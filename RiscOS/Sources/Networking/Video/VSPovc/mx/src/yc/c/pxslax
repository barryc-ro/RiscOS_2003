/* mx/src/yc/pxslax.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/

#ifdef RCSID
static char *RCSid  =
"$Header$";
#endif


 

#define PXLOOKST 4
#define PXFLAG -32768
#define TOKCVT(tok) mach->pxtmap_[pxtgid(tok)]       


#ifndef SYSX_ORACLE
#include <sysx.h>
#endif
#ifndef SYSI_ORACLE
#include <sysi.h>
#endif

typedef unsigned char *PXVALTYPE;

#include <pxslax.h>
#include <pxtokn.h>

#define pxacof (mach->pxacof_)
#define pxstat (mach->pxstat_)
#define pxacts (mach->pxacts_)
#define pxlhsn (mach->pxlhsn_)
#define pxrhsc (mach->pxrhsc_)
#define pxdefs (mach->pxdefs_)
#define pxgoff (mach->pxgoff_)
#define pxgfrm (mach->pxgfrm_)
#define pxgto  (mach->pxgto_)
#define pxsubs (mach->pxsubs_)
#define pxeoff (mach->pxeoff_)
#define pxsytk (mach->pxsytk_)
#define pxcorl (mach->pxcorl_)
#define pxtoid (mach->pxtoid_)
#define pxgram (mach->pxgram_)
#define pxlex  (mach->pxlex_)
#define pxacti (mach->pxacti_)
#define pxroff (mach->pxroff_)
#define pxred (mach->pxred_)
#define pxredc (*mach->pxredc_)
#define pxkywd (*mach->pxkywd_)
#define pxdbtm (mach->pxdbtm_)
#define pxdbpd (mach->pxdbpd_)
#define pxtkno (mach->pxtkno_)
#define pxextk (mach->pxextk_)

#define PXGETTOK (*mach->pxgett)


#define FATALERR 1
#define FATNORECOVER 2
#define STACKOVFLW 6
#define TABETC 101
#define TABSTR 102
#define ENCOUNTER 103
#define EXPECTING 104
#define INSERTED 105
#define REPLACING 106
#define QUOTE 107
#define IGNORED1 108
#define PRESENT 109
#define SYMBOL 110
#define IGNORED2 111
#define SUBST 112
#define RESUMING 113
#define ETC 114
#define NL_SPACE 115
#define STRING 116
#define QUOTSTRING 117
#define NL 118
#define UNSUP 119




sb2 pxnmstt(mach)
     pxnmach *mach;
{
  return mach->status;
}



static void pxnfcopy(mach, copymach)
      pxnmach *mach;
      pxnmach *copymach;
{

  
  memcpy((void *)copymach, (void *)mach,
		 mach->mnssize + (mach->partop + 1) * mach->frmsize );
  copymach->status = PXMNORMAL;
}



void pxnspus(
      pxnmach    *mach,
      sb2         state,
      sb2         symbol,
      PXVALTYPE  *val,
      sb2         line,
      sb2         col,
      char       *nam)
{
  sb2 top;
  pxstk *frame;

  if ((top = ++mach->partop) >= PXMAXDEPTH)
    {
      mach->status = PXOVERFL;
      return;
    }
  if (mach->ngrams > 1)
    {
      sb2 index = pxgram[state];
      mach->pxgett  = pxlex[index];
    }
  frame = &(mach->parse[top]);
  frame->state = state;
  frame->symbol = symbol;
  frame->srclin = line;
  frame->srccol = col;
  frame->srcnam = nam;

  if (val)
    memcpy((void *)&(frame->val),  (void *)val, mach->valsize);
}




static int pxnolk(mach, retact)
     pxnmach *mach;                                           
     pxacdf *retact;                 
{
  sb2 state = mach->parse[mach->partop].state;
  sb2 prdno = mach->pxdfact_[state];

  if (mach->pxpact_[state] == PXFLAG && 
      prdno != 0)
    {
      
      if (pxlhsn[prdno] == mach->accept)
	{
	  mach->status = PXMACCEPT;
	  retact->type = PXACCEPT;
	  return TRUE;
	}
      retact->type   = PXREDUCE;
      retact->action = (ub2)prdno;
      return TRUE;
    }
  return FALSE;
}


static void pxnact(mach, state, look, retact)
      pxnmach *mach;                                    
      ub2     state;                                    
      sb2     look;                                  
      pxacdf *retact;                 
{
  sb2  index;
  sb2  prdno;
  sb2  action;

  index = mach->pxpact_[state] + look;

  if (index < 0 || ((ub2)index > mach->pxtablen) || mach->pxchek_[index] != look)
    {
      
      prdno = mach->pxdfact_[state];
      if (prdno > 0)                                      
	{
	  retact->type   = PXREDUCE;
	  retact->action = (ub2)prdno;
	}
      else                                                   
	{
	  retact->type   = PXERROR;      
	}
    }
  else                        
    {
      action = mach->pxatabl_[index];
      if (action > 0)                                               
	{
	  retact->type   = PXSHIFT;
	  retact->action = (ub2)action;
	}
      else                                                         
	{
	  retact->type   = PXREDUCE;
	  retact->action = (ub2)-action;
	}
    }
}


sb2 pxngoto(
      pxnmach *mach,
      ub2     state,                                    
      ub2     nonterm)                  
{

   ub2 index = mach->pxpgoto_[nonterm] + state;
  if (index <= mach->pxtablen && ((ub2)mach->pxchek_[index] == state))
    return mach->pxatabl_[index];
  else
    return mach->pxdfgoto_[nonterm];
}


static void pxnfkrd(mach, prod)
      pxnmach *mach;                  
      ub2     prod;                           
{
   ub2 lrcnt;
   ub2 top;

  
  lrcnt = (ub2)mach->pxrhsc_[prod];
  if ((ub2)mach->partop < lrcnt)
    mach->status = PXMERROR;
  if (mach->status != PXMNORMAL)
    return;

  
  mach->partop -= (sb2)lrcnt;
  top = (ub2)mach->partop;
  pxnspus(mach,
	  pxngoto(mach, (ub2)mach->parse[top].state, (ub2)mach->pxlhsn_[prod]),
	  (sb2) mach->pxlhsn_[prod],
	  (PXVALTYPE *) 0,
	  0, 0, (char *)0);
}

#ifdef PXDEBUG

static char *pxlktm(mach, token)
      pxnmach *mach;
      sb2      token;
{
  return pxdbtm[mach->pxtmap_[token]];
}

static void pxdbug(mach, action, token)
      pxnmach *mach;
      pxacdf *action;
      sb2      token;
{
  switch (action->type)
    {
    case PXREDUCE:
      printf("  Reduce %s, enter state %d\n",
		     pxdbpd[action->action],
		     pxngoto(mach,  
			    (ub2)
			     mach->parse[mach->partop -
					 mach->pxrhsc_[action->action]].state,
			     mach->pxlhsn_[action->action]));
      break;
    case PXSHIFT:
      printf("  SHIFT token %s, enter state %d\n",
		     pxlktm(mach, token), action->action);
      break;
    case PXACCEPT:
      printf("  SLAX accepts.\n");
      break;
    case PXERROR:
      printf("  SLAX detects possible syntax error.\n");
      break;
    default:
      printf("  SLAX detects fatal error.\n");
      break;						     
    }
}
#endif




static ub2 pxnfake(mach, nexttok)
       pxnmach *mach;                  
       sb2       nexttok;               
{
   pxacdf     *action;
  mach->pxnumacts = 0;

  while (TRUE)
    {
      
      action = &(mach->pxacstk[mach->pxnumacts++]);
      pxnact(mach, (ub2)mach->parse[mach->partop].state,
	     nexttok, action);
#ifdef PXDEBUG
      if (mach->debug)
	pxdbug(mach, action, pxtkno[nexttok]);
#endif

      switch (action->type)
	{
	case PXACCEPT:
	  return PXMACCEPT;
	case PXREDUCE:
	  pxnfkrd(mach, action->action);
	  if (mach->status == PXMERROR || mach->status == PXFATAL ||
	      mach->status == PXOVERFL)
	    return mach->status;
	  continue;
	case PXSHIFT:
	  return PXMNORMAL;
	case PXERROR:
	  return PXMERROR;
	default:
	  return PXFATAL;
	}
    }
}



static int pxnextm(inmach, terms)
      pxnmach *inmach;                                     
      ub4     *terms;                        
{
   sb2     i;
   sb2     nterms = inmach->pxterms;
   int   found = FALSE;
       pxnmach  copymach;
   pxnmach *mach = &copymach;
  
  for (i = 0; (ub2)i < inmach->pxtklen; i++)
    terms[i] = 0;

  
  for (i = 2; i <= nterms; i++)
    {
      
      pxnfcopy(inmach, mach);

      
      mach->debug = FALSE;
      if (pxnfake(mach, i) == PXMERROR)
	continue;
      SETBIT(terms, i);
      found = TRUE;
    }
  return found;
}


pxnmach *pxnmove(
      pxnmach *inmach,                           
      pxtokn *tok,                                      
      void *   cs,                                      
      char   *stat)
{

   sb2         nexttok;
   PXVALTYPE *lrtok = (PXVALTYPE *)pxtatt(tok);
       pxnmach    tmpmach;           
   pxnmach   *mach = &tmpmach;
   pxnmach   *stkmach;                      
   ub2         ctr;

  
  pxnfcopy(inmach, mach);

#ifdef PXDEBUG
  if (mach->debug)
    printf("Lookahead token is %s.\n", pxlktm(mach, pxtgid(tok)));
#endif

  
  if (pxnfake(mach, TOKCVT(tok)) != PXMNORMAL)
    {
      
      if (pxkywd(cs, pxtgid(tok), tok))
	{
	  
	  pxnfcopy(inmach, mach);
	  pxtgid(tok) = pxtoid;
#ifdef PXDEBUG
	      if (mach->debug)
		{
		  printf("  Keyword detected, restoring machine: \
state now %d.\n",
			       mach->parse[mach->partop].state);
		  printf("  New token is %s.\n",
				 pxlktm(mach, pxtgid(tok)));
	        }
#endif
	  if (pxnfake(mach, TOKCVT(tok)) == PXMNORMAL)
	    goto success;
	}
      
      
      if (mach->ngrams > 1)
	{
	  sb2 origstate = inmach->parse[inmach->partop].state;
	  sb2 newstate  = mach->parse[mach->partop].state;
	  if (pxgram[origstate] != pxgram[newstate])
	    {
#ifdef PXDEBUG
	      if (mach->debug)
		printf("  Grammar switch: Pushing token %s.\n",
			       pxlktm(mach, pxtgid(tok)));
#endif
	      PXGETTOK(cs, PXUNGET, tok);
	      
	      
	      pxnfcopy(inmach, mach);
	      mach->pxgett = pxlex[pxgram[newstate]];
	      
	      tok = PXGETTOK(cs, PXGETNEXT);
#ifdef PXDEBUG
	      if (mach->debug)
		{
		  printf("  Restoring machine: state now %d.\n",
				 mach->parse[mach->partop].state);
		  printf("  New token is %s.\n",
				 pxlktm(mach, pxtgid(tok)));
		}
#endif
	      if (pxnfake(mach, TOKCVT(tok)) == PXMNORMAL)
		goto success;
	    }
	}
		 
      
      inmach->status = PXMERROR;
      return inmach;
    }

	 

success:

  
  stkmach = mach;
  mach = inmach;                           
  nexttok = pxtgid(tok);
  ctr = 0;
  while (ctr < stkmach->pxnumacts)
    {
      pxacdf *action = &(stkmach->pxacstk[ctr++]);
      switch (action->type)
	{
	case PXACCEPT:
	  mach->status = PXMACCEPT;
	  return mach;
	case PXREDUCE:
	  if (!mach->fnderr)
	    {
	      
	      if (mach->ngrams > 1)
		{
		  const sb2  *_pxlhsn = pxlhsn;
		  mach->pxredc_ =
		    pxred[mach->pxntgr_[_pxlhsn[action->action]]];
		}
	      pxredc(mach, action->action, cs);
	    }
	  else
	    pxnfkrd(mach, action->action);
	  
	  if (mach->status == PXMERROR || mach->status == PXFATAL ||
	      mach->status == PXOVERFL)
	    {
	      mach->status = PXFATAL;
	      return mach;
	    }
	  continue;
	case PXSHIFT:
	  pxnspus(mach, (sb2)action->action, nexttok, lrtok, 
		 (sb2)pxtlin(tok), (sb2)pxtcol(tok), pxtfil(tok));

	  

	  while (pxnolk(mach, action) == TRUE)
	    {
#ifdef PXDEBUG
	      if (mach->debug)
		pxdbug(mach, action, nexttok);
#endif
	      if (mach->status == PXMACCEPT)
		return mach;
		
	      if (!mach->fnderr)
		{
		  
		  if (mach->ngrams > 1)
		    {
		      const sb2   *_pxlhsn = pxlhsn;
		      mach->pxredc_ =
			pxred[mach->pxntgr_[_pxlhsn[action->action]]];
		    }
		  pxredc(mach, action->action, cs);
		}
	      else
		pxnfkrd(mach, action->action);

	      if (mach->status == PXMERROR || mach->status == PXFATAL ||
		  mach->status == PXOVERFL)
		{
		  mach->status = PXFATAL;
		  return mach;
		}
	    }
	  return mach;
	case PXERROR:
         

	default:
	  mach->status = PXFATAL;
	  return mach;
	}
    }
  return (pxnmach*)0;	
}


static int pxspop(mach)
      pxnmach *mach;
{
  sb2 top;
  if ((top = --mach->partop) <= -1)
    return FALSE;

  if (mach->ngrams > 1)
    {
       sb2 index = pxgram[top];
      mach->pxgett  = pxlex[index];
      mach->pxredc_ = pxred[index];
    }

  return TRUE;
}



static int pxwnp(inmach, cs, token)
          pxnmach *inmach;
      void *   cs;
      pxtokn *token;  
{

  pxtokn *tkstack[PXLOOKST + 1];
  pxnmach  copymach;
      pxnmach *mach = &copymach;
  sb2 stackctr = 0;
  ub2 status; 

  pxnfcopy(inmach, mach);
  tkstack[0] = token;
  while (TRUE)
    {
      status = pxnfake(mach, TOKCVT(tkstack[stackctr]));

      if (status == PXMERROR)
	{
	  while (stackctr > 0)
	    PXGETTOK(cs, PXUNGET, tkstack[stackctr--]);
	  return FALSE;
	}
      pxnmove(mach, tkstack[stackctr], cs, (char *) 0);

      
      if ((stackctr == PXLOOKST) || (mach->status == PXMACCEPT))     
	break;

      stackctr++;
      tkstack[stackctr] = PXGETTOK(cs, PXGETNEXT);
    }

  
  while (stackctr > 0)                    
    PXGETTOK(cs, PXUNGET, tkstack[stackctr--]);    
  return TRUE;
}


int pxnrcov(
      pxnmach *mach,
      pxtokn *tok,
      void *   cs,
      char *retbuf)     
{

  
  pxtokn *token;
  pxtokn *token0;
  pxtokn  dummytk;
  sb2 i;
  char  errbuf[PXMAXERRLEN];
  size_t  linelen;

  int tmfound = pxnextm(mach, pxextk);

   sprintf((char *)errbuf, "Encountered the symbol \"%s\" ",
		  pxtnam(tok));

  linelen = strlen(errbuf);
  
  if (tmfound)
    {
      int needs_nl = TRUE;  

      
       strcat(errbuf, "when expecting one of the following:\n");
      linelen = strlen(errbuf);
      
      for (i = 1; i <= mach->pxterms; i++)
	{
	  if (BIT(pxextk, i))
	    {
	      char *tstr = pxtmmp(i);
	      
	      
	      if (linelen + strlen(tstr) > 60)
		{
		   strcat(errbuf, "\n   ");
		   strcat(errbuf, tstr);
		  linelen = strlen(tstr);
		}
	      else                
		{
		  char locbuf[80];
		   sprintf(locbuf, " %s", tstr);
		   strcat(errbuf, locbuf);
		  linelen += strlen(locbuf);
		}
	      
	      
	      if (strlen(errbuf) > (size_t)(PXMAXERRLEN - 80))
		{
		  
		   strcat(errbuf, " etc.\n");
		  needs_nl = FALSE;
		  break;
		}
	    }
	}

      
      if (needs_nl == TRUE)
	 strcat(errbuf, "\n");
    }

  

  
   PXGETTOK(cs, PXUNGET, tok);

#ifdef PXDEBUG
  if (mach->debug)
     printf("\t\tEntering error recovery.\n\t\tTrying insert token.\n");
#endif


  
  for (i = 1; i <= mach->pxterms; i++)
    if (BIT(pxextk, i))
      {
	pxtcrt(pxtkno[i], (char *)"", 0, 0, (char *)"", (PXVALTYPE *) 0,
	       &dummytk);
	if (pxwnp(mach, cs, &dummytk) == TRUE)
	  {
	    mach->status = PXMNORMAL;
	     pxnmove(mach, &dummytk, cs, (char *)0);
#ifdef PXDEBUG
	    if (mach->debug)
	       printf("\t\tSuccess. Inserted token %s.\n",pxdbtm[i]);
#endif
	     strcat(errbuf, "The symbol \"");
	     strcat(errbuf, pxtmmp(i));
	    
	    {
	      char locbuf[80];
	       sprintf(locbuf,
			      "\" was substituted for \"%s\" to continue.\n",
			      pxtnam(tok));
	       strcat(errbuf, locbuf);
	    }
	    goto bye;
	  }
#ifdef PXDEBUG
	else
	  if (mach->debug)
	     printf("  **Insert token attempt failed.\n");
#endif
      }


  

#ifdef PXDEBUG
  if (mach->debug)
     printf("\t\tTrying insert state.\n");
#endif

  
  token = PXGETTOK(cs, PXGETNEXT);

  for (i = 0; i < mach->pxnonts; i++)
    {
      sb2 dest = pxngoto(mach, (ub2)mach->parse[mach->partop].state, (ub2)i);
      if (dest != -1)                                  
	{
	  pxnspus(mach, dest, i, (PXVALTYPE *) 0, 0, 0, (char *)0 );
	  if (pxwnp(mach, cs, token) == TRUE)
	    {
	      pxnmove(mach, token, cs, (char *)0);

#ifdef PXDEBUG
	      if (mach->debug)
		printf("\t\tSuccess.\n");
#endif
	      mach->status = PXMNORMAL;
	      goto bye;
	    }	  
	  else
	    {
	       pxspop(mach);         
#ifdef PXDEBUG
	      if (mach->debug)
		 printf("  **Insert state attempt failed.\n");
#endif	      
	    }
	}
    }

  

#ifdef PXDEBUG
  if (mach->debug)
     printf("\t\tTrying delete token.\n");
#endif

  
  token0 = token;
  token = PXGETTOK(cs, PXGETNEXT);  
  
  if (pxwnp(mach, cs, token) == TRUE)
    {
       pxnmove(mach, token, cs, (char *)0 );
#ifdef PXDEBUG
      if (mach->debug)
	 printf("\t\tSuccess.\n");
#endif
       strcat(errbuf, "The symbol \"");
       strcat(errbuf, pxtnam(token0));
       strcat(errbuf, "\" was ignored.\n");
      goto bye;
    }
#ifdef PXDEBUG
  else
    if (mach->debug)
       printf("  **Delete token attempt failed.\n");
#endif

   PXGETTOK(cs, PXUNGET, token);
  token = token0;

  
  
#ifdef PXDEBUG
  if (mach->debug)
     printf("\t\tTrying replace token.\n");
#endif

  
  for (i = 1; i <= mach->pxterms; i++)
    if (BIT(pxextk, i))
      {
	pxtcrt(pxtkno[i], (char *)"", 0, 0, (char *)"", (PXVALTYPE *) 0,
	       &dummytk);
	if (pxwnp(mach, cs, &dummytk) == TRUE)
	  {
	    mach->status = PXMNORMAL;
	    pxnmove(mach, &dummytk, cs, (char *)0 );

#ifdef PXDEBUG
	    if (mach->debug)
	      printf("\t\tSuccess. Replaced with %s.\n", pxdbtm[i]);
#endif

	     strcat(errbuf, "The symbol \"");
	     strcat(errbuf, pxtmmp(i));
	    {
	      char locbuf[80];
	       sprintf(locbuf,
			      " was inserted before \"%s\" to continue.\n",
			      pxtnam(tok));
	       strcat(errbuf, locbuf);
	    }

	    goto bye;
	  }
#ifdef PXDEBUG
	else
	  if (mach->debug)
	     printf("  **Replace token attempt failed.\n");
#endif

      }

  
  
#ifdef PXDEBUG
  if (mach->debug)
     printf("\t\tTrying delete state, insert token.\n");
#endif

   PXGETTOK(cs, PXUNGET, token);

  if (pxspop(mach) == TRUE)
    {
       pxnextm(mach, pxextk);
      
      for (i = 1; i <= mach->pxterms; i++)
	if (BIT(pxextk, i))
	  {
	    pxtcrt(pxtkno[i], (char *)"", 0, 0, (char *)"", (PXVALTYPE *) 0,
		   &dummytk);
	    if (pxwnp(mach, cs, &dummytk) == TRUE)
	      {
		mach->status = PXMNORMAL;
		pxnmove(mach, &dummytk, cs, (char *)0);
#ifdef PXDEBUG
		if (mach->debug)
		   printf("\t\tSuccess. Inserted token %s.\n",pxdbtm[i]);
#endif
		goto bye;
	      }
#ifdef PXDEBUG
	    else
	      if (mach->debug)
		 printf("  *Delete/insert attempt failed.\n");
#endif

	  }
    }

  
  
#ifdef PXDEBUG
  if (mach->debug)
     printf("\t\tError recovery failed.\n");
#endif
  mach->status = PXFATAL;

bye:
   PXGETTOK(cs, PXERRORMSG, tok);
  if (retbuf)
     strcpy(retbuf, errbuf);

  if (mach->status == PXFATAL)
    return FALSE;

  return TRUE;

}
