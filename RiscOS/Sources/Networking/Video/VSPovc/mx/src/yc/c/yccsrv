/* mx/src/yc/yccsrv.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/


#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCC0_ORACLE
#include <ycc0.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif

STATICF void yccGenIntfSrv( ycctx* ctx, yccfp* fp, yrobj* inf);
STATICF void yccGenSrvFunc( ycctx* ctx, yccfp* fp, yrobj* intf,
                            yrobj* rettype, CONST char* name, 
                            CONST char* implName, yslst* pars, yslst* ctxs);
STATICF void yccGenOpSrv( ycctx* ctx, yccfp* fp, yrobj* op, yrobj* intf);
STATICF void yccGenAttrSrv( ycctx* ctx, yccfp* fp, yrobj* attr, yrobj* intf);
STATICF void yccGenTypeCast( ycctx* ctx, yccfp* fp, yrobj* type, sword mode);
STATICF void yccGenCGSrvObjs( ycctx* ctx, yccfp* fp, yslst* objs);

void yccsrv(ycctx* ctx, char* base, ycfile* fd)
{
  yccfp *fp;
  CONST char* errtxt;

  
  fp = yccfpOpen(fd->newtmp, "w", SYSFPKIND_NONE, &errtxt, 
                 yccGetLineLimit(ctx));
  if ( !fp )
  {
    ysRecord( YCMSG(1), YCERRSEV, YSLSTR(fd->target), YSLSTR(errtxt), YSLEND);
    return;
  }

    
  yccfpPrint( fp, "/* GENERATED FILE\n * %s - server stubs\n", base);
  yccfpPrint( fp, " * from %s\n */\n\n", ctx->srcnm);
  yccGenSysIncls( ctx, fp, TRUE);
  yccfpPrint( fp, "#ifndef YOCOA_ORACLE\n#include <yocoa.h>\n#endif\n");

    
  {
    char* dummy = (char*) ysmGlbAlloc( strlen(base) + 2, "basename");
    char  clientStubs[SYSFP_MAX_PATHLEN];
    ub4 len;

    len = strlen(base);
    DISCARD strcpy( dummy, base);
    dummy[len] = 'C';
    dummy[len+1] = '\0';
    sysfpForm( clientStubs, (char*)0, dummy, SYSFPKIND_CSOURCE);
    yccfpPrint( fp, "#include <%s>\n\n", clientStubs);
    ysmGlbFree( (dvoid*)dummy);
  }
  yccfpPrint( fp, "EXTC_START\n\n");

    
  yccfpSetIndent( fp, 0);
  yccGenCGSrvObjs( ctx, fp, ctx->newobjs);

  yccfpPrint( fp, "\nEXTC_END\n");
  yccfpClose(fp);
}





STATICF void yccGenCGSrvObjs( ycctx* ctx, yccfp* fp, yslst* objs)
{
  ysle* le;

  if ( objs )
  {
    for ( le = ysLstHead(objs); le; le = ysLstNext(le))
    {
      ycgobj* cgobj = (ycgobj*) ysLstVal(le);

      if ( yrGetKind( cgobj->ifrobj) == yrdkModule )
        yccGenCGSrvObjs( ctx, fp, cgobj->objlist);
      else if ( !ycShouldGenCode(ctx, cgobj->ifrobj) )
        continue;	
      else if ( (yrGetKind(cgobj->ifrobj) == yrdkInterface) &&
           !(cgobj->flags & YCG_FWD) )
	yccGenIntfSrv( ctx, fp, cgobj->ifrobj);
    }
  }
}





STATICF void yccGenIntfSrv( ycctx* ctx, yccfp* fp, yrobj* inf)
{
  ysle* le;
  yslst* all;
  ub4 cnt = (ub4)0;
  CONST char* intfName;	     
  CONST char* absName;	     
  CONST char* voidstr;
  boolean hasOps;            
  ycsym* syminfo;
  yrintf* idata;
  boolean localOnly = FALSE; 

  if ( ycIsCorbaObject( ctx, inf) ||  
       !yrGetContents(inf) )             
    return;

  voidstr = YCCVOID(ctx);
  intfName = yrGetAbsoluteName( inf);
  yccfpPrint( fp, "/* Server stubs for interface %s */\n", intfName);
  ysmGlbFree(  (dvoid*)intfName);
  syminfo = ycSymLookup( ctx->symtbl, inf);
  all = (syminfo ? syminfo->opsNattrs : (yslst*)0);
  hasOps = !ycIsEmptyLst(all);
  intfName = yccGetAbsoluteName( ctx, inf, (yrobj*)0);
  idata = &yrInterfaceData(inf);

    
  if ( hasOps )
  {
    ub4 locals = (ub4)0;

      
    for (cnt = 0, le = ysLstHead(all); le; le = ysLstNext(le), cnt++)
    {
      yrobj* obj = (yrobj*) ysLstVal(le);

      if ( yrGetKind(obj) == yrdkOperation )
        yccGenOpSrv( ctx, fp, obj, inf);
      else
      {
        yccGenAttrSrv( ctx, fp, obj, inf);
        if ( (yrGetKind(obj) == yrdkAttribute) && 
             (yrAttrData(obj).mode != YR_ATTR_RO) )
          cnt++;      
      }
      if ( yrGetDefinedIn(obj) == inf )
        locals++;     
    }
    localOnly = (ysLstCount(all) == locals);     

    
    if ( !localOnly )
    {
      yrobj* base = (yrobj*)0;
      ub4 offset;

      yccfpPrint(fp,"%syogfp %s__widen( ub4 _idx, %s*_data, %sysid* _id);\n\n",
                  YCCSTATIC(ctx), intfName, voidstr, YCCCONST(ctx));
      yccfpPrint(fp,"%syogfp %s__widen( ub4 _idx, %s*_data, %sysid* _id)\n{\n",
                  YCCSTATIC(ctx), intfName, voidstr, YCCCONST(ctx));
      yccfpIncIndent( fp);
      yccfpPrint( fp, "yogfp* _fps = (yogfp*)_data;\n\n");
      for ( le = ysLstHead(all), offset = 0; le; le = ysLstNext(le), offset++)
      {
        yrobj* mem = (yrobj*)ysLstVal(le);
        if ( base != yrGetDefinedIn(mem) )
        {
          CONST char* bname;
          ycsym* bsym;

          base = yrGetDefinedIn(mem);
          bsym = ycSymLookup(ctx->symtbl, base);

          if ( bsym && bsym->opsNattrs && 
               (ysLstCount(bsym->opsNattrs) > 0) )
          {                 
            bname = yccGetAbsoluteName(ctx, base, (yrobj*)0);
            yccfpPrint( fp, "if ( ysidEq( %s__id, _id) )\n", bname);
            if ( offset == 0 )
              yccfpPrint( fp, "{\n}\n");
            else
            {
              yccfpIncIndent(fp);
              yccfpPrint( fp, "_fps += %d;\n", offset);
              yccfpDecIndent(fp);
            }
            yccfpPrint( fp, "else ");
          }
        }
        if ( (yrGetKind(mem) == yrdkAttribute) && 
             (yrAttrData(mem).mode != YR_ATTR_RO) )
          offset++;      
      }
      yccfpPrint( fp, "\n");
      yccfpIncIndent( fp);
      yccfpPrint( fp, "yseThrow(YS_EX_BADPARAM);\n");   
      yccfpDecIndent( fp);
      yccfpPrint( fp, "return _fps[_idx];\n");
      yccfpDecIndent( fp);
      yccfpPrint( fp, "}\n\n");
    }
  }

    

    
  if ( !ycIsEmptyLst(idata->bases) )
  {
    yslst* ancestors;

    ancestors = ysLstCreate();
    yrGetAncestors( inf, ancestors);
    yccfpPrint( fp, "static const char* const %s__bases[] =\n{\n", intfName);
    yccfpIncIndent(fp);
    for (le = ysLstHead(ancestors); le; le = ysLstNext(le))
      yccfpPrint( fp, "\"%s\",\n", yrGetRepId((yrobj*)ysLstVal(le)));
    yccfpPrint( fp, "(char*)0\n");
    yccfpDecIndent(fp);
    yccfpPrint( fp, "};\n\n");
    ysLstDestroy(ancestors, (ysmff)0);
  }

    
  yccfpPrint( fp, "yostub* %s__getStubs(void)\n{\n", intfName);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "yostub* _result;\n");
  yccfpPrint( fp, "yostbb* _stubs;\n\n");
  yccfpPrint( fp, "_result = (yostub*) ysmGlbAlloc( sizeof(yostub)+");
  yccfpPrint( fp, "(sizeof(yostbb)*%u), \"yostubs\");\n", cnt);
  if ( hasOps && !localOnly )
    yccfpPrint( fp, "_result->widen = (yowiden)%s__widen;\n", intfName);
  else
    yccfpPrint( fp, "_result->widen = (yowiden)0;\n");
  if ( ycIsEmptyLst(idata->bases) )
    yccfpPrint( fp, "_result->bases = (const char**)0;\n");
  else
    yccfpPrint( fp, "_result->bases = %s__bases;\n", intfName);
  yccfpPrint( fp, "_stubs = &(_result->stuba[0]);\n\n");

    
  if ( cnt > 0 )
  {
    for (cnt = 0, le = ysLstHead(all); le; cnt++, le = ysLstNext(le))
    {
      yrobj* obj = (yrobj*) ysLstVal(le);
      CONST char* objname = yrGetName(obj);

      if ( yrGetKind(obj) == yrdkOperation )
      {
        absName = yccGetAbsoluteName( ctx, obj, inf);
        yccfpPrint( fp, "_stubs[%u].opernm = \"%s\";\n", cnt, objname);
        yccfpPrint( fp, "_stubs[%u].parms = %s_pars;\n", cnt, absName);
        yccfpPrint( fp, "_stubs[%u].oper = %s_s;\n", cnt, absName);
        if ( inf != yrGetDefinedIn(obj) )
	  ysmGlbFree( (dvoid*) absName);
      }
      else if ( yrGetKind(obj) == yrdkAttribute )
      {
        yccfpPrint( fp, "_stubs[%u].opernm = \"_get_%s\";\n", cnt, objname);
        yccfpPrint( fp, "_stubs[%u].parms = %s__get_%s_pars;\n", 
                    cnt, intfName, objname);
        yccfpPrint( fp, "_stubs[%u].oper = %s__get_%s_s;\n", 
                    cnt, intfName, objname);
        if ( yrAttrData(obj).mode != YR_ATTR_RO )
        {
          cnt++;
          yccfpPrint( fp, "_stubs[%u].opernm = \"_set_%s\";\n", cnt, objname);
          yccfpPrint( fp, "_stubs[%u].parms = %s__set_%s_pars;\n", 
                      cnt, intfName, objname);
          yccfpPrint( fp, "_stubs[%u].oper = %s__set_%s_s;\n", 
                      cnt, intfName, objname);
        }
      }
    }
  }
    
  yccfpPrint( fp, "_stubs[%u].opernm = (%schar*)0;\n", cnt, YCCCONST(ctx));
  yccfpPrint( fp, "_stubs[%u].parms = (yopar*)0;\n", cnt);
  yccfpPrint( fp, "_stubs[%u].oper = (void (*)(%s*,yoenv*,%s*,%s**))0;\n",
              cnt, voidstr, voidstr, voidstr);
  yccfpPrint( fp, "\nreturn _result;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");
}




STATICF void yccGenSrvFunc( ycctx* ctx, yccfp* fp, yrobj* intf,
                            yrobj* rettype, CONST char* name, 
                            CONST char* implName, yslst* pars, yslst* ctxs)
{
  ysle* le;
  CONST char* intfName;
  CONST char* voidstr = YCCVOID(ctx);
  boolean isVoidReturn = !rettype || ((yrGetKind(rettype) == yrdkPrimitive) &&
				(yrPrimData(rettype).kind == yrpkvoid));
  CONST char* kwdpfx = ((*ctx->lang->kwdchk)( ctx, implName) ? "_" : "");
  sword i = 0;		

    
  yccfpPrint( fp,"%svoid %s_s", YCCSTATIC(ctx), name);
  yccfpPrint( fp,"( %s* or, yoenv* ev, %s* impldef, %s** args);\n\n",
              voidstr, voidstr, voidstr);

    
  yccfpPrint( fp,"%svoid %s_s", YCCSTATIC(ctx), name);
  yccfpPrint( fp,"( %s* or, yoenv* ev, %s* impldef, %s** args",
              voidstr, voidstr, voidstr);
  if ( ycStyleOra(ctx) && isVoidReturn && ycIsEmptyLst(pars) )
    yccfpPrint( fp, " /* ARGUSED */");
  yccfpPrint( fp,")\n{\n");
  yccfpIncIndent( fp);

  if ( ctx->objAdaptor == YCOA_BOA )                
  {
    yccfpPrint( fp, "CORBA_Environment cev;\n\n");
    yccfpPrint( fp, "ORA_CORBA_BuildEnv( &cev, ev, %s_pars);\n", name);
  }                                                 

  if ( !isVoidReturn )
  {
    yccGenTypeCast( ctx, fp, rettype, YOMODE_RETURN);
    yccfpPrint( fp, "args[0] = ");
    i++;
  }
  intfName = yccGetAbsoluteName( ctx, intf, (yrobj*)0);
  yccfpPrint( fp, "(*((struct %s__tyimpl*)impldef)->%s%s)( (%s)or", 
              intfName, kwdpfx, implName, intfName);
  if ( ycCORBA1_2(ctx) )
    yccfpPrint( fp, ", %s", (ctx->objAdaptor == YCOA_BOA) ? "&cev" : "ev");
  if ( pars )
  {
    for ( le = ysLstHead(pars); le; le = ysLstNext(le))
    {
      yrpar* par = (yrpar*) ysLstVal(le);

      yccfpPrint( fp, ",");
      yccGenTypeCast( ctx, fp, par->type, par->mode);
      yccfpPrint( fp, "args[%d]", i++);
    }
  }

  if ( !ycCORBA1_2(ctx) )
  {
    if ( !ycIsEmptyLst(ctxs) )
      yccfpPrint( fp, ", (CORBA_Context)args[%d]", i++);
    yccfpPrint( fp, ", %s);\n", (ctx->objAdaptor == YCOA_BOA) ? "&cev" : "ev");
  }
  else
    yccfpPrint( fp, ");\n");

  if ( ctx->objAdaptor == YCOA_BOA )                
  {
    yccfpPrint( fp, "if ( cev._major != CORBA_NO_EXCEPTION )\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "ORA_CORBA_ExceptionToYo( &cev);\n");
    yccfpDecIndent( fp);
  }                                                 
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");
}





STATICF void yccGenOpSrv( ycctx* ctx, yccfp* fp, yrobj* op, yrobj* intf)
{
  CONST char* name = yccGetAbsoluteName( ctx, op, intf);

  yccGenSrvFunc( ctx, fp, intf, yrOpData(op).rettype, name, yrGetName(op), 
                 yrOpData(op).pars, yrOpData(op).ctxts);
  if ( intf != yrGetDefinedIn(op) )
    ysmGlbFree( (dvoid*)name);
}





STATICF void yccGenAttrSrv( ycctx* ctx, yccfp* fp, yrobj* attr, yrobj* intf)
{
  CONST char* base = yccGetAbsoluteName( ctx, intf, (yrobj*)0);
  char* attrName = yrGetName(attr);
  char* name = 
	(char*) ysmGlbAlloc( strlen(base) + strlen(attrName) + 7, "attrName");
		

    
  DISCARD ysFmtStr( name, "%s__get_%s", base, attrName);
  yccGenSrvFunc( ctx, fp, intf, yrAttrData(attr).type,
			name, name + strlen(base) + 1, (yslst*)0, (yslst*)0);

    
  if ( yrAttrData(attr).mode != YR_ATTR_RO )
  {
    yslst* pars = ysLstCreate();
    yrpar param;

    DISCARD ysFmtStr( name, "%s__set_%s", base, attrName);
    param.type = yrAttrData(attr).type;
    param.mode = YOMODE_IN;
    DISCARD ysLstEnq( pars, (dvoid*) &param);

    yccGenSrvFunc( ctx, fp, intf, (yrobj*) 0,
			name, name + strlen(base) + 1, pars, (yslst*)0);
    ysLstDestroy( pars, (ysmff)0);
  }

  ysmGlbFree(  (dvoid*)name);
}





STATICF void yccGenTypeCast( ycctx* ctx, yccfp* fp, yrobj* type, sword mode)
{
  boolean needDeref = FALSE;
  boolean stop = FALSE;
  yrobj* base = type;
  sword origMode = mode;

  while ( !stop )
  {
    stop = TRUE;
    switch (yrGetKind(base))
    {
      case yrdkInterface:
      case yrdkEnum:
	if ( (mode == YOMODE_IN) || (mode == YOMODE_RETURN) )
	{
	  needDeref = TRUE;
	  mode = YOMODE_OUT;
	}
	break;
      case yrdkUnion:
      case yrdkStruct:
      case yrdkSequence:
	if ( mode == YOMODE_RETURN )
	{
	   needDeref = TRUE;
	   mode = YOMODE_OUT;
	}
	break;
      case yrdkString:
        if ( (mode == YOMODE_IN) || (mode == YOMODE_RETURN) )
        {
           needDeref = TRUE;
           mode = YOMODE_OUT;
        }
        break;
      case yrdkArray:
        mode = YOMODE_RETURN;	
	break;
      case yrdkAlias:
	stop = FALSE;
	base = yrAliasData(base).type;
	break;
      case yrdkPrimitive:
        if ( yrPrimData(type).kind == yrpkany )
        {
          if ( mode == YOMODE_RETURN )
          {
            needDeref = TRUE;
            mode = YOMODE_OUT;
          }
          break;
        }
        else if ( (mode == YOMODE_IN) || (mode == YOMODE_RETURN) )
        {
           needDeref = TRUE;
           mode = YOMODE_OUT;
        }
	break;
      default:
	yseThrow(YS_EX_FAILURE);
	break;
    }
  }

  if ( needDeref )
    yccfpPrint( fp, "*(");
  else if ( origMode == YOMODE_RETURN )		
    return;
  else
    yccfpPrint( fp, "(");
  yccGenParamType( ctx, fp, type, mode);
  yccfpPrint( fp, ")");
}
