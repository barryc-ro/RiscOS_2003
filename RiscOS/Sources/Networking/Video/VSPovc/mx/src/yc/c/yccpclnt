/* mx/src/yc/yccpclnt.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/


 
#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCCP0_ORACLE
#include <yccp0.h>
#endif
#ifndef YSSTR_ORACLE
#include <ysstr.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif
 

STATICF void yccpGenClient( ycctx* ctx, yccfp* fp, yrobj* obj, boolean dummy);
STATICF void yccpGenIntfClient( ycctx* ctx, yccfp* fp, yrobj* obj);
STATICF void yccpGenExcClient( ycctx* ctx, yccfp* fp, yrobj* obj);
STATICF void yccpGenStructClient( ycctx* ctx, yccfp* fp, yrobj* obj);
STATICF void yccpGenUnionClient( ycctx* ctx, yccfp* fp, yrobj* obj);
STATICF void yccpGenSeqClient( ycctx* ctx, yccfp* fp, yrobj* obj);
STATICF void yccpGenArrayClient( ycctx* ctx, yccfp* fp, yrobj* obj);
#ifndef RISCOS
STATICF void yccpGenAliasClient( ycctx* ctx, yccfp* fp, yrobj* obj);
#endif
STATICF void yccpGenUnionMbrDefn( ycctx* ctx, yccfp* fp, yrunmbr* mbr, 
                             CONST char* name);
STATICF void yccpGenOpClient( ycctx* ctx, yccfp* fp, yrobj* obj);
STATICF void yccpGenAttrClient( ycctx* ctx, yccfp* fp, yrobj* obj);
STATICF void yccpGenTypeCodeDefn( ycctx* ctx, yccfp* fp, yrobj* type);
STATICF void yccpGenOraExtDefns( ycctx* ctx, yccfp* fp, yrobj* type);
STATICF void yccpGenConstClient( ycctx* ctx, yccfp* fp, yrobj* obj);





void yccpclnt(ycctx *ctx, CONST char *base, ycfile* fd)
{
  yccfp* fp;
  char  *upbase;
  CONST char* errtxt;
 
    
  fp = yccfpOpen(fd->newtmp, "w", SYSFPKIND_NONE, &errtxt, 
                 yccGetLineLimit(ctx));
  if (!fp )
  {
    ysRecord( YCMSG(8), YCERRSEV, YSLSTR(fd->target), YSLSTR(errtxt), YSLEND);
    return;
  }
  upbase = ycToUpper(ysStrDup(base));        
  yccfpSetIndent( fp, 0);
 
    
  yccfpPrint( fp, "/* GENERATED FILE\n * %s - client stubs\n", base);
  yccfpPrint( fp, " * from %s\n */\n\n", ctx->srcnm);
  yccfpPrint( fp, "extern \"C\"\n{\n");    
  yccGenSysIncls(ctx, fp, TRUE);
  yccfpPrint( fp, "}\n\n");
  upbase = ycToUpper(ysStrDup(base));           
  yccfpPrint( fp, "#ifndef %s_%s\n#include <%s.h>\n#endif\n\n", 
              upbase, (ycStyleOra(ctx) ? "ORACLE" : "IDL"), base);
  ysmGlbFree( (dvoid*)upbase);

    
  if ( ysLstCount( ctx->newobjs) > 0 )
  {
    ycgNewScopeStack( ctx);
    yccpGenCGObjs( ctx, fp, ctx->newobjs, yccpGenClient, (yccpdefcgfp)0);
    DISCARD ycgPopScope(ctx);      
  }

  yccfpClose(fp);
}




STATICF void yccpGenClient( ycctx* ctx, yccfp* fp, yrobj* obj, boolean dummy)
{
  switch ( yrGetKind(obj) )
  {
    case yrdkInterface:		
      yccpGenIntfClient( ctx, fp, obj);
      break;
    case yrdkException:		
      yccpGenExcClient( ctx, fp, obj);
      break;
    case yrdkStruct:
      yccpGenStructClient( ctx, fp, obj);
      break;
    case yrdkUnion:
      yccpGenUnionClient( ctx, fp, obj);
      break;
    case yrdkAlias:
      yccpGenTypeCodeDefn( ctx, fp, obj);
      break;
    case yrdkEnum:
      yccpGenTypeCodeDefn( ctx, fp, obj);
      yccpGenAnyFuncs( ctx, fp, obj, TRUE);
      break;
    case yrdkOperation:
      yccpGenOpClient( ctx, fp, obj);
      break;
    case yrdkAttribute:
      yccpGenAttrClient( ctx, fp, obj);
      break;
    case yrdkConstant:
      yccpGenConstClient( ctx, fp, obj);
      break;
    default:			
      break;
  }
}




STATICF void yccpGenConstClient( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  if ( yrGetKind(yrGetDefinedIn(obj)) == yrdkInterface )
  {
    yccfpPrint( fp, "const %s %s = ", 
                yccpTypeName( ctx, yrConstData(obj).type), 
                yccpAbsoluteName( ctx, obj));
    yccGenConstVal( ctx, fp, obj);
    yccfpPrint( fp, ";\n\n");
  }
}






STATICF void yccpGenIntfClient( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  CONST char* name;
  CONST char* scname;
  ysle* le;

  name = yccpSimpleName( ctx, obj);
  scname = yccpScopedName( ctx, obj);

  for ( le = ysLstHead( yrGetContents(obj)); le; le = ysLstNext(le))
  {
    yrobj* mem = (yrobj*) ysLstVal(le);

    if ( yrGetDefinedIn(mem) == obj )        
    {
        yccpGenClient( ctx, fp, mem, FALSE);
    }
  }

  yccpGenTypeCodeDefn( ctx, fp, obj);
  yccfpPrint( fp, "%s_ptr %s::_duplicate( %s_ptr _obj)\n{\n", 
              name, scname, name);
  yccfpIncIndent(fp);
  yccfpDecIndent(fp);
  yccfpPrint( fp, "}\n\n");

  yccfpPrint( fp, "%s_ptr %s::_narrow( %sObject_ptr _obj)\n{\n",
              name, scname, YCP_CORBA(ctx));
  yccfpIncIndent(fp);
  yccfpDecIndent(fp);
  yccfpPrint( fp, "}\n\n");

  yccfpPrint( fp, "%s_ptr %s::_nil()\n{\n", name, scname);
  yccfpIncIndent(fp);
  yccfpPrint( fp, "return (%s_ptr)0;\n", name);
  yccfpDecIndent(fp);
  yccfpPrint( fp, "}\n\n");

  yccfpPrint( fp, "%s::%s( const %s& _val)\n{\n", scname, name, name);
  yccfpIncIndent(fp);
  yccfpDecIndent(fp);
  yccfpPrint( fp, "}\n\n");

  yccfpPrint( fp, "%s& %s::operator=( const %s& _rhs)\n{\n", 
              name, scname, name);
  yccfpIncIndent(fp);
  yccfpDecIndent(fp);
  yccfpPrint( fp, "}\n\n");

  yccfpPrint( fp, "YOTVAR_INTF_DEFN(%s)\n\n", scname);
}






STATICF void yccpGenExcClient( ycctx* ctx, yccfp* fp, yrobj* ex)
{
  CONST char* name;
  CONST char* scname;
  ysle* le;
  yslst* mbrs;
  yslst* nested;
  boolean hasMbrs;

  name = yccpSimpleName( ctx, ex);
  scname = yccpScopedName( ctx, ex);

    
  nested = yrGetContents(ex);
  if ( nested )
  {
    for (le = ysLstHead( nested); le; le = ysLstNext(le))
      yccpGenClient( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
  }
 
    
  mbrs = yrStructData(ex).mbrs;
  hasMbrs = !ycIsEmptyLst(mbrs);
  if ( hasMbrs )
  {
    ycgPushScope( ctx, ex);
    for (le = ysLstHead(mbrs); le; le = ysLstNext(le))
    {
      yrstrmbr* mem = (yrstrmbr*) ysLstVal(le);
      if ( yrGetKind(mem->type) == yrdkSequence )
        yccpGenSeqClient( ctx, fp, mem->type);
      else if ( yrGetKind(mem->type) == yrdkArray )
      {
        DISCARD yccpAnonArrayName( ctx, mem->type, mem->name);
        yccpGenArrayClient( ctx, fp, mem->type);
      }
    }
    DISCARD ycgPopScope( ctx);
  }

    
  yccfpPrint( fp, "%s::%s()\n{\n", scname, name);
  if ( hasMbrs )
  {
    yccfpIncIndent( fp);
    yccfpDecIndent( fp);
  }
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "%s::%s( const %s& _ref)\n{\n", scname, name, scname);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  if ( hasMbrs )
  {
    yccfpPrint( fp, "%s::%s( ", scname, name);
    for (le = ysLstHead(mbrs); le; le = ysLstNext(le))
    {
      yrstrmbr* mem = (yrstrmbr*) ysLstVal(le);
      yccpGenParamType( ctx, fp, mem->type, YOMODE_IN);   
      yccfpPrint( fp, " _%s", mem->name);
      if ( ysLstNext(le) )
        yccfpPrint( fp, ", ");
    }
    yccfpPrint( fp, ") : ");
    for (le = ysLstHead(mbrs); le; le = ysLstNext(le))
    {
      yrstrmbr* mem = (yrstrmbr*) ysLstVal(le);
      yccGenSimpleName( ctx, fp, mem->name);        
      yccfpPrint( fp, "(_%s)",  mem->name);
      yccfpPrint( fp, "%s", ysLstNext(le) ? ", " : "\n{\n}\n\n");
    }
  }

    
  yccfpPrint( fp, "%s::~%s()\n{\n", scname, name);
  if ( hasMbrs )
  {
    yccfpIncIndent( fp);
    yccfpDecIndent( fp);
  }
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "%s::operator=( const %s& _rhs)\n{\n", scname, scname);
  if ( hasMbrs )
  {
    yccfpIncIndent( fp);
    yccfpDecIndent( fp);
  }
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "%s::_narrow( %sException* _ex)\n{\n", 
              scname, YCP_CORBA(ctx));
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

  yccpGenOraExtDefns( ctx, fp, ex);
  yccpGenTypeCodeDefn( ctx, fp, ex);
}






STATICF void yccpGenStructClient( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  ysle* le;
  yrstrmbr* mem;

    
  for (le = ysLstHead( yrGetContents(obj)); le; le = ysLstNext(le))
    yccpGenClient( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
 
    
  ycgPushScope( ctx, obj);
  for (le = ysLstHead(yrStructData(obj).mbrs); le; le = ysLstNext(le))
  {
    mem = (yrstrmbr*) ysLstVal(le);
    if ( yrGetKind(mem->type) == yrdkSequence )
      yccpGenSeqClient( ctx, fp,  mem->type);
    else if ( yrGetKind(mem->type) == yrdkArray )
    {
      DISCARD yccpAnonArrayName( ctx, mem->type, mem->name);
      yccpGenArrayClient( ctx, fp, mem->type);
    }
  }
  DISCARD ycgPopScope(ctx);

  yccpGenAnyFuncs( ctx, fp, obj, TRUE);
  yccpGenTypeCodeDefn( ctx, fp, obj);
  yccfpPrint( fp, "YOTVAR_STRUCT_DEFN(%s)\n\n", yccpScopedName(ctx, obj));
}







STATICF void yccpGenUnionClient( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  ysle* le;
  yslst* mbrs;
  yrunmbr* mem;
  CONST char* scname;      
  CONST char* name;        
  ycsym* syminfo;
  yrobj* disc;

  for (le = ysLstHead( yrGetContents(obj)); le; le = ysLstNext(le))
    yccpGenClient( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
 
  scname = yccpScopedName( ctx, obj);
  name = yccpSimpleName( ctx, obj);

    
  yccfpPrint( fp, "%s::%s()\n{\n", scname, name);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "%s::%s( const %s& _ref)\n{\n", scname, name, scname);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "%s::~%s()\n{\n", scname, name);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "%s::operator=( const %s& _rhs)\n{\n", scname, scname);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  disc = yrUnionData(obj).disctype;
  yccfpPrint( fp, "void %s::_d( ", scname);              
  yccpGenParamType( ctx, fp, disc, YOMODE_IN);
  yccfpPrint( fp, " _value)\n{\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "this->_disc = _value;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

  yccpGenParamType( ctx, fp, disc, YOMODE_RETURN);       
  yccfpPrint( fp, " %s::_d() const\n{\n", scname);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "return this->_disc;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  mbrs = yrUnionData(obj).arms;
  ycgPushScope( ctx, obj);
  for (le = ysLstHead(mbrs); le; le = ysLstNext(le))
  {
    mem = (yrunmbr*) ysLstVal(le);
    if ( yrGetKind(mem->type) == yrdkSequence )          
      yccpGenSeqClient( ctx, fp, mem->type);
    else if ( yrGetKind(mem->type) == yrdkArray )        
    {
      DISCARD yccpAnonArrayName( ctx, mem->type, mem->name);
      yccpGenArrayClient( ctx, fp, mem->type);
    }
    yccpGenUnionMbrDefn( ctx, fp, mem, scname);
  }
  DISCARD ycgPopScope(ctx);

    
  syminfo = ycSymLookup( ctx->symtbl, obj);
  if ( syminfo->lang.cplus.union_dflt > 0 )
  {
    yccfpPrint( fp, "void %s::_default()\n{\n", scname);
    yccfpIncIndent( fp);
    yccfpPrint( fp, "this->_disc = ");

    yccfpPrint( fp, ";\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n\n");
  }

  yccpGenOraExtDefns( ctx, fp, obj);
  yccpGenTypeCodeDefn( ctx, fp, obj);
  yccfpPrint( fp, "YOTVAR_STRUCT_DEFN(%s)\n\n", scname);
}







STATICF void yccpGenSeqClient( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  yrobj* seq;
  yrobj* elmtype;
  ub4 bound;
  char* ename;
  CONST char* name;
  CONST char* scname;

  if ( yrGetKind(obj) == yrdkSequence )
  {
    seq = obj;
  }
  else      
  {
    seq = yrAliasData(obj).type;
    while ( yrGetKind(seq) == yrdkAlias )
      seq = yrAliasData(seq).type;
  }
  elmtype = yrSeqData(seq).elmtype;
  bound = yrSeqData(seq).bound;

  if ( (bound == 0) && (ctx->lang->flags & YCCP_BUILTIN_SEQ_FLG) &&
      (yrGetKind(elmtype) == yrdkPrimitive) )
    return;    

  ename = yccpElemName( ctx, seq);
  name = yccpSimpleName( ctx, obj);
  scname = yccpScopedName( ctx, obj);

    
  yccfpPrint( fp, "%s::%s() : _maximum(%u), _length(0),", scname, name, bound);
  yccfpPrint( fp, " _buffer((%s*)0), _release(TRUE)\n{\n}\n\n", 
              ename, scname, name);

    
  yccfpPrint( fp, "%s::%s( const %s& _val) : ", scname, name, name);
  yccfpPrint( fp, "_maximum(0), _length(0), _buffer((%s*)0), ", ename);
  yccfpPrint( fp, "_release(TRUE)\n{\n", ename);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "this->copy( _val);\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

  if ( bound == 0 )
  {
      
    yccfpPrint( fp, "%s::%s( ub4 _max) : _maximum(_max),", scname, name);
    yccfpPrint( fp, " _length(0), _buffer(%s*)0), _release(TRUE)\n{\n", ename);
    yccfpIncIndent( fp);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n\n");

      
    yccfpPrint( fp, "%s::%s( ub4 _max, ub4 _length, %s* _data, ", 
                scname, name, ename);
    yccfpPrint( fp, "boolean _release) : _maximum(_max), _length(_length), ");
    yccfpPrint( fp, "_buffer(_data), _release(_release)\n{\n}\n\n");
  }
  else
  {
      
    yccfpPrint( fp, "%s::%s( ub4 _length, %s* _data, ", scname, name, ename);
    yccfpPrint( fp, "boolean _release) : _maximum(0), _length(_length), ");
    yccfpPrint( fp, "_buffer(_data), _release(_release)\n{\n}\n\n");
  }

    
  yccfpPrint( fp, "%s::~%s()\n{\n", scname, name);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "if ( this->_release && this->_buffer )\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "%s::freebuf( this->_buffer);\n", scname);
  yccfpDecIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "%s& %s::operator=( const %s& _val)\n{\n\n", 
              name, scname, name);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "this->_copy( _val);\nreturn *this;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "ub4 %s::maximum() const\n{\n", scname);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "return this->_maximum;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "ub4 %s::length() const\n{\n", scname);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "return this->_length;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

  yccfpPrint( fp, "void %s::length(ub4 _len)\n{\n\n", scname);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "%s& %s::operator[]( ub4 index)\n{\n", ename, scname);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "return this->_buffer[index];\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

  yccfpPrint( fp, "const %s& %s::operator[]( ub4 index) const\n{\n\n", 
              ename, scname);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "return this->_buffer[index];\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "static %s* %s::allocbuf( ub4 nelems)\n{\n", ename, scname);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "static void %s::freebuf( %s* buff)\n{\n\n", ename, scname);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");
  
  
  yccpGenOraExtDefns( ctx, fp, seq);     
  if ( bound == 0 )
  {
      
    yccfpPrint( fp, "void %s::reallocbuf( ub4 nelems)\n{\n", scname);
    yccfpIncIndent( fp);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n\n");

      
    yccfpPrint( fp, "void %s::maximum( ub4 len)\n{\n", scname);
    yccfpIncIndent( fp);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n\n");
  }

    
  yccfpPrint( fp, "%s::_copy( const %s& _val)\n{\n", scname);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "if ( this->_release && this->_buffer )\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "%s::freebuf( this->_buffer);\n", scname);
  yccfpDecIndent( fp);
  
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccpGenExtractor( ctx, fp, seq, name, FALSE);
  yccpGenInserter( ctx, fp, seq, name, FALSE);
  yccpGenCopyInserter( ctx, fp, seq, name, FALSE);
  yccfpPrint( fp, "\n");

    
  yccpGenTypeCode( ctx, fp, seq, name, TRUE);
  yccfpPrint( fp, "YOTVAR_SEQ_DEFN(%s, %s)\n\n", scname, ename);

  ysmGlbFree( (dvoid*)ename);
}







STATICF void yccpGenArrayClient( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  CONST char* name = yccpScopedName( ctx, obj);

    
  yccfpPrint( fp, "%s_slice* %s_alloc()\n{\n", name, name);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "%s_slice* %s_dup( const %s_slice* _val)\n{\n", 
              name, name, name);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "void %s_free( %s_slice*)\n{\n", name, name);
  yccfpIncIndent( fp);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");

    
  yccfpPrint( fp, "YOTVAR_ARRAY_DEFN(%s)\n\n", name);
  yccfpPrint( fp, "YOFORANY_DEFN(%s)\n\n", name);
  yccpGenAnyFuncs( ctx, fp, obj, TRUE);
  yccpGenTypeCodeDefn( ctx, fp, obj);
}




STATICF void yccpGenTypeCodeDefn( ycctx* ctx, yccfp* fp, yrobj* type)
{
  CONST char* name = yccpSimpleName( ctx, type);

  yccpGenTypeCode( ctx, fp, type, name, TRUE);
  yccfpPrint( fp, " = \n");
  yccfpIncIndent( fp);
  yccFormatTypeCodeDefn( ctx, fp, yrGetTypeCode( type));
  yccfpDecIndent( fp);
}



STATICF void yccpGenUnionMbrDefn( ycctx* ctx, yccfp* fp, yrunmbr* mbr, 
                             CONST char* unname)
{
  yrobj* type;
  yrobj* base;
  yrdk base_kind;
  CONST char* tname;
  CONST char* kwdpfx = ((*ctx->lang->kwdchk)( ctx, mbr->name) ? "_" : "");

  type = mbr->type;
  if ( yrGetKind(type) == yrdkAlias )
    base = yrGetAliasBaseType( type);
  else
    base = type;
  base_kind = yrGetKind( base);
  tname = yccpTypeName( ctx, type);

  for (;;)                    
  {
    switch (base_kind)
    {
      case yrdkInterface:
          
        yccfpPrint( fp, "void %s::%s%s( %s_ptr _val)\n{\n", 
                    unname, kwdpfx, mbr->name, tname);
        yccfpIncIndent( fp);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");

          
        yccfpPrint( fp, "%s_ptr %s::%s%s() const\n{\n", 
                    tname, unname, kwdpfx, mbr->name);
        yccfpIncIndent( fp);
        yccfpPrint( fp, "return *(%s_ptr*)(this->_data);\n", tname);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");

        return;
      case yrdkEnum:
          
        yccfpPrint( fp, "void %s::%s%s( %s _val)\n{\n", 
                    unname, kwdpfx, mbr->name, tname);
        yccfpIncIndent( fp);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");

          
        yccfpPrint( fp, "%s %s%s() const\n{\n", tname, kwdpfx, mbr->name);
        yccfpIncIndent( fp);
        yccfpPrint( fp, "return *(%s*)(this->_data);\n", tname);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");

        return;
      case yrdkStruct:
      case yrdkUnion:
      case yrdkException:
      case yrdkSequence:
          
        yccfpPrint( fp, "void %s::%s%s( const %s& _val)\n{\n", 
                    unname, kwdpfx, mbr->name, tname);
        yccfpIncIndent( fp);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");

          
        yccfpPrint( fp, "%s& %s::%s%s()\n{\n", 
                    tname, unname, kwdpfx, mbr->name);
        yccfpIncIndent( fp);
        yccfpPrint( fp, "return *(%s*)(this->_data);\n", tname);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");

          
        yccfpPrint( fp, "const %s& %s::%s%s() const\n{\n", 
                    tname, unname, kwdpfx, mbr->name);
        yccfpIncIndent( fp);
        yccfpPrint( fp, "return *(%s*)(this->_data);\n", tname);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");
        return;
      case yrdkArray:
          
        yccfpPrint( fp, "void %s::%s%s( %s _val)\n{\n", 
                    unname, kwdpfx, mbr->name, tname);
        yccfpIncIndent( fp);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");

          
        yccfpPrint( fp, "%s_slice* %s::%s%s() const\n{\n", 
                    tname, unname, kwdpfx, mbr->name);
        yccfpIncIndent( fp);
        yccfpPrint( fp, "return (%s_slice*)(this->_data);\n", tname);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");
        return;
      case yrdkString:
          
        yccfpPrint( fp, "void %s::%s%s( char* _val)\n{\n", 
                    unname, kwdpfx, mbr->name);
        yccfpIncIndent( fp);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");

          
        yccfpPrint( fp, "void %s::%s%s( const char* _val)\n{\n", 
                    unname, kwdpfx, mbr->name);
        yccfpIncIndent( fp);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");

          
        yccfpPrint( fp, "void %s::%s%s( const %sString_var& _val)\n{\n",
                    unname, kwdpfx, mbr->name, YCP_CORBA(ctx));
        yccfpIncIndent( fp);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");

          
        yccfpPrint( fp, "const char* %s::%s%s() const\n{\n", 
                    unname, kwdpfx, mbr->name);
        yccfpIncIndent( fp);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");
        return;
      case yrdkPrimitive:
          
        switch (yrPrimData(base).kind)
        {
          case yrpkstring:
            base_kind = yrdkString;
            break;
          case yrpkTypeCode:
            base_kind = yrdkInterface;
            break;
          case yrpkany:
            base_kind = yrdkStruct;
            break;
          default:
            base_kind = yrdkEnum;
            break;
        }
        break;
      default:
        yseThrow(YC_EX_FAILURE);
        break;
    }
  }
}





STATICF void yccpGenOraExtDefns( ycctx* ctx, yccfp* fp, yrobj* type)
{
  switch (yrGetKind( ycgScope(ctx)))
  {
    case yrdkStruct:             
    case yrdkUnion:
    case yrdkException:
    case yrdkInterface:
    case yrdkSequence:
    {
      CONST char* name = yccpScopedName( ctx, type);

      yccfpPrint( fp, "/* OMN Extensions */\n");
      yccfpPrint( fp, "%sTypeCode_ptr %s::_typecode()\n{\n", 
                  name, YCP_CORBA(ctx));
      yccfpIncIndent( fp);
      yccfpDecIndent( fp);
      yccfpPrint( fp, "}\n\n");
      break;
    }
    default:
      break;
  }
}



STATICF void yccpGenOpClient( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  CONST char* scname;
  CONST char* name;
  ycgkwdfp kwdfp = ctx->lang->kwdchk;
  yrobj* rettype = (yrOpData(obj).rettype ? yrOpData(obj).rettype
                           : yrGetPrimitive( ctx->repository, yrpkvoid));
  yslst* pars = yrOpData(obj).pars;
  ysle* le;

  scname = yccpScopedName( ctx, yrGetDefinedIn(obj));
  name = yccpSimpleName( ctx, obj);

    
  yccpGenParamType( ctx, fp, rettype, YOMODE_RETURN);
  yccfpPrint( fp, " %s::%s( ", scname, name);

  if ( pars )
  {
    for ( le = ysLstHead(pars); le; le = ysLstNext(le))
    {
      yrpar* par = (yrpar*)ysLstVal(le);
 
      yccpGenParamType( ctx, fp, par->type, par->mode);
      yccfpPrint( fp, " %s%s, ",
                  ((*kwdfp)(ctx, par->name) ? "_" : ""), par->name);
    }
  }
  yccfpPrint( fp, "%sEnvironment& env, ysevt* usrevt)\n{\n", YCP_CORBA(ctx));
  yccfpIncIndent(fp);

  yccfpDecIndent(fp);
  yccfpPrint( fp, "}\n\n");
}



STATICF void yccpGenAttrClient( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  CONST char* scname;
  CONST char* name;
  yrobj* rettype = (yrOpData(obj).rettype ? yrOpData(obj).rettype
                           : yrGetPrimitive( ctx->repository, yrpkvoid));
  yslst* pars = yrOpData(obj).pars;

  scname = yccpScopedName( ctx, yrGetDefinedIn(obj));
  name = yccpSimpleName( ctx, obj);

    
  yccpGenParamType( ctx, fp, yrAttrData(obj).type, YOMODE_RETURN);
  yccfpPrint( fp, " %s::%s( %sEnvironment& _env, ysevt* usrevt)\n{\n", 
              scname, name, YCP_CORBA(ctx));
  yccfpIncIndent(fp);
  
  yccfpDecIndent(fp);
  yccfpPrint( fp, "}\n\n");

    
  if ( yrAttrData(obj).mode != YR_ATTR_RO )
  {
    yccfpPrint( fp, "void %s::%s( ", scname, name);
    yccpGenParamType( ctx, fp, yrAttrData(obj).type, YOMODE_IN);
    yccfpPrint( fp, " _val, %sEnvironment& env, ysevt* usrevt)\n{\n", 
                YCP_CORBA(ctx));
    yccfpIncIndent(fp);
    
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");
  }
}
