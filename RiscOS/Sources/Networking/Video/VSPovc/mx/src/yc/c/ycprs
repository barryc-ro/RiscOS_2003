/* mx/src/yc/ycprs.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YC_ORACLE
#include <yc.h>
#endif

typedef struct ycktd ycktd;

struct ycktd
{
  char *tokrep;                                      
  sb2   tokval;                                               
};

externdef ysmtagDecl(YCONODE_TAG) = "AST node";

static CONST_W_PTR ycktd kwdtab[] =
{
  { "FALSE", YCTFALSE },
  { "TRUE", YCTTRUE },
  { "TypeCode", YCTTYPECODE },
  { "any", YCTANY },
  { "attribute", YCTATTRIBUTE },
  { "boolean", YCTBOOLEAN },
  { "case", YCTCASE },
  { "char", YCTCHAR },
  { "const", YCTCONST },
  { "context", YCTCONTEXT },
  { "default", YCTDEFAULT },
  { "double", YCTDOUBLE },
  { "enum", YCTENUM },
  { "exception", YCTEXCEPTION },
  { "float", YCTFLOAT },
  { "in", YCTIN },
  { "inout", YCTINOUT },
  { "interface", YCTINTERFACE },
  { "long", YCTLONG },
  { "module", YCTMODULE },
  { "octet", YCTOCTET },
  { "oneway", YCTONEWAY },
  { "out", YCTOUT },
  { "raises", YCTRAISES },
  { "readonly", YCTREADONLY },
  { "sequence", YCTSEQUENCE },
  { "short", YCTSHORT },
  { "string", YCTSTRING },
  { "struct", YCTSTRUCT },
  { "switch", YCTSWITCH },
  { "typedef", YCTTYPEDEF },
  { "union", YCTUNION },
  { "unsigned", YCTUNSIGNED },
  { "void", YCTVOID }
};

static CONST_DATA size_t kwdtabsiz = sizeof(kwdtab) / sizeof(ycktd);

STATICF dvoid *ycprAlloc(size_t len);
STATICF boolean ycprKywd(dvoid *ctx, sb2 tokid, pxtokn *tok);
STATICF void ycprGetNext(ycctx *ctx, pxtokn *tok);
STATICF sb2 ycprReserved(ycctx *ctx, char *nm);
STATICF sb2 ycprPragma( ycctx* ctx, CONST char* nm);


void ycprs(ycctx *ctx)
{
  sb1 err;
  boolean trace = FALSE;

  ctx->curln = ysLstHead(ctx->tu);
  ctx->pos = 0;
  ctx->tokq = ysLstCreate();

#ifdef PXDEBUG
    
  {
    yslst* lst;
    lst = ysResGet( "mnidlc.debug-trace-type");
    if ( lst )
    {
      ysle* le;
      for ( le = ysLstHead( lst); le; le = ysLstNext(le) )
	if ( strcmp( "parse", (char*) ysLstVal(le)) == 0 )
        {
	   trace = TRUE;
	   break;
	}
    }
  }
#endif
   
  ycosyn((dvoid*)ctx, trace, ycprLex, ycprAlloc, ysmFGlbFree, ycprKywd, 
	&err, yct_identifier);

  if ( !err )
    DISCARD ycprLex( (dvoid*)ctx, PXFREETOK, ctx->lastTok);
  ysLstDestroy(ctx->tokq, (ysmff) 0);
}


STATICF dvoid *ycprAlloc(size_t len)
{
  return ysmGlbAlloc(len, "parser memory");
}



STATICF boolean ycprKywd(dvoid *ctxp, sb2 tokid, pxtokn *tok)
{
  return FALSE;
}


pxtokn *ycprLex(dvoid *ctxp, sword action, ...)
{
  ycctx  *ctx;
  ycln   *ln;
  pxtokn *tok = (pxtokn*)0;
  va_list arg;

  ctx = (ycctx *) ctxp;

  va_start(arg, action);

  switch (action)
    {
    case PXGETNEXT:
      if (ysLstHead(ctx->tokq))
	tok = (pxtokn*) ysLstPop(ctx->tokq);
      else
      {
        tok = (pxtokn *) ysmGlbAlloc(sizeof(pxtokn), "token");
        CLRSTRUCT(*tok);
        ycprGetNext(ctx, tok);
      }
      ctx->lastTok = tok;
      break;
    case PXUNGET:
      tok = va_arg(arg, pxtokn *);
      DISCARD ysLstPush(ctx->tokq, (dvoid *) tok);
      break;
    case PXERRORMSG:
      tok = (pxtokn*) va_arg(arg, pxtokn *);
      ln = (ycln *) pxtfil(tok);
      ctx->inpragma = FALSE;
      if ( !pxtgid(tok) )
        ysRecord( YCMSG(47), YCERRSEV, YCERRLN(ln), YSLEND);
      else
        ysRecord( YCMSG(46), YCERRSEV, YCERRLN(ln), YSLSTR(pxtnam(tok)), 
                  YSLEND);
      break;
    case PXFREETOK:
      tok = va_arg( arg, pxtokn*);
      ysmGlbFree((dvoid *) tok);
      break;
    default:
      ysePanic(YS_EX_FAILURE);
      break;
    }

  va_end(arg);
  return (action == PXGETNEXT ? tok : (pxtokn *) 0);
}


STATICF void ycprGetNext(ycctx *ctx, pxtokn *tok)
{
  ycln  *ln;
  sword  cls, val;
  ysstr *nm;
  char  *id;

 retry:
  if (!ctx->curln)
    {
      tok->tokid = 0;
      tok->filnam = (char *) ysLstVal(ysLstTail(ctx->tu));
    }
  else
    {
      ln = (ycln *) ysLstVal(ctx->curln);
      cls = (ln->dir ? YCPP_EOL : ycppGetToken(ln, &ctx->pos, &val, &nm));

      switch (cls)
	{
	case YCPP_IDENT:
	  id = ysStrToText(nm);

	  tok->tokid = ycprReserved(ctx, id);
	  DISCARD strncpy(tok->toknam, id, PXMAXTOKNAME);
	  tok->filnam = (char *) ln;
	  tok->attrib.literal = id;

	  if (pxtgid(tok) != yct_identifier)
	    ysStrDestroy(nm);
	  break;
	case YCPP_NUM:
	  tok->tokid = yct_numeric_literal;
	  DISCARD strcpy(tok->toknam, ysStrToText(nm));
	  tok->filnam = (char *) ln;
	  tok->attrib.literal = ysStrToText(nm);
	  break;
	case YCPP_CHAR:
	  tok->tokid = yct_character_literal;
	  DISCARD strcpy(tok->toknam, ysStrToText(nm));
	  tok->filnam = (char *) ln;
	  tok->attrib.literal = ysStrToText(nm);
	  break;
	case YCPP_STRING:
	  tok->tokid = yct_string;
	  DISCARD strcpy(tok->toknam, ysStrToText(nm));
	  tok->filnam = (char *) ln;
	  tok->attrib.literal = ysStrToText(nm);
	  break;
	case YCPP_PUNC:
	  tok->tokid = (sb2)val;
	  tok->filnam = (char *) ln;
	  if (nm)
	  {
	    DISCARD strcpy(tok->toknam, ysStrToText(nm));
	    ysStrDestroy(nm);
	  }
	  else
          {
	    tok->toknam[0] = (char) val; 
            tok->toknam[1] = '\0';
          }
	  break;
	case YCPP_EOL:
	  ctx->curln = ysLstNext(ctx->curln);
	  ctx->pos = 0;
          if ( ctx->inpragma )
          {   
            tok->tokid = YCTNEWLINE;
            DISCARD strcpy( tok->toknam, "end-of-line");
            tok->filnam = (char*)ln;
            ctx->inpragma = FALSE;
          }
          else
          {
            ctx->inpragma = FALSE;
	    goto retry;
          }
          break;
        case YCPP_PPPOUND:
	  cls = ycppGetToken(ln, &ctx->pos, &val, &nm);
          if ( cls == YCPP_IDENT && !strcmp( ysStrToText(nm), "pragma") )
          {
            ysStrDestroy(nm);
	    cls = ycppGetToken(ln, &ctx->pos, &val, &nm);
            tok->tokid = ycprPragma( ctx, ysStrToText(nm));
            if ( nm )
            {
	      DISCARD strncpy(tok->toknam, ysStrToText(nm), PXMAXTOKNAME);
              ysStrDestroy( nm);
            }
	    tok->filnam = (char *) ln;
            ctx->inpragma = TRUE;   
          }
          break;
	case YCPP_PPPASTE:
	case YCPP_OTHER:
          ysRecord( YCMSG(45), YCERRSEV, YCERRLN(ln), YSLSB4(val), YSLEND);
	  goto retry;
	}
    }
}


STATICF sb2 ycprReserved(  ycctx *ctx, char *nm)
{
  CONST ycktd *low; 
  CONST ycktd *mid;
  CONST ycktd *high;
  sword  cmp;

  
  high = kwdtab + kwdtabsiz;
  low = kwdtab;

  while (low < high)
    {
      mid = low + (high - low) / 2;
      cmp = (sword) strcmp(nm, mid->tokrep);
      if (cmp < 0)
	high = mid;
      else if (cmp > 0)
	low = mid + 1;
      else
	return mid->tokval;
    }

  return yct_identifier;
}


STATICF sb2 ycprPragma(   ycctx* ctx, CONST char* nm)
{
  if ( (nm[0] == 'I') && (strcmp(nm, "ID") == 0) )
    return YCTPRAGMAID;
  else if ( (nm[0] == 'p') && (strcmp(nm, "prefix") == 0) )
    return YCTPRAGMAPREFIX;
  else if ( (nm[0] == 'v') && (strcmp(nm, "version") == 0) )
    return YCTPRAGMAVERSION;
  else if ( nm[0] == 'I' )
    if ( strcmp( nm, "IAO_DB_ATTR") == 0 )
      return YCTPRAGMADBATTR;
    else if ( strcmp( nm, "IAO_DB_CREATE") == 0 )
      return YCTPRAGMADBCREAT;
    else if ( strcmp( nm, "IAO_DB_LIST") == 0 )
      return YCTPRAGMADBLST;
    else
      return yct_identifier;
  else
    return yct_identifier;
}

