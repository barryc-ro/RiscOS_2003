/* mx/src/yc/yccphdr.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCCP0_ORACLE
#include <yccp0.h>
#endif
#ifndef YSSTR_ORACLE
#include <ysstr.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif


STATICF void yccpGenDecl( ycctx* ctx, yccfp* fp, yrobj* decl, boolean isFwd);
STATICF void yccpGenIntfDecl(ycctx* ctx, yccfp* fp, yrobj* intf, boolean fwd);
STATICF void yccpGenExDecl( ycctx* ctx, yccfp* fp, yrobj* ex, boolean fwd);
STATICF void yccpGenStructDecl(ycctx* ctx, yccfp* fp, yrobj* sobj,boolean fwd);
STATICF void yccpGenUnionDecl( ycctx* ctx, yccfp* fp, yrobj* uobj,boolean fwd);
STATICF void yccpGenAliasDecl(ycctx* ctx, yccfp* fp, yrobj* alias,boolean fwd);
STATICF void yccpGenEnumDecl(ycctx* ctx, yccfp* fp, yrobj* eobj, boolean fwd);
STATICF void yccpGenSeqDecl( ycctx* ctx, yccfp* fp, yrobj* name, yrobj* seq);
STATICF void yccpGenAttrDecl(ycctx* ctx, yccfp* fp, yrobj* attr);
STATICF void yccpGenOpDecl(ycctx* ctx, yccfp* fp, yrobj* op);
STATICF void yccpGenConstDecl(ycctx *ctx, yccfp *fp, yrobj *obj);
STATICF void yccpGenField(ycctx* ctx,yccfp* fp, yrobj* type, CONST char* name);
STATICF void yccpGenArrayDeclr( ycctx* , yccfp* , yrobj* , CONST char*);
STATICF void yccpGenOraExtDecls( ycctx* ctx, yccfp* fp, yrobj* type);
STATICF void yccpGenUnionMbrDecls( ycctx* ctx, yccfp* fp, yrunmbr* mbr);
STATICF void yccpGenArrayDecl( ycctx* ctx, yccfp* fp, yrobj* array);
STATICF void yccpGenDeferredDecls( ycctx* ctx, yccfp* fp, yslst* deferred);





void yccphdr(ycctx *ctx, CONST char *base, ycfile* fd)
{
  yccfp *fp;
  char  *upbase;
  CONST char* errtxt;
  CONST char* incl_sfx = (ycStyleOra(ctx) ? "ORACLE" : "IDL");

    
  fp = yccfpOpen(fd->newtmp, "w", SYSFPKIND_NONE, &errtxt, 
                 yccGetLineLimit( ctx));
  if ( !fp )
  {
    ysRecord( YCMSG(8), YCERRSEV, YSLSTR(fd->target), YSLSTR(errtxt), YSLEND);
    return;
  }
  upbase = ycToUpper(ysStrDup(base));        
  yccfpSetIndent( fp, 0);

    
  yccfpPrint( fp, "/* GENERATED FILE\n * %s - public declarations\n", base);
  yccfpPrint( fp, " * from %s\n */\n\n", ctx->srcnm);
  yccfpPrint( fp, "#ifndef %s_%s\n#define %s_%s\n\n", 
              upbase, incl_sfx, upbase, incl_sfx);

  yccfpPrint(fp, "extern \"C\"\n{\n");    
  yccGenSysIncls(ctx, fp, FALSE);
  yccfpPrint(fp, "}\n\n");
yccfpPrint( fp, "#include \"yocplus.h\"\n");   

    
  if ( ysLstCount( ctx->newobjs) > 0 )
  {
    yslst* deferred;

    ycgNewScopeStack( ctx);
    yccpGenCGObjs( ctx, fp, ctx->newobjs, yccpGenDecl, yccpGenDeferredDecls);
    deferred = ycgPopScope(ctx);
    if ( deferred )
    {
      yccpGenDeferredDecls( ctx, fp, deferred);
      ysLstDestroy( deferred, (ysmff)0);
    }
  }

    
  yccfpPrint(fp, "#endif /* %s_%s */\n", upbase, incl_sfx);

  ysmGlbFree((dvoid *) upbase);
  yccfpClose( fp);
}




STATICF void yccpGenDecl( ycctx* ctx, yccfp* fp, yrobj* decl, boolean isFwd)
{
  switch ( yrGetKind(decl) )
  {
    case yrdkInterface:
      yccpGenIntfDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkConstant:
        
      if ( !ycIsEnumConst(decl) )
        yccpGenConstDecl(ctx,fp, decl);
      break;
    case yrdkException:
      yccpGenExDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkAlias:
      yccpGenAliasDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkStruct:
      yccpGenStructDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkUnion:
      yccpGenUnionDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkEnum:
      yccpGenEnumDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkSequence:
      yccpGenSeqDecl(ctx, fp, (yrobj*)0, decl);
      break;
    case yrdkAttribute:
      yccpGenAttrDecl(ctx, fp, decl);
      break;
    case yrdkOperation:
      yccpGenOpDecl(ctx, fp, decl);
      break;
    default:
      
      break;
  }
}




STATICF void yccpGenConstDecl(ycctx *ctx, yccfp *fp, yrobj *obj)
{
  CONST char* name;
  CONST char* guard = (char*)0;
  boolean inClass = yccpInClassScope( ctx, obj);

  if ( !inClass )
  {
    guard = yccpFlattenAbsName( ctx, obj);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }

    
  yccfpPrint( fp, "static const %s", yccpTypeName(ctx, yrConstData(obj).type));
  name = yccpSimpleName( ctx, obj);

    
  if ( !inClass )
  {
    yccfpPrint( fp, " %s = ", name);
    yccGenConstVal( ctx, fp, obj);
    yccfpPrint( fp, ";\n");
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
    ysmGlbFree( (dvoid*)guard);
  }
  else
    yccfpPrint( fp, " %s;\n\n", name);
}




STATICF void yccpGenIntfDecl(ycctx* ctx, yccfp* fp, yrobj* intf, boolean fwd)
{
  CONST char* name;
  yslst* deferred;
  CONST char* guard;

  if ( ycIsCorbaObject( ctx, intf) )   
    return;

  guard = yccpFlattenAbsName( ctx, intf);
  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n", guard, guard);
  yccfpEndPP( fp);

  name = yccpSimpleName( ctx, intf);
  yccfpPrint( fp, "class %s;\n", name);
  yccfpPrint( fp, "typedef %s* %s_ptr;\n", name, name);
  yccfpPrint( fp, "typedef %s* %sRef;\n", name, name);
#ifdef NEVER
  yccpGenIntfTVar( ctx, fp, intf, FALSE);
#else
  yccfpPrint( fp, "YOTVAR_INTF_DECL(%s);\n", name);
#endif

  yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);

  if ( ! fwd )
  {
    ysle* le;
    CONST char* sname;    

    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DEFINED\n#define %s_DEFINED\n", guard, guard);
    yccfpEndPP( fp);

    yccfpPrint( fp, "class %s", name);

      
    if ( yrInterfaceData(intf).bases )
    {
      ysle* le;

      yccfpPrint( fp, " : ");
      for (le = ysLstHead(yrInterfaceData(intf).bases); le; le = ysLstNext(le))
      {
        CONST char* bname;
        yrobj* base = (yrobj*) ysLstVal(le);

        bname = yccpScopedName( ctx, base);
        yccfpPrint( fp,"public %s%s", bname, ysLstNext(le) ? ", " : "");
      }
    }

    yccfpPrint( fp, "\n{\npublic:\n");
    yccfpIncIndent( fp);
    ycgPushScope( ctx, intf);
    sname = yccpAbsoluteName( ctx, intf);

      
    yccfpPrint( fp, "static %s_ptr _duplicate( %s_ptr obj);\n", sname, sname);
    yccfpPrint( fp, "static %s_ptr _narrow( %sObject_ptr obj);\n",
                sname, YCP_CORBA(ctx));
    yccfpPrint( fp, "static %s_ptr _nil();\n\n");

      
    for ( le = ysLstHead( yrGetContents(intf)); le; le = ysLstNext(le))
    {
      yrobj* mem = (yrobj*) ysLstVal(le);

      if ( yrGetDefinedIn(mem) == intf )        
        yccpGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
    }
      
    yccpGenOraExtDecls( ctx, fp, intf);

      
    yccfpPrint( fp, "\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "protected:\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s();\nvirtual ~%s() {}\n\n", name, name);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "private:\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s( const %s&);\n", name, sname);
    yccfpPrint( fp, "%s& operator=( const %s&);\n", sname, sname);

    yccfpDecIndent( fp);
    yccfpPrint( fp, "};\n\n");
    deferred = ycgPopScope( ctx);

    yccpGenTypeCode( ctx, fp, intf, name, FALSE);
    yccpGenAnyFuncs( ctx, fp, intf, FALSE);
    if ( deferred )
    {
      yccpGenDeferredDecls( ctx, fp, deferred);
      ysLstDestroy( deferred, (ysmff)0);
    }
    yccfpPrint( fp, "#endif /* %s_DEFINED */\n\n", guard);
  }
}




STATICF void yccpGenExDecl( ycctx* ctx, yccfp* fp, yrobj* ex, boolean fwd)
{
  CONST char* name;
  CONST char* sname;
  yslst* mbrs = yrStructData(ex).mbrs;
  yslst* nested;
  ysle* le;
  yrstrmbr* mem;
  CONST char* guard = (char*)0;

  if ( !yccpInClassScope( ctx, ex) )
  {
    guard = yccpFlattenAbsName( ctx, ex);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }
  name = yccpSimpleName( ctx, ex);
  yccfpPrint( fp, "class %s : public %sUserException\n", name, YCP_CORBA(ctx));
  yccfpPrint( fp, "{\npublic:\n");

  ycgPushScope( ctx, ex);
  yccfpIncIndent( fp);
  sname = yccpAbsoluteName( ctx, ex);     

    
  nested = yrGetContents(ex);
  if ( nested )
  {
    for (le = ysLstHead( nested); le; le = ysLstNext(le))
      yccpGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
  }

    
  if ( mbrs )
  {
    for (le = ysLstHead(yrStructData(ex).mbrs); le; le = ysLstNext(le))
    {
      mem = (yrstrmbr*) ysLstVal(le);
      if ( yrGetKind(mem->type) == yrdkSequence )
        yccpGenSeqDecl( ctx, fp, (yrobj*)0, mem->type);
      else if ( yrGetKind(mem->type) == yrdkArray )
      {
        DISCARD yccpAnonArrayName( ctx, mem->type, mem->name);
        yccpGenArrayDecl( ctx, fp, mem->type);
      }
    }
  }

    
  yccfpPrint( fp, "%s();\n%s( const %s&);\n", name, name, sname);
  if ( mbrs && (ysLstCount(mbrs) > 0) )     
  {
    yccfpPrint( fp, "%s( ", name);
    for (le = ysLstHead(mbrs); le; le = ysLstNext(le))
    {
      mem = (yrstrmbr*) ysLstVal(le);
      yccpGenParamType( ctx, fp, mem->type, YOMODE_IN);   
      yccfpPrint( fp, "%s", ysLstNext(le) ? ", " : " ");
    }
    yccfpPrint( fp, ");\n");
  }
  yccfpPrint( fp, "~%s();\n", name);
  yccfpPrint( fp, "%s& operator=( const %s&);\n\n", sname, sname);
    
  yccfpPrint( fp, "static %s* _narrow( %sException*);\n",
              sname, YCP_CORBA(ctx));
  yccpGenOraExtDecls( ctx, fp, ex);

    
  if ( mbrs && (ysLstCount(mbrs) > 0) )
  {
    for (le = ysLstHead(mbrs); le; le = ysLstNext(le))
    {
      mem = (yrstrmbr*) ysLstVal(le);
      yccpGenField(ctx, fp, mem->type, mem->name);
    }
  }

  DISCARD ycgPopScope( ctx);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "};\n");
  yccpGenTypeCode( ctx, fp, ex, name, FALSE);
  if ( guard )
  {
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
  }
  else
    yccfpPrint( fp, "\n");
}





STATICF void yccpGenStructDecl(ycctx* ctx, yccfp* fp, yrobj* sobj, boolean fwd)
{
  ysle* le;
  CONST char* name;
  yrstrmbr* mem;
  CONST char* guard = (char*)0;

  if ( !yccpInClassScope( ctx, sobj) )
  {
    guard = yccpFlattenAbsName( ctx, sobj);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }
  name = yccpSimpleName( ctx, sobj);
  if ( fwd )
  {
    yccfpPrint( fp, "struct %s;\n", name);
  }
  else
  {
    yccfpPrint( fp, "struct %s\n{\n", name);
    ycgPushScope( ctx, sobj);
    yccfpIncIndent( fp);

      
    for (le = ysLstHead( yrGetContents(sobj)); le; le = ysLstNext(le))
      yccpGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);

      
    for (le = ysLstHead(yrStructData(sobj).mbrs); le; le = ysLstNext(le))
    {
      mem = (yrstrmbr*) ysLstVal(le);
      if ( yrGetKind(mem->type) == yrdkSequence )
        yccpGenSeqDecl( ctx, fp, (yrobj*)0, mem->type);
      else if ( yrGetKind(mem->type) == yrdkArray )
      {
        DISCARD yccpAnonArrayName( ctx, mem->type, mem->name);
        yccpGenArrayDecl( ctx, fp, mem->type);
      }
    }
      
    for (le = ysLstHead(yrStructData(sobj).mbrs); le; le = ysLstNext(le))
    {
      mem = (yrstrmbr*) ysLstVal(le);
      yccpGenField(ctx, fp, mem->type, mem->name);
    }
    yccpGenOraExtDecls( ctx, fp, sobj);
    DISCARD ycgPopScope( ctx);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "};\n");

    yccpGenTypeCode( ctx, fp, sobj, name, FALSE);
    if ( !ycgScopeDefer( ctx, sobj) )
      yccpGenAnyFuncs( ctx, fp, sobj, FALSE);
#ifdef NEVER
    yccpGenStructTVar( ctx, fp, sobj, FALSE);
#else
    yccfpPrint( fp, "YOTVAR_STRUCT_DECL(%s);\n", name);
#endif
  }

  if ( guard )
  {
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
  }
}




 
STATICF void yccpGenArrayDeclr( ycctx* ctx, yccfp* fp, yrobj* arr,
        CONST char* declr)
{
  yccfpPrint( fp, "%s", declr);
  for (; yrGetKind(arr) == yrdkArray; arr = yrArrayData(arr).elmtype)
  {
    yccfpPrint( fp, "[%u]", yrArrayData(arr).length);
  }
}





STATICF void yccpGenField(ycctx* ctx, yccfp* fp, yrobj* type, CONST char* name)
{
  CONST char* kwdpfx = (*ctx->lang->kwdchk)( ctx, name) ? "_" : "";

  switch (yrGetKind(type))
  {
    case yrdkInterface:
      yccfpPrint( fp, "%s_var %s%s;\n", yccpTypeName(ctx, type), kwdpfx, name);
      break;
    case yrdkArray:
    {
      CONST char* tname = yccpAnonArrayName( ctx, type, name);

      yccfpPrint( fp, "%s %s%s;\n", tname, kwdpfx, name);
      break;
    }
    case yrdkString:
      yccfpPrint( fp, "%sString_var %s%s;\n", YCP_CORBA(ctx), kwdpfx, name);
      break;
    case yrdkSequence:
    {
      char* tname = yccpSeqName( ctx, type);

      yccfpPrint( fp, "%s %s%s;\n", tname, kwdpfx, name);
      ysmGlbFree( (dvoid*)tname);
      break;
    }
    case yrdkPrimitive:
      if ( yrPrimData(type).kind == yrpkstring )
      {
        yccfpPrint( fp, "%sString_var %s%s;\n", YCP_CORBA(ctx), kwdpfx, name);
        break;
      }
      
    default:
      yccfpPrint(fp,"%s %s;\n", yccpTypeName(ctx, type), name);
      break;
  }
}




STATICF void yccpGenUnionDecl( ycctx* ctx, yccfp* fp, yrobj* uobj, boolean fwd)
{
  boolean hasDefault = FALSE;
  boolean hasGaps = TRUE;
  CONST char* name;
  CONST char* sname;
  ysle* le;
  yslst* mbrs;
  yrunmbr* mem;
  yrobj* disc;
  CONST char* guard = (char*)0;
  ycsym* syminfo;
  
  name = yccpSimpleName( ctx, uobj);
  if ( fwd )
  {
    yccfpPrint( fp, "class %s;\n", name);
    return;
  }

  if ( !yccpInClassScope( ctx, uobj) )
  {
    guard = yccpFlattenAbsName( ctx, uobj);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }

  yccfpPrint( fp, "class %s\n{\npublic:\n", name);
  ycgPushScope( ctx, uobj);
  yccfpIncIndent( fp);
  sname = yccpAbsoluteName( ctx, uobj);

      
  for (le = ysLstHead( yrGetContents(uobj)); le; le = ysLstNext(le))
    yccpGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);

      
  mbrs = yrUnionData(uobj).arms;
  for (le = ysLstHead(mbrs); le; le = ysLstNext(le))
  {
    mem = (yrunmbr*) ysLstVal(le);
    if ( yrGetKind(mem->type) == yrdkSequence )
      yccpGenSeqDecl( ctx, fp, (yrobj*)0, mem->type);
    else if ( yrGetKind(mem->type) == yrdkArray )
    {
      DISCARD yccpAnonArrayName( ctx, mem->type, mem->name);
      yccpGenArrayDecl( ctx, fp, mem->type);
    }
  }

    
  yccfpPrint( fp, "%s();\n", name);
  yccfpPrint( fp, "%s( const %s&);\n", name, sname);
  yccfpPrint( fp, "~%s();\n", name);
  yccfpPrint( fp, "%s& operator=( const %s&);\n\n", sname, sname);

    
  disc = yrUnionData(uobj).disctype;
  yccfpPrint( fp, "void _d( ");
  yccpGenParamType( ctx, fp, disc, YOMODE_IN);
  yccfpPrint( fp, ");\n");
  yccpGenParamType( ctx, fp, disc, YOMODE_RETURN);
  yccfpPrint( fp, " _d() const;\n\n");

    
  for ( le = ysLstHead(mbrs); le; le = ysLstNext(le))
  {
    mem = (yrunmbr*) ysLstVal(le);
    if ( yotkGetKind(mem->label._type) == yotkNull )       
      hasDefault = TRUE;
    yccpGenUnionMbrDecls( ctx, fp, mem);
  }

    
  if ( !hasDefault )
  {
    yrobj* base = disc;

    syminfo = ycSymLookup( ctx->symtbl, uobj);
    if ( syminfo->lang.cplus.union_dflt != 0 )
      hasGaps = ((syminfo->lang.cplus.union_dflt == 1) ? TRUE : FALSE);
    else
    {
      if ( yrGetKind( disc) == yrdkAlias )
        base = yrGetAliasBaseType(disc);
      if ( yrGetKind(base) == yrdkPrimitive )
      {
        switch (yrPrimData(base).kind)
        {
          case yrpkboolean:
            hasGaps = ( ysLstCount( mbrs) <= 1);
            break;
          case yrpkchar:            
          case yrpkoctet:
            hasGaps = (ysLstCount(mbrs) < UB1MAXVAL);
            break;
          case yrpklong:
          case yrpkulong:
          case yrpkshort:
          case yrpkushort:
            hasGaps = TRUE;          
            break;
          default:
            yseThrow( YC_EX_FAILURE);
            break;    
        }
      }
      else    
      {
        hasGaps = (ysLstCount(mbrs) < ysLstCount( yrEnumData(base).mbrs));
      }
      syminfo->lang.cplus.union_dflt = (hasGaps ? 1 : -1);
    }

    if ( hasGaps )             
      yccfpPrint( fp, "void _default();\n\n");
  }

    
  yccpGenOraExtDecls( ctx, fp, uobj);

    
  yccfpDecIndent( fp);
  yccfpPrint( fp, "private:\n");
  yccfpIncIndent( fp);
  yccpGenField( ctx, fp, disc, "_disc");
  yccfpPrint( fp, "%s* _data;\n", YCCVOID(ctx));

  DISCARD ycgPopScope( ctx);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "};\n");

  yccpGenTypeCode( ctx, fp, uobj, name, FALSE);
  if ( !ycgScopeDefer( ctx, uobj) )
    yccpGenAnyFuncs( ctx, fp, uobj, FALSE);
#ifdef NEVER
  yccpGenStructTVar( ctx, fp, uobj, FALSE);
#else
    yccfpPrint( fp, "YOTVAR_STRUCT_DECL(%s);\n", name);
#endif

  if ( guard )
  {
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
  }
}




STATICF void yccpGenAliasDecl(ycctx* ctx, yccfp* fp, yrobj* alias, boolean fwd)
{
  yrobj* base;
  CONST char* pname;
  CONST char* name = yccpSimpleName( ctx, alias);
  yrobj* parent = yrAliasData(alias).type;
  CONST char* guard = (char*)0;

  if ( !yccpInClassScope( ctx, alias) )
  {
    guard = yccpFlattenAbsName( ctx, alias);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }

  base = yrGetAliasBaseType( alias);
  switch (yrGetKind( base))
  {
    case yrdkInterface:
      
      pname = ((yrGetKind(parent) == yrdkAlias) ?
                   yccpAbsoluteName( ctx, parent) :
                   yccpAbsoluteName( ctx, base));
      yccfpPrint( fp, "typedef %s %s;\n", pname, name);
      yccfpPrint( fp, "typedef %s_var %s_var;\n", pname, name);
      yccfpPrint( fp, "typedef %s_ptr %s_ptr;\n", pname, name);
      yccfpPrint( fp, "typedef %sRef %sRef;\n", pname, name);
      break;
    case yrdkStruct:
    case yrdkUnion:
      
      pname = ((yrGetKind(parent) == yrdkAlias) ?
                 yccpAbsoluteName( ctx, parent) :
                 yccpAbsoluteName( ctx, base));
      yccfpPrint( fp, "typedef %s %s;\n", pname, name);
      yccfpPrint( fp, "typedef %s_var %s_var;\n", pname, name);
      break;
    case yrdkException:
    case yrdkEnum:
      
      pname = ((yrGetKind(parent) == yrdkAlias) ?
                 yccpAbsoluteName( ctx, parent) :
                 yccpAbsoluteName( ctx, base));
      yccfpPrint( fp, "typedef %s %s;\n", pname, name);
      break;
    case yrdkPrimitive:
      
      switch (yrPrimData(base).kind)
      {
        case yrpkany:
          yccfpPrint( fp, "typedef %sAny %s;\n", YCP_CORBA(ctx), name);
          yccfpPrint( fp, "typedef %sAny %s_var;\n", YCP_CORBA(ctx), name);
          break;
        case yrpkTypeCode:
          yccfpPrint( fp, "typedef %sTypeCode %s;\n", YCP_CORBA(ctx), name);
          yccfpPrint( fp, "typedef %sTypeCode_var %s_var;\n",
                      YCP_CORBA(ctx), name);
          yccfpPrint( fp, "typedef %sTypeCode_ptr %s_ptr;\n", 
                      YCP_CORBA(ctx), name);
          yccfpPrint( fp, "typedef %sTypeCodeRef %sRef;\n",
                      YCP_CORBA(ctx), name);
          break;
        case yrpkstring:
          yccfpPrint( fp, "typedef char* %s;\n", name);
          yccfpPrint( fp, "typedef %sString_var %s_var;\n",
                      YCP_CORBA(ctx), name);
          break;
        default:
          yccfpPrint( fp, "typedef %s %s;\n", 
                      yccGetPrimitiveName( ctx, yrPrimData(base).kind), name);
          break;
        }
      break;
    case yrdkString:
      
      yccfpPrint( fp, "typedef char* %s;\n", name);
      yccfpPrint( fp, "typedef %sString_var %s_var;\n", YCP_CORBA(ctx), name);
      break;
    case yrdkArray:
      
      if ( yrGetKind(parent) == yrdkAlias )
      {
        pname = yccpAbsoluteName( ctx, parent);
        yccfpPrint( fp, "typedef %s %s;\n", pname, name);
        yccfpPrint( fp, "typedef %s_var %s_var;\n", pname, name);
        yccfpPrint( fp, "typedef %s_forany %s_forany;\n", pname, name);
        yccfpPrint( fp, "typedef %s_slice %s_slice;\n", pname, name);
        yccfpPrint( fp, "%s_slice* %s_alloc();\n", name, name);
        yccfpPrint( fp, "%s_slice* %s_dup( const %s_slice*);\n",
                    name, name, name);
        yccfpPrint( fp, "void %s_free( const %s_slice*);\n", name, name);
      }
      else
      {


        yrobj* scope = yrGetDefinedIn(alias);

        if ( yrGetKind(scope) == yrdkModule )
          ycgPushScope( ctx, scope);
        yccpGenArrayDecl( ctx, fp, alias);
        if ( yrGetKind(scope) == yrdkModule )
          DISCARD ycgPopScope( ctx);
      }
      break;
    case yrdkSequence:
      
      if ( yrGetKind(parent) == yrdkAlias )
      {
        pname = yccpAbsoluteName( ctx, parent);
        yccfpPrint( fp, "typedef %s %s;\n", pname, name);
        yccfpPrint( fp, "typedef %s_var %s_var;\n", pname, name);
      }
      else if ( (yrSeqData(base).bound == 0) && 
                (ctx->lang->flags & YCCP_BUILTIN_SEQ_FLG) &&
                (yrGetKind(yrSeqData(base).elmtype) == yrdkPrimitive) )
      {
        pname = yccpSimpleName( ctx, base);
        yccfpPrint( fp, "typedef %s %s;\n", pname, name);
        yccfpPrint( fp, "typedef %s_var %s_var;\n", pname, name);
      }
      else
        yccpGenSeqDecl( ctx, fp, alias, base);
      break;
    default:
      yseThrow( YC_EX_FAILURE);
      break;   
  }
  yccpGenTypeCode( ctx, fp, alias, name, FALSE);
  if ( guard )
  {
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
  }
  else
    yccfpPrint( fp, "\n");
}



STATICF void yccpGenEnumDecl(ycctx* ctx, yccfp* fp, yrobj* eobj, boolean fwd)
{
  CONST char* name;
  CONST char* ename;
  yslst* mbrs;
  ysle* le;
  boolean needmax = TRUE;      
  CONST char* guard = (char*)0;

  if ( !yccpInClassScope( ctx, eobj) )
  {
    guard = yccpFlattenAbsName( ctx, eobj);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }
  name = yccpSimpleName( ctx, eobj);
  mbrs = yrEnumData(eobj).mbrs;

  yccfpPrint( fp, "enum %s\n{\n", name);
  yccfpIncIndent( fp);
  for ( le = ysLstHead( mbrs); le; le = ysLstNext(le))
  {
    yrobj* mbr = (yrobj*) ysLstVal(le);       

    ename = yccpSimpleName( ctx, mbr);
    yccfpPrint( fp, "%s%c\n", ename, ysLstNext(le) ? ',' : ' ');
    if ( *((ub4*)yrConstData(mbr).val._value) >= UB2MAXVAL )
      needmax = FALSE;
  }

    
  if ( needmax || ysLstCount(mbrs) < UB2MAXVAL )     
  {
    yccfpPrint( fp, ", ORA_CORBA_ENUM_MAX(%s)\n", name);
  }

  yccfpDecIndent( fp);
  yccfpPrint( fp, "};\n");
  yccpGenTypeCode( ctx, fp, eobj, name, FALSE);
  if ( !ycgScopeDefer( ctx, eobj) )
    yccpGenAnyFuncs( ctx, fp, eobj, FALSE);
  if ( guard )
  {
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
  }
  else
    yccfpPrint( fp, "\n");
}





STATICF void yccpGenSeqDecl( ycctx* ctx, yccfp* fp, yrobj* nm, 
                             yrobj* seq)
{
  ub4 bound = yrSeqData(seq).bound;
  char* ename;
  CONST char* name;

  if ( (bound == 0) && (ctx->lang->flags & YCCP_BUILTIN_SEQ_FLG) &&
      (yrGetKind(yrSeqData(seq).elmtype) == yrdkPrimitive) )
    return;    

  ename = yccpElemName( ctx, seq);
  name = yccpSimpleName( ctx, nm ? nm : seq);
  yccfpPrint( fp, "class %s\n{\npublic:\n", name);
  ycgPushScope( ctx, seq);
  yccfpIncIndent( fp);

  
    
  yccfpPrint( fp, "%s();\n", name);
  yccfpPrint( fp, "%s( const %s&);\n", name, name);
  if ( bound == 0 )
  {
      
    yccfpPrint( fp, "%s( ub4 _max);\n", name);
    yccfpPrint( fp, "%s( ub4 _max, ", name);
  }
  else
  {
      
    yccfpPrint( fp, "%s( ", name);
  }
  yccfpPrint( fp, "ub4 _length, %s* _data, boolean _release = FALSE);\n",
                      ename);

    
  yccfpPrint( fp, "~%s();\n", name);
  yccfpPrint( fp, "%s& operator=( const %s&);\n\n", name, name);
  
  yccfpPrint( fp, "ub4 maximum() const;\n");
  yccfpPrint( fp, "ub4 length() const;\n");
  yccfpPrint( fp, "void length(ub4);\n\n");

  
  yccfpPrint( fp, "%s& operator[]( ub4 index);\n", ename);
  yccfpPrint( fp, "const %s& operator[]( ub4 index) const;\n\n", ename);

  
  yccfpPrint( fp, "static %s* allocbuf( ub4 _nelems);\n", ename);
  yccfpPrint( fp, "static void freebuf( %s* _buff);\n\n", ename);
  
  
  yccpGenOraExtDecls( ctx, fp, seq);     
  if ( bound == 0 )
  {
    yccfpPrint( fp, "void reallocbuf( ub4 _nelems);\n");
    yccfpPrint( fp, "void maximum( ub4 _len);\n");
  }

  
  yccfpDecIndent( fp);
  yccfpPrint( fp, "private:\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "void _copy( const %s&);\n", name);
  yccfpPrint( fp, "ub4 _maximum;\nub4 _length;\n%s* _buffer;\n", ename);
  yccfpPrint( fp, "boolean _release;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "};\n\n");
  DISCARD ycgPopScope(ctx);    

  
  if ( !ycgScopeDefer( ctx, seq) )
  {
    yccpGenExtractor( ctx, fp, seq, name, FALSE);
    yccpGenInserter( ctx, fp, seq, name, FALSE);
    yccpGenCopyInserter( ctx, fp, seq, name, FALSE);
    yccfpPrint( fp, "\n");
  }

  
  if ( !nm )
    yccpGenTypeCode( ctx, fp, seq, name, FALSE);
#ifdef NEVER
  yccpGenSeqTVar( ctx, fp, seq, FALSE);
#else
  yccfpPrint( fp, "YOTVAR_SEQ_DECL(%s, %s);\n", name, ename);
#endif
  ysmGlbFree( (dvoid*)ename);
}




STATICF void yccpGenArrayDecl( ycctx* ctx, yccfp* fp, yrobj* type)
{
  yrobj* etype;
  yrobj* p;
  CONST char* ename = (char*)0;
  yrobj* array = type;
  CONST char* name = yccpSimpleName(ctx, type);
  CONST char* pfx = yccpInClassScope(ctx, type) ? "static " : "";

  while ( yrGetKind(array) == yrdkAlias )    
    array = yrAliasData(array).type;

  etype = yrArrayData(array).elmtype;
  while ( yrGetKind(etype) == yrdkArray )    
    etype = yrArrayData(etype).elmtype;
  ename = yccpTypeName( ctx, etype);

    
  yccfpPrint( fp, "typedef %s %s", ename, name);
  for (p = array; yrGetKind(p) == yrdkArray; p = yrArrayData(p).elmtype)
  {
    yccfpPrint( fp, "[%u]", yrArrayData(p).length);
  }

    
  yccfpPrint( fp, ";\n");
  yccfpPrint( fp, "typedef %s %s_slice", ename, name);
  for (p = yrArrayData(array).elmtype; yrGetKind(p) == yrdkArray; 
        p = yrArrayData(p).elmtype)
  {
    yccfpPrint( fp, "[%u]", yrArrayData(p).length);
  }
  yccfpPrint( fp, ";\n");

    
  yccfpPrint( fp, "%s%s_slice* %s_alloc();\n", pfx, name, name);
  yccfpPrint( fp, "%s%s_slice* %s_dup( const %s_slice*);\n", 
              pfx, name, name, name);
  yccfpPrint( fp, "%svoid %s_free( %s_slice*);\n", pfx, name, name);

    
#ifdef NEVER
  yccpGenArrayTVar( ctx, fp, array, FALSE);
#else
  yccfpPrint( fp, "YOTVAR_ARRAY_DECL(%s);\n", name);
  yccfpPrint( fp, "YOFORANY_DECL(%s);\n", name);
#endif

    
  if ( !ycgScopeDefer( ctx, array) )
  {
    yccpGenExtractor( ctx, fp, array, name, FALSE);
    yccpGenCopyInserter( ctx, fp, array, name, FALSE);
  }
  yccfpPrint( fp, "\n");
}




STATICF void yccpGenAttrDecl(ycctx* ctx, yccfp* fp, yrobj* attr)
{
  CONST char* name;

  name = yccpSimpleName( ctx, attr);

    
  yccpGenParamType( ctx, fp, yrAttrData(attr).type, YOMODE_RETURN);
  yccfpPrint( fp, " %s( %sEnvironment& env, ", name, YCP_CORBA(ctx));
  yccfpPrint( fp, "ysevt* usrevt = (ysevt*)0);\n");

    
  if ( yrAttrData(attr).mode != YR_ATTR_RO )
  {
    yccfpPrint( fp, "void %s( ", name);
    yccpGenParamType( ctx, fp, yrAttrData(attr).type, YOMODE_IN);
    yccfpPrint( fp, " _val, %sEnvironment& env, ", YCP_CORBA(ctx));
    yccfpPrint( fp, "ysevt* usrevt = (ysevt*)0);\n");
  }
}





STATICF void yccpGenOpDecl(ycctx* ctx, yccfp* fp, yrobj* op)
{
  CONST char* name;
  ysle* le;
  ycgkwdfp kwdfp = ctx->lang->kwdchk;

  name = yccpSimpleName( ctx, op);
  yccpGenParamType( ctx, fp, yrOpData(op).rettype, YOMODE_RETURN);
  yccfpPrint( fp, " %s( ", name);

  if ( yrOpData(op).pars )
  {
    for ( le = ysLstHead( yrOpData(op).pars); le; le = ysLstNext(le))
    {
      yrpar* par = (yrpar*) ysLstVal(le);

      yccpGenParamType( ctx, fp, par->type, par->mode);
      yccfpPrint( fp, " %s%s, ", 
                  ((*kwdfp)(ctx, par->name) ? "_" : ""), par->name);
    }
  }
    
  yccfpPrint( fp, "%sEnvironment& env, ", YCP_CORBA(ctx));
  yccfpPrint( fp, "ysevt* usrevt = (ysevt*)0);\n");
}





STATICF void yccpGenOraExtDecls( ycctx* ctx, yccfp* fp, yrobj* type)
{
  switch (yrGetKind( ycgScope(ctx)))
  {
    case yrdkStruct:             
    case yrdkUnion:
    case yrdkException:
    case yrdkInterface:
    case yrdkSequence:
    {
      yccfpPrint( fp, "/* OMN Extensions */\n");
      yccfpPrint( fp, "static %sTypeCode_ptr _typecode();\n", YCP_CORBA(ctx));
      break;
    }
    default:
      break;
  }
}




STATICF void yccpGenUnionMbrDecls( ycctx* ctx, yccfp* fp, yrunmbr* mbr)
{
  yrobj* type;
  yrobj* base;
  yrdk base_kind;
  CONST char* tname;
  CONST char* kwdpfx = ((*ctx->lang->kwdchk)( ctx, mbr->name) ? "_" : "");

  type = mbr->type;
  if ( yrGetKind(type) == yrdkAlias )
    base = yrGetAliasBaseType( type);
  else
    base = type;
  base_kind = yrGetKind( base);
  tname = yccpTypeName( ctx, type);

  for (;;)                    
  {
    switch (base_kind)
    {
      case yrdkInterface:
          
        yccfpPrint( fp, "void %s%s( %s_ptr);\n", kwdpfx, mbr->name, tname);
        yccfpPrint( fp, "%s_ptr %s%s() const;\n\n", tname, kwdpfx, mbr->name);
        return;
      case yrdkEnum:
          
        yccfpPrint( fp, "void %s%s( %s);\n", kwdpfx, mbr->name, tname);
        yccfpPrint( fp, "%s %s%s() const;\n\n", tname, kwdpfx, mbr->name);
        return;
      case yrdkStruct:
      case yrdkUnion:
      case yrdkException:
      case yrdkSequence:
          
        yccfpPrint( fp, "void %s%s( const %s&);\n", kwdpfx, mbr->name, tname);
        yccfpPrint( fp, "%s& %s%s();\n", tname, kwdpfx, mbr->name);
        yccfpPrint( fp, "const %s& %s%s() const;\n\n", 
                    tname, kwdpfx, mbr->name);
        return;
      case yrdkArray:
          
        yccfpPrint( fp, "void %s%s( %s);\n", kwdpfx, mbr->name, tname);
        yccfpPrint( fp, "%s_slice* %s%s() const;\n\n", 
                    tname, kwdpfx, mbr->name);
        return;
      case yrdkString:
          
        yccfpPrint( fp, "void %s%s( char*);\n", kwdpfx, mbr->name);
        yccfpPrint( fp, "void %s%s( const char*);\n", kwdpfx, mbr->name);
        yccfpPrint( fp, "void %s%s( const %sString_var&);\n",
                    kwdpfx, mbr->name, YCP_CORBA(ctx));
        yccfpPrint( fp, "const char* %s%s() const;\n\n", kwdpfx, mbr->name);
        return;
      case yrdkPrimitive:
          
        switch (yrPrimData(base).kind)
        {
          case yrpkstring:
            base_kind = yrdkString;
            break;
          case yrpkTypeCode:
            base_kind = yrdkInterface;
            break;
          case yrpkany:
            base_kind = yrdkStruct;
            break;
          default:
            base_kind = yrdkEnum;
            break;
        }
        break;
      default:
        yseThrow(YC_EX_FAILURE);
        break;
    }
  }
}






STATICF void yccpGenDeferredDecls( ycctx* ctx, yccfp* fp, yslst* deferred)
{
  ysle* le;

  for ( le = ysLstHead(deferred); le; le = ysLstNext(le))
  {
    yrobj* obj = (yrobj*) ysLstVal(le);

    switch (yrGetKind(obj))
    {
      case yrdkStruct:
      case yrdkUnion:
      case yrdkEnum:
        yccpGenAnyFuncs( ctx, fp, obj, FALSE);
        break;
      default:         
        break;
    }
  }
}
