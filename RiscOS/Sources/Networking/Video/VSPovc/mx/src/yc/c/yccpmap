/* mx/src/yc/yccpmap.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCCP0_ORACLE
#include <yccp0.h>
#endif
#ifndef YSL_ORACLE
#include <ysl.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif


STATICF boolean yccpSymFlush( dvoid* usrp, dvoid* elm);
STATICF void yccpmap(ycctx *ctx);

STATICF void yccpmap(ycctx *ctx)
{
  char  base[SYSFP_MAX_PATHLEN];
  CONST char* path;
  CONST char* hdr_suffix;
  CONST char* src_suffix;
  ub4 baselen;
  ycfile* noreg files;
  noreg ub4 fcount;
  boolean hdronly, tmpl;
  ub4 hdridx, clntidx, srvridx, thidx, tcidx;

  NOREG(files);
  NOREG(fcount);
  hdridx = clntidx = srvridx = thidx = tcidx = (ub4)0;

    
  fcount = (ub4) 1;
  hdridx = (ub4) 0;
  if ( !(hdronly = ysResGetBool("mnidlc.header-only")) )
  {
    clntidx = (ub4) fcount++;
    srvridx = (ub4) fcount++;
  }
  if ( (tmpl = ysResGetBool("mnidlc.server-template")) )
  {                                    
    thidx = (ub4) fcount++;
    tcidx = (ub4) fcount++;
  }

    
  sysfpExtractBase(base, ctx->srcnm);
  baselen = strlen(base);
  path = ysResGetLast("mnidlc.outputpath");
  hdr_suffix = ysResGetLast( "mnidlc.header-suffix");
  if ( !hdr_suffix )
    hdr_suffix = YC_CPHEADER;
  src_suffix = ysResGetLast( "mnidlc.source-suffix");
  if ( !src_suffix )
    src_suffix = YC_CPSOURCE;

  files = (ycfile*) ysmGlbAlloc(sizeof(ycfile) * fcount, "ycfile");
  sysfpForm(files[hdridx].target, path, base, hdr_suffix);
  if ( !hdronly )
  {
    base[baselen] = 'C';
    base[baselen+1] = '\0';
    sysfpForm(files[clntidx].target, path, base, src_suffix);
    base[baselen] = 'S';
    sysfpForm(files[srvridx].target, path, base, src_suffix);
  }
  if ( tmpl )
  {
    base[baselen] = 'I';
    base[baselen+1] = '\0';
    sysfpForm(files[thidx].target, path, base, hdr_suffix);
    sysfpForm(files[tcidx].target, path, base, src_suffix);
  }
  if ( !ycFileInit( (ycfile*)files, (ub4)fcount, path) )
  {                                         
    ysmGlbFree((dvoid*)files);
    return;
  }

  yseTry
  {
      
    base[baselen] = '\0';
    yccphdr(ctx, base, &files[hdridx]);

#ifdef NOT_YET
    if ( tmpl )
      yccptmpl(ctx, base, &filex[thidx]);
#endif

    if ( !hdronly )
    {
      yccpclnt(ctx, base, &files[clntidx]);
#ifdef NOT_YET
      yccpsrv(ctx, base, &files[srvridx]);
#endif
    }
    ycSymTblFlush( ctx->symtbl, (ycsymwcb)yccpSymFlush, (dvoid*)0);
    ycFileRename((ycfile*)files, (ub4)fcount);
  }
  yseCatchAll
  {
    CONST char* fn;
    sword ln;
    ub4 i;

    yseGetLoc(&fn, &ln);
    ysRecord( YCMSG(0), YCERRSEV, YSLSTR(ysidToStr(yseExid)), 
              YSLSTR(fn), YSLSB4(ln), YSLEND);
    for ( i = (ub4)0; i < (ub4)fcount; i++)
      DISCARD sysfpRemove(files[i].newtmp);
  }
  yseEnd
  ysmGlbFree((dvoid*)files);
}





void yccpGenTypeCode( ycctx* ctx, yccfp* fp, yrobj* type, CONST char* name, 
                      boolean defn)
{
  if ( defn )
  {
    CONST char* parent = yccpParentPrefix( ctx, type);

    yccfpPrint( fp, "%s%sTypeCode_ptr %s_tc_%s", 
                YCCEXREF(ctx), YCP_CORBA(ctx), parent ? parent : "",  name);
  }
  else
  {
    yccfpPrint( fp, "%s%sTypeCode_ptr _tc_%s;\n", 
                yccpInClassScope( ctx, type) ? "static " : YCCEXREF(ctx),
                YCP_CORBA(ctx), name);
  }
}




void yccpGenAnyFuncs( ycctx* ctx, yccfp* fp, yrobj* type, boolean defn)
{
  CONST char* tname;

  tname = yccpScopedName( ctx, type);
  yccpGenInserter( ctx, fp, type, tname, defn);
  yccpGenCopyInserter( ctx, fp, type, tname, defn);
  yccpGenExtractor( ctx, fp, type, tname, defn);
  yccfpPrint( fp, "\n");
}





void yccpGenExtractor( ycctx* ctx, yccfp* fp, yrobj* type, 
                       CONST char* tname, boolean defn)
{
  switch ( yrGetKind(type))
  {
    case yrdkInterface:
      yccfpPrint( fp, "boolean operator>>=( const %sAny& _any, ", 
                  YCP_CORBA(ctx));
      yccfpPrint( fp, "%s_ptr& _dest)", tname);
      break;
    case yrdkEnum:
      yccfpPrint( fp, "boolean operator>>=( const %sAny& _any, ",
                  YCP_CORBA(ctx));
      yccfpPrint( fp, "%s& _dest)", tname);
      break;
    case yrdkStruct:
    case yrdkUnion:
    case yrdkSequence:
      yccfpPrint( fp, "boolean operator>>=( const %sAny& _any, ",
                  YCP_CORBA(ctx));
      yccfpPrint( fp, "%s*& _dest)", tname);
      break;
    case yrdkArray:
      yccfpPrint( fp, "boolean operator>>=( const %sAny& _any, ",
                  YCP_CORBA(ctx));
      yccfpPrint( fp, "%s_forany& _dest)", tname);
      break;
    case yrdkAlias:

    default:
      return;
      break;      
  }
  if ( !defn )
    yccfpPrint( fp, ";\n");
  else
  {
    yccfpPrint( fp, "\n{\n");
    yccfpIncIndent( fp);
    
    yccfpPrint( fp, "if ( %s%s::_typecode == _any.type() )\n", 
                tname, yrGetKind(type) == yrdkArray ? "_forany" : "");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "return FALSE;\n");
    yccfpDecIndent( fp);

    switch ( yrGetKind(type))
    {
      case yrdkEnum:
        yccfpPrint( fp, "_dest = *(%s*)_any.value();\n");
        break;
      case yrdkStruct:
      case yrdkUnion:
      case yrdkSequence:
      case yrdkInterface:
        yccfpPrint( fp, "if ( _any.is_flat() )\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "_dest = new %s( (%s__cmap*)_any.value());\n", 
                    tname, tname);
        yccfpDecIndent( fp);
        yccfpPrint( fp, "else\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "_dest = (%s*)_any.value();\n");
        yccfpDecIndent( fp);
        break;
      case yrdkArray:
        
        break;
      case yrdkAlias:
        
      default:
        return;
        break;      
    }

    
    yccfpPrint( fp, "return TRUE;\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n\n");
  }
}




void yccpGenInserter( ycctx* ctx, yccfp* fp, yrobj* type, 
                      CONST char* tname, boolean defn)
{
  switch ( yrGetKind(type))
  {
    case yrdkInterface:
      yccfpPrint( fp, "void operator<<=( %sAny& _any, ", YCP_CORBA(ctx));
      yccfpPrint( fp, "%s_ptr* _val)", tname);
      if ( defn )
      {
        yccfpPrint( fp, "\n{\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "_any.replace( %s::_typecode(), (%s*)_val, ",
                    tname, YCCVOID(ctx));
        yccfpPrint( fp, "FALSE, FALSE);\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");
      }
      else
        yccfpPrint( fp, ";\n");
      break;
    case yrdkEnum:
      yccfpPrint( fp, "void operator<<=( %sAny& _any, ", YCP_CORBA(ctx));
      yccfpPrint( fp, "%s _val)", tname);
      if ( defn )
      {
        yccfpPrint( fp, "\n{\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "%s* _ptr = new %s;\n\n", tname, tname);
        yccfpPrint( fp, "*_ptr = _val;\n");
        yccfpPrint( fp, "_any.replace( %s::_typecode(), (%s*)_ptr, ",
                    tname, YCCVOID(ctx));
        yccfpPrint( fp, "FALSE, FALSE);\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");
      }
      else
        yccfpPrint( fp, ";\n");
      break;
    case yrdkSequence:
    case yrdkStruct:
    case yrdkUnion:
      yccfpPrint( fp, "void operator<<=( %sAny& _any, ", YCP_CORBA(ctx));
      yccfpPrint( fp, "%s* _val)", tname);
      if ( defn )
      {
        yccfpPrint( fp, "\n{\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "_any.replace( %s::_typecode(), (%s*)_val, ",
                    tname, YCCVOID(ctx));
        yccfpPrint( fp, "FALSE, FALSE);\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");
      }
      else
        yccfpPrint( fp, ";\n");
      break;
    case yrdkAlias:

    default:
      break;
  }
}




void yccpGenCopyInserter( ycctx* ctx, yccfp* fp, yrobj* type, 
                          CONST char* tname, boolean defn)
{
  switch ( yrGetKind(type))
  {
    case yrdkInterface:
      yccfpPrint( fp, "void operator<<=( %sAny& _any, ", YCP_CORBA(ctx));
      yccfpPrint( fp, "%s_ptr _val)", YCP_CORBA(ctx), tname);
      if ( defn )
      {
        yccfpPrint( fp, "\n{\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "_any.replace( %s::_typecode(), (*_val)->_flatten(), ",
                    tname, YCCVOID(ctx));
        yccfpPrint( fp, "TRUE, TRUE);\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");
      }
      else
        yccfpPrint( fp, ";\n");
      break;
    case yrdkStruct:
    case yrdkUnion:
    case yrdkSequence:
      yccfpPrint( fp, "void operator<<=( %sAny& _any, ", YCP_CORBA(ctx));
      yccfpPrint( fp, "const %s& _val)", YCP_CORBA(ctx), tname);
      if ( defn )
      {
        yccfpPrint( fp, "\n{\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "_any.replace( %s::_typecode(), _val._flatten(), ",
                    tname, YCCVOID(ctx));
        yccfpPrint( fp, "TRUE, TRUE);\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");
      }
      else
        yccfpPrint( fp, ";\n");
      break;
    case yrdkArray:
      yccfpPrint( fp, "void operator<<=( %sAny& _any, ", YCP_CORBA(ctx));
      yccfpPrint( fp, "const %s_forany& _val)", 
                  YCP_CORBA(ctx), tname);
      if ( defn )
      {
        yccfpPrint( fp, "\n{\n");
        yccfpIncIndent( fp);
        
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n\n");
      }
      else
        yccfpPrint( fp, ";\n");
      break;
    case yrdkAlias:

    default:
      return;
      break;      
  }
}



boolean yccpInClassScope( ycctx* ctx, yrobj* obj)
{
  yrobj* top = ycgScope(ctx);

  if ( !top )          
    return FALSE;
  switch (yrGetKind(top))
  {
    case yrdkInterface:
    case yrdkUnion:
    case yrdkStruct:
    case yrdkException:
    case yrdkSequence:
      return TRUE;
    default:
      return FALSE;
  }
}




void yccpGenParamType( ycctx* ctx, yccfp* fp, yrobj* type, sword mode)
{
  boolean genName = TRUE;	

  for (;;)
  {
    switch (yrGetKind(type))
    {
      case yrdkInterface:
	if ( genName )
        {
          yccfpPrint( fp, "%s_ptr", yccpTypeName(ctx, type));
        }
	if ( (mode == YOMODE_OUT) || (mode == YOMODE_INOUT) )
	  yccfpPrint(fp,"&");      
        return;
      case yrdkEnum:
	if ( genName )
          yccfpPrint( fp, "%s", yccpTypeName(ctx, type));
	if ( (mode == YOMODE_OUT) || (mode == YOMODE_INOUT) )
	  yccfpPrint(fp,"&");         
	return;
      case yrdkSequence:
      case yrdkUnion:
      case yrdkStruct:
      case yrdkException:
	if ( genName )
        {
          if ( mode == YOMODE_IN )
            yccfpPrint( fp, "const ");
          yccfpPrint( fp, "%s", yccpTypeName(ctx, type));
        }
        if ( yccIsVariableType( ctx, type) )
        {
          switch (mode)
          {
            case YOMODE_IN:                   
            case YOMODE_INOUT:                
	      yccfpPrint(fp,"&");
              break;
            case YOMODE_OUT:                  
	      yccfpPrint(fp,"*&");
              break;
            case YOMODE_RETURN:               
	      yccfpPrint(fp,"*");
              break;
          }
        }
        else if ( mode != YOMODE_RETURN )
	  yccfpPrint(fp,"&");         
	return;
      case yrdkAlias:

	if ( genName )
	{
          yrobj* base = yrGetAliasBaseType( type);

          if ( (yrGetKind(base) == yrdkArray) &&
               ((mode == YOMODE_RETURN) ||
               ((mode == YOMODE_OUT) && yccIsVariableType( ctx, base))) )
          {
            CONST char* tname = yccpScopedName(ctx, type);

            if ( mode == YOMODE_RETURN )
              yccfpPrint( fp, "%s_slice*", tname);
            else     
              yccfpPrint( fp, "%s_slice**", tname);
            return;
          }
          else
            yccfpPrint( fp, "%s", yccpTypeName(ctx, type));
	  genName = FALSE;
	  type = base;
	}
	break;
      case yrdkString:
	if ( genName )
        {
          if ( mode == YOMODE_IN )
            yccfpPrint( fp, "const char*");
          else
            yccfpPrint( fp, "char*");
        }
	if ( (mode == YOMODE_OUT) || (mode == YOMODE_INOUT) )
	  yccfpPrint(fp, "&");
	return;
      case yrdkArray:
	return;
      case yrdkPrimitive:
        switch (yrPrimData(type).kind)
        {
          case yrpkany:                         
	    if ( genName )
            {
              if ( mode == YOMODE_IN )          
                yccfpPrint( fp, "const ");
              yccfpPrint( fp, "%s", yccpTypeName(ctx, type));
            }
            switch (mode)
            {
              case YOMODE_IN:                   
              case YOMODE_INOUT:                
	        yccfpPrint(fp,"&");
                break;
              case YOMODE_OUT:                  
	        yccfpPrint(fp,"*&");
                break;
              case YOMODE_RETURN:               
	        yccfpPrint(fp,"*");
                break;
            }
            break;
          case yrpkTypeCode:                    
	    if ( genName )
            {
              yccfpPrint( fp, "%s_ptr", yccpTypeName(ctx, type));
            }
	    if ( (mode == YOMODE_OUT) || (mode == YOMODE_INOUT) )
	      yccfpPrint(fp,"&");       
            break;
          case yrpkstring:                      
	    if ( genName )
            {
              if ( mode == YOMODE_IN )
                yccfpPrint( fp, "const char*");
              else
                yccfpPrint( fp, "char*");
            }
	    if ( (mode == YOMODE_OUT) || (mode == YOMODE_INOUT) )
	      yccfpPrint(fp, "&");       
            break;
          default:  
	    if ( genName )
              yccfpPrint( fp, "%s", yccpTypeName(ctx, type));
	    if ( (mode == YOMODE_OUT) || (mode == YOMODE_INOUT) )
	      yccfpPrint(fp, "&");       
        }
	return;
      default:
	yseThrow(YC_EX_FAILURE);
	break;
    }
  }
}




static CONST_DATA char* yccpKwdTbl[] = 
{
  "and",                "and_eq",                        
  "asm",                "bitand",                        
  "bitor",              "bool",                          
  "catch",              "class",                         
  "compl",              "const_cast",                    
  "delete",             "dynamic_cast",                  
  "explicit",           "friend",                        
  "inline",             "mutable",                       
  "namespace",          "new",                           
  "not",                "not_eq",                        
  "operator",           "or",                            
  "or_eq",              "private",                       
  "protected",          "public",                        
  "reinterpret_cast",   "static_cast",                   
  "template",           "this",                          
  "throw",              "try",                           
  "typeid",             "typename",                      
  "using",              "virtual",                       
  "wchar_t",            "xor",                           
  "xor_eq"                                               
};

static CONST_DATA size_t yccpKwdCnt = sizeof(yccpKwdTbl) / sizeof(char*);




boolean yccpIsKeyword( ycctx* ctx, CONST char* name)
{
  boolean matched;

  matched = yccIsKeyword( ctx, name);
  if ( !matched )
  {
    CONST char **low; 
    CONST char **mid;
    CONST char **high;
    sword  cmp;

    high = yccpKwdTbl + yccpKwdCnt;
    low = yccpKwdTbl;

    while ( !matched && (low < high) )
    {
      mid = low + (high - low) / 2;
      cmp = strcmp(name, *mid);
      if (cmp < 0)
        high = mid;
      else if (cmp > 0)
        low = mid + 1;
      else
        matched = TRUE;
    }
  }
  return matched;
}




ycgmap* yccpLangMap( ycctx* ctx)
{
  ycgmap* map = (ycgmap*) ysmGlbAlloc( sizeof(ycgmap), "ycgmap");

  CLRSTRUCT(*map);
  map->langid = YCG_CPLUS_LANG;
  map->driver = yccpmap;
  map->kwdchk = yccpIsKeyword;

    
  if ( !ysResGetBool("mnidlc.nobuiltin-seq") )
    map->flags |= YCCP_BUILTIN_SEQ_FLG;
  if ( ysResGetBool( "mnidlc.static-typecodes") )
    map->flags |= YCCP_STATIC_TC_FLG;
  if ( ysResGetBool("mnidlc.cp-eh") )
    map->flags |= YCCP_EH_NATIVE_FLG;
  if ( ysResGetBool("mnidlc.cp-rtti") )
    map->flags |= YCCP_RTTI_FLG;
  if ( ysResGetBool("mnidlc.cp-namespace") )
    map->flags |= YCCP_NAMESPACE_FLG;

  return map;
}





STATICF boolean yccpSymFlush( dvoid* usrp, dvoid* elm)
{
  ycsym* sym = (ycsym*)elm;

  if ( sym )
  {
    if ( sym->lang.cplus.scopednm )
      ysmGlbFree( (dvoid*)sym->lang.cplus.scopednm);
    if ( sym->lang.cplus.simplenm )
      ysmGlbFree( (dvoid*)sym->lang.cplus.simplenm);
    if ( sym->lang.cplus.ppfx )
      ysmGlbFree( (dvoid*)sym->lang.cplus.ppfx);
    if ( sym->lang.cplus.flatnm )
      ysmGlbFree( (dvoid*)sym->lang.cplus.flatnm);
  }
  return TRUE;
}





void yccpGenCGObjs( ycctx* ctx, yccfp* fp, yslst* objs, yccpcgfp cgcb, 
                    yccpdefcgfp defcgcb)
{
  ysle* le;
  boolean usenmsp = yccpUseNamespaces(ctx);
  CONST char* name;

  if ( objs )
  {
    for ( le = ysLstHead(objs); le; le = ysLstNext(le))
    {
      ycgobj* cgobj = (ycgobj*) ysLstVal(le);
  
      if ( yrGetKind(cgobj->ifrobj) == yrdkModule )
      {
        yslst* deferred;

        name = yccpSimpleName( ctx, cgobj->ifrobj);
        if ( usenmsp )
        {
          yccfpPrint( fp, "namespace %s\n{\n", name);
          yccfpIncIndent( fp);
        }
        else
          yccfpPrint( fp, "/* module %s */\n", name);

        ycgPushScope( ctx, cgobj->ifrobj);
        yccpGenCGObjs( ctx, fp, cgobj->objlist, cgcb, defcgcb);
        deferred = ycgPopScope(ctx);
        if ( deferred )
        {
          if ( defcgcb )
            (*defcgcb)( ctx, fp, deferred);
          ysLstDestroy( deferred, (ysmff)0);
        }

        if ( usenmsp )
        {
          yccfpDecIndent( fp);
          yccfpPrint( fp, "};  /* module %s */\n", name);
        }
      }
      else
        (*cgcb)( ctx, fp, cgobj->ifrobj, cgobj->flags & YCG_FWD);
    }
  }
}
