/* mx/src/yc/yccclnt.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/


#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCC0_ORACLE
#include <ycc0.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif

STATICF void yccGenClientDefn( ycctx* ctx, yccfp* fp, yrobj* obj);
STATICF void yccGenIntfClient( ycctx* ctx, yccfp* fp, yrobj* inf);
STATICF void yccGenOpClient( ycctx* ctx, yccfp* fp, yrobj* op, ub4* idx);
STATICF void yccGenAttrClient( ycctx* ctx, yccfp* fp, yrobj* attr, ub4* idx);
STATICF void yccGenStringTypeCodes( ycctx* ctx, yccfp* fp, yrobj* op);
STATICF void yccGenCGClientObjs( ycctx* ctx, yccfp* fp, yslst* objs);
STATICF void yccGenSyncClient( ycctx* ctx, yccfp* fp, yrobj* intf, 
                               yrobj* rettype, CONST char* opName,
                               CONST char* implName, yslst* pars, 
                               yslst* ctxs, boolean oneway, ub4 idx);
STATICF void yccGenAsyncClient( ycctx* ctx, yccfp* fp, yrobj* intf, 
	                        CONST char* opName, CONST char* implName, 
                                yslst* pars, yslst* ctxs, boolean oneway);
STATICF void yccGenAsyncBody( ycctx* ctx, yccfp* fp, CONST char* opName, 
                              CONST char* implName, yslst* pars, 
                              yslst* ctxs, boolean oneway);


void yccclnt(ycctx* ctx, char* base, ycfile* fd)
{
  yccfp *fp;
  CONST char* errtxt;
  char* upbase;		
  CONST char* guardsfx = 
           ((ycStyleOra(ctx) && !ycCORBA1_2(ctx)) ? "ORACLE" : "IDL");

  
  fp = yccfpOpen( fd->newtmp, "w", SYSFPKIND_NONE, &errtxt, 
                  yccGetLineLimit(ctx));
  if ( !fp )
  {
    ysRecord(YCMSG(1), YCERRSEV, YSLSTR(fd->target), YSLSTR(errtxt), YSLEND);
    return;
  }

  
  yccfpSetIndent( fp, 0);
  yccfpPrint( fp, "/* GENERATED FILE\n * %s - client stubs\n", base);
  yccfpPrint( fp, " * from %s\n */\n\n", ctx->srcnm);
  yccGenSysIncls(ctx, fp, TRUE);
  upbase = ycToUpper(ysStrDup(base));
  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s_%s\n#include <%s.h>\n#endif\n\n", 
	      upbase, guardsfx, base);
  yccfpEndPP( fp);
  ysmGlbFree( (dvoid*)upbase);
  yccfpPrint( fp, "EXTC_START\n\n");

    
  yccGenCGClientObjs( ctx, fp, ctx->newobjs);

  yccfpPrint( fp, "\nEXTC_END\n");
  yccfpClose(fp);
}





STATICF void yccGenCGClientObjs( ycctx* ctx, yccfp* fp, yslst* objs)
{
  ysle* le;

  if ( objs )
  {
    for ( le = ysLstHead(objs); le; le = ysLstNext(le))
    {
      ycgobj* cgobj = (ycgobj*) ysLstVal(le);

      if ( yrGetKind( cgobj->ifrobj) == yrdkModule )
        yccGenCGClientObjs( ctx, fp, cgobj->objlist);
      else if ( !ycShouldGenCode(ctx, cgobj->ifrobj) )
        continue;	
      else if ( !(cgobj->flags & YCG_FWD) )	
	yccGenClientDefn( ctx, fp, cgobj->ifrobj);
    }
  }
}




void yccGenTypeCodeDefn( ycctx* ctx, yccfp* fp, yrobj* obj, boolean external)
{
  CONST char* name;
  CONST char* tcpfx;

  switch ( yrGetKind(obj) )
  {
    case yrdkSequence:		
      if ( (ctx->lang->flags & YCCFLG_BUILTIN_SEQ) && 
          (yrGetKind(yrSeqData(obj).elmtype) == yrdkPrimitive) )
	return;
      break;
    case yrdkPrimitive:		
      return;
    case yrdkInterface:
      if ( ycIsCorbaObject( ctx, obj) ) 
        return;                 
      break;
    case yrdkException:
    case yrdkStruct:
    case yrdkUnion:
    case yrdkEnum:
    case yrdkArray:
    case yrdkString:
    case yrdkAlias:
      break;
    default:
      yseThrow(YS_EX_FAILURE);
      break;
  }

  tcpfx = yccTCPrefix(ctx);
  if ( yrGetKind(obj) == yrdkString )
  {
    ub4 bnd = yrStringData(obj).bound;

    yccfpPrint( fp, "#ifndef %s_string_%d_DEFINED\n", tcpfx, bnd);
    yccfpPrint( fp, "#define %s_string_%d_DEFINED\n", tcpfx, bnd);
    yccfpPrint( fp, "static yotk %s_string_%d[] =\n", tcpfx, bnd);
    yccfpIncIndent( fp);
    yccFormatTypeCodeDefn( ctx, fp, yrGetTypeCode( obj));
    yccfpDecIndent( fp);
    yccfpPrint( fp, "#endif\n");
  }
  else
  {
    name = yccGetAbsoluteName( ctx, obj, (yrobj*)0);
    if ( !external )
    {
      yccfpStartPP( fp);
      yccfpPrint( fp, "#ifndef %s_%s_DEFINED\n", tcpfx, name);
      yccfpPrint( fp, "#define %s_%s_DEFINED\n", tcpfx, name);
      yccfpEndPP( fp);
    }
    yccGenTypeCode( ctx, fp, name, yrGetTypeCode( obj), external);
    if ( !external )
    {
      yccfpStartPP( fp);
      yccfpPrint( fp, "#endif /* %s_%s_DEFINED */\n\n", tcpfx, name);
      yccfpEndPP( fp);
    }
  }
}




STATICF void yccGenClientDefn( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  ysle* le;

  switch ( yrGetKind(obj) )
  {
    case yrdkInterface:		
      yccGenIntfClient( ctx, fp, obj);
      break;
    case yrdkException:		
      yccGenExcClient( ctx, fp, obj);
      break;
    case yrdkStruct:		
    case yrdkUnion:		
      if ( yrGetContents( obj) )
      {
        for ( le = ysLstHead( yrGetContents(obj)); le; le = ysLstNext(le))
        {
          yccGenClientDefn( ctx, fp, (yrobj*) ysLstVal(le));
        }
      }
      yccGenTypeCodeDefn( ctx, fp, obj, TRUE);
      yccGenSupportFuncs( ctx, fp, obj, TRUE);
      break;
    case yrdkAlias:		
    case yrdkEnum:		
      yccGenTypeCodeDefn( ctx, fp, obj, TRUE);
      yccGenSupportFuncs( ctx, fp, obj, TRUE);
      break;
    default:			
      break;
  }
}





STATICF void yccGenIntfClient( ycctx* ctx, yccfp* fp, yrobj* inf)
{
  CONST char* name;
  char* sname;
  ysle* le;

  if ( ycIsCorbaObject( ctx, inf) )   
    return;

  name = yccGetAbsoluteName( ctx, inf, (yrobj*)0);
  sname = yrGetAbsoluteName( inf);
  yccfpPrint( fp, "/* Client stubs for interface %s */\n", sname);

    
  yccGenId( ctx, fp, name, name, TRUE, yrGetRepId(inf));
  yccGenTypeCodeDefn( ctx, fp, inf, TRUE);
  yccfpPrint( fp, "\n");
  ysmGlbFree( (dvoid*)sname);

    
  yccGenSupportFuncs( ctx, fp, inf, TRUE);
  
  if ( yrGetContents(inf) )
  {
    ycsym* syminfo = ycSymLookup( ctx->symtbl, inf);
    yslst* all = (syminfo ? syminfo->opsNattrs : (yslst*)0);
    yrobj* obj;

    for (le = ysLstHead(yrGetContents(inf)); le; le = ysLstNext(le))
    {
      obj = (yrobj*) ysLstVal(le);
      if ( (yrGetDefinedIn(obj) != inf) ||
           (yrGetKind(obj) == yrdkOperation) ||
           (yrGetKind(obj) == yrdkAttribute) )
        continue;	
      else
        yccGenClientDefn( ctx, fp, obj);  
    }
    yccfpPrint( fp, "\n");

    if ( !ycIsEmptyLst(all) )
    {
      ub4 opidx = 0;
      for (le = ysLstHead(all); le; le = ysLstNext(le))
      {
        obj = (yrobj*) ysLstVal(le);
        if ( yrGetDefinedIn(obj) != inf )
          continue;	
        if ( yrGetKind(obj) == yrdkOperation )
	  yccGenOpClient( ctx, fp, obj, &opidx);
        else 
	  yccGenAttrClient( ctx, fp, obj, &opidx);
      }
      yccfpPrint( fp, "\n");
    }
  }
}





void yccGenExcClient( ycctx* ctx, yccfp* fp, yrobj* ex)
{
  CONST char* name = (char*)0;
  CONST char* exName = (char*)0;
  char* sname = yrGetAbsoluteName( ex);
  sword saveStyle = ctx->style;

  name = yccGetAbsoluteName(ctx, ex, (yrobj*)0);
  ctx->style |= YCSTYLE_EXC;
  exName = yccGetAbsoluteName(ctx, ex, (yrobj*)0);
  ctx->style = saveStyle;

  yccGenId( ctx, fp, exName, name, FALSE, yrGetRepId(ex));
  ysmGlbFree((dvoid*)sname);
  ysmGlbFree((dvoid*)exName);

  yccGenTypeCodeDefn( ctx, fp, ex, TRUE);
  if ( yrStructData(ex).mbrs )
    yccGenSupportFuncs( ctx, fp, ex, TRUE);
  if ( yrGetContents( ex) )
  {
    ysle* le;

    for ( le = ysLstHead( yrGetContents(ex)); le; le = ysLstNext(le))
    {
      yccGenClientDefn( ctx, fp, (yrobj*) ysLstVal(le));
    }
  }
}




STATICF void yccGenSyncClient( ycctx* ctx, yccfp* fp, yrobj* intf, 
                               yrobj* rettype, CONST char* opName,                                            CONST char* implName, yslst* pars, 
                               yslst* ctxs, boolean oneway, ub4 idx)
{
  ysle* le;
  boolean isVoidReturn = (yrGetKind(rettype) == yrdkPrimitive) &&
				(yrPrimData(rettype).kind == yrpkvoid);
  boolean useOraNames = ctx->style & YCSTYLE_ORA ? TRUE : FALSE;
  CONST char* intfName = yccGetAbsoluteName( ctx, intf, (yrobj*)0);
  CONST char* kwdpfx = ((*ctx->lang->kwdchk)( ctx, implName) ? "_" : "");
  boolean vers1_2 = ycCORBA1_2(ctx);

  yccGenFuncHdr( ctx, fp, rettype, intf, opName, pars, 
                 ctxs, FALSE, yccfnk_normal);
  yccfpPrint( fp, "\n{\n");
  yccfpIncIndent( fp);

  if ( !isVoidReturn )                     
  {
    yccGenParamType( ctx, fp, rettype, YOMODE_RETURN);
    yccfpPrint( fp, " _result;\n");
  }

    
  yccfpPrint( fp,"ysevt* %s _sem = (ysevt*)0;\n", YCCVOLATILE(ctx));
  yccfpPrint( fp,"struct %s__tyimpl* _impl;\n", intfName);
  yccfpPrint( fp, "yowiden _widen = (yowiden)0;\n\n");
  if ( useOraNames )
    yccfpPrint( fp, "NOREG(_sem);\n");

    
  if ( ctx->objAdaptor == YCOA_BOA )             
  {
    yccfpPrint( fp, "if ( ev->_major != CORBA_NO_EXCEPTION )\n");
    yccfpIncIndent( fp);
    if ( isVoidReturn )
      yccfpPrint( fp, "return;\n");
    else
      yccfpPrint( fp, "return _result;\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "\nyseTry\n{\n");
    yccfpIncIndent( fp);
  }

    
  yccfpPrint( fp, "_impl = (struct %s__tyimpl*) yoLocalObj( ", intfName);
  yccfpPrint( fp, "(CORBA_Object)or, (yowiden*)&_widen);\nif ( _impl )\n{\n");
  yccfpIncIndent( fp);

    
  yccfpPrint( fp, "if ( _widen )\n{\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "yogfp _f = (*_widen)( (ub4)%u, (%s*)_impl, %s__id);\n",
              idx, YCCVOID(ctx), intfName);
  yccfpPrint( fp, "%s(*(", isVoidReturn ? "" : "_result = ");
  yccGenFuncHdr( ctx, fp, rettype, intf, "", pars, ctxs, TRUE, yccfnk_normal);
  yccfpPrint( fp, ")_f)(or%s", (vers1_2 ? ", ev" : ""));
  if ( pars )
  {
    for ( le = ysLstHead(pars); le; le = ysLstNext(le))
    {
      yccfpPrint( fp, ", ");
      yccGenSimpleName( ctx, fp, ((yrpar*)ysLstVal(le))->name);
    }
  }
  if ( !vers1_2 )
    yccfpPrint( fp, "%s, ev", ycIsEmptyLst(ctxs) ? "" : ", corbctx_");
  yccfpPrint( fp, ");\n");
  yccfpDecIndent( fp);

    
  yccfpPrint( fp, "}\nelse\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "%s(*_impl->%s%s)(or%s",
              isVoidReturn ? "" : "_result = ", kwdpfx, implName,
              (vers1_2 ? ", ev" : ""));

  if ( pars )
  {
    for ( le = ysLstHead(pars); le; le = ysLstNext(le))
    {
      yccfpPrint( fp, ", ");
      yccGenSimpleName( ctx, fp, ((yrpar*)ysLstVal(le))->name);
    }
  }
  if ( !vers1_2 )
    yccfpPrint( fp, "%s, ev", ycIsEmptyLst(ctxs) ? "" : ", corbctx_");
  yccfpPrint( fp, ");\n");
  yccfpDecIndent( fp);
  yccfpDecIndent( fp);

    

  yccfpPrint( fp, "}\nelse\n{\n");
  yccfpIncIndent( fp);

  yccfpPrint( fp, "%s((%s*)or, ev, YOFLTR_CSND, ",
              (ctx->objAdaptor == YCOA_COA) ? "yoFilterRunEx" 
                                            : "ORA_CORBA_FilterRun",
              YCCVOID(ctx));
  yccfpPrint( fp, "(%s char*)0, (%s*)0);\n", YCCCONST(ctx), YCCVOID(ctx));
  if ( ctx->objAdaptor == YCOA_BOA )               
  {
    yccfpPrint( fp, "if ( ev->_major == CORBA_NO_EXCEPTION )\n{\n");
    yccfpIncIndent(fp);
  }
  yccfpPrint( fp, "yseTry\n{\n");
  yccfpIncIndent(fp);

     
  yccfpPrint( fp, "_sem = ysSemCreate((%s*)0);\n", YCCVOID(ctx));
  if ( yccGenAsync(ctx) )
  {
    yccfpPrint( fp, "%s_nw( or%s", opName, vers1_2 ? ", ev" : "");
    if ( pars )
    {
      for ( le = ysLstHead(pars); le; le = ysLstNext(le))
      {
        yccfpPrint( fp, ", ");
        yccGenSimpleName( ctx, fp, ((yrpar*)ysLstVal(le))->name);
      }
    }
    if ( !vers1_2 )
      yccfpPrint( fp, "%s, ev", ycIsEmptyLst(ctxs) ? "" : ", corbctx_");
    yccfpPrint( fp, ", (ysevt*)_sem);\n");
  }
  else
  {
    yccGenAsyncBody( ctx, fp, opName, implName, pars, ctxs, oneway);
  }

    
  if ( ctx->objAdaptor == YCOA_BOA )             
  {
    yccfpPrint( fp, "ORA_CORBA_SemSynch(");
    yccfpPrint( fp, " ev, (ysevt*)_sem, %s_pars, ", opName);
    if ( isVoidReturn )
      yccfpPrint( fp, "(%s*)0, 0);\n", YCCVOID(ctx));
    else
      yccfpPrint( fp, "(%s*)&_result, sizeof(_result));\n", YCCVOID(ctx));
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\nyseFinally\n{\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "ORA_CORBA_FilterRunEx((%s*)or, ev, YOFLTR_CRCV, ",
                YCCVOID(ctx));
    yccfpPrint( fp, "CORBA_exception_id(ev), CORBA_exception_value(ev));\n");
    yccfpPrint( fp, "if ( _sem )\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "ysSemDestroy( (ysevt*)_sem);\n");
    yccfpDecIndent( fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\nyseEnd\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n");                     
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n");                     
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\nyseCatchAll\n{\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "if ( _sem )\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "ysSemDestroy( (ysevt*)_sem);\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "ev->_major = CORBA_SYSTEM_EXCEPTION;\n");
    yccfpPrint( fp, "ev->id = (char*) yseExid;\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\nyseEnd\n");
  }                                              

  else                                           
  {
    yccfpDecIndent( fp);
    yccfpPrint( fp,"}\nyseCatchAll\n{\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "%sysid* _exid;\n%s* _exbody;\n\n", 
                YCCCONST(ctx), YCCVOID(ctx));
    yccfpPrint( fp, "_exid = yseExid;\n_exbody = yseExobj;\nyseTry\n{\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "yoFilterRunEx((%s*)or, ev, YOFLTR_CRCV, ", YCCVOID(ctx));
    yccfpPrint( fp, "_exid, _exbody);\n");
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\nyseFinally\n{\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "if ( _sem )\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "ysSemDestroy( (ysevt*)_sem);\n");
    yccfpDecIndent( fp);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\nyseEnd\nyseRethrow;\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\nyseEnd\n");
    yccfpPrint( fp, "yseTry\n{\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "ysSemSynch( (ysevt*)_sem, ");
    if ( isVoidReturn )
      yccfpPrint( fp, "(%s*)0);\n", YCCVOID(ctx));
    else
      yccfpPrint( fp, "(%s*)&_result);\n", YCCVOID(ctx));
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\nyseFinally\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "yoFilterRunEx((%s*)or, ev, YOFLTR_CRCV, ", YCCVOID(ctx));
    yccfpPrint( fp, "yseExid, yseExobj);\n");
    yccfpDecIndent(fp);
    yccfpPrint( fp, "yseEnd\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n");
  }                                              

  if ( !isVoidReturn )
    yccfpPrint( fp, "return _result;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");
}





STATICF void yccGenAsyncClient( ycctx* ctx, yccfp* fp, yrobj* intf, 
                                CONST char* opName, CONST char* implName, 
                                yslst* pars, yslst* ctxs, boolean oneway)
{
  if ( yccGenAsync(ctx) )
  {
    yccGenFuncHdr( ctx, fp, (dvoid*)0, intf, opName, pars, 
                   ctxs, FALSE, yccfnk_nw);
    yccfpPrint( fp, "\n");
    yccGenAsyncBody(ctx, fp, opName, implName, pars, ctxs, oneway);
    yccfpPrint( fp, "\n");
  }
}




STATICF void yccGenAsyncBody( ycctx* ctx, yccfp* fp, CONST char* opName, 
                              CONST char* implName, yslst* pars, 
                              yslst* ctxs, boolean oneway)
{
  sword npar;
  ysle* le;
  sword i = 0;

  yccfpPrint( fp, "{\n");
  yccfpIncIndent( fp);

    
  npar = pars ? ysLstCount(pars) : 0;
  if ( !ycIsEmptyLst(ctxs) && !ycCORBA1_2( ctx) )
    npar++;
  if ( npar )
    yccfpPrint( fp, "%s* _parvec[%d];\n\n", YCCVOID(ctx), npar);

  if ( !ycIsEmptyLst(pars) )
  {
    for ( le = ysLstHead(pars); le; i++, le = ysLstNext(le))
    {
      yrpar* par = (yrpar*) ysLstVal(le);
      yccfpPrint( fp, "_parvec[%d] = (%s*)%c", i, YCCVOID(ctx),
	          yccTakeAddrOf( ctx, par->type, par->mode) ? '&' : ' ');
      yccGenSimpleName( ctx, fp, par->name);
      yccfpPrint( fp, ";\n");
    }
  }

  if ( !ycIsEmptyLst(ctxs) && !ycCORBA1_2( ctx) )
  {
    yccfpPrint( fp, "_parvec[%d] = (%s*)corbctx_;\n", i, YCCVOID(ctx));
    i++;
  }

  yccfpPrint( fp, "%sSendReq( (%s*)or, ev, \"%s\", %s, _sem, ",
              (ctx->objAdaptor == YCOA_COA) ? "yo" : "ORA_CORBA_",
              YCCVOID(ctx), implName, oneway ? "FALSE" : "TRUE");
  yccfpPrint( fp, "(sword)%d, %s_pars, ", npar, opName);
  if ( npar )
    yccfpPrint( fp, "_parvec);\n");
  else
    yccfpPrint( fp, "(%s**)0);\n", YCCVOID(ctx));

  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n");
}






STATICF void yccGenOpClient( ycctx* ctx, yccfp* fp, yrobj* op, ub4* idx)
{
  CONST char* name = yccGetAbsoluteName( ctx, op, (yrobj*)0);
  yrop* opdata = &(yrOpData(op));
  yrobj* defn = yrGetDefinedIn(op);

  yccGenStringTypeCodes( ctx, fp, op);
  yccGenParamDesc( ctx, fp, name, opdata->pars, opdata->raises, 
                   opdata->rettype, opdata->ctxts);
  yccGenSyncClient( ctx, fp, defn, opdata->rettype,
                    name, yrGetName(op), opdata->pars, opdata->ctxts,
                    opdata->mode == YR_OP_ONEWAY, *idx);
  yccGenAsyncClient( ctx, fp, defn, name, yrGetName(op),
                    opdata->pars, opdata->ctxts, 
                    opdata->mode == YR_OP_ONEWAY);
  (*idx)++;
}





STATICF void yccGenAttrClient( ycctx* ctx, yccfp* fp, yrobj* attr, ub4* idx)
{
  CONST char* base = yccGetAbsoluteName( ctx, yrGetDefinedIn(attr), (yrobj*)0);
  char* attrName = yrGetName(attr);
  yrattr* attrdata = &(yrAttrData(attr));
  yrobj* defined_in = yrGetDefinedIn(attr);
  char* name = 
	(char*) ysmGlbAlloc( strlen(base) + strlen(attrName) + 7, "attrName");
		

  yccGenStringTypeCodes( ctx, fp, attr);

    
  DISCARD ysFmtStr( name, "%s__get_%s", base, attrName);
  yccGenParamDesc( ctx, fp, name, (yslst*)0, (yslst*)0, 
                   attrdata->type, (yslst*)0);
  yccGenSyncClient( ctx, fp, defined_in, attrdata->type,
                    name, name + strlen(base) + 1, (yslst*)0, (yslst*)0, 
                    FALSE, *idx);
  yccGenAsyncClient( ctx, fp, defined_in, name,  name + strlen(base) + 1,
                     (yslst*)0, (yslst*)0, FALSE);
  (*idx)++;

    
  if ( attrdata->mode != YR_ATTR_RO )
  {
    yslst* pars = ysLstCreate();
    yrpar param;

    DISCARD ysFmtStr( name, "%s__set_%s", base, attrName);
    param.name = "val";
    param.type = attrdata->type;
    param.mode = YOMODE_IN;
    DISCARD ysLstEnq( pars, (dvoid*) &param);

    yccGenSyncClient( ctx, fp, defined_in, 
			yrGetPrimitive( yrGetRepository(attr), yrpkvoid),
			name, name + strlen(base) + 1, pars, (yslst*)0, 
                        FALSE, *idx);
    yccGenParamDesc( ctx, fp, name, pars, (yslst*)0, (yrobj*)0, (yslst*)0);
    yccGenAsyncClient( ctx, fp, defined_in, name, name + strlen(base) + 1, 
                       pars, (yslst*)0, FALSE);

    ysLstDestroy( pars, (ysmff)0);
    (*idx)++;
  }

  ysmGlbFree( (dvoid*)name);
}




void yccGenStrAsChar( ycctx* ctx, yccfp* fp, CONST char* str)
{
  char buff[69];            
  CONST char* p;
  sword i;

  for ( i = 0, p = str; *p; p++ )
  {
    buff[i++] = '\'';
    buff[i++] = *p;
    buff[i++] = '\'';
    buff[i++] = ',';
    if ( i == 68 )
    {
      buff[i] = '\0';
      yccfpPrint( fp, "%s", buff);
      i = 0;
    }
  }
  if ( i )       
  {
    buff[i] = '\0';
    yccfpPrint( fp, "%s", buff);
  }
}




STATICF void yccGenStringTypeCodes( ycctx* ctx, yccfp* fp, yrobj* op)
{
  yrobj* strtype;

  if ( yrGetKind(op) == yrdkAttribute )
  {
    strtype = yrAttrData(op).type;
    if ( yrGetKind(strtype) == yrdkString )
      yccGenTypeCodeDefn( ctx, fp, strtype, FALSE);
  }
  else   
  {
    yslst* pars = yrOpData(op).pars;

    strtype = yrOpData(op).rettype;
    if ( yrGetKind(strtype) == yrdkString )
      yccGenTypeCodeDefn( ctx, fp, strtype, FALSE);

    if ( pars )
    {
      ysle* le;

      for ( le = ysLstHead(pars); le; le = ysLstNext(le))
      {
        yrpar* par = (yrpar*) ysLstVal(le);

        if ( yrGetKind(par->type) == yrdkString )
          yccGenTypeCodeDefn( ctx, fp, par->type, FALSE);
      } 
    } 
  }
}





void yccFormatTypeCodeDefn( ycctx* ctx, yccfp* fp, CONST yotk* tc)
{
  char* tcStr;      
  char* p;          
  char* start;      
  sword i = 0;      

  tcStr = yotkToStr(tc);
  p = tcStr;
  start = tcStr;

  while ( *p )
  {
    if ( *p == '\'' )                
    {
      p++, i++;                      
      if ( (*p == '\\') && (*(p+1) == '\'') )
      {
	p += 2;
	i += 2;
      }
      while ( *p != '\'' )
	p++, i++;
      p++, i++;                      
    }                                
    else if ( *p == '0' && ((*(p+1) == 'x') || (*(p+1) == 'X')) )
    {                                
      p += 2;                        
      i += 2;
      while ( *p && isxdigit(*p) )
	p++, i++;
    }                                
    else
      p++, i++;

    if ( i >= 60 )                   
    {
      char c = *p;                   

      *p = '\0';
      yccfpPrint( fp, "%s\n", start);
      *p = c;                        
      start = p;
      i = 0;
    }
  }
  if ( *start )                      
    yccfpPrint( fp, "%s", start);
  yccfpPrint( fp, ";\n\n");
  ysmGlbFree( (dvoid*)tcStr);
}





void yccGenParamDesc( ycctx* ctx, yccfp* fp, CONST char* name, yslst* pars,
		      yslst* raises, yrobj* rettype, yslst* ctxs) 
{
  ub4 tot = 0;
  ub4 i = 0;      
  ysle* le;
  boolean isVoidReturn = !rettype || 
                         ((yrGetKind(rettype) == yrdkPrimitive) && 
                          (yrPrimData(rettype).kind == yrpkvoid));
  boolean v12 = ycCORBA1_2(ctx);
  CONST char* tc = yccGetPrimitiveName( ctx, yrpkTypeCode);

    
    
    
  if ( ctx->lang->flags & YCCFLG_STATIC_TC )
  {
    if ( !isVoidReturn && !ycShouldGenCode(ctx, rettype) && 
         (yrGetKind(rettype) != yrdkString) )
    {
      yccGenTypeCodeDefn( ctx, fp, rettype, FALSE);
    }
    if ( pars )
    {
      for ( le = ysLstHead(pars); le; le = ysLstNext(le) )
      {
        yrpar* par = (yrpar*) ysLstVal(le);
        if ( !ycShouldGenCode(ctx, par->type) && 
             (yrGetKind(par->type) != yrdkString) )
          yccGenTypeCodeDefn( ctx, fp, par->type, FALSE);
      }
    }
    if ( raises )
    {
      for ( le = ysLstHead(raises); le; le = ysLstNext(le) )
      {
        yrobj* ex = (yrobj*) ysLstVal(le);
        if ( !ycShouldGenCode(ctx, ex) )
          yccGenTypeCodeDefn( ctx, fp, ex, FALSE);
      }
    }
  }

    
  if ( !isVoidReturn )
    tot++;
  if ( pars )
    tot += ysLstCount( pars);
  if ( raises )
    tot += ysLstCount( raises);
  if ( ctxs && !v12 )
    tot += ysLstCount( ctxs);

    
  yccfpPrint( fp, "yopar* %s__getPars(void)\n{\n", name);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "yopar* _pars = (yopar*)0;\n\n");
  yccfpPrint( fp, "_pars = yoParsGet( \"%s\");\n", name);
  yccfpPrint( fp, "if ( _pars == (yopar*)0 )\n{\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "yopard* _desc = yoPardCreate( \"%s\", (ub4)%u);\n", 
              name, tot);
  yccfpPrint( fp, "_pars = _desc->pars;\n");

  if ( !isVoidReturn )                          
  {
    i = 1;
    yccfpPrint( fp, "_pars[0].mode = YOMODE_RETURN;\n");
    yccfpPrint( fp, "_pars[0].tk = (%s)", tc);
    yccGenTypeCodeName( ctx, fp, rettype);
    yccfpPrint( fp, ";\n");
    if ( !v12 )
      yccfpPrint( fp, "_pars[0].fixed = %s;\n", 
                  yccIsVariableType(ctx, rettype) ? "FALSE" : "TRUE");
  }

  if ( pars )                                   
  {
   for ( le = ysLstHead(pars); le; i++, le = ysLstNext(le) )
    {
      yrpar* par = (yrpar*) ysLstVal(le);

      yccfpPrint( fp, "_pars[%u].mode = ", i);
      switch (par->mode)
      {
        case YOMODE_IN:
          yccfpPrint( fp, "YOMODE_IN");
          break;
        case YOMODE_OUT:
          yccfpPrint( fp, "YOMODE_OUT");
          break;
        case YOMODE_INOUT:
          yccfpPrint( fp, "YOMODE_INOUT");
          break;
      }
      yccfpPrint( fp, ";\n_pars[%u].tk = (%s)", i, tc);
      yccGenTypeCodeName( ctx, fp, par->type);
      yccfpPrint( fp, ";\n");
      if ( !v12 )
        yccfpPrint( fp, "_pars[%u].fixed = %s;\n", 
                    i, (yccIsVariableType(ctx, par->type) ? "FALSE" : "TRUE"));
    }
  }
  
  if ( ctxs && !v12 )                           
  {    
    for ( le = ysLstHead(ctxs); le; i++, le = ysLstNext(le) )
    {
      const char* id = (char*) ysLstVal(le);

      yccfpPrint( fp, "_pars[%u].mode = YOMODE_CTX;\n", i);
      yccfpPrint( fp, "_pars[%u].tk = (%s)\"%s\";\n", i, tc, id);
      yccfpPrint( fp, "_pars[%u].fixed = TRUE;\n", i);
    }
  }

  if ( raises )                                 
  {
    for ( le = ysLstHead(raises); le; i++, le = ysLstNext(le) )
    {
      yrobj* ex = (yrobj*) ysLstVal(le);

      yccfpPrint( fp, "_pars[%u].mode = YOMODE_EXCEPT;\n", i);
      yccfpPrint( fp, "_pars[%u].tk = (%s)", i, tc);
      yccGenTypeCodeName( ctx, fp, ex);
      yccfpPrint( fp, ";\n");
      if ( !v12 )
        yccfpPrint( fp, "_pars[%u].fixed = TRUE;\n", i);
    }
  }

  yccfpPrint( fp, "_pars[%u].mode = YOMODE_INVALID;\n", i);
  yccfpPrint( fp, "_pars[%u].tk = (%s)%s;\n", 
              i, tc, ycStyleCORBA(ctx) ? "TC_null" : "yoTcNull");
  yccfpPrint( fp, "_pars[%u].sz = (ub4)0;\n", i);
  if ( !v12 )
    yccfpPrint( fp, "_pars[%u].fixed = FALSE;\n", i);
  yccfpPrint( fp, "yoParsSize( _pars);\nyoParsSet( _desc);\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\nreturn _pars;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");
}
