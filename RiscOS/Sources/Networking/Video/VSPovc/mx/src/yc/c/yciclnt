/* mx/src/yc/yciclnt.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/


#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCI0_ORACLE
#include <yci0.h>
#endif
#ifndef YCC0_ORACLE
#include <ycc0.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif

STATICF void yciGenClientDefn( ycctx* ctx, yccfp* fp, yrobj* obj);
STATICF void yciGenIntfClient( ycctx* ctx, yccfp* fp, yrobj* inf);
STATICF void yciGenOpClient( ycctx* ctx, yccfp* fp, yrobj* op);
STATICF void yciGenAttrClient( ycctx* ctx, yccfp* fp, yrobj* attr);
STATICF void yciGenInit( ycctx* ctx, yccfp* fp, char* base);
STATICF void yciGenCGClientObjs( ycctx* ctx, yccfp* fp, yslst* objs,
				boolean init);
STATICF void yciGenCbEntries( ycctx* ctx, yccfp *fp, yrobj *inf  );

void yciclnt(ycctx* ctx, char* base, ycfile* fd)
{
  yccfp *fp;
  CONST char* errtxt;
  char* upbase;		
  ysle* le;

  
  fp = yccfpOpen(fd->newtmp, "w", SYSFPKIND_NONE, &errtxt, 
                 yccGetLineLimit(ctx));
  if (!fp)
  {
    ysRecord(YCMSG(1), YCERRSEV, YSLSTR(fd->target), YSLSTR(errtxt), YSLEND);
    return;
  }

  
  yccfpSetIndent( fp, 0);
  yccfpPrint(fp, "/* GENERATED FILE\n * %s - client stubs\n", base);
  yccfpPrint(fp, " * from %s\n */\n\n", ctx->srcnm);
  yciGenSysIncls(ctx, fp, TRUE);
  upbase = ycToUpper(ysStrDup(base));
  yccfpStartPP( fp);
  yccfpPrint(fp, "#ifndef MTTC%s_ORACLE\n", upbase);
  yccfpPrint(fp, "#include <mttc%s.h>\n#endif\n\n", base);
  yccfpEndPP( fp);
  ysmGlbFree( (dvoid*)upbase);

  
  yciGenInit(ctx, fp, base);
  
  yciGenCGClientObjs(ctx, fp, ctx->newobjs, FALSE);

  yccfpClose(fp);
}



STATICF void yciGenCGClientObjs( ycctx* ctx, yccfp* fp, yslst* objs,
				boolean init)
{
  ysle* le;
 
  if ( objs )
  {
    for ( le = ysLstHead(objs); le; le = ysLstNext(le))
    {
      ycgobj* cgobj = (ycgobj*) ysLstVal(le);
 
      if ( yrGetKind( cgobj->ifrobj) == yrdkModule )
        yciGenCGClientObjs( ctx, fp, cgobj->objlist, init);
      else if ( !ycShouldGenCode(ctx, cgobj->ifrobj) )
        continue;       
      else if ( !(cgobj->flags & YCG_FWD) )     
      {
	if (init)
	  yciGenCbEntries(ctx, fp, cgobj->ifrobj);
	else
	  yciGenClientDefn( ctx, fp, cgobj->ifrobj);
      }
    }
  }
}





STATICF void yciGenCbEntries( ycctx* ctx, yccfp *fp, yrobj *inf  )
{
  ysle *le;

  CONST char* base = (char *)0;
  char* attrName = (char *)0;
  char* opName = (char *)0;
  yrattr* attrdata = (yrattr *)0;

  if (yrGetKind(inf) == yrdkInterface && yrGetContents(inf)) 
  {
    yccfpPrint(fp, "mtticRegInterface(cx, %s__getId());\n",
	       yccGetAbsoluteName(ctx, inf, (yrobj *)0));

    for (le = ysLstHead(yrGetContents(inf)); le; le = ysLstNext(le))
    {
      yrobj* obj = (yrobj*) ysLstVal(le);

      if ( yrGetKind(obj) == yrdkOperation )
      {
	base = yccGetAbsoluteName( ctx, inf, (yrobj *)0);
	opName = yrGetName(obj);

	yccfpPrint(fp, "%s(cx, \"%s_%s\", %s_%s);\n", 
		   "mtticRegCallback", base, opName, base, opName); 
      }
      else if ( yrGetKind(obj) == yrdkAttribute )
      {
	base = yccGetAbsoluteName( ctx, inf, (yrobj*)0);
	attrName = yrGetName(obj);
	attrdata = &(yrAttrData(obj));
	yccfpPrint(fp, "%s(cx, \"%s__get_%s\", %s__get_%s);\n", 
		   "mtticRegCallback", base, attrName, base, attrName); 

	if (attrdata->mode != YR_ATTR_RO)
	  yccfpPrint(fp, "%s(cx, \"%s__set_%s\", %s__set_%s);\n", 
		     "mtticRegCallback", base, attrName, base, attrName); 
      }
    }
    yccfpPrint( fp, "\n");
  }
}




STATICF void yciGenInit( ycctx* ctx, yccfp* fp, char* base)
{
  ysle *le;

  yccfpPrint(fp, "/* init routine for %s */\n", base);
  yccfpPrint(fp, "boolean mttc%s__init( mttictx *cx )\n{\n");
  yccfpIncIndent( fp);

  
  yciGenCGClientObjs( ctx, fp, ctx->newobjs, TRUE);

  yccfpPrint(fp, "return (TRUE);\n");
  yccfpDecIndent( fp);
  yccfpPrint(fp, "}\n\n");
}



STATICF void yciGenClientDefn( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  switch ( yrGetKind(obj) )
  {
    case yrdkInterface:		
      yciGenIntfClient( ctx, fp, obj);
      break;
    case yrdkException:		
      yccGenExcClient( ctx, fp, obj);
      break;
    case yrdkAlias:		
    case yrdkStruct:		
    case yrdkUnion:		
    case yrdkEnum:		
      yccGenTypeCodeDefn( ctx, fp, obj, TRUE);
      break;
    default:			
      break;
  }
}





STATICF void yciGenIntfClient( ycctx* ctx, yccfp* fp, yrobj* inf)
{
  CONST char* name;
  char* sname;
  ysle* le;

  if ( ycIsCorbaObject( ctx, inf) )       
    return;

  name = yccGetAbsoluteName( ctx, inf, (yrobj*)0);
  sname = yrGetAbsoluteName( inf);
  yccfpPrint( fp, "/* Client stubs for interface %s */\n", sname);

    
  yccGenId( ctx, fp, name, name, TRUE, yrGetRepId(inf));
  yccGenTypeCodeDefn( ctx, fp, inf, TRUE);
  yccfpPrint( fp, "\n");
  ysmGlbFree( (dvoid*)sname);

    
  if ( yrGetContents(inf) )
  {
    for (le = ysLstHead(yrGetContents(inf)); le; le = ysLstNext(le))
    {
      yrobj* obj = (yrobj*) ysLstVal(le);

      if ( yrGetDefinedIn(obj) != inf )
        continue;	
      if ( yrGetKind(obj) == yrdkOperation )
	yciGenOpClient( ctx, fp, obj);
      else if ( yrGetKind(obj) == yrdkAttribute )
	yciGenAttrClient( ctx, fp, obj);
      else
        yciGenClientDefn( ctx, fp, obj);  
    }
    yccfpPrint( fp, "\n");
  }
}




STATICF void yciGenClientStub(  ycctx* ctx,
			       yccfp* fp,
			        yrobj* intf, 
			        yrobj* rettype,
			       CONST char* opName,
			       CONST char* implName, 
			        yslst* pars,
			        boolean oneway)
{
  
  yccfpPrint(fp,"void %s( mttictx *cx, yslst *args, mttitc *ret)\n{\n",
		     opName);

  
  yccfpIncIndent(fp);
  yccfpPrint(fp, "mttioSendReq( cx, \"%s\", ", implName);
  yccfpPrint(fp, "%s__getPars(), args, ret);\n", opName);
  yccfpDecIndent(fp);
  yccfpPrint(fp, "}\n\n");
  
}




STATICF void yciGenOpClient( ycctx* ctx, yccfp* fp, yrobj* op)
{
  CONST char* name = yccGetAbsoluteName( ctx, op, (yrobj*)0);
  yrop* opdata = &(yrOpData(op));

  yccGenParamDesc( ctx, fp, name,opdata->pars,opdata->raises,opdata->rettype,
                   opdata->ctxts);
  yciGenClientStub( ctx, fp, yrGetDefinedIn(op), opdata->rettype,
		   name, yrGetName(op), opdata->pars, 
		   opdata->mode == YR_OP_ONEWAY);
}





STATICF void yciGenAttrClient( ycctx* ctx, yccfp* fp, yrobj* attr)
{
  CONST char* base = yccGetAbsoluteName( ctx, yrGetDefinedIn(attr), (yrobj*)0);
  char* attrName = yrGetName(attr);
  yrattr* attrdata = &(yrAttrData(attr));
  yrobj* defined_in = yrGetDefinedIn(attr);
  char* name = 
	(char*) ysmGlbAlloc( strlen(base) + strlen(attrName) + 7, "attrName");
		

    
  ysFmtStr( name, "%s__get_%s", base, attrName);
  yccGenParamDesc( ctx, fp, name, (yslst*)0, (yslst*)0, 
			attrdata->type, (yslst*)0);
  yciGenClientStub( ctx, fp, defined_in, attrdata->type,
			name, name + strlen(base) + 1, (yslst*)0, FALSE);

    
  if ( attrdata->mode != YR_ATTR_RO )
  {
    yslst* pars = ysLstCreate();
    yrpar param;

    ysFmtStr( name, "%s__set_%s", base, attrName);
    param.name = (char *)"val";
    param.type = attrdata->type;
    param.mode = YOMODE_IN;
    DISCARD ysLstEnq( pars, (dvoid*) &param);

    yccGenParamDesc( ctx, fp, name, pars, (yslst*)0, (yrobj*)0, (yslst*)0);
    yciGenClientStub( ctx, fp, defined_in, 
			yrGetPrimitive( yrGetRepository(attr), yrpkvoid),
			name, name + strlen(base) + 1, pars, FALSE);
    ysLstDestroy( pars, (ysmff)0);
  }

  ysmGlbFree( (dvoid*)name);
}
