/* mx/src/yc/ycppdir.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCPP_ORACLE
#include <ycpp.h>
#endif


static CONST char *CONST_W_PTR ycppDirTbl[] =
{
  "define",
  "elif",
  "else",
  "endif",
  "error",
  "if",
  "ifdef",
  "ifndef",
  "include",
  "line",
  "pragma",
  "undef"
};

STATICF yslst *ycppAccumPars(ycctx *ctx, ycmd *md, ycln *ln, sword pos);
STATICF void ycppReplace(ycctx *ctx, ycln *ln, ycmd *md, yslst *parnms);
STATICF void ycppLine(ycctx *ctx, ysle *elm, sword pos);
STATICF void ycppPragma(ycctx *ctx, ysle *elm, sword pos);
STATICF void ycppInclude(ycctx *ctx, ysle *elm, sword pos);


void ycppDirective(ycctx *ctx, ysle *elm)
{
  sword dirid, pos;
  ycln *ln;

  ln = (ycln *) ysLstVal(elm);
  dirid = ycppDirIdent(ln->text, &pos);

  switch (dirid)
    {
    case YCDIR_INVALID: 
      ysRecord( YCMSG(16), YCERRSEV, YCERRLN(ln), YSLEND);
      break;
    case YCDIR_NONE: 
      break;
    case YCDIR_DEFINE: 
      ycppDefine(ctx, ln, pos); 
      break;
    case YCDIR_ELIF: 
      ysRecord( YCMSG(17), YCERRSEV, YCERRLN(ln), YSLSTR("#elif"), YSLEND);
      break;
    case YCDIR_ELSE: 
      ysRecord( YCMSG(17), YCERRSEV, YCERRLN(ln), YSLSTR("#else"), YSLEND);
      break;
    case YCDIR_ENDIF: 
      ysRecord( YCMSG(17), YCERRSEV, YCERRLN(ln), YSLSTR("#endif"), YSLEND);
      break;
    case YCDIR_ERROR:
      ysRecord( YCMSG(18), YCERRSEV, YCERRLN(ln), 
                YSLSTR(ysStrToText(ln->text) + pos), YSLEND);
      break;
    case YCDIR_IF:
    case YCDIR_IFDEF:
    case YCDIR_IFNDEF:
      ycppIf(ctx, elm, pos, dirid);
      break;
    case YCDIR_INCLUDE: 
      ycppInclude(ctx, elm, pos); 
      break;
    case YCDIR_LINE: 
      ycppLine(ctx, elm, pos); 
      break;
    case YCDIR_PRAGMA: 
      ycppPragma(ctx, elm, pos);
      break;
    case YCDIR_UNDEF: 
      ycppUndef(ctx, ln, pos); 
      break;
    default: 
      ysePanic(YS_EX_FAILURE); 
      break;
    }
}


sword ycppDirIdent(ysstr *txt, sword *posp)
{
  ysstr *dir;
  sword  sp, pos, i;
  char  *buf;
  size_t len, tbsz;

  buf = ysStrToText(txt);
  len = ysStrLen(txt);

  
  sp = ycSkipWS(txt, 0, (sword) len);
  sp = ycSkipWS(txt, sp + 1, (sword) len);

  
  if (sp >= (sword)len)
    return YCDIR_NONE;

  
  dir = ysStrCreate((char *) 0);
  for (pos = sp; pos < (sword)len && isalnum(buf[pos]); pos++)
    dir = ysStrApp(dir, buf[pos]);

  
  tbsz = sizeof(ycppDirTbl) / sizeof(ycppDirTbl[0]);
  for (i = 0; i < (sword)tbsz && strcmp(ycppDirTbl[i], ysStrToText(dir)); i++)
    ;

  ysStrDestroy(dir);
  *posp = pos;

  return (i < (sword)tbsz ? i : YCDIR_INVALID);
}


void ycppDefine(ycctx *ctx, ycln *ln, sword pos)
{
  char   *buf, *obuf;
  sword   i, opos, cls;
  ysstr  *id;
  ycmd   *md;
  boolean inpar;
  yslst  *pars;
  size_t  len, olen;

  
  cls = ycppGetToken(ln, &pos, (sword *) 0, &id);
  if (cls != YCPP_IDENT)
  {
    if (id)
      ysStrDestroy(id);

    ysRecord( YCMSG(20), YCERRSEV, YCERRLN(ln), YSLSTR("#define"), YSLEND);
    return;
  }

  if (!strcmp(ysStrToText(id), "defined"))
  {
    ysRecord( YCMSG(39), YCERRSEV, YCERRLN(ln), YSLSTR(ysStrToText(id)), 
              YSLEND);
    ysStrDestroy(id);
    return;
  }

  
  md = (ycmd *)
    ysHshFind(ctx->mdtbl, (dvoid *) ysStrToText(id), ysStrLen(id) + 1);

  buf = ysStrToText(ln->text);
  len = ysStrLen(ln->text);

  if (md)
    {
      ysStrDestroy(id);

      
      obuf = ysStrToText(md->origln->text);
      olen = ysStrLen(md->origln->text);
      opos = md->opos;

      inpar = (buf[pos] == '(');
      while (opos < (sword)olen && pos < (sword)len)
	{
	  
	  if ((inpar && (isspace(obuf[opos]) || isspace(buf[pos]))) ||
	      (!inpar && isspace(obuf[opos]) && isspace(buf[pos])))
	    {
	      while (isspace(obuf[opos]))
		opos++;
	      while (isspace(buf[pos]))
		pos++;
	    }
	  else if (obuf[opos] != buf[pos])
	    break;
	  else
	    {
	      if (inpar && obuf[opos] == ')')
		inpar = FALSE;

	      opos++, pos++;
	    }
	}

      
      if (opos == (sword)olen || pos == (sword)len)
	{
	  while (isspace(obuf[opos]))
	    opos++;
	  while (isspace(buf[pos]))
	    pos++;
	}

      if (opos < (sword)olen || pos < (sword)len)
        ysRecord( YCMSG(21), YCERRSEV, YCERRLN(ln), YSLSTR(md->name), 
                  YCERRLN(md->origln), YSLEND);
    }
  else
    {
      md = ycMdNew(ysStrToText(id), ln, pos);

      if (buf[pos] == '(')
	{
	  
	  pars = ycppAccumPars(ctx, md, ln, pos + 1);
	}
      else
	{
	  
	  pars = (yslst *) 0;
	  md->rpl = ysStrCreate(buf + pos);
	}

      if (md->rpl)
	{
	  
	  for (i = 0, buf = ysStrToText(md->rpl), len = ysStrLen(md->rpl);
	       i < (sword)len && isspace(buf[i]); i++) ;
	  md->rpl = ysStrDel(md->rpl, 0, i);

	  buf = ysStrToText(md->rpl);
	  len = ysStrLen(md->rpl);
	  for (i = (sword) len; i > 0 && isspace(buf[i-1]); i--) ;
	  md->rpl = ysStrDel(md->rpl, i, (sword) (len - i));

	  
	  ycppReplace(ctx, ln, md, pars);
	  ysHshIns(ctx->mdtbl, (dvoid *) md->name, strlen(md->name) + 1,
		   (dvoid *) md);
	}
      else
	ycMdFree((dvoid *) md);

      if (pars)
	ysLstDestroy(pars, (ysmff) ysStrDestroy);
    }
}


STATICF yslst *ycppAccumPars(ycctx *ctx, ycmd *md, ycln *ln, sword pos)
{
  yslst *pars;
  ysle  *scle1, *scle2;
  ysstr *parid;
  sword  i, j, cls, val;

  pars = ysLstCreate();

  
  cls = ycppGetToken(ln, &pos, &val, &parid);
  while (cls == YCPP_IDENT)
  {
    DISCARD ysLstEnq(pars, (dvoid *) parid);

    cls = ycppGetToken(ln, &pos, &val, (ysstr **) 0);
    if (cls == YCPP_PUNC && val == ',')
      cls = ycppGetToken(ln, &pos, &val, &parid);
    else
      break;    
  }

  if (cls != YCPP_PUNC || val != ')')
  {
    ysRecord( YCMSG(22), YCERRSEV, YCERRLN(ln), YSLEND);
    ysLstDestroy(pars, (ysmff) ysStrDestroy);
    return (yslst *) 0;
  }

  
  md->pcnt = ysLstCount(pars);
  for (i = 0, scle1 = ysLstHead(pars); i < md->pcnt - 1;
       i++, scle1 = ysLstNext(scle1))
    for (j = i + 1, scle2 = ysLstNext(scle1); j < md->pcnt;
	 j++, scle2 = ysLstNext(scle2))
      if (!strcmp(ysStrToText((ysstr *) ysLstVal(scle1)),
		  ysStrToText((ysstr *) ysLstVal(scle2))))
	{
          ysRecord( YCMSG(23), YCERRSEV, YCERRLN(ln), 
                    YSLSTR(ysStrToText((ysstr *) ysLstVal(scle1))), YSLEND);
	  ysLstDestroy(pars, (ysmff) ysStrDestroy);
	  return (yslst *) 0;
	}

  
  md->rpl = ysStrCreate(ysStrToText(ln->text) + pos);
  return pars;
}


STATICF void ycppReplace(ycctx *ctx, ycln *ln, ycmd *md, yslst *parnms)
{
  sword   i, sp, op, cls, val;
  boolean stringize, concat, ok;
  ycpar  *par, *last;
  ysstr  *id, *origstr;
  ysle   *le;
  size_t  len;

  sp = 0;
  stringize = concat = ok = FALSE;
  last = (ycpar *) 0;

  origstr = ln->text;
  ln->text = md->rpl;

  
  op = sp;
  cls = ycppGetToken(ln, &sp, &val, &id);
  while (cls != YCPP_EOL)
  {
      
    if (cls != YCPP_IDENT)
    {
      if (stringize)
        ysRecord( YCMSG(24), YCERRSEV, YCERRLN(ln), YSLEND);

      stringize = concat = FALSE;
      if (id)
        ysStrDestroy(id);
    }

    if (cls != YCPP_PPPASTE)
      last = (ycpar *) 0;

    switch (cls)
    {
      case YCPP_PPPASTE:
        
        if (!op && !ok)
          ysRecord( YCMSG(25), YCERRSEV, YCERRLN(ln), YSLEND);
        
        md->rpl = ysStrDel(md->rpl, op, sp - op);

        
        len = ysStrLen(md->rpl);
        sp = ycSkipWS(md->rpl, op, (sword) len);
        if (sp == (sword)len)
            ysRecord( YCMSG(26), YCERRSEV, YCERRLN(ln), YSLEND);
        else
        {
          md->rpl = ysStrDel(md->rpl, op, sp - op);
          sp = op;
        }

        if (last)
          last->cmd =
            (last->cmd == YCPAR_NORM ? YCPAR_STRIPAFT : YCPAR_STRIPALL);

        last = (ycpar *) 0;
        concat = TRUE;
        break;
      case YCPP_PPPOUND:
        if ((stringize = (md->pcnt > 0)))
        {
          sp--;
          md->rpl = ysStrDel(md->rpl, sp, 1);
        }
        break;
      case YCPP_IDENT:
        
        if (parnms)
        {
          for (i = 0, le = ysLstHead(parnms); le; i++, le = ysLstNext(le))
          if (!strcmp(ysStrToText((ysstr *) ysLstVal(le)),
                    ysStrToText(id)))
            break;
        }
        else
          i = 0;

        ysStrDestroy(id);

        if (i < md->pcnt)
        {
            
          op = ycSkipWS(ln->text, op, (sword) ysStrLen(ln->text));
          md->rpl = ysStrDel(md->rpl, op, sp - op);
          sp = op;

            
          par = (ycpar *) ysmGlbAlloc(sizeof(ycpar), "ycpar");
          par->spos = sp;
          par->cmd = (stringize ? YCPAR_STR : YCPAR_NORM);
          par->argno = i;

          DISCARD ysLstEnq(md->pars, (dvoid *) par);

          if (par->cmd != YCPAR_STR)
          {
            if (concat)
              par->cmd = YCPAR_STRIPBEF;
            last = par;
          }

          ok = TRUE;
        }
        else if (stringize)
          ysRecord( YCMSG(24), YCERRSEV, YCERRLN(ln), YSLEND);

        stringize = concat = FALSE;
        break;
    }

    op = sp;
    cls = ycppGetToken(ln, &sp, &val, &id);
  }

  ln->text = origstr;
}


void ycppUndef(ycctx *ctx, ycln *ln, sword pos)
{
  sword  cls;
  ysstr *id;
  dvoid *mdp;

  cls = ycppGetToken(ln, &pos, (sword *) 0, &id);
  if (cls != YCPP_IDENT)
    ysRecord( YCMSG(20), YCERRSEV, YCERRLN(ln), YSLSTR("#undef"), YSLEND);
  else
  {
    char* idstr = ysStrToText(id);

    if ( strcmp( idstr, "__FILE__") == 0 )
      ysRecord(YCMSG(86), YCERRSEV, YCERRLN(ln), YSLSTR("__FILE__"), YSLEND);
    else if ( strcmp( idstr, "__LINE__") == 0 )
      ysRecord(YCMSG(86), YCERRSEV, YCERRLN(ln), YSLSTR("__LINE__"), YSLEND);
    else if ( strcmp( idstr, "__DATE__") == 0 )
      ysRecord(YCMSG(86), YCERRSEV, YCERRLN(ln), YSLSTR("__DATE__"), YSLEND);
    else if ( strcmp( idstr, "__TIME__") == 0 )
      ysRecord(YCMSG(86), YCERRSEV, YCERRLN(ln), YSLSTR("__TIME__"), YSLEND);
    else if ( strcmp( idstr, "__STDC__") == 0 )
      ysRecord(YCMSG(86), YCERRSEV, YCERRLN(ln), YSLSTR("__STDC__"), YSLEND);
    else
    {
      mdp = ysHshRem(ctx->mdtbl, (dvoid *) idstr, ysStrLen(id) + 1);
      if (mdp)
        ycMdFree(mdp);
    }
  }

  if (id)
    ysStrDestroy(id);
}


STATICF void ycppLine(ycctx *ctx, ysle *elm, sword pos)
{
  sword  val, op, cls, i;
  char  *buf;
  ysstr *nm, *num;
  ycln  *ln;
  size_t len;
  CONST char *fn;

  ln = (ycln *) ysLstVal(elm);

  op = pos;
  cls = ycppGetToken(ln, &pos, (sword *) 0, &num);
  if (cls != YCPP_NUM)
    {
      if (num)
	ysStrDestroy(num);

      
      pos = op;
      ycppExpand(ctx, elm, pos, (sword) ysStrLen(ln->text), FALSE);
      ysLstDestroy(ctx->mdexp, ysmFGlbFree);
      ctx->mdexp = ysLstCreate();

      cls = ycppGetToken(ln, &pos, (sword *) 0, &num);
      if (cls != YCPP_NUM)
	{
          ysRecord( YCMSG(20), YCERRSEV, YCERRLN(ln), 
                    YSLSTR("#line"), YSLEND);
	  if (num)
	    ysStrDestroy(num);

	  return;
	}
    }

  
  val = 0;
  for (i = 0, buf = ysStrToText(num), len = ysStrLen(num);
       i < (sword)len && isdigit(buf[i]); i++)
    val = val * 10 + (buf[i] - '0');
  ysStrDestroy(num);

  if (i < (sword)len)
    {
      ysRecord( YCMSG(20), YCERRSEV, YCERRLN(ln), YSLSTR("#line"), YSLEND);
      return;
    }

  
  cls = ycppGetToken(ln, &pos, (sword *) 0, &nm);
  if (cls == YCPP_STRING)
    cls = ycppGetToken(ln, &pos, (sword *) 0, (ysstr **) 0);

  
  if (cls != YCPP_EOL)
  {
    ysRecord( YCMSG(20), YCERRSEV, YCERRLN(ln), YSLSTR("#line"), YSLEND);
    if (nm)
      ysStrDestroy(nm);
    return;
  }

  
  if ( nm )
    DISCARD ysLstEnq(ctx->nms, (dvoid *) nm);
  fn = ln->name;
  while ( (elm = ysLstNext(elm)) && 
           ((ln = (ycln*)ysLstVal(elm))->name == fn) )
  {
    ln->line = val++;
    if (nm)
      ln->name = ysStrToText(nm);
  }
}


STATICF void ycppInclude(ycctx *ctx, ysle *elm, sword pos)
{
  size_t len;
  ycln  *ln;
  ysstr* nm;
  ysstr* noreg fullnm = (ysstr*)0;
  ysle  *le, *path;
  yslst *pathlst ,*tu;
  char  *buf, quote, result[SYSFP_MAX_PATHLEN];
  char* noreg errtxt;

  NOREG(fullnm);
  NOREG(errtxt);
  ln = (ycln *) ysLstVal(elm);

  len = ysStrLen(ln->text);
  buf = ysStrToText(ln->text);
  pos = ycSkipWS(ln->text, pos, (sword) len);

  if (buf[pos] != '"' && buf[pos] != '<')
  {
    
    ycppExpand(ctx, elm, pos, (sword) len, FALSE);
    ysLstDestroy(ctx->mdexp, ysmFGlbFree);
    ctx->mdexp = ysLstCreate();

    len = ysStrLen(ln->text);
    buf = ysStrToText(ln->text);
    pos = ycSkipWS(ln->text, pos, (sword) len);

    if (buf[pos] != '"' && buf[pos] != '<')
    {
      ysRecord(YCMSG(20), YCERRSEV, YCERRLN(ln), YSLSTR("#include"), YSLEND);
      return;
    }
  }

  
  quote = (buf[pos] == '"' ? '"' : '>');
  pos++;
  nm = ysStrCreate((char *) 0);
  while (pos < (sword)len && buf[pos] != quote)
  {
    nm = ysStrApp(nm, buf[pos]);
    pos++;
  }

  if (buf[pos++] != quote)
  {
    ysRecord( YCMSG(20), YCERRSEV, YCERRLN(ln), YSLSTR("#include"), YSLEND);
    ysStrDestroy(nm);
    return;
  }

  
  if (ycppGetToken(ln, &pos, (sword *) 0, (ysstr **) 0) != YCPP_EOL)
  {
    ysRecord( YCMSG(20), YCERRSEV, YCERRLN(ln), YSLSTR("#include"), YSLEND);
    ysStrDestroy(nm);
    return;
  }

  
  if (ln->lvl + 1 > YCPP_MAXNESTLVL)
  {
    ysRecord( YCMSG(27), YCERRSEV, YCERRLN(ln), YSLEND);
    ysStrDestroy(nm);
    return;
  }

  
  tu = (yslst *) 0;
  errtxt = (char *) 0;
  if (quote == '"')
    {
      sysfpExtractPath(result, ln->name);
      sysfpForm(result, result, ysStrToText(nm), SYSFPKIND_TEXT);
      fullnm = ysStrCreate(result);
      yseTry
	tu = ycppRead(ctx, ysStrToText((ysstr*)fullnm), ln->lvl + 1);
      yseCatchObj(YC_EX_NOTFOUND, char *, tmp)
	ysStrDestroy((ysstr*)fullnm);
        errtxt = tmp;
      yseEnd
    }

  pathlst = ysResGet("mnidlc.preprocess.include");
  if (pathlst)
    for (path = ysLstHead(pathlst); path && !tu; path = ysLstNext(path))
      {
	sysfpForm(result, (char *) ysLstVal(path), ysStrToText(nm),
		  SYSFPKIND_TEXT);
	fullnm = ysStrCreate(result);
	yseTry
	  tu = ycppRead(ctx, ysStrToText((ysstr*)fullnm), ln->lvl + 1);
	yseCatchObj(YC_EX_NOTFOUND, char *, tmp)
	  ysStrDestroy((ysstr*)fullnm);
	  errtxt = tmp;
	yseEnd
      }

  
  if (tu)
    {
      for (le = ysLstTail(tu); le; le = ysLstPrev(le))
	ysLstIns(ctx->tu, elm, ysLstVal(le));

      ysLstDestroy(tu, (ysmff) 0);
      DISCARD ysLstEnq(ctx->nms, (dvoid *) fullnm);
    }
  else if (errtxt)
    ysRecord( YCMSG(2), YCERRSEV, YCERRLN(ln), YSLSTR(ysStrToText(nm)), 
              YSLSTR((char*)errtxt), YSLEND);
  else
    ysRecord( YCMSG(28), YCERRSEV, YCERRLN(ln), YSLSTR(ysStrToText(nm)), 
              YSLEND);

  ysStrDestroy(nm);
}





STATICF void ycppPragma(ycctx *ctx, ysle* elm, sword pos)
{
  sword cls;
  ysstr *id = (ysstr*)0;
  ycln* ln = (ycln *) ysLstVal(elm);

    
  ycppExpand(ctx, elm, pos, (sword) ysStrLen(ln->text), FALSE);
  ysLstDestroy(ctx->mdexp, ysmFGlbFree);
  ctx->mdexp = ysLstCreate();

  cls = ycppGetToken(ln, &pos, (sword *) 0, &id);
  if (cls != YCPP_IDENT)
  {
    ysRecord( YCMSG(20), YCERRSEV, YCERRLN(ln), YSLSTR("#pragma"), YSLEND);
  }
  else
  {
    CONST char* pragmaName = ysStrToText(id);

    if ( (strcmp(pragmaName, "ID") == 0) ||
	(strcmp(pragmaName, "prefix") == 0) ||
	(strcmp(pragmaName, "version") == 0) ||
	(strcmp(pragmaName, "IAO_DB_ATTR") == 0) ||
	(strcmp(pragmaName, "IAO_DB_CREATE") == 0) ||
	(strcmp(pragmaName, "IAO_DB_LIST") == 0) )
    {
      ln->dir = FALSE;
    }
    else
      ysRecord(YCMSG(82), YCWARNSEV, YCERRLN(ln), YSLSTR(pragmaName), YSLEND);
  }
  if ( id )
    ysStrDestroy(id);
}
