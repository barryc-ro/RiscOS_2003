/* mx/src/yc/ycutil.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YC_ORACLE
#include <yc.h>
#endif
#ifndef YSL_ORACLE
#include <ysl.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif


STATICF void ycgFreeScope( dvoid* data);




char* ycToUpper( char* in)
{
  char *up;
  for (up = in; *up; up++)
    *up = toupper(*up);
  return in;
}







typedef struct ycgscope
{
  yrobj* scope;
  yslst* deferred;
} ycgscope;



yrobj* ycgScope( ycctx* ctx)
{
  ysle* s;

  if ( ctx->scopes && (s = ysLstHead( ctx->scopes)) )
    return ((ycgscope*) ysLstVal(s))->scope;
  else
    return (yrobj*)0;
}



void ycgPushScope( ycctx* ctx, yrobj* scope)
{
  ycgscope* p;

  if ( !ctx->scopes )
    ycgNewScopeStack(ctx);
  p = (ycgscope*) ysmGlbAlloc( sizeof(ycgscope), "ycgscope");
  p->scope = scope;
  p->deferred = (yslst*)0;
  DISCARD ysLstPush( ctx->scopes, (dvoid*) p);
}



yslst* ycgPopScope( ycctx* ctx)
{
  if ( ctx->scopes )
  {
    ycgscope* p = (ycgscope*) ysLstPop( ctx->scopes);
    yslst* l = p->deferred;
    
    ysmGlbFree( (dvoid*)p);
    return l;
  }
  else
    return (yslst*)0;
}



STATICF void ycgFreeScope( dvoid* data)
{
  ycgscope* p = (ycgscope*) data;

  if ( p )
  {
    if ( p->deferred )
      ysLstDestroy( p->deferred, (ysmff)0);
    ysmGlbFree( (dvoid*)p);
  }
}




void ycgNewScopeStack( ycctx* ctx)
{
  ycgscope* p;

  if ( ctx->scopes )
  {
    while ( (p = ysLstDeq( ctx->scopes)) )
      ycgFreeScope(p);
  }
  else
    ctx->scopes = ysLstCreate();
  p = (ycgscope*) ysmGlbAlloc( sizeof(ycgscope), "ycgscope");
  p->scope = ctx->repository;
  p->deferred = (yslst*)0;
  DISCARD ysLstPush( ctx->scopes, (dvoid*) p);
}




void ycgDestroyScopeStack( ycctx* ctx)
{
  ycgscope* p;

  if ( ctx->scopes )
  {
    while ( (p = (ycgscope*) ysLstDeq( ctx->scopes)) )
      ycgFreeScope(p);
    ysLstDestroy( ctx->scopes, (ysmff)0);
  }
}



boolean ycgScopeDefer( ycctx* ctx, yrobj* obj)
{
  ysle* le;
  boolean top = TRUE;

  if ( !ctx->scopes )
    return FALSE;
  for ( le = ysLstHead( ctx->scopes); le; le = ysLstNext(le))
  {
    ycgscope* p = (ycgscope*) ysLstVal(le);

    switch (yrGetKind(p->scope))
    {
      case yrdkRepository:
      case yrdkModule:
      {
        if ( !top )
        {
          if ( !p->deferred )
            p->deferred = ysLstCreate();
          DISCARD ysLstEnq( p->deferred, (dvoid*)obj);
        }
        return !top;
      }
      default:
        top = FALSE;
        break;
    }
  }
  return FALSE;
}



yrobj* ycgScopeLookup( ycctx* ctx, yrdk kind)
{
  ysle* le;

  if ( ctx->scopes )
  {
    for ( le = ysLstHead( ctx->scopes); le; le = ysLstNext(le))
    {
      ycgscope* s = (ycgscope*) ysLstVal(le);

      if ( yrGetKind(s->scope) == kind )
        return s->scope;
    }
  }
  return (yrobj*)0;
}



ub4 ycgScopeModuleDepth( ycctx* ctx)
{
  ub4 count = 0;
  ysle* le;

  if ( ctx->scopes )
  {
    for ( le = ysLstTail(ctx->scopes); le; le = ysLstPrev(le))
    {
      ycgscope* s = (ycgscope*) ysLstVal(le);

      switch (yrGetKind(s->scope))
      {
        case yrdkModule:
          count++;
          break;
        case yrdkInterface:      
        case yrdkStruct:
        case yrdkUnion:
        case yrdkException:
          return count;
        default:
          break;
      }
    }
  }
  return count;
}



boolean ycShouldGenCode( ycctx* ctx, yrobj* obj)
{
  yrobj* o;
  yrobj* inInterface = ycgScopeLookup( ctx, yrdkInterface);
  CONST char* srcnm;

  if ( ysResGetLast("mnidlc.gen-include") )
    return TRUE;
  else if ( inInterface &&
            (yrGetKind(yrGetDefinedIn(obj)) == yrdkInterface) )
    o = inInterface;	
  else
    o = obj;
  srcnm = yrGetSrcName(o);
  return (srcnm && !strcmp( yrGetSrcName(o), ctx->srcnm));
}





boolean ycgInherited( ycctx* ctx, yrobj* obj)
{
  yrobj* inInterface = ycgScopeLookup( ctx, yrdkInterface);
  yrobj* p;

  if ( !inInterface )
    return FALSE;

  for ( p = yrGetDefinedIn(obj); yrGetKind(p) != yrdkRepository; 
        p = yrGetDefinedIn(p))
  {
    switch (yrGetKind(p))
    {
      case yrdkInterface:
        return (p != inInterface);
      case yrdkModule:
      case yrdkRepository:
        return FALSE;
      default:
        break;
    }
  }
  return FALSE;
}




void ycgObjDestroy( dvoid* obj)
{
  ycgobj* cgobj = (ycgobj*) obj;

  if ( cgobj->objlist )
    ysLstDestroy( cgobj->objlist, (ysmff)ycgObjDestroy);
  ysmGlbFree(obj);
}








boolean ycFileInit( ycfile* files, ub4 count, CONST char* path)
{
  char dir[SYSFP_MAX_PATHLEN];
  CONST char* errtxt;
  boolean err;
  ub4 i;
  sysfp* fp;

  yseTry
      
    err = FALSE;
    if ( path && (strlen(path) > (size_t)0) )
    {
      if ( !sysfpIsDir(path) )
      {
        ysRecord( YCMSG(9), YCERRSEV, YSLSTR(path), YSLEND);
        err = TRUE;
      }
      else if ( !sysfpAccess(path, "w") )
      {
        ysRecord( YCMSG(6), YCERRSEV, YSLSTR(path), YSLEND);
        err = TRUE;
      }
    }
    else                      
    {
      errtxt = sysfpGetCwd(dir);
      if ( errtxt )
      {
        ysRecord( YCMSG(1), YCERRSEV, YSLSTR("Current working directory"), 
                  YSLSTR(errtxt), YSLEND);
        err = TRUE;
      }
      else if ( !sysfpAccess(dir, "w") )
      {
          ysRecord( YCMSG(6), YCERRSEV, YSLSTR(dir), YSLEND);
          err = TRUE;
      }
    }
  
      
    if ( !err )
    {
      for (i = 0; i < count; i++)
      {
        fp = sysfpOpen( files[i].target, "r", SYSFPKIND_TEXT, &errtxt);
        if ( fp )                                                 
        {
          sysfpClose(fp);
          fp = sysfpOpen( files[i].target, "a", SYSFPKIND_TEXT, &errtxt);
          if ( !fp )                                       
          {
            ysRecord( YCMSG(8), YCERRSEV, YSLSTR(files[i].target), 
                      YSLSTR(errtxt), YSLEND);
            err = TRUE;
            break;
          }
          else                                   
          {
            sysfpClose(fp);
            sysfpTemp(files[i].oldtmp, path, (char*)0);
            files[i].exists = TRUE;
          }
        }
        else                                               
          files[i].exists = FALSE;
        sysfpTemp(files[i].newtmp, path, (char*)0);
      }
    }
  yseCatchAll
    err = TRUE;
  yseEnd
  return !err;
}




void ycFileRename( ycfile* files, ub4 count)
{
  boolean err;
  ub4 i,j;
  CONST char* errtxt;

  err = FALSE;
  for (i = 0; i < count; i++)
  {
    if ( files[i].exists )                       
    {
      errtxt = sysfpRename(files[i].target, files[i].oldtmp);
      if ( errtxt )
      {
        ysRecord( YCMSG(8), YCERRSEV, YSLSTR(files[i].target), 
                  YSLSTR(errtxt), YSLEND);
        err = TRUE;
        break;
      }
    }
    errtxt = sysfpRename(files[i].newtmp, files[i].target);    
    if ( errtxt )
    {
      ysRecord( YCMSG(8), YCERRSEV, YSLSTR(files[i].target), 
                YSLSTR(errtxt), YSLEND);
      if ( files[i].exists )
        DISCARD sysfpRename(files[i].oldtmp, files[i].target);
      err = TRUE;
      break;
    }
  }

  if ( err )                          
  {
    for (j = 0; j < count; j++)
    {
      if ( j < i )                                     
      {
        DISCARD sysfpRemove(files[j].target);
        if ( files[j].exists )
          DISCARD sysfpRename(files[j].oldtmp, files[j].target);
      }
      else                                         
        DISCARD sysfpRemove(files[j].newtmp);
    }
  }
  else                                                   
  {
    for (i = 0; i < count; i++)
      if ( files[i].exists )
        DISCARD sysfpRemove(files[i].oldtmp);
  }
}




char* ycStrLitToString( ycctx* ctx, yslst* strs)
{
  ysle* le;
  char* result = (char*)0;
  char* p;
  size_t len = 0;

  if ( !strs )
    return (char*)0;

  if ( strs )
  {
    for ( le = ysLstHead( strs); le; le = ysLstNext(le))
    {
      len += strlen( (char*)ysLstVal(le)) - 2;    
    }
    len++;       
    result = (char*)ysmGlbAlloc( len, "stringlit");
    p = result;
    for ( le = ysLstHead( strs); le; le = ysLstNext(le))
    {
      char* s = (char*) ysLstVal(le);
      len = strlen(s) - 2;
      if ( len > 0 )
      {
        strncpy(p, s+1, len);
        p += len;
      }
    }
    *p = '\0';
  }
  return result;
}




dvoid* ycAllocTC(size_t len)
{
  return ysmGlbAlloc(len, "yotk");
}
