/* mx/src/yc/ycchdr.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCC0_ORACLE
#include <ycc0.h>
#endif
#ifndef YSSTR_ORACLE
#include <ysstr.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif

STATICF void yccGenDerivedFunc( ycctx* ctx, yccfp* fp, CONST char* dname, 
                                CONST char* bname, yrobj* bintf, 
                                yrobj* rettype, yslst* pars, yslst* ctxs);
STATICF void yccGenCGObjs( ycctx* ctx, yccfp* fp, yslst* objs);




#define yccGenSimpleDerived( ctx, fp, dname, bname) \
  { \
    yccfpStartPP( (fp)); \
    yccfpPrint( fp, "#ifndef %s\n#define %s %s\n#endif /* %s */\n\n", \
                (dname), (dname), (bname), (dname)); \
    yccfpEndPP( (fp)); \
  }



void ycchdr(ycctx *ctx, char *base, ycfile* fd)
{
  yccfp *fp;
  char  *upbase;
  CONST char* errtxt;
  ysle* le;
  CONST char* guardsfx = 
           ((ycStyleOra(ctx) && !ycCORBA1_2(ctx)) ? "ORACLE" : "IDL");




  
  fp = yccfpOpen(fd->newtmp, "w", SYSFPKIND_NONE, &errtxt, 
                 yccGetLineLimit(ctx));
  if ( !fp )
  {
    ysRecord( YCMSG(1), YCERRSEV, YSLSTR(fd->target), YSLSTR(errtxt), YSLEND);
    return;
  }
  upbase = ycToUpper(ysStrDup(base));    

  
  yccfpSetIndent( fp, 0);
  yccfpPrint(fp, "/* GENERATED FILE\n * %s - public declarations\n", base);
  yccfpPrint(fp, " * from %s\n */\n\n", ctx->srcnm);
  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s_%s\n#define %s_%s\n\n", 
              upbase, guardsfx, upbase, guardsfx);
  yccfpEndPP( fp);
  yccGenSysIncls(ctx, fp, FALSE);
  yccfpPrint( fp, "EXTC_START\n\n");       

  
  if ( ysLstCount( ctx->seqs) > 0 )
  {
    yccfpPrint( fp, "/**********  SEQUENCE DECLARATIONS *********/\n");
    for ( le = ysLstHead(ctx->seqs); le; le = ysLstNext(le))
    {
      yrobj* obj = (yrobj*) ysLstVal(le);
      yccGenDecl( ctx, fp, obj, TRUE);
    }
  }
  
  
  if ( ysLstCount( ctx->newobjs) > 0 )
  {
    yccfpPrint( fp, "/******* NON-SEQUENCE DECLARATIONS *******/\n");
    yccGenCGObjs( ctx, fp, ctx->newobjs);
  }

  
  yccfpPrint( fp, "EXTC_END\n#endif /* %s_%s */\n", upbase, guardsfx);

  ysmGlbFree((dvoid *) upbase);
  yccfpClose( fp);
}




void yccGenDecl(ycctx* ctx, yccfp* fp, yrobj* obj, boolean isForward)
{
  switch ( yrGetKind(obj) )
  {
    case yrdkInterface:
      yccGenIntfDecl(ctx, fp, obj, isForward);
      break;
    case yrdkConstant:
	
      if ( !ycIsEnumConst(obj) )
	yccGenConstDecl(ctx,fp, obj);
      break;
    case yrdkException:
      yccGenExDecl(ctx, fp, obj, isForward);
      break;
    case yrdkTypedef:
    case yrdkAlias:
      yccGenAliasDecl(ctx, fp, obj, isForward);
      break;
    case yrdkStruct:
      yccGenStructDecl(ctx, fp, obj, isForward);
      break;
    case yrdkUnion:
      yccGenUnionDecl(ctx, fp, obj, isForward);
      break;
    case yrdkEnum:
      yccGenEnumDecl(ctx, fp, obj, isForward);
      break;
    case yrdkSequence:
      yccGenSequenceDecl(ctx, fp, obj);
      break;
    case yrdkArray:
      break;
    case yrdkAttribute:
      yccGenAttrDecl(ctx, fp, obj, FALSE);
      break;
    case yrdkOperation:
      yccGenOpDecl(ctx, fp, obj, FALSE);
      break;
    default:
      
      break;
  }
}





STATICF void yccGenCGObjs( ycctx* ctx, yccfp* fp, yslst* objs)
{
  ysle* le;

  if ( objs )
  {
    for ( le = ysLstHead(objs); le; le = ysLstNext(le))
    {
      ycgobj* cgobj = (ycgobj*) ysLstVal(le);
  
      if ( yrGetKind(cgobj->ifrobj) == yrdkModule )
        yccGenCGObjs( ctx, fp, cgobj->objlist);
      else
        yccGenDecl( ctx, fp, cgobj->ifrobj, cgobj->flags & YCG_FWD);
    }
  }
}



void yccGenConstDecl(ycctx *ctx, yccfp *fp, yrobj *obj)
{
  CONST char  *name;

  name = yccGetAbsoluteName(ctx, obj, (yrobj*)0);
  if ( ycgInherited(ctx, obj) )
  {
    yrobj* inInterface = ycgScopeLookup( ctx, yrdkInterface);
    CONST char* dname = yccGetAbsoluteName( ctx, obj, inInterface);
    yccGenSimpleDerived( ctx, fp, dname, name);
    ysmGlbFree( (dvoid*)dname);
    return;
  }

  if ( yccNeedsGuard(obj) )
    yccGenOpenGuard(ctx, fp, name, FALSE);

	
  yccfpStartPP( fp);
  yccfpPrint(fp, "#define %s ((", name);
  yccGenTypeName(ctx, fp, yrConstData(obj).type);
  yccfpPrint(fp, ") ");
  yccGenConstVal( ctx, fp, obj);
  yccfpPrint(fp,")\n");
  yccfpEndPP( fp);

  if ( yccNeedsGuard(obj) )
    yccGenCloseGuard(ctx, fp, name, FALSE);
}






void yccGenIntfDecl(ycctx* ctx, yccfp* fp, yrobj* intf, boolean fwd)
{
  CONST char* name;
  ysle* le;
  boolean genDefn;
  yrobj* mem;

  if ( ycIsCorbaObject( ctx, intf) )   
    return;

  genDefn = ycShouldGenCode( ctx, intf);
  name = yccGetAbsoluteName(ctx, intf, (yrobj*)0);

  yccfpPrint(fp, "\n/* interface %s declarations */\n", name);
  yccGenOpenGuard(ctx, fp, name, FALSE);
  if ( ycStyleCORBA(ctx) )
    yccfpPrint(fp, "typedef CORBA_Object %s;\n", name, name);
  else
    yccfpPrint(fp, "typedef struct YC%s* %s;\n", name, name);
  if ( yccNeedsTypeCode( ctx, intf) )
    yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
  yccGenCloseGuard(ctx, fp, name, FALSE);
  yccGenSupportFuncs( ctx, fp, intf, FALSE);
  if ( fwd )
  {
    return;
  }

    
  if ( genDefn )
  {
    yccGenOpenGuard( ctx, fp, name, TRUE);
    yccfpStartPP( fp);
    yccfpPrint( fp, "struct yostub* %s__getStubs(void);\n", name);
    yccfpPrint( fp, "#define %s__stubs (%s__getStubs())\n", name, name);
    yccfpEndPP( fp);
    yccGenCloseGuard( ctx, fp, name, TRUE);
  }
  yccGenId( ctx, fp, name, name, TRUE, (char*)0);

      
  ycgPushScope( ctx, intf);
  for (le = ysLstHead( yrGetContents(intf)); le; le = ysLstNext(le))
  {
    mem = (yrobj*) ysLstVal(le);
    yccGenDecl( ctx, fp, mem, FALSE);
  }

  if ( genDefn )
  {
    ycsym* syminfo = ycSymLookup( ctx->symtbl, intf);
    yslst* all = (syminfo ? syminfo->opsNattrs : (yslst*)0);

	
    if ( !ycIsEmptyLst(all) )
    {
      yccfpStartPP( fp);
      yccfpPrint( fp, "#ifndef %s__tyimpl_DEFINED\n", name);
      yccfpPrint( fp, "#define %s__tyimpl_DEFINED\n", name);
      yccfpEndPP( fp);
      yccfpPrint(fp, "struct %s__tyimpl\n{\n", name);
      yccfpIncIndent( fp);

      
      for ( le = ysLstHead(all); le; le = ysLstNext(le))
      {
        mem = (yrobj*)ysLstVal(le);
        if ( yrGetKind(mem) == yrdkOperation )
          yccGenOpDecl( ctx, fp, mem, TRUE);
        else
          yccGenAttrDecl( ctx, fp, mem, TRUE);
      }

      yccfpDecIndent( fp);
      yccfpPrint(fp, "};\n");
      yccfpPrint( fp, "#endif /* %s__tyimpl_DEFINED */\n\n", name);
    }
  }
  DISCARD ycgPopScope(ctx);
}




void yccGenExDecl( ycctx* ctx, yccfp* fp, yrobj* ex, boolean fwd)
{
  CONST char* exName = (char*)0;      
  CONST char* name = (char*)0;        
  sword saveStyle = ctx->style;
  boolean inherited = ycgInherited( ctx, ex);

	
  if ( !fwd )
  {
    ctx->style |= YCSTYLE_EXC;
    exName = yccGetAbsoluteName(ctx, ex, (yrobj*)0);
    if ( inherited )
    {
      CONST char* dname;

      dname = yccGetAbsoluteName(ctx, ex, ycgScopeLookup( ctx, yrdkInterface));
      yccGenSimpleDerived( ctx, fp, dname, exName);
      if ( !yrStructData(ex).mbrs )
        yccGenTypeCodeMacro( ctx, fp, dname, ex);
      ysmGlbFree( (dvoid*)dname);
      ctx->style = saveStyle;
    }
    else			
    {
      ctx->style = saveStyle;
      yccGenOpenGuard(ctx, fp, exName, FALSE);
      name = yccGetAbsoluteName( ctx, ex, (yrobj*)0);
      yccGenId( ctx, fp, exName, name, FALSE, (char*)0);
      yccGenCloseGuard(ctx, fp, exName, FALSE);
    }
    ysmGlbFree((dvoid*) exName);
  }

	
  if ( yrStructData(ex).mbrs )
    yccGenStructDecl(ctx, fp, ex, fwd);
  else if ( !fwd && !inherited && yccNeedsTypeCode( ctx, ex) )
  {     
    if ( !name)
      name = yccGetAbsoluteName( ctx, ex, (yrobj*)0);
    yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
  }
}




void yccGenStructDecl( ycctx* ctx, yccfp* fp, yrobj* sobj, boolean fwd)
{
  CONST char* name;
  ysle* le;

  name = yccGetAbsoluteName(ctx, sobj, (yrobj*)0);
  if ( ycgInherited( ctx, sobj) )
  {
    CONST char* dname;
    dname = yccGetAbsoluteName(ctx, sobj, ycgScopeLookup( ctx, yrdkInterface));
    yccGenSimpleDerived( ctx, fp, dname, name);
    if ( !fwd )
      yccGenTypeCodeMacro( ctx, fp, dname, sobj);
    ysmGlbFree( (dvoid*)dname);
  }

  else              
  {
    if ( !fwd )     
    {
      for (le = ysLstHead( yrGetContents(sobj)); le; le = ysLstNext(le))
        yccGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
    }

    yccGenOpenGuard( ctx, fp, name, FALSE);
    yccfpPrint( fp, "typedef struct %s %s;\n", name, name);
    yccGenCloseGuard( ctx, fp, name, FALSE);

    if ( !fwd )
    {
      yccGenOpenGuard(ctx, fp, name, TRUE);

      yccfpPrint(fp, "struct %s\n{\n", name);
      yccfpIncIndent( fp);
      for (le = ysLstHead(yrStructData(sobj).mbrs); le; le = ysLstNext(le))
      {
        yrstrmbr* mem = (yrstrmbr*) ysLstVal(le);
        yccGenField(ctx, fp, mem->type, mem->name);
      }
      yccfpDecIndent( fp);
      yccfpPrint(fp, "};\n");

      if ( yccNeedsTypeCode( ctx, sobj) )
        yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
      yccGenCloseGuard(ctx, fp, name, TRUE);
    }
  }

  if ( !fwd )
    yccGenSupportFuncs( ctx, fp, sobj, FALSE);
}




void yccGenUnionDecl( ycctx* ctx, yccfp* fp, yrobj* uobj, boolean fwd)
{
  CONST char* name;
  ysle* le;

  name = yccGetAbsoluteName(ctx, uobj, (yrobj*)0);
  if ( ycgInherited( ctx, uobj) )
  { 
    CONST char* dname;

    dname = yccGetAbsoluteName(ctx, uobj, ycgScopeLookup( ctx, yrdkInterface));
    yccGenSimpleDerived( ctx, fp, dname, name);
    if ( !fwd )
      yccGenTypeCodeMacro( ctx, fp, dname, uobj);
    ysmGlbFree( (dvoid*)dname);
  }
  else                          
  {
    if ( !fwd )     
    {
      for (le = ysLstHead( yrGetContents(uobj)); le; le = ysLstNext(le))
        yccGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
    }

    yccGenOpenGuard(ctx, fp, name, FALSE);
    yccfpPrint(fp, "typedef struct %s %s;\n", name, name);
    yccGenCloseGuard(ctx, fp, name, FALSE);

    if ( !fwd )
    {
      CONST char* prevnm;

      yccGenOpenGuard(ctx, fp, name, TRUE);

      yccfpPrint(fp, "struct %s\n{\n", name);
      yccfpIncIndent( fp);
      yccGenField(ctx, fp, yrUnionData(uobj).disctype, "_d");
      yccfpPrint(fp, "union\n{\n");
      yccfpIncIndent( fp);
      prevnm = "";
      for (le = ysLstHead(yrUnionData(uobj).arms); le; le = ysLstNext(le))
      {
        yrunmbr* mem = (yrunmbr*) ysLstVal(le);
        if ( strcmp(mem->name, prevnm) != 0 )
        {
          yccGenField(ctx, fp, mem->type, mem->name);
          prevnm = mem->name;
        } 
      }
      yccfpDecIndent( fp);
      yccfpPrint(fp, "} _u;\n");
      yccfpDecIndent( fp);
      yccfpPrint( fp, "};\n");

      if ( yccNeedsTypeCode( ctx, uobj) )
        yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
      yccGenCloseGuard(ctx, fp, name, TRUE);
    }
  }

  if ( !fwd )
    yccGenSupportFuncs( ctx, fp, uobj, FALSE);
}





void yccGenArrayDeclr( ycctx* ctx, yccfp* fp, yrobj* arr, CONST char* declr)
{
  yccfpPrint( fp, "%s", declr);
  for (; yrGetKind(arr) == yrdkArray; arr = yrArrayData(arr).elmtype)
  {
    yccfpPrint( fp, "[%u]", yrArrayData(arr).length);
  }
}





void yccGenField( ycctx* ctx, yccfp* fp, yrobj* type, CONST char* name)
{
  yccGenTypeName(ctx, fp, type);
  if ( yrGetKind(type) == yrdkArray )
  {
    char nm[20];                   
    CONST char* p;

    yccfpPrint( fp, " ");
    if ( (*ctx->lang->kwdchk)( ctx, name) )
    {
      nm[0] = '_';
      DISCARD strcpy( nm+1, name);
      p = nm;
    }
    else
      p = name;
    yccGenArrayDeclr( ctx, fp, type, p);
    yccfpPrint( fp, ";\n");
  }
  else
    yccfpPrint( fp," %s%s;\n", 
                ((*ctx->lang->kwdchk)(ctx, name) ? "_" : ""), name);
}




void yccGenAliasDecl(ycctx* ctx, yccfp* fp, yrobj* alias, boolean fwd)
{
  CONST char* name;
  yrobj* basetype;

  if ( fwd )			
  {
    yrobj* p = yrAliasData(alias).type;

    while ( yrGetKind(p) == yrdkArray )	
      p = yrArrayData(p).elmtype;
    yccGenDecl( ctx, fp, p, TRUE);
  }

  name = yccGetAbsoluteName(ctx, alias, (yrobj*)0);
  basetype = yrAliasData(alias).type;
  if ( ycgInherited( ctx, alias) )
  { 
    CONST char* dname;

    dname = yccGetAbsoluteName(ctx, alias, ycgScopeLookup(ctx, yrdkInterface));
    yccGenSimpleDerived( ctx, fp, dname, name);
    if ( yrGetKind(basetype) == yrdkArray )
    {
      yccfpStartPP( fp);
      yccfpPrint( fp, "#ifndef %s_slice\n", dname);
      yccfpPrint( fp, "#define %s_slice %s_slice\n", dname, name);
      yccfpPrint( fp, "#endif /* %s_slice */\n\n", dname);
      yccfpEndPP( fp);
    }
    if ( !fwd )
    {
      yccGenSupportFuncs( ctx, fp, alias, FALSE);
      yccGenTypeCodeMacro( ctx, fp, dname, alias);
    }
    ysmGlbFree( (dvoid*)dname);
  }
  else
  {
    yccGenOpenGuard(ctx, fp, name, FALSE);

    yccfpPrint(fp, "typedef ");
    yccGenTypeName(ctx, fp, basetype);

      
    if ( yrGetKind(basetype) == yrdkArray )
    {
      yrobj* sliceType = yrArrayData(basetype).elmtype;
      char* sliceName = (char*) ysmGlbAlloc( strlen(name)+7, "slice");
  
      yccfpPrint( fp, " ");
      yccGenArrayDeclr( ctx, fp, basetype, name);
      yccfpPrint( fp, ";\n");
  
        
      yccfpPrint( fp, "typedef ");
      yccGenTypeName(ctx, fp, basetype);
      yccfpPrint( fp, " ");
      ysFmtStr( sliceName, "%s_slice", name);
      if ( yrGetKind(sliceType) == yrdkArray )
      {
        yccGenArrayDeclr( ctx, fp, sliceType, sliceName);
        yccfpPrint( fp, ";\n");
      }
      else
        yccfpPrint( fp, "%s;\n", sliceName);
      ysmGlbFree( (dvoid*)sliceName);
    }
      
    else
    {
      yccfpPrint(fp, " %s;\n", name);
    }
  
    if ( yccNeedsTypeCode( ctx, alias) )
      yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
    yccGenCloseGuard(ctx, fp, name, FALSE);
    yccGenSupportFuncs( ctx, fp, alias, FALSE);
  }
}




void yccGenEnumDecl(ycctx* ctx, yccfp* fp, yrobj* eobj, boolean fwd)
{
  CONST char* name;
  ysle* le;
  CONST char* dname;
  boolean inherited = ycgInherited( ctx, eobj);

  name = yccGetAbsoluteName(ctx, eobj, (yrobj*)0);
  if ( inherited )
  {
    dname = yccGetAbsoluteName(ctx, eobj, ycgScopeLookup(ctx, yrdkInterface));
    yccGenSimpleDerived( ctx, fp, dname, name);
    yccGenTypeCodeMacro( ctx, fp, dname, eobj);
    name = dname;
  }
  else
  {
    yccGenOpenGuard(ctx, fp, name, FALSE);
    yccfpPrint( fp, "typedef %s %s;\n", 
                ycStyleCORBA(ctx) ? "CORBA_enum" : "ub4", name);
    if ( yccNeedsTypeCode( ctx, eobj) )
      yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
    yccGenCloseGuard(ctx, fp, name, FALSE);
  }

  if ( !fwd )
  {
    yccGenOpenGuard(ctx, fp, name, TRUE);

    for (le = ysLstHead(yrEnumData(eobj).mbrs); le; le = ysLstNext(le))
    {
      yccGenConstDecl( ctx, fp, (yrobj*) ysLstVal(le));
    }

    yccGenCloseGuard(ctx, fp, name, TRUE);
    yccGenSupportFuncs( ctx, fp, eobj, FALSE);
  }
  if ( inherited )
    ysmGlbFree((dvoid*) name);
}




void yccGenSequenceDecl(ycctx* ctx, yccfp* fp, yrobj* seq)
{
  CONST char* name;
  yrobj* elemtype = yrSeqData(seq).elmtype;
  CONST char* ulongnm;

    
  for ( ; yrGetKind(elemtype) == yrdkAlias; 
          elemtype = yrAliasData(elemtype).type)
  {
    if ( yrGetKind(yrAliasData(elemtype).type) == yrdkArray )
      break;
  }

    
  switch ( yrGetKind(elemtype) )
  {
    case yrdkPrimitive:
    case yrdkString:
      if ( ctx->lang->flags & YCCFLG_BUILTIN_SEQ )
        return;	
      else
        break;
    case yrdkSequence:
      break;	
    default:	
      yccGenDecl( ctx, fp, elemtype, TRUE);
      break;
  }

    
  name = yccGetAbsoluteName(ctx, seq, (yrobj*)0);
  yccGenOpenGuard(ctx, fp, name, TRUE);
  yccfpPrint( fp, "typedef struct\n{\n");
  yccfpIncIndent( fp);
  ulongnm = yccGetPrimitiveName( ctx, yrpkulong);
  yccfpPrint( fp, "%s _maximum;\n%s _length;\n", ulongnm, ulongnm);
  yccGenTypeName( ctx, fp, elemtype);
  yccfpPrint( fp, "* _buffer;\n");
  if ( !ycCORBA1_2(ctx) )
    yccfpPrint( fp, "%s _release;\n", yccGetPrimitiveName( ctx, yrpkboolean));
  yccfpDecIndent( fp);
  yccfpPrint( fp, "} %s;\n", name);

  yccGenSupportFuncs( ctx, fp, seq, FALSE);
  yccGenCloseGuard( ctx, fp, name, TRUE);
}





void yccGenAttrDecl(ycctx* ctx, yccfp* fp, yrobj* attr, boolean fptr)
{
  CONST char* base;	     
  char* attrName;
  char* name;		            
  yrobj* voidType;
  CONST char* dbase = (char*)0;	         
  char* dname = (char*)0;	              
  yrobj* bintf = yrGetDefinedIn(attr);
  yrobj* inInterface = (yrobj*)0;
  boolean inherited;
  yrobj* intf;

  if ( !ycShouldGenCode( ctx, attr) )
    return;		

  inherited = ycgInherited( ctx, attr);
  if ( inherited )
  {
    inInterface = ycgScopeLookup( ctx, yrdkInterface);
    intf = inInterface;
  }
  else
    intf = bintf;
  base = fptr ? "" : yccGetAbsoluteName( ctx, bintf, (yrobj*)0);
  attrName = yrGetName(attr);
  voidType = yrGetPrimitive( ctx->repository, yrpkvoid);
  name = (char*) ysmGlbAlloc(strlen(base) + strlen(attrName) + 7, "attrName");
		

    
  if ( inherited && !fptr )
  {
    dbase = yccGetAbsoluteName( ctx, inInterface, (yrobj*)0);
    dname = (char*) ysmGlbAlloc(strlen(dbase) + strlen(attrName) + 10, 
		"attrName");
    DISCARD ysFmtStr( name, "%s__get_%s", base, attrName);
    DISCARD ysFmtStr( dname, "%s__get_%s", dbase, attrName);
    yccGenDerivedFunc( ctx, fp, dname, name, bintf, yrAttrData(attr).type, 
                       (yslst*)0, (yslst*)0);
  }
  else		
  {
    if ( !fptr )
      DISCARD ysFmtStr( name, "%s__get_%s", base, attrName);
    else
      DISCARD ysFmtStr( name, "_get_%s", attrName);
    yccGenFuncHdr( ctx, fp, yrAttrData(attr).type, intf,
		   name, (yslst*)0, (yslst*)0, fptr, yccfnk_normal);
    yccfpPrint(fp,";\n");
      
    if ( !fptr )
    {
      if ( yccGenAsync(ctx) )
      {
        yccGenFuncHdr( ctx, fp, voidType, intf, name, (yslst*)0, 
                       (yslst*)0, fptr, yccfnk_nw);
        yccfpPrint( fp, ";\n");
      }
      yccGenParsDecl( ctx, fp, name);
    }
  }

    
  if ( yrAttrData(attr).mode != YR_ATTR_RO )
  {
    yrpar param;
    yslst* pars = ysLstCreate();

    param.name = "val";
    param.type = yrAttrData(attr).type;
    param.mode = YOMODE_IN;
    DISCARD ysLstEnq( pars, (dvoid*) &param);

    if ( inherited && !fptr )
    {
      DISCARD ysFmtStr( name, "%s__set_%s", base, attrName);
      DISCARD ysFmtStr( dname, "%s__set_%s", dbase, attrName);
      yccGenDerivedFunc( ctx, fp, dname, name, bintf, voidType, pars,
                         (yslst*)0);
    }
    else
    {
      if ( !fptr )
	DISCARD ysFmtStr( name, "%s__set_%s", base, attrName);
      else
	DISCARD ysFmtStr( name, "_set_%s", attrName);

	
      yccGenFuncHdr( ctx, fp, voidType, intf, name, pars, (yslst*)0, 
                     fptr, yccfnk_normal);
      yccfpPrint(fp,";\n");
	
      if ( !fptr )
      {
        if ( yccGenAsync(ctx) )
        {
	  yccGenFuncHdr( ctx, fp, voidType, intf, name, pars, (yslst*)0, 
                         fptr, yccfnk_nw);
          yccfpPrint( fp, ";\n");
        }
        yccGenParsDecl( ctx, fp, name);
      }
    }
    ysLstDestroy( pars, (ysmff)0);
  }

  ysmGlbFree((dvoid*)name);
  if ( inherited && !fptr )
  {
    ysmGlbFree((dvoid*)dname);
  }
}




void yccGenOpDecl(ycctx* ctx, yccfp* fp, yrobj* op, boolean fptr)
{
  CONST char* name = (char*) 0;
  yrobj* inInterface = (yrobj*) 0;
  boolean inherited;

  if ( !ycShouldGenCode( ctx, op) )
    return;

  inherited = ycgInherited( ctx, op);
  if ( inherited )
    inInterface = ycgScopeLookup( ctx, yrdkInterface);

  if ( inherited && !fptr )
  {
    CONST char* dname;

    dname = yccGetAbsoluteName( ctx, op, inInterface);
    yccGenDerivedFunc( ctx, fp, dname, yccGetAbsoluteName(ctx, op, (yrobj*)0),
			yrGetDefinedIn(op), yrOpData(op).rettype, 
			yrOpData(op).pars, yrOpData(op).ctxts);
    ysmGlbFree( (dvoid*)dname);
  }
  else
  {
    yrobj* intf = inherited ? inInterface : yrGetDefinedIn(op);

    if ( !fptr )
      name = yccGetAbsoluteName(ctx, op, intf);
    else
      name = yrGetName(op);
    yccGenFuncHdr( ctx, fp, yrOpData(op).rettype, intf, name,
		   yrOpData(op).pars, yrOpData(op).ctxts, fptr, yccfnk_normal);
    yccfpPrint(fp, ";\n");

	
    if ( !fptr )
    {
      if ( yccGenAsync(ctx) )
      {
        yccGenFuncHdr( ctx, fp, yrGetPrimitive( ctx->repository, yrpkvoid), 
		      intf, name, yrOpData(op).pars, yrOpData(op).ctxts, 
                      FALSE, yccfnk_nw);
        yccfpPrint( fp, ";\n");
      }
      yccGenParsDecl( ctx, fp, name);
    }
  }
}




void yccGenTypeName( ycctx* ctx, yccfp* fp, yrobj* type)
{
  CONST char* tname;

  switch (yrGetKind(type))
  {
    case yrdkInterface:
    case yrdkUnion:
    case yrdkStruct:
    case yrdkException:
    case yrdkAlias:
    case yrdkTypedef:
    case yrdkEnum:
    case yrdkSequence:
      tname = yccGetAbsoluteName(ctx, type, (yrobj*)0);
      yccfpPrint(fp,"%s", tname);
      break;
    case yrdkString:
      yccGenPrimitiveName(ctx, fp, yrpkstring);
      break;
    case yrdkArray:	
    {
      yrobj* eltype = type;

      while ( yrGetKind(eltype) == yrdkArray )	
	eltype = yrArrayData(eltype).elmtype;
      yccGenTypeName(ctx, fp, eltype);
      break;
    }
    case yrdkPrimitive:
      yccGenPrimitiveName(ctx, fp, yrPrimData(type).kind);
      break;
    default:
      yseThrow(YS_EX_FAILURE);
      break;
  }
}




STATICF void yccGenDerivedFunc( ycctx* ctx, yccfp* fp, CONST char* dname, 
	CONST char* bname, yrobj* bintf, yrobj* rettype, yslst* pars, 
        yslst* ctxs)
{
  ysle* le;
  CONST char* base = yccGetAbsoluteName( ctx, bintf, (yrobj*) 0);
  yrobj* voidType = yrGetPrimitive(ctx->repository, yrpkvoid);

      
  if ( !ycShouldGenCode( ctx, bintf) )
  {	
    yccGenFuncHdr( ctx, fp, rettype, bintf, bname, pars, 
                   ctxs, FALSE, yccfnk_normal);
    yccfpPrint(fp,";\n");
    if ( yccGenAsync(ctx) )
    {
      yccGenFuncHdr( ctx, fp, voidType, bintf, bname, pars, 
                     ctxs, FALSE, yccfnk_nw);
      yccfpPrint(fp, ";\n");
    }
    yccGenParsDecl( ctx, fp, bname);
  }

      
  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s\n#define %s(or", dname, dname);
  if ( ycCORBA1_2(ctx) )
    yccfpPrint( fp, ", ev");

  if ( pars )
    for ( le = ysLstHead( pars); le; le = ysLstNext(le))
      yccfpPrint( fp, ", %s", ((yrpar*)ysLstVal(le))->name);

  if ( ycCORBA1_2(ctx) )
    yccfpPrint( fp, ") \\\n    %s((%s)(or), (ev)", bname, base);
  else
  {
    if ( !ycIsEmptyLst(ctxs) )
      yccfpPrint( fp, ", corbctx_");
    yccfpPrint( fp, ", ev) \\\n    %s((%s)(or)", bname, base);
  }

  if ( pars )
    for ( le = ysLstHead( pars); le; le = ysLstNext(le))
      yccfpPrint( fp, ", (%s)", ((yrpar*)ysLstVal(le))->name);
  if ( ycCORBA1_2(ctx) )
    yccfpPrint( fp, ")\n");
  else
  {
    if ( !ycIsEmptyLst(ctxs) )
      yccfpPrint( fp, ", (corbctx_)");
    yccfpPrint( fp, ", (ev))\n");
  }

      
  if ( yccGenAsync(ctx) )
  {
    yccfpPrint( fp, "#define %s_nw(or", dname);
    if ( ycCORBA1_2(ctx) )
      yccfpPrint( fp, ", ev");

    if ( pars )
      for ( le = ysLstHead( pars); le; le = ysLstNext(le))
        yccfpPrint( fp, ", %s", ((yrpar*)ysLstVal(le))->name);

    if ( ycCORBA1_2(ctx) )
      yccfpPrint( fp, ", ue) \\\n    %s_nw((%s)(or), (ev)", bname, base);
    else
    {
      if ( !ycIsEmptyLst(ctxs) )
        yccfpPrint( fp, ", corbctx_");
      yccfpPrint( fp, ", ev, ue) \\\n    %s_nw((%s)(or)", bname, base);
    }

    if ( pars )
      for ( le = ysLstHead( pars); le; le = ysLstNext(le))
        yccfpPrint( fp, ", (%s)", ((yrpar*)ysLstVal(le))->name);

    if ( !ycCORBA1_2(ctx) )
    {
      if ( !ycIsEmptyLst(ctxs) )
        yccfpPrint( fp, ", (corbctx_)");
      yccfpPrint( fp, ", (ev)");
    }
    yccfpPrint( fp, ", (ue))\n");
  } 

    
  yccfpPrint( fp, "#define %s_pars %s_pars\n#endif /* %s */\n\n", 
                      dname, bname, dname);
  yccfpEndPP( fp);
}




void yccGenParsDecl( ycctx* ctx, yccfp* fp, CONST char* opnm)
{
  yccfpPrint( fp, "yopar* %s__getPars(void);\n", opnm);
  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s_pars\n", opnm);
  yccfpPrint( fp, "#define %s_pars (%s__getPars())\n", opnm, opnm);
  yccfpPrint( fp, "#endif\n\n");
  yccfpEndPP( fp);
}

