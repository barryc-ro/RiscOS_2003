/* Copyright (c) 1995 by Oracle Corporation.  All Rights Reserved.
 *
 * boa.h - Oracle BOA compatiblity layer
 */

#ifndef YOBOA_ORACLE
#define YOBOA_ORACLE

#ifndef YOORB_ORACLE
#include <yoorb.h>
#endif
#ifndef YOCOA_ORACLE
#include <yocoa.h>
#endif

EXTC_START

typedef CORBA_Object CORBA_BOA;

/*
 * CORBA_BOA_create - create an object
 *
 * DESCRIPTION
 * CORBA_BOA_create() creates an object.  intf and impl together must define
 * an implementation previously specified with ORA_CORBA_BOA_set_impl().  An
 * object reference to the created object is returned.
 *
 * id is a pointer to reference data whose type is sequence<octet>.
 * The id is immutable identification information, chosen by the
 * implementation at object creation time and never changed.  The
 * usage of the id is entirely implementation-defined.  Two objects
 * created with the same id are not the same object as far as the
 * object layer is concerned.  For implementations with loaders,
 * the reference data is made available to the loader to allow
 * the object to be reactivated.  In other words, it persists past
 * the activation (unlike the state).  The id may be null.  If id is
 * non-null, the value is copied into the reference returned.
 */
CORBA_Object CORBA_BOA_create(CORBA_BOA boa, CORBA_Environment *ev,
                         CORBA_ReferenceData *id, CORBA_InterfaceDef intf,
                         CORBA_ImplementationDef impl);
/*
 * CORBA_BOA_dispose - destroy an object
 *
 * DESCRIPTION
 * CORBA_BOA_dispose() destroys an object.  This may be used even if there
 * are still outstanding references to the object.  These references will
 * no longer be valid.
 */
void CORBA_BOA_dispose(CORBA_BOA boa, CORBA_Environment *ev, CORBA_Object obj);

/*
 * CORBA_BOA_get_id - reference data from an object
 *
 * DESCRIPTION
 * Returns a copy of the reference data associated with the specified object.
 * ORA_CORBA_BOA_free_id() should be used to free the reference data returned.
 */
CORBA_ReferenceData *CORBA_BOA_get_id(CORBA_BOA boa, CORBA_Environment *ev,
                                      CORBA_Object obj);
/*
 * CORBA_BOA_set_exception - set exception
 *
 * DESCRIPTION
 * Places the excpetion described by major, userid, and param into the
 * environment, ev.  Major specifies the type of the exception.  userid
 * specifies the exception id which is returned via CORBA_exception_id().
 * param specifies the value returned via CORBA_exception_value().
 */
void CORBA_BOA_set_exception(CORBA_BOA boa, CORBA_Environment *ev,
                             CORBA_exception_type major, CORBA_char *userid,
                             void *param);
/*
 * CORBA_BOA_impl_is_ready - implemenation ready
 *
 * DESCRIPTION
 * CORBA_BOA_impl_is_ready() notifies the ORB that all interfaces with the
 * specified impl are ready to process requests.
 */
void CORBA_BOA_impl_is_ready(CORBA_BOA boa, CORBA_Environment *ev,
                             CORBA_ImplementationDef impl);
/*
 * CORBA_BOA_deactivate_impl - implementation deactivate
 *
 * DESCRIPTION
 * CORBA_BOA_deactivate_impl() notifies the ORB that the specified impl is 
 * no longer available to process requests.
 */
void CORBA_BOA_deactivate_impl(CORBA_BOA boa, CORBA_Environment *ev,
                               CORBA_ImplementationDef impl);

/* BOA extensions */

/* 
 * ORA_CORBA_ORB_BOA_init - init & term BOA
 *
 * DESCRIPTION
 * ORA_CORBA_ORB_BOA_init() inits the BOA and returns a CORBA_BOA object
 * reference for use with all of the interfaces described in this interface
 * file.
 * ORA_CORBA_ORB_BOA_term() terminates the BOA.
 */
CORBA_BOA ORA_CORBA_ORB_BOA_init(void);
void ORA_CORBA_ORB_BOA_term(CORBA_BOA boa, CORBA_Environment *ev);

/*
 * ORA_CORBA_BOA_set_impl - define an implementation
 *
 * DESCRIPTION
 * ORA_CORBA_BOA_set_impl() binds an interface to its implementation.
 * The interface is identified by its CORBA_InterfaceDef object reference
 * generated by calling ORA_CORBA_IdToIntfDef with the IDL compiler with the
 * name <interface>__id.  The implementation is identified by its
 * CORBA_ImplementationDef. If no implementation id is specified,
 * the program name is used (taken from ysProgName()) to create the
 * CORBA_ImplementationDef.
 *
 * An implementation consists of a set of stubs, an implementation
 * dispatch vector, an object adapter, and optionally, a object loader.
 * The elements are explained as follows:
 *
 * stubs is a null-terminated array of server-side stub routines that
 * will be invoked when a request arrives.  These are the skeletons
 * that perform the unmarshalling of the request, make the upcall,
 * and then marshal the results.  The server-side stub routines are
 * generated by the IDL compiler which also generates an array
 * named <interface>__stubs for use here.  Note that the stubs are
 * specific to the interface, not the implementation, and
 * so the same set of stubs may be used for several different
 * implementations to the same interface.
 *
 * The impldef is a structure whose fields point to the actual routines
 * that implement the operations.  The type of the structure is generated
 * by the IDL Compiler as is a default initialization for the structure.
 * This may be modified as necessary to bind different routines to the
 * operation names.  The name of the structure generated is
 * <interface>__impl.
 *
 * loader is the name of the loader function that is to be used during
 * object activation and deactivation of persistent objects.  If no
 * loader is provided, then objects for this implementation must be
 * created during execution and cannot live longer than the process itself.
 *
 * state is a pointer to some optional state information which may be
 * associated with a particular implementation.
 *
 * stateless is a boolean which indicates if the implementation is stateless.
 * If an implementation is stateless, the ORBD will be notified of the
 * existance of the implemenation.  Calling yoGetState() or yoSetState()
 * with a stateless object reference will result in an exception.
 */

void ORA_CORBA_BOA_set_impl(CORBA_BOA boa, CORBA_Environment *ev,
                            CORBA_InterfaceDef intf,
                            CORBA_ImplementationDef impl, yostub *stubs,
                            void *impldef, yoload loader, boolean stateless,
                            void *state);
/*
 * ORA_CORBA_BOA_set_state, get_state - set & get in-memory state
 *
 * DESCRIPTION
 * Associated with each activated object is some in-memory state.
 * These routines allow a pointer to this state to be retrieved
 * from and set into the object reference.
 */
void ORA_CORBA_BOA_set_state(CORBA_BOA boa, CORBA_Environment *ev,
                             CORBA_Object obj, void *state);
void *ORA_CORBA_BOA_get_state(CORBA_BOA boa, CORBA_Environment *ev,
                              CORBA_Object obj);
/*
 * ORA_CORBA_BOA_get_impl_state - get implementation state
 *
 * DESCRIPTION
 * This routine allows the implementation state information to be retrieved
 * from the object reference.
 */
void *ORA_CORBA_BOA_get_impl_state(CORBA_BOA boa, CORBA_Environment *ev,
                                   CORBA_Object obj);
/*
 * ORA_CORBA_BOA_service, shutdown - begin & end service
 *
 * DESCRIPTION
 * ORA_CORBA_BOA_service() begins servicing incoming implementation/object
 * requests. ORA_CORBA_BOA_service blocks until ORA_CORBA_BOA_shutdown() is
 * called.
 *
 * ORA_CORBA_BOA_shutdown() is used to terminate service started with
 * ORA_CORBA_BOA_service().  All unprocessed requests are rejected and no new
 * ones will be accepted.
 */

void ORA_CORBA_BOA_service(CORBA_BOA boa, CORBA_Environment *ev);
void ORA_CORBA_BOA_shutdown(CORBA_BOA boa, CORBA_Environment *ev);

/*
 * ORA_CORBA_BOA_free_id - free refdata
 *
 * DESCRIPTION
 * ORA_CORBA_BOA_free_id() frees the CORBA_ReferenceData storage returned by
 * CORBA_BOA_get_id().
 */

void ORA_CORBA_BOA_free_id(CORBA_BOA boa, CORBA_Environment *ev,
                           CORBA_ReferenceData *id);
EXTC_END
#endif /* YOBOA_ORACLE */

