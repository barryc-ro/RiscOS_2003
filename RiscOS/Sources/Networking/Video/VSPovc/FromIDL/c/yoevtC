/* GENERATED FILE
 * yoevt - client stubs
 * from <Obey$Dir>.yoevt/idl
 */

#ifndef YO_ORACLE
#include <yo.h>
#endif

#ifndef YOEVT_IDL
#include <yoevt.h>
#endif

EXTC_START

/* Client stubs for interface ::yoevtc */
static ysidDecl(yoevtc___id) = "IDL:yoevtc:1.0";

CONST ysid* yoevtc__getId(void)
{
  return (CONST ysid*)yoevtc___id;
}

static const yotk yoevtc__tc[] = 
  {0x00,0x00,0x00,0x0e,0x00,0x00,0x00,'%',0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,'I','D','L',':','y','o','e','v','t','c',
  ':','1','.','0',0x00,0x00,0x00,0x00,0x00,0x09,':',':','y','o'
  ,'e','v','t','c',0x00};

yotk* yoevtc__getTC(void)
{
  return (yotk*)yoevtc__tc;
}


void yoevtc__free( yoevtc* val, ysmff ffunc)
{
  yotkFreeVal( YCTC_yoevtc, (void *)val, ffunc);
}

void yoevtc__copy( yoevtc* dest, yoevtc* src, ysmaf afunc)
{
  yotkCopyVal( YCTC_yoevtc, (void *)dest, (void *)src, afunc);
}


yopar* yoevtc_cancel__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "yoevtc_cancel");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "yoevtc_cancel", (ub4)0);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_INVALID;
    _pars[0].tk = (yotk*)yoTcNull;
    _pars[0].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

void yoevtc_cancel( yoevtc or, yoenv* ev)
{
  ysevt* volatile _sem = (ysevt*)0;
  struct yoevtc__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  _impl = (struct yoevtc__tyimpl*) yoLocalObj( (CORBA_Object)or, (yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)0, (void *)_impl, yoevtc__id);
      (*(void (*)( yoevtc, yoenv*))_f)(or, ev);
    }
    else
      (*_impl->cancel)(or, ev);
  }
  else
  {
    yoFilterRunEx((void *)or, ev, YOFLTR_CSND, (const  char*)0, (void *)0);
    yseTry
    {
      _sem = ysSemCreate((void *)0);
      yoevtc_cancel_nw( or, ev, (ysevt*)_sem);
    }
    yseCatchAll
    {
      const ysid* _exid;
      void * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((void *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (void *)0);
    }
    yseFinally
      yoFilterRunEx((void *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
}

void yoevtc_cancel_nw( yoevtc or, yoenv* ev, ysevt* _sem)
{
  yoSendReq( (void *)or, ev, "cancel", TRUE, _sem, (sword)0, yoevtc_cancel_pars, (void **)0);
}


/* Client stubs for interface ::yoevt */
static ysidDecl(yoevt___id) = "IDL:yoevt:1.0";

CONST ysid* yoevt__getId(void)
{
  return (CONST ysid*)yoevt___id;
}

static const yotk yoevt__tc[] = 
  {0x00,0x00,0x00,0x0e,0x00,0x00,0x00,'$',0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0e,'I','D','L',':','y','o','e','v','t',':',
  '1','.','0',0x00,0x00,0x00,0x00,0x00,0x00,0x08,':',':','y','o'
  ,'e','v','t',0x00};

yotk* yoevt__getTC(void)
{
  return (yotk*)yoevt__tc;
}


void yoevt__free( yoevt* val, ysmff ffunc)
{
  yotkFreeVal( YCTC_yoevt, (void *)val, ffunc);
}

void yoevt__copy( yoevt* dest, yoevt* src, ysmaf afunc)
{
  yotkCopyVal( YCTC_yoevt, (void *)dest, (void *)src, afunc);
}


yopar* yoevt_trigger__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "yoevt_trigger");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "yoevt_trigger", (ub4)2);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_IN;
    _pars[0].tk = (yotk*)yoTcString;
    _pars[1].mode = YOMODE_IN;
    _pars[1].tk = (yotk*)yoTcAny;
    _pars[2].mode = YOMODE_INVALID;
    _pars[2].tk = (yotk*)yoTcNull;
    _pars[2].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

void yoevt_trigger( yoevt or, yoenv* ev, char* exid, yoany* arg)
{
  ysevt* volatile _sem = (ysevt*)0;
  struct yoevt__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  _impl = (struct yoevt__tyimpl*) yoLocalObj( (CORBA_Object)or, (yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)0, (void *)_impl, yoevt__id);
      (*(void (*)( yoevt, yoenv*, char*, yoany*))_f)(or, ev, exid, arg);
    }
    else
      (*_impl->trigger)(or, ev, exid, arg);
  }
  else
  {
    yoFilterRunEx((void *)or, ev, YOFLTR_CSND, (const  char*)0, (void *)0);
    yseTry
    {
      _sem = ysSemCreate((void *)0);
      yoevt_trigger_nw( or, ev, exid, arg, (ysevt*)_sem);
    }
    yseCatchAll
    {
      const ysid* _exid;
      void * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((void *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (void *)0);
    }
    yseFinally
      yoFilterRunEx((void *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
}

void yoevt_trigger_nw( yoevt or, yoenv* ev, char* exid, yoany* arg, ysevt* _sem)
{
  void * _parvec[2];

  _parvec[0] = (void *)&exid;
  _parvec[1] = (void *) arg;
  yoSendReq( (void *)or, ev, "trigger", TRUE, _sem, (sword)2, yoevt_trigger_pars, _parvec);
}

yopar* yoevt_setCancel__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "yoevt_setCancel");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "yoevt_setCancel", (ub4)1);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_IN;
    _pars[0].tk = (yotk*)YCTC_yoevtc;
    _pars[1].mode = YOMODE_INVALID;
    _pars[1].tk = (yotk*)yoTcNull;
    _pars[1].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

void yoevt_setCancel( yoevt or, yoenv* ev, yoevtc obj)
{
  ysevt* volatile _sem = (ysevt*)0;
  struct yoevt__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  _impl = (struct yoevt__tyimpl*) yoLocalObj( (CORBA_Object)or, (yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)1, (void *)_impl, yoevt__id);
      (*(void (*)( yoevt, yoenv*, yoevtc))_f)(or, ev, obj);
    }
    else
      (*_impl->setCancel)(or, ev, obj);
  }
  else
  {
    yoFilterRunEx((void *)or, ev, YOFLTR_CSND, (const  char*)0, (void *)0);
    yseTry
    {
      _sem = ysSemCreate((void *)0);
      yoevt_setCancel_nw( or, ev, obj, (ysevt*)_sem);
    }
    yseCatchAll
    {
      const ysid* _exid;
      void * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((void *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (void *)0);
    }
    yseFinally
      yoFilterRunEx((void *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
}

void yoevt_setCancel_nw( yoevt or, yoenv* ev, yoevtc obj, ysevt* _sem)
{
  void * _parvec[1];

  _parvec[0] = (void *)&obj;
  yoSendReq( (void *)or, ev, "setCancel", TRUE, _sem, (sword)1, yoevt_setCancel_pars, _parvec);
}



EXTC_END
