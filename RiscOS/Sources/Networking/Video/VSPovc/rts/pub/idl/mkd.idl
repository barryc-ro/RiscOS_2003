//----------------------------------------------------------------------------
// File: mkd.idl - Media Kernel Datatypes
//									     
// Description:								     
//   This file holds datatypes generic to the Media Server that may be used
//   across multiple layers or server processes.
//									     
// Modification History:						     
//   Name	Date		Comments				     
//   plord      03/18/97        Added mkd_contFormat for Logical Content
//   dweaver    12/04/96        Extend time mkd_pos flexibility
//   dpawson	11/26/96	Change definition for byte pos
//				Change name for block pos
//   dpawson	11/25/96	Return bytes in length, not KBytes
//   dpawson    09/11/96	Segments have filenames, not assetCookies
//   dpawson	06/07/96	Change name of prohibition field
//   dpawson    06/06/96        Creation
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
// Oracle Corporation							     
// Oracle Media Server (TM)						     
// All Rights Reserved
// Copyright (C) 1993-1996						     
//---------------------------------------------------------------------------

#ifndef MKD_ORACLE
#define MKD_ORACLE

//----------------------------------------------------------------------------
// Module: mkd
// Function:
//   This is the module that defines all the datatypes
//----------------------------------------------------------------------------
module mkd
{
  //--------------------------------------------------------------------------
  // Common Typedefs
  //--------------------------------------------------------------------------

  // assetCookie identifies an asset on the server.  This is a binary tag,
  // and should not be interpreted as a filename.  It is completely opaque
  // to the client, and will generally be obtained from some sort of content
  // manager
  const short assetCookieMaxlen = 128;
  typedef string assetCookie;
  typedef sequence<assetCookie> assetCookieList;

  // systemTime specified time in terms of typical unix file creation time -
  // seconds since January 1970, I think...
  typedef long systemTime;

  // segCapMask is a bitmask which specifies rate control capabilities 
  // allowed or prohibited by an entity.
  typedef unsigned long segCapMask;
  const segCapMask  segCapVideo = 0x00000001;  // i.e., is there any.
  const segCapMask  segCapVCBR  = 0x00000002;  // constant bit rate video
  const segCapMask  segCapVSeek = 0x00000004;  // can handle blind seeking
  const segCapMask  segCapVScan = 0x00000008;  // can handle frame dropping
  const segCapMask  segCapAudio = 0x00010000;
  const segCapMask  segCapACBR  = 0x00020000;  // constant bit rate audio
  const segCapMask  segCapASeek = 0x00040000;  // can handle blind seeking
  const segCapMask  segCapAScan = 0x00080000;  // can handle frame dropping(?)

  // This type is used to indicate where a piece of content is located.
  // This gives some indication how long it will take before the content
  // can be delivered to a client.
  enum contStatus
  {
    contStatusDisk,             // The content is already located on disk
    contStatusTape,             // The content is stored on tape
    contStatusFeed,             // The content is still being encoded,
                                // aka "One-Step Encoding"
    contStatusRolling,          // Is being encoded and may also be deleted
                                // aka "Continuous Realtime Feed"
    contStatusUnavailable       // Access is restricted for some reason
  };

  //----------------------------- Clip formats -------------------------------

  typedef unsigned long compFormat;
  // compFormat is the compression format of the content file.  It is a 
  // mirror of the mkcFmt* defines, and should eventually replace them.
  const compFormat  compFormatError    = 0x00000000;
  const compFormat  compFormatMpeg1    = 0x00000001;
  const compFormat  compFormatMpeg2    = 0x00000004;
  const compFormat  compFormatOrca     = 0x00000008;
  const compFormat  compFormatRawKey   = 0x00000400;
  const compFormat  compFormatSegWHdr  = 0x00002000;
  const compFormat  compFormatSegWoHdr = 0x00004000;
  const compFormat  compFormatDsmcc    = 0x00008000;

  // prohib is a bitmask detailing prohibited rate control operations
  typedef unsigned long prohib; 
  const prohib  prohibError    = 0x80000000;
  const prohib  prohibPause    = 0x00000001;
  const prohib  prohibStop     = 0x00000002;
  const prohib  prohibBlindFF  = 0x00000004;  // aka scan forward
  const prohib  prohibBlindRW  = 0x00000008;  // aka scan backward
  const prohib  prohibVisualFF = 0x00000010;
  const prohib  prohibVisualRW = 0x00000020;
  const prohib  prohibFrameAdv = 0x00000040;
  const prohib  prohibFrameRew = 0x00000080;
   
  //----------------------------- Time formats -------------------------------
  // Once a stream has been prepared and is being operated upon, the play    
  // routines expect positions to describe where a client is, where a request 
  // should begin, and where it should end.  These are commonly known as the  
  // curPos, startPos, and endPos.  These positions are expressed using the   
  // position type described below.  It may support multiple ways of        
  // expressing time, and will probably allow more options in the future.     
  //
  // Previously, it was possible to pass a NULL pointer for any of these      
  // positions to most routines.  This, however, led to confusing semantics   
  // and was not possible when new interfaces required the passing of an      
  // actual structure rather than just a pointer.  The previous semantics     
  // can still be obtained using several special variables which are globally 
  // available.  Each is a constant mkd::pos.  They are:                   
  //
  //      mkdBeginning    This is a structure which indicates that you mean    
  //                      the beginning of the stream.                         
  //      mkdEnd          This is a structure which indicates that you mean   
  //                      the end of the stream.                              
  //      mkdCurrent      This is a structure which indicates that you mean   
  //                      something like "wherever I am now."  It is always   
  //                      preferable for a caller to specify their current    
  //                      position if they can determine it.                  
  //
  // Clients who previously passed NULL pointers to mzsPrepare or mzsPlay     
  // should be able to easily conver these to &mkdCurrent, &mkdBeginning, or  
  // &mkdEnd as appropriate.                                                  
  //
  // Since CORBA, in it's infinite wisdom, doesn't allow for constant         
  // structures, mkd[Beginning|End|Current] are available in language         
  // extension files. mkd.[ch] contains the C extensions.                    
  //--------------------------------------------------------------------------

  // Although everthing here is presented in terms of "stream", in segment
  // structures the positions refer to the position in the file represented
  // by that segment.

  enum posType
  // posType describes the various formats that the server understands for
  // specifying positions within a stream or segment.
  {
    posTypeBeginning,     // beginning of stream
    posTypeCurrent,       // current position in stream
    posTypeEnd,           // end of stream
    posTypeByte,          // Bytes from start of stream, zero-based
    posTypeTime,          // Timecode from beginning of stream
    posTypeMillisecs,     // alternate from of time from beginning of stream
    posTypeMpegSCR,       // 33 bit SCR
    posTypeMpegPCR,       // 42 bit PCR
    posTypeBlock,         // Segment from start of stream, one-based
    posTypeDsmcc,
    posTypeContFeed,      // Realtime feed, specifies size of rolling buffer
    posTypeUnformed       // Specifically, a time that can't be interpreted
    /* Future types that we would like support include:
       posTypeFrames,        // frames from beginning of stream, zero-based */
  };
  
  struct posByte 
  // posByte specifies a specific byte in the content.  It is zero-based 
  // from the beginning of the stream.
  {
    long long       mkd_posByteOff;
  };

  struct posTime 
  // posTime uses the tag file to find the frame closest to the specified
  // stream time.
  {
    unsigned long  mkd_posTimeHour;
    octet          mkd_posTimeMinute;
    octet          mkd_posTimeSecond;
    octet          mkd_posTimeHundredth;
  };

  // posBlock specifies chunks within a boot image.
  typedef unsigned long posBlock; 

  typedef unsigned long posMs;  // milliseconds from beginning of stream
  typedef long long     posSCR; // least significant 33 bits only
  typedef long long     posPCR; // least significant 42 bits only

  union pos switch (posType)
  // The pos type describes a time in a stream or segment.  It can be 
  // specified in any of the time formats listed above.
  {
    // Warning: semantics have not yet been defined for the times in beginning,
    // current and end. The wisest course of action is to set them to 0:0:0.0.
    case posTypeBeginning: posTime   mkd_posBegin;    // Stream beginning
    case posTypeCurrent:   posTime   mkd_posCur;      // Stream current pos
    case posTypeEnd:       posTime   mkd_posEnd;      // End of stream
    case posTypeByte:      posByte   mkd_posBytePos;  // Specify a byte pos
    case posTypeTime:      posTime   mkd_posTimePos;  // hh:mm:ss:cc
    case posTypeMillisecs: posMs     mkd_posMsPos;    // millisecs from start
    case posTypeMpegSCR:   posSCR    mkd_posSCRPos;   // 33 bit SCR
    case posTypeMpegPCR:   posPCR    mkd_posPCRPos;   // 42 bit PCR
    case posTypeBlock:     posBlock  mkd_posBlockPos; // Block number for boot
    case posTypeDsmcc:     posBlock  mkd_posDsmcc;    // Dsmcc boot
    case posTypeContFeed:  posTime   mkd_posFeed;     // hh:mm:ss:cc
    case posTypeUnformed:  posTime   mkd_posNoWay;    // Stream beginning
  };

  // A segment mask can be used to specify particular options for a segment
  // of content.  It is currently unused, and should always be set to 0.
  typedef unsigned long segMask; 

  struct segment
  // The segment structure is used to describe a segment of a piece of 
  // content.  It is generally used when requested the delivery of such
  // a segment.
  {
    string		mkd_segFile;
    pos		        mkd_segStart;
    pos		        mkd_segEnd;
    segMask		mkd_segFlags;
    prohib		mkd_segProhib;
  };
  typedef sequence<segment> segmentList;

  struct segInfo 
  // segInfo gives the client information about a segment or stream.  This
  // may be as the result of a query, or information provided on a prepared
  // stream.  In particular, it includes rate control prohibitions imposed 
  // by the server, and gives display information (pixel size, frame rate,
  // etc.) about the clip.
  {
    segment	   mkd_segInfoSeg;	// The segment in question
    string	   mkd_segInfoType;	// The type of the file (currently
					//   this is just the file suffix)
    string         mkd_segTitle;        // Title for human consumption
    systemTime     mkd_segCreateTime;
    unsigned long  mkd_segBitrate;
    long           mkd_segPresRate;
    compFormat     mkd_segCmpFmt;
    segCapMask     mkd_segCapabilities;
    unsigned long  mkd_segMilliseconds;
    long long      mkd_segByteLength;   // Bytes in length 
    unsigned short mkd_segFrameHeight;  // pixels
    unsigned short mkd_segFrameWidth;   // pixels
    long           mkd_segAspectRatio;  // of individual pixels, p:ht*1000/p:wd
    unsigned long  mkd_segFrameRate;    // Average frames per second * 1000
    long long	   mkd_segInfoStartT;	// The starting time of the file
    long long	   mkd_segInfoEndT;	// The ending time of the file
    contStatus	   mkd_segInfoCStat;	// Where is the content currently?
    prohib         mkd_segProhibitions;
  };
  typedef sequence<segInfo> segInfoList;

  //--------------------------------------------------------------------------
  // Content Format datatypes
  // The Logical Content service represents content of the format 
  // using the following datatypes.
  //
  //--------------------------------------------------------------------------
  typedef string formatCode;

  //--------------------------------------------------------------------------
  //
  // Well known format, audio and video codec types. These map to three
  // database tables. This allows new types to be created 
  // in the database at anytime. If they are there just won't 
  // be any constant defined for it here. If the tagger needs to know about a 
  // new format type or codec type, it will need to be added here as well 
  // as the database (if applicable).
  //
  //
  // The database  tables are called CONTENT_FORMAT_TYPES,
  // CONTENT_FORMAT_VIDEO and CONTENT_FORMAT_AUDIO.
  // These tables are used to enforce known values as well as 
  // convert meaningless four character codes to readable strings.
  //
  // Note:
  //    These will be replaced with real values at some point.
  //--------------------------------------------------------------------------

  const formatCode containerUnknown  = "cunk"; // We don't know 
  const formatCode containerMpeg1SS  = "cm1s"; 
  const formatCode containerMpeg2T   = "cm2t"; 
  const formatCode containerRKF      = "crkf"; // Unspecified Raw Key 
  const formatCode containerAVI      = "cavi"; 
  const formatCode containerOSF      = "cosf"; 

  const formatCode videoNone      = "vnon"; 
  const formatCode videoUnknown   = "vunk"; 
  const formatCode videoMpeg1     = "vmp1"; 
  const formatCode videoMpeg2     = "vmp2"; 
  const formatCode videoAviCVID   = "avi1"; 
  const formatCode videoAviIV32   = "avi2"; 
  const formatCode videoAviUCOD   = "avi3"; 

  const formatCode audioNone      = "anon"; 
  const formatCode audioUnknown   = "aunk"; 
  const formatCode audioMpeg1     = "amp1"; 
  const formatCode audioMpeg2     = "amp2"; 
  const formatCode audioWavePCM   = "awv1"; 
  const formatCode audioWaveADPCM = "awv2"; 
  const formatCode audioWaveALAW  = "awv3"; 
  const formatCode audioWaveMULAW = "awv4"; 

  struct contFormat
  {
      string         creator;       // Optional
      formatCode     container;
      formatCode     video;
      formatCode     audio;

      // Client display information
      unsigned short frameHeight;	// In Pixels
      unsigned short frameWidth;	// In Pixels
      long           pelAspectRatio; // ht*10000/wd of INDIVIDUAL pixels
      unsigned long  frameRate;      // *1000, e.g. 29970 -> 29.97 fps
  };

};

#endif /* !MKD_ORACLE */
