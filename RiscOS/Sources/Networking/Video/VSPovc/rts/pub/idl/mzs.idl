//----------------------------------------------------------------------------
// File: mzs.idl - Media Zerver Streams interface
//
// Description:
//   This module defines the interface between a video client and the stream
//   service.
//
//   This interface describes how to request the initiation and subsequent
//   control of streams from the Oracle Media Server.  The interface
//   is meant to be used on a client device ("Set Top Box") or from an
//   application server.  This interface document pertains to the client side
//   ONLY.  The server side of the stream service may accept and make many
//   more calls in order to implement the functionality provided to clients.
//   The server side of the stream service is further documented in mzs0.h.
//
//    Though the interface is directed towards the MPEG-1 and MPEG-2 method
//    of encoding video, it is not restricted to it.  Some support is currently
//    provided for:
//      - MPEG2 Transport Streams
//      - MPEG1 System Streams
//      - Raw Keyframe Streams (including .avi and .wav)
//
//    Note that this interface does not provide a name service for streams, 
//    though it allows for the existence of such a service.  This
//    interface expects to be provided an 'assetCookie' which the caller 
//    obtained through some other mechanism.  If the given assetCookie is 
//    not valid for the the services requested, an error is returned.  
//    The current recommended means for obtaining such an assetCookie is 
//    from the content information server, vscontinf.  In the future, more
//    complex content management servers will be built.
//
//    This interface also does not handle the reading of the data from the
//    server, nor creating connections to the server.  That is done outside
//    of this component, and handed to it in the allocate call.  This allows
//    those network ports to be created with whatever parameters they need,
//    without imposing a synchronous or asynchonous model upon them.
//
//    Idle reclaim of dead circuits is supported by this interface.  If a
//    client has been timed out, it will receive an error on the next
//    server access.
//
//    This file does not document the binding mechanism between stream pumps
//    on the server and output ports on the server.  That binding is private
//    to each implementation of this service.
//
//    In order to use the mzs_stream interface, a client must acquire an
//    object reference from the mzs_factory interface via alloc. The boot
//    function allows a client to allocate a stream and make the first
//    block request as a single call in order to decrease latency (by cutting
//    out a client-server round trip). This stream should be freed up after
//    boot; it will contain information inappropriate for playing regular
//    video.
//
// Modification History:
//   Date	Name	Comments
//   03-Jan-97  dpawson Add raises clause to play helper functions
//   05-Nov-96  dpawson prepare must return a segInfoList
//   31-Oct-96  dpawson Don't inherit from pump any longer 
//   28-Oct-96	dpawson Document for public consumption
//   24-Sep-96	dpawson Update internals structure to be useful
//   11-Sep-96	dpawson Add support for content resolution
//   05-Sep-96  dpawson Add flag to cancel looping
//   04-Sep-96  dpawson Add flags for looping
//   07-Jul-96  dpawson Add exception for AutoDealloc
//		        Add raises statements
//   06-Jun-96  dpawson Extract common types into mkd.idl
//   28-May-96  dweaver filling in the rest of the old mzs.h
//   12-May-96  dweaver the arduous process of redefinition begins
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// Oracle Corporation							     
// Oracle Media Server (TM)						     
// All Rights Reserved
// Copyright (C) 1993-1996						     
//---------------------------------------------------------------------------

#ifndef MZS_ORACLE
#define MZS_ORACLE

/*-------------------------------- Includes ---------------------------------*/

#ifndef MKD_ORACLE
#include "mkd/idl"                          /* stream-based server datatypes */
#endif /* !MKD_ORACLE */

#ifndef MZC_IDL_ORACLE
#include "mzc/idl"                                        /* Circuit Manager */
#endif

#ifndef MZSCLI_ORACLE
#include "mzscli/idl"                      /* Client-side callback interface */
#endif

//----------------------------------------------------------------------------
// Module: mzs
// Function:
//   This is the module responsible for stream operations.
//----------------------------------------------------------------------------
module mzs 
{

  //--------------------------------------------------------------------------
  // Exceptions
  //--------------------------------------------------------------------------
    
  // This exception indicates some error happened in the communications
  // infrastructure between the client and the server.
  enum networkException
  {
    networkDown,         // Network problem establishing session
    networkSendFailure,  // Missing server component
    networkMarshal       // Error preparing to make a call
  };
  exception network { networkException networkFailType; };

  // This exception indicates a problem that occurred in the server
  // complex, and was not caused by the client.  These exceptions
  // should generally be reported to Oracle.
  enum serverException
  {
    serverBadIndex,             // Error when indexing tag file
    serverStreamIncompatible,   // Index file incompatible with code version
    serverInternal,             // Internal error - call support
    serverOutMem,               // Stream service out of memory
    serverPumpError,            // Error communicating with vspump
    serverOutOfMemory           // Stream service out of memory
  };
  exception server { serverException serverFailType; };

  // This exception is caused in response to some error in a client call.
  // The client should attempt to determine what problem in the application
  // or stored content caused the problem and remedy it.
  enum clientException
  {
    clientBadStreamID,		// Told to play a stream that doesn't exist
                                // or is invalid.
    clientInvContext,		// Invalid context passed to stream service.
    clientInvArgs,		// An argument didn't obey the proper semantics
    clientFinishBadInst,	// Inst passed to finish not valid
    clientBadPosition,		// Illegal or unsupported position structure
    clientPastStreamEnd,	// A position was given over the end of stream
    clientNoSuchMember,		// Requested compression format or bitrate
                                // didn't match stored content.
    clientNoPrepare,		// Must call prepare or prepareSequence before
                                // playing.
    clientFileNotFound,		// Missing tag file
    clientNonIndexedStream,	// Client asked for something other than a
                                // tag file.
    clientStbIncapable,		// Client requested a rate control operation
                                // that their client device doesn't support.
    clientStreamIncapable,	// Client requested a rate control operation
                                // that isn't allowed on their stream.
    clientPlayFailure,		// Error occurred during rate control.
                                // Treat this as a server error and contact
                                // Oracle.
    clientBadPrate,		// Client requested a play rate that wasn't
                                // stored on disk and couldn't be generated
                                // on the fly.
    clientNoCallbackSet,	// Client tried to remove a client callback,
                                // but hadn't previously set one.
    clientAutoDeallocDone,	// Normal termination condition during boot -
                                // a boot finished and the context was
                                // automatically deallocated.
    clientNotPlaying,		// Client tried to get current position when
                                // not playing.
    clientNotLooping		// Tried to cancel a loop when not looping.
  };
  exception client { clientException clientFailType; };

  // This exception indicates the client was denied access to a requested
  // asset.
  enum denialException
  {
    denialPrepareRefused,       // Content resolver refused access
    denialDsmccBootRefused      // DsmccBoot is refused
  };
  exception denial { denialException denialFailType; };

  //--------------------------------------------------------------------------
  // Constants
  //--------------------------------------------------------------------------

  // Client capabilities - passed to mzs::factory::alloc
  typedef unsigned long capMask;

  // Basic types of client capabilities
  const capMask  capAudio  = 0x00000001;             // Plays audio
  const capMask  capVideo  = 0x00000002;             // Plays video
  const capMask  capMultipleStreams = 0x0000004;     // > 1 video at a time
                                                     // Not supported.
  // Specific compression formats understood
  const capMask  capMpeg1  = 0x00000010;             // MPEG1 System streams
  const capMask  capMpeg2  = 0x00000020;             // MPEG2 Transport streams
  const capMask  capJpeg   = 0x00000040;             // JPEG stills
  const capMask  capOrca   = 0x00000080;             // Orca (unsupported)
  const capMask  capRawKey = 0x00000100;             // At least one raw key
                                                     // format (AVI, WAV, etc.)
  // VCR operations that can be dealt with
  const capMask  capSeek   = 0x00001000;             // Blind seek
  const capMask  capScan   = 0x00002000;             // Visual scan
  const capMask  capPause  = 0x00004000;             // Pause a stream
  const capMask  capFrame  = 0x00008000;             // Frame step
  const capMask  capSkip   = 0x00100000;             // Visual ff/rw via
                                                     // frame drops
  // Unusual capabilities. Consult Oracle before using.
  const capMask  capBoot   = 0x00040000;  // used internally to aid STB boot
  const capMask  capBootDSMCC = 0x00080000;  // used internally to aid STB boot

  // A type for a MediaNet address.  Used internally.
  typedef sequence<octet> mnAddr; 

  // Stream state.  Derived from DSM-CC stream states.  This is exposed
  // to monitoring tools on a per stream basis.
  // Our server is never in states ST or STP, although we might be with HSM  
  enum state        // Letters are corresponding DSM-CC state
  {
    // Typically our state progression moves along the track of:
    // stateDead, but no object reference so you couldn't find that out anyway
    // mzs::factory::alloc           ->   stateIdle
    // mzs::stream::prepareSequence  ->   statePrepared
    //           w/ playNow flag set ->   stateMoreClips or Stream or Finished
    //   note: Stream indicates the last segment is being played, MoreClips
    //         means there are additional segments yet to be played;
    //         after all video has been sent, state changes to stateFinished
    // mzs::stream::pause            ->   statePaused
    // mzs::stream::play             ->   stateMoreClips or Stream or Finished
    // mzs::stream::finish           ->   stateIdle (NOT stateFinished)
    // stateDead may be returned after an internal server error.
    // stateBoot is always reported for any stream that has been used to boot.
    // stateClip is not currently used, since we don't have a "pause at time"
    // style play function.
    stateDead,      // U
    stateBoot,      // Also U, for lack of a better approximation
    stateStream,    // T, will pause at end of stream (entering EOS)
    stateClip,      // TP, will pause at endPos specified (entering P)
    stateMoreClips, // PST, playing with multiple segments pending
    stateIdle,      // O, no segments pending
    statePause,     // P, play rate of zero, one segment pending
    stateFinished,  // EOS, same as pause, except initiated by server
    statePrepared   // best represented as P
  };

  // Server-wide statistics.  Exposed to monitoring facilities through the
  // mzs::factory::getStats call.
  struct stats
  {
    unsigned long  mzs_statsAllocs;     // Allocated streams
    unsigned long  mzs_statsPlays;      // Play calls processed
    unsigned long  mzs_statsRepos;      // Stream repositions.
    unsigned long  mzs_statsCompletes;  // Completed streams.
    unsigned long  mzs_statsQueries;    // Not used.
  };

  // Stream-specific statistics.  Exposed to monitoring facilities through
  // the mzs::stream::query call.
  struct internals
  {
    state		mzs_intActivity;        // Current state.
    capMask		mzs_intCaps;            // Capabilities.
    unsigned long	mzs_intMaxBitrate;      // Maximum bitrate.
    unsigned long	mzs_intLastBitrate;     // Last requested bitrate.
    unsigned long	mzs_intCurrentBitrate;  // The current bitrate 
						// requested of the video 
						// pump.  Note that when
						// playing a sequence with 
						// varying bitrates, this is
						// not necessarily the bitrate
						// currently being delivered 
						// by the video pump.
    long		mzs_intPlayRate;        // Current presentation rate.
    mkd::segmentList	mzs_intCurSegs;         // Current prepared segments.
  };


  // Flags passed to mzs::factory::boot and mzs::stream::bootMore.
  typedef unsigned long bootMask;
  
  const bootMask  bootAutoClose  = 0x00000001;  // Dealloc when the boot
                                                // completes.

  //--------------------------------------------------------------------------
  // Interface: stream
  // Function:
  //   This is the heart of the stream interface.  Once an individual stream
  //   has been obtained from the factory interface, this interface allows a
  //   client to perform VCR operations on it.
  //--------------------------------------------------------------------------
  interface stream
  {
    // An 'instance' is an opaque type returned by the prepare calls to be
    // passed back in to later calls.  Eventually, the stream service might
    // allow a client to have multiple, simultaneously prepared instances
    // to pass interchangeably to calls like mzs::stream::play.  Today, if
    // a client prepares an instance when one is already prepared, the first
    // becomes unusable.
    typedef unsigned long  instance; // A descriptor for the prepared stream
    
    // These are flags passed to mzs::stream::prepare and
    // mzs::stream::prepareSequence.
    // playWait - The default.  The stream service will prepare the
    //   requested assets and then wait for further commands.
    // playNow - Causes the stream service to play the clip as soon as
    //   the prepare completes.  Clients that are going to immediately
    //   follow a prepare with a play are urged to use this flag to reduce
    //   latency.
    // playLoop - Asks the stream service to prepare to loop the entire
    //   submitted play request until told to stop.
    // playLoopLast - Asks the stream service to loop the last segment
    //   in a submitted sequence.
    // playNext - Not defined or implemented.
    //
    // Note that it is illegal to pass both playWait and playNow.
    // It is also illegal to pass playLoop and playLoopLast, or to send
    // playLoopLast when only submitting one segment.
      
    typedef unsigned long playFlags; // series of MzsPlayFoo defines
    const playFlags  playWait		= 0x00000001;
    const playFlags  playNow		= 0x00000002;
    const playFlags  playNext		= 0x00000004;
    const playFlags  playLoop		= 0x00000008;
    const playFlags  playLoopLast	= 0x00000010;

    //------------------------------------------------------------------------
    // Name: mzs::stream::prepare
    // Function:
    //   Prepare a stream for delivery.  This call should return
    //   immediately from the server with an estimate for the user
    //   of when the stream will be ready.  (i.e. it may have to
    //   be loaded off of slow media, or the server may be buffering
    //   a couple seconds, and thus needs a couple seconds before starting).
    //   The goal here is to instantly get a countdown timer on the user's
    //   screen, so they don't perceive server communication as slow.
    //   In addition, this call will return a stream instance, which must
    //   be used during all other calls to the stream server.  The stream
    //   instance identifies for the server the prepared assets.
    //
    //   "playFlags" control when and how the stream should be played.
    //   The possible flags are described above.
    //
    //   Note that this function takes an mkd::segInfo structure.
    //   The structure will be filled in with information about
    //   the prepared stream.  This is useful for reducing latency in
    //   applications that might prepare a movie, then query it to find
    //   its length, for instance.
    // Input:
    //   cookie         The asset the client is requesting for preparation.
    //                  This is obtained from some other entity, such as
    //                  vscontinf.
    //   start          The position to start playing at if the playNow flag
    //                  is passed.  Without this flag, the parameter is
    //                  ignored by the server.
    //   end            The position to end playing at if the playNow flag
    //                  is passed.  Without this flag, the parameter is
    //                  ignored by the server.
    //   bitrate        The bitrate the client expects to initially play
    //                  the content at.  A value of '0' means to play at
    //                  whatever rate the content was encoded at.  If playNow
    //                  is passed, this bitrate will be used for that play.
    //   flags          Options for how the content should be prepared.
    //                  These are described above.
    //   status         A sequence structure to be filled in.
    //   authRef        An object reference to be used for authentication.
    //                  The source of the assetCookie should dictate what
    //                  object reference to pass here.  For example, when
    //                  passing assetCookies from vscontinf, no authorization
    //                  object is required.
    // Output:
    //   status         A sequence of segment information structures.  This
    //                  tells the client what physical content was actually
    //                  prepared.  Note that there isn't necessarily one
    //                  such structure, since one assetCookie can resolve to
    //                  multiple pieces of physical content.
    // Returns:
    //   An instance to be passed to further calls such as mzs::stream::play
    //   and mzs::stream::finish.
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //   denial         The denial exception indicates why the request was
    //                  denied.
    //------------------------------------------------------------------------
    instance prepare(in  mkd::assetCookie cookie,
		     in  mkd::pos	  start,
		     in  mkd::pos	  end,
		     in  unsigned long    bitrate,
		     in  playFlags        flags,
		     out mkd::segInfoList status,
		     in  Object           authRef)
	raises(client, server, denial);

    //------------------------------------------------------------------------
    // Name: mzs::stream::prepareSequence
    // Function:
    //   Prepare one or more assetCookies for delivery.  This call should
    //   return immediately from the server with an estimate for the user
    //   of when the assetCookies will be ready.  (i.e. it may have to
    //   be loaded off of slow media, or the server may be buffering
    //   a couple seconds, and thus needs a couple seconds before starting).
    //   The goal here is to instantly get a countdown timer on the user's
    //   screen, so they don't perceive server communication as slow.
    //   In addition, this call will return a stream instance, which must
    //   be used during all other calls to the stream server.  The stream
    //   instance identifies for the server the prepared assets.
    //
    //   Multiple assets prepared via one call to this function are
    //   treated as one piece of logical content.  They will be streamed
    //   frame contiguous with as little latency as possible between
    //   segments.  When repositioning, the client is expected to give
    //   positions in the sequence as a whole, as if it were one piece
    //   of physical content.  On transports that support it, indicators
    //   will be sent at segment transitions to help a client application
    //   track progress through the sequence.
    //
    //   "playFlags" control when and how the stream should be played.
    //   The possible flags are described above.
    //
    //   Note that this function now takes a sequence of mkd::segInfo
    //   structures to fill in.  The structures will be filled in with
    //   information about the prepared assets.  This is useful for reducing
    //   latency in applications that might prepare a movie, then query it
    //   to find its length, for instance.
    // Input:
    //   cookies        A sequence of assets the client is requesting for
    //                  preparation.  These are obtained from some other
    //                  entity, such as vscontinf.
    //   clipStatus     A sequence to be filled in with information about
    //                  the prepared assets.
    //   start          The position to start playing at if the playNow flag
    //                  is passed.  Without this flag, the parameter is
    //                  ignored by the server.
    //   end            The position to end playing at if the playNow flag
    //                  is passed.  Without this flag, the parameter is
    //                  ignored by the server.
    //   bitrate        The bitrate the client expects to initially play
    //                  the content at.  A value of '0' means to play at
    //                  whatever rate the content was encoded at.  If playNow
    //                  is passed, this bitrate will be used for that play.
    //   playRate       The presentation rate the client expects to initially
    //                  play the content at.  If playNow is passed, this is
    //                  is the presentation rate at which the content will
    //                  be played.
    //   flags          Options for how the content should be prepared.
    //                  These are described above.
    //   prohibitions   Not currently supported.  Will eventually allow the
    //                  prohibition of rate control operations on the
    //                  prepared sequence.
    //   authRef        An object reference to be used for authentication.
    //                  The source of the assetCookie should dictate what
    //                  object reference to pass here.  For example, when
    //                  passing assetCookies from vscontinf, no authorization
    //                  object is required.
    // Output:
    //   clipStatus     A sequence of segment information structures.  This
    //                  tells the client what physical content was actually
    //                  prepared.  Note that there isn't necessarily one
    //                  such structure for each passed assetCookie, since
    //                  one assetCookie can resolve to multiple pieces of
    //                  physical content.
    // Returns:
    //   An instance to be passed to further calls such as mzs::stream::play
    //   and mzs::stream::finish.
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //   denial         The denial exception indicates why the request was
    //                  denied.
    //------------------------------------------------------------------------
    instance prepareSequence(in  mkd::assetCookieList  cookies,
			     out mkd::segInfoList  clipStatus,
			     in  mkd::pos          startPos,
			     in  mkd::pos          endPos,
			     in  unsigned long     bitrate,
			     in  long              playRate,
			     in  playFlags         flags,
			     in  mkd::prohib       prohibitions,
			     in  Object            authRef)
			raises(client, server, denial);

    //------------------------------------------------------------------------
    // Name: mzs::stream::play
    // Function:
    //   This call is the heart of the stream service.  All
    //   calls to deliver stream data use this call.  It provides for play,
    //   ff, rewind, frame advance and rewind, and changing of the current
    //   bitrate.
    //
    //   The call is passed a "curPos", "startPos", and "endPos".  Each of
    //   these can be a time specified via the mkd::pos structure described
    //   in mkd.idl, or the special mkd::pos structures described in mkdc.h
    //   (such as mkdBeginning, mkdCurrent, and mkdEnd).
    //
    //   curPos is a hint to the server of where the client is currently
    //   located.  It may be passed to an application service for information
    //   gathering, or used to enforce rate control limitations with regard
    //   to seeking.  A box that can gather this information and always send
    //   an accurate curPos will be more full-featured than one that cannot.
    //
    //   startPos, as it sounds, indicates the position that a request should
    //   begin at.  It has no meaning when pausing.
    //
    //   endPos, as it sounds, indicates the position at which a request should
    //   stop playing.  It also has no meaning when pausing.
    //
    //   When paused, a client may take advantage of some special semantics.
    //   If a paused client passes &mkdCurrent for the start position, it
    //   requests that the server start playing as close as possible to where
    //   it was delivering data when the pause arrived.  If the client sends
    //   &mkdCurrent for the startPos when not paused, the results are
    //   undefined.
    //
    //   Note that at no time may a client pass a NULL pointer for any of
    //   these positions.
    //
    //   The bitrate is a guideline for the server.  It will try to play you
    //   the requested stream at a bitrate less than or equal to the requested
    //   rate.  If it has no copy of the movie that qualifies, it will return
    //   an error.
    //
    // Input:
    //   inst           An instance returned from either mzs::stream::prepare
    //                  or mzs::stream::prepareSequence.
    //   curPos         A positioning hint.  If possible on a client, it
    //                  should always indicate where the client was when the
    //                  command was submitted.
    //   startPos       Where to begin playing.
    //   endPos         Where to stop playing.
    //   playRate       The presentation rate to play at.  This is described
    //                  in great detail below.
    //   bitrate        The bitrate to deliver the content.  The server will
    //                  never deliver content at a bitrate higher than this
    //                  passed value, but it may choose a lower value.
    // Output:
    //   None
    // Returns:
    //   Nothing
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //------------------------------------------------------------------------
    //
    //   Rate control, direction control, etc:
    //
    //   Multi-Stream Rate Control
    //
    //   There are two types of rate control supported by this server.  The
    //   first, multi-stream rate control is a situation where there are
    //   separate compressed files (ie. MPEG files) on the server for
    //   each presentation rate the client can attempt.  For example, if 1x,
    //   2x, and 4x files exist on the server the cleint may switch between
    //   these at will but if the client asks for a rate for which there is
    //   no corresponding compressed file the server will return an error.
    //   NOTE: Multi-stream rate control is currently disabled in the server
    //      due to lack of customer interest.  If required, this feature will
    //      be re-enabled in a future version.
    //
    //   Single-Stream Rate Control
    //
    //   In general, in the fast forward or fast rewind modes, the
    //   server should ship the frames that it HAS to ship to do the
    //   specified speedup, and also ship whatever data it can that
    //   follows those to keep up the correct bitrate.  It is up to the 
    //   client to deal with missing frames.  
    //
    //   For rewind, it is transparent to the client how it is being handled.
    //   There are two modes the server may enter: The first is the obvious
    //   frame skipping rewind, where the server sends whichever frames it can
    //   in the reverse direction.  The second would be to use multi-stream
    //   rate control, since in some compression formats (such as MPEG) going
    //   backwards is more difficult than going forwards.
    //
    //   This is all handled in the server.
    //
    //   NOTE: Frame advance is not supported at this time.
    //
    //   Frame advance and rewind are also handled by this call.
    //   Since either time or frame position can be given to the call,
    //   the client can navigate to their desired point in the stream
    //   by whichever method they want. At that point,
    //   to do frame advance or rewind, the client specifies a timefactor
    //   of 1 or -1.
    //   Each call to this routine will play one frame of the given piece if
    //   timefactor is 1 or -1.  For frame advance, the semantics are obvious.
    //   For frame rewind with a reverse-encoded stream available
    //   they are as well.
    //   However, for a frame rewind with only a forward stream,
    //   the server may not be able to send all frames. Thus, though a frame
    //   advance will go 1/30th (NTSC) of a second forward,
    //   a frame rewind may go more than 1/30th of a second backwards.
    //   An example of this occurs in MPEG, where frames are "forward diffed"
    //   and it is therefore impossible to present frames in reverse order and
    //   have a decoder present the frames.
    //
    //   During all modes of play, if the server reaches endpos,
    //   it will stop sending data and go into a paused state.  The
    //   server will return an error if a reverse play command is given and
    //   the endpos is greater than the startpos.
    //
    //   playRate specifies how fast the stream should be played,
    //   and in which direction.  A value of 1000 means play forward
    //   at normal speed, -1000 means play reverse at normal speed.
    //   More examples are given below.
    //
    //   This example uses MPEG with 30 FPS, NTSC, and 3 I-Frames per second.
    //
    //   For illustration, note that this will most likely be coded as
    //
    //   Time---> 1 second
    //
    //      1 2 3  4 5 6 7 8 9 0 1 2 3  4 5 6 7 8 9 0 1 2 3  4 5 6 7 8 9 0
    //      B B I1 P B B P B B P B B I2 P B B P B B P B B I3 P B B P B B P
    //
    //   timefactor  effect
    //   ----------  --------------------------------------------------------
    //
    //        ....................FASTER THAN REALTIME....................
    //
    //      10000  10x speed:  Display 30 iframes per second. This
    //             rate is notable because it must be handled differently
    //             than slower FF speeds, and will require more intelligence:
    //             Since iframes are bigger than b/p frames, we clearly can't
    //             serve 30 iframes/sec down the same pipe we were only
    //             able to serve 30 mixed i/p/b frames per second down).
    //             This illustrates a complicated optimization, which is
    //             to start skipping even iframes when doing quick ff or
    //             rewind.
    //
    //       5000  5x speed: Display 15 iframes per second.  Double each
    //             iframe at the client side to maintain 30fps rate,
    //             i.e. only transmit 15fps over the wire. Alternatively,
    //             display the first P after each I (if it fits in the same
    //             packet as the I).
    //
    //       3000  3x: Display 9 iframes per second.  You might even get
    //             away with transmitting the next PBB sequence with the
    //             iframe (you display it as BBP, of course), thus providing
    //             a smoother FF.
    //
    //       2000  2x: Display 6 iframes + 6 PBB sets/ second.
    //             Thus, the rate to the user is a slightly jumpy 6+6*3 = 24
    //             frames per second.  We just skip the last six PBB frames
    //             in each 1/3 second. (See picture above for clarification)
    //
    //        ..........................REALTIME..........................
    //
    //       1000  realtime - normal replay rate
    //
    //        ......................SLOWER THAN REALTIME..................
    //
    //        500  Play 15 of the original frames per second - run at 1/2 speed
    //
    //         33  Play 1 of the original frames per second - run at 1/30th
    //             speed
    //
    //          1  Play 1 frame forward
    //
    //          0  Pause the stream.
    //             For this and other operations, the "curpos" parameter
    //             can be Used as a hint to the server to position the stream
    //             at this point (buffer it up, etc).  But no
    //             data is actually sent. 
    //
    //        ........................REVERSE............................
    //
    //         -1  Play 1 frame in reverse (previous i-frame if necessary)
    //
    //       -500  Play at 1/2 normal speed in reverse.
    //
    //      -1000  Play at normal speed in reverse.  For most set top boxes,
    //             this will probably mean displaying only iframes (3 per
    //             second in this example), unless a reverse stream is encoded.
    //
    //      etc...
    //
    //------------------------------------------------------------------------
    //
    // NOTE: Again, please note that multi-stream rate control is currently
    //   disable due to lack of customer interest.
    //
    // Semantics of Single- and Multi-stream rate control combined
    //
    // The semantics of the server for a client capable single-stream rate
    // control are as follows:
    //   - for a specified presentation rate x, if there exists a compressed
    //     file (aka member) for that rate, that matches all the other
    //     constraints of the client, it will be chosen
    //   - if there does not exist a member at the correct presentation rate,
    //     the server will perform single-stream rate control 
    //------------------------------------------------------------------------

    // These constants describe commonly used presentation rates.
    const long rate1x           = 1000;
    const long ratePause        =    0;

    void play(in  instance  inst,
	      in  mkd::pos  curPos,
	      in  mkd::pos  startPos,
	      in  mkd::pos  endPos,
	      in  long      playRate,   
	      in  unsigned long bitrate)
    	raises(client, server);

    //-----------------------------------------------------------------------
    // These helper methods cover common uses of mzs::stream::play, and make
    // it easier to call.
    //-----------------------------------------------------------------------

    //-----------------------------------------------------------------------
    // Name: mzs::stream::pause
    // Function:
    //   Pause a playing stream at the current position.
    // Input:
    //   inst           An instance returned from either mzs::stream::prepare
    //                  or mzs::stream::prepareSequence.
    //   curPos         A positioning hint.  If possible on a client, it
    //                  should always indicate where the client was when the
    //                  command was submitted.
    // Output:
    //   None
    // Returns:
    //   Nothing
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //------------------------------------------------------------------------
    void pause(in  instance  inst,
	       in  mkd::pos  curPos)
	 raises(client, server);
    //-----------------------------------------------------------------------
    // Name: mzs::stream::playFwd
    // Function:
    //   Play a stream at normal speed.  This can be used to "unpause" a
    //   paused stream or begin playing for the first time.
    // Input:
    //   inst           An instance returned from either mzs::stream::prepare
    //                  or mzs::stream::prepareSequence.
    //   startPos       Where to begin playing.
    //   endPos         Where to stop playing.
    // Output:
    //   None
    // Returns:
    //   Nothing
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //------------------------------------------------------------------------
    void playFwd(in  instance  inst,
		 in  mkd::pos  startPos,
		 in  mkd::pos  endPos)
       	 raises(client, server);
    //-----------------------------------------------------------------------
    // Name: mzs::stream::playRev
    // Function:
    //   Play a stream in reverse at normal speed.  This can be used to
    //   "unpause" a paused stream, or to play initially presuming that
    //   logical start and end positions are passed in.
    // Input:
    //   inst           An instance returned from either mzs::stream::prepare
    //                  or mzs::stream::prepareSequence.
    //   startPos       Where to begin playing.
    //   endPos         Where to stop playing.
    // Output:
    //   None
    // Returns:
    //   Nothing
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //------------------------------------------------------------------------

    void playRev(in  instance  inst,
		 in  mkd::pos  startPos,
		 in  mkd::pos  endPos)
         raises(client, server);

    //-----------------------------------------------------------------------
    // Name: mzs::stream::frameFwd
    // Function:
    //   Frame advance a stream one frame forward.
    //   NOTE: This function is not currently supported.  The semantics of
    //   the function will be clarified when implemented.
    // Input:
    //   inst           An instance returned from either mzs::stream::prepare
    //                  or mzs::stream::prepareSequence.
    //   curPos         A positioning hint.  If possible on a client, it
    //                  should always indicate where the client was when the
    //                  command was submitted.
    // Output:
    //   None
    // Returns:
    //   Nothing
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //------------------------------------------------------------------------
    void frameFwd(in  instance  inst,
		  in  mkd::pos  curPos)
         raises(client, server);

    //-----------------------------------------------------------------------
    // Name: mzs::stream::frameRev
    // Function:
    //   Frame advance a stream one frame backward.
    //   NOTE: This function is not currently supported.  The semantics of
    //   the function will be clarified when implemented.
    // Input:
    //   inst           An instance returned from either mzs::stream::prepare
    //                  or mzs::stream::prepareSequence.
    //   curPos         A positioning hint.  If possible on a client, it
    //                  should always indicate where the client was when the
    //                  command was submitted.
    // Output:
    //   None
    // Returns:
    //   Nothing
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //------------------------------------------------------------------------
    void frameRev(in  instance  inst,
		  in  mkd::pos  curPos)
         raises(client, server);

    //-----------------------------------------------------------------------
    // Name: mzs::stream::finish
    // Function:
    //   This call indicates that the client is no longer interested in the
    //   passed inst.  If it is currently playing, it is stopped immediately.
    //   Further pieces of content can then be prepared, but this call
    //   should be viewed as an "un-prepare", and it is not allowable to
    //   try to play content that has been finished with this call.
    //   An additional function of this function is to cancel an exisiting 
    //   loop.  If a stream was prepared with looping requested, and finish
    //   is called with the finishLoop flag, the loop will be cancelled.  If
    //   the stream is currently looping, it will stop at the end of the 
    //   current iteration.
    //
    // Input:
    //   inst           An instance returned from either mzs::stream::prepare
    //                  or mzs::stream::prepareSequence.
    //   flags          Flags modifying the request.  Possible flags are
    //                  described below.  The default value is finishAll.
    // Output:
    //   None
    // Returns:
    //   Nothing
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //------------------------------------------------------------------------

    // Values for the flags parameter to finish.
    typedef unsigned long finishFlags;

    // Note that since we currently do not support multiple outstanding
    // prepared inst's, finishOne and finishAll are effectively equal.
    const finishFlags  finishOne	= 0x00000001;   // Finish the current
                                                        // prepare.
    const finishFlags  finishAll	= 0x00000002;   // Finish all prepares
                                                        // for this context.
    const finishFlags  finishLoop	= 0x00000004;   // Cancel an existing
                                                        // loop.

    void finish(in  instance    inst,
		in  finishFlags flags)
	raises(client, server);

    //-----------------------------------------------------------------------
    // Name: mzs::stream::bootMore
    // Function:
    //   Continue a boot that was begun with the mzs::factory::boot call.
    //   It is passed positions that indicate the piece of the boot that is
    //   to be sent next.  In an Oracle boot protocol boot, this is just a
    //   block number.  In a DSM-CC boot, this might be something more complex
    //   like a module and block number.  It sends this to the client.
    // Input:
    //   startPos               The starting position for the boot request
    //   endPos                 The end position for the boot request
    //   flags                  Flags modifying the boot request
    // Output:
    // Returns:
    //   Nothing
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //   denial         The denial exception indicates why the boot was
    //                  denied.
    //------------------------------------------------------------------------
    void bootMore(in  mkd::pos startPos,     
		  in  mkd::pos endPos,       
		  in  bootMask flags)
	raises(client, server, denial);

    //-----------------------------------------------------------------------
    // Name: mzs::stream::bootCancel
    // Function:
    //   If something goes wrong in the middle of a mzs::stream::bootMore call
    //   the server throws exceptions to the upstream. The upstream is then
    //   responsible for catching these exceptions and calling 
    //   mzs::stream::bootCancel so that cancel error info is propagated to
    //   the setop box.
    // Input:
    //   startPos               The starting position for the boot cancel
    //   endPos                 The end position for the boot cancel
    //   cancel_err             The dsmcc error that the server is going to
    //                          return to the setop-box
    // Output:
    // Returns:
    //   Nothing
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //   denial         The denial exception indicates why the boot was
    //                  denied.
    //------------------------------------------------------------------------
    void bootCancel(in  mkd::pos  startPos,
                    in  mkd::pos  endPos, 
                    in  unsigned short  cancel_err)
	raises(client, server, denial);

    //-----------------------------------------------------------------------
    // Name: mzs::stream::setCallback [INTERNAL use only]
    // Function: 
    //   This function is intended to set a callback function to be notified
    //   when a stream is terminated.  When a stream ends, this function will
    //  be called to indicate that the stream has ended, with a flag to
    //   indicate why.
    // Input:
    //    orCli    The hidden object reference that is used for the callback
    //             from the server to the client
    // Output:
    //   None
    // Returns:
    //   mzs_clientCB The old hidden object reference that was used in a 
    //                previous cli_stream_SetCallback call from the client.
    // Raises:
    //   Nothing
    //------------------------------------------------------------------------
    mzs_clientCB setCallback (in mzs_clientCB orCli);

    //-----------------------------------------------------------------------
    // Name: mzs::stream::removeCallback [INTERNAL use only]
    // Function: 
    //   This function is intended to remove a previous installed callback 
    //   function 
    // Input:
    //   None
    // Output:
    //   None
    // Returns:
    //   mzs_clientCB The hidden object reference that was used in the 
    //                last cli_stream_SetCallback call from the client.
    // Raises:
    //   Nothing
    //------------------------------------------------------------------------
    mzs_clientCB  removeCallback();

    //-----------------------------------------------------------------------
    // Name: mzs::stream::query
    // Function:
    //   This function can be called by monitoring utilities to get
    //   diagnostic information on a per context basis.  The context
    //   must presumably be obtained via some other mechanism, such
    //   as querying from the connection service.  A client can also
    //   call this function on its own context if so inclined.
    // Input:
    //   sessionState   Structure to fill in with statistics
    // Output:
    //   sessionState   Structure holds diagnostic information        
    // Returns:
    //   Nothing
    // Raises:
    //   Nothing
    //------------------------------------------------------------------------
    void query(out internals  sessionState);

    //-----------------------------------------------------------------------
    // Name: mzs::stream::getPos
    // Function:
    //   Get the current position of a playing stream.  Note that only the
    //   client device can know the true position of a playing stream due
    //   to network latencies; this function can only return the position
    //   last delivered by the video pump.  This also implies race conditions.
    //   A query on a playing stream may indicate the stream has stopped when
    //   video is still being displayed to the client.  Latencies in this
    //   call are entirely dependent on the network configuration.
    // Input:
    //   inst           An instance returned from either mzs::stream::prepare
    //                  or mzs::stream::prepareSequence.
    //   status         Space to store the current state.
    //   playRate       Space to store the current presentation rate.
    // Output:
    //   status         Will eventually indicate the current state of the
    //                  stream.  This parameter is currently unsupported.
    //   playRate       Holds the current presentation rate of the stream.
    // Returns:
    //   The current position of the stream.  Note that if the client is
    //   playing a sequence of more than one segment, this time is in the
    //   sequence as a whole.
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //------------------------------------------------------------------------
    mkd::pos getPos(in instance inst, out state status, out long playRate)
	raises(client, server);

    //-----------------------------------------------------------------------
    // Name: mzs::stream::dealloc
    // Function:
    //   Deallocate a stream obtained via mzs::factory::alloc or
    //   mzs::factory::boot, indicating that it is no longer needed.
    //   Once this call has been made, the stream object is no longer
    //   valid and cannot be passed back to the stream service.
    // Input:
    //   None
    // Output:
    //   None
    // Returns:
    //   Nothing
    // Raises:
    //   Nothing
    //------------------------------------------------------------------------
    void dealloc(); 
      
  };

  // Since MediaNet doesn't have an IDL type for physical addresses,
  // mzs defined this type.
  typedef sequence <octet> physAddr;

  //--------------------------------------------------------------------------
  // Interface: factory
  // Function:
  //   The mzs factory generates stream objects for the mzs::stream functions.
  //   With the exception of the getStats call, all of the factory functions
  //   are allocators, which reserve resources in the stream service to service
  //   a client.
  //
  //   This is not a "login" call.  All information pertaining to login
  //   such as authentication, identification, etc., is presumed to have
  //   already been performed.
  //
  //   These calls allocate resources on the server.  They only need to
  //   be made once, i.e. many streams can be played without deallocating and
  //   reallocating.  For boxes which can support multiple simultaneous
  //   streams, these calls would be made once per simultaneous stream
  //   and the bitrates would be presumed to not add up to over the
  //   bitrate of the line into the settop. Note that it is the boxes'
  //   responsibility to supply a bit rate that it knows the network
  //   can support.  When the object is no longer required, the client
  //   should use mzs::stream::dealloc to free up the resource.
  //
  //   The server has the ability to call authentication & identification
  //   routines to determine if this box has the ability to serve streams
  //   of a passed bitrate, or at all. (i.e. if the network is busy,
  //   priority-based stream allocation may be going on).
  //
  //--------------------------------------------------------------------------
  interface factory
  {
    //-----------------------------------------------------------------------
    // Name: mzs::factory::alloc
    // Function:
    //   Allocate a stream object to be used in calls to the mzs::stream
    //   interface.
    //   When allocating a stream context, the client passes a simple
    //   capability mask to the server.  This acts as a guideline for
    //   what operations the stream service should perform on behalf
    //   of that client.
    //   In networks where bandwidth is allocated rather than hardcoded, this
    //   call may also cause the server to ask the network for bandwidth, if
    //   that has not already been done..
    // Input:
    //   clientCircuit  A circuit to the client.  This is obtained from some
    //                  external source, probably session setup.
    //   capabilities   A capability mask describing the abilities of the
    //                  client device.
    //   maxBitrate     The maximum bitrate at which the stream service should
    //                  ever try to deliver a stream to the client device.
    // Output:
    //   None
    // Returns:
    //   A stream object to be passed to the calls in the mzs::stream
    //   interface.
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //------------------------------------------------------------------------
    stream alloc(in mzc::circuit clientCircuit,
		 in capMask        capabilities,
		 in unsigned long  maxBitrate)
      raises(client, server);

    //-----------------------------------------------------------------------
    // Name: mzs::factory::boot
    // Function:
    //   This function is used to initiate a boot with the stream service,
    //   using either the Oracle Boot Protocol or the DSM-CC download
    //   protocol.
    //   The call is designed to reduce round trips from the server.  It
    //   encapsulates the functionality of the mzs::factory::alloc call with
    //   an initial call to the mzs::stream::bootMore call.  In this way,
    //   the client begins a boot, and gets back a stream context which holds
    //   the state required to complete the boot.
    //   The client can either continue the boot to completion and then
    //   manually free the context using mzs::stream::dealloc, or can pass
    //   the bootAutoClose flag to each boot and bootMore call to indicate
    //   that the stream service should automatically deallocate the context
    //   when the boot either finishes or fails.
    //   In general, a client cannot make this call (most clients do not
    //   have MediaNet local, and couldn't make an ORB call to boot themself.
    //   Instead, clients communicate with an upstream manager via some sort
    //   of low-level signalling such as DSM-CC download messages, and the
    //   upstream manager calls the stream service to boot.
    // Input:
    //   clientCircuit  A circuit to the client.  This is obtained from some
    //                  external source, probably session setup.
    //   startPos       A start position to be used for the first boot
    //                  request.
    //   endPos         The end position to use for the first boot request.
    //   flags          Flags to modify the boot, defined above.  This
    //                  includes the bootAutoClose flag.
    //   req_blocksz    The block size the client would like to use.  The
    //                  stream service reserves the right to deny the
    //                  request if it cannot grant this request.
    // Output:
    //   RespInfoP      The server returns RespInfo to the upstream server
    //                  (block size that the boot file was wrapped in).
    // Returns:
    //   A stream object for use to calls to mzs::stream::bootMore.  Note
    //   that this context is not suitable for calls to most other stream
    //   functions, such as mzs::stream::prepare and mzs::stream::play.
    // Raises:
    //   client         The client exception indicates what exactly was wrong.
    //   server         The server exception indicates what server problem to
    //                  report to Oracle.
    //   denial         The denial exception indicates why the boot was
    //                  denied.
    //------------------------------------------------------------------------
    struct  bootRespInfo
    {
       unsigned short  mzsbootBlock_sz;
    };

    stream boot(in  mzc::circuit clientCircuit,
		in  mkd::pos startPos,     // in block numbers, one hopes
		in  mkd::pos endPos,
		in  bootMask flags,
                in  unsigned short  req_blocksz,
                out bootRespInfo  RespInfoP)
	raises(client, server, denial);

    //-----------------------------------------------------------------------
    // Name: mzs::factory::getStats
    // Function:
    //   Query statistics about a stream service.  This is different than
    //   the query function described above, in that it is returning process
    //   wide statistics, not statistics on a particular stream object.  It
    //   is intended to be called by monitoring facilities, but could be
    //   called by any entity looking for this information.
    // Input:
    //   statistics     Space to store the process-wide statistics
    // Output:
    //   statistics     Filled in with stats on the called stream service
    // Returns:
    //   Nothing
    // Raises:
    //   Nothing
    //------------------------------------------------------------------------
    void getStats(out stats statistics);

  };
};

#endif /* !MZS_ORACLE */
