//----------------------------------------------------------------------------
// File: mtcr.idl - Media Tools Content Resolution
//
// Description:
//   This module describes the interface used to resolve logical assetCookies
//   to physical content segments.  When the stream service is asked to play
//   an assetCookie, it processes it to figure out which resolution
//   implementation is required to properly translate the content name.  It
//   then calls a resolver of the appropriate type, who translates the name
//   and returns a list of segments which are the physical instantiation of
//   the name.
//   If someone wanted to implement a content manager, they could do so by
//   following these steps:
//      1. Create a server and means for providing asset cookies.  This means
//         defining a unique asset cookie type (a string), and defining the
//         format for such an asset cookie.  As an example, someone might 
//	   decide to create a 'foo' content manager.  Their asset cookies 
//         would then look like:
//		foo:XXX
//	   where 'XXX' would be some string whose format was  defined by 
//	   the implementation.
//	   If the content manager was also going to provide for authorization,
//	   they would also need to define what the authorization object was
//	   for the content, and instruct clients on how to obtain such an
//	   object.  For example, an implementation might choose to use the
//	   session object obtaining from the session manager to perform
//	   authorization.
//	2. Implement the interface provided below in an ORB server.  This
//	   interface would be called any time the stream service needed to
//	   resolve an asset cookie of the given type.  Note that it is also
//	   passed the authorization object.
//	3. The content manager would need to publish its implementation of 
//	   the mtcr interface.  This is done using the typical ORB calls. 
//	   The interface id is generated by compiling this IDL file. For 
//	   example, the C mapping produces the ysid mtcr_resolve__id, which 
//	   can be passed to the yoSetImpl and yoImplReady calls.  The 
//	   implementation should be set to the name chosen in step 1.  So, 
//	   in the example given above, a client would publish a service with 
//	   the interface mtcr_resolve__id, and the implementation "foo".
//   Once these steps are followed, a client might do the following:
//	1. Obtain an asset cookie (and possibly an authorization object) from
//	   the new content manager through a means defined by the content
//	   manager.
//	2. Pass these asset cookies (and possibly authorization objects) to
//	   the stream service or other service provider.
//	3. The stream service or other service provider would then inspect
//	   the asset cookie type, and try to bind to a content resolver with
//	   the appropriate implementation id.  This would cause the stream
//	   service to call the new content manager, who could translate the
//	   asset cookie to physical content (or refuse to based on the passed
//	   authorization object).
//
// Modification History:
//   Name       Date            Comments
//   dpawson	04/25/97	Add circuit for server-side authorization
//   dpawson    12/11/96	Add further documentation
//   dpawson    09/10/96        Creation
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// Oracle Corporation							     
// Oracle Media Server (TM)						     
// All Rights Reserved
// Copyright (C) 1993-1996						     
//---------------------------------------------------------------------------

#ifndef MTCR_ORACLE
#define MTCR_ORACLE

#ifndef MKD_ORACLE
#include "mkd"                           /* Format for resolved segments */
#endif /* !MKD_ORACLE */

//----------------------------------------------------------------------------
// Module: mtcr
// Function:
//   This is the module responsible for translation.
//----------------------------------------------------------------------------
module mtcr
{
   // The maximum length for any implementation name
   const unsigned short maxImplNameLen    = 32;

   // This exception will be thrown if a resolver implementation cannot be
   // determined from a passed assetCookie.
   exception noImpl {};

   // This exception will be thrown if a resolver cannot be found with the
   // given implementation ID
   // Note that anyone catching this exception must yoFree() the name.
   exception badImpl
   {
     string implName;
   };
   
   // This exception will be thrown if a name cannot be translated.
   // Note that anyone catching this exception must yoFree() the name.
   exception badName
   {
     string theName;
   };

   // This exception will be thrown if the content resolver refuses to
   // resolve an asset cookie because it finds that there is insufficient
   // authentication.
   exception authFailed {};
   
   //-------------------------------------------------------------------------
   // Interface: resolve
   // Function:
   //   This holds the actual content resolution call.
   //-------------------------------------------------------------------------
   interface resolve
   {
      //----------------------------------------------------------------------
      // Name: mtcr::resolve::name
      // Function:
      //   This is the call which actually translates the given name into
      //   physical segments.  The format of the name is dependent on the
      //   implementation of the resolver.
      // Input:
      //   resName      A string whose format is determined by the
      //                implementation.  This is what will be translated.
      //   authRef      An object that the content resolver can use for
      //                authorizing the content.  The nature of this object
      //                is defined by the supplier of the assetCookie.
      //   destination  The network circuit that will be used to deliver the
      //                content if it is authorized.  The content resolver
      //                can use this for further authorization.  It is 
      //		possible that a client may ask for content translation
      //		without providing this circuit (it may not be 
      //		available to all content distributors).  In this case,
      //		it is up to the discretion of the content manager 
      //		whether to actually do the resolution or to return
      //		an authFailed exception.
      //		Note: This is defined as an any rather than 
      //		an mzc::circuit to prevent unpleasant dependencies for
      //		clients who need to resolve content but will not be
      //		passing a circuit.  The object passed should always be
      //		either an mzc::circuit or a NULL object.
      // Output:
      //   None
      // Returns:
      //   An array of segments describing the physical instantiation of
      //   the named logical content.
      // Raises:
      //   badName      The passed name could not be translated.
      //   authFailed	The authentication reference does not allow the
      //	        translation of the given asset cookie.
      //----------------------------------------------------------------------
      mkd::segmentList name(in string resName, in Object authRef,
                            in any destination)
        raises(badName, authFailed);
   };
};

#endif /* !MTCR_ORACLE */
