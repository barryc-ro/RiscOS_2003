/* Copyright (c) 1996 by Oracle Corporation.  All Rights Reserved.
 *
 * yccphdr.c - generation of C++ header output 
 *
 * NOTES
 *
 * HISTORY
 * 06/06/96 kcoleman    Bug 369357: Revamp I/O to limit line length
 * 04/08/96 kcoleman	Use ysRecord for error reporting.
 * 03/25/96 kcoleman	Support for static typecode option.
 * 02/27/96 kcoleman	Creation
@@ guard code on anonymous types
@@ include files
@@ string_var vs. char* vs. string_seqmem
 */

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCCP0_ORACLE
#include <yccp0.h>
#endif
#ifndef YSSTR_ORACLE
#include <ysstr.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif


STATICF void yccpGenDecl( ycctx* ctx, yccfp* fp, yrobj* decl, boolean isFwd);
STATICF void yccpGenIntfDecl(ycctx* ctx, yccfp* fp, yrobj* intf, boolean fwd);
STATICF void yccpGenExDecl( ycctx* ctx, yccfp* fp, yrobj* ex, boolean fwd);
STATICF void yccpGenStructDecl(ycctx* ctx, yccfp* fp, yrobj* sobj,boolean fwd);
STATICF void yccpGenUnionDecl( ycctx* ctx, yccfp* fp, yrobj* uobj,boolean fwd);
STATICF void yccpGenAliasDecl(ycctx* ctx, yccfp* fp, yrobj* alias,boolean fwd);
STATICF void yccpGenEnumDecl(ycctx* ctx, yccfp* fp, yrobj* eobj, boolean fwd);
STATICF void yccpGenSeqDecl( ycctx* ctx, yccfp* fp, yrobj* name, yrobj* seq);
STATICF void yccpGenAttrDecl(ycctx* ctx, yccfp* fp, yrobj* attr);
STATICF void yccpGenOpDecl(ycctx* ctx, yccfp* fp, yrobj* op);
STATICF void yccpGenConstDecl(ycctx *ctx, yccfp *fp, yrobj *obj);
STATICF void yccpGenField(ycctx* ctx,yccfp* fp, yrobj* type, CONST char* name);
STATICF void yccpGenArrayDeclr( ycctx* , yccfp* , yrobj* , CONST char*);
STATICF void yccpGenOraExtDecls( ycctx* ctx, yccfp* fp, yrobj* type);
STATICF void yccpGenUnionMbrDecls( ycctx* ctx, yccfp* fp, yrunmbr* mbr);
STATICF void yccpGenArrayDecl( ycctx* ctx, yccfp* fp, yrobj* array);
STATICF void yccpGenDeferredDecls( ycctx* ctx, yccfp* fp, yslst* deferred);


/* ----------------------------------------------------------------------- */
/*
 * yccphdr - Shared header file code generation, driver
 */

void yccphdr(ycctx *ctx, CONST char *base, ycfile* fd)
{
  yccfp *fp;
  char  *upbase;
  CONST char* errtxt;
  CONST char* incl_sfx = (ycStyleOra(ctx) ? "ORACLE" : "IDL");

    /**** open temporary output file ****/
  fp = yccfpOpen(fd->newtmp, "w", SYSFPKIND_NONE, &errtxt, 
                 yccGetLineLimit( ctx));
  if ( !fp )
  {
    ysRecord( YCMSG(8), YCERRSEV, YSLSTR(fd->target), YSLSTR(errtxt), YSLEND);
    return;
  }
  upbase = ycToUpper(ysStrDup(base));        /* upper case for #define's */
  yccfpSetIndent( fp, 0);

    /**** produce boilerplate output ****/
  yccfpPrint( fp, "/* GENERATED FILE\n * %s - public declarations\n", base);
  yccfpPrint( fp, " * from %s\n */\n\n", ctx->srcnm);
  yccfpPrint( fp, "#ifndef %s_%s\n#define %s_%s\n\n", 
              upbase, incl_sfx, upbase, incl_sfx);

  yccfpPrint(fp, "extern \"C\"\n{\n");    /* protect against C-ness */
  yccGenSysIncls(ctx, fp, FALSE);
  yccfpPrint(fp, "}\n\n");
yccfpPrint( fp, "#include \"yocplus.h\"\n");   /* @@ testing hack */

    /***** output all the declarations *****/
  if ( ysLstCount( ctx->newobjs) > 0 )
  {
    yslst* deferred;

    ycgNewScopeStack( ctx);
    yccpGenCGObjs( ctx, fp, ctx->newobjs, yccpGenDecl, yccpGenDeferredDecls);
    deferred = ycgPopScope(ctx);
    if ( deferred )
    {
      yccpGenDeferredDecls( ctx, fp, deferred);
      ysLstDestroy( deferred, (ysmff)0);
    }
  }

    /***** produce boilerplate ending *****/
  yccfpPrint(fp, "#endif /* %s_%s */\n", upbase, incl_sfx);

  ysmGlbFree((dvoid *) upbase);
  yccfpClose( fp);
}


/* ----------------------------------------------------------------------- */

STATICF void yccpGenDecl( ycctx* ctx, yccfp* fp, yrobj* decl, boolean isFwd)
{
  switch ( yrGetKind(decl) )
  {
    case yrdkInterface:
      yccpGenIntfDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkConstant:
        /* enumerators are gen'd with their enum type */
      if ( !ycIsEnumConst(decl) )
        yccpGenConstDecl(ctx,fp, decl);
      break;
    case yrdkException:
      yccpGenExDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkAlias:
      yccpGenAliasDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkStruct:
      yccpGenStructDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkUnion:
      yccpGenUnionDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkEnum:
      yccpGenEnumDecl(ctx, fp, decl, isFwd);
      break;
    case yrdkSequence:
      yccpGenSeqDecl(ctx, fp, (yrobj*)0, decl);
      break;
    case yrdkAttribute:
      yccpGenAttrDecl(ctx, fp, decl);
      break;
    case yrdkOperation:
      yccpGenOpDecl(ctx, fp, decl);
      break;
    default:
      /* error */
      break;
  }
}


/* ----------------------------------------------------------------------- */
/*
 * yccpGenConstDecl - generate code for an IDL constant declaration
 *
 * const <type> <name> = <value>;
 */
STATICF void yccpGenConstDecl(ycctx *ctx, yccfp *fp, yrobj *obj)
{
  CONST char* name;
  CONST char* guard = (char*)0;
  boolean inClass = yccpInClassScope( ctx, obj);

  if ( !inClass )
  {
    guard = yccpFlattenAbsName( ctx, obj);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }

    /***** print the type *****/
  yccfpPrint( fp, "static const %s", yccpTypeName(ctx, yrConstData(obj).type));
  name = yccpSimpleName( ctx, obj);

    /***** print name and possibly value *****/
  if ( !inClass )
  {
    yccfpPrint( fp, " %s = ", name);
    yccGenConstVal( ctx, fp, obj);
    yccfpPrint( fp, ";\n");
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
    ysmGlbFree( (dvoid*)guard);
  }
  else
    yccfpPrint( fp, " %s;\n\n", name);
}

/* ----------------------------------------------------------------------- */
/*
 * yccpGenIntfDecl - Generate declarations for an IDl interface type
 *
 * A forward declaration ("interface T;") produces a forward decl of class
 * T, typedefs for T_ptr and TRef, and the T_var class declaration.
 *
 * A full interface declaration produces all of the above, plus the full
 * declaration of class T, a typecode, and Any insertion/extraction ops.
 */

STATICF void yccpGenIntfDecl(ycctx* ctx, yccfp* fp, yrobj* intf, boolean fwd)
{
  CONST char* name;
  yslst* deferred;
  CONST char* guard;

  if ( ycIsCorbaObject( ctx, intf) )   /* CORBA::Object is a magic cookie */
    return;

  guard = yccpFlattenAbsName( ctx, intf);
  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n", guard, guard);
  yccfpEndPP( fp);

  name = yccpSimpleName( ctx, intf);
  yccfpPrint( fp, "class %s;\n", name);
  yccfpPrint( fp, "typedef %s* %s_ptr;\n", name, name);
  yccfpPrint( fp, "typedef %s* %sRef;\n", name, name);
#ifdef NEVER
  yccpGenIntfTVar( ctx, fp, intf, FALSE);
#else
  yccfpPrint( fp, "YOTVAR_INTF_DECL(%s);\n", name);
#endif

  yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);

  if ( ! fwd )
  {
    ysle* le;
    CONST char* sname;    /* simple name of the interface in its own scope */

    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DEFINED\n#define %s_DEFINED\n", guard, guard);
    yccfpEndPP( fp);

    yccfpPrint( fp, "class %s", name);

      /***** Print inheritance list *****/
    if ( yrInterfaceData(intf).bases )
    {
      ysle* le;

      yccfpPrint( fp, " : ");
      for (le = ysLstHead(yrInterfaceData(intf).bases); le; le = ysLstNext(le))
      {
        CONST char* bname;
        yrobj* base = (yrobj*) ysLstVal(le);

        bname = yccpScopedName( ctx, base);
        yccfpPrint( fp,"public %s%s", bname, ysLstNext(le) ? ", " : "");
      }
    }

    yccfpPrint( fp, "\n{\npublic:\n");
    yccfpIncIndent( fp);
    ycgPushScope( ctx, intf);
    sname = yccpAbsoluteName( ctx, intf);

      /***** static mem funcs required by CORBA *****/
    yccfpPrint( fp, "static %s_ptr _duplicate( %s_ptr obj);\n", sname, sname);
    yccfpPrint( fp, "static %s_ptr _narrow( %sObject_ptr obj);\n",
                sname, YCP_CORBA(ctx));
    yccfpPrint( fp, "static %s_ptr _nil();\n\n");

      /***** Types, constants, ops, and attributes from the IDL *****/
    for ( le = ysLstHead( yrGetContents(intf)); le; le = ysLstNext(le))
    {
      yrobj* mem = (yrobj*) ysLstVal(le);

      if ( yrGetDefinedIn(mem) == intf )        /* not an inherited member */
        yccpGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
    }
      /***** Public Oracle Extensions *****/
    yccpGenOraExtDecls( ctx, fp, intf);

      /***** Private and protected regions *****/
    yccfpPrint( fp, "\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "protected:\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s();\nvirtual ~%s() {}\n\n", name, name);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "private:\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s( const %s&);\n", name, sname);
    yccfpPrint( fp, "%s& operator=( const %s&);\n", sname, sname);

    yccfpDecIndent( fp);
    yccfpPrint( fp, "};\n\n");
    deferred = ycgPopScope( ctx);

    yccpGenTypeCode( ctx, fp, intf, name, FALSE);
    yccpGenAnyFuncs( ctx, fp, intf, FALSE);
    if ( deferred )
    {
      yccpGenDeferredDecls( ctx, fp, deferred);
      ysLstDestroy( deferred, (ysmff)0);
    }
    yccfpPrint( fp, "#endif /* %s_DEFINED */\n\n", guard);
  }
}

/* ----------------------------------------------------------------------- */
/*
 * yccpGenExDecl - generate code for an IDL exception
 *
 * An exception maps to a C++ class derived from CORBA::UserException.
 * The class has the typical ctors and ops, plus a constructor which
 * has one parameter for each field in the exception.
 *
 * class T : public CORBA::UserException
 * {
 * public:
 *   T();
 *   T(...);       -- a param for every field
 *   T( const T&);
 *   ~T();
 *   T& operator=( const T&);
 *
 *   -- field declarations
 * };
@@ is the damn custom constructor supposed to copy or consume the params?!
 *
 * Unlike most IDL types, exceptions do not get Any insertion/extraction ops
 * or a T_var class.
 */

STATICF void yccpGenExDecl( ycctx* ctx, yccfp* fp, yrobj* ex, boolean fwd)
{
  CONST char* name;
  CONST char* sname;
  yslst* mbrs = yrStructData(ex).mbrs;
  yslst* nested;
  ysle* le;
  yrstrmbr* mem;
  CONST char* guard = (char*)0;

  if ( !yccpInClassScope( ctx, ex) )
  {
    guard = yccpFlattenAbsName( ctx, ex);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }
  name = yccpSimpleName( ctx, ex);
  yccfpPrint( fp, "class %s : public %sUserException\n", name, YCP_CORBA(ctx));
  yccfpPrint( fp, "{\npublic:\n");

  ycgPushScope( ctx, ex);
  yccfpIncIndent( fp);
  sname = yccpAbsoluteName( ctx, ex);     /* name inside it's own scope */

    /***** Nested types *****/
  nested = yrGetContents(ex);
  if ( nested )
  {
    for (le = ysLstHead( nested); le; le = ysLstNext(le))
      yccpGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
  }

    /***** Look for anonymous field types *****/
  if ( mbrs )
  {
    for (le = ysLstHead(yrStructData(ex).mbrs); le; le = ysLstNext(le))
    {
      mem = (yrstrmbr*) ysLstVal(le);
      if ( yrGetKind(mem->type) == yrdkSequence )
        yccpGenSeqDecl( ctx, fp, (yrobj*)0, mem->type);
      else if ( yrGetKind(mem->type) == yrdkArray )
      {
        DISCARD yccpAnonArrayName( ctx, mem->type, mem->name);
        yccpGenArrayDecl( ctx, fp, mem->type);
      }
    }
  }

    /***** ctors, dtor, op=, _narrow, etc. *****/
  yccfpPrint( fp, "%s();\n%s( const %s&);\n", name, name, sname);
  if ( mbrs && (ysLstCount(mbrs) > 0) )     /* custom ctor */
  {
    yccfpPrint( fp, "%s( ", name);
    for (le = ysLstHead(mbrs); le; le = ysLstNext(le))
    {
      mem = (yrstrmbr*) ysLstVal(le);
      yccpGenParamType( ctx, fp, mem->type, YOMODE_IN);   /* @@ mode? */
      yccfpPrint( fp, "%s", ysLstNext(le) ? ", " : " ");
    }
    yccfpPrint( fp, ");\n");
  }
  yccfpPrint( fp, "~%s();\n", name);
  yccfpPrint( fp, "%s& operator=( const %s&);\n\n", sname, sname);
    /***** Don't assume RTTI, must have _narrow op. See D.4 of CORBA 2.0 *****/
  yccfpPrint( fp, "static %s* _narrow( %sException*);\n",
              sname, YCP_CORBA(ctx));
  yccpGenOraExtDecls( ctx, fp, ex);

    /***** Member field declarations ****/
  if ( mbrs && (ysLstCount(mbrs) > 0) )
  {
    for (le = ysLstHead(mbrs); le; le = ysLstNext(le))
    {
      mem = (yrstrmbr*) ysLstVal(le);
      yccpGenField(ctx, fp, mem->type, mem->name);
    }
  }

  DISCARD ycgPopScope( ctx);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "};\n");
  yccpGenTypeCode( ctx, fp, ex, name, FALSE);
  if ( guard )
  {
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
  }
  else
    yccfpPrint( fp, "\n");
}


/* ----------------------------------------------------------------------- */
/*
 * yccpGenStructDecl - generate decls for an IDL struct type
 *
 * A IDL struct gens a corresponding C++ struct with *more or less* the same
 * fields as the IDL type, a T_var class, a typecode, and Any operators.
 * The "more or less" comes in for interface and string fields which are
 * handled via their associated T_var types, rather than the normal mapping
 * type.
 */

STATICF void yccpGenStructDecl(ycctx* ctx, yccfp* fp, yrobj* sobj, boolean fwd)
{
  ysle* le;
  CONST char* name;
  yrstrmbr* mem;
  CONST char* guard = (char*)0;

  if ( !yccpInClassScope( ctx, sobj) )
  {
    guard = yccpFlattenAbsName( ctx, sobj);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }
  name = yccpSimpleName( ctx, sobj);
  if ( fwd )
  {
    yccfpPrint( fp, "struct %s;\n", name);
  }
  else
  {
    yccfpPrint( fp, "struct %s\n{\n", name);
    ycgPushScope( ctx, sobj);
    yccfpIncIndent( fp);

      /***** Nested types *****/
    for (le = ysLstHead( yrGetContents(sobj)); le; le = ysLstNext(le))
      yccpGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);

      /***** Look for anonymous field types *****/
    for (le = ysLstHead(yrStructData(sobj).mbrs); le; le = ysLstNext(le))
    {
      mem = (yrstrmbr*) ysLstVal(le);
      if ( yrGetKind(mem->type) == yrdkSequence )
        yccpGenSeqDecl( ctx, fp, (yrobj*)0, mem->type);
      else if ( yrGetKind(mem->type) == yrdkArray )
      {
        DISCARD yccpAnonArrayName( ctx, mem->type, mem->name);
        yccpGenArrayDecl( ctx, fp, mem->type);
      }
    }
      /***** Struct members *****/
    for (le = ysLstHead(yrStructData(sobj).mbrs); le; le = ysLstNext(le))
    {
      mem = (yrstrmbr*) ysLstVal(le);
      yccpGenField(ctx, fp, mem->type, mem->name);
    }
    yccpGenOraExtDecls( ctx, fp, sobj);
    DISCARD ycgPopScope( ctx);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "};\n");

    yccpGenTypeCode( ctx, fp, sobj, name, FALSE);
    if ( !ycgScopeDefer( ctx, sobj) )
      yccpGenAnyFuncs( ctx, fp, sobj, FALSE);
#ifdef NEVER
    yccpGenStructTVar( ctx, fp, sobj, FALSE);
#else
    yccfpPrint( fp, "YOTVAR_STRUCT_DECL(%s);\n", name);
#endif
  }

  if ( guard )
  {
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
  }
}


/* ----------------------------------------------------------------------- */
/*
 * yccGenArrayDeclr - generate an array declarator
 *
 * What's so special about an array declarator? It has to have the
 * dimensions added after the declarator name.
 */
 
STATICF void yccpGenArrayDeclr( ycctx* ctx, yccfp* fp, yrobj* arr,
        CONST char* declr)
{
  yccfpPrint( fp, "%s", declr);
  for (; yrGetKind(arr) == yrdkArray; arr = yrArrayData(arr).elmtype)
  {
    yccfpPrint( fp, "[%u]", yrArrayData(arr).length);
  }
}


/* ----------------------------------------------------------------------- */
/*
 * yccpGenField - Generate the declaration of a struct field
 *
 * These differ from the C mapping primarily in the handling of string and
 * object reference fields, both of which are handled as their corresponding
 * T_var type when they appear as fields.
 */

STATICF void yccpGenField(ycctx* ctx, yccfp* fp, yrobj* type, CONST char* name)
{
  CONST char* kwdpfx = (*ctx->lang->kwdchk)( ctx, name) ? "_" : "";

  switch (yrGetKind(type))
  {
    case yrdkInterface:
      yccfpPrint( fp, "%s_var %s%s;\n", yccpTypeName(ctx, type), kwdpfx, name);
      break;
    case yrdkArray:
    {
      CONST char* tname = yccpAnonArrayName( ctx, type, name);

      yccfpPrint( fp, "%s %s%s;\n", tname, kwdpfx, name);
      break;
    }
    case yrdkString:
      yccfpPrint( fp, "%sString_var %s%s;\n", YCP_CORBA(ctx), kwdpfx, name);
      break;
    case yrdkSequence:
    {
      char* tname = yccpSeqName( ctx, type);

      yccfpPrint( fp, "%s %s%s;\n", tname, kwdpfx, name);
      ysmGlbFree( (dvoid*)tname);
      break;
    }
    case yrdkPrimitive:
      if ( yrPrimData(type).kind == yrpkstring )
      {
        yccfpPrint( fp, "%sString_var %s%s;\n", YCP_CORBA(ctx), kwdpfx, name);
        break;
      }
      /* else fall through */
    default:
      yccfpPrint(fp,"%s %s;\n", yccpTypeName(ctx, type), name);
      break;
  }
}

/* ----------------------------------------------------------------------- */
/*
 * yccpGenUnionDecl - generate code for an IDL union type
 *
 * Unions are annoyingly complicated - see Section 16.10 of the CORBA 2.0
 * spec for the details. In brief, they map to a class with accesors and
 * mutators for each of the individual fields, plus one for the discriminator,
 * and possibly one for the default case.
 *
 * At the declaration level, the notable twists are: The number and kind
 * of mutators associated with each field vary depending on the field type;
 * you have to be aware of multiple cases mapping to the same field; and
 * you have to figure out whether or not there is an implicit default case.
 * value to something which matches the current field. An _default member
 * An _default member function (for setting the discriminator) is only
 * only generated if there is no explicit default and if all value of 
 * the discriminator are not accounted for by the explicit cases.
 *
 * All this adds up to a lot more knowledge about the discriminator values
 * than I'd really care to have: 
 *
 * - What range of values attaches to each field? 
 * - What's an unused value that may be used for the default case?
 * - Are all the discriminator value accounted for? (e.g. do we need _default?)
 *
 * How do multiple union discriminator values for a case manifest in the
 * IFR? I'm sorry to say, as individual fields with the same name. How
 * very inconvenient; how very CORBA...Given the way the FE works, at least
 * you can assume here that they'll appear adjacent to one another on the
 * list of union arms.
 *
 * The algorithm for determining whether or not the union type has an implicit
 * default case isn't strictly correct: It assumes if the discriminator type
 * isn't an enum, boolean, or char type, then all the possible values aren't 
 * covered by cases. Strictly speaking, it is possible to cover all the
 * cases, but be serious: Do you really think there's going to be one out
 * there with 32k or more in explicit case labels? If someone finds it,
 * I'll fix it.
 */

STATICF void yccpGenUnionDecl( ycctx* ctx, yccfp* fp, yrobj* uobj, boolean fwd)
{
  boolean hasDefault = FALSE;
  boolean hasGaps = TRUE;
  CONST char* name;
  CONST char* sname;
  ysle* le;
  yslst* mbrs;
  yrunmbr* mem;
  yrobj* disc;
  CONST char* guard = (char*)0;
  ycsym* syminfo;
  
  name = yccpSimpleName( ctx, uobj);
  if ( fwd )
  {
    yccfpPrint( fp, "class %s;\n", name);
    return;
  }

  if ( !yccpInClassScope( ctx, uobj) )
  {
    guard = yccpFlattenAbsName( ctx, uobj);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }

  yccfpPrint( fp, "class %s\n{\npublic:\n", name);
  ycgPushScope( ctx, uobj);
  yccfpIncIndent( fp);
  sname = yccpAbsoluteName( ctx, uobj);

      /***** Nested types *****/
  for (le = ysLstHead( yrGetContents(uobj)); le; le = ysLstNext(le))
    yccpGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);

      /***** Look for anonymous field types *****/
  mbrs = yrUnionData(uobj).arms;
  for (le = ysLstHead(mbrs); le; le = ysLstNext(le))
  {
    mem = (yrunmbr*) ysLstVal(le);
    if ( yrGetKind(mem->type) == yrdkSequence )
      yccpGenSeqDecl( ctx, fp, (yrobj*)0, mem->type);
    else if ( yrGetKind(mem->type) == yrdkArray )
    {
      DISCARD yccpAnonArrayName( ctx, mem->type, mem->name);
      yccpGenArrayDecl( ctx, fp, mem->type);
    }
  }

    /***** ctors, dtor, op= *****/
  yccfpPrint( fp, "%s();\n", name);
  yccfpPrint( fp, "%s( const %s&);\n", name, sname);
  yccfpPrint( fp, "~%s();\n", name);
  yccfpPrint( fp, "%s& operator=( const %s&);\n\n", sname, sname);

    /***** Discriminator mem funcs, T::_d *****/
  disc = yrUnionData(uobj).disctype;
  yccfpPrint( fp, "void _d( ");
  yccpGenParamType( ctx, fp, disc, YOMODE_IN);
  yccfpPrint( fp, ");\n");
  yccpGenParamType( ctx, fp, disc, YOMODE_RETURN);
  yccfpPrint( fp, " _d() const;\n\n");

    /***** Accessors/Mutators for each field *****/
  for ( le = ysLstHead(mbrs); le; le = ysLstNext(le))
  {
    mem = (yrunmbr*) ysLstVal(le);
    if ( yotkGetKind(mem->label._type) == yotkNull )       /* default case */
      hasDefault = TRUE;
    yccpGenUnionMbrDecls( ctx, fp, mem);
  }

    /***** Do we need to generate an _default mem func? *****/
  if ( !hasDefault )
  {
    yrobj* base = disc;

    syminfo = ycSymLookup( ctx->symtbl, uobj);
    if ( syminfo->lang.cplus.union_dflt != 0 )
      hasGaps = ((syminfo->lang.cplus.union_dflt == 1) ? TRUE : FALSE);
    else
    {
      if ( yrGetKind( disc) == yrdkAlias )
        base = yrGetAliasBaseType(disc);
      if ( yrGetKind(base) == yrdkPrimitive )
      {
        switch (yrPrimData(base).kind)
        {
          case yrpkboolean:
            hasGaps = ( ysLstCount( mbrs) <= 1);
            break;
          case yrpkchar:            /* Unlikely, but conceivable. Barely. */
          case yrpkoctet:
            hasGaps = (ysLstCount(mbrs) < UB1MAXVAL);
            break;
          case yrpklong:
          case yrpkulong:
          case yrpkshort:
          case yrpkushort:
            hasGaps = TRUE;          /* OK, I'm guessing. So sue me. */
            break;
          default:
            yseThrow( YC_EX_FAILURE);
            break;    /* unreachable */
        }
      }
      else    /* enum */
      {
        hasGaps = (ysLstCount(mbrs) < ysLstCount( yrEnumData(base).mbrs));
      }
      syminfo->lang.cplus.union_dflt = (hasGaps ? 1 : -1);
    }

    if ( hasGaps )             /* we need _default */
      yccfpPrint( fp, "void _default();\n\n");
  }

    /***** Oracle Extensions *****/
  yccpGenOraExtDecls( ctx, fp, uobj);

    /***** Private part of the union *****/
  yccfpDecIndent( fp);
  yccfpPrint( fp, "private:\n");
  yccfpIncIndent( fp);
  yccpGenField( ctx, fp, disc, "_disc");
  yccfpPrint( fp, "%s* _data;\n", YCCVOID(ctx));

  DISCARD ycgPopScope( ctx);
  yccfpDecIndent( fp);
  yccfpPrint( fp, "};\n");

  yccpGenTypeCode( ctx, fp, uobj, name, FALSE);
  if ( !ycgScopeDefer( ctx, uobj) )
    yccpGenAnyFuncs( ctx, fp, uobj, FALSE);
#ifdef NEVER
  yccpGenStructTVar( ctx, fp, uobj, FALSE);
#else
    yccfpPrint( fp, "YOTVAR_STRUCT_DECL(%s);\n", name);
#endif

  if ( guard )
  {
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
  }
}

/* ----------------------------------------------------------------------- */
/*
 * yccpGenAliasDecl - generate code for an IDL typedef
 *
 * An alias must generate renames of all types generated for the parent
 * type, plus a typecode. Note that it is not necessary to generate new
 * Any inserters/extractors for most alias because typedefs are not 
 * distinct C++ types, so the ones generated for the parent type work for 
 * the alias. As usual, this does not apply to an alias of an anonymous
 * type like an array.
 */

STATICF void yccpGenAliasDecl(ycctx* ctx, yccfp* fp, yrobj* alias, boolean fwd)
{
  yrobj* base;
  CONST char* pname;
  CONST char* name = yccpSimpleName( ctx, alias);
  yrobj* parent = yrAliasData(alias).type;
  CONST char* guard = (char*)0;

  if ( !yccpInClassScope( ctx, alias) )
  {
    guard = yccpFlattenAbsName( ctx, alias);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }

  base = yrGetAliasBaseType( alias);
  switch (yrGetKind( base))
  {
    case yrdkInterface:
      /* T, T_var, T_ptr, TRef */
      pname = ((yrGetKind(parent) == yrdkAlias) ?
                   yccpAbsoluteName( ctx, parent) :
                   yccpAbsoluteName( ctx, base));
      yccfpPrint( fp, "typedef %s %s;\n", pname, name);
      yccfpPrint( fp, "typedef %s_var %s_var;\n", pname, name);
      yccfpPrint( fp, "typedef %s_ptr %s_ptr;\n", pname, name);
      yccfpPrint( fp, "typedef %sRef %sRef;\n", pname, name);
      break;
    case yrdkStruct:
    case yrdkUnion:
      /* T, T_var */
      pname = ((yrGetKind(parent) == yrdkAlias) ?
                 yccpAbsoluteName( ctx, parent) :
                 yccpAbsoluteName( ctx, base));
      yccfpPrint( fp, "typedef %s %s;\n", pname, name);
      yccfpPrint( fp, "typedef %s_var %s_var;\n", pname, name);
      break;
    case yrdkException:
    case yrdkEnum:
      /* T */
      pname = ((yrGetKind(parent) == yrdkAlias) ?
                 yccpAbsoluteName( ctx, parent) :
                 yccpAbsoluteName( ctx, base));
      yccfpPrint( fp, "typedef %s %s;\n", pname, name);
      break;
    case yrdkPrimitive:
      /* T, for most types. */
      switch (yrPrimData(base).kind)
      {
        case yrpkany:
          yccfpPrint( fp, "typedef %sAny %s;\n", YCP_CORBA(ctx), name);
          yccfpPrint( fp, "typedef %sAny %s_var;\n", YCP_CORBA(ctx), name);
          break;
        case yrpkTypeCode:
          yccfpPrint( fp, "typedef %sTypeCode %s;\n", YCP_CORBA(ctx), name);
          yccfpPrint( fp, "typedef %sTypeCode_var %s_var;\n",
                      YCP_CORBA(ctx), name);
          yccfpPrint( fp, "typedef %sTypeCode_ptr %s_ptr;\n", 
                      YCP_CORBA(ctx), name);
          yccfpPrint( fp, "typedef %sTypeCodeRef %sRef;\n",
                      YCP_CORBA(ctx), name);
          break;
        case yrpkstring:
          yccfpPrint( fp, "typedef char* %s;\n", name);
          yccfpPrint( fp, "typedef %sString_var %s_var;\n",
                      YCP_CORBA(ctx), name);
          break;
        default:
          yccfpPrint( fp, "typedef %s %s;\n", 
                      yccGetPrimitiveName( ctx, yrPrimData(base).kind), name);
          break;
        }
      break;
    case yrdkString:
      /* T, T_var */
      yccfpPrint( fp, "typedef char* %s;\n", name);
      yccfpPrint( fp, "typedef %sString_var %s_var;\n", YCP_CORBA(ctx), name);
      break;
    case yrdkArray:
      /* T, T_var, T_forany, T_slice, T_alloc, T_dup, T_free */
      if ( yrGetKind(parent) == yrdkAlias )
      {
        pname = yccpAbsoluteName( ctx, parent);
        yccfpPrint( fp, "typedef %s %s;\n", pname, name);
        yccfpPrint( fp, "typedef %s_var %s_var;\n", pname, name);
        yccfpPrint( fp, "typedef %s_forany %s_forany;\n", pname, name);
        yccfpPrint( fp, "typedef %s_slice %s_slice;\n", pname, name);
        yccfpPrint( fp, "%s_slice* %s_alloc();\n", name, name);
        yccfpPrint( fp, "%s_slice* %s_dup( const %s_slice*);\n",
                    name, name, name);
        yccfpPrint( fp, "void %s_free( const %s_slice*);\n", name, name);
      }
      else
      {
/* @@ sequence hack alert! */
/* @@ this is a problem because modules aren't showing up on scope stack right now */
        yrobj* scope = yrGetDefinedIn(alias);

        if ( yrGetKind(scope) == yrdkModule )
          ycgPushScope( ctx, scope);
        yccpGenArrayDecl( ctx, fp, alias);
        if ( yrGetKind(scope) == yrdkModule )
          DISCARD ycgPopScope( ctx);
      }
      break;
    case yrdkSequence:
      /* T, T_var */
      if ( yrGetKind(parent) == yrdkAlias )
      {
        pname = yccpAbsoluteName( ctx, parent);
        yccfpPrint( fp, "typedef %s %s;\n", pname, name);
        yccfpPrint( fp, "typedef %s_var %s_var;\n", pname, name);
      }
      else if ( (yrSeqData(base).bound == 0) && 
                (ctx->lang->flags & YCCP_BUILTIN_SEQ_FLG) &&
                (yrGetKind(yrSeqData(base).elmtype) == yrdkPrimitive) )
      {
        pname = yccpSimpleName( ctx, base);
        yccfpPrint( fp, "typedef %s %s;\n", pname, name);
        yccfpPrint( fp, "typedef %s_var %s_var;\n", pname, name);
      }
      else
        yccpGenSeqDecl( ctx, fp, alias, base);
      break;
    default:
      yseThrow( YC_EX_FAILURE);
      break;   /* unreachable */
  }
  yccpGenTypeCode( ctx, fp, alias, name, FALSE);
  if ( guard )
  {
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
  }
  else
    yccfpPrint( fp, "\n");
}

/* ----------------------------------------------------------------------- */
/*
 * yccpGenEnumDecl - Generate an enumeration type
 *
 * IDL enumeration types map directly on to C++ enumeration types, with
 * one small hitch: They must be 32 bits long. In C++, compilers are free
 * to make enum types any size that will hold all the value (e.g. 8 bits
 * if all the enumerators are < 128). In order to force a 32-bit 
 * representation, we must sometimes generate an extra enumerator with a
 * value too large to fit in less than 32 bits.
@@ and just what is this value? Can it be handled in a non-OSD fashion?
 */
STATICF void yccpGenEnumDecl(ycctx* ctx, yccfp* fp, yrobj* eobj, boolean fwd)
{
  CONST char* name;
  CONST char* ename;
  yslst* mbrs;
  ysle* le;
  boolean needmax = TRUE;      /* Need an enumerator to force 32 bit size? */
  CONST char* guard = (char*)0;

  if ( !yccpInClassScope( ctx, eobj) )
  {
    guard = yccpFlattenAbsName( ctx, eobj);
    yccfpStartPP( fp);
    yccfpPrint( fp, "#ifndef %s_DECLARED\n#define %s_DECLARED\n",
                guard, guard);
    yccfpEndPP( fp);
  }
  name = yccpSimpleName( ctx, eobj);
  mbrs = yrEnumData(eobj).mbrs;

  yccfpPrint( fp, "enum %s\n{\n", name);
  yccfpIncIndent( fp);
  for ( le = ysLstHead( mbrs); le; le = ysLstNext(le))
  {
    yrobj* mbr = (yrobj*) ysLstVal(le);       /* yrconst */

    ename = yccpSimpleName( ctx, mbr);
    yccfpPrint( fp, "%s%c\n", ename, ysLstNext(le) ? ',' : ' ');
    if ( *((ub4*)yrConstData(mbr).val._value) >= UB2MAXVAL )
      needmax = FALSE;
  }

    /***** Gen an enum lit large enough to force type to 32 bits *****/
  if ( needmax || ysLstCount(mbrs) < UB2MAXVAL )     /* @@ */
  {
    yccfpPrint( fp, ", ORA_CORBA_ENUM_MAX(%s)\n", name);
  }

  yccfpDecIndent( fp);
  yccfpPrint( fp, "};\n");
  yccpGenTypeCode( ctx, fp, eobj, name, FALSE);
  if ( !ycgScopeDefer( ctx, eobj) )
    yccpGenAnyFuncs( ctx, fp, eobj, FALSE);
  if ( guard )
  {
    yccfpPrint( fp, "#endif /* %s_DECLARED */\n\n", guard);
  }
  else
    yccfpPrint( fp, "\n");
}


/* ----------------------------------------------------------------------- */
/*
 * yccpGenSequenceDecl - generate code for an IDL sequence type
 *
 * This can be called either as the result of code gen for a sequence
 * alias, or to generate code for a truly anonymous type (e.g. a
 * sequence used in a struct field). In the alias case, <nm> is the
 * alias object and the sequence type name is derived from that. In the
 * anonymous case, the sequence type name is derived via formulas known
 * to the functions in yccpname.c.
 *
 * A class T, T_var, typecode, and Any inserters/extractors are generated.
 *
 * A word about naming: Unlike most named types, a sequence type decl
 * doesn't have to worry about whether or not the sequence name is unique
 * within its own scope - the nature of how and where they can be declared
 * in the IDL means it is always safe to use the simple name.
 */

STATICF void yccpGenSeqDecl( ycctx* ctx, yccfp* fp, yrobj* nm, 
                             yrobj* seq)
{
  ub4 bound = yrSeqData(seq).bound;
  char* ename;
  CONST char* name;

  if ( (bound == 0) && (ctx->lang->flags & YCCP_BUILTIN_SEQ_FLG) &&
      (yrGetKind(yrSeqData(seq).elmtype) == yrdkPrimitive) )
    return;    /* unbound seq of primitive type -> class decl is predef'd */

  ename = yccpElemName( ctx, seq);
  name = yccpSimpleName( ctx, nm ? nm : seq);
  yccfpPrint( fp, "class %s\n{\npublic:\n", name);
  ycgPushScope( ctx, seq);
  yccfpIncIndent( fp);

  /***** constructors, destructor, operator= *****/
    /* T(), T(const T&) */
  yccfpPrint( fp, "%s();\n", name);
  yccfpPrint( fp, "%s( const %s&);\n", name, name);
  if ( bound == 0 )
  {
      /* T( ub4 max), T( ub4 max, ub4 length, E* , boolean = FALSE) */
    yccfpPrint( fp, "%s( ub4 _max);\n", name);
    yccfpPrint( fp, "%s( ub4 _max, ", name);
  }
  else
  {
      /* T( ub4 length, E* data, boolean release = FALSE) */
    yccfpPrint( fp, "%s( ", name);
  }
  yccfpPrint( fp, "ub4 _length, %s* _data, boolean _release = FALSE);\n",
                      ename);

    /* ~T(), T& operator=( const T&) */
  yccfpPrint( fp, "~%s();\n", name);
  yccfpPrint( fp, "%s& operator=( const %s&);\n\n", name, name);
  /***** Length & max manipulation *****/
  yccfpPrint( fp, "ub4 maximum() const;\n");
  yccfpPrint( fp, "ub4 length() const;\n");
  yccfpPrint( fp, "void length(ub4);\n\n");

  /***** Indexing *****/
  yccfpPrint( fp, "%s& operator[]( ub4 index);\n", ename);
  yccfpPrint( fp, "const %s& operator[]( ub4 index) const;\n\n", ename);

  /***** Buffer management *****/
  yccfpPrint( fp, "static %s* allocbuf( ub4 _nelems);\n", ename);
  yccfpPrint( fp, "static void freebuf( %s* _buff);\n\n", ename);
  
  /***** Oracle Extensions *****/
  yccpGenOraExtDecls( ctx, fp, seq);     /* @@ might not want them all */
  if ( bound == 0 )
  {
    yccfpPrint( fp, "void reallocbuf( ub4 _nelems);\n");
    yccfpPrint( fp, "void maximum( ub4 _len);\n");
  }

  /***** Private portion *****/
  yccfpDecIndent( fp);
  yccfpPrint( fp, "private:\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "void _copy( const %s&);\n", name);
  yccfpPrint( fp, "ub4 _maximum;\nub4 _length;\n%s* _buffer;\n", ename);
  yccfpPrint( fp, "boolean _release;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "};\n\n");
  DISCARD ycgPopScope(ctx);    /* never any deferred objects here */

  /***** CORBA Any operators *****/
  if ( !ycgScopeDefer( ctx, seq) )
  {
    yccpGenExtractor( ctx, fp, seq, name, FALSE);
    yccpGenInserter( ctx, fp, seq, name, FALSE);
    yccpGenCopyInserter( ctx, fp, seq, name, FALSE);
    yccfpPrint( fp, "\n");
  }

  /***** Typecode, T_var, etc. *****/
  if ( !nm )
    yccpGenTypeCode( ctx, fp, seq, name, FALSE);
#ifdef NEVER
  yccpGenSeqTVar( ctx, fp, seq, FALSE);
#else
  yccfpPrint( fp, "YOTVAR_SEQ_DECL(%s, %s);\n", name, ename);
#endif
  ysmGlbFree( (dvoid*)ename);
}


/* ----------------------------------------------------------------------- */
/*
 * yccpGenArrayDecl - generate code for an IDL array type
 *
 * Array types are always anonymous. They can be associated with a name
 * by being part of a typedef, but they can also appear totally anonymously
 * in struct, union, and exception fields. When truly anonymous, the
 * compiler manufactures some appropriate name and passes it in here.
 *
 * Every array type T of E therefore has associated with it:
 *   typedef E T[..];
 *   typedef E T_slice[..];   -- T, less the first dimension
 *   class T_var;
 *   class T_forany;
 *   T_slice* T_alloc();
 *   T_slice* T_dup( const T_slice*);
 *   void T_free( T_slice*);
 *   void operator<<=( Any&, const T_forany&);
 *   boolean operator>>=( const Any&, T_forany&);
 *
 * When appearing inside an interface, union, struct, or exception scope,
 * the support functions are static member functions of the enclosing type.
 * In addition, there are the standard Any ops and typecode decls.
@@ anonymous element types (sequence, string)
 */
STATICF void yccpGenArrayDecl( ycctx* ctx, yccfp* fp, yrobj* type)
{
  yrobj* etype;
  yrobj* p;
  CONST char* ename = (char*)0;
  yrobj* array = type;
  CONST char* name = yccpSimpleName(ctx, type);
  CONST char* pfx = yccpInClassScope(ctx, type) ? "static " : "";

  while ( yrGetKind(array) == yrdkAlias )    /* find array type under alias */
    array = yrAliasData(array).type;

  etype = yrArrayData(array).elmtype;
  while ( yrGetKind(etype) == yrdkArray )    /* find element type */
    etype = yrArrayData(etype).elmtype;
  ename = yccpTypeName( ctx, etype);

    /***** typedef E T[..]; *****/
  yccfpPrint( fp, "typedef %s %s", ename, name);
  for (p = array; yrGetKind(p) == yrdkArray; p = yrArrayData(p).elmtype)
  {
    yccfpPrint( fp, "[%u]", yrArrayData(p).length);
  }

    /***** typedef E T_slice{[..]}; *****/
  yccfpPrint( fp, ";\n");
  yccfpPrint( fp, "typedef %s %s_slice", ename, name);
  for (p = yrArrayData(array).elmtype; yrGetKind(p) == yrdkArray; 
        p = yrArrayData(p).elmtype)
  {
    yccfpPrint( fp, "[%u]", yrArrayData(p).length);
  }
  yccfpPrint( fp, ";\n");

    /***** T_alloc, T_dup, T_free *****/
  yccfpPrint( fp, "%s%s_slice* %s_alloc();\n", pfx, name, name);
  yccfpPrint( fp, "%s%s_slice* %s_dup( const %s_slice*);\n", 
              pfx, name, name, name);
  yccfpPrint( fp, "%svoid %s_free( %s_slice*);\n", pfx, name, name);

    /***** class T_var, class T_forany *****/
#ifdef NEVER
  yccpGenArrayTVar( ctx, fp, array, FALSE);
#else
  yccfpPrint( fp, "YOTVAR_ARRAY_DECL(%s);\n", name);
  yccfpPrint( fp, "YOFORANY_DECL(%s);\n", name);
#endif

    /***** CORBA::Any ops *****/
  if ( !ycgScopeDefer( ctx, array) )
  {
    yccpGenExtractor( ctx, fp, array, name, FALSE);
    yccpGenCopyInserter( ctx, fp, array, name, FALSE);
  }
  yccfpPrint( fp, "\n");
}

/* ----------------------------------------------------------------------- */
/*
 * yccpGenAttrDecl - generate code for an interface attribute
 *
 * A readonly attribute generates a single method for retrieving the
 * attribute value; a read/write attribute additionally generates an
 * overload for setting the attribute value:
 *
 *   <attr-type> attr( {<environment>,} <event> = NULL);          -- get op
 *   void attr( <attr-type>, {<environment>,} <event> = NULL);    -- set op
 *
 * The set op treats the attribute type as it normally would be for an in
 * parameter. See yccpGenOpDecl for more information about the environment
 * and event parameters.
 */

STATICF void yccpGenAttrDecl(ycctx* ctx, yccfp* fp, yrobj* attr)
{
  CONST char* name;

  name = yccpSimpleName( ctx, attr);

    /***** The get operation *****/
  yccpGenParamType( ctx, fp, yrAttrData(attr).type, YOMODE_RETURN);
  yccfpPrint( fp, " %s( %sEnvironment& env, ", name, YCP_CORBA(ctx));
  yccfpPrint( fp, "ysevt* usrevt = (ysevt*)0);\n");

    /***** The set operation *****/
  if ( yrAttrData(attr).mode != YR_ATTR_RO )
  {
    yccfpPrint( fp, "void %s( ", name);
    yccpGenParamType( ctx, fp, yrAttrData(attr).type, YOMODE_IN);
    yccfpPrint( fp, " _val, %sEnvironment& env, ", YCP_CORBA(ctx));
    yccfpPrint( fp, "ysevt* usrevt = (ysevt*)0);\n");
  }
}


/* ----------------------------------------------------------------------- */
/*
 * yccpGenOpDecl - generate the declaration of an interface operation
 *
 * Roughly speaking, we generate:
 *   <rettype> op(<pars>, {<environment>,} <event> = NULL);
 *
 * Where the presence of the environment parameter is dependent upon 
 * whether or not we're generating code for an C++ development environment
 * which supports native C++ exceptions.
 *
 * The event parameter, which always appears last, is an Oracle extension
 * for making asynchronous calls. By default, the event is NULL, indicating
 * a blocking, or synchronous, call as CORBA object requests normally are.
 */

STATICF void yccpGenOpDecl(ycctx* ctx, yccfp* fp, yrobj* op)
{
  CONST char* name;
  ysle* le;
  ycgkwdfp kwdfp = ctx->lang->kwdchk;

  name = yccpSimpleName( ctx, op);
  yccpGenParamType( ctx, fp, yrOpData(op).rettype, YOMODE_RETURN);
  yccfpPrint( fp, " %s( ", name);

  if ( yrOpData(op).pars )
  {
    for ( le = ysLstHead( yrOpData(op).pars); le; le = ysLstNext(le))
    {
      yrpar* par = (yrpar*) ysLstVal(le);

      yccpGenParamType( ctx, fp, par->type, par->mode);
      yccfpPrint( fp, " %s%s, ", 
                  ((*kwdfp)(ctx, par->name) ? "_" : ""), par->name);
    }
  }
    /* @@ make this a function or a macro... */
  yccfpPrint( fp, "%sEnvironment& env, ", YCP_CORBA(ctx));
  yccfpPrint( fp, "ysevt* usrevt = (ysevt*)0);\n");
}


/* ----------------------------------------------------------------------- */
/*
 * yccpGenOraExtDecls - Generate Oracle Extensions for types which map to
 *    C++ classes.
 *
 * At present, this is only the _typecode member function. Presumably it will 
 * grow once we hammer out the implementation.
 */

STATICF void yccpGenOraExtDecls( ycctx* ctx, yccfp* fp, yrobj* type)
{
  switch (yrGetKind( ycgScope(ctx)))
  {
    case yrdkStruct:             /* static member function */
    case yrdkUnion:
    case yrdkException:
    case yrdkInterface:
    case yrdkSequence:
    {
      yccfpPrint( fp, "/* OMN Extensions */\n");
      yccfpPrint( fp, "static %sTypeCode_ptr _typecode();\n", YCP_CORBA(ctx));
      break;
    }
    default:
      break;
  }
}


/* ----------------------------------------------------------------------- */
/*
 * yccpGenUnionMbrDecls - Generate accessors and mutators for a union field.
 *
 * This varies widely, depending upon the type of the field. Some types get
 * a mutator and a read-only accessor, others get a mutator and two accessors,
 * and strings get a whole flock. See below for details.
 */
STATICF void yccpGenUnionMbrDecls( ycctx* ctx, yccfp* fp, yrunmbr* mbr)
{
  yrobj* type;
  yrobj* base;
  yrdk base_kind;
  CONST char* tname;
  CONST char* kwdpfx = ((*ctx->lang->kwdchk)( ctx, mbr->name) ? "_" : "");

  type = mbr->type;
  if ( yrGetKind(type) == yrdkAlias )
    base = yrGetAliasBaseType( type);
  else
    base = type;
  base_kind = yrGetKind( base);
  tname = yccpTypeName( ctx, type);

  for (;;)                    /* will loop for primitives */
  {
    switch (base_kind)
    {
      case yrdkInterface:
          /*
           * void N( T_ptr);
           * T_ptr N() const;
           */
        yccfpPrint( fp, "void %s%s( %s_ptr);\n", kwdpfx, mbr->name, tname);
        yccfpPrint( fp, "%s_ptr %s%s() const;\n\n", tname, kwdpfx, mbr->name);
        return;
      case yrdkEnum:
          /*
           * void N( T);
           * T N() const;
           */
        yccfpPrint( fp, "void %s%s( %s);\n", kwdpfx, mbr->name, tname);
        yccfpPrint( fp, "%s %s%s() const;\n\n", tname, kwdpfx, mbr->name);
        return;
      case yrdkStruct:
      case yrdkUnion:
      case yrdkException:
      case yrdkSequence:
          /*
           * void N( const T&);
           * T& N();
           * const T& N() const;
           */
        yccfpPrint( fp, "void %s%s( const %s&);\n", kwdpfx, mbr->name, tname);
        yccfpPrint( fp, "%s& %s%s();\n", tname, kwdpfx, mbr->name);
        yccfpPrint( fp, "const %s& %s%s() const;\n\n", 
                    tname, kwdpfx, mbr->name);
        return;
      case yrdkArray:
          /*
           * void N(T);
           * T_slice* N() const;
           */
        yccfpPrint( fp, "void %s%s( %s);\n", kwdpfx, mbr->name, tname);
        yccfpPrint( fp, "%s_slice* %s%s() const;\n\n", 
                    tname, kwdpfx, mbr->name);
        return;
      case yrdkString:
          /*
           * void N( char*);
           * void N( const char*);
           * void N( const CORBA::String_var&);
           * const char* N() const;
           */
        yccfpPrint( fp, "void %s%s( char*);\n", kwdpfx, mbr->name);
        yccfpPrint( fp, "void %s%s( const char*);\n", kwdpfx, mbr->name);
        yccfpPrint( fp, "void %s%s( const %sString_var&);\n",
                    kwdpfx, mbr->name, YCP_CORBA(ctx));
        yccfpPrint( fp, "const char* %s%s() const;\n\n", kwdpfx, mbr->name);
        return;
      case yrdkPrimitive:
          /*
           * For most types, it's just like enums:
           *  void N(T);
           *  T N() const;
           * For strings, see yrdkString. For TypeCode, see yrdkInterface.
           * For Any, see yrdkStruct.
           */
        switch (yrPrimData(base).kind)
        {
          case yrpkstring:
            base_kind = yrdkString;
            break;
          case yrpkTypeCode:
            base_kind = yrdkInterface;
            break;
          case yrpkany:
            base_kind = yrdkStruct;
            break;
          default:
            base_kind = yrdkEnum;
            break;
        }
        break;
      default:
        yseThrow(YC_EX_FAILURE);
        break;
    }
  }
}



/* ----------------------------------------------------------------------- */
/*
 * yccpGenDeferredDecls - On scope exit, generate code for deferred objects
 *
 * This is moderately vile, but will do for now. Some things (currently
 * only Any inserters/extractors, but eventually perhaps typecodes) cannot
 * be generated in the same scope as their associated type because the
 * type can appear at class scope, but it's adjuncts cannot be class
 * members.
 *
 * For example, the Any <<= and >>= operators can never be member funcs
 * because (a) making them non-static member functions of the enclosing
 * class would be ridiculous, and (b) C++ says they cannot be static 
 * member functions. So, if they're generated for a type that is inside
 * class scope (such as a struct, union, exception, or enum type in
 * interface scope), code generation is deferred until we pop out to
 * file or module scope, at which point this function gets called with
 * all the deferred objects.
 */

STATICF void yccpGenDeferredDecls( ycctx* ctx, yccfp* fp, yslst* deferred)
{
  ysle* le;

  for ( le = ysLstHead(deferred); le; le = ysLstNext(le))
  {
    yrobj* obj = (yrobj*) ysLstVal(le);
/* @@ */
    switch (yrGetKind(obj))
    {
      case yrdkStruct:
      case yrdkUnion:
      case yrdkEnum:
        yccpGenAnyFuncs( ctx, fp, obj, FALSE);
        break;
      default:         /* @@ */
        break;
    }
  }
}
