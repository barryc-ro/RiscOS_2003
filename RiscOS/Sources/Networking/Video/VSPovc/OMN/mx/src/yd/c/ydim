/* Copyright (c) Oracle Corporation 1995.  All Rights Reserved. */

/*
 NAME
   ydim.c
 DESCRIPTION
   YD Orb Daemon Implementation Repository.

   This provides the implementation repository defined in ydidl.idl.
   This consists of these major types of data, with various indexed
   access paths:

   (1) Implementation info.  We keep a tree of ydim_info structures,
       keyed on the intf/impl/host.  Lookups with partial keys
       are allowed.  Each node in the tree is also a first-class object.

       The path is NOT considered, nor are the arguments part of the key.

   (2) ActiveImpl info.  We keep ydim_active objects with
       ydyo_activeInfo attributes.  Behind these we (a) maintain a
       list of active impls in ydim_info objects; (b) two trees
       containing identical data describing the process and the
       active implementations it contains.  One tree is keyed on the
       yort or the process, the other by process host/pid/affinity.

    (3) Registry of yorts.  Server processes announce themselves when
       they do a yoImplReady.

    (4)	Exclusive claims to "property".  The IMRs conspire to maintain
	an identical replicated database of entires defining exclusive
	rights to "properties".  Properties are keyed by a string, and
	have a user-defined attached object reference.  Each granted
	claim is bound to an owner; if the owner dies, the claim is
	abandoned.

   Info, ActiveInfo, and other things are propagated from orbd to
   orbd by flooding from the daemon that receives a "global" request.

 PUBLIC FUNCTIONS

   -- vanilla functions

   ydimInit
   ydimTerm

   -- object methods

   void ydim_imr_addInfoLocal_i( ydim_imr or, ydim_info* info,
			    ydim_info* infoObj);

   void ydim_imr_addInfoGlobal_i( ydim_imr or, ydim_info* info,
			     ydim_info* infoObj);

   void ydim_imr_destroyInfoLocal_i( ydim_imr or, ydim_info* info);

   void ydim_imr_destroyInfoGlobal_i( ydim_imr or, ydim_info* info);

   void ydim_imr_destroyYortLocal_i( ydim_imr or, yort_proc yort);

   void ydim_imr_addActiveLocal_i( ydim_imr or, yort_procInfo* pinfo,
			      ydyo_activeInfoList* list);

   void ydim_imr_addActiveGlobal_i( ydim_imr or, yort_procInfo* pinfo,
			       ydyo_activeInfoList* list);

   void ydim_imr_destroyActiveLocal_i( ydim_imr or,
				  ydyo_activeInfoList* list);

   void ydim_imr_destroyActiveGlobal_i( ydim_imr or,
				   ydyo_activeInfoList* list);

   void ydim_imr_destroyYortGlobal_i( ydim_imr or, yort_proc yort);

   yort_proc ydim_imr_yortOfProc_i( ydim_imr or, char* host, char* pid,
			   char* affinity);

   boolean ydim_imr_procOfYort_i( ydim_imr or, yort_proc y,
			     yort_procInfo* pinfo);

   boolean ydim_imr_activeOfYort_i( ydim_imr or, yort_proc yort,
			       ydim_activeList* list);

   void ydim_imr_listImpl_i( ydim_imr or, sb4 count, char* intf,
			char* impl,
			char* host, ydim_infoList* list,
			ydim_infoIterator* ii);

   void ydim_imr_listYort_i( ydim_imr or, sb4 count,
			CONST yort_proc yort,
			ydim_yortList* ylist, ydim_yortIterator* ii);

  ydim_info ydim_info_info__get_info_i( ydim_info or);

   void ydim_info_destroyLocal_i( ydim_info or);

   void ydim_info_destroyGlobal_i( ydim_info or);

   ydyo_activeInfo ydim_active__get_ainfo_i( ydim_active or);

   void ydim_active_destroyLocal_i( ydim_active or);

   void ydim_active_destroyGlobal_i( ydim_active or);

   boolean ydim_infoIterator_next_one_i( ydim_infoIterator or,
				   ydim_implInfo* info);

   boolean ydim_infoIterator_next_n_i( ydim_infoIterator or, ub4 count,
				 ydim_infoList* list);

   void ydim_infoIterator_destroy_i( ydim_infoIterator or);

   boolean ydim_yortIterator_next_one_i( ydim_yortIterator or,
				       yort* yort);

   boolean ydim_yortIterator_next_n_i( ydim_yortIterator or,
				     ub4 count, ydim_yortList* list);

   void ydim_yortIterator_destroy_i( ydim_yortIterator or);

 PRIVATE FUNCTIONS

   STATICF void ydimObjReleaseDispose( dvoid *o );
   STATICF sword ydimIImplCmp( CONST dvoid *a, CONST dvoid *b );
   STATICF sword ydimIIIHWCmp( CONST dvoid *a, CONST dvoid *b );
   STATICF void ydimInitInfo( ydim_implInfo *info );
   STATICF void ydimPutGlobal( CONST ydim_imr or, CONST dvoid *obj,
			      ydimGlobalFunc f, CONST char *name );
   STATICF void ydimPutInfo(CONST ydim_imr self, CONST ydim_imr o,
			   CONST dvoid *usrp );
   STATICF void ydimDelInfo(CONST ydim_imr self, CONST ydim_imr o,
			   CONST dvoid *usrp );
   STATICF void ydimPutActive(CONST ydim_imr self, CONST ydim_imr o,
			   CONST dvoid *usrp );
   STATICF void ydimDelActive(CONST ydim_imr self, CONST ydim_imr o,
			   CONST dvoid *usrp );
   STATICF void ydimDelYort(CONST ydim_imr self, CONST ydim_imr o,
			   CONST dvoid *usrp );

   STATICF sword ydimYYortCmp( CONST dvoid *a, CONST dvoid *b );
   STATICF sword ydimYProcCmp( CONST dvoid *a, CONST dvoid *b );
   STATICF void ydimKeySet( ydim_implInfo *dest, ydim_implInfo *src );
   STATICF void ydimAddToInfoActive( ydim_info *o, ydyo_activeInfo *ainfo );
   STATICF ydimy *ydimAddYort( ydimcx *cx, yort_procInfo *pinfo );
   STATICF ysspNode *ydimLookup( dvoid *key, ysspTree *t, ysspCmpFunc cmp );
   STATICF ysspNode *ydimFirstLookup( dvoid *key, ysspTree *t,
				     ysspCmpFunc cmp );
   STATICF ydim_active ydimGetActive( ydimcx *cx, ydyo_activeInfo *ainfo );

 NOTES

   SCALABILITY

       The flooding algorithms for propagating global entries could
       be made more responsive to the initial global caller by
       queueing the remote requests for delivery after-the-fact.
       This could be done either by having another method here with
       consumed new requests, or by creating another implementation
       queue to be consumed by another, lower-priority thread.

 MODIFIED   (MM/DD/YY)
    dbrower 07/18/95 - created.
    dbrower   02/14/96 -  Do PutGlobal stuff syncronously.
    dbrower   02/22/96 -  many performance changes; do putglobal async
			  until we have threads; otherwise we deadlock.
    dbrower   02/23/96 -  more perf changes; keep local ucnt instead
			    of requiring ydmt metric for everything.
    dbrower   02/26/96 -  move ucnt to ydimain; make that shared between
			    ydim and ydrt.
    dbrower   02/27/96 -  Change startup sync completely; create new
			  sync-done object, then tell other orbds to
			  start sending.  This reduces the memory needed
			  on both ends to marshall the IMR info, since
			  the real server can chunk it up.  This also
			  lets us use the same interfaces for all
			  replication operations.

			  Also adjust logging levels.
    dbrower   02/28/96 -  Change ysid intf to string intf.
    dbrower   03/14/96 -  remove redundant yort_ydimy; dupe launched yort
			  correctly.
    dbrower   05/17/96 -  fix bug 366675, "CONST type or" in _i funcs
    dbrower   05/23/96 -  Add claim/abandon interfaces.  Remove ResHost
			  stuff.  Rename listHost to listImpl.
    dbrower   06/ 4/96 -  Add startup sync for claim/abandon; formalize
			  the state machine for sync processing.  Have
			  update _i routines block if sync process is
			  active.  This will give syncing-orbd a consistant
			  snapshot of the IMR+claims when the sync started.
			  Remove retries in global updates; bogus concept.
    dbrower   06/ 7/96 -  have listClaim take regexp filter.
    dbrower   06/10/96 -  add listProperties and propertyResolve.
    dbrower   06/18/96 -  convert to ysRecord.
    dbrower   07/ 3/96 -  change claim/abandon to use yoevts.
    dbrower   07/30/96 -  add launch lock.
    dbrower   01/14/97 -  change ydim_imr_exists_i to make sure the impls
			  aren't suspended. 
*/

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YDYOIDL_ORACLE
#include <ydyoidl.h>
#endif
#ifndef YDIDL_IDL
#include <ydidl.h>
#endif
#ifndef YDIDLI_ORACLE
#include <ydidlI.h>
#endif
#ifndef YOSTD_ORACLE
#include <yostd.h>
#endif
#ifndef YSV_ORACLE
#include <ysv.h>
#endif
#ifndef YDIM_ORACLE
#include <ydim.h>
#endif
#ifndef YDSP_ORACLE
#include <ydsp.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif
#ifndef YOCOA_ORACLE
#include <yocoa.h>
#endif
#ifndef YDU_ORACLE
#include <ydu.h>
#endif
#ifndef YSSP_ORACLE
#include <yssp.h>
#endif
#ifndef YOYD_ORACLE
#include <yoyd.h>
#endif
#ifndef YSR_ORACLE
#include <ysr.h>
#endif
#ifndef YDQ_ORACLE
#include <ydq.h>
#endif
#ifndef YSSTR_ORACLE
#include <ysstr.h>
#endif
#ifndef YDCA_ORACLE
#include <ydca.h>
#endif
#ifndef YSMSC_ORACLE
#include <ysmsc.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif

/* PRIVATE TYPES AND CONSTANTS */

/* default chunk size for internal list ops */
#define YDIM_CHUNK_SIZE	    ((sb4)100)

#define YDIM_FAC	    "YDIM"

/* typedef forward decls */

typedef struct ydimcx	ydimcx;
typedef struct ydimln	ydimln;
typedef struct ydimn	ydimn;
typedef struct ydimy	ydimy;
typedef struct ydima	ydima;
typedef struct ydimso	ydimso;
typedef struct ydimsp	ydimsp;
typedef struct ydimicx	ydimicx;
typedef struct ydimcicx	ydimcicx;
typedef struct ydimyicx	ydimyicx;
typedef struct ydimghcx	ydimghcx;

externdef ysmtagDecl(ydimcx_tag) = "ydimcx";
externdef ysmtagDecl(ydimln_tag) = "ydimln";
externdef ysmtagDecl(ydimn_tag) = "ydimn";
externdef ysmtagDecl(ydimain_tag) = "ydimain";
externdef ysmtagDecl(ydimy_tag) = "ydimy";
externdef ysmtagDecl(ydima_tag) = "ydima";
externdef ysmtagDecl(ydimso_tag) = "ydimso";
externdef ysmtagDecl(ydimsp_tag) = "ydimsp";
externdef ysmtagDecl(ydimicx_tag) = "ydimicx";
externdef ysmtagDecl(ydimyicx_tag) = "ydimyicx";
externdef ysmtagDecl(ydimcicx_tag) = "ydimcicx";
externdef ysmtagDecl(ydimghcx_tag) = "ydimghcx";

/* launch node in ltree_ydimcx */
struct ydimln
{
 ysspNode	ydimln_spnode;
 ydimcx	*cx_ydimln;	/* for backtracking */

 char		*host_ydimln;
 char		*path_ydimln;
 yostd_stringList args_ydimln;

 ysstr		*lock_ydimln;	/* launch lock string */

 /* when launching */
 yslst		    *rlist_ydimln; /* list of requests */

 /* When we create launching impls, they go on ilist, and move
    to alist as disposition is determined.  On timeout, ilist
    entries are inactive and requests must be rejected. */

 yslst		    *ilist_ydimln; /* list of requested impls */
 yslst		    *alist_ydimln; /* list of ones gone active  */

 dvoid		    *usrp_ydimln; /* usrp to use */
 ydimRdyFunc	    rdy_ydimln; /* function to drive */
 ysevt		    *evt_ydimln; /* timeout event */
};

/* impl node in itree_ydimcx */
struct ydimn
{
 /* impl node - key is intf/impl/host ; partial leading keys
    may be used to do lookups with ydimIxxxCmp functions given
    to ydimLookup() and ydimFirstLookup() */

 ysspNode	inode_ydimn;
 ydim_implInfo  info_ydimn;	/* the info */
 ydimln		*launch_ydimn;	/* launch stuff */
 ysspTree	otree_ydimn;	/* alist stuff, as tree. */
 boolean	update_ydimn;	/* alist in info needs to be updated. */
};

/* known yort.  node in ptree_ydimcx and ytree_ydimcx, processes and yorts */
struct ydimy
{
 ysspNode	    ynode_ydimy;    /* key points to ydimy, key pinfo->yort */
 ysspNode	    pnode_ydimy;    /* key points to ydimy */
 yort_procInfo	    pinfo_ydimy;    /* proc info, host/pid/aff key in ptree */
 ysspTree	    otree_ydimy;    /* alist info, as tree */
 ysevt		    *devt_ydimy;    /* deathwatch event */
 ydimcx		    *cx_ydimy;
};

/* context for info iterator */
struct ydimicx
{
 ysle		*le_ydimicx;
 ydim_infoIterator self_ydimicx;
 boolean	first_ydimicx;	    /* got first data yet?  */
 ydim_implInfo	kinfo_ydimicx;	    /* init key info, if needed */
 ydim_implInfo	info_ydimicx;	    /* context key info, if needed */
 char		*host_ydimicx;	    /* host restriction */
};

/* context for yort iterator */
struct ydimyicx
{
 ysle	    *le_ydimyicx;
 ydim_yortIterator self_ydimyicx;
 boolean    first_ydimyicx;	/* got first data yet? */
 yort_proc  yort_ydimyicx;	/* yort key */
};

/* context for claim iterator */
struct ydimcicx
{
  ysle	    *le_ydimcicx;
  ydim_claimIterator self_ydimcicx;
  yort_claim	filter_ydimcicx; /* user filter */
  ysre		*re_ydimcicx;	/* filter.property, compiled */
  yort_claim	cursor_ydimcicx; /* where we are in scan */
  boolean	first_ydimcicx;	/* is cursor set? */
};

/* argument with active data to propagate thru ydimPutGlobal */
struct ydima
{
 yort_procInfo	        *pinfo_ydima;
 ydyo_activeInfoList    *alist_ydima;
};

/* context of a sync object */
struct ydimso
{
  ydim_sync self_ydimso;
  ydimSyncFunc	hdlr_ydimso;
  dvoid	    *usrp_ydimso;	/* handler */
  sb4	    cnt_ydimso;		/* count of decrements needed. */
};

/* sync proc -- serving a ydim_imr_startSync request  */
struct ydimsp
{
  ydim_imr  dest_ydimsp;	/* destination ydim_imr */
  ydim_sync whenDone_ydimsp;	/* his reply sync object to decrement */
  enum
  {
    sendInfo_ydimsp,		/* sending info */
    sendActive_ydimsp,		/* sending activeInfo */
    sendTry_ydimsp,		/* sending claim try */
    sendCommit_ydimsp,		/* sending claim commit */
    sendRep_ydimsp,		/* sending a reply */
    repComp_ydimsp		/* delete when completed. */
  } state_ydimsp;
  ysevt	    *evt_ydimsp;	/* current event; kept, must be nuked */

  ydim_info outobj_ydimsp;	/* from addInfoLocal, when sending info */
  ydim_implInfo ikey_ydimsp;
  yort_proc ykey_ydimsp;	/* current proc, 0 to start */
  yort_claim claim_ydimsp;	/* current claim, NULL property to start */
  ysevt	    *devt_ydimsp;	/* deathwatch on dest event */
  ysevt	    *gsem_ydimsp;	/* global sem for ydimSyncWait. */
  yoenv	    env_ydimsp;		/* the env to use for this dest. */
  ydimcx    *cx_ydimsp;
};

/* context for the ydim, state of ydim_imr object */
struct ydimcx
{
 ydim_imr	self_ydimcx;
 ydmt_imtr	mt_ydimcx;	/* admin module */
 ydsp_spawner	sp_ydimcx;	/* sp to addExisting to... */
 yort_proc	yort_ydimcx;	/* self */

 ysque	    *q_ydimcx;		/* queue we're on, or NULL */
 yoenv	    ev_ydimcx;		/* call env, when in synchronous mainline */

 ydcacx	    *cacx_ydimcx;	/* ydca context */

 /* tree of ydimn objects -- the implementation table */
 ysspTree  itree_ydimcx;	/* key intf,impl */

 /* tree of ydimln launch objects */
 ysspTree  ltree_ydimcx;

 /* tree of active impls */
 ysspTree  atree_ydimcx;	/* key intf,impl,yort */

 /* trees of ydimy objects */
 ysspTree  ytree_ydimcx;	/* tree of known yorts */
 ysspTree  ptree_ydimcx;	/* tree of known procs */

 sb4	    chunk_ydimcx;	/* chunk size for block ops */

 yslst	    *iis_ydimcx;	/* info iterators */
 yslst	    *yis_ydimcx;	/* yort iterators */
 yslst	    *cis_ydimcx;	/* claim iterators */
 ydimso	    *so_ydimcx;		/* sync object */
 ydimsp	    *asp_ydimcx;	/* the single active sync proc */
};

typedef void (*ydimGlobalFunc)( CONST ydim_imr place,
			      CONST dvoid *usrp, yoenv *ev, ydimghcx *gh );

/* structure given to complete async ydimPutGlobal operations */
struct ydimghcx
{
 ydimcx    *ydimcx_ydimghcx;	/* global context */
 dvoid	    *obj_ydimghcx;	/* object handed to ydimPutGlobal */
 dvoid	    *outobj_ydimghcx;	/* place for output object */
 CONST char *name_ydimghcx;	/* function name, for tracing */
 ydim_imr   dest_ydimghcx;	/* target of operation. */
 yoenv	    ev_ydimghcx;	/* the environment for the send */
 ysevt	    *evt_ydimghcx;	/* async event, or NULL */

 ydimGlobalFunc    func_ydimghcx; /* function called. */
};

/* PRIVATE FUNCTION DECLARATIONS */

STATICF void ydimObjReleaseDispose( dvoid *o );

/* ydim_info, compare complete key: intf/impl/host */
STATICF sword ydimIImplCmp( CONST dvoid *a, CONST dvoid *b );

/* ydyo_activeInfo, compare intf,impl,yort */
STATICF sword ydimAICmp( CONST dvoid *a, CONST dvoid *b );

/* ydim_infos, intf, impl, host; null matches any */
STATICF sword ydimIIIHWCmp( CONST dvoid *a, CONST dvoid *b );


STATICF void ydimInitInfo( ydim_implInfo *info );
STATICF void ydimInitAinfo( ydyo_activeInfo *ainfo, ydim_implInfo *info );

STATICF void ydimPutGlobal( CONST ydim_imr or, CONST dvoid *obj,
			  CONST ydimGlobalFunc f, CONST char *name );

STATICF void ydimGlobalHandler(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			       size_t argsz);

STATICF void ydimYortDeath(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			   size_t argsz);

/* ydimGlobalFuncs to hand to ydimPutGlobal */
STATICF void ydimPutInfo(CONST ydim_imr dest,
			CONST dvoid *usrp,
			yoenv *ev, ydimghcx *gh);
STATICF void ydimDelInfo(CONST ydim_imr dest,
			CONST dvoid *usrp,
			yoenv *ev, ydimghcx *gh);
STATICF void ydimPutActive(CONST ydim_imr dest,
			  CONST dvoid *usrp,
			  yoenv *ev, ydimghcx *gh);
STATICF void ydimDelActive(CONST ydim_imr dest,
			  CONST dvoid *usrp,
			  yoenv *ev, ydimghcx *gh);
STATICF void ydimDelYort(CONST ydim_imr dest,
			CONST dvoid *usrp,
			yoenv *ev, ydimghcx *gh);

STATICF sword ydimYYortCmp( CONST dvoid *a, CONST dvoid *b );
STATICF sword ydimYProcCmp( CONST dvoid *a, CONST dvoid *b );

STATICF void ydimKeySet( ydim_implInfo *dest, ydim_implInfo *src );

STATICF ydimy *ydimAddYort( ydimcx *cx, yort_procInfo *pinfo );

STATICF ydimln *ydimAddLaunch( ydimcx *cx, ydim_implInfo *info );
STATICF void ydimFreeLaunch( ydimln *ln );
STATICF void  ydimLaunchActive( ydimcx *cx, ydimain *ain );
STATICF void ydimLaunchTimeout(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			      size_t argsz);
STATICF void ydimLaunchCheck( ydimln *ln );


STATICF ysspNode *ydimLookup( dvoid *key, ysspTree *t, ysspCmpFunc cmp );
STATICF ysspNode *ydimFirstLookup(dvoid *key, ysspTree *t, ysspCmpFunc cmp);

STATICF ydim_active ydimGetActive( ydimcx *cx, ydyo_activeInfo *ainfo );

STATICF void ydimAddActiveToAlist( ydim_activeList *alist, ydim_active ai );
STATICF void ydimAddObjToTree( ysspTree *otree, dvoid *or );
STATICF void ydimDelObjFromOtree(ysspTree *otree, dvoid *or );
STATICF void ydimDestroyOtree( ysspTree *ht );
STATICF void ydimOtreeToAlist( ysspTree *otree, ydim_activeList *alist,
			      ysmaf af, ysmff ff  );
STATICF void ydimAlistToOtree( ydim_activeList *alist, ysspTree *otree );
STATICF void ydimUpdateAlist( ydimn *on );

STATICF ub4 ysspTreeCount( ysspTree *h );

STATICF sword ydimStringListCmp( CONST dvoid *a, CONST dvoid *b );
STATICF sword ydimLaunchCmp( CONST dvoid *a, CONST dvoid *b );

STATICF yort_procInfo *ydimPInfoOfYort( ydimcx *cx, yort_proc y );

STATICF void ydimDestroyII( dvoid *x );
STATICF void ydimDestroyCI( dvoid *x );
STATICF void ydimDestroyYI( dvoid *x );

STATICF void ydimSyncComplete( dvoid *usrp, CONST ysid *exid,
			      dvoid *argp, size_t argsz );
STATICF void ydimSyncInfo( ydimsp *sp );
STATICF void ydimSyncActive( ydimsp *sp );
STATICF void ydimSyncTry( ydimsp *sp );
STATICF void ydimSyncReply( ydimsp *sp );
STATICF void ydimSyncWait( ydimcx *cx );
STATICF void ydimSyncDeath( dvoid *usrp, CONST ysid *exid,
			   dvoid *argp, size_t argsz );

/* ydyo methods */

externdef ysidDecl(YDIM_EX_INTERNAL) = "ydim::internal";

static CONST_W_PTR struct ydim_imr__tyimpl ydim_imr__impl =
 {
  ydim_imr_addInfoLocal_i,
  ydim_imr_addInfoGlobal_i,
  ydim_imr_destroyInfoLocal_i,
  ydim_imr_destroyInfoGlobal_i,
  ydim_imr_addActiveLocal_i,
  ydim_imr_destroyActiveLocal_i,
  ydim_imr_destroyYortLocal_i,
  ydim_imr_yortOfProc_i,
  ydim_imr_procOfYort_i,
  ydim_imr_activeOfYort_i,
  ydim_imr_listImpl_i,
  ydim_imr_listYort_i,
  ydim_imr_createSync_i,
  ydim_imr_startSync_i,
  ydim_imr_abandonFor_i,
  ydim_imr_transfer_i,
  ydim_imr_tryStake_i,
  ydim_imr_transferStake_i,
  ydim_imr_commitStake_i,
  ydim_imr_abortStake_i,
  ydim_imr_listClaim_i,
  ydim_imr__get_self_i,
  ydim_imr__get_mt_i,
  ydim_imr__get_plist_i,
  ydim_imr_addActiveGlobal_i,
  ydim_imr_destroyActiveGlobal_i,
  ydim_imr_destroyYortGlobal_i,
  ydim_imr_exists_i,
  ydim_imr_stake_i,
  ydim_imr_abandon_i,
  ydim_imr_listProperties_i,
  ydim_imr_propertyResolve_i
 };

static CONST_W_PTR struct ydim_info__tyimpl ydim_info__impl =
{
 ydim_info_destroyLocal_i,
 ydim_info_destroyGlobal_i,
 ydim_info__get_info_i
};

static CONST_W_PTR struct ydim_active__tyimpl ydim_active__impl =
{
 ydim_active_destroyLocal_i,
 ydim_active_destroyGlobal_i,
 ydim_active__get_ainfo_i
};

static CONST_W_PTR struct ydim_infoIterator__tyimpl ydim_infoIterator__impl =
 {
  ydim_infoIterator_next_one_i,
  ydim_infoIterator_next_n_i,
  ydim_infoIterator_destroy_i
 };

static CONST_W_PTR struct ydim_yortIterator__tyimpl ydim_yortIterator__impl =
 {
  ydim_yortIterator_next_one_i,
  ydim_yortIterator_next_n_i,
  ydim_yortIterator_destroy_i
 };


static CONST_W_PTR struct ydim_sync__tyimpl ydim_sync__impl =
 {
  ydim_sync_decrement_i,
  ydim_sync_destroy_i,
 };

static CONST_W_PTR struct ydim_claimIterator__tyimpl ydim_claimIterator__impl =
 {
  ydim_claimIterator_next_one_i,
  ydim_claimIterator_next_n_i,
  ydim_claimIterator_destroy_i
 };


/* PUBLIC FUNCTIONS */

/* ---------------------------------------------------------------- */

/* initialize the implementation  */
void ydimInit( ysque *imq, ydim_imr *oydim_imr )
{
  ydimcx *cx = (ydimcx*)ysmGlbAlloc( sizeof(*cx), ydimcx_tag );
  char	*arg;

  cx->q_ydimcx = imq;
  cx->mt_ydimcx = (ydmt_imtr)0;
  cx->sp_ydimcx = (ydsp_spawner)0;
  yoEnvInit( &cx->ev_ydimcx );

  DISCARD ysspNewTree( &cx->itree_ydimcx, ydimIImplCmp );
  DISCARD ysspNewTree( &cx->ltree_ydimcx, ydimLaunchCmp );
  DISCARD ysspNewTree( &cx->atree_ydimcx, ydimAICmp );
  DISCARD ysspNewTree( &cx->ytree_ydimcx, ydimYYortCmp );
  DISCARD ysspNewTree( &cx->ptree_ydimcx, ydimYProcCmp );

  cx->iis_ydimcx = ysLstCreate();
  cx->cis_ydimcx = ysLstCreate();
  cx->yis_ydimcx = ysLstCreate();
  cx->so_ydimcx = (ydimso*)0;
  cx->asp_ydimcx = (ydimsp*)0;

  cx->cacx_ydimcx = ydcaInit( imq );

  /* start implementation(s) */
  yoSetImpl( ydim_imr__id, (char*)0, ydim_imr__stubs,
	    (dvoid*)&ydim_imr__impl, (yoload)0, TRUE, (dvoid*)cx );

  yoSetImpl( ydim_info__id, (char*)0, (yostub*)ydim_info__stubs,
	    (dvoid*)&ydim_info__impl, (yoload)0, FALSE, (dvoid*)cx );
  yoSetImpl( ydim_sync__id, (char*)0, (yostub*)ydim_sync__stubs,
	    (dvoid*)&ydim_sync__impl, (yoload)0, FALSE, (dvoid*)cx );
  yoSetImpl( ydim_active__id, (char*)0, (yostub*)ydim_active__stubs,
	    (dvoid*)&ydim_active__impl, (yoload)0, FALSE, (dvoid*)cx );
  yoSetImpl( ydim_infoIterator__id, (char*)0,
	    ydim_infoIterator__stubs,
	    (dvoid*)&ydim_infoIterator__impl, (yoload)0, FALSE, (dvoid*)cx );
  yoSetImpl( ydim_yortIterator__id, (char*)0,
	    ydim_yortIterator__stubs,
	    (dvoid*)&ydim_yortIterator__impl, (yoload)0, FALSE, (dvoid*)cx );
  yoSetImpl( ydim_claimIterator__id, (char*)0,
	    ydim_claimIterator__stubs,
	    (dvoid*)&ydim_claimIterator__impl, (yoload)0, FALSE, (dvoid*)cx );

  /* make the ydim_imr object and keep back pointer */
  cx->self_ydimcx = (ydim_imr)yoCreate( ydim_imr__id, (char*)0,
				       (yoRefData*)0, (char *)0, (dvoid *)0);

  arg = ysResGetLast("ydim.chunksize");
  cx->chunk_ydimcx = arg ? atoi(arg) : YDIM_CHUNK_SIZE;
  if( cx->chunk_ydimcx <= 0 ) cx->chunk_ydimcx = 1;

  cx->yort_ydimcx = (yort_proc)yoYort();

  /* 1250, "ydimInit: implementation repository object started" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1250,YSLSEV_INFO,(char*)0, YSLNONE );

  *oydim_imr = (ydim_imr)yoDuplicate((dvoid*)cx->self_ydimcx);

  yoImplReady( ydim_imr__id, (char*)0, cx->q_ydimcx );
  yoImplReady( ydim_info__id, (char*)0, cx->q_ydimcx );
  yoImplReady( ydim_sync__id, (char*)0, cx->q_ydimcx );
  yoImplReady( ydim_active__id, (char*)0, cx->q_ydimcx );
  yoImplReady( ydim_infoIterator__id, (char*)0, cx->q_ydimcx );
  yoImplReady( ydim_yortIterator__id, (char*)0, cx->q_ydimcx );
  yoImplReady( ydim_claimIterator__id, (char*)0, cx->q_ydimcx );
}

STATICF void ydimDestroyII( dvoid *x )
{
  ydimicx *myii = (ydimicx*)x;

  ydim_implInfo__free( &myii->kinfo_ydimicx, yotkFreeStr);
  ydim_implInfo__free( &myii->info_ydimicx, yotkFreeStr);
  yduFreeCacheStr(myii->host_ydimicx);
  ydimObjReleaseDispose( (dvoid*)myii->self_ydimicx );
  ysmGlbFree( (dvoid*)myii );
}

STATICF void ydimDestroyCI( dvoid *x )
{
  ydimcicx *cix = (ydimcicx*)x;

  if( !cix->first_ydimcicx )
    yort_claim__free( &cix->cursor_ydimcicx, yotkFreeStr );
  yort_claim__free( &cix->filter_ydimcicx, yotkFreeStr );
  if( cix->re_ydimcicx )
    ysREFree( cix->re_ydimcicx );
  ydimObjReleaseDispose( (dvoid*)cix->self_ydimcicx );
  ysmGlbFree( (dvoid*)cix );
}

STATICF void ydimDestroyYI( dvoid *x )
{
  ydimyicx *myyi = (ydimyicx*)x;

  ydimObjReleaseDispose( (dvoid*)myyi->self_ydimyicx );
  if( myyi->yort_ydimyicx )
    yoRelease( (dvoid*)myyi->yort_ydimyicx );
  ysmGlbFree( (dvoid*)myyi );
}

void ydimTerm( ydim_imr imr )
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)imr);
  ysspNode  *n;			/* node */
  ydimy     *ytn;		/* ytree node */
  ydimn	    *itn;		/* itree node */
  ydimain   *ain;		/* atree node */
  yoenv	    ev;

  yoEnvInit(&ev);

  /* 1251, "ydimTerm: terminating imr objects" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1251,YSLSEV_INFO,(char*)0, YSLNONE );

  if( cx->mt_ydimcx )
    yoRelease( (dvoid*)cx->mt_ydimcx );
  if( cx->sp_ydimcx )
    yoRelease( (dvoid*)cx->sp_ydimcx );
  yoRelease( (dvoid*)cx->yort_ydimcx );

  yoImplDeactivate( ydim_infoIterator__id, (char*)0 );
  yoImplDeactivate( ydim_yortIterator__id, (char*)0 );
  yoImplDeactivate( ydim_claimIterator__id, (char*)0 );
  yoImplDeactivate( ydim_info__id, (char*)0 );
  yoImplDeactivate( ydim_sync__id, (char*)0 );
  yoImplDeactivate( ydim_imr__id, (char*)0 );

  ysLstDestroy( cx->cis_ydimcx, ydimDestroyCI );
  ysLstDestroy( cx->iis_ydimcx, ydimDestroyII );
  ysLstDestroy( cx->yis_ydimcx, ydimDestroyYI );

  if( cx->so_ydimcx )
  {
    /* EMPTY */;
    /* FIXME */
  }
  if( cx->asp_ydimcx )
  {
    /* EMPTY */;
    /* FIXME */
  }

  ydcaTerm( cx->cacx_ydimcx );

  yoImplDeactivate( ydim_yortIterator__id, (char*)0 );
  yoImplDeactivate( ydim_infoIterator__id, (char*)0 );

  while( (n = ysspDeqTree( &cx->ltree_ydimcx ) ) )
    ydimFreeLaunch( (ydimln*)n->key_ysspNode );

  /* remove refs to ydim_actives first from itree */
  while( (n = ysspDeqTree( &cx->itree_ydimcx ) ) )
  {
    itn = (ydimn*)n;
    ydimDestroyOtree( &itn->otree_ydimn );
    ydim_implInfo__free( &itn->info_ydimn, yotkFreeStr);
    yoDispose( (dvoid*)itn->info_ydimn.self_ydim_implInfo );
    ysmGlbFree( (dvoid*)itn );
  }

  /* then remove yorts, including ydim_active refs */
  while( (n = ysspDeqTree( &cx->ytree_ydimcx ) ) )
  {
    ytn = (ydimy*)n->key_ysspNode;
    /* ytree in parallel. */
    ysspRemove( &ytn->pnode_ydimy, &cx->ptree_ydimcx );

    /* stop deathwatch */
    ysEvtDestroy( ytn->devt_ydimy );
    yort_procInfo__free( &ytn->pinfo_ydimy, yotkFreeStr);
    ydimDestroyOtree( &ytn->otree_ydimy );
    ysmGlbFree( (dvoid*)ytn );
  }

  /* then remove actual ydim_actives in otree */
  while( ( n = ysspDeqTree( &cx->atree_ydimcx ) ) )
  {
    ain = (ydimain*)n;
    ydyo_activeInfo__free( &ain->ainfo_ydimain, yotkFreeStr);
    yoDispose( (dvoid*)ain->ainfo_ydimain.self_ydyo_activeInfo );
    ysmGlbFree( (dvoid*)ain );
  }

  yoEnvFree( &cx->ev_ydimcx );
  ydimObjReleaseDispose( (dvoid*)cx->self_ydimcx );
  ysmGlbFree( (dvoid*)cx );
  yoEnvFree(&ev);
}

void ydimSetRefs( ydim_imr imr, ydmt_imtr mt, ydsp_spawner sp )
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)imr);

  cx->mt_ydimcx = (ydmt_imtr)yoDuplicate( (dvoid*)mt );
  cx->sp_ydimcx = (ydsp_spawner)yoDuplicate( (dvoid*)sp );
}


/* ---------------------------------------------------------------- */
/* Launch hooks for ydrt */
/* ---------------------------------------------------------------- */

/* start a launch, with one element on the request list. */

yort_proc ydimStartLaunch( ydim_imr imr, ydim_implInfo *info, sysb8 *timeout,
			  dvoid *usrp, ydimRdyFunc rdy, dvoid *element )
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)imr);
  ysspNode  *n = ysspLookup( (dvoid*)info, &cx->itree_ydimcx );
  ydimln    *ln;
  ydimn	    *in;
  ydimain   *ain;
  ydyo_activeInfo fake;
  ydim_active a;

  /* 1252, "ydimStartLaunch: starting %s/%s h:%s", */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1252,YSLSEV_INFO,(char*)0,
	   YSLSTR(yduStr(info->intf_ydim_implInfo)),
	   YSLSTR(yduStr(info->impl_ydim_implInfo)),
	   YSLSTR(yduStr(info->host_ydim_implInfo)), YSLEND );

  in = (ydimn*)n;
  info = (ydim_implInfo*)n->key_ysspNode;
  ydimInitAinfo( &fake, info );
  ln = in->launch_ydimn;
  if( ln )			/* launchable */
  {
    if( !ln->rlist_ydimln )	/* not yet started. */
    {
      /* setup callbacks, start timeout timer */
      ln->usrp_ydimln = usrp;
      ln->rdy_ydimln = rdy;
      ln->rlist_ydimln = ysLstCreate();
      ln->ilist_ydimln = ysLstCreate();
      ln->alist_ydimln = ysLstCreate();

      /* for each intf with this launch record, add "launching" active */

      fake.yort_ydyo_activeInfo = (yort_proc)0;
      for( n = ysspFHead( &cx->itree_ydimcx ) ; n ; n = ysspFNext( n ) )
      {
	in = (ydimn*)n;
	if( in->launch_ydimn == ln )
	{
	  info = (ydim_implInfo*)n->key_ysspNode;
	  fake.intf_ydyo_activeInfo = info->intf_ydim_implInfo;
	  fake.impl_ydyo_activeInfo = info->impl_ydim_implInfo;
	  a = ydimGetActive( cx, &fake );
	  ydimAddActiveToAlist( &info->alist_ydim_implInfo, a );
	  ain = (ydimain*)yoGetState( (dvoid*)a );
	  /*CONSTCOND*/
	  ysmCheck( ain, ydimain_tag );
	  yoRelease( (dvoid*)a );

	  /* tack activeInfo onto the pending ilist */
	  DISCARD ysLstEnq( ln->ilist_ydimln, (dvoid*)&ain->ainfo_ydimain );

	  /* 1253, "ydimStartLaunch: add fake alist entry to %s/%s h:%s", */
	  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1253,YSLSEV_INFO,(char*)0,
		   YSLSTR(yduStr(info->intf_ydim_implInfo)),
		   YSLSTR(yduStr(info->impl_ydim_implInfo)),
		   YSLSTR(yduStr(info->host_ydim_implInfo)), YSLEND);
	}
      }
      DISCARD ysLstEnq( ln->rlist_ydimln, element );

      /* now start timeout going */
      ln->evt_ydimln =
	ysEvtCreate( ydimLaunchTimeout, (dvoid*)ln, (ysque*)0, TRUE );
      ysTimer( timeout, ln->evt_ydimln );
    }
  }
  else				/* not launchable? */
  {
    /* 1254, "ydimStartLaunch: %s/%s h:%s not launchable!?", */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1254,YSLSEV_EMERG,(char*)0,
	     YSLSTR(yduStr(info->intf_ydim_implInfo)),
	     YSLSTR(yduStr(info->impl_ydim_implInfo)),
	     YSLSTR(yduStr(info->host_ydim_implInfo)), YSLEND);
    ysePanic(YDIM_EX_INTERNAL);
  }

  /* 1255, "ydimStartLaunch: exit" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1255,YSLSEV_DEBUG(3),(char*)0, YSLNONE);

  return( (yort_proc)yoDuplicate((dvoid*)cx->self_ydimcx) );
}


/* add another request to the launching proc's list */
void ydimAppendLaunch( ydim_imr imr, ydim_implInfo *info, dvoid *element )
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)imr);
  ysspNode  *n;
  ydimln    *ln;
  ydimn	    *in;

  n = ysspLookup( (dvoid*)info, &cx->itree_ydimcx );
  in = (ydimn*)n;
  info = (ydim_implInfo*)n->key_ysspNode;

  /* 1256, "ydimAppendLaunch: adding request for %s/%s h:%s" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1256,YSLSEV_DEBUG(2),(char*)0,
	   YSLSTR(yduStr(info->intf_ydim_implInfo)),
	   YSLSTR(yduStr(info->impl_ydim_implInfo)),
	   YSLSTR(info->host_ydim_implInfo), YSLEND );

  /* ASSIGNOK */
  if( (ln = in->launch_ydimn) )
  {
    if( ln->rlist_ydimln )
      DISCARD ysLstEnq( ln->rlist_ydimln, element );
    else
    {
      /* 1257, "ydimAppendLaunch: no rlist!?" */
      ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1257,YSLSEV_EMERG,(char*)0, YSLNONE );
      ysePanic(YDIM_EX_INTERNAL);
    }
  }
}


boolean ydimIsLaunching( ydim_imr imr, yort_proc y )
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)imr);

  return( yoIsEq( (dvoid*)cx->self_ydimcx, (dvoid*)y ) );
}


/* ---------------------------------------------------------------- */
/* Routing performance hacks */
/* ---------------------------------------------------------------- */

ydimain *ydimActiveGetAinfo( CONST ydim_active or )
{
  ydimain   *ain = (ydimain*)yoGetState((dvoid *)or);
  return( ain );
}


void ydimActiveSetUsrp( CONST ydim_imr imr, yort_proc y,
		       char *intf, char *impl, dvoid *usrp )
{
  ydimcx *cx = (ydimcx*)yoGetImplState( (dvoid*)imr );
  ydyo_activeInfo    lainfo;
  ydimain *ain;

  lainfo.intf_ydyo_activeInfo = intf;
  lainfo.impl_ydyo_activeInfo = impl;
  lainfo.yort_ydyo_activeInfo = y;

  if( (ain = (ydimain*)ysspLookup( (dvoid *)&lainfo, &cx->atree_ydimcx ) ) )
    ain->usrp_ydimain = usrp;
}

yslst *ydimListImpl( yslst *lst, ydim_imr imr,
		    char *intf, char *impl, char *host )
{

  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)imr);

  ydim_implInfo  lookup;
  ysspNode  *n;

  lookup.intf_ydim_implInfo = intf;
  lookup.impl_ydim_implInfo = impl;
  lookup.host_ydim_implInfo = host;
  lookup.pathName_ydim_implInfo = (char*)0;

  n = ydimFirstLookup((dvoid*)&lookup, &cx->itree_ydimcx, ydimIIIHWCmp);
  while( n && !ydimIIIHWCmp( (dvoid*)&lookup, n->key_ysspNode ) )
  {
    ydimUpdateAlist( (ydimn*)n );
    DISCARD ysLstEnq( lst, n->key_ysspNode );
    n = ysspFNext( n );
  }
  return( lst );
}


/* ---------------------------------------------------------------- */
/* YDIM info Methods */
/* ---------------------------------------------------------------- */

/* ARGSUSED */
ydim_imr ydim_imr__get_self_i( ydim_imr or, yoenv *ev)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  return( (ydim_imr)yoDuplicate((dvoid*)cx->self_ydimcx) );
}

/* ARGSUSED */
ydmt_imtr ydim_imr__get_mt_i( ydim_imr or, yoenv *ev)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  return( (ydmt_imtr)yoDuplicate((dvoid*)cx->mt_ydimcx) );
}

/* object method */
/* ARGSUSED */
void ydim_imr_addInfoGlobal_i( ydim_imr or, yoenv *ev,
			      ydim_implInfo* info, ydim_info* infoObj)
{
  ysspNode  *n;
  ydim_implInfo  *o;
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  /* 1258, "ydim_imr_addInfoGlobal_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1258,YSLSEV_INFO,(char*)0, YSLNONE );

  /* send it everywhere, immediately; will send to self. */

  ydimPutGlobal( or, (dvoid *)info, (CONST ydimGlobalFunc)ydimPutInfo,
		"ydimPutInfo" );

  /* locate local object and set return value */
  if( (n = ysspLookup( (dvoid *)info, &cx->itree_ydimcx ) ) )
  {
    o = (ydim_implInfo*)n->key_ysspNode;
    *infoObj = (ydim_info)yoDuplicate((dvoid*)o->self_ydim_implInfo);
  }
  else
    *infoObj = (ydim_info)0;
}


/* object method */
/* ARGSUSED */
void ydim_imr_addInfoLocal_i( ydim_imr or, yoenv *ev,
			     ydim_implInfo* info, ydim_info* infoObj)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ysspNode  *n;			/* raw node */
  ydimn	    *on;		/* info tree node */
  ydim_implInfo  *infon;	/* info in node */
  ydyo_activeInfo ainfo;	/* fake for spawnable intf's */
  boolean   isnew;
  ydim_active	a;

  /* 1259, "ydim_imr_addInfoLocal_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1259,YSLSEV_INFO,(char*)0, YSLNONE );

  ydimSyncWait( cx );		/* wait for syncing orbd to complete */

  /* got old info with this key? */
  if( (n = ysspLookup( (dvoid *)info, &cx->itree_ydimcx ) ) )
  {
    on = (ydimn*)n;
    infon = (ydim_implInfo*)n->key_ysspNode; /* yes. */
    isnew = FALSE;
  }
  else				/* no. need to make new one */
  {
    isnew = TRUE;
    on = (ydimn*) ysmGlbAlloc( sizeof(*on), ydimn_tag );
    on->inode_ydimn.key_ysspNode = (dvoid *)(infon = &on->info_ydimn);
    on->launch_ydimn = (ydimln*)0;
    on->update_ydimn = TRUE;
    DISCARD ysspNewTree( &on->otree_ydimn, yoCmp );

    /* copy everything */
    ydim_implInfo__copy( infon, info, yotkAllocStr );
    ydimAlistToOtree( &info->alist_ydim_implInfo, &on->otree_ydimn );

    /* make the object and keep back pointer */
    infon->self_ydim_implInfo =
      (ydim_info)yoCreate( ydim_info__id, (char*)0,
			  (yoRefData*)0,
			  (char *)0, (dvoid *)infon);

    /* 1260, "ydim_imr_addInfoLocal_i: made ref" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1260,YSLSEV_DEBUG(4),(char*)0, YSLNONE);

    DISCARD ysspEnq( &on->inode_ydimn, &cx->itree_ydimcx );
  }

  /* update possibly changed values */

  infon->minInstances_ydim_implInfo = info->minInstances_ydim_implInfo;
  infon->maxInstances_ydim_implInfo = info->maxInstances_ydim_implInfo;

  /* if had old path, but we have new path, free old stuff  */
  if( !isnew && infon->pathName_ydim_implInfo && info->pathName_ydim_implInfo )
  {
    yostd_stringList__free(&infon->args_ydim_implInfo, yotkFreeStr);
  }

  /* need to save path  */
  if( !isnew && info->pathName_ydim_implInfo )
  {
    yduFreeCopyStr( &infon->pathName_ydim_implInfo,
		   info->pathName_ydim_implInfo, yotkFreeStr, yotkAllocStr );
    yostd_stringList__copy( &infon->args_ydim_implInfo,
			   &info->args_ydim_implInfo, yotkAllocStr );
  }

  /* if have path but no launch record, make one */
  if( info->pathName_ydim_implInfo && !on->launch_ydimn )
  {
    /* if spawnable, add launch entry and active with NULL yort */
    ydimInitAinfo( &ainfo, infon );
    a = ydimGetActive( cx, &ainfo );
    ydimAddObjToTree( &on->otree_ydimn, (dvoid*)a);
    on->update_ydimn = TRUE;
    on->launch_ydimn = ydimAddLaunch( cx, infon );
    yoRelease( (dvoid*)a );
  }

  /* leave active impls alone - only we know that */

  yostd_stringList__free( &infon->args_ydim_implInfo, yotkFreeStr);
  yostd_stringList__copy( &infon->args_ydim_implInfo,
			 &info->args_ydim_implInfo, yotkAllocStr );

  *infoObj = (ydim_info)yoDuplicate((dvoid*)infon->self_ydim_implInfo);
}

/* object method */
/* ARGSUSED */
void ydim_imr_destroyInfoLocal_i( ydim_imr or, yoenv *ev,
				 ydim_implInfo* info)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ysspNode  *n;
  ydim_implInfo  *ninfo;

  /* 1261, "ydim_imr_destroyInfoLocal_i: entry" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1261,YSLSEV_INFO,(char*)0, YSLNONE );

  ydimSyncWait( cx );		/* wait for syncing orbd to complete */

  /* got info with this key? */
  if( (n = ysspLookup( (dvoid *)info, &cx->itree_ydimcx ) ) )
  {
    /* yes.  delete it. */
    ninfo = (ydim_implInfo*)n->key_ysspNode;

    /* 1262, "ydim_imr_destroyInfoLocal_i: deleting ydim_imr" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1262,YSLSEV_INFO,(char*)0, YSLEND );

    ysspRemove( n, &cx->itree_ydimcx );
    ydim_implInfo__free( ninfo, yotkFreeStr);
    yoDispose( (dvoid*)ninfo->self_ydim_implInfo );
    ysmGlbFree( (dvoid *)n );
  }
}

/* object method */
/* ARGSUSED */
void ydim_imr_destroyInfoGlobal_i( ydim_imr or, yoenv *ev,
				  ydim_implInfo* info)
{
  /* 1263, "ydim_imr_destroyInfoGlobal_i: entry" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1263,YSLSEV_INFO,(char*)0, YSLNONE);

  ydimPutGlobal(or, (dvoid *)info, (CONST ydimGlobalFunc)ydimDelInfo,
		"ydimDelInfo");
}

/* ---------------------------------------------------------------- */
/* YDIM Active methods */
/* ---------------------------------------------------------------- */

/* object method */
/* ARGSUSED */
void ydim_imr_addActiveGlobal_i( ydim_imr or, yoenv *ev,
				yort_procInfo* pinfo,
				ydyo_activeInfoList* list)

{
  ydima	    arg;
  arg.pinfo_ydima = pinfo;
  arg.alist_ydima = list;

  /* 1264, "ydim_imr_addActiveGlobal_i: %s:%s:%s", */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1264,YSLSEV_INFO,(char*)0,
	   YSLSTR(pinfo->host_yort_procInfo),
	   YSLSTR(pinfo->pid_yort_procInfo),
	   YSLSTR(yduStr(pinfo->affinity_yort_procInfo)), YSLEND);

  /* send it everywhere, immediately */
  ydimPutGlobal(or,(dvoid*)&arg,(CONST ydimGlobalFunc)ydimPutActive,
		"ydimPutActive");
}


/* object method */
void ydim_imr_addActiveLocal_i( ydim_imr or, yoenv *ev,
			       yort_procInfo* pinfo,
			       ydyo_activeInfoList* list)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydim_active	a;

  ub4		i;		/* loop index */
  ysspNode	*n;		/* tree node */
  ydim_implInfo	*info;		/* info in node */
  ydim_implInfo	linfo;		/* local info for lookup proxy key */
  ydim_info	outobj;
  ydimn		*in;
  ydimy		*y;

  ydyo_activeInfo    *ainfo;

  /* 1265, "ydim_imr_addActiveLocal_i:"  */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1265,YSLSEV_INFO,(char*)0,YSLNONE );

  ydimSyncWait( cx );		/* wait for syncing orbd to complete */

  /* enter/lookup yort just once. */
  y = ydimAddYort( cx, pinfo );
  for( i = 0 ; i < list->_length ; i++ )
  {
    ainfo = &list->_buffer[i];

    /* do not add yorts, ever */

    if( !strcmp( ainfo->intf_ydyo_activeInfo, ysidToStr(yort_proc__id) ) )
      continue;

    ydimInitInfo( &linfo );
    linfo.intf_ydim_implInfo = ainfo->intf_ydyo_activeInfo;
    linfo.impl_ydim_implInfo = ainfo->impl_ydyo_activeInfo;
    linfo.host_ydim_implInfo = pinfo->host_yort_procInfo;

    /* got any info for this intf/impl/host? */
    if((n = ydimFirstLookup((dvoid*)&linfo, &cx->itree_ydimcx,
			    ydimIIIHWCmp)))
    {
      /* yes, this is the object */
      in = (ydimn*)n;
      info = (ydim_implInfo *)n->key_ysspNode;
    }
    else
    {
      /* no, add it now with empty path, and get back ptr to it */
      ydim_imr_addInfoLocal_i( or, ev, &linfo, &outobj );
      info = (ydim_implInfo *)yoGetState( (dvoid *)outobj );
      in = (ydimn*)ysspLookup( (dvoid*)info, &cx->itree_ydimcx );
      yoRelease( (dvoid*)outobj );
    }

    a = ydimGetActive( cx, ainfo );
    ydimAddObjToTree( &y->otree_ydimy, (dvoid*)a );
    ydimAddObjToTree( &in->otree_ydimn, (dvoid*)a );
    in->update_ydimn = TRUE;
    yoRelease( (dvoid*)a );
  }
}

/* object method */
/* ARGSUSED */
void ydim_imr_destroyActiveLocal_i( ydim_imr or, yoenv *ev,
				   ydyo_activeInfoList* list)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  ub4	    i;			/* loop index */
  ysspNode  *n;			/* tree node */
  ydimn	    *on;
  ydim_implInfo  linfo;
  ydyo_activeInfo    *ainfo;
  ydimy	    lookup;
  yort_proc y = (yort_proc)0;
  ydim_active	a;

  /* 1266, "ydim_imr_destroyActiveLocal_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1266,YSLSEV_INFO,(char*)0, YSLNONE );

  ydimSyncWait( cx );		/* wait for syncing orbd to complete */

  ydimInitInfo( &linfo );
  for( i = 0 ; i < list->_length ; i++ )
  {
    ainfo = &list->_buffer[i];
    y = ainfo->yort_ydyo_activeInfo;

    /* 1267, "ydim_imr_destroyActiveLocal_i: %s/%s" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1267,YSLSEV_DEBUG(3),(char*)0,
	     YSLSTR(ainfo->intf_ydyo_activeInfo),
	     YSLSTR(yduStr(ainfo->impl_ydyo_activeInfo)), YSLEND );

    /* if yort was removed, assume everything inside was removed too */
    lookup.pinfo_ydimy.self_yort_procInfo = y;
    if( !ysspLookup( (dvoid *)&lookup, &cx->ytree_ydimcx ) )
      continue;

    yduFreeCopyStr(&linfo.intf_ydim_implInfo, ainfo->intf_ydyo_activeInfo,
		   yotkFreeStr, yotkAllocStr);
    yduFreeCopyStr(&linfo.impl_ydim_implInfo, ainfo->impl_ydyo_activeInfo,
		   yotkFreeStr, yotkAllocStr);

    /* if this is a yort, take it out too */
    if( !strcmp(ysidToStr(yort_proc__id), ainfo->intf_ydyo_activeInfo) )
    {
      /* FIXME? cheesy way to get host -- extract from yort impl. */
      yduFreeCopyStr(&linfo.host_ydim_implInfo, ainfo->impl_ydyo_activeInfo,
		     yotkFreeStr, yotkAllocStr);
      *(strchr( linfo.host_ydim_implInfo, ':')) = 0;

      /* take out the yort */
      ydim_imr_destroyYortLocal_i( or, ev, y );
      /* and delete info for the proc in the imr */
      ydim_imr_destroyInfoLocal_i( or, ev, &linfo );
      yduFreeCacheStr( linfo.host_ydim_implInfo );
      linfo.host_ydim_implInfo = (char*)0;
    }

    /* for all occurances of this intf/impl, check for active match */
    for((n = ydimFirstLookup((dvoid*)&linfo, &cx->itree_ydimcx, ydimIIIHWCmp));
	n && !ydimIIIHWCmp( (dvoid*)&linfo, n->key_ysspNode );
	n = ysspFNext( n ) )
    {
      /* lookup active tree, and remove this yort if found */
      on = (ydimn*)ysspLookup( n->key_ysspNode, &cx->itree_ydimcx );
      a = ydimGetActive( cx, ainfo );
      ydimDelObjFromOtree( &on->otree_ydimn, (dvoid*)a );
      yoRelease( (dvoid*)a );
      on->update_ydimn = TRUE;
    }
  }
  ydim_implInfo__free( &linfo, yotkFreeStr);
}

/* object method */
/* ARGSUSED */
void ydim_imr_destroyActiveGlobal_i( ydim_imr or, yoenv *ev,
				ydyo_activeInfoList* list)
{
  /* 1268, "ydim_imr_destroyActiveGlobal_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1268,YSLSEV_INFO,(char*)0, YSLNONE);

  ydimPutGlobal(or,(dvoid*)list,(CONST ydimGlobalFunc)ydimDelActive,
		"ydimDelActive");
}

/* object method */
/* ARGSUSED */
yort_proc ydim_imr_yortOfProc_i( ydim_imr or, yoenv *ev,
				char* host, char* pid, char* affinity)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimy	    lookup;
  ydimy	    *y;
  ysspNode  *n;

  /* 1269, "ydim_imr_yortOfProc_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1269,YSLSEV_INFO,(char*)0, YSLNONE);

  CLRSTRUCT(lookup);
  lookup.pinfo_ydimy.host_yort_procInfo = host;
  lookup.pinfo_ydimy.pid_yort_procInfo = pid;
  lookup.pinfo_ydimy.affinity_yort_procInfo = affinity;

  if( (n = ysspLookup( (dvoid *)&lookup, &cx->ptree_ydimcx ) ) )
  {
    y = (ydimy*)n->key_ysspNode;
    return((yort_proc)yoDuplicate((dvoid*)y->pinfo_ydimy.self_yort_procInfo));
  }
  return( (yort_proc)0 );
}

/* ---------------------------------------------------------------- */
/* YDIM yort methods */
/* ---------------------------------------------------------------- */

/* object method */
/* ARGSUSED */
boolean ydim_imr_procOfYort_i( ydim_imr or, yoenv *ev, yort_proc y,
			  yort_procInfo* pinfo)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  yort_procInfo	*lpinfo;

  if( (lpinfo = ydimPInfoOfYort( cx, y ) ) )
  {
    yort_procInfo__copy( pinfo, lpinfo, yoAlloc );
    return( TRUE );
  }
  return FALSE;
}


/* object method */
/* ARGSUSED */
boolean ydim_imr_activeOfYort_i( ydim_imr or, yoenv *ev, yort_proc yr,
			  ydim_activeList* list)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimy	    *y = (ydimy*)0;
  ydimy	    lookup;
  boolean   rv = FALSE;
  ysspNode  *n;

  lookup.pinfo_ydimy.self_yort_procInfo = yr;

  list->_length = list->_maximum = 0;
  list->_buffer = (ydim_active*)0;
  if( (n = ysspLookup( (dvoid *)&lookup, &cx->ytree_ydimcx ) ) )
  {
    y = (ydimy*)n->key_ysspNode;
    ydimOtreeToAlist( &y->otree_ydimy, list, yoAlloc, yoFree );
    rv = TRUE;
  }
  return( rv );
}

/* object method */
void ydim_imr_destroyYortLocal_i( ydim_imr or, yoenv *ev, yort_proc yr)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ysspNode  *n, *an;
  ydimy	    *y;
  ydimy	    lookup;

  /* 1270, ""ydim_imr_destroyYortLocal_i: deleting yort" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1270,YSLSEV_INFO,(char*)0, YSLNONE );

  ydimSyncWait( cx );		/* wait for syncing orbd to complete */

  lookup.pinfo_ydimy.self_yort_procInfo = yr;

  if( (n = ysspLookup( (dvoid *)&lookup, &cx->ytree_ydimcx ) ) )
  {
    y = (ydimy*)n->key_ysspNode;

    /* take out the active tree, and refs in impl lists */
    while( (an = ysspDeqTree( &y->otree_ydimy ) ) )
    {
      /* 1271, "ydim_imr_destroyYortLocal_i: deleting active" */
      ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1271,YSLSEV_DEBUG(3),(char*)0,YSLNONE);

      ydim_active_destroyLocal_i( (ydim_active)an->key_ysspNode, ev );
      yoRelease( an->key_ysspNode );
      ysmGlbFree( (dvoid*)an );
    }

    /* stop deathwatch */
    ysEvtDestroy( y->devt_ydimy );

    ysspRemove( n, &cx->ytree_ydimcx );
    ysspRemove( &y->pnode_ydimy, &cx->ptree_ydimcx );
    yort_procInfo__free( &y->pinfo_ydimy, yotkFreeStr);
    ysmGlbFree( (dvoid *)y );
  }
}

/* object method */
/* ARGSUSED */
void ydim_imr_destroyYortGlobal_i( ydim_imr or, yoenv *ev, yort_proc y)
{
  /* 1272, "ydim_imr_destroyYortGlobal_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1272,YSLSEV_INFO,(char*)0, YSLNONE);

  ydimPutGlobal(or,(dvoid*)y,(CONST ydimGlobalFunc)ydimDelYort,
		"ydimDelYort" );
}


/* ---------------------------------------------------------------- */
/* YDIM List methods */
/* ---------------------------------------------------------------- */

boolean ydim_imr_exists_i( ydim_imr or, yoenv *ev, char *intf, char *impl )
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydim_infoList ilist;
  ydim_infoIterator ii;
  ydim_activeList *alist;
  ydimain *ain;
  ydyo_activeInfo *ainfo;
  ub4 i, j;
  boolean rv = FALSE;
  
  /* 1273, "ydim_imr_exists_i: %s/%s" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1273,YSLSEV_INFO,(char*)0,
	   YSLSTR(intf), YSLSTR(yduStr(impl)), YSLEND );

  ydim_imr_listImpl( or, ev, cx->chunk_ydimcx, intf, impl, (char*)0,
		    &ilist, &ii );

  while( !rv && ilist._length )
  {
    for( i = 0 ; !rv && i < ilist._length ; i++ )
    {
      /* check for any non-suspended impl */
      alist = &ilist._buffer[i].alist_ydim_implInfo; 
      for( j = 0 ; j < alist->_length ; j++ )
      {
	ain = ydimActiveGetAinfo( alist->_buffer[j] );
	ainfo = &ain->ainfo_ydimain;
	if( !bit( ainfo->implFlags_ydyo_activeInfo, yort_suspended_implFlag))
	{
	  rv = TRUE;
	  break;
	}
      }
    }
    ydim_infoList__free( &ilist, yoFree );
    if( !rv && ii )
      DISCARD ydim_infoIterator_next_n_i(ii, ev, cx->chunk_ydimcx,&ilist);
    else
      break;
  }
  if( ii )
    ydim_infoIterator_destroy_i( ii, ev );

  return( rv );
}


/* object method */

void ydim_imr_listImpl_i( ydim_imr or, yoenv *ev, sb4 count,
		     char* intf, char* impl,
		     char* host,
		     ydim_infoList* list,
		     ydim_infoIterator* ii)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimicx   *myii;

  /* 1274, "ydim_imr_listImpl_i: count %d" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1274,YSLSEV_INFO,(char*)0,
	   YSLSB4( count ), YSLEND );

  list->_length = list->_maximum = 0;
  list->_buffer = (ydim_implInfo*)0;

  myii = (ydimicx*)ysmGlbAlloc( sizeof(*myii), ydimicx_tag );
  myii->first_ydimicx = TRUE;

  ydimInitInfo( &myii->kinfo_ydimicx );
  ydimInitInfo( &myii->info_ydimicx );

  myii->kinfo_ydimicx.intf_ydim_implInfo = yduCopyCacheStr( intf );
  myii->kinfo_ydimicx.impl_ydim_implInfo = yduCopyCacheStr( impl );
  myii->host_ydimicx = yduCopyCacheStr( host );

  *ii = (ydim_infoIterator)yoCreate( ydim_infoIterator__id,
				    (char*)0,
				    (yoRefData*)0,
				    (char *)0, (dvoid *)myii );
  myii->self_ydimicx = *ii;
  myii->le_ydimicx = ysLstEnq( cx->iis_ydimcx, (dvoid*)myii );

  if( count && (!ydim_infoIterator_next_n_i( *ii, ev, count, list ) ||
		list->_length != (ub4)count) )
  {
    ydim_infoIterator_destroy_i( *ii, ev );
    *ii = (ydim_infoIterator)0;
  }
  if( *ii )
    *ii = (ydim_infoIterator)yoDuplicate((dvoid*)*ii);

  /* 1275, "ydim_imr_listImpl_i: out iterator %s" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1275,YSLSEV_DEBUG(3),(char*)0,
	   YSLSTR( *ii ? "TRUE" : "FALSE"), YSLEND );
}


/* object method */
void ydim_imr_listYort_i( ydim_imr or, yoenv *ev, sb4 count, yort_proc y,
			 ydim_yortList* ylist, ydim_yortIterator* yi)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimyicx  *myyi;

  /* 1276, "ydim_imr_listYort: count %d" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1276,YSLSEV_INFO,(char*)0,
	   YSLSB4( count ), YSLEND );

  ylist->_length = ylist->_maximum = 0;
  ylist->_buffer = (yort_proc*)0;

  myyi = (ydimyicx*)ysmGlbAlloc( sizeof(*myyi), ydimyicx_tag );
  myyi->first_ydimyicx = TRUE;
  myyi->yort_ydimyicx = (yort_proc)yoDuplicate((dvoid*)y);

  *yi = (ydim_yortIterator)yoCreate( ydim_yortIterator__id,
				    (char*)0,
				    (yoRefData*)0,
				    (char *)0, (dvoid *)myyi );
  myyi->self_ydimyicx = *yi;
  myyi->le_ydimyicx = ysLstEnq( cx->yis_ydimcx, (dvoid*)myyi );

  if( count && (!ydim_yortIterator_next_n_i( *yi, ev, count, ylist ) ||
     ylist->_length != (ub4)count) )
  {
    ydim_yortIterator_destroy_i( *yi, ev );
    *yi = (ydim_yortIterator)0;
  }
  if( *yi )
    *yi = (ydim_yortIterator)yoDuplicate((dvoid*)*yi);

  /* 1277, "ydim_imr_listYort: return iterator %s", */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1277,YSLSEV_DEBUG(3),(char*)0,
	   YSLSTR( *yi ? "TRUE" : "FALSE"), YSLEND );
}


/* ARGSUSED */
ydim_sync ydim_imr_createSync_i( ydim_imr or, yoenv* ev, sb4 cnt)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimso    *so = (ydimso*)ysmGlbAlloc( sizeof(*so), ydimso_tag );

  if( cx->so_ydimcx )
  {
    /* 1278, "ydim_imr_createSync: already have a sync object" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1278,YSLSEV_EMERG,(char*)0, YSLNONE );
    ysePanic(YDIM_EX_INTERNAL);
  }

  so->self_ydimso = (ydim_sync)yoCreate( ydim_sync__id, (char*)0,
					(yoRefData*)0,  (char*)0, (dvoid*)so );
  so->cnt_ydimso = cnt;
  so->hdlr_ydimso = (ydimSyncFunc)0;
  so->usrp_ydimso = (dvoid*)0;
  cx->so_ydimcx = so;

  /* 1279, "ydim_imr_createSync_i: made object with cnt %d", */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1279,YSLSEV_INFO,(char*)0,
	   YSLSB4(so->cnt_ydimso), YSLEND );

  return( (ydim_sync)yoDuplicate( (dvoid*)so->self_ydimso ) );
}

void ydimSetSyncHandler( ydim_sync or, ydimSyncFunc hdlr, dvoid *usrp )
{
  ydimso    *so = (ydimso*)yoGetState((dvoid*)or );

  /* 1280, "ydimSetSyncHandler:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1280,YSLSEV_INFO,(char*)0, YSLNONE);

  so->hdlr_ydimso = hdlr;
  so->usrp_ydimso = usrp;
}


/* ARGSUSED */
void ydim_imr_startSync_i( ydim_imr or, yoenv* ev, ydim_imr dest,
			  ydim_sync whenDone)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimsp    *sp = (ydimsp*)ysmGlbAlloc( sizeof(*sp), ydimsp_tag );
  ysevt	*evt;

  /* 1281, "ydim_imr_startSync:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1281,YSLSEV_INFO,(char*)0, YSLNONE );

  /* should only be one at a time, globally */
  if( cx->asp_ydimcx )
  {
    /* 1282, "ydim_imr_startSync: already have sync proc!" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1282,YSLSEV_EMERG,(char*)0, YSLNONE );
    ysePanic(YDIM_EX_INTERNAL);
  }

  sp->ykey_ydimsp = (yort_proc)0;
  sp->dest_ydimsp = (ydim_imr)yoDuplicate( (dvoid*)dest );
  sp->whenDone_ydimsp = (ydim_sync)yoDuplicate( (dvoid*)whenDone );
  sp->outobj_ydimsp = (ydim_info)0;
  sp->claim_ydimsp.property = (char*)0;
  sp->claim_ydimsp.owner = (yort_proc)0;
  sp->claim_ydimsp.obj = (CORBA_Object)0;
  sp->devt_ydimsp = (ysevt*)0;
  sp->evt_ydimsp = (ysevt*)0;
  sp->gsem_ydimsp = (ysevt*)0;
  sp->cx_ydimsp = cx;
  sp->state_ydimsp = sendInfo_ydimsp;
  ydimInitInfo( &sp->ikey_ydimsp );
  yoEnvInit( &sp->env_ydimsp );

  /* global serialization */
  cx->asp_ydimcx = sp;

  if( yoIsEq( (dvoid*)or, (dvoid*)dest ) )
  {
    /* 1283, "ydim_imr_startSync: sync to self ignored" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1283,YSLSEV_EMERG,(char*)0, YSLNONE);
    ysePanic( YDIM_EX_INTERNAL );
  }
  else				/* kick the machine into life */
  {
    /* Wait for all tries/abandons to complete */
    evt = ysSemCreate( (dvoid*)0 );
    ydcaSetInactiveEvt( cx->cacx_ydimcx, evt );

    while( !ysSemTest( evt ) )
    {
      ysSvcAll( cx->q_ydimcx );
      ysYield();
    }
    ysSemDestroy( evt );

    /* 1284, "ydim_imr_startSync: starting sends" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1284,YSLSEV_DEBUG(3),(char*)0, YSLNONE);

    /* set deathwatch */
    sp->devt_ydimsp = ysEvtCreate(ydimSyncDeath, (dvoid*)sp,
				  cx->q_ydimcx, TRUE);
    yoWatchOwner( (dvoid*)sp->dest_ydimsp, sp->devt_ydimsp );

    sp->evt_ydimsp = ysEvtCreate( ydimSyncComplete, (dvoid*)sp,
				 (ysque*)0, TRUE );
    ysTrigger( sp->evt_ydimsp, (ysid*)0, (dvoid*)0, (size_t)0 );
  }
}


/* ARGSUSED */
void ydim_imr_stake_i( ydim_imr or, yoenv* ev, yort_claim* what,
		      yoevt replyTo)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  ydimSyncWait( cx );		/* wait for syncing orbd to complete */

  ydcaStakeFor( cx->cacx_ydimcx, what, replyTo );
}

/* ARGSUSED */
void ydim_imr_abandon_i( ydim_imr or, yoenv* ev, yort_claim* what)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  ydimSyncWait( cx );		/* wait for syncing orbd to complete */

  ydcaAbandonFor( cx->cacx_ydimcx, what, FALSE );
}

/* ARGSUSED */
void ydim_imr_transfer_i( ydim_imr or, yoenv* ev, yort_claim* newClaim)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  ydimSyncWait( cx );

  ydcaTransfer( cx->cacx_ydimcx, newClaim );
}


/* ARGSUSED */
yostd_stringList ydim_imr_listProperties_i( ydim_imr or, yoenv* ev,
					   char* regexp )
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  yslst	    *l;
  ysre	    *re;
  boolean   first = TRUE;
  char	    *s;
  yostd_stringList list;
  yort_claim	*now;
  yort_claim	cursor;

  l = ysLstCreate();
  re = regexp ? ysRECompile( regexp, FALSE ) : (ysre*)0;
  cursor.owner = (yort_proc)0;
  cursor.obj = (CORBA_Object)0;

  /* loop to make list of matching list */
  while( (now = ydcaListNext(cx->cacx_ydimcx,first?(yort_claim*)0: &cursor)) )
  {
    cursor.property = now->property;
    first = FALSE;
    if( (!re || ysREMatch( re, now->property, TRUE )))
      DISCARD ysLstEnq( l, (dvoid*)now->property );
  }

  /* now build output sequence from the list */
  list._length = 0;
  list._maximum = (ub4)ysLstCount( l );
  list._buffer =
    (char**)yoAlloc( (size_t)list._maximum * sizeof(char*));

  while( (s = (char*)ysLstDeq( l ) ) )
    list._buffer[ list._length++ ] = ysStrDupWaf( s, yoAlloc );

  ysLstDestroy( l, (ysmff)0 );
  if( re )
    ysREFree( re );

  return( list );
}


CORBA_Object ydim_imr_propertyResolve_i(ydim_imr or, yoenv* ev, char* property)
{
  yort_claimList    clist;
  yort_claim	    what;
  ydim_claimIterator	ci;
  dvoid *obj;

  what.property = property;
  what.obj = (dvoid*)0;
  what.owner = (yort_proc)0;
  ydim_imr_listClaim_i( or, ev, (sb4)2, &what, &clist, &ci );

  if( ci )
  {
    /* not supposed to happen... */
    ydim_claimIterator_destroy_i( ci, ev );
    yseThrow( YDYO_EX_NOTUNIQUE );
  }

  obj = clist._length ? clist._buffer[0].obj : (dvoid*)0;
  return( (CORBA_Object)yoDuplicate( obj ) );
}

/* ARGSUSED */
void ydim_imr_abandonFor_i( ydim_imr or, yoenv* ev, yort_claim* what)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  ydimSyncWait( cx );		/* wait for syncing orbd to complete */

  ydcaAbandonFor( cx->cacx_ydimcx, what, TRUE );
}

/* no syncWait on internal routines */
/* ARGSUSED */
ydim_tryResult ydim_imr_tryStake_i( ydim_imr or, yoenv* ev, yort_claim* what)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  return ydcaTryStake( cx->cacx_ydimcx, what );
}

/* no syncWait on internal routines */
/* ARGSUSED */
ydim_tryResult ydim_imr_transferStake_i( ydim_imr or, yoenv* ev,
					yort_claim* what)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  return ydcaTransferStake( cx->cacx_ydimcx, what );
}

/* no syncWait on internal routines */
/* ARGSUSED */
void ydim_imr_commitStake_i( ydim_imr or, yoenv* ev, yort_claim* what)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  ydcaCommitStake( cx->cacx_ydimcx, what );
}

/* no syncWait on internal routines */
/* ARGSUSED */
void ydim_imr_abortStake_i( ydim_imr or, yoenv* ev, yort_claim* what)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  ydcaAbortStake( cx->cacx_ydimcx, what );
}

void ydim_imr_listClaim_i( ydim_imr or, yoenv* ev, sb4 count,
			  yort_claim* what, yort_claimList* claims,
			  ydim_claimIterator* ci)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimcicx  *cix;

  claims->_length = claims->_maximum = 0;
  claims->_buffer = (yort_claim*)0;

  cix = (ydimcicx*)ysmGlbAlloc( sizeof(*cix), ydimcicx_tag );
  yort_claim__copy( &cix->filter_ydimcicx, what, yotkAllocStr );
  if( cix->filter_ydimcicx.property )
    cix->re_ydimcicx = ysRECompile( cix->filter_ydimcicx.property, FALSE );
  else
    cix->re_ydimcicx = (ysre*)0;

  *ci = (ydim_claimIterator)yoCreate( ydim_claimIterator__id, (char*)0,
				 (yoRefData*)0, (char*)0, (dvoid*)cix);

  cix->cursor_ydimcicx.property = (char*)0;
  cix->cursor_ydimcicx.obj = (dvoid*)0;
  cix->cursor_ydimcicx.owner = (yort_proc)0;
  cix->first_ydimcicx = TRUE;
  cix->self_ydimcicx = *ci;
  cix->le_ydimcicx = ysLstEnq( cx->cis_ydimcx, (dvoid*)cix );

  if( count && (!ydim_claimIterator_next_n_i( *ci, ev, count, claims ) ||
		claims->_length != (ub4)count) )
  {
    ydim_claimIterator_destroy_i( *ci, ev );
    *ci = (ydim_claimIterator)0;
  }
  if( *ci )
    *ci = (ydim_claimIterator)yoDuplicate((dvoid*)*ci);
}


/* ---------------------------------------------------------------- */
/* YDIMI methods */
/* ---------------------------------------------------------------- */

/* object method */
/* ARGSUSED */
ydim_implInfo ydim_info__get_info_i( ydim_info or, yoenv *ev)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydim_implInfo  *info = (ydim_implInfo*)yoGetState((dvoid *)or);
  ydimn	    *on = (ydimn*)ysspLookup( (dvoid*)info, &cx->itree_ydimcx );
  ydim_implInfo  rv;

  /* CONSTCOND */
  ysmCheck( on, ydimn_tag );

  /* update the sequence */
  ydimUpdateAlist( on );

  /* copy to user space */
  ydim_implInfo__copy( &rv, info, yoAlloc );
  return rv;
}

/* object method */
/* ARGSUSED */
void ydim_info_destroyLocal_i( ydim_info or, yoenv *ev)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydim_implInfo  *info = (ydim_implInfo *)yoGetState((dvoid *)or);
  ydimn	    *on = (ydimn*)ysspLookup( (dvoid*)info, &cx->itree_ydimcx );

  /* CONSTCOND */
  ysmCheck( on, ydimn_tag );

  ydimSyncWait( cx );		/* wait for syncing orbd to complete */

  /* 1285, "ydim_info_destroyLocal_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1285,YSLSEV_INFO,(char*)0, YSLNONE );

  ysspRemove( &on->inode_ydimn, &cx->itree_ydimcx );
  ydim_implInfo__free( info, yotkFreeStr);
  yoDispose( (dvoid*)or );
  ysmGlbFree( (dvoid *)on );
}

/* object method */
void ydim_info_destroyGlobal_i( ydim_info or, yoenv *ev)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydim_implInfo  *info = (ydim_implInfo *)yoGetState((dvoid *)or);
  ydimn	    *on = (ydimn*)ysspLookup( (dvoid*)info, &cx->itree_ydimcx );

  /* CONSTCOND */
  ysmCheck( on, ydimn_tag );

  /* 1286, "ydim_info_destroyGlobal_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1286,YSLSEV_INFO,(char*)0, YSLNONE);

  ydim_imr_destroyInfoGlobal_i( cx->self_ydimcx, ev, info );
}

/* ---------------------------------------------------------------- */
/* YDIM ACTIVE methods */
/* ---------------------------------------------------------------- */

/* object method */
/* ARGSUSED */
ydyo_activeInfo ydim_active__get_ainfo_i( ydim_active or, yoenv *ev)
{
  ydimain   *ain = (ydimain*)yoGetState((dvoid *)or);
  ydyo_activeInfo rv;

  /* 1287, "ydim_active__get_ainfo_i:"  */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1287,YSLSEV_INFO,(char*)0, YSLNONE );

  /* CONSTCOND */
  ysmCheck( ain, ydimain_tag );
  ydyo_activeInfo__copy( &rv, &ain->ainfo_ydimain, yoAlloc );

  /* 1288, "ydim_active__get_ainfo_i: returning %s|%s" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1288,YSLSEV_DEBUG(4),(char*)0,
	   YSLSTR(yduStr(ain->ainfo_ydimain.intf_ydyo_activeInfo)),
	   YSLSTR(yduStr(ain->ainfo_ydimain.impl_ydyo_activeInfo)), YSLEND);

  return rv;
}

/* ARGSUSED */
ydim_yortProcInfoList ydim_imr__get_plist_i( ydim_imr or, yoenv *ev)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);

  ydim_yortProcInfoList rv;
  ysspNode  *n;
  ydimy	    *y;

  /* 1289, "ydim_active__get_plist_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1289,YSLSEV_INFO,(char*)0, YSLNONE);

  rv._length = rv._maximum = 0;
  for( n = ysspFHead( &cx->ptree_ydimcx); n ; n = ysspFNext( n ) )
      rv._maximum++;

  rv._buffer =
    (yort_procInfo*)yoAlloc((size_t)rv._maximum*sizeof(yort_procInfo));

  for( n = ysspFHead( &cx->ptree_ydimcx); n ; n = ysspFNext( n ) )
  {
    y = (ydimy*)n->key_ysspNode;
    yort_procInfo__copy( &rv._buffer[rv._length++], &y->pinfo_ydimy, yoAlloc );
  }
  return( rv );
}



/* object method */
void ydim_active_destroyLocal_i( ydim_active or, yoenv *ev)
{
  ydimcx  *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimain *ain = (ydimain *)yoGetState((dvoid *)or);

  ydyo_activeInfo    *ainfo = &ain->ainfo_ydimain;
  ydim_implInfo  *info;
  ydimy	    lookup;
  ydimy	    *y = (ydimy*)0;
  ub4	    i;
  ydim_infoIterator ii;
  ydim_infoList	ilist;
  ysspNode  *n;
  ydimn	    *on;

  /* CONSTCOND */
  ysmCheck( ain, ydimain_tag );

  /* 1290, "ydim_active_destroyLocal_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1290,YSLSEV_INFO,(char*)0, YSLNONE);

  ydimSyncWait( cx );		/* wait for syncing orbd to complete */

  /* search down and kill refs in ydimys. */
  lookup.pinfo_ydimy.self_yort_procInfo = ainfo->yort_ydyo_activeInfo;
  if( (n = ysspLookup( (dvoid *)&lookup, &cx->ytree_ydimcx ) ) )
  {
    /* 1291, "ydim_active_destroyLocal_i: del refs to active" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1291,YSLSEV_DEBUG(3),(char*)0, YSLNONE);
    y = (ydimy*)n->key_ysspNode;
    ydimDelObjFromOtree( &y->otree_ydimy, (dvoid*)or );
  }

  /* search down and kill refs in alists in ydim_implInfo structures. */

  /* 1292, "ydim_active_destroyLocal_i: del refs in info to active" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1292,YSLSEV_DEBUG(3),(char*)0, YSLNONE);

  ydim_imr_listImpl_i( cx->self_ydimcx, ev, cx->chunk_ydimcx,
		      ainfo->intf_ydyo_activeInfo, ainfo->impl_ydyo_activeInfo,
		      y ? y->pinfo_ydimy.host_yort_procInfo : (char *)0,
		      &ilist, &ii );
  do
  {
    for( i = 0 ; i < ilist._length ; i++ )
    {
      info =
	(ydim_implInfo*)yoGetState((dvoid*)
				   ilist._buffer[i].self_ydim_implInfo);
      on = (ydimn*)ysspLookup( (dvoid*)info, &cx->itree_ydimcx );

      /* 1293, "ydim_active_destroyLocal_i: intf %s", */
      ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1293,YSLSEV_DEBUG(4),(char*)0,
	       YSLSTR(yduStr(info->intf_ydim_implInfo)), YSLEND );

      ydimDelObjFromOtree( &on->otree_ydimn, (dvoid*)or );
      on->update_ydimn = TRUE;
    }
    ydim_infoList__free( &ilist, yoFree );

  } while(ii && ydim_infoIterator_next_n_i( ii, ev, cx->chunk_ydimcx, &ilist));

  if( ii )
    ydim_infoIterator_destroy_i( ii, ev );

  ysspRemove( &ain->anode_ydimain, &cx->atree_ydimcx );
  ydyo_activeInfo__free( ainfo, yotkFreeStr);
  yoDispose( (dvoid*)or );
  ysmGlbFree( (dvoid *)ain );
}

/* object method */
void ydim_active_destroyGlobal_i( ydim_active or, yoenv *ev)
{
  ydimcx  *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydyo_activeInfoList ailist;
  ydimain *ain = (ydimain*)yoGetState((dvoid *)or);

  /* CONSTCOND */
  ysmCheck( ain, ydimain_tag );

  /* 1294, "ydim_active_destroyGlobal_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1294,YSLSEV_INFO,(char*)0, YSLNONE);

  ailist._maximum = ailist._length = 1;
  ailist._buffer = &ain->ainfo_ydimain;

  ydim_imr_destroyActiveGlobal_i( cx->self_ydimcx, ev, &ailist );
}

/* ---------------------------------------------------------------- */
/* ydim_infoIterator methods */
/* ---------------------------------------------------------------- */

/* object method */
boolean ydim_infoIterator_next_one_i( ydim_infoIterator or, yoenv *ev,
				     ydim_implInfo* info)
{
  boolean rv = FALSE;
  ydim_infoList list;

  /* 1295, "ydim_infoIterator_next_one_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1295,YSLSEV_INFO,(char*)0, YSLNONE);

  if( ydim_infoIterator_next_n_i( or, ev, (sb4)1, &list ) && list._length )
  {
    /* list._buffer[0] allocated with yoAlloc, so we are done */
    DISCARD memcpy( (dvoid*)info, (dvoid*)&list._buffer[0], sizeof(*info) );
    rv = TRUE;
    yoFree( (dvoid*)list._buffer );
  }
  return( rv );
}

/* object method */
/* ARGSUSED */
boolean ydim_infoIterator_next_n_i( ydim_infoIterator or, yoenv *ev,
				   sb4 count, ydim_infoList* list)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimicx   *myii = (ydimicx*)yoGetState( (dvoid*)or );
  ydim_implInfo  *lookup;
  ydim_implInfo  *info = (ydim_implInfo*)0;
  ysspNode  *n;
  boolean   rv;

  /* CONSTCOND */
  ysmCheck( myii, ydimicx_tag );

  /* 1296, "ydim_infoIterator_next_n_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1296,YSLSEV_INFO,(char*)0,YSLNONE);

  list->_length = 0;
  list->_maximum = (ub4)count;
  list->_buffer =
    (ydim_implInfo*)yoAlloc( (size_t)count * sizeof(*list->_buffer) );

  while( list->_length < (ub4)count )
  {
    /* 1297, "ydim_infoIterator_next_n_i: considering host %s", */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1297,YSLSEV_DEBUG(4),(char*)0,
	     YSLSTR(yduStr(myii->host_ydimicx)), YSLEND );

    lookup = &myii->kinfo_ydimicx;
    yduFreeCopyStr(&lookup->host_ydim_implInfo, myii->host_ydimicx,
		   yotkFreeStr, yotkAllocStr);

    /* locate first thing to consider */
    if( myii->first_ydimicx )
      n = ydimFirstLookup((dvoid*)&myii->kinfo_ydimicx, &cx->itree_ydimcx,
			  ydimIIIHWCmp);
    else
      n = ysspNextLookup((dvoid*)&myii->info_ydimicx, &cx->itree_ydimcx );

    /* 1298, "ydim_infoIter_next_n_i: %s" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1298,YSLSEV_DEBUG(4),(char*)0,
	     YSLSTR(myii->first_ydimicx ? "FIRST" : "NEXT"), YSLEND);

    for( ; n && list->_length < (ub4)count ; n = ysspFNext(n) )
    {
      if( ydimIIIHWCmp( (dvoid *)&myii->kinfo_ydimicx, n->key_ysspNode ) )
      {
	/* 1299, "ydim_infoIter_next_n_i: stop" */
	ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1299,YSLSEV_DEBUG(4),
		 (char*)0,YSLNONE);
	n = (ysspNode *)0;
	break;
      }
      info = (ydim_implInfo*)n->key_ysspNode;
      ydimUpdateAlist( (ydimn*)n );
      /* 1300, "ydim_infoIter_next_n_i: adding result info" */
      ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1300,YSLSEV_DEBUG(5),(char*)0,YSLNONE);
      ydim_implInfo__copy( &list->_buffer[list->_length++], info, yoAlloc );
      myii->first_ydimicx = FALSE;
    }
    /* if no more, done */
    if( !n )
      break;
  }
  if( !list->_length )
  {
    list->_maximum = 0;
    yoFree( (dvoid*)list->_buffer );
    list->_buffer = (ydim_implInfo*)0;
  }

  if( !myii->first_ydimicx && info )
    ydimKeySet( &myii->info_ydimicx, info );

  /* asking for count == 0 returns TRUE */
  rv = !count || list->_length;

  /* 1301, "ydim_infoIter_next_n_i: returning %d, %d rows", */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1301,YSLSEV_DEBUG(4),(char*)0,
	   YSLUB4((ub4)rv), YSLUB4(list->_length), YSLEND );

  return( rv );
}


/* object method */
/* ARGSUSED */
void ydim_infoIterator_destroy_i( ydim_infoIterator or, yoenv *ev)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimicx  *myii = (ydimicx*)yoGetState( (dvoid*)or );

  /* 1302, "ydim_infoIter_destroy:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1302,YSLSEV_INFO,(char*)0, YSLNONE );

  /* CONSTCOND */
  ysmCheck( myii, ydimicx_tag );
  DISCARD ysLstRem( cx->iis_ydimcx, myii->le_ydimicx );
  ydimDestroyII( (dvoid*)myii );
}

/* ---------------------------------------------------------------- */
/* ydim_yortIterator methods */
/* ---------------------------------------------------------------- */


/* object method */
boolean ydim_yortIterator_next_one_i( ydim_yortIterator or, yoenv *ev,
				     yort_proc *oyort)
{
  boolean rv = FALSE;
  ydim_yortList list;

  /* 1303, "ydimYortIter_next_one_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1303,YSLSEV_INFO,(char*)0, YSLNONE );

  list._length = list._maximum = 0;
  list._buffer = (yort_proc*)0;
  if( ydim_yortIterator_next_n_i( or, ev, (sb4)1, &list ) && list._length )
  {
    rv = TRUE;
    *oyort = list._buffer[0];
    yoFree( (dvoid*)list._buffer );
  }
  return( rv );
}

/* object method */
/* ARGSUSED */
boolean ydim_yortIterator_next_n_i( ydim_yortIterator or, yoenv *ev,
				   sb4 count, ydim_yortList* list)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimyicx  *myyi = (ydimyicx*)yoGetState((dvoid*)or);
  ydimy	    lookup;
  ydimy	    *y = (ydimy*)0;
  ysspNode  *n;
  boolean   rv;

  /* 1304, "ydimYortIter_next_n_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1304,YSLSEV_INFO,(char*)0, YSLNONE);

  /* CONSTCOND */
  ysmCheck( myyi, ydimyicx_tag );

  lookup.pinfo_ydimy.self_yort_procInfo = myyi->yort_ydimyicx;

  list->_maximum = (ub4)count;
  list->_length = 0;
  list->_buffer =
    (yort_proc*)yoAlloc( (size_t)count * sizeof(*list->_buffer) );

  if( myyi->first_ydimyicx )
    if( lookup.pinfo_ydimy.self_yort_procInfo )
      n = ysspLookup(  (dvoid *)&lookup, &cx->ytree_ydimcx );
    else
      n = ysspFHead( &cx->ytree_ydimcx );
  else
    n = ysspNextLookup( (dvoid *)&lookup, &cx->ytree_ydimcx );

  for( ; n && list->_length < (ub4)count ; n = ysspFNext( n ))
  {
    y = (ydimy *)n->key_ysspNode;
    if( myyi->yort_ydimyicx )
      yoRelease((dvoid*)myyi->yort_ydimyicx );
    myyi->yort_ydimyicx =
      (yort_proc)yoDuplicate((dvoid*)y->pinfo_ydimy.self_yort_procInfo);
    list->_buffer[list->_length++] =
      (yort_proc)yoDuplicate((dvoid*)y->pinfo_ydimy.self_yort_procInfo);
    myyi->first_ydimyicx = FALSE;
  }

  if( !list->_length )
  {
    list->_maximum = 0;
    yoFree( (dvoid *)list->_buffer );
    list->_buffer = (yort_proc*)0;
  }
  /* asking for count == 0 returns TRUE */
  rv = !count || list->_length;

  /* 1305, "ydimYortIter_next_n_i: returning %d, %d rows" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1305,YSLSEV_DEBUG(4),(char*)0,
	   YSLUB4((ub4)rv), YSLUB4( list->_length ), YSLEND);

  return( rv );
}

/* object method */
/* ARGSUSED */
void ydim_yortIterator_destroy_i( ydim_yortIterator or, yoenv *ev)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimyicx  *myyi = (ydimyicx*)yoGetState((dvoid*)or);

  /* 1306, "ydimYortIter_destroy:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1306,YSLSEV_INFO,(char*)0, YSLNONE);

  /* CONSTCOND */
  ysmCheck( myyi, ydimyicx_tag );
  DISCARD ysLstRem( cx->yis_ydimcx, myyi->le_ydimyicx );
  ydimDestroyYI( (dvoid*)myyi );
}


/* ---------------------------------------------------------------- */
/* ydim_sync methods */
/* ---------------------------------------------------------------- */

/* ARGSUSED */
void ydim_sync_decrement_i( ydim_sync or, yoenv* ev)
{
  ydimcx *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimso *so = (ydimso*)yoGetState((dvoid*)or );

  ydimSyncFunc hdlr;

  /* 1308, "ydim_sync_decrement_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1308,YSLSEV_INFO,(char*)0, YSLNONE );

  if( cx->so_ydimcx != so )
  {
    /* 1307, "%s: mismatch" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1307,YSLSEV_EMERG,(char*)0,
	     YSLSTR("ydim_sync_decrement"), YSLEND );
    ysePanic(YDIM_EX_INTERNAL);
  }

  if( --so->cnt_ydimso == 0 && so->hdlr_ydimso )
  {
    hdlr = so->hdlr_ydimso;
    so->hdlr_ydimso = (ydimSyncFunc)0;
    /* handler may delete the ydimso so. */
    (*hdlr)( or, TRUE, so->usrp_ydimso );
  }
}

/* ARGSUSED */
void ydim_sync_destroy_i( ydim_sync or, yoenv* ev)
{
  ydimcx *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimso *so = (ydimso*)yoGetState((dvoid*)or );

  /* 1309, "ydim_sync_destroy_i:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1309,YSLSEV_INFO,(char*)0, YSLNONE );

  if( cx->so_ydimcx != so )
  {
    /* 1307, "%s: mismatch" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1307,YSLSEV_EMERG,(char*)0,
	     YSLSTR("ydim_sync_destroy"), YSLEND );
    ysePanic(YDIM_EX_INTERNAL);
  }

  if( so->hdlr_ydimso )
    (*so->hdlr_ydimso)( or, FALSE, so->usrp_ydimso );

  yoDispose( (dvoid*)or );
  yoRelease( (dvoid*)or );
  ysmGlbFree( (dvoid*)so );
  cx->so_ydimcx = (ydimso*)0;
}

/* ---------------------------------------------------------------- */
/* ydim claim methods */
/* ---------------------------------------------------------------- */

boolean ydim_claimIterator_next_one_i( ydim_claimIterator or, yoenv* ev,
				      yort_claim* claim)
{
  yort_claimList claims;
  boolean rv;

  rv = ydim_claimIterator_next_n_i( or, ev, (sb4)1, &claims );

  if( claims._length )
    yort_claim__copy( claim, &claims._buffer[0], yoAlloc );

  yort_claimList__free( &claims, yoFree );
  return( rv );
}

/* ARGSUSED */
boolean ydim_claimIterator_next_n_i( ydim_claimIterator or, yoenv* ev,
				    sb4 count, yort_claimList* list)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimcicx   *cix = (ydimcicx*)yoGetState( (dvoid*)or );
  yort_claim	*current = (yort_claim*)0;

  /* CONSTCOND */
  ysmCheck( cix, ydimcicx_tag );

  list->_length = 0;
  list->_maximum = (ub4)count;
  list->_buffer =
    (yort_claim*)yoAlloc( (size_t)count * sizeof(*list->_buffer) );

  while( list->_length < (ub4)count )
  {
    current = cix->first_ydimcicx ? (yort_claim*)0 : &cix->cursor_ydimcicx;
    if( !(current = ydcaListNext( cx->cacx_ydimcx, current ) ) )
      break;

    /* maintain the cursor */
    if( !cix->first_ydimcicx )
      yort_claim__free( &cix->cursor_ydimcicx, yotkFreeStr );
    yort_claim__copy( &cix->cursor_ydimcicx, current, yotkAllocStr );
    cix->first_ydimcicx = FALSE;

    /* if it passes the filter, add it to the output list */
    if((!cix->re_ydimcicx ||
	ysREMatch( cix->re_ydimcicx, current->property, TRUE )) &&
       (!cix->filter_ydimcicx.obj ||
	yoIsEq(cix->filter_ydimcicx.obj, current->obj)) &&
       (!cix->filter_ydimcicx.owner ||
	yoIsEq((dvoid*)cix->filter_ydimcicx.owner, (dvoid*)current->owner)))
    {
      yort_claim__copy( &list->_buffer[ list->_length++ ], current, yoAlloc);
    }
  }
  return current ? TRUE : FALSE;
}

/* ARGSUSED */
void ydim_claimIterator_destroy_i( ydim_claimIterator or, yoenv* ev)
{
  ydimcx    *cx = (ydimcx*)yoGetImplState((dvoid *)or);
  ydimcicx   *cix = (ydimcicx*)yoGetState( (dvoid*)or);

  DISCARD ysLstRem( cx->cis_ydimcx, cix->le_ydimcicx );
  ydimDestroyCI( (dvoid*)cix );
}





/* ---------------------------------------------------------------- */
/* PRIVATE FUNCTIONS */
/* ---------------------------------------------------------------- */


/* ------------------------ ydimObjReleaseDispose ---------------------------- */
/*
  NAME
    ydimObjReleaseDispose
  DESCRIPTION
    Release and dispose object in one shot.
  PARAMETERS
    o	    -- object to release and dipose
  RETURNS
    none
*/

STATICF void ydimObjReleaseDispose( dvoid *o )
{
  yoRelease( o );
  yoDispose( o );
}

/* ---------------------------- ydimInitInfo ---------------------------- */
/*
   NAME
   ydimInitInfo
   DESCRIPTION
   set up a ydim_implInfo structure so it can be freed with
   ydim_implInfo__free.
   PARAMETERS
   into    -- the info to set up.
   RETURNS
   none
*/

STATICF void ydimInitInfo( ydim_implInfo *info )
{
  info->self_ydim_implInfo = (ydim_info)0;

  info->intf_ydim_implInfo =
    info->impl_ydim_implInfo =
      info->host_ydim_implInfo =
	info->pathName_ydim_implInfo = (char *)0;

  info->level_ydim_implInfo = (char *)0;
  info->minInstances_ydim_implInfo = 0;
  info->maxInstances_ydim_implInfo = SB4MAXVAL;

  info->alist_ydim_implInfo._length = info->alist_ydim_implInfo._maximum = 0;
  info->alist_ydim_implInfo._buffer = (ydim_active*)0;
  info->args_ydim_implInfo._length = info->args_ydim_implInfo._maximum = 0;
  info->args_ydim_implInfo._buffer = (char **)0;
}

/* ---------------------------- ydimInitAinfo ---------------------------- */
/*
  NAME
    ydimInitAinfo
  DESCRIPTION
    Initialize a fake ydyo_activeInfo element.
  PARAMETERS
    ainfo	-- the activeInfo to initialize [OUT]
    info	-- implInfo to seed ainfo with -- NOT duplicated.
  RETURNS
    none
*/

STATICF void ydimInitAinfo( ydyo_activeInfo *ainfo, ydim_implInfo *info )
{
  CLRSTRUCT( *ainfo );
  ainfo->self_ydyo_activeInfo = (ydim_active)0;
  ainfo->intf_ydyo_activeInfo = info->intf_ydim_implInfo;
  ainfo->impl_ydyo_activeInfo = info->impl_ydim_implInfo;
  ainfo->yort_ydyo_activeInfo = (yort_proc)0;
  ainfo->yortImpl_ydyo_activeInfo = (yort_impl)0;
  ainfo->implFlags_ydyo_activeInfo = 0;
}

/* ---------------------------- ydimIImplCmp ---------------------------- */
/*
   NAME
   ydimIImplCmp
   DESCRIPTION
   comparison function for two ydim_implInfo structures, considering
   the full unique key intf/impl/host
   PARAMETERS
   a	    pointer to one ydim_implInfo
   b	    pointer to another
   RETURNS
   < 0, 0, >0 to order a and b.
   */
STATICF sword ydimIImplCmp( CONST dvoid *a, CONST dvoid *b )
{
  sword rv;
  ydim_implInfo  *ap = (ydim_implInfo *)a;
  ydim_implInfo  *bp = (ydim_implInfo *)b;

  if(!(rv = yduSafeStrcmp(ap->intf_ydim_implInfo, bp->intf_ydim_implInfo)) &&
     !(rv = yduSafeStrcmp(ap->impl_ydim_implInfo, bp->impl_ydim_implInfo)))
    rv = yduSafeStrcmp(ap->host_ydim_implInfo, bp->host_ydim_implInfo);

  return( rv );
}


/* ---------------------------- ydimIIIHWCmp ---------------------------- */
/*
   NAME
   ydimIIIHWCmp
   DESCRIPTION
   Compare ydiminfo intf/impl/host fields; null pointer matches anything.
   PARAMETERS
   a	    pointer to one ydim_implInfo
   b	    pointer to another
   RETURNS
   < 0, 0, >0 to order a and b.
   */

STATICF sword ydimIIIHWCmp( CONST dvoid *a, CONST dvoid *b )
{
  sword rv;
  ydim_implInfo  *ap = (ydim_implInfo *)a;
  ydim_implInfo  *bp = (ydim_implInfo *)b;

  if(!(rv = yduWildStrcmp(ap->intf_ydim_implInfo, bp->intf_ydim_implInfo)) &&
     !(rv = yduWildStrcmp(ap->impl_ydim_implInfo, bp->impl_ydim_implInfo)))
    rv = yduWildStrcmp(ap->host_ydim_implInfo, bp->host_ydim_implInfo);

  return( rv );
}


STATICF sword ydimAICmp( CONST dvoid *a, CONST dvoid *b )
{
  sword rv;
  ydyo_activeInfo  *ap = (ydyo_activeInfo *)a;
  ydyo_activeInfo  *bp = (ydyo_activeInfo *)b;

  if(!(rv = yoCmp((dvoid*)ap->yort_ydyo_activeInfo,
	       (dvoid*)bp->yort_ydyo_activeInfo)) &&
     !(rv = yduWildStrcmp(ap->intf_ydyo_activeInfo,
			  bp->intf_ydyo_activeInfo)))
     rv = yduWildStrcmp(ap->impl_ydyo_activeInfo,
			bp->impl_ydyo_activeInfo);

  return( rv );
}

/* ---------------------------- ydimPutGlobal ---------------------------- */
/*
  NAME
    ydimPutGlobal
  DESCRIPTION
    Execute a method to all other ORBDs using the given object.  This
    is used to send and delete ydyo_activeInfo and ydim_implInfo, and
    centralizes the iteration over orbds in one place.
  PARAMETERS
    or	    -- ref to the ydim_imr object.
    obj	    -- object argument to the function
    f	    -- the function to call with the object.
    name    -- function name, for tracing messages
  RETURNS
    none
*/
STATICF void ydimPutGlobal( CONST ydim_imr or, CONST dvoid *obj,
			   CONST ydimGlobalFunc f, CONST char *name )
{
  ydimcx *cx = (ydimcx*)yoGetImplState( (dvoid*)or );
  yslst	*orbds;
  ysle	*e;
  ydimghcx  lgh;
  ydimghcx  *gh;
  ydimsp *sp;
  char *refstr;

  /* 1310, "ydimPutGlobal: %s" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1310,YSLSEV_DEBUG(4),(char*)0,
	   YSLSTR(name), YSLEND );

  /* send to public orbds... */
  orbds = yoListORBDs();

  /* Also send to any orbd being synced now.  Need to get this now,
     because it vanished after the ydimSyncWait that follows.  We are
     covering the timing whole between when the sync closes here (unblocking
     updates), and when the other process registers in the name server.
     Because we do the list orbds first, and then add it explicitly here,
     we can't miss him, and we can't have a duplicate of him either. */

  /* ASSIGNOK */
  if( (sp = cx->asp_ydimcx ) )
    DISCARD ysLstEnq( orbds, yoDuplicate( (dvoid*)sp->dest_ydimsp ) );

  /* wait for sync to be done */
  ydimSyncWait( cx );

  /* send to everyplace except self first... */
  yseTry
  {

    for( e = ysLstHead( orbds ); e ; e = ysLstNext( e ) )
    {
      if( !yoIsEq( (dvoid*)cx->self_ydimcx, ysLstVal(e) ) )
      {
	refstr = yoRefToStr( ysLstVal(e) );
	/* 1311, "ydimPutGlobal: sending to %s" */
	ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1311,YSLSEV_DEBUG(5),(char*)0,
		 YSLSTR(refstr), YSLEND );
	yoFree( (dvoid*)refstr );

	gh = (ydimghcx*)ysmGlbAlloc(sizeof(*gh),"ydimghcx");
	/* send to others, syncronously! */
	gh->ydimcx_ydimghcx = cx;
	gh->func_ydimghcx = f;
	gh->name_ydimghcx = name;
	gh->obj_ydimghcx = (dvoid*)obj;
	gh->dest_ydimghcx = (ydim_imr)yoDuplicate(ysLstVal(e));
	gh->outobj_ydimghcx = (dvoid*)0;
	gh->evt_ydimghcx = ysEvtSimple( ydimGlobalHandler, (dvoid*)gh );
	yoEnvInit( &gh->ev_ydimghcx );
	(*gh->func_ydimghcx)( gh->dest_ydimghcx, gh->obj_ydimghcx,
			     &gh->ev_ydimghcx, gh );
	ysYield();
      }
    }
    /* send to self last, in case we're deleting it */
    lgh.ydimcx_ydimghcx = cx;
    lgh.func_ydimghcx = f;
    lgh.name_ydimghcx = name;
    lgh.obj_ydimghcx = (dvoid*)obj;
    lgh.dest_ydimghcx = (ydim_imr)cx->self_ydimcx;
    lgh.outobj_ydimghcx = (dvoid*)0;
    lgh.evt_ydimghcx = (ysevt*)0;
    (*f)( cx->self_ydimcx, obj, &cx->ev_ydimcx, &lgh );
  }
  yseCatch( YS_EX_INTERRUPT )
    yseRethrow;
  yseCatchAll
    /* 1312, "ydimPutGlobal caught unexpected exception %s" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1312,YSLSEV_WARNING,(char*)0,
	     YSLSTR(ysidToStr(yseExid)), YSLEND );
  yseEnd;

  if( orbds )
    ysLstDestroy( orbds, yoRelease );

  /* 1313, "ydimPutGlobal: exit" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1313,YSLSEV_DEBUG(5),(char*)0, YSLNONE );
}

/* -------------------------- ydimGlobalHandler -------------------------- */
/*
  NAME
    ydimGlobalHandler
  DESCRIPTION
    handler to complete global put i/o operations.
  PARAMETERS
    usrp    -- the ydimghcx context.
    exid    -- completion exception, if any.
    arg	    -- ?? ignored.
    argsz   -- ?? ignored.
  RETURNS
    <x>
  NOTES
    <x>
  MODIFIED   (MM/DD/YY)
    dbrower   09/ 1/95 -  created.
*/

/* ARGSUSED */
STATICF void ydimGlobalHandler(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			       size_t argsz)
{
  ydimghcx *ghcx = (ydimghcx*)usrp;
  char *refstr;

  if(exid)
  {
    refstr = yoRefToStr( (dvoid*)ghcx->dest_ydimghcx );
    /* 1314, "ydimGlobalHandler: exception %s on %s to %s" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1314,YSLSEV_WARNING,(char*)0,
	     YSLSTR(ysidToStr(exid)),
	     YSLSTR(ghcx->name_ydimghcx),
	     YSLSTR(refstr), YSLEND);
    yoFree( (dvoid*)refstr );
  }
  else
  {
    /* 1315, "ydimGlobalHandler: completed %s OK" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1315,YSLSEV_DEBUG(5),(char*)0,
	     YSLSTR(ghcx->name_ydimghcx), YSLEND );
  }

  if( ghcx->outobj_ydimghcx )
    yoRelease( ghcx->outobj_ydimghcx );
  yoRelease( (dvoid*)ghcx->dest_ydimghcx );
  yoEnvFree( &ghcx->ev_ydimghcx );
  ysmGlbFree( (dvoid*)ghcx );
}


/* ---------------------------- ydimPutInfo ---------------------------- */
/*
   NAME
    ydimPutInfo
   DESCRIPTION
    Function to call to send method info to another orbd.

   PARAMETERS
     self	    -- this ydim
     o		    -- object ref of the ydim_imr in an orbd.
     usrp	    -- the info to send.
     ev		    -- environment to use.
     gh		    -- other needed context.
   RETURNS
   none
*/
STATICF void ydimPutInfo(CONST ydim_imr dest,
			 CONST dvoid *usrp, yoenv *ev, ydimghcx *gh )
{
  if( gh->evt_ydimghcx )
  {
    ydim_imr_addInfoLocal_nw( dest, ev, (ydim_implInfo *)usrp,
			  (ydim_info*)&gh->outobj_ydimghcx,
			  gh->evt_ydimghcx );
  }
  else
  {
    ydim_imr_addInfoLocal( dest, ev, (ydim_implInfo *)usrp,
			  (ydim_info*)&gh->outobj_ydimghcx );
    yoRelease( gh->outobj_ydimghcx );
  }
}

/* ---------------------------- ydimDelInfo ---------------------------- */
/*
   NAME
     ydimDelInfo
   DESCRIPTION
     Function to delete a ydim_implInfo from a ydim; called from ydimPutGlobal.
   PARAMETERS
     self	    -- this ydim
     o		    -- object ref of the ydim_imr in an orbd.
     usrp	    -- the info to send.
     ev		    -- environment to use.
     gh		    -- other needed context.
   RETURNS
     none
*/
/* ARGSUSED */
STATICF void ydimDelInfo( CONST ydim_imr dest,
			 CONST dvoid *usrp,
			 yoenv *ev, ydimghcx *gh)
{
  if( gh->evt_ydimghcx )
    ydim_imr_destroyInfoLocal_nw( dest, ev, (ydim_implInfo *)usrp,
				 gh->evt_ydimghcx );
  else
    ydim_imr_destroyInfoLocal( dest, ev, (ydim_implInfo *)usrp );
}


/* ---------------------------- ydimPutActive ---------------------------- */
/*
   NAME
     ydimPutActive
   DESCRIPTION
     Function to call to send method info to another orbd.

     Takes dvoid * for compatibility with ydimGlobal

   PARAMETERS
     self	    -- this ydim
     o		    -- object ref of the ydim_imr in an orbd.
     usrp	    -- the info to send.
     ev		    -- environment to use.
     gh		    -- other needed context.
   RETURNS
     none
*/
/* ARGSUSED */
STATICF void ydimPutActive(CONST ydim_imr dest,
			   CONST dvoid *usrp,
			   yoenv *ev, ydimghcx *gh )
{
  ydima *arg = (ydima *)usrp;

  if( gh->evt_ydimghcx )
    ydim_imr_addActiveLocal_nw( dest, ev, arg->pinfo_ydima,
			       arg->alist_ydima,
			       gh->evt_ydimghcx);
  else
    ydim_imr_addActiveLocal( dest, ev, arg->pinfo_ydima, arg->alist_ydima );
}

/* ---------------------------- ydimDelActive ---------------------------- */
/*
   NAME
     ydimDelActive
   DESCRIPTION
     function to delete ydyo_activeInfo entries from a ydim.  Called
     from ydimPutGlobal.
   PARAMETERS
     self	    -- this ydim
     o		    -- object ref of the ydim_imr in an orbd.
     usrp	    -- the info to send.
     ev		    -- environment to use.
     gh		    -- other needed context.
   RETURNS
     none
*/
/* ARGSUSED */
STATICF void ydimDelActive(CONST ydim_imr dest,
			   CONST dvoid *usrp,
			   yoenv *ev, ydimghcx *gh )
{
  if( gh->evt_ydimghcx )
    ydim_imr_destroyActiveLocal_nw( dest, ev, (ydyo_activeInfoList*)usrp,
				   gh->evt_ydimghcx );
  else
    ydim_imr_destroyActiveLocal( dest, ev, (ydyo_activeInfoList*)usrp );
}




/* ---------------------------- ydimDelYort ---------------------------- */
/*
   NAME
     ydimDelYort
   DESCRIPTION
     function to delete a yort; called through ydimPutGlobal.
   PARAMETERS
     self	    -- this ydim
     o		    -- object ref of the ydim_imr in an orbd.
     usrp	    -- the info to send.
     ev		    -- environment to use.
     gh		    -- other needed context.
   RETURNS
     none
*/
/* ARGSUSED */
STATICF void ydimDelYort(CONST ydim_imr dest,
			 CONST dvoid *usrp,
			 yoenv *ev, ydimghcx *gh)
{
  if( gh->evt_ydimghcx )
    ydim_imr_destroyYortLocal_nw( dest, ev, (yort_proc)usrp,
				 gh->evt_ydimghcx );
  else
    ydim_imr_destroyYortLocal( dest, ev, (yort_proc)usrp );
}


/* ---------------------------- ydimKeySet ---------------------------- */
/*
   NAME
   ydimKeySet
   DESCRIPTION
     Set keys in iterator object state.  Pointers to existing strings
     in the dest object are freed first.
   PARAMETERS
     dest    -- ydim_implInfo for new key [OUT].
     src	    -- ydim_implInfo with current key values.
     type    -- either YDIM_II_KEY or YDIM_RI_KEY.
   RETURNS
   none
   */
STATICF void ydimKeySet( ydim_implInfo *dest, ydim_implInfo *src )
{
  yduFreeCopyStr(&dest->intf_ydim_implInfo, src->intf_ydim_implInfo,
		 yotkFreeStr, yotkAllocStr);
  yduFreeCopyStr(&dest->impl_ydim_implInfo, src->impl_ydim_implInfo,
		 yotkFreeStr, yotkAllocStr);
  yduFreeCopyStr(&dest->host_ydim_implInfo, src->host_ydim_implInfo,
		 yotkFreeStr, yotkAllocStr);
  yduFreeCopyStr(&dest->pathName_ydim_implInfo, src->pathName_ydim_implInfo,
		 yotkFreeStr, yotkAllocStr);
}

/* ---------------------------- ydimYYortCmp ---------------------------- */
/*
  NAME
    ydimYYortCmp
  DESCRIPTION
    Compare two ydimy nodes based on the yort values.
  PARAMETERS
    a	    -- one ydimy to consider;
    b	    -- the other.
  RETURNS
    <0, 0, >0 ordering of the two elements.
*/

STATICF sword ydimYYortCmp( CONST dvoid *a, CONST dvoid *b )
{
  ydimy *ap = (ydimy*)a;
  ydimy *bp = (ydimy*)b;

  return( yoCmp((dvoid*)ap->pinfo_ydimy.self_yort_procInfo,
		(dvoid*)bp->pinfo_ydimy.self_yort_procInfo ) );
}

/* ---------------------------- ydimYProcCmp ---------------------------- */
/*
  NAME
    ydimYProcCmp
  DESCRIPTION
    Compare two ydimy nodes based on the process information.
  PARAMETERS
    a	    -- one ydimy to consider;
    b	    -- the other.
  RETURNS
    <0, 0, >0 ordering of the two elements.
*/

STATICF sword ydimYProcCmp( CONST dvoid *a, CONST dvoid *b )
{
  sword rv = 0;
  ydimy *ap = (ydimy*)a;
  ydimy *bp = (ydimy*)b;

  if(!(rv = (sword)strcmp(ap->pinfo_ydimy.host_yort_procInfo,
		   bp->pinfo_ydimy.host_yort_procInfo )) &&
     !(rv = yduSafeStrcmp(ap->pinfo_ydimy.pid_yort_procInfo,
			  bp->pinfo_ydimy.pid_yort_procInfo )))
    rv = yduSafeStrcmp(ap->pinfo_ydimy.affinity_yort_procInfo,
		       bp->pinfo_ydimy.affinity_yort_procInfo );
  return( rv );
}


/* ---------------------------- ydimAddYort ---------------------------- */
/*
   NAME
     ydimAddYort
   DESCRIPTION
     Add knowledge of a process to ydsp and yort tree, from ydim.
   PARAMETERS
     pinfo   -- proc info given to us.
   RETURNS
    pointer to ydimy, old or new.
*/

STATICF ydimy *ydimAddYort( ydimcx *cx, yort_procInfo *pinfo )
{
  ydsp_procInfo	spinfo;
  ydsp_proc	proc;
  CONST char	*host = ysGetHostName();
  ydimy	    lookup;
  ysspNode  *n;
  ydimy	    *y;

  /* make sure we have yort and proc entries */
  CLRSTRUCT(lookup);
  lookup.pinfo_ydimy.self_yort_procInfo = pinfo->self_yort_procInfo;
  if( (n = ysspLookup( (dvoid *)&lookup, &cx->ytree_ydimcx ) ) )
  {
    y = (ydimy*)n;
    /* 1316, "ydimAddYort: using old ydimy" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1316,YSLSEV_DEBUG(4),(char*)0, YSLNONE );
  }
  else			/* not found; make it */
  {
    y = (ydimy*)ysmGlbAlloc( sizeof(*y), ydimy_tag );
    y->ynode_ydimy.key_ysspNode = y->pnode_ydimy.key_ysspNode = (dvoid*)y;
    DISCARD ysspNewTree( &y->otree_ydimy, yoCmp );

    /* copies key values */
    yort_procInfo__copy( &y->pinfo_ydimy, pinfo, yotkAllocStr );

    /* 1317, "ydimAddYort: added yort for %s:%s:%s" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1317,YSLSEV_DEBUG(3),(char*)0,
	     YSLSTR(y->pinfo_ydimy.host_yort_procInfo),
	     YSLSTR(y->pinfo_ydimy.pid_yort_procInfo),
	     YSLSTR(yduStr(y->pinfo_ydimy.affinity_yort_procInfo)), YSLEND);

    DISCARD ysspEnq( &y->pnode_ydimy, &cx->ptree_ydimcx );
    DISCARD ysspEnq( &y->ynode_ydimy, &cx->ytree_ydimcx );

    y->cx_ydimy = cx;
    y->devt_ydimy = ysEvtCreate(ydimYortDeath, (dvoid*)y, cx->q_ydimcx, TRUE);
    yoWatchOwner( (dvoid*)pinfo->self_yort_procInfo, y->devt_ydimy );
  }

  /* only add procs if we have sp and it's on this host */
  if( cx->sp_ydimcx && !strcmp( host, pinfo->host_yort_procInfo ) )
  {
    /* add info about possibly unknown proc */
    spinfo.self_ydsp_procInfo = (ydsp_proc)0;
    spinfo.host_ydsp_procInfo = pinfo->host_yort_procInfo;
    spinfo.pid_ydsp_procInfo = pinfo->pid_yort_procInfo;
    spinfo.affinity_ydsp_procInfo = pinfo->affinity_yort_procInfo;
    spinfo.name_ydsp_procInfo = pinfo->name_yort_procInfo;
    spinfo.parent_ydsp_procInfo = (ydsp_spawner)0;
    spinfo.state_ydsp_procInfo = ydsp_start_ok;
    ydsp_spawner_addExisting( cx->sp_ydimcx, &cx->ev_ydimcx,
			     &spinfo, &proc );
    yoRelease( (dvoid*)proc );
  }
  return y;
}


/* ---------------------------- ydimYortDeath ---------------------------- */
/*
  NAME
    ydimYortDeath
  DESCRIPTION
    Function called when a process dies.  We do global cleanup on it's
    behalf.
  PARAMETERS
    usrp	-- the ydimy.
    exid	-- some exception.
    arg		-- some arg.
    argsz	-- some size.
  RETURNS
    none
*/

/* ARGSUSED */
STATICF void ydimYortDeath(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			   size_t argsz)
{
  ydimy *y = (ydimy*)usrp;

  ydim_imr_destroyYortLocal_i( y->cx_ydimy->self_ydimcx,
			      &y->cx_ydimy->ev_ydimcx,
			      y->pinfo_ydimy.self_yort_procInfo );
}


/* ---------------------------- ydimLookup ---------------------------- */
/*
   NAME
   ydimLookup
   DESCRIPTION
   Find a node in the tree matching a key using a supplied compare
   function.  The node returned may be any of ones with equivalent keys.
   PARAMETERS
   key	    -- key to search for.
   t	    -- tree to search.
   cmp	    -- function to use to compare.
   RETURNS
   pointer to located node, or NULL.
   */

STATICF ysspNode *ydimLookup( dvoid *key, ysspTree *t, ysspCmpFunc cmp )
{
  ysspNode *n;
  sb4 cmpval = 0;		/* shut up bogus "used before set"  */

  /* find node in the tree using arg supplied compare func */
  n = t->root_ysspTree;
  while( n && (cmpval = (*cmp)( key, n->key_ysspNode ) ) )
    n = ( cmpval < 0 ) ? n->left_ysspNode : n->right_ysspNode;

  /* reorganize tree around this node */
  if( n )
    ysspSplay( n, t );

  return( n );
}

/* --------------------------- ydimFirstLookup ---------------------------- */
/*
   NAME
   ydimFirstLookup
   DESCRIPTION
   Find the first node in a tree qualifying with the compare function
   supplied.  This is like ysspFirstLookup, except fot the cmp argument.
   This lets the tree be maintained with a fully-qualified unique key,
   while allowing lookups on partial keys.
   PARAMETERS
   key	    -- the key to locate.
   t	    -- the tree to search
   cmp	    -- the comparison function to use
   RETURNS
   pointer to located node, or null.
*/

STATICF ysspNode *ydimFirstLookup( dvoid *key, ysspTree *t, ysspCmpFunc cmp )
{
  ysspNode *n, *pn;

  /* find one node of this key, then back up to first with same key */
  for(n = ydimLookup( key, t, cmp ); (pn = ysspFPrev(n)) ; n = pn )
    if( (*cmp)( key, pn->key_ysspNode) )
      break;

  if( n )
    ysspSplay( n, t );
  return( n );
}



/* ---------------------------- ydimGetActive ---------------------------- */
/*
  NAME
    ydimGetActive
  DESCRIPTION
    Locate or create a ydim_active reference for active info.

    This does some surprisingly complicated things that really want to
    be handled in some other way.  The wrinkle is that this is where
    we handle the state manipulation associated with implementations
    that are in the middle of being launched.

    Specificially,

	if the info is known, and the yort in question is not null,
	    then return a ref to that info.

        if the info is known, but the yort is NULL, then this is
	    going to be launched.  Create another object with
	    a yort that is our ydim, so we can identify it later.

	if the info is known, but the yort is us, then this is one
	    that was being launched and is coming active.  Change
	    the yort to the right value, and drive the launch callback.

	if the info is unknown, create a new object with the specified
	    yort value.

  PARAMETERS
    cx	    -- the context
    ainfo   -- contains the info we want to get an object for.
  RETURNS
    ydim_active object ref.
*/

STATICF ydim_active ydimGetActive( ydimcx *cx, ydyo_activeInfo *ainfo )
{
  ysspNode	*n;
  ydimain	*ain = (ydimain*)0;
  ydyo_activeInfo    *nainfo = (ydyo_activeInfo*)0;
  ydyo_activeInfo    lainfo;
  ydim_active	a;

  /* 1318, "ydimGetActive: make/find %s/%s" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1318,YSLSEV_DEBUG(4),(char*)0,
	   YSLSTR(yduStr(ainfo->intf_ydyo_activeInfo)),
	   YSLSTR(yduStr(ainfo->impl_ydyo_activeInfo)), YSLEND),

  /* copy for short-term memory */
  DISCARD memcpy( (dvoid*)&lainfo, (dvoid*)ainfo, sizeof(lainfo));

  /* got the one we want already? */
  if( (n = ysspLookup( (dvoid*)ainfo, &cx->atree_ydimcx ) ) )
  {
    ain = (ydimain*)n;
    nainfo = &ain->ainfo_ydimain;

    if( ainfo->yort_ydyo_activeInfo )
    {
      /* 1319, "ydimGetActive: use existing node" */
      ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1319,YSLSEV_DEBUG(4),(char*)0,YSLNONE);

      /* update flags only - may be suspending or re-activating */
      nainfo->implFlags_ydyo_activeInfo = ainfo->implFlags_ydyo_activeInfo;
    }
    else			/* null yort, fake launch entry  */
    {
      /* 1320, "ydimGetActive: launching one; creating queue" */
      ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1320,YSLSEV_DEBUG(3),(char*)0,YSLNONE);

      /* create new one that is in-flight, with a queue -- don't dupe self */
      lainfo.yort_ydyo_activeInfo = (yort_proc)cx->self_ydimcx;
      lainfo.yortImpl_ydyo_activeInfo = (yort_impl)0;
      ain = (ydimain*)yoGetState( (dvoid*)(a = ydimGetActive(cx, &lainfo)));
      /* CONSTCOND */
      ysmCheck( ain, ydimain_tag );
      nainfo = &ain->ainfo_ydimain;
      yoRelease( (dvoid*)a );
    }
  }

  /* nope.  Is this one that is starting coming alive? */
  if( ainfo->yort_ydyo_activeInfo && !ain )
  {
    /* 1321, "ydimGetActive: not there"  */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1321,YSLSEV_DEBUG(4),(char*)0, YSLNONE);

    /* have one in process of spawning? */
    lainfo.yort_ydyo_activeInfo = (yort_proc)cx->self_ydimcx;
    if( (n = ysspLookup( (dvoid*)&lainfo, &cx->atree_ydimcx ) ) )
    {
      ain = (ydimain*)n;
      nainfo = &ain->ainfo_ydimain;

      /* 1322, "ydimGetActive: was launching; drive queued items" */
      ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1322,YSLSEV_DEBUG(4),(char*)0,YSLNONE);

      /* now sucessfully launched */
      ysspRemove( n, &cx->atree_ydimcx );
      /* don't release non-duped self reference */
      nainfo->yort_ydyo_activeInfo =
	(yort_proc)yoDuplicate((dvoid*)ainfo->yort_ydyo_activeInfo);
      nainfo->yortImpl_ydyo_activeInfo = ainfo->yortImpl_ydyo_activeInfo;
      DISCARD ysspEnq( n, &cx->atree_ydimcx );

      /* drive any waiting launches on this. */
      ydimLaunchActive( cx, ain );
    }
  }

  if( !ain )			/* need brand new one */
  {
    /* 1323, "ydimGetActive: brand new" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1323,YSLSEV_DEBUG(4),(char*)0, YSLNONE );

    ain = (ydimain*)ysmGlbAlloc( sizeof(*ain), ydimain_tag );
    nainfo = &ain->ainfo_ydimain;
    ain->anode_ydimain.key_ysspNode = (dvoid*)nainfo;
    ain->ucnt_ydimain = 0;
    ain->usrp_ydimain = (dvoid*)0;
    ydyo_activeInfo__copy( nainfo, ainfo, yotkAllocStr );
    nainfo->self_ydyo_activeInfo =
      (ydim_active)yoCreate( ydim_active__id, (char*)0,
			    (yoRefData*)0, (char *)0, (dvoid *)ain );

    /* 1324, "ydimGetActive: added new node" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1324,YSLSEV_DEBUG(4),(char*)0, YSLNONE );
    DISCARD ysspEnq( &ain->anode_ydimain, &cx->atree_ydimcx );
  }

  /* 1325, "ydimGetActive: returning ainfo ref for %s/%s" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1325,YSLSEV_DEBUG(4),(char*)0,
	   YSLSTR(yduStr(nainfo->intf_ydyo_activeInfo)),
	   YSLSTR(yduStr(nainfo->impl_ydyo_activeInfo)), YSLEND );

  return( (ydim_active)yoDuplicate((dvoid*)nainfo->self_ydyo_activeInfo));
}


/* ------------------------- ydimAddActiveToAlist ------------------------- */
/*
  NAME
    ydimAddActiveToAlist
  DESCRIPTION
    Add an active entry to an active list; used to maintain the
    lists in the ydimln.
  PARAMETERS
    alist	-- list to update
    ai		-- the active info to add.  The reference is copied.
  RETURNS
    none
*/

STATICF void ydimAddActiveToAlist( ydim_activeList *alist, ydim_active ai )
{
  ub4 i;
  ydim_active	*nbuffer;

  /* Is this already an active impl? */
  for( i = 0 ; i < alist->_length ; i++ )
    if( yoIsEq( (dvoid*)ai, (dvoid*)alist->_buffer[i] ) )
      break;
    else if( !(i % 100 ) )
      ysYield();

  /* if not found, need to add new object and maybe extend the sequence  */
  if( i >= alist->_length )
  {
    /* need to add space too? */
    if( i >= alist->_maximum )
    {
      ysYield();
      alist->_maximum += max( 5, alist->_maximum / 2 );
      nbuffer = (ydim_active*)
	ysmGlbAlloc(sizeof(*nbuffer)*(size_t)alist->_maximum,
		    "ydim_active _buffer" );
      if( alist->_buffer )
      {
	DISCARD memcpy( nbuffer, alist->_buffer, i * sizeof(*nbuffer) );
	ysmGlbFree( (dvoid*)alist->_buffer );
      }
      alist->_buffer = nbuffer;
    }
    alist->_buffer[alist->_length++] = (ydim_active)yoDuplicate((dvoid*)ai);
  }
}


/* ------------------------- ydimAddObjToTree ------------------------- */
/*
  NAME
    ydimAddObjToTree
  DESCRIPTION
    Add an active entry to hash table of refs.  Used to maintain the
    lists in the ydim_implInfo and the yort.
  PARAMETERS
    otree	-- tree to update
    or		-- the object ref to add
  RETURNS
    none
*/

STATICF void ydimAddObjToTree( ysspTree *ht, dvoid *or )
{
  ysspNode *n;

  if( !ysspLookup( or, ht ))
  {
    n = (ysspNode*)ysmGlbAlloc( sizeof(*n), "ydim ref node");
    n->key_ysspNode = yoDuplicate( or );
    DISCARD ysspEnq( n, ht );
  }
}

STATICF void ydimDelObjFromOtree( ysspTree *ht, dvoid *or )
{
  ysspNode *n;

  if( ( n = ysspLookup( (dvoid*)or, ht )))
  {
    ysspRemove( n, ht );
    yoRelease( n->key_ysspNode );
    ysmGlbFree( (dvoid*)n );
  }
}

STATICF void ydimDestroyOtree( ysspTree *ht )
{
  ysspNode *n;
  while( (n = ysspDeqTree( ht ) ) )
  {
    yoRelease( n->key_ysspNode );
    ysmGlbFree( (dvoid*)n );
  }
}


/* ----------------------------ydimOtreeToAlist ---------------------------- */
/*
  NAME
    ydimOtreeToAlist
  DESCRIPTION
    Convert a tree to an alist, with the alist allocated in global space.
    Do this only when you need the alist to be correct, as when returning
    the alist to some other place.  Until needed, just keep the tree
    up-to-date.
  PARAMETERS
    otree   the authoritative tree
    alist   the current possibly out-of-date seq of the alist.
  RETURNS
    none
*/

STATICF void ydimOtreeToAlist( ysspTree *otree, ydim_activeList *alist,
			      ysmaf af, ysmff ff )
{
  ub4 i;
  ysspNode *n;

  if( !ff ) ff = ysmFGlbFree;

  /* free existing list */
  ydim_activeList__free( alist, (ysmff)ff );

  i = alist->_length = alist->_maximum = 0;
  alist->_buffer = (ydim_active*)0;

  /* build new list */
  if( ( i = ysspTreeCount( otree ) ) )
  {
    if( af )
      alist->_buffer =
	(ydim_active*)(*af)( (size_t)i * sizeof(ydim_active) );
    else
      alist->_buffer =
	(ydim_active*)ysmGlbAlloc( (size_t)i * sizeof(ydim_active),
				  "ydim_activeList buffer" );

    alist->_maximum = i;

    for( n = ysspFHead( otree ) ; n ; n = ysspFNext( n ) )
      alist->_buffer[ alist->_length++ ] =
	(ydim_active)yoDuplicate( n->key_ysspNode );
  }
}


STATICF void ydimUpdateAlist( ydimn *on )
{
  if( on->update_ydimn )
  {
    on->update_ydimn = FALSE;
    ydimOtreeToAlist( &on->otree_ydimn,
		     &on->info_ydimn.alist_ydim_implInfo,
		     yotkAllocStr, yotkFreeStr );
  }
}


STATICF ub4 ysspTreeCount( ysspTree *h )
{
  ub4 rv= 0;
  ysspNode *n;

  for( n = ysspFHead( h ); n ; n = ysspFNext(n) )
    rv++;

  return rv;
}



/* --------------------------- ydimAlistToOtree ---------------------------- */
/*
  NAME
    ydimAlistToOtree
  DESCRIPTION
    Convert an alist to a tree, when loading the tree for the first time.
  PARAMETERS
    otree   the authoritative tree
    alist   the current possibly out-of-date seq of the alist.
  RETURNS
    none
*/

STATICF void ydimAlistToOtree( ydim_activeList *alist, ysspTree *otree )
{
  ub4 i;

  for( i = 0; i < alist->_length ; i++ )
    ydimAddObjToTree( otree, (dvoid*)alist->_buffer[i] );
}




/* --------------------------- ydimLaunchActive --------------------------- */
/*
  NAME
    ydimLaunchActive
  DESCRIPTION
    Called when a launch-pending implementation goes active.  This
    drives the callback, allowing the list or pending requests for
    the implementation(s) to be drained.
  PARAMETERS
    cx		-- the ydim_imr context;
    ain		-- the active info node.
  RETURNS
    none
*/

STATICF void  ydimLaunchActive( ydimcx *cx, ydimain *ain )
{
  ydim_implInfo  lookup;
  ysspNode  *n;
  ydyo_activeInfo    *ainfo;
  ydyo_activeInfo    *lainfo;
  yort_procInfo	    *pinfo;
  ydimn	    *in;
  ysle	    *e = (ysle*)0;
  ysle	    *next;
  ydimln    *ln;

  /* locate the impl info. */

  ainfo = &ain->ainfo_ydimain;
  pinfo = ydimPInfoOfYort( cx, ainfo->yort_ydyo_activeInfo );

  lookup.intf_ydim_implInfo  = ainfo->intf_ydyo_activeInfo;
  lookup.impl_ydim_implInfo  = ainfo->impl_ydyo_activeInfo;
  lookup.host_ydim_implInfo  = pinfo->host_yort_procInfo;

  /* 1326, "ydimLaunchActive: %s/%s h:%s went active" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1326,YSLSEV_INFO,(char*)0,
	   YSLSTR(yduStr(ainfo->intf_ydyo_activeInfo)),
	   YSLSTR(yduStr(ainfo->impl_ydyo_activeInfo)),
	   YSLSTR(pinfo->host_yort_procInfo), YSLEND);

  if( (n = ysspLookup( (dvoid*)&lookup, &cx->itree_ydimcx )) )
  {
    in = (ydimn*)n;
    ln = in->launch_ydimn;

    /* locate the launch record for this newly active impl in
       the ilist and move it to the alist for the launch */

    for( e = ysLstHead( ln->ilist_ydimln ) ; e ; e = next )
    {
      next = ysLstNext(e);
      lainfo = (ydyo_activeInfo*)ysLstVal(e);
      if( yoIsEq((dvoid*)ainfo->self_ydyo_activeInfo,
		 (dvoid*)lainfo->self_ydyo_activeInfo ))
      {
	/* 1327, "ydimLaunchActive: moving from ilist to alist" */
	ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1327,YSLSEV_DEBUG(4),
		 (char*)0,YSLNONE);
	DISCARD ysLstEnq( ln->alist_ydimln, ysLstVal(e) );
	DISCARD ysLstRem( ln->ilist_ydimln, e );
	break;
      }
    }
    if( !e )
    {
      /* 1328, "ydimLaunchActive: no ilist entry!?"); */
      ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1328,YSLSEV_EMERG,(char*)0,YSLNONE);
      ysePanic(YDIM_EX_INTERNAL);
    }
    ydimLaunchCheck(ln);
  }
  else
  {
    /* 1329, "ydimLaunchActive: no info entry!?" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1329,YSLSEV_EMERG,(char*)0,YSLNONE);
    ysePanic(YDIM_EX_INTERNAL);
  }
}

/* --------------------------- ydimLaunchTimeout --------------------------- */
/*
  NAME
    ydimLaunchTimeout
  DESCRIPTION
    ysevt handler function for catching spawned implementation timeout.
    When this is caught, anything that has not come ready is abandoned,
    and we drive the callback to allow rejection of those requests.
  PARAMETERS
    usrp	-- the launch node.
    exid	-- should be timeout exception.
    arg		-- ignored.
    argsz	-- ignored.
  RETURNS
    none
*/

/* ARGSUSED */
STATICF void ydimLaunchTimeout(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			       size_t argsz)
{
  ydimln *ln = (ydimln*)usrp;

  /* 1351, "ydimLaunchTimeout: %s:%s didn't start, %3 requests aborted" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1351,YSLSEV_EMERG,(char*)0,
	   YSLSTR(ln->host_ydimln),
	   YSLSTR(ln->path_ydimln),
	   YSLUB4(ysLstCount(ln->rlist_ydimln)),
	   YSLEND);

  /* clear timeout... */
  if( ln->evt_ydimln )
  {
    ysEvtDestroy( ln->evt_ydimln );
    ln->evt_ydimln = (ysevt*)0;
  }

  /* then drive callback and cleanup */
  ydimLaunchCheck( ln );
}


/* --------------------------- ydimLaunchCheck --------------------------- */
/*
  NAME
    ydimLaunchCheck
  DESCRIPTION
    Handle callback and cleanup when a launch-pending impl comes
    active, or when timeout has occurred.  Drives the callback,
    and if no more requests are pending, clears out the state.
  PARAMETERS
    ln	    -- the launch node.
  RETURNS
    none
*/

STATICF void ydimLaunchCheck( ydimln *ln )
{
  ydyo_activeInfo    *ainfo = (ydyo_activeInfo*)0;
  yoenv ev;

  yoEnvInit(&ev);

  /* Drive callback.  If timeout expired, remaining ilist is inactive */

  /* 1330, "ydimLaunchCheck: %d reqs, %d rdy" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1330,YSLSEV_INFO,(char*)0,
	   YSLUB4(ysLstCount(ln->rlist_ydimln)),
	   YSLUB4(ysLstCount(ln->alist_ydimln)), YSLEND);

  if( ln->rdy_ydimln && ln->rlist_ydimln )
  {
    /* 1331, "ydimLaunchCheck: calling ready func" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1331,YSLSEV_INFO,(char*)0, YSLNONE );
    (*ln->rdy_ydimln)( ln->usrp_ydimln,
		      ln->rlist_ydimln,
		      ln->alist_ydimln,
		      ln->evt_ydimln ? (yslst*)0 : ln->ilist_ydimln );
  }

  /* if no reqs left, this launch is over; clean it up. */

  if( ln->rlist_ydimln && !ysLstCount( ln->rlist_ydimln ) )
  {
    /* cancel timeout on this launch */
    if( ln->evt_ydimln )
    {
      ysEvtDestroy( ln->evt_ydimln );
      ln->evt_ydimln = (ysevt*)0;
    }

    /* Remove any remaining ilist entries.  */

    while( (ainfo = (ydyo_activeInfo*)ysLstDeq( ln->ilist_ydimln ) ) )
      ydim_active_destroyLocal( ainfo->self_ydyo_activeInfo, &ev );

    /* cleanup lists */
    ysLstDestroy( ln->rlist_ydimln, (ysmff)0 );
    ysLstDestroy( ln->ilist_ydimln, (ysmff)0 );
    ysLstDestroy( ln->alist_ydimln, (ysmff)0 );
    ln->rlist_ydimln = (yslst *)0;
    ln->ilist_ydimln = (yslst *)0;
    ln->alist_ydimln = (yslst *)0;

    /* 1332, "ydimLaunchCheck: lists reset; awaiting new launch" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1332,YSLSEV_INFO,(char*)0, YSLNONE );
  }
  else if (!ln->evt_ydimln)
  {
    /* 1333, "ydimLaunchCheck: non-empty rlist, but no evt!?" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1333,YSLSEV_EMERG,(char*)0, YSLNONE );
    ysePanic(YDIM_EX_INTERNAL);
  }
  yoEnvFree(&ev);

  /* 1334, "ydimLaunchCheck: exit: %d reqs, %d rdy" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1334,YSLSEV_INFO,(char*)0,
	   YSLUB4(ln->rlist_ydimln ? ysLstCount(ln->rlist_ydimln) : 0),
	   YSLUB4(ln->alist_ydimln ? ysLstCount(ln->alist_ydimln) : 0),
	   YSLEND);
}


/* -------------------------- ydimStringListCmp -------------------------- */
/*
  NAME
    ydimStringListCmp
  DESCRIPTION
    Comparison function for two string lists.  A shorter one is < a longer
    one.
  PARAMETERS
    a	    -- pointer to one yostd_stringList;
    b	    -- pointer to another.
  RETURNS
    < 0, 0, > 0 to order the two.
*/

STATICF sword ydimStringListCmp( CONST dvoid *a, CONST dvoid *b )
{
  yostd_stringList *ap = (yostd_stringList *)a;
  yostd_stringList *bp = (yostd_stringList *)b;
  sword rv = 0;
  ub4 i = 0;

  for( ; !rv && i < ap->_length && i < bp->_length ; i++ )
    rv = (sword)strcmp( ap->_buffer[i], bp->_buffer[i] );
  return( rv );
}

/* ---------------------------- ydimLaunchCmp ---------------------------- */
/*
  NAME
    ydimLaunchCmp
  DESCRIPTION
    comparison function for ydimln launch nodes.  key is host/path/args.
  PARAMETERS
    a	    -- one ydimln;
    b	    -- another ydimln;
  RETURNS
    < 0, 0, > 0 to order the two arguments.
*/

STATICF sword ydimLaunchCmp( CONST dvoid *a, CONST dvoid *b )
{
  sword rv = 0;
  ydimln *ap = (ydimln *)a;
  ydimln *bp = (ydimln *)b;

  if(!(rv = (sword)strcmp( ap->host_ydimln, bp->host_ydimln ) ) &&
     !(rv = (sword)strcmp( ap->path_ydimln, bp->path_ydimln ) ) )
    rv = ydimStringListCmp((dvoid*)&ap->args_ydimln,
			   (dvoid*)&ap->args_ydimln );

  return( rv );
}


/* ---------------------------- ydimAddLaunch ---------------------------- */
/*
  NAME
    ydimAddLaunch
  DESCRIPTION
    Add a request to an outstanding launch entry.
  PARAMETERS
    cx	    -- the ydim_imr context;
    info    -- implementation we want to send to, when it comes active.
  RETURNS
    none
*/

STATICF ydimln *ydimAddLaunch( ydimcx *cx, ydim_implInfo *info )
{
  ysspNode  *n;
  ydimln    *ln = (ydimln*)0;
  ydimln    lookup;

  lookup.host_ydimln = info->host_ydim_implInfo;
  lookup.path_ydimln = info->pathName_ydim_implInfo;
  lookup.args_ydimln._maximum = info->args_ydim_implInfo._maximum;
  lookup.args_ydimln._length = info->args_ydim_implInfo._length;
  lookup.args_ydimln._buffer = info->args_ydim_implInfo._buffer;
  lookup.host_ydimln = info->host_ydim_implInfo;

  if( (n = ysspLookup( (dvoid *)&lookup, &cx->ltree_ydimcx ) ) )
  {
    /* 1335, "ydimAddLaunch: old node for host %s, path %s" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1335,YSLSEV_DEBUG(4),(char*)0,
	     YSLSTR(info->host_ydim_implInfo),
	     YSLSTR(info->pathName_ydim_implInfo), YSLEND);

    ln = (ydimln*)n->key_ysspNode;
  }
  else
  {
    /* 1336, "ydimAddLaunch: new node for host %s, path %s" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1336,YSLSEV_DEBUG(4),(char*)0,
	     YSLSTR(info->host_ydim_implInfo),
	     YSLSTR(info->pathName_ydim_implInfo), YSLEND);

    ln = (ydimln*)ysmGlbAlloc( sizeof(*ln), ydimln_tag);
    ln->ydimln_spnode.key_ysspNode = (dvoid*)ln;
    ln->cx_ydimln = cx;
    ln->host_ydimln = yduCopyCacheStr(info->host_ydim_implInfo);
    ln->path_ydimln = yduCopyCacheStr(info->pathName_ydim_implInfo);
    yostd_stringList__copy( &ln->args_ydimln, &info->args_ydim_implInfo,
			   yotkAllocStr );
    ln->rlist_ydimln = (yslst*)0;
    ln->ilist_ydimln = (yslst*)0;
    ln->alist_ydimln = (yslst*)0;
    ln->usrp_ydimln = (dvoid*)0;
    ln->rdy_ydimln = (ydimRdyFunc)0;
    ln->evt_ydimln = (ysevt*)0;
    DISCARD ysspEnq( &ln->ydimln_spnode, &cx->ltree_ydimcx );
  }
  return( ln );
}



/* ---------------------------- ydimFreeLaunch ---------------------------- */
/*
  NAME
    ydimFreeLaunch
  DESCRIPTION
    Completely remove a ydimln launch entry.
  PARAMETERS
    ln	    -- the node.  It contains the ydimcx.
  RETURNS
    none
*/
STATICF void ydimFreeLaunch( ydimln *ln )
{
  /* 1337, "ydimFreeLaunch:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1337,YSLSEV_DEBUG(3),(char*)0, YSLNONE);

  /* clean up the pending launch... */

  if( ln->evt_ydimln )
  {
    ysEvtDestroy( ln->evt_ydimln );
    ln->evt_ydimln = (ysevt*)0;
  }
  if( ln->rlist_ydimln )
    ydimLaunchCheck( ln );

  /* then take out the node */

  /* FIXME -- cache remove these */
  if( ln->host_ydimln)
    yduFreeCacheStr( ln->host_ydimln );
  if( ln->path_ydimln )
    yduFreeCacheStr( ln->path_ydimln );

  yostd_stringList__free( &ln->args_ydimln, yotkFreeStr);
  ysmGlbFree( (dvoid*)ln );
}


/* ---------------------------- ydimPInfoOfYort ---------------------------- */
/*
  NAME
    ydimPInfoOfYort
  DESCRIPTION
    return pointer to the process info for a yort we know about.
  PARAMETERS
    cx	    -- context, to locate ytree.
    yort    -- the yort in question.
  RETURNS
    pointer to yort_procInfo, or NULL if not known.
*/
STATICF yort_procInfo *ydimPInfoOfYort( ydimcx *cx, yort_proc y )
{
  ysspNode  *n;
  ydimy	    *yy;
  ydimy	    lookup;

  lookup.pinfo_ydimy.self_yort_procInfo = y;
  if( (n = ysspLookup( (dvoid *)&lookup, &cx->ytree_ydimcx ) ) )
  {
    yy = (ydimy*)n->key_ysspNode;
    return( &yy->pinfo_ydimy );
  }
  else
  {
    /* 1338, "ydimPInfoOfYort: didn't find  yort" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1338,YSLSEV_INFO,(char*)0, YSLNONE );
    return (yort_procInfo*)0;
  }
}


/* ---------------------------- ydimSyncComplete ---------------------------- */
/*
  NAME
    ydimSyncComplete
  DESCRIPTION
    Completion handler for operations on a ydimsp sync process block.
    Given the state in the block, start the next appropriate thing.

  PARAMETERS
    usrp	-- the ydimsp, as a dvoid *.
    exid	-- operation completion exception.
    argp	-- argument, ignored.
    argsz	-- arg size, ignored.
  RETURNS
    none
*/

/* ARGSUSED */
STATICF void ydimSyncComplete( dvoid *usrp, CONST ysid *exid,
			      dvoid *argp, size_t argsz )
{
  ydimsp    *sp = (ydimsp*)usrp;
  ysevt	    *sem;

  /* something completed badly... kill dest & re-enter through death */
  if( exid )
  {
    /* 1339, "ydimSyncComplete: state %d exid %s" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1339,YSLSEV_WARNING,(char*)0,
	     YSLUB4((ub4)sp->state_ydimsp),
	     YSLSTR(yduStr(ysidToStr( exid ))), YSLEND );
    ydimSyncDeath( usrp, exid, argp, argsz );
    return;
  }
  else
    /* 1339, "ydimSyncComplete: state %d exid %s" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1339,YSLSEV_INFO,(char*)0,
	     YSLUB4((ub4)sp->state_ydimsp),
	     YSLSTR(yduStr(ysidToStr( exid ))), YSLEND );

  /* kill kept event now... */
  ysEvtDestroy( sp->evt_ydimsp );

  switch( sp->state_ydimsp )
  {
  case sendInfo_ydimsp:
    ydimSyncInfo( sp );
    break;

  case sendActive_ydimsp:
    ydimSyncActive( sp );
    break;

  case sendTry_ydimsp:
    ydimSyncTry( sp );
    break;

  case sendCommit_ydimsp:

    sp->evt_ydimsp = ysEvtCreate( ydimSyncComplete, (dvoid*)sp,
				 (ysque*)0, TRUE );

    if( argp && *(ydim_tryResult*)argp == ydim_success_tryResult )
    {
      /* that was ok, now commit it. */
      sp->state_ydimsp = sendTry_ydimsp;
      ydim_imr_commitStake_nw(sp->dest_ydimsp, &sp->env_ydimsp,
			      &sp->claim_ydimsp, sp->evt_ydimsp);
    }
    else			/* fail or retry */
    {
      /* May get errors duplicating a try the dest was informed of by some
	 other server, in which case we are done. */
      sp->state_ydimsp = sendRep_ydimsp;
      ysTrigger( sp->evt_ydimsp, (ysid*)0, (dvoid*)0, (size_t)0 );
    }
    break;

  case sendRep_ydimsp:
    ydimSyncReply( sp );
    break;

  case repComp_ydimsp:

    sem = sp->gsem_ydimsp;
    yoRelease( (dvoid*)sp->ykey_ydimsp );
    yoRelease( (dvoid*)sp->whenDone_ydimsp );
    yoRelease( (dvoid*)sp->dest_ydimsp );
    yoEnvFree( &sp->env_ydimsp );
    sp->cx_ydimsp->asp_ydimcx = (ydimsp*)0;

    /* cancel death watch */
    if( sp->devt_ydimsp )
      ysEvtDestroy( sp->devt_ydimsp );

    ysmGlbFree( (dvoid*)sp );

    /* if something is waiting, wake it up */
    if( sem )
      ysTrigger( sem, (ysid*)0, (dvoid*)0, (size_t)0 );
    break;

  default:
    /* 1340, "ydimSyncComplete: bad state %d"  */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1340,YSLSEV_EMERG,(char*)0,
	     YSLUB4((ub4)(sword)sp->state_ydimsp), YSLEND );
    ysePanic(YDIM_EX_INTERNAL);
  }
}


/* ---------------------------- ydimSyncInfo ---------------------------- */
/*
  NAME
    ydimSyncInfo
  DESCRIPTION
    Given the current key in sp->ikey_ydimsp, start sending the next
    non-default info entry to the destination.

    If no i/o was really started because of end-of-scan, set state_ydimsp
    to initiate active info sends, and call the completion handler anyway.

  PARAMETERS
    sp	    -- the ydimsp in question.
  RETURNS
    none */

STATICF void ydimSyncInfo( ydimsp *sp )
{
  ydimcx    *cx = sp->cx_ydimsp;
  ysspNode  *n;
  ydimn	    *on;
  ydim_implInfo	*ii;
  ydim_implInfo	lii;
  ydim_active   *obuffer;

  /* 1341, "ydimSyncInfo: Sending non-default info after %s/%s h:%s" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1341,YSLSEV_DEBUG(3),(char*)0,
	   YSLSTR(yduStr( sp->ikey_ydimsp.intf_ydim_implInfo )),
	   YSLSTR(yduStr( sp->ikey_ydimsp.impl_ydim_implInfo )),
	   YSLSTR(yduStr( sp->ikey_ydimsp.host_ydim_implInfo )), YSLEND );

  sp->evt_ydimsp = ysEvtCreate( ydimSyncComplete, (dvoid*)sp,
			       (ysque*)0, TRUE );

  if( sp->outobj_ydimsp )
    yoRelease( (dvoid*)sp->outobj_ydimsp );
  sp->outobj_ydimsp = (ydim_info)0;

  /* look over impls until end or until send is started. */

  while( ( n = ysspNextLookup( (dvoid*)&sp->ikey_ydimsp,
			      &cx->itree_ydimcx ) ) )
  {
    on = (ydimn*)n;
    ii = (ydim_implInfo*)&on->info_ydimn;

    ydimKeySet( &sp->ikey_ydimsp, ii );

    if( ii->level_ydim_implInfo || ii->minInstances_ydim_implInfo
       || ii->maxInstances_ydim_implInfo != SB4MAXVAL ||
       ii->pathName_ydim_implInfo )
    {
      ydim_implInfo__copy( &lii, ii, yotkAllocStr );

      /* clear out all the actives -- they go separately */
      obuffer = lii.alist_ydim_implInfo._buffer;
      lii.alist_ydim_implInfo._buffer = (ydim_active*)0;
      lii.alist_ydim_implInfo._maximum =
	lii.alist_ydim_implInfo._length = 0;

      ydim_imr_addInfoLocal_nw( sp->dest_ydimsp, &sp->env_ydimsp,
			    &lii, &sp->outobj_ydimsp, sp->evt_ydimsp );

      lii.alist_ydim_implInfo._buffer = obuffer;
      lii.alist_ydim_implInfo._maximum =
	lii.alist_ydim_implInfo._length = ii->alist_ydim_implInfo._length;
      ydim_implInfo__free( &lii, yotkFreeStr );
      return;
    }
  }
  if( !n )
  {
    /* 1342, "ydimSyncInfo: done sending info" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1342,YSLSEV_DEBUG(3),(char*)0, YSLNONE );
    ydim_implInfo__free( &sp->ikey_ydimsp, yotkFreeStr );

    /* need to start sendActive */
    sp->state_ydimsp = sendActive_ydimsp;
    ysTrigger( sp->evt_ydimsp, (ysid*)0, (dvoid*)0, (size_t)0 );
  }
}


/* ---------------------------- ydimSyncActive ---------------------------- */
/*
  NAME
    ydimSyncActive
  DESCRIPTION
    Given the current active proc key in ykey_ydimsp, start a send of
    the active info for the next process.  If no more are left, put machine
    into claims_ydimsp state and re-enter.

  PARAMETERS
    sp	    -- the sync process in question
  RETURNS
    none
*/

STATICF void ydimSyncActive( ydimsp *sp )
{
  ydimcx    *cx = sp->cx_ydimsp;
  ydimy	    *y;
  ysle	    *e;
  sb4	    i;
  ydyo_activeInfo  *aip;
  ysspNode  *n, *m;
  yslst	    *alist;
  ydimy	    lookup;

  ydyo_activeInfoList ailist;

  /* 1343, "ydimSyncActive: Sending next yort" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1343,YSLSEV_DEBUG(3),(char*)0, YSLNONE );
  	
  sp->evt_ydimsp = ysEvtCreate( ydimSyncComplete, (dvoid*)sp,
			       (ysque*)0, TRUE );

  /* get the next yort, if any */
  lookup.pinfo_ydimy.self_yort_procInfo = sp->ykey_ydimsp;
  if( !(n = ysspNextLookup( (dvoid*)&lookup, &cx->ytree_ydimcx ) ) )
  {
    /* 1344, "ydimSyncActive: No more yorts" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1344,YSLSEV_DEBUG(3),(char*)0, YSLNONE);
    yoRelease( (dvoid*)sp->ykey_ydimsp );
    sp->ykey_ydimsp = (yort_proc)0;

    /* need to start sendTry */
    sp->state_ydimsp = sendTry_ydimsp;
    ysTrigger( sp->evt_ydimsp, (ysid*)0, (dvoid*)0, (size_t)0 );
  }
  else				/* send this yort's active impls. */
  {
    y = (ydimy*)n->key_ysspNode;
    alist = ysLstCreate();
    ailist._length = 0;

    /* enq pointer to all AI's in this proc... */
    for( m = ysspFHead( &cx->atree_ydimcx ); m ; m = ysspFNext( m ) )
    {
      aip = (ydyo_activeInfo *)m->key_ysspNode;
      if(yoIsEq((dvoid*)aip->yort_ydyo_activeInfo,
		(dvoid*)y->pinfo_ydimy.self_yort_procInfo))
	DISCARD ysLstEnq( alist, (dvoid *)aip );
    }

    ailist._length = ailist._maximum = ysLstCount( alist );
    yoRelease( (dvoid*)sp->ykey_ydimsp );

    sp->ykey_ydimsp =
      (yort_proc)yoDuplicate((dvoid*)y->pinfo_ydimy.self_yort_procInfo);

    /* only send if there are ai's */
    if( ailist._length )
    {
      /* FIXME -- could chop into smaller sequences here,
	 but we currently send all at once. */

      /* 1345, "ydimSyncActive: sending %d active impls", */
      ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1345,YSLSEV_DEBUG(3),(char*)0,
	       YSLUB4( ailist._length ), YSLEND );

      ailist._buffer = (ydyo_activeInfo*)
	ysmGlbAlloc( (size_t)ailist._length * sizeof(ydyo_activeInfo),
		    "active list");

      for( i = 0, e = ysLstHead( alist ); e ; e = ysLstNext( e ), i++ )
	ydyo_activeInfo__copy( &ailist._buffer[i],
			      (ydyo_activeInfo*)ysLstVal(e), yotkAllocStr );

      ysLstDestroy( alist, (ysmff)0 );

      ydim_imr_addActiveLocal_nw( sp->dest_ydimsp, &sp->env_ydimsp,
				 &y->pinfo_ydimy, &ailist, sp->evt_ydimsp );
      ydyo_activeInfoList__free( &ailist, yotkFreeStr );
    }
  }
}

/* ---------------------------- ydimSyncTry ---------------------------- */
/*
  NAME
    ydimSyncTry
  DESCRIPTION
    Given current claim key in claim_ydimsp, start a send of the next
    claim try.  If no more are left to send, put the machine into finished
    state and re-enter the machine.   If try is attempted, put machine into
    commit.
  PARAMETERS
    sp	    -- the sync proc to work on.
  RETURNS
    none
*/

STATICF void ydimSyncTry( ydimsp *sp )
{
  yort_claim *what;

  sp->evt_ydimsp = ysEvtCreate( ydimSyncComplete, (dvoid*)sp,
			       (ysque*)0, TRUE );

  /* if have more to send... */
  if((what = ydcaListNext(sp->cx_ydimsp->cacx_ydimcx,
			  sp->claim_ydimsp.property ?
			  &sp->claim_ydimsp : (yort_claim*)0)))
  {
    if( sp->claim_ydimsp.property )
      yort_claim__free( &sp->claim_ydimsp, yotkFreeStr );
    yort_claim__copy( &sp->claim_ydimsp, what, yotkAllocStr );

    sp->state_ydimsp = sendCommit_ydimsp;
    ydim_imr_tryStake_nw(sp->dest_ydimsp, &sp->env_ydimsp,
			 &sp->claim_ydimsp, sp->evt_ydimsp);
  }
  else				/* no more claims to send, wrap up. */
  {
    sp->state_ydimsp = sendRep_ydimsp;
    ysTrigger( sp->evt_ydimsp, (ysid*)0, (dvoid*)0, (size_t)0 );
  }
}


/* ---------------------------- ydimSyncReply ---------------------------- */
/*
  NAME
    ydimSyncReply
  DESCRIPTION

    Release a ydimsp sync process block.  This calls the whenDone object to
    waken the destination from its service loop.

    WARNING:  Don't call this during shutdown!  The hanging async
    context will become invalid!

  PARAMETERS
    sp	    -- the ydimsp.
  RETURNS
    none
*/
STATICF void ydimSyncReply( ydimsp *sp )
{
  /* 1346, "ydimSyncReply:" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1346,YSLSEV_DEBUG(2),(char*)0, YSLNONE );

  sp->state_ydimsp = repComp_ydimsp;
  sp->evt_ydimsp = ysEvtCreate( ydimSyncComplete, (dvoid*)sp,
			       (ysque*)0, TRUE );

  if( sp->whenDone_ydimsp )
    ydim_sync_decrement_nw( sp->whenDone_ydimsp,
			   &sp->cx_ydimsp->ev_ydimcx, sp->evt_ydimsp );
  else
    ysTrigger( sp->evt_ydimsp, (ysid*)0, (dvoid*)0, (size_t)0 );
}


/* -------------------------- ydimSyncDeath ---------------------------- */
/*
  NAME
    ydimSyncDeath
  DESCRIPTION
    Called when thing we are sync-ing to dies.  Shutdown the machine without
    doing anything else.
  PARAMETERS
    usrp    -- the active ydimsp
  RETURNS
    none
*/

/* ARGSUSED */
STATICF void ydimSyncDeath( dvoid *usrp, CONST ysid *exid,
			   dvoid *argp, size_t argsz )
{
  ydimsp *sp = (ydimsp*)usrp;
  char *rs;

  rs = yoRefToStr((dvoid*)sp->dest_ydimsp );
  /* 1347, "ydimSyncDeath: dest %s died while active" */
  ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1347,YSLSEV_WARNING,(char*)0,
	   YSLSTR(rs), YSLEND ); 
  yoFree( (dvoid*)rs );

  /* cleanup as per the current state. */

  switch( sp->state_ydimsp )
  {
  case sendInfo_ydimsp:
    ydim_implInfo__free( &sp->ikey_ydimsp, yotkFreeStr );
    break;

  case sendActive_ydimsp:
    yoRelease( (dvoid*)sp->ykey_ydimsp );
    sp->ykey_ydimsp = (yort_proc)0;
    break;

  case sendTry_ydimsp:
  case sendCommit_ydimsp:
    yort_claim__free( &sp->claim_ydimsp, yotkFreeStr );
    break;

  case sendRep_ydimsp:
  case repComp_ydimsp:
    break;

  default:
    /* 1348, "ydimSyncDeath: unexpected state %d in sync machine" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1348,YSLSEV_EMERG,(char*)0,
	     YSLUB4((ub4)sp->state_ydimsp), YSLEND );
    ysePanic( YDIM_EX_INTERNAL );
    break;
  }

  /* destroy the outstanding event */
  ysEvtDestroy( sp->evt_ydimsp );

  /* re-enter the machine as finished. */
  sp->state_ydimsp = repComp_ydimsp;
  sp->evt_ydimsp = ysEvtCreate( ydimSyncComplete, (dvoid*)sp,
			       (ysque*)0, TRUE );
  ysTrigger( sp->evt_ydimsp, (ysid*)0, (dvoid*)0, (size_t)0 );
}



/* ---------------------------- ydimSyncWait ---------------------------- */
/*
  NAME
    ydimSyncWait
  DESCRIPTION
    Called from method routines that modify the IMR or the claim list.
    When someone is syncing to this process, we can't modify anything
    until a consistant snapshot is sent.  This function sees if we are
    have an active sync.  If so, we create a semaphore and wait on it;
    it will be cleared when the sync finishes.
  PARAMETERS
    cx	    -- the ydim context.
  RETURNS
    none.
*/

STATICF void ydimSyncWait( ydimcx *cx )
{
  ydimsp *sp;
  ysevt *sem;

  /* ASSIGNOK */
  if( (sp = cx->asp_ydimcx ) )
  {
    if( sp->gsem_ydimsp )
    {
      /* 1349, "ydimSyncWait: already have gsem" */
      ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1349,YSLSEV_EMERG,(char*)0, YSLNONE );
      ysePanic(YDIM_EX_INTERNAL);
    }

    /* 1350, "ydimSyncWait: waiting" */
    ysRecord(YS_PRODUCT,YDIM_FAC,(ub4)1350,YSLSEV_DEBUG(2),(char*)0, YSLNONE );

    /* rely on yo q service to get this triggered. */
    sem = sp->gsem_ydimsp = ysSemCreate((dvoid*)0);
    ysSemWait(sem); 
    ysSemDestroy(sem); 
  }
}


