/* Copyright (c) 1995 by Oracle Corporation.  All Rights Reserved.
 *
 * yr.c - Generic Interface Repository functions
 *
 * NOTES
 * This file contains the bulk of the repository implementation that is
 * shared between the library form used by the IDL compiler and the
 * IFR server, mnirsrv. The persistence story is pretty flimsy - the
 * IDL compiler can emit IFR data files which in turn can be loaded
 * into mnirsrv. Outside of this, there is no persistence.
 *
 * This is a relatively lightweight implementation: Since there is no real
 * persistence and the compiler isn't really using the IFR to replace
 * include files, there's no code in here to deal with recompilation
 * vs. redefinition. In the future, the compiler will need a way to
 * invalidate IFR entries based on yrid so that it can toss something
 * out before it compiles it, preventing redefinition errors for
 * recompilation.
 *
 * Another hoky thing that may or may not be temporary is the treatment
 * of Object. Object is a pseudo object in CORBA and is implicitly the
 * base type of all interfaces. If users are to be able to reference it
 * in their IDL, we either need a definition of it in a global IDL
 * file somewhere, the compiler has to create it's own builtin defn,
 * or the repository has to create a builtin defn. Currently, we do the
 * latter: When the repository is opened, it is seeded with a definition
 * of Object. The compiler has to remember to special case for Object
 * when generating code so that it doesn't spit out any forward decls,
 * etc.
 *
 * The real name of this type is supposed to be CORBA::Object, but the
 * IDL specification also allows you to refer to it as just "Object". So,
 * repository knows about both, and both are equivalent to CORBA::Object.
 * All the lookup routines, etc. have been patched to return the CORBA::Object
 * yrobj when someone looks for ::Object. The CORBA spec actually says the
 * repository doesn't contain entries for Object, but I'd like to know
 * just how it is supposed to deal with things of type Object if it doesn't...
 *
 *   The repository object (yrdkRepository) points to itself for its
 * defined_in and repository fields. That way, you're assured of always
 * getting something valid for these two operations, and the respository
 * object is easily identifiable as the only object "defined in" itself.
 *
 * Bug #336120: The CORBA spec is decidedly wishy-washy on the subject of
 * nested types. The IDL syntax very clearly allows you to define a new
 * named type inside a struct or union, such as:
 *
 *   struct outer
 *   {
 *     struct inner
 *     {
 *       long whatever;
 *     } field;
 *   };
 *
 * However, the spec doesn't have much to say about about the scope of the
 * inner type. The only clear things it says are that (a) structs and
 * unions are scopes (of course, if only for their field names) and (b)
 * an enumeration type defined in the switch-type-spec of a union is 
 * scoped to (inside) the union.  I'm convinced that last one must have
 * been some psycho's pet peeve.
 *
 * Initially, I said phooey to that bit of illogic and decided that the
 * scope of a type defined in a struct or union was first enclosing file,
 * interface, or repository scope. I rationalized this decision by the
 * observation that the kind folks who defined the IFR IDL failed to make
 * structs and unions CORBA::Containers, so they quite clearly didn't
 * intend for them to be able to contain other types. 
 *
 * I still like that interpretation much better, but I've since had an
 * attack of conscience - OMG is serious about that union thing, and we
 * should be compliant. But I absolutely refuse to put some kind
 * of stupid special case in for enums in union switch-type-specs!
 *
 * So, the new world order is that structs and unions are containers.
 * Normally, their content lists are (thankfully) empty - the fields do
 * NOT show up on the content list. Only nested types show up there.
 * I have taken appropriate liberties with the IFR IDL to go with this.
 *
 * HISTORY
 * 01/03/96 kcoleman    Bug #434824: Free of nested types incorrect
 * 07/04/96 kcoleman	Support for context id lists
 * 02/27/96 kcoleman	Major roadwork for bug #336120: Structs and unions
 *                      are scopes and can have types defined inside them.
 * 11/25/95 kcoleman	Move Interface Id construction here from ycidl.
 * 11/18/95 kcoleman	Make rep id for primitives use primitive type kind
 * 10/23/95 kcoleman	Support for pragmas prefix, version, and ID.
 * 08/15/95 kcoleman	Beefed up yrAddBase.
 * 08/14/95 kcoleman	Added impl of yrLookupId, changed name lookup
 *			routines to deal with inheritance.
 * 07/??/95 kcoleman	Creation
 */
#ifndef SYSX_ORACLE
#include <sysi.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif
#ifndef YR_ORACLE
#include <yr.h>
#endif
#ifndef YR0_ORACLE
#include <yr0.h>
#endif


externdef ysidDecl(YR_EX_AMBIGUOUS) = "::YR_EX_AMBIGUOUS";
externdef ysidDecl(YR_EX_BADNAME) = "::YR_EX_BADNAME";
externdef ysidDecl(YR_EX_CONFLICT) = "::YR_EX_CONFLICT";
externdef ysidDecl(YR_EX_MULTIPLE) = "::YR_EX_MULTIPLE";
externdef ysidDecl(YR_EX_NOTFOUND) = "::YR_EX_NOTFOUND";
externdef ysidDecl(YR_EX_BADTYPE) = "::YR_EX_BADTYPE";
externdef ysidDecl(YR_EX_REPFULL) = "::YR_EX_REPFULL";
externdef ysidDecl(YR_EX_EXISTS) = "::YR_EX_EXISTS";
externdef ysidDecl(YR_EX_INVALIDID) = "::YR_EX_INVALIDID";
externdef ysidDecl(YR_EX_UNDEFINED) = "::YR_EX_UNDEFINED";
externdef ysidDecl(YR_EX_REDEFINED) = "::YR_EX_REDEFINED";
externdef ysidDecl(YR_EX_PSEUDO) = "::YR_EX_PSEUDO";


STATICF void yrSearchContainer( yrobj* or, CONST char* name, sb4 levels,
				yrdk limit_type, boolean exclude_inherited,
				yslst* matches);

/* ---------------------------------------------------------------------- */
/*
 * yrSetName - set the name of a repository object
 *
 * The string is copied into IFR-local storage and should be freed
 * using ysmGlbFree when the IFR destructors run.
 */

void yrSetName( yrobj* obj, CONST char* name)
{
  char* newName = (char*) ysmGlbAlloc(strlen(name) + 1, "yrobjName");
  DISCARD strcpy(newName, name);
  obj->name = newName;
}


/* ---------------------------------------------------------------------- */
/*
 * yrSetSrcnm - set the source name of a repository object
 */

void yrSetSrcnm( yrobj* obj, CONST char* name)
{
  char* newName = (char*) ysmGlbAlloc(strlen(name) + 1, "yrobjName");
  DISCARD strcpy(newName, name);
  obj->srcnm = newName;
}

/* ---------------------------------------------------------------------- */
/*
 * yrCloseRepository - close and release a repository
 *
 * Any space in memory occupied by the repository is freed, so <robj>
 * is no longer valid after calling this operation. This is just a
 * wrapper around yrDestroyObject, which is private to the repository.
 *
 * Not all the objects in the repository can be deleted in a single pass
 * because of interface inheritance: When deep freeing a derived interface,
 * there is no way to avoid touching the (possibly previously freed)
 * inherited members. So, all interface members are gathered into a list
 * which we cleanup at the end.
 */
void yrDestroyRepository( yrobj* robj, ysmff usrpFree, ysmff objFree)
{
  yslst* deferred = ysLstCreate();
  yrobj* o;

  yrDestroyObj( robj->repository, deferred, usrpFree, objFree);
  while ( (o = (yrobj*) ysLstDeq(deferred)) )
    yrDestroyObj( o, deferred, usrpFree, objFree);
  ysLstDestroy( deferred, (ysmff)0);
}



/* ---------------------------------------------------------------------- */
/*
 * yrGetAbsoluteName - Construct the absolute name of a repository object
 *
 * What the repository thinks of as an absolute name, everyone else thinks
 * of as a scoped name. That is, it is the absolute IDL name of an object,
 * not the name as it appears in a particular language mapping.
 *
 * Anonymous types are not handled consistently. The anonymous types are
 * string, array, and sequence types. Since string is also a primitive,
 * we're friendly here and return "string". For sequences, we build what
 * looks like the sequence type as specified in the IDL. For arrays, you
 * lose - NULL is returned.
 *
 * This is not a valid operation on a repository; NULL is returned.
 *
 */

char *yrGetAbsoluteName(yrobj *or)
{
  yslst* comps; 		/* name components */
  yrobj* o;
  ub4 len = 0;			/* total length of absolute name */
  char* name;
  ysle* le;
  char* elemName = (dvoid*)0;
  char* p;

  if ( (or->tag == yrdkArray) || (or->tag == yrdkRepository) )
    return (char*) 0;	/* anonymous types have no scoped name */
  else
    comps = ysLstCreate();

  if ( or == yrRepData(or->repository)->object )
    or = yrRepData(or->repository)->corba_object;

    /* figure out how much space we need, find all the name pieces */
  for ( o = or; o->tag != yrdkRepository; o = o->defined_in )
  {			 /* build up list of name components */
    ysLstPush(comps, (dvoid*) o->name);
    len += strlen(o->name);
  }

    /* special case handling for anonymouse strings and sequences */
  if ( or->tag == yrdkSequence )
  {
    char* seqName;

    elemName = yrGetAbsoluteName( or->data.seqval.elmtype);
    seqName = ysmGlbAlloc( strlen(elemName) + 11, "seqName");
    ysFmtStr( seqName, "sequence<%s>", elemName);
    ysmGlbFree( elemName);
    elemName = seqName;

    DISCARD ysLstDeq( comps);			/* replace empty seq name */
    ysLstEnq( comps, (dvoid*) elemName);	/* add element type name */
    len += strlen(elemName);
  }
  else if ( or->tag == yrdkString )
  {
    DISCARD ysLstDeq( comps);			/* replace empty string name */
    ysLstEnq( comps, (dvoid*) "string");
    len += 6;
  }

  len += ysLstCount(comps) * 2;			/* "::" separator */
  name = (char*) ysmGlbAlloc( (size_t)len+1, "absName");
  name[0] = '\0';

	/* construct the name */
  for (p = name, le = ysLstHead(comps); le; le = ysLstNext(le))
  {
    char* n = (char*) ysLstVal(le);

    p[0] = ':';
    p[1] = ':';
    p += 2;
    DISCARD strcpy( p, n);
    p += strlen(n);
  }

  if ( or->tag == yrdkSequence )
    ysmGlbFree( elemName);
  ysLstDestroy(comps, (ysmff)0);

  return name;
}


/* ---------------------------------------------------------------------- */
/*
 * yrParseScopedName - break a scoped name into it's components
 *
 * A copy of the name is made and stored in <buff>. A list of pointers
 * into <buff> is returned, each one pointing to the beginning of a
 * component of the name. For example:
 *
 *	Foo::bar::baz
 *      ^    ^    ^	pointers
 *
 * The first character of each separator is replaced with '\0', hence the
 * need to make a copy of <scoped>. 
 *
 * If the name begins with a separator, the separator itself forms the
 * first name component so the caller can distinguish this from a name
 * which begins with an id. In order to make this work, we allocate one
 * byte of extra space so we can copy in the leading separator, followed
 * by '\0'.
 *
 * If <scoped> is illformed, YR_EX_BADNAME is raised.
 */

void yrParseScopedName( CONST char* scoped, char** buff, yslst** ptrs)
{
  char* p1;
  char* p2;
  char* parseBuff;		/* copy of <scoped> */
  yslst* comps;			/* list of ptrs into parseBuff */

  if ( scoped == (char*)0 )
    yseThrow(YR_EX_BADNAME);	/* @@ badname is supposed to have a param */

  if ( strncmp(scoped, YR_SCOPED_SEP, YR_SCOPED_SEP_SIZE) == 0 )
  {	/* compensate for leading separator. Copy it + a null */
    parseBuff = ysmGlbAlloc( strlen(scoped)+2, "scopedName");
    strncpy( parseBuff, scoped, YR_SCOPED_SEP_SIZE);
    parseBuff[YR_SCOPED_SEP_SIZE] = '\0';
    strcpy( parseBuff+YR_SCOPED_SEP_SIZE+1, scoped+YR_SCOPED_SEP_SIZE);
    p1 = parseBuff + YR_SCOPED_SEP_SIZE + 1;
  }
  else
  {
    parseBuff = ysmGlbAlloc( strlen(scoped)+1, "scopedName");
    strcpy( parseBuff, scoped);
    p1 = parseBuff;
  }
  comps = ysLstCreate();

  while (*p1)
  {
    ysLstEnq( comps, (dvoid*) p1);
    p2 = strstr(p1, YR_SCOPED_SEP);
    if ( p2 )
    {
      p1 += (p2 - p1) + YR_SCOPED_SEP_SIZE;
      *p2 = '\0';		/* stomp separator to isolate name */
    }
    else
      break;
  } 
  if ( *p1 == '\0' )		/* ended with YR_SCOPED_SEP - error */
  {
    ysLstDestroy( comps, (ysmff)0);
    ysmGlbFree( parseBuff);
    yseThrow( YR_EX_BADNAME);
  }
  *buff = parseBuff;
  *ptrs = comps;
}


/* ---------------------------------------------------------------------- */
/*
 * yrContents - return the contents of a container object
 *
 * Return the entire contents, or a subset as determined by <limit_type>
 * and <exclude_inherited>. If no appropriate content items are found,
 * an empty list is returned.
 *
@@ should it return NULL instead to save the caller the hassle of cleaning
@@ up the space?
 */

yslst *yrContents(yrobj *or, yrdk limit_type, boolean exclude_inherited)
{
  yslst* result = ysLstCreate();
  ysle* le;

  if ( or->contents != (yslst*)0 )
  {
    for (le = ysLstHead(or->contents); le; le = ysLstNext(le))
    {
      yrobj* obj = (yrobj*) ysLstVal(le);

      if ( ((limit_type == yrdkall) || (obj->tag == limit_type)) &&
	  (!exclude_inherited || (obj->defined_in == or)) )
      {
        if ( obj != yrRepData(or->repository)->object )
	  ysLstEnq(result, (dvoid*) obj);
      }
    }
  }
  return result;
}


/* ---------------------------------------------------------------------- */
/*
 * yrLookupId - look up a repository object by repository id
 *
 * No smarts here: iterate over all the repository objects and 
 * compare their id's to the desired one.
@@ strictly speaking, outsiders should call this only with a yrdkRepository,
@@ so we should be checking that and calling down into something else that
@@ is suitable for recursion.
 */

yrobj *yrLookupId(yrobj *repository, CONST char *repid)
{
  ysle* le;
  yrobj* result = (yrobj*) 0;

  if ( !repid || (strlen(repid) == 0) || !repository->contents )
    return (yrobj*) 0;

  for ( le = ysLstHead(repository->contents); le; le = ysLstNext(le))
  {
    yrobj* obj = (yrobj*) ysLstVal(le);

    if ( strcmp( obj->repid, repid) == 0 )
    {
      result = obj;
      break;
    }
    else if ( yrIsContainer(obj) )     /* Recurse thru container contents */
    {
      result = yrLookupId( obj, repid);
      if ( result )
        break;
    }
  }

  if ( result == yrRepData(repository->repository)->object )
    result = yrRepData(repository->repository)->corba_object;
  return result;
}


/* ---------------------------------------------------------------------- */
/*
 * yrGetPrimitive - Get an IFR obj representing a primitive type
 *
 * Primitive types (long, short, etc.) are implicitly defined in the
 * repository, but we create them lazily when someone asks for the,
 * rather than all at once in the beginning. So, this function first
 * searches the repository for the requested primitive kind. Note
 * that if it is defined, it will only occur at the top level of the
 * repository.
 *
 * If the repository does not already contain a defn for this type, we
 * create one and add it to the repository.
 *
 */

yrobj *yrGetPrimitive(yrobj *repository, yrpk kind)
{
  yrobj* match = (yrobj*)0;
  ysle* le;
  yslst* decls = repository->repository->contents;

  if ( decls != (yslst*)0 )
  {
    for ( le = ysLstHead(decls); le; le = ysLstNext(le) )
    {
      yrobj* obj = (yrobj*) ysLstVal(le);
      if ( (obj->tag == yrdkPrimitive) && (obj->data.pval.kind == kind) )
      {
        match = obj;
        break;
      }
    }
  }
  
  if ( !match )
    match = yrCreatePrimitive( repository, kind);
  return match;
}


/* ---------------------------------------------------------------------- */
/*
 * yrAddBase - add a base interface
 *
 * <base> should be a base interface of derived interface <intf>. This
 * process will check that <base> is not already a direct base of
 * of <intf>, and that there are not attribute or operation name
 * conflicts between <base> and existing bases.
 *
 * The CORBA 1.2 spec states: "It is currently illegal to inherit from
 * two interfaces with the same operation or attribute name." The contents
 * of <intf> at this point can only be members of other base classes, so
 * we can check for this case by iterating over the contents. Need not do
 * anything special for indirectly inherited names as they're already on
 * the content list of the base class.
 *
 * Only duplicate op and attr names cause an exception to be raised, but
 * any sort of ambiguous name requires special handling. If an inherited
 * name is ambiguous, it is not added to the contents of the derived
 * interface, and the inherited name it conflicts with is removed. This
 * accurately reflects the fact that the ambiguous name cannot be
 * referenced without first qualifying it by the base interface name. e.g.,
 *
 *    interface A { typedef long conflict; };
 *    interface B { typedef char conflict; };
 *    interface C : A,B {};
 *
 * C::conflict is always ambiguous. Must be referenced as A::conflict or
 * B::conflict.
 */

void yrAddBase(yrobj *intf, yrobj *base)
{
  ysle* le;
  yslst* matches;

  if ( base->tag == yrdkAlias )
    base = yrGetAliasBaseType( base);

  if ( (base == yrRepData( intf->repository)->object) ||
       (base == yrRepData( intf->repository)->corba_object) )
    yseThrow( YR_EX_PSEUDO);         /* Object can't be explicit base type */

  if ( (intf->tag == yrdkInterface) && (base->tag == yrdkInterface) )
  {
    if ( intf->data.intfval.bases == (yslst*)0 )
       intf->data.intfval.bases = ysLstCreate();

      /* make sure this isn't already one <intf>'s direct bases */
    for (le = ysLstHead(intf->data.intfval.bases); le; le = ysLstNext(le))
      if ( ((yrobj*) ysLstVal(le)) == base )
	yseThrow(YR_EX_MULTIPLE);

      /* check for duplicate names, add inherited members */
    ysLstEnq(intf->data.intfval.bases, (dvoid*) base);
    if ( base->contents )
    {
      for ( le = ysLstHead( base->contents); le; le = ysLstNext(le))
      {		/* check for duplicate ops and attrs */
        yrobj* mem = (yrobj*) ysLstVal(le);
	matches = yrLookupName( intf, mem->name, YR_SHALLOW_LOOKUP, 
				mem->tag, FALSE);
        if ( matches )
        {
          if ( (ysLstCount( matches) == 1) && (mem->defined_in == 
		((yrobj*)ysLstVal(ysLstHead( matches)))->defined_in) )
             ysLstDestroy( matches, (ysmff)0);	/* already inherited */
	  else if ( (mem->tag == yrdkOperation) || (mem->tag == yrdkAttribute))
	  {		/* duplicate op or attr => error */
	    ysLstPush( matches, (dvoid*) mem);
	    yseThrowObj( YR_EX_CONFLICT, matches);
          }
          else
          {	/* ambiguous name. Don't add new one, remove old one(s). */
            ysle* ce;	/* interface content list element */
            ysle* me;	/* matches list element */
          
	    for ( me = ysLstHead( matches); me; me = ysLstNext(me))
            {
              yrobj* match = (yrobj*) ysLstVal(me);
	      for ( ce = ysLstHead( intf->contents); ce; ce = ysLstNext(ce))
		if ( (yrobj*)ysLstVal(ce) == match )
		{	/* found the matching ambiguity. Axe it. */
		  ysLstRem( intf->contents, ce);
		  break;
		}
            }
            ysLstDestroy( matches, (ysmff)0);
          }
        }  /* if matches */
	else	/* only add to content list if there's no conflict */
          yrContainerAdd( intf, mem);
      }
    }
  }
  else		/* someone did something stupid */
  {
    yrdk kind = yrdkInterface;
    yseThrowObj( YR_EX_BADTYPE, kind);
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yrGetAliasBaseType - traverse an alias (typedef) until you find the
 * 	base primitive, interface, module, struct, union, enum, array,
 *	or sequence type.
 */

yrobj* yrGetAliasBaseType( yrobj* alias)
{
  while ( alias->tag == yrdkAlias )
    alias = alias->data.aval.type;
  return alias;
}



/* ---------------------------------------------------------------------- */
/*
 * yrLookup - Look up a scoped name relative to an IFR object.
 *
 * This is equivalent to Container::lookup in the OMG IFR spec: "The
 * lookup operation locates a definition relative to this container
 * given a scoped name using IDL's name scoping rules. An absolute name
 * (beginning with "::") locates the definition relative to the enclosing 
 * repository."
 *
 * In other words, this essentially does an outward search using the
 * standard name lookup rules on the portion of the scoped name which
 * represents a scope, then an inward search through the located scope.
 *
 * It differs from yrLookupName in that (a) the name can be scoped, and
 * (b) the scope search is outward rather than inward. However, it is
 * built on top of yrLookupName - yrLookupName is used to search for
 * the individual name components as each scope is located.
 *
 * Example: Give A::B::C, locate A by an outward search of the enclosing
 * scopes (walks defined_in chain), then locate B within A via an inward
 * search, finally locate C within B via an inward search.
 */

yrobj *yrLookup(yrobj *or, CONST char *scoped)
{
  yslst* comps;		/* list of <scoped>'s name components */
  char* parseBuff;	/* copy of <scoped>, set by yrParseScopedName */
  ysle* le;
  yslst* matches;
  boolean foundOuter;	/* Have we located the outermost name component? */

    /* Break the scoped name into it's components */
  yrParseScopedName( scoped, &parseBuff, &comps);
  if ( strcmp(YR_SCOPED_SEP, (char*)ysLstVal( ysLstHead(comps))) == 0 )
  {	/* do absolute name lookup, relative to repository */
    or = or->repository;
    ysLstPop(comps);
  }

    /* lookup each component in scope of the previous one until done */
  foundOuter = FALSE;
  for (le = ysLstHead(comps); le; le = ysLstNext(le))
  {
    CONST char* name = (char*) ysLstVal(le);
    do
    {
      matches = yrLookupName( or, name, (sb4)1, yrdkall, FALSE);
      if ( !matches || (ysLstCount( matches) == 0) )
      {					/* no match found, keep looking */
	  if ( matches )
	    ysLstDestroy(matches, (ysmff)0);
	  if ( foundOuter || or->tag == yrdkRepository )
	  {
	    ysLstDestroy(comps, (ysmff)0);
	    ysmGlbFree( parseBuff);
	    yseThrow(YR_EX_NOTFOUND);
          }
	  else if ( !foundOuter )	/* keep searching outward */
	    or = or->defined_in;	/* next enclosing scope */
	  /* dangling else already taken care of, above */
      }
      else if ( ysLstCount(matches) == 1 )
      {					/* exactly 1 match found */
	foundOuter = TRUE;		/* search inward from here on */
	or = (yrobj*) ysLstVal( ysLstHead(matches));
	ysLstDestroy(matches, (ysmff)0);
      }
      else				/* multiple matches found */
      {
	ysLstDestroy(comps, (ysmff)0);
	ysmGlbFree( parseBuff);
	yseThrowObj(YR_EX_AMBIGUOUS, matches);
      }
    } while ( !foundOuter );
  }

  ysLstDestroy(comps, (ysmff)0);
  ysmGlbFree( parseBuff);

  if ( or == yrRepData(or->repository)->object )
    or = yrRepData(or->repository)->corba_object;
  return or;
}

/* ---------------------------------------------------------------------- */
/*
 * yrSearchContainer - Lookup <name> in <or>
 *
 * This does the real work for yrLookupName. If <or> is not a Container
 * (repository, module, or interface), this routine does nothing. If it
 * is a qualifying container, the container contents are searched for
 * one or more matches, recursing to handle content items which are
 * themselves containers.
 *
 * <matches> is a list of matching objects; it must be allocated by the
 * caller.
 *
 * This may look a little odd in that we recurse almost unconditionally
 * on object contents. However, this is safe because IDL semantics are
 * such that we can never have a module or interface inside an interface,
 * so we're never in danger of doing something wierd like searching in
 * an inherited container when <exclude_inherited> is TRUE - there is
 * no such thing as an inherited container.
 */

STATICF void yrSearchContainer( yrobj* or, CONST char* name, sb4 levels,
			yrdk limit_type, boolean exclude_inherited,
			yslst* matches)
{
  ysle* le;

  if ( or->tag == yrdkAlias )
    or = yrGetAliasBaseType( or);
  
  if ( or->contents && yrIsContainer( or) )
  {
    boolean checkInherited = !(exclude_inherited&&(or->tag == yrdkInterface));
    boolean checkKind = limit_type != yrdkall;

    for (le = ysLstHead(or->contents); le; le = ysLstNext(le))
    {
      yrobj* obj = (yrobj*) ysLstVal(le);
      if ( (checkInherited || (obj->defined_in == or)) &&
	   ( !checkKind || (obj->tag == limit_type)) &&
	   (strcmp( name, obj->name) == 0) )
      {
        if ( (or->tag == yrdkRepository) &&
             ( obj == yrRepData(or)->object) )
	  ysLstEnq( matches, (dvoid*)yrRepData(or)->corba_object);
        else
	  ysLstEnq( matches, (dvoid*)obj);
      }
      if ( levels == YR_DEEP_LOOKUP )
	yrSearchContainer( obj, name, levels, limit_type, 
			   exclude_inherited, matches);
    }
  }
  return;
}

/* ---------------------------------------------------------------------- */
/*
 * yrLookupName - Lookup <name> relative to <or>
 *
 * This differs from yrLookup in that it looks inward through the 
 * contained objects, rather than outward. <name> should NOT be a
 * scoped name.
 *
 * If no matches are found, a null pointer is returned.
@@ can <name> be a scoped name? I think not.
 */

yslst *yrLookupName(yrobj *or, CONST char *name, sb4 levels,
                    yrdk limit_type, boolean exclude_inherited)
{
  yslst* result = ysLstCreate();

  yrSearchContainer( or, name, levels, limit_type, exclude_inherited, result);
  if ( ysLstCount( result) == 0 )
  {
    ysLstDestroy( result, (ysmff)0);
    result = (dvoid*) 0;
  }
  return result;
}


/* ---------------------------------------------------------------------- */
/*
 * yrGetPrimitiveName - map a primitive type kind to it's IDL name
 *
 * This is the name of a primitive type in the IDL, not in a specific
 * language mapping.
 */

char* yrGetPrimitiveName( yrpk kind )
{
  char* name = ysmGlbAlloc( 15, "primitive name");
  			/* strlen("unsigned short") + 1 */
  switch ( kind )
  {
    case yrpkvoid:     strcpy( name, "void"); break;
    case yrpkshort:    strcpy( name, "short"); break;
    case yrpklong:     strcpy( name, "long"); break;
    case yrpkushort:   strcpy( name, "unsigned short"); break;
    case yrpkulong:    strcpy( name, "unsigned long"); break;
    case yrpkfloat:    strcpy( name, "float"); break;
    case yrpkdouble:   strcpy( name, "double"); break;
    case yrpkboolean:  strcpy( name, "boolean"); break;
    case yrpkchar:     strcpy( name, "char"); break;
    case yrpkoctet:    strcpy( name, "octet"); break;
    case yrpkany:      strcpy( name, "any"); break;
    case yrpkstring:   strcpy( name, "string"); break;
    case yrpkTypeCode: strcpy( name, "TypeCode"); break;
    case yrpklonglong: strcpy( name, "long long"); break;
    default:
      yseThrow(YS_EX_FAILURE);
  }
  return name;
}


/* ---------------------------------------------------------------------- */
/*
 * yrAssignId - Assign a repository id to a repository object
 *
 * All yrid requests MUST go through here. The ID format and the
 * unique repository object sequence numbers are controlled from here.
 *
 * The format of a Repository ID follows the CORBA 2.0 spec's suggestions:
 *
 * For the "magic" types like the primitives and anonymous types, it is:
 *
 *     LOCAL:<seqnum>
 *
 * Where <seqnum> is a sequence number maintained by the repository and
 * incremented for each local id that is created. One trick here: The
 * low sequence numbers are reserved for the primitive types so they
 * always have the same repid..."LOCAL:<yrpk>".
 *
 * Named, user-defined entities in the repository have the following
 * default identifier format:
 *
 *     IDL:<prefix>/<name>:<vers>
 *
 * Where <prefix> defaults to an empty string, but can be set by the
 * user via #pragma prefix; <name> is the absolute name of the entity
 * with each component separated by a '/' (so A::B becomes A/B), and
 * <vers> is 1.0 by default but may be set by the user via #pragma version.
 *
 * If the sequence number overflows, the repository is "full" and an
 * exception is raised.
 *
 * RAISES
 * YR_EX_EXISTS - <robj> already has a repository id.
 * YR_EX_REPFULL - repository cannot contain any more objects
 */

void yrAssignId( yrobj* scope, yrobj* obj, boolean usePrefix)
{
  char* newid;

  if ( obj->repid )		/* obj already has an id */
    yseThrow( YR_EX_EXISTS);

  if ( obj->tag == yrdkPrimitive )
  {
    newid = ysmGlbAlloc( 9, "yrid");    /* LOCAL: + 2 for primitive kind */
    ysFmtStr( newid, "LOCAL:%u", yrPrimData(obj).kind);
  }

  else if ( usePrefix )              /* use IDL format */
  {
    char* pfx = scope->prefix ? scope->prefix : "";
    yslst* names;
    ysle* le;
    sword namesz = 0;
    char* p;
    CONST char* vers = (obj->version && (strlen(obj->version) > (size_t)0)) ?
                       obj->version : "1.0";

      /* Figure out how long the names is with a '/' between each piece */
    names = yrGetNameComponents(obj);
    for (le = ysLstHead(names); le; le = ysLstNext(le))
      namesz += strlen( yrGetName( (yrobj*)ysLstVal(le))) + 1;
    namesz--;                          /* no '/' on leading component */

    newid = ysmGlbAlloc( strlen(pfx) + namesz + strlen(vers) + 6, "yrid");
    ysFmtStr( newid, "IDL:%s", pfx);
      /* add the absolute name */
    p = newid + strlen(newid);
    for (le = ysLstHead(names); le; le = ysLstNext(le))
    {
      yrobj* o = (yrobj*) ysLstVal(le);

      DISCARD strcpy( p, yrGetName(o));
      p += strlen(yrGetName(o));
      *p = '/';
      p++;
    }
    ysLstDestroy( names, (ysmff)0);
      /* add the version */
    ysFmtStr( p - 1, ":%s", vers);      /* -1 to stomp trailing slash */
  }
  else                                  /* use local format */
  {
    char seq[25];
    yrobj* rep = scope->repository;

    if ( yrRepData(rep)->seqnum == YR_SEQ_MAX )
      yseThrow( YR_EX_REPFULL );
    ysFmtStrl( seq, 25, "%u", yrRepData(rep)->seqnum);
    newid = ysmGlbAlloc( strlen(seq) + 7, "yrid");
    ysFmtStr( newid, "LOCAL:%s", seq);
    yrRepData(rep)->seqnum++;
  }
  obj->repid = (yrid*) newid;
}


/* ---------------------------------------------------------------------- */
/*
 * yrGetNameComponents - make a list of all the components of an obj name
 *
 * Name components are gathered by walking the "defined_in" chain from
 * <obj> to the enclosing repository. The list of yrobj's is ordered
 * from outermost to innermost scope; <obj> itself will always by the
 * last item on the list.
 *
 * Why do we bother with this? Because if you're doing something like
 * building a scoped name, it's a hell of a lot easier to do front to
 * back than back to front!
 *
 * The caller is reponsible for garbage collecting the returned list
 * by calling ysLstDestroy. The list elements belong to the repository
 * and should not be garbage collected. They're on loan to the caller. :-)

 * If <obj> is a repository, this action isn't valid and YR_EX_BADTYPE
 * is raised.
 */

yslst* yrGetNameComponents( yrobj* obj)
{
  yslst* comps;
  yrobj* o;

  if ( obj->tag == yrdkRepository )
    yseThrow( YR_EX_BADTYPE);

  if ( obj == yrRepData(obj->repository)->object )
    obj = yrRepData(obj->repository)->corba_object;
  comps = ysLstCreate();
  for (o = obj; o->tag != yrdkRepository; o = o->defined_in)
  {
    ysLstPush(comps, (dvoid*)o);
  }
  return comps;
}


/* ---------------------------------------------------------------------- */
/*
 * yrSetSrcInfo - Set source file and line number info on an IFR object
 *
 * The string gets copied. Source file info is not allowed on a repository
 * object or a primitive.
@@ what about sequences, strings, and arrays? They're anonymous, but
@@ they still have associated source info in some sense...
 */

void yrSetSrcInfo( yrobj* obj, CONST char* srcnm, sword lineno)
{
  if ( (obj->tag != yrdkRepository) && (obj->tag != yrdkPrimitive) )
  {
    if ( srcnm != (char*)0 )
    {
      char* newName = (char*) ysmGlbAlloc(strlen(srcnm) + 1, "yrsrcnm");
      DISCARD strcpy(newName, srcnm);
      if ( obj->srcnm )
        ysmGlbFree( obj->srcnm);
      obj->srcnm = newName;
    }
    obj->line = lineno;
  }
  else
    yseThrow( YR_EX_BADTYPE);
}

/* ---------------------------------------------------------------------- */
/*
 * yrSetId - Set an object's yrid
 *
 * This operation is generally provoked by a #pragma ID in input IDL.
 * The ID format must conform to that specified in the CORBA 2.0 spec:
 *
 *   <format>:<name>:<version>
 *
 * Where <format> is one of IDL, DCE, or LOCAL, <name> is an
 * arbitrary sequence not including a ':', and version is also an
 * arbitrary sequence not including a ':'. If version is missing,
 * "1.0" will be used.
 *
 * The repository is in sole control of id's for primitive and
 * anonymous types, so attempts to set the yrid for such an object
 * causes YR_EX_BADTYPE to be raised.
@@ Should just anybody be able to do this?
@@ Are there situations when you might want to allow this operation
@@   to go through? What if I create the object and you change it's
@@   id? Can that even happen?
@@ Can the user use LOCAL format? 
 */

void yrSetId( yrobj* obj, CONST char* newid)
{
  CONST char* p;
  sword fmtsz;

  if ( obj == (dvoid*)0 )
    return;

  switch ( yrGetKind(obj) )
  {
    case yrdkRepository:
    case yrdkPrimitive:
    case yrdkSequence:
    case yrdkArray:
    case yrdkString:
      yseThrow( YR_EX_BADTYPE);
      break;
    default:
      for ( p = newid; *p != '\0'; p++)        /* find end of format id */
        if ( *p == ':' )
          break;
      if ( *p == '\0' )
        yseThrow( YR_EX_INVALIDID);
      fmtsz = p - newid;
      if ( !((fmtsz == 3) && ((strncmp(newid, "IDL", fmtsz) == 0) ||
	     (strncmp(newid, "DCE", fmtsz)))) &&
	   !((fmtsz == 5) && (strncmp( newid, "LOCAL", fmtsz) == 0)) )
	yseThrow( YR_EX_INVALIDID);

      if ( obj->repid )
	ysmGlbFree( obj->repid);
      for ( p++; *p != '\0'; p++)        /* find end of name */
        if ( *p == ':' )
          break;

      if ( *p == '\0' )                        /* no vers comp, add one */
      {
        obj->repid = (char*) ysmGlbAlloc( strlen(newid) + 5, "repid");
        DISCARD ysFmtStr( obj->repid, "%s:1.0", newid);
      }
      else                                     /* incls vers, just copy id */
      {
	obj->repid = (char*) ysmGlbAlloc( strlen(newid) + 1, "repid");
	DISCARD strcpy( obj->repid, newid);
      }
      break;
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yrSetPrefix - Set the yrid prefix on a module, interface, or repository.
 *
 * This is only a valid prefix on a container scope (e.g. one in which
 * another type can be defined). File scope is dealt with by setting the 
 * prefix on the repository object.
 *
 * yrSetPrefix is intended to be called by the IDL compiler when it sees
 * a #pragma prefix. This pragma specifies a prefix to be added to the
 * yrid's of objects added to the repository within the scope of the prefix.
 * As usual, the CORBA 2.0 spec is pretty sloppy about how the scoping works:
 *
 * "The specified prefix applies to repository ids generated after the
 * pragma until the end of the current scope is reached or another
 * prefix pragma is encountered."
 *
 * There's a lot that isn't said there. Do they stack? e.g. When you leave
 * an inner scope, is the outer scope's prefix restored? By scope, do they
 * really mean file, module, interface, struct, union, and parameter list?
 * If there's a pragma prefix in an include file, is it still in effect
 * after the include file text?
 *
 * For a cross between ease of implementation and user utility, we 
 * implement #pragma prefix as follows, in conjunction with the IDL compiler:
 *
 * 1. They nest (stack) like scopes do. So, if a prefix is in effect and
 * we encounter another pragma in an inner scope, the outer scope's
 * prefix goes back into effect when we leave the inner scope.
 *
 * 2. We pay no attention to file scopes. Or, more accurately, we act
 * as if there is one big file scope, regardless of whether the text
 * came from an include file or not. This really isn't good, but by the
 * time we get to semantic analysis, it's a lot harder to deal with this.
 * In other words, I'm ducking. Improving this is a good exercise for
 * the reader.
 *
 * 3. We also pay no attention to parameter decl scopes: They introduce no
 * new (named) IFR objects.
 *
 * Once a prefix is set (via calling this function) it is inherited by
 * every module and interface from its parent scope. This is done in the
 * object creation functions for the container types.
 */

void yrSetPrefix( yrobj* obj, CONST char* prefix)
{
  if ( !prefix )
    return;
  if ( yrIsContainer( obj) )
  {
    size_t newsz = strlen(prefix) + 1;
    if ( obj->prefix )
    {
      if ( newsz >= strlen(obj->prefix) )
        ysmGlbRealloc( obj->prefix, newsz);
      /* else will fit in previous memory block */
    }
    else
      obj->prefix = (char*) ysmGlbAlloc(newsz, "yrpfx");
    DISCARD strcpy( obj->prefix, prefix);
  }
  else
    yseThrow( YR_EX_BADTYPE);
}


/* ---------------------------------------------------------------------- */
/*
 * yrSetVersion - Set an object's version id
 *
 * This operation is generally called in reposnse to a #pragma version
 * in the user's IDL. Default version id is "1.0". You cannot set the
 * version on a primitive or anonymous type; attempts to do so cause
 * YR_EX_BADTYPE to be raised.
 *
 * In addition to setting the version field on the object, the repository
 * id is updated to reflect the version. It is possible that the current
 * repository id doesn't include a version component (if it was set by
 * #pragma ID to some funny format). In this case, we add a version
 * component.
 */

void yrSetVersion( yrobj* obj, CONST char* newver)
{
  if ( obj == (dvoid*)0 )
    return;

  switch ( yrGetKind(obj) )
  {
    case yrdkRepository:
    case yrdkPrimitive:
    case yrdkSequence:
    case yrdkArray:
    case yrdkString:
      yseThrow( YR_EX_BADTYPE);
      break;
    default:
    {
      if ( obj->version )
	ysmGlbFree( obj->version);
      obj->version = (char*) ysmGlbAlloc( strlen(newver) + 1, "yrvers");
      DISCARD strcpy( obj->version, newver);

      if ( obj->repid )               /* update the rep id of this obj */
      {
	char* p;
        sword oldIdSz = strlen(obj->repid);
        for (p = obj->repid + oldIdSz - 1; p != obj->repid; p--)
          if ( *p == ':' )
            break;
        if ( p != obj->repid )        /* Found the vers component */
        {
          sword vdiff;
          sword vstart;

          p++;                       /* p points to start of old vers string */
          vdiff = strlen(newver) - strlen(p+1);
          if ( vdiff > 0 )           /* new is longer than old */
          {
	    vstart = p - obj->repid;      /* save offset from start of repid */
            obj->repid = ysmGlbRealloc( obj->repid, oldIdSz + vdiff + 1);
            p = obj->repid + vstart;      /* reset p in case repid moved */
          }
          DISCARD strcpy(p, newver);
        }
        else                          /* there was no vers component */
        {
          obj->repid = ysmGlbRealloc( obj->repid, oldIdSz + strlen(newver) +2);
          obj->repid[oldIdSz] = ':';
          DISCARD strcpy( obj->repid + oldIdSz + 1, newver);
        }
      }
      break;
    }
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yrGetAncestors - build a list of the interfaces in the inheritance graph
 *
 * Each ancestor appears on the list only once. This list is unordered.
 * <ancestors> should be allocated by the caller.
 *
 * This isn't the world's fastest algorithm, but is predicated on the
 * assumption that most inheritance hierarchies aren't going to be very
 * deep and thus both the base lists and the ancestor list will stay
 * small, on the order of < 5.
 */

void yrGetAncestors( yrobj* intf, yslst* ancestors)
{
  yslst* bases;
  ysle* le;

  bases = yrInterfaceData(intf).bases;
  if ( !bases || (ysLstCount(bases) == 0) )
    return;

  for ( le = ysLstHead(bases); le; le = ysLstNext(le))
  {
    yrobj* base = (yrobj*) ysLstVal(le);
    boolean doneThat = FALSE;
    ysle* granny;

    for ( granny = ysLstHead(ancestors); granny; granny = ysLstNext(granny))
    {
      if ( base == (yrobj*) ysLstVal(granny) )
      {
        doneThat = TRUE;
        break;
      }
    }
    if ( !doneThat )
    {
      ysLstEnq( ancestors, (dvoid*) base);
      yrGetAncestors( base, ancestors);
    }
  }
}

/* ---------------------------------------------------------------------- */
/*
 * yrCreateIntfId - Build an interface id
 *
 * This function is really private between the compiler and the IFR since
 * the nature of an interface id is internal to the system. The compiler
 * must know what they look like so it can spit them into the stubs; the
 * IFR server must know what they look like so it can manipulate them to
 * satisfy DII queries (see yrdii.c).
 *
 * An interface id is the scoped name of an interface, followed by a '/'
 * delimited list of ancestor scoped names:
 *
 *   <intf-name>{/<base1-name>/<base2-name>/.../<baseN-name>}
 *
 * The ancestor names are used by yoNarrow to determine whether or not
 * a narrowing operation is legitimate. This is thus not any sort of
 * representation of the inheritance graph, but an unordered list of
 * the interfaces in the graph, each appearing only once on the list.
 * This list is constructed by yrGetAncestors.
 */

ysid* yrCreateIntfId( yrobj* intf)
{
  ub4 len;
  yslst* names = ysLstCreate();
  yslst* ancestors = ysLstCreate();
  char* intfnm;
  ysid* p;
  ysid* result;
  char* name;
  yrobj* o;

  len = 0;
  yrGetAncestors( intf, ancestors);
  while ( (o = (yrobj*)ysLstDeq( ancestors)) )
  {
    name = yrGetAbsoluteName(o);
    len += strlen(name) + 1;       /* name plus '/' separator */
    ysLstEnq(names, (dvoid*) name);
  }
  ysLstDestroy(ancestors, (ysmff)0);

  intfnm = yrGetAbsoluteName(intf);
  len += strlen( intfnm) + 1;       /* name plus null terminator */
  result = (ysid*) ysmGlbAlloc( len, "ysid");
  strcpy( result, intfnm);
  p = result + strlen(intfnm);
  ysmGlbFree(intfnm);
  
  while ( (name = (char*) ysLstDeq( names)) )
  {
    DISCARD ysFmtStr(p, "/%s", name);
    p += strlen(name) + 1;
    ysmGlbFree(name);
  }
  *p = '\0';
  ysLstDestroy(names, (ysmff)0);
  return result;
}

/* ---------------------------------------------------------------------- */
/*
 * yrIsContainer - is this object a container object
 *
 * A container is an IFR object which defines a scope enclosing other
 * items. All containers represent a scope, but all scopes are not
 * containers. The containers are: Repository, module, interface, struct,
 * and union. The Repository may be said to represent file scope in some
 * sense; parameter scope is not represented.
 */
boolean yrIsContainer( yrobj* obj)
{
  switch (yrGetKind(obj))
  {
    case yrdkRepository:
    case yrdkModule:
    case yrdkInterface:
    case yrdkStruct:
    case yrdkUnion:
    case yrdkException:
      return TRUE;
    default:
      return FALSE;
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yrSetOpCtxtList - Add list of context id's to an operation
 *
 * <op> must be of type yrdkOperation or else YR_EX_BADTYPE is raised.
 * If <op> already has a context id list, the exception YR_EX_EXISTS
 * is thrown - you can only set context data once.
 *
 * The passed in list is consumed by this operation. The IFR takes
 * responsibility for the list and all strings it contains.
 */
void yrSetOpCtxtList( yrobj* op, yslst* ctxts)
{
  if ( yrGetKind(op) == yrdkOperation )
  {
    if ( yrOpData(op).ctxts )
    {
      if ( ysLstCount( yrOpData(op).ctxts) == 0 )
      {
        ysLstDestroy( yrOpData(op).ctxts, (ysmff)0);
        yrOpData(op).ctxts = ctxts;
      }
      else
        yseThrow( YR_EX_EXISTS);
    }
    else
      yrOpData(op).ctxts = ctxts;
  }
  else
  {
    yrdk kind = yrdkOperation;
    yseThrowObj( YR_EX_BADTYPE, kind);
  }
}
