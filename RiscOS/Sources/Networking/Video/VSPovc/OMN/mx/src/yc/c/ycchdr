/* Copyright (c) 1995 by Oracle Corporation.  All Rights Reserved.
 *
 * ycchdr.c - generation of header output (C language mapping)
 *
 * NOTES
 *	Any typedefs or #defines generated in the header must be wrapped
 *	in #ifndef guards to insure there are no duplicate declarations
 *	such as might occur if the user includes two generated header
 *	files which contain references to the same interface.
 *
 *	Declarations which come from source files, whether included
 *	headers or the current translation unit, are guaranteed to
 *	occur in the correct order on the list of newobjects (ctx->newobjs).
 * 	Alas, the same cannot be said for names that are implicitly
 *	No code is generated for implicit declarations (from the IFR);
 *	the user has to #include the appropriate stuff himself.
 *
 *	Function naming convention: yccGenFooDecl generates public header
 *	declarations for an IR object of type foo (e.g. yccGenIntfDecl).
 *	yccGenFooCStub generates client stubs, yccGenFooSStub generates
 *	server stubs, and yccGenFooSkel generates server skeleton code.
 *	Obviously, every object type doesn't require all the functions.
 *
 * Inheritance
 * -----------
 * One of the sneakier things that goes in here is code gen for inherited
 * types. Unfortunately, the IFR is currently set up so that when a type
 * is inherited, both the base and derived interface point to the same
 * IFR object. Once you tunnel down past the derived scope, you can no
 * longer tell whether you're generating code for the derived object or
 * the base one.
 *
 * To get around this, yccGenIntfDecl sets ctx->derived to point to the
 * the derived interface object when we are generating code for an
 * inherited member. Thus, most of the code gen routines below will
 * check ctx->derived as their first act and generate differenet code
 * as follows:
 *
 * When generating code for a non-inherited type, we generate a full
 * set of C declarations, such as a typedef, type code declaration, and
 * prototype for support functions like T__copy and T__free. When
 * generating code for an inherited type, we just generate macro wrappers
 * around the base typedef, type code, and support functions.
 *
 * This, of course, impacts what things get real code generated for them
 * in the stub files as well. Be sure to keep these three in sync.
 *
 * Aliases
 * -------
 * Aliases are pesky little buggers, just like inherited types. To avoid
 * code bloat, we really don't want to generate new support
 * functions for every stop along an alias chain. So, we try to generate
 * real declarations/definitions only for the base type and use macro
 * wrappers for the aliases.
 *
 * The predefined (primitive) types also have predefined typecodes; we
 * never need to generate new ones for them.
 *
 * HISTORY
 * 12/12/96 kcoleman	Call filters from stubs
 * 11/28/96 kcoleman	Bug #426687: Change handling of output files
 * 09/27/96 kcoleman	Strict CORBA naming
 * 09/19/96 kcoleman	Release field for any and seq in CORBA 2.0
 * 08/20/96 kcoleman	Bug #393905: Change gen of typecode and id defns
 * 07/10/96 kcoleman	Make generated headers safe for C++
 * 06/27/96 kcoleman	Bug #377748: No more global external data
 * 06/13/96 kcoleman	Bug #369357: Make __impl static & const in template
 * 06/06/96 kcoleman	Bug 369357: Revamp I/O to limit line length
 * 05/15/96 kcoleman	Bug #367030: Union fields with multiple case labels
 *                      not generated correctly.
 * 04/08/96 kcoleman	Use ysRecord for error reporting.
 * 03/25/96 kcoleman	Support for static typecode option.
 * 03/18/96 kcoleman	Make modules code gen objects
 * 02/27/96 kcoleman	Bug #336120: Structs and unions have contents
 * 02/05/96 kcoleman	Support for CORBA 2.0
 * 12/06/95 kcoleman	__copy/__free not gen'd for intf's from include files
 * 11/07/95 kcoleman	Implement distinct Oracle and CORBA naming styles
 * 11/06/95 kcoleman    Beef up typecode gen for aliases & inherited types
 * 11/03/95 kcoleman	Add __Free and __Copy functions
 * 11/02/95 kcoleman	Embed '*' in intf typedef, add CORBA/BOA stubs
 * 10/13/95 kcoleman	Support for TypeCode pseudo-objects
 * 10/04/95 kcoleman	Added gen of base func decls to yccGenDerivedFunc
 * 09/27/95 kcoleman	Make -e behavior the default behavior
 */

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCC0_ORACLE
#include <ycc0.h>
#endif
#ifndef YSSTR_ORACLE
#include <ysstr.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif

STATICF void yccGenDerivedFunc( ycctx* ctx, yccfp* fp, CONST char* dname, 
                                CONST char* bname, yrobj* bintf, 
                                yrobj* rettype, yslst* pars, yslst* ctxs);
STATICF void yccGenCGObjs( ycctx* ctx, yccfp* fp, yslst* objs);

/* ---------------------------------------------------------------------- */
/*
 * yccGenSimpleDerived - gen code for a simple derived name (not an op)
 *
 * Everything except op and attr names map into simple #defines. <dname>
 * is the absolute name of the derived object, <bname> is the absolute
 * name of the defining occurrence of the name.
 *
 * void yccGenSimpleDerived( ycctx* ctx, yccfp* fp, CONST char* dname, 
 *	CONST char* bname)
 */

#define yccGenSimpleDerived( ctx, fp, dname, bname) \
  { \
    yccfpStartPP( (fp)); \
    yccfpPrint( fp, "#ifndef %s\n#define %s %s\n#endif /* %s */\n\n", \
                (dname), (dname), (bname), (dname)); \
    yccfpEndPP( (fp)); \
  }

/* ---------------------------------------------------------------------- */
/*
 * ycchdr - generation of header output
 */
void ycchdr(ycctx *ctx, char *base, ycfile* fd)
{
  yccfp *fp;
  char  *upbase;
  CONST char* errtxt;
  ysle* le;
  CONST char* guardsfx = (ycStyleOra(ctx) ? "ORACLE" : "IDL");

  /* open temporary output file */
  fp = yccfpOpen(fd->newtmp, "w", SYSFPKIND_NONE, &errtxt, 
                 yccGetLineLimit(ctx));
  if ( !fp )
  {
    ysRecord( YCMSG(1), YCERRSEV, YSLSTR(fd->target), YSLSTR(errtxt), YSLEND);
    return;
  }
  upbase = ycToUpper(ysStrDup(base));    /* uppercase for use in macros */

  /* produce boilerplate output */
  yccfpSetIndent( fp, 0);
  yccfpPrint(fp, "/* GENERATED FILE\n * %s - public declarations\n", base);
  yccfpPrint(fp, " * from %s\n */\n\n", ctx->srcnm);
  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s_%s\n#define %s_%s\n\n", 
              upbase, guardsfx, upbase, guardsfx);
  yccfpEndPP( fp);
  yccGenSysIncls(ctx, fp, FALSE);
  yccfpPrint( fp, "EXTC_START\n\n");       /* extern "C" for C++ */

  /* output sequences along with fwd decls for element types */
  if ( ysLstCount( ctx->seqs) > 0 )
  {
    yccfpPrint( fp, "/**********  SEQUENCE DECLARATIONS *********/\n");
    for ( le = ysLstHead(ctx->seqs); le; le = ysLstNext(le))
    {
      yrobj* obj = (yrobj*) ysLstVal(le);
      yccGenDecl( ctx, fp, obj, TRUE);
    }
  }
  
  /* output all the declarations */
  if ( ysLstCount( ctx->newobjs) > 0 )
  {
    yccfpPrint( fp, "/******* NON-SEQUENCE DECLARATIONS *******/\n");
    yccGenCGObjs( ctx, fp, ctx->newobjs);
  }

  /* produce boilerplate ending */
  yccfpPrint( fp, "EXTC_END\n#endif /* %s_%s */\n", upbase, guardsfx);

  ysmGlbFree((dvoid *) upbase);
  yccfpClose( fp);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenDecl - generate declarations for a list of objects
 *
 * Starting point for code generation for top level objects and
 * interface members.
 */
void yccGenDecl(ycctx* ctx, yccfp* fp, yrobj* obj, boolean isForward)
{
  switch ( yrGetKind(obj) )
  {
    case yrdkInterface:
      yccGenIntfDecl(ctx, fp, obj, isForward);
      break;
    case yrdkConstant:
	/* enumerators are gen'd with their enum type */
      if ( !ycIsEnumConst(obj) )
	yccGenConstDecl(ctx,fp, obj);
      break;
    case yrdkException:
      yccGenExDecl(ctx, fp, obj, isForward);
      break;
    case yrdkTypedef:
    case yrdkAlias:
      yccGenAliasDecl(ctx, fp, obj, isForward);
      break;
    case yrdkStruct:
      yccGenStructDecl(ctx, fp, obj, isForward);
      break;
    case yrdkUnion:
      yccGenUnionDecl(ctx, fp, obj, isForward);
      break;
    case yrdkEnum:
      yccGenEnumDecl(ctx, fp, obj, isForward);
      break;
    case yrdkSequence:
      yccGenSequenceDecl(ctx, fp, obj);
      break;
    case yrdkArray:
      break;
    case yrdkAttribute:
      yccGenAttrDecl(ctx, fp, obj, FALSE);
      break;
    case yrdkOperation:
      yccGenOpDecl(ctx, fp, obj, FALSE);
      break;
    default:
      /* error */
      break;
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenCGObjs - Generate code from a list of ycobj's.
 *
 * There will always be one list of code gen objects attached to the
 * context. In addition, there may be list embedded within there for
 * any modules in the IDL. 
 */

STATICF void yccGenCGObjs( ycctx* ctx, yccfp* fp, yslst* objs)
{
  ysle* le;

  if ( objs )
  {
    for ( le = ysLstHead(objs); le; le = ysLstNext(le))
    {
      ycgobj* cgobj = (ycgobj*) ysLstVal(le);
  
      if ( yrGetKind(cgobj->ifrobj) == yrdkModule )
        yccGenCGObjs( ctx, fp, cgobj->objlist);
      else
        yccGenDecl( ctx, fp, cgobj->ifrobj, cgobj->flags & YCG_FWD);
    }
  }
}

/* ---------------------------------------------------------------------- */
/*
 * yccGenConstDecl - generate code for a constant declaratioin
 *
 *	optional guard open 
 *	#define name ((type) value)
 *	optional guard close
 *
 * For an inherited constant:
 *
 *	#ifndef derived_name
 *	#define derived_name name
 *	#endif
 */
void yccGenConstDecl(ycctx *ctx, yccfp *fp, yrobj *obj)
{
  CONST char  *name;

  name = yccGetAbsoluteName(ctx, obj, (yrobj*)0);
  if ( ycgInherited(ctx, obj) )
  {
    yrobj* inInterface = ycgScopeLookup( ctx, yrdkInterface);
    CONST char* dname = yccGetAbsoluteName( ctx, obj, inInterface);
    yccGenSimpleDerived( ctx, fp, dname, name);
    ysmGlbFree( (dvoid*)dname);
    return;
  }

  if ( yccNeedsGuard(obj) )
    yccGenOpenGuard(ctx, fp, name, FALSE);

	/* #define name ((type) vale) */
  yccfpStartPP( fp);
  yccfpPrint(fp, "#define %s ((", name);
  yccGenTypeName(ctx, fp, yrConstData(obj).type);
  yccfpPrint(fp, ") ");
  yccGenConstVal( ctx, fp, obj);
  yccfpPrint(fp,")\n");
  yccfpEndPP( fp);

  if ( yccNeedsGuard(obj) )
    yccGenCloseGuard(ctx, fp, name, FALSE);
}


/* -------------------------------------------------------------------- */

/*
 * yccGenIntfDecl - generate an Interface declaration
 *
 * With interfaces, it is necessary to distinguish between forward
 * declarations and full type declarations. If <fwd> is TRUE, we're
 * generating code for a forward declaration; else the whole thing.
 * You cannot just check the "defined" attribute of <intf> because
 * if there was a forward decl followed by a definition, "defined"
 * is true, but you need to generate (different) code for both the
 * forward decl and the defn.
 *
 * A full interface declaration includes code for all member types,
 * constants, exceptions, operations, and attributes, plus supporting
 * declarations for things like the __stubs and __tyimpl object.
 * Refer to the compiler internals document for more information.
 *
 * Be careful with the __tyimpl generation: The order in which the
 * fields are defined here had better stay in step with the order
 * of the initializer generated in yccsrv.c.
 *
 * The (incomplete) struct type that the objref typedef sits on
 * top of is YC<T> for some interface T to avoid problems with
 * C++: Because struct tags and typedefs are in the same namespace,
 * declarations of the form "typedef struct T* T;" are illegal.
 */

void yccGenIntfDecl(ycctx* ctx, yccfp* fp, yrobj* intf, boolean fwd)
{
  CONST char* name;
  ysle* le;
  boolean genDefn;
  yrobj* mem;

  if ( ycIsCorbaObject( ctx, intf) )   /* CORBA::Object is a magic cookie */
    return;

  genDefn = ycShouldGenCode( ctx, intf);
  name = yccGetAbsoluteName(ctx, intf, (yrobj*)0);

  yccfpPrint(fp, "\n/* interface %s declarations */\n", name);
  yccGenOpenGuard(ctx, fp, name, FALSE);
  if ( ycStyleCORBA(ctx) )
    yccfpPrint(fp, "typedef CORBA_Object %s;\n", name, name);
  else
    yccfpPrint(fp, "typedef struct YC%s* %s;\n", name, name);
  if ( yccNeedsTypeCode( ctx, intf) )
    yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
  yccGenCloseGuard(ctx, fp, name, FALSE);
  yccGenSupportFuncs( ctx, fp, intf, FALSE);
  if ( fwd )
  {
    return;
  }

    /****
     * If this is not an interface from an include file, generate
     * full declaration. Even if it is an from an incl, must gen all
     * the type decls because they may be used by something in the 
     * including source file.
     ****/
  if ( genDefn )
  {
    yccGenOpenGuard( ctx, fp, name, TRUE);
    yccfpStartPP( fp);
    yccfpPrint( fp, "struct yostub* %s__getStubs(void);\n", name);
    yccfpPrint( fp, "#define %s__stubs (%s__getStubs())\n", name, name);
    yccfpEndPP( fp);
    yccGenCloseGuard( ctx, fp, name, TRUE);
  }
  yccGenId( ctx, fp, name, name, TRUE, (char*)0);

      /* gen decls for operations, attributes, types, etc. */
  ycgPushScope( ctx, intf);
  for (le = ysLstHead( yrGetContents(intf)); le; le = ysLstNext(le))
  {
    mem = (yrobj*) ysLstVal(le);
    yccGenDecl( ctx, fp, mem, FALSE);
  }

  if ( genDefn )
  {
    ycsym* syminfo = ycSymLookup( ctx->symtbl, intf);
    yslst* all = (syminfo ? syminfo->opsNattrs : (yslst*)0);

	/* gen __tyimpl type */
    if ( !ycIsEmptyLst(all) )
    {
      yccfpStartPP( fp);
      yccfpPrint( fp, "#ifndef %s__tyimpl_DEFINED\n", name);
      yccfpPrint( fp, "#define %s__tyimpl_DEFINED\n", name);
      yccfpEndPP( fp);
      yccfpPrint(fp, "struct %s__tyimpl\n{\n", name);
      yccfpIncIndent( fp);

      
      for ( le = ysLstHead(all); le; le = ysLstNext(le))
      {
        mem = (yrobj*)ysLstVal(le);
        if ( yrGetKind(mem) == yrdkOperation )
          yccGenOpDecl( ctx, fp, mem, TRUE);
        else
          yccGenAttrDecl( ctx, fp, mem, TRUE);
      }

      yccfpDecIndent( fp);
      yccfpPrint(fp, "};\n");
      yccfpPrint( fp, "#endif /* %s__tyimpl_DEFINED */\n\n", name);
    }
  }
  DISCARD ycgPopScope(ctx);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenExDecl - generate an exception declaration
 *
 * If use of global data not allowed:
 *      CONST ysid* scope_name__getId();
 *      #define scope_EX_name (scope_name__getId())
 *      yotk* scope_name__getTC();
 *      #define YCTC_scope_name (scope_name__getTC())
 *
 * If generating external globals for typecodes and ex id's:
 *	externref ysidDecl(scope_EX_name);
 *	typedef struct 
 *	{
 *	  members...
 *	} scope_name;
 *	externref yotk YCTC_scope_name[];
 *
 * For an inherited exception:
 *      #ifndef derived_EX_name
 *      #define derived_EX_name scope_EX_name
 *      #endif
 *      #ifndef derived_name
 *      #define derived_name scope_name
 *      #endif
 */
void yccGenExDecl( ycctx* ctx, yccfp* fp, yrobj* ex, boolean fwd)
{
  CONST char* exName = (char*)0;      /* EX_FOO */
  CONST char* name = (char*)0;        /* foo */
  sword saveStyle = ctx->style;
  boolean inherited = ycgInherited( ctx, ex);

	/* "externref ysidDecl(scope_EX_name);" */
  if ( !fwd )
  {
    ctx->style |= YCSTYLE_EXC;
    exName = yccGetAbsoluteName(ctx, ex, (yrobj*)0);
    if ( inherited )
    {
      CONST char* dname;

      dname = yccGetAbsoluteName(ctx, ex, ycgScopeLookup( ctx, yrdkInterface));
      yccGenSimpleDerived( ctx, fp, dname, exName);
      if ( !yrStructData(ex).mbrs )
        yccGenTypeCodeMacro( ctx, fp, dname, ex);
      ysmGlbFree( (dvoid*)dname);
      ctx->style = saveStyle;
    }
    else			/* not inherited */
    {
      ctx->style = saveStyle;
      yccGenOpenGuard(ctx, fp, exName, FALSE);
      name = yccGetAbsoluteName( ctx, ex, (yrobj*)0);
      yccGenId( ctx, fp, exName, name, FALSE, (char*)0);
      yccGenCloseGuard(ctx, fp, exName, FALSE);
    }
    ysmGlbFree((dvoid*) exName);
  }

	/* gen exception typedef if there is data */
  if ( yrStructData(ex).mbrs )
    yccGenStructDecl(ctx, fp, ex, fwd);
  else if ( !fwd && !inherited && yccNeedsTypeCode( ctx, ex) )
  {     /* gen typecode even if there is no data */
    if ( !name)
      name = yccGetAbsoluteName( ctx, ex, (yrobj*)0);
    yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenStructDecl - generate code for a struct object
 *
 * For some struct T:
 *    <decl guard open>
 *    typedef struct T T;
 *    <decl guard close>
 *    
 *    <defn guard open>                         -- !fwd
 *    struct T                                  -- !fwd
 *    {                                         -- !fwd
 *      ...members...                           -- !fwd
 *    };                                        -- !fwd
 *    extern yotk YCTC_T[];                     -- !fwd
 *    <defn guard close>                        -- !fwd
 *    <support function decls>                  -- !fwd
 *
 * For a struct D derived from struct B:
 *    <forward decl of B, if necessary>
 *    <#define D B>
 *    <#define YCTC_D YCTC_B>                   -- !fwd
 *    <support function decls>                  -- !fwd
 */
void yccGenStructDecl( ycctx* ctx, yccfp* fp, yrobj* sobj, boolean fwd)
{
  CONST char* name;
  ysle* le;

  name = yccGetAbsoluteName(ctx, sobj, (yrobj*)0);
  if ( ycgInherited( ctx, sobj) )
  {
    CONST char* dname;
    dname = yccGetAbsoluteName(ctx, sobj, ycgScopeLookup( ctx, yrdkInterface));
    yccGenSimpleDerived( ctx, fp, dname, name);
    if ( !fwd )
      yccGenTypeCodeMacro( ctx, fp, dname, sobj);
    ysmGlbFree( (dvoid*)dname);
  }

  else              /* not doing an inherited type */
  {
    if ( !fwd )     /* gen code for nested types */
    {
      for (le = ysLstHead( yrGetContents(sobj)); le; le = ysLstNext(le))
        yccGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
    }

    yccGenOpenGuard( ctx, fp, name, FALSE);
    yccfpPrint( fp, "typedef struct %s %s;\n", name, name);
    yccGenCloseGuard( ctx, fp, name, FALSE);

    if ( !fwd )
    {
      yccGenOpenGuard(ctx, fp, name, TRUE);

      yccfpPrint(fp, "struct %s\n{\n", name);
      yccfpIncIndent( fp);
      for (le = ysLstHead(yrStructData(sobj).mbrs); le; le = ysLstNext(le))
      {
        yrstrmbr* mem = (yrstrmbr*) ysLstVal(le);
        yccGenField(ctx, fp, mem->type, mem->name);
      }
      yccfpDecIndent( fp);
      yccfpPrint(fp, "};\n");

      if ( yccNeedsTypeCode( ctx, sobj) )
        yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
      yccGenCloseGuard(ctx, fp, name, TRUE);
    }
  }

  if ( !fwd )
    yccGenSupportFuncs( ctx, fp, sobj, FALSE);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenUnionDecl - generate code for a union object
 *
 * For some union T:
 *    <decl guard open>
 *    typedef struct T T;
 *    <decl guard close>
 *    
 *    <defn guard open>                         -- !fwd
 *    struct T                                  -- !fwd
 *    {                                         -- !fwd
 *      discrminatorType _d;                    -- !fwd
 *      union                                   -- !fwd
 *      {                                       -- !fwd
 *        ...members...                         -- !fwd
 *      } _u;                                   -- !fwd
 *    };                                        -- !fwd
 *    extern yotk YCTC_T[];                     -- !fwd
 *    <defn guard close>                        -- !fwd
 *    <support function decls>                  -- !fwd
 *
 * For a union D derived from struct B:
 *    <forward decl of B, if necessary>
 *    <#define D B>
 *    <#define YCTC_D YCTC_B>                   -- !fwd
 *    <support function decls>                  -- !fwd
 */
void yccGenUnionDecl( ycctx* ctx, yccfp* fp, yrobj* uobj, boolean fwd)
{
  CONST char* name;
  ysle* le;

  name = yccGetAbsoluteName(ctx, uobj, (yrobj*)0);
  if ( ycgInherited( ctx, uobj) )
  { 
    CONST char* dname;

    dname = yccGetAbsoluteName(ctx, uobj, ycgScopeLookup( ctx, yrdkInterface));
    yccGenSimpleDerived( ctx, fp, dname, name);
    if ( !fwd )
      yccGenTypeCodeMacro( ctx, fp, dname, uobj);
    ysmGlbFree( (dvoid*)dname);
  }
  else                          /* not an inherited type */
  {
    if ( !fwd )     /* gen code for nested types */
    {
      for (le = ysLstHead( yrGetContents(uobj)); le; le = ysLstNext(le))
        yccGenDecl( ctx, fp, (yrobj*) ysLstVal(le), FALSE);
    }

    yccGenOpenGuard(ctx, fp, name, FALSE);
    yccfpPrint(fp, "typedef struct %s %s;\n", name, name);
    yccGenCloseGuard(ctx, fp, name, FALSE);

    if ( !fwd )
    {
      CONST char* prevnm;

      yccGenOpenGuard(ctx, fp, name, TRUE);

      yccfpPrint(fp, "struct %s\n{\n", name);
      yccfpIncIndent( fp);
      yccGenField(ctx, fp, yrUnionData(uobj).disctype, "_d");
      yccfpPrint(fp, "union\n{\n");
      yccfpIncIndent( fp);
      prevnm = "";
      for (le = ysLstHead(yrUnionData(uobj).arms); le; le = ysLstNext(le))
      {
        yrunmbr* mem = (yrunmbr*) ysLstVal(le);
        if ( strcmp(mem->name, prevnm) != 0 )
        {
          yccGenField(ctx, fp, mem->type, mem->name);
          prevnm = mem->name;
        } /* else, duplicate case label, not really a new arm */
      }
      yccfpDecIndent( fp);
      yccfpPrint(fp, "} _u;\n");
      yccfpDecIndent( fp);
      yccfpPrint( fp, "};\n");

      if ( yccNeedsTypeCode( ctx, uobj) )
        yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
      yccGenCloseGuard(ctx, fp, name, TRUE);
    }
  }

  if ( !fwd )
    yccGenSupportFuncs( ctx, fp, uobj, FALSE);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenArrayDeclr - generate an array declarator
 *
 * What's so special about an array declarator? It has to have the
 * dimensions added after the declarator name.
 */

void yccGenArrayDeclr( ycctx* ctx, yccfp* fp, yrobj* arr, CONST char* declr)
{
  yccfpPrint( fp, "%s", declr);
  for (; yrGetKind(arr) == yrdkArray; arr = yrArrayData(arr).elmtype)
  {
    yccfpPrint( fp, "[%u]", yrArrayData(arr).length);
  }
}


/* ---------------------------------------------------------------------- */

/*
 * yccGenField - generate a struct, union, or exception field
 *
 * Generates "  type name;\n"
 */
void yccGenField( ycctx* ctx, yccfp* fp, yrobj* type, CONST char* name)
{
  yccGenTypeName(ctx, fp, type);
  if ( yrGetKind(type) == yrdkArray )
  {
    char nm[20];                   /* keywords are all short */
    CONST char* p;

    yccfpPrint( fp, " ");
    if ( (*ctx->lang->kwdchk)( ctx, name) )
    {
      nm[0] = '_';
      DISCARD strcpy( nm+1, name);
      p = nm;
    }
    else
      p = name;
    yccGenArrayDeclr( ctx, fp, type, p);
    yccfpPrint( fp, ";\n");
  }
  else
    yccfpPrint( fp," %s%s;\n", 
                ((*ctx->lang->kwdchk)(ctx, name) ? "_" : ""), name);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenAliasDecl - generate an alias/typedef declaration
 *
 *	optional guard open
 *	typedef type name;
 *	optional guard close
 *
 * Custom type codes are generated for all typedefs. Though they're
 * essentially just a renaming of the base type's typecode and adds
 * nothing to the marshalling/unmarshalling process, it is necessary for
 * accurate typecode querying.
 * 
 * Note that you don't have to worry about typedefs of anonymous sequence
 * types - the seq type code is generated along with sequence type.
 *
 * A forward declaration of an alias type is a weird concept, but if you
 * think of it as meaning the typedef is being declared out of context,
 * then it means you have to generate a forward declaration for the base
 * type of alias before declaring the typedef. Note that for typedefs of
 * arrays, this degenerates further into a forward declaration of the
 * array element type.
 *
 * For an inherited alias:
 *
 *	#ifndef derived_name
 *	#define derived_name name
 *	#endif
 *
 * For array aliases, we define both the array typedef and a "slice"
 * typedef to go with it, as specified by the CORBA 2.0 spec. The slice
 * is the original array minus the 1st dimension; it is used for return
 * types on operations. Example:
 *
 *	given: typedef long mumble[4][5];
 *      slice is: typedef long mumble_slice[5];
 *
 * For the sake of symmetry, a slice is generated even for a one
 * dimensional array. Obviously, it is a typedef of the element type.
 * No type code is generated for the slice; it is unnecessary.
 */
void yccGenAliasDecl(ycctx* ctx, yccfp* fp, yrobj* alias, boolean fwd)
{
  CONST char* name;
  yrobj* basetype;

  if ( fwd )			/* declare fwd of base type first */
  {
    yrobj* p = yrAliasData(alias).type;

    while ( yrGetKind(p) == yrdkArray )	/* walk array chain to elem type */
      p = yrArrayData(p).elmtype;
    yccGenDecl( ctx, fp, p, TRUE);
  }

  name = yccGetAbsoluteName(ctx, alias, (yrobj*)0);
  basetype = yrAliasData(alias).type;
  if ( ycgInherited( ctx, alias) )
  { 
    CONST char* dname;

    dname = yccGetAbsoluteName(ctx, alias, ycgScopeLookup(ctx, yrdkInterface));
    yccGenSimpleDerived( ctx, fp, dname, name);
    if ( yrGetKind(basetype) == yrdkArray )
    {
      yccfpStartPP( fp);
      yccfpPrint( fp, "#ifndef %s_slice\n", dname);
      yccfpPrint( fp, "#define %s_slice %s_slice\n", dname, name);
      yccfpPrint( fp, "#endif /* %s_slice */\n\n", dname);
      yccfpEndPP( fp);
    }
    if ( !fwd )
    {
      yccGenSupportFuncs( ctx, fp, alias, FALSE);
      yccGenTypeCodeMacro( ctx, fp, dname, alias);
    }
    ysmGlbFree( (dvoid*)dname);
  }
  else
  {
    yccGenOpenGuard(ctx, fp, name, FALSE);

    yccfpPrint(fp, "typedef ");
    yccGenTypeName(ctx, fp, basetype);

      /***** Array aliases. Need typedef, type code, and slice typedef *****/
    if ( yrGetKind(basetype) == yrdkArray )
    {
      yrobj* sliceType = yrArrayData(basetype).elmtype;
      char* sliceName = (char*) ysmGlbAlloc( strlen(name)+7, "slice");
  
      yccfpPrint( fp, " ");
      yccGenArrayDeclr( ctx, fp, basetype, name);
      yccfpPrint( fp, ";\n");
  
        /* gen slice typedef by stripping off first dimension */
      yccfpPrint( fp, "typedef ");
      yccGenTypeName(ctx, fp, basetype);
      yccfpPrint( fp, " ");
      ysFmtStr( sliceName, "%s_slice", name);
      if ( yrGetKind(sliceType) == yrdkArray )
      {
        yccGenArrayDeclr( ctx, fp, sliceType, sliceName);
        yccfpPrint( fp, ";\n");
      }
      else
        yccfpPrint( fp, "%s;\n", sliceName);
      ysmGlbFree( (dvoid*)sliceName);
    }
      /**** Sequence, bound string, or non-array alias. *****/
    else
    {
      yccfpPrint(fp, " %s;\n", name);
    }
  
    if ( yccNeedsTypeCode( ctx, alias) )
      yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
    yccGenCloseGuard(ctx, fp, name, FALSE);
    yccGenSupportFuncs( ctx, fp, alias, FALSE);
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenEnumDecl - generate code for an enumeration type
 *
 *	optional guard open
 *	typedef ub4 enumName;
 *	#define enumerator1 0
 *	#define enumerator2 1
 *	... for all enumerators ...
 *	optional guard close
 *
 * For an inherited enumerator, renaming #defines are generated for
 * the enumeration type and the enumerators:
 *
 *	#ifndef derived_enumName
 *	#define derived_enumName enumName
 *	#endif
 *	#ifndef derived_enumName_DEFINED
 *	#define derived_enumName_DEFINED
 *	#define derived_enumerator1 enumerator1
 *	...
 *	#endif
 */
void yccGenEnumDecl(ycctx* ctx, yccfp* fp, yrobj* eobj, boolean fwd)
{
  CONST char* name;
  ysle* le;
  CONST char* dname;
  boolean inherited = ycgInherited( ctx, eobj);

  name = yccGetAbsoluteName(ctx, eobj, (yrobj*)0);
  if ( inherited )
  {
    dname = yccGetAbsoluteName(ctx, eobj, ycgScopeLookup(ctx, yrdkInterface));
    yccGenSimpleDerived( ctx, fp, dname, name);
    yccGenTypeCodeMacro( ctx, fp, dname, eobj);
    name = dname;
  }
  else
  {
    yccGenOpenGuard(ctx, fp, name, FALSE);
    yccfpPrint( fp, "typedef %s %s;\n", 
                ycStyleCORBA(ctx) ? "CORBA_enum" : "ub4", name);
    if ( yccNeedsTypeCode( ctx, eobj) )
      yccGenTypeCode(ctx, fp, name, (yotk*)0, TRUE);
    yccGenCloseGuard(ctx, fp, name, FALSE);
  }

  if ( !fwd )
  {
    yccGenOpenGuard(ctx, fp, name, TRUE);

    for (le = ysLstHead(yrEnumData(eobj).mbrs); le; le = ysLstNext(le))
    {
      yccGenConstDecl( ctx, fp, (yrobj*) ysLstVal(le));
    }

    yccGenCloseGuard(ctx, fp, name, TRUE);
    yccGenSupportFuncs( ctx, fp, eobj, FALSE);
  }
  if ( inherited )
    ysmGlbFree((dvoid*) name);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenSequenceDecl - generate code for a sequence
 *
 * If builtin sequences are in use, generate no code if the
 * element type is one of the primitive types. If builtin
 * sequences are not in use, or the element type is not just
 * a primitve:
 *
 *	guard open
 *	typedef struct
 *	{
 *	  ub4 _maximum;
 *	  ub4 _length;
 *	  elemType* buffer;
 *	} YCIDL_seqName;
 *	typecode
 *	guard close
 *
 * Sequences are named rather strangely, using the effective name of
 * their element types (e.g. peers through typedefs), with special
 * handling for sequences of strings. To the greatest degree possible,
 * try to match sequence name and the buffer name together. Since figuring
 * out the name of a sequence is fairly costly and since the buffer type
 * name is more or less a subset of the sequence name, we tweak the name
 * we already calculated for the sequence in gen'ing the buffer decl:
 *
 *   if the sequence name is:		then the buffer type is:
 *   -----------------------            -----------------------
 *   YCIDL_sequence_sb4			sb4
 *   YCIDL_sequence_sequence_sb4	YCIDL_sequence_sb4
 *   YCIDL_sequence_string		char*
 *
 * Note that "sb4" is used even if the real element type is a typedef
 * of "long". For info on all the special casing for sequence names,
 * refer to yccGenSeqName.
 *
 * Since sequences can be used to refer recursively to their element
 * type and since such fields are not of pointer type, the sequence
 * type declaration must occur before the element type is completed.
 * Therefore, all sequences are generated first along with forward
 * declarations for their element types, where appropriate. e.g.,
 *
 *   struct whatever
 *   {
 *     sequence<whatever> f1;
 *   };
 */
void yccGenSequenceDecl(ycctx* ctx, yccfp* fp, yrobj* seq)
{
  CONST char* name;
  yrobj* elemtype = yrSeqData(seq).elmtype;
  CONST char* ulongnm;

    /***** Find buffer type *****/
  for ( ; yrGetKind(elemtype) == yrdkAlias; 
          elemtype = yrAliasData(elemtype).type)
  {
    if ( yrGetKind(yrAliasData(elemtype).type) == yrdkArray )
      break;
  }

    /***** Generate forward decl for some element types *****/
  switch ( yrGetKind(elemtype) )
  {
    case yrdkPrimitive:
    case yrdkString:
      if ( ctx->lang->flags & YCCFLG_BUILTIN_SEQ )
        return;	/* decls provided outside for builtin seqs */
      else
        break;
    case yrdkSequence:
      break;	/* assume elem type decl already occurred */
    default:	/* generate fwd decl of element type */
      yccGenDecl( ctx, fp, elemtype, TRUE);
      break;
  }

    /***** Gen the sequence struct decl *****/
  name = yccGetAbsoluteName(ctx, seq, (yrobj*)0);
  yccGenOpenGuard(ctx, fp, name, TRUE);
  yccfpPrint( fp, "typedef struct\n{\n");
  yccfpIncIndent( fp);
  ulongnm = yccGetPrimitiveName( ctx, yrpkulong);
  yccfpPrint( fp, "%s _maximum;\n%s _length;\n", ulongnm, ulongnm);
  yccGenTypeName( ctx, fp, elemtype);
  yccfpPrint( fp, "* _buffer;\n");
  if ( !ycCORBA1_2(ctx) )
    yccfpPrint( fp, "%s _release;\n", yccGetPrimitiveName( ctx, yrpkboolean));
  yccfpDecIndent( fp);
  yccfpPrint( fp, "} %s;\n", name);

  yccGenSupportFuncs( ctx, fp, seq, FALSE);
  yccGenCloseGuard( ctx, fp, name, TRUE);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenAttrDecl - generate declarative code for an interface attribute
 *
 *	attrtype base__get_attr(intf);
 *	externref yopar base__get_attr_pars[];
 *	void base__set_attr(intf, attrtype val);
 *	externref yopar base__set_attr_pars[];
 *
 * if <fptr> is true, gen the function signature in function pointer
 * form for use in the __tyimpl structure.
 *
 * For an inherited attribute, we generate macro defns a la yccGenDerivedFunc.
 * If <fptr> is TRUE, pay no attention to inherited vs. defined.
 */

void yccGenAttrDecl(ycctx* ctx, yccfp* fp, yrobj* attr, boolean fptr)
{
  CONST char* base;	     /* attr's intf or base intf attr absolute name */
  char* attrName;
  char* name;		            /* attr or base intf attr absolute name */
  yrobj* voidType;
  CONST char* dbase = (char*)0;	         /* derived interface absolute name */
  char* dname = (char*)0;	              /* derived attr absolute name */
  yrobj* bintf = yrGetDefinedIn(attr);
  yrobj* inInterface = (yrobj*)0;
  boolean inherited;
  yrobj* intf;

  if ( !ycShouldGenCode( ctx, attr) )
    return;		/* don't gen for include files */

  inherited = ycgInherited( ctx, attr);
  if ( inherited )
  {
    inInterface = ycgScopeLookup( ctx, yrdkInterface);
    intf = inInterface;
  }
  else
    intf = bintf;
  base = fptr ? "" : yccGetAbsoluteName( ctx, bintf, (yrobj*)0);
  attrName = yrGetName(attr);
  voidType = yrGetPrimitive( ctx->repository, yrpkvoid);
  name = (char*) ysmGlbAlloc(strlen(base) + strlen(attrName) + 7, "attrName");
		/* "__get_" + 1 == 7 */

    /* synchronous get function */
  if ( inherited && !fptr )
  {
    dbase = yccGetAbsoluteName( ctx, inInterface, (yrobj*)0);
    dname = (char*) ysmGlbAlloc(strlen(dbase) + strlen(attrName) + 10, 
		"attrName");
    DISCARD ysFmtStr( name, "%s__get_%s", base, attrName);
    DISCARD ysFmtStr( dname, "%s__get_%s", dbase, attrName);
    yccGenDerivedFunc( ctx, fp, dname, name, bintf, yrAttrData(attr).type, 
                       (yslst*)0, (yslst*)0);
  }
  else		/* gen real func decls */
  {
    if ( !fptr )
      DISCARD ysFmtStr( name, "%s__get_%s", base, attrName);
    else
      DISCARD ysFmtStr( name, "_get_%s", attrName);
    yccGenFuncHdr( ctx, fp, yrAttrData(attr).type, intf,
		   name, (yslst*)0, (yslst*)0, fptr, yccfnk_normal);
    yccfpPrint(fp,";\n");
      /* asynchronous get function */
    if ( !fptr )
    {
      if ( yccGenAsync(ctx) )
      {
        yccGenFuncHdr( ctx, fp, voidType, intf, name, (yslst*)0, 
                       (yslst*)0, fptr, yccfnk_nw);
        yccfpPrint( fp, ";\n");
      }
      yccGenParsDecl( ctx, fp, name);
    }
  }

    /* gen set operation if not readonly attribute */
  if ( yrAttrData(attr).mode != YR_ATTR_RO )
  {
    yrpar param;
    yslst* pars = ysLstCreate();

    param.name = "val";
    param.type = yrAttrData(attr).type;
    param.mode = YOMODE_IN;
    DISCARD ysLstEnq( pars, (dvoid*) &param);

    if ( inherited && !fptr )
    {
      DISCARD ysFmtStr( name, "%s__set_%s", base, attrName);
      DISCARD ysFmtStr( dname, "%s__set_%s", dbase, attrName);
      yccGenDerivedFunc( ctx, fp, dname, name, bintf, voidType, pars,
                         (yslst*)0);
    }
    else
    {
      if ( !fptr )
	DISCARD ysFmtStr( name, "%s__set_%s", base, attrName);
      else
	DISCARD ysFmtStr( name, "_set_%s", attrName);

	/* synchronous set function */
      yccGenFuncHdr( ctx, fp, voidType, intf, name, pars, (yslst*)0, 
                     fptr, yccfnk_normal);
      yccfpPrint(fp,";\n");
	/* asynchronous set function */
      if ( !fptr )
      {
        if ( yccGenAsync(ctx) )
        {
	  yccGenFuncHdr( ctx, fp, voidType, intf, name, pars, (yslst*)0, 
                         fptr, yccfnk_nw);
          yccfpPrint( fp, ";\n");
        }
        yccGenParsDecl( ctx, fp, name);
      }
    }
    ysLstDestroy( pars, (ysmff)0);
  }

  ysmGlbFree((dvoid*)name);
  if ( inherited && !fptr )
  {
    ysmGlbFree((dvoid*)dname);
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenOpDecl - generate declarative code for an interface operation
 *
 *	rettype op(intf or, params);
 *	void op_nw(intf or, params, ysevt* usrevt);
 *	externref yotk op_pars[];
 *
 * For an inherited operation:
 *
 *	#ifndef derived_op
 *	#define derived_op(or, params) base_op( (base*)or, params)
 *	#define derived_op_nw(or, params, evt) base_op( (base*)or, params, evt)
 *	#define derived_op_pars base_op_pars
 *	#endif derived_op
 *
 * If <fptr> is TRUE, we're generating a function pointer decl for
 * use in the __tyimpl structure. Base vs. derived has no affect on this.
 */
void yccGenOpDecl(ycctx* ctx, yccfp* fp, yrobj* op, boolean fptr)
{
  CONST char* name = (char*) 0;
  yrobj* inInterface = (yrobj*) 0;
  boolean inherited;

  if ( !ycShouldGenCode( ctx, op) )
    return;

  inherited = ycgInherited( ctx, op);
  if ( inherited )
    inInterface = ycgScopeLookup( ctx, yrdkInterface);

  if ( inherited && !fptr )
  {
    CONST char* dname;

    dname = yccGetAbsoluteName( ctx, op, inInterface);
    yccGenDerivedFunc( ctx, fp, dname, yccGetAbsoluteName(ctx, op, (yrobj*)0),
			yrGetDefinedIn(op), yrOpData(op).rettype, 
			yrOpData(op).pars, yrOpData(op).ctxts);
    ysmGlbFree( (dvoid*)dname);
  }
  else
  {
    yrobj* intf = inherited ? inInterface : yrGetDefinedIn(op);

    if ( !fptr )
      name = yccGetAbsoluteName(ctx, op, intf);
    else
      name = yrGetName(op);
    yccGenFuncHdr( ctx, fp, yrOpData(op).rettype, intf, name,
		   yrOpData(op).pars, yrOpData(op).ctxts, fptr, yccfnk_normal);
    yccfpPrint(fp, ";\n");

	/* asynchronous stub decl */
    if ( !fptr )
    {
      if ( yccGenAsync(ctx) )
      {
        yccGenFuncHdr( ctx, fp, yrGetPrimitive( ctx->repository, yrpkvoid), 
		      intf, name, yrOpData(op).pars, yrOpData(op).ctxts, 
                      FALSE, yccfnk_nw);
        yccfpPrint( fp, ";\n");
      }
      yccGenParsDecl( ctx, fp, name);
    }
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenTypeName - generate the name of a type, suitable for use in an
 *	object, field, return type, or parameter declaration
@@ not sure how best to handle array at the moment...
 */
void yccGenTypeName( ycctx* ctx, yccfp* fp, yrobj* type)
{
  CONST char* tname;

  switch (yrGetKind(type))
  {
    case yrdkInterface:
    case yrdkUnion:
    case yrdkStruct:
    case yrdkException:
    case yrdkAlias:
    case yrdkTypedef:
    case yrdkEnum:
    case yrdkSequence:
      tname = yccGetAbsoluteName(ctx, type, (yrobj*)0);
      yccfpPrint(fp,"%s", tname);
      break;
    case yrdkString:
      yccGenPrimitiveName(ctx, fp, yrpkstring);
      break;
    case yrdkArray:	/* just prints the element type name for now */
    {
      yrobj* eltype = type;

      while ( yrGetKind(eltype) == yrdkArray )	/* find element type */
	eltype = yrArrayData(eltype).elmtype;
      yccGenTypeName(ctx, fp, eltype);
      break;
    }
    case yrdkPrimitive:
      yccGenPrimitiveName(ctx, fp, yrPrimData(type).kind);
      break;
    default:
      yseThrow(YS_EX_FAILURE);
      break;
  }
}


/* --------------------------------------------------------------------- */
/*
 * yccGenDerivedFunc - generate inherited op/attr function declaration
 *
 * For any operation/attribute "op", generate:
 *
 *      <extern decls for base_op, base_op_nw, base_op_pars>
 *	#ifndef derived_op
 *	#define derived_op(or, params) base_op((base)(or), params)
 *	#define derived_op_nw(or, params, ue) 
 *		base_op_nw((base)(or), params, (ue))
 *	#define derived_op_pars base_op_pars
 *	#endif
 *
 * We generate declarations for the base interface functions and pars
 * structure because if the base interface is from an include file
 * these declarations aren't normally generated.
 */
STATICF void yccGenDerivedFunc( ycctx* ctx, yccfp* fp, CONST char* dname, 
	CONST char* bname, yrobj* bintf, yrobj* rettype, yslst* pars, 
        yslst* ctxs)
{
  ysle* le;
  CONST char* base = yccGetAbsoluteName( ctx, bintf, (yrobj*) 0);
  yrobj* voidType = yrGetPrimitive(ctx->repository, yrpkvoid);

      /* base interface op decls */
  if ( !ycShouldGenCode( ctx, bintf) )
  {	/* this could would not otherwise get generated */
    yccGenFuncHdr( ctx, fp, rettype, bintf, bname, pars, 
                   ctxs, FALSE, yccfnk_normal);
    yccfpPrint(fp,";\n");
    if ( yccGenAsync(ctx) )
    {
      yccGenFuncHdr( ctx, fp, voidType, bintf, bname, pars, 
                     ctxs, FALSE, yccfnk_nw);
      yccfpPrint(fp, ";\n");
    }
    yccGenParsDecl( ctx, fp, bname);
  }

      /* derived sync */
  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s\n#define %s(or", dname, dname);
  if ( ycCORBA1_2(ctx) )
    yccfpPrint( fp, ", ev");

  if ( pars )
    for ( le = ysLstHead( pars); le; le = ysLstNext(le))
      yccfpPrint( fp, ", %s", ((yrpar*)ysLstVal(le))->name);

  if ( ycCORBA1_2(ctx) )
    yccfpPrint( fp, ") \\\n    %s((%s)(dvoid*)(or), (ev)", bname, base);
  else
  {
    if ( !ycIsEmptyLst(ctxs) )
      yccfpPrint( fp, ", corbctx_");
    yccfpPrint( fp, ", ev) \\\n    %s((%s)(dvoid*)(or)", bname, base);
  }

  if ( pars )
    for ( le = ysLstHead( pars); le; le = ysLstNext(le))
      yccfpPrint( fp, ", (%s)", ((yrpar*)ysLstVal(le))->name);
  if ( ycCORBA1_2(ctx) )
    yccfpPrint( fp, ")\n");
  else
  {
    if ( !ycIsEmptyLst(ctxs) )
      yccfpPrint( fp, ", (corbctx_)");
    yccfpPrint( fp, ", (ev))\n");
  }

      /* derived async */
  if ( yccGenAsync(ctx) )
  {
    yccfpPrint( fp, "#define %s_nw(or", dname);
    if ( ycCORBA1_2(ctx) )
      yccfpPrint( fp, ", ev");

    if ( pars )
      for ( le = ysLstHead( pars); le; le = ysLstNext(le))
        yccfpPrint( fp, ", %s", ((yrpar*)ysLstVal(le))->name);

    if ( ycCORBA1_2(ctx) )
      yccfpPrint( fp, ", ue) \\\n    %s_nw((%s)(dvoid*)(or), (ev)",
		 bname, base);
    else
    {
      if ( !ycIsEmptyLst(ctxs) )
        yccfpPrint( fp, ", corbctx_");
      yccfpPrint( fp, ", ev, ue) \\\n    %s_nw((%s)(dvoid*)(or)", bname, base);
    }

    if ( pars )
      for ( le = ysLstHead( pars); le; le = ysLstNext(le))
        yccfpPrint( fp, ", (%s)", ((yrpar*)ysLstVal(le))->name);

    if ( !ycCORBA1_2(ctx) )
    {
      if ( !ycIsEmptyLst(ctxs) )
        yccfpPrint( fp, ", (corbctx_)");
      yccfpPrint( fp, ", (ev)");
    }
    yccfpPrint( fp, ", (ue))\n");
  } /* async */

    /* derived pars descriptor */
  yccfpPrint( fp, "#define %s_pars %s_pars\n#endif /* %s */\n\n", 
                      dname, bname, dname);
  yccfpEndPP( fp);
}


/* --------------------------------------------------------------------- */
/*
 * yccGenParsDecl - Generate parameter descriptor declaration for an
 *   operation or attribute accessor/mutator. A #define for op_pars
 *   is generated for backward compatibility with OMN 3.1 and earlier.
 *
 * #ifdnef op_pars
 * yopar* op__getPars();
 * #define op_pars op__getPars()
 * #endif
 */
void yccGenParsDecl( ycctx* ctx, yccfp* fp, CONST char* opnm)
{
  yccfpPrint( fp, "yopar* %s__getPars(void);\n", opnm);
  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s_pars\n", opnm);
  yccfpPrint( fp, "#define %s_pars (%s__getPars())\n", opnm, opnm);
  yccfpPrint( fp, "#endif\n\n");
  yccfpEndPP( fp);
}

