/* Copyright (c) Oracle Corporation 1995.  All Rights Reserved. */

/*
  NAME
    ydmtd.c
  DESCRIPTION
    YD ORB METRICS daemon.
 
   Polls yorts for stats and loads up ydmt's in orbd's with the results.

    Maintains a local ydmt.

  PUBLIC FUNCTIONS
    main

  PRIVATE FUNCTIONS
    <x>

  NOTES

  MODIFIED   (MM/DD/YY)
    dbrower   08/15/95 - created.
    dbrower   05/17/96 -  fix bug 366675 ("CONST type or" in _i funcs)
    dbrower   02/ 5/96 -  Fix bug 338405.
			  Fix bug 338411.
			  Fix bug 338412.
    dbrower   02/23/96 -  change -d and -p to -D and -P; add -d to
			  explicitly turn on metric distribution,
			  because the default is now off.  Even without
			  distribution we do death detection and clean out
			  dead yorts.
    dbrower   03/11/96 -  change to use yoQueues, making shutdown completely
			  different.
    dbrower   10/10/96 -  fix dist loop and shutdown with it on! bug 411358.
    dbrower   10/11/96 -  interrupt handling, bug 411329
*/

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif
#ifndef YSR_ORACLE
#include <ysr.h>
#endif
#ifndef YSL_ORACLE
#include <ysl.h>
#endif
#ifndef YSV_ORACLE
#include <ysv.h>
#endif
#ifndef YDIDL_ORACLE
#include <ydidl.h>
#endif
#ifndef YDMTDIDLI_ORACLE
#include <ydmtdidlI.h>
#endif
#ifndef YDRT_ORACLE
#include <ydrt.h>
#endif
#ifndef YDIM_ORACLE
#include <ydim.h>
#endif
#ifndef YDMT_ORACLE
#include <ydmt.h>
#endif
#ifndef YT_ORACLE
#include <yt.h>
#endif
#ifndef YDQ_ORACLE
#include <ydq.h>
#endif
#ifndef YOYD_ORACLE
#include <yoyd.h>
#endif
#ifndef YDIDL_ORACLE
#include <ydidl.h>
#endif
#ifndef YDMTDIDL_ORACLE
#include <ydmtdidl.h>
#endif
#ifndef YSSP_ORACLE
#include <yssp.h>
#endif

#define ENTRY_POINT ydmtdMain
#include <s0ysmain.c>

/* PRIVATE TYPES AND CONSTANTS */

/* time before mandatory resend -- 30s */
#define	YDMTD_DEFAULT_TTL_MS    ((sb4)30000)

/* timeout time on poll for death detection of yorts and orbs -- 30s */
#define	YDMTD_DEFAULT_TIMEOUT_MS    (YDMTD_DEFAULT_TTL_MS)
    
/* times with timeout before we let something die */
#define	YDMTD_DEFAULT_LIVES    ((sb4)6)
    
/* Max number of concurrent polls we allow */
#define	YDMTD_DEFAULT_POLL_LIMIT    ((sb4)8)

/* time for the reaper -- free dead things after this long */
#define YDMTD_DEFAULT_REAP_MS	(YDMTD_DEFAULT_TTL_MS * YDMTD_DEFAULT_LIVES)

/* Idle wait in polling after a complete loop - 10 secs */
#define	YDMTD_DEFAULT_POLL_IDLE_MS	((sb4)10000)

/* wait between dest checks - 1 minute */
#define	YDMTD_DEFAULT_DEST_CHECK_MS	((sb4)YDMTD_DEFAULT_TTL_MS)

/* only send if current is more than this % from last sent */
#define	YDMTD_DEFAULT_Q_LEN_SEND_PCT	((sb4)25)

#define	YDMTD_DEFAULT_CHUNK_SIZE	((sb4)50)

/*
 * Command-line Arguments -- none for now!
 */
static struct ysargmap ydmtdmap[] =
{
   { 'x', "mnorbmet.trace-level=5", 0 },
   { 't', "mnorbmet.trace-level", 1 },
   { 'd', "mnorbmet.distribute=true", 0 },
   { 'D', "mnorbmet.trace-dist-only=true", 0 },
   { 'P', "mnorbmet.trace-poll-only=true", 0 },
   { 'p', "mnorbmet.client-proc-metrics", 1 },
   { 'q', "mnorbmet.client-quit=true", 0 },
   { 'c', "mnorbmet.client-stats=true", 0 },
   { 'm', "mnorbmet.client-metrics=true", 0 },
   { 's', "mnorbmet.server=true", 0 },  
   { 'y', "mnorbmet.client-yort-metrics", 1 },
   { 0, (char *) 0, 0 }
};

typedef struct ydmtdcx ydmtdcx;	/* master context */
typedef struct ydmtdd ydmtdd;	/* dist/dest node */
typedef struct ydmtddx ydmtddx;	/* dist/dest context */
typedef struct ydmtde ydmtde;	/* dist/dest queue entry */
typedef struct ydmtdp ydmtdp;	/* poll context */
typedef struct ydmtdy ydmtdy;	/* yort/host node */

/* known yorts (servers) */
struct ydmtdy
{
  ysspNode	    node_ydmtdy;	/* key is yort obj ref  */
  boolean	    ioactive_ydmtdy;	/* poll in progress? */
  sb4		    lives_ydmtdy;	/* number of lives left 0 == dead */
  yort_timeTicks    ourUptime_ydmtdy;	/* time we noticed it */
  yort_timeTicks    hisStart_ydmtdy;	/* his uptime when we noticed it */
  sysb8		    exptime_ydmtdy;	/* time lilist goes invalid */
  yort_procInfo	    iopinfo_ydmtdy;	/* current proc info */
  yort_procInfo	    pinfo_ydmtdy;	/* current proc info */
  boolean	    phave_ydmtdy;	/* have pinfo? */
  yort_dispInfoList iodlist_ydmtdy;	/* current dispatcher info */
  yort_dispInfoList dlist_ydmtdy;	/* current dispatcher info */
  boolean	    dhave_ydmtdy;	/* have dinfo? */
  yort_implAllList  iolist_ydmtdy;	/* current i/o info from the yort */
  yort_implAllList  ilist_ydmtdy;	/* current info from the yort */
  boolean	    ihave_ydmtdy;	/* stuff in ilist? */
  yort_implAllList  lilist_ydmtdy;	/* last from yort distributed  */
  boolean	    lihave_ydmtdy;	/* stuff in lilist? */

  sysb8		    expire_ydmtdy;	/* when to give up on this one */
   
  ydmtdcx   *cx_ydmtdy;		/* pointer back */
  yoenv	    ev_ydmtdy;		/* environment */
  ysevt	    *sem_ydmtdy;	/* completion for poll */
  ysevt	    *tsem_ydmtdy;	/* completion for timeout */
};


/* known destinations */
struct ydmtdd
{
  ysspNode	node_ydmtdd;	/* key is ydim_imr of the orbd */
  sb4		lives_ydmtdd;	/* still alive? 0 == dead */
  ydmt_imtr	ydmt_ydmtdd;	/* ydmt_metrics in the ydim_imr */
  sysb8		expire_ydmtdd;	/* when to give up on this one. */
  sb4		nioactive_ydmtdd; /* i/o active? */
};

/* pending send entry i/o context */
struct ydmtde
{
  ydmtdcx   *cx_ydmtde;		/* the global context */
  ydmtdy    *yh_ydmtde;		/* info being sent */
  ydmtdd    *dest_ydmtde;	/* where it's going */
  yoenv	    ev_ydmtde;		/* env for operation */
  ysevt	    *sem_ydmtde;	/* i/o sem */
  ysevt	    *tsem_ydmtde;	/* timeout sem */
};

/* state id of the poll async machine */
typedef enum
{
  sleeping_ydmtdp,		/* waiting for timeout */
  proclist_ydmtdp,		/* marching through ylist */
  iolimit_ydmtdp,		/* waiting to be under i/o limit */
  iterating_ydmtdp,		/* getting more ylist */
  stopping_ydmtdp,		/* want to leave, intermediate */
  finished_ydmtdp		/* all done. */
} ydmtd_pstate;

/* poll state machine context */
struct ydmtdp
{
  ydmtd_pstate	    state_ydmtdp;
  sb4		    lives_ydmtdp; /* lives allowed */
  sysb8		    pollIdle_ydmtdp; /* between loops */
  ydim_yortList	    ylist_ydmtdp;   /* list of yorts */
  ub4		    cursor_ydmtdp; /* cursor in ylist. */
  ydim_yortIterator yi_ydmtdp;	    /* iterator ref, or NULL */
  sb4		    npolls_ydmtdp;  /* yorts polled */
  sb4		    npending_ydmtdp;
  yoenv		    ev_ydmtdp;	    /* poll environment */
  ysevt		    *sem_ydmtdp;    /* for async ops */
  boolean	    trace_ydmtdp;   /* trace in poll? */
};

/* state id of the dist async machine */
typedef enum
{
  sleeping_ydmtddx,
  getmt_ydmtddx,
  stopping_ydmtddx,
  finished_ydmtddx
} ydmtd_dstate;

/* dist state machine context */
struct ydmtddx			/* distribution context */
{
  ydmtd_dstate state_ydmtddx;

  sysb8	    destInterval_ydmtddx;	/* interval between dest checks */
  yoenv	    ev_ydmtddx;		/* env for async ops */
  ysevt	    *sem_ydmtddx;	/* my machine sem */
  sb4	    nsends_ydmtddx;	/* number of sends started */
  sb4	    npending_ydmtddx;	/* count of i/o pending */
  yslst	    *olist_ydmtddx;	/* list of orbds */
  ydim_imr  imr_ydmtddx;	/* imr of interest */
  boolean   trace_ydmtddx;	/* trace in dist? */
};

/* master context, created by ydmtdInit, freed in ydmtdFree */
struct ydmtdcx
{
  ysque	    *q_ydmtdcx;
  boolean   serving_ydmtdcx;	/* TRUE in in yoService */
  ydmtd	    self_ydmtdcx;

  boolean   dist_ydmtdcx;	/* doing distribution? */

  /* obj attrs */
  sysb8	    timeout_ydmtdcx;	/* timeout on sends or polls */
  sb4	    lives_ydmtdcx;
  sysb8	    ttl_ydmtdcx;	/* time to live for ydmtdy's and ydmtdd's  */
  sb4	    maxPoll_ydmtdcx;	/* max concurrent poll */

  ydim_imr  imr_ydmtdcx;	/* implementation repository, loosely */
  sb4	    trace_ydmtdcx;	/* trace level */

  ysevt	    *dsem_ydmtdcx;	/* post-yoService shutdown semaphore */
  boolean   stop_ydmtdcx;	/* should we stop polling/distributing? */
  sb4	    chunk_ydmtdcx;	/* chunking for block ops */

  ysspTree  ytree_ydmtdcx;	/* yort tree */
  sb4	    nytree_ydmtdcx;
  ysspTree  dtree_ydmtdcx;	/* dest tree */
  sb4	    ndtree_ydmtdcx;

  sysb8	    reap_ydmtdcx;	/* expire time for metrics. */
  ydmtdp    pcx_ydmtdcx;	/* polling context */
  ydmtddx   dcx_ydmtdcx;	/* dist context */
};

/* PRIVATE FUNCTION DECLARATIONS */

/* main operations */
STATICF void ydmtdClient( boolean quit, boolean stats, boolean metrics,
			 char *yortstr, char *noreg procstr );
STATICF void ydmtdServer( sb4 trace );

/* utility */
STATICF ydmtd ydmtdInit( ysque *q );
STATICF void ydmtdTerm( ydmtd mtd );
STATICF void ydmtdCleanup( ydmtdcx *cx );

STATICF void ydmtdSendMetrics( ydmtdcx *cx, ydmtdy *yh, ydmtdd *dest );
STATICF void ydmtdConsiderInfo( ydmtdcx *cx, ydmtdy *yh );
STATICF boolean ydmtdShouldSend(ydmtdcx *cx, yort_implAll *o, yort_implAll *n);
STATICF void ydmtdReaper( ydmtdcx *cx );
STATICF void ydmtdPFree( ydmtdy *yh );
STATICF void ydmtdIFree( ydmtdy *yh );
STATICF void ydmtdDFree( ydmtdy *yh );
STATICF void ydmtdLIFree( ydmtdy *yh );
STATICF void ydmtdYHDestroy( ydmtdy *yh );
STATICF void ydmtdDDDestroy( ydmtdd *dd );

/* OBJECT METHODS */

/* poll related */
STATICF void ydmtdPoll(dvoid *usrp, CONST ysid *exid,
		       dvoid *arg, size_t argsz);
STATICF void ydmtdPollComp(dvoid *usrp, CONST ysid *exid,
			   dvoid *arg, size_t argsz);
STATICF void ydmtdPollTimeout(dvoid *usrp, CONST ysid *exid,
			      dvoid *arg, size_t argsz);
STATICF void ydmtdPollHead( CONST char *msg, CONST ysid *exid, ydmtdy *yh,
			   ydmtdp *p, ydmtdcx *cx );
STATICF void ydmtdPollTail( ydmtdcx *cx, ydmtdp *p );
STATICF CONST char *ydmtdPState( ydmtdp *p );
STATICF void ydmtdProcList( ydmtdcx *cx );
STATICF void ydmtdPollStop( ydmtdcx *cx );

/* dist related */
STATICF void ydmtdDist(dvoid *usrp, CONST ysid *exid,
		       dvoid *arg, size_t argsz);
STATICF void ydmtdDistComp(dvoid *usrp, CONST ysid *exid,
			   dvoid *arg, size_t argsz);
STATICF void ydmtdDistTimeout(dvoid *usrp, CONST ysid *exid,
			      dvoid *arg, size_t argsz);
STATICF CONST char *ydmtdDState( ydmtddx *d );
STATICF boolean ydmtdDeqDest( ydmtdcx *cx );
STATICF void ydmtdDistStop( ydmtdcx *cx );

externdef ysmtagDecl(ydmtdcx_tag) = "ydmtdcx";
externdef ysmtagDecl(ydmtde_tag) = "ydmtde";
externdef ysmtagDecl(ydmtdd_tag) = "ydmtdd";
externdef ysmtagDecl(ydmtdy_tag) = "ydmtdy";

externdef ysidDecl(YDMTD_EX_INTERNAL) = "ydmtd::internal";
externdef ysidDecl(YDMTD_EX_IOLIMIT_OVER) = "ydmtd::iolimit_over";
externdef ysidDecl(YDMTD_EX_MACHINE_DOWN) = "ydmtd::machine_down";
externdef ysidDecl(YDMTD_EX_QUEUE_DOWN) = "ydmtd::queue_down";

static CONST_W_PTR struct ydmtd__tyimpl ydmtd__impl =
 {
  ydmtd_getYortMetrics_i,
  ydmtd_getProcMetrics_i,
  ydmtd_shutdown_i,
  ydmtd__get_self_i,
  ydmtd__get_stats_i,
  ydmtd__get_metrics_i,
  ydmtd__get_ttlMs_i,
  ydmtd__set_ttlMs_i,
  ydmtd__get_pollIdleMs_i,
  ydmtd__set_pollIdleMs_i,
  ydmtd__get_destCheckMs_i,
  ydmtd__set_destCheckMs_i,
  ydmtd__get_timeoutMs_i,
  ydmtd__set_timeoutMs_i,
  ydmtd__get_maxPoll_i,
  ydmtd__set_maxPoll_i
 };


/* PUBLIC FUNCTIONS */

/* ---------------------------- ydmtdMain ---------------------------- */
/*
  NAME
    ydmtdMain
  DESCRIPTION
    Main function for the ORB Metric daemon.
  PARAMETERS
    osdp    -- osd pointer
    nm	    -- program name string
    argc    -- arg count
    argv    -- argument vector.
  RETURNS
    TRUE on success, FALSE on error exit.

  NOTES
    In the future, the modules should be started with queues, and the
    queues serviced in threads.
*/

boolean ydmtdMain(dvoid *osdp, char *nm, sword argc, char **argv)
{
  boolean   ok, quit, stats, metrics;
  sword     sts = 0;
  char	    *arg;
  char      vbuf[80];
  noreg sb4 trace;
  char	    *yortstr;
  char	    *procstr;
  
  NOREG(trace);

  /* initialization */
  ysInit(osdp, nm);
  sts = ysArgParse(argc, argv, ydmtdmap);
  if (sts == YSARG_VERSION)
    {
      yslError("Oracle Media Exchange ORB Metric Daemon");
      vbuf[0] = 0;
      yslError(ysVersion(vbuf, sizeof(vbuf)));
    }
  ok = (sts == YSARG_NORMAL);
  
  if (!ok)
    return(FALSE);
  
  arg = ysResGetLast("mnorbmet.trace-level");
  trace = arg ? atoi(arg) : 0;

  quit = ysResGetBool("mnorbmet.client-quit");
  stats = ysResGetBool("mnorbmet.client-stats");
  metrics = ysResGetBool("mnorbmet.client-metrics");
  yortstr = ysResGetLast("mnorbmet.client-yort-metrics");
  procstr = ysResGetLast("mnorbmet.client-proc-metrics");

  yseTry
  {
    ytInit();
    yoInit();

    if( quit || stats || metrics || yortstr || procstr )
      ydmtdClient( quit, stats, metrics, yortstr, procstr );
    else
    {
      yslDetach();			/* this is a daemon */
      ydmtdServer( trace );
    }
  }
  yseCatch( YS_EX_INTERRUPT )
  {
  }
  yseCatchAll
    yslError("%s caught exception %s, exiting\n",
	     ysProgName(), ysidToStr(yseExid));
  yseEnd;

  yseTry
  {
    if( trace ) yslError("ydmtdMain: yoTerm...\n");
    yoTerm();
    if( trace ) yslError("ydmtdMain: ytTerm...\n");
    ytTerm();
  }
  yseCatchAll
    yslError("%s caught exception %s while exiting\n",
	     ysProgName(), ysidToStr(yseExid));
  yseEnd;

  if( trace ) yslError("ydmtdMain: ysTerm...\n");
  ysTerm(osdp);
  return TRUE;
}

/* ---------------------------------------------------------------- */
/* PRIVATE FUNCTIONS */
/* ---------------------------------------------------------------- */


/* ---------------------------- ydmtdServer ---------------------------- */
/*
  NAME
    ydmtdServer
  DESCRIPTION
    Become the ydmtd metric daemon server.   Return when everything
    is shut down.
  PARAMETERS
    trace	-- trace level.
  RETURNS
    none
*/
STATICF void ydmtdServer( sb4 trace )
{
  ydmtdcx   *cx;
  ydmtd	    mtd;
  ysque *q;
  
  if( trace )
    yslError("ydmtdServer: Becoming ORBD Metric server\n");

  q = yoQueCreate( "ydmtd" );

  /* init objects */
  mtd = ydmtdInit( q );
  
  cx = (ydmtdcx*)yoGetImplState( (dvoid*)mtd );

  /* do service loop */
  
  if( trace ) yslError("ydmtdServer: Entering service loop...\n");

  cx->serving_ydmtdcx = TRUE;
  yseTry
    yoService( q ); 
  yseCatch( YS_EX_INTERRUPT )
    yslError("ydmtdIntrHdlr: interrupted, shutting down");
  yseEnd;
  cx->serving_ydmtdcx = FALSE;
  
  if( trace ) yslError("ydmtdServer: Exited service loop.\n");
  
  if( trace ) yslError("ydmtdServer: terminating object services\n");
  ydmtdTerm( mtd );
  
  /* stop queue(s), drive everything to completion */
  if( trace )
    yslError("ydmtdServer: destroying queue %x\n", q );

  yoQueDestroy( q );

  if( trace )
    yslError("ydmtdServer: ready to exit\n");
}


/* ---------------------------- ydmtdClient ---------------------------- */
/*
  NAME
    ydmtdClient
  DESCRIPTION
    Do client operations against all ydmtd daemons -- collect statistics,
    and possibly set them to shutdown.
  PARAMETERS
    trace	-- trace level
    quit	-- if we should shut down all daemons.
  RETURNS
    none
*/

STATICF void ydmtdClient( boolean quit, boolean dostats, boolean metrics,
			 char *yortstr, char *noreg procstr )
{
  ydmtd	    lmtd;
  yoenv	    ev;
  ydmtdStats	    stats;
  ydmtdMetricsList  mlist;
  ydmtdMetrics	    met;
  yort_proc yort;
  char *host;
  char *pid;
  char *aff;
  
  NOREG(procstr);
  yoEnvInit(&ev);
 
  lmtd = (ydmtd)yoBind(ydmtd__id, (char *)0, (yoRefData*)0, (char*)0);
  yseTry
  {
    if( dostats )
    {
      yslPrint("%8s %8s %8s %8s\n",
	       "ndests", "nyorts", "npolls", "nsends" );
      yslPrint("%8s %8s %8s %8s\n",
	       "--------", "--------", "--------", "--------" );
      stats = ydmtd__get_stats( lmtd, &ev );
      yslPrint("%8d %8d %8d %8d\n",
	       stats.ndests_ydmtdStats,
	       stats.nyorts_ydmtdStats,
	       stats.npolls_ydmtdStats,
	       stats.nsends_ydmtdStats );
      ydmtdStats__free( &stats, yoFree);
    }
    if( metrics )
    {
      mlist = ydmtd__get_metrics(lmtd, &ev); 
      yslPrint("Metrics from mtd -- %d procs\n", mlist._length);
      ydqShowMtdList( &mlist );
      ydmtdMetricsList__free(&mlist, yoFree);
    }

    if( yortstr )
    {
      yort = (yort_proc)yoStrToRef( yortstr ); 
      ydmtd_getYortMetrics( lmtd, &ev, yort, &met );
      mlist._length = mlist._maximum = 1;
      mlist._buffer = &met;
      ydqShowMtdList( &mlist );
      ydmtdMetrics__free( &met, yoFree );
      yoRelease( (dvoid*)yort );
    }

    if( procstr )
    {
      host = procstr;
      while( *procstr && *procstr != ':' )
	procstr++;
      if( *procstr && *procstr == ':' )
	*procstr++ = 0;
      pid = procstr;
      while( *procstr && *procstr != ':' )
	procstr++;
      if( *procstr && *procstr == ':' )
	*procstr++ = 0;
      aff = procstr;

      ydmtd_getProcMetrics( lmtd, &ev, host, pid, aff, &met );
      mlist._length = mlist._maximum = 1;
      mlist._buffer = &met;
      ydqShowMtdList( &mlist );
      ydmtdMetrics__free( &met, yoFree );
    }

    if( quit )
      ydmtd_shutdown( lmtd, &ev );
  }
  yseCatch(YO_EX_BADOBJ)
  {
    /* expected */
  }
  yseCatchAll
    yslError("%s caught exception %s, exiting\n",
	     ysProgName(), ysidToStr(yseExid));
  yseEnd

  yoRelease( (dvoid*)lmtd );
  yoEnvFree(&ev);
}


/* ---------------------------- ydmtdInit ---------------------------- */
/*
  NAME
    ydmtdInit
  DESCRIPTION
    Initialize ydmtd objects for service, and start the poll and
    distribution loops.
  PARAMETERS
    q		-- q to use
  RETURNS
    object reference to the ydmtd we're implementing.
*/

STATICF ydmtd ydmtdInit( ysque *q )
{
  ydmtdcx   *cx = (ydmtdcx*)ysmGlbAlloc( sizeof(*cx), "ydmtdcx" );
  char	    *arg;
  sb4	    val;
  ydmtdp    *p = &cx->pcx_ydmtdcx;
  ydmtddx   *d = &cx->dcx_ydmtdcx;

  CLRSTRUCT(*cx);

  cx->q_ydmtdcx = q;
  cx->serving_ydmtdcx = FALSE;
  cx->imr_ydmtdcx = (ydim_imr)yoBind( ydim_imr__id, (char*)0,
				     (yoRefData*)0,(char*)0);

  arg = ysResGetLast("mnorbmet.trace-level");
  cx->trace_ydmtdcx = arg ? atoi(arg) : 0;

  cx->stop_ydmtdcx = FALSE;

  arg = ysResGetLast("mnorbmet.chunksize");
  cx->chunk_ydmtdcx = arg ? atoi(arg) : YDMTD_DEFAULT_CHUNK_SIZE;

  arg = ysResGetLast("mnorbmet.ttl-ms");
  val = arg ? (sb4)atol( arg ) : YDMTD_DEFAULT_TTL_MS;
  sysb8ext( &cx->ttl_ydmtdcx, val * 1000 );

  arg = ysResGetLast("mnorbmet.max-polls");
  val = arg ? (sb4)atol( arg ) : YDMTD_DEFAULT_POLL_LIMIT;
  cx->maxPoll_ydmtdcx = val;
  if( cx->maxPoll_ydmtdcx < 0 )
    cx->maxPoll_ydmtdcx = 1;

  arg = ysResGetLast("mnorbmet.reap-ms");
  val = arg ? (sb4)atol( arg ) : YDMTD_DEFAULT_REAP_MS;
  sysb8ext( &cx->reap_ydmtdcx, val * 1000 );

  arg = ysResGetLast("mnorbmet.timeout-ms");
  val = arg ? (sb4)atol( arg ) : YDMTD_DEFAULT_TIMEOUT_MS;
  sysb8ext( &cx->timeout_ydmtdcx, val * 1000 );

  arg = ysResGetLast("mnorbmet.lives");
  cx->lives_ydmtdcx = arg ? (sb4)atol( arg ) : YDMTD_DEFAULT_LIVES;

  DISCARD ysspNewTree( &cx->ytree_ydmtdcx, yoCmp );
  cx->nytree_ydmtdcx = 0;
  DISCARD ysspNewTree( &cx->dtree_ydmtdcx, yoCmp );
  cx->ndtree_ydmtdcx = 0;

  p->trace_ydmtdp = d->trace_ydmtddx = TRUE;
  if( ysResGetBool("mnorbmet.trace-dist-only") )
    p->trace_ydmtdp = FALSE;
  if( ysResGetBool("mnorbmet.trace-poll-only") )
    d->trace_ydmtddx = FALSE;

  /* set up poll context */
  p->state_ydmtdp = sleeping_ydmtdp;

  arg = ysResGetLast("mnorbmet.poll-idle-ms");
  val = arg ? (sb4)atol( arg ) : YDMTD_DEFAULT_POLL_IDLE_MS;
  sysb8ext( &p->pollIdle_ydmtdp, val * 1000 );

  p->npolls_ydmtdp = p->npending_ydmtdp = 0;
  p->ylist_ydmtdp._length = p->ylist_ydmtdp._maximum = 0;
  p->ylist_ydmtdp._buffer = (yort_proc*)0;
  p->yi_ydmtdp = (ydim_yortIterator)0;
  yoEnvInit( &p->ev_ydmtdp );
  p->sem_ydmtdp = ysEvtCreate( ydmtdPoll, (dvoid*)cx, cx->q_ydmtdcx, TRUE );
  
  d->state_ydmtddx = finished_ydmtddx;
  if( (cx->dist_ydmtdcx = ysResGetBool( "mnorbmet.distribute" ) ) )
  {    
    /* set up distribution context */
    d->state_ydmtddx = sleeping_ydmtddx;
    
    arg = ysResGetLast("mnorbmet.dest-check-ms");
    val = arg ? (sb4)atol( arg ) : YDMTD_DEFAULT_DEST_CHECK_MS;
    sysb8ext( &d->destInterval_ydmtddx, val * 1000 );
    
    d->npending_ydmtddx = d->nsends_ydmtddx = 0;
    d->olist_ydmtddx = (yslst*)0;
    yoEnvInit( &d->ev_ydmtddx );
    d->sem_ydmtddx = (ysevt*)ysEvtCreate( ydmtdDist, (dvoid*)cx,
					 cx->q_ydmtdcx, TRUE );
  }

  /* start async polling  */
  ysTrigger( p->sem_ydmtdp, YS_EX_TIMEOUT, (dvoid*)0, (size_t)0 );

  /* start async distribution/dest checking */
  if( cx->dist_ydmtdcx )
    ysTrigger( d->sem_ydmtddx, (ysid*)0, (dvoid*)0, (size_t)0 );
  
  /* then serve objects syncronously on the queue */
  
  yoSetImpl( ydmtd__id, (char*)0, ydmtd__stubs,
	    (dvoid*)&ydmtd__impl, (yoload)0, TRUE, (dvoid*)cx );
  
  cx->self_ydmtdcx = (ydmtd)yoCreate( ydmtd__id, (char*)0,
				      (yoRefData*)0, (char*)0, (dvoid*)cx);
  
  yoImplReady( ydmtd__id, (char*)0, cx->q_ydmtdcx );

  return( cx->self_ydmtdcx );
}


/* ---------------------------- ydmtdTerm ---------------------------- */
/*
  NAME
    ydmtdTerm
  DESCRIPTION
    Terminate the ydmtd objects and the polling and distribution
    loops.  Does not return until all is shut down.
  PARAMETERS
    mtd	    -- object reference from ydmtdInit
  RETURNS
    none
*/
STATICF void ydmtdTerm( ydmtd mtd )
{
  ydmtdcx *cx = (ydmtdcx*)yoGetImplState( (dvoid*)mtd );

  /* take out objs immediately, so if we hang at least the imr
     is rid of us. */

  yoDispose( (dvoid*)mtd );
  yoImplDeactivate( ydmtd__id, (char*)0 );

  cx->dsem_ydmtdcx = ysSemCreate( (dvoid*)0 );
  cx->stop_ydmtdcx = TRUE;

  if( cx->trace_ydmtdcx >= 2 )
  {
    yslError("ydmtdTerm: stopping async services\n");
    yslError("ydmtdTerm: poll in state '%s', dist in state '%s'\n",
	     ydmtdPState( &cx->pcx_ydmtdcx ),
	     ydmtdDState( &cx->dcx_ydmtdcx ));
  }

  /* now, service async evts till they wrap themselves up. */

  ysSvcLoop( cx->q_ydmtdcx, cx->dsem_ydmtdcx );
  ysSemDestroy( cx->dsem_ydmtdcx );

  /* FIXME -- maybe cancel sleep timers here -- how? */

  if( cx->trace_ydmtdcx >= 2 )
  {
    yslError("ydmtdTerm: async services stopped\n");
    yslError("ydmtdTerm: poll in state '%s', dist in state '%s'\n",
	     ydmtdPState( &cx->pcx_ydmtdcx ),
	     ydmtdDState( &cx->dcx_ydmtdcx ));
  }
  ydmtdCleanup( cx );
}


/* ---------------------------- ydmtdCleanup ---------------------------- */
/*
  NAME
    ydmtdCleanup
  DESCRIPTION
    Free all contexts in use prior to exit.
  PARAMETERS
    cx	    -- the ydmtd context identifying everything.
  RETURNS
    none
*/
STATICF void ydmtdCleanup( ydmtdcx *cx )
{
  ydmtdp *p = &cx->pcx_ydmtdcx;
  ydmtddx *d = &cx->dcx_ydmtdcx;
  ydmtdy *yh;
  ydmtdd *dd;
  if( p->yi_ydmtdp )
  {
    /* call it sync; we don't care anymore */
    p->yi_ydmtdp = (ydim_yortIterator)0;
    if( cx->trace_ydmtdcx >= 4 )
      yslError("ydmtdCleanup: destroying yort iterator %x\n", p->yi_ydmtdp );
    ydim_yortIterator_destroy( p->yi_ydmtdp, &p->ev_ydmtdp );
  }

  if( p->ylist_ydmtdp._buffer ) /* release old list */
    ydim_yortList__free( &p->ylist_ydmtdp, yoFree );

  if( d->olist_ydmtddx )
    ysLstDestroy( d->olist_ydmtddx, (ysmff)0 );

  /* ALIGNOK */
  while( (yh = (ydmtdy*)ysspDeq( &cx->ytree_ydmtdcx.root_ysspTree ) ) )
    ydmtdYHDestroy( yh );

  /* ALIGNOK */
  while( (dd = (ydmtdd*)ysspDeq( &cx->dtree_ydmtdcx.root_ysspTree ) ) )
    ydmtdDDDestroy( dd );

  yoRelease((dvoid*)cx->imr_ydmtdcx);
  yoEnvFree( &p->ev_ydmtdp );
  ysmGlbFree( (dvoid*)cx );
}

/* ---------------- */
/* OBJECT METHODS */
/* ---------------- */

/* ARGSUSED */
void ydmtd_getYortMetrics_i( ydmtd or, yoenv* ev, yort_proc yort,
			    ydmtdMetrics* metrics)
{
  ydmtdcx *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  ysspNode *n;
  ydmtdy *yh;
  yort_implAllList *m = (yort_implAllList*)0;

  if( (n = ysspLookup( (dvoid*)yort, &cx->ytree_ydmtdcx ) ) )
  {
    /* ALIGNOK */
    yh = (ydmtdy*)n;

    yort_procInfo__copy( &metrics->pinfo_ydmtdMetrics,
			&yh->pinfo_ydmtdy, yoAlloc );

    yort_dispInfoList__copy( &metrics->dlist_ydmtdMetrics,
			    &yh->dlist_ydmtdy, yoAlloc );

    /* if ilist ok, use it, else assume lilist is ok */
    m = yh->ihave_ydmtdy ? &yh->ilist_ydmtdy : &yh->lilist_ydmtdy;

    yort_implAllList__copy( &metrics->metrics_ydmtdMetrics, m, yoAlloc );
  }
  else
    yseThrow(YDMTD_EX_NOTFOUND);
}

/* ARGSUSED */
void ydmtd_getProcMetrics_i( ydmtd or, yoenv* ev, char* host, char* pid,
			    char* affinity, ydmtdMetrics* metrics)
{
  ydmtdcx *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  ysspNode *n;
  ydmtdy *yh;
  yort_procInfo *pinfo;
  yort_implAllList *m = (yort_implAllList*)0;

  for( n = ysspFHead( &cx->ytree_ydmtdcx ) ; n ; n = ysspFNext( n ) )
  {
    /* ALIGNOK */
    yh = (ydmtdy*)n;
    pinfo = &yh->pinfo_ydmtdy;

    if( yh->phave_ydmtdy && 
       !strcmp( host, pinfo->host_yort_procInfo ) &&
       !strcmp( pid, pinfo->pid_yort_procInfo ) &&
       !yduWildStrcmp( affinity, pinfo->affinity_yort_procInfo ))
    {
      yort_procInfo__copy( &metrics->pinfo_ydmtdMetrics,
			  &yh->pinfo_ydmtdy, yoAlloc );

      yort_dispInfoList__copy( &metrics->dlist_ydmtdMetrics,
			      &yh->dlist_ydmtdy, yoAlloc );

      /* if ilist ok, use it, else assume lilist is ok */
      m = yh->ihave_ydmtdy ? &yh->ilist_ydmtdy : &yh->lilist_ydmtdy;

      yort_implAllList__copy( &metrics->metrics_ydmtdMetrics, m, yoAlloc );
      return;
    }
  }
  yseThrow(YDMTD_EX_NOTFOUND);
}


/* ARGSUSED */
ydmtdMetricsList ydmtd__get_metrics_i( ydmtd or, yoenv *ev)
{
  ydmtdcx *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  ysspNode *n;
  ydmtdy *yh;
  ydmtdMetricsList  mlist;
  yort_implAllList *m = (yort_implAllList*)0;

  mlist._maximum = (ub4)cx->nytree_ydmtdcx;
  mlist._buffer = (ydmtdMetrics*)yoAlloc( (size_t)cx->nytree_ydmtdcx *
					 sizeof(ydmtdMetrics));
  mlist._length = 0;
  for( n = ysspFHead( &cx->ytree_ydmtdcx ) ; n ; n = ysspFNext(n) )
  {
    /* ALIGNOK */
    yh = (ydmtdy*)n;

    /* if first in progress, or never answered, skip */
    if( !yh->phave_ydmtdy )
      continue;
    
    yort_procInfo__copy( &mlist._buffer[mlist._length].pinfo_ydmtdMetrics,
			&yh->pinfo_ydmtdy, yoAlloc );

    yort_dispInfoList__copy( &mlist._buffer[mlist._length].dlist_ydmtdMetrics,
			    &yh->dlist_ydmtdy, yoAlloc );

    /* if ilist ok, use it, else assume lilist is ok */
    m = yh->ihave_ydmtdy ? &yh->ilist_ydmtdy : &yh->lilist_ydmtdy;

    yort_implAllList__copy( &mlist._buffer[mlist._length].metrics_ydmtdMetrics,
			   m, yoAlloc );

    mlist._length++;
  }

  return( mlist );
}


/* ARGSUSED */
void ydmtd_shutdown_i( ydmtd or, yoenv *ev)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  ydmtdp    *p = &cx->pcx_ydmtdcx;
  ydmtddx   *d = &cx->dcx_ydmtdcx;

  if( cx->trace_ydmtdcx >= 1 )
    yslError("ydmtd_Shutdown_i: set flag to stop %d poll, %d dist\n",
	     p->npending_ydmtdp, d->npending_ydmtddx );
  
  /* do yo shutdown, service in ydmdtTerm till loops stop.  */
  yoShutdown( cx->q_ydmtdcx );
}


/* ARGSUSED */
ydmtd ydmtd__get_self_i( ydmtd or, yoenv* ev)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  return( (ydmtd)yoDuplicate((dvoid*)cx->self_ydmtdcx ) );
}


/* ARGSUSED */
sb4 ydmtd__get_pollIdleMs_i( ydmtd or, yoenv *ev)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  sb4	    rv;
  
  rv = sysb8msk( &cx->pcx_ydmtdcx.pollIdle_ydmtdp ) / 1000;
  return( rv );
}

/* ARGSUSED */
void ydmtd__set_pollIdleMs_i( ydmtd or, yoenv *ev, sb4 val)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );

  sysb8ext( &cx->pcx_ydmtdcx.pollIdle_ydmtdp, val * 1000 );
}

/* ARGSUSED */
sb4 ydmtd__get_timeoutMs_i( ydmtd or, yoenv *ev)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  sb4	    rv;
  
  rv = sysb8msk( &cx->timeout_ydmtdcx ) / 1000;
  return( rv );
}

/* ARGSUSED */
void ydmtd__set_timeoutMs_i( ydmtd or, yoenv *ev, sb4 val)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );

  sysb8ext( &cx->timeout_ydmtdcx, val * 1000 );
}


/* ARGSUSED */
sb4 ydmtd__get_ttlMs_i( ydmtd or, yoenv *ev)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  sb4	    rv;
  
  rv = sysb8msk( &cx->ttl_ydmtdcx ) / 1000;
  return( rv );
}

/* ARGSUSED */
void ydmtd__set_ttlMs_i( ydmtd or, yoenv *ev, sb4 val)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );

  sysb8ext( &cx->ttl_ydmtdcx, val * 1000 );
}


/* ARGSUSED */
sb4 ydmtd__get_destCheckMs_i( ydmtd or, yoenv *ev)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  sb4	    rv;

  rv = sysb8msk( &cx->dcx_ydmtdcx.destInterval_ydmtddx ) / 1000;
  return( rv );
}

/* ARGSUSED */
void ydmtd__set_destCheckMs_i( ydmtd or, yoenv *ev, sb4 val)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );

  sysb8ext( &cx->dcx_ydmtdcx.destInterval_ydmtddx, val * 1000 );
}

/* ARGSUSED */
sb4 ydmtd__get_maxPoll_i( ydmtd or, yoenv *ev)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  return( cx->maxPoll_ydmtdcx );
}

/* ARGSUSED */
void ydmtd__set_maxPoll_i( ydmtd or, yoenv *ev, sb4 val)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  cx->maxPoll_ydmtdcx = val;
  if( cx->maxPoll_ydmtdcx < 0 )
    cx->maxPoll_ydmtdcx = 1;
}

/* ARGSUSED */
ydmtdStats ydmtd__get_stats_i( ydmtd or, yoenv *ev)
{
  ydmtdcx   *cx = (ydmtdcx*)yoGetImplState( (dvoid*)or );
  ydmtdStats rv;

  rv.ndests_ydmtdStats = cx->ndtree_ydmtdcx;
  rv.nyorts_ydmtdStats = cx->nytree_ydmtdcx;
  rv.npolls_ydmtdStats = cx->pcx_ydmtdcx.npolls_ydmtdp;
  rv.nsends_ydmtdStats = cx->dcx_ydmtdcx.nsends_ydmtddx;
  return( rv );
}

/* ---------------- */
/* INTERNAL */
/* ---------------- */

/* ---------------- */
/* POLL RELATED */
/* ---------------- */

/* ---------------------------- ydmtdPoll ---------------------------- */
/*
  NAME
    ydmtdPoll
  DESCRIPTION
    Async function that handles all of the polling loop and iteration.

    This is organized as a state machine, as there are various operations
    that need to be launched in sequence.

  PARAMETERS
    usrp	-- ydmtd cx
    exid	-- exception from the operation
    arg		-- sometimes the operation return
    argsz	-- return size.
  RETURNS
    none
*/

STATICF void ydmtdPoll(dvoid *usrp, CONST ysid *exid,
		       dvoid *arg, size_t argsz)
{
  ydmtdcx   *cx = (ydmtdcx*)usrp;
  ydmtdp    *p;
  ydim_yortIterator yi;
  
  p = &cx->pcx_ydmtdcx;    
  ysEvtDestroy( p->sem_ydmtdp );
  p->sem_ydmtdp = (ysevt*)0;

  if( exid && (ysidEq(exid,YS_EX_SHUTDOWN) || ysidEq(exid,YS_EX_CANCELLED)) )
  {
    yslError("ydmtdPoll: exid %s, returning\n", ysidToStr(exid) );
    return;
  }

  if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 4 )
    yslError("ydmtdPoll: entry state %s ex '%s' arg %x argsz %d\n",
	     ydmtdPState(p), yduIdStr(exid), arg, argsz);
  
  /* need sem unless stopping */
  if( cx->stop_ydmtdcx )
    p->state_ydmtdp = stopping_ydmtdp;
  else
    p->sem_ydmtdp = ysEvtCreate( ydmtdPoll, (dvoid*)cx,
				cx->q_ydmtdcx, TRUE );

  switch( p->state_ydmtdp )
  {
  case stopping_ydmtdp:

    ydmtdPollStop( cx );
    break;

  case sleeping_ydmtdp:			/* start a new poll */
    
    if( exid && !ysidEq(exid,YS_EX_TIMEOUT) )
      yslError("ydmtdPoll: unexpected exception %s in state %s\n",
	       yduIdStr(exid), ydmtdPState(p) );
    else if( !exid )
      yslError("ydmtdPoll: sleeping, but woke up without timeout!?\n");

    ydmtdReaper( cx );
    p->state_ydmtdp = proclist_ydmtdp;
    p->cursor_ydmtdp = 0;
    if( p->ylist_ydmtdp._buffer ) /* release old list */
    {
      ydim_yortList__free( &p->ylist_ydmtdp, yoFree );
      p->ylist_ydmtdp._buffer = (yort_proc*)0;
      p->ylist_ydmtdp._length = p->ylist_ydmtdp._maximum = 0;
    }
    ydim_imr_listYort_nw( cx->imr_ydmtdcx,
			 &p->ev_ydmtdp, cx->chunk_ydmtdcx, (yort_proc)0, 
			 &p->ylist_ydmtdp, &p->yi_ydmtdp, p->sem_ydmtdp );
    break;

  case proclist_ydmtdp:			/* run down the current list */
    
    /* list yort failed? */
    if( exid && ysidEq(exid,YT_EX_BROKEN) )
    {
      ydmtd_shutdown_i( cx->self_ydmtdcx, (yoenv*)0 );
      ydmtdPollStop( cx );
      break;
    }

    if( exid && ysidEq(exid,YDMTD_EX_IOLIMIT_OVER) )
    {
      /* restart poll -- probably addrs out-of-date  */
      if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 5 )
	yslError("ydmtdPoll: exception %s in state %s, restarting poll\n",
	       yduIdStr(exid), ydmtdPState(p) );
      p->state_ydmtdp = sleeping_ydmtdp;
      ysTimer( &p->pollIdle_ydmtdp, p->sem_ydmtdp );
    }
    ydmtdProcList( cx );
    break;

  case iolimit_ydmtdp:  	/* run down the current list after wait */
    
    /* never expect to execute this state at all; it's for parking. */
    yslError("ydmtdPoll: unexpected exid %s in state %s\n",
	     yduIdStr(exid), ydmtdPState(p) );
    break;

  case iterating_ydmtdp:		/* handle iteration end */

    if( exid )
      yslError("ydmtdPoll: unexpected exception %s in state %s\n",
	       yduIdStr(exid), ydmtdPState(p) );

    if( exid || !(*(boolean*)arg) )
    {
      if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 5 )
	yslError("ydmtdPoll: iterating over\n");
      yi = p->yi_ydmtdp;
      p->state_ydmtdp = proclist_ydmtdp;
      p->yi_ydmtdp = (ydim_yortIterator)0;

      if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 1 )
	yslError("ydmtdPoll: destroying yi %x @ %x\n", yi, &p->yi_ydmtdp );

      ydim_yortIterator_destroy_nw( yi, &p->ev_ydmtdp, p->sem_ydmtdp );
      break;
    }
    ydmtdProcList( cx );
    break;
    
  default:

    yslError("ymtdpPoll: invalid state %d!?, exception %s\n",
	     p->state_ydmtdp, yduIdStr(exid) );
    ysePanic( exid ? exid : YDMTD_EX_INTERNAL);
    break;
  }

  if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 4)
    yslError("ydmtdPoll: exit state %s, sem %x\n",
	     ydmtdPState(p), p->sem_ydmtdp );
}


/* ---------------------------- ydmtdPollComp ---------------------------- */
/*
  NAME
    ydmtdPollComp
  DESCRIPTION
    Completion handler for async poll operation.  This one gets triggered
    on normal completion, or on transport errors (like dead server).

    It destroys the i/o and timeout events, saves the new data, and
    if necessary sends it to the interested destinations.
    
  PARAMETERS
    usrp    -- the ydmtdy of the i/o op.
    exid    -- the completion exception.
    arg	    -- ignored.
    argsz   -- ignored.
  RETURNS
    none
*/

/* ARGSUSED */
STATICF void ydmtdPollComp(dvoid *usrp, CONST ysid *exid,
			   dvoid *arg, size_t argsz)
{
  ydmtdy    *yh = (ydmtdy*)usrp;
  ydmtdcx   *cx = yh->cx_ydmtdy;
  ydmtdp    *p = &cx->pcx_ydmtdcx;
  sysb8	    t, tenk, cs;

  ydmtdPollHead( "ydmtdPollComp", exid, yh, p, cx );    
  if( !exid )		/* it's good data */
  {
    if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 4 )
      yslError("ydmtdPollComp: got yh %x pinfo %x %s/%s/%s %s y:%x ilist %x\n",
	       yh, &yh->pinfo_ydmtdy,
	       yduStr(yh->pinfo_ydmtdy.host_yort_procInfo),
	       yduStr(yh->pinfo_ydmtdy.pid_yort_procInfo),
	       yduStr(yh->pinfo_ydmtdy.affinity_yort_procInfo),
	       yduStr(yh->pinfo_ydmtdy.name_yort_procInfo),
	       yh->node_ydmtdy.key_ysspNode,
	       yh->ilist_ydmtdy );
    
    ysGetUpTime(&yh->expire_ydmtdy);
    sysb8add( &yh->expire_ydmtdy, &yh->expire_ydmtdy, &cx->reap_ydmtdcx );
    
    /* copy from i/o space (that will be freed) to permanent ysmGlbAlloc */
    yort_procInfo__copy( &yh->pinfo_ydmtdy, &yh->iopinfo_ydmtdy,
			yotkAllocStr );
    yort_procInfo__free( &yh->iopinfo_ydmtdy, yoFree );
    yh->phave_ydmtdy = TRUE;

    yort_dispInfoList__copy( &yh->dlist_ydmtdy, &yh->iodlist_ydmtdy,
			    yotkAllocStr );
    yort_dispInfoList__free( &yh->iodlist_ydmtdy, yoFree );
    yh->dhave_ydmtdy = TRUE;

    yort_implAllList__copy( &yh->ilist_ydmtdy, &yh->iolist_ydmtdy,
			   yotkAllocStr );
    yort_implAllList__free( &yh->iolist_ydmtdy, yoFree );
    yh->ihave_ydmtdy = TRUE;

    /* If we haven't seen this before, mark it as up now */
    if( !yh->ourUptime_ydmtdy )
    {
      if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 5 )
	yslError("ydmtdPollComp: new yort\n");

      ysGetUpTime(&t);
      sysb8ext( &tenk, 10000 );
      sysb8div( &cs, &t, &tenk );
      yh->ourUptime_ydmtdy = sysb8msk( &cs );
      yh->hisStart_ydmtdy = yh->pinfo_ydmtdy.upTime_yort_procInfo;
    }
    ydmtdConsiderInfo( cx, yh );
  }
  ydmtdPollTail( cx, p );
}


/* --------------------------- ydmtdPollTimeout --------------------------- */
/*
  NAME
    ydmtdPollTimeout
  DESCRIPTION
    Completion handler for timeout on on a poll i/o operation.  If this
    happens, we cancel the outstanding i/o and this timeout event,
    and then take one of the target's lives.
  PARAMETERS
    usrp    -- the ydmtdy of the i/o op.
    exid    -- the completion exception.
    arg	    -- ignored.
    argsz   -- ignored.

  RETURNS
    none    
*/

/* ARGSUSED */
STATICF void ydmtdPollTimeout(dvoid *usrp, CONST ysid *exid,
			      dvoid *arg, size_t argsz)
{
  ydmtdy *yh = (ydmtdy*)usrp;
  ydmtdcx *cx = yh->cx_ydmtdy;
  ydmtdp *p = &cx->pcx_ydmtdcx;
  
  ydmtdPollHead( "ydmtdPollTimeout", exid, yh, p, cx );
  ydmtdPollTail( cx, p );
}


/* ---------------------------- ydmtdPollHead ---------------------------- */
/*
  NAME
    ydmtdPollHead
  DESCRIPTION
    Common parts at the beginning of the ydmtdPollComp and ydmtdPollTimeout
    handlers.  Destroys both events, handles log messages, exceptions,
    lives, and destroying newly dead targets.
  PARAMETERS
    msg	    -- message to prefix traces with.
    yh	    -- the target of completion.
    p	    -- the poll context
    cx	    -- the global context
  RETURNS
    none
*/

STATICF void ydmtdPollHead( CONST char *msg, CONST ysid *exid, ydmtdy *yh,
			   ydmtdp *p, ydmtdcx *cx )
{
  ysEvtDestroy( yh->sem_ydmtdy );
  ysEvtDestroy( yh->tsem_ydmtdy );
  yh->ioactive_ydmtdy = FALSE;
  p->npending_ydmtdp--;

  if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 4 )
  {
    yslError("%s: yh %x, ex '%s' y:%x\n",
	     msg, yh, yduIdStr(exid), yh->node_ydmtdy.key_ysspNode );
    yslError("%s: sem %x, tsem %x\n",
	     msg, yh->sem_ydmtdy, yh->tsem_ydmtdy );
  }

  if( exid && (ysidEq(exid,YT_EX_BADADDR) || ysidEq(exid,YT_EX_BROKEN)))
				yh->lives_ydmtdy = 0;
  else if( exid )		yh->lives_ydmtdy-- ;
  else				yh->lives_ydmtdy = cx->lives_ydmtdcx;
  if( yh->lives_ydmtdy < 0 )    yh->lives_ydmtdy = 0;
  
  if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 4  )
    yslError("%s: npending %d, state %s  stop %d\n",
	     msg, p->npending_ydmtdp, ydmtdPState(p), cx->stop_ydmtdcx);

  /* keep anyone from seeing this again */
  if(!yh->lives_ydmtdy)
  {
    if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 4 )
    {
      yslError("%s: Destroying yort of dead target...\n", msg);
      yslError("%s: yh->ev._buffer is %x\n", msg, yh->ev_ydmtdy._buffer );
    }
    ydim_imr_destroyYortGlobal_nw( cx->imr_ydmtdcx, &yh->ev_ydmtdy,
				  (yort_proc)yh->node_ydmtdy.key_ysspNode,
				  ysEvtDummy() );
  }
  if( exid && !ysidEq(exid,YT_EX_BADADDR) && !ysidEq(exid,YS_EX_TIMEOUT) &&
     !ysidEq(exid,YT_EX_BROKEN) )
  {
    yslError( "%s: unexpected exid %s to y:%x\n", msg,
	     yduIdStr(exid), yh->node_ydmtdy.key_ysspNode );
  }
}

/* ---------------------------- ydmtdPollTail ---------------------------- */
/*
  NAME
    ydmtdPollTail
  DESCRIPTION
    Common parts at the end of ydmtdPollComp and ydmtdPollTimeout.
    Checks stop processing, and whether to re-awaken the poll machine
    after falling back under the concurrent poll limit.
  PARAMETERS
    cx	    -- context
    p	    -- the party being polled.
  RETURNS
    none
*/

STATICF void ydmtdPollTail( ydmtdcx *cx, ydmtdp *p )
{
  if( cx->stop_ydmtdcx )
    ydmtdPollStop( cx );

  if( p->state_ydmtdp == iolimit_ydmtdp &&
     p->sem_ydmtdp && p->npending_ydmtdp < cx->maxPoll_ydmtdcx )
  {
    if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 2 )
      yslError("ydmtdPollTail: back under poll limit\n");
    p->state_ydmtdp = proclist_ydmtdp;
    ysTrigger( p->sem_ydmtdp, YDMTD_EX_IOLIMIT_OVER, (dvoid*)0, (size_t)0 );
  }

  if( !cx->stop_ydmtdcx )
    ysSvcAll( cx->q_ydmtdcx );
}


/* ---------------------------- ydmtdPState ---------------------------- */
/*
  NAME
    ydmtdPState
  DESCRIPTION
    decode the ydmtdPoll machine state for pretty debug info.
  PARAMETERS
    p	    -- poll machine state.
  RETURNS
    char string describing the state.
*/

STATICF CONST char *ydmtdPState( ydmtdp *p )
{
  switch( p->state_ydmtdp )
  {
  case sleeping_ydmtdp:    return "sleeping";   
  case proclist_ydmtdp:    return "proclist";
  case iolimit_ydmtdp:    return "iolimit";
  case iterating_ydmtdp:   return "iterating";
  case stopping_ydmtdp:    return "stopping";
  case finished_ydmtdp:    return "finished";
  default:	    return "UNKNOWN STATE";
  }
}



/* ---------------------------- ydmtdProcList ---------------------------- */
/*
  NAME
    ydmtdProcList
  DESCRIPTION
    handle work of getting the next yort in a poll.

    Start polls of anything in the list.  When none left, go into
    "iterating" to get the next list, or go into "sleeping".

    Called from the ydmtdPoll state machine.

    Leaves the machine in: sleeping, iterating, or iolimit state,
	with an operation pending

  PARAMETERS
    cx	    -- the global context.
    RETURNS
    none
*/

STATICF void ydmtdProcList( ydmtdcx *cx )
{
  ydmtdp    *p = &cx->pcx_ydmtdcx;
  ydmtdy    *yh;	
  ysspNode  *n;
  yort_proc y;

  if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 4 )
    yslError("ydmtdProcList: cursor %d of %d\n",
	     p->cursor_ydmtdp, p->ylist_ydmtdp._length );

  /* process yorts in the list, as long as possible */
  while( !cx->stop_ydmtdcx &&
	p->cursor_ydmtdp < p->ylist_ydmtdp._length &&
	p->npending_ydmtdp < cx->maxPoll_ydmtdcx )
  {
    y = p->ylist_ydmtdp._buffer[ p->cursor_ydmtdp++ ];
    if( (n = ysspLookup( (dvoid*)y, &cx->ytree_ydmtdcx ) ) )
    {
      /* ALIGNOK */
      yh = (ydmtdy*)n;
      /* if this is known to be dead or in-progress, skip to next */
      if( !yh->lives_ydmtdy || yh->ioactive_ydmtdy )
	continue;
    }
    else
    {
      /* new yort.  create.  */
      yh = (ydmtdy*) ysmGlbAlloc(sizeof(*yh), ydmtdy_tag );
      CLRSTRUCT(*yh);
      yoEnvInit( &yh->ev_ydmtdy );
      sysb8ext( &yh->exptime_ydmtdy, 0 );
      yh->node_ydmtdy.key_ysspNode = yoDuplicate((dvoid*)y);
      yh->ourUptime_ydmtdy = 0;
      yh->lives_ydmtdy = cx->lives_ydmtdcx;
      ysClock(&yh->expire_ydmtdy);
      sysb8add( &yh->expire_ydmtdy, &yh->expire_ydmtdy, &cx->reap_ydmtdcx );
      yh->cx_ydmtdy = cx;
      DISCARD ysspEnq( &yh->node_ydmtdy, &cx->ytree_ydmtdcx );
      cx->nytree_ydmtdcx++;
    }

    /* start the poll to this server. */

    ydmtdPFree( yh );
    ydmtdIFree( yh );
    ydmtdDFree( yh );
    yh->ioactive_ydmtdy = TRUE;
    p->npolls_ydmtdp++;
    p->npending_ydmtdp++;

    /* FIXME -- these were queue 0; why? */

    yh->sem_ydmtdy = ysEvtCreate( ydmtdPollComp, (dvoid*)yh,
				 cx->q_ydmtdcx, TRUE );
    yh->tsem_ydmtdy = ysEvtCreate( ydmtdPollTimeout, (dvoid*)yh,
				 cx->q_ydmtdcx, TRUE );

    if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 4 )
      yslError("ydmtdProcList: polling y:%x, lives %d, pending %d\n",
	       y, yh->lives_ydmtdy, p->npending_ydmtdp );

    ysTimer( &cx->timeout_ydmtdcx, yh->tsem_ydmtdy );
    yort_proc_getImplAll_nw( (yort_proc)yh->node_ydmtdy.key_ysspNode,
			    &p->ev_ydmtdp,
			    (yort_implFlags)0,
			    &yh->iopinfo_ydmtdy,
			    &yh->iodlist_ydmtdy,
			    &yh->iolist_ydmtdy,
			    yh->sem_ydmtdy );
  }

  if( cx->stop_ydmtdcx )
  {
    ydmtdPollStop( cx );
  }
  else if( p->cursor_ydmtdp < p->ylist_ydmtdp._length )
  {
    /* Too many outstanding getImplAlls.  Completion will re-awaken us */
    p->state_ydmtdp = iolimit_ydmtdp;
    if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 4 )
      yslError("ydmtdProcList: hit poll limit %d\n", cx->maxPoll_ydmtdcx );
  }
  else				/* nothing left in ylist to poll. */
  {
    if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 4 )
      yslError("ydmtdProcList: empty list\n");
    
    if( p->ylist_ydmtdp._buffer ) /* release old list */
    {
      ydim_yortList__free( &p->ylist_ydmtdp, yoFree );
      p->ylist_ydmtdp._buffer = (yort_proc*)0;
      p->ylist_ydmtdp._length = p->ylist_ydmtdp._maximum = 0;
    }
    if( p->yi_ydmtdp )		/* get more, if possible */
    {
      if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 1 )
	yslError("ydmtdPoll: iterating with yi %x for ylist %x\n",
		 p->yi_ydmtdp, &p->ylist_ydmtdp );

      p->state_ydmtdp = iterating_ydmtdp;
      p->cursor_ydmtdp = 0;
      ydim_yortIterator_next_n_nw( p->yi_ydmtdp, &p->ev_ydmtdp,
				 cx->chunk_ydmtdcx,
				 &p->ylist_ydmtdp, p->sem_ydmtdp );
    }
    else			/* end of scan.  do end-of-scan delay */
    {
      if( p->trace_ydmtdp && cx->trace_ydmtdcx >= 5 )
	yslError("ydmtdProcList: starting sleeping delay\n");
      p->state_ydmtdp = sleeping_ydmtdp;
      ysTimer( &p->pollIdle_ydmtdp, p->sem_ydmtdp );
    }
  }
}



/* ---------------------------- ydmtdPollStop ---------------------------- */
/*
  NAME
    ydmtdPollStop
  DESCRIPTION
    Function called to shutdown the ydmtdPoll state machine.  Doesn't
    start any new operations, cleans up the iterator (if one is active),
    and signals that the machine is 'down'.

  PARAMETERS
    cx	    -- the ydmtdcx.
  RETURNS
    none
*/

STATICF void ydmtdPollStop( ydmtdcx *cx )
{
  ydmtdp    *p = &cx->pcx_ydmtdcx;
  ydmtddx   *d = &cx->dcx_ydmtdcx;

  if( cx->trace_ydmtdcx >= 1 )
    yslError("ydmtdPollStop: pending %d state %s sem %x \n",
	     p->npending_ydmtdp, ydmtdPState(p),
	     p->sem_ydmtdp );

  /* whatever, we're not interested anymore. */
  if( p->sem_ydmtdp )
  {
    if( cx->trace_ydmtdcx >= 3 )
      yslError("ydmtdPollStop: cancelling evt %x\n", p->sem_ydmtdp );
    ysEvtDestroy( p->sem_ydmtdp );
    p->sem_ydmtdp = (ysevt*)0;
  }
  p->state_ydmtdp = stopping_ydmtdp;

  /* wait for poll events to complete */
  if( !p->npending_ydmtdp && p->state_ydmtdp != finished_ydmtdp )
  {
    p->state_ydmtdp = finished_ydmtdp;
    if( !d->npending_ydmtddx && d->state_ydmtddx == finished_ydmtddx &&
       cx->dsem_ydmtdcx )
      ysTrigger( cx->dsem_ydmtdcx, (ysid*)0, (dvoid*)0, (size_t)0 );
  }
}


/* --------------------------- ydmtdConsiderInfo --------------------------- */
/*
  NAME
    ydmtdConsiderInfo
  DESCRIPTION
    Given new info about a yort, in pinfo, dlist and ilist,
    send it wherever appropriate.
  PARAMETERS
    cx	    - the ydmtd context
    yh	    - the yort info to consider.
  RETURNS
    none
*/

STATICF void ydmtdConsiderInfo( ydmtdcx *cx, ydmtdy *yh )
{
  ysspNode  *n;
  boolean   sendit = FALSE;
  ub4	    i;
  sysb8	    now;
  yort_implAllList   *il, *lil;
  boolean isnew, changed, expired; 

  /* if invalid, ignore; simplest to consolidate this test here. */
  if( !yh->ourUptime_ydmtdy )
    return;

  isnew = changed = expired = FALSE;
  
  il = &yh->ilist_ydmtdy;
  lil = &yh->lilist_ydmtdy;
  ysClock(&now);

  /* simple cases -- new info is very different from old, or expired */
  if( !yh->lihave_ydmtdy )
    isnew = TRUE;
  else if( il->_length != lil->_length )
    changed = TRUE;
  else if( sysb8cmp( &yh->exptime_ydmtdy, <= , &now ) )
    expired = TRUE;

  if( isnew || changed || expired )  
  {
    sendit = TRUE;
    if( cx->trace_ydmtdcx >= 4 )
      yslError("ydmtdConsiderInfo: isnew %d, changed %d, expired %d\n",
	       isnew, changed, expired );

    /* if no dist, just switch now */
    if( !cx->dist_ydmtdcx )
    {
      /* release last data in lil, and move current in il there */
      ydmtdLIFree( yh );
      
      /* copy the data -- orig will be freed on return from the
	 completion handler */
      DISCARD memcpy( lil, il, sizeof(*lil) );
      yh->lihave_ydmtdy = yh->ihave_ydmtdy;
      yh->ihave_ydmtdy = FALSE;
    }
  }
  else for( i = 0 ; !sendit && i < il->_length ; i++ )
    sendit = ydmtdShouldSend( cx, &lil->_buffer[i], &il->_buffer[i] );

  if( cx->dist_ydmtdcx && sendit ) /* mark switch and enqueue */
  {
    if( cx->trace_ydmtdcx >= 4 )
      yslError("ydmtdConsiderInfo: switching/sending lihave %d ihave %d\n",
	       yh->lihave_ydmtdy, yh->ihave_ydmtdy );

    sysb8add( &yh->exptime_ydmtdy, &now, &cx->ttl_ydmtdcx );

    /* release last data in lil, and move current in il there */
    ydmtdLIFree( yh );

    /* copy the data -- orig will be freed on return from the
       completion handler */
    DISCARD memcpy( lil, il, sizeof(*lil) );
    yh->lihave_ydmtdy = yh->ihave_ydmtdy;
    yh->ihave_ydmtdy = FALSE;
    for( n = ysspFHead( &cx->dtree_ydmtdcx ); n ; n = ysspFNext( n ) )
      /* ALIGNOK */
      ydmtdSendMetrics( cx, yh, (ydmtdd*)n );
  }
}

/* ---------------------------- ydmtdShouldSend ---------------------------- */
/*
  NAME
    ydmtdShouldSend
  DESCRIPTION
    given thresholds in the cx, and an old and new info block, should
    we sent the new info?

    In the future this might evaluate more criteria.

  PARAMETERS
    cx	    -- the context.
    o	    -- the old data to consider.
    n	    -- the new data to consider.
  RETURNS
    TRUE if it's different enough to warrant sending.
*/

STATICF boolean ydmtdShouldSend(ydmtdcx *cx, yort_implAll *o, yort_implAll *n)
{
  sb4	olen = o->queue_yort_implAll.curLen_yort_queueInfo; 
  sb4	nlen = n->queue_yort_implAll.curLen_yort_queueInfo; 
  boolean rv = nlen != olen;
  
  return( cx->dist_ydmtdcx && rv );
}


/* ---------------- */
/* DIST RELATED */
/* ---------------- */


/* ---------------------------- ydmtdDist ---------------------------- */
/*
  NAME
    ydmtdDist
  DESCRIPTION

    Handles all dest checks and sends, as a state machine
    running asyncronously.

    The machine is left put in sleep when there is nothing to do.  It
    gets to sleep by initialization, and when all the send queues have
    been drained.  It is woken from sleep vis ysTrigger when (a) the
    machine is first started, and (b) when a timer decides it is time
    to check for new destinations.
    
  PARAMETERS
    usrp	-- the ydmtdcx
    exid	-- operation completion exception
    arg		-- op return value, if any.
    argsz	-- return size.
  RETURNS
    none
*/

STATICF void ydmtdDist(dvoid *usrp, CONST ysid *exid,
		       dvoid *arg, size_t argsz)
{
  ydmtdcx   *cx = (ydmtdcx*)usrp;
  ydmtddx   *d;
  ysspNode  *n;
  ydmtdd    *dn;
  
  d = &cx->dcx_ydmtdcx;
  ysEvtDestroy( d->sem_ydmtddx );
  d->sem_ydmtddx = (ysevt*)0;

  if( exid && (ysidEq(exid,YS_EX_SHUTDOWN) || ysidEq(exid,YS_EX_CANCELLED)))
  {
    yslError("ydmtdDist: exid %s, returning\n", yduIdStr(exid) );
    return;
  }

  if( d->trace_ydmtddx && cx->trace_ydmtdcx >= 4 )
    yslError("ydmtdDist: entry state %s, ex '%s' arg %x argsz %d\n",
	     ydmtdDState(d), yduIdStr(exid), arg, argsz );

  if( cx->stop_ydmtdcx )
    d->state_ydmtddx = stopping_ydmtddx; 
  else
    d->sem_ydmtddx = ysEvtCreate( ydmtdDist, (dvoid*)cx,
				 cx->q_ydmtdcx, TRUE );

  switch( d->state_ydmtddx )
  {
  case stopping_ydmtddx:

    ydmtdDistStop( cx );
    break;
    
  case sleeping_ydmtddx:
    
    /* start to update the dest list.  listORBDs is possibly slow */
    
    ydmtdReaper( cx );
    d->olist_ydmtddx = yoListORBDs();
    if( !ysLstCount( d->olist_ydmtddx ) )
    {
      yslError("ydmdtDist: no orbds.  Exiting\n");
      ydmtd_shutdown_i( cx->self_ydmtdcx, (yoenv*)0 );
    }
    else
    {
      d->state_ydmtddx = getmt_ydmtddx; 
      if( !ydmtdDeqDest( cx ) )
	d->state_ydmtddx = sleeping_ydmtddx;
    }
    break;

  case getmt_ydmtddx:

    /* often get timeout here; just skip to next. */
    if( exid && !ysidEq(exid,YS_EX_TIMEOUT) && !ysidEq(exid,YT_EX_BROKEN) )
    {
      /* often get timeout here... */
      yslError("ydmtdDist: getmt received unexpected exception %s\n",
	       yduIdStr(exid) );
    }
    else if( !exid )
    {
      /* creation step 3: insert node, queue known info  */
      dn = (ydmtdd*)ysmGlbAlloc(sizeof(*dn), ydmtdd_tag );
      dn->node_ydmtdd.key_ysspNode = yoDuplicate((dvoid*)d->imr_ydmtddx);
      dn->lives_ydmtdd = cx->lives_ydmtdcx;
      dn->ydmt_ydmtdd = *(ydmt_imtr*)arg;
      ysGetUpTime(&dn->expire_ydmtdd);
      sysb8add( &dn->expire_ydmtdd, &dn->expire_ydmtdd, &cx->reap_ydmtdcx );
      dn->nioactive_ydmtdd = 0;

      cx->ndtree_ydmtdcx++;
      DISCARD ysspEnq( &dn->node_ydmtdd, &cx->dtree_ydmtdcx );

      /* queue new orbd all we now know. */
      for( n = ysspFHead( &cx->ytree_ydmtdcx ); n ; n = ysspFNext( n ) )
	/* ALIGNOK */
    	ydmtdSendMetrics( cx, (ydmtdy*)n, dn );
    }
    
    /* check the next imr on the orbd list, or go to sleep */
    if( !ydmtdDeqDest( cx ) )
      d->state_ydmtddx = sleeping_ydmtddx; 

    break;

  default:

    yslError("ydmtdDist: unknown state %d, exid %s\n",
	     d->state_ydmtddx, yduIdStr(exid));
    ysePanic(exid ? exid : YDMTD_EX_INTERNAL);
  }

  if( d->state_ydmtddx == sleeping_ydmtddx )
    ysTimer( &d->destInterval_ydmtddx, d->sem_ydmtddx );

  if( d->trace_ydmtddx && cx->trace_ydmtdcx >= 4 )
    yslError("ydmtdDist: exit state %s, sem %x\n",
	     ydmtdDState(d), d->sem_ydmtddx );

}

    

/* ---------------------------- ydmtdDistComp ---------------------------- */
/*
  NAME
    ydmtdDistComp
  DESCRIPTION
    Completion handler for addYortAll_nw calls.  Keeps track of number
    in flight, and shutdown when i/o is active.  May be cancelled by
    a timeout.
  PARAMETERS
    usrp	-- the ydmdte for the i/o.
    exid	-- completion error code, 0 on success.
  RETURNS
    none
*/

STATICF void ydmtdDistComp(dvoid *usrp, CONST ysid *exid,
			   dvoid *arg, size_t argsz)
{
  ydmtde    *e = (ydmtde*)usrp;
  ydmtdcx   *cx = e->cx_ydmtde;
  ydmtddx   *d = &cx->dcx_ydmtdcx;
  ydmtdd    *dd = e->dest_ydmtde;

  ysEvtDestroy( e->sem_ydmtde );
  ysEvtDestroy( e->tsem_ydmtde );
  d->npending_ydmtddx--;

  if( d->trace_ydmtddx && cx->trace_ydmtdcx >= 4 )
    yslError("ydmtdDistComp: e %x ex '%s' arg %x argsz %d\n",
	     e, yduIdStr(exid), arg, argsz );

  dd->nioactive_ydmtdd--;

  if( exid && (ysidEq(exid,YT_EX_BADADDR) || ysidEq(exid,YT_EX_BROKEN)) )
				dd->lives_ydmtdd = 0;
  else if( exid )		dd->lives_ydmtdd--;
  else				dd->lives_ydmtdd = cx->lives_ydmtdcx;

  if( dd->lives_ydmtdd < 0 )
    dd->lives_ydmtdd = 0;
  else if( dd->lives_ydmtdd )
  {
    ysGetUpTime(&dd->expire_ydmtdd);
    sysb8add( &dd->expire_ydmtdd, &dd->expire_ydmtdd, &cx->reap_ydmtdcx );
  }

  yoEnvFree( &e->ev_ydmtde );
  ysmGlbFree( usrp );

  if( d->trace_ydmtddx && cx->trace_ydmtdcx >= 4 )
    yslError("ydmtdDistComp: npending %d, state %s stop %d\n",
	     d->npending_ydmtddx, ydmtdDState(d), cx->stop_ydmtdcx);

  if( cx->stop_ydmtdcx )
    ydmtdDistStop( cx );
  else
    ysSvcAll( cx->q_ydmtdcx );
}


/* --------------------------- ydmtdDistTimeout --------------------------- */
/*
  NAME
    ydmtdDistTimeout
  DESCRIPTION
    timeout handler, used around i/o calls to put metric data.  If/when
    this completes with something other than YS_EX_CANCELLED, it needs
    to cancell the i/o and decrement the lives counter.  Since there
    can be more than one i/o to a yort at one time, be prepared for lives
    to go < 0.
  PARAMETERS
    usrp    -- the ydmtde.
    exid    -- should be either YS_EX_CANCELLED (i/o OK) or YS_EX_TIMEOUT.
  RETURNS
    none
*/

STATICF void ydmtdDistTimeout(dvoid *usrp, CONST ysid *exid,
			      dvoid *arg, size_t argsz)
{
  ydmtde    *e = (ydmtde*)usrp;
  ydmtdcx   *cx = e->cx_ydmtde;
  ydmtddx   *d = &cx->dcx_ydmtdcx;

  ysEvtDestroy( e->sem_ydmtde );
  d->npending_ydmtddx--;

  if( d->trace_ydmtddx && cx->trace_ydmtdcx >= 4 )
    yslError("ydmtdDistTimeout: e %x ex '%s' arg %x argsz %d\n",
	     e, yduIdStr(exid), arg, argsz );

  e->dest_ydmtde->nioactive_ydmtdd--;

  if( !--(e->dest_ydmtde->lives_ydmtdd) )
    e->dest_ydmtde->lives_ydmtdd = 0;

  yoEnvFree( &e->ev_ydmtde );
  ysmGlbFree( usrp );

  if( cx->stop_ydmtdcx )
    ydmtdDistStop( cx );
  else
    ysSvcAll( cx->q_ydmtdcx );
}

/* ---------------------------- ydmtdDState ---------------------------- */
/*
  NAME
    ydmtdDState
  DESCRIPTION
    decode state of Dist machine for nice debug info.
  PARAMETERS
    d	    -- the dist machine state.
  RETURNS
    char string of the state name.
*/
STATICF CONST char *ydmtdDState( ydmtddx *d )
{
  switch( d->state_ydmtddx )
  {
  case sleeping_ydmtddx:    return "sleeping";   
  case getmt_ydmtddx:	    return "getmt";
  case stopping_ydmtddx:    return "stopping";
  case finished_ydmtddx:    return "finished";
  default:	    return "UNKNOWN STATE";
  }
}


/* ---------------------------- ydmtdDeqDest ---------------------------- */
/*
  NAME
    ydmtdDeqDest
  DESCRIPTION
    Deq an imr the list and start to get the ydad_orbd of an entry.
    
  PARAMETERS
    cx	    -- ydmtdcx.
  RETURNS
    TRUE if started a getmt, FALSE if list is now empty.
*/

STATICF boolean ydmtdDeqDest( ydmtdcx *cx )    
{
  ydmtddx *d = &cx->dcx_ydmtdcx;

  /* consume the orbd list */
  while( (d->imr_ydmtddx = (ydim_imr)ysLstDeq( d->olist_ydmtddx)) )
  {
    if( d->trace_ydmtddx && cx->trace_ydmtdcx >= 5 )
      yslError("ydmtdDeqDest: checking imr %x\n", d->imr_ydmtddx );

    if( !ysspLookup( (dvoid*)d->imr_ydmtddx, &cx->dtree_ydmtdcx ) )
    {
      if( d->trace_ydmtddx && cx->trace_ydmtdcx >= 5 )
	yslError("ydmtdDeqDest: is new imr, getting ydad_orbd and ydmt\n");

      /* no; need to create it.  first get ydad_orbd for it... */
      ydim_imr__get_mt_nw( d->imr_ydmtddx, &d->ev_ydmtddx, d->sem_ydmtddx );
      return TRUE;
    }
  }

  if( d->trace_ydmtddx && cx->trace_ydmtdcx >= 5 )
    yslError("ydmtdDeqDest: list consumed\n");

  /* orbd list is empty; proceed */
  ysLstDestroy( d->olist_ydmtddx, (ysmff)0 );
  d->olist_ydmtddx = (yslst*)0;
  return( FALSE );
}


/* -------------------------- ydmtdSendMetrics -------------------------- */
/*
  NAME
    ydmtdSendMetrics
  DESCRIPTION
    Send info from a yort for a ydmt_metrics destination.  Called from two
    paths:

    1.  ydmtdConsider, which is when new data is received in polling
	or forced.

    2.  ydmtdDist, when a new destination has been detected; it needs
	to be sent all the information we now have.

    In some cases, ydmtdDist will call after poll detected the yort
    and started an i/o, but before we've gotten valid data back.  In
    this case, we toss the queue request.  When the data does come in,
    we'll get queued from ydmtdConsider.

  PARAMETERS
    cx	    -- context
    yh	    -- yort handle, info to send within.
    dest    -- destination description.
  RETURNS
    none
*/    

STATICF void ydmtdSendMetrics( ydmtdcx *cx, ydmtdy *yh, ydmtdd *dest )
{
  ydmtde    *e;
  ydmtddx   *d = &cx->dcx_ydmtdcx;

  if( !cx->dist_ydmtdcx )
    ysePanic( YDMTD_EX_INTERNAL );

  /* ignore request with incomplete yh or to dead dest. */
  if( yh->ourUptime_ydmtdy && dest->lives_ydmtdd )
  {
    if( !cx->stop_ydmtdcx )
    {
      e = (ydmtde*)ysmGlbAlloc( sizeof(*e), ydmtde_tag );
      yoEnvInit( &e->ev_ydmtde );
      e->cx_ydmtde = cx;
      e->yh_ydmtde = yh;
      e->dest_ydmtde = dest;
      e->sem_ydmtde = ysEvtCreate( ydmtdDistComp, (dvoid*)e,
				  cx->q_ydmtdcx, TRUE );
      e->tsem_ydmtde = ysEvtCreate( ydmtdDistTimeout, (dvoid*)e,
				   cx->q_ydmtdcx, TRUE );
      d->npending_ydmtddx++;
      d->nsends_ydmtddx++;
      if( cx->trace_ydmtdcx >= 5 )
      {
	yslError("ydmtdSendMetrics: e %x y:%x ydim:%x s:%x ts:%x pending %d\n",
		 e, yh->node_ydmtdy.key_ysspNode,
		 dest->node_ydmtdd.key_ysspNode,
		 e->sem_ydmtde,
		 e->tsem_ydmtde,
		 d->npending_ydmtddx );
      }
      dest->nioactive_ydmtdd++;
      ysTimer( &cx->timeout_ydmtdcx, e->tsem_ydmtde );
      ydmt_imtr_addYortAll_nw( dest->ydmt_ydmtdd,
			      &e->ev_ydmtde,
			      (yort_proc)yh->node_ydmtdy.key_ysspNode,
			      &yh->lilist_ydmtdy, e->sem_ydmtde );
    }
  }
}


/* ---------------------------- ydmtdDistStop ---------------------------- */
/*
  NAME
    ydmtdDistStop
  DESCRIPTION
    Put dist/dest checker in stopped mode; raise event if possible and
    needed.
  PARAMETERS
    cx	    -- the ydmtd context.
  RETURNS
    none
*/

STATICF void ydmtdDistStop( ydmtdcx *cx )
{
  ydmtddx *d = &cx->dcx_ydmtdcx;
  ydmtdp *p = &cx->pcx_ydmtdcx;

  if( cx->trace_ydmtdcx >= 1 )
    yslError("ydmtdDistStop: %d npending, state %s, sem %x\n",
	     d->npending_ydmtddx, ydmtdDState(d),
	     d->sem_ydmtddx );

  /* whatever it is, we don't care */
  if( d->sem_ydmtddx )
  {
    if( cx->trace_ydmtdcx >= 5 )
      yslError("ydmtdDistStop: cancelling evt %x\n", d->sem_ydmtddx );
    ysEvtDestroy( d->sem_ydmtddx );
    d->sem_ydmtddx = (ysevt*)0;
  }
  
  if( !d->npending_ydmtddx && d->state_ydmtddx != finished_ydmtddx )
  {
    d->state_ydmtddx = finished_ydmtddx;
    if( !p->npending_ydmtdp && p->state_ydmtdp == finished_ydmtdp )
      ysTrigger( cx->dsem_ydmtdcx, (ysid*)0, (dvoid*)0, (size_t)0 );
  }
}


/* ---------------------------- ydmtdPFree ---------------------------- */
/*
  NAME
    ydmtdPFree
  DESCRIPTION
    Free and clear yh->pinfo_ydmtdy for reuse, using the saved pfree function
  PARAMETERS
    yh	    -- the container to clear.
  RETURNS
    none
*/

STATICF void ydmtdPFree( ydmtdy *yh )
{
  if( yh->phave_ydmtdy )
  {
    yort_procInfo__free( &yh->pinfo_ydmtdy, yotkFreeStr );
    CLRSTRUCT( yh->pinfo_ydmtdy );
    yh->phave_ydmtdy = FALSE;
  }
}



/* ---------------------------- ydmtdIFree ---------------------------- */
/*
  NAME
    ydmtdIFree
  DESCRIPTION
    free and clear yh->ilist_ydmtdy using the saved ifree function.
  PARAMETERS
    yh	    --- the container to clear.
  RETURNS
    none
*/

STATICF void ydmtdIFree( ydmtdy *yh )
{
  if( yh->ihave_ydmtdy )
  {
    yort_implAllList__free( &yh->ilist_ydmtdy, yotkFreeStr );
    CLRSTRUCT( yh->ilist_ydmtdy );
    yh->ihave_ydmtdy = FALSE;
  }
}


STATICF void ydmtdDFree( ydmtdy *yh )
{
  if( yh->dhave_ydmtdy )
  {
    yort_dispInfoList__free( &yh->dlist_ydmtdy, yotkFreeStr );
    CLRSTRUCT( yh->dlist_ydmtdy );
    yh->dhave_ydmtdy = FALSE;
  }
}




/* ---------------------------- ydmtdLIFree ---------------------------- */
/*
  NAME
    ydmtdLIFree
  DESCRIPTION
    Free and clear yh->lilist_ydmtdy using the saved lifree function.
  PARAMETERS
    yh		-- the container to clear.
  RETURNS
    none
*/

STATICF void ydmtdLIFree( ydmtdy *yh )
{
  if( yh->lihave_ydmtdy )
  {
    yort_implAllList__free( &yh->lilist_ydmtdy, yotkFreeStr );
    CLRSTRUCT( yh->lilist_ydmtdy );
    yh->lihave_ydmtdy = FALSE;
  }
}


/* ---------------------------- ydmtdYHDestroy ---------------------------- */
/*
  NAME
    ydmtdYHDestroy
  DESCRIPTION
    destroy a yort handle completely.
  PARAMETERS
    yh	    -- the handle to destroy.
  RETURNS
    none
*/

STATICF void ydmtdYHDestroy( ydmtdy *yh )
{
  yoRelease( yh->node_ydmtdy.key_ysspNode );
  ydmtdPFree( yh );
  ydmtdIFree( yh );
  ydmtdLIFree( yh );
  yoEnvFree( &yh->ev_ydmtdy );
  ysmGlbFree( (dvoid*)yh );
}

/* ---------------------------- ydmtdDDDestroy ---------------------------- */
/*
  NAME
    ydmtdDDDestroy
  DESCRIPTION
    Destroy a dest entry completely.
  PARAMETERS
    dd	    -- the dest entry to clobber.
  RETURNS
    none
*/

STATICF void ydmtdDDDestroy( ydmtdd *dd )
{
  yoRelease( dd->node_ydmtdd.key_ysspNode );
  yoRelease( (dvoid*)dd->ydmt_ydmtdd );
  ysmGlbFree( (dvoid*)dd );
}

/* ---------------------------- ydmtdReaper ---------------------------- */
/*
  NAME
    ydmtdReaper
  DESCRIPTION
    Remove expired dests and yorts, presumably because they are dead.
  PARAMETERS
    cx	    -- the ydmtd context
  RETURNS
    none
*/

STATICF void ydmtdReaper( ydmtdcx *cx )
{
  ydmtdy *yh = (ydmtdy*)0;
  ydmtdd *dd = (ydmtdd*)0;
  ysspNode  *n, *next;
  sysb8	now;

  ysClock(&now);

  for( n = ysspFHead( &cx->ytree_ydmtdcx ); n ; n = next )
  {
    next = ysspFNext( n );
    /* ALIGNOK */
    yh = (ydmtdy*)n;
    if( !yh->lives_ydmtdy && sysb8cmp( &now, >= , &yh->expire_ydmtdy) )
    {
      if( yh->ioactive_ydmtdy )
      {
	yslError("***ydmtdReaper: dead yh %x has i/o active\n", yh );
      }
      else
      {
	if( cx->trace_ydmtdcx >= 2 )
	  yslError("ydmtdReaper: releasing dead yh %x\n", yh );
	ysspRemove( n, &cx->ytree_ydmtdcx );
	cx->nytree_ydmtdcx--;
	ydmtdYHDestroy( yh );
      }
    }
  }

  for( n = ysspFHead( &cx->dtree_ydmtdcx ); n ; n = next )
  {
    next = ysspFNext( n );
    /* ALIGNOK */
    dd = (ydmtdd*)n;
    if( !dd->lives_ydmtdd && sysb8cmp( &now, >= , &dd->expire_ydmtdd) )
    {
      if( dd->nioactive_ydmtdd )
      {
	yslError("***ydmtdReaper: dest dest %x (imr %x) has %d io's active.\n",
		 dd, dd->node_ydmtdd.key_ysspNode, dd->nioactive_ydmtdd );
      }
      else
      {
	if( cx->trace_ydmtdcx >= 2 )
	  yslError("ydmtdReaper: releasing dead dest %x, imr %x, mt %x\n",
		   dd, dd->node_ydmtdd.key_ysspNode, dd->ydmt_ydmtdd );
	ysspRemove( n, &cx->dtree_ydmtdcx );
	cx->ndtree_ydmtdcx--;
	ydmtdDDDestroy( dd );
      }
    }
  }
}


