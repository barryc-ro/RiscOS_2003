/* Copyright (c) 1995 by Oracle Corporation.  All Rights Reserved.
 *
 * NAME
 *   yrmgr.c - Implementation of interface yr::mgr, the runtime IFR
 *             manager.
 *
 * NOTES
 * The IFR manager exists merely to load data into the runtime repository
 * and to shutdown the runtime repository. As it grows, it will export
 * more query operations; at the moment, all you can find out is what
 * IFR data files have been loaded.
 *
 * For information on the operations supported, see yrmgidl.idl.
 *
 * HISTORY
 * 04/19/96 kcoleman	Switch over to ysRecord for error reporting.
 * 01/30/96 kcoleman	Add some ysYield calls during loading
 * 11/09/95 kcoleman	Creation
 */

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif

#ifndef YO_ORACLE
#include <yo.h>
#endif

#ifndef YOCOA_ORACLE
#include <yocoa.h>
#endif

#ifndef YRMGIDLI_H
#include <yrmgidlI.h>
#endif

#ifndef YR_ORACLE
#include <yr.h>
#endif

#ifndef YR0_ORACLE
#include <yr0.h>
#endif

#ifndef YR0UTIL_ORACLE
#include <yr0util.h>
#endif

#ifndef YRTYPIDL_IDL
#include <yrtypidl.h>
#endif

/* --------------------------------------------------------------------- */
/*
 * yr::mgr::load - Load data into the repository
 *
 * This is where all the work gets done. <fn> should be the name of
 * an IFR data file or a directory of such files. We attempt to 
 * load them into the repository. All the work is done by yrmgrLoad
 * (because all loads are triggered by an object request).
 */
void yr_mgr_load_i( yr_mgr or, yoenv* ev, yr_path fn)
{
  yrmgrctx* ctx = yoGetImplState((dvoid*) or);
  yslst* newldlst;

  newldlst = yrmgrLoad( ctx->repository, fn);
  if ( ctx->loadlst )
  {
    dvoid* f;
    while ( (f = ysLstDeq( newldlst)) )
      ysLstEnq( ctx->loadlst, f);
    ysLstDestroy( newldlst, (ysmff)0);
  } 
  else
    ctx->loadlst = newldlst;
}

/* --------------------------------------------------------------------- */
/*
 * yr::mgr::shutdown
 */
void yr_mgr_shutdown_i( yr_mgr or, yoenv* ev)
{
  yoShutdown( (ysque*)0);
}

/* --------------------------------------------------------------------- */
/*
 * yr::mgr::loadlist - regurgitates a list of files loaded into the IFR.
 */

yr_pathSeq yr_mgr__get_loadlist_i( yr_mgr or, yoenv* ev)
{
  yrmgrctx* ctx = yoGetImplState((dvoid*) or);
  ysle* le;
  sword i;
  volatile yr_pathSeq seq = {0,0,0};
  sword nelems = ysLstCount( ctx->loadlst);

  if ( nelems > 0 )
    seq._buffer = (yr_path*) yoAlloc( sizeof(yr_path) * nelems);
  yseTry
  {
    for ( i = 0, le = ysLstHead(ctx->loadlst); le; i++, le = ysLstNext(le))
    {
      seq._buffer[i] = ysStrDupWaf( (char*) ysLstVal(le), yoAlloc);
      seq._length++;
    } 
  }
  yseCatchAll
  {
    yr_pathSeq__free( (yr_pathSeq*) &seq, yoFree);
    yseRethrow;
  }
  yseEnd
  return seq;
}


/* --------------------------------------------------------------------- */
/*
 * yr::mgr::repository - The only way to get a tightly bound IFR object.
 */

CORBA_Repository yr_mgr__get_repository_i( yr_mgr or, yoenv* ev)
{
  yrmgrctx* ctx = (yrmgrctx*) yoGetImplState( or);

  return yoDuplicate( (dvoid*) yrYRtoCORBA(ctx->repository));
}


/* --------------------------------------------------------------------- */
/*
 * yr_mgr__impl - Implementation map definition. Generated by ycidl -S.
 */

externdef struct yr_mgr__tyimpl yr_mgr__impl =
 {
  yr_mgr_load_i,
  yr_mgr_shutdown_i,
  yr_mgr__get_loadlist_i,
  yr_mgr__get_repository_i
 };

/* ------------------------------------------------------------------ */
/* 
 * The functions and objects defined above here have their declarations
 * generated by the IDL compiler from yrmgidl.idl.
 */
/* ------------------------------------------------------------------ */


/*
 * yrmgrLoad - Load one or more IFR data files into the repository
 *
 * <path> can be the name of either a single file or a directory. If it
 * is a directory, we attempt to load all files in that directory. 
 * Non-IFR files are skipped without reporting any errors, though if
 * tracing is turned on, it will report the skipped files. If only a
 * single file is specified, it must exist and be an IFR data file.
 *
 * Whether it is a single file or a directory, <path> must exist and
 * be readable by the IFR server.
 * 
 * The data read in from the file or directory is merged into <repository>.
 * A file is rejected if a read or merge error occurs, but we continue
 * processing additional files. The repository is not updated wrt a
 * particular file until the entire file has been read in and consistency
 * checking performed on it.
 *
 * If you throw any yr::mgr exceptions, be sure to use yoAlloc for all
 * your related allocations.
 *
 * This function needs to yield periodically so that other calls can 
 * be queued - loading is a greedy operation and potentially takes a long
 * time if there are lots of files.
 *
 * Exceptions:
 * YR_MGR_EX_FILENOTFOUND - Unable to access file or directory
 * YR_MGR_EX_LOADCONFLICT - Load rejected for redefined or undefined names
 * YR_MGR_EX_FILECORRUPTED - File couldn't be interpreted as IFR file
 */
yslst* yrmgrLoad( yrobj* repository, CONST char* path)
{
  CONST char* fn;
  noreg char fullfn[SYSFP_MAX_PATHLEN];
  noreg ub4 nobjs;
  yrldblk* noreg data;
  yslst* noreg files = (yslst*)0;
  noreg boolean isdir = FALSE;
  yslst* loadlst;
  boolean openErr = FALSE;

  NOREG(files);
  NOREG(fullfn);
  NOREG(isdir);
  NOREG(nobjs);
  NOREG(data);

  if ( sysfpIsDir( path) )                   /* load all files in a dir */
  {
    isdir = TRUE;
    files = sysfpGetDir( path);
    if ( !files )
      openErr = TRUE;
  }
  else                                       /* load one file */
  {
    openErr = !sysfpAccess( path, "r");
    if ( !openErr )
    {
      files = ysLstCreate();
      isdir = FALSE;
      ysLstEnq(files, (dvoid*)path);
    }
  }

  if ( openErr )                             /* unable to open <path> */
  {
    yr_mgr_fileNotFound ex;

    ysRecord( YR_MSG(401, YRSRV_FAC), YSLSEV_DEBUG(1), (char*)0, 
                YSLSTR(path), YSLEND);
    ex.path = ysStrDupWaf( path, yoAlloc);
    yseThrowObj( YR_MGR_EX_FILENOTFOUND, ex);
  }

  loadlst = ysLstCreate();
  while ( (fn = ysLstDeq( files)) )
  {
    if ( isdir )
      sysfpForm( (char*) fullfn, path, fn, SYSFPKIND_NONE);
    else
      strcpy( (char*)fullfn, fn);

    if ( !sysfpIsDir( (char*) fullfn) )
    {
      ysRecord( YR_MSG(300, YRSRV_FAC), YSLSEV_DEBUG(1), (char*)0, 
                YSLSTR((char*)fullfn), YSLEND);

      yseTry
      {
        yrRead( repository, (char*) fullfn, (ub4*)&nobjs, (yrldblk**)&data);
        ysYield();
        yrMergeFile( data, nobjs, FALSE);
        ysYield();
        yrFreeMergeData( data, nobjs);
        ysmGlbFree( (dvoid*) data);
        ysLstEnq( loadlst, (dvoid*) ysStrDup((char*)fullfn));
      }
      yseCatch( YR_EX_BADHDR )
      {
        ysRecord( YR_MSG(400, YRSRV_FAC), YSLSEV_DEBUG(1), (char*)0, 
                  YSLSTR(fullfn), YSLEND);
      }
      yseCatchObj( YR_MGR_EX_LOADCONFLICT, yr_mgr_LoadConflict, ex)
      {
        yr_mgr_LoadConflict newex;    /* so we can fill in fn */

        newex.filename = ysStrDupWaf( (char*) fullfn, yoAlloc);
        newex.undefined = ex.undefined;
        newex.redefined = ex.redefined;

        yrmgrReportLoadConflict( &newex, YSLSEV_DEBUG(1));
        if ( isdir )
          ysLstDestroy( files, ysmFGlbFree);
        else
          ysLstDestroy( files, (ysmff)0);
        yrFreeMergeData( data, nobjs);
        ysmGlbFree( (dvoid*) data);
        ysLstDestroy( loadlst, ysmFGlbFree);
        yseThrowObj( YR_MGR_EX_LOADCONFLICT, newex);
      }
      yseCatchObj( YR_EX_REDEFINED, char*, redef)
      {
        yr_mgr_LoadConflict ex;

        ysRecord( YR_MSG(402, YRSRV_FAC), YSLSEV_DEBUG(1), (char*)0, 
                  YSLSTR(redef), YSLSTR(fullfn), YSLEND);
        ex.filename = ysStrDupWaf( (char*) fullfn, yoAlloc);
        ex.undefined._length = 0;
        ex.redefined._length = 1;
        ex.redefined._buffer = yoAlloc( sizeof(yr_repid));
        ex.redefined._buffer[0] = ysStrDupWaf(redef, yoAlloc);
        if ( isdir )
          ysLstDestroy( files, ysmFGlbFree);
        else
          ysLstDestroy( files, (ysmff)0);
        yrFreeMergeData( data, nobjs);
        ysmGlbFree( (dvoid*) data);
        ysLstDestroy( loadlst, ysmFGlbFree);
        yseThrowObj( YR_MGR_EX_LOADCONFLICT, ex);
      }
      yseCatch ( YR_EX_BADTYPE)
      {
        yr_mgr_fileCorrupted ex;

        ex.path = ysStrDupWaf( (char*)fullfn, yoAlloc);
        if ( isdir )
          ysLstDestroy( files, ysmFGlbFree);
        else
          ysLstDestroy( files, (ysmff)0);
        ysLstDestroy( loadlst, ysmFGlbFree);
        yseThrowObj( YR_MGR_EX_FILECORRUPTED, ex);
      }
      yseCatch( YR_EX_READ_FAIL)
      {
        yr_mgr_fileCorrupted ex;
  
        ex.path = ysStrDupWaf( (char*)fullfn, yoAlloc);
        if ( isdir )
          ysLstDestroy( files, ysmFGlbFree);
        else
          ysLstDestroy( files, (ysmff)0);
        ysLstDestroy( loadlst, ysmFGlbFree);
        yseThrowObj( YR_MGR_EX_FILECORRUPTED, ex);
      }
      yseCatch( YR_EX_OPEN_FAIL)
      {    /* fold this into file-not-found */
        yr_mgr_fileNotFound ex;

        ysRecord( YR_MSG(401, YRSRV_FAC), YSLSEV_DEBUG(1), (char*)0, 
                  YSLSTR((char*)fullfn), YSLEND);
        ex.path = ysStrDupWaf( (char*)fullfn, yoAlloc);
        ysLstDestroy( loadlst, ysmFGlbFree);
        yseThrowObj( YR_MGR_EX_FILENOTFOUND, ex);
      }
      yseEnd
    }
    if ( isdir )
      ysmGlbFree( (dvoid*)fn);
  }

  if ( isdir )
    ysLstDestroy( files, ysmFGlbFree);
  else
  {
    ysLstDestroy( files, (ysmff)0);
    if ( ysLstCount( loadlst) == 0 )      /* one file specified, but no good */
    {
      yr_mgr_fileCorrupted ex;

      ysLstDestroy( loadlst, (ysmff)0);
      ex.path = ysStrDupWaf( (char*)path, yoAlloc);
      yseThrowObj( YR_MGR_EX_FILECORRUPTED, ex);
    }
  }

  return loadlst;
}


/*
 * This takes a dvoid* for the exception so that I don't have to have
 * knowledge of yr_mgr_LoadConflict in the header file which declares this.
 */
void yrmgrReportLoadConflict( dvoid* err, ub4 severity)
{
  yr_mgr_LoadConflict* ex = (yr_mgr_LoadConflict*) err;
  ub4 i;

  ysRecord( YR_MSG(8, YRSRV_FAC), severity, (char*)0, 
            YSLSTR(ex->filename), YSLEND);
  for ( i = 0; i < ex->undefined._length; i++)
    ysRecord( YR_MSG(9, YRSRV_FAC), severity, (char*)0, 
              YSLSTR(ex->undefined._buffer[i]), YSLEND);
  for ( i = 0; i < ex->redefined._length; i++)
    ysRecord( YR_MSG(10, YRSRV_FAC), severity, (char*)0, 
              YSLSTR(ex->redefined._buffer[i]), YSLEND);
}

/* ------------------------------------------------------------------------ */

void yrmgrInit( yrmgrctx* ctx)
{
  yoSetImpl( yr_mgr__id, ctx->tag,
             yr_mgr__stubs, &yr_mgr__impl,
             (yoload)0, TRUE, (dvoid*) ctx);
  yoImplReady( yr_mgr__id, ctx->tag, (ysque*)0);
}


/* ------------------------------------------------------------------------ */

void yrmgrTerm( yrmgrctx* ctx)
{
  yoImplDeactivate( yr_mgr__id, ctx->tag);
  ysLstDestroy( ctx->loadlst, ysmFGlbFree);
}

