
/* Copyright (c) Oracle Corporation 1995.  All Rights Reserved. */

/*
   NAME
   yeev.c
   DESCRIPTION

     YE event objects.  Can be linked into any process as the distributed
     event generation module.

     To have ysLog tracing raise yeev events, you need to call yeevSinkAttach

   PUBLIC FUNCTIONS

    yeevInit		-- init event system
    yeevTerm		-- shut down event system
    yeevHaveLogger	-- try to get a logger connection, return success.
    yeevReceiverSetHandler  -- where to send received events.
    yeevSinkAttach	-- send ysRecord events. 
    yeevBatchStart	-- start batching events.
    yeevBatchSend	-- send accumulated batch.
    yeevEvaluate	-- evaluate a record against filters.
   
   PRIVATE FUNCTIONS
    many -- FIXME
   
   MODIFIED   (MM/DD/YY)
   
    dbrower 10/16/95 - created.
    dbrower 01/19/96 - prepared for MX 3.1 check-in. 
    dbrower   02/28/96 -  convert to ysLog.
    dbrower   03/ 1/96 -  olint
    dbrower   03/28/96 -  add prog everywhere.
    dbrower   04/18/96 -  return proper value from yeevSend; avoid UMR
    dbrower   04/19/96 -  avoid making connections in async handler/idler
			  by making initial connection during the
			  sinkAttach.  We can still be in the bad state
			  if the logger dies and the next send happens
			  in an idler, but that's too complicated to solve
			  now.  Doing so will involve creating an async
			  state machine to make the logger connection,
			  and queueing 'to be sent' records while the
			  connection is pending.
    dbrower   04/22/96 -  behave better on log failure for Bug 360256.
			  Still not perfect -- should make async calls in
			  yeevGetLog, but that is too dangerous for 3.1
    dbrower   04/30/96 -  make connect async.
    dbrower   05/17/96 -  fix bug 366675 ("CONST type or" in _i funcs)
    dbrower   10/10/96 -  (1) If ye.log.tty.filter is set, then RemoteLog
			      will set up a new sink with that filter.
			      Bug 411337.
			  (2) Use the raiser's sequence instead of our
			      nevent count, and use the YS record seqid
			      as the value in the YsSink.  This way, the
			      display sequence id's match between the logs
			      and the ye tty sink.  Bug 411338.
			   This will make Dirke smirk.
    dbrower   07/11/96 -  remove bogus include of yeevchI.h
    dbrower   03/28/97 -  fix two pawson-found bugs -- check noi on
			  bad dest, and dup/release dn keys properly.
			  Caused panics/segvs when dest dies when there
			  is traffic outstanding.
    dbrower   05/29/97 -  fix 496588 -- time comparison wrong, missing
			  else in yeevFESb8Cmp.
*/
#ifndef SYSI_ORACLE
#include <sysi.h>
#endif

#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YSV_ORACLE
#include <ysv.h>
#endif
#ifndef YSSTR_ORACLE
#include <ysstr.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif
#ifndef YOCOA_ORACLE
#include <yocoa.h>
#endif
#ifndef YEEVENT_ORACLE
#include <yeevent.h>
#endif
#ifndef YEEV_ORACLE
#include <yeev.h>
#endif
#ifndef YEEVENTI_ORACLE
#include <yeeventI.h>
#endif
#ifndef YEU_ORACLE
#include <yeu.h>
#endif
#ifndef YSSP_ORACLE
#include <yssp.h>
#endif
#ifndef YEEVLOG_ORACLE
#include <yeevlog.h>
#endif
#ifndef YSMSC_ORACLE
#include <ysmsc.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif
#ifndef YSX_ORACLE
#include <ysx.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif
#ifndef YSLOG_ORACLE
#include <yslog.h>
#endif
#ifndef YSFE_ORACLE
#include <ysfe.h>
#endif
#ifndef CTYPE_ORACLE
#include <ctype.h>
#endif
#ifndef YSMSG_ORACLE
#include <ysmsg.h>
#endif

/* PRIVATE TYPES AND CONSTANTS */

typedef struct yeevcx yeevcx;	/* event context */
typedef struct yeevdx yeevdx;	/* discriminator */
typedef struct yeevdlx yeevdlx;	/* discriminator list */
typedef struct yeevrx yeevrx;	/* receiver */
typedef struct yeevdn yeevdn;	/* dest node, with it's filters */
typedef struct yeevoe yeevoe;	/* outstanding event push */
typedef struct yeevmd yeevmd;	/* many-dest */
typedef struct yeevpw yeevpw;	/* pointer wrapper */

static CONST_W_PTR struct yeevDiscList__tyimpl yeevDiscList__impl =
 {
  yeevDiscList_destroy_i,
  yeevDiscList_replace_i,
  yeevDiscList_append_i,
  yeevDiscList_remove_i,
  yeevDiscList_listDest_i,
  yeevDiscList_replaceDest_i,
  yeevDiscList_destroyDest_i,
  yeevDiscList__get_dlist_i,
  yeevDiscList__get_numEntries_i
 };

static CONST_W_PTR struct yeevReceiver__tyimpl yeevReceiver__impl =
 {
  yeevReceiver_destroy_i,
  yeevReceiver_push_i,
  yeevReceiver_pushMany_i,
  yeevReceiver_pull_i,
  yeevReceiver_pullMany_i,
  yeevReceiver_tryPull_i,
  yeevReceiver_tryPullMany_i,
  yeevReceiver__get_name_i
 };

static CONST_W_PTR struct yeev__tyimpl yeev__impl =
 {
  yeev_createReceiver_i,
  yeev_createDiscList_i,
  yeev_raise_i,
  yeev_raiseMany_i,
  yeev_forward_i,
  yeev__get_info_i,
  yeev__get_receivers_i,
  yeev__get_filters_i,
  yeev__set_filters_i,
  yeev__get_limit_drop_i,
  yeev__set_limit_drop_i,
  yeev__get_globalEventHighWater_i,
  yeev__set_globalEventHighWater_i,
  yeev__get_globalEventRestart_i,
  yeev__set_globalEventRestart_i
 };



/* internal representation of a yeevReceiver */
struct yeevrx
{
  yeevReceiver	self_yeevrx;
  char		*name_yeevrx;	/* name given at creation */
  yeevHndlr	hndlr_yeevrx;	/* handler function */
  dvoid		*usrp_yeevrx;	/* usrp for Hndlr */
  yslst		*q_yeevrx;	/* queue of received yeevr's */
  yslst		*evq_yeevrx;	/* queue of sems for blocked pullers */
  ysle		*le_yeevrx;	/* entry on chs_yeevcx */
};

/* internal form of discriminator */
struct yeevdx
{
  boolean   valid_yeevdx;	/* compiled ok? */
  yeevd	    qual_yeevdx;	/* user visible discriminator */
  ysfe	    *cqual_yeevdx;	/* compiled version of logic */
  ysle	    *le_yeevdx;		/* where in quals_yeevdn */
};

/* many dest node in dests_yeevcx, for batching requests for pushMany */
struct yeevmd
{
  ysspNode  node_yeevmd;	/* node is object ref of yeevReceiver */
  yslst	    *recs_yeevmd;	/* queued events, or NULL */
  sb4	    noi_yeevmd;		/* outstanding i/o ops */
  sb4	    noe_yeevmd;		/* num of events outstanding to this dest */
  boolean   dead_yeevmd;	/* to be deleted when noe is 0 */
}; 

/* dest node, in a yeevdlx disc list */
struct yeevdn
{
  ysspNode  node_yeevdn;	/* key is object ref of dest */
  yslst	    *quals_yeevdn;	/* quals for the dest, each a yeevdx* */
  yeevdlx   *dl_yeevdn;		/* list this is in */
};

/* internal representation of yeevDiscList object */
struct yeevdlx
{
  yeevDiscList	self_yeevdlx;
  ysspTree	dests_yeevdlx;	/* list by dest */
  ysle		*le_yeevdlx;	/* entry on dls_yeevcx  */
};

/* outstanding i/o event item, usrp to completion routine */
struct yeevoe
{
  yeevcx    *cx_yeevoe;
  yeevmd    *md_yeevoe;		/* md entry */
  sb4	    noe_yeevoe;		/* number of events this i/o */
  yoenv	    env_yeevoe;		/* env for this op */
};

struct yeevpw
{
  char *ptr_yeevpw;		/* pointer to buf */
  char buf_yeevpw[1];		/* pointer as a string */
} ;


/* log connection state */
typedef enum
{
  none_yeevcs,
  logimpl_yeevcs,
  default_yeevcs,
  connected_yeevcs
} yeevcs;

/* master context, created by yeevInit, freed in yeevFree */
struct yeevcx
{
  ysque	    *q_yeevcx;
  yeev	    self_yeevcx;
  sb4	    trace_yeevcx;	/* trace level */
  yoenv	    env_yeevcx;		/* handy environment  */

  yssnk	    *sink_yeevcx;	/* our sink for yslogs, if any */

  yeevdlx   *fcx_yeevcx;	/* our filters, really */

  ysevt	    *dsem_yeevcx;	/* shutdown semaphore */
  sb4	    noe_yeevcx;		/* num events outstanding */
  boolean   limited_yeevcx;	/* are we limited right now? */
  boolean   doDrop_yeevcx;	/* attribute; drop or block? */
  sb4	    ndropped_yeevcx;	/* num this limit only */

  char	    *logimpl_yeevcx;	/* special log impl, or NULL */

  yeevl_sender sender_yeevcx;	/* our connection to logger */
  yeevcs       cstate_yeevcx;	/* connect state */
  boolean      csync_yeevcx;	/* want sync connect */
  yslst	       *cwait_yeevcx;	/* list of waiter semaphores */
  yoenv	       cenv_yeevcx;	/* connect environment */
  yeevdSeq     quals_yeevcx;	/* quals back from connect */
    
  yeevReceiver	logr_yeevcx;	/* receiver in sender */
  boolean   shutdown_yeevcx;	/* are we shutting down? */

  yeevReceiver	panic_yeevcx;	/* a panic receiver. */
  sb4   inSend_yeevcx;	/* recursion gate */

  /* obj attrs */

  yeevInfo  info_yeevcx;
  yeevDiscList	filters_yeevcx;	/* my filters */
  ub4	    globLimit_yeevcx;	/* n outstanting to limit */
  ub4	    globRestart_yeevcx;	/* n to fall under to clear limit */
  
  yslst	    *dls_yeevcx;	/* list of known disc lists */
  yslst	    *rcvs_yeevcx;	/* list of known receivers */
  ysspTree  dests_yeevcx;	/* tree of all destinations, yeevmd */
  ysfemap   *map_yeevcx;	/* map to compile with */
  sword	    nmap_yeevcx;	/* entries in map. */
};


/* maximum number of events in flight to all destinations before
   imposing a "limit" state */
#define YEEV_DEF_GLOBAL_LIMIT (200)

/* default to any logger we can find */
#define YEEV_DEF_LOG_IMPL   ((char*)0)

/* facility for our ysRecord-ed events */
#define YEEV_FAC    "YEEV"

/* digits of fractional seconds to show in replacement tty sink */
#define YEEV_TIME_DIGS 3

externdef ysidDecl(YEEV_EX_BAD_SINK) = "yeev::badsink";
externdef ysidDecl(YEEV_EX_ALREADY_SUNK) = "yeev::already_sunk";
externdef ysidDecl(YEEV_EX_NOLOG) = "yeev::nolog";
externdef ysidDecl(YEEV_EX_BAD_CSTATE) = "yeev::bad_cstate";

externdef ysmtagDecl(yeevcx_tag) = "yeevcx";
externdef ysmtagDecl(yeevch_tag) = "yeevch";
externdef ysmtagDecl(yeevdx_tag) = "yeevdx";
externdef ysmtagDecl(yeevdlx_tag) = "yeevdlx";
externdef ysmtagDecl(yeevrx_tag) = "yeevrx";
externdef ysmtagDecl(yeevr_tag) = "yeevr";
externdef ysmtagDecl(yeevdn_tag) = "yeevdn";
externdef ysmtagDecl(yeevoe_tag) = "yeevoe";

#define YEEVFEVAL_ORIG		(YSLOGFEVAL_MAX)
#define YEEVFEVAL_ORIGSEQ	(YSLOGFEVAL_MAX + 1)
#define YEEVFEVAL_TIME		(YSLOGFEVAL_MAX + 2)
#define YEEVFEVAL_HOST		(YSLOGFEVAL_MAX + 3)
#define YEEVFEVAL_PID		(YSLOGFEVAL_MAX + 4)
#define YEEVFEVAL_AFF		(YSLOGFEVAL_MAX + 5)
#define YEEVFEVAL_FORW		(YSLOGFEVAL_MAX + 6)
#define YEEVFEVAL_HOPS		(YSLOGFEVAL_MAX + 7)
#define YEEVFEVAL_PROG		(YSLOGFEVAL_MAX + 8)
#define YEEVFEVAL_MAX		(YSLOGFEVAL_MAX + 9)

STATICF dvoid *yeevFESb8Parse( CONST char *str );
STATICF sword yeevFESb8Cmp( CONST dvoid *a, CONST dvoid*b );    

static CONST_DATA ysfemap yeevFEmap[] =
{
  { "orig", YEEVFEVAL_ORIG,
     yoStrToRef,	yoRelease,      yoIsEq,		ysFENoRelop },
  { "forw", YEEVFEVAL_FORW,
      yoStrToRef,	yoRelease,	yoIsEq,		ysFENoRelop },
  { "origseq", YEEVFEVAL_ORIGSEQ,
      ysFEIntParse,	ysFEDfltFree,	ysFENoPred,	ysFEIntRelop },
  { "time", YEEVFEVAL_TIME,
      yeevFESb8Parse,	ysFEDfltFree,	ysFENoPred,	yeevFESb8Cmp },
  { "host", YEEVFEVAL_HOST,
      ysFEDfltParse,	ysFEDfltFree,	ysFEStrPred,	ysFENoRelop },
  { "pid", YEEVFEVAL_PID,
      ysFEDfltParse,	ysFEDfltFree,	ysFEStrPred,	ysFENoRelop },
  { "aff", YEEVFEVAL_AFF,
      ysFEDfltParse,	ysFEDfltFree,	ysFEStrPred,	ysFENoRelop },
  { "prog", YEEVFEVAL_PROG,
      ysFEDfltParse,	ysFEDfltFree,	ysFEStrPred,	ysFENoRelop },
  { "hops", YEEVFEVAL_HOPS,
      ysFEIntParse,	ysFEDfltFree,	ysFENoPred,	ysFEIntRelop },
};


/* PRIVATE FUNCTION DECLARATIONS */

STATICF void yeSinkTty(dvoid *rusrp, yslrec *rec);

STATICF char *yeevCopyCacheStr( CONST char *s );
STATICF void yeevFreeCacheStr( char *s );

STATICF ub4 yeevNQual( yeevdlx *dl );
STATICF void yeevCompileQual( yeevcx *cx, yeevdx *d );
STATICF boolean yeevEvaluateList( yslst *dl, yeevr* rec);

STATICF yeevdn *yeevDestList( yeevdlx *dl, yeevReceiver r );
STATICF void yeevAddToDestList( yeevcx *cx, yeevdn *dn, yeevd *qual );
STATICF void yeevFreeDestQuals( yeevdn *dn );
STATICF void yeevFreeDest( yeevdn *dn );
STATICF void yeevFreeQual( dvoid *x );
STATICF void yeevFreeRec( dvoid *r );
STATICF void yeevFreeReceiver( dvoid *x );
STATICF void yeevFreeDiscList( dvoid *x );
STATICF void yeevFreeDiscEnts( dvoid *x );

STATICF void yeevGetLog( yeevcx *cx, boolean sync );
STATICF void yeevLogHandler( dvoid *usrp, CONST ysid *exid,
			    dvoid *arg, size_t argsz );
STATICF void yeevEConnect( yeevcx *cx, dvoid *arg );
STATICF void yeevBadDest( yeevcx *cx, yeevmd *dest );

STATICF boolean yeevSend( yeevcx *cx, yeevr *rec );
STATICF void yeevComplete(dvoid *usrp, CONST ysid *exid,
			  dvoid *arg, size_t argsz);

STATICF void yeevDummy(dvoid *usrp, CONST ysid *exid,
			  dvoid *arg, size_t argsz);

STATICF void yeevYsSink( dvoid *rusrp, yslrec *rec );

STATICF yeevmd* yeevManyDestGet( yeevcx *cx, yeevReceiver r );
STATICF void yeevManyDestBatch( yeevmd *md );
STATICF void yeevManyDestSend( yeevcx *cx, yeevmd *md );
STATICF void yeevManyDestFree( yeevcx *cx, yeevmd *md );

STATICF void yeevAllBatch( yeevcx *cx );
STATICF void yeevAllSend( yeevcx *cx );

STATICF void yeevDestDeath( dvoid *usrp, CONST ysid *exid,
			   dvoid *arg, size_t argsz );

/* ---------------------------------------------------------------- */

/* PUBLIC FUNCTIONS */
/* ---------------------------------------------------------------- */

/* ---------------------------- yeevInit ---------------------------- */
/*
   NAME
   yeevInit
   DESCRIPTION
   Initialize yeev objects for service
   
   PARAMETERS
   q		-- q to use.
   RETURNS
   object reference to the yeev we're implementing.
*/

yeev yeevInit( ysque *q )
{
  yeevcx   *cx = (yeevcx*)ysmGlbAlloc( sizeof(*cx), yeevcx_tag );
  char	    *arg;
  yeevdSeq  quals;
  yeevDiscList filters;

  CLRSTRUCT(*cx);
  arg = ysResGetLast("yeev.trace-level");
  cx->trace_yeevcx = arg ? atoi(arg) : 0;
  cx->q_yeevcx = q;
  cx->rcvs_yeevcx = ysLstCreate();
  cx->dls_yeevcx = ysLstCreate();
  DISCARD ysspNewTree( &cx->dests_yeevcx, yoCmp );

  /* build filter map later */
  cx->map_yeevcx = (ysfemap*)0;
  cx->nmap_yeevcx = 0;

  yoEnvInit( &cx->env_yeevcx );

  cx->sink_yeevcx = (yssnk*)0;
  cx->info_yeevcx.host_yeevInfo = yeevCopyCacheStr((char*)ysGetHostName());
  cx->info_yeevcx.pid_yeevInfo = yeevCopyCacheStr((char*)ysGetPid());
  cx->info_yeevcx.affinity_yeevInfo = yeevCopyCacheStr((char*)ysGetAffinity());
  cx->info_yeevcx.prog_yeevInfo = yeevCopyCacheStr((char*)ysProgName());

  /* set limits */
  cx->globLimit_yeevcx = (arg=ysResGetLast("yeev.global-limit")) ?
    (ub4)atol(arg) : YEEV_DEF_GLOBAL_LIMIT;
  cx->globRestart_yeevcx = (arg=ysResGetLast("yeev.global-restart")) ?
    (ub4)atol(arg) : (cx->globLimit_yeevcx - (cx->globLimit_yeevcx / 5));

  cx->shutdown_yeevcx = FALSE;
  cx->doDrop_yeevcx = TRUE;
  cx->inSend_yeevcx = 0;

  /* then serve objects syncronously on the queue */

  yoSetImpl( yeev__id, (char*)0, yeev__stubs,
	    (dvoid*)&yeev__impl, (yoload)0, FALSE, (dvoid*)cx );

  yoSetImpl( yeevReceiver__id, (char*)0, yeevReceiver__stubs,
	    (dvoid*)&yeevReceiver__impl, (yoload)0, FALSE, (dvoid*)cx );

  yoSetImpl( yeevDiscList__id, (char*)0,
	    yeevDiscList__stubs, (dvoid*)&yeevDiscList__impl,
	    (yoload)0, FALSE, (dvoid*)cx );

  cx->self_yeevcx = (yeev)yoCreate( yeev__id, (char*)0 ,
				    (yoRefData*)0, 
				    (char*)0, (dvoid*)0);
  
  /* create empty filter list */
  quals._length = quals._maximum = 0;
  quals._buffer = (yeevd*)0;
  filters = yeev_createDiscList_i( cx->self_yeevcx, &cx->env_yeevcx, &quals );
  yeev__set_filters_i( cx->self_yeevcx, &cx->env_yeevcx, filters );
  yoRelease( (dvoid*)filters );

  yoImplReady( yeev__id, (char*)0, cx->q_yeevcx );
  yoImplReady( yeevReceiver__id, (char*)0, cx->q_yeevcx );
  yoImplReady( yeevDiscList__id, (char*)0, cx->q_yeevcx );
  
  /* get logger info */
  cx->logimpl_yeevcx = (char*)ysResGetLast("yeev.log-impl");
  cx->sender_yeevcx = (yeevl_sender)0;
  cx->cstate_yeevcx = none_yeevcs;
  cx->csync_yeevcx = FALSE;
  cx->cwait_yeevcx = ysLstCreate();
  yoEnvInit( &cx->cenv_yeevcx );

  /* don't do yeevGetLog here -- this may be the logger, and it might
     not be up yet.   Get the log the first time someone needs it. */

  return( cx->self_yeevcx );
}


/* ---------------------------- yeevTerm ---------------------------- */
/*
  NAME
    yeevTerm
  DESCRIPTION
    Terminate the yeev objects and the polling and distribution
    loops.  Does not return until all is shut down.
  PARAMETERS
    ev	    -- object reference from yeevInit
  RETURNS
    none
*/
void yeevTerm( yeev ev )
{
  yeevcx *cx = (yeevcx*)yoGetImplState( (dvoid*)ev );
  ysspNode *n, *next;
  ysevt *evt;

  cx->shutdown_yeevcx = TRUE; 

  /* queue everything up */
  yeevAllSend( cx );

  /* wait until logger connect event completes for better or worse */
  while ((cx->cstate_yeevcx == logimpl_yeevcs) 
	 || (cx->cstate_yeevcx == default_yeevcs))
    ysYield();

  /* wait until current events are drained */
  if( cx->noe_yeevcx && cx->trace_yeevcx )
    /* 150, "yeevTerm: Waiting for %d events to drain to logger(s)" */
    ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)150, YSLSEV_DEBUG(0), (char*)0, 
	     YSLSB4(cx->noe_yeevcx), YSLEND );

  while( cx->noe_yeevcx )
    ysYield();

  /* disconnnect from ysLog */
  if( cx->sink_yeevcx )
    ysSinkDestroy( cx->sink_yeevcx );

  if( cx->filters_yeevcx )
  {
    yeevDiscList_destroy( cx->filters_yeevcx, &cx->env_yeevcx );
    yoRelease( cx->filters_yeevcx );
  }
  
  if( cx->sender_yeevcx )
  {
    /* If logger has gone down, this may take a long time, like
       forever.  Do this async in a way that lets us exit anyway. */
      
    /* FIXME - why not ysEvtDummy?  Think there was a reason... -dB */

    evt = ysEvtCreate( yeevDummy, (dvoid*)0, (ysque*)0, TRUE );
    yeevl_sender_destroy_nw( cx->sender_yeevcx, &cx->env_yeevcx, evt );
    ysEvtDestroy( evt );
			
    yoRelease((dvoid*)cx->sender_yeevcx);
    cx->sender_yeevcx = (yeevl_sender)0;
  }

  ysLstDestroy( cx->cwait_yeevcx, (ysmff)ysEvtDestroy );
  
  yoRelease( (dvoid*)ev );	/* bug 524764 */
  yoDispose( (dvoid*)ev );
  yoImplDeactivate( yeev__id, (char*)0 );

  if( cx->noe_yeevcx )
  {
    /* flag/signal for yeevComplete */
    cx->dsem_yeevcx = ysSemCreate((dvoid*)0 );
    ysSemWait( cx->dsem_yeevcx );
    ysSemDestroy( cx->dsem_yeevcx );
  }

  /* clean up context */

  ysLstDestroy( cx->dls_yeevcx, yeevFreeDiscList ); 
  ysLstDestroy( cx->rcvs_yeevcx, yeevFreeReceiver );

  for( n = ysspFHead(  &cx->dests_yeevcx ); n ; n = next )
  {
    next = ysspFNext( n );
    yeevManyDestFree( cx, (yeevmd*)n );
  }

  /* don't deactivate till we are cleaned up above */
  yoImplDeactivate( yeevReceiver__id, (char*)0 );
  yoImplDeactivate( yeevDiscList__id, (char*)0 ); 

  if( cx->map_yeevcx )
    ysmGlbFree( (dvoid*)cx->map_yeevcx );
  
  yoEnvFree( &cx->env_yeevcx );

  ysmGlbFree( (dvoid*)cx );
}


/* ---------------------------- yeevHaveLogger ---------------------------- */
/*
  NAME
    yeevHaveLogger
  DESCRIPTION
    Do we have a connection to a logger?  If so, it may be time to
    yeevSinkAttach and redirect ysLog output from the screen/local console
    to the network logger.

    If we don't have a logger at the time of the call, we'll go look.
    
  PARAMETERS
    yeev	-- event system ref.
  RETURNS
    TRUE if we have a logger, FALSE if we haven't find one yet.
*/
boolean yeevHaveLogger( yeev ev )
{
  yeevcx *cx = (yeevcx*)yoGetImplState( (dvoid*)ev );

  if( cx->cstate_yeevcx != connected_yeevcs )
    yeevGetLog( cx, TRUE );

  return( cx->cstate_yeevcx == connected_yeevcs );
}


/* ---------------------- yeevReceiverSetHandler -------------------------- */
/*
  NAME
    yeevReceiverSetHandler
  DESCRIPTION
    In the process owing the receiver, attach a function to be called
    when an event is received.  The event will appear as the arg of the
    handler function.
  PARAMETERS
    or	    -- reference to a yeevReceiver to attach.
    hndlr	-- new handler to install.
    usrp	-- usrp for the handler.
  RETURNS
    previous handler, initially NULL
*/
yeevHndlr yeevReceiverSetHandler(yeevReceiver or,
				 yeevHndlr hndlr, dvoid *usrp)
{
  yeevrx *rcv = (yeevrx*)yoGetState((dvoid*)or);
  yeevHndlr oh = rcv->hndlr_yeevrx;
  yeevr *rec;

  rcv->hndlr_yeevrx = hndlr;
  rcv->usrp_yeevrx = usrp;

  if( hndlr && ysLstCount( rcv->q_yeevrx ) )
  {
    /* take anything currently queued */
    while( (rec = (yeevr*)ysLstDeq( rcv->q_yeevrx ) ) )
    {
      (*hndlr)( rec, usrp );
      yeevr__free( rec, yotkFreeStr );
      ysmGlbFree( (dvoid*)rec );
    }
  }
  return( oh );
}


void yeevBatchStart( yeev ev )
{
  yeevcx *cx = (yeevcx*)yoGetImplState( (dvoid*)ev );
  yeevAllBatch( cx );
}



void yeevBatchSend( yeev ev )
{
  yeevcx *cx = (yeevcx*)yoGetImplState( (dvoid*)ev );
  yeevAllSend( cx );
}


/* -------------------------- yeevSinkAttach --------------------------- */
/*
  NAME
    yeevSinkAttach
  DESCRIPTION
    Attach yeev to the ysLog system, as specified.  There is only one
    sink from ysLog to yeev ever present; if this is called multiple times,
    the state of the existing sink is changed.
  PARAMETERS
    evr		the yeev
    level	level to deliver records <=, YSLSEVALL for all.
  RETURNS
    none
*/

void yeevSinkAttach(yeev evr, ub4 level)
{
  yeevcx    *cx = (yeevcx*)yoGetImplState((dvoid*)evr);
  ub4	    ylevel;
  char	    buf[ 100 ];

  /* try to get logger connection now to avoid sync connect call in
     idler later. */
  if( cx->cstate_yeevcx != connected_yeevcs )
    yeevGetLog( cx, TRUE );

  /* do not allow level debug(7) -- that gets yo trace events that would
     cause amplified feedback! */

  ylevel = level;
  if ( level > (YSLSEV_MAX - 2) )
    ylevel = YSLSEV_MAX - 2;
  ysFmtStr( buf, "maxsev %d", ylevel );

  if( cx->sink_yeevcx )
    ysePanic( YEEV_EX_ALREADY_SUNK );
  else
    cx->sink_yeevcx = ysSinkCreate( "yeevSink", yeevYsSink, (dvoid*)cx );

  ysSinkSetFilter( cx->sink_yeevcx, ysFilterSimple, (dvoid*)0,
		  (ysFilterCB*)0, (dvoid**)0 );
  ysAddFilter( cx->sink_yeevcx, buf );
}

/* -------------------------- yeevSinkDetach ---------------------------- */
/*
  NAME
    yeevSinkDetach
  DESCRIPTION
    Disconnect yeev from ysLog.  Error if not already attached.
  PARAMETERS
    evr	    the yeev.
  RETURNS
    none
*/
void yeevSinkDetach( yeev evr )
{
  yeevcx    *cx = (yeevcx*)yoGetImplState((dvoid*)evr);

  if( !cx->sink_yeevcx )
  {
    /* 160, "yeevSinkDestroy: not currently attached" */
    ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)160, YSLSEV_WARNING, (char*)0,
	     YSLNONE);
    yseThrow( YEEV_EX_BAD_SINK );
  }
  else
  {
    ysSinkDestroy( cx->sink_yeevcx );
    cx->sink_yeevcx = (yssnk*)0;
  }
}

/* should we keep the record for anyone? */
boolean yeevEvaluate( yeevr *rec, yeevDiscList dl )
{
  yeevdlx *dlx = (yeevdlx*)yoGetState( (dvoid*)dl );
  ysspNode  *n;
  yeevdn *dn;
  
  boolean rv = FALSE;

  /* for each dest, evaluate the filters list  */
  for( n = ysspFHead( &dlx->dests_yeevdlx ) ; n && !rv; n = ysspFNext(n) )
  {
    dn = (yeevdn*)n;
    rv = yeevEvaluateList( dn->quals_yeevdn, rec );
  }
  return( rv );
}




/* ---------------------------- yeevRemoteLog ---------------------------- */
/*
  NAME
    yeevRemoteLog
  DESCRIPTION
    Switch to remote logging, turning off tty output of ysRecords.
    If input yeev is null, starts up the yeev system.

    ysRecord logging may be terminated with yeevSinkDetach.  The returned
    yeev object must eventually be terminated with yeevTerm.

    This version creates a new sink if the resource
    "ye.lot.tty.filter" is set.

  PARAMETERS
    ev	    -- event system reference, or NULL.
    q	    -- queue to run new yeev on.
  RETURNS
    yeev reference, for later use by yeevTerm.
*/

yeev yeevRemoteLog( yeev ev, ysque *q )
{
  yssnk *sink;
  yslst *lst;
  ysle *le;

  if( !ev )
    ev = yeevInit( q );

  if(yeevHaveLogger(ev))
  {
    yeevSinkAttach(ev, YSLSEV_DEBUG(8));

    /* destroy old tty sink */

    if((sink=ysSinkFind("tty")))
      ysSinkDestroy(sink);

    /* if filters exist, install new tty sink */

    lst = ysResGet("ye.log.tty.filter");
    if( lst && ysLstCount(lst) )
    {
      sink = ysSinkCreate("tty", yeSinkTty, yoGetImplState((dvoid*)ev));
      ysSinkSetFilter(sink, ysFilterSimple, (dvoid *) 0,
		      (ysFilterCB *) 0, (dvoid **) 0);
      for (le = ysLstHead(lst); le; le = ysLstNext(le))
	ysAddFilter(sink, (char *) ysLstVal(le));
    }
  }
  return( ev );
}



/* ---------------------------------------------------------------- */
/* PRIVATE FUNCTIONS */
/* ---------------------------------------------------------------- */

/*
 * yeSinkTty - fancier terminal sink, shows time, seq, assoc.
 */

STATICF  void yeSinkTty(dvoid *rusrp, yslrec *rec)
{
  yeevcx *cx = (yeevcx*)rusrp;
  ysmsgd *msgd;
  char   *bufp, buf[512], out[512];
  CONST char	*assoc;
  ystm	tm;
  char tbuf[ YSTM_BUFLEN ];
  sysb8	now;
 
  if (rec)
    {
      msgd = ysMsgFind(rec->prod, rec->fac);
      bufp = ysMsgGet(msgd, rec->msgid, buf, sizeof(buf));
      ysMsgFmt(out, sizeof(out), (sword)rec->argvec.narg,
	       rec->argvec.args, bufp);

      ysClock(&now);
      ysConvClock( &now, &tm );
      DISCARD ysStrClock( tbuf, &tm, FALSE, YEEV_TIME_DIGS );
      assoc = rec->assoc && *rec->assoc ? rec->assoc : (CONST char*)0;

      yslError("%s %d %s:%s%s%s %s %s-%d %d %s%s%s { %s }\n",
	       tbuf,
	       rec->seqid,
	       cx->info_yeevcx.host_yeevInfo,
	       cx->info_yeevcx.pid_yeevInfo,
	       cx->info_yeevcx.affinity_yeevInfo ? ":" : "",
	       cx->info_yeevcx.affinity_yeevInfo ?
	       cx->info_yeevcx.affinity_yeevInfo : "",
	       cx->info_yeevcx.prog_yeevInfo,
	       rec->prod, rec->msgid, rec->sev,
	       assoc ? "[" : "",
	       assoc ? assoc : "",
	       assoc ? "] " : "",
	       out);
    }
}


/* ---------------------------- yeevCopyCacheStr ---------------------------- */
/*
  NAME
    yeevCopyCacheStr
  DESCRIPTION
    copy a string into the cache.
  PARAMETERS
    s	    -- the string to copy.
  RETURNS
    pointer to a cached version of the string.
*/

STATICF char *yeevCopyCacheStr( CONST char *s )
{
  char *rv = (char*)0;

  if( s )
    yotkCopyVal( yoTcString, (dvoid*)&rv, (dvoid*)&s, yotkAllocStr );  

  return rv;
}

/* ---------------------------- yeevFreeCacheStr ---------------------------- */
/*
  NAME
    yeevFreeCacheStr
  DESCRIPTION
    Release a copy of a cached string.
  PARAMETERS
    s	    -- the string to release a reference to.
  RETURNS
    none
*/

STATICF void yeevFreeCacheStr( char *s )
{
  yotkFreeVal( yoTcString, (dvoid*)&s, yotkFreeStr );
}


/* ---------------------------- yeevYsSink ---------------------------- */
/*
  NAME
    yeevYsSink
  DESCRIPTION
    Callback driven by ysLog to deliver records that are to be turned into
    yeev events.  This raises a yeevYsLogEvent. 
    
  PARAMETERS
    rusrp   -- pointer to cx;
    lrec    -- the YsRecord-ed record.
  RETURNS
    none
*/

/* ARGSUSED */
STATICF void yeevYsSink( dvoid *rusrp, yslrec *lrec )
{
  yeevcx *cx = (yeevcx*)rusrp;
  yeevr rec;
  yeevYsLogEvent yevt;

  if( !lrec )
    return;

  /* set up the yeev event wrapper */
  rec.origseq_yeevr = lrec->seqid;
  rec.fac_yeevr = (char*)lrec->fac;
  rec.prod_yeevr = (char*)lrec->prod;
  rec.assoc_yeevr = (char*)lrec->assoc;
  rec.sev_yeevr = lrec->sev;
  rec.msgid_yeevr = lrec->msgid;

  rec.val_yeevr._type = (yotk*)YCTC_yeevYsLogEvent;
  rec.val_yeevr._value = (dvoid*)&yevt;
  yevt.seqid = lrec->seqid;
  yevt.vals._length = lrec->argvec.narg;
  yevt.vals._buffer = (yoany*)lrec->argvec.args;

  /* raise the event */
  yeev_raise_i( cx->self_yeevcx, &cx->env_yeevcx, &rec );
}


/* ---------------------------- yeevDestList ---------------------------- */
/*
  NAME
    yeevDestList
  DESCRIPTION
    Return a dest node for the receiver, creating one if needed.
  PARAMETERS
    dl	    the discriminator list to use.
    r	    the receiver
  RETURNS
    pointer to the dest node.
*/

STATICF yeevdn *yeevDestList( yeevdlx *dl, yeevReceiver r )
{
  yeevdn *dn;

  if( !(dn = (yeevdn*)ysspLookup( (dvoid*)r, &dl->dests_yeevdlx ) ) )
  {
    dn = (yeevdn*)ysmGlbAlloc( sizeof(*dn), yeevdn_tag );
    dn->node_yeevdn.key_ysspNode = (dvoid*)yoDuplicate(r);
    dn->quals_yeevdn = ysLstCreate();
    dn->dl_yeevdn = dl;
    DISCARD ysspEnq( &dn->node_yeevdn, &dl->dests_yeevdlx ); 

  }
  return dn;
}


/* ------------------------- yeevAddToDestist --------------------------- */
/*
  NAME
    yeevAddToDestList
  DESCRIPTION
    Add a qualification to the discriminator list for a destination.
  PARAMETERS
    dn	    the dest to modify
    qual    the qualification to add.
  RETURNS
    none
*/

STATICF void yeevAddToDestList( yeevcx *cx, yeevdn *dn, yeevd *qual )
{
  yeevdx *dx = (yeevdx*)ysmGlbAlloc(sizeof(*dx), yeevdx_tag );

  dx->valid_yeevdx = FALSE;
  yeevd__copy( &dx->qual_yeevdx, qual, yotkAllocStr );
  yeevCompileQual( cx, dx );
  dx->le_yeevdx = ysLstEnq( dn->quals_yeevdn, (dvoid*)dx );
}

/* ---------------------------- yeevNQual ---------------------------- */
/*
  NAME
    yeevNQual
  DESCRIPTION
    Figure out how many quals are in the entire discriminator list;
    this is the sum of the list length of all the dests.
  PARAMETERS
    dl	    -- disc list to count quals in.
  RETURNS
    number of qualifications in the list
*/

STATICF ub4 yeevNQual( yeevdlx *dl )
{
  ysspNode *n;
  yeevdn *dn;
  ub4 rv = 0;
  
  for( n = ysspFHead( &dl->dests_yeevdlx ) ; n ; n = ysspFNext( n ) )
  {
    dn = (yeevdn*)n;
    rv += ysLstCount( dn->quals_yeevdn );
  }
  return( rv );
}

/* ---------------------------- yeevCompileQual ---------------------------- */
/*
  NAME
    yeevCompileQual
  DESCRIPTION
    Turn a string form qualification into a more useful internal form.

    obeys yslog.h filter format, with extensions for
    the yeevent record as follows

	name		data type	expr type
	-----------------------------------------
	"orig"		str obj ref	predicate
	"forw"		str obj ref	predicate
	"hops"		integer		relop
	"time"		string		relop
	"origseq"	integer		relop
	"host"		string		predicate
	"pid"		string		predicate
	"aff"		string		predicate
	"prog"		string		predicate

  PARAMETERS
    dx	    -- the discriminator to process
  RETURNS
    none
*/

STATICF void yeevCompileQual( yeevcx *cx, yeevdx *dx )
{
  ysfe	*fe;
  CONST ysfemap   *map;
  sword nmap;

  yeev_qual_invalid pex;

  if( !cx->map_yeevcx )
  {
    map = ysLogGetMap( &nmap );
    cx->map_yeevcx = (ysfemap*)ysmGlbAlloc( (nmap + sizeof(yeevFEmap) /
					     sizeof(*map)) * sizeof(*map),
					   "yeev fe map" ); 
    DISCARD memcpy( (dvoid*)cx->map_yeevcx, (dvoid*)map, nmap * sizeof(*map));
    DISCARD memcpy( (dvoid*)(cx->map_yeevcx + nmap), (dvoid*)yeevFEmap,
		   sizeof(yeevFEmap) );
    cx->nmap_yeevcx = (sword)(nmap + (sizeof(yeevFEmap) / sizeof(*map)));
  }

  /* apply a promiscuous default filter if NULL or empty */
  if( dx->qual_yeevdx.qual_yeevd && !*dx->qual_yeevdx.qual_yeevd )
  {
    yeevFreeCacheStr( dx->qual_yeevdx.qual_yeevd );
    dx->qual_yeevdx.qual_yeevd = (char*)0;
  }
  if( !dx->qual_yeevdx.qual_yeevd )
    dx->qual_yeevdx.qual_yeevd = yeevCopyCacheStr( "maxsev 16" );

  if( !( fe = ysFECompile( dx->qual_yeevdx.qual_yeevd,
			  cx->nmap_yeevcx, cx->map_yeevcx )) )
  {
    dx->valid_yeevdx = FALSE;

    /* 170, "yeevCompileQual: error compiling '%s'" */
    ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)170, YSLSEV_INFO, (char*)0,
	     YSLSTR(dx->qual_yeevdx.qual_yeevd), YSLEND);
    pex.qual = dx->qual_yeevdx.qual_yeevd;
    yseThrowObj( EX_YEEV_QUAL_INVALID, pex );
  }
  dx->valid_yeevdx = TRUE;
  dx->cqual_yeevdx = fe;
}

/* ------------------------- yeevEvaluateList ---------------------------- */
/*
  NAME
    yeevEvaluateList
  DESCRIPTION
    Given a record and a discriminator list, evaluate the list and determine
    what to do.  Return TRUE to deliver, FALSE to drop.

    For each destination, the list of pre-compiled qualifications is
    evaluated.  The quals are "or-ed" together.

  PARAMETERS
    dl	    -- discriminator list
    rec	    -- record to consider.
  RETURNS
    TRUE to deliver.
    FALSE to drop.
*/

STATICF boolean yeevEvaluateList( yslst *dl, yeevr* rec )
{
  ysle *e;
  yeevdx *dx;

  dvoid *vals[YEEVFEVAL_MAX];
  
  vals[YSLOGFEVAL_PROD] = (dvoid *) rec->prod_yeevr;
  vals[YSLOGFEVAL_FAC] = (dvoid *) rec->fac_yeevr;
  vals[YSLOGFEVAL_MSGID] = (dvoid*)&rec->msgid_yeevr;
  vals[YSLOGFEVAL_SEV] = (dvoid*)&rec->sev_yeevr;
  vals[YSLOGFEVAL_ASSOC] =
    (dvoid *) (rec->assoc_yeevr ? rec->assoc_yeevr : "");

  vals[YSLOGFEVAL_SEQID] = (dvoid*)&rec->origseq_yeevr;

  vals[ YEEVFEVAL_ORIG ] = (dvoid*)rec->orig_yeevr;
  vals[ YEEVFEVAL_ORIGSEQ ] = (dvoid*)&rec->origseq_yeevr;
  vals[ YEEVFEVAL_TIME ] = (dvoid*)&rec->origtime_yeevr;
  vals[ YEEVFEVAL_HOST ] = (dvoid*)rec->orighost_yeevr;
  vals[ YEEVFEVAL_PID ] =  (dvoid*)rec->origpid_yeevr;
  vals[ YEEVFEVAL_AFF ] = (dvoid*)rec->origaff_yeevr;
  vals[ YEEVFEVAL_FORW ] = (dvoid*)rec->orig_yeevr;
  vals[ YEEVFEVAL_HOPS ] = (dvoid*)&rec->hops_yeevr;
  vals[ YEEVFEVAL_PROG ] = (dvoid*)rec->origprog_yeevr;

  for( e = ysLstHead( dl ); e ; e = ysLstNext( e ) )
  {
    dx = (yeevdx*)ysLstVal(e);
    if( !dx->valid_yeevdx )
      continue;

    if( ysFEEval(dx->cqual_yeevdx, YEEVFEVAL_MAX, vals ) )
      return( TRUE );
  }
  return( FALSE );
}

/* ------------------------- yeevFreeDestQuals ---------------------------- *//*
  NAME
    yeevFreeDestQuals
  DESCRIPTION  
    Free all the qualifications currently attached to a destination.
    Don't destroy the list that contains them.
  PARAMETERS
    dn	    the dest in question.
  RETURNS
    none
*/

STATICF void yeevFreeDestQuals( yeevdn *dn )
{
  dvoid *x;

  while( (x = ysLstDeq( dn->quals_yeevdn ) ) )
    yeevFreeQual( x );
}


/* ---------------------------- yeevFreeQual ---------------------------- */
/*
  NAME
    yeevFreeQual
  DESCRIPTION
    Free a yeevdx completely, in a way usable in a ysLstDestroy function.
  PARAMETERS
    x	    -- the yeevdx as a dvoid *.
  RETURNS
    none
*/

STATICF void yeevFreeQual( dvoid *x )
{
  yeevdx *dx = (yeevdx*)x;

  yeevd__free( &dx->qual_yeevdx, yotkFreeStr );
  if( dx->valid_yeevdx )
    ysFEFree( dx->cqual_yeevdx );
  ysmGlbFree( x );
}

/* ---------------------------- yeevFreeDest ---------------------------- */
/*
  NAME
    yeevFreeDest
  DESCRIPTION
    Remove a destination node from a tree.
  PARAMETERS
    dn	    -- the dest node to remove.
  RETURNS
    none
*/

STATICF void yeevFreeDest( yeevdn *dn )
{
  yoRelease(dn->node_yeevdn.key_ysspNode);
  ysLstDestroy( dn->quals_yeevdn, yeevFreeQual );
  ysspRemove( &dn->node_yeevdn, &dn->dl_yeevdn->dests_yeevdlx );
  ysmGlbFree( (dvoid*)dn );
}

/* ---------------------------- yeevFreeRec ---------------------------- */
/*
  NAME
    yeevFreeRec
  DESCRIPTION
    Release an event completely.
  PARAMETERS
    x	    -- the yeevr, as a dvoid * 
  RETURNS
    none
*/

STATICF void yeevFreeRec( dvoid *x )
{
  yeevr__free( (yeevr*)x, yotkFreeStr );
  ysmGlbFree( (dvoid *) x );
}

/* --------------------------- yeevFreeReceiver ---------------------------- */
/*
  NAME
    yeevFreeReceiver
  DESCRIPTION
    Release a known receiver entry, completely.
  PARAMETERS
    x	    -- the yeevrx, as a dvoid *.
  RETURNS
    none
*/

STATICF void yeevFreeReceiver( dvoid *x )
{
  yeevrx *r = (yeevrx*)x;

  yoRelease((dvoid*)r->self_yeevrx);
  yoDispose((dvoid*)r->self_yeevrx);
  ysLstDestroy( r->evq_yeevrx, (ysmff)ysEvtDestroy );
  ysLstDestroy( r->q_yeevrx, yeevFreeRec );
  if( r->name_yeevrx )
    ysmGlbFree((dvoid*)r->name_yeevrx);
  ysmGlbFree( (dvoid*)r );
}


/* ---------------------------- yeevFreeDiscList ---------------------------- */
/*
  NAME
    yeevFreeDiscList
  DESCRIPTION
    Release a discriminator list, and destorying it's object.
  PARAMETERS
    x	    -- the yeevdlx, as a dvoid *.
  RETURNS
    none
*/

STATICF void yeevFreeDiscList( dvoid *x )
{
  yeevdlx *dl = (yeevdlx *)x;

  yeevFreeDiscEnts( x );
  yoRelease((dvoid*)dl->self_yeevdlx);
  yoDispose((dvoid*)dl->self_yeevdlx);
  ysmGlbFree( (dvoid*)dl );
}


/* ---------------------------- yeevFreeDiscEnts ---------------------------- */
/*
  NAME
    yeevFreeDiscEnts
  DESCRIPTION
    Release contents of discriminator list.
  PARAMETERS
    x	    yeevdlx, as dvoid *.
  RETURNS
    none
*/

STATICF void yeevFreeDiscEnts( dvoid *x )
{
  yeevdlx *dl = (yeevdlx *)x;
  yeevdn *dn;

  while( (dn = (yeevdn*)ysspDeq( &dl->dests_yeevdlx.root_ysspTree )) )
  {
    yoRelease(dn->node_yeevdn.key_ysspNode);
    ysLstDestroy( dn->quals_yeevdn, (ysmff)yeevFreeQual );
    ysmGlbFree( (dvoid*)dn );
  }
}


/* ---------------------------- yeevGetLog ---------------------------- */
/*
  NAME
    yeevGetLog
  DESCRIPTION

    If we have no destinations, get the programming for the best available
    logger.  This locates our logger, using the search strategy:
    
	1.  explicit logimpl match;
	2.  default logimpl match (null).

    We retrieve programming from the logger, and attach that to the
    discriminator list for that destination.

  PARAMETERS
    cx	    -- our context.
    sync    -- true if we should block till result is known, else async.
  RETURNS
    none
*/

STATICF void yeevGetLog( yeevcx *cx, boolean sync )
{
  ysevt *sem = (ysevt*)0;

  if( sync && cx->cstate_yeevcx != connected_yeevcs )
  {
    /* We can only make sync calls in connect if nothing else is 
       going on; and we MUST make sync calls in the logger itself
       or it will deadlock against itself */

    if( cx->cstate_yeevcx == none_yeevcs )
      cx->csync_yeevcx = TRUE;
    else
      DISCARD ysLstEnq( cx->cwait_yeevcx,
		       (dvoid*)(sem = ysSemCreate( (dvoid*)0 ))); 
  }

  switch( cx->cstate_yeevcx )
  {
  case none_yeevcs:    /* input exception causes machine restart */
    yeevLogHandler( (dvoid*)cx, YEEV_EX_NOLOG, (dvoid*)0, (size_t)0 );
    break;

  case logimpl_yeevcs:
  case default_yeevcs:
  case connected_yeevcs:
    /* already running the machine or have logger; nothing to do */
    break;

  default:
    yslError("yeevGetLog: unexpected cstate %d\n", cx->cstate_yeevcx);
    ysePanic( YEEV_EX_BAD_CSTATE );
  }

  if( cx->csync_yeevcx )
    cx->csync_yeevcx = FALSE;   

  if( sem )
  {
    ysSemWait( sem );
    ysSemDestroy( sem );
  }
}

/* ---------------------------- yeevLogHandler ---------------------------- */
/*
  NAME
    yeevLogHandler
  DESCRIPTION
    State machine for getting a log connection.  Sets the next state and
    starts the necessary operation.   If connected on exit, awaken all
    waiting threads.
  PARAMETERS
    usrp	-- the context, as a dvoid *.
    exid	-- exception
    arg		-- sometimes pointer to returned object ref.
    argsz	-- size of arg.
  RETURNS
    none
*/
/* ARGSUSED */
STATICF void yeevLogHandler( dvoid *usrp, CONST ysid *exid,
			    dvoid *arg, size_t argsz )
{
  yeevcx	*cx = (yeevcx*)usrp;
  yeevl_logProc noreg lg = (yeevl_logProc)0;
  ysevt		*sem;
  yeevl_sender	sender;

  NOREG(lg);

  switch( cx->cstate_yeevcx )
  {
  case none_yeevcs:		/* no log, start connect attempts */

    if( cx->logimpl_yeevcx )
    {
      /* try logimpl */
      cx->cstate_yeevcx = logimpl_yeevcs;
      lg = (yeevl_logProc) yoBind( yeevl_logProc__id, cx->logimpl_yeevcx,
				  (yoRefData*)0, (char*)0 );
      break;
    }
    /* FALLTHROUGH */

  case logimpl_yeevcs:		/* completion of logimpl attempt */

    if( !exid )
      yeevEConnect( cx, arg );	/* success */
    else
    {
      /* try default */
      cx->cstate_yeevcx = default_yeevcs;
      lg = (yeevl_logProc)yoBind( yeevl_logProc__id, (char*)YEEV_DEF_LOG_IMPL,
				 (yoRefData*)0, (char*)0 );
    }
    break;

  case default_yeevcs:		/* completion of default attempt */

    if( !exid )
      yeevEConnect( cx, arg );	/* success */
    else
    {
      /* failure; just reset the machine for another try the next
         time someone wants to make the attempt. */
      cx->cstate_yeevcx = none_yeevcs;
    }
    break;
    

    /* already done. */
  case connected_yeevcs:
    lg = (yeevl_logProc)0;
    break;
    
  default:

    yslError("yeevLogHandler: unexpected state %d\n", cx->cstate_yeevcx);
    ysePanic( YEEV_EX_BAD_CSTATE );
    break;
  }

  /* if need to, make/start connection attempt */
  if( lg )
  {
    if( cx->csync_yeevcx )
    {
      yseTry
      {
	sender =
	  yeevl_logProc_connectSender( lg, &cx->env_yeevcx,
				      cx->self_yeevcx,
				      cx->info_yeevcx.host_yeevInfo,
				      cx->info_yeevcx.pid_yeevInfo,
				      cx->info_yeevcx.affinity_yeevInfo,
				      cx->info_yeevcx.prog_yeevInfo,
				      &cx->quals_yeevcx );
	arg = (dvoid*)&sender; 
	yeevEConnect( cx, arg );
	yoRelease( (dvoid*)sender );
      }
      yseCatch(YO_EX_BADOBJ)	/* nothing */;
      yseCatch(YEEVL_EX_OPERATIONFAILED) /* nothing */;
      yseEnd;

      /* (ugly) recursion to next state */
      if( cx->cstate_yeevcx != connected_yeevcs )
	yeevLogHandler( (dvoid*)cx, YEEV_EX_NOLOG, (dvoid*)0, (size_t)0 );
    }
    else
    {
      yeevl_logProc_connectSender_nw( lg, &cx->env_yeevcx,
				     cx->self_yeevcx,
				     cx->info_yeevcx.host_yeevInfo,
				     cx->info_yeevcx.pid_yeevInfo,
				     cx->info_yeevcx.affinity_yeevInfo,
				     cx->info_yeevcx.prog_yeevInfo,
				     &cx->quals_yeevcx,
				     ysEvtSimple(yeevLogHandler, (dvoid*)cx));
    }
    yoRelease( (dvoid*)lg );
  }

  /* if now connected, wake up waiters */
  if( cx->cstate_yeevcx == connected_yeevcs )
  {
    /* waken all the waiting threads */
    while( (sem = (ysevt*)ysLstDeq( cx->cwait_yeevcx ) ) )
      ysTrigger( sem, (ysid*)0, (dvoid*)0, (size_t)0 ); 
  }
}


/* ---------------------------- yeevEConnect ---------------------------- */
/*
  NAME
    yeevEConnect
  DESCRIPTION
    End of a connection; absorb the returned qualifications and program
    our local filters to the new logger.  
  PARAMETERS
    cx		-- the context
    arg		-- yeevl_sender*
  RETURNS
    none
*/

STATICF void yeevEConnect( yeevcx *cx, dvoid *arg )
{
  cx->sender_yeevcx = (yeevl_sender)yoDuplicate(*(dvoid**)arg);
  cx->cstate_yeevcx = connected_yeevcs;
  cx->logr_yeevcx =
    (yeevReceiver)yoDuplicate((dvoid*)cx->quals_yeevcx._buffer[0].dest_yeevd);
 
  yeevDiscList_append_i( cx->filters_yeevcx, &cx->env_yeevcx,
			&cx->quals_yeevcx );
  yeevdSeq__free( &cx->quals_yeevcx, yoFree );
}


/* ---------------------------- yeevBadDest ---------------------------- */
/*
  NAME
    yeevBadDest
  DESCRIPTION
    Remove all knowledge about a destination we have decided is no good
    anymore.  Do this everywhere, iterating over all the places dests
    are kept -- this is currently in all the discriminator lists that
    may have a reference.

  PARAMETERS
    cx	    -- our context
    md	    -- the bad destination.
  RETURNS
    none
*/

STATICF void yeevBadDest( yeevcx *cx, yeevmd *md )
{
  dvoid *victim;		/* really a yeevReceiver */
  yeevdlx *dl;
  ysle	*e;
  yeevdn    *dn;

  if( !cx->shutdown_yeevcx )
  {
    victim = md->node_yeevmd.key_ysspNode;
    md->dead_yeevmd = TRUE;

#ifdef NEVER
    /* 190, "yeevBadDest: md %s, victim r %s" */
    ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)190, YSLSEV_DEBUG(8), (char*)0,
	     YSLPTR(md), YSLPTR(victim), YSLEND );
#endif

    /* special case if the logger dies */
    if( yoIsEq( (dvoid*)victim, (dvoid*)cx->logr_yeevcx ) )
    {
#ifdef NEVER
      /* 191, "yeevBadDest: breaking logger connection" */
      ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)191, YSLSEV_DEBUG(8), (char*)0,
	       YSLNONE);
#endif
      cx->sender_yeevcx = (yeevl_sender)0;
      cx->cstate_yeevcx = none_yeevcs;

      /* defer this till outstanding sends drain. May leak refs if we get
         new a logger before the drain is complete; too bad.  */
      if( !md->noi_yeevmd )
      {
	yoRelease( (dvoid*)cx->logr_yeevcx );
	/* don't do sender_destroy; presume it's dead */
	yoRelease( (dvoid*)cx->sender_yeevcx );
      }
    }

    /* kill filters to that destination.  for each disc list... */
    for( e = ysLstHead( cx->dls_yeevcx ) ; e ; e = ysLstNext(e) )
    {
      /* lookup the victim and destroy */
      dl = (yeevdlx*) ysLstVal(e);
      if( (dn = (yeevdn*)ysspLookup( victim, &dl->dests_yeevdlx ) ) )
	yeevFreeDest( dn );
    }

    yeevManyDestFree( cx, md );
  }
}

/* ---------------------------- yeevSend ---------------------------- */
/*
  NAME
    yeevSend
  DESCRIPTION
    Given a completely filled in event, distribute it as per the
    programming.  For each destination, evaluate it's discrimiminator
    list against the event.  Also, enforce global and per-destination
    in-flight event limits.

    This version starts the push operations asyncronously.

  PARAMETERS
    cx	-- context
    ev	-- environment to use for the send.
    rec	-- the event record to distribute
  RETURNS
    none
*/

STATICF boolean yeevSend( yeevcx *cx, yeevr *rec )
{
  ysspNode  *n;
  yeevdlx   *dl;
  yeevdn    *dn;
  ysevt	    *evt;
  yeevoe    *oe;
  yowiden dummy = (yowiden)0;
  yeevmd    *md;
  yeevr	    *srec;
  boolean   qualified = FALSE;

  /* if recursive and getting logger, drop */
  if( cx->inSend_yeevcx && !cx->sender_yeevcx )
    return FALSE;

  cx->inSend_yeevcx++;

  /* we want completions to drop noe, but ysYield is slow, so only
     do it when it seems necessary. */

  if( cx->noe_yeevcx > (cx->globLimit_yeevcx / 4) )
    ysYield();

  /* don't get log if have dest */
  if( !cx->sender_yeevcx )
    yeevGetLog( cx, FALSE );	/* async - drop events until connected */

  /* for each dest, evaluate the filters list  */
  dl = cx->fcx_yeevcx;
  for( n = ysspFHead( &dl->dests_yeevdlx ) ; n ; n = ysspFNext(n) )
  {
    dn = (yeevdn*)n;
    if( yeevEvaluateList( dn->quals_yeevdn, rec ) )
    {
      qualified = TRUE;
      md = yeevManyDestGet( cx, (yeevReceiver)n->key_ysspNode );

      /* do locally, immediately and fast? */
      if( yoLocalObj( (CORBA_Object)n->key_ysspNode, &dummy ) )
      {
#ifdef NEVER
	/* 195 "yeevSend: local" */
	ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)195, YSLSEV_DEBUG(8), (char*)0,
		 YSLNONE);
#endif
	/* stats in stub */
	yeevReceiver_push((yeevReceiver)n->key_ysspNode, &cx->env_yeevcx, rec);
      }
      else			/* consider async to remote */
      {
	/* consider global limit state */
	if( !cx->limited_yeevcx && (cx->noe_yeevcx > cx->globLimit_yeevcx) )
	{
	  if( !cx->doDrop_yeevcx )
	  {
	    while( cx->noe_yeevcx > cx->globRestart_yeevcx )
	      ysYield();
	  }
	  else
	  {
	    cx->info_yeevcx.nlimits_yeevInfo++; /* global count */
	    cx->limited_yeevcx = TRUE;

	    /* 200, "yeevSend: global limit start, %d outstanding" */
	    ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)200, YSLSEV_ERR, (char*)0,
		     YSLSB4(cx->globLimit_yeevcx), YSLEND );
	  }
	}
	if( cx->limited_yeevcx )
	{
	  cx->ndropped_yeevcx++; /* this limit count */
	  cx->info_yeevcx.ndropped_yeevInfo++; /* global count */
	  break;
	}

	if( !md->dead_yeevmd )	/* queue many or start the send */
	{
	  cx->noe_yeevcx++;
	  md->noe_yeevmd++;
	  if( md->recs_yeevmd )
	  {
#ifdef NEVER
	    /* 201, "yeevSend: batched" */
	    ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)201, YSLSEV_DEBUG(8), (char*)0,
		     YSLEND);
#endif
	    /* enq rec for this dest; must deep copy now; this is
	       incredibly expensive, but unavoidable, sigh. */
	    srec = (yeevr*)ysmGlbAlloc( sizeof(*srec), "yeevr" );
	    yeevr__copy( srec, rec, yotkAllocStr );
	    DISCARD ysLstEnq( md->recs_yeevmd, (dvoid*)srec );

	    /* start batches that are > 1/4 the limit */
	    if(ysLstCount( md->recs_yeevmd ) > (cx->globLimit_yeevcx/4) )
	    {
	      yeevManyDestSend( cx, md );
	      md->recs_yeevmd = ysLstCreate();
	    }
	  }
	  else			/* send now */
	  {
#ifdef NEVER
	    /* 202, "yeevSend: sent" */
	    ysRecord(YS_PRODUCT, YEEV_FAC, 202, YSLSEV_DEBUG(8), (char*)0,
		     YSLNONE);
#endif
	    /* send stats */
	    cx->info_yeevcx.npush_yeevInfo++;
	    md->noi_yeevmd++;
	    oe = (yeevoe*)ysmGlbAlloc(sizeof(*oe), yeevoe_tag );
	    oe->md_yeevoe = md;
	    oe->cx_yeevoe = cx;
	    oe->noe_yeevoe = 1;
	    yoEnvInit( &oe->env_yeevoe );

	    evt = ysEvtSimple( yeevComplete, (dvoid*)oe );
	    yeevReceiver_push_nw( (yeevReceiver)md->node_yeevmd.key_ysspNode,
				 &oe->env_yeevoe, rec, evt );
	  }
	}
      }
    }
  }
  cx->inSend_yeevcx--;
  return( qualified );
}


/* ARGSUSED */
STATICF void yeevDummy(dvoid *usrp, CONST ysid *exid,
			  dvoid *arg, size_t argsz)
{
  /* nothing */
}


/* ---------------------------- yeevComplete ---------------------------- */
/*
  NAME
    yeevComplete
  DESCRIPTION
    Completion routine for an event push that was started asyncronously.
    Recoup resources, and handle i/o limit counts.
  PARAMETERS
    usrp    -- the yeevoe of the operation
    exid    -- the system supplied exception
    arg	    -- ignored
    argsz   -- ignored.
  RETURNS
    none
*/
/* ARGSUSED */
STATICF void yeevComplete(dvoid *usrp, CONST ysid *exid,
			  dvoid *arg, size_t argsz)
{
  yeevoe *oe = (yeevoe*)usrp;
  yeevmd *md;
  yeevcx *cx;
  sb4	dropped;

  /*CONSTCOND*/
  ysmCheck( usrp, yeevoe_tag );
  md = oe->md_yeevoe;
  cx = oe->cx_yeevoe;

  cx->noe_yeevcx -= oe->noe_yeevoe;
  md->noe_yeevmd -= oe->noe_yeevoe;
  md->noi_yeevmd--;

  yoEnvFree( &oe->env_yeevoe );

  if( cx->limited_yeevcx && (cx->noe_yeevcx < cx->globRestart_yeevcx) )
  {
    dropped = cx->ndropped_yeevcx;
    cx->limited_yeevcx = FALSE;
    cx->ndropped_yeevcx = 0;

    /* 205, "yeevComplete: global limit over, dropped %d events" */
    ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)205, YSLSEV_ERR, (char*)0,
	     YSLSB4(dropped), YSLEND );
  }

  if( exid )
  {
#ifdef NEVER
    /* 206, "yeevComplete: exid %s on completion to md %s" */
    ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)206, YSLSEV_DEBUG(0), (char*)0,
	     YSLSTR(ysidToStr(exid)), YSLPTR(md), YSLEND );
#endif
    /* badDest does ManyDestFree if needed */
    yeevBadDest( cx, md );
  }
  else if( md->dead_yeevmd && !md->noi_yeevmd )
  {
    yeevManyDestFree( cx, oe->md_yeevoe );
  }

  /* if in shutdown wait and time to wake up, trigger */
  if( !cx->noe_yeevcx && cx->dsem_yeevcx )
    ysTrigger( cx->dsem_yeevcx, (ysid*)0, (dvoid*)0, (size_t)0 );

  ysmGlbFree( usrp );
}



/* ---------------------------- yeevManyDestGet ---------------------------- */
/*
  NAME
    yeevManyDestGet
  DESCRIPTION
    Locate a ManyDest node, creating it if needed.
  PARAMETERS
    cx	    -- context for tree
    r	    -- receiver to look up.
  RETURNS
    pointer to yeevmd structure.
*/

STATICF yeevmd* yeevManyDestGet( yeevcx *cx, yeevReceiver r )
{
  ysspNode *n;
  yeevmd *md;

  if( (n = ysspLookup((dvoid*)r, &cx->dests_yeevcx )) )
  {
    md = (yeevmd*)n;
  }
  else
  {
    md = (yeevmd*)ysmGlbAlloc(sizeof(*md), "yeevmd");
    md->node_yeevmd.key_ysspNode = yoDuplicate((dvoid*)r);
    md->recs_yeevmd = (yslst*)0;
    md->noe_yeevmd = 0;
    md->noi_yeevmd = 0;
    md->dead_yeevmd = FALSE;
    DISCARD ysspEnq( &md->node_yeevmd, &cx->dests_yeevcx );
  }
  return( md );
}

/* -------------------------- yeevManyDestFree --------------------------- */
/*
  NAME
    yeevManyDestFree
  DESCRIPTION
    Release a many dest structure (for shutdown mostly).
  PARAMETERS
    cx	    -- our context
    md	    -- the manyDest to release.
  RETURNS
    none
*/

STATICF void yeevManyDestFree( yeevcx *cx, yeevmd *md )
{
  if( md->noi_yeevmd || (md->recs_yeevmd && ysLstCount(md->recs_yeevmd)) )
  {
    if( !md->dead_yeevmd )	/* if not already dead */
      yeevManyDestSend( cx, md ); /* start remaining send */
    md->dead_yeevmd = TRUE;	/* no more allowed */
  }

  /* don't delete until 0 noi */
  if( !md->noi_yeevmd )
  {
    ysspRemove( &md->node_yeevmd, &cx->dests_yeevcx );
    /* FIXME-- should release here? */
    ysmGlbFree( (dvoid*)md );
  }
}


/* -------------------------- yeevManyDestBatch --------------------------- */
/*
  NAME
    yeevManyDestBatch
  DESCRIPTION
    Commence batching for a many dest.  Nothing will be send until someone
    does a yeevManyDestSend().
  PARAMETERS
    md	    -- many dest to mark
  RETURNS
    none
*/

STATICF void yeevManyDestBatch( yeevmd *md )
{
  if( !md->recs_yeevmd )
    md->recs_yeevmd = ysLstCreate();
}

/* -------------------------- yeevManyDestSend ---------------------------- */
/*
  NAME
    yeevManyDestSend
  DESCRIPTION
    Send any/all records batched up for the destination.
  PARAMETERS
    cx	    -- our context.
    md	    -- the destination.  [IN/OUT]
  RETURNS
    none
*/

STATICF void yeevManyDestSend( yeevcx *cx, yeevmd *md )
{
  yeevrList recs;
  ub4 i;
  yeevr *rec;
  yeevoe *oe;
  ysevt *evt;

  if( !md->recs_yeevmd )
    return;

  recs._length = recs._maximum = ysLstCount(md->recs_yeevmd);
  if( recs._length )
  {
    recs._buffer = (yeevr*)ysmGlbAlloc(sizeof(yeevr) * (size_t)recs._maximum,
				       "yeevrList");

    /* roll all the queued events into one sequence */
    for( i = 0 ; i < recs._maximum ; i++ )
    {
      rec = (yeevr*)ysLstDeq( md->recs_yeevmd );
      DISCARD memcpy( (dvoid*)&recs._buffer[i], (dvoid*)rec, sizeof(yeevr));

      /* toss rec wrapper */
      ysmGlbFree( (dvoid*)rec );
    }

    /* now send the sequence, async */

    cx->info_yeevcx.npushm_yeevInfo++;

    oe = (yeevoe*)ysmGlbAlloc(sizeof(*oe), yeevoe_tag );
    oe->cx_yeevoe = cx;
    oe->md_yeevoe = md;
    oe->noe_yeevoe = (sb4)i;
    md->noi_yeevmd++;
    yoEnvInit( &oe->env_yeevoe );

    evt = ysEvtSimple( yeevComplete, (dvoid*)oe );
    yeevReceiver_pushMany_nw( (yeevReceiver)md->node_yeevmd.key_ysspNode,
			     &oe->env_yeevoe, &recs, evt );

    /* now free rec contents; they've been marshalled */
    yeevrList__free( &recs, yotkFreeStr );
  }
  ysLstDestroy( md->recs_yeevmd, (ysmff)0 );
  md->recs_yeevmd = (yslst*)0;
}


STATICF void yeevAllBatch( yeevcx *cx )
{
  ysspNode *n;

  /* 210, "yeevAllBatch" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)210, YSLSEV_DEBUG(8), (char*)0, YSLNONE);

  for( n = ysspFHead( &cx->dests_yeevcx ) ; n ; n = ysspFNext( n ) )
    yeevManyDestBatch( (yeevmd*)n );
}


STATICF void yeevAllSend( yeevcx *cx )
{
  ysspNode *n;

  /* 211, "yeevAllSend" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)211, YSLSEV_DEBUG(8), (char*)0, YSLNONE);

  for( n = ysspFHead( &cx->dests_yeevcx ) ; n ; n = ysspFNext( n ) )
    yeevManyDestSend( cx, (yeevmd*)n );
}


STATICF dvoid *yeevFESb8Parse( CONST char *str )
{
  sysb8	*rv = (sysb8*)ysmGlbAlloc( sizeof(*rv), "yeevFEsb8" );

  DISCARD sysb8fromstr( rv, str );
  return (dvoid*)rv;
}


STATICF sword yeevFESb8Cmp( CONST dvoid *a, CONST dvoid*b )
{
  sword rv;

  if( sysb8cmp( (sysb8*)a, <, (sysb8*)b ) )
    rv = -1;
  else if( sysb8cmp( (sysb8*)a, ==, (sysb8*)b ) )
    rv = 0;
  else rv = 1;
  
  return rv;
}


/* ARGSUSED */
STATICF void yeevDestDeath( dvoid *usrp, CONST ysid *exid,
			   dvoid *arg, size_t argsz )
{
#ifdef NEVER
  yeevmd *dest = (yeevmd*)usrp;

  /* This causes problems -- FIXME */

  yeevBadDest( dest->cx_yeevmd, dest );
#endif
}

/* ---------------------------------------------------------------- */
/* Object Methods */
/* ---------------------------------------------------------------- */


/* ARGSUSED */
void yeevDiscList_destroy_i( yeevDiscList or, yoenv* ev)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevdlx   *dl = (yeevdlx*)yoGetState((dvoid*)or);

  /* 212, "yeevDiscList_destroy_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)212, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND );

  DISCARD ysLstRem( cx->dls_yeevcx, dl->le_yeevdlx );
  yeevFreeDiscList( yoGetState((dvoid*)or ) );
}

void yeevDiscList_replace_i( yeevDiscList or, yoenv* ev, yeevdSeq* newSeq)
{
  yeevdlx *dl = (yeevdlx*)yoGetState((dvoid*)or);

  /* 213, "yeevDiscList_replace_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)213, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND );

  /* get rid of all current filters for all dests*/
  yeevFreeDiscEnts( (dvoid*)dl );

  /* add stuff from new list */
  yeevDiscList_append_i( or, ev, newSeq );
}

/* ARGSUSED */
void yeevDiscList_append_i( yeevDiscList or, yoenv* ev,
				   yeevdSeq* ds)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevdlx *dl = (yeevdlx*)yoGetState((dvoid*)or);
  ub4 i;

  /* 214, "yeevDiscList_append_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)214, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND );

  for( i = 0; i < ds->_length ; i++ )
    yeevAddToDestList( cx,
		      yeevDestList( dl, ds->_buffer[i].dest_yeevd ),
		      &ds->_buffer[i] );
}

/* ARGSUSED */
void yeevDiscList_remove_i( yeevDiscList or, yoenv* ev, yeevd* evd)
{
  yeevdlx *dl = (yeevdlx*)yoGetState((dvoid*)or);
  ysle *e, *next;
  yeevdn *dn;
  yeevdx *dx;

  /* 215, "yeevDiscList_delete_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)215, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND );

  dn = yeevDestList( dl, evd->dest_yeevd );
  for( e = ysLstHead( dn->quals_yeevdn ) ; e ; e = next )
  {
    next = ysLstNext( e );
    dx = (yeevdx*)ysLstVal(e);
    if( !yeuSafeStrcmp( dx->qual_yeevdx.qual_yeevd, evd->qual_yeevd ) )
    {
      DISCARD ysLstRem( dn->quals_yeevdn, dx->le_yeevdx );
      yeevFreeQual( (dvoid*)dx );
    }
  }
}

/* ARGSUSED */
void yeevDiscList_listDest_i( yeevDiscList or, yoenv* ev,
			       yeevReceiver dest, yeevdSeq* ds)
{
  yeevdlx   *dl = (yeevdlx*)yoGetState((dvoid*)or);
  ysspNode  *n;
  yeevdn    *dn;
  yeevdx    *dx;
  ysle	    *e = (ysle*)0;
  ub4	    i;

  /* 216, "yeevDiscList_listDest_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)216, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND);

  ds->_maximum = yeevNQual( dl );
  ds->_buffer = (yeevd*)yoAlloc(sizeof(yeevd) * (size_t)ds->_maximum );
  i = 0;

  if( (n = ysspLookup( (dvoid*)dest, &dl->dests_yeevdlx ) ) )
  {
    dn = (yeevdn*)n;
    for( e = ysLstHead( dn->quals_yeevdn ) ; e ; e = ysLstNext( e ) )
    {
      dx = (yeevdx*)ysLstVal(e);
      yeevd__copy( &ds->_buffer[i], &dx->qual_yeevdx, yoAlloc );
      i++;
    }
  }
  ds->_length = i;
}


/* ARGSUSED */
void yeevDiscList_replaceDest_i( yeevDiscList or, yoenv* ev,
			       yeevdSeq* ds)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevdlx   *dl = (yeevdlx*)yoGetState((dvoid*)or);
  yeevdn    *dn;
  sb4	    i;
  yeevReceiver dest;

  /* 217, "yeevDiscList_replaceDest_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)217, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND );

  /* verify same dest */
  dest = (yeevReceiver)0;
  for( i = 0; i < ds->_length ; i++ )
    if( dest && !yoIsEq( (dvoid*)dest, (dvoid*)ds->_buffer[i].dest_yeevd ) )
      yseThrow( EX_YEEV_NOT_SAME_DEST );
    else
      dest = ds->_buffer[i].dest_yeevd;

  if( (dn = (yeevdn*)ysspLookup( (dvoid*)dest, &dl->dests_yeevdlx ) ) )
    yeevFreeDestQuals( dn );
  else
    dn = yeevDestList( dl, dest );

  for( i = 0; i < ds->_length ; i++ )
    yeevAddToDestList( cx, dn, &ds->_buffer[i] );
}

/* ARGSUSED */
void yeevDiscList_destroyDest_i( yeevDiscList or, yoenv* ev,
			       yeevReceiver dest)
{
  yeevdlx   *dl = (yeevdlx*)yoGetState((dvoid*)or);
  yeevdn    *dn;

  /* 245, "yeevDiscList_destroyDest:  or %s, dest %s"  */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)245, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLPTR(dest), YSLEND );

  if( (dn = (yeevdn*)ysspLookup( (dvoid*)dest, &dl->dests_yeevdlx ) ) )
    yeevFreeDestQuals( dn );
}


/* ARGSUSED */
yeevdSeq yeevDiscList__get_dlist_i( yeevDiscList or, yoenv* ev)
{
  yeevdlx   *dl = (yeevdlx*)yoGetState((dvoid*)or);
  yeevdSeq  rv;
  ysspNode  *n;
  yeevdn    *dn;
  yeevdx    *dx;
  ysle	    *e = (ysle*)0;
  ub4 i;

  /* 218, "yeevDiscList__get_dlist_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)218, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND );

  rv._maximum = yeevNQual( dl );
  rv._buffer = (yeevd*)yoAlloc(sizeof(yeevd) * (size_t)rv._maximum );
  i = 0;
  for( n = ysspFHead( &dl->dests_yeevdlx ) ; n ; n = ysspFNext(n) )
  {
    dn = (yeevdn*)n;
    for( e = ysLstHead( dn->quals_yeevdn ) ; e ; e = ysLstNext( e ) )
    {
      dx = (yeevdx*)ysLstVal(e);
      yeevd__copy( &rv._buffer[i], &dx->qual_yeevdx, yoAlloc );
      i++;
    }
  }
  rv._length = i;
  return(rv);
}

/* ARGSUSED */
ub4 yeevDiscList__get_numEntries_i( yeevDiscList or, yoenv* ev)
{
  yeevdlx   *dl = (yeevdlx*)yoGetState((dvoid*)or);

  /* 219, "yeevDiscList__get_numEntries_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)219, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLEND );

  return( yeevNQual( dl ) );
}


/* ---------------------------------------------------------------- */

/* ARGSUSED */
void yeevReceiver_destroy_i( yeevReceiver or, yoenv* ev)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevrx *rcv = (yeevrx*)yoGetState((dvoid*)or);

  /* 220, "yeevReceiver_destroy_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)220, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND );

  DISCARD ysLstRem( cx->rcvs_yeevcx, rcv->le_yeevrx );
  yeevFreeReceiver( (dvoid*)rcv );
}


/* this is the receiver side being fed by the event generator */
/* ARGSUSED */
void yeevReceiver_push_i( yeevReceiver or, yoenv* ev, yeevr* rec)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevrx *rcv = (yeevrx*)yoGetState((dvoid*)or);
  yeevr	*qr;

  cx->info_yeevcx.npush_yeevInfo++;

  /* 221, "yeevReceiver_push_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)221, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLEND );

  /* if handled, drive immediately with no copy */
  if( rcv->hndlr_yeevrx )
  {
    (*rcv->hndlr_yeevrx)( rec, rcv->usrp_yeevrx );
  }
  else				/* queue up a copy */
  {
    qr = (yeevr*)ysmGlbAlloc( sizeof(*qr), yeevr_tag );
    yeevr__copy( qr, rec, yotkAllocStr );
    DISCARD ysLstEnq( rcv->q_yeevrx, (dvoid*)qr );
    if( ysLstCount( rcv->evq_yeevrx ) )
      ysTrigger( (ysevt*)ysLstDeq( rcv->evq_yeevrx ), (ysid*)0,
		(dvoid*)0, (size_t)0);
  }
}

void yeevReceiver_pushMany_i( yeevReceiver or, yoenv* ev,
			      yeevrList* recs)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  ub4 i;

  cx->info_yeevcx.npushm_yeevInfo++;

  /* 222, "yeevReceiver_pushMany_i %s (%d)" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)222, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLSB4(recs->_length), YSLEND );

  for( i = 0 ; i < recs->_length ; i++ )
    yeevReceiver_push_i( or, ev, &recs->_buffer[i] );
}

/* this is the receiver side! */
/* ARGSUSED */
void yeevReceiver_pull_i( yeevReceiver or, yoenv* ev, yeevr* rec)
{
  yeevcx *cx = (yeevcx*)yoGetState((dvoid*)or);
  yeevrx *rcv = (yeevrx*)yoGetImplState((dvoid*)or);
  yeevr *qr;
  ysevt	*evt;
  boolean got = FALSE;

  /* 223, "yeevReceiver_pull_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)223, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLEND );

  cx->info_yeevcx.npull_yeevInfo++;

  while( !got )
  {
    if( ysLstCount( rcv->q_yeevrx ) )
    {
      /* pull off the queued record */
      qr = (yeevr*)ysLstDeq( rcv->q_yeevrx );
      yeevr__copy( rec, qr, yoAlloc );
      ysmGlbFree( (dvoid*)qr );
      got = TRUE;
    }
    else			/* nothing here; need to wait. */
    {
      evt = ysSemCreate( (dvoid*)rcv );
      DISCARD ysLstEnq( rcv->evq_yeevrx, (dvoid*)evt );
      ysSemWait( evt );
    }
  }
}

void yeevReceiver_pullMany_i( yeevReceiver or, yoenv* ev,
			     yeevrList* recs)
{
  yeevrx *rcv = (yeevrx*)yoGetImplState((dvoid*)or);

  /* 224, "yeevReceiver_pullMany_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)224, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLEND );

  recs->_maximum = ysLstCount( rcv->q_yeevrx );

  /* get at least one */
  if( !recs->_maximum )
    recs->_maximum = 1;

  recs->_buffer = (yeevr*)yoAlloc( (size_t)recs->_maximum * sizeof(yeevr) );
  recs->_length = 0;

  while( ysLstCount( rcv->q_yeevrx ) && recs->_length < recs->_maximum )
    yeevReceiver_pull_i( or, ev, &recs->_buffer[ recs->_length++ ] );
}

/* This is the receiver side! */
/* ARGSUSED */
boolean yeevReceiver_tryPull_i( yeevReceiver or, yoenv* ev,
				      yeevr* rec)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevrx *rcv = (yeevrx*)yoGetState((dvoid*)or);
  yeevr *qr;

  /* 225, "yeevReceiver_tryPull_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)225, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLEND );

  cx->info_yeevcx.ntpull_yeevInfo++;
  if( ysLstCount( rcv->q_yeevrx ) )
  {
    qr = (yeevr*)ysLstDeq( rcv->q_yeevrx );
    yeevr__copy( rec, qr, yoAlloc );
    yeevr__free( qr, yotkFreeStr );
    ysmGlbFree( (dvoid*)qr );
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}


boolean yeevReceiver_tryPullMany_i( yeevReceiver or, yoenv* ev,
				   yeevrList* recs)
{
  yeevrx *rcv = (yeevrx*)yoGetImplState((dvoid*)or);

  /* 226, "yeevReceiver_tryPullMany_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)226, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLEND );

  recs->_maximum = ysLstCount( rcv->q_yeevrx );
  recs->_buffer = (yeevr*)yoAlloc( (size_t)recs->_maximum * sizeof(yeevr) );
  recs->_length = 0;

  while( ysLstCount( rcv->q_yeevrx ) && recs->_length < recs->_maximum )
    yeevReceiver_pull_i( or, ev, &recs->_buffer[ recs->_length++ ] );

  return( recs->_length != 0 );
}

/* ARGSUSED */
char* yeevReceiver__get_name_i( yeevReceiver or, yoenv* ev)
{
  char *rv;
  yeevrx *rcv = (yeevrx*)yoGetState((dvoid*)or);

  /* 227, "yeevReceiver__get_name_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)227, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLEND );

  rv = ysStrDupWaf(rcv->name_yeevrx, yoAlloc );
  return( rv );
}


/* ---------------------------------------------------------------- */

/* ARGSUSED */
yeevReceiver yeev_createReceiver_i( yeev or, yoenv* ev, char *name )
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevrx *rcv;

  /* 228, "yeev_createReceiver_i %s %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)228, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLSTR(name), YSLEND );

  rcv = (yeevrx*)ysmGlbAlloc(sizeof(*rcv), yeevch_tag );
  rcv->self_yeevrx =
    (yeevReceiver )yoCreate( yeevReceiver__id, (char*)0,
			    (yoRefData*)0, (char*)0, (dvoid*)rcv );
  rcv->name_yeevrx = ysStrDup( name );
  rcv->hndlr_yeevrx = (yeevHndlr)0;
  rcv->q_yeevrx = ysLstCreate();
  rcv->evq_yeevrx = ysLstCreate();
  rcv->le_yeevrx = ysLstEnq( cx->rcvs_yeevcx, (dvoid*)rcv );

  /* 229, "yeev_createReceiver_i: ref %s rcv %s name %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)229, YSLSEV_DEBUG(0), (char*)0, 
	   YSLPTR(rcv->self_yeevrx), YSLPTR(rcv), YSLSTR(name), YSLEND );

  return( (yeevReceiver)yoDuplicate((dvoid*)rcv->self_yeevrx) );
}

/* ARGSUSED */
yeevDiscList yeev_createDiscList_i( yeev or, yoenv* ev,
					    yeevdSeq* dlist)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevdlx   *dl;
  ub4	i;

  /* 230, "yeev_createDiscList_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)230, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND );

  dl = (yeevdlx*)ysmGlbAlloc(sizeof(*dl), yeevdlx_tag );
  CLRSTRUCT(*dl);
  dl->self_yeevdlx =
    (yeevDiscList )yoCreate( yeevDiscList__id, (char*)0,
			     (yoRefData*)0, (char*)0, (dvoid*)dl );
  dl->le_yeevdlx = ysLstEnq( cx->dls_yeevcx, (dvoid*)dl);
  DISCARD ysspNewTree( &dl->dests_yeevdlx, yoCmp );

  for( i = 0; i < dlist->_length ; i++ )
    yeevAddToDestList( cx, yeevDestList( dl, dlist->_buffer[i].dest_yeevd ),
		      &dlist->_buffer[i] );

  /* 231, "yeev_createDiscList_i: ref %s, dl %s with %d quals" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)231, YSLSEV_DEBUG(0), (char*)0,
	   YSLPTR(dl->self_yeevdlx), YSLPTR(dl), YSLSB4(dlist->_length),
	   YSLEND);

  return( (yeevDiscList)yoDuplicate((dvoid*)dl->self_yeevdlx) );
}

/* ARGSUSED */
void yeev_raise_i( yeev or, yoenv* ev, yeevr* rec)
{
  yeevcx    *cx = (yeevcx*)yoGetImplState((dvoid*)or);

  /* 232, "yeev_raise_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)232, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND);

  ++cx->info_yeevcx.nevent_yeevInfo;

  rec->orig_yeevr = or;
  ysClock((sysb8*)&rec->origtime_yeevr);
  rec->orighost_yeevr = cx->info_yeevcx.host_yeevInfo;
  rec->origpid_yeevr = cx->info_yeevcx.pid_yeevInfo;
  rec->origaff_yeevr = cx->info_yeevcx.affinity_yeevInfo;
  rec->origprog_yeevr = cx->info_yeevcx.prog_yeevInfo;
  rec->forw_yeevr = (yeev)or;
  rec->hops_yeevr = 0;

  DISCARD yeevSend( cx, rec );
}


/* ARGSUSED */
void yeev_raiseMany_i( yeev or, yoenv* ev, yeevrList* recs)
{
  yeevcx    *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  ub4 i;
  yeevr	*rec;
  sysb8 now;

  /* 233, "yeev_raiseMany_i %s - %d events" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)233, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLSB4(recs->_length), YSLEND);

  ysClock(&now);
  yeevAllBatch( cx );
  for( i = 0; i < recs->_length ; i++ )
  {
    rec = &recs->_buffer[i];

    rec->orig_yeevr = or;
    rec->origtime_yeevr = now;
    rec->origseq_yeevr = ++cx->info_yeevcx.nevent_yeevInfo;
    rec->orighost_yeevr = cx->info_yeevcx.host_yeevInfo;
    rec->origpid_yeevr = cx->info_yeevcx.pid_yeevInfo;
    rec->origaff_yeevr = cx->info_yeevcx.affinity_yeevInfo;
    rec->origprog_yeevr = cx->info_yeevcx.prog_yeevInfo;
    rec->forw_yeevr = (yeev)or;
    rec->hops_yeevr = 0;

    DISCARD yeevSend( cx, rec );
  }
  yeevAllSend( cx );
}


/* ARGSUSED */
void yeev_forward_i( yeev or, yoenv* ev, yeevr* rec)
{
  yeevcx    *cx = (yeevcx*)yoGetImplState((dvoid*)or);

  /* 234, "yeev_forward_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)234, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND);

  rec->forw_yeevr = or;
  rec->hops_yeevr++;

  /* orighost/pid/aff/prog not touched here */

  /* ignore non-qualify here. */
  DISCARD yeevSend( cx, rec );
}


/* ARGSUSED */
yeevInfo yeev__get_info_i( yeev or, yoenv* ev)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevInfo oinfo;

  /* 235, "yeev__get_info_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)235, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLEND);

  yeevInfo__copy( &oinfo, &cx->info_yeevcx, yoAlloc );
  return oinfo;
}

/* ARGSUSED */
yeevReceiverList yeev__get_receivers_i( yeev or, yoenv* ev)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevReceiverList l;
  ysle	*e;

  /* 236, "yeev__get_receivers_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)236, YSLSEV_DEBUG(8), (char*)0, 
	   YSLPTR(or), YSLEND);

  l._length = 0;
  l._maximum = ysLstCount( cx->rcvs_yeevcx );
  l._buffer =
    (yeevReceiver*)yoAlloc( (size_t)l._maximum * sizeof(l._buffer[0] ));

  for( e = ysLstHead( cx->rcvs_yeevcx ); e ; e =ysLstNext(e) )
    l._buffer[ l._length++ ] =
      (yeevReceiver)yoDuplicate((dvoid*)((yeevrx*)ysLstVal( e ))->self_yeevrx);

  return(l);
}


/* ARGSUSED */
yeevDiscList yeev__get_filters_i( yeev or, yoenv* ev)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  yeevDiscList rv;

  /* 237, "yeev__get_filters_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)237, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND);

  yeevDiscList__copy( &rv, &cx->filters_yeevcx, yoAlloc );
  return( rv );
}

/* sets list to List OR. */
/* ARGSUSED */
void yeev__set_filters_i( yeev or, yoenv* ev, yeevDiscList val)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);

  /* 238, "yeev__set_filters_i %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)238, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLEND);

  if( cx->filters_yeevcx )
    yoRelease( (dvoid*)cx->filters_yeevcx );
  cx->filters_yeevcx = (yeevDiscList)yoDuplicate((dvoid*)val);
  cx->fcx_yeevcx = (yeevdlx*)yoGetState((dvoid*)val);
}

/* ARGSUSED */
boolean yeev__get_limit_drop_i( yeev or, yoenv* ev)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);

  /* 243, "yeev__get_limit_drop_i %s, is %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)243, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLSTR(cx->doDrop_yeevcx ? "TRUE" : "FALSE"),
	   YSLEND);

  return(cx->doDrop_yeevcx);
}


/* ARGSUSED */
void yeev__set_limit_drop_i( yeev or, yoenv* ev, boolean val)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);

  /* 244, "yeev__set_limit_drop_i %s, new %s" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)244, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLSTR(val ? "TRUE" : "FALSE"), YSLEND);

  cx->doDrop_yeevcx = val;
}

/* ARGSUSED */
ub4 yeev__get_globalEventHighWater_i( yeev or, yoenv* ev)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);

  /* 239, "yeev__get_globalEventHighWater_i %s, is %d" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)239, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLUB4(cx->globLimit_yeevcx), YSLEND);

  return( cx->globLimit_yeevcx );
}

/* ARGSUSED */
void yeev__set_globalEventHighWater_i( yeev or, yoenv* ev, ub4 val)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);
  /* 240, "yeev__set_globalEventHighWater_i %s, new %d" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)240, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLUB4(val), YSLEND);

  cx->globLimit_yeevcx = val;
}

/* ARGSUSED */
ub4 yeev__get_globalEventRestart_i( yeev or, yoenv* ev)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);

  /* 241, "yeev__get_globalEventRestart_i %s, is %d" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)241, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLUB4(cx->globRestart_yeevcx), YSLEND);

  return( cx->globRestart_yeevcx );
}

/* ARGSUSED */
void yeev__set_globalEventRestart_i( yeev or, yoenv* ev, ub4 val)
{
  yeevcx *cx = (yeevcx*)yoGetImplState((dvoid*)or);

  /* 242, "yeev__set_globalEventRestart_i %s, new %d" */
  ysRecord(YS_PRODUCT, YEEV_FAC, (ub4)242, YSLSEV_DEBUG(8), (char*)0,
	   YSLPTR(or), YSLUB4(val), YSLEND);

  cx->globRestart_yeevcx = val;
}


