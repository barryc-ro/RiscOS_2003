/* Copyright (c) 1995 by Oracle Corporation.  All Rights Reserved.
 *
 * ycprfree.c - Free up parser AST's
 *
 * NOTES
 * The functions in this file walk the AST's generated by the parser and
 * free their contents. These functions must stay in sync with the 
 * declarations in ycotre.h.
 *
 * Note that you cannot assume non-null pointers inside the trees for
 * things which logically cannot be null because a syntax error may 
 * leave you with a partially constructed tree. For example, a tree for
 * a struct which has a null member list.
 *
 * HISTORY
 * 07/04/96 kcoleman	Support for context ids
 * 04/16/96 kcoleman	Support for the new IAO server code gen pragmas
 * 12/22/95 kcoleman	Creation
 */
 
#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YC_ORACLE
#include <yc.h>
#endif
 

/*
 * These #define's mirror what is in ycotre.h
 */
#define ycfConstExp ycfOrExpr
#define ycfPositiveIntConst ycfConstExp
#define ycfComplexDeclarator ycfArrayDeclarator

/* Local function prototypes */
STATICF void ycfDefinition( yctDefinition* defn);
STATICF void ycfTypeDcl( yctTypeDcl* dcl);
STATICF void ycfConstDcl( yctConstDcl* dcl);
STATICF void ycfExceptDcl( yctExceptDcl* dcl);
STATICF void ycfInterface( yctInterface* dcl);
STATICF void ycfModule( yctModule* dcl);
STATICF void ycfInterfaceDcl( yctInterfaceDcl* dcl);
STATICF void ycfForwardDcl( yctForwardDcl* dcl);
STATICF void ycfInterfaceHeader( yctInterfaceHeader* dcl);
STATICF void ycfExport( yctExport* dcl);
STATICF void ycfInheritanceSpec( yctInheritanceSpec* dcl);
STATICF void ycfScopedName( yctScopedName* dcl);
STATICF void ycfConstType( yctConstType* dcl);
STATICF void ycfOrExpr( yctOrExpr* dcl);
STATICF void ycfXorExpr( yctXorExpr* dcl);
STATICF void ycfAndExpr( yctAndExpr* dcl);
STATICF void ycfShiftExpr( yctShiftExpr* dcl);
STATICF void ycfAddExpr( yctAddExpr* dcl);
STATICF void ycfMultExpr( yctMultExpr* dcl);
STATICF void ycfUnaryExpr( yctUnaryExpr* dcl);
STATICF void ycfPrimaryExpr( yctPrimaryExpr* dcl);
STATICF void ycfLiteral( yctLiteral* dcl);
STATICF void ycfTypeDeclarator( yctTypeDeclarator* dcl);
STATICF void ycfTypeSpec( yctTypeSpec* dcl);
STATICF void ycfSimpleTypeSpec( yctSimpleTypeSpec* dcl);
STATICF void ycfBaseTypeSpec( yctBaseTypeSpec* dcl);
STATICF void ycfTemplateTypeSpec( yctTemplateTypeSpec* dcl);
STATICF void ycfConstrTypeSpec( yctConstrTypeSpec* dcl);
STATICF void ycfDeclarator( yctDeclarator* dcl);
STATICF void ycfStructType( yctStructType* dcl);
STATICF void ycfMember( yctMember* dcl);
STATICF void ycfUnionType( yctUnionType* dcl);
STATICF void ycfSwitchTypeSpec( yctSwitchTypeSpec* dcl);
STATICF void ycfCase( yctCase* dcl);
STATICF void ycfCaseLabel( yctCaseLabel* dcl);
STATICF void ycfElementSpec( yctElementSpec* dcl);
STATICF void ycfEnumType( yctEnumType* dcl);
STATICF void ycfSequenceType( yctSequenceType* dcl);
STATICF void ycfStringType( yctStringType* dcl);
STATICF void ycfArrayDeclarator( yctArrayDeclarator* dcl);
STATICF void ycfAttrDcl( yctAttrDcl* dcl);
STATICF void ycfOpDcl( yctOpDcl* dcl);
STATICF void ycfOpTypeSpec( yctOpTypeSpec* dcl);
STATICF void ycfParameterDcls( yctParameterDcls* dcl);
STATICF void ycfParamDcl( yctParamDcl* dcl);
STATICF void ycfRaisesExpr( yctRaisesExpr* dcl);
STATICF void ycfContextExpr( yctContextExpr* dcl);
STATICF void ycfParamTypeSpec( yctParamTypeSpec* dcl);
STATICF void ycfPragmaId( yctPragmaId* dcl);
STATICF void ycfPragmaPrefix( yctPragmaPrefix* dcl);
STATICF void ycfPragmaVersion( yctPragmaVersion* dcl);
STATICF void ycfPragma( yctPragma* dcl);
STATICF void ycfPragmaDbAttr( yctPragmaDbAttr* dcl);
STATICF void ycfPrgParKey( yctPrgParKey* dcl);
STATICF void ycfPragmaDbCreate( yctPragmaDbCreat* dcl);
STATICF void ycfPragmaDbLst( yctPragmaDbLst* dcl);


void ycfDefns( yslst* defns)
{
  yctDefinition* defn;

  if ( defns )
  {
    while ( (defn = (yctDefinition*) ysLstDeq(defns)) )
      ycfDefinition( defn);
    ysLstDestroy( defns, (ysmff)0);
  }
}

STATICF void ycfDefinition( yctDefinition* defn)
{
  if ( defn )
  {
    switch( defn->tag )
    {
      case ycttTypeDcl:
	ycfTypeDcl(MEMBER(defn, typedcl));
	break;
      case ycttConstDcl:
	ycfConstDcl( MEMBER(defn, constdcl));
	break;
      case ycttExceptDcl:
	ycfExceptDcl( MEMBER(defn, exceptdcl));
	break;
      case ycttInterface:
	ycfInterface( MEMBER(defn, interface));
	break;
      case ycttModule:
	ycfModule( MEMBER(defn, module));
	break;
      case ycttPragma:
	ycfPragma( MEMBER(defn, pragmadir));
	break;
      default:
	break;
    }
    ysmGlbFree( (dvoid*)defn);
  }
}

STATICF void ycfTypeDcl( yctTypeDcl* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttTypeDeclarator:
        ycfTypeDeclarator( MEMBER( dcl, typedecl));
        break;
      case ycttStructType:
        ycfStructType( MEMBER( dcl, structtype));
        break;
      case ycttUnionType:
        ycfUnionType( MEMBER( dcl, uniontype));
        break;
      case ycttEnumType:
        ycfEnumType( MEMBER( dcl, enumtype));
        break;
      default:
        break;
    }
    ysmGlbFree( (dvoid*)dcl);
  }
}

STATICF void ycfExceptDcl( yctExceptDcl* dcl)
{
  yctMember* mem;

  if ( dcl )
  {
    ysmGlbFree( (dvoid*) dcl->id);
    if ( dcl->members )
    {
      while ( (mem = (yctMember*) ysLstDeq( dcl->members)) )
        ycfMember( mem);
      ysLstDestroy( dcl->members, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfInterface( yctInterface* dcl)
{
  if ( dcl )
  {
    if ( dcl->tag == ycttInterfaceDcl )
      ycfInterfaceDcl( MEMBER( dcl, interfacedcl));
    else if ( dcl->tag == ycttForwardDcl )
      ycfForwardDcl( MEMBER( dcl, forwarddcl));
    ysmGlbFree( (dvoid*)dcl);
  }
}

STATICF void ycfModule( yctModule* dcl)
{
  yctDefinition* defn;

  if ( dcl )
  {
    ysmGlbFree( (dvoid*)dcl->id);
    if ( dcl->defs )
    {
      while ( (defn = (yctDefinition*) ysLstDeq(dcl->defs)) )
        ycfDefinition( defn);
      ysLstDestroy( dcl->defs, (ysmff)0);
    }
    ysmGlbFree( (dvoid*)dcl);
  }
}

STATICF void ycfInterfaceDcl( yctInterfaceDcl* dcl)
{
  yctExport* exprt;

  if ( dcl )
  {
    ycfInterfaceHeader( dcl->header);
    if ( dcl->body )
    {
      while ( (exprt = (yctExport*) ysLstDeq( dcl->body)) )
        ycfExport( exprt);
      ysLstDestroy( dcl->body, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfForwardDcl( yctForwardDcl* dcl)
{
  if ( dcl )
  {
    ysmGlbFree( (dvoid*) dcl->id);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfInterfaceHeader( yctInterfaceHeader* dcl)
{
  if ( dcl )
  {
    ysmGlbFree( (dvoid*) dcl->id);
    ycfInheritanceSpec( dcl->inheritancespec);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfExport( yctExport* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttTypeDcl:
	ycfTypeDcl(MEMBER(dcl, typedcl));
	break;
      case ycttConstDcl:
	ycfConstDcl( MEMBER(dcl, constdcl));
	break;
      case ycttExceptDcl:
	ycfExceptDcl( MEMBER(dcl, exceptdcl));
	break;
      case ycttAttrDcl:
	ycfAttrDcl( MEMBER( dcl, attrdcl));
	break;
      case ycttOpDcl:
	ycfOpDcl( MEMBER( dcl, opdcl));
	break;
      case ycttPragma:
	ycfPragma( MEMBER(dcl, pragmadir));
	break;
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfInheritanceSpec( yctInheritanceSpec* dcl)
{
  yctScopedName* name;

  if ( dcl )
  {
    if ( dcl->names )
    {
      while ( (name = ysLstDeq( dcl->names)) )
        ycfScopedName( name);
      ysLstDestroy( dcl->names, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfScopedName( yctScopedName* dcl)
{
  if ( dcl )
  {
    ycfScopedName( dcl->name);
    ysmGlbFree( (dvoid*) dcl->id);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfConstDcl( yctConstDcl* dcl)
{
  if ( dcl )
  {
    ycfConstType( dcl->type);
    ysmGlbFree( (dvoid*) dcl->id);
    ycfConstExp( dcl->exp);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfConstType( yctConstType* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttIntegerType:
	ysmGlbFree( (dvoid*) MEMBER( dcl, inttype));
	break;
      case ycttStringType:
	ycfStringType( MEMBER( dcl, stringtype));
	break;
      case ycttScopedName:
	ycfScopedName( MEMBER( dcl, name));
	break;
      case ycttCharType:
      case ycttBooleanType:
      case ycttFloatType:
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfOrExpr( yctOrExpr* dcl)
{
  if ( dcl )
  {
    ycfOrExpr( dcl->orexpr);
    ycfXorExpr( dcl->xorexpr);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfXorExpr( yctXorExpr* dcl)
{
  if ( dcl )
  {
    ycfXorExpr( dcl->xorexpr);
    ycfAndExpr( dcl->andexpr);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfAndExpr( yctAndExpr* dcl)
{
  if ( dcl )
  {
    ycfAndExpr( dcl->andexpr);
    ycfShiftExpr( dcl->shiftexpr);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfShiftExpr( yctShiftExpr* dcl)
{
  if ( dcl )
  {
    ycfShiftExpr( dcl->shiftexpr);
    ycfAddExpr( dcl->addexpr);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfAddExpr( yctAddExpr* dcl)
{
  if ( dcl )
  {
    ycfAddExpr( dcl->addexpr);
    ycfMultExpr( dcl->multexpr);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfMultExpr( yctMultExpr* dcl)
{
  if ( dcl )
  {
    ycfMultExpr( dcl->multexpr);
    ycfUnaryExpr( dcl->unaryexpr);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfUnaryExpr( yctUnaryExpr* dcl)
{
  if ( dcl )
  {
    ycfPrimaryExpr( dcl->primexpr);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfPrimaryExpr( yctPrimaryExpr* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttScopedName:
	ycfScopedName( MEMBER( dcl, name));
	break;
      case ycttLiteral:
	ycfLiteral( MEMBER( dcl, literal));
	break;
      case ycttConstExp:
	ycfConstExp( MEMBER( dcl, constexp));
	break;
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfLiteral( yctLiteral* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttNumLit:
	ysmGlbFree( (dvoid*) MEMBER( dcl, numlit));
	break;
      case ycttStrLit:
      {
        if ( MEMBER( dcl, strlit) )
	  ysLstDestroy( MEMBER( dcl, strlit), ysmFGlbFree);
	break;
      }
      case ycttCharLit:
	ysmGlbFree( (dvoid*) MEMBER( dcl, charlit));
	break;
      case ycttBoolLit:
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfTypeDeclarator( yctTypeDeclarator* dcl)
{
  yctDeclarator* decl;

  if ( dcl )
  {
    ycfTypeSpec( dcl->typespec);
    if ( dcl->declarators )
    {
      while ( (decl = ysLstDeq( dcl->declarators)) )
        ycfDeclarator( decl);
      ysLstDestroy( dcl->declarators, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfTypeSpec( yctTypeSpec* dcl)
{
  if ( dcl )
  {
    switch ( dcl->tag )
    {
      case ycttSimple:
	ycfSimpleTypeSpec( MEMBER( dcl, simple));
	break;
      case ycttConstr:
	ycfConstrTypeSpec( MEMBER( dcl, constr));
	break;
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfSimpleTypeSpec( yctSimpleTypeSpec* dcl)
{
  if ( dcl )
  {
    switch ( dcl->tag )
    {
      case ycttBase:
	ycfBaseTypeSpec( MEMBER( dcl, base));
	break;
      case ycttTemplate:
	ycfTemplateTypeSpec( MEMBER( dcl, template));
	break;
      case ycttScopedName:
	ycfScopedName( MEMBER( dcl, name));
	break;
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}


STATICF void ycfBaseTypeSpec( yctBaseTypeSpec* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttIntegerType:
	ysmGlbFree( (dvoid*) MEMBER( dcl, inttype));
	break;
      case ycttCharType:
      case ycttBooleanType:
      case ycttOctetType:
      case ycttAnyType:
      case ycttTypeCodeType:
      case ycttFloatType:
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfTemplateTypeSpec( yctTemplateTypeSpec* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttSeqType:
	ycfSequenceType( MEMBER( dcl, seqtype));
	break;
      case ycttStrType:
	ycfStringType( MEMBER( dcl, strtype));
	break;
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfConstrTypeSpec( yctConstrTypeSpec* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttStructType:
	ycfStructType( MEMBER( dcl, structtype));
	break;
      case ycttUnionType:
	ycfUnionType( MEMBER( dcl, uniontype));
	break;
      case ycttEnumType:
	ycfEnumType( MEMBER( dcl, enumtype));
	break;
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfDeclarator( yctDeclarator* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttSimple:
	ysmGlbFree( (dvoid*) MEMBER( dcl, simple));
	break;
      case ycttComplex:
	ycfComplexDeclarator( MEMBER( dcl, complex));
	break;
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfStructType( yctStructType* dcl)
{
  yctMember* mem;

  if ( dcl )
  {
    ysmGlbFree( (dvoid*) dcl->id);
    if ( dcl->members )
    {
      while ( (mem = (yctMember*) ysLstDeq( dcl->members)) )
        ycfMember( mem);
      ysLstDestroy( dcl->members, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfMember( yctMember* dcl)
{
  yctDeclarator* declr;

  if ( dcl )
  {
    ycfTypeSpec( dcl->typespec);
    if ( dcl->declarators )
    {
      while ( (declr = (yctDeclarator*) ysLstDeq( dcl->declarators)) )
        ycfDeclarator( declr);
      ysLstDestroy( dcl->declarators, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfUnionType( yctUnionType* dcl)
{
  yctCase* arm;

  if ( dcl )
  {
    ysmGlbFree( (dvoid*) dcl->id);
    ycfSwitchTypeSpec( dcl->typespec);
    if ( dcl->cases )
    {
      while ( (arm = (yctCase*) ysLstDeq( dcl->cases)) )
        ycfCase( arm);
      ysLstDestroy( dcl->cases, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfSwitchTypeSpec( yctSwitchTypeSpec* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttIntegerType:
	ysmGlbFree( (dvoid*) MEMBER( dcl, inttype));
	break;
      case ycttEnumType:
	ycfEnumType( MEMBER( dcl, enumtype));
	break;
      case ycttScopedName:
	ycfScopedName( MEMBER( dcl, name));
	break;
      case ycttBooleanType:
      case ycttCharType:
      default:
	break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfCase( yctCase* dcl)
{
  yctCaseLabel* lbl;

  if ( dcl )
  {
    if ( dcl->caselabels )
    {
      while ( (lbl = (yctCaseLabel*) ysLstDeq( dcl->caselabels)) )
        ycfCaseLabel( lbl);
      ysLstDestroy( dcl->caselabels, (ysmff)0);
    }
    ycfElementSpec( dcl->elemspec);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfCaseLabel( yctCaseLabel* dcl)
{
  if ( dcl )
  {
    ycfConstExp( dcl->constexp);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfElementSpec( yctElementSpec* dcl)
{
  if ( dcl )
  {
    ycfTypeSpec( dcl->typespec);
    ycfDeclarator( dcl->declarator);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfEnumType( yctEnumType* dcl)
{
  yctEnumerator* e;

  if ( dcl )
  {
    ysmGlbFree( (dvoid*) dcl->id);
    if ( dcl->enumerators )
    {
      while ( (e = (yctEnumerator*) ysLstDeq( dcl->enumerators)) )
      {
        /* essentially, ycfEnumerator */
        ysmGlbFree( (dvoid*) e->id);
        ysmGlbFree( (dvoid*) e);
      }
    }
    ysLstDestroy( dcl->enumerators, (ysmff)0);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfSequenceType( yctSequenceType* dcl)
{
  if ( dcl )
  {
    ycfSimpleTypeSpec( dcl->simple);
    ycfPositiveIntConst( dcl->intconst);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfStringType( yctStringType* dcl)
{
  if ( dcl )
  {
    ycfPositiveIntConst( dcl->intconst);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfArrayDeclarator( yctArrayDeclarator* dcl)
{
  yctFixedArraySize* dim;

  if ( dcl )
  {
    ysmGlbFree( (dvoid*) dcl->id);
    if ( dcl->arraysize )
    {
      while ( (dim = (yctFixedArraySize*) ysLstDeq( dcl->arraysize)) )
      {
        /* essentially, ycfFixedArraySize */
        ycfPositiveIntConst( dim->intconst);
        ysmGlbFree( (dvoid*) dim);
      }
      ysLstDestroy( dcl->arraysize, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfAttrDcl( yctAttrDcl* dcl)
{
  if ( dcl )
  {
    ycfParamTypeSpec( dcl->paramtype);
    if ( dcl->simples )
      ysLstDestroy( dcl->simples, ysmFGlbFree);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfOpDcl( yctOpDcl* dcl)
{
  if ( dcl )
  {
    ycfOpTypeSpec( dcl->optype);
    ysmGlbFree( (dvoid*) dcl->id);
    ycfParameterDcls( dcl->paramdcls);
    ycfRaisesExpr( dcl->raisesexpr);
    ycfContextExpr( dcl->contextexpr);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfOpTypeSpec( yctOpTypeSpec* dcl)
{
  if ( dcl )
  {
    ycfParamTypeSpec( dcl->paramtype);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfParameterDcls( yctParameterDcls* dcl)
{
  yctParamDcl* param;

  if ( dcl )
  {
    if ( dcl->paramdcls )
    {
      while ( (param = (yctParamDcl*) ysLstDeq( dcl->paramdcls)) )
        ycfParamDcl( param);
      ysLstDestroy( dcl->paramdcls, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfParamDcl( yctParamDcl* dcl)
{
  if ( dcl )
  {
    ycfParamTypeSpec( dcl->typespec);
    ysmGlbFree( (dvoid*) dcl->simple);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfRaisesExpr( yctRaisesExpr* dcl)
{
  yctScopedName* name;

  if ( dcl )
  {
    if ( dcl->names )
    {
      while ( (name = (yctScopedName*) ysLstDeq( dcl->names)) )
        ycfScopedName( name);
      ysLstDestroy( dcl->names, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfContextExpr( yctContextExpr* dcl)
{
  yslst* lst;

  if ( dcl )
  {
    if ( dcl->ids )
    {
      while ( (lst = (yslst*) ysLstDeq( dcl->ids)) )
      {
        ysLstDestroy( lst, ysmFGlbFree);
      }
      ysLstDestroy( dcl->ids, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfParamTypeSpec( yctParamTypeSpec* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttBase:
	ycfBaseTypeSpec( MEMBER( dcl, base));
	break;
      case ycttStringType:
	ycfStringType( MEMBER( dcl, stringtype));
	break;
      case ycttScopedName:
	ycfScopedName( MEMBER( dcl, name));
	break;
      default:
        break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfPragmaId( yctPragmaId* dcl)
{
  if ( dcl )
  {
    ycfScopedName( dcl->name);
    ysmGlbFree( (dvoid*) dcl->id);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfPragmaPrefix( yctPragmaPrefix* dcl)
{
  if ( dcl )
  {
    ysmGlbFree( (dvoid*) dcl->prefix);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfPragmaVersion( yctPragmaVersion* dcl)
{
  if ( dcl )
  {
    ycfScopedName( dcl->name);
    ysmGlbFree( (dvoid*) dcl->vers);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfPragmaDbAttr( yctPragmaDbAttr* dcl)
{
  if ( dcl )
  {
    ycfScopedName( dcl->name);
    if ( dcl->keystr )
      ysLstDestroy( dcl->keystr, ysmFGlbFree);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfPrgParKey( yctPrgParKey* dcl)
{
  if ( dcl )
  {
    if ( dcl->paramnm )
      ysmGlbFree( (dvoid*) dcl->paramnm);
    if ( dcl->keystr )
      ysLstDestroy( dcl->keystr, ysmFGlbFree);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfPragmaDbCreate( yctPragmaDbCreat* dcl)
{
  if ( dcl )
  {
    ycfScopedName( dcl->name);
    if ( dcl->mapping )
    {
      yctPrgParKey* parmap; 

      while ( (parmap = (yctPrgParKey*) ysLstDeq(dcl->mapping)) )
        ycfPrgParKey( parmap);
      ysLstDestroy( dcl->mapping, (ysmff)0);
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfPragmaDbLst( yctPragmaDbLst* dcl)
{
  if ( dcl )
  {
    ycfScopedName( dcl->name);
    ysmGlbFree( (dvoid*) dcl);
  }
}

STATICF void ycfPragma( yctPragma* dcl)
{
  if ( dcl )
  {
    switch (dcl->tag)
    {
      case ycttPragmaId:
	ycfPragmaId( MEMBER( dcl, prgid));
	break;
      case ycttPragmaPrefix:
	ycfPragmaPrefix( MEMBER( dcl, prgprefix));
	break;
      case ycttPragmaVersion:
	ycfPragmaVersion( MEMBER( dcl, prgversion));
	break;
      case ycttPragmaDbAttr:
        ycfPragmaDbAttr( MEMBER( dcl, prgdbattr));
        break;
      case ycttPragmaDbCreat:
        ycfPragmaDbCreate( MEMBER( dcl, prgdbcreate));
        break;
      case ycttPragmaDbLst:
        ycfPragmaDbLst( MEMBER( dcl, prgdblst));
        break;
      default:
        break;
    }
    ysmGlbFree( (dvoid*) dcl);
  }
}
