/* Copyright (c) Oracle Corporation 1995.  All Rights Reserved. */

/*
  NAME
    yece.c
  DESCRIPTION

    This file provides an implementation of the CORBA COSS V1 event
    chanel (yece*).

    It is completely independant with the channels in yeec.
    These object implementations  may be linked into a separable
    daemon (yeced), or into individual servers and clients.
    
     PROBLEMS:

	Consumers and Producers that blindly exit after connection
	will cause object leaks.  Short of polling them, there is
	little way to garbage collect these.

	We don't do typed pull producers or consumers.  For typed pull
	consumers we'd need to have duplicatable/savable DSI call contexts,
	which don't exist.  For typed pull suppliers we'd need to have the
	proxy do DII calls, which is too involved for now.

  PUBLIC FUNCTIONS

    yeceInit
    yeceTerm

    yece*_i functions for implementing methods, see yecevch.idl.

  PRIVATE FUNCTIONS

  NOTES

    The objects created are:

    Type	    ImplState	    ObjState

    yeceCa_Factory  cx		    n/a
    yeceCa_EventChannel		    yecech *
    yeceCa_SuppAdm  cx		    yecech *
    yeceCa_ConsAdm  cx		    yecech *

    yeceCa_ProxyPushCons	    yecepc *
    yeceCa_ProxyPullCons	    yecepc *
    yeceCa_ProxyPullSupp	    yecep *
    yeceCa_ProxyPushSupp	    yecep *

    Proxy states:

	    create                for_*                  obtain
    Factory -------> EventChannel ------> Cons/SupAdmin ---------> 
					  [disconnected]   

    obtain               connectXX		[operations]  
    ------>  ProxyXXXYYY ---------> ProxyXXXYYY ------------>ProxyXXXYYY -->
	     [discon]		    [connected]		     [connected]

    disconnect
    ----------> ProxyXXXYYY
	        [destroyed]
    
    Some Scenarios:

	Push Consumer

	    pc = yoCreate( PushConsumer, ... );
	    ec = Factory_create();  |* or from name service... *|
	    consad = EventChannel_for_consumers( ec );
	    proxysup = ConsumerAdmin_obtain_push_supp( consad );
	    ProxyPushSupplier_connect_push_cons( proxysup, pc );
	    |* stuff happens *|
	    ProxyPushSupplier_disconnect_push_supp( proxysup );

	Push Supplier

	    ps = yoCreate( PushSuplier, ... );
	    ec = Factory_create();  |* or from name service *|
	    supad = EventChannel_for_suppliers(ec);
	    proxycons = SupplierAdmin_obtain_push_cons( supad );
	    ProxyPushConsumer_connect_push_supp( proxycons, ps );

	    ProxyPushConsumer_push( proxycons, stuff... );

	    ProxyPushConsumer_disconnect_push_cons( proxycons );

        ----------------------------------------------------------------

	Pull Consumer

	    pc = yoCreate( PullConsumer, ... );
	    
	    ec = Factory_create();  |* or from name service... *|
	    consad = EventChannel_for_consumers( ec );
	    proxysup = ConsumerAdmin_obtain_pull_supp( consad );
	    ProxyPullSupplier_connect_pull_cons( proxysup, pc );
	    ...
	    data = ProxyPullSupplier_*pull( proxysup, ... );
	    ...
	    ProxyPullSupplier_disconnect_pull_supp( proxysup );

	Pull Supplier

	    ps = yoCreate( PullSupplier, ... );
	    
	    ec = Factory_create();  |* or from name service... *|
	    supsad = EventChannel_for_supplier( ec );
	    proxycons = ConsumerAdmin_obtain_pull_cons( supad );
	    ProxyPullConsumer_connect_pull_supp( proxysup, ps );

	    |* queue events internally as needed; service pull
	       requests when they are invoked from the queue. *|

	    ProxyPullConsumer_disconnnect_pull_cons( proxycons );

  MODIFIED   (MM/DD/YY)
    dbrower   10/13/95 -  created.
    dbrower   11/11/95 -  split from yece.c
    dbrower   03/ 1/96 -  olint.
    dbrower   07/12/96 -  OMN 4.0 work.
			  - convert to ysRecord messages.
			  - Duplicate some refs that need it (this is/will
			    be a bug pre-4.0).
			  - Do completion events on a queue to serialize
			    access on error.
			  - fix yoRelease leaks.
			  - deathwatch suppliers and consumers.
    dbrower   08/ 2/96 -  fix 388215, removing consumer too early.
    dbrower   01/28/97 -  fix 444759, freeing data when we don't have any.
*/

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif
#ifndef YOCOA_ORACLE
#include <yocoa.h>
#endif
#ifndef YSV_ORACLE
#include <ysv.h>
#endif
#ifndef YSL_ORACLE
#include <ysl.h>
#endif
#ifndef YSSP_ORACLE
#include <yssp.h>
#endif
#ifndef YSSTR_ORACLE
#include <ysstr.h>
#endif
#ifndef YECE_ORACLE
#include <yece.h>
#endif
#ifndef YEU_ORACLE
#include <yeu.h>
#endif
#ifndef YECEVCH_ORACLE
#include <yecevch.h>
#endif
#ifndef YECEVCHI_ORACLE
#include <yecevchI.h>
#endif
#ifndef YOTK_ORACLE
#include <yotk.h>
#endif
#ifndef YSLOG_ORACLE
#include <yslog.h>
#endif
#ifndef YEMSG_ORACLE
#include <yemsg.h>
#endif
#ifndef YEEVF_ORACLE
#include <yeevf.h>
#endif

#define YECE_FAC    "YECE"

/* PUBLIC TYPES AND CONSTANTS */

/* PRIVATE TYPES AND CONSTANTS */

typedef struct yececx yececx;	/* master context, the yece object */
typedef struct yecech yecech;	/* channel within the yece */
typedef struct yecesc yecesc;	/* typed sub-channel within the yecech */
typedef struct yecep yecep;	/* party known on a channel (proxy supp) */
typedef struct yecepc yecepc;	/* proxy consumer */

static CONST_W_PTR struct yeceCa_ProxyPushCons__tyimpl
yeceCa_ProxyPushCons__impl =
 {
  yeceCa_ProxyPushCons_connect_push_supp_i,
  yeceCa_ProxyPushCons_push_i,
  yeceCa_ProxyPushCons_disconnect_i
 };

static CONST_W_PTR struct yeceCa_ProxyPullSupp__tyimpl
yeceCa_ProxyPullSupp__impl =
 {
  yeceCa_ProxyPullSupp_connect_pull_cons_i,
  yeceCa_ProxyPullSupp_pull_i,
  yeceCa_ProxyPullSupp_try_pull_i,
  yeceCa_ProxyPullSupp_disconnect_i
 };

static CONST_W_PTR struct yeceCa_ProxyPullCons__tyimpl
yeceCa_ProxyPullCons__impl =
 {
  yeceCa_ProxyPullCons_connect_pull_supp_i,
  yeceCa_ProxyPullCons_disconnect_i
 };

static CONST_W_PTR struct yeceCa_ProxyPushSupp__tyimpl
yeceCa_ProxyPushSupp__impl =
 {
  yeceCa_ProxyPushSupp_connect_push_cons_i,
  yeceCa_ProxyPushSupp_disconnect_push_supp_i
 };

static CONST_W_PTR struct yeceCa_ConsAdm__tyimpl yeceCa_ConsAdm__impl =
 {
  yeceCa_ConsAdm_obtain_push_supp_i,
  yeceCa_ConsAdm_obtain_pull_supp_i
 };

static CONST_W_PTR struct yeceCa_SuppAdm__tyimpl yeceCa_SuppAdm__impl =
 {
  yeceCa_SuppAdm_obtain_push_cons_i,
  yeceCa_SuppAdm_obtain_pull_cons_i
 };

static CONST_W_PTR struct yeceCa_EventChannel__tyimpl
yeceCa_EventChannel__impl =
 {
  yeceCa_EventChannel_for_consumers_i,
  yeceCa_EventChannel_for_suppliers_i,
  yeceCa_EventChannel_destroy_i
 };

static CONST_W_PTR struct yeceCa_Factory__tyimpl yeceCa_Factory__impl =
 {
  yeceCa_Factory_create_i,
  yeceCa_Factory__get_channels_i,
  yeceCa_Factory__get_self_i
 };

static CONST_W_PTR struct yeceTeca_TypedProxyPushCons__tyimpl
yeceTeca_TypedProxyPushCons__impl =
 {
  yeceTeca_TypedProxyPushCons_connect_push_supp_i,
  yeceTeca_TypedProxyPushCons_push_i,
  yeceTeca_TypedProxyPushCons_disconnect_i,
  yeceTeca_TypedProxyPushCons_get_typed_cons_i
 };

static CONST_W_PTR struct yeceTeca_TypedProxyPullSupp__tyimpl
yeceTeca_TypedProxyPullSupp__impl =
 {
  yeceTeca_TypedProxyPullSupp_connect_pull_cons_i,
  yeceTeca_TypedProxyPullSupp_pull_i,
  yeceTeca_TypedProxyPullSupp_try_pull_i,
  yeceTeca_TypedProxyPullSupp_disconnect_i,
  yeceTeca_TypedProxyPullSupp_get_typed_supp_i
 };

static CONST_W_PTR struct yeceTeca_TypedSuppAdm__tyimpl
yeceTeca_TypedSuppAdm__impl =
 {
  yeceTeca_TypedSuppAdm_obtain_typed_push_cons_i,
  yeceTeca_TypedSuppAdm_obtain_typed_pull_cons_i,
  yeceTeca_TypedSuppAdm_obtain_push_cons_i,
  yeceTeca_TypedSuppAdm_obtain_pull_cons_i
 };

static CONST_W_PTR struct yeceTeca_TypedConsAdm__tyimpl
yeceTeca_TypedConsAdm__impl =
 {
  yeceTeca_TypedConsAdm_obtain_typed_pull_supp_i,
  yeceTeca_TypedConsAdm_obtain_typed_push_supp_i,
  yeceTeca_TypedConsAdm_obtain_push_supp_i,
  yeceTeca_TypedConsAdm_obtain_pull_supp_i
 };

static CONST_W_PTR struct yeceTeca_TypedEventChannel__tyimpl
yeceTeca_TypedEventChannel__impl =
 {
  yeceTeca_TypedEventChannel_for_consumers_i,
  yeceTeca_TypedEventChannel_for_suppliers_i
 };

static CONST_W_PTR struct yeceTeca_Factory__tyimpl yeceTeca_Factory__impl =
 {
  yeceTeca_Factory_create_i,
  yeceTeca_Factory__get_channels_i,
  yeceTeca_Factory__get_self_i
 };


/* proxy consumer state */
struct yecepc
{
  CORBA_Object    self_yecepc;	/* me, the proxy consumer, either a
				   yeceCa_ProxyPushCons or a 
				   yeceCa_ProxyPullCons */
  boolean   pull_yecepc;	/* pull consumer? */
  boolean   connected_yecepc;	/* is connected now? */
  CORBA_Object    supp_yecepc;	/* who is my supplier -- may be null */
  ysevt		  *sevt_yecepc;	/* supp death event. usrp is yecepc */
  yoenv	    ev_yecep;		/* env for polls to it. */
  CORBA_Object    proxy_yecepc;	/* typed consuming proxy object */
  yecesc    *sc_yecepc;		/* sub-channel we are in */
  ysle	    *le_yecepc;		/* element in sc->sups_yecesc */
};

/* consumer party in a subchannel (the proxy supplier) */
struct yecep
{
  CORBA_Object	self_yecep;	/* either yeceCa_ProxyPullSupp
				   yeceCa_ProxyPushSupp */
  yslst		*q_yecep;	/* events queued for pull, null for push */
  boolean	connected_yecep;
  CORBA_Object	dest_yecep;	/* the real dest obj */
  ysevt		*devt_yecep;	/* dest death event, usrp is yecep */
  yoenv		ev_yecep;	/* env for sends to it. */
  yecesc	*sc_yecep;	/* channel it's in. */
  ysle		*le_yecep;	/* where in sc->cons_yecsc this is */
  ub4		ucnt_yecep;	/* outstanding i/o to the dest. */
  boolean	removed_yecep;	/* le valid? */
  boolean	dead_yecep;	/* is dead; remove when ucnt == 0 */
};

/* sub-channel, keyed on interface string; null is the untyped channel */
struct yecesc
{
  ysspNode  node_yecesc;	/* key is allocated string of type name */
  sb4	    nevts_yecesc;	/* number of events sent to the subchannel */
  yecech    *ch_yecesc;		/* channel this is in. */
  yslst	    *sups_yecesc;	/* suppliers to this typed channel --
				   pointers to yecepc structs */
  yslst	    *cons_yecesc;	/* consumers of this typed channel --
				   pointers to yecep structs. */
};

/* yeceChannel/yeceCa_EventChannel state

   A channel is either typed or untyped, in which case different objects
   are created internally.  The typed objects are derived from the
   untyped ones.
 */
struct yecech
{
  boolean   typed_yecech;
  yececx    *cx_yecech;

  yeceCa_EventChannel		self_yecech;
  yeceTeca_TypedEventChannel	tself_yecech;
  yeceCa_ConsAdm		cself_yecech;
  yeceTeca_TypedConsAdm		tcself_yecech;
  yeceCa_SuppAdm		sself_yecech;
  yeceTeca_TypedSuppAdm		tsself_yecech;

  ysspTree  sch_yecech;		/* sub-channels, keyed by intf */
  sb4	    nevts_yecech;	/* number of events sent to the channel */
  ysle	    *le_yecech;		/* element in cx->ch_yececx */
};

/* master context (yece state), created by yeceInit, freed in yeceFree */
struct yececx
{
  ysque	    *q_yececx;		/* q for service */
  yeceCa_Factory self_yececx;	/* corba channel factory */
  yeceTeca_Factory tself_yececx; /* corba typed channel factory */
  yslst	    *ch_yececx;		/* list of known channels */
};

externdef ysmtagDecl(yececx_tag) = "yececx";
externdef ysmtagDecl(yecech_tag) = "yecech";
externdef ysmtagDecl(yecesc_tag) = "yecesc";

externdef ysmtagDecl(yecep_tag) = "yecep";
externdef ysmtagDecl(yecepc_tag) = "yecepc";
externdef ysmtagDecl(yecers_tag) = "yecers";
externdef ysmtagDecl(yecec_tag) = "yecec";

externdef ysidDecl( YECE_EX_UNIMPL ) = "yece::unimplemented";

STATICF void yeceSendComplete( dvoid *usrp, CONST ysid *exid,
			      dvoid *arg, size_t argsz );

STATICF yecech *yeceNewChannel( yececx *cx, boolean typed );
STATICF void yeceDestroyChannel( yecech *ch );

STATICF yecesc *yeceGetSubChannel( yecech *ch, char *eventIntf );
STATICF void yeceDestroySubChannel( yecesc *sc );

STATICF yecepc *yeceNewProxyConsumer( yecesc *sc );
STATICF void yeceDestroyProxyConsumer( yecepc *pc );

STATICF yecep *yeceNewParty( yecesc *sc );
STATICF void yeceDestroyParty( yecep *p );

STATICF void yeceDestroyAny(dvoid *x );

STATICF sword yeceChCmp( CONST dvoid *a, CONST dvoid *b );

STATICF void yecePollSuppliers( yecesc *sc, yoenv *ev );

STATICF void yeceShowAny(char *msg, yoany *ap );

STATICF void yecePCDeath( dvoid *usrp, CONST ysid *exid, dvoid *arg,
			 size_t argsz );

STATICF void yecePDeath( dvoid *usrp, CONST ysid *exid, dvoid *arg,
			size_t argsz );



/* ---------------------------- yeceInit ---------------------------- */
/*
  NAME
    yeceInit
  DESCRIPTION
    Initialize yece objects for service, and start the poll and
    distribution loops.
  PARAMETERS
    q		-- q to use.
  RETURNS
    object reference to the yece we're implementing.
*/

yeceCa_Factory yeceInit( ysque *q )
{
  yececx   *cx = (yececx*)ysmGlbAlloc( sizeof(*cx), yececx_tag );

  cx->q_yececx = q;
  cx->ch_yececx = ysLstCreate();

  yoSetImpl( yeceCa_ProxyPushCons__id, (char*)0,
	    yeceCa_ProxyPushCons__stubs, (dvoid*)&yeceCa_ProxyPushCons__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
  yoSetImpl( yeceCa_ProxyPullSupp__id, (char*)0,
	    yeceCa_ProxyPullSupp__stubs, (dvoid*)&yeceCa_ProxyPullSupp__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
	
  yoSetImpl( yeceCa_ProxyPullCons__id, (char*)0,
	    yeceCa_ProxyPullCons__stubs, (dvoid*)&yeceCa_ProxyPullCons__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
  yoSetImpl( yeceCa_ProxyPushSupp__id, (char*)0,
	    yeceCa_ProxyPushSupp__stubs, (dvoid*)&yeceCa_ProxyPushSupp__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
	
  yoSetImpl( yeceCa_ConsAdm__id, (char*)0,
	    yeceCa_ConsAdm__stubs, (dvoid*)&yeceCa_ConsAdm__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
  yoSetImpl( yeceCa_SuppAdm__id, (char*)0,
	    yeceCa_SuppAdm__stubs, (dvoid*)&yeceCa_SuppAdm__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
	
  yoSetImpl( yeceCa_EventChannel__id, (char*)0,
	    yeceCa_EventChannel__stubs, (dvoid*)&yeceCa_EventChannel__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
	
  yoSetImpl( yeceCa_Factory__id, (char*)0,
	    yeceCa_Factory__stubs, (dvoid*)&yeceCa_Factory__impl,
	    (yoload)0, TRUE, (dvoid*)cx );

  yoSetImpl( yeceTeca_TypedProxyPushCons__id, (char*)0,
	    yeceTeca_TypedProxyPushCons__stubs,
	    (dvoid*)&yeceTeca_TypedProxyPushCons__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
  yoSetImpl( yeceTeca_TypedProxyPullSupp__id, (char*)0,
	    yeceTeca_TypedProxyPullSupp__stubs,
	    (dvoid*)&yeceTeca_TypedProxyPullSupp__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
	
  yoSetImpl( yeceTeca_TypedSuppAdm__id, (char*)0,
	    yeceTeca_TypedSuppAdm__stubs,
	    (dvoid*)&yeceTeca_TypedSuppAdm__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
  yoSetImpl( yeceTeca_TypedConsAdm__id, (char*)0,
	    yeceTeca_TypedConsAdm__stubs,
	    (dvoid*)&yeceTeca_TypedConsAdm__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
	
  yoSetImpl( yeceTeca_TypedEventChannel__id, (char*)0,
	    yeceTeca_TypedEventChannel__stubs,
	    (dvoid*)&yeceTeca_TypedEventChannel__impl,
	    (yoload)0, FALSE, (dvoid*)cx );
	
  yoSetImpl( yeceTeca_Factory__id, (char*)0,
	    yeceTeca_Factory__stubs, (dvoid*)&yeceTeca_Factory__impl,
	    (yoload)0, TRUE, (dvoid*)cx );

  cx->self_yececx =
    (yeceCa_Factory)yoCreate( yeceCa_Factory__id, (char*)0,
			     (yoRefData*)0, (char*)0, (dvoid*)0 );

  cx->tself_yececx =
    (yeceTeca_Factory)yoCreate( yeceTeca_Factory__id, (char*)0,
			       (yoRefData*)0, (char*)0, (dvoid*)0 );

  yoImplReady( yeceCa_ProxyPushCons__id, (char*)0, q );
  yoImplReady( yeceCa_ProxyPullSupp__id, (char*)0, q );
  yoImplReady( yeceCa_ProxyPullCons__id, (char*)0, q );
  yoImplReady( yeceCa_ProxyPushSupp__id, (char*)0, q );
  yoImplReady( yeceCa_ConsAdm__id, (char*)0, q );
  yoImplReady( yeceCa_SuppAdm__id, (char*)0, q );
  yoImplReady( yeceCa_EventChannel__id, (char*)0, q );
  yoImplReady( yeceCa_Factory__id, (char*)0, q );

  yoImplReady( yeceTeca_TypedProxyPushCons__id, (char*)0, q);
  yoImplReady( yeceTeca_TypedProxyPullSupp__id, (char*)0, q);
  yoImplReady( yeceTeca_TypedSuppAdm__id, (char*)0, q );
  yoImplReady( yeceTeca_TypedConsAdm__id, (char*)0, q );
  yoImplReady( yeceTeca_TypedEventChannel__id, (char*)0, q );
  yoImplReady( yeceTeca_Factory__id, (char*)0, q );

  /* 501, "yeceInit: ready" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)501, YSLSEV_INFO, (char*)0, YSLNONE);

  return( (yeceCa_Factory)yoDuplicate((dvoid*)cx->self_yececx ));
}


/* ---------------------------- yeceTerm ---------------------------- */
/*
  NAME
    yeceTerm
  DESCRIPTION
    Terminate the yece objects and the polling and distribution
    loops.  Does not return until all is shut down.
  PARAMETERS
    ev	    -- object reference from yeceInit
  RETURNS
    none
*/
void yeceTerm( yeceCa_Factory or )
{
  yececx *cx = (yececx*)yoGetImplState( (dvoid*)or );

  /* 502, "yeceTerm: deactivating" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)502, YSLSEV_INFO, (char*)0, YSLNONE );

  yoImplDeactivate( yeceCa_ProxyPushCons__id, (char*)0 );
  yoImplDeactivate( yeceCa_ProxyPullSupp__id, (char*)0 );
  yoImplDeactivate( yeceCa_ProxyPullCons__id, (char*)0 );
  yoImplDeactivate( yeceCa_ProxyPushSupp__id, (char*)0 );
  yoImplDeactivate( yeceCa_ConsAdm__id, (char*)0 );
  yoImplDeactivate( yeceCa_SuppAdm__id, (char*)0 );
  yoImplDeactivate( yeceCa_EventChannel__id, (char*)0 );
  yoImplDeactivate( yeceCa_Factory__id, (char*)0 );

  yoImplDeactivate( yeceTeca_TypedProxyPushCons__id, (char*)0 );
  yoImplDeactivate( yeceTeca_TypedProxyPullSupp__id, (char*)0);
  yoImplDeactivate( yeceTeca_TypedSuppAdm__id, (char*)0 );
  yoImplDeactivate( yeceTeca_TypedConsAdm__id, (char*)0 );
  yoImplDeactivate( yeceTeca_TypedEventChannel__id, (char*)0 );
  yoImplDeactivate( yeceTeca_Factory__id, (char*)0 );

  yoDispose( (dvoid*)cx->self_yececx );
  yoDispose( (dvoid*)cx->tself_yececx );
  yoRelease( (dvoid*)cx->self_yececx );
  yoRelease( (dvoid*)cx->tself_yececx );

  /* 503, "yeceTerm: destroying channels" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)503, YSLSEV_INFO, (char*)0, YSLNONE );

  ysLstDestroy( cx->ch_yececx, (ysmff)yeceDestroyChannel );

  /* 504, "yeceTerm: finished" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)504, YSLSEV_INFO, (char*)0, YSLNONE );

  ysmGlbFree( (dvoid*)cx );
}


/* -------------------------- yeceProxyConsumer --------------------------- */
/*
  NAME
    yeceProxyConsumer
  DESCRIPTION
    Generic proxy consumer/forwarder.   This is called from the DSI
    defined implementation of a typed push channel with a request to handle.

    It looks on the subscription list of the channel for the type, and
    supplies all the qualifying real consumers.
    
    PROBLEMS:  due to limitations with the current DSI, we can't support
    pull consumers.  We'd need to save the yosreq on the consumer's queue,
    but there is no way to do so; the state vanishes when the DSI routine
    exits to the dispatcher.

  PARAMETERS
    or	    -- object ref; state is the yeceSupplier; it's state is the ch.
    ev	    -- call environment, passed on.
    opernm  -- the method name, ignored.
    rh	    -- request handle (opaque).
  RETURNS
    none
*/

/* ARGSUSED */
STATICF void yeceProxyConsumer( CORBA_Object or, yoenv *ev,
			       char *opernm, yosreq *rh )
{
  yecech    *ch;		/* main channel */
  ysle	    *e = (ysle*)0;	/* consumer list element */
  yecep	    *p;			/* consuming party */
  yecesc    *sc;		/* sub-channel */
  yecepc    *pc;
  
  pc = (yecepc*)yoGetState((dvoid*)or);
  sc = pc->sc_yecepc;
  ch = sc->ch_yecesc;

  /* 505, "yeceProxyConsumer: or %s oper %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)505, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&or),
	   YSLSTR( yeuStr(opernm) ), YSLEND );

  ch->nevts_yecech++;
  sc->nevts_yecesc++;
  for( e = ysLstHead( sc->cons_yecesc ); e ; e = ysLstNext(e) )
  {
    p = (yecep*)ysLstVal(e);
    if( p->dead_yecep )
      continue;

    /* 506, "yeceProxyConsumer: send to %s" */
    ysRecord(YS_PRODUCT,YECE_FAC,(ub4)506, YSLSEV_DEBUG(3), (char*)0,
	     YSLANY(yoTcObject,&p->dest_yecep), YSLEND );

    p->ucnt_yecep++;
    yodsReSendReq( rh, p->dest_yecep, &p->ev_yecep,
		  ysEvtCreate( yeceSendComplete, (dvoid*)p,
			      ch->cx_yecech->q_yececx, FALSE )); 
  }
}


/* ------------------------- yeceSendComplete ---------------------------- */
/*
  NAME
    yeceSendComplete
  DESCRIPTION
    Completion handler for send request.    On error, clean out
    all references to the destination party.

  PARAMETERS
    usrp    -- the yecep something was being sent to.
    exid    -- error status from the send.
    arg	    -- reply handle to free if no exid; may be null.
    argsz   -- size of arg.
  RETURNS
    none
*/
/* ARGSUSED */
STATICF void yeceSendComplete( dvoid *usrp, CONST ysid *exid,
			      dvoid *arg, size_t argsz )
{
  yecep *p;

  p = (yecep*)usrp;
  /*CONSTCOND*/ 
  ysmCheck(p, yecep_tag); 
  p->ucnt_yecep--;

  if( exid )
    p->dead_yecep = TRUE;
  else if( arg )
    yodsFreeRep( *(yodsrep**)arg );

  if( p->dead_yecep && !p->ucnt_yecep )
  {
    yslError("yeceSendComplete: exid %s, removing party %p\n",
	     yeuStr(ysidToStr(exid)), p );

    /* remove this subscription */
    if( !p->removed_yecep )
      DISCARD ysLstRem( p->sc_yecep->cons_yecesc, p->le_yecep );

    /* 507, "yeceSendComplete: exid %s, removing party %s" */
    ysRecord(YS_PRODUCT,YECE_FAC,(ub4)507, YSLSEV_WARNING, (char*)0,
	     YSLSTR(yeuStr(ysidToStr(exid))),
	     YSLANY(yoTcObject,&p->dest_yecep),
	     YSLEND );

    yeceDestroyParty( p );
  }
}


/* ---------------------------- yeceNewChannel ---------------------------- */
/*
  NAME
    yeceNewChannel
  DESCRIPTION
    Create a new channel 
  PARAMETERS
    cx	    -- context
  RETURNS
    pointer to new initialized yecech structure
*/
STATICF yecech *yeceNewChannel( yececx *cx, boolean typed )
{
  yecech *ch;

  ch = (yecech*)ysmGlbAlloc( sizeof(*ch), yecech_tag );
  CLRSTRUCT(*ch);
  
  if( (ch->typed_yecech = typed) )
  {
    ch->tself_yecech =
      (yeceTeca_TypedEventChannel) yoCreate( yeceTeca_TypedEventChannel__id,
					    (char*)0, (yoRefData*)0, 
					    (char*)0, (dvoid*)ch );
    ch->tcself_yecech =
      (yeceTeca_TypedConsAdm)yoCreate( yeceTeca_TypedConsAdm__id, (char*)0,
				      (yoRefData*)0, (char*)0, (dvoid*)ch );
    ch->tsself_yecech =
      (yeceTeca_TypedSuppAdm)yoCreate( yeceTeca_TypedSuppAdm__id, (char*)0,
				      (yoRefData*)0, (char*)0, (dvoid*)ch );
  }
  else				/* untyped base channel */
  {
    ch->self_yecech =
      (yeceCa_EventChannel) yoCreate( yeceCa_EventChannel__id,
				     (char*)0, (yoRefData*)0, 
				     (char*)0, (dvoid*)ch );
    ch->cself_yecech =
      (yeceCa_ConsAdm)yoCreate( yeceCa_ConsAdm__id, (char*)0, (yoRefData*)0,
			       (char*)0, (dvoid*)ch );
    ch->sself_yecech =
      (yeceCa_SuppAdm)yoCreate( yeceCa_SuppAdm__id, (char*)0, (yoRefData*)0,
			       (char*)0, (dvoid*)ch );
  }
  ch->cx_yecech = cx;
  DISCARD ysspNewTree( &ch->sch_yecech, yeceChCmp );
  ch->nevts_yecech = 0;
  ch->le_yecech = ysLstEnq( cx->ch_yececx, (dvoid*)ch );

  /* 508, "yeceNewChannel: made %s channel %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)508, YSLSEV_DEBUG(2), (char*)0,
	   YSLSTR( typed ? "typed" : "untyped" ),
	   YSLANY(yoTcObject,ch->typed_yecech ?
		  (dvoid*)&ch->tself_yecech : (dvoid*)&ch->self_yecech),
	   YSLEND );

  return( ch );
}


/* -------------------------- yeceDestroyChannel -------------------------- */
/*
  NAME
    yeceDestroyChannel
  DESCRIPTION
    Destroy a yecech channel completely.
  PARAMETERS
    ch	    -- the channel to destroy.
  RETURNS
    none
*/

STATICF void yeceDestroyChannel( yecech *ch )
{
  ysspNode *n;

  /* 509, "yeceDestroyChannel: destroying channel %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)509, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,
		  ch->typed_yecech ?
		  (dvoid**)&ch->tself_yecech : (dvoid**)&ch->self_yecech),
	   YSLEND );

  while( (n = ysspDeq( &ch->sch_yecech.root_ysspTree ) ) )
    yeceDestroySubChannel( (yecesc*)n );

  if( ch->self_yecech )
  {
    yoDispose((dvoid*)ch->self_yecech);
    yoRelease((dvoid*)ch->self_yecech);
  }
  if( ch->tself_yecech )
  {
    yoDispose((dvoid*)ch->tself_yecech);
    yoRelease((dvoid*)ch->tself_yecech);
  }
  ysmGlbFree( (dvoid*)ch );
}


/* -------------------------- yeceGetSubChannel --------------------------- */
/*
  NAME
    yeceGetSubChannel
  DESCRIPTION
    Get or create a subchannel structure for an interface; NULL interface
    is the "untyped" channel.
  PARAMETERS
    ch	    -- channel to attach sub-channel to.
    eventIntf	-- the string to use as a key.
  RETURNS
    pointer to the sub-channel.
*/
STATICF yecesc *yeceGetSubChannel( yecech *ch, char *eventIntf )
{
  yececx *cx;
  yecesc *noreg sc;
  ysspNode *n;
  char	    *intf;

  NOREG(sc);

  intf = eventIntf;

  /* 510, "yeceGetSubChannel: channel %s intf %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)510, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject, ch->typed_yecech ?
		  (dvoid**)&ch->tself_yecech : (dvoid**)&ch->self_yecech),
	   YSLSTR(yeuStr(intf)), YSLEND ); 

  if( (n = ysspLookup( (dvoid*)intf, &ch->sch_yecech ) ) )
  {
    sc = (yecesc*)n;
    /* 511, "yeceGetSubChannel: using existing sc" */
    ysRecord(YS_PRODUCT,YECE_FAC,(ub4)511, YSLSEV_DEBUG(2), (char*)0, YSLNONE);
  }
  else
  {
    sc = (yecesc*)ysmGlbAlloc(sizeof(*sc), yecesc_tag );
    CLRSTRUCT(*sc);
    sc->node_yecesc.key_ysspNode = (dvoid*)ysStrDup(intf);
    sc->ch_yecesc = ch;
    sc->nevts_yecesc = 0;
    sc->sups_yecesc = ysLstCreate();
    sc->cons_yecesc = ysLstCreate();
    DISCARD ysspEnq( &sc->node_yecesc, &ch->sch_yecech );
    cx = ch->cx_yecech;
	
    /* 512, "yeceGetSubChannel: making new channel sc"  */
    ysRecord(YS_PRODUCT,YECE_FAC,(ub4)512, YSLSEV_DEBUG(2), (char*)0, YSLNONE);

    if( intf )
    {
      yseTry
      {
	yodsSetImpl( eventIntf, (char*)0, yeceProxyConsumer,
		    (yoload)0, FALSE, (dvoid*)cx );
	yoImplReady( eventIntf, (char*)0, cx->q_yececx );
      }
      yseCatch(YO_EX_DUPLICATE)
      {
	/* nothing */
      }
      yseEnd;
    }
  }
  return( sc );
}

/* ------------------------- yeceDestroySubChannel ------------------------- */
/*
  NAME
    yeceDestroySubChannel
  DESCRIPTION
    Clean up a sub-channel, releasing it's contents and it's wrapper.
    The node is assumed to be already removed from the tree.
  PARAMETERS
    sc	    -- the subchannel to destroy.
  RETURNS
    none
*/

STATICF void yeceDestroySubChannel( yecesc *sc )
{
  /*CONSTCOND*/
  ysmCheck( sc, yecesc_tag );
  
  /* 513, "yeceDestroySubChannel: destroying intf %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)513, YSLSEV_DEBUG(2), (char*)0,
	   YSLSTR(yeuStr(sc->node_yecesc.key_ysspNode)), YSLEND );
      
  if( sc->node_yecesc.key_ysspNode )
  {
    yseTry
    {
      /* 514, "yeceDestroySubChannel: deactivating %s" */
      ysRecord(YS_PRODUCT,YECE_FAC,(ub4)514, YSLSEV_DEBUG(2), (char*)0,
	       YSLSTR(sc->node_yecesc.key_ysspNode), YSLEND );
      yoImplDeactivate( (char*)sc->node_yecesc.key_ysspNode, (char*)0 );

      /* 515, "yeceDestroySubChannel: done deactivating" */
      ysRecord(YS_PRODUCT,YECE_FAC,(ub4)515,YSLSEV_DEBUG(2),(char*)0,YSLNONE);
    }
    yseCatchAll
    {
      /* 516, "yeceDestroySubChannel: exid %s on intf %s" */
      ysRecord(YS_PRODUCT,YECE_FAC,(ub4)515,YSLSEV_WARNING,(char*)0,
	       YSLSTR(yeuStr(ysidToStr(yseExid))),
	       YSLSTR(sc->node_yecesc.key_ysspNode), YSLEND );
      yslError("yeceDestroySubChannel: exid %s\n", yeuStr(ysidToStr(yseExid)));
    }
    yseEnd;
  }

  ysLstDestroy( sc->sups_yecesc, (ysmff)yeceDestroyProxyConsumer );
  ysLstDestroy( sc->cons_yecesc, (ysmff)yeceDestroyParty );

  /* copy of type */
  ysmGlbFree( sc->node_yecesc.key_ysspNode );

  /* 517, "yeceDestroySubChannel: exit" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)517, YSLSEV_DEBUG(2), (char*)0, YSLNONE);

  ysmGlbFree( (dvoid*)sc );
}

/* ---------------------------- yeceNewParty ---------------------------- */
/*
  NAME
    yeceNewParty
  DESCRIPTION
    Create a new party, filling in common parts.
  PARAMETERS
    sc	    -- sub channel to create the party in.
  RETURNS
    pointer to initialized yececp.
*/
STATICF yecep *yeceNewParty( yecesc *sc )
{
  yecep *p;

  p = (yecep*)ysmGlbAlloc( sizeof(*p), yecep_tag );
  CLRSTRUCT(*p);
  p->connected_yecep = FALSE;
  p->dest_yecep = (CORBA_Object)0;
  p->sc_yecep = sc;
  p->q_yecep = (yslst*)0;
  yoEnvInit(&p->ev_yecep);
  p->removed_yecep = FALSE;
  p->dead_yecep = FALSE;
  p->ucnt_yecep = 0;
  p->le_yecep = ysLstEnq( sc->cons_yecesc, (dvoid*)p );

  /* self must be filled in by the caller */

  /* 518, "yeceNewParty: made party"  */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)518, YSLSEV_DEBUG(2), (char*)0, YSLNONE );
  return p;
}

/* ---------------------------- yeceDestroyParty --------------------------- */
/*
  NAME
    yeceDestroyParty
  DESCRIPTION
    Release a party and it's wrapper.
  PARAMETERS
    p	    -- the party to destroy.
  RETURNS
    none
*/

STATICF void yeceDestroyParty( yecep *p )
{
  /*CONSTCOND*/
  ysmCheck( p, yecep_tag );

  /* if in use, leak rather than fault on completion. */
  p->removed_yecep = TRUE;
  if( p->ucnt_yecep )
    return;


  /* 519, "yeceDestroyParty: destroying %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)519, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&p->self_yecep), YSLEND );
  
  yoDispose((dvoid*)p->self_yecep);
  yoRelease((dvoid*)p->self_yecep);
  if( p->dest_yecep )
  {
    yoRelease((dvoid*)p->dest_yecep);
    ysEvtDestroy( p->devt_yecep );
  }
  if( p->q_yecep )
    ysLstDestroy( p->q_yecep, yeceDestroyAny );
  yoEnvFree(&p->ev_yecep);
  ysmGlbFree( (dvoid*)p );
}


/* ---------------------------- yeceDestroyAny ---------------------------- */
/*
  NAME
    yeceDestroyAny
  DESCRIPTION
    Destroy an allocated any, probably from a queue.
  PARAMETERS
    x -- pointer to an any, as a dvoid *.
  RETURNS
    none
*/
STATICF void yeceDestroyAny(dvoid *x)
{
  yotkFreeVal( yoTcAny, x, (ysmff)0 );
  ysmGlbFree( x );
}



/* ------------------------ yeceNewProxyConsumer -------------------------- */
/*
  NAME
    yeceNewProxyConsumer
  DESCRIPTION
    create a new proxy consumer (for suppliers)
  PARAMETERS
    sc	    -- sub-channel to make it in.
  RETURNS
    pointer to new yecesc.
*/

STATICF yecepc *yeceNewProxyConsumer( yecesc *sc )
{
  yecepc *pc = (yecepc*)ysmGlbAlloc(sizeof(*pc), yecepc_tag); 

  pc->pull_yecepc = FALSE;
  pc->supp_yecepc = (CORBA_Object)0;
  pc->proxy_yecepc = (CORBA_Object)0;
  pc->connected_yecepc = FALSE;
  pc->sc_yecepc = sc;
  pc->le_yecepc = ysLstEnq( pc->sc_yecepc->sups_yecesc, (dvoid*)pc );

  /* 520, "yeceNewProxyConsumer: created" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)520, YSLSEV_DEBUG(2), (char*)0, YSLNONE);

  return pc;
}

/* ----------------------- yeceDestroyProxyConsumer ------------------------ */
/*
  NAME
    yeceDestroyProxyConsumer
  DESCRIPTION
    Destroy contents and wrapper of a yecepc.
  PARAMETERS
    pc	    -- proxy consumer to clobber.
  RETURNS
    none
*/

STATICF void yeceDestroyProxyConsumer( yecepc *pc )
{
  /* 521, "yeceDestroyProxyConsumer: destroying %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)521, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&pc->self_yecepc), YSLEND );

  yoDispose((dvoid*)pc->self_yecepc); /* our proxy */
  yoRelease((dvoid*)pc->self_yecepc); /* our proxy */
  if( pc->supp_yecepc )
  {
    yoRelease( (dvoid*)pc->supp_yecepc ); /* the yeceSupplier ref */
    ysEvtDestroy( pc->sevt_yecepc );
  }
  if( pc->proxy_yecepc )
  {
    yoDispose( pc->proxy_yecepc ); /* typed proxy */
    yoRelease( pc->proxy_yecepc ); /* typed proxy */
  }
  ysmGlbFree( (dvoid*)pc );
}


/* ---------------------------- yeceChCmp ---------------------------- */
/*
  NAME
    yeceChCmp
  DESCRIPTION
    Comparison function for sub-channels in a channel's tree.   The
    keys are interface name strings, and may be null for the untyped
    sub-channel.
  PARAMETERS
    a	    one string pointer (may be NULL)
    b	    another string pointer (may be NULL)
  RETURNS
    < 0, 0 , >0 to order the strings.
*/
STATICF sword yeceChCmp( CONST dvoid *a, CONST dvoid *b )
{
  return( yeuSafeStrcmp( (char*)a, (char *)b ) );
}

/* ------------------------- yecePollSuppliers ---------------------------- */
/*
  NAME
    yecePollSuppliers
  DESCRIPTION
    Poll all the suppliers on the sub-channel, and push any events
    we get back.  Would be nice to do this async, but we can't for now. 
  PARAMETERS
    sc	    -- the subchannel in question
  RETURNS
    none
*/

STATICF void yecePollSuppliers( yecesc *sc, yoenv *ev )
{
  yoany	data;
  yecepc *pc;
  ysle *noreg e;
  boolean has = FALSE;

  NOREG(e);

  /* 522, "yecePollSuppliers: entry" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)522, YSLSEV_DEBUG(2), (char*)0, YSLNONE );

  for( e = ysLstHead( sc->sups_yecesc ); e ; e = ysLstNext( e ) )
  {
    pc = (yecepc*)ysLstVal(e);
    if( !pc->pull_yecepc )
      continue;

    yseTry
    {
      do
      {
	data =
	  yecec_PullSupp_try_pull( (yecec_PullSupp)pc->supp_yecepc, ev, &has );
	if( has )
	{
	  yeceShowAny((char*)"yecePollSuppliers: pushing", &data );
	  yeceCa_ProxyPushCons_push_i((yeceCa_ProxyPushCons)pc->self_yecepc,
				      ev, &data );
	}
      } while( has );
      yotkFreeVal( yoTcAny, (dvoid*)&data, yoFree );
    }
    yseCatchAll
    {
      /* FIXME?  Something else to do? */
      /* 533, "yecePollSuppliers: exception '%s' from %s" */
      ysRecord(YS_PRODUCT,YECE_FAC,(ub4)533, YSLSEV_WARNING, (char*)0,
	       YSLSTR(yeuStr(ysidToStr(yseExid))),
	       YSLANY(yoTcObject,&pc->supp_yecepc),
	       YSLEND );
    }
    yseEnd;
  }

  /* 523, "yecePollSuppliers: exit" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)523, YSLSEV_DEBUG(2), (char*)0, YSLNONE);
}

STATICF void yeceShowAny(char *msg, yoany *ap )
{
  ysstr	*anystr;
  
  anystr = yeevFormat( (yemsgcx*)0, (char*)0, (char*)0, (ub4)0, ap, TRUE );

  /* 524, "%s %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)524, YSLSEV_DEBUG(3), (char*)0,
	   YSLSTR(msg),
	   YSLSTR(ysStrToText(anystr)), YSLEND );
  
  ysStrDestroy( anystr );
}

/* ARGSUSED */
STATICF void yecePCDeath( dvoid *usrp, CONST ysid *exid, dvoid *arg,
			 size_t argsz )
{
  yecepc *pc = (yecepc*)usrp;

  /* 546, "yecePCDeath: death of supplier %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)546, YSLSEV_WARNING, (char*)0,
	   YSLANY(yoTcObject, (dvoid**)&pc->supp_yecepc), YSLEND );

  DISCARD ysLstRem( pc->sc_yecepc->sups_yecesc, pc->le_yecepc );

  yeceDestroyProxyConsumer( pc );
}

/* ARGSUSED */
STATICF void yecePDeath( dvoid *usrp, CONST ysid *exid, dvoid *arg,
			size_t argsz )
{
  yecep *p = (yecep*)usrp;

  /* 547, "yecePCDeath: death of consumer %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)547, YSLSEV_WARNING, (char*)0,
	   YSLANY(yoTcObject, (dvoid**)&p->dest_yecep), YSLEND );

  DISCARD ysLstRem( p->sc_yecep->cons_yecesc, p->le_yecep ); 
  yeceDestroyParty( p );
}

/* ================================================================ */
/* CORBA COSS EVENT CHANNELS */
/* ================================================================ */

/* ---------------------------------------------------------------- */
/* Module EventComm -- no impl ever used in daemon? */
/* ---------------------------------------------------------------- */

/* ---------------------------------------------------------------- */
/* Module EventChannelAdmin  */
/* ---------------------------------------------------------------- */

/* Objects created in the daemon use for the typeless case */

/* ARGSUSED */
void yeceCa_ProxyPushCons_push_i( yeceCa_ProxyPushCons or, yoenv* ev,
				 yoany* data)
{
  yecepc    *pc = (yecepc*)yoGetState((dvoid*)or);
  yecesc    *sc = pc->sc_yecepc;
  yecech    *ch = sc->ch_yecesc;
  ysle	    *e = (ysle*)0;	/* consumer list element */
  yecep	    *p;			/* consuming party */
  yoany	    *qd;

  /* called with data; loop over connected consumers and send
     the data there. */

  yeceShowAny((char*)"yeceCa_ProxyPushCons_push_i:", data );

  ch->nevts_yecech++;
  sc->nevts_yecesc++;
  for( e = ysLstHead( sc->cons_yecesc ); e ; e = ysLstNext(e) )
  {
    p = (yecep*)ysLstVal(e);

    if( p->dead_yecep )
      continue;	

    if( p->q_yecep )		/* queue it for later pull */
    {
      qd = (yoany*)ysmGlbAlloc(sizeof(*qd), "queued any");
      yotkCopyVal( yoTcAny, (dvoid*)qd, (dvoid*)data, (ysmaf)0 );

      /* 525, "yeceCa_ProxyPushCons_push_i: enqueued for pull" */
      ysRecord(YS_PRODUCT,YECE_FAC,(ub4)525, YSLSEV_DEBUG(2), (char*)0,
	       YSLNONE);
    
      DISCARD ysLstEnq( p->q_yecep, (dvoid*)qd );
    }
    else			/* push it right away */
    {
      p->ucnt_yecep++;
      yecec_PushCons_push_nw( (yecec_PushCons)p->dest_yecep,
			     &p->ev_yecep, data,
			     ysEvtCreate( yeceSendComplete, (dvoid*)p,
					 ch->cx_yecech->q_yececx, FALSE ));
    }
  }
}

/* ARGSUSED */
void yeceCa_ProxyPushCons_disconnect_i( yeceCa_ProxyPushCons or, yoenv* ev)
{
  yecepc    *pc = (yecepc*)yoGetState((dvoid*)or);
  
  if( !pc->supp_yecepc )
    yseThrow( YS_EX_BADPARAM );
  if( !pc->connected_yecepc )
    yseThrow(YECEC_EX_DISCONNECTED);

  DISCARD ysLstRem( pc->sc_yecepc->sups_yecesc, pc->le_yecepc );
  yeceDestroyProxyConsumer( pc );
}

/* connect the proxy consumer to the supplier push_supp */

/* push_supp may be null; if so, PushSupplier::disconnect is invalid. */
/* raise AlreadyConnected if that's the case. */

/* ARGSUSED */
void yeceCa_ProxyPushCons_connect_push_supp_i( yeceCa_ProxyPushCons or,
					      yoenv* ev,
					      yecec_PushSupp push_supp)
{
  yecepc *pc = (yecepc*)yoGetState((dvoid*)or );
  yececx *cx = (yececx*)yoGetImplState((dvoid*)or);

  if( pc->connected_yecepc )
    yseThrow( YECECA_EX_ALREADYCONNECTED );

  pc->supp_yecepc = (CORBA_Object)yoDuplicate(push_supp); /* possibly NIL */
  pc->connected_yecepc = TRUE;

  if( push_supp )
  {
    pc->sevt_yecepc = ysEvtCreate(yecePCDeath, (dvoid*)pc, cx->q_yececx, TRUE);
    yoWatchOwner( push_supp, pc->sevt_yecepc );
  }
}


/* ---------------------------------------------------------------- */

/* op invoked by the consumer to poll for events in our queue for him. */
yoany yeceCa_ProxyPullSupp_pull_i( yeceCa_ProxyPullSupp or, yoenv* ev)
{
  /* dequeue or block.  blocking would be bad, so throw
     exeception instead. */

  yecep *p = (yecep*)yoGetState((dvoid*)or);
  yoany	*data;
  yoany rv;
  
  if( !p->q_yecep )
    yseThrow( YS_EX_BADPARAM ); 

  /* fill queues with anything waiting to be picked up */
  yecePollSuppliers( p->sc_yecep, ev );

  if( !ysLstCount( p->q_yecep ) )
    yseThrow( YECEC_EX_NOTHINGTOPULL );

  data = (yoany*)ysLstDeq( p->q_yecep );
  yotkCopyVal( yoTcAny, (dvoid*)&rv, (dvoid*)data, yoAlloc );
  yeceDestroyAny((dvoid*)data );
  return rv;
}

/* op invoked by the consumer to check poll for events in our queue for him. */

yoany yeceCa_ProxyPullSupp_try_pull_i( yeceCa_ProxyPullSupp or, yoenv* ev,
				      boolean* has_event)
{
  yecep *p = (yecep*)yoGetState((dvoid*)or);
  yoany	*data;
  yoany rv;
  
  if( !p->q_yecep )
    yseThrow( YS_EX_BADPARAM ); 

  /* 526, "yeceCa_ProxyPullSupp_try_pull: entry" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)526, YSLSEV_DEBUG(2), (char*)0, YSLNONE );

  /* fill queues with anything waiting to be picked up */
  yecePollSuppliers( p->sc_yecep, ev );

  if( ysLstCount( p->q_yecep ) )
  {
    *has_event = TRUE;
    data = (yoany*)ysLstDeq( p->q_yecep );
    yotkCopyVal( yoTcAny, (dvoid*)&rv, (dvoid*)data, yoAlloc );
    yeceDestroyAny((dvoid*)data );
  }
  else
  {
    *has_event = FALSE;
    rv._type = (yotk*)yoTcNull;
    rv._value = (dvoid*)0;
  }

  /* 527, "yeceCa_ProxyPullSupp_try_pull: exit, has %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)527, YSLSEV_DEBUG(2), (char*)0,
	   YSLSTR( *has_event ? "TRUE" : "FALSE"), YSLEND );

  yeceShowAny((char*)"yeceCa_ProxyPullSupp_try_pull_i: returning", &rv );
  return rv;
}

/* op invoked by consumer to disconnect and drain queue; invalid if
   pull_cons given at connect time was NULL (?) */

/* ARGSUSED */
void yeceCa_ProxyPullSupp_disconnect_i( yeceCa_ProxyPullSupp or, yoenv* ev)
{
  yecep  *p = (yecep*)yoGetState((dvoid*)or);
  
  /* FIXME -- what about the queue in the yecep? */

  DISCARD ysLstRem( p->sc_yecep->cons_yecesc, p->le_yecep ); 
  yeceDestroyParty( p );
}

/* ARGSUSED */
void yeceCa_ProxyPullSupp_connect_pull_cons_i( yeceCa_ProxyPullSupp or,
					      yoenv* ev,
					      yecec_PullCons pull_cons)
{
  yecep *p = (yecep*)yoGetState((dvoid*)or);
  yececx *cx = (yececx*)yoGetImplState((dvoid*)or);

  if( !p->q_yecep || !pull_cons )
    yseThrow( YS_EX_BADPARAM ); 

  if( p->connected_yecep )
    yseThrow( YECECA_EX_ALREADYCONNECTED );
    
  /* 528, "yeceCa_ProxyPullSupp_connect_pull_cons: connecting %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)528, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&pull_cons), YSLNONE );

  p->connected_yecep = TRUE;
  p->dest_yecep = (CORBA_Object)yoDuplicate((dvoid*)pull_cons);
  p->devt_yecep = ysEvtCreate( yecePDeath, (dvoid*)p, cx->q_yececx, TRUE );
  yoWatchOwner( pull_cons, p->devt_yecep );

  yoEnvInit(&p->ev_yecep);
  p->sc_yecep = p->sc_yecep;
  p->q_yecep = ysLstCreate();
}


/* ---------------------------------------------------------------- */

/* op invoked by supplier to disconnect.  Stop asking him for events. */

/* ARGSUSED */
void yeceCa_ProxyPullCons_disconnect_i( yeceCa_ProxyPullCons or, yoenv* ev)
{
  yecepc    *pc = (yecepc*)yoGetState((dvoid*)or);
  
  DISCARD ysLstRem( pc->sc_yecepc->sups_yecesc, pc->le_yecepc );
  yeceDestroyProxyConsumer( pc );

  /* FIXME -- stop poll? */
}

/* op invoked by supplier to annonce his presence.  Start asking him
   for events. */

/* ARGSUSED */
void yeceCa_ProxyPullCons_connect_pull_supp_i( yeceCa_ProxyPullCons or,
					      yoenv* ev,
					      yecec_PullSupp pull_supp)
{
  yecepc *pc = (yecepc*)yoGetState((dvoid*)or);
  yececx *cx = (yececx*)yoGetImplState((dvoid*)or);

  if( !pull_supp || !pc->pull_yecepc )
    yseThrow( YS_EX_BADPARAM ); 

  if( pc->connected_yecepc )
    yseThrow( YECECA_EX_ALREADYCONNECTED );

  pc->supp_yecepc = (CORBA_Object)yoDuplicate(pull_supp); /* possibly NIL */
  pc->connected_yecepc = TRUE;
  pc->sevt_yecepc = ysEvtCreate( yecePCDeath, (dvoid*)pc, cx->q_yececx, TRUE);
  yoWatchOwner( pull_supp, pc->sevt_yecepc );
}


/* ---------------------------------------------------------------- */

/* op to disconnect supplier from push interface.
   dec count of known suppliers...  */

/* ARGSUSED */
void yeceCa_ProxyPushSupp_disconnect_push_supp_i( yeceCa_ProxyPushSupp or,
						 yoenv* ev)
{
  yecep *p = (yecep*)yoGetState((dvoid*)or);

  /* 529, "yeceCa_ProxyPushSupp_disconnect_push_supp: disconnecting %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)529, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&or), YSLNONE );
  
  /* FIXME other state? */

  DISCARD ysLstRem( p->sc_yecep->cons_yecesc, p->le_yecep ); 
  yeceDestroyParty( p );
}

/* ARGSUSED */
void yeceCa_ProxyPushSupp_connect_push_cons_i( yeceCa_ProxyPushSupp or,
					      yoenv* ev,
					      yecec_PushCons push_cons)
{
  yecep *p = (yecep*)yoGetState((dvoid*)or);
  yececx *cx = (yececx*)yoGetImplState((dvoid*)or);

  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)530, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&push_cons), YSLEND );

  if( p->connected_yecep )
    yseThrow( YECECA_EX_ALREADYCONNECTED );

  if( !push_cons )
    yseThrow( YS_EX_BADPARAM ); 

  p->connected_yecep = TRUE;
  p->dest_yecep = yoDuplicate( (dvoid*)push_cons );
  p->devt_yecep = ysEvtCreate( yecePDeath, (dvoid*)p, cx->q_yececx, TRUE );
  yoWatchOwner( push_cons, p->devt_yecep );
}

/* ---------------------------------------------------------------- */

/* Used by clients to obtain proxy suppliers */


/* ARGSUSED */
yeceCa_ProxyPushSupp yeceCa_ConsAdm_obtain_push_supp_i( yeceCa_ConsAdm or,
						       yoenv* ev)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);
  yecesc *sc = yeceGetSubChannel( ch, (char*)0 );
  yecep *p = yeceNewParty( sc );

  p->self_yecep = (CORBA_Object)yoCreate(yeceCa_ProxyPushSupp__id,
				   (char*)0, (yoRefData*)0,
				   (char*)0, (dvoid*)p );
  return( (yeceCa_ProxyPushSupp)yoDuplicate((dvoid*)p->self_yecep) );
}

/* ARGSUSED */
yeceCa_ProxyPullSupp yeceCa_ConsAdm_obtain_pull_supp_i( yeceCa_ConsAdm or,
						       yoenv* ev)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);
  yecesc *sc = yeceGetSubChannel( ch, (char*)0 );
  yecep *p = yeceNewParty( sc );

  p->q_yecep = ysLstCreate();
  p->self_yecep = (CORBA_Object)yoCreate(yeceCa_ProxyPullSupp__id,
				   (char*)0, (yoRefData*)0,
				   (char*)0, (dvoid*)p );
  return( (yeceCa_ProxyPullSupp)yoDuplicate((dvoid*)p->self_yecep) );
}


/* ---------------------------------------------------------------- */

/* used by suppliers to get proxy consumers */

/* ARGSUSED */
yeceCa_ProxyPushCons yeceCa_SuppAdm_obtain_push_cons_i( yeceCa_SuppAdm or,
						       yoenv* ev)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);
  yecesc *sc = yeceGetSubChannel( ch, (char*)0 );
  yecepc *pc = yeceNewProxyConsumer(sc); 

  pc->self_yecepc = (CORBA_Object)yoCreate( yeceCa_ProxyPushCons__id,
				      (char*)0, (yoRefData*)0,
				      (char*)0, (dvoid*)pc );
  return( (yeceCa_ProxyPushCons)yoDuplicate((dvoid*)pc->self_yecepc) );
}

/* ARGSUSED */
yeceCa_ProxyPullCons yeceCa_SuppAdm_obtain_pull_cons_i( yeceCa_SuppAdm or,
						       yoenv* ev)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);
  yecesc *sc = yeceGetSubChannel( ch, (char*)0 );
  yecepc *pc = yeceNewProxyConsumer(sc); 

  pc->pull_yecepc = TRUE;
  pc->self_yecepc = (CORBA_Object)yoCreate( yeceCa_ProxyPullCons__id,
				      (char*)0, (yoRefData*)0,
				      (char*)0, (dvoid*)pc );
  return( (yeceCa_ProxyPullCons)yoDuplicate((dvoid*)pc->self_yecepc) );
}


/* ---------------------------------------------------------------- */

/* ARGSUSED */
yeceCa_ConsAdm yeceCa_EventChannel_for_consumers_i( yeceCa_EventChannel or,
						   yoenv* ev)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);
  return( (yeceCa_ConsAdm)yoDuplicate((dvoid*)ch->cself_yecech) );
}

/* ARGSUSED */
yeceCa_SuppAdm yeceCa_EventChannel_for_suppliers_i( yeceCa_EventChannel or,
						   yoenv* ev)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);

  return( (yeceCa_SuppAdm)yoDuplicate((dvoid*)ch->sself_yecech) );
}

/* ARGSUSED */
void yeceCa_EventChannel_destroy_i( yeceCa_EventChannel or, yoenv* ev)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);
  
  /* 531, "yeceCa_EventChannel_destroy: or %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)531, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&or), YSLEND );

  DISCARD ysLstRem( ch->cx_yecech->ch_yececx, ch->le_yecech );
  yeceDestroyChannel( ch );
}


/* ---------------------------------------------------------------- */

/* ARGSUSED */
yeceCa_EventChannel yeceCa_Factory_create_i( yeceCa_Factory or, yoenv* ev)
{
  yececx *cx = (yececx*)yoGetImplState((dvoid*)or);
  yecech *ch = (yecech*)0; 

  ch = yeceNewChannel( cx, FALSE );

  /* 532, "yeceCa_Factory_create:  new channel %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)532, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,ch->typed_yecech ?
		  (dvoid*)&ch->tself_yecech : (dvoid*)&ch->self_yecech),
	   YSLEND);

  return( (yeceCa_EventChannel)yoDuplicate((dvoid*)ch->self_yecech) );
}


/* ARGSUSED */
yeceCa_eventChannelList
yeceCa_Factory__get_channels_i( yeceCa_Factory or, yoenv* ev)
{
  yeceCa_eventChannelList olist;

  yececx *cx = (yececx*)yoGetImplState((dvoid*)or);
  yecech *ch;
  ysle	*e;
  
  /* 534, "yeceCa_Factory__get_channels: or %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)534, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&or), YSLEND );

  olist._maximum = ysLstCount( cx->ch_yececx );
  olist._length = 0;
  olist._buffer = (yeceCa_EventChannel*)yoAlloc(olist._maximum *
						sizeof(yeceCa_EventChannel));
  for( e = ysLstHead(cx->ch_yececx) ; e ; e = ysLstNext( e ) )
  {
    ch = (yecech*)ysLstVal(e);
    if( !ch->typed_yecech ) 
      olist._buffer[olist._length++] =
	(yeceCa_EventChannel)yoDuplicate( (dvoid*)ch->self_yecech);
  }
  return( olist );
}

/* ARGSUSED */
yeceCa_Factory yeceCa_Factory__get_self_i( yeceCa_Factory or, yoenv* ev)
{
  yececx *cx = (yececx*)yoGetImplState((dvoid*)or);

  /* 535, "yeceCa_Factory__get_self:  or %s, returning %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)535, YSLSEV_DEBUG(2), (char*)0,
	   "yeceCa_Factory__get_self: or %s, returning %s\n",
	   YSLANY(yoTcObject,&or),
	   YSLANY(yoTcObject,&cx->self_yececx), YSLEND );

  return( (yeceCa_Factory)yoDuplicate((dvoid*)cx->self_yececx) );
}


/* ---------------------------------------------------------------- */
/* MODULE TypedEventComm not used in the channel server */
/* ---------------------------------------------------------------- */

/* ---------------------------------------------------------------- */

void yeceTeca_TypedProxyPushCons_push_i( yeceTeca_TypedProxyPushCons or,
					yoenv* ev, yoany* data)
{
  yeceCa_ProxyPushCons_push_i( (yeceCa_ProxyPushCons)or, ev, data );
}

void yeceTeca_TypedProxyPushCons_disconnect_i( yeceTeca_TypedProxyPushCons or,
					      yoenv* ev)
{
  yeceCa_ProxyPushCons_disconnect_i( (yeceCa_ProxyPushCons)or, ev );
}

void
yeceTeca_TypedProxyPushCons_connect_push_supp_i(yeceTeca_TypedProxyPushCons or,
						yoenv* ev,
						yecec_PushSupp push_supp)
{
  /* 536,
     "yeceTeca_TypedProxyPushCons_connect_push_supp: or %s push_supp %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)536, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&or),
	   YSLANY(yoTcObject,&push_supp), YSLEND );

  yeceCa_ProxyPushCons_connect_push_supp_i( (yeceCa_ProxyPushCons)or,
					   ev, push_supp );
}

/* ARGSUSED */
CORBA_Object
yeceTeca_TypedProxyPushCons_get_typed_cons_i( yeceTeca_TypedProxyPushCons or,
					     yoenv* ev)
{
  yecepc *pc = (yecepc*)yoGetState((dvoid*)or);

  /* 537, "yeceTeca_TypedProxyPushCons_get_typed_cons: or %p, intf %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)537, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&or),
	   YSLSTR(yeuStr((char*)pc->sc_yecepc->node_yecesc.key_ysspNode)),
	   YSLEND);

  /* Create a proxy object to the DSI enabled interface.  Methods on
     this object end up in yeceProxyConsumer(). */

  pc->proxy_yecepc = yoCreate( (char*)pc->sc_yecepc->node_yecesc.key_ysspNode,
			      (char*)0, (yoRefData*)0, (char*)0, (dvoid*)pc );

  /* 538, "yeceTeca_TypedProxyPushCons_get_typed_cons:  return %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)538, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&pc->proxy_yecepc), YSLEND);

  return( (CORBA_Object)yoDuplicate((dvoid*)pc->proxy_yecepc) );
}


/* ---------------------------------------------------------------- */

/* ARGSUSED */
yoany yeceTeca_TypedProxyPullSupp_pull_i( yeceTeca_TypedProxyPullSupp or,
					 yoenv* ev)
{
  yoany rv;
  CLRSTRUCT(rv);

  yseThrow( YECE_EX_UNIMPL );
  return(rv);
}

/* ARGSUSED */
yoany yeceTeca_TypedProxyPullSupp_try_pull_i( yeceTeca_TypedProxyPullSupp or,
					     yoenv* ev, boolean* has_event)
{
  yoany rv;
  CLRSTRUCT(rv);

  yseThrow( YECE_EX_UNIMPL );
  return(rv);
}

/* ARGSUSED */
void yeceTeca_TypedProxyPullSupp_disconnect_i(yeceTeca_TypedProxyPullSupp or,
					      yoenv* ev)
{
  yseThrow( YECE_EX_UNIMPL );
}

/* ARGSUSED */
void
yeceTeca_TypedProxyPullSupp_connect_pull_cons_i(yeceTeca_TypedProxyPullSupp or,
						yoenv* ev,
						yecec_PullCons pull_cons)
{
  yseThrow( YECE_EX_UNIMPL );
}

/* ARGSUSED */
CORBA_Object
yeceTeca_TypedProxyPullSupp_get_typed_supp_i( yeceTeca_TypedProxyPullSupp or,
					     yoenv* ev)
{
  yseThrow( YECE_EX_UNIMPL );
  return( (CORBA_Object)0 );
}


/* ---------------------------------------------------------------- */

yeceCa_ProxyPushCons
yeceTeca_TypedSuppAdm_obtain_push_cons_i( yeceTeca_TypedSuppAdm or, yoenv* ev)
{
  return( yeceCa_SuppAdm_obtain_push_cons_i( (yeceCa_SuppAdm)or, ev ) );
}

yeceCa_ProxyPullCons
yeceTeca_TypedSuppAdm_obtain_pull_cons_i( yeceTeca_TypedSuppAdm or, yoenv* ev)
{
  return( yeceCa_SuppAdm_obtain_pull_cons_i( (yeceCa_SuppAdm)or, ev ) );
}

/* ARGSUSED */
yeceTeca_TypedProxyPushCons
yeceTeca_TypedSuppAdm_obtain_typed_push_cons_i( yeceTeca_TypedSuppAdm or,
					       yoenv* ev,
					       char* supported_interface)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);
  yecesc *sc = yeceGetSubChannel( ch, supported_interface );
  yecepc *pc = yeceNewProxyConsumer(sc); 

  /* 539, "yeceTeca_TypedSuppAdm_obtain_typed_push_cons: or %s intf %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)539, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&or), YSLSTR(supported_interface), YSLEND );

  pc->self_yecepc = (CORBA_Object)yoCreate( yeceTeca_TypedProxyPushCons__id,
				      (char*)0, (yoRefData*)0,
				      (char*)0, (dvoid*)pc );
  return( (yeceTeca_TypedProxyPushCons)yoDuplicate((dvoid*)pc->self_yecepc ));
}

/* ARGSUSED */
yeceCa_ProxyPullCons
yeceTeca_TypedSuppAdm_obtain_typed_pull_cons_i( yeceTeca_TypedSuppAdm or,
					       yoenv* ev,
					       char* uses_interface)
{
  yseThrow( YECE_EX_UNIMPL );
  return( (yeceCa_ProxyPullCons)0 );
}


/* ---------------------------------------------------------------- */
	
yeceCa_ProxyPushSupp
yeceTeca_TypedConsAdm_obtain_push_supp_i( yeceTeca_TypedConsAdm or, yoenv* ev)
{
  return( yeceCa_ConsAdm_obtain_push_supp_i( (yeceCa_ConsAdm)or, ev ) );
}

yeceCa_ProxyPullSupp
yeceTeca_TypedConsAdm_obtain_pull_supp_i( yeceTeca_TypedConsAdm or, yoenv* ev)
{
  return( yeceCa_ConsAdm_obtain_pull_supp_i( (yeceCa_ConsAdm)or, ev ) );
}

/* ARGSUSED */
yeceTeca_TypedProxyPullSupp
yeceTeca_TypedConsAdm_obtain_typed_pull_supp_i( yeceTeca_TypedConsAdm or,
					       yoenv* ev,
					       char* supported_interface)
{
  yseThrow( YECE_EX_UNIMPL );
  return((yeceTeca_TypedProxyPullSupp)0);
}

/* ARGSUSED */
yeceCa_ProxyPushSupp
yeceTeca_TypedConsAdm_obtain_typed_push_supp_i( yeceTeca_TypedConsAdm or,
					       yoenv* ev,
					       char* uses_interface)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);
  yecesc *sc = yeceGetSubChannel( ch, uses_interface );
  yecep *p = yeceNewParty( sc );

  p->self_yecep = (CORBA_Object)yoCreate(yeceCa_ProxyPushSupp__id,
				   (char*)0, (yoRefData*)0,
				   (char*)0, (dvoid*)p );
  return( (yeceCa_ProxyPushSupp)yoDuplicate((dvoid*)p->self_yecep) );
}


/* ARGSUSED */
yeceTeca_TypedConsAdm
yeceTeca_TypedEventChannel_for_consumers_i( yeceTeca_TypedEventChannel or,
					   yoenv* ev)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);

  /* 540, "yeceTeca_TypedEventChannel_for_consumers: return %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)540, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&ch->tcself_yecech), YSLEND );

  return( (yeceTeca_TypedConsAdm)yoDuplicate((dvoid*)ch->tcself_yecech) );
}

/* ARGSUSED */
yeceTeca_TypedSuppAdm
yeceTeca_TypedEventChannel_for_suppliers_i( yeceTeca_TypedEventChannel or,
					   yoenv* ev)
{
  yecech *ch = (yecech*)yoGetState((dvoid*)or);

  /* 541, "yeceTeca_TypedEventChannel_for_suppliers: return %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)541, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&ch->tsself_yecech), YSLEND );

  return( (yeceTeca_TypedSuppAdm)yoDuplicate((dvoid*)ch->tsself_yecech ) );
}


/* ---------------------------------------------------------------- */


/* ARGSUSED */
yeceTeca_TypedEventChannel
yeceTeca_Factory_create_i( yeceTeca_Factory or, yoenv* ev)
{
  yececx *cx = (yececx*)yoGetImplState((dvoid*)or);
  yecech *ch = (yecech*)0; 
 
  ch = yeceNewChannel( cx, TRUE );

  /* 542, "yece_create:  returning %s"  */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)542, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&ch->tself_yecech), YSLEND );

  return( (yeceTeca_TypedEventChannel)yoDuplicate((dvoid*)ch->tself_yecech ));
}

/* ARGSUSED */
yeceTeca_typedEventChannelList
yeceTeca_Factory__get_channels_i( yeceTeca_Factory or, yoenv* ev)
{
  yeceTeca_typedEventChannelList olist;

  yececx *cx = (yececx*)yoGetImplState((dvoid*)or);
  yecech *ch;
  ysle	*e;
  
  /* 544, "yeceTeca_Factory__get_channels:  or %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)544, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&or), YSLEND);

  olist._maximum = ysLstCount( cx->ch_yececx );
  olist._length = 0;
  olist._buffer =
    (yeceTeca_TypedEventChannel*)yoAlloc(olist._maximum *
					 sizeof(yeceCa_EventChannel));
  for( e = ysLstHead(cx->ch_yececx) ; e ; e = ysLstNext( e ) )
  {
    ch = (yecech*)ysLstVal(e);
    if( ch->typed_yecech ) 
      olist._buffer[olist._length++] =
	(yeceTeca_TypedEventChannel)yoDuplicate( ch->tself_yecech );
  }
  return( olist );
}

/* ARGSUSED */
yeceTeca_Factory yeceTeca_Factory__get_self_i( yeceTeca_Factory or, yoenv* ev)
{
  yececx *cx = (yececx*)yoGetImplState((dvoid*)or);

  /* 546, "yeceTeca_Factory__get_self:  or %s, returning %s" */
  ysRecord(YS_PRODUCT,YECE_FAC,(ub4)545, YSLSEV_DEBUG(2), (char*)0,
	   YSLANY(yoTcObject,&or),
	   YSLANY(yoTcObject,&cx->tself_yececx), YSLEND);

  return( (yeceTeca_Factory)yoDuplicate((dvoid*)cx->tself_yececx) );
}



