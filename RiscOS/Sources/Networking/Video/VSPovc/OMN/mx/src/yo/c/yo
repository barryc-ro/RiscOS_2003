/* Copyright (c) 1996, 1995 by Oracle Corporation.  All Rights Reserved.
 *
 * yo.c - Object Runtime Layer Services
 */

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif
#ifndef YSR_ORACLE
#include <ysr.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif
#ifndef YSTHR_ORACLE
#include <ysthr.h>
#endif
#ifndef YOT_ORACLE
#include <yot.h>
#endif
#ifndef YOI_ORACLE
#include <yoi.h>
#endif
#ifndef YOYD_ORACLE
#include <yoyd.h>
#endif
#ifndef YDYOIDL_ORACLE
#include <ydyoidl.h>
#endif
#ifndef YOCY_ORACLE
#include <yocy.h>
#endif

/* Memory Manager Tags */
externdef ysmtagDecl(yoTagObjRef) = "yoObjRef";
externdef ysmtagDecl(yoTagMsgDesc) = "yomd";
externdef ysmtagDecl(yoTagYoAlloc) = "yoAlloc";
externdef ysmtagDecl(yoTagStrCache) = "yoStrCache";
externdef ysmtagDecl(yoTagQueInfo) = "yoQue";
externdef ysmtagDecl(yoTagCur) = "yoCur";

/* Exceptions */
externdef ysidDecl(YO_EX_BADREFSTR) = "yo::badrefstr";
externdef ysidDecl(YO_EX_UNIMPLEMENTED) = "yo::unimplemented";
externdef ysidDecl(YO_EX_INTERNAL) = "yo::internal";
externdef ysidDecl(YO_EX_UNEXPECTED) = "yo::unexpected";
externdef ysidDecl(YO_EX_NOOPT) = "yo::noopt";
externdef ysidDecl(YO_EX_BADOBJ) = "yo::badobj";
externdef ysidDecl(YO_EX_BADOPER) = "yo::badoper";
externdef ysidDecl(YO_EX_NORES) = "yo::nores";

/* Builtin sequence typecodes */
/* DISABLE check_naming */
static CONST_DATA yotk yoTc_seq_sb2[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x02, 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTc_seq_sb4[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03, 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTc_seq_ub2[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x04, 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTc_seq_ub4[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x05, 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTc_seq_boolean[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x08, 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTc_seq_char[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x09, 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTc_seq_ub1[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0a, 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTc_seq_yoany[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0b, 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTc_seq_TypeCode[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTc_seq_string[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x10, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x12, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTc_seq_sysb8[] =
{ 0x00,0x00,0x00,0x13, 0x00,0x00,0x00,0x0c, 0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x17, 0x00,0x00,0x00,0x00 };

externdef CONST_DATA yotk yoevm__tc[] =
  {0x00,0x00,0x00,0x0f,0x00,0x00,0x00,'L',0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0e,'I','D','L',':','y','o','e','v','m',':',
  '1','.','0',0x00,0x00,0x00,0x00,0x00,0x00,0x08,':',':','y','o'
  ,'e','v','m',0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x05,'n'
  ,'a','m','e',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x06,'v','a','l','u','e',0x00,0x00
  ,0x00,0x00,0x00,0x00,0x0b};

externdef CONST_DATA yotk yoenv__tc[] =
  {0x00,0x00,0x00,0x15,0x00,0x00,0x00,0x88,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x0e,'I','D','L',':','y','o','e','n','v',':'
  ,'1','.','0',0x00,0x00,0x00,0x00,0x00,0x00,0x08,':',':','y',
  'o','e','n','v',0x00,0x00,0x00,0x00,0x13,0x00,0x00,0x00,0x5c
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,'L',
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,'I','D','L',':','y',
  'o','e','v','m',':','1','.','0',0x00,0x00,0x00,0x00,0x00,0x00
  ,0x08,':',':','y','o','e','v','m',0x00,0x00,0x00,0x00,0x02,0x00
  ,0x00,0x00,0x05,'n','a','m','e',0x00,0x00,0x00,0x00,0x00,0x00
  ,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,'v','a','l'
  ,'u','e',0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x00
  };

/* ENABLE check_naming */

/* private types */
typedef struct yostrc yostrc;                          /* string cache entry */
struct yostrc
{
  ub4 ucnt;
  char str[1];
};

/* Static Functions */
#define yoRemPendReq(ctx,id) \
  ((yocreq *)(ysHshRem(ctx->preqs,(dvoid *)&id,sizeof(ub4))))
#define yoGetPendReq(ctx,id) \
  ((yocreq *)(ysHshFind(ctx->preqs,(dvoid *)&id,sizeof(ub4))))
STATICF ub4 yoRefHash(CONST dvoid *ref, size_t dummy, ub4 max);
STATICF void yoExistsCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                            size_t argsz);
STATICF void yoExistsHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                          size_t argsz);
STATICF void yoOneWayLocReqH(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                             size_t argsz);
STATICF yocreq *yoCReqCreate(yoctx *ctx, ub4 type, yoo *ref, yosvcxs *svcx,
                             CONST char *op, boolean response, ysevt *evt,
                             CONST yopar *pars);
STATICF void yoCReqSend(yoctx *ctx, yocreq *req, ysbv *bv, sword nbv);
STATICF void   yoSndReqCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                              size_t argsz);
STATICF boolean yoReqQSend(yoctx *ctx, yslst *sndq);
STATICF void   yoReqQSendHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                              size_t argsz);
STATICF void yoReqTimeout(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                          size_t argsz);
STATICF void yoRepHdrFree(yoreph *hdr);
STATICF void   yoRepRcv(yoctx *ctx, yomd *noreg md, ub4 type);
STATICF sword  yoReqEq(dvoid *elm, dvoid *key, size_t keysz);
STATICF yocreq *yoReqRepRcv(yoctx *ctx, yocreq *req, yoreph *hdr, yomd *md);
STATICF yocreq *yoLocReqRepRcv(yoctx *ctx, yocreq *req, yoreph *hdr, yomd *md);
STATICF void   yoMsgWaitHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                            size_t argsz);
STATICF void   yoMsgRcvHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                           size_t argsz);
STATICF void yoHbWaitHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                          size_t argsz);
STATICF void yoHbRcvHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                          size_t argsz);
STATICF void   yoIdle(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                      size_t argsz);
STATICF void   yoLocateORBD(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                      size_t argsz);
STATICF void yoFreeCliReqFF(dvoid *ptr);
STATICF void yoFreeCliReq(yoctx *ctx, yocreq *req);
STATICF void yoFreeCliReqF(yoctx *ctx, yocreq *req);
STATICF sword yoStrEq(dvoid *elm, dvoid *key, size_t keysz);
STATICF sword yoPardEq(dvoid *elm, dvoid *key, size_t keysz);
STATICF boolean yoIsARemote(dvoid *ref, CONST char *intf);

void yoInit(void)
{
  yoctx *ctx;
  char *res;
  sysb8 mult;
  sb4 hbi, toi;
  size_t sndhsz, rcvhsz;

  if ((ctx = yoCtx) && ctx->yoinit++) return;    /* maintain refcnt for init */
  
  /* grock resources */
  hbi = YO_REQ_HB;
  toi = 0;
  sysb8ext(&mult, 1000000);               /* convert seconds to microseconds */
  sndhsz = rcvhsz = 0;

  /* hbi == 0 turns off heartbeats */
  if((res = ysResGetLast("yo.req-heart-secs")))
    hbi = atoi(res);
  if(hbi < 0) hbi = YO_REQ_HB;

  if((res = ysResGetLast("yo.req-timeout-secs")))
    toi = atoi(res);
  if(toi <= 0) toi = YO_REQ_TO;

  /* sanity check hbi, if set at all */
  if(hbi > (toi/2)) hbi = toi / 2;

  if((res = ysResGetLast("yo.rcv-heap-kb")))
    rcvhsz = atoi(res);
  if(rcvhsz) rcvhsz *= 1024;

  if((res = ysResGetLast("yo.snd-heap-kb")))
    sndhsz = atoi(res);
  if(sndhsz) sndhsz *= 1024;

  ctx = (yoctx *) ysmGlbAlloc(sizeof(yoctx),"yoctx");

  /* cache expensive to retrieve values */
  ctx->hostname = ysGetHostName();
  ctx->pid = ysGetPid();

  ctx->flags = 0;
  ctx->yoinit = 1;

  /* event queue for YO events */
  ctx->evtq = ysQueCreate((dvoid *)ctx);

  /* send and receive heaps */
  if(rcvhsz)
  {
    ctx->rcvbuf.len = rcvhsz;
    ctx->rcvbuf.buf = (ub1 *) ysmGlbAlloc(ctx->rcvbuf.len,"rcvheap");
    ctx->rcvhp = ysmCreate((ysmaf)0, (ysmrf)0, (ysmff)0, &ctx->rcvbuf, 1);
  }
  else
  {
    ctx->rcvbuf.len = 0;
    ctx->rcvbuf.buf = (ub1 *) 0;
    ctx->rcvhp = ysmGlbHeap();
  }
  if(sndhsz)
  {
    ctx->sndbuf.len = sndhsz;
    ctx->sndbuf.buf = (ub1 *) ysmGlbAlloc(ctx->sndbuf.len,"sndheap");
    ctx->sndhp = ysmCreate((ysmaf)0, (ysmrf)0, (ysmff)0, &ctx->sndbuf, 1);
  }
  else
  {
    ctx->sndbuf.len = 0;
    ctx->sndbuf.buf = (ub1 *) 0;
    ctx->sndhp = ysmGlbHeap();
  }

  ctx->fltrs = ysLstCreate();

  /* string table for id's and resources */
  ctx->strs = ysHshCreate((ub4)257,(yshash)0,yoStrEq,ysmFGlbFree);

  /* object references */
  ctx->refs = ysHshCreate((ub4)257,yoRefHash,yoRefEq,yoFreeRef);

  /* yopar's for all client and server */
  ctx->partab = ysHshCreate((ub4)257,(yshash)0,yoPardEq,ysmFGlbFree);

  /* server side request processing init */
  ctx->intfs = ysHshCreate((ub4)257,ysHshKey,yoIntfEq,yoFreeImpLst);
  ctx->stateid = YOSTID_BASE;
  ctx->srvmeml = ysThrKeyCreate();
  ctx->deltaq = ysLstCreate();
  ctx->dqesem = (ysevt *) 0;
  ctx->iirefl = ysLstCreate();
  ctx->dspreq = ysThrKeyCreate();
  ctx->actreqs = ysLstCreate();
  ctx->replst = ysLstCreate();                /* replies currently in flight */
  sysb8ext(&ctx->reqhb,hbi);                   /* request heartbeat interval */
  sysb8mul(&ctx->reqhb,&ctx->reqhb,&mult);
  ctx->yoques = ysLstCreate();
  ctx->svclps = ysLstCreate();
  ctx->ltridseq = 1;
  ctx->scq = ysQueCreate((dvoid *)0);
  ctx->cur = ysThrKeyCreate();                            /* yocur by thread */

  /* client side data */
  ctx->rrport = yotOpen(YOTPROTO_MESSAGE);
  yotBind(ctx->rrport,YO_RRPORT);
  ctx->rrpaddr = yotGetAddr(ctx->rrport);
  ctx->rrevt = (ysevt *) 0;
  ctx->hbport = yotOpen(YOTPROTO_MESSAGE);
  yotBind(ctx->hbport,YO_HBPORT);
  ctx->hbevt = (ysevt *) 0;
  ctx->preqs = ysHshCreate((ub4)257,ysHshKey,yoReqEq,yoFreeCliReqFF);
  ctx->reqid = 1;
  ysMtxCreate(&ctx->ydmtx,YSMTXTYPE_NORMAL);
  ysCondCreate(&ctx->ydcv);
  ctx->ydaddr = (yota *) 0;
  ctx->ydimref = (yoo *) 0;
  ctx->reqsndq = ysLstCreate();
  sysb8ext(&ctx->reqto,toi);                        /* request timeout value */
  sysb8mul(&ctx->reqto,&ctx->reqto,&mult);

  /* init routing activities - shutdown */
  ctx->rtq = (ysque *) 0;
  ctx->rtpnm = (ysstr *) 0;
  ctx->rthdlr = (ysHndlr) 0;
  ctx->rtusrp = (dvoid *) 0;

  /* init bridge actitivites */
  ctx->iiopbr = yotStrToAddr(YOBR_IIOP_ADDR);
  ctx->iiopexta = (char *)0;
  ctx->iiopextp = 0;

  /* FIXME: bridge bootstapping hack */
  if((res = ysResGetLast("yo.bridge-iiop-addr")))
  {
    char *cp;

    cp = strchr(res,':');
    if(cp)
    {
      ctx->iiopexta = (char *)ysStrDup(res);
      cp = strchr(ctx->iiopexta,':');
      *cp = '\0';
      ctx->iiopextp = (ub2) atoi(cp+1);
    }
  }


  DISCARD yscSet(YSC_YOCTX,(dvoid *)ctx);

  ysSinkRegister((ub1 *)0,0,(ysSinkFmtCB)yotkFormat,(ysSinkEncCB)yotkEncode);


  /* Setup Object Runtime Management Stuff */
  ctx->yort = (yoo *) 0;

  /* perhaps install idler to dequeue events */
  ctx->yoidle = 0;
  ysSetIdler("yoIdle()",yoIdle,(dvoid *)ctx);

  yortInit(ctx);
  yoevtInit(ctx);

  /* default request queue */
  ctx->reqq = yoQueCreate("yo-default");

  yocyInit(ctx);
  yoDeadORBD(ctx);
}

STATICF boolean yoShowRef(dvoid *usrp /* ARGUSED */, dvoid *elm)
{
  yoo *r = (yoo *)elm;
  char abuf[YOTAMAXLEN];
  CONST char *astr = "<null>";

  if(r->addr)
  {
    DISCARD yotAddrToStr(r->addr,abuf,sizeof(abuf));
    astr = abuf;
  }

  yslError("r=%p if=%s im=%s ad=%s id=%u uc=%u  st=%p\n", r,
           yoStr(ysidToStr(r->intf)), yoStr(r->impl), astr, r->key,
           r->ucnt, r->state);

  return TRUE;
}

void yoTerm(void)
{
  yoctx *ctx;
  ysevt *sem;
  ysque *q;

  if(!(ctx = yoCtx)) return;                      /* make yoTerm idempotent */
  if(--ctx->yoinit)  return;                             /* maintain refcnt */

  yoevtTerm(ctx);
  yortTerm(ctx);

  yoTermRouter();                                         /* if routing stop */

  /* remove YORT from ORBD if it was aware of it */
  if(bit(ctx->flags,YOCTXFL_SNTYORT) && ctx->ydimref)
  {
    yoenv ev;

    yoEnvInit(&ev);
    yseTry
      ydyo_imr_destroyYortGlobal((ydyo_imr)(dvoid*)ctx->ydimref, &ev,
                                 (yort_proc)(dvoid*)ctx->yort);
    yseCatchAll
    {
    }
    yseEnd;
    yoEnvFree(&ev);
  }

  /* wait for delta queue to clear */
  ctx->dqesem = sem = ysSemCreate((dvoid *)0);
  ysSemWait(sem);
  ysSemDestroy(sem);

  /* send all pending requests */
  if(ysLstCount(ctx->reqsndq))
    DISCARD yoReqQSend(ctx, ctx->reqsndq);

  q = ctx->evtq;
  ctx->evtq = (ysque *) 0;
  ysQueDestroy(q);
  q = ctx->scq;
  ctx->scq = (ysque *) 0;
  ysQueDestroy(q);
  yoQueDestroy(ctx->reqq);

  ysHshDestroy(ctx->preqs);

  ysSetIdler("yoIdle()",(ysHndlr)0,(dvoid *)0);

  yotClose(ctx->rrport);
  yotClose(ctx->hbport);
  yocyTerm(ctx);

  if(ctx->yort)
    yoRelease((dvoid *)ctx->yort);
  if(ctx->ydimref)
    yoRelease((dvoid *)ctx->ydimref);
  ysHshDestroy(ctx->intfs);                   /* release implementation OR's */

  ysSinkRegister((ub1 *)0,0,(ysSinkFmtCB)0,(ysSinkEncCB)0);

  ysLstDestroy(ctx->replst, yoFreeRepLst);      /* free pending reply memory */

  /* must release all object refs and such before the context gets wrecked */
  DISCARD yscSet(YSC_YOCTX,(dvoid *)0);

  if(ysResGetBool("yo.dump-leaked-refs"))
    ysHshWalk(ctx->refs, yoShowRef, (dvoid *)0);
  ysHshDestroy(ctx->refs);

  ysHshDestroy(ctx->strs);
  ysHshDestroy(ctx->partab);

  ysLstDestroy(ctx->deltaq, (ysmff) 0);
  ysLstDestroy(ctx->iirefl, (ysmff) 0);
  ysLstDestroy(ctx->actreqs, (ysmff) 0);
  ysLstDestroy(ctx->yoques, (ysmff) 0);
  ysLstDestroy(ctx->svclps, (ysmff) 0);

  ysMtxDestroy(&ctx->ydmtx);
  ysCondDestroy(&ctx->ydcv);
  if(ctx->rrpaddr)
    yotAddrFree(ctx->rrpaddr);
  if(ctx->ydaddr)
    yotAddrFree(ctx->ydaddr);
  if(ctx->iiopbr)
    yotAddrFree(ctx->iiopbr);
  if(ctx->iiopexta)
    ysmGlbFree((dvoid *)ctx->iiopexta);

  ysLstDestroy(ctx->reqsndq, (ysmff) 0 /* FIXME: should do right */);
  ysLstDestroy(ctx->fltrs, ysmFGlbFree);

  ysThrKeyDestroy(ctx->srvmeml);
  ysThrKeyDestroy(ctx->dspreq);
  ysThrKeyDestroy(ctx->cur);

  ysmGlbFree((dvoid *)ctx);
}

CONST ysid *yoGetInterface(CONST dvoid *ref)
{
  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);
  return ((yoo *)ref)->intf;
}

CONST char *yoGetImplementation(CONST dvoid *ref)
{
  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);
  return ((yoo *)ref)->impl;
}

dvoid *yoDuplicate(CONST dvoid *ref)
{
  if(ref)
  {
    ysmCheck(ref,yoTagObjRef);
    if(bit(((yoo *)ref)->flags,YOOFL_DEBUG))                /* debugging aid */
      yoCheckRefcnt_here(ref,((yoo *)ref)->ucnt);
    ((yoo *)ref)->ucnt++;
  }

  return (dvoid *)ref;
}

void yoRelease(dvoid *ref)
{
  yoo *r;
  dvoid *fnd;
  yoctx *ctx;

  if(!ref) return;

  ysmCheck(ref,yoTagObjRef);
  r = (yoo *)ref;

  if(bit(r->flags,YOOFL_DEBUG))                             /* debugging aid */
    yoCheckRefcnt_here(ref,r->ucnt);

  if(!r->ucnt)
    yseThrow(YS_EX_BADPARAM);

  ctx = yoCtx;

  if(--(r->ucnt) == 0 &&
     (!r->addr || !r->key || !yotAddrEq(ctx->rrpaddr,r->addr) ||
      bit(r->flags,YOOFL_INVALID)))
  {
    fnd = ysHshRem(ctx->refs,(dvoid *)r,sizeof(yoo));
    yoFreeRef(ref);
    if(fnd != ref)
      yseThrow(YO_EX_INTERNAL);
  }
}

ub4 yoRefCnt(CONST dvoid *ref)
{
  if(!ref)
    yseThrow(YS_EX_BADPARAM);

  ysmCheck(ref,yoTagObjRef);

  return ((yoo *)ref)->ucnt;
}

boolean yoIsEq(CONST dvoid *ref1, CONST dvoid *ref2)
{
  if(ref1)
    ysmCheck(ref1,yoTagObjRef);
  if(ref2)
    ysmCheck(ref2,yoTagObjRef);

  return (ref1 == ref2);
}

ub4 yoHash(CONST dvoid *ref, size_t dummy, ub4 max)
{
  if(ref)
    ysmCheck(ref,yoTagObjRef);

  return yoRefHash(ref,dummy,max);
}

STATICF ub4 yoRefHash(CONST dvoid *ref, /* ARGUSED */ size_t dummy, ub4 max)
{
  ub4 hash;
  yoo *r = (yoo *)ref;
  ub1 *cp;
  ub1 *end;

  hash = 0;
  if(!ref)
    return hash;

  if(bit(r->flags,YOOFL_IOR))
  {
    hash = yogiHashIOR(&r->ior);
  }
  else if(r->key != YOSTID_INV)
  {
    /* generate has based on key and address */
    hash = r->key;
    hash += yotHashAddr(r->addr);
  }
  else
  {
    if(r->intf)
      for(cp = (ub1 *)ysidToStr(r->intf); *cp; cp++)
        hash += *cp;
    if(r->impl)
      for(cp = (ub1 *)r->impl; *cp; cp++)
        hash += *cp;
    if(r->id._length)
    {
      end = r->id._buffer + r->id._length;
      for(cp = r->id._buffer; cp < end; cp++)
        hash += *cp;
    }
  }
  return hash % max;
}

sword yoCmp(CONST dvoid *ref1, CONST dvoid *ref2)
{
  sword val = 0;
  yoo *r1, *r2;
  boolean iorf;

  if(ref1)
    ysmCheck(ref1,yoTagObjRef);
  if(ref2)
    ysmCheck(ref2,yoTagObjRef);

  if(ref1 != ref2)
  {
    if(!ref1) return -1;
    if(!ref2) return 1;

    r1 = (yoo *)ref1;
    r2 = (yoo *)ref2;

    if((iorf = (boolean)bit(r1->flags,YOOFL_IOR)) != bit(r2->flags,YOOFL_IOR))
      return (sword) (bit(r1->flags,YOOFL_IOR) - bit(r2->flags,YOOFL_IOR));
    if(iorf)
      return yogiCmpIOR(&r1->ior, &r2->ior);

    /* compare state id */
    if(r1->key != r2->key)
      return (r1->key < r2->key) ? -1 : 1;

    /* compare target address */
    if(!r1->addr || !r2->addr)
    {
      if(r1->addr != r2->addr)
      {
        if(!r1->addr)
          val = -1;
        else
          val = 1;
      }
    }
    else
      val = (sword) memcmp((dvoid *)r1->addr,(dvoid *)r2->addr,sizeof(yota));

    /* stop here if tightly bound reference w/ state and addr matching or
       an addr mismatch
     */
    if(r1->key || val) return val;

    /* compare interface */
    if(r1->intf && r2->intf)
      val = (sword) strcmp(ysidToStr(r1->intf),ysidToStr(r2->intf));
    else
    {
      if(r1->intf != r2->intf)
      {
        if(r1->intf)
          val = 1;
        else
          val = -1;
      }
    }
    if(val) return val;

    /* compare implementation */
    if(r1->impl && r2->impl)
      val = (sword) strcmp(r1->impl,r2->impl);
    else
    {
      if(r1->impl != r2->impl)
      {
        if(r1->impl)
          val = 1;
        else
          val = -1;
      }
    }
    if(val) return val;

    /* compare refdata */
    if(r1->id._length != r2->id._length)
      return (r1->id._length < r2->id._length) ? -1 : 1;
    if(r1->id._length)
    {
      val = (sword) memcmp((dvoid *)r1->id._buffer,(dvoid *)r2->id._buffer,
                           (size_t)r1->id._length);
      if(val) return val;
    }

    yseThrow(YO_EX_INTERNAL);                       /* should never get here */
  }

  return val;
}

char *yoRefToStr(CONST dvoid *ref)
{
  yosx *x;
  ysstr *str;
  ysbv *bv, *v;
  sword nbv, i;
  ub4 j;
  ub1 *p;
  char ch;
  char *s;
  size_t slen;

  if(ref)
    ysmCheck(ref,yoTagObjRef);

  x = yosxEncode(0,ysmGlbHeap());
  yosxPutUB1(x,YO_BYTESEX);
  yogiPutOR(x,(dvoid *)ref,YOGIIOR_TAG_INTERNET);
  yosxEncEnd(x,&bv,&nbv);

  str = ysStrCreate("IOR:");
  for(i = 0, v = bv; i < nbv; i++, v++)
    for(j = 0, p = v->buf; j < v->len; j++, p++)
    {
      ch = (char) ((*p >> 4) & 0x0f);
      ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
      str = ysStrApp(str,ch);
      ch = (char) (*p & 0x0f);
      ch = ch > 9 ? ch + 'A' - 10 : ch + '0';
      str = ysStrApp(str,ch);
    }
  ysBvFree(ysmGlbHeap(),bv,nbv);

  /* FIXME: hack to put the right tag on the memory */
  slen = ysStrLen(str) + 1;
  s = (char *) ysmGlbAlloc(slen,yoTagYoAlloc);
  DISCARD memcpy((dvoid *)s,(dvoid *)ysStrToText(str),slen);
  ysStrDestroy(str);

  return s;
}

dvoid *yoStrToRef(CONST char *str)
{
  dvoid *ref;
  ub4 slen, blen;
  ub4 i;
  ysbv bv;
  CONST char *cp;
  char ch;
  ub1 *bp, b;
  yosx *x;

  if(!str || strncmp(str,"IOR:",4) != 0)
    yseThrow(YS_EX_BADPARAM);

  str += 4;
  slen = strlen(str);

  blen = slen / 2;
  bv.len = (size_t) blen;
  bv.buf = bp = (ub1 *) ysmGlbAlloc((size_t)blen,"ref2str data");

  for(i = 0, cp = str; i < slen; i += 2)
  {
    ch = (char)toupper(*cp++);
    b = (ub1)(ch > '9' ? ch - 'A' + 10: ch - '0') << 4;
    ch = (char)toupper(*cp++);
    b |= (ub1)(ch > '9' ? ch - 'A' + 10 : ch - '0');
    *bp++ = b;
  }

  x = yosxDecode(0,&bv,1);
  yosxDecSet(x,(boolean)yosxGetUB1(x));
  ref = yogiGetOR(x);
  yosxDecEnd(x);
  ysmGlbFree((dvoid *)bv.buf);

  return ref;
}

dvoid *yoAlloc(size_t len)
{
  yoctx *ctx;
  dvoid *ptr;
  yslst *lst;

  ctx = yoCtx;
  /* keep list of all allocations and check that the time is right */
  ptr = ysmGlbAlloc(len,yoTagYoAlloc);

  if((lst = (yslst *)ysThrKeyGet(ctx->srvmeml)))
    DISCARD ysLstEnq(lst,ptr);

  return ptr;
}

dvoid *yoRealloc(dvoid *ptr, size_t len)
{
  yoctx *ctx;
  ysle  *e;
  yslst *lst;

  ctx = yoCtx;

  ysmCheck(ptr,yoTagYoAlloc);                                   /* tag check */

  if((lst = (yslst *)ysThrKeyGet(ctx->srvmeml)))
  {
    /* find the pointer */
    for(e = ysLstHead(lst); e; e = ysLstNext(e))
      if(ysLstVal(e) == ptr)
        break;
  }
  else
    e = (ysle *) 0;

  ptr = ysmGlbRealloc(ptr,len);
  if(e)
    ysLstVal(e) = ptr;

  return ptr;
}

void yoFreeSrvrAlloc(yoctx *ctx)
{
  dvoid  *ptr;
  yslst  *lst;

  if(!(lst = (yslst *)ysThrKeyGet(ctx->srvmeml)))
    ysePanic(YO_EX_INTERNAL);

  /* find the pointer */
  while((ptr = ysLstDeq(lst)))
  {
    ysmCheck(ptr,yoTagYoAlloc);
    ysmFree(ysmGlbHeap(), ptr);
  }
  DISCARD ysThrKeySet(ctx->srvmeml,(dvoid *)0);
  ysLstDestroy(lst,(ysmff) 0);
}

void yoFree(dvoid *ptr)
{
  yoctx *ctx;
  ysle  *e;
  yslst  *lst;

  if(ptr)
  {
    ysmCheck(ptr,yoTagYoAlloc);                                /* tag check */
    ctx = yoCtx;

    if((lst = (yslst *)ysThrKeyGet(ctx->srvmeml)))
    {
      /* find the pointer */
      for(e = ysLstHead(lst); e; e = ysLstNext(e))
        if(ysLstVal(e) == ptr)
        {
          DISCARD ysLstRem(lst,e);
          break;
        }
    }
    ysmFree(ysmGlbHeap(), ptr);
  }
}

dvoid *yoNarrow(CONST dvoid *ref, CONST ysid *intf)
{
  if(!ref)
    yseThrow(YS_EX_BADPARAM);

  if(!yoIsA(ref,intf))
    yseThrow(YS_EX_BADPARAM);

  /* FIXME -- CONST ripples */
  return (dvoid*)ref;
}

boolean yoIsA(CONST dvoid *ref, CONST ysid *intf)
{
  yoctx *ctx;
  yoo *r;
  yoimp *imp;
  boolean result;

  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);

  ctx = yoCtx;
  r = (yoo *)ref;

  /* exact match */
  if((result = (strcmp(r->intf,intf) == 0)))
    return result;

  /* do we have information about the interface locally? */
  imp = yoFindImp(ctx,r->intf,(char *)0,FALSE);
  if(imp)
    return yoIsALocal(imp,intf);
  else
    return yoIsARemote((dvoid*)ref,intf);
}

STATICF boolean yoIsARemote(dvoid *ref, CONST char *intf)
{
  yopar pars[3];
  dvoid *parvec[2];
  yoenv ev;
  ysevt *noreg sem;
  boolean result = 0;

  NOREG(sem);
  sem = (ysevt *) 0;

  pars[0].mode = YOMODE_RETURN;
  pars[0].tk = (yotk *)yoTcBoolean;
  pars[1].mode = YOMODE_IN;
  pars[1].tk = (yotk *)yoTcString;
  pars[2].mode = YOMODE_INVALID;
  pars[2].tk = (yotk *)yoTcNull;
  parvec[0] = (dvoid *) &intf;

  yoEnvInit(&ev);
  yseTry
  {
    sem = ysSemCreate((dvoid *)0);
    yseTry
      yoSendReq(ref, &ev, "_is_a", TRUE, sem, 1, pars, parvec);
    yseCatchAll
      ysSemDestroy((ysevt *)sem);
    yseEnd;
    ysSemSynch((ysevt *)sem, (dvoid *)&result);
  }
  yseFinally
  {
    yoEnvFree(&ev);
  }
  yseEnd;

  return result;
}

dvoid *yoBind(CONST ysid *intf, CONST char *impl, CONST yoRefData *id,
              /* ARGUSED */ CONST char *ignored)
{
  yoctx *ctx;
  yoo *ref;

  ctx = yoCtx;

  if(intf)
    intf = (ysid *) yoGetStr(ctx,ysidToStr(intf));
  if(impl)
    impl = (char *) yoGetStr(ctx,impl);

  ref = yoRefCreate(ctx, intf, impl, (yoRefData*)id, YOSTID_INV, (yota *)0,
                    (dvoid *)0, FALSE);
  return (dvoid *)ref;
}

typedef struct yoexsd yoexsd;

struct yoexsd
{
  yoenv ev;
  ysevt *evt;
};

boolean yoExists(CONST dvoid *ref, ysevt *evt)
{
  yoctx *ctx;
  yoo *r;
  boolean exists;
  yoo *yref;
  yoexsd  *d;
  ysevt *ievt;

  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);

  ctx = yoCtx;
  r = (yoo *)ref;
  exists = TRUE;

  if(r->addr && yotAddrEq(r->addr,ctx->rrpaddr))
  {
    exists = yoExistsLocal(ctx,r);
    if(evt)
      ysTrigger(evt,(ysid *)0,(dvoid *)&exists,sizeof(boolean));
  }
  else
  {
    d = (yoexsd *) ysmGlbAlloc(sizeof(yoexsd),"yoexsd");
    yoEnvInit(&d->ev);
    if(evt)
    {
      d->evt = ysEvtAttach(evt,ysEvtSimple(yoExistsCancel,(dvoid *)d));
      ievt = ysEvtCreate(yoExistsHdlr,(dvoid *)d,ctx->evtq,FALSE);
    }
    else
      ievt = ysSemCreate((dvoid *)0);
    if(r->key == YOSTID_INV)
    {
      ysMtxLock(&ctx->ydmtx);
      while(!ctx->ydimref)
        ysCondWait(&ctx->ydcv,&ctx->ydmtx);
      ysMtxUnlock(&ctx->ydmtx);

      ydyo_imr_exists_nw((ydyo_imr)(dvoid*)ctx->ydimref, &d->ev,
			 (char *)r->intf,
                     (char *)r->impl, ievt);
    }
    else
    {
      yref = yoRefCreate(ctx,(ysid *)yort_proc__id,(char *)0,
                         (yoRefData *)0, YOSTID_YORT, yotAddrDup(r->addr),
                         (dvoid *)0, FALSE);
      yort_proc_exists_nw((yort_proc)(dvoid*)yref, &d->ev, (dvoid*)ref, ievt);
      yoRelease((dvoid *)yref);
    }
    if(!evt)
    {
      yseTry
        ysSemSynch(ievt,(dvoid *)&exists);
      yseFinally
      {
        yoEnvFree(&d->ev);
        ysmGlbFree((dvoid *)d);
        if(yseExid) yseRethrow;
      }
      yseEnd;
    }
  }
  return exists;
}

/* ARGSUSED */
STATICF void yoExistsCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                            size_t argsz)
{
  yoexsd *d = (yoexsd *) usrp;

  d->evt = (ysevt *) 0;
}

STATICF void yoExistsHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                          size_t argsz)
{
  yoexsd *d = (yoexsd *) usrp;
  boolean sts = FALSE;

  /* return FALSE for network exceptions */
  if(d->evt)
    if(ysidEq(exid, YT_EX_BADADDR) || ysidEq(exid, YT_EX_BROKEN) 
       || ysidEq(exid, YO_EX_BADOBJ))
      ysTrigger(d->evt,(CONST ysid *)0,(dvoid *)&sts,sizeof(boolean));
    else
      ysTrigger(d->evt,exid,arg,argsz);

  yoEnvFree(&d->ev);
  ysmGlbFree((dvoid *)d);
}

boolean yoExistsLocal(yoctx *ctx, yoo *ref)
{
  boolean exists = FALSE;


  if(ref->key != YOSTID_INV && ref->addr && yotAddrEq(ref->addr,ctx->rrpaddr))
    exists = !bit(ref->flags,YOOFL_INVALID);
  else if(ref->key == YOSTID_INV &&
          (!ref->addr || yotAddrEq(ref->addr,ctx->rrpaddr)))
    exists = (yoFindImp(ctx,ref->intf,ref->impl,TRUE) != (yoimp *)0);


  return exists;
}

typedef struct yodw yodw;
struct yodw
{
  mna    addr;
  ysevt *evt;
};

/* ARGSUSED */
STATICF void yoWatchCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                           size_t argsz)
{
  yodw *dw = (yodw *)usrp;

  dw->evt = (ysevt *) 0;
  DISCARD mnDeathIgnore(&dw->addr,usrp);
}

/* a handler to map mn to ysevt's -- arg is yotEvt to trigger */
STATICF void yoWatchHandler( dvoid *arg, sb4 val )
{
  ysid *exid;
  yodw *dw = (yodw *)arg;

  if(dw->evt)
  {
    exid = yotMnStsToExid(val);
    ysTrigger(dw->evt, exid, (dvoid *)&val, sizeof(val));
  }
  ysmGlbFree(arg);
}

void yoWatchOwner(dvoid *ref, ysevt *evt)
{
  ysid *exid;
  sb4	rv;
  mnHandler h = (mnHandler)0;
  yodw *dw;
  dvoid *arg = (dvoid *)0;
  mna *addr;

  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);

  addr = (mna *) ((yoo *)ref)->addr;
  if(!addr)
    yseThrow(YS_EX_BADPARAM);

  if(evt)
  {
    h = yoWatchHandler;
    dw = (yodw *) (arg = ysmGlbAlloc(sizeof(yodw),"yodw"));
    dw->evt = evt;
    DISCARD memcpy((dvoid *)&dw->addr,(dvoid *)addr,sizeof(mna));
    DISCARD ysEvtAttach(evt,ysEvtSimple(yoWatchCancel,(dvoid *)dw));
  }

  rv = mnDeathWatch(addr, h, arg);

  exid = yotMnStsToExid(rv);
  if(exid)
  {
    if(arg) ysmGlbFree(arg);
    yseThrow(exid);
  }
}

void yoGetAddr(CONST dvoid *ref, mna *addr)
{
  mna *ra;

  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);

  ra = (mna *) ((yoo *)ref)->addr;
  if(ra)
    mnaCopy(addr,ra);
  else
    mnaClear((dvoid *)addr);
}

boolean yoClaim(CONST char *property, dvoid *obj)
{
  yoctx   *ctx;
  yoenv    ev;
  ysevt	  *noreg sem;
  boolean  rv;
  yoevt	  revt;
  yoany	  any;
  yort_claim thing;

  NOREG(sem);
  CLRSTRUCT(any);
  sem = (ysevt *) 0;

  if(obj)
    ysmCheck(obj,yoTagObjRef);

  ctx = yoCtx;
  thing.owner = (yort_proc)0;
  thing.obj = (dvoid *)0;
  sem = ysSemCreate((dvoid*)0);
  revt = (yoevt)0;
  yseTry
  {
    /* build the arg structure and reply event */
    thing.property = (char *) property;
    thing.obj = yoDuplicate(obj);
    thing.owner = (yort_proc) yoDuplicate((dvoid *)ctx->yort);
    revt = yoToRmtEvt(sem);

    /* make sure we have an orb daemon */
    ysMtxLock(&ctx->ydmtx);
    while(!ctx->ydimref)
      ysCondWait(&ctx->ydcv,&ctx->ydmtx);
    ysMtxUnlock(&ctx->ydmtx);

    yoEnvInit(&ev);
    yseTry
    {
      ydyo_imr_stake((ydyo_imr)(dvoid*)ctx->ydimref,&ev,&thing,revt);
    }
    yseFinally
    {
      yoEnvFree(&ev);
    }
    yseEnd;
  }
  yseFinally
  {
    if(sem && yseExid)
      ysSemDestroy(sem);
    if(thing.obj)
      yoRelease(thing.obj);
    if(thing.owner)
      yoRelease((dvoid *)thing.owner);
  }
  yseEnd;

  ysSemSynch(sem,(dvoid *)&any); /* wait for the claim to be processed */
  rv = *(boolean*)any._value;
  yotkFreeVal(yoTcAny,(dvoid *)&any,(ysmff)0);

  return rv;
}

void yoAbandon(CONST char *property)
{
  yoctx      *ctx;
  yoenv	      ev;
  yort_claim  what;

  ctx = yoCtx;

  what.property = (char *) property;
  what.obj = (dvoid *)0;
  what.owner = (yort_proc)(dvoid*)ctx->yort;

  yoEnvInit(&ev);

  ysMtxLock(&ctx->ydmtx);
  while(!ctx->ydimref)
    ysCondWait(&ctx->ydcv,&ctx->ydmtx);
  ysMtxUnlock(&ctx->ydmtx);

  yseTry
  {
    ydyo_imr_abandon((ydyo_imr)(dvoid*)ctx->ydimref, &ev, &what);
  }
  yseFinally
  {
    yoEnvFree(&ev);
  }
  yseEnd;
}

void yoListInitRefs(YCIDL_sequence_string *nmlst)
{
  yoctx *ctx;
  yoenv ev;
  yostd_stringList list;
  char *n, **sp, *os;
  ub4 i;
  size_t len;

  ctx = yoCtx;
  yoEnvInit(&ev);
  CLRSTRUCT(list);

  ysMtxLock(&ctx->ydmtx);
  while(!ctx->ydimref)
    ysCondWait(&ctx->ydcv,&ctx->ydmtx);
  ysMtxUnlock(&ctx->ydmtx);

  yseTry
  {
    list = ydyo_imr_listProperties((ydyo_imr)(dvoid*)ctx->ydimref, &ev, 
                                   (char *)"^yoir:");
  }
  yseFinally
  {
    yoEnvFree(&ev);
  }
  yseEnd;

  /* gronk the strings */
  yseTry
  {
    for(i=0, sp=list._buffer; i < list._length; i++, sp++)
    {
      os = *sp;
      len = strlen(os) + 1;
      if(len > (size_t)5)
      {
        len -= (size_t)5;
        n = (char *) yoAlloc(len);
        DISCARD memcpy((dvoid *)n,(dvoid *)(os+5),len);
        *sp = n;
        yoFree((dvoid *)os);
      }
    }
  }
  yseCatchAll
  {
    yotkFreeVal(YCTC_YCIDL_sequence_string,(dvoid *)&list,yoFree);
    yseRethrow;
  }
  yseEnd;

  nmlst->_maximum = list._maximum;
  nmlst->_length = list._length;
  nmlst->_buffer = list._buffer;
}

dvoid *yoGetInitRef(CONST char *name)
{
  yoctx  *ctx;
  yoenv   ev;
  ysstr  *noreg pname;
  dvoid  *ref = (dvoid *)0;

  NOREG(pname);
  pname = (ysstr *) 0;
  ctx = yoCtx;

  yoEnvInit(&ev);

  ysMtxLock(&ctx->ydmtx);
  while(!ctx->ydimref)
    ysCondWait(&ctx->ydcv,&ctx->ydmtx);
  ysMtxUnlock(&ctx->ydmtx);

  yseTry
  {
    pname = ysStrCreate("^yoir:");
    pname = ysStrCat(pname, name);
    pname = ysStrApp(pname, '$');

    ref = (dvoid *) ydyo_imr_propertyResolve((ydyo_imr)(dvoid*)ctx->ydimref,
					     &ev, ysStrToText(pname));
  }
  yseFinally
  {
    if(pname)
      ysStrDestroy(pname);
    yoEnvFree(&ev);
  }
  yseEnd;

  return ref;
}

void yoEnvInit(yoenv *ev)
{
  ev->_length = ev->_maximum = 0;
  ev->_buffer = (yoevm *)0;
}

void yoEnvCopy(yoenv *dst, CONST yoenv *src)
{
  yotkCopyVal(yoenv__tc,(dvoid *)dst,(dvoid *)src,(ysmaf)0);
}

void yoEnvFree(yoenv *ev)
{
  yotkFreeVal(yoenv__tc,(dvoid *)ev,(ysmff)0);
}

boolean yoEnvGet(CONST yoenv *ev, CONST char *name, yoany *value)
{
  ub4 i;
  yoevm *m;

  /* FIXME: use hash table if performance problem */
  m = ev->_buffer;
  for(i=0; i < ev->_length; i++, m++)
    if(strcmp(name,m->name) == 0)
    {
      yotkCopyVal(yoTcAny,(dvoid *)value,(dvoid *)&m->value,yoAlloc);
      return TRUE;
    }
  return FALSE;
}

void yoEnvSet(yoenv *ev, CONST char *name, CONST yoany *value)
{
  ub4 i;
  yoany a;
  yoevm *m, mcp;

  /* FIXME: use hash table if performance problem */
  m = ev->_buffer;
  CLRSTRUCT(a);
  for(i=0; i < ev->_length; i++, m++)
    if(strcmp(name,m->name) == 0)
    {
      if(value)
      {
        yotkCopyVal(yoTcAny,(dvoid *)&a,(dvoid *)value,(ysmaf)0);
        yotkFreeVal(yoTcAny,(dvoid *)&m->value,(ysmff)0);
        CPSTRUCT(m->value,a);
      }
      else
      {
        yotkFreeVal(yoevm__tc,(dvoid *)m,(ysmff)0);
        for(i++; i < ev->_length; i++, m++)
          CPSTRUCT(*m,*(m+1));
        ev->_length--;
      }
      return;
    }
  if(value)
  {
    if(ev->_length >= ev->_maximum)
    {
      ev->_maximum = ev->_length + 10;
      if(ev->_buffer)
        ev->_buffer = (yoevm *) ysmGlbRealloc((dvoid *)ev->_buffer,
                                              (size_t)ev->_maximum*
                                              sizeof(yoevm));
      else
        ev->_buffer = (yoevm *) ysmGlbAlloc((size_t)ev->_maximum*sizeof(yoevm),
                                            "yoevm");
      m = ev->_buffer + ev->_length;
    }
    mcp.name = name;
    CPSTRUCT(mcp.value,*value);
    yotkCopyVal(yoevm__tc,(dvoid *)m,(dvoid *)&mcp,(ysmaf)0);
    ev->_length++;
  }
}

void yoSetFilter(CONST char *name, sword type, yofilter filter, dvoid *usrp)
{
  yoctx *ctx;
  ysle *e;
  yofltr *f = (yofltr *)0;

  ctx = yoCtx;
  for(e = ysLstHead(ctx->fltrs); e; e = ysLstNext(e))
  {
    f = (yofltr *) ysLstVal(e);
    if(f->type == type && strcmp(f->name,name) == 0)
      break;
  }
  if(!filter)
  {
    if(e)
    {
      DISCARD ysLstRem(ctx->fltrs,e);
      ysmGlbFree((dvoid *)f);
    }
  }
  else
  {
    if(!e)
    {
      f = (yofltr *)ysmGlbAlloc(sizeof(yofltr),"yofltr");
      DISCARD ysLstEnq(ctx->fltrs,(dvoid *)f);
    }
    f->name = name;
    f->type = type;
    f->filter = filter;
    f->usrp = usrp;
  }
}

void yoFilterRunEx(dvoid *or, yoenv *ev, sword type, 
		   CONST ysid *exid, dvoid *exobj)
{
  ysle *e;
  yofltr *f;
  yoctx *ctx;
  yocur *cur;
  yoo *oldref;
  CONST ysid *oldexid;
  dvoid *oldexobj;

  /* only get (maybe creating) a current if there are filters to run */
  ctx = yoCtx;
  if(ysLstCount(ctx->fltrs))
  {
    /* set ref only as long as necessary; if nil in, nil out */
    cur = yoCurGet();
    oldexid = cur->reqh.exid;
    oldexobj = cur->reqh.exobj;
    oldref = cur->reqh.ref;
    cur->reqh.exid = exid;
    cur->reqh.exobj = exobj;
    cur->reqh.ref = (yoo*)or;
    
    for(e = ysLstHead(ctx->fltrs); e; e = ysLstNext(e))
    {
      f = (yofltr *) ysLstVal(e);
      if(f->type == type)
	(*f->filter)(ev,f->usrp);
    }
    cur->reqh.ref = oldref;
    cur->reqh.exid = oldexid;
    cur->reqh.exobj = oldexobj;
  }
}

/* may return null if nothing set; this is OK, everything else works */
yocur *yoCurGet(void)
{
  yoctx *ctx;
  yocur *cur;

  ctx = yoCtx;
  cur = (yocur*)ysThrKeyGet(ctx->cur);
  if(!cur)
  {
    cur = (yocur*)ysmGlbAlloc(sizeof(yocur),yoTagCur);
    DISCARD ysThrKeySet(ctx->cur,(dvoid*)cur);
    CLRSTRUCT(*cur);
    cur->reqh.ref = (yoo*)0;
    cur->reqh.scxs.upctx = (yoTrans_pctx*)0;
  }
  return (yocur*)cur;
}

void yoCurDestroy(void)
{
  yoctx *ctx;
  yocur *cur;

  ctx = yoCtx;
  if((cur = (yocur*)ysThrKeyGet(yoCtx->cur)))
  {
    if(cur->reqh.scxs.upctx)
      yoTrans_pctx__free(cur->reqh.scxs.upctx,(ysmff)0);
    ysmGlbFree((dvoid*)cur);
  }
  DISCARD ysThrKeySet(ctx->cur,(dvoid*)0);
}

/* get the object ref in the yocur.  yoRelease when done.  Cur might
   be a client yoTagCur obj or a server yoreqh. */
dvoid *yoCurGetRef(yocur *cur)
{
  return(yoDuplicate((dvoid*)cur->reqh.ref));
}

/* Set the propctx, copying the one handed in.  Can be used in clients 
  and servers, though servers should beware it will vanish when the
  request completes unless saved elsewhere. */

void yoCurSetPropCtx(yocur *cur,  CosTransactions_PropagationContext *pctx )
{
  yoTrans_pctx *ypcx = (yoTrans_pctx*)(dvoid*)pctx;
  yoctx *ctx;

  ctx = yoCtx;

  /* if have current value, release it */
  if(cur->reqh.scxs.upctx)
    yoTrans_pctx__free(cur->reqh.scxs.upctx,(ysmff)0);

  if(!ypcx)		/* if no new value, remember that */
    cur->reqh.scxs.upctx = ypcx;
  else			/* copy contents to handy container */
  {
    cur->reqh.scxs.upctx = &cur->reqh.scxs.pctx;
    yoTrans_pctx__copy(cur->reqh.scxs.upctx,ypcx,(ysmaf)0);
  }
}

/* get pointer to the propctx, gone when cur vanishes or changes. */
CosTransactions_PropagationContext *yoCurGetPropCtx(yocur *cur)
{
  return((CosTransactions_PropagationContext*)(dvoid*)cur->reqh.scxs.upctx);
}

/* return exception info, if any */
CONST ysid *yoCurGetExid(yocur *cur, dvoid **exobj)
{
  if (exobj)
    *exobj = cur->reqh.exobj;
  return cur->reqh.exid;
}

void yoSendReq(CONST dvoid *or, yoenv *ev, CONST char *op, boolean response,
               ysevt *uevt, sword args, CONST yopar *pars, dvoid **values)
{
  if(!or)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck((dvoid *)or,yoTagObjRef);

  yoSndReq(yoCtx,(yoo *)or,ev,op,response,uevt,args,pars,values,(ysbv *)0,0);
}

void yoParsSize(yopar *pars)
{
  yopar *p;
  size_t align;
  size_t sz;

  for(p = pars; p->mode != YOMODE_INVALID; p++)
  {
    yotkSizeAlign(p->tk,&sz,&align);
    p->sz = (ub4)sz;
  }
}

dvoid *yoLocalObj(dvoid *or, yowiden *widener)
{
  yoctx *ctx;
  yoimp *imp;
  dvoid *impldef;
  yoo *r;
  ysthr thrid;

  /* guard the kingdom */
  if(!(or))
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(or,yoTagObjRef);
  r = (yoo *) or;
  if(bit(r->flags,YOOFL_INVALID))
    yseThrow(YO_EX_BADOBJ);

  ctx = yoCtx;
  impldef = (dvoid *) 0;

  if(ysThrSelf(&thrid) == (ysthr *)0)              /* if we are not threaded */
  {
    if(!r->addr || yotAddrEq(r->addr,ctx->rrpaddr))
    {
      if(r->key)
      {
        impldef = (dvoid*)r->imp->impldef;
      }
      else
      {
        imp = yoFindImp(ctx, r->intf, r->impl,TRUE);
        if(imp)
        {
          impldef = (dvoid*)imp->impldef;
          r->imp = imp;	/* ??? FIXME */
        }
      }
    }
  }

  if(r->imp)
    *widener = r->imp->stubs->widen;

  return impldef;
}

yopard *yoPardCreate(CONST char *id, ub4 cnt)
{
  yopard *pd;

  pd = (yopard*)ysmGlbAlloc((size_t)(sizeof(yopard)+(cnt * sizeof(yopar))),id);
  pd->id = id;

  return pd;
}

void  yoParsSet(yopard *pd)
{
  ysHshIns(yoCtx->partab, (dvoid *)pd->id, strlen(pd->id), (dvoid *)pd);
}

yopar *yoParsGet(CONST char *id)
{
  yopar *pars = (yopar *) 0;
  yopard *pd;

  pd = (yopard *) ysHshFind(yoCtx->partab, (dvoid *)id, strlen(id));
  if(pd)
    pars = pd->pars;

  return pars;
}

STATICF sword yoPardEq(dvoid *elm, dvoid *key, /* ARGUSED */ size_t keysz)
{
  return (sword) strcmp(((yopard *)elm)->id,(char *)key);
}

CONST yotk *yoTc_seq_sb2_getTC(void)
{
  return yoTc_seq_sb2;
}

CONST yotk *yoTc_seq_sb4_getTC(void)
{
  return yoTc_seq_sb4;
}

CONST yotk *yoTc_seq_ub2_getTC(void)
{
  return yoTc_seq_ub2;
}

CONST yotk *yoTc_seq_ub4_getTC(void)
{
  return yoTc_seq_ub4;
}

CONST yotk *yoTc_seq_boolean_getTC(void)
{
  return yoTc_seq_boolean;
}

CONST yotk *yoTc_seq_char_getTC(void)
{
  return yoTc_seq_char;
}

CONST yotk *yoTc_seq_ub1_getTC(void)
{
  return yoTc_seq_ub1;
}

CONST yotk *yoTc_seq_yoany_getTC(void)
{
  return yoTc_seq_yoany;
}

CONST yotk *yoTc_seq_TypeCode_getTC(void)
{
  return yoTc_seq_TypeCode;
}

CONST yotk *yoTc_seq_string_getTC(void)
{
  return yoTc_seq_string;
}

CONST yotk *yoTc_seq_sysb8_getTC(void)
{
  return yoTc_seq_sysb8;
}

typedef struct yoowlr yoowlr;
struct yoowlr
{
  yoctx  *ctx;
  yocreq *req;
  ysbv   *bv;
  sword   nbv;
};

void yoSndReq(yoctx *ctx, yoo *ref, yoenv *ev, CONST char *op,
              boolean response, ysevt *uevt, sword args, CONST yopar *pars,
              dvoid **values, ysbv *bv, sword nbv)
{
  yocreq *req;
  yosvcxs svcx;
  yocur *cur;

  if(!ev)
    yseThrow(YS_EX_BADPARAM);
  svcx.uev = ev;
  cur = (yocur*)ysThrKeyGet(ctx->cur);
  svcx.upctx = (cur) ? cur->reqh.scxs.upctx : (yoTrans_pctx*)0;

  req = yoCReqCreate(ctx,(ub4)YOGIMT_REQ,ref,&svcx,op,response,uevt,pars);
  yseTry
  {
    if(pars)
      req->outs = yoxPutReqParms(req->x, req->reftag, args, pars, values);
    if(ref->addr || response)
      yoCReqSend(ctx,req,bv,nbv);
    else
    {
      yoowlr *owlr;
      sword i;
      ysevt *levt;

      /* the dreaded loosely bound oneway call */
      owlr = (yoowlr *) ysmGlbAlloc(sizeof(yoowlr),"yoowlr");
      owlr->ctx = ctx;
      owlr->req = req;
      if(nbv && bv)
      {
        owlr->bv = (ysbv *) ysmGlbAlloc((size_t)(sizeof(ysbv)*nbv),"ysbv");
        owlr->nbv = nbv;
        for(i = 0; i < nbv; i++)
        {
          owlr->bv[i].len = bv[i].len;
          owlr->bv[i].buf = bv[i].buf;
        }
      }
      else
      {
        owlr->bv = bv;
        owlr->nbv = nbv;
      }
      levt = ysEvtCreate(yoOneWayLocReqH,(dvoid *)owlr,ctx->evtq,FALSE);
      yoSndLocReq(ctx,ref,levt);
    }
  }
  yseCatchAll
  {
    yoFreeCliReq(ctx,req);
    yseRethrow;
  }
  yseEnd;
}

STATICF void yoOneWayLocReqH(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                             size_t argsz)
{
  yoowlr *owlr = (yoowlr *) usrp;

  if(exid)
  {
    ysTrigger(owlr->req->uevt,exid,arg,argsz);
    owlr->req->uevt = (ysevt *) 0;
    yoFreeCliReq(owlr->ctx,owlr->req);
  }
  else
  {
    if(arg)
    {
      yoRelease((dvoid *)owlr->req->hdr.ref);
      owlr->req->hdr.ref = *(yoo **)arg;
    }
    yoCReqSend(owlr->ctx,owlr->req,owlr->bv,owlr->nbv);
  }
  if(owlr->nbv && owlr->bv)
    ysmGlbFree((dvoid *)owlr->bv);
  ysmGlbFree((dvoid *)owlr);
}


STATICF yocreq *yoCReqCreate(yoctx *ctx, ub4 type, yoo *ref, yosvcxs *svcx,
                             CONST char *op, boolean response, ysevt *evt,
                             CONST yopar *pars)
{
  ub4 reqid;
  yocreq *noreg req;
  boolean bridge;
  yosx *x;

  NOREG(req);
  req = (yocreq *)0;

  /* get a unique request id */
  reqid = ctx->reqid;
  do
    if(!(++ctx->reqid)) ctx->reqid++;
  while(yoGetPendReq(ctx,ctx->reqid));

  yseTry
  {
    req = (yocreq *)ysmAlloc(ctx->sndhp,sizeof(yocreq),"yocreq");

    ref = (yoo *) yoDuplicate((dvoid *)ref);

    req->type = type;
    /* FIXME: determining bridge based on ref is a temporary solution */
    if((bridge = (boolean)bit(ref->flags,YOOFL_IOR)))
      req->reftag = YOGIIOR_TAG_INTERNET;
    else
      req->reftag = YOGIIOR_TAG_YO;

    /* populate the request header */
    if( svcx->uev )
      CPSTRUCT(req->hdr.scxs.ev,*svcx->uev);
    else
      CLRSTRUCT(req->hdr.scxs.ev);

    if((req->hdr.scxs.upctx = svcx->upctx))
      CPSTRUCT(req->hdr.scxs.pctx,*svcx->upctx);
    else
      CLRSTRUCT(req->hdr.scxs.pctx);

    req->hdr.scxs.scl = (yslst *)0;
    req->hdr.id = reqid;
    req->hdr.ref = ref;
    req->hdr.op = (char *) 0;
    req->hdr.resp = response;
    req->hdr.exid = (CONST ysid *)0;
    req->hdr.exobj = (dvoid *)0;

    req->uevt = evt;
    req->pars = pars;
    req->scxs.uev = svcx->uev;
    req->scxs.upctx = svcx->upctx;
    req->outs = (yslst *) 0;
    req->sevt = (ysevt *) 0;
    req->ttl = (ysevt *)0;
    req->bv = (ysbv *) 0;
    req->nbv = 0;

    req->hdr.op = op ? ysStrDup(op) : (char *)0;

    req->x = x = yosxEncode((size_t)YO_RCVPGSZ,ctx->sndhp);
    if(bridge)
    {
      yosxPutUB1(x,YO_BYTESEX);                             /* byte ordering */
      yogiPutIOR(x,&ref->ior);             /* pre-pend target IOR for bridge */
      yosxAlign(x,16);                                   /* align for safety */
    }
    yogiPutMsgHeader(x,(ub1)type,&req->lp);
    switch(type)
    {
    case YOGIMT_REQ:
      yogiPutReqHeader(x,req->reftag,&req->hdr);
      break;
    case YOGIMT_LOCREQ:
      yogiPutLocReqHeader(x,req->reftag,&req->hdr);
      break;
    default:
      ysePanic(YO_EX_INTERNAL);
      break;
    }
  }
  yseCatchAll
  {
    if(req) yoFreeCliReq(ctx,req);
    yseRethrow;
  }
  yseEnd;

  return req;
}

STATICF void yoCReqSend(yoctx *ctx, yocreq *req, ysbv *bv, sword nbv)
{
  yosxPos ep;
  ub4 len;
  ub1 *buf;
  sword i,j;
  ysbv *obv;
  sword onbv;

  yosxGetPos(req->x,&ep);
  len = yosxGetLength(req->x,&ep,&req->lp) - 4;
  yosxEncEnd(req->x, &req->bv, &req->nbv);
  req->x = (yosx *)0;

  if(bv)
  {
    req->bv = (ysbv *) ysmRealloc(ctx->sndhp,(dvoid *)req->bv,
				  sizeof(ysbv)*(req->nbv+nbv));
    for(i = req->nbv, j = 0;  j < nbv; i++, j++)
    {
      len += bv[j].len;
      req->bv[i].len = bv[j].len;
      req->bv[i].buf = bv[j].buf;
    }
    req->nbv += nbv;
  }

  /* fixup message header length */
  buf = req->bv[req->lp.idx].buf + req->lp.off;
  sysxPut4(buf,len);

  /* encrypt now instead of in dequeue in idle thread. */
  if( ctx->cycx )
  {
    yocyBvEncrypt(ctx,req->bv,req->nbv,&obv,&onbv,ctx->sndhp);
    ysBvFree(ctx->sndhp,req->bv,req->nbv);
    req->bv = obv;
    req->nbv = onbv;
  }

  /* place the request on the request send queue */
  DISCARD ysLstEnq(ctx->reqsndq,(dvoid *)req);
  DISCARD ysEvtAttach(req->uevt,ysEvtSimple(yoSndReqCancel,(dvoid *)req));
}


/* ARGSUSED */
STATICF void   yoSndReqCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                              size_t argsz)
{
  yocreq *req = (yocreq *)usrp;

  req->uevt = (ysevt *) 0;
}

STATICF boolean yoReqQSend(yoctx *ctx, yslst *sndq)
{
  ysle *e, *ne;
  yocreq *req;
  yoo *ref;
  ysevt *noreg evt;
  yota *dest;
  char astr[YOTAMAXLEN];
  sword i;
  sb4 reqsz;
  boolean work;

  NOREG(evt);
  work = FALSE;

  for(ne = e = ysLstHead(sndq); e; e = ne)
  {
    ne = ysLstNext(e);
    req = (yocreq *) ysLstVal(e);
    ref = req->hdr.ref;

    /* determine destination based on object reference */
    dest = (yota *) 0;

    if(bit(ref->flags,YOOFL_IOR))
      dest = ctx->iiopbr;
    else
    {
      dest = ref->addr;
      if(!dest)
      {
        ysMtxLock(&ctx->ydmtx);
        dest = ctx->ydaddr;                                /* route via ORBD */
        ysMtxUnlock(&ctx->ydmtx);
        if(!dest) continue;                       /* no address to route via */
      }
    }

    evt = (ysevt *) 0;
    yseTry
    {
      /* insert into pending request table */
      ysHshIns(ctx->preqs,(dvoid *)&req->hdr.id,sizeof(req->hdr.id),
               (dvoid *)req);

      if (req->sevt)
      {
        ysEvtDestroy(req->sevt);
        req->sevt = (ysevt *) 0;
      }
      evt = ysEvtCreate(yoReqQSendHdlr, (dvoid *)req, ctx->evtq, TRUE);

      /* Do not encrypt here -- already done in yoSndReq */

      DISCARD yotSendV(ctx->rrport, dest, req->bv, req->nbv, evt);

      DISCARD ysLstRem(sndq,e);                  /* remove from send queue */
      work = TRUE;

      DISCARD yotAddrToStr(dest,astr,sizeof(astr));
      for(reqsz = 0, i = 0; i < req->nbv; i++)
        reqsz += req->bv[i].len;
      ysRecord(YOCLI_ERR(1), YSLSEV_DEBUG(8), (char *)0, YSLSTR(astr),
               YSLUB4(req->hdr.id), YSLUB4(reqsz),
               YSLSTR(yoStr(req->hdr.ref->intf)),
               YSLSTR(yoStr(req->hdr.ref->impl)), YSLSTR(req->hdr.op), YSLEND);
      req->sevt = evt;
    }
    yseCatchAll
    {
      /* remove from pending request table */
      DISCARD yoRemPendReq(ctx,req->hdr.id);
      if(evt) ysEvtDestroy(evt);
      ysRecord(YOCLI_ERR(2), YSLSEV_ERR, (char *)0, YSLUB4(req->hdr.id),
               YSLSTR(yseExid),YSLEND);
    }
    yseEnd;
  }

  return work;
}

STATICF void yoReqQSendHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                            size_t argsz)
{
  yoctx *ctx;
  yocreq *req = (yocreq *) usrp;

  ctx = yoCtx;
  if(exid || !req->hdr.resp)
  {
    if(!exid)
    {
      arg = (dvoid *)0;
      argsz = (size_t)0;
    }
    if(req->uevt)
    {
      ysTrigger(req->uevt,exid,arg,argsz);
    }
    yoFreeCliReq(ctx,req);
  }
  else
  {
    /* setup timer to deal with request timeout.  this timer gets reset by
       heartbeats from the server
     */
    if(req->hdr.resp && !bit(req->hdr.ref->flags,YOOFL_IOR))
    {
      req->ttl = ysEvtCreate(yoReqTimeout, (dvoid *) req, ctx->evtq, TRUE);
      ysTimer(&ctx->reqto,req->ttl);
    }
    else
      req->ttl = (ysevt *)0;
    ysEvtDestroy(req->sevt);
    req->sevt = (ysevt *) 0;
  }
}

STATICF void yoReqTimeout(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                          size_t argsz)
{
  yoctx  *ctx;
  yocreq *req;

  req = (yocreq *) usrp;
  ctx = yoCtx;

  if(req->uevt)
    ysTrigger(req->uevt,exid,arg,argsz);
  yoFreeCliReq(ctx,req);
}


STATICF void yoRepHdrFree(yoreph *hdr)
{
  yoEnvFree((yoenv *)&(hdr->scxs.ev));
  if(hdr->scxs.upctx)
    yoTrans_pctx__free(hdr->scxs.upctx, (ysmff)0);
  if(hdr->scxs.scl)
    ysLstDestroy(hdr->scxs.scl, (ysmff)yogiFreeSvcCtx);
}

STATICF void yoRepRcv(yoctx *ctx, yomd *noreg md, ub4 type)
{
  yosx *x = md->x;
  noreg yoreph hdr;
  yocreq *noreg req = (yocreq *) 0;
  char astr[YOTAMAXLEN];

  NOREG(md);
  NOREG(hdr);
  NOREG(req);
  CLRSTRUCT(hdr);

  yseTry
  {
    switch(type)
    {
    case YOGIMT_REP:
      yogiGetRepHeader(x,(yoreph *) &hdr);
      break;
    case YOGIMT_LOCREP:
      yogiGetLocRepHeader(x,(yoreph *) &hdr);
      break;
    default:
      ysePanic(YO_EX_INTERNAL);
      break;
    }

    req = yoGetPendReq(ctx,hdr.id);           /* find request to match reply */
    if(req)
    {
      if(req->sevt)           /* don't care about send anymore -- bug 575410 */
      {
        ysEvtDestroy(req->sevt);
        req->sevt = (ysevt *) 0;
      }
      if(req->ttl)                                         /* stop the clock */
      {
        ysEvtDestroy(req->ttl);
        req->ttl = (ysevt *) 0;
      }
      DISCARD yotAddrToStr(md->addr,astr,sizeof(astr));
      ysRecord(YOCLI_ERR(3), YSLSEV_DEBUG(8), (char *)0,
               YSLSTR(astr), YSLUB4(hdr.id), YSLUB4(hdr.sts),
               YSLSTR(yoStr(req->hdr.ref->intf)),
               YSLSTR(yoStr(req->hdr.ref->impl)),YSLSTR(req->hdr.op),YSLEND);

      if(req->uevt)
      {
        switch(req->type)
        {
        case YOGIMT_REQ:
          req = yoReqRepRcv(ctx,req,(yoreph *)&hdr,md);
          break;
        case YOGIMT_LOCREQ:
          req = yoLocReqRepRcv(ctx,req,(yoreph *)&hdr,md);
          break;
        }
      }
      else
      {
        /* request canceled */
        ysRecord(YOCLI_ERR(4), YSLSEV_INFO, (char *)0, YSLNONE);
        yoFreeMsgDesc(ctx->rcvhp,md);
	yoRepHdrFree((yoreph *)&hdr);
      }
    }
    else
    {
      /* no matching request */
      ysRecord(YOCLI_ERR(5), YSLSEV_WARNING, (char *)0, YSLUB4(hdr.id),
               YSLEND);
      yoFreeMsgDesc(ctx->rcvhp,md);
      yoRepHdrFree((yoreph *)&hdr);
    }
  }
  yseCatchAll
  {
    if(req)
    {
      if(req->uevt) yseTrigger(req->uevt);
      /* unable to decode payload */
      ysRecord(YOCLI_ERR(6), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
    }
    else
    {
      /* unable to decode even the reply header */
      ysRecord(YOCLI_ERR(7), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
    }
  }
  yseEnd;

  if(req)
    yoFreeCliReq(ctx,req);                       /* free client side request */
}

STATICF sword yoReqEq(dvoid *elm, dvoid *key, size_t keysz /* ARGUSED */)
{
  return !(((yocreq *)elm)->hdr.id == *((ub4 *)key));
}

STATICF yocreq *yoReqRepRcv(yoctx *ctx, yocreq *req, yoreph *hdr, yomd *md)
{
  dvoid *ref;
  CONST ysid *noreg exid = (ysid *) 0;
  dvoid *noreg arg = (dvoid *) 0;
  size_t argsz = 0;
  yodsrep *noreg dsrep = (yodsrep *) 0;

  NOREG(exid);
  NOREG(arg);
  NOREG(dsrep);

  yseTry
  {
    if(hdr->sts == YOGIRS_LOCFWD)
    {
      yoEnvFree((yoenv *)&hdr->scxs.ev);
      ref = yogiGetOR(md->x);
      yoRelease((dvoid *)req->hdr.ref);
      req->hdr.ref = (yoo *)ref;                       /* resend the request */
      DISCARD yoRemPendReq(ctx,req->hdr.id);
      DISCARD ysLstEnq(ctx->reqsndq,(dvoid *)req);
      req = (yocreq *) 0;
    }
    else
    {
      yoEnvFree(req->scxs.uev);
      CPSTRUCT(*req->scxs.uev,hdr->scxs.ev);       /* update the environment */

      /* if want and got, copy; if want != got, panic */
      if(req->scxs.upctx && hdr->scxs.upctx)
      {
	yoTrans_pctx__free( req->scxs.upctx, (ysmff)0 );
	CPSTRUCT(*req->scxs.upctx,*hdr->scxs.upctx);
      }
      else if(req->scxs.upctx != hdr->scxs.upctx)
	ysePanic(YO_EX_INTERNAL);

      if(req->pars)
      {
        switch(hdr->sts)
        {
        case YOGIRS_NOEX:
          yoxGetRepParms(md->x,req->pars,req->outs,(dvoid **)&arg,&argsz);
          break;
        case YOGIRS_USREX:
          exid = yoxGetUserEx(md->x,req->pars,(dvoid **)&arg,&argsz);
          break;
        case YOGIRS_SYSEX:
          exid = yoxGetSysEx(md->x, (dvoid **)&arg, &argsz);
          break;
	default:
	  ysePanic(YO_EX_INTERNAL);
	  break;
        }
        ysTrigger(req->uevt,exid,arg,argsz);
      }
      else
      {
        dsrep = (yodsrep *) ysmGlbAlloc(sizeof(yodsrep),"yodsrep");
        CPSTRUCT(dsrep->hdr,*hdr);
        dsrep->md = md;
        ysTrigger(req->uevt,(ysid *)0,(dvoid *)&dsrep,sizeof(dsrep));
        dsrep = (yodsrep *) 0;
        md = (yomd *) 0;
      }
      req->uevt = (ysevt *) 0;                            /* event triggered */
    }
  }
  yseFinally
  {
    if(md)
      yoFreeMsgDesc(ctx->rcvhp,md);
    if(arg)
      ysmGlbFree(arg);
    if(dsrep)
      ysmGlbFree((dvoid *)dsrep);
  }
  yseEnd;

  return req;
}

STATICF yocreq *yoLocReqRepRcv(yoctx *ctx, yocreq *req, yoreph *hdr, yomd *md)
{
  dvoid *ref;
  CONST ysid *exid = (ysid *)0;
  dvoid *arg = (dvoid *)0;
  size_t argsz = (size_t) 0;

  switch(hdr->sts)
  {
  case YOGILRS_UNKNOWN:
    exid = YO_EX_BADOBJ;
    break;
  case YOGILRS_HERE:
    /* do nothing */
    break;
  case YOGILRS_FORWARD:
    ref = yogiGetOR(md->x);
    arg = (dvoid *) &ref;
    argsz = sizeof(ref);
    break;
  default:
    ysePanic(YO_EX_INTERNAL);
    break;
  }

  ysTrigger(req->uevt,exid,arg,argsz);
  req->uevt = (ysevt *)0;

  if(md)
    yoFreeMsgDesc(ctx->rcvhp,md);

  return req;
}

void yoSndLocReq(yoctx *ctx, yoo *ref, ysevt *evt)
{
  yocreq *req;
  yosvcxs svcx;

  svcx.uev = (yoenv*)0;
  svcx.upctx = (yoTrans_pctx*)0;
  req = yoCReqCreate(ctx,(ub4)YOGIMT_LOCREQ,ref,&svcx,
		     (char*)0,TRUE,evt,(yopar*)0);
  yseTry
  {
    yogiPutOR(req->x,(dvoid *)ref,req->reftag);
    yoCReqSend(ctx,req,(ysbv *)0,0);
  }
  yseCatchAll
  {
    yoFreeCliReq(ctx,req);
    yseRethrow;
  }
  yseEnd;
}

STATICF void yoMsgWaitHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                          /* ARGUSED */ size_t argsz)
{
  yoctx *ctx = (yoctx *) usrp;
  sb4 len;
  ysbv *noreg bv;
  noreg sword nbv;
  yomd *noreg md = (yomd *) 0;
  ysevt *noreg rcvevt = (ysevt *) 0;

  NOREG(bv);
  NOREG(nbv);
  NOREG(md);
  NOREG(rcvevt);
  nbv = 0;
  bv = (ysbv*)0;

  if(exid)                                         /* problem with port test */
  {
    ctx->rrevt = (ysevt *) 0;
    ysRecord(YOGEN_ERR(1), YSLSEV_ERR, (char *)0, YSLSTR(exid), YSLEND);
    return;
  }
  if(!ctx->evtq) return;                       /* drop message shutting down */

  len = *(sb4 *)arg;                                   /* get message length */

  yseTry
  {
    yoAllocMsgBufs(ctx->rcvhp,len,(ysbv **)&bv,(sword *)&nbv);

    /* allocate memory for the request / reply */
    md = (yomd *) ysmAlloc(ctx->rcvhp,sizeof(yomd),yoTagMsgDesc);
    md->usrp = (dvoid *) 0;
    md->addr = (yota *) 0;
    md->x = (yosx *) 0;
    md->len = len;
    md->bv = bv;
    md->nbv = nbv;

    /* attempt to receive the YO layer message */
    rcvevt = ysEvtCreate(yoMsgRcvHdlr, (dvoid *) md, ctx->evtq, FALSE);
    DISCARD yotRecvV(ctx->rrport,&md->addr,md->bv,md->nbv,rcvevt);
  }
  yseCatchAll
  {
    if(bv) ysBvFree(ysmGlbHeap(),bv,nbv);
    if(md) ysmGlbFree((dvoid *) md);
    if(rcvevt) ysEvtDestroy(rcvevt);
    ctx->rrevt = (ysevt *) 0;

    /* port receive failure */
    ysRecord(YOGEN_ERR(2), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
  }
  yseEnd;
}


STATICF void yoMsgRcvHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                           /* ARGUSED */ size_t argsz)
{
  yoctx *ctx;
  yomd *md = (yomd *) usrp;
  sb4 len;
  ub4 glen;
  ub1 mtype;
  char astr[YOTAMAXLEN];
  ub4 reftag;
  ysbv *bv;
  sword nbv;

  ctx = yoCtx;
  ctx->rrevt = (ysevt *) 0;

  if(exid)
  {
    /* message receive failed */
    ysRecord(YOGEN_ERR(3), YSLSEV_ERR, (char *)0, YSLSTR(exid), YSLEND);
    yoFreeMsgDesc(ctx->rcvhp,md);
    goto skipmsg;
  }

  len = *(sb4 *)arg;
  DISCARD yotAddrToStr(md->addr,astr,sizeof(astr));

  if(yotAddrEq(md->addr,ctx->iiopbr))                 /* IIOP bridge address */
    reftag = YOGIIOR_TAG_INTERNET;
  else
    reftag = YOGIIOR_TAG_YO;

  yseTry
  {
    md->x = (yosx*)0;
    if(yocyIsCipher(md->bv))
      if(ctx->cycx)
      {
	yocyBvDecrypt(ctx,md->bv,md->nbv,&bv,&nbv,ctx->rcvhp);
	ysBvFree(ctx->rcvhp,md->bv,md->nbv);
	md->bv = bv;
	md->nbv = nbv;
      }
      else
	yseThrow(YO_EX_CRYPTO_ERR);
    else if(ctx->cycx)
      yseThrow(YO_EX_CRYPTO_ERR);

    md->x = yosxDecode(0,md->bv,md->nbv);
    mtype = yogiGetMsgHeader(md->x,&glen);
    ysRecord(YOGEN_ERR(4), YSLSEV_DEBUG(8), (char *)0, YSLSTR(astr),
             YSLUB4(mtype), YSLUB4(len), YSLUB4(glen), YSLEND);
    yseTry
    {
      switch(mtype)                                  /* extract message type */
      {
      case YOGIMT_REQ:
        yoReqRcv(ctx,md,reftag);                      /* process the request */
        break;
      case YOGIMT_REP:
        yoRepRcv(ctx,md,(ub4)mtype);                    /* process the reply */
        break;
      case YOGIMT_LOCREQ:                                /* location request */
        yoLocReqRcv(ctx,md,reftag);
        break;
      case YOGIMT_LOCREP:                                  /* location reply */
        yoRepRcv(ctx,md,(ub4)mtype);
        break;
      case YOGIMT_ERR:
        break;
      default:
        ysRecord(YOGEN_ERR(5), YSLSEV_WARNING, (char *)0, YSLNONE);
        /* fall through */
      case YOGIMT_CLOSE:                                 /* close connection */
      case YOGIMT_CANCEL:                                  /* cancel request */
        /* we just eat these messages */
        yoFreeMsgDesc(ctx->rcvhp,md);
        break;
      }
    }
    yseCatchAll
    {
      ysRecord(YOGEN_ERR(6), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
    }
    yseEnd;
  }
  yseCatchAll
  {
    yoFreeMsgDesc(ctx->rcvhp,md);
    ysRecord(YOGEN_ERR(7), YSLSEV_ERR, (char *)0, YSLSTR(yseExid),
             YSLSTR(astr), YSLEND);
  }
  yseEnd;

 skipmsg:
  if(!ctx->rrevt)
  {
    /* wait for message */
    yseTry
    {
      ctx->rrevt = ysEvtCreate(yoMsgWaitHdlr, (dvoid *)ctx, ctx->evtq, FALSE);
      DISCARD yotTest(ctx->rrport,YSTM_INFINITE,ctx->rrevt);
    }
    yseCatchAll
    {
      ysRecord(YOGEN_ERR(8), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
    }
    yseEnd;
  }
}

/* ARGSUSED */
STATICF void yoHbWaitHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                          size_t argsz /* ARGUSED */)
{
  yoctx *ctx = (yoctx *) usrp;
  sb4 len;
  ysbv *noreg bv;
  noreg sword nbv;
  yomd *noreg md = (yomd *) 0;
  ysevt *noreg rcvevt = (ysevt *) 0;

  NOREG(bv);
  NOREG(nbv);
  NOREG(md);
  NOREG(rcvevt);
  bv = (ysbv*)0;
  nbv = 0;

  if(exid)                                         /* problem with port test */
  {
    ctx->hbevt = (ysevt *) 0;
    ysRecord(YOGEN_ERR(1), YSLSEV_ERR, (char *)0, YSLSTR(exid), YSLEND);
    return;
  }
  if(!ctx->evtq) return;                       /* drop message shutting down */

  len = *(sb4 *)arg;                                   /* get message length */

  yseTry
  {
    yoAllocMsgBufs(ctx->rcvhp,len,(ysbv **)&bv,(sword *)&nbv);

    /* allocate memory for the request / reply */
    md = (yomd *) ysmAlloc(ctx->rcvhp,sizeof(yomd),yoTagMsgDesc);
    md->usrp = (dvoid *) 0;
    md->addr = (yota *) 0;
    md->x = (yosx *) 0;
    md->len = len;
    md->bv = bv;
    md->nbv = nbv;

    /* attempt to receive the YO layer message */
    rcvevt = ysEvtCreate(yoHbRcvHdlr, (dvoid *) md, ctx->evtq, FALSE);
    DISCARD yotRecvV(ctx->hbport,&md->addr,md->bv,md->nbv,rcvevt);
  }
  yseCatchAll
  {
    if(bv) ysBvFree(ysmGlbHeap(),bv,nbv);
    if(md) ysmGlbFree((dvoid *) md);
    if(rcvevt) ysEvtDestroy(rcvevt);
    ctx->hbevt = (ysevt *) 0;

    /* port receive failure */
    ysRecord(YOGEN_ERR(2), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
  }
  yseEnd;
}

STATICF void yoHbRcvHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                          size_t argsz /* ARGUSED */)
{
  yoctx *ctx;
  yomd *md = (yomd *) usrp;
  sb4 len;
  char astr[YOTAMAXLEN];
  ub4 reqid;
  yocreq *req;

  ctx = yoCtx;
  ctx->hbevt = (ysevt *) 0;

  if(exid)
  {
    /* message receive failed */
    ysRecord(YOGEN_ERR(3), YSLSEV_ERR, (char *)0, YSLSTR(exid), YSLEND);
    yoFreeMsgDesc(ctx->rcvhp,md);
    goto skipmsg;
  }

  len = *(sb4 *)arg;
  DISCARD yotAddrToStr(md->addr,astr,sizeof(astr));
  
  yseTry
  {
    md->x = yosxDecode(0,md->bv,md->nbv);
    reqid = yoxGetPing(md->x);

    if(reqid)
      req = yoGetPendReq(ctx,reqid);
    else
      req = (yocreq *) 0;
    if(req)
    {
      DISCARD yotAddrToStr(md->addr,astr,sizeof(astr));
      ysRecord(YOCLI_ERR(8), YSLSEV_DEBUG(8), (char *)0, YSLSTR(astr),
               YSLUB4(reqid), YSLEND);
      if(req->ttl)
      {
        ysEvtDestroy(req->ttl);
        req->ttl = ysEvtCreate(yoReqTimeout, (dvoid *) req, ctx->evtq, TRUE);
        ysTimer(&ctx->reqto,req->ttl);
      }
      else
      {
        /* ttl event missing ?!? */
        ysRecord(YOCLI_ERR(9), YSLSEV_ERR, (char *)0, YSLNONE);
      }
    }
    else
    {
      /* ping for an unknown request */
      ysRecord(YOCLI_ERR(10), YSLSEV_WARNING, (char *)0, YSLUB4(reqid),
             YSLEND);
    }
    yoFreeMsgDesc(ctx->rcvhp,md);
  }
  yseCatchAll
  {
    yoFreeMsgDesc(ctx->rcvhp,md);
    ysRecord(YOGEN_ERR(7), YSLSEV_ERR, (char *)0, YSLSTR(yseExid),
             YSLSTR(astr), YSLEND);
  }
  yseEnd;

 skipmsg:
  if(!ctx->hbevt)
  {
    /* wait for message */
    yseTry
    {
      ctx->hbevt = ysEvtCreate(yoHbWaitHdlr, (dvoid *)ctx, ctx->evtq, FALSE);
      DISCARD yotTest(ctx->hbport,YSTM_INFINITE,ctx->hbevt);
    }
    yseCatchAll
    {
      ysRecord(YOGEN_ERR(8), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
    }
    yseEnd;
  }
}


yoo *yoRefCreate(yoctx *ctx, CONST ysid *intf, CONST char *impl,
                 yoRefData *id, ub4 key, yota *addr, dvoid *state,
                 boolean yocreate)
{
  yoo r, *ref;

  CLRSTRUCT(r);
  r.intf = intf;
  r.impl = impl;
  if(id)
    CPSTRUCT(r.id,*id);
  else
  {
    r.id._maximum = r.id._length = 0;
    r.id._buffer = (ub1 *) 0;
  }
  r.birthdate = (dvoid *)0;
  r.addr = addr;
  r.key = key;
  r.state = state;
  r.ucnt = 0;
  r.single = TRUE;
  r.grpid = 0;
  r.imp = (yoimp *)0;
  r.refq = (ysque *)0;

  /* build a reference if we don't have it */
  if(yocreate || !(ref = yoGetRef(ctx,r)))
  {
    ref = (yoo *)ysmGlbAlloc(sizeof(yoo),yoTagObjRef);
    CPSTRUCT(*ref,r);                                   /* deep copy refdata */
    if(r.id._buffer)
    {
      ref->id._buffer = (ub1 *) ysmGlbAlloc((size_t)r.id._length,"refdata");
      DISCARD memcpy((dvoid *)ref->id._buffer,(dvoid *)r.id._buffer,
                     (size_t)r.id._length);
    }

    if(addr && yotAddrEq(ctx->rrpaddr,addr))             /* local reference? */
    {
      if((key != YOSTID_INV && !yocreate) ||
         !(ref->imp = yoFindImp(ctx,intf,impl,FALSE)))
        bis(ref->flags,YOOFL_INVALID);
    }
    ysHshIns(ctx->refs,(dvoid *)ref,sizeof(*ref),(dvoid *)ref);
  }
  else
  {
    if(addr)
      yotAddrFree(addr);
  }

  return (yoo *)yoDuplicate((dvoid *)ref);
}

yoo *yoRefCreateIOR(yoctx *ctx, yogiIOR *ior)
{
  yoo r, *ref;

  CLRSTRUCT(r);
  bis(r.flags,YOOFL_IOR);
  CPSTRUCT(r.ior,*ior);
  r.intf = r.ior.type_id;
  ref = yoGetRef(ctx,r);
  if(!ref)
  {
    ref = (yoo *) ysmGlbAlloc(sizeof(yoo),yoTagObjRef);
    CPSTRUCT(*ref,r);
    ysHshIns(ctx->refs,(dvoid *)ref,sizeof(*ref),(dvoid *)ref);
  }
  else
    yogiFreeIOR(ior);

  return (yoo *)yoDuplicate((dvoid *)ref);
}

sword yoRefEq(dvoid *elm, dvoid *key, /* ARGUSED */ size_t keysz)
{
  yoo *r1, *r2;
  boolean iorf;

  r1 = (yoo *) elm;
  r2 = (yoo *) key;

  if((iorf = (boolean)bit(r1->flags,YOOFL_IOR)) == bit(r2->flags,YOOFL_IOR))
  {
    if(iorf)
    {
      return yogiCmpIOR(&r1->ior,&r2->ior) != 0;
    }
    else
    {
      if(r1->key == r2->key)
      {
        /* addresses need to match */
        if(!r1->addr || !r2->addr)
        {
          if(r1->addr != r2->addr)
            return 1;
        }
        else
        {
          if(!yotAddrEq(r1->addr,r2->addr))
            return 1;
        }
        if(r1->key)
        {
          /* if tighly bound no need to check futher we have a match */
          return 0;
        }
        else
        {
          if(!r1->intf || !r2->intf)
          {
            if(r1->intf != r2->intf)
              return 1;
          }
          else
          {
            if(!ysidEq(r1->intf,r2->intf))
              return 1;
          }
          if(!r1->impl || !r2->impl)
          {
            if(r1->impl != r2->impl)
              return 1;
          }
          else
          {
            if(strcmp(r1->impl,r2->impl) != 0)
              return 1;
          }
          if(r1->id._length != r2->id._length)
          {
            return 1;
          }
          else
          {
            if(memcmp((dvoid *)r1->id._buffer,(dvoid *)r2->id._buffer,
                      (size_t)r1->id._length) != 0)
              return 1;
          }
          return 0;
        }
      }
    }
  }
  return 1;
}

void yoAllocMsgBufs(ysmhp *hp, sb4 len, ysbv **bv, sword *nbv)
{
  sb4 cnt, max, rem;
  ysbv *noreg vs;
  noreg sword i;
  ysbv *v;

  NOREG(vs);
  NOREG(i);

  *bv = vs = (ysbv *) 0;
  *nbv = 0;
  rem = 0;

  cnt = len / YO_RCVPGSZ;
  max = cnt;
  if((rem = len % YO_RCVPGSZ) != 0 || !cnt)
    cnt++;

  yseTry
  {
    i = 0;
    vs = (ysbv *)ysmAlloc(hp,(size_t)(sizeof(ysbv)*cnt),"rcv-bv");
    for(v = vs; i < max; i++, v++)                    /* allocate full pages */
    {
      v->len = YO_RCVPGSZ;
      v->buf = (ub1 *)ysmAlloc(hp,YO_RCVPGSZ,"rcv-buf");
    }
    if(cnt > max)                                   /* allocate the odd boy */
    {
      v->len = (size_t) rem;
      if(rem)
        v->buf = (ub1 *)ysmAlloc(hp,(size_t)rem,"rcv-buf");
      else
        v->buf = (ub1 *) 0;
    }
    *bv = vs;
    *nbv = (sword) cnt;
  }
  yseCatchAll
  {
    if(vs)                                       /* clean up our allocation */
    {
      max = i;
      for(v = vs, i = 0; i < max; i++, v++)
      {
        if(v->buf)
          ysmFree(hp,(dvoid *)v->buf);
      }
      ysmFree(hp,(dvoid *)vs);
    }
    ysRecord(YOGEN_ERR(10), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
    yseRethrow;
  }
  yseEnd;
}

void yoFreeMsgDesc(ysmhp *hp, yomd *md)
{
  if(md->addr)
    yotAddrFree(md->addr);
  if(md->x)
    yosxDecEnd(md->x);
  ysBvFree(hp,md->bv,md->nbv);
  ysmFree(hp,(dvoid *)md);
}

STATICF void yoFreeCliReqFF(dvoid *ptr)
{
  yoFreeCliReqF(yoCtx,(yocreq *)ptr);
}

STATICF void yoFreeCliReq(yoctx *ctx, yocreq *req)
{
  DISCARD yoRemPendReq(ctx,req->hdr.id);
  yoFreeCliReqF(ctx,req);
}

STATICF void yoFreeCliReqF(yoctx *ctx, yocreq *req)
{
  if(req->hdr.scxs.scl)
    yogiFreeSvcCtxLst(req->hdr.scxs.scl);
  if(req->hdr.op)
    ysmGlbFree((dvoid *)req->hdr.op);
  if(req->hdr.ref)
    yoRelease((dvoid *)req->hdr.ref);
  if(!req->bv)
    yosxEncEnd(req->x, &req->bv, &req->nbv);
  if(req->bv)
    ysBvFree(ctx->sndhp,req->bv,req->nbv);
  if(req->outs)
    ysLstDestroy(req->outs, (ysmff) 0);
  if(req->sevt)
    ysEvtDestroy(req->sevt);
  if(req->ttl)
    ysEvtDestroy(req->ttl);
  ysmFree(ctx->sndhp,(dvoid *)req);
}

/* ARGSUSED */
STATICF void yoIdle(dvoid *usrp, CONST ysid *exid, dvoid *arg, size_t argsz)
{
  yoctx *ctx = (yoctx *)usrp;
  boolean *work = (boolean *) arg;
  yoo *ydimref;

  if(exid)
  {
    /* FIXME: handle YS_EX_SHUTDOWN */
    return;
  }

  if(ctx->yoidle)
    return;
  ctx->yoidle++;

  if(!ctx->rrevt)                                  /* FIXME: move somewhere? */
  {
    /* wait for message on YO port */
    yseTry
    {
      ctx->rrevt = ysEvtCreate(yoMsgWaitHdlr, (dvoid *)ctx, ctx->evtq, FALSE);
      DISCARD yotTest(ctx->rrport,YSTM_INFINITE,ctx->rrevt);
      *work = TRUE;
    }
    yseCatchAll
    {
      if(ctx->rrevt)
      {
        ysEvtDestroy(ctx->rrevt);
        ctx->rrevt = (ysevt *) 0;
      }
    }
    yseEnd;
  }
  if(!ctx->hbevt)                                         /* bride of pinbot */
  {
    /* wait for message on YO port */
    yseTry
    {
      ctx->hbevt = ysEvtCreate(yoHbWaitHdlr, (dvoid *)ctx, ctx->evtq, FALSE);
      DISCARD yotTest(ctx->hbport,YSTM_INFINITE,ctx->hbevt);
      *work = TRUE;
    }
    yseCatchAll
    {
      if(ctx->hbevt)
      {
        ysEvtDestroy(ctx->hbevt);
        ctx->hbevt = (ysevt *) 0;
      }
    }
    yseEnd;
  }

  if(ctx->evtq && ysSvcPending(ctx->evtq))
  {
    ysSvcAll(ctx->evtq);
    *work = TRUE;
  }

  if(ysLstCount(ctx->reqsndq))
    *work |= yoReqQSend(ctx, ctx->reqsndq);

  ysMtxLock(&ctx->ydmtx);
  ydimref = ctx->ydimref;
  ysMtxUnlock(&ctx->ydmtx);

  if(ydimref &&
     (ysLstCount(ctx->deltaq) || bit(ctx->flags,YOCTXFL_SNDYORT)))
  {
    *work |= yoRunDeltaQ(ctx);
  }

  if(ctx->dqesem && (!ydimref || !ysLstCount(ctx->deltaq)))
  {
    ysTrigger(ctx->dqesem,(ysid *)0,(dvoid *)0,(size_t)0);
    ctx->dqesem = (ysevt *)0;
    *work = TRUE;
  }

  ctx->yoidle--;
  if(ctx->scq)
    ysSvcAll(ctx->scq);                               /* short circuit queue */
}


void yoDeadORBD(yoctx *ctx)
{
  yota *addr;
  yoo *ref;

  ysMtxLock(&ctx->ydmtx);
  addr = ctx->ydaddr;
  ref = ctx->ydimref;
  ctx->ydaddr = (yota *)0;
  ctx->ydimref = (yoo *)0;
  ysMtxUnlock(&ctx->ydmtx);
  if(addr)
    yotAddrFree(addr);
  if(ref)
    yoRelease((dvoid *)ref);

  yoLocateORBD((dvoid *)ctx, (CONST ysid *) 0, (dvoid *)0, (size_t) 0);
}

/* ARGSUSED */
STATICF void   yoLocateORBD(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                      size_t argsz)
{
  yoctx *ctx = (yoctx *) usrp;
  sysb8 retry;
  ysevt *noreg evt = (ysevt *) 0;
  yota   *ydaddr;

  NOREG(evt);

  ysMtxLock(&ctx->ydmtx);
  ydaddr = ctx->ydaddr;
  ysMtxUnlock(&ctx->ydmtx);

  if(ydaddr) return;

  yseTry
  {
    yoFindORBD(ctx);
    ysMtxLock(&ctx->ydmtx);
    ydaddr = ctx->ydaddr;
    ysMtxUnlock(&ctx->ydmtx);
    if(!ydaddr)
    {
      evt = ysEvtCreate(yoLocateORBD,usrp,ctx->evtq,FALSE);
      sysb8ext(&retry,YO_YDRETRY);
      ysTimer(&retry,evt);
    }
  }
  yseCatchAll
  {
    if(evt) ysEvtDestroy(evt);
    ysRecord(YOGEN_ERR(11), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
  }
  yseEnd;
}

/* keep a table of strings to avoid lots of copies */
char *yoGetStr(yoctx *ctx, CONST char *str)
{
  yostrc *sce;
  size_t slen;

  sce = (yostrc *) ysHshFind(ctx->strs,(dvoid *)str,slen=strlen(str));
  if(!sce)
  {
    sce = (yostrc *) ysmGlbAlloc(sizeof(yostrc) + slen,yoTagStrCache);
    sce->ucnt = 1;
    DISCARD memcpy((dvoid *)sce->str,(dvoid *)str,slen+1);
    ysHshIns(ctx->strs,(dvoid *)sce->str,strlen(sce->str),(dvoid *)sce);
  }
  else
    sce->ucnt++;

  return sce->str;
}

void yoFreeStr(yoctx *ctx, char *str)
{
  yostrc *sce;

  sce = (yostrc *) ((ub1 *)str - offsetof(yostrc,str));
  ysmCheck((dvoid *)sce,yoTagStrCache);

  if(!(--sce->ucnt))
  {
    if(ysHshRem(ctx->strs,(dvoid *)str,strlen(str)) != (dvoid *)sce)
       ysePanic(YO_EX_INTERNAL);
    ysmGlbFree((dvoid *)sce);
  }
}

STATICF sword yoStrEq(dvoid *elm, dvoid *key, /* ARGUSED */ size_t keysz)
{
  return (sword) strcmp(((yostrc *)elm)->str,(char *)key);
}

void yoFreeRef(dvoid *ref)
{
  yoo *r;

  ysmCheck((dvoid *)ref,yoTagObjRef);

  r = (yoo *) ref;

  if(bit(r->flags,YOOFL_IOR))
    yogiFreeIOR(&r->ior);
  if(r->id._buffer)
    ysmGlbFree((dvoid *)r->id._buffer);
  if(r->addr)
    yotAddrFree(r->addr);

  ysmGlbFree(ref);
}

void yoCheckRefcnt(CONST dvoid *ref, boolean on)
{
  if(on)
    bis(((yoo *)ref)->flags,YOOFL_DEBUG);
  else
    bic(((yoo *)ref)->flags,YOOFL_DEBUG);
}

/* ARGSUSED */
void yoCheckRefcnt_here(CONST dvoid *ref, ub4 ucnt)
{
}

sb4 yoGetUpTimeCs(void)
{
  sysb8 cs, t, div;

  sysb8ext(&div,10000);

  ysGetUpTime(&t);
  sysb8div(&cs,&t,&div);
  return sysb8msk(&cs);
}



