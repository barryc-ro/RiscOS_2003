/* Copyright (c) 1995 by Oracle Corporation.  All Rights Reserved.
 *
 * yotk.c - typecode manipulation
 */

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif
#ifndef YOTK_ORACLE
#include <yotk.h>
#endif
#ifndef YOTKI_ORACLE
#include <yotki.h>
#endif

/*
 * Constants & Types
 */

/* DISABLE check_naming */
externdef ysidDecl(YO_EX_BADCODE) = "yo::badcode";
externdef ysidDecl(YO_EX_BOUNDS) = "IDL:omg.org/CORBA/TypeCode/Bounds:1.0";
externdef ysidDecl(YO_EX_BOUNDSMISMATCH) = "yo::boundsmismatch";

static CONST_DATA yotk yoTcNull__TC[] = { 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTcVoid__TC[] = { 0x00,0x00,0x00,0x01 };
static CONST_DATA yotk yoTcShort__TC[] = { 0x00,0x00,0x00,0x02 };
/* yoTcLong defined in YS - don't panic */
static CONST_DATA yotk yoTcUshort__TC[] = { 0x00,0x00,0x00,0x04 };
/* yoTcUlong defined in YS - don't panic */
static CONST_DATA yotk yoTcFloat__TC[] = { 0x00,0x00,0x00,0x06 };
static CONST_DATA yotk yoTcDouble__TC[] = { 0x00,0x00,0x00,0x07 };
static CONST_DATA yotk yoTcBoolean__TC[] = { 0x00,0x00,0x00,0x08 };
static CONST_DATA yotk yoTcChar__TC[] = { 0x00,0x00,0x00,0x09 };
static CONST_DATA yotk yoTcOctet__TC[] = { 0x00,0x00,0x00,0x0a };
static CONST_DATA yotk yoTcAny__TC[] = { 0x00,0x00,0x00,0x0b };
static CONST_DATA yotk yoTcTypeCode__TC[] = { 0x00,0x00,0x00,0x0c };
static CONST_DATA yotk yoTcPrincipal__TC[] = { 0x00,0x00,0x00,0x0d };
static CONST_DATA yotk yoTcObject__TC[] =
 { 0x00,0x00,0x00,0x0e, 0x00,0x00,0x00,0x34, 0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x15, 'I', 'D', 'L', ':',  'C', 'O', 'R', 'B',
   'A', '/', 'O', 'b',  'j', 'e', 'c', 't',  ':', '1', '.', '0',
   0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x10, ':', ':', 'C', 'O',
   'R', 'B', 'A', ':',  ':', 'O', 'b', 'j',  'e', 'c', 't', 0x00 };


/* ENABLE check_naming */

/*
 * yotktTable - size and alignment table
 *
 * DESCRIPTION
 * The typecode interpreter expects to be able to traverse in-memory C data
 * structures, which means that it must have an understanding of the way
 * such data is laid out.  Fortunately, the C definition specifies enough
 * information that this can be accomplished by the compiler itself.
 *
 * The yotktTable is an array of size and alignment boundaries for each of
 * the typecode kinds.  If the alignment given is 1, then no alignment is
 * required (and the data is byte-packed).  Entries within this table
 * with an alignment of zero are not used and should be ignored.
 *
 * In particular, the typecode interpreter assumes that it can understand
 * the layout of structures and unions, and uses the following
 * representation principles (which are required by the C standard):
 *
 * 1) structures:  C compilers are constrained to assign components
 *    increasing memory addresses in a strict order, with the first
 *    component starting at the beginning of the address of the structure
 *    itself.  The alignment requirement for a structure will be at least as
 *    stringent as for the component having the most stringent requirements.
 *    The total size of a structure includes padding between and following
 *    the components that ensures that the structure terminates on the
 *    same alignment boundary on which it begins.
 *
 *    Note, however, that compilers may allow individual structures to be
 *    represented in different ways and this will confuse the typecode
 *    interpreter.  The IDL Compiler, therefore, must be instructed to
 *    insert pragmas required by the compiler to ensure that all structures
 *    are consistently represented.
 *
 * 2) unions: each component of a union is allocated storage starting at
 *    the beginning of the union.  An object of a union type will begin on
 *    a storage alignment boundary appropriate for the any component.  The
 *    size of the union is the amount of storage necessary to represent
 *    the largest component, plus any padding needed at the end to raise the
 *    length to the appropriate alignment boundary.  The alignment requirement
 *    is as stringent as the component having the most stringent requirement.
 */

/* cool generic code de tsepez@us.oracle.com */

typedef struct yotktDesc yotktDesc;
struct yotktDesc
{
  size_t size;
  size_t align;
  size_t salign;
};

typedef struct { ub1 yotktsb2x; sb2 yotktsb2f; } yotktsb2;
typedef struct { ub1 yotktsb4x; sb4 yotktsb4f; } yotktsb4;
typedef struct { ub1 yotktub2x; ub2 yotktub2f; } yotktub2;
typedef struct { ub1 yotktub4x; ub4 yotktub4f; } yotktub4;
typedef struct { ub1 yotktfloatx; float yotktfloatf; } yotktfloat;
typedef struct { ub1 yotktdoublex; double yotktdoublef; } yotktdouble;
typedef struct { ub1 yotktboolx; boolean yotktboolf; } yotktbool;
typedef struct { ub1 yotktcharx; char yotktcharf; } yotktchar;
typedef struct { ub1 yotktub1x; ub1 yotktub1f; } yotktub1;
typedef struct { ub1 yotktyoanyx; yoany yotktyoanyf; } yotktyoany;
typedef struct { ub1 yotktyotkx; yotk *yotktyotkf; } yotktyotk;
typedef struct { ub1 yotktseqx; YCIDL_sequence_ub1 yotktseqf; } yotktseq;
typedef struct { ub1 yotktptrx; dvoid *yotktptrf; } yotktptr;
typedef struct { ub1 yotktstringx; char *yotktstringf; } yotktstring;
typedef struct { ub1 yotktsysb8x; sysb8 yotktsysb8f; } yotktsysb8;

typedef struct { ub1 yotktsb2sx; yotktsb2 yotktsb2sf; } yotktsb2s;
typedef struct { ub1 yotktsb4sx; yotktsb4 yotktsb4sf; } yotktsb4s;
typedef struct { ub1 yotktub2sx; yotktub2 yotktub2sf; } yotktub2s;
typedef struct { ub1 yotktub4sx; yotktub4 yotktub4sf; } yotktub4s;
typedef struct { ub1 yotktfloatsx; yotktfloat yotktfloatsf; } yotktfloats;
typedef struct { ub1 yotktdoublesx; yotktdouble yotktdoublesf; } yotktdoubles;
typedef struct { ub1 yotktboolsx; yotktbool yotktboolsf; } yotktbools;
typedef struct { ub1 yotktcharsx; yotktchar yotktcharsf; } yotktchars;
typedef struct { ub1 yotktub1sx; yotktub1 yotktub1sf; } yotktub1s;
typedef struct { ub1 yotktyoanysx; yotktyoany yotktyoanysf; } yotktyoanys;
typedef struct { ub1 yotktyotksx; yotktyotk yotktyotksf; } yotktyotks;
typedef struct { ub1 yotktseqsx; yotktseq yotktseqsf; } yotktseqs;
typedef struct { ub1 yotktptrsx; yotktptr yotktptrsf; } yotktptrs;
typedef struct { ub1 yotktstringsx; yotktstring yotktstringsf; } yotktstrings;
typedef struct { ub1 yotktsysb8sx; yotktsysb8 yotktsysb8sf; } yotktsysb8s;

#define yotkt3(a, b, c) { (a), (b), (c) }
#define yotkt5(a, b, c, d, e) { sizeof(a), offsetof(b, c), offsetof(d, e) }

static CONST_DATA yotktDesc yotktTable[] =
{
  yotkt3(0, 1, 1),                                                /* tk_null */
  yotkt3(0, 1, 1),                                                /* tk_void */
  yotkt5(sb2, yotktsb2, yotktsb2f, yotktsb2s, yotktsb2sf),       /* tk_short */
  yotkt5(sb4, yotktsb4, yotktsb4f, yotktsb4s, yotktsb4sf),        /* tk_long */
  yotkt5(ub2, yotktub2, yotktub2f, yotktub2s, yotktub2sf),       /* tk_short */
  yotkt5(ub4, yotktub4, yotktub4f, yotktub4s, yotktub4sf),       /* tk_ulong */
  /* tk_float */
  yotkt5(float, yotktfloat, yotktfloatf, yotktfloats, yotktfloatsf),
  /* tk_double */
  yotkt5(double, yotktdouble, yotktdoublef, yotktdoubles, yotktdoublesf),
  /* tk_bool */
  yotkt5(boolean, yotktbool, yotktboolf, yotktbools, yotktboolsf),
  yotkt5(char, yotktchar, yotktcharf, yotktchars, yotktcharsf),   /* tk_char */
  yotkt5(ub1, yotktub1, yotktub1f, yotktub1s, yotktub1sf),         /* tk_ub1 */
  /* tk_any */
  yotkt5(yoany, yotktyoany, yotktyoanyf, yotktyoanys, yotktyoanysf),  
  /* tk_typecode */
  yotkt5(yotk *, yotktyotk, yotktyotkf, yotktyotks, yotktyotksf),  
  /* tk_principal */
  yotkt5(YCIDL_sequence_ub1, yotktseq, yotktseqf, yotktseqs, yotktseqsf),  
  yotkt5(dvoid *, yotktptr, yotktptrf, yotktptrs, yotktptrsf),  /* tk_objref */
  yotkt3(0, 0, 0),                                              /* tk_struct */
  yotkt3(0, 0, 0),                                               /* tk_union */
  yotkt5(ub4, yotktub4, yotktub4f, yotktub4s, yotktub4sf),        /* tk_enum */
  /* tk_string */
  yotkt5(char *, yotktstring, yotktstringf, yotktstrings, yotktstringsf),
  /* tk_sequence */
  yotkt5(YCIDL_sequence_ub1, yotktseq, yotktseqf, yotktseqs, yotktseqsf),
  yotkt3(0, 0, 0),                                               /* tk_array */
  yotkt3(0, 0, 0),                                               /* tk_alias */
  yotkt3(0, 0, 0),                                              /* tk_except */
  /* tk_longlong */
  yotkt5(sysb8, yotktsysb8, yotktsysb8f, yotktsysb8s, yotktsysb8sf),
};

STATICF void yotkSizeSalign(CONST yotk *tk, size_t *sz, size_t *align, 
			    size_t *salign);
STATICF boolean yotkStructTrv(CONST yotk *tk, dvoid *val1, dvoid *val2,
                              dvoid *usrp,
                              boolean (*visit)(CONST yotk *tk, dvoid *val1,
                                               dvoid *val2, dvoid *usrp));
STATICF void yotkStructSz(CONST yotk *tk, size_t *sz, size_t *align,
			  size_t *salign);
STATICF boolean yotkUnionTrv(CONST yotk *tk, dvoid *val1, dvoid *val2,
                             dvoid *usrp,
                             boolean (*visit)(CONST yotk *tk, dvoid *val1,
                                              dvoid *val2, dvoid *usrp));
STATICF void yotkUnionSz(CONST yotk *tk, size_t *sz, size_t *align,
			 size_t *salign);
STATICF size_t yotkUnLblSize(yotkKind disckind);

/*
 * Accessors for primitive TypeCodes
 */

CONST yotk *yoTcNull__getTC(void)
{
  return yoTcNull__TC;
}

CONST yotk *yoTcVoid__getTC(void)
{
  return yoTcVoid__TC;
}

CONST yotk *yoTcShort__getTC(void)
{
  return yoTcShort__TC;
}

CONST yotk *yoTcUshort__getTC(void)
{
  return yoTcUshort__TC;
}

CONST yotk *yoTcFloat__getTC(void)
{
  return yoTcFloat__TC;
}

CONST yotk *yoTcDouble__getTC(void)
{
  return yoTcDouble__TC;
}

CONST yotk *yoTcBoolean__getTC(void)
{
  return yoTcBoolean__TC;
}

CONST yotk *yoTcChar__getTC(void)
{
  return yoTcChar__TC;
}

CONST yotk *yoTcOctet__getTC(void)
{
  return yoTcOctet__TC;
}

CONST yotk *yoTcAny__getTC(void)
{
  return yoTcAny__TC;
}

CONST yotk *yoTcTypeCode__getTC(void)
{
  return yoTcTypeCode__TC;
}

CONST yotk *yoTcPrincipal__getTC(void)
{
  return yoTcPrincipal__TC;
}

CONST yotk *yoTcObject__getTC(void)
{
  return yoTcObject__TC;
}

/*
 * TypeCode manipulation routines
 */

/* yotkDuplicateWaf - copy a typecode, private to OMN */
yotk *yotkDuplicateWaf(CONST yotk *tk, ysmaf af)
{
  yotk *ntk;
  size_t tklen;

  switch(yotkGetKind(tk))
  {
  case yotkNull:
    ntk = (yotk *)yoTcNull__TC;
    break;
  case yotkVoid:
    ntk = (yotk *)yoTcVoid__TC;
    break;    
  case yotkShort:
    ntk = (yotk *)yoTcShort__TC;
    break;
  case yotkLong:
    ntk = (yotk *)yoTcLong;		/* defined in YS */
    break;
  case yotkUshort:
    ntk = (yotk *)yoTcUshort__TC;
    break;
  case yotkUlong:
    ntk = (yotk *)yoTcUlong;		/* defined in YS */
    break;
  case yotkFloat:
    ntk = (yotk *)yoTcFloat__TC;
    break;
  case yotkDouble:
    ntk = (yotk *)yoTcDouble__TC;
    break;
  case yotkBoolean:
    ntk = (yotk *)yoTcBoolean__TC;
    break;
  case yotkChar:
    ntk = (yotk *)yoTcChar__TC;
    break;
  case yotkOctet:
    ntk = (yotk *)yoTcOctet__TC;
    break;
  case yotkAny:
    ntk = (yotk *)yoTcAny__TC;
    break;
  case yotkTypeCode:
    ntk = (yotk *)yoTcTypeCode__TC;
    break;
  case yotkPrincipal:
    ntk = (yotk *)yoTcPrincipal__TC;
    break;
  case yotkString:
    ntk = (yotk *)yoTcString;		/* defined in YS */
    break;
  case yotkLongLong:
    ntk = (yotk *)yoTcLongLong;		/* defined in YS */
    break;
  default:
    ntk = (yotk *)0;
    break;
  }

  if (!ntk || tk != ntk)
  {
    tklen = yotkSize(tk);
    ntk = (yotk *)(*af)(tklen);
    DISCARD memcpy((dvoid *)ntk,(dvoid *)tk,tklen);
  }
  return ntk;
}

/* yotkFreeWaf - free storage required by a typecode, private to OMN */
void yotkFreeWaf(yotk *tk, ysmff ff)
{
  yotk *ntk;

  switch(yotkGetKind(tk))
  {
  case yotkNull:
    ntk = (yotk *)yoTcNull__TC;
    break;
  case yotkVoid:
    ntk = (yotk *)yoTcVoid__TC;
    break;    
  case yotkShort:
    ntk = (yotk *)yoTcShort__TC;
    break;
  case yotkLong:
    ntk = (yotk *)yoTcLong;		/* defined in YS */
    break;
  case yotkUshort:
    ntk = (yotk *)yoTcUshort__TC;
    break;
  case yotkUlong:
    ntk = (yotk *)yoTcUlong;		/* defined in YS */
    break;
  case yotkFloat:
    ntk = (yotk *)yoTcFloat__TC;
    break;
  case yotkDouble:
    ntk = (yotk *)yoTcDouble__TC;
    break;
  case yotkBoolean:
    ntk = (yotk *)yoTcBoolean__TC;
    break;
  case yotkChar:
    ntk = (yotk *)yoTcChar__TC;
    break;
  case yotkOctet:
    ntk = (yotk *)yoTcOctet__TC;
    break;
  case yotkAny:
    ntk = (yotk *)yoTcAny__TC;
    break;
  case yotkTypeCode:
    ntk = (yotk *)yoTcTypeCode__TC;
    break;
  case yotkPrincipal:
    ntk = (yotk *)yoTcPrincipal__TC;
    break;
  case yotkString:
    ntk = (yotk *)yoTcString;		/* defined in YS */
    break;
  case yotkLongLong:
    ntk = (yotk *)yoTcLongLong;		/* defined in YS */
    break;
  default:
    ntk = (yotk *)0;
    break;
  }

  if (tk && (tk != ntk))
    (*ff)((dvoid *)tk);
}

/* yotkCmp - compare two typecodes for equality */
sword yotkCmp(CONST yotk *tk1, CONST yotk *tk2)
{
  size_t l1,l2;

  if(tk1 == tk2)
    return 0;
  l1 = yotkSize(tk1);
  l2 = yotkSize(tk2);

  if(l1 == l2)
    return (sword) memcmp((dvoid *)tk1,(dvoid *)tk2,l1);
  else
    return (sword) ((l1 < l2) ? -1 : 1);
}

/* yotkToStr - generate string representation of typecode value */
char *yotkToStr(CONST yotk *tk)
{
#define YOTK_TO_HEXD(x) (((sb1)(x) > 9) ? ((x) - 10 + 'a') : ((x) + '0'))
  CONST ub1 *buf;
  CONST ub1 *end;
  ub1 t;
  size_t tksz;
  char *str;
  char *s;
  size_t strsz;

  /* prescan for length */
  tksz = yotkSize(tk);
  buf = (CONST ub1 *)tk;
  end = buf + tksz;
  for(strsz = 3; buf < end; buf++)
  {
    strsz += 4;
    t = *buf;
    if((!isalnum((int)t) && !ispunct((int)t)) || t != '\\' || t != '\'')
      strsz += 4;
  }

  /* build the actual string */
  str = (char *) ysmGlbAlloc(strsz,"yotk-str");
  s = str;
  *s++ = '{';
  for(buf = (ub1 *)tk; buf < end; buf++)
  {
    t = *buf;
    if((isalnum((int)t) || ispunct((int)t)) && t != '\\' && t != '\'')
    {
      *s++ = '\'';
      *s++ = (char) *buf;
      *s++ = '\'';
    }
    else
    {
      *s++ = '0';
      *s++ = 'x';
      *s++ = (char) YOTK_TO_HEXD(t>>4 & 0x0f);
      *s++ = (char) YOTK_TO_HEXD(t & 0x0f);
    }
    *s++ = ',';
  }
  *(s-1) = '}';
  *s = '\0';

  return str;
}
#undef YOTK_TO_HEXD

/*
 * TypeCode inspection routines
 */

/* yotkKind - return primitive kind of a typecode */
yotkKind yotkGetKind(CONST yotk *tk)
{
  return (yotkKind) sysxGetUaB4((ub1 *)tk);
}

/* yotkGetBaseKind - return the base kind of a typecode */
yotkKind yotkGetBaseKind(CONST yotk *tk)
{
  yotkKind kind = sysxGetUaB4((ub1 *)tk);
  
  if (kind == yotkAlias)
  {
    ysbv bv;
    yosx x;
    ub4 dummy;

    yotkInitStream(&x, tk, &bv);
    while ((kind = yosxGetNetUB4(&x)) == yotkAlias)
    {
      dummy = yosxGetNetUB4(&x);                          /* skip tc length */
      yotkxSkipByteSex(&x);                                /* Skip byte sex */
      yotkxSkipString(&x);                                   /* skip rep id */
      yotkxSkipString(&x);                                     /* skip name */
    }
  }
  return kind;
}
    
/* yotkGetBaseType - return the base type of a typecode */
CONST yotk *yotkGetBaseType(CONST yotk *tk)
{
  ub1 *buf;
  yotkKind kind;
  
  buf = (ub1*)tk;
  kind = sysxGetUaB4(buf);
  if (kind == yotkAlias)
  {
    ysbv bv;
    yosx x;

    yotkInitStream(&x, tk, &bv);
    while ((kind = sysxGetUaB4(buf)) == yotkAlias)
    {
      yotkxSkipToBuffer(&x);
      yotkxSkipString(&x);                                   /* skip rep id */
      yotkxSkipString(&x);                                     /* skip name */
      yosxAlign(&x, (sword)4);                           /* start of sub tk */
      buf = x.ptr;
    }
  }
  return (yotk*)buf;
}

/* yotkGetName - extract the name of a typecode */
CONST char *yotkGetName(CONST yotk *tk)
{
  CONST char *name = (CONST char *)0;
  ysbv bv;
  yosx x;
  ub4 dummy;                  /* so Sun cc optimizer doesn't stomp our code */

  switch(yotkGetKind(tk))
  {
  case yotkObjref:
  case yotkStruct:
  case yotkExcept:
  case yotkUnion:
  case yotkEnum:
  case yotkAlias:
    yotkInitStream(&x, tk, &bv);
    yotkxSkipToBuffer(&x);
    yotkxSkipString(&x);                                          /* rep id */
    dummy = yosxGetNetUB4(&x);                               /* skip length */
    name = (char *) x.ptr;
    break;
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return name;
}

/* yotkGetId - extract the repository id from a typecode */
CONST char *yotkGetId(CONST yotk *tk)
{
  CONST char *id = (CONST char *)0;
  yosx x;
  ysbv bv;
  ub4 dummy;                  /* so Sun cc optimizer doesn't stomp our code */

  switch(yotkGetKind(tk))
  {
  case yotkObjref:
  case yotkStruct:
  case yotkExcept:
  case yotkUnion:
  case yotkEnum:
  case yotkAlias:
    yotkInitStream(&x, tk, &bv);
    yotkxSkipToBuffer(&x);
    dummy = yosxGetNetUB4(&x);                               /* skip length */
    id = (char *) x.ptr;
    break;
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return id;
}

/* yotkMbrCount - get # of members in a typecode */
ub4 yotkMbrCount(CONST yotk *tk)
{
  ub4  cnt = 0;
  yotkKind kind;
  
  kind = yotkGetKind(tk);
  switch (kind)
  {
  case yotkStruct:
  case yotkExcept:
  case yotkEnum:
  case yotkUnion:
  {
    ysbv bv;
    yosx x;

    yotkInitStream(&x, tk, &bv);
    yotkxSkipToBuffer(&x);
    yotkxSkipString(&x);                                          /* rep id */
    yotkxSkipString(&x);                                            /* name */
    if (kind == yotkUnion)
    {
      yotkxSkipTC(&x);                                        /* discrim tc */
      cnt = yosxGetNetUB4(&x);                          /* skip default ind */
    }
    cnt = yosxGetNetUB4(&x);
    break;
  }
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return cnt;
}

/* yotkMbrName  - get name associated with a particular index */
CONST char *yotkMbrName(CONST yotk *tk, ub4 index)
{
  ub4  i;
  size_t dsz = 0;
  yotkKind kind = yotkGetKind(tk);
  ysbv bv;
  yosx x;
  const char* name;
  
  switch (kind)
  {
  case yotkStruct:
  case yotkExcept:
  case yotkEnum:
  case yotkUnion:
    break;
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            /* rep id */
  yotkxSkipString(&x);                                              /* name */
    /* skip discrim info, get discrim size */
  if (kind == yotkUnion)
  {
    yosxAlign(&x, (sword)4);
    dsz = yotkUnLblSize(yotkGetKind((yotk *)x.ptr));    /* size of lbl vals */
    yotkxSkipTC(&x);                                          /* discrim tc */
    i = yosxGetNetUB4(&x);                              /* skip default ind */
  }

  if (index >= yosxGetNetUB4(&x))                           /* member count */
    yseThrow(YO_EX_BOUNDS);

    /* locate correct member */
  for (i = 0; i < index ; i++)
  {
    if (kind == yotkUnion)                            /* skip discrim value */
    {
      yosxAlign(&x, (sword)dsz);
      yosxSkip(&x, dsz);
    }
    yotkxSkipString(&x);                                   /* skip mem name */
    if (kind != yotkEnum)
      yotkxSkipTC(&x);                                     /* mem type code */
  }

  if (kind == yotkUnion)
  {                                                          /* label value */
    yosxAlign(&x, (sword)dsz);
    yosxSkip(&x, dsz);
  }
  dsz = yosxGetNetUB4(&x);                             /* throw away strlen */
  name = (char*)x.ptr;
  return name;
}

/* yotkMbrType  - get type of a particular index */
CONST yotk *yotkMbrType(CONST yotk *tk, ub4 index)
{
  ub4  i;
  size_t dsz = 0;
  yotkKind kind = yotkGetKind(tk);
  ysbv bv;
  yosx x;
  const yotk* result;
  
  switch (kind)
  {
  case yotkStruct:
  case yotkExcept:
  case yotkUnion:
    break;
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            /* rep id */
  yotkxSkipString(&x);                                              /* name */

    /* skip discrim info, get discrim size */
  if (kind == yotkUnion)
  {                                 
    yosxAlign(&x, (sword)4);
    dsz = yotkUnLblSize(yotkGetKind((yotk *)x.ptr));    /* size of lbl vals */
    yotkxSkipTC(&x);                                          /* discrim tc */
    DISCARD yosxGetNetUB4(&x);                               /* default ind */
  }

  if (index >= yosxGetNetUB4(&x))                              /* mem count */
    yseThrow(YO_EX_BOUNDS);

    /* locate correct member */
  for (i = 0; i < index ; i++)
  {
    if (kind == yotkUnion)                            /* skip discrim value */
    {
      yosxAlign(&x, (sword)dsz);
      yosxSkip(&x, dsz);
    }
    yotkxSkipString(&x);                                   /* skip mem name */
    if (kind != yotkEnum)
      yotkxSkipTC(&x);                                     /* mem type code */
  }

  if (kind == yotkUnion)
  {                                                          /* label value */
    yosxAlign(&x, (sword)dsz);
    yosxSkip(&x, dsz);
  }
  yotkxSkipString(&x);                                       /* member name */
  yosxAlign(&x, 4);                                     /* find start of tk */
  result = (const yotk*)x.ptr;

  return result;
}

/* yotkDiscType - return the discriminator type for a union */
CONST yotk *yotkDiscType(CONST yotk *tk)
{
  ysbv bv;
  yosx x;
  const yotk* result;

  if (yotkGetKind(tk) != yotkUnion)
    yseThrow(YO_EX_BADCODE);

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            /* rep id */
  yotkxSkipString(&x);                                              /* name */
  yosxAlign(&x, (sword)4);
  result = (const yotk*)x.ptr;
  return result;
}

/* yotkMbrLabel - return the label value for a union */
/* 
 * It is the responsibility of the caller to free _value field of the
 * yoany that is returned.
 */
yoany yotkMbrLabel(CONST yotk *tk, ub4 index)
{
  yoany parm;
  ub4   i;
  ub4  lval;
  ub2  sval;
  size_t dsz = 0;
  ysbv bv;
  yosx x;
  yotkKind dkind;
  
  if (yotkGetKind(tk) != yotkUnion)
    yseThrow(YO_EX_BADCODE);
  if (index > yotkMbrCount(tk))
    yseThrow(YO_EX_BOUNDS);

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            /* rep id */
  yotkxSkipString(&x);                                              /* name */

  yosxAlign(&x, (sword)4);
  parm._type = (yotk *) x.ptr;
  yotkxSkipTC(&x);                                            /* discrim tk */
  dkind = yotkGetKind(yotkGetBaseType(parm._type));
  dsz = yotkUnLblSize(dkind);                           /* size of lbl vals */
  lval = yosxGetNetUB4(&x);                                  /* default ind */
  lval = yosxGetNetUB4(&x);                                    /* mem count */

    /* locate member we want */
  for (i=0 ; i < index ; i++)
  {
    yosxAlign(&x, (sword)dsz);                               /* label value */
    yosxSkip(&x, dsz);
    yotkxSkipString(&x);                                        /* mem name */
    yotkxSkipTC(&x);                                              /* mem tk */
  }

    /* alloc space for value and retrieve it. Caller to free */
  switch(dkind)
  {
    case yotkShort:
    case yotkUshort:
      parm._value = ysmGlbAlloc(2, "value");
      sval = yosxGetNetUB2(&x);
      *(ub2 *) parm._value = sval;
      break;
    case yotkLong:
    case yotkUlong:
    case yotkEnum:
    case yotkBoolean:
      parm._value = ysmGlbAlloc(4, "value");
      lval = yosxGetNetUB4(&x);
      *(ub4 *) parm._value = lval;
      break;
    case yotkChar:
      parm._value = ysmGlbAlloc(1, "value");
      *(ub1 *) parm._value = yosxGetNetUB1(&x);
      break;
    default:
      yseThrow(YO_EX_BADCODE);
      break;
  }
  return parm;
}

/* yotkDefIndex - returns the index of the default value (if any) in a union */
ub4   yotkDefIndex(CONST yotk *tk)
{
  ysbv bv;
  yosx x;
  ub4 result;

  if (yotkGetKind(tk) != yotkUnion)
    yseThrow(YO_EX_BADCODE);

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            /* rep id */
  yotkxSkipString(&x);                                              /* name */
  yotkxSkipTC(&x);                                            /* discrim tk */
  result = yosxGetNetUB4(&x);
  return result;
}

/* yotkLength - return length of string, seq, array */
ub4 yotkLength(CONST yotk *tk)
{
  ub4  len = 0;
  
  switch (yotkGetKind(tk))
  {
  case yotkString:
    len = sysxGetUaB4(((ub1 *)tk)+4);
    break;
  case yotkSequence:
  case yotkArray:
  {
    ysbv bv;
    yosx x;

    yotkInitStream(&x, tk, &bv);
    yotkxSkipToBuffer(&x);
    yotkxSkipTC(&x);
    len = yosxGetNetUB4(&x);
    break;
  }
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return len;
}

/* yotkRecOffset - return offset of recursive typecode */
ub4 yotkRecOffset(CONST yotk *tk)
{
  sb4   off;
  ub4   i, cnt;
  yotk *btk;                                                /* base typecode */
  yotk *mtk;                                              /* member typecode */
  
  if (yotkGetKind(tk) != yotkRecurs)
    yseThrow(YO_EX_BADCODE);
  
  off = sysxGetUaB4(((ub1 *)tk)+4);
  btk = (yotk *)((ub1 *)tk + off + 4);        /* +4: offset includes itself */

  /* walk base typeCode until we find this pointer in a sequence */
  cnt = yotkMbrCount(btk);
  for (i=0 ; i<cnt; i++)
  {
    mtk = (yotk *)yotkMbrType(btk, i);
    if (yotkGetKind(mtk) == yotkSequence)
    {
      if (yotkContentType(mtk) == tk)
	return 1;
    }
  }
  
  /* XXX: must be nested more than one lvl deep. Can't deal w/ that yet */
  yseThrow(YO_EX_BADCODE);
  return 0;
}

/* Determine the type contained in an array, sequence or alias */
CONST yotk *yotkContentType(CONST yotk *tk)
{
  CONST yotk *ntk = (CONST yotk *)0;
  ysbv bv;
  yosx x;
  yotkKind kind;

  kind = yotkGetKind(tk);
  switch(kind)
  {
  case yotkSequence:
  case yotkArray:
  case yotkAlias:
    break;
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  if ( kind == yotkAlias )
  {
    yotkxSkipString(&x);                                          /* rep id */
    yotkxSkipString(&x);                                          /* name */
  }
  yosxAlign(&x, 4);
  ntk = (const yotk*) x.ptr;

  return ntk;
}

/* yotkParamCount - # of parameters in complex typecode */
ub4 yotkParamCount(CONST yotk *tk)
{
  ub4 cnt = 0;
  
  switch (yotkGetKind(tk))
  {
  case yotkNull:
  case yotkVoid:
  case yotkShort:
  case yotkUshort:
  case yotkLong:
  case yotkUlong:
  case yotkFloat:
  case yotkDouble:
  case yotkBoolean:
  case yotkChar:
  case yotkOctet:
  case yotkAny:
  case yotkTypeCode:
  case yotkPrincipal:
  case yotkLongLong:
    cnt = 0;
    break;
  case yotkString:
  case yotkObjref:
    cnt = 1;
    break;
  case yotkSequence:
  case yotkArray:
  case yotkAlias:
    cnt = 2;
    break;
  case yotkStruct:
  case yotkExcept:
    cnt = 1 + 2 * yotkMbrCount(tk);
    break;
  case yotkEnum:
    cnt = 1 + yotkMbrCount(tk);
    break;
  case yotkUnion:
    cnt = 2 + 3 * yotkMbrCount(tk);
    break;
  case yotkRecurs:
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return cnt;
}

/* yotkParam - nth parameter in complex typecode */
yoany yotkParam(CONST yotk *tk, ub4 index)
{
  yoany parm;
  
  if (index >= yotkParamCount(tk))
    yseThrow(YO_EX_BOUNDS);

  switch (yotkGetKind(tk))
  {
  case yotkString:
    parm._type  = (yotk *)yoTcUlong;                               /* length */
    parm._value = ysmGlbAlloc(4, "parm");
    *(ub4 *)parm._value = yotkLength(tk);
    break;
  case yotkObjref:
    parm._type  = (yotk *)yoTcString;                     /* interface id ?? */
    parm._value = ysmGlbAlloc(sizeof(char *), "parm");
    *(char **)parm._value = (char *)yotkGetName(tk);
    break;
  case yotkArray:
  case yotkSequence:
    if (index == 0)                                          /* content type */
    {
      parm._type  = (yotk *)yoTcTypeCode;
      parm._value = ysmGlbAlloc(sizeof(yotk *), "parm");
      *(yotk **)parm._value = (yotk *)yotkContentType(tk);
    }
    else                                                           /* length */
    {
      parm._type  = (yotk *)yoTcUlong;
      parm._value = ysmGlbAlloc(4, "parm");
      *(ub4 *)parm._value = yotkLength(tk);
    }
    break;
  case yotkAlias:
    if (index == 0)                                                  /* name */
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkGetName(tk);
    }
    else                                                     /* content type */
    {
      parm._type  = (yotk *)yoTcTypeCode;
      parm._value = ysmGlbAlloc(sizeof(yotk *), "parm");
      *(yotk **)parm._value = (yotk *)yotkContentType(tk);
    }
    break;
  case yotkStruct:
  case yotkExcept:
    if (index == 0)                                                  /* name */
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkGetName(tk);
    }
    else if (index % 2)                                          /* mbr name */

    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkMbrName(tk, (index-1)/2);
    }
    else                                                         /* mbr type */
    {
      parm._type  = (yotk *)yoTcTypeCode;
      parm._value = ysmGlbAlloc(sizeof(yotk *), "parm");
      *(yotk **)parm._value = (yotk *)yotkMbrType(tk, (index-1)/2);
    }
    break;
  case yotkEnum:
    if (index == 0)                                                  /* name */
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkGetName(tk);
    }
    else                                                         /* mbr name */
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkMbrName(tk, index-1);
    }
    break;
  case yotkUnion:
    if (index == 0)                                                  /* name */
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkGetName(tk);
    }
    else if (index == 1)                                        /* disc type */
    {
      parm._type  = (yotk *)yoTcTypeCode;
      parm._value = ysmGlbAlloc(sizeof(yotk *), "parm");
      *(yotk **)parm._value = (yotk *)yotkDiscType(tk);
    }
    else if ((index % 3) == 2)                                /* label value */
    {
      parm._type  = (yotk *)yoTcAny;
      parm._value = ysmGlbAlloc(sizeof(yoany), "any");
      *(yoany *)parm._value = yotkMbrLabel(tk, (index-2)/3);
    }
    else if ((index % 3) == 0)                                   /* mbr name */
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkMbrName(tk, (index-2)/3);
    }
    else                                                         /* mbr type */
    {
      parm._type  = (yotk *)yoTcTypeCode;
      parm._value = ysmGlbAlloc(sizeof(yotk *), "parm");
      *(yotk **)parm._value = (yotk *)yotkMbrType(tk, (index-2)/3 );
    }
    break;
  case yotkRecurs:
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return parm;
}

/*
 * TypeCode synthesis routines
 */

/* yotkCrStruct - create a TypeCode for a struct */
yotk *yotkCrStruct(CONST yrid *id, CONST ysid *nm, CONST yotkStrMbrSeq *mbrs)
{
  yosx *x;
  yosxPos lpos, epos;
  yotk  *ntk;
  ub4 tklen;
  ub4 i;
  CONST yotkStrMbr *mbr;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkStruct);                                       /* kind */
  yosxAlign(x,4);                               /* align for length position */
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   /* dummy length */
  yosxPutNetUB1(x,(ub1)0);                                        /* bytesex */
  yotkgPutStr(x,(const char *) id);                         /* repository id */
  yotkgPutStr(x,ysidToStr(nm));                                      /* name */

  if(mbrs && (mbrs->_length > 0))
  {
    yosxPutNetUB4(x,mbrs->_length);                          /* member count */
    for (i=0, mbr = mbrs->_buffer; i < mbrs->_length ; i++, mbr++)   /* mbrs */
    {
      yotkgPutStr(x,ysidToStr(mbr->name));                    /* member name */
      yosxAlign(x,4);
      yosxCopy(x,(ub1 *) mbr->type,yotkSize(mbr->type));      /* member type */
    }
  }
  else
    yosxPutNetUB4(x,(ub4)0);

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  /* length fixup */
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   /* finish the typecode */
  return ntk;
}

/* yotkCrUnion - create a TypeCode for a union */
yotk *yotkCrUnion(CONST yrid *id, CONST ysid *nm, CONST yotk *disc,
		  CONST yotkUnMbrSeq *mbrs)
{
  yotk *ntk;
  ub4    i;
  yosx *x;
  yosxPos lpos, epos;
  yosxPos dpos;
  ub4 tklen;
  ub4 disckind;
  CONST yotkUnMbr *umbr;
  boolean isDefault;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkUnion);                                        /* kind */
  yosxAlign(x,4);                               /* align for length position */
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   /* dummy length */
  yosxPutNetUB1(x,(ub1)0);                                        /* bytesex */
  yotkgPutStr(x,(const char*)id);                           /* repository id */
  yotkgPutStr(x,ysidToStr(nm));                                      /* name */
  yosxAlign(x,4);
  yosxCopy(x,(ub1 *) disc,yotkSize(disc));                        /* disc tk */
  yosxAlign(x,4);
  yosxGetPos(x,&dpos);                      /* get position of default index */
  yosxPutNetUB4(x,(ub4)-1);                                 /* default index */
  yosxPutNetUB4(x,mbrs->_length);                               /* arm count */
  disckind = yotkGetKind(yotkGetBaseType(disc));
  for (i=0, umbr=mbrs->_buffer; i < mbrs->_length ; i++, umbr++)
  {
    isDefault = (yotkGetKind(umbr->label._type) == yotkOctet);
    /* lay down discrim value */
    switch(disckind)
    {
    case yotkShort:
      if (!isDefault)
        yosxPutNetUB2(x,(ub2) *((sb2 *) umbr->label._value));
      else
        yosxPutNetUB2(x,(ub2) 0);
      break;
    case yotkLong:
      if (!isDefault)
        yosxPutNetUB4(x,(ub4) *((sb4 *) umbr->label._value));
      else
        yosxPutNetUB4(x,(ub4) 0);
      break;
    case yotkUshort:
      if (!isDefault)
        yosxPutNetUB2(x,(ub2) *((ub2 *) umbr->label._value));
      else
        yosxPutNetUB2(x,(ub2) 0);
      break;
    case yotkEnum:
    case yotkUlong:
      if (!isDefault)
        yosxPutNetUB4(x,(ub4) *((ub4 *) umbr->label._value));
      else
        yosxPutNetUB4(x,(ub4) 0);
      break;
    case yotkBoolean:
      if (!isDefault)
        yosxPutNetUB1(x,(ub1) *((boolean *) umbr->label._value));
      else
        yosxPutNetUB1(x,(ub1) 0);
      break;
    case yotkChar:
      if (!isDefault)
        yosxPutNetUB1(x,(ub1) *((char *) umbr->label._value));
      else
        yosxPutNetUB1(x,(ub1) 0);
      break;
    default:
      yseThrow(YO_EX_BADCODE);
      break;
    }
    yotkgPutStr(x,ysidToStr(umbr->name));                        /* arm name */
    yosxAlign(x,4);                                          /* align for tc */
    yosxCopy(x,umbr->type,yotkSize(umbr->type));                   /* arm tk */
    if(isDefault)
      yosxPutNetUB4AtPos(x, &dpos, (ub4)i);
  }

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  /* length fixup */
  yosxPutNetUB4AtPos(x, &lpos, tklen);
  ntk = yotkgGenTk(ysmGlbHeap(),x);                   /* finish the typecode */

  return ntk;
}

/* yotkCrEnum - create a TypeCode for an enum */
yotk *yotkCrEnum(CONST yrid *id, CONST ysid *nm, CONST yotkEnumMbrSeq *mbrs)
{
  yotk *ntk;
  yosx *x;
  yosxPos lpos, epos;
  ub4 tklen;
  ub4 i;
  
  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkEnum);                                         /* kind */
  yosxAlign(x,4);                               /* align for length position */
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   /* dummy length */
  yosxPutNetUB1(x,(ub1)0);                                        /* bytesex */
  yotkgPutStr(x,(const char *)id);                          /* repository id */
  yotkgPutStr(x,ysidToStr(nm));                                      /* name */
  yosxPutNetUB4(x,mbrs->_length);                            /* member count */
  for (i=0; i < mbrs->_length; i++)                          /* member names */
    yotkgPutStr(x,ysidToStr(mbrs->_buffer[i]));

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  /* length fixup */
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   /* finish the typecode */
  return ntk;
}

/* yotkCrAlias - create a TypeCode for an alias (typedef) */
yotk *yotkCrAlias(CONST yrid *id, CONST ysid *nm, CONST yotk *base)
{
  yotk *ntk;
  yosx *x;
  yosxPos lpos, epos;
  ub4 tklen;
  
  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkAlias);                                        /* kind */
  yosxAlign(x,4);                               /* align for length position */
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   /* dummy length */
  yosxPutNetUB1(x,(ub1)0);                                        /* bytesex */
  yotkgPutStr(x,(const char *)id);                          /* repository id */
  yotkgPutStr(x,ysidToStr(nm));                                      /* name */
  yosxAlign(x,4);
  yosxCopy(x,(ub1 *)base,yotkSize(base));                        /* typecode */

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  /* length fixup */
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   /* finish the typecode */

  return ntk;
}

/* yotkCrExcept - create a TypeCode for an interface (objref) */
yotk *yotkCrExcept(CONST yrid *id, CONST ysid *nm, CONST yotkStrMbrSeq *mbrs)
{
  yosx *x;
  yosxPos lpos, epos;
  yotk  *ntk;
  ub4 tklen;
  ub4 i;
  CONST yotkStrMbr *mbr;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkExcept);                                       /* kind */
  yosxAlign(x,4);                               /* align for length position */
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   /* dummy length */
  yosxPutNetUB1(x,(ub1)0);                                        /* bytesex */
  yotkgPutStr(x,(const char *) id);                         /* repository id */
  yotkgPutStr(x,ysidToStr(nm));                                      /* name */

  if(mbrs && (mbrs->_length > 0))
  {
    yosxPutNetUB4(x,mbrs->_length);                          /* member count */
    for (i=0, mbr = mbrs->_buffer; i < mbrs->_length ; i++, mbr++)   /* mbrs */
    {
      yotkgPutStr(x,ysidToStr(mbr->name));                    /* member name */
      yosxAlign(x,4);
      yosxCopy(x,(ub1 *) mbr->type,yotkSize(mbr->type));      /* member type */
    }
  }
  else
    yosxPutNetUB4(x,(ub4)0);

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  /* length fixup */
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   /* finish the typecode */
  return ntk;
}

/* yotkCrInterface - create a TypeCode for an interface (objref) */
yotk *yotkCrInterface(CONST yrid *id, CONST ysid *nm)
{
  yosx *x;
  yosxPos lpos, epos;
  yotk  *ntk;
  ub4 tklen;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkObjref);                                       /* kind */
  yosxAlign(x,4);                               /* align for length position */
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   /* dummy length */
  yosxPutNetUB1(x,(ub1)0);                                        /* bytesex */
  yotkgPutStr(x,(const char *) id);                         /* repository id */
  yotkgPutStr(x,ysidToStr(nm));                                      /* name */

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  /* length fixup */
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   /* finish the typecode */

  return ntk;
}

/* yotkCrString - create a TypeCode for a string */
yotk *yotkCrString(ub4 bound)
{
  ub1   *tk;

  tk = (ub1 *)ysmGlbAlloc(8, "yotk");

  sysxPutUaB4(tk, (ub4) yotkString);                                 /* kind */
  sysxPutUaB4(tk+4, bound);                                        /* length */

  return (yotk *)tk;
}

/* yotkCrSeq - create a TypeCode for a sequence */
yotk *yotkCrSeq(ub4 bound, CONST yotk *elt)
{
  yotk *ntk;
  yosx *x;
  yosxPos lpos, epos;
  ub4 tklen;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkSequence);                                     /* kind */
  yosxAlign(x,4);                               /* align for length position */
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   /* dummy length */
  yosxPutNetUB1(x,(ub1)0);                                        /* bytesex */
  yosxAlign(x,4);
  yosxCopy(x,(ub1 *)elt,yotkSize(elt));
  yosxPutNetUB4(x,bound);                                  /* sequence bound */

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  /* length fixup */
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   /* finish the typecode */

  return ntk;
}

/* yotkCrRecSeq - create a TypeCode for a recursive sequence */
yotk *yotkCrRecSeq(/* ARGUSED */ub4 bound, /* ARGUSED */ ub4 offset,
		   sb4 byteoff )
{
  ub1   *tk;

  tk = (ub1 *)ysmGlbAlloc(8, "yotk");

  sysxPutUaB4(tk, (ub4) yotkRecurs);
  sysxPutUaB4(tk+4, (ub4) byteoff);

  return (yotk *)tk;
}

/* yotkCrArray - create a TypeCode for an array */
yotk *yotkCrArray(ub4 length, CONST yotk *elt)
{
  yotk *ntk;
  yosx *x;
  yosxPos lpos, epos;
  ub4 tklen;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkArray);                                        /* kind */
  yosxAlign(x,4);                               /* align for length position */
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   /* dummy length */
  yosxPutNetUB1(x,(ub1)0);                                        /* bytesex */
  yosxAlign(x,4);
  yosxCopy(x,(ub1 *)elt,yotkSize(elt));                          /* typecode */
  yosxPutNetUB4(x,length);

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  /* length fixup */
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   /* finish the typecode */

  return ntk;
}

/*
 * TypeCode utility and traversal routines
 */

/* yotkSizeSalign - compute size, alignment, & struct alignment */
STATICF void yotkSizeSalign(CONST yotk *tk, size_t *sz, size_t *align, 
			    size_t *salign)
{
  yotkKind kind;
  ub4  bounds;
  const yotk *tk2;

  kind = yotkGetKind(tk);
  switch (kind)
    {
    case yotkNull:
    case yotkVoid:
    case yotkShort:
    case yotkLong:
    case yotkUshort:
    case yotkUlong:
    case yotkFloat:
    case yotkDouble:
    case yotkBoolean:
    case yotkChar:
    case yotkOctet:
    case yotkAny:
    case yotkTypeCode:
    case yotkObjref:
    case yotkEnum:
    case yotkString:
    case yotkSequence:
    case yotkLongLong:
      if (sz)
	*sz = yotktTable[kind].size;
      if (align)
	*align = yotktTable[kind].align;
      if (salign)
	*salign = yotktTable[kind].salign;
      break;
    case yotkStruct:
      yotkStructSz(tk, sz, align, salign);
      break;
    case yotkUnion:
      yotkUnionSz(tk, sz, align, salign);
      break;
    case yotkArray:
    {
      yotkCollDecomp(tk, &tk2, &bounds);

      /* size = size of element * number of elements */
      /* alignment = alignment of element. */
      yotkSizeSalign(tk2, sz, align, salign);
      if (sz)
	*sz = (size_t)(*sz * bounds);
      break;
    }
    case yotkAlias:
      yotkSizeSalign(yotkGetBaseType(tk), sz, align, salign);
      break;
    case yotkExcept:
      yotkStructSz(tk, sz, align, salign);
      break;
    default:
      yseThrow(YO_EX_BADCODE);
      break;
    }
}

/* yotkSizeAlign() - public function to return size & alignment */
void yotkSizeAlign(CONST yotk *tk, size_t *sz, size_t *align)
{
  size_t salign;
  yotkSizeSalign(tk, sz, align, &salign);
}

/* yotkUnionSz - compute the size and alignment of a union */
STATICF void yotkUnionSz(CONST yotk *tk, size_t *sz, size_t *align, 
			 size_t *salign)
{
  ub4    arms;
  size_t usz, ualign, usalign;
  size_t dsz, dalign, dsalign;
  size_t talign;
  yosx x;
  ysbv bv;

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            /* rep id */
  yotkxSkipString(&x);                                         /* type name */

  /* process discriminator */
  yosxAlign(&x, 4);                                  /* start of discrim tk */
  yotkSizeSalign((yotk*)x.ptr, &dsz, &dalign, &dsalign);
  yotkxSkipTC(&x);

  arms = yosxGetNetUB4(&x);                                  /* default ind */
  arms = yosxGetNetUB4(&x);                                    /* mem count */
  yotkUnionArmsSz(arms, dsz, &x, &usz, &ualign);
  
  /* alignment of struct is the greater of disc or arms alignment */
  talign = max(ualign, dsalign);

  if (sz)
  {
    *sz = ysRoundVal(dsz, ualign);       /* align past discriminator to arms */
    *sz += usz;                                                 /* skip arms */
    *sz = ysRoundVal(*sz, talign);                           /* tail padding */
  }

  /* offset alignment and struct alignment are identical */
  if (align)
    *align = talign;
  if (salign)
    *salign = talign;
}

/* yotkStructSz - compute the size and alignment of a structure */
STATICF void yotkStructSz(CONST yotk *tk, size_t *sz, size_t *align,
			  size_t *salign)
{
  ub4     members;
  size_t  tsz, talign, tsalign; 
  size_t  mbrsz, mbralign, mbrsalign;
  yosx    x;
  ysbv    bv;

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            /* rep id */
  yotkxSkipString(&x);                                         /* type name */

  tsz = 0, talign = 1, tsalign = 1;
  members = yosxGetNetUB4(&x);

  while (members--)
  {
    yotkxSkipString(&x);                                        /* mem name */
    yosxAlign(&x, (sword)4);                                /* mem typecode */
    tk = (yotk *) x.ptr;
    yotkxSkipTC(&x);

    /* determine size and alignment & struct alignment */
    yotkSizeSalign(tk, &mbrsz, &mbralign, &mbrsalign); 

    tsz = ysRoundVal(tsz, mbralign) + mbrsz;
    if (mbralign > talign)
      talign = mbralign;
    if (mbrsalign > tsalign)
      tsalign = mbrsalign;
  }

  /* round up to include tail & accounting for potential struct padding */
  if (sz)
    *sz = ysRoundVal(tsz, max(talign, tsalign));

  /* offset alignment and struct alignment are identical */
  if (align)
    *align = tsalign;
  if (salign)
    *salign = tsalign;
}

/* yotkUnionArmsSz - compute the size and alignment of the union arms */
void yotkUnionArmsSz(ub4 arms, size_t dsz, yosx *x, size_t *sz, size_t *align)
{
  size_t nsz, nalign, nsalign;
  size_t asz, aalign, asalign;

  nsz = 0; nalign = 1; nsalign = 1;

  while (arms--)
  {
    yosxAlign(x, (sword)dsz);                       /* start of label value */
    yosxSkip(x, dsz);                                   /* skip label value */
    yotkxSkipString(x);                                    /* skip mem name */
    yosxAlign(x, (sword)4);                              /* start of mem tk */

    /* size & alignment of arm */
    yotkSizeSalign((yotk *) x->ptr, &asz, &aalign, &asalign);
    yotkxSkipTC(x);

    /* strictest alignment is determined independently of largest size */
    if (aalign > nalign)
      nalign = aalign;
    if (asalign > nsalign)
      nsalign = asalign;
    if (asz > nsz)
      nsz = asz;
  }

  /* alignment of union is struct alignment, not member alignment */
  if (align)
    *align = nsalign;
  if (sz)
    *sz = ysRoundVal(nsz, nsalign);
}

dvoid *yotkOffset(CONST yotk *tk, ub4 mbr, dvoid *val)
{
  ub1 *ptr;
  CONST yotk *mtk;
  size_t sz, align, salign, tsz;
  yotkKind knd;
  yosx x;
  ysbv bv;
  ub4 i, arms;
  
  knd = yotkGetBaseKind(tk);
  ptr = (ub1 *)val;
  switch (knd)
  {
  case yotkSequence:
    ptr += 8;                                /* skip over length, max fields */
    ptr = *(dvoid **)ptr;                          /* reset to actual buffer */
    ;/* FALLTHROUGH */
  case yotkArray:
    i = yotkLength(tk);
    if (i && i <= mbr)
      yseThrow(YO_EX_BOUNDS);
    mtk = yotkContentType(tk);
    yotkSizeSalign(mtk, &sz, &align, &salign);
    ptr += sz * mbr;
    break;
  case yotkStruct:
  case yotkExcept:
    if (mbr >= yotkMbrCount(tk))
      yseThrow(YO_EX_BOUNDS);
    for (i=0, tsz=0; i <= mbr; i++) 
    {
      mtk = yotkMbrType(tk, i);

      yotkSizeSalign(mtk, &sz, &align, &salign);
      tsz = ysRoundVal(tsz, align);
      if (i < mbr)
        tsz += sz;
    }
    ptr += tsz;
    break;
  case yotkUnion:
    yotkInitStream(&x, tk, &bv);
    yotkxSkipToBuffer(&x);
    yotkxSkipString(&x);                                          /* rep id */
    yotkxSkipString(&x);                                       /* type name */

    /* process discriminator */
    yosxAlign(&x, 4);                                /* start of discrim tk */
    yotkSizeSalign((yotk*)x.ptr, &sz, &align, &salign);
    yotkxSkipTC(&x);

    arms = yosxGetNetUB4(&x);                                /* default ind */
    arms = yosxGetNetUB4(&x);                                  /* mem count */
    yotkUnionArmsSz(arms, sz, &x, &tsz, &align);

    /* Align ptr to beginning of enclosed union */
    tsz = ysRoundVal(sz, align);
    ptr += tsz;
    break;
  default:
    yseThrow(YO_EX_BADCODE);
  }
  return (dvoid *)ptr;
}


/* yotkTraverse - traverse a value */
boolean yotkTraverse(CONST yotk *tk, dvoid *val1, dvoid *val2, dvoid *usrp,
                     boolean (*visit)(CONST yotk *tk, dvoid *val1, dvoid *val2,
                                      dvoid *usrp))
{
  boolean sts = TRUE;
  yotkKind kind;
  CONST char *name;
  ub4    bounds;
  size_t sz;
  YCIDL_sequence_ub1 *vseqoct;
  const yotk *tk2;

  kind = yotkGetKind(tk);
  switch(kind)
  {
  case yotkObjref:
  case yotkStruct:
  case yotkExcept:
  case yotkUnion:
  case yotkEnum:
  case yotkAlias:
    name = yotkGetName(tk);
    break;
  default:
    name = "<none>";
    break;
  }
#ifdef DEBUG
  yslError("Traversing: kind = %d name = %s\n",kind,name);
#endif
  switch (kind)
    {
    case yotkNull:
    case yotkVoid:
    case yotkShort:
    case yotkLong:
    case yotkUshort:
    case yotkUlong:
    case yotkFloat:
    case yotkDouble:
    case yotkBoolean:
    case yotkChar:
    case yotkOctet:
    case yotkAny:
    case yotkTypeCode:
    case yotkPrincipal:
    case yotkObjref:
    case yotkLongLong:
    case yotkEnum:
    case yotkString:
      sts = (*visit)(tk, val1, val2, usrp);
      break;
    case yotkStruct:
      sts = yotkStructTrv(tk, val1, val2, usrp, visit);
      break;
    case yotkUnion:
      sts = yotkUnionTrv(tk, val1, val2, usrp, visit);
      break;
    case yotkSequence:
      vseqoct = (YCIDL_sequence_ub1 *) val1;
      bounds = vseqoct->_length;
      val1 = (dvoid *) vseqoct->_buffer;

      if (val2)
      {
        vseqoct = (YCIDL_sequence_ub1 *) val2;
        if (vseqoct->_length != bounds)
          yseThrow(YO_EX_BOUNDSMISMATCH);
        val2 = (dvoid *) vseqoct->_buffer;
      }

      tk = yotkContentType(tk);
      if (yotkGetKind(tk) == yotkRecurs)
	tk = tk + ((sb4) yotkGetLength(tk)) + 4;

      yotkSizeAlign(tk, &sz, (size_t *) 0);
      while (sts && bounds--)
      {
        sts = (*visit)(tk, val1, val2, usrp);
        val1 = (dvoid *) (((ub1 *) val1) + sz);
        if (val2)
          val2 = (dvoid *) (((ub1 *) val2) + sz);
      }
      break;
    case yotkArray:
      yotkCollDecomp(tk, &tk2, &bounds);
      yotkSizeAlign(tk2, &sz, (size_t *) 0);
      while (sts && bounds--)
      {
        sts = (*visit)(tk2, val1, val2, usrp);
        val1 = (dvoid *) (((ub1 *) val1) + sz);
        if (val2)
          val2 = (dvoid *) (((ub1 *) val2) + sz);
      }
      break;
    case yotkAlias:
      tk = yotkContentType(tk);
      sts = (*visit)(tk, val1, val2, usrp);
      break;
    case yotkExcept:
      sts = yotkStructTrv(tk, val1, val2, usrp, visit);
      break;
    case yotkRecurs:
    default:
      yseThrow(YO_EX_BADCODE);
      break;
    }

  return sts;
}

/* yotkStructTrv - traverse a structure */
STATICF boolean yotkStructTrv(CONST yotk *tk, dvoid *val1, dvoid *val2,
                           dvoid *usrp,
                           boolean (*visit)(CONST yotk *tk, dvoid *val1, 
                                            dvoid *val2, dvoid *usrp))
{
  boolean sts = TRUE;
  ub4    members;
  size_t sz, align, salign, tsz;
  yosx  x;
  ysbv  bv;
  ub1  *base1, *base2;

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                           /* rep id */
  yotkxSkipString(&x);                                        /* type name */

  base1 = (ub1 *)val1;
  base2 = (ub1 *)val2;
  tsz = 0;

  members = yosxGetNetUB4(&x);
  while (sts && members--)
  {
#ifdef DEBUG
    yslError("  struct member: name = %s\n",buf+4);
#endif
    yotkxSkipString(&x);                                       /* mem name */
    yosxAlign(&x, (sword)4);                               /* mem typecode */
    tk = (yotk *) x.ptr;
    if (yotkGetKind(tk) == yotkRecurs)
      tk = tk + ((sb4) yotkGetLength(tk)) + 4;      /* GetLength == offset */

    yotkSizeSalign(tk, &sz, &align, &salign);  /* determine sz & alignment */

    /* align the value pointer */
    tsz = ysRoundVal(tsz, align);
      
    val1 = (dvoid *)(base1 + tsz);
    if (val2)
      val2 = (dvoid *)(base2 + tsz);
 
    sts = (*visit)(tk, val1, val2, usrp);               /* visit the value */
    tsz += sz;                             /* skip the member in the value */
    yotkxSkipTC(&x);
  }
  return sts;
}

/* yotkUnionTrv - traverse a union */
STATICF boolean yotkUnionTrv(CONST yotk *tk, dvoid *val1, dvoid *val2,
                             dvoid *usrp,
                             boolean (*visit)(CONST yotk *tk, dvoid *val1,
                                              dvoid *val2, dvoid *usrp))
{
  boolean sts = TRUE;
  const yotk  *disctk;
  const yotk  *dflttk;
  sb4    dflt, lbl, tag;
  ub4    i, arms;
  size_t sz, usz, ualign;
  yosx  x;
  ysbv  bv;
  yotkKind dkind;
  yosxPos pos;

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                           /* rep id */
  yotkxSkipString(&x);                                        /* type name */

  /* process discriminator */
  yosxAlign(&x, (sword)4);                          /* start of discrim tk */
  disctk = (yotk *) x.ptr; 
  disctk = yotkGetBaseType(disctk);
  sts = (*visit)(disctk, val1, val2, usrp);     /* visit the discriminator */

  if (sts)
  {
    yotkSizeAlign(disctk, &sz, (size_t *) 0);

    /* get the tag value */
    tag = 0;			/* shut up uninit warning. */
    /* YYY: No need to unmarshal Tag ? */
    dkind = yotkGetKind(disctk);
    switch (dkind)
    {
      case yotkShort:
        tag = (sb4) *((sb2 *) val1);
        break;
      case yotkLong:
        tag = *((sb4 *) val1);
        break;
      case yotkUshort:
        tag = (sb4) *((ub2 *) val1);
        break;
      case yotkEnum:
      case yotkUlong:
        tag = (sb4) *((ub4 *) val1);
        break;
      case yotkBoolean:
        tag = (sb4) *((boolean *) val1);
        break;
      case yotkChar:
        tag = (sb4) *((char *) val1);
        break;
      default:
        yseThrow(YO_EX_BADCODE);
      break;
    }

    yotkxSkipTC(&x);                                    /* skip discrim tk */
    dflt = (sb4) yosxGetNetUB4(&x);                    /* get default case */
    dflttk = (yotk *) 0;                                 /* no default arm */

    arms = yosxGetNetUB4(&x);                    /* get the number of arms */
    yosxGetPos(&x, &pos);
    yotkUnionArmsSz(arms, sz, &x, &usz, &ualign);
    yosxSetPos(&x, &pos);

    /* skip past the discriminator */
    sz = ysRoundVal(sz, ualign);
    val1 = (dvoid *) (((ub1 *) val1) + sz);
    if (val2)
      val2 = (dvoid *) (((ub1 *) val2) + sz);

    /* locate the selected arm (remember default position) */
    lbl = (sb4)0;                                /* stomp compiler warning */
    for (i = 0; i < arms; i++)
    {
      switch (dkind)                                /* get the label value */
      {
        case yotkShort:
        case yotkUshort:
          lbl = (sb4) yosxGetNetUB2(&x);
          break;
        case yotkLong:
        case yotkEnum:
        case yotkUlong:
          lbl = (sb4) yosxGetNetUB4(&x);
          break;
        case yotkChar:
        case yotkBoolean:
          lbl = (sb4) yosxGetNetUB1(&x);
          break;
      }
      yotkxSkipString(&x);                             /* skip member name */
      yosxAlign(&x, (sword)4);                        /* start of typecode */

      if (dflt >= 0 && i == (ub4)dflt)                     /* save default */
	dflttk = (yotk *) x.ptr;
      else if (lbl == tag)                          /* do we have a match? */
	break;

      yotkxSkipTC(&x);                                      /* skip mem tk */
    }

    tk = (i == arms ? dflttk : (yotk *) x.ptr);
    if (tk)
      sts = (*visit)(tk, val1, val2, usrp);
  }
  return sts;
}

/*
 * pseudo - "PRIVATE" ROUTINES
 */

/* yotkGetLength - return length field of a typecode (if any) */
size_t yotkGetLength(CONST yotk *tk)
{
  return (size_t)(sysxGetUaB4(((ub1 *)tk) + 4));
}

/* yotkSize - return size required to hold a typecode */
size_t yotkSize(CONST yotk *tk)
{
  switch (yotkGetKind(tk))
  {
    case yotkString:
    case yotkRecurs:
      return 8;
    case yotkObjref:
    case yotkStruct:
    case yotkUnion:
    case yotkEnum:
    case yotkSequence:
    case yotkArray:
    case yotkAlias:
    case yotkExcept:
      return 8 + sysxGetUaB4(((ub1 *)tk + 4));
    default:
      return 4;
    }
}

/*
 * yotkInitStream
 *
 * Set up a yosx "unmarshalling" stream for walking through a typecode.
 * The buffer vector (bv) and yosx should be allocated by the caller.
 */
void yotkInitStream(yosx *x, const yotk *tk, ysbv *bv)
{
  bv->buf = (ub1 *)tk;
  bv->len = yotkSize(tk);
  yosxDecInit(x, FALSE, bv, (sword)1);
}

/*
 * yotkCollDecomp - Decompose a collection
 *
 * Split a sequence or array typecode into the typecode of the element
 * type and the bounds.
 */
void yotkCollDecomp(const yotk *tk, const yotk **etk, ub4* bounds)
{
  ysbv bv;
  yosx x;
  yotkKind kind;

  kind = yotkGetKind(tk);
  if ((kind != yotkSequence) && (kind != yotkArray))
    yseThrow(YO_EX_BADCODE);

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yosxAlign(&x, 4);
  *etk = (const yotk*) x.ptr;
  yotkxSkipTC(&x);
  *bounds = yosxGetNetUB4(&x);
}

/*
 * You'd really like these two operations to be in yotkg.c, but they're
 * needed by both yotk.c and yotkg.c. If you put them in yotkg.c, you 
 * run up against the circular dependency between yr and yo.
 */
void yotkgPutStr(yosx *x, const char *str)
{
  size_t len;

  if(str)
    len = strlen(str) + 1;
  else
    len = 0;

  yosxPutNetUB4(x,(ub4)len);
  if(len)
    yosxCopy(x,(ub1 *)str,len);
}

yotk *yotkgGenTk(ysmhp *hp, yosx *x)
{
  ysbv *bv, *b;
  sword nbv, i;
  yotk *tk;
  size_t len;

  yosxEncEnd(x, &bv, &nbv);
  if(nbv > 1)
  {
    for(len = 0, i = 0, b = bv; i < nbv; i++, b++)
      len += b->len;
    tk = (yotk *)ysmAlloc(hp, len,"yotk");
    ysBvGather(tk, len, bv, nbv);
    ysBvFree(hp, bv, nbv);
  }
  else
  {
    tk = (yotk *)ysmRealloc(hp,bv->buf,bv->len);
    ysmFree(hp,(dvoid *)bv);
  }
  return tk;
}


/*
 * yotkUnLblSize - size in bytes of union case label value in a typecode
 *
 * Can't use yotkSizeAlign for this because it is platform dependent
 * and thinks weird things such as booleans not 1 byte quantities.
 * Correct for manipulating values in the user's data, but not inside
 * a typecode.
 */
STATICF size_t yotkUnLblSize(yotkKind disckind)
{
  size_t sz;

  switch(disckind)
  {
    case yotkShort:
    case yotkUshort:
      sz = (size_t)2;
      break;
    case yotkLong:
    case yotkUlong:
    case yotkEnum:
      sz = (size_t)4;
      break;
    case yotkBoolean:
    case yotkChar:
      sz = (size_t)1;
      break;
    default:
      sz = (size_t)0;
      yseThrow(YO_EX_BADCODE);
      break;
  }
  return sz;
}
