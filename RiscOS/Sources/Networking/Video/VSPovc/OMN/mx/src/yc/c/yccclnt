/* Copyright (c) 1995 by Oracle Corporation.  All Rights Reserved.
 *
 * yccclnt.c - generation of client stubs for C language mapping
 *
 * NOTES
 *	In the client stubs we generate stub functions for each attribute
 *	and definitions for all the type codes, ysids, and pars structures
 *	declared in the public header.
 *
 *	There's a pars structure for every method, one for every readonly
 *	attribute, two for every read/write attribute. Type codes are
 *	required for most types; ysid's are needed for all interfaces types.
 *
 *	Both attributes and operations eventually go through the two
 *	functions yccGenSynchClient and yccGenAsyncClient for stub
 *	generation, to insure consistency of the stubs.
 *
 * CORBA 1.2 Mapping
 * =================
 * Here is a summary of how data is passed for a parameter of type T
 * in the IDL. In addition to parameter modes and returns, it lists
 * how yoSendReq expects to receive the data. 
 *
 * Type T            in     out/inout     return     yoSendReq
 * -----------------------------------------------------------
 * long,short,       T      T*            T          T*
 *  char,octet,
 *  (unsigned),
 *  float,double,
 *  boolean
 * enum              T      T*            T          T*
 * interface         T      T*            T          T*
 * struct,union,     T*     T*            T          T*
 *  seq, any
 * string            char*  char**        char*      char**
 * array (alias)     T      T             T_slice*   T
 *
 * Aliases behave as their base types do for most types, but interfaces,
 * strings, and arrays are handled as special cases. Where the base type
 * encapsulates a pointer (such as an interface or string typedef),
 * the behavior is altered accordingly. So, for instance, a string
 * typedef encodes to:  T (in), T* (out/inout), T (return), T* (yoSendReq)
 * because you would have "typedef char* T;". 
 *
 * Array aliases make use of the aliased array slice for returns, to
 * simplify the declarations. The alias name is used in all other cases.
 *
 * Stub Format
 * -----------
 * Stubs come in two flavors, COA and BOA (detailed below). Also, every
 * operation maps to a synchronous and an asynchronous client stub.
 *
 * In broad terms, the synchronous stubs:
 * a) check to see if this is a local call. If so, short-circuit the
 *    network trip and call the impl function directly.
 * b) If this isn't a local call, invoke the async stub and block until
 *    the call finishes (triggering the associated event).
 *
 * The asynchronous stub is nothing but a wrapper around yoSendReq which
 * puts the parameters into the desired format and makes the yoSendReq call.
 * 
 * COA Stubs
 * ---------
 * These are the default stubs. They all look pretty much the same except
 * for minor difference for handling return values and parameters. Here is
 * a simple example:
 *
 * IDL:  interface intf { long op(in long par); };
 *
 * sb4 intf_op( intf or, sb4 par, yoenv* ev)
 * {
 *   sb4 _result;                           (if there's a return value)
 *   ysevt* noreg _sem = (ysevt*)0;
 *   intf__tyimpl* _impl;
 *   yowiden _widen = (yowiden)0;
 * 
 *   NOREG(_sem);                           (if style == YCSTYLE_ORA)
 *
 *   _impl = (intf__tyimpl*) yoLocalObj((dvoid*)or, (yowiden)&_widen);
 *   if ( _impl )
 *   {
 *     if ( _widen )
 *     {
 *       yogfp _f = (*_widen)( N, _impl, intf__id);
 *
 *       _result = (*(sb4 (*)(intf, yoenv*, sb4))_f)(or, ev, par);
 *     }
 *     else
 *       _result = (*_impl->exists)(or, ev, par);
 *   }
 *   else
 *   {
 *     yoFilterRunEx((dvoid*)0r, ev, YOFLTR_CSND, (CONST ysid*)0, (dvoid*)0);
 *     yseTry
 *     {
 *       _sem = ysSemCreate( (dvoid*)0);
 *       intf_op_nw( or, ev, par, _sem);
 *     }
 *     yseCatchAll
 *     {
 *       CONST ysid* exid;
 *       dvoid* exbody;
 *
 *       exid = yseExid;
 *       exbody = yseExobj;
 *       yseTry
 *         yoFilterRunEx((dvoid*)or, ev, YOFLTR_CRCV, exid, exbody);
 *       yseFinally
 *         if ( _sem )
 *           ysSemDestroy((ysevt*)_sem);
 *       yseEnd
 *       yseRethrow;
 *     }
 *     yseEnd;
 *     yseTry
 *       ysSemSync((ysevt*)_sem, (dvoid*)&_result);
 *     yseFinally
 *       yoFilterRunEx((dvoid*)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
 *     yseEnd
 *   }
 *   return _result;
 * }
 *
 * void intf_op_nw( intf or, sb4 par, yoenv*, ysevt* _sem)
 * {
 *   dvoid* _parvec[1];                     (if there are pars)
 * 
 *   _parvec[0] = (dvoid*) &par;
 *   yoSendReq( (dvoid*) or, ev, "op", TRUE, _sem, 1, intf_op_pars, _parvec);
 * }
 *
 * BOA Stubs
 * ---------
 * Users can also decide they want CORBA Basic Object Adaptor (BOA) stubs.
 * The major difference between BOA and COA is that in COA exceptions are
 * propagated by yse's Throw/Catch mechanism, and under BOA the exceptions
 * are stuffed in the environment and never thrown via yseThrow. This means
 * the environment parameter looks a little different (because it is
 * carrying exception data) and the stubs trap all exceptions and stuff
 * them into the environment. So, life gets a little more complicated.
 * Using the same IDL as above:
 * 
 * sb4 intf_op( intf or, sb4 par, CORBA_Environment* ev)
 * {
 *   sb4 _result;
 *   ysevt* noreg _sem = (ysevt*)0;
 *   intf__tyimpl* _impl;
 *   yowiden _widen = (yowiden)0;
 * 
 *   NOREG(_sem); 
 *   if ( ev->_major != CORBA_NO_EXCEPTION )
 *     return _result;
 * 
 *   yseTry
 *   {
 *     _impl = (intf__tyimpl*)yoLocalObj((dvoid*)or, (yowiden)&_widen);
 *     if ( _impl )
 *     {
 *       if ( _widen )
 *       {
 *         yogfp _f = (*_widen)( N, _impl, intf__id);
 *
 *         _result = (*(sb4 (*)(intf, CORBA_Environment*, sb4))_f)
 *                       (or, ev, par);
 *       }
 *       else
 *         _result = (*_impl->exists)( or, ev, par);
 *     }
 *     else
 *     {
 *       ORA_CORBA_FilterRun((dvoid*)or, ev, YOFLTR_CSND, 
 *                           (CORBA_char*)0, (dvoid*)0);
 *       if ( ev->_major == CORBA_NO_EXCEPTION )
 *       {
 *         yseTry
 *           _sem = ysSemCreate( (dvoid*)0);
 *           intf_op_nw( or, ev, par, (ysevt*)_sem);
 *           ORA_CORBA_SemSynch( ev, (ysevt*)_sem, intf_op_pars, &result,
 *                               sizeof(_result));
 *         yseFinally
 *           ORA_CORBA_FilterRun((dvoid*)or, ev, YOFLTR_CRCV,
 *                               CORBA_exception_id, CORBA_exception_value);
 *           if ( _sem )
 *             ysSemDestroy( _sem);
 *         yseEnd
 *       }
 *     }
 *   }
 *   yseCatchAll
 *   {
 *     if ( _sem )
 *       ysSemDestroy((ysevt*)_sem);
 *     ev->_major = CORBA_SYSTEM_EXCEPTION;
 *     ev->id = yseExid;
 *   }
 *   yseEnd
 *   return _result;                        (if there is a return)
 * }
 * 
 * void intf_op_nw( intf or, sb4 par, CORBA_Environment* ev, ysevt* _sem)
 * {
 *   dvoid* _parvec[1];                     (if there are pars)
 * 
 *   parvec[0] = (dvoid*) &par;
 *   ORA_CORBA_SendReq((dvoid*) or, ev, "op", TRUE, _sem, 0, 
 *                 intf_op_pars, _parvec);
 * }
 *
 * Don't be tempted to think the two calls to ysSemDestroy in the synchronous
 * stub can be consolidated: ysSemDestroy itself may raise an exception, so
 * it has to be part of the try block AND part of the catch block.
 *
 * CORBA 2.0 Mapping
 * =================
 *
 * The major differences between 1.2 and 2.0 at the user level are:
 *
 * - Environment parameter placement 
 * - Parameter and return type handling is different
 * - New type-specific allocator functions are generated
 *
 * Environment Parameter
 * ---------------------
 * In CORBA 1.2, the env param always comes immediately after the 
 * discriminated object; in other words, it is always the 2nd parameter.
 * In CORBA 2.0, the env param is always on the end. OK, almost always:
 * we have extended the CORBA mapping for async calls (the "_nw" stubs)
 * by adding a ysevt* parameter. I have chosen to place this after the
 * environment parameter in all cases so that our extensions are always
 * added to the end, thereby making them easier for users to add/delete.
 *
 * Parameter and Return Type Handling
 * ----------------------------------
 * CORBA 2.0 distinguishes between fixed and variable length types and
 * chooses different parameter/return protocols based on this attribute.
 * See Sections 14.8, 14.18, and 14.19 of the CORBA 2.0 spec for details.
 * Here is our summary:
 *
 * Type T            in     out        inout     return     yoSendReq
 * ------------------------------------------------------------------
 * long,short,       T      T*         T*        T          T*
 *  char,octet,
 *  (unsigned),
 *  float,double,
 *  boolean
 * enum              T      T*         T*        T          T*
 * interface         T      T*         T*        T          T*
 * variable length   T*     T**        T*        T*         T*
 *  struct, union;
 *  all seqs, anys
 * fixed length      T*     T*         T*        T          T*
 *  struct, union
 * string            char*  char**     char**    char*      char**
 * fixed length      T      T          T         T_slice*   T
 *   array (alias)
 * variable length   T      T_slice**  T         T_slice*   T
 *   array (alias)
 * TypeCode          yotk*  yotk**     yotk**    yotk*      yotk**      
 *
 * Type-specific Allocators
 * ------------------------
 * Allocation wrapper functions are generated for the following kinds of
 * types: variable length struct and union, any, string, and sequences.
 * Yo provides predefinitions of the allocators for strings, anys, and
 * the builtin sequence types:
 *
 *   CORBA_string_alloc
 *   CORBA_any_alloc
 *   CORBA_T_alloc, where T is the C stub name of the sequence type
 *
 * The compiler generates allocators for the remaining types. For aliases,
 * a #define wrapper around the base type's allocator is generated.
 *
 * Typecodes
 * ---------
 * Depending upon the characteristics of the client/server application,
 * typecodes can cause significant code bloat by requiring the presence
 * of stub files the apps wouldn't otherwise need. To alleviate this
 * problem, there is a compiler option to force generation of static
 * typecode definitions for types declared in #include'd IDL files.
 * 
 * When this option is in effect, no typecode declarations are generated
 * in the public header for included types, and ycclnt.c generates
 * static definitions of typecodes for included types which are used as
 * parameter, return, and exception types by interfaces defined in the
 * current comp unit. The resource controlling this behavior is
 * mnidlc.static-typeocodes. All of this is documented in detail in 
 * /vobs/mx/doc/notes/static_tc.mif.
 *
 * Short Circuit Calls
 * -------------------
 * Short circuiting can be a problem in the face of inheritance. The
 * desired behavior is to dispatch directly through the __tyimpl of
 * the interface whose client stub function we're in. However, if this is
 * an inherited operation, you may be in a stub function with an object
 * of a derived type, in which case the layout of the __tyimpl for that
 * object does not match the stub's expectations. Note that there is no
 * possible way to lay out the __tyimpl's which avoids this problem because
 * the same base interface may be inherited along multiple paths but be
 * represented as only a single flow of control (like C++ virtual base
 * classes).
 *
 * Since this layout problem is a function of the derived interface rather
 * than the base interface for which the stub is generated, the stubs
 * cannot make any assumptions about whether or not adjustments are needed.
 * Instead, a (private) widen function is generated along with the server
 * stubs and retrieved via yoLocalObj. This function will see to it that
 * the correct implementation function is returned. A widen function is
 * not generated unless absolutely necessary; if there is no widener, it
 * is safe for the stub to call directly through the __tyimpl returned
 * by yoLocalObj.
 *
 * HISTORY
 * 12/12/96 kcoleman	Call filters from stubs
 * 11/28/96 kcoleman	Bug #426687: Change handling of output files
 * 11/20/96 kcoleman	Change intf id's to repository id's
 * 08/23/96 kcoleman	Context parameter support
 * 08/23/96 kcoleman	Bug 395093: Add ub4 cast to _widen calls
 * 08/20/96 kcoleman	Bug 393905: Change gen of typecode and id defns
 * 07/18/96 kcoleman	Bug 382537: Rewrite short circuit for inheritance
 * 07/11/96 kcoleman	Allow for C/C++ keywords as IDL identifiers
 * 06/06/96 kcoleman	Bug 369357: Revamp I/O to limit line length
 * 04/08/96 kcoleman	Use ysRecord for error reporting.
 * 03/25/96 kcoleman	Support for static typecode option.
 * 03/18/96 kcoleman	Make modules code gen objects
 * 02/27/96 kcoleman	Fix for bug #336120: Change scope of nested types
 * 02/27/96 kcoleman	Fix for bug #329928: bound anonymous strings typecodes
 * 02/05/96 kcoleman	Support for CORBA 2.0 stubs
 * 01/29/96 kcoleman    Fill in size on yopar for all types.
 * 12/18/95 kcoleman	Size in yopar for bound anon strings was incorrect.
 * 12/04/95 kcoleman	__copy & __free funcs weren't gen'd for exceptions
 * 12/01/95 kcoleman	Change terminator for par descriptor to use yoTcNull
 * 11/28/95 kcoleman	Updated stubs for direct local calls
 * 11/25/95 kcoleman	Moved interface id construction to IFR
 * 11/07/95 kcoleman	Implement distinct Oracle and ANSI naming styles
 * 11/06/95 kcoleman    Add inheritance data to ysid of interfaces
 * 11/06/95 kcoleman	Fix typecode gen bugs, add __copy & __free support
 * 11/02/95 kcoleman	Add CORBA/BOA stub format
 * 10/04/95 kcoleman	Change yccGenFuncHdr to handle async headers
 * 10/03/95 kcoleman	Upgrade env param to the real thing
 * 09/27/95 kcoleman	Interface to yoSendReq now takes an array of ptrs
 *			Remove special casing for -e.
 * 09/25/95 kcoleman	Add env par to yoSendReq
 * 08/07/95 kcoleman	Implementation of client stubs
 * 07/17/95 kcoleman	Creation
 */
#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCC0_ORACLE
#include <ycc0.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif

STATICF void yccGenClientDefn( ycctx* ctx, yccfp* fp, yrobj* obj);
STATICF void yccGenIntfClient( ycctx* ctx, yccfp* fp, yrobj* inf);
STATICF void yccGenOpClient( ycctx* ctx, yccfp* fp, yrobj* op, ub4* idx);
STATICF void yccGenAttrClient( ycctx* ctx, yccfp* fp, yrobj* attr, ub4* idx);
STATICF void yccGenStringTypeCodes( ycctx* ctx, yccfp* fp, yrobj* op);
STATICF void yccGenCGClientObjs( ycctx* ctx, yccfp* fp, yslst* objs);
STATICF void yccGenSyncClient( ycctx* ctx, yccfp* fp, yrobj* intf, 
                               yrobj* rettype, CONST char* opName,
                               CONST char* implName, yslst* pars, 
                               yslst* ctxs, boolean oneway, ub4 idx);
STATICF void yccGenAsyncClient( ycctx* ctx, yccfp* fp, yrobj* intf, 
	                        CONST char* opName, CONST char* implName, 
                                yslst* pars, yslst* ctxs, boolean oneway);
STATICF void yccGenAsyncBody( ycctx* ctx, yccfp* fp, CONST char* opName, 
                              CONST char* implName, yslst* pars, 
                              yslst* ctxs, boolean oneway);


void yccclnt(ycctx* ctx, char* base, ycfile* fd)
{
  yccfp *fp;
  CONST char* errtxt;
  char* upbase;		/* upper case of base */
  CONST char* guardsfx = (ycStyleOra(ctx)  ? "ORACLE" : "IDL");

  /* open temporary output file */
  fp = yccfpOpen( fd->newtmp, "w", SYSFPKIND_NONE, &errtxt, 
                  yccGetLineLimit(ctx));
  if ( !fp )
  {
    ysRecord(YCMSG(1), YCERRSEV, YSLSTR(fd->target), YSLSTR(errtxt), YSLEND);
    return;
  }

  /* produce boilerplate output - header, sys includes, generated include */
  yccfpSetIndent( fp, 0);
  yccfpPrint( fp, "/* GENERATED FILE\n * %s - client stubs\n", base);
  yccfpPrint( fp, " * from %s\n */\n\n", ctx->srcnm);
  yccGenSysIncls(ctx, fp, TRUE);
  upbase = ycToUpper(ysStrDup(base));
  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s_%s\n#include <%s.h>\n#endif\n\n", 
	      upbase, guardsfx, base);
  yccfpEndPP( fp);
  ysmGlbFree( (dvoid*)upbase);
  yccfpPrint( fp, "EXTC_START\n\n");

    /* Generate stub functions, ysid's, and remaining type codes */
  yccGenCGClientObjs( ctx, fp, ctx->newobjs);

  yccfpPrint( fp, "\nEXTC_END\n");
  yccfpClose(fp);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenCGClientObjs - Generate client stub decls for code gen objects
 *
 * Lots of hoop jumping to deal with modules and interface forward decls...
 * see ycsem.c, ycsAddObj. Never use the source file name as a means of
 * deciding whether or not to generate code for a module: The source file
 * name of the module in the IFR is always the first occurrence of the
 * module, so it may appear to be from include file, but we may be gen'ing
 * code for a piece of the module in the current source file. So, always
 * recurse on modules, thereby checking the source file name at the content
 * level. It sucks, but there's not a thing you can do about it.
 */

STATICF void yccGenCGClientObjs( ycctx* ctx, yccfp* fp, yslst* objs)
{
  ysle* le;

  if ( objs )
  {
    for ( le = ysLstHead(objs); le; le = ysLstNext(le))
    {
      ycgobj* cgobj = (ycgobj*) ysLstVal(le);

      if ( yrGetKind( cgobj->ifrobj) == yrdkModule )
        yccGenCGClientObjs( ctx, fp, cgobj->objlist);
      else if ( !ycShouldGenCode(ctx, cgobj->ifrobj) )
        continue;	/* from an include file. Don't gen code */
      else if ( !(cgobj->flags & YCG_FWD) )	/* do nothing for forwards */
	yccGenClientDefn( ctx, fp, cgobj->ifrobj);
    }
  }
}

/* ---------------------------------------------------------------------- */
/*
 * yccGenTypeCodeDefn - generate a defining decl for a type code
 *
 * externdef YCTC_<name>[] = "<typecode>";
 *
 * The actual type code stringification is handled by yotkToStr. Type
 * codes are not needed for primitive types or builtin sequence types.
 *
 * <External> will be true in most cases, but can be FALSE under certai
 * circumstances if mnidlc.static-typecodes is in effect.
 */

void yccGenTypeCodeDefn( ycctx* ctx, yccfp* fp, yrobj* obj, boolean external)
{
  CONST char* name;
  CONST char* tcpfx;

  switch ( yrGetKind(obj) )
  {
    case yrdkSequence:		/* some are predef'd, others not */
      if ( (ctx->lang->flags & YCCFLG_BUILTIN_SEQ) && 
          (yrGetKind(yrSeqData(obj).elmtype) == yrdkPrimitive) )
	return;
      break;
    case yrdkPrimitive:		/* predefined, do nothing */
      return;
    case yrdkInterface:
      if ( ycIsCorbaObject( ctx, obj) ) 
        return;                 /* predefined, do nothing */
      break;
    case yrdkException:
    case yrdkStruct:
    case yrdkUnion:
    case yrdkEnum:
    case yrdkArray:
    case yrdkString:
    case yrdkAlias:
      break;
    default:
      yseThrow(YS_EX_FAILURE);
      break;
  }

  tcpfx = yccTCPrefix(ctx);
  if ( yrGetKind(obj) == yrdkString )
  {
    ub4 bnd = yrStringData(obj).bound;

    yccfpPrint( fp, "#ifndef %s_string_%d_DEFINED\n", tcpfx, bnd);
    yccfpPrint( fp, "#define %s_string_%d_DEFINED\n", tcpfx, bnd);
    yccfpPrint( fp, "static yotk %s_string_%d[] =\n", tcpfx, bnd);
    yccfpIncIndent( fp);
    yccFormatTypeCodeDefn( ctx, fp, yrGetTypeCode( obj));
    yccfpDecIndent( fp);
    yccfpPrint( fp, "#endif\n");
  }
  else
  {
    name = yccGetAbsoluteName( ctx, obj, (yrobj*)0);
    if ( !external )
    {
      yccfpStartPP( fp);
      yccfpPrint( fp, "#ifndef %s_%s_DEFINED\n", tcpfx, name);
      yccfpPrint( fp, "#define %s_%s_DEFINED\n", tcpfx, name);
      yccfpEndPP( fp);
    }
    yccGenTypeCode( ctx, fp, name, yrGetTypeCode( obj), external);
    if ( !external )
    {
      yccfpStartPP( fp);
      yccfpPrint( fp, "#endif /* %s_%s_DEFINED */\n\n", tcpfx, name);
      yccfpEndPP( fp);
    }
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenClientDefn - generate a client stub definition for an IFR object
 *
 */
STATICF void yccGenClientDefn( ycctx* ctx, yccfp* fp, yrobj* obj)
{
  ysle* le;

  switch ( yrGetKind(obj) )
  {
    case yrdkInterface:		/* lots of stuff */
      yccGenIntfClient( ctx, fp, obj);
      break;
    case yrdkException:		/* typecode and ysid */
      yccGenExcClient( ctx, fp, obj);
      break;
    case yrdkStruct:		/* support funcs & typecode only */
    case yrdkUnion:		/* support funcs & typecode only */
      if ( yrGetContents( obj) )
      {
        for ( le = ysLstHead( yrGetContents(obj)); le; le = ysLstNext(le))
        {
          yccGenClientDefn( ctx, fp, (yrobj*) ysLstVal(le));
        }
      }
      yccGenTypeCodeDefn( ctx, fp, obj, TRUE);
      yccGenSupportFuncs( ctx, fp, obj, TRUE);
      break;
    case yrdkAlias:		/* support funcs & typecode only */
    case yrdkEnum:		/* support funcs & typecode only */
      yccGenTypeCodeDefn( ctx, fp, obj, TRUE);
      yccGenSupportFuncs( ctx, fp, obj, TRUE);
      break;
    default:			/* do nothing */
      break;
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenInterfaceDefn - generate definition code for an interface
 *
 * For each interface, we generate:
 *  ysid definition for interface name
 *  type code definition for interface name
 *  client stub functions for all operations and attributes
 *  yopar parameter descriptors for all operations and attributes
 *
 * Nothing is generated for op, attrs, types, etc. which are inherited.
 *
 * The ysid for an interface includes a list of all the interfaces from
 * which it inherits, directly or indirectly. This data is used by
 * yoNarrow to figure out whether or not the narrow op is allowed. The
 * format of the ysids is:
 *
 *   inf {/base1/base2.../baseN}
 *
 * Where each interface name is the IDL scoped name (::A::B) and each
 * ancestor name is separated by '/'. The slashes are arbitrary - any
 * char not allowed in a scoped name will do - but if you change it,
 * yoNarrow has to change as well.
 */

STATICF void yccGenIntfClient( ycctx* ctx, yccfp* fp, yrobj* inf)
{
  CONST char* name;
  char* sname;
  ysle* le;

  if ( ycIsCorbaObject( ctx, inf) )   /* CORBA::Object is a magic cookie */
    return;

  name = yccGetAbsoluteName( ctx, inf, (yrobj*)0);
  sname = yrGetAbsoluteName( inf);
  yccfpPrint( fp, "/* Client stubs for interface %s */\n", sname);

    /***** Generate ysid & typecode definition *****/
  yccGenId( ctx, fp, name, name, TRUE, yrGetRepId(inf));
  yccGenTypeCodeDefn( ctx, fp, inf, TRUE);
  yccfpPrint( fp, "\n");
  ysmGlbFree( (dvoid*)sname);

    /***** Gen supporting and member definitions *****/
  yccGenSupportFuncs( ctx, fp, inf, TRUE);
  
  if ( yrGetContents(inf) )
  {
    ycsym* syminfo = ycSymLookup( ctx->symtbl, inf);
    yslst* all = (syminfo ? syminfo->opsNattrs : (yslst*)0);
    yrobj* obj;

    for (le = ysLstHead(yrGetContents(inf)); le; le = ysLstNext(le))
    {
      obj = (yrobj*) ysLstVal(le);
      if ( (yrGetDefinedIn(obj) != inf) ||
           (yrGetKind(obj) == yrdkOperation) ||
           (yrGetKind(obj) == yrdkAttribute) )
        continue;	/* no code for inherited members, handle ops below */
      else
        yccGenClientDefn( ctx, fp, obj);  /* to get type code defns, etc. */
    }
    yccfpPrint( fp, "\n");

    if ( !ycIsEmptyLst(all) )
    {
      ub4 opidx = 0;
      for (le = ysLstHead(all); le; le = ysLstNext(le))
      {
        obj = (yrobj*) ysLstVal(le);
        if ( yrGetDefinedIn(obj) != inf )
          continue;	/* gen no code for inherited members */
        if ( yrGetKind(obj) == yrdkOperation )
	  yccGenOpClient( ctx, fp, obj, &opidx);
        else 
	  yccGenAttrClient( ctx, fp, obj, &opidx);
      }
      yccfpPrint( fp, "\n");
    }
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenExcClient - generate client stub code for an exception
 *
 * Each exception gets a ysid definition and, if it has data associated
 * with it, a type code. If there are data members, __copy and __free
 * operations are also generated.
 */

void yccGenExcClient( ycctx* ctx, yccfp* fp, yrobj* ex)
{
  CONST char* name = (char*)0;
  CONST char* exName = (char*)0;
  char* sname = yrGetAbsoluteName( ex);
  sword saveStyle = ctx->style;

  name = yccGetAbsoluteName(ctx, ex, (yrobj*)0);
  ctx->style |= YCSTYLE_EXC;
  exName = yccGetAbsoluteName(ctx, ex, (yrobj*)0);
  ctx->style = saveStyle;

  yccGenId( ctx, fp, exName, name, FALSE, yrGetRepId(ex));
  ysmGlbFree((dvoid*)sname);
  ysmGlbFree((dvoid*)exName);

  yccGenTypeCodeDefn( ctx, fp, ex, TRUE);
  if ( yrStructData(ex).mbrs )
    yccGenSupportFuncs( ctx, fp, ex, TRUE);
  if ( yrGetContents( ex) )
  {
    ysle* le;

    for ( le = ysLstHead( yrGetContents(ex)); le; le = ysLstNext(le))
    {
      yccGenClientDefn( ctx, fp, (yrobj*) ysLstVal(le));
    }
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenSyncClient - gen client stub for synchronous op/attribute
 *
 * See comment at the top of the file for documentation on what the
 * stubs look like for the various object adaptors. The COA and BOA
 * stubs differ just enough to make much code sharing impractical. 
 * However, they have MUCH in common, so be sure to update both flavors
 * when making changes.
 *
 * Parameters (largely determined by yccGenFuncHdr requirements):
 *   intf       interface defining this op
 *   rettype    return type
 *   opName     op name as it appears as the stub function name
 *   implName   "simple" op name as needed by yoSendReq
 *   pars       yslst of yrpar's - parameter list
 *   idx        position of this op in _tyimpl if treated as an array
 */
STATICF void yccGenSyncClient( ycctx* ctx, yccfp* fp, yrobj* intf, 
                               yrobj* rettype, CONST char* opName,                                            CONST char* implName, yslst* pars, 
                               yslst* ctxs, boolean oneway, ub4 idx)
{
  ysle* le;
  boolean isVoidReturn = (yrGetKind(rettype) == yrdkPrimitive) &&
				(yrPrimData(rettype).kind == yrpkvoid);
  boolean useOraNames = ctx->style & YCSTYLE_ORA ? TRUE : FALSE;
  CONST char* intfName = yccGetAbsoluteName( ctx, intf, (yrobj*)0);
  CONST char* kwdpfx = ((*ctx->lang->kwdchk)( ctx, implName) ? "_" : "");
  boolean vers1_2 = ycCORBA1_2(ctx);

  yccGenFuncHdr( ctx, fp, rettype, intf, opName, pars, 
                 ctxs, FALSE, yccfnk_normal);
  yccfpPrint( fp, "\n{\n");
  yccfpIncIndent( fp);

  if ( !isVoidReturn )                     /* declare return value */
  {
    yccGenParamType( ctx, fp, rettype, YOMODE_RETURN);
    yccfpPrint( fp, " _result;\n");
  }

    /***** Declare the standard local vars *****/
  yccfpPrint( fp,"ysevt* %s _sem = (ysevt*)0;\n", YCCVOLATILE(ctx));
  yccfpPrint( fp,"struct %s__tyimpl* _impl;\n", intfName);
  yccfpPrint( fp, "yowiden _widen = (yowiden)0;\n\n");
  if ( useOraNames )
    yccfpPrint( fp, "NOREG(_sem);\n");

    /***** Generate the main body of the stub code *****/
  if ( ctx->objAdaptor == YCOA_BOA )             /* BOA stubs */
  {
    yccfpPrint( fp, "if ( ev->_major != CORBA_NO_EXCEPTION )\n");
    yccfpIncIndent( fp);
    if ( isVoidReturn )
      yccfpPrint( fp, "return;\n");
    else
      yccfpPrint( fp, "return _result;\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "\nyseTry\n{\n");
    yccfpIncIndent( fp);
  }

    /***** See if this is a short circuit call *****/
  yccfpPrint( fp, "_impl = (struct %s__tyimpl*) yoLocalObj( ", intfName);
  yccfpPrint( fp, "(dvoid*)or, (yowiden*)&_widen);\nif ( _impl )\n{\n");
  yccfpIncIndent( fp);

    /***** Yes, do we need to widen to get right function? *****/
  yccfpPrint( fp, "if ( _widen )\n{\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "yogfp _f = (*_widen)( (ub4)%u, (%s*)_impl, %s__id);\n",
              idx, YCCVOID(ctx), intfName);
  yccfpPrint( fp, "%s(*(", isVoidReturn ? "" : "_result = ");
  yccGenFuncHdr( ctx, fp, rettype, intf, "", pars, ctxs, TRUE, yccfnk_normal);
  yccfpPrint( fp, ")_f)(or%s", (vers1_2 ? ", ev" : ""));
  if ( pars )
  {
    for ( le = ysLstHead(pars); le; le = ysLstNext(le))
    {
      yccfpPrint( fp, ", ");
      yccGenSimpleName( ctx, fp, ((yrpar*)ysLstVal(le))->name);
    }
  }
  if ( !vers1_2 )
    yccfpPrint( fp, "%s, ev", ycIsEmptyLst(ctxs) ? "" : ", corbctx_");
  yccfpPrint( fp, ");\n");
  yccfpDecIndent( fp);

    /***** Don't need to widen, call directly thru _impl *****/
  yccfpPrint( fp, "}\nelse\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "%s(*_impl->%s%s)(or%s",
              isVoidReturn ? "" : "_result = ", kwdpfx, implName,
              (vers1_2 ? ", ev" : ""));

  if ( pars )
  {
    for ( le = ysLstHead(pars); le; le = ysLstNext(le))
    {
      yccfpPrint( fp, ", ");
      yccGenSimpleName( ctx, fp, ((yrpar*)ysLstVal(le))->name);
    }
  }
  if ( !vers1_2 )
    yccfpPrint( fp, "%s, ev", ycIsEmptyLst(ctxs) ? "" : ", corbctx_");
  yccfpPrint( fp, ");\n");
  yccfpDecIndent( fp);
  yccfpDecIndent( fp);

    /***** No, not short circuit, make remote call *****/

  yccfpPrint( fp, "}\nelse\n{\n");
  yccfpIncIndent( fp);

  yccfpPrint( fp, "%s((%s*)or, ev, YOFLTR_CSND, ",
              (ctx->objAdaptor == YCOA_COA) ? "yoFilterRunEx" 
                                            : "ORA_CORBA_FilterRun",
              YCCVOID(ctx));
  yccfpPrint( fp, "(%s char*)0, (%s*)0);\n", YCCCONST(ctx), YCCVOID(ctx));
  if ( ctx->objAdaptor == YCOA_BOA )               /* BOA stubs */
  {
    yccfpPrint( fp, "if ( ev->_major == CORBA_NO_EXCEPTION )\n{\n");
    yccfpIncIndent(fp);
  }
  yccfpPrint( fp, "yseTry\n{\n");
  yccfpIncIndent(fp);

     /***** Semaphore creation, call to _nw stub *****/
  yccfpPrint( fp, "_sem = ysSemCreate((%s*)0);\n", YCCVOID(ctx));
  if ( yccGenAsync(ctx) )
  {
    yccfpPrint( fp, "%s_nw( or%s", opName, vers1_2 ? ", ev" : "");
    if ( pars )
    {
      for ( le = ysLstHead(pars); le; le = ysLstNext(le))
      {
        yccfpPrint( fp, ", ");
        yccGenSimpleName( ctx, fp, ((yrpar*)ysLstVal(le))->name);
      }
    }
    if ( !vers1_2 )
      yccfpPrint( fp, "%s, ev", ycIsEmptyLst(ctxs) ? "" : ", corbctx_");
    yccfpPrint( fp, ", (ysevt*)_sem);\n");
  }
  else
  {
    yccGenAsyncBody( ctx, fp, opName, implName, pars, ctxs, oneway);
  }

    /***** Call completion and exception handling *****/
  if ( ctx->objAdaptor == YCOA_BOA )             /* BOA stubs */
  {
    yccfpPrint( fp, "ORA_CORBA_SemSynch(");
    yccfpPrint( fp, " ev, (ysevt*)_sem, %s_pars, ", opName);
    if ( isVoidReturn )
      yccfpPrint( fp, "(%s*)0, 0);\n", YCCVOID(ctx));
    else
      yccfpPrint( fp, "(%s*)&_result, sizeof(_result));\n", YCCVOID(ctx));
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\nyseFinally\n{\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "ORA_CORBA_FilterRunEx((%s*)or, ev, YOFLTR_CRCV, ",
                YCCVOID(ctx));
    yccfpPrint( fp, "CORBA_exception_id(ev), CORBA_exception_value(ev));\n");
    yccfpPrint( fp, "if ( _sem )\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "ysSemDestroy( (ysevt*)_sem);\n");
    yccfpDecIndent( fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\nyseEnd\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n");                     /* if no exception */
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n");                     /* else (not short circuit) */
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\nyseCatchAll\n{\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "if ( _sem )\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "ysSemDestroy( (ysevt*)_sem);\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "ev->_major = CORBA_SYSTEM_EXCEPTION;\n");
    yccfpPrint( fp, "ev->id = (char*) yseExid;\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\nyseEnd\n");
  }                                              /* end BOA stub */

  else                                           /* COA stub */
  {
    yccfpDecIndent( fp);
    yccfpPrint( fp,"}\nyseCatchAll\n{\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "%sysid* _exid;\n%s* _exbody;\n\n", 
                YCCCONST(ctx), YCCVOID(ctx));
    yccfpPrint( fp, "_exid = yseExid;\n_exbody = yseExobj;\nyseTry\n{\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "yoFilterRunEx((%s*)or, ev, YOFLTR_CRCV, ", YCCVOID(ctx));
    yccfpPrint( fp, "_exid, _exbody);\n");
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\nyseFinally\n{\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "if ( _sem )\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "ysSemDestroy( (ysevt*)_sem);\n");
    yccfpDecIndent( fp);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\nyseEnd\nyseRethrow;\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\nyseEnd\n");
    yccfpPrint( fp, "yseTry\n{\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "ysSemSynch( (ysevt*)_sem, ");
    if ( isVoidReturn )
      yccfpPrint( fp, "(%s*)0);\n", YCCVOID(ctx));
    else
      yccfpPrint( fp, "(%s*)&_result);\n", YCCVOID(ctx));
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\nyseFinally\n");
    yccfpIncIndent(fp);
    yccfpPrint( fp, "yoFilterRunEx((%s*)or, ev, YOFLTR_CRCV, ", YCCVOID(ctx));
    yccfpPrint( fp, "yseExid, yseExobj);\n");
    yccfpDecIndent(fp);
    yccfpPrint( fp, "yseEnd\n");
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n");
  }                                              /* end COA stub */

  if ( !isVoidReturn )
    yccfpPrint( fp, "return _result;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenAsyncClient - generate async client op/attr stub
 *
 * Parameters (largely determined by yccGenFuncHdr requirements):
 *   intf       interface defining this op
 *   opName     op name, excluding "_nw" suffix 
 *   implName   "simple" op name as needed by yoSendReq
 *   pars       yslst of yrpar's - parameter list
 *   oneway     TRUE if op is oneway
 *
 * void <op>_nw( <intf> or, <pars>, ysevt* _sem)
 * {
 *   ... see yccGenAsyncBody...
 * }
 *
 */

STATICF void yccGenAsyncClient( ycctx* ctx, yccfp* fp, yrobj* intf, 
                                CONST char* opName, CONST char* implName, 
                                yslst* pars, yslst* ctxs, boolean oneway)
{
  if ( yccGenAsync(ctx) )
  {
    yccGenFuncHdr( ctx, fp, (dvoid*)0, intf, opName, pars, 
                   ctxs, FALSE, yccfnk_nw);
    yccfpPrint( fp, "\n");
    yccGenAsyncBody(ctx, fp, opName, implName, pars, ctxs, oneway);
    yccfpPrint( fp, "\n");
  }
}

/* ---------------------------------------------------------------------- */
/*
 * yccGenAsyncBody - generate async client op/attr send request
 *
 * Parameters (largely determined by yccGenFuncHdr requirements):
 *   opName     op name, excluding "_nw" suffix 
 *   implName   "simple" op name as needed by yoSendReq
 *   pars       yslst of yrpar's - parameter list
 *   oneway     TRUE if op is oneway
 *
 * Generates:
 * {
 *   yoSendReq( (dvoid*)or, "<implName>", !<oneway>, _sem, <par-count>,
 *		<op>_pars, <pars>);
 * }
 *
 * Parameters are always passed into yoSendReq by reference. We build an
 * array of pointers to the parameters on the stack and pass that in.
 * If the function has no parameters, NULL is passed in.
 *
 * Body is generated separately from function header because this code
 * is used both in the async stub functions (as the entire func body)
 * and in the sync stubs when no async's are generated (as an embedded
 * block of code).
 */

STATICF void yccGenAsyncBody( ycctx* ctx, yccfp* fp, CONST char* opName, 
                              CONST char* implName, yslst* pars, 
                              yslst* ctxs, boolean oneway)
{
  sword npar;
  ysle* le;
  sword i = 0;

  yccfpPrint( fp, "{\n");
  yccfpIncIndent( fp);

    /* create vector of param addresses for yoSendReq */
  npar = pars ? ysLstCount(pars) : 0;
  if ( !ycIsEmptyLst(ctxs) && !ycCORBA1_2( ctx) )
    npar++;
  if ( npar )
    yccfpPrint( fp, "%s* _parvec[%d];\n\n", YCCVOID(ctx), npar);

  if ( !ycIsEmptyLst(pars) )
  {
    for ( le = ysLstHead(pars); le; i++, le = ysLstNext(le))
    {
      yrpar* par = (yrpar*) ysLstVal(le);
      yccfpPrint( fp, "_parvec[%d] = (%s*)%c", i, YCCVOID(ctx),
	          yccTakeAddrOf( ctx, par->type, par->mode) ? '&' : ' ');
      yccGenSimpleName( ctx, fp, par->name);
      yccfpPrint( fp, ";\n");
    }
  }

  if ( !ycIsEmptyLst(ctxs) && !ycCORBA1_2( ctx) )
  {
    yccfpPrint( fp, "_parvec[%d] = (%s*)corbctx_;\n", i, YCCVOID(ctx));
    i++;
  }

  yccfpPrint( fp, "%sSendReq( (%s*)or, ev, \"%s\", %s, _sem, ",
              (ctx->objAdaptor == YCOA_COA) ? "yo" : "ORA_CORBA_",
              YCCVOID(ctx), implName, oneway ? "FALSE" : "TRUE");
  yccfpPrint( fp, "(sword)%d, %s_pars, ", npar, opName);
  if ( npar )
    yccfpPrint( fp, "_parvec);\n");
  else
    yccfpPrint( fp, "(%s**)0);\n", YCCVOID(ctx));

  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n");
}



/* ---------------------------------------------------------------------- */
/*
 * yccGenOpClient - generate client stubs for an interface operation
 *
 * Generates <op> and <op>_nw - sync and async stubs.
 *
 * <idx> is the position of the generated function in the __tyimpl struct
 * if the struct is treated as an array of generic function pointers.
 * Increment it once for each function that is generated here.
 */

STATICF void yccGenOpClient( ycctx* ctx, yccfp* fp, yrobj* op, ub4* idx)
{
  CONST char* name = yccGetAbsoluteName( ctx, op, (yrobj*)0);
  yrop* opdata = &(yrOpData(op));
  yrobj* defn = yrGetDefinedIn(op);

  yccGenStringTypeCodes( ctx, fp, op);
  yccGenParamDesc( ctx, fp, name, opdata->pars, opdata->raises, 
                   opdata->rettype, opdata->ctxts);
  yccGenSyncClient( ctx, fp, defn, opdata->rettype,
                    name, yrGetName(op), opdata->pars, opdata->ctxts,
                    opdata->mode == YR_OP_ONEWAY, *idx);
  yccGenAsyncClient( ctx, fp, defn, name, yrGetName(op),
                    opdata->pars, opdata->ctxts, 
                    opdata->mode == YR_OP_ONEWAY);
  (*idx)++;
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenAttrClient - generate client stubs for an attribute
 *
 * Generates <intf>__get_<attr> and <intf>__set_<attr> in synchronous
 * and asynchronous forms - 4 functions in all.
 *
 * <idx> is the position of the generated function in the __tyimpl struct
 * if the struct is treated as an array of generic function pointers.
 * Increment it once for each function that is generated here.
 */

STATICF void yccGenAttrClient( ycctx* ctx, yccfp* fp, yrobj* attr, ub4* idx)
{
  CONST char* base = yccGetAbsoluteName( ctx, yrGetDefinedIn(attr), (yrobj*)0);
  char* attrName = yrGetName(attr);
  yrattr* attrdata = &(yrAttrData(attr));
  yrobj* defined_in = yrGetDefinedIn(attr);
  char* name = 
	(char*) ysmGlbAlloc( strlen(base) + strlen(attrName) + 7, "attrName");
		/* "__get_" + 1 == 7 */

  yccGenStringTypeCodes( ctx, fp, attr);

    /* get stub */
  DISCARD ysFmtStr( name, "%s__get_%s", base, attrName);
  yccGenParamDesc( ctx, fp, name, (yslst*)0, (yslst*)0, 
                   attrdata->type, (yslst*)0);
  yccGenSyncClient( ctx, fp, defined_in, attrdata->type,
                    name, name + strlen(base) + 1, (yslst*)0, (yslst*)0, 
                    FALSE, *idx);
  yccGenAsyncClient( ctx, fp, defined_in, name,  name + strlen(base) + 1,
                     (yslst*)0, (yslst*)0, FALSE);
  (*idx)++;

    /* set stub */
  if ( attrdata->mode != YR_ATTR_RO )
  {
    yslst* pars = ysLstCreate();
    yrpar param;

    DISCARD ysFmtStr( name, "%s__set_%s", base, attrName);
    param.name = "val";
    param.type = attrdata->type;
    param.mode = YOMODE_IN;
    DISCARD ysLstEnq( pars, (dvoid*) &param);

    yccGenSyncClient( ctx, fp, defined_in, 
			yrGetPrimitive( yrGetRepository(attr), yrpkvoid),
			name, name + strlen(base) + 1, pars, (yslst*)0, 
                        FALSE, *idx);
    yccGenParamDesc( ctx, fp, name, pars, (yslst*)0, (yrobj*)0, (yslst*)0);
    yccGenAsyncClient( ctx, fp, defined_in, name, name + strlen(base) + 1, 
                       pars, (yslst*)0, FALSE);

    ysLstDestroy( pars, (ysmff)0);
    (*idx)++;
  }

  ysmGlbFree( (dvoid*)name);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenStrAsChar - print an alpha numeric string as a list of char literals
 *
 * Talk about a special purpose function...This is just to print scoped
 * names out as character literals rather than strings when formatting
 * interface ysid's. Because the scoped names can be fairly long and the
 * inheritance walk arbitrarily long, we can't stuff it all in a string
 * literal without offending Olint and less-than-robust C compilers.
 *
 * Given "abc", you get out:
 *
 *   'a','b','c',\n
 *
 * To make life simpler for yccfpPrint, we buffer output by a reasonable
 * line length, but yccfpPrint is in charge of indentation and inserting 
 * the newlines.
 *
 * Note that there's always a trailing comma and that this doesn't deal 
 * with non-printing characters at all. Nothing general purpose about 
 * this nasty thing.
 */
void yccGenStrAsChar( ycctx* ctx, yccfp* fp, CONST char* str)
{
  char buff[69];            /* Multiple of 4, + 1. Fit it on 1 line */
  CONST char* p;
  sword i;

  for ( i = 0, p = str; *p; p++ )
  {
    buff[i++] = '\'';
    buff[i++] = *p;
    buff[i++] = '\'';
    buff[i++] = ',';
    if ( i == 68 )
    {
      buff[i] = '\0';
      yccfpPrint( fp, "%s", buff);
      i = 0;
    }
  }
  if ( i )       /* spill remnants of the buffer, if any */
  {
    buff[i] = '\0';
    yccfpPrint( fp, "%s", buff);
  }
}

/* ---------------------------------------------------------------------- */
/*
 * yccGenStringTypeCodes - Gen type codes for bound anonymous strings
 *
 * Bound anonymous strings are a real pain in the #$*. They are the only
 * anonymous type which can appear in isolation (as parameter, return,
 * or attribute types). The other anonymous types (sequences and arrays)
 * can only appear as part of a typedef or inside a struct or union.
 *
 *    interface biteme
 *    {
 *      attribute string<2> bleah;
 *      string<3> ugh( in string<4> par);
 *    };
 *
 * Why do you care? Because a bound string has a typecode distinct from an
 * unbound string and you must have said typecode to put in the parameter
 * descriptor block (_pars array) for the associated operation. This is
 * the only place it is used; we do not make it available to the user to
 * manipulate - if he wants to do that, he must make it a named type.
 *
 * So, for bound anonymous strings appearing as return, parameter, or
 * attribute types, we generate a static typecode in the client stubs.
 * The naming convention for these typecodes is dictated by CORBA to be:
 *
 *   TC_string_N
 *
 * where <N> is the bound.
 */

STATICF void yccGenStringTypeCodes( ycctx* ctx, yccfp* fp, yrobj* op)
{
  yrobj* strtype;

  if ( yrGetKind(op) == yrdkAttribute )
  {
    strtype = yrAttrData(op).type;
    if ( yrGetKind(strtype) == yrdkString )
      yccGenTypeCodeDefn( ctx, fp, strtype, FALSE);
  }
  else   /* operation */
  {
    yslst* pars = yrOpData(op).pars;

    strtype = yrOpData(op).rettype;
    if ( yrGetKind(strtype) == yrdkString )
      yccGenTypeCodeDefn( ctx, fp, strtype, FALSE);

    if ( pars )
    {
      ysle* le;

      for ( le = ysLstHead(pars); le; le = ysLstNext(le))
      {
        yrpar* par = (yrpar*) ysLstVal(le);

        if ( yrGetKind(par->type) == yrdkString )
          yccGenTypeCodeDefn( ctx, fp, par->type, FALSE);
      } /* for */
    } /* if pars */
  }
}


/* ---------------------------------------------------------------------- */
/* 
 * yccFormatTypeCodeDefn - dandify typecode aggregate initializer
 *
 * Type codes are HUGE, so we split them up when printing them out.
 * This function spills a line of type blather roughly every 60 chars.
 * Specifically, at the first char literal close after 60 chars.
 * So we don't shoot ourselves in the foot by trying to break a line
 * in the middle of a constant, we parse out char literals and hex
 * constants as a block.
 */

void yccFormatTypeCodeDefn( ycctx* ctx, yccfp* fp, CONST yotk* tc)
{
  char* tcStr;      /* beginning of the whole type code */
  char* p;          /* current character of interest */
  char* start;      /* beginning of current line */
  sword i = 0;      /* num chars in current line */

  tcStr = yotkToStr(tc);
  p = tcStr;
  start = tcStr;

  while ( *p )
  {
    if ( *p == '\'' )                /* start of a char literal */
    {
      p++, i++;                      /* skip opening quote */
      if ( (*p == '\\') && (*(p+1) == '\'') )
      {
	p += 2;
	i += 2;
      }
      while ( *p != '\'' )
	p++, i++;
      p++, i++;                      /* skip closing quote */
    }                                /* at 1st char after char literal */
    else if ( *p == '0' && ((*(p+1) == 'x') || (*(p+1) == 'X')) )
    {                                /* start of a hex literal */
      p += 2;                        /* skip the "0x" */
      i += 2;
      while ( *p && isxdigit(*p) )
	p++, i++;
    }                                /* 1st char after end of hex literal */
    else
      p++, i++;

    if ( i >= 60 )                   /* spill a line */
    {
      char c = *p;                   /* so we can stomp with a null */

      *p = '\0';
      yccfpPrint( fp, "%s\n", start);
      *p = c;                        /* restore char we stomped */
      start = p;
      i = 0;
    }
  }
  if ( *start )                      /* dump last line */
    yccfpPrint( fp, "%s", start);
  yccfpPrint( fp, ";\n\n");
  ysmGlbFree( (dvoid*)tcStr);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenParamDesc - generate parameter descriptor for an op or attr
 *
 * This cannot be global data - see /vobs/mx/doc/notes/ycexport.txt.
 * We generate a function that will construct an appropriate descriptor
 * the first time it is called, stash it in the object runtime layer,
 * and thereafter return this same object.
 *
 * For some operation "op" with N parameters, we generate:
 *
 * yopar* op__getPars()
 * {
 *   yopar* _pars = yoParsGet( "op");
 *   if ( _pars == (yopar*)0 )
 *   {
 *     yopard* _desc = yoPardCreate( "op", N);
 *     _pars = _desc->pars;
 *     _pars[0].mode = ...;
 *     _pars[0].tk = ...;
 *     ... etc. for return, params, and exceptions
 *     _pars[N].mode = YOMODE_INVALID;
 *     _pars[N].tk = (yotk*)yoTcNull;
 *     _pars[N].sz = (ub4)0;
 *     yoParsSize( _pars);
 *     yoParsSet( _desc);
 *   }
 *   return _pars;
 * }
 *
 * The parameter descriptor is an array of yopar's, "null" terminated.
 * This descriptor block is wrapped in a yopard along with the op name
 * so that it can be stored by the object runtime layer. See yoParsSet.
 *
 * Note: Don't use a null pointer for the terminating typecode - a null 
 * pointer is not meaningful for typecodes and if it ever gets passed into 
 * any of the yotk operations, they'll choke. The Object runtime layer keys
 * off the mode field anyway, so it doesn't matter much.
 *
 * Bit of a hack here for anonymous bound strings. See yccGenStringTypeCodes.
 * Wrt static typecode generation, need do nothing for bound anonymous
 * strings because they always get static typecodes.
 *
 * If the static typecode option is in effect, we must generate static
 * typecodes for any types used in the param descriptor but not defined
 * in this compilation unit. Types defined in this compilation unit are
 * assumed to already have externally visible decls/defns.
 *
 * Version differences: CORBA 1.2/OMN3.x stubs do not have context or
 * var/fixed type info on them. Though context id's are part of CORBA 1.2,
 * they were not part of OMN 3.x; the feature is not backward compatible.
 * Starting with CORBA 2.0/OMN 4.0, param descriptors get entries for
 * context ids and each yopar has an additional field indicating whether
 * the param/return type is fixed or variable length.
 */

void yccGenParamDesc( ycctx* ctx, yccfp* fp, CONST char* name, yslst* pars,
		      yslst* raises, yrobj* rettype, yslst* ctxs) 
{
  ub4 tot = 0;
  ub4 i = 0;      /* pars index */
  ysle* le;
  boolean isVoidReturn = !rettype || 
                         ((yrGetKind(rettype) == yrdkPrimitive) && 
                          (yrPrimData(rettype).kind == yrpkvoid));
  boolean v12 = ycCORBA1_2(ctx);
  CONST char* tc = yccGetPrimitiveName( ctx, yrpkTypeCode);

    /***** check for static type codes we may need to generate *****/
    /*   special case handling is needed for bound anonymous strings */
    /*   (which get static tc's anyway) and CORBA::Object. */
  if ( ctx->lang->flags & YCCFLG_STATIC_TC )
  {
    if ( !isVoidReturn && !ycShouldGenCode(ctx, rettype) && 
         (yrGetKind(rettype) != yrdkString) )
    {
      yccGenTypeCodeDefn( ctx, fp, rettype, FALSE);
    }
    if ( pars )
    {
      for ( le = ysLstHead(pars); le; le = ysLstNext(le) )
      {
        yrpar* par = (yrpar*) ysLstVal(le);
        if ( !ycShouldGenCode(ctx, par->type) && 
             (yrGetKind(par->type) != yrdkString) )
          yccGenTypeCodeDefn( ctx, fp, par->type, FALSE);
      }
    }
    if ( raises )
    {
      for ( le = ysLstHead(raises); le; le = ysLstNext(le) )
      {
        yrobj* ex = (yrobj*) ysLstVal(le);
        if ( !ycShouldGenCode(ctx, ex) )
          yccGenTypeCodeDefn( ctx, fp, ex, FALSE);
      }
    }
  }

    /***** calculate how many entries in pars desc *****/
  if ( !isVoidReturn )
    tot++;
  if ( pars )
    tot += ysLstCount( pars);
  if ( raises )
    tot += ysLstCount( raises);
  if ( ctxs && !v12 )
    tot += ysLstCount( ctxs);

    /***** Gen function definition *****/
  yccfpPrint( fp, "yopar* %s__getPars(void)\n{\n", name);
  yccfpIncIndent( fp);
  yccfpPrint( fp, "yopar* _pars = (yopar*)0;\n\n");
  yccfpPrint( fp, "_pars = yoParsGet( \"%s\");\n", name);
  yccfpPrint( fp, "if ( _pars == (yopar*)0 )\n{\n");
  yccfpIncIndent( fp);
  yccfpPrint( fp, "yopard* _desc = yoPardCreate( \"%s\", (ub4)%u);\n", 
              name, tot);
  yccfpPrint( fp, "_pars = _desc->pars;\n");

  if ( !isVoidReturn )                          /* return type */
  {
    i = 1;
    yccfpPrint( fp, "_pars[0].mode = YOMODE_RETURN;\n");
    yccfpPrint( fp, "_pars[0].tk = (%s)", tc);
    yccGenTypeCodeName( ctx, fp, rettype);
    yccfpPrint( fp, ";\n");
    if ( !v12 )
      yccfpPrint( fp, "_pars[0].fixed = %s;\n", 
                  yccIsVariableType(ctx, rettype) ? "FALSE" : "TRUE");
  }

  if ( pars )                                   /* parameters */
  {
   for ( le = ysLstHead(pars); le; i++, le = ysLstNext(le) )
    {
      yrpar* par = (yrpar*) ysLstVal(le);

      yccfpPrint( fp, "_pars[%u].mode = ", i);
      switch (par->mode)
      {
        case YOMODE_IN:
          yccfpPrint( fp, "YOMODE_IN");
          break;
        case YOMODE_OUT:
          yccfpPrint( fp, "YOMODE_OUT");
          break;
        case YOMODE_INOUT:
          yccfpPrint( fp, "YOMODE_INOUT");
          break;
      }
      yccfpPrint( fp, ";\n_pars[%u].tk = (%s)", i, tc);
      yccGenTypeCodeName( ctx, fp, par->type);
      yccfpPrint( fp, ";\n");
      if ( !v12 )
        yccfpPrint( fp, "_pars[%u].fixed = %s;\n", 
                    i, (yccIsVariableType(ctx, par->type) ? "FALSE" : "TRUE"));
    }
  }
  
  if ( ctxs && !v12 )                           /* context ids */
  {    /* context id's are wedged into tk field */
    for ( le = ysLstHead(ctxs); le; i++, le = ysLstNext(le) )
    {
      const char* id = (char*) ysLstVal(le);

      yccfpPrint( fp, "_pars[%u].mode = YOMODE_CTX;\n", i);
      yccfpPrint( fp, "_pars[%u].tk = (%s)\"%s\";\n", i, tc, id);
      yccfpPrint( fp, "_pars[%u].fixed = TRUE;\n", i);
    }
  }

  if ( raises )                                 /* exceptions */
  {
    for ( le = ysLstHead(raises); le; i++, le = ysLstNext(le) )
    {
      yrobj* ex = (yrobj*) ysLstVal(le);

      yccfpPrint( fp, "_pars[%u].mode = YOMODE_EXCEPT;\n", i);
      yccfpPrint( fp, "_pars[%u].tk = (%s)", i, tc);
      yccGenTypeCodeName( ctx, fp, ex);
      yccfpPrint( fp, ";\n");
      if ( !v12 )
        yccfpPrint( fp, "_pars[%u].fixed = TRUE;\n", i);
    }
  }

  yccfpPrint( fp, "_pars[%u].mode = YOMODE_INVALID;\n", i);
  yccfpPrint( fp, "_pars[%u].tk = (%s)%s;\n", 
              i, tc, ycStyleCORBA(ctx) ? "TC_null" : "yoTcNull");
  yccfpPrint( fp, "_pars[%u].sz = (ub4)0;\n", i);
  if ( !v12 )
    yccfpPrint( fp, "_pars[%u].fixed = FALSE;\n", i);
  yccfpPrint( fp, "yoParsSize( _pars);\nyoParsSet( _desc);\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\nreturn _pars;\n");
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");
}
