/* Copyright (c) 1995 by Oracle Corporation.  All Rights Reserved.
 *
 * yccmap.c - generation of output (C language mapping)
 *
 * NOTES
 * This file contains both the main driver for C stub generation (yccmap),
 * and utility functions useful to all phases of the code gen (header,
 * client and server stubs).
 *
 * HISTORY
 * 11/28/96 kcoleman	Bug #426687: Change handling of output files
 * 11/11/96 kcoleman	Boolean constant value printing was broken
 * 09/27/96 kcoleman	Strict CORBA naming
 * 08/23/96 kcoleman	Support for context ids
 * 08/20/96 kcoleman	Bug 393905: Change gen of typecode and id defns
 * 07/17/96 kcoleman	Bug #382537: Rewrite short circuit, fix tyimpl
 * 07/10/96 kcoleman	Make generated headers safe for C++, handle C keywrds
 * 06/27/96 kcoleman	Bug 377748: No more global external data
 * 06/06/96 kcoleman	Bug 369357: Revamp I/O to limit line length
 * 04/17/96 kcoleman	Support for IAO server code generation (*G.c)
 * 04/08/96 kcoleman	Use ysRecord for error reporting.
 * 02/05/96 kcoleman	CORBA 2.0 stub generation
 * 12/06/95 kcoleman	New copy/free ops for BOA, fix copy/free for aliases
 * 11/11/95 dpranke     Push yrCloseRepository call into main driver
 * 11/07/95 kcoleman	Implement distinct Oracle and ANSI naming styles
 * 11/04/95 kcoleman	Copy/free support function generation
 * 11/02/95 kcoleman	Support for BOA stubs
 * 10/04/95 kcoleman	Make yccGenFuncHdr handle async func hdrs
 * 09/27/95 kcoleman	Make -e behavior the default behavior
 */

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCC0_ORACLE
#include <ycc0.h>
#endif
#ifndef YSL_ORACLE
#include <ysl.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif
#ifndef YCCFP_ORACLE
#include <yccfp.h>
#endif
#ifndef YCCP0_ORACLE
#include <yccp0.h>          /* to get at yccpIsKeyword */
#endif


STATICF void yccGenCopyFreeMacros( 
           ycctx* ctx, yccfp* fp, CONST char* derived, CONST char* base);
STATICF void yccGenAliasAllocator( ycctx* ctx, yccfp* fp, yrobj* type);
STATICF void yccmap(ycctx *ctx);
STATICF boolean yccSymFlush( dvoid* usrp, dvoid* elm);


/* --------------------------------------------------------------------- */
/*
 * yccmap - Driver for C code generation
 */

STATICF void yccmap(ycctx *ctx)
{
  char  base[SYSFP_MAX_PATHLEN];
  CONST char* path;
  ub4 baselen;
  yccctx cctx;
  ycfile* noreg files;
  noreg ub4 fcount;
  boolean hdronly, tmpl, iaosrvr;
  ub4 hdridx, clntidx, srvridx, thidx, tcidx, iaoidx;

  NOREG(files);
  NOREG(fcount);
  hdridx = clntidx = srvridx = thidx = tcidx = iaoidx = 0;
  iaosrvr = FALSE;

    /***** Figure out how many output files we're generating *****/
  sysfpExtractBase(base, ctx->srcnm);
  baselen = strlen(base);
  path = ysResGetLast("mnidlc.outputpath");
  fcount = (ub4) 1;
  hdridx = (ub4) 0;
  if ( !(hdronly = ysResGetBool("mnidlc.header-only")) )
  {
    clntidx = (ub4) fcount++;
    srvridx = (ub4) fcount++;
  }
  if ( (tmpl = ysResGetBool("mnidlc.server-template")) )
  {                                     /* order matters here - see ycctmpl */
    thidx = (ub4) fcount++;
    if ( !ysResGetBool( "mnidlc.tmpl-hdr-only") )
    {
      tcidx = (ub4) fcount++;
      if ( (iaosrvr = ysResGetBool("mnidlc.iao-srvr-gen")) )
        iaoidx = (ub4) fcount++;
    }
  }

    /***** Set up output file descriptors *****/
  files = (ycfile*) ysmGlbAlloc(sizeof(ycfile) * fcount, "ycfile");
  sysfpForm(files[hdridx].target, path, base, SYSFPKIND_CHEADER);
  if ( !hdronly )
  {
    base[baselen] = 'C';
    base[baselen+1] = '\0';
    sysfpForm(files[clntidx].target, path, base, SYSFPKIND_CSOURCE);
    base[baselen] = 'S';
    sysfpForm(files[srvridx].target, path, base, SYSFPKIND_CSOURCE);
  }
  if ( tmpl )
  {
    base[baselen] = 'I';
    base[baselen+1] = '\0';
    sysfpForm(files[thidx].target, path, base, SYSFPKIND_CHEADER);
    if ( !ysResGetBool( "mnidlc.tmpl-hdr-only") )
    {
      sysfpForm(files[tcidx].target, path, base, SYSFPKIND_CSOURCE);
      if ( iaosrvr )
      {
        base[baselen] = 'G';
        sysfpForm(files[iaoidx].target, path, base, SYSFPKIND_CSOURCE);
      }
    }
  }
  if ( !ycFileInit( (ycfile*)files, (ub4)fcount, path) )
  {                                         /* unable to set up output files */
    ysmGlbFree((dvoid*)files);
    return;
  }

    /***** Generate code *****/
  /***** Set up C lang mapping specific context *****/
  CLRSTRUCT(cctx);
  cctx.tcpfx_yccctx = (ycStyleCORBA(ctx) ? "TC" : "YCTC");
  cctx.seqpfx_yccctx = (ycStyleCORBA(ctx) ? "CORBA" : "YCIDL");
  ctx->langctx = &cctx;

  yseTry
  {
      /* generate output */
    base[baselen] = '\0';                  /* cause we diddled with it above */
    ycchdr(ctx, base, &(files[hdridx]));                       /* gen header */

    if (ysResGet("mnidlc.server-template"))            /* gen impl templates */
      ycctmpl(ctx, base, &(files[thidx]));

    if (!ysResGet("mnidlc.header-only"))
    {
      yccclnt(ctx, base, &(files[clntidx]));              /* gen client stub */
      yccsrv(ctx, base, &(files[srvridx]));              /* gen server stubs */
    }
    ycSymTblFlush( ctx->symtbl, (ycsymwcb)yccSymFlush, (dvoid*)0);
    ycFileRename((ycfile*)files, (ub4)fcount);
  }
  yseCatchAll
  {
    CONST char* fn;
    sword ln;
    ub4 i;

    yseGetLoc(&fn, &ln);
    ysRecord( YCMSG(0), YCERRSEV, YSLSTR(ysidToStr(yseExid)), 
              YSLSTR(fn), YSLSB4(ln), YSLEND);
    for (i = 0; i < fcount; i++)
      DISCARD sysfpRemove(files[i].newtmp);
  }
  yseEnd
  ysmGlbFree((dvoid*)files);
}


/* --------------------------------------------------------------------- */
/*
 * yccGenTypeCode - generate a type code declaration/definition
 *
 * For a declaration:
 *   CONST yotk* name__getTC();
 *   #define YCTC_name (name__getTC())
 *
 * For a definition:
 *   static CONST_DATA yotk name__tc[] = {...};
 *   CONST yotk* name__getTC()
 *   {
 *     return name__tc;
 *   }
 *
 * The #define in the decl is generated primarily for backward compatibility. 
 * Guards are not generated here to allow callers to embed this within 
 * other guards.
 *
 * Note that for CORBA compliance, the user visible name should be
 * TC_name, not YCTC_name.
 */
void yccGenTypeCode( ycctx* ctx, yccfp* fp, CONST char* name, CONST yotk* tc,
                     boolean external)
{
  boolean useGlob = yccUseGlobals( ctx);
  CONST char* tcpfx = yccTCPrefix(ctx);
  CONST char* tcnm;

  if ( tc )                  /* type code definition */
  {
    if ( external )
    {
      if ( !useGlob )
        yccfpPrint( fp, "static %syotk %s__tc[]", YCCCDATA(ctx), name);
      else
        yccfpPrint( fp, "%s%s yotk %s_%s[]", 
                    YCCEXDEF(ctx), YCCCDATA(ctx), tcpfx, name);
    }
    else     /* static typecode generation enabled */
    {
      yccfpPrint(fp, "static %syotk %s_%s[]", YCCCDATA(ctx), tcpfx, name);
    }

    yccfpPrint( fp, " = \n");
    yccfpIncIndent( fp);
    yccFormatTypeCodeDefn( ctx, fp, tc);
    yccfpDecIndent( fp);

    if ( external )
    {
      tcnm = yccGetPrimitiveName( ctx, yrpkTypeCode);
      yccfpPrint( fp, "CONST %s %s__getTC(void)\n{\n", tcnm, name);
      yccfpIncIndent( fp);
      if ( !useGlob )
        yccfpPrint( fp, "return %s__tc;\n",  name);
      else
        yccfpPrint( fp, "return %s_%s;\n", tcpfx, name);
      yccfpDecIndent( fp);
      yccfpPrint( fp, "}\n\n");
    }
  }
  else                       /* type code declaration only */
  {
    tcnm = yccGetPrimitiveName( ctx, yrpkTypeCode);
    yccfpPrint( fp, "CONST %s %s__getTC(void);\n", tcnm, name);
    if ( !useGlob )
    {
      yccfpStartPP( fp);
      yccfpPrint( fp, "#ifndef %s_%s\n", tcpfx, name);
      yccfpPrint( fp, "#define %s_%s   (%s__getTC())\n", tcpfx, name, name);
      yccfpPrint( fp, "#endif\n");
      yccfpEndPP( fp);
    }
    else
      yccfpPrint( fp, "%s%syotk %s_%s[];\n", 
                  YCCEXREF(ctx), YCCCDATA(ctx), tcpfx, name);
  }
}

/* --------------------------------------------------------------------- */
/*
 * yccGenTypeCodeMacro - generate a type code "declaration" macro
 *
 * Inherited types do not get new typecodes; they used #defines of
 * the defining type.
 */
void yccGenTypeCodeMacro( ycctx* ctx, yccfp* fp, CONST char* alias, 
                          yrobj* basetype)
{
  CONST char* tcpfx = yccTCPrefix(ctx);

  yccfpStartPP( fp);
  yccfpPrint( fp, "#ifndef %s_%s\n#define %s_%s ", tcpfx, alias, tcpfx, alias);
  yccGenTypeCodeName( ctx, fp, basetype);
  yccfpPrint( fp, "\n#endif /* %s_%s */\n\n", tcpfx, alias);
  yccfpEndPP( fp);
}


/* --------------------------------------------------------------------- */
/*
 * yccGenSysIncls - generate include directives used by all generated files.
 *
 * Currrently, we include sysx/i.h and yo.h in files. If <impl> is true,
 * we generating an implementation vs. a header files, so we include
 * sysi instead of sysx.
 *
 * sysi.h is not a public Oracle header, so dependencies on it are only
 * permitted when the selected naming style is YCSTYLE_ORA.
 */
void yccGenSysIncls(ycctx* ctx, yccfp* fp, boolean impl)
{
  yccfpStartPP( fp);
  if ( impl && (ctx->style & YCSTYLE_ORA) )
    yccfpPrint(fp, "#ifndef SYSI_ORACLE\n#include <sysi.h>\n#endif\n");
  else if ( !impl )
    yccfpPrint(fp, "#ifndef SYSX_ORACLE\n#include <sysx.h>\n#endif\n");

  if ( (ctx->objAdaptor == YCOA_BOA) || (ctx->style & YCSTYLE_CORBA) )
    yccfpPrint(fp, "#ifndef YOORB_ORACLE\n#include <yoorb.h>\n#endif\n\n");
  else
    yccfpPrint(fp, "#ifndef YO_ORACLE\n#include <yo.h>\n#endif\n\n");
  yccfpEndPP( fp);
}


/* --------------------------------------------------------------------- */
/*
 * yccGenFuncHdr - generate a function header, ANSI C style
 *
 * All function header generation goes through here: prototypes for the
 * public header, function pointers for the __tyimpl structure, and
 * function definition headers for client, server, and implementation
 * stubs. Please keep it that way so we don't get divergent behavior.
 *
 * Given a function name, return type, and parameter list, generate a
 * a function header. The header is closed, but no newline or semi-colon
 * is placed after it because we may be doing this in many different
 * contexts. 
 *
 * I know this looks like the parameter list from hell, but you pass
 * all this in in pieces so that attributes and operations can share
 * the same code for the sake of consistency. All the requisite information
 * is gathered together nicely for ops, but is constructed on the fly for
 * attributes.
 *
 * <fptr> indicates whether we're generating a real function decl or a
 * function pointer decl. <intf> is needed to gen the implicit first
 * parameter for the discriminated object.
 *
 * <kind> indicates what sort of function suffix is required. No-wait
 * (async) funcs use "_nw". This is a convenience to save the caller
 * from constructing the alternative forms of the name. Also lets us tack 
 * on the extra event param for _nw ops here.
 *
 * If you need to make a change here, you will almost certainly need to
 * make a corresponding change to yccGenDerivedFunc in ycchdr.c.
 */
void yccGenFuncHdr( ycctx* ctx, yccfp* fp, yrobj* rettype, yrobj* intf,
        CONST char* funcName, yslst* params, yslst* ctxs, boolean fptr, 
        yccfnk kind)
{
  ysle* le;

  if ( rettype )
    yccGenParamType( ctx, fp, rettype, YOMODE_RETURN);
  else
    yccGenParamType( ctx, fp, yrGetPrimitive( ctx->repository, yrpkvoid),
                     YOMODE_RETURN);

  if ( !fptr )
  {
    switch (kind)
    {
      case yccfnk_normal:
        yccfpPrint(fp, " %s( ", funcName);
        break;
      case yccfnk_nw:
        yccfpPrint(fp, " %s_nw( ", funcName);
        break;
      default:
        yseThrow(YC_EX_FAILURE);
    }
  }
  else
  {
    CONST char* kwdpfx = ((*ctx->lang->kwdchk)(ctx, funcName) ? "_" : "");

    switch (kind)
    {
      case yccfnk_normal:
        yccfpPrint(fp, " (*%s%s)( ", kwdpfx, funcName);
        break;
      default:
        yseThrow(YC_EX_FAILURE);
    }
  }

  yccGenTypeName(ctx, fp, intf);
  if ( ycCORBA1_2(ctx) )
    yccfpPrint( fp, "%s, %s*%s", 
                fptr ? "" : " or", yccEnvPar( ctx), fptr ? "" : " ev");
  else if ( !fptr )
    yccfpPrint(fp, " or");

  if ( params )
  {
    for (le = ysLstHead(params); le; le = ysLstNext(le))
    {
      yrpar* par = (yrpar*) ysLstVal(le);

      yccfpPrint(fp, ", ");
      yccGenParamType( ctx, fp, par->type, par->mode);
      if ( !fptr )
      {
        yccfpPrint( fp, " ");
        yccGenSimpleName( ctx, fp, par->name);
      }
    }
  }
  if ( !ycCORBA1_2(ctx) )
  {
    if ( !ycIsEmptyLst(ctxs) )
      yccfpPrint( fp, ", CORBA_Context%s", fptr ? "" : " corbctx_");
    yccfpPrint( fp, ", %s*%s", yccEnvPar( ctx), fptr ? "" : " ev");
  }
  if ( kind == yccfnk_nw )
    yccfpPrint( fp, ", ysevt*%s)", fptr ? "" : " _sem");
  else
    yccfpPrint( fp, ")");
}


/* --------------------------------------------------------------------- */
/*
 * yccGenCopyFreeMacros - generate macros for support funcs like copy and free
 *
 * Inherited types and most aliases get macro wrappers around the support
 * functions of their base types rather than new function prototypes.
 *
 * The BOA version takes an extra parameter (the CORBA_Environment) and
 * have "ORA_CORBA" prefixed to the function names, just to make them
 * REALLY horrific.
 */
STATICF void yccGenCopyFreeMacros( 
           ycctx* ctx, yccfp* fp, CONST char* derived, CONST char* base)
{
  yccfpStartPP( fp);
  if ( ctx->objAdaptor == YCOA_BOA )
  {
    yccfpPrint( fp, "#define ORA_CORBA_%s__free(ev, val, ffunc) ", derived);
    yccfpPrint( fp, "ORA_CORBA_%s__free((ev), (val),(ffunc))\n", base);
    yccfpPrint( fp, "#define ORA_CORBA_%s__copy(ev, dest, src, afunc) ",
                derived);
    yccfpPrint( fp, "ORA_CORBA_%s__copy((ev),(dest),(src),(afunc))\n", base);
  }
  else
  {
    yccfpPrint( fp, "#define %s__free(val, ffunc) %s__free((val),(ffunc))\n",
                    derived, base);
    yccfpPrint( fp, "#define %s__copy(dest, src, afunc) ", derived);
    yccfpPrint( fp, "%s__copy((dest),(src),(afunc))\n", base);
  }
  yccfpEndPP( fp);
}


/* --------------------------------------------------------------------- */
/*
 * ycIsAnonymous - is this an anonymous type, or an alias of one?
 *
 * One tricky thing about this function: Unbound strings are not treated
 * as anonymous...because they can be referred to in code by name ("string").
 * I haven't decided whether I like this or not - it fit for one place I
 * wanted this operation, but not in the other. Live with it awhile and see.
 */
boolean ycIsAnonymous( ycctx* ctx, yrobj* type)
{
  if ( yrGetKind(type) == yrdkAlias )
    type = yrAliasData(type).type;     /* only look thru 1 level */
  switch ( yrGetKind(type) )
  {
    case yrdkString:
    case yrdkSequence:
    case yrdkArray:
      return TRUE;
    default:
      return FALSE;
  }
}

/* --------------------------------------------------------------------- */
/*
 * yccGenCopyFree - generate __copy and __free support functions
 *
 * For any type T, T__copy is a wrapper around yotkCopyVal and T__free
 * is a wrapper around yotkFreeVal. They are predefined for the 
 * primitive and builtin sequence types.
 *
 * Aliases of named types just get macro wrappers around the corresponding
 * base type functions. Ditto for inherited non-interface types. Aliases
 * of anonymous types get real function definitions.
 *
 * The function prototypes, in twisty pseudo-IDL/pseudo-C:
 *
 *   void T__free( out T val, ysmff ffunc);
 *   void T__copy( out T dest, out T src, ysmaf afunc);
 *
 * Out parameter semantics are used in all cases for consistency with
 * the underlying yotk operations.  *
 * With the possible exception of primitive types, these support
 * functions should be hand in glove with typecode generation: If a
 * type doesn't get a distinct typecode, it shouldn't get real
 * function definitions either. YCTC macro -> copy/free macros.
 *
 * BOA users require special versions because of the difference in how
 * exceptions are handled. To avoid problems with mixed environments,
 * the function names are also changed:
 *
 *   void ORA_CORBA_T__copy( CORBA_Environment* ev, <same as above>);
 *   void ORA_CORBA_T__free( CORBA_Environment* ev, <same as above);
 *
 * They differ from the COA versions only in that the calls to yotkCopyVal
 * and yotkFreeVal are wrapped in try/catch blocks and exception info is
 * shoved into the environment.
 */

void yccGenCopyFree( ycctx* ctx, yccfp* fp, yrobj* type, boolean defn)
{
  CONST char* tname;
  boolean inherited = ycgInherited( ctx, type);
 
    /*** Eliminate the types for which copy/free funcs aren't generated ***/
  switch (yrGetKind( type))
  {
    case yrdkAlias:
    {
      yrobj* basetype = yrGetAliasBaseType(type);

      if ( (yrGetKind(basetype) == yrdkPrimitive) || 
           ycIsCorbaObject( ctx, basetype) )
        return;
      /* else fall thru */
    }
    case yrdkStruct:
    case yrdkUnion:
    case yrdkInterface:
    case yrdkException:
    case yrdkEnum:
      if ( defn && (!ycShouldGenCode( ctx, type) || inherited) )
        return; 
      tname = yccGetAbsoluteName(ctx, type, (yrobj*)0);
      break;
    default:
      return;
  }

    /*** inherited type (&!defn) ***/
  if ( inherited )
  {
    yrobj* inInterface = ycgScopeLookup( ctx, yrdkInterface);
    CONST char* dname = yccGetAbsoluteName( ctx, type, inInterface);

    yccGenCopyFreeMacros( ctx, fp, dname, tname);
    ysmGlbFree( (dvoid*)dname);
    return;
  }

    /*** an alias type which just gets a macro ***/
  if ( (yrGetKind(type) == yrdkAlias) && !ycIsAnonymous(ctx, type) )
  {
    CONST char* bname;

    if ( !defn )
    {
      bname = yccGetAbsoluteName( ctx, yrAliasData(type).type, (yrobj*)0);
      yccGenCopyFreeMacros( ctx, fp, tname, bname);
    }   /* else, no defns for most aliases */
  }
    /*** aliases of anonymous types, and all other types ***/
  else
  {
    CONST char* voidstr = YCCVOID(ctx);
    boolean doingBOA = (ctx->objAdaptor == YCOA_BOA);
    CONST char* prefix = (doingBOA ? "ORA_CORBA_" : "");

      /*** free function ***/
    yccfpPrint( fp, "void %s%s__free( ", prefix, tname);
    if ( doingBOA )
      yccfpPrint( fp, "CORBA_Environment* ev, ");
    yccGenParamType( ctx, fp, type, YOMODE_INOUT);
    yccfpPrint( fp, " val, ysmff ffunc)");
    if ( defn )
    {
      yccfpPrint( fp, "\n{\n");
      yccfpIncIndent( fp);
      if ( doingBOA )
      {
        yccfpPrint( fp, "if ( ev->_major != CORBA_NO_EXCEPTION )\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "return;\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "yseTry\n{\n");
        yccfpIncIndent( fp);
      }

      yccfpPrint( fp, "yotkFreeVal( ");
      yccGenTypeCodeName( ctx, fp, type);
      yccfpPrint( fp, ", (%s*)val, ffunc);\n", voidstr);
      yccfpDecIndent( fp);
      yccfpPrint( fp, "}\n");

      if ( doingBOA )
      {
        yccfpPrint( fp, "yseCatchAll\n{\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "ev->_major = CORBA_SYSTEM_EXCEPTION;\n");
        yccfpPrint( fp, "ev->id = (CORBA_char*) yseExid;\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\nyseEnd\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n");
      }
      yccfpPrint( fp, "\n");
    }
    else
      yccfpPrint( fp, ";\n");

      /*** copy function ***/
    yccfpPrint( fp, "void %s%s__copy( ", prefix, tname);
    if ( doingBOA )
      yccfpPrint( fp, "CORBA_Environment* ev, ");
    yccGenParamType( ctx, fp, type, YOMODE_INOUT);
    yccfpPrint( fp, " dest, ");
    yccGenParamType( ctx, fp, type, YOMODE_INOUT);
    yccfpPrint( fp, " src, ysmaf afunc)");
    if ( defn )
    {
      yccfpPrint( fp, "\n{\n");
      yccfpIncIndent( fp);
      if ( doingBOA )
      {
        yccfpPrint( fp, "if ( ev->_major != CORBA_NO_EXCEPTION )\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "return;\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "yseTry\n{\n");
        yccfpIncIndent( fp);
      }
      yccfpPrint( fp, "yotkCopyVal( ");
      yccGenTypeCodeName( ctx, fp, type);
      yccfpPrint( fp, ", (%s*)dest, (%s*)src, afunc);\n", voidstr, voidstr);
      yccfpDecIndent( fp);
      yccfpPrint( fp, "}\n");
      if ( doingBOA )
      {
        yccfpPrint( fp, "yseCatchAll\n{\n");
        yccfpIncIndent( fp);
        yccfpPrint( fp, "ev->_major = CORBA_SYSTEM_EXCEPTION;\n");
        yccfpPrint( fp, "ev->id = (CORBA_char*) yseExid;\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\nyseEnd\n");
        yccfpDecIndent( fp);
        yccfpPrint( fp, "}\n");
      }
      yccfpPrint( fp, "\n");
    }
    else
      yccfpPrint( fp, ";\n");
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenParamType - generate func param/return type declarator, according
 *        to mode of YOMODE_IN, YOMODE_OUT, YOMODE_INOUT, YOMODE_RETURN.
 *
 * The rules for how parameters and return values are passed is
 * complicated to get into in detail here. See section 5.18 of
 * the CORBA 1.2 spec for a summary.
 *
 * Typedefs are handled by printing out the typedef name and then
 * looping until we get our hands on the base type.
 */
void yccGenParamType( ycctx* ctx, yccfp* fp, yrobj* type, sword mode)
{
  boolean genName = TRUE;	/* used to peer through typedefs */

  for (;;)
  {
    switch (yrGetKind(type))
    {
      case yrdkInterface:
      case yrdkEnum:
	  /* by ref for out/inout, else by value */
        if ( genName )
          yccGenTypeName(ctx, fp, type);
        if ( (mode == YOMODE_OUT) || (mode == YOMODE_INOUT) )
          yccfpPrint(fp,"*");
        return;
      case yrdkUnion:
      case yrdkStruct:
      case yrdkSequence:
      case yrdkException:
        if ( genName )
          yccGenTypeName(ctx, fp, type);
        if ( yccIsVariableType( ctx, type) )
        {
          if ( mode != YOMODE_OUT )
            yccfpPrint(fp,"*");
          else
            yccfpPrint(fp,"**");
        }
        else if ( mode != YOMODE_RETURN )
            yccfpPrint(fp,"*");
        return;
      case yrdkAlias:
        if ( genName )
        {
          yrobj* base = yrGetAliasBaseType( type);

          if ( (yrGetKind(base) == yrdkArray) &&
               ((mode == YOMODE_RETURN) ||
               ((mode == YOMODE_OUT) && yccIsVariableType( ctx, base))) )
          {
            CONST char* tname = yccGetAbsoluteName(ctx, type, (yrobj*)0);

            if ( mode == YOMODE_RETURN )
              yccfpPrint( fp, "%s_slice*", tname);
            else     /* mode == out and this is a var length type */
              yccfpPrint( fp, "%s_slice**", tname);
            return;
          }
          else
            yccGenTypeName(ctx, fp, type);
          genName = FALSE;
          type = base;
        }
        break;
      case yrdkString:
          /* ptr to first element everything but out/inout */
        if ( genName )
          yccGenPrimitiveName(ctx, fp, yrpkstring);
        if ( (mode == YOMODE_OUT) || (mode == YOMODE_INOUT) )
          yccfpPrint(fp, "*");
        return;
      case yrdkArray:
        return;
      case yrdkPrimitive:
        if ( genName )
          yccGenTypeName(ctx, fp, type);
        if ( yrPrimData(type).kind == yrpkany )    /* like var struct */
        {
          if ( yccIsVariableType( ctx, type) )
          {
            if ( mode != YOMODE_OUT )
              yccfpPrint(fp,"*");
            else
              yccfpPrint(fp,"**");
          }
          else if ( mode != YOMODE_RETURN )
              yccfpPrint(fp,"*");
        }
        else if ( (mode == YOMODE_OUT) || (mode == YOMODE_INOUT) )
             yccfpPrint(fp, "*");
        return;
      default:
        yseThrow(YS_EX_FAILURE);
        break;
    }
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccIsVariableType - Is this a variable length type?
 *
 * According to CORBA 2.0, Section 14.8, a variable length type is one
 * of the following:
 * 
 * - Any, string (bounded or unbounded), sequence (bounded or unbounded)
 * - Object reference, or ref to transmissible pseudo object (like TypeCode)
 * - A struct or union with a member of variable-length type
 * - An array with variable-length element type
 * - A typedef of a variable-length type
 *
 * This attribute affects parameter and return type handling and the
 * generation of certain type-specific allocators.
 *
 * Since this operation is potentially expensive, for the more complicated
 * types which require recursive analysis, the variable length attribute 
 * is stashed in the symbol table entry. We don't bother for types for
 * which the question is easily answered because this analysis is cheaper
 * than the symbol table lookup.
 */
boolean yccIsVariableType( ycctx* ctx, yrobj* type)
{
  boolean result = FALSE;
  ysle* le;
  ycsym* syminfo = (ycsym*)0;

  if ( ycCORBA1_2( ctx) )
    return FALSE;           /* no notion of variable length types before 2.0 */

    /***** The easy cases *****/
  switch (yrGetKind(type))
  {
    case yrdkPrimitive:
      switch ( yrPrimData(type).kind)
      {
        case yrpkany:
        case yrpkstring:
        case yrpkTypeCode:
        case yrpkobjref:
          return TRUE;
          break;
        default:
          return FALSE;
          break;
      }
      break;
    case yrdkInterface:
    case yrdkString:
    case yrdkSequence:
      return TRUE;
      break;
    case yrdkArray:
    case yrdkStruct:
    case yrdkException:    /* @@ not too sure about this one */
    case yrdkUnion:
    case yrdkAlias:
      syminfo = ycSymLookup( ctx->symtbl, type);
      break;
    default:
      return FALSE;
      break;
  }

  if ( syminfo && syminfo->isVarType )       /* already set in sym tab */
    return ((syminfo->isVarType > 0) ? TRUE : FALSE);

    /***** The more complex types requiring recursive analysis *****/
  switch (yrGetKind(type))
  {
    case yrdkArray:
      result = yccIsVariableType( ctx, yrArrayData(type).elmtype);
      break;
    case yrdkStruct:
    case yrdkException:    /* @@ not too sure about this one */
      for ( le = ysLstHead( yrStructData(type).mbrs); le; le = ysLstNext(le))
      {
        if ((result = yccIsVariableType(ctx, ((yrstrmbr*)ysLstVal(le))->type)))
          break;
      }
      break;
    case yrdkUnion:
      /* discrim type doesn't matter since it's limited to fixed types */
      for ( le = ysLstHead( yrUnionData(type).arms); le; le = ysLstNext(le))
      {
        if ((result = yccIsVariableType(ctx, ((yrunmbr*)ysLstVal(le))->type)))
          break;
      }
      break;
    case yrdkAlias:
      result = yccIsVariableType( ctx, yrGetAliasBaseType( type));
      break;
    default:
      result = FALSE;
      break;
  }
  if ( syminfo )                         /* stash in symtab */
    syminfo->isVarType = result;
  return result;
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenAllocator - Generate custom allocator as required by CORBA 2.0
 *
 * Variable length struct/union/arrays types, string, sequence, and any
 * all get custom allocators under CORBA 2.0. The string and any
 * allocators are predefined, as are allocators for the builtin sequence
 * types. All other allocators are generated by this function. All of
 * them are macro wrappers because for anonymous types (like sequences)
 * we have no way to select the right place to generate a func definition.
 *
 * If <type> is an alias of a qualifying type, a #define of the base
 * type's allocator is generated. Otherwise, for struct or union type T:
 *
 *   T* T__alloc();                                 -- conceptually
 *   #define T__alloc() ((T*) yoAlloc(sizeof(T)))   -- in reality
 *
 * For an array T:
 *
 *   T_slice* T__alloc();                                -- conceptually
 *
 *   #define T__alloc() ((T_slice*) yoAlloc(sizeof(T)))  -- in reality
 *
 * For sequence<T>:
 *
 *   YCIDL_sequence_T* YCIDL_sequence_T__alloc();   -- conceptually
 *   T* YCIDL_sequence_T_allocbuf( ub4 len);        -- conceptually
 *
 *   #define YCIDL_sequence_T__alloc() ...like structs, etc...
 *   #define YCIDL_sequence_T__allocbuf()   ((T*) yoAlloc( len*sizeof(T)))
 *
 * We do the usual derivation, making the allocator for an inherited type
 * just a #define of the defining type.
 *
 * As always, aliases are a mess unto themselves. See yccGenAliasAllocator.
 *
@@ In reality, we should probably generate custom allocators for all 
@@ structs and unions, not just variable length ones. For now, leave it as
@@ CORBA specifies to I can tell if we're making the right type determinations
 *
@@ The allocator function definitions are just wrappers around yoAlloc
@@ right now. Change them as needed once we've spec'd the new yo interactions.
 */

void yccGenAllocator( ycctx* ctx, yccfp* fp, yrobj* type, boolean defn)
{
  CONST char* tname;
  boolean inherited;

  if ( defn || ycCORBA1_2( ctx) || !yccIsVariableType( ctx, type) )
    return;

  tname = yccGetAbsoluteName(ctx, type, (yrobj*)0);
  switch ( yrGetKind(type) )
  {
    case yrdkSequence:             /* OK to ignore inheritance here */
    {
      yrobj* etype = yrSeqData(type).elmtype;
      CONST char* ename = yccGetAbsoluteName( ctx, etype, (yrobj*)0);

      yccfpStartPP( fp);
      yccfpPrint( fp, "#define %s_allocbuf(len) ", tname);
      yccfpPrint( fp, "((%s*) yoAllocBufTk((len), sizeof((%s)), ",
                  ename, ename);
      yccGenTypeCodeName(ctx, fp, etype);
      yccfpPrint( fp, "))\n");
      yccfpEndPP( fp);
      /* fall through */
    }
    case yrdkUnion:
    case yrdkStruct:
      inherited = ycgInherited( ctx, type);
      yccfpStartPP( fp);
      if ( inherited )
      {
        CONST char* dname = 
           yccGetAbsoluteName( ctx, type, ycgScopeLookup( ctx, yrdkInterface));
    
        yccfpPrint( fp, "#define %s__alloc() ", dname);
        yccfpPrint( fp, "  ((%s*) %s__alloc())\n", dname, tname);
        ysmGlbFree( (dvoid*)dname);
      }
      else
      {
        yccfpPrint( fp, "#define %s__alloc() ", tname);
        yccfpPrint( fp, "    ((%s*) yoAllocTk( sizeof(%s), ", tname, tname);
        yccGenTypeCodeName( ctx, fp, type);
        yccfpPrint( fp, "))\n");
      }
      yccfpEndPP( fp);
      break;
    case yrdkAlias:
      yccGenAliasAllocator( ctx, fp, type);
      break;
    default:
      return;
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenAliasAllocator - Generate CORBA 2.0 type-specific allocator for alias
 *
 * For most aliases, this is just a #define of base type (even if the base
 * type is an alias itself). Arrays and sequences get special handling:
 * Sequences because they get 2 alloc functions instead of just one, arrays 
 * because the allocator return type is a pointer to the slice.
 *
 * Aliases of most primitives get no allocator because the primitives
 * don't have one either. The two exceptions are "string" and "any".
 *
 * As usual, if the alias is an inherited type, we generate a #define
 * of the defining type name.
 */

STATICF void yccGenAliasAllocator( ycctx* ctx, yccfp* fp, yrobj* type)
{
  CONST char* tname;
  yrobj* base = yrGetAliasBaseType( type);
  boolean inherited = ycgInherited( ctx, type);

    /*** Deal with inheritance annoyance ***/
  if ( inherited )
    tname = yccGetAbsoluteName(ctx, type, ycgScopeLookup( ctx, yrdkInterface));
  else
    tname = yccGetAbsoluteName(ctx, type, (yrobj*)0);

  yccfpStartPP( fp);
  switch (yrGetKind( base))
  {
    case yrdkString:
      yccfpPrint( fp, "#define %s__alloc(len)  CORBA_string_alloc((len))\n", 
                  tname);
      break;
    case yrdkPrimitive:
      if ( yrPrimData(base).kind == yrpkany )
        yccfpPrint( fp, "#define %s__alloc()  CORBA_any_alloc()\n", tname);
      else if ( yrPrimData(base).kind == yrpkstring )
        yccfpPrint( fp, "#define %s__alloc(len) CORBA_string_alloc((len))\n", 
                    tname);
      break;
    case yrdkArray:
      if ( inherited )
      {
        CONST char* bname = yccGetAbsoluteName( ctx, type, (yrobj*)0);
    
        yccfpPrint( fp, "#define %s__alloc() ", tname);
        yccfpPrint( fp, "((%s_slice*) %s__alloc())\n", tname, bname);
      }
      else
      {
        yccfpPrint( fp, "#define %s__alloc() ", tname);
        yccfpPrint( fp, "((%s_slice*) yoAllocTk( sizeof(%s), ", tname, tname);
        yccGenTypeCodeName( ctx, fp, type);
        yccfpPrint( fp, "))\n");
      }
      break;
    case yrdkSequence:
      yccfpPrint( fp, "#define %s_allocbuf(len) ", tname);
      yccfpPrint( fp, "(%s_allocbuf((len)))\n",
                  yccGetAbsoluteName( ctx, base, (yrobj*)0));
      /* fall thru */
    case yrdkStruct:
    case yrdkUnion:
      yccfpPrint( fp, "#define %s__alloc() ", tname);
      yccfpPrint( fp, "((%s*) %s__alloc())\n", 
                  tname, yccGetAbsoluteName( ctx, base, (yrobj*)0));
      break;
    case yrdkInterface:
    case yrdkException:
    case yrdkEnum:
    default:
      break;
  }
  yccfpEndPP( fp);

  if ( inherited )
    ysmGlbFree( (dvoid*)tname);
}


/* ---------------------------------------------------------------------- */
/*
 * yccGenSupportFuncs - decls/defns of any functions we generate beyond
 *   the required op/attribute funcs
 *
 * Currently, we generated T__copy, T__free, and T__getTC for most types T.
 * In addition, interface types get T__getId and T__getStubs; exceptions
 * also have a T__getId for their exception id.
 *
 * Not all functions are generated for all types - we must make allowances
 * for anonymous vs. named types, builtin vs. user defined, and inherited
 * vs. defining.
 */
void yccGenSupportFuncs( ycctx* ctx, yccfp* fp, yrobj* type, boolean defn)
{
  CONST char* nm = (char*)0;
  yrobj* inInterface;
  boolean inherited = FALSE;

  if ( ctx->lang->flags & YCCFLG_NO_SUPP_FUNCS )
    return;

  if ( !defn )
  {
    inherited = ycgInherited( ctx, type);

    if ( inherited )
    {
      inInterface = ycgScopeLookup( ctx, yrdkInterface);
      nm = yccGetAbsoluteName( ctx, type, inInterface);
    }
    else
      nm = yccGetAbsoluteName( ctx, type, (yrobj*)0);

    yccfpStartPP( fp);
/* @@ change this for 4.0 - use same guard for both OA's */
    if ( ctx->objAdaptor == YCOA_BOA )
    {
      yccfpPrint( fp, "#ifndef ORA_CORBA_%s_SUPP_FUNCS\n", nm);
      yccfpPrint( fp, "#define ORA_CORBA_%s_SUPP_FUNCS\n", nm);
    }
    else
      yccfpPrint( fp, "#ifndef %s_SUPP_FUNCS\n#define %s_SUPP_FUNCS\n",
                  nm, nm);
    yccfpEndPP( fp);
  }

  yccGenCopyFree( ctx, fp, type, defn);
  yccGenAllocator( ctx, fp, type, defn);

  if ( !defn )
  {
    yccfpStartPP( fp);
    if ( ctx->objAdaptor == YCOA_BOA )
      yccfpPrint( fp, "#endif /* ORA_CORBA_%s_SUPP_FUNCS */\n\n", nm);
    else
      yccfpPrint( fp, "#endif /* %s_SUPP_FUNCS */\n\n", nm);
    yccfpEndPP( fp);
  
    if ( inherited )
      ysmGlbFree( (dvoid*)nm);
  }
}


/* ---------------------------------------------------------------------- */
/*
 * yccTakeAddrOf - Determine whether or not we need to take the
 *      address of a parameter before sending it to yoSendReq or
 *      stuffing it into the _value field of an Any.
 *
 * If this function returns TRUE, it means that a parameter of type <type>
 * passed into a client stub as mode <mode> must have it's address taken 
 * before it is stuffed into the vector that is passed to yoSendReq.
 *
 * Out and inout parameters are always in the proper form to begin with
 * since that is essentially what yoSendReq uses as a guideline. In
 * parameters must sometimes have their address taken to make them
 * use the out mode. See the table at the top of this file for a
 * summary of how things are passed.
 *
 * You can almost do this as a table lookup, but primitive (yrdkPrimitive)
 * of type "any" and aliases have to be handled as special cases, and
 * you essentially need to index by type, mode, and yoSendReq-ity.
 */

boolean yccTakeAddrOf( ycctx* ctx, yrobj* type, sword mode)
{
  if ( mode != YOMODE_IN )
    return FALSE;

  for (;;)	/* loops to deal with aliases */
  {
    switch (yrGetKind(type))
    {
      case yrdkUnion:
      case yrdkStruct:
      case yrdkSequence:
      case yrdkArray:
        return FALSE;                           /* already passed by ref */

      case yrdkAlias:                           /* peer thru to base type */
        type = yrGetAliasBaseType( type);
        break;

      case yrdkInterface:
      case yrdkEnum:
      case yrdkString:
        return TRUE;                            /* usually passed by value */

      case yrdkPrimitive:
        if ( yrPrimData(type).kind == yrpkany )		/* any == struct */
          return FALSE;
        else
          return TRUE;

      default:
        yseThrow(YS_EX_FAILURE);
        break;
    }
  }
}

/* ------------------------------------------------------------------------ */
/*
 * yccGetLineLimit - determine output file line length max based on context.
 *
 * Theoretically, it is possible to have no line limit, but this means you
 * lose the auto-indentation of yccfp and your output is unreadable. So, we
 * use a default line limit of YCC_LINE_DEFAULT.
 *
 * If the user supplies an explicit line limit via the environment, we
 * use that instead. This takes precedence over all other settings.
 *
 * If we're generating Oracle code (YCSTYLE_ORA), we need to be OCCS
 * compliant, so the line limit is 79 unless explicitly overridden.
 */

ub2 yccGetLineLimit( ycctx* ctx)
{
  ub2 maxline;
  CONST char* limit;

  limit = ysResGetLast( "mnidlc.c-line-limit");
  if ( limit )
  {
    maxline = (ub2) strtoul( limit, (char**)0, 10);
    if ( maxline < YCC_MIN_LINE )    /* no line limits like 5 chars! */
      maxline = YCC_MIN_LINE;
  }
  else if ( ctx->style & YCSTYLE_ORA )
    maxline = YCC_OCCS_MAX_LINE;
  else
    maxline = YCC_DFLT_MAX_LINE;
  return maxline;
}

/* ------------------------------------------------------------------------ */
/*
 * yccGenId - generate an interface or exception id decl or defn.
 *
 * This involves either a static ysid and a macro, or a global ysid.
 * In both cases, we also generate an accessor function.
 *
 * When generating the definition, the last declaration is left incomplete
 * so that the caller can generate the value.
 *
 * We take two names because this code is shared for interface ids and
 * exception ids, and for exception ids part of the decls uses the
 * EX_FOO form of a name. Nm1 should be the EX_* form, nm2 is the
 * "normal" name. For interfaces, nm1 and nm2 should be the same.
 */

void yccGenId( ycctx* ctx, yccfp* fp, CONST char* nm1, CONST char* nm2, 
               boolean interface, CONST char* defn)
{
  boolean useGlob = yccUseGlobals( ctx);

  if ( defn )
  {
    if ( !useGlob )
      yccfpPrint( fp, "static ysidDecl(%s___id) = ", nm2);
    else if ( interface )
      yccfpPrint( fp, "%sysidDecl(%s__id) = ", YCCEXDEF(ctx), nm1);
    else
      yccfpPrint( fp, "%sysidDecl(%s) = ", YCCEXDEF(ctx), nm1);
    if ( strlen(defn) > (size_t)70 )    /* too long, use aggregate init */
    {
      yccfpPrint( fp, "\n {\n");
      yccfpIncIndent( fp);
      yccGenStrAsChar( ctx, fp, defn);
      yccfpPrint( fp, " '\\0'\n");
      yccfpDecIndent( fp);
      yccfpPrint( fp, " };\n\n");
    }
    else                                 /* simple quoted string literal */
      yccfpPrint( fp, "\"%s\";\n\n", defn);

    yccfpPrint( fp, "CONST ysid* %s__getId(void)\n{\n", nm2);
    yccfpIncIndent( fp);
    if ( !useGlob )
      yccfpPrint( fp, "return (CONST ysid*)%s___id;\n", nm2);
    else if ( interface )
      yccfpPrint( fp, "return (CONST ysid*)%s__id;\n", nm1);
    else
      yccfpPrint( fp, "return (CONST ysid*)%s;\n", nm1);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "}\n\n");

  }
  else
  {
    yccfpPrint( fp, "CONST ysid* %s__getId(void);\n", nm2);
    if ( !useGlob )
    {
      yccfpStartPP( fp);
      if ( interface )
        yccfpPrint( fp, "#ifndef %s__id\n#define %s__id   (%s__getId())\n", 
                    nm1, nm1, nm2);
      else
        yccfpPrint( fp, "#ifndef %s\n#define %s   (%s__getId())\n", 
                    nm1, nm1, nm2);
      yccfpPrint( fp, "#endif\n");
      yccfpEndPP( fp);
    }
    else if ( interface )
      yccfpPrint( fp, "%sysidDecl(%s__id);\n", YCCEXREF(ctx), nm1);
    else
      yccfpPrint( fp, "%sysidDecl(%s);\n", YCCEXREF(ctx), nm1);
  }
}

/* ------------------------------------------------------------------------ */
/*
 * yccKwdTbl - Table of C and C++ keywords
 *
 * C keywords may be used as identifier in IDL. Where they appear as
 * standalone identifiers in the generated code, they must be preceded
 * with an underscore to prevent C compilation errors. This applies to
 * any IDL id's defined at file scope, as well as field and parameter names.
 *
 * For C++, this behavior is mandated for C++ keywords in the C++ language
 * mapping. The C language mapping doesn't say anything about C keywords,
 * let alone C++, but this is clearly an oversight.
 *
 * We may also care about C++ identifiers if this C code may be included
 * by a C++ program. Rather than suprise your average C programmer by
 * always handling C++ keywords, this behavior is controlled by the
 * resource "mnidlc.c-cplus-kwd". If this is in effect, yccpIsKeyword is
 * used to check for keywords instead of yccIsKeyword.
 *
 * YccIsKeyword uses a binary search, so be sure to keep the table sorted.
 */

static CONST_DATA char* yccKwdTbl[] = 
{
  "auto",
  "break",
  "continue",
  "do",
  "else",
  "extern",
  "for",
  "goto",
  "if",
  "int",
  "register",
  "return",
  "signed",
  "sizeof",
  "static",
  "volatile",
  "while"
};

static CONST_DATA size_t yccKwdCnt = sizeof(yccKwdTbl) / sizeof(char*);

/* ------------------------------------------------------------------------ */
/*
 * yccIsKeyword - Returns TRUE if name signifies a C keyword
 *
 * Simple binary search of the keyword table.
 */
boolean yccIsKeyword( ycctx* ctx, CONST char* name)
{
  CONST char **low; 
  CONST char **mid;
  CONST char **high;
  sword  cmp;
  boolean matched = FALSE;

  /* check for C keywords */
  high = yccKwdTbl + yccKwdCnt;
  low = yccKwdTbl;

  while ( !matched && (low < high) )
  {
    mid = low + (high - low) / 2;
    cmp = strcmp(name, *mid);
    if (cmp < 0)
      high = mid;
    else if (cmp > 0)
      low = mid + 1;
    else
      matched = TRUE;
  }
  return matched;
}


/* ------------------------------------------------------------------------ */
/*
 * yccLangMap - Returns a ycgmap for the C language mapping
 *
 * This is not done with static constant data because the keyword checking
 * callback is determined at runtime, based on whether or not we want to
 * check for C++ keywords.
 */
ycgmap* yccLangMap( ycctx* ctx)
{
  ycgmap* map = (ycgmap*) ysmGlbAlloc( sizeof(ycgmap), "ycgmap");

  CLRSTRUCT(*map);
  map->langid = YCG_C_LANG;
  map->driver = yccmap;

    /***** Set C code gen config flags *****/
  if ( ysResGetBool("mnidlc.c-cplus-kwd") )
    map->flags |= YCCFLG_CPLUS_KWD;
  if ( ysResGetBool("mnidlc.static-typecodes") )
    map->flags |= YCCFLG_STATIC_TC;
  if ( !ysResGetBool("mnidlc.nobuiltin-seq") )
    map->flags |= YCCFLG_BUILTIN_SEQ;
  if ( ysResGetBool("mnidlc.c-global-const") )
    map->flags |= YCCFLG_GLOB_CONST;
  if ( ysResGetBool("mnidlc.c-no-supp") )
    map->flags |= YCCFLG_NO_SUPP_FUNCS;
  if ( ysResGetBool("mnidlc.c-no-async") )
    map->flags |= YCCFLG_NO_ASYNC;

    /***** Deal with keyword callback *****/
  if ( map->flags & YCCFLG_CPLUS_KWD )
    map->kwdchk = yccpIsKeyword;
  else
    map->kwdchk = yccIsKeyword;

  return map;
}

/* ------------------------------------------------------------------------ */

STATICF boolean yccSymFlush( dvoid* usrp, dvoid* elm)
{
  ycsym* sym = (ycsym*)elm;

  if ( sym && sym->lang.c.absnm )
  {
    ysmGlbFree( (dvoid*)sym->lang.c.absnm);
  }
  return TRUE;
}

/* ------------------------------------------------------------------------ */

void yccGenConstVal( ycctx* ctx, yccfp* fp, yrobj* constobj)
{
  dvoid *value;

  value = yrConstData(constobj).val._value;
  switch (yotkGetKind(yrConstData(constobj).val._type))
  {
    case yotkString:
      yccfpPrint(fp, "%s", *((char **) value));
      break;
    case yotkBoolean:
      if ( *(boolean*)value )
        yccfpPrint(fp, "%s", ycStyleOra(ctx) ? "TRUE" : "1");
      else
        yccfpPrint(fp, "%s", ycStyleOra(ctx) ? "FALSE" : "0");
      break;
    case yotkChar:
      yccfpPrint(fp, "'%c'", *((char *) value));
      break;
    case yotkShort:
      yccfpPrint(fp, "%d", *((sb2 *) value));
      break;
    case yotkUshort:
      yccfpPrint(fp, "%u", *((ub2 *) value));
      break;
    case yotkLong:
      yccfpPrint(fp, "%ld", *((sb4 *) value));
      break;
    case yotkEnum:
    case yotkUlong:
      yccfpPrint(fp, "%lu", *((ub4 *) value));
      break;
    default:
      yseThrow(YC_EX_FAILURE);
      break;
    }
}
