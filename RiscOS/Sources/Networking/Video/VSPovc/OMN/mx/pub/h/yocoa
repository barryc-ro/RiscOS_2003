/* Copyright (c) 1995 by Oracle Corporation.  All Rights Reserved.
 *
 * yocoa.h - Oracle OMX Common Object Adapter
 *
 * DESCRIPTION
 * The following routines should be used only by programs which implement
 * objects, also known as servers.  Of course, any program may act as a
 * server.
 */

#ifndef YOCOA_ORACLE
#define YOCOA_ORACLE

#ifndef SYSX_ORACLE
#include <sysx.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif
#ifndef MN_ORACLE
#include <mn.h>
#endif

EXTC_START

/* Exceptions */
externref ysidDecl(YO_EX_DUPLICATE);            /* duplicate entry exception */
externref ysidDecl(YO_EX_STATELESS);    /* specified interface was stateless */

/*
 * yoload - object loader
 *
 * DESCRIPTION
 * An object loader is used by the object layer to activate or deactivate
 * an object.  When an object is being activated, the loader routine for
 * the object's implementation is invoked and passed the object reference.
 * At this time, any state associated with the object may be loaded into
 * memory as the system will guarantee that all subsequent operations on
 * the same object will be routed to the same process until the object is
 * deactivated.  The loader has available to it the reference data in order
 * to determine what to load.  Object activiation is indicated when the
 * activate parameter is TRUE.  If the load fails, FALSE should be returned
 * from the loader; otherwise, TRUE should be returned to indicate success.
 *
 * Any implementation that includes a loader implicitly supports object
 * deactivation and the system may attempt to deactivate the object at
 * various times, including explicit object deactivation and process
 * termination.  The system guarantees that it will call the loader on
 * all activate objects during process termination.  The deactivation
 * may not be refused.  Object deactivation is indicated when the
 * activate parameter is FALSE.
 */
typedef boolean (*yoload)(dvoid *ref, boolean activate);    /* object loader */

/*
 * yoSetImpl - set an implementation
 *
 * DESCRIPTION
 * yoSetImpl() binds an interface to its implementation.  The interface
 * is identified by its tag generated by the IDL compiler with the name
 * <interface>__id.  The implementation is identified by any tag that
 * uniquely identifies the implementation, although it should normally
 * be one that is registered in the implementation repository.  If no
 * implementation id is specified, the program name is used (taken from
 * ysProgName()).
 *
 * An implementation consists of a set of stubs, an implementation
 * dispatch vector, an object adapter, and optionally, a object loader.
 * The elements are explained as follows:
 *
 * stubs is a null-terminated array of server-side stub routines that
 * will be invoked when a request arrives.  These are the skeletons
 * that perform the unmarshalling of the request, make the upcall,
 * and then marshal the results.  The server-side stub routines are
 * generated by the IDL compiler which also generates an array
 * named <interface>__stubs for use here.  Note that the stubs are
 * specific to the interface, not the implementation, and
 * so the same set of stubs may be used for several different
 * implementations to the same interface.
 *
 * The impldef is a structure whose fields point to the actual routines
 * that implement the operations.  The type of the structure is generated
 * by the IDL Compiler as is a default initialization for the structure.
 * This may be modified as necessary to bind different routines to the
 * operation names.  The name of the structure generated is
 * <interface>__impl.
 *
 * loader is the name of the loader function that is to be used during
 * object activation and deactivation of persistent objects.  If no
 * loader is provided, then objects for this implementation must be
 * created during execution and cannot live longer than the process itself.
 *
 * state is a pointer to some optional state information which may be
 * associated with a particular implementation.
 *
 * stateless is a boolean which indicates if the implementation is stateless.
 * If an implementation is stateless, the ORBD will be notified of the
 * existance of the implemenation.  Calling yoGetState() or yoSetState()
 * with a stateless object reference will result in the exception
 * YO_EX_STATELESS.
 */
typedef struct  yostub yostub;                            /* stub descriptor */
typedef struct  yostbb yostbb;
typedef struct  yooad  yooad;                   /* object adapter descriptor */

/* DISABLE check_naming */
struct yostbb
{
  CONST char *opernm;                                      /* operation name */
  yopar *parms;                                     /* parameter description */
  void (*oper)(dvoid *ref, yoenv *ev, dvoid *impldef, dvoid **args); /* oper */
};

struct yostub
{
  yowiden widen;
  const char* const* bases;
  yostbb stuba[1];
};
/* ENABLE check_naming */

void yoSetImpl(CONST ysid *intf, CONST char *impl, yostub *stubs,
               CONST dvoid *impldef, yoload loader, boolean stateless,
	       dvoid *state);

/*
 * yoCreate - create an object
 *
 * DESCRIPTION
 * yoCreate() creates an object.  intf and impl together must define an
 * implementation previously specified with yoSetImpl().  An object
 * reference to the created object is returned.
 *
 * id is a pointer to reference data whose type is sequence<octet>.
 * The id is immutable identification information, chosen by the
 * implementation at object creation time and never changed.  The
 * usage of the id is entirely implementation-defined.  Two objects
 * created with the same id are not the same object as far as the
 * object layer is concerned.  For implementations with loaders,
 * the reference data is made available to the loader to allow
 * the object to be reactivated.  In other words, it persists past
 * the activation (unlike the state).  The id may be null.  If id is
 * non-null, the value is copied into the reference returned.
 *
 * state is a pointer to in-memory state that may be used while
 * the object is active.  This is a convenience for fast access to
 * in-memory information.  For object without loaders, it is usually
 * the primary means to access the state of the object.
 *
 * A created object starts off as an active object.
 */
dvoid *yoCreate(CONST ysid *intf, CONST char *impl, yoRefData *id,
                CONST char *ignored, dvoid *state);

/*
 * yoDispose - destroy an object
 *
 * DESCRIPTION
 * yoDispose() destroys an object.  This may be used even if there are
 * still outstanding references to the object.  These references will
 * no longer be valid.  The object is not deactivated before it is
 * disposed and the object's loader (if any) will not be called.
 */
void yoDispose(dvoid *ref);

/*
 * yoGetId, yoFreeId - reference data
 *
 * DESCRIPTION
 * yoGetId() returns a copy of the reference data (if any) is returned for
 * the given object reference.  The pointer which is returned should be
 * freed using yoFreeId().
 */
yoRefData *yoGetId(CONST dvoid *ref);
void yoFreeId(yoRefData *id);

/*
 * yoGetState, yoSetState - set & get the in-memory state
 *
 * DESCRIPTION
 * Associated with each activated object is some in-memory state.
 * These routines allow a pointer to this state to be retrieved
 * from and set into the object reference.
 */
dvoid *yoGetState(CONST dvoid *ref);
void yoSetState(CONST dvoid *ref, CONST dvoid *state);

/*
 * yoGetImplState - get the implementation state
 *
 * DESCRIPTION
 * This routine allows the implementation state information to be retrieved
 * from the object reference.
 */
dvoid *yoGetImplState(CONST dvoid *ref);

/*
 * yoGetCaller - return an object reference to the caller
 *
 * DESCRIPTION
 * This function returns an opaque object reference which identifies the
 * entity which made the current server call.  This object reference can
 * be passed to yoWatchOwner() to detect client death.
 */
dvoid *yoGetCaller(void);

/*
 * yoQueCreate, yoQueDestroy - create & destroy ysque's for YO
 *
 * DESCRIPTION
 * yoQueCreate() creates a queue for use by several functions defined
 * in this interface file, yoService(), yoShutdown(), yoImplReady(),
 * and yoObjListen().  The forementioned functions require that the ysque
 * passed in was created by yoQueCreate().  The ysque returned is also vaild
 * for use with any of the functions defined in ysv.h which require ysque's.
 *
 * yoQueDestroy() destroys a queue created via yoQueCreate().
 */
ysque *yoQueCreate(CONST char *name);
void yoQueDestroy(ysque *q);

/*
 * yoService, yoThreadService, yoShutdown - begin & end service
 *
 * DESCRIPTION
 * yoService() and yoThreadService() begin servicing incoming
 * implementation/object requests for the specified queue.  If a null queue
 * is specified, the default queue is serviced. As requests come in,
 * they are dispatched to the appropriate methods to implement the requests.
 * yoService() and yoThreadService() block until yoShutdown() is called.
 *
 * yoService() runs completely in the current thread, and is appropriate use
 * in non-threaded programs.
 *
 * yoThreadService() services the queue with multiple threads, the arguments
 * specifying semantics and limits.  On entry, mint threads will be started,
 * each servicing the queue.  Only maxt will ever be allowed to exist.  If
 * maxt is set, deadlocks may occur if all threads are busy waiting for the
 * processing of requests that can't be serviced because there are no
 * threads available.  As each request is about to be serviced, if no more
 * threads are available, and maxt threads don't yet exist, a new thread is
 * started.  This will guarantee an available thread at all times (up to
 * maxt).  As each service completes, each thread sees if keept is exceeded.
 * If so, then that thread exits.  A call with mint = 0 and keept = 0 gives
 * "thread-per-request" semantics.  Calling with mint = X, keept = X, maxt = X
 * gives bounded thread-pool semantics with X threads.
 *
 * yoShutdown() is used to terminate service started with yoService() or
 * yoThreadService(). All unprocessed requests are rejected and no new ones
 * will be accepted.  Active threads are allowed to run to completion.
 * Finally, yoService() will return.  yoService() will also return if there
 * are no active implementations or objects.
 *
 * The queue passed to yoService(), yoThreadService() and yoShutdown() must
 * be created using yoQueCreate().
 */
void yoService(ysque *q);
void yoThreadService(ysque *q, sword mint, sword keept, sword maxt);
void yoShutdown(ysque *q);

/*
 * yoDefQue - get the default queue
 *
 * DESCRIPTION
 * yoDefQue() returns the default queue.  This is the actual queue that
 * is used when a null queue is passed to yoService(), yoShutdown(),
 * yoImplReady(), etc.
 */
ysque *yoDefQue(void);

/*
 * yoImplReady, yoImplDeactive - implementation activation & deactivation
 * yoImplSuspend, yoImplResume - suspend & resume implementation
 *
 * DESCRIPTION
 * yoImplReady() informs the object layer that the server is ready to
 * accept requests for objects based on the given implementation.  No
 * requests can be received or processed by an implementation until this
 * routine has been called.
 * yoImplReady() may be passed a queue onto which dispatch events are
 * posted that will actually cause method invocation to take place when 
 * dequeued.  If no queue is specified, requests are are placed in the default
 * queue which can be serviced by calling yoService with a null queue.
 * Invocations of the loader are also posted to the same queue.  The queue
 * passed to yoImplReady() must have been created by yoQueCreate().
 *
 * yoImplDeactivate() informs the object layer that the server is no
 * longer able to accept requests for objects based on the given
 * implementation.  All active objects of the given type are deactivated
 * and the ORB is not permitted to forward any more calls.  Any pending
 * but unprocessed requests are rejected.
 *
 * yoImplSuspend() suspends the acceptance of operations for the objects
 * of the given implementation.  Any calls forwarded to the server
 * while this operation is suspended are rejected.
 *
 * yoImplResume() resumes the acceptance of operations for objects of
 * the given implementation.
 */
void yoImplReady(CONST ysid *intf, CONST char *impl, ysque *q);
void yoImplDeactivate(CONST ysid *intf, CONST char *impl);
void yoImplSuspend(CONST ysid *intf, CONST char *impl);
void yoImplResume(CONST ysid *intf, CONST char *impl);

/*
 * yoObjListen, yoObjDeactivate - object activation & deactivation
 *
 * DESCRIPTION
 * An object is considered active once the loader for the object
 * completes or after yoCreate() completes.  Once the object is
 * active, it may have method calls dispatched on it.  yoObjListen()
 * allows a queue to be associated with the reference where all
 * invocations are queued for dispatch.  A null queue explicitly
 * causes the invocations to be dispatched on thread yields.  By
 * default, the queue used for dispatch is the same as that given
 * to yoImplReady().  If yoImplReady() was never called for the
 * object's implementation, then the default is a null queue.  The
 * queue passed to yoObjListen() must have been created by yoQueCreate().
 *
 * yoObjDeactivate() is used to explicitly deactivate an object.
 * As long as an object is active, all operations invoked on the
 * object are routed to the same server process.  Once the object
 * is deactivated, it may be reactivated in another server process
 * (depending on the characteristics of the object).  For an object
 * with no loader, yoObjDeactivate() is equivalent to yoDispose().
 */
void yoObjListen(CONST dvoid *ref, ysque *q);
void yoObjDeactivate(dvoid *ref);


/*
 * yodsSetImpl, yodsParams, yodsReturn, yodsException - Dynamic Skeleton
 *
 * DESCRIPTION
 * yodsSetImpl() sets up a DSI implementation taking arguments similar to
 * yoSetImpl().  The impfunc is the DSI dynamic implementation function.
 * This dynamic implementation function is responsible for decoding the
 * requests paramenters using yodsParams() and returning a result via
 * yodsReturn().  Exceptions are returned using either yseThrow() or
 * yodsException().
 *
 */
typedef struct yosreq yosreq;
typedef void (*yodir)(CONST dvoid *ref, yoenv *ev, CONST char *opernm,
		      yosreq *req);

void yodsSetImpl(CONST ysid *intf, CONST char *impl, CONST yodir impfunc,
                 yoload loader, boolean stateless, dvoid *state);
dvoid **yodsParams(yosreq *req, yopar *parms);
void yodsReturn(yosreq *req, dvoid *value, size_t size);
void yodsException(yosreq *req, CONST ysid *exid, dvoid *obj, size_t size);


/*
 * yodsReSendReq, yodsFreeRep, yodsProxyRep - resend a request received via DSI
 *
 * DESCRIPTION
 * yodsReSendReq() resends the request to the specified object.
 * yodsReSendReq() must be called from within a dynamic implementation
 * function. yodsReSendReq() can *not* be called after calling yodsParams().
 * The event will be triggered with a pointer to a yodsrep.  This is a handle
 * to the reply data.  This handle should be freed using yodsFreeReply().
 * yodsProxyRep() can be used to pass the reply from yodsReSendReq() to
 * the client which invoked the dynamic implementation function.
 */
typedef struct yodsrep yodsrep;

void yodsReSendReq(yosreq *req, CONST dvoid *ref, yoenv *ev, ysevt *evt);
void yodsFreeRep(yodsrep *rep);
void yodsProxyRep(yosreq *req, yodsrep *rep);

/*
 * yoimpadm - implementation administrative callback function
 *
 * DESCRIPTION
 * yoimpadm is called whenever the administrative state of an implementation
 * changes.  The implementation is identified by the parameters intf and impl.
 * The stateless parameter is the boolean passed to yoSetImpl.  ostate is the
 * original administrative state.  nstate is the new administrative state.
 * Based on the values of ostate and nstate the callback should do whatever
 * is appropriate/possible to make the requested change in state.  usrp is
 * the user specified pointer passed to yoSetImplAdmCb() when setting the
 * callback for a particular implementation.
 *
 */

#define YOIMPADST_DOWN          0            /* go down as soon as practical */
#define YOIMPADST_RUN           1           /* resume from halt or congested */
#define YOIMPADST_HALTED        2    /* suspend but allow set of admin state */
#define YOIMPADST_CONGESTED     3                 /* pretend to be congested */
#define YOIMPADST_RESTART       4      /* restart from beginning if possible */
#define YOIMPADST_QUIESCE       5      /* process current load, take no more,
                                          go down gracefully */

typedef void (*yoimpadm)(CONST ysid *intf, CONST ysid *impl, boolean stateless,
                         ub4 ostate, ub4 nstate, dvoid *usrp);
/*
 * yoSetImplAdmCb - set implementation administrative callback.
 *
 * DESCRIPTION
 * Sets the administrative callback for a particular implementation.  If
 * yoSetImplAdmCb() is not called for an implementation or called with
 * a null admcb, the default administrative callback is used.
 *
 *The default administrative callback will do the following:
 *
 *      nstate                  Action
 *      YOIMPADST_DOWN          yoImplDeactivate(intf,impl);
 *      YOIMPADST_RUN           yoImplResume(intf,impl);
 *      YOIMPADST_HALTED        <none>
 *      YOIMPADST_CONGESTED     yoImplSuspend(intf,impl);
 *      YOIMPADST_RESTART       <none>
 *      YOIMPADST_QUIESCE       if(stateless) yoImplDeactivate(intf,impl);
 */
void yoSetImplAdmCb(CONST ysid *intf, CONST ysid *impl, yoimpadm admcb,
                    dvoid *usrp);

EXTC_END

#endif /* YOCOA_ORACLE */
