/*   smnudp.c

Purpose : Defines the methods for Oracle Media Net UDP (ie. socket-based)
          Network interface Objects for Risc OS.

Functions : smnudpOpen
            smnudpClose
            smnudpSend
            smnudpRecv
*/

/*#define SMNUDP_DBG*/


#include <kernel.h>
#include <swis.h>

#include <errno.h>
#include <sys/fcntl.h>
#include <sys/types.h>

#ifndef __SYS_TIME__  /* protect from xple inclusion */
#include <sys/time.h>
#endif

#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
/*#include <sys/signal.h>*/
#include <sys/ioctl.h>

#include <sx.h>
#ifndef MN_ORACLE
#include <mn.h>
#endif
#ifndef MNNIO_ORACLE
#include <mnnio.h>
#endif
#ifndef SMN_ORACLE
#include <smn.h>
#endif

#include "smnudp.h"
#include "udpNIO.h"
#include "rosevents.h"
#include "options.h"

/*
 * Routine Declarations
 */
void smnudpClose(mnnio *nio);
static sb4  smnudpSend(mnnio *nio, mnnpa *pa, ub1 *buf, size_t len);
static sb4  smnudpRecv(mnnio *nio, mnnpa *pa, ub1 *buf, size_t len,
                       boolean poll, ub4 timeout);
extern void *module_wsp;  /* defined in modulewrap */
extern int mn_started;

/*
 * UDP Address Family
 * The layout of the UDP address family is as follows:  the first four
 * bytes is the IP address (in network order); the next two bytes is
 * the port number (in network order).
 */
#define FAMILY_NAME  "UDP"
#define smnudpAddr(buf)  *((ub4 *) (buf))
#define smnudpPort(buf)  *((ub2 *) (((ub1 *) (buf)) + 4))

int mnsockid = -1;

/*
 * smnudpOpen - Opens a UDP NIO
 */
mnnio *smnudpOpen(char *name, boolean intr)
{
  mnnio *nio;
  int    fd, len;
  char   buf[128];
  struct sockaddr_in sa;

#ifdef SMNUDP_DBG
    printf("\n\n\n\n\n\n          smnudpopen()!\n");
#endif
  /* initialize the NIO */
  if (!(nio = (mnnio *) malloc(sizeof(mnnio))))
     return (mnnio *) 0;

  nio->pktmax = 4096;
  nio->send = smnudpSend;
  nio->recv = smnudpRecv;
  nio->close = smnudpClose;
  nio->flags = MNNFLG_RECV | MNNFLG_SEND | MNNFLG_CKSM;

  /* open the socket */
  if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
    goto error_return;
  }
  nio->usrp = (void *) fd;
  mnsockid = fd;

  /* increase receive buffer size */
  len = 50000;
  setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &len, sizeof(len));

  if (intr || !name)
      return (mnnio *) 0;

  /* bind the address */
  if (smnudpPa(&nio->pa, name)) {
    goto error_return;
  }

  sa.sin_family = AF_INET;
  sa.sin_addr.s_addr = INADDR_ANY;
  sa.sin_port = smnudpPort(nio->pa.addr);

  if (bind(fd, (struct sockaddr *) &sa, sizeof(struct sockaddr_in)) == -1) {
    goto error_return;
  }

  /* get bound address */

  return nio;

 error_return:
#ifdef SMNUDP_DBG
    printf("\n\n\n\n\n        smnudpopen() error!\n");
#endif
  if (mnsockid != -1) {
      socketclose(mnsockid);
      mnsockid = -1;
  }
  return (mnnio *) 0;
}

/*
 * smnudpPa - converts a text string to a physical address
 */
sb4 smnudpPa(mnnpa *pa, char *name)
{
  char ip[64];
  int  prtno;
  long host;
  struct hostent *he, *gethostbyname();

  /* parse text string */
  if (sscanf(name, "UDP:%[^:]:%d", ip, &prtno) < 2)
    return -1;
  if (isalpha(ip[0]))
    {
      /* search for address by name */
      he = gethostbyname(ip);
      if (!he)
        return -1;
      host = *((long *) he->h_addr_list[0]);
    }
  else
    {
      /* parse IP address */
      host = inet_addr(ip);
      if (host == -1)
      {
        return -1;
      }
    }

  /* build physical address */
  memcpy(pa->family, FAMILY_NAME, 4);
  smnudpAddr(pa->addr) = host;
  smnudpPort(pa->addr) = smnHton2(prtno);
  return 0;
}

void smnudpClose(mnnio *nio)
{
#ifdef SMNUDP_DBG
    printf("\n\n\n\n\n\n        smnudpclose()\n");
#endif
    if (mnsockid != -1) {
        socketclose(mnsockid);
        mnsockid = -1;
    }
    return;
}

/*
 * smnudpSend - Sends data over UDP
 */
static sb4 smnudpSend(mnnio *nio, mnnpa *pa, ub1 *buf, size_t len)
{
  int fd, cnt;
  struct sockaddr_in sa;

  fd = (int) nio->usrp;

  /* create the address */
  sa.sin_family = AF_INET;
  sa.sin_addr.s_addr = smnudpAddr(pa->addr);
  sa.sin_port = smnudpPort(pa->addr);

#ifdef SMNUDP_DBG
printf("smnudpSend: sending %i bytes to socket at %s, %X\n", len, inet_ntoa(sa.sin_addr.s_addr), (int)smnNtoh2(sa.sin_port));
#endif

  /* mnnTrace("SEND", buf, len); */

  cnt = sendto(fd, buf, len, 0,
               (struct sockaddr *) &sa, sizeof(struct sockaddr_in));

#ifdef SMNUDP_DBG
printf("smnudpSend: finished, return value %i\n", cnt);
#endif
  if (cnt == -1) 
    return (MNERR_FAILURE);
  else
    return cnt;
}

/*
 * smnudpRecv - Receives data from UDP
 */
static sb4 smnudpRecv(mnnio *nio, mnnpa *pa, ub1 *buf, size_t len,
                      boolean poll, ub4 timeout)
{
  int fd, cnt, fromlen;
  fd_set fdset;
  struct sockaddr_in from;
  struct timeval to;

  fd = (int) nio->usrp;

  if (poll)
    to.tv_sec = to.tv_usec = 0;
  else if (timeout)
    to.tv_sec = timeout / 1000, to.tv_usec = (timeout % 1000) * 1000;

  FD_ZERO(&fdset);
  FD_SET(fd, &fdset);
  cnt = select(fd+1, &fdset, 0, 0, (poll || timeout ? &to : 0));
  if (cnt == -1)
    return MNERR_FAILURE;
  else if (cnt == 0)
  {
    return (poll ? MNERR_WOULDBLOCK : MNERR_TIMEOUT);
  }
  else
    {
      fromlen = sizeof(struct sockaddr_in);
      cnt = recvfrom(fd, buf, len, 0, (struct sockaddr *) &from, &fromlen);
      if (cnt == -1)
        return MNERR_FAILURE;

#ifdef SMNUDP_DBG
printf("smnudpRecv: received %i bytes of data\n", cnt);
#endif
      /* fill in address and return */
      memcpy(pa->family, FAMILY_NAME, 4);
      smnudpAddr(pa->addr) = from.sin_addr.s_addr;
      smnudpPort(pa->addr) = from.sin_port;
      return (sb4) cnt;
    }
}

int smnudpPoll(mnnio *nio)
{
  int fd, cnt;
  fd_set fdset;
  struct timeval to;

  if (!mn_started)
    ovcabort();
  fd = (int) nio->usrp;
  to.tv_sec = to.tv_usec = 0;
  FD_ZERO(&fdset);
  FD_SET(fd, &fdset);
  cnt = select(fd+1, &fdset, 0, 0, &to);
  return (cnt <= 0 ? 0 : cnt);
}
