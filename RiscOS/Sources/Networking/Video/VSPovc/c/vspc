/*	VSPC.C

Copyright © Acorn Computers Ltd 1998

Purpose: map VSP swis to Oracle Video Server calls

History:

Date      Who     Description of change
===========================================
27/2/97   CP      Inherited sources.

                  Some layout changes to make code more readable

                  Fixed uninitialised error ptr bug in CloseStream()

***************************************************************************/

#include <stdio.h>
#include "types.h"
#include <kernel.h>
#include <swis.h>
#include "vsp.h"
#include "misc.h"

extern _kernel_oserror *ovs_startstream(), *ovs_closestream(), *ovs_playcontrol(), *ovs_jump();
extern _kernel_oserror *ovs_resume(), *ovs_pause();
extern _kernel_oserror *vsp_error();

struct active_play active = { 0 };

extern char *malloc();
extern int mpeg_handle;
extern int current_npt;
extern int endofstream, endofstream_timer, endofstream_timeout;
int last_rxcount = 0;

void reset_eos_timer(void)
{
    endofstream_timer = 0;
    last_rxcount = 0;
    endofstream = 0;
}

int caseless_strcmp(char *a, char *b)
{
    int d;

    while ( *a || *b ) {
        d = toupper( *(a++) ) - toupper( *(b++) );
        if ( d )
            return d;
    }
    return 0;
}

_kernel_oserror *OpenStream(_kernel_swi_regs *r)
{
    _kernel_oserror *err;
    int margc, from, to, loop, frame;
    char *margv[10];
    char *cp;
    char **argp = margv;

    if (active.id != 0)
    {
        r->r[0] = 0;
        return (vsp_error(VSP_E_NOHANDLE));
    }
    margc = 0;
    loop = r->r[0] & 01;
    frame = r->r[0] & 02;
    cp = (char *)r->r[1];
    mpeg_handle = r->r[2];
    from = r->r[4];
    to = r->r[5];
    while (*cp) {
        while (isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *argp++ = cp;
        margc++;
        while (*cp != '\0' && !iscntrl(*cp) && !isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *cp++ = '\0';
    }
    *argp++ = 0;
    err = ovs_startstream(margc, margv, mpeg_handle, loop, frame, from, to);
    r->r[0] = err ? 0 : 1;
    return (err);
}

_kernel_oserror *CloseStream(_kernel_swi_regs *r)
{
    _kernel_oserror *err = NULL;  /* 27/2/98:CP:initialise ptr */

    if (active.id != 0)
    {
        err = ovs_closestream();
    }

    return (err);
}

_kernel_oserror *CheckEndofStream(_kernel_swi_regs *r)
{
    int rxcount;

    if (endofstream_timeout == 0 || active.mode == MODE_PAUSE || endofstream)
    {
        goto out;
    }

    rxcount = mpeg_streamcount(mpeg_handle);
    if (rxcount == -1)
    {
        endofstream = 1;
        goto out;
    }

    if (rxcount > 0)
    {
        if (rxcount > last_rxcount)
        {
            endofstream_timer = 0;
        }
        else
        {
           if (endofstream_timer == 0)
           {
              endofstream_timer = endofstream_timeout;
           }
        }
    }

    last_rxcount = rxcount;

out:
    r->r[0] = endofstream;
    r->r[2] = 0;
    r->r[3] = 0;

    return ((_kernel_oserror *)0);
}

_kernel_oserror *SetSpeed(_kernel_swi_regs *r)
{
    if (active.id != 0)
        (void) ovs_playcontrol(r->r[0], r->r[2]);
    return (0);
}

_kernel_oserror *SetPosition(_kernel_swi_regs *r)
{
    if (active.id != 0)
        (void) ovs_jump(r->r[0], r->r[2]);
    return (0);
}

_kernel_oserror * ReadNPT(_kernel_swi_regs *r)
{
    if (active.id != 0) {
        current_npt = read_pos();
        r->r[0] = current_npt;
    }
    else
        r->r[0] = -1;
    return ((_kernel_oserror *)0);
}

_kernel_oserror *SetServer(_kernel_swi_regs *r)
{
    return ((_kernel_oserror *)0);
}
