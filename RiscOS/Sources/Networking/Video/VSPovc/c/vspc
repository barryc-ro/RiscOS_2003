/*	VSPC.C

Copyright © Acorn Computers Ltd 1998

Purpose: map VSP swis to Oracle Video Server calls

History:

Date      Who     Description of change
===========================================
27/2/97   CP      Inherited sources.

                  Some layout changes to make code more readable

                  Fixed uninitialised error ptr bug in CloseStream()

25/8/98   CP      Fixed some prototyipng on standard libraries!

26/8/98   CP      Fixed problem with using signed ints to measure MPEG data
                  received.

***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "debug.h"

#include "sys/types.h"
#include <kernel.h>
#include <swis.h>
#include "vsp.h"
#include "misc.h"

/* exports from other C files */
#include "vspc.h"
#include "mzswrap.h"
#include "module.h"


struct active_play active = { 0 };

static int last_rxcount = 0;

void reset_eos_timer(void)
{
    endofstream_timer = 0;
    last_rxcount = 0;
    endofstream = 0;
}

int caseless_strcmp(char *a, char *b)
{
    int d;

    while ( *a || *b ) {
        d = toupper( *(a++) ) - toupper( *(b++) );
        if ( d )
            return d;
    }
    return 0;
}

_kernel_oserror *OpenStream(_kernel_swi_regs *r)
{
    _kernel_oserror *err;
    int margc, from, to, loop, frame;
    char *margv[10];
    char *cp;
    char **argp = margv;

    if (active.id != 0)
    {
        r->r[0] = 0;
        return (vsp_error(VSP_E_NOHANDLE));
    }
    margc = 0;
    loop = r->r[0] & 01;
    frame = r->r[0] & 02;
    cp = (char *)r->r[1];
    mpeg_handle = r->r[2];
    from = r->r[4];
    to = r->r[5];
    while (*cp) {
        while (isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *argp++ = cp;
        margc++;
        while (*cp != '\0' && !iscntrl(*cp) && !isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *cp++ = '\0';
    }
    *argp++ = 0;
    err = ovs_startstream(margc, margv, mpeg_handle, loop, frame, from, to);
    r->r[0] = err ? 0 : 1;
    return (err);
}

_kernel_oserror *CloseStream(_kernel_swi_regs *r)
{
    _kernel_oserror *err = NULL;  /* 27/2/98:CP:initialise ptr */

    if (active.id != 0)
    {
#if !defined(NDEBUG) && defined(EOS)
       SetSystemVariable("OVCdebug$close", "ovs_closestream called from SWI");
#endif
        err = ovs_closestream();
    }

    return (err);
}

_kernel_oserror *CheckEndofStream(_kernel_swi_regs *r)
{
    int rxcount;

    if (endofstream_timeout == 0 || active.mode == MODE_PAUSE || endofstream)
    {
        goto out;
    }

    rxcount = mpeg_streamcount(mpeg_handle);
    if (rxcount == -1)
    {
#if !defined(NDEBUG) && defined(EOS)
      SetSystemVariable("OVCdebug$EOSerror", "rxcount == -1");
#endif
        endofstream = 1;
        goto out;
    }

    if ( 0 != (rxcount - last_rxcount) ) /* note this copes with signed ints when they wrap around!! */
    {
       endofstream_timer = 0;
    }
    else
    {
       if (endofstream_timer == 0)
       {
          endofstream_timer = endofstream_timeout;
       }
    }


    last_rxcount = rxcount;

out:
    r->r[0] = endofstream;
    r->r[2] = 0;
    r->r[3] = 0;

    return ((_kernel_oserror *)0);
}

_kernel_oserror *SetSpeed(_kernel_swi_regs *r)
{
    if (active.id != 0)
        (void) ovs_playcontrol(r->r[0], r->r[2]);
    return (0);
}

_kernel_oserror *SetPosition(_kernel_swi_regs *r)
{
    if (active.id != 0)
        (void) ovs_jump(r->r[0], r->r[2]);
    return (0);
}

_kernel_oserror * ReadNPT(_kernel_swi_regs *r)
{
  char buffer[32];

    if (active.id != 0)
    {
        current_npt = read_pos();
        r->r[0] = current_npt;

        sprintf(buffer, "%u", current_npt);
        SetSystemVariable("OVCdebug$lastNPT", buffer);
    }
    else
    {
        r->r[0] = -1;
    }

    return ((_kernel_oserror *)0); /* never error */
}

_kernel_oserror *SetServer(_kernel_swi_regs *r)
{
    return ((_kernel_oserror *)0);
}
