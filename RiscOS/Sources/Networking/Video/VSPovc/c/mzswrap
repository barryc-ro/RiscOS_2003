/*	MZSWRAP.C

Copyright © Acorn Computers Ltd 1998

History:

Date      Who     Description of change
===========================================
27/2/98   CP      Source inherited.
                  Version released SysEnv 1.06

                  Changed all function declarations to be ANSI.
                  Some layout things to make source more readable.

                  Fixed input parameter in call to ovs_error in function
                  ovs_startstream.  Because it isn't properly prototyped, 2
                  parameters were being allowed to be passed!!

6/10/98   SC      Fixed duplicate name problem (fix donated by Carl).

***************************************************************************/

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif /* !SYSI_ORACLE */

#ifndef YS_ORACLE
#include <ys.h>
#endif

#ifndef MZCCH_IDL
#include <mzcch.h>    /* channel interface */
#endif

#ifndef MZC_IDL
#include <mzc.h>      /* circuit interface */
#endif

#ifndef MZZCH_IDL
#include <mzz.h>      /* session interface */
#endif

#ifndef MKD_IDL
#include <mkd.h>
#endif

#ifndef MKDC_IDL
#include <mkdc.h>     /* C constants for mkd */
#endif

#ifndef MZALGCTN_IDL
#include <mzalgctn.h>           /* logical content datatypes */
#endif

#ifndef MZS_IDL
#include <mzs.h>
#endif

#ifndef MZSCL_IDL
#include <mzscl.h>
#endif

#include "vsp.h"
#include "misc.h"
#include <time.h>
#include <kernel.h>
#include <swis.h>

extern _kernel_oserror *ovs_play(void);
extern _kernel_oserror *ovs_error(int); /* corrected prototype */
extern _kernel_oserror *vsp_error();
extern _kernel_oserror *ovs_closestream(void);
extern _kernel_oserror *ovs_playcontrol(int val0, int val);

extern struct active_play active;
extern int mpeg_handle, turnsoundbackon, turnsoundbackon_timer;
extern char *strchr();
extern void ovs_npt(void);
extern int currentop;
extern int boottime;
extern int endofstream, mn_started, mnidle_timer;
extern int endofstream_timeout;
extern char mpeg_vs_pvc[16];
extern char destadr[128];
extern char gw_phy_adr[64];
extern char dflt_gw_phy_adr[64];
extern int ovs_vsscan_rate;
extern int ovs_slomo_rate;

int playrate = 0;
int current_npt = 0;
int start_npt = 0;
int new_npt = 0;
int session_is_established = 0;
int is_dumpmode = 0;
int callb_init = 0;

extern int udpport;
extern int endofstream;
char cidbuffer[64];

mzs_stream           streamRef;        /* object reference from server */
mzs_stream_instance  streamInst;       /* And it's instantiation */
mkd_assetCookie      streamId;         /* stream id of the stream */
mzs_factory          mzsRef;
ub4                  asset_bitrate;
ub4                  asset_len;
yoenv                evs;              /* yo environment variable */
mzz_session          ses;
mkd_segInfoList      status;
mzc_circuit          dcirc;
mkd_pos              mkdCur;
mkd_pos              mkdBegin;
mkd_pos              mkdFinish;
mkd_pos              mkdSkip;
mza_LgCtntMgmt       fobj;

/*
 * ovsdemoQuery - query the content service to get an asset cookie
 *
 * fobj     is the obj reference of the content service (IN)
 * env      is the active environment (INOUT)
 * file     is the name of the requested file (IN)
 * tagfile  is this for a tagfile or some other kind of content (IN)
 * cookie   is the returned asset cookie (OUT)
 * bitrate  is the bitrate of the returned cookie (if applicable) (OUT)
 *
 * return TRUE if query succeeded and matched one file; FALSE otherwise
 */
static boolean ovsQuery( mza_LgCtntMgmt fobj, yoenv *env, const char *file,
                             boolean tagfile, mkd_assetCookie *cookie,
                             ub4 *bitrate, ub4 *len)
{
    mza_LgCtntAtrLst listings;
    mza_Itr itr;
    boolean err = FALSE;
    int i;

    itr.Position = 0;
    itr.NumItems = 1;
    currentop = 1;

    listings = mza_LgCtntMgmt_lstAtrByNm( fobj, env, (char *)file, tagfile, &itr );

    /* check to make sure we only retrieved one match */
    if (listings._length == 0)
        return FALSE;
    /* This should never happen since we only asked for 1 */
    if (listings._length > 1)
        return FALSE;
    /* This should never happen since we only asked for 1 */
    if (listings._buffer[0].numClips == 0 )
        return FALSE;
    *cookie = (mkd_assetCookie) ysStrDup( listings._buffer[0].cookie );
    *bitrate = listings._buffer[0].maxRate;
    *len = listings._buffer[0].msecs / 1000;
    mza_LgCtntAtrLst__free( &listings, yoFree );
    return TRUE;
}

void setposition(mkd_pos *pos, int newsecs)
{
/* works out a new position based on seconds from start ? */
    int hours, mins, secs;

    secs = newsecs;
    hours = 0; mins = 0;

    while (secs >= SECONDS_PER_HOUR)
    {
        secs -= SECONDS_PER_HOUR;
        hours++;
    }

    while (secs >= SECONDS_PER_MINUTE)
    {
        secs -= SECONDS_PER_MINUTE;
        mins++;
    }

    pos->_d                                      = mkd_posTypeTime;
    pos->_u.mkd_posTimePos.mkd_posTimeHour       = (ub4)hours;
    pos->_u.mkd_posTimePos.mkd_posTimeMinute     = (ub1)mins;
    pos->_u.mkd_posTimePos.mkd_posTimeSecond     = (ub1)secs;
    pos->_u.mkd_posTimePos.mkd_posTimeHundredth  = (ub1)0;
}

int prtime(char *s, int timenow)
{
    int hours, mins, secs;

    secs = timenow;
    hours = 0; mins = 0;

    while (secs >= SECONDS_PER_HOUR) {
        secs -= SECONDS_PER_HOUR;
        hours++;
    }
    while (secs >= SECONDS_PER_MINUTE) {
        secs -= SECONDS_PER_MINUTE;
        mins++;
    }
    sprintf(s, "%d:%d:%d", hours, mins, secs);
    return (1);
}

initposition(mkd_pos *pos, int ptype)
{
    switch (ptype) {
        case 0:
            pos->_d = mkd_posTypeTime;
            break;
        case 1:
            pos->_d = mkd_posTypeBeginning;
            break;
        case 2:
            pos->_d = mkd_posTypeEnd;
            break;
        case 3:
            pos->_d = mkd_posTypeCurrent;
            break;
    }
    pos->_u.mkd_posTimePos.mkd_posTimeHour       = (ub4)0;
    pos->_u.mkd_posTimePos.mkd_posTimeMinute     = (ub1)0;
    pos->_u.mkd_posTimePos.mkd_posTimeSecond     = (ub1)0;
    pos->_u.mkd_posTimePos.mkd_posTimeHundredth  = (ub1)0;
}

/*ARGS_USED*/
void ovs_callbackhandler(dvoid  *argv, mzs_notify reason)
{
    endofstream = 1;
}

_kernel_oserror *ovs_startstream(int argc, char **argv, int handle, int loop, int ogf, int from, int to)
{
    int                i, err = 0;
    char               *name, *d;
    mzs_network        netErr;
    mzc_commProperty   props, props1;
    mzz_factory        zfac;
    mzs_factory        sfac;
    mzc_cktspec        spec[2];
    mzc_cktspecs       specs;
    mzc_clientDeviceId cid;
    mzc_circuit        *ckt;
    mkd_assetCookie    cookie;
    mkd_segInfo        *seginfo;
    boolean            sts;
    mzs_capMask        playcapabilities;
    char               ipadr[32];
    char               udpadr[64];
    char               tbuf[96];
    int                prtno;
    int                skipcnt = 0;

    if (ogf)
        skipcnt = MktGenHdrLen;

    name = argv[0];
    is_dumpmode = 0;
    gw_phy_adr[0] = 0;
    for (i = 1; i < argc; i++) {
        if (caseless_strcmp(argv[i], "-server") == 0 && ++i < argc) {
            if (caseless_strcmp(argv[i], "continuous") == 0) {
                is_dumpmode = 1;
                (void) ovs_playcontrol_init();
                ovs_initmpegpvc();
                ovs_initstream(handle, skipcnt);
                return (ovs_error(0));  /* 27feb98:CP:fixed input parameter mismatch */
            }
            else {
                strcpy(gw_phy_adr, "UDP:");
                strcat(gw_phy_adr, argv[i]);
            }
        }
    }
    if (name[0] == '/' && name[1] == '/' && (d = strchr(&name[2], '/')) != 0) {
        *d = 0;
        strcpy(gw_phy_adr, "UDP:");
        strcat(gw_phy_adr, &name[2]);
        *d = '/';
        name = d;
    }
    if (gw_phy_adr[0] == 0)
        strcpy(gw_phy_adr, dflt_gw_phy_adr);

    /* initialise MediaNet environment */
    set_watchdog_timer();
    Fire_Up_MediaNet();
    clr_watchdog_timer();
    if (mn_started)
        mnidle_timer = MNIDLE_TIMEOUT;
    set_watchdog_timer();

    /* initialise ORB environment */
    yoEnvInit(&evs);
    /*
     * query the content service to get the asset cookie and segment info
     * corresponding to the requested video tag file
     */
    fobj = (mza_LgCtntMgmt) yoBind( mza_LgCtntMgmt__id, (char *)0, (yoRefData *)0, (char *)0);
    sts = ovsQuery( fobj, &evs, name, TRUE, &cookie, &asset_bitrate, &asset_len);
    yoRelease ((dvoid *)fobj);
    if (sts == FALSE) {
         err = 1;
         yoEnvFree(&evs);
         goto out;
    }
     /* construct a control circuit address */
    read_sysvar("OMN_ADDR", udpadr, sizeof(udpadr));
    sscanf(udpadr, "UDP:%[^:]:%d", ipadr, &prtno);
    (void) read_my_ip_address(ipadr);
    sprintf(udpadr, "%s:%d", ipadr, prtno);

    /* Build a client unique id from hostname and time */
    /*
     * Bodged to use Inet$LocalAddr and "STB" to test for *
     * possible name clash problem - CE 1/10/98           *
     * Would be preferable to specifically use IP address *
     * rather than relying upon a variable defined for    *
     * use of Freeway etc.                                *
     */
    read_sysvar("Inet$LocalAddr", cidbuffer+3, sizeof(cidbuffer)-3);
    cidbuffer[0] = 'S';
    cidbuffer[1] = 'T';
    cidbuffer[2] = 'B';

    cid._maximum = cid._length = strlen(cidbuffer) + 1;
    cid._buffer = (ub1 *)cidbuffer;

    /* build control circuit for session - a persistant point-to-point
     * bidirectional channel
     */
    props = mzc_propPersistantConnect | mzc_propDown | mzc_propUp |
                               mzc_propPointcast | mzc_propControl;

    spec[0]._d = mzc_cktspecTypeRequest;
    spec[0]._u.req._d = mzc_cktreqTypeSymmetric;
    spec[0]._u.req._u.sym.props = props;
    spec[0]._u.req._u.sym.chnl._d = mzc_chnlspecTypeRequest;
    spec[0]._u.req._u.sym.chnl._u.req.props = props;
    spec[0]._u.req._u.sym.chnl._u.req.protocol.name = "UDP";
    spec[0]._u.req._u.sym.chnl._u.req.protocol.info = udpadr;
    spec[0]._u.req._u.sym.chnl._u.req.bitrate = 0;
    currentop = 2;

    /* build data circuit - asymmetric persistant point-to-point
     * downstream-only real time channel from the video pump to the stb
     */
    sprintf(udpadr, "%s:%d", ipadr, udpport);

    props1 = mzc_propPersistantConnect | mzc_propDown | mzc_propData |
            mzc_propIsochronousData | mzc_propPointcast;
    spec[1]._d = mzc_cktspecTypeRequest;
    spec[1]._u.req._d = mzc_cktreqTypeAsymmetric;
    spec[1]._u.req._u.asym.props = props1;
    spec[1]._u.req._u.asym.upchnl._d = mzc_chnlspecTypeNone;
    spec[1]._u.req._u.asym.upchnl._u.none = 0;
    spec[1]._u.req._u.asym.downchnl._d = mzc_chnlspecTypeRequest;
    spec[1]._u.req._u.asym.downchnl._u.req.props = props1;
    spec[1]._u.req._u.asym.downchnl._u.req.bitrate = asset_bitrate;
    if (destadr[0] != 0) {
        strcpy(tbuf, destadr);
        d = strchr(tbuf, ':');
        *d++ = 0;
        spec[1]._u.req._u.asym.downchnl._u.req.protocol.name = tbuf;
        spec[1]._u.req._u.asym.downchnl._u.req.protocol.info = d;
    }
    else {
        spec[1]._u.req._u.asym.downchnl._u.req.protocol.name = "UDP";
        spec[1]._u.req._u.asym.downchnl._u.req.protocol.info = udpadr;
    }
    specs._maximum = specs._length = 2;
    specs._buffer = &spec[0];

    /* bind to session factory, then
     * allocate session
     */

    zfac = (mzz_factory) yoBind(mzz_factory__id, (char *)0, (yoRefData *)0, (char *)0);
    ses = mzz_factory_AllocateSessionEx(zfac, &evs, mzz_sessNull, &cid, &specs);
    ckt = &(ses.info.circuits._buffer[1]);
    yoRelease((dvoid *)zfac);

    session_is_established = 1;

    /* bind to stream factory, then allocate stream */

    playcapabilities = mzs_capAudio | mzs_capVideo | mzs_capSeek | mzs_capMpeg1 | mzs_capMpeg2 |
                       mzs_capPause | mzs_capScan | mzs_capSkip;

    currentop = 4;
    sfac = (mzs_factory) yoBind(mzs_factory__id, (char *)0, (yoRefData *)0, (char *)0);
    streamRef = mzs_factory_alloc(sfac, &evs, ckt, playcapabilities, asset_bitrate);
    yoRelease((dvoid *)sfac);

    current_npt = 0;
    new_npt = -1;
    ovs_initmpegpvc();
    ovs_initstream(handle, skipcnt);

    /* prepare stream to play from start_point to end_point at the given bitrate.
     * playNow starts the movie immediately
     */
    if (from > 1000) {
        from = from / 1000;
        setposition(&mkdBegin, from);
        start_npt = from;
    }
    else
        initposition(&mkdBegin, 1);
    if (to > 1000) {
        to = to / 1000;
        setposition(&mkdFinish, to);
        if (to < asset_len)
            asset_len = to;
    }
    else
        initposition(&mkdFinish, 2);
    initposition(&mkdCur, 3);
    currentop = 5;

    streamInst = mzs_stream_prepare(streamRef, &evs, cookie,
                        (mkd_pos *)&mkdBegin,
                        (mkd_pos *)&mkdFinish,
                        asset_bitrate,
                        loop ? (mzs_stream_playLoop | mzs_stream_playNow) : mzs_stream_playNow,
                        &status,
                        (dvoid *)0);
    /* throw away the status info */
    mkd_segInfoList__free (&status, yoFree);

    if (endofstream_timeout == 0) {
        mzscl_stream_cliInit();
        mzscl_stream_setCallback(streamRef, &evs, (mzs_stream_cliCallbackHdlr)ovs_callbackhandler, (dvoid *)0);
    }

    (void) ovs_playcontrol_init();
    currentop = 6;
out:
    return (ovs_error(err));
}

_kernel_oserror *ovs_closestream(void)
{
    active.id = 0;
    playrate = 0;
    current_npt = 0;
    new_npt = -1;

    if (is_dumpmode)
    {
        return ((_kernel_oserror *)0);
    }

    if (session_is_established)
    {
        session_is_established = 0;

        if (streamRef)
        {
            if (endofstream_timeout == 0)
            {
                mzscl_stream_removeCallback(streamRef, &evs);
                mzscl_stream_cliTerm();
            }
            yoRelease((dvoid *)streamRef);
        }
        mzz_ses_Release(ses.or, &evs);
        mzz_session__free(&ses, yoFree);
        yoEnvFree(&evs);
    }

    streamInst = (mzs_stream_instance)0;
    streamRef = (mzs_stream)0;
    endofstream = 1;
    (void) Close_Down_MediaNet();
    reset_eos_timer();

    return ((_kernel_oserror *)0);
}

/*ARGS_USED*/
_kernel_oserror *ovs_resume(void)
{
   reset_eos_timer();


   yseTry  /* weird C++ lookalike exception handling! */
   {
      if (active.mode == MODE_PAUSE)
      {
          mzs_stream_playFwd( streamRef,
                             &evs,
                              streamInst,
                  (mkd_pos *)&mkdCur,
                  (mkd_pos *)&mkdFinish);
      }
      else
      {
printf("ovs_resume from %i:%i:%i\n", mkdSkip._u.mkd_posTimePos.mkd_posTimeHour, mkdSkip._u.mkd_posTimePos.mkd_posTimeMinute, mkdSkip._u.mkd_posTimePos.mkd_posTimeSecond);
          mzs_stream_play( streamRef,
                          &evs,
                           streamInst,
               (mkd_pos *)&mkdCur,     /* current position */
               (mkd_pos *)&mkdSkip,    /* play from */
                           playrate < 0 ? &mkdBegin : &mkdFinish,  /* play until */
                           playrate,
                           asset_bitrate);
      }
   }

   yseCatchAll
   {
      yslError("ovs_resume: exception caught resuming video: %s\n", ysidToStr(yseExid));
   }
   yseEnd;

   return ((_kernel_oserror *)0);
}

_kernel_oserror *ovs_pause(void)
{
    mzs_stream_pause(streamRef, &evs, streamInst, (mkd_pos *)&mkdCur);
    reset_eos_timer();
    return ((_kernel_oserror *)0);
}

_kernel_oserror *ovs_jump(int direction, int position)
{
    if (is_dumpmode || !session_is_established)
    {
        return ((_kernel_oserror *)0);
    }

    switch (direction)
    {
        case 0:
            new_npt = position;
            break;
        case 1:
            new_npt = current_npt + position;
            break;
        case 2:
            new_npt = current_npt - position;
            break;
       default:
            return ((_kernel_oserror *)0);
    }

    if (new_npt > (asset_len - 5))
    {
        new_npt = asset_len - 5;
    }

    else
    {
       if (new_npt < 0)
       {
          new_npt = 0;
       }
    }

    return ((_kernel_oserror *)0);
}

int ovs_playcontrol_init(void)
{
    reset_eos_timer();
    active.id = 1;
    active.mode = MODE_NORMAL;
    playrate = OVS_NORMAL_RATE;
    return (1);
}

/******* ovs_playcontrol **************************************************

Purpose: Controls playback mode

Inputs: do_fast_scan (R0)
        val (R2)

From VSP spec:

         R0   R2
	 0    0    Pause
	 0    1    Play
	 0   2-8   1/2 to 1/8 slow motion

	 1    1    FF scan (modulus of R2 is the requested speed)
	 1   -1    RWD scan


Outputs: None (never generates an error, always returns NULL)

***************************************************************************/

_kernel_oserror *ovs_playcontrol(int do_fast_scan, int val)
{
    if (is_dumpmode || !session_is_established)
        return ((_kernel_oserror *)0);

    if (do_fast_scan) /* FAST SCAN */
    {
        current_npt = read_pos() + 2;
        setposition(&mkdSkip, current_npt);
        playrate = (val > 0) ? ovs_vsscan_rate : -ovs_vsscan_rate;
        active.mode = MODE_NORMAL;
        (void) ovs_resume();
        return ((_kernel_oserror *)0);
    }

    if (val == 0)  /* PAUSE */
    {
        playrate = OVS_NORMAL_RATE;
        active.mode = MODE_PAUSE;
        (void) ovs_pause();
        return ((_kernel_oserror *)0);
    }

/* NORMAL PLAY/SLOWMO */

   /* if npt is different from current position, jump */

/* 13may98:CP:WTF is new_npt being set???!!! */

    if (new_npt != -1)
    {
        current_npt = new_npt;
        new_npt = -1;
    }

   /* otherwise,
          if paused, then resume play and return
          otherwise, set current position slightly beyond current position
   */
    else
    {
        if (active.mode == MODE_PAUSE)
        {
            (void) ovs_resume();
            active.mode = MODE_NORMAL;
            return ((_kernel_oserror *)0);
        }
        else
        {
            current_npt = read_pos() + 2;
        }
    }

    setposition(&mkdSkip, current_npt);

/* 13may98:CP:MUST BE TRUE!! If val == 0, then routine has exited earlier! */
    if (val == 1)
    {
        playrate = OVS_NORMAL_RATE;
    }
    else /* can never do this! */
    {
        playrate = (val > 0) ? ovs_slomo_rate : -ovs_slomo_rate;
    }

    active.mode = MODE_NORMAL;
    (void) ovs_resume();

    return ((_kernel_oserror *)0);
}

int read_pos(void)
{
    mkd_pos pos;
    mzs_state status;
    sb4 rate;
    int npt = 0;

    pos = mzs_stream_getPos(streamRef, &evs, streamInst, &status, &rate);

    if (status != mzs_statePause && status != mzs_stateStream)
    {
        endofstream = 1;
        return (0);
    }

    if (pos._u.mkd_posTimePos.mkd_posTimeHour > 0)
    {
        npt += pos._u.mkd_posTimePos.mkd_posTimeHour * SECONDS_PER_HOUR;
    }

    if (pos._u.mkd_posTimePos.mkd_posTimeMinute > 0)
    {
        npt += pos._u.mkd_posTimePos.mkd_posTimeMinute * SECONDS_PER_MINUTE;
    }

    npt += pos._u.mkd_posTimePos.mkd_posTimeSecond;
    return (npt);
}

/******* local_npt  ********************************************************

Purpose: keeps count of local time.  Called on TickerV (every 1 cs)

Inputs: none

Outputs: increments the global variable current_npt

***************************************************************************/

void local_npt(void)
{
    if (streamInst != 0 && active.mode != MODE_PAUSE)
    {
        current_npt++;
    }
}
