/*	MZSWRAP.C

Copyright © Acorn Computers Ltd 1998

History:

Date	  Who	  Description of change
===========================================
27/2/98	  CP	  Source inherited.
		  Version released SysEnv 1.06

		  Changed all function declarations to be ANSI.
		  Some layout things to make source more readable.

		  Fixed input parameter in call to ovs_error in function
		  ovs_startstream.  Because it isn't properly prototyped, 2
		  parameters were being allowed to be passed!!

28/8/98	  CP	  Made NPTs unsigned to avoid wraparound

		  Fixed bug in pause behaviour.

		  Added code to estimate how stale the NPT from the MPEG module
		  is.  Basically, module will now compare the time received from
		  the MPEG to where it thinks it is in the stream. If they don't
		  match fairly closely, then it will use its internal estimate.
		  Note that this is only used when switching from 1x 'normal'
		  play to a trickplay mode.  This is because the problem is due
		  to normal streams not necessarily carrying sufficient PMTs
		  (holding NPT info) to provide accurate timing information.  So
		  everything resyncs when switching between other modes.

28/8/98    CP     Removed error printfs caused by 'no NPT' error from
                  MPEGControl_Stats.

                  Changed way that code changes from pause mode.  If going from
                  pause to previous mode, it will start from previously logged
                  position (mkd_Cur) which suppresses the GDF transmission, and
                  causes a smooth transition.  If going to a different mode,
                  then it will estimate its position in the normal way.

1/10/98    CP/CE  Changed STB unique ID from being <hostname><time> to being
                  STB<ipaddress> (eg. STB5320aa88).  This fixes a potential bug
                  caused by name duplication in the name.

20/10/98   CP     Modified to use OLD read_pos() if necessary so that it can be
                  integrated with older baselines (eg. Elmsdale).

                  Removed a watchdogtimer start which doesn't have a matching stop.

4jan98    CP      Changed input parameter of initposition() to take an
                  enumerated value (to clarify calls, and catch duff values -
                  bad values will show as warnings at compile times).

                  Added the value DEFAULTSTART to initposition().

18jan99   CP      Definition of callback handler no longer dependent on the
                  timeout being zero (there's no guarantee that we will get a
                  callback in the case of a catastrophic server failure, so we
                  need the timeout too!).

3feb99    CP      Fixed (badly...) a bug in logic when switching to trickplay -
                  a parameter was being left as 'default'.  Should really define
                  constants for such goodies as positions beginning, end,
                  default etc etc.

4feb99     CP     Made use of MediaNet callbacks conditonal on USE_MN_CALLBACKS
                  (default behaviour is to see if EOS timeout is set to 0)

5mar99     CP     Added missing mzs_stream_finish() call to ovs_closestream().
                  This effectively  'unprepares' the video.  Strictly, it's not
                  necessary, but it is good manners on the part of the client to
                  call it!

15mar99    CP     Changed structure of estimation used to ensure NPTs are not
                  stale so that ReadNPT can use same approach.

***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#ifndef SYSI_ORACLE
#include <sysi.h>
#endif /* !SYSI_ORACLE */

#ifndef YS_ORACLE
#include <ys.h>
#endif

#ifndef MZCCH_IDL
#include <mzcch.h>    /* channel interface */
#endif

#ifndef MZC_IDL
#include <mzc.h>      /* circuit interface */
#endif

#ifndef MZZCH_IDL
#include <mzz.h>      /* session interface */
#endif

#ifndef MKD_IDL
#include <mkd.h>
#endif

#ifndef MKDC_IDL
#include <mkdc.h>     /* C constants for mkd */
#endif

#ifndef MZALGCTN_IDL
#include <mzalgctn.h>		/* logical content datatypes */
#endif

#ifndef MZS_IDL
#include <mzs.h>
#endif

#ifndef MZSCL_IDL
#include <mzscl.h>
#endif

#include "mkd.h"

#include "vsp.h"
#include "misc.h"
#include <time.h>
#include <kernel.h>
#include <swis.h>

#include "mpegctrl.h"

/* exports from the other files */
#include "mzswrap.h"
#include "vspc.h"
#include "module.h"

#include "debug.h"

/* imports */
extern void Fire_Up_MediaNet(void);
extern int mn_started;
extern int sshutdown;

/* global variables */
unsigned int mzswrap_CurrentNPT = 0; /* current video position in seconds */


/* statics */
static int static_PreviousPlayRate = 0;
static int static_playrate = 0;
static int start_npt = 0;
static int new_npt = 0;
static int session_is_established = 0;
static int is_dumpmode = 0;
/*static int callb_init = 0;*/

static char cidbuffer[64];

static mzs_stream	    streamRef;	      /* object reference from server */
static mzs_stream_instance  streamInst;	      /* And it's instantiation */
static ub4		    asset_bitrate;
static ub4		    asset_len;
static yoenv		    evs;	      /* yo environment variable */
static mzz_session	    ses;
static mkd_segInfoList	    status;
static mzc_circuit	    dcirc;
static mkd_pos		    mkdCur;
static mkd_pos		    mkdBegin;
static mkd_pos		    mkdFinish;
static mkd_pos		    mkdSkip;
static mza_LgCtntMgmt	    fobj;


enum Position {TIME, BEGINNING, END, CURRENT, DEFAULTSTART};


#define MAXTIMINGERROR 5    /* maximum tolerable difference between STB and MPEG
			       stream timing.  Used to estimate how stale the
			       MPEG NPT really is (in seconds)*/

/*
 * ovsdemoQuery - query the content service to get an asset cookie
 *
 * fobj	    is the obj reference of the content service (IN)
 * env	    is the active environment (INOUT)
 * file	    is the name of the requested file (IN)
 * tagfile  is this for a tagfile or some other kind of content (IN)
 * cookie   is the returned asset cookie (OUT)
 * bitrate  is the bitrate of the returned cookie (if applicable) (OUT)
 *
 * return TRUE if query succeeded and matched one file; FALSE otherwise
 */
static boolean ovsQuery( mza_LgCtntMgmt fobj, yoenv *env, const char *file,
			     boolean tagfile, mkd_assetCookie *cookie,
			     ub4 *bitrate, ub4 *len)
{
    mza_LgCtntAtrLst listings;
    mza_Itr itr;

    itr.Position = 0;
    itr.NumItems = 1;
    currentop = 1;

    listings = mza_LgCtntMgmt_lstAtrByNm( fobj, env, (char *)file, tagfile, &itr );

    /* check to make sure we only retrieved one match */
    if (listings._length == 0)
	return FALSE;
    /* This should never happen since we only asked for 1 */
    if (listings._length > 1)
	return FALSE;
    /* This should never happen since we only asked for 1 */
    if (listings._buffer[0].numClips == 0 )
	return FALSE;
    *cookie = (mkd_assetCookie) ysStrDup( listings._buffer[0].cookie );
    *bitrate = listings._buffer[0].maxRate;
    *len = listings._buffer[0].msecs / 1000;
    mza_LgCtntAtrLst__free( &listings, yoFree );
    return TRUE;
}

static void setposition(mkd_pos *pos, int newsecs)
{
/* works out a new position based on seconds from start ? */
    int hours, mins, secs;

    secs = newsecs;
    hours = 0; mins = 0;

    while (secs >= SECONDS_PER_HOUR)
    {
	secs -= SECONDS_PER_HOUR;
	hours++;
    }

    while (secs >= SECONDS_PER_MINUTE)
    {
	secs -= SECONDS_PER_MINUTE;
	mins++;
    }

    pos->_d					 = mkd_posTypeTime;
    pos->_u.mkd_posTimePos.mkd_posTimeHour	 = (ub4)hours;
    pos->_u.mkd_posTimePos.mkd_posTimeMinute	 = (ub1)mins;
    pos->_u.mkd_posTimePos.mkd_posTimeSecond	 = (ub1)secs;
    pos->_u.mkd_posTimePos.mkd_posTimeHundredth  = (ub1)0;
}

static int prtime(char *s, int timenow)
{
    int hours, mins, secs;

    secs = timenow;
    hours = 0; mins = 0;

    while (secs >= SECONDS_PER_HOUR) {
	secs -= SECONDS_PER_HOUR;
	hours++;
    }
    while (secs >= SECONDS_PER_MINUTE) {
	secs -= SECONDS_PER_MINUTE;
	mins++;
    }
    sprintf(s, "%d:%d:%d", hours, mins, secs);
    return (1);
}


static void initposition(mkd_pos *pos, enum Position ptype)
{
    switch (ptype)
    {
	case TIME:
	    pos->_d = mkd_posTypeTime;
	    break;
	case BEGINNING:
	    pos->_d = mkd_posTypeBeginning;
	    break;
	case END:
	    pos->_d = mkd_posTypeEnd;
	    break;
	case CURRENT:
	    pos->_d = mkd_posTypeCurrent;
	    break;
	case DEFAULTSTART:
	    pos->_d = mkd_posTypeDefaultStart;
	    break;
    }

    pos->_u.mkd_posTimePos.mkd_posTimeHour	 = (ub4)0;
    pos->_u.mkd_posTimePos.mkd_posTimeMinute	 = (ub1)0;
    pos->_u.mkd_posTimePos.mkd_posTimeSecond	 = (ub1)0;
    pos->_u.mkd_posTimePos.mkd_posTimeHundredth  = (ub1)0;
}

/*ARGS_USED*/
static void ovs_callbackhandler(dvoid  *argv, mzs_notify reason)
{
/*#if !defined(NDEBUG) && defined(SOS)*/
#ifdef SOS
    SetSystemVariable("OVCdebug$open", "ovs_callbackhandler called/n");
#endif

printf("\tOVS_CALLBAKHANDLER CALLED, reason %i\n", reason);
SetSystemVariable("OVCdebug$open", "ovs_callbackhandler called/n");

    endofstream = 1;
}

static int ovs_playcontrol_init(void)
{
    reset_eos_timer();
    active.id = 1;
    active.mode = MODE_NORMAL;
    static_playrate = OVS_NORMAL_RATE;
    return (1);
}

_kernel_oserror *ovs_startstream(int argc, char **argv, int handle, int loop, int ogf, int from, int to)
{
    int		       i, err = 0;
    char	       *name, *d;
    mzc_commProperty   props, props1;
    mzz_factory	       zfac;
    mzs_factory	       sfac;
    mzc_cktspec	       spec[2];
    mzc_cktspecs       specs;
    mzc_clientDeviceId cid;
    mzc_circuit	       *ckt;
    mkd_assetCookie    cookie;
    boolean	       sts;
    mzs_capMask	       playcapabilities;
    char	       ipadr[32];
    char	       udpadr[64];
    char	       tbuf[96];
    int		       prtno;
    int		       skipcnt = 0;

#ifndef NDEBUG
   _swix(OS_WriteC, _IN(0), 12); /* clear text screen & reset cursor to home */
   printf("\n\n\nON SCREEN DEBUGGING ON\n");
#endif

    if (ogf)
    {
	skipcnt = MktGenHdrLen;
    }

/*#if !defined(NDEBUG) && defined(SOS)*/
#ifdef SOS
    SetSystemVariable("OVCdebug$open", "ovs_openstream called/n");
#endif

    name = argv[0];
    is_dumpmode = 0;
    gw_phy_adr[0] = 0;

    for (i = 1; i < argc; i++)
    {
      /* if there is a flag -server <something>, then process it */
	if (caseless_strcmp(argv[i], "-server") == 0 && ++i < argc)
	{
	 /* if it's -server continuous, then initialise 'dumb' STB decode */
	    if (caseless_strcmp(argv[i], "continuous") == 0)
	    {
		is_dumpmode = 1;
		(void) ovs_playcontrol_init();
		ovs_initmpegpvc();
		ovs_initstream(handle, skipcnt);
		return (ovs_error(0));  /* 27feb98:CP:fixed input parameter mismatch */
	    }

	    /* ...otherwise copy the value to gateway address string */
	    /*
	       25/8/98:CP:possible barf here - gw_phy_adr is fixed length, and
	       there is no check on the length of string being strcat'd to it
	    */
	    else
	    {
		strcpy(gw_phy_adr, "UDP:");
		strcat(gw_phy_adr, argv[i]);
	    }
	}
    }


    /* parse things like //server/video  ????

    Looks for "//", then checks to see if there is another '/' later in the string.
    If all are true, then
       set server to be the name after //, up to the first /.
       set 'name' to be everything after, including the '/'.

    (ie. //server/name => server = 'server', name = '/name')
    */
    if (name[0] == '/' && name[1] == '/' && (d = strchr(&name[2], '/')) != 0)
    {
	*d = 0;
	/*
	   25/8/98:CP:possible barf here - gw_phy_adr is fixed length, and
	   there is no check on the length of string being strcat'd to it
	*/
	strcpy(gw_phy_adr, "UDP:");
	strcat(gw_phy_adr, &name[2]);
	*d = '/';
	name = d;
    }

    if (gw_phy_adr[0] == 0)
    {
	strcpy(gw_phy_adr, dflt_gw_phy_adr);
    }

    /* initialise MediaNet environment */
    set_watchdog_timer();
    Fire_Up_MediaNet();
    clr_watchdog_timer();

/*#if !defined(NDEBUG) && defined(SOS)*/
#ifdef SOS
    SetSystemVariable("OVCdebug$open", "OMN started/n");
#endif

    if (mn_started)
    {
	mnidle_timer = MNIDLE_TIMEOUT;
    }

/*    set_watchdog_timer(); 20oct98:CP:no timer termination, so could wreak havoc! */

    /* initialise ORB environment */
    yoEnvInit(&evs);
/*#if !defined(NDEBUG) && defined(SOS)*/
#ifdef SOS
    SetSystemVariable("OVCdebug$open", "yoEnvInit/n");
#endif
    /*
     * query the content service to get the asset cookie and segment info
     * corresponding to the requested video tag file
     */
    fobj = (mza_LgCtntMgmt) yoBind( mza_LgCtntMgmt__id, (char *)0, (yoRefData *)0, (char *)0);
    sts = ovsQuery( fobj, &evs, name, TRUE, &cookie, &asset_bitrate, &asset_len);
    yoRelease ((dvoid *)fobj);


    /* 30mar99:CP:NAB special; force default bitrate! */
    asset_bitrate = 0;

/*#if !defined(NDEBUG) && defined(SOS)*/
#ifdef SOS
    SetSystemVariable("OVCdebug$open", "yoRelease/n");
#endif

    if (sts == FALSE)
    {
	 err = 1;
	 yoEnvFree(&evs);
	 goto out;
    }


     /* construct a control circuit address */
    /* 4nov98:CP:
       let's just get this right....this bit of code:

       reads variable OMN_ADDR into udpadr
       scans the string for values which it stores in ipadr and prtno
       puts STB IP address into ipadr (which has just been filled in...)
       sets up udpadr to be <ipadr>:<prtno>

       So, all it does is read the OMN port used by the server, and use this to
       set up the control channel.

       Ummm.
    */
    read_sysvar("OMN_ADDR", udpadr, sizeof(udpadr));
    sscanf(udpadr, "UDP:%[^:]:%d", ipadr, &prtno);
    (void) read_my_ip_address(ipadr);
//    sprintf(udpadr, "\"%s:%d\"", ipadr, prtno); /* 5nov98:CP:quotes added */
    sprintf(udpadr, "%s:%d", ipadr, prtno);



    /* Build a client unique id from hostname and time */
    /*
     * Bodged to use Inet$LocalAddr and "STB" to test for *
     * possible name clash problem - CE 1/10/98           *
     * Would be preferable to specifically use IP address *
     * rather than relying upon a variable defined for    *
     * use of Freeway etc.                                *
     */
      read_sysvar("Inet$LocalAddr", cidbuffer+3, sizeof(cidbuffer)-3);
      cidbuffer[0] = 'S';
      cidbuffer[1] = 'T';
      cidbuffer[2] = 'B';

    cid._maximum = cid._length = strlen(cidbuffer) + 1;
    cid._buffer = (ub1 *)cidbuffer;

    /* build control circuit for session - a persistant point-to-point
     * bidirectional channel
     */
    props = mzc_propPersistantConnect | mzc_propDown | mzc_propUp |
			       mzc_propPointcast | mzc_propControl;

    spec[0]._d = mzc_cktspecTypeRequest;
    spec[0]._u.req._d = mzc_cktreqTypeSymmetric;
    spec[0]._u.req._u.sym.props = props;
    spec[0]._u.req._u.sym.chnl._d = mzc_chnlspecTypeRequest;
    spec[0]._u.req._u.sym.chnl._u.req.props = props;
    spec[0]._u.req._u.sym.chnl._u.req.protocol.name = "UDP";
    spec[0]._u.req._u.sym.chnl._u.req.protocol.info = udpadr;
    spec[0]._u.req._u.sym.chnl._u.req.bitrate = 0;
    currentop = 2;

    /* build data circuit - asymmetric persistant point-to-point
     * downstream-only real time channel from the video pump to the stb
     */
//    sprintf(udpadr, "\"%s:%d\"", ipadr, udpport); /* 5nov98:CP:quotes added */
    sprintf(udpadr, "%s:%d", ipadr, udpport);

    props1 = mzc_propPersistantConnect | mzc_propDown | mzc_propData |
	    mzc_propIsochronousData | mzc_propPointcast;
    spec[1]._d = mzc_cktspecTypeRequest;
    spec[1]._u.req._d = mzc_cktreqTypeAsymmetric;
    spec[1]._u.req._u.asym.props = props1;
    spec[1]._u.req._u.asym.upchnl._d = mzc_chnlspecTypeNone;
    spec[1]._u.req._u.asym.upchnl._u.none = 0;
    spec[1]._u.req._u.asym.downchnl._d = mzc_chnlspecTypeRequest;
    spec[1]._u.req._u.asym.downchnl._u.req.props = props1;
    spec[1]._u.req._u.asym.downchnl._u.req.bitrate = asset_bitrate;

    if (destadr[0] != 0)  /* value found in suitable file, eg. SysEnv.DestAdrs */
    {
	strcpy(tbuf, destadr);
	d = strchr(tbuf, ':');
	*d++ = 0;
	spec[1]._u.req._u.asym.downchnl._u.req.protocol.name = tbuf;
	spec[1]._u.req._u.asym.downchnl._u.req.protocol.info = d;
    }

    else
    {
	spec[1]._u.req._u.asym.downchnl._u.req.protocol.name = "UDP";
	spec[1]._u.req._u.asym.downchnl._u.req.protocol.info = udpadr;
    }
    specs._maximum = specs._length = 2;
    specs._buffer = &spec[0];

    /* bind to session factory, then
     * allocate session
     */

/*#if !defined(NDEBUG) && defined(SOS)*/
#ifdef SOS
    SetSystemVariable("OVCdebug$open", "Binding/n");
#endif


    zfac = (mzz_factory) yoBind(mzz_factory__id, (char *)0, (yoRefData *)0, (char *)0);
    ses = mzz_factory_AllocateSessionEx(zfac, &evs, mzz_sessNull, &cid, &specs);
    ckt = &(ses.info.circuits._buffer[1]);
    yoRelease((dvoid *)zfac);

    session_is_established = 1;

    /* bind to stream factory, then allocate stream */

    playcapabilities = mzs_capAudio | mzs_capVideo | mzs_capSeek | mzs_capMpeg1 | mzs_capMpeg2 |
		       mzs_capPause | mzs_capScan | mzs_capSkip;

    currentop = 4;
    sfac = (mzs_factory) yoBind(mzs_factory__id, (char *)0, (yoRefData *)0, (char *)0);
    streamRef = mzs_factory_alloc(sfac, &evs, ckt, playcapabilities, asset_bitrate);
    yoRelease((dvoid *)sfac);

    mzswrap_CurrentNPT = 0;
    new_npt = -1;
    ovs_initmpegpvc();
    ovs_initstream(handle, skipcnt);

/*#if !defined(NDEBUG) && defined(SOS)*/
#ifdef SOS
    SetSystemVariable("OVCdebug$open", "Prep play/n");
#endif
    /* prepare stream to play from start_point to end_point at the given bitrate.
     * playNow starts the movie immediately
     */
    if (from > 1000)
    {
	from = from / 1000;
	setposition(&mkdBegin, from);
	start_npt = from;
    }
    else
    {
	initposition(&mkdBegin, DEFAULTSTART);
	printf("Play from default\n");
    }

    if (to > 1000)
    {
	to = to / 1000;
	setposition(&mkdFinish, to);
	if (to < asset_len)
	{
	    asset_len = to;
	}
    }
    else
    {
	initposition(&mkdFinish, END);
    }

    initposition(&mkdCur, CURRENT);
    currentop = 5;

    streamInst = mzs_stream_prepare(streamRef, &evs, cookie,
			(mkd_pos *)&mkdBegin,
			(mkd_pos *)&mkdFinish,
			asset_bitrate,
			loop ? (mzs_stream_playLoop | mzs_stream_playNow) : mzs_stream_playNow,
			&status,
			(dvoid *)0);
    /* throw away the status info */
    mkd_segInfoList__free (&status, yoFree);

/* 18jan99:CP:conditionally removed conditional case for callbackhandler */
#ifndef USE_MN_CALLBACKS
    if (endofstream_timeout == 0)
    {
#endif

      printf("Setting ovs_callbackhandler\n");
      mzscl_stream_cliInit();
      mzscl_stream_setCallback(streamRef, &evs, (mzs_stream_cliCallbackHdlr)ovs_callbackhandler, (dvoid *)"");

#ifndef USE_MN_CALLBACKS
    }
#endif

/*#if !defined(NDEBUG) && defined(SOS)*/
#ifdef SOS
    SetSystemVariable("OVCdebug$open", "callback set/n");
#endif
    (void) ovs_playcontrol_init();
    currentop = 6;

//   _swix(OS_WriteC, _IN(0), 12); /* clear text screen & reset cursor to home */
#ifndef NDEBUG
//   _swix(OS_WriteC, _IN(0), 12); /* clear text screen & reset cursor to home */
    printf("requested video OK\n");
#endif
out:

#if !defined(NDEBUG) && defined(SOS)
    SetSystemVariable("OVCdebug$open", "finished/n");
#endif
    return (ovs_error(err));
}

_kernel_oserror *ovs_closestream(void)
{
    active.id = 0;
    static_playrate = 0;
    mzswrap_CurrentNPT = 0;
    new_npt = -1;

    if (is_dumpmode)
    {
	return ((_kernel_oserror *)0);
    }

SetSystemVariable("OVCclosestream$status", "Started");

    if (session_is_established)
    {
	session_is_established = 0;

	if (streamRef)
	{
/* 5mar99:CP:added missing mzs_stream_finish() and dealloc calls which
effectively 'unprepares' the video.  Strictly, it's not necessary, but it is
good manners on the part of the client to call it! */
	  mzs_stream_finish(streamRef, &evs, streamInst, 0x01);
	  /* 0x01 => finish specified stream; really needs to be a macro in a
             header somewhere */

	  mzs_stream_dealloc(streamRef, &evs);


/* 18jan99:CP:removed conditional for removing callbackhandler */
/* 5mar99:CP:added macro control of whether this gets called rather than relying
on server error handling */

#ifndef USE_MN_CALLBACKS
    if (endofstream_timeout == 0)
    {
#endif

SetSystemVariable("OVCclosestream$status", "mzscl_stream_removeCallback");
	    mzscl_stream_removeCallback(streamRef, &evs);
#ifndef USE_MN_CALLBACKS
    }
#endif


SetSystemVariable("OVCclosestream$status", "mzscl_stream_cliTerm");
	    mzscl_stream_cliTerm();

SetSystemVariable("OVCclosestream$status", "yoRelease");
	    yoRelease((dvoid *)streamRef);
	}
SetSystemVariable("OVCclosestream$status", "mzz_ses_Release");
	mzz_ses_Release(ses.or, &evs);

SetSystemVariable("OVCclosestream$status", "mzz_session__free");
	mzz_session__free(&ses, yoFree);

SetSystemVariable("OVCclosestream$status", "yoEnvFree");
	yoEnvFree(&evs);

    } /* endif (session_is_established) */

    streamInst = (mzs_stream_instance)0;
    streamRef = (mzs_stream)0;
    endofstream = 1;
SetSystemVariable("OVCclosestream$status", "Close_Down_MediaNet");
    (void) Close_Down_MediaNet();
SetSystemVariable("OVCclosestream$status", "reset_eos_timer");
    reset_eos_timer();
    endofstream = 1;

SetSystemVariable("OVCclosestream$status", "closed OK");
    return ((_kernel_oserror *)0);
}

/*ARGS_USED*/
static _kernel_oserror *ovs_resume(void)
{
   reset_eos_timer();


   yseTry  /* weird C++ lookalike exception handling! */
   {
      if ( (active.mode == MODE_PAUSE) && (static_PreviousPlayRate == static_playrate) )
      {
//	    mzs_stream_playFwd( streamRef,
//			       &evs,
//				streamInst,
//		    (mkd_pos *)&mkdCur,	   /* start posn */
//		    (mkd_pos *)&mkdFinish);/* end posn */
	  mzs_stream_play( streamRef,
			  &evs,
			   streamInst,
	       (mkd_pos *)&mkdCur,     /* current position */
	       (mkd_pos *)&mkdCur,    /* play from */
			   static_playrate < 0 ? &mkdBegin : &mkdFinish,  /* play until */
			   static_playrate,
			   asset_bitrate);
      }
      else
      {
        /* check to see if mkdBegin is set to default start; if it is then make
           it 'beginning' */
        if (mkdIsDefaultStart (&mkdBegin) )
        {
          initposition (&mkdBegin, BEGINNING);
        }

#ifndef NDEBUG
	 printf("ovs_resume from %i:%i:%i\n", mkdSkip._u.mkd_posTimePos.mkd_posTimeHour, mkdSkip._u.mkd_posTimePos.mkd_posTimeMinute, mkdSkip._u.mkd_posTimePos.mkd_posTimeSecond);
#endif
	  mzs_stream_play( streamRef,
			  &evs,
			   streamInst,
	       (mkd_pos *)&mkdSkip,	/* current position */
	       (mkd_pos *)&mkdSkip,    /* play from */
			   static_playrate < 0 ? &mkdBegin : &mkdFinish,  /* play until */
			   static_playrate,
			   asset_bitrate);
      }
   }

   yseCatchAll
   {
      yslError("ovs_resume: exception caught resuming video: %s\n", ysidToStr(yseExid));
   }
   yseEnd;

   return ((_kernel_oserror *)0);
}

static _kernel_oserror *ovs_pause(void)
{
    mzs_stream_pause(streamRef, &evs, streamInst, (mkd_pos *)&mkdCur);
    reset_eos_timer();
    return ((_kernel_oserror *)0);
}

_kernel_oserror *ovs_jump(int direction, int position)
{
    if (is_dumpmode || !session_is_established)
    {
	return ((_kernel_oserror *)0);
    }

    switch (direction)
    {
	case 0:
	    new_npt = position;
	    break;
	case 1:
	    new_npt = mzswrap_CurrentNPT + position;
	    break;
	case 2:
	    new_npt = mzswrap_CurrentNPT - position;
	    break;
       default:
	    return ((_kernel_oserror *)0);
    }

    if (new_npt > (asset_len - 5))
    {
	new_npt = asset_len - 5;
    }

    else
    {
       if (new_npt < 0)
       {
	  new_npt = 0;
       }
    }

    return ((_kernel_oserror *)0);
}


/******* ovs_playcontrol **************************************************

Purpose: Controls playback mode

Inputs: do_fast_scan (R0)
	val (R2)

From VSP spec:

	 R0   R2
	 0    0	   Pause
	 0    1	   Play
	 0   2-8   1/2 to 1/8 slow motion

	 1    1	   FF scan (modulus of R2 is the requested speed)
	 1   -1	   RWD scan


Outputs: None (never generates an error, always returns NULL)

***************************************************************************/

_kernel_oserror *ovs_playcontrol(int do_fast_scan, int val)
{
    unsigned int NPTfromStream;

    if (is_dumpmode || !session_is_established)
	return ((_kernel_oserror *)0);

    static_PreviousPlayRate = static_playrate;  /* need to track previous modes */

    if (do_fast_scan) /* FAST SCAN */
    {
#ifndef NDEBUG
	    printf("mzswrap:ovs_playcontrol() - I think NPT is %i s\n", mzswrap_CurrentNPT);
#endif

	if (OVS_NORMAL_RATE == static_PreviousPlayRate) /* was previously playing 1x */
	{
         /* check to see if the NPT value from the MPEG module more-or-less matches
	   where the STB thinks it is for switching to trick modes from normal
	   play mode.  If it doesn't, then use the STB estimate instead.  This
	   is because the NPT information in the normal play stream can be
	   extremely stale.
	 */

          mzswrap_CurrentNPT = EstimatePosition();
	}

	else
	{
	   mzswrap_CurrentNPT = read_pos() + 2;
	}

#ifndef NDEBUG
	printf("mzswrap:ovs_playcontrol() - fast scan starting at %i s\n", mzswrap_CurrentNPT);
#endif
	setposition(&mkdSkip, mzswrap_CurrentNPT);
	static_playrate = (val > 0) ? ovs_vsscan_rate : -ovs_vsscan_rate;
	active.mode = MODE_NORMAL;
	(void) ovs_resume();
	return ((_kernel_oserror *)0);
    }

    if (val == 0)  /* PAUSE */
    {
/*	  static_playrate = OVS_NORMAL_RATE;*/
	active.mode = MODE_PAUSE;
	(void) ovs_pause();
	return ((_kernel_oserror *)0);
    }

/* NORMAL PLAY/SLOWMO */

   /* if npt is different from current position, jump */

/* 13may98:CP:WTF is new_npt being set???!!! */
/* 8jun98:CP:new_npt is set to the new NPT after a jump cf ovs_jump() */

    if (new_npt != -1)
    {
	mzswrap_CurrentNPT = new_npt;
	new_npt = -1;
    }

   /* otherwise,
	  if paused, then resume play and return
	  otherwise, set current position slightly beyond current position
   */
    else
    {
	if (active.mode == MODE_PAUSE)
	{
#ifndef NDEBUG
	    printf("mzswrap:ovs_playcontrol() - I think NPT is %i s\n", mzswrap_CurrentNPT);
#endif
	    mzswrap_CurrentNPT = read_pos() + 2;

#ifndef NDEBUG
	    printf("mzswrap:ovs_playcontrol() - fast scan starting at %i s\n", mzswrap_CurrentNPT);
#endif
	    setposition(&mkdSkip, mzswrap_CurrentNPT);
	    static_playrate = OVS_NORMAL_RATE;

	    (void) ovs_resume();
	    active.mode = MODE_NORMAL;
	    return ((_kernel_oserror *)0);
	}
	else
	{
#ifndef NDEBUG
	    printf("mzswrap:ovs_playcontrol() - I think NPT is %i s\n", mzswrap_CurrentNPT);
#endif

	    mzswrap_CurrentNPT = read_pos() - (static_playrate / 1000);
#ifndef NDEBUG
	    printf("mzswrap:ovs_playcontrol() - normal play starting at %i s\n", mzswrap_CurrentNPT);
#endif
	}
    }

    setposition(&mkdSkip, mzswrap_CurrentNPT);

/* 13may98:CP:MUST BE TRUE!! If val == 0, then routine has exited earlier! */
    if (val == 1)
    {
	static_playrate = OVS_NORMAL_RATE;
    }
    else /* can never do this! */
    {
	static_playrate = (val > 0) ? ovs_slomo_rate : -ovs_slomo_rate;
    }

    active.mode = MODE_NORMAL;
    (void) ovs_resume();

    return ((_kernel_oserror *)0);
}


/******* read_pos   ********************************************************

Purpose: returns number of seconds from start of film.
	 The value is read from the MPEG Trans module, which provides a
	 full set of data for the stream timing.

Inputs: none

Outputs: unsigned int number of seconds elapsed into movie

***************************************************************************/

#ifndef USEOLDREAD_POS
unsigned int read_pos(void)
{
   char buffer[25];

   _kernel_swi_regs r;
   StatNPTBuffer Stats;
   int Tags[2];
   unsigned int npt = 0;   /* seconds...*/

   Tags[0] = MPEGControl_Stats_NPT;
   Tags[1] = ENDOFTAGS;

   r.r[0] = 0; /* not used yet */
   r.r[1] = mpeg_handle;
   r.r[2] = (int)Tags;
   r.r[3] = (int)&Stats;
   r.r[4] = sizeof(Stats);

   _kernel_swi(MPEGControl_Stats, &r, &r);

   /* note: R3 returns pointing to the end of the structure if successful; recommended coding style */
   if ( 0 < (r.r[3] - (int) &Stats) )
   {
      if (MPEGControl_Stats_NPT == Stats.Tag)
      {
#ifndef NDEBUG
	printf("RECEIVED %i BYTES OF DATA FROM STATS\n", Stats.DataLength);
#endif

        sprintf(buffer, "Rx %i from Stats", Stats.DataLength);
        SetSystemVariable("OVCinfo$read_pos", buffer);


	 if ( ( sizeof(Stats.Data) + sizeof(Stats.Flags) ) == Stats.DataLength )
	 {
	 /*
	    NOTE - the NPT here is a 33 bit signed integer! I have ignored bit 33
	    for the moment since we can't have negative times
	 */
	    npt = (Stats.Data[10] << 24) | (Stats.Data[11] << 16) | (Stats.Data[12] << 8) | Stats.Data[13];

	    npt /= 90000; /* represents a 90 kHz clock */

	 }

	 else
	 {
	    if (sizeof(Stats.Flags) == Stats.DataLength)
	    {
#ifndef NDEBUG
		printf ("VSPovc:read_pos() - \neither no NPT available, or parsing not enabled (bit 10 of ctrlflags must be set)\n");
#endif
                SetSystemVariable("OVCerror$read_pos", "either no NPT available, or parsing not enabled (bit 10 of ctrlflags must be set)");
	    }

	    else
	    {
#ifndef NDEBUG
		printf ("VSPovc:read_pos() - strange descriptor length\n");
#endif
                SetSystemVariable("OVCerror$read_pos", "strange descriptor length");
	    }
	 }
      }


      else
      {
#ifndef NDEBUG
	 printf ("VSPovc:read_pos() - Tag word wrong (not 9)\n");

#endif
         SetSystemVariable("OVCerror$read_pos", "Tag word wrong (not 9)");
      }
   }

   else
   {
#ifndef NDEBUG
      printf ("VSPovc:read_pos() - MPEGTrans module did not recognise tag 9\n");
#endif
      SetSystemVariable("OVCerror$read_pos", "MPEGTrans module did not recognise tag 9");
    }


   return npt;
}
#else
unsigned int read_pos(void)
{
    mkd_pos pos;
    mzs_state status;
    sb4 rate;
    unsigned int npt = 0;

    pos = mzs_stream_getPos(streamRef, &evs, streamInst, &status, &rate);

    if (status != mzs_statePause && status != mzs_stateStream)
    {
        endofstream = 1;
        return (0);
    }

    if (pos._u.mkd_posTimePos.mkd_posTimeHour > 0)
    {
        npt += pos._u.mkd_posTimePos.mkd_posTimeHour * SECONDS_PER_HOUR;
    }

    if (pos._u.mkd_posTimePos.mkd_posTimeMinute > 0)
    {
        npt += pos._u.mkd_posTimePos.mkd_posTimeMinute * SECONDS_PER_MINUTE;
    }

    npt += pos._u.mkd_posTimePos.mkd_posTimeSecond;
    return (npt);
}
#endif


/******* estimateposition **************************************************

Purpose: Takes the MPEG time, and compares it with the STB estimate.

         check to see if the NPT value from the MPEG module more-or-less matches
	   where the STB thinks it is for switching to trick modes from normal
	   play mode.  If it doesn't, then use the STB estimate instead.  This
	   is because the NPT information in the normal play stream can be
	   extremely stale.

	   Specifically, if the MPEG NPT is more than a given amount behind the
	   STB position, then use the STB estimate.  Otherwise use the MPEG
	   estimate.

Inputs: none

Outputs: unsigned int NPT estimate

***************************************************************************/

unsigned int EstimatePosition(void)
{
  unsigned int BestEstimate;

  BestEstimate = read_pos() + 2; /* get MPEG estimate */

  if ( (mzswrap_CurrentNPT - BestEstimate) > MAXTIMINGERROR )
  {
    /* STB estimate is probably closer; use it! */
    BestEstimate = mzswrap_CurrentNPT;

#ifndef NDEBUG
    printf("mzswrap:ovs_playcontrol() - using STB estimate\n");
#endif
  }

#ifndef NDEBUG
  else
  {
    /* MPEG estimate appears more accurate; use it */
    printf("mzswrap:ovs_playcontrol() - using MPEG estimate\n");
  }
#endif

  return BestEstimate;
}



/******* local_npt  ********************************************************

Purpose: keeps count of local time.  Called on TickerV (every 1 cs)

Inputs: none

Outputs: increments the global variable mzswrap_CurrentNPT

***************************************************************************/

void local_npt(void)
{
    if (streamInst != 0 && active.mode != MODE_PAUSE)
    {
	mzswrap_CurrentNPT += static_playrate / 1000; /* increment at the appropriate rate */
    }
}
