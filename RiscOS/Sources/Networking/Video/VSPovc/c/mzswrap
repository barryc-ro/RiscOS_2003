/*  mzswrap.c

Copyright © Acorn Computers Ltd 1998

History:

Date        Who   Description of change
=======================================
27-Feb-1998 CP    Source inherited.
                  Version released SysEnv 1.06

                  Changed all function declarations to be ANSI.
                  Some layout things to make source more readable.

                  Fixed input parameter in call to ovs_error in function
                  ovs_startstream.  Because it isn't properly prototyped,
                  2 parameters were being allowed to be passed!!

28-Aug-1998 CP    Made NPTs unsigned to avoid wraparound

                  Fixed bug in pause behaviour.

                  Added code to estimate how stale the NPT from the MPEG module
                  is.  Basically, module will now compare the time received from
                  the MPEG to where it thinks it is in the stream. If they don't
                  match fairly closely, then it will use its internal estimate.
                  Note that this is only used when switching from 1x 'normal'
                  play to a trickplay mode.  This is because the problem is due
                  to normal streams not necessarily carrying sufficient PMTs
                  (holding NPT info) to provide accurate timing information.  So
                  everything resyncs when switching between other modes.

28-Aug-1998 CP    Removed error printfs caused by 'no NPT' error from
                  MPEGControl_Stats.

                  Changed way that code changes from pause mode.  If going from
                  pause to previous mode, it will start from previously logged
                  position (mkd_Cur) which suppresses the GDF transmission, and
                  causes a smooth transition.  If going to a different mode,
                  then it will estimate its position in the normal way.

01-Oct-1998 CP/CE Changed STB unique ID from being <hostname><time> to being
                  STB<ipaddress> (eg. STB5320aa88).  This fixes a potential bug
                  caused by name duplication in the name.

20-Oct-1998 CP    Modified to use OLD read_pos() if necessary so that it can be
                  integrated with older baselines (eg. Elmsdale).

                  Removed a watchdogtimer start which doesn't have a matching stop.

04-Jan-1999 CP    Changed input parameter of initposition() to take an
                  enumerated value (to clarify calls, and catch duff values -
                  bad values will show as warnings at compile times).

                  Added the value DEFAULTSTART to initposition().

18-Jan-1999 CP    Definition of callback handler no longer dependent on the
                  timeout being zero (there's no guarantee that we will get a
                  callback in the case of a catastrophic server failure, so we
                  need the timeout too!).

03-Feb-1999 CP    Fixed (badly...) a bug in logic when switching to trickplay -
                  a parameter was being left as 'default'.  Should really define
                  constants for such goodies as positions beginning, end,
                  default etc etc.

04-Feb-1999 CP    Made use of MediaNet callbacks conditonal on USE_MN_CALLBACKS
                  (default behaviour is to see if EOS timeout is set to 0)

05-Mar-1999 CP    Added missing mzs_stream_finish() call to ovs_closestream().
                  This effectively  'unprepares' the video.  Strictly, it's not
                  necessary, but it is good manners on the part of the client to
                  call it!

15-Mar-1999 CP    Changed structure of estimation used to ensure NPTs are not
                  stale so that ReadNPT can use same approach.

19-May-1999 ADH   Look, you can read the source now! Wow. Given up on this
                  history - use CVS logs. That's what they're for. Did take
                  the time to rationalise the random collection of dates and
                  indentations in the history though, so you can read that too.

***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#ifndef SYSI_ORACLE
#include <sysi.h>
#endif /* !SYSI_ORACLE */

#ifndef YS_ORACLE
#include <ys.h>
#endif

#ifndef MZCCH_IDL
#include <mzcch.h>    /* channel interface */
#endif

#ifndef MZC_IDL
#include <mzc.h>      /* circuit interface */
#endif

#ifndef MZZCH_IDL
#include <mzz.h>      /* session interface */
#endif

#ifndef MKD_IDL
#include <mkd.h>
#endif

#ifndef MKDC_IDL
#include <mkdc.h>     /* C constants for mkd */
#endif

#ifndef MZALGCTN_IDL
#include <mzalgctn.h> /* logical content datatypes */
#endif

#ifndef MZS_IDL
#include <mzs.h>
#endif

#ifndef MZSCL_IDL
#include <mzscl.h>
#endif

#include "mkd.h"

#include "vsp.h"
#include "misc.h"
#include <time.h>
#include <kernel.h>
#include <swis.h>

#include "mpegctrl.h"

/* exports from the other files */

#include "mzswrap.h"
#include "vspc.h"
#include "module.h"

#include "debug.h"

#ifdef MODULE_DEBUG
  #define DEBUGLIB
  #include "debuglib/debuglib.h"
#endif

/* imports */

extern void Fire_Up_MediaNet(void);
extern int mn_started;
extern int sshutdown;

/* global variables */

unsigned int mzswrap_CurrentNPT = 0; /* current video position in seconds */

/* statics */

static int static_PreviousPlayRate = 0;
static int static_playrate         = 0;
static int start_npt               = 0;
static int new_npt                 = 0;
static int session_is_established  = 0;
static int is_dumpmode             = 0;

/*static int callb_init = 0;*/

static char cidbuffer[64];

static mzs_stream          streamRef;      /* object reference from server */
static mzs_stream_instance streamInst;     /* And its instantiation */
static ub4                 asset_bitrate;
static ub4                 asset_len;
static yoenv               evs;            /* yo environment variable */
static mzz_session         ses;
static mkd_segInfoList     status;
static mzc_circuit         dcirc;
static mkd_pos             mkdCur;
static mkd_pos             mkdBegin;
static mkd_pos             mkdFinish;
static mkd_pos             mkdSkip;
static mza_LgCtntMgmt      fobj;

enum Position {TIME, BEGINNING, END, CURRENT, DEFAULTSTART};

#define MAXTIMINGERROR 5  /* maximum tolerable difference between STB and MPEG
                           * stream timing.  Used to estimate how stale the
                           * MPEG NPT really is (in seconds)
                           */

/*************************************************/
/* ovsQuery()                                    */
/*                                               */
/* Query the content service to get an asset     */
/* cookie.                                       */
/*                                               */
/* Parameters: Object reference of the content   */
/*             service;                          */
/*                                               */
/*             Pointer to active environment;    */
/*                                               */
/*             Name of the requested file;       */
/*                                               */
/*             Boolean for "is this for a        */
/*             tagfile or some other kind of     */
/*             content?";                        */
/*                                               */
/*             Pointer to a mkd_assetCookie to   */
/*             hold the returned asset cookie;   */
/*                                               */
/*             Pointer to a ub4 to hold the      */
/*             bitrate of the returned cookie if */
/*             applicable;                       */
/*                                               */
/*             Pointer to another ub4 - TBD.     */
/*                                               */
/* Returns:    TRUE if the query succeeded and   */
/*             matched one file, else FALSE.     */
/*************************************************/

static boolean ovsQuery(mza_LgCtntMgmt fobj, yoenv * env, const char * file,
                        boolean tagfile, mkd_assetCookie * cookie,
                        ub4 * bitrate, ub4 * len)
{
  mza_LgCtntAtrLst listings;
  mza_Itr          itr;

  itr.Position = 0;
  itr.NumItems = 1;
  currentop    = 1;

  listings = mza_LgCtntMgmt_lstAtrByNm(fobj, env, (char *) file, tagfile, &itr);

  /* check to make sure we only retrieved one match */
  if (listings._length == 0) return FALSE;

  /* This should never happen since we only asked for 1 */
  if (listings._length > 1) return FALSE;

  /* This should never happen since we only asked for 1 */
  if (listings._buffer[0].numClips == 0 ) return FALSE;

  *cookie = (mkd_assetCookie) ysStrDup(listings._buffer[0].cookie);
  *bitrate = listings._buffer[0].maxRate;
  *len = listings._buffer[0].msecs / 1000;

  mza_LgCtntAtrLst__free(&listings, yoFree);

  return TRUE;
}

/*************************************************/
/* setposition()                                 */
/*                                               */
/* Work out a new position based on seconds from */
/* the start.                                    */
/*                                               */
/* Parameters: Pointer to a mkd_pos to update    */
/*             based on the given new time;      */
/*                                               */
/*             Number of seconds from the start. */
/*************************************************/

static void setposition(mkd_pos * pos, int newsecs)
{
  int hours, mins, secs;

  secs  = newsecs;
  hours = 0;
  mins  = 0;

  while (secs >= SECONDS_PER_HOUR)
  {
    secs -= SECONDS_PER_HOUR;
    hours++;
  }

  while (secs >= SECONDS_PER_MINUTE)
  {
    secs -= SECONDS_PER_MINUTE;
    mins++;
  }

  pos->_d                                     = mkd_posTypeTime;
  pos->_u.mkd_posTimePos.mkd_posTimeHour      = (ub4)hours;
  pos->_u.mkd_posTimePos.mkd_posTimeMinute    = (ub1)mins;
  pos->_u.mkd_posTimePos.mkd_posTimeSecond    = (ub1)secs;
  pos->_u.mkd_posTimePos.mkd_posTimeHundredth = (ub1)0;
}

/*************************************************/
/* prtime()                                      */
/*                                               */
/* Given a time in seconds, construct a string   */
/* of the form "hrs:mins:secs".                  */
/*                                               */
/* Parameters: Pointer to a buffer to construct  */
/*             the string in (must be "large     */
/*             enough");                         */
/*                                               */
/*             Time in seconds.                  */
/*************************************************/

static int prtime(char * s, int timenow)
{
  int hours, mins, secs;

  secs  = timenow;
  hours = 0;
  mins  = 0;

  while (secs >= SECONDS_PER_HOUR)
  {
    secs -= SECONDS_PER_HOUR;
    hours++;
  }

  while (secs >= SECONDS_PER_MINUTE)
  {
    secs -= SECONDS_PER_MINUTE;
    mins++;
  }

  sprintf(s, "%d:%d:%d", hours, mins, secs);

  return (1);
}

/*************************************************/
/* initposition()                                */
/*                                               */
/* Convert from a Position to a mkd_pos.         */
/*                                               */
/* Parameters: Pointer to the mkd_pos to update; */
/*                                               */
/*             A Position to write into the      */
/*             mkd_pos (e.g. TIME, BEGINNING,    */
/*             END etc.).                        */
/*************************************************/

static void initposition(mkd_pos * pos, enum Position ptype)
{
    switch (ptype)
    {
      case TIME:
        pos->_d = mkd_posTypeTime;
        break;
      case BEGINNING:
        pos->_d = mkd_posTypeBeginning;
        break;
      case END:
        pos->_d = mkd_posTypeEnd;
        break;
      case CURRENT:
        pos->_d = mkd_posTypeCurrent;
        break;
      case DEFAULTSTART:
        pos->_d = mkd_posTypeDefaultStart;
        break;
    }

    pos->_u.mkd_posTimePos.mkd_posTimeHour      = (ub4) 0;
    pos->_u.mkd_posTimePos.mkd_posTimeMinute    = (ub1) 0;
    pos->_u.mkd_posTimePos.mkd_posTimeSecond    = (ub1) 0;
    pos->_u.mkd_posTimePos.mkd_posTimeHundredth = (ub1) 0;
}

/*************************************************/
/* ovs_callbackhandler()                         */
/*                                               */
/* MediaNet sometimes calls back here. Our       */
/* apparent objective is to then panic and try   */
/* to end the stream. Ho hum. This code sucks.   */
/* Why can't I ever inherit stuff that *isn't*   */
/* junk...? =8*O                                 */
/*                                               */
/* Parameters: TBD.                              */
/*************************************************/

static void ovs_callbackhandler(dvoid  * argv, mzs_notify reason)
{
  #ifdef SOS
    SetSystemVariable("OVCdebug$open", "ovs_callbackhandler called/n");
  #endif

  #ifdef MODULE_DEBUG
    dprintf(("", "\tovs_callbackhandler called, reason %i\n", reason));
    SetSystemVariable("OVCdebug$open", "ovs_callbackhandler called/n");
  #endif

  endofstream = 1;
}

/*************************************************/
/* ovs_playcontrol_init()                        */
/*                                               */
/* TBD.                                          */
/*************************************************/

static int ovs_playcontrol_init(void)
{
  reset_eos_timer();

  active.id       = 1;
  active.mode     = MODE_NORMAL;
  static_playrate = OVS_NORMAL_RATE;

  return (1);
}

/*************************************************/
/* ovs_startstream()                             */
/*                                               */
/* TBD, though the function name gives away the  */
/* top level aim here!                           */
/*************************************************/

_kernel_oserror * ovs_startstream(int argc, char ** argv, int handle, int loop, int ogf, int from, int to)
{
  int                  i, err = 0;
  char               * name, * d;
  mzc_commProperty     props, props1;
  mzz_factory          zfac;
  mzs_factory          sfac;
  mzc_cktspec          spec   [2];
  mzc_cktspecs         specs;
  mzc_clientDeviceId   cid;
  mzc_circuit        * ckt;
  mkd_assetCookie      cookie;
  boolean              sts;
  mzs_capMask          playcapabilities;
  char                 ipadr  [32];
  char                 udpadr [64];
  char                 tbuf   [96];
  int                  prtno;
  int                  skipcnt = 0;

  #ifdef MODULE_DEBUG
    dprintf(("", "DEBUGGING ON\n"));
  #endif

  if (ogf) skipcnt = MktGenHdrLen;

  #ifdef SOS
    SetSystemVariable("OVCdebug$open", "ovs_openstream called/n");
  #endif

  name          = argv[0];
  is_dumpmode   = 0;
  gw_phy_adr[0] = 0;

  for (i = 1; i < argc; i++)
  {
    /* if there is a flag -server <something>, then process it */
    if (caseless_strcmp(argv[i], "-server") == 0 && ++i < argc)
    {
      /* if it's -server continuous, then initialise 'dumb' STB decode */

      if (caseless_strcmp(argv[i], "continuous") == 0)
      {
        is_dumpmode = 1;
        (void) ovs_playcontrol_init();
        ovs_initmpegpvc();
        ovs_initstream(handle, skipcnt);

        /* 27-Feb-1998 (CP): fixed input parameter mismatch */

        return (ovs_error(0));
      }

      /* ...otherwise copy the value to gateway address string */

      /*
       * 25-Aug-199 (CP): possible barf here - gw_phy_adr is fixed length,
       * and there is no check on the length of string being strcat'd to it
       */

      else
      {
        strcpy(gw_phy_adr, "UDP:");
        strcat(gw_phy_adr, argv[i]);
      }
    }
  }

  /* parse things like //server/video?
   *
   * Looks for "//", then checks to see if there is another '/' later in the string.
   * If all are true, then
   *    set server to be the name after //, up to the first /.
   *    set 'name' to be everything after, including the '/'.
   *
   * (ie. //server/name => server = 'server', name = '/name')
   */

  if (name[0] == '/' && name[1] == '/' && (d = strchr(&name[2], '/')) != 0)
  {
    *d = 0;

    /*
     * 25-Aug-1998 (CP): possible barf here - gw_phy_adr is fixed length,
     * and there is no check on the length of string being strcat'd to it
     */

    strcpy(gw_phy_adr, "UDP:");
    strcat(gw_phy_adr, &name[2]);

    *d   = '/';
    name = d;
  }

  if (gw_phy_adr[0] == 0)
  {
    strcpy(gw_phy_adr, dflt_gw_phy_adr);
  }

  /* initialise MediaNet environment */

  set_watchdog_timer();
  Fire_Up_MediaNet();
  clr_watchdog_timer();

  #ifdef SOS
    SetSystemVariable("OVCdebug$open", "OMN started/n");
  #endif

  if (mn_started)
  {
    mnidle_timer = MNIDLE_TIMEOUT;
  }

  /* set_watchdog_timer(); 20-Oct-1998 (CP): no timer termination, so could wreak havoc! */

  /*
   * 19-May-1999 (ADH): Quality. Rather than fix it by introducing deregistration
   * code, let's just comment out the line that registers it in the first place.
   * I hope that timer wasn't important.
   */

  /* initialise ORB environment */
  yoEnvInit(&evs);

  #ifdef SOS
    SetSystemVariable("OVCdebug$open", "yoEnvInit/n");
  #endif

  /*
   * query the content service to get the asset cookie and segment info
   * corresponding to the requested video tag file
   */
  fobj = (mza_LgCtntMgmt) yoBind( mza_LgCtntMgmt__id, (char *)0, (yoRefData *)0, (char *)0);
  sts  = ovsQuery( fobj, &evs, name, TRUE, &cookie, &asset_bitrate, &asset_len);
  yoRelease ((dvoid *)fobj);

  /* 30-Mar-1999 (CP): NAB special; force default bitrate! */
  asset_bitrate = 0;

  #ifdef SOS
    SetSystemVariable("OVCdebug$open", "yoRelease/n");
  #endif

  if (sts == FALSE)
  {
    err = 1;
    yoEnvFree(&evs);
    goto out;
  }

  /* construct a control circuit address */

  /* 04-Nov-1998 (CP):
   *
   * let's just get this right....this bit of code:
   *
   * reads variable OMN_ADDR into udpadr
   * scans the string for values which it stores in ipadr and prtno
   * puts STB IP address into ipadr (which has just been filled in...)
   * sets up udpadr to be <ipadr>:<prtno>
   *
   * So, all it does is read the OMN port used by the server, and use this to
   * set up the control channel.
   *
   * Ummm.
   */

  read_sysvar("OMN_ADDR", udpadr, sizeof(udpadr));
  sscanf(udpadr, "UDP:%[^:]:%d", ipadr, &prtno);
  (void) read_my_ip_address(ipadr);
//  sprintf(udpadr, "\"%s:%d\"", ipadr, prtno); /* 5nov98:CP:quotes added */
  sprintf(udpadr, "%s:%d", ipadr, prtno);

  /* Build a client unique id from hostname and time */
  /*
   * Bodged to use Inet$LocalAddr and "STB" to test for
   * possible name clash problem - CE 1/10/98
   * Would be preferable to specifically use IP address
   * rather than relying upon a variable defined for
   * use of Freeway etc.
   */

  read_sysvar("Inet$LocalAddr", cidbuffer+3, sizeof(cidbuffer)-3);
  cidbuffer[0] = 'S';
  cidbuffer[1] = 'T';
  cidbuffer[2] = 'B';

  cid._maximum = cid._length = strlen(cidbuffer) + 1;
  cid._buffer = (ub1 *)cidbuffer;

  /* build control circuit for session - a persistant point-to-point
   * bidirectional channel
   */

  props = mzc_propPersistantConnect |
          mzc_propDown              |
          mzc_propUp                |
          mzc_propPointcast         |
          mzc_propControl;

  spec[0]._d                                      = mzc_cktspecTypeRequest;
  spec[0]._u.req._d                               = mzc_cktreqTypeSymmetric;
  spec[0]._u.req._u.sym.props                     = props;
  spec[0]._u.req._u.sym.chnl._d                   = mzc_chnlspecTypeRequest;
  spec[0]._u.req._u.sym.chnl._u.req.props         = props;
  spec[0]._u.req._u.sym.chnl._u.req.protocol.name = "UDP";
  spec[0]._u.req._u.sym.chnl._u.req.protocol.info = udpadr;
  spec[0]._u.req._u.sym.chnl._u.req.bitrate       = 0;

  currentop = 2;

  /* build data circuit - asymmetric persistant point-to-point
   * downstream-only real time channel from the video pump to the stb
   */
//  sprintf(udpadr, "\"%s:%d\"", ipadr, udpport); /* 05-Nov-1998 (CP): quotes added */

  sprintf(udpadr, "%s:%d", ipadr, udpport);

  props1 = mzc_propPersistantConnect |
           mzc_propDown              |
           mzc_propData              |
           mzc_propIsochronousData   |
           mzc_propPointcast;

  spec[1]._d                                     = mzc_cktspecTypeRequest;
  spec[1]._u.req._d                              = mzc_cktreqTypeAsymmetric;
  spec[1]._u.req._u.asym.props                   = props1;
  spec[1]._u.req._u.asym.upchnl._d               = mzc_chnlspecTypeNone;
  spec[1]._u.req._u.asym.upchnl._u.none          = 0;
  spec[1]._u.req._u.asym.downchnl._d             = mzc_chnlspecTypeRequest;
  spec[1]._u.req._u.asym.downchnl._u.req.props   = props1;
  spec[1]._u.req._u.asym.downchnl._u.req.bitrate = asset_bitrate;

  if (destadr[0] != 0)  /* value found in suitable file, eg. SysEnv.DestAdrs */
  {
    strcpy(tbuf, destadr);

    d    = strchr(tbuf, ':');
    *d++ = 0;

    spec[1]._u.req._u.asym.downchnl._u.req.protocol.name = tbuf;
    spec[1]._u.req._u.asym.downchnl._u.req.protocol.info = d;
  }
  else
  {
    spec[1]._u.req._u.asym.downchnl._u.req.protocol.name = "UDP";
    spec[1]._u.req._u.asym.downchnl._u.req.protocol.info = udpadr;
  }

  specs._maximum = specs._length = 2;
  specs._buffer  = &spec[0];

  /* bind to session factory, then
   * allocate session
   */

  #ifdef SOS
    SetSystemVariable("OVCdebug$open", "Binding/n");
  #endif

  zfac = (mzz_factory) yoBind(mzz_factory__id,
                              (char *) 0,
                              (yoRefData *) 0,
                              (char *) 0);

  ses = mzz_factory_AllocateSessionEx(zfac,
                                      &evs,
                                      mzz_sessNull,
                                      &cid,
                                      &specs);

  ckt = &(ses.info.circuits._buffer[1]);
  yoRelease((dvoid *) zfac);
  session_is_established = 1;

  /* bind to stream factory, then allocate stream */

  playcapabilities = mzs_capAudio |
                     mzs_capVideo |
                     mzs_capSeek  |
                     mzs_capMpeg1 |
                     mzs_capMpeg2 |
                     mzs_capPause |
                     mzs_capScan  |
                     mzs_capSkip;

  currentop = 4;

  sfac = (mzs_factory) yoBind(mzs_factory__id,
                              (char *) 0,
                              (yoRefData *) 0,
                              (char *) 0);

  streamRef = mzs_factory_alloc(sfac,
                                &evs,
                                ckt,
                                playcapabilities,
                                asset_bitrate);
  yoRelease((dvoid *) sfac);
  mzswrap_CurrentNPT = 0;
  new_npt = -1;

  ovs_initmpegpvc();
  ovs_initstream(handle, skipcnt);

  #ifdef SOS
    SetSystemVariable("OVCdebug$open", "Prep play/n");
  #endif

  /* prepare stream to play from start_point to end_point at the given bitrate.
   * playNow starts the movie immediately
   */

  if (from > 1000)
  {
    from = from / 1000;
    setposition(&mkdBegin, from);
    start_npt = from;
  }
  else
  {
    initposition(&mkdBegin, DEFAULTSTART);

    #ifdef MODULE_DEBUG
      dprintf(("", "Play from default\n"));
    #endif
  }

  if (to > 1000)
  {
    to = to / 1000;
    setposition(&mkdFinish, to);
    if (to < asset_len)
    {
      asset_len = to;
    }
  }
  else
  {
    initposition(&mkdFinish, END);
  }

  initposition(&mkdCur, CURRENT);
  currentop = 5;

  streamInst = mzs_stream_prepare(streamRef,
                                  &evs,
                                  cookie,
                                  (mkd_pos *) &mkdBegin,
                                  (mkd_pos *) &mkdFinish,
                                  asset_bitrate,

                                  loop ? (mzs_stream_playLoop | mzs_stream_playNow) : mzs_stream_playNow,

                                  &status,
                                  (dvoid *) 0);

  /* throw away the status info */

  mkd_segInfoList__free (&status, yoFree);

  /* 18-Jan-1999 (CP): conditionally removed conditional case for callbackhandler */

  #ifndef USE_MN_CALLBACKS
    if (endofstream_timeout == 0)
    {
  #endif

    #ifdef MODULE_DEBUG
      dprintf(("", "Setting ovs_callbackhandler\n"));
    #endif

    mzscl_stream_cliInit();
    mzscl_stream_setCallback(streamRef, &evs, (mzs_stream_cliCallbackHdlr)ovs_callbackhandler, (dvoid *)"");

  #ifndef USE_MN_CALLBACKS
    }
  #endif

  #ifdef SOS
    SetSystemVariable("OVCdebug$open", "callback set/n");
  #endif

  (void) ovs_playcontrol_init();
  currentop = 6;

  #ifdef MODULE_DEBUG
    dprintf(("", "requested video OK\n"));
  #endif

out:

  /* #if defined(MODULE_DEBUG) && defined(SOS) */
  #ifdef SOS
    SetSystemVariable("OVCdebug$open", "finished/n");
  #endif

  return (ovs_error(err));
}

/*************************************************/
/* ovs_closestream()                             */
/*                                               */
/* Shut down the stream (stop playing video).    */
/*                                               */
/* Returns: NULL, as far as I can tell.          */
/*************************************************/

_kernel_oserror * ovs_closestream(void)
{
  active.id          = 0;
  static_playrate    = 0;
  mzswrap_CurrentNPT = 0;
  new_npt            = -1;

  if (is_dumpmode)
  {
    return NULL;
  }

  SetSystemVariable("OVCclosestream$status", "Started");

  if (session_is_established)
  {
    session_is_established = 0;

    if (streamRef)
    {
      /* 05-Mar-1999 (CP): added missing mzs_stream_finish() and dealloc calls which
       * effectively 'unprepares' the video.  Strictly, it's not necessary, but it is
       * good manners on the part of the client to call it!
       */

      mzs_stream_finish(streamRef, &evs, streamInst, 0x01);

      /* 0x01 => finish specified stream; really needs to be a macro in a
       * header somewhere
       */

      mzs_stream_dealloc(streamRef, &evs);

      /* 18-Jan-1999 (CP): removed conditional for removing callbackhandler */
      /* 05-Mar-1999 (CP): added macro control of whether this gets called rather than
       * relying on server error handling
       */

      #ifndef USE_MN_CALLBACKS
        if (endofstream_timeout == 0)
        {
      #endif

        SetSystemVariable("OVCclosestream$status", "mzscl_stream_removeCallback");
        mzscl_stream_removeCallback(streamRef, &evs);

      #ifndef USE_MN_CALLBACKS
        }
      #endif

      SetSystemVariable("OVCclosestream$status", "mzscl_stream_cliTerm");
      mzscl_stream_cliTerm();

      SetSystemVariable("OVCclosestream$status", "yoRelease");
      yoRelease((dvoid *)streamRef);
    }

    SetSystemVariable("OVCclosestream$status", "mzz_ses_Release");
    mzz_ses_Release(ses.or, &evs);

    SetSystemVariable("OVCclosestream$status", "mzz_session__free");
    mzz_session__free(&ses, yoFree);

    SetSystemVariable("OVCclosestream$status", "yoEnvFree");
    yoEnvFree(&evs);

  } /* endif (session_is_established) */

  streamInst  = (mzs_stream_instance)0;
  streamRef   = (mzs_stream)0;
  endofstream = 1;

  SetSystemVariable("OVCclosestream$status", "Close_Down_MediaNet");

  (void) Close_Down_MediaNet();

  SetSystemVariable("OVCclosestream$status", "reset_eos_timer");

  reset_eos_timer();
  endofstream = 1;

  SetSystemVariable("OVCclosestream$status", "closed OK");

  return NULL;
}

/*************************************************/
/* ovs_resume()                                  */
/*                                               */
/* I think you call this to get out of various   */
/* trick play modes.                             */
/*************************************************/

static _kernel_oserror * ovs_resume(void)
{
  reset_eos_timer();

  yseTry  /* weird C++ lookalike exception handling! */
  {
    if ( (active.mode == MODE_PAUSE) && (static_PreviousPlayRate == static_playrate) )
    {
//    mzs_stream_playFwd(streamRef,
//                       &evs,
//                       streamInst,
//                       (mkd_pos *) &mkdCur,     /* start posn */
//                       (mkd_pos *) &mkdFinish); /* end posn */

      mzs_stream_play(streamRef,
                      &evs,
                      streamInst,
                      (mkd_pos *) &mkdCur,                          /* current position */
                      (mkd_pos *) &mkdCur,                          /* play from */

                      static_playrate < 0 ? &mkdBegin : &mkdFinish, /* play until */

                      static_playrate,
                      asset_bitrate);
    }
    else
    {
      /* check to see if mkdBegin is set to default start; if it is then make
       * it 'beginning'
       */

      if (mkdIsDefaultStart (&mkdBegin) )
      {
        initposition (&mkdBegin, BEGINNING);
      }

      #ifdef MODULE_DEBUG
        dprintf(("", "ovs_resume from %i:%i:%i\n", mkdSkip._u.mkd_posTimePos.mkd_posTimeHour,
                                               mkdSkip._u.mkd_posTimePos.mkd_posTimeMinute,
                                               mkdSkip._u.mkd_posTimePos.mkd_posTimeSecond));
      #endif

      mzs_stream_play(streamRef,
                      &evs,
                      streamInst,
                      (mkd_pos *) &mkdSkip,                         /* current position */
                      (mkd_pos *) &mkdSkip,                         /* play from */

                      static_playrate < 0 ? &mkdBegin : &mkdFinish, /* play until */

                      static_playrate,
                      asset_bitrate);
    }
  }

  yseCatchAll
  {
    yslError("ovs_resume: exception caught resuming video: %s\n", ysidToStr(yseExid));
  }
  yseEnd;

  return NULL;
}

/*************************************************/
/* ovs_pause()                                   */
/*                                               */
/* Pause the currently playing video stream.     */
/*************************************************/

static _kernel_oserror * ovs_pause(void)
{
  mzs_stream_pause(streamRef, &evs, streamInst, (mkd_pos *) &mkdCur);
  reset_eos_timer();

  return NULL;
}

/*************************************************/
/* ovs_jump()                                    */
/*                                               */
/* Attempt to jump forwards or backwards through */
/* the currently playing stream by a given       */
/* number of seconds.                            */
/*                                               */
/* Parameters: 0 = Jump to an absolute time in   */
/*             seconds, 1 = jump forwards 'n'    */
/*             seconds, 2 = jump backwards 'n'   */
/*             seconds;                          */
/*                                               */
/*             The amount to move by or the      */
/*             absolute position, in seconds.    */
/*************************************************/

_kernel_oserror * ovs_jump(int direction, int position)
{
  if (is_dumpmode || !session_is_established)
  {
    return ((_kernel_oserror *)0);
  }

  switch (direction)
  {
    case 0:
      new_npt = position;
      break;
    case 1:
      new_npt = mzswrap_CurrentNPT + position;
      break;
    case 2:
      new_npt = mzswrap_CurrentNPT - position;
      break;
    default:
      return NULL;
  }

  if (new_npt > (asset_len - 5))
  {
    new_npt = asset_len - 5;
  }

  else
  {
    if (new_npt < 0)
    {
      new_npt = 0;
    }
  }

  return NULL;
}

/*************************************************/
/* ovs_playcontrol()                             */
/*                                               */
/* Controls the playback mode.                   */
/*                                               */
/* Parameters: R0 from mapping SWI call;         */
/*                                               */
/*             R2 from mapping SWI call.         */
/*                                               */
/*             From the VSP spec, this means:    */
/*                                               */
/*             R0  R2   Meaning                  */
/*             ================================= */
/*             0   0    Pause                    */
/*             0   1    Play                     */
/*             0   2-8  1/2 to 1/8 slow motion   */
/*             1   1    FFWD (modulus of R2 is   */
/*                      the requested speed)     */
/*             1   -1   FRWD                     */
/*************************************************/

_kernel_oserror * ovs_playcontrol(int do_fast_scan, int val)
{
  unsigned int NPTfromStream;

  if (is_dumpmode || !session_is_established) return NULL;

  static_PreviousPlayRate = static_playrate;  /* need to track previous modes */

  if (do_fast_scan) /* FAST SCAN */
  {
    #ifdef MODULE_DEBUG
      dprintf(("", "mzswrap:ovs_playcontrol() - I think NPT is %i s\n", mzswrap_CurrentNPT));
    #endif

    if (OVS_NORMAL_RATE == static_PreviousPlayRate) /* was previously playing 1x */
    {
      /* check to see if the NPT value from the MPEG module more-or-less matches
       * where the STB thinks it is for switching to trick modes from normal
       * play mode.  If it doesn't, then use the STB estimate instead.  This
       * is because the NPT information in the normal play stream can be
       * extremely stale.
       */

      mzswrap_CurrentNPT = EstimatePosition();
    }

    else
    {
      mzswrap_CurrentNPT = read_pos() + 2;
    }

    #ifdef MODULE_DEBUG
      dprintf(("", "mzswrap:ovs_playcontrol() - fast scan starting at %i s\n", mzswrap_CurrentNPT));
    #endif

    setposition(&mkdSkip, mzswrap_CurrentNPT);
    static_playrate = (val > 0) ? ovs_vsscan_rate : -ovs_vsscan_rate;
    active.mode = MODE_NORMAL;
    (void) ovs_resume();

    return NULL;
  }

  if (val == 0)  /* PAUSE */
  {
    /* static_playrate = OVS_NORMAL_RATE; */
    active.mode = MODE_PAUSE;
    (void) ovs_pause();

    return NULL;
  }

  /* NORMAL PLAY/SLOWMO */

  /* if npt is different from current position, jump */

  /* 13-May-1998 (CP): WTF is new_npt being set?! */
  /* 08-Jun-1998 (CP): new_npt is set to the new NPT after a jump cf ovs_jump() */

  if (new_npt != -1)
  {
    mzswrap_CurrentNPT = new_npt;
    new_npt = -1;
  }

  /* otherwise,
   * if paused, then resume play and return
   * otherwise, set current position slightly beyond current position
   */

  else
  {
    if (active.mode == MODE_PAUSE)
    {
      #ifdef MODULE_DEBUG
        dprintf(("", "mzswrap:ovs_playcontrol() - I think NPT is %i s\n", mzswrap_CurrentNPT));
      #endif

      mzswrap_CurrentNPT = read_pos() + 2;

      #ifdef MODULE_DEBUG
        dprintf(("", "mzswrap:ovs_playcontrol() - fast scan starting at %i s\n", mzswrap_CurrentNPT));
      #endif

      setposition(&mkdSkip, mzswrap_CurrentNPT);
      static_playrate = OVS_NORMAL_RATE;
      (void) ovs_resume();
      active.mode = MODE_NORMAL;

      return NULL;
    }
    else
    {
      #ifdef MODULE_DEBUG
        dprintf(("", "mzswrap:ovs_playcontrol() - I think NPT is %i s\n", mzswrap_CurrentNPT));
      #endif

      mzswrap_CurrentNPT = read_pos() - (static_playrate / 1000);

      #ifdef MODULE_DEBUG
        dprintf(("", "mzswrap:ovs_playcontrol() - normal play starting at %i s\n", mzswrap_CurrentNPT));
      #endif
    }
  }

  setposition(&mkdSkip, mzswrap_CurrentNPT);

  /* 13-May-1998 (CP): MUST BE TRUE!! If val == 0, then routine has exited earlier! */

  if (val == 1)
  {
    static_playrate = OVS_NORMAL_RATE;
  }
  else /* can never do this! */
  {
    static_playrate = (val > 0) ? ovs_slomo_rate : -ovs_slomo_rate;
  }

  active.mode = MODE_NORMAL;
  (void) ovs_resume();

  return NULL;
}

/*************************************************/
/* read_pos()                                    */
/*                                               */
/* Returns the number of seconds from the start  */
/* of the film. Read from the MPEG module.       */
/*                                               */
/* There are two versions of this for some       */
/* reason... (Explanation TBD).                  */
/*                                               */
/* Returns:    Number of seconds elapsed.        */
/*************************************************/

#ifndef USEOLDREAD_POS

  unsigned int read_pos(void)
  {
    _kernel_swi_regs r;
    StatNPTBuffer    Stats;
    char             buffer [25];
    int              Tags   [2];
    unsigned int     npt = 0; /* seconds...*/

    Tags[0] = MPEGControl_Stats_NPT;
    Tags[1] = ENDOFTAGS;

    r.r[0] = 0; /* not used yet */
    r.r[1] = mpeg_handle;
    r.r[2] = (int)Tags;
    r.r[3] = (int)&Stats;
    r.r[4] = sizeof(Stats);

    _kernel_swi(MPEGControl_Stats, &r, &r);

    /* note: R3 returns pointing to the end of the structure if successful; recommended coding style */

    if ( 0 < (r.r[3] - (int) &Stats) )
    {
      if (MPEGControl_Stats_NPT == Stats.Tag)
      {
        #ifdef MODULE_DEBUG
          dprintf(("", "RECEIVED %i BYTES OF DATA FROM STATS\n", Stats.DataLength));
        #endif

        sprintf(buffer, "Rx %i from Stats", Stats.DataLength);
        SetSystemVariable("OVCinfo$read_pos", buffer);

        if ((sizeof(Stats.Data) + sizeof(Stats.Flags) ) == Stats.DataLength)
        {
          /*
           * NOTE - the NPT here is a 33 bit signed integer! I have ignored bit 33
           * for the moment since we can't have negative times
           */

          npt = (Stats.Data[10] << 24) | (Stats.Data[11] << 16) | (Stats.Data[12] << 8) | Stats.Data[13];
          npt /= 90000; /* represents a 90 kHz clock */
        }
        else
        {
          if (sizeof(Stats.Flags) == Stats.DataLength)
          {
            #ifdef MODULE_DEBUG
              dprintf(("", "VSPovc:read_pos() - \neither no NPT available, or parsing not enabled (bit 10 of ctrlflags must be set)\n"));
            #endif

            SetSystemVariable("OVCerror$read_pos", "either no NPT available, or parsing not enabled (bit 10 of ctrlflags must be set)");
          }
          else
          {
            #ifdef MODULE_DEBUG
              dprintf(("", "VSPovc:read_pos() - strange descriptor length\n"));
            #endif

            SetSystemVariable("OVCerror$read_pos", "strange descriptor length");
          }
        }
      }
      else
      {
        #ifdef MODULE_DEBUG
          dprintf(("", "VSPovc:read_pos() - Tag word wrong (not 9)\n"));
        #endif

        SetSystemVariable("OVCerror$read_pos", "Tag word wrong (not 9)");
      }
    }
    else
    {
      #ifdef MODULE_DEBUG
        dprintf(("", "VSPovc:read_pos() - MPEGTrans module did not recognise tag 9\n"));
      #endif

      SetSystemVariable("OVCerror$read_pos", "MPEGTrans module did not recognise tag 9");
    }

    return npt;
  }

#else /* #ifndef USEOLDREAD_POS */

  unsigned int read_pos(void)
  {
    mkd_pos      pos;
    mzs_state    status;
    sb4          rate;
    unsigned int npt = 0;

    pos = mzs_stream_getPos(streamRef, &evs, streamInst, &status, &rate);

    if (status != mzs_statePause && status != mzs_stateStream)
    {
      endofstream = 1;
      return (0);
    }

    if (pos._u.mkd_posTimePos.mkd_posTimeHour > 0)
    {
      npt += pos._u.mkd_posTimePos.mkd_posTimeHour * SECONDS_PER_HOUR;
    }

    if (pos._u.mkd_posTimePos.mkd_posTimeMinute > 0)
    {
      npt += pos._u.mkd_posTimePos.mkd_posTimeMinute * SECONDS_PER_MINUTE;
    }

    npt += pos._u.mkd_posTimePos.mkd_posTimeSecond;
    return (npt);
  }

#endif /* #ifndef USEOLDREAD_POS */

/*************************************************/
/* EstimatePosition()                            */
/*                                               */
/* Takes the MPEG time, and compares it with the */
/* STB estimate.                                 */
/*                                               */
/* If the NPT value from the MPEG module more or */
/* less matches where the STB things it is for   */
/* switching to trick play modes from normal     */
/* play, that's OK. If not, use the STB estimate */
/* instead - this is because the NPT information */
/* in the normal play stream can be extremely    */
/* stale.                                        */
/*                                               */
/* "More-or-less" is defined via. MAXTIMINGERROR */
/* (see top of file).                            */
/*                                               */
/* Returns:    The NPT estimate to use (an       */
/*             unsigned int, giving time in      */
/*             seconds).                         */
/*************************************************/

unsigned int EstimatePosition(void)
{
  unsigned int BestEstimate;

  BestEstimate = read_pos() + 2; /* get MPEG estimate */

  if ((mzswrap_CurrentNPT - BestEstimate) > MAXTIMINGERROR)
  {
    /* STB estimate is probably closer; use it! */
    BestEstimate = mzswrap_CurrentNPT;

    #ifdef MODULE_DEBUG
      dprintf(("", "mzswrap:ovs_playcontrol() - using STB estimate\n"));
    #endif
  }

  #ifdef MODULE_DEBUG

    else
    {
      /* MPEG estimate appears more accurate; use it */
      dprintf(("", "mzswrap:ovs_playcontrol() - using MPEG estimate\n"));
    }

  #endif

  return BestEstimate;
}

/*************************************************/
/* local_npt()                                   */
/*                                               */
/* Keeps count of local time. Called on TickerV  */
/* (every 1 cs).                                 */
/*                                               */
/* Increments the global variable                */
/* mzswrap_CurrentNPT.                           */
/*************************************************/

void local_npt(void)
{
  if (streamInst != 0 && active.mode != MODE_PAUSE)
  {
    mzswrap_CurrentNPT += static_playrate / 1000; /* increment at the appropriate rate */
  }
}
