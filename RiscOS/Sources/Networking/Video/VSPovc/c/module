/*	MODULE.C

© Acorn Computers Ltd

Project : Acorn OVC

Purpose:


History:

Date      Who     Description of change
===========================================
25/6/98    CP     Header added

                  Modified to use auto-generated cmhg.h file

                  Converted all functions to ANSI style.

4/9/98     CP     Overhauled SWI handler, although forced to leave the longjmp
                  in place untouched.  It is now protected against
                  unused/unknown SWI numbers.

***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "debug.h"

#include "sys/types.h"
#include "stdio.h"
#include "vsp.h"
#include <sys/socket.h>
#include <socklib.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <inetlib.h>
#include <net/if.h>
#include <kernel.h>
#include <swis.h>
#include <setjmp.h>
#include "misc.h"

#include "cmhg.h"

/* exports from other C files */
#include "module.h"
#include "vspc.h"
#include "mzswrap.h"
/*#include "smnudp.h"*/

volatile int callbackflag = 0;

struct {
    int  e_nbr;
    char e_string[64];
} ebuf = { 0 };

struct eblock {
    int err_nbr;
    char *err_string;
};

struct eblock error_blocks[N_ERRORS] = {
    VSP_E_WRONGCTRL,   "Invalid play control value",
    VSP_E_UNKSERVER,   "Video server not known",
    VSP_E_INVHANDLE,   "Invalid stream handle",
    VSP_E_NOHANDLE,    "No stream handle available",
    VSP_E_NOMEMORY,    "No memory",
};

#define N_OVS_ERRORS 9

struct eblock ovs_error_blocks[N_OVS_ERRORS] = {
    1,   "Movie not found",
    2,   "Session allocation error",
    3,   "Insufficient network resources. Please try again later",
    4,   "Factory error",
    5,   "Prepare error",
    6,   "Play error",
    7,   "There has been a fatal error. Please reboot.",
    8,   "Invalid channel selection",
    999, "Can't contact video server",
};

extern _kernel_oserror *ovs_error(int); /* fixed prototype */


/* imports */
extern int mn_started;
extern void init_yoSysExMap(void);
extern void init_yoCorbaExTbl(void);


/* global variables */
int endofstream = 0;
int endofstream_timer = 0;
int endofstream_timeout = 0;
int mpeg_handle;
int currentop = 0;
char gw_phy_adr[64];
char dflt_gw_phy_adr[64];
int mnidle_timer = 0;
int boottime = 0;
int udpport = 0;
char destadr[128];
int ovs_vsscan_rate;
int ovs_slomo_rate;


/* static variables */

static void *module_wsp = 0;
static int is_atm_mpeg = 0;
static int save_optype = 0;
static char mpeg_vs_pvc[16];

static jmp_buf ljenv;
static int watchdog_timer = 0;
static int init_type = 0;
static int done_pvc = 0;

void set_watchdog_timer(void)
{
    watchdog_timer = WATCHDOG_TIMEOUT;
}

void clr_watchdog_timer(void)
{
    watchdog_timer = 0;
}

static int read_destadr(void)
{
    FILE *fp;
    int i;
    char line[256], adr[64], did[128], myadr[64];

    read_my_ip_address(myadr);

    if ((fp = fopen(DESTADRSFILE, "r")) == NULL)
    {
        return (0);
    }

    while(fgets(line, 100, fp) != NULL)
    {
        if (line[0] == '|') /* ignore comment lines */
        {
            continue;
        }

        i = sscanf(line, "%s %s", adr, did);

        if (i == 2 && strcmp(adr, myadr) == 0)
        {
          /* if 2 values read OK, and the 1st value matches STB IP address then
             set the destination address to be the value of the second value */

            strcpy(destadr, did);
            break;
        }
    }

    fclose(fp);
    return (1);
}

static int enable_tick_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = 100;
  r.r[1] = (int)tick_entry;
  r.r[2] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_CallEvery, &r, &r) != 0 ? -1 : 0);
}

_kernel_oserror *vsp_init(const char *cmd_tail, int pbase, void *pw)
{
    char buf[128];

    module_wsp = pw;
    if (read_sysvar("MPEG$EOSTimeout", buf, sizeof(buf)) != 0)
        endofstream_timeout = atoi(buf);
    if (read_sysvar("MPEG$DTType", buf, sizeof(buf)) == 0)
        return ((_kernel_oserror *)0);
    if (caseless_strcmp(buf, "ATM_AAL5") == 0)
        is_atm_mpeg = 1;
    if (read_sysvar("MPEG$UDPPort", buf, sizeof(buf)) != 0)
        udpport = atoi(buf);
    if (read_sysvar("MPEG$ATMpvc", buf, sizeof(buf)) != 0)
        strcpy(mpeg_vs_pvc, buf);
    if (read_sysvar("OMN_ADDR", dflt_gw_phy_adr, sizeof(dflt_gw_phy_adr)) == 0)
        return ((_kernel_oserror *)0);
    if (read_sysvar("OVS$ScanRate", buf, sizeof(buf)) != 0)
        ovs_vsscan_rate = atoi(buf);
    else
        ovs_vsscan_rate = OVS_VSSCAN_RATE;
    if (read_sysvar("OVS$SloMoRate", buf, sizeof(buf)) != 0)
        ovs_slomo_rate = atoi(buf);
    else
        ovs_slomo_rate = OVS_SLOWMO_RATE;
    boottime = time(0);
    destadr[0] = 0;
    (void) read_destadr();
    (void) enable_tick_handler();
    init_yoSysExMap();
    init_yoCorbaExTbl();
    init_yoSysExMap();
    init_yoCorbaExTbl();
    return ((_kernel_oserror *)0);
}

int read_my_ip_address(char *adr)
{
    char buf[512];
    struct ifconf ifc;
    struct ifreq ifreq, *ifr;
    struct sockaddr_in *sin;
    int s, n;

    if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
        return (0);
    ifc.ifc_len = sizeof (buf);
    ifc.ifc_buf = buf;
    if (socketioctl(s, SIOCGIFCONF, (char *)&ifc) < 0) {
        socketclose(s);
        return (0);
    }
    ifr = ifc.ifc_req;
    for (n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++) {
        ifreq = *ifr;
        if (socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0 || ifreq.ifr_flags & IFF_LOOPBACK)
            continue;
        if ((ifreq.ifr_flags & (IFF_BROADCAST|IFF_UP)) != (IFF_BROADCAST|IFF_UP))
            continue;
        if (socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0)
            continue;
        sin = (struct sockaddr_in *)&ifreq.ifr_addr;
        strcpy(adr, inet_ntoa (sin->sin_addr) );
        break;
    }
    socketclose(s);
    return (1);
}

static int callback(void (* func)())
{
    _kernel_swi_regs r;

    r.r[0] = (int)func;
    r.r[1] = (int)module_wsp;
    return (_kernel_swi(XOS_Bit | OS_AddCallBack, &r, &r) != 0 ? -1 : 0);
}

static void setcallback(void)
{
    if (callbackflag == 0) {
        callbackflag = 1;
        if (callback(callb_entry) != 0)
            callbackflag = 0;
    }
}


_kernel_oserror * tick_handler(_kernel_swi_regs *r, void *pw)
{
  if (!mn_started)
        return (NULL);
    if (watchdog_timer && --watchdog_timer == 0) {
       mn_started = 0;
       currentop = 999;
       return (NULL);
    }
    if (mnidle_timer && --mnidle_timer == 0) {
        /* post callback to do mnIdle() */
        setcallback();
    }
    if (endofstream_timer > 0 && --endofstream_timer == 0)
    {
#if !defined(NDEBUG) && defined(EOS)
      SetSystemVariable("OVCdebug$EOS", "normal timeout");
#endif
        endofstream = 1;
    }
    else
        local_npt();
    return (NULL);
}


static int disable_tick_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = (int)tick_entry;
  r.r[1] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_RemoveTickerEvent, &r, &r) != 0 ? -1 : 0);
}

_kernel_oserror * vsp_final(int fatal, int podule, void *pw)
{
   (void) disable_tick_handler();
   smnudpClose(0);
   return (0);
}

_kernel_oserror *ovs_error(int err)
{
    int i;

    if (!err)
        return ((_kernel_oserror *)0);
    for (i = 0; i < N_OVS_ERRORS; i++) {
        if (ovs_error_blocks[i].err_nbr == err) {
            ebuf.e_nbr = err;
            sprintf(ebuf.e_string, "%s\n", ovs_error_blocks[i].err_string);
            return ((_kernel_oserror *)&ebuf);
        }
    }
    ebuf.e_nbr = err;
    sprintf(ebuf.e_string, "Unspecified Error %d\n", err);
    return ((_kernel_oserror *)&ebuf);
}


/* debug SWI tracking */
struct LLint
{
   int SWInum;
   struct LLint *next;
};

struct LLint *SWIlistHead = NULL; /* start of list */
struct LLint *SWIlistTail = NULL; /* end of list, where you add next LLint */

_kernel_oserror *
vsp_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    int optype;
    _kernel_oserror *err = 0;

/* 4sep98:CP:set up longjmp to enter this conditional statement.  Dunno why this
   is being done. :-(
*/
    if ((optype = setjmp(ljenv)) != 0)
    {
        clr_watchdog_timer();
        save_optype = optype;

        if (optype == 999)
        {
            smnudpClose(0);
        }
        else
        {
#if !defined(NDEBUG) && defined(EOS)
          SetSystemVariable("OVCdebug$close", "ovs_closestream called from longjmp");
#endif
            (void) ovs_closestream();
        }

        return (ovs_error(optype));
    }

    set_watchdog_timer();


    switch (swinum)
    {
      case (VSP_OpenStream - VSP_00):
        err = OpenStream(r);
      break;

      case (VSP_CloseStream - VSP_00):
        err = CloseStream(r);
      break;

      case (VSP_CheckEndOfStream - VSP_00):
        err = CheckEndofStream(r);
      break;

      case (VSP_SetSpeed - VSP_00):
        err = SetSpeed(r);
      break;

      case (VSP_SetPosition - VSP_00):
        err = SetPosition(r);
      break;

      case (VSP_ReadNPT - VSP_00):
        err = ReadNPT(r);
      break;

      default:
        err = error_BAD_SWI;
      break;
    }

    clr_watchdog_timer();

    return (err);
}

void ovs_initstream(int handle, int skipcnt)
{
    _kernel_swi_regs r;

    if (is_atm_mpeg) {
        char video_host[6];
        int i;

        video_host[0] = 0; video_host[1] = 0;
        for (i = 2; i < 6; i++)
            video_host[i] = 1;
        r.r[0] = 0;
        r.r[1] = (int)video_host;
        r.r[2] = MPEG_PORT_AAL5;
        r.r[3] = handle;
        r.r[4] = 0;
        r.r[5] = 0;
        (void) _kernel_swi(XOS_Bit | StreamInitSWI_ATM, &r, &r);
        init_type = 1;
    }
    else {
        r.r[0] = 2;
        r.r[1] = 0;
        r.r[2] = 0;
        r.r[3] = handle;
        r.r[4] = skipcnt;
        (void) _kernel_swi(XOS_Bit | StreamInitSWI, &r, &r);
        init_type = 2;
    }
}

_kernel_oserror *vsp_error(int err)
{
    int i;

    if (!err)
        return ((_kernel_oserror *)0);
    for (i = 0; i < N_ERRORS; i++) {
        if (error_blocks[i].err_nbr == err) {
            ebuf.e_nbr = err;
            strcpy(ebuf.e_string, error_blocks[i].err_string);
            return ((_kernel_oserror *)&ebuf);
        }
    }
    ebuf.e_nbr = err;
    sprintf(ebuf.e_string, "Unspecified error %d\n", err);
    return ((_kernel_oserror *)&ebuf);
}


#define MPEGControl_Stats           0x492c9

int tags[2];
int stats[3];

int mpeg_streamcount (int handle)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    tags[0] = 0;  /* tag value for amount received by ctrl module */
    tags[1] = -1; /* terminator */

    stats[2] = -1;  /* default value */

    r.r[0] = 0;
    r.r[1] = handle;
    r.r[2] = (int)tags;
    r.r[3] = (int)stats;
    r.r[4] = 12;
    e = _kernel_swi(XOS_Bit | MPEGControl_Stats, &r, &r);
    return (stats[2]);
}

static void do_cli(char *str)
{
    _kernel_swi_regs r;

    r.r[0] = (int)str;
    (void) _kernel_swi(XOS_Bit | OS_CLI, &r, &r);
}

void ovs_initmpegpvc(void)
{
    char buf[48];

    if (is_atm_mpeg) {
        done_pvc = 1;
        sprintf(buf, "atm25pvc 1.1.1.1 32 %s", mpeg_vs_pvc);
        do_cli(buf);
    }
}

int read_sysvar(char *var, char *buf, int buflen)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    r.r[0] = (int)var;
    r.r[1] = (int)buf;
    r.r[2] = buflen;
    r.r[3] = 0;
    r.r[4] = 0;
    e = _kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r);
    if (e || r.r[2] == 0)
        return (0);
    buf[r.r[2]] = 0;
    return (1);
}


_kernel_oserror * callb_handler(_kernel_swi_regs *rr, void *pw)
{
    if (callbackflag == 0)
        return (NULL);
    /* SCormie (06-Oct-98): Fix data abort problem if call back is set by ticker going off */
    /* during VSP_CloseStream (shouldn't call mnIdle() if stream is now closed -
       only call it if mn_started flag is set).           */
    if (mn_started)
    {
        mnIdle();
        mnidle_timer = MNIDLE_TIMEOUT;
    }
    callbackflag = 0;
    return (NULL);
}


void ovcabort(void)
{
    longjmp(ljenv, currentop);
}
