/**************************************************************/
/* File:    LVFCtrl.c                                         */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Control the LVFmip module.                        */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 01-Jun-2000 (ADH): Imported to LVF Generic.       */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>

#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <socklib.h>
#include <inetlib.h>
#include <netinet/in.h>

#include <Global/SWIs.h>
#include <MPEG/MPEGCtrl.h>
#include <VideoCtrl.h> /* Exported by VideoCtrl's !MkExport */

#include "Buffers.h"
#include "CallOut.h"
#include "LVFGErrors.h"
#include "LVFGHdr.h"
#include "Module.h"
#include "MPEGCtrl.h"
#include "Session.h"
#include "Status.h"
#include "Utils.h"

#include "LVFCtrl.h"

/* Local functions */

static _kernel_oserror * lvfctrl_read_block (session * s);

/**************************************************************/
/* lvfctrl_open_stream()                                      */
/*                                                            */
/* Open a multicast stream with LVF_OpenStream, if one is not */
/* already open.                                              */
/*                                                            */
/* Parameters: Pointer to a session struct relevant to the    */
/*             new stream.                                    */
/**************************************************************/

_kernel_oserror * lvfctrl_open_stream(session * s)
{
  if (s->running == 0)
  {
    buffers_allocate_main_buffer(s);
    if (s->carrier.buffer == NULL) return make_error(lvfgeneric_ERROR_MEMORY_EXHAUSTED, 0);

    RetError(lvfctrl_read_block(s));
  }

  return NULL;
}

/**************************************************************/
/* lvfctrl_close_stream()                                     */
/*                                                            */
/* Close a multicast stream with LVF_CloseStream.             */
/*                                                            */
/* Parameters: Pointer to a session struct relevant to the    */
/*             existing stream.                               */
/**************************************************************/

_kernel_oserror * lvfctrl_close_stream(session * s)
{
  /* Cancel any pending callback */

  if (s->running != 0)
  {
    s->running = 0;
    untimeout(lvfctrl_callout_handler, s);
  }

  /* Shut an open file if we have one */

  if (s->open != 0)
  {
    unsigned int temp = s->open;

    s->open = 0;

    _swix(OS_Find,
          _INR(0,1),

          0,
          temp);
  }

  /* Free the buffer */

  buffers_free_main_buffer(s);

  return NULL;
}

/**************************************************************/
/* lvfctrl_callout_handler()                                  */
/*                                                            */
/* Prepare to read more file data.                            */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: Pointer to session struct to use, as a void *. */
/**************************************************************/

void lvfctrl_callout_handler(void * handle)
{
  _kernel_oserror * e;
  session         * s = (session *) handle;

  if (s->running != 0)
  {
    /* Clear the expecting flag and call the file read routine */

    s->running = 0;

    e = lvfctrl_read_block(s);

    if (e != NULL)
    {
      utils_store_error(e);
      s->state = protostate_ERROR_OS;

      /* This is a background generated error. It isn't really right to */
      /* call VideoControl_ProtocolNotify 0 as that will end up raising */
      /* Service_VideoControl 2, which is meant to be based on a        */
      /* request->response model. So, instead, we call the server       */
      /* message SWI, and flag that we've told Video Control. Astute    */
      /* player clients may spot our error; if not, they'll get given   */
      /* it next time they cause the state machine to tick anyway.      */

      if (s->reported == 0)
      {
        s->reported = 1;

        _swix(VideoControl_ProtocolNotify,
              _INR(0,3),

              0,
              s->id,
              VideoControlProtocolNotifyMessageReceived, /* Well, sort of - our 'server' is the RISC OS file access interface, which has given some error */
              0);
      }
    }
  }

  return;
}

/**************************************************************/
/* lvfctrl_read_block()                                       */
/*                                                            */
/* Read more file data, setting a callback if there's more    */
/* left afterwards.                                           */
/*                                                            */
/* Parameters: Pointer to the session to read for.            */
/**************************************************************/

static _kernel_oserror * lvfctrl_read_block(session * s)
{
  bool restart_ok = s->restart_ok;

  if (restart_ok) s->restart_ok = 0;

  /* Don't do anything file-related unless we're not paused and */
  /* we've cleared the pending restart condition.               */

  if (s->restart == 0 && s->lastplay != MPEGCtrl_MCRS_Trick_Freeze)
  {
    bs_buffer    * buf = NULL;
    unsigned int   pointer,   extent;
    unsigned int   remaining, read;

    /* Open the file if we need to */

    if (s->open == 0)
    {
      if (s->filename == NULL)
      {
        return make_error(lvfgeneric_ERROR_CANNOT_OPEN_FILE, 1, "");
      }
      else
      {
        RetError(_swix(OS_Find,
                       _INR(0,1) | _OUT(0),

                       0x4F, /* Open file read-only, no path */
                       s->filename,

                       &s->open));

        /* SWI should've return an error if the open failed, but just in case... */

        if (s->open == 0) return make_error(lvfgeneric_ERROR_CANNOT_OPEN_FILE, 1, s->filename);
      }
    }

    /* Restarting? */

    if (restart_ok)
    {
      /* Yes, so set file pointer back to zero */

      RetError(_swix(OS_Args,
                     _INR(0,2),

                     1,       /* Write file pointer */
                     s->open,
                     0));

      pointer = 0;
    }
    else
    {
      /* Not restarting, so read the file pointer */

      RetError(_swix(OS_Args,
                     _INR(0,1) | _OUT(2),

                     0,       /* Read file pointer */
                     s->open,

                     &pointer));
    }

    /* How much do we read? */

    RetError(_swix(OS_Args,
                   _INR(0,1) | _OUT(2),

                   2,       /* Read file extent */
                   s->open,

                   &extent));

    remaining = extent - pointer;

    /* Handle looping and telling other people about the end of stream */

    if (remaining == 0)
    {
      if (s->loop != 0)
      {
        RetError(_swix(OS_Args,
                       _INR(0,2),

                       1,       /* Write file pointer */
                       s->open,
                       0));

        remaining = extent;
      }
      else
      {
        _swix(VideoControl_ProtocolNotify,
              _INR(0,3),

              0,
              s->id,
              VideoControlProtocolNotifyNewPlayState,
              vc_play_state_normal_eos);
      }
    }

    if (remaining >= Buffers_BlockSize) read = Buffers_BlockSize;
    else                                read = remaining;

    /* Get a block from the buffer manager */

    if (read > 0) buf = buffers_claim_bs_buffer(s, read + sizeof(bs_buffer));

    if (buf != NULL)
    {
      char * bptr = ((char *) buf) + sizeof(bs_buffer);

      buf->bs_next    = NULL;                   /* We don't use this, the MPEG software does.       */
      buf->bs_handle  = 0;                      /* If zero, flags = SWI to call...                  */
      buf->bs_flags   = LVFGeneric_EmptyBuffer; /* ...so call LVFGeneric_EmptyBuffer please.        */
      buf->bs_packets = 0;                      /* Must be zero on entry to MPEGControl_FullBuffers */
      buf->bs_data    = bptr;
      buf->bs_offset  = buf->bs_data;
      buf->bs_len     = read;                   /* We rely on this being intact at all times.       */
      buf->bs_session = s;                      /* This is also essential.                          */

      /* Read a chunk */

      RetError(_swix(OS_GBPB,
                     _INR(0,3),

                     4,
                     s->open,
                     buf->bs_data,
                     read));

      /* Send it to the MPEG software */

      RetError(_swix(MPEGControl_FullBuffers,
                     _INR(0,2),

                     0,
                     s->mpegid,
                     buf));
    }
  }

  /* Set a new callback if required. Errors generated by SWIs   */
  /* above should always exit prior to this, to avoid a cascade */
  /* of repeating error reports.                                */

  if (s->running == 0)
  {
    timeout(lvfctrl_callout_handler, s, LVFCtrl_CalloutDelay);
    s->running = 1;
  }

  return NULL;
}
