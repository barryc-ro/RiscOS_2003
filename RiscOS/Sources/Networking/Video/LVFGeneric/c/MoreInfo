/**************************************************************/
/* File:    MoreInfo.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement LVFGeneric_MoreInformation.             */
/*                                                            */
/* Author:  A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 01-Jun-2000 (ADH): Imported to LVF Generic.       */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "LVFGErrors.h"
#include "Module.h"
#include "Session.h"
#include "Utils.h"

#include "MoreInfo.h"

/**************************************************************/
/* moreinfo_more_information()                                */
/*                                                            */
/* Implement LVFGeneric_MoreInformation. See the Video        */
/* Control specification, 2501,817/FS, for more.              */
/**************************************************************/

_kernel_oserror * moreinfo_more_information(_kernel_swi_regs * r)
{
  session * s = session_find_by_id(r->r[1]);

  dprintf(("", "moreinfo_more_information called for %08X\n", r->r[1]));

  if (s == NULL)
  {
    dprintf(("", "moreinfo_more_information: ID not found\n"));

    return make_error(lvfgeneric_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  if (r->r[2] == 0)
  {
    /* Read buffer size required */

    if (s->state == protostate_COMPLETED) r->r[0] = s->data_len;
    else                                  r->r[0] = 0;

    return NULL;
  }
  else if (r->r[2] == 1)
  {
    /* Write into given buffer. R3 = buffer address, R4 = size */

    if (
         s->state != protostate_COMPLETED ||
         r->r[3] == 0                     ||
         r->r[4] < 1
       )
    {
      r->r[0] = r->r[1] = 0;
    }
    else
    {
      int copy;

      if (r->r[4] > s->data_len) copy = s->data_len;
      else                       copy = r->r[4];

      memcpy((void *) r->r[3], s->data, copy);

      if (copy < s->data_len)
      {
        void * newdata;

        memmove(s->data, s->data + copy, s->data_len - copy);
        s->data_len -= copy;

        newdata = realloc(s->data, copy);
        if (newdata != NULL) s->data = newdata;
      }
      else
      {
        /* Interrupt-safe */

        void * f = s->data;

        s->data     = NULL;
        s->data_len = 0;

        free(f);
      }

      r->r[0] = s->data_len;
      r->r[1] = copy;
    }
  }

  return NULL;
}
