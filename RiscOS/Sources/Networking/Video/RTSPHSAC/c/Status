/**************************************************************/
/* File:    Status.c                                          */
/*          (C) 2002 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPHSAC_Status and handle the state    */
/*          machine.                                          */
/*                                                            */
/* Author:  A.D.Hodgkinson. Partially based on URL_Fetcher    */
/*          source by S.N.Brodie and P.Wain.                  */
/*                                                            */
/* History: 08-Nov-1999 (ADH): Created.                       */
/*          02-Dec-1999 (ADH): Extended to handle the state   */
/*                             machine as well as the status  */
/*                             SWI call.                      */
/*          25-Jul-2002 (ADH): Imported to RTSP HSAC from     */
/*                             RTSP OVS.                      */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>

#include <swis.h>

#include <inetlib.h>
#include <socklib.h>
#include <unixlib.h>
#include <sys/errno.h>

#ifndef ENOERROR
  #define ENOERROR 0
#endif

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "Announce.h"
#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "Global.h"
#include "Headers.h"
#include "Module.h"
#include "MPEGCtrl.h"
#include "Play.h"
#include "RTSPHErrors.h"
#include "RTSPHHdr.h"
#include "Session.h"
#include "Setup.h"
#include "Utils.h"

#include "Status.h"

/* Local options */

#undef DUMP_HEADERS_TO_CACHEFS

/*
 * #define DUMP_HEADERS_TO_CACHEFS "Cache:$.Test"
 */

/* Local variables */

static _kernel_oserror final;
static char            recbuf[2048];

/* Local functions */

static bool status_proceed_completed (session * s, bool * repeat);
static bool status_proceed_connected (session * s, bool * repeat);
static bool status_proceed_default   (session * s, bool * repeat);
static bool status_proceed_dns       (session * s, bool * repeat);
static bool status_proceed_error     (session * s, bool * repeat);
static bool status_proceed_initial   (session * s, bool * repeat);
static bool status_proceed_receiving (session * s, bool * repeat);
static bool status_proceed_sending   (session * s, bool * repeat);
static bool status_proceed_sent      (session * s, bool * repeat);
static bool status_proceed_waiting   (session * s, bool * repeat);
static bool status_check_headers     (session * s);


/**************************************************************/
/* status_status()                                            */
/*                                                            */
/* Implement RTSPHSAC_Status. See the Video Control           */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * status_status(_kernel_swi_regs * r)
{
  _kernel_oserror * e = NULL;
  session         * s = session_find_by_id(r->r[1]);

  dprintf(("Entry_2", "status_status: Called\n"));

  if (!s)
  {
    dprintf(("Error_0", "status_status: ID not found\n"));
    return make_error(rtsphsac_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  /* If we have no command queue, return the real state */

  if (s->next_command_cb == NULL)
  {
    r->r[0] = s->reported_state;
    r->r[2] = s->response_code;
  }

  /* Otherwise, return a "connected and waiting" indication */

  else
  {
    r->r[0] = VC_Status_ConnectionEstablished;
    r->r[2] = 0;
  }

  /* Any asynchronous messages? */

  if (s->async_msg_list != NULL)
    r->r[0] |= VC_Status_AsyncMessageReceived;

  /* Error, or normal state? */

  e = status_check_error(s);

  /* Any asynchronous error? */

  if (e == NULL)
    e = s->async_error;

  dprintf(("Entry_2", "status_status: Returning status %08x, response %d, error %p\n", r->r[0], r->r[2], e));

  return e;
}

/**************************************************************/
/* status_send()                                              */
/*                                                            */
/* Once a session has been fully initialised with all the     */
/* data needed to send a command, kick off the send.          */
/*                                                            */
/* This is normally the last thing done in a function that    */
/* needs to issue a command to a server.                      */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

_kernel_oserror * status_send(session * s)
{
  dprintf(("", "status_send: Called for &%08X\n", (int) s));

  /* Open a connection to send the command down, if not already opened */

  if (s->sd < 0)
  {
    int port;

    /* A child session must have a valid socket (its parent's). If not, */
    /* it's a programming error.                                        */

    if (s->parent != NULL)
      return make_error(rtsphsac_ERROR_CONNECT_WRITE, 1, "No child socket");

    if (s->url->port && *s->url->port) port = atoi(s->url->port);
    else                               port = RTSPHSAC_DefaultPort;
   
    s->last = utils_read_time();

    s->sd = opensock(s->url->host,
                     port,
                     NULL,
                     &s->state,
                     -1);

    if (s->child != NULL)
      s->child->sd = s->sd;

    if (s->state == protostate_ERROR) s->err_no = -s->sd;
  }
  else s->state = protostate_CONNECTED;

  dprintf(("", "status_send: Socket descriptor %d, state %d\n", s->sd, s->state));

  /* Set the state machine going to see errors and DNS stuff. The callout  */
  /* will normally always be cleared already when this function is called. */

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  dprintf(("", "status_send: Successful\n"));

  return NULL;
}

/**************************************************************/
/* status_proceed_on_callout()                                */
/*                                                            */
/* A CallOut handler (see CallOut.h) which drives the state   */
/* machine. Used for anything that can't be event driven,     */
/* such as waiting for a DNS lookup to complete.              */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void status_proceed_on_callout(void * handle)
{
  session * s = (session *) handle;

  dprintf(("State_0", "status_proceed_on_callout: Called for %p, forwarding to status_proceed\n", s));

  if (s->dying != 0) return;

  if (s->callout_set != 0)
  {
    s->callout_set = 0;
    status_proceed(s);
  }
}

/**************************************************************/
/* status_proceed()                                           */
/*                                                            */
/* Main module state machine.                                 */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: Pointer to the session struct to work for.     */
/**************************************************************/

void status_proceed(session * s)
{
  bool repeat;

  dprintf(("State_0", "status_proceed: Called for %p\n", s));

  do
  {
    repeat = false;

    switch (s->state)
    {
      default:
      {
        if (status_proceed_default(s, &repeat)) return;
      }
      break;

      /* Error states: Various things went wrong... */

      case protostate_ERROR:
      case protostate_ERROR_DEAD:
      case protostate_ERROR_MEM:
      case protostate_ERROR_WRITE:
      case protostate_ERROR_READ:
      case protostate_ERROR_CONNECTION:
      case protostate_ERROR_NO_TOKEN:
      case protostate_ERROR_NOT_IMPLEMENTED:
      case protostate_ERROR_TIMEOUT:
      case protostate_ERROR_DNS:
      case protostate_ERROR_VCPN:
      {
        if (status_proceed_error(s, &repeat)) return;
      }
      break;

      /* Idle */

      case protostate_INITIAL:
      {
        if (status_proceed_initial(s, &repeat)) return;
      }
      break;

      /* After calling opensock (Connect.c) to kick things off, we're */
      /* waiting for DNS lookup to complete.                          */

      case protostate_DNS:
      {
        if (status_proceed_dns(s, &repeat)) return;
      }
      break;

      /* DNS is complete, and we're connected. Well, almost, could still try to */
      /* send down the socket and get ENOTCONN for a while...! At this point,   */
      /* call any connection callback function immediately, add in a sequence   */
      /* header, and move to a SENDING state to send the command off.           */

      case protostate_CONNECTED:
      {
        if (status_proceed_connected(s, &repeat)) return;
      }
      break;

      /* We are ready to send, but must wait if a parent or child  */
      /* is already in the sending state.                          */

      case protostate_WAITING:
      {
        if (status_proceed_waiting(s, &repeat)) return;
      }
      break;

      /* Whilst we could still be in an ENOTCONN state, the state machine */
      /* is way ahead and will be issuing socket_write calls.             */

      case protostate_SENDING:
      {
        if (status_proceed_sending(s, &repeat)) return;
      }
      break;

      /* As soon as a full command is sent, we start listening for a response */

      case protostate_RECEIVING:
      case protostate_RECEIVING_ASYNC:
      {
        if (status_proceed_receiving(s, &repeat)) return;
      }
      break;

      /* Once a response (rather than a command) has been sent, check to */
      /* see if any more responses are waiting to be sent.               */

      case protostate_SENT:
      {
        if (status_proceed_sent(s, &repeat)) return;
      }
      break;

      case protostate_COMPLETED:
      {
        if (status_proceed_completed(s, &repeat)) return;
      }
      break;
    }
  }
  while (repeat);

  /* If we've got a server session, no callout set and a timeout value, */
  /* set a callout to keep the session up (ensuring we're idling).      */

  if (
          s->parent         == NULL
       && s->state          == protostate_INITIAL
       && s->ping_set       == 0
       && s->server_session != NULL
       && s->server_timeout != 0
     )
  {
    dprintf(("State_1","status_proceed: Setting server ping callout\n"));

    s->ping_set = 1;
    timeout(status_ping_on_callout, s, s->server_timeout);
  }

  dprintf(("State_0", "status_proceed: Successful\n"));
}

/**************************************************************/
/* status_proceed_default()                                   */
/*                                                            */
/* State machine handler for an unknown state.                */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_default(session * s, bool * repeat)
{
  dprintf(("State_0,Error_0", "status_proceed_default: UNKNOWN STATE %d ENTERED\n", s->state));

  s->state = protostate_COMPLETED;
  *repeat  = true;

  return false;
}

/**************************************************************/
/* status_proceed_error()                                     */
/*                                                            */
/* State machine handler for any error state.                 */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_error(session * s, bool * repeat)
{
  (void)repeat;
  
  dprintf(("State_0,Error_0", "status_proceed_error: General error\n"));

  if (s->destruct)
  {
    dprintf(("State_0,Error_0", "status_proceed_error: Session self-destructing (on error), state machine exitting\n"));
    session_free_item(s);
    return true;
  }
  else
  {
    /* Video Control needs to know about this... */

    if (s->parent == NULL)
    {
      /* This is the main session - report a new status */

      if (s->reported == 0 && s->id != 0)
      {
        s->reported = 1;
  
        _swix(VideoControl_ProtocolNotify,
              _INR(0,3),
  
              0,
              s->id,
              VideoControlProtocolNotifyNewStatus,
              0);

        dprintf(("State_0,Error_0", "status_proceed_error: Main session error - notified Video Control of new status\n"));
      }
    }
    else if (s->parent->parent == NULL)
    {
      /* This is the child session, so the error occurred when receiving  */
      /* an asynchronous message. Report this as an asynchronous message. */

      if (s->parent->id != 0)
      {
        _swix(VideoControl_ProtocolNotify,
              _INR(0,2),
  
              0,
              s->parent->id,
              VideoControlProtocolNotifyMessageReceived);

        dprintf(("State_0,Error_0", "status_proceed_error: Child session error - notified Video Control of async message\n"));
      }

      /* Record the error in the parent session to be returned through */
      /* the next call to RTSPHSAC_Status.                             */

      s->parent->async_error = status_check_error(s);

      /* Set the child to start listening again. */

      session_reset_session(s);
      s->state = protostate_RECEIVING_ASYNC;
    }

    /* Clear the change pending flag - whatever was pending has failed */

    s->change_pending = 0;
  }

  return false;
}

/**************************************************************/
/* status_proceed_initial()                                   */
/*                                                            */
/* State machine handler for an initial (idling) state.       */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_initial(session * s, bool * repeat)
{
  (void)s;
  (void)repeat;
  
  dprintf(("State_0", "status_proceed_initial: Initial state\n"));

  return false;
}

/**************************************************************/
/* status_proceed_dns()                                       */
/*                                                            */
/* State machine handler for a DNS (resolving) state: "After  */
/* calling opensock (Connect.c) to kick things off, we're     */
/* waiting for DNS lookup to complete".                       */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_dns(session * s, bool * repeat)
{
  int port;

  dprintf(("State_0", "status_proceed_dns: DNS; recalling opensock\n"));

  if (s->url->port && *s->url->port) port = atoi(s->url->port);
  else                               port = RTSPHSAC_DefaultPort;

  s->sd = opensock(s->url->host,
                   port,
                   NULL,
                   &s->state,
                   s->sd);

  /* The child gets the parent's socket descriptor */

  if (s->child != NULL)
    s->child->sd = s->sd;

  /* If we're still in the DNS state, set another callout. Otherwise we */
  /* have to wait until the Internet event handler gets triggered when  */
  /* the socket gets connected.                                         */

  if (s->sd < 0 || s->state == protostate_DNS)
  {
    unsigned now = utils_read_time();

    if (s->state == protostate_ERROR) s->err_no = -s->sd;

    dprintf(("State_1", "status_proceed_dns: Still in DNS state / sd < 0\n"));

    /* Check timeout */

    if (utils_time_difference(s->last, now) > Headers_Timeout_General)
    {
      dprintf(("State_0,Error_0", "status_proceed_dns: DNS timeout\n"));

      s->state = protostate_ERROR_TIMEOUT;
      *repeat  = true;
    }
    else if (s->callout_set == 0)
    {
      dprintf(("State_1", "status_proceed_dns: Setting a %dcs callout for DNS lookup\n", Session_State_Timer));

      s->callout_set = 1;
      timeout(status_proceed_on_callout, s, Session_State_Timer);
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_connected()                                 */
/*                                                            */
/* State machine handler for a connected (post-DNS, but could */
/* be waiting for actual connection) state: "DNS is complete, */
/* and we're connected. Well, almost, could still try to send */
/* down the socket and get ENOTCONN for a while...! At this   */
/* point, call any connection callback function immediately,  */
/* add in a sequence header, and move to a SENDING state to   */
/* send the command off".                                     */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_connected(session * s, bool * repeat)
{
  /* Socket is connected. Compile our command data into a continuous block */
  /* and move to a "sending" state.                                        */

  dprintf(("State_0", "status_proceed_connected: Connected\n"));

  s->last = utils_read_time();

  if (s->connected_cb != NULL)
  {
    dprintf(("State_1", "status_proceed_connected: Calling callback function.\n"));

    // And we do what exactly with errors...?

    s->connected_cb(s);
    s->connected_cb = NULL;
  }

  /* Compile the headers into a continuous block for sending */

  s->reqlen = headers_construct_header_buffer(s, s->data_len, s->response_code);

  if (s->full_request != NULL)
  {
    /* If there's body data, include it */

    if (s->data_len > 0)
    {
      memcpy(s->full_request + s->reqlen, s->data, s->data_len);
      s->reqlen += s->data_len;

      /* We're always over-allocated by 1 to allow for a NUL terminator, keeps */
      /* things tidy elsewhere (see function header comments in Headers.c).    */

      (s->full_request)[s->reqlen] = '\0';
    }

    dprintf(("State_1,RTSP_0", "status_proceed_connected: Command buffer compiled -\n'%s'\n",s->full_request));

    s->state = protostate_WAITING;
    *repeat  = true;
  }

  return false;
}

/**************************************************************/
/* status_proceed_waiting()                                   */
/*                                                            */
/* State machine handler for a waiting to send state:         */
/* "We are ready to send, but must wait if a parent or child  */
/* is already in the sending state."                          */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_waiting(session * s, bool * repeat)
{
  session * other;
  bool      wait = false;

  dprintf(("State_0", "status_proceed_waiting: Called\n"));

  /* Check our child and below */

  for (other = s->child; other; other = other->child)
  {
    if (other->state == protostate_SENDING || other->state == protostate_SENT)
    {
      wait = true;
      break;
    }
  }

  if (!wait)
  {
    /* Check our parent and above */

    for (other = s->parent; other; other = other->parent)
    {
      if (other->state == protostate_SENDING || other->state == protostate_SENT)
      {
        wait = true;
        break;
      }
    }
  }

  if (wait)
  {
    if (s->callout_set == 0)
    {
      dprintf(("State_1", "status_proceed_waiting: Setting a %dcs callout for waiting\n", Session_State_Retry));

      s->callout_set = 1;
      timeout(status_proceed_on_callout, s, Session_State_Retry);
    }
  }
  else
  {
    dprintf(("State_1", "status_proceed_waiting: No need to wait - moving to SENDING\n"));

    s->state = protostate_SENDING;
    *repeat  = true;
  }

  return false;
}

/**************************************************************/
/* status_proceed_sending()                                   */
/*                                                            */
/* State machine handler for a sending state: "Whilst we      */
/* could still be in an ENOTCONN state, the state machine is  */
/* way ahead and will be issuing socket_write calls".         */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_sending(session * s, bool * repeat)
{
  int    sent;
  time_t now;

  /* We're sending a command out */

  /* Cancel any outstanding server ping callout */

  if (s->ping_set != 0)
  {
    s->ping_set = 0;
    untimeout(status_ping_on_callout, s);
  }

  dprintf(("State_0,RTSP_5", "status_proceed_sending: Sending (%d of %d done so far) to socket %d...\n", s->reqptr, s->reqlen, s->sd));

  sent = socketwrite(s->sd,
                     s->full_request + s->reqptr,
                     s->reqlen - s->reqptr);

  dprintf(("State_1,RTSP_5", "status_proceed_sending: ...sent %d this time\n", sent));

  now = utils_read_time();

  if (sent <= 0)
  {
    /* No data was sent */

    if ( sent  == 0           ||
         errno == ENOTCONN    ||
         errno == EWOULDBLOCK
       )
    {
      /* Check timeout and retry */

      if (utils_time_difference(s->last, now) > Headers_Timeout_General)
      {
        s->state = protostate_ERROR_TIMEOUT;
        *repeat  = true;
      }
      else if (s->callout_set == 0)
      {
        dprintf(("State_1,RTSP_5", "status_proceed_sending: Setting %dcs callout for send timeout\n", Session_State_Retry));

        s->callout_set = 1;
        timeout(status_proceed_on_callout, s, Session_State_Retry);
      }
    }
    else
    {
      /* An error occurred */

      dprintf(("State_1,RTSP_0,Error_0", "status_proceed_sending: Error %d\n", errno));

      s->state  = protostate_ERROR_WRITE;
      s->err_no = errno;
      *repeat   = true;
    }
  }
  else
  {
    /* Some data was sent */

    s->reported_state |= VC_Status_ConnectionEstablished;
    s->last            = now;
    s->reqptr         += sent;

    #ifdef DUMP_HEADERS_TO_CACHEFS
    {
      FILE * f = fopen(DUMP_HEADERS_TO_CACHEFS, "ab");
 
      if (f != NULL)
      {
        fprintf(f, "SEND (%p):\r\n", s);
        fwrite(s->full_request, 1, s->reqlen, f);
        fclose(f);
      }
    }
    #endif

    if (s->reqptr >= s->reqlen)
    {
      dprintf(("State_1,RTSP_2", "status_proceed_sending: Full message sent\n"));

      /* If response_code is non-zero it means we were sending a response */
      /* to a server message (i.e. ANNOUNCE), so we've now finished.      */
      /* Otherwise, we've just sent a command and must now wait for a     */
      /* response.                                                        */

      if (s->response_code != 0)
      {
        dprintf(("State_1,RTSP_2", "SENT\n"));

        s->state = protostate_SENT;
      }
      else
      {
        dprintf(("State_1,RTSP_2", "RECEIVING\n"));

        s->last = now;
  
        free(s->full_request), s->full_request = NULL;
        s->reqptr = s->reqlen = 0;
  
        /* We'll read into s->data, so don't forget to clear anything lying */
        /* around in there from the request we sent.                        */
  
        free(s->data), s->data = NULL;
        s->data_len = 0;
        s->data_to_read = -1;
  
        s->state = protostate_RECEIVING;
      }
      *repeat  = true;
    }
    else
    {
      /* Some data left to send - try again */

      *repeat  = true;
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_receiving()                                 */
/*                                                            */
/* State machine handler for a receiving state: "As soon as a */
/* full command is sent, we start listening for a response".  */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_receiving(session * s, bool * repeat)
{
  int          ret;
  unsigned int now = utils_read_time();

  dprintf(("State_0,RTSP_6", "status_proceed_receiving: Receiving\n"));

  /* For the child session, start the timeout time from when the first */
  /* data arrives.                                                     */

  if (s->parent != NULL && s->data_len == 0)
    s->last = now;

  for (;;)
  {
    ret = socketread(s->sd,
                     recbuf,
                     sizeof(recbuf));

    dprintf(("State_1,RTSP_6", "status_proceed_receiving: Retrieved %d, existing data length is %d\n", ret, s->data_len));

    /* If we get > 0, we read data successfully */

    if (ret > 0)
    {
      char * new_data = module_realloc(s->data, s->data_len + ret + 1);

      s->last = now;

      if (new_data == NULL)
      {
        dprintf(("State_0,RTSP_0,Error_0", "status_proceed_receiving: Can't realloc for receive\n"));

        s->state = protostate_ERROR_MEM;
        *repeat  = true;

        return false;
      }
      else
      {
        dprintf(("State_1,RTSP_6", "status_proceed_receiving: Read %d bytes, realloced to %d\n", ret, s->data_len + ret + 1));

        s->data = new_data;
        memcpy(s->data + s->data_len, recbuf, ret);
        s->data_len += ret; /* data_len always lags 1 byte behind actual allocation */

        if (s->data_to_read > 0)
        {
          s->data_to_read -= ret;

          dprintf(("State_1,RTSP_6", "status_proceed_receiving: %d bytes of data left to read\n", s->data_to_read));

          /* If s->data_to_read has reduced to 0 it means we have read the   */
          /* whole message, up to the length specified in the Content-Length */
          /* header field, so exit the read loop.                            */

          if (s->data_to_read <= 0) break;
        }
      }
    }
    else if (ret == 0 && s->data_len == 0)
    {
      /* We've received an empty message */

      dprintf(("State_0,RTSP_0", "status_proceed_receiving: Empty response\n"));

      /* Empty messages for the parent are treated as an error. For the */
      /* child they are ignored.                                        */

      if (s->parent == NULL)
      {
        s->state  = protostate_ERROR_READ;
        s->err_no = ENOERROR;
        *repeat = true;
      }

      return false;
    }
    else  /* when ret <= 0 */
    {
      /* If we now have some data, and haven't parsed the headers yet, */
      /* see if we can do it now.                                      */

      if (s->data_len != 0 && s->data_to_read == -1)
      {
        /* Force a terminator at the end - we're expecting no binary data so */
        /* this ensures correct termination and makes life easier.           */

        s->data[s->data_len] = '\0'; /* Correct as data_len is always 1 byte behind actual allocation */

        /* Have we read in all the headers yet? */

        if (strstr(s->data, "\r\n\r\n") != NULL || ret == 0)
        {
          dprintf(("State_1,RTSP_6", "status_proceed_receiving: All headers read\n"));

          /* We have all the headers, so parse them and set s->data_to_read */
          /* to the amount of data still to be read for this message.       */

          if (!status_check_headers(s))
          {
            s->state = protostate_ERROR_MEM;
            *repeat = true;
            return false;
          }

          /* Is there any body data left to be read? Exit read loop if not. */

          if (s->data_to_read == 0) break;
        }
      }

      if (ret == 0)
      {
        /* Give up reading more data if 0 was returned. */

        break;
      }
      else if (errno != EWOULDBLOCK)
      {
        s->state  = protostate_ERROR_READ;
        s->err_no = errno;
        *repeat   = true;

        dprintf(("State_0,RTSP_0,Error_0", "status_proceed_receiving: Error = %d\n", errno));
      }
      else
      {
        /* Check timeout */

        if (utils_time_difference(s->last, now) > Headers_Timeout_General)
        {
          s->state = protostate_ERROR_TIMEOUT;
          *repeat  = true;
        }
        else if (s->callout_set == 0 && (s->parent == NULL || s->data_to_read > 0))
        {
          dprintf(("State_1,RTSP_6", "status_proceed_receiving: Setting a %dcs callout for receive timeout\n", Session_State_Retry));

          s->callout_set = 1;
          timeout(status_proceed_on_callout, s, Session_State_Retry);
        }
      }

      return false;
    }
  }

  /* If we get here, it is because we have decided that we have read the */
  /* entire message.                                                     */

  /* Force a terminator at the end - we're expecting no binary data so */
  /* this ensures correct termination and makes life easier later.     */

  s->data[s->data_len] = '\0'; /* Correct as data_len is always 1 byte behind actual allocation */

  #ifdef DUMP_HEADERS_TO_CACHEFS
  {
    FILE * f = fopen(DUMP_HEADERS_TO_CACHEFS, "ab");

    if (f != NULL)
    {
      fprintf(f, "RECEIVE (%p):\r\n", s);
      fwrite(s->data, 1, s->data_len, f);
      fclose(f);
    }
  }
  #endif

  #ifdef TRACE
  {
    char * e;
    char * p;
    char   c;

    /* Dump out one line at a time, since DebugLib will go wrong if you output more than about 1K at once */
    
    dprintf(("State_1,RTSP_1", "status_proceed_receiving: Receive complete with %d bytes\n--- Received ---\n", s->data_len));
    e = s->data;
    do
    {
      for (p = e; (*e != 0) && (*e != '\n'); e++);
      c = *e;
      *e = 0;
      dprintf(("State_1,RTSP_1", "%s\n", p));
      *e++ = c;
    }
    while (c != 0);
    dprintf(("State_1,RTSP_1", "--- End ---\n"));
  }
  #endif

  /* Did we just receive an ANNOUNCE from the server? */

  if (s->headers != NULL)
  {
    if (strcmp(s->headers->header, Headers_CommandName_Announce) == 0)
    {
      _kernel_oserror * e;

      /* ANNOUNCE received - process it */

      e = announce_received(s);

      if (e != NULL)
      {
        final.errnum = e->errnum;
        strncpy(final.errmess, e->errmess, sizeof(final.errmess));
  
        s->state = protostate_ERROR_VCPN;
        *repeat  = true;
  
        return false;
      }

      /* Reset the session to wait for the next message. The state remains the same. */

      if (s->parent == NULL)
      {
        /* If it's the parent session, just discard the recieved data, we */
        /* continue in the receive state as we are still waiting for an   */
        /* outstanding response.                                          */

        s->data_len     = 0, free(s->data), s->data    = NULL;
        s->data_to_read = -1;                         
        headers_free_headers(&s->headers),  s->headers = NULL;
      }
      else
      {
        /* If it's the child session, reset everything. */

        session_reset_session(s);
      }

      /* Repeat to check for more data and reset the timeout. */

      *repeat = true;
      return false;
    }
  }

  if (s->parent == NULL)
  {
    s->reported_state |= VC_Status_NewStatus | VC_Status_MoreInformationAvailable;
    s->state = protostate_COMPLETED;
  
    *repeat = true;
  }
  else
  {
    /* If the child session receives anything that isn't an ANNOUNCE, */
    /* we just ignore it and carry on in the receive state.           */

    session_reset_session(s);
    if (ret > 0) *repeat = true; /* Repeat if there may be more data */
  }

  return false;
}

/**************************************************************/
/* status_proceed_sent()                                      */
/*                                                            */
/* State machine handler for a send state. "Once a response   */
/* has been sent, check to see if any more responses are      */
/* waiting to be sent."                                       */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_sent(session * s, bool * repeat)
{
  (void)repeat;
  
  /* Is there another response waiting? */

  if (s->child != NULL)
  {
    session * child = s->child;
    session * parent = s->parent;
    int irqs_off = _kernel_irqs_disabled();

    /* This session will be destroyed, and its child will take its place */

    dprintf(("", "status_proceed_sent: Response sent, chaining to child\n"));

    _kernel_irqs_off();

    /* The following must be done in this order to stop session_free_item() */
    /* doing things we don't want.                                          */

    s->child = NULL;
    session_free_item(s);
    parent->child = child;
    child->parent = parent;

    if (!irqs_off) _kernel_irqs_on();

    /* Now get this child to send its response */

    status_send(child);
  }
  else
  {
    dprintf(("", "status_proceed_sent: Session self-destructing (completed), state machine exitting\n"));
    session_free_item(s);
  }

  return true;
}

/**************************************************************/
/* status_proceed_completed()                                 */
/*                                                            */
/* State machine handler for a completed state (tidy up).     */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_completed(session * s, bool * repeat)
{
  _kernel_oserror * e;

  dprintf(("", "status_proceed_completed: Called.\n"));

  /* We may have to send another command */

  if (s->next_command_cb)
  {
    e = (s->next_command_cb)(s);

    if (e != NULL)
    {
      if (s->destruct)
      {
        session_free_item(s);
        return true;
      }
      else
      {
        final.errnum = e->errnum;
        strncpy(final.errmess, e->errmess, sizeof(final.errmess));

        s->state = protostate_ERROR_VCPN;
        *repeat  = true;
      }
    }

    /* If the called routine did not change the state, repeat. */

    if (s->state == protostate_COMPLETED)
      *repeat = true;

    return false;
  }
  else if (s->destruct)
  {
    /* We're on the way out - no status change to Video Control... */

    dprintf(("", "status_proceed_completed: Session self-destructing (completed), state machine exitting\n"));
    session_free_item(s);
    return true;
  }
  else if (s->id != 0)
  {
    bool  prepare;

    /* We're more or less finished, just need to let Video Control */
    /* know about the status change.                               */

    prepare = (s->play_record != NULL && s->started == 0 && s->response_code == 200);

    dprintf(("","status_proceed_completed: Calling VideoControl_ProtocolNotify (prepare=%d)\n", prepare));

    e = _swix(VideoControl_ProtocolNotify,
              _INR(0,4),

              0,
              s->id,
              VideoControlProtocolNotifyNewStatus,
              prepare ? VC_ProtocolNotify_NewStatus_Prepare : 0,
              s->play_record);

    /* Yikes, Video Control had a problem */

    if (e != NULL)
    {
      final.errnum = e->errnum;
      strncpy(final.errmess, e->errmess, sizeof(final.errmess));

      s->state = protostate_ERROR_VCPN;
      *repeat  = true;

      return false;
    }

    /* Things seem to be working */

    if (prepare && s->mpegid == 0)
    {
      int opts[4];
    
      /* Get the MPEGControl handle for this stream */

      opts[0] = vc_tags_control_handle;
      opts[1] = 1;
      opts[2] = 0;
      opts[3] = vc_tags__end;
    
      e = _swix(VideoControl_ProtocolOptions,
                _INR(0,2),
    
                0,
                s->vcid,
                opts);
    
      if (e == NULL) s->mpegid = (unsigned int) opts[2];
      dprintf(("", "status_proceed_completed: read MPEGControl handle as %08X\n", s->mpegid));
    }

    if (s->change_pending)
    {
      if (s->parent == NULL && s->response_code == 200)
        play_command_completed(s);

      s->change_pending = 0;
    }

    if (prepare)
      s->started = 1;
  }

  /* If we got here, we've definitely finished the whole sequence correctly */
  /* so it's safe to reset the state.                                       */

  s->state = protostate_INITIAL;

  return false;
}

/**************************************************************/
/* status_ping_on_callout()                                   */
/*                                                            */
/* A CallOut handler (see CallOut.h) which pings the server   */
/* by sending a CRLF to it at regular intervals, to stop      */
/* the session from timing out when no commands are being     */
/* sent.                                                      */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void status_ping_on_callout(void * handle)
{
  session * s = (session *) handle;

  dprintf(("", "status_ping_on_callout: Called for %p\n", s));

  if (s->dying != 0) return;

  if (s->ping_set != 0)
  {
    if (s->sd >= 0)
    {
      int sent = socketwrite(s->sd, "\r\n", 2);

      dprintf(("State_1", "status_ping_on_callout: ...sent %d bytes\n", sent));

      if (sent < 2)
      {
        /* If the send failed, try again shortly */

        dprintf(("", "status_ping_on_callout: Setting %dcs callout for send timeout\n", Session_State_Retry));
        timeout(status_ping_on_callout, s, Session_State_Retry);
      }
      else
      {
        /* Reset the time-out period to ping again if nothing else happens */

        timeout(status_ping_on_callout, s, s->server_timeout);
      }
    }
  }
}

/**************************************************************/
/* status_check_error()                                       */
/*                                                            */
/* Examine a session structure to see if there's an error     */
/* state and if so return an appropriate _kernel_oserror.     */
/*                                                            */
/* Parameters: Pointer to the session structure to examine.   */
/*                                                            */
/* Returns:    NULL or pointer to a filled in _kernel_oserror */
/*             if the session was in an error state.          */
/**************************************************************/

_kernel_oserror * status_check_error(session * s)
{
  _kernel_oserror * e   = NULL;
  int               use = rtsphsac_ERROR_CONNECT_GENERAL;

  switch (s->state)
  {
    /* Error states: Various things went wrong... */

    case protostate_ERROR_READ:
    case protostate_ERROR_WRITE:
    {
      /* For a socket with a failed read or write we should do a   */
      /* getsockopt call to extract something more meaningful than */
      /* will be present in the session's copy of errno...         */

      if (s->sd >= 0)
      {
        int err, so, size = sizeof(int);

        err = getsockopt(s->sd, SOL_SOCKET, SO_ERROR, &so, &size);
        dprintf(("", "s->err_no was %d, getsockopt returned %d, SO_ERROR was %d\n", s->err_no, err, so));
        if (err == 0 && so != ENOERROR) s->err_no = so;
      }

      /* Read or write error? */

      if (s->state == protostate_ERROR_READ) use = rtsphsac_ERROR_CONNECT_READ;
      else                                   use = rtsphsac_ERROR_CONNECT_WRITE;

    } /* (...and drop through to next set of conditions) */

    case protostate_ERROR:
    case protostate_ERROR_DEAD:
    case protostate_ERROR_CONNECTION:
    case protostate_ERROR_NO_TOKEN:
    case protostate_ERROR_NOT_IMPLEMENTED:
    {
      char         en[16];
      const char * message;
      char       * dup;

      /* If there's nothing recorded in the session's copy of errno */
      /* or it's out of range, report the number; else report a     */
      /* message from the errno table in Unixlib.                   */

      if (s->err_no == ENOERROR || s->err_no >= sys_nerr)
      {
        sprintf(en, "%d", s->err_no);
        message = en;
      }
      else message = sys_errlist[s->err_no];

      /* Aesthetics - ensure first letter of sub-message is lower case */

      dup = Strdup(message);
      if (dup != NULL && isupper(dup[0])) dup[0] = tolower(dup[0]);

      /* Generate the full report */

      e = make_error(use, 1, dup == NULL ? message : dup);
      free(dup);
    }
    break;

    case protostate_ERROR_MEM:
    {
      e = make_error(rtsphsac_ERROR_MEMORY_EXHAUSTED, 0);
    }
    break;

    case protostate_ERROR_TIMEOUT:
    {
      e = make_error(rtsphsac_ERROR_CONNECT_TIMEOUT, 0);
    }
    break;

    case protostate_ERROR_DNS:
    {
      char * host;

      if (s->url && s->url->host && *s->url->host) host = s->url->host;
      else                                         host = "<?>";

      e = make_error(rtsphsac_ERROR_CONNECT_DNS, 1, host);
    }
    break;

    case protostate_ERROR_VCPN:
    {
      e = &final;
    }
    break;
  }

  #ifdef TRACE

    if (e != NULL && strlen(e->errmess) < (sizeof(e->errmess) - 12))
    {
      sprintf(strchr(e->errmess, '\0'), " (%08X)", (unsigned int) s);
    }

    if (e != NULL)
      dprintf(("", "status_check_error: Returning error &%x: %s\n", e->errnum, e->errmess));

  #endif


  return e;
}

/**************************************************************/
/* status_check_headers()                                     */
/*                                                            */
/* This function is called by status_proceed_receiving when   */
/* all of the headers of an RTSP message have been received   */
/* It parses the headers, extracts the session identifier     */
/* and timeout if we don't have them aleady, and sets         */
/* s->data_to_read to the amount of body data that has yet to */
/* be read in.                                                */
/*                                                            */
/* Parameters: Pointer to a session structure.                */
/*                                                            */
/* Returns:    True if successful, false if memory allocation */
/*             error occured.                                 */
/**************************************************************/

static bool status_check_headers(session * s)
{
  int           len_read = s->data_len;
  int           consumed;
  rtsp_header * h;
  
  consumed = headers_parse_response(s);
  
  if (consumed < 0)
  {
    dprintf(("State_0,RTSP_0,Error_0", "status_check_headers: Memory allocation failure parsing headers\n"));
    return false;
  }
  
  /* Have we got any more message body data to read? */

  h = headers_find_header(s->headers,
                          Headers_HeaderName_ContentLength);

  if (h != NULL)
  {
    s->data_to_read = consumed + atoi(h->value) - len_read;
    if (s->data_to_read < 0)
      s->data_to_read = 0;
  }
  else
  {
    s->data_to_read = 0;
  }

  dprintf(("State_1,RTSP_6", "status_check_headers: %d bytes of data left to read\n", s->data_to_read));

  /* If we've not got a server session, try to find one from this response. */
  /* Don't bother with this if we're a child though because if we need a    */
  /* session we'll be using the parent's.                                   */

  if (s->server_session == NULL && s->parent == NULL)
  {
    char * store;

    h = headers_find_header(s->headers,
                            Headers_HeaderName_Session);

    if (h != NULL)
    {
      s->server_timeout = Session_Timeout_Default;

      /* Find the session ID. It'll be terminated by ';' or end of string */

      store = strchr(h->value, ';');
      if (store != NULL) *store = '\0';

      s->server_session = Strdup(h->value);
      if (s->server_session == NULL)
      {
        dprintf(("State_0,RTSP_0,Error_0", "status_check_headers: Memory allocation failure\n"));
        return false;
      }

      /* Find "timeout" then "=" */

      if (store != NULL)
      {
        *store = ';';

        store = strstr(h->value, Headers_HeaderValue_Session);

        if (store != NULL)
        {
          while (*store != '\0' && *store != '=') store++;
          if (*store == '=') store++;
          while (*store != '\0' && *store <= ' ') store++;

          s->server_timeout = atoi(store);
          if (s->server_timeout == 0) s->server_timeout = Session_Timeout_Default;
        }
      }

      /* Convert server timeout in seconds to the 'keep-alive' ping  */
      /* interval in centiseconds. The multiplier has been chosen so */
      /* that up to two pings can be missed before the server times  */
      /* out. Originally the interval was half the server timeout,   */
      /* but occasionally a ping failed to reach the server (for     */
      /* reasons that are unclear) and the server closed the         */
      /* connection before another ping arrived.                     */

      s->server_timeout *= 32;

      dprintf(("State_1,RTSP_6", "status_check_headers: New session '%s', timeout %d\n", s->server_session, s->server_timeout));
    }
  }

  return true;
}
