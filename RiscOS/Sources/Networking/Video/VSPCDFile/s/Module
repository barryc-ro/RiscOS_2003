;******************************************************************************
;
; s.Module
;
; Authors: Tim Dobson (Online Media)
;          Christopher Partington (Cambridge Systems Design)
;
; Description
; ===========
; This is the main source file for the VSPFile and VSPCD modules.
;
; Change record
; =============
; 02-Aug-95  ..:..  tdobson
; * First version.
;
; 10-Aug-95  14:44  cpartington (Cambridge Systems Design)
; * Started VSPCD work.
; * Definitions moved to hdr.defs.
;
; 08-Sep-95  10:30  cpartington (Cambridge Systems Design)
; * Added stuff to bring this module in line with TDobson's VSPFile 0.03.
;   TDobson's change record:
;   - 0.02 Added SetStopPosition
;   - 0.03 Protect GenerateCallback from IRQs, and call it from SetPosition
;          and SetStopPosition
;
;*end of change record*

        LEADR   Module_LoadAddr

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       Ether2DCISWI_Base               ; SWI chunk for VSP
        &       Mod_SWIHandler-Module_BaseAddr
        &       Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry

 [ CD
Mod_Title
        =       "VSPCD", 0

Mod_HelpStr
        =       "VSP CD", TAB, TAB, "$VString ($Date)"
        =       0
 |
Mod_Title
        =       "VSPFile", 0

Mod_HelpStr
        =       "VSP File", TAB, "$VString ($Date)"
        =       0
 ]
        ALIGN

Mod_SWITable
        =       "VSP", 0
        =       "OpenStream", 0
        =       "CloseStream", 0
        =       "CheckEndOfStream", 0
        =       "SetSpeed", 0
        =       "SetPosition", 0
        =       "FreeBuffer", 0
        =       "ReadPosition", 0
        =       "SetStopPosition", 0
        =       0

Mod_HC_Table
        Command VSPInfo, 0, 0
        =       0
        ALIGN

VSPInfo_Help
        =       "*VSPInfo outputs debugging info.", CR
VSPInfo_Syntax
        =       "Syntax: *VSPInfo", 0
        ALIGN

; **************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [R12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

        MOV     r0, #StreamState_Dormant
        STR     r0, StreamState

        MOV     r0, #0
 [ CD
        STR     r0,CDPendingList
        STR     r0,CDPendingListTail
        STR     r0,CDOnLoanList
        STR     r0,CDOnLoanListTail
        STR     r0,CDFreeList
        STR     r0,CDOffsetInBlock
 |
        STR     r0, CallBackRequested
        STR     r0, FreeBufferListHeadPtr
 ]
        CLRV
        EXIT

; **************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

        LDR     r0, StreamState
        CMP     r0, #StreamState_Dormant
        EXIT    EQ                      ; V=0 from compare

        TEQ     r0, #StreamState_Closing
        ADREQL  r0, ErrorBlock_BuffersOnLoan
        ADRNEL  r0, ErrorBlock_FileOpen ; active, finished, or error
        SETV
        EXIT

; **************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service * Module_BaseAddr   ; nothing to do yet!

; **************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     r12, [wp]
 [ cdebug2
        CDebug_StrReg8  "VSPSWI ",r11
 ]
 [ 1=1
        CMPS    r11,#(SWIBTable_end - SWIBTable) / 4
 |
        CMP     r11, #MPEGControlSWICheckValue - MPEGControlSWI_Base
 ]
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
SWIBTable
        B       OpenStream      ; open stream
        B       CloseStream     ; close stream
        B       CheckEndOfStream ; check for end of stream
        B       SetSpeed        ; may encompass pause/slow/fast/rewind
        B       SetPosition     ; set new file position
        B       FreeBuffer      ; free buffer
        B       ReadPosition    ; read current file position
        B       SetStopPosition ; set position to stop at
SWIBTable_end
        ASSERT  ((.-SWIBTable) / 4) = (VSPSWICheckValue - Ether2DCISWI_Base)

NoSuchSWI
        Push    "lr"
 [ {FALSE}
        SWI     XOS_WriteI+22
        SWI     XOS_WriteI+12
        DREG    r11, "Unknown VSP SWI - offset from base = "
        DLINE   "Press any key"
        SWI     XOS_ReadC
 ]
        ADR     r0, NoSuchSWIError
        SETV
        Pull    "pc"

NoSuchSWIError
        &       0
        =       "No such VSP SWI", 0
        ALIGN

; **************************************************************************
;
;       VSPInfo_Code - Entry point for *VSPInfo
;

VSPInfo_Code Entry
        LDR     wp, [r12]

        SWI     XOS_WriteS
        =       "Stream state: ", 0
        ALIGN
        LDR     r0, StreamState
        CMP     r0, #5
        MOVCS   r0, #5
        ADR     r1, StreamStateStrings
        LDR     r0, [r1, r0, LSL #2]
        ADD     r0, r0, r1
        SWI     XOS_Write0
        SWI     XOS_NewLine

        LDR     r0, NBuffersOnLoan
        DREG    r0, "Buffers on loan = "
 [ :LNOT: CD
        LDR     r0, CallBackRequested
        DREG    r0, "Callback requested = "

        LDR     r0, FileHandle
        DREG    r0, "File handle = "
 ]
        LDR     r0, NBuffersTotal
        DREG    r0, "Total buffers = "

        LDR     r0, BufferSize
        DREG    r0, "Buffer size = "

        LDR     r0, MPEGControlStreamHandle
        DREG    r0, "Control stream handle = "

        LDR     r0, CurrentPTR
        DREG    r0, "Current PTR = "

        LDR     r0, EndPTR
        DREG    r0, "End PTR = "

 [ CD
        LDR     r0,CDFileSize
        DREG    r0,"File size = "

        LDR     r0,CDRequestPTR
        DREG    r0,"Request PTR = "

        LDR     r0,CDDataMode
        DREG    r0,"Data mode = "

        LDR     r0,CDNextBlock
        DREG    r0,"Next LBA = "

        LDR     r0,StreamState
        TEQS    r0,#StreamState_Error
        ADREQ   r0,BackgroundErrorBlock+4
  [ cdebug
        CDebug_WriteS   "Last error ",cc
        CDebug_WriteS0  r0
        CDebug_NewLine
        BL      CDPrintLists
  ]
 |
        LDR     r0, FreeBufferListHeadPtr
        DREG    r0, "Free buffer list = "
 ]

        EXIT

StreamStateStrings
        &       StringDormant-StreamStateStrings
        &       StringActive-StreamStateStrings
        &       StringFinished-StreamStateStrings
        &       StringClosing-StreamStateStrings
        &       StringError-StreamStateStrings
        &       StringUnknown-StreamStateStrings

StringDormant   =       "Dormant", 0
StringActive    =       "Active", 0
StringFinished  =       "Finished", 0
StringClosing   =       "Closing", 0
StringError     =       "Error", 0
StringUnknown   =       "Unknown", 0
        ALIGN

; **************************************************************************
;
;       OpenStream - Open VSP stream
;
; in:   r0 = flags
;       r1 -> stream identification string, of the form "<pathname> <parameters>"
;       r2 = MPEG control stream handle
;
; out:  r0 = VSP stream handle
;

 [ CD
OpenStream Entry "r1-r7"
 |
OpenStream Entry "r1-r2"
 ]
        LDR     lr, StreamState
 [ cdebug
        CDebug_StrReg8  "Open: state ",lr
 ]
        TEQ     lr, #StreamState_Dormant
        BNE     %FT90                           ; stream already open

 [ CD
        STR     r2, MPEGControlStreamHandle

; r1 -> filename
;
; Now try to determine which drive the file is on by canonicalising the
; filename and comparing it with a canonicalised name for each drive. There
; ought to be a FS call to do this but I can't find one.
;
; find how long canonicalised name will be

        MOV     r0,#37          ; canonicalise
        MOV     r2,#0           ; no buffer
        MOV     r3,#0           ; no path
        MOV     r4,#0           ; no 2nd path
        MOV     r5,#0           ; no buffer
        SWI     XOS_FSControl
        EXIT    VS

; get buffer for name

        MOV     r0,#ModHandReason_Claim
        RSB     r3,r5,#1        ; r3 = buffer size
        SWI     XOS_Module      ; (r0,r3->r2)
        EXIT    VS
 [ cdebug
        CDebug_StrReg8  "Claimed ",r2
 ]

; canonicalise the name

        MOV     r6,r2           ; save buffer pointer
        MOV     r0,#37          ; canonicalise
        MOV     r5,r3           ; size of buffer
        MOV     r3,#0           ; no path
        MOV     r4,#0           ; no 2nd path
        SWI     XOS_FSControl
        BVS     %FT52
        TEQS    r5,#1
        BNE     %FT50

; now, for each drive, construct a canonicalised name

        MOV     r0,#161         ; read CMOS
        MOV     r1,#CDROMFSCMOS ; location to read
        SWI     XOS_Byte
        BVS     %FT52
        ANDS    r2,r2,#CDCMOSDRIVEBITS
        BEQ     %FT50           ; branch if no drives configured

        LDR     lr,=&53464443   ; "CDFS"
        STR     lr,CDDrivePath
        LDR     lr,=&00303A3A   ; 0+"0::"
        SUB     r2,r2,#1        ; max drive number
        ORR     lr,lr,r2,LSL #16
        STR     lr,CDDrivePath + 4
20

; find how long canonicalised name will be

        MOV     r0,#37          ; canonicalise
        ADR     r1,CDDrivePath
        MOV     r2,#0           ; no buffer
        MOV     r3,#0           ; no path
        MOV     r4,#0           ; no 2nd path
        MOV     r5,#0           ; no buffer
        SWI     XOS_FSControl
        BVS     %FT45

; get buffer for name

        MOV     r0,#ModHandReason_Claim
        RSB     r3,r5,#1        ; r3 = buffer size
        SWI     XOS_Module      ; (r0,r3->r2)
        BVS     %FT52
 [ cdebug
        CDebug_StrReg8  "Claimed ",r2
 ]

; canonicalise the name

        MOV     r7,r2           ; save buffer pointer
        MOV     r0,#37          ; canonicalise
        MOV     r5,r3           ; size of buffer
        MOV     r3,#0           ; no path
        MOV     r4,#0           ; no 2nd path
        SWI     XOS_FSControl
        BVS     %FT55
        TEQS    r5,#1
        BNE     %FT54

; r6 -> filename
; r7 -> name of root
; compare

 [ cdebug
        CDebug_WriteS   "compare ",cc
        CDebug_WriteS0  r6
        CDebug_WriteS   " and ",cc
        CDebug_WriteS0  r7
        CDebug_NewLine
 ]

        MOV     r1,r6
        MOV     r2,r7
30
        LDRB    lr,[r2],#1
        TEQS    lr,#0
        BEQ     %FT60           ; match
        LDRB    r0,[r1],#1
        TEQS    lr,r0
        BEQ     %BT30

40
; no match, step to next drive

        MOV     r0,#ModHandReason_Free  ; free old buffer
        MOV     r2,r7
 [ cdebug
        CDebug_StrReg8  "Release ",r2
 ]
        SWI     XOS_Module

45
        LDRB    lr,CDDrivePath + 6
        TEQS    lr,#"0"
        SUBNE   lr,lr,#1
        STRNEB  lr,CDDrivePath + 6
        BNE     %BT20

; no match found

50
        ADRL    r0,ErrorBlock_FileNotFound
52
; r0 -> error block
; free name buffer

        MOV     r1,r0                   ; save error
        MOV     r0,#ModHandReason_Free
        MOV     r2,r6
 [ cdebug
        CDebug_StrReg8  "Release ",r2
 ]
        SWI     XOS_Module

        MOV     r0,r1
        SETV
        EXIT

;;;;;;;;;;;;;;;;;

54
        ADRL    r0,ErrorBlock_FileNotFound
55
; r0 -> error block
; free root buffer

        MOV     r1,r0                   ; save error
        MOV     r0,#ModHandReason_Free
        MOV     r2,r7
 [ cdebug
        CDebug_StrReg8  "Release ",r2
 ]
        SWI     XOS_Module
        B       %BT52

;;;;;;;;;;;;;;;;;

60
; canonicalised filename and canonicalised root name matched
; r6 -> canonicalised filename
; r7 -> canonicalised name of root
; free root buffer

        MOV     r0,#ModHandReason_Free
        MOV     r2,r7
 [ cdebug
        CDebug_StrReg8  "Release ",r2
 ]
        SWI     XOS_Module

; get drive number and convert to CDFS internal number

        LDRB    lr,CDDrivePath + 6
        SUB     r0,lr,#"0"                      ; r0 = drive number
        SWI     XCDFS_ConvertDriveToDevice      ; (r0->r1)
        BVS     %BT50

; create CDFS control block from value returned in r1

        ADR     r7,CDControlBlock
        AND     lr,r1,#7
        STR     lr,[r7,#0]
        MOV     lr,r1,LSR #3
        AND     lr,lr,#3
        STR     lr,[r7,#4]
        MOV     lr,r1,LSR #5
        AND     lr,lr,#7
        STR     lr,[r7,#8]
        MOV     lr,r1,LSR #8
        AND     lr,lr,#&FF
        STR     lr,[r7,#12]
        MOV     lr,r1,LSR #16
        BIC     lr,lr,#&FF000000
        BIC     lr,lr,#&00FF0000
        STR     lr,[r7,#16]

; ask CDFS for the address of the file and its size
; r6 -> canonicalised name (and is word-aligned)
; first skip over CDFS: at start of name

        LDR     lr,[r6]                 ; get first 4 chars
        LDR     r0,CDDrivePath          ; get 'CDFS'
        TEQS    lr,r0
        LDREQB  lr,[r6,#4]              ; if match, look for ':'
        TEQEQS  lr,#":"
        BNE     %BT50
        ADD     r0,r6,#5

 [ cdebug
        CDebug_WriteS   "WhereIsFile ",cc
        CDebug_WriteS0  r0
        CDebug_NewLine
 ]
        SWI     XCDFS_WhereIsFile       ; (r0->r1,r2)
        BVS     %BT52

; check that CDFS found the file

        CMPS    r1,#-1
        BEQ     %BT50                   ; error if not found
        STR     r1,CDStartBlock         ; save LBA of block 0
        STR     r1,CDNextBlock
        STR     r2,CDFileSize           ; save size
        STR     r2,EndPTR               ; and set stop position

 [ cdebug
        CDebug_StrReg8  "File is at LBA ",r1,cc
        CDebug_StrReg8  ", length ",r2
 ]

; free the name buffer

        MOV     r0,#ModHandReason_Free
        MOV     r2,r6
 [ cdebug
        CDebug_StrReg8  "Release ",r2
 ]
        SWI     XOS_Module

; check the data mode of the first block and assume all file can be accessed
; in that mode
; r1 = LBA
; r7 -> ControlBlock

        MOV     r0,#0                           ; addressing mode = LBA
        SWI     XCD_EnquireDataMode             ; (r0,r1,r7->r0)
        EXIT    VS

; r0 = data mode

        STR     r0,CDDataMode

 |
        MOV     r0, #OSFind_ReadFile            ; try to open (must be existing file)
        SWI     XOS_Find
        EXIT    VS                              ; return error if open failed

        STR     r0, FileHandle
        STR     r2, MPEGControlStreamHandle
 ]
        MOV     lr, #0
        STR     lr, NBuffersTotal               ; no buffers allocated yet
        STR     lr, NBuffersOnLoan              ; no buffers free either
        STR     lr, CurrentPTR                  ; starting ptr
 [ CD
        STR     lr,CDRequestPTR
        STR     lr,CDOffsetInBlock
 |
        MOV     r1, r0
        MOV     r0, #OSArgs_ReadEXT
        SWI     XOS_Args
        BVS     %FT80
        STR     r2, EndPTR
 ]

; allocate some buffers
; eventually read -buffersize and -nbuffers from stream id string

        MOV     lr, #StreamState_Active         ; indicate active before allocating buffers
        STR     lr, StreamState                 ; so CloseStream will work
        LDR     r0, =DefaultNBuffers
        LDR     r3, =DefaultBufferSize
        STR     r3, BufferSize

        BL      AllocateBuffers
        BVS     %FT80                           ; exit closing stream

 [ CD

; calculate how many blocks will fit in each buffer
; r3 = BufferSize

        LDR     r0,CDDataMode
        TSTS    r0,#1                           ; mode 1 or 3 (=2/1) ?
        MOVNE   r0,#2048                        ; yes
        MOVEQ   r0,#2352                        ; no, mode 0 or 2 (=2/2)
        DivRem  r1,r3,r0,lr                     ; r1 = blocks in buffer
        STR     r1,CDBlocksPerBuffer
 [ cdebug
        CDebug_StrReg8  "Blocks per buffer ",r1
 ]

; now start some background reads

        BL      CDStartSomeReads
 |
        BL      GenerateCallBack
 ]

        MOV     r0, wp                          ; handle of our wp for now
        CLRV
        EXIT

; error allocating buffers or reading extent, so free up resources

80
        Push    "r0"
        MOV     r0, #0
        MOV     r1, wp
        BL      CloseStream
        Pull    "r0"
        SETV
        EXIT

90
        ADRL    r0, ErrorBlock_StreamActive
        SETV
        EXIT

 [ CD
        LTORG
 ]

; **************************************************************************
;
;       CloseStream - Close the stream
;
; in:   r0 = flags
;       r1 = VSP stream handle
;

 [ CD
CloseStream Entry "r0-r5"
 |
CloseStream Entry "r0,r1"
 ]
        BL      CheckStreamHandle               ; check handle valid
        STRVS   r0, [sp]
        EXIT    VS                              ; return error if not

 [ cdebug
        CDebug_WriteS   "CloseStream OK"
 ]
        MOV     lr, #StreamState_Closing        ; indicate closing, so any further callbacks will free buffers
        STR     lr, StreamState                 ; rather than filling them

        BL      FreeBuffers                     ; free all

 [ CD

; abort all outstanding operations
; IRQs off for this bit

        MOV     r5,pc
        TSTS    r5,#I_bit
        TEQEQP  r5,#I_bit

        LDR     r2,CDPendingList
80
        TEQS    r2,#0
        BEQ     %FT90

; DON'T unlink item and put it in the free list - the callback will

        LDR     r0,[r2,#CDLI_Handle]
        SWI     XATAPI_CancelBackgroundOp       ; (r0->r1,r3,r4)
        LDR     r2,[r2,#CDLI_Next]
        B       %BT80

;;;;;;;;;;;;;;;;;

90
        TEQP    pc,r5                           ; restore IRQ state

 |
        MOV     r0, #0
        LDR     r1, FileHandle
        STR     r0, FileHandle                  ; zero file handle
        TEQ     r1, #0
        SWINE   XOS_Find                        ; close file if there is one (there should be)
 ]
 [ cdebug
        CDebug_WriteS   "Leaving CloseStream"
 ]
        CLRV
        EXIT

; **************************************************************************
;
;       CheckEndOfStream - Check for end of stream
;
; in:   r0 = flags (zero for now)
;       r1 = VSP stream handle
;
; out:  r0 = 0 => not end-of-stream
;            1 => end-of-stream

CheckEndOfStream Entry
        BL      CheckStreamHandle
        EXIT    VS                              ; return error if handle invalid

        LDR     lr, StreamState
        TEQ     lr, #StreamState_Error          ; if we've had a background error
        ADREQ   r0, BackgroundErrorBlock        ; then return it from the CheckEndOfStream call
        BEQ     %FT90

        TEQ     lr, #StreamState_Finished
        MOVEQ   r0, #1                          ; if finished, return 1
        MOVNE   r0, #0                          ; else return 0
        CLRV
        EXIT

90
        SETV
        EXIT

; **************************************************************************
;
;       SetSpeed - Set speed of play on MPEG stream
;
; in:   r0 = flags
;       r1 = VSP stream handle
;       r2 = speed indicator
;              0    = paused
;              1    = normal speed
;              2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

SetSpeed Entry

; ignore it for now (maybe forever on a flow-controlled system like this)

        CLRV
        EXIT

; **************************************************************************
;
;       SetPosition - Set position in file
;
; in:   r0 = flags
;       r1 = VSP stream handle
;       r2 = position indicator:
;               r2+0 = position indicator type
;                       0 => r2+4 = byte offset in file (bits 0..31)
;                            r2+8 = -------""---------- (bits 32..63)
;                       others yet to be defined
;
; out:  All registers preserved?
;       NB it clears any background error condition (if a valid stream and position type)
;

 [ CD
SetPosition Entry "r0-r6"
 |
SetPosition Entry "r1"
 ]
        BL      CheckStreamHandle
 [ CD
        STRVS   r0,[sp]
 ]
        EXIT    VS                              ; return error if stream handle invalid

 [ CD

; check position type is valid

        LDMIA   r2,{r1,r2}                      ; r1 = position type
        TEQS    r1,#0                           ; only recognise byte offset
        BNE     %FT90

; check requested file pointer is in range but don't bounce it if it's not -
; Tim's comments above may mean that any value should be accepted to clear
; error condition

        LDR     lr,CDFileSize                   ; force pointer in range
        CMPS    r2,lr
        MOVHI   r2,lr

 [ cdebug
        CDebug_StrReg8  "SetPosition ",r2
 ]

; r2 = new file position, <= CDFileSize
; To change position, abort all outstanding operations and start some new ones.
; Could check if new position is same as old before aborting ops but probably
; no need

        MOV     r6,pc                           ; disable IRQs
        TSTS    r6,#I_bit
        TEQEQP  r6,#I_bit

        LDR     r5,CDPendingList
10
        TEQS    r5,#0
        BEQ     %FT20

; abort op - callback will free list item

        LDR     r0,[r5,#CDLI_Handle]
        SWI     XATAPI_CancelBackgroundOp       ; (r0->r1,r3,r4)
        LDR     r5,[r5,#CDLI_Next]
        B       %BT10

;;;;;;;;;;;;;;;;;

20
; have cancelled all pending background ops
; r2 = new PTR (valid)

        STR     r2,CurrentPTR                   ; store new PTR
        BL      CDRestart                       ; (sets state)
        TEQP    pc,r6                           ; restore IRQ state
 |
        LDR     lr, [r2, #0]                    ; get position type
        TEQ     lr, #0                          ; only recognise byte offset position type
        BNE     %FT90

        LDR     lr, [r2, #4]
        STR     lr, CurrentPTR                  ; store new current PTR

        LDR     r1, EndPTR
        CMP     lr, r1                          ; if new pointer >= end
        MOVCS   lr, #StreamState_Finished       ; then mark as finished
        MOVCC   lr, #StreamState_Active         ; else mark as active
        STR     lr, StreamState
        BL      GenerateCallBack
 ]
        CLRV
        EXIT

;;;;;;;;;;;;;;;;

90
        ADRL    r0, ErrorBlock_UnknownPositionType
 [ CD
        STR     r0,[sp]
 ]
        SETV
        EXIT

; **************************************************************************
;
;       SetStopPosition - Set position in file
;
; in:   r0 = flags
;       r1 = VSP stream handle
;       r2 = position indicator:
;               r2+0 = position indicator type
;                       0 => r2+4 = byte offset in file (bits 0..31)
;                            r2+8 = -------""---------- (bits 32..63)
;                       others yet to be defined
;
; out:  All registers preserved
;       NB it clears any background error condition (if a valid stream and position type)
;

 [ CD
SetStopPosition Entry "r0-r6"
 |
SetStopPosition Entry "r1"
 ]
        BL      CheckStreamHandle
 [ CD
        STRVS   r0,[sp]
 ]
        EXIT    VS                              ; return error if stream handle invalid

 [ CD

; check position type is valid

        LDMIA   r2,{r1,r2}                      ; r1 = position type
        TEQS    r1,#0                           ; only recognise byte offset
        BNE     %FT90

; check requested file pointer is in range but don't bounce it if it's not -
; Tim's comments above may mean that any value should be accepted to clear
; error condition

        LDR     lr,CDFileSize                   ; force pointer in range
        CMPS    r2,lr
        MOVHI   r2,lr

 [ cdebug
        CDebug_StrReg8  "SetStopPosition ",r2
 ]

; r2 = new stop position, <= CDFileSize
; if active
;    if end < request      // request >= current
;       cancel all outstanding reads
;       restart
;    else
;       do nothing
;    fi
; else
;    restart
; fi

        MOV     r6,pc                           ; disable IRQs
        TSTS    r6,#I_bit
        TEQEQP  r6,#I_bit

        STR     r2,EndPTR                       ; store new stop position

        LDR     lr,StreamState
        TEQS    lr,#StreamState_Active
        BNE     %FT20

; stream is currently active
; check if new stop position is within scope of current reads

        LDR     lr,CDRequestPTR                 ; get where we've asked up to
        CMPS    r2,lr                           ; if new stop is after this
        BHS     %FT30                           ; leave alone

; new stop position is within the scope of current reads so cancel them

        LDR     r5,CDPendingList
10
        TEQS    r5,#0
        BEQ     %FT20

; abort op - callback will free list item

        LDR     r0,[r5,#CDLI_Handle]
        SWI     XATAPI_CancelBackgroundOp       ; (r0->r1,r3,r4)
        LDR     r5,[r5,#CDLI_Next]
        B       %BT10

;;;;;;;;;;;;;;;;;

20
; have cancelled all pending background ops

        BL      CDRestart                       ; (resets state)
30
        TEQP    pc,r6                           ; restore IRQ state
 |
        LDR     lr, [r2, #0]                    ; get position type
        TEQ     lr, #0                          ; only recognise byte offset position type
        BNE     %FT90

        LDR     r1, [r2, #4]
        STR     r1, EndPTR                      ; store new end PTR

        LDR     lr, CurrentPTR
        CMP     lr, r1                          ; if new pointer >= end
        MOVCS   lr, #StreamState_Finished       ; then mark as finished
        MOVCC   lr, #StreamState_Active         ; else mark as active
        STR     lr, StreamState
        BL      GenerateCallBack
 ]
        CLRV
        EXIT

90
        ADRL    r0, ErrorBlock_UnknownPositionType
        SETV
        EXIT

;******************************************************************************
;
;       FreeBuffer - Called by MPEG Control to free a buffer
;
; in:   r0 = flags (normally zero)
;       r1 = reserved (currently zero)
;       r2 -> buffer descriptor
;
; out:  All registers preserved
;

 [ CD
FreeBuffer Entry "r0-r1"
 |
FreeBuffer Entry "r0"
 ]
        MOV     lr, pc
        ORR     lr, lr, #I_bit
        TEQP    lr, #0                          ; disable IRQs round update to list

 [ cdebug
        CDebug_StrReg8  "FreeBuffer ",r2
        BL      CDPrintLists
 ]
 [ CD

; find list item that points to this buffer descriptor

        ADR     r1,CDOnLoanList                 ; lr -> item pointer
10
        LDR     r0,[r1]
        TEQS    r0,#0
 [ cdebug
        BNE     %FT00
        CDebug_WriteS   "FreeBuffer can't find buffer"
00
 ]
        EXITS   EQ                              ; should never happen

        LDR     lr,[r0,#CDLI_BufferDescriptorPtr]
        TEQS    lr,r2                           ; this one?
        ADDNE   r1,r0,#CDLI_Next                ; if not, step on
        BNE     %BT10

; buffer descriptor pointer matches
; r0 -> item being returned
; r1 -> pointer to list item
; must unlink it from this list and put it in free list

        LDR     lr,[r0,#CDLI_Next]      ; get item's next
        STR     lr,[r1]                 ; overwrite pointer to this one

        TEQS    lr,#0                   ; last in list?
        LDRNE   r1,CDOnLoanListTail     ; if not, r1 = tail
        LDREQ   lr,CDOnLoanList         ; if yes, check if also first
        TEQEQS  lr,#0                   ; (if so, we have just zeroed it)
        MOVEQ   r1,#0                   ; if yes, tail = 0
        ASSERT  CDLI_Next = 0
        STR     r1,CDOnLoanListTail

; item is now unlinked
; r0 -> item

        LDR     lr,CDFreeList
        STR     lr,[r0,#CDLI_Next]
        STR     r0,CDFreeList
 |
        LDR     lr, FreeBufferListHeadPtr
        STR     lr, [r2, #BufferDescriptor_Link] ; this->link = head
        STR     r2, FreeBufferListHeadPtr       ; head = this
 ]
        LDR     lr, NBuffersOnLoan
        SUB     lr, lr, #1                      ; decrement count of buffers on loan
        STR     lr, NBuffersOnLoan

 [ CD
        LDR     lr,StreamState
        TEQS    lr,#StreamState_Closing
        BLNE    CDStartSomeReads
        BLEQ    FreeBuffers
 |
        BL      GenerateCallBack                ; ask for callback, with IRQs off
 ]
 [ cdebug
        CDebug_WriteS   "Leaving FreeBuffer"
 ]
        EXITS

; **************************************************************************
;
;       ReadPosition - Read position in file
;
; in:   r0 = flags
;       r1 = VSP stream handle
;       r2 = position indicator:
;               r2+0 = type of position indicator to store in block
;                       0 => store at r2+4 the byte offset in file (bits 0..31)
;                            store at r2+8 -----------""---------- (bits 32..63)
;                       others yet to be defined
;
; out:  All registers preserved
;

ReadPosition Entry "r1"
        BL      CheckStreamHandle
        EXIT    VS                              ; return error if stream handle invalid

        LDR     lr, [r2, #0]                    ; get position type
        TEQ     lr, #0                          ; only recognise byte offset position type
        BNE     %FT90

        LDR     lr, CurrentPTR
        STR     lr, [r2, #4]
        MOV     lr, #0                          ; RISC OS PTRs are only 32 bit
        STR     lr, [r2, #8]
        CLRV
        EXIT

90
        ADRL    r0, ErrorBlock_UnknownPositionType
        SETV
        EXIT

; **************************************************************************
;
;       CheckStreamHandle - Check stream handle is valid and stream is open
;
; in:   r1 = VSP stream handle
;
; out:  If OK, all registers preserved, else r0->error and VS
;

CheckStreamHandle Entry
        TEQ     r1, wp
        BNE     %FT90

        LDR     lr, StreamState
        TEQ     lr, #StreamState_Dormant        ; if dormant
        TEQNE   lr, #StreamState_Closing        ; or already closing
        BEQ     %FT90                           ; then no file open, so bad handle
        EXIT

90
        ADRL    r0, ErrorBlock_BadHandle
        SETV
        EXIT

; **************************************************************************

 [ :LNOT: CD
;
;       GenerateCallBack - Ask for a callback if one not already requested
;
; in:   -
; out:  -

GenerateCallBack Entry "r0-r1"
        MOV     lr, pc
        ORR     lr, lr, #I_bit                  ; disable IRQs
        TEQP    lr, #0

        LDR     lr, CallBackRequested           ; is callback already requested?
        TEQ     lr, #0                          ; if so, then exit
        BNE     %FT10                           ; (because we're in SVC mode, it can't go off before we return)

        MOV     lr, #1
        STR     lr, CallBackRequested           ; indicate one requested

        ADR     r0, CallBackRoutine
        MOV     r1, wp
        SWI     XOS_AddCallBack
10
        EXITS                                   ; exit restoring IRQ state

 ]

; **************************************************************************

 [ :LNOT: CD
;
;       CallBackRoutine - CallBack routine to fill (or free buffers)
;       NB Can't be reentered
;
; in:   -
; out:  -
;

debug   SETL    {FALSE}

CallBackRoutine Entry
        LDR     lr, StreamState
        TEQ     lr, #StreamState_Closing
        BNE     %FT10

; closing, so free buffers

        DLine   "Freeing buffers in callback"

        BL      FreeBuffers
        B       %FT70

10
        TEQ     lr, #StreamState_Active                 ; if not active, ie dormant (shouldn't happen) or finished or error,
        BNE     %FT70                                   ; then just exit

        Push    "r0-r4"
20
        LDR     r4, CurrentPTR                          ; if reached end of data
        LDR     lr, EndPTR
        SUBS    r3, lr, r4                              ; number of bytes left to do
        MOVLS   lr, #StreamState_Finished               ; then mark as finished
        STRLS   lr, StreamState
        BLS     %FT60                                   ; and exit

        MOV     r0, pc
        ORR     lr, r0, #I_bit                          ; disable IRQs while we extract head of list
        TEQP    lr, #0

        LDR     r1, FreeBufferListHeadPtr
        TEQ     r1, #0
        LDRNE   lr, [r1, #BufferDescriptor_Link]
        STRNE   lr, FreeBufferListHeadPtr
        LDRNE   lr, NBuffersOnLoan
        ADDNE   lr, lr, #1
        STRNE   lr, NBuffersOnLoan

        TEQP    r0, #0                                  ; restore IRQ state

        TEQ     r1, #0                                  ; if no more free buffers, then exit
        BEQ     %FT60

        DReg    lr, "Buffers on loan now = "

        MOV     lr, #0
        STR     lr, [r1, #BufferDescriptor_Link]

        LDR     lr, BufferSize
        CMP     r3, lr                                  ; if more than buffer size
        MOVHI   r3, lr                                  ; then limit it to buffer size
        STR     r3, [r1, #BufferDescriptor_Length]

        LDR     r2, [r1, #BufferDescriptor_Start]
        DReg    r2, "About to do OS_GBPB to address ",cc
        DReg    r4, " from PTR "

        Push    "r1"
        LDR     r1, FileHandle
        MOV     r0, #OSGBPB_ReadFromGiven
        SWI     XOS_GBPB
        Pull    "r1"
        MOVVS   r2, r1                                  ; if error then point r2 at buffer descriptor
        BVS     %FT90                                   ; then copy error away and return buffer descriptor
        STRVC   r4, CurrentPTR                          ; update current ptr

        DLine   "Issuing MPEGControl_FullBuffers"

        MOV     r0, #0
        MOV     r2, r1                                  ; r2 -> buffer descriptor
        LDR     r1, MPEGControlStreamHandle
        SWI     XMPEGControl_FullBuffers                ; ignore errors?
        BVC     %BT20
        B       %FT90

60
        Pull    "r0-r4"
70
        MOV     lr, #0
        STR     lr, CallBackRequested
        EXIT

90
        ADR     r1, BackgroundErrorBlock
        ADD     r3, r1, #?BackgroundErrorBlock
        LDR     lr, [r0], #4                            ; get error number
        STR     lr, [r1], #4
92
        LDRB    lr, [r0], #1                            ; copy zero-terminated error string
        STRB    lr, [r1], #1
        TEQ     lr, #0
        BEQ     %FT94
        EORS    lr, r1, r3                              ; have we overrun block?
        BNE     %BT92                                   ; no, so loop

        STRB    lr, [r3, #-1]                           ; terminate block properly with zero
94
        BL      FreeBuffer                              ; return buffer descriptor to our free list

        MOV     lr, #StreamState_Error                  ; indicate background error
        STR     lr, StreamState
        B       %BT60                                   ; exit callback


debug   SETL    {FALSE}
 ]

; **************************************************************************
;
;       AllocateBuffers - Allocate buffers and buffer descriptors
;
; in:   r0 = number of buffers to allocate
;       r3 = size of buffers to allocate
;
; out:  -

debug   SETL    {FALSE}

AllocateBuffers Entry "r0,r2,r4,r5"
        DLine   "Entered AllocateBuffers"
        DReg    r0, "Number of buffers to allocate = "
        DReg    r3, "...of size "
        MOV     r5, r0
10
        DReg    r5, "Number still to do = "
        SUBS    r5, r5, #1                              ; decrement number of buffers to allocate (V:=0)
        EXIT    CC                                      ; if no more, then exit (VC)


        Push    "r3"
 [ CD

; claim list item

        MOV     r0,#ModHandReason_Claim
        MOV     r3,#CDLI_Size                           ; r3 = bytes to claim
        SWI     XOS_Module
        Pull    "r3",VS
        BVS     %FT90

 [ cdebug
        CDebug_StrReg8  "list item @ ",r2
 ]
        MOV     r4,r2                                  ; r4 -> list item
        LDR     lr,NBuffersTotal                       ; inc allocated count
        ADD     lr,lr,#1
        STR     lr,NBuffersTotal

; put item in free list

        LDR     lr,CDFreeList
        STR     lr,[r4,#CDLI_Next]
        STR     r4,CDFreeList
        MOV     lr,#0
        STR     lr,[r4,#CDLI_BufferDescriptorPtr]       ; in case claim fails
 ]

; claim buffer descriptor

        DLine   "Claiming buffer descriptor"
        MOV     r0, #ModHandReason_Claim
        MOV     r3, #BufferDescriptorSize               ; claim buffer descriptor
        SWI     XOS_Module
        Pull    "r3"
        BVS     %FT90

 [ CD
  [ cdebug
        CDebug_StrReg8  "buffer descriptor @ ",r2
  ]
        STR     r2,[r4,#CDLI_BufferDescriptorPtr]
        MOV     r4,r2
 |
        MOV     r4, r2
        LDR     lr, NBuffersTotal                       ; one more buffer descriptor allocated (may not have any data)
        ADD     lr, lr, #1
        STR     lr, NBuffersTotal

        LDR     lr, FreeBufferListHeadPtr
        STR     lr, [r4, #BufferDescriptor_Link]
        STR     r4, FreeBufferListHeadPtr
 ]
        STR     r3, [r4, #BufferDescriptor_Length]
        MOV     lr, #0
        STR     lr, [r4, #BufferDescriptor_FreeRoutine]
        LDR     lr, =XVSP_FreeBuffer                    ; SWI number to call to free buffer
        STR     lr, [r4, #BufferDescriptor_FreeWorkspace]

        DReg    r3, "Claiming actual buffer of size "

        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module                              ; claim actual buffer
        MOVVS   r2, #0
        STR     r2, [r4, #BufferDescriptor_Start]       ; save pointer to block (or zero) in buffer descriptor before exiting
  [ cdebug
        CDebug_StrReg8  "buffer @ ",r2
  ]

        BVC     %BT10

        DLine   "Exiting AllocateBuffers with error"

90
        STRVS   r0, [sp]
        EXIT

        LTORG

debug   SETL    {FALSE}

; **************************************************************************
;
;       FreeBuffers - Called by CloseStream or background callback to free all buffers on list
;

FreeBuffers Entry "r0-r2"
10
        MOV     r2, pc
        ORR     lr, r2, #I_bit
        TEQP    lr, #0                                  ; disable IRQs

        LDR     lr, NBuffersTotal                       ; load total buffers for later
 [ CD
  [ cdebug
        CDebug_StrReg8  "FreeBuffers ",lr
  ]
        LDR     r1,CDFreeList                           ; get head of list
        TEQS    r1,#0                                   ; if non-zero
        LDRNE   r0,[r1,#CDLI_Next]                      ; ...make next
        STRNE   r0,CDFreeList                           ; ...new head of list
 |
        LDR     r1, FreeBufferListHeadPtr               ; check head of list
        TEQ     r1, #0                                  ; if non-zero

        LDRNE   r0, [r1, #BufferDescriptor_Link]        ; then find next node
        STRNE   r0, FreeBufferListHeadPtr               ; and make that head
 ]
        SUBNE   lr, lr, #1                              ; and decrement total number of buffers allocated
        STRNE   lr, NBuffersTotal

        TEQ     lr, #0                                  ; check if total number of buffers is zero

        MOVEQ   lr, #StreamState_Dormant                ; if no buffers left
        STREQ   lr, StreamState                         ; mark us as dormant

        TEQP    r2, #0                                  ; restore IRQ state

        TEQ     r1, #0                                  ; if we have no buffer to free
        EXIT    EQ                                      ; then exit

 [ CD

; free up any attached buffer descriptor and its buffer
; r1 -> list item

        LDR     r2,[r1,#CDLI_BufferDescriptorPtr]
        TEQS    r2,#0
        LDRNE   r2,[r2,#BufferDescriptor_Start]         ; r2 -> buf
        TEQNES  r2,#0
        MOVNE   r0,#ModHandReason_Free                  ; if non-zero, free it
        SWINE   XOS_Module
        LDR     r2,[r1,#CDLI_BufferDescriptorPtr]       ; get bufdesc again
        TEQS    r2,#0
        MOVNE   r0,#ModHandReason_Free                  ; if non-zero, free it
        SWINE   XOS_Module

; drop through to free the list item

 |
        LDR     r2, [r1, #BufferDescriptor_Start]       ; find start of actual buffer (if any)
        TEQ     r2, #0                                  ; if we actually allocated the buffer
        MOVNE   r0, #ModHandReason_Free                 ; then free the buffer
        SWINE   XOS_Module                              ; (ignore any error from this)
 ]
        MOV     r2, r1                                  ; now free buffer descriptor
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        B       %BT10                                   ; go back for some more

; **************************************************************************
;
;       Error messages

ErrorBlock_FileOpen
        &       0
        =       "VSPFile cannot die: a stream is open", 0
        ALIGN

ErrorBlock_BuffersOnLoan
        &       0
        =       "VSPFile cannot die: not all buffers have been returned", 0
        ALIGN

ErrorBlock_StreamActive
        &       0
        =       "VSP stream already active", 0
        ALIGN

ErrorBlock_BadHandle
        &       0
        =       "Invalid VSP stream handle", 0
        ALIGN

ErrorBlock_UnknownPositionType
        &       0
        =       "Unknown stream position specifier type", 0
        ALIGN

 [ CD
ErrorBlock_CDError
        &       0
        =       "CD-ROM read error ",0  ; NOTE trailing space
        ALIGN

ErrorBlock_FileNotFound
        &       0
        =       "File not found",0
        ALIGN
 ]

; **************************************************************************
;
;       Message stuff


 [ international
CopyError ENTRY "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile ENTRY "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message ENTRY "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message ENTRY "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

        InsertDebugRoutines

;******************************************************************************

        END

; EOF s.Module
