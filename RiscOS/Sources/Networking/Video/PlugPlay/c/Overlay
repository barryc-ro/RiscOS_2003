/**************************************************************/
/* File:    Overlay.c                                         */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Overlay manager for full screen playback.         */
/*          Overlays are sprite or text items placed on the   */
/*          screen at various alignment points for a certain  */
/*          duration.                                         */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 24-Apr-2000 (ADH): Created.                       */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/toolbox.h>

#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "FromROSLib.h"
#include "Global.h"
#include "Limit.h"
#include "Utils.h"

#include "Overlay.h"

/* Local options */

#define Overlay_FontName        "Homerton.Medium"
#define Overlay_FontX           288
#define Overlay_FontY           288
#define Overlay_IconIndirection "F7A"

/* Flags definitions for the overlay structure */

#define Overlay_Deleted (1u<<0)
#define Overlay_Drawn   (1u<<1)

/* Local variables */

static bool            polling      = false;
static bool            font_claimed = false;

static unsigned int    screen_w;
static unsigned int    screen_h;
static unsigned int    font_handle;

static overlay       * overlays[oa__end];

/* Local functions */

static void              overlay_free_item   (overlay * current);

static _kernel_oserror * overlay_draw_item   (overlay * current);
static _kernel_oserror * overlay_undraw_item (overlay * current);

/**************************************************************/
/* overlay_add()                                              */
/*                                                            */
/* Add a new overlay to one of the nine known positions (see  */
/* Overlay.h). Overlays can be made of text, a sprite, or     */
/* both. If you ask for neither, a blank overlay is used -    */
/* this could be handy if you want to ensure any currently    */
/* showing overlay in a particular position is blanked for a  */
/* known length of time.                                      */
/*                                                            */
/* Parameters: Pointer to sprite name for this overlay, if    */
/*             applicable;                                    */
/*                                                            */
/*             Pointer to text for this overlay, if           */
/*             applicable;                                    */
/*                                                            */
/*             Alignment position (as an overlay_align, see   */
/*             Overlay.h);                                    */
/*                                                            */
/*             Duration of overlay in cs, or 0 for forver     */
/*             (you MUST use overlay_remove at some point);   */
/*                                                            */
/*             Pointer to an overlay structure pointer which  */
/*             is updated to point to the new item, or NULL   */
/*             if memory runs out (an error will be           */
/*             returned in this event anyway) - may be NULL   */
/*             on entry if you're not interested.             */
/**************************************************************/

_kernel_oserror * overlay_add(const char * sprite, const char * text, overlay_alignment align,
                              unsigned int duration, overlay * ret)
{
  overlay * new = calloc(1, sizeof(overlay));

  if (new == NULL)      return make_no_memory_error(4);
  if (align >= oa__end) return NULL;

  /* Fill in the new structure */

  if (text != NULL)
  {
    new->text = utils_strdup(text);
    if (new->text == NULL) return make_no_memory_error(4);
  }

  if (sprite != NULL)
  {
    new->sprite = utils_strdup(sprite);
    if (new->sprite == NULL) return make_no_memory_error(4);
  }

  new->align    = align;
  new->duration = duration;

  _swix(OS_ReadMonotonicTime,
        _OUT(0),

        &new->start_time);

  /* Link the item in */

  if (overlays[align])
  {
    overlays[align]->prev = new;
    new->next             = overlays[align];

    /* Ensure the top item is flagged as not redrawn now so that if the */
    /* new one disappears before it does it will get drawn again.       */

    overlays[align]->flags &= ~Overlay_Drawn;
  }

  overlays[align] = new;

  /* Ensure we're polling */

  if (polling == false)
  {
    register_null_claimant(Wimp_ENull, overlay_poll, NULL);
    polling = true;
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* overlay_remove()                                           */
/*                                                            */
/* Remove an item from the list of overlays. In practice the  */
/* item is just marked for deletion and the poll routine gets */
/* rid of it shortly afterwards.                              */
/*                                                            */
/* Parameters: Pointer to the item to remove.                 */
/**************************************************************/

_kernel_oserror * overlay_remove(overlay * item)
{
  item->flags |= Overlay_Deleted;
  return NULL;
}

/**************************************************************/
/* overlay_poll()                                             */
/*                                                            */
/* Poll the overlays, redrawing as necessary.                 */
/*                                                            */
/* Parameters as standard for a Wimp event handler, but not   */
/* used in practice, so this can be called directly for a     */
/* single tasking player.                                     */
/**************************************************************/

int overlay_poll(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  unsigned int time, count, i;

  _swix(OS_ReadMonotonicTime,
        _OUT(0),

        &time);

  count = 0;

  for (i = 0; i < oa__end; i++)
  {
    overlay * current = overlays[i];
    bool      undraw  = true;

    while (current)
    {
      if (
           ((current->flags & Overlay_Deleted) != 0) ||
           (
             current->duration != 0 &&
             time - current->start_time > current->duration
           )
         )
      {
        /* This item should possibly be undrawn and should be deleted */

        if (undraw)
        {
          ChkError(overlay_undraw_item(current));
          undraw = false;
        }

        overlay_free_item(current);

        /* Go around again to see if the next item should be removed too */

        current = overlays[i];
        continue;
      }
      else if ((current->flags & Overlay_Drawn) == 0)
      {
        ChkError(overlay_draw_item(current));
        current = NULL;
      }
      else break;
    }

    /* Keep track of how many empty lists there were */

    if (overlays[i] == NULL) count++;
  }

  /* If all lists were empty, stop polling */

  if (count == oa__end && polling)
  {
    deregister_null_claimant(Wimp_ENull, overlay_poll, NULL);
    polling = false;
  }

  return 0;
}

/**************************************************************/
/* overlay_free_item()                                        */
/*                                                            */
/* Assuming screen display issues have been taken care of,    */
/* free an overlay structure.                                 */
/*                                                            */
/* Parameters: Pointer to the item to free.                   */
/**************************************************************/

static void overlay_free_item(overlay * current)
{
  unsigned int i = current->align;

  if (current->text)   free(current->text);
  if (current->sprite) free(current->sprite);

  if (current->prev)          current->prev->next = current->next;
  if (current->next)          current->next->prev = current->prev;
  if (current == overlays[i]) overlays[i]         = current->next;

  free(current);
}

/**************************************************************/
/* overlay_initialise()                                       */
/*                                                            */
/* Initialise the overlay system.                             */
/**************************************************************/

void overlay_initialise(void)
{
  unsigned int i;

  for (i = 0; i < oa__end; i++)
  {
    overlays[i] = NULL;
  }

  screen_w = (bbc_modevar(-1, BBC_XWindLimit) + 1) << bbc_modevar(-1, BBC_XEigFactor);
  screen_h = (bbc_modevar(-1, BBC_YWindLimit) + 1) << bbc_modevar(-1, BBC_YEigFactor);

  ChkError(_swix(Font_FindFont,
                 _INR(1,5) | _OUT(0),

                 Overlay_FontName,
                 Overlay_FontX,
                 Overlay_FontY,
                 0,
                 0,

                 &font_handle));

  font_claimed = true;
}

/**************************************************************/
/* overlay_shutdown()                                         */
/*                                                            */
/* Free all overlay structures and stop polling, if we are.   */
/* The screen display should be tidied externally by (e.g.) a */
/* mode change or CLG after calling.                          */
/**************************************************************/

void overlay_shutdown(void)
{
  unsigned int i;

  for (i = 0; i < oa__end; i++)
  {
    while (overlays[i]) overlay_free_item(overlays[i]);
  }

  if (polling)
  {
    deregister_null_claimant(Wimp_ENull, overlay_poll, NULL);
    polling = false;
  }

  if (font_claimed == false) _swix(Font_LoseFont,
                                   _IN(0),

                                   font_handle);
}

/**************************************************************/
/* overlay_draw_item()                                        */
/*                                                            */
/* Redraw the given overlay item, flagging it as redrawn.     */
/*                                                            */
/* Parameters: Pointer to the item to redraw                  */
/**************************************************************/

static _kernel_oserror * overlay_draw_item(overlay * current)
{
  char              buffer [sizeof(Overlay_IconIndirection) - 1 + sizeof(";S") - 1 + Limits_OS_SpriteName];
  bool              undraw = false;
  int               sw, sh;
  unsigned int      sx, sy;
  unsigned int      tw, th;
  unsigned int      tx, ty;

  /* See if we've a blanking item and undraw the first non-blanking */
  /* item under it if so; check also if we've no item at all!       */

  while (
          current                 &&
          current->text == NULL   &&
          current->sprite == NULL
        )
  {
    undraw  = true;
    current = current->next;
  }

  if (current == NULL) return NULL;
  if (undraw) return overlay_undraw_item(current);

  dprintf(("",
           "Draw item '%s', '%s' at %d\n",
           current->text   ? current->text   : "<NULL>",
           current->sprite ? current->sprite : "<NULL>",
           current->align));

  current->flags |= Overlay_Drawn;

  /* Work out the sprite size */

  sw = sh = 0;

  if (current->sprite != NULL)
  {
    RetError(read_sprite_size(current->sprite, &sw, &sh));
  }

  /* Work out the text size */

  tw = th = 0;

(void) ty;
(void) tx;
(void) sy;
(void) sx;
(void) buffer;


return NULL;

//  if (current->text != NULL)
//  {
//    RetError(_swix(Font_ScanString,
//                   _INR(0,7),
//
//                   font_handle,
//                   current->text,
//
//  }
//
//
//  /* Work out the bounding box for each of the nine positions. Each icon */
//  /* gets a ninth of the screen area. This is mostly for text purposes   */
//  /* as the Wimp will happily plot sprites outside of the bounding box.  */
//
//  switch (current->align)
//  {
//    default:
//    case oa_top_left:
//    {
//      icon.bbox.xmin = 0;
//      icon.bbox.ymin = screen_h - height;
//      icon.bbox.xmax = screen_w / 3;
//      icon.bbox.ymax = screen_h - 1;
//    }
//    break;
//
//    case oa_top_centre:
//    {
//      icon.bbox.xmin = (screen_w / 2) - (screen_w / 6);
//      icon.bbox.ymin = screen_h       - height;
//      icon.bbox.xmax = (screen_w / 2) + (screen_w / 6);
//      icon.bbox.ymax = screen_h       - 1;
//
//      icon.flags |= WimpIcon_HCentred;
//    }
//    break;
//
//    case oa_top_right:
//    {
//      icon.bbox.xmin = screen_w - (screen_w / 3);
//      icon.bbox.ymin = screen_h - height;
//      icon.bbox.xmax = screen_w - 1;
//      icon.bbox.ymax = screen_h - 1;
//
//      icon.flags |= WimpIcon_RJustified;
//    }
//    break;
//
//    case oa_middle_left:
//    {
//      icon.bbox.xmin = 0;
//      icon.bbox.ymin = (screen_h / 2) - (screen_h / 6);
//      icon.bbox.xmax = (screen_w / 3);
//      icon.bbox.ymax = (screen_h / 2) + (screen_h / 6);
//    }
//    break;
//
//    case oa_middle_centre:
//    {
//      icon.bbox.xmin = (screen_w / 2) - (screen_w / 6);
//      icon.bbox.ymin = (screen_h / 2) - (screen_h / 6);
//      icon.bbox.xmax = (screen_w / 2) + (screen_w / 6);
//      icon.bbox.ymax = (screen_h / 2) + (screen_h / 6);
//
//      icon.flags |= WimpIcon_HCentred;
//    }
//    break;
//
//    case oa_middle_right:
//    {
//      icon.bbox.xmin = screen_w - (screen_w / 3);
//      icon.bbox.ymin = (screen_h / 2) - (screen_h / 6);
//      icon.bbox.xmax = (screen_w - 1);
//      icon.bbox.ymax = (screen_h / 2) + (screen_h / 6);
//
//      icon.flags |= WimpIcon_RJustified;
//    }
//    break;
//
//    case oa_bottom_left:
//    {
//      icon.bbox.xmin = 0;
//      icon.bbox.ymin = 0;
//      icon.bbox.xmax = screen_w / 3;
//      icon.bbox.ymax = screen_h / 3;
//    }
//    break;
//
//    case oa_bottom_centre:
//    {
//      icon.bbox.xmin = (screen_w / 2) - (screen_w / 6);
//      icon.bbox.ymin = 0;
//      icon.bbox.xmax = (screen_w / 2) + (screen_w / 6);
//      icon.bbox.ymax = (screen_h / 3);
//
//      icon.flags |= WimpIcon_HCentred;
//    }
//    break;
//
//    case oa_bottom_right:
//    {
//      icon.bbox.xmin = screen_w - (screen_w / 3);
//      icon.bbox.ymin = 0;
//      icon.bbox.xmax = screen_w - 1;
//      icon.bbox.ymax = screen_h / 3;
//
//      icon.flags |= WimpIcon_RJustified;
//    }
//    break;
//  }
//
//  /* Font stuff */
//
//  icon.flags |= WimpIcon_AntiAliased;
//  icon.flags |= font_handle * WimpIcon_FontHandle;
//
//  /* Now the main icon data */
//
//  if (current->sprite != NULL)
//  {
//    sprintf(buffer, "%s%s", Overlay_IconIndirection, ";S");
//    strncat(buffer, current->sprite, Limits_OS_SpriteName);
//
//    buffer[sizeof(buffer) - 1] = '\0';
//  }
//  else
//  {
//    strcpy(buffer, Overlay_IconIndirection);
//  }
//
//  icon.data.ist.buffer      = current->text ? current->text : "";
//  icon.data.ist.validation  = buffer;
//  icon.data.ist.buffer_size = strlen(icon.data.ist.buffer);
//
//  return _swix(Wimp_PlotIcon,
//               _IN(1) | _INR(4,5),
//
//               &icon,
//               0,
//               0);
}

/**************************************************************/
/* overlay_undraw_item()                                      */
/*                                                            */
/* "Undraw" the given overlay item - clear the screen space   */
/* it occupied. The undrawn item is not freed in case the     */
/* caller needs to do more with it, so the caller is          */
/* responsible for calling overlay_free_item later.           */
/*                                                            */
/* Parameters: Pointer to the item to redraw                  */
/**************************************************************/

static _kernel_oserror * overlay_undraw_item(overlay * current)
{
  if (current == NULL) return NULL;

  dprintf(("",
           "Undraw item '%s', '%s' at %d\n",
           current->text   ? current->text   : "<NULL>",
           current->sprite ? current->sprite : "<NULL>",
           current->align));

  return NULL;
}
