/**************************************************************/
/* File:    FullScreen.c                                      */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Core routines for full screen video playback with */
/*          Video Control and RTSP URLs.                      */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 18-Apr-2000 (ADH): Created.                       */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include <kernel.h>
#include <swis.h>
#include <Global/SWIs.h>
#include <Global/Services.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <SVBmip.h>
#include <VideoCtrl.h>

#include "Mouse.h"
#include "Parameters.h"
#include "Play.h"
#include "PlugIn.h"
#include "Overlay.h"
#include "URLutils.h"
#include "Utils.h"

#include "FullScreen.h"

/* Local definitions */

/* This defines a string which is strstr'd in a URL. If found, a channel */
/* number is expected to follow it and SVBmip will be called to get a    */
/* channel name; the "up/down" channel hopping stuff is then activated   */
/* as well.                                                              */

#define FullScreen_ChannelID "channel="

/* This is the time in cs that the channel change stuff stays up */
/* before channel is changed automatically (so user can type in  */
/* '001' and change directly, or '1' and wait for this delay).   */

#define FullScreen_ChannelDelay 100u

/* Length of time an error message is up before auto-destruct in cs */

#define FullScreen_AutoDestructTimer 400u

/* This is the number of digits we allow in a channel number. Must not be */
/* zero!                                                                  */

#define FullScreen_Digits 3u

/* Error number we expect from SVB_EnumerateChannels for an invalid */
/* channel number.                                                  */

#define FullScreen_BadChannelError 0x81730A

/* Local structures */

typedef struct channel_description
{
  unsigned int   size;
  unsigned int   channel_handle;
  unsigned int   channel_number;
  char         * name;
  char         * parameters;
  unsigned int   flags;
  unsigned int   joins;
  unsigned int   leaves;
  unsigned int   port;
  unsigned int   in_addr;

  char           data[64 + 256];

} channel_description;

/* Local variables */

static play_session    * fullscreen_session = NULL;
static unsigned int      fullscreen_plugin  = 0;
static bool              fullscreen_nulls   = false;
static bool              fullscreen_keys    = false;
static overlay         * fullscreen_waiting = NULL;
static url_description * fullscreen_url     = NULL;
static char            * fullscreen_name    = NULL;
static bool              fullscreen_mcast   = false;
static unsigned int      fullscreen_timer   = 0;
static char              fullscreen_cbuffer [FullScreen_Digits + 1];
static bool              fullscreen_autodn  = false;
static unsigned int      fullscreen_autodt  = 0;
static overlay         * fullscreen_ov1     = NULL;
static overlay         * fullscreen_ov2     = NULL;

/* Our overlay handle is self-allocated as "FULL" */

static unsigned int fullscreen_overlay_handle = 0x4C4C5546;

/* Local functions */

static _kernel_oserror * fullscreen_play_callback            (play_session * s, unsigned int response);
static const char      * fullscreen_determine_icon           (play_session * s);

static int               fullscreen_keypress                 (int eventcode, WimpPollBlock * block, IdBlock * idb, void * handle);

static _kernel_oserror * fullscreen_get_channel_name         (unsigned int channel, char ** name);
static _kernel_oserror * fullscreen_change_channel           (unsigned int chan_no);
static _kernel_oserror * fullscreen_change_channel_and_check (unsigned int chan_no);
static int               fullscreen_channel_poll             (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);

static int               fullscreen_auto_destruct            (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);

/**************************************************************/
/* fullscreen_start()                                         */
/*                                                            */
/* Start full screen video playback. Will not return an error */
/* unless the overlay system is up with a window open; any    */
/* errors before that are thrown high with ChkError. Callers  */
/* should run this function's return value through            */
/* fullscreen_report_error, ideally.                          */
/*                                                            */
/* Parameters: RTSP URL for the video to play;                */
/*                                                            */
/*             If being launched on behalf of another plug-in */
/*             (so e.g. all our deviations from default       */
/*             options will be stored in that other item),    */
/*             pass its plug-in instance handle here, else    */
/*             pass in zero.                                  */
/**************************************************************/

_kernel_oserror * fullscreen_start(const char * url, unsigned int launcher)
{
  char       * start;
  const char * end;

  if (url == NULL) return NULL;

  #ifdef TRACE
    if (tl & (1u<<31)) dprintf(("", "fullscreen_start: Called for '%s'\n",url));
  #endif

  /* Shut down and restart the overlay system to ensure */
  /* any current overlays are cancelled.                */

  overlay_shutdown();
  overlay_initialise();

  fullscreen_ov1 = fullscreen_ov2 = NULL;

  /* Open a full-screen window via. stand-alone plug-in instance */

  ChkError(overlay_open_window(&fullscreen_plugin));
  plugin_set_launcher(fullscreen_plugin, launcher);

  // TBD - if we turn this off and it used to be on, the browser doesn't
  // know and doesn't reactivate it when the mouse next moves. This means
  // we don't have to rectangle the mouse to not move, but it means we
  // need to now if the pointer was on, and therefore, should we restore
  // it afterwards.
  //
  // mouse_pointer_off();

  /* General key press handler. We can do RetError now */

  RetError(event_register_wimp_handler(-1, Wimp_EKeyPressed, fullscreen_keypress, NULL));
  fullscreen_keys = true;

  /* Get a new playback session and kick off playback */

  RetError(play_new_session(&fullscreen_session));

  fullscreen_session->plugin   = fullscreen_plugin;
  fullscreen_session->callback = fullscreen_play_callback;

  RetError(play_setup(fullscreen_session, url));

  /* Take a copy of the URL */

  if (fullscreen_url != NULL) urlutils_free_description(fullscreen_url);
  fullscreen_url = urlutils_return_description(url);
  if (fullscreen_url == NULL)return make_no_memory_error(9);

  /* If this is a ".mpi" item, take the stuff from "/" to ".mpi" */

  fullscreen_mcast = false;

  if ((end = strstr(url, ".mpi")) != NULL)
  {
    start = strrchr(url, '/');

    if (start != NULL && start < end)
    {
      free(fullscreen_name);

      fullscreen_name = malloc(end - start + 2); /* end-start includes terminator, but need '"' at either end */

      if (fullscreen_name != NULL)
      {
        memcpy(fullscreen_name + 1, start + 1, end - start - 1);

        *(fullscreen_name)                     = '"';
        *(fullscreen_name + (end - start))     = '"';
        *(fullscreen_name + (end - start) + 1) = '\0';
      }
    }
  }

  /* If this is destined for SVBGeneric, we understand it as a multicast */
  /* item that can be a channel number or (in later versions) a direct   */
  /* specified IP address with possible adjoining name.                  */

  else if (fullscreen_session->swi_base == SVBGenericSWI_Base)
  {
    char * found;

    fullscreen_mcast = true;
    found            = parameters_find_item(fullscreen_url->query,
                                            Parameters_ChannelNumber);

    if (found != NULL)
    {
      char           channel[17 + 64]; /* 17 for number plus terminator and ": ", 64 for channel name */
      char         * name;
      unsigned int   chan_no;

      chan_no = atoi(found);

      if (
           fullscreen_get_channel_name(chan_no, &name) != NULL ||
           name                                        == NULL
         )
      {
        sprintf(channel, "%d", chan_no);
      }
      else
      {
        if (strlen(name) > 64) name[64] = '\0';
        sprintf(channel, "%d: %s", chan_no, name);
        free(name);
      }

      fullscreen_name = utils_strdup(channel);
    }
    else
    {
      found = parameters_find_item(fullscreen_url->query,
                                   Parameters_ChannelName);

      if (found == NULL) fullscreen_name = utils_strdup("");
      else               fullscreen_name = utils_strdup(found), free(found);
    }
  }

  /* Maybe it's a file URL */

  else if (!utils_strncasecmp(url, MPEGMethod3, sizeof(MPEGMethod3) - 1))
  {
    if (fullscreen_url->path != NULL)
    {
      end = strrchr(fullscreen_url->path, '/');

      if (end == NULL) end = strrchr(fullscreen_url->path, ':');
      if (end == NULL) end = fullscreen_url->path;
      else end++;

      if (*end != '\0')
      {
        fullscreen_name = malloc(strlen(end) + 3);
        if (fullscreen_name != NULL) sprintf(fullscreen_name, "\"%s\"", end);
      }
    }
  }

  /* If we got a name, show it */

  if (fullscreen_name != NULL)
  {
    overlay_add("tv",
                fullscreen_name,
                oa_bottom_left,
                400,
                NULL,
                fullscreen_overlay_handle);
  }

  /* If we're not looking at multicast data, put up the clock. */
  /* The "not multicast" exclusion is there because there's a  */
  /* small delay, but only a very small one, and the flicking  */
  /* on and off of the clock - especially when channel hopping */
  /* - is annoying.                                            */

  if (!fullscreen_mcast && fullscreen_waiting == NULL)
  {
    overlay_add("wait",
                NULL,
                oa_top_right,
                0,
                &fullscreen_waiting,
                fullscreen_overlay_handle);
  }

  #ifdef TRACE
    if (tl & (1u<<31)) dprintf(("", "fullscreen_start: Successful\n"));
  #endif

  return NULL;
}

/**************************************************************/
/* fullscreen_shutdown()                                      */
/*                                                            */
/* Shut down full screen playback. Caller is responsible for  */
/* calling overlay_shutdown() if they want to ensure any      */
/* pending or displaying overlays are cleared.                */
/*                                                            */
/* If closing down overlays, call *before* overlay_shutdown!  */
/**************************************************************/

_kernel_oserror * fullscreen_shutdown(void)
{
  #ifdef TRACE
    if (tl & (1u<<31)) dprintf(("", "fullscreen_shutdown: Called\n"));
  #endif

  if (fullscreen_nulls)
  {
    deregister_null_claimant(Wimp_ENull,
                             fullscreen_channel_poll,
                             NULL);

    fullscreen_nulls = false;
    fullscreen_timer = 0;
  }

  if (fullscreen_autodn)
  {
    deregister_null_claimant(Wimp_ENull,
                             fullscreen_auto_destruct,
                             (void *) FullScreen_AutoDestructTimer);

    fullscreen_autodn = false;
    fullscreen_autodt = 0;
  }

  free(fullscreen_name), fullscreen_name = NULL;

  if (fullscreen_url != NULL)
  {
    urlutils_free_description(fullscreen_url);
    fullscreen_url = NULL;
  }

  overlay_remove(NULL, fullscreen_overlay_handle);

  fullscreen_ov1     = NULL;
  fullscreen_ov2     = NULL;
  fullscreen_waiting = NULL;

  overlay_poll(0, NULL, NULL, NULL);

  if (fullscreen_keys)
  {
    event_deregister_wimp_handler(-1, Wimp_EKeyPressed, fullscreen_keypress, NULL);
    fullscreen_keys = false;
  }

  if (
       fullscreen_session                != NULL &&
       fullscreen_session->auto_destruct == 0
     )
  {
    play_delete_session(fullscreen_session);
    fullscreen_session = NULL;
  }

  if (fullscreen_plugin != 0)
  {
    plugin_delete_stand_alone(fullscreen_plugin);
    fullscreen_plugin = 0;
  }

  return NULL;
}

/**************************************************************/
/* fullscreen_handle_eos()                                    */
/*                                                            */
/* Handle an end-of-stream event. Will shut down the session  */
/* immediately, after warning of a stream timeout, or not at  */
/* all according to the event's nature.                       */
/*                                                            */
/* The function attempts to run any errors raised internally  */
/* through fullscreen_report_error, and will only return a    */
/* non-NULL result if this wasn't possible for some reason.   */
/*                                                            */
/* Parameters: Pointer to the SWI register payload of a       */
/*             Wimp message from TaskModule reporting a       */
/*             service call for Service_VideoControl 5        */
/*             (VideoControlPlayStateChanged).                */
/**************************************************************/

_kernel_oserror * fullscreen_handle_eos(_kernel_swi_regs * r)
{
  /* The Video Control client ID should be in R2 */

  if (fullscreen_session == NULL || r->r[2] != fullscreen_session->handle) return NULL;

  /* Is this a normal or error based timeout? We only take it as a */
  /* timeout if the flag saying "read new status" is set and the   */
  /* status says "timeout EOS".                                    */

  if ((r->r[3] & VC_SVC_NewPlayState_StateIsInR4) != 0)
  {
    _kernel_oserror * e;
    int               opts[4];
    vc_play_state     state;

    opts[0] = vc_tags_play_state;
    opts[1] = 1;
    opts[2] = 0;
    opts[3] = vc_tags__end;

    e = _swix(VideoControl_Options,
               _INR(0,2),

               VC_Options_ReadValues,
               fullscreen_session->handle,
               opts);

    if (e != NULL)
    {
      if (!fullscreen_report_error(e, true)) return e;
      else                                   return NULL;
    }

    state = (vc_play_state) opts[2];

    /* A timeout? If so, raise a nice error rather than just exitting */

    if (state == vc_play_state_timeout_eos)
    {
      erb.errnum = Utils_Error_Custom_Message;

      StrNCpy0(erb.errmess,
               lookup_token("Timeout:Video stream ended due to timeout",
                            0,
                            0));

      if (!fullscreen_report_error(&erb, true)) return &erb;
      else                                      return NULL;
    }
    else if (
              state != vc_play_state_normal_eos
            )
            return NULL; /* I.e, "huh?" - this is one of those Should Never Happen things */
  }

  /* We often briefly see EOS for looping playback since the looping is done */
  /* client-side; the issue 3E Video Control specification, for example,     */
  /* warns of this, in the tag 24 documentation in the options table.        */
  /*                                                                         */
  /* Don't check this flag any earlier, by the way - we need to have made    */
  /* sure this wasn't an end of stream due to timeout beforehand.            */

  if (fullscreen_session->loop != 0) return NULL;

  /* Right then, that just about wraps it up - that end of stream signal */
  /* really was for us and really did mean a normal end of stream.       */

  fullscreen_shutdown();

  return NULL;
}

/**************************************************************/
/* fullscreen_report_error()                                  */
/*                                                            */
/* If there's an error during fullscreen_start, report it     */
/* with an overlay that auto-destructs the fullscreen system  */
/* when removed.                                              */
/*                                                            */
/* Parameters: Pointer to the error to report - may be NULL   */
/*             to take no action;                             */
/*                                                            */
/*             If true, the play session is killed outright;  */
/*             this is unsafe if calling from within any      */
/*             routine that deals with the play session       */
/*             linked list or is called from something that   */
/*             deals with it, for obvious reasons. In such    */
/*             cases pass 'false', and put up with the play   */
/*             session persisting until fullscreen_shutdown   */
/*             gets called. This may mean video continues to  */
/*             play back under the error, depending on the    */
/*             nature of that error.                          */
/*                                                            */
/* Returns:    true if action was taken or the error block    */
/*             pointer passed in was NULL, else false -       */
/*             callers may wish to try an alternative error   */
/*             reporting method in the latter case.           */
/**************************************************************/

bool fullscreen_report_error(_kernel_oserror * e, bool kill)
{
  if (e                 == NULL) return true;
  if (fullscreen_plugin == 0)    return false;

  /* Remove all existant overlays */

  overlay_remove(NULL, fullscreen_overlay_handle);

  /* Add our message */

  overlay_add("warning",
              e->errmess,
              oa_middle_centre,
              FullScreen_AutoDestructTimer,
              NULL,
              fullscreen_overlay_handle);

  /* If we're called when auto destruct is already counting, something's */
  /* very wrong - so keep counting, don't reset the timer!               */

  if (fullscreen_autodn == false)
  {
    _swix(OS_ReadMonotonicTime,
          _OUT(0),

          &fullscreen_autodt);

    register_null_claimant(Wimp_ENull,
                           fullscreen_auto_destruct,
                           (void *) FullScreen_AutoDestructTimer);

    fullscreen_autodn = true;
  }

  /* Kill the session, if asked */

  if (kill && fullscreen_session != NULL && fullscreen_session->auto_destruct == 0)
  {
    play_delete_session(fullscreen_session);
    fullscreen_session = NULL;
  }

  return true;
}

/**************************************************************/
/* fullscreen_get_plugin()                                    */
/*                                                            */
/* Return the instance handle for the pseudo plug-in we're    */
/* using for playback.                                        */
/*                                                            */
/* Returns:    Instance handle of truly stand-alone plug-in.  */
/**************************************************************/

unsigned int fullscreen_get_plugin(void)
{
  return fullscreen_plugin;
}

/**************************************************************/
/* fullscreen_play_callback()                                 */
/*                                                            */
/* Play callback function. Will be called after play_poll has */
/* looked at any server response. Allows us to shut down      */
/* sessions if errors occur during setup, etc.                */
/*                                                            */
/* Parameters: Pointer to relevant play_session struct;       */
/*                                                            */
/*             Server response code.                          */
/**************************************************************/

static _kernel_oserror * fullscreen_play_callback(play_session * s, unsigned int response)
{
  char   number[24];
  char * use = number;

  #ifdef TRACE
    if (tl & (1u<<31)) dprintf(("", "fullscreen_play_callback: Called for %p, %d\n", s, response));
  #endif

  if (s->current_speed > 1)
  {
    play_build_speed(s->current, s->current_speed, number + 1, false);

    if (number[1] == '-') use++;
    *use = '×';
  }
  else use = NULL;

  /* If we're setting up, leave things alone. Overlay consequences of any */
  /* setup-time errors are handled by fullscreen_report_error. If we're   */
  /* playing, though, remove the clock and dislay an appropriate overlay  */
  /* given the response code we've been passed.                           */

  if (s->setting_up == 0)
  {
    if (fullscreen_waiting)
    {
      overlay_remove(fullscreen_waiting, NULL);
      fullscreen_waiting = NULL;
    }

    if (
         response >= Play_Response_OK_Lower &&
         response <= Play_Response_OK_Upper
       )
    {
      /* OK, operation successful. Cue overlay. */

      overlay_add(fullscreen_determine_icon(s),
                  use,
                  oa_top_right,
                  200,
                  NULL,
                  fullscreen_overlay_handle);
    }
    else
    {
      /* If not supported, show "X" */

      if (response == Play_Response_NotSupported)
      {
        overlay_add(fullscreen_determine_icon(s), use,    oa_top_right, 200, NULL, fullscreen_overlay_handle);
        overlay_add("disabled",                   NULL,   oa_top_right, 100, NULL, fullscreen_overlay_handle);
      }

      /* Other errors are dealt with already - play_poll will have called */
      /* fullscreen_report_error before calling here.                     */
    }
  }

  /* Reflect the change immediately */

  overlay_poll(0, NULL, NULL, NULL);

  return NULL;
}

/**************************************************************/
/* fullscreen_determine_icon()                                */
/*                                                            */
/* Return a pointer to a read-only sprite name determined     */
/* from the current play mode in the given play session.      */
/*                                                            */
/* Speed is not taken into account.                           */
/*                                                            */
/* Parameters: Pointer to a relevant play_session structure.  */
/*                                                            */
/* Returns:    Pointer to a read-only sprite name.            */
/**************************************************************/

static const char * fullscreen_determine_icon(play_session * s)
{
  if (s->setting_up) return "wait";

  switch (s->current)
  {
    default:
    case play_mode_none:   return "blank_tv";
    case play_mode_frwd:   return "fr";
    case play_mode_srwd:   return "last";
    case play_mode_pause:  return "pause";
    case play_mode_sfwd:   return "next";
    case play_mode_normal: return "play";
    case play_mode_ffwd:   return "ff";
  }
}

/**************************************************************/
/* fullscreen_wait()                                          */
/*                                                            */
/* Wait for a response from a server through Video Control.   */
/* Note that this is a blocking process.                      */
/*                                                            */
/* Parameters: Pointer to an unsigned int, into which the     */
/*             server response code is written (unless an     */
/*             error is returned).                            */
/**************************************************************/

_kernel_oserror * fullscreen_wait(unsigned int * response)
{
  unsigned int status, code;

  #ifdef TRACE
    if (tl && (1u<<31)) dprintf(("", "fullscreen_wait: Called\n"));
  #endif

  do
  {
    RetError(_swix(VideoControl_Status,
                   _INR(0,1) | _OUT(0) | _OUT(2),

                   0,
                   fullscreen_session->handle,

                   &status,
                   &code));

  }
  while ((status & VC_Status_NewStatus) == 0);

  #ifdef TRACE
    if (tl && (1u<<31)) dprintf(("", "fullscreen_wait: Response %d\n", code));
  #endif

  if (response != NULL) *response = code;

  return NULL;
}

/**************************************************************/
/* fullscreen_get_channel_name                                */
/*                                                            */
/* Get a given channel number's name.                         */
/*                                                            */
/* Parameters: Channel number;                                */
/*                                                            */
/*             Pointer to a char *, updated to point to a     */
/*             malloc block holding the name or NULL for some */
/*             unforseen circumstance. Out of memory is       */
/*             reported directly. The caller must free the    */
/*             malloc block when appropriate.                 */
/**************************************************************/

static _kernel_oserror * fullscreen_get_channel_name(unsigned int channel, char ** name)
{
  channel_description buffer;
  int                 done;

  *name = NULL;

  RetError(_swix(SVB_EnumerateChannels,
                 _INR(0,4) | _OUT(4),

                 1u<<1, /* Read specific channel number */
                 channel,
                 &buffer,
                 sizeof(buffer),
                 1,

                 &done));

  if (done == 0) return NULL;
  else *name = utils_strdup(buffer.name);

  if (*name == NULL) return make_no_memory_error(7);
  else               return NULL;
}

/**************************************************************/
/* fullscreen_overlay_callback()                              */
/*                                                            */
/* An overlay callback function set up from the key handler   */
/* for the time display shown when "I" / "Info" / "i" / "?"   */
/* (or whatever!) is pressed. Constructs a new NPT string,    */
/* compares it with the current string, and if there's a      */
/* change alters the overlay text string and returns a non-   */
/* zero value to signal a redraw is needed.                   */
/*                                                            */
/* Parameters: Pointer to the overlay structure in question,  */
/*             cast to void *.                                */
/*                                                            */
/* Returns:    0 for any internal failure or if there is no   */
/*             need to redraw the item yet, else 1.           */
/**************************************************************/

static int fullscreen_overlay_callback(void * v)
{
  play_session * ps;
  overlay      * o = (overlay *) v;

  if (o != NULL && o->text != NULL && o->cbhandle != NULL)
  {
    int opt[4];

    ps = (play_session *) o->cbhandle;

    opt[0] = vc_tags_npt;
    opt[1] = 1;
    opt[2] = 0;
    opt[3] = vc_tags__end;

    if (
         _swix(VideoControl_Options,
               _INR(0,2),

               VC_Options_ReadValues,
               ps->handle,
               opt)

         == NULL
       )
    {
      unsigned int hours, minutes, seconds;
      char         n[17 + 17 + 17]; /* <number>:<number>:<number><terminator> */

      hours   = opt[2] / 3600;
      opt[2] -= hours * 3600;
      minutes = opt[2] / 60;
      seconds = opt[2] - minutes * 60;

      sprintf(n, "%02d:%02d:%02d", hours, minutes, seconds);

      if (strcmp(o->text, n))
      {
        char * ot = o->text;

        o->text = utils_strdup(n);

        if (o->text == NULL)
        {
          o->text = ot;
          return 0;
        }
        else
        {
          o->antiflicker = 1;
          return 1;
        }
      }
    }
  }

  return 0;
}

/**************************************************************/
/* fullscreen_keypress()                                      */
/*                                                            */
/* Deal with keyboard pressed events from the Wimp.           */
/* Parameters are as standard for a Wimp event handler.       */
/**************************************************************/

static int fullscreen_keypress(int eventcode, WimpPollBlock * block, IdBlock * idb, void * handle)
{
  unsigned int key = ((WimpKeyPressedEvent *) block)->key_code;

  #ifdef TRACE
    if (tl & (1u<<31)) dprintf(("", "fullscreen_keypress: Called for key %d\n",key));
  #endif

  // Even the unobservant will notice that this is toilet roll code
  // at its worst, built up over a series of days/weeks from a
  // function of initially sane construction into a leviathan. At
  // some point, the individual key handling code chunks want to go
  // into service functions for black-boxing and clarifying the key
  // handling path (ADH, 05-Jul-2000 - it's all my fault anyway).

  /* First pass - is this keypress allowed in the current context? Deal */
  /* with overlay issues and so-on too.                                 */

  switch (key)
  {
    /* Always allow "stop" */

    case 83:
    case 115: /* "S", "s" */
    case 459: /* Stop */
    case 387: /* Home */
    {
      fullscreen_shutdown();
      return 1;
    }
    break;

    /* Show current clip name / channel number & name */

    case 63:
    case 73:
    case 105: /* "?", "I", "i" */
    case 386: /* Info */
    {
      bool   done_mode = false;
      bool   done_name = false;
      bool   done_time = false;
      bool   persist;

      char   number    [24];
      char * use       = number;

      persist = plugin_get_persistence(fullscreen_plugin);

      /* If using a persistent info display and there's something shown right */
      /* now, remove the information                                          */

      if (
           persist == true &&
           (
             fullscreen_ov1 != NULL ||
             fullscreen_ov2 != NULL
           )
         )
      {
        if (fullscreen_ov1 != NULL) overlay_remove(fullscreen_ov1, 0);
        if (fullscreen_ov2 != NULL) overlay_remove(fullscreen_ov2, 0);

        fullscreen_ov1 = fullscreen_ov2 = NULL;
        done_name      = done_time      = true;
      }
      else
      {
        /* Otherwise, (re)-show things */

        if (fullscreen_session->current_speed > 1)
        {
          play_build_speed(fullscreen_session->current,
                           fullscreen_session->current_speed,
                           number + 1,
                           false);

          if (number[1] == '-') use++;
          *use = '×';
        }
        else use = NULL;

        /* Current play mode */

        if (
             overlay_add(fullscreen_determine_icon(fullscreen_session),
                         use,
                         oa_top_right,
                         200,
                         NULL,
                         fullscreen_overlay_handle)
             != NULL
           )
        {
          done_mode = false;
        }
        else
        {
          done_mode = true;
        }

        /* If we got a name, show it */

        if (fullscreen_name != NULL)
        {
          if (
               overlay_add("tv",
                           fullscreen_name,
                           oa_bottom_left,
                           persist ? 0 : 200,
                           persist ? &fullscreen_ov1 : NULL,
                           fullscreen_overlay_handle)
               != NULL
             )
          {
            fullscreen_ov1 = NULL;
            done_name      = false;
          }
          else
          {
            done_name = true;
          }
        }

        /* Try to read the NPT */

        if (fullscreen_session != NULL && fullscreen_session->handle != 0)
        {
          int opt[4];

          opt[0] = vc_tags_npt;
          opt[1] = 1;
          opt[2] = 0;
          opt[3] = vc_tags__end;

          if (
               _swix(VideoControl_Options,
                     _INR(0,2),

                     VC_Options_ReadValues,
                     fullscreen_session->handle,
                     opt)

               == NULL
             )
          {
            unsigned int   hours, minutes, seconds;
            char           n[17 + 17 + 17]; /* <number>:<number>:<number><terminator> */
            overlay      * o;

            hours   = opt[2] / 3600;
            opt[2] -= hours * 3600;
            minutes = opt[2] / 60;
            seconds = opt[2] - minutes * 60;

            sprintf(n, "%02d:%02d:%02d", hours, minutes, seconds);

            if (
                 overlay_add(done_name ? "blank_tv" : NULL,
                             n,
                             oa_bottom_right,
                             persist ? 0 : 200,
                             &o,
                             fullscreen_overlay_handle)
                 != NULL
               )
            {
              fullscreen_ov2 = NULL;
              done_time      = false;
            }
            else
            {
              fullscreen_ov2 = persist ? o : NULL;
              done_time      = true;

              o->callback = fullscreen_overlay_callback;
              o->cbhandle = (void *) fullscreen_session;
              o->kern_off = 1;
            }
          }
        }
      }

      if (done_mode || done_name || done_time) overlay_poll(0, NULL, NULL, NULL);
    }
    break;

    /* Channel changing */

    case 398:
    case 399: /* Down, Up */
    {
      if (fullscreen_mcast)
      {
        unsigned int prev, current, next;

        if (
             _swix(SVB_ReadChannel,
                   _INR(0,2) | _OUT(0) | _OUTR(3,4),

                   1u<<1, /* R3 and R4 to hold prev/next channels on exit */
                   0,
                   0,

                   &current,
                   &prev,
                   &next)

             == NULL

             && current != -1
           )
        {
          ChkError(fullscreen_change_channel_and_check(key == 398 ? prev : next));
        }
      }
      else
      {
        /* Another case of "can't do that" - this isn't a (recognised) multicast stream. */

        overlay_add("disabled",
                    NULL,
                    oa_top_right,
                    100,
                    NULL,
                    fullscreen_overlay_handle);
      }

      /* We claim these keys whether or not a channel change was done */

      return 1;
    }
    break;

    /* Channel changing is always allowed */

    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:  /* "0" through "9" */
    {
      if (fullscreen_mcast)
      {
        char str[2];

        /* Ensure the timer is reset for each number entered */

        _swix(OS_ReadMonotonicTime,
              _OUT(0),

              &fullscreen_timer);

        /* Register a null claimant if we haven't already got one. */

        if (fullscreen_nulls == false)
        {
          register_null_claimant(Wimp_ENull,
                                 fullscreen_channel_poll,
                                 NULL);

          fullscreen_nulls    = true;
          *fullscreen_cbuffer = '\0';
        }

        /* Append the key to the buffer */

        sprintf(str, "%d", key - 48);
        strcat(fullscreen_cbuffer, str);

        /* Display it immediately */

        overlay_add("goto",
                    fullscreen_cbuffer,
                    oa_bottom_left,
                    FullScreen_ChannelDelay,
                    NULL,
                    fullscreen_overlay_handle);

        overlay_poll(0, NULL, NULL, NULL);

        /* Change channel if we've 'n' numbers */

        if (strlen(fullscreen_cbuffer) >= FullScreen_Digits) /* We hope it's never "greater than"! */
        {
          deregister_null_claimant(Wimp_ENull,
                                   fullscreen_channel_poll,
                                   NULL);

          fullscreen_nulls = false;
          fullscreen_timer = 0;

          fullscreen_change_channel_and_check(atoi(fullscreen_cbuffer));
          *fullscreen_cbuffer = '\0';
        }
      }
      else
      {
        /* Another case of "can't do that" - this isn't a (recognised) multicast stream. */

        overlay_add("disabled",
                    NULL,
                    oa_top_right,
                    100,
                    NULL,
                    fullscreen_overlay_handle);
      }

      /* We claim these keys whether or not a channel change was done */

      return 1;
    }
    break;

    /* Can't do these if we've an operation in progress; if we can cope, */
    /* though, put up the waiting sign.                                  */

    case 393: /* Play */
    case 70:
    case 102: /* "F", "f" */
    case 458: /* >> */
    case 397: /* Right */
    case 82:
    case 114: /* "R", "r" */
    case 392: /* << */
    case 396: /* Left */
    case 80:
    case 112: /* "p", "P" */
    case 390: /* Pause */
    case 389: /* |< (seek to start) */
    case 391: /* >| (seek to end) */
    {
      if (
           fullscreen_session == NULL ||
           fullscreen_session->in_transition != 0
         )
         return 1; /* Operation In Progress; showing a 'Disabled' icon proved to be annoying, so it was taken out */

      /* Operation not in progress so show the clock */

      if (fullscreen_waiting == NULL)
      {
        overlay_add("wait",
                    NULL,
                    oa_top_right,
                    0,
                    &fullscreen_waiting,
                    fullscreen_overlay_handle);
      }
    }
    break;
  }

  /* Second pass - deal with command keys */

  switch (key)
  {
    /* Play - return to 1x */

    case 393: /* Play */
    {
      ChkError(play_play(fullscreen_session, play_mode_normal, 1));
    }
    break;

    /* Forward */

    case 70:
    case 102: /* "F", "f" */
    case 458: /* >> */
    case 397: /* Right */
    {
      switch (fullscreen_session->current)
      {
        /* Start at 2x forward for normal play, reverse, etc. */

        default:
        {
          ChkError(play_play(fullscreen_session, play_mode_ffwd, 2));
        }
        break;

        /* Go to 8x, 16x, 32x, back to normal play from ffwd */

        case play_mode_ffwd:
        {
          unsigned int speed;

          switch (fullscreen_session->current_speed)
          {
            default: speed = 8;  break;
            case 8:  speed = 16; break;
            case 16: speed = 32; break;
            case 32: speed = 1;  break;
          }

          if (speed == 1)
          {
            ChkError(play_play(fullscreen_session, play_mode_normal, 1));
          }
          else
          {
            ChkError(play_play(fullscreen_session, play_mode_ffwd, speed));
          }
        }
        break;

        /* Go to 1/8, 1/4, 1/2, back to normal from pause */

        case play_mode_pause:
        case play_mode_sfwd:
        {
          unsigned int speed;

          switch(fullscreen_session->current_speed)
          {
            default: speed = 8; break;
            case 8:  speed = 4; break;
            case 4:  speed = 2; break;
            case 2:  speed = 1; break;
          }

          if (speed == 1)
          {
            ChkError(play_play(fullscreen_session, play_mode_normal, 1));
          }
          else
          {
            ChkError(play_play(fullscreen_session, play_mode_sfwd, speed));
          }
        }
      }
    }
    break;

    /* Rewind */

    case 82:
    case 114: /* "R", "R" */
    case 392: /* << */
    case 396: /* Left */
    {
      switch (fullscreen_session->current)
      {
        /* Start at 2x reverse for normal play, fast forward, etc. */

        default:
        {
          ChkError(play_play(fullscreen_session, play_mode_frwd, 2));
        }
        break;

        /* Go to 8x, 16x, 32x, back to normal play from frwd */

        case play_mode_frwd:
        {
          unsigned int speed;

          switch (fullscreen_session->current_speed)
          {
            default: speed = 8;  break;
            case 8:  speed = 16; break;
            case 16: speed = 32; break;
            case 32: speed = 1;  break;
          }

          if (speed == 1)
          {
            ChkError(play_play(fullscreen_session, play_mode_normal, 1));
          }
          else
          {
            ChkError(play_play(fullscreen_session, play_mode_frwd, speed));
          }
        }
        break;

        /* Go to 1/8, 1/4, 1/2, back to normal from pause */

        case play_mode_pause:
        case play_mode_srwd:
        {
          unsigned int speed;

          switch(fullscreen_session->current_speed)
          {
            default: speed = 8; break;
            case 8:  speed = 4; break;
            case 4:  speed = 2; break;
            case 2:  speed = 1; break;
          }

          if (speed == 1)
          {
            ChkError(play_play(fullscreen_session, play_mode_normal, 1));
          }
          else
          {
            ChkError(play_play(fullscreen_session, play_mode_srwd, speed));
          }
        }
      }
    }
    break;

    /* Pause */

    case 80:
    case 112: /* "p", "P" */
    case 390: /* Pause */
    {
      if (fullscreen_session->current == play_mode_pause)
      {
        ChkError(play_play(fullscreen_session, play_mode_normal, 1));
      }
      else
      {
        ChkError(play_play(fullscreen_session, play_mode_pause, 0));
      }
    }
    break;

    /* Seek to start or end */

    case 389: /* |< (seek to start) */
    {
      fullscreen_session->seek = 1;
      ChkError(play_play(fullscreen_session, play_mode_normal, 1));
    }
    break;

    case 391: /* >| (seek to end) */
    {
      fullscreen_session->seek = 1;
      ChkError(play_play(fullscreen_session, play_mode_frwd, 2));
    }
    break;

    /* The next chunk of code shouldn't normally be compiled in, even */
    /* for debug builds. You'll need to knock out the wimp_process*/

    #if 0

      /* Big D - shut all files; useful for testing LVFGeneric error */
      /* throwing as a server message, for example.                  */

      case 68:
      {
        _swix(OS_CLI,
        _IN(0),
        "SHUT");
      }
      break;

      #define VideoControl_Test 0x053509

      /* Little D - call "Friday Evening" interface, so named from the time it was */
      /* written and the silly SWI name that I used, temporarily. That was before  */
      /* altering it to a more sane "Test" when I decided to keep the code in the  */
      /* Video Control module, albeit commented/compiled out. To use this, add the */
      /* SWI name to the CMHG header file for Video Control, fix the above SWI     */
      /* number definition if it's not right, and uncomment the relevant stuff in  */
      /* the module SWI handler. As ever, don't forget to undo all of that when    */
      /* you've finished testing things.                                           */

      case 100:
      {
        _swix(VideoControl_Test,
              _INR(0,3),

              0,
              fullscreen_session->handle,
              1,  /* Set play state */
              vc_play_state_normal_eos);

        _swix(OS_ServiceCall,
              _INR(0,3),

              VideoControlNewPlayState,
              Service_VideoControl,
              fullscreen_session->handle,
              VC_SVC_NewPlayState_ReadNewState | VC_SVC_NewPlayState_EndOfStreamSignalled);
      }
      break;

    #endif

    /* Anything left over gets passed on */

    default:
    {
      wimp_process_key(key);
      return 1;
    }
  }

  return 1;
}

/**************************************************************/
/* fullscreen_change_channel()                                */
/*                                                            */
/* Change to the given multicast channel number, by taking    */
/* the launch URL, finding its existant channel specifier,    */
/* rewriting it for the given number, and shutting down then  */
/* restarting the full screen routines with the result.       */
/*                                                            */
/* Parameters: Channel number.                                */
/**************************************************************/

static _kernel_oserror * fullscreen_change_channel(unsigned int chan_no)
{
  if (fullscreen_url != NULL)
  {
    _kernel_oserror * e;
    char            * channel;
    char            * query;
    char            * newu;
    unsigned int      launcher_record;
    bool              gotit;

    e = _swix(SVB_EnumerateChannels,
              _INR(0,4),

              1u<<1, /* Read specific channel number */
              chan_no,
              NULL,
              0,
              0);

    /* We need to construct a URL identical to the original except for a */
    /* new channel specifier. Since we're specifying by number, the host */
    /* and port could be NULL, but the CheckURL setup may be keying on   */
    /* that information so it must be preserved anyway.                  */

    channel = parameters_find_item(fullscreen_url->query, Parameters_ChannelNumber);

    /* Is there a channel specifier at all? Set 'gotit' to 'true' if so */

    if (channel != NULL)
    {
      free(channel);
      gotit = true;
    }
    else gotit = false;

    /* Duplicate the URL query string (use an empty string if the URL */
    /* has no query on it).                                           */

    query = utils_strdup(fullscreen_url->query ? fullscreen_url->query : "");
    if (query == NULL) return make_no_memory_error(10);

    /* If we had a channel specifier, we need to extract that bit from the */
    /* query string, preserving all the rest, ready to attach our new      */
    /* channel number specifier to the end.                                */

    if (gotit)
    {
      char * found;
      char * next;

      found = strstr(query, "&" Parameters_ChannelNumber "="); /* Make sure we don't find the string as a substring of a different item */
      if (found == NULL) found = query;                        /* It wasn't found because of the '&' => "channel="... is the first item */

      /* Find the item (if any) after the found channel specifier */

      next = strchr(found == query ? found : found + 1, '&');

      if (next == NULL)
      {
        *found='\0';
      }
      else
      {
        memmove(found, next, strlen(next) + 1); /* +1 to include terminator */
      }
    }

    /* Right, we've got a (possibly amended) query string; append our */
    /* new channel specifier to it.                                   */

    newu = malloc(strlen(query) + sizeof(Parameters_ChannelNumber) + 2 + 12); /* Additions to allow for a string of length up to "&channel=<n>" */

    if (newu == NULL)
    {
      free(query);
      return make_no_memory_error(10);
    }

    /* Only want an '&' before the specifier if the query string has stuff in it already */

    sprintf(newu,
            "%s%s%d",
            query,
            *query == '\0' ? Parameters_ChannelNumber "=" : "&" Parameters_ChannelNumber "=",
            chan_no);

    /* We're finished with the copy of the old query string */

    free(query);

    /* Now need to take that query string and reconstruct it into a new URL; this */
    /* bit gets slightly hacky :-)                                                */

    {
      char * block[10];

      /* Fill in the composition blovk */

      block[0] = 0; /* I.e., return length required please */
      block[1] = fullscreen_url->protocol;
      block[2] = fullscreen_url->host;
      block[3] = fullscreen_url->port;
      block[4] = fullscreen_url->user;
      block[5] = fullscreen_url->password;
      block[6] = fullscreen_url->account;
      block[7] = fullscreen_url->path;
      block[8] = newu;
      block[9] = fullscreen_url->fragment;

      /* Ask URL_Fetcher the length of the URL */

      e = _swix(URL_ParseURL,
                _INR(0,5),

                0,
                URL_ParseURL_Reason_ComposeFromComponents,
                NULL,
                NULL,
                block,
                0);

      if (e != NULL)
      {
        free(newu);
        return e;
      }

      /* Allocate the required space */

      block[0] = malloc((size_t) block[0]);

      if (block[0] == NULL)
      {
        free(newu);
        return make_no_memory_error(10);
      }

      /* Ask URL_Fetcher to build the URL */

      e = _swix(URL_ParseURL,
                _INR(0,5),

                0,
                URL_ParseURL_Reason_ComposeFromComponents,
                NULL,
                NULL,
                block,
                0);

      if (e != NULL)
      {
        free(block[0]);
        free(newu);

        return e;
      }

      /* Finished with the new query string now */

      free(newu);
      newu = block[0];
    }

    /* Now shutdown and restart with the new URL */

    launcher_record = plugin_get_launcher(fullscreen_plugin);
    fullscreen_shutdown();
    e = fullscreen_start(newu, launcher_record);

    free(newu);

    return e;
  }

  return NULL;
}

/**************************************************************/
/* fullscreen_change_channel_and_check()                      */
/*                                                            */
/* As fullscreen_change_channel, but deals with a             */
/* FullScreen_BadChannelError error number internally, via.   */
/* calling SVB_EnumerateChannels. It handles the appropriate  */
/* on-screen displays to indicate the failure and returns     */
/* NULL. Of course, other errors are returned directly.       */
/* doing appropriate on-screen displays to indicate the       */
/* failure, and returning NULL.                               */
/*                                                            */
/* Parameters: As fullscreen_change_channel.                  */
/**************************************************************/

static _kernel_oserror * fullscreen_change_channel_and_check(unsigned int chan_no)
{
  _kernel_oserror * e;
  char              n[17];

  e = _swix(SVB_EnumerateChannels,
            _INR(0,4),

            1u<<1, /* Read specific channel number */
            chan_no,
            NULL,
            0,
            0);

  if (e != NULL && e->errnum == FullScreen_BadChannelError)
  {
    /* Bad channel number */

    sprintf(n, "%d", chan_no);

    overlay_add("disabled",
                lookup_token("NotThere:Channel %0 is not available", 0, n),
                oa_bottom_left,
                250,
                NULL,
                fullscreen_overlay_handle);

    return NULL;
  }

  return fullscreen_change_channel(chan_no);
}

/**************************************************************/
/* fullscreen_channel_poll()                                  */
/*                                                            */
/* Null handler which checks a timer on the channel change    */
/* overlay (number keys used during multicast streaming) and  */
/* changes channel if the timer expires.                      */
/*                                                            */
/* Parameters as standard for a Wimp event handler; none      */
/* currently used.                                            */
/**************************************************************/

static int fullscreen_channel_poll(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  unsigned int time;

  #ifdef TRACE
    if (tl & (1u<<31)) dprintf(("", "fullscreen_channel_poll: Called\n"));
  #endif

  ChkError(_swix(OS_ReadMonotonicTime,
                 _OUT(0),

                 &time));

  /* If we've nothing in the channel buffer we were called by accident, so */
  /* prepare to deregister. Alternatively, if the timer has expired, also  */
  /* continue for deregistration and channel change.                       */

  if (
       *fullscreen_cbuffer == '\0' ||
       (
         time - fullscreen_timer > FullScreen_ChannelDelay &&
         fullscreen_timer        > 0
       )
     )
  {
    /* Deregister if nulls are claimed */

    if (fullscreen_nulls)
    {
      deregister_null_claimant(Wimp_ENull,
                               fullscreen_channel_poll,
                               NULL);

      fullscreen_nulls = false;
      fullscreen_timer = 0;
    }

    /* If we've a channel to change to, do it */

    if (*fullscreen_cbuffer != '\0')
    {
      fullscreen_change_channel_and_check(atoi(fullscreen_cbuffer));
      *fullscreen_cbuffer = '\0';
    }
  }

  #ifdef TRACE
    if (tl & (1u<<31)) dprintf(("", "fullscreen_channel_poll: Successful\n"));
  #endif

  return 0;
}

/**************************************************************/
/* fullscreen_auto_destruct()                                 */
/*                                                            */
/* Null handler which checks a timer and after "handle" cs    */
/* (converted to an unsigned int) shuts down the fullscreen   */
/* system.                                                    */
/*                                                            */
/* Parameters as standard for a Wimp event handler; "handl"   */
/* holds the number of cs to wait for, cast to void *.        */
/**************************************************************/

static int fullscreen_auto_destruct(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  unsigned int time;

  ChkError(_swix(OS_ReadMonotonicTime,
                 _OUT(0),

                 &time));

  if (time - fullscreen_autodt > (unsigned int) handle) fullscreen_shutdown();

  return 0;
}
