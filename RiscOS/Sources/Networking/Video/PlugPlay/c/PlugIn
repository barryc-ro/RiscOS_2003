/**************************************************************/
/* File:    PlugIn.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Supporting the generic RISC OS plug-in interface. */
/*                                                            */
/*          Unusual allocation schemes may be used to replace */
/*          malloc here, so do NOT malloc a message block and */
/*          try to send it; you'll hit the Wimp bug regarding */
/*          message blocks at high addresses with older       */
/*          versions.                                         */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 05-Oct-1997 (ADH): Created.                       */
/*          05-Apr-2000 (ADH): 64-wide comments adopted.      */
/*          18-Apr-2000 (ADH): Imported into PlugPlay.        */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/event.h>
#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>

#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "Filter.h"
#include "FromROSLib.h"
#include "FullScreen.h"
#include "Global.h"
#include "MiscDefs.h"
#include "ModeInfo.h"
#include "Overlay.h"
#include "RMA.h"
#include "Utils.h"

#include "PlugIn.h"

/* Local definitions and structures */

#define Magic_PlugIn_Instance    0x47554C50 /* "PLUG" */

#define PlugIn_ParamsName_ID         "id"
#define PlugIn_ParamsName_Data       "data"
#define PlugIn_ParamsName_Border     "border"
#define PlugIn_ParamsName_FS         "fullscreen"
#define PlugIn_ParamsName_SA         "standalone"
#define PlugIn_ParamsName_Demux      "demux"
#define PlugIn_ParamsName_AudStream  "audstream"
#define PlugIn_ParamsName_VidStream  "vidstream"
#define PlugIn_ParamsName_Program    "program"
#define PlugIn_ParamsName_From       "from"
#define PlugIn_ParamsName_To         "to"
#define PlugIn_ParamsName_Loop       "loop"
#define PlugIn_ParamsName_Volume     "volume"
#define PlugIn_ParamsName_NoAudio    "noaudio"
#define PlugIn_ParamsName_NoVideo    "novideo"
#define PlugIn_ParamsName_NTSC       "ntsc"

typedef struct plugin_file_entry
{
  struct plugin_file_entry * next;
  struct plugin_file_entry * prev;

  char                     * name;
  char                     * data;
  char                     * mime;
}
plugin_file_entry;

typedef struct plugin_instance
{
  unsigned int               magic;

  struct plugin_instance   * next;
  struct plugin_instance   * prev;
  unsigned int               launcher;

  plugin_file_entry        * entries;

  unsigned int               browser_instance_handle;
  unsigned int               plugin_instance_handle;
  unsigned int               video_control_handle;

  unsigned int               parent_task_handle;
  unsigned int               parent_window_handle;
  ObjectId                   window_id;
  int                        window_handle;
  BBox                       position;

  const char               * id;  /* These point into the plugin_file_entry structs, */
  const char               * url; /* so should not have free() called on them.       */

  int                        border;
  int                        from;
  int                        to;
  unsigned int               volume;
  unsigned int               aud_stream;
  unsigned int               vid_stream;
  unsigned int               program;

  unsigned                   redraw_handler :1;
  unsigned                   reopen_handler :1;
  unsigned                   filter_done    :1;

  unsigned                   full_screen    :1;
  unsigned                   stand_alone    :1;
  unsigned                   demux          :2;
  unsigned                   loop           :1;
  unsigned                   no_audio       :1;
  unsigned                   no_video       :1;
  unsigned                   ntsc           :1;
}
plugin_instance;

/* Local variables */

static plugin_instance * instances = NULL;

/* Local functions */

static plugin_instance * plugin_new_instance        (void);
static void              plugin_delete_instance     (plugin_instance * i);
static plugin_instance * plugin_find_instance       (unsigned int handle);

static _kernel_oserror * plugin_new_file_entry      (plugin_instance * i);
static void              plugin_delete_file_entry   (plugin_instance * i, plugin_file_entry * en);
static void              plugin_delete_file_entries (plugin_instance * i);
static _kernel_oserror * plugin_read_params_file    (plugin_instance * i, const char * filename);

static _kernel_oserror * plugin_make_initialised    (WimpMessage * m, BBox * at, unsigned int * newh);

static int               plugin_redraw_window       (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);
static int               plugin_reopen_window       (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);

static _kernel_oserror * plugin_move_window         (plugin_instance * i);
static _kernel_oserror * plugin_move_video          (plugin_instance * i);

/**************************************************************/
/* plugin_new_instance()                                      */
/*                                                            */
/* Allocate space for a new plugin_instance struct. The item  */
/* is 0-initialised and essential fields filled in (e.g. the  */
/* magic word).                                               */
/*                                                            */
/* Returns:    Pointer to the new item, or NULL if out of     */
/*             memory.                                        */
/**************************************************************/

static plugin_instance * plugin_new_instance(void)
{
  #ifdef APPLICATION

    plugin_instance * new = calloc(1, sizeof(plugin_instance));

    if (new == NULL) return NULL;

  #else

    plugin_instance * new = NULL;

    rma_claim(NULL, sizeof(plugin_instance), (void **) &new);

    if (new == NULL) return NULL;
    else memset(new, '\0', sizeof(plugin_instance));

  #endif

  new->magic                  = Magic_PlugIn_Instance;
  new->window_id              = NULL_ObjectId;
  new->plugin_instance_handle = (int) new; /* At present, the instance handle is just a pointer to the structure */

  if (instances != NULL)
  {
    instances->prev = new;
    new->next       = instances;
  }

  instances = new;

  return new;
}

/**************************************************************/
/* plugin_delete_stand_alone()                                */
/*                                                            */
/* Delete a stand alone plug-in instance created with         */
/* plugin_make_stand_alone.                                   */
/*                                                            */
/* Parameters: Stand-alone plug-in's instance handle.         */
/**************************************************************/

void plugin_delete_stand_alone(unsigned int handle)
{
  plugin_delete_instance(plugin_find_instance(handle));
}

/**************************************************************/
/* plugin_delete_instance()                                   */
/*                                                            */
/* Delete a plugin_instance from the list along with any      */
/* items related to it (e.g. Toolbox objects).                */
/*                                                            */
/* Parameters: Instance handle for item to delete.            */
/**************************************************************/

static void plugin_delete_instance(plugin_instance * i)
{
  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_delete_instance: Called for %p\n", i));
  #endif

  if (i == NULL) return;

  /* The 'id' and 'url' fields point into the file entries, so we */
  /* do NOT free these individually.                              */

  plugin_delete_file_entries(i);

  if (i->prev)        i->prev->next = i->next;
  if (i->next)        i->next->prev = i->prev;
  if (instances == i) instances     = i->next;

  if (i->filter_done    == 1) filter_remove_filter();
  if (i->redraw_handler == 1) event_deregister_wimp_handler(i->window_id, Wimp_ERedrawWindow, plugin_redraw_window, (void *) i->plugin_instance_handle);
  if (i->reopen_handler == 1) event_deregister_wimp_handler(i->window_id, Wimp_EOpenWindow,   plugin_reopen_window, (void *) i->plugin_instance_handle);

  if (i->window_id != NULL_ObjectId) toolbox_delete_object(0, i->window_id);

  #ifdef APPLICATION
    free(i);
  #else
    rma_release(NULL, (void *) i);
  #endif

  return;
}

/**************************************************************/
/* plugin_find_instance()                                     */
/*                                                            */
/* Given a plug-in instance handle, returns a pointer to the  */
/* related plugin_instance struct or NULL if the handle is    */
/* unknown / invalid.                                         */
/*                                                            */
/* Parameters: Plug-in instance handle.                       */
/*                                                            */
/* Returns:    Pointer to related plugin_instance struct or   */
/*             NULL if the handle is unknown.                 */
/**************************************************************/

static plugin_instance * plugin_find_instance(unsigned int handle)
{
  _kernel_oserror * e;
  plugin_instance * i;
  unsigned int      valid;

  /* The plug-in instance handle is the address off the plugin_instance */
  /* structure for the referenced instance. Validate the address and    */
  /* ensure that there's the magic word there before proceeding.        */

  i = (plugin_instance *) handle;

  e = _swix(OS_ValidateAddress,
            _INR(0,1) | _OUT(_FLAGS),

            i,
            i + 1,
            &valid);

  if (e || (valid & _C) || i->magic != Magic_PlugIn_Instance)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_find_instance: Handle &%08X is invalid\n", handle));
    #endif

    return NULL;
  }

  return i;
}

/**************************************************************/
/* plugin_new_file_entry()                                    */
/*                                                            */
/* Adds a plugin_file_entry to a given plugin_instance at the */
/* head of the list.                                          */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure to    */
/*             add to.                                        */
/**************************************************************/

static _kernel_oserror * plugin_new_file_entry(plugin_instance * i)
{
  #ifdef APPLICATION

    plugin_file_entry * new = calloc(1, sizeof(plugin_file_entry));

    if (new == NULL) return make_no_memory_error(0);

  #else

    plugin_file_entry * new = NULL;

    RetError(rma_claim(NULL, sizeof(plugin_file_entry), (void **) &new));
    memset(new, '\0', sizeof(plugin_file_entry));

  #endif

  if (i->entries != NULL)
  {
    i->entries->prev = new;
    new->next        = i->entries;
  }

  i->entries = new;

  return NULL;
}

/**************************************************************/
/* plugin_delete_file_entry()                                 */
/*                                                            */
/* Delete a given plugin_file_entry from a given              */
/* plugin_instance.                                           */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure to    */
/*             delete from;                                   */
/*                                                            */
/*             Pointer to the plugin_file_entry to delete.    */
/**************************************************************/

static void plugin_delete_file_entry(plugin_instance * i, plugin_file_entry * en)
{
  if (en->prev != NULL) en->prev->next = en->next;
  if (en->next != NULL) en->next->prev = en->prev;
  if (en == i->entries) i->entries     = en->next;

  #ifdef APPLICATION

    if (en->name != NULL) free(en->name);
    if (en->data != NULL) free(en->data);
    if (en->mime != NULL) free(en->mime);

    free(en);

  #else

    if (en->name != NULL) rma_release(NULL, (void *) en->name);
    if (en->data != NULL) rma_release(NULL, (void *) en->data);
    if (en->mime != NULL) rma_release(NULL, (void *) en->mime);

    rma_release(NULL, (void *) en);

  #endif

  return;
}

/**************************************************************/
/* plugin_delete_file_entries()                               */
/*                                                            */
/* Delete all plugin_file_entry structures from a given       */
/* plugin_instance.                                           */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure to    */
/*             delete from.                                   */
/**************************************************************/

static void plugin_delete_file_entries(plugin_instance * i)
{
  while (i->entries != NULL) plugin_delete_file_entry(i, i->entries);

  return;
}

/**************************************************************/
/* plugin_read_params_word()                                  */
/*                                                            */
/* Read an integer from a parameters file.                    */
/*                                                            */
/* Parameters: Pointer to FILE struct to read through;        */
/*                                                            */
/*             Pointer to int to update.                      */
/*                                                            */
/* Returns:    0 for success, EOF for an error.               */
/*                                                            */
/* Assumes:    Parameter pointers must be non-NULL and valid. */
/**************************************************************/

static int plugin_read_params_word(FILE * f, int * word)
{
  int i;
  int c;

  /* Despite assumption stated in comments above, this is not speed */
  /* critical in practice so paranoid code is worthwhile.           */

  if (word == NULL) return EOF;

  /* Read each byte, assembling the word */

  c = fgetc(f);
  if (c == EOF) return EOF;

  i = c & 0xff;

  c = fgetc(f);
  if (c == EOF) return EOF;

  i |= ((c & 0xff) << 8);

  c = fgetc(f);
  if (c == EOF) return EOF;

  i |= ((c & 0xff) << 16);

  c = fgetc(f);
  if (c == EOF) return EOF;

  i |= ((c & 0xff) << 24);

  /* Finished */

  *word = i;

  return 0;
}

/**************************************************************/
/* plugin_read_params_string()                                */
/*                                                            */
/* Read a name, mime type or data string from the parameters  */
/* file.                                                      */
/*                                                            */
/* Parameters: Pointer to a FILE struct to read through;      */
/*                                                            */
/*             Pointer to a char * updated to point to the    */
/*             string in a malloced block that the caller     */
/*             must free if APPLICATION is defined, or an     */
/*             rma_claim'd block that the caller must         */
/*             rma_release (with allocator=NULL) if           */
/*             APPLICATION is not defined.                    */
/*                                                            */
/* Returns:    0 for success, EOF for an error, and the char  */
/*             * updated to NULL if, specifically, out of     */
/*             memory.                                        */
/*                                                            */
/* Assumes:    Parameter pointers must be non-NULL and valid. */
/**************************************************************/

static int plugin_read_params_string(FILE * f, char ** string)
{
  int i, l;
  int c;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_read_params_string: Called\n"));
  #endif

  /* Read the string length and allocate a buffer */

  c = plugin_read_params_word(f, &i);

  if (c == EOF) return EOF;

  #ifdef APPLICATION

    *string = malloc(i + 1);

  #else

    *string = NULL;
    rma_claim(NULL, i + 1, (void **) string);

  #endif

  if (*string == NULL) return EOF;

  /* Read the string */

  for (l = 0; l < i; l++)
  {
    c = fgetc(f);
    if (c == EOF) return EOF;
    (*string)[l] = c;
  }

  (*string)[i] = '\0';

  /* Skip to word aligned point */

  while (ftell(f) % 4 != 0)
  {
    c = fgetc(f);
    if (c == EOF) return EOF;
  }

  /* Finished */

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_read_params_string: Successful, read '%s', ended up at %d\n", *string, (unsigned int) ftell(f)));
  #endif

  return 0;
}

/**************************************************************/
/* plugin_read_params_file()                                  */
/*                                                            */
/* Read a parameters file. The 'url' and 'id' fields of the   */
/* given plugin_instance structure may be updated on exit to  */
/* point into appropriate strings within the file structures. */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure       */
/*             relevant to the file;                          */
/*                                                            */
/*             Pointer to the filename, NUL terminated.       */
/**************************************************************/

static _kernel_oserror * plugin_read_params_file(plugin_instance * i, const char * filename)
{
  _kernel_oserror * e = NULL;
  FILE            * f = fopen(filename, "rb");
  int               c = 0;
  int               word;

  if (f == NULL)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("CannotOpen:Cannot open parameters file",
                          0,0));

    return &erb;
  }

  for (;;)
  {
    /* Read the entry type */

    c = plugin_read_params_word(f, &word);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    if (word == PlugIn_ParamType_Terminator) break;

    /* Read the record size - we don't actually care about this */

    c = plugin_read_params_word(f, &word);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    /* Allocate a new entry structure */

    e = plugin_new_file_entry(i);
    if (e != NULL) goto plugin_read_params_file_exit_with_error;

    /* Read the name, data and mime type */

    c = plugin_read_params_string(f, &i->entries->name);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    c = plugin_read_params_string(f, &i->entries->data);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    c = plugin_read_params_string(f, &i->entries->mime);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    /* If we get the ID or DATA entries, store a direct pointer to them */
    /* within the instance structure for faster access later.           */

    if (i->entries->name != NULL && i->entries->data != NULL)
    {
      #define YesNoToFlag(x) (utils_strcasecmp((x), "yes") == 0 ? 1 : 0)

      if      (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_ID))   i->id  = i->entries->data;
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Data)) i->url = i->entries->data;

      /* Now read our various plug-in supported options */

      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Border))    i->border      = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_FS))        i->full_screen = YesNoToFlag(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_SA))        i->stand_alone = YesNoToFlag(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Demux))     i->demux       = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_AudStream)) i->aud_stream  = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_VidStream)) i->vid_stream  = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Program))   i->program     = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_From))      i->from        = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_To))        i->to          = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Loop))      i->loop        = YesNoToFlag(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Volume))    i->volume      = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_NoAudio))   i->no_audio    = YesNoToFlag(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_NoVideo))   i->no_video    = YesNoToFlag(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_NTSC))      i->ntsc        = YesNoToFlag(i->entries->data);
    }
  }

  /* Normal mode exit */

  fclose(f);
  return NULL;

  /* Error mode exit */

plugin_read_params_file_exit_with_error:

  if (f != NULL) fclose(f);
  plugin_delete_file_entries(i);

  if (e == NULL)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("CannotRead:Cannot understand parameters file",
                          0,0));

    return &erb;
  }
  else return e;
}

/**************************************************************/
/* plugin_return_string()                                     */
/*                                                            */
/* Takes a message block and string_value from within it, and */
/* returns the string it points to.                           */
/*                                                            */
/* Parameters: Pointer to a WimpMessage struct holding the    */
/*             string_value field;                            */
/*                                                            */
/*             Pointer to the string_value field inside that  */
/*             message.                                       */
/*                                                            */
/* Returns:    Pointer to the string the string_value         */
/*             references, or NULL if the value seems         */
/*             invalid.                                       */
/**************************************************************/

const char * plugin_return_string(WimpMessage * m, string_value * sv)
{
  int offset = ((char *) sv) - ((char *) m);

  if (!m || !sv || !sv->offset) return NULL;

  /* Is the offset of the string_value field within the message */
  /* block out of range (i.e. the string_value does not appear  */
  /* to lie in the given message block)?                        */

  if (offset >= m->hdr.size || offset < sizeof(m->hdr)) return NULL;

  /* Now read the string_value field itself */

  if (sv->offset < 256)
  {
    if (sizeof(m->hdr) + offset >= m->hdr.size) return NULL;

    else return (const char *) (((char *) m) + sizeof(m->hdr) + sv->offset);
  }
  else return (const char *) sv->offset;
}

/**************************************************************/
/* plugin_make_stand_alone_instance()                         */
/*                                                            */
/* Make a stand-alone plug-in instance.                       */
/*                                                            */
/* Parameters: Pointer to a BBox holding coords to open the   */
/*             item at (screen coords, OS units);             */
/*                                                            */
/*             Pointer to an unsigned int to take the stand-  */
/*             alone plugin-instance handle, so that          */
/*             plugin_delete_instance can later be called.    */
/*                                                            */
/* Assumes:    Both pointers are non-NULL and valid.          */
/**************************************************************/

_kernel_oserror * plugin_make_stand_alone(BBox * at, unsigned int * newh)
{
  *newh = NULL;

  return plugin_make_initialised(NULL, at, newh);
}

/**************************************************************/
/* plugin_got_open()                                          */
/*                                                            */
/* Handle reception of a Message_PlugIn_Open.                 */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_open(WimpMessage * m)
{
  return plugin_make_initialised(m, NULL, NULL);
}

/**************************************************************/
/* plugin_make_initialised()                                  */
/*                                                            */
/* Make a plug-in instance based on a Message_PlugIn_Open or  */
/* as a stand-alone item.                                     */
/*                                                            */
/* Plug-ins that launch and find themselves flagged as stand- */
/* alone via. the Params file will act as placeholders and    */
/* a second, "true" stand-alone session will be automatically */
/* launched. This means that this function MUST BE REENTRANT. */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message, or NULL for a stand-alone item;   */
/*                                                            */
/*             NULL for a conventional plug-in, or pointer to */
/*             a BBox holding coords to open stand-alone item */
/*             at (screen coords, OS units).                  */
/*                                                            */
/*             Optional pointer to unsigned into take new     */
/*             item's instance handle.                        */
/**************************************************************/

static _kernel_oserror * plugin_make_initialised(WimpMessage * m, BBox * at, unsigned int * newh)
{
  _kernel_oserror         * e;
  WimpGetWindowStateBlock   state;
  WimpMessage               response;
  ObjectId                  newo;
  int                       plugin_instance_handle;
  plugin_instance         * i;
  MPlugIn_Open            * open;
  MPlugIn_Opening         * opening = (MPlugIn_Opening *) &response.data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Called for %p, %p\n", m, at));
  #endif

  if (m == NULL && at == NULL) return NULL;

  if (m == NULL) open = NULL;
  else           open = (MPlugIn_Open *) &m->data;

  if (open != NULL && open->file_type != PlugIn_LaunchKey)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Filetype %03X doesn't match launch key %03X\n", open->file_type, PlugIn_LaunchKey));
    #endif

    return NULL;
  }

  i = plugin_new_instance();

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Out of memory\n"));
    #endif

    return make_no_memory_error(0);
  }

  /* Currently, instance handles just point back to the plugin_instance structure */

  plugin_instance_handle = (int) i;
  if (newh != NULL) *newh = plugin_instance_handle;

  /* Set defaults prior to reading the params file (if we read it, that is) */

  i->border      = 0;
  i->from        = -1; /* Beginning */
  i->to          = -1; /* End */
  i->volume      = 256;
  i->aud_stream  = 1;
  i->vid_stream  = 1;
  i->program     = 1;
  i->full_screen = open == NULL ? 1 : 0;
  i->stand_alone = open == NULL ? 1 : 0;
  i->demux       = 0;
  i->loop        = 0;
  i->no_audio    = 0;
  i->no_video    = 0;

  /* If not stand-alone, record the parent task and read the parameters file */

  if (i->stand_alone == 0 && m != NULL)
  {
    i->parent_task_handle = m->hdr.sender;
    e = plugin_read_params_file(i, plugin_return_string(m, &open->file_name));
  }
  else e = NULL;

  /* Note that stand-alone plug-ins exist in two forms. Having the stand_alone flag */
  /* set isn't enough. If you've got that set but also have a parent window handle, */
  /* the plug-in instance is there just to fill the hole in the web page. There     */
  /* will be / should be later another plug-in created as "completely" stand-alone, */
  /* which has no parent window handle. When that full-screen play session is shut  */
  /* down the placeholder plug-in remains, keeping the web browser happy and        */
  /* keeping the whole in the page.                                                 */
  /*                                                                                */
  /* For this reason, many bits of the code below continue to use "open != NULL" to */
  /* see if this is a *truly* stand-alone plug-in rather than checking the          */
  /* stand_alone flag; it's a shorthand way of checking the flag and parent handle. */

  if (e == NULL)
  {
    /* Create the video window. If this works, register our redraw handler. */

    e = toolbox_create_object(0,
                              "Video",
                              &newo);
  }

  if (e == NULL)
  {
    e = event_register_wimp_handler(newo,
                                    Wimp_ERedrawWindow,
                                    plugin_redraw_window,
                                    (void *) plugin_instance_handle);
  }

  /* Flag this was successful register our OpenWindow event filter, if not stand-alone */
  /* (so plug-ins which are in-page placeholders with the stand-alone flag set *do*    */
  /* have a filter)                                                                    */

  if (e == NULL)
  {
    i->redraw_handler = 1;

    if (open != NULL) e = filter_add_filter();
  }

  /* Now other general bits of information */

  if (e == NULL)
  {
    if (open != NULL)
    {
      i->filter_done = 1;

      i->browser_instance_handle = open->browser_instance_handle;
      i->parent_window_handle    = open->parent_window_handle;
    }

    i->window_id = newo;
    e = window_get_wimp_handle(0, newo, &i->window_handle);
  }

  if (e == NULL && open != NULL)
  {
    state.window_handle = open->parent_window_handle;
    e = wimp_get_window_state(&state);
  }

  if (e != NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: General error - '%s'\n", e->errmess));
    #endif

    plugin_delete_instance(i);
    return e;
  }

  /* We only use the given bounding box for completely stand-alone plugins, not   */
  /* placeholders, thus switch on 'open != NULL' rather than the stand_alone flag */

  if (open != NULL)
  {
    i->position = open->parent_area;
    coords_box_toscreen(&i->position, (WimpRedrawWindowBlock *) &state);
  }
  else
  {
    i->position = *at;
  }

  e = plugin_move_window(i);

  if (e != NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Error from plugin_move_window - '%s'\n", e->errmess));
    #endif

    plugin_delete_instance(i);
    return e;
  }

  if (open != NULL)
  {
    /* Respond with Message_PlugIn_Opening */

    response.hdr.size                = sizeof(MPlugIn_Opening);
    response.hdr.your_ref            = m->hdr.my_ref;
    response.hdr.action_code         = Message_PlugIn_Opening;

    opening->flags                   = MPlugIn_Opening_ActionBeyondStop;
    opening->browser_instance_handle = i->browser_instance_handle;
    opening->plugin_instance_handle  = plugin_instance_handle;
    opening->parent_window_handle    = i->parent_window_handle;
    opening->parent_area             = i->position;

    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Exitting through wimp_send_message, sending handle %p\n", i));
    #endif

    RetError(wimp_send_message(Wimp_EUserMessage,
                               &response,
                               m->hdr.sender,
                               0,
                               NULL));

    if (i->stand_alone && i->full_screen)
    {
      /* If we're stand-alone but open != NULL, this is a placeholder plug-in. We */
      /* should now launch the true full screen client. Note that this routine    */
      /* will be re-entered as a result of this call, assuming all goes well.     */

      fullscreen_report_error(fullscreen_start(i->url, i->plugin_instance_handle), true);
    }

    return NULL;
  }
  else
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Stand-alone creation successful, exitting for handle %p\n", i));
    #endif

    return NULL;
  }
}

/**************************************************************/
/* plugin_got_close()                                         */
/*                                                            */
/* Handle reception of a Message_PlugIn_Close.                */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_close(WimpMessage * m)
{
  WimpMessage       response;
  plugin_instance * i;
  MPlugIn_Close   * close  = (MPlugIn_Close  *) &m->data;
  MPlugIn_Closed  * closed = (MPlugIn_Closed *) &response.data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_close: Called\n"));
  #endif

  /* Validate the plug-in instance handle */

  i = plugin_find_instance(close->plugin_instance_handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_close: Instance handle &%08X invalid\n", close->plugin_instance_handle));
    #endif

    return NULL;
  }

  /* The handle is good */

  plugin_delete_instance(i);

  /* Respond with Message_PlugIn_Closed */

  response.hdr.size               = sizeof(MPlugIn_Closed);
  response.hdr.your_ref           = m->hdr.my_ref;
  response.hdr.action_code        = Message_PlugIn_Closed;

  closed->flags                   = 0;
  closed->browser_instance_handle = i->browser_instance_handle;
  closed->plugin_instance_handle  = i->plugin_instance_handle;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_close: Exitting through wimp_send_message\n"));
  #endif

  return wimp_send_message(Wimp_EUserMessage,
                           &response,
                           m->hdr.sender,
                           0,
                           NULL);
}

/**************************************************************/
/* plugin_got_reshape()                                       */
/*                                                            */
/* Handle reception of a Message_PlugIn_Reshape.              */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_reshape(WimpMessage * m)
{
  WimpGetWindowStateBlock   state;
  plugin_instance         * i;
  MPlugIn_Reshape         * reshape = (MPlugIn_Reshape *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_reshape: Called for %p\n", (plugin_instance *) reshape->plugin_instance_handle));
  #endif

  /* Validate the plug-in instance handle */

  i = plugin_find_instance(reshape->plugin_instance_handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_reshape: Instance handle &%08X invalid\n", reshape->plugin_instance_handle));
    #endif

    return NULL;
  }

  /* The handle is good */

  state.window_handle = reshape->parent_window_handle;
  RetError(wimp_get_window_state(&state));

  i->position = reshape->parent_area;

  coords_box_toscreen(&i->position, (WimpRedrawWindowBlock *) &state);

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_reshape: Exitting through plugin_move_window with %d, %d, %d, %d\n", i->position.xmin, i->position.ymin, i->position.xmax, i->position.ymax));
  #endif

  return plugin_move_window(i);
}

/**************************************************************/
/* plugin_got_action()                                        */
/*                                                            */
/* Handle reception of a Message_PlugIn_Action.               */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_action(WimpMessage * m)
{
  MPlugIn_Action * action = (MPlugIn_Action *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_action: Called\n"));
  #endif

  (void) action;

  return NULL;
}

/**************************************************************/
/* plugin_got_abort()                                         */
/*                                                            */
/* Handle reception of a Message_PlugIn_Abort.                */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_abort(WimpMessage * m)
{
  MPlugIn_Abort * abort = (MPlugIn_Abort *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_abort: Called\n"));
  #endif

  (void) abort;

  return NULL;
}

/**************************************************************/
/* plugin_got_inform()                                        */
/*                                                            */
/* Handle reception of a Message_PlugIn_Inform.               */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_inform(WimpMessage * m)
{
  plugin_instance * i;
  MPlugIn_Inform  * inform = (MPlugIn_Inform *) &m->data;
  char              id [sizeof(inform->name) + 1];

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Called\n"));
  #endif

  if (inform->info_id == MPlugIn_Inform_InfoID_VideoControlHandle)
  {
    strncpy(id, inform->name, sizeof(id) - 1);
    id[sizeof(id) - 1] = '\0';

    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Supported inform received for '%s', handle %08X\n",
                                  id,
                                  inform->info.video_control_handle));
    #endif

    i = instances;

    while (i)
    {
      if (!strcmp(i->id, id)) break;
      i = i->next;
    }

    if (i != NULL)
    {
      #ifdef TRACE
        if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Assigning handle to instance %p\n", i));
      #endif

      i->video_control_handle = inform->info.video_control_handle;

      /* Ensure the video position is up to date */

      RetError(plugin_move_video(i));
    }
  }

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Successful\n"));
  #endif

  return NULL;
}

/**************************************************************/
/* plugin_redraw_window()                                     */
/*                                                            */
/* Handle Redraw requests for a plug-in window from the Wimp. */
/*                                                            */
/* Parameters are as standard for a Wimp event handler with   */
/* 'handle' set to the instance handle related to the window. */
/**************************************************************/

static int plugin_redraw_window(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  WimpRedrawWindowBlock   r;
  int                     more;
  plugin_instance       * i;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_redraw_window: Called\n"));
  #endif

  i = plugin_find_instance((int) handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_redraw_window: Instance handle &%08X invalid\n", (int) handle));
    #endif

    return NULL;
  }

  r.window_handle = ((WimpRedrawWindowRequestEvent *) b)->window_handle;
  ChkError(wimp_redraw_window(&r, &more));

  if (more)
  {
    unsigned int trans = modeinfo_return_transparent_gcol();

    do
    {
      _swix(OS_SetColour,
            _INR(0,1),

            1u<<4,
            trans);

      bbc_vdu(BBC_ClearGraph);

      ChkError(wimp_get_rectangle(&r, &more));

    }
    while (more);
  }

  /* Stand-alone items: Poll the overlay system */

  if (i->parent_window_handle == 0) overlay_poll(0, NULL, NULL, NULL);

  return 1;
}

/**************************************************************/
/* plugin_reopen_window()                                     */
/*                                                            */
/* Handle Open requests for a plug-in window from the Wimp.   */
/*                                                            */
/* Parameters are as standard for a Wimp event handler with   */
/* 'handle' set to the instance handle related to the window. */
/**************************************************************/

static int plugin_reopen_window(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  plugin_instance * i;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_reopen_window: Called\n"));
  #endif

  i = plugin_find_instance((int) handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_reopen_window: Instance handle &%08X invalid\n", (int) handle));
    #endif

    return NULL;
  }

  return 1;
}

/**************************************************************/
/* plugin_move_window()                                       */
/*                                                            */
/* Move a plug-in window to the location currenly specified   */
/* by the "position" BBox and parent window handle in the     */
/* given plugin_instance structure. If the parent window      */
/* handle is zero, the item is opened with no parent.         */
/*                                                            */
/* Parameters: Pointer to a plugin_instance struct relevant   */
/*             to the plug-in window to move.                 */
/**************************************************************/

static _kernel_oserror * plugin_move_window(plugin_instance * i)
{
  WindowShowObjectBlock show;

  /* Construct the Show block */

  show.visible_area         = i->position;
  show.xscroll              = 0;
  show.yscroll              = 0;
  show.behind               = -1;

  show.window_flags         = 0;
  show.parent_window_handle = i->parent_window_handle;
  show.alignment_flags      = 0;

  if (i->parent_window_handle != 0)
  {
    RetError(toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
                                 i->window_id,
                                 Toolbox_ShowObject_FullSpec,
                                 &show,
                                 NULL_ObjectId,
                                 NULL_ComponentId));

    return plugin_move_video(i);
  }
  else
  {
    RetError(toolbox_show_object(0,
                                 i->window_id,
                                 Toolbox_ShowObject_FullSpec,
                                 &show,
                                 NULL_ObjectId,
                                 NULL_ComponentId));

    return wimp_set_caret_position(i->window_handle,
                                     -1,
                                     0,
                                     0,
                                     -1,
                                     -1);
  }
}

/**************************************************************/
/* plugin_set_launcher()                                      */
/*                                                            */
/* Set the 'launcher' field of a given plug-in to a given     */
/* other instance handle.                                     */
/*                                                            */
/* Parameters: Instance handle of the item to alter;          */
/*                                                            */
/*             Instance handle to set.                        */
/**************************************************************/

void plugin_set_launcher(unsigned int instance, unsigned int launcher)
{
  plugin_instance * i = plugin_find_instance(instance);

  if (i != NULL) i->launcher = launcher;
}

/**************************************************************/
/* plugin_get_launcher()                                      */
/*                                                            */
/* Given an instance handle, returns the instance handle of   */
/* the plug-in responsible for launching this item (in        */
/* practice the value of the 'launcher' field of the plug-in  */
/* instance structure internally).                            */
/*                                                            */
/* Parameters: Instance handle of the item to examine.        */
/*                                                            */
/* Returns:    Instance handle of the launcher, or zero if    */
/*             there's no launcher or the instance handle     */
/*             passed in was unrecognised.                    */
/**************************************************************/

unsigned int plugin_get_launcher(unsigned int instance)
{
  plugin_instance * i = plugin_find_instance(instance);

  if (i != NULL) return i->launcher;
  else           return 0;
}

/**************************************************************/
/* plugin_move_video()                                        */
/*                                                            */
/* Move video playback to the location derived from the given */
/* plugin_instance structure. Usually called from             */
/* plugin_move_window.                                        */
/*                                                            */
/* This code may be called from filter_code in Filter.c and   */
/* thus has all the restrictions of that function too.        */
/*                                                            */
/* Parameters: Pointer to a plugin_instance struct relevant   */
/*             to the video to move.                          */
/**************************************************************/

static _kernel_oserror * plugin_move_video(plugin_instance * i)
{
  /* Can't proceed unless we have a Video Control handle */

  if (i->video_control_handle != 0)
  {
    int opts[7];

    opts[0] = vc_tags_rectangle;
    opts[1] = 4;
    opts[4] = i->position.xmax - i->position.xmin;
    opts[5] = i->position.ymax - i->position.ymin;
    opts[2] = i->position.xmin + opts[4] / 2;
    opts[3] = i->position.ymin + opts[5] / 2;

    opts[4] -= i->border * 4; /* 2 OS units = 1 "web pixel" taken twice for left plus right borders */
    opts[5] -= i->border * 4; /* 2 OS units = 1 "web pixel" taken twice for top plus bottom borders */

    opts[6] = vc_tags__end;

    _swix(VideoControl_Options,
          _INR(0,2),

          0,
          i->video_control_handle,
          &opts);
  }

  return NULL;
}

/**************************************************************/
/* plugin_set_video_options()                                 */
/*                                                            */
/* After a starting-up player has set any options it wants,   */
/* it should call this if running on the basis of a plug-in.  */
/* Here, the options within that plug-in are examined and     */
/* conveyed to Video Control as appropriate.                  */
/*                                                            */
/* Parameters: Plug-in instance handle of item to examine;    */
/*                                                            */
/*             Video Control client ID to use.                */
/**************************************************************/

_kernel_oserror * plugin_set_video_options(unsigned int instance, unsigned int vc_id)
{
  plugin_instance * i;
  int               opts[28];

  if (instance == 0) return NULL;
  i = plugin_find_instance(instance);
  if (i == NULL) return NULL;

  /* If the 'launcher' field is non-NULL the instance given was for a completely  */
  /* stand-alone item which was launched via. another item; the options we should */
  /* set are in that launcher item.                                               */

  if (i->launcher != 0)
  {
    plugin_instance * l = plugin_find_instance(i->launcher);

   /* If we can't find it, it's died! Maybe the browser crashed or something? */

    if (l != NULL) i           = l;
    else           i->launcher = 0; /* Clear the launcher reference since it's invalid */
  }

  /* Build the options block */

  opts[0]  = vc_tags_volume;
  opts[1]  = 1;
  opts[2]  = i->volume;

  opts[3]  = vc_tags_mp2program,
  opts[4]  = 1;
  opts[5]  = i->program;

  opts[6]  = vc_tags_mp2audiostream;
  opts[7]  = 1;
  opts[8]  = i->aud_stream;

  opts[9]  = vc_tags_mp2videostream;
  opts[10] = 1;
  opts[11] = i->vid_stream;

  opts[12] = vc_tags_demux;
  opts[13] = 1;

  switch(i->demux)
  {
    default:
    case 0: opts[14] = vc_demux_auto;  break;
    case 1: opts[14] = vc_demux_mpeg1; break;
    case 2: opts[14] = vc_demux_mpeg2; break;
  }

  opts[15] = vc_tags_looping;
  opts[16] = 1;
  opts[17] = i->loop;

  opts[18] = vc_tags_video_only;
  opts[19] = 1;
  opts[20] = i->no_audio;

  opts[21] = vc_tags_audio_only;
  opts[22] = 1;
  opts[23] = i->no_video;

  opts[24] = vc_tags_ntsc;
  opts[25] = 1;
  opts[26] = i->ntsc;

  opts[27] = vc_tags__end;

  /* Exit through Video Control */

  return _swix(VideoControl_Options,
               _INR(0,2),

               0,
               vc_id,
               &opts);
}

/**************************************************************/
/* plugin_get_video_options()                                 */
/*                                                            */
/* Return stored options for from and to positions for        */
/* playback.                                                  */
/*                                                            */
/* Parameters: Plug-in instance handle (passing zero is OK,   */
/*             you'll just get 'false' returned as described  */
/*             below);                                        */
/*                                                            */
/*             Pointer to an int to take "from";              */
/*                                                            */
/*             Pointer to an int to take "to".                */
/*                                                            */
/*             Pointer to a bool to take looping state -      */
/*             'true' if looping is on, else 'false'.         */
/*                                                            */
/* Returns:    Ints are updated with time in seconds for      */
/*             from/to. Negative values mean "unset", i.e.,   */
/*             beginning/end. The direct return value is      */
/*             true or false - if false, the plug-in          */
/*             instance handle given wasn't recognised and    */
/*             any pointers you passed will not have been     */
/*             written through.                               */
/*                                                            */
/* Assumes:    Any pointers passed may be NULL, but if not    */
/*             NULL must be valid.                            */
/**************************************************************/

bool plugin_get_video_options(unsigned int instance, int * from, int * to, bool * loop)
{
  plugin_instance * i;

  if (instance == 0) return false;
  i = plugin_find_instance(instance);
  if (i == NULL) return false;

  if (i->launcher != 0)
  {
    plugin_instance * l = plugin_find_instance(i->launcher);

   /* If we can't find it, it's died! Maybe the browser crashed or something? */

    if (l != NULL) i           = l;
    else           i->launcher = 0; /* Clear the launcher reference since it's invalid */
  }

  if (from != NULL) *from = i->from;
  if (to   != NULL) *to   = i->to;
  if (loop != NULL) *loop = i->loop == 0 ? false : true;

  return true;
}

/**************************************************************/
/* plugin_reread_all_windows()                                */
/*                                                            */
/* Read all plug-in window positions after a rectangle or     */
/* copy filter has been fired.                                */
/*                                                            */
/* This code may be called from filter_code in Filter.c and   */
/* thus has all the restrictions of that function too.        */
/**************************************************************/

_kernel_oserror * plugin_reread_all_windows(void)
{
  WimpGetWindowStateBlock   state;
  plugin_instance         * i = instances;
  int                       dx, dy;

  while (i)
  {
    state.window_handle = i->window_handle;
    RetError(wimp_get_window_state(&state));

    dx = state.visible_area.xmin - i->position.xmin;
    dy = state.visible_area.ymax - i->position.ymax;

    if (dx != 0 || dy != 0)
    {
      i->position = state.visible_area;
      plugin_move_video(i);
    }

    i = i->next;
  }

  return NULL;
}

/**************************************************************/
/* plugin_shutdown()                                          */
/*                                                            */
/* Closes down all plug-ins.                                  */
/**************************************************************/

void plugin_shutdown(void)
{
  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_shutdown: Called\n"));
  #endif

  while (instances != NULL)
  {
    plugin_delete_instance(instances);
  }

  /* Finished */

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_shutdown: Successful\n"));
  #endif

  return;
}
