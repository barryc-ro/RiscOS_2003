/**************************************************************/
/* File:    PlugIn.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Supporting the generic RISC OS plug-in interface. */
/*                                                            */
/*          Unusual allocation schemes may be used to replace */
/*          malloc here, so do NOT malloc a message block and */
/*          try to send it; you'll hit the Wimp bug regarding */
/*          message blocks at high addresses with older       */
/*          versions.                                         */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 05-Oct-1997 (ADH): Created.                       */
/*          05-Apr-2000 (ADH): 64-wide comments adopted.      */
/*          18-Apr-2000 (ADH): Imported into PlugPlay.        */
/**************************************************************/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/event.h>
#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>

#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <Global/SWIs.h>
#include <MPEG/MPEGCtrl.h>
#include <MPEG/MPEGVideo.h>
#include <VideoCtrl.h>

#include "Filter.h"
#include "Fixed.h"
#include "FromROSLib.h"
#include "FullScreen.h"
#include "Global.h"
#include "MiscDefs.h"
#include "ModeInfo.h"
#include "Mouse.h"
#include "Overlay.h"
#include "RMA.h"
#include "Utils.h"

#include "PlugIn.h"

/* Possible missing external definitions */

#ifndef ModeFiles_SafeArea
  #define ModeFiles_SafeArea 0x4D481
#endif

#define ModeFiles_SafeArea_MagicWord 0x45444957 /* "WIDE" */

/* Local definitions and structures */

#define Magic_PlugIn_Instance    0x47554C50 /* "PLUG" */

#define PlugIn_ParamsName_ID          "id"
#define PlugIn_ParamsName_Data        "data"
#define PlugIn_ParamsName_Border      "border"
#define PlugIn_ParamsName_FS          "fullscreen"
#define PlugIn_ParamsName_SA          "standalone"
#define PlugIn_ParamsName_Adjust      "adjust"
#define PlugIn_ParamsName_Fixed       "fixed"
#define PlugIn_ParamsName_Demux       "demux"
#define PlugIn_ParamsName_AudStream   "audstream"
#define PlugIn_ParamsName_VidStream   "vidstream"
#define PlugIn_ParamsName_Program     "program"
#define PlugIn_ParamsName_From        "from"
#define PlugIn_ParamsName_To          "to"
#define PlugIn_ParamsName_Loop        "loop"
#define PlugIn_ParamsName_Volume      "volume"
#define PlugIn_ParamsName_NoAudio     "noaudio"
#define PlugIn_ParamsName_NoVideo     "novideo"
#define PlugIn_ParamsName_NoPalette   "nopalette"
#define PlugIn_ParamsName_NTSC        "ntsc"
#define PlugIn_ParamsName_HidePointer "hidepointer"

typedef struct plugin_file_entry
{
  struct plugin_file_entry * next;
  struct plugin_file_entry * prev;

  char                     * name;
  char                     * data;
  char                     * mime;
}
plugin_file_entry;

typedef struct plugin_instance
{
  unsigned int               magic;

  struct plugin_instance   * next;
  struct plugin_instance   * prev;
  unsigned int               launcher;

  plugin_file_entry        * entries;

  unsigned int               browser_instance_handle;
  unsigned int               plugin_instance_handle;
  unsigned int               video_control_handle;

  unsigned int               parent_task_handle;
  unsigned int               parent_window_handle;
  ObjectId                   window_id;
  int                        window_handle;
  BBox                       position;

  const char               * id;  /* These point into the plugin_file_entry structs, */
  const char               * url; /* so should not have free() called on them.       */

  int                        border;
  int                        from;
  int                        to;
  unsigned int               volume;
  unsigned int               aud_stream;
  unsigned int               vid_stream;
  unsigned int               program;

  unsigned                   redraw_handler :1;
  unsigned                   reopen_handler :1;
  unsigned                   focus_handler  :1;
  unsigned                   filter_done    :1;
  unsigned                   monitoring     :1;

  unsigned                   adjustable     :1;
  unsigned                   fixed_width    :1;
  unsigned                   fixed_height   :1;

  unsigned                   full_screen    :1;
  unsigned                   stand_alone    :1;
  unsigned                   demux          :2;
  unsigned                   loop           :1;
  unsigned                   no_audio       :1;
  unsigned                   no_video       :1;
  unsigned                   no_palette     :1;
  unsigned                   ntsc           :1;
}
plugin_instance;

/* Local variables */

static plugin_instance * instances = NULL;

/* Local functions */

static plugin_instance * plugin_new_instance        (void);
static void              plugin_delete_instance     (plugin_instance * i);
static plugin_instance * plugin_find_instance       (unsigned int handle);

static _kernel_oserror * plugin_new_file_entry      (plugin_instance * i);
static void              plugin_delete_file_entry   (plugin_instance * i, plugin_file_entry * en);
static void              plugin_delete_file_entries (plugin_instance * i);
static _kernel_oserror * plugin_read_params_file    (plugin_instance * i, const char * filename);

static _kernel_oserror * plugin_make_initialised    (WimpMessage * m, BBox * at, unsigned int * newh);

static int               plugin_redraw_window       (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);
static int               plugin_reopen_window       (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);
static int               plugin_regain_focus        (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);

static _kernel_oserror * plugin_move_window         (plugin_instance * i);
static _kernel_oserror * plugin_move_video          (plugin_instance * i);

static _kernel_oserror * plugin_resize_window       (plugin_instance * i, unsigned int w, unsigned int h);
static void              plugin_resize_video        (plugin_instance * i);
static int               plugin_monitor_video       (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);

/**************************************************************/
/* plugin_new_instance()                                      */
/*                                                            */
/* Allocate space for a new plugin_instance struct. The item  */
/* is 0-initialised and essential fields filled in (e.g. the  */
/* magic word).                                               */
/*                                                            */
/* Returns:    Pointer to the new item, or NULL if out of     */
/*             memory.                                        */
/**************************************************************/

static plugin_instance * plugin_new_instance(void)
{
  #ifdef APPLICATION

    plugin_instance * new = calloc(1, sizeof(plugin_instance));

    if (new == NULL) return NULL;

  #else

    plugin_instance * new = NULL;

    rma_claim(NULL, sizeof(plugin_instance), (void **) &new);

    if (new == NULL) return NULL;
    else memset(new, '\0', sizeof(plugin_instance));

  #endif

  new->magic                  = Magic_PlugIn_Instance;
  new->window_id              = NULL_ObjectId;
  new->plugin_instance_handle = (int) new; /* At present, the instance handle is just a pointer to the structure */

  if (instances != NULL)
  {
    instances->prev = new;
    new->next       = instances;
  }

  instances = new;

  return new;
}

/**************************************************************/
/* plugin_delete_stand_alone()                                */
/*                                                            */
/* Delete a stand alone plug-in instance created with         */
/* plugin_make_stand_alone.                                   */
/*                                                            */
/* Parameters: Stand-alone plug-in's instance handle.         */
/**************************************************************/

void plugin_delete_stand_alone(unsigned int handle)
{
  plugin_delete_instance(plugin_find_instance(handle));
}

/**************************************************************/
/* plugin_delete_instance()                                   */
/*                                                            */
/* Delete a plugin_instance from the list along with any      */
/* items related to it (e.g. Toolbox objects).                */
/*                                                            */
/* Parameters: Instance handle for item to delete.            */
/**************************************************************/

static void plugin_delete_instance(plugin_instance * i)
{
  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_delete_instance: Called for %p\n", i));
  #endif

  if (i == NULL) return;

  /* The 'id' and 'url' fields point into the file entries, so we */
  /* do NOT free these individually.                              */

  plugin_delete_file_entries(i);

  if (i->prev)        i->prev->next = i->next;
  if (i->next)        i->next->prev = i->prev;
  if (instances == i) instances     = i->next;

  if (i->filter_done    == 1) filter_remove_filter();
  if (i->redraw_handler == 1) event_deregister_wimp_handler(i->window_id, Wimp_ERedrawWindow, plugin_redraw_window, (void *) i->plugin_instance_handle);
  if (i->reopen_handler == 1) event_deregister_wimp_handler(i->window_id, Wimp_EOpenWindow,   plugin_reopen_window, (void *) i->plugin_instance_handle);
  if (i->focus_handler  == 1) event_deregister_wimp_handler(i->window_id, Wimp_ELoseCaret,    plugin_regain_focus,  (void *) i->window_handle);
  if (i->monitoring     == 1) deregister_null_claimant(Wimp_ENull, plugin_monitor_video, (void *) i);

  if (i->window_id != NULL_ObjectId) toolbox_delete_object(0, i->window_id);

  #ifdef APPLICATION
    free(i);
  #else
    rma_release(NULL, (void *) i);
  #endif

  return;
}

/**************************************************************/
/* plugin_find_instance()                                     */
/*                                                            */
/* Given a plug-in instance handle, returns a pointer to the  */
/* related plugin_instance struct or NULL if the handle is    */
/* unknown / invalid.                                         */
/*                                                            */
/* Parameters: Plug-in instance handle.                       */
/*                                                            */
/* Returns:    Pointer to related plugin_instance struct or   */
/*             NULL if the handle is unknown.                 */
/**************************************************************/

static plugin_instance * plugin_find_instance(unsigned int handle)
{
  _kernel_oserror * e;
  plugin_instance * i;
  unsigned int      valid;

  /* The plug-in instance handle is the address off the plugin_instance */
  /* structure for the referenced instance. Validate the address and    */
  /* ensure that there's the magic word there before proceeding.        */

  i = (plugin_instance *) handle;

  e = _swix(OS_ValidateAddress,
            _INR(0,1) | _OUT(_FLAGS),

            i,
            i + 1,
            &valid);

  if (e || (valid & _C) || i->magic != Magic_PlugIn_Instance)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_find_instance: Handle &%08X is invalid\n", handle));
    #endif

    return NULL;
  }

  return i;
}

/**************************************************************/
/* plugin_new_file_entry()                                    */
/*                                                            */
/* Adds a plugin_file_entry to a given plugin_instance at the */
/* head of the list.                                          */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure to    */
/*             add to.                                        */
/**************************************************************/

static _kernel_oserror * plugin_new_file_entry(plugin_instance * i)
{
  #ifdef APPLICATION

    plugin_file_entry * new = calloc(1, sizeof(plugin_file_entry));

    if (new == NULL) return make_no_memory_error(0);

  #else

    plugin_file_entry * new = NULL;

    RetError(rma_claim(NULL, sizeof(plugin_file_entry), (void **) &new));
    memset(new, '\0', sizeof(plugin_file_entry));

  #endif

  if (i->entries != NULL)
  {
    i->entries->prev = new;
    new->next        = i->entries;
  }

  i->entries = new;

  return NULL;
}

/**************************************************************/
/* plugin_delete_file_entry()                                 */
/*                                                            */
/* Delete a given plugin_file_entry from a given              */
/* plugin_instance.                                           */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure to    */
/*             delete from;                                   */
/*                                                            */
/*             Pointer to the plugin_file_entry to delete.    */
/**************************************************************/

static void plugin_delete_file_entry(plugin_instance * i, plugin_file_entry * en)
{
  if (en->prev != NULL) en->prev->next = en->next;
  if (en->next != NULL) en->next->prev = en->prev;
  if (en == i->entries) i->entries     = en->next;

  #ifdef APPLICATION

    if (en->name != NULL) free(en->name);
    if (en->data != NULL) free(en->data);
    if (en->mime != NULL) free(en->mime);

    free(en);

  #else

    if (en->name != NULL) rma_release(NULL, (void *) en->name);
    if (en->data != NULL) rma_release(NULL, (void *) en->data);
    if (en->mime != NULL) rma_release(NULL, (void *) en->mime);

    rma_release(NULL, (void *) en);

  #endif

  return;
}

/**************************************************************/
/* plugin_delete_file_entries()                               */
/*                                                            */
/* Delete all plugin_file_entry structures from a given       */
/* plugin_instance.                                           */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure to    */
/*             delete from.                                   */
/**************************************************************/

static void plugin_delete_file_entries(plugin_instance * i)
{
  while (i->entries != NULL) plugin_delete_file_entry(i, i->entries);

  return;
}

/**************************************************************/
/* plugin_read_params_word()                                  */
/*                                                            */
/* Read an integer from a parameters file.                    */
/*                                                            */
/* Parameters: Pointer to FILE struct to read through;        */
/*                                                            */
/*             Pointer to int to update.                      */
/*                                                            */
/* Returns:    0 for success, EOF for an error.               */
/*                                                            */
/* Assumes:    Parameter pointers must be non-NULL and valid. */
/**************************************************************/

static int plugin_read_params_word(FILE * f, int * word)
{
  int i;
  int c;

  /* Despite assumption stated in comments above, this is not speed */
  /* critical in practice so paranoid code is worthwhile.           */

  if (word == NULL) return EOF;

  /* Read each byte, assembling the word */

  c = fgetc(f);
  if (c == EOF) return EOF;

  i = c & 0xff;

  c = fgetc(f);
  if (c == EOF) return EOF;

  i |= ((c & 0xff) << 8);

  c = fgetc(f);
  if (c == EOF) return EOF;

  i |= ((c & 0xff) << 16);

  c = fgetc(f);
  if (c == EOF) return EOF;

  i |= ((c & 0xff) << 24);

  /* Finished */

  *word = i;

  return 0;
}

/**************************************************************/
/* plugin_read_params_string()                                */
/*                                                            */
/* Read a name, mime type or data string from the parameters  */
/* file.                                                      */
/*                                                            */
/* Parameters: Pointer to a FILE struct to read through;      */
/*                                                            */
/*             Pointer to a char * updated to point to the    */
/*             string in a malloced block that the caller     */
/*             must free if APPLICATION is defined, or an     */
/*             rma_claim'd block that the caller must         */
/*             rma_release (with allocator=NULL) if           */
/*             APPLICATION is not defined.                    */
/*                                                            */
/* Returns:    0 for success, EOF for an error, and the char  */
/*             * updated to NULL if, specifically, out of     */
/*             memory.                                        */
/*                                                            */
/* Assumes:    Parameter pointers must be non-NULL and valid. */
/**************************************************************/

static int plugin_read_params_string(FILE * f, char ** string)
{
  int i, l;
  int c;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_read_params_string: Called\n"));
  #endif

  /* Read the string length and allocate a buffer */

  c = plugin_read_params_word(f, &i);

  if (c == EOF) return EOF;

  #ifdef APPLICATION

    *string = malloc(i + 1);

  #else

    *string = NULL;
    rma_claim(NULL, i + 1, (void **) string);

  #endif

  if (*string == NULL) return EOF;

  /* Read the string */

  for (l = 0; l < i; l++)
  {
    c = fgetc(f);
    if (c == EOF) return EOF;
    (*string)[l] = c;
  }

  (*string)[i] = '\0';

  /* Skip to word aligned point */

  while (ftell(f) % 4 != 0)
  {
    c = fgetc(f);
    if (c == EOF) return EOF;
  }

  /* Finished */

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_read_params_string: Successful, read '%s', ended up at %d\n", *string, (unsigned int) ftell(f)));
  #endif

  return 0;
}

/**************************************************************/
/* plugin_read_params_file()                                  */
/*                                                            */
/* Read a parameters file. The 'url' and 'id' fields of the   */
/* given plugin_instance structure may be updated on exit to  */
/* point into appropriate strings within the file structures. */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure       */
/*             relevant to the file;                          */
/*                                                            */
/*             Pointer to the filename, NUL terminated.       */
/**************************************************************/

static _kernel_oserror * plugin_read_params_file(plugin_instance * i, const char * filename)
{
  _kernel_oserror * e = NULL;
  FILE            * f = fopen(filename, "rb");
  int               c = 0;
  int               word;

  if (f == NULL)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("CannotOpen:Cannot open parameters file",
                          0,0));

    return &erb;
  }

  for (;;)
  {
    /* Read the entry type */

    c = plugin_read_params_word(f, &word);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    if (word == PlugIn_ParamType_Terminator) break;

    /* Read the record size - we don't actually care about this */

    c = plugin_read_params_word(f, &word);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    /* Allocate a new entry structure */

    e = plugin_new_file_entry(i);
    if (e != NULL) goto plugin_read_params_file_exit_with_error;

    /* Read the name, data and mime type */

    c = plugin_read_params_string(f, &i->entries->name);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    c = plugin_read_params_string(f, &i->entries->data);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    c = plugin_read_params_string(f, &i->entries->mime);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    /* If we get the ID or DATA entries, store a direct pointer to them */
    /* within the instance structure for faster access later.           */

    if (i->entries->name != NULL && i->entries->data != NULL)
    {
      #define YesNoToFlag(x) (utils_strcasecmp((x), "yes") == 0 ? 1 : 0)

      if      (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_ID))   i->id  = i->entries->data;
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Data)) i->url = i->entries->data;

      /* Now read our various plug-in supported options */

      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Border))      i->border      = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_FS))          i->full_screen = YesNoToFlag(i->entries->data); /* Forces Stand Alone to 'yes', see below */
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_SA))          i->stand_alone = YesNoToFlag(i->entries->data);

      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Demux))       i->demux       = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_AudStream))   i->aud_stream  = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_VidStream))   i->vid_stream  = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Program))     i->program     = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_From))        i->from        = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_To))          i->to          = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Loop))        i->loop        = YesNoToFlag(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Volume))      i->volume      = atoi(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_NoAudio))     i->no_audio    = YesNoToFlag(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_NoVideo))     i->no_video    = YesNoToFlag(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_NoPalette))   i->no_palette  = YesNoToFlag(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_NTSC))        i->ntsc        = YesNoToFlag(i->entries->data);

      /* Auto resize stuff */

      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Adjust))      i->adjustable  = YesNoToFlag(i->entries->data);
      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Fixed))
      {
        if      (!utils_strcasecmp(i->entries->data, "width"))  i->fixed_width  = 1;
        else if (!utils_strcasecmp(i->entries->data, "height")) i->fixed_height = 1;
      }

      /* Force mouse pointer off, on the head of the web page designer...! */

      else if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_HidePointer))
      {
        if (YesNoToFlag(i->entries->data) != 0) mouse_pointer_off();
      }
    }
  }

  /* If full-screen, must implicitly be stand-alone */

  if (i->full_screen != 0) i->stand_alone = 1;

  /* Normal mode exit */

  fclose(f);
  return NULL;

  /* Error mode exit */

plugin_read_params_file_exit_with_error:

  if (f != NULL) fclose(f);
  plugin_delete_file_entries(i);

  if (e == NULL)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("CannotRead:Cannot understand parameters file",
                          0,0));

    return &erb;
  }
  else return e;
}

/**************************************************************/
/* plugin_return_string()                                     */
/*                                                            */
/* Takes a message block and string_value from within it, and */
/* returns the string it points to.                           */
/*                                                            */
/* Parameters: Pointer to a WimpMessage struct holding the    */
/*             string_value field;                            */
/*                                                            */
/*             Pointer to the string_value field inside that  */
/*             message.                                       */
/*                                                            */
/* Returns:    Pointer to the string the string_value         */
/*             references, or NULL if the value seems         */
/*             invalid.                                       */
/**************************************************************/

const char * plugin_return_string(WimpMessage * m, string_value * sv)
{
  int offset = ((char *) sv) - ((char *) m);

  if (!m || !sv || !sv->offset) return NULL;

  /* Is the offset of the string_value field within the message */
  /* block out of range (i.e. the string_value does not appear  */
  /* to lie in the given message block)?                        */

  if (offset >= m->hdr.size || offset < sizeof(m->hdr)) return NULL;

  /* Now read the string_value field itself */

  if (sv->offset < 256)
  {
    if (sizeof(m->hdr) + offset >= m->hdr.size) return NULL;

    else return (const char *) (((char *) m) + sizeof(m->hdr) + sv->offset);
  }
  else return (const char *) sv->offset;
}

/**************************************************************/
/* plugin_make_stand_alone()                                  */
/*                                                            */
/* Make a stand-alone plug-in instance.                       */
/*                                                            */
/* Parameters: Pointer to a BBox holding coords to open the   */
/*             item at (screen coords, OS units);             */
/*                                                            */
/*             Pointer to an unsigned int to take the stand-  */
/*             alone plugin-instance handle, so that          */
/*             plugin_delete_instance can later be called.    */
/*                                                            */
/* Assumes:    Both pointers are non-NULL and valid.          */
/**************************************************************/

_kernel_oserror * plugin_make_stand_alone(BBox * at, unsigned int * newh)
{
  *newh = NULL;

  return plugin_make_initialised(NULL, at, newh);
}

/**************************************************************/
/* plugin_got_open()                                          */
/*                                                            */
/* Handle reception of a Message_PlugIn_Open.                 */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_open(WimpMessage * m)
{
  return plugin_make_initialised(m, NULL, NULL);
}

/**************************************************************/
/* plugin_make_initialised()                                  */
/*                                                            */
/* Make a plug-in instance based on a Message_PlugIn_Open or  */
/* as a stand-alone item.                                     */
/*                                                            */
/* Plug-ins that launch and find themselves flagged as stand- */
/* alone via. the Params file will act as placeholders and    */
/* a second, "true" stand-alone session will be automatically */
/* launched. This means that this function MUST BE REENTRANT. */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message, or NULL for a stand-alone item;   */
/*                                                            */
/*             NULL for a conventional plug-in, or pointer to */
/*             a BBox holding coords to open stand-alone item */
/*             at (screen coords, OS units).                  */
/*                                                            */
/*             Optional pointer to unsigned into take new     */
/*             item's instance handle.                        */
/**************************************************************/

static _kernel_oserror * plugin_make_initialised(WimpMessage * m, BBox * at, unsigned int * newh)
{
  _kernel_oserror         * e;
  WimpGetWindowStateBlock   state;
  ObjectId                  newo;
  int                       plugin_instance_handle;
  plugin_instance         * i;
  MPlugIn_Open            * open;
  MPlugIn_Opening         * opening = (MPlugIn_Opening *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Called for %p, %p\n", m, at));
  #endif

  if (m == NULL && at == NULL) return NULL;

  if (m == NULL) open = NULL;
  else           open = (MPlugIn_Open *) &m->data;

  if (open != NULL && open->file_type != PlugIn_LaunchKey)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Filetype %03X doesn't match launch key %03X\n", open->file_type, PlugIn_LaunchKey));
    #endif

    return NULL;
  }

  i = plugin_new_instance();

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Out of memory\n"));
    #endif

    return make_no_memory_error(0);
  }

  /* Currently, instance handles just point back to the plugin_instance structure */

  plugin_instance_handle = (int) i;
  if (newh != NULL) *newh = plugin_instance_handle;

  /* Set defaults prior to reading the params file (if we read it, that is) */

  i->border      = 0;
  i->from        = -1; /* Beginning */
  i->to          = -1; /* End */
  i->volume      = 256;
  i->aud_stream  = 1;
  i->vid_stream  = 1;
  i->program     = 1;
  i->full_screen = open == NULL ? 1 : 0;
  i->stand_alone = open == NULL ? 1 : 0;
  i->demux       = 0;
  i->loop        = 0;
  i->no_audio    = 0;
  i->no_video    = 0;
  i->no_palette  = 0;

  /* If not stand-alone, record the parent task and read the parameters file */

  if (i->stand_alone == 0 && m != NULL)
  {
    i->parent_task_handle = m->hdr.sender;
    e = plugin_read_params_file(i, plugin_return_string(m, &open->file_name));
  }
  else e = NULL;

  /* Note that stand-alone plug-ins exist in two forms. Having the stand_alone flag */
  /* set isn't enough. If you've got that set but also have a parent window handle, */
  /* the plug-in instance is there just to fill the hole in the web page. There     */
  /* will be / should be later another plug-in created as "completely" stand-alone, */
  /* which has no parent window handle. When that full-screen play session is shut  */
  /* down the placeholder plug-in remains, keeping the web browser happy and        */
  /* keeping the whole in the page.                                                 */
  /*                                                                                */
  /* For this reason, many bits of the code below continue to use "open != NULL" to */
  /* see if this is a *truly* stand-alone plug-in rather than checking the          */
  /* stand_alone flag; it's a shorthand way of checking the flag and parent handle. */

  if (e == NULL)
  {
    /* Create the video window. If this works, register our redraw handler. */

    e = toolbox_create_object(0,
                              "Video",
                              &newo);
  }

  if (e == NULL)
  {
    e = event_register_wimp_handler(newo,
                                    Wimp_ERedrawWindow,
                                    plugin_redraw_window,
                                    (void *) plugin_instance_handle);
  }

  /* Flag this was successful register our OpenWindow event filter, if not stand-alone */
  /* (so plug-ins which are in-page placeholders with the stand-alone flag set *do*    */
  /* have a filter)                                                                    */

  if (e == NULL)
  {
    i->redraw_handler = 1;

    if (open != NULL) e = filter_add_filter();
  }

  /* Now other general bits of information */

  if (e == NULL)
  {
    if (open != NULL)
    {
      i->filter_done = 1;

      i->browser_instance_handle = open->browser_instance_handle;
      i->parent_window_handle    = open->parent_window_handle;
    }

    i->window_id = newo;
    e = window_get_wimp_handle(0, newo, &i->window_handle);
  }

  /* For plug-in, get the parent window state so we can work out where the plug-in */
  /* should be opened in a moment. For full-screen items, install a 'regain input  */
  /* focus' handler.                                                               */

  if (e == NULL)
  {
    if (open != NULL)
    {
      state.window_handle = open->parent_window_handle;
      e = wimp_get_window_state(&state);
    }
    else
    {
      e = event_register_wimp_handler(newo,
                                      Wimp_ELoseCaret,
                                      plugin_regain_focus,
                                      (void *) i->window_handle);
    }
  }

  if (e != NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: General error - '%s'\n", e->errmess));
    #endif

    plugin_delete_instance(i);
    return e;
  }

  /* We only use the given bounding box for completely stand-alone plugins, not   */
  /* placeholders, thus switch on 'open != NULL' rather than the stand_alone flag */

  if (open != NULL)
  {
    i->position = open->parent_area;
    coords_box_toscreen(&i->position, (WimpRedrawWindowBlock *) &state);
  }
  else
  {
    i->position = *at;
  }

  e = plugin_move_window(i);

  if (e != NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Error from plugin_move_window - '%s'\n", e->errmess));
    #endif

    plugin_delete_instance(i);
    return e;
  }

  if (open != NULL)
  {
    /* Respond with Message_PlugIn_Opening */

    m->hdr.size                      = sizeof(MPlugIn_Opening) + offsetof(WimpMessage, data);
    m->hdr.your_ref                  = m->hdr.my_ref;
    m->hdr.action_code               = Message_PlugIn_Opening;

    opening->flags                   = MPlugIn_Opening_ActionBeyondStop;
    opening->browser_instance_handle = i->browser_instance_handle;
    opening->plugin_instance_handle  = plugin_instance_handle;
    opening->parent_window_handle    = i->parent_window_handle;
    opening->parent_area             = i->position;

    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Exitting through wimp_send_message, sending handle %p\n", i));
    #endif

    RetError(wimp_send_message(Wimp_EUserMessage,
                               m,
                               m->hdr.sender,
                               0,
                               NULL));

    if (i->stand_alone && i->full_screen)
    {
      /* If we're stand-alone but open != NULL, this is a placeholder plug-in. We */
      /* should now launch the true full screen client. Note that this routine    */
      /* will be re-entered as a result of this call, assuming all goes well.     */

      fullscreen_report_error(fullscreen_start(i->url, i->plugin_instance_handle), true);
    }

    else
    {
      /* If this item can be resized to fit the video, set a watcher. It's the */
      /* best we can do - we don't know when the first frame will be decoded   */
      /* but we can't read the current video size until then.                  */

      if (i->adjustable != 0 && i->monitoring == 0)
      {
        i->monitoring = 1;

        register_null_claimant(Wimp_ENull,
                               plugin_monitor_video,
                               i);
      }
    }

    return NULL;
  }
  else
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_make_initialised: Stand-alone creation successful, exitting for handle %p\n", i));
    #endif

    return NULL;
  }
}

/**************************************************************/
/* plugin_got_close()                                         */
/*                                                            */
/* Handle reception of a Message_PlugIn_Close.                */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_close(WimpMessage * m)
{
  plugin_instance * i;
  MPlugIn_Close   * close  = (MPlugIn_Close  *) &m->data;
  MPlugIn_Closed  * closed = (MPlugIn_Closed *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_close: Called\n"));
  #endif

  /* Validate the plug-in instance handle */

  i = plugin_find_instance(close->plugin_instance_handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_close: Instance handle &%08X invalid\n", close->plugin_instance_handle));
    #endif

    return NULL;
  }

  /* The handle is good */

  plugin_delete_instance(i);

  /* Respond with Message_PlugIn_Closed */

  m->hdr.size                     = sizeof(MPlugIn_Closed) + offsetof(WimpMessage, data);;
  m->hdr.your_ref                 = m->hdr.my_ref;
  m->hdr.action_code              = Message_PlugIn_Closed;

  closed->flags                   = 0;
  closed->browser_instance_handle = i->browser_instance_handle;
  closed->plugin_instance_handle  = i->plugin_instance_handle;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_close: Exitting through wimp_send_message\n"));
  #endif

  return wimp_send_message(Wimp_EUserMessage,
                           m,
                           m->hdr.sender,
                           0,
                           NULL);
}

/**************************************************************/
/* plugin_got_reshape()                                       */
/*                                                            */
/* Handle reception of a Message_PlugIn_Reshape.              */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_reshape(WimpMessage * m)
{
  WimpGetWindowStateBlock   state;
  plugin_instance         * i;
  MPlugIn_Reshape         * reshape = (MPlugIn_Reshape *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_reshape: Called for %p\n", (plugin_instance *) reshape->plugin_instance_handle));
  #endif

  /* Validate the plug-in instance handle */

  i = plugin_find_instance(reshape->plugin_instance_handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_reshape: Instance handle &%08X invalid\n", reshape->plugin_instance_handle));
    #endif

    return NULL;
  }

  /* The handle is good */

  state.window_handle = reshape->parent_window_handle;
  RetError(wimp_get_window_state(&state));

  i->position = reshape->parent_area;

  coords_box_toscreen(&i->position, (WimpRedrawWindowBlock *) &state);

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_reshape: Exitting through plugin_move_window with %d, %d, %d, %d\n", i->position.xmin, i->position.ymin, i->position.xmax, i->position.ymax));
  #endif

  return plugin_move_window(i);
}

/**************************************************************/
/* plugin_got_action()                                        */
/*                                                            */
/* Handle reception of a Message_PlugIn_Action.               */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_action(WimpMessage * m)
{
  MPlugIn_Action * action = (MPlugIn_Action *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_action: Called\n"));
  #endif

  (void) action;

  return NULL;
}

/**************************************************************/
/* plugin_got_abort()                                         */
/*                                                            */
/* Handle reception of a Message_PlugIn_Abort.                */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_abort(WimpMessage * m)
{
  MPlugIn_Abort * abort = (MPlugIn_Abort *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_abort: Called\n"));
  #endif

  (void) abort;

  return NULL;
}

/**************************************************************/
/* plugin_got_inform()                                        */
/*                                                            */
/* Handle reception of a Message_PlugIn_Inform.               */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_inform(WimpMessage * m)
{
  plugin_instance * i;
  MPlugIn_Inform  * inform = (MPlugIn_Inform *) &m->data;
  char              id [sizeof(inform->name) + 1];

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Called\n"));
  #endif

  if (inform->info_id == MPlugIn_Inform_InfoID_VideoControlHandle)
  {
    strncpy(id, inform->name, sizeof(id) - 1);
    id[sizeof(id) - 1] = '\0';

    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Supported inform received for '%s', handle %08X\n",
                                  id,
                                  inform->info.video_control_handle));
    #endif

    i = instances;

    while (i)
    {
      if (!strcmp(i->id, id)) break;
      i = i->next;
    }

    if (i != NULL)
    {
      MPlugIn_Informed * r = (MPlugIn_Informed *) &m->data;

      #ifdef TRACE
        if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Assigning handle to instance %p\n", i));
      #endif

      i->video_control_handle = inform->info.video_control_handle;

      /* Ensure the video position is up to date */

      RetError(plugin_move_video(i));

      /* Ensure the plug-in matches the video */

      if (i->adjustable != 0 && i->monitoring == 0)
      {
        i->monitoring = 1;

        register_null_claimant(Wimp_ENull,
                               plugin_monitor_video,
                               i);
      }

      /* Reply */

      m->hdr.size                = sizeof(MPlugIn_Informed) + offsetof(WimpMessage, data);;
      m->hdr.your_ref            = m->hdr.my_ref;
      m->hdr.action_code         = Message_PlugIn_Informed;

      r->browser_instance_handle = i->browser_instance_handle;
      r->plugin_instance_handle  = i->plugin_instance_handle;

      RetError(wimp_send_message(Wimp_EUserMessage,
                                 m,
                                 m->hdr.sender,
                                 0,
                                 NULL));
    }
  }

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Successful\n"));
  #endif

  return NULL;
}

/**************************************************************/
/* plugin_got_focus()                                         */
/*                                                            */
/* Handle reception of a Message_PlugIn_Focus.                */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_focus(WimpMessage * m)
{
  plugin_instance * i;
  MPlugIn_Focus   * focus = (MPlugIn_Focus *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_focus: Called\n"));
  #endif

  i = plugin_find_instance(focus->plugin_instance_handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_focus: Instance handle &%08X invalid\n", focus->plugin_instance_handle));
    #endif

    return NULL;
  }

  /* And then do... Something. */

//  if (i->full_screen == 0)
//  {
//    fullscreen_start(i->url, 0);
//  }

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_focus: Successful\n"));
  #endif

  return NULL;
}

/**************************************************************/
/* plugin_redraw_window()                                     */
/*                                                            */
/* Handle Redraw requests for a plug-in window from the Wimp. */
/*                                                            */
/* Parameters are as standard for a Wimp event handler with   */
/* 'handle' set to the instance handle related to the window. */
/**************************************************************/

static int plugin_redraw_window(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  WimpRedrawWindowBlock   r;
  int                     more;
  plugin_instance       * i;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_redraw_window: Called\n"));
  #endif

  i = plugin_find_instance((int) handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_redraw_window: Instance handle &%08X invalid\n", (int) handle));
    #endif

    return NULL;
  }

  r.window_handle = ((WimpRedrawWindowRequestEvent *) b)->window_handle;
  ChkError(wimp_redraw_window(&r, &more));

  if (more)
  {
    unsigned int trans = modeinfo_return_transparent_gcol();

    do
    {
      _swix(OS_SetColour,
            _INR(0,1),

            1u<<4,
            trans);

      bbc_vdu(BBC_ClearGraph);

// Not particularly good, but just about useable debug stuff -
// check that the intended play rectangle is correct (best used
// in conjunction with "command:screensave <filename>").
//
//      {
//        int xmin, ymin, xmax, ymax;
//
//        _swix(OS_SetColour,
//              _INR(0,1),
//
//              1u<<4,
//              0x8);
//
//        xmax = i->position.xmax - i->position.xmin;
//        ymax = i->position.ymax - i->position.ymin;
//        xmin = i->position.xmin + xmax / 2;
//        ymin = i->position.ymin + ymax / 2;
//
//        xmax -= i->border * 4; /* 2 OS units = 1 "web pixel" taken twice for left plus right borders */
//        ymax -= i->border * 4; /* 2 OS units = 1 "web pixel" taken twice for top plus bottom borders */
//
//        bbc_rectangle(xmin - (xmax / 2), ymin - (ymax / 2), xmax - 1, ymax - 1);
//      }

      ChkError(wimp_get_rectangle(&r, &more));
    }
    while (more);
  }

  /* Stand-alone items: Poll the overlay system */

  if (i->parent_window_handle == 0) overlay_poll(0, NULL, NULL, NULL);

  return 1;
}

/**************************************************************/
/* plugin_reopen_window()                                     */
/*                                                            */
/* Handle Open requests for a plug-in window from the Wimp.   */
/*                                                            */
/* Parameters are as standard for a Wimp event handler with   */
/* 'handle' set to the instance handle related to the window. */
/**************************************************************/

static int plugin_reopen_window(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  plugin_instance * i;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_reopen_window: Called\n"));
  #endif

  i = plugin_find_instance((int) handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_reopen_window: Instance handle &%08X invalid\n", (int) handle));
    #endif

    return NULL;
  }

  return 1;
}

/**************************************************************/
/* plugin_regain_focus()                                      */
/*                                                            */
/* For full-screen windows, handle Wimp_ELoseCaret by         */
/* putting the caret back into the window again.              */
/**************************************************************/

static int plugin_regain_focus(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  unsigned int window_handle = (unsigned int) handle;

  ChkError(wimp_set_caret_position(window_handle,
                                   -1,
                                   0,
                                   0,
                                   -1,
                                   -1));
  return 1;
}

/**************************************************************/
/* plugin_move_window()                                       */
/*                                                            */
/* Move a plug-in window to the location currenly specified   */
/* by the "position" BBox and parent window handle in the     */
/* given plugin_instance structure. If the parent window      */
/* handle is zero, the item is opened with no parent.         */
/*                                                            */
/* If the window is to be moved because we want it to move,   */
/* rather than because the browser asked for it, you MUST go  */
/* through plugin_resize_window instead.                      */
/*                                                            */
/* Parameters: Pointer to a plugin_instance struct relevant   */
/*             to the plug-in window to move.                 */
/**************************************************************/

static _kernel_oserror * plugin_move_window(plugin_instance * i)
{
  WindowShowObjectBlock show;

  /* Construct the Show block */

  show.visible_area         = i->position;
  show.xscroll              = 0;
  show.yscroll              = 0;
  show.behind               = -1;

  show.window_flags         = 0;
  show.parent_window_handle = i->parent_window_handle;
  show.alignment_flags      = 0;

  if (i->parent_window_handle != 0)
  {
    RetError(toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
                                 i->window_id,
                                 Toolbox_ShowObject_FullSpec,
                                 &show,
                                 NULL_ObjectId,
                                 NULL_ComponentId));

    return plugin_move_video(i);
  }
  else
  {
    RetError(toolbox_show_object(0,
                                 i->window_id,
                                 Toolbox_ShowObject_FullSpec,
                                 &show,
                                 NULL_ObjectId,
                                 NULL_ComponentId));

    return wimp_set_caret_position(i->window_handle,
                                     -1,
                                     0,
                                     0,
                                     -1,
                                     -1);
  }
}

/**************************************************************/
/* plugin_set_launcher()                                      */
/*                                                            */
/* Set the 'launcher' field of a given plug-in to a given     */
/* other instance handle.                                     */
/*                                                            */
/* Parameters: Instance handle of the item to alter;          */
/*                                                            */
/*             Instance handle to set.                        */
/**************************************************************/

void plugin_set_launcher(unsigned int instance, unsigned int launcher)
{
  plugin_instance * i = plugin_find_instance(instance);

  if (i != NULL) i->launcher = launcher;
}

/**************************************************************/
/* plugin_get_launcher()                                      */
/*                                                            */
/* Given an instance handle, returns the instance handle of   */
/* the plug-in responsible for launching this item (in        */
/* practice the value of the 'launcher' field of the plug-in  */
/* instance structure internally).                            */
/*                                                            */
/* Parameters: Instance handle of the item to examine.        */
/*                                                            */
/* Returns:    Instance handle of the launcher, or zero if    */
/*             there's no launcher or the instance handle     */
/*             passed in was unrecognised.                    */
/**************************************************************/

unsigned int plugin_get_launcher(unsigned int instance)
{
  plugin_instance * i = plugin_find_instance(instance);

  if (i != NULL) return i->launcher;
  else           return 0;
}

/**************************************************************/
/* plugin_move_video()                                        */
/*                                                            */
/* Move video playback to the location derived from the given */
/* plugin_instance structure. Usually called from             */
/* plugin_move_window.                                        */
/*                                                            */
/* This code may be called from filter_code in Filter.c and   */
/* thus has all the restrictions of that function too.        */
/*                                                            */
/* Parameters: Pointer to a plugin_instance struct relevant   */
/*             to the video to move.                          */
/**************************************************************/

static _kernel_oserror * plugin_move_video(plugin_instance * i)
{
  /* Can't proceed unless we have a Video Control handle */

  if (i->video_control_handle != 0)
  {
    int opts[7];

    opts[0] = vc_tags_rectangle;
    opts[1] = 4;
    opts[4] = i->position.xmax - i->position.xmin;
    opts[5] = i->position.ymax - i->position.ymin;
    opts[2] = i->position.xmin + opts[4] / 2;
    opts[3] = i->position.ymin + opts[5] / 2;

    opts[4] -= i->border * 4; /* 2 OS units = 1 "web pixel" taken twice for left plus right borders */
    opts[5] -= i->border * 4; /* 2 OS units = 1 "web pixel" taken twice for top plus bottom borders */

    if      (i->fixed_width  != 0) opts[5] = 0; /* Let the MPEG system choose the height */
    else if (i->fixed_height != 0) opts[4] = 0; /* Let the MPEG system choose the width  */

    opts[6] = vc_tags__end;

    _swix(VideoControl_Options,
          _INR(0,2),

          0,
          i->video_control_handle,
          &opts);
  }

  return NULL;
}

/**************************************************************/
/* plugin_check_videos()                                      */
/*                                                            */
/* On seeing Service_VideoControl 6 (active area changed),    */
/* this is called to see if the Video Control handle given in */
/* the message matches a plug-in instance, and if so,         */
/* resize the item as required.                               */
/*                                                            */
/* Parameters: Video Control session handle to check for.     */
/*                                                            */
/* Returns:    Plug-in instance handle for which the resize   */
/*             was done, else 0 for none.                     */
/**************************************************************/

unsigned int plugin_check_videos(unsigned int vc_id)
{
  plugin_instance * i;

  for (i = instances; i != NULL; i = i->next)
  {
    if (i->video_control_handle == vc_id && (i->fixed_width != 0 || i->fixed_height != 0))
    {
      /* We found a match */

      plugin_resize_video(i);

      return i->plugin_instance_handle;
    }
  }

  /* No match found */

  return 0;
}

/**************************************************************/
/* plugin_resize_window()                                     */
/*                                                            */
/* Ask the browser to move (resize) the plug-in window via.   */
/* Message_PlugIn_ReshapeRequest. The parent task handle must */
/* be non-zero (so calling on slaves has no effect).          */
/*                                                            */
/* If width/height of the plug-in matches the given values no */
/* resize is done.                                            */
/*                                                            */
/* Parameters: Pointer to a plugin_instance struct relevant   */
/*             to the video to examine and plug-in to move;   */
/*                                                            */
/*             New width (OS units).                          */
/*                                                            */
/*             New height (OS units).                         */
/**************************************************************/

static _kernel_oserror * plugin_resize_window(plugin_instance * i, unsigned int w, unsigned int h)
{
  if (i->parent_task_handle)
  {
    /* Is the width/height different from what we last asked for? */

    if (
         w != i->position.xmax - i->position.xmin ||
         h != i->position.ymax - i->position.ymin
       )
    {
      WimpMessage              m;
      MPlugIn_ReshapeRequest * r = (MPlugIn_ReshapeRequest *) &m.data;

      m.hdr.size                 = sizeof(MPlugIn_ReshapeRequest) + offsetof(WimpMessage, data);
      m.hdr.your_ref             = 0;
      m.hdr.action_code          = Message_PlugIn_ReshapeRequest;

      r->flags                   = 0;
      r->browser_instance_handle = i->browser_instance_handle;
      r->plugin_instance_handle  = i->plugin_instance_handle;
      r->width                   = w;
      r->height                  = h;

      return wimp_send_message(Wimp_EUserMessage,
                               &m,
                               i->parent_task_handle,
                               0,
                               NULL);
    }
  }

  return NULL;
}

/**************************************************************/
/* plugin_resize_video()                                      */
/*                                                            */
/* If the active area of a clip changes, resize the plug-in   */
/* instance to which it relates.                              */
/*                                                            */
/* Service function for plugin_check_videos.                  */
/*                                                            */
/* Parameters: Pointer to plugin_instance to deal with.       */
/**************************************************************/

static void plugin_resize_video(plugin_instance * i)
{
  /* We'll use plugin_monitor_video for this. Video is probably already */
  /* decoding, but the UpCall leading to Service_VideoControl 6 leading */
  /* to this function being called may have happened right at the start */
  /* of the clip and data could be buffering up somewhere. So, whilst   */
  /* we must formally install the monitor as a null handler to catch    */
  /* the 'still buffering' case, we don't want a possibly large lag     */
  /* waiting for the null handler to eventually get called if it can be */
  /* avoided - thus the handler is called directly after it has been    */
  /* registered. It'll deregister itself immediately if it succeeds.    */

  if (i->monitoring == 0)
  {
    i->monitoring = 1;

    register_null_claimant(Wimp_ENull,
                           plugin_monitor_video,
                           i);
  }

  plugin_monitor_video(Wimp_ENull, NULL, NULL, (void *) i);

  /* ...and that's it; the monitor code and message handlers do the rest. */

  return;
}

/**************************************************************/
/* plugin_monitor_video()                                     */
/*                                                            */
/* Wait until we have a control handle and MPEGControl says   */
/* that the first frame of the video has been played; when it */
/* has, resize the plugin to fit it.                          */
/*                                                            */
/* If the "monitoring" flag of the plug-in instance structure */
/* is set then the routine assumes it was installed as a      */
/* NULL event handler and deregisters itself (when and only   */
/* when the MPEG system has reported that video is decoding). */
/* If this flag is clear the deregistration isn't done, so    */
/* it's possible to directly call this function as a one-off  */
/* if required.                                               */
/*                                                            */
/* Parameters as normal for a Wimp event handler, with the    */
/* handle pointing to the plugin_instance structure.          */
/**************************************************************/

static int plugin_monitor_video(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  plugin_instance * i = (plugin_instance *) handle;
  unsigned int      mh;
  unsigned int      ready;

  /* Extract the MPEG control handle */

  if (i->video_control_handle == 0)
  {
    return 0;
  }
  else
  {
    int opts[4];

    opts[0] = vc_tags_control_handle;
    opts[1] = 1;
    opts[2] = 0;
    opts[3] = vc_tags__end;

    if (
         _swix(VideoControl_Options,
               _INR(0,2),

               VC_Options_ReadValues,
               i->video_control_handle,
               opts)

         != NULL
       )
       return 0;

    mh = opts[2];
  }

  /* Read the decoding state */

  if (
       _swix(MPEGVideo_ReadParameters,
             _IN(0) | _OUT(1),

             5, /* 5 = "Check if display is ready" */

             &ready)

       != NULL
     )
     return 0;

  /* Has video decoded? */

  if (ready != 0)
  {
    unsigned int   w, h;
    unsigned int   statsin  [2];
    unsigned int   statsout [10];
    unsigned int * written;

    /* Yes - don't need this handler anymore, if it was installed as one */

    if (i->monitoring != 0)
    {
      i->monitoring = 0;

      deregister_null_claimant(Wimp_ENull,
                               plugin_monitor_video,
                               i);
    }

    /* Work out where to move to */

    statsin[0] = 0x1011; /* Active area information */
    statsin[1] = -1;

    if (
         _swix(MPEGControl_Stats,
               _INR(0,4) | _OUT(3),

               0,
               mh,
               statsin,
               statsout,
               sizeof(statsout),

               &written)

         != NULL

         || written     == 0
         || written     == statsout
         || statsout[1] == 0
       )
       return 0;

    /* The width / height to use depends on the HTML's PARAM settings... */

    if (i->fixed_width != 0)
    {
      /* Fixed width, so use our existing dimension. If the MPEG system had told us */
      /* to change width too, tough; the page author gets what the page author      */
      /* asked for. This may well mean the plug-in window is too narrow or tall,    */
      /* leading to a slight in-plug-in letterbox or vertical overscan effect.      */

      w = i->position.xmax - i->position.xmin;
      h = statsout[8] + i->border * 4;
    }
    else if (i->fixed_height != 0)
    {
      /* As before, with a fixed height the width just has to take its chances. If */
      /* scaling can't match exactly there'll be a pillarboxing or horizontal      */
      /* overscan effect.                                                          */

      w = statsout[7] + i->border * 4;
      h = i->position.ymax - i->position.ymin;
    }
    else
    {
      fixed fw, fh, da;

      /* If width or height are fixed, this is a start of playback only adjustment. */
      /* The MPEG system will make a best-fit guess to the size we requested. This  */
      /* will not necessarily be the right aspect ratio though - e.g. the page      */
      /* author's done a 4:3 shape plug-in but somebody later points it at a 16:9   */
      /* clip. Since the horizontal direction is the most flexible on STB 400       */
      /* hardware and in the absence of any other indicators, the height that the   */
      /* MPEG system says it can manage is taken and the width determined by        */
      /* applying the clip's aspect ratio to it. The pixel aspect ratio must be     */
      /* taken into account too.                                                    */

      if (
           _swix(ModeFiles_SafeArea,
                 _IN(0) | _OUT(4),

                 ModeFiles_SafeArea_MagicWord, /* See top of this file */

                 &da)

           != NULL
         )
         da = (fixed) 0x10000; /* 1:1 */

      h  = statsout[8];
      fh = (fixed) (h << 16u);

      fw = fixed_fixed_multiply(fh, (fixed) statsout[4]);
      fw = fixed_fixed_divide(fw, da);

      w  = ((unsigned int) fw + 32768) >> 16u;

      w += i->border * 4; /* 1 'web pixel' = 2 OS units, taken */
      h += i->border * 4; /* twice for left+right/top+bottom.  */
    }

    plugin_resize_window(i, w, h);
  }

  return 0;
}

/**************************************************************/
/* plugin_set_video_options()                                 */
/*                                                            */
/* After a starting-up player has set any options it wants,   */
/* it should call this if running on the basis of a plug-in.  */
/* Here, the options within that plug-in are examined and     */
/* conveyed to Video Control as appropriate.                  */
/*                                                            */
/* Parameters: Plug-in instance handle of item to examine;    */
/*                                                            */
/*             Video Control client ID to use.                */
/**************************************************************/

_kernel_oserror * plugin_set_video_options(unsigned int instance, unsigned int vc_id)
{
  plugin_instance * i;
  int               opt[31];
  int             * opts = opt;

  if (instance == 0) return NULL;
  i = plugin_find_instance(instance);
  if (i == NULL) return NULL;

  /* If the 'launcher' field is non-NULL the instance given was for a completely  */
  /* stand-alone item which was launched via. another item; the options we should */
  /* set are in that launcher item.                                               */

  if (i->launcher != 0)
  {
    plugin_instance * l = plugin_find_instance(i->launcher);

   /* If we can't find it, it's died! Maybe the browser crashed or something? */

    if (l != NULL) i           = l;
    else           i->launcher = 0; /* Clear the launcher reference since it's invalid */
  }

  /* Build the options block */

  *opts++ = vc_tags_volume;
  *opts++ = 1;
  *opts++ = i->volume;

  *opts++ = vc_tags_mp2program,
  *opts++ = 1;
  *opts++ = i->program;

  *opts++ = vc_tags_mp2audiostream;
  *opts++ = 1;
  *opts++ = i->aud_stream;

  *opts++ = vc_tags_mp2videostream;
  *opts++ = 1;
  *opts++ = i->vid_stream;

  *opts++ = vc_tags_demux;
  *opts++ = 1;

  switch (i->demux)
  {
    default:
    case 0: *opts++ = vc_demux_auto;  break;
    case 1: *opts++ = vc_demux_mpeg1; break;
    case 2: *opts++ = vc_demux_mpeg2; break;
  }

  *opts++ = vc_tags_looping;
  *opts++ = 1;
  *opts++ = i->loop;

  *opts++ = vc_tags_video_only;
  *opts++ = 1;
  *opts++ = i->no_audio;

  *opts++ = vc_tags_audio_only;
  *opts++ = 1;
  *opts++ = i->no_video;

  *opts++ = vc_tags_no_palette;
  *opts++ = 1;
  *opts++ = i->no_palette;

  *opts++ = vc_tags_ntsc;
  *opts++ = 1;
  *opts++ = i->ntsc;

  *opts++ = vc_tags__end;

  /* Exit through Video Control */

  return _swix(VideoControl_Options,
               _INR(0,2),

               0,
               vc_id,
               opt);
}

/**************************************************************/
/* plugin_get_video_options()                                 */
/*                                                            */
/* Return stored options for from and to positions for        */
/* playback.                                                  */
/*                                                            */
/* Parameters: Plug-in instance handle (passing zero is OK,   */
/*             you'll just get 'false' returned as described  */
/*             below);                                        */
/*                                                            */
/*             Pointer to an int to take "from";              */
/*                                                            */
/*             Pointer to an int to take "to".                */
/*                                                            */
/*             Pointer to a bool to take looping state -      */
/*             'true' if looping is on, else 'false'.         */
/*                                                            */
/* Returns:    Ints are updated with time in seconds for      */
/*             from/to. Negative values mean "unset", i.e.,   */
/*             beginning/end. The direct return value is      */
/*             true or false - if false, the plug-in          */
/*             instance handle given wasn't recognised and    */
/*             any pointers you passed will not have been     */
/*             written through.                               */
/*                                                            */
/* Assumes:    Any pointers passed may be NULL, but if not    */
/*             NULL must be valid.                            */
/**************************************************************/

bool plugin_get_video_options(unsigned int instance, int * from, int * to, bool * loop)
{
  plugin_instance * i;

  if (instance == 0) return false;
  i = plugin_find_instance(instance);
  if (i == NULL) return false;

  if (i->launcher != 0)
  {
    plugin_instance * l = plugin_find_instance(i->launcher);

   /* If we can't find it, it's died! Maybe the browser crashed or something? */

    if (l != NULL) i           = l;
    else           i->launcher = 0; /* Clear the launcher reference since it's invalid */
  }

  if (from != NULL) *from = i->from;
  if (to   != NULL) *to   = i->to;
  if (loop != NULL) *loop = i->loop == 0 ? false : true;

  return true;
}

/**************************************************************/
/* plugin_reread_all_windows()                                */
/*                                                            */
/* Read all plug-in window positions after a rectangle or     */
/* copy filter has been fired.                                */
/*                                                            */
/* This code may be called from filter_code in Filter.c and   */
/* thus has all the restrictions of that function too.        */
/**************************************************************/

_kernel_oserror * plugin_reread_all_windows(void)
{
  WimpGetWindowStateBlock   state;
  plugin_instance         * i = instances;
  int                       dx, dy;

  while (i)
  {
    state.window_handle = i->window_handle;
    RetError(wimp_get_window_state(&state));

    dx = state.visible_area.xmin - i->position.xmin;
    dy = state.visible_area.ymax - i->position.ymax;

    if (dx != 0 || dy != 0)
    {
      i->position = state.visible_area;
      plugin_move_video(i);
    }

    i = i->next;
  }

  return NULL;
}

/**************************************************************/
/* plugin_shutdown()                                          */
/*                                                            */
/* Closes down all plug-ins.                                  */
/**************************************************************/

void plugin_shutdown(void)
{
  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_shutdown: Called\n"));
  #endif

  while (instances != NULL)
  {
    plugin_delete_instance(instances);
  }

  /* Finished */

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_shutdown: Successful\n"));
  #endif

  return;
}
