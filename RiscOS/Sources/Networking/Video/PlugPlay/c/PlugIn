/**************************************************************/
/* File:    PlugIn.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Supporting the generic RISC OS plug-in interface. */
/*                                                            */
/*          Unusual allocation schemes may be used to replace */
/*          malloc here, so do NOT malloc a message block and */
/*          try to send it; you'll hit the Wimp bug regarding */
/*          message blocks at high addresses with older       */
/*          versions.                                         */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 05-Oct-1997 (ADH): Created.                       */
/*          05-Apr-2000 (ADH): 64-wide comments adopted.      */
/*          18-Apr-2000 (ADH): Imported into PlugPlay.        */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/event.h>
#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>

#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "Filter.h"
#include "FromROSLib.h"
#include "Global.h"
#include "MiscDefs.h"
#include "ModeInfo.h"
#include "RMA.h"
#include "Utils.h"

#include "PlugIn.h"

/* Local compile-time options */

#define Magic_PlugIn_Instance    0x47554C50 /* "PLUG" */
#define PlugIn_ParamsName_ID     "id"
#define PlugIn_ParamsName_Data   "data"
#define PlugIn_ParamsName_Border "border"

/* Local structures */

typedef struct plugin_file_entry
{
  struct plugin_file_entry * next;
  struct plugin_file_entry * prev;

  char                     * name;
  char                     * data;
  char                     * mime;
}
plugin_file_entry;

typedef struct plugin_instance
{
  unsigned int               magic;

  struct plugin_instance   * next;
  struct plugin_instance   * prev;

  plugin_file_entry        * entries;

  int                        browser_instance_handle;
  int                        plugin_instance_handle;
  int                        video_control_handle;

  unsigned int               parent_task_handle;
  unsigned int               parent_window_handle;
  ObjectId                   window_id;
  int                        window_handle;
  int                        border;
  BBox                       position;

  const char               * id;  /* These point into the plugin_file_entry structs, */
  const char               * url; /* so should not have free() called on them.       */

  unsigned                   redraw_handler :1;
  unsigned                   reopen_handler :1;
  unsigned                   filter_done    :1;
}
plugin_instance;

/* Local variables */

static plugin_instance * instances = NULL;

/* Local functions */

static plugin_instance * plugin_new_instance        (void);
static void              plugin_delete_instance     (int handle);
static plugin_instance * plugin_find_instance       (int handle);

static _kernel_oserror * plugin_new_file_entry      (plugin_instance * i);
static void              plugin_delete_file_entry   (plugin_instance * i, plugin_file_entry * en);
static void              plugin_delete_file_entries (plugin_instance * i);
static _kernel_oserror * plugin_read_params_file    (plugin_instance * i, const char * filename);

static int               plugin_redraw_window       (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);
static int               plugin_reopen_window       (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);

static _kernel_oserror * plugin_move_window         (plugin_instance * i);
static _kernel_oserror * plugin_move_video          (plugin_instance * i);

/**************************************************************/
/* plugin_new_instance()                                      */
/*                                                            */
/* Allocate space for a new plugin_instance struct. The item  */
/* is 0-initialised and essential fields filled in (e.g. the  */
/* magic word).                                               */
/*                                                            */
/* Returns:    Pointer to the new item, or NULL if out of     */
/*             memory.                                        */
/**************************************************************/

static plugin_instance * plugin_new_instance(void)
{
  #ifdef APPLICATION

    plugin_instance * new = calloc(1, sizeof(plugin_instance));

    if (new == NULL) return NULL;

  #else

    plugin_instance * new = NULL;

    rma_claim(NULL, sizeof(plugin_instance), (void **) &new);

    if (new == NULL) return NULL;
    else memset(new, '\0', sizeof(plugin_instance));

  #endif

  new->magic                  = Magic_PlugIn_Instance;
  new->window_id              = NULL_ObjectId;
  new->plugin_instance_handle = (int) new; /* At present, the instance handle is just a pointer to the structure */

  if (instances != NULL)
  {
    instances->prev = new;
    new->next       = instances;
  }

  instances = new;

  return new;
}

/**************************************************************/
/* plugin_delete_instance()                                   */
/*                                                            */
/* Delete a plugin_instance from the list along with any      */
/* items related to it (e.g. Toolbox objects).                */
/*                                                            */
/* Parameters: Instance handle for item to delete.            */
/**************************************************************/

static void plugin_delete_instance(int handle)
{
  plugin_instance * i = plugin_find_instance(handle);

  if (i == NULL) return;

  /* The 'id' and 'url' fields point into the file entries, so we */
  /* do NOT free these individually.                              */

  plugin_delete_file_entries(i);

  if (i->prev)        i->prev->next = i->next;
  if (i->next)        i->next->prev = i->prev;
  if (instances == i) instances     = i->next;

  if (i->filter_done    == 1) filter_remove_filter();
  if (i->redraw_handler == 1) event_deregister_wimp_handler(i->window_id, Wimp_ERedrawWindow, plugin_redraw_window, (void *) i->plugin_instance_handle);
  if (i->reopen_handler == 1) event_deregister_wimp_handler(i->window_id, Wimp_EOpenWindow,   plugin_reopen_window, (void *) i->plugin_instance_handle);

  if (i->window_id != NULL_ObjectId) toolbox_delete_object(0, i->window_id);

  #ifdef APPLICATION
    free(i);
  #else
    rma_release(NULL, (void *) i);
  #endif

  return;
}

/**************************************************************/
/* plugin_find_instance()                                     */
/*                                                            */
/* Given a plug-in instance handle, returns a pointer to the  */
/* related plugin_instance struct or NULL if the handle is    */
/* unknown / invalid.                                         */
/*                                                            */
/* Parameters: Plug-in instance handle.                       */
/*                                                            */
/* Returns:    Pointer to related plugin_instance struct or   */
/*             NULL if the handle is unknown.                 */
/**************************************************************/

static plugin_instance * plugin_find_instance(int handle)
{
  _kernel_oserror * e;
  plugin_instance * i;
  unsigned int      valid;

  /* The plug-in instance handle is the address off the plugin_instance */
  /* structure for the referenced instance. Validate the address and    */
  /* ensure that there's the magic word there before proceeding.        */

  i = (plugin_instance *) handle;

  e = _swix(OS_ValidateAddress,
            _INR(0,1) | _OUT(_FLAGS),

            i,
            i + 1,
            &valid);

  if (e || (valid & _C) || i->magic != Magic_PlugIn_Instance)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_find_instance: Handle &%08X is invalid\n", handle));
    #endif

    return NULL;
  }

  return i;
}

/**************************************************************/
/* plugin_new_file_entry()                                    */
/*                                                            */
/* Adds a plugin_file_entry to a given plugin_instance at the */
/* head of the list.                                          */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure to    */
/*             add to.                                        */
/**************************************************************/

static _kernel_oserror * plugin_new_file_entry(plugin_instance * i)
{
  #ifdef APPLICATION

    plugin_file_entry * new = calloc(1, sizeof(plugin_file_entry));

    if (new == NULL) return make_no_memory_error(0);

  #else

    plugin_file_entry * new = NULL;

    RetError(rma_claim(NULL, sizeof(plugin_file_entry), (void **) &new));
    memset(new, '\0', sizeof(plugin_file_entry));

  #endif

  if (i->entries != NULL)
  {
    i->entries->prev = new;
    new->next        = i->entries;
  }

  i->entries = new;

  return NULL;
}

/**************************************************************/
/* plugin_delete_file_entry()                                 */
/*                                                            */
/* Delete a given plugin_file_entry from a given              */
/* plugin_instance.                                           */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure to    */
/*             delete from;                                   */
/*                                                            */
/*             Pointer to the plugin_file_entry to delete.    */
/**************************************************************/

static void plugin_delete_file_entry(plugin_instance * i, plugin_file_entry * en)
{
  if (en->prev != NULL) en->prev->next = en->next;
  if (en->next != NULL) en->next->prev = en->prev;
  if (en == i->entries) i->entries     = en->next;

  #ifdef APPLICATION

    if (en->name != NULL) free(en->name);
    if (en->data != NULL) free(en->data);
    if (en->mime != NULL) free(en->mime);

    free(en);

  #else

    if (en->name != NULL) rma_release(NULL, (void *) en->name);
    if (en->data != NULL) rma_release(NULL, (void *) en->data);
    if (en->mime != NULL) rma_release(NULL, (void *) en->mime);

    rma_release(NULL, (void *) en);

  #endif


  return;
}

/**************************************************************/
/* plugin_delete_file_entries()                               */
/*                                                            */
/* Delete all plugin_file_entry structures from a given       */
/* plugin_instance.                                           */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure to    */
/*             delete from.                                   */
/**************************************************************/

static void plugin_delete_file_entries(plugin_instance * i)
{
  while (i->entries != NULL) plugin_delete_file_entry(i, i->entries);

  return;
}

/**************************************************************/
/* plugin_read_params_word()                                  */
/*                                                            */
/* Read an integer from a parameters file.                    */
/*                                                            */
/* Parameters: Pointer to FILE struct to read through;        */
/*                                                            */
/*             Pointer to int to update.                      */
/*                                                            */
/* Returns:    0 for success, EOF for an error.               */
/*                                                            */
/* Assumes:    Parameter pointers must be non-NULL and valid. */
/**************************************************************/

static int plugin_read_params_word(FILE * f, int * word)
{
  int i;
  int c;

  /* Despite assumption stated in comments above, this is not speed */
  /* critical in practice so paranoid code is worthwhile.           */

  if (word == NULL) return EOF;

  /* Read each byte, assembling the word */

  c = fgetc(f);
  if (c == EOF) return EOF;

  i = c & 0xff;

  c = fgetc(f);
  if (c == EOF) return EOF;

  i |= ((c & 0xff) << 8);

  c = fgetc(f);
  if (c == EOF) return EOF;

  i |= ((c & 0xff) << 16);

  c = fgetc(f);
  if (c == EOF) return EOF;

  i |= ((c & 0xff) << 24);

  /* Finished */

  *word = i;

  return 0;
}

/**************************************************************/
/* plugin_read_params_string()                                */
/*                                                            */
/* Read a name, mime type or data string from the parameters  */
/* file.                                                      */
/*                                                            */
/* Parameters: Pointer to a FILE struct to read through;      */
/*                                                            */
/*             Pointer to a char * updated to point to the    */
/*             string in a malloced block that the caller     */
/*             must free if APPLICATION is defined, or an     */
/*             rma_claim'd block that the caller must         */
/*             rma_release (with allocator=NULL) if           */
/*             APPLICATION is not defined.                    */
/*                                                            */
/* Returns:    0 for success, EOF for an error, and the char  */
/*             * updated to NULL if, specifically, out of     */
/*             memory.                                        */
/*                                                            */
/* Assumes:    Parameter pointers must be non-NULL and valid. */
/**************************************************************/

static int plugin_read_params_string(FILE * f, char ** string)
{
  int i, l;
  int c;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_read_params_string: Called\n"));
  #endif

  /* Read the string length and allocate a buffer */

  c = plugin_read_params_word(f, &i);

  if (c == EOF) return EOF;

  #ifdef APPLICATION

    *string = malloc(i + 1);

  #else

    *string = NULL;
    rma_claim(NULL, i + 1, (void **) string);

  #endif

  if (*string == NULL) return EOF;

  /* Read the string */

  for (l = 0; l < i; l++)
  {
    c = fgetc(f);
    if (c == EOF) return EOF;
    (*string)[l] = c;
  }

  (*string)[i] = '\0';

  /* Skip to word aligned point */

  while (ftell(f) % 4 != 0)
  {
    c = fgetc(f);
    if (c == EOF) return EOF;
  }

  /* Finished */

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_read_params_string: Successful, read '%s', ended up at %d\n", *string, (unsigned int) ftell(f)));
  #endif

  return 0;
}

/**************************************************************/
/* plugin_read_params_file()                                  */
/*                                                            */
/* Read a parameters file. The 'url' and 'id' fields of the   */
/* given plugin_instance structure may be updated on exit to  */
/* point into appropriate strings within the file structures. */
/*                                                            */
/* Parameters: Pointer to the plugin_instance structure       */
/*             relevant to the file;                          */
/*                                                            */
/*             Pointer to the filename, NUL terminated.       */
/**************************************************************/

static _kernel_oserror * plugin_read_params_file(plugin_instance * i, const char * filename)
{
  _kernel_oserror * e = NULL;
  FILE            * f = fopen(filename, "rb");
  int               c = 0;
  int               word;

  if (f == NULL)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("CannotOpen:Cannot open parameters file",
                          0,0));

    return &erb;
  }

  for (;;)
  {
    /* Read the entry type */

    c = plugin_read_params_word(f, &word);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    if (word == PlugIn_ParamType_Terminator) break;

    /* Read the record size - we don't actually care about this */

    c = plugin_read_params_word(f, &word);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    /* Allocate a new entry structure */

    e = plugin_new_file_entry(i);
    if (e != NULL) goto plugin_read_params_file_exit_with_error;

    /* Read the name, data and mime type */

    c = plugin_read_params_string(f, &i->entries->name);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    c = plugin_read_params_string(f, &i->entries->data);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    c = plugin_read_params_string(f, &i->entries->mime);
    if (c == EOF) goto plugin_read_params_file_exit_with_error;

    /* If we get the ID or DATA entries, store a direct pointer to them */
    /* within the instance structure for faster access later.           */

    if (i->entries->name != NULL)
    {
      if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_ID))   i->id  = i->entries->data;
      if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Data)) i->url = i->entries->data;

      /* If we get the border, fill it in too */

      if (!utils_strcasecmp(i->entries->name, PlugIn_ParamsName_Border)) i->border = atoi(i->entries->data);
    }
  }

  /* Normal mode exit */

  fclose(f);
  return NULL;

  /* Error mode exit */

plugin_read_params_file_exit_with_error:

  if (f != NULL) fclose(f);
  plugin_delete_file_entries(i);

  if (e == NULL)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("CannotRead:Cannot understand parameters file",
                          0,0));

    return &erb;
  }
  else return e;
}

/**************************************************************/
/* plugin_return_string()                                     */
/*                                                            */
/* Takes a message block and string_value from within it, and */
/* returns the string it points to.                           */
/*                                                            */
/* Parameters: Pointer to a WimpMessage struct holding the    */
/*             string_value field;                            */
/*                                                            */
/*             Pointer to the string_value field inside that  */
/*             message.                                       */
/*                                                            */
/* Returns:    Pointer to the string the string_value         */
/*             references, or NULL if the value seems         */
/*             invalid.                                       */
/**************************************************************/

const char * plugin_return_string(WimpMessage * m, string_value * sv)
{
  int offset = ((char *) sv) - ((char *) m);

  if (!m || !sv || !sv->offset) return NULL;

  /* Is the offset of the string_value field within the message */
  /* block out of range (i.e. the string_value does not appear  */
  /* to lie in the given message block)?                        */

  if (offset >= m->hdr.size || offset < sizeof(m->hdr)) return NULL;

  /* Now read the string_value field itself */

  if (sv->offset < 256)
  {
    if (sizeof(m->hdr) + offset >= m->hdr.size) return NULL;

    else return (const char *) (((char *) m) + sizeof(m->hdr) + sv->offset);
  }
  else return (const char *) sv->offset;
}

/**************************************************************/
/* plugin_got_open()                                          */
/*                                                            */
/* Handle reception of a Message_PlugIn_Open.                 */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_open(WimpMessage * m)
{
  _kernel_oserror         * e;
  WimpGetWindowStateBlock   state;
  WimpMessage               response;
  ObjectId                  new;
  int                       plugin_instance_handle;
  plugin_instance         * i;
  MPlugIn_Open            * open    = (MPlugIn_Open    *) &m->data;
  MPlugIn_Opening         * opening = (MPlugIn_Opening *) &response.data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_open: Called\n"));
  #endif

  i = plugin_new_instance();

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_open: Out of memory\n"));
    #endif

    return make_no_memory_error(0);
  }

  /* Currently, instance handles just point back to the plugin_instance structure */

  plugin_instance_handle = (int) i;
  i->parent_task_handle  = m->hdr.sender;

  /* Read the parameters file */

  e = plugin_read_params_file(i, plugin_return_string(m, &open->file_name));

  if (e == NULL)
  {
    /* Create the video window. If this works, register our redraw handler. */

    e = toolbox_create_object(0,
                              "Video",
                              &new);
  }

  if (e == NULL)
  {
    e = event_register_wimp_handler(new,
                                    Wimp_ERedrawWindow,
                                    plugin_redraw_window,
                                    (void *) plugin_instance_handle);
  }

  /* Flag this was successful register our OpenWindow event filter */

  if (e == NULL)
  {
    i->redraw_handler = 1;

    e = filter_add_filter();
  }

  /* Now other general bits of information */

  if (e == NULL)
  {
    i->filter_done = 1;

    i->browser_instance_handle = open->browser_instance_handle;
    i->parent_window_handle    = open->parent_window_handle;
    i->window_id               = new;

    e = window_get_wimp_handle(0, new, &i->window_handle);
  }

  if (e == NULL)
  {
    state.window_handle = open->parent_window_handle;
    e = wimp_get_window_state(&state);
  }

  if (e != NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_open: General error - '%s'\n", e->errmess));
    #endif

    plugin_delete_instance(i->plugin_instance_handle);
    return e;
  }

  i->position = open->parent_area;
  coords_box_toscreen(&i->position, (WimpRedrawWindowBlock *) &state);

  e = plugin_move_window(i);

  if (e != NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_open: Error from plugin_move_window - '%s'\n", e->errmess));
    #endif

    plugin_delete_instance(i->plugin_instance_handle);
    return e;
  }

  /* Respond with Message_PlugIn_Opening */

  response.hdr.size                = sizeof(MPlugIn_Opening);
  response.hdr.your_ref            = m->hdr.my_ref;
  response.hdr.action_code         = Message_PlugIn_Opening;

  opening->flags                   = MPlugIn_Opening_ActionBeyondStop;
  opening->browser_instance_handle = i->browser_instance_handle;
  opening->plugin_instance_handle  = plugin_instance_handle;
  opening->parent_window_handle    = i->parent_window_handle;
  opening->parent_area             = i->position;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_open: Exitting through wimp_send_message, sending handle %p\n", i));
  #endif

  return wimp_send_message(Wimp_EUserMessage,
                           &response,
                           m->hdr.sender,
                           0,
                           NULL);
}

/**************************************************************/
/* plugin_got_close()                                         */
/*                                                            */
/* Handle reception of a Message_PlugIn_Close.                */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_close(WimpMessage * m)
{
  WimpMessage       response;
  plugin_instance * i;
  MPlugIn_Close   * close  = (MPlugIn_Close  *) &m->data;
  MPlugIn_Closed  * closed = (MPlugIn_Closed *) &response.data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_close: Called\n"));
  #endif

  /* Validate the plug-in instance handle */

  i = plugin_find_instance(close->plugin_instance_handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_close: Instance handle &%08X invalid\n", close->plugin_instance_handle));
    #endif

    return NULL;
  }

  /* The handle is good */

  plugin_delete_instance(close->plugin_instance_handle);

  /* Respond with Message_PlugIn_Closed */

  response.hdr.size               = sizeof(MPlugIn_Closed);
  response.hdr.your_ref           = m->hdr.my_ref;
  response.hdr.action_code        = Message_PlugIn_Closed;

  closed->flags                   = 0;
  closed->browser_instance_handle = i->browser_instance_handle;
  closed->plugin_instance_handle  = i->plugin_instance_handle;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_close: Exitting through wimp_send_message\n"));
  #endif

  return wimp_send_message(Wimp_EUserMessage,
                           &response,
                           m->hdr.sender,
                           0,
                           NULL);
}

/**************************************************************/
/* plugin_got_reshape()                                       */
/*                                                            */
/* Handle reception of a Message_PlugIn_Reshape.              */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_reshape(WimpMessage * m)
{
  WimpGetWindowStateBlock   state;
  plugin_instance         * i;
  MPlugIn_Reshape         * reshape = (MPlugIn_Reshape *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_reshape: Called for %p\n", (plugin_instance *) reshape->plugin_instance_handle));
  #endif

  /* Validate the plug-in instance handle */

  i = plugin_find_instance(reshape->plugin_instance_handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_reshape: Instance handle &%08X invalid\n", reshape->plugin_instance_handle));
    #endif

    return NULL;
  }

  /* The handle is good */

  state.window_handle = reshape->parent_window_handle;
  RetError(wimp_get_window_state(&state));

  i->position = reshape->parent_area;

  coords_box_toscreen(&i->position, (WimpRedrawWindowBlock *) &state);

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_reshape: Exitting through plugin_move_window with %d, %d, %d, %d\n", i->position.xmin, i->position.ymin, i->position.xmax, i->position.ymax));
  #endif

  return plugin_move_window(i);
}

/**************************************************************/
/* plugin_got_action()                                        */
/*                                                            */
/* Handle reception of a Message_PlugIn_Action.               */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_action(WimpMessage * m)
{
  MPlugIn_Action * action = (MPlugIn_Action *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_action: Called\n"));
  #endif

  (void) action;

  return NULL;
}

/**************************************************************/
/* plugin_got_abort()                                         */
/*                                                            */
/* Handle reception of a Message_PlugIn_Abort.                */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_abort(WimpMessage * m)
{
  MPlugIn_Abort * abort = (MPlugIn_Abort *) &m->data;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_abort: Called\n"));
  #endif

  (void) abort;

  return NULL;
}

/**************************************************************/
/* plugin_got_inform()                                        */
/*                                                            */
/* Handle reception of a Message_PlugIn_Inform.               */
/*                                                            */
/* Parameters: Pointer to a Wimp_Message struct relevant to   */
/*             the message.                                   */
/**************************************************************/

_kernel_oserror * plugin_got_inform(WimpMessage * m)
{
  plugin_instance * i;
  MPlugIn_Inform  * inform = (MPlugIn_Inform *) &m->data;
  char              id [sizeof(inform->name) + 1];

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Called\n"));
  #endif

  if (inform->info_id == MPlugIn_Inform_InfoID_VideoControlHandle)
  {
    strncpy(id, inform->name, sizeof(id) - 1);
    id[sizeof(id) - 1] = '\0';

    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Supported inform received for '%s', handle %08X\n",
                                  id,
                                  inform->info.video_control_handle));
    #endif

    i = instances;

    while (i)
    {
      if (!strcmp(i->id, id)) break;
      i = i->next;
    }

    if (i != NULL)
    {
      #ifdef TRACE
        if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Assigning handle to instance %p\n", i));
      #endif

      i->video_control_handle = inform->info.video_control_handle;

      /* Ensure the video position is up to date */

      RetError(plugin_move_video(i));
    }
  }

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_got_inform: Successful\n"));
  #endif

  return NULL;
}

/**************************************************************/
/* plugin_redraw_window()                                     */
/*                                                            */
/* Handle Redraw requests for a plug-in window from the Wimp. */
/*                                                            */
/* Parameters are as standard for a Wimp event handler with   */
/* 'handle' set to the instance handle related to the window. */
/**************************************************************/

static int plugin_redraw_window(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  WimpRedrawWindowBlock   r;
  int                     more;
  plugin_instance       * i;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_redraw_window: Called\n"));
  #endif

  i = plugin_find_instance((int) handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_redraw_window: Instance handle &%08X invalid\n", (int) handle));
    #endif

    return NULL;
  }

  r.window_handle = ((WimpRedrawWindowRequestEvent *) b)->window_handle;
  ChkError(wimp_redraw_window(&r, &more));

  if (more)
  {
    unsigned int trans = modeinfo_return_transparent_gcol();

    do
    {
      _swix(OS_SetColour,
            _INR(0,1),

            1u<<4,
            trans);

      bbc_vdu(BBC_ClearGraph);

      /* Alternatively, but possibly slower and certainly bigger code:
       *
       * bbc_rectanglefill(r.redraw_area.xmin,
       *                   r.redraw_area.ymin,
       *                   r.redraw_area.xmax - r.redraw_area.xmin - 1,
       *                   r.redraw_area.ymax - r.redraw_area.ymin - 1);
       */

      ChkError(wimp_get_rectangle(&r, &more));

    }
    while (more);
  }

  return 1;
}

/**************************************************************/
/* plugin_reopen_window()                                     */
/*                                                            */
/* Handle Open requests for a plug-in window from the Wimp.   */
/*                                                            */
/* Parameters are as standard for a Wimp event handler with   */
/* 'handle' set to the instance handle related to the window. */
/**************************************************************/

static int plugin_reopen_window(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  plugin_instance * i;

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_reopen_window: Called\n"));
  #endif

  i = plugin_find_instance((int) handle);

  if (i == NULL)
  {
    #ifdef TRACE
      if (tl & (1u<<30)) dprintf(("", "plugin_reopen_window: Instance handle &%08X invalid\n", (int) handle));
    #endif

    return NULL;
  }

  return 1;
}

/**************************************************************/
/* plugin_move_window()                                       */
/*                                                            */
/* Move a plug-in window to the location currenly specified   */
/* by the "position" BBox and parent window handle in the     */
/* given plugin_instance structure.                           */
/*                                                            */
/* Parameters: Pointer to a plugin_instance struct relevant   */
/*             to the plug-in window to move.                 */
/**************************************************************/

static _kernel_oserror * plugin_move_window(plugin_instance * i)
{
  WindowShowObjectBlock show;

  /* Construct the Show block */

  show.visible_area         = i->position;
  show.xscroll              = 0;
  show.yscroll              = 0;
  show.behind               = -1;

  show.window_flags         = 0;
  show.parent_window_handle = i->parent_window_handle;
  show.alignment_flags      = 0;

  RetError(toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
                               i->window_id,
                               Toolbox_ShowObject_FullSpec,
                               &show,
                               NULL_ObjectId,
                               NULL_ComponentId));

  return plugin_move_video(i);
}

/**************************************************************/
/* plugin_move_video()                                        */
/*                                                            */
/* Move video playback to the location derived from the given */
/* plugin_instance structure. Usually called from             */
/* plugin_move_window.                                        */
/*                                                            */
/* This code may be called from filter_code in Filter.c and   */
/* thus has all the restrictions of that function too.        */
/*                                                            */
/* Parameters: Pointer to a plugin_instance struct relevant   */
/*             to the video to move.                          */
/**************************************************************/

static _kernel_oserror * plugin_move_video(plugin_instance * i)
{
  /* Can't proceed unless we have a Video Control handle */

  if (i->video_control_handle != 0)
  {
    int opts[7];

    opts[0] = vc_tags_rectangle;
    opts[1] = 4;
    opts[4] = i->position.xmax - i->position.xmin;
    opts[5] = i->position.ymax - i->position.ymin;
    opts[2] = i->position.xmin + opts[4] / 2;
    opts[3] = i->position.ymin + opts[5] / 2;

    opts[4] -= i->border * 4;
    opts[5] -= i->border * 4;

    opts[6] = vc_tags__end;

    _swix(VideoControl_Options,
          _INR(0,2),

          0,
          i->video_control_handle,
          &opts);
  }

  return NULL;
}

/**************************************************************/
/* plugin_reread_all_windows()                                */
/*                                                            */
/* Read all plug-in window positions after a rectangle or     */
/* copy filter has been fired.                                */
/*                                                            */
/* This code may be called from filter_code in Filter.c and   */
/* thus has all the restrictions of that function too.        */
/**************************************************************/

_kernel_oserror * plugin_reread_all_windows(void)
{
  WimpGetWindowStateBlock   state;
  plugin_instance         * i = instances;
  int                       dx, dy;

  while (i)
  {
    state.window_handle = i->window_handle;
    RetError(wimp_get_window_state(&state));

    dx = state.visible_area.xmin - i->position.xmin;
    dy = state.visible_area.ymax - i->position.ymax;

    if (dx != 0 || dy != 0)
    {
      i->position = state.visible_area;
      plugin_move_video(i);
    }

    i = i->next;
  }

  return NULL;
}

/**************************************************************/
/* plugin_shutdown()                                          */
/*                                                            */
/* Closes down all plug-ins.                                  */
/**************************************************************/

void plugin_shutdown(void)
{
  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_shutdown: Called\n"));
  #endif

  while (instances != NULL)
  {
    plugin_delete_instance(instances->plugin_instance_handle);
  }

  /* Finished */

  #ifdef TRACE
    if (tl & (1u<<30)) dprintf(("", "plugin_shutdown: Successful\n"));
  #endif

  return;
}
