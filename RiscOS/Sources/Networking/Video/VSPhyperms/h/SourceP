/**************************************
 SourceP.h

Private declarations for the Source class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
07/09/98  SNB     File created

**************************************/

#ifndef _SourceP_H_
#define _SourceP_H_

#include "source.h"

// This constant defines how long we are willing to wait (in centiseconds) for
// an incomplete block to receive more data from the server.  It is used to
// control how much time must expire after reception of a datagram for a given
// block before the datagram is considered "lost" and must be re-requested from
// the server
static const int max_datagram_latency = 50;

// this constant defines the maximum number of datagrams that can be read in one
// sitting without stealing too much processor time.

static const int max_datagram_read = 100;

// This constant defines the extra latency allowed after a NAK has been sent
static const int max_datagram_resent_latency = 100;

// This is an invalid block number.  It must be zero, as the getBlock method
// won't be able to find the very first block in a stream.
static const ULONG invalid_block_marker = 0UL;

// Magic word.  This magic word is used to mark MemBlock structures such that the
// conversions to and from MemBlock and NECBlock can be validated.
static const unsigned long MemBlock__GuardWord ('b'|('C'<<8)|('E'<<16)|('N'<<24));


// class DatagramBitfield;
//
// This is the quick lookup to check the Datagram buffer availability
//
// This class implements an array of bits determining the availability of
// datagram buffers.  It is similar in functionality to the standard
// fd_set type and its macros FD_SET, FD_CLR, FD_ISSET and FD_ZERO,
// but does not rely on macros and the maximum size is determined at
// object construction time.
//
// Type bitfield is private to DatagramBitfield.  This type needs to
// remain an unsigned type.  Implementation here is fully portable provided
// sizeof(bitfield) is an exact power of two.
//
class DatagramBitfield : public Error {
        private:
                typedef unsigned long bitfield;         // private type

        private:
                size_t max_dgram;                       // Upper limit ("FD_SETSIZE")
                size_t max_words;                       // Number of words allocated
                bitfield *b;                            // Bitfield array                
                int alloc, free;

                void clear();                           // Clear array ("FD_ZERO")
                size_t word_no(size_t n) const;         // For datagram n, return word offset
                size_t bit_mask(size_t n) const;        // For datagram n, return bit number

        public:
                // Public constructor.  Must supply maximum limit to allow construction to work
                DatagramBitfield(size_t max_dgram);
                // Public destructor to release bitfield array
                ~DatagramBitfield();
                // NO public copy constructors - this class may not be copied.

                // Is the class fully initialised?
                int ok() const;
                // is a particularly datagram descriptor free?  ("!FD_ISSET")
                int isFree(size_t) const;
                // allocate a datagram buffer and return its index
                int allocate(size_t *n);
                // allocate a specific datagram buffer ("FD_SET")
                int allocate(size_t n);
                // deallocate a datagram buffer ("FD_CLR")
                int deallocate(size_t n);
#ifdef DEBUG               
                // dumps debug information
                int Dump(void);
#endif                

        private:
                // Private copy constructor - not to be implemented.
                // By not defining this, attempts to copy will be faulted
                // by the linker.
                DatagramBitfield(const DatagramBitfield &);
};

// The internal data structure which holds the administrative details
// associated with an NECBlock.
struct MemBlock {
        int             inuse:1;
        int             completed:1;
        int             pending_ack:1;
        int             pending_nak:1;
        int		to_be_freed:1;
        int             _unused_[CHAR_BIT * sizeof(int) - 3 /*number of previous fields*/];

        ULONG           block_id;       // == NECDatagram.block_number == NECBlock.block_number
        size_t          block_total;    // == size of block to arrive
        size_t          sum_so_far;     // == cumulative size of block
        size_t		dgrams_received;// == cumulative total of datagrams AR
        size_t		dgrams_nakd;	// == cumulative total of nakd datagrams AR
        size_t          dgrams_in_block;// == number of datagrams in block
        unsigned int    last_nak;   // Time last datagram arrived - used for NAK generation
        // The following two fields must always live at the end of the MemBlock structure
        unsigned long   guard_word;
        NECBlock        nec_block;
};

#endif
