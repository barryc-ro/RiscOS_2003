/**************************************
 Source.h

describes standard Server class for mass data transfer.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
25/8/98    AR      File created

**************************************/

#ifndef _Source_H_
#define _Source_H_

#include <stddef.h>
#include "Error.h"
#include "ServCtrl.h"
#include "vspSocket.h"

class Source;
#include "NECstruct.h"

#ifdef DEBUGLIB
//#define MEM_SANE_CHECK	// this will dump the layout of the dynamic area it will also do
				// checks on locations of allocated datagrams etc.  this will ensure
				// that memory maps as it should
#endif

class Statistics {
  public:
  	int dgrams_read;
  	int duplicate_dgrams;
  	int acks_sent;
  	int naks_sent;
  	int block_naks_sent;
  	int bytes_received;
  
  	Statistics(void);
  	~Statistics(void) {}
  
  	void print();
};

#define NAK_timeout 50

// NECBlock data structure.
typedef struct {
    size_t       iov_size;   // s/g array size
    struct iovec iov[1];     // s/g array - must be last in structure
} NECBlock;

// Payload data is opaque to us
typedef void *NECPayload;	// this is the datagram

// This macro returns the size of an NECBlock structure with iov_size
// entries in the s/g array.
#define sizeof_NECBlock(iov_size) \
	(offsetof(NECBlock, iov) + sizeof(struct iovec) * (iov_size))

// The following structures are private to c++.Source defined in SourceP and are used in the 
// memmap class as such invisible to outside classes.

typedef struct MemBlock MemBlock;
typedef struct DynamicAreaHeader DynamicAreaHeader;
class DatagramBitfield;

// ---------------------------------------------------------- Source Memory map ------------------
// this class controls the dynamic area used by the source class
//
class SourceMemMap : public Error
{
  //friend Source;	// Originally these two classes were one however due to the complexity of supporting two
  			// concepts within one class I believe it better to seperate it into the memory management
  			// and the block management as such the source class consults the source memory map for
  			// memory allocation and destruction.  I is ideal if we can get rid of the friend clause.
  
  private:
	size_t max_block_size;		// maximum size of each block
	size_t total_dgrams;		// total dgram buffers for object

	DatagramBitfield *dgram_use;	// Quick lookup bitfields

	// Dynamic area information
	int    da_number;		// dynamic area number
	void  *da_base;			// base address in memory
        size_t total_memory;		// Total size of dynamic area

        // Quick lookup pointers
        MemBlock 	*block_hd;     	// Memory block header buffer start
        NECDatagram 	*dgram_hd;  	// Datagram header buffer start
        NECPayload 	*dgram_data_hd; // Datagram payload buffer start
        
   public: // these are made public for reasons of speed of reading
	size_t dgrams_per_block;	// max dgrams making up one block size of iov vector
        size_t max_blocks;		// Number of blocks to be able to hold
	size_t dgram_size;		// UDP datagram payload size

   private:		// constructive
	error_flag 	initLimits(void);
	error_flag 	createDynamicArea(void);
	error_flag 	initDynamicArea(void);

   			// validation and assignment
	error_flag 	validateNECBlock(const NECBlock *);			// checks the signiture
	error_flag 	validateMemBlock(const MemBlock *);			// checks the signiture
        
        		// methodic
	error_flag 	memFreeDatagram(size_t);
			
			// locational
	NECPayload 	*findPayloadBuffer(size_t n) const;
	size_t 		findDatagramNumber(NECDatagram *dgram) const;
	size_t 		findDatagramNumber(NECPayload *dgram) const;
	
  public:
  	// block location
	MemBlock 	*findExistingBlock(ULONG id, size_t *block_num = 0);	// finds a block based on an allocated block id, null on error
	MemBlock 	*findBlock(ULONG id, size_t *block_num = 0);		// finds a block, if it cannot find it allocate it, null on erro	
	MemBlock 	*getBlock(size_t n) const;		// returns a block addressed by its array offset in the dynamic area 

	// validation
 	error_flag 	memMemBlockToNECBlock(const MemBlock *block, NECBlock **nec_block);
        error_flag 	memNECBlockToMemBlock(const NECBlock *block, MemBlock **mem_block);
         
        // datagram location
        error_flag 	freeBlock_background(MemBlock *mb);			// free block when called from user mode, ie not re-entered

	NECPayload 	*findPayloadBuffer(NECDatagram *dgram) const;
        error_flag	memFindFreeDatagramBuffer(NECDatagram **datagram);	// returns a free datagram header, indicating a free area
	error_flag 	memFreeDatagram(const NECDatagram *);

  	// dynamic area renumbering
  	void	setDaNumber(int new_id) { da_number = new_id; }
  	int 	getDaNumber(void)	{ return da_number; }
  	
  	SourceMemMap(size_t blocks, size_t max_block_size, size_t datagram_size);
  	~SourceMemMap();
};
// ---------------------------------------------------------- Source Class ------------------
// this class maintains a three way relationship.  Between the stream through the stream owning it
// through the socket as it owning it and the memory map, an intermate relationship where the source
// will request memory etc.
//

class Source : public Error
{
  private:
	// Stream related data
	ULONG last_block_sent;		// ID of the last block returned to caller
	//ULONG max_block_received;	// ID of HWM used block in stream
	ULONG max_completed_block;	// ID of the greatest completed block in source.
	ULONG nak_block;
	
	int current_play_id;		// this is the trickplay flag this changes with each new trickplay
	ULONG stream_end_block;		// this is set when we know what the last block in the stream is
	
	// Network information
	Socket 		sd;
	
	SourceMemMap	*mem_map;	// if this is not allocated it is assigned to null
     					// if it is null and any method attempts to use it it will result in an error
     //public:
	int full_blocks;
	
      private:	// object manipulation
	
	error_flag calculateMaxCompleteBlock(void);
	error_flag calculatePosAckSequence(Server *server, Statistics *stats);
	//error_flag calculatePosNAKSequence(int *naks_sent, Server *server, int max_block);
	error_flag calculatePosNAKSequence(Server *server, Statistics *stats, int *naks = NULL);

      public:	// object creation destruction
        Source(void);
        ~Source(void);
        error_flag Allocate(size_t max_blocks, size_t max_block_size, size_t initial_block_num, size_t datagram_size);

        	// processor entry points
        error_flag calculate_freeBlocks(Server *server, callback_flag callback_pending, Statistics *stats);
        error_flag foregroundExecute(callback_flag *callback_flags, Server *server, Statistics *stats);
	error_flag serviceDynamicAreaRenumber(int old_id, int new_id);
	
        error_flag ReadDatagrams(callback_flag current_flags, callback_flag *flags, Server *server, Statistics *stats);	// reads off the socket

		// block manipulation
	ULONG 	   getAckSeq(void) { return max_completed_block; }
	int	   getCurrentPlayId() {return current_play_id; }
  	error_flag getMiscInfo(int flags);
  	
  	int	   getFullBlocks(void)			{ return full_blocks; }
  	void	   setEndPlayState(void);
  	error_flag setNewPlayState(int *play_state, int *request_num, int *max_complete);
        error_flag getBlockStatus(size_t *num_blocks, size_t *max_blocks, size_t *num_free);
        
        void	   clearFinalBlock(void)		{ stream_end_block = 0; }
	void 	   setFinalBlock(ULONG final_block) 	{ stream_end_block = final_block; }
	int  	   getFinalBlock(void) 			{ return (int)stream_end_block; }
	
        error_flag getBlock(NECBlock **block);		// give block to stream object
        error_flag freeBlock(const NECBlock *block);	// flag block as returned under interrupt
		
      		// socket manipulation 
        error_flag setServerDetails(const char *hostname, int port);
        error_flag setServerDetails(const char *hostname, const char *port);
        error_flag setServerDetails(struct in_addr address, int port);
        error_flag getLocalPort(int *port);
	error_flag getSocket(Socket *);
        error_flag setSocketError(int socket_result);
};

#endif
