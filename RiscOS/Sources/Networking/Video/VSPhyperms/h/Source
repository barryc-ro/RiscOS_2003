/**************************************
 Source.h

describes standard Server class for mass data transfer.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
25/8/98    AR      File created

**************************************/

#ifndef _Source_H_
#define _Source_H_

#include <stddef.h>
#include "Error.h"
#include "ServCtrl.h"
#include "vspSocket.h"

class Source;
#include "NECstruct.h"

#ifdef DEBUGLIB
//#define MEM_SANE_CHECK	// this will dump the layout of the dynamic area it will also do
				// checks on locations of allocated datagrams etc.  this will ensure
				// that memory maps as it should
class Statistics : public Error {	// for debug
#else
class Statistics {
#endif
  public:
  	ULINT last_stream_bytes_received;
  	ULINT last_stream_time;
  	ULINT last_stream_acks;
  	ULINT last_stream_naks;
  	
  	ULINT dgrams_read;
  	ULINT duplicate_dgrams;
  	ULINT bytes_received;
  	ULINT acks_sent;
  	ULINT naks_sent;
  	ULINT block_naks_sent;
  	ULINT deleted_blocks;
  
  	Statistics(void);
  	~Statistics(void) {}
  
  	void print();
#ifdef DEBUGLIB
	void DebugPrint();	// print to debug
#endif  	
};

typedef struct {
  size_t	max_buffers;	// this gives an outside on the array
  size_t	num_buffers;	// this is the number of buffers used after optimisation
  BitstreamBufferDescriptor buffers[1];	// see vsp_types header
} NECBlock;

// Payload data is opaque to us
typedef void *NECPayload;	// this is the datagram

// This macro returns the size of an NECBlock structure with iov_size
// entries in the s/g array.
#define sizeof_NECBlock(size) \
	(offsetof(NECBlock, buffers) + sizeof(BitstreamBufferDescriptor) * (size))

// The following structures are private to c++.Source defined in SourceP and are used in the 
// memmap class as such invisible to outside classes.

typedef struct MemBlock MemBlock;
typedef struct DynamicAreaHeader DynamicAreaHeader;
class DatagramBitfield;

// ---------------------------------------------------------- Source Memory map ------------------
// this class controls the dynamic area used by the source class
//
class SourceMemMap : public Error
{ 
  private:
	size_t max_block_size;		// maximum size of each block
	size_t total_dgrams;		// total dgram buffers for object

	DatagramBitfield *dgram_use;	// Quick lookup bitfields

	// Dynamic area information
	size_t  da_number;		// dynamic area number
	void   *da_base;		// base address in memory
        size_t total_memory;		// Total size of dynamic area

        // memory area pointers
        MemBlock 	*block_hd;     	// Memory block header buffer start
        NECDatagram 	*dgram_hd;  	// Datagram header buffer start
        NECPayload 	*dgram_data_hd; // Datagram payload buffer start
        
        // initialised once information
	size_t dgrams_per_block;	// max dgrams making up one block size of iov vector
        size_t max_blocks;		// Number of blocks to be able to hold
	size_t dgram_size;		// UDP datagram payload size

   private:		// constructive
	error_flag 	initLimits(void);
	error_flag 	createDynamicArea(void);
	error_flag 	initDynamicArea(void);

   			// validation and assignment
	error_flag 	validateNECBlock(const NECBlock *);			// checks the signiture
	error_flag 	validateMemBlock(const MemBlock *);			// checks the signiture
        
        		// methodic
	error_flag 	memFreeDatagram(size_t);
			
			// locational
	NECPayload 	*findPayloadBuffer(size_t n) const;
	size_t 		findDatagramNumber(NECDatagram *dgram) const;
	size_t 		findDatagramNumber(NECPayload *dgram) const;
	
  public:
  	// access to variables
	inline size_t dgramsPerBlock()	{ return dgrams_per_block; }	// max dgrams making up one block size of iov vector
        inline size_t maxBlocks()	{ return max_blocks; }		// Number of blocks to be able to hold
	inline size_t dgramSize()	{ return dgram_size; }		// UDP datagram payload size

  	// block reinitialisation
  	error_flag	blockReset(void);				// this sets all blocks to empty
  	
  	// block location allocation					// finds a block, if it cannot find it allocate it, replace least	
	MemBlock 	*findOrReplaceBlock(ULONG id, ULONG *last_block_sent, ULONG *max_complete);	
	MemBlock 	*findExistingBlock(ULONG id, size_t *block_num = 0);	// finds a block based on an allocated block id, null on error
	MemBlock 	*findBlock(ULONG id, size_t *block_num = 0);		// finds a block, if it cannot find it allocate it, null on erro	
	MemBlock 	*getBlock(size_t n) const;				// returns a block addressed by its array offset in the dynamic area 

	// validation
 	error_flag 	memMemBlockToNECBlock(const MemBlock *block, NECBlock **nec_block);
        error_flag 	memNECBlockToMemBlock(const NECBlock *block, MemBlock **mem_block);
         
        // datagram location
        error_flag 	freeBlock_background(MemBlock *mb);			// free block when called from user mode, ie not re-entered

	NECPayload 	*findPayloadBuffer(NECDatagram *dgram) const;
        error_flag	memFindFreeDatagramBuffer(NECDatagram **datagram);	// returns a free datagram header, indicating a free area
	error_flag 	memFreeDatagram(const NECDatagram *);

  	// dynamic area renumbering
  	inline void	setDaNumber(int new_id) { da_number = new_id; }
  	inline size_t 	getDaNumber(void)	{ return da_number; }
  	
  	SourceMemMap(size_t blocks, size_t max_block_size, size_t datagram_size);
  	~SourceMemMap();
};
// ---------------------------------------------------------- Source Class ------------------
// this class maintains a three way relationship.  Between the stream through the stream owning it
// through the socket as it owning it and the memory map, an intermate relationship where the source
// will request memory etc.
//

class Source : public Error	// virtual base class
{
  protected:	// private by inheritance
	// Stream related data
	ULONG last_block_sent;		// ID of the last block returned to caller
	ULONG max_completed_block;	// ID of the greatest completed block in source.
	ULONG most_significant_time;
	ULONG nak_block;
	ULONG nak_timeout;

	size_t full_blocks;		// number of blocks available
	
	ULONG current_play_id;		// this is the trickplay flag this changes with each new trickplay
	ULONG stream_end_block;		// this is set when we know what the last block in the stream is
	
	// Network information
	
	Socket 		sd;
	SourceMemMap	*mem_map;	// if this is not allocated it is assigned to null
     					// if it is null and any method attempts to use it it will result in an error    		
	inline error_flag calculateMaxCompleteBlock(void);
	
	error_flag calculatePosAckSequence(Server *server, Statistics *stats);
	error_flag calculatePosNAKSequence(Server *server, Statistics *stats, size_t *naks = NULL);

  public:	// object creation destruction
  
 	inline size_t getFullBlocks(void)		{ return full_blocks; }
        inline ULONG  get_most_significant_block(void) 	{ return last_block_sent; }
        inline ULONG  get_most_significant_time(void)	{ return most_significant_time; }
        
	inline ULONG  getFinalBlock(void) 		{ return stream_end_block; }
        inline void   clearFinalBlock(void)		{ stream_end_block = 0; }
	inline void   setFinalBlock(ULONG final_block) 	{ stream_end_block = final_block; }

     	void SetSourceVar(Socket *socket, SourceMemMap **mem);				// only to be used in live <-> stored conversions
     	
     	Source(void) {};
     	Source(Source &live);
        Source(size_t set_nak_timeout, size_t source_recvspace);
        ~Source(void);
        
        error_flag Allocate(size_t max_blocks, size_t max_block_size, size_t initial_block_num, size_t datagram_size);
  	
  	void	   setEndPlayState(void);		// resets the mem_map and ignores any further incomming data
  	error_flag setNewPlayState(ULINT *play_state, ULONG *request_num, size_t *max_complete, size_t play_mode);
  							// returns freeblocks etc.
        error_flag getBlockStatus(size_t *num_blocks, size_t *max_blocks, size_t *num_free);
	
      		// socket manipulation 
        error_flag setServerDetails(const char *hostname, int port);
        error_flag setServerDetails(const char *hostname, const char *port);
        error_flag setServerDetails(struct in_addr address, int port);
        error_flag getLocalPort(int *port);
	error_flag getSocketDescriptor(int *s);
        error_flag setSocketError(int socket_result);

        virtual error_flag getMiscInfo(misc_info_flags flags, void *ptr);
        virtual error_flag getBlock(NECBlock **block, BitstreamBufferDescriptor **mpeg_buffer, int free_routine, int pw); // source -> stream	
        virtual error_flag freeBlock(const NECBlock *block);	// flag block as returned under interrupt                    stream -> source
		       
        	// processor entry points
	error_flag serviceDynamicAreaRenumber(int old_id, int new_id);
        virtual error_flag foregroundExecute(callback_flag *callback_flags, Server *server, Statistics *stats);
        virtual error_flag calculate_freeBlocks(Server *server, callback_flag callback_pending, Statistics *stats);
		// reads off the socket
        virtual error_flag ReadDatagrams(callback_flag current_flags, callback_flag *flags, Server *server, Statistics *stats, int timeout);
};

// this is the first step in push based video
class SourceLIVE : public Source
{
    public:
    	SourceLIVE(Source& vod); // it can only be made by converting the VOD object
    	SourceLIVE() {};
 	~SourceLIVE() {};
 	
        error_flag foregroundExecute(callback_flag *callback_flags, Server *server, Statistics *stats);
        error_flag calculate_freeBlocks(Server *server, callback_flag callback_pending, Statistics *stats);
  		
        error_flag ReadDatagrams(callback_flag current_flags, callback_flag *flags, Server *server, Statistics *stats, int timeout);
};

class SourceMultiCast : public SourceLIVE
{
    private:
    	USHORT pixel_height, pixel_width;
    	ULINT bitrate;
    	
   public:
  	SourceMultiCast(const char *hostname, size_t source_recvspace, int portnumber, size_t numBlocks, int timeout);
  	~SourceMultiCast() {};
 
       error_flag getMiscInfo(misc_info_flags flags, void *ptr);
       error_flag getBlock(NECBlock **block, BitstreamBufferDescriptor **mpeg_buffer, int free_routine, int pw); // source -> stream	
       error_flag freeBlock(const NECBlock *block);	// flag block as returned under interrupt                    stream -> source


       error_flag ReadDatagrams(callback_flag current_flags, callback_flag *flags, Server *server, Statistics *stats, int timeout);
};

#endif
