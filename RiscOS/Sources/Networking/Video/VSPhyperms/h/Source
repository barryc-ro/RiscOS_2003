/**************************************
 Source.h

describes standard Server class for mass data transfer.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
25/8/98    AR      File created

**************************************/

#ifndef _Source_H_
#define _Source_H_

#include <stddef.h>
#include "Error.h"
#include "ServCtrl.h"
#include "vspSocket.h"

class Source;
#include "NECstruct.h"

#ifdef DEBUGLIB
//#define MEM_SANE_CHECK	// this will dump the layout of the dynamic area it will also do
				// checks on locations of allocated datagrams etc.  this will ensure
				// that memory maps as it should
#endif

#define MAX_NAKS 10

// NECBlock data structure.
typedef struct {
    size_t       iov_size;   // s/g array size
    struct iovec iov[1];     // s/g array - must be last in structure
} NECBlock;

// Payload data is opaque to us
typedef void *NECPayload;	// this is the datagram

// This macro returns the size of an NECBlock structure with iov_size
// entries in the s/g array.
#define sizeof_NECBlock(iov_size) \
	(offsetof(NECBlock, iov) + sizeof(struct iovec) * (iov_size))

// The following structures are private to c++.Source defined in SourceP and are used in the 
// memmap class as such invisible to outside classes.

typedef struct MemBlock MemBlock;
typedef struct DynamicAreaHeader DynamicAreaHeader;
class DatagramBitfield;

// ---------------------------------------------------------- Source Memory map ------------------
// this class controls the dynamic area used by the source class
//
class SourceMemMap : public Error
{
  friend Source;	// Originally these two classes were one however due to the complexity of supporting two
  			// concepts within one class I believe it better to seperate it into the memory management
  			// and the block management as such the source class consults the source memory map for
  			// memory allocation and destruction.  I is ideal if we can get rid of the friend clause.
  
  private:
        size_t max_blocks;		// Number of blocks to be able to hold
	size_t max_block_size;		// maximum size of each block

	size_t dgrams_per_block;	// max dgrams making up one block size of iov vector
	size_t total_dgrams;		// total dgram buffers for object
	size_t dgram_size;		// UDP datagram payload size

	DatagramBitfield *dgram_use;	// Quick lookup bitfields

	// Dynamic area information
	int    da_number;		// dynamic area number
	void  *da_base;			// base address in memory
        size_t total_memory;		// Total size of dynamic area

        // Quick lookup pointers
        MemBlock *block_hd;     	// Memory block header buffer start
        NECDatagram *dgram_hd;  	// Datagram header buffer start
        NECPayload *dgram_data_hd;    	// Datagram payload buffer start

   private:		// constructive
	error_flag 	initLimits(void);
	error_flag 	createDynamicArea(void);
	error_flag 	initDynamicArea(void);

   			// validation and assignment
	error_flag 	validateNECBlock(const NECBlock *);			// checks the signiture
	error_flag 	validateMemBlock(const MemBlock *);			// checks the signiture
 	error_flag 	memMemBlockToNECBlock(const MemBlock *block, NECBlock **nec_block);
        error_flag 	memNECBlockToMemBlock(const NECBlock *block, MemBlock **mem_block);
        
        		// methodic
        error_flag	memFindFreeDatagramBuffer(NECDatagram **datagram);	// returns a free datagram header, indicating a free area
	error_flag 	memFreeDatagram(const NECDatagram *);
	error_flag 	memFreeDatagram(size_t);
			
			// locational
	NECPayload 	*findPayloadBuffer(size_t n) const;
	NECPayload 	*findPayloadBuffer(NECDatagram *dgram) const;
	size_t 		findDatagramNumber(NECDatagram *dgram) const;
	size_t 		findDatagramNumber(NECPayload *dgram) const;
	
	MemBlock 	*findExistingBlock(ULONG id, size_t *block_num = 0);	// finds a block based on an allocated block id, null on error
	MemBlock 	*findBlock(ULONG id, size_t *block_num = 0);		// finds a block, if it cannot find it allocate it, null on error
	
	MemBlock 	*getBlock(size_t n) const;		// returns a block addressed by its array offset in the dynamic area 
         
        error_flag 	freeBlock_background(MemBlock *mb);	// free block when called from user mode, ie not re-entered
	
  public:
  	SourceMemMap() {};
  	~SourceMemMap() {};
};
// ---------------------------------------------------------- Source Class ------------------
// this class maintains a three way relationship.  Between the stream through the stream owning it
// through the socket as it owning it and the memory map, an intermate relationship where the source
// will request memory etc.
//

class Source : public Error
{
  private:
	// Stream related data
	ULONG last_block_sent;		// ID of the last block returned to caller
	ULONG max_block_received;	// ID of HWM used block in stream
	ULONG max_completed_block;	// ID of the greatest completed block in source.
	
	
	int current_play_id;		// this is the trickplay flag this changes with each new trickplay
	
	// Network information
	Socket 		sd;
	
	SourceMemMap	mem_map;
     
     public:
	ULONG stream_end_block;		// this is set when we know what the last block in the stream is
	int full_blocks;
	
      private:	// object manipulation
	
	error_flag calculateMaxCompleteBlock(void);
	error_flag calculatePosAckSequence(Server *server);
	error_flag calculatePosNAKSequence(int *naks_sent, Server *server, int max_block);

      public:	// object creation destruction
        Source(size_t max_blocks);
        ~Source();
        error_flag Allocate( size_t max_block_size, size_t initial_block_num, size_t datagram_size);

        	// processor entry points
        error_flag calculate_freeBlocks(void);
        error_flag foregroundExecute(callback_flag *callback_flags, Server *server);
	error_flag serviceDynamicAreaRenumber(int old_id, int new_id);
	
        error_flag ReadDatagrams(callback_flag *flags);			// reads off the socket

		// block manipulation
	ULONG 	   getAckSeq(void) { return max_completed_block; }
	int	   getCurrentPlayId() {return current_play_id; }
  	error_flag getMiscInfo(int flags);
  	
  	error_flag setNewPlayState(int *play_state, int *max_complete);
        error_flag getBlockStatus(size_t *num_blocks, size_t *max_blocks, size_t *num_free);
	void 	   setFinalBlock(ULONG final_block) { stream_end_block = final_block; }
	int  	   getFinalBlock(void) { return (int)stream_end_block; }
	
        error_flag getBlock(NECBlock **block);		// give block to stream object
        error_flag freeBlock(const NECBlock *block);	// flag block as returned under interrupt
		
      		// socket manipulation 
        error_flag setServerDetails(const char *hostname, int port);
        error_flag setServerDetails(const char *hostname, const char *port);
        error_flag setServerDetails(struct in_addr address, int port);
        error_flag getLocalPort(int *port);
	error_flag getSocket(Socket *);
        error_flag setSocketError(int socket_result);
};

#endif
