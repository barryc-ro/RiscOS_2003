/**************************************
 Source.h

describes standard Server class for mass data transfer.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
25/8/98    AR      File created

**************************************/

#ifndef _Source_H_
#define _Source_H_

#include <stddef.h>
#include "Error.h"
#include "ServCtrl.h"
#include "vspSocket.h"

class Source;
#include "NECstruct.h"

#ifdef DEBUG
//#define MEM_SANE_CHECK
#endif

extern "C" {

// NECBlock data structure.
typedef struct {
    size_t       iov_size;   // s/g array size
    struct iovec iov[1];     // s/g array - must be last in structure
} NECBlock;

// Payload data is opaque to us
typedef void *NECPayload;

// This macro returns the size of an NECBlock structure with iov_size
// entries in the s/g array.
#define sizeof_NECBlock(iov_size) \
	(offsetof(NECBlock, iov) + sizeof(struct iovec) * (iov_size))


// The following structures are private to c++.Source
typedef struct MemBlock MemBlock;
typedef struct DynamicAreaHeader DynamicAreaHeader;

} // C structures

class DatagramBitfield;


class Source : public Error
{
	// this class maintains the window and returns a pointer to a data
	// block when it is requested.

  public:
//
// Public Methods
// --------------
//
        Source(size_t max_blocks);
//
// Constructor. this creates a local socket it creates an unallocated error
// this avoids any call to the source object until allocation has been done.
 
        ~Source();
//
// Destructor.  Frees any memory associated with the object.
//
// Errors: None.
//
//   
        int Allocate( size_t max_block_size, size_t initial_block_num, size_t datagram_size);
        
// allocate creates the dynamic area max_blocks is the maximum number of blocks to be held
// simultaneously.  Typically a value of 10 is used here.  max_block_size
// is the maximum size of each block.  This will be rounded up to be an
// exact multiple of the UDP datagram length.
//
// Errors: VSP_Alloc: the required buffers could not be claimed
//
//
        int setServerDetails(const char *hostname, int port);
        int setServerDetails(const char *hostname, const char *port);
        int setServerDetails(struct in_addr address, int port);
//
// Declares where the UDP packets are going to be coming from.  Port number
// may be specified as a number or a well-known service name.  Quoting a
// service "name" which is actually a string representation of a numeric value
// is treated as an explicit port selection.  If an int port is given, then
// this value is in host-order.
//
// Errors: TCP_BadPortSpecification, TCP_UnknownServer, TCP_SocketError
//         TCP_ServerRefusedConnection
//
//
        int getLocalPort(int *port);
//
// Returns the local port number being used by this Source object.  This
// information is required by the Server class for Asset Presentation Request
// messages.
//
// Errors: TCP_SocketError: Unable to bind to local port.
//
//
        int getBlockStatus(size_t *num_blocks, size_t *max_blocks, size_t *num_free);
//
// Gets Misc Header information as per spec

	int getMiscInfo(int flags);
	
// Gets the number of full blocks pending and the maximum number of bufferable
// blocks as set in the constructor, number of currently free blocks.
//
// Errors: None.
//
//
        int getBlock(NECBlock **block);
//
// Gets a pointer to the next completed complete block.  Changes to the
// data structures associated with the block are locked out until the
// block is freed with a call to the freeBlock method.
//
// Errors: VSP_NoDataAvailable
//
//
        int freeBlock(const NECBlock *block);
        int freeBlock_background(const NECBlock *block, Server *server = NULL);
//
// Releases the specifed block structure.  The data structures associated
// with the block are marked available for re-use.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
        int backgroundExecute(int *callback_flags, Server *server, int *full_blocks);
//
// Informs the Source object that an external signal has occurred (event or
// interrupt) that may be relevant to the Source object.  Source object can
// handle it as it pleases.  Use of private_handle is not yet defined.
// What this method may and may not do depends upon the host environment.
// Code that may not be executed in this method due to environment (eg. being
// in an interrupt handler) must be placed inside the foregroundExecute method.
//
// Errors: None.
//
//
        int foregroundExecute(int *callback_flags, Server *server, int *full_blocks);
//
// Allows the Source object foreground execution time so that it can perform
// operations not permitted in the interrupt method.  Use of private_handle is
// not yet defined.
//
// Errors: None.
//
//
	int getSocket(Socket *);
//
// Gets the underlying socket object being used for UDP datagram reception
// by the Source class.
//
// Errors: None.
//
	int serviceDynamicAreaRenumber(int old_id, int new_id);
//
// Informs a Source object that a dynamic area has been renumbered.  Each
// object needs to check whether its own dynamic area is the one being
// renumbered and note the change for future reference.
//
// Errors: None.
//

  private:
//
// Private Methods
// ---------------
//
        int memMemBlockToNECBlock(const MemBlock *block, NECBlock **nec_block);
//
// Maps an internal MemBlock object to an externally visible NECBlock object.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
        int memNECBlockToMemBlock(const NECBlock *block, MemBlock **mem_block);
//
// Maps an externally visible NECBlock object to an internal memBlock object.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
        int memAllocateBlock(MemBlock **block, size_t *block_num = 0);
//
// Reserves an MemBlock data structure from the block pool.  Returns NULL if
// none were available, otherwise the returned block is re-initialised ready
// for receiving information from the network.  If block_num is non-NULL,
// it is filled in with the ordinal position of the returned block.
//
//
        int memReleaseBlock(MemBlock *block);
//
// Releases a previous block allocation.  Datagram buffers for the block also
// released.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
        int memFindFreeDatagramBuffer(NECDatagram **datagram);
//
// Locates a free datagram buffer
//
// Errors: VSP_Alloc: Datagram store has been exhausted.  This
//         error should never occur unless faulty configuration information has
//         been supplied on object instantiation.
//
//
        int memReadDatagram(int *size, Server *tcp_link, unsigned int time);
//
// Reads a pending datagram into a free datagram buffer and links it into the
// block's scatter array.
//
// Errors: TCP_ReadFail, VSP_Alloc
//
//
        int memOptimiseBlock(MemBlock *block);
//
// Examines a completed block and attempts to minimise the size of the scatter
// array by merging contiguous blocks into single blocks.  This is an
// optimisation which is performed in order to minimise the number of separate
// calls that the Stream object will have to make to the Sink object.  This
// optimisation will work best when the communication channel between the server
// and client is mostly reliable and delivers datagrams in order.
//
// Errors: None.
//
//
	int linkDatagramToBlock(NECDatagram *, Server *tcp_link, unsigned int time);
	int linkDatagramToBlock(NECDatagram *, MemBlock *mb, Server *tcp_link);
//
// Link a received datagram to its matching block.  Allocate the block if
// possible.  If it is a duplicate, free the datagram and return NoError.
// If block is now completed, set the flag in the MemBlock indicating this.
//
// Errors: VSP_Alloc: no free block buffers
//
        int setSocketError(int result);
//
// Converts the current value of errno into a VSP module error code if result
// was less than zero.  If result was >= 0, then there was no error.
// This method allows setSocketError(some_system_call()) to wrap system calls.
//
// Errors: TCP_BadPortSpecification, TCP_UnknownServer, TCP_SocketError
//         TCP_ServerRefusedConnection
//
	int validateNECBlock(const NECBlock *);
//
// This function validates a given NECBlock pointer by checking the magic word
// which immediately precedes the structure in memory.
//
// Errors: VSP_InvalidValue
//
	int validateMemBlock(const MemBlock *);
//
// This function validates a given MemBlock pointer by checking the magic word
// which occurs within the structure.
//
// Errors: VSP_InvalidValue
//
	MemBlock *getBlock(size_t n); //const;
	
// same as free block but as in user mode	
        int freeBlock_background(MemBlock *mb);

// calculate the largest block_id for full blocks, this means that no block_id
// smaller shall be incomplete and no block_id greater shall be complete.

	int calculateMaxCompleteBlock(void);
	
// this routine calculates if there are any acks to be sent.
// calculate possible ack sequence.
// the idea is to maintain a window of NEC_databurstval from the last complete block 

	int calculatePosAckSequence(Server *server);
//
// This function maps a block offset number (not a block ID!) to a pointer
// to the block.  It does not validate n.
//
// Errors: None.
//
	int memFreeDatagram(const NECDatagram *);
	int memFreeDatagram(size_t);
//
// Frees the specified datagram buffer.
//
// Errors: VSP_BadErr: block pointer/number was illegal - this is a fatal
// internal error
//

// Utility methods which do not use the standard error report mechanism
  private:
        size_t sizeof_MemBlock() const;
// Returns the size of a MemBlock stucture (depends on dgrams_per_block)
	int initLimits(size_t datagram_size);
// Calculate the memory requirements - used during object construction
	int createDynamicArea();
// Request memory block from the OS.
	int initDynamicArea();
// Final initialisation of Source objects - caches some useful constants

	NECPayload *findPayloadBuffer(size_t n) const;
	NECPayload *findPayloadBuffer(NECDatagram *dgram) const;
// Locate the payload buffer for the particular datagram

	size_t findDatagramNumber(NECDatagram *dgram) const;
	size_t findDatagramNumber(NECPayload *dgram) const;
// Discover the datagram buffer number of the given pointer

	MemBlock *findBlock(ULONG id, size_t *block_num = 0);
	MemBlock *findExistingBlock(ULONG id, size_t *block_num = 0);
//
// This function looks to see if the block with the identifier of id
// has been allocated, and if so, what its address is.  If the block
// is not found, then it is created if possible.  If that was not
// possible, then NULL is returned.  If block_num is non-NULL, it is
// filled in with the ordinal position of the MemBlock in the memblock
// buffer array.
//
	MemBlock *locateBlock(ULONG id);
//
// This function looks to see if the block with the identifier of id
// has been allocated, and if so, where
//


  private:
        // Private data members

        // Overall memory limits
        size_t total_memory;		// Total size of dynamic area
        size_t max_blocks;		// Number of blocks to be able to hold
	size_t max_block_size;		// maximum size of each block

	size_t dgrams_per_block;	// max dgrams making up one block
	size_t total_dgrams;		// total dgram buffers for object
	size_t dgram_size;		// UDP datagram payload size
	size_t dgram_sendto_size;	// returned from asset presentation AR

	DatagramBitfield *dgram_use;	// Quick lookup bitfields

	// Dynamic area information
	int da_number;			// dynamic area number
	void *da_base;			// base address in memory
        size_t size_limit;		// D.A. size limit

        // Quick lookup pointers
        MemBlock *block_hd;     	// Memory block header buffer start
        NECDatagram *dgram_hd;  	// Datagram header buffer start
        NECPayload *dgram_data_hd;    	// Datagram payload buffer start

	// Stream related data
	ULONG last_block_sent;		// ID of the last block returned to caller
	ULONG max_block_received;	// ID of HWM used block in stream
	ULONG max_completed_block;	// ID of the greatest completed block in source.

	// Network information
	Socket sd;

};
#endif
