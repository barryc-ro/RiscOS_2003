/**************************************
 Source.h

describes standard Server class for mass data transfer.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
25/8/98    AR      File created

**************************************/

#ifndef _Source_H_
#define _Source_H_

#include "Error.h"
#include "ServCtrl.h"	// sending of Acks / Naks
#include "vspSocket.h"
#include "SourceMem.h"
#include "NECstruct.h"

// these values are used to divide the datagrams into one multicast block
#define Multi_block_num(a)            ( (a)>>3 )
#define Multi_dgram_num(a)            ( (a)&0x07 )
#define Multi_dgrams_per_block        0x08
#define Multi_mul_dgrams_per_block(a) ( (a)<<3 )

#define Acceptable_NAKS			10

// ---------------------------------------------------------- Source Class ------------------
// this class maintains a three way relationship.  Between the stream through the stream owning it
// through the socket as it owning it and the memory map, an intermate relationship where the source
// will request memory etc.
//

class Source : public Error	// virtual base class
{
  protected:	// private by inheritance
	// Stream related data
	ULONG last_block_sent;		// ID of the last block returned to caller
	ULONG max_completed_block;	// ID of the greatest completed block in source.
	ULONG most_significant_time;
	ULINT nak_block;
	ULINT nak_timeout;

	size_t full_blocks;		// number of blocks available
	
	ULONG current_play_id;		// this is the trickplay flag this changes with each new trickplay
	ULONG stream_end_block;		// this is set when we know what the last block in the stream is
	
	// Network information
	
	Socket 		sd;
	SourceMemMap	*mem_map;	// if this is not allocated it is assigned to null
     					// if it is null and any method attempts to use it it will result in an error    		
	inline error_flag calculateMaxCompleteBlock(void);
        inline error_flag getBlockStatus(size_t *num_blocks, size_t *max_blocks = NULL, size_t *num_free = NULL);
	
	error_flag calculatePosAckSequence(InternetObject *server, Statistics *stats);
	error_flag calculatePosNAKSequence(InternetObject *server, Statistics *stats, size_t *naks = NULL);

  public:	// object creation destruction
  
 	inline size_t getFullBlocks(void)		{ return full_blocks; }
        inline ULONG  get_most_significant_block(void) 	{ return last_block_sent; }
        inline ULONG  get_most_significant_time(void)	{ return most_significant_time; }
        inline ULONG  get_current_play_id(void)		{ return current_play_id; }
        
	inline ULONG  getFinalBlock(void) 		{ return stream_end_block; }
        inline void   clearFinalBlock(void)		{ stream_end_block = 0; }
	inline void   setFinalBlock(ULONG final_block) 	{ stream_end_block = final_block; }

     	void SetSourceVar(Socket *socket, SourceMemMap **mem);				// only to be used in live <-> stored conversions
     	
     	//Source(void) {};
        Source(size_t set_nak_timeout, size_t source_recvspace);
      	Source(Source &live);
       ~Source(void);
        
        error_flag Allocate(size_t max_blocks, size_t max_block_size, size_t initial_block_num, size_t datagram_size);
  	
  	void	   setEndPlayState(void);		// resets the mem_map and ignores any further incomming data
  	error_flag setNewPlayState(ULINT *play_state, ULONG *request_num, size_t *max_complete, size_t play_mode);
  							// returns freeblocks etc.
	
      		// socket manipulation 
        error_flag setServerDetails(const char *hostname, int port);
        error_flag setServerDetails(const char *hostname, const char *port);
        error_flag setServerDetails(struct in_addr *address, int port);
        error_flag getLocalPort(int *port);
	error_flag getSocketDescriptor(int *s);
        error_flag setSocketError(int socket_result);

        virtual error_flag getMiscInfo(misc_info_flags flags, void *ptr);
        virtual error_flag getBlock(NECBlock **block, BitstreamBufferDescriptor **mpeg_buffer, int free_routine, int pw); // source -> stream	
        virtual error_flag freeBlock(const NECBlock *block);	// flag block as returned under interrupt                    stream -> source
		       
        	// processor entry points
	error_flag serviceDynamicAreaRenumber(int old_id, int new_id);
        virtual error_flag foregroundExecute(callback_flag *callback_flags, InternetObject *server, Statistics *stats);
        virtual error_flag calculate_freeBlocks(InternetObject *server, callback_flag callback_pending, Statistics *stats);
		// reads off the socket
        virtual error_flag ReadDatagrams(callback_flag current_flags, callback_flag *flags, InternetObject *server, Statistics *stats, int timeout);
};

// this is the first step in push based video
class SourceLIVE : public Source
{
    public:
    	SourceLIVE(Source& vod); // it can only be made by converting the VOD object
    	SourceLIVE(size_t set_nak_timeout, size_t source_recvspace):Source(set_nak_timeout, source_recvspace) {};
    	//SourceLIVE() {};
 	~SourceLIVE() {};
 	
        error_flag foregroundExecute(callback_flag *callback_flags, InternetObject *server, Statistics *stats);
        error_flag calculate_freeBlocks(InternetObject *server, callback_flag callback_pending, Statistics *stats);
  		
        error_flag ReadDatagrams(callback_flag current_flags, callback_flag *flags, InternetObject *server, Statistics *stats, int timeout);
};

class SourceMultiCast : public SourceLIVE
{
    private:
    	USHORT pixel_height, pixel_width;
    	ULINT bitrate;
    	
   public:
  	SourceMultiCast(InternetObject *server, size_t source_recvspace, size_t numBlocks, int timeout);
  	~SourceMultiCast() {};
 
       error_flag getMiscInfo(misc_info_flags flags, void *ptr);
       error_flag getBlock(NECBlock **block, BitstreamBufferDescriptor **mpeg_buffer, int free_routine, int pw); // source -> stream	
       error_flag freeBlock(const NECBlock *block);	// flag block as returned under interrupt                    stream -> source


       error_flag ReadDatagrams(callback_flag current_flags, callback_flag *flags, InternetObject *server, Statistics *stats, int timeout);
};

#endif
