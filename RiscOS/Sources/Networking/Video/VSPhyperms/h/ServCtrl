/**************************************
 Server Control.h

descibes standard Server class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/

#ifndef _ServerControl_H_
#define _ServerControl_H_

#include "Error.h"
#include "List.h"
#include "vspSocket.h"

typedef enum {
  owner_none		= 0x00,
  owner_interface 	= 0x01,
  owner_stream		= 0x02
} ownership_flag;

#define  NEC_databurstval 	 4	// defined in spec pg 36, "thou shalt not request more than 4"
#define  MAX_scene_list	64	// this is the number of scenes that can be contained in a scene list;

// command numbers
#define COMMAND_ACK			0x2b	// ANK/NAK
#define COMMAND_NAK			0x2c
#define COMMAND_CPNN			0x31	// control port number notification
#define COMMAND_assetlist_request	0x21
#define COMMAND_assetlist_response	0x81
#define COMMAND_scenelist_request	0x27
#define COMMAND_scenelist_response	0x87
#define COMMAND_assetpres_request	0x22	// asset presentation request
#define COMMAND_assetpres_response	0x82
#define COMMAND_assetend_request	0x23
#define COMMAND_assetend_response	0x83
#define COMMAND_playback_request	0x2a
#define COMMAND_playback_response	0x8a
#define COMMAND_startend_notification	0x32

class Server : public Error
{
  friend Stream;
  /*
  this defines the specifices for the server it will
  define the protocol headers.
  */

  private:
  	int certification_code;		// an incremental certification code
  	int timeout_period;		// this is the timeout on waiting for server communication
  	int connection_port;		// this defines the port used to connect to the server
   	server_comms comms_flag;	// if an ACK/NAK has been sent since last dummy
  	ULINT assetresponse_dgram_size; // datagram size set on the server
	ULINT MAX_requested_block;	// error checking to avoid multilple requests for the same thing
	ownership_flag owners;
  	
  	ACK_Block	ack;
  	NAK_Block	nak;
  	
  	Socket SocketDescriptor;	// this is a vspSocket
  	  	
  	error_flag InitVar(void);
        error_flag setSocketError(int socket_result);

  	error_flag Connect(char *server_name, char *service);
  	error_flag Connect(char *server_name, int service);
  	error_flag Connect(struct in_addr server_name, int service);
  	
  	// protocol messages
  	error_flag send_assetlist_request(int select_flags, int start, int number);
  	error_flag get_assetlist_response(int *number, AssetIDDescriptor *buffer, int *buffer_size);
  	
  	error_flag send_scenelist_request(int asset_id);
  	error_flag get_scenelist_response(int *number, SceneInformationDescriptor *buffer, int *buffer_size);
  	
  	error_flag send_assetpresentation_request(int init_value, PlayElementRequest playlist[], int size,  struct in_addr ipaddr, ULINT port);
  	// this sets the server port and ip
  	error_flag get_assetpresentation_response(struct in_addr *ipaddr, ULINT *port, unsigned int *stream_time,
  						ULINT *dgram_size, ULINT *bitrate, int *fast_play_ratio); 
  	
	error_flag send_playback_request(int state_id, ULINT MAX_storableBlock, ULONG AckSeq, int time = 0, int mode = 0);
	error_flag get_playback_response(ULINT *result);
	
  	error_flag SendData(void *buffer, int size);
  	error_flag GetData(void *buffer, int size);
  	error_flag PeekHeader(int *command);
#ifdef DEBUGLIB  	
  	int ReadDataToDebug(void);
#endif
  	int timeout(void) { return timeout_period; }
  	  
  	error_flag getSocket(Socket *sock);
  	error_flag inetevent(int *event, ULINT *result);
  	
  	error_flag AssetPresentation(int init_value, PlayElementRequest playlist[], int size, unsigned int *stream_time,
  					struct in_addr *ipaddr, ULINT *port, ULINT *dgram_size, ULINT *bitrate, int *fast_play_ratio);
  	error_flag AssetEnd(int status, int endflag);
 
  public:
  	void	setMaxRequestedBlock(ULONG value)	{  MAX_requested_block = (ULINT)value; }
  		// ownership battles
  	int	stream_uses(void) 		{return (owners & owner_stream);}
  	int	interface_uses(void) 		{return (owners & owner_interface);}
  	void 	set_stream_owner(void) 		{ owners = (ownership_flag)(owners | owner_stream); }
  	void 	set_interface_owner(void) 	{ owners = (ownership_flag)(owners | owner_interface); }
  	void	clear_stream_owner(void)	{ owners = (ownership_flag)(owners & ~owner_stream); }
  	void 	clear_interface_owner(void) 	{ owners = (ownership_flag)(owners & ~owner_interface); }
  	
  	Server(Server *server);		// copy constructor
    	Server(char *server, char *port, int timeout);
  	~Server();
  		
  	//-----
  	inline ULINT getMaxRequestedBlock(void) { return MAX_requested_block; }

  	error_flag SendAck(ULINT MAX_storableBlocks, ULINT MAX_complete_block, ACK_type datatype = data);
  	error_flag SendNak(ULINT BlockStart, LINT DatagramStart, ULINT BlockEnd, LINT DatagramEnd); 

   	error_flag GetAssetList(_kernel_swi_regs *regs);
  	error_flag GetSceneAssetList(_kernel_swi_regs *regs);
  	
};

class ServerList : public List
{
  public:
  ServerList():List() {}
  ~ServerList(void);
  
  error_flag Remove(int identifier);
};

#endif
