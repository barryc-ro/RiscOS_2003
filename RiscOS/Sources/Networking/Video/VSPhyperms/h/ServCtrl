/**************************************
 Server Control.h

descibes standard Server class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/

#ifndef _ServerControl_H_
#define _ServerControl_H_

#include "Error.h"
#include "List.h"
#include "vspSocket.h"

#define ServerComms	1
#define NoServerComms	(~ServerComms)
#define SearchForAllAssetsFlags  (0x01 | (0x02<<8) | (0x02<<16))
#define  NEC_databurstval 4	// defined in spec pg 36, "thou shalt not request more than 4"

// ACK datatypes
#define DummyACK	-2
#define PlayPreparation -1

// command numbers
#define COMMAND_ACK			0x2b	// ANK/NAK
#define COMMAND_NAK			0x2c
#define COMMAND_CPNN			0x31	// control port number notification
#define COMMAND_assetlist_request	0x21
#define COMMAND_assetlist_response	0x81
#define COMMAND_assetpres_request	0x22	// asset presentation request
#define COMMAND_assetpres_response	0x82
#define COMMAND_assetend_request	0x23
#define COMMAND_assetend_response	0x83
#define COMMAND_playback_request	0x2a
#define COMMAND_playback_response	0x8a
#define COMMAND_startend_notification	0x32

class Server : public Error
{
  /*
  this defines the specifices for the server it will
  define the protocol headers.
  */

  private:
  	int certification_code;		// an incremental certification code
  	int timeout_period;
  	ACK_Block	ack;
  	NAK_Block	nak;
  	ULINT assetresponse_dgram_size; // datagram size set on the server
	ULINT MAX_requested_block;	// error checking to avoid multilple requests for the same thing
  	
  	Socket SocketDescriptor;
  	int Connect(char *server_name, char *service);
  	int Connect(char *server_name, int service);
  	int Connect(struct in_addr server_name, int service);
  	
  	// protocol messages
  	int send_assetlist_request(int select_flags, int start, int number);
  	int get_assetlist_response(int *number, AssetIDDescriptor *buffer, int *buffer_size);
  	
  	int send_assetpresentation_request(int init_value, PlayElementRequest playlist[], int size,  struct in_addr ipaddr, ULINT port);
  	int get_assetpresentation_response(struct in_addr *ipaddr, ULINT *port, ULINT *dgram_size, ULINT *bitrate); // this sets the server port and ip

	int send_playback_request(ULINT MAX_storableBlocks, int time = 0);
	int get_playback_response(ULINT *result);
	
  public:
  	int comms_flag;			// if an ACK/NAK has been sent since last dummy
  	int connection_port;
	
  	Server(Server *server);		// copy constructor
    	Server(char *server, char *port, int timeout);
  	~Server();
  	
  	int timeout(void) { return timeout_period; }
  	
 	int getMaxRequestedBlock(void) { return (int)MAX_requested_block; }
  	int getSocket(Socket *sock);
  	int inetevent(int *event, ULINT *result);
  	
  	int SendData(void *buffer, int size);
  	int GetData(void *buffer, int size);
  	int PeekHeader(int *command);
  	
  	int SendAck(ULINT MAX_storableBlocks, ULINT MAX_complete_block, int datatype = 0);
  	int SendNak(ULINT BlockStart, LINT DatagramStart, ULINT BlockEnd, LINT DatagramEnd); 
  	
  	//-----
  	int GetAssetList(_kernel_swi_regs *regs);
  	int GetSceneAssetList(_kernel_swi_regs *regs);
  	
  	int AssetPresentation(int init_value, PlayElementRequest playlist[], int size, 
  					struct in_addr *ipaddr, ULINT *port, ULINT *dgram_size, ULINT *bitrate);
  	int AssetEnd(int status, int endflag);
  	int Play(ULINT MAX_storableBlocks, int time = 0);
};

class ServerList : public List
{
  public:
  ServerList():List() {}
  ~ServerList(void);
  
  int Remove(int identifier);
};

#endif
