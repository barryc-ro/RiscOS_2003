#ifndef VSP_TYPES_H_
#define VSP_TYPES_H_

/*
* AR I have extended this header file to extend global types such as the claim
* therefore types are defined in the order of file scope or here if module scope
* beyond this they are library scope
*/

#ifdef __cplusplus
extern "C" {
#endif

/* typedefs to allow code to match NEC specification document */

typedef unsigned char  UBYTE;	/* 8 bits               */
typedef unsigned char  UCHAR;   /* 8 bits               */
typedef unsigned short USHORT;  /* 16 bits              */
typedef unsigned long  ULONG;   /* 32 bit               */
typedef ULONG   ULINT;		/* 32 bits              */
typedef int     LINT;           /* 32 bits signed       */

/* XXX: Specification isn't clear on whether this is unsigned or not */
typedef struct {
        unsigned int lo;
        unsigned int hi;
} UINT64;

typedef enum {
  	true  = 1,
  	false = 0
} bool;

typedef enum {
  	ErrorOccurred = 0,
  	NoError	= 1
} error_flag;

typedef enum {
  	claim_token = 0,
  	free_token  = 1
} semaphor;

typedef enum {
  	claim_event  = 0,
  	ignore_event = 1
} claim_flag;

typedef enum {
  owner_none		= 0x00,
  owner_interface 	= 0x01,
  owner_stream		= 0x02,
  owner_streamrunning	= 0x04
} ownership_flag;

// these are the definitions as passed in a play request,
typedef enum {
  mode_normalplay = 0,
  mode_forwardskip,
  mode_backwardskip,
  mode_fastforward,
  mode_fastrewind,
  mode_still,
  mode_releasestill,
  mode_streamlive,
  mode_pause
} play_mode;

// this is defined in 4.4 of the specification
typedef enum {
	data = 0,
	play_preparation = -1,
	dummy_ack = -2
} ACK_type;

#ifdef DEBUGLIB
typedef enum {
  debug_always  	= 0x00000001,
  debug_errors  	= 0x00000002,
  debug_ack     	= 0x00000004,
  debug_naks		= 0x00000008,
  debug_callbacks	= 0x00000010,
  debug_streaminfo	= 0x00000020,
  debug_Registers03	= 0x00000040,
  debug_Registers47	= 0x00000080,
  debug_servercontrol	= 0x00000100,
  debug_miscinfo	= 0x00000200,
  debug_assetlists	= 0x00000400,
  debug_scenelists	= 0x00000800,
  debug_SWIentryexit	= 0x00001000,
  debug_messageQ	= 0x00002000,
  debug_multicast	= 0x00004000,
  debug_blockerrors	= 0x00008000,
  debug_startend	= 0x00010000,
  debug_all		= 0xffffffff
} debug_flags;
#endif

// these are used to determine the type of callback
typedef enum {
  callback_none  	= 0x000,
  callback_nak_after	= 0x001,
  callback_nak_now	= 0x002,
  callback_timeout 	= 0x003, // umbrella source save
  callback_fullblocks 	= 0x004, // used to notify no need for callback
  callback_startend	= 0x008, // this stops re-requesting blocks when we have played the last block
  callback_token1free 	= 0x010, 
  callback_token2free   = 0x020,
  //callback_token3free   = 0x040,
  //callback_token4free   = 0x080,
  callback_tokenfree	= 0x030, // umbrella buffers free for tests
  callback_bufferswait	= 0x040,
  callback_trickplay  	= 0x080  // change in play mode
} callback_flag_vals;

typedef enum {
  type_debug,
  type_buffers,
  type_misc_5_10
} misc_info_flags;

// this is taken from the MPEG spec for STB 22
typedef struct {
  void  *link;
 // buffer_descriptor	*link;  // set to zero as we are passing one at a time
  int	free_routine;           // callback address
  int	free_workspace;		// workspace pointer
  char	*buffer_ptr;		// as returned in get_block
  int	buffer_length;		// >= datagram,  < block
  int	packets;		// set to zero on call to full buffers
} BitstreamBufferDescriptor;

// this structure is the response to the MiscInfo query.
typedef struct{
  	USHORT h_pixels;	// 16 bits
  	USHORT v_pixels;
  	ULONG  play_time;	// 32 bits
  	USHORT status_word;
  	USHORT scene_number;
  	ULONG  head_time;
  	ULONG  end_time;
  	ULONG  encode_time;
  	ULONG  bitrate;
} misc_5_10;

// C++ specific types, c++ is a strongly typed language use it to stop typo's
// you should not be able to inappropriately assign these types.

#ifdef __cplusplus
}// end of C

class callback_flag 
{  
  	callback_flag_vals value;
  public:
  	callback_flag() 			{ value = callback_none; }
        callback_flag(callback_flag_vals val) 	{ value = val; }
  	callback_flag(callback_flag& flags) 	{ value = flags.value; }
  	
  	inline bool	     operator ==(const callback_flag_vals& val) { return (bool)(value == val); }
  	inline bool	     operator !=(const callback_flag_vals& val) { return (bool)(value != val); }
  	inline bool	     operator |(const callback_flag& flags)	{ return (bool)(value | flags.value); }
  	inline bool 	     operator &(const callback_flag& flags)	{ return (bool)(value & flags.value); }
  	inline callback_flag operator =(const callback_flag& flags) 	{ value = flags.value; 				      return (*this);}
  	inline callback_flag operator +=(const callback_flag& flags) 	{ value = (callback_flag_vals)(value | flags.value);  return (*this);}
  	inline callback_flag operator -=(const callback_flag& flags) 	{ value = (callback_flag_vals)(value & ~flags.value); return (*this);}
  	inline callback_flag operator |=(const callback_flag& flags)    { value = (callback_flag_vals)(value | flags.value);  return (*this);}
  	inline callback_flag operator &=(const callback_flag& flags)	{ value = (callback_flag_vals)(value & flags.value);  return (*this);}
  	inline callback_flag operator ~() 				{ return (*new callback_flag(~value)); }
};

class Statistics {
  public:
  	ULINT last_stream_bytes_received;
  	ULINT last_stream_time;
  	ULINT last_stream_acks;
  	ULINT last_stream_naks;
  	
  	ULINT dgrams_read;
  	ULINT duplicate_dgrams;
  	ULINT bytes_received;
  	ULINT acks_sent;
  	ULINT naks_sent;
  	ULINT block_naks_sent;
  	ULINT deleted_blocks;
  
  	Statistics(void);
  	~Statistics(void) {}
  
  	void print();
};

#endif

#endif
