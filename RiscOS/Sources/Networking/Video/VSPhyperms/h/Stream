/**************************************
 Stream.h
	
descibes standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/

#ifndef _Stream_H_
#define _Stream_H_

#include "Error.h"
#include "List.h"	// Parent List Class
#include "ServCtrl.h"	// control path
#include "Sink.h"	// Sink element for the stream
#include "Source.h"	// Source Element

#define NUM_MPEG_Tokens 	2	// this is the number of tokens passed between source and stream
#define STREAM_NAK_period	400	// centiseconds, I would suggest that this is larger than one block

#define FINISHED	1
#define NOTFINISHED	(~FINISHED)
#define STREAM_inet_inuse 	1
#define CLAIMED		1
#define UNCLAIMED	(~CLAIMED)

// query 5.8
typedef enum {
	state_stop = 1,
	state_play,
	state_pause,
	state_fast_forward,
	state_fast_rewind,
	state_forward_skip,
	state_backward_skip,
	state_back_skip,
	state_slow,
	state_step,
	state_still
} state_of_play;
 
// query 5.9
#define trick_fast_forward 	0x0001
#define trick_fast_rewind	0x0002
#define trick_forward_skip	0x0004
#define trick_backward_skip	0x0008
#define trick_forward_jump	0x0010
#define trick_backward_jump	0x0020
#define trick_normal_play	0x0040
#define trick_slow_play		0x0080
#define	trick_pause		0x0100
#define trick_step_play		0x0200
#define trick_jump_most_rec	0x0400
#define trick_still		0x0800

#define trick_modes	(trick_normal_play | trick_pause)

class StreamToken : public Error{
  public:
   int 			in_use;	 // this is a claimed not claimed boolean
   int 			list_size;
   Bitstream_buffer_descriptor	*list;
   NECBlock			*block;
   NECBlockHeader		*block_header;
   int 				num_blocks, blocks_returned;
  
  StreamToken(void);
  ~StreamToken(void);
  
  int AllocList(int max_dgrams);
};

typedef PlayElementRequest* PlayList;

typedef struct{
  USHORT h_pixels;	// 16 bits
  USHORT v_pixels;
  ULONG	 play_time;	// 32 bits
  USHORT status_word;
  USHORT scene_number;
  ULONG	 head_time;
  ULONG	 end_time;
  ULONG  encode_time;
  ULONG  bitrate;
} misc_5_10;

class Stream : public Error
{
  /* 
  This defines a dynamic stream it is instantiated while a stream
  is to be expected from the server.  It contains a state that indicates
  its speed this avoids calls that aim to change the state in a manor
  of which it is incapable
  */

  private:
  	StreamToken buffers[NUM_MPEG_Tokens];
  	
  	NECBlockHeader	most_significant_block;
  	
  	int full_blocks;			// if the mpeg player stalls it is better to start with
  	int from, to;
  					// full blocks
  	void *pw;			// for callbacks
  	state_of_play state;		// state of play, FF, RW etc. STATE_ declarations
  	Sink    *mysink;          	// pointer to sink
  	Source  *mysource;		// pointer to source

  	int init_buffers(void);
   	int test_empty_buffers(void);
   	int NECBlockToMPEGBufferList(StreamToken *buffer);
	int MPEGBufferListToNECBlock(StreamToken *buffer);
	  	
  public:
  	callback_flag callback_pending;		// this is used by the Stream List class

  	int source_full_blocks;
  	Server  *myserver;
  	int source_flag, server_flag;	// flags are to avoid inet re-entrancy
  	int source_sd, server_sd;	// search criteria
 	Stream(int MPEGid, PlayList playlist, int play_num, Server* server, int NumBlocks, 
 					int BufferBlocks, void *pwork, int in_from = 0, int in_to = 0);
 	~Stream();
 					// delete only if MPEG modules don't own any memory
 	int change_state(state_of_play new_state);
 	state_of_play get_state(void) { return state; } 
 		
 	int GetSinkHandle(void);	// call to Decoder
 	int CheckEOS(int *play_state);	// returns the state of the stream
 	int SetSpeed(int direction, int speed);	// call to Decoder
 	int SetPosition(int flags, int pos_time);  // call to Decoder
 	int ReadNPT(int *time);		// call to Decoder
 	int GetMiscInfo(int *reg_r0, misc_5_10 *ptr, int size);
 	
	int source_inetevent(void);
	int server_inetevent(void);
	int NakCall(void);

	int MPEGInterrupt(int buffer_descriptor, int *claim);
	int DummyAckCall(void);
	int ServiceDynamicAreaRenumber(int old_id, int new_id);
};


class StreamList : public List
{
  /*
  This extends the list class to make it specific to the stream
  values.  This can test that no two decoder handles have been issued before
  creating a new stream element with this handle.
  */

  public:
  	StreamList(void);
  	~StreamList(void);
  	Stream *identify(int identifier);
  	int Add(Stream *, int *);
  	int Remove(int identifier);	// returns a boolean success value
  	
	// poll events
	int inetEvent(int code, int identifier, int *claim, void *pw);
	int TimeSliceCall(void *pw);
	int NAKCallBack(void);
	int MPEGInterrupt(int buffer_descriptor);
	int DummyAckPoll(void);
	int ServiceDynamicAreaRenumber(int old_id, int new_id);
};
#endif //_Stream_H_
