/**************************************
 Stream.h
	
descibes standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/

#ifndef _Stream_H_
#define _Stream_H_

#include "Error.h"
#include "List.h"	// Parent List Class
#include "ServCtrl.h"	// control path
#include "Sink.h"	// Sink element for the stream
#include "Source.h"	// Source Element

#define NUM_MPEG_Tokens 	2

#define MACRO_getFreeToken(a) \
	{if (buffers[0].in_use == free_token) {(a)=0;} else \
	{if (buffers[1].in_use == free_token) {(a)=1;} else { (a) = -1;} }}
	
typedef enum {
  	source_multicast,
  	source_streamlive,
  	source_vod
} source_type;

// query 5.8
typedef enum {
	state_stop = 1,
	state_play,
	state_pause,
	state_fast_forward,
	state_fast_rewind,
	state_forward_skip,
	state_backward_skip,
	state_slow,
	state_step,
	state_still,			// beyond here is differing states of play
	state_streamlive,
	state_endreceived,
	state_prestart
} state_of_play;

// query 5.9
#define trick_fast_forward 	0x0001
#define trick_fast_rewind	0x0002
#define trick_forward_skip	0x0004
#define trick_backward_skip	0x0008
#define trick_forward_jump	0x0010
#define trick_backward_jump	0x0020
#define trick_normal_play	0x0040
#define trick_slow_play		0x0080
#define	trick_pause		0x0100
#define trick_step_play		0x0200
#define trick_jump_most_rec	0x0400
#define trick_still		0x0800

#define implemented_trick_modes	(trick_normal_play |\
				trick_forward_jump |\
				trick_backward_jump|\
				trick_normal_play  |\
				trick_slow_play	   |\
				trick_pause	   |\
				trick_step_play	   |\
				trick_pause	\
				)
				
class StreamToken : public Error{
  public:
   semaphor			in_use;	 // this is a claimed not claimed boolean
   int 				blocks_returned;
   NECBlock			*block;
   BitstreamBufferDescriptor	*mpeg_buffer;
  
  StreamToken(void);
  ~StreamToken(void);
};

typedef PlayElementRequest* PlayList;

class Stream : public ListObject
{
  friend StreamList;
  
  /* 
  This defines a dynamic stream it is instantiated while a stream
  is to be expected from the server.  It contains a state that indicates
  its speed this avoids calls that aim to change the state in a manor
  of which it is incapable
  */

  private:
  	StreamToken buffers[NUM_MPEG_Tokens];
  	
  	ULINT start_time, data_at_start;	// stats for this stream
  	ULINT acks_at_start, naks_at_start;	// used by stream list.stats on closure
  	
  	LINT step_times;			// blocks that can be passed before blocking
  	
  	ULINT buffer_blocks;			// if the mpeg player stalls it is better to start with
   	ULINT from;				// jump position
   	ULINT endofstream;	// time criteria
   	ULINT fast_playback_ratio;		// used in time calculations
   	callback_flag 	callback_pending;	// this is used by the Stream List class
  	int 		comms_timeout;		// panic period from data not arriving
  	int		current_scene;
  	bool		scene_blanking;		// blank between scenes.

  	void 		*pw;			// for callbacks (workspace pointer)
  	ULINT		trick_modes_available;	// trickmodes available to this stream
  	state_of_play 	state;			// state of play, current state of the stream
  	source_type	source;			// this is used in the case of jumping to stream live

  	LINT 		source_sd, server_sd;		// socket search criteria
  	ULINT		inet_udp_reenter, inet_tcp_reenter; // reentrancy
  	Sink    	mysink;          		// reference to sink
  	Source		*mysource;			// pointer to source
 	InternetObject 	*myserver;			// pointer to the control oject
	
	
  	inline ULINT	  trick_modes(void);
	error_flag 	  ServiceDynamicAreaRenumber(int old_id, int new_id);
	
	inline ULINT 	  getNECTime(void);			// NPTtime without rounding

	inline bool	  tokenfree(void);	// returns true if a token is free
   	inline error_flag test_empty_buffers(void);
   	inline void       reset_sink(play_mode mode) { if ((mode == mode_fastforward)||(mode == mode_fastrewind)) 
   							       mysink.ResetStream(1); else mysink.ResetStream(3); }

	inline error_flag timeslice(Statistics *stats);
	inline error_flag server_inetevent(int code);
	inline error_flag source_inetevent(int code, Statistics *stats);
	inline error_flag MPEGInterrupt(int buffer_descriptor);
	inline error_flag DummyAckCall(void);
	inline error_flag swap_source(void); 	// changes stream live to stored
 	error_flag 	  change_state(state_of_play new_state);
 	  	
  public:
  	
	Stream(int inet_timeout, InternetObject *server, int MPEGid, int source_recvspace,
		int NumBlocks, int BufferBlocks, int TCP_TimeOut, void *pwork);
 	Stream(int inet_timeout, int initial_block, int MPEGid, PlayList playlist, int play_num, Server* server, 
 		int NumBlocks, int source_recvspace, int BufferBlocks, void *pwork, bool sceneblank, int in_from = 0);
 	~Stream();
 					// delete only if MPEG modules don't own any memory
 	inline state_of_play getstate(void) { return state; }		// returns the state
 	error_flag 	     stop_stream(ULONG *new_block_number);	// sets the greatest block used
		
 	error_flag GetSinkHandle(void);	// call to Decoder
 	error_flag CheckEOS(int *play_state);	// returns the state of the stream
 	error_flag SetSpeed(int direction, int speed);	  // call to Decoder
 	error_flag SetPosition(int flags, int pos_time);  // call to Decoder
 	error_flag ReadNPT(ULINT *NPT_time);
 	error_flag GetMiscInfo(ULINT *reg_r0, misc_5_10 *ptr, int *size);
 	
};

class StreamList : public List
{
  /*
  This extends the list class to make it specific to the stream
  values.  This can test that no two decoder handles have been issued before
  creating a new stream element with this handle.
  */
   public:
   	Statistics stats;
   	
  	StreamList(void);
  	~StreamList(void) {};
  				
  	error_flag Add(Stream *, int *);
  	error_flag Remove(int identifier);	// returns a boolean success value
 	
	// poll events
	error_flag inetEvent(int code, int identifier, claim_flag *claim, void *pw);
	error_flag TimeSliceCall(void *pw);
	error_flag TimeSliceCallTickerTimeout(void *pw);
	error_flag MPEGInterrupt(int buffer_descriptor);
	error_flag DummyAckPoll(void);
	error_flag ServiceDynamicAreaRenumber(int old_id, int new_id);
};
#endif //_Stream_H_
