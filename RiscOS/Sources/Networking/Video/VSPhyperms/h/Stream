/**************************************
 Stream.h

descibes standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/

#ifndef _Stream_H_
#define _Stream_H_

#include "Error.h"
#include "List.h"	// Parent List Class
#include "ServCtrl.h"	// control path
#include "Sink.h"	// Sink element for the stream
#include "Source.h"	// Source Element

  	// 08/11/1999 AR allowing multicast streams to have more tokens
  	// this now relies on a variable amount of tokens 0-4
#define MAX_NUM_MPEG_Tokens 	4

typedef enum {
  	source_multicast,
  	source_streamlive,
  	source_vod
} source_type;

// query 5.8
typedef enum {
	state_stop = 1,
	state_play,
	state_pause,
	state_fast_forward,
	state_fast_rewind,
	state_forward_skip,
	state_backward_skip,
	state_slow,
	state_step,
	state_still,			// beyond here is differing states of play
	state_streamlive,
	state_endreceived,
	state_prestart
} state_of_play;

// query 5.9
#define trick_fast_forward 	0x0001
#define trick_fast_rewind	0x0002
#define trick_forward_skip	0x0004
#define trick_backward_skip	0x0008
#define trick_forward_jump	0x0010
#define trick_backward_jump	0x0020
#define trick_normal_play	0x0040
#define trick_slow_play		0x0080
#define	trick_pause		0x0100
#define trick_step_play		0x0200
#define trick_jump_most_rec	0x0400
#define trick_still		0x0800

#define implemented_trick_modes	(trick_normal_play |\
				trick_forward_jump |\
				trick_backward_jump|\
				trick_normal_play  |\
				trick_slow_play	   |\
				trick_pause	   |\
				trick_step_play	   |\
				trick_pause	\
				)
// AR 11/11/1999 added a second semaphor to ensure mutual exclusion of get token
// and return token methods.
class StreamToken : public Error{
  public:
   semaphor			in_use;	 // this is a claimed not claimed boolean
   semaphor			allocating;
   int 				blocks_returned;
   NECBlock			*block;
   BitstreamBufferDescriptor	*mpeg_buffer;

  StreamToken(void);
  ~StreamToken(void);
};

typedef PlayElementRequest* PlayList;

class Stream : public ListObject
{
  friend StreamList;

  /*
  This defines a dynamic stream it is instantiated while a stream
  is to be expected from the server.  It contains a state that indicates
  its speed this avoids calls that aim to change the state in a manor
  of which it is incapable
  */

  private:
  	// 08/11/1999 AR allowing multicast streams to have more tokens
 	int	num_tokens_to_pass;		// this allows for a variable number of tokens
   	StreamToken buffers[MAX_NUM_MPEG_Tokens];

  	ULINT RTSP_stat_word, RTSP_code;	// rtsp codes.
  	ULINT RTSP_client_identity;		// used for getting options
  	ULINT RTSP_proto_identity;		// used for notifications
  	size_t amount_read;			// used for multiple reads of more info, contains what is left
  	char *moreInfo;				// used in the more info call

  	ULINT start_time, data_at_start;	// stats for this stream
  	ULINT acks_at_start, naks_at_start;	// used by stream list.stats on closure

  	ULINT buffer_blocks;			// if the mpeg player stalls it is better to start with
  	size_t srcNumBlocks, srcInitBlock;	// used to temporarily hold the block size.
   	ULINT from;				// jump position
   	ULINT endofstream;			// time criteria
   	ULINT fast_playback_ratio;		// used in time calculations
   	callback_flag 	callback_pending;	// this is used by the Stream List class
  	int 		comms_timeout;		// panic period from data not arriving
  	int		currentMPEG_scene;	// this is the scene that the MPEG player has
  	int		currentMPEG_playid;	// this is the playid of the MPEG player.
  	flags_word	stream_flags;		// boolean values manipulating stream actions.

  	void 		*pw;			// for callbacks (workspace pointer)
  	ULINT		trick_modes_available;	// trickmodes available to this stream
  	state_of_play 	state;			// state of play, current state of the stream
  	source_type	source;			// this is used in the case of jumping to stream live
  	LINT 		state_value;		// slow speed or the blocks that can be passed before blocking

  	LINT 		source_sd, server_sd;		// socket search criteria
  	ULINT		inet_udp_reenter, inet_tcp_reenter; // reentrancy
  	Sink    	mysink;          		// reference to sink
  	Source		*mysource;			// pointer to source
 	InternetObject 	*myserver;			// pointer to the control oject


  	inline ULINT	  trick_modes(void);
	error_flag 	  ServiceDynamicAreaRenumber(int old_id, int new_id);

	inline ULINT 	  getNECTime(void);			// NPTtime without rounding

	inline bool	  tokenfree(void);			// returns true if a token is free
   	inline error_flag test_empty_buffers(void);
   	inline void       reset_sink(play_mode mode);

	inline error_flag timeslice(Statistics *stats);				// callback handler avoiding too much activity in inet event
	inline error_flag server_inetevent(int code, int identity);
	inline error_flag source_inetevent(int code, Statistics *stats);
	inline error_flag MPEGInterrupt(int buffer_descriptor);			// returning buffers
	inline error_flag DummyAckCall(void);					// tell the server we are still alive
	inline error_flag swap_source(void); 					// changes stream live to stored
 	error_flag 	  change_state(state_of_play new_state);

 	error_flag	PostPresentationSetup(char** datablock = NULL);

  public:
	// Multicast
	Stream(int inet_timeout, InternetObject *server, int MPEGid, int source_recvspace,
		int NumBlocks, int BufferBlocks, int TCP_TimeOut, void *pwork);
	// VOD
 	Stream(int inet_timeout, int initial_block, int MPEGid, PlayList playlist, int play_num, Server* server,
 		int NumBlocks, int source_recvspace, int BufferBlocks, void *pwork, flags_word flags, int in_from = 0);
 	~Stream();
 					// delete only if MPEG modules don't own any memory
 	inline state_of_play getstate(void) { return state; }		// returns the state
 	error_flag 	     stop_stream(ULONG *new_block_number);	// sets the greatest block used

 	error_flag GetSinkHandle(void);	// call to Decoder
 	error_flag CheckEOS(int *play_state);	// returns the state of the stream
 	error_flag SetSpeed(int direction, int speed, int identity = 0);		// call to Decoder
 	error_flag SetPosition(int flags, int pos_time, bool do_statechange =true);	// call to Decoder
 	error_flag ReadNPT(ULINT *NPT_time);
 	error_flag GetMiscInfo(ULINT *reg_r0, misc_5_10 *ptr, int *size);

 	error_flag RTSP_getStatus(ULINT *reg_r0, ULINT *reg_r2);
	error_flag RTSP_getMoreInfo(int reason_code, char* buffer, int* size, int* copied_size);
	bool	   RTSP_requestinprogress(void) { return ((RTSP_stat_word & 0x02) ? true:false); }

 	void setRTSPClientId(ULINT id);

};

class StreamList : public List
{
  /*
  This extends the list class to make it specific to the stream
  values.  This can test that no two decoder handles have been issued before
  creating a new stream element with this handle.
  */
   public:
   	Statistics stats;

  	StreamList(void);
  	~StreamList(void) {};

  	error_flag Add(Stream *, int *);
  	error_flag Remove(int identifier);	// returns a boolean success value

	// poll events
	error_flag inetEvent(int code, int identifier, claim_flag *claim, void *pw);
	error_flag TimeSliceCall(void *pw);
	error_flag TimeSliceCallTickerTimeout(void *pw);
	error_flag MPEGInterrupt(int buffer_descriptor);
	error_flag DummyAckPoll(void);
	error_flag ServiceDynamicAreaRenumber(int old_id, int new_id);
};
#endif //_Stream_H_
