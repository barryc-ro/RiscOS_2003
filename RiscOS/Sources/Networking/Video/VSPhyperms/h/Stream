/**************************************
 Stream.h
	
descibes standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/

#ifndef _Stream_H_
#define _Stream_H_

#include "Error.h"
#include "List.h"	// Parent List Class
#include "ServCtrl.h"	// control path
#include "Sink.h"	// Sink element for the stream
#include "Source.h"	// Source Element

#define NUM_MPEG_Tokens 	2

#define MACRO_getFreeToken(a) \
	{if (buffers[0].in_use == free_token) {(a)=0;} else \
	{ if (buffers[1].in_use == free_token) {(a)=1;} else { (a) = -1;} }}	

	// this is the number of tokens passed between source and stream.
	// two is recommended as each is half a second of video.  The second
	// overlaps the edges of the first.
//#define STREAM_NAK_timeout	50	// defined as 3 * VSPhyperms$inettimeout
	// centiseconds, timeout after sending a nak before calculating the necessity
	// of sending others.
//#define STREAM_comms_timeout	50	// VSPhyperms$inettimeout
	// timeout by which we suppose no more information is on its way.  This is the
	// leading window which internet events push along.  if no internet events occur
	// within this window we assume that all the information we are expecting on this
	// databurst has either arrived or is lost.  If it has all arrived then an ACK
	// is in order and we are happy, if some has been lost then we will have to
	// send naks for the outstanding datagrams.
	// Set this value too low and increase the network traffic
	// Set it too high and the stream will dry up.
// query 5.8
typedef enum {
	state_stop = 1,
	state_play,
	state_pause,
	state_fast_forward,
	state_fast_rewind,
	state_forward_skip,
	state_backward_skip,
	state_slow,
	state_step,
	state_still,			// beyond here is differing states of play
	state_streamlive,
	state_endreceived,
	state_prestart
} state_of_play;

// query 5.9
#define trick_fast_forward 	0x0001
#define trick_fast_rewind	0x0002
#define trick_forward_skip	0x0004
#define trick_backward_skip	0x0008
#define trick_forward_jump	0x0010
#define trick_backward_jump	0x0020
#define trick_normal_play	0x0040
#define trick_slow_play		0x0080
#define	trick_pause		0x0100
#define trick_step_play		0x0200
#define trick_jump_most_rec	0x0400
#define trick_still		0x0800

#define implemented_trick_modes	(trick_normal_play |\
				trick_forward_jump |\
				trick_backward_jump|\
				trick_normal_play  |\
				trick_slow_play	   |\
				trick_pause	   |\
				trick_step_play	   |\
				trick_pause	\
				)

class StreamToken : public Error{
  public:
   semaphor			in_use;	 // this is a claimed not claimed boolean
   int 				blocks_returned;
   NECBlock			*block;
   BitstreamBufferDescriptor	*mpeg_buffer;
  
  StreamToken(void);
  ~StreamToken(void);
};

typedef PlayElementRequest* PlayList;

class Stream : public Error
{
  friend StreamList;
  
  /* 
  This defines a dynamic stream it is instantiated while a stream
  is to be expected from the server.  It contains a state that indicates
  its speed this avoids calls that aim to change the state in a manor
  of which it is incapable
  */

  private:
  	StreamToken buffers[NUM_MPEG_Tokens];
  	
  	unsigned int start_time, data_at_start;
  	unsigned int acks_at_start, naks_at_start;	// used by stream list
  	int step_times;
  	
  	int buffer_blocks;			// if the mpeg player stalls it is better to start with
   	unsigned int from, endofstream;				// time criteria
   	int fast_playback_ratio;
  	int source_sd, server_sd;		// search criteria
  	int comms_timeout;

  	void 		*pw;			// for callbacks
  	int		trick_modes;		// trickmodes available to this stream
  	state_of_play 	state;			// state of play, current state of the stream
  	Sink    	*mysink;          	// pointer to sink
  	Source  	*mysource;		// pointer to source
  	callback_flag 	callback_pending;		// this is used by the Stream List class
  	semaphor 	source_flag, server_flag;	// flags are to avoid inet re-entrancy

   	error_flag test_empty_buffers(void);

	error_flag timeslice(Statistics *stats);
	error_flag server_inetevent(void);

	error_flag MPEGInterrupt(int buffer_descriptor);
	error_flag DummyAckCall(void);
	error_flag ServiceDynamicAreaRenumber(int old_id, int new_id);
	  	
  public:
 	Server  *myserver;
  	
 	Stream(int inet_timeout, int initial_block, int MPEGid, PlayList playlist, int play_num, Server* server, 
 		int NumBlocks, int source_recvspace, int BufferBlocks, void *pwork, int in_from = 0, int in_to = 0);
 	~Stream();
 					// delete only if MPEG modules don't own any memory
 	inline state_of_play getstate(void) { return state; }
 	error_flag change_state(state_of_play new_state);
 		
 	error_flag GetSinkHandle(void);	// call to Decoder
 	error_flag CheckEOS(int *play_state);	// returns the state of the stream
 	error_flag SetSpeed(int direction, int speed);	// call to Decoder
 	error_flag SetPosition(int flags, int pos_time);  // call to Decoder
 	error_flag ReadNPT(unsigned int *NPT_time);		// call to Decoder
 	error_flag GetMiscInfo(int *reg_r0, misc_5_10 *ptr, int *size);
 	int getBlockVal(void);			// returns the greatest block used
 	
};


class StreamList : public List
{
  /*
  This extends the list class to make it specific to the stream
  values.  This can test that no two decoder handles have been issued before
  creating a new stream element with this handle.
  */
   public:
   	Statistics stats;
   	
  	StreamList(void);
  	~StreamList(void);
  	error_flag identify(Stream **item, int identifier);
  	error_flag Add(Stream *, int *);
  	error_flag Remove(int identifier);	// returns a boolean success value
 	
	// poll events
	error_flag inetEvent(int code, int identifier, claim_flag *claim, void *pw);
	error_flag TimeSliceCall(void *pw);
	error_flag MPEGInterrupt(int buffer_descriptor);
	error_flag DummyAckPoll(void);
	error_flag ServiceDynamicAreaRenumber(int old_id, int new_id);
};
#endif //_Stream_H_
