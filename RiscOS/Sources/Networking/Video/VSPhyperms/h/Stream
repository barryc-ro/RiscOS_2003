/**************************************
 Stream.h
	
descibes standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/

#ifndef _Stream_H_
#define _Stream_H_

#include "Error.h"
#include "List.h"	// Parent List Class
#include "ServCtrl.h"	// control path
#include "Sink.h"	// Sink element for the stream
#include "Source.h"	// Source Element

#define NUM_MPEG_Tokens 	2	// this is the number of tokens passed between source and stream
#define STREAM_NAK_timeout	150	// centiseconds, timeout after sending a nak before having a problem
#define STREAM_comms_timeout	25	// timeout by which we suppose no more information on its way.
// query 5.8
typedef enum {
	state_stop = 1,
	state_play,
	state_pause,
	state_fast_forward,
	state_fast_rewind,
	state_forward_skip,
	state_backward_skip,
	state_back_skip,
	state_slow,
	state_step,
	state_still,			// beyond here is differing states of play
	state_endreceived,
	state_prestart
} state_of_play;

// query 5.9
#define trick_fast_forward 	0x0001
#define trick_fast_rewind	0x0002
#define trick_forward_skip	0x0004
#define trick_backward_skip	0x0008
#define trick_forward_jump	0x0010
#define trick_backward_jump	0x0020
#define trick_normal_play	0x0040
#define trick_slow_play		0x0080
#define	trick_pause		0x0100
#define trick_step_play		0x0200
#define trick_jump_most_rec	0x0400
#define trick_still		0x0800

#define trick_modes	(trick_normal_play | trick_pause)

class StreamToken : public Error{
  public:
   semaphor			in_use;	 // this is a claimed not claimed boolean
   int	 			list_size;
   int 				num_blocks, blocks_returned;
   Bitstream_buffer_descriptor	*list;
   NECBlock			*block;
   NECBlockHeader		*block_header;
  
  StreamToken(void);
  ~StreamToken(void);
  
  error_flag AllocList(int max_dgrams);
};

typedef PlayElementRequest* PlayList;

typedef struct{
  	USHORT h_pixels;	// 16 bits
  	USHORT v_pixels;
  	ULONG  play_time;	// 32 bits
  	USHORT status_word;
  	USHORT scene_number;
  	ULONG  head_time;
  	ULONG  end_time;
  	ULONG  encode_time;
  	ULONG  bitrate;
} misc_5_10;

class Stream : public Error
{
  friend StreamList;
  
  /* 
  This defines a dynamic stream it is instantiated while a stream
  is to be expected from the server.  It contains a state that indicates
  its speed this avoids calls that aim to change the state in a manor
  of which it is incapable
  */

  private:
  	StreamToken buffers[NUM_MPEG_Tokens];
  	
  	NECBlockHeader	most_significant_block;
  	
  	int buffer_blocks;			// if the mpeg player stalls it is better to start with
   	int from, to;				// time criteria
   	int fast_playback_ratio;
  	int source_sd, server_sd;		// search criteria

  	void 		*pw;			// for callbacks
  	state_of_play 	state;			// state of play, current state of the stream
  	Sink    	*mysink;          	// pointer to sink
  	Source  	*mysource;		// pointer to source
  	callback_flag 	callback_pending;		// this is used by the Stream List class
  	semaphor 	source_flag, server_flag;	// flags are to avoid inet re-entrancy

   	error_flag test_empty_buffers(void);
   	error_flag NECBlockToMPEGBufferList(StreamToken *buffer);
	error_flag MPEGBufferListToNECBlock(StreamToken *buffer);
 
	error_flag timeslice(void);
	error_flag server_inetevent(void);

	error_flag MPEGInterrupt(int buffer_descriptor);
	error_flag DummyAckCall(void);
	error_flag ServiceDynamicAreaRenumber(int old_id, int new_id);
	  	
  public:
 	Server  *myserver;
  	
 	Stream(int initial_block, int MPEGid, PlayList playlist, int play_num, Server* server, int NumBlocks, 
 					int BufferBlocks, void *pwork, int in_from = 0, int in_to = 0);
 	~Stream();
 					// delete only if MPEG modules don't own any memory
 	state_of_play getstate(void) { return state; }
 	error_flag change_state(state_of_play new_state);
 		
 	error_flag GetSinkHandle(void);	// call to Decoder
 	error_flag CheckEOS(int *play_state);	// returns the state of the stream
 	error_flag SetSpeed(int direction, int speed);	// call to Decoder
 	error_flag SetPosition(int flags, int pos_time);  // call to Decoder
 	error_flag ReadNPT(int *NPT_time);		// call to Decoder
 	error_flag GetMiscInfo(int *reg_r0, misc_5_10 *ptr, int size);
 	int getBlockVal(void);			// returns the greatest block used
 	
};


class StreamList : public List
{
  /*
  This extends the list class to make it specific to the stream
  values.  This can test that no two decoder handles have been issued before
  creating a new stream element with this handle.
  */
   public:
  	StreamList(void);
  	~StreamList(void);
  	error_flag identify(Stream **item, int identifier);
  	error_flag Add(Stream *, int *);
  	error_flag Remove(int identifier);	// returns a boolean success value
 	
	// poll events
	error_flag inetEvent(int code, int identifier, claim_flag *claim, void *pw);
	error_flag TimeSliceCall(void *pw);
	error_flag MPEGInterrupt(int buffer_descriptor);
	error_flag DummyAckPoll(void);
	error_flag ServiceDynamicAreaRenumber(int old_id, int new_id);
};
#endif //_Stream_H_
