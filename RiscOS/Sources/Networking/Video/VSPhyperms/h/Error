/**************************************
 Error.h

descibes standard Error class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

// Note that this is defined to be a super class
// as such if the need arises a debug element can be
// included into the error class.
**************************************/

#ifndef _Error_H_
#define _Error_H_

#include <stdlib.h>
#include "kernel.h"     // error structure
extern "C" {
#include "VSPHdr.h"
}

#define DEBUG           // global definition as this is super class

#ifdef DEBUG
#include <stdarg.h>
#define DEBUG_FILE			"Debug:VSPHyperDg"
#endif

#define FILENAME_MESSAGES               "VSPHyper:Messages"

#define XDebugMod_Send  0x06c440

#define VSP__ErrorBase                  (0x815d00)

/* These values map directly to Exx messages in the Messages file.  Note that it is
 * not so inefficient to require construction of such large constants as errors should
 * be extremely rare!
 */
typedef enum {
        VSP_Alloc                       = VSP__ErrorBase,
        VSP_Error,
        VSP_BadSWI,
        VSP_Unique,
        VSP_UnknownObj,
        VSP_BadErr,
        VSP_MPEGErr,
        VSP_BadServer,
        TCP_UnknownService,
        TCP_BadPortSpecification,
        TCP_UnknownServer,
        TCP_SocketError,
        TCP_ConnectionRefused,
        TCP_ReadFail,
        TCP_SendFail,
        VSP_InvalidValue,
        VSP_NoDataAvailable,
        VSP_UnknownMessage,
        VSP_ServerCertError,
        VSP_NoReadEnvironment,
        VSP_ServerError,
        VSP_SourceUninit,
        VSP_DatagramSizeError,
        VSP_BadBlock,
        VSP_CantDeleteSharedMemory,
        VSP_Unimplemented,

        // This value must appear at the end of the declaration.
        VSPMaxError
} VSPErrorCodes;

#define ErrorOccurred   0               // this allows for pointers
#define NoError         1

/* class MessagesFile.  This is the class for cacheing a messages file in the RMA
 * for the duration of module execution.  Module initialisation code needs to
 * call the static init method before any errors can be generated, and bail out
 * of module if it fails to initialise.  finalise method must be called on module
 * finalisation to complete tidying up.
 */
class MessagesFile {
        private:
                // MessageTrans descriptor is 16-byte opaque block
                struct {
                        char _opaque_[16];
                } msgtrans_desc;
                // Points to cached messages file data
                char *data;

                // Constructors and destructor - deliberately private so that
                // only the init and finalise methods can invoke them
                MessagesFile(const char *filename);  // Constructor
                ~MessagesFile();                     // Destructor
                MessagesFile(const MessagesFile&);   // unimplemented copy ctor

        public:

                // Allow the main module to initialise us and close us down
                // init returns zero if it failed to initialise the message object.
                static int init();
                static void finalise();

                _kernel_oserror *ErrorLookup(_kernel_oserror *e, int errnum,
                        const char *p1 = 0, const char *p2 = 0,
                        const char *p3 = 0, const char *p4 = 0);
};


class ErrorBlk
{
  /*
  This uses the standard RiscOS error construct
  on error at SWI level R0 will point to this
  */
  private:
        _kernel_oserror err;
  public:
        ErrorBlk(char *, int token);            // constructor
        ErrorBlk(const VSPErrorCodes);     	// constructor
        ErrorBlk(const ErrorBlk& errblk);       // copy constructor
        ErrorBlk(_kernel_oserror *ro_err);      // copy from sys construtor
        ErrorBlk& operator =(const ErrorBlk& errblk);

        int ErrorNum(void);			// returns the error number

#ifdef DEBUG
        void Print(void);
        void Debug(char *string);
#endif
};

class Error
{
  /*
  This works as follows all classes inherit from this class, this means that
  all classes have this functionality.  When one of a classes own methods
  creates an error then the error is created and notified.  when a method
  creates an error it creates an error block and assigns this pointer to it,
  this error remains with that object until it is forcebly removed
  ie corrected.

  If an error occurs in another object the call to that objects
  'ReturnCopyOfError' method will return a copy of that error, as such
  it can be passed up the chain of command or repaired. This method
  returns a reference to a created object that the calling object can
  own this error structure is NOT SHARED.

  if (call fails){
        err = &(<object>.ReturnCopyOfError());
        ....fix and delete or return and halt calls;
  }
  */

  protected:
        ErrorBlk *err;
  public:
        Error(void);            // constructor, assigns null pointer
        ~Error(void);           // destructor, ensures error is freed

                                // returns reference to a new error block
        ErrorBlk& ReturnCopyOfError(void);
        void    RemoveErr(void);        // deletes the error block,(ie fixed)
        void    MakeError(char *s_token, int token);   // error discovered
        void    MakeError(_kernel_oserror *ro_err);   // from system error
        void    MakeError(const VSPErrorCodes);       // VSP error
        int     ErrorExists(void);      // boolean error occured yes/no
        int	ErrorNum(void);		// return the error number

        void    PrintError(void);       // debug dump error

#ifdef DEBUG
        void	Debug(char *format, ...);
#endif
};
#endif
