/**************************************
 Server.c++

implements standard Server class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include <string.h>
#include "NECstruct.h"
#include "ServCtrl.h"

#include "kernel.h"
#include "swis.h"

// this routine construct the connection to the specified server on the
// specified port.  It sets up the SocketDescriptor (of class Socket)
// to act as the communications end-point.  All socket operations may
// only be performed through the Socket methods

ServerList::~ServerList(void){
  for(int i = 0; i < CurrentSize; i++){
    	if (object[i] != NULL) {
  		delete ((Server*)object[i]);
  		object[i] = NULL;
  	}
  }
  ExpectedSize = CurrentSize = 0;
}

error_flag
ServerList::Remove(int identifier)
{
  int i =0;	// count value
  error_flag result = ErrorState();
  
  --ExpectedSize;
  
  if (result != ErrorOccurred) {
  
  	while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  	if (i == CurrentSize)
  		result = MakeError(VSP_UnknownObj);

	if (result != ErrorOccurred){
	  	if (!( ((Server*)object[i])->stream_uses() ))
  			delete (Server*)object[i];	// delete if not used in a stream
  		else
  			((Server*)object[i])->clear_interface_owner();
  			
  		object[i] = NULL;
  
  		while (i < CurrentSize -1){
    			object[i] = object[i+1];
    			identifiers[i] = identifiers[i+1];
    			i++;
  		}
  		--CurrentSize;
  
  		if (decreasesize() != ErrorOccurred)		// this does test for sufficient decrease in size
  			result = ErrorOccurred;
  	}
  }
  return ErrorOccurred;
}

//--------------------------------------------- Server Specific ---------------------------------
error_flag
Server::setSocketError(int socket_result)
{
    error_flag result = ErrorState();
        
        if ((result != ErrorOccurred)&&(socket_result < 0)) {
                switch (errno) {
                        default:
                                result = MakeError(IP_SocketError);
#ifdef DEBUGLIB                                
                                Debug("tcp errno = %i", errno);
#endif                                
                                break;
                        case ECONNREFUSED:
                                result = MakeError(IP_ConnectionRefused);
                                break;
                        case ENOENT:
                                result = MakeError(IP_UnknownServer);
                                break;
                        case EINVAL:
                                result = MakeError(IP_BadPortSpecification);
                                break;
                        case ENOBUFS:
                        	result = MakeError(IP_NoBuffer);
                        	break;
                        case EWOULDBLOCK:
                        	result = NoError;
                }
        }
        else {
                result = NoError;
        }
        return result;
}

//--------------------------------------------------------
error_flag
Server::send_assetlist_request(ULINT select_flags, size_t start, size_t number)

{
  AssetListRequest request;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_assetlist_request;

  request.command_length = sizeof(AssetListRequest)-8;		// size of structure - header.
  request.certification_code = certification_code;
  request.request_type = 0x01;
  request.continuity_flag = 0x01;
  request.asset_status_selection = (UCHAR)(select_flags&0xff);
  request.asset_type_selection = (UCHAR)((select_flags>>8)&0xff);
  request.starting_entry = start;
  request.number_of_entries = number;
  request.sort_type =  (select_flags>>16)&0xff;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0x00;

  if (hton_structure(&request, map_AssetListRequest, AssetListRequest) == ErrorOccurred){
  	return MakeError(IP_SendFail);
  }
  
  return SendData(&request, sizeof(AssetListRequest));
}

error_flag
Server::get_assetlist_response(size_t *number, AssetIDDescriptor *buffer, size_t *buffer_size)
{
  // this pans out as r4, r5, r6
  
  PacketHeader header;
  AssetListResponseHeader alr_header;
  size_t asset_count;
  error_flag result = ErrorState();

  if (result != ErrorOccurred)
  	result = GetData(&header, sizeof(PacketHeader));
  	
  if ((result != ErrorOccurred)&&(ntoh_structure((void*)&header, map_PacketHeader, PacketHeader) == ErrorOccurred))
  	result = MakeError(IP_ReadFail);
  
  if ((result != ErrorOccurred)&&(header.command_number != COMMAND_assetlist_response))
    	result = MakeError(VSP_UnknownMessage);
    	
  if (result != ErrorOccurred)
  	result = GetData(&alr_header, sizeof(AssetListResponseHeader));

  if ((result != ErrorOccurred)&&(ntoh_structure(&alr_header, map_AssetListResponseHeader, AssetListResponseHeader) == ErrorOccurred))
    	result = MakeError(IP_SendFail);

  if ((result != ErrorOccurred)&&(alr_header.certification_code != certification_code++))    
  	result = MakeError(VSP_ServerCertError);
  
  if (result != ErrorOccurred){
  	if ((*number) == 0) // if a request for the number of assets
  		(*number) = (size_t)alr_header.total_number_of_assets;
  	else {   	
  		size_t readsize = (size_t)(header.command_length - sizeof(AssetListResponseHeader));
  	  	// extract the data from the socket.
  	  	result = GetData(buffer, readsize);

		for ( asset_count = 0; asset_count < ( readsize/sizeof(AssetIDDescriptor) ); ++asset_count) {
 		
	  		if (ntoh_structure(&(buffer[asset_count]), map_AssetIDDescriptor, AssetIDDescriptor) == ErrorOccurred){
	  			result = MakeError(IP_ReadFail);
	  		}
	  		
	  		if (result == ErrorOccurred)
	  			break;
			/* 		
	    		AssetIDDescriptor *asset = &buffer[asset_count];
    		
	  		Debug("asset id (%i)", asset->asset_id);
	        	Debug("last update%8.8X%8.8X", (int)asset->time_of_last_update[8], (int)asset->time_of_last_update);     
	        	Debug("registration %i", asset->registration);         
	        	Debug("bitrate %i", asset->bit_rate);            
	        	Debug("asset type %i", asset->asset_type);         
	        	Debug("encoding %i", asset->encoding);           
	        	Debug("block_length %i", asset->block_length);      
	        	Debug("total time %i", asset->total_time);       
	        	Debug("short title %s", asset->video_title); 
	        	Debug("long title  %s", asset->full_title); 
	        	Debug("ff time  %i", asset->ff_time);     
	        	Debug("rw time  %i", asset->rw_time);     
	        	Debug("video type  %i", asset->video_type);    
	        	Debug("video status  %i", asset->video_status);
			*/
	  		(*buffer_size) -= sizeof(AssetIDDescriptor);
	 		//asset_count++;
	  	}// while
	  	(*number) = asset_count;
	  }
  }
  if ((result != ErrorOccurred)&&(alr_header.result != 0))
  	result = MakeError(VSP_ServerError);
   		      	  
  return result;
}

error_flag
Server::send_scenelist_request(ULINT asset_id)
{
  SceneListRequest request;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_scenelist_request;
  request.command_length = sizeof(SceneListRequest)-8;
  request.certification_code = certification_code;
  request.asset_id = asset_id;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0;

  if (hton_structure(&request, map_SceneListRequest, SceneListRequest) == ErrorOccurred){
  	return MakeError(IP_SendFail);
  }
  
  return SendData((void*)&request, sizeof(SceneListRequest));
}

error_flag
Server::get_scenelist_response(size_t *number, SceneInformationDescriptor *buffer, size_t *buffer_size)
{
  // reads a maximum of number of assets into the buffer 
  error_flag result = ErrorState();
  SceneListHeader header;
  size_t asset_count;
 
  if (result != ErrorOccurred)
  	result = GetData((void*)&header, sizeof(SceneListHeader));

  if ((result != ErrorOccurred)&&(ntoh_structure(&header, map_SceneListHeader, SceneListHeader) == ErrorOccurred)){
    	result = MakeError(IP_SendFail);
  }

  if ((result != ErrorOccurred)&&(header.command_number != COMMAND_scenelist_response)) {
    	result = MakeError(VSP_UnknownMessage);
  }

  if ((result != ErrorOccurred)&&(header.certification_code != certification_code++)){
  	result = MakeError(VSP_ServerCertError);
  }
  if (result != ErrorOccurred){
  	if ((*number) == 0)
  		(*number) = (size_t)header.number_of_scenes;
  	else {
  	  	// extract data from the socket
  	  	
  	  	size_t readsize = (size_t)(header.command_length - ( sizeof(SceneListHeader)-sizeof(PacketHeader) ));

	  	result = GetData(buffer, readsize);
    	
  	  	for ( asset_count = 0; asset_count < (readsize/sizeof(SceneInformationDescriptor)); ++asset_count) {   		  
  		
  			if (ntoh_structure(&(buffer[asset_count]), map_SceneInformationDescriptor, SceneInformationDescriptor) == ErrorOccurred){
  				result = MakeError(IP_ReadFail);
  			}
  			
  			if (result == ErrorOccurred)
	  			break;
	  		/*	
	  		SceneInformationDescriptor *scene = &buffer[asset_count];
	  		Debug("scene %i, asset_id %i, from %i to %i", asset_count, scene->asset_id, scene->start_time, scene->end_time);
	  		*/
  			(*buffer_size) -= sizeof(SceneInformationDescriptor);
  		}// while
  	 	(*number) = asset_count;
  	}
  }
  
  if ((result != ErrorOccurred)&&(header.result != 0)){
    return MakeError(VSP_ServerError);
  }
  return NoError;
}

error_flag
Server::send_assetpresentation_request(ULINT init_value, PlayElementRequest playlist[], size_t size, struct in_addr ipaddr, ULINT port)
{
  AssetPresentationRequest request;
  int i;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_assetpres_request;

  request.command_length = sizeof(AssetPresentationRequest)-8 + (size * sizeof(PlayElementRequest));
  request.certification_code = certification_code;
  request.client_type = 1; 				// as per specification
  request.packet_interval = 0;	// (visit)		// packet transition interval environment var
  request.initial_packet_num = init_value;
  MAX_requested_block = init_value -1;
  request.my_udp_port = port;				// source.port_num;
  if (size == 1)
  	request.playlist_num = 0;
  else
  	request.playlist_num = size;
  request.QOS_control = 0;				// as per specification

  unsigned int systime;
  _swix(OS_ReadMonotonicTime, _OUT(0), &systime);

  sprintf(((char*)&(request.log_comment)), "STB LOG:%i, timestamp in centiseconds\0",systime);
#ifdef DEBUGLIB
  Debug("STB LOG: timestamp in centiseconds %i",systime);
#endif  
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = 0;

  if (hton_structure(&request, map_AssetPresentationRequest, AssetPresentationRequest) == ErrorOccurred) {
         return MakeError(IP_SendFail);
  }

  request.my_IP_address = (int)ipaddr.s_addr;		// my_IP_address of source object;

  for (i = 0; i < size; i++){
  	if (hton_structure(&(playlist[i]), map_PlayElementRequest, PlayElementRequest) == ErrorOccurred){
  	  	return MakeError(IP_SendFail);
  	}
  }  
        
  if ( 	(SendData(&request, sizeof(AssetPresentationRequest)) == ErrorOccurred) ||
  	(SendData(playlist, sizeof(PlayElementRequest)*size) == ErrorOccurred) ){// ||
  	return MakeError(IP_SendFail);
  }

  return NoError;
}

error_flag
Server::get_assetpresentation_response(struct in_addr *ipaddr, ULINT *port, ULINT *stream_time, 
						ULINT *dgram_size, ULINT *bitrate, ULINT *fast_playback_ratio)
{
  PacketHeader header;
  AssetPresentationResponse response;
  size_t buffersize;
  UCHAR *buffer;

  if (GetData((void*)&header, sizeof(PacketHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&header, map_PacketHeader, PacketHeader) == ErrorOccurred) {
    	return MakeError(IP_ReadFail);
  }

  if (header.command_number != COMMAND_assetpres_response) {
    	return MakeError(VSP_UnknownMessage);
  }
    // certification code
  if (GetData((void*)&response, sizeof(AssetPresentationResponse)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&response, map_AssetPresentationResponse, AssetPresentationResponse) == ErrorOccurred) {
    	return MakeError(IP_ReadFail);
  }

  if (response.certification_code != certification_code++){
  	return MakeError(VSP_ServerCertError);
  }
  
  buffersize = (size_t)(header.command_length) - sizeof(AssetPresentationResponse);

  if (buffersize != 0) {	// get scene information
   	if ( (buffer = new UCHAR[buffersize]) == NULL)
	    return MakeError(VSP_Alloc);
  	else {
		if (GetData((void*)buffer, buffersize) == ErrorOccurred)
  			return ErrorOccurred;	//Null
  		delete buffer;
  	}
  } // scene info exists
  
  ipaddr->s_addr = (u_long) response.server_IP;
  *port = response.server_port;
  //if (response.datagram_size != 0)
  	*dgram_size = assetresponse_dgram_size = response.datagram_size;
  //else
  //	*dgram_size = assetresponse_dgram_size = SocketDescriptor.getDgramSize();
  
  *bitrate = response.bit_rate;
  *fast_playback_ratio = (ULINT)response.ff_ratio;
  *fast_playback_ratio |= (ULINT)((response.fast_playback)<<24);
  
  if (response.video_status != 0)
  	(*stream_time) = 0xFFFFFFFF;
  else
  	(*stream_time) = (unsigned int)response.total_time;
  
  if (response.result != 0){
    return MakeError(VSP_ServerError);
  }

  return NoError;
}

error_flag
Server::send_playback_request(ULINT state_id, ULINT MAX_storableBlock, ULONG AckSeq, ULINT time, ULINT mode)
{
  PlayBackRequest request;
 
  if ((MAX_storableBlock-AckSeq) > NEC_databurstval){
#ifdef DEBUGLIB
	Debug("invalid value in play request, %i-%i", MAX_storableBlock, AckSeq);
#endif	    
    return MakeError(VSP_InvalidValue);
  }
  
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_playback_request;

  request.command_length = sizeof(PlayBackRequest) - 8;
  request.certification_code = certification_code;
  request.playback_id = state_id;
  request.playback_mode = mode;
  request.time_mode = 0;		// always normal ?? time specified means nothing
  request.time_spec = time;
  request.skip_rate = 0;
  request.data_type = 0;
  request.data_rate = 0;
  request.max_received = AckSeq;
  request.request_sequence_num = MAX_requested_block = MAX_storableBlock;
  request.datagram_size = 0;
  request.play_live_margin = 0;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = 0;

  if (hton_structure((void*)&request, map_PlayBackRequest, PlayBackRequest) == ErrorOccurred){
  	return MakeError(IP_SendFail);
  }	
  
  if (SendData((void*)&request, sizeof(PlayBackRequest)) == ErrorOccurred)
  	return ErrorOccurred;
  	    
  return NoError;
}

error_flag
Server::get_playback_response(ULINT *result)
{
  error_flag  e_result = NoError;
  PlayBackResponse response;
  
  if (GetData((void*)&response, sizeof(PlayBackResponse)) == ErrorOccurred)
  	e_result = ErrorOccurred;	//Null

  if ((e_result != ErrorOccurred)&&(ntoh_structure(&response, map_PlayBackResponse, PlayBackResponse) == ErrorOccurred)) {
    	e_result = MakeError(IP_ReadFail);
  }
  
  if ((e_result != ErrorOccurred)&&(response.certification_code != certification_code++)){
  	e_result = MakeError(VSP_ServerCertError);
  }
    
  if ((e_result != ErrorOccurred)&&(response.result != 0)){
    *result = response.result;
    e_result = MakeError(VSP_ServerError);
  }
  
#ifdef DEBUGLIB
	Debug("playback response %i, wait %i", response.result, response.wait);
#endif 

  return e_result;
}
 
//--------------------------------------------------------public methods---------------

Server::Server(char *server, char *port, ULINT timeout):Error()
{
  ControlPortNumberNotification		cpnn;
  Socket				connection_port;

  timeout_period = timeout;
  message_pipe = NULL;
  
#ifdef DEBUGLIB
  Debug("create server link");
#endif
  // connect to ping socket.
  connection_port.creat();
  SocketDescriptor.creat();
  
  connection_port.connect(server, port);
  
  if (connection_port.valid()){
    	int data_read;
    	
    	data_read = connection_port.read( &cpnn, sizeof(ControlPortNumberNotification) );
    	
    	if (data_read == sizeof(ControlPortNumberNotification)){

    		setSocketError(SocketDescriptor.connect(server, (int)(cpnn.connection_port_number>>16)));
    		
    		setSocketError(SocketDescriptor.makeNonBlocking());
    		  
    		  // initialise variables
  		comms_flag = no_comms;
  		// certification_code is never initialised as it is a comparitive value its initial value doesn't matter
    		ack.interface_number = 0;
  		ack.route_type = 0;
  		ack.command_number = COMMAND_ACK;
 		ack.command_length = sizeof(ACK_Block)-8;
  		ack.certification_code = 0;	// not used
  		ack.data_rate = 0;		// not used
 		ack.RFU[0] = ack.RFU[1] = ack.RFU[2] = ack.RFU[3] = ack.RFU[4] = 0x00;
 	  	hton_structure(&ack, map_ACK_Block, ACK_Block);
	  	//NAK initialise
  		nak.interface_number = 0;
  		nak.route_type = 0;
  		nak.command_number = COMMAND_NAK;
 	 	nak.command_length = sizeof(NAK_Block)-8;
 	 	nak.certification_code = 0;	// not used
 	 	nak.RFU[0] = nak.RFU[1] = nak.RFU[2] = nak.RFU[3] = nak.RFU[4] = 0x00;
 	 	hton_structure(&nak, map_NAK_Block, NAK_Block);
    	}
    	else {
    		setSocketError(data_read);
    	}
  }
  else
  	MakeError(IP_SocketError);
} 

Server::~Server()
{
#ifdef DEBUGLIB
  Debug("delete control socket +");
#endif  
  SocketDescriptor.close();
  if (message_pipe_exists())
  	delete message_pipe;
}

error_flag
Server::getSocketDescriptor(int *sock)
{
    if (!SocketDescriptor.valid()) {
        return MakeError(IP_SocketError);
    }
    *sock = SocketDescriptor.getSocketDescriptor();
    return NoError;
}


error_flag
Server::SendData(void *buffer, size_t size)
{
  error_flag result = ErrorState();

  ULINT t1, t2;
  UBYTE *buf_ptr = (UBYTE*)buffer;
  size_t remaining_data = size;
 	
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
  
  do {	
    	int data_written;
  	
	if (result == ErrorOccurred)
		break;
			
  	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
    	  	
    	data_written = SocketDescriptor.write(buf_ptr, remaining_data);
    
  	if ( (int)(remaining_data) > data_written )
    		setSocketError(SocketDescriptor.wait_write((unsigned int)((timeout_period+50)/100)));
    
    	if ( data_written > 0) {
    		remaining_data -= data_written;
    		buf_ptr += data_written;
    	  	t1 = t2;
    	}

    	if (data_written < 0){
    		result = setSocketError(data_written);
    	}
    	
    	if (t2 > (t1 + timeout_period)){
    	  	result = MakeError(IP_TimeOutOnCommunication);
    	}
    	  	
  } while (remaining_data > 0);


  return result;
}

error_flag
Server::GetData(void *buffer, size_t size)
{
  error_flag result = ErrorState();
  
  ULINT t1, t2;
  
  UBYTE *buf_ptr = (UBYTE*)buffer;
  size_t remaining_data = size;
 	
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
  	
  do {
    	int data_read;
    	
  	if (result == ErrorOccurred)
  		break;
  		
  	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
    	  	
    	data_read = SocketDescriptor.read(buf_ptr, remaining_data);
    	  
    	if ( (int)(remaining_data) > data_read )
    		setSocketError(SocketDescriptor.wait_read((unsigned int)((timeout_period+50)/100)));
    		
    	if ( data_read > 0) {
    	  	
    		remaining_data -= data_read;
    		buf_ptr += data_read;
    	  	t1 = t2;
    	}
   		
    	if (data_read < 0){
    		result = setSocketError(data_read);
    	}
    	
    	if (t2 > (t1 + timeout_period)){
    	  	result = MakeError(IP_TimeOutOnCommunication);
    	}
    	  	
  }while (remaining_data > 0);
  
  return result;
}

#ifdef DEBUGLIB
size_t
Server::ReadDataToDebug(void)
{
  int data;
  size_t size, size_total = 0;
  SocketDescriptor.makeNonBlocking();
      
    while ( (size = SocketDescriptor.read(&data, sizeof(int))) == sizeof(int) ) {
    	size_total += size;
    	Debug("data %8.8X", ntohl(data) );
    }
        
    if (size == -1)    
    	Debug("data errno %i", errno);
    	
  SocketDescriptor.makeBlocking();
  return size_total;
} 
#endif  

error_flag
Server::PeekHeader(UCHAR *command)
{
  PacketHeader header;

    if (SocketDescriptor.read(&header, sizeof(PacketHeader), MSG_PEEK) != sizeof(PacketHeader)) {
    	return ErrorOccurred;
    }
    *command = header.command_number;
    return NoError;
} 
 
error_flag
Server::inetevent(UCHAR *event, ULINT *result, ULINT play_mode)
{
  
  *result = 0;
  
  if (PeekHeader(event) == ErrorOccurred){
    return NoError;	// no data
  }
  
  switch (*event) {
  	case COMMAND_startend_notification:
  		{
  		StartEndNotification notify;
  		
  			if (GetData(&notify, sizeof(StartEndNotification)) == ErrorOccurred)
    				return ErrorOccurred;
    			if (ntoh_structure(&notify, map_StartEndNotification, StartEndNotification) == ErrorOccurred){
    				return MakeError(IP_ReadFail);
    			}
    			if (notify.special_playbackID == play_mode)
    				*result = (int)notify.trans_block_num;
    			else
    				(*event) = 0;
    		}
    	        break;
    	case COMMAND_playback_response:
    		if (get_playback_response(result) == ErrorOccurred)
    			return ErrorOccurred;
    		break;
    	case COMMAND_assetend_response:
   		{
   			AssetEndResponse response;
   			if ((GetData((void*)&response, sizeof(AssetEndResponse)) == ErrorOccurred))
   				return ErrorOccurred;
			if ((ntoh_structure(&response, map_AssetEndResponse, AssetEndResponse) == ErrorOccurred)) {
     				return MakeError(IP_ReadFail);
   			}
   	
   			if ((response.certification_code != certification_code++)){
   				return MakeError(VSP_ServerCertError);
   			}
   			
   			*result = response.result;
#ifdef DEBUGLIB
   			if (ErrorExists())
				Debug("asset end result (%i)", response.result);
   			else
   				Debug("timeout on receiving asset end %i words in buffer", ReadDataToDebug());
#endif   
                }
    		break;
    	default:

#ifdef DEBUGLIB    
    		Debug("TCP: inet ignore unknown command %2.2X\n", *event);
    		ReadDataToDebug();
#else
		{
  		int buffer;
    			while (SocketDescriptor.read(&buffer, 4)==4);
    		}
#endif    		
    		break;
    		
  }
  return NoError;
}

error_flag
Server::SendAck(ULINT MAX_storableBlocks, ULINT MAX_complete_block, ACK_type datatype)
{
  error_flag result = NoError;
  
  	ack.data_type =    (LINT)ntohl(datatype);
  	ack.min_sequence = (ULINT)ntohl(MAX_complete_block);
  	ack.max_sequence = (ULINT)ntohl(MAX_storableBlocks);
  		
  	comms_flag = comms;		// communicated with server;
  	
  	int size = SocketDescriptor.write((void*)&ack, sizeof(ACK_Block));
  	if (size < 0){
#ifdef DEBUGLIB  	  
  	  	Debug("error sending ACK %i", errno);
#endif  	  	
     		result = setSocketError(size);
     		if (ErrorNum() == IP_NoBuffer){
  			RemoveErr();
  		}
  	}
  	else
  		MAX_requested_block = (MAX_storableBlocks);
  		
  return result;
}

error_flag
Server::SendNak(ULINT BlockStart, LINT DatagramStart, ULINT BlockEnd, LINT DatagramEnd)
{
  	nak.BlockStart =    (ULINT)ntohl(BlockStart);
  	nak.DatagramStart = (LINT)ntohl(DatagramStart);
  	nak.BlockEnd =      (ULINT)ntohl(BlockEnd);
 	nak.DatagramEnd =   (LINT)ntohl(DatagramEnd);

	comms_flag = comms;		// communicated with server;
	
  	int size = SocketDescriptor.write((void*)&nak, sizeof(NAK_Block));
  		
  	if (size < 0){
#ifdef DEBUGLIB  		  
  	  	Debug("error sending NAK %i", errno);
#endif  		  	
  		if (ErrorNum() == IP_NoBuffer){
  			RemoveErr();
  		}
  	}
  			
  return ErrorState();	
}

error_flag
Server::GetAssetList(_kernel_swi_regs *regs)
{
  // register usage
  // r2 = selection flags
  // r3 = start
  // r4 = number of entries;
  // r5 = buffer
  // r6 = size of r5
  
  error_flag result = ErrorState();
  
  if (  (result != ErrorOccurred)&&(regs->r[4] == 0)&&
  	(( send_assetlist_request(regs->r[2], 0, 0) == ErrorOccurred) ||
  	    (get_assetlist_response((size_t*)&(regs->r[4]), NULL, 0)== ErrorOccurred)) )
  		result = ErrorOccurred;		
  
  if ((result != ErrorOccurred)&&(regs->r[5] == 0)){
    	regs->r[6] = regs->r[4] * sizeof(AssetIDDescriptor);
  }
  else {
  	// read r4 assets whilst avoiding overflowing the socket buffer
    	size_t expected_num_assets = (size_t)regs->r[4];
    	AssetIDDescriptor *buffer_offset = (AssetIDDescriptor*)regs->r[5];
    	
	// this is the number of entries that can be read at once without overflow
    	int number_entries = (int)((SocketDescriptor.getTCPrecvspace()) - 
    				(sizeof(PacketHeader)+sizeof(AssetListResponseHeader)))/sizeof(AssetIDDescriptor); 
    	
    	while ((result != ErrorOccurred)&&(regs->r[4] > 0)){
    	  
    	  	if (regs->r[4] < number_entries)
    	  		number_entries = regs->r[4];
    	  		
  		expected_num_assets = number_entries;	// this is the number of assets that we expect to receive

 		if ((result != ErrorOccurred)&&(( send_assetlist_request(regs->r[2], regs->r[3], expected_num_assets) == ErrorOccurred) ||
  	    		(get_assetlist_response((size_t*)&expected_num_assets, buffer_offset, (size_t*)&(regs->r[6])) == ErrorOccurred)))
  			result = ErrorOccurred;
  		else {
  		  	regs->r[4] -= expected_num_assets;		// decrement request count
  		  	if (regs->r[3] == 0)
  		  		regs->r[3] = 1;
  		  	regs->r[3] += expected_num_assets;		// increment start position
  		  	buffer_offset += expected_num_assets;
  		}
  				
#ifdef DEBUGLIB  		
  		Debug("Asset list: read %i size %i new start %i", expected_num_assets, regs->r[6], regs->r[3]);
#endif
   		if (expected_num_assets < number_entries)
  			break;
  	}
 	regs->r[4] = (buffer_offset - (AssetIDDescriptor*)regs->r[5]);
  }
  return result;
}

error_flag
Server::GetSceneAssetList(_kernel_swi_regs *regs)
{
  error_flag result = ErrorState();
   
  if (  (result != ErrorOccurred)&&(regs->r[5] != 0)&&
  	(( send_scenelist_request(regs->r[3]) == ErrorOccurred) ||
  	    (get_scenelist_response((size_t*)&(regs->r[4]), (SceneInformationDescriptor*)regs->r[5], (size_t*)(&regs->r[6])) == ErrorOccurred)) )
  		result = ErrorOccurred;
  else {
    if ((result != ErrorOccurred)&&(regs->r[5] == 0)){
      if (regs->r[4] != 0)
      	regs->r[6] = regs->r[4] * sizeof(SceneInformationDescriptor);
      else
      	regs->r[6] = MAX_scene_list * sizeof(SceneInformationDescriptor);
    }
  }

  return result;
}

error_flag
Server::AssetPresentation(ULINT init_value, PlayElementRequest playlist[], size_t size, ULINT *stream_time, struct in_addr *ipaddr, 
								ULINT *port, ULINT *dgram_size, ULINT *bitrate, ULINT *fast_playback_ratio)
{
  error_flag result = ErrorState();
  
  if (  (result != ErrorExists())
  	&&(
  	(send_assetpresentation_request(init_value, playlist, size, (*ipaddr), (*port)) == ErrorOccurred ) ||
 	(get_assetpresentation_response(ipaddr, port, stream_time, dgram_size, bitrate, fast_playback_ratio) == ErrorOccurred) 
 	) )
     		result = ErrorOccurred;

  
  if (result != ErrorOccurred){
  	SocketDescriptor.eventsOn();
  	SocketDescriptor.makeNonBlocking();
  }
  
  return result ;
}

error_flag
Server::AssetEnd(ULINT status, ULINT endflag)
{
   AssetEndRequest request;
   
   error_flag result = ErrorState();
   
   if (result == ErrorOccurred){
     switch(ErrorNum()){
        case IP_UnknownService:
        case IP_BadPortSpecification:
        case IP_UnknownServer:
        case IP_SocketError:
        case IP_ConnectionRefused:
        case IP_ReadFail:
        case IP_SendFail:
        case IP_TimeOutOnCommunication:
             return ErrorOccurred;
             
     	default:
  		RemoveErr();	// it doesn't matter now we are trying to get out
  		result = NoError;
  		break;
     }
   }

#ifdef DEBUGLIB
    int size_remaining = ReadDataToDebug();
    if (size_remaining > 0) {
    	Debug("Asset End %i remaining in socket", ReadDataToDebug());
    	SocketDescriptor.makeNonBlocking();
    }
#endif    

   request.interface_number = 0;
   request.route_type = 0;
   request.command_number = COMMAND_assetend_request;
   request.command_length = sizeof(AssetEndRequest) - 8;
   request.certification_code = certification_code;
   if (endflag != 0)
   	request.end_flag = 1;
   else
   	request.end_flag = endflag;
   request.asset_status = status;
   request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0;

   if ( hton_structure(&request, map_AssetEndRequest, AssetEndRequest) == ErrorOccurred) {
     	return MakeError(IP_SendFail);
   }

   result = SendData((void*)&request, sizeof(AssetEndRequest));
  
   return NoError;
}
  // -- message pipe veneers
error_flag
Server::send_message_Error( ErrorBlk  *error )
{
  error_flag result = NoError;
  
  if (message_pipe_exists()){
    	result = message_pipe->send_Error(error);
   
  	if (result == ErrorOccurred){
    		if (  (message_pipe->ErrorNum() == Error_MessageQueue_UnknownQueue)||
    	  		(message_pipe->ErrorNum() == 0 /*swi not known*/) 	){
    				delete message_pipe;
    				result = NoError;
                        }
    			else {
    				message_pipe->RemoveErr();
    				result = NoError;
                        }
        }
  }
  return result;	
}
error_flag
Server::send_message_Diagnostic ( const char *string )
{
  error_flag result = NoError;
  
  if (message_pipe_exists()){
    	result = message_pipe->send_Diagnostic(string);
   
  	if (result == ErrorOccurred){
    		if (  (message_pipe->ErrorNum() == Error_MessageQueue_UnknownQueue)||
    	  		(message_pipe->ErrorNum() == 0 /*swi not known*/) 	){
    				delete message_pipe;
    				result = NoError;
                        }
    			else {
    				message_pipe->RemoveErr();
    				result = NoError;
                        }
        }
  }
  return result;	
}
error_flag
Server::send_message_StartNotification ( ULINT block )
{
  error_flag result = NoError;
  
  if (message_pipe_exists()){
    	result = message_pipe->send_StartNotification(block);
   
  	if (result == ErrorOccurred){
    		if (  (message_pipe->ErrorNum() == Error_MessageQueue_UnknownQueue)||
    	  		(message_pipe->ErrorNum() == 0 /*swi not known*/) 	){
    				delete message_pipe;
    				result = NoError;
                        }
    			else {
    				message_pipe->RemoveErr();
    				result = NoError;
                        }
        }
  }
  return result;	
}
error_flag
Server::send_message_EndNotification ( ULINT block )
{
  error_flag result = NoError;
  
  if (message_pipe_exists()){
    	result = message_pipe->send_EndNotification(block);
   
  	if (result == ErrorOccurred){
    		if (  (message_pipe->ErrorNum() == Error_MessageQueue_UnknownQueue)||
    	  		(message_pipe->ErrorNum() == 0 /*swi not known*/) 	){
    				delete message_pipe;
    				result = NoError;
                        }
    			else {
    				message_pipe->RemoveErr();
    				result = NoError;
                        }
        }
  }
  return result;	
}
error_flag 
Server::send_message_StreamClosing ( ErrorBlk *error )
{
  error_flag result = NoError;
  
  if (message_pipe_exists()){
    	result = message_pipe->send_StreamClosing(error);
   
  	if (result == ErrorOccurred){
    		if (  (message_pipe->ErrorNum() == Error_MessageQueue_UnknownQueue)||
    	  		(message_pipe->ErrorNum() == 0 /*swi not known*/) 	){
    				delete message_pipe;
    				result = NoError;
                        }
    			else {
    				message_pipe->RemoveErr();
    				result = NoError;
                        }
        }
  }
  return result;	
}
