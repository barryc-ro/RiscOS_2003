/**************************************
 Server.c++

implements standard Server class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include <string.h>
#include "NECstruct.h"
#include "ServCtrl.h"

#include "kernel.h"
#include "swis.h"

error_flag
ServerList::inetEvent(int code, int identifier, claim_flag *claim)
{
  error_flag result = ErrorState();
  int i;
  InternetObject *server;
  
  if ((result != ErrorOccurred)&&(identifier != -1)){
  
	for (i=0;i<Size();i++){
  	
		server = (InternetObject*) object[i];
  	  	
     		if (server->getSocketDescriptor() == identifier) {
        		if (code == Socket_Broken_Event){
        		     	server->MakeError(IP_SocketError);
        		     	err = &server->ReturnCopyOfError();
        		     	server->send_message_Error(err);
        		     	result = ErrorOccurred;
        	   	}
        	   	else {
        	   	  	UCHAR event;
  				ULINT comms_result;
        	   	  	
      				if ( server->inetevent(&event, &comms_result,0) == ErrorOccurred){
    					err = &server->ReturnCopyOfError();
    					server->send_message_Error(err);
    					result = ErrorOccurred;
      				}
        		}
        	   	*claim = claim_event; // claim even if in use
    		}
    	}
  }
  return result;
}

InternetObject::InternetObject(struct in_addr *server, ULINT port)
{
  	inuse  = free_token;
  	owners = owner_none;
  	message_pipe = NULL;
  	message_sent = false;
  	MAX_requested_block = 0;	// error checking to avoid multilple requests for the same thing
        address.s_addr = server->s_addr;
  	portnumber = port;
}

InternetObject::~InternetObject()
{
  if (message_pipe_exists())
  	delete message_pipe;
}

  // -- message pipe veneers
error_flag
InternetObject::send_message_Error( ErrorBlk  *error )
{
  error_flag result = NoError;
  
  if (message_pipe_exists()&&(message_sent == false)){
    	result = message_pipe->send_Error(error);
    	message_sent = true;
   
  	if (result == ErrorOccurred){
    		if (  (message_pipe->ErrorNum() == Error_MessageQueue_UnknownQueue)||
    	  		(message_pipe->ErrorNum() == 0 /*swi not known*/) 	){
    				delete message_pipe;
    				result = NoError;
                        }
    			else {
    				message_pipe->RemoveErr();
    				result = NoError;
                        }
        }
  }
  return result;	
}
error_flag
InternetObject::send_message_Diagnostic ( const char *string )
{
  error_flag result = NoError;
  
  if (message_pipe_exists()){
    	result = message_pipe->send_Diagnostic(string);
   
  	if (result == ErrorOccurred){
    		if (  (message_pipe->ErrorNum() == Error_MessageQueue_UnknownQueue)||
    	  		(message_pipe->ErrorNum() == 0 /*swi not known*/) 	){
    				delete message_pipe;
    				result = NoError;
                        }
    			else {
    				message_pipe->RemoveErr();
    				result = NoError;
                        }
        }
  }
  return result;	
}
error_flag
InternetObject::send_message_StartNotification ( ULINT block )
{
  error_flag result = NoError;
  
  if (message_pipe_exists()&&(message_sent == false)){
    	result = message_pipe->send_StartNotification(block);
    	message_sent = true;
   
  	if (result == ErrorOccurred){
    		if (  (message_pipe->ErrorNum() == Error_MessageQueue_UnknownQueue)||
    	  		(message_pipe->ErrorNum() == 0 /*swi not known*/) 	){
    				delete message_pipe;
    				result = NoError;
                        }
    			else {
    				message_pipe->RemoveErr();
    				result = NoError;
                        }
        }
  }
  return result;	
}
error_flag
InternetObject::send_message_EndNotification ( ULINT block )
{
  error_flag result = NoError;
  
  if (message_pipe_exists()&&(message_sent == false)){
    	result = message_pipe->send_EndNotification(block);
    	message_sent = true;
   
  	if (result == ErrorOccurred){
    		if (  (message_pipe->ErrorNum() == Error_MessageQueue_UnknownQueue)||
    	  		(message_pipe->ErrorNum() == 0 /*swi not known*/) 	){
    				delete message_pipe;
    				result = NoError;
                        }
    			else {
    				message_pipe->RemoveErr();
    				result = NoError;
                        }
        }
  }
  return result;	
}
error_flag 
InternetObject::send_message_StreamClosing ( ErrorBlk *error )
{
  error_flag result = NoError;
  
  if (message_pipe_exists()){
    	result = message_pipe->send_StreamClosing(error);
   
  	if (result == ErrorOccurred){
    		if (  (message_pipe->ErrorNum() == Error_MessageQueue_UnknownQueue)||
    	  		(message_pipe->ErrorNum() == 0 /*swi not known*/) 	){
    				delete message_pipe;
    				result = NoError;
                        }
    			else {
    				message_pipe->RemoveErr();
    				result = NoError;
                        }
        }
  }
  return result;	
}

#ifdef DEBUGLIB 
size_t
InternetObject::ReadDataToDebug(void)
{
  return 0;
} 	
#endif

int
InternetObject::getSocketDescriptor(void)
{
    return -1;
}

server_type 
InternetObject::InternetObjectType(void)
{
  	return server_ip_address;
}
 
error_flag
InternetObject::inetevent(UCHAR*, ULINT*, ULINT)
{
  	return NoError;
}  	

error_flag
InternetObject::SendAck(ULINT, ULINT, ACK_type)
{
  	return NoError;
}

error_flag
InternetObject::SendNak(ULINT, LINT, ULINT, LINT)
{
  	return NoError;
}
 
error_flag
InternetObject::GetAssetList(_kernel_swi_regs *)
{
  	return NoError;
}

error_flag
InternetObject::GetSceneAssetList(_kernel_swi_regs *)
{ 
	return NoError;
}

error_flag
InternetObject::send_playback_request(ULINT, ULINT, ULONG, ULINT, ULINT)
{ 
	return NoError;
}

error_flag
InternetObject::AssetEnd(ULINT, ULINT)
{
  	return NoError;
}

// this routine construct the connection to the specified server on the
// specified port.  It sets up the SocketDescriptor (of class Socket)
// to act as the communications end-point.  All socket operations may
// only be performed through the Socket methods

//--------------------------------------------- Server Specific ---------------------------------
error_flag
Server::setSocketError(int socket_result)
{
    error_flag result = ErrorState();
        
        if ((result != ErrorOccurred)&&(socket_result < 0)) {
                switch (errno) {
                        default:
                                result = MakeError(IP_SocketError);
#ifdef DEBUGLIB                                
                                Debug("tcp errno = %i", errno);
#endif                                
                                break;
                        case ECONNREFUSED:
                                result = MakeError(IP_ConnectionRefused);
                                break;
                        case ENOENT:
                                result = MakeError(IP_UnknownServer);
                                break;
                        case EINVAL:
                                result = MakeError(IP_BadPortSpecification);
                                break;
                        case ENOBUFS:
                        	result = MakeError(IP_NoBuffer);
                        	break;
                        case EWOULDBLOCK:
                        	result = NoError;
                }
        }
        else {
                result = NoError;
        }
        return result;
}

//--------------------------------------------------------
error_flag
Server::send_assetlist_request(ULINT select_flags, size_t start, size_t number)
{
  AssetListRequest request;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_assetlist_request;

  request.command_length = sizeof(AssetListRequest)-8;		// size of structure - header.
  request.certification_code = certification_code;
  request.request_type = 0x01;
  request.continuity_flag = 0x01;
  request.asset_status_selection = (UCHAR)(select_flags&0xff);
  request.asset_type_selection = (UCHAR)((select_flags>>8)&0xff);
  request.starting_entry = start;
  request.number_of_entries = number;
  request.sort_type =  (select_flags>>16)&0xff;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0x00;

  if (hton_structure(&request, map_AssetListRequest, AssetListRequest) == ErrorOccurred){
  	return MakeError(IP_SendFail);
  }
  
  return SendData(&request, sizeof(AssetListRequest));
}

error_flag
Server::get_assetlist_response(size_t *number, AssetIDDescriptor *buffer, size_t *buffer_size)
{
  // this pans out as r4, r5, r6
  
  PacketHeader header;
  AssetListResponseHeader alr_header;
  size_t asset_count;
  error_flag result = ErrorState();

  UCHAR event = 0;
  while ((result = PeekHeaderWait(&event)) != ErrorOccurred){ 
    if ((event == COMMAND_assetlist_response)||((result = asyncInetEventHandler(&event)) == ErrorOccurred))
    	break;
  }

  if (result != ErrorOccurred)
  	result = GetData(&header, sizeof(PacketHeader));
  	
  if ((result != ErrorOccurred)&&(ntoh_structure((void*)&header, map_PacketHeader, PacketHeader) == ErrorOccurred))
  	result = MakeError(IP_ReadFail);
  
  if ((result != ErrorOccurred)&&(header.command_number != COMMAND_assetlist_response))
    	result = MakeError(VSP_UnknownMessage);
  	
  if (result != ErrorOccurred)
  	result = GetData(&alr_header, sizeof(AssetListResponseHeader));

  if ((result != ErrorOccurred)&&(ntoh_structure(&alr_header, map_AssetListResponseHeader, AssetListResponseHeader) == ErrorOccurred))
    	result = MakeError(IP_SendFail);

  if ((result != ErrorOccurred)&&(alr_header.certification_code != certification_code++))    
  	result = MakeError(VSP_ServerCertError);
  
  if (result != ErrorOccurred){
  	if ((*number) == 0) // if a request for the number of assets
  		(*number) = (size_t)alr_header.total_number_of_assets;
  	else {   	
  		size_t readsize = (size_t)(header.command_length - sizeof(AssetListResponseHeader));
  	  	// extract the data from the socket.
  	  	result = GetData(buffer, readsize);

		for ( asset_count = 0; asset_count < ( readsize/sizeof(AssetIDDescriptor) ); ++asset_count) {
 		
	  		if (ntoh_structure(&(buffer[asset_count]), map_AssetIDDescriptor, AssetIDDescriptor) == ErrorOccurred){
	  			result = MakeError(IP_ReadFail);
	  		}
	  		
	  		if (result == ErrorOccurred)
	  			break;
			/* 		
	    		AssetIDDescriptor *asset = &buffer[asset_count];
    		
	  		Debug("asset id (%i)", asset->asset_id);
	        	Debug("last update%8.8X%8.8X", (int)asset->time_of_last_update[8], (int)asset->time_of_last_update);     
	        	Debug("registration %i", asset->registration);         
	        	Debug("bitrate %i", asset->bit_rate);            
	        	Debug("asset type %i", asset->asset_type);         
	        	Debug("encoding %i", asset->encoding);           
	        	Debug("block_length %i", asset->block_length);      
	        	Debug("total time %i", asset->total_time);       
	        	Debug("short title %s", asset->video_title); 
	        	Debug("long title  %s", asset->full_title); 
	        	Debug("ff time  %i", asset->ff_time);     
	        	Debug("rw time  %i", asset->rw_time);     
	        	Debug("video type  %i", asset->video_type);    
	        	Debug("video status  %i", asset->video_status);
			*/
	  		(*buffer_size) -= sizeof(AssetIDDescriptor);
	 		//asset_count++;
	  	}// while
	  	(*number) = asset_count;
	  }
  }
  
  if ((result != ErrorOccurred)&&(alr_header.result != 0)){
 	result = MakeError(VSP_ServerError, alr_header.result);
  }
   		      	  
  return result;
}

error_flag
Server::send_scenelist_request(ULINT asset_id)
{
  SceneListRequest request;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_scenelist_request;
  request.command_length = sizeof(SceneListRequest)-8;
  request.certification_code = certification_code;
  request.asset_id = asset_id;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0;

  if (hton_structure(&request, map_SceneListRequest, SceneListRequest) == ErrorOccurred){
  	return MakeError(IP_SendFail);
  }
  
  return SendData((void*)&request, sizeof(SceneListRequest));
}

error_flag
Server::get_scenelist_response(size_t *number, SceneInformationDescriptor *buffer, size_t *buffer_size)
{
  // reads a maximum of number of assets into the buffer 
  error_flag result = ErrorState();
  SceneListHeader header;
  size_t asset_count;

  UCHAR event;
  while ((result = PeekHeaderWait(&event)) != ErrorOccurred){     
    if ((event == COMMAND_scenelist_response)||((result = asyncInetEventHandler(&event)) == ErrorOccurred))
    	break;
  }
 
  if (result != ErrorOccurred)
  	result = GetData((void*)&header, sizeof(SceneListHeader));

  if ((result != ErrorOccurred)&&(ntoh_structure(&header, map_SceneListHeader, SceneListHeader) == ErrorOccurred)){
    	result = MakeError(IP_SendFail);
  }

  if ((result != ErrorOccurred)&&(header.command_number != COMMAND_scenelist_response)) {
    	result = MakeError(VSP_UnknownMessage);
  }

  if ((result != ErrorOccurred)&&(header.certification_code != certification_code++)){
  	result = MakeError(VSP_ServerCertError);
  }
  if (result != ErrorOccurred){
  	if ((*number) == 0)
  		(*number) = (size_t)header.number_of_scenes;
  	else {
  	  	// extract data from the socket
  	  	
  	  	size_t readsize = (size_t)(header.command_length - ( sizeof(SceneListHeader)-sizeof(PacketHeader) ));

	  	result = GetData(buffer, readsize);
    	
  	  	for ( asset_count = 0; asset_count < (readsize/sizeof(SceneInformationDescriptor)); ++asset_count) {   		  
  		
  			if (ntoh_structure(&(buffer[asset_count]), map_SceneInformationDescriptor, SceneInformationDescriptor) == ErrorOccurred){
  				result = MakeError(IP_ReadFail);
  			}
  			
  			if (result == ErrorOccurred)
	  			break;
	  			
	  		SceneInformationDescriptor *scene = &buffer[asset_count];
#ifdef DEBUGLIB	  		
	  		Debug("scene %i, asset_id %i, from %i to %i", asset_count, scene->asset_id, scene->start_time, scene->end_time);
#endif	  		
  			(*buffer_size) -= sizeof(SceneInformationDescriptor);
  		}// while
  	 	(*number) = asset_count;
  	}
  }
  
  if ((result != ErrorOccurred)&&(header.result != 0)){
    return MakeError(VSP_ServerError, header.result);
  }
  return NoError;
}

error_flag
Server::fill_assetpresentation_request(int size, ULINT init_value, PlayElementRequest playlist[], size_t play_size, struct in_addr ipaddr, ULINT port)
{
  AssetPresentationRequest request;
  int i;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_assetpres_request;
    
  request.command_length = size;
  request.certification_code = certification_code;
  request.client_type = 1; 				// as per specification
  request.packet_interval = 0;				// packet transition interval environment var
  request.initial_packet_num = init_value;
  MAX_requested_block = init_value -1;
  request.my_udp_port = port;				// source.port_num;
  if ((play_size > 1)||(playlist[0].viewing_end_time != 0))
  	request.playlist_num = play_size;
  else
  	request.playlist_num = 0;
  request.QOS_control = 0;				// as per specification

  unsigned int systime;
  _swix(OS_ReadMonotonicTime, _OUT(0), &systime);

  sprintf(((char*)&(request.log_comment)), "STB LOG:%i, timestamp in centiseconds\0",systime);
#ifdef DEBUGLIB
  Debug("STB LOG: timestamp in centiseconds %i",systime);
#endif  
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = 0;

  if (hton_structure(&request, map_AssetPresentationRequest, AssetPresentationRequest) == ErrorOccurred) {
         MakeError(IP_SendFail);
  }

  request.my_IP_address = (int)ipaddr.s_addr;		// my_IP_address of source object;

  if (!ErrorExists()){
  	for (i = 0; i < play_size; i++){
#ifdef DEBUGLIB
		Debug("Play Element Request asset [%i] %i -> %i", 
			playlist[i].asset_id, playlist[i].viewing_start_time, playlist[i].viewing_end_time);
#endif  	
	  	if (hton_structure(&(playlist[i]), map_PlayElementRequest, PlayElementRequest) == ErrorOccurred){
	  	  	MakeError(IP_SendFail);
	  	  	break;
	  	}
	  }  
        
  	if ((!ErrorExists())&&( 	
  		(SendData(&request, sizeof(AssetPresentationRequest)) == ErrorOccurred) ||
  		(SendData(playlist, sizeof(PlayElementRequest)*play_size) == ErrorOccurred) )){// ||
  		MakeError(IP_SendFail);
  	}
  }
  return ErrorState();
}

error_flag
Server::send_assetpresentation_request(ULINT init_value, PlayElementRequest playlist[], size_t play_size, struct in_addr ipaddr, ULINT port)
{
   int request_length = sizeof(AssetPresentationRequest)-8 + (play_size * sizeof(PlayElementRequest));

   return fill_assetpresentation_request(request_length, init_value, playlist, play_size, ipaddr, port);
}

error_flag
Server::get_assetpresentation_response(struct in_addr *ipaddr, ULINT *port, ULINT *stream_time, 
						ULINT *dgram_size, ULINT *bitrate, ULINT *fast_playback_ratio)
{
  PacketHeader header;
  AssetPresentationResponse response;
  size_t buffersize;
  UCHAR *buffer;

  UCHAR event;
  while (PeekHeaderWait(&event) != ErrorOccurred){    
    	if ((event == COMMAND_assetpres_response)||(asyncInetEventHandler(&event) == ErrorOccurred))
    		break;
  }
  
  if (ErrorExists())
  	return ErrorOccurred;

  if (GetData((void*)&header, sizeof(PacketHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&header, map_PacketHeader, PacketHeader) == ErrorOccurred) {
    	return MakeError(IP_ReadFail);
  }

  if (header.command_number != COMMAND_assetpres_response) {
    	return MakeError(VSP_UnknownMessage);
  }
    // certification code
  if (GetData((void*)&response, sizeof(AssetPresentationResponse)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&response, map_AssetPresentationResponse, AssetPresentationResponse) == ErrorOccurred) {
    	return MakeError(IP_ReadFail);
  }

  if (response.certification_code != certification_code++){
  	return MakeError(VSP_ServerCertError);
  }
  
  buffersize = (size_t)(header.command_length) - sizeof(AssetPresentationResponse);

  if (buffersize != 0) {	// get scene information
   	if ( (buffer = new UCHAR[buffersize]) == NULL)
	    return MakeError(VSP_Alloc);
  	else {
		if (GetData((void*)buffer, buffersize) == ErrorOccurred)
  			return ErrorOccurred;	//Null
  		delete buffer;
  	}
  } // scene info exists
  
  ipaddr->s_addr = (u_long) response.server_IP;
  *port = response.server_port;
  //if (response.datagram_size != 0)
  	*dgram_size = assetresponse_dgram_size = response.datagram_size;
  //else
  //	*dgram_size = assetresponse_dgram_size = SocketDescriptor.getDgramSize();
  
  *bitrate = response.bit_rate;
  *fast_playback_ratio = (ULINT)response.ff_ratio;
  *fast_playback_ratio |= (ULINT)((response.fast_playback)<<24);
  
  if (response.video_status != 0)
  	(*stream_time) = 0xFFFFFFFF;
  else
  	(*stream_time) = (unsigned int)response.total_time;
  
  if (response.result != 0){
    return MakeError(VSP_ServerError, response.result);
  }

  return NoError;
}

error_flag
Server::send_playback_request(ULINT state_id, ULINT MAX_storableBlock, ULONG AckSeq, ULINT time, ULINT mode)
{
  PlayBackRequest request;
 
  if ((MAX_storableBlock-AckSeq) > NEC_databurstval){
#ifdef DEBUGLIB
	Debug("invalid value in play request, %i-%i", MAX_storableBlock, AckSeq);
#endif	    
    return MakeError(VSP_InvalidValue);
  }
  
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_playback_request;

  request.command_length = sizeof(PlayBackRequest) - 8;
  request.certification_code = certification_code;
  request.playback_id = state_id;
  request.playback_mode = mode;
  request.time_mode = mode;		// always normal ?? time specified means nothing
  request.time_spec = time;
  request.skip_rate = 0;
  request.data_type = 0;
  request.data_rate = 0;
  request.max_received = AckSeq;
  request.request_sequence_num = MAX_requested_block = MAX_storableBlock;
  request.datagram_size = 0;
  request.play_live_margin = 0;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = 0;

  if (hton_structure((void*)&request, map_PlayBackRequest, PlayBackRequest) == ErrorOccurred){
  	return MakeError(IP_SendFail);
  }
  	
  if (inuse != claim_token){
  	inuse = claim_token;
  	
  	if (SendData((void*)&request, sizeof(PlayBackRequest)) == ErrorOccurred)
  		return ErrorOccurred;
  	/*	
  	Debug("sent play request");
  	
  	UCHAR event;
  	while (PeekHeaderWait(&event) != ErrorOccurred){
  	  	//Debug("play request %i err %8.8X", event, ErrorNum());
    		if ((event == COMMAND_playback_response)||(asyncInetEventHandler(&event) == ErrorOccurred))
    			break;
  	}
	*/	
  	inuse = free_token;
  }
  	    
  return ErrorState();
}

error_flag
Server::get_playback_response(ULINT *comms_result)
{
  error_flag  result = NoError;
  PlayBackResponse response;
  
  if (GetData((void*)&response, sizeof(PlayBackResponse)) == ErrorOccurred)
  	result = ErrorOccurred;	//Null

  if ((result != ErrorOccurred)&&(ntoh_structure(&response, map_PlayBackResponse, PlayBackResponse) == ErrorOccurred)) {
    	result = MakeError(IP_ReadFail);
  }
  
  if ((result != ErrorOccurred)&&(response.certification_code != certification_code++)){
  	result = MakeError(VSP_ServerCertError);
  }
   
  if (*comms_result != NULL)
    	*comms_result = response.result;
  
  if ((result != ErrorOccurred)&&(response.result != 0)){
  	result = MakeError(VSP_ServerError, response.result);
  }

  return result;
}
 
//--------------------------------------------------------public methods---------------
// extracted from constructor so ATM server can call it.
error_flag
Server::createVSPLink(void)
{
  ControlPortNumberNotification		cpnn;
  Socket				connection_port;
  
#ifdef DEBUGLIB
  Debug("create server link %8.8X:%i", address.s_addr, portnumber);
#endif

  // connect to ping socket.
  connection_port.creat();
  SocketDescriptor.creat();
  
  connection_port.connect(&address, ntohs((int)portnumber));
  
  if (connection_port.valid()){
    	int data_read;
    	
    	setSocketError(connection_port.makeNonBlocking());
    	
    	data_read = connection_port.readWithTimeout(&cpnn, sizeof(ControlPortNumberNotification), (unsigned int)(timeout_period+50));
    	
    	if (data_read == sizeof(ControlPortNumberNotification)){

    		setSocketError(SocketDescriptor.connect(&address, (int)(cpnn.connection_port_number>>16)));
    		
    		setSocketError(SocketDescriptor.makeNonBlocking());
    		setSocketError(SocketDescriptor.eventsOn());

    		  // initialise variables
  		comms_flag = false;
  		// certification_code is never initialised as it is a comparitive value its initial value doesn't matter
    		ack.interface_number = 0;
  		ack.route_type = 0;
  		ack.command_number = COMMAND_ACK;
 		ack.command_length = sizeof(ACK_Block)-8;
  		ack.certification_code = 0;	// not used
  		ack.data_rate = 0;		// not used
 		ack.RFU[0] = ack.RFU[1] = ack.RFU[2] = ack.RFU[3] = ack.RFU[4] = 0x00;
 	  	hton_structure(&ack, map_ACK_Block, ACK_Block);
	  	//NAK initialise
  		nak.interface_number = 0;
  		nak.route_type = 0;
  		nak.command_number = COMMAND_NAK;
 	 	nak.command_length = sizeof(NAK_Block)-8;
 	 	nak.certification_code = 0;	// not used
 	 	nak.RFU[0] = nak.RFU[1] = nak.RFU[2] = nak.RFU[3] = nak.RFU[4] = 0x00;
 	 	hton_structure(&nak, map_NAK_Block, NAK_Block);
    	}
    	else {
    	  	if (setSocketError(data_read) != ErrorOccurred)
    	  		MakeError(IP_SocketError);
    	}
  }
  else
  	MakeError(IP_SocketError);
  	
  return ErrorState();
}	  

Server::Server(struct in_addr *server, ULINT port, ULINT timeout):InternetObject(server, port)
{
  	timeout_period = timeout;
	createVSPLink();
} 

Server::~Server()
{
#ifdef DEBUGLIB
  Debug("delete control socket +");
#endif  
  SocketDescriptor.close();
}

int
Server::getSocketDescriptor(void)
{
    return SocketDescriptor.getSocketDescriptor();
}

error_flag
Server::SendData(void *buffer, size_t size)
{
  error_flag result = ErrorState();

  ULINT t1, t2;
  UBYTE *buf_ptr = (UBYTE*)buffer;
  size_t remaining_data = size;
 	
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
  
  do {	
    	int data_written;
  	
	if (result == ErrorOccurred)
		break;
			
  	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
    	  	
    	data_written = SocketDescriptor.write(buf_ptr, remaining_data);
    
  	if ( (int)(remaining_data) > data_written )
    		setSocketError(SocketDescriptor.wait_write((unsigned int)((timeout_period+50)/100)));
    
    	if ( data_written > 0) {
    		remaining_data -= data_written;
    		buf_ptr += data_written;
    	  	t1 = t2;
    	}

    	if (data_written < 0){
    		result = setSocketError(data_written);
    	}
    	
    	if (t2 > (t1 + timeout_period)){
    	  	result = MakeError(IP_TimeOutOnCommunication);
    	}
    	  	
  } while (remaining_data > 0);


  return result;
}

error_flag
Server::GetData(void *buffer, size_t size)
{
  error_flag result = ErrorState();
  
  ULINT t1, t2;
  
  UBYTE *buf_ptr = (UBYTE*)buffer;
  size_t remaining_data = size;
 	
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
  	
  do {
    	int data_read;
    	
  	if (result == ErrorOccurred)
  		break;
  		
  	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
    	  	
    	data_read = SocketDescriptor.read(buf_ptr, remaining_data);
    	  
    	if ( (int)(remaining_data) > data_read )
    		setSocketError(SocketDescriptor.wait_read((unsigned int)((timeout_period+50)/100)));
    		
    	if ( data_read > 0) {
    		remaining_data -= data_read;
    		buf_ptr += data_read;
    	  	t1 = t2;
    	}
   		
    	if (data_read < 0){
    		result = setSocketError(data_read);
    	}
    	
    	if (t2 > (t1 + timeout_period)){
    	  	result = MakeError(IP_TimeOutOnCommunication);
    	}
    	  	
  }while (remaining_data > 0);
  
  return result;
}

#ifdef DEBUGLIB
size_t
Server::ReadDataToDebug(void)
{
  int data;
  size_t size, size_total = 0;
      
    while ( (size = SocketDescriptor.read(&data, sizeof(int))) == sizeof(int) ) {
    	size_total += size;
    	Debug("data %8.8X", ntohl(data) );
    }
        
    if (size == -1)    
    	Debug("data errno %i", errno);
    	
  return size_total;
} 
#endif  

error_flag
Server::PeekHeader(UCHAR *command)
{
  PacketHeader header;
  *command = 0;
     
    if (SocketDescriptor.read(&header, sizeof(PacketHeader), MSG_PEEK) != sizeof(PacketHeader)) {
    	return ErrorOccurred;
    }
    *command = header.command_number;
    return NoError;
} 

error_flag
Server::PeekHeaderWait(UCHAR *command)
{
  PacketHeader header;
  error_flag result = ErrorState();
  *command = 0;
  
  ULINT t1, t2;
  	
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
  	
  while (result != ErrorOccurred) {
   	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
    	  	
    	int data_read = SocketDescriptor.read(&header, sizeof(PacketHeader), MSG_PEEK);
    	    	   	  
    	if (data_read < 0){
    		result = setSocketError(data_read);
    	}
 
    	if (t2 > (t1 + timeout_period)){
    	  	result = MakeError(IP_TimeOutOnCommunication);
    	}	

	if (result != ErrorOccurred){
    		if ( data_read != (int)(sizeof(PacketHeader)) ){
    		  	//Debug("wait+ %i", (unsigned int)((timeout_period+50)/100));
    			setSocketError(SocketDescriptor.wait_read((unsigned int)((timeout_period+50)/100)));
    			//Debug("wait-");
    		}
    		else {
    		  	*command = header.command_number;
    			break;
    		}
    	}
  }
  return result;
} 

error_flag
Server::asyncInetEventHandler(UCHAR *event, ULINT *comms_result, ULINT play_mode)
{
  UCHAR local_event = 0;
  ULINT local_result= 0;
  error_flag result = ErrorState();
  
  if ((result != ErrorOccurred)&&(PeekHeader(&local_event) != ErrorOccurred)){ // no real error just no event
  	
  		switch (local_event) {
    			case COMMAND_playback_response:
    				result = get_playback_response(&local_result);
    				break;
  			case COMMAND_startend_notification:
	  			{
		  			StartEndNotification notify;
  		
  					if (GetData(&notify, sizeof(StartEndNotification)) == ErrorOccurred)
    						result = ErrorOccurred;
    					else {
    					  	if (ntoh_structure(&notify, map_StartEndNotification, StartEndNotification) == ErrorOccurred)
    							result = MakeError(IP_ReadFail);
    						else {
    							if (notify.special_playbackID == play_mode)
    								local_result = (int)notify.trans_block_num;
    							else
    								local_event = 0; // it is out of date.
    						}
    					}
    				}
    	        		break;
    			case COMMAND_assetend_response:
   				{
   					AssetEndResponse response;
   				
   					if ((GetData((void*)&response, sizeof(AssetEndResponse)) == ErrorOccurred))
   						result = ErrorOccurred;
   					else {
						if ((ntoh_structure(&response, map_AssetEndResponse, AssetEndResponse) == ErrorOccurred))
     							result = MakeError(IP_ReadFail);
   						else {
   							if ((response.certification_code != certification_code++))
   								result = MakeError(VSP_ServerCertError);
   			                        	else {
   			                        		clear_streamrunning();
   								local_result = response.result;
   							}
   					        }
   				        }
                	        }
    				break;
    			default:
#ifdef DEBUGLIB    
    				Debug("TCP: inet ignore unknown command %2.2X\n", local_event);
    					ReadDataToDebug();
#else
				{
  					int buffer;
    					while (SocketDescriptor.read(&buffer, 4)==4);
    				}
#endif    		
    				break;	
    	        }
#ifdef DEBUGLIB    	
    		Debug("async event (%2.2X)", local_event);
#endif    	
  }
  if (event != NULL) *event = local_event;
  if (comms_result != NULL) *comms_result = local_result;
  
  return result;
}

error_flag
Server::inetevent(UCHAR *event, ULINT *result, ULINT play_mode)
{
  error_flag err_result = ErrorState();
  
   if ((err_result != ErrorOccurred)&&(inuse != claim_token)) {
    	inuse = claim_token;
    	
    	err_result = asyncInetEventHandler(event, result, play_mode);
 
    	inuse = free_token;
  }
  return err_result;
}

error_flag
Server::SendAck(ULINT MAX_storableBlocks, ULINT MAX_complete_block, ACK_type datatype)
{
 	ack.data_type =    (LINT)ntohl(datatype);
  	ack.min_sequence = (ULINT)ntohl(MAX_complete_block);
  	ack.max_sequence = (ULINT)ntohl(MAX_storableBlocks);
  		
  	comms_flag = true;		// communicated with server;
  	
#ifdef DEBUGLIB	
	if (!streamrunning())
		Debug("attempt to send Ack out of stream bounds");
#endif		
  	if (!ErrorExists() && streamrunning()){
   		int size = SocketDescriptor.write((void*)&ack, sizeof(ACK_Block));
  		if (size < 0){
#ifdef DEBUGLIB  	  
  	  		Debug("error sending ACK %i", errno);
#endif  	  	
     			setSocketError(size);
     			
     			if ((datatype == data)&&(ErrorNum() == IP_NoBuffer)){
  				RemoveErr();
  			}
  		}
  		else
  			MAX_requested_block = MAX_storableBlocks;
  	}	
  	return ErrorState();
}

error_flag
Server::SendNak(ULINT BlockStart, LINT DatagramStart, ULINT BlockEnd, LINT DatagramEnd)
{
  	nak.BlockStart =    (ULINT)ntohl(BlockStart);
  	nak.DatagramStart = (LINT)ntohl(DatagramStart);
  	nak.BlockEnd =      (ULINT)ntohl(BlockEnd);
 	nak.DatagramEnd =   (LINT)ntohl(DatagramEnd);

	comms_flag = true;		// communicated with server;
	
#ifdef DEBUGLIB	
	if (!streamrunning())
		Debug("attempt to send NAK out of stream bounds");
#endif		
	if (!ErrorExists() && streamrunning()){
  		int size = SocketDescriptor.write((void*)&nak, sizeof(NAK_Block));
  	
  		if (size < 0){
#ifdef DEBUGLIB  		  
  	  		Debug("error sending NAK %i", errno);
#endif  		  	
  			if (ErrorNum() == IP_NoBuffer){
  				RemoveErr();
  			}
  		}
  	}		
  	return ErrorState();	
}

error_flag
Server::GetAssetList(_kernel_swi_regs *regs)
{
  // register usage
  // r2 = selection flags
  // r3 = start
  // r4 = number of entries;
  // r5 = buffer
  // r6 = size of r5
  
  error_flag result = ErrorState();

  if (inuse != claim_token){
  	inuse = claim_token;	
  	//Debug("assetlist claim");
  
#ifdef DEBUGLIB
	Debug("select %8.8X, start (%i), entries (%i)", regs->r[2], regs->r[3], regs->r[4]);
#endif 
  
  	if (  (result != ErrorOccurred)&&(regs->r[4] == 0)&&
  		(( send_assetlist_request(regs->r[2], 0, 0) == ErrorOccurred) ||
  		    (get_assetlist_response((size_t*)&(regs->r[4]), NULL, 0)== ErrorOccurred)) )
  			result = ErrorOccurred;		
  
  	if ((result != ErrorOccurred)&&(regs->r[5] == 0)){
  	  	regs->r[6] = regs->r[4] * sizeof(AssetIDDescriptor);
  	}
  	else {
  		// read r4 assets whilst avoiding overflowing the socket buffer
  	  	size_t expected_num_assets = (size_t)regs->r[4];
  	  	AssetIDDescriptor *buffer_offset = (AssetIDDescriptor*)regs->r[5];
    	
		// this is the number of entries that can be read at once without overflow
	    	int number_entries = (int)((SocketDescriptor.getTCPrecvspace()) - 
    				(sizeof(PacketHeader)+sizeof(AssetListResponseHeader)))/sizeof(AssetIDDescriptor); 
	    	
    		while ((result != ErrorOccurred)&&(regs->r[4] > 0)){
    	  
    		  	if (regs->r[4] < number_entries)
    		  		number_entries = regs->r[4];
    	  		
  			expected_num_assets = number_entries;	// this is the number of assets that we expect to receive

 			if ((result != ErrorOccurred)&&(( send_assetlist_request(regs->r[2], regs->r[3], expected_num_assets) == ErrorOccurred) ||
  		    		(get_assetlist_response((size_t*)&expected_num_assets, buffer_offset, (size_t*)&(regs->r[6])) == ErrorOccurred)))
  				result = ErrorOccurred;
  			else {
  			  	regs->r[4] -= expected_num_assets;		// decrement request count
  			  	if (regs->r[3] == 0)
  			  		regs->r[3] = 1;
  			  	regs->r[3] += expected_num_assets;		// increment start position
  			  	buffer_offset += expected_num_assets;
  			}
  				
#ifdef DEBUGLIB  		
  			Debug("Asset list: read %i size %i new start %i", expected_num_assets, regs->r[6], regs->r[3]);
#endif
   			if (expected_num_assets < number_entries)
  				break;
  		}
 		regs->r[4] = (buffer_offset - (AssetIDDescriptor*)regs->r[5]);
  	}	
  	//Debug("assetlist free");
     	inuse = free_token;
  }
  else
  	result = MakeError(IP_SendFail);

  return result;
}

error_flag
Server::GetSceneAssetList(_kernel_swi_regs *regs)
{
  error_flag result = ErrorState();

  if (inuse != claim_token){
  	inuse = claim_token;
  	//Debug("scenelist claim");
   
  	if (  (result != ErrorOccurred)&&(regs->r[5] != 0)&&
  		(( send_scenelist_request(regs->r[3]) == ErrorOccurred) ||
  		 (get_scenelist_response((size_t*)&(regs->r[4]), (SceneInformationDescriptor*)regs->r[5], (size_t*)(&regs->r[6])) == ErrorOccurred)) )
  			result = ErrorOccurred;
  	else {
    	if ((result != ErrorOccurred)&&(regs->r[5] == 0)){
      		if (regs->r[4] != 0)
      			regs->r[6] = regs->r[4] * sizeof(SceneInformationDescriptor);
      		else
      			regs->r[6] = MAX_scene_list * sizeof(SceneInformationDescriptor);
    		}
  	}
  	//Debug("scenelist free");
     	inuse = free_token;
  }
  else
  	result = MakeError(IP_SendFail);
 
  return result;
}

error_flag
Server::AssetPresentation(ULINT init_value, PlayElementRequest playlist[], size_t size, ULINT *stream_time, struct in_addr *ipaddr, 
								ULINT *port, ULINT *dgram_size, ULINT *bitrate, ULINT *fast_playback_ratio)
{
  error_flag result = ErrorState();
  
  if (inuse != claim_token){
  	inuse = claim_token;
  	
  	if (  (result != ErrorExists())
  		&&(
  		(send_assetpresentation_request(init_value, playlist, size, (*ipaddr), (*port)) == ErrorOccurred ) ||
 		(get_assetpresentation_response(ipaddr, port, stream_time, dgram_size, bitrate, fast_playback_ratio) == ErrorOccurred) 
 		) )
 	    		result = ErrorOccurred;
 	    		
 	set_streamrunning();
     	inuse = free_token;
  }
  else
  	result = MakeError(IP_SendFail);
  	
  return result;
}

error_flag
Server::AssetEnd(ULINT status, ULINT endflag)
{
   AssetEndRequest request;   
   error_flag result = ErrorState();
   
   if (result == ErrorOccurred){
     switch(ErrorNum()){
        case IP_UnknownService:
        case IP_BadPortSpecification:
        case IP_UnknownServer:
        case IP_SocketError:
        case IP_ConnectionRefused:
        case IP_TimeOutOnCommunication:
             result = ErrorOccurred;
             
     	default:
  		RemoveErr();	// it doesn't matter now we are trying to get out
  		result = NoError;
  		break;
     }
   }
   
   if (result != ErrorOccurred){
   	request.interface_number = 0;
   	request.route_type = 0;
   	request.command_number = COMMAND_assetend_request;
   	request.command_length = sizeof(AssetEndRequest) - 8;
   	request.certification_code = certification_code;
   	
   	if (endflag != 0)
   		request.end_flag = 1;
   	else
   	   	request.end_flag = 0;
   	
   	request.asset_status = status;
   	request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0;
   
   	if ( hton_structure(&request, map_AssetEndRequest, AssetEndRequest) == ErrorOccurred)
     		result = MakeError(IP_SendFail);
   	else
   		result = SendData(&request, sizeof(AssetEndRequest));
   }
   return result;
}
