/**************************************
 Server.c

implements standard Server class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include <string.h>
#include "NECstruct.h"
#include "ServCtrl.h"

// this routine construct the connection to the specified server on the
// specified port.  It sets up the SocketDescriptor (of class Socket)
// to act as the communications end-point.  All socket operations may
// only be performed through the Socket methods

ServerList::~ServerList(void){
  for(int i = 0; i < CurrentSize; i++){
    	if (object[i] != NULL) {
  		delete ((Server*)object[i]);
  		object[i] = NULL;
  	}
  }
}

int 
ServerList::Remove(int identifier)
{
  int i =0;	// count value
  
   
  if (SwitchError() == ErrorOccurred) {
    return ErrorOccurred;
  }	// if we cannot recover from this error
  
  while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  if (i == CurrentSize){
  	MakeError(VSP_UnknownObj);
        return ErrorOccurred;
  }

  delete (Server*)object[i]; object[i] = NULL;
  
  while (i < CurrentSize -1){
    object[i] = object[i+1];
    identifiers[i] = identifiers[i+1];
    i++;
  }
  CurrentSize--;
  
  if (decreasesize() != ErrorOccurred)		// this does test for sufficient decrease in size
  	return NoError;
  return ErrorOccurred;
}

int
Server::Connect(char *server_name, char *service)
{
  // Create a TCP socket
  SocketDescriptor = Socket::creat();
  if (!SocketDescriptor.valid()) {
    MakeError(TCP_SocketError);
    return ErrorOccurred;
  }
  else {
    // OK - made the socket, now connect it to the remote end
    int result = SocketDescriptor.connect(server_name, service);
    int error = errno;

    if (result < 0) {
      // Oh dear - it failed.  Check the error
      SocketDescriptor.close();
      switch (error) {
        default:
          MakeError(TCP_SocketError);
          break;
        case ECONNREFUSED:
          MakeError(TCP_ConnectionRefused);
          break;
        case ENOENT:
          MakeError(TCP_UnknownServer);
          break;
        case EINVAL:
          MakeError(TCP_BadPortSpecification);
          break;
      }
      return ErrorOccurred;
    }// result < 0
  } // else
  return NoError;
}

int
Server::Connect(struct in_addr server_name, int service)
{
  // Create a TCP socket
  SocketDescriptor = Socket::creat();
  if (!SocketDescriptor.valid()) {
    MakeError(TCP_SocketError);
    return ErrorOccurred;
  }
  else {
    // OK - made the socket, now connect it to the remote end
    int result = SocketDescriptor.connect(server_name, service);
    int error = errno;

    if (result < 0) {
      // Oh dear - it failed.  Check the error
      SocketDescriptor.close();
      switch (error) {
        default:
          MakeError(TCP_SocketError);
          break;
        case ECONNREFUSED:
          MakeError(TCP_ConnectionRefused);
          break;
        case ENOENT:
          MakeError(TCP_UnknownServer);
          break;
        case EINVAL:
          MakeError(TCP_BadPortSpecification);
          break;
      }
      return ErrorOccurred;
    }// result < 0
  } // else
  return NoError;
}

int
Server::Connect(char *server_name, int service)
{
  // Create a TCP socket
  SocketDescriptor = Socket::creat();
  if (!SocketDescriptor.valid()) {
    MakeError(TCP_SocketError);
    return ErrorOccurred;
  }
  else {
    // OK - made the socket, now connect it to the remote end
    int result = SocketDescriptor.connect(server_name, service);
    int error = errno;

    if (result < 0) {
      // Oh dear - it failed.  Check the error
      SocketDescriptor.close();
      switch (error) {
        default:
          MakeError(TCP_SocketError);
          break;
        case ECONNREFUSED:
          MakeError(TCP_ConnectionRefused);
          break;
        case ENOENT:
          MakeError(TCP_UnknownServer);
          break;
        case EINVAL:
          MakeError(TCP_BadPortSpecification);
          break;
      }
      return ErrorOccurred;
    }// result < 0
  } // else
  return NoError;
}

//--------------------------------------------------------
int
Server::send_assetlist_request(int select_flags, int start, int number)

{
  AssetListRequest request;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_assetlist_request;

  request.command_length = sizeof(AssetListRequest)-8;		// size of structure - header.
  request.certification_code = certification_code;
  request.request_type = 0x01;
  request.continuity_flag = 0x01;
  request.asset_status_selection = select_flags&0xff;
  request.asset_type_selection = (select_flags>>8)&0xff;
  request.starting_entry = start;
  request.number_of_entries = number;
  request.sort_type =  (select_flags>>16)&0xff;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0x00;

  if (hton_structure(&request, map_AssetListRequest, AssetListRequest) == ErrorOccurred){
  	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }
  
  if (SendData((void*)&request, sizeof(AssetListRequest)) == ErrorOccurred)
  	return ErrorOccurred;

  return NoError;
}

int
Server::get_assetlist_response(int *number, AssetIDDescriptor *buffer, int *buffer_size)
{
  // this pans out as r4, r5, r6
  
  PacketHeader header;
  AssetListResponseHeader alr_header;
  int asset_count;
  
  if (ErrorExists())
  	return ErrorOccurred;

  if (GetData((void*)&header, sizeof(PacketHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (header.command_number != COMMAND_assetlist_response) {
    	MakeError(VSP_UnknownMessage);
    	return ErrorOccurred;
  }

  if (GetData((void*)&alr_header, sizeof(AssetListResponseHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&alr_header, map_AssetListResponseHeader, AssetListResponseHeader) == ErrorOccurred){
    	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }

  if (alr_header.certification_code != certification_code++){
  	MakeError(VSP_ServerCertError);
  	return ErrorOccurred;
  }
  
  if ((*number) == 0)
  	(*number) = (int)alr_header.total_number_of_assets;
  else {
    	asset_count = 0;
    	while ((asset_count < (*number))&&(asset_count < alr_header.number_of_entries)
    		&&( (asset_count+1) * sizeof(AssetIDDescriptor) <= (*buffer_size)) ) {
    		  
   		if (GetData((void*)&(buffer[asset_count]), sizeof(AssetIDDescriptor)) == ErrorOccurred)
  			return ErrorOccurred;	//Null
  		
  		if (ntoh_structure((void*)&(buffer[asset_count]), map_AssetIDDescriptor, AssetIDDescriptor) == ErrorOccurred){
  	  		MakeError(TCP_ReadFail);
  			return ErrorOccurred;
  		}
  		asset_count++;
  	}// while
  	(*number) = asset_count;
  	(*buffer_size) -= (asset_count)*sizeof(AssetIDDescriptor);
  }
  if (alr_header.result != 0){
    MakeError(VSP_ServerError);
    return ErrorOccurred;
  }
  return NoError;
}

int
Server::send_assetpresentation_request(int init_value, PlayElementRequest playlist[], int size, struct in_addr ipaddr, ULINT port)
{
  AssetPresentationRequest request;
  int i;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_assetpres_request;

  request.command_length = sizeof(AssetPresentationRequest)-8 + (size * sizeof(PlayElementRequest));
  request.certification_code = certification_code;
  request.client_type = 1; 				// as per specification
  request.packet_interval = 0;	// (visit)		// packet transition interval environment var
  request.initial_packet_num = init_value;
  MAX_requested_block = init_value -1;
  request.my_udp_port = port;				// source.port_num;
  if (size == 1)
  	request.playlist_num = 0;
  else
  	request.playlist_num = size;
  request.QOS_control = 0;				// as per specification
  strncpy(((char*)&(request.log_comment)), "LOG COMMENT: Mon 28th", 64);
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = 0;

  if (hton_structure(&request, map_AssetPresentationRequest, AssetPresentationRequest) == ErrorOccurred) {
         MakeError(TCP_SendFail);
         return ErrorOccurred;
  }

  request.my_IP_address = (int)ipaddr.s_addr;		// my_IP_address of source object;

  for (i = 0; i < size; i++){
  	if (hton_structure(&(playlist[i]), map_PlayElementRequest, PlayElementRequest) == ErrorOccurred){
  	  	MakeError(TCP_SendFail);
  		return ErrorOccurred;
  	}
  }  
        
  if ( 	(SendData(&request, sizeof(AssetPresentationRequest)) == ErrorOccurred) ||
  	(SendData(playlist, sizeof(PlayElementRequest)*size) == ErrorOccurred) ){// ||
  	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }

  return NoError;
}

int
Server::get_assetpresentation_response(struct in_addr *ipaddr, ULINT *port, ULINT *dgram_size, ULINT *bitrate)
{
  PacketHeader header;
  AssetPresentationResponse response;
  int buffersize;
  char *buffer;

  if (GetData((void*)&header, sizeof(PacketHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (header.command_number != COMMAND_assetpres_response) {
    	MakeError(VSP_UnknownMessage);
    	return ErrorOccurred;
  }
    // certification code
  if (GetData((void*)&response, sizeof(AssetPresentationResponse)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&response, map_AssetPresentationResponse, AssetPresentationResponse) == ErrorOccurred) {
    	MakeError(TCP_ReadFail);
  	return ErrorOccurred;
  }

  if (response.certification_code != certification_code++){
  	MakeError(VSP_ServerCertError);
  	return ErrorOccurred;
  }
  
  buffersize = (int) (response.command_length+4) - sizeof(AssetPresentationResponse);

  if (buffersize != 0) {	// get scene information
   	if ( (buffer = new char[buffersize]) ==NULL)
	    MakeError(VSP_Alloc);
  	else {
		if (GetData((void*)buffer, buffersize) == ErrorOccurred)
  			return ErrorOccurred;	//Null
  		delete buffer;
  	}
  } // scene info exists
  
  ipaddr->s_addr = (u_long) response.server_IP;
  *port = response.server_port;
  *dgram_size = assetresponse_dgram_size = response.datagram_size;
  *bitrate = response.bit_rate;

  if (response.result != 0){
    MakeError(VSP_ServerError);
    return ErrorOccurred;
  }

  return NoError;
}

int
Server::send_playback_request(ULINT MAX_storableBlocks)
{
  PlayBackRequest request;
 
  if (MAX_storableBlocks > NEC_databurstval){
    MakeError(VSP_InvalidValue);
    return ErrorOccurred;
  }
  
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_playback_request;

  request.command_length = sizeof(PlayBackRequest) - 8;
  request.certification_code = certification_code;
  request.playback_id = 0;	// this is just a recognisable number it shouldn't mean anything
  request.playback_mode = 0;
  request.time_mode = 0;
  request.time_spec = 0;
  request.skip_rate = 0;
  request.data_type = 0;
  request.data_rate = 0;
  request.max_received = MAX_requested_block;	
  request.request_sequence_num = MAX_requested_block = MAX_storableBlocks + MAX_requested_block;
  
  request.datagram_size = assetresponse_dgram_size;
  request.play_live_margin = 0;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = 0;

  if (hton_structure((void*)&request, map_PlayBackRequest, PlayBackRequest) == ErrorOccurred){
  	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }	
  
  if (SendData((void*)&request, sizeof(PlayBackRequest)) == ErrorOccurred)
  	return ErrorOccurred;
  	    
  return NoError;
}

int
Server::get_playback_response(ULINT *result)
{
  PlayBackResponse response;
  
  if (GetData((void*)&response, sizeof(PlayBackResponse)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&response, map_PlayBackResponse, PlayBackResponse) == ErrorOccurred) {
    	MakeError(TCP_ReadFail);
  	return ErrorOccurred;
  }

  if (response.result != 0){
    *result = response.result;
    MakeError(VSP_ServerError);
    return ErrorOccurred;
  }

  return NoError;
}
 
//--------------------------------------------------------public methods---------------

Server::Server(char *server, char *port):Error()
{
  PacketHeader				header;
  ControlPortNumberNotification		cpnn;  

  if ( Connect(server, port) != ErrorOccurred ){			// connect to known port
    	 SocketDescriptor.getPeerPort(&connection_port);
  	 if (GetData((void*)(&header), sizeof(PacketHeader)) != ErrorOccurred ){
  		if (header.command_number == COMMAND_CPNN) {		// check packet type
  			if ( GetData((void*)&cpnn, sizeof(cpnn)) != ErrorOccurred ) {
  				SocketDescriptor.close();		// close known port
  				if (cpnn.result != 0)
    					MakeError(VSP_ServerError);
  				else
  				if (Connect(server, (int)(cpnn.connection_port_number>>16)) == ErrorOccurred)
  					SocketDescriptor.close();	// attempt to connect to given port
 			}
 			else { // get CPNN
        		     SocketDescriptor.close();			// close on error
  			}
  		}
  		else { // not CPNN message
  		     MakeError(VSP_UnknownMessage);
        	}
        }
        else { // get header
             SocketDescriptor.close();					// close on error
        }
  }// connected to known port

  comms_flag = NoServerComms;
  // certification_code is never initialised as it is a comparitive value its initial value doesn't matter
}

Server::~Server()
{
  SocketDescriptor.close();
}

Server::Server(Server *server)
{
  PacketHeader				header;
  ControlPortNumberNotification		cpnn;
  
  struct in_addr server_addr;
  server->SocketDescriptor.getPeerAddress(&server_addr);
  
  connection_port = ntohs(server->connection_port);
  
  if ( Connect(server_addr, connection_port) != ErrorOccurred ){	// connect to known port
  	if ( GetData((void*)(&header), sizeof(PacketHeader)) != ErrorOccurred ){
  		if (header.command_number == COMMAND_CPNN) {		// check packet type
  			if ( GetData((void*)&cpnn, sizeof(cpnn)) != ErrorOccurred ) {
  				SocketDescriptor.close();		// close known port
  				if (cpnn.result != 0)
    					MakeError(VSP_ServerError);
  				else
  				if (Connect(server_addr, (int)(cpnn.connection_port_number>>16)) == ErrorOccurred)
  					SocketDescriptor.close();	// attempt to connect to given port
 			}
 			else { // get CPNN
        		     SocketDescriptor.close();			// close on error
 			}
  		}
  		else { // not CPNN message
  		     MakeError(VSP_UnknownMessage);
        	}
        }
        else { // get header
             SocketDescriptor.close();					// close on error
        }
  }// connected to known port
  comms_flag = NoServerComms;
  // certification_code is never initialised as it is a comparitive value its initial value doesn't matter
}

int
Server::getSocket(Socket *s)
{
    if (!SocketDescriptor.valid()) {
        MakeError(TCP_SocketError);
        return ErrorOccurred;
    }
    *s = SocketDescriptor;		// block copy
    return NoError;
}


int
Server::SendData(void *buffer, int size)
{
    if (SocketDescriptor.write(buffer, size) != size) {
        MakeError(TCP_SendFail);
        return ErrorOccurred;
    }
    return NoError;
}

int
Server::GetData(void *buffer, int size)
{
   if (SocketDescriptor.read(buffer, size) != size) {
        MakeError(TCP_ReadFail);
        return ErrorOccurred;
    }
    return NoError;
}

int
Server::PeekHeader(int *command)
{
  PacketHeader header;

    if (SocketDescriptor.read(&header, sizeof(PacketHeader), MSG_PEEK) != sizeof(PacketHeader)) {
    	return ErrorOccurred;
    }
    *command = header.command_number;
    return NoError;
} 
 
int
Server::inetevent(int *event, ULINT *result)
{
  StartEndNotification notify;
  
  *result = 0;
  int buffer;
  
  if (PeekHeader(event) == ErrorOccurred){
    return NoError;	// no data
  }
  
  switch (*event) {
  	case COMMAND_startend_notification:
  		if (GetData(&notify, sizeof(StartEndNotification)) == ErrorOccurred)
    			return ErrorOccurred;
    		if (ntoh_structure(&notify, map_StartEndNotification, StartEndNotification) == ErrorOccurred){
    			MakeError(TCP_ReadFail);
    			return  ErrorOccurred;
    		}
#ifdef DEBUG    		
    		Debug("start end notification @ block %i\n", notify.trans_block_num);
#endif    		
    		*result = (int)notify.trans_block_num;
    	        break;
    	case COMMAND_playback_response:
    		if (get_playback_response(result) == ErrorOccurred)
    			return ErrorOccurred;
    		break;
    	default:
#ifdef DEBUG    
    		Debug("TCP: inet ignore command %2.2X\n", *event);
#endif    		
    		while (SocketDescriptor.read(&buffer, 4)==4);
    		break;
    		
  }
  return NoError;
}

int
Server::SendAck(ULINT MAX_storableBlocks, ULINT MAX_complete_block, int datatype)
{
  int result = !ErrorExists();
  
  if (((MAX_storableBlocks - MAX_complete_block) > NEC_databurstval)||(MAX_storableBlocks < MAX_complete_block)
  	||(MAX_storableBlocks < MAX_requested_block)) {
#ifdef DEBUG  	  
  	  Debug("Error in Send Ack (%i-%i) max = %i", MAX_storableBlocks, MAX_complete_block, MAX_requested_block);
#endif  	  
    MakeError(VSP_InvalidValue);
    result = ErrorOccurred;
  }
  else {
  	//ACK initialise
  	ack.interface_number = 0;
  	ack.route_type = 0;
  	ack.command_number = COMMAND_ACK;
 	ack.command_length = sizeof(ACK_Block)-8;
  	ack.certification_code = 0;	// not used
  	ack.data_rate = 0;		// not used
  	// ACK use
  	ack.data_type = datatype;
  	ack.min_sequence = MAX_complete_block;
  	ack.max_sequence = MAX_requested_block = MAX_storableBlocks;
  	ack.RFU[0] = ack.RFU[1] = ack.RFU[2] = ack.RFU[3] = ack.RFU[4] = 0x00;
  
  	if (hton_structure(&ack, map_ACK_Block, ACK_Block) == ErrorOccurred){
    		MakeError(TCP_SendFail);
  		result =  ErrorOccurred;
  	}
  	comms_flag = ServerComms;		// communicated with server;
  	result = SendData((void*)&ack, sizeof(ACK_Block));
  }
  return result;
}

int
Server::SendNak(ULINT BlockStart, LINT DatagramStart, ULINT BlockEnd, LINT DatagramEnd)
{
  //NAK initialise
  nak.interface_number = 0;
  nak.route_type = 0;
  nak.command_number = COMMAND_NAK;
  nak.command_length = sizeof(NAK_Block)-8;
  nak.certification_code = 0;	// not used
  //NAK use
  nak.BlockStart = BlockStart;
  nak.DatagramStart = DatagramStart;
  nak.BlockEnd = BlockEnd;
  nak.DatagramEnd = DatagramEnd;
  nak.RFU[0] = nak.RFU[1] = nak.RFU[2] = nak.RFU[3] = nak.RFU[4] = 0x00;

  if (hton_structure(&nak, map_NAK_Block, NAK_Block) == ErrorOccurred){
    	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }
  comms_flag = ServerComms;		// communicated with server;
  return SendData((void*)&nak, sizeof(NAK_Block));
}

int
Server::GetAssetList(_kernel_swi_regs *regs)
{
  int expected_number, result = !ErrorExists();
  
  expected_number = regs->r[4];	// this is the number of assets that we expect to receive
  
  if ((result != ErrorOccurred)&&(regs->r[5] == 0)){
    regs->r[6] = regs->r[4] * sizeof(AssetIDDescriptor);
  }
  else {
  	if ((result != ErrorOccurred)&&(( send_assetlist_request(regs->r[2], regs->r[3], regs->r[4]) == ErrorOccurred) ||
  	    (get_assetlist_response(&(regs->r[4]), (AssetIDDescriptor*)regs->r[5], &(regs->r[6])) == ErrorOccurred)))
  		result = ErrorOccurred;
  	else {
  	  if (regs->r[4] == expected_number)
  		regs->r[3] += regs->r[4] + 1;
  	  else
  	  	regs->r[3] = -1;
  	}
  }
  return result;
}

int
Server::GetSceneAssetList(_kernel_swi_regs *regs)
{
  regs = regs;
  
  MakeError(VSP_Unimplemented);
  return ErrorOccurred;
}
int
Server::AssetPresentation(int init_value, PlayElementRequest playlist[], int size, struct in_addr *ipaddr, ULINT *port, ULINT *dgram_size, ULINT *bitrate)
{
  if (ErrorExists()) {
    return ErrorOccurred;
  }

  if (	(send_assetpresentation_request(init_value, playlist, size, (*ipaddr), (*port)) == ErrorOccurred ) ||
 	(get_assetpresentation_response(ipaddr, port, dgram_size, bitrate) == ErrorOccurred) )
     return ErrorOccurred;

  SocketDescriptor.eventsOn();
  SocketDescriptor.makeNonBlocking();
  return NoError;
}

int
Server::AssetEnd(int status, int endflag)
{
   AssetEndRequest request;
   AssetEndResponse response;
   int command;
   ULINT result;
      
   
   SocketDescriptor.eventsOff();
   SocketDescriptor.makeBlocking();
  
   request.interface_number = 0;
   request.route_type = 0;
   request.command_number = COMMAND_assetend_request;
   request.command_length = sizeof(AssetEndRequest) - 8;
   request.certification_code = certification_code;
   if (endflag != 0) endflag = 1;
   request.end_flag = endflag;
   request.asset_status = status;

   if ( hton_structure(&request, map_AssetEndRequest, AssetEndRequest) == ErrorOccurred) {
     	MakeError(TCP_SendFail);
     	return ErrorOccurred;
   }

   if  (SendData((void*)&request, sizeof( AssetEndRequest)) == ErrorOccurred)
     	return ErrorOccurred;
   
   PeekHeader(&command);
   
   while (command != COMMAND_assetend_response) {	// internet events are off but we will need to
     	if (inetevent(&command, &result) == ErrorOccurred)		// clear the queue
     		return ErrorOccurred;
   }

   if (GetData((void*)&response, sizeof(AssetEndResponse)) == ErrorOccurred)
   	return ErrorOccurred;

   if ( ntoh_structure(&response, map_AssetEndResponse, AssetEndResponse) == ErrorOccurred) {
     	MakeError(TCP_ReadFail);
     	return ErrorOccurred;
   }
   
   if (response.certification_code != certification_code++){
   	MakeError(VSP_ServerCertError);
   	return ErrorOccurred;
   }
#ifdef DEBUG
   else
        Debug("assetend result = (%i)\n", response.result);
#endif       
  
   return NoError;
}

int
Server::Play(ULINT MAX_storableBlock)
{
  if (ErrorExists()) {
    return ErrorOccurred;
  }
    
  if (send_playback_request(MAX_storableBlock) == ErrorOccurred ){
  	return ErrorOccurred;
  }
  	
  return NoError;
}
