/**************************************
 Server.c

implements standard Server class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include <string.h>
#include "NECstruct.h"
#include "ServCtrl.h"

#include "kernel.h"
#include "swis.h"

// this routine construct the connection to the specified server on the
// specified port.  It sets up the SocketDescriptor (of class Socket)
// to act as the communications end-point.  All socket operations may
// only be performed through the Socket methods

ServerList::~ServerList(void){
  for(int i = 0; i < CurrentSize; i++){
    	if (object[i] != NULL) {
  		delete ((Server*)object[i]);
  		object[i] = NULL;
  	}
  }
  ExpectedSize = CurrentSize = 0;
}

error_flag
ServerList::Remove(int identifier)
{
  int i =0;	// count value
  error_flag result = ErrorState();
  
  --ExpectedSize;
  
  if (result != ErrorOccurred) {
  
  	while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  	if (i == CurrentSize){
  		MakeError(VSP_UnknownObj);
        	result = ErrorOccurred;
  	}

	if (result != ErrorOccurred){
  		delete (Server*)object[i]; object[i] = NULL;
  
  		while (i < CurrentSize -1){
    			object[i] = object[i+1];
    			identifiers[i] = identifiers[i+1];
    			i++;
  		}
  		--CurrentSize;
  
  		if (decreasesize() != ErrorOccurred)		// this does test for sufficient decrease in size
  			result = ErrorOccurred;
  	}
  }
  return ErrorOccurred;
}

//--------------------------------------------- Server Specific ---------------------------------

error_flag
Server::setSocketError(int socket_result)
{
    error_flag result = ErrorState();
        
        if ((result != ErrorOccurred)&&(socket_result < 0)) {
                switch (errno) {
                        default:
                                MakeError(TCP_SocketError);
                                break;
                        case ECONNREFUSED:
                                MakeError(TCP_ConnectionRefused);
                                break;
                        case ENOENT:
                                MakeError(TCP_UnknownServer);
                                break;
                        case EINVAL:
                                MakeError(TCP_BadPortSpecification);
                                break;
                        case ENOBUFS:
                        	MakeError(TCP_NoBuffer);
                        	break;
                }
                result = ErrorOccurred;
        }
        else {
                result = NoError;
        }
        return result;
}

error_flag
Server::Connect(char *server_name, char *service)
{
  // Create a TCP socket
  SocketDescriptor = Socket::creat();
  if (!SocketDescriptor.valid()) {
    MakeError(TCP_SocketError);
    return ErrorOccurred;
  }
  else {
    // OK - made the socket, now connect it to the remote end
    return setSocketError(SocketDescriptor.connect(server_name, service));
  }
}

error_flag
Server::Connect(struct in_addr server_name, int service)
{
  // Create a TCP socket
  SocketDescriptor = Socket::creat();
  if (!SocketDescriptor.valid()) {
    MakeError(TCP_SocketError);
    return ErrorOccurred;
  }
  else {
    // OK - made the socket, now connect it to the remote end
    return setSocketError(SocketDescriptor.connect(server_name, service));
  }
}

error_flag
Server::Connect(char *server_name, int service)
{
  // Create a TCP socket
  SocketDescriptor = Socket::creat();
  if (!SocketDescriptor.valid()) {
    MakeError(TCP_SocketError);
    return ErrorOccurred;
  }
  else {
    // OK - made the socket, now connect it to the remote end
    return setSocketError(SocketDescriptor.connect(server_name, service));
  }
}

//--------------------------------------------------------
error_flag
Server::send_assetlist_request(int select_flags, int start, int number)

{
  AssetListRequest request;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_assetlist_request;

  request.command_length = sizeof(AssetListRequest)-8;		// size of structure - header.
  request.certification_code = certification_code;
  request.request_type = 0x01;
  request.continuity_flag = 0x01;
  request.asset_status_selection = select_flags&0xff;
  request.asset_type_selection = (select_flags>>8)&0xff;
  request.starting_entry = start;
  request.number_of_entries = number;
  request.sort_type =  (select_flags>>16)&0xff;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0x00;

  if (hton_structure(&request, map_AssetListRequest, AssetListRequest) == ErrorOccurred){
  	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }
  
  if (SendData((void*)&request, sizeof(AssetListRequest)) == ErrorOccurred)
  	return ErrorOccurred;

  return NoError;
}

error_flag
Server::get_assetlist_response(int *number, AssetIDDescriptor *buffer, int *buffer_size)
{
  // this pans out as r4, r5, r6
  
  PacketHeader header;
  AssetListResponseHeader alr_header;
  int asset_count;
  
  if (ErrorExists())
  	return ErrorOccurred;

  if (GetData((void*)&header, sizeof(PacketHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (header.command_number != COMMAND_assetlist_response) {
    	MakeError(VSP_UnknownMessage);
    	return ErrorOccurred;
  }

  if (GetData((void*)&alr_header, sizeof(AssetListResponseHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&alr_header, map_AssetListResponseHeader, AssetListResponseHeader) == ErrorOccurred){
    	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }

  if (alr_header.certification_code != certification_code++){
  	MakeError(VSP_ServerCertError);
  	return ErrorOccurred;
  }
  
  if ((*number) == 0)
  	(*number) = (int)alr_header.total_number_of_assets;
  else {
    	asset_count = 0;
    	while ((asset_count < (*number))&&(asset_count < alr_header.number_of_entries)
    		&&( (asset_count+1) * sizeof(AssetIDDescriptor) <= (*buffer_size)) ) {
    		  
   		if (GetData((void*)&(buffer[asset_count]), sizeof(AssetIDDescriptor)) == ErrorOccurred)
  			return ErrorOccurred;	//Null
  		
  		if (ntoh_structure((void*)&(buffer[asset_count]), map_AssetIDDescriptor, AssetIDDescriptor) == ErrorOccurred){
  	  		MakeError(TCP_ReadFail);
  			return ErrorOccurred;
  		}
  		asset_count++;
  	}// while
  	(*number) = asset_count;
  	(*buffer_size) -= (asset_count)*sizeof(AssetIDDescriptor);
  }
  if (alr_header.result != 0){
    MakeError(VSP_ServerError);
    return ErrorOccurred;
  }
  return NoError;
}

error_flag
Server::send_assetpresentation_request(int init_value, PlayElementRequest playlist[], int size, struct in_addr ipaddr, ULINT port)
{
  AssetPresentationRequest request;
  int i;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_assetpres_request;

  request.command_length = sizeof(AssetPresentationRequest)-8 + (size * sizeof(PlayElementRequest));
  request.certification_code = certification_code;
  request.client_type = 1; 				// as per specification
  request.packet_interval = 0;	// (visit)		// packet transition interval environment var
  request.initial_packet_num = init_value;
  MAX_requested_block = init_value -1;
  request.my_udp_port = port;				// source.port_num;
  if (size == 1)
  	request.playlist_num = 0;
  else
  	request.playlist_num = size;
  request.QOS_control = 0;				// as per specification
  strncpy(((char*)&(request.log_comment)), "LOG COMMENT: Mon 28th", 64);
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = 0;

  if (hton_structure(&request, map_AssetPresentationRequest, AssetPresentationRequest) == ErrorOccurred) {
         MakeError(TCP_SendFail);
         return ErrorOccurred;
  }

  request.my_IP_address = (int)ipaddr.s_addr;		// my_IP_address of source object;

  for (i = 0; i < size; i++){
  	if (hton_structure(&(playlist[i]), map_PlayElementRequest, PlayElementRequest) == ErrorOccurred){
  	  	MakeError(TCP_SendFail);
  		return ErrorOccurred;
  	}
  }  
        
  if ( 	(SendData(&request, sizeof(AssetPresentationRequest)) == ErrorOccurred) ||
  	(SendData(playlist, sizeof(PlayElementRequest)*size) == ErrorOccurred) ){// ||
  	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }

  return NoError;
}

error_flag
Server::get_assetpresentation_response(struct in_addr *ipaddr, ULINT *port, ULINT *dgram_size, ULINT *bitrate, int *fast_playback_ratio)
{
  PacketHeader header;
  AssetPresentationResponse response;
  int buffersize;
  char *buffer;

  if (GetData((void*)&header, sizeof(PacketHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (header.command_number != COMMAND_assetpres_response) {
    	MakeError(VSP_UnknownMessage);
    	return ErrorOccurred;
  }
    // certification code
  if (GetData((void*)&response, sizeof(AssetPresentationResponse)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&response, map_AssetPresentationResponse, AssetPresentationResponse) == ErrorOccurred) {
    	MakeError(TCP_ReadFail);
  	return ErrorOccurred;
  }

  if (response.certification_code != certification_code++){
  	MakeError(VSP_ServerCertError);
  	return ErrorOccurred;
  }
  
  buffersize = (int) (response.command_length+4) - sizeof(AssetPresentationResponse);

  if (buffersize != 0) {	// get scene information
   	if ( (buffer = new char[buffersize]) ==NULL)
	    MakeError(VSP_Alloc);
  	else {
		if (GetData((void*)buffer, buffersize) == ErrorOccurred)
  			return ErrorOccurred;	//Null
  		delete buffer;
  	}
  } // scene info exists
  
  ipaddr->s_addr = (u_long) response.server_IP;
  *port = response.server_port;
  *dgram_size = assetresponse_dgram_size = response.datagram_size;
  *bitrate = response.bit_rate;
  *fast_playback_ratio = (int)response.ff_ratio;

  if (response.result != 0){
    MakeError(VSP_ServerError);
    return ErrorOccurred;
  }

  return NoError;
}

error_flag
Server::send_playback_request(int state_id, ULINT MAX_storableBlock, ULONG AckSeq, int time, int mode)
{
  PlayBackRequest request;
 
  if ((MAX_storableBlock-AckSeq) > NEC_databurstval){
    MakeError(VSP_InvalidValue);
    return ErrorOccurred;
  }

#ifdef DEBUGLIB  
  Debug("play request(%i) %i - %i, time(%i), mode (%i)", state_id, MAX_storableBlock, AckSeq, time, mode);
#endif
  
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_playback_request;

  request.command_length = sizeof(PlayBackRequest) - 8;
  request.certification_code = certification_code;
  request.playback_id = state_id;
  //if (time == 0) {
  	request.playback_mode = mode;
 	request.time_mode = 0;	// always normal
  //}else {
  //	request.playback_mode = 0;
  //	request.time_mode = mode;
  //}    
  request.time_spec = time;
  request.skip_rate = 0;
  request.data_type = 0;
  request.data_rate = 0;
  request.max_received = AckSeq;
  request.request_sequence_num = MAX_requested_block = MAX_storableBlock;
  request.datagram_size = 0;
  request.play_live_margin = 0;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = 0;

  if (hton_structure((void*)&request, map_PlayBackRequest, PlayBackRequest) == ErrorOccurred){
  	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }	
  
  if (SendData((void*)&request, sizeof(PlayBackRequest)) == ErrorOccurred)
  	return ErrorOccurred;
  	    
  return NoError;
}

error_flag
Server::get_playback_response(ULINT *result)
{
  PlayBackResponse response;
  
  if (GetData((void*)&response, sizeof(PlayBackResponse)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&response, map_PlayBackResponse, PlayBackResponse) == ErrorOccurred) {
    	MakeError(TCP_ReadFail);
  	return ErrorOccurred;
  }

  if (response.result != 0){
    *result = response.result;
    MakeError(VSP_ServerError);
    return ErrorOccurred;
  }

  return NoError;
}
 
//--------------------------------------------------------public methods---------------
error_flag
Server::InitVar(void)
{
  comms_flag = no_comms;
  // certification_code is never initialised as it is a comparitive value its initial value doesn't matter
    	ack.interface_number = 0;
  	ack.route_type = 0;
  	ack.command_number = COMMAND_ACK;
 	ack.command_length = sizeof(ACK_Block)-8;
  	ack.certification_code = 0;	// not used
  	ack.data_rate = 0;		// not used
 	ack.RFU[0] = ack.RFU[1] = ack.RFU[2] = ack.RFU[3] = ack.RFU[4] = 0x00;
   	hton_structure(&ack, map_ACK_Block, ACK_Block);
  	//NAK initialise
  	nak.interface_number = 0;
  	nak.route_type = 0;
  	nak.command_number = COMMAND_NAK;
  	nak.command_length = sizeof(NAK_Block)-8;
  	nak.certification_code = 0;	// not used
  	nak.RFU[0] = nak.RFU[1] = nak.RFU[2] = nak.RFU[3] = nak.RFU[4] = 0x00;
  	hton_structure(&nak, map_NAK_Block, NAK_Block);
 
  return NoError;
}
Server::Server(char *server, char *port, int timeout):Error()
{
  PacketHeader				header;
  ControlPortNumberNotification		cpnn;  

  timeout_period = timeout;
  
  if ( Connect(server, port) != ErrorOccurred ){			// connect to known port
    	 SocketDescriptor.getPeerPort(&connection_port);
  	 if (GetData((void*)(&header), sizeof(PacketHeader)) != ErrorOccurred ){
  		if (header.command_number == COMMAND_CPNN) {		// check packet type
  			if ( GetData((void*)&cpnn, sizeof(cpnn)) != ErrorOccurred ) {
  				SocketDescriptor.close();		// close known port
  				if (cpnn.result != 0)
    					MakeError(VSP_ServerError);
  				else
  				if (Connect(server, (int)(cpnn.connection_port_number>>16)) == ErrorOccurred)
  					SocketDescriptor.close();	// attempt to connect to given port
 			}
 			else { // get CPNN
        		     SocketDescriptor.close();			// close on error
  			}
  		}
  		else { // not CPNN message
  		     MakeError(VSP_UnknownMessage);
        	}
        }
        else { // get header
             SocketDescriptor.close();					// close on error
        }
  }// connected to known port
  InitVar();
}

Server::~Server()
{
  SocketDescriptor.close();
}

Server::Server(Server *server)
{
  PacketHeader				header;
  ControlPortNumberNotification		cpnn;
  
  timeout_period = server->timeout();
  
  struct in_addr server_addr;
  server->SocketDescriptor.getPeerAddress(&server_addr);
  
  connection_port = ntohs(server->connection_port);
  
  if ( Connect(server_addr, connection_port) != ErrorOccurred ){	// connect to known port
  	if ( GetData((void*)(&header), sizeof(PacketHeader)) != ErrorOccurred ){
  		if (header.command_number == COMMAND_CPNN) {		// check packet type
  			if ( GetData((void*)&cpnn, sizeof(cpnn)) != ErrorOccurred ) {
  				SocketDescriptor.close();		// close known port
  				if (cpnn.result != 0)
    					MakeError(VSP_ServerError);
  				else
  				if (Connect(server_addr, (int)(cpnn.connection_port_number>>16)) == ErrorOccurred)
  					SocketDescriptor.close();	// attempt to connect to given port
 			}
 			else { // get CPNN
        		     SocketDescriptor.close();			// close on error
 			}
  		}
  		else { // not CPNN message
  		     MakeError(VSP_UnknownMessage);
        	}
        }
        else { // get header
             SocketDescriptor.close();					// close on error
        }
  }// connected to known port
  InitVar();
}

error_flag
Server::getSocket(Socket *s)
{
    if (!SocketDescriptor.valid()) {
        MakeError(TCP_SocketError);
        return ErrorOccurred;
    }
    *s = SocketDescriptor;		// block copy
    return NoError;
}


error_flag
Server::SendData(void *buffer, int size)
{
  error_flag result = ErrorState();
 
  unsigned int t1, t2;
  int sent_size = 0;
  
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
   
   while ((sent_size = SocketDescriptor.write(buffer, size)) != size) {
     	if (sent_size < 0){
     		result = setSocketError(sent_size);
     		break;
     	}
     		
   	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
     	if (t2 > (t1 + timeout_period)){
        	MakeError(TCP_SendFail);
        	result = ErrorOccurred;
        	break;
     	}
    }
    
  return result;
}

error_flag
Server::GetData(void *buffer, int size)
{
  error_flag result = ErrorState();
 
  unsigned int t1, t2;
  int get_size = 0;
  
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
   
  while ((get_size = SocketDescriptor.read(buffer, size, MSG_PEEK)) != size) {
    	if (get_size < 0){
    		result = setSocketError(get_size);
    		break;
    	}
    		
   	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
   	if (t2 > (t1 + timeout_period)){
   		MakeError(TCP_TimeOutOnReceive);
   		result = ErrorOccurred;
   		break;
   	}
   }	
 
   if ((result != ErrorOccurred)&&(SocketDescriptor.read(buffer, size) != size)) {
        MakeError(TCP_ReadFail);
        return ErrorOccurred;
   }

   return NoError;
}

#ifdef DEBUGLIB
int
Server::ReadDataToDebug(void)
{
  int data, size, size_total = 0;
  
    while ( (size = SocketDescriptor.read(&data, sizeof(int))) == sizeof(int) ) {
    	size_total += size;
    	Debug("data %8.8X", data);
    }
    if (size == -1)    
    	Debug("data errno %i", errno);
    	
    return size_total;
} 
#endif  

error_flag
Server::PeekHeader(int *command)
{
  PacketHeader header;

    if (SocketDescriptor.read(&header, sizeof(PacketHeader), MSG_PEEK) != sizeof(PacketHeader)) {
    	return ErrorOccurred;
    }
    *command = header.command_number;
    return NoError;
} 
 
error_flag
Server::inetevent(int *event, ULINT *result)
{
  StartEndNotification notify;
  
  *result = 0;
  int buffer;
  
  if (PeekHeader(event) == ErrorOccurred){
    return NoError;	// no data
  }
  
  switch (*event) {
  	case COMMAND_startend_notification:
  		if (GetData(&notify, sizeof(StartEndNotification)) == ErrorOccurred)
    			return ErrorOccurred;
    		if (ntoh_structure(&notify, map_StartEndNotification, StartEndNotification) == ErrorOccurred){
    			MakeError(TCP_ReadFail);
    			return  ErrorOccurred;
    		}
#ifdef DEBUGLIB    		
    		Debug("start end notification @ block %i\n", notify.trans_block_num);
#endif    		
    		*result = (int)notify.trans_block_num;
    	        break;
    	case COMMAND_playback_response:
    		if (get_playback_response(result) == ErrorOccurred)
    			return ErrorOccurred;
    		break;
    	case COMMAND_assetend_response:
    		break;
    	default:
#ifdef DEBUGLIB    
    		Debug("TCP: inet ignore command %2.2X\n", *event);
#endif    		
    		while (SocketDescriptor.read(&buffer, 4)==4);
    		break;
    		
  }
  return NoError;
}

error_flag
Server::SendAck(ULINT MAX_storableBlocks, ULINT MAX_complete_block, ACK_type datatype)
{
  	ack.data_type =    (LINT)ntohl(datatype);
  	ack.min_sequence = (ULINT)ntohl(MAX_complete_block);
  	ack.max_sequence = (ULINT)ntohl(MAX_storableBlocks);
  	
	//Debug("A %i-%i, %i", MAX_storableBlocks, MAX_complete_block, datatype);
	
  	comms_flag = comms;		// communicated with server;
  	
  	if (SendData((void*)&ack, sizeof(ACK_Block)) == ErrorOccurred){
  	//  	Debug("A error %i", errno);
  		if (ErrorNum() == TCP_NoBuffer){
  			RemoveErr();
  		}
  	}
  	else
  		MAX_requested_block = (MAX_storableBlocks);
  		
  return ErrorState();
}

error_flag
Server::SendNak(ULINT BlockStart, LINT DatagramStart, ULINT BlockEnd, LINT DatagramEnd)
{
  	nak.BlockStart =    (ULINT)ntohl(BlockStart);
  	nak.DatagramStart = (LINT)ntohl(DatagramStart);
  	nak.BlockEnd =      (ULINT)ntohl(BlockEnd);
 	nak.DatagramEnd =   (LINT)ntohl(DatagramEnd);

	//Debug("N %i-%i, %i-%i", BlockStart, DatagramStart, BlockEnd, DatagramEnd);

	comms_flag = comms;		// communicated with server;
	
  	if (SendData((void*)&nak, sizeof(NAK_Block)) == ErrorOccurred)
  	//  	Debug("N error %i", errno);
  		if (ErrorNum() == TCP_NoBuffer){
  			RemoveErr();
  		}
  			
  return ErrorState();	
}

error_flag
Server::GetAssetList(_kernel_swi_regs *regs)
{
  int expected_num_assets;
  error_flag result = ErrorState();
  
  expected_num_assets = regs->r[4];	// this is the number of assets that we expect to receive
  
  if ((result != ErrorOccurred)&&(regs->r[5] == 0)){
    regs->r[6] = regs->r[4] * sizeof(AssetIDDescriptor);
  }
  else {
  	if ((result != ErrorOccurred)&&(( send_assetlist_request(regs->r[2], regs->r[3], regs->r[4]) == ErrorOccurred) ||
  	    (get_assetlist_response(&(regs->r[4]), (AssetIDDescriptor*)regs->r[5], &(regs->r[6])) == ErrorOccurred)))
  		result = ErrorOccurred;
  	else {
  	  if (regs->r[4] == expected_num_assets)
  		regs->r[3] += regs->r[4] + 1;
  	  else
  	  	regs->r[3] = -1;
  	}
  }
  return result;
}

error_flag
Server::GetSceneAssetList(_kernel_swi_regs *regs)
{
  regs = regs;
  
  MakeError(VSP_Unimplemented);
  return ErrorOccurred;
}

error_flag
Server::AssetPresentation(int init_value, PlayElementRequest playlist[], int size, struct in_addr *ipaddr, 
								ULINT *port, ULINT *dgram_size, ULINT *bitrate, int *fast_playback_ratio)
{
  if (ErrorExists()) {
    return ErrorOccurred;
  }

  if (	(send_assetpresentation_request(init_value, playlist, size, (*ipaddr), (*port)) == ErrorOccurred ) ||
 	(get_assetpresentation_response(ipaddr, port, dgram_size, bitrate, fast_playback_ratio) == ErrorOccurred) )
     return ErrorOccurred;

  SocketDescriptor.eventsOn();
  SocketDescriptor.makeNonBlocking();
  return NoError;
}

error_flag
Server::AssetEnd(int status, int endflag)
{
   AssetEndRequest request;
   AssetEndResponse response;
   int command = 0;
   
   error_flag result = NoError;
   unsigned int t1, t2;
   
   if (ErrorExists()){
     switch(ErrorNum()){
        case TCP_UnknownService:
        case TCP_BadPortSpecification:
        case TCP_UnknownServer:
        case TCP_SocketError:
        case TCP_ConnectionRefused:
        case TCP_ReadFail:
        case TCP_SendFail:
        case TCP_TimeOutOnReceive:
             return ErrorOccurred;
             
     	default:
  		RemoveErr();	// it doesn't matter now we are trying to get out
  		break;
     }
   }
   
   SocketDescriptor.eventsOff();
   //SocketDescriptor.makeBlocking();
  
   request.interface_number = 0;
   request.route_type = 0;
   request.command_number = COMMAND_assetend_request;
   request.command_length = sizeof(AssetEndRequest) - 8;
   request.certification_code = certification_code;
   if (endflag != 0) endflag = 1;
   request.end_flag = endflag;
   request.asset_status = status;

   if ( hton_structure(&request, map_AssetEndRequest, AssetEndRequest) == ErrorOccurred) {
     	MakeError(TCP_SendFail);
     	return ErrorOccurred;
   }
   
   (void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
   
   do {   // loop until we receive end request dialogue

     ULINT comms_result;
     
     		// roughly every second send a request
     	if (( !((t2-t1) | 0x7f) ) &&(SendData((void*)&request, sizeof( AssetEndRequest)) == ErrorOccurred)){
   		if (ErrorNum() == TCP_NoBuffer){
  			RemoveErr();
  		}	
  		else
     			result = ErrorOccurred;
     	}
     	
     	result = inetevent(&command, &comms_result);	// clear the queue this clears start end notifications

   	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
   	
     	if (t2 > (t1 + timeout_period)){
#ifdef DEBUGLIB     	  
   		Debug("timeout on receiving asset end");
#endif
     	  	MakeError(TCP_TimeOutOnReceive);
     		return ErrorOccurred;
     	}
   }
   while ((result != ErrorOccurred)&&(command != COMMAND_assetend_response));
   if (result == ErrorOccurred)
   	return result;

   if (GetData((void*)&response, sizeof(AssetEndResponse)) == ErrorOccurred)
   	return ErrorOccurred;

   if ( ntoh_structure(&response, map_AssetEndResponse, AssetEndResponse) == ErrorOccurred) {
     	MakeError(TCP_ReadFail);
     	return ErrorOccurred;
   }
   
   if (response.certification_code != certification_code++){
   	MakeError(VSP_ServerCertError);
   	return ErrorOccurred;
   }
#ifdef DEBUGLIB
   else
        Debug("assetend result = (%i)\n", response.result);
#endif       
  
   return NoError;
}
