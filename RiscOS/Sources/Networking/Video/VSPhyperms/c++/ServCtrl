/**************************************
 Server.c

implements standard Server class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include <string.h>
#include "NECstruct.h"
#include "ServCtrl.h"

#include "kernel.h"
#include "swis.h"

// this routine construct the connection to the specified server on the
// specified port.  It sets up the SocketDescriptor (of class Socket)
// to act as the communications end-point.  All socket operations may
// only be performed through the Socket methods

ServerList::~ServerList(void){
  for(int i = 0; i < CurrentSize; i++){
    	if (object[i] != NULL) {
  		delete ((Server*)object[i]);
  		object[i] = NULL;
  	}
  }
  ExpectedSize = CurrentSize = 0;
}

error_flag
ServerList::Remove(int identifier)
{
  int i =0;	// count value
  error_flag result = ErrorState();
  
  --ExpectedSize;
  
  if (result != ErrorOccurred) {
  
  	while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  	if (i == CurrentSize){
  		MakeError(VSP_UnknownObj);
        	result = ErrorOccurred;
  	}

	if (result != ErrorOccurred){
	  	if (!( ((Server*)object[i])->stream_uses() ))
  			delete (Server*)object[i];	// delete if not used in a stream
  		else
  			((Server*)object[i])->clear_interface_owner();
  			
  		object[i] = NULL;
  
  		while (i < CurrentSize -1){
    			object[i] = object[i+1];
    			identifiers[i] = identifiers[i+1];
    			i++;
  		}
  		--CurrentSize;
  
  		if (decreasesize() != ErrorOccurred)		// this does test for sufficient decrease in size
  			result = ErrorOccurred;
  	}
  }
  return ErrorOccurred;
}

//--------------------------------------------- Server Specific ---------------------------------

error_flag
Server::setSocketError(int socket_result)
{
    error_flag result = ErrorState();
        
        if ((result != ErrorOccurred)&&(socket_result < 0)) {
                switch (errno) {
                        default:
                                MakeError(TCP_SocketError);
                		result = ErrorOccurred;
                                break;
                        case ECONNREFUSED:
                                MakeError(TCP_ConnectionRefused);
                		result = ErrorOccurred;
                                break;
                        case ENOENT:
                                MakeError(TCP_UnknownServer);
                		result = ErrorOccurred;
                                break;
                        case EINVAL:
                                MakeError(TCP_BadPortSpecification);
                		result = ErrorOccurred;
                                break;
                        case ENOBUFS:
                        	MakeError(TCP_NoBuffer);
                		result = ErrorOccurred;
                        	break;
                        case EWOULDBLOCK:
                        	result = NoError;
                }
        }
        else {
                result = NoError;
        }
        return result;
}

error_flag
Server::Connect(char *server_name, char *service)
{
  // Create a TCP socket
  SocketDescriptor = Socket::creat();
  if (!SocketDescriptor.valid()) {
    MakeError(TCP_SocketError);
    return ErrorOccurred;
  }
  else {
    // OK - made the socket, now connect it to the remote end
    return setSocketError(SocketDescriptor.connect(server_name, service));
  }
}

error_flag
Server::Connect(struct in_addr server_name, int service)
{
  // Create a TCP socket
  SocketDescriptor = Socket::creat();
  if (!SocketDescriptor.valid()) {
    MakeError(TCP_SocketError);
    return ErrorOccurred;
  }
  else {
    // OK - made the socket, now connect it to the remote end
    return setSocketError(SocketDescriptor.connect(server_name, service));
  }
}

error_flag
Server::Connect(char *server_name, int service)
{
  // Create a TCP socket
  SocketDescriptor = Socket::creat();
  if (!SocketDescriptor.valid()) {
    MakeError(TCP_SocketError);
    return ErrorOccurred;
  }
  else {
    // OK - made the socket, now connect it to the remote end
    return setSocketError(SocketDescriptor.connect(server_name, service));
  }
}

//--------------------------------------------------------
error_flag
Server::send_assetlist_request(int select_flags, int start, int number)

{
  AssetListRequest request;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_assetlist_request;

  request.command_length = sizeof(AssetListRequest)-8;		// size of structure - header.
  request.certification_code = certification_code;
  request.request_type = 0x01;
  request.continuity_flag = 0x01;
  request.asset_status_selection = select_flags&0xff;
  request.asset_type_selection = (select_flags>>8)&0xff;
  request.starting_entry = start;
  request.number_of_entries = number;
  request.sort_type =  (select_flags>>16)&0xff;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0x00;

  if (hton_structure(&request, map_AssetListRequest, AssetListRequest) == ErrorOccurred){
  	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }
  
  if (SendData((void*)&request, sizeof(AssetListRequest)) == ErrorOccurred)
  	return ErrorOccurred;

  return NoError;
}

error_flag
Server::get_assetlist_response(int *number, AssetIDDescriptor *buffer, int *buffer_size)
{
  // this pans out as r4, r5, r6
  
  PacketHeader header;
  AssetListResponseHeader alr_header;
  int asset_count;
  
  if (ErrorExists())
  	return ErrorOccurred;

  if (GetData((void*)&header, sizeof(PacketHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (header.command_number != COMMAND_assetlist_response) {
    	MakeError(VSP_UnknownMessage);
    	return ErrorOccurred;
  }

  if (GetData((void*)&alr_header, sizeof(AssetListResponseHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&alr_header, map_AssetListResponseHeader, AssetListResponseHeader) == ErrorOccurred){
    	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }

  if (alr_header.certification_code != certification_code++){
  	MakeError(VSP_ServerCertError);
  	return ErrorOccurred;
  }
#ifdef DEBUGLIB  
  Debug("number %i, assets %i, entries %i, cont %x, result %i", (*number), alr_header.total_number_of_assets, 
  				alr_header.number_of_entries, alr_header.continuity_flag, alr_header.result);
#endif  
  if ((*number) == 0) // if a request for the number of assets
  	(*number) = (int)alr_header.total_number_of_assets;
  else {
    	asset_count = 0;
    	while ((asset_count < (*number))&&(asset_count < alr_header.number_of_entries)
    		&&( (asset_count+1) * sizeof(AssetIDDescriptor) <= (*buffer_size)) ) {
    		  
   		if (GetData((void*)&(buffer[asset_count]), sizeof(AssetIDDescriptor)) == ErrorOccurred){
   		  	if (ErrorNum() == TCP_TimeOutOnReceive){
   		  		RemoveErr();
   		  		break;
   		  	}
   		  	else
   		  		return ErrorOccurred;	//Null
  		}
  		
  		if (ntoh_structure((void*)&(buffer[asset_count]), map_AssetIDDescriptor, AssetIDDescriptor) == ErrorOccurred){
  	  		MakeError(TCP_ReadFail);
  			return ErrorOccurred;
  		}
  		/*
    		AssetIDDescriptor *asset = &buffer[asset_count];
    		
  		Debug("asset id (%i)", asset->asset_id); 
        	Debug("last update%8.8X%8.8X", (int)asset->time_of_last_update[8], (int)asset->time_of_last_update);     
        	Debug("registration %i", asset->registration);         
        	Debug("bitrate %i", asset->bit_rate);            
        	Debug("asset type %i", asset->asset_type);         
        	Debug("encoding %i", asset->encoding);           
        	Debug("block_length %i", asset->block_length);      
        	Debug("total time %i", asset->total_time);       
        	Debug("short title %s", asset->video_title); 
        	Debug("long title  %s", asset->full_title); 
        	Debug("ff time  %i", asset->ff_time);     
        	Debug("rw time  %i", asset->rw_time);     
        	Debug("video type  %i", asset->video_type);    
        	Debug("video status  %i", asset->video_status);
		*/
  		asset_count++;
  	}// while
  	(*number) = asset_count;
  	(*buffer_size) -= (asset_count)*sizeof(AssetIDDescriptor);
  }
  if (alr_header.result != 0){
    MakeError(VSP_ServerError);
    return ErrorOccurred;
  }
  return NoError;
}

error_flag
Server::send_scenelist_request(int asset_id)
{
  SceneListRequest request;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_scenelist_request;
  request.command_length = sizeof(SceneListRequest)-8;
  request.certification_code = certification_code;
  request.asset_id = asset_id;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0;

  if (hton_structure(&request, map_SceneListRequest, SceneListRequest) == ErrorOccurred){
  	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }
  
  if (SendData((void*)&request, sizeof(SceneListRequest)) == ErrorOccurred)
  	return ErrorOccurred;

  return NoError;
}

error_flag
Server::get_scenelist_response(int *number, SceneInformationDescriptor *buffer, int *buffer_size)
{
  // reads a maximum of number of assets into the buffer 
  
  SceneListHeader header;
  int asset_count;
 
  if (ErrorExists())
  	return ErrorOccurred;

  if (GetData((void*)&header, sizeof(SceneListHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&header, map_SceneListHeader, SceneListHeader) == ErrorOccurred){
    	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }

  if (header.command_number != COMMAND_scenelist_response) {
    	MakeError(VSP_UnknownMessage);
    	return ErrorOccurred;
  }

  if (header.certification_code != certification_code++){
  	MakeError(VSP_ServerCertError);
  	return ErrorOccurred;
  }
  
  if ((*number) == 0)
  	(*number) = (int)header.number_of_scenes;
  else {
    	asset_count = 0;
    	while ((asset_count < (*number))&&(asset_count < header.number_of_scenes)
    		&&( (asset_count+1) * sizeof(SceneInformationDescriptor) <= (*buffer_size)) ) {
    		  
   		if (GetData((void*)&(buffer[asset_count]), sizeof(SceneInformationDescriptor)) == ErrorOccurred)
  			return ErrorOccurred;	//Null
  		
  		if (ntoh_structure((void*)&(buffer[asset_count]), map_SceneInformationDescriptor, SceneInformationDescriptor) == ErrorOccurred){
  	  		MakeError(TCP_ReadFail);
  			return ErrorOccurred;
  		}
  		asset_count++;
  	}// while
   	(*number) = asset_count;
  	(*buffer_size) -= (asset_count)*sizeof(SceneInformationDescriptor);
  }
  
  // read the rest of the scenes from the socket
  if (asset_count >= header.number_of_scenes){
    	SceneInformationDescriptor descriptor;
  	while (asset_count < header.number_of_scenes){
  	   	if (GetData(&descriptor, sizeof(SceneInformationDescriptor)) == ErrorOccurred)
  			return ErrorOccurred;	//Null
  		++asset_count;
          }
  }
  if (header.result != 0){
    MakeError(VSP_ServerError);
    return ErrorOccurred;
  }
  return NoError;
}

error_flag
Server::send_assetpresentation_request(int init_value, PlayElementRequest playlist[], int size, struct in_addr ipaddr, ULINT port)
{
  AssetPresentationRequest request;
  int i;
 
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_assetpres_request;

  request.command_length = sizeof(AssetPresentationRequest)-8 + (size * sizeof(PlayElementRequest));
  request.certification_code = certification_code;
  request.client_type = 1; 				// as per specification
  request.packet_interval = 0;	// (visit)		// packet transition interval environment var
  request.initial_packet_num = init_value;
  MAX_requested_block = init_value -1;
  request.my_udp_port = port;				// source.port_num;
  if (size == 1)
  	request.playlist_num = 0;
  else
  	request.playlist_num = size;
  request.QOS_control = 0;				// as per specification

  unsigned int systime;
  _swix(OS_ReadMonotonicTime, _OUT(0), &systime);

  sprintf(((char*)&(request.log_comment)), "STB LOG:%i, timestamp in centiseconds\0",systime);
#ifdef DEBUGLIB
  Debug("STB LOG: timestamp in centiseconds %i",systime);
#endif  
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = 0;

  if (hton_structure(&request, map_AssetPresentationRequest, AssetPresentationRequest) == ErrorOccurred) {
         MakeError(TCP_SendFail);
         return ErrorOccurred;
  }

  request.my_IP_address = (int)ipaddr.s_addr;		// my_IP_address of source object;

  for (i = 0; i < size; i++){
  	if (hton_structure(&(playlist[i]), map_PlayElementRequest, PlayElementRequest) == ErrorOccurred){
  	  	MakeError(TCP_SendFail);
  		return ErrorOccurred;
  	}
  }  
        
  if ( 	(SendData(&request, sizeof(AssetPresentationRequest)) == ErrorOccurred) ||
  	(SendData(playlist, sizeof(PlayElementRequest)*size) == ErrorOccurred) ){// ||
  	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }

  return NoError;
}

error_flag
Server::get_assetpresentation_response(struct in_addr *ipaddr, ULINT *port, unsigned int *stream_time, 
						ULINT *dgram_size, ULINT *bitrate, int *fast_playback_ratio)
{
  PacketHeader header;
  AssetPresentationResponse response;
  int buffersize;
  char *buffer;

  if (GetData((void*)&header, sizeof(PacketHeader)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (header.command_number != COMMAND_assetpres_response) {
    	MakeError(VSP_UnknownMessage);
    	return ErrorOccurred;
  }
    // certification code
  if (GetData((void*)&response, sizeof(AssetPresentationResponse)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&response, map_AssetPresentationResponse, AssetPresentationResponse) == ErrorOccurred) {
    	MakeError(TCP_ReadFail);
  	return ErrorOccurred;
  }

  if (response.certification_code != certification_code++){
  	MakeError(VSP_ServerCertError);
  	return ErrorOccurred;
  }
  
  buffersize = (int) (response.command_length+4) - sizeof(AssetPresentationResponse);

  if (buffersize != 0) {	// get scene information
   	if ( (buffer = new char[buffersize]) ==NULL)
	    MakeError(VSP_Alloc);
  	else {
		if (GetData((void*)buffer, buffersize) == ErrorOccurred)
  			return ErrorOccurred;	//Null
  		delete buffer;
  	}
  } // scene info exists
  
   ipaddr->s_addr = (u_long) response.server_IP;
  *port = response.server_port;
  //if (response.datagram_size != 0)
  	*dgram_size = assetresponse_dgram_size = response.datagram_size;
  //else
  //	*dgram_size = assetresponse_dgram_size = SocketDescriptor.getDgramSize();
  
  *bitrate = response.bit_rate;
  *fast_playback_ratio = (int)response.ff_ratio;
  *fast_playback_ratio |= (int)((response.fast_playback)<<24);
  
  if (response.video_status != 0)
  	(*stream_time) = 0xFFFFFFFF;
  else
  	(*stream_time) = (unsigned int)response.total_time;
  
  if (response.result != 0){
    MakeError(VSP_ServerError);
    return ErrorOccurred;
  }

  return NoError;
}

error_flag
Server::send_playback_request(int state_id, ULINT MAX_storableBlock, ULONG AckSeq, int time, int mode)
{
  PlayBackRequest request;
 
  if ((MAX_storableBlock-AckSeq) > NEC_databurstval){
#ifdef DEBUGLIB
	Debug("invalid value in play request, %i-%i", MAX_storableBlock, AckSeq);
#endif	    
    MakeError(VSP_InvalidValue);
    return ErrorOccurred;
  }
  
  request.interface_number = 0;
  request.route_type = 0;
  request.command_number = COMMAND_playback_request;

  request.command_length = sizeof(PlayBackRequest) - 8;
  request.certification_code = certification_code;
  request.playback_id = state_id;
  request.playback_mode = mode;
  request.time_mode = 0;		// always normal ?? time specified means nothing
  request.time_spec = time;
  request.skip_rate = 0;
  request.data_type = 0;
  request.data_rate = 0;
  request.max_received = AckSeq;
  request.request_sequence_num = MAX_requested_block = MAX_storableBlock;
  request.datagram_size = 0;
  request.play_live_margin = 0;
  request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = 0;

  if (hton_structure((void*)&request, map_PlayBackRequest, PlayBackRequest) == ErrorOccurred){
  	MakeError(TCP_SendFail);
  	return ErrorOccurred;
  }	
  
  if (SendData((void*)&request, sizeof(PlayBackRequest)) == ErrorOccurred)
  	return ErrorOccurred;
  	    
  return NoError;
}

error_flag
Server::get_playback_response(ULINT *result)
{
  PlayBackResponse response;
  
  if (GetData((void*)&response, sizeof(PlayBackResponse)) == ErrorOccurred)
  	return ErrorOccurred;	//Null

  if (ntoh_structure(&response, map_PlayBackResponse, PlayBackResponse) == ErrorOccurred) {
    	MakeError(TCP_ReadFail);
  	return ErrorOccurred;
  }
  
  if (response.certification_code != certification_code++){
  	MakeError(VSP_ServerCertError);
  	return ErrorOccurred;
  }
    
  if (response.result != 0){
    *result = response.result;
    MakeError(VSP_ServerError);
    return ErrorOccurred;
  }

  return NoError;
}
 
//--------------------------------------------------------public methods---------------
error_flag
Server::InitVar(void)
{
  comms_flag = no_comms;
  // certification_code is never initialised as it is a comparitive value its initial value doesn't matter
    	ack.interface_number = 0;
  	ack.route_type = 0;
  	ack.command_number = COMMAND_ACK;
 	ack.command_length = sizeof(ACK_Block)-8;
  	ack.certification_code = 0;	// not used
  	ack.data_rate = 0;		// not used
 	ack.RFU[0] = ack.RFU[1] = ack.RFU[2] = ack.RFU[3] = ack.RFU[4] = 0x00;
   	hton_structure(&ack, map_ACK_Block, ACK_Block);
  	//NAK initialise
  	nak.interface_number = 0;
  	nak.route_type = 0;
  	nak.command_number = COMMAND_NAK;
  	nak.command_length = sizeof(NAK_Block)-8;
  	nak.certification_code = 0;	// not used
  	nak.RFU[0] = nak.RFU[1] = nak.RFU[2] = nak.RFU[3] = nak.RFU[4] = 0x00;
  	hton_structure(&nak, map_NAK_Block, NAK_Block);
 
  return NoError;
}
Server::Server(char *server, char *port, int timeout):Error()
{
  PacketHeader				header;
  ControlPortNumberNotification		cpnn;  

  timeout_period = timeout;
  
#ifdef DEBUGLIB
  Debug(" create server link");
#endif  
  if ( Connect(server, port) != ErrorOccurred ){			// connect to known port
    	 SocketDescriptor.getPeerPort(&connection_port);
  	 if (GetData((void*)(&header), sizeof(PacketHeader)) != ErrorOccurred ){
  		if (header.command_number == COMMAND_CPNN) {		// check packet type
  			if ( GetData((void*)&cpnn, sizeof(cpnn)) != ErrorOccurred ) {
  				SocketDescriptor.close();		// close known port
  				if (cpnn.result != 0)
    					MakeError(VSP_ServerError);
  				else
  				if (Connect(server, (int)(cpnn.connection_port_number>>16)) == ErrorOccurred)
  					SocketDescriptor.close();	// attempt to connect to given port
 			}
 			else { // get CPNN
        		     SocketDescriptor.close();			// close on error
  			}
  		}
  		else { // not CPNN message
  		     MakeError(VSP_UnknownMessage);
        	}
        }
        else { // get header
             SocketDescriptor.close();					// close on error
        }
  }// connected to known port
  InitVar();
}

Server::~Server()
{
#ifdef DEBUGLIB  
  Debug("delete control socket +");
  SocketDescriptor.close();
  Debug("delete control socket -");
#else
  SocketDescriptor.close();
#endif  
}

Server::Server(Server *server)
{
  PacketHeader				header;
  ControlPortNumberNotification		cpnn;

#ifdef DEBUGLIB  
  Debug(" create server link");
#endif  

  timeout_period = server->timeout();
  
  struct in_addr server_addr;
  server->SocketDescriptor.getPeerAddress(&server_addr);
  
  connection_port = ntohs(server->connection_port);
  
  if ( Connect(server_addr, connection_port) != ErrorOccurred ){	// connect to known port
  	if ( GetData((void*)(&header), sizeof(PacketHeader)) != ErrorOccurred ){
  		if (header.command_number == COMMAND_CPNN) {		// check packet type
  			if ( GetData((void*)&cpnn, sizeof(cpnn)) != ErrorOccurred ) {
  				SocketDescriptor.close();		// close known port
  				if (cpnn.result != 0)
    					MakeError(VSP_ServerError);
  				else
  				if (Connect(server_addr, (int)(cpnn.connection_port_number>>16)) == ErrorOccurred)
  					SocketDescriptor.close();	// attempt to connect to given port
 			}
 			else { // get CPNN
        		     SocketDescriptor.close();			// close on error
 			}
  		}
  		else { // not CPNN message
  		     MakeError(VSP_UnknownMessage);
        	}
        }
        else { // get header
             SocketDescriptor.close();					// close on error
        }
  }// connected to known port
  InitVar();
}

error_flag
Server::getSocket(Socket *s)
{
    if (!SocketDescriptor.valid()) {
        MakeError(TCP_SocketError);
        return ErrorOccurred;
    }
    *s = SocketDescriptor;		// block copy
    return NoError;
}


error_flag
Server::SendData(void *buffer, int size)
{
  error_flag result = ErrorState();
 
  unsigned int t1, t2;
  int sent_size = 0;
  
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
   
   while ((sent_size = SocketDescriptor.write(buffer, size)) != size) {
     	if (sent_size < 0){
     		result = setSocketError(sent_size);
     		break;
     	}
     		
   	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
     	if (t2 > (t1 + timeout_period)){
        	MakeError(TCP_SendFail);
        	result = ErrorOccurred;
        	break;
     	}
    }
    
  return result;
}

error_flag
Server::GetData(void *buffer, int size)
{
  error_flag result = ErrorState();
 
  unsigned int t1, t2;
  int get_size = 0;
  
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
   
  while ((result != ErrorOccurred)&&
  	((get_size = SocketDescriptor.read(buffer, size, MSG_PEEK)) != size)) {
    
   	result = setSocketError(get_size);
   		
   	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
   	if (t2 > (t1 + timeout_period)){
   		MakeError(TCP_TimeOutOnReceive);
   		result = ErrorOccurred;
   		break;
   	}
   }	
 
   if ((result != ErrorOccurred)&&(SocketDescriptor.read(buffer, size) != size)) {
        MakeError(TCP_ReadFail);
        result = ErrorOccurred;
   }

   return result;
}

#ifdef DEBUGLIB
int
Server::ReadDataToDebug(void)
{
  int data, size, size_total = 0;
  
    while ( (size = SocketDescriptor.read(&data, sizeof(int))) == sizeof(int) ) {
    	size_total += size;
    	Debug("data %8.8X", data);
    }
    if (size == -1)    
    	Debug("data errno %i", errno);
    	
    return size_total;
} 
#endif  

error_flag
Server::PeekHeader(int *command)
{
  PacketHeader header;

    if (SocketDescriptor.read(&header, sizeof(PacketHeader), MSG_PEEK) != sizeof(PacketHeader)) {
    	return ErrorOccurred;
    }
    *command = header.command_number;
    return NoError;
} 
 
error_flag
Server::inetevent(int *event, ULINT *result)
{
  StartEndNotification notify;
  
  *result = 0;
  int buffer;
  
  if (PeekHeader(event) == ErrorOccurred){
    return NoError;	// no data
  }
  
  switch (*event) {
  	case COMMAND_startend_notification:
  		if (GetData(&notify, sizeof(StartEndNotification)) == ErrorOccurred)
    			return ErrorOccurred;
    		if (ntoh_structure(&notify, map_StartEndNotification, StartEndNotification) == ErrorOccurred){
    			MakeError(TCP_ReadFail);
    			return  ErrorOccurred;
    		}
    		*result = (int)notify.trans_block_num;
    	        break;
    	case COMMAND_playback_response:
    		if (get_playback_response(result) == ErrorOccurred)
    			return ErrorOccurred;
    		break;
    	case COMMAND_assetend_response:
#ifdef DEBUGLIB    	
    		Debug("asset end response");
#endif    		
    		break;
    	default:

#ifdef DEBUGLIB    
    		Debug("TCP: inet ignore unknown command %2.2X\n", *event);
#endif    		
    		while (SocketDescriptor.read(&buffer, 4)==4);
    		break;
    		
  }
  return NoError;
}

error_flag
Server::SendAck(ULINT MAX_storableBlocks, ULINT MAX_complete_block, ACK_type datatype)
{
  error_flag result = NoError;
  
  	ack.data_type =    (LINT)ntohl(datatype);
  	ack.min_sequence = (ULINT)ntohl(MAX_complete_block);
  	ack.max_sequence = (ULINT)ntohl(MAX_storableBlocks);
  		
  	comms_flag = comms;		// communicated with server;
  	
  	int size = SocketDescriptor.write((void*)&ack, sizeof(ACK_Block));
  	if (size < 0){
#ifdef DEBUGLIB  	  
  	  	Debug("error sending ACK %i", errno);
#endif  	  	
     		result = setSocketError(size);
     		if (ErrorNum() == TCP_NoBuffer){
  			RemoveErr();
  		}
  	}
  	else
  		MAX_requested_block = (MAX_storableBlocks);
  		
  return result;
}

error_flag
Server::SendNak(ULINT BlockStart, LINT DatagramStart, ULINT BlockEnd, LINT DatagramEnd)
{
  	nak.BlockStart =    (ULINT)ntohl(BlockStart);
  	nak.DatagramStart = (LINT)ntohl(DatagramStart);
  	nak.BlockEnd =      (ULINT)ntohl(BlockEnd);
 	nak.DatagramEnd =   (LINT)ntohl(DatagramEnd);

	comms_flag = comms;		// communicated with server;
	
  	int size = SocketDescriptor.write((void*)&nak, sizeof(NAK_Block));
  	if (size < 0){
#ifdef DEBUGLIB  		  
  	  	Debug("error sending NAK %i", errno);
#endif  		  	
  		if (ErrorNum() == TCP_NoBuffer){
  			RemoveErr();
  		}
  	}
  			
  return ErrorState();	
}

error_flag
Server::GetAssetList(_kernel_swi_regs *regs)
{
  // register usage
  // r2 = selection flags
  // r3 = start
  // r4 = number of entries;
  // r5 = buffer
  // r6 = size of r5
  
  error_flag result = ErrorState();
  
  if (  (result != ErrorOccurred)&&(regs->r[4] == 0)&&
  	(( send_assetlist_request(regs->r[2], 0, 0) == ErrorOccurred) ||
  	    (get_assetlist_response(&(regs->r[4]), NULL, 0)== ErrorOccurred)) )
  		result = ErrorOccurred;		
  
  
  if ((result != ErrorOccurred)&&(regs->r[5] == 0)){
    	regs->r[6] = regs->r[4] * sizeof(AssetIDDescriptor);
  }
  else {
  	// read r4 assets whilst avoiding overflowing the socket buffer
    	int expected_num_assets = regs->r[4];
    	AssetIDDescriptor *buffer_offset = (AssetIDDescriptor*)regs->r[5];
    	
	// this is the number of entries that can be read at once without overflow
    	int number_entries = (int)((SocketDescriptor.getrecvspace()) - 
    				(sizeof(PacketHeader)+sizeof(AssetListResponseHeader)))/sizeof(AssetIDDescriptor); 	
    	
    	while ((result != ErrorOccurred)&&(regs->r[4] > 0)){
    	  
    	  	if (regs->r[4] < number_entries)
    	  		number_entries = regs->r[4];
    	  		
  		expected_num_assets = number_entries;	// this is the number of assets that we expect to receive
#ifdef DEBUGLIB  			
  		Debug("from %i buffer %8.8X, size %i expected num %i", regs->r[3], buffer_offset, regs->r[6], expected_num_assets);
#endif   		
  		if ((result != ErrorOccurred)&&(( send_assetlist_request(regs->r[2], regs->r[3], expected_num_assets) == ErrorOccurred) ||
  	    		(get_assetlist_response(&expected_num_assets, buffer_offset, &(regs->r[6])) == ErrorOccurred)))
  			result = ErrorOccurred;
  		else {
  		  	regs->r[4] -= expected_num_assets;		// decrement request count
  		  	regs->r[3] += expected_num_assets;		// increment start position
  		  	buffer_offset += expected_num_assets;
  		}
#ifdef DEBUGLIB  		
  		Debug("read %i buffer %8.8X, size %i new start %i", expected_num_assets, buffer_offset, regs->r[6], regs->r[3]);
#endif
   		if (expected_num_assets < number_entries)
  			break;
  	}
 	regs->r[4] = (buffer_offset - (AssetIDDescriptor*)regs->r[5]);
  }
  return result;
}

error_flag
Server::GetSceneAssetList(_kernel_swi_regs *regs)
{
  error_flag result = ErrorState();
  
  if (  (result != ErrorOccurred)&&(regs->r[5] != 0)&&
  	(( send_scenelist_request(regs->r[3]) == ErrorOccurred) ||
  	    (get_scenelist_response(&(regs->r[4]), (SceneInformationDescriptor*)regs->r[5], (int*)(&regs->r[6])) == ErrorOccurred)) )
  		result = ErrorOccurred;
  else {
    if ((result != ErrorOccurred)&&(regs->r[5] == 0)){
      if (regs->r[4] != 0)
      	regs->r[6] = regs->r[4] * sizeof(SceneInformationDescriptor);
      else
      	regs->r[6] = MAX_scene_list * sizeof(SceneInformationDescriptor);
    }
  }

  return result;
}

error_flag
Server::AssetPresentation(int init_value, PlayElementRequest playlist[], int size, unsigned int *stream_time, struct in_addr *ipaddr, 
								ULINT *port, ULINT *dgram_size, ULINT *bitrate, int *fast_playback_ratio)
{
  if (ErrorExists()) {
    return ErrorOccurred;
  }

  if (	(send_assetpresentation_request(init_value, playlist, size, (*ipaddr), (*port)) == ErrorOccurred ) ||
 	(get_assetpresentation_response(ipaddr, port, stream_time, dgram_size, bitrate, fast_playback_ratio) == ErrorOccurred) )
     return ErrorOccurred;

  SocketDescriptor.eventsOn();
  SocketDescriptor.makeNonBlocking();
  return NoError;
}

error_flag
Server::AssetEnd(int status, int endflag)
{
   AssetEndRequest request;
   AssetEndResponse response;
   
   error_flag result = NoError;
   unsigned int t1, t2;
   
   if (ErrorExists()){
     switch(ErrorNum()){
        case TCP_UnknownService:
        case TCP_BadPortSpecification:
        case TCP_UnknownServer:
        case TCP_SocketError:
        case TCP_ConnectionRefused:
        case TCP_ReadFail:
        case TCP_SendFail:
        case TCP_TimeOutOnReceive:
             return ErrorOccurred;
             
     	default:
  		RemoveErr();	// it doesn't matter now we are trying to get out
  		break;
     }
   }
   
   //SocketDescriptor.eventsOff();
  
   request.interface_number = 0;
   request.route_type = 0;
   request.command_number = COMMAND_assetend_request;
   request.command_length = sizeof(AssetEndRequest) - 8;
   request.certification_code = certification_code;
   if (endflag != 0)
   	request.end_flag = 1;
   else
   	request.end_flag = endflag;
   request.asset_status = status;
   request.RFU[0] = request.RFU[1] = request.RFU[2] = request.RFU[3] = request.RFU[4] = 0;

   if ( hton_structure(&request, map_AssetEndRequest, AssetEndRequest) == ErrorOccurred) {
     	MakeError(TCP_SendFail);
     	return ErrorOccurred;
   }
   
   	
   result = SendData((void*)&request, sizeof(AssetEndRequest));
  
   if (result != ErrorOccurred){
   	int command = 0;
   	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);
      	
   	do {   // loop until we receive end request dialogue

     		ULINT comms_result;
     
     		result = inetevent(&command, &comms_result);	// clear the queue this clears start end notifications

   		(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
   	
     		if (t2 > (t1 + timeout_period)){
#ifdef DEBUGLIB     	  
   			Debug("timeout on receiving asset end");
#endif
     	  		MakeError(TCP_TimeOutOnReceive);
     			return ErrorOccurred;
     		} 	
   	}
   	while (command != COMMAND_assetend_response);
   }
   
   if ((result != ErrorOccurred)&&(GetData((void*)&response, sizeof(AssetEndResponse)) == ErrorOccurred))
   	result = ErrorOccurred;

   	
   if ((result != ErrorOccurred)&&(ntoh_structure(&response, map_AssetEndResponse, AssetEndResponse) == ErrorOccurred)) {
     	MakeError(TCP_ReadFail);
     	result = ErrorOccurred;
   }
   	
   if ((result != ErrorOccurred)&&(response.certification_code != certification_code++)){
   	MakeError(VSP_ServerCertError);
   	return ErrorOccurred;
   }
#ifdef DEBUGLIB
   if (result != ErrorOccurred)
	Debug("asset end result (%i)", response.result);
   else
   	ErrorDump();
#endif   
   return NoError;
}
