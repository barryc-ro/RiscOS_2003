/**************************************
 Stream.c
	
impliments standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Stream.h"	// Source Element
#include "swis.h"
#include "string.h"

StreamToken::StreamToken()
{
  	list = NULL;
	block = NULL;
	block_header = NULL;
	in_use = free_token;
	list_size = 0;
	num_blocks = blocks_returned = 0;
}

StreamToken::~StreamToken(void)
{
  	delete[] list;
	list_size = 0;
	list = NULL;
  	block = NULL;		// this is assigned to point to source memory space
  	block_header = NULL;
	num_blocks = blocks_returned = 0;
}

error_flag
StreamToken::AllocList(int max_datagrams)
{
 	error_flag result = NoError;
 
  	list = new Bitstream_buffer_descriptor[max_datagrams];
  	 		
  	list_size = max_datagrams -1;
  	
 	if (list == NULL){
  	  	MakeError(VSP_Alloc);
  		result = ErrorOccurred;
  	}

  return result;
}

error_flag
Stream::MPEGBufferListToNECBlock(StreamToken *buffer)
{
  // this is operated under interupt so it is important that no shared memory is used
  // to this ends. nothing should touch a StreamToken if in_use != 0 and not
  // try to use read its memory it is owned by the MPEG module.
  
  // THIS METHOD RETURNS A TOKEN FROM THE MPEG PLAYER
  
  error_flag result = ErrorState();
 
  if ((buffer->block == NULL)||(buffer->list == NULL)){
    MakeError(VSP_BadErr);
    result = ErrorOccurred;
  }
   
  if ((result != ErrorOccurred)&&(( result = mysource->freeBlock(buffer->block)) == ErrorOccurred))
  	err = &mysource->ReturnCopyOfError();

  if ((result != ErrorOccurred)&&(callback_pending == 0)){    	
  	_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
 		else
 			callback_pending = (callback_flag)(callback_pending | callback_foreground);
  }
  
  buffer->block = NULL;
  buffer->block_header = NULL;
  buffer->blocks_returned = 0;
  buffer->num_blocks = 0;
  buffer->in_use = free_token;
 
  return result;
}

  // THIS METHOD PREPARES A TOKEN FOR THE MPEG PLAYER, 
  
  // these two methods are the gateway; nothing should touch
  // the buffer or the token until the above method is called.
  
error_flag
Stream::NECBlockToMPEGBufferList(StreamToken *buffer)
{
  int i = 0, j = 0;
  size_t remaining_header;	// this is the amount left to read into the header.
  error_flag result = ErrorState();
  
  if ((result != ErrorOccurred)&&
      ((buffer->block == NULL)||(buffer->block->iov_size == 0))||(buffer->block->iov_size > buffer->list_size)) {
    MakeError(VSP_BadBlock);	// test if the block looks dodgy.
    result = ErrorOccurred;
    }
  					// is out list still there
  if ((result != ErrorOccurred)&&(buffer->list == NULL)){
    MakeError(VSP_Alloc);
    result =  ErrorOccurred;
  }
  
  buffer->block_header = (NECBlockHeader*)buffer->block->iov[0].iov_base;
  
  if ((result != ErrorOccurred)&&(buffer->block->iov[i].iov_len < sizeof(NECBlockHeader))){
		MakeError(VSP_DatagramSizeError);
		result = ErrorOccurred;
  }	
	
  if (result !=ErrorOccurred) {
  	if (buffer->block_header->status_word & 0x10){	// if GOP exists
 		remaining_header = (int)buffer->block_header->GOP_start_offset;	
 							// calculate the offset to the data	
 		while( (result != ErrorOccurred)&&(remaining_header >= buffer->block->iov[i].iov_len)){
    			remaining_header -= buffer->block->iov[i].iov_len;
    			i++;
    			if ((int)buffer->block->iov[i].iov_base == NULL){
    				MakeError(VSP_BadBlock);
    				result =  ErrorOccurred;
                	}
        	}
        }
	else
		remaining_header = sizeof(NECBlockHeader);	// must be within one dgram else error
  }//no error
  
  // the only way to ensure it is valid memory is to copy it to valid memory
  memcpy((void*)&most_significant_block, (void*)buffer->block_header, sizeof(NECBlockHeader));
  if (ntoh_structure((void*)&most_significant_block, map_NECBlockHeader, NECBlockHeader) == ErrorOccurred){
  	MakeError(TCP_SendFail);
  	result = ErrorOccurred;
  }

  if (result != ErrorOccurred) {
  	buffer->list[j].free_routine = (int)VSP_MPEGCall;
  	buffer->list[j].free_workspace = (int)pw;
  	buffer->list[j].buffer_start_address = buffer->block->iov[i].iov_base + remaining_header;
  	buffer->list[j].buffer_length =  buffer->block->iov[i].iov_len - remaining_header;
  	buffer->list[j].packets = 0;
  
  	j++; i++;
  	while (i < buffer->block->iov_size){	// count the remainding NEC buffers
    		if ((int)buffer->block->iov[i].iov_base != NULL)
    		{
  			buffer->list[j-1].link = &buffer->list[j]; // last buffer equals this one.
    			buffer->list[j].free_routine = (int)VSP_MPEGCall;
    			buffer->list[j].free_workspace = (int)pw;
  			buffer->list[j].buffer_start_address = buffer->block->iov[i].iov_base;
  			buffer->list[j].buffer_length =  buffer->block->iov[i].iov_len;
  			buffer->list[j].packets = 0;
  			j++;
    		}
    		i++;
  	}
  	buffer->list[j-1].link = NULL; // last buffer equals this one.
  	
  }// error 
  buffer->blocks_returned = 0;
  
#ifdef OUTPUT_FILE
  buffer->num_blocks = 1;
#else
  buffer->num_blocks = j;
#endif

  if (buffer->num_blocks == 0) {
  	MakeError(VSP_BadBlock);
  	result = ErrorOccurred;
  }
  else 
  if (result != ErrorOccurred){
	result = mysink->FullBuffer(buffer->list);
  }
  return result;
}

error_flag
Stream::test_empty_buffers(void)
{
  int i, callback = 0, tokens = 0;
  error_flag result;
  result = ErrorState();
  
  if ( (result != ErrorOccurred)&&(state != state_stop) ) {
    
  	for (i = 0; (i<NUM_MPEG_Tokens); i++){
  		if (result != ErrorOccurred) {
    	  		if (buffers[i].in_use == free_token){
    	  		  	++tokens;
    	  		  
    	  	  		buffers[i].in_use = claim_token;	// paired with free block
    	  	  		result = mysource->getBlock(&(buffers[i].block));
 	  			if (result == ErrorOccurred){
 	  		  		err = &mysource->ReturnCopyOfError();
 	  			}
 	  			else {
 	  	     	  		if (buffers[i].block == NULL){
 	  	     	  	  		buffers[i].in_use = free_token;
 	  	     	  	  		++callback;
 	  	     	  		}
 	  	     	  		else {
 	  	     	  		  	--(mysource->full_blocks);
 	  	     	  		  	--tokens;
 	  	     	  		  	
						result = NECBlockToMPEGBufferList(&buffers[i]);
 	  	     	  		  	     	  	
 	  	     	  			if ((result == ErrorOccurred)&&(ErrorNum() == VSP_BadBlock)){
 	  	     	  				RemoveErr();
 	  	     	  			}	
 	  	     	  		} // != null
                        	} // !get block error occurred
 	        	}// not in use
 		}
  	}
  }
  if (tokens != 0)
  	callback_pending = (callback_flag)(callback_pending | callback_tokenfree);
  else
   	callback_pending = (callback_flag)(callback_pending & ~callback_tokenfree); 	
  	
  return result;
}

Stream::Stream(int initial_block, int MPEGid, PlayList playlist, int play_num, Server *server, int NumBlocks, 
					int BufferBlocks, void *pwork, int in_from, int in_to):Error()
{
  // server specific variables
  int BlockSize;		// data size calculation
  int num_dgrams; 		// maximum number of datagrams
  ULINT dgram_size, bitrate;
  in_addr ipAddress;		// structure defined in internet library
  ULINT portnum;			// of server object, receiving
    
  // STB specific variables
  Socket server_sock, source_sock;	// these are captured as part of the internet event
  source_flag = server_flag = free_token;
  
  (void) memset((void*)&most_significant_block, 0, sizeof(NECBlockHeader)); // zero initial block
  most_significant_block.block_number = initial_block;
  
  pw = pwork;
  from = in_from*2; to = in_to*2;
  callback_pending = (callback_flag)0;

  error_flag result = NoError;
  
  mysink = new Sink(MPEGid);
  state = state_prestart;		// set the state of play

  buffer_blocks = BufferBlocks;	
   
  if ((result != ErrorOccurred)&&(mysink->ErrorExists())) {
   	err = &mysink->ReturnCopyOfError();
   	result = ErrorOccurred;
  }
  else{ 	
    	myserver = new Server(server);				// create TCP link
  	mysource = new Source(NumBlocks);			// create UDP socket
 	
 	if (myserver->ErrorExists()){ 				// errors on creation of TCP
  		err = &myserver->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  	else 
  	if  (mysource->ErrorExists()&&(mysource->ErrorNum() != VSP_SourceUninit)){ // errors on creation of UDP
  		err = &mysource->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  }
  	
  if ((result != ErrorOccurred) &&		// on no error
  	   	( (mysource->getLocalPort((int*)&portnum)== ErrorOccurred)  ||	// get UDP port number for asset presentation
  	   	  (mysource->getSocket(&source_sock) == ErrorOccurred)    ) ){
  			err = &mysource->ReturnCopyOfError();
  			result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
  		((myserver->getSocket(&server_sock)) == ErrorOccurred)) {
    			err = &(myserver->ReturnCopyOfError());
    			result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
    	    	 ((source_sd = source_sock.getSocketDescriptor()) == -1) ||
    	         ((server_sd = server_sock.getSocketDescriptor()) == -1) ||
    	         (server_sock.getLocalAddress((in_addr*)&ipAddress) != 0) ){
    		      MakeError(TCP_SocketError);
    		      result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
  		((myserver->AssetPresentation(initial_block, playlist, play_num,
  						 &ipAddress, &portnum, &dgram_size, &bitrate, &fast_playback_ratio)) == ErrorOccurred)) {
   			err = &myserver->ReturnCopyOfError();
   			result = ErrorOccurred;
  }
  
  bitrate = (bitrate/8);  			// bytes per 2/3 sec's	this ensures enough dgrams
  num_dgrams = (int) (bitrate / (dgram_size-sizeof(NECDatagram)));  
  BlockSize =  num_dgrams * (int)dgram_size;		// calculation on datagram size and bitrate
 
  if (result != ErrorOccurred){
    for (int i=0; i < NUM_MPEG_Tokens; i++){
    	if (buffers[i].AllocList(num_dgrams) == ErrorOccurred) {
    	  	MakeError(VSP_Alloc);
    	  	result = ErrorOccurred;
    	}
    }
  }
  
  if ((result != ErrorOccurred)&&
   		(mysource->Allocate(BlockSize, initial_block, (size_t)dgram_size) == ErrorOccurred)){
  			err = &mysource->ReturnCopyOfError();
  			result = ErrorOccurred;

  }
  	
  ipAddress.s_addr = ntohl(ipAddress.s_addr);		// ipaddress of server as port are set in the asset presentation
  if ((result != ErrorOccurred)&&
  		(mysource->setServerDetails(ipAddress, (int)portnum) == ErrorOccurred)) {
  		      	   err = &mysource->ReturnCopyOfError();
 	 	      	   result = ErrorOccurred;
  }

  if (result != ErrorOccurred){
#ifdef DEBUGLIB    
        unsigned int mt_time;
    	_swix(OS_ReadMonotonicTime, _OUT(0), &mt_time);
    	Debug("send play prep ack %i", mt_time);
#endif   
 	result = myserver->SendAck(myserver->getMaxRequestedBlock(),
 			myserver->getMaxRequestedBlock(), play_preparation);// send request for play
  }
  
} 	// stream constructor

Stream::~Stream(void)
{
  int i, used_buffer = 1;	// token used by MPEG module
  
  source_flag = claim_token;
  if (myserver != NULL)
  	myserver->AssetEnd(0, (state == state_endreceived));
 
  if ((change_state(state_stop) != ErrorOccurred)||(ErrorNum() != VSP_CantDeleteSharedMemory)){
    	// this is because errors can occur including errors returned from the server not always shared memory
    	delete mysource; mysource = NULL;
  }
  else {
#ifdef DEBUGLIB
  	Debug("attempt to delete shared memory");
#endif 
    	do {	// this should never be called while buffers are owned by the mpeg player this is a last resort
    		RemoveErr();
 		mysink->DropBuffers();	
    	}
    	while (change_state(state_stop) == ErrorOccurred);
    	delete mysource; mysource = NULL;
  } 
  delete mysink;   mysink = NULL;
  delete myserver; myserver = NULL;

  for (i=0;i<NUM_MPEG_Tokens;i++) {
  	delete[] (buffers[i].list);	// allocated in block  	
  	buffers[i].list = NULL;
  }
  delete[] buffers;
}

error_flag
Stream::change_state(state_of_play new_state)
{ 
   error_flag result = ErrorState();
   int i;
   bool used_buffer = false;

#ifdef DEBUGLIB
	Debug("^state = %i", new_state);
#endif	
	   
   switch (new_state) {
     case state_stop:
   	if (state != state_stop){
   		mysource->setEndPlayState();		// this ensures no more data is copied upriver.
   		state = state_stop;
        }
     	for (i=0; i < NUM_MPEG_Tokens; i++){
     		if (buffers[i].in_use != free_token) {
     			used_buffer = true;
    		}
     	}
#ifdef DEBUGLIB
     	Debug("stream - cb %2.2X, t[0] (%i), t[1] = (%i)", 
    				callback_pending, (buffers[0].in_use == claim_token), (buffers[1].in_use== claim_token));
#endif    				
     	if (used_buffer == true){
     		MakeError(VSP_CantDeleteSharedMemory);
     		result = ErrorOccurred;
     	}
   	break;
     case state_pause:
     	if (state == state_endreceived) mysource->setFinalBlock(0);	// "that which was once dead"
     	if (state != state_pause) {
     		result = ReadNPT(&from);
   		from = from << 1;
     		state = state_pause;
     	}
     	break;
     case state_play:
     	if (state == state_endreceived) mysource->setFinalBlock(0);
        if (state != state_play) {
           	if (state != state_pause) {
     	  		callback_pending = (callback_flag) (callback_pending | callback_trickplay);
     	  		result = ReadNPT(&from);
   			from = from << 1;
   		}// if state is paused time is set at pause time, jumps reset this time
     		state = state_play;
	}
     	break;
     case state_fast_forward:
     	if (state == state_endreceived) mysource->setFinalBlock(0);
        if (state != state_fast_forward){
              	result = ReadNPT(&from);
   		from = from << 1;
         	state =  state_fast_forward;
     	  	callback_pending = (callback_flag) (callback_pending | callback_trickplay);
	}
     	break;
     case state_fast_rewind:
     	if (state == state_endreceived) mysource->setFinalBlock(0);
        if (state != state_fast_rewind){
           	result = ReadNPT(&from);
   		from = from << 1;
     		state =  state_fast_rewind;
     	  	callback_pending = (callback_flag) (callback_pending | callback_trickplay);
	}
     	break;
   }
 
   if ((callback_pending & callback_trickplay)&&(!(callback_pending & callback_foreground))) {
  	_kernel_oserror *e = _swix(OS_CallBack, _INR(0,1), VSP_CallBack, pw);	  	
 	if (e != NULL){
  		MakeError(e);
  		result = ErrorOccurred;
 	} 
    }

   return result;
}

error_flag
Stream::GetSinkHandle(void)
{
  if (mysink->GetHandle() == ErrorOccurred){
    	err = &(mysink->ReturnCopyOfError());
  	return ErrorOccurred;
  }
  else
  	return NoError;
}

error_flag 
Stream::CheckEOS(int *play_state)			// call to Decoder
{
  if ((state == state_stop)||(state == state_endreceived)){
  	(*play_state) = 1;
  }
  else
  	(*play_state) = 0;
  
  return ErrorState();
}

error_flag
Stream::SetSpeed(int direction, int speed)		// call to Decoder
{
  speed = speed;
  direction = direction;
  
#ifdef DEBUGLIB
  int NPT_time;
  ReadNPT(&NPT_time);
  Debug("set speed NPT = %i", NPT_time);
#endif  
  
  switch(speed) {
    case 0:
    	change_state(state_pause);
    	break;
    case 1:
    	if (direction == 1)
    		change_state(state_fast_forward);
    	else
    		change_state(state_play);
    	break;
    case -1:
     	if (direction == 1)
    		change_state(state_fast_rewind);
    	break;
    default:
  	MakeError(VSP_Unimplemented);
  }
  return ErrorState();
}

error_flag
Stream::SetPosition(int flags, int pos_time)	 // call to Decoder
{
  error_flag result = NoError;
  int NPT_time = (int)most_significant_block.playback_time;
  int abs_time;//, playback_id, AckNum;
  //size_t freebuf;
  
  if (flags == 1)
     abs_time = NPT_time + (pos_time * 2);
  else
  if (flags == 2)
     abs_time = NPT_time - (pos_time * 2);
  else
     abs_time = (pos_time <<1);
     
  from = abs_time;
  
  callback_pending = (callback_flag) (callback_pending | callback_trickplay);
  if (!(callback_pending & callback_foreground)) {
  	_kernel_oserror *e = _swix(OS_CallBack, _INR(0,1), VSP_CallBack, pw);	  	
 	if (e != NULL){
  		MakeError(e);
  		result = ErrorOccurred;
 	} 
  }

#ifdef DEBUGLIB
  Debug("set position flags (%i), time = (%i), abs (%i), NPT = (%i)", flags, pos_time, abs_time, from >> 1 );
#endif
   return result;
}

error_flag
Stream::ReadNPT(int *NPT_time)			// call to Decoder
{
  if ((state == state_fast_forward)||(state == state_fast_rewind))
    	(*NPT_time) = (int)((most_significant_block.playback_time*fast_playback_ratio) >> 1);
  else
  	(*NPT_time) = (int)(most_significant_block.playback_time >> 1); // div 2
  return NoError;
}

error_flag
Stream::GetMiscInfo(int *reg_r0, misc_5_10 *ptr, int size)
{
  int flags = (*reg_r0);
  
  switch (flags) {
    case 0:
    	if ( size < sizeof(misc_5_10) )
    		MakeError(VSP_InvalidValue);
    	else {
    	  	ptr->h_pixels = most_significant_block.image_width;
  		ptr->v_pixels = most_significant_block.image_height;
	 	ptr->play_time = most_significant_block.playback_time;
 	 	ptr->status_word = most_significant_block.status_word;
 	 	ptr->scene_number = most_significant_block.scene_number;
 	 	ptr->head_time = most_significant_block.video_start_time;
	 	ptr->end_time = most_significant_block.video_end_time;
 	 	ptr->encode_time = most_significant_block.encode_time;
	  	ptr->bitrate = most_significant_block.bit_rate_value;
    	}
    	break;
    case 1:
    	(*reg_r0) = trick_modes;
    	break;
    case 2:
    	if (state > state_still)
    		(*reg_r0) = state_play;
    	else
    		(*reg_r0) = state;
    	break;
#ifdef DEBUGLIB    	
    default:
    	if (ErrorExists()){
    	  	Debug("stream error exists");
    	  	if (err != NULL){
    	  	  	err->Print();
    	  	}
    	}
    	else
    	if (myserver->ErrorExists()){
    	  	Debug("server error");
    	}
    	else {
    	Debug("stream - cb %2.2X, t[0] (%i), t[1] = (%i)", 
    				callback_pending, (buffers[0].in_use == claim_token), (buffers[1].in_use== claim_token));
    	mysource->getMiscInfo(flags);
    	}
#endif    	
  }
  return ErrorState();
}

int
Stream::getBlockVal(void)
{
  int block;
  
  if ((block = mysource->getFinalBlock()) == 0)
    block = (int)most_significant_block.block_number;
  
  return block;
}
  
//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++

error_flag
Stream::timeslice(void)
{
  error_flag result = NoError;
  int foreground_flag = 0;
  
  if (state == state_stop) return result;
  
#ifdef DEBUGLIB
  Debug("+ts %2.2X, blocks %i, state %i", callback_pending, mysource->full_blocks, state);
#endif
		// if there is a request to change the mode of play
//	if (callback_pending & callback_PlayBufferError){
	  
//	}
//	else
	if (callback_pending & callback_trickplay){
	  
        	int playback_id, RequestNum, AckNum, play_mode = 0;
        	
        	callback_pending = (callback_flag)(callback_pending & ~callback_trickplay);
        	
        	switch (state){
        	  case state_fast_forward:
        	  	play_mode = 3;
        	  	break;
        	  case state_fast_rewind:
        	  	play_mode = 4;
        	  	break;
        	}
   	 	result = mysource->setNewPlayState(&playback_id, &RequestNum, &AckNum);
   		if (result != ErrorOccurred){
     	 		result = myserver->send_playback_request(playback_id, RequestNum, AckNum, from, play_mode);
     	 		if (result == ErrorOccurred){
     	 		  //
     	 		  //	if (myserver->ErrorNum() == TCP_NoBuffer){
     	 		  //	  	myserver->RemoveErr();
     	 		  //	  	callback_pending = (callback_flag)(callback_pending | callback_PlayBufferError);
     			//		_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), STREAM_NAK_timeout, VSP_CallAfter, pw);	 
 			//		if (e != NULL){
  			//			MakeError(e);
  			//			result = ErrorOccurred;
 			//		} 	
     	 		//  	}
     	 		//  	
     	 			err = &(myserver->ReturnCopyOfError());
     	 		}
                }
                
                callback_pending = (callback_flag)(callback_pending | callback_foreground);
                
                _kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), STREAM_NAK_timeout, VSP_CallAfter, pw);	  	
 		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
        }
        else {   // else, if we are freeing a buffer
  		if (callback_pending & callback_bufferfree){
  			callback_pending = (callback_flag)(callback_pending & ~callback_bufferfree);

  			result = mysource->calculate_freeBlocks();
  			result = test_empty_buffers();
  			  		
  			if (!(callback_pending & callback_foreground))
  				foreground_flag = 1;	// this restarts the Ack sequence on a full buffer
  		}
  		else {
  		  	if (callback_pending & callback_tokenfree)
  		  		result = test_empty_buffers();
  			foreground_flag = 1;
  		}
  		
  		if (foreground_flag == 1){
  			if (mysource->foregroundExecute(&callback_pending, myserver) == ErrorOccurred){
  				err = &mysource->ReturnCopyOfError();
  				result =  ErrorOccurred;
  			}
  			
  			if (callback_pending){
                		callback_pending = (callback_flag)(callback_pending | callback_foreground);
     				_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), STREAM_NAK_timeout, VSP_CallAfter, pw);	  	
 				if (e != NULL){
  					MakeError(e);
  					result = ErrorOccurred;
 				} 
  			}
  		}
  	}
  	// calculate if the mpeg player has tokens if so use them as timeout values
  	// also calculate if we own all the tokens then we are starting the stream
  	// wait for more than buffer blocks
  	
  	int token_buffers_free = 0;
  	
  	for (int i=0; i < NUM_MPEG_Tokens; i++)
  		if (buffers[i].in_use == free_token) 
  		  	++token_buffers_free;
  		  
  	if ((token_buffers_free == NUM_MPEG_Tokens)&&(mysource->full_blocks >= buffer_blocks)
  	    &&(result != ErrorOccurred)) {
 		result = test_empty_buffers();
  	}
#ifdef DEBUGLIB    	
 // Debug("-ts %2.2X", callback_pending);
  
  if (result == ErrorOccurred) {
    	Debug("stream error");
    	mysource->getMiscInfo(0);
    	if (err != NULL)
    		err->Print();
    	else
    		Debug("Null Error");
  }
#endif    	
  return result;
}

error_flag
Stream::server_inetevent(void)
{
  int event;
  ULINT comms_result;
  error_flag result;
  
  if ( myserver->inetevent(&event, &comms_result) == ErrorOccurred) {
  	err = &myserver->ReturnCopyOfError();
  	return ErrorOccurred;
  }
#ifdef DEBUGLIB  
  if (comms_result != 0)
  	Debug("erronous result form TCP event 0x%2.2X, result = %i\n", event, comms_result);

   if (event == COMMAND_playback_response)
  	Debug("+ + play response %i + +", comms_result);	
#endif  	
 
  if (event == COMMAND_startend_notification){
    if (state == state_prestart){
      
#ifdef DEBUGLIB      
        unsigned int mt_time;
    	_swix(OS_ReadMonotonicTime, _OUT(0), &mt_time);
    	Debug("received start notification %i", mt_time);
#endif    	
        result = change_state(state_play);
        result = timeslice();
    }
    else
    if (state == state_play){ 			// if already playing
    	mysource->setFinalBlock(comms_result);
    	change_state(state_endreceived);
    }
  }
  return result;
}

error_flag
Stream::DummyAckCall(void)
{
 if (state != state_stop) {
   if (myserver->comms_flag != comms)	// defined in the server class
 	if (myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock(), dummy_ack) == ErrorOccurred){
 		err = &(myserver->ReturnCopyOfError());
 		return ErrorOccurred;
 	}
 	myserver->comms_flag = no_comms;
 }
 return NoError;
}

#ifdef OUTPUT_FILE
error_flag
Stream::MPEGInterrupt(int)
{
  error_flag result = ErrorState();
  
  for (int i = 0; i < NUM_MPEG_Tokens; i++)
  	if (buffers[i].block != NULL){
  		result = MPEGBufferListToNECBlock(&buffers[i]);	
  	}
  return result;
}
#else
error_flag
Stream::MPEGInterrupt(int buffer_descriptor)
{
  int i;	// this runs under interrupt avoid changing other peoples variables
  error_flag result = ErrorState();
  
  i = 0;
  while (i < NUM_MPEG_Tokens) {	// remember if num_blocks is zero we cannot touch it.
    	if ((buffers[i].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[i].list)&&
      	    (buffer_descriptor <  (((int)buffers[i].list) + (buffers[i].num_blocks * sizeof(Bitstream_buffer_descriptor))) )){
      	  	buffers[i].blocks_returned++;
      	  	break; 	//claim
        }
        i++;
  }//while search buffers
 
  if ((i < NUM_MPEG_Tokens)&&(buffers[i].blocks_returned == buffers[i].num_blocks)){	// if we have received all the blocks free it  		  	
  	result = MPEGBufferListToNECBlock(&buffers[i]);		// this marks it as free
 				
  	callback_pending = (callback_flag)(callback_pending | callback_bufferfree);
    	_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 	if (e != NULL){
  		MakeError(e);
  		result = ErrorOccurred;
 	}
  }

  return result;
}
#endif

error_flag
Stream::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  if (mysource->serviceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    	err = &(mysource->ReturnCopyOfError());
    	return ErrorOccurred;
    }
  return NoError;
}

//+++++++++++++++++++++++++++++++ StreamList Methods ++++++++++++++++
StreamList::StreamList(void):List()
{
}

error_flag
StreamList::Add(Stream *str, int *id)
{
  int identifier;
  error_flag result = ErrorState();
  
  if (result != ErrorOccurred) {
  
  	identifier = str->GetSinkHandle();
  
  	while (EnsureUnique(identifier) == ErrorOccurred){
  	  RemoveErr();
  	  identifier++;
  	}
  
  	result = List::Add((void*)str, &identifier);
  	
  	(*id) = identifier;
  }	// if we cannot recover from this error

  return result;
}

error_flag
StreamList::identify(Stream **item, int identifier)
{
  return List::identify((void**)item, identifier);
}

StreamList::~StreamList(void)
{
  int i;
  
  ExpectedSize = 0;
  
  for (i=(CurrentSize-1); i>=0; i--){
    	delete (Stream*)object[i];			// delete from the top to the bottom
    	object[i] = NULL;
  }
  
  delete[] object; object = NULL;
  delete[] identifiers; identifiers = NULL;
  
  CurrentSize = 0;
}

error_flag
StreamList::Remove(int identifier)	// returns a boolean success value
{
  int i = 0;	// count value
  error_flag result = ErrorState();
   
 
  if (result != ErrorOccurred) {
   	if (ExpectedSize != CurrentSize){
 		MakeError(VSP_BadDelete);
  		return ErrorOccurred;
        }
        
  	--ExpectedSize;
  	
   	while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  	if (i == CurrentSize){
  		MakeError(VSP_UnknownObj);
        	result = ErrorOccurred;
  	}

	if (result != ErrorOccurred){
  		delete (Stream*)object[i]; 
  		object[i] = NULL;
  
  		while (i < CurrentSize -1){
    			object[i] = object[i+1];
    			identifiers[i] = identifiers[i+1];
    			i++;
  		}
  		--CurrentSize;

  		if (decreasesize() == ErrorOccurred)		// this does test for sufficient decrease in size
  			result = ErrorOccurred;
  	}
  }
  return result;
}

//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++
// the first argument is code or the out of band etc indicator.
error_flag 
StreamList::inetEvent(int, int identifier, claim_flag *claim, void *)
{
  error_flag result = ErrorState();

  int i;
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++){
  		Stream *stream = ((Stream*)object[i]);
    		if ((stream->getstate() != state_stop)&&(stream->source_sd == identifier)) {
        		if (stream->callback_pending & callback_foreground){	// remove ticket event
                		stream->callback_pending = (callback_flag)(stream->callback_pending & ~callback_foreground);
    				_kernel_oserror *e = _swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfter, stream->pw);	  	
				if (e != NULL){
  					MakeError(e);
  					result = ErrorOccurred;
 				}
 		        }
      			if (stream->mysource->ReadDatagrams(&(stream->callback_pending)) == ErrorOccurred) {
    				err = &stream->ReturnCopyOfError();
    				result = ErrorOccurred;
      			}
      			stream->callback_pending = (callback_flag)(stream->callback_pending | callback_foreground);
  			_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), STREAM_comms_timeout, VSP_CallAfter, stream->pw);	  	
 			if (e != NULL){						// reset ticker event
  				MakeError(e);
  				result = ErrorOccurred;
 			}
    	 		*claim = claim_event;
                } 
    		else 
    		if ((stream->server_sd) == identifier) {
     			if (stream->server_flag == free_token){
      				stream->server_flag = claim_token; 		// in use
      				if ( stream->server_inetevent() == ErrorOccurred){
    					err = &stream->ReturnCopyOfError();
    					result = ErrorOccurred;
      				}
	       			stream->server_flag = free_token; 	// not in use
        		}
        		*claim = claim_event; // claim even if in use
    		}
        }

  }
  return result;
}

error_flag
StreamList::TimeSliceCall(void *)
{
  error_flag result = ErrorState();
  int i;
  
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++){
    		Stream *stream = ((Stream*)object[i]);
    		if(stream->callback_pending){
    			if (stream->source_flag == free_token ){
      				stream->source_flag = claim_token; 		// in use
       				if (stream->timeslice() == ErrorOccurred){
    					err = &stream->ReturnCopyOfError();
    					result = ErrorOccurred;
      				}
      				stream->source_flag = free_token; 		// not in use
      				
      				if ( stream->state == state_stop) {
      		  			if ( stream->change_state(state_stop) == ErrorOccurred )
      		  	  			stream->RemoveErr();
      		  			else{
      		  				Remove(identifiers[i]);	// removeit from the list
      		  			}
      				}     		  	
	       			
			}
			else {
	  			if (stream->state != state_stop){
#ifdef DEBUGLIB	  	  
      					Debug("timeslice making callback");
#endif      			
      					_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, stream->pw);	  	
 						if (e != NULL){
  							MakeError(e);
  							result = ErrorOccurred;
 	        		                }
 	                        }
	                }
                }// callback_pending 		
        }
  }
  return result;
}

error_flag
StreamList::MPEGInterrupt(int buffer_descriptor)
{
  int i;
  error_flag result = ErrorState();
  
  if (result !=ErrorOccurred){
  	for (i=0;((i<CurrentSize)&&(result != ErrorOccurred));i++) {
    		if ( ((Stream*)object[i])->MPEGInterrupt(buffer_descriptor) == ErrorOccurred ) {
    			err = &( (Stream*)object[i])->ReturnCopyOfError();
    			result = ErrorOccurred;
    		}
  	}
  }
  return result;
}

error_flag
StreamList::DummyAckPoll(void)
{
  int i;
  error_flag result = ErrorState();

  if (result != ErrorOccurred){
  	for (i=0;((i<CurrentSize)&&(result != ErrorOccurred));i++)
    		if ( ((Stream*)object[i])->DummyAckCall() ) {
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			result = ErrorOccurred;
    		}
  }
  return result;
}

error_flag
StreamList::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  int i;
  error_flag result = ErrorState();
  
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++)
  		if ( ((Stream*)object[i])->ServiceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			result = ErrorOccurred;
                }
  }
  return result;
}
