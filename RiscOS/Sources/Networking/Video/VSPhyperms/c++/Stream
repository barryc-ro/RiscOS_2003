/**************************************
 Stream.c
	
impliments standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Stream.h"	// Source Element
#include "swis.h"
#include "string.h"

StreamToken::StreamToken()
{
	block = NULL;
	in_use = free_token;
	blocks_returned = 0;
}

StreamToken::~StreamToken(void)
{
 	block = NULL;		// this is assigned to point to source memory space
	blocks_returned = 0;
}

error_flag
Stream::MPEGBufferListToNECBlock(StreamToken *buffer)
{
  
  error_flag result = NoError;
 
  if (buffer->block == NULL){
    MakeError(VSP_BadErr);
    result = ErrorOccurred;
  }
   
  if ((result != ErrorOccurred)&&(( result = mysource->freeBlock(buffer->block)) == ErrorOccurred))
  	err = &mysource->ReturnCopyOfError();
  
  buffer->block = NULL;
  buffer->in_use = free_token;
 
  return result;
}

error_flag
Stream::NECBlockToMPEGBufferList(StreamToken *buffer)
{
  error_flag result = NoError;
  
  if ((buffer->block == NULL)||(buffer->block->num_buffers == 0)) {
    	MakeError(VSP_BadBlock);	// test if the block looks dodgy.
    	result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&(buffer->block->buffers[0].buffer_length < sizeof(NECBlockHeader))){
	MakeError(VSP_DatagramSizeError);
	result = ErrorOccurred;
  }	
  
  buffer->block->buffers[0].buffer_ptr    +=  sizeof(NECBlockHeader);
  buffer->block->buffers[0].buffer_length -=  sizeof(NECBlockHeader);
  
  for (int i = 0; i < buffer->block->max_buffers; i++){
        buffer->block->buffers[i].free_routine = (int)VSP_MPEGCall;
  	buffer->block->buffers[i].free_workspace = (int)pw;
  	buffer->block->buffers[i].packets = 0;
  }

  buffer->blocks_returned = 0;
  
#ifdef OUTPUT_FILE
  buffer->block->num_buffers = 1; // hack for testing or writing to file
#endif

  if (result != ErrorOccurred){
    	if ( buffer->block->buffers[0].buffer_length == 0)
    		result = mysink->FullBuffer((BitstreamBufferDescriptor*)buffer->block->buffers[0].link);
    	else
		result = mysink->FullBuffer(&(buffer->block->buffers[0]));
  }
  return result;
}

error_flag
Stream::test_empty_buffers(void)
{
  int i,  tokens = 0;
  error_flag result;
  result = ErrorState();
  
  if ( (result != ErrorOccurred)&&(state != state_stop) ) {
  	for (i = 0; (i<NUM_MPEG_Tokens); i++){
  		if ((result != ErrorOccurred)&&(buffers[i].in_use == free_token)){
    	  		++tokens;
    	  		  
    	  	  	buffers[i].in_use = claim_token;	// paired with free block
    	  	  	result = mysource->getBlock(&(buffers[i].block));
 	  		if ((result != ErrorOccurred)&&(buffers[i].block != NULL)){
				--tokens;
 	  	     		  result = NECBlockToMPEGBufferList(&buffers[i]);
                    	}
 	  		else {
                          	buffers[i].in_use = free_token;
 	  	      		err = &mysource->ReturnCopyOfError();
 	  	        } // !get block error occurred
 		}
  	}
  }
  if (tokens != 0)
  	callback_pending = (callback_flag)(callback_pending | callback_tokenfree);
  else
   	callback_pending = (callback_flag)(callback_pending & ~callback_tokenfree);
  	
  return result;
}

Stream::Stream(int inet_timeout, int initial_block, int MPEGid, PlayList playlist, int play_num, Server *server, int NumBlocks, 
	int source_recvspace, int BufferBlocks, void *pwork, int in_from, int in_to):Error()
{
  // server specific variables
  int BlockSize;		// data size calculation
  int num_dgrams; 		// maximum number of datagrams
  ULINT dgram_size, bitrate;
  in_addr ipAddress;		// structure defined in internet library
  ULINT portnum;			// of server object, receiving
    
  // STB specific variables
  Socket server_sock, source_sock;	// these are captured as part of the internet event
  source_flag = server_flag = free_token;
  comms_timeout = inet_timeout;

  pw = pwork;
  from = in_from*2; to = in_to*2;
  callback_pending = callback_bufferswait;

  error_flag result = NoError;
  
  mysink = new Sink(MPEGid);
  state = state_prestart;		// set the state of play

  buffer_blocks = BufferBlocks;	
   
  if ((result != ErrorOccurred)&&(mysink->ErrorExists())) {
   	err = &mysink->ReturnCopyOfError();
   	result = ErrorOccurred;
  }
  else{ 	
    	//myserver = new Server(server);				// create TCP link, copy passed server
    	myserver = server;
    	myserver->set_stream_owner();
  	mysource = new Source((comms_timeout+1)>>1, source_recvspace);			// create UDP socket
 	
 	if (myserver->ErrorExists()){ 				// errors on creation of TCP
  		err = &myserver->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  	else 
  	if  (mysource->ErrorExists()&&(mysource->ErrorNum() != VSP_SourceUninit)){ // errors on creation of UDP
  		err = &mysource->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  }
  	
  if ((result != ErrorOccurred) &&		// on no error
  	   	( (mysource->getLocalPort((int*)&portnum)== ErrorOccurred)  ||	// get UDP port number for asset presentation
  	   	  (mysource->getSocket(&source_sock) == ErrorOccurred)    ) ){
  			err = &mysource->ReturnCopyOfError();
  			result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
  		((myserver->getSocket(&server_sock)) == ErrorOccurred)) {
    			err = &(myserver->ReturnCopyOfError());
    			result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
    	    	 ((source_sd = source_sock.getSocketDescriptor()) == -1) ||
    	         ((server_sd = server_sock.getSocketDescriptor()) == -1) ||
    	         (server_sock.getLocalAddress((in_addr*)&ipAddress) != 0) ){
    		      MakeError(TCP_SocketError);
    		      result = ErrorOccurred;
  }
  if ((result != ErrorOccurred)&&
  		((myserver->AssetPresentation(initial_block, playlist, play_num,
  						 &ipAddress, &portnum, &dgram_size, &bitrate, &fast_playback_ratio)) == ErrorOccurred)) {
   			err = &myserver->ReturnCopyOfError();
   			result = ErrorOccurred;
  }

  bitrate = (bitrate/8);  			// bytes per 2/3 sec's	this ensures enough dgrams
  num_dgrams = (int) (bitrate / (dgram_size-sizeof(NECDatagram)));  
  BlockSize =  num_dgrams * (int)dgram_size;		// calculation on datagram size and bitrate
  if ((result != ErrorOccurred)&&
   		(mysource->Allocate(NumBlocks, BlockSize, initial_block, (size_t)dgram_size) == ErrorOccurred)){
  			err = &mysource->ReturnCopyOfError();
  			result = ErrorOccurred;

  }
  ipAddress.s_addr = ntohl(ipAddress.s_addr);		// ipaddress of server as port are set in the asset presentation
  if ((result != ErrorOccurred)&&
  		(mysource->setServerDetails(ipAddress, (int)portnum) == ErrorOccurred)) {
  		      	   err = &mysource->ReturnCopyOfError();
 	 	      	   result = ErrorOccurred;
  }

  if (result != ErrorOccurred){
#ifdef DEBUGLIB    
    	Debug("send play prep ack");
#endif   
 	result = myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock());// send request for play
        result = change_state(state_play);	// this will make an imediate callback for trickplay.
  }
} 	// stream constructor

Stream::~Stream(void)
{
  int used_buffer = 1;		// token used by MPEG module
  
  int status = 0;		// this is a code used in the server log.
  
  source_flag = claim_token;
  
  if (myserver != NULL)
  	myserver->AssetEnd(status, (state != state_endreceived));
 
  if ((change_state(state_stop) != ErrorOccurred)||(ErrorNum() != VSP_CantDeleteSharedMemory)){
    	// this is because errors can occur including errors returned from the server not always shared memory
    	delete mysource; mysource = NULL;
  }
  else {
#ifdef DEBUGLIB
  	Debug("attempt to delete shared memory");
#endif 
    	do {	// this should never be called while buffers are owned by the mpeg player this is a last resort
    		RemoveErr();
 		mysink->DropBuffers();	
    	}
    	while (change_state(state_stop) == ErrorOccurred);
    	delete mysource; mysource = NULL;
  }

  delete mysink;   mysink = NULL;
  if (myserver->interface_uses()){
#ifdef DEBUGLIB
    	Debug("don't delete server");
#endif    	
    	myserver->clear_stream_owner();
  }
  else  {
#ifdef DEBUGLIB
    	Debug("stream delete server");
#endif
  	delete myserver; myserver = NULL;
  }
}

error_flag
Stream::change_state(state_of_play new_state)
{ 
   error_flag result = ErrorState();
   int i;
   bool used_buffer = false;

#ifdef DEBUGLIB
	Debug("^state = %i", new_state);
#endif	
	   
   switch (new_state) {
     case state_endreceived:
     	state = state_endreceived;
     	break;
     case state_stop:
   	if (state != state_stop){
   	  	if (callback_pending & callback_timeout){
   			callback_pending = (callback_flag)(callback_pending & ~callback_timeout);
     			_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
     		}
   		mysource->setEndPlayState();		// this ensures no more data is copied upriver.
   		state = state_stop;
        }
     	for (i=0; i < NUM_MPEG_Tokens; i++){
     		if (buffers[i].in_use != free_token) {
     			used_buffer = true;
    		}
     	}
#ifdef DEBUGLIB
     	Debug("kill stream; flags %2.2X, tokens (%i)(%i)", 
    				callback_pending, (buffers[0].in_use == claim_token), (buffers[1].in_use== claim_token));
#endif    				
     	if (used_buffer == true){
     		MakeError(VSP_CantDeleteSharedMemory);
     		result = ErrorOccurred;
     	}
   	break;
     case state_pause:
     	if (state != state_pause) {
     		result = ReadNPT(&from);
   		from = from << 1;
     		state = state_pause;
     	}
     	break;
     case state_play:
        if (state != state_play) {
           	if (state != state_pause) {
     	  		callback_pending = (callback_flag) (callback_pending | callback_trickplay);
     	  		result = ReadNPT(&from);
   			from = from << 1;
   		}// if state is paused time is set at pause time, jumps reset this time
     		state = state_play;
	}
     	break;
     case state_fast_forward:
        if (state != state_fast_forward){
              	result = ReadNPT(&from);
   		from = from << 1;
         	state =  state_fast_forward;
     	  	callback_pending = (callback_flag) (callback_pending | callback_trickplay);
	}
     	break;
     case state_fast_rewind:
        if (state != state_fast_rewind){
           	result = ReadNPT(&from);
   		from = from << 1;
     		state =  state_fast_rewind;
     	  	callback_pending = (callback_flag) (callback_pending | callback_trickplay);
	}
     	break;
   }
   
   if (callback_pending & callback_trickplay) {
  	_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 	if (e != NULL){
  		MakeError(e);
  		result = ErrorOccurred;
 	} 
   }

   return result;
}

error_flag
Stream::GetSinkHandle(void)
{
  if (mysink->GetHandle() == ErrorOccurred){
    	err = &(mysink->ReturnCopyOfError());
  	return ErrorOccurred;
  }
  else
  	return NoError;
}

error_flag 
Stream::CheckEOS(int *play_state)			// call to Decoder
{
  if ((state == state_stop)||(state == state_endreceived)){
  	(*play_state) = 1;
  }
  else
  	(*play_state) = 0;
  
  return ErrorState();
}

error_flag
Stream::SetSpeed(int direction, int speed)		// call to Decoder
{
  speed = speed;
  direction = direction;
  
#ifdef DEBUGLIB
  int NPT_time;
  ReadNPT(&NPT_time);
  Debug("set speed NPT = %i", NPT_time);
#endif  
  
  switch(speed) {
    case 0:
    	change_state(state_pause);
    	break;
    case 1:
    	if (direction == 1)
    		change_state(state_fast_forward);
    	else
    		change_state(state_play);
    	break;
    case -1:
     	if (direction == 1)
    		change_state(state_fast_rewind);
    	break;
    default:
  	MakeError(VSP_Unimplemented);
  }
  return ErrorState();
}

error_flag
Stream::SetPosition(int flags, int pos_time)	 // call to Decoder
{
  error_flag result = NoError;
  int NPT_time = (int)mysource->get_most_significant_time();
  int abs_time;//, playback_id, AckNum;
  //size_t freebuf;
  
  if (flags == 1)
     abs_time = NPT_time + (pos_time * 2);
  else
  if (flags == 2)
     abs_time = NPT_time - (pos_time * 2);
  else
     abs_time = (pos_time <<1);
     
  from = abs_time;
  
  callback_pending = (callback_flag) (callback_pending | callback_trickplay);
  _kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
  if (e != NULL){
  	MakeError(e);
  	result = ErrorOccurred;
  } 

#ifdef DEBUGLIB
  Debug("set position flags (%i), time = (%i), abs (%i), NPT = (%i)", flags, pos_time, abs_time, from >> 1 );
#endif
   return result;
}

error_flag
Stream::ReadNPT(int *NPT_time)			// call to Decoder
{
  if ((state == state_fast_forward)||(state == state_fast_rewind))
    	(*NPT_time) = (int)((mysource->get_most_significant_time()*fast_playback_ratio) >> 1);
  else
  	(*NPT_time) = (int)(mysource->get_most_significant_time() >> 1); // div 2
  return NoError;
}

error_flag
Stream::GetMiscInfo(int *reg_r0, misc_5_10 *ptr, int *size)
{
  int flags = (*reg_r0);
  
  switch (flags) {
    case 0:
    	if ((ptr == NULL)||(size == 0))
    		(*size) = sizeof(misc_5_10);
    	else {
    	  	if ( (*size) < sizeof(misc_5_10) )
    	  		MakeError(VSP_InvalidValue);
    	  	else {
    	  	  	if (mysource->getMiscInfo(type_misc_5_10, ptr) == ErrorOccurred)
    	  	  		err = &(mysource->ReturnCopyOfError());
	  	}
    	}
    	break;
    case 1:
    	(*reg_r0) = trick_modes;
    	break;
    case 2:
    	if (state > state_still)
    		(*reg_r0) = state_play;
    	else
    		(*reg_r0) = state;
    	break;
#ifdef DEBUGLIB    	
    default:
    	if (ErrorExists()){
    	  	Debug("stream error exists");
		ErrorDump();
    	}
    	else
    	if (myserver->ErrorExists()){
    	  	Debug("server error");
    	}
    	else {
    	Debug("stream - cb %2.2X, t[0] (%i), t[1] = (%i)", 
    				callback_pending, (buffers[0].in_use == claim_token), (buffers[1].in_use== claim_token));
    	mysource->getMiscInfo(type_debug, NULL);
    	}
#endif    	
  }
  return ErrorState();
}

int
Stream::getBlockVal(void)
{
  int block;
  
  if ((block = mysource->getFinalBlock()) == 0)
    block = mysource->get_most_significant_block();
  
  return block;
}
  
//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++

error_flag
Stream::timeslice(Statistics *stats)
{
  error_flag result = NoError;
  
  if (state == state_stop) return result;
  
  	if (callback_pending & callback_bufferfree){
  		callback_pending = (callback_flag)(callback_pending & ~callback_bufferfree);

  		result = mysource->calculate_freeBlocks(myserver, callback_pending, stats);
  		if (result == ErrorOccurred)
  			err = &(mysource->ReturnCopyOfError());
  			
  		if (callback_pending & callback_tokenfree)
  			result = test_empty_buffers();
  			
  		if (!(callback_pending & callback_timeout)){
                       	// this reinitialises the block callback vector if we fill up the blocks
  			callback_pending = (callback_flag)(callback_pending | callback_block);
			_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), comms_timeout, VSP_CallAfterVeneer, pw);	  	
 			if (e != NULL){
  				MakeError(e);
  				result = ErrorOccurred;
 			}  
 		} 
  	}
  	else {
		if (callback_pending & callback_trickplay){
		  
        		int playback_id, RequestNum, AckNum, play_mode = 0;
        	
        		callback_pending = (callback_flag)(callback_pending & ~callback_trickplay);
        	
        		switch (state){
        			case state_fast_forward:
        	  			play_mode = 3;
        	  			break;
        	  		case state_fast_rewind:
        	  			play_mode = 4;
        	  			break;
        		}
        	
        		mysource->clearFinalBlock();	// ignore any previous end block numbs
   	 		result = mysource->setNewPlayState(&playback_id, &RequestNum, &AckNum);
   			if (result != ErrorOccurred){
   			  
   			  	if (callback_pending & callback_timeout){
   			  		callback_pending = (callback_flag)(callback_pending & ~callback_timeout);
     					_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
     				}	 

     	 			result = myserver->send_playback_request(playback_id, RequestNum, AckNum, from, play_mode);
     	 			if (result == ErrorOccurred){
     	 			  	if (myserver->ErrorNum() == TCP_NoBuffer){
     	 			  	  	myserver->RemoveErr();
     	 			  	  	result = NoError;
     	 			 	  	callback_pending = (callback_flag)(callback_pending | callback_trickplay);
     	 			 	}
     	 			 	else  	
     	 					err = &(myserver->ReturnCopyOfError());
     	 			}
     	 			else
                			callback_pending = (callback_flag)(callback_pending | callback_block);
                			
                		if (result != ErrorOccurred){
                			_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), (comms_timeout), VSP_CallAfterVeneer, pw);	  	
 					if (e != NULL){
  						MakeError(e);
  						result = ErrorOccurred;
 					}
 				}
                	}
                	else
                		err = &(mysource->ReturnCopyOfError());
                }
 		else {
 			if (mysource->foregroundExecute(&callback_pending, myserver, stats) == ErrorOccurred){
  				err = &mysource->ReturnCopyOfError();
  				result =  ErrorOccurred;
  			}
  				
  			if (callback_pending & callback_nak){
                		callback_pending = (callback_flag)(callback_pending | callback_nak);
     				_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), ((comms_timeout+1)>>1), VSP_CallAfterVeneer, pw);	  	
 				if (e != NULL){
  					MakeError(e);
  					result = ErrorOccurred;
 				} 
 			}
  		}
  	}
  	// calculate if the mpeg player has tokens if so use them as timeout values
  	// also calculate if we own all the tokens then we are starting the stream
  	// wait for more than buffer blocks

#ifdef DEBUGLIB    	  
  if (result == ErrorOccurred) {
    	Debug("stream error");
    	mysource->getMiscInfo(type_debug, NULL);
    	ErrorDump();
  }
#endif    	
  return result;
}

error_flag
Stream::server_inetevent(void)
{
  int event;
  ULINT comms_result;
  //error_flag result;
  
  if ( myserver->inetevent(&event, &comms_result) == ErrorOccurred) {
  	err = &myserver->ReturnCopyOfError();
  	return ErrorOccurred;
  }
#ifdef DEBUGLIB  
  if (comms_result != 0)
  	Debug("non-zero result form TCP event 0x%2.2X, result = %i\n", event, comms_result);

   if (event == COMMAND_playback_response)
  	Debug("+ + play response %i + +", comms_result);	
#endif  	
 
  if ((event == COMMAND_startend_notification)&&(state == state_play)){
    	// if already playing
    	mysource->setFinalBlock(comms_result);
    	change_state(state_endreceived);
  }
  return NoError;//result;
}

error_flag
Stream::DummyAckCall(void)
{
 if (state != state_stop) {
   if (myserver->comms_flag != comms)	// defined in the server class
 	if (myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock(), dummy_ack) == ErrorOccurred){
 		err = &(myserver->ReturnCopyOfError());
 		return ErrorOccurred;
 	}
 	myserver->comms_flag = no_comms;
 }
 return NoError;
}

#ifdef OUTPUT_FILE
error_flag
Stream::MPEGInterrupt(int)
{
  error_flag result = ErrorState();
  
  for (int i = 0; i < NUM_MPEG_Tokens; i++)
  	if (buffers[i].block != NULL){
  		result = MPEGBufferListToNECBlock(&buffers[i]);	
  	}
  return result;
}
#else
error_flag
Stream::MPEGInterrupt(int buffer_descriptor)
{
  int i;	// this runs under interrupt avoid changing other peoples variables
  error_flag result = ErrorState();
  
  i = 0;
  while (i < NUM_MPEG_Tokens) {	// remember if num_blocks is zero we cannot touch it.
    	if ((buffers[i].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[i].block->buffers)&&
      	    (buffer_descriptor <  (((int)buffers[i].block->buffers) + (buffers[i].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
      	  	buffers[i].blocks_returned++;
      	  	break; 	//claim
        }
        i++;
  }//while search buffers
 
  if ((i < NUM_MPEG_Tokens)&&(buffers[i].blocks_returned == buffers[i].block->num_buffers)){	// if we have received all the blocks free it
  	result = MPEGBufferListToNECBlock(&buffers[i]);		// this marks it as free	
  	
	if ((!(callback_pending & callback_bufferfree))||(state == state_stop)){
  		callback_pending = (callback_flag)(callback_pending | callback_bufferfree);	  	
    		_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
 	}
 	
 	if (state != state_stop){
 		if (callback_pending & callback_fullblocks)
  			callback_pending = (callback_flag)(callback_pending & ~callback_fullblocks);
  			
  		callback_pending = (callback_flag)(callback_pending | callback_tokenfree);
  	}// !stop
 }

  return result;
}
#endif

error_flag
Stream::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  if (mysource->serviceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    	err = &(mysource->ReturnCopyOfError());
    	return ErrorOccurred;
    }
  return NoError;
}

//+++++++++++++++++++++++++++++++ StreamList Methods ++++++++++++++++
StreamList::StreamList(void):List()
{
}

error_flag
StreamList::Add(Stream *str, int *id)
{
  int identifier;
  error_flag result = ErrorState();
  
  if (result != ErrorOccurred) {
  
  	identifier = str->GetSinkHandle();
  
  	while (EnsureUnique(identifier) == ErrorOccurred){
  	  RemoveErr();
  	  identifier++;
  	}
  	
	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &(str->start_time));
	str->data_at_start = stats.bytes_received;
	
  
  	result = List::Add((void*)str, &identifier);
  	
  	(*id) = identifier;
  }	// if we cannot recover from this error

  return result;
}

error_flag
StreamList::identify(Stream **item, int identifier)
{
  return List::identify((void**)item, identifier);
}

StreamList::~StreamList(void)
{
  int i;
  
  ExpectedSize = 0;
  
  for (i=(CurrentSize-1); i>=0; i--){
    	delete (Stream*)object[i];			// delete from the top to the bottom
    	object[i] = NULL;
  }
  
  delete[] object; object = NULL;
  delete[] identifiers; identifiers = NULL;
  
  CurrentSize = 0;
}

error_flag
StreamList::Remove(int identifier)	// returns a boolean success value
{
  int i = 0;	// count value
  error_flag result = ErrorState();
   
 
  if (result != ErrorOccurred) {
   	if (ExpectedSize != CurrentSize){
 		MakeError(VSP_BadDelete);
  		return ErrorOccurred;
        }
        
  	--ExpectedSize;
  	
   	while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  	if (i == CurrentSize){
  		MakeError(VSP_UnknownObj);
        	result = ErrorOccurred;
  	}

	if (result != ErrorOccurred){
	  	unsigned int mt_time;
	  	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &mt_time);
	  	
	  	if (mt_time > ((Stream*)object[i])->start_time){
	  	// stream bytes received
	  		stats.last_stream_bitrate = stats.bytes_received - ((Stream*)object[i])->data_at_start;
	  		mt_time -=  ((Stream*)object[i])->start_time;
	  		stats.last_stream_bitrate = stats.last_stream_bitrate / (mt_time/100);
	  	} // bitrate calculation

  		delete (Stream*)object[i]; 
  		object[i] = NULL;
  
  		while (i < CurrentSize -1){
    			object[i] = object[i+1];
    			identifiers[i] = identifiers[i+1];
    			i++;
  		}
  		--CurrentSize;

  		if (decreasesize() == ErrorOccurred)		// this does test for sufficient decrease in size
  			result = ErrorOccurred;
  	}
  }
  return result;
}

//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++
// the first argument is code or the out of band etc indicator.
error_flag 
StreamList::inetEvent(int, int identifier, claim_flag *claim, void *)
{
  error_flag result = ErrorState();

  int i;
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++){
  		Stream *stream = ((Stream*)object[i]);
    		if ((stream->getstate() != state_stop)&&(stream->source_sd == identifier)) {
        		
        		callback_flag callback = callback_none;
        		
      			if (stream->mysource->ReadDatagrams(stream->callback_pending, &callback, stream->myserver, &stats, stream->comms_timeout) == ErrorOccurred) {
    				err = &stream->ReturnCopyOfError();
    				result = ErrorOccurred;
      			}
      			
      			if (callback & callback_timeout){	// analyse if there is any need to change the callback vector
				stream->callback_pending = (callback_flag)(stream->callback_pending & ~callback_timeout);
     				_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, stream->pw);	 
				
				if (stream->state != state_stop){
 		        		if (callback & callback_nak){ // initiate callback sequence
		        			_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), ((stream->comms_timeout+1)>>1), VSP_CallAfterVeneer, stream->pw);	  	
 						if (e != NULL){						// reset ticker event
  							MakeError(e);
  							result = ErrorOccurred;
 						}
 		        		}
 		        	
					if (callback & callback_block) {	// block timeout (timeout = block | nak)
						if ((stream->callback_pending & callback_bufferswait)&&
							(stream->mysource->getFullBlocks() > stream->buffer_blocks))
							stream->callback_pending = (callback_flag)((stream->callback_pending & ~callback_bufferswait) | callback_tokenfree);
						
						if (result != ErrorOccurred){
 		        				_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), stream->comms_timeout, VSP_CallAfterVeneer, stream->pw);	  	
 							if (e != NULL){						// reset ticker event
  								MakeError(e);
  								result = ErrorOccurred;
 							}
 						}
 						if (stream->callback_pending & callback_tokenfree)
							result = stream->test_empty_buffers();
					}
 		        	}
 		        	stream->callback_pending = (callback_flag)(stream->callback_pending | callback);
      			}
      			
				
    	 		*claim = claim_event;
                } 
    		else 
    		if ((stream->server_sd) == identifier) {
     			if (stream->server_flag == free_token){
      				stream->server_flag = claim_token; 		// in use
      				if ( stream->server_inetevent() == ErrorOccurred){
    					err = &stream->ReturnCopyOfError();
    					result = ErrorOccurred;
      				}
	       			stream->server_flag = free_token; 	// not in use
        		}
        		*claim = claim_event; // claim even if in use
    		}
        }

  }
  return result;
}

error_flag
StreamList::TimeSliceCall(void *)
{
  error_flag result = ErrorState();
  int i;
  
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++){
    		Stream *stream = ((Stream*)object[i]);
    		if(stream->callback_pending){
    			if (stream->source_flag == free_token ){
      				stream->source_flag = claim_token; 		// in use
       				if (stream->timeslice(&stats) == ErrorOccurred){
    					err = &stream->ReturnCopyOfError();
    					result = ErrorOccurred;
      				}
      				
      				if ( stream->state == state_stop) {
      		  			if ( stream->change_state(state_stop) == ErrorOccurred )
      		  	  			stream->RemoveErr();
      		  			else{
      		  				Remove(identifiers[i]);	// removeit from the list
      		  			}
      				}     		  	
      				stream->source_flag = free_token; 		// not in use
	       			
			}
			else {
	  			if (stream->state != state_stop){
#ifdef DEBUGLIB	  	  
      					Debug("timeslice making callback");
#endif      			
      					_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, stream->pw);	  	
 						if (e != NULL){
  							MakeError(e);
  							result = ErrorOccurred;
 	        		                }
 	                        }
	                }
                }// callback_pending 		
        }
  }
  return result;
}

error_flag
StreamList::MPEGInterrupt(int buffer_descriptor)
{
  int i;
  error_flag result = ErrorState();
  
  if (result !=ErrorOccurred){
  	for (i=0;((i<CurrentSize)&&(result != ErrorOccurred));i++) {
  	  
  	  	Stream *stream = (Stream*)object[i];
  	  	
    		if ( stream->MPEGInterrupt(buffer_descriptor) == ErrorOccurred ) {
    			err = &(stream->ReturnCopyOfError());
    			result = ErrorOccurred;
    		}
  	}
  }
  return result;
}

error_flag
StreamList::DummyAckPoll(void)
{
  int i;
  error_flag result = ErrorState();

  if (result != ErrorOccurred){
  	for (i=0;((i<CurrentSize)&&(result != ErrorOccurred));i++)
    		if ( ((Stream*)object[i])->DummyAckCall() ) {
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			result = ErrorOccurred;
    		}
  }
  return result;
}

error_flag
StreamList::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  int i;
  error_flag result = ErrorState();
  
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++)
  		if ( ((Stream*)object[i])->ServiceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			result = ErrorOccurred;
                }
  }
  return result;
}
