/**************************************
 Stream.c

impliments standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Stream.h"	// Source Element
#include "swis.h"
#include "string.h"
#include "rtsp_defs.h"

StreamToken::StreamToken()
{
	block = NULL;
	in_use = free_token;
	allocating = free_token;
	blocks_returned = 0;
}

StreamToken::~StreamToken(void)
{
 	block = NULL;		// this is assigned to point to source memory space
	blocks_returned = 0;
}

// 4/11/1999 AR this must be used with a variable number of tokens
inline bool
Stream::tokenfree(void)
{
  for (int i = 0; i < num_tokens_to_pass; ++i)
  	if ((buffers[i].in_use == free_token)&&(buffers[i].allocating == free_token))
  		break;

  return ((i < num_tokens_to_pass)?true:false);
}

inline error_flag
Stream::test_empty_buffers(void)
{
  error_flag result = ErrorState();
  int token_id = -1;

  if ((state != state_step)||((--state_value) >= 0))
  {
   	if ( (result != ErrorOccurred)&&(state != state_stop)&&(mysink.validHandle()) ) {

		_kernel_irqs_off();
  		for (int i = 0; i < num_tokens_to_pass; ++i){
 		  	if ((buffers[i].in_use == free_token)&&(buffers[i].allocating == free_token)){
 		  	  	token_id = i;
 		  	  	break;
 		  	}
 		}
  		if (token_id == -1)
  			_kernel_irqs_on();
  		else {
  		  							// denote 'allocating' not 'in_use' as we have not set
  			buffers[token_id].allocating = claim_token;	// up the datastructures.
  			_kernel_irqs_on();

			int scene_num = 0;
			int play_id = 0;
	    		result = mysource->getBlock(&(buffers[token_id].block),
	    		                            &(buffers[token_id].mpeg_buffer),
	    		                            ((int)VSP_MPEGCall), ((int)pw),
	    		                            &scene_num, &play_id);

	 		if (result != ErrorOccurred){
	 			if(buffers[token_id].block != NULL){
					buffers[token_id].blocks_returned = 0;
					if (play_id != currentMPEG_playid)
					{
					    if (0 != currentMPEG_playid)
					    {
					        reset_sink(mysource->get_most_significant_mode());
					        currentMPEG_scene = scene_num;
					    }
					    currentMPEG_playid = play_id;
					}
					else
					// currentMPEG_playid = play_id;
					if (!(stream_flags & flags_sceneblanking)&&(scene_num != 0)){
						if (currentMPEG_scene != scene_num){
						  	if (currentMPEG_scene != 0)
								reset_sink(mysource->get_most_significant_mode());
							currentMPEG_scene = scene_num;
						}
					}

					buffers[token_id].in_use = claim_token;
					buffers[token_id].allocating = free_token;

					if ((result = mysink.FullBuffer(buffers[token_id].mpeg_buffer)) == ErrorOccurred){
					  	if (err_ptr == NULL) err_ptr = &(mysink.ReturnCopyOfError());
						buffers[token_id].allocating = free_token;
						buffers[token_id].in_use = free_token;
					}
				} else {
					buffers[token_id].allocating = free_token;
                                }

		        }
		 	else {
		                buffers[token_id].allocating = free_token;
		 	  	if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
		 	} // !get block error occurred
		}
	}
  }
  else
  if (result != ErrorOccurred)
  {
      result = change_state(state_pause);
  }

   return result;
}

inline void
Stream::reset_sink(play_mode mode)
{
    int mpeg_flags = 0x01; /* video present */

    if (mode == mode_normalplay)
    {
        mpeg_flags |= 0x02; /* audio present */
    }

    if ((mode == mode_fastforward) || (mode == mode_fastrewind))
    {
       //mpeg_flags |= 0x08; /* iframes only */
    }
#ifdef DEBUGLIB
    Debug("reset_sink flags(%i)\n", mpeg_flags);
#endif

    if ((ErrorOccurred == mysink.ResetStream(mpeg_flags)) && (NULL == err_ptr))
    {
            err_ptr = &mysink.ReturnCopyOfError();
    }

    // if we need to
    if (state == state_slow) mysink.SetSpeed(state_value);
}


Stream::Stream(int inet_timeout, InternetObject *server, int MPEGid, int source_recvspace, int NumBlocks,
                                  int BufferBlocks, int TCP_TimeOut, void *pwork, int VC_id) :mysink(MPEGid)
{
    // MULTICAST CONSTRUCTOR

    // STB specific variables
    source = source_multicast;

    // 08/11/1999 variable tokens to pass must be set.
    num_tokens_to_pass = 4;	// define use of all of the tokens (stream -> MPEG buffers)
    RTSP_client_identity = VC_id;
    RTSP_proto_identity = (ULINT)this;
    RTSP_StatusChanged = false;
    RTSP_RequestInProgress = false;
    RTSP_code = 200;
    amount_read = 0;			// used for multiple reads of more info
    moreInfo = NULL;				// used in the more info call
    pw = pwork;
    comms_timeout = inet_timeout;
    from = to = start = end = 0;
    looping = false;
    callback_pending = callback_bufferswait;	// buffer management is in a state of waiting for buffer blocks
#ifdef DEBUGLIB
    if (Debug(debug_callbacks)) Debug("=callback_bufferswait mccon");
#endif
    state = state_play;				// set the state of play
    buffer_blocks = BufferBlocks;
    currentMPEG_playid = currentMPEG_scene = 0;
    stream_flags = flags_standard_op;
    inet_udp_reenter = inet_tcp_reenter = 0;

    if (0 != RTSP_client_identity)
    {
        stream_flags = (flags_word) (stream_flags | flags_informvideoctrl);
    }

    if (mysink.ErrorExists())
    {
        if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
    }
    else
    {
        myserver = server;
        mysource = new SourceMultiCast(server, source_recvspace, NumBlocks, TCP_TimeOut);		// create UDP socket
        if  ( mysource->ErrorExists() ) // errors on creation of UDP
        {
            if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
        }
    }

    if ((!ErrorExists()) && (mysource->getSocketDescriptor(&source_sd) == ErrorOccurred)  )
    {
        if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
    }
    server_sd = -1;

    if (mysink.SetSpeed(0) == ErrorOccurred) // start in slow motion.
    {
        if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
    }

    trick_modes_available = trick_normal_play | trick_pause;

    /* set the more info block. */
    if (stream_flags & flags_informvideoctrl)
    {
        SourceMultiCast*  multi_source = (SourceMultiCast*)mysource; /* used to squeeze stats */
#ifdef DEBUGLIB
        if (Debug(debug_servercontrol))
            Debug("more info datablock = (%8.8X)\n", moreInfo);
#endif
        int header_length = 0;
        int body_length = 0;
        unsigned int systime;

        const RTSP_status *status_block = RTSP_get_status(NEC_OK);
        char* trick_play_description = RTSP_get_alloc_tricks_array(trick_modes_available);

        if (NULL == trick_play_description)
        {
            MakeError(VSP_Alloc);
        }
        else
        {
            int server_IP = (int)(server->address.s_addr);

            _swix(OS_ReadMonotonicTime, _OUT(0), &systime);

            char num_strings[8][16]; /* for printing numeric values */

            sprintf(num_strings[2], "0");// session number
            sprintf(num_strings[3], "%u",  systime);// version number
            sprintf(num_strings[4], "%u.%u.%u.%u", ((server_IP>>24)& 0xff),((server_IP>>16)& 0xff),
                    ((server_IP>>8)& 0xff),(server_IP& 0xff));// ipaddress

            sprintf(num_strings[5], "live");                                   // range
            sprintf(num_strings[6], "1");                                      // fast playback ratio
            sprintf(num_strings[7], "%.3f", ((double)multi_source->getBitrate())); // bitrate

            body_length = strlen(RTSP_describe_body) +
                          strlen(num_strings[2]) +
                          strlen(num_strings[3]) +
                          strlen(num_strings[4]) +
                          strlen(num_strings[5]) +
                          strlen(num_strings[6]) +
                          strlen(trick_play_description) +
                          strlen(num_strings[7]) +
                          RTSP_content_type_length +
                          RTSP_content_disk_status +
                          RTSP_content_video_type;

            sprintf(num_strings[0], "0"); //CSeq
            sprintf(num_strings[1], "%u",  body_length);                 /* calculate the length of the body */

            header_length = strlen(RTSP_describe_header) +
                            strlen(status_block->number) +
                            strlen(status_block->message) +
                            strlen(num_strings[0] +
                            strlen(num_strings[1]));

            if ((moreInfo) != NULL)
            {
                amount_read = 0;
                my_free (moreInfo);
                (moreInfo) = NULL;
            }

            (moreInfo) = (char*)my_malloc(header_length + body_length + 1);

            if (moreInfo)
            {
                const char* content_type = RTSP_get_encoding_type(multi_source->getEncoding());

                // add the header to the response block
                sprintf(moreInfo, RTSP_describe_header,
                        status_block->number,
                        status_block->message,
                        num_strings[0],
                        num_strings[1]);

                // add the body to the block
                sprintf(moreInfo + strlen(moreInfo), RTSP_describe_body,
                        num_strings[2],
                        num_strings[3],
                        num_strings[4],
                        num_strings[5],
                        content_type,
                        RTSP_get_disk_status(1/*!= 0*/),
                        num_strings[6],
                        trick_play_description,
                        RTSP_get_video_type(multi_source->getVideoType()),
                        num_strings[7]);
#ifdef DEBUGLIB
                if (Debug(debug_servercontrol))
                {
                    Debug("more info size = (%i)\n%s\n", strlen(moreInfo), (moreInfo));
                    Debug("**** inform video control new status\n");
                }
#endif

                RTSP_code = status_block->status_value;
                RTSP_StatusChanged = true;
                MakeErrorOnError(VideoControlInformNewStatus(RTSP_proto_identity));

                amount_read = strlen(moreInfo);
            }
            else
            {
                MakeError(VSP_Alloc);
            }
            my_free(trick_play_description);
        }
    }
}

// stream constructor VOD
Stream::Stream(int inet_timeout, int initial_block, int MPEGid, PlayList playlist, int play_num, Server *server, int NumBlocks,
	int source_recvspace, int BufferBlocks, void *pwork, flags_word flags, int in_from, int VC_id):mysink(MPEGid)
{
  // server specific variables
  in_addr ipAddress;		// structure defined in internet library
  ULINT portnum;		// of server object, receiving

  amount_read = 0;			// used for multiple reads of more info
  moreInfo = NULL;				// used in the more info call
  RTSP_client_identity = VC_id;
  RTSP_proto_identity = (ULINT)this;
  RTSP_StatusChanged = false;
  RTSP_RequestInProgress = true;
  RTSP_code = 200;
  num_tokens_to_pass = 4;	// 08/11/1999 AR define use of all of the tokens (stream -> MPEG buffers)

  // STB specific variables
  pw = pwork;
  source = source_vod;
  comms_timeout = inet_timeout;
  callback_pending = callback_bufferswait;	// buffer management is in a state of waiting for buffer blocks
#ifdef DEBUGLIB
  if (Debug(debug_callbacks)) Debug("=callback_bufferswait con");
#endif
  state = state_prestart;			// set the state of play
  buffer_blocks = BufferBlocks;
  currentMPEG_playid = currentMPEG_scene = 0;
  stream_flags = flags;
  inet_udp_reenter = inet_tcp_reenter = 0;
  from = start = in_from;
  looping = false;
  srcNumBlocks = NumBlocks;
  srcInitBlock = initial_block;

  if (0 != RTSP_client_identity)
  {
      stream_flags = (flags_word) (stream_flags | flags_informvideoctrl);
  }

  if ((!ErrorExists())&&(mysink.ErrorExists())) {
    	if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
  }
  else{
    	myserver = server;

    	server->set_stream_owner();
     	server->reset_message_sent();
  	mysource = new Source((comms_timeout+1)>>1, source_recvspace);			// create UDP socket
  	//mysource = new Source(comms_timeout, source_recvspace);			// create UDP socket

 	if (server->ErrorExists()){ 				// errors on creation of TCP
 		if (err_ptr == NULL) err_ptr = &server->ReturnCopyOfError();
  	}
  	else
  	if  (mysource->ErrorExists()&&(mysource->ErrorNum() != VSP_SourceUninit)){ // errors on creation of UDP
		if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  	}
  }

  if ((!ErrorExists()) &&		// on no error
  	   	( (mysource->getLocalPort((int*)&portnum)== ErrorOccurred)  ||	// get UDP port number for asset presentation
  	   	  (mysource->getSocketDescriptor(&source_sd) == ErrorOccurred)    ) ){
  	if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  }

  if ((!ErrorExists()) && (server->getLocalAddress((in_addr*)&ipAddress) == ErrorOccurred) ){
    	if (err_ptr == NULL) err_ptr = &(server->ReturnCopyOfError());
  }

  if ((!ErrorExists()) && ((server_sd = server->getSocketDescriptor()) == -1)) MakeError(IP_SocketError);

  if ((!ErrorExists()) && (server->send_assetpresentation_request(initial_block, playlist, play_num, ipAddress, portnum) == ErrorOccurred))
  {
	if (err_ptr == NULL) err_ptr = &server->ReturnCopyOfError();
  }
}

error_flag
Stream::PostPresentationSetup()
{
    in_addr ipAddress;  // structure defined in internet library
    int portnum = 0;
    ULINT bitrate = 0;
    ULINT dgram_size = 0;
    ULINT fast_playback = 0;
    int BlockSize = 0, num_dgrams = 0;
    trick_modes_available = implemented_trick_modes;

    if (stream_flags & flags_informvideoctrl)
    {
        if ((!ErrorExists()) && (((Server*)myserver)->get_assetpresentation_response(&ipAddress, (ULINT*)&portnum,
                          &end, &dgram_size, &bitrate, &fast_playback_ratio, &trick_modes_available, &moreInfo, &RTSP_code) == ErrorOccurred))
        {
           if (err_ptr == NULL) err_ptr = &myserver->ReturnCopyOfError();
        }
    }
    else
    {
        if ((!ErrorExists()) && (((Server*)myserver)->get_assetpresentation_response(&ipAddress, (ULINT*)&portnum,
                                                 &end, &dgram_size, &bitrate, &fast_playback, &trick_modes_available) == ErrorOccurred))
        {
           if (err_ptr == NULL) err_ptr = &myserver->ReturnCopyOfError();
        }
    }

  // set the server to listen to the port returned from the presentation
  ipAddress.s_addr = ntohl(ipAddress.s_addr);		// ipaddress of server as port are set in the asset presentation

  if ( (!ErrorExists()) && (mysource->setServerDetails(&ipAddress, (int)portnum) == ErrorOccurred))
  {
	if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  }
  to = end;

  // start and end are set in the play element, we set them here so as to get notifications
  if (from >= to)	// this in most cases is zero
  	MakeError(VSP_InvalidValue);

  // calculate the size of the source buffering
  // bytes per 2/3 sec's this ensures enough dgrams
  num_dgrams = (int) ( ((double)(((bitrate/8)*2)/3) / (dgram_size-sizeof(NECDatagram))) +0.5 ) + 1;  // rounded up + 1
  BlockSize = num_dgrams * (int)dgram_size;	// calculation on datagram size and bitrate

  // allocate the buffer space in the source object
  if ((!ErrorExists())&&(mysource->Allocate(srcNumBlocks, BlockSize, srcInitBlock, (size_t)dgram_size) == ErrorOccurred)){
  	if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  }

  // send pre-play ack
  if ((!ErrorExists()) && (myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock()) == ErrorOccurred)){
  	if (err_ptr == NULL) err_ptr = &myserver->ReturnCopyOfError();
  }

  if ((!ErrorExists()) && !(stream_flags & flags_noplayonopen))
  {
#ifdef DEBUGLIB
	if (Debug(debug_callbacks)) Debug("+callback_trickplay con");
#endif
        change_state(state_play);	// this will make an imediate callback for trickplay.
        myserver->send_message_StartNotification(srcInitBlock);
  }
#ifdef DEBUGLIB
  if ((!ErrorExists())&&(Debug(debug_streaminfo))) {
    	Debug("stream bitrate = %i, datagram size %i, datagrams/block %i, fast play ratio %i",
    				bitrate, dgram_size, num_dgrams, fast_playback_ratio);
    	if (trick_modes_available & trick_jump_most_rec)
		Debug("Being Registered tricks %8.8X, initial block %i", trick_modes_available, srcInitBlock);
	else
		Debug("Registered Video %i to %i (secs), tricks %8.8X", from/2, end/2, trick_modes_available);

  }
#endif
  return ErrorState();
} 	// stream constructor

Stream::~Stream(void)
{
  if ((change_state(state_stop) != ErrorOccurred)||(ErrorNum() != VSP_CantDeleteSharedMemory)){
    	// this is because errors can occur including errors returned from the server not always shared memory
    	delete mysource; mysource = NULL;
  }
  else {
    	int count = 0;
   	do {
   	  	++count;
    		RemoveErr();
  		reset_sink(mysource->get_most_significant_mode());
 		if (count > 10) {
 			mysink.CloseStream();
 			break;
 		}
    	}
    	while (change_state(state_stop) == ErrorOccurred);
    	delete mysource; mysource = NULL;
  }

  if (moreInfo)
  {
    	my_free(moreInfo);
    	moreInfo = NULL;
    	amount_read = 0;
  }

  myserver->send_message_StreamClosing(err_ptr);

  if (myserver->interface_uses()){
    	myserver->clear_streamrunning();
  	myserver->clear_stream_owner();
  	if (myserver->ErrorExists())
  	  	myserver->RemoveErr();
  }
  else  {
  	delete myserver;
  	myserver = NULL;
  }
}

inline error_flag
Stream::swap_source(void)
{
    if (source == source_streamlive)
    {
        Source *tmp = mysource;
        Source *tmp2 = new Source((*tmp));
        _kernel_irqs_off();
        source = source_vod;
        num_tokens_to_pass = 2;
        mysource = tmp2;
        _kernel_irqs_on();
        delete tmp; tmp = NULL;
        if (mysource->ErrorExists())
        {
            if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
        }
        // 08/11/1999 AR this allows larger buffers to be passed with accuracy.
#ifdef DEBUGLIB
        Debug("LIVE -> Stored");
#endif
        }
        else
        {
            if (source == source_vod)
            {
                Source *tmp = mysource;
                Source *tmp2 = new Source((*tmp));
                _kernel_irqs_off();
                source = source_streamlive;
                num_tokens_to_pass = 4;
                mysource = tmp2;
                _kernel_irqs_on();
                delete tmp; tmp = NULL;
                if (mysource->ErrorExists())
                {
                    if (err_ptr == NULL) err_ptr = &ReturnCopyOfError();
                }
#ifdef DEBUGLIB
                Debug("Stored -> LIVE");
#endif
            }
        }

        return (ErrorExists() ? ErrorOccurred : NoError);
}
//
// this is the central change of state method for the stream class
// the stream state should not change state unless going through here
// the 'trick_mode' are checked to ensure that a particular state is
// available to a particular stream.  It is debatable as to whether
// an error should be created otherwise.
//
// it is expected that most error handling is done externally
// with the exeption of stopping the stream

inline ULINT
Stream::trick_modes(void)
{
  return ((source == source_streamlive) ? (trick_normal_play | trick_backward_jump) : (trick_modes_available));
}

error_flag
Stream::change_state(state_of_play new_state)
{
    state_of_play old_state = state;
    // if from time has not already been set, ie jump
    if (!(callback_pending & callback_trickplay))
        from = getNECTime();

    typedef struct {
      state_of_play state;
      void* next;
    } re_entrancy_struct;

    static bool re_entered = false;
    static re_entrancy_struct* requests = NULL;

    if (re_entered == true)
    {
       re_entrancy_struct* tmp = new re_entrancy_struct;
#ifdef DEBUGLIB
       if (Debug(debug_streaminfo)) Debug("change state re-entered\n");
#endif
       tmp->state = new_state;
       tmp->next = requests;
       requests = tmp;
    }
    else
    {
       re_entered = true;
    }

#ifdef DEBUGLIB
   	if (Debug(debug_streaminfo)) Debug("state %i -> %i, from = %i to %i", state, new_state, from, to);
#endif
        /*_kernel_irqs_off();*/
        switch (new_state) {
            case state_slow:
                if (trick_modes() & trick_slow_play)
                {
                    state = state_slow;
                    if (stream_flags & flags_setspeeds)
                    {
                        mysink.SetSpeed(state_value);
                    }
                }
                break;
            case state_step:
                if (trick_modes() & trick_step_play)
                {
                    state = state_step;
                    if ((!(callback_pending & callback_bufferswait))&&(mysink.SetSpeed(1) == ErrorOccurred))// play
                    {
                        if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
                    }
                }
                break;
            case state_endreceived:
                if (state != state_stop)
                {
#ifdef DEBUGLIB
                    if (Debug(debug_streaminfo))
                        Debug("end received");
#endif
                    state = state_endreceived;
                }
                break;
            case state_stop:
                {
                    bool used_buffer = false;

                    if (ErrorExists()) RemoveErr(); // just try to stop
                    if (state != state_stop)
                    {
                        if ((myserver->streamrunning())&&
                            (myserver->AssetEnd(0, (state != state_endreceived)) == ErrorOccurred))
                        {
                            if (err_ptr == NULL) err_ptr = &(myserver->ReturnCopyOfError());
                        }
                        mysource->setEndPlayState(); // this ensures no more data is copied upriver.

                        state = state_stop;
                    }

                    for (int i=0; i < MAX_NUM_MPEG_Tokens; i++)
                    {
                        if (buffers[i].in_use != free_token)
                            used_buffer = true;
                    }
#ifdef DEBUGLIB
#if (MAX_NUM_MPEG_Tokens != 4)
#error debug is looking for 4 tokens
#endif
                     if (Debug(debug_streaminfo))
                              Debug("close stream; flags %3.3X, tokens (%i)(%i)(%i)(%i)", callback_pending,
                              (buffers[0].in_use == claim_token),(buffers[1].in_use == claim_token),
                              (buffers[2].in_use == claim_token),(buffers[3].in_use == claim_token));
#endif
                     if (used_buffer == true)
                         MakeError(VSP_CantDeleteSharedMemory);
                    }
                    break;
               case state_pause:
                    if (trick_modes() & trick_pause)
                    {
                        state = state_pause;
                        if (mysink.SetSpeed(0) == ErrorOccurred)// pause
                        {
                            if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
                        }
                    }
                    break;
               case state_play:
                    if (trick_modes() & trick_normal_play)
                    {
                        if (source == source_streamlive)
                        {
                            swap_source();
                        }
#ifdef DEBUGLIB
                        if (Debug(debug_RTSP)) Debug("change state to play msig mode (%i)", mysource->get_most_significant_mode());
#endif
                        // do we need to change server file
                        if ((mysource->get_most_significant_mode() != mode_normalplay)||(state == state_prestart))
                        {
                            if (state == state_prestart)
                            {
                            }
                            callback_pending += callback_trickplay;
                        }
#ifdef DEBUGLIB
                        if (Debug(debug_callbacks)) Debug("+callback_trickplay cs");
#endif
                        if (stream_flags & flags_setspeeds)
                            mysink.SetSpeed(1);

                        state = state_play;
                    }
                    break;
               case state_streamlive:
                    if (trick_modes() & trick_jump_most_rec)
                    {
                        if (mysource->get_most_significant_mode() != mode_streamlive)// do we need to change server file
                        {
                            callback_pending += callback_trickplay;
#ifdef DEBUGLIB
                            if (Debug(debug_callbacks)) Debug("+callback_trickplay cs");
#endif
                            swap_source();
                            from = 0xFFFFFFFF;
                            if (stream_flags & flags_setspeeds)
                                mysink.SetSpeed(1);
                            state = state_streamlive;
                        }
                    }
                    break;
               case state_fast_forward:
                    if (trick_modes() & trick_fast_forward)
                    {
                        if (mysource->get_most_significant_mode() != mode_fastforward) // do we need to change server file
                            callback_pending += callback_trickplay;
#ifdef DEBUGLIB
                        if (Debug(debug_callbacks)) Debug("+callback_trickplay cs");
#endif
                        if (stream_flags & flags_setspeeds)
                            mysink.SetSpeed(1);
                         state =  state_fast_forward;
                    }
                    break;
               case state_fast_rewind:
                    if (trick_modes() & trick_fast_rewind)
                    {
                        if (mysource->get_most_significant_mode() != mode_fastrewind) // do we need to change server file
                            callback_pending += callback_trickplay;
#ifdef DEBUGLIB
                        if (Debug(debug_callbacks)) Debug("+callback_trickplay cs");
#endif
                        if (stream_flags & flags_setspeeds)
                            mysink.SetSpeed(1);
                        state =  state_fast_rewind;
                    }
                    break;
        } /* switch */
        /*_kernel_irqs_on();*/

        if (old_state == state_step)
            test_empty_buffers();

    // the trick flag is set if this trick requires dialogue with the server ie change file or jump.
    if ((!ErrorExists())&&(callback_pending & callback_trickplay))
    {
#ifdef DEBUGLIB
        ULINT current_min, future_min;

        current_min = (int)((getNECTime() >> 1) / 60);
        future_min = (int)((from >> 1)/ 60);
        if (Debug(debug_time))
            Debug("trick play (%i) (%2i:%2i:%2i) -> (%2i:%2i:%2i) %i -> %i", state,
                 (int)(current_min/60), (int)(current_min % 60), (int)((getNECTime()>>1) % 60),
                 (int)(future_min/60), (int)(future_min % 60), (int)((from >> 1) % 60),
                 getNECTime(), from);
#endif
        MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));

        if (!(stream_flags & flags_nochangepause) && (mysink.SetSpeed(0) == ErrorOccurred))// pause
        {
            if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
        }
    }

    re_entered = false;

    if ((!ErrorExists()) && (requests != NULL))
    {
        re_entrancy_struct* tmp = requests;
        state_of_play state = tmp->state;

        requests = (re_entrancy_struct*)requests->next;
        tmp->next = NULL;

        delete tmp;

        change_state(state);
    }

    return (ErrorExists() ? ErrorOccurred : NoError);
}

error_flag
Stream::GetSinkHandle(void)
{
  if (mysink.GetHandle() == ErrorOccurred){
    	if (err_ptr == NULL) err_ptr = &(mysink.ReturnCopyOfError());
  }

  return (ErrorExists() ? ErrorOccurred : NoError);
}

error_flag
Stream::CheckEOS(int *play_state)			// call to Decoder
{
  if ((ErrorState() == ErrorOccurred)||(state == state_stop)||(state == state_endreceived)){
#ifdef DEBUGLIB
	if (Debug(debug_streaminfo))
		Debug("eos %i || %i || %i", (ErrorState() == ErrorOccurred),(state == state_stop),(state == state_endreceived));
#endif
  	(*play_state) = 1;
  }
  else
  	(*play_state) = 0;

  return NoError;
}

error_flag
Stream::SetSpeed(int direction, int speed)		// call to Decoder
{
    if (stream_flags &  flags_informvideoctrl)
    {
        if (!err_ptr) MakeError(VSP_InvalidUsage);
    }
    else
    if (ErrorState() != ErrorOccurred)
    {
        if ((direction == 2)&&(trick_modes() & trick_step_play))
        {
     	state_value = speed;		// this is the number of blocks to play
     	change_state(state_step);
        }
        else
        {
            switch(speed)
            {
                case 0:
                	if (speed == 0)
                		change_state(state_pause);
                	else
                	MakeError(VSP_Unimplemented);
                	break;
                case 1:
                	if (direction == 1)
                		change_state(state_fast_forward);
                	else
                		change_state(state_play);
                	break;
                case -1:
                 	if (direction == 1)
                		change_state(state_fast_rewind);
                	break;
                default:
                	if (direction == 0){
                	state_value = speed;		// this is the speed of the mpeg player
                		change_state(state_slow);
                	}
                else
                	MakeError(VSP_Unimplemented);
            }
        }
    }
    return (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
Stream::SetPosition(int flags, int pos_time, bool do_statechange)	 // call to Decoder
{
  if (stream_flags &  flags_informvideoctrl)
  {
      if (!err_ptr) MakeError(VSP_InvalidUsage);
  }
  else
  if (ErrorState() != ErrorOccurred){
  	ULINT NEC_time = getNECTime();
  	ULINT abs_time;

  	if (flags == 1){
  		abs_time = NEC_time + (pos_time * 2);
  	}
  	else
  	if (flags == 2){
  		abs_time = NEC_time - (pos_time * 2);
  	}
  	else {
  		if ((pos_time < 0)&&(end == 0xFFFFFFFF))
     			abs_time = 0xFFFFFFFF;
     		else
     			abs_time = (pos_time << 1);
        }

  	if (((abs_time & 0x80000000)&&(end != 0xFFFFFFFF))||(abs_time > end))
  		MakeError(VSP_InvalidValue);
  	else {
  		from = abs_time;

  		callback_pending += callback_trickplay;
#ifdef DEBUGLIB
		if (Debug(debug_callbacks)) Debug("+callback_trickplay sp");
#endif
		if (do_statechange == true)
		{
  			if (abs_time == 0xFFFFFFFF)
  				change_state(state_streamlive);
  			else
  				if (state == state_streamlive)
  					change_state(state_play);
  				else
 					change_state(state);
		}
        }
  }
  return (ErrorExists() ? ErrorOccurred : NoError );
}

inline ULINT
Stream::getNECTime(void)
{
  play_mode mode = mysource->get_most_significant_mode();
  ULINT time = mysource->get_most_significant_time();

  if ((mode == mode_fastrewind)||(mode == mode_fastforward))
  	time *=  fast_playback_ratio;

  if (mode != mode_fastrewind)
  	time += num_tokens_to_pass>>1;
  else {
    	if (time >= num_tokens_to_pass>>1)
  		time -= num_tokens_to_pass>>1;
  }

 return time;
}

error_flag
Stream::ReadNPT(ULINT *NPT_time)
{
   if (ErrorState() != ErrorOccurred){
	if (source == source_multicast){
		if (mysink.ReadNPT(NPT_time) == ErrorOccurred)
			if (err_ptr == NULL)
				err_ptr = &(mysink.ReturnCopyOfError());
	}
	else {
#ifdef DEBUGLIB
/*	if (Debug(debug_time)) {
	    	int current_min = (int)((getNECTime() >> 1) / 60);
 		Debug("NPT (%2i:%2i:%2i) %i, (%i)",
  					   (int)(current_min/60), (int)(current_min % 60), (int)((getNECTime()>>1) % 60),
  					   getNECTime(), mysource->get_most_significant_mode());
  	}*/
#endif
		(*NPT_time) = (getNECTime() >> 1);
	}
   }
   else
   	*NPT_time = 0xFFFFFFFF;

   return (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
Stream::GetMiscInfo(ULINT *reg_r0, misc_5_10 *ptr, int *size)
{
#ifdef DEBUGLIB
	if ((*reg_r0) == 1) {
		if (Debug(debug_streaminfo)){
        		Debug("stream (%i)- cb %3.3X, tokens (%i)(%i)(%i)(%i)", mysource->getFullBlocks(), callback_pending,
        	    		(buffers[0].in_use == claim_token), (buffers[1].in_use== claim_token),
        	    		(buffers[2].in_use == claim_token), (buffers[3].in_use== claim_token));
        	}
		if(Debug(debug_bufferdump)) mysource->getMiscInfo(type_debug, NULL);
	}
#endif

   if (ErrorState() != ErrorOccurred){
  	ULINT flags = (*reg_r0);
  	switch (flags) {
    		case 0x00:
    			if ((ptr == NULL)||((*size) == 0))
    				(*size) = sizeof(misc_5_10);
    			else {
    			  	if ( (*size) < sizeof(misc_5_10) )
    			  		MakeError(VSP_InvalidValue);
    			  	else {
    			  	  	if ((mysource->getMiscInfo(type_misc_5_10, ptr) == ErrorOccurred)&&(err_ptr == NULL))
    			  	  		err_ptr = &(mysource->ReturnCopyOfError());
			  	}
    			}
    			break;
    		case 0x01:
    			(*reg_r0) = trick_modes();
   			break;
    		case 0x02:
	    		if (state > state_still)
	    			(*reg_r0) = state_play;
	    		else
	    			(*reg_r0) = state;
	    		break;
	    	case 0x03:
	    		if (mysource != NULL)
	    			mysource->getMiscInfo(type_buffers, reg_r0);
	    		break;
	 }
  }
  return (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
Stream::create_RTSP_playblock(server_response_type server_response)
{
    const RTSP_status *response = RTSP_get_status(server_response);

    RTSP_StatusChanged = true;

    if (moreInfo)
    {
        amount_read = 0;
        my_free(moreInfo);
        moreInfo = NULL;
    }

    if (moreInfo == NULL)
    {
        char num_strings[4][20];

        sprintf(num_strings[0], "%u",   (NULL != myserver) ? myserver->getCertCode() : 0);
        sprintf(num_strings[1], "%.2f", (double)from/2);
        sprintf(num_strings[2], "%.2f", (double)to/2);

        switch (state)
        {
            case state_fast_rewind:
                sprintf(num_strings[3], "-%i.00", fast_playback_ratio);
                break;
            case state_fast_forward:
                sprintf(num_strings[3], "%i.00", fast_playback_ratio);
                break;
            case state_slow:
                sprintf(num_strings[3], "1/%i", state_value);
                break;
            default:
                sprintf(num_strings[3], "1.0000");
        }
#ifdef DEBUGLIB
        if (Debug(debug_RTSP)) Debug("times (%i) - {(%i)|(%i)}", getNECTime(), from, to);
#endif
        moreInfo = (char*)my_malloc(strlen(RTSP_play_response) +
                             strlen(response->number) +
                             strlen(response->message) +
                             strlen(num_strings[0]) +
                             strlen(num_strings[1]) +
                             strlen(num_strings[2]) +
                             strlen(num_strings[3]));

        if (moreInfo)
        {
            sprintf(moreInfo, RTSP_play_response,
                    response->number,
                    response->message,
                    num_strings[0], num_strings[1], num_strings[2], num_strings[3]
                    );

            amount_read = strlen(moreInfo);

#ifdef DEBUGLIB
            if (Debug(debug_RTSP)) Debug("generate play response block:\n%s", moreInfo);
#endif
        }
        else
        {
            MakeError(VSP_Alloc);
        }
    }
    return (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
Stream::RTSP_play(bool forward, ULINT numerator, ULINT denominator, position_type *pos_from, position_type *pos_to)
{
    state_of_play n_state = state_play;
    LINT speed = 1;
    ULINT play_start = 0, finish = end;
    bool start_specified = false, end_specified = false;
    bool update_state = false;
    server_response_type server_response = NEC_OK;

    /*initial checks*/
    if ((denominator == 0) || (numerator/denominator > fast_playback_ratio * 2))
    {
        server_response = NEC_NoGOPatJump;
    }

    /* check speed first as this has more limitations */
    if (forward == false)
    {
        if (numerator >= denominator)
        {
            if (trick_modes() & trick_fast_rewind)
            {
                n_state = state_fast_rewind;
            }
            else
            {
                server_response =  RTSP_MethodNotAllowed;
            }
        }
        else
        {
            server_response = NEC_NoGOPatJump;
        }
    }
    else
    if (numerator > denominator)
    {
        if (trick_modes() & trick_fast_forward)
        {
            n_state = state_fast_forward;
        }
        else
        {
            server_response = RTSP_MethodNotAllowed;
        }
    }
    else
    if (numerator == 0)
    { /* pause */

        if (trick_modes() & trick_pause)
        {
            n_state = state_pause;
        }
        else
        {
            server_response = RTSP_MethodNotAllowed;
        }
    }
    else
    if (numerator < denominator)
    { /* slow play */
        speed = (LINT)(denominator/numerator); /* which cannot be zero */
        n_state = state_slow;

        if (!(trick_modes() & trick_slow_play) ||
            ((stream_flags & flags_limit_on_slow)&&(speed > 8)))
        {
                server_response = RTSP_MethodNotAllowed;
        }
    }
#ifdef DEBUGLIB
    if (Debug(debug_streaminfo))
        Debug("parsed speed [n_state = %i], checking position\n", n_state);
#endif
    /* check position */
    if (!ErrorExists())
    {
        if (pos_from->denom == 0)
        {
            if (pos_from->numer == TIME_live)
            {
                if (trick_modes() & trick_jump_most_rec)
                {
                    n_state = state_streamlive;
                    play_start = 0xFFFFFFFF;
                    start_specified = true;
                }
                else
                {
                    server_response = NEC_NoGOPatJump;
                }
            }
            else
            if (pos_from->numer == TIME_end)
            {
                play_start = end;
                update_state = true;
                start_specified = true;
            }
            else
            {
                if (pos_from->numer == TIME_now)
                {
                    start_specified = true;
                }
                play_start = getNECTime();
            }
        }
        else
        {
            play_start = (pos_from->numer *2)/pos_from->denom; /* != 0 */
            update_state = true;
            start_specified = true;
        }

        if (!ErrorExists())
        {
            if (pos_to->denom == 0)
            {
                if (pos_to->numer == TIME_live)
                {
                    if (trick_modes() & trick_jump_most_rec)
                    {
                        finish = end;
                        end_specified = true;
                    }
                    else
                    {
                        server_response = NEC_NoGOPatJump;
                    }
                }
                else
                if (pos_to->numer == TIME_end)
                {
                    if (n_state == state_fast_rewind)
                    {
                        finish = 0;
                        end_specified = true;
                    }
                    else
                    {
                        finish = end;
                        if (!(trick_modes() & trick_jump_most_rec))
                        {
                            end_specified = true;
                        }
                    }
                }
                else
                {
                    if (n_state == state_fast_rewind)
                    {
                       finish = 0;
                    }
                    else
                    {
                       finish = end;
                    }
                    end_specified = true;
                }
            }
            else
            {
                finish = (pos_to->numer *2)/pos_to->denom; /* != 0 */
                end_specified = true;
            }
        }
    }
#ifdef DEBUGLIB
    if (Debug(debug_RTSP)) Debug("calculating server response (%i) play_start (%i) finish (%i) end (%i) state (%i)\n",
                                                                     server_response, play_start, finish, end, n_state);
#endif
    if (!ErrorExists())
    {
        if ( (finish == play_start) ||
             ((n_state == state_fast_rewind) && (finish > play_start)) ||
             ((n_state != state_fast_rewind) && (finish < play_start)) ||
             ((0xFFFFFFFF != end)&&(finish > end)) )
        {
            server_response = NEC_NoGOPatJump;
        }
        else
        {
            if (NEC_OK == server_response)
            {
                from = play_start;

                if (true == start_specified)
                {
                    start = play_start;
                }

                if (true == end_specified)
                {
                    to = finish;
                }

                state_value = speed;
                
                if ((true == update_state)||(state_prestart == state))
                {
                    callback_pending += callback_trickplay;
                    update_state = true;
                }

                /* thus avoiding play requests on current blocks */
                if ((true == update_state) || ((n_state != state) || (speed != 1)))
                {
                    update_state = true;
                    change_state(n_state);
                }
            }
        }

        if (stream_flags & flags_informvideoctrl)
        {
             if (!(callback_pending & callback_trickplay) ||
                  ( NEC_OK != server_response)
                )
             {
                create_RTSP_playblock(server_response);
#ifdef DEBUGLIB
                if (Debug(debug_RTSP))
                  Debug("**** inform new status from play request, no call\n");
#endif
                MakeErrorOnError(VideoControlInformNewStatus(RTSP_proto_identity));
             }
             else
             {
                    RTSP_RequestInProgress = true;
             }
        }
        /* else caught in play response */
    }

    return (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
Stream::RTSP_getStatus(ULINT *reg_r0, ULINT *reg_r2)
{
    (*reg_r0) = (((NULL != myserver) ? 0x01 : 0x00) |
                 ((true == RTSP_StatusChanged) ? 0x02 : 0x00) |
                 ((NULL != moreInfo) ? 0x04 : 0x00) );

#ifdef DEBUGLIB
    if (Debug(debug_RTSP))
    {
        Debug("getStatus word = (%2.2X), response = (%i) error = (%i)\n", (*reg_r0), RTSP_code, ErrorExists());
    }
#endif

    RTSP_StatusChanged = false;

    (*reg_r2) = RTSP_code;

    return ErrorState();
}

error_flag
Stream::RTSP_getMoreInfo(int reason_code, char* buffer, int* size, int* copied_size)
{
#ifdef DEBUGLIB
    if (Debug(debug_streaminfo))
        Debug("amount read (%i)\n", amount_read);
#endif
    if (reason_code == 0)
    {
        (*size) = (amount_read) ? amount_read + 1: 0;
    }
    else
    {
        if ((1 == reason_code)&&(moreInfo))
        {
            int copy_size = (((*size-1) < amount_read) ? (*size-1):amount_read);
            int len_info = strlen(moreInfo) - amount_read;
#ifdef DEBUGLIB
            if (Debug(debug_streaminfo))
            {
                Debug("read more info (size = (%i) amount read (%i) len info(%i) copy size (%i))\n",
                                                                     (*size), amount_read, len_info, copy_size);
                Debug("%s\n", moreInfo);
            }
#endif
            if (len_info <= amount_read)
            {
                memcpy(buffer, (moreInfo + len_info), copy_size);
                (*size) = (*size) - amount_read;
                (*copied_size) = copy_size;
                amount_read -= copy_size;

                buffer[copy_size] = '\0'; // ensure it is null terminated

                if (amount_read == 0)
                {
                    my_free(moreInfo);
                    moreInfo = NULL;
                    amount_read = 0;
                }
            }
            else
            {
                MakeError(VSP_BadErr);
            }
#ifdef DEBUGLIB
            if (Debug(debug_streaminfo))
            {
                Debug("done read more info (reason (%i) size (%i) amount_read (%i) error (%i))\n",
                                                             reason_code, (*size), amount_read, ErrorExists());
                Debug("%s\n", buffer);
            }
#endif
        }
        else
        {
            MakeError(VSP_InvalidValue);
        }
    }
    return ErrorState();
}

error_flag
Stream::stop_stream(ULONG *new_block_number)
{
  (*new_block_number) = myserver->getMaxRequestedBlock() + (NEC_databurstval << 1);

  return change_state(state_stop);
}

//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++
// this can and will be interrupted by the mpeg calls and internet events.
//
inline error_flag
Stream::timeslice(Statistics *stats)
{
    bool returned_end_block = false;

    if ((ErrorState() == NoError)&&(state != state_stop))
    {
        // 08/11/1999 AR this has been extended to check for the other possible buffers.
        if (callback_pending & callback_tokenfree)
        {
            _kernel_irqs_off();
#if (MAX_NUM_MPEG_Tokens != 4)
            callback_pending -= callback_tokenfree;
#else
            if (callback_pending & callback_token1free)
                callback_pending -= callback_token1free;
            else
            if (callback_pending & callback_token2free)
                callback_pending -= callback_token2free;
            else
            if (callback_pending & callback_token3free)
                callback_pending -= callback_token3free;
            else
                callback_pending -= callback_token4free;
#endif
            _kernel_irqs_on();
#ifdef DEBUGLIB
            if (Debug(debug_callbacks)) Debug("-callback_token?free ts");
#endif
            if ((mysource->calculate_freeBlocks(myserver, &callback_pending, stats, comms_timeout, &returned_end_block)) &&
                (err_ptr == NULL))
            {
                err_ptr = &(mysource->ReturnCopyOfError());
            }

            if ((!(callback_pending & callback_bufferswait))&&(tokenfree()))
            {
                /*--state_value;*/
                test_empty_buffers();
            }

            // this reinitialises the block callback vector if we fill up the blocks
            if (!(callback_pending & callback_timeout))
            {
                MakeErrorOnError(_swix(OS_CallAfter, _INR(0,2), comms_timeout, VSP_CallAfterVeneer, pw));
                callback_pending += callback_nak_after;
#ifdef DEBUGLIB
                if (Debug(debug_callbacks)) Debug("+callback_nak_after %i ts", comms_timeout);
#endif
            }

        }
        else
        {
            if (callback_pending & callback_trickplay)
            {
                ULINT timetoplay = to - from;
                ULONG RequestNum;
                size_t AckNum;
                play_mode mode = mode_normalplay;

                callback_pending -= callback_trickplay;
                callback_pending -= callback_startend;
#ifdef DEBUGLIB
                ULINT from_min = (int)((from >> 1) / 60);
                if (Debug(debug_callbacks))
                    Debug("-callback_trickplay ts\n-callback_startend ts\nplay from NPT %2i:%2i:%2i, %i",
                                       (int)(from_min/60), (int)(from_min % 60), (int)(from_min % 60), from );
#endif
                switch (state)
                {
                    case state_fast_forward:
                        from /= fast_playback_ratio;
                        to   /= fast_playback_ratio;
                        timetoplay =  to - from;
                        mode = mode_fastforward;
                        break;
                    case state_fast_rewind:
                        from /= fast_playback_ratio;
                        to   /= fast_playback_ratio;
                        timetoplay = from - to;
                        mode = mode_fastrewind;
                        break;
                    case state_streamlive:
                        mode = mode_streamlive;
                        break;
                    default:
                        mode = mode_normalplay;
                        break;
                }
                RequestNum = timetoplay;
#ifdef DEBUGLIB
                if (Debug(debug_time)) Debug("play request (expected blocks %i) times %i->%i", RequestNum, from, to);
#endif
                if (mysource->setNewPlayState(&RequestNum, &AckNum, mode, from, comms_timeout) == ErrorOccurred)
                {
                    if (err_ptr == NULL) err_ptr = &(mysource->ReturnCopyOfError());
                }
                else
                {
                    // clear callback vector
                    if (callback_pending & callback_timeout)
                    {
                        callback_pending -= callback_timeout;
#ifdef DEBUGLIB
                        if (Debug(debug_callbacks)) Debug("-callback_timeout ts");
#endif
                        _swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
                    }

                    myserver->send_playback_request( mysource->get_current_play_id(), RequestNum, AckNum, from, mode);

                    if (myserver->ErrorExists())
                    {
                        if (myserver->ErrorNum() == IP_NoBuffer)
                        {
                            myserver->RemoveErr();
                            callback_pending += callback_trickplay;
#ifdef DEBUGLIB
                            if (Debug(debug_callbacks)) Debug("+callback_trickplay %i ts", comms_timeout);
#endif
                            MakeErrorOnError(_swix(OS_CallAfter, _INR(0,2), (comms_timeout), VSP_CallAfterVeneer, pw));
                        }
                        else
                        {
                            if (err_ptr == NULL) err_ptr = &(myserver->ReturnCopyOfError());
                        }
                    }
                    else
                    {
                        myserver->reset_message_sent();
                        callback_pending += callback_bufferswait;
#ifdef DEBUGLIB
                        if (Debug(debug_callbacks)) Debug("+callback_bufferswait ts");
#endif
                        if ((!ErrorExists())&&(state != state_streamlive))
                        {
                            callback_pending += callback_nak_after;
#ifdef DEBUGLIB
                            if (Debug(debug_callbacks)) Debug("+callback_nak_after %i ts", comms_timeout);
#endif
                            MakeErrorOnError(_swix(OS_CallAfter, _INR(0,2), comms_timeout, VSP_CallAfterVeneer, pw));
                        }
                    }
                }
            }
            else // default event foreground execute (save stream)
            {
                callback_pending -= callback_nak_now;
#ifdef DEBUGLIB
                if (Debug(debug_callbacks)) Debug("-callback_nak_now ts");
#endif
                if (!(callback_pending & callback_startend))
                {
                    ULINT timeout = comms_timeout;
                    if (mysource->foregroundExecute(myserver, stats, &timeout) == ErrorOccurred)
                    {
                        if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
                    }
                    else
                    {
                        // test this as we may have deleted a block revealing others
                        if ((!(callback_pending & callback_bufferswait))&&(tokenfree()))
                            test_empty_buffers();

                        if (callback_pending & callback_nak_after)
                        {
                            _swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
#ifdef DEBUGLIB
                            if (Debug(debug_callbacks)) Debug("move callback_nak_after %i ts", timeout);
#endif
                        }
                        callback_pending += callback_nak_after;
                        MakeErrorOnError(_swix(OS_CallAfter, _INR(0,2), timeout, VSP_CallAfterVeneer, pw));
                    }
                }
            }
        }
    }

    if (returned_end_block)
    {
#ifdef DEBUGLIB
        if (Debug(debug_startend))
            Debug("Got end_block callbacks (%x)\n", callback_pending);
#endif
        if (callback_pending & callback_bufferswait)
        {
            reset_sink(mysource->get_most_significant_mode());
            callback_pending -= callback_bufferswait;
#ifdef DEBUGLIB
            if (Debug(debug_callbacks)) Debug("-callback_bufferswait ie");
#endif
            test_empty_buffers();
        }
        bool used_buffer = false;

        for (int i=0; i < MAX_NUM_MPEG_Tokens; i++)
        {
            if (buffers[i].in_use != free_token)
            used_buffer = true;
        }
#ifdef DEBUGLIB
        if (Debug(debug_startend))
            Debug("getStartEnd() used buffer = %i, full blocks = %i", used_buffer, mysource->getFullBlocks());
#endif
        if ((used_buffer == false)&&(mysource->getFullBlocks() == 0))
        {
            if ((mysource->get_most_significant_mode() == mode_fastrewind)||
                (mysource->get_most_significant_mode() == mode_backwardskip))
            {
                myserver->send_message_StartNotification(mysource->getStartEnd());
                callback_pending += callback_startend;
            }
            else
            {
                myserver->send_message_EndNotification(mysource->getStartEnd());
                callback_pending += callback_startend;
                if (!(stream_flags & flags_terminate_eos))
                {
                    change_state(state_endreceived);
                }
                else
                {
#ifdef DEBUGLIB
                    if (Debug(debug_startend))
                    {
                        Debug("determined end of stream looping (%i)\n", looping);
                    }
#endif
                    if (true == looping)
                    {
                        from = start;
                        callback_pending += callback_trickplay;
                        change_state(state);
                    }
                    else
                    {
                        if ((mysink.NotifyEndOfStream() == ErrorOccurred)&&(err_ptr == NULL))
                        {
                            err_ptr = &(mysink.ReturnCopyOfError());
                        }
                    }
                }
            }
#ifdef DEBUGLIB
            if (Debug(debug_callbacks)) Debug("+callback_startend ts");
#endif
        }
    }
    if ((state != state_stop)&&(ErrorExists()))
    {
        myserver->send_message_Error(err_ptr);
    }
    return NoError;
}

inline error_flag
Stream::server_inetevent(int code, int)
{
    UCHAR event = 0;
    ULINT comms_result;
    ULINT CSeq;
    ULINT play_id = mysource->get_current_play_id();

    if (ErrorState() != ErrorOccurred)
    {
        if ( myserver->inetevent(&event, &comms_result, play_id, code, &CSeq) == ErrorOccurred)
        {
            if (err_ptr == NULL) err_ptr = &myserver->ReturnCopyOfError();
        }

        if (!ErrorExists())
        {
            switch (event)
            {
                case COMMAND_startend_notification:
                    mysource->setStartEnd(comms_result);
#ifdef DEBUGLIB
                    if (Debug(debug_startend))
                    {
                        Debug("START/END %i, current block %i", comms_result, mysource->get_most_significant_block());
                    }
#endif
                    break;
                case COMMAND_assetpres_response:
                    if (stream_flags & flags_informvideoctrl)
                    {
                        RTSP_StatusChanged = true;
                        RTSP_RequestInProgress = false;
                        RTSP_code = 500;

                        PostPresentationSetup(); /* this will fill in the status/moreinfo stuff */

                        if (moreInfo != NULL)
                        {
                            amount_read = strlen(moreInfo);
                        }
                        else
                        {
                            amount_read = 0;
                        }
#ifdef DEBUGLIB
                        if (Debug(debug_RTSP))
                        {
                            Debug("Done Post Setup (%i) moreInfo(%8.8X), size (%i)", ErrorExists(), moreInfo, strlen(moreInfo));
                            Debug("**** inform new status presentation response\n");
                        }
#endif
                        MakeErrorOnError(VideoControlInformNewStatus(RTSP_proto_identity));
                    }
                    else
                    { /* don't inform video control */
                        PostPresentationSetup();
                    }
                    break;
                case COMMAND_playback_response:
#ifdef DEBUGLIB
                    Debug("playback response request in progress (%d)\n", RTSP_RequestInProgress);
#endif
                    /* looping may cause a play request but we need to hide this from VideoCtrl */
                    if ((stream_flags & flags_informvideoctrl)&&(true == RTSP_RequestInProgress))
                    {
                        create_RTSP_playblock((server_response_type)comms_result);
                        
                        if ((!ErrorExists())&&(true == RTSP_RequestInProgress))
                        {
                            RTSP_RequestInProgress = false;
                            
                            if (!mysink.validHandle())
                            {
                                int handle = 0;
                                
                                MakeErrorOnError(VideoControlInformPrepareForData(RTSP_proto_identity, RTSP_client_identity, &handle));

                                if (!ErrorExists())
                                {
                                    mysink.SetHandle(handle);
                                }
                           }
                           else
                           {
                               MakeErrorOnError(VideoControlInformNewStatus(RTSP_proto_identity));
                           }
                        }
                    }
                    else
                    {
                        if ((!ErrorExists())&&(comms_result != 0))
                            MakeError(VSP_ServerError, comms_result);
                    }
                /* case switch */
            }
        }
    }

    if ((state != state_stop)&&(ErrorExists()))
    {
        myserver->send_message_Error(err_ptr);
    }
    return NoError;
}

inline error_flag
Stream::source_inetevent(int code, Statistics *stats)
{
  if ((ErrorState() != ErrorOccurred)&&(state != state_stop)) {
  	if (code == Socket_Broken_Event)
        	MakeError(IP_SocketError);// make an error in the stream object to be
        else {
        	callback_flag callback = callback_none;
        	ULINT timeout = comms_timeout; // this is the block timeout
		if (mysource->ReadDatagrams(&callback, stats, &timeout) == ErrorOccurred) {
    			if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
    		}
      		else {
      			if (callback & callback_timeout){
#ifdef DEBUGLIB
				if (Debug(debug_callbacks))
					Debug("%2.2X timeout %i", callback_pending, timeout);
#endif
      			  	// if oldest block has been completed then
				if (callback_pending & callback_nak_after){ // if we update the callback vector.
					_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
  					callback_pending -= callback_nak_after;
#ifdef DEBUGLIB
					if (Debug(debug_callbacks)) Debug("-callback_nak_after ie");
#endif
				}

      			  	if (!(callback_pending & callback_nak_now)){// if a callback is not in the pipe
					if (timeout > 5){
						MakeErrorOnError(_swix(OS_CallAfter, _INR(0,2), timeout, VSP_CallAfterVeneer, pw));
					  	callback_pending += callback_nak_after;
#ifdef DEBUGLIB
						if (Debug(debug_callbacks)) Debug("+callback_nak_after %i ie", timeout);
#endif
					}
					else {
						MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
					  	callback_pending += callback_nak_now;
#ifdef DEBUGLIB
						if (Debug(debug_callbacks)) Debug("+callback_nak_now ie");
#endif
					}
				}

  				if (callback_pending & callback_bufferswait)	// allow for acks
  				  	MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
      			}
      			else
      			if (callback & callback_fullblocks){
      				_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
				callback_pending += callback_fullblocks;
      				callback_pending -= callback_timeout;
#ifdef DEBUGLIB
				if (Debug(debug_callbacks)) Debug("+callback_fullblocks ie\n-callback_timeout ie");
#endif
      			}

      			if ((source != source_vod)&&(mysource->getFullBlocks() == (mysource->getNumBlocks()-num_tokens_to_pass))){
				if ((tokenfree() == false)&&(state != state_pause)) {
#ifdef DEBUGLIB
                        		if (Debug(debug_multicast))
                        	      		Debug("resetting the stream state = %i", state);
#endif
					if ((state != state_stop)&&(state != state_play))
						change_state(state_play);

                                       	reset_sink(mysource->get_most_significant_mode());
                                }
      			}

  			if (callback_pending & callback_bufferswait){

  			  	if (source == source_multicast){
  			  	  	if (mysource->getFullBlocks() >= mysource->getNumBlocks()>>2){	// back to normal play.
  			  	  		if (mysink.SetSpeed(1) == ErrorOccurred){
       							if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
       						}
       						callback_pending -= callback_bufferswait;
#ifdef DEBUGLIB
						if (Debug(debug_callbacks)) Debug("-callback_bufferswait ie");
#endif
                                        }
	  				test_empty_buffers();

                                }
                                else {
  					if (mysource->getFullBlocks() >= buffer_blocks){
						//reset_sink(mysource->get_most_significant_mode());
       						callback_pending -= callback_bufferswait;
#ifdef DEBUGLIB
						if (Debug(debug_callbacks))
							Debug("-callback_bufferswait ie");
#endif
						// 08/11/1999 AR this just gets confusing with variable tokens
						for (int i = 0; i < num_tokens_to_pass; i++)
							test_empty_buffers();
					}
				}
				//check send of acks this should not be used for re-entrancy problems acks and naks are when called
				// from usr mode.
				//if (!ErrorExists()){
				//  	ULINT timeout = comms_timeout;
				//	mysource->foregroundExecute(myserver, stats, &timeout);
				//}
			} // not buffers wait
			else
				if (tokenfree()) test_empty_buffers();

 		}
 	}
  }

  if ((state != state_stop)&&(ErrorExists())) {
  	myserver->send_message_Error(err_ptr);
  }
  return NoError;
}

inline error_flag
Stream::DummyAckCall(void)
{
  if (myserver->comms_flag == false){
      myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock(), dummy_ack);
#ifdef DEBUGLIB
	if (Debug(debug_dummyacks))
		Debug("Dummy Ack");
#endif
  }
  myserver->comms_flag = false;

  if ((state != state_stop)&&(ErrorExists())){
    	myserver->send_message_Error(err_ptr);
  }
   return NoError;
}

#if (MAX_NUM_MPEG_Tokens != 4)
#error Re-defining the number of MPEG tokens; be aware of optimisations used.
inline error_flag
Stream::MPEGInterrupt(int buffer_descriptor)
{
  int i;	// this runs under interrupt avoid changing other peoples variables

  i = 0;
  while (i < MAX_NUM_MPEG_Tokens) {	// remember if num_blocks is zero we cannot touch it.
    	if ((buffers[i].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[i].block->buffers)&&
      	    (buffer_descriptor <  (((int)buffers[i].block->buffers) + (buffers[i].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
  		_kernel_irqs_off();
      	  	buffers[i].blocks_returned++;
  		_kernel_irqs_on();

      	  	if (buffers[i].blocks_returned == buffers[i].block->num_buffers){	// if we have received all the blocks free it
  			if ((mysource->freeBlock(buffers[i].block) == ErrorOccurred )&&(err_ptr == NULL))
  				err_ptr = &mysource->ReturnCopyOfError();

  			buffers[i].block = NULL;
  			buffers[i].in_use = free_token;

  			callback_pending += callback_tokenfree;

    			MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
  		}
      	  	break; 	//claim
        }
        i++;
  }//while search buffers
  return NoError;
}
#else
// 08/11/1999 AR added tests for extra tokens these are always tested, though the call should exit before those tests.
inline error_flag
Stream::MPEGInterrupt(int buffer_descriptor)
{
   if ((buffers[0].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[0].block->buffers)&&
      (buffer_descriptor <  (((int)buffers[0].block->buffers) + (buffers[0].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){

  		_kernel_irqs_off();
      	  	buffers[0].blocks_returned++;
  		_kernel_irqs_on();

  		if (buffers[0].blocks_returned == buffers[0].block->num_buffers){	// if we have received all the blocks free it
  			if ((mysource->freeBlock(buffers[0].block) == ErrorOccurred )&&(err_ptr == NULL))
  				err_ptr = &mysource->ReturnCopyOfError();

  			buffers[0].block = NULL;
  			buffers[0].in_use = free_token;
#ifdef DEBUGLIB
			if (Debug(debug_callbacks)) Debug("token 1 free");
#endif
  			callback_pending += callback_token1free;
    			MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
  		}
   }
   else         // not token 0 try token 1
   if ((buffers[1].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[1].block->buffers)&&
          (buffer_descriptor <  (((int)buffers[1].block->buffers) + (buffers[1].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){

  		_kernel_irqs_off();
      	  	buffers[1].blocks_returned++;
  		_kernel_irqs_on();

   		if (buffers[1].blocks_returned == buffers[1].block->num_buffers){	// if we have received all the blocks free it
  			if (( mysource->freeBlock(buffers[1].block) == ErrorOccurred )&&(err_ptr == NULL))
  				err_ptr = &mysource->ReturnCopyOfError();

  			buffers[1].block = NULL;
  			buffers[1].in_use = free_token;
#ifdef DEBUGLIB
			if (Debug(debug_callbacks)) Debug("token  2 free");
#endif
  			callback_pending += callback_token2free;
    			MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
  		}
    }
    else
    if ((buffers[2].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[2].block->buffers)&&
          (buffer_descriptor <  (((int)buffers[2].block->buffers) + (buffers[2].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){

  		_kernel_irqs_off();
      	  	buffers[2].blocks_returned++;
  		_kernel_irqs_on();

  		if (buffers[2].blocks_returned == buffers[2].block->num_buffers){	// if we have received all the blocks free it
  			if (( mysource->freeBlock(buffers[2].block) == ErrorOccurred )&&(err_ptr == NULL))
  				err_ptr = &mysource->ReturnCopyOfError();

  			buffers[2].block = NULL;
  			buffers[2].in_use = free_token;
#ifdef DEBUGLIB
			if (Debug(debug_callbacks)) Debug("token   3 free");
#endif
  			callback_pending += callback_token3free;
    			MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
  		}
    }
    else
    if ((buffers[3].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[3].block->buffers)&&
          (buffer_descriptor <  (((int)buffers[3].block->buffers) + (buffers[3].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){

  		_kernel_irqs_off();
      	  	buffers[3].blocks_returned++;
  		_kernel_irqs_on();

  		if (buffers[3].blocks_returned == buffers[3].block->num_buffers){	// if we have received all the blocks free it
  			if (( mysource->freeBlock(buffers[3].block) == ErrorOccurred )&&(err_ptr == NULL))
  				err_ptr = &mysource->ReturnCopyOfError();

  			buffers[3].block = NULL;
  			buffers[3].in_use = free_token;
#ifdef DEBUGLIB
			if (Debug(debug_callbacks)) Debug("token 4 free");
#endif
  			callback_pending += callback_token4free;
    			MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
  		}
    }
    return NoError;
}
#endif

error_flag
Stream::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  mysource->serviceDynamicAreaRenumber(old_id, new_id);

  if ((state != state_stop)&&(ErrorExists()))
  	myserver->send_message_Error(err_ptr);

  return NoError;
}

//+++++++++++++++++++++++++++++++ StreamList Methods ++++++++++++++++
StreamList::StreamList(void):List()
{
}

error_flag
StreamList::Add(Stream *str, int *id)
{
	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &(str->start_time));

	str->data_at_start = stats.bytes_received;
	str->acks_at_start = stats.acks_sent;
	str->naks_at_start = stats.naks_sent + stats.block_naks_sent;

  	*id = (int)str;

  	return List::Add((ListObject*)str, id);
}


error_flag
StreamList::Remove(int identifier)	// returns a boolean success value
{
  error_flag result = ErrorState();

  if (result != ErrorOccurred) {
	  unsigned int mt_time;
	  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &mt_time);

	  Stream *str;

	  if (identify((ListObject**)&str, identifier) != ErrorOccurred) {

	  	if (mt_time > str->start_time){
	  		// stream bytes received
	  		stats.last_stream_bytes_received = (ULINT)(stats.bytes_received - str->data_at_start);
	  		stats.last_stream_time = (ULINT)(mt_time - str->start_time);
	  		stats.last_stream_acks = (ULINT)(stats.acks_sent - str->acks_at_start);
	  		stats.last_stream_naks = (ULINT)((stats.naks_sent + stats.block_naks_sent) - str->naks_at_start);
	  	} // bitrate calculation

	  	result = List::Remove(identifier);
         }
         result = ErrorOccurred;
  }

  return  (ErrorExists() ? ErrorOccurred : NoError );
}

//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++
// the first argument is code or the out of band etc indicator.
error_flag
StreamList::inetEvent(int code, int identifier, claim_flag *claim, void *)
{
  if ((ErrorState() != ErrorOccurred)&&(identifier != -1)){
  	for (int i=0;i<Size();i++){
  	  	if (object[i] != NULL){
  			Stream *stream = ((Stream*)object[i]);
    			if ((stream->source_sd) == identifier) {
#ifdef DEBUGLIB
			if (Debug(debug_callbacks)) Debug("source++ (%i)", stream->inet_udp_reenter);
#endif
    			  	_kernel_irqs_off();
    			  	if ( (++(stream->inet_udp_reenter)) <= 1)
    			  		do {
        					_kernel_irqs_on();
    		  				if (stream->source_inetevent(code, &stats) == ErrorOccurred){
    		  	  				if (err_ptr == NULL) err_ptr = &stream->ReturnCopyOfError();
    		  				}
    		  				_kernel_irqs_off();
    		  			} while ((--(stream->inet_udp_reenter)) > 0);
    	 			*claim = claim_event;
    	 			_kernel_irqs_on();
#ifdef DEBUGLIB
			if (Debug(debug_callbacks)) Debug("source--");
#endif
                	}
    			else
    			if ((stream->server_sd) == identifier) {
#ifdef DEBUGLIB
			if (Debug(debug_callbacks)) Debug("server++ (%i)", stream->inet_tcp_reenter);
#endif
    			  	_kernel_irqs_off();
    			        if ( (++stream->inet_tcp_reenter) <= 1)
    			  		do {
        					_kernel_irqs_on();
        	   				if ( stream->server_inetevent(code, identifiers[i]) == ErrorOccurred){
      			  				if (err_ptr == NULL) err_ptr = &stream->ReturnCopyOfError();
       						}
       						_kernel_irqs_off();
    		  			} while ((--stream->inet_tcp_reenter) > 0);
        			*claim = claim_event; // claim even if in use
    			  	_kernel_irqs_on();
#ifdef DEBUGLIB
			if (Debug(debug_callbacks)) Debug("server--");
#endif

        		}

        	}
        }
  }
  return  NoError;
}

error_flag
StreamList::TimeSliceCall(void *)
{
  if (ErrorState() != ErrorOccurred){
  	for (int i=0; i<Size(); i++){
  	  	if (object[i] != NULL){
    			Stream *stream = ((Stream*)object[i]);

    			if ((stream->callback_pending != callback_none)){
      				if (( stream->state == state_stop)&&( stream->change_state(state_stop) != ErrorOccurred ))
      				  	Remove(identifiers[i--]);	// remove it from the list (decrement i because the list is moved down)
      				else
      					if (stream->timeslice(&stats) == ErrorOccurred){
    						if (err_ptr == NULL) err_ptr = &stream->ReturnCopyOfError();
      					}
			}
                }
        }
  }
  return  (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag // fast interrupt
StreamList::TimeSliceCallTickerTimeout(void *pw)
{
#ifdef DEBUGLIB
  if (Debug(debug_callbacks)) Debug("ticker timeout");
#endif
  if (ErrorState() != ErrorOccurred){
  	for (int i=0; i<Size(); i++){
  	  	if (object[i] != NULL){
  	  	  	Stream *stream = ((Stream*)object[i]);
  	  	  	bool swapped = false;

  	  	  	_kernel_irqs_off();
  	  	  	if (stream->callback_pending & callback_nak_after){
  	  	  	  	if (!(stream->callback_pending & callback_nak_now)){
  	  	  	  	  	swapped = true;
  	  	  	  		stream->callback_pending += callback_nak_now;
#ifdef DEBUGLIB
					if (Debug(debug_callbacks)) Debug("+callback_nak_now tt");
#endif
  	  	  	  	}
  	  	  	  	stream->callback_pending -= callback_nak_after;
#ifdef DEBUGLIB
				if (Debug(debug_callbacks)) Debug("-callback_nak_after tt");
#endif
  	  	  	}
  	  	  	_kernel_irqs_on();

  	  	  	if (swapped == true)
  	  	  		_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);
	        }
	}
  }
  return NoError;
}

error_flag // fast interrupt no error handling as this is a re-entrancy issue
StreamList::MPEGInterrupt(int buffer_descriptor)
{
 if (ErrorState() != ErrorOccurred){
  	for (int i=0; i<Size(); ++i) {
  	  	if (object[i] != NULL)
    			((Stream*)object[i])->MPEGInterrupt(buffer_descriptor);
  	}
  }
  return NoError;
}

error_flag // fast interrupt on call every
StreamList::DummyAckPoll(void)
{
  if (ErrorState() != ErrorOccurred){
  	for (int i=0; i<Size(); ++i)
    		if (object[i] != NULL)
    		  	((Stream*)object[i])->DummyAckCall();
  }
  return  NoError;
}

error_flag
StreamList::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  if ( ErrorState() != ErrorOccurred){
  	for (int i=0;i<Size();i++)
  		if (object[i] != NULL)
  			((Stream*)object[i])->ServiceDynamicAreaRenumber(old_id, new_id);
  }
  return NoError;
}
