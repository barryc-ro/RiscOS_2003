/**************************************
 Stream.c
	
impliments standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Stream.h"	// Source Element
#include "swis.h"
#include "string.h"

StreamToken::StreamToken()
{
	block = NULL;
	in_use = free_token;
	blocks_returned = 0;
}

StreamToken::~StreamToken(void)
{
 	block = NULL;		// this is assigned to point to source memory space
	blocks_returned = 0;
}

#if (NUM_MPEG_Tokens != 2)
#error Re-defining the number of MPEG tokens; be aware of optimisations used.
inline bool
Stream::tokenfree(void)
{
  for (int i = 0; i < NUM_MPEG_Tokens; ++i)
  	if (buffers[i].in_use == free_token)
  		break;
  return (i < NUM_MPEG_Tokens);
}

inline error_flag
Stream::test_empty_buffers(void)
{
  error_flag result = ErrorState();
  int token_id = -1;
  
  if ((state != state_step)||(step_times != 0)&&(--step_times)){
 	
 	for (int i = 0; i < NUM_MPEG_Tokens; ++i){
 	  	if (buffers[i].in_use == free_token){
 	  	  	token_id = i;
 	  	  	break;
 	  	}
 	}
  
  	if ( (result != ErrorOccurred)&&(state != state_stop)&&(token_id != -1) ) {
		buffers[token_id].in_use = claim_token;	// paired with free block
	    	result = mysource->getBlock(&(buffers[token_id].block), &(buffers[token_id].mpeg_buffer), ((int)VSP_MPEGCall), ((int)pw));
 	
	 	if (result != ErrorOccurred){
	 		if(buffers[token_id].block != NULL){
				buffers[token_id].blocks_returned = 0;
				if ((result = mysink->FullBuffer(buffers[token_id].mpeg_buffer)) == ErrorOccurred)
					err = &(mysink->ReturnCopyOfError());
			}
			else
				buffers[token_id].in_use = free_token;
	        }
	 	else {
	                buffers[token_id].in_use = free_token;
	 	  	err = &mysource->ReturnCopyOfError();
	 	} // !get block error occurred
	}
  }
  return result;
}
#else
inline bool
Stream::tokenfree(void)
{
 	return (bool)((buffers[0].in_use == free_token)||(buffers[1].in_use == free_token));
}

inline error_flag
Stream::test_empty_buffers(void)
{
  error_flag result = ErrorState();
  int token_id;
  
  if ((state != state_step)||(step_times != 0)&&(--step_times)){
 
  	MACRO_getFreeToken(token_id);
  
  	if ( (result != ErrorOccurred)&&(state != state_stop)&&(token_id != -1) ) {
		buffers[token_id].in_use = claim_token;	// paired with free block
	    	result = mysource->getBlock(&(buffers[token_id].block), &(buffers[token_id].mpeg_buffer), ((int)VSP_MPEGCall), ((int)pw));
 	
	 	if (result != ErrorOccurred){
	 		if(buffers[token_id].block != NULL){
				buffers[token_id].blocks_returned = 0;
				if ((result = mysink->FullBuffer(buffers[token_id].mpeg_buffer)) == ErrorOccurred)
					err = &(mysink->ReturnCopyOfError());
			}
			else
				buffers[token_id].in_use = free_token;
	        }
	 	else {
	                buffers[token_id].in_use = free_token;
	 	  	err = &mysource->ReturnCopyOfError();
	 	} // !get block error occurred
	}
  }
  return result;
}
#endif


Stream::Stream(int inet_timeout, char* group, int port, int MPEGid, int source_recvspace, int NumBlocks, int BufferBlocks, int TCP_TimeOut, void *pwork):Error()
{
  // MULTICAST CONSTRUCTOR
  
  // STB specific variables
  source = source_multicast;
  
  message_sent = false;
  source_flag = free_token;
  server_flag = claim_token;
  comms_timeout = inet_timeout;

  pw = pwork;
  from = endofstream = 0;
  	
  callback_pending = callback_bufferswait;	// buffer management is in a state of waiting for buffer blocks

  error_flag result = NoError;
  
  state = state_play;			// set the state of play

  buffer_blocks = BufferBlocks;	
   
  mysink = new Sink(MPEGid);
  if (mysink->ErrorExists()) {
   	err = &mysink->ReturnCopyOfError();
   	result = ErrorOccurred;
  }
  else{ 	
    	myserver = NULL;
  	mysource = new SourceMultiCast(group, source_recvspace, port, NumBlocks, TCP_TimeOut);		// create UDP socket
  	if  ( mysource->ErrorExists() ){ // errors on creation of UDP
  		err = &mysource->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  }
  
  if ((result != ErrorOccurred) && (mysource->getSocketDescriptor(&source_sd) == ErrorOccurred)  ){
  		err = &mysource->ReturnCopyOfError();
  		result = ErrorOccurred;
  }
  server_sd = -1;

  trick_modes = trick_normal_play;
}
// stream constructor MULTICAST

Stream::Stream(int inet_timeout, int initial_block, int MPEGid, PlayList playlist, int play_num, Server *server, int NumBlocks, 
	int source_recvspace, int BufferBlocks, void *pwork, int in_from, int in_to):Error()
{
  // server specific variables
  int BlockSize;		// data size calculation
  int num_dgrams; 		// maximum number of datagrams
  ULINT dgram_size, bitrate;
  in_addr ipAddress;		// structure defined in internet library
  ULINT portnum;		// of server object, receiving
    

  // STB specific variables
  message_sent = false;
  source = source_vod;
  source_flag = server_flag = free_token;
  comms_timeout = inet_timeout;

  pw = pwork;
  if (in_from > 0)
  	from = in_from*2;
  else
  	from = 0;
  	
  callback_pending = callback_bufferswait;	// buffer management is in a state of waiting for buffer blocks

  error_flag result = NoError;
  
  mysink = new Sink(MPEGid);
  state = state_prestart;			// set the state of play

  buffer_blocks = BufferBlocks;	
   
  if ((result != ErrorOccurred)&&(mysink->ErrorExists())) {
   	err = &mysink->ReturnCopyOfError();
   	result = ErrorOccurred;
  }
  else{ 	
    	myserver = server;

#ifdef DEBUGLIB
	Debug("creating  messageQ id 0x07");
	myserver->create_message_pipe(0x07);
#endif	  
    	myserver->set_stream_owner();
  	mysource = new Source((comms_timeout+1)>>1, source_recvspace);			// create UDP socket
 	
 	if (myserver->ErrorExists()){ 				// errors on creation of TCP
  		err = &myserver->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  	else 
  	if  (mysource->ErrorExists()&&(mysource->ErrorNum() != VSP_SourceUninit)){ // errors on creation of UDP
  		err = &mysource->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  }
  	
  if ((result != ErrorOccurred) &&		// on no error
  	   	( (mysource->getLocalPort((int*)&portnum)== ErrorOccurred)  ||	// get UDP port number for asset presentation
  	   	  (mysource->getSocketDescriptor(&source_sd) == ErrorOccurred)    ) ){
  			err = &mysource->ReturnCopyOfError();
  			result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
  		((myserver->getSocketDescriptor(&server_sd)) == ErrorOccurred)) {
    			err = &(myserver->ReturnCopyOfError());
    			result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
  		(myserver->getLocalAddress((in_addr*)&ipAddress) == ErrorOccurred) ){
    			err = &(myserver->ReturnCopyOfError());
    			result = ErrorOccurred;
  }
  ULINT fast_playback;
  
  if ((result != ErrorOccurred)&&
  		((myserver->AssetPresentation(initial_block, playlist, play_num, &endofstream,
  						 &ipAddress, &portnum, &dgram_size, &bitrate, &fast_playback)) == ErrorOccurred)) {
   			err = &myserver->ReturnCopyOfError();
   			result = ErrorOccurred;
  }
  trick_modes = implemented_trick_modes | (fast_playback >> 24);
  fast_playback_ratio = fast_playback & 0xFFFFFF;
  
  if (endofstream == 0xFFFFFFFF){	// if stream live
  	trick_modes +=  trick_jump_most_rec;
  }
  
  if ((in_from >= 0)&&(in_from < endofstream))
  	from = in_from*2;
  else
  	MakeError(VSP_InvalidValue);
  	
  if ((in_to == 0)||(in_to > from)){
  	if (((in_to << 1) < endofstream)&&(in_to != 0))
  		endofstream = (in_to << 1);
  }
  else
	MakeError(VSP_InvalidValue);
	
#ifdef DEBUGLIB
	ErrorDump();
	if (trick_modes & trick_jump_most_rec)
		Debug("Being Registered tricks %8.8X", trick_modes);
	else
		Debug("Registered Video %i to %i (secs), tricks %8.8X", from/2, endofstream/2, trick_modes);
#endif  
	  	
  bitrate = (bitrate/8);  			// bytes per 2/3 sec's	this ensures enough dgrams
  num_dgrams = (int) (bitrate / (dgram_size-sizeof(NECDatagram)));  
  BlockSize =  num_dgrams * (int)dgram_size;	// calculation on datagram size and bitrate
  if ((result != ErrorOccurred)&&
   		(mysource->Allocate(NumBlocks, BlockSize, initial_block, (size_t)dgram_size) == ErrorOccurred)){
  			err = &mysource->ReturnCopyOfError();
  			result = ErrorOccurred;

  }
  ipAddress.s_addr = ntohl(ipAddress.s_addr);		// ipaddress of server as port are set in the asset presentation
  if ((result != ErrorOccurred)&&
  	(mysource->setServerDetails(ipAddress, (int)portnum) == ErrorOccurred)) {
  		      	   err = &mysource->ReturnCopyOfError();
 	 	      	   result = ErrorOccurred;
  }

  if ((result != ErrorOccurred)&&
 	(myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock(), play_preparation) == ErrorOccurred)){
  		  err = &myserver->ReturnCopyOfError();
  		  result = ErrorOccurred;
 	}// send request for play
  if (result != ErrorOccurred){
        result = change_state(state_play);	// this will make an imediate callback for trickplay.
        if (myserver != NULL){
        	myserver->send_message_StartNotification(initial_block);
        	message_sent = true;
        }
  }
        
#ifdef DEBUGLIB
  ErrorDump();
#endif	  
} 	// stream constructor

Stream::~Stream(void)
{
  int used_buffer = 1;		// token used by MPEG module
  
  int status = 0;		// this is a code used in the server log.
  
  source_flag = claim_token;
  
  if (myserver != NULL){
    	myserver->send_message_StreamClosing(err);
  	myserver->AssetEnd(status, (state != state_endreceived));
  }
 
  if ((change_state(state_stop) != ErrorOccurred)||(ErrorNum() != VSP_CantDeleteSharedMemory)){
    	// this is because errors can occur including errors returned from the server not always shared memory
    	delete mysource; mysource = NULL;
  }
  else {
   	do {
    		RemoveErr();
 		mysink->DropBuffers();	
    	}
    	while (change_state(state_stop) == ErrorOccurred);
    	delete mysource; mysource = NULL;
  }

  delete mysink;   mysink = NULL;
  
  if (myserver != NULL){
  	if (myserver->interface_uses()){
    		myserver->clear_stream_owner();
  	}
  	else  {
  		delete myserver; myserver = NULL;
  	}
  }
}
inline error_flag
Stream::swap_source(void)
{
  error_flag result = NoError;
 
	if (source == source_streamlive){
     		Source *tmp = mysource;
     		mysource = new Source((*tmp));
     		delete tmp;
     		if (mysource->ErrorExists()){
     			err = &ReturnCopyOfError();
     			result = ErrorOccurred;
     		}
     		source = source_vod;
#ifdef DEBUGLIB     
        	Debug("LIVE -> Stored");
#endif
        }
        else {
        	if (source == source_vod){
    	  		Source *tmp = mysource;
     	  		mysource = new SourceLIVE((*tmp));
     	  		delete tmp;
     			if (mysource->ErrorExists()){
     				err = &ReturnCopyOfError();
     				result = ErrorOccurred;
     			}
     			source = source_streamlive;
#ifdef DEBUGLIB     	  
        	Debug("Stored -> LIVE");
#endif        	
                }
         }
        return result;
}
//
// this is the central change of state method for the stream class
// the stream state should not change state unless going through here
// the 'trick_mode' are checked to ensure that a particular state is 
// available to a particular stream.  It is debatable as to whether 
// an error should be created otherwise.
//
error_flag
Stream::change_state(state_of_play new_state)
{ 
   error_flag result = ErrorState();
   int i;
   bool used_buffer = false;

#ifdef DEBUGLIB
   	Debug("state %i -> %i", state, new_state);
#endif
	   
   switch (new_state) {
     case state_slow:
     	if (trick_modes & trick_slow_play)
     		state = state_slow;
     	break;
     case state_step:
     	if (trick_modes & trick_step_play){
     	  	if (source != source_vod) 
     	  		swap_source();
     		state = state_step;
     		result = test_empty_buffers();
     	}
     	break;
     case state_endreceived:
     	state = state_endreceived;
     	break;
     case state_stop:
   	if (state != state_stop){
   	  	if (callback_pending & callback_timeout){
   			callback_pending -= callback_timeout;
     			_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
     		}
   		mysource->setEndPlayState();		// this ensures no more data is copied upriver.
   		state = state_stop;
        }
     	for (i=0; i < NUM_MPEG_Tokens; i++){
     		if (buffers[i].in_use != free_token) {
     			used_buffer = true;
    		}
     	}
#ifdef DEBUGLIB
     	//Debug("close stream; flags %2.2X, tokens (%i)(%i)", callback_pending, 
     	//(buffers[0].in_use == claim_token), (buffers[1].in_use== claim_token));
#endif    				
     	if (used_buffer == true){
     		MakeError(VSP_CantDeleteSharedMemory);
     		result = ErrorOccurred;
     	}
   	break;
     case state_pause:
     	if ((state != state_pause)&&(trick_modes & trick_pause)) {
   		from = getNECTime();
     		state = state_pause;
     	}
     	break;
     case state_play:
        if ((state != state_play)&&(trick_modes & trick_normal_play)) {
     	  	if (source != source_vod) {
     	  		state = state_streamlive;
     	  		swap_source();
    	  	}
         	
          	if (state == state_step) {
          		state = state_play;
               		result = test_empty_buffers();
               	}
		else{
           		if ((state != state_pause)&&(state != state_step)&&(state != state_slow)) {
     	  			callback_pending += callback_trickplay;
     	  			if (state != state_prestart)
   					from = getNECTime();
   			}// if state is paused time is set at pause time, jumps reset this time
   			state = state_play;
   		}
	}
     	break;
     case state_streamlive:
     	if ((state != state_streamlive)&&(trick_modes & trick_jump_most_rec)){
     	  	if (source != source_streamlive) swap_source();
     		callback_pending += callback_trickplay;
     		from = 0xFFFFFFFF;
     		state = state_streamlive;
     	}
        break;
     case state_fast_forward:
        if ((state != state_fast_forward)&&(trick_modes & trick_fast_forward)&&(source != source_streamlive)){
   		from = getNECTime();
         	state =  state_fast_forward;
     	  	callback_pending += callback_trickplay;
	}
     	break;
     case state_fast_rewind:
        if ((state != state_fast_rewind)&&(trick_modes & trick_fast_rewind)){
               if (source != source_vod) 
     	  		swap_source();
   		from = getNECTime();
     		state =  state_fast_rewind;
     	  	callback_pending += callback_trickplay;
	}
     	break;
   }
   
   if (callback_pending & callback_trickplay) {
#ifdef DEBUGLIB
  	int current_min, future_min;
  	
  	current_min = (int)((getNECTime()>>1) / 60);
  	future_min = (int)((from >> 1)/ 60);
  	Debug("trick play (%2i:%2i:%2i) -> (%2i:%2i:%2i)", (int)(current_min/60), (int)(current_min % 60), (int)((getNECTime()>>1) % 60),
  							   (int)(future_min/60), (int)(future_min % 60), (int)((from >> 1) % 60));
#endif

  	_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 	if (e != NULL){
  		MakeError(e);
  		result = ErrorOccurred;
 	} 
   }

   return result;
}

error_flag
Stream::GetSinkHandle(void)
{
  if (mysink->GetHandle() == ErrorOccurred){
    	err = &(mysink->ReturnCopyOfError());
  	return ErrorOccurred;
  }
  else
  	return NoError;
}

error_flag 
Stream::CheckEOS(int *play_state)			// call to Decoder
{
  if ((state == state_stop)||(state == state_endreceived)){
  	(*play_state) = 1;
  }
  else
  	(*play_state) = 0;
  
  return ErrorState();
}

error_flag
Stream::SetSpeed(int direction, int speed)		// call to Decoder
{
  
 if ((direction == 2)&&(trick_modes & trick_step_play)){
 	step_times = speed;
 	change_state(state_step);
 }
 else 
 switch(speed) {
    case 0:
    	if (speed == 0)
    		change_state(state_pause);
    	else
  		MakeError(VSP_Unimplemented);
    	break;
    case 1:
    	if (direction == 1)
    		change_state(state_fast_forward);
    	else
    		change_state(state_play);
    	break;
    case -1:
     	if (direction == 1)
    		change_state(state_fast_rewind);
    	break;
    default:
    	if (direction == 0)
    		change_state(state_slow);
	else    		
  		MakeError(VSP_Unimplemented);
 }
 return ErrorState();
}

error_flag
Stream::SetPosition(int flags, int pos_time)	 // call to Decoder
{
  error_flag result = NoError;
  ULINT NEC_time = getNECTime();
  ULINT abs_time;//, playback_id, AckNum;
  //size_t freebuf;
 if (flags == 1){
     abs_time = NEC_time + (pos_time * 2);
  }
  else
  if (flags == 2){
    abs_time = NEC_time - (pos_time * 2);
  }
  else {
     if ((pos_time < 0)&&(endofstream == 0xFFFFFFFF))
     	abs_time = 0xFFFFFFFF;
     else
     	abs_time = (pos_time << 1);
  }
  
  if (((abs_time & 0x80000000)&&(endofstream != 0xFFFFFFFF))||(abs_time > endofstream)){
  	MakeError(VSP_InvalidValue);
  	result = ErrorOccurred;
  }
  else {
  	from = abs_time;
  
  	if (abs_time == 0xFFFFFFFF)
  		change_state(state_streamlive);
  	else {
#ifdef DEBUGLIB
  		int current_min, future_min;
  	
  		current_min = (int)((NEC_time>>1) / 60);
  		future_min = (int)((from >> 1)/ 60);
  		Debug("trick play (%2i:%2i:%2i) -> (%2i:%2i:%2i)", (int)(current_min/60), (int)(current_min % 60), (int)((NEC_time>>1) % 60),
  							   (int)(future_min/60), (int)(future_min % 60), (int)((from >> 1) % 60));
#endif
  		callback_pending += callback_trickplay;
  		_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
  		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
  		} 
  	}
  }
  return result;
}

inline ULINT
Stream::getNECTime(void)
{
  ULINT time;
  
  if ((state == state_fast_forward)||(state == state_fast_rewind))
    	time = (ULINT)(mysource->get_most_significant_time()) * fast_playback_ratio;
  else
  	time = (ULINT)mysource->get_most_significant_time();
  	
  return time;
}

error_flag
Stream::ReadNPT(ULINT *NPT_time)
{ 
   if (!ErrorExists()){
	//if (source == source_multicast){
	//	if (mysink->ReadNPT(NPT_time) == ErrorOccurred)
	//		err = &(mysink->ReturnCopyOfError());
	//}
	//else {
		(*NPT_time) = (getNECTime() >> 1);
	//}
   }
   return ErrorState();
}

error_flag
Stream::GetMiscInfo(ULINT *reg_r0, misc_5_10 *ptr, int *size)
{
  ULINT flags = (*reg_r0);
  switch (flags) {
    case 0x00:
    	if ((ptr == NULL)||(size == 0))
    		(*size) = sizeof(misc_5_10);
    	else {
    	  	if ( (*size) < sizeof(misc_5_10) )
    	  		MakeError(VSP_InvalidValue);
    	  	else {
    	  	  	if (mysource->getMiscInfo(type_misc_5_10, ptr) == ErrorOccurred)
    	  	  		err = &(mysource->ReturnCopyOfError());
	  	}
    	}
    	break;
    case 0x01:
    	(*reg_r0) = trick_modes;
    	break;
    case 0x02:
#ifdef DEBUGLIB    	
    	if (ErrorExists()){
    	  	Debug("stream error exists");
		ErrorDump();
    	}
    	else
    	if ((myserver != NULL)&&(myserver->ErrorExists())){
    	  	Debug("server error");
    	}
    	else {
    	  	if (mysink->ErrorExists()){
    	  	  	Debug("SinkError");
    	  	}
   		Debug("stream (%i)- cb %2.2X, t[0] (%i), t[1] = (%i)", 
    				mysource->getFullBlocks(), callback_pending, 
    				(buffers[0].in_use == claim_token), (buffers[1].in_use== claim_token));
    		mysource->getMiscInfo(type_debug, NULL);
    	}
#endif    	
    	if (state > state_still)
    		(*reg_r0) = state_play;
    	else
    		(*reg_r0) = state;
    	break;
  }
  
  return ErrorState();
}

error_flag
Stream::stop_stream(ULONG *new_block_number)
{
  if (((*new_block_number) = mysource->getFinalBlock()) == 0)
    (*new_block_number) = mysource->get_most_significant_block();
    
    (*new_block_number) += (NEC_databurstval << 1);	// ensure that the next block requested is greater than any sent
  
  return change_state(state_stop);
}

//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++

inline error_flag
Stream::timeslice(Statistics *stats)
{
  error_flag result = NoError;
  callback_flag flags = callback_pending;
  if (state == state_stop) return result;
  
  	if (callback_pending & callback_bufferfree){

  		result = mysource->calculate_freeBlocks(myserver, callback_pending, stats);
  		if (result == ErrorOccurred)
  			err = &(mysource->ReturnCopyOfError());

  		callback_pending -= callback_bufferfree;
  			
  		if (tokenfree())
  			result = test_empty_buffers();
  			
  		if (!(callback_pending & callback_timeout)){
                       	// this reinitialises the block callback vector if we fill up the blocks
  			callback_pending += callback_block;
			_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), comms_timeout, VSP_CallAfterVeneer, pw);	  	
 			if (e != NULL){
  				MakeError(e);
  				result = ErrorOccurred;
 			}  
 		} 
  	}
  	else {
		if (callback_pending & callback_trickplay){
		  
        		ULINT playback_id;
        		ULONG RequestNum;
        		size_t AckNum, play_mode = 0;
        	
        		callback_pending -= callback_trickplay;
       			
       			switch (state){
        			case state_fast_forward:
        	  			play_mode = 3;
        	  			break;
        	  		case state_fast_rewind:
        	  			play_mode = 4;
        	  			break;
        	  		case state_streamlive:
        	  		  	callback_pending += callback_bufferswait;
        	  			play_mode = 7;
        	  			break;
        	  		//default 0;
        		}
        	
        		mysource->clearFinalBlock();	// ignore any previous end block numbs
   	 		result = mysource->setNewPlayState(&playback_id, &RequestNum, &AckNum, play_mode);
   			if (result != ErrorOccurred){
   			  
   			  	if (callback_pending & callback_timeout){
   			  		callback_pending -= callback_timeout;
     					_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
     				}	 
     	 			result = myserver->send_playback_request(playback_id, RequestNum, AckNum, from, play_mode);
     	 			
     	 			if (result == ErrorOccurred){
     	 			  	if (myserver->ErrorNum() == IP_NoBuffer){
     	 			  	  	myserver->RemoveErr();
     	 			  	  	result = NoError;
     	 			 	  	callback_pending += callback_trickplay;
     	 			 	  	_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), (comms_timeout), VSP_CallAfterVeneer, pw);	  	
 						if (e != NULL){
  							MakeError(e);
  							result = ErrorOccurred;
 						}
     	 			 	}
     	 			 	else  	
     	 					err = &(myserver->ReturnCopyOfError());
     	 			}
     	 			else{
     	 			  	message_sent = false;
     	 			  	callback_pending += callback_bufferswait;
     	 			  	if ((result != ErrorOccurred)&&(state != state_streamlive)){
     	 					callback_pending += callback_block;
                				_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), (comms_timeout), VSP_CallAfterVeneer, pw);	  	
 						if (e != NULL){
  							MakeError(e);
  							result = ErrorOccurred;
 						}
 					}
 				}
                	}
                	else
                		err = &(mysource->ReturnCopyOfError());
                }
 		else {// default foreground execute (save stream)
 		  	if (mysource->foregroundExecute(&callback_pending, myserver, stats) == ErrorOccurred){
  				err = &mysource->ReturnCopyOfError();
  				result =  ErrorOccurred;
  			}
  				
  			if (callback_pending & callback_nak){
                		callback_pending += callback_nak;
     				_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), ((comms_timeout+1)>>1), VSP_CallAfterVeneer, pw);	  	
 				if (e != NULL){
  					MakeError(e);
  					result = ErrorOccurred;
 				} 
 			}
 		}
  	}
  	// calculate if the mpeg player has tokens if so use them as timeout values
  	// also calculate if we own all the tokens then we are starting the stream
  	// wait for more than buffer blocks

#ifdef DEBUGLIB    	  
  if (result == ErrorOccurred) {
    	Debug("stream error");
    	ErrorDump();
    	mysource->getMiscInfo(type_debug, NULL);
  }
#endif
  if ((result == ErrorOccurred)&&(myserver != NULL)&&(!message_sent)){
    	myserver->send_message_Error(err);
    	message_sent = true;
  }
  	  	
  return result;
}

inline error_flag
Stream::server_inetevent(void)
{
  UCHAR event = 0;
  ULINT comms_result;
  error_flag result = ErrorState();
  
  if ( myserver->inetevent(&event, &comms_result, mysource->get_current_play_id()) == ErrorOccurred) {
  	err = &myserver->ReturnCopyOfError();
  	result = ErrorOccurred;
  } 
  if ((event == COMMAND_startend_notification)&&(myserver != NULL)&&(!message_sent)){
  	if ((state == state_fast_rewind)||(state == state_backward_skip))
		myserver->send_message_StartNotification(comms_result);        
        else
		myserver->send_message_EndNotification(comms_result);
	message_sent = true;
  }

  if ((result == ErrorOccurred)&&(myserver != NULL)&&(!message_sent)){
    	myserver->send_message_Error(err);
  	message_sent = true;
  }
  return result;
}

inline error_flag
Stream::DummyAckCall(void)
{
  error_flag result = NoError;
  
  if ((myserver != NULL)&&(state != state_stop)) { //server is null if multicast
  	if (myserver->comms_flag != comms)	// defined in the server class
 		if (myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock(), dummy_ack) == ErrorOccurred){
 			err = &(myserver->ReturnCopyOfError());
 			result = ErrorOccurred;
 		}
 		myserver->comms_flag = no_comms;
  }
  if ((result == ErrorOccurred)&&(myserver != NULL)&&(!message_sent)){
    	myserver->send_message_Error(err);
    	message_sent = true;
  }
 return result;
}

#if (NUM_MPEG_Tokens != 2)
#error Re-defining the number of MPEG tokens; be aware of optimisations used.
inline error_flag
Stream::MPEGInterrupt(int buffer_descriptor)
{
  int i;	// this runs under interrupt avoid changing other peoples variables
  error_flag result = ErrorState();
  
  i = 0;
  while (i < NUM_MPEG_Tokens) {	// remember if num_blocks is zero we cannot touch it.
    	if ((buffers[i].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[i].block->buffers)&&
      	    (buffer_descriptor <  (((int)buffers[i].block->buffers) + (buffers[i].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
      	  	buffers[i].blocks_returned++;
      	  	break; 	//claim
        }
        i++;
  }//while search buffers
 
  if ((i < NUM_MPEG_Tokens)&&(buffers[i].blocks_returned == buffers[i].block->num_buffers)){	// if we have received all the blocks free it
  	if ( (result != ErrorOccurred)&&(( result = mysource->freeBlock(buffers[i].block)) == ErrorOccurred) )
  		err = &mysource->ReturnCopyOfError();
  
  	buffers[i].block = NULL;
  	buffers[i].in_use = free_token;
  	
	if ((!(callback_pending & callback_bufferfree))||(state == state_stop)){
  		callback_pending += callback_bufferfree;	  	
    		_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
 	}
 	
 	if (state != state_stop){
 		if (callback_pending & callback_fullblocks)
  			callback_pending -= callback_fullblocks);
  			
  		callback_pending += callback_tokenfree;
  	}// !stop
 }

  if ((result == ErrorOccurred)&&(myserver != NULL)&&(!message_sent)){
    	myserver->send_message_Error(&err);
    	message_sent = true;
  }
  return result;
}
#else
inline error_flag
Stream::MPEGInterrupt(int buffer_descriptor)
{
  error_flag result = ErrorState();
  int token_freed = -1;
  
  if (result == ErrorOccurred)
  	return result;
    
  if ((buffers[0].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[0].block->buffers)&&
      (buffer_descriptor <  (((int)buffers[0].block->buffers) + (buffers[0].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
      	  	buffers[0].blocks_returned++;
      	  	
  		if (buffers[0].blocks_returned == buffers[0].block->num_buffers){	// if we have received all the blocks free it
  			
  			if ((result = mysource->freeBlock(buffers[0].block)) == ErrorOccurred )
  				err = &mysource->ReturnCopyOfError();
  
  			buffers[0].block = NULL;
  			buffers[0].in_use = free_token;
  			
  			token_freed = 0;
  		}
  }
  else         // not token 0 try token 1
  if ((buffers[1].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[1].block->buffers)&&
          (buffer_descriptor <  (((int)buffers[1].block->buffers) + (buffers[1].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
      	  	buffers[1].blocks_returned++;
      	  	
  		if (buffers[1].blocks_returned == buffers[1].block->num_buffers){	// if we have received all the blocks free it
  			if (( result = mysource->freeBlock(buffers[1].block)) == ErrorOccurred )
  				err = &mysource->ReturnCopyOfError();
  
  			buffers[1].block = NULL;
  			buffers[1].in_use = free_token;
  	
  			token_freed = 1;
  		}
   }
  	
  	
  if (token_freed != -1){
  	
	if ((!(callback_pending & callback_bufferfree))||(state == state_stop)){
  		callback_pending += callback_bufferfree;	  	
    		_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
 	}
 	
 	if (state != state_stop){
 		if (callback_pending & callback_fullblocks)
  			callback_pending -= callback_fullblocks;
  	}// !stop
  } 
  if ((result == ErrorOccurred)&&(myserver != NULL)&&(!message_sent)){
    	myserver->send_message_Error(err);
    	message_sent = true;
  }
  return result;
}
#endif

error_flag
Stream::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  if (mysource->serviceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    	err = &(mysource->ReturnCopyOfError());
    	return ErrorOccurred;
    }

  return NoError;
}

//+++++++++++++++++++++++++++++++ StreamList Methods ++++++++++++++++
StreamList::StreamList(void):List()
{
}

error_flag
StreamList::Add(Stream *str, int *id)
{
  int identifier;
  error_flag result = ErrorState();
  
  if (result != ErrorOccurred) {
  
  	identifier = str->GetSinkHandle();
  
  	while (EnsureUnique(identifier) == ErrorOccurred){
  	  RemoveErr();
  	  identifier++;
  	}
  	
	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &(str->start_time));
	str->data_at_start = stats.bytes_received;
	str->acks_at_start = stats.acks_sent;
	str->naks_at_start = stats.naks_sent + stats.block_naks_sent;
	
  
  	result = List::Add((void*)str, &identifier);
  	
  	(*id) = identifier;
  }	// if we cannot recover from this error

  return result;
}

error_flag
StreamList::identify(Stream **item, int identifier)
{
  return List::identify((void**)item, identifier);
}

StreamList::~StreamList(void)
{
  int i;
  
  ExpectedSize = 0;
  
  for (i=(CurrentSize-1); i>=0; i--){
    	delete (Stream*)object[i];			// delete from the top to the bottom
    	object[i] = NULL;
  }
  
  delete[] object; object = NULL;
  delete[] identifiers; identifiers = NULL;
  
  CurrentSize = 0;
}

error_flag
StreamList::Remove(int identifier)	// returns a boolean success value
{
  int i = 0;	// count value
  error_flag result = ErrorState();
   
 
  if (result != ErrorOccurred) {
   	if (ExpectedSize != CurrentSize){
 		MakeError(VSP_BadDelete);
  		return ErrorOccurred;
        }
        
  	--ExpectedSize;
  	
   	while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  	if (i == CurrentSize){
  		MakeError(VSP_UnknownObj);
        	result = ErrorOccurred;
  	}

	if (result != ErrorOccurred){
	  	unsigned int mt_time;
	  	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &mt_time);
	  	
	  	if (mt_time > ((Stream*)object[i])->start_time){
	  	// stream bytes received
	  		stats.last_stream_bytes_received = (ULINT)(stats.bytes_received - ((Stream*)object[i])->data_at_start);
	  		stats.last_stream_time = (ULINT)(mt_time - ((Stream*)object[i])->start_time);
	  		stats.last_stream_acks = (ULINT)(stats.acks_sent - ((Stream*)object[i])->acks_at_start);
	  		stats.last_stream_naks = (ULINT)((stats.naks_sent + stats.block_naks_sent) - ((Stream*)object[i])->naks_at_start);
	  	} // bitrate calculation

  		delete (Stream*)object[i]; 
  		object[i] = NULL;
  
  		while (i < CurrentSize -1){
    			object[i] = object[i+1];
    			identifiers[i] = identifiers[i+1];
    			i++;
  		}
  		--CurrentSize;

  		if (decreasesize() == ErrorOccurred)		// this does test for sufficient decrease in size
  			result = ErrorOccurred;
  	}
  }

  return result;
}

//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++
// the first argument is code or the out of band etc indicator.
error_flag 
StreamList::inetEvent(int code, int identifier, claim_flag *claim, void *)
{
  error_flag result = ErrorState();
  int i;
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++){
  		Stream *stream = ((Stream*)object[i]);
    		if ((stream->source_sd == identifier)&&(stream->getstate() != state_stop)) {
	       	   if (code == Socket_Broken_Event){
        	     	stream->MakeError(IP_SocketError);
        	     	err = &stream->ReturnCopyOfError();
        	     	result = ErrorOccurred;
        	   }
        	   else {
        		callback_flag callback;
        		
      			if (stream->mysource->ReadDatagrams(stream->callback_pending, &callback, stream->myserver, &stats, stream->comms_timeout) == ErrorOccurred) {
    				err = &stream->ReturnCopyOfError();
    				result = ErrorOccurred;
      			}
      			
      			if (callback & callback_timeout){	// analyse if there is any need to change the callback vector
				stream->callback_pending -= callback_timeout;
     				_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, stream->pw);	 
				
				if (stream->state != state_stop){
 		        		if (callback & callback_nak){ // initiate callback sequence
		        			_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), ((stream->comms_timeout+1)>>1), VSP_CallAfterVeneer, stream->pw);	  	
 						if (e != NULL){						// reset ticker event
  							MakeError(e);
  							result = ErrorOccurred;
 						}
 		        		}
 		        										// block timeout (timeout = block | nak)
					if (callback & callback_block) {
					
						if (result != ErrorOccurred){
 		        				_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), stream->comms_timeout, VSP_CallAfterVeneer, stream->pw);	  	
 							if (e != NULL){						// reset ticker event
  								MakeError(e);
  								result = ErrorOccurred;
 							}
 						}
					}
					if (stream->callback_pending & callback_bufferswait){
						if (stream->mysource->getFullBlocks() > stream->buffer_blocks){
							stream->callback_pending -= callback_bufferswait;
							for(int i = 0; i < NUM_MPEG_Tokens; ++i)
								result = stream->test_empty_buffers();
						}
					}
					else {
						if (stream->tokenfree())
							result = stream->test_empty_buffers();
					}
 		        	}
 		        	stream->callback_pending += callback;
      			}      			
    	 		*claim = claim_event;
    	 	   }
                } 
    		else 
    		if (((stream->server_sd) == identifier)&&(identifier != -1)) {
        	   if (code == Socket_Broken_Event){
        	     	stream->MakeError(IP_SocketError);
        	     	err = &stream->ReturnCopyOfError();
        	     	result = ErrorOccurred;
        	   }
        	   else {
     			if (stream->server_flag == free_token){
      				stream->server_flag = claim_token; 		// in use
      				if ( stream->server_inetevent() == ErrorOccurred){
    					err = &stream->ReturnCopyOfError();
    					result = ErrorOccurred;
      				}
	       			stream->server_flag = free_token; 	// not in use
        		}
        		*claim = claim_event; // claim even if in use
        	   }
    		}
        }
  }
  return result;
}

error_flag
StreamList::TimeSliceCall(void *)
{
  error_flag result = ErrorState();
  
  int i;
  
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++){
    		Stream *stream = ((Stream*)object[i]);
    		if ((stream != NULL)&&(stream->callback_pending != callback_none)){
    			if (stream->source_flag == free_token ){
      				stream->source_flag = claim_token; 		// in use
      				if (stream->timeslice(&stats) == ErrorOccurred){
    					err = &stream->ReturnCopyOfError();
    					result = ErrorOccurred;
      				}
      				if ( stream->state == state_stop) {
      		  			if ( stream->change_state(state_stop) == ErrorOccurred )
      		  	  			stream->RemoveErr();
      		  			else{
      		  				Remove(identifiers[i]);	// removeit from the list
      		  			}
      				}     		  	
      				stream->source_flag = free_token; 		// not in use
	       			
			}
			else {
	  			if (stream->state != state_stop){
#ifdef DEBUGLIB	  	  
      					Debug("timeslice making callback");
#endif      			
      					_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, stream->pw);	  	
 						if (e != NULL){
  							MakeError(e);
  							result = ErrorOccurred;
 	        		                }
 	                        }
	                }
                }// callback_pending 		
        }
  }
  return result;
}

error_flag
StreamList::MPEGInterrupt(int buffer_descriptor)
{
  int i;
  error_flag result = ErrorState();
  
  if (result !=ErrorOccurred){
  	for (i=0;((i<CurrentSize)&&(result != ErrorOccurred));i++) {
  	  
  	  	Stream *stream = (Stream*)object[i];
  	  	
    		if ( stream->MPEGInterrupt(buffer_descriptor) == ErrorOccurred ) {
    			err = &(stream->ReturnCopyOfError());
    			result = ErrorOccurred;
    		}
  	}
  }
  return result;
}

error_flag
StreamList::DummyAckPoll(void)
{
  int i;
  error_flag result = ErrorState();

  if (result != ErrorOccurred){
  	for (i=0;((i<CurrentSize)&&(result != ErrorOccurred));i++)
    		if ( ((Stream*)object[i])->DummyAckCall() ) {
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			result = ErrorOccurred;
    		}
  }
  return result;
}

error_flag
StreamList::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  int i;
  error_flag result = ErrorState();
  
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++)
  		if ( ((Stream*)object[i])->ServiceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			result = ErrorOccurred;
                }
  }
  return result;
}
