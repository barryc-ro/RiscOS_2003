/**************************************
 Stream.c
	
impliments standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Stream.h"	// Source Element
#include "swis.h"
#include "string.h"

StreamToken::StreamToken()
{
	block = NULL;
	in_use = free_token;
	blocks_returned = 0;
}

StreamToken::~StreamToken(void)
{
 	block = NULL;		// this is assigned to point to source memory space
	blocks_returned = 0;
}

error_flag
Stream::test_empty_buffers(void)
{
  error_flag result = ErrorState();
  int token_id;
  
  if ((state != state_step)||((--step_times) >= 0)){
 
  	MACRO_getFreeToken(token_id);
  
  	if ( (result != ErrorOccurred)&&(state != state_stop)&&(token_id != -1) ) {
		buffers[token_id].in_use = claim_token;	// paired with free block
	    	result = mysource->getBlock(&(buffers[token_id].block), &(buffers[token_id].mpeg_buffer), ((int)VSP_MPEGCall), ((int)pw));
 	
	 	if ((result != ErrorOccurred)&&(buffers[token_id].block != NULL)){
			buffers[token_id].blocks_returned = 0;
			result = mysink->FullBuffer(buffers[token_id].mpeg_buffer);
	        }
	 	else {
	                buffers[token_id].in_use = free_token;
	 	  	err = &mysource->ReturnCopyOfError();
	 	} // !get block error occurred
	}
  
	MACRO_getFreeToken(token_id);
  
	if (token_id != -1)
	  	callback_pending = (callback_flag)(callback_pending | callback_tokenfree);
	else
	   	callback_pending = (callback_flag)(callback_pending & ~callback_tokenfree);
  }
  
  return result;
}

Stream::Stream(int inet_timeout, int initial_block, int MPEGid, PlayList playlist, int play_num, Server *server, int NumBlocks, 
	int source_recvspace, int BufferBlocks, void *pwork, int in_from, int in_to):Error()
{
  // server specific variables
  int BlockSize;		// data size calculation
  int num_dgrams; 		// maximum number of datagrams
  ULINT dgram_size, bitrate;
  in_addr ipAddress;		// structure defined in internet library
  ULINT portnum;			// of server object, receiving
    
  // STB specific variables
  Socket server_sock, source_sock;	// these are captured as part of the internet event
  source_flag = server_flag = free_token;
  comms_timeout = inet_timeout;

  pw = pwork;
  if (in_from > 0)
  	from = in_from*2;
  else
  	from = 0;
  	
  callback_pending = callback_bufferswait;	// buffer management is in a state of waiting for buffer blocks

  error_flag result = NoError;
  
  mysink = new Sink(MPEGid);
  state = state_prestart;			// set the state of play

  buffer_blocks = BufferBlocks;	
   
  if ((result != ErrorOccurred)&&(mysink->ErrorExists())) {
   	err = &mysink->ReturnCopyOfError();
   	result = ErrorOccurred;
  }
  else{ 	
    	myserver = server;
    	myserver->set_stream_owner();
  	mysource = new SourceVOD((comms_timeout+1)>>1, source_recvspace);			// create UDP socket
 	
 	if (myserver->ErrorExists()){ 				// errors on creation of TCP
  		err = &myserver->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  	else 
  	if  (mysource->ErrorExists()&&(mysource->ErrorNum() != VSP_SourceUninit)){ // errors on creation of UDP
  		err = &mysource->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  }
  	
  if ((result != ErrorOccurred) &&		// on no error
  	   	( (mysource->getLocalPort((int*)&portnum)== ErrorOccurred)  ||	// get UDP port number for asset presentation
  	   	  (mysource->getSocket(&source_sock) == ErrorOccurred)    ) ){
  			err = &mysource->ReturnCopyOfError();
  			result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
  		((myserver->getSocket(&server_sock)) == ErrorOccurred)) {
    			err = &(myserver->ReturnCopyOfError());
    			result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
    	    	 ((source_sd = source_sock.getSocketDescriptor()) == -1) ||
    	         ((server_sd = server_sock.getSocketDescriptor()) == -1) ||
    	         (server_sock.getLocalAddress((in_addr*)&ipAddress) != 0) ){
    		      MakeError(TCP_SocketError);
    		      result = ErrorOccurred;
  }
  int fast_playback;
  
  if ((result != ErrorOccurred)&&
  		((myserver->AssetPresentation(initial_block, playlist, play_num, &endofstream,
  						 &ipAddress, &portnum, &dgram_size, &bitrate, &fast_playback)) == ErrorOccurred)) {
   			err = &myserver->ReturnCopyOfError();
   			result = ErrorOccurred;
  }
  trick_modes = implemented_trick_modes | (fast_playback >> 24);
  fast_playback_ratio = fast_playback & 0xFFFFFF;
  
  if (endofstream == 0xFFFFFFFF){	// if stream live
  	trick_modes |=  trick_jump_most_rec;
  }
  
  if ((in_from >= 0)&&(in_from < endofstream))
  	from = in_from*2;
  else
  	MakeError(VSP_InvalidValue);
  	
  if ((in_to == 0)||(in_to > from)){
  	if (((in_to << 1) < endofstream)&&(in_to != 0))
  		endofstream = (in_to << 1);
  }
  else
	MakeError(VSP_InvalidValue);
	
#ifdef DEBUGLIB
	ErrorDump();
	if (trick_modes & trick_jump_most_rec)
		Debug("Being Registered tricks %8.8X", trick_modes);
	else
		Debug("Registered Video %i to %i (secs), tricks %8.8X", from/2, endofstream/2, trick_modes);
#endif  
	  	
  bitrate = (bitrate/8);  			// bytes per 2/3 sec's	this ensures enough dgrams
  num_dgrams = (int) (bitrate / (dgram_size-sizeof(NECDatagram)));  
  BlockSize =  num_dgrams * (int)dgram_size;	// calculation on datagram size and bitrate
  if ((result != ErrorOccurred)&&
   		(mysource->Allocate(NumBlocks, BlockSize, initial_block, (size_t)dgram_size) == ErrorOccurred)){
  			err = &mysource->ReturnCopyOfError();
  			result = ErrorOccurred;

  }
  ipAddress.s_addr = ntohl(ipAddress.s_addr);		// ipaddress of server as port are set in the asset presentation
  if ((result != ErrorOccurred)&&
  	(mysource->setServerDetails(ipAddress, (int)portnum) == ErrorOccurred)) {
  		      	   err = &mysource->ReturnCopyOfError();
 	 	      	   result = ErrorOccurred;
  }

  if (result != ErrorOccurred){
 	result = myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock(), play_preparation);// send request for play
        result = change_state(state_play);	// this will make an imediate callback for trickplay.
  }
} 	// stream constructor

Stream::~Stream(void)
{
  int used_buffer = 1;		// token used by MPEG module
  
  int status = 0;		// this is a code used in the server log.
  
  source_flag = claim_token;
  
  if (myserver != NULL)
  	myserver->AssetEnd(status, (state != state_endreceived));
 
  if ((change_state(state_stop) != ErrorOccurred)||(ErrorNum() != VSP_CantDeleteSharedMemory)){
    	// this is because errors can occur including errors returned from the server not always shared memory
    	delete mysource; mysource = NULL;
  }
  else {
   	do {
    		RemoveErr();
 		mysink->DropBuffers();	
    	}
    	while (change_state(state_stop) == ErrorOccurred);
    	delete mysource; mysource = NULL;
  }

  delete mysink;   mysink = NULL;
  
  if (myserver != NULL){
  	if (myserver->interface_uses()){
    		myserver->clear_stream_owner();
  	}
  	else  {
  		delete myserver; myserver = NULL;
  	}
  }
}

error_flag
Stream::change_state(state_of_play new_state)
{ 
   error_flag result = ErrorState();
   int i;
   bool used_buffer = false;

   if ((state == state_streamlive)&&(new_state != state_streamlive)){
     	Source *tmp = mysource;
     	mysource = new SourceVOD((*tmp));
     	delete tmp;
     	callback_pending = (callback_flag) (callback_pending | callback_trickplay);
#ifdef DEBUGLIB     
        Debug("LIVE -> Stored");
   }
   	Debug("state %i -> %i", state, new_state);
#else
   }
#endif	
	   
   switch (new_state) {
     case state_slow:
     	if (trick_modes & trick_slow_play)
     		state = state_slow;
     	break;
     case state_step:
     	if (trick_modes & trick_step_play){
     		state = state_step;
     		result = test_empty_buffers();
     	}
     	break;
     case state_endreceived:
     	state = state_endreceived;
     	break;
     case state_stop:
   	if (state != state_stop){
   	  	if (callback_pending & callback_timeout){
   			callback_pending = (callback_flag)(callback_pending & ~callback_timeout);
     			_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
     		}
   		mysource->setEndPlayState();		// this ensures no more data is copied upriver.
   		state = state_stop;
        }
     	for (i=0; i < NUM_MPEG_Tokens; i++){
     		if (buffers[i].in_use != free_token) {
     			used_buffer = true;
    		}
     	}
#ifdef DEBUGLIB
     	Debug("kill stream; flags %2.2X, tokens (%i)(%i)", callback_pending, (buffers[0].in_use == claim_token), (buffers[1].in_use== claim_token));
#endif    				
     	if (used_buffer == true){
     		MakeError(VSP_CantDeleteSharedMemory);
     		result = ErrorOccurred;
     	}
   	break;
     case state_pause:
     	if ((state != state_pause)&&(trick_modes & trick_pause)) {
     		result = ReadNPT(&from);
   		from = from << 1;
     		state = state_pause;
     	}
     	break;
     case state_play:
        if ((state != state_play)&&(trick_modes & trick_normal_play)) {
          	if (state == state_step) {
          		state = state_play;
               		result = test_empty_buffers();
               	}
		else{
           		if ((state != state_pause)&&(state != state_step)&&(state != state_slow)) {
     	  			callback_pending = (callback_flag) (callback_pending | callback_trickplay);
     	  			if (state != state_prestart){
     	  				result = ReadNPT(&from);
   					from = from << 1;
   				}
   			}// if state is paused time is set at pause time, jumps reset this time
   			state = state_play;
   		}
	}
     	break;
     case state_streamlive:
     	if ((state != state_streamlive)&&(trick_modes & trick_jump_most_rec)){
#ifdef DEBUGLIB     	  
        	Debug("Stored -> LIVE");
#endif        	
     	  	Source *tmp = mysource;
     	  	mysource = new SourceLIVE((*tmp));
     	  	delete tmp;
     		callback_pending = (callback_flag) (callback_pending | callback_trickplay);
     		from = 0xFFFFFFFF;
     		state = state_streamlive;
     	}
        break;
     case state_fast_forward:
        if ((state != state_fast_forward)&&(trick_modes & trick_fast_forward)){
              	result = ReadNPT(&from);
   		from = from << 1;
         	state =  state_fast_forward;
     	  	callback_pending = (callback_flag) (callback_pending | callback_trickplay);
	}
     	break;
     case state_fast_rewind:
        if ((state != state_fast_rewind)&&(trick_modes & trick_fast_rewind)){
           	result = ReadNPT(&from);
   		from = from << 1;
     		state =  state_fast_rewind;
     	  	callback_pending = (callback_flag) (callback_pending | callback_trickplay);
	}
     	break;
   }
   
   if (callback_pending & callback_trickplay) {
  	_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 	if (e != NULL){
  		MakeError(e);
  		result = ErrorOccurred;
 	} 
   }

   return result;
}

error_flag
Stream::GetSinkHandle(void)
{
  if (mysink->GetHandle() == ErrorOccurred){
    	err = &(mysink->ReturnCopyOfError());
  	return ErrorOccurred;
  }
  else
  	return NoError;
}

error_flag 
Stream::CheckEOS(int *play_state)			// call to Decoder
{
  if ((state == state_stop)||(state == state_endreceived)){
  	(*play_state) = 1;
  }
  else
  	(*play_state) = 0;
  
  return ErrorState();
}

error_flag
Stream::SetSpeed(int direction, int speed)		// call to Decoder
{
  
#ifdef DEBUGLIB
  unsigned int NPT_time;
  ReadNPT(&NPT_time);
  Debug("set speed R0(%i), R2(%i) NPT = %i", direction, speed, NPT_time);
#endif
 if (direction == 2){
 	step_times = speed;
 	change_state(state_step);
 }
 else 
 switch(speed) {
    case 0:
    	if (speed == 0)
    		change_state(state_pause);
    	else
  		MakeError(VSP_Unimplemented);
    	break;
    case 1:
    	if (direction == 1)
    		change_state(state_fast_forward);
    	else
    		change_state(state_play);
    	break;
    case -1:
     	if (direction == 1)
    		change_state(state_fast_rewind);
    	break;
    default:
    	if (direction == 0)
    		change_state(state_slow);
	else    		
  		MakeError(VSP_Unimplemented);
 }
 return ErrorState();
}

error_flag
Stream::SetPosition(int flags, int pos_time)	 // call to Decoder
{
  error_flag result = NoError;
  unsigned int NPT_time = (unsigned int)mysource->get_most_significant_time();
  unsigned int abs_time;//, playback_id, AckNum;
  //size_t freebuf;
 if (flags == 1){
     abs_time = NPT_time + (pos_time * 2);
  }
  else
  if (flags == 2){
    abs_time = NPT_time - (pos_time * 2);
  }
  else {
     if ((pos_time < 0)&&(endofstream == 0xFFFFFFFF))
     	abs_time = 0xFFFFFFFF;
     else
     	abs_time = (pos_time << 1);
  }
  
#ifdef DEBUGLIB
  Debug("jump play R0(%i), R2(%i) abs_time %i, endofstream %i", flags, pos_time, abs_time, endofstream);
#endif  

  if (((abs_time & 0x80000000)&&(endofstream != 0xFFFFFFFF))||(abs_time > endofstream)){
  	MakeError(VSP_InvalidValue);
  	result = ErrorOccurred;
  }
  else {
  	from = abs_time;
  
  	if (abs_time == 0xFFFFFFFF)
  		change_state(state_streamlive);
  	else {
  		callback_pending = (callback_flag) (callback_pending | callback_trickplay);
  		_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
  		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
  		} 
  	}
  }
  return result;
}

error_flag
Stream::ReadNPT(unsigned int *NPT_time)			// call to Decoder
{
  if ((state == state_fast_forward)||(state == state_fast_rewind))
    	(*NPT_time) = ((mysource->get_most_significant_time()*fast_playback_ratio) >> 1);
  else
  	(*NPT_time) = (mysource->get_most_significant_time() >> 1); // div 2
  return NoError;
}

error_flag
Stream::GetMiscInfo(int *reg_r0, misc_5_10 *ptr, int *size)
{
  int flags = (*reg_r0);
  switch (flags) {
    case 0:
    	if ((ptr == NULL)||(size == 0))
    		(*size) = sizeof(misc_5_10);
    	else {
    	  	if ( (*size) < sizeof(misc_5_10) )
    	  		MakeError(VSP_InvalidValue);
    	  	else {
    	  	  	if (mysource->getMiscInfo(type_misc_5_10, ptr) == ErrorOccurred)
    	  	  		err = &(mysource->ReturnCopyOfError());
	  	}
    	}
    	break;
    case 1:
    	(*reg_r0) = trick_modes;
    	break;
    case 2:
    	if (state > state_still)
    		(*reg_r0) = state_play;
    	else
    		(*reg_r0) = state;
    	break;
#ifdef DEBUGLIB    	
    default:
    	if (ErrorExists()){
    	  	Debug("stream error exists");
		ErrorDump();
    	}
    	else
    	if (myserver->ErrorExists()){
    	  	Debug("server error");
    	}
    	else {
   	Debug("stream (%i)- cb %2.2X, t[0] (%i), t[1] = (%i)", 
    				mysource->getFullBlocks(), callback_pending, 
    				(buffers[0].in_use == claim_token), (buffers[1].in_use== claim_token));
    	mysource->getMiscInfo(type_debug, NULL);
    	}
#endif    	
  }
  return ErrorState();
}

int
Stream::getBlockVal(void)
{
  int block;
  
  if ((block = mysource->getFinalBlock()) == 0)
    block = mysource->get_most_significant_block();
  
  return block;
}
  
//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++

error_flag
Stream::timeslice(Statistics *stats)
{
  error_flag result = NoError;
  callback_flag flags = callback_pending;
  //Debug("ts %2.2X", callback_pending);
  if (state == state_stop) return result;
  
  	if (callback_pending & callback_bufferfree){

  		result = mysource->calculate_freeBlocks(myserver, callback_pending, stats);
  		if (result == ErrorOccurred)
  			err = &(mysource->ReturnCopyOfError());

  		callback_pending = (callback_flag)(callback_pending & ~callback_bufferfree);
  			
  		if (callback_pending & callback_tokenfree)
  			result = test_empty_buffers();
  			
  		if (!(callback_pending & callback_timeout)){
                       	// this reinitialises the block callback vector if we fill up the blocks
  			callback_pending = (callback_flag)(callback_pending | callback_block);
			_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), comms_timeout, VSP_CallAfterVeneer, pw);	  	
 			if (e != NULL){
  				MakeError(e);
  				result = ErrorOccurred;
 			}  
 		} 
  	}
  	else {
		if (callback_pending & callback_trickplay){
		  
        		int playback_id, RequestNum, AckNum, play_mode = 0;
        	
        		callback_pending = (callback_flag)(callback_pending & ~callback_trickplay);
       			
       			switch (state){
        			case state_fast_forward:
        	  			play_mode = 3;
        	  			break;
        	  		case state_fast_rewind:
        	  			play_mode = 4;
        	  			break;
        	  		case state_streamlive:
        	  		  	callback_pending = (callback_flag)(callback_pending & callback_bufferswait);
        	  			play_mode = 7;
        	  			break;
        	  		//default 0;
        		}
        	
        		mysource->clearFinalBlock();	// ignore any previous end block numbs
   	 		result = mysource->setNewPlayState(&playback_id, &RequestNum, &AckNum, play_mode);
   			if (result != ErrorOccurred){
   			  
   			  	if (callback_pending & callback_timeout){
   			  		callback_pending = (callback_flag)(callback_pending & ~callback_timeout);
     					_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
     				}	 
#ifdef DEBUGLIB
				Debug("request for play from %8.8X, block %i, mode %i", from, AckNum, play_mode);
#endif
     	 			result = myserver->send_playback_request(playback_id, RequestNum, AckNum, from, play_mode);
     	 			if (result == ErrorOccurred){
     	 			  	if (myserver->ErrorNum() == TCP_NoBuffer){
     	 			  	  	myserver->RemoveErr();
     	 			  	  	result = NoError;
     	 			 	  	callback_pending = (callback_flag)(callback_pending | callback_trickplay);
     	 			 	  	_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), (comms_timeout), VSP_CallAfterVeneer, pw);	  	
 						if (e != NULL){
  							MakeError(e);
  							result = ErrorOccurred;
 						}
     	 			 	}
     	 			 	else  	
     	 					err = &(myserver->ReturnCopyOfError());
     	 			}
     	 			else{
     	 			  	if ((result != ErrorOccurred)&&(state != state_streamlive)){
     	 					callback_pending = (callback_flag)(callback_pending | callback_block);
                				_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), (comms_timeout), VSP_CallAfterVeneer, pw);	  	
 						if (e != NULL){
  							MakeError(e);
  							result = ErrorOccurred;
 						}
 					}
 				}
                	}
                	else
                		err = &(mysource->ReturnCopyOfError());
                }
 		else {
 		  	if (state != state_streamlive) {
				if (mysource->foregroundExecute(&callback_pending, myserver, stats) == ErrorOccurred){
  					err = &mysource->ReturnCopyOfError();
  					result =  ErrorOccurred;
  				}
  				
  				if (callback_pending & callback_nak){
                			callback_pending = (callback_flag)(callback_pending | callback_nak);
     					_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), ((comms_timeout+1)>>1), VSP_CallAfterVeneer, pw);	  	
 					if (e != NULL){
  						MakeError(e);
  						result = ErrorOccurred;
 					} 
 				}
 			}
  		}
  	}
  	// calculate if the mpeg player has tokens if so use them as timeout values
  	// also calculate if we own all the tokens then we are starting the stream
  	// wait for more than buffer blocks

#ifdef DEBUGLIB    	  
  if (result == ErrorOccurred) {
    	Debug("stream error");
    	ErrorDump();
    	mysource->getMiscInfo(type_debug, NULL);
  }
#endif    	
  return result;
}

error_flag
Stream::server_inetevent(void)
{
  int event = 0;
  ULINT comms_result;
  //error_flag result;
  
  if ( myserver->inetevent(&event, &comms_result) == ErrorOccurred) {
  	err = &myserver->ReturnCopyOfError();
  	return ErrorOccurred;
  }
#ifdef DEBUGLIB  
  if (comms_result != 0)
  	Debug("non-zero result form TCP event 0x%2.2X, result = %i\n", event, comms_result);

  if (event == COMMAND_playback_response)
  	Debug("+ + play response %i + +", comms_result);	
#endif  	
 /*
  if (event == COMMAND_startend_notification) {
  	if (state == state_play){
    		// if already playing
#ifdef DEBUGLIB
		Debug("setting final block %i", comms_result);
#endif			
    		mysource->setFinalBlock(comms_result);
    		change_state(state_endreceived);
    	}
  }
  */
  return NoError;//result;
}

error_flag
Stream::DummyAckCall(void)
{
 if (state != state_stop) {
   if (myserver->comms_flag != comms)	// defined in the server class
 	if (myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock(), dummy_ack) == ErrorOccurred){
 		err = &(myserver->ReturnCopyOfError());
 		return ErrorOccurred;
 	}
 	myserver->comms_flag = no_comms;
 }
 return NoError;
}

#ifdef OUTPUT_FILE
error_flag
Stream::MPEGInterrupt(int)
{
  error_flag result = ErrorState();
  
  for (int i = 0; i < NUM_MPEG_Tokens; i++)
  	if (buffers[i].block != NULL){
  		result = MPEGBufferListToNECBlock(&buffers[i]);	
  	}
  return result;
}
#else
#if (NUM_MPEG_Tokens != 2)
#error Re-defining the number of MPEG tokens; be aware of speed ups used.

error_flag
Stream::MPEGInterrupt(int buffer_descriptor)
{
  int i;	// this runs under interrupt avoid changing other peoples variables
  error_flag result = ErrorState();
  
  i = 0;
  while (i < NUM_MPEG_Tokens) {	// remember if num_blocks is zero we cannot touch it.
    	if ((buffers[i].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[i].block->buffers)&&
      	    (buffer_descriptor <  (((int)buffers[i].block->buffers) + (buffers[i].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
      	  	buffers[i].blocks_returned++;
      	  	break; 	//claim
        }
        i++;
  }//while search buffers
 
  if ((i < NUM_MPEG_Tokens)&&(buffers[i].blocks_returned == buffers[i].block->num_buffers)){	// if we have received all the blocks free it
  	if ( (result != ErrorOccurred)&&(( result = mysource->freeBlock(buffers[i].block)) == ErrorOccurred) )
  		err = &mysource->ReturnCopyOfError();
  
  	buffers[i].block = NULL;
  	buffers[i].in_use = free_token;
  	
	if ((!(callback_pending & callback_bufferfree))||(state == state_stop)){
  		callback_pending = (callback_flag)(callback_pending | callback_bufferfree);	  	
    		_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
 	}
 	
 	if (state != state_stop){
 		if (callback_pending & callback_fullblocks)
  			callback_pending = (callback_flag)(callback_pending & ~callback_fullblocks);
  			
  		callback_pending = (callback_flag)(callback_pending | callback_tokenfree);
  	}// !stop
 }

  return result;
}
#endif
error_flag
Stream::MPEGInterrupt(int buffer_descriptor)
{
  error_flag result = ErrorState();
  int token_freed = -1;
  
  if (result == ErrorOccurred)
  	return result;
  
  //NUM_MPEG_Tokens defined as 2 else error
  if ((buffers[0].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[0].block->buffers)&&
      (buffer_descriptor <  (((int)buffers[0].block->buffers) + (buffers[0].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
      	  	buffers[0].blocks_returned++;
      	  	
  		if (buffers[0].blocks_returned == buffers[0].block->num_buffers){	// if we have received all the blocks free it
  			
  			if ((result = mysource->freeBlock(buffers[0].block)) == ErrorOccurred )
  				err = &mysource->ReturnCopyOfError();
  
  			buffers[0].block = NULL;
  			buffers[0].in_use = free_token;
  			
  			token_freed = 0;
  			callback_pending = (callback_flag)(callback_pending & callback_tokenfree);
  		}
  }
  else         // not token 0 try token 1
  {
  if ((buffers[1].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[1].block->buffers)&&
      (buffer_descriptor <  (((int)buffers[1].block->buffers) + (buffers[1].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
      	  	buffers[1].blocks_returned++;
      	  	
  		if (buffers[1].blocks_returned == buffers[1].block->num_buffers){	// if we have received all the blocks free it
  			if (( result = mysource->freeBlock(buffers[1].block)) == ErrorOccurred )
  				err = &mysource->ReturnCopyOfError();
  
  			buffers[1].block = NULL;
  			buffers[1].in_use = free_token;
  	
  			token_freed = 1;
  			callback_pending = (callback_flag)(callback_pending & callback_tokenfree);
  		}
      }
  }
  	
  	
  if (token_freed != -1){
  	
	if ((!(callback_pending & callback_bufferfree))||(state == state_stop)){
  		callback_pending = (callback_flag)(callback_pending | callback_bufferfree);	  	
    		_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
 	}
 	
 	if (state != state_stop){
 		if (callback_pending & callback_fullblocks)
  			callback_pending = (callback_flag)(callback_pending & ~callback_fullblocks);
  			
  		callback_pending = (callback_flag)(callback_pending | callback_tokenfree);
  	}// !stop
  } 

  return result;
}
#endif

error_flag
Stream::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  if (mysource->serviceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    	err = &(mysource->ReturnCopyOfError());
    	return ErrorOccurred;
    }
  return NoError;
}

//+++++++++++++++++++++++++++++++ StreamList Methods ++++++++++++++++
StreamList::StreamList(void):List()
{
}

error_flag
StreamList::Add(Stream *str, int *id)
{
  int identifier;
  error_flag result = ErrorState();
  
  if (result != ErrorOccurred) {
  
  	identifier = str->GetSinkHandle();
  
  	while (EnsureUnique(identifier) == ErrorOccurred){
  	  RemoveErr();
  	  identifier++;
  	}
  	
	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &(str->start_time));
	str->data_at_start = stats.bytes_received;
	str->acks_at_start = stats.acks_sent;
	str->naks_at_start = stats.naks_sent + stats.block_naks_sent;
	
  
  	result = List::Add((void*)str, &identifier);
  	
  	(*id) = identifier;
  }	// if we cannot recover from this error

  return result;
}

error_flag
StreamList::identify(Stream **item, int identifier)
{
  return List::identify((void**)item, identifier);
}

StreamList::~StreamList(void)
{
  int i;
  
  ExpectedSize = 0;
  
  for (i=(CurrentSize-1); i>=0; i--){
    	delete (Stream*)object[i];			// delete from the top to the bottom
    	object[i] = NULL;
  }
  
  delete[] object; object = NULL;
  delete[] identifiers; identifiers = NULL;
  
  CurrentSize = 0;
}

error_flag
StreamList::Remove(int identifier)	// returns a boolean success value
{
  int i = 0;	// count value
  error_flag result = ErrorState();
   
 
  if (result != ErrorOccurred) {
   	if (ExpectedSize != CurrentSize){
 		MakeError(VSP_BadDelete);
  		return ErrorOccurred;
        }
        
  	--ExpectedSize;
  	
   	while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  	if (i == CurrentSize){
  		MakeError(VSP_UnknownObj);
        	result = ErrorOccurred;
  	}

	if (result != ErrorOccurred){
	  	unsigned int mt_time;
	  	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &mt_time);
	  	
	  	if (mt_time > ((Stream*)object[i])->start_time){
	  	// stream bytes received
	  		stats.last_stream_bytes_received = stats.bytes_received - ((Stream*)object[i])->data_at_start;
	  		stats.last_stream_time = (mt_time - ((Stream*)object[i])->start_time);
	  		stats.last_stream_acks = stats.acks_sent - ((Stream*)object[i])->acks_at_start;
	  		stats.last_stream_naks = (stats.naks_sent + stats.block_naks_sent) - ((Stream*)object[i])->naks_at_start;
	  	} // bitrate calculation

  		delete (Stream*)object[i]; 
  		object[i] = NULL;
  
  		while (i < CurrentSize -1){
    			object[i] = object[i+1];
    			identifiers[i] = identifiers[i+1];
    			i++;
  		}
  		--CurrentSize;

  		if (decreasesize() == ErrorOccurred)		// this does test for sufficient decrease in size
  			result = ErrorOccurred;
  	}
  }
  return result;
}

//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++
// the first argument is code or the out of band etc indicator.
error_flag 
StreamList::inetEvent(int code, int identifier, claim_flag *claim, void *)
{
  error_flag result = ErrorState();
  int i;
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++){
  		Stream *stream = ((Stream*)object[i]);
    		if ((stream->source_sd == identifier)&&(stream->getstate() != state_stop)) {
	       	   if (code == Socket_Broken_Event){
        	     	stream->MakeError(TCP_SocketError);
        	     	err = &stream->ReturnCopyOfError();
        	     	result = ErrorOccurred;
        	   }
        	   else {
        		callback_flag callback = callback_none;
        		
      			if (stream->mysource->ReadDatagrams(stream->callback_pending, &callback, stream->myserver, &stats, stream->comms_timeout) == ErrorOccurred) {
    				err = &stream->ReturnCopyOfError();
    				result = ErrorOccurred;
      			}
      			
      			if (callback & callback_timeout){	// analyse if there is any need to change the callback vector
				stream->callback_pending = (callback_flag)(stream->callback_pending & ~callback_timeout);
     				_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, stream->pw);	 
				
				if (stream->state != state_stop){
 		        		if (callback & callback_nak){ // initiate callback sequence
		        			_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), ((stream->comms_timeout+1)>>1), VSP_CallAfterVeneer, stream->pw);	  	
 						if (e != NULL){						// reset ticker event
  							MakeError(e);
  							result = ErrorOccurred;
 						}
 		        		}
 		        										// block timeout (timeout = block | nak)
					if (callback & callback_block) {
					
						if (result != ErrorOccurred){
 		        				_kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), stream->comms_timeout, VSP_CallAfterVeneer, stream->pw);	  	
 							if (e != NULL){						// reset ticker event
  								MakeError(e);
  								result = ErrorOccurred;
 							}
 						}
					}
					if ((stream->callback_pending & callback_bufferswait)&&(stream->mysource->getFullBlocks() > stream->buffer_blocks))
						stream->callback_pending = (callback_flag)((stream->callback_pending & ~callback_bufferswait) | callback_tokenfree);
						
					if (stream->callback_pending & callback_tokenfree)
						result = stream->test_empty_buffers();
 		        	}
				
 		        	stream->callback_pending = (callback_flag)(stream->callback_pending | callback);
      			}
      			
				
    	 		*claim = claim_event;
    	 	   }
                } 
    		else 
    		if ((stream->server_sd) == identifier) {
        	   if (code == Socket_Broken_Event){
        	     	stream->MakeError(TCP_SocketError);
        	     	err = &stream->ReturnCopyOfError();
        	     	result = ErrorOccurred;
        	   }
        	   else {
     			if (stream->server_flag == free_token){
      				stream->server_flag = claim_token; 		// in use
      				if ( stream->server_inetevent() == ErrorOccurred){
    					err = &stream->ReturnCopyOfError();
    					result = ErrorOccurred;
      				}
	       			stream->server_flag = free_token; 	// not in use
        		}
        		*claim = claim_event; // claim even if in use
        	   }
    		}
        }

  }
  return result;
}

error_flag
StreamList::TimeSliceCall(void *)
{
  error_flag result = ErrorState();
  
  int i;
  
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++){
    		Stream *stream = ((Stream*)object[i]);
    		if ((stream != NULL)&&(stream->callback_pending)){
    			if (stream->source_flag == free_token ){
      				stream->source_flag = claim_token; 		// in use
      				if (stream->timeslice(&stats) == ErrorOccurred){
    					err = &stream->ReturnCopyOfError();
    					result = ErrorOccurred;
      				}
      				if ( stream->state == state_stop) {
      		  			if ( stream->change_state(state_stop) == ErrorOccurred )
      		  	  			stream->RemoveErr();
      		  			else{
      		  				Remove(identifiers[i]);	// removeit from the list
      		  			}
      				}     		  	
      				stream->source_flag = free_token; 		// not in use
	       			
			}
			else {
	  			if (stream->state != state_stop){
#ifdef DEBUGLIB	  	  
      					Debug("timeslice making callback");
#endif      			
      					_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, stream->pw);	  	
 						if (e != NULL){
  							MakeError(e);
  							result = ErrorOccurred;
 	        		                }
 	                        }
	                }
                }// callback_pending 		
        }
  }
  return result;
}

error_flag
StreamList::MPEGInterrupt(int buffer_descriptor)
{
  int i;
  error_flag result = ErrorState();
  
  if (result !=ErrorOccurred){
  	for (i=0;((i<CurrentSize)&&(result != ErrorOccurred));i++) {
  	  
  	  	Stream *stream = (Stream*)object[i];
  	  	
    		if ( stream->MPEGInterrupt(buffer_descriptor) == ErrorOccurred ) {
    			err = &(stream->ReturnCopyOfError());
    			result = ErrorOccurred;
    		}
  	}
  }
  return result;
}

error_flag
StreamList::DummyAckPoll(void)
{
  int i;
  error_flag result = ErrorState();

  if (result != ErrorOccurred){
  	for (i=0;((i<CurrentSize)&&(result != ErrorOccurred));i++)
    		if ( ((Stream*)object[i])->DummyAckCall() ) {
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			result = ErrorOccurred;
    		}
  }
  return result;
}

error_flag
StreamList::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  int i;
  error_flag result = ErrorState();
  
  if (result != ErrorOccurred){
  	for (i=0;i<CurrentSize;i++)
  		if ( ((Stream*)object[i])->ServiceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			result = ErrorOccurred;
                }
  }
  return result;
}
