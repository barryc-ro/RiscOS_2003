/**************************************
 Stream.c
	
impliments standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Stream.h"	// Source Element
#include "swis.h"
#include "string.h"

StreamToken::StreamToken()
{
  	list = NULL;
	block = NULL;
	block_header = NULL;
	in_use = 0;
	list_size = 0;
	num_blocks = blocks_returned = 0;
}

StreamToken::~StreamToken(void)
{
  	delete[] list;
	list_size = 0;
	list = NULL;
  	block = NULL;		// this is assigned to point to source memory space
  	block_header = NULL;
	num_blocks = blocks_returned = 0;
}

int
StreamToken::AllocList(int max_datagrams)
{
 int result = NoError;
 
  	list = new Bitstream_buffer_descriptor[max_datagrams];
  	 		
  	list_size = max_datagrams -1;
  	
 	if (list == NULL){
  	  	MakeError(VSP_Alloc);
  		result = ErrorOccurred;
  	}

  return result;
}

int
Stream::MPEGBufferListToNECBlock(StreamToken *buffer)
{
  // this is operated under interupt so it is important that no shared memory is used
  // to this ends. nothing should touch a StreamToken if in_use != 0 and not
  // try to use read its memory it is owned by the MPEG module.
  
  // THIS METHOD RETURNS A TOKEN FROM THE MPEG PLAYER
  
  int result = !ErrorExists();
 
  if ((buffer->block == NULL)||(buffer->list == NULL)){
    MakeError(VSP_BadErr);
    return ErrorOccurred;
  }
  
#ifdef DEBUG  
  //Debug("_%i__free block\n", ntohl(buffer->block_header->block_number)+19);
#endif
  
  if ((result != ErrorOccurred)&&(( result = mysource->freeBlock(buffer->block)) == ErrorOccurred))
  	err = &mysource->ReturnCopyOfError();

  if ((result != ErrorOccurred)&&(callback_pending == 0)){    	
  	_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
 		else
 			callback_pending = 1;
  }
  
  buffer->block = NULL;
  buffer->block_header = NULL;
  buffer->blocks_returned = 0;
  buffer->num_blocks = 0;
  buffer->in_use = 0;
 
  return result;
}

  // THIS METHOD PREPARES A TOKEN FOR THE MPEG PLAYER, 
  
  // these two methods are the gateway; nothing should touch
  // the buffer or the token until the above method is called.
  
int
Stream::NECBlockToMPEGBufferList(StreamToken *buffer)
{
  int i = 0, j = 0;
  size_t remaining_header;	// this is the amount left to read into the header.
  int result = !ErrorExists();
  
  if ((result != ErrorOccurred)&&
      ((buffer->block == NULL)||(buffer->block->iov_size == 0))||(buffer->block->iov_size > buffer->list_size)) {
    MakeError(VSP_BadBlock);	// test if the block looks dodgy.
    result = ErrorOccurred;
    }
  					// is out list still there
  if ((result != ErrorOccurred)&&(buffer->list == NULL)){
    MakeError(VSP_Alloc);
    result =  ErrorOccurred;
  }
  
  if (result != ErrorOccurred) { 	
	if (buffer->block->iov[i].iov_len > sizeof(NECBlockHeader))
		buffer->block_header = (NECBlockHeader*)buffer->block->iov[0].iov_base;
	else {
		MakeError(VSP_DatagramSizeError);
		result = ErrorOccurred;
	}
  }	
	
  if (result !=ErrorOccurred) {
  	if (buffer->block_header->status_word & 0x10){	// if GOP exists
 		remaining_header = (int)buffer->block_header->GOP_start_offset;	
 							// calculate the offset to the data	
 		while( (result != ErrorOccurred)&&(remaining_header >= buffer->block->iov[i].iov_len)){
    			remaining_header -= buffer->block->iov[i].iov_len;
    			i++;
    			if ((int)buffer->block->iov[i].iov_base == NULL){
    				MakeError(VSP_BadBlock);
    				result =  ErrorOccurred;
                	}
        	}
        }
	else
		remaining_header = sizeof(NECBlockHeader);	// must be within one dgram else error
  }//no error
  	// the only way to ensure it is valid memory is to copy it to valid memory
        memcpy((void*)&most_significant_block, (void*)buffer->block_header, sizeof(NECBlockHeader));

#ifdef DEBUG  
  	//Debug("read block__%i_ free %i", ntohl(buffer->block_header->block_number)+19, source_full_blocks);
#endif
  if (result != ErrorOccurred) {
  	buffer->list[j].free_routine = (int)VSP_MPEGCall;
  	buffer->list[j].free_workspace = (int)pw;
  	buffer->list[j].buffer_start_address = buffer->block->iov[i].iov_base + remaining_header;
  	buffer->list[j].buffer_length =  buffer->block->iov[i].iov_len - remaining_header;
  	buffer->list[j].packets = 0;
  
  	j++; i++;
  	while (i < buffer->block->iov_size){	// count the remainding NEC buffers
    		if ((int)buffer->block->iov[i].iov_base != NULL)
    		{
  			buffer->list[j-1].link = &buffer->list[j]; // last buffer equals this one.
    			buffer->list[j].free_routine = (int)VSP_MPEGCall;
    			buffer->list[j].free_workspace = (int)pw;
  			buffer->list[j].buffer_start_address = buffer->block->iov[i].iov_base;
  			buffer->list[j].buffer_length =  buffer->block->iov[i].iov_len;
  			buffer->list[j].packets = 0;
  			j++;
    		}
    		i++;
  	}
  	buffer->list[j-1].link = NULL; // last buffer equals this one.
  	
  }// error 
  buffer->blocks_returned = 0;
  
#ifdef OUTPUT_FILE
  buffer->num_blocks = 1;
#else
  buffer->num_blocks = j;
#endif

  if (buffer->num_blocks == 0) {
  	MakeError(VSP_BadBlock);
  	result = ErrorOccurred;
  }
  else 
  if ((result != ErrorOccurred)&&(state != state_stop)){
	result = mysink->FullBuffer(buffer->list);
  }
  return result;
}

int
Stream::test_empty_buffers(void)
{
  int i, result;
  
  result = !ErrorExists();
  for (i = 0; (i<NUM_MPEG_Tokens); i++){
  	if (result != ErrorOccurred) {
    	  	if (buffers[i].in_use == 0){
    	  	  	
    	  	  	buffers[i].in_use = 1;	// paired with free block
    	  	  	
    	  	  	result = mysource->getBlock(&(buffers[i].block));
 	  		if (result == ErrorOccurred){
 	  		  	err = &mysource->ReturnCopyOfError();
 	  		}
 	  		else {
 	  	     	  	if (buffers[i].block == NULL){
 	  	     	  	  	buffers[i].in_use = 0;
 	  	     	  	}
 	  	     	  	else {
					result = NECBlockToMPEGBufferList(&buffers[i]);
 	  	     	  		  	     	  	
 	  	     	  		if ((result == ErrorOccurred)&&(ErrorNum() == VSP_BadBlock)){
 	  	     	  			RemoveErr();
 	  	     	  		}	
 	  	     	  	} // != null
                        } // !get block error occurred
 	        }// not in use
 	}
  }
  
  if (most_significant_block.block_number == mysource->getFinalBlock()){
    change_state(state_stop);	// this will return a deleting shared memory error
    RemoveErr();
  }
  	
  return result;
}


Stream::Stream(int MPEGid, PlayList playlist, int play_num, Server *server, int NumBlocks, int BufferBlocks, void *pwork):Error()
{
  // server specific variables
  int BlockSize;		// data size calculation
  int num_dgrams; 		// maximum number of datagrams
  int initial_block = 20;
  ULINT dgram_size, bitrate;
  in_addr ipAddress;		// structure defined in internet library
  ULINT portnum;			// of server object, receiving
    
  // STB specific variables
  Socket server_sock, source_sock;	// these are captured as part of the internet event
  source_flag = server_flag = !STREAM_inet_inuse;
  
  pw = pwork;
  callback_pending = 0;

  int result = NoError;
  
  mysink = new Sink(MPEGid);
  change_state(state_pause);		// set the state of play

  full_blocks = BufferBlocks;	
   
  if ((result != ErrorOccurred)&&(mysink->ErrorExists())) {
   	err = &mysink->ReturnCopyOfError();
   	result = ErrorOccurred;
  }
  else{ 	
    	myserver = new Server(server);				// create TCP link
  	mysource = new Source(NumBlocks);			// create UDP socket
 	
 	if (myserver->ErrorExists()){ 				// errors on creation of TCP
  		err = &myserver->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  	else 
  	if  (mysource->ErrorExists()&&(mysource->ErrorNum() != VSP_SourceUninit)){ // errors on creation of UDP
  		err = &mysource->ReturnCopyOfError();
  		result = ErrorOccurred;
  	}
  }
  	
  if ((result != ErrorOccurred) &&		// on no error
  	   	( (mysource->getLocalPort((int*)&portnum)== ErrorOccurred)  ||	// get UDP port number for asset presentation
  	   	  (mysource->getSocket(&source_sock) == ErrorOccurred)    ) ){
  			err = &mysource->ReturnCopyOfError();
  			result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
  		((myserver->getSocket(&server_sock)) == ErrorOccurred)) {
    			err = &(myserver->ReturnCopyOfError());
    			result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
    	    	 ((source_sd = source_sock.getSocketDescriptor()) == -1) ||
    	         ((server_sd = server_sock.getSocketDescriptor()) == -1) ||
    	         (server_sock.getLocalAddress((in_addr*)&ipAddress) != 0) ){
    		      MakeError(TCP_SocketError);
    		      result = ErrorOccurred;
  }
  
  if ((result != ErrorOccurred)&&
  		((myserver->AssetPresentation(initial_block, playlist, play_num,
  						 &ipAddress, &portnum, &dgram_size, &bitrate)) == ErrorOccurred)) {
   			err = &myserver->ReturnCopyOfError();
   			result = ErrorOccurred;
  }
  
  bitrate = (bitrate/8);  			// bytes per 2/3 sec's	this ensures enough dgrams
  num_dgrams = (int) (bitrate / (dgram_size-sizeof(NECDatagram)));  
  BlockSize =  num_dgrams * (int)dgram_size;		// calculation on datagram size and bitrate
 
  if (result != ErrorOccurred){
    for (int i=0; i < NUM_MPEG_Tokens; i++){
    	if (buffers[i].AllocList(num_dgrams) == ErrorOccurred) {
    	  	MakeError(VSP_Alloc);
    	  	result = ErrorOccurred;
    	}
    }
  }
  
  if ((result != ErrorOccurred)&&
   		(mysource->Allocate(BlockSize, initial_block, (size_t)dgram_size) == ErrorOccurred)){
  			err = &mysource->ReturnCopyOfError();
  			result = ErrorOccurred;

  }
  	
  ipAddress.s_addr = ntohl(ipAddress.s_addr);		// ipaddress of server as port are set in the asset presentation
  if ((result != ErrorOccurred)&&
  		(mysource->setServerDetails(ipAddress, (int)portnum) == ErrorOccurred)) {
  		      	   err = &mysource->ReturnCopyOfError();
 	 	      	   result = ErrorOccurred;
  }

  if (result != ErrorOccurred){
 	result = myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock(), PlayPreparation);// send request for play
  }
  
} 	// stream constructor

Stream::~Stream(void)
{
  int i;
  
  source_flag = STREAM_inet_inuse;
  
  if (myserver != NULL)
  	myserver->AssetEnd(0,(state == state_stop));
  	
  if (change_state(state_stop) != ErrorOccurred){
    	delete mysource; mysource = NULL;
  }
#ifdef DEBUG
  else	// better to have floating memory than freeing somebody elses
  	// either way it is as ugly as a bucket of sick.
	Debug("attemt to delete shared memory");    
#endif	
  	
  delete mysink;   mysink = NULL;
  delete myserver; myserver = NULL;

  for (i=0;i<NUM_MPEG_Tokens;i++) {
  	delete[] (buffers[i].list);	// allocated in block  	
  	buffers[i].list = NULL;
  }

  delete[] buffers;
}

int
Stream::change_state(state_of_play new_state)
{ 
   int result = !ErrorExists();
   int i;

#ifdef DEBUG
	//Debug("^state = %i", new_state);
#endif	
	   
   switch (new_state) {
     case state_stop:
   	state = state_stop;
     	for (i=0; i < NUM_MPEG_Tokens; i++){
     		if (buffers[i].in_use == 1) {
     			MakeError(VSP_CantDeleteSharedMemory);
     			result = ErrorOccurred;
     			break;
     		}
     	}
   	break;
     case state_pause:
     	if ((state != state_pause)&&(mysink->SetSpeed(0) == ErrorOccurred))
     		result = ErrorOccurred;
     	state = state_pause;
     	break;
     case state_play:
     	if ((state != state_play)&&(mysink->SetSpeed(1) == ErrorOccurred))
     		result = ErrorOccurred;
     	state = state_play;
     	break;
   }
   return result;
}

int
Stream::GetSinkHandle(void)
{
  return mysink->GetHandle();
}

int 
Stream::CheckEOS(int *play_state)			// call to Decoder
{
  if (state == state_stop)
  	(*play_state) = 1;
  else
  	(*play_state) = 0;
  
  return !ErrorExists();
}

int
Stream::SetSpeed(int direction, int speed)		// call to Decoder
{
  speed = speed;
  direction = direction;
  switch(speed) {
    case 0:
    	change_state(state_pause);
    	break;
    case 1:
    	change_state(state_play);
    	break;
    default:
  	MakeError(VSP_Unimplemented);
  }
  return !ErrorExists();
}

int
Stream::SetPosition(int flags, int pos_time)	 // call to Decoder
{
  flags = flags;
  pos_time = pos_time;
  
  
  MakeError(VSP_Unimplemented);
  return ErrorOccurred;
}

int
Stream::ReadNPT(int *time)			// call to Decoder
{
  time = time;
  return 1;
}

int
Stream::GetMiscInfo(int *reg_r0, misc_5_10 *ptr, int size)
{
  int flags = (*reg_r0);
  
  switch (flags) {
    case 0:
    	if (size<sizeof(misc_5_10))
    		MakeError(VSP_InvalidValue);
    	else {
    	  	ptr->h_pixels = most_significant_block.image_width;
  		ptr->v_pixels = most_significant_block.image_height;
	 	ptr->play_time = most_significant_block.playback_time;
 	 	ptr->status_word = most_significant_block.status_word;
 	 	ptr->scene_number = most_significant_block.scene_number;
 	 	ptr->head_time = most_significant_block.video_start_time;
	 	ptr->end_time = most_significant_block.video_end_time;
 	 	ptr->encode_time = most_significant_block.encode_time;
	  	ptr->bitrate = most_significant_block.bit_rate_value;
    	}
    	break;
    case 1:
    	(*reg_r0) = trick_modes;
    	break;
    case 2:
    	(*reg_r0) = state;
    	break;
#ifdef DEBUG    	
    default:
    	mysource->getMiscInfo(flags);
#endif    	
  }
  return !ErrorExists();
}
//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++
int
Stream::source_inetevent(void)
{
  int timer_flag = 0; // do we require a callback
  int result = !ErrorExists();
  	
  if ((result != ErrorOccurred)&&(callback_pending)) {	// callback reset as we are about to recalculate
  	_kernel_oserror *e = _swix(OS_RemoveCallBack, _INR(0,1), VSP_CallBack, pw);	  	
		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
 		else{
 			callback_pending = 0;
 		}
  }
  if ((result != ErrorOccurred)&&
      (mysource->backgroundExecute(&timer_flag, myserver, &source_full_blocks) == ErrorOccurred)) {
  		err = &mysource->ReturnCopyOfError();
  		result =  ErrorOccurred;
  }
  if ((result != ErrorOccurred)&&(timer_flag)){
  	_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
 		else {
 			callback_pending = 1;
 		}
  }
  
  if ((result != ErrorOccurred)&&(source_full_blocks >= full_blocks)&&(state != state_stop)) 
  	result = test_empty_buffers();
  	
  return result;
}

int
Stream::server_inetevent(void)
{
  int event;
  ULINT result;
  
  if ( myserver->inetevent(&event, &result) == ErrorOccurred) {
  	err = &myserver->ReturnCopyOfError();
  	return ErrorOccurred;
  }
#ifdef DEBUG  
  if (result != 0)
  	Debug("erronous result form TCP event 0x%2.2X, result = %i\n", event, result);
#endif  	
  	
  if (event == COMMAND_playback_response)
  	change_state(state_play);
  else
  if (event == COMMAND_startend_notification){
     if (( state == state_pause )&&(myserver->Play(NEC_databurstval) == ErrorOccurred)){
 	err = &myserver->ReturnCopyOfError();
 	return ErrorOccurred;
     }
     if (state == state_play){ 			// if already playing
     	mysource->setFinalBlock(result);	
     }
  }
  return NoError;
}

int
Stream::DummyAckCall(void)
{
 if (state != state_stop) {
   if (myserver->comms_flag != ServerComms)	// defined in the server class
 	if (myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock(), DummyACK) == ErrorOccurred){
 		err = &(myserver->ReturnCopyOfError());
 		return ErrorOccurred;
 	}
 	myserver->comms_flag = NoServerComms;
 }
 return NoError;
}
#ifdef OUTPUT_FILE
int
Stream::MPEGInterrupt(int, int *claim)
{
  int result = !ErrorExists();
  
  for (int i = 0; i < NUM_MPEG_Tokens; i++)
  	if (buffers[i].block != NULL){
  	  	*claim = CLAIMED;
  		result = MPEGBufferListToNECBlock(&buffers[i]);	
  	}
#ifdef DEBUG  		
  if (result == ErrorOccurred){
    if (err != NULL)
    	PrintError();
    else
    	Debug("Unknown error occurred in MPEG handler\n");
  }
#endif  
  return result;
}
#else
int
Stream::MPEGInterrupt(int buffer_descriptor, int *claim)
{
  int i;	// this runs under interrupt avoid changing other peoples variables
  int result = !ErrorExists();
  
  i = 0;
  
  while (i < NUM_MPEG_Tokens) {	// remember if num_blocks is zero we cannot touch it.
    	if ((buffers[i].in_use != 0)&&(buffer_descriptor >= (int)buffers[i].list)&&
      	    (buffer_descriptor <  (((int)buffers[i].list) + (buffers[i].num_blocks * sizeof(Bitstream_buffer_descriptor))) )){
      	  	buffers[i].blocks_returned++;
      	  	break; 	//claim
        }
        i++;
  }//while search buffers
 
  if (i < NUM_MPEG_Tokens){	// if a token was found
  	(*claim) = CLAIMED;
  	
   	if (buffers[i].blocks_returned == buffers[i].num_blocks){	// if we have received all the blocks free it
  		result = MPEGBufferListToNECBlock(&buffers[i]);		// this marks it as free 
  		
  		if ((source_full_blocks)&&(state != state_stop))
    			result = test_empty_buffers();
#ifdef DEBUG    			
  		else
  			if (source_full_blocks == 0)
  				Debug("no full buffers for the mpeg player");
#endif  			
   	}
  }

  return result;
}
#endif

int
Stream::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  if (mysource->serviceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    	err = &(mysource->ReturnCopyOfError());
    	return ErrorOccurred;
    }
  return NoError;
}

//+++++++++++++++++++++++++++++++ StreamList Methods ++++++++++++++++
StreamList::StreamList(void)
{
}

int
StreamList::Add(Stream *str, int *id)
{
  int identifier;
  
  if (SwitchError() == ErrorOccurred) {
    return ErrorOccurred;
  }	// if we cannot recover from this error
  
  identifier = str->GetSinkHandle();
  
  while (EnsureUnique(identifier) == ErrorOccurred){
    RemoveErr();
    identifier++;
  }
  return List::Add((void*)str, ((*id)=identifier) );
}

Stream*
StreamList::identify(int identifier)
{
    
  if (SwitchError() == ErrorOccurred) {
    return ErrorOccurred;
  }	// if we cannot recover from this error
 
  return (Stream*)List::identify(identifier);
}

StreamList::~StreamList(void)
{
  int i;
  
  for (i=(CurrentSize-1); i>=0; i--){
    	delete (Stream*)object[i];			// delete from the top to the bottom
    	object[i] = NULL;
  }
  
  delete[] object; object = NULL;
  delete[] identifiers; identifiers = NULL;
  
  CurrentSize = 0;
}

int
StreamList::Remove(int identifier)	// returns a boolean success value
{
  int i = 0;	// count value
    
  if (SwitchError() == ErrorOccurred) {
    return ErrorOccurred;
  }	// if we cannot recover from this error
   
  while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  if (i == CurrentSize){
  	MakeError(VSP_UnknownObj);
        return ErrorOccurred;
  }

  delete (Stream*)object[i]; 
  object[i] = NULL;
  
  while (i < CurrentSize -1){
    object[i] = object[i+1];
    identifiers[i] = identifiers[i+1];
    i++;
  }
  CurrentSize--;
  
  if (decreasesize() != ErrorOccurred)		// this does test for sufficient decrease in size
  	return NoError;
  return ErrorOccurred;
}

//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++

int 
StreamList::inetEvent(int code, int identifier, int *claim, void *)
{
  int result = !ErrorExists();
  if (result == ErrorOccurred) return result;
  
  int i;
  code = code;
  for (i=0;i<CurrentSize;i++){
    if ((((Stream*)object[i])->source_sd) == identifier) {
    	if (((Stream*)object[i])->source_flag != STREAM_inet_inuse ){
      		((Stream*)object[i])->source_flag = STREAM_inet_inuse; 		// in use
      		if (((Stream*)object[i])->source_inetevent() == ErrorOccurred){
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			return ErrorOccurred;
      		}
      		if (((Stream*)object[i])->get_state() == state_stop){
      		   if (((Stream*)object[i])->change_state(state_stop) == ErrorOccurred)
      		   	 ((Stream*)object[i])->RemoveErr();
      		   else
      		   	if (Remove(identifiers[i]) == ErrorOccurred)
      		   		result = ErrorOccurred;
      		}// if closing this stream, we are doing this in a non interrupt mode.
      		((Stream*)object[i])->source_flag = !STREAM_inet_inuse; 	// not in use
      	}
        *claim = CLAIMED;
    } 
    else 
    if ((((Stream*)object[i])->server_sd) == identifier) {
     	if (((Stream*)object[i])->server_flag != STREAM_inet_inuse){
      		((Stream*)object[i])->server_flag = STREAM_inet_inuse; 		// in use
      		if ( ((Stream*)object[i])->server_inetevent() == ErrorOccurred){
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			return ErrorOccurred;
      		}
	       	((Stream*)object[i])->server_flag = !STREAM_inet_inuse; 	// not in use
        }
        *claim = CLAIMED; // claim even if in use
    }
  }
#ifdef DEBUG  
  if (ErrorExists()){
    	if (err != NULL)
    		PrintError();
    	else
    		Debug("error in inetEvent");
  }
#endif  
  return NoError;
}

int
StreamList::TimeSliceCall(void *)
{
  int result = !ErrorExists();
  if (result == ErrorOccurred) return result;

  int i;
  for (i=0;i<CurrentSize;i++){
    if( ((Stream*)object[i])->callback_pending != 0){
    	if (((Stream*)object[i])->source_flag != STREAM_inet_inuse ){
      		((Stream*)object[i])->source_flag = STREAM_inet_inuse; 		// in use
      		if (((Stream*)object[i])->source_inetevent() == ErrorOccurred){
    			err = &((Stream*)object[i])->ReturnCopyOfError();
    			result = ErrorOccurred;
      		}
	       	((Stream*)object[i])->source_flag = !STREAM_inet_inuse; 	// not in use
	}
    }// timer flag 		
  }
  return result;
}

int
StreamList::MPEGInterrupt(int buffer_descriptor)
{
  int i, claim = UNCLAIMED;
   
  for (i=0;i<CurrentSize;i++) {
    if ( ((Stream*)object[i])->MPEGInterrupt(buffer_descriptor, &claim) == ErrorOccurred ) {
    	err = &( (Stream*)object[i])->ReturnCopyOfError();
    	return ErrorOccurred;
    }
  }
  return NoError;
}

int
StreamList::DummyAckPoll(void)
{
  int i;

  for (i=0;i<CurrentSize;i++)
    if ( ((Stream*)object[i])->DummyAckCall() ) {
    	err = &((Stream*)object[i])->ReturnCopyOfError();
    	return ErrorOccurred;
    }
    
  return NoError;
}

int
StreamList::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  int i;
  
  for (i=0;i<CurrentSize;i++)
    if ( ((Stream*)object[i])->ServiceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    	err = &((Stream*)object[i])->ReturnCopyOfError();
    	return ErrorOccurred;
    }
  return NoError;
}
