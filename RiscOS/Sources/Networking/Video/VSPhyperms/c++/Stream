/**************************************
 Stream.c
	
impliments standard Stream class.

and the StreamList Class

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Stream.h"	// Source Element
#include "swis.h"
#include "string.h"

StreamToken::StreamToken()
{
	block = NULL;
	in_use = free_token;
	blocks_returned = 0;
}

StreamToken::~StreamToken(void)
{
 	block = NULL;		// this is assigned to point to source memory space
	blocks_returned = 0;
}

#if (NUM_MPEG_Tokens != 2)
#error Re-defining the number of MPEG tokens; be aware of optimisations used.
inline bool
Stream::tokenfree(void)
{
  for (int i = 0; i < NUM_MPEG_Tokens; ++i)
  	if (buffers[i].in_use == free_token)
  		break;
  return (i < NUM_MPEG_Tokens);
}

inline error_flag
Stream::test_empty_buffers(void)
{
  error_flag result = ErrorState();
  int token_id = -1;
  
  if ((state != state_step)||( (--step_times) >= 0)){
 	
 	for (int i = 0; i < NUM_MPEG_Tokens; ++i){
 	  	if (buffers[i].in_use == free_token){
 	  	  	token_id = i;
 	  	  	break;
 	  	}
 	}
  
  	if ( (result != ErrorOccurred)&&(state != state_stop)&&(token_id != -1) ) {
		buffers[token_id].in_use = claim_token;	// paired with free block
	    	result = mysource->getBlock(&(buffers[token_id].block), &(buffers[token_id].mpeg_buffer), ((int)VSP_MPEGCall), ((int)pw));
 	
	 	if (result != ErrorOccurred){
	 		if(buffers[token_id].block != NULL){
				buffers[token_id].blocks_returned = 0;
				if ((result = mysink.FullBuffer(buffers[token_id].mpeg_buffer)) == ErrorOccurred){
					err = &(mysink.ReturnCopyOfError());
					buffers[token_id].in_use = free_token;
				}
			}
			else
				buffers[token_id].in_use = free_token;
	        }
	 	else {
	                buffers[token_id].in_use = free_token;
	 	  	err = &mysource->ReturnCopyOfError();
	 	} // !get block error occurred
	}
  }  
  return result;
}
#else
inline bool
Stream::tokenfree(void)
{
 	return (bool)((buffers[0].in_use == free_token)||(buffers[1].in_use == free_token));
}

inline error_flag
Stream::test_empty_buffers(void)
{
  error_flag result = ErrorState();
  int token_id;
  
  if ((state != state_step)||( (--step_times) >= 0)){
 
  	MACRO_getFreeToken(token_id);
  
  	if ( (result != ErrorOccurred)&&(state != state_stop)&&(token_id != -1) ) {
		buffers[token_id].in_use = claim_token;	// paired with free block
		
	    	result = mysource->getBlock(&(buffers[token_id].block), &(buffers[token_id].mpeg_buffer), ((int)VSP_MPEGCall), ((int)pw));
 	
	 	if (result != ErrorOccurred){
	 		if(buffers[token_id].block != NULL){
				buffers[token_id].blocks_returned = 0;
				if ((result = mysink.FullBuffer(buffers[token_id].mpeg_buffer)) == ErrorOccurred){
				  	if (err_ptr == NULL) err_ptr = &(mysink.ReturnCopyOfError());
					buffers[token_id].in_use = free_token;
				}
			}
			else
				buffers[token_id].in_use = free_token;
	        }
	 	else {
	                buffers[token_id].in_use = free_token;
	 	  	if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
	 	} // !get block error occurred
	}
  }
  return result;
}
#endif


Stream::Stream(int inet_timeout, InternetObject *server, int MPEGid, int source_recvspace, int NumBlocks, int BufferBlocks, int TCP_TimeOut, void *pwork)
:mysink(MPEGid)
{
  // MULTICAST CONSTRUCTOR
  
  // STB specific variables
  source = source_multicast;
  
  pw = pwork;
  comms_timeout = inet_timeout;
  from = endofstream = 0; 	
  callback_pending = callback_bufferswait;	// buffer management is in a state of waiting for buffer blocks
  state = state_play;				// set the state of play
  buffer_blocks = BufferBlocks;	
   
  if (mysink.ErrorExists()) {
    	if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
  }
  else{ 	
    	myserver = server;
  	mysource = new SourceMultiCast(server, source_recvspace, NumBlocks, TCP_TimeOut);		// create UDP socket
  	if  ( mysource->ErrorExists() ){ // errors on creation of UDP
  		if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  	}
  }
  
  if ((!ErrorExists()) && (mysource->getSocketDescriptor(&source_sd) == ErrorOccurred)  ){
    	if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  }
  server_sd = -1;

  if (mysink.SetSpeed(2) == ErrorOccurred){	// start in slow motion.
       	if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
  }
  	
  trick_modes_available = trick_normal_play;
}
// stream constructor MULTICAST

Stream::Stream(int play_ack, int inet_timeout, int initial_block, int MPEGid, PlayList playlist, int play_num, Server *server, int NumBlocks, 
	int source_recvspace, int BufferBlocks, void *pwork, int in_from):mysink(MPEGid)
{
  // server specific variables
  int BlockSize;		// data size calculation
  int num_dgrams; 		// maximum number of datagrams
  ULINT dgram_size, bitrate;
  in_addr ipAddress;		// structure defined in internet library
  ULINT portnum;		// of server object, receiving
    
  // STB specific variables
  pw = pwork;  
  source = source_vod;
  comms_timeout = inet_timeout;
  callback_pending = callback_bufferswait;	// buffer management is in a state of waiting for buffer blocks
  state = state_prestart;			// set the state of play
  buffer_blocks = BufferBlocks;	
   
  if ((!ErrorExists())&&(mysink.ErrorExists())) {
    	if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
  }
  else{ 	
    	myserver = server;

    	server->set_stream_owner();
  	mysource = new Source((comms_timeout+1)>>1, source_recvspace);			// create UDP socket
 	
 	if (server->ErrorExists()){ 				// errors on creation of TCP
 		if (err_ptr == NULL) err_ptr = &server->ReturnCopyOfError();
  	}
  	else 
  	if  (mysource->ErrorExists()&&(mysource->ErrorNum() != VSP_SourceUninit)){ // errors on creation of UDP
		if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  	}
  }
  	
  if ((!ErrorExists()) &&		// on no error
  	   	( (mysource->getLocalPort((int*)&portnum)== ErrorOccurred)  ||	// get UDP port number for asset presentation
  	   	  (mysource->getSocketDescriptor(&source_sd) == ErrorOccurred)    ) ){
  	if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  }
  
  if ((!ErrorExists()) && ((server_sd = server->getSocketDescriptor()) == -1)) MakeError(IP_SocketError);
  
  if ((!ErrorExists()) && (server->getLocalAddress((in_addr*)&ipAddress) == ErrorOccurred) ){
    	if (err_ptr == NULL) err_ptr = &(server->ReturnCopyOfError());
  }
  
  ULINT fast_playback;	// this is used for the playback ratio, I also place the flags that indicate which is available.
  if ((!ErrorExists()) && ((server->AssetPresentation(initial_block, playlist, play_num, &endofstream,
  						 &ipAddress, &portnum, &dgram_size, &bitrate, &fast_playback)) == ErrorOccurred)) {
  	if (err_ptr == NULL) err_ptr = &server->ReturnCopyOfError();
  }
  
  // set the server to listen to the port returned from the presentation
  ipAddress.s_addr = ntohl(ipAddress.s_addr);		// ipaddress of server as port are set in the asset presentation
  if ( (!ErrorExists()) && (mysource->setServerDetails(&ipAddress, (int)portnum) == ErrorOccurred)) {
       	if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  }
  
  // calculate trick modes for this stream
  trick_modes_available = implemented_trick_modes | (fast_playback >> 24);
  fast_playback_ratio = fast_playback & 0xFFFFFF;
  if (endofstream == 0xFFFFFFFF){	// if stream live
  	trick_modes_available +=  trick_jump_most_rec;
  }
  // start and end are set in the play element, we set them here so as to get notifications
  if ((from = in_from) >= endofstream)	// this in most cases is zero
  	MakeError(VSP_InvalidValue);

  // calculate the size of the source buffering	 
  // bytes per 2/3 sec's this ensures enough dgrams
  num_dgrams = (int) ( ((double)(((bitrate/8)*2)/3) / (dgram_size-sizeof(NECDatagram))) +0.5 ) + 1;  // rounded up + 1
  BlockSize =  num_dgrams * (int)dgram_size;	// calculation on datagram size and bitrate
  
  // allocate the buffer space in the source object
  if ((!ErrorExists())&&(mysource->Allocate(NumBlocks, BlockSize, initial_block, (size_t)dgram_size) == ErrorOccurred)){
  	if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  }
  
  // send pre-play ack
  if (play_ack != 0) {
  	if ((!ErrorExists()) && (server->SendAck(server->getMaxRequestedBlock(), server->getMaxRequestedBlock(), play_preparation) == ErrorOccurred)){
  		if (err_ptr == NULL) err_ptr = &server->ReturnCopyOfError();
  	}
  }
  else{ 
  	if ((!ErrorExists()) && (server->SendAck(server->getMaxRequestedBlock(), server->getMaxRequestedBlock()) == ErrorOccurred)){
  		if (err_ptr == NULL) err_ptr = &server->ReturnCopyOfError();
  	}
  }

  if (!ErrorExists()){
    	callback_pending += callback_trickplay;	// from set
        change_state(state_play);	// this will make an imediate callback for trickplay.
        server->send_message_StartNotification(initial_block);
  }
#ifdef DEBUGLIB  
  if ((!ErrorExists())&&(Debug(debug_streaminfo))) {
    	Debug("stream bitrate = %i, datagram size %i, datagrams/block %i, fast play ratio %i", 
    				bitrate, dgram_size, num_dgrams, fast_playback_ratio);	
    	if (trick_modes_available & trick_jump_most_rec)
		Debug("Being Registered tricks %8.8X, initial block %i", trick_modes_available, initial_block);
	else
		Debug("Registered Video %i to %i (secs), tricks %8.8X", from/2, endofstream/2, trick_modes_available);

  }
#endif
} 	// stream constructor

Stream::~Stream(void)
{
  if ((change_state(state_stop) != ErrorOccurred)||(ErrorNum() != VSP_CantDeleteSharedMemory)){
    	// this is because errors can occur including errors returned from the server not always shared memory
    	delete mysource; mysource = NULL;
  }
  else {
    	int count = 0;
   	do {
   	  	++count;
    		RemoveErr();
 		if (mysink.ResetStream(3) == ErrorOccurred)
 			break;
 		if (count > 10) {
 			mysink.CloseStream();	
 			break;
 		}
    	}
    	while (change_state(state_stop) == ErrorOccurred);
    	delete mysource; mysource = NULL;
  }
  
  myserver->send_message_StreamClosing(err_ptr);
 	
  if (myserver->interface_uses()){
    	myserver->clear_streamrunning();
  	myserver->clear_stream_owner();
  	if (myserver->ErrorExists())
  	  	myserver->RemoveErr();
  }
  else  {
  	delete myserver;
  	myserver = NULL;
  }
}

inline error_flag
Stream::swap_source(void)
{
  	if (source == source_streamlive){
     		Source *tmp = mysource;
     		mysource = new Source((*tmp));
     		delete tmp;
     		if (mysource->ErrorExists()){
     			if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
     		}
     		source = source_vod;
#ifdef DEBUGLIB     
        	Debug("LIVE -> Stored");
#endif
        }
        else {
        	if (source == source_vod){
    	  		Source *tmp = mysource;
     	  		mysource = new SourceLIVE((*tmp));
     	  		delete tmp;
     			if (mysource->ErrorExists()){
     			  	if (err_ptr == NULL) err_ptr = &ReturnCopyOfError();
     			}
     			source = source_streamlive;
#ifdef DEBUGLIB     	  
        	Debug("Stored -> LIVE");
#endif        	
                }
        }
        return (ErrorExists() ? ErrorOccurred : NoError);
}
//
// this is the central change of state method for the stream class
// the stream state should not change state unless going through here
// the 'trick_mode' are checked to ensure that a particular state is 
// available to a particular stream.  It is debatable as to whether 
// an error should be created otherwise.
//
// it is expected that most error handling is done externally
// with the exeption of stopping the stream

inline ULINT
Stream::trick_modes(void)
{
  return ((source == source_streamlive) ? (trick_normal_play | trick_backward_jump) : (trick_modes_available));
}

error_flag
Stream::change_state(state_of_play new_state)
{
  	state_of_play old_state = state;
	// if from time has not already been set, ie jump
	if (!(callback_pending & callback_trickplay))
		from = getNECTime();

#ifdef DEBUGLIB
   	Debug("state %i -> %i, from = %i", state, new_state, from);
#endif
		
	switch (new_state) {
     		case state_slow:
     			if (trick_modes() & trick_slow_play)
     				state = state_slow;
     			break;
     		case state_step:
     			if (trick_modes() & trick_step_play)
     				state = state_step;
     			break;
     		case state_endreceived:
     			if (state != state_stop) {
#ifdef DEBUGLIB
				if (Debug(debug_streaminfo))
					Debug("end received");
#endif     		
     				state = state_endreceived;
     			}
     			break;
     		case state_stop:
        			if (ErrorExists()) RemoveErr(); // just try to stop
      				  		
   				if (state != state_stop){
  					if ((myserver->streamrunning())&&(myserver->AssetEnd(0, (state != state_endreceived)) == ErrorOccurred)){
  						if (err_ptr == NULL) err_ptr = &(myserver->ReturnCopyOfError());
  					}
   					mysource->setEndPlayState();		// this ensures no more data is copied upriver.
     					state = state_stop;
        			}
        			{
        				bool used_buffer = false;
     				
     					for (int i=0; i < NUM_MPEG_Tokens; i++){
     						if (buffers[i].in_use != free_token)
     							used_buffer = true;	
     	                        	}
#ifdef DEBUGLIB
     					Debug("close stream; flags %2.2X, tokens (%i)(%i)", callback_pending, 
     					(buffers[0].in_use == claim_token), (buffers[1].in_use == claim_token));
#endif    				
     					if (used_buffer == true)
     						MakeError(VSP_CantDeleteSharedMemory);
     				}
   			break;
     		case state_pause:
     			if (trick_modes() & trick_pause)
     				state = state_pause;
     			break;
     		case state_play:
        		if (trick_modes() & trick_normal_play) {
     	  			if (source != source_vod)
     	  				swap_source();
         	 			
         	      		if (mysource->get_most_significant_mode() != mode_normalplay)	// do we need to change server file
					callback_pending += callback_trickplay;
   				
   				state = state_play;
			}
		     	break;
     		case state_streamlive:
     			if (trick_modes() & trick_jump_most_rec){
     	  			if (mysource->get_most_significant_mode() != mode_streamlive){	// do we need to change server file
					callback_pending += callback_trickplay;
					swap_source();
     					from = 0xFFFFFFFF;
     					state = state_streamlive;
     				}
     			}
        		break;
     		case state_fast_forward:
        		if (trick_modes() & trick_fast_forward){
        		  	if (mysource->get_most_significant_mode() != mode_fastforward)	// do we need to change server file
					callback_pending += callback_trickplay;
         			state =  state_fast_forward;
			}
     			break;
     		case state_fast_rewind:
        		if (trick_modes() & trick_fast_rewind){
        		  	if (mysource->get_most_significant_mode() != mode_fastrewind)	// do we need to change server file
					callback_pending += callback_trickplay;
     		  		state =  state_fast_rewind;
			}
     			break;
        }
   
   	if (old_state == state_step)
     		test_empty_buffers();
     		
   	// the trick flag is set if this trick requires dialogue with the server ie change file or jump.
   	if ((!ErrorExists())&&(callback_pending & callback_trickplay)) {
#ifdef DEBUGLIB
  		ULINT current_min, future_min;
  	
  		current_min = (int)((getNECTime() >> 1) / 60);
  		future_min = (int)((from >> 1)/ 60);
  		Debug("trick play (%i) (%2i:%2i:%2i) -> (%2i:%2i:%2i) %i -> %i", state,
  							   (int)(current_min/60), (int)(current_min % 60), (int)((getNECTime()>>1) % 60),
  							   (int)(future_min/60), (int)(future_min % 60), (int)((from >> 1) % 60),
  							   getNECTime(), from);
#endif
  		MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
        }
   	return (ErrorExists() ? ErrorOccurred : NoError);
}

error_flag
Stream::GetSinkHandle(void)
{
  if (mysink.GetHandle() == ErrorOccurred){
    	if (err_ptr == NULL) err_ptr = &(mysink.ReturnCopyOfError());
  }
  
  return (ErrorExists() ? ErrorOccurred : NoError);
}

error_flag
Stream::CheckEOS(int *play_state)			// call to Decoder
{
  if ((ErrorState() == ErrorOccurred)||(state == state_stop)||(state == state_endreceived)){
#ifdef DEBUGLIB    
	if (Debug(debug_streaminfo))
		Debug("eos %i || %i || %i", (ErrorState() == ErrorOccurred),(state == state_stop),(state == state_endreceived));
#endif
  	(*play_state) = 1;
  }
  else
  	(*play_state) = 0;
  
  return NoError;
}

error_flag
Stream::SetSpeed(int direction, int speed)		// call to Decoder
{
 if (ErrorState() != ErrorOccurred){
 	if ((direction == 2)&&(trick_modes() & trick_step_play)){
 		step_times = speed;
 		change_state(state_step);
 	}
 	else 
 	switch(speed) {
 	   case 0:
 	   	if (speed == 0)
 	   		change_state(state_pause);
 	   	else
 	 		MakeError(VSP_Unimplemented);
 	   	break;
 	   case 1:
 	   	if (direction == 1)
 	   		change_state(state_fast_forward);
 	   	else
 	   		change_state(state_play);
 	   	break;
 	   case -1:
 	    	if (direction == 1)
 	   		change_state(state_fast_rewind);
 	   	break;
 	   default:
 	   	if (direction == 0)
 	   		change_state(state_slow);
		else    		
	  		MakeError(VSP_Unimplemented);
 	}
 }
 return (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
Stream::SetPosition(int flags, int pos_time)	 // call to Decoder
{
  if (ErrorState() != ErrorOccurred){
  	ULINT NEC_time = getNECTime();
  	ULINT abs_time;
  
  	if (flags == 1){
  		abs_time = NEC_time + (pos_time * 2);
  	}
  	else
  	if (flags == 2){
  		abs_time = NEC_time - (pos_time * 2);
  	}
  	else {
  		if ((pos_time < 0)&&(endofstream == 0xFFFFFFFF))
     			abs_time = 0xFFFFFFFF;
     		else
     			abs_time = (pos_time << 1);
        }
  
  	if (((abs_time & 0x80000000)&&(endofstream != 0xFFFFFFFF))||(abs_time > endofstream))
  		MakeError(VSP_InvalidValue);
  	else {
  		from = abs_time;
  		
  		callback_pending += callback_trickplay;
  		
  		if (abs_time == 0xFFFFFFFF)
  			change_state(state_streamlive);
  		else
  			if (state == state_streamlive)
  				change_state(state_play);
  			else
 				change_state(state);
        }
  }
  return (ErrorExists() ? ErrorOccurred : NoError );
}

inline ULINT
Stream::getNECTime(void)
{
  play_mode mode = mysource->get_most_significant_mode();
  ULINT time = mysource->get_most_significant_time();
  
  if ((mode == mode_fastrewind)||(mode == mode_fastforward))
  	time *=  fast_playback_ratio;
  	
  return time;
}

error_flag
Stream::ReadNPT(ULINT *NPT_time)
{ 
   if (ErrorState() != ErrorOccurred){
	if (source == source_multicast){
		if (mysink.ReadNPT(NPT_time) == ErrorOccurred)
			if (err_ptr == NULL)
				err_ptr = &(mysink.ReturnCopyOfError());
	}
	else {
#ifdef DEBUGLIB	  
	    	int current_min = (int)((getNECTime() >> 1) / 60);
 		Debug("NPT (%2i:%2i:%2i) %i, (%i)", 
  					   (int)(current_min/60), (int)(current_min % 60), (int)((getNECTime()>>1) % 60),
  					   getNECTime(), mysource->get_most_significant_mode());
#endif
		(*NPT_time) = (getNECTime() >> 1);
	}
   }
   else
   	*NPT_time = 0xFFFFFFFF;
   	
   return (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
Stream::GetMiscInfo(ULINT *reg_r0, misc_5_10 *ptr, int *size)
{
  if (ErrorState() != ErrorOccurred){
  	ULINT flags = (*reg_r0);
  	switch (flags) {
    		case 0x00:
    			if ((ptr == NULL)||((*size) == 0))
    				(*size) = sizeof(misc_5_10);
    			else {
    			  	if ( (*size) < sizeof(misc_5_10) )
    			  		MakeError(VSP_InvalidValue);
    			  	else {
    			  	  	if ((mysource->getMiscInfo(type_misc_5_10, ptr) == ErrorOccurred)&&(err_ptr == NULL))
    			  	  		err_ptr = &(mysource->ReturnCopyOfError());
			  	}
    			}
    			break;
    		case 0x01:
    			(*reg_r0) = trick_modes();
    			break;
    		case 0x02:
#ifdef DEBUGLIB    	
    			if (ErrorExists()){
    			  	Debug("stream error exists");
				ErrorDump(debug_always);
	    		}
	    		else
	    		if ((myserver != NULL)&&(myserver->ErrorExists())){
	    		  	Debug("server error");
	    		}
	    		else {
	    		  	if (mysink.ErrorExists()){
	    		  	  	Debug("SinkError");
	    		  	}
	   			Debug("stream (%i)- cb %2.2X, t[0] (%i), t[1] = (%i)", 
	    					mysource->getFullBlocks(), callback_pending, 
	    					(buffers[0].in_use == claim_token), (buffers[1].in_use== claim_token));
	    			mysource->getMiscInfo(type_debug, NULL);
	    		}
#endif    	
	    		if (state > state_still)
	    			(*reg_r0) = state_play;
	    		else
	    			(*reg_r0) = state;
	    		break;
	    	case 0x03:
	    		if (mysource != NULL)
	    			mysource->getMiscInfo(type_buffers, reg_r0);
	    		break;
	 }
  }
  return (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
Stream::stop_stream(ULONG *new_block_number)
{
  (*new_block_number) = myserver->getMaxRequestedBlock() + (NEC_databurstval << 1);

  return change_state(state_stop);
}

//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++

inline error_flag
Stream::timeslice(Statistics *stats)
{
  if ((ErrorState() == NoError)&&(state != state_stop)){  
  	if (callback_pending & callback_bufferfree){
		
#if (NUM_MPEG_Tokens != 2)
		callback_pending -= callback_bufferfree;
#else
		if (callback_pending & callback_buffer1free)
  			callback_pending -= callback_buffer1free;
  		else
  			callback_pending -= callback_buffer2free;
#endif  		
  		if ((mysource->calculate_freeBlocks(myserver, &callback_pending, stats, comms_timeout))&&(err_ptr == NULL))
  			err_ptr = &(mysource->ReturnCopyOfError());

  		if ((!(callback_pending & callback_bufferswait))&&(tokenfree()))
  		  	test_empty_buffers();
  			
                // this reinitialises the block callback vector if we fill up the blocks
  		if (!(callback_pending & callback_timeout)){
  			callback_pending += callback_timeout;
			MakeErrorOnError(_swix(OS_CallAfter, _INR(0,2), comms_timeout, VSP_CallAfterVeneer, pw));
 		}
 		
		ULINT time = getNECTime(); //based on normal time
 		if ((time == 0)&&
 		    ((mysource->get_most_significant_mode() == mode_fastrewind)||(mysource->get_most_significant_mode() == mode_backwardskip))){
 			       	myserver->send_message_StartNotification(time);
 				callback_pending += callback_startend;
 		}
 		else {
 			if ((endofstream != 0)&&(endofstream != 0xFFFFFFFF)&&(time == endofstream)){
				myserver->send_message_EndNotification(time);
				callback_pending += callback_startend;
				change_state(state_endreceived);
			}
		}
  	}
  	else {
		if (callback_pending & callback_trickplay){
		  
        		ULONG RequestNum;
        		size_t AckNum;
        		play_mode mode;
        	
        		callback_pending -= callback_trickplay;
        		callback_pending -= callback_startend;
#ifdef DEBUGLIB	 	
	  		ULINT from_min = (int)((from >> 1) / 60);
  			Debug("play from NPT %2i:%2i:%2i, %i", (int)(from_min/60), (int)(from_min % 60), (int)(from_min % 60), from );
#endif  				
       			switch (state){
        			case state_fast_forward:
        				from /= fast_playback_ratio;
        	  			mode = mode_fastforward;
        	  			break;
        	  		case state_fast_rewind:
        				from /= fast_playback_ratio;
        	  			mode = mode_fastrewind;
        	  			break;
        	  		case state_streamlive:
        	  			mode = mode_streamlive;
        	  			break;
        	  		default:
        				mode = mode_normalplay;
        				break;
        		}
        	
        		if (mysource->setNewPlayState(&RequestNum, &AckNum, mode, from, comms_timeout) == ErrorOccurred){
        			 
        			 if (err_ptr == NULL)	err_ptr = &(mysource->ReturnCopyOfError());
   			}
                	else {
                		// clear callback vector
   			  	if (callback_pending & callback_timeout){
   			  		callback_pending -= callback_timeout;
     					_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
     				}     				
     	 			myserver->send_playback_request( mysource->get_current_play_id(), RequestNum, AckNum, from, mode);
     	 			
     	 			if (myserver->ErrorExists()){
     	 			  	if (myserver->ErrorNum() == IP_NoBuffer){
     	 			  	  	myserver->RemoveErr();
     	 			 	  	callback_pending += callback_trickplay;
     	 			 	  	MakeErrorOnError(_swix(OS_CallAfter, _INR(0,2), (comms_timeout), VSP_CallAfterVeneer, pw));
     	 			 	}
     	 			 	else  	
     	 			 		if (err_ptr == NULL) err_ptr = &(myserver->ReturnCopyOfError());
     	 			}
     	 			else{
     	 			  	myserver->reset_message_sent();
     	 			  	callback_pending += callback_bufferswait;
     	 			  	
     	 			  	if ((!ErrorExists())&&(state != state_streamlive)){
     	 					callback_pending += callback_timeout;
                				MakeErrorOnError(_swix(OS_CallAfter, _INR(0,2), comms_timeout, VSP_CallAfterVeneer, pw));
 					}
 				}
 			}
                	
                }
 		else {// default event foreground execute (save stream)
 		  	if (!(callback_pending & callback_startend)) {
 				ULINT timeout = comms_timeout;
 		  		if (mysource->foregroundExecute(myserver, stats, &timeout) == ErrorOccurred){
  					if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
  				}
  				else
  				if (timeout != 0)
  					MakeErrorOnError(_swix(OS_CallAfter, _INR(0,2), timeout, VSP_CallAfterVeneer, pw));
  			}
 		}
  	}
  }
  if ((state != state_stop)&&(ErrorExists())){
    	myserver->send_message_Error(err_ptr);
  }
  return NoError;
}

inline error_flag
Stream::server_inetevent(int code)
{
  UCHAR event = 0;
  ULINT comms_result;
  ULINT play_id = mysource->get_current_play_id();
  
  if (ErrorState() != ErrorOccurred){
  	if ( myserver->inetevent(&event, &comms_result, play_id, code) == ErrorOccurred) {
  		if (err_ptr == NULL) err_ptr = &myserver->ReturnCopyOfError();
	} 
  	if (event == COMMAND_startend_notification) {
  	 	if (((play_id >> 24) == 3)||((play_id >> 24) == 4))
  	 		endofstream = comms_result * fast_playback_ratio;
  	 	else
        		endofstream = comms_result;
#ifdef DEBUGLIB
		if (Debug(debug_startend)) Debug("START/END endofstream set to %i, current time %i", endofstream, getNECTime());
#endif        	
        }
  }
  
  if ((state != state_stop)&&(ErrorExists())) {
    	myserver->send_message_Error(err_ptr);
  }   	
  return NoError;
}

inline error_flag
Stream::source_inetevent(int code, Statistics *stats)
{
  if ((ErrorState() != ErrorOccurred)&&(state != state_stop)) {
  	if (code == Socket_Broken_Event)
        	MakeError(IP_SocketError);// make an error in the stream object to be
        else {      
        	callback_flag callback = callback_none;
        	ULINT timeout = comms_timeout; // this is the block timeout
		if (mysource->ReadDatagrams(&callback, myserver, stats, &timeout) == ErrorOccurred) {
    			if (err_ptr == NULL) err_ptr = &mysource->ReturnCopyOfError();
    		}
      		else {	      				
      			if (callback & callback_timeout){
				callback_pending += callback_timeout;
				_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
      			  	// if oldest block has been completed then
				if (timeout > 1)
					MakeErrorOnError(_swix(OS_CallAfter, _INR(0,2), timeout, VSP_CallAfterVeneer, pw));
				else
					MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
      			}
      			else
      			if (callback & callback_fullblocks){
      				_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
				callback_pending += callback_fullblocks;
      				callback_pending -= callback_timeout;
      			}
  				
  			if (callback_pending & callback_bufferswait){
  			  	if (source == source_multicast){
  			  	  	if (mysource->getFullBlocks() >= (mysource->getNumBlocks()>>1)){
  			  	  		if (mysink.SetSpeed(1) == ErrorOccurred){
       							if (err_ptr == NULL) err_ptr = &mysink.ReturnCopyOfError();
       						}
       						callback_pending -= callback_bufferswait;
                                        }	// back to normal play.
                                        test_empty_buffers();
                                }
                                else
  				if (mysource->getFullBlocks() > buffer_blocks){
  					play_mode mode = mysource->get_most_significant_mode();
  				  	
  				  	if ((mode == mode_fastforward)||(mode == mode_fastrewind))
						mysink.ResetStream(1);
					else
						mysink.ResetStream(3);
					
					callback_pending -= callback_bufferswait;
					test_empty_buffers();
				}
			}
			else
				if (tokenfree()) test_empty_buffers();
 		}
 	}
  }
  
  if ((state != state_stop)&&(ErrorExists())) {
  	myserver->send_message_Error(err_ptr);
  }
  return NoError; 		         
}

inline error_flag
Stream::DummyAckCall(void)
{
  if ((myserver->comms_flag == false)&&
      (myserver->SendAck(myserver->getMaxRequestedBlock(), myserver->getMaxRequestedBlock(), dummy_ack) == ErrorOccurred)){
 		if (err_ptr == NULL) err_ptr = &(myserver->ReturnCopyOfError());
  }
  myserver->comms_flag = false;
  
  if ((state != state_stop)&&(ErrorExists())){
    	myserver->send_message_Error(err_ptr);
  }
   return NoError;
}

#if (NUM_MPEG_Tokens != 2)
#error Re-defining the number of MPEG tokens; be aware of optimisations used.
inline error_flag
Stream::MPEGInterrupt(int buffer_descriptor)
{
  int i;	// this runs under interrupt avoid changing other peoples variables
//  error_flag result = ErrorState();
  
  i = 0;
  while (i < NUM_MPEG_Tokens) {	// remember if num_blocks is zero we cannot touch it.
    	if ((buffers[i].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[i].block->buffers)&&
      	    (buffer_descriptor <  (((int)buffers[i].block->buffers) + (buffers[i].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
      	  	buffers[i].blocks_returned++;
      	  	break; 	//claim
        }
        i++;
  }//while search buffers
 
  if ((i < NUM_MPEG_Tokens)&&(buffers[i].blocks_returned == buffers[i].block->num_buffers)){	// if we have received all the blocks free it
  	if ( (result != ErrorOccurred)&&(( result = mysource->freeBlock(buffers[i].block)) == ErrorOccurred) )
  		err = &mysource->ReturnCopyOfError();
  
  	buffers[i].block = NULL;
  	buffers[i].in_use = free_token;
  	
	if ((!(callback_pending & callback_bufferfree))||(state == state_stop)){
  		callback_pending += callback_bufferfree;
    		_kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 		if (e != NULL){
  			MakeError(e);
  			result = ErrorOccurred;
 		}
 	}
 	
 	if (state != state_stop){
 		if (callback_pending & callback_fullblocks)
  			callback_pending -= callback_fullblocks);
  			
  		callback_pending += callback_tokenfree;
  	}
 }
  return NoError;
}
#else
inline error_flag
Stream::MPEGInterrupt(int buffer_descriptor)
{
  int token_freed = -1;
      
  if ((buffers[0].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[0].block->buffers)&&
      (buffer_descriptor <  (((int)buffers[0].block->buffers) + (buffers[0].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
      	  	buffers[0].blocks_returned++;
      	  	
  		if (buffers[0].blocks_returned == buffers[0].block->num_buffers){	// if we have received all the blocks free it 			
  			if ((mysource->freeBlock(buffers[0].block) == ErrorOccurred )&&(err_ptr == NULL))
  				err_ptr = &mysource->ReturnCopyOfError();
  
  			buffers[0].block = NULL;
  			buffers[0].in_use = free_token;
  			
  			token_freed = 0;
  			
  			callback_pending += callback_buffer1free;	  	
    			MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
  		}
  }
  else         // not token 0 try token 1
  if ((buffers[1].in_use == claim_token)&&(buffer_descriptor >= (int)buffers[1].block->buffers)&&
          (buffer_descriptor <  (((int)buffers[1].block->buffers) + (buffers[1].block->max_buffers * sizeof(BitstreamBufferDescriptor))) )){
      	  	buffers[1].blocks_returned++;
      	  	
  		if (buffers[1].blocks_returned == buffers[1].block->num_buffers){	// if we have received all the blocks free it
  			if (( mysource->freeBlock(buffers[1].block) == ErrorOccurred )&&(err_ptr == NULL))
  				err_ptr = &mysource->ReturnCopyOfError();
  
  			buffers[1].block = NULL;
  			buffers[1].in_use = free_token;
  	
  			token_freed = 1;
  			callback_pending += callback_buffer2free;	  	
    			MakeErrorOnError(_swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw));
  		}
   }
   return NoError;
}
#endif

error_flag
Stream::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  if (mysource->serviceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred) {
    	if (err_ptr == NULL) err_ptr = &(mysource->ReturnCopyOfError());
  }
  
  if ((state != state_stop)&&(ErrorExists()))
  	myserver->send_message_Error(err_ptr);
  	
  return NoError;
}

//+++++++++++++++++++++++++++++++ StreamList Methods ++++++++++++++++
StreamList::StreamList(void):List()
{
}

error_flag
StreamList::Add(Stream *str, int *id)
{
	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &(str->start_time));
					
	str->data_at_start = stats.bytes_received;
	str->acks_at_start = stats.acks_sent;
	str->naks_at_start = stats.naks_sent + stats.block_naks_sent;
  	
  	*id = str->GetSinkHandle();
  	
  	return List::Add((ListObject*)str, id);
}


error_flag
StreamList::Remove(int identifier)	// returns a boolean success value
{
  error_flag result = ErrorState();
 
  if (result != ErrorOccurred) {
	  unsigned int mt_time;
	  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &mt_time);
	  	
	  Stream *str;
	  	
	  if (identify((ListObject**)&str, identifier) != ErrorOccurred) {
	  	
	  	if (mt_time > str->start_time){
	  		// stream bytes received
	  		stats.last_stream_bytes_received = (ULINT)(stats.bytes_received - str->data_at_start);
	  		stats.last_stream_time = (ULINT)(mt_time - str->start_time);
	  		stats.last_stream_acks = (ULINT)(stats.acks_sent - str->acks_at_start);
	  		stats.last_stream_naks = (ULINT)((stats.naks_sent + stats.block_naks_sent) - str->naks_at_start);
	  	} // bitrate calculation
	  	
	  	result = List::Remove(identifier);
         }
         result = ErrorOccurred;
  }

  return  (ErrorExists() ? ErrorOccurred : NoError );
}

//+++++++++++++++++++++++++++++++ interrupt handlers ++++++++++++++++
// the first argument is code or the out of band etc indicator.
error_flag 
StreamList::inetEvent(int code, int identifier, claim_flag *claim, void *)
{
  if ((ErrorState() != ErrorOccurred)&&(identifier != -1)){
  	for (int i=0;i<Size();i++){
  	  	if (object[i] != NULL){
  			Stream *stream = ((Stream*)object[i]);
 		
    			if ((stream->source_sd) == identifier) {
    		  		if (stream->source_inetevent(code, &stats) == ErrorOccurred){
    		  	  		if (err_ptr == NULL) err_ptr = &stream->ReturnCopyOfError();
    		  		}	
    	 		*claim = claim_event;
                	} 
    			else 
    			if ((stream->server_sd) == identifier) {
        	   		if ( stream->server_inetevent(code) == ErrorOccurred){
      			  		if (err_ptr == NULL) err_ptr = &stream->ReturnCopyOfError();
       				}
        			*claim = claim_event; // claim even if in use
        		}
        	}
        }
  }  
  return  (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
StreamList::TimeSliceCall(void *)
{
  if (ErrorState() != ErrorOccurred){
  	for (int i=0; i<Size(); i++){
  	  	if (object[i] != NULL){
    			Stream *stream = ((Stream*)object[i]);
  			
    			if ((stream->callback_pending != callback_none)){
      				if (( stream->state == state_stop)&&( stream->change_state(state_stop) != ErrorOccurred ))
      		  			Remove(identifiers[i]);	// removeit from the list
      				else
      				if (stream->timeslice(&stats) == ErrorOccurred){
    					if (err_ptr == NULL)	err_ptr = &stream->ReturnCopyOfError();
      				}	  	
			}
                } 		
        }
  }
  return  (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
StreamList::MPEGInterrupt(int buffer_descriptor)
{
 if (ErrorState() != ErrorOccurred){
  	for (int i=0; i<Size(); ++i) {
  	  	if (object[i] != NULL){
  	  		Stream *stream = (Stream*)object[i];
  	  		
    			if ( stream->MPEGInterrupt(buffer_descriptor) == ErrorOccurred ) {
    				if (err_ptr == NULL)
    					err_ptr = &(stream->ReturnCopyOfError());
    				break;
    			}
    		}
  	}
  }
  return  (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
StreamList::DummyAckPoll(void)
{
  if (ErrorState() != ErrorOccurred){
  	for (int i=0; i<Size(); ++i)
    		if ((object[i] != NULL)&&((Stream*)object[i])->DummyAckCall() == ErrorOccurred) {
    			if (err_ptr == NULL) err_ptr = &((Stream*)object[i])->ReturnCopyOfError();
    			break;
    		}
  }
  return  (ErrorExists() ? ErrorOccurred : NoError );
}

error_flag
StreamList::ServiceDynamicAreaRenumber(int old_id, int new_id)
{
  if ( ErrorState() != ErrorOccurred){
  	for (int i=0;i<Size();i++)
  		if ( (object[i] != NULL)&&(((Stream*)object[i])->ServiceDynamicAreaRenumber(old_id, new_id) == ErrorOccurred)) {
    			if (err_ptr == NULL)
    				err_ptr = &((Stream*)object[i])->ReturnCopyOfError();
    			break;
                }
  }
  return  (ErrorExists() ? ErrorOccurred : NoError);
}
