/**************************************
 Source.c++

implements Source class
© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
03/09/98  SNB     File created

**************************************/
extern "C" {
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

// Current Clib stddef.h does not define a C++ compatible offsetof
#undef offsetof
#define offsetof(type, member) \
    ((size_t)((char *)&(((type *)0)->member) - (char *)0))

#include "kernel.h"
#include "swis.h"
}
#include "SourceP.h"
#include "Source.h"

extern "C" {
#include "sys/ioctl.h"
#include "netinet/udp.h"
}

//
// This function validates a given NECBlock pointer by checking the magic word
// which immediately precedes the structure in memory.
//
// Errors: VSP_InvalidValue
//
int Source::validateNECBlock(const NECBlock *nec_block)
{
        int result = NoError;
        
        if (nec_block == 0) {
                MakeError(VSP_InvalidValue);
                result = ErrorOccurred;
        }
        else {
                const unsigned long *backPtr = (const unsigned long *) nec_block;
                if (backPtr[-1] != MemBlock__GuardWord) {
                        MakeError(VSP_InvalidValue);
                        result = ErrorOccurred;
                }
        }

        return result;
}

//
// This function validates a given MemBlock pointer by checking the magic word
// which occurs within the structure.
//
// Errors: VSP_InvalidValue
//
int Source::validateMemBlock(const MemBlock *block)
{
        int result = NoError;

        if (block == 0) {
                MakeError(VSP_InvalidValue);
                result = ErrorOccurred;
        }
        else {
                if (block->guard_word != MemBlock__GuardWord) {
                        MakeError(VSP_InvalidValue);
                        result = ErrorOccurred;
                }
        }

        return result;
}

//
// This function maps a block offset number (not a block ID!) to a pointer
// to the block.  It does not validate n.
//
// Errors: None.
//

int
Source::getMiscInfo(int flags)
{
  flags = flags;
  int result = !ErrorExists();

#ifdef DEBUG               
         for (int i = 0; ( (i < max_blocks)&&(result != ErrorOccurred) ); i++) {
               MemBlock *mb = getBlock(i);
               Debug("block (%i)(%i)[%i], naks = %i, dg rec = %i/%i, max blk = %i",
              	 mb->completed!=0, mb->inuse!=0, mb->block_id, mb->pending_nak!=0,  
              	 mb->dgrams_received, mb->dgrams_in_block, max_block_received);
         }
#endif               	
  return result;
}

MemBlock *Source::getBlock(size_t n)// const
{
  MemBlock *ptr;
  
        const size_t offset = sizeof_MemBlock() * n;
        ptr = (MemBlock *) (((char *) block_hd) + offset);

#ifdef MEM_SANE_CHECK        
        if ( ((int)ptr < (int)block_hd)||((int)ptr > ((int)(dgram_hd) - sizeof_MemBlock())) )
        	Debug("memblock out of range %8.8X\n", ptr);
#endif
        return ptr;
}

// calculate the largest block_id for full blocks, this means that no block_id
// smaller shall be incomplete and no block_id greater shall be complete.

int
Source::calculateMaxCompleteBlock(void)
{
  MemBlock *mb;
  
  //getMiscInfo(0);
  
  while (((mb = findExistingBlock(max_completed_block+1)) != NULL)&&(mb->inuse)&&(mb->completed))
  	max_completed_block++;
  	
  return !ErrorExists();
}

int 
Source::calculatePosAckSequence(Server *server)
{
    size_t freeblocks;
    int MAX_block_request;
    int result = NoError;
         
    // this also fills the full blocks variable
    // the idea here is to maintain a window of databurst size from max_completed
    
    result = getBlockStatus(0, 0, &freeblocks);
           
    if ((result != ErrorOccurred)&&
    	((max_completed_block + freeblocks) > server->getMaxRequestedBlock() ) ) {		// allow for the expecting
 	
           if (freeblocks > NEC_databurstval)							// send the least widnow or space.
            	MAX_block_request = (int)(max_completed_block + NEC_databurstval); 		// maintaining the window
           else {// Debug
           	MAX_block_request = (int)(max_completed_block + freeblocks);
           } 
            
	   if ((stream_end_block != 0)&&(MAX_block_request > stream_end_block))	{// if set
	   		MAX_block_request = (int)stream_end_block;
	   }
	   
	   if (MAX_block_request > server->getMaxRequestedBlock()){
#ifdef DEBUG
	//Debug("Ack %i - %i", MAX_block_request, max_completed_block);
#endif
               if (server->SendAck(MAX_block_request, max_completed_block) == ErrorOccurred) {
         		err = &(server->ReturnCopyOfError());
          		result = ErrorOccurred;
               }
           }
        } // if free blocks
    return result;        
}

int          
Source::calculatePosNAKSequence(callback_flag *callback_flags, Server *server, ULONG max_block)
{
  // this method could possibly be called in interrupt mode so don't change anything just read
        MemBlock *mb;
        int naks_sent = 0, i; 
        int dgm, min_val, max_val;	// nak calcs
        
        int result = !ErrorExists();
        
	if ((stream_end_block != 0)&&(max_block > stream_end_block)) {	// if set
			max_block = stream_end_block;
	}
        
        
        for (i = (int)(max_completed_block+1); ( (i <= max_block)&&(result!=ErrorOccurred) ); i++) {
               if (((mb = findBlock(i)) == NULL)||(mb->dgrams_received == 0))	{// rare block missing case
                 	naks_sent++;
                 	result = server->SendNak(i, 0, i, -1);
               }
               else 
	       if ((mb->inuse)&&(!mb->completed)) {
               		dgm = 0;                 	  	                 	  	
               		while ((dgm < mb->dgrams_in_block)&&(result != ErrorOccurred)){
               	  		while ((mb->nec_block.iov[dgm].iov_base != NULL)&&(dgm < mb->dgrams_in_block)) dgm++;
               	  		
               	  		min_val = dgm;
                		  	
               	  		while ((mb->nec_block.iov[dgm].iov_base == NULL)&&(dgm < mb->dgrams_in_block)) dgm++;
                 		  			
               	  		max_val = dgm - 1;

                		if (min_val <= max_val){
                 			  naks_sent++;
                 			  mb->pending_nak = 1;
                 			  result = server->SendNak(mb->block_id, min_val, mb->block_id, max_val);
                 			}
                 	}// while datagrams      
               }// in use and not completed
         }// for loop
         
	if (naks_sent != 0){
		(*callback_flags) = (callback_flag)((*callback_flags) | callback_background);
	}
	else
		(*callback_flags) = (callback_flag)((*callback_flags) & (~callback_background));

#ifdef DEBUG
        Debug("window %i-%i", server->getMaxRequestedBlock(), max_completed_block);
	Debug("naks sent = %i", naks_sent);
        // result = getMiscInfo(0);
#endif         
	return result;
}
//
// Determine the size of a MemBlock structure given the maximum size of the s/g array
//
size_t Source::sizeof_MemBlock() const
{
        return offsetof(MemBlock, nec_block) + sizeof_NECBlock(dgrams_per_block);
}

//
// Create the dynamic area based on the calculated requirements.  The only error
// possible is VSP_Alloc if dynamic area creation fails, or we do not get given
// the memory that we requested.
//
int Source::createDynamicArea()
{
        _kernel_oserror *e = _swix(OS_DynamicArea,  _INR(0,8)|_OUT(1)|_OUT(3)|_OUT(5),
                0,              // reason code, create dynamic area
                -1,             // kernel allocates number,
                total_memory,   // requested size
                -1,             // do not care what address is allocated
                0x80,           // flags: not draggable in taskmanager display
                total_memory,   // maximum size that will be required
                0,              // no special handler (routine address)
                0,              // no special handler (R12 for routine)
                Module_Title,   // title for Dynamic Area

                &da_number,     // allocated dynamic area number
                &da_base,       // allocated base address
                &size_limit);   // allocated maximum size

        if (e != NULL) {
                MakeError(e);
        }
        else {
                if (size_limit < total_memory) {
                        MakeError(VSP_Alloc);
                }
                else {
                        // Woo!  We got enough memory, everything's OK so far
                        // Blank the memory out
                        (void) memset(da_base, 0, total_memory);
                }
        }

        return !ErrorExists();
}

//
// Calculate the memory limits and various sizes of objects in preparation
// for creation of the dynamic area.  The only error possible is VSP_BadErr
// raised when the Socket class was unable to read the maximum datagram size
// from the Internet module.  This may mean that you do not have Internet 5.xx
// running.
//
int Source::initLimits(size_t datagram_size)
{
	sd.setDgramSize(datagram_size + sizeof(struct udphdr));
	
        dgram_size  = sd.getDgramSize() - sizeof(struct udphdr);        
         if ((dgram_size <= sizeof(struct udphdr))||(dgram_size != datagram_size) ) {
                MakeError(VSP_DatagramSizeError);
        }
        else {
                // Calculate maximum number of datagrams per block - round value up
                dgrams_per_block = (max_block_size + dgram_size - 1) / dgram_size;
                
                total_dgrams = dgrams_per_block * max_blocks;
                
#ifdef MEM_SANE_CHECK        
         Debug("datagram_size = %i, requested %i, header = %i", dgram_size, datagram_size, sizeof(struct udphdr));
                Debug("init limits, total dgrams %i, dgram_size %i, MemBlock_size %i, maxblocks %i\n", total_dgrams, 
                dgram_size, sizeof_MemBlock(), max_blocks);
#endif
                total_memory = // Calculate total memory requirement:
                        (max_blocks *sizeof_MemBlock()) + // MemBlock array at base of dynamic area
                        (total_dgrams * dgram_size);       // NECDatagram header and payload arrays
        }

        return !ErrorExists();
}

//
// Makes all the values in the dynamic area safe.  We know that the area has been
// zero-initialised already, but any further initialisation should be carried out
// here.
//
int Source::initDynamicArea()
{
  	size_t memory_offset;	// this is to ensure that memory used is less than allocated
  	size_t i;
  	MemBlock *mb;
  	
        dgram_use = new DatagramBitfield(total_dgrams);
        if (dgram_use == 0) {
                MakeError(VSP_Alloc);
        }
        else {
                // For efficiency we want to cache these values
                // these are worked out in size_t units to avoid array type counting
                block_hd = (MemBlock *)(memory_offset = (size_t)da_base);	// base address, where blocks are 
                
                memory_offset += (max_blocks * sizeof_MemBlock());		// base for dgram headers              		
                dgram_hd = (NECDatagram *)memory_offset;
                
                memory_offset +=  (total_dgrams * sizeof(NECDatagram));		// base for dgram payloads
                dgram_data_hd = (NECPayload *)memory_offset;
        }
        for (i = 0; i < max_blocks; i++){	//AR guard word is never set
        	mb = getBlock(i);
        	if (mb != NULL)
        		mb->guard_word = MemBlock__GuardWord;
        	else {
        		MakeError(VSP_BadErr);
        	}
        }
               
#ifdef MEM_SANE_CHECK        
        Debug("Memory Map\n start = %8.8X End = %8.8X\n", (int)da_base, (((int)da_base)+total_memory));
	Debug("block_hd      @ %8.8X\ndgram_headers @ %8.8X\ndgram_payloads@ %8.8X\n",block_hd, dgram_hd, dgram_data_hd);
#endif

        return !ErrorExists();
}

//
// Public Methods
// --------------
//
//
// Constructor.  max_blocks is the maximum number of blocks to be held
// simultaneously.  Typically a value of 10 is used here.  max_block_size
// is the maximum size of each block.  This will be rounded up to be an
// exact multiple of the UDP datagram length.
//
// Errors: VSP_Alloc: the required buffers could not be claimed
//
//
Source::Source(size_t blocks)
        : max_blocks(blocks),
          da_number(-1),
          da_base(0),
          dgram_use(0),
          sd(-1),
          max_block_received(invalid_block_marker)

{
  	max_block_size = 0;
  	stream_end_block = 0;
    	// Initialisation completed successfully
        sd = sd.creat(PF_INET, SOCK_DGRAM);
        setSocketError(sd.bind());
        MakeError(VSP_SourceUninit);
}
// this is to be called after the asset presentation dialogue
int
Source::Allocate(size_t block_size, size_t initial_block_num, size_t datagram_size)
{
 	if (ErrorExists()&&(ErrorNum() == VSP_SourceUninit))
  		RemoveErr();
  		
  	max_block_size = block_size;
  	
  	if (initial_block_num < 1){
  	  MakeError(VSP_InvalidValue);
  	}
  	else 					// must be less than one by specification;
  		max_block_received = last_block_sent = max_completed_block = initial_block_num -1;
  	
       return ((!ErrorExists())&&initLimits(datagram_size)&&createDynamicArea()&&initDynamicArea());
}

//
// Destructor.  Frees any memory associated with the object.
//
// Errors: None.
//
//
Source::~Source()
{
        if (da_base != 0) {
                (void) _swix(OS_DynamicArea, _INR(0,1), 1, da_number);
        }

        if (dgram_use != 0) {
                delete dgram_use;
                dgram_use = NULL;
        }

        sd.close();
}

//
// Converts the current value of errno into a VSP module error code if result
// was less than zero.  If result was >= 0, then there was no error.
// This method allows setSocketError(some_system_call()) to wrap system calls.
//
// Errors: TCP_BadPortSpecification, TCP_UnknownServer, TCP_SocketError
//         TCP_ServerRefusedConnection
//
int Source::setSocketError(int result)
{
        if (result < 0) {
                switch (errno) {
                        default:
                                MakeError(TCP_SocketError);
                                break;
                        case ECONNREFUSED:
                                MakeError(TCP_ConnectionRefused);
                                break;
                        case ENOENT:
                                MakeError(TCP_UnknownServer);
                                break;
                        case EINVAL:
                                MakeError(TCP_BadPortSpecification);
                                break;
                }
                result = ErrorOccurred;
        }
        else {
                result = NoError;
        }

        return result;
}

//
// Declares where the UDP packets are going to be coming from.  Port number
// may be specified as a number or a well-known service name.  Quoting a
// service "name" which is actually a string representation of a numeric value
// is treated as an explicit port selection.
//
// Errors: TCP_BadPortSpecification, TCP_UnknownServer, TCP_SocketError
//         TCP_ServerRefusedConnection
//
//
int Source::setServerDetails(const char *hostname, int port)
{
        sd.eventsOn();
        sd.makeNonBlocking();
        return setSocketError(sd.connect(hostname, htons(port)));
}

int Source::setServerDetails(const char *hostname, const char *port)
{
        sd.eventsOn();
        sd.makeNonBlocking();
        return setSocketError(sd.connect(hostname, port, "udp"));
}

int Source::setServerDetails(struct in_addr address, int port)
{
        sd.eventsOn();
        sd.makeNonBlocking();
        return setSocketError(sd.connect(address, htons(port)));
}
//
// Returns the local port number being used by this Source object.  This
// information is required by the Server class for Asset Presentation Request
// messages.
//
// Errors: TCP_SocketError: Unable to bind to local port.
//
//
int Source::getLocalPort(int *port)
{
        return setSocketError(sd.getLocalPort(port));
}

//
// Gets the number of full blocks pending and the maximum number of bufferable
// blocks as set in the constructor.
//
// Errors: None.
//
//
int Source::getBlockStatus(size_t *num_blocks, size_t *max_blocks_r, size_t *num_free)
{
        
        
        if (num_blocks != 0 || num_free != 0) {
        	size_t n;
        	size_t full_blocks = 0;
        	size_t empty_blocks = 0;
        	
                for (n = 0; n < max_blocks; n++) {
                        MemBlock *mb = getBlock(n);
                        if (!mb->inuse) empty_blocks++;
                        else if (mb->completed) full_blocks++;
                }
                if (num_blocks != 0) *num_blocks = full_blocks;
                if (num_free != 0) *num_free = empty_blocks;
        }
        
        if (max_blocks_r != 0) {
                *max_blocks_r = max_blocks;
        }

        return NoError;
}


//
// Gets a pointer to the next completed complete block.  Changes to the
// data structures associated with the block are locked out until the
// block is freed with a call to the freeBlock method.
//
// Errors: VSP_NoDataAvailable
//
//
int Source::getBlock(NECBlock **block)
{
        // Look for next block number (last_block_sent+1)
        MemBlock *mb;
        int result = !ErrorExists();
        
#ifdef DEBUG        
        if (result != NoError){
        	if (err != NULL)
        		err->Print();//Debug("error before trying to get block %i\n", ErrorNum());
        	else
        		Debug("error in get block not its own\n");
        }
#endif        	
        mb = findExistingBlock(last_block_sent + 1);
        
        if (mb != NULL && mb->inuse && mb->completed) {
          	result = memMemBlockToNECBlock(mb, block);
          	(*block)->iov_size = mb->dgrams_in_block;
                ++last_block_sent;
#ifdef MEM_SANE_CHECK        
                int dgram_num;
                NECDatagram* header;
                Debug("block[%i] = %i dgrams", mb->block_id, (*block)->iov_size);
                for (int i = 0; i < mb->dgrams_in_block; i++){
                  dgram_num = findDatagramNumber((NECPayload*)(mb->nec_block.iov[i].iov_base));
                  header = &dgram_hd[dgram_num];
                  Debug("grab %i = dgram [%i][%i] @ %8.8X - %i", i , header->block_number, header->dgram_seq, 
                  					(mb->nec_block.iov[i].iov_base), (mb->nec_block.iov[i].iov_len));
                }
#endif
       }
        else {
                *block = 0;
                //MakeError(VSP_NoDataAvailable);
                //result = ErrorOccurred;
        }
     return result;
}

//
// Releases the specifed block structure.  The data structures associated
// with the block are marked available for re-use.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
int Source::freeBlock(const NECBlock *block)
{
  MemBlock *mb;
         
  int result = memNECBlockToMemBlock(block, &mb);
  if (result != ErrorOccurred)
  	mb->to_be_freed = 1;
#ifdef DEBUG
   else
	Debug("error in free routine");
#endif	  
  return result;
}

  
int Source::freeBlock_background(MemBlock *mb)
{
       int result = !ErrorExists();
                    
       if (result == NoError) {
                // De-allocate all the datagrams associated with this block
                size_t i;
                
#ifdef MEM_SANE_CHECK        
                int dgram_num;
                NECDatagram* header;
                
                for (int j = 0; j < mb->dgrams_in_block; j++){
                  dgram_num = findDatagramNumber((NECPayload*)(mb->nec_block.iov[j].iov_base));
                  header = &dgram_hd[dgram_num];
                  	Debug("free %i = dgram [%i][%i] @ %i", j , header->block_number, header->dgram_seq, dgram_num);
                	result = NoError;
                }
#endif                
                for (i = 0; ((i<dgrams_per_block)&&(result!=ErrorOccurred)); ++i) {
                        NECPayload *payload = (NECPayload *)mb->nec_block.iov[i].iov_base;
                        if (payload != NULL) {
                               result = memFreeDatagram(findDatagramNumber(payload));
                        }
                        mb->nec_block.iov[i].iov_base = NULL;
                }
#ifdef DEBUG                
                if (result == ErrorOccurred) Debug("free block exit early\n");
#endif                
               mb->block_id = 0;
               mb->completed = 0;
               mb->inuse = 0;
               mb->to_be_freed = 0;
        }
       
       return result;
}


//
// Informs the Source object that an external signal has occurred (event or
// interrupt) that may be relevant to the Source object.  Source object can
// handle it as it pleases.  Use of private_handle is not yet defined.
// What this method may and may not do depends upon the host environment.
// Code that may not be executed in this method due to environment (eg. being
// in an interrupt handler) must be placed inside the foregroundExecute method.
//
// Errors: None.
//
//
int Source::backgroundExecute(callback_flag *callback_flags, Server *server)
{
        // If this method is called PURELY as a result of Internet events, then
        // it may consider itself to be running on a callback (because the Internet
        // module only issues events during its own callback.
#ifdef DEBUG
	Debug("stream saver called");
        //int result = getMiscInfo(0);
        int result =  calculatePosNAKSequence(callback_flags, server, server->getMaxRequestedBlock());
        return result;
#else
        return calculatePosNAKSequence(callback_flags, server, server->getMaxRequestedBlock()); 
#endif	        
        
        
        
}


//
// Allows the Source object foreground execution time so that it can perform
// operations not permitted in the interrupt method.  Use of private_handle is
// not yet defined.
//
// Errors: None.
//
//
int Source::foregroundExecute(callback_flag *callback_flags, Server *server, int *full_blocks)
{
        int size;
        int dgrams_read = max_datagram_read;	// greedy calculation
        
        int result = !ErrorExists();
               
        size = 1;
         
        while (( size > 0)&&(result != ErrorOccurred)){
           
        	result = memReadDatagram(callback_flags, &size, server);
           
           	if (--dgrams_read < 0) { 				// have we read out quota
          		(*callback_flags) = (callback_flag)((*callback_flags) | callback_foreground); 	// set callback;
           		break;
           	}
         }
         
         // free blocks
         for (int i = 0; ( (i < max_blocks)&&(result != ErrorOccurred)); i++) {
                MemBlock *mb = getBlock(i);
                if (mb->to_be_freed != 0)
                	freeBlock_background(mb);
         }
         
         // ack calc
         result = calculatePosAckSequence(server);
         
         (*full_blocks) = (int)(max_completed_block - last_block_sent);
         
         if (stream_end_block != 0){
         	if (stream_end_block != max_completed_block)
         		(*callback_flags) = (callback_flag)((*callback_flags) | callback_background);
         }
         else
         if (max_completed_block != server->getMaxRequestedBlock()){
         	(*callback_flags) = (callback_flag)((*callback_flags) | callback_background);
         }
	 return result;
}

//
// Informs a Source object that a dynamic area has been renumbered.  Each
// object needs to check whether its own dynamic area is the one being
// renumbered and note the change for future reference.
//
// Errors: None.
//
int Source::serviceDynamicAreaRenumber(int old_id, int new_id)
{
        if (old_id == da_number) {
                da_number = new_id;
        }
        return NoError;
}

//
// Gets the underlying socket object being used for UDP datagram reception
// by the Source class.
//
// Errors: None.
//
int Source::getSocket(Socket *s)
{
        int result;
        if (sd.valid()) {
                *s = sd;		// block copy
                result = NoError;
        }
        else {
          	RemoveErr();		// remove the uninit error
                MakeError(TCP_SocketError);
                result = ErrorOccurred;
        }

        return result;
}


//
// Private Methods
// ---------------
//
//
// Maps an internal MemBlock object to an externally visible NECBlock object.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
int Source::memMemBlockToNECBlock(const MemBlock *block, NECBlock **nec_block)
{
        int result = validateMemBlock(block);

        if (result == NoError) {
                *nec_block = (NECBlock *) &block->nec_block;
        }

        return result;
}


//
// Maps an externally visible NECBlock object to an internal memBlock object.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
int Source::memNECBlockToMemBlock(const NECBlock *block, MemBlock **mem_block)
{
        int result = validateNECBlock(block);

        if (result == NoError) {
                *mem_block = (MemBlock *) (((char *) block) - offsetof(MemBlock, nec_block));
        }

        return result;
}


//
// Reserves an MemBlock data structure from the block pool.  Returns NULL if
// none were available, otherwise the returned block is re-initialised ready
// for receiving information from the network.
//
//
int Source::memAllocateBlock(MemBlock **block, size_t *block_num)
{
        int result = NoError;
        size_t i, j;
        /*
        MemBlock *mb;	// Debug
        int n, m, count = 0, dgram_count;
        for (n = 0; n < max_blocks; n++) {
          mb = getBlock(n);
          dgram_count = 0;
          for (m=0; m< dgrams_per_block; m++)
          	if (mb->nec_block.iov[m].iov_base != NULL)
          	  	dgram_count++;
          count += dgram_count;
          Debug("[%i].block_id = %i, uses %i, inuse %i, complete %i\n", n, mb->block_id, dgram_count, mb->inuse, mb->completed);
        }
        */
        for (i = 0; i < max_blocks; i++) {
                MemBlock *mb = getBlock(i);
                if (!mb->inuse) {
                        mb->inuse = 1;
                        mb->completed = 0;
                        mb->block_id = invalid_block_marker;
                        mb->dgrams_received = 0;		// AR
                        mb->dgrams_nakd = 0;			// AR
                        *block = mb;
                        if (block_num != 0) {
                                *block_num = i;
                        }
                        for (j = 0; ((j< dgrams_per_block)&&(result != ErrorOccurred)); ++j)	// AR initialising buffer
                        	if (mb->nec_block.iov[j].iov_base != NULL){
#ifdef DEBUG                        	  
                        	  Debug("deleting a block that should be zero %i\n", findDatagramNumber((NECPayload*)(mb->nec_block.iov[i].iov_base)));
#endif
                        	  result = memFreeDatagram(findDatagramNumber((NECPayload*)mb->nec_block.iov[j].iov_base));
                        	  mb->nec_block.iov[j].iov_base = NULL;
                        	}
                        break;
                }
        }

        if (i == max_blocks) {
                *block = 0;
                MakeError(VSP_Alloc);
                result = ErrorOccurred;
        }

        return result;
}


//
// Releases a previous block allocation.  Datagram buffers for the block also
// released.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
int Source::memReleaseBlock(MemBlock *block)
{
        int result = validateMemBlock(block);
        if (result == NoError) {
                block->completed = 0;
                if (block->inuse) {
                        block->inuse = 0;
                        freeBlock(&block->nec_block);
                }
        }

        return result;
}


//
// Locates a free datagram buffer
//
// Errors: VSP_Alloc: Datagram store has been exhausted.  This
//         error should never occur unless faulty configuration information has
//         been supplied on object instantiation.
//
//
int Source::memFindFreeDatagramBuffer(NECDatagram **datagram)
{
        size_t n = 0;
        int result = dgram_use->allocate(&n);
        
        //Debug("alloc %i", n);

        if (result != NoError) {
                MakeError(VSP_Alloc);
        }
        else {
                *datagram = dgram_hd + n;
        }

        return result;
}

//
// Frees the specified datagram buffer.
//
// Errors: VSP_BadErr: block pointer/number was illegal - this is a fatal
// internal error
//
int Source::memFreeDatagram(size_t number)
{
  	//Debug("free %i", number);
  	
        int result = dgram_use->deallocate(number);
        
        if (result == ErrorOccurred) {
                MakeError(VSP_BadErr);
        }
        return result;
}

int Source::memFreeDatagram(const NECDatagram *dgram)
{
  size_t elem = (((char*)dgram - (char*)dgram_hd)/sizeof(NECDatagram));
  
  //Debug("free datagram %8.8X, element %i\n", dgram, elem);
  
      return memFreeDatagram(elem);
}

//
// Reads a pending datagram into a free datagram buffer and links it into the
// block's scatter array.
//
// Errors: TCP_ReadFail, VSP_Alloc
//
//
int Source::memReadDatagram(callback_flag *flags, int *size, Server *tcp_link)
{
        int r;
        NECDatagram *dgram;
        
        r = memFindFreeDatagramBuffer(&dgram);
        
#ifdef MEM_SANE_CHECK        
        size_t a, b, c;
        
        if (r == ErrorOccurred){
          	getBlockStatus(&a, &b, &c);
        	Debug("error allocating datagram header, a = %i, b = %i, c = %i\n", a, b, c);
        }
        if ( ((int)dgram <  (int)dgram_hd) || ((int)dgram >=  (int)dgram_data_hd) )
 		Debug("datagram out of range @%8.8X, r = %i\n", dgram, r);
 	else	
#endif
        if (r == NoError) {
                struct iovec iov[2];
                
                iov[0].iov_len = sizeof(NECDatagram);
                iov[1].iov_len =  (unsigned int)(dgram_size - sizeof(NECDatagram)) ;
                
                iov[0].iov_base = (char*) dgram;
#ifdef MEM_SANE_CHECK        
		char *ptr =  (char*) findPayloadBuffer(dgram); 
        	if ( ((int)ptr <  (int)dgram_data_hd) || ((int)dgram >= ((int)da_base)+total_memory) )
 			Debug("datagram payload out of range @%8.8X, r = %i\n", ptr, r);
 			
 		iov[1].iov_base = ptr;
#else              
                iov[1].iov_base = (char*) findPayloadBuffer(dgram);  
#endif
                //Debug(" attempt to read into %8.8X, %8.8X, sizes resp. %i, %i\n", iov[0].iov_base, iov[1].iov_base
                //								, iov[0].iov_len,  iov[1].iov_len);
                                               
                (*size) = sd.read(iov,sizeof(iov)/sizeof(struct iovec));
                      
                 switch (*size) {
                       case -1:
                               if (errno != EWOULDBLOCK) {
                                        MakeError(TCP_ReadFail);
                                        r = ErrorOccurred;
                                }
                                else {
                                        // Read datagram successfully
                                }
                                break;
                        case 0:
                        	// Debug("empty read\n");
                                // Erk?  How can a datagram socket be closed!
                                break;
                        default:
                        	ntoh_structure(dgram, map_NECDatagram, NECDatagram);
                                if ((*size) < sizeof(NECDatagram)) {
                                        // Oh erk - this datagram was way too short
                                        MakeError(TCP_ReadFail);
                                        r = ErrorOccurred;
                                }
                                break;
                }
                                
                if ((*size <= 0)||(r != NoError)) {
                        r = memFreeDatagram(dgram);
                        (*size) = 0;
                }
                else {
#ifdef DEBUG                  
                  //Debug("dgram [%i][%i] size = %i", dgram->block_number, dgram->dgram_seq, dgram->dgram_size);
#endif                  
                        // OK - try and associate it with a block
                        r = linkDatagramToBlock(flags, dgram, tcp_link);
                }
        }
        return r;
}


//
// Link a received datagram to its matching block.  Allocate the block if
// possible.  If it is a duplicate, free the datagram and return NoError.
// If block is now completed, set the flag in the MemBlock indicating this.
//
// Errors: VSP_Alloc: no free block buffers, or packet was duplicate.
//
int Source::linkDatagramToBlock(callback_flag *flags, NECDatagram *dgram, Server *tcp_link)
{
         int i;
         size_t free_buffers;
         int result = !ErrorExists();
	
        if (dgram->dgram_seq >= dgrams_per_block) {
#ifdef DEBUG          
          	Debug("datagram allocation error not enough datagrams\n");
#endif
                MakeError(VSP_Alloc);
                result = ErrorOccurred;
        }
        else {
                MemBlock *mb = NULL;
                size_t index;
		
	    if (dgram->block_number <= max_completed_block){
		  // old datagram , the block may even be used by other classes
		  // remove the datagram now.
		  //Debug("deleting old block [%i] max %i", dgram->block_number, max_completed_block);
		   result = memFreeDatagram(dgram);	// old dgram come to haunt a read block	
	    }
	    else {	// assume it is an old block
                if (dgram->block_number <= max_block_received) { 	// result of a nak or as expected
                	mb = findBlock(dgram->block_number, &index);
                	if (mb != NULL) {                // deleted block datagram	  	
                	        if ((mb->completed != 1)&&(dgram->dgram_seq == 0)&&(dgram->status_word&0x01)){
#ifdef DEBUG                	          
                	        	Debug("deleted block[%i], %i missing datagrams\n", mb->block_id, 
                	        			mb->dgrams_in_block - mb->dgrams_received);
#endif                	        			
               	        		for (i=0; i < mb->dgrams_in_block; i++) {
               	        			if (mb->nec_block.iov[i].iov_base == NULL){
               	        		  		mb->nec_block.iov[i].iov_base = (char *) findPayloadBuffer(dgram);
               				  		mb->nec_block.iov[i].iov_len = (unsigned int) dgram->dgram_size;
               				  	}
               	                        }
               	                        mb->dgrams_received = mb->dgrams_in_block;
               	                        mb->dgrams_nakd = 0;	
      			  		mb->completed = 1;
			  		mb->pending_nak = 0;	// denote deleted block
			  		calculateMaxCompleteBlock();
               	                } 
               	                else {
               				if (linkDatagramToBlock(dgram, mb, tcp_link) == ErrorOccurred)
			  			result = ErrorOccurred;
					else {	
						if ((mb->dgrams_received == mb->dgrams_in_block)&&(mb->dgrams_in_block != 0 ) ){
			  				mb->completed = 1;	// completed block
			  				mb->pending_nak = 0;
			  				mb->dgrams_nakd = 0;
			  				calculateMaxCompleteBlock();
			  			}
			  		}
			  	}
              	        }
                	else{
                	  	// we have found a datagram for a block greater than greatest complete
                	  	// but less than the most recent recieved. But cannot allocate the space for it
#ifdef DEBUG                	  
                	  	Debug("no block between %i & %i for %i", max_block_received, max_completed_block, dgram->block_number);
#endif                	  	
                 	  	MakeError(VSP_Alloc);
                 	  	result = ErrorOccurred;
			}
                } else {	// new block number
			result = calculatePosNAKSequence(flags, tcp_link, max_block_received-1);
			mb = findExistingBlock(max_block_received, &index);	// calculate outstanding datagrams
			if (mb != NULL) {	// if not first block, send nak from max datagram seq - new block-dgram->seq
				if (mb->dgrams_received+mb->dgrams_nakd < mb->dgrams_in_block) {
					mb->pending_nak = 1;
				  	if (dgram->dgram_seq == 0){	// if this datagram is the first of the new block
						if (tcp_link->SendNak(max_block_received,(mb->dgrams_received+mb->dgrams_nakd),
							max_block_received, -1) == ErrorOccurred)
							result = ErrorOccurred;
					}
					else{ 				// otherwise send nak accross
						if (tcp_link->SendNak(max_block_received,(mb->dgrams_received+mb->dgrams_nakd),
							dgram->block_number, (LINT)dgram->dgram_seq) == ErrorOccurred)
							result = ErrorOccurred;
					}
				}
			}
			// sort this new block
			getBlockStatus(0, 0, &free_buffers);
			if ( (dgram->block_number - max_block_received) <= free_buffers ) {	// can we accomodate this radical new block?
                		mb = findBlock(dgram->block_number, &index);			// find or allocate the new block
              			if (mb != NULL) {
                 			max_block_received = dgram->block_number;
                 			if (linkDatagramToBlock(dgram, mb, tcp_link) == ErrorOccurred)
			  			result = ErrorOccurred;
					else
					if ( (mb->dgrams_received == mb->dgrams_in_block)&&(mb->dgrams_in_block != 0)){
			  			mb->completed = 1;	// completed
			  			mb->pending_nak = 0;
			  			mb->dgrams_nakd = 0;
			  			calculateMaxCompleteBlock();
			        	}
                		} else{
#ifdef DEBUG                		  
	                  		Debug("unable to find block\n"); 
#endif	                  	
                        		MakeError(VSP_Alloc);
                        		result = ErrorOccurred;
  			        }
			}
			else { // no room at the inn
#ifdef DEBUG			
				Debug("out of range dgram [%i-%i], max = %i, free%i\n ",dgram->block_number, dgram->dgram_seq, 
												max_block_received, free_buffers);
#endif											
                	   	result = memFreeDatagram(dgram);
			}
                }
            } // datagram less than max_completed
        }
#ifdef DEBUG        
        if (result != NoError) Debug("error in dgram level\n");
#endif       
        return result;
}

// ties a datagram to a specific memory block found on the basis of block number
int Source::linkDatagramToBlock(NECDatagram *dgram, MemBlock *mb, Server *tcp_link)
{
        int result = NoError;
     
        struct iovec *iov = &mb->nec_block.iov[dgram->dgram_seq];	// lookup the datagram's slot within the memblock

        if (iov->iov_base != 0) {
                memFreeDatagram(dgram);
                return NoError;
        }
        else {
        	if (dgram->dgram_seq < (mb->dgrams_received+mb->dgrams_nakd)) {
          	       	if ((--mb->dgrams_nakd)==0){
          			mb->pending_nak = 0;
		        }	// completion will be caught in the block level routine
               }
               iov->iov_base = (char *) findPayloadBuffer(dgram);
               iov->iov_len = (unsigned int) dgram->dgram_size;
               mb->dgrams_received++;
               mb->sum_so_far += iov->iov_len;
               
               if (dgram->dgram_total != 0)
               		mb->dgrams_in_block = (unsigned int) dgram->dgram_total;
        }
     		// forward jump in dgrams same block send NAK for the missing
        if (dgram->dgram_seq > (mb->dgrams_received+mb->dgrams_nakd)){
                  tcp_link->SendNak(dgram->block_number, (mb->dgrams_received + mb->dgrams_nakd), 
                   						dgram->block_number,(LINT)(dgram->dgram_seq -1) );
                  mb->dgrams_nakd = (size_t) dgram->dgram_seq - (mb->dgrams_received - 1);
                  mb->pending_nak = 1;
        }
                 
                        
#ifdef DEBUG      
       if (result != NoError) Debug("error in dgram level\n");
#endif      
       return result;
}          

// Locate the payload buffer for the particular datagram
NECPayload *Source::findPayloadBuffer(size_t n) const
{
        return (NECPayload *) (((char *)dgram_data_hd) + (n * (dgram_size-sizeof(NECDatagram))) );
}

NECPayload *Source::findPayloadBuffer(NECDatagram *dgram) const
{
        return findPayloadBuffer(findDatagramNumber(dgram));
}

// Discover the datagram buffer number of the given pointer
size_t Source::findDatagramNumber(NECDatagram *dgram) const
{
        return ((char*)dgram - (char*)dgram_hd)/sizeof(NECDatagram);
}

size_t Source::findDatagramNumber(NECPayload *dgram) const
{
        return (((char *)dgram) - ((char *)dgram_data_hd)) / (dgram_size-sizeof(NECDatagram));
}

//
// This function looks to see if the block with the identifier of id
// has been allocated, and if so, where
//
MemBlock *Source::locateBlock(ULONG id)
{
        for (size_t n = 0; n < max_blocks; n++) {
                MemBlock *mb = getBlock(n);
                if (mb->inuse != 0 && mb->block_id == id) {
                        return mb;
                }
        }

        return NULL;
}

//
// This function looks to see if the block with the identifier of id
// has been allocated, and if so, what its address is.  If the block
// is not found, then it is created if possible.  If that was not
// possible, then NULL is returned.
//
MemBlock *Source::findBlock(ULONG id, size_t *block_num)
{
        MemBlock *result = NULL;
        size_t n;

        for (n = 0; n < max_blocks; n++) {
               MemBlock *mb = getBlock(n);
               if (mb->inuse != 0 && mb->block_id == id) {
                        if (block_num != 0) {
                                *block_num = n;
                        }
                        return mb;
                }
       }
	
        if (memAllocateBlock(&result, block_num) != NoError) {
                result = NULL;
        }
        else{
	       	result->block_id = id;		// AR
        }

        return result;
}

MemBlock *Source::findExistingBlock(ULONG id, size_t *block_num)
{
        MemBlock *result = NULL;
        size_t n;

        for (n = 0; n < max_blocks; n++) {
               MemBlock *mb = getBlock(n);
               if (mb->inuse != 0 && mb->block_id == id) {
                        if (block_num != 0) {
                                *block_num = n;
                        }
                        return mb;
                }
       }
       // return null if you cannot find this block
       return result;
}

//
// Examines a completed block and attempts to minimise the size of the scatter
// array by merging contiguous blocks into single blocks.  This is an
// optimisation which is performed in order to minimise the number of separate
// calls that the Stream object will have to make to the Sink object.  This
// optimisation will work best when the communication channel between the server
// and client is mostly reliable and delivers datagrams in order.
//
// Errors: None.
//
//
int Source::memOptimiseBlock(MemBlock *)
{
        // This method does not need to be implemented.  Everything will
        // function just fine without it.
        //
        // NOTE: It is critical that this routine does not interfere at this
        //       stage, because the memory management routine cannot cope with
        //       merged blocks (yet).
        //
        return NoError;
}


////////////////////////////////////////////////////////////////////////////////////////

//
// Datagram bitfield management class.
//
DatagramBitfield::DatagramBitfield(size_t max_dgrams) :
        max_dgram(max_dgrams),
        b(0)
{
  	alloc = free = 0;	//Debug
        const size_t bits_per_word = CHAR_BIT * sizeof(*b);
        max_words = (max_dgrams + bits_per_word - 1) / bits_per_word;
        b = new bitfield[max_words];
        if (ok()) clear();
}

DatagramBitfield::~DatagramBitfield()
{
        delete[] b;
        b = NULL;
}

int DatagramBitfield::ok() const
{
        return b != 0;
}

void DatagramBitfield::clear()
{
        (void) memset(b, 0, max_words * sizeof(*b));
        size_t max_bit = bit_mask(max_dgram);
        if (max_bit > 1) {
                // max_dgram wasn't an exact number of words.  Therefore 'claim' the
                // datagrams that lie beyond the limit of available datagram numbers
                // so that they don't get accidentally allocated.
                size_t w = word_no(max_dgram);
                b[word_no(max_dgram)] |= ~(max_bit-1);
        }
}

size_t DatagramBitfield::word_no(size_t n) const
{
        return n / (CHAR_BIT * sizeof(*b));
}

size_t DatagramBitfield::bit_mask(size_t n) const
{
        return 1UL << (n % (CHAR_BIT * sizeof(*b)));
}

int DatagramBitfield::isFree(size_t n) const
{
        return (n < max_dgram) && ((b[word_no(n)] & bit_mask(n)) == 0);
}

//
// Allocate an explicit datagram.  The datagram MUST be free - no check will be made here.
//
int DatagramBitfield::allocate(size_t n)
{
  	alloc++;
        int result = ErrorOccurred;
        if (n < max_dgram) {
                b[word_no(n)] |= bit_mask(n);
                result = NoError;
        }
        return result;
}

int DatagramBitfield::allocate(size_t *n)
{
        size_t i;
        int result = ErrorOccurred;
        alloc++;

        for (i=0; i < max_words; ++i) {
               // Awooga - find lowest unset bit in word.  This *does* work - promise!
                // The general algorithm here is to find the lowest bit *set*, so we invert
                // the value at the start so that we are finding the lowest set bit.
                // Then noting that x & (~x + 1) (=> x & -x) gives just the lowest set bit,
                // binary search the word for the single set bit.
                	const bitfield b_i_invert = ~b[i];
                	bitfield bit = b_i_invert & -b_i_invert;
               // Check word for being completely full (ie. ~word == 0)
                if (bit == 0) continue;
                // There is one.  Set bit to claim datagram, then proceed to find the bit position
                b[i] |= bit;
                // Find position.  (This loop compiles to compact ARM assembler
                // to calculate the full value to store in *n)
                size_t index = 0;
                size_t bitno;
                for (bitno = (CHAR_BIT * sizeof(*b) / 2); bitno > 1; bitno >>= 1) {
                        if (bit >> bitno) { bit >>= bitno; index += bitno; }
                }
                *n = (size_t) ((i * CHAR_BIT * sizeof(*b)) + index + bit) - 1;	// AR sub 1 as array overshot 

                result = NoError;
                break;
        }
#ifdef DEBUG        
        if (result == ErrorOccurred) {
          Dump();
                  for (i=0; i < max_words; ++i)
        	Debug("word [%i] = %8.8X\n",i ,b[i]);
        }
#endif       	
        return result;
}

int DatagramBitfield::deallocate(size_t n)
{
  	free++;
        int result = ErrorOccurred;
        if (n < max_dgram) {
                b[word_no(n)] &= ~bit_mask(n);
                result = NoError;
        }
        return result;
}
#ifdef DEBUG
int DatagramBitfield::Dump(void)
{
  //int i;
        Debug("used = %i\n", alloc - free);
        	
  return NoError;
}
#endif
