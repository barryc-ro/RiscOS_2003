/**************************************
 Source.c++

implements Source class
© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
03/09/98  SNB     File created

**************************************/
extern "C" {
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

// Current Clib stddef.h does not define a C++ compatible offsetof
#undef offsetof
#define offsetof(type, member) \
    ((size_t)((char *)&(((type *)0)->member) - (char *)0))

#include "kernel.h"
#include "swis.h"
}

#include "SourceP.h"
#include "Source.h"

extern "C" {
#include "sys/ioctl.h"
#include "netinet/udp.h"
}


Statistics::Statistics(void)
{
  last_stream_bytes_received = 0;
  last_stream_time = 0;
  last_stream_acks = 0;
  last_stream_naks = 0;
  
  dgrams_read = 0;
  duplicate_dgrams = 0;
  acks_sent = 0;
  naks_sent = 0;
  block_naks_sent = 0;
  deleted_blocks = 0;
  bytes_received = 0;
} 

void
Statistics::print(void)
{
  int bandwidth;
  
  
  if (last_stream_time > 100){
  	bandwidth = last_stream_bytes_received + (last_stream_acks *sizeof(ACK_Block)) + (last_stream_naks * sizeof(NAK_Block));
  	bandwidth = bandwidth / (last_stream_time/100);
  }
  else 
  	bandwidth = 0;
  
  printf(" Bandwidth usage of last stream\n");
  printf("     run time in centiseconds        %i\n", last_stream_time);
  printf("     bytes received by stream        %i\n", last_stream_bytes_received);
  printf("     bytes in the form of acks       %i\n", last_stream_acks * sizeof(ACK_Block));
  printf("     bytes in the form of naks       %i\n", last_stream_naks * sizeof(NAK_Block));
  printf("     Total bandwidth  (bytes/sec)    %i\n", bandwidth);
  printf(" Diagnostics for all streams\n");
  printf("     bytes received                  %i\n", bytes_received);
  printf("     datagrams read                  %i\n", dgrams_read);
  printf("     duplicate datagrams             %i\n", duplicate_dgrams);
  printf("     acks sent                       %i\n", acks_sent);
  printf("     naks sent                       %i\n", naks_sent);
  printf("     entire blocks nakd              %i\n", block_naks_sent);
  printf("     deleted blocks received         %i\n", deleted_blocks);
}

//---------------------------------------------------------------------- private -- run time calculations --------------------

// calculate the largest block_id for full blocks, this means that no block_id
// smaller shall be incomplete and no block_id greater shall be complete.

error_flag
Source::calculateMaxCompleteBlock(void)
{
  MemBlock *mb;
   
  while (((mb = mem_map->findExistingBlock(max_completed_block+1)) != NULL)&&(mb->inuse)&&(mb->completed))
  	max_completed_block++;
  
  full_blocks = (int)(max_completed_block - last_block_sent);
  	
  return ErrorState();
}

error_flag 
Source::calculatePosAckSequence(Server *server, Statistics *stats)
{
  server = server;
  stats = stats;
  
  return NoError;
}

error_flag 
Source::calculatePosNAKSequence(Server *server, Statistics *stats, int *naks)
{
  server = server;
  stats = stats;
  naks = naks;
  
  return NoError;
}
               	
//---------------------------------------------------------------------- public -- object creation/deletion methods --------------------
// this creates the udp link and sets local variables
// 
Source::Source(int set_nak_timeout, int source_recvspace)
{
  	stream_end_block = current_play_id = full_blocks = 0;
  	
   	mem_map = NULL;
  	
        nak_block = 0;
        nak_timeout = set_nak_timeout;
        most_significant_time = 0;
  	
  	
    	// Initialisation completed successfully
        sd = sd.creat(PF_INET, SOCK_DGRAM);
        setSocketError(sd.bind());
        
        sd.setrecvspace(source_recvspace);
}
// this is used so VOD can become LIVE and visa versa.

void 
Source::SetSourceVar(Socket *socket, SourceMemMap **mem)
{ 
	(*socket) = sd; 
	(*mem) = mem_map;
	
	mem_map = NULL;	// the socket is still non zero but this is used in a test in the destructor
}
 
// this is to be called after the asset presentation dialogue
error_flag
Source::Allocate(size_t max_blocks, size_t block_size, size_t initial_block_num, size_t datagram_size)
{
  	error_flag result = ErrorState();
  	
 	if ((result == ErrorOccurred)&&(ErrorNum() == VSP_SourceUninit))
  		RemoveErr();	// if source memory not allocated error has occurred it is no longer relevant
  	
	if (result != ErrorOccurred) {	
  		if (initial_block_num < 1){
  		  	result = MakeError(VSP_InvalidValue);
  		}
  		else {					// must be greater than one by specification;
  			//max_block_received = 
  			last_block_sent = max_completed_block = initial_block_num -1;
        	
        		if (datagram_size <= sizeof(struct udphdr)) {
        		        result = MakeError(VSP_DatagramSizeError);
        		}
 			else {	
   				mem_map = new SourceMemMap(max_blocks, block_size + sizeof(struct udphdr), datagram_size);
   		
   				if (mem_map->ErrorState() == ErrorOccurred){
   				  	err = &(mem_map->ReturnCopyOfError());	// this will be VSP_Alloc
   		  			delete mem_map;
   		  			mem_map = NULL;
   		                }
   		        }
   	        }
   	}
       	return result;
}

//
// Destructor.  Frees any memory associated with the object.
//
// Errors: None.
//
//
Source::~Source(void)
{
  	if (mem_map != NULL){
  		delete mem_map;
  		mem_map = NULL;
#ifdef DEBUGLIB  	
		Debug("delete source socket +");
       		sd.close();
		Debug("delete source socket -");
#else	
        	sd.close();
#endif        
        }
}

//
// Converts the current value of errno into a VSP module error code if result
// was less than zero.  If result was >= 0, then there was no error.
// This method allows setSocketError(some_system_call()) to wrap system calls.
//
// Errors: TCP_BadPortSpecification, TCP_UnknownServer, TCP_SocketError
//         TCP_ServerRefusedConnection
//
error_flag
Source::setSocketError(int socket_result)
{
    error_flag result = ErrorState();
        
    if ((result != ErrorOccurred)&&(socket_result < 0)) {
           switch (errno) {
                 default:
                        result = MakeError(TCP_SocketError);
                        break;
                 case ECONNREFUSED:
                        result = MakeError(TCP_ConnectionRefused);
                        break;
                 case ENOENT:
                        result = MakeError(TCP_UnknownServer);
                        break;
                 case EINVAL:
                        result = MakeError(TCP_BadPortSpecification);
                        break;
                }
        }
        return result;
}

//
// Declares where the UDP packets are going to be coming from.  Port number
// may be specified as a number or a well-known service name.  Quoting a
// service "name" which is actually a string representation of a numeric value
// is treated as an explicit port selection.
//
// Errors: TCP_BadPortSpecification, TCP_UnknownServer, TCP_SocketError
//         TCP_ServerRefusedConnection
//
//
error_flag
Source::setServerDetails(const char *hostname, int port)
{
        sd.eventsOn();
        sd.makeNonBlocking();
        return setSocketError(sd.connect(hostname, htons(port)));
}

error_flag
Source::setServerDetails(const char *hostname, const char *port)
{
        sd.eventsOn();
        sd.makeNonBlocking();
        return setSocketError(sd.connect(hostname, port, "udp"));
}

error_flag
Source::setServerDetails(struct in_addr address, int port)
{
        sd.eventsOn();
        sd.makeNonBlocking();
        return setSocketError(sd.connect(address, htons(port)));
}
//
// Returns the local port number being used by this Source object.  This
// information is required by the Server class for Asset Presentation Request
// messages.
//
// Errors: TCP_SocketError: Unable to bind to local port.
//
//
error_flag
Source::getLocalPort(int *port)
{
        return setSocketError(sd.getLocalPort(port));
}

//
// Gets the number of full blocks pending and the maximum number of bufferable
// blocks as set in the constructor.
//
// Errors: None.
//
//
error_flag
Source::getBlockStatus(size_t *num_blocks, size_t *max_blocks_r, size_t *num_free)
{
        if (num_blocks != 0 || num_free != 0) {
        	size_t n;
        	size_t full_blocks = 0;
        	size_t empty_blocks = 0;
        	
                for (n = 0; n < mem_map->max_blocks; n++) {
                        MemBlock *mb = mem_map->getBlock(n);
                        if (!mb->inuse) empty_blocks++;
                        else if (mb->completed) full_blocks++;
                }
                if (num_blocks != 0) *num_blocks = full_blocks;
                if (num_free != 0) *num_free = empty_blocks;
        }
        
        if (max_blocks_r != 0) {
                *max_blocks_r = mem_map->max_blocks;
        }

        return NoError;
}

// this clears the source and sets the play state to -1 so no more is added to the source
// ie. from this time until state is moved out of stop nothing will be placed into the 
// source data structures.
void
Source::setEndPlayState(void)
{
   	current_play_id = -1;
   	nak_block = 0;
   	if ((mem_map != NULL)&&(mem_map->blockReset() == ErrorOccurred))
   		err = &(mem_map->ReturnCopyOfError());
   	  	
        full_blocks = 0; 
}

// this routine dumps all blocks and sets the play state to a new value so the source holds blocks
// for the new play method.

error_flag
Source::setNewPlayState(int *play_state, int *request_num, int *max_complete, int play_mode)
{
	size_t freebuf;
	int i;
	error_flag result = ErrorState();
	nak_block = 0;
  	
  	if (current_play_id >= 0xFFFFFF)// rotate play id
  		current_play_id = 0;	// this avoids negative numbers -1 of which is used for end of stream

     	(*play_state) = ++current_play_id;
     	
   	if ((mem_map != NULL)&&(mem_map->blockReset() == ErrorOccurred))
   		err = &(mem_map->ReturnCopyOfError());

        full_blocks = 0;
         
        result = getBlockStatus(0, 0, &freebuf);
     	if (freebuf > NEC_databurstval)
   		freebuf = NEC_databurstval;
   		// this adds a margin just outside any possibly requested block
   	if (play_mode == 7)
		(*max_complete) = (int)(last_block_sent = (max_completed_block = 0));
	else
		(*max_complete) = (int)(last_block_sent = (max_completed_block += NEC_databurstval+1));
	(*request_num) = (int)(max_completed_block + freebuf);
   	
   	if (play_mode != 7){
		for (i = (int)max_completed_block+1; i <= (*request_num); i++)
			mem_map->findBlock(i);
	}
  		 	
     return result;
}

//
// Gets a pointer to the next completed complete block.  Changes to the
// data structures associated with the block are locked out until the
// block is freed with a call to the freeBlock method.
//
// Errors: VSP_NoDataAvailable
//
//
error_flag
Source::getBlock(NECBlock **block, BitstreamBufferDescriptor **mpeg_buffer, int free_routine, int pw)
{
        MemBlock *mb;
        error_flag result = ErrorState();
        
        do {
        	mb = mem_map->findExistingBlock(last_block_sent + 1);
        	
        	if (mb == NULL)
        		break;
        } while (mb->deleted_block);
        	
 	if (mb != NULL && mb->inuse && mb->completed) {
        	result = mem_map->memMemBlockToNECBlock(mb, block);
          	//------- optimisation --
          	int j, i;
          	(*block)->num_buffers = 0;
          	(*block)->max_buffers = mb->dgrams_in_block;
          	if ((*block)->buffers[0].buffer_length < sizeof(NECBlockHeader)){
          		result = MakeError(VSP_DatagramSizeError);
		}
          	else
          	{
          		most_significant_time = (unsigned int)ntohl(((NECBlockHeader*)(*block)->buffers[0].buffer_ptr)->playback_time);
          		for (i = 0; i < mb->dgrams_in_block; ++i){
          		  	j = i;
          		  	while ((i+1 < mb->dgrams_in_block)&&
          		  	    ((*block)->buffers[i+1].buffer_ptr == (*block)->buffers[i].buffer_ptr + (*block)->buffers[i].buffer_length)){	
          		  		(*block)->buffers[j].buffer_length += (*block)->buffers[i+1].buffer_length;
          		  		i++;
          		  	}
          		  	if (i+1 == mb->dgrams_in_block)
          		  		(*block)->buffers[j].link = NULL;
          		  	else 
          		  		(*block)->buffers[j].link = &((*block)->buffers[i+1]);
          		  	
          		  	(*block)->buffers[j].free_routine = free_routine;
          		  	(*block)->buffers[j].free_workspace = pw;
          		  	(*block)->buffers[j].packets = 0;
          		  		
          		  	++(*block)->num_buffers;     		
          		}
                }
          	(*block)->buffers[0].buffer_ptr    +=  sizeof(NECBlockHeader);
  		(*block)->buffers[0].buffer_length -=  sizeof(NECBlockHeader);
  		
  		if ( (*block)->buffers[0].buffer_length == 0 )
    			(*mpeg_buffer) = (BitstreamBufferDescriptor*)((*block)->buffers[0].link);
    		else {
			(*mpeg_buffer) = &((*block)->buffers[0]);
		}
          	//-------
          	//(*block)->num_buffers = mb->dgrams_in_block;
                mb->mpeg_owned = 1;
                ++last_block_sent;
	}
        else 
                *block = 0;

     return result;    
}

//
// Releases the specifed block structure.  The data structures associated
// with the block are marked available for re-use.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
error_flag
Source::freeBlock(const NECBlock *block)
{
  MemBlock *mb;

         
  error_flag result = mem_map->memNECBlockToMemBlock(block, &mb);
  if (result != ErrorOccurred){
  	mb->nec_block.buffers[0].buffer_ptr    -=  sizeof(NECBlockHeader);
  	mb->nec_block.buffers[0].buffer_length +=  sizeof(NECBlockHeader);
  	mb->to_be_freed = 1;
  	mb->mpeg_owned = 0;
  }
  return result;
}

// calculates if any blocks need to be freed

error_flag
Source::calculate_freeBlocks(Server *server, callback_flag callback_pending, Statistics *stats)
{  
    	int i;
  	
 	error_flag result = ErrorState();
      	 
        for (i = 0; ( (i < mem_map->max_blocks)&&(result != ErrorOccurred)); i++) {
                MemBlock *mb = mem_map->getBlock(i);
                if (mb->to_be_freed != 0){
                	result = mem_map->freeBlock_background(mb);
                }
        }
        full_blocks = (int)(max_completed_block - last_block_sent);

        if (!(callback_pending & callback_timeout))
          	result = calculatePosAckSequence(server, stats);
                       
       return result;
}
//
// Allows the Source object foreground execution time so that it can perform
// operations not permitted in the interrupt method.  Use of private_handle is
// not yet defined.
//
// Errors: None.
//
//
error_flag
Source::foregroundExecute(callback_flag *callback_flags, Server *server, Statistics *stats)
{
    error_flag result = ErrorState();
    int naks = 0;
    	
 	if ((result != ErrorOccurred)&&(max_completed_block != server->getMaxRequestedBlock())){	// ack problem not ours
 	
 		if ((*callback_flags) & callback_block){
 	     		// we would expect to find no nak_block
 	     		nak_block = max_completed_block + 1;
 		}
             	 
 		(*callback_flags) = (callback_flag)((*callback_flags) & ~callback_timeout);
 	
 		if (nak_block == 0){	// missing datagrams have turned up
 				// in this case the callback has been placed by inet event
        		(*callback_flags) = (callback_flag)((*callback_flags) | callback_block);
        	}
        	else {           	 		
         		result = calculatePosNAKSequence(server, stats, &naks);
         		        		
        		if (naks != 0)	// -1 signifies no naks sent for time reasons
        			(*callback_flags) = (callback_flag)((*callback_flags) | callback_nak);
        	}
        }
    	else {
    		(*callback_flags) = (callback_flag)((*callback_flags) & ~callback_timeout);
    	}	
    return result;
}

//
// Informs a Source object that a dynamic area has been renumbered.  Each
// object needs to check whether its own dynamic area is the one being
// renumbered and note the change for future reference.
//
// Errors: None.
//
error_flag
Source::serviceDynamicAreaRenumber(int old_id, int new_id)
{
        if (old_id == mem_map->getDaNumber()) {
                mem_map->setDaNumber(new_id);
        }
        return NoError;
}

//
// Gets the underlying socket object being used for UDP datagram reception
// by the Source class.
//
// Errors: None.
//
error_flag
Source::getSocket(Socket *s)
{
        error_flag result;
        if (sd.valid()) {
                *s = sd;		// block copy
                result = NoError;
        }
        else {
          	RemoveErr();		// remove the uninit error
                result = MakeError(TCP_SocketError);
        }

        return result;
}
//
// Reads a pending datagram into a free datagram buffer and links it into the
// block's scatter array.
//
// Errors: TCP_ReadFail, VSP_Alloc
//
// it is a virtual function as each of the inherited forms will re define it

error_flag
Source::ReadDatagrams(callback_flag current_flags, callback_flag *flags, Server *server, Statistics *stats, int timeout)
{
  current_flags = current_flags;
  flags = flags;
  server = server;
  stats = stats;
  timeout = timeout;
  
  return NoError;
}

//---------------------------------------------------------------------- VOD specific --------------------
// this is a copy constructor allowing the conversion from a stream live to a stream stored.
SourceVOD::SourceVOD(Source& live)
{
  
  last_block_sent = live.get_most_significant_block();
  max_completed_block = last_block_sent;
  most_significant_time = live.get_most_significant_time();
  nak_block = last_block_sent;
  nak_timeout = 0;
  current_play_id = 0;		// this is the trickplay flag this changes with each new trickplay
  stream_end_block = 0;		// this is set when we know what the last block in the stream is

  live.SetSourceVar(&sd, &mem_map);

  mem_map->blockReset();
   		
  full_blocks = 0;
}
// calculate a new window period if it is different from now then notify the server this is the only
// place where a request for more blocks during normal play.  Play notifications also have Ack capability.

// freeblocks does not take into account half full blocks but this is not important. What is most important
// is that we maintain a window from the most complete block no greater than that specified by the server.
// it is better to undercalculate than overestimate.

error_flag 
SourceVOD::calculatePosAckSequence(Server *server, Statistics *stats)
{
    size_t freeblocks;
    ULINT MAX_block_request = 0;
    ULINT prior_max_request;
    error_flag result = ErrorState();
    
    
    if (result != ErrorOccurred){
	prior_max_request = server->getMaxRequestedBlock();
    	MAX_block_request = (max_completed_block + NEC_databurstval) - prior_max_request;
        
    	result = getBlockStatus(0, 0, &freeblocks);

    	if (MAX_block_request > 0) {			// if window available
		result = getBlockStatus(0, 0, &freeblocks);
		if (freeblocks > 0) {
    			if (MAX_block_request > freeblocks)
    				MAX_block_request = freeblocks;
    				
    			MAX_block_request += prior_max_request;
    			
	   		if ((stream_end_block != 0)&&(MAX_block_request > stream_end_block))	{		// if set
	   			MAX_block_request = (int)stream_end_block;
	   		}
	   		if (MAX_block_request > prior_max_request){
	   		  	++(stats->acks_sent);
	   		  	//Debug("send ack %i-%i", MAX_block_request, max_completed_block);
             			if (server->SendAck(MAX_block_request, max_completed_block) == ErrorOccurred) {
         				err = &server->ReturnCopyOfError();
          				result = ErrorOccurred;
               			}
               			MAX_block_request = server->getMaxRequestedBlock();
               			size_t block_location;
               			MemBlock *mb;
               			for (ULINT i = prior_max_request+1; i <= MAX_block_request; i++){
               				mb = mem_map->findBlock(i, &block_location);
               				if ((mb == NULL)&&(mem_map->ErrorExists())){
              				  	mem_map->RemoveErr();
               				}
               			}
               		}
	   	}
	}
    }   
    return result;        
}

error_flag          
SourceVOD::calculatePosNAKSequence(Server *server, Statistics *stats, int *naks)
{
        MemBlock *mb;
        int dgm, min_val, max_val;	// nak calcs
        error_flag result = ErrorState();
        int local_naks = 0;
        unsigned int systime;
#ifdef DEBUGLIB
	unsigned int mb_time;
#endif        
	
	if (nak_block != 0){
		_swix(OS_ReadMonotonicTime, _OUT(0), &systime);

		mb = mem_map->findExistingBlock(nak_block);
		
        	if ((mb!=NULL)&&((mb->nak_timeout == 0)||(mb->nak_timeout  < systime))){
#ifdef DEBUGLIB
			mb_time = mb->nak_timeout;
#endif        	  
			mb->nak_timeout = (int)(systime + nak_timeout);
			
			if ((mb->dgrams_received == 0)||(mb->dgrams_in_block == 0)){
				local_naks = mem_map->dgrams_per_block;
				++stats->block_naks_sent;
				if (server->SendNak(nak_block, 0, nak_block, -1) == ErrorOccurred){
        	         		err = &(server->ReturnCopyOfError());
        	         		result = ErrorOccurred;
        		        }
        		}
        		else {					  
        	      		dgm = 0;                 	  	                 	  	
 				while ((dgm < mb->dgrams_in_block)&&(result != ErrorOccurred)){
        	       		  
        	       			while ((mb->nec_block.buffers[dgm].buffer_ptr != NULL)&&(dgm < mb->dgrams_in_block)) dgm++;
        	       		  		
        	       		  	min_val = dgm;
                			  	
        	       		  	while ((mb->nec_block.buffers[dgm].buffer_ptr == NULL)&&(dgm < mb->dgrams_in_block)) dgm++;
                 		  			
        	       		  	max_val = dgm - 1;

        	        		if (min_val <= max_val){
        	         			  local_naks += (max_val - min_val)+1;
        	         			  mb->pending_nak = 1;
        	         			  if (server->SendNak(mb->block_id, min_val, mb->block_id, max_val) == ErrorOccurred) {
        	         				err = &(server->ReturnCopyOfError());
        	         				result = ErrorOccurred;
        	         			  }
        	         		}
        	         	}// while datagrams
        	         	stats->naks_sent += local_naks;
        	        }//else
        	}
        	else 
        		local_naks = -1;
#ifdef DEBUGLIB				
		if (mb != NULL)
               		Debug("nak (%i)(%i)[%i] @ %i, %i/%i (%i)",
              			mb->completed!=0, mb->inuse!=0, mb->block_id, mb_time, 
              			mb->dgrams_received, mb->dgrams_in_block, local_naks);
              	else
              		Debug("zero nak_block %i", nak_block);
#endif	

        }
        if (naks != NULL)
        	(*naks) += local_naks;
        	
        return result;
}

//
// Reads a pending datagram into a free datagram buffer and links it into the
// block's scatter array.
//
// Errors: TCP_ReadFail, VSP_Alloc
//
//
error_flag
SourceVOD::ReadDatagrams(callback_flag current_flags, callback_flag *flags, Server *server, Statistics *stats, int timeout)
{
        error_flag result = ErrorState();
        
        NECDatagram *dgram;
        int size = 1;
       
        while (( size > 0)&&(result != ErrorOccurred)){
                      
         	result = mem_map->memFindFreeDatagramBuffer(&dgram);
        
         	if ( result != ErrorOccurred) {
                	struct iovec iov[2];
                
                	iov[0].iov_len =  sizeof(NECDatagram);
                	iov[1].iov_len =  (unsigned int)(mem_map->dgram_size - sizeof(NECDatagram)) ;
                
                	iov[0].iov_base = (char*) dgram;
                	iov[1].iov_base = (char*) mem_map->findPayloadBuffer(dgram);  
                          
                	size = sd.read(iov,sizeof(iov)/sizeof(struct iovec));	// read from socket
                     
                 	if ( size >= sizeof(NECDatagram) ){			// if greater than header size
                 		MemBlock *mb = NULL;
                 	  	stats->bytes_received += size;
                  	  	++(stats->dgrams_read);

                	  	ntoh_structure(dgram, map_NECDatagram, NECDatagram);
                	  	
         			if ( (dgram->playback_classification_id == current_play_id)&&(dgram->block_number > max_completed_block)
         			   &&( (mb=mem_map->findExistingBlock(dgram->block_number)) != NULL) ) {
         									// if that piece of information is not already received
       					if (mb->nec_block.buffers[dgram->dgram_seq].buffer_ptr == NULL) {
       					  					// assign that datagram to the block
						mb->nec_block.buffers[dgram->dgram_seq].buffer_ptr = iov[1].iov_base;
       						mb->nec_block.buffers[dgram->dgram_seq].buffer_length = (unsigned int) dgram->dgram_size;
       						++mb->dgrams_received;
              		
       						if (mb->dgrams_in_block == 0) {	// if block values needs initialising
       							if (dgram->dgram_total != 0){
       	       							mb->dgrams_in_block = (unsigned int) dgram->dgram_total;
       	       							mb->special_play_id = (int) dgram->playback_classification_id;
								mb->nak_timeout = 0;	
       	       						}
       	       					}
       	       					else {
    										// if completed or deleted
    							if ( (dgram->status_word & 0x01) || (mb->dgrams_received == mb->dgrams_in_block) ){
						  
								mb->completed = 1;	// assign completed block
								mb->pending_nak = 0;
													
	       							result = calculateMaxCompleteBlock();	// calculate most completed
	       							result = calculatePosAckSequence(server, stats);
							
								if (nak_block <= max_completed_block+1)	{
								  	mb = mem_map->findExistingBlock(max_completed_block+1);
									if (mb != NULL) {
										mb->nak_timeout = 0;
									  	nak_block = max_completed_block+1;
									}
								}
													// stream live or full buffers
								if ( max_completed_block == server->getMaxRequestedBlock() ){
									(*flags) = (callback_flag)((*flags) | callback_fullblocks);
								}
								else{					// otherwise set block timeout
									if (dgram->block_number <= max_completed_block){
										(*flags) = (callback_flag)((*flags) | callback_block);
										mb = mem_map->findExistingBlock(max_completed_block+1);
        									if ((mb != NULL)&&(nak_block == max_completed_block +1)){
        										unsigned int systime;
											_swix(OS_ReadMonotonicTime, _OUT(0), &systime);
        										mb->nak_timeout = systime + timeout;
        									}
        								}
								}				
        							full_blocks = (int)(max_completed_block - last_block_sent);
        							
								if (dgram->status_word & 0x01){
								  	++(stats->deleted_blocks);
									mb = mem_map->findExistingBlock(dgram->block_number);
									if (mb != NULL)
										mb->deleted_block = 1;
							        }
							}
							else {// not full block
								if ( (!( ((*flags) & callback_nak) | (current_flags & callback_nak) ))
									&&(dgram->block_number > (max_completed_block + 1) )){
									mb = mem_map->findExistingBlock(max_completed_block+1);
									if (mb != NULL) {
									  	if (nak_block != max_completed_block+1){
									  	  	nak_block = max_completed_block+1;
											mb->nak_timeout = 0;
										}
										result = calculatePosNAKSequence(server, stats);
										(*flags) = (callback_flag)((*flags) | callback_nak);
							                }	
							        }
						        }
					        }// dgrams in block
				        }
       					else { 	//duplicate datagram != 0
       						++(stats->duplicate_dgrams);
                 			       	result = mem_map->memFreeDatagram(dgram);              		
       					}
               		        }
               		        else {
               		          
               		        	result = mem_map->memFreeDatagram(dgram);
               		          	if ((result != ErrorOccurred)&&(mem_map->ErrorExists())){
       						  result = ErrorOccurred;
       						  mem_map->ReturnCopyOfError();
       					}
               		        }
	               	}// (size > datagram)
        	       	else {        	       	  		
                       		if ((size == -1)&&(errno != EWOULDBLOCK)) {
#ifdef DEBUGLIB
                       	  		Debug("read errno = %i", errno);
#endif                       	  	  	
                                        result = MakeError(TCP_ReadFail);
                                }
                        	result = mem_map->memFreeDatagram(dgram);
                        }
                }// no error result
        }// while datagrams
        return result;
}

//---------------------------------------------------------------------- LIVE specific --------------------
SourceLIVE::SourceLIVE(Source& vod)
{
  last_block_sent = 0;
  max_completed_block = 0;
  most_significant_time = 0;
  nak_block = 0;
  nak_timeout = 0;
  current_play_id = 0;		// this is the trickplay flag this changes with each new trickplay
  stream_end_block = 0;		// this is set when we know what the last block in the stream is
	// Network information
  //sd = vod.sd;
  //mem_map = vod.mem_map;
  vod.SetSourceVar(&sd, &mem_map);
  
  mem_map->blockReset();
   		
  full_blocks = 0;
}

error_flag 
SourceLIVE::calculatePosAckSequence(Server *server, Statistics *stats)
{
  server = server;
  stats = stats;
  
  return NoError;
}
	//error_flag calculatePosNAKSequence(int *naks_sent, Server *server, int max_block);
error_flag 
SourceLIVE::calculatePosNAKSequence(Server *server, Statistics *stats, int *naks)
{
  server = server;
  stats = stats;
  naks = naks;
  
  return NoError;
}
//
// Reads a pending datagram into a free datagram buffer and links it into the
// block's scatter array.
//
// Errors: TCP_ReadFail, VSP_Alloc
//
//
error_flag
SourceLIVE::ReadDatagrams(callback_flag current_flags, callback_flag *flags, Server *server, Statistics *stats, int timeout)
{
  current_flags = current_flags;
  server = server;
  timeout = timeout;
  
        error_flag result = ErrorState();
        
        NECDatagram *dgram;
        int size = 1;
        
        while (( size > 0)&&(result != ErrorOccurred)){
                      
         	result = mem_map->memFindFreeDatagramBuffer(&dgram);
        
         	if ( result != ErrorOccurred) {
                	struct iovec iov[2];
                
                	iov[0].iov_len =  sizeof(NECDatagram);
                	iov[1].iov_len =  (unsigned int)(mem_map->dgram_size - sizeof(NECDatagram)) ;
                
                	iov[0].iov_base = (char*) dgram;
                	iov[1].iov_base = (char*) mem_map->findPayloadBuffer(dgram);  
                          
                	size = sd.read(iov,sizeof(iov)/sizeof(struct iovec));	// read from socket
                     
                 	if ( size >= sizeof(NECDatagram) ){			// if greater than header size
                 		MemBlock *mb = NULL;
                 	  	stats->bytes_received += size;
                  	  	++(stats->dgrams_read);

                	  	ntoh_structure(dgram, map_NECDatagram, NECDatagram);

         			if ((mb = mem_map->findOrReplaceBlock(dgram->block_number,&last_block_sent, &max_completed_block)) != NULL ) {
         									// if that piece of information is not already received
       					if (mb->nec_block.buffers[dgram->dgram_seq].buffer_ptr == NULL) {
       					  					// assign that datagram to the block
						mb->nec_block.buffers[dgram->dgram_seq].buffer_ptr = iov[1].iov_base;
       						mb->nec_block.buffers[dgram->dgram_seq].buffer_length = (unsigned int) dgram->dgram_size;
       						++mb->dgrams_received;
              		
       						if (mb->dgrams_in_block == 0) {	// if block values needs initialising
       							if (dgram->dgram_total != 0){
       	       							mb->dgrams_in_block = (unsigned int) dgram->dgram_total;
       	       							mb->special_play_id = (int) dgram->playback_classification_id;
								mb->nak_timeout = 0;	
       	       						}
       	       					}
    										// if completed
    						if ((mb->dgrams_in_block != 0)&&(mb->dgrams_received == mb->dgrams_in_block)){
						  
							mb->completed = 1;	// assign completed block
							mb->pending_nak = 0;
													
	       						result = calculateMaxCompleteBlock();	// calculate most completed
													// stream live or full buffers
							if ((max_completed_block+2) < dgram->block_number){
								mb = mem_map->findExistingBlock(max_completed_block+1);
								if (mb != NULL){
									++(stats->deleted_blocks);
									mem_map->freeBlock_background(mb);
								}
							}
										
							(*flags) = (callback_flag)((*flags) | callback_fullblocks);
												
        						full_blocks = (int)(max_completed_block - last_block_sent);
					        }// dgrams in block
				        }
       					else { 	//duplicate datagram != 0
       						++(stats->duplicate_dgrams);
                 			       	result = mem_map->memFreeDatagram(dgram);              		
       					}
               		        }
               		        else {
               		          
               		        	result = mem_map->memFreeDatagram(dgram);
               		          	if ((result != ErrorOccurred)&&(mem_map->ErrorExists())){
       						  result = ErrorOccurred;
       						  mem_map->ReturnCopyOfError();
       					}
               		        }
	               	}// (size > datagram)
        	       	else {        	       	  		
                       		if ((size == -1)&&(errno != EWOULDBLOCK)) {
#ifdef DEBUGLIB
                       	  		Debug("read errno = %i", errno);
#endif                       	  	  	
                                        result = MakeError(TCP_ReadFail);
                                }
                        	result = mem_map->memFreeDatagram(dgram);
                        }
                }// no error result
        }// while datagrams
        return result;
}

//---------------------------------------------------------------------- BroadCast specific --------------------
SourceMultiCast::SourceMultiCast(const char *hostname, int source_recvspace, int netTimeOut)
{
#ifdef DEBUGLIB
  	Debug("creating multicast source+");
    	// Initialisation completed successfully
  	
        sd = sd.creat(PF_INET, SOCK_DGRAM);
       
        struct ip_mreq mreq;
	mreq.imr_interface.s_addr = INADDR_ANY;
        if (inet_aton(hostname, &(mreq.imr_multiaddr)) ) {
        	if (IN_MULTICAST(mreq.imr_multiaddr.s_addr)){
          		if (setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0)
          			Debug("error in set sock opt.");
          	}
          	else
          		Debug("not a multicast address");
        }
        else
        	Debug("error returned from name change");
 
        //setSocketError(sd.joinMulti(hostname));
        if (ErrorExists()) Debug("errno = %i", errno);
        
        //setsockopt(getSocket(), IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
        //else Debug("Ok on join multi");
          
        sd.setrecvspace(source_recvspace);
        sd.makeNonBlocking();
 	//setSocketError(sd.bind());
        //setSocketError(sd.connect("230.1.1.10", "30000"));
              
        if(!ErrorExists()){
          	Debug("reading datagram");
        	char *data;
        	sd.setDgramSize(12524);
        	nak_block = sd.getDgramSize();

        	in_addr address;
        	inet_aton(hostname, &address);
        	Debug("datagram size = %i, address %8.8X", nak_block, address);
        	data = new char(nak_block);
          
        	if (data != NULL){
        	  	Debug("reading socket");
            		struct iovec iov[2];
            		int size, *ptr;
                
            		iov[0].iov_len =  sizeof(MultiCastDatagram);
                	iov[1].iov_len =  (unsigned int)(nak_block - sizeof(MultiCastDatagram)) ;
                	
                	iov[0].iov_base = data;
                	iov[1].iov_base = data + sizeof(MultiCastDatagram);
                	
                	 unsigned int t1, t2;
  				
  			_swix(OS_ReadMonotonicTime, _OUT(0), &t1);
  			
  			t2 = t1;
  			t1 += netTimeOut;
  			size = -1;
  			
  			while (( t2 < t1 )&&(size <= 0)){
	                	size = sd.read(iov,sizeof(iov)/sizeof(struct iovec));
	                	_swix(OS_ReadMonotonicTime, _OUT(0), &t2);
                	}
                	Debug("read size = %i", size);
                	if (size < 0){
                		Debug("problem %i", errno);
                		MakeError(TCP_TimeOutOnCommunication);
                	}
                	else {
                		ptr = (int*)data;
                		for (size = 0; size < sizeof(MultiCastDatagram)/4; size++)
                			Debug("%8.8X", ptr[size]);
                	}
          }
          delete data;
        }
        
  	Debug("creating multicast source-");
#else
	hostname = hostname;
	source_recvspace = source_recvspace;
	netTimeOut = netTimeOut;  	
#endif  	

  	stream_end_block = current_play_id = full_blocks = 0;
  	
   	mem_map = NULL;
  	
        nak_block = 0;
        nak_timeout = 0;
        most_significant_time = 0;
}

SourceMultiCast::~SourceMultiCast(void)
{
   	//sd.close();
}
 
error_flag 
SourceMultiCast::calculatePosAckSequence(Server *server, Statistics *stats)
{
  server = server;
  stats = stats;
  
  return NoError;
}
	//error_flag calculatePosNAKSequence(int *naks_sent, Server *server, int max_block);
error_flag 
SourceMultiCast::calculatePosNAKSequence(Server *server, Statistics *stats, int *naks)
{
  server = server;
  stats = stats;
  naks = naks;
  
  return NoError;
}
//
// Reads a pending datagram into a free datagram buffer and links it into the
// block's scatter array.
//
// Errors: TCP_ReadFail, VSP_Alloc
//
//
error_flag
SourceMultiCast::ReadDatagrams(callback_flag current_flags, callback_flag *flags, Server *server, Statistics *stats, int timeout)
{
  current_flags = current_flags;
  server = server;
  timeout = timeout;
  
        error_flag result = ErrorState();
        
        NECDatagram *dgram;
        int size = 1;
        
        while (( size > 0)&&(result != ErrorOccurred)){
                      
         	result = mem_map->memFindFreeDatagramBuffer(&dgram);
        
         	if ( result != ErrorOccurred) {
                	struct iovec iov[2];
                
                	iov[0].iov_len =  sizeof(NECDatagram);
                	iov[1].iov_len =  (unsigned int)(mem_map->dgram_size - sizeof(NECDatagram)) ;
                
                	iov[0].iov_base = (char*) dgram;
                	iov[1].iov_base = (char*) mem_map->findPayloadBuffer(dgram);  
                          
                	size = sd.read(iov,sizeof(iov)/sizeof(struct iovec));	// read from socket
                     
                 	if ( size >= sizeof(NECDatagram) ){			// if greater than header size
                 		MemBlock *mb = NULL;
                 	  	stats->bytes_received += size;
                  	  	++(stats->dgrams_read);

                	  	ntoh_structure(dgram, map_NECDatagram, NECDatagram);

         			if ((mb = mem_map->findOrReplaceBlock(dgram->block_number,&last_block_sent, &max_completed_block)) != NULL ) {
         									// if that piece of information is not already received
       					if (mb->nec_block.buffers[dgram->dgram_seq].buffer_ptr == NULL) {
       					  					// assign that datagram to the block
						mb->nec_block.buffers[dgram->dgram_seq].buffer_ptr = iov[1].iov_base;
       						mb->nec_block.buffers[dgram->dgram_seq].buffer_length = (unsigned int) dgram->dgram_size;
       						++mb->dgrams_received;
              		
       						if (mb->dgrams_in_block == 0) {	// if block values needs initialising
       							if (dgram->dgram_total != 0){
       	       							mb->dgrams_in_block = (unsigned int) dgram->dgram_total;
       	       							mb->special_play_id = (int) dgram->playback_classification_id;
								mb->nak_timeout = 0;	
       	       						}
       	       					}
       	       					else {
    										// if completed
    							if (mb->dgrams_received == mb->dgrams_in_block){
						  
								mb->completed = 1;	// assign completed block
								mb->pending_nak = 0;
													
	       							result = calculateMaxCompleteBlock();	// calculate most completed
													// stream live or full buffers
								(*flags) = (callback_flag)((*flags) | callback_fullblocks);
												
        							full_blocks = (int)(max_completed_block - last_block_sent);
        							
							}
					        }// dgrams in block
				        }
       					else { 	//duplicate datagram != 0
       						++(stats->duplicate_dgrams);
                 			       	result = mem_map->memFreeDatagram(dgram);              		
       					}
               		        }
               		        else {
               		          
               		        	result = mem_map->memFreeDatagram(dgram);
               		          	if ((result != ErrorOccurred)&&(mem_map->ErrorExists())){
       						  result = ErrorOccurred;
       						  mem_map->ReturnCopyOfError();
       					}
               		        }
	               	}// (size > datagram)
        	       	else {        	       	  		
                       		if ((size == -1)&&(errno != EWOULDBLOCK)) {
#ifdef DEBUGLIB
                       	  		Debug("read errno = %i", errno);
#endif                       	  	  	
                                        result = MakeError(TCP_ReadFail);
                                }
                        	result = mem_map->memFreeDatagram(dgram);
                        }
                }// no error result
        }// while datagrams
        return result;
}

error_flag
Source::getMiscInfo(misc_info_flags flags, void *ptr)
{
  error_flag result = ErrorState();
  NECBlockHeader most_significant_block;
  
	switch (flags) {
	  case type_misc_5_10:
	  	{
  		(void) memset((void*)&most_significant_block, 0, sizeof(NECBlockHeader));
  
	  	misc_5_10 *ptr_misc_5_10 = (misc_5_10*)ptr;
	  	
	  	MemBlock *mb = mem_map->findExistingBlock(last_block_sent);
	  	
	  	if (mb != NULL) {
  			memcpy((void*)&most_significant_block, (void*)mb->nec_block.buffers[0].buffer_ptr, sizeof(NECBlockHeader));
  			if (ntoh_structure((void*)&most_significant_block, map_NECBlockHeader, NECBlockHeader) == ErrorOccurred){
  				result = MakeError(TCP_SendFail);
  			}
  		}
		ptr_misc_5_10->h_pixels = most_significant_block.image_width;
  		ptr_misc_5_10->v_pixels = most_significant_block.image_height;
	 	ptr_misc_5_10->play_time = most_significant_block.playback_time;
 	 	ptr_misc_5_10->status_word = most_significant_block.status_word;
 	 	ptr_misc_5_10->scene_number = most_significant_block.scene_number;
 	 	ptr_misc_5_10->head_time = most_significant_block.video_start_time;
	 	ptr_misc_5_10->end_time = most_significant_block.video_end_time;
 	 	ptr_misc_5_10->encode_time = most_significant_block.encode_time;
	  	ptr_misc_5_10->bitrate = most_significant_block.bit_rate_value;
	  	}
	  	break;
	  	
#ifdef DEBUGLIB
	default:
		{
		Debug("MiscInfo - nak_block %i, max comp %i-%i, play id %i", nak_block, max_completed_block, last_block_sent, current_play_id);
    	  	ErrorDump();  

         	for (int i = 0; ( (i < mem_map->max_blocks)&&(result != ErrorOccurred) ); i++) {
         	      MemBlock *mb = mem_map->getBlock(i);
         	      Debug("block (%i)(%i)(%i)(%i)[%i] - %i, %i/%i, p_id = %i",
         	     	 mb->to_be_freed!=0, mb->mpeg_owned!=0, mb->completed!=0, mb->inuse!=0, mb->block_id, mb->pending_nak!=0,  
         	     	 mb->dgrams_received, mb->dgrams_in_block, mb->special_play_id);
         	}
         	}
         	break;
#endif      
        } // switch         	
  return result;
}
