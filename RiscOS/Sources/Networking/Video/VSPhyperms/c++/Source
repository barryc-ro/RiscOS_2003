/**************************************
 Source.c++

implements Source class
© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
03/09/98  SNB     File created

**************************************/
extern "C" {
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

#include "kernel.h"
#include "swis.h"
}

#include "SourceP.h"
#include "Source.h"

extern "C" {
#include "sys/ioctl.h"
#include "netinet/udp.h"
}


Statistics::Statistics(void)
{
  last_stream_bytes_received = 0;
  last_stream_time = 0;
  last_stream_acks = 0;
  last_stream_naks = 0;

  dgrams_read = 0;
  duplicate_dgrams = 0;
  acks_sent = 0;
  naks_sent = 0;
  block_naks_sent = 0;
  deleted_blocks = 0;
  bytes_received = 0;
}

void
Statistics::print(void)
{
  ULINT bandwidth;


  if (last_stream_time > 100){
  	bandwidth = last_stream_bytes_received + (last_stream_acks *sizeof(ACK_Block)) + (last_stream_naks * sizeof(NAK_Block));
  	bandwidth = (bandwidth / last_stream_time)*100;
  }
  else
  	bandwidth = 0;

  printf(" Bandwidth usage of last stream\n");
  printf("     run time in centiseconds             %u\n", last_stream_time);
  printf("     bytes received by stream             %u\n", last_stream_bytes_received);
  printf("     bytes in the form of acks            %u\n", last_stream_acks * sizeof(ACK_Block));
  printf("     bytes in the form of naks            %u\n", last_stream_naks * sizeof(NAK_Block));
  printf("     Total bandwidth  (bytes, bits)/sec   %u, %u\n", bandwidth, bandwidth*8);
  printf(" Diagnostics for all streams\n");
  printf("     bytes received                       %u\n", bytes_received);
  printf("     datagrams read                       %u\n", dgrams_read);
  printf("     duplicate datagrams                  %u\n", duplicate_dgrams);
  printf("     acks sent                            %u\n", acks_sent);
  printf("     naks sent                            %u\n", naks_sent);
  printf("     entire blocks nakd                   %u\n", block_naks_sent);
  printf("     deleted blocks / block errors        %u\n", deleted_blocks);
}

//---------------------------------------------------------------------- private -- run time calculations --------------------

// calculate the largest block_id for full blocks, this means that no block_id
// smaller shall be incomplete and no block_id greater shall be complete.

inline error_flag
Source::calculateMaxCompleteBlock(void)
{
  MemBlock *mb;

  while (((mb = mem_map->findExistingBlock(max_completed_block+1)) != NULL)&&(mb->completed))
  	max_completed_block++;

  if (max_completed_block >= last_block_sent)
  	full_blocks = (size_t)(max_completed_block - last_block_sent);
  else {
#ifdef DEBUGLIB
    	if (Debug(debug_blockerrors)) Debug("max completed is less than last sent ???");
#endif
	// serious error when last block sent is greater than that completed, this can occur under changes
	// of play mode when blocks are deleted
    	while (max_completed_block < last_block_sent){
    		if ((mb = mem_map->findExistingBlock(max_completed_block+1)) != NULL) {
    			mb->deleted_block = 1;
        		mb->completed = 1;	// assign completed block
			mb->pending_nak = 0;
			mb->to_be_freed = 1;
		}
		++max_completed_block;
	}
  	full_blocks = 0;
  }

  return ErrorState();
}

// calculate a new window period if it is different from now then notify the server this is the only
// place where a request for more blocks during normal play.  Play notifications also have Ack capability.

// freeblocks does not take into account half full blocks but this is not important. What is most important
// is that we maintain a window from the most complete block no greater than that specified by the server.
// it is better to undercalculate than overestimate.

inline error_flag
Source::calculatePosAckSequence(InternetObject *server, Statistics *stats, ULINT timeout)
{
    size_t freeblocks;
    ULINT MAX_block_request = 0;
    error_flag result = ErrorState();


    if ((result != ErrorOccurred)&&(getStartEnd() == 0)){
	prior_max_request = server->getMaxRequestedBlock();
    	MAX_block_request = (max_completed_block + NEC_databurstval) - prior_max_request;

    	if (MAX_block_request > 0) {			// if window available
		result = getBlockStatus(0, 0, &freeblocks);
		if (freeblocks > 0) {
    			if (MAX_block_request > freeblocks)
    				MAX_block_request = freeblocks;

    			MAX_block_request += prior_max_request;

	   		if (MAX_block_request > prior_max_request){
	   		  	++(stats->acks_sent);
             			if (server->SendAck(MAX_block_request, max_completed_block, data) == ErrorOccurred) {
             			  	if (err_ptr == NULL)
         					err_ptr = &server->ReturnCopyOfError();
          				result = ErrorOccurred;
               			}
#ifdef DEBUGLIB
	   		  	if (Debug(debug_ack)) Debug("send ack %i-(%i,%i)", max_completed_block, MAX_block_request, server->getMaxRequestedBlock());
#endif
               			MAX_block_request = server->getMaxRequestedBlock();
               			ULINT last_completed_block = prior_max_request;	// the largest block number completed ignoring incomplete blocks.
               			MemBlock *mb;
               			unsigned int systime;
				_swix(OS_ReadMonotonicTime, _OUT(0), &systime);

				while (last_completed_block > max_completed_block){
				  	mb = mem_map->findExistingBlock(last_completed_block);

				  	if ((mb != NULL)&&(mb->completed)) break;

				  	--last_completed_block;
				}
#ifdef DEBUGLIB
	   		  	if (Debug(debug_ack)) Debug("lcb[%i] timeout = %i", last_completed_block, timeout);
#endif
              			for (ULINT i = 1; (i+last_completed_block) <= MAX_block_request; i++){
             				mb = mem_map->findBlock(last_completed_block+i);
               				if ((mb == NULL)||(mem_map->ErrorExists())){
              				  	mem_map->RemoveErr();
               				}
               				else
               				{
               				  	unsigned int new_nak_timeout = (unsigned int) (systime + timeout + (i-1)*block_time);

               				  	if ((mb->nak_timeout == 0)||(new_nak_timeout < mb->nak_timeout))
               						mb->nak_timeout = new_nak_timeout;
               					mb->special_play_id = (unsigned int)get_current_play_id();
               					// Avoid deleting block in calculatePosNAKSequence before we even block NAK
               				}
               			}
               			prior_max_request = MAX_block_request;
               		}
	   	}
	}
    }
    return result;
}

error_flag
Source::calculatePosNAKSequence(InternetObject *server, Statistics *stats, size_t *naks, ULINT *timeout)
{
        MemBlock *mb;
        int dgm, min_val, max_val;	// nak calcs
        error_flag result = ErrorState();
        int local_naks = 0;

        unsigned int systime;
	_swix(OS_ReadMonotonicTime, _OUT(0), &systime);

	mb = mem_map->findExistingBlock(max_completed_block+1);

#ifdef DEBUGLIB
	unsigned int mb_time= 1;
	if (mb != NULL)	mb_time = mb->nak_timeout;
#endif

	// if we can find the block and its timeout is set to zero or amnesty is over.
	if ( (mb==NULL)||(systime+5 < mb->nak_timeout) ){
	  	if (mb != NULL)
	  		(*timeout) = mb->nak_timeout - systime;
        	local_naks = -1;
       	}
        else {
		mb->nak_timeout = systime + (unsigned int)nak_timeout;

		(*timeout) = nak_timeout;

        	if ((++mb->resends) > Acceptable_NAKS){
#ifdef DEBUGLIB
        	  	if (Debug(debug_naks)) Debug("deleting block [%i]", mb->block_id);
        	  	//getMiscInfo(type_debug, NULL);
#endif
        		mb->deleted_block = 1;
        		mb->completed = 1;	// assign completed block
			mb->pending_nak = 0;
			if (mb->block_id == last_block_sent +1){
			  	++last_block_sent;
				mb->to_be_freed = 1;
			}

			++(stats->deleted_blocks);
			result = calculateMaxCompleteBlock();	// calculate most completed

			if (( ++deleted_blocks > Acceptable_deleted_blocks)&&(getStartEnd() == 0))
				result = MakeError(IP_TimeOutOnCommunication);
		}
		else {
		  	if (mb->special_play_id != get_current_play_id()){
		  	  	mb->deleted_block = 1;
        			mb->completed = 1;			// assign completed block
				mb->pending_nak = 0;
				if (mb->block_id == last_block_sent +1){
			  		++last_block_sent;
					mb->to_be_freed = 1;
				}

				++(stats->deleted_blocks);
#ifdef DEBUGLIB
        	  		if (Debug(debug_naks)) Debug("deleted block [%i]", mb->block_id);
#endif
				result = calculateMaxCompleteBlock();	// calculate most completed

				if (( ++deleted_blocks > Acceptable_deleted_blocks)&&(getStartEnd() == 0))
					result = MakeError(IP_TimeOutOnCommunication);
			}
			else {
				if ((mb->dgrams_received == 0)||(mb->dgrams_in_block == 0)){
					local_naks = mem_map->dgramsPerBlock();
					++stats->block_naks_sent;
					if (server->SendNak((max_completed_block+1), 0, (max_completed_block+1), -1) == ErrorOccurred){
						if (err_ptr == NULL)
       	        		 			err_ptr = &(server->ReturnCopyOfError());
       	        		 		result = ErrorOccurred;
       				        }
       				}
       				else {
       	      				dgm = 0;
					while ((dgm < mb->dgrams_in_block)&&(result != ErrorOccurred)){

       						while ((mb->nec_block.buffers[dgm].buffer_ptr != NULL)&&(dgm < mb->dgrams_in_block)) dgm++;

       				  		min_val = dgm;

      				  		while ((mb->nec_block.buffers[dgm].buffer_ptr == NULL)&&(dgm < mb->dgrams_in_block)) dgm++;

      				  		max_val = dgm - 1;

		       				if (min_val <= max_val){
        	      				  	local_naks += (max_val - min_val)+1;
               					  	mb->pending_nak = 1;
               					  	if (server->SendNak(mb->block_id, min_val, mb->block_id, max_val) == ErrorOccurred) {
								if (err_ptr == NULL) err_ptr = &(server->ReturnCopyOfError());
        			       				result = ErrorOccurred;
        			                  	}
        			                }
        			        }// while datagrams
        			        stats->naks_sent += local_naks;
        			}//else
#ifdef DEBUGLIB
        			if (Debug(debug_naks)){
        				Debug("nak (%i)(%i)[%i] @ %i, %i/%i (%i)",
              					mb->completed!=0, mb->inuse!=0, mb->block_id, mb_time,
              					mb->dgrams_received, mb->dgrams_in_block, local_naks);
                                }
#endif
                        }
                }

        }

        if (naks != NULL) (*naks) += local_naks;

        return result;
}

//---------------------------------------------------------------------- public -- object creation/deletion methods --------------------
// this creates the udp link and sets local variables
//
Source::Source(size_t set_nak_timeout, size_t source_recvspace)
{
  	current_play_id = full_blocks = 0;

   	mem_map = NULL;
  	nak_timeout = set_nak_timeout;
        most_significant_time = 0;
        start_end_block = 0;
        deleted_blocks = 0;
        max_completed_block = prior_max_request = 0;

    	// Initialisation completed successfully
        sd.creat(PF_INET, SOCK_DGRAM);
        setSocketError(sd.bind());

        sd.setrecvspace(source_recvspace);
}
// this is a copy constructor allowing the conversion from a stream live to a stream stored.
Source::Source(Source& live)
{

  last_block_sent = live.get_most_significant_block();
  max_completed_block = last_block_sent = prior_max_request;
  most_significant_time = live.get_most_significant_time();
  nak_timeout = live.get_nakTimeout();
  current_play_id = live.get_current_play_id();		// this is the trickplay flag this changes with each new trickplay
  start_end_block = 0;
  deleted_blocks = 0;

  live.SetSourceVar(&sd, &mem_map);

  mem_map->blockReset();

  full_blocks = 0;
}
// this is used so VOD can become LIVE and visa versa.
void
Source::SetSourceVar(Socket *socket, SourceMemMap **mem)
{
	(*socket) = sd;
	(*mem) = mem_map;

	sd.invalidateSocket();

	mem_map = NULL;	// the socket is still non zero but this is used in a test in the destructor
}

// this is to be called after the asset presentation dialogue
error_flag
Source::Allocate(size_t max_blocks, size_t block_size, size_t initial_block_num, size_t datagram_size)
{
  	error_flag result = ErrorState();

 	if ((result == ErrorOccurred)&&(ErrorNum() == VSP_SourceUninit))
  		RemoveErr();	// if source memory not allocated error has occurred it is no longer relevant

	if (result != ErrorOccurred) {
  		if (initial_block_num < 1){
  		  	result = MakeError(VSP_InvalidValue);
  		}
  		else {					// must be greater than one by specification;
  			//max_block_received =
  			last_block_sent = max_completed_block = prior_max_request = initial_block_num -1;

        		if ( datagram_size <= sizeof(struct udphdr)) {
#ifdef DEBUGLIB
				if (Debug(debug_always))
					Debug("datagram size error %i < %i", datagram_size, sizeof(struct udphdr));
#endif
	       		        result = MakeError(VSP_DatagramSizeError);
        		}
 			else {
 				// datagram size is specified as the send to size this size does not include the header.
   				mem_map = new SourceMemMap(max_blocks, block_size, datagram_size-sizeof(NECDatagram) );

   				if (mem_map->ErrorState() == ErrorOccurred){
					if (err_ptr == NULL)
						err_ptr = &(mem_map->ReturnCopyOfError());	// this will be VSP_Alloc
   		  			delete mem_map;
   		  			mem_map = NULL;
   		                }
   		        }
   	        }
   	}
       	return result;
}

//
// Destructor.  Frees any memory associated with the object.
//
// Errors: None.
//
//
Source::~Source(void)
{
  if (mem_map != NULL){
  	delete mem_map;
  	mem_map = NULL;
  }
}

//
// Converts the current value of errno into a VSP module error code if result
// was less than zero.  If result was >= 0, then there was no error.
// This method allows setSocketError(some_system_call()) to wrap system calls.
//
// Errors: IP_BadPortSpecification, IP_UnknownServer, IP_SocketError
//         IP_ServerRefusedConnection
//
error_flag
Source::setSocketError(int socket_result)
{
    error_flag result = ErrorState();

    if ((result != ErrorOccurred)&&(socket_result < 0)) {
          switch (errno) {
                 default:
                        result = MakeError(IP_SocketError);
                        break;
                 case ECONNREFUSED:
                        result = MakeError(IP_ConnectionRefused);
                        break;
                 case ENOENT:
                        result = MakeError(IP_UnknownServer);
                        break;
                 case EINVAL:
                        result = MakeError(IP_BadPortSpecification);
                        break;
                 case EWOULDBLOCK:
                 	// ignore it is just busy
                 	break;
                }
        }
        return result;
}

//
// Declares where the UDP packets are going to be coming from.  Port number
// may be specified as a number or a well-known service name.  Quoting a
// service "name" which is actually a string representation of a numeric value
// is treated as an explicit port selection.
//
// Errors: IP_BadPortSpecification, IP_UnknownServer, IP_SocketError
//         IP_ServerRefusedConnection
//
//
error_flag
Source::setServerDetails(const char *hostname, int port)
{
  	int connect_error = sd.connect(hostname, htons(port));

  	if (connect_error >= 0)
        {
        	sd.eventsOn();
        	sd.makeNonBlocking();
        }

        return setSocketError(connect_error);
}

error_flag
Source::setServerDetails(const char *hostname, const char *port)
{
  	int connect_error = sd.connect(hostname, port, "udp");

  	if (connect_error >= 0)
        {
        	sd.eventsOn();
        	sd.makeNonBlocking();
        }

        return setSocketError(connect_error);
}

error_flag
Source::setServerDetails(struct in_addr *address, int port)
{
  	int connect_error = sd.connect(address, htons(port));

  	if (connect_error >= 0)
        {
        	sd.eventsOn();
        	sd.makeNonBlocking();
        }
        return setSocketError(connect_error);
}
//
// Returns the local port number being used by this Source object.  This
// information is required by the Server class for Asset Presentation Request
// messages.
//
// Errors: IP_SocketError: Unable to bind to local port.
//
//
error_flag
Source::getLocalPort(int *port)
{
        return setSocketError(sd.getLocalPort(port));
}

//
// Gets the number of full blocks pending and the maximum number of bufferable
// blocks as set in the constructor.
//
// Errors: None.
//
//
inline error_flag
Source::getBlockStatus(size_t *num_blocks, size_t *max_blocks_r, size_t *num_free)
{
        if (num_blocks != 0 || num_free != 0) {
        	size_t n;
        	size_t full_blocks = 0;
        	size_t empty_blocks = 0;

                for (n = 0; n < mem_map->maxBlocks(); n++) {
                        MemBlock *mb = mem_map->getBlock(n);
                        if (!mb->inuse) empty_blocks++;
                        else if (mb->completed) full_blocks++;
                }
                if (num_blocks != 0) *num_blocks = full_blocks;
                if (num_free != 0) *num_free = empty_blocks;
        }

        if (max_blocks_r != 0) *max_blocks_r = mem_map->maxBlocks();

        return NoError;
}

// this clears the source and sets the play state to -1 so no more is added to the source
// ie. from this time until state is moved out of stop nothing will be placed into the
// source data structures.
void
Source::setEndPlayState(void)
{
   	current_play_id &= 0x80000000;
   	if ((mem_map != NULL)&&(mem_map->blockReset() == ErrorOccurred)&&(err_ptr == NULL))
   			err_ptr = &(mem_map->ReturnCopyOfError());

        full_blocks = 0;
}

// this routine dumps all blocks and sets the play state to a new value so the source holds blocks
// for the new play method.

error_flag
Source::setNewPlayState(ULONG *request_num, size_t *max_complete, play_mode mode, ULINT from_time, ULINT timeout)
{
	size_t freebuf;
	start_end_block = 0;
	int i;
	error_flag result = ErrorState();

	current_play_id &= ~0xff000000;	// use the most significant two nibbles for flagging

  	if (current_play_id >= 0xFFFFFF)// rotate play id
  		current_play_id = 0;	// this avoids negative numbers -1 of which is used for end of stream
  	else
  		++current_play_id;

        most_significant_time = from_time;

  	current_play_id |= mode << 24;// flag the playmode in the top bits of the play_id

   	if ((mem_map != NULL)&&(mem_map->blockReset() == ErrorOccurred)&&(err_ptr == NULL))
   		err_ptr = &(mem_map->ReturnCopyOfError());

        full_blocks = 0;

        result = getBlockStatus(0, 0, &freebuf);
     	if (freebuf > NEC_databurstval)
   		freebuf = NEC_databurstval;

	(*max_complete) = (int)(last_block_sent = max_completed_block = prior_max_request);

	(*request_num) = (int)(max_completed_block + freebuf);

   	if (mode != mode_streamlive){
		unsigned int systime;
		MemBlock *mb;
		_swix(OS_ReadMonotonicTime, _OUT(0), &systime);
		for (i = 1; (max_completed_block+i) <= (*request_num); i++){
			mb = mem_map->findBlock(max_completed_block+i);
			if (mb != NULL){
				mb->nak_timeout = (unsigned int)(systime + timeout + (i-1)*block_time);
				mb->special_play_id = (unsigned int)get_current_play_id();
			}
		}
	}
#ifdef DEBUGLIB
	if (Debug(debug_blockerrors))
		Debug("new play state mx_complete = %i", (*max_complete));
#endif
     return result;
}

//
// Gets a pointer to the next completed complete block.  Changes to the
// data structures associated with the block are locked out until the
// block is freed with a call to the freeBlock method.
//
//
//
error_flag
Source::getBlock(NECBlock **block, BitstreamBufferDescriptor **mpeg_buffer, int free_routine, int pw, int *scene, int *playid)
{
       MemBlock *mb;
       error_flag result = ErrorState();

       _kernel_irqs_off();

       do {
        	mb = mem_map->findExistingBlock(last_block_sent + 1);

        	if (mb == NULL)
        		break;
        	else {
        		if (mb->special_play_id != get_current_play_id()){
        			mb->deleted_block = 1;
        			mb->completed = 1;
        		}

        		if (mb->deleted_block){
        			++last_block_sent;
        			mb->to_be_freed = 1;
        		}
        	}
        } while (mb->deleted_block);

 	if (mb != NULL && mb->inuse && mb->completed) {
                mb->mpeg_owned = 1;
                last_block_sent = mb->block_id;
        }
        else
        	mb = NULL;	// if we cannot use it

  	_kernel_irqs_on(); // claimed our block

  	if (mb != NULL){
        	result = mem_map->memMemBlockToNECBlock(mb, block);
        	//------- optimisation --
          	int j, i;
          	(*block)->num_buffers = 0;
          	(*block)->max_buffers = mb->dgrams_in_block;
          	if ((*block)->buffers[0].buffer_length < sizeof(NECBlockHeader)){
          		result = MakeError(VSP_DatagramSizeError);
#ifdef DEBUGLIB
				if (Debug(debug_always))
					Debug("datagram size error %i < %i", (*block)->buffers[0].buffer_length,  sizeof(NECBlockHeader));
#endif
		}
          	else
          	{
          	  	for (i = 0; i < mb->dgrams_in_block; ++i){
          		  	j = i;
          		  	while ((i+1 < mb->dgrams_in_block)&&
          		  	    ((*block)->buffers[i+1].buffer_ptr == (*block)->buffers[i].buffer_ptr + (*block)->buffers[i].buffer_length)){
          		  		(*block)->buffers[j].buffer_length += (*block)->buffers[i+1].buffer_length;
          		  		i++;
          		  	}

          		  	if ((i+1) == mb->dgrams_in_block)
          		  	  	(*block)->buffers[j].link = NULL;
          		  	else
          		  		(*block)->buffers[j].link = &((*block)->buffers[i+1]);

          		  	(*block)->buffers[j].free_routine = free_routine;
          		  	(*block)->buffers[j].free_workspace = pw;
				(*block)->buffers[j].packets = 0;

          		  	++(*block)->num_buffers;
          	        }
                }
                (*scene) = ((NECBlockHeader*)(*block)->buffers[0].buffer_ptr)->scene_number;	// in network order, no problem
           	(*playid) = mb->special_play_id;
#ifdef DEBUGLIB
	if (Debug(debug_time))
		if (mb != NULL)
			Debug("b[%i] t=%i p_id = %i",
			 mb->block_id, ntohl(((NECBlockHeader*)(*block)->buffers[0].buffer_ptr)->playback_time), (mb->special_play_id >> 24));
#endif
           	(*block)->buffers[0].buffer_ptr    +=  sizeof(NECBlockHeader);
  		(*block)->buffers[0].buffer_length -=  sizeof(NECBlockHeader);

  		if ( (*block)->buffers[0].buffer_length == 0 )
    			(*mpeg_buffer) = (BitstreamBufferDescriptor*)((*block)->buffers[0].link);
    		else {

			(*mpeg_buffer) = &((*block)->buffers[0]);
		}
	}
        else
                *block = 0;

/*
#ifdef DEBUGLIB
	if (Debug(debug_blockerrors)) {
		if (mb == NULL)
			Debug("gb NULL");
		else
			Debug("gb [%i]", mb->block_id);
	}
#endif
*/
     return result;
}

//
// Releases the specifed block structure.  The data structures associated
// with the block are marked available for re-use.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
error_flag
Source::freeBlock(const NECBlock *block)
{
  MemBlock *mb;

  error_flag result = mem_map->memNECBlockToMemBlock(block, &mb);
  if (result != ErrorOccurred){
   	mb->nec_block.buffers[0].buffer_ptr    -=  sizeof(NECBlockHeader);
  	mb->nec_block.buffers[0].buffer_length +=  sizeof(NECBlockHeader);
  	if (mb->special_play_id == get_current_play_id())
        	most_significant_time = (ULINT)ntohl(((NECBlockHeader*)(mb->nec_block.buffers[0].buffer_ptr))->playback_time);

 	mb->mpeg_owned = 0;
  	mb->to_be_freed = 1;
  }
  return result;
}

// calculates if any blocks need to be freed

error_flag
Source::calculate_freeBlocks(InternetObject *server, callback_flag *callback_pending, Statistics *stats, ULINT timeout)
{
    	int i;
 	error_flag result = ErrorState();

        for (i = 0; ( (i < mem_map->maxBlocks())&&(result != ErrorOccurred)); i++) {
                MemBlock *mb = mem_map->getBlock(i);
                if (mb->to_be_freed != 0){
                	result = mem_map->freeBlock_background(mb);
                }
        }

 	if ((*callback_pending) & callback_fullblocks)
 	{
  		(*callback_pending) -= callback_fullblocks;
#ifdef DEBUGLIB
		if (Debug(debug_callbacks)) Debug("-callback_fullblocks fb");
#endif
  	}

	result = calculatePosAckSequence(server, stats, timeout);

        return result;
}
//
// Allows the Source object foreground execution time so that it can perform
// operations not permitted in the interrupt method.  Use of private_handle is
// not yet defined.
//
// Errors: None.
//
//
error_flag
Source::foregroundExecute(InternetObject *server, Statistics *stats, ULINT *timeout)
{
   if (!ErrorExists()){
      	calculateMaxCompleteBlock();
        if (!ErrorExists()) calculatePosAckSequence(server, stats, (*timeout));
       	if (!ErrorExists()) calculatePosNAKSequence(server, stats, NULL, timeout);
    }
    return ErrorState();
}

//
// Informs a Source object that a dynamic area has been renumbered.  Each
// object needs to check whether its own dynamic area is the one being
// renumbered and note the change for future reference.
//
// Errors: None.
//
error_flag
Source::serviceDynamicAreaRenumber(int old_id, int new_id)
{
        if (old_id == mem_map->getDaNumber()) {
                mem_map->setDaNumber(new_id);
        }
        return NoError;
}

//
// Gets the underlying socket object being used for UDP datagram reception
// by the Source class.
//
// Errors: None.
//
error_flag
Source::getSocketDescriptor(int *s)
{
        error_flag result;
        if (sd.valid()) {
                *s = sd.getSocketDescriptor();
                result = NoError;
        }
        else {
          	RemoveErr();		// remove the uninit error
                result = MakeError(IP_SocketError);
        }

        return result;
}
//
//
// Reads a pending datagram into a free datagram buffer and links it into the
// block's scatter array.
//
// Errors: IP_ReadFail, VSP_Alloc
//
//
error_flag
Source::ReadDatagrams(callback_flag *flags, Statistics *stats, ULINT *timeout)
{
        error_flag result = ErrorState();

        NECDatagram *dgram;
        int size = 1;

        while (( size > 0)&&(result != ErrorOccurred)){

         	result = mem_map->memFindFreeDatagramBuffer((DummyNECDatagram **)&dgram);

         	if ( result != ErrorOccurred) {
                	struct iovec iov[2];

                	iov[0].iov_len =  sizeof(NECDatagram);
                	iov[1].iov_len =  (unsigned int)(mem_map->dgramSize());

                	iov[0].iov_base = (char*) dgram;
                	iov[1].iov_base = (char*) mem_map->findPayloadBuffer((DummyNECDatagram*)dgram);

                	size = sd.read(iov,sizeof(iov)/sizeof(struct iovec));	// read from socket

                 	if ( size >= sizeof(NECDatagram) )
                 	{			// if greater than header size
                 		MemBlock *mb = NULL;
                 	  	stats->bytes_received += size;
                  	  	++(stats->dgrams_read);

                	  	ntoh_structure(dgram, map_NECDatagram, NECDatagram);
#ifdef DEBUGLIB
     	       			if (Debug(debug_datagrams))
     	       				Debug("dgram  [%i], play_id %i, s_word %8.8X", dgram->block_number, dgram->playback_classification_id, dgram->status_word);
#endif

               			if ( (dgram->dgram_seq < mem_map->dgramsPerBlock())
         			   &&(dgram->block_number > max_completed_block)&&(dgram->playback_classification_id == get_current_play_id())
         			   &&( (mb=mem_map->findExistingBlock(dgram->block_number)) != NULL)&&(!mb->deleted_block) )
         			   {
         									// if that piece of information is not already received
       					if (mb->nec_block.buffers[dgram->dgram_seq].buffer_ptr == NULL)
       					{
       					  					// assign that datagram to the block
						mb->nec_block.buffers[dgram->dgram_seq].buffer_ptr = iov[1].iov_base;
       						mb->nec_block.buffers[dgram->dgram_seq].buffer_length = (unsigned int) dgram->dgram_size;
       						++mb->dgrams_received;

       						if (mb->dgrams_in_block == 0)
       						{	// if block values needs initialising
       							// set the timeout of this new block

       							if (dgram->dgram_total != 0)
       							{
       	       							mb->special_play_id = (int) dgram->playback_classification_id;

       							  	if (dgram->dgram_total <= mem_map->dgramsPerBlock())
       							  	{
       	       								mb->dgrams_in_block = (unsigned int) dgram->dgram_total;
       	       							}
       	       							else
       	       							{
#ifdef DEBUGLIB
       	       							  	if (Debug(debug_blockerrors))
       	       							  		Debug("block error insufficent memory allocated / block %i-%i",
       	       							  				dgram->dgram_total, mem_map->dgramsPerBlock());
#endif
       	       							  	++stats->deleted_blocks;
       							  	  	mb->dgrams_in_block = mem_map->dgramsPerBlock();
       							  	}
       	       						}
       	       					}// initialise the block

       	       					// Block may only have one dgram so check this even if its just been initialised
						if ( (mb->dgrams_received == mb->dgrams_in_block) || (dgram->status_word & 0x01) )
						{
					  		// if completed or deleted
					  		if (mb->block_id == (max_completed_block+1))
					  			(*flags) = callback_timeout;	// set a new timeout value

							mb->completed = 1;			// assign completed block
							mb->pending_nak = 0;
							deleted_blocks = 0;			// reset the timeout

							result = calculateMaxCompleteBlock();	// calculate most completed

							MemBlock *mb2 = mem_map->findExistingBlock(max_completed_block+1);

							if (mb2 != NULL)
							{
								 if ((*flags) == callback_timeout)
								 { // calculate the timeout
									unsigned int systime;
									_swix(OS_ReadMonotonicTime, _OUT(0), &systime);
							 		int x = mb2->nak_timeout - systime;
									(*timeout) = (x > 0) ? x:0;
								}
							}
							else
								(*flags) = callback_fullblocks;

							if (dgram->status_word & 0x01)
							{
#ifdef DEBUGLIB
       							  	if (Debug(debug_blockerrors))
       							  		Debug("block [%i] deleted by server", mb->block_id);
#endif
								mb->deleted_block = 1;
								if (mb->block_id == last_block_sent +1){
			  						++last_block_sent;
									mb->to_be_freed = 1;
				                                }
							  	++(stats->deleted_blocks);
						        }
#ifdef DEBUGLIB
							else
							{
       							  	if (Debug(debug_blocks))
       							  		Debug("-------- blk [%i] complete", mb->block_id);
       							}
#endif
						}
				        } // datagram with that value already exists.
       					else
       					{
       						++(stats->duplicate_dgrams);
                 			       	result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
#ifdef DEBUGLIB
       	       					if (Debug(debug_blockerrors))
       	       						Debug("duplicate dgram");
#endif
       					}
               		        }// less than dgrams/block and can find block number.
               		        else
               		        {
#ifdef DEBUGLIB
       	       				if (Debug(debug_blockerrors))
       	       				{
               					if (dgram->dgram_seq >= mem_map->dgramsPerBlock()) Debug("failed, seq %i", dgram->dgram_seq);
         			   		if (dgram->playback_classification_id != get_current_play_id()) Debug ("failed, playid %i", dgram->playback_classification_id);
         			   		if (dgram->block_number <= max_completed_block) Debug("failed, maxblk %i", max_completed_block);
         			   		if (mb == NULL) Debug("failed, mb==NULL");
         			   		else
         			   			if (mb->deleted_block) Debug("failed, deleted blk");
       	       				}
#endif
               		        	result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
               		          	if ((result != ErrorOccurred)&&(mem_map->ErrorExists()))
               		          	{
       						  result = ErrorOccurred;
       						  mem_map->ReturnCopyOfError();
       					}
               		        }
	               	}// (size > datagram header)
        	       	else
        	       	{
                        	result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
                        	result = setSocketError(size);
#ifdef DEBUGLIB
       	       			if (Debug(debug_blockerrors))
       	       				if (size > 0) Debug("dgram too small, size %i", size);
#endif
                        }
                }// no error occurred in finding a free datagram
                else
                {
        		result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
        		if ((result != ErrorOccurred)&&(mem_map->ErrorExists()))
        		{
       				result = ErrorOccurred;
       				mem_map->ReturnCopyOfError();
       			}
#ifdef DEBUGLIB
       	       		if (Debug(debug_blockerrors))
       	       			Debug("no free dgram");
#endif
                }

        }// while datagrams

        return result;
}

error_flag
Source::getMiscInfo(misc_info_flags flags, void *ptr)
{
  error_flag result = ErrorState();

	switch (flags) {
	  case type_buffers:
	  		result = getBlockStatus(((size_t*)ptr));
	  	break;
	  case type_misc_5_10:
	  	{
  			NECBlockHeader most_significant_block;
	  		misc_5_10 *ptr_misc_5_10 = (misc_5_10*)ptr;

  			(void) memset((void*)&most_significant_block, 0, sizeof(NECBlockHeader));
	  		MemBlock *mb = mem_map->findExistingBlock(last_block_sent);

	  		if (mb != NULL) {
	  		  	if (mb->mpeg_owned)
  					memcpy(	(void*)&most_significant_block,
  						(void*)(mb->nec_block.buffers[0].buffer_ptr- sizeof(NECBlockHeader)),
  						sizeof(NECBlockHeader));
  				else
  					memcpy(	(void*)&most_significant_block,
  						(void*)mb->nec_block.buffers[0].buffer_ptr,
  						sizeof(NECBlockHeader));

				ptr_misc_5_10->h_pixels = ntohs(most_significant_block.image_width);
  				ptr_misc_5_10->v_pixels = ntohs(most_significant_block.image_height);
	 			ptr_misc_5_10->play_time = ntohl(most_significant_block.playback_time);
 	 			ptr_misc_5_10->status_word = ntohs(most_significant_block.status_word);
 	 			ptr_misc_5_10->scene_number = ntohs(most_significant_block.scene_number);
 	 			ptr_misc_5_10->head_time = ntohl(most_significant_block.video_start_time);
	 			ptr_misc_5_10->end_time = ntohl(most_significant_block.video_end_time);
 	 			ptr_misc_5_10->encode_time = ntohl(most_significant_block.encode_time);
	  			ptr_misc_5_10->bitrate = ntohl(most_significant_block.bit_rate_value);
	  		}
	  	}
	  	break;

#ifdef DEBUGLIB
	default:
		{
		Debug("MiscInfo - max comp %i-%i c_id = %i", max_completed_block, last_block_sent, current_play_id);

         		for (int i = 0; ( (i < mem_map->maxBlocks())&&(result != ErrorOccurred) ); i++) {
         		      MemBlock *mb = mem_map->getBlock(i);
         		      Debug("block (%i)(%i)(%i)(%i)(%i)[%i] - %i, %i/%i, p_id = %i",
         		     	 mb->deleted_block!=0, mb->to_be_freed!=0, mb->mpeg_owned!=0, mb->completed!=0, mb->inuse!=0, mb->block_id,
         		     	 mb->nak_timeout, mb->dgrams_received, mb->dgrams_in_block, mb->special_play_id);
         		}
         	}
         	break;
#endif
        } // switch
  return result;
}

//---------------------------------------------------------------------- LIVE specific --------------------
SourceLIVE::SourceLIVE(Source& vod):Source(0,0)
{
  last_block_sent = 0;
  max_completed_block = prior_max_request = 0;
  most_significant_time = 0;
  nak_timeout = vod.get_nakTimeout();
  current_play_id = 0;		// this is the trickplay flag this changes with each new trickplay
  start_end_block = 0;
  deleted_blocks = 0;
  	// Network information
  vod.SetSourceVar(&sd, &mem_map);

  mem_map->blockReset();

  full_blocks = 0;
}

// this is the same as source free blocks but doesn't send naks if the blocks are full
error_flag
SourceLIVE::calculate_freeBlocks(InternetObject *, callback_flag*, Statistics*, ULINT)
{
    	int i;

 	error_flag result = ErrorState();

        for (i = 0; ( (i < mem_map->maxBlocks())&&(result != ErrorOccurred)); i++) {
                MemBlock *mb = mem_map->getBlock(i);
                if (mb->to_be_freed != 0){
                	result = mem_map->freeBlock_background(mb);
                }
        }
        full_blocks = (int)(max_completed_block - last_block_sent);

       return result;
}

error_flag
SourceLIVE::foregroundExecute(InternetObject*, Statistics*, ULINT*)
{
  error_flag result = ErrorState();

  if (mem_map == NULL)
  	result = MakeError(VSP_SourceUninit);
  else {
  	if ( ++deleted_blocks > (Acceptable_deleted_blocks*Acceptable_NAKS))
		result = MakeError(IP_TimeOutOnCommunication);
  }

  return result;
}

error_flag
SourceLIVE::ReadDatagrams(callback_flag *flags, Statistics *stats, ULINT *timeout)
{
  timeout = timeout;

        error_flag result = ErrorState();

        NECDatagram *dgram;
        int size = 1;

        while (( size > 0)&&(result != ErrorOccurred)){

         	result = mem_map->memFindFreeDatagramBuffer((DummyNECDatagram **)&dgram);

         	if ( result != ErrorOccurred) {
                	struct iovec iov[2];

                	iov[0].iov_len =  sizeof(NECDatagram);
                	iov[1].iov_len =  (unsigned int)(mem_map->dgramSize()) ;

                	iov[0].iov_base = (char*) dgram;
                	iov[1].iov_base = (char*) mem_map->findPayloadBuffer((DummyNECDatagram*)dgram);

                	size = sd.read(iov,sizeof(iov)/sizeof(struct iovec));	// read from socket

                 	if ( size >= sizeof(NECDatagram) ){			// if greater than header size
                 		MemBlock *mb = NULL;
                 	  	stats->bytes_received += size;
                  	  	++(stats->dgrams_read);

                	  	ntoh_structure(dgram, map_NECDatagram, NECDatagram);

         			if ( (dgram->dgram_seq < mem_map->dgramsPerBlock())
         			    &&((mb = mem_map->findOrReplaceBlock(dgram->block_number,&last_block_sent, &max_completed_block, stats)) != NULL ) ) {
         									// if that piece of information is not already received
       					if (mb->nec_block.buffers[dgram->dgram_seq].buffer_ptr == NULL) {
       					  					// assign that datagram to the block
						mb->nec_block.buffers[dgram->dgram_seq].buffer_ptr = iov[1].iov_base;
       						mb->nec_block.buffers[dgram->dgram_seq].buffer_length = (unsigned int) dgram->dgram_size;
       						++mb->dgrams_received;

       						if (mb->dgrams_in_block == 0) {	// if block values needs initialising
       							deleted_blocks = 0;
       							if (dgram->dgram_total != 0){
       	       							if (dgram->dgram_total > mem_map->dgramsPerBlock()){
       	       							        ++stats->deleted_blocks;
       							  	  	mb->dgrams_in_block = mem_map->dgramsPerBlock();
       							  	}
       							  	else
       	       								mb->dgrams_in_block = (unsigned int) dgram->dgram_total;

       	       							mb->special_play_id = (int) dgram->playback_classification_id;
       	       						}
       	       					}

    						// if completed
    						if ((mb->dgrams_in_block != 0)&&(mb->dgrams_received == mb->dgrams_in_block)){

							mb->completed = 1;	// assign completed block
							mb->pending_nak = 0;

	       						result = calculateMaxCompleteBlock();	// calculate most completed

							if (max_completed_block < dgram->block_number){
							  	// clean up blocks that will not fill
							  	mb = mem_map->findExistingBlock(max_completed_block+1);
							  	while ((mb != NULL)&&(mb->block_id < dgram->block_number)){
							  		if (mb->completed != 1){
										++(stats->deleted_blocks);
										mem_map->freeBlock_background(mb);
									}
									mb = mem_map->findExistingBlock(mb->block_id+1);
							        }
								result = calculateMaxCompleteBlock();	// re-calculate most completed
							}

							(*flags) += callback_timeout;

        						full_blocks = (int)(max_completed_block - last_block_sent);
					        }// dgrams in block
				        }
       					else { 	//duplicate datagram != 0
       						++(stats->duplicate_dgrams);
                 			       	result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
       					}
               		        }
               		        else {
               		        	result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
               		          	if ((result != ErrorOccurred)&&(mem_map->ErrorExists())){
       						  result = ErrorOccurred;
       						  mem_map->ReturnCopyOfError();
       					}
               		        }
	               	}// (size > datagram)
        	       	else {
                        	result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
                        	result = setSocketError(size);
                        }
                }// no error result
                else {
        		result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
        		if ((result != ErrorOccurred)&&(mem_map->ErrorExists())){
       				result = ErrorOccurred;
       				mem_map->ReturnCopyOfError();
       			}
                }

        }// while datagrams
        return result;
}

//---------------------------------------------------------------------- BroadCast specific --------------------

SourceMultiCast::SourceMultiCast(InternetObject *server, size_t source_recvspace, size_t numBlocks, int timeout):SourceLIVE(0, source_recvspace)
{
 	// unused
  	full_blocks = 0;
        nak_timeout = 0;
        most_significant_time = 0;
        current_play_id = 0;
        start_end_block = 0;
        deleted_blocks = 0;
        mem_map = NULL;
  	struct ip_mreq mreq;

        sd.creat(PF_INET, SOCK_DGRAM);

	mreq.imr_interface.s_addr = INADDR_ANY;
        mreq.imr_multiaddr.s_addr = server->address.s_addr;

        setSocketError(setsockopt(sd.getSocketDescriptor(), IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)));

        sd.setrecvspace(source_recvspace);

        if ( sd.getDgramSize() < sizeof(MultiCastDatagram) )
        	sd.setDgramSize(sizeof(MultiCastDatagram));

        if (!ErrorExists()) setSocketError(sd.eventsOn());
        if (!ErrorExists()) setSocketError(sd.makeNonBlocking());

        if (!ErrorExists()) setSocketError(sd.bind((int)(server->portnumber)));

        if (!ErrorExists()){
          	int size;
        	ULINT t1, t2;
                struct iovec iov;
                MultiCastDatagram header;

                iov.iov_len  = sizeof(MultiCastDatagram);
                iov.iov_base = (char*)&header;

        	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t2);
        	t1 = t2;
        	t2 += timeout;

        	do {
          		size = sd.read(&iov, sizeof(iov)/sizeof(struct iovec));	// read from socket

          		if (size < (int)(sizeof(MultiCastDatagram)))
          			sd.wait_read((unsigned int)((timeout+50)/100));

        		if (setSocketError(size) == ErrorOccurred)
        			break;

        		(void) _swix(OS_ReadMonotonicTime, _OUT(0), &t1);

        	} while ((size < sizeof(MultiCastDatagram))&&(t1 < t2));

 		if (t1 >= t2)
 			MakeError(IP_TimeOutOnCommunication);
 		else {
 		   	if (!ErrorExists()){

 		   	  	ntoh_structure(&header, map_MultiCastDatagram, MultiCastDatagram);
#ifdef DEBUGLIB
				if (Debug(debug_multicast)) {
                 	  		Debug("packet id     %8.8X", 	header.EMPacketID);
                  	  		Debug("payload       %i", 	header.PayloadLength);
                  	  		Debug("datarate Kb   %i", 	header.DataRate);
                  	  		Debug("picture hxw   %ix%i", 	header.H_pixels, header.V_pixels);
                  	  		Debug("MaxLength     %i", 	header.MaxLength);
                  	  		Debug("TimeStamp     %i", 	header.TimeStamp);
                  	  		Debug("EMPacketsize  %i", 	header.EMPacketSize);
                  	  		Debug("fragment      %i", 	header.fragmentOffset);
                  	  		Debug("continued     %i", 	header.Continuity);
                  	  		Debug("Mpeg type     %i", 	header.DataType);
                  	  	}
#endif
 		   	  	pixel_height = header.H_pixels;
 		   	  	pixel_width  = header.V_pixels;
#ifdef MULTICAST_REL2
 		   	  	bitrate = header.DataRate>>10;
#else
 		   	  	bitrate = header.DataRate;
#endif
                  	  	max_completed_block = last_block_sent = header.EMPacketID;

                  	  	if (header.MaxLength <= sizeof(MultiCastDatagram)) {
        		        	MakeError(VSP_DatagramSizeError);
        			} else {
 		   			sd.setDgramSize((size_t)header.MaxLength);

  					mem_map = new SourceMemMap(numBlocks, (size_t)header.EMPacketSize, (size_t)header.MaxLength - sizeof(MultiCastDatagram) );

  					if (mem_map->ErrorState() == ErrorOccurred){
  						if (err_ptr == NULL)
   							err_ptr = &(mem_map->ReturnCopyOfError());	// this will be VSP_Alloc
   						delete mem_map;
   						mem_map = NULL;
   					}
   				}
   	                }
 		}
 	}
}
//
// Gets a pointer to the next completed complete block.  Changes to the
// data structures associated with the block are locked out until the
// block is freed with a call to the freeBlock method.
//
//
//
error_flag
SourceMultiCast::getBlock(NECBlock **block, BitstreamBufferDescriptor **mpeg_buffer, int free_routine, int pw, int *scene, int*)
{
        MemBlock *mb;
        error_flag result = ErrorState();

       _kernel_irqs_off();

        do { // determine if last block sent is missing datagrams if so delete it
             // we assume that there are no out of order blocks.
        	mb = mem_map->findExistingBlock(last_block_sent + 1);

        	if (mb == NULL)	break;
        	else {
        	  	if (mb->deleted_block){
        			++last_block_sent;
        			mb->completed = 1;
        			mb->to_be_freed = 1;
        		}
        	}

        } while (mb->deleted_block);

 	if (mb != NULL && mb->inuse && mb->completed) {
                mb->mpeg_owned = 1;
                last_block_sent = mb->block_id;
        }
        else
        	mb = NULL;	// if we cannot use it

  	_kernel_irqs_on(); // claimed our block

 	if (mb != NULL) {
        	result = mem_map->memMemBlockToNECBlock(mb, block);
          	//------- optimisation --
          	int j, i;
          	(*block)->num_buffers = 0;
          	(*block)->max_buffers = mb->dgrams_in_block;
		for (i = 0; i < mb->dgrams_in_block; ++i){
          		j = i;
          		while ((i+1 < mb->dgrams_in_block)&&((*block)->buffers[i+1].buffer_ptr == (*block)->buffers[i].buffer_ptr + (*block)->buffers[i].buffer_length)){
          		  	(*block)->buffers[j].buffer_length += (*block)->buffers[i+1].buffer_length;
          		  	i++;
          		}
          		if (i+1 == mb->dgrams_in_block)
          			(*block)->buffers[j].link = NULL;
          		else
          			(*block)->buffers[j].link = &((*block)->buffers[i+1]);

          		(*block)->buffers[j].free_routine = free_routine;
          		(*block)->buffers[j].free_workspace = pw;
          		(*block)->buffers[j].packets = 0;

          		++(*block)->num_buffers;
          	}
#ifdef DEBUGLIB
		if (Debug(debug_blocks)) {
		  	BitstreamBufferDescriptor *tmp;
		  	Debug("get block [%i]", mb->block_id);
		  	tmp =  &((*block)->buffers[0]);
		  	while (tmp != NULL){
				Debug(" --- size --- %8.8X", tmp->buffer_length);
				tmp = (BitstreamBufferDescriptor*)tmp->link;
			}

		}
#endif
		(*mpeg_buffer) = &((*block)->buffers[0]);
#ifdef MULTICAST_REL2
		(*scene) = mb->special_play_id;
#else
		scene = scene;
#endif
	}
        else
                *block = 0;

     return result;
}

//
// Releases the specifed block structure.  The data structures associated
// with the block are marked available for re-use.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
error_flag
SourceMultiCast::freeBlock(const NECBlock *block)
{
  MemBlock *mb;


  error_flag result = mem_map->memNECBlockToMemBlock(block, &mb);
  if (result != ErrorOccurred){
  	mb->to_be_freed = 1;
  	mb->mpeg_owned = 0;
  }
  return result;
}

//
// Reads a pending datagram into a free datagram buffer and links it into the
// block's scatter array.
//
// Errors: IP_ReadFail, VSP_Alloc
//
// In this case there is one datagram per block that datagram is the size of an EM packet
// if an MPC packet is fragmented it is joined here.

error_flag
SourceMultiCast::ReadDatagrams(callback_flag *flags, Statistics *stats, ULINT *timeout)
{
  timeout = timeout;

       error_flag result = ErrorState();

        MultiCastDatagram *dgram;
        int size = 1;

        while (( size > 0)&&(result != ErrorOccurred)){

         	result = mem_map->memFindFreeDatagramBuffer((DummyNECDatagram**)&dgram);

         	if ( result != ErrorOccurred) {
                	struct iovec iov[2];

                	iov[0].iov_len =  sizeof(MultiCastDatagram);
                	iov[1].iov_len =  (unsigned int)(mem_map->dgramSize());

                	iov[0].iov_base = (char*) dgram;
                	iov[1].iov_base = (char*) mem_map->findPayloadBuffer((DummyNECDatagram*)dgram);

                	size = sd.read(iov,sizeof(iov)/sizeof(struct iovec));	// read from socket

                 	if ( size >= sizeof(MultiCastDatagram) ){		// if greater than header size
                 		MemBlock *mb = NULL;
                 	  	stats->bytes_received += size;
                  	  	++(stats->dgrams_read);

                	  	ntoh_structure(dgram, map_MultiCastDatagram, MultiCastDatagram);
#ifdef DEBUGLIB
     	       			if (Debug(debug_datagrams)) {
     	       				Debug("[%i]+%8.8X", dgram->EMPacketID, dgram->fragmentOffset);
                 	  	}
#endif

				if ((mb = mem_map->findOrReplaceBlock(dgram->EMPacketID, &last_block_sent, &max_completed_block, stats)) != NULL ) {
				  	// determine the fragment
				  	ULONG datagram_num = (dgram->fragmentOffset / mem_map->dgramSize());

				  	if (datagram_num < mem_map->dgramsPerBlock()) {

				  		if (mb->nec_block.buffers[datagram_num].buffer_ptr == NULL) {
				  			// assign the  block the the location in the header
       					  		mb->nec_block.buffers[datagram_num].buffer_ptr = iov[1].iov_base;
       							mb->nec_block.buffers[datagram_num].buffer_length = (unsigned int) dgram->PayloadLength;
       							++mb->dgrams_received;


       							if (mb->dgrams_in_block == 0){ // if the block value need initialising.
       								deleted_blocks = 0;
#ifdef MULTICAST_REL2
       							  	mb->special_play_id = dgram->SceneCounter;// this is overloaded for scenes
#endif
								mb->dgrams_in_block = (unsigned int) mem_map->dgramsPerBlock();
        						}

        						// the number of datagrams in a block is defined by the block without continuity
        						if (!dgram->Continuity)
        						  	mb->dgrams_in_block = (unsigned int) datagram_num + 1; // datagrams start at 0

        						// if completed
    							if ((mb->dgrams_in_block != 0)&&(mb->dgrams_received == mb->dgrams_in_block)){

								mb->completed = 1;	// assign completed block
								mb->pending_nak = 0;

	       							result = calculateMaxCompleteBlock();	// calculate most completed
													// stream live or full buffers
								if (max_completed_block < dgram->EMPacketID){
								  	// clean up blocks that will not fill
								  	mb = mem_map->findExistingBlock(max_completed_block+1);
								  	while ((mb != NULL)&&(mb->block_id < dgram->EMPacketID)){
								  		if (mb->completed != 1){
											++(stats->deleted_blocks);
											mem_map->freeBlock_background(mb);
										}
										mb = mem_map->findExistingBlock(mb->block_id+1);
								        }
									result = calculateMaxCompleteBlock();	// re-calculate most completed
								}

								(*flags) += callback_timeout;

        							full_blocks = (int)(max_completed_block - last_block_sent);
					        	}// completed

        					} else { //duplicate datagram != 0
       							++(stats->duplicate_dgrams);
                 			       		result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
        					}
        				} else { // too manu datagrams
				  		++stats->deleted_blocks;
				  	  	result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
				   	}
				} else { // error allocating or replacing block
               		        	result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
               		        	if ((result != ErrorOccurred)&&(mem_map->ErrorExists())){
       				  		result = ErrorOccurred;
       						mem_map->ReturnCopyOfError();
       				        }
               		        }
        	       	} else {  // datagram too small for header.
                        	result = mem_map->memFreeDatagram((DummyNECDatagram*)dgram);
        	       		result = setSocketError(size);
                        }
                } // no error result
        }// while datagrams
        return result;
}

error_flag
SourceMultiCast::getMiscInfo(misc_info_flags flags, void *ptr)
{
  error_flag result = ErrorState();

	switch (flags) {
	  case type_buffers:
	  		result = getBlockStatus(((size_t*)ptr));
	  	break;
	  case type_misc_5_10:
	  	{
	  	  misc_5_10 *ptr_misc_5_10 = (misc_5_10*)ptr;

		  ptr_misc_5_10->h_pixels = pixel_height;
  		  ptr_misc_5_10->v_pixels = pixel_width;
	 	  ptr_misc_5_10->play_time = 0xFFFFFFFF;
 	 	  ptr_misc_5_10->status_word = 0;
 	 	  ptr_misc_5_10->scene_number = 0;
 	 	  ptr_misc_5_10->head_time = 0;
	 	  ptr_misc_5_10->end_time = 0;
 	 	  ptr_misc_5_10->encode_time = 0;
	  	  ptr_misc_5_10->bitrate = bitrate;
	  	}
	  	break;

#ifdef DEBUGLIB
	default:
		{
		Debug("MiscInfo - fullblocks %i, max comp %i-%i", full_blocks, max_completed_block, last_block_sent);
		ErrorDump(debug_always);

         		for (int i = 0; ( (i < mem_map->maxBlocks())&&(result != ErrorOccurred) ); i++) {
         		      MemBlock *mb = mem_map->getBlock(i);
         		      Debug("block (%i)(%i)(%i)(%i)[%i] - %i, %i/%i, p_id = %i",
         		     	 mb->to_be_freed!=0, mb->mpeg_owned!=0, mb->completed!=0, mb->inuse!=0, mb->block_id, mb->pending_nak!=0,
         		     	 mb->dgrams_received, mb->dgrams_in_block, mb->special_play_id);
         		}
         	}
         	break;
#endif
        } // switch
  return result;
}
