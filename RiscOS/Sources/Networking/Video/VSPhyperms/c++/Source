/**************************************
 Source.c++

implements Source class
© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
03/09/98  SNB     File created

**************************************/
extern "C" {
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

// Current Clib stddef.h does not define a C++ compatible offsetof
#undef offsetof
#define offsetof(type, member) \
    ((size_t)((char *)&(((type *)0)->member) - (char *)0))

#include "kernel.h"
#include "swis.h"
}

#include "SourceP.h"
#include "Source.h"

extern "C" {
#include "sys/ioctl.h"
#include "netinet/udp.h"
}
//---------------------------------------------------------------------- private -- run time calculations --------------------

// calculate the largest block_id for full blocks, this means that no block_id
// smaller shall be incomplete and no block_id greater shall be complete.

error_flag
Source::calculateMaxCompleteBlock(void)
{
  MemBlock *mb;
  
  while (((mb = mem_map->findExistingBlock(max_completed_block+1)) != NULL)&&(mb->inuse)&&(mb->completed))
  	max_completed_block++;
  
  full_blocks = (int)(max_completed_block - last_block_sent);
  	
  return ErrorState();
}

// calculate a new window period if it is different from now then notify the server this is the only
// place where a request for more blocks during normal play.  Play notifications also have Ack capability.

// freeblocks does not take into account half full blocks but this is not important. What is most important
// is that we maintain a window from the most complete block no greater than that specified by the server.
// it is better to undercalculate than overestimate.

error_flag 
Source::calculatePosAckSequence(Server *server)
{
    size_t freeblocks;
    ULINT MAX_block_request;
    ULINT prior_max_request;
    error_flag result = NoError;
             
    if (result != ErrorOccurred){
	prior_max_request = server->getMaxRequestedBlock();
    	MAX_block_request = (max_completed_block + NEC_databurstval) - prior_max_request;
        
    	if (MAX_block_request > 0) {			// if window available
		result = getBlockStatus(0, 0, &freeblocks);
		if (freeblocks > 0) {
    			if (MAX_block_request > freeblocks)
    				MAX_block_request = freeblocks;
    				
    			MAX_block_request += prior_max_request;
    			
	   		if ((stream_end_block != 0)&&(MAX_block_request > stream_end_block))	{		// if set
	   			MAX_block_request = (int)stream_end_block;
	   		}
	   		if (MAX_block_request > prior_max_request){
#ifdef DEBUGLIB	     
	      			//Debug("ack [%i-%i], free %i", MAX_block_request, max_completed_block, freeblocks);
#endif	     
              			if (server->SendAck(MAX_block_request, max_completed_block) == ErrorOccurred) {
         				err = &server->ReturnCopyOfError();
          				result = ErrorOccurred;
               			}
               			MAX_block_request = server->getMaxRequestedBlock();
               			size_t block_location;
               			MemBlock *mb;
               			for (ULINT i = prior_max_request+1; i <= MAX_block_request; i++){
               				mb = mem_map->findBlock(i, &block_location);
               				if ((mb == NULL)&&(mem_map->ErrorExists())){
              				  	mem_map->RemoveErr();
               				}
               			}
               		}
	   	}
	}
    }
    return result;        
}
 
// this method could possibly be called in interrupt mode so don't change anything just read
// its purpose is to go through the blocks upto max_block to calculate the outstanding datagrams
// this method will then request re-sending of these blocks, there is two areas that this is called
// from; one is during normal operation, this searches all blocks that have been received so far
// the other is a stream save calculation this sets max_block to be the top of the window period.

error_flag          
Source::calculatePosNAKSequence(int *naks_sent, Server *server, int max_block)
{
        MemBlock *mb;
        int dgm, min_val, max_val;	// nak calcs
        size_t i;
        error_flag result = ErrorState();
                     
        i = (int)(max_completed_block+1);
        
        while( (i <= max_block)&&(result!=ErrorOccurred)&&((*naks_sent) < mem_map->dgrams_per_block) ) {
               if (((mb = mem_map->findExistingBlock(i)) == NULL)||(mb->dgrams_received == 0))	{// rare block missing case
               		if (*naks_sent != 0)
               			break;
               		else {
                 		(*naks_sent) += mem_map->dgrams_per_block;
                 		if (server->SendNak(i, 0, i, -1) == ErrorOccurred) {
                 			err = &(server->ReturnCopyOfError());
                 			result = ErrorOccurred;
                 		}
                 		break;
                 	}
               }
               else 
	       if ((mb->inuse)&&(!mb->completed)) {
               		dgm = 0;                 	  	                 	  	
               		while ((dgm < mb->dgrams_in_block)&&(result != ErrorOccurred)&&((*naks_sent) < mem_map->dgrams_per_block)){
               	  		while ((mb->nec_block.iov[dgm].iov_base != NULL)&&(dgm < mb->dgrams_in_block)) dgm++;
               	  		
               	  		min_val = dgm;
                		  	
               	  		while ((mb->nec_block.iov[dgm].iov_base == NULL)&&(dgm < mb->dgrams_in_block)) dgm++;
                 		  			
               	  		max_val = dgm - 1;

                		if (min_val <= max_val){
                 			  (*naks_sent) += (max_val - min_val)+1;
                 			  mb->pending_nak = 1;
                 			  if (server->SendNak(mb->block_id, min_val, mb->block_id, max_val) == ErrorOccurred) {
                 				err = &(server->ReturnCopyOfError());
                 				result = ErrorOccurred;
                 			  }
                 		}
                 	}// while datagrams      
               }// in use and not completed
               i++;
         }// for loop
         return result;
}

//---------------------------------------------------------------------- public -- object creation/deletion methods --------------------
// this creates the udp link and sets local variables
// 
Source::Source(void)
{
  	stream_end_block = current_play_id = full_blocks = 0;
  	
   	mem_map = NULL;
   	
        max_block_received = invalid_block_marker;
  	
  	
    	// Initialisation completed successfully
        sd = sd.creat(PF_INET, SOCK_DGRAM);
        setSocketError(sd.bind());
}

// this is to be called after the asset presentation dialogue
error_flag
Source::Allocate(size_t max_blocks, size_t block_size, size_t initial_block_num, size_t datagram_size)
{
  	error_flag result = ErrorState();
  	
 	if ((result == ErrorOccurred)&&(ErrorNum() == VSP_SourceUninit))
  		RemoveErr();	// if source memory not allocated error has occurred it is no longer relevant
  	
	if (result != ErrorOccurred) {	
  		if (initial_block_num < 1){
  		  	MakeError(VSP_InvalidValue);
  		  	result = ErrorOccurred;
  		}
  		else {					// must be greater than one by specification;
  			max_block_received = last_block_sent = max_completed_block = initial_block_num -1;
        	
        		if (datagram_size <= sizeof(struct udphdr)) {
        		        MakeError(VSP_DatagramSizeError);
        		        result = ErrorOccurred;
        		}
 			else {	
   				mem_map = new SourceMemMap(max_blocks, block_size + sizeof(struct udphdr), datagram_size);
   		
   				if (mem_map->ErrorState() == ErrorOccurred){
   		  			delete mem_map;
   		  			mem_map = NULL;
   		  			MakeError(VSP_SourceUninit);
   		                }
   		        }
   	        }
   	}
       	return result;
}

//
// Destructor.  Frees any memory associated with the object.
//
// Errors: None.
//
//
Source::~Source(void)
{
  	delete mem_map;
  	mem_map = NULL;
        
        sd.close();
}

//
// Converts the current value of errno into a VSP module error code if result
// was less than zero.  If result was >= 0, then there was no error.
// This method allows setSocketError(some_system_call()) to wrap system calls.
//
// Errors: TCP_BadPortSpecification, TCP_UnknownServer, TCP_SocketError
//         TCP_ServerRefusedConnection
//
error_flag
Source::setSocketError(int socket_result)
{
    error_flag result = ErrorState();
        
        if ((result != ErrorOccurred)&&(socket_result < 0)) {
                switch (errno) {
                        default:
                                MakeError(TCP_SocketError);
                                break;
                        case ECONNREFUSED:
                                MakeError(TCP_ConnectionRefused);
                                break;
                        case ENOENT:
                                MakeError(TCP_UnknownServer);
                                break;
                        case EINVAL:
                                MakeError(TCP_BadPortSpecification);
                                break;
                }
                result = ErrorOccurred;
        }
        else {
                result = NoError;
        }
        return result;
}

//
// Declares where the UDP packets are going to be coming from.  Port number
// may be specified as a number or a well-known service name.  Quoting a
// service "name" which is actually a string representation of a numeric value
// is treated as an explicit port selection.
//
// Errors: TCP_BadPortSpecification, TCP_UnknownServer, TCP_SocketError
//         TCP_ServerRefusedConnection
//
//
error_flag
Source::setServerDetails(const char *hostname, int port)
{
        sd.eventsOn();
        sd.makeNonBlocking();
        return setSocketError(sd.connect(hostname, htons(port)));
}

error_flag
Source::setServerDetails(const char *hostname, const char *port)
{
        sd.eventsOn();
        sd.makeNonBlocking();
        return setSocketError(sd.connect(hostname, port, "udp"));
}

error_flag
Source::setServerDetails(struct in_addr address, int port)
{
        sd.eventsOn();
        sd.makeNonBlocking();
        return setSocketError(sd.connect(address, htons(port)));
}
//
// Returns the local port number being used by this Source object.  This
// information is required by the Server class for Asset Presentation Request
// messages.
//
// Errors: TCP_SocketError: Unable to bind to local port.
//
//
error_flag
Source::getLocalPort(int *port)
{
        return setSocketError(sd.getLocalPort(port));
}

//
// Gets the number of full blocks pending and the maximum number of bufferable
// blocks as set in the constructor.
//
// Errors: None.
//
//
error_flag
Source::getBlockStatus(size_t *num_blocks, size_t *max_blocks_r, size_t *num_free)
{
        if (num_blocks != 0 || num_free != 0) {
        	size_t n;
        	size_t full_blocks = 0;
        	size_t empty_blocks = 0;
        	
                for (n = 0; n < mem_map->max_blocks; n++) {
                        MemBlock *mb = mem_map->getBlock(n);
                        if (!mb->inuse) empty_blocks++;
                        else if (mb->completed) full_blocks++;
                }
                if (num_blocks != 0) *num_blocks = full_blocks;
                if (num_free != 0) *num_free = empty_blocks;
        }
        
        if (max_blocks_r != 0) {
                *max_blocks_r = mem_map->max_blocks;
        }

        return NoError;
}

// this clears the source and sets the play state to -1 so no more is added to the source
// ie. from this time until state is moved out of stop nothing will be placed into the 
// source data structures.
void
Source::setEndPlayState(void)
{
   	current_play_id = -1;
   	
        for (int i=0;i<mem_map->max_blocks; i++){
        	MemBlock *mb = mem_map->getBlock(i);
        	if ((mb->inuse)&&(!mb->mpeg_owned))
        	   mem_map->freeBlock_background(mb);
        }
        full_blocks = 0; 
}

// this routine dumps all blocks and sets the play state to a new value so the source holds blocks
// for the new play method.

error_flag
Source::setNewPlayState(int *play_state, int *request_num, int *max_complete)
{
  	MemBlock *mb;
	size_t freebuf;
	int i;
	error_flag result = ErrorState();
  	
  	if (current_play_id >= 0xFFFFFF)
  		current_play_id = 0;	// this avoids negative numbers -1 of which is used for end of stream

  	*play_state = ++current_play_id;
  		
        for (i=0;i<mem_map->max_blocks; i++){
        	mb = mem_map->getBlock(i);
        	if ((mb->inuse)&&(!mb->mpeg_owned))
        	   mem_map->freeBlock_background(mb);
        }
        full_blocks = 0;
         
        result = getBlockStatus(0, 0, &freebuf);
     	if (freebuf > NEC_databurstval)
   		freebuf = NEC_databurstval;
   	
  	(*max_complete) = (int)(last_block_sent = max_completed_block);
  	
   	(*request_num) = (int)(max_completed_block + freebuf);
   	
	for (i = (int)max_completed_block+1; i <= (*request_num); i++)
		mem_map->findBlock(i);
  		 	
     return result;
}
//
// Gets a pointer to the next completed complete block.  Changes to the
// data structures associated with the block are locked out until the
// block is freed with a call to the freeBlock method.
//
// Errors: VSP_NoDataAvailable
//
//
error_flag
Source::getBlock(NECBlock **block)
{
        MemBlock *mb;
        error_flag result = ErrorState();
        
        mb = mem_map->findExistingBlock(last_block_sent + 1);
        	
 	if (mb != NULL && mb->inuse && mb->completed) {
        	result = mem_map->memMemBlockToNECBlock(mb, block);
          	(*block)->iov_size = mb->dgrams_in_block;
                ++last_block_sent;
                mb->mpeg_owned = 1;
                //Debug("gb %i", mb->block_id);
	}
        else 
                *block = 0;

     return result;    
}

//
// Releases the specifed block structure.  The data structures associated
// with the block are marked available for re-use.
//
// Errors: VSP_InvalidValue: the block was invalid or did not belong to this
//         Source object.
//
//
error_flag
Source::freeBlock(const NECBlock *block)
{
  MemBlock *mb;
         
  error_flag result = mem_map->memNECBlockToMemBlock(block, &mb);
  if (result != ErrorOccurred){
  	mb->to_be_freed = 1;
  	mb->mpeg_owned = 0;
  }
  return result;
}

error_flag
Source::calculate_freeBlocks(void)
{
    	int i;
  	
 	error_flag result = ErrorState();
      	 
        for (i = 0; ( (i < mem_map->max_blocks)&&(result != ErrorOccurred)); i++) {
                MemBlock *mb = mem_map->getBlock(i);
                if (mb->to_be_freed != 0){
                	result = mem_map->freeBlock_background(mb);
                }
        }
        full_blocks = (int)(max_completed_block - last_block_sent);
        
       return result;
}
//
// Allows the Source object foreground execution time so that it can perform
// operations not permitted in the interrupt method.  Use of private_handle is
// not yet defined.
//
// Errors: None.
//
//
error_flag
Source::foregroundExecute(callback_flag *callback_flags, Server *server)
{
 	error_flag result = ErrorState();
       	int naks = 0;
       
        result = calculateMaxCompleteBlock();

        if (result != ErrorOccurred)
 		result = calculatePosNAKSequence(&naks, server, (int)server->getMaxRequestedBlock());
		
       	full_blocks = (int)(max_completed_block - last_block_sent);

#ifdef DEBUGLIB
        Debug("naks %i, [%i-%i], %i, %i", naks, server->getMaxRequestedBlock(), 
        			max_completed_block, stream_end_block, full_blocks);
        //result = getMiscInfo(0);
#endif
        if (naks == 0)
        	(*callback_flags) = (callback_flag)((*callback_flags) & ~callback_foreground);
        	
        if (result != ErrorOccurred)
        	result = calculatePosAckSequence(server);
       	
       	
    return result;
}

//
// Informs a Source object that a dynamic area has been renumbered.  Each
// object needs to check whether its own dynamic area is the one being
// renumbered and note the change for future reference.
//
// Errors: None.
//
error_flag
Source::serviceDynamicAreaRenumber(int old_id, int new_id)
{
        if (old_id == mem_map->getDaNumber()) {
                mem_map->setDaNumber(new_id);
        }
        return NoError;
}

//
// Gets the underlying socket object being used for UDP datagram reception
// by the Source class.
//
// Errors: None.
//
error_flag
Source::getSocket(Socket *s)
{
        error_flag result;
        if (sd.valid()) {
                *s = sd;		// block copy
                result = NoError;
        }
        else {
          	RemoveErr();		// remove the uninit error
                MakeError(TCP_SocketError);
                result = ErrorOccurred;
        }

        return result;
}

//
// Reads a pending datagram into a free datagram buffer and links it into the
// block's scatter array.
//
// Errors: TCP_ReadFail, VSP_Alloc
//
//
error_flag
Source::ReadDatagrams(callback_flag *flags)
{
        error_flag result = ErrorState();
        
        NECDatagram *dgram;
        int size = 1, num_dgrams = 0;

#ifdef DEBUGLIB        
        if (result == ErrorOccurred)
        	Debug("error occurred in read dgram");
#endif        	
        
        while (( size > 0)&&(result != ErrorOccurred)){
                      
         	result = mem_map->memFindFreeDatagramBuffer(&dgram);
        
         	if ( result != ErrorOccurred) {
                	struct iovec iov[2];
                
                	iov[0].iov_len =  sizeof(NECDatagram);
                	iov[1].iov_len =  (unsigned int)(mem_map->dgram_size - sizeof(NECDatagram)) ;
                
                	iov[0].iov_base = (char*) dgram;
                	iov[1].iov_base = (char*) mem_map->findPayloadBuffer(dgram);  
                                              
                	size = sd.read(iov,sizeof(iov)/sizeof(struct iovec));
                     
                 	if ( size > sizeof(NECDatagram) ){
                  	  	++num_dgrams;
                	  	ntoh_structure(dgram, map_NECDatagram, NECDatagram);
 
         			if ((dgram->playback_classification_id == current_play_id)
         					&&(dgram->block_number > max_completed_block)){
         					  
               				if (dgram->block_number > max_block_received){	// new block
               				  	(*flags) = (callback_flag)((*flags) | callback_foreground);
               	 				max_block_received = dgram->block_number;
                			}                			
               			       					// lookup the datagram's slot within the memblock
                 			MemBlock *mb = mem_map->findBlock(dgram->block_number);
                 			
       					if (mb->nec_block.iov[dgram->dgram_seq].iov_base == NULL) {
       					  
						mb->nec_block.iov[dgram->dgram_seq].iov_base = iov[1].iov_base;
       						mb->nec_block.iov[dgram->dgram_seq].iov_len = (unsigned int) dgram->dgram_size;
       						mb->dgrams_received++;
              	
       						if (dgram->dgram_total != 0){
       	       						mb->dgrams_in_block = (unsigned int) dgram->dgram_total;
       	       						mb->special_play_id = (int) dgram->playback_classification_id;
       	       					}
    							// forward jump in dgrams same block send NAK for the missing
						if ( (dgram->status_word&0x01) ||
							(mb->dgrams_received == mb->dgrams_in_block)&&(mb->dgrams_in_block != 0 ) ){
							mb->completed = 1;	// completed block
							mb->pending_nak = 0;
							mb->dgrams_nakd = 0;
							(*flags) = (callback_flag)((*flags) | callback_foreground);
							result = calculateMaxCompleteBlock();
        						full_blocks = (int)(max_completed_block - last_block_sent);
						}
				        } 
       					else { 	//duplicate datagram != 0
#ifdef DEBUGLIB       					
       						Debug("duplicate dgram");
#endif       						
       					  	result = mem_map->memFreeDatagram(dgram);
       					}
               		        }
               		        else
               		        	result = mem_map->memFreeDatagram(dgram);
	               	}// (size > datagram)
        	       	else {
                	  	if (size > 0) {		// Oh erk - this datagram was way too short
                                        	MakeError(TCP_ReadFail);
                                        	result = ErrorOccurred;
                                	}
                       	  	else
                       	  	if ((size == -1)&&(errno != EWOULDBLOCK)) {
                                        	MakeError(TCP_ReadFail);
                                        	result = ErrorOccurred;
                                	}
                               result = mem_map->memFreeDatagram(dgram);
                        }
                }// no error result
        }// while datagrams
#ifdef DEBUGLIB        
        //Debug("in %i", num_dgrams);
#endif        
        num_dgrams = num_dgrams;
        return result;
}

error_flag
Source::getMiscInfo(int flags)
{
  flags = flags;
  error_flag result = ErrorState();

#ifdef DEBUGLIB
    	if (ErrorExists()){
    	  	Debug("error exists");
    	  	if (err != NULL){
    	  	  	err->Print();
    	  	}
    	}               
	Debug("MiscInfo - max_rec %i, max comp %i, play id %i", max_block_received, max_completed_block, current_play_id);

         for (int i = 0; ( (i < mem_map->max_blocks)&&(result != ErrorOccurred) ); i++) {
               MemBlock *mb = mem_map->getBlock(i);
               Debug("block (%i)(%i)(%i)(%i)[%i] - %i, %i/%i, p_id = %i",
              	 mb->to_be_freed!=0, mb->mpeg_owned!=0, mb->completed!=0, mb->inuse!=0, mb->block_id, mb->pending_nak!=0,  
              	 mb->dgrams_received, mb->dgrams_in_block, mb->special_play_id);
         }
         if (result == ErrorOccurred)
         	Debug("error occurred exit");
#endif               	
  return result;
}
