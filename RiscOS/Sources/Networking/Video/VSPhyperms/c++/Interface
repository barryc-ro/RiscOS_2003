/***********************************************************************
 Interface.c

impliments standard interface class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

***********************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

extern "C" {
#include "VSPHdr.h"
}

#include "Interface.h"
#include "ServCtrl.h"


static _kernel_oserror *setcallevery(int return_time, void *pw)
{
    return _swix(OS_CallEvery, _INR(0,2), return_time, VSP_Poll, pw);
}

//  +++++++++++++++++++++++++++++++++++++ private functions +++++++++++++++++++++++++++++++++++++

error_flag
Interface::ReadEnvVar(void)
{
    error_flag result = ErrorState();
    const char *setting = NULL;
    
    // if at any stage setting == NULL the method will fall through setting default settings
    
    if (result != ErrorOccurred)
    	setting = getenv("VSPhyperms$NecBlocks");
    
    if (setting != NULL) {
       EnvNumBlocks = atoi(setting);
       setting = getenv("VSPhyperms$HealthPeriod");
    }
    else {
       EnvNumBlocks = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL) {
        Envhealthperiod = atoi(setting);
        setting = getenv("VSPhyperms$VideoPort");
        EnvPortString[0] = '\0';
    }
    else {
    	Envhealthperiod = 0;
    	result = ErrorOccurred;
    }
    
    if (setting != NULL) {
         strncat(EnvPortString, setting, sizeof(EnvPortString));
         setting = getenv("VSPhyperms$DefaultServer");
         EnvServerString[0] = '\0';
    }
    else
         result = ErrorOccurred;
    
    if (setting != NULL){
         strncat(EnvServerString, setting, sizeof(EnvServerString));
         setting = getenv("VSPhyperms$BufferBlocks");
    }
    else
    	result = ErrorOccurred;
    
    if (setting != NULL) {
       EnvBufferBlocks = atoi(setting);
       setting = getenv("VSPhyperms$TCPtimeout");
    }
    else {
       EnvBufferBlocks = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL){
       EnvTCPtimeout = atoi(setting);
       setting = getenv("VSPhyperms$INETtimeout");
    }
    else {
       EnvTCPtimeout = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL){
    	EnvINETtimeout = atoi(setting);
        setting = getenv("VSPhyperms$SourceRecvSpace");
    }
    else {
    	EnvINETtimeout = 0;
    	result = ErrorOccurred;
    }
    
    if (setting != NULL){
    	EnvSourceRecvSpace = atoi(setting);
    }
	// -- 
    if (result == ErrorOccurred) {
    	MakeError(VSP_NoReadEnvironment);
    }
    
    
    return result;
}

enum riscos_event_numbers {
        internet_event = 19
};

enum riscos_vector_numbers {
        event_vector = 0x10
};

enum riscos_osbyte_numbers {
        osbyte_disable_event = 13,
        osbyte_enable_event = 14
};

static _kernel_oserror *enableInternetEvent(void *pw)
{
    _kernel_oserror *e;

    e = _swix(OS_Claim, _INR(0,2), event_vector, VSP_InternetEventVeneer, pw);
    if (e == NULL) {
        e = _swix(OS_Byte, _INR(0,1), osbyte_enable_event, internet_event);
    }
    return e;
}

static void disableInternetEvent(void *pw)
{
    (void) _swix(OS_Byte, _INR(0,1), osbyte_disable_event, internet_event);
    (void) _swix(OS_Release, _INR(0,2), event_vector, VSP_InternetEventVeneer, pw);
}

Interface::Interface(void* pword):Error()
{
  _kernel_oserror *ro_error;
  
  for (int i = 0; i < ERROR_ARRAY; i++) errors[i] = NULL;
  errorsOffset = 0;
  	
  pw = pword;
  ReadEnvVar();
  if ( (ro_error = setcallevery(Envhealthperiod, pw)) != NULL ){
  	MakeError(ro_error);
  }
  enableInternetEvent(pw);
  init_block_val = 1;
}

Interface::~Interface(void)
{
  disableInternetEvent(pw);
}

void
Interface::error_array_print(void)
{
  int i, count = 0;
  printf(" history of last %i error messages, most recent first\n", ERROR_ARRAY);
  for (i=(errorsOffset-1); i != errorsOffset; --i){
    if (i < 0) i = ERROR_ARRAY - 1;
    if (errors[i] != NULL){
      	++count;
    	errors[i]->error_print();
    }
  } 	
  printf(" (%i) errors recorded\n", count);
}

ErrorBlk *Interface::AddError(ErrorBlk *new_error)
{
  ErrorBlk *errptr;
   if (errors[errorsOffset] != NULL){
     delete errors[errorsOffset];
     errors[errorsOffset] = NULL;
   }
   
   errptr = errors[errorsOffset] = new_error;
   
   errorsOffset++;
   if (errorsOffset == ERROR_ARRAY) errorsOffset = 0; 	// rotate
   
   return errptr;
}

//  +++++++++++++++++++++++++++++++++++++ SWI interface +++++++++++++++++++++++++++++++++++++

error_flag
Interface::SetServer(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  non_fatal = non_fatal;
  Server *p_ControlStream = NULL;

  if (ErrorExists()) return ErrorOccurred;	// fatal error;

  if (regs->r[0] & 0x01){	// delete server reference in r1
    if (servers.Remove(regs->r[1]) == ErrorOccurred){
    	(*non_fatal) = AddError(&servers.ReturnCopyOfError());
    }
  }
  else {			
    if (regs->r[1] == NULL){// connect to default server
    	if (EnvServerString[0] == NULL) {
    		(*non_fatal) = AddError(new ErrorBlk(TCP_UnknownServer));
    	}
    	else {
    	     if (regs->r[0] & 0x02) {	// port specified
	    	p_ControlStream = new Server(EnvServerString, (char*)regs->r[2], EnvTCPtimeout);
	    	p_ControlStream->set_interface_owner();
	     }
	     else {
	     	p_ControlStream = new Server(EnvServerString, EnvPortString, EnvTCPtimeout);
	    	p_ControlStream->set_interface_owner();
	     }
	}
    }
    else { // R1 specified
    	     if (regs->r[0] & 0x02) {	// port specified
	    	p_ControlStream = new Server((char*)regs->r[1], (char*)regs->r[2], EnvTCPtimeout);
	    	p_ControlStream->set_interface_owner();
	     }
	     else {
	     	p_ControlStream = new Server((char*)regs->r[1], EnvPortString, EnvTCPtimeout);
	    	p_ControlStream->set_interface_owner();
	     }
    }
    // we should have a connection to the server now
    
    if (p_ControlStream == NULL){
	    MakeError(VSP_Alloc);
	    return ErrorOccurred;
    }
    else {
       	if (p_ControlStream->ErrorExists()) {
    		(*non_fatal) = AddError(&p_ControlStream->ReturnCopyOfError());
    		delete p_ControlStream;
    		p_ControlStream = NULL;
	}
	else {
    		if (servers.Add((void*)p_ControlStream, &(regs->r[0])) == ErrorOccurred)
    			(*non_fatal) = AddError(&servers.ReturnCopyOfError());	// return identifier
    	}
    }
  } // delete element
  regs->r[1] = NECServerType;
  return NoError;

}

error_flag
Interface::OpenStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp = NULL;
  Server *p_ControlStream;
  int tmp_server = 0;
  PlayElementRequest play_element;
  PlayList play_list;
  int asset_id, play_count;
  
  if (ErrorExists()) return ErrorOccurred;	// fatal error;
  
  if ((regs->r[0] == 0)||(regs->r[4] == 0)) {
    tmp_server = 1;
    p_ControlStream = new Server(EnvServerString, EnvPortString, EnvTCPtimeout);

    if ((p_ControlStream != NULL)&&(p_ControlStream->ErrorExists())) {
    	(*non_fatal) = AddError(&(p_ControlStream->ReturnCopyOfError()));
    	delete p_ControlStream; p_ControlStream = NULL;
    	tmp_server = 0;
    }
  }
  else {
  	p_ControlStream->set_interface_owner();
  	if (servers.identify((void**)&p_ControlStream, regs->r[4]) == ErrorOccurred) {
    		(*non_fatal) = AddError(&servers.ReturnCopyOfError());
  	}
  }
  
  if (*non_fatal == NULL)
  {
  	if (regs->r[0] == 0x00) { // historic
  		if (isdigit(*(char*)regs->r[1])){// attempt to convert the string to an asset number
 			asset_id = atoi((char*)regs->r[1]);
 			play_element.asset_id = asset_id;
  			play_element.viewing_start_time = 0;
  			play_element.viewing_end_time = 0;
  			play_element.RFU[0] = 0;
  			play_element.RFU[1] = 0;
     			tmp = new Stream(EnvINETtimeout, init_block_val, regs->r[2], &play_element, 1, p_ControlStream,
     			EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw, regs->r[4], regs->r[5]);
                }
                else
                	(*non_fatal) = AddError(new ErrorBlk(VSP_InvalidValue));
        }
        else
        if (regs->r[0] & 0x01) {		// r1 contains an asset number
  		play_element.asset_id = regs->r[1];
  		play_element.viewing_start_time = 0;
  		play_element.viewing_end_time = 0;
  		play_element.RFU[0] = 0;
  		play_element.RFU[1] = 0;
     		tmp = new Stream(EnvINETtimeout, init_block_val, regs->r[2], &play_element, 1, p_ControlStream, 
     								EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw);
  	}
  	else
        if (regs->r[0] & 0x02){			// r1 is a pointer to an array of play elements
          	play_list = (PlayList)regs->r[1];
          	
          	for (play_count = 0; play_list[play_count].asset_id != NULL; play_count++);
          	
    		tmp = new Stream(EnvINETtimeout, init_block_val, regs->r[2], play_list, play_count+1, p_ControlStream, 
    									EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw);
    	}
    	  	
    	if ((tmp != NULL)&&(tmp->ErrorExists())){
    	  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	  	delete tmp;
    	  	tmp = NULL;
    	}
       
   	if ( (tmp != NULL) && (CurrentStreams.Add(tmp, &(regs->r[0]) ) == ErrorOccurred)) {
   	  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
    		delete tmp;
    		tmp = NULL;
    	} // this sets the handle as well.
  }
  if (tmp_server){
    	if (p_ControlStream->stream_uses())
    		p_ControlStream->clear_interface_owner();
    	else
  		delete p_ControlStream;
  }
  return NoError;
}

error_flag
Interface::CloseStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  error_flag result = ErrorState();
/*  
  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  else {	// if we cannot find it why should we worry about deleting it
    */
  if (CurrentStreams.identify(&tmp, regs->r[1]) != ErrorOccurred) {
    
    init_block_val = tmp->getBlockVal() + EnvNumBlocks;
    
    if (tmp->change_state(state_stop) == ErrorOccurred){
      if (tmp->ErrorNum() == VSP_CantDeleteSharedMemory)// the mpeg player still ownes some memory
      		tmp->RemoveErr();			// in this case callbacks are used for ending
      else {	// terminal error
        	err = &tmp->ReturnCopyOfError();
      		result = ErrorOccurred;
      }
    }
    else{ // no error
    	if (CurrentStreams.Remove(regs->r[1]) == ErrorOccurred) {// if ok remove it from the list.
    		(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
    	}
    }
  }
  return result;
}

error_flag
Interface::CheckEndOfStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  error_flag result = ErrorState();

  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred){
    	regs->r[0] = 1;	// it has ended if it is not here
  	//(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  }
  else {
    if (tmp->CheckEOS(&(regs->r[0])) == ErrorOccurred){
    	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
    }
  }
  return ErrorState();
}

error_flag
Interface::SetSpeed(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  error_flag result = ErrorState();

  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  else 
    if (tmp->SetSpeed(regs->r[0], regs->r[2]) == ErrorOccurred){
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
    }
  return ErrorState();
}

error_flag
Interface::SetPosition(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  error_flag result = ErrorState();

  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  else 
    if (tmp->SetPosition(regs->r[0], regs->r[2]) == ErrorOccurred){
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
    }
  return ErrorState();
}

error_flag
Interface::ReadNPT(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  error_flag result = ErrorState();

  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred)
  	//(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  	regs->r[0] = -1;	// as per spec, if we cannot find the stream
  else 
    if (tmp->ReadNPT((unsigned int*)&(regs->r[0])) == ErrorOccurred){
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
    }
  return ErrorState();
}

// new swis NEC

error_flag
Interface::GetAssetList(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Server *tmp = NULL;
  int new_server = 0; 

  if (regs->r[1] == NULL){// connect to default server
    	if (EnvServerString[0] == NULL) {
    		(*non_fatal) = AddError(new ErrorBlk(TCP_UnknownServer));
    	}
    	else{
    	   tmp = new Server(EnvServerString, EnvPortString, EnvTCPtimeout);
    	   tmp->set_interface_owner();
    	   new_server = 1;
    	   if (tmp->ErrorExists()){
    	   	(*non_fatal) = AddError(&(tmp->ReturnCopyOfError()));
    	   	delete tmp;
    	   	new_server = 0;
    	   }
    	}
  }
  else {
  if (servers.identify((void**)&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  }
  
  if ((tmp != NULL)&&((*non_fatal) == NULL)&&(tmp->GetAssetList(regs) == ErrorOccurred)){
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
  }
  
  if ( (new_server == 1)&&(!(tmp->stream_uses())) )
  		delete tmp;
  	
  regs->r[2] = NECServerType;
  
  return ErrorState();
}

error_flag
Interface::GetSceneList(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Server *tmp = NULL;
  int new_server = 0;
  error_flag result = ErrorState();

  if (regs->r[1] == NULL){// connect to default server
    	if (EnvServerString[0] == NULL) {
    		(*non_fatal) = AddError(new ErrorBlk(TCP_UnknownServer));
    	}
    	else{
    	   tmp = new Server(EnvServerString, EnvPortString, EnvTCPtimeout);
    	   tmp->set_interface_owner();
    	   new_server = 1;
    	   if (tmp->ErrorExists()){
    	   	(*non_fatal) = AddError(&(tmp->ReturnCopyOfError()));
    	   	delete tmp;
    	   	new_server = 0;
    	   }
    	}
  }
  else {
  if (servers.identify((void**)&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  }
  
  if ((tmp != NULL)&&((*non_fatal) == NULL)&&(tmp->GetSceneAssetList(regs) == ErrorOccurred)){
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
  }
  
  if ( (new_server == 1)&&(!(tmp->stream_uses())) )
  		delete tmp;
  
  return ErrorState();
}

error_flag 
Interface::GetMiscInfo(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  
  //Source *source;
  //source = new SourceBroadCast("136.170.33.72", EnvSourceRecvSpace);
  //delete source;
  
  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  else {
    if (tmp->GetMiscInfo(&(regs->r[0]), (misc_5_10*)regs->r[2], &(regs->r[3])) == ErrorOccurred) 
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  }
  return NoError;
}
