/***********************************************************************
 Interface.c

impliments standard interface class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

***********************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

extern "C" {
#include "VSPHdr.h"
}

#include "Interface.h"
#include "ServCtrl.h"

static _kernel_oserror *setcallevery(int return_time, void *pw)
{
    return _swix(OS_CallEvery, _INR(0,2), return_time, VSP_Poll, pw);
}

//  +++++++++++++++++++++++++++++++++++++ private functions +++++++++++++++++++++++++++++++++++++

error_flag
Interface::ReadEnvVar(void)
{
    error_flag result = ErrorState();
    
    if ((ErrorExists())&&(ErrorNum() == VSP_NoReadEnvironment)){
      	RemoveErr();
      	result = NoError;
    }
    
        	
    const char *setting = NULL;
    
    // if at any stage setting == NULL the method will fall through setting default settings
    
    if (result != ErrorOccurred)
    	setting = getenv("VSPhyperms$NecBlocks");
    
    if (setting != NULL) {
       EnvNumBlocks = atoi(setting);
       setting = getenv("VSPhyperms$HealthPeriod");
    }
    else {
       EnvNumBlocks = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL) {
        Envhealthperiod = atoi(setting);
        setting = getenv("VSPhyperms$VideoPort");
        EnvPortNum = 0;
    }
    else {
    	Envhealthperiod = 0;
    	result = ErrorOccurred;
    }
    
    if (setting != NULL) {
      	 EnvPortNum = atoi(setting);
         setting = getenv("VSPhyperms$DefaultServer");
         EnvServerString[0] = '\0';
    }
    else
         result = ErrorOccurred;
    
    if (setting != NULL){
         strncat(EnvServerString, setting, sizeof(EnvServerString));
         setting = getenv("VSPhyperms$BufferBlocks");
    }
    else
    	result = ErrorOccurred;
    
    if (setting != NULL) {
       EnvBufferBlocks = atoi(setting);
       setting = getenv("VSPhyperms$TCPtimeout");
    }
    else {
       EnvBufferBlocks = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL){
       EnvTCPtimeout = atoi(setting);
       setting = getenv("VSPhyperms$INETtimeout");
    }
    else {
       EnvTCPtimeout = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL){
    	EnvINETtimeout = atoi(setting);
        setting = getenv("VSPhyperms$SourceRecvSpace");
    }
    else {
    	EnvINETtimeout = 0;
    	result = ErrorOccurred;
    }
    
    if (setting != NULL){
    	EnvSourceRecvSpace = atoi(setting);
    }
    else {
      	 EnvSourceRecvSpace = 0;
      	 result = ErrorOccurred;
    }   
	// -- 
    if (result == ErrorOccurred)
    	result = MakeError(VSP_NoReadEnvironment);
    
    return result;
}

enum riscos_event_numbers {
        internet_event = 19
};

enum riscos_vector_numbers {
        event_vector = 0x10
};

enum riscos_osbyte_numbers {
        osbyte_disable_event = 13,
        osbyte_enable_event = 14
};

static _kernel_oserror *enableInternetEvent(void *pw)
{
    _kernel_oserror *e;

    e = _swix(OS_Claim, _INR(0,2), event_vector, VSP_InternetEventVeneer, pw);
    if (e == NULL) {
        e = _swix(OS_Byte, _INR(0,1), osbyte_enable_event, internet_event);
    }
    return e;
}

static void disableInternetEvent(void *pw)
{
    (void) _swix(OS_Byte, _INR(0,1), osbyte_disable_event, internet_event);
    (void) _swix(OS_Release, _INR(0,2), event_vector, VSP_InternetEventVeneer, pw);
}

Interface::Interface(void* pword):Error()
{
  // set the error array to null
  for (int i = 0; i < ERROR_ARRAY; i++) errors[i] = NULL;
  
  errorsOffset = 0;
  	
  pw = pword;
  
  ReadEnvVar();
   
  MakeErrorOnError(setcallevery(Envhealthperiod, pw));
  
  MakeErrorOnError(enableInternetEvent(pw));
  	
  init_block_val = 1;
}

Interface::~Interface(void)
{
  disableInternetEvent(pw);
  for (int i=0; i < ERROR_ARRAY; ++i){
  	delete errors[errorsOffset];
   	errors[errorsOffset] = NULL;
  }
}

//---- error list methods --
void
Interface::error_array_print(void)
{
  int nxt_mst_recn, count = 0;	// incrementor and a count of the number of errors found

  printf(" history of last %i error messages, most recent first\n", ERROR_ARRAY);

  // point to the last error made.
  nxt_mst_recn = errorsOffset;
  
  do {
    	// if we fall off the beginning of the list jump to the end
    	if (nxt_mst_recn <= 0) 
    		nxt_mst_recn = ERROR_ARRAY - 1;
    	else 
    		--nxt_mst_recn;

    	if (errors[nxt_mst_recn] != NULL){
      		++count;
    		errors[nxt_mst_recn]->error_print();
    	}
  } while (nxt_mst_recn != errorsOffset);
  	
  printf(" (%i) errors recorded\n", count);
}

void
Interface::disconnect_all(void)
{
	CurrentServers.RemoveAll();// this is done first as it will remove unused and remove interface references to the rest.
	CurrentStreams.RemoveAll();
}

ErrorBlk *Interface::AddError(ErrorBlk *new_error)
{
  // assign an error to error offset then increment it
  // if error[erroroffset] has an error it is ERROR_ARRAY errors old
  
  ErrorBlk *errptr;
  
   if (errors[errorsOffset] != NULL){	// if we have an old error
   	delete errors[errorsOffset];
   	errors[errorsOffset] = NULL;
   }
   
   errptr = errors[errorsOffset] = new_error;
   
   ++errorsOffset;
   
   if (errorsOffset == ERROR_ARRAY) errorsOffset = 0; 	// rotate
   
   return errptr;
}

inline error_flag
Interface::strToAddr(char *string, struct in_addr *addr, ErrorBlk **non_fatal)
{
  	// it string is a dotted decimal
	if ( ! inet_aton(string, addr) ) {
	  
  		struct hostent *he;
                // look up the string in the host table
  		he = gethostbyname(string);
  		
                if (he == NULL)
                	(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
                else
                	addr->s_addr = (**he->h_addr_list);
        }
        return NoError;
}
//  +++++++++++++++++++++++++++++++++++++ SWI interface +++++++++++++++++++++++++++++++++++++
// adds a server to the server list
error_flag
Interface::SetServer(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  non_fatal = non_fatal;
  InternetObject *p_ControlStream = NULL;
  ULINT port_number;
  struct in_addr address;
  
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_SetServer){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else {
        // if bit 1 is set then we expect to remove an asset
        
  	if (regs->r[0] & 0x01){	// delete server reference in r1
  		if (CurrentServers.identify((ListObject**)&p_ControlStream, regs->r[1]) == ErrorOccurred)
  			(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
  		else{
#ifdef DEBUGLIB
			if (Debug(debug_servercontrol)) Debug("delete server handle %i stream uses %i", 
								regs->r[1], p_ControlStream->stream_uses()); 
#endif				
  		  	if (p_ControlStream->stream_uses()){	// remove interface reference
  		  	  	p_ControlStream->clear_interface_owner();
  		  	  	if (CurrentServers.RemoveFromList(regs->r[1]) == ErrorOccurred)
  	  				(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
  		  	  	//(*non_fatal) = AddError(new ErrorBlk(VSP_ObjectInUse));
  		  	}
  		  	else {
  				if (CurrentServers.Remove(regs->r[1]) == ErrorOccurred){
  	  				(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
  	  			}
			}	  		
  	  	}
  	}
  	else {
  		if (regs->r[0] & 0x02)	// if port specified
  			port_number = regs->r[2];
  		else
  			port_number = EnvPortNum;
  			
  		if (regs->r[1] == NULL){// connect to default server
    			if (EnvServerString[0] == NULL)
    				(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    			else 
    				strToAddr(EnvServerString, &address, non_fatal);
                }
    		else // R1 specified
    			strToAddr((char*)regs->r[1], &address, non_fatal);
    				
    		// we have an ip address and a port number (or an error)
    		if ((*non_fatal) == NULL){
    		  	// one of three types of server multicast address, TCP (ethernet), TCP (ATM)
    		  	if (IN_MULTICAST(ntohl(address.s_addr)))
    		  	  	p_ControlStream = new InternetObject(&address, port_number);
    		  	else {
    		  	  	if (regs->r[0] & 0x08) // if ATM address specified
    		  	  		p_ControlStream = (InternetObject*)new ATMServer(&address, port_number, (UBYTE*)regs->r[4], 
    		  	  								(bool)(regs->r[0] & 0x10), EnvTCPtimeout);
    		  		else
    		  			p_ControlStream = (InternetObject*)new Server(&address, port_number, EnvTCPtimeout);
    		  	}
    		  	
			// we now have a server or an error, that error can be in the server object	
    		  	if (p_ControlStream != NULL) {
      				if (p_ControlStream->ErrorExists()) {
    					(*non_fatal) = AddError(&p_ControlStream->ReturnCopyOfError());
    					delete p_ControlStream;
    					p_ControlStream = NULL;
	                	}
				else {
				  	int message_flag = (regs->r[0] & 0x04);
    		  	  		// tell the server that it is going on the server list
    		  			p_ControlStream->set_interface_owner();
    		  			
				  	regs->r[0] = INVALID_LIST_ID;
				  	// add it to the list r0 becomes the identifiers
    					if (CurrentServers.Add(p_ControlStream, &(regs->r[0])) == ErrorOccurred)
    						(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());	// return identifier
#ifdef DEBUGLIB
					else
						if (Debug(debug_servercontrol)) Debug("create server handle %i", regs->r[0]);
#endif
    					// if an error identifier is given add a message pipe
					if ((*non_fatal == NULL)&&(message_flag))
	  					p_ControlStream->create_message_pipe(regs->r[3], regs->r[0]);
	  				
	  			}
    	                }
    	                else
    	                	MakeError(VSP_Alloc); // fatal die	
                } // if (non_fatal == Null)
        } // ! delete element
  } // R0 flags
  

  regs->r[1] = NECServerType;
  return ErrorState();
}

error_flag
Interface::OpenStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  InternetObject *server = NULL;
  Stream *stream = NULL;
  
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_OpenStream){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else{
#ifdef DEBUGLIB    
    	if (Debug(debug_streaminfo)) Debug("open stream server %i, r0 %i", regs->r[4], regs->r[0]);
#endif    	
   	if ((regs->r[4] == INVALID_LIST_ID)||(regs->r[0] == 0)){ // if no server specified or Default open stream
    		// use default server or attempt to find multicast address
    	  	struct in_addr address;
    	  	ULINT port = EnvPortNum;
    		if (regs->r[0] == 0){ // assume multicast string in R1.
    		
    		  	char serverString[STRINGLENGTH];
    			char *group_addr = (char*)regs->r[1];
    			int i;
    			
    			for (i=0; i < STRINGLENGTH; ++i){
    		  		if (group_addr[i] == '\0')
    		  			break;
    		  		
    				if (group_addr[i] != ':')
    					serverString[i] = group_addr[i];
    				else{
    				  	serverString[i] = '\0';
    					break;
    				}
    			}
    			
   			if ((inet_aton(serverString, &address))&&(group_addr[i] == ':'))
   				port = atoi(group_addr+i+1);
   			else
   				strToAddr(EnvServerString, &address, non_fatal);
    		}
    		else // use default address
    	  		strToAddr(EnvServerString, &address, non_fatal);
    	  	
    	  	if (*non_fatal == NULL){// if it is multicast else use default.
    	  		if (IN_MULTICAST(ntohl(address.s_addr)))
    		 		server = new InternetObject(&address, port);
    			else
   				server = new Server(&address, EnvPortNum, EnvTCPtimeout);			
    		}
    		
    		if (server == NULL)
    			(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    		else {
    			if (server->ErrorExists()){
    				(*non_fatal) = AddError(&server->ReturnCopyOfError());
    				delete server; server = NULL;
    			}
    		}
    	}// get a server, or an error
    	else {	// derive a server reference from r[4] or the default server, or multicast ip:port from R1.
    		if (CurrentServers.identify((ListObject**)&server, regs->r[4]) == ErrorOccurred)
    		  		(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
    	}
     	
    	if ((*non_fatal) == NULL){
    	  	if (server->stream_uses())
    	  		(*non_fatal) = AddError(new ErrorBlk(VSP_ObjectInUse));
    	  	else {
    	  		if (server->ErrorExists()) // check residual errors in server
    	  			(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
    	  		else {
    	  	  		if (server->InternetObjectType() == server_ip_address) { // if multicast server
    	  	  			 stream = new Stream(EnvINETtimeout, server, regs->r[2], EnvSourceRecvSpace, EnvNumBlocks, EnvBufferBlocks, EnvTCPtimeout, pw);
    	  	  		}
    	  	  		else {
    	  	  	  		Server *control_server = (Server*)server;	   
 	   				switch (regs->r[0]){
	  					default:   // historic R0 = zero
	  						{
	        	            				PlayElementRequest play_element;
	  			    				int asset_id;
	  			    
	  							if (isdigit(*(char*)regs->r[1])){// attempt to convert the string to an asset number
	 								asset_id = atoi((char*)regs->r[1]);
	 								play_element.asset_id = asset_id;
	 								int from = 0;
	 								if (regs->r[5] > regs->r[4]){
	  									play_element.viewing_start_time = regs->r[4]<<1;
	  									play_element.viewing_end_time = regs->r[5]<<1;
	  								}
	  								else{
	  									play_element.viewing_start_time = 0;
	  									play_element.viewing_end_time = 0;
	  									from = regs->r[4]<<1;
	  								}
	  								play_element.RFU[0] = 0;
	  								play_element.RFU[1] = 0;
	  								stream = new Stream(EnvINETtimeout, init_block_val, regs->r[2], &play_element, 1, 
	  									control_server, EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw, from);
  								}
        	        					else
                							(*non_fatal) = AddError(new ErrorBlk(VSP_InvalidValue));
        						}
        	        				break;
		        			case (0x01):	// r1 contains an asset number
        						{
        			        		    PlayElementRequest play_element;
				
  								play_element.asset_id = regs->r[1];
  								play_element.viewing_start_time = 0;
  								play_element.viewing_end_time = 0;
  								play_element.RFU[0] = 0;
  								play_element.RFU[1] = 0;
     								stream = new Stream(EnvINETtimeout, init_block_val, regs->r[2], &play_element, 1, 
     										control_server, EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw);
     							}
     							break;
  						case (0x02):
  							{	// r1 is a pointer to an array of play elements
				    			PlayList play_list = (PlayList)regs->r[1];
  				    			size_t play_count;
        		  	
        		  				for (play_count = 0; play_list[play_count].asset_id != NULL; play_count++);
        		  				
 	   						stream = new Stream(EnvINETtimeout, init_block_val, regs->r[2], play_list, play_count, 
 	   									control_server, EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw);
    							}
    							break;
        				}// switch to create asset
  				}// control stream type
  			
    				if ((stream != NULL)&&(stream->ErrorExists())){
    		  			(*non_fatal) = AddError(&stream->ReturnCopyOfError());
    		  			delete stream;
    			  		stream = NULL;
    				}
        			else
   				if ( (stream != NULL) && (CurrentStreams.Add(stream, &(regs->r[0]) ) == ErrorOccurred)) {
   			  		(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
    				} // this sets the handle as well.
  			}// no error
  		}// if stream uses
  	}// non_fatal != null	
  }
  return ErrorState();
}

error_flag
Interface::CloseStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_CloseStream){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else{
  	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) != ErrorOccurred) {
    		if (tmp->stop_stream((ULONG*)&init_block_val) == ErrorOccurred){
    			if (tmp->ErrorNum() == VSP_CantDeleteSharedMemory)// the mpeg player still ownes some memory
    		  		tmp->RemoveErr();			// in this case callbacks are used for ending
    			else
    			    	(*non_fatal) = &tmp->ReturnCopyOfError();
    		}
    		else // no error
    			if (CurrentStreams.Remove(regs->r[1]) == ErrorOccurred)// if ok remove it from the list.
    				(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  	}
  }
  return ErrorState();
}

error_flag
Interface::CheckEndOfStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_CheckEndOfStream){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else{
	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred){
    		regs->r[0] = 1;// if we cannot find it is closed
    	}
  	else {
    		if (tmp->CheckEOS(&(regs->r[0])) == ErrorOccurred)
    			(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	}
  }
  return ErrorState();
}

error_flag
Interface::SetSpeed(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_SetSpeed){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else{
	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  		(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  	else 
  	  	if (tmp->SetSpeed(regs->r[0], regs->r[2]) == ErrorOccurred)
  			(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  }
  return ErrorState();
}

error_flag
Interface::SetPosition(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_SetPosition){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else{
	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  		(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  	else 
    		if (tmp->SetPosition(regs->r[0], regs->r[2]) == ErrorOccurred)
  			(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  }
  return ErrorState();
}

error_flag
Interface::ReadNPT(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_ReadNPT){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else {
  	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  		regs->r[0] = -1;	// as per spec, if we cannot find the stream
  	else 
    		if (tmp->ReadNPT((ULINT*)&(regs->r[0])) == ErrorOccurred)
  			(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  }
  return ErrorState();
}

// new swis NEC

error_flag
Interface::GetAssetList(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Server *tmp = NULL;
  int new_server = 0;

  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_GetAssetList){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else {
    	if (regs->r[1] == NULL){// connect to default server
    		if (EnvServerString[0] == NULL) {
    			(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    		}
    		else{
  			struct in_addr address;
  			
  			strToAddr(EnvServerString, &address, non_fatal);
  			
  			if ((*non_fatal) == NULL){
  				new_server = 1;
    	   			tmp = new Server(&address, EnvPortNum, EnvTCPtimeout);
    	   			
    	   			if (tmp->ErrorExists()){
    	   				(*non_fatal) = AddError(&(tmp->ReturnCopyOfError()));
    	   				delete tmp;
    	   				new_server = 0;
    	                	}
    	                	else
    	                		tmp->set_interface_owner();
    	                }
    	        }
  	}
  	else {
  		if (CurrentServers.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  			(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
  	}

  	if ((tmp != NULL)&&((*non_fatal) == NULL)){
  	  	if (tmp->stream_uses())
  	  		(*non_fatal) = AddError(new ErrorBlk(VSP_ObjectInUse));
  	  	else {
  	  		if (tmp->GetAssetList(regs) == ErrorOccurred){
  				(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  	  			tmp->RemoveErr();
  	  	        }
  	  	}
  	}
  
  	if ( (new_server == 1)&&(!tmp->stream_uses()) )
  			delete tmp;
  }
  regs->r[2] = NECServerType;
  return ErrorState();
}

error_flag
Interface::GetSceneList(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Server *tmp = NULL;
  int new_server = 0;
  
#ifdef DEBUGLIB
	if (Debug(debug_scenelists))
		Debug("get scenelist serverhandle = %i", regs->r[1]);
#endif

  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_GetSceneList){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else {
	if (regs->r[1] == NULL){// connect to default server
    		if (EnvServerString[0] == NULL) {
    			(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    		}
    		else{
    		  
  			struct in_addr address;
  			
  			strToAddr(EnvServerString, &address, non_fatal);
  			
  			if ((*non_fatal) == NULL){
  				new_server = 1;
  				tmp = new Server(&address, EnvPortNum, EnvTCPtimeout);
    			
    	   			if (tmp->ErrorExists()){
    	   				(*non_fatal) = AddError(&(tmp->ReturnCopyOfError()));
    	   				delete tmp;
    	   				new_server = 0;
    	   			}
    	   			else
    	   				tmp->set_interface_owner();
    	   		}
    	        }
  	}
  	else {
  		if (CurrentServers.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  			(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
  	}
  
  	if ((tmp != NULL)&&((*non_fatal) == NULL)){
  	  	if (tmp->stream_uses())
  	  		(*non_fatal) = AddError(new ErrorBlk(VSP_ObjectInUse));
  	  	else
  	  		if (tmp->GetSceneAssetList(regs) == ErrorOccurred){
  				(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    				tmp->RemoveErr();
    			}
        }
  
  	if ( (new_server == 1)&&(!(tmp->stream_uses())) )
  		delete tmp;
  }
  regs->r[2] = NECServerType;
  return ErrorState();
}

error_flag 
Interface::GetMiscInfo(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
   //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_GetMiscInfo){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else {
    	if (regs->r[0] == 4){
    	  	regs->r[0] = NECServerType;
    	  	regs->r[1] = NULL;
    	}
    	else {
#ifdef DEBUGLIB
		int tempR0 = regs->r[0];
		int tempR3 = regs->r[3];
#endif
  		if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  			(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  		else {
  			if (tmp->GetMiscInfo((ULINT*)&(regs->r[0]), (misc_5_10*)regs->r[2], &(regs->r[3])) == ErrorOccurred) 
  				(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  		}
#ifdef DEBUGLIB
		if ((!ErrorExists())&&(Debug(debug_miscinfo))){
    			if ((tempR0 == 0x00)&&(regs->r[2] != NULL)&&(tempR3 >= sizeof(misc_5_10))){
    				Debug("h_pixels         %i", ((misc_5_10*)(regs->r[2]))->h_pixels);	// 16 bits
      				Debug("v_pixels         %i", ((misc_5_10*)(regs->r[2]))->v_pixels);
      				Debug("play_time        %i", ((misc_5_10*)(regs->r[2]))->play_time);	// 32 bits
      				Debug("status_word      0x%8.8X", ((misc_5_10*)(regs->r[2]))->status_word);
  				Debug("scene_number     %i", ((misc_5_10*)(regs->r[2]))->scene_number);
  				Debug("head_time        %i", ((misc_5_10*)(regs->r[2]))->head_time);
  				Debug("end_time         %i", ((misc_5_10*)(regs->r[2]))->end_time);
  				Debug("encode_time      %i", ((misc_5_10*)(regs->r[2]))->encode_time);
  				Debug("bitrate          %i", ((misc_5_10*)(regs->r[2]))->bitrate);
    			}
    			else {
    				if (tempR0 == 0x01)
    					Debug("query 5.9, functionality %8.8X", regs->r[0]);
    				else {
    					if (tempR0 == 0x02)
    						Debug("query 5.8, state %8.8X", regs->r[0]);
    				}
    			}
        	}
#endif
        }
  }
  return ErrorState();
}
