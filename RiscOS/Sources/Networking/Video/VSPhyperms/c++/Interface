/***********************************************************************
 Interface.c

impliments standard interface class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

***********************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"
#include "VideoCtrl.h"

extern "C" {
#include "VSPHdr.h"
}

#include "Interface.h"
#include "ServCtrl.h"
#include "rtsp_defs.h"
#include "sink.h" // the interface uses the flags defined in the sink object.

static _kernel_oserror *setcallevery(int return_time, void *pw)
{
    return _swix(OS_CallEvery, _INR(0,2), return_time, VSP_Poll, pw);
}

//  +++++++++++++++++++++++++++++++++++++ private functions +++++++++++++++++++++++++++++++++++++

error_flag
Interface::ReadEnvVar(void)
{
    error_flag result = ErrorState();

    if ((ErrorExists())&&(ErrorNum() == VSP_NoReadEnvironment)){
          RemoveErr();
          result = NoError;
    }

    const char *setting = NULL;

    // if at any stage setting == NULL the method will fall through setting default settings

    if (result != ErrorOccurred)
        setting = getenv("VSPhyperms$NecBlocks");

    // 08/11/1999 AR because of the difference in multicast block size
    if (setting != NULL) {
       EnvNumBlocks = atoi(setting);
       setting = getenv("VSPhyperms$MulticastBlocks");
    }
    else {
       EnvNumCastBlocks = 0;
       result = ErrorOccurred;
    }

    if (setting != NULL) {
       EnvNumCastBlocks = atoi(setting);
       setting = getenv("VSPhyperms$HealthPeriod");
    }
    else {
       EnvNumBlocks = 0;
       result = ErrorOccurred;
    }

    if (setting != NULL) {
        Envhealthperiod = atoi(setting);
        setting = getenv("VSPhyperms$VideoPort");
        EnvPortNum = 0;
    }
    else {
        Envhealthperiod = 0;
        result = ErrorOccurred;
    }

    if (setting != NULL) {
           EnvPortNum = atoi(setting);
         setting = getenv("VSPhyperms$DefaultServer");
         EnvServerString[0] = '\0';
    }
    else
         result = ErrorOccurred;

    if (setting != NULL){
         strncat(EnvServerString, setting, sizeof(EnvServerString));
         setting = getenv("VSPhyperms$BufferBlocks");
    }
    else
        result = ErrorOccurred;

    if (setting != NULL) {
       EnvBufferBlocks = atoi(setting);
       setting = getenv("VSPhyperms$TCPtimeout");
    }
    else {
       EnvBufferBlocks = 0;
       result = ErrorOccurred;
    }

    if (setting != NULL){
       EnvTCPtimeout = atoi(setting);
       setting = getenv("VSPhyperms$INETtimeout");
    }
    else {
       EnvTCPtimeout = 0;
       result = ErrorOccurred;
    }

    if (setting != NULL){
        EnvINETtimeout = atoi(setting);
        setting = getenv("VSPhyperms$SourceRecvSpace");
    }
    else {
        EnvINETtimeout = 0;
        result = ErrorOccurred;
    }

    if (setting != NULL){
        EnvSourceRecvSpace = atoi(setting);
        setting = getenv("VSPhyperms$FlagsWord");
    }
    else {
           EnvSourceRecvSpace = 0;
           result = ErrorOccurred;
    }

    if (setting != NULL){
        EnvFlagsWord = (flags_word)( atoi(setting) & flags_interface_set );
    }
    else
        EnvFlagsWord = flags_standard_op;

#ifdef DEBUGLIB
    setting = getenv("VSPhyperms$DiagnosticWord");

    if (setting != NULL){
          DebugClear();
          DebugAdd((debug_flags)atoi(setting));
    }
#endif

    // --
    if (result == ErrorOccurred)
        result = MakeError(VSP_NoReadEnvironment);

    return result;
}

enum riscos_event_numbers {
    internet_event = 19
};

enum riscos_vector_numbers {
    event_vector = 0x10
};

enum riscos_osbyte_numbers {
    osbyte_disable_event = 13,
    osbyte_enable_event = 14
};

static _kernel_oserror *enableInternetEvent(void *pw)
{
    _kernel_oserror *e;

    e = _swix(OS_Claim, _INR(0,2), event_vector, VSP_InternetEventVeneer, pw);
    if (e == NULL) {
        e = _swix(OS_Byte, _INR(0,1), osbyte_enable_event, internet_event);
    }
    return e;
}

static void disableInternetEvent(void *pw)
{
    (void) _swix(OS_Byte, _INR(0,1), osbyte_disable_event, internet_event);
    (void) _swix(OS_Release, _INR(0,2), event_vector, VSP_InternetEventVeneer, pw);
}

Interface::Interface(void* pword):Error()
{
    // set the error array to null
    for (int i = 0; i < ERROR_ARRAY; i++) errors[i] = NULL;

    errorsOffset = 0;

    pw = pword;

    ReadEnvVar();

    if (!ErrorExists())
        RTSP_Register();

    MakeErrorOnError(setcallevery(Envhealthperiod, pw));

    MakeErrorOnError(enableInternetEvent(pw));

    init_block_val = 1;
}

Interface::~Interface(void)
{
    RTSP_Deregister();

    disableInternetEvent(pw);
    for (int i=0; i < ERROR_ARRAY; ++i){
        delete errors[errorsOffset];
        errors[errorsOffset] = NULL;
    }

#ifdef DEBUGLIB
    malloc_check();
#endif
}

//---- error list methods --
void
Interface::error_array_print(void)
{
    int nxt_mst_recn, count = 0;    // incrementor and a count of the number of errors found

    printf(" history of last %i error messages, most recent first\n", ERROR_ARRAY);

    // point to the last error made.
    nxt_mst_recn = errorsOffset;

    do {
        // if we fall off the beginning of the list jump to the end
        if (nxt_mst_recn <= 0)
            nxt_mst_recn = ERROR_ARRAY - 1;
        else
            --nxt_mst_recn;

        if (errors[nxt_mst_recn] != NULL){
              ++count;
            errors[nxt_mst_recn]->error_print();
        }
    } while (nxt_mst_recn != errorsOffset);

    printf(" (%i) errors recorded\n", count);
}

void
Interface::disconnect_all(void)
{
    CurrentServers.RemoveAll();// this is done first as it will remove unused and remove interface references to the rest.
    CurrentStreams.RemoveAll();// this will then delete them, this will delete regardless of whom ownes the stream.
}

ErrorBlk *Interface::AddError(ErrorBlk *new_error)
{
    // assign an error to error offset then increment it
    // if error[erroroffset] has an error it is ERROR_ARRAY errors old

    ErrorBlk *errptr = NULL;

    if (new_error)
    {
        if (errors[errorsOffset] != NULL)    // if we have an old error
        {
            delete errors[errorsOffset];
            errors[errorsOffset] = NULL;
        }

        errptr = errors[errorsOffset] = new_error;

        ++errorsOffset;

        if (errorsOffset == ERROR_ARRAY) errorsOffset = 0;     // rotate
    }
    return errptr;
}

error_flag
Interface::RTSP_Register()
{
    _kernel_oserror* err = NULL;

#ifdef DEBUGLIB
    if (Debug(debug_RTSP))
        {
          Debug("register with video control\n");
        }
#endif

    int register_flags =    VC_ProtocolRegister_IDoReducedRateSlowmoForward |\
                    VC_ProtocolRegister_DoNotResetOrSetSpeed |\
                    VC_ProtocolRegister_DoNotCallUDPV|\
                    VC_ProtocolRegister_OpenStreamFlagsInR5;

    int ctrlflags =     //MPEGCtrl_MCOS_AudioToStreamSyncOn |
                        MPEGCtrl_MCOS_ReservedSetToOne    |
                        //MPEGCtrl_MCOS_EnableOVSTrickPlay  |
                        MPEGCtrl_MCOS_AutoReset;

    err = _swix(VideoControl_ProtocolRegister, _INR(0,5), register_flags, VSP_Protocol_Setup,
                                                   "rtsp:", Module_VersionNumber,
                                                   "NEC HyperMS, Generic RTSP", ctrlflags);

    if (err)
    {
        AddError(new ErrorBlk(err));
    }

    return ErrorState();
}

error_flag
Interface::RTSP_Deregister()
{
    _kernel_oserror* err = NULL;

#ifdef DEBUGLIB
    if (Debug(debug_RTSP))
        {
          Debug("de-register with video control\n");
        }
#endif

    err = _swix(VideoControl_ProtocolDeregister, _INR(0,1), 0, VSP_Protocol_Setup);

    if (err)
    {
        AddError(new ErrorBlk(err));
    }

    return ErrorState();
}

//  +++++++++++++++++++++++++++++++++++++ SWI interface +++++++++++++++++++++++++++++++++++++
// adds a server to the server list
error_flag
Interface::SetServer(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    non_fatal = non_fatal;
    InternetObject *p_ControlStream = NULL;
    ULINT port_number;
    struct in_addr address;

    //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created

    if (regs->r[0] & ~R0_MASK_SetServer)
    {
        (*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    }// this ensures that no expected functionality is requested
    else
    {
        // if bit 1 is set then we expect to remove an asset
        if (regs->r[0] & 0x01)   // delete server reference in r1
        {
            if (CurrentServers.identify((ListObject**)&p_ControlStream, regs->r[1]) == ErrorOccurred)
            {
                (*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
            }
            else
            {
#ifdef DEBUGLIB
                if (Debug(debug_servercontrol)) Debug("delete server handle %i stream uses %i",
                                regs->r[1], p_ControlStream->stream_uses());
#endif
                if (p_ControlStream->stream_uses())   // remove interface reference
                {
                    p_ControlStream->clear_interface_owner();
                    if (CurrentServers.RemoveFromList(regs->r[1]) == ErrorOccurred)
                        (*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
                }
                else
                {
                    if (CurrentServers.Remove(regs->r[1]) == ErrorOccurred)
                    {
                        (*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
                    }
                }
            }
        }
        else
        {
            if (regs->r[0] & 0x02)    // if port specified
                port_number = regs->r[2];
            else
                port_number = EnvPortNum;

            if (regs->r[1] == NULL)  // connect to default server
            {
                if (EnvServerString[0] == NULL)
                    (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
                else
                {
                    if (false == parse_server_address(EnvServerString, &address))
                    {
                        (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
                    }
                }
            }
            else // R1 specified
            {
                if (false == parse_server_address((char*)regs->r[1], &address))
                {
                    (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
                }
            }

            // we have an ip address and a port number (or an error)
            if ((*non_fatal) == NULL)
            {
                // one of three types of server multicast address, TCP (ethernet), TCP (ATM)
                if (IN_MULTICAST(ntohl(address.s_addr)))
                {
                    p_ControlStream = new InternetObject(&address, port_number);
                }
                else
                {
                    if (regs->r[0] & 0x08) // if ATM address specified
                        p_ControlStream = (InternetObject*)new ATMServer(&address, port_number, (UBYTE*)regs->r[4],
                                                    (bool)(regs->r[0] & 0x10), EnvTCPtimeout, pw);
                    else
                        p_ControlStream = (InternetObject*)new Server(&address, port_number, EnvTCPtimeout);
                }

                // we now have a server or an error, that error can be in the server object
                if (p_ControlStream != NULL)
                {
                    if ((p_ControlStream->ErrorExists())&&(p_ControlStream->ErrorNum() != IP_WaitConnection))
                    {
                        (*non_fatal) = AddError(&p_ControlStream->ReturnCopyOfError());
                        delete p_ControlStream;
                        p_ControlStream = NULL;
                    }
                    else
                    {
                        int message_flag = (regs->r[0] & 0x04);
                        // tell the server that it is going on the server list
                        p_ControlStream->set_interface_owner();

                        regs->r[0] = INVALID_LIST_ID;
                        // add it to the list r0 becomes the identifiers
                        if (CurrentServers.Add(p_ControlStream, &(regs->r[0])) == ErrorOccurred)
                        {
                            (*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());    // return identifier
                        }
#ifdef DEBUGLIB
                        else
                        {
                            if (Debug(debug_servercontrol)) Debug("create server handle %i", regs->r[0]);
                        }
#endif
                        // if an error identifier is given add a message pipe
                        if ((*non_fatal == NULL)&&(message_flag))
                            p_ControlStream->create_message_pipe(regs->r[3], regs->r[0]);
                    }
                }
                else
                {
                    MakeError(VSP_Alloc); // fatal die
                }
            } // if (non_fatal == Null)
        } // ! delete element
    } // R0 flags
    regs->r[1] = NECServerType;
    return ErrorState();
}

error_flag
Interface::OpenStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    InternetObject *server = NULL;
    Stream *stream = NULL;

    //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
    if (regs->r[0] > R0_Reason_OpenStream)
    {
        (*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    }// this ensures that no expected functionality is requested
    else
    {
#ifdef DEBUGLIB
        if (Debug(debug_streaminfo)) Debug("open stream server %i, r0 %i", regs->r[4], regs->r[0]);
#endif
        if ((regs->r[4] == INVALID_LIST_ID)||(regs->r[0] == 0)) // if no server specified or Default open stream
        {
            // use default server or attempt to find multicast address
            struct in_addr address;
            ULINT port = EnvPortNum;

            if (regs->r[0] == 0) // assume multicast string in R1.
            {
                char serverString[STRINGLENGTH];
                char *group_addr = (char*)regs->r[1];
                int i;

                for (i=0; i < STRINGLENGTH; ++i)
                {
                    if (group_addr[i] == '\0')
                        break;

                    if (group_addr[i] != ':')
                    {
                        serverString[i] = group_addr[i];
                    }
                    else
                    {
                          serverString[i] = '\0';
                        break;
                    }
                }

                if ((inet_aton(serverString, &address))&&(group_addr[i] == ':'))
                    port = atoi(group_addr+i+1);
                else
                {
                    if (false == parse_server_address(EnvServerString, &address))
                    {
                        (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
                    }
                }
            }
            else // use default address
            {
                if (false == parse_server_address(EnvServerString, &address))
                {
                    (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
                }
            }

            if (*non_fatal == NULL) // if it is multicast else use default.
            {
                if (IN_MULTICAST(ntohl(address.s_addr)))
                    server = new InternetObject(&address, port);
                else
                    server = new Server(&address, EnvPortNum, EnvTCPtimeout);
            }

            if (server == NULL)
            {
                (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
            }
            else
            {
                if (server->ErrorExists())
                {
                    (*non_fatal) = AddError(&server->ReturnCopyOfError());
                    delete server; server = NULL;
                }
            }
        }// get a server, or an error
        else    // derive a server reference from r[4] or the default server, or multicast ip:port from R1.
        {
            if (CurrentServers.identify((ListObject**)&server, regs->r[4]) == ErrorOccurred)
                (*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
        }

        if ((*non_fatal) == NULL)
        {
            if (server->stream_uses())
            {
                (*non_fatal) = AddError(new ErrorBlk(VSP_ObjectInUse));
            }
            else
            {
                if (server->ErrorExists()) // check residual errors in server
                {
                    (*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
                }
                else
                {
                    if (server->InternetObjectType() == server_ip_address) // if multicast server
                    {
                        stream = new Stream(EnvINETtimeout, server, regs->r[2], EnvSourceRecvSpace,
                                                            EnvNumCastBlocks, EnvBufferBlocks, EnvTCPtimeout, pw);
                    }
                    else
                    {
                        Server *control_server = (Server*)server;
                        switch (regs->r[0])
                        {
                            default:   // historic R0 = zero
                            {
                                PlayElementRequest play_element;
                                int asset_id;

                                if (isdigit(*(char*)regs->r[1]))// attempt to convert the string to an asset number
                                {
                                    asset_id = atoi((char*)regs->r[1]);
                                    play_element.asset_id = asset_id;
                                    int from = 0;
                                    if (regs->r[5] > regs->r[4])
                                    {
                                        play_element.viewing_start_time = regs->r[4]<<1;
                                        play_element.viewing_end_time = regs->r[5]<<1;
                                    }
                                    else
                                    {
                                        play_element.viewing_start_time = 0;
                                        play_element.viewing_end_time = 0;
                                        from = regs->r[4]<<1;
                                    }
                                    play_element.RFU[0] = 0;
                                    play_element.RFU[1] = 0;
                                    stream = new Stream(EnvINETtimeout, init_block_val, regs->r[2], &play_element, 1,
                                          control_server, EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw, EnvFlagsWord, from);
                                }
                                else
                                {
                                    (*non_fatal) = AddError(new ErrorBlk(VSP_InvalidValue));
                                }
                            }
                            break;
                            case (0x01):    // r1 contains an asset number
                            {
                                PlayElementRequest play_element;

                                play_element.asset_id = regs->r[1];
                                play_element.viewing_start_time = 0;
                                play_element.viewing_end_time = 0;
                                play_element.RFU[0] = 0;
                                play_element.RFU[1] = 0;

                                stream = new Stream(EnvINETtimeout, init_block_val, regs->r[2], &play_element, 1,
                                             control_server, EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw, EnvFlagsWord);
                            }
                            break;
                            case (0x02):
                            {    // r1 is a pointer to an array of play elements
                                PlayList play_list = (PlayList)regs->r[1];
                                size_t play_count;

                                for (play_count = 0; play_list[play_count].asset_id != NULL; play_count++);

                                stream = new Stream(EnvINETtimeout, init_block_val, regs->r[2], play_list, play_count,
                                            control_server, EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw, EnvFlagsWord);
                            }
                            break;
                        }// switch to create asset
                    }// control stream type

                    if ((stream != NULL)&&(stream->ErrorExists()))
                    {
                        (*non_fatal) = AddError(&stream->ReturnCopyOfError());
                        delete stream;
                        stream = NULL;
                    }
                    else
                    {
                        if ( (stream != NULL) && (CurrentStreams.Add(stream, &(regs->r[0]) ) == ErrorOccurred))
                        {
                            (*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
                        } // this sets the handle as well.
                    }
                }// no error
            }// if stream uses
        }// non_fatal != null
    }
    return ErrorState();
}

error_flag
Interface::CloseStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Stream *tmp;
    //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
    if (regs->r[0] & ~R0_MASK_CloseStream)
    {
        (*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    }// this ensures that no expected functionality is requested
    else
    {
        if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) != ErrorOccurred)
        {
            if ((tmp->ErrorExists())&&(tmp->ErrorNum() != VSP_CantDeleteSharedMemory))
                (*non_fatal) = AddError(&tmp->ReturnCopyOfError()); // add the error to the log

            if (tmp->stop_stream((ULONG*)&init_block_val) == ErrorOccurred)
            {
                if (tmp->ErrorNum() == VSP_CantDeleteSharedMemory)// the mpeg player still ownes some memory
                    tmp->RemoveErr();            // in this case callbacks are used for ending
                else
                    (*non_fatal) = &tmp->ReturnCopyOfError();
            }
            else // no error
            {
                if (CurrentStreams.Remove(regs->r[1]) == ErrorOccurred)// if ok remove it from the list.
                    (*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
            }
        }
    }
    return ErrorState();
}

error_flag
Interface::CheckEndOfStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Stream *tmp;

    //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created

    if (regs->r[0] & ~R0_MASK_CheckEndOfStream)
    {
        (*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    }// this ensures that no expected functionality is requested
    else
    {
        if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
        {
            regs->r[0] = 1;// if we cannot find it is closed
        }
        else
        {
            if (tmp->CheckEOS(&(regs->r[0])) == ErrorOccurred)
                (*non_fatal) = AddError(&tmp->ReturnCopyOfError());
        }
    }
    return ErrorState();
}

error_flag
Interface::SetSpeed(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Stream *tmp;

    //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
    if (regs->r[0] > R0_Reason_SetSpeed)
    {
        (*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    }// this ensures that no expected functionality is requested
    else
    {
        if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
            (*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
        else
            if (tmp->SetSpeed(regs->r[0], regs->r[2]) == ErrorOccurred)
                (*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    }
    return ErrorState();
}

error_flag
Interface::SetPosition(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Stream *tmp;

    //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
    if (regs->r[0] > R0_Reason_SetPosition)
    {
        (*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    }// this ensures that no expected functionality is requested
    else
    {
        if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
            (*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
        else
            if (tmp->SetPosition(regs->r[0], regs->r[2]) == ErrorOccurred)
                (*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    }
    return ErrorState();
}

error_flag
Interface::ReadNPT(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Stream *tmp;

    //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
    if (regs->r[0] & ~R0_MASK_ReadNPT)
    {
        (*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    }// this ensures that no expected functionality is requested
    else
    {
        if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
            regs->r[0] = -1;    // as per spec, if we cannot find the stream
        else
            if (tmp->ReadNPT((ULINT*)&(regs->r[0])) == ErrorOccurred)
                (*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    }
    return ErrorState();
}

// new swis NEC

error_flag
Interface::GetAssetList(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Server *tmp = NULL;
    int new_server = 0;

    //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
    if (regs->r[0] & ~R0_MASK_GetAssetList)
    {
        (*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    }// this ensures that no expected functionality is requested
    else
    {
        if (regs->r[1] == NULL)// connect to default server
        {
            if (EnvServerString[0] == NULL)
            {
                (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
            }
            else
            {
                struct in_addr address;

                if (false == parse_server_address(EnvServerString, &address))
                {
                    (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
                }

                if ((*non_fatal) == NULL)
                {
                    new_server = 1;
                    tmp = new Server(&address, EnvPortNum, EnvTCPtimeout);

                    if ((tmp != NULL)&&(tmp->ErrorExists()))
                    {
                        (*non_fatal) = AddError(&(tmp->ReturnCopyOfError()));
                        delete tmp; tmp = NULL;
                        new_server = 0;
                    }
                    else
                    {
                        tmp->set_interface_owner();
                    }
                }
            }
        }
        else
        {
            if (CurrentServers.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
                (*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
        }

        if ((tmp != NULL)&&((*non_fatal) == NULL))
        {
            if (tmp->stream_uses())
            {
                (*non_fatal) = AddError(new ErrorBlk(VSP_ObjectInUse));
            }
            else
            {
                if (tmp->GetAssetList(regs) == ErrorOccurred)
                {
                    (*non_fatal) = AddError(&tmp->ReturnCopyOfError());
                    tmp->RemoveErr();
                }
            }
        }

        if ( (new_server == 1)&&(!tmp->stream_uses()) )
        {
            delete tmp;
            tmp = NULL;
        }
    }
    regs->r[2] = NECServerType;
    return ErrorState();
}

error_flag
Interface::GetSceneList(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Server *tmp = NULL;
    int new_server = 0;

    //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
    if (regs->r[0] & ~R0_MASK_GetSceneList)
    {
        (*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    }// this ensures that no expected functionality is requested
    else
    {
        if (regs->r[1] == NULL) // connect to default server
        {
            if (EnvServerString[0] == NULL)
            {
                (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
            }
            else
            {
                struct in_addr address;

                if (false == parse_server_address(EnvServerString, &address))
                {
                    (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
                }

                if ((*non_fatal) == NULL)
                {
                    new_server = 1;
                    tmp = new Server(&address, EnvPortNum, EnvTCPtimeout);

                    if (tmp->ErrorExists())
                    {
                        (*non_fatal) = AddError(&(tmp->ReturnCopyOfError()));
                        delete tmp; tmp = NULL;
                        new_server = 0;
                    }
                    else
                    {
                        tmp->set_interface_owner();
                    }
                }
            }
        }
        else
        {
            if (CurrentServers.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
                (*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
        }

        if ((tmp != NULL)&&((*non_fatal) == NULL))
        {
            if (tmp->stream_uses())
            {
                (*non_fatal) = AddError(new ErrorBlk(VSP_ObjectInUse));
            }
            else
            {
                if (tmp->GetSceneAssetList(regs) == ErrorOccurred)
                {
                  (*non_fatal) = AddError(&tmp->ReturnCopyOfError());
                    tmp->RemoveErr();
                }
            }
        }

        if ( (new_server == 1)&&(!(tmp->stream_uses())) )
        {
            delete tmp;
            tmp = NULL;
        }
    }
    regs->r[2] = NECServerType;
    return ErrorState();
}

error_flag
Interface::GetMiscInfo(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Stream *tmp;
     //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
    if (regs->r[0] > R0_Reason_GetMiscInfo)
    {
        (*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    }// this ensures that no expected functionality is requested
    else
    {
        if (regs->r[0] == 4)
        {
            regs->r[0] = NECServerType;
            regs->r[1] = NULL;
        }
        else
        {
#ifdef DEBUGLIB
            int tempR0 = regs->r[0];
            int tempR3 = regs->r[3];
#endif
            if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
            {
              (*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
            }
            else
            {
                if (tmp->GetMiscInfo((ULINT*)&(regs->r[0]), (misc_5_10*)regs->r[2], &(regs->r[3])) == ErrorOccurred)
                    (*non_fatal) = AddError(&tmp->ReturnCopyOfError());
            }
#ifdef DEBUGLIB
            if ((!ErrorExists())&&(Debug(debug_miscinfo)))
            {
                if ((tempR0 == 0x00)&&(regs->r[2] != NULL)&&(tempR3 >= sizeof(misc_5_10)))
                {
                    Debug("h_pixels         %i", ((misc_5_10*)(regs->r[2]))->h_pixels);    // 16 bits
                    Debug("v_pixels         %i", ((misc_5_10*)(regs->r[2]))->v_pixels);
                    Debug("play_time        %i", ((misc_5_10*)(regs->r[2]))->play_time);    // 32 bits
                    Debug("status_word      0x%8.8X", ((misc_5_10*)(regs->r[2]))->status_word);
                    Debug("scene_number     %i", ((misc_5_10*)(regs->r[2]))->scene_number);
                    Debug("head_time        %i", ((misc_5_10*)(regs->r[2]))->head_time);
                    Debug("end_time         %i", ((misc_5_10*)(regs->r[2]))->end_time);
                    Debug("encode_time      %i", ((misc_5_10*)(regs->r[2]))->encode_time);
                    Debug("bitrate          %i", ((misc_5_10*)(regs->r[2]))->bitrate);
                }
                else
                {
                    if (tempR0 == 0x01)
                    {
                        Debug("query 5.9, functionality %8.8X", regs->r[0]);
                    }
                    else
                    {
                        if (tempR0 == 0x02)
                            Debug("query 5.8, state %8.8X", regs->r[0]);
                    }
                }
            }
#endif
        }
    }
    return ErrorState();
}

/**************************************************************** video control interface ******************/
error_flag
Interface::Protocol_Setup(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    PlayElementRequest *play_elements = NULL;
    Server *server = NULL;
    const char* sub_query;
    struct in_addr address;
    int port, assets;
    _kernel_oserror* err = NULL;

    err = parse_URL_server((char*)regs->r[2], &sub_query, &address, &port, &play_elements, &assets);

    if (!err)
    {
        if (port == 0) port = EnvPortNum;

        if ((0 == address.s_addr)&&(false == parse_server_address(EnvServerString, &address)))
        {
            (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
        }
        else
        {
            server = new Server(&address, port, EnvTCPtimeout);
        }
    }

    if (err)
    {
        (*non_fatal) = AddError(new ErrorBlk(err));
    }
    else
    {
        if (server == NULL)
        {
            if (NULL == (*non_fatal))
            {
                (*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
            }
        }
        else
        {
            if (server->ErrorExists())
            {
                (*non_fatal) = AddError(&server->ReturnCopyOfError());
                delete server; server = NULL;
            }
            else
            {
                Stream *stream = NULL;

                if (assets <= 0)
                {
                    if (!(*non_fatal))
                    {
                        (*non_fatal) = AddError(new ErrorBlk(VSP_InvalidValue));
                    }
                }
                else
                {
                    stream = new Stream(EnvINETtimeout, init_block_val, 0, play_elements, assets,
                                            server, EnvNumBlocks, EnvSourceRecvSpace,
                                            EnvBufferBlocks, pw, EnvFlagsWord);
                    if (stream)
                    {
                        if (stream->ErrorExists())
                        {
                            (*non_fatal) = AddError(&stream->ReturnCopyOfError());
                            delete stream; stream = NULL;
                        }
                        else
                        {
                            stream->setRTSPClientId(regs->r[1]);
                            if (CurrentStreams.Add(stream, &(regs->r[1]) ) == ErrorOccurred)
                            {
                                (*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
                            } // this sets the handle as well.
#ifdef DEBUGLIB
                            if (Debug(debug_RTSP))
                            {
                                Debug("loaded id = (%i)\n", regs->r[1]);
                            }
#endif
                        }
                    }
                }
            }
        }
    }
    if (play_elements)
    {
        my_free(play_elements);
        play_elements = NULL;
    }
    return ErrorState();
}
/*************************/
error_flag
Interface::Protocol_Options(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Stream *tmp;
    bool setting = (regs->r[0] & 0x01) ? false : true;

    if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
    {
        (*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
    }
    else
    {
        int i = 0;
        int* params = (int*)regs->r[2];
        

        while (params[i] != -1)
        {
#ifdef DEBUGLIB
            if (Debug(debug_RTSP))
                Debug("setting [r0(%i)] param(%i)\n", regs->r[0], params[i]);
#endif 
            if (params[i] == 18) /* normal play time */
            {
               if (tmp->ReadNPT((ULINT*)&params[i+2]) == ErrorOccurred)
                   (*non_fatal) = AddError(&tmp->ReturnCopyOfError());
            }
            else
            if (params[i] == 19)
            {
               bool looping = (0 != params[i+2])?true:false;
#ifdef DEBUGLIB
               if (Debug(debug_RTSP))
                   Debug("setting [if (%i)] looping to (%i)\n", setting, looping);
#endif
               if (setting)
               {
                   tmp->set_looping(looping);
               }
               else
               {
                   looping = tmp->get_looping();
                   params[i+2] = ((true == looping) ? 1 :0);
               }
            }
            i += (params[i+1] + 2);
        }
    }
    return ErrorState();
}
/*************************/
error_flag
Interface::Protocol_Status(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Stream *tmp;
#ifdef DEBUGLIB
    if (Debug(debug_RTSP))
    {
        Debug("get Status for id = (%i)\n", regs->r[1]);
    }
#endif
    if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
    {
        (*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
    }
    else
    if (tmp->RTSP_getStatus((ULINT*)&(regs->r[0]), (ULINT*)&(regs->r[2])) == ErrorOccurred)
        (*non_fatal) = AddError(&tmp->ReturnCopyOfError());

    return ErrorState();
}
/*************************/
error_flag
Interface::Protocol_MoreInformation(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Stream *tmp;
    if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
    {
        (*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
    }
    else
    {
        regs->r[0] = regs->r[4];
#ifdef DEBUGLIB
        if (Debug(debug_RTSP))
        {
            Debug("get moreInfo for id = (%i),reason (%i) buffer (%8.8X) size (%i) \n", regs->r[1], regs->r[2], regs->r[3], regs->r[4]);
        }
#endif

        if (tmp->RTSP_getMoreInfo(regs->r[2], (char*)regs->r[3], &(regs->r[0]), &regs->r[1]) == ErrorOccurred)
        {
            (*non_fatal) = AddError(&tmp->ReturnCopyOfError());
        }
    }
    return ErrorState();
}
/*************************/
error_flag
Interface::Protocol_Play(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
    Stream *tmp;

    if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
    {
        regs->r[0] = -1;    // as per spec, if we cannot find the stream
    }
    else
    {
        if (tmp->RTSP_requestinprogress() == true)
        {
            (*non_fatal) = AddError(new ErrorBlk(VSP_ObjectInUse));
        }
        else
        {
            _kernel_oserror *err = NULL;
            position_type from, to;
            bool forward;
            ULINT numerator, denominator;

            if (!parse_position((char*)regs->r[2], NULL, &from, &to))
            {
                from.numer = TIME_undef;
                from.denom = 0;

                to.numer = TIME_undef;
                to.denom = 0;
            }

            if (!parse_speed((char*)regs->r[3], NULL, &forward, (int*)&numerator, (int*)&denominator))
            {
                forward = true;
                numerator = 1;
                denominator = 1;
            }
#ifdef DEBUGLIB
            if (Debug(debug_RTSP))
            {
                Debug("speed [forward (%s), %i/%i]\n", (forward)?"TRUE":"FALSE", numerator, denominator);
                Debug("position\n");
                if (from.denom ==0)
                    Debug(" from (%s)\n", get_TIME(&from));
                else
                    Debug(" from (%i/%i)\n", from.numer, from.denom);

                if (to.denom ==0)
                    Debug(" to   (%s)\n", get_TIME(&to));
                else
                    Debug(" to  (%i/%i)\n", to.numer, to.denom);
            }
#endif
            if (tmp->RTSP_play(forward, numerator, denominator, &from, &to) == ErrorOccurred)
            {
                (*non_fatal) = AddError(&tmp->ReturnCopyOfError());
                tmp->RemoveErr();
            }
        }
    }
    return ErrorState();
}
