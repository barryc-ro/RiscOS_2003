/***********************************************************************
 Interface.c

impliments standard interface class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

***********************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

extern "C" {
#include "VSPHdr.h"
}

#include "Interface.h"
#include "ServCtrl.h"


static _kernel_oserror *setcallevery(int return_time, void *pw)
{
    return _swix(OS_CallEvery, _INR(0,2), return_time, VSP_Poll, pw);
}

//  +++++++++++++++++++++++++++++++++++++ private functions +++++++++++++++++++++++++++++++++++++

error_flag
Interface::ReadEnvVar(void)
{
    error_flag result = ErrorState();
    const char *setting = NULL;
    
    // if at any stage setting == NULL the method will fall through setting default settings
    
    if (result != ErrorOccurred)
    	setting = getenv("VSPhyperms$NecBlocks");
    
    if (setting != NULL) {
       EnvNumBlocks = atoi(setting);
       setting = getenv("VSPhyperms$HealthPeriod");
    }
    else {
       EnvNumBlocks = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL) {
        Envhealthperiod = atoi(setting);
        setting = getenv("VSPhyperms$VideoPort");
        EnvPortString[0] = '\0';
    }
    else {
    	Envhealthperiod = 0;
    	result = ErrorOccurred;
    }
    
    if (setting != NULL) {
         strncat(EnvPortString, setting, sizeof(EnvPortString));
         setting = getenv("VSPhyperms$DefaultServer");
         EnvServerString[0] = '\0';
    }
    else
         result = ErrorOccurred;
    
    if (setting != NULL){
         strncat(EnvServerString, setting, sizeof(EnvServerString));
         setting = getenv("VSPhyperms$BufferBlocks");
    }
    else
    	result = ErrorOccurred;
    
    if (setting != NULL) {
       EnvBufferBlocks = atoi(setting);
       setting = getenv("VSPhyperms$TCPtimeout");
    }
    else {
       EnvBufferBlocks = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL){
       EnvTCPtimeout = atoi(setting);
       setting = getenv("VSPhyperms$INETtimeout");
    }
    else {
       EnvTCPtimeout = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL){
    	EnvINETtimeout = atoi(setting);
        setting = getenv("VSPhyperms$SourceRecvSpace");
    }
    else {
    	EnvINETtimeout = 0;
    	result = ErrorOccurred;
    }
    
    if (setting != NULL){
    	EnvSourceRecvSpace = atoi(setting);
    }
	// -- 
    if (result == ErrorOccurred)
    	result = MakeError(VSP_NoReadEnvironment);
    
    return result;
}

enum riscos_event_numbers {
        internet_event = 19
};

enum riscos_vector_numbers {
        event_vector = 0x10
};

enum riscos_osbyte_numbers {
        osbyte_disable_event = 13,
        osbyte_enable_event = 14
};

static _kernel_oserror *enableInternetEvent(void *pw)
{
    _kernel_oserror *e;

    e = _swix(OS_Claim, _INR(0,2), event_vector, VSP_InternetEventVeneer, pw);
    if (e == NULL) {
        e = _swix(OS_Byte, _INR(0,1), osbyte_enable_event, internet_event);
    }
    return e;
}

static void disableInternetEvent(void *pw)
{
    (void) _swix(OS_Byte, _INR(0,1), osbyte_disable_event, internet_event);
    (void) _swix(OS_Release, _INR(0,2), event_vector, VSP_InternetEventVeneer, pw);
}

Interface::Interface(void* pword):Error()
{
  // set the error array to null
  for (int i = 0; i < ERROR_ARRAY; i++) errors[i] = NULL;
  
  errorsOffset = 0;
  	
  pw = pword;
  
  ReadEnvVar();
   
  MakeError(setcallevery(Envhealthperiod, pw));
  
  if (!ErrorExists())
  	MakeError(enableInternetEvent(pw));
  	
  init_block_val = 1;
}

Interface::~Interface(void)
{
  disableInternetEvent(pw);
}

//---- error list methods --
void
Interface::error_array_print(void)
{
  int nxt_mst_recn, count = 0;	// incrementor and a count of the number of errors found

  printf(" history of last %i error messages, most recent first\n", ERROR_ARRAY);

  // point to the last error made.
  nxt_mst_recn = errorsOffset;
  
  do {
    	// if we fall off the beginning of the list jump to the end
    	if (nxt_mst_recn <= 0) 
    		nxt_mst_recn = ERROR_ARRAY - 1;
    	else 
    		--nxt_mst_recn;

    	if (errors[nxt_mst_recn] != NULL){
      		++count;
    		errors[nxt_mst_recn]->error_print();
    	}
  } while (nxt_mst_recn != errorsOffset);
  	
  printf(" (%i) errors recorded\n", count);
}

ErrorBlk *Interface::AddError(ErrorBlk *new_error)
{
  // assign an error to error offset then increment it
  // if error[erroroffset] has an error it is ERROR_ARRAY errors old
  
  ErrorBlk *errptr;
  
   if (errors[errorsOffset] != NULL){	// if we have an old error
   	delete errors[errorsOffset];
   	errors[errorsOffset] = NULL;
   }
   
   errptr = errors[errorsOffset] = new_error;
   
   ++errorsOffset;
   
   if (errorsOffset == ERROR_ARRAY) errorsOffset = 0; 	// rotate
   
   return errptr;
}

//  +++++++++++++++++++++++++++++++++++++ SWI interface +++++++++++++++++++++++++++++++++++++

error_flag
Interface::SetServer(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  non_fatal = non_fatal;
  Server *p_ControlStream = NULL;

  if (ErrorExists()) return ErrorOccurred;	// fatal error;
  
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_SetServer){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    	return NoError;
  }// this ensures that no expected functionality is requested

  if (regs->r[0] & 0x01){	// delete server reference in r1
    if (servers.Remove(regs->r[1]) == ErrorOccurred){
    	(*non_fatal) = AddError(&servers.ReturnCopyOfError());
    }
  }
  else {			
    if (regs->r[1] == NULL){// connect to default server
    	if (EnvServerString[0] == NULL) {
    		(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    	}
    	else {
    	     if (regs->r[0] & 0x02) {	// port specified
	    	p_ControlStream = new Server(EnvServerString, (char*)regs->r[2], EnvTCPtimeout);
	    	p_ControlStream->set_interface_owner();
	     }
	     else {
	     	p_ControlStream = new Server(EnvServerString, EnvPortString, EnvTCPtimeout);
	    	p_ControlStream->set_interface_owner();
	     }
	}
    }
    else { // R1 specified
    	     if (regs->r[0] & 0x02) {	// port specified
	    	p_ControlStream = new Server((char*)regs->r[1], (char*)regs->r[2], EnvTCPtimeout);
	    	p_ControlStream->set_interface_owner();
	     }
	     else {
	     	p_ControlStream = new Server((char*)regs->r[1], EnvPortString, EnvTCPtimeout);
	    	p_ControlStream->set_interface_owner();
	     }
    }
    // we should have a connection to the server now
    
    if (p_ControlStream == NULL){
	    return MakeError(VSP_Alloc);
    }
    else {
       	if (p_ControlStream->ErrorExists()) {
    		(*non_fatal) = AddError(&p_ControlStream->ReturnCopyOfError());
    		delete p_ControlStream;
    		p_ControlStream = NULL;
	}
	else {
	  	if ((regs->r[0] & 0x04)&&(regs->r[3] != 0))	// if an error identifier is given
	  		p_ControlStream->create_message_pipe(regs->r[3]);

    		if (servers.Add((void*)p_ControlStream, &(regs->r[0])) == ErrorOccurred)
    			(*non_fatal) = AddError(&servers.ReturnCopyOfError());	// return identifier
    	}
    }
  } // delete element
  regs->r[1] = NECServerType;
  return NoError;

}

error_flag
Interface::OpenStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp = NULL;
  Server *p_ControlStream;
  int tmp_server = 0;
  char ip_addr[STRINGLENGTH];

  if (ErrorExists()) return ErrorOccurred;	// fatal error;

  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_OpenStream){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    	return NoError;
  }// this ensures that no expected functionality is requested

  if (regs->r[0] == 0) {
   	struct in_addr address;
    	char *group_addr = (char*)regs->r[1];
    	int i;
    	for (i=0; i < STRINGLENGTH; ++i){
    	  	if (group_addr[i] == '\0')
    	  		break;
    	  		
    		if (group_addr[i] != ':')
    			ip_addr[i] = group_addr[i];
    		else{
    		  	ip_addr[i] = '\0';
    			break;
    		}
    	}
   	if (inet_aton(ip_addr, &address)){
    	  	if (group_addr[i] == ':'){
    	  	 	regs->r[4] = atoi(group_addr+i+1);
    	  	 	regs->r[1] = (int)ip_addr;
    	  	 	regs->r[0] = 0x03;
    	  	}
    	}
  }
  // attempt to parse R0 == 0;
  
  if (regs->r[0] != 0x03) {//if not a multicast stream
  	if ((regs->r[0] == 0)||(regs->r[4] == 0)) {
  		tmp_server = 1;
 		p_ControlStream = new Server(EnvServerString, EnvPortString, EnvTCPtimeout);
	
 		if ((p_ControlStream != NULL)&&(p_ControlStream->ErrorExists())) {
 			(*non_fatal) = AddError(&(p_ControlStream->ReturnCopyOfError()));
 			delete p_ControlStream; p_ControlStream = NULL;
 			tmp_server = 0;
 		}
 	 }
 	 else {
 	 	p_ControlStream->set_interface_owner();
 	 	if (servers.identify((void**)&p_ControlStream, regs->r[4]) == ErrorOccurred) {
 	 		(*non_fatal) = AddError(&servers.ReturnCopyOfError());
 	 	}
 	 }
  }
  // end parse
  if (*non_fatal == NULL)
  {
    	switch (regs->r[0]){
  		default:   // historic R0 = zero
  			{
        	            PlayElementRequest play_element;
  			    int asset_id;
  			    
  				if (isdigit(*(char*)regs->r[1])){// attempt to convert the string to an asset number
 					asset_id = atoi((char*)regs->r[1]);
 					play_element.asset_id = asset_id;
  					play_element.viewing_start_time = regs->r[4]<<1;
  					play_element.viewing_end_time = regs->r[5]<<1;
  					play_element.RFU[0] = 0;
  					play_element.RFU[1] = 0;
     					tmp = new Stream(EnvINETtimeout, init_block_val, regs->r[2], &play_element, 1, p_ControlStream,
     							EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw);
                		}
                		else
                			(*non_fatal) = AddError(new ErrorBlk(VSP_InvalidValue));
        		}
        	        break;
        	case (0x01):	// r1 contains an asset number
        		{
        	            PlayElementRequest play_element;
	
  				play_element.asset_id = regs->r[1];
  				play_element.viewing_start_time = 0;
  				play_element.viewing_end_time = 0;
  				play_element.RFU[0] = 0;
  				play_element.RFU[1] = 0;
     				tmp = new Stream(EnvINETtimeout, init_block_val, regs->r[2], &play_element, 1, p_ControlStream, 
     								EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw);
     			}
     			break;
  		case (0x02):
  			{	// r1 is a pointer to an array of play elements
			    PlayList play_list = (PlayList)regs->r[1];
  			    size_t play_count;
        	  	
        	  		for (play_count = 0; play_list[play_count].asset_id != NULL; play_count++);
          	
    				tmp = new Stream(EnvINETtimeout, init_block_val, regs->r[2], play_list, play_count+1, p_ControlStream, 
    									EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw);
    			}
    			break;
    		case (0x03):	// multicast stream
    			{				
        	        	tmp = new Stream(EnvINETtimeout, (char*)regs->r[1], regs->r[4], regs->r[2], EnvSourceRecvSpace, 
        	        			EnvNumBlocks, EnvBufferBlocks, EnvTCPtimeout, pw);
                	}
                	break;
        }
        // switch to create asset
    	if ((tmp != NULL)&&(tmp->ErrorExists())){
    	  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	  	delete tmp;
    	  	tmp = NULL;
    	}
        else
   	if ( (tmp != NULL) && (CurrentStreams.Add(tmp, &(regs->r[0]) ) == ErrorOccurred)) {
   	  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
    		delete tmp;
    		tmp = NULL;
    	} // this sets the handle as well.
  }
  
  if (tmp_server){// if we have created a tmp server then we will delete it unless it is now used by the new stream
    	if (p_ControlStream->stream_uses())
    		p_ControlStream->clear_interface_owner();
    	else
  		delete p_ControlStream;
  }
  return NoError;
}

error_flag
Interface::CloseStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  error_flag result = ErrorState();
/*  
  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  else {	// if we cannot find it why should we worry about deleting it
    */
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_CloseStream){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    	return NoError;
  }// this ensures that no expected functionality is requested

  if (CurrentStreams.identify(&tmp, regs->r[1]) != ErrorOccurred) {
    
    if (tmp->stop_stream((ULONG*)&init_block_val) == ErrorOccurred){
      if (tmp->ErrorNum() == VSP_CantDeleteSharedMemory)// the mpeg player still ownes some memory
      		tmp->RemoveErr();			// in this case callbacks are used for ending
      else {	// terminal error
        	err = &tmp->ReturnCopyOfError();
      		result = ErrorOccurred;
      }
    }
    else{ // no error
    	if (CurrentStreams.Remove(regs->r[1]) == ErrorOccurred) {// if ok remove it from the list.
    		(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
    	}
    }
  }

  return result;
}

error_flag
Interface::CheckEndOfStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  error_flag result = ErrorState();

  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_CheckEndOfStream){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    	return NoError;
  }// this ensures that no expected functionality is requested

  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred){
    	regs->r[0] = 1;	// it has ended if it is not here
  	//(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  }
  else {
    if (tmp->CheckEOS(&(regs->r[0])) == ErrorOccurred){
    	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
    }
  }
  return ErrorState();
}

error_flag
Interface::SetSpeed(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  error_flag result = ErrorState();
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_SetSpeed){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    	return NoError;
  }// this ensures that no expected functionality is requested

  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  else 
    if (tmp->SetSpeed(regs->r[0], regs->r[2]) == ErrorOccurred){
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
    }
  return ErrorState();
}

error_flag
Interface::SetPosition(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  error_flag result = ErrorState();
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_SetPosition){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    	return NoError;
  }// this ensures that no expected functionality is requested

  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  else 
    if (tmp->SetPosition(regs->r[0], regs->r[2]) == ErrorOccurred){
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
    }
  return ErrorState();
}

error_flag
Interface::ReadNPT(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  error_flag result = ErrorState();
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_ReadNPT){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    	return NoError;
  }// this ensures that no expected functionality is requested

  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred)
  	//(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  	regs->r[0] = -1;	// as per spec, if we cannot find the stream
  else 
    if (tmp->ReadNPT((ULINT*)&(regs->r[0])) == ErrorOccurred){
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
    }
  return ErrorState();
}

// new swis NEC

error_flag
Interface::GetAssetList(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Server *tmp = NULL;
  int new_server = 0; 

  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_GetAssetList){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    	return NoError;
  }// this ensures that no expected functionality is requested

  if (regs->r[1] == NULL){// connect to default server
    	if (EnvServerString[0] == NULL) {
    		(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    	}
    	else{
    	   tmp = new Server(EnvServerString, EnvPortString, EnvTCPtimeout);
    	   tmp->set_interface_owner();
    	   new_server = 1;
    	   if (tmp->ErrorExists()){
    	   	(*non_fatal) = AddError(&(tmp->ReturnCopyOfError()));
    	   	delete tmp;
    	   	new_server = 0;
    	   }
    	}
  }
  else {
  if (servers.identify((void**)&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  }

  if ((tmp != NULL)&&((*non_fatal) == NULL)&&(tmp->GetAssetList(regs) == ErrorOccurred)){
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
  }
  
  if ( (new_server == 1)&&(!(tmp->stream_uses())) )
  		delete tmp;
  	
  regs->r[2] = NECServerType;
  
  return ErrorState();
}

error_flag
Interface::GetSceneList(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Server *tmp = NULL;
  int new_server = 0;

  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_GetSceneList){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    	return NoError;
  }// this ensures that no expected functionality is requested

  if (regs->r[1] == NULL){// connect to default server
    	if (EnvServerString[0] == NULL) {
    		(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    	}
    	else{
    	   tmp = new Server(EnvServerString, EnvPortString, EnvTCPtimeout);
    	   tmp->set_interface_owner();
    	   new_server = 1;
    	   if (tmp->ErrorExists()){
    	   	(*non_fatal) = AddError(&(tmp->ReturnCopyOfError()));
    	   	delete tmp;
    	   	new_server = 0;
    	   }
    	}
  }
  else {
  if (servers.identify((void**)&tmp, regs->r[1]) == ErrorOccurred)
  	(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  }
  
  if ((tmp != NULL)&&((*non_fatal) == NULL)&&(tmp->GetSceneAssetList(regs) == ErrorOccurred)){
  	(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	tmp->RemoveErr();
  }
  
  if ( (new_server == 1)&&(!(tmp->stream_uses())) )
  		delete tmp;
  
  regs->r[2] = NECServerType;

  return ErrorState();
}

error_flag 
Interface::GetMiscInfo(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
   //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_GetMiscInfo){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
    	return NoError;
  }// this ensures that no expected functionality is requested
#ifdef DEBUGLIB
  	misc_5_10 query_510, *answer;
	int type = regs->r[0];
	
	if ((regs->r[0] == 0x00)&&(regs->r[2] == NULL)){
		regs->r[2] = (int)&query_510;
		regs->r[3] = sizeof(misc_5_10);
	}
	if (regs->r[0] == 0x00)
		answer = (misc_5_10*)regs->r[2];
	
#endif
  if (CurrentStreams.identify(&tmp, regs->r[1]) == ErrorOccurred)
  		(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  else {
  	  if (tmp->GetMiscInfo((ULINT*)&(regs->r[0]), (misc_5_10*)regs->r[2], &(regs->r[3])) == ErrorOccurred) 
  		(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  }
#ifdef DEBUGLIB
    if (type == 0x00){
    	Debug("h_pixels         %i", answer->h_pixels);	// 16 bits
      	Debug("v_pixels         %i", answer->v_pixels);
      	Debug("play_time        %i", answer->play_time);	// 32 bits
      	Debug("status_word      0x%8.8X", answer->status_word);
  	Debug("scene_number     %i", answer->scene_number);
  	Debug("head_time        %i", answer->head_time);
  	Debug("end_time         %i", answer->end_time);
  	Debug("encode_time      %i", answer->encode_time);
  	Debug("bitrate          %i", answer->bitrate);
  	if (regs->r[2] == (int)&query_510){
  		regs->r[2] = NULL;
  		regs->r[3] = 0;
  	}
    }else {
    	if (type == 0x01){
    		Debug("query 5.9, functionality %8.8X", regs->r[0]);
    		Debug("Servers still connected                     %i", getServerListSize());
      		Debug("Streams still active                        %i", CurrentStreams.Size());
    	}
    	else {
    		if (type == 0x02)
    			Debug("query 5.8, state %8.8X", regs->r[0]);
    	}
    }
    	
  	
#endif
  return NoError;
}
