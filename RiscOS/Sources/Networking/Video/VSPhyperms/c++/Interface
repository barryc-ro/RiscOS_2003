/***********************************************************************
 Interface.c

impliments standard interface class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

***********************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

extern "C" {
#include "VSPHdr.h"
}

#include "Interface.h"
#include "ServCtrl.h"

static _kernel_oserror *setcallevery(int return_time, void *pw)
{
    return _swix(OS_CallEvery, _INR(0,2), return_time, VSP_Poll, pw);
}

//  +++++++++++++++++++++++++++++++++++++ private functions +++++++++++++++++++++++++++++++++++++

error_flag
Interface::ReadEnvVar(void)
{
    error_flag result = ErrorState();
    const char *setting = NULL;
    
    // if at any stage setting == NULL the method will fall through setting default settings
    
    if (result != ErrorOccurred)
    	setting = getenv("VSPhyperms$NecBlocks");
    
    if (setting != NULL) {
       EnvNumBlocks = atoi(setting);
       setting = getenv("VSPhyperms$HealthPeriod");
    }
    else {
       EnvNumBlocks = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL) {
        Envhealthperiod = atoi(setting);
        setting = getenv("VSPhyperms$VideoPort");
        EnvPortNum = 0;
    }
    else {
    	Envhealthperiod = 0;
    	result = ErrorOccurred;
    }
    
    if (setting != NULL) {
      	 EnvPortNum = atoi(setting);
         setting = getenv("VSPhyperms$DefaultServer");
         EnvServerString[0] = '\0';
    }
    else
         result = ErrorOccurred;
    
    if (setting != NULL){
         strncat(EnvServerString, setting, sizeof(EnvServerString));
         setting = getenv("VSPhyperms$BufferBlocks");
    }
    else
    	result = ErrorOccurred;
    
    if (setting != NULL) {
       EnvBufferBlocks = atoi(setting);
       setting = getenv("VSPhyperms$TCPtimeout");
    }
    else {
       EnvBufferBlocks = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL){
       EnvTCPtimeout = atoi(setting);
       setting = getenv("VSPhyperms$INETtimeout");
    }
    else {
       EnvTCPtimeout = 0;
       result = ErrorOccurred;
    }
    
    if (setting != NULL){
    	EnvINETtimeout = atoi(setting);
        setting = getenv("VSPhyperms$SourceRecvSpace");
    }
    else {
    	EnvINETtimeout = 0;
    	result = ErrorOccurred;
    }
    
    if (setting != NULL){
    	EnvSourceRecvSpace = atoi(setting);
    }
	// -- 
    if (result == ErrorOccurred)
    	result = MakeError(VSP_NoReadEnvironment);
    
    return result;
}

enum riscos_event_numbers {
        internet_event = 19
};

enum riscos_vector_numbers {
        event_vector = 0x10
};

enum riscos_osbyte_numbers {
        osbyte_disable_event = 13,
        osbyte_enable_event = 14
};

static _kernel_oserror *enableInternetEvent(void *pw)
{
    _kernel_oserror *e;

    e = _swix(OS_Claim, _INR(0,2), event_vector, VSP_InternetEventVeneer, pw);
    if (e == NULL) {
        e = _swix(OS_Byte, _INR(0,1), osbyte_enable_event, internet_event);
    }
    return e;
}

static void disableInternetEvent(void *pw)
{
    (void) _swix(OS_Byte, _INR(0,1), osbyte_disable_event, internet_event);
    (void) _swix(OS_Release, _INR(0,2), event_vector, VSP_InternetEventVeneer, pw);
}

Interface::Interface(void* pword):Error()
{
  // set the error array to null
  for (int i = 0; i < ERROR_ARRAY; i++) errors[i] = NULL;
  
  errorsOffset = 0;
  	
  pw = pword;
  
  ReadEnvVar();
   
  MakeError(setcallevery(Envhealthperiod, pw));
  
  if (!ErrorExists())
  	MakeError(enableInternetEvent(pw));
  	
  init_block_val = 1;
}

Interface::~Interface(void)
{
  disableInternetEvent(pw);
}

//---- error list methods --
void
Interface::error_array_print(void)
{
  int nxt_mst_recn, count = 0;	// incrementor and a count of the number of errors found

  printf(" history of last %i error messages, most recent first\n", ERROR_ARRAY);

  // point to the last error made.
  nxt_mst_recn = errorsOffset;
  
  do {
    	// if we fall off the beginning of the list jump to the end
    	if (nxt_mst_recn <= 0) 
    		nxt_mst_recn = ERROR_ARRAY - 1;
    	else 
    		--nxt_mst_recn;

    	if (errors[nxt_mst_recn] != NULL){
      		++count;
    		errors[nxt_mst_recn]->error_print();
    	}
  } while (nxt_mst_recn != errorsOffset);
  	
  printf(" (%i) errors recorded\n", count);
}

ErrorBlk *Interface::AddError(ErrorBlk *new_error)
{
  // assign an error to error offset then increment it
  // if error[erroroffset] has an error it is ERROR_ARRAY errors old
  
  ErrorBlk *errptr;
  
   if (errors[errorsOffset] != NULL){	// if we have an old error
   	delete errors[errorsOffset];
   	errors[errorsOffset] = NULL;
   }
   
   errptr = errors[errorsOffset] = new_error;
   
   ++errorsOffset;
   
   if (errorsOffset == ERROR_ARRAY) errorsOffset = 0; 	// rotate
   
   return errptr;
}

inline error_flag
Interface::strToAddr(char *string, struct in_addr *addr, ErrorBlk **non_fatal)
{
	if ( ! inet_aton(string, addr) ) {
  		struct hostent *he;

  		he = gethostbyname(EnvServerString);
                if (he == NULL)
                	(*non_fatal) = AddError(new ErrorBlk(IP_BadPortSpecification));
                else
                	       	addr->s_addr = (**he->h_addr_list);
        }
        return NoError;
}
//  +++++++++++++++++++++++++++++++++++++ SWI interface +++++++++++++++++++++++++++++++++++++

error_flag
Interface::SetServer(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  non_fatal = non_fatal;
  InternetObject *p_ControlStream = NULL;
  ULINT port_number;
  struct in_addr address;
  
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_SetServer){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else {
        // if bit 1 is set then we expect to remove an asset
        
  	if (regs->r[0] & 0x01){	// delete server reference in r1
  		if (CurrentServers.Remove(regs->r[1]) == ErrorOccurred){
  	  		(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
  	  	}
  	}
  	else {
#ifdef DEBUGLIB  	  
  	  	Debug("set server %s:%i", regs->r[1], regs->r[2]);
#endif  	  	
  		// if port specified
  		if (regs->r[0] & 0x02)
  			port_number = regs->r[2];
  		else
  			port_number = EnvPortNum;
  			
  		if (regs->r[0] & 0x08)
  			(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  		else {
  			if (regs->r[1] == NULL){// connect to default server
    				if (EnvServerString[0] == NULL)
    					(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    				else 
    					strToAddr(EnvServerString, &address, non_fatal);
                	}
    			else // R1 specified
    				strToAddr((char*)regs->r[1], &address, non_fatal);
                }
    		// we have an ip address and a port number (or an error)
    		if ((*non_fatal) == NULL){
    		  
    		  	if (IN_MULTICAST(ntohl(address.s_addr)))
    		  	  	p_ControlStream = new InternetObject(&address, port_number);
    		  	else 
    		  		p_ControlStream = (InternetObject*)new Server(&address, port_number, EnvTCPtimeout);
    		  		
    		  	if (p_ControlStream != NULL) {
    		  		p_ControlStream->set_interface_owner();
    		  	
      				if (p_ControlStream->ErrorExists()) {
    					(*non_fatal) = AddError(&p_ControlStream->ReturnCopyOfError());
    					delete p_ControlStream;
    					p_ControlStream = NULL;
	                	}
				else {
    					if (CurrentServers.Add(p_ControlStream, &(regs->r[0])) == ErrorOccurred)
    						(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());	// return identifier
    						
    					// if an error identifier is given
    					if ((*non_fatal == NULL)&&(regs->r[0] & 0x04))
	  					p_ControlStream->create_message_pipe(regs->r[3], regs->r[0]);
	  					// handle, stream handle
	  			}
    	                }
    	                else
    	                	MakeError(VSP_Alloc); // fatal die	
                }
        } // delete element
  }
#ifdef DEBUGLIB
	Debug("server handle %i, error %i", regs->r[0], (*non_fatal));
#endif
	  
  regs->r[1] = NECServerType;
  return ErrorState();
}

error_flag
Interface::OpenStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  InternetObject *server = NULL;
  Stream *stream = NULL;
  
  if (ErrorExists()) return ErrorOccurred;	// fatal error;

  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_OpenStream){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else{
#ifdef DEBUGLIB    
    	Debug("open stream server %i, r0 %i", regs->r[4], regs->r[0]);
#endif    	
    	
    	if (regs->r[4] != NULL){
    		if (CurrentServers.identify((ListObject**)&server, regs->r[4]) == ErrorOccurred)
    		  		(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
    	}
    	else {// use default
    	  	struct in_addr address;
    	  	ULINT port = EnvPortNum;
    		if (regs->r[0] == 0){ // assume multicast string in R1.
    		
    		  	char serverString[STRINGLENGTH];
    			char *group_addr = (char*)regs->r[1];
    			int i;
    			
    			for (i=0; i < STRINGLENGTH; ++i){
    		  		if (group_addr[i] == '\0')
    		  			break;
    		  		
    				if (group_addr[i] != ':')
    					serverString[i] = group_addr[i];
    				else{
    				  	serverString[i] = '\0';
    					break;
    				}
    			}
    			
   			if ((inet_aton(serverString, &address))&&(group_addr[i] == ':'))
   				port = atoi(group_addr+i+1);
   			else
   				strToAddr(EnvServerString, &address, non_fatal);
    		}
    		else // use default address
    	  		strToAddr(EnvServerString, &address, non_fatal);
    	  	
    	  	if (*non_fatal == NULL){
    	  		if (IN_MULTICAST(ntohl(address.s_addr))){
    		 		server = new InternetObject(&address, EnvPortNum);
    		 	}
    			else {
    				server = new Server(&address, EnvPortNum, EnvTCPtimeout);
    			}			
    		}
    		
    		if (server == NULL)
    			(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    	}// get a server, or an error
    	
    	if ((*non_fatal) == NULL){
    	  	if (server->ErrorExists()) // check residual errors in server
    	  		(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
    	  	else {
    	  	  	if (server->InternetObjectType() == server_ip_address)
    	  	  		 stream = new Stream(EnvINETtimeout, server, regs->r[2], EnvSourceRecvSpace, EnvNumBlocks, EnvBufferBlocks, EnvTCPtimeout, pw);
    	  	  	else {
    	  	  	  	Server *control_server = (Server*)server;	   
 	   			switch (regs->r[0]){
	  				default:   // historic R0 = zero
	  					{
	        	            			PlayElementRequest play_element;
	  			    			int asset_id;
	  			    
	  						if (isdigit(*(char*)regs->r[1])){// attempt to convert the string to an asset number
	 							asset_id = atoi((char*)regs->r[1]);
	 							play_element.asset_id = asset_id;
	 							if (regs->r[5] > regs->r[4]){
	  								play_element.viewing_start_time = regs->r[4]<<1;
	  								play_element.viewing_end_time = regs->r[5]<<1;
	  							}
	  							else{
	  								play_element.viewing_start_time = 0;
	  								play_element.viewing_end_time = 0;
	  							}
	  							play_element.RFU[0] = 0;
	  							play_element.RFU[1] = 0;
	  							stream = new Stream(EnvINETtimeout, init_block_val, regs->r[2], &play_element, 1, control_server, 
		  								EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw, regs->r[4], regs->r[5]);
  							}
        	        				else
                						(*non_fatal) = AddError(new ErrorBlk(VSP_InvalidValue));
        					}
        	        			break;
		        		case (0x01):	// r1 contains an asset number
        					{
        		        		    PlayElementRequest play_element;
			
  							play_element.asset_id = regs->r[1];
  							play_element.viewing_start_time = 0;
  							play_element.viewing_end_time = 0;
  							play_element.RFU[0] = 0;
  							play_element.RFU[1] = 0;
     							stream = new Stream(EnvINETtimeout, init_block_val, regs->r[2], &play_element, 1, control_server, 
     											EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw);
     						}
     						break;
  					case (0x02):
  						{	// r1 is a pointer to an array of play elements
				    			PlayList play_list = (PlayList)regs->r[1];
  				    			size_t play_count;
        		  	
        		  				for (play_count = 0; play_list[play_count].asset_id != NULL; play_count++);
        	  	
    							stream = new Stream(EnvINETtimeout, init_block_val, regs->r[2], play_list, play_count+1, control_server, 
    										EnvNumBlocks, EnvSourceRecvSpace, EnvBufferBlocks, pw);
    						}
    						break;
        			}// switch to create asset
    				if ((stream != NULL)&&(stream->ErrorExists())){
    		  			(*non_fatal) = AddError(&stream->ReturnCopyOfError());
    		  			delete stream;
    		  			stream = NULL;
    				}
        			else
   				if ( (stream != NULL) && (CurrentStreams.Add(stream, &(regs->r[0]) ) == ErrorOccurred)) {
   		  			(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
    				} // this sets the handle as well.
  			}// control stream type
  		}// no error
  	}// non_fatal != null	
  }
  return ErrorState();
}

error_flag
Interface::CloseStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_CloseStream){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else{
  	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) != ErrorOccurred) {
    		if (tmp->stop_stream((ULONG*)&init_block_val) == ErrorOccurred){
    			if (tmp->ErrorNum() == VSP_CantDeleteSharedMemory)// the mpeg player still ownes some memory
    		  		tmp->RemoveErr();			// in this case callbacks are used for ending
    			else
    			    	(*non_fatal) = &tmp->ReturnCopyOfError();
    		}
    		else // no error
    			if (CurrentStreams.Remove(regs->r[1]) == ErrorOccurred)// if ok remove it from the list.
    				(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  	}
  }
  return ErrorState();
}

error_flag
Interface::CheckEndOfStream(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_CheckEndOfStream){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else{
	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred){
    		regs->r[0] = 1;// if we cannot find it is closed
    	}
  	else {
    		if (tmp->CheckEOS(&(regs->r[0])) == ErrorOccurred)
    			(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    	}
  }
  return ErrorState();
}

error_flag
Interface::SetSpeed(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_SetSpeed){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else{
	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  		(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  	else 
  	  	if (tmp->SetSpeed(regs->r[0], regs->r[2]) == ErrorOccurred)
  			(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  }
  return ErrorState();
}

error_flag
Interface::SetPosition(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_SetPosition){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else{
	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  		(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  	else 
    		if (tmp->SetPosition(regs->r[0], regs->r[2]) == ErrorOccurred)
  			(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  }
  return ErrorState();
}

error_flag
Interface::ReadNPT(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
  
  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_ReadNPT){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else {
  	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  		regs->r[0] = -1;	// as per spec, if we cannot find the stream
  	else 
    		if (tmp->ReadNPT((ULINT*)&(regs->r[0])) == ErrorOccurred)
  			(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  }
  return ErrorState();
}

// new swis NEC

error_flag
Interface::GetAssetList(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Server *tmp = NULL;
  int new_server = 0; 

  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_GetAssetList){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else {
    	if (regs->r[1] == NULL){// connect to default server
    		if (EnvServerString[0] == NULL) {
    			(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    		}
    		else{
  			struct in_addr address;
  			
  			strToAddr(EnvServerString, &address, non_fatal);
  			
  			if ((*non_fatal) == NULL){
  				new_server = 1;
    	   			tmp = new Server(&address, EnvPortNum, EnvTCPtimeout);
    	   			
    	   			if (tmp->ErrorExists()){
    	   				(*non_fatal) = AddError(&(tmp->ReturnCopyOfError()));
    	   				delete tmp;
    	   				new_server = 0;
    	                	}
    	                	else
    	                		tmp->set_interface_owner();
    	                }
    	        }
  	}
  	else {
  		if (CurrentServers.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  			(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
  	}

  	if ((tmp != NULL)&&((*non_fatal) == NULL)&&(!tmp->stream_uses())&&(tmp->GetAssetList(regs) == ErrorOccurred)){
  		(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  	  	tmp->RemoveErr();
  	}
  
  	if ( (new_server == 1)&&(!tmp->stream_uses()) )
  			delete tmp;
#ifdef DEBUGLIB  			
  	else
  		Debug("new server (%i), tmp->stream_uses (%i)", new_server, tmp->stream_uses());
#endif  		
  }
  regs->r[2] = NECServerType;
  return ErrorState();
}

error_flag
Interface::GetSceneList(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Server *tmp = NULL;
  int new_server = 0;

  //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] & ~R0_MASK_GetSceneList){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else {
	if (regs->r[1] == NULL){// connect to default server
    		if (EnvServerString[0] == NULL) {
    			(*non_fatal) = AddError(new ErrorBlk(IP_UnknownServer));
    		}
    		else{
    		  
  			struct in_addr address;
  			
  			strToAddr(EnvServerString, &address, non_fatal);
  			
  			if ((*non_fatal) == NULL){
  				new_server = 1;
  				tmp = new Server(&address, EnvPortNum, EnvTCPtimeout);
    			
    	   			if (tmp->ErrorExists()){
    	   				(*non_fatal) = AddError(&(tmp->ReturnCopyOfError()));
    	   				delete tmp;
    	   				new_server = 0;
    	   			}
    	   			else
    	   				tmp->set_interface_owner();
    	   		}
    	        }
  	}
  	else {
  		if (CurrentServers.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  			(*non_fatal) = AddError(&CurrentServers.ReturnCopyOfError());
  	}
  
  	if ((tmp != NULL)&&((*non_fatal) == NULL)&&(!tmp->stream_uses())&&(tmp->GetSceneAssetList(regs) == ErrorOccurred)){
  		(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
    		tmp->RemoveErr();
        }
#ifdef DEBUGLIB
	else
		Debug("number of scenes %i", regs->r[4]);
#endif        
  
  	if ( (new_server == 1)&&(!(tmp->stream_uses())) )
  		delete tmp;
  }
  regs->r[2] = NECServerType;
  return ErrorState();
}

error_flag 
Interface::GetMiscInfo(_kernel_swi_regs *regs, ErrorBlk **non_fatal)
{
  Stream *tmp;
   //FLAGS: if a bit is set that is not recognised in the flags a non fatal 'not implemented' error is created
  if (regs->r[0] > R0_Reason_GetMiscInfo){
    	(*non_fatal) = AddError(new ErrorBlk(VSP_Unimplemented));
  }// this ensures that no expected functionality is requested
  else {
#ifdef DEBUGLIB
  	misc_5_10 query_510, *answer;
	int type = regs->r[0];
	
	if ((regs->r[0] == 0x00)&&(regs->r[2] == NULL)){
		regs->r[2] = (int)&query_510;
		regs->r[3] = sizeof(misc_5_10);
	}
	if (regs->r[0] == 0x00)
		answer = (misc_5_10*)regs->r[2];
	
#endif
  	if (CurrentStreams.identify((ListObject**)&tmp, regs->r[1]) == ErrorOccurred)
  		(*non_fatal) = AddError(&CurrentStreams.ReturnCopyOfError());
  	else {
  		if (tmp->GetMiscInfo((ULINT*)&(regs->r[0]), (misc_5_10*)regs->r[2], &(regs->r[3])) == ErrorOccurred) 
  			(*non_fatal) = AddError(&tmp->ReturnCopyOfError());
  	}
#ifdef DEBUGLIB
    	if (type == 0x00){
    		Debug("h_pixels         %i", answer->h_pixels);	// 16 bits
      		Debug("v_pixels         %i", answer->v_pixels);
      		Debug("play_time        %i", answer->play_time);	// 32 bits
      		Debug("status_word      0x%8.8X", answer->status_word);
  		Debug("scene_number     %i", answer->scene_number);
  		Debug("head_time        %i", answer->head_time);
  		Debug("end_time         %i", answer->end_time);
  		Debug("encode_time      %i", answer->encode_time);
  		Debug("bitrate          %i", answer->bitrate);
  		if (regs->r[2] == (int)&query_510){
  			regs->r[2] = NULL;
  			regs->r[3] = 0;
  		}
    	}else {
    		if (type == 0x01){
    			Debug("query 5.9, functionality %8.8X", regs->r[0]);
    			Debug("Servers still connected                     %i", getServerListSize());
      			Debug("Streams still active                        %i", CurrentStreams.Size());
    		}	
    		else {
    			if (type == 0x02)
    				Debug("query 5.8, state %8.8X", regs->r[0]);
    		}
        }
#endif
  }
  return ErrorState();
}
