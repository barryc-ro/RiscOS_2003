/******************************************************************************

      File: main.c++
   Purpose: module entry points
    Author: A.Rodger
   History:

 ******************************************************************************/

#include <string.h>
#include <stdio.h>
#include "kernel.h"
#include "swis.h"

extern "C" {
#include "VSPHdr.h"
}

#include "Interface.h"
#include "Error.h"

Interface *interface;
ErrorBlk  *error;

#define UNUSED(a) ((void)(a))
#define Service_DynamicAreaRenumber	0x92

#if CMHG_VERSION < 516
#define CMHG_CONST
#else
#define CMHG_CONST const
#endif

/******************************************************************************
 Generic Veneers
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *VSP_TimeSlice(_kernel_swi_regs *, void *pw) {

  ErrorBlk *non_fatal = NULL;

  if (error == NULL){ 	// if not fatal error
    if (interface != NULL){
 		if (interface->CurrentStreams.TimeSliceCall(pw) == ErrorOccurred )
    		non_fatal = interface->AddError(&(interface->CurrentStreams.ReturnCopyOfError()));
    }
    else
      error = new ErrorBlk(VSP_BadErr);	// fatal
  }
  if (error != NULL)
  	return (_kernel_oserror*)error;
  else
  	return (_kernel_oserror*)non_fatal;
}

// this is the procedure that is placed in the MPEG block descriptor
_kernel_oserror *VSP_EmptyBuffer(_kernel_swi_regs *r, void *) {

  ErrorBlk *non_fatal = NULL;
  
  if (error == NULL){
    if (interface != NULL){
      		//interface->Debug("EmptyBuffer = %8.8X\n", r->r[1]);
		if (interface->CurrentStreams.MPEGInterrupt(r->r[1]) == ErrorOccurred )
    		non_fatal = interface->AddError(&(interface->CurrentStreams.ReturnCopyOfError()));
    }
    else
      error = new ErrorBlk(VSP_BadErr);
  }
  if (error != NULL)
  	return (_kernel_oserror*)error;
  else
  	return (_kernel_oserror*)non_fatal;
}

_kernel_oserror *VSP_SaveStream(_kernel_swi_regs *, void *pw) {
   
  _kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 	if (e != NULL){
  		error = new ErrorBlk(e);
 	}
  return (_kernel_oserror*)error;
}

// this is the call back placed by the source object
_kernel_oserror *VSP_DummyAck(_kernel_swi_regs *, void *) {

  ErrorBlk *non_fatal = NULL;
  
  if (error == NULL){
    if (interface != NULL){
 		if (interface->CurrentStreams.DummyAckPoll() == ErrorOccurred )
    		non_fatal = interface->AddError(&(interface->CurrentStreams.ReturnCopyOfError()));
    }
    else
      error = new ErrorBlk(VSP_BadErr);
  }

  if (error != NULL)
  	return (_kernel_oserror*)error;
  else
  	return (_kernel_oserror*)non_fatal;
}

int VSP_InternetEvent(_kernel_swi_regs *r, void *pw)
{
  // Internet Event has occurred, MUST check event and MUST check socket id.
  // Do not just claim these events, because it will stuff all other network s/w
  
  claim_flag claim = ignore_event;
  
  if (error == NULL){
    if (interface != NULL){
 	interface->CurrentStreams.inetEvent(r->r[1], r->r[2], &claim, pw);	// ignore errors as
    }									// we cannot return any.
  }

  return claim;
}

/******************************************************************************
  module_service

       Module service call entry point.

 ******************************************************************************/
extern "C" void module_service_call( int service_no, _kernel_swi_regs *r, void *pw )
{
	UNUSED( r );
	UNUSED( pw );
	switch ( service_no )
	{
		case Service_DynamicAreaRenumber:
		  	if (error == NULL){ 
    			    if (interface != NULL){
 				if (interface->CurrentStreams.ServiceDynamicAreaRenumber(r->r[2], r->r[3]) == ErrorOccurred )
    					error = &(interface->ReturnCopyOfError());	// that is fatal
			    }
    			    else
    			  	error = new ErrorBlk(VSP_BadErr);
                        }
			break;
	}
}


/******************************************************************************
 module initialisation
  parameters:
     returns:
 ******************************************************************************/

int main(void){
  /*
  this needs to be called to set up the C++ static elements
  */
}

_kernel_oserror *module_initialise(CMHG_CONST char *, int, void *pw)
{
  if (!MessagesFile::init()) {
          // Really bad problems - return error taken from global messages file
          _kernel_oserror e;
          e.errnum = 0;
          strcpy(e.errmess, "NoStore");
          return _swix(MessageTrans_ErrorLookup, _INR(0,2), &e, 0, 0);
  }

  // if you look at the DecAOF of the main.o file
  // the main function makes a call to ______main
  // "BL ______main" this is a call to the C++ library
  // routine to set up the static data.

  main(); //set up static elements


  interface = new Interface(pw);
  error = NULL;

  return NULL;
}

/******************************************************************************
 module finalisation
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *module_finalise (int, int, void *pw)
{
  _kernel_oserror *err;

  // clear timer related callbacks
  err = _swix(OS_RemoveTickerEvent, _INR(0,1), VSP_Poll, pw);
  
  // clear MPEG related callbacks this will have to confer with the MPEG modules
  if ( err != NULL){
  	err = _swix(OS_RemoveTickerEvent, _INR(0,1), VSP_MPEGCall, pw);
  }
  else
  	_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_MPEGCall, pw);
  
  // clear timeslice callbacks.
  if ( err != NULL){
  	err = _swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallBack, pw);
  }
  else
  	_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallBack, pw);

  delete interface; interface = NULL;

  delete error; error = NULL;		// if there are any errors left over from running
  					// it is too late now.
  if (err != NULL) {
          MessagesFile::finalise();
  }

  return err;
}

/******************************************************************************
 module swi decoder
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *swi_handler ( int swi_no, _kernel_swi_regs *r, void *)
{
  ErrorBlk *non_fatal = NULL;
  
  if (error != NULL) return (_kernel_oserror*)error;	// fatal error
  
  if (interface == NULL) 
    error = new ErrorBlk(VSP_BadErr);
  else {
  // if any of the SWI calls return ErrorOccurred it is fatal non fatal errors are
  // returned in the non_fatal pointer,
  
  // Dispatch SWI based on SWI number offset (more efficient for compiler)
  
#ifdef DEBUGLIB
	/*
   int i;
	interface->Debug("SWI CALL %i", swi_no);
	for(i=0; i<7;i++)
		interface->Debug("reg[%i] = %i", i, r->r[i]);
	*/
#endif  
  switch ( swi_no  )
  {
    case VSP_SetServer - VSP_00:
    	if (interface->SetServer(r, &non_fatal) == ErrorOccurred )
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_OpenStream - VSP_00:
    	if (interface->OpenStream(r, &non_fatal) == ErrorOccurred )
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_CloseStream - VSP_00:
  	if (interface->CloseStream(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_CheckEndOfStream - VSP_00:
    	if (interface->CheckEndOfStream(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_SetSpeed - VSP_00:
    	if (interface->SetSpeed(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_SetPosition - VSP_00:
    	if (interface->SetPosition(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_ReadNPT - VSP_00:
    	if (interface->ReadNPT(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_GetAssetList - VSP_00:
    	if (interface->GetAssetList(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_GetSceneList - VSP_00:
    	if (interface->GetSceneList(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_GetMiscInfo - VSP_00:
    	if (interface->GetMiscInfo(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    default:
      non_fatal = interface->AddError(new ErrorBlk(VSP_BadSWI));
      break;
  }
  }// else
  if (error != NULL)
  	return (_kernel_oserror*)error;
  else{
#ifdef DEBUGLIB
	if (non_fatal != NULL) {
		non_fatal->Print(); 
	}
#endif	
  	return (_kernel_oserror*)non_fatal;
  }
}

/*****************************************************************************
 module command handler
  parameters:
     returns:
 *****************************************************************************/
_kernel_oserror *module_clihandler (CMHG_CONST char *, int, int command_no, void *)
{
  switch ( command_no)
  {
    case CMD_VSPInfo:
      printf ( "Development version of " Module_Title " module\n");
      break;
  }
  return (_kernel_oserror*)error;
}

