/******************************************************************************

      File: main.c++
   Purpose: module entry points
    Author: A.Rodger
   History:

 ******************************************************************************/

#include <string.h>
#include <stdio.h>
#include "kernel.h"
#include "swis.h"

extern "C" {
#include "VSPHdr.h"
}

#include "Interface.h"
#include "Error.h"

Interface *interface;
ErrorBlk  *error;

#ifdef DEBUGLIB
ULINT timeslice, inetevents, free_buffer, dummy;
#endif

#define UNUSED(a) ((void)(a))
#define Service_DynamicAreaRenumber	0x92

#if CMHG_VERSION < 516
#define CMHG_CONST
#else
#define CMHG_CONST const
#endif

/******************************************************************************
 Generic Veneers
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *VSP_TimeSlice(_kernel_swi_regs *, void *pw) {

  ErrorBlk *non_fatal = NULL;
#ifdef DEBUGLIB  
  ULINT monotime1, monotime2;
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &monotime1);
#endif
  if (error == NULL){ 	// if not fatal error
    if (interface != NULL){
      	//interface->Debug("ts+");
 	if (interface->stream_list()->TimeSliceCall(pw) == ErrorOccurred ){
    		non_fatal = interface->AddError(&(interface->stream_list()->ReturnCopyOfError()));
    		interface->stream_list()->RemoveErr();
    	}
      	//interface->Debug("ts-");
    }
    else
      	error = new ErrorBlk(VSP_BadErr);	// fatal
  }
#ifdef DEBUGLIB  
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &monotime2);
  timeslice += monotime2 - monotime1;
#endif
  
  return error->get_ro_err();
}

// this is the procedure that is placed in the MPEG block descriptor
_kernel_oserror *VSP_EmptyBuffer(_kernel_swi_regs *r, void *) {

  ErrorBlk *non_fatal = NULL;

#ifdef DEBUGLIB  
  ULINT monotime1, monotime2;
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &monotime1);
#endif
  
  if (error == NULL){
    if (interface != NULL){
      	//interface->Debug("eb+");
	if (interface->stream_list()->MPEGInterrupt(r->r[1]) == ErrorOccurred ){
    		non_fatal = interface->AddError(&(interface->stream_list()->ReturnCopyOfError()));
    		interface->stream_list()->RemoveErr();
    	}
      	//interface->Debug("eb-");
    }
    else
    	error = new ErrorBlk(VSP_BadErr);
  }
  
#ifdef DEBUGLIB  
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &monotime2);
  free_buffer += monotime2 - monotime1;
#endif
   
  return error->get_ro_err();
}

_kernel_oserror *VSP_CallAfter(_kernel_swi_regs *, void *pw)
{  	
  _kernel_oserror *e = _swix(OS_AddCallBack, _INR(0,1), VSP_CallBack, pw);	  	
 	if (e != NULL){
  		error = new ErrorBlk(e);
 	}
  return error->get_ro_err();
}

// this is the call back placed by the source object
_kernel_oserror *VSP_DummyAck(_kernel_swi_regs *, void *) {

  ErrorBlk *non_fatal = NULL;
  
#ifdef DEBUGLIB  
  ULINT monotime1, monotime2;
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &monotime1);
#endif

  if (error == NULL){
    if (interface != NULL){
      	//interface->Debug("da+");
 	if (interface->stream_list()->DummyAckPoll() == ErrorOccurred){
    		non_fatal = interface->AddError(&(interface->stream_list()->ReturnCopyOfError()));
    		interface->stream_list()->RemoveErr();
    	}
      	//interface->Debug("da-");
    }
    else
      	error = new ErrorBlk(VSP_BadErr);
  }
#ifdef DEBUGLIB  
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &monotime2);
  dummy += monotime2 - monotime1;
#endif
 
  return error->get_ro_err();
}

int VSP_InternetEvent(_kernel_swi_regs *r, void *pw)
{
  // Internet Event has occurred, MUST check event and MUST check socket id.
  // Do not just claim these events, because it will stuff all other network s/w
  
  claim_flag claim = ignore_event;

#ifdef DEBUGLIB  
  ULINT monotime1, monotime2;
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &monotime1);
#endif
  
  if (error == NULL){
    if (interface != NULL){
      	//interface->Debug("in+");
        _kernel_irqs_on();
 	if (interface->stream_list()->inetEvent(r->r[1], r->r[2], &claim, pw) == ErrorOccurred) {
    		interface->AddError(&(interface->stream_list()->ReturnCopyOfError()));
    		interface->stream_list()->RemoveErr();
    	}
    	
    	if (claim == ignore_event){
 		if (interface->server_list()->inetEvent(r->r[1], r->r[2], &claim) == ErrorOccurred) {
    			interface->AddError(&(interface->server_list()->ReturnCopyOfError()));
    			interface->server_list()->RemoveErr();
    		}
    	}
        _kernel_irqs_off();
      	//interface->Debug("in-");
    }									// we cannot return any.
  }
#ifdef DEBUGLIB  
  (void) _swix(OS_ReadMonotonicTime, _OUT(0), &monotime2);
  inetevents += monotime2 - monotime1;
#endif
 
  return claim;
}

/******************************************************************************
  module_service

       Module service call entry point.

 ******************************************************************************/
extern "C" void module_service_call( int service_no, _kernel_swi_regs *r, void *pw )
{
	UNUSED( r );
	UNUSED( pw );
	switch ( service_no )
	{
		case Service_DynamicAreaRenumber:
		  	if (error == NULL){ 
    			    if (interface != NULL){
      				//interface->Debug("service+");
      				
 				if (interface->stream_list()->ServiceDynamicAreaRenumber(r->r[2], r->r[3]) == ErrorOccurred )
    					interface->AddError(&(interface->stream_list()->ReturnCopyOfError()));
    				
      				//interface->Debug("service-");
			    }
    			    else
    			  	error = new ErrorBlk(VSP_BadErr);
                        }
			break;
	}
}


/******************************************************************************
 module initialisation
  parameters:
     returns:
 ******************************************************************************/

int main(void){
  /*
  this needs to be called to set up the C++ static elements
  */
}

_kernel_oserror *module_initialise(CMHG_CONST char *, int, void *pw)
{
  if (!MessagesFile::init()) {
          // Really bad problems - return error taken from global messages file
          _kernel_oserror e;
          e.errnum = 0;
          strcpy(e.errmess, "NoStore");
          return _swix(MessageTrans_ErrorLookup, _INR(0,2), &e, 0, 0);
  }

  // if you look at the DecAOF of the main.o file
  // the main function makes a call to ______main
  // "BL ______main" this is a call to the C++ library
  // routine to set up the static data.

  main(); //set up static elements


  interface = new Interface(pw);
  error = NULL;
  
#ifdef DEBUGLIB  
	timeslice = inetevents = free_buffer = dummy = 0;
#endif 
  return NULL;
}

/******************************************************************************
 module finalisation
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *module_finalise (int, int, void *pw)
{
  _kernel_oserror *err;

  delete interface; interface = NULL;

  delete error; error = NULL;		// if there are any errors left over from running
  
  // clear timer related callbacks
  err = _swix(OS_RemoveTickerEvent, _INR(0,1), VSP_Poll, pw);
  
  // clear MPEG related callbacks this will have to confer with the MPEG modules
  if ( err != NULL){
  	err = _swix(OS_RemoveTickerEvent, _INR(0,1), VSP_MPEGCall, pw);
  }
  else
  	_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_MPEGCall, pw);
  
  // clear timeslice callbacks.
  if ( err != NULL){
  	err = _swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);
  }
  else
  	_swix(OS_RemoveTickerEvent, _INR(0,1), VSP_CallAfterVeneer, pw);

  					// it is too late now.
  if (err != NULL) {
          MessagesFile::finalise();
  }
  return err;
}

/******************************************************************************
 module swi decoder
  parameters:
     returns:
 ******************************************************************************/
_kernel_oserror *swi_handler ( int swi_no, _kernel_swi_regs *r, void *)
{
  ErrorBlk *non_fatal = NULL;
  
  if (error != NULL) return error->get_ro_err();	// fatal error
  
  if (interface == NULL) 
    error = new ErrorBlk(VSP_BadErr);
  else {
  // if any of the SWI calls return ErrorOccurred it is fatal non fatal errors are
  // returned in the non_fatal pointer,
  
  // Dispatch SWI based on SWI number offset (more efficient for compiler)
#ifdef DEBUGLIB
 //	interface->Debug("+ %8.8X", swi_no);
#endif
	  
  switch ( swi_no  )
  {
    case VSP_SetServer - VSP_00:
    	if (interface->SetServer(r, &non_fatal) == ErrorOccurred )
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_OpenStream - VSP_00:
    	if (interface->OpenStream(r, &non_fatal) == ErrorOccurred )
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_CloseStream - VSP_00:
  	if (interface->CloseStream(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_CheckEndOfStream - VSP_00:
    	if (interface->CheckEndOfStream(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_SetSpeed - VSP_00:
    	if (interface->SetSpeed(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_SetPosition - VSP_00:
    	if (interface->SetPosition(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_ReadNPT - VSP_00:
    	if (interface->ReadNPT(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_GetAssetList - VSP_00:
    	if (interface->GetAssetList(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_GetSceneList - VSP_00:
    	if (interface->GetSceneList(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    case VSP_GetMiscInfo - VSP_00:
    	if (interface->GetMiscInfo(r, &non_fatal) == ErrorOccurred)
    		error = &(interface->ReturnCopyOfError());
    	else error = NULL;
    	break;
    default:
      non_fatal = interface->AddError(new ErrorBlk(VSP_BadSWI));
      break;
  }
  }// else
#ifdef DEBUGLIB  
  if (non_fatal != NULL)
  	interface->Debug("- error %8.8X, %8.8X", swi_no, non_fatal->ErrorNum());
  //else
  //	interface->Debug("-");
#endif  	
  if (error != NULL)
  	return error->get_ro_err();
  else
  	return non_fatal->get_ro_err();
}

/*****************************************************************************
 module command handler
  parameters:
     returns:
 *****************************************************************************/
_kernel_oserror *module_clihandler (CMHG_CONST char *, int, int command_no, void *)
{
  switch ( command_no)
  {
    case CMD_VSPInfo:
#ifdef DEBUGLIB
      printf ( " " Module_Title " module, Diagnostic Version " Module_VersionString "\n");
      printf ( " timeslice   = %i\n", timeslice);
      printf ( " inetevents  = %i\n", inetevents);
      printf ( " free_buffer = %i\n", free_buffer);
      printf ( " dummy acks  = %i\n", dummy );
      printf ( " total time in module interrupts %i", timeslice+inetevents+free_buffer+dummy);
#else
      printf ( " " Module_Title " module, Version " Module_VersionString "\n");
#endif
      printf ( "\n Servers still connected                      %i\n", interface->getServerListSize());
      printf (   " Streams still active                         %i\n", interface->stream_list()->Size());
      if (interface != NULL)
        interface->stream_list()->stats.print();
      break;
    case CMD_VSPError:
    	if (error != NULL) {
    		printf(" Terminal error in VSPmodule\n");
    		error->error_print();
    	}
    	else
    		interface->error_array_print();
      break;
    case CMD_VSPConfig:
    	if (error != NULL) {
    		if (error->ErrorNum() == VSP_NoReadEnvironment){
    			delete error; error = NULL;
    			interface->RemoveErr();
		      	interface->ReadEnvVar();
    		}
  	}
    	else    // no error
      		interface->ReadEnvVar();
      break;
  }
  return error->get_ro_err();
}

