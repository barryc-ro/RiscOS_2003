#include "List.h"
#include <stdlib.h>
#include "stdio.h"
#include <limits.h>

int
List::increasesize(void)
{
  /*
  allocate new memory copy the values over and delete the old.
  */
  
  void **tmp_pt_void;	// temporary pointer to void
  int  *tmp_pt_int;	// temporary pointer to identifiers
  int  i;		// counter
  
  tmp_pt_void =(void**)new int[MaxSize + ListChangeSize];
  tmp_pt_int  = new int[MaxSize + ListChangeSize];
  
  if ((tmp_pt_void == NULL)||(tmp_pt_int == NULL)){
      MakeError(VSP_Alloc);
      return ErrorOccurred;
  }
  
  for (i=0; i < CurrentSize; i++){
    tmp_pt_void[i] = object[i];
    tmp_pt_int[i]  = identifiers[i];
  }
  
  delete object; object = NULL;
  delete identifiers; object = NULL;
  
  object 	= tmp_pt_void;
  identifiers 	= tmp_pt_int;
  
  return NoError;
}
  
int
List::decreasesize(void)
{
  /*
  allocate new memory copy the values over and delete the old.
  only if there is sufficient room
  */
  
  void **tmp_pt_void;	// temporary pointer to void
  int   *tmp_pt_int;	// temporary pointer to identifiers
  int i;		// counter
  
  if ( ((MaxSize-ListChangeSize) > CurrentSize)&&((MaxSize-ListChangeSize) >= 0) ) {
  	tmp_pt_void = (void**)new int[MaxSize - ListChangeSize];
  	tmp_pt_int  = new int[MaxSize - ListChangeSize];
  
  	if ((tmp_pt_void == NULL)||(tmp_pt_int == NULL)){
    		MakeError(VSP_Alloc);
      		return ErrorOccurred;
  	}
  
  	for (i=0; i <= CurrentSize; i++){
    		tmp_pt_void[i] = object[i];
    		tmp_pt_int[i]  = identifiers[i];
  	}
  
  	delete object; object = NULL;
  	delete identifiers; identifiers = NULL;
  
  	object 		= tmp_pt_void;
  	identifiers 	= tmp_pt_int;
  }
  return NoError;
}

int
List::EnsureUnique(int id)
{
  int i;
  
  for (i=0;i<CurrentSize;i++)
    if (identifiers[i] == id){
      MakeError(VSP_Unique);
      return ErrorOccurred;
    }   
  return NoError;
}

int 
List::CreateUniqueID(int *id)
{
  if (ErrorExists())
  	return ErrorOccurred;
  	
	// a straight pass through here should be the norm  	
  current_guess++;
  
  if (current_guess == INT_MAX) current_guess = 1;
  
  while (EnsureUnique(current_guess) == ErrorOccurred){
  	RemoveErr();
  	current_guess++;
  	if (current_guess == INT_MAX)
  		current_guess = 1;
  }
  *id = current_guess;
  
  return NoError;
}

int
List::SwitchError(void)
{
  if (!ErrorExists())
  	return NoError;
  	
  switch(ErrorNum()) {
    case VSP_Unique:
    case VSP_UnknownObj:
    	  RemoveErr();
	  break;   	  
    default:
    	return ErrorOccurred;
  }
  return NoError;
}
    

List::List(void):Error()
{
  /*
  Constructor this may cause an error that could go undetected until the object is
  used.
  */
  current_guess = 1;
  object 	= (void**)new int[ListDefaultSize];
  identifiers 	= new int[ListDefaultSize];
  
  if ((object == NULL)||(identifiers == NULL)){
    	MakeError(VSP_Alloc);
    	MaxSize = 0;
  }
  else  MaxSize = ListDefaultSize;
  CurrentSize = 0;				// start with no elements in the list
}

List::List(int size):Error()
{
  current_guess = 1;
  object 	= (void**)new int[size];
  identifiers 	= new int[size];
  
  if ((object == NULL)||(identifiers == NULL)){
    	MakeError(VSP_Alloc);
  	MaxSize = 0;
  }
  else  MaxSize = size;
  CurrentSize = 0;
} 

List::~List(void)
{
  int i;
  
  for (i=(CurrentSize-1); i>=0; i--){
    	delete object[i];			// delete from the top to the bottom
    	object[i] = NULL;
  }
  
  delete[] object; object = NULL;
  delete[] identifiers; identifiers = NULL;
  
  CurrentSize = 0;
}

int
List::Add(void *item)
{
  int id;
  
  if (SwitchError() == ErrorOccurred) {
    return ErrorOccurred;
  }	// if we cannot recover from this error
  
  if (	((CurrentSize >= MaxSize)&&(increasesize() == ErrorOccurred)) ||
  	(CreateUniqueID(&id) == ErrorOccurred) )
  	return ErrorOccurred;
  
  identifiers[CurrentSize] = id;
  object[CurrentSize] = item;
  CurrentSize++;
  
  return id;	//non zero id
}

int
List::Add(void *item, int id)
{
    
  if (SwitchError() == ErrorOccurred) {
    return ErrorOccurred;
  }	// if we cannot recover from this error
 
  if ( (CurrentSize >= MaxSize)&&(increasesize() == ErrorOccurred))
  	return ErrorOccurred;

  if (EnsureUnique(id) == ErrorOccurred){
  	return ErrorOccurred;
  }
  
  identifiers[CurrentSize] = id;
  object[CurrentSize] = item;
  CurrentSize++;
  
  return NoError;
}

void*
List::identify(int identifier)
{  
  int i=0;	// count value

  
  if (SwitchError() == ErrorOccurred) {
    return ErrorOccurred;
  }	// if we cannot recover from this error
   
  while( (i <= CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  if (i > CurrentSize){
  	MakeError(VSP_UnknownObj);
        return (void*)ErrorOccurred;
  }
  else
  	return object[i];
}

int 
List::Remove(int identifier)
{
  int i =0;	// count value
     
  if (SwitchError() == ErrorOccurred) {
    return ErrorOccurred;
  }	// if we cannot recover from this error
  
  while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  if (i == CurrentSize){
  	MakeError(VSP_UnknownObj);
        return ErrorOccurred;
  }

  delete[] object[i]; object[i] = NULL;
  
  while (i < CurrentSize -1){
    object[i] = object[i+1];
    identifiers[i] = identifiers[i+1];
    i++;
  }
  CurrentSize--;
  
  if (decreasesize() != ErrorOccurred)		// this does test for sufficient decrease in size
  	return NoError;
  return ErrorOccurred;
}
