#include "List.h"
#include <stdlib.h>
#include "stdio.h"
#include <limits.h>

error_flag
List::increasesize(void)
{
  /*
  allocate new memory copy the values over and delete the old.
  */
  
  void **tmp_pt_void;	// temporary pointer to void
  int  *tmp_pt_int;	// temporary pointer to identifiers
  int  i;		// counter
  
  tmp_pt_void =(void**)new int[MaxSize + ListChangeSize];
  tmp_pt_int  = new int[MaxSize + ListChangeSize];
  
  if ((tmp_pt_void == NULL)||(tmp_pt_int == NULL))
      return MakeError(VSP_Alloc);
  
  for (i=0; i < CurrentSize; i++){
    tmp_pt_void[i] = object[i];
    tmp_pt_int[i]  = identifiers[i];
  }
  
  delete object; object = NULL;
  delete identifiers; object = NULL;
  
  object 	= tmp_pt_void;
  identifiers 	= tmp_pt_int;
  
  return NoError;
}
  
error_flag
List::decreasesize(void)
{
  /*
  allocate new memory copy the values over and delete the old.
  only if there is sufficient room
  */
  
  void **tmp_pt_void;	// temporary pointer to void
  int   *tmp_pt_int;	// temporary pointer to identifiers
  int i;		// counter
  
  if ( ((MaxSize-ListChangeSize) > CurrentSize)&&((MaxSize-ListChangeSize) >= 0) ) {
  	tmp_pt_void = (void**)new int[MaxSize - ListChangeSize];
  	tmp_pt_int  = new int[MaxSize - ListChangeSize];
  
  	if ((tmp_pt_void == NULL)||(tmp_pt_int == NULL))
    		return MakeError(VSP_Alloc);
  
  	for (i=0; i <= CurrentSize; i++){
    		tmp_pt_void[i] = object[i];
    		tmp_pt_int[i]  = identifiers[i];
  	}
  
  	delete object; object = NULL;
  	delete identifiers; identifiers = NULL;
  
  	object 		= tmp_pt_void;
  	identifiers 	= tmp_pt_int;
  }
  return NoError;
}

error_flag
List::EnsureUnique(int id)
{
  error_flag result = ErrorState();
  int i;
  
  for (i=0;i<CurrentSize;i++){
    if (result == ErrorOccurred)
    	break;
    	
    if (identifiers[i] == id)
      	result = MakeError(VSP_Unique);
  }
      
  return result;
}

error_flag
List::CreateUniqueID(int *id)
{
  // a straight pass through here should be the norm  	
  current_guess++;
  
  if (current_guess == INT_MAX) current_guess = 1;
  
  while (EnsureUnique(current_guess) == ErrorOccurred){
  	RemoveErr();
  	current_guess++;
  	if (current_guess == INT_MAX)
  		current_guess = 1;
  }
  *id = current_guess;
  
  return NoError;
}

error_flag
List::ErrorState(void)
{	
  if (!ErrorExists()){	// contemporary of errorstate
  
   	return NoError;
  }
 	
  switch(ErrorNum()) {
    case VSP_Unique:
    case VSP_UnknownObj:
    	  RemoveErr();
	  break;   	  
    default:
    	return ErrorOccurred;
  }
  return NoError;
}
    

List::List(void):Error()
{
  /*
  Constructor this may cause an error that could go undetected until the object is
  used.
  */
  current_guess = 1;
  object 	= (void**)new int[ListDefaultSize];
  identifiers 	= new int[ListDefaultSize];
  
  if ((object == NULL)||(identifiers == NULL)){
    	MakeError(VSP_Alloc);
    	MaxSize = 0;
  }
  else  MaxSize = ListDefaultSize;
  ExpectedSize = CurrentSize = 0;		// start with no elements in the list
}

List::List(int size):Error()
{
  current_guess = 1;
  object 	= (void**)new int[size];
  identifiers 	= new int[size];
  
  if ((object == NULL)||(identifiers == NULL)){
    	MakeError(VSP_Alloc);
  	MaxSize = 0;
  }
  else  MaxSize = size;
  ExpectedSize = CurrentSize = 0;
} 

List::~List(void)
{
  int i;
  
  ExpectedSize = 0;
  
  for (i=(CurrentSize-1); i>=0; i--){
    	delete object[i];			// delete from the top to the bottom
    	object[i] = NULL;
  }
  
  delete[] object; object = NULL;
  delete[] identifiers; identifiers = NULL;
  
  CurrentSize = 0;
}

error_flag
List::Add(void *item, int *id)
{  
  
  error_flag result = ErrorState();
  
  if (result != ErrorOccurred) {
    	if (ExpectedSize != CurrentSize)
 		return MakeError(VSP_BadDelete);
 		
	++ExpectedSize;
  
  	if (	((CurrentSize >= MaxSize)&&(increasesize() == ErrorOccurred)) ||
  		(CreateUniqueID(id) == ErrorOccurred) )
  		result = ErrorOccurred;
  	else {
  		identifiers[CurrentSize] = (*id);
  		object[CurrentSize] = item;

  		++CurrentSize;
        }
  }
  return result;	//non zero id
}

error_flag
List::identify(void **l_item, int identifier)
{  
  error_flag result = ErrorState();
  
  if (result != ErrorOccurred) {
  	int i=0;	// count value
  	if (result != ErrorOccurred){
  		while( (i <= CurrentSize)&&(identifiers[i] != identifier) )
  			i++;
  
  		if (i > CurrentSize){
  			result = MakeError(VSP_UnknownObj);
  		}
  		else {
 			(*l_item) = object[i];
  		}
  	}
  }
  return result;
}

error_flag 
List::Remove(int identifier)
{
  int i =0;	// count value
  error_flag result = ErrorState();
  

  
  if (result != ErrorOccurred) {
    
     	if (ExpectedSize != CurrentSize)
  		result = MakeError(VSP_BadDelete);
  	
    	--ExpectedSize;
    	
  	while( (i < CurrentSize)&&(identifiers[i] != identifier) ) i++;
  
  	if ((result != ErrorOccurred)&&(i == CurrentSize))
  		result = MakeError(VSP_UnknownObj);
  	
  	if (result != ErrorOccurred){
  		delete[] object[i]; 
  		object[i] = NULL;
        
  		while (i < CurrentSize -1){
    			object[i] = object[i+1];
    			identifiers[i] = identifiers[i+1];
    			i++;
  		}
  		CurrentSize--;
  		
  		// this does test for sufficient decrease in size
  		if (decreasesize() == ErrorOccurred)	
	  		 result = ErrorOccurred;
        	}
  }
  return result;
}
