/**************************************
 ServerATM.c++

implements ATM extentions to the Server class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
15/2/99    AR      File created

**************************************/

#include <string.h>
#include "NECstruct.h"
#include "ServCtrl.h"

#include "kernel.h"
#include "swis.h"

#define ATM_AssociateAddress	0x47B3A
#define ATM_VCConnect           0x47B3B
#define ATM_VCListen		0x47B3C
#define ATM_VCClose		0x47B3D
  	
typedef enum{
  multicap_none = 0,
  multicap_LLC_SNAP,
  multicap_VCMultiplex
} multicap;
// multiprotocol encapsulation type
  	
// this associates our ATM address with our ip address
error_flag  
ATMServer::ATM_Associate()
{
  	return MakeErrorOnError(_swix(ATM_AssociateAddress, _INR(1,2), address.s_addr, &ATMaddress));
}
// this instructs the ATM layer that a connection is expected from the server
error_flag  
ATMServer::ATM_Listen(int *handle)
{
  	return MakeErrorOnError(_swix(ATM_VCListen, _INR(1,2)|_OUT(0), ATMaddress, multicap_LLC_SNAP, handle));
}
error_flag  
ATMServer::ATM_Connect(int *handle)
{
  	return MakeErrorOnError(_swix(ATM_VCConnect, _INR(1,2)|_OUT(0), ATMaddress, multicap_LLC_SNAP, handle));
}
error_flag  
ATMServer::ATM_Close(int handle)
{
  	return MakeErrorOnError(_swix(ATM_VCClose, _INR(1,1), handle));
}
error_flag
ATMServer::send_assetpresentation_request(ULINT init_value, PlayElementRequest playlist[], size_t play_size, struct in_addr ipaddr, ULINT port)
{
   ATM_Address ourATMaddress;
   int request_length = sizeof(AssetPresentationRequest)-8 + (play_size * sizeof(PlayElementRequest)) + sizeof(ATM_Address);

   //get our atm address
   for (int i = 0; i < sizeof(ATM_Address); ++i)
   	ourATMaddress.data[i] = 0;

   if (fill_assetpresentation_request(request_length, init_value, playlist, play_size, ipaddr, port) != ErrorOccurred)
   	SendData(ourATMaddress.data, sizeof(ATM_Address));
   
   return ErrorState();
}

error_flag 
ATMServer::get_assetpresentation_response(struct in_addr *ipaddr, ULINT *port, ULINT *stream_time, ULINT *dgram_size, ULINT *bitrate, ULINT *fast_play_ratio)
{
    error_flag result = Server::get_assetpresentation_response(ipaddr, port, stream_time, dgram_size, bitrate, fast_play_ratio);
    if (result != ErrorOccurred)
    		result = ATM_Listen(&UDPhandle);
    	
    return result;
}

  	
ATMServer::ATMServer(struct in_addr *server, ULINT port, UBYTE *address, bool TCPListen, ULINT timeout):Server(server, port, TCPListen, timeout)
{
    	for(int i = 0; i < sizeof(ATMaddress); ++i)
    		ATMaddress.data[i] = address[i];

    	if (ATM_Associate() != ErrorOccurred){
    		if (TCPListen)
    			ATM_Listen(&TCPhandle);
    		else
    			ATM_Connect(&TCPhandle);
    	}
    
    	if (!ErrorExists())
    		createVSPLink();
}

ATMServer::~ATMServer()
{
  	ATM_Close(TCPhandle);
}
	
server_type
ATMServer::InternetObjectType(void)
{
  	return server_ATM;
}
 
error_flag 
ATMServer::AssetEnd(ULINT status, ULINT endflag)
{
  	error_flag result = Server::AssetEnd(status, endflag);
  	return ATM_Close(UDPhandle);
}
