/**************************************
 ServerATM.c++

implements ATM extentions to the Server class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
15/2/99    AR      File created

**************************************/

#include <string.h>
#include "NECstruct.h"
#include "ServCtrl.h"

#include "kernel.h"
#include "swis.h"

#define ATM_EmptyBuffer                 0x047b39
#define ATM_AssociateAddress            0x047b3a
#define ATM_VCConnect                   0x047b3b
#define ATM_VCListen                    0x047b3c
#define ATM_VCClose                     0x047b3d
#define ATM_VCStatus                    0x047b3e
#define ATM_BootConfig                  0x047b3f
	
typedef enum{
  multicap_none = 0,
  multicap_LLC_SNAP = 33,
  multicap_VCMultiplex = 56
} multicap;
// multiprotocol encapsulation type

#ifdef DEBUGLIB
void
ATMServer::DebugATM(UBYTE *ATMaddress)
{
  int* ATMptr = (int*)ATMaddress;
  
  Debug(" ATM address %8.8X %8.8X %8.8X %8.8X %8.8X", ATMptr[0],  ATMptr[1], ATMptr[2], ATMptr[3], ATMptr[4]);
  Debug(" ip address = %8.8X", address.s_addr);
}
#endif 
	
//-------------------------------------------------------------------start wrappers------------


error_flag  
ATMServer::ATM_Associate(ATML_SOCKADDR_ATM *atm_addr)
{
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMAssociate");
#endif   
  	MakeErrorOnError(_swix(ATM_AssociateAddress, _INR(0,2), 0, atm_addr, address.s_addr));	
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMAssociate-");
#endif  
	return ErrorState();
}


error_flag  
ATMServer::ATM_Listen(int *handle, bool *valid, ATML_SOCKADDR_ATM *atm_addr)
{
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATM_Listen handle %i", (*handle));
#endif   
	if (MakeErrorOnError(_swix(ATM_VCListen, _INR(0,3)|_OUT(0), 0, atm_addr, multicap_LLC_SNAP, 0, handle)) == NoError)
	  	(*valid) = true;
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATM_Listen handle %i-", (*handle));
#endif   
	return ErrorState();
}


error_flag  
ATMServer::ATM_Connect(int *handle, bool *valid, ATML_SOCKADDR_ATM *atm_addr)
{
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMCOnnect %i", (*handle));
#endif   
  	if (MakeErrorOnError(_swix(ATM_VCConnect, _INR(0,8)|_OUT(0), 
  		0, atm_addr, multicap_LLC_SNAP, 0, 0, 0, 0, 0, 0, handle)) == NoError)
  		(*valid) = true;
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMCOnnect %i-", (*handle));
#endif   
  	
  	return ErrorState();
}


error_flag  
ATMServer::ATM_Close(int handle, bool *valid)
{
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMClose %i if %i", handle, *valid);
#endif   
	if (*valid) MakeErrorOnError(_swix(ATM_VCClose, _INR(0,1), 0, handle));
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMClose %i if %i-", handle, *valid);
#endif   
	(*valid) = false;
	
  	return ErrorState();
}
//-------------------------------------------------------------------end wrappers------------
/*
error_flag
ATMServer::send_assetpresentation_request(ULINT init_value, PlayElementRequest playlist[], size_t play_size, struct in_addr ipaddr, ULINT port)
{
   UBYTE ATMbytes[20];
   
   int request_length = sizeof(AssetPresentationRequest)-8 + (play_size * sizeof(PlayElementRequest)) + sizeof(ATMbytes);

   //get our atm address
   for (int i = 0; i < sizeof(ATMbytes); ++i)
   	ATMbytes[i] = 0;

   if (fill_assetpresentation_request(request_length, init_value, playlist, play_size, ipaddr, port) != ErrorOccurred)
   	SendData(ATMbytes, sizeof(ATMbytes));
   
   return ErrorState();
}
*/
error_flag 
ATMServer::get_assetpresentation_response(struct in_addr *ipaddr, ULINT *port, ULINT *stream_time, ULINT *dgram_size, ULINT *bitrate, ULINT *fast_play_ratio)
{
    error_flag result = Server::get_assetpresentation_response(ipaddr, port, stream_time, dgram_size, bitrate, fast_play_ratio);
    if (result != ErrorOccurred)
    		result = ATM_Listen(&UDPhandle, &UDPhandleValid, &atm_addr);
    	
    return result;
}

  	
ATMServer::ATMServer(struct in_addr *server, ULINT port, UBYTE *address, bool TCPListen, ULINT timeout):Server(server, port, TCPListen, timeout)
{
  	TCPhandleValid = UDPhandleValid = false;

    	memset (&atm_addr, 0, sizeof (ATML_SOCKADDR_ATM));
    	atm_addr.satm_family = AF_ATML_ATM;

    	atm_addr.satm_number.type = ATML_NSAP;
    	atm_addr.satm_number.numofdigits = 20;
    	memcpy (atm_addr.satm_number.contents, address, 20);
    	
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) DebugATM(address);
#endif	
    	if (ATM_Associate(&atm_addr) != ErrorOccurred){
    		if (TCPListen)
    			ATM_Listen(&TCPhandle, &TCPhandleValid, &atm_addr);
    		else
    			ATM_Connect(&TCPhandle, &TCPhandleValid, &atm_addr);
    	}
    
    	if (!ErrorExists())
    		createVSPLink();
}

ATMServer::~ATMServer()
{
  	ATM_Close(TCPhandle, &TCPhandleValid);
}
	
server_type
ATMServer::InternetObjectType(void)
{
  	return server_ATM;
}
 
error_flag 
ATMServer::AssetEnd(ULINT status, ULINT endflag)
{
  	Server::AssetEnd(status, endflag);
  	ATM_Close(UDPhandle, &UDPhandleValid);
  	
  	return ErrorState();
}
