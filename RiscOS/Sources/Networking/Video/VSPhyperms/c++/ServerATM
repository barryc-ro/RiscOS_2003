/**************************************
 ServerATM.c++

implements ATM extentions to the Server class.

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
15/2/99    AR      File created

**************************************/

#include <string.h>
#include "NECstruct.h"
#include "ServCtrl.h"

#include "kernel.h"
#include "swis.h"

#ifdef DEBUGLIB
void
ATMServer::DebugATM(UBYTE *ATMaddress)
{
  int* ATMptr = (int*)ATMaddress;
  
  Debug(" ATM address %8.8X %8.8X %8.8X %8.8X %8.8X", ATMptr[0],  ATMptr[1], ATMptr[2], ATMptr[3], ATMptr[4]);
  Debug(" ip address = %8.8X", address.s_addr);
}
#endif 
	
//-------------------------------------------------------------------start wrappers------------


error_flag  
ATMServer::ATM_Associate(ATML_SOCKADDR_ATM *atm_addr)
{
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMAssociate");
#endif   
  	MakeErrorOnError(_swix(ATM_AssociateAddress, _INR(0,2), 0, atm_addr, address.s_addr));	
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMAssociate-");
#endif  
	return ErrorState();
}


error_flag  
ATMServer::ATM_Listen(int *handle, bool *valid, ATML_SOCKADDR_ATM *atm_addr, void *pw)
{
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATM_Listen handle %i", (*handle));
#endif  
	if (pw == NULL)
		MakeErrorOnError(_swix(ATM_VCListen, _INR(0,3)|_OUT(0), 0, atm_addr, multicap_LLC_SNAP, 0, handle));
	else
		MakeErrorOnError(_swix(ATM_VCListen, _INR(0,4)|_OUT(0), 0, atm_addr, multicap_LLC_SNAP, VSP_ServerStatus, pw, handle));	
	  	
	if (!ErrorExists()) (*valid) = true;
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATM_Listen handle %i-", (*handle));
#endif   
	return ErrorState();
}


error_flag  
ATMServer::ATM_Connect(int *handle, bool *valid, ATML_SOCKADDR_ATM *atm_addr, void *pw)
{
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMCOnnect %i", (*handle));
#endif  
	if (pw == NULL)
  		MakeErrorOnError(_swix(ATM_VCConnect, _INR(0,8)|_OUT(0), 0, atm_addr, multicap_LLC_SNAP, 0, 0, 0, 0, 0, 0, handle));
  	else
  		MakeErrorOnError(_swix(ATM_VCConnect, _INR(0,8)|_OUT(0), 0, atm_addr, multicap_LLC_SNAP, VSP_ServerStatus, pw, 0, 0, 0, 0, handle));
  		
  	if (!ErrorExists()) (*valid) = true;
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMCOnnect %i-", (*handle));
#endif   
  	
  	return ErrorState();
}


error_flag  
ATMServer::ATM_Close(int handle, bool *valid)
{
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMClose %i if %i", handle, *valid);
#endif   
	if (*valid) MakeErrorOnError(_swix(ATM_VCClose, _INR(0,1), 0, handle));
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMClose %i if %i-", handle, *valid);
#endif   
	(*valid) = false;
	
  	return ErrorState();
}

error_flag
ATMServer::ATM_Status(int handle, bool valid, ATM_status *status)
{
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMStatus %i if %i", handle, valid);
#endif   
	if (valid)
		MakeErrorOnError(_swix(ATM_VCStatus, _INR(0,5)|_OUT(0), 0, handle, 0, 0, 0, 0, status));
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) Debug("ATMStatus %i", *status);
#endif
	return ErrorState();
}  
	 
//-------------------------------------------------------------------end wrappers------------

error_flag
ATMServer::send_assetpresentation_request(ULINT init_value, PlayElementRequest playlist[], size_t play_size, struct in_addr ipaddr, ULINT port)
{
   UBYTE ATMbytes[20];
   int size = 0;
   
   // set up a listening channel
   if (!ErrorExists()){
    	ATM_Listen(&UDPhandle, &UDPhandleValid, &atm_addr);	// this may or maynot be used by the server
    	
   	int request_length = sizeof(AssetPresentationRequest)-8 + (play_size * sizeof(PlayElementRequest)) + sizeof(ATMbytes);

   //get our atm address
   	MakeErrorOnError(_swix(ATM_GetUNIAddress, _INR(0,2)|_OUT(2), 0, ATMbytes, sizeof(ATMbytes), &size));
   	if (size != sizeof(ATMbytes))
		MakeError(VSP_InvalidValue);
   	else {
		if (fill_assetpresentation_request(request_length, init_value, playlist, play_size, ipaddr, port) != ErrorOccurred)
   			SendData(ATMbytes, sizeof(ATMbytes));
        }
   }
   
   return ErrorState();
}
  	
ATMServer::ATMServer(struct in_addr *server, ULINT port, UBYTE *address, bool TCPListen, ULINT timeout, void *pw)
:Server(server, port, TCPListen, timeout)
{
  	ATM_status status = ATM_status_invalid;
  	
  	TCPhandleValid = UDPhandleValid = false;

    	memset (&atm_addr, 0, sizeof (ATML_SOCKADDR_ATM));
    	atm_addr.satm_family = AF_ATML_ATM;

    	atm_addr.satm_number.type = ATML_NSAP;
    	atm_addr.satm_number.numofdigits = 20;
    	memcpy (atm_addr.satm_number.contents, address, 20);
    	
#ifdef DEBUGLIB
	if (Debug(debug_ATMserver)) DebugATM(address);
#endif	
    	if (ATM_Associate(&atm_addr) != ErrorOccurred){
    		if (TCPListen)
    			ATM_Listen(&TCPhandle, &TCPhandleValid, &atm_addr, pw);
    		else
    			ATM_Connect(&TCPhandle, &TCPhandleValid, &atm_addr, pw);
    	}
  	
  	if (!ErrorExists()){
  		ATM_Status(TCPhandle, TCPhandleValid, &status);
  		if (status == ATM_status_connected)
  			createVSPLink();
  		else
    			MakeError(IP_WaitConnection);
    	}
}

ATMServer::~ATMServer()
{
  	ATM_Close(TCPhandle, &TCPhandleValid);
}
	
server_type
ATMServer::InternetObjectType(void)
{
  	return server_ATM;
}

error_flag
ATMServer::statusEvent(int handle, int state)
{
  	if (ErrorExists() && (ErrorNum() == IP_WaitConnection)){
  	  	if (handle = TCPhandle){
  	  		switch (state){
  			  	case ATM_status_connected:
  			  		{
  			  		  RemoveErr();
  			  		  createVSPLink();
  			  		}
  			  		break;
  			  	case ATM_status_error:
  			  		{
  			  		  RemoveErr();
  			  		  MakeError(IP_SocketError);
  			  		}
  			  		break;
  			}
  		}
  	}
  	return NoError;
}

error_flag 
ATMServer::AssetEnd(ULINT status, ULINT endflag)
{
  	Server::AssetEnd(status, endflag);
  	ATM_Close(UDPhandle, &UDPhandleValid);
  	
  	return ErrorState();
}
