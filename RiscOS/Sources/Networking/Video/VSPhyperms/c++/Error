/**************************************
 Error message control and generation

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
04/09/98  SNB     Updated to cache messages file and do errors nicely

**************************************/

#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "VSPHdr.h"
#include "Error.h"

#ifdef DEBUGLIB //++++++++++++++++++++++++++++++ DEBUG +++++++++++++++++++++++++++++++++

#include "stdio.h"
#include "stdarg.h"

static semaphor debug_semaphor = free_token;
int debug_failures = 0;
debug_flags DebugWord = (debug_flags)0;

void
DebugClass::Debug(_kernel_oserror *err)
{
  unsigned int mt_time;

  if (debug_semaphor != claim_token)
  {
  	debug_semaphor = claim_token;

  	_swix(OS_ReadMonotonicTime, _OUT(0), &mt_time);

  	dprintf(("", "%i, error :%8.8X:%s\n", mt_time, err->errnum, err->errmess));

   	debug_semaphor = free_token;
  }
  else
    	debug_failures++;
}

void
DebugClass::Debug(char *format, ...) const
{
  va_list list;

  unsigned int mt_time;

  if (debug_semaphor != claim_token)
  {
  	debug_semaphor = claim_token;

  	_swix(OS_ReadMonotonicTime, _OUT(0), &mt_time);
  	dprintf(("", "%i, ", mt_time));

  	va_start(list, format);
  	dvprintf(("", format, list));
  	va_end(list);

  	dprintf(("", "\n"));

  	debug_semaphor = free_token;
  }
  else
    	debug_failures++;
}
#endif //debug    //++++++++++++++++++++++++++++++ DEBUG +++++++++++++++++++++++++++++++++

static MessagesFile *messages_file = 0;

MessagesFile::MessagesFile(const char *filename)
        : data(0)
{
        _kernel_oserror *e;
        int size;

        e = _swix(MessageTrans_FileInfo, _IN(1)|_OUT(2), filename, &size);
        if (e == NULL) {
                data = new char[size];
                if (data != NULL) {
                        e = _swix(MessageTrans_OpenFile, _INR(0,2), &msgtrans_desc, filename, data);
                        if (e != NULL) {
                                delete[] data;
                                data = 0;
                        }
                }
        }

}

MessagesFile::~MessagesFile()
{
        (void) _swix(MessageTrans_CloseFile, _IN(0), &msgtrans_desc);
        delete[] data;
        data = 0;
}

int MessagesFile::init()
{
        messages_file = new MessagesFile(FILENAME_MESSAGES);
        return messages_file != 0;
}

void MessagesFile::finalise()
{
        delete messages_file;
        messages_file = 0;
}

_kernel_oserror *MessagesFile::ErrorLookup(_kernel_oserror *e, int errnum,
	const char *p1, const char *p2, const char *p3, const char *p4)
{
        if (data == 0) {
                e->errnum = VSP_Alloc;
                (void) strncpy(e->errmess, "Out of memory for messages file", sizeof(e->errmess));
        }
        else {
                e->errnum = errnum;
                if (errnum == VSP_BadSWI) {
                        /* Generate the standard OS error for this and not a module specific
                         * code.  Parameter is the module name to substitute into message.
                         * (This message comes from Resources:$.Resources.Global.Messages)
                         */
                        e->errnum = 0x1E6;
                        (void) strcpy(e->errmess, "BadSWI");
                        p1 = Module_Title;
                }
                else if (errnum >= VSP_Alloc && errnum < VSPMaxError) {
                        (void) sprintf(e->errmess, "E%02x", errnum%256);
                        e->errnum = errnum;
                }
                else {
                        /* Assume that the token is already in the error buffer */
                }
                // MessageTrans_ErrorLookup always exits with V set and hence a non-NULL result
                // is returned by _swix here.
                (void) memcpy(e, _swix(MessageTrans_ErrorLookup, _INR(0,7), e, &msgtrans_desc,
                        0, 0, p1, p2, p3, p4), sizeof(_kernel_oserror));
        }

        return e;
}

ErrorBlk::ErrorBlk(char *s_token, int token)
{
        (void) strncpy(err.errmess, s_token, sizeof(err.errmess));
        (void) messages_file->ErrorLookup(&err, token);
#ifdef DEBUGLIB
        if (Debug(debug_errors)) {
          	Debug("create error @ %8.8X", &err);
          	Debug(&err);
        }
#endif
}

ErrorBlk::ErrorBlk(const ErrorBlk& errblk)
{
        err.errnum = errblk.err.errnum;
        (void) strncpy(err.errmess, errblk.err.errmess, sizeof(errblk.err.errmess));
#ifdef DEBUGLIB
        if (Debug(debug_errors)) {
          	Debug("create error @ %8.8X", &err);
          	Debug(&err);
        }
#endif
}

ErrorBlk::ErrorBlk(const VSPErrorCodes v)
{
        (void) messages_file->ErrorLookup(&err, (int) v);
#ifdef DEBUGLIB
        if (Debug(debug_errors)) {
          	Debug("create error @ %8.8X", &err);
          	Debug(&err);
        }
#endif
}

ErrorBlk::ErrorBlk(const VSPErrorCodes v, ULINT num)
{
  char str[sizeof(_kernel_oserror)];

  sprintf(str, "%i", num);
        (void) messages_file->ErrorLookup(&err, (int) v, str);
#ifdef DEBUGLIB
        if (Debug(debug_errors)) {
          	Debug("create error @ %8.8X", &err);
          	Debug(&err);
        }
#endif
}

ErrorBlk::ErrorBlk(_kernel_oserror *ro_err)
{
        err.errnum = ro_err->errnum;
        (void) strncpy(err.errmess, ro_err->errmess, sizeof(err.errmess));
#ifdef DEBUGLIB
        if (Debug(debug_errors)) {
          	Debug("create error @ %8.8X", &err);
          	Debug(&err);
        }
#endif
}

ErrorBlk&
ErrorBlk::operator =(const ErrorBlk& errblk)
{
        if (errblk.err.errmess != err.errmess) {
                err.errnum = errblk.err.errnum;
                (void) strncpy(err.errmess, errblk.err.errmess, sizeof(err.errmess));
        }

        return *this;
}

void
ErrorBlk::copy_into_ro_err(_kernel_oserror *ro_err)	// copies this error into the RiscOS errorBlock;
{
  if (ro_err != NULL){
  	ro_err->errnum = err.errnum;
  	strncpy(ro_err->errmess, err.errmess, sizeof(err.errmess));
  }
}

void
ErrorBlk::error_print(void)
{	// used in command line arguments
  printf(" %i: %s\n", err.errnum, err.errmess);
}

/************************************************************************/
// Error SuperClass

ErrorBlk&
Error::ReturnCopyOfError(void)
{
  ErrorBlk *temp = NULL;

  if (err_ptr != NULL){
  	temp = new ErrorBlk(*err_ptr);
#ifdef DEBUGLIB
  	if ((Debug(debug_errors))&&(temp != NULL)) {
  	  	Debug("copy construct error @ %8.8X -> %8.8X", err_ptr->get_ro_err(), temp->get_ro_err());
  		Debug(err_ptr->get_ro_err());
  	}
#endif
  }

  return *temp;
}
// constructors

Error::Error(void) { err_ptr = NULL; }

Error::~Error(void) { delete err_ptr; err_ptr = NULL; }

// other methods

void
Error::RemoveErr(void) {
	delete err_ptr;
	err_ptr = NULL;
}

error_flag
Error::MakeError(char *s_token, int token)
{
   if (err_ptr == NULL)
	err_ptr = new ErrorBlk(s_token, token);

   return ((err_ptr != NULL) ? ErrorOccurred : NoError);
}

error_flag
Error::MakeError(const enum VSPErrorCodes v)
{
   if (err_ptr == NULL)
	err_ptr = new ErrorBlk(v);

   return ((err_ptr != NULL) ? ErrorOccurred : NoError);
}

error_flag
Error::MakeError(const enum VSPErrorCodes v, ULINT num)
{
   if (err_ptr == NULL)
	err_ptr = new ErrorBlk(v, num);

   return  ((err_ptr != NULL) ? ErrorOccurred : NoError);
}

error_flag
Error::MakeErrorOnError(_kernel_oserror *ro_err)
{
   //Debug("make error err_ptr = %8.8X, ro_err = %8.8X", err_ptr, ro_err);
   if ((err_ptr == NULL)&&(ro_err != NULL)){
	err_ptr = new ErrorBlk(ro_err);
   }
   return (ErrorExists() ? ErrorOccurred : NoError);
}

VSPErrorCodes
Error::ErrorNum(void)
{
	return (err_ptr == NULL) ? (VSPErrorCodes)0:err_ptr->ErrorNumber();
}// return the error number
