/**************************************
 Error message control and generation

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
04/09/98  SNB     Updated to cache messages file and do errors nicely

**************************************/

#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "VSPHdr.h"
#include "Error.h"

#ifdef DEBUGLIB //++++++++++++++++++++++++++++++ DEBUG +++++++++++++++++++++++++++++++++

#include "stdio.h"
#include "stdarg.h"

static int flag = 1;

//#define DBG_parallel

#ifdef DBG_parallel
#include "DebugLib/DebugLib.h"
#define DEBUG_FILE			"root:VSPHyperDg"
#else
#define XDebugMod_Send  		0x06c440
#endif

#ifdef DBG_parallel
extern "C" void dbg_init(void){
  debug_initialise("VSP", DEBUG_FILE, "VSP$Debug");
  debug_output_device(PDEBUG_OUTPUT);
}

extern "C" void dbg_exit(void){
  debug_atexit();
}
#endif

#ifdef DEBUG_Errors
ErrorBlk::~ErrorBlk()
{
  char buffer[64];
  sprintf(buffer, "delete error %8.8X ( @ %8.8X )", err.errnum, this);
  
#ifdef DBG_parallel  
  dprintf( ("%s", buffer ) );
#else
  _swix(XDebugMod_Send, _IN(0), buffer);
  //printf("%s", buffer);
#endif
}

void
ErrorBlk::debug(void)
{
    char buffer[64];
   sprintf(buffer, "create error %8.8X ( @ %8.8X )", err.errnum, this);
  
#ifdef DBG_parallel  
  dprintf( ("%s", buffer ) );
#else
  _swix(XDebugMod_Send, _IN(0), buffer);
  //printf("%s", buffer);
#endif
}
#endif // debug errors

void
Error::ErrorDump(void){
  // dumps to standard out
  if (err_ptr != NULL)
  	Debug("error %i:%s", ErrorNum(), err_ptr->ErrorStr());
  else
  	Debug("error none");
}

void
Error::Debug(char *format, ...) const
{
  int string_size;
  va_list list;
 
  if (flag == 0) return;
  flag = 0;
  
  char buffer[128];
  
  unsigned int mt_time;
  _swix(OS_ReadMonotonicTime, _OUT(0), &mt_time);
  sprintf(buffer, "%i, ", mt_time);

  va_start (list, format);
  string_size = strlen(buffer);
  string_size += vsprintf (buffer+string_size, format, list);
  va_end(list);
   
  if (string_size > 124)	// terminate at the correct length
        string_size = 124;
        
  buffer[string_size] = '\n';	// string size is the size of the string not including the null terminator
  buffer[string_size+1] = '\0';	// string size is the size of the string not including the null terminator

#ifdef DBG_parallel  
  dprintf( ("%s", buffer ) );
#else
  _swix(XDebugMod_Send, _IN(0), buffer);
  //printf("%s", buffer);
#endif

  flag = 1;
}

#endif //debug    //++++++++++++++++++++++++++++++ DEBUG +++++++++++++++++++++++++++++++++

static MessagesFile *messages_file = 0;

MessagesFile::MessagesFile(const char *filename)
        : data(0)
{
        _kernel_oserror *e;
        int size;

        e = _swix(MessageTrans_FileInfo, _IN(1)|_OUT(2), filename, &size);
        if (e == NULL) {
                data = new char[size];
                if (data != NULL) {
                        e = _swix(MessageTrans_OpenFile, _INR(0,2), &msgtrans_desc, filename, data);
                        if (e != NULL) {
                                delete[] data;
                                data = 0;
                        }
                }
        }
}

MessagesFile::~MessagesFile()
{
        (void) _swix(MessageTrans_CloseFile, _IN(0), &msgtrans_desc);
        delete[] data;
        data = 0;
}

int MessagesFile::init()
{
#ifdef DBG_parallel  
	dbg_init();
#endif
        messages_file = new MessagesFile(FILENAME_MESSAGES);
        return messages_file != 0;
}

void MessagesFile::finalise()
{
#ifdef DBG_parallel  
	dbg_exit();
#endif
        delete messages_file;
        messages_file = 0;
}

_kernel_oserror *MessagesFile::ErrorLookup(_kernel_oserror *e, int errnum,
	const char *p1, const char *p2, const char *p3, const char *p4)
{
        if (data == 0) {
                e->errnum = VSP_Alloc;
                (void) strncpy(e->errmess, "Out of memory for messages file", sizeof(e->errmess));
        }
        else {
                e->errnum = errnum;
                if (errnum == VSP_BadSWI) {
                        /* Generate the standard OS error for this and not a module specific
                         * code.  Parameter is the module name to substitute into message.
                         * (This message comes from Resources:$.Resources.Global.Messages)
                         */
                        e->errnum = 0x1E6;
                        (void) strcpy(e->errmess, "BadSWI");
                        p1 = Module_Title;
                }
                else if (errnum >= VSP_Alloc && errnum < VSPMaxError) {
                        (void) sprintf(e->errmess, "E%02x", errnum%256);
                        e->errnum = errnum;
                }
                else {
                        /* Assume that the token is already in the error buffer */
                }
                // MessageTrans_ErrorLookup always exits with V set and hence a non-NULL result
                // is returned by _swix here.
                (void) memcpy(e, _swix(MessageTrans_ErrorLookup, _INR(0,7), e, &msgtrans_desc,
                        0, 0, p1, p2, p3, p4), sizeof(_kernel_oserror));
        }

        return e;
}

ErrorBlk::ErrorBlk(char *s_token, int token)
{
        (void) strncpy(err.errmess, s_token, sizeof(err.errmess));
        (void) messages_file->ErrorLookup(&err, token);
#ifdef DEBUG_Errors    
        debug();
#endif        
}

ErrorBlk::ErrorBlk(const ErrorBlk& errblk)
{
        err.errnum = errblk.err.errnum;
        (void) strncpy(err.errmess, errblk.err.errmess, sizeof(errblk.err.errmess));
#ifdef DEBUG_Errors        
        debug();
#endif        
}

ErrorBlk::ErrorBlk(const VSPErrorCodes v)
{
        (void) messages_file->ErrorLookup(&err, (int) v);
#ifdef DEBUG_Errors        
        debug();
#endif        
}

ErrorBlk::ErrorBlk(const VSPErrorCodes v, ULINT num)
{
  char str[sizeof(_kernel_oserror)];
  
  sprintf(str, "%i", num);
        (void) messages_file->ErrorLookup(&err, (int) v, str);
#ifdef DEBUG_Errors        
        debug();
#endif        
}

ErrorBlk::ErrorBlk(_kernel_oserror *ro_err)
{
        err.errnum = ro_err->errnum;
        (void) strncpy(err.errmess, ro_err->errmess, sizeof(err.errmess));
#ifdef DEBUG_Errors        
        debug();
#endif        
}

ErrorBlk&
ErrorBlk::operator =(const ErrorBlk& errblk)
{
        if (errblk.err.errmess != err.errmess) {
                err.errnum = errblk.err.errnum;
                (void) strncpy(err.errmess, errblk.err.errmess, sizeof(err.errmess));
        }

        return *this;
}

void
ErrorBlk::copy_into_ro_err(_kernel_oserror *ro_err)	// copies this error into the RiscOS errorBlock;
{
  if (ro_err != NULL){
  	ro_err->errnum = err.errnum;
  	strncpy(ro_err->errmess, err.errmess, sizeof(err.errmess));
  }
}
  
VSPErrorCodes 
ErrorBlk::ErrorNum(void) { return (VSPErrorCodes)err.errnum; }

void
ErrorBlk::error_print(void)
{	// used in command line arguments
  printf(" %i: %s\n", err.errnum, err.errmess);
}

/************************************************************************/
// Error SuperClass

ErrorBlk&
Error::ReturnCopyOfError(void)
{
  ErrorBlk *temp = NULL;

  if (err_ptr != NULL){
  	temp = new ErrorBlk(*err_ptr);
#ifdef DEBUG_Errors  	
  	Debug("copy (@ %8.8X)", temp);
  	ErrorDump();
#endif  	
  }

  return *temp;
}
// constructors

Error::Error(void) { err_ptr = NULL; }

Error::~Error(void) { delete err_ptr; err_ptr = NULL; }

// other methods

void
Error::RemoveErr(void) {
	delete err_ptr;
	err_ptr = NULL; 
}

error_flag
Error::MakeError(char *s_token, int token) 
{ 
   if (err_ptr == NULL)
	err_ptr = new ErrorBlk(s_token, token);
	
   return ErrorOccurred;
}

error_flag
Error::MakeError(const enum VSPErrorCodes v)
{ 
   if (err_ptr == NULL)
	err_ptr = new ErrorBlk(v);
 
   return ErrorOccurred;
}

error_flag
Error::MakeError(const enum VSPErrorCodes v, ULINT num)
{ 
   if (err_ptr == NULL)
	err_ptr = new ErrorBlk(v, num);
	
   return ErrorOccurred;
}

error_flag
Error::MakeErrorOnError(_kernel_oserror *ro_err) 
{ 
   if ((err_ptr == NULL)&&(ro_err != NULL)){
	err_ptr = new ErrorBlk(ro_err);
   }
   return (ErrorExists() ? ErrorOccurred : NoError);
}
