/**************************************
 Sink.c
	
impliments standard Sink class.

In this case the MPEGTrans Module

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Sink.h"
#include "stdlib.h"
#include "stdio.h"
#include "swis.h"
#include "vspSocket.h"

StatBuffer*
Sink::readstats(tagtype tag, size_t *BufferSize)
{
  tagtype tags[2];
  
  tags[0] = tag;
  tags[1] = ENDOFTAGS;
  
  return readstats(tags, BufferSize);
}

StatBuffer*
Sink::readstats(tagtype *tags, size_t *BufferSize)
{
  _kernel_swi_regs r;
  _kernel_oserror *ro_err = NULL;	//pointer to RiscOS error
  int *buffer;
  	
  buffer = new int[((*BufferSize)+3)>>2];	
 			
  if (buffer == NULL)
   	MakeError(VSP_Alloc);	// Allocation Error
  else
  {
     	r.r[0] = 0; 		// Flags not used yet
     	r.r[1] = MPEGHandle;
     	r.r[2] = (int)tags;
     	r.r[3] = (int)buffer;
     	r.r[4] = (*BufferSize);
     	
     	MakeError(_kernel_swi(MPEGControl_Stats, &r, &r));
     
     	if (!ErrorExists()) {
     		if (r.r[4] < 0){			// if not enough buffer allocation
     		  	delete[] buffer; buffer = NULL;	// free old buffer and allocate larger
       		
     		  	(*BufferSize) = (*BufferSize)-r.r[4];
     		  	buffer = new int[((*BufferSize)+3)>>2];
       			  
			if (buffer == NULL)
 			   	MakeError(VSP_Alloc);
 		 	else
 		 	{
 		      		r.r[0] = 0; 		// Flags not used yet
 		      		r.r[1] = MPEGHandle;
 		      		r.r[2] = (int)tags;
       				r.r[3] = (int)buffer;
       				r.r[4] = (*BufferSize);
       				
     				MakeError(_kernel_swi(MPEGControl_Stats, &r, &r));
   			}
   		}//Buffer overflow, increase buffer
     	}
  }//allocation falt
  return (StatBuffer*)buffer;	// there may be more than one
}  

Sink::Sink(int Handle):Error()
{
  MPEGHandle = Handle;
  //if (fp != NULL)
}

Sink::~Sink(void)
{
}

int
Sink::GetHandle(void)	// returns a copy of the handle
{
  return MPEGHandle;
}

error_flag 
Sink::FullBuffer(BitstreamBufferDescriptor *buffer)	// sends a buffer to the MPEG player
{

  _kernel_oserror *e = _swix(MPEGControl_FullBuffers, _INR(0,2), 0, 
  		MPEGHandle, (int)buffer);
	  	
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG fullbuffers\n");
  			Debug("RO error %s", e+4);
#endif
			return MakeError(e);
   		}

  return ErrorState();
}

error_flag 
Sink::DropBuffers(void)		// returns all buffers
{
  _kernel_oserror *e = _swix(MPEGControl_ResetStream, _INR(0,1), 3, MPEGHandle);
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG dropbuffers\n");
#endif
			return MakeError(e);
   		}
  return ErrorState();
}

error_flag
Sink::ReadNPT(ULINT *time)	// returns the current time since start of play
{
 StatBuffer *buf;		// allocated in read stats
 size_t BufferSize = DefaultBufferSize;
 
 (*time) = 0;
 
 buf = readstats(MPEGControl_Stats_NPT, &BufferSize);

 if (buf!=NULL){
 
 	if ( buf->Tag != MPEGControl_Stats_NPT )
 		MakeError(VSP_MPEGErr);		// should not happen
 	else
 		(*time) = (buf->Data)/100;

 	delete[] buf; buf = NULL;
 }
 
 return ErrorState();
}

error_flag
Sink::CheckEOS(void)		// returns boolean
{
  MakeError(VSP_Unimplemented);
  return ErrorState();
}

error_flag
Sink::OpenStream(void)  	// play, should really be constructor
{
  MakeError(VSP_Unimplemented);
  return ErrorState();
}

error_flag
Sink::CloseStream(void)	// stop, should be destructor
{
  MakeError(VSP_Unimplemented);
  return ErrorState();
}

error_flag
Sink::SetPosition(ULINT time)	// jump to time absolute
{
  time = time;
  MakeError(VSP_Unimplemented);
  return ErrorState();
}

error_flag
Sink::SetSpeed(ULINT speed)	// prime the decoder to handle the new speed
{
    _kernel_oserror *e = _swix(MPEGControl_SetSpeed, _INR(0,2), 0, MPEGHandle, speed);
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG setspeed\n");
#endif
			return MakeError(e);
   		}
  return NoError;
}
