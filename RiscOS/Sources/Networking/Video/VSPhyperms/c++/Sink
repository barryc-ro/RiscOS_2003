/**************************************
 Sink.c
	
impliments standard Sink class.

In this case the MPEGTrans Module

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Sink.h"
#include "stdlib.h"
#include "stdio.h"
#include "swis.h"
#include "vspSocket.h"

StatBuffer*
Sink::readstats(tagtype tag, size_t *BufferSize)
{
  tagtype tags[2];
  
  tags[0] = tag;
  tags[1] = ENDOFTAGS;
  
  return readstats(tags, BufferSize);
}

StatBuffer*
Sink::readstats(tagtype *tags, size_t *BufferSize)
{
  _kernel_swi_regs r;
  _kernel_oserror *ro_err = NULL;	//pointer to RiscOS error
  int *buffer;
  
  if ((*BufferSize)&0x03){
  	(*BufferSize) = (*BufferSize & ~0x03) + 0x04;
  }
  
  buffer = new int[(*BufferSize)];	
  				//word alligned
  if (buffer == NULL)
    MakeError(VSP_Alloc);	// Allocation Error
  else
  {
     Debug("tags %i, %i", tags[0], tags[1]);
     r.r[0] = 0; 		// Flags not used yet
     r.r[1] = MPEGHandle;
     r.r[2] = (int)tags;
     r.r[3] = (int)&buffer;
     r.r[4] = (*BufferSize);
     ro_err = _kernel_swi(MPEGControl_Stats, &r, &r);
     
     if ((ro_err != NULL)&&(r.r[4] >= 0)){
        delete buffer; buffer = NULL;
        MakeError(ro_err);
     }
     if (r.r[4] < 0){			// if not enough buffer allocation
       	delete buffer; buffer = NULL;	// free old buffer and allocate larger
       	
       	(*BufferSize) = (*BufferSize)-r.r[4];
       	buffer = new int[((*BufferSize)|3)>>2];
       					// word aligned	

 	if (buffer == NULL)
    		MakeError(VSP_Alloc);
  	else
  	{
       		r.r[0] = 0; 		// Flags not used yet
       		r.r[1] = MPEGHandle;
       		r.r[2] = (int)tags;
       		r.r[3] = (int)&buffer;
       		r.r[4] = (*BufferSize);
     		ro_err = _kernel_swi(MPEGControl_Stats, &r, &r);
     		
     	   	if ((ro_err != NULL)&&(r.r[4] >= 0))
     	   	{
        		delete buffer; buffer = NULL;
        		MakeError(ro_err);
   		}
   	}
     }//Buffer overflow, increase buffer
     else {
     		Debug("buffer.tags = %i, %i, %i", buffer[0], buffer[1], buffer[2]);
     }
  }//allocation falt
  return (StatBuffer*)buffer;	// there may be more than one
}  

Sink::Sink(int Handle):Error()
{
  MPEGHandle = Handle;
  //if (fp != NULL)
}

Sink::~Sink(void)
{
}

int
Sink::GetHandle(void)	// returns a copy of the handle
{
  return MPEGHandle;
}

error_flag 
Sink::FullBuffer(BitstreamBufferDescriptor *buffer)	// sends a buffer to the MPEG player
{

  _kernel_oserror *e = _swix(MPEGControl_FullBuffers, _INR(0,2), 0, 
  		MPEGHandle, (int)buffer);
	  	
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG fullbuffers\n");
  			Debug("RO error %s", e+4);
#endif
			return MakeError(e);
   		}

  return ErrorState();
}

error_flag 
Sink::DropBuffers(void)		// returns all buffers
{
  _kernel_oserror *e = _swix(MPEGControl_ResetStream, _INR(0,1), 3, MPEGHandle);
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG dropbuffers\n");
#endif
			return MakeError(e);
   		}
  return ErrorState();
}

error_flag
Sink::ReadNPT(ULINT *time)	// returns the current time since start of play
{
 StatBuffer *buf;
 size_t BufferSize = DefaultBufferSize;
 char *datablock;
 
 (*time) = 0;
 
 buf = readstats(MPEGControl_Stats_NPT, &BufferSize);
 if (buf==NULL) return ErrorState();
 
 if ( buf->Tag != MPEGControl_Stats_NPT ){
 	delete buf; buf = NULL;
 	return ErrorState();//MakeError(VSP_MPEGErr);		// should not happen
 }
 else {
     datablock = (char*) &(buf->Data);
     
     (*time) =((datablock[14] << 24) 
 	     | (datablock[15] << 16) 
 	     | (datablock[16] << 8) 
 	     | (datablock[17]));
 	     
     (*time) /= MPEGClockSpeed;	     
 }
 delete buf; buf = NULL;
 return NoError;
}

error_flag
Sink::CheckEOS(void)		// returns boolean
{
  MakeError(VSP_Unimplemented);
  return ErrorState();
}

error_flag
Sink::OpenStream(void)  	// play, should really be constructor
{
  MakeError(VSP_Unimplemented);
  return ErrorState();
}

error_flag
Sink::CloseStream(void)	// stop, should be destructor
{
  MakeError(VSP_Unimplemented);
  return ErrorState();
}

error_flag
Sink::SetPosition(ULINT time)	// jump to time absolute
{
  time = time;
  MakeError(VSP_Unimplemented);
  return ErrorState();
}

error_flag
Sink::SetSpeed(ULINT speed)	// prime the decoder to handle the new speed
{
    _kernel_oserror *e = _swix(MPEGControl_SetSpeed, _INR(0,2), 0, MPEGHandle, speed);
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG setspeed\n");
#endif
			return MakeError(e);
   		}
  return NoError;
}
