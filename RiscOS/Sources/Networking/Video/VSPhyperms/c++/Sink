/**************************************
 Sink.c
	
impliments standard Sink class.

In this case the MPEGTrans Module

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Sink.h"
#include "stdlib.h"
#include "stdio.h"
#include "swis.h"
#include "vspSocket.h"

StatBuffer*
Sink::readstats(tagtype tag, int *BufferSize)
{
  tagtype tags[2];
  
  tags[0] = tag;
  tags[1] = ENDOFTAGS;
  
  return readstats(tags, BufferSize);
}

StatBuffer*
Sink::readstats(tagtype *tags, int *BufferSize)
{
  _kernel_swi_regs r;
  _kernel_oserror *ro_err = NULL;	//pointer to RiscOS error
  int *buffer;
  
  buffer = new int[((*BufferSize)|3)>>2];	
  				//word alligned
  if (buffer == NULL)
    MakeError(VSP_Alloc);	// Allocation Error
  else
  {
     r.r[0] = 0; 		// Flags not used yet
     r.r[1] = MPEGHandle;
     r.r[2] = (int)tags;
     r.r[3] = (int)&buffer;
     r.r[4] = (*BufferSize);
     ro_err = _kernel_swi(MPEGControl_Stats, &r, &r);
     
     			
     if ((ro_err != NULL)&&(r.r[4] >= 0)){
        delete buffer; buffer = NULL;
        MakeError(ro_err);
     }
     if (r.r[4] < 0){			// if not enough buffer allocation
       	delete buffer; buffer = NULL;	// free old buffer and allocate larger
       	
       	(*BufferSize) = (*BufferSize)-r.r[4];
       	buffer = new int[((*BufferSize)|3)>>2];
       					// word aligned	

 	if (buffer == NULL)
    		MakeError(VSP_Alloc);
  	else
  	{
       		r.r[0] = 0; 		// Flags not used yet
       		r.r[1] = MPEGHandle;
       		r.r[2] = (int)tags;
       		r.r[3] = (int)&buffer;
       		r.r[4] = (*BufferSize);
     		ro_err = _kernel_swi(MPEGControl_Stats, &r, &r);
     		
     	   	if ((ro_err != NULL)&&(r.r[4] >= 0))
     	   	{
        		delete buffer; buffer = NULL;
        		MakeError(ro_err);
   		}
   	}
     }//Buffer overflow, increase buffer
  }//allocation falt
  return (StatBuffer*)buffer;	// there may be more than one
}  

Sink::Sink(int Handle):Error()
{
  MPEGHandle = Handle;
  //if (fp != NULL)
}

Sink::~Sink(void)
{
}

int
Sink::GetHandle(void)	// returns a copy of the handle
{
  return MPEGHandle;
}

error_flag 
Sink::FullBuffer(BitstreamBufferDescriptor *buffer)	// sends a buffer to the MPEG player
{
  /*
  FILE *fp = NULL;
  fp = fopen("root:rm.output", "a+");
  
  for (int i =0; i < buffer->buffer_length; ++i)
    	putc(buffer->buffer_ptr[i], fp);
  	
  fclose(fp);
  */
  //Debug("sent %8.8X, size %i", buffer->buffer_ptr, buffer->buffer_length);
  _kernel_oserror *e = _swix(MPEGControl_FullBuffers, _INR(0,2), 0, 
  		MPEGHandle, (int)buffer);
	  	
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG fullbuffers\n");
#endif
			return MakeError(e);
   		}
  return ErrorState();
}

error_flag 
Sink::DropBuffers(void)		// returns all buffers
{
  _kernel_oserror *e = _swix(MPEGControl_ResetStream, _INR(0,1), 3, MPEGHandle);
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG dropbuffers\n");
#endif
			return MakeError(e);
   		}
  return ErrorState();
}

error_flag
Sink::ReadNPT(int *time)	// returns the current time since start of play
{
 StatBuffer *buf;
 int BufferSize = DefaultBufferSize;
 char *datablock;
 
 (*time) = 0;
 
 buf = readstats(MPEGControl_Stats_NPT, &BufferSize);
 if (buf==NULL) return ErrorOccurred;
 
 if ( buf->Tag != MPEGControl_Stats_NPT ){
 	delete buf; buf = NULL;
 	return MakeError(VSP_MPEGErr);		// should not happen
 }
 else {
     datablock = (char*) &(buf->Data);
     
     (*time) =((datablock[14] << 24) 
 	     | (datablock[15] << 16) 
 	     | (datablock[16] << 8) 
 	     | (datablock[17]));
 	     
     (*time) /= MPEGClockSpeed;	     
 }
 delete buf; buf = NULL;
 return NoError;
}

error_flag
Sink::CheckEOS(void)		// returns boolean
{
  return NoError;
}

error_flag
Sink::OpenStream(void)  	// play, should really be constructor
{
  return NoError;
}

error_flag
Sink::CloseStream(void)	// stop, should be destructor
{
  return NoError;
}

error_flag
Sink::SetPosition(int time)	// jump to time absolute
{
  time = time;
  return ErrorState();
}

error_flag
Sink::SetSpeed(int speed)	// prime the decoder to handle the new speed
{
    _kernel_oserror *e = _swix(MPEGControl_SetSpeed, _INR(0,2), 0, MPEGHandle, speed);
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG setspeed\n");
#endif
			return MakeError(e);
   		}
  return NoError;
}
