/**************************************
 Sink.c
	
impliments standard Sink class.

In this case the MPEGTrans Module

© Acorn Computers Ltd

History:

Date      Who     Description of change
===========================================
31/7/98    AR      File created

**************************************/
#include "Sink.h"
#include "stdlib.h"
#include "stdio.h"
#include "swis.h"
#include "vspSocket.h"

Bitstream_buffer_descriptor::Bitstream_buffer_descriptor(void)
{
  link = NULL;
  
  free_routine = NULL;
  free_workspace = NULL;
  buffer_start_address = NULL;
  buffer_length = 0;
  packets = 0;

}

Bitstream_buffer_descriptor::~Bitstream_buffer_descriptor(void)
{
  link = NULL;
  free_routine = NULL;
  free_workspace = NULL;
  buffer_start_address = NULL;
  buffer_length = 0;
  packets = 0;
}

StatBuffer*
Sink::readstats(tagtype tag, int *BufferSize)
{
  tagtype tags[2];
  
  tags[0] = tag;
  tags[1] = ENDOFTAGS;
  
  return readstats(tags, BufferSize);
}

StatBuffer*
Sink::readstats(tagtype *tags, int *BufferSize)
{
  _kernel_swi_regs r;
  _kernel_oserror *ro_err = NULL;	//pointer to RiscOS error
  int *buffer;
  
  buffer = new int[((*BufferSize)|3)>>2];	
  				//word alligned
  if (buffer == NULL)
    MakeError(VSP_Alloc);	// Allocation Error
  else
  {
     r.r[0] = 0; 		// Flags not used yet
     r.r[1] = MPEGHandle;
     r.r[2] = (int)tags;
     r.r[3] = (int)&buffer;
     r.r[4] = (*BufferSize);
     ro_err = _kernel_swi(MPEGControl_Stats, &r, &r);
     
     			
     if ((ro_err != NULL)&&(r.r[4] >= 0)){
        delete buffer; buffer = NULL;
        MakeError(ro_err);
     }
     if (r.r[4] < 0){			// if not enough buffer allocation
       	delete buffer; buffer = NULL;	// free old buffer and allocate larger
       	
       	(*BufferSize) = (*BufferSize)-r.r[4];
       	buffer = new int[((*BufferSize)|3)>>2];
       					// word aligned	

 	if (buffer == NULL)
    		MakeError(VSP_Alloc);
  	else
  	{
       		r.r[0] = 0; 		// Flags not used yet
       		r.r[1] = MPEGHandle;
       		r.r[2] = (int)tags;
       		r.r[3] = (int)&buffer;
       		r.r[4] = (*BufferSize);
     		ro_err = _kernel_swi(MPEGControl_Stats, &r, &r);
     		
     	   	if ((ro_err != NULL)&&(r.r[4] >= 0))
     	   	{
        		delete buffer; buffer = NULL;
        		MakeError(ro_err);
   		}
   	}
     }//Buffer overflow, increase buffer
  }//allocation falt
  return (StatBuffer*)buffer;	// there may be more than one
}  

Sink::Sink(int Handle):Error()
{
  MPEGHandle = Handle;
  //if (fp != NULL)
}

Sink::~Sink(void)
{
}

int
Sink::GetHandle(void)	// returns a copy of the handle
{
  return MPEGHandle;
}

#ifdef OUTPUT_FILE 
error_flag 
Sink::FullBuffer(Bitstream_buffer_descriptor *buffer)	// sends a buffer to the MPEG player
{
  // this must pass buffer + 4 to the MPEG player as the first word is for ownership;
/*
   FILE *fp = NULL;
   int i;
   Bitstream_buffer_descriptor *buffer_ptr = buffer;
   
   char file[16];
   
   sprintf(file, "%s%i\0", "Output:output", MPEGHandle);

  fp = fopen(file, "a+");
  
  do {
    //Debug("%8.8X - %i", buffer_ptr->buffer_start_address, buffer_ptr->buffer_length);
 	for (i=0; i < buffer_ptr->buffer_length; i++){
    		putc((buffer_ptr->buffer_start_address)[i], fp);
    	}

  } while((buffer_ptr = buffer_ptr->link) != NULL);
  
  fclose(fp);
 */
  _kernel_oserror *e = _swix(OS_CallAfter, _INR(0,2), 10, 
  		buffer->free_routine, buffer->free_workspace);
	  	
   		if (e != NULL){
			//Debug("Error in setting callback\n");
			MakeError(e);
   		}
  
  return ErrorState();
}
#else
error_flag 
Sink::FullBuffer(Bitstream_buffer_descriptor *buffer)	// sends a buffer to the MPEG player
{
  _kernel_oserror *e = _swix(MPEGControl_FullBuffers, _INR(0,2), 0, 
  		MPEGHandle, (int)buffer);
	  	
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG fullbuffers\n");
#endif
			MakeError(e);
   		}
  return ErrorState();
}
#endif

error_flag 
Sink::DropBuffers(void)		// returns all buffers
{
  _kernel_oserror *e = _swix(MPEGControl_ResetStream, _INR(0,1), 3, MPEGHandle);
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG fullbuffers\n");
#endif
			MakeError(e);
   		}
  return ErrorState();
}

error_flag
Sink::ReadNPT(int *time)	// returns the current time since start of play
{
 StatBuffer *buf;
 int BufferSize = DefaultBufferSize;
 char *datablock;
 
 (*time) = 0;
 
 buf = readstats(MPEGControl_Stats_NPT, &BufferSize);
 if (buf==NULL) return ErrorOccurred;
 
 if ( buf->Tag != MPEGControl_Stats_NPT ){
 	MakeError(VSP_MPEGErr);		// should not happen
 	delete buf; buf = NULL;
 	return ErrorOccurred;
 }
 else {
     datablock = (char*) &(buf->Data);
     
     (*time) =((datablock[14] << 24) 
 	     | (datablock[15] << 16) 
 	     | (datablock[16] << 8) 
 	     | (datablock[17]));
 	     
     (*time) /= MPEGClockSpeed;	     
 }
 delete buf; buf = NULL;
 return NoError;
}

error_flag
Sink::CheckEOS(void)		// returns boolean
{
  return NoError;
}

error_flag
Sink::OpenStream(void)  	// play, should really be constructor
{
  return NoError;
}

error_flag
Sink::CloseStream(void)	// stop, should be destructor
{
  return NoError;
}

error_flag
Sink::SetPosition(int time)	// jump to time absolute
{
  time = time;
  return ErrorState();
}

error_flag
Sink::SetSpeed(int speed)	// prime the decoder to handle the new speed
{
    _kernel_oserror *e = _swix(MPEGControl_SetSpeed, _INR(0,2), 0, MPEGHandle, speed);
   		if (e != NULL){
#ifdef DEBUGLIB
			Debug("Error in calling MPEG setspeed\n");
#endif
			MakeError(e);
   		}
  return ErrorState();
}
