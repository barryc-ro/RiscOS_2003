/*
 * module.c
 *
 * RISC OS environment dependencies
 */
#include "types.h"
#include "stdio.h"
#include "vsp.h"
#include "misc.h"
#include "errno.h"
#include "zap.h"
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <net/if.h>

#include <netdb.h>
#include <kernel.h>
#include <swis.h>

#include "dci4.h"
#include "mbuf.h"

extern u_long inet_addr();
extern _kernel_oserror *vsp_error(), *calleverytick(), *claim_frames();

#define TickerV              28

struct ebuf {
    int  e_nbr;
    char e_string[64];
} ebuf = { 0 };

#define N_ZAP_ERRORS 16
struct ebuf zap_error_blocks[N_ZAP_ERRORS];

struct cbuf {
    int  c_nbr;
    char c_name[64];
};

#define N_CHANNELS 32
struct cbuf zap_channel_blocks[N_CHANNELS];

struct client {
        int (*cli_call)();      /* cli handler */
};

extern int vsstats();

struct client vsp_cli_call[2] = {
    vsstats,
    0,
};

extern int tick_entry();

struct swient {
    int (*swi_call)();      /* swi handler */
};

#define MAXSWI 10

extern int SetServer(_kernel_swi_regs *r);
extern int OpenStream(_kernel_swi_regs *r);
extern int CloseStream(_kernel_swi_regs *r);
extern int CheckEndofStream(_kernel_swi_regs *r);
extern int SetSpeed(_kernel_swi_regs *r);
extern int SetPosition(_kernel_swi_regs *r);
extern int ReadNPT(_kernel_swi_regs *r);
extern int ReadChannel(_kernel_swi_regs *r);
extern int ReadChannelNames(_kernel_swi_regs *r);

struct swient vsp_ent[MAXSWI] = {
    SetServer,
    OpenStream,
    CloseStream,
    CheckEndofStream,
    SetSpeed,
    SetPosition,
    ReadNPT,
    ReadChannel,
    ReadChannelNames,
    0,
};

void *module_wsp = 0;
int mpeg_handle;
int endofstream = 0;
int endofstream_timer = 0;
int endofstream_timeout = 0;
int do_keepalive = 0;
int zap_keepalive_timer = 0;
char mpeg_vs_pvc[16];
char ccp_pvc[16];
unsigned int atm_swibase;
int dib_unit;
int ccp_pvc_type = CCPPVCTYPE;
char macadr[6];
int alive_timeout = 0;
int do_debug = 0;
int notify_via_var = 0;

extern int vsp_final();
extern int read_npt();

_kernel_oserror *vsp_init(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *e;
    char buf[64];

    module_wsp = pw;
    if(!mb_present() || !read_atm_swibase())
        return ((_kernel_oserror *)0);
    if (read_sysvar("SVB$EOSTimeout", buf, sizeof(buf)) != 0)
        endofstream_timeout = atoi(buf);
    else
        endofstream_timeout = ENDOFSTREAM_TIMEOUT;
    if (read_sysvar("SVB$CCPpvc", buf, sizeof(buf)) != 0)
        strcpy(ccp_pvc, buf);
    if (read_sysvar("SVB$AliveTimeout", buf, sizeof(buf)) != 0)
        alive_timeout = atoi(buf);
    if (read_sysvar("SVB$Debug", buf, sizeof(buf)) != 0)
        do_debug = 1;
    if (read_sysvar("SVB$WebErrorReports", buf, sizeof(buf)) != 0)
        notify_via_var = 0;
    else
        notify_via_var = 1;
    (void) enable_tick_handler();
    (void) read_error_msgs();
    (void) read_channel_names();
    if( (e = mb_entryinit()) != 0 )
        goto out;
    (void) read_atm_swibase();
    e = claim_frames(1);
    if (e)
        goto out;
    atexit(vsp_final);
    return ((_kernel_oserror *)0);
out:
    vsp_final();
    return ((_kernel_oserror *)0);
}

int enable_tick_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = 100;
  r.r[1] = (int)tick_entry;
  r.r[2] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_CallEvery, &r, &r) != 0 ? -1 : 0);
}

int disable_tick_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = (int)tick_entry;
  r.r[1] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_RemoveTickerEvent, &r, &r) != 0 ? -1 : 0);
}

int tick_handler(_kernel_swi_regs *r)
{
    if (zap_keepalive_timer > 0 && --zap_keepalive_timer == 0)
        do_keepalive = 1;
    if (endofstream_timer && --endofstream_timer == 0)
        endofstream = 1;
    return (1);
}

int vsp_final(void)
{
    (void) claim_frames(0);
    (void) mb_closesession();
    (void) disable_tick_handler();
    return (1);
}

_kernel_oserror *
vsp_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    _kernel_oserror *err = 0;
    struct swient *callp = &vsp_ent[swinum];

    err = (_kernel_oserror *)(*(callp->swi_call))(r);
    return (err);
}

/*ARGSUSED*/
_kernel_oserror *
vsp_cli_handler(arg_string, arg_count, cmd_no, pw)
char *arg_string;
int arg_count, cmd_no;
void *pw;
{
    struct client *callp;
    int margc;
    char *margv[10];
    char *cp;
    char **argp = margv;

    margc = 0;
    cp = arg_string;
    while (*cp && arg_count-- > 0) {
        while (isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *argp++ = cp;
        margc++;
        while (*cp != '\0' && !iscntrl(*cp) && !isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *cp++ = '\0';
    }
    *argp++ = 0;
    callp = &vsp_cli_call[cmd_no];
    (void)(*(callp->cli_call))(margc, margv);
    return ((_kernel_oserror *)0);
}

void zap_initstream(int handle)
{
/* This routine commented out by TMD 10-Mar-98
 * Chris Pitts says it doesn't do anything useful
 * and is positively harmful cos it loses buffers
 */
#if 0
    _kernel_swi_regs r;
    char video_host[6];
    int i;

    video_host[0] = 0; video_host[1] = 0;
    for (i = 2; i < 6; i++)
        video_host[i] = 1;
    r.r[0] = 0;
    r.r[1] = (int)video_host;
    r.r[2] = MPEG_PORT_AAL5;
    r.r[3] = handle;
    r.r[4] = 0;
    r.r[5] = 0;
    (void) _kernel_swi(XOS_Bit | StreamInitSWI_ATM, &r, &r);
#endif
}

_kernel_oserror *zap_error(int err, int fatal)
{
    int i;

    if (!err)
        return ((_kernel_oserror *)0);
    for (i = 0; i < N_ZAP_ERRORS; i++) {
        if (zap_error_blocks[i].e_nbr == 0)
            break;
        if (zap_error_blocks[i].e_nbr == err) {
            ebuf.e_nbr = err;
            sprintf(ebuf.e_string, "%s\n", zap_error_blocks[i].e_string);
            if (notify_via_var) {
                if (fatal)
                    (void) set_sysvar("SVB$StatusFatal", ebuf.e_string, strlen(ebuf.e_string));
                else
                    (void) set_sysvar("SVB$StatusInfo", ebuf.e_string, strlen(ebuf.e_string));
                return ((_kernel_oserror *)0);
            }
            else
                return ((_kernel_oserror *)&ebuf);
        }
    }
    ebuf.e_nbr = err;
    sprintf(ebuf.e_string, "Unspecified SVB error %d\n", err);
    return ((_kernel_oserror *)&ebuf);
}

char *zap_channel_name(int c_id)
{
    int i;

    for (i = 0; i < N_CHANNELS; i++) {
        if (zap_channel_blocks[i].c_nbr == -1)
            break;
        if (zap_channel_blocks[i].c_nbr == c_id)
            return (zap_channel_blocks[i].c_name);
    }
    return ((char *)0);
}
#define MPEGControl_MuteSound       0x492c6
#define MPEGControl_Stats           0x492c9

void togglesound (int onoff, int handle)
{
    _kernel_swi_regs r;

    r.r[0] = onoff;
    r.r[1] = handle;
    (void) _kernel_swi(XOS_Bit | MPEGControl_MuteSound, &r, &r);
}

int tags[2];
int stats[3];

int mpeg_streamcount (int handle)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    tags[0] = 0;  /* tag value for amount received by ctrl module */
    tags[1] = -1; /* terminator */

    stats[2] = -1;  /* default value */

    r.r[0] = 0;
    r.r[1] = handle;
    r.r[2] = (int)tags;
    r.r[3] = (int)stats;
    r.r[4] = 12;
    e = _kernel_swi(XOS_Bit | MPEGControl_Stats, &r, &r);
    return (stats[2]);
}

void do_cli(char *str)
{
    _kernel_swi_regs r;

    r.r[0] = (int)str;
    (void) _kernel_swi(XOS_Bit | OS_CLI, &r, &r);
}

zap_initmpegpvc(int vpi, int vci)
{
    char buf[48];

    vpi = vpi;  /* for now - vpis not supported */
    sprintf(buf, "atm25pvc 1.1.1.2 32 %d", vci);
    do_cli(buf);
}

zap_initccppvc()
{
    char buf[48];

    sprintf(buf, "atm25pvc 1.1.1.1 %d %s", ccp_pvc_type, ccp_pvc);
    do_cli(buf);
}

int read_sysvar(var, buf, buflen)
char *var, *buf;
int buflen;
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    r.r[0] = (int)var;
    r.r[1] = (int)buf;
    r.r[2] = buflen;
    r.r[3] = 0;
    r.r[4] = 0;
    e = _kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r);
    if (e || r.r[2] == 0)
        return (0);
    buf[r.r[2]] = 0;
    return (1);
}

int set_sysvar(var, buf, len)
char *var, *buf;
int len;
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    r.r[0] = (int)var;
    r.r[1] = (int)buf;
    r.r[2] = len;
    r.r[3] = 0;
    r.r[4] = 0;
    e = _kernel_swi(XOS_Bit | OS_SetVarVal, &r, &r);
    return (1);
}

vsstats(argc, argv)
int argc;
char **argv;
{
    printf("atm_swibase=%x, alive_timeout=%d\n", atm_swibase, alive_timeout);
    return;
}

int read_error_msgs(void)
{
    FILE *fp;
    int i, n = 0;
    char line[300], *p;

    if ((fp = fopen(ERRMSGFILE, "r")) == NULL)
        return (0);
    while(fgets(line, 100, fp) != NULL) {
        if (line[0] == '|')
            continue;
        p = strchr(line, ':');
        if (p) {
             *p++ = 0;
             zap_error_blocks[n].e_nbr = atoi(line);
             strncpy(zap_error_blocks[n].e_string, p, 64);
             n++;
        }
    }
    zap_error_blocks[n].e_nbr = 0;
    fclose(fp);
    return (1);
}

int read_channel_names(void)
{
    FILE *fp;
    int i, n = 0;
    char line[300], *p;

    if ((fp = fopen(CHANNELFILE, "r")) == NULL) {
        zap_channel_blocks[0].c_nbr = -1;
        return (0);
    }
    while(fgets(line, 100, fp) != NULL) {
        if (line[0] == '|')
            continue;
        p = strchr(line, ':');
        if (p) {
             *p++ = 0;
             zap_channel_blocks[n].c_nbr = atoi(line);
             strncpy(zap_channel_blocks[n].c_name, p, 64);
             n++;
        }
    }
    zap_channel_blocks[n].c_nbr = -1;
    fclose(fp);
    return (1);
}

/*
 * claim_frames - claim/release raw atm aal5 frames; returns
 * error block from Filter SWI, or NULL if no errors.
 */
_kernel_oserror *claim_frames(claim)
int claim;
{
    _kernel_swi_regs r;
    extern int rxf_entry();

    r.r[0] = claim ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
    r.r[1] = dib_unit;
    r.r[2] = FILTER_FRAMETYPE;                      /* Frame type */
    r.r[3] = ADDRLVL_NORMAL;                        /* address level */
    r.r[4] = ERRLVL_NO_ERRORS;                      /* error level */
    r.r[5] = (int)module_wsp;                       /* Protocol Handle */
    r.r[6] = (int)rxf_entry;                        /* Rx frame handler */
    return (_kernel_swi(XOS_Bit | (atm_swibase + DCI_Filter), &r, &r));
}

/*
 * rxf_handler - received frame handler
 */
int rxf_handler(r, pw)
_kernel_swi_regs *r;
void *pw;
{
    struct mbuf *m, *m0;

    m0 = (struct mbuf *)(r->r[1]);
    while( m0 ) {
        m = m0->m_list;
        m0->m_list = 0;
        if (m0->m_next) {
            struct mbuf *n = m0->m_next;
            m_free(m0);
            m0 = n;
            (void) ZAPresponse(mtod(m0, char *), m0->m_len);
        }
        m_freem(m0);
        m0 = m;
    }
    return(1);
}

int read_atm_swibase()
{
    _kernel_swi_regs r;
    struct chaindib *d;

    r.r[0] = 0;
    r.r[1] = Service_EnumerateNetworkDrivers;
    if (_kernel_swi(XOS_Bit | OS_ServiceCall,&r, &r) != 0 )
       return (0);
    d = (struct chaindib *)(r.r[0]);
    if (d == (struct chaindib *)0)
       return (0);
    atm_swibase = d->chd_dib->dib_swibase;
    dib_unit = d->chd_dib->dib_unit;
    memcpy(macadr, d->chd_dib->dib_address, 6);
    return (1);
}

int ZAPwrite(char *msg, int flen)
{
    struct mbuf *m0;
    _kernel_swi_regs r;
    _kernel_oserror *e;
    char atmdst[6];
    int i;

    atmdst[0] = 0; atmdst[1] = 0;
    for (i = 2; i < 6; i++)
        atmdst[i] = 1;
    r.r[0] = (int)atmdst;
    r.r[1] = ccp_pvc_type;
    r.r[2] = msg;
    r.r[3] = flen;
    r.r[4] = 0;
    r.r[5] = 0;
    e = _kernel_swi(XOS_Bit | (atm_swibase + ATMTxFrame), &r, &r);
    return (e ? 0 : 1);
}




