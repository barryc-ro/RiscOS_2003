/*
 *  DHCP (sockets.c)
 *
 * Copyright (C) Element 14 Ltd. 1999
 *
 */
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include "kernel.h"
#include "swis.h"

#include "sys/types.h"
#include "sys/socket.h"
#include "sys/ioctl.h"
#include "sys/filio.h"
#include "sys/sockio.h"
#include "net/if.h"
#include "protocols/dhcp.h"
#include "sys/dcistructs.h"
#include "netinet/in.h"
#include "arpa/inet.h"

#include "dhcp.h"
#include "interfaces.h"
#include "sockets.h"
#include "socklib.h"
#include "packets.h"

/* This is the socket handle which we can use for all our activities, including
 * sending ioctls to the Internet module, and actually receiving the incoming
 * datagrams that are response sto our requests.
 */
static int s;


/* This routine pulls the loopback interface into existence, otherwise we are
 * unable to bind to the bootp client port because there are no active IP
 * addresses,
 */
static void sockets_get_loopback(void)
{
        struct ifreq req;
        di_ifdhcpreq *dif = (di_ifdhcpreq *) &req; /* Note - not the full thing! */

        (void) strncpy(dif->ifr_in.name, "lo0", IFNAMSIZ);
        (void) memset(&dif->ifr_in.sin, '\0', sizeof(dif->ifr_in.sin));
        dif->ifr_in.sin.sin_family = AF_INET;
#ifndef COMPAT_INET4
        dif->ifr_in.sin.sin_len = sizeof(dif->ifr_in.sin);
#endif
        dif->ifr_in.sin.sin_port = 0;
        inet_aton("127.0.0.1", &dif->ifr_in.sin.sin_addr);
        (void) socketioctl(s, SIOCSIFADDR, &req);
}

/* Creates a new datagram socket and binds it to the DHCP client port so that it
 * receives copies of any incoming datagrams on any interface.  This allows it
 * to bypass the Internet module.
 */
void sockets_init(void)
{
	struct sockaddr_in sin;

        s = socket(PF_INET, SOCK_DGRAM, 0);
        if (s == -1) {
                trace(("socket() failed -> errno %d (%s)\n", errno, _inet_err()));
                return;
        }

	(void) memset(&sin, '\0', sizeof(sin));
	sin.sin_family = AF_INET;
#ifndef COMPAT_INET4
	sin.sin_len = sizeof(sin);
#endif
	sin.sin_addr.s_addr = htonl(INADDR_ANY);
	sin.sin_port = htons(DHCP_client);

	sockets_get_loopback();

	if (bind(s, (struct sockaddr *) &sin, sizeof(sin)) < 0) {
	        /* Erk - unable to bind.  We have a problem - reset ourselves,
	         * although it probably won't do much good.  This is serious.
	         * Surely the Internet module must be broken if this fails?
	         */
                trace(("bind() failed -> errno %d (%s)\n", errno, _inet_err()));
	        sockets_discard();
	}
	else {
		/* Set taskwindow flag - for testing mainly, but it doesn't actually
		 * harm it having the bit set.  Request events when data is delivered
		 * to the socket, and ensure that it is using non-blocking I/O.  If
		 * events are not enabled, this module will not work as it relies on
		 * them to drive the DHCP processing engine.
		 */
	        int one = 1;

	        (void) ioctl(s, FIOSLEEPTW, &one);
	        (void) ioctl(s, FIOASYNC, &one);
	        (void) ioctl(s, FIONBIO, &one);
	}
}

void sockets_discard(void)
{
        if (s != -1) {
                (void) socketclose(s);
                s = -1;
        }
}

int sockets_data_arrived(int ns, void *private_word)
{
        static DHCP packet;
        int res;

        if (ns != s) {
                /* Not our socket - pass the event on */
                return 1;
        }

        /* Note.  The PRMs will harp on about re-enabling interrupts by calling
         * _kernel_irqs_on() at this point, and that it is safe because it is in
         * a callback already.  Unfortunately, that static DHCP packet up above
         * puts a spanner in the works.  IRQs cannot even be re-enabled once the
         * packet is copied into the dhcp_interface structure, because in the event
         * of multiple replies arriving "simultaneously", they are almost certainly
         * going to be destined for the same dhcp_interface (eg. multiple DHCPOFFER
         * messages).  So, basically, don't do it!
         */

	/* Drain socket ... no more events unless we do */
	while ((res = recv(s, &packet, sizeof(packet), 0)) > 0) {
	        if (res < offsetof(DHCP, options[8])) {
	                /* Not a valid DHCP packet - too short!
	                 * (Base message without options, plus 4 for cookie
	                 * sentinel, plus 3 for DHCP message type, plus OPTION_END).
	                 */
	                continue;
	        }
	        if (htonl(OPTIONS_COOKIE) != *(u_long *) packet.options) {
	                /* Magic cookie did not match */
	                continue;
	        }
	        if (res < sizeof(DHCP)) {
	                /* Not the maximum length we were expecting.  For
	                 * a little bit of security and safety, we'll try
	                 * to blat out the rest of the packet with OPTION_PAD
	                 * and put an OPTION_END in.
	                 */
	                size_t ores = res - offsetof(DHCP, options);
	                const size_t blank = sizeof(DHCP) - res;
	                (void) memset(&packet.options[ores], OPTION_PAD, blank);
	                /* Search back through any OPTION_PAD characters to the
	                 * last non-pad character ...
	                 */
	                while (ores > 4 && packet.options[ores-1] == OPTION_PAD) {
	                        --ores;
	                }
	                /* If the last non-pad character wasn't the end option,
	                 * then put one in to defend ourselves against rubbish.
	                 */
	                if (packet.options[ores-1] != OPTION_END) {
		                packet.options[ores] = OPTION_END;
	                }
	        }
	        (void) dhcp_deliver_incoming_packet(&packet, private_word);
	}

	/* Claim the event - it's our socket, nobody else should be interested.
	 * If they were, then it's tough because they should have bound their
	 * own datagram socket to the bootpc port, then they'd have got a copy
	 * of the packet too.
	 */
        return 0;
}

/* Sets an IP address type field on an interface - command indicates which types of
 * address - netmask (SIOCSIFNETMASK) or address (SIOCSIFADDR).  Any other calls
 * which use the sockaddr version of the ifr union may use this too.
 */
static int sockets_set_address(dhcp_interface *di, struct in_addr in, u_long command)
{
        struct sockaddr_in *const sin = &di->req.ifr_in.sin;

	sockets_ensure_init();

	(void) memset(sin, '\0', sizeof(*sin));
        sin->sin_family = AF_INET;
#ifndef COMPAT_INET4
        sin->sin_len = sizeof(*sin);
#endif
	sin->sin_port = 0;
	sin->sin_addr = in;

	return socketioctl(s, command, &di->req.ifr);
}

/* Unfortunately, the interface cannot use its bound IP address any longer because
 * it has expired.  Tell Internet to disable the interface immediately.
 */
int sockets_kill_interface(dhcp_interface *di)
{
        struct ifreq *ifr = &di->di_ifr;

	sockets_ensure_init();

	/* Disassociate address with interface */
	/* Ignore errors on this call - the machine's shafted anyway, so
	 * ignoring this isn't going to make any difference really.
	 */
	{
	        struct in_addr in;
	        in.s_addr = INADDR_ANY;

		(void) sockets_set_address(di, in, SIOCSIFADDR);
	}

	if (socketioctl(s, SIOCGIFFLAGS, ifr) < 0) {
	        /* Erk - an error - the interface has gone? Let's assume so */
	        return -1;
	}
	ifr->ifr_flags &= ~(IFF_UP|IFF_RUNNING);

	/* Finally, force the interface down.  Do this after setting the address
	 * as setting the address can affect the flags
	 */
	if (socketioctl(s, SIOCSIFFLAGS, ifr) < 0) {
	        /* Unable to table interface down - nasty.  Let's stick our
	         * heads in the sand and assume the interface died.
	         */
	        return -1;
	}

	return 0;
}

void sockets_transmit(dhcp_interface *di, int ioctl_flags)
{
	/* This is the function that causes packets to be sent.  It asks the
   	 * Internet module to do this on its behalf, because there are many
   	 * complex issues to consider, such as claiming frames in the driver,
   	 * interface manipulation etc.  Requires Internet 5.20 or later to
   	 * recognise the IOCTL command being used.  The IOCTL is provided
   	 * solely for this module's benefit.  This routine is the gateway to
   	 * the Internet module's DHCP interfaces.  The ifr_flags are used
   	 * to indicate what action the Internet module should be taking.
	 */
        trace(("sockets_transmit: Transmit (DHCP Message Type %d).\n",
        	dhcp_find_option(&di->di_dhcp, OPTION_DHCPMESSAGETYPE)[2]));

	sockets_ensure_init();
        di->req.ifr.ifr_flags = ioctl_flags;
        if (socketioctl(s, SIOCGWHOIAMD, &di->req) < 0) {
                trace(("sockets_transmit: Internet module error %d\n", errno));
                sockets_discard();
                sockets_ensure_init();
        }
}

/* This routine is called by the handler for SWI DHCP_Execute to get the Internet
 * module to set itself up for a BOOTP.  It won't get very far though, because when
 * it sends around the dynamic boot start service call, we're going to claim it.
 * Doing it this way lets Internet get into a vaguely sensible internal state first
 * and tricks it into revealing the DCI4 driver DIB that we need for hardware
 * address validation.  It also means that DHCP initiation is done through a
 * single call point (the service call handler).
 */
void sockets_trigger_internet_dhcp(const char *if_name)
{
        struct ifreq ifr;
        int res;

	trace(("sockets_trigger_internet_dhcp: poking Internet module\n"));
	sockets_ensure_init();
	(void) memset(&ifr, '\0', sizeof(ifr));
       	(void) strncpy(ifr.ifr_name, if_name, sizeof(ifr.ifr_name));
       	res = socketioctl(s, SIOCGWHOIAMB, &ifr);
       	if (res<0) {
                trace(("SIOCWHOIAMB -> error %d\n", errno));
        }
}

/* Called before using the socket to make sure we really did create it.  It may
 * have been the case that we tried to create it before the Internet module was
 * present, in which case creation would have failed.  Repeated failure to create
 * the datagram socket is not a feasible situation except in the absense of the
 * Internet module - which would be a rather serious problem in itself!
 */
void sockets_ensure_init(void)
{
        if (s == -1) {
                sockets_init();
        }
}
