/* > c.Menus
 *
 *  Paint: Arthur 2 sprite editor
 *   Menu handling
 *
 *  Author: A.P. Thompson
 *  Others:
 *     DAHE David Elworthy
 *     JAB  James Bye
 *     CDP  Christopher Partington (Cambridge Systems Design)
 *     TMD  Tim Dobson
 *
 *  DAHE, 28 Aug  89 - internationalisation
 *         1 Sept 89 - made menu divisions symbolic
 *         6 Sept 89 - enable nulls during dboxtcol
 *  JAB,   3 Oct  90 - Changed sprite creation stuff
 *  JAB,  26 Oct  90 - Gave all dboxes raw event handlers for
 *                     interactive help purposes
 *  JAB,  30 Oct  90 - Added interactive menu help
 *  JAB,  22 Oct  90 - Now auto opens sprite window on sprite creation
 *  JAB,  04 Feb  91 - Fixed bug where lanscape/portrait always = portrait on
 *                     start up
 *  JAB,  06 May  91 - Added 'Misc' entry to sprite menu
 *  JAB,  08 May  91 - Added 'Misc' entry to sprite filer menu
 *  CDP,  20 Feb  92
 *     Added FIX9544: part of fix of G-RO-9544 (large shear factor causes
 *     arithmetic exception). Checks flex requests. See also PSprite.c.
 *     Added FIX0770: fixes RP-0770 (adjust size smaller causes crash) by
 *     substantial changes to menus_ensure_size (flex de/allocator).
 *     Added FIXDELSPR: fixes deletion of sprites causing crash, a bug that
 *     only showed up when the flex routine was sorted out.
 *  CDP,  27 Feb  92
 *     Added FIX0553: fixes a bug similar to RP-0553 (summary window not
 *     updated on create sprite) but copy rather than create sprite.
 *  TMD,  11 Mar  92
 *     Added FIX1764: fixes copy sprite to same name not giving error
 *  TMD,  12 Mar  92
 *     Disallow zero for width or height in 'Adjust size'
 */

#include <assert.h>
#include <ctype.h>
#include <stddef.h>
#include <swis.h>
#include <signal.h>

#include "bbc.h"
#include "colourmenu.h"
#include "colourtran.h"
#include "dboxquery.h"
#include "dboxtcol.h"
#include "flex.h"
#include "help.h"
#include "magnify.h"
#include "msgtrans.h"
#include "saveas.h"
#include "visdelay.h"
#include "werr.h"
#include "wimpt.h"
#include "xfersend.h"

#include "m.h"
#include "ftrace.h"
#include "main.h"
#include "psprite.h"
#include "menus.h"
#include "sprwindow.h"
#include "toolwindow.h"
#include "tools.h"
#include "colours.h"
#include "MenuD.h"
#include "trace.h"

#undef  ColourPicker_UpdateDialogue
#define ColourPicker_UpdateDialogue 0x47704

#define MIN(x, y) ((x) < (y)? (x): (y))
#define MAX(x, y) ((x) > (y)? (x): (y))

#define COPY_N(s1, s2, n) (sprintf ((s1), "%.*s", (n), (s2)), s1)
  /*this is strncpy() really*/

#define XPDriver_DeclareFont (0x80155 | 1 << 17)

static int Do_Print (char *, void *);

/***********************
 * Static menu handles *
 ***********************/

static menu
  sprite_main_menu,
  sprite_save_menu,
  sprite_paint_menu,
  sprite_edit_menu,
  spritefile_main_menu,
  spritefile_misc_menu,
  filedisplay_menu,
  sprite_colour_menu,
  sprite_misc_menu;

static char Spritename [22];
static main_sprite *hit_sprite;

static int Row;
static int Column;

/* data for graphic entry of insert/delete */

static int insdel_pending = 0; /* to frig entry by click in sprite window */
static int insdel_rowfield;
static int insdel_colfield;
static int insdel_row;
static int insdel_col;
static main_sprite *insdel_sprite;
static toolwindow_block *insdel_tool;
static dbox insdel_d;

static char
  spritenamebuffer [13],
  rotatebuffer [13] = "0",
  scalebuffer [13] = "1",
  shearbuffer [13] = "0";

/*************************************
 *   Static variables for printing   *
 *************************************/

#define PRINT_INCHES_TO_72000 72000.0
#define PRINT_CM_TO_72000 (18144.0*72000.0/ (180<<8))
 /* above is at least the same as Draw uses */

print_positionstr
    menus_print_where = {0, 0}, menus_print_last_where = {0, 0};
static int print_copies = 1;
static int print_landscape = 1;
static main_scaling_block print_scale = {1, 1, 1, 1};
static double print_scalefactor = PRINT_INCHES_TO_72000;

/*************************************
 *   Generate sprite info dbox       *
 *************************************/
static char *yesno (int from)

{ ftracef0 ("yesno\n");
  return msgs_lookup (from? "PntG3": "PntG4");
}

static void display_sprite_info (main_sprite *sprite)

{ dbox d;
  psprite_info info;

  ftracef0 ("display_sprite_info\n");
  psprite_read_full_info (sprite, &info);

  if ((d = dbox_new ("spriteInfo")) != 0)
  { dbox_setfield   (d, d_Info_Name, info.name);
    if ((unsigned) info.mode < 256u)
    { dbox_setfield   (d, d_Info_Type, msgs_lookup ("PntWB"));
      dbox_setnumeric (d, d_Info_Mode, info.mode);
    }
    else
    { int T = (unsigned) info.mode >> 27;
      char *ncol [] =
          {"2", "4", "16", "256", "32k", "16M"};

      dbox_setfield (d, d_Info_Type, msgs_lookup ("PntWC"));
      dbox_setfield (d, d_Info_Mode, ncol [T - 1]);
    }

    dbox_setfield (d, d_Info_Mask, yesno (info.mask));

    if (info.width == -1)
      dbox_setfield (d, d_Info_Width, "?");
    else
      dbox_setnumeric (d, d_Info_Width, info.width);

    if (info.height == -1)
      dbox_setfield (d, d_Info_Height, "?");
    else
      dbox_setnumeric (d, d_Info_Height, info.height);

    dbox_setfield   (d, d_Info_Palette, yesno (info.palette));
    dbox_setnumeric (d, d_Info_Size,    info.size);

    dbox_show (d);
    dbox_raw_eventhandler (d, &help_dboxrawevents, (void *) "PntHA");
  }
}
/********************************
 * Generate info dbox           *
 ********************************/

static void show_info_box (void)

{ dbox d;

  ftracef0 ("show_info_box\n");
  if ((d = dbox_new ("progInfo"))!= 0)
  { dbox_setfield (d, d_Prog_Name,     msgs_lookup ("Pnt00"));
    dbox_setfield (d, d_Prog_Copy,     msgs_lookup ("PntM1"));
    dbox_setfield (d, d_Prog_WhatIsIt, msgs_lookup ("PntM2"));
    dbox_setfield (d, d_Prog_Version,  msgs_lookup ("PntID"));
    dbox_show (d);

    dbox_raw_eventhandler (d, &help_dboxrawevents, (void *) "PntH8");
  }
}

/********************************
 *  Force rethink on a file     *
 ********************************/

static void iconsize_has_changed (main_window *window)

{ main_file *file = &window->data->file;

  ftracef0 ("iconsize_has_changed\n");
  psprite_set_plot_info (file);

  window->data->file.lastwidth = 0; /*force screen update*/
  main_set_extent (window);
  main_force_redraw (window->handle);
}

void menus_file_has_changed (main_window *window)

{ main_file *file = &window->data->file;

  ftracef0 ("menus_file_has_changed\n");
  psprite_recalculate_offsets (file);
  iconsize_has_changed (window);
}

/****************************
 * Common create/copy code  *
 ****************************/

void menus_sprite_new (main_window *window, BOOL hack_palette)

{ main_file *file = &window->data->file;
  main_sprite **sprptr, *sprite;
  int o, offset = 0 /**/, spriteno;

  ftracef0 ("menus_sprite_new\n");
  /* find linked list end */
  for (sprptr = &file->sprites; *sprptr != NULL; sprptr = &(*sprptr)->link)
    ;

  /*Find the right offset and spriteno - they are actually used by
    psprite_new to get the number of colours.*/
  spriteno = 0;
  for (o = psprite_first (&file->spritearea); o != 0;
      o = psprite_next (&file->spritearea, o))
  { offset = o;
    spriteno++;
  }

  ftracef2 ("creating main_sprite for offset %d, spriteno %d\n",
      offset, spriteno);
  if ((sprite = *sprptr = psprite_new (offset, spriteno, file) /* at end */) == NULL)
    werr (FALSE, msgs_lookup ("PntEG"));

  menus_file_has_changed (window);   /* force recache of offsets */
  sprite->gcol = colours_count (sprite) - 1;
  sprite->gcol2 = 0;

  if (hack_palette) menus_hack_palette (sprite);
  psprite_set_colour (sprite);
  psprite_set_brush_translation (sprite);
}

/*************************************
 * Ensure spritearea large enough    *
 *************************************/
#if 1
#if FIX0770
/*
 * OK: this is what *I* think menus_ensure_size() is supposed to do.
 *
 * bytesneeded > 0: if not at least <bytesneeded> bytes free in sprite area,
 *                  extend it.
 * bytesneeded < 0: reduce size of sprite area by <bytesneeded> bytes. This
 *                  used to do this regardless but I have changed it so
 *                  that it never reduces it such that the free offset points
 *                  outside the area. This should fix many bugs.
 * bytesneeded = 0: reduce size of sprite area to exactly what is needed by
 *                  the contents of the area.
 *
 * Hence I expect an operation that changes the size of a sprite area to
 * do an menus_ensure_size( , 0) on completion to release the free space. This seems
 * to be what is done so was probably the intention.
 *
 * Christopher Partington  18-Feb-1992
 */
#endif
BOOL menus_ensure_size (sprite_area **sarea, int bytesneeded)

{ int bytesfree = (*sarea)->size - (*sarea)->freeoff;
#if FIX9544
  int newsize;
#endif

  ftracef1 ("menus_ensure_size of %d\n", bytesneeded);
  ftracef3("bytesfree = %d - %d = %d\n", (*sarea)->size, (*sarea)->freeoff,
                                         bytesfree);
  #if TRACE
    assert (bytesfree >= 0);
  #endif

  ftracef1 ("menus_ensure_size: %d bytes free\n", bytesfree);

  if (bytesneeded > 0 && bytesneeded <= bytesfree)
  { ftracef0 ("... enough space already - do nothing\n"); /*JRC*/
    return TRUE;
  }

  bytesneeded -= bytesfree;         /* amount needed */
  if (bytesneeded > 0)
    bytesneeded += 256;             /* and a little headroom */

  ftracef1 ("... do flex_extend of %d\n", bytesneeded);
#if FIX0770
  if (bytesneeded < 0)
  {
    ftracef1("shrinking area, change = %d bytes\n", bytesneeded);
    /* shrinking area - make sure that ok to do so */
    if ((*sarea)->size + bytesneeded < (*sarea)->freeoff)
    {
       bytesneeded = - ((*sarea)->size - (*sarea)->freeoff);
       ftracef1("...would be too much - change by %d instead\n", bytesneeded);
    }
  }
  if (bytesneeded == 0)
  {
    ftracef0("area is just the right size - no change\n");
    return TRUE;
  }
#endif

#if FIX9544
  newsize = flex_size((flex_ptr) sarea) + bytesneeded;
  /* check for overflow before calling flex */
#if TRACE
  if (newsize < 0)
     ftracef0("arithmetic overflow, so not enough memory\n");
#endif
  if (newsize < 0 || !flex_extend((flex_ptr) sarea, newsize))
#else
  if (!flex_extend ((flex_ptr) sarea,
      flex_size ((flex_ptr) sarea) + bytesneeded))
#endif
    return FALSE;

  (*sarea)->size += bytesneeded;
  ftracef1 ("menus_ensure_size: leaving area with %d bytes free\n",
      (*sarea)->size - (*sarea)->freeoff);
  return TRUE;
}
#else
int menus_ensure_size (sprite_area **sarea, int bytesneeded)

{ int bytesfree = (*sarea)->size - (*sarea)->freeoff;

  ftracef1 ("menus_ensure_size of %d\n", bytes_needed);
  if (bytesneeded < 0)
  { ftracef0 ("Asked to shrink negatively\n");
    bytesneeded = 0;
  }

  bytesneeded -= bytesfree;         /* amount needed */
  bytesneeded += 256;               /* and a little headroom */

  ftracef3 ("Extend sprite area from %d by %d (spare %d)\n",
      flex_size ((flex_ptr) sarea), bytesneeded, bytesfree);
  if (!flex_extend ((flex_ptr) sarea,
      flex_size ((flex_ptr) sarea) + bytesneeded))
  { main_NO_ROOM ("ensure size");
    return 0;
  }

  (*sarea)->size += bytesneeded;
  return 1;
}
#endif

/**********************************
 * Check for sprite existence     *
 **********************************/

BOOL menus_sprite_exists (sprite_area *sarea, char *name)

{ sprite_id sid;

  ftracef0 ("menus_sprite_exists\n");
  sid.s.name = name; sid.tag = sprite_id_name;
  if (!sprite_select (sarea, &sid))
  { werr (FALSE, msgs_lookup ("PntE6"), name);
    return TRUE;
  }

  return FALSE;
}

/************************************************
 * xfersend handlers for sprite and file saving *
 ************************************************/

static BOOL myxfersend (int filetype, char *name, int estsize,
    xfersend_saveproc p1, xfersend_sendproc p2, xfersend_printproc p3,
    void *handle)

{ wimp_w nullc = win_idle_event_claimer ();
  BOOL res;

  ftracef0 ("myxfersend\n");
  main_claim_idle ((wimp_w) -1);
#if (1)
  ftracef1 ("myxfersend: calling saveas (..., \"%s\", ...)\n", name);
  res = saveas (filetype, name, estsize, p1, p2, p3, handle);
#else
  res = xfersend (filetype, name, estsize, p1, p2, p3, handle);
#endif
  main_claim_idle (nullc);
  return res;
}

static int My_File_Is_Safe;
static int File_Saved;

static BOOL save_file_proc (char *filename, void *handle)

{ main_window *window = (main_window *) handle;
  os_error *error = NULL;

  ftracef1 ("save_file_proc %s\n", filename);

  visdelay_begin ();

  if ((error = sprite_area_save (window->data->file.spritearea,
      filename)) != NULL)
    goto finish;

  if (My_File_Is_Safe || xfersend_file_is_safe ())
  { main_set_title (window, filename);
    window->data->file.modified = 0;
    main_set_extent (window);
  }

  File_Saved = 1;

finish:
  visdelay_end ();

  return wimpt_complain (error) == NULL;
}

static BOOL save_sprite (char *filename, void *shandle)

{ main_sprite *sprite = (main_sprite *) shandle;
  sprite_header *spriteaddr = psprite_address (sprite);
  int spritesize = spriteaddr->next, handle = 0, hdr [3];
  os_regset reg_set;
  os_filestr file_str;
  os_gbpbstr gbpb_str;
  os_error *error;
  char *txt = NULL;

  ftracef1 ("save_sprite %s\n", filename);

  visdelay_begin ();

  /* Open file */
  reg_set.r [0] = 0x8C;
  reg_set.r [1] = (int) filename;
  if ((error = os_find (&reg_set)) != NULL)
  { txt = error->errmess;
    goto finish;
  }
  handle = reg_set.r [0];

  if (handle == 0)
  { /*In case the FileSwitch bug returns a 0 handle.*/
    txt = msgs_lookup ("PntE4");
    goto finish;;
  }

  hdr [0] = 1;               /* no of sprites */
  hdr [1] = 16;              /* offset to sprite */
  hdr [2] = spritesize + 16; /* offset to first free */

  /* GBPB the header */
  gbpb_str.action = 2;
  gbpb_str.file_handle = handle;

  gbpb_str.data_addr = hdr;
  gbpb_str.number = sizeof hdr;
  if ((error = os_gbpb (&gbpb_str)) != NULL)
  { txt = error->errmess;
    goto finish;
  }

  gbpb_str.data_addr = spriteaddr;
  gbpb_str.number = spritesize;
  if ((error = os_gbpb (&gbpb_str)) != NULL)
  { txt = error->errmess;
    goto finish;
  }

finish:
  if (handle != 0)
  { /* Close the file */
    os_error *error1;

    reg_set.r [0] = 0;
    reg_set.r [1] = handle;
    error1 = os_find (&reg_set);
    if (txt == NULL && error1 != NULL) txt = error1->errmess;

    /*Set the file to type "Sprite"*/
    file_str.action = 18;
    file_str.name = filename;
    file_str.loadaddr = SPRITE_FILE;
    error1 = os_file (&file_str);
    if (txt == NULL && error1 != NULL) txt = error1->errmess;
  }

  visdelay_end ();

  if (txt != NULL)
    werr (FALSE, txt, filename);

  return txt == NULL;
}

#if 0
static char vdu19bytes [] =
  { 0, 16,     1, 16,     2, 16,     3, 16,
    4, 16,     5, 16,     6, 16,     7, 16,
    8, 16,     9, 16,    10, 16,    11, 16,
   12, 16,    13, 16,    14, 16,    15, 16,
    0, 24,     1, 25,     2, 25,     3, 25 /*oops*/
  };
#endif

static void build_sprite_palette_file (main_sprite *sprite,
    char *palette)

{ int len, i;
  char *p = palette;
  os_error *error = NULL;

  static int *Palette = NULL;

  ftracef0 ("build_sprite_palette_file\n");
  if ((error = psprite_build_palette (sprite, &Palette)) != NULL)
    goto finish;

  len = psprite_palsize (sprite)/sizeof (int);

  for (i = 0; i < len; i++)
  { *p++ = 19;
    *p++ = i;
    *p++ = 16;
    *p++ = Palette [i] >> 8;
    *p++ = Palette [i] >> 16;
    *p++ = Palette [i] >> 24;
  }

  if (len == 16)
  { /*Append the current mouse and border colours, for historical reasons.*/
    wimp_palettestr palette_str;

    if ((error = wimp_readpalette (&palette_str)) != NULL)
      goto finish;
    for (i = 0; i < 4; i++)
    { *p++ = 19;
      *p++ = i;
      *p++ = i == 0? 24: 25;
      *p++ = palette_str.c [16 + i].bytes.red;
      *p++ = palette_str.c [16 + i].bytes.green;
      *p++ = palette_str.c [16 + i].bytes.blue;
  } }

finish:
  wimpt_noerr (error);
}

static BOOL save_sprite_palette (char *filename, void *shandle)

{ main_sprite *sprite = (main_sprite *) shandle;
  char palette [6*256];
  os_regset r;
  int len;
  BOOL saved;

  ftracef1 ("save_sprite_palette %s\n", filename);

  /*Work out how long this palette file is.*/
  len = 6*(psprite_palsize (sprite)/sizeof (int));
  if (len == 6*16) len += 6*4;

  build_sprite_palette_file (sprite, palette);
  r.r [0] = 10;
  r.r [1] = (int) filename;
  r.r [2] = 0xFED;
  r.r [4] = (int) &palette;
  r.r [5] = (int) &palette + len;

  visdelay_begin ();
  saved = wimpt_complain (os_swix (OS_File, &r)) == NULL;
  visdelay_end ();

  return saved;
}

static BOOL mysendbuf (char **buffer, int size, int *max, int fudge)

{ BOOL OK = TRUE;
  int done = 0;

  ftracef0 ("mysendbuf\n");
  while (done < size && OK)
  { int buffsize = size - done;

    if (*max < buffsize) buffsize = *max;
    OK = xfersend_sendbuf (*buffer + done + fudge, buffsize);
    done += buffsize;
  }

  return OK;
}

static BOOL buffer_file_proc (void *handle, int *max)

{ main_window *window = (main_window *)handle;
  sprite_area **sarea = &window->data->file.spritearea;

  ftracef1 ("buffer_file_proc %s\n", window->data->file.filename);
  return File_Saved = mysendbuf ((char **) sarea, (*sarea)->freeoff - 4,
      max, sizeof (int));
}

static BOOL print_file_proc (char *filename, void *handle)

{ main_sprite *sprite = ((main_window *) handle)->data->file.sprites;

  filename = filename; /*for Norcroft*/
  return sprite != NULL && menus_do_print (sprite)? xfersend_printPrinted:
      xfersend_printFailed;
}

static BOOL buffer_sprite (void *shandle, int *max)

{ main_sprite *sprite = (main_sprite *)shandle;
  int  hdr [3], i;
  char name [13];
  sprite_header *spriteaddr = psprite_address (sprite);
  int spritesize = spriteaddr->next;
  char *buffer;

  ftracef0 ("buffer_sprite\n");
  saveas_read_leafname_during_send (name, 13);
  ftracef1 ("sprite name is \"%.12s\"\n", name);

  if (strlen (name) == 0)
  { werr (FALSE, msgs_lookup ("PntE7"));
    return 0;
  }

  for (i = 0 ; i < 13 && name [i] != 0 ; i++) name [i] = tolower (name [i]);

  ftracef2 ("Buffering out sprite @ %x, size %d\n", spriteaddr, spritesize);
  hdr [0] = 1;       /* no of sprites */
  hdr [1] = 16;      /* offset to sprite */
  hdr [2] = spritesize + 16; /* offset to first free */

  buffer = (char *)hdr;
  if (!mysendbuf (&buffer, 12, max, 0)) return 0;
  if (!mysendbuf ((char **)&sprite->file->spritearea,
                 4, max, sprite->offset)) return 0;

  buffer = (char *) &name;
  if (!mysendbuf (&buffer, 12, max, 0)) return 0;

  return mysendbuf ((char **)&sprite->file->spritearea,
                   spritesize, max, sprite->offset+16);
}

static BOOL buffer_sprite_palette (void *shandle, int *max)

{ main_sprite *sprite = (main_sprite *)shandle;
  char palette [6*256], *pp = palette;
  int len;

  ftracef0 ("buffer_sprite_palette\n");

  /*Work out how long this palette is.*/
  len = 6*(psprite_palsize (sprite)/sizeof (int));
  if (len == 6*16) len += 6*4;

  build_sprite_palette_file (sprite, palette);
  return mysendbuf (&pp, len, max, 0);
}

void menus_save_sprite (main_sprite *sprite)

{ char name [NAME_LIMIT + 1];

  ftracef0 ("menus_save_sprite\n");
  (void) COPY_N (name, psprite_address (sprite)->name, NAME_LIMIT);
  ftracef1 ("sprite called \"%s\"\n", name);
  myxfersend (SPRITE_FILE, name,
      psprite_address (sprite)->next + sizeof (sprite_area),
      &save_sprite, &buffer_sprite,
      &Do_Print, /*Protocol now in xfersend(), immediate printing
          allowed. Was NULL. JRC 4 Apr 1992*/
      /*FIX G-RO-7139 JRC 16 Oct '91 Use new printer protocol - was
        &call_print_sprite*/
      sprite);
}

BOOL menus_save_file (main_window *window, int askfor_name)

{ char *name = window->data->file.filename;
  File_Saved = 0;

  ftracef0 ("menus_save_file\n");
  if (name == NULL)
  { name = msgs_lookup ("PntF1");
    askfor_name = TRUE; /*JRC 12 July 1991*/
  }

  if (askfor_name)
  { My_File_Is_Safe = FALSE;
    ftracef0 ("menus_save_file: myxfersend\n");
    myxfersend (SPRITE_FILE, name, window->data->file.spritearea->size,
        &save_file_proc, &buffer_file_proc,
        &print_file_proc, /*Protocol now in xfersend(), immediate printing
          allowed. Was NULL. JRC 4 Apr 1992*/
        /*FIX G-RO-7139 JRC 16 Oct '91 Use new printer protocol - was
          print_spritefile*/
        window);
  }
  else
  { My_File_Is_Safe = TRUE;
    save_file_proc (name, window);
  }

  return File_Saved;
}

/*******************************
 *  Add/delete columns/rows    *
 *******************************/

static void Change_Size (sprite_area **sarea, sprite_id *sid,
    main_sprite *sprite, int number, BOOL rows, int at)

{ BOOL insert = number > 0, hourglass = FALSE;
  main_sprite_window *sprw;
  psprite_info info;
  char *msg = NULL;
  os_error *error;

  ftracef3 ("Change_Size: number %d, rows %s, at %d\n",
      number, WHETHER (rows), at);
  sprwindow_remove_wastage (sprite);

  psprite_read_full_info (sprite, &info);
  ftracef2 ("BEFORE: sprite is %d columns by %d rows\n",
      info.width, info.height);
  if (at < 0) at = 0;      /* can menu outside the sprite */
  if (rows)
    {if (at > info.height) at = info.height;}
  else
    {if (at > info.width) at = info.width;}

  ftracef4 ("Insert %d %s%s at %d\n", number, rows? "row": "column",
      number == 1? "": "s", at);

  if (insert)
  { int newsize;

    newsize = psprite_size (info.width + (!rows? number: 0),
        info.height + (rows? number: 0), info.mode, info.mask,
        !info.palette? 0: !info.truepalette? 1: 2);
    ftracef2 ("newsize %d, oldsize %d\n", newsize, info.size);
    if (!menus_ensure_size (sarea, newsize - info.size))
    { msg = msgs_lookup ("PntEG");
      goto finish;
  } }
  else
  { /* Deleting - find the maximum number or rows or columns that can go */
    int max;

    max = (rows? info.height: info.width) - at;

    number = -number;
    if (number > max) number = max;
  }
  if (number == 0) goto finish;

  visdelay_begin ();
  hourglass = TRUE;

  ftracef3 ("sprite_change_size: rows %s, at %d, number %d\n",
      WHETHER (rows), at, insert? number: -number);
  if ((error = sprite_change_size (*sarea, sid, rows, at,
      insert? number: -number)) != NULL)
  { msg = error->errmess;
    goto finish;
  }

finish:
  if (hourglass) visdelay_end ();

  #if TRACE
    psprite_read_full_info (sprite, &info);
    ftracef2 ("AFTER: sprite is %d columns by %d rows\n",
        info.width, info.height);
  #endif

  sprwindow_invalidate (sprite);
  psprite_set_icon_scale (sprite);
  psprite_recalculate_offsets (sprite->file);

  for (sprw = sprite->windows; sprw != NULL; sprw = sprw->link)
    sprwindow_set_work_extent (sprw->window, TRUE);

  if (msg != NULL) werr (FALSE, msg);
}

/***************************************
 * Graphical display of insert/delete  *
 ***************************************/

void menus_restart_tool (void)

{ main_window *window;
  main_sprite *sprite;

  ftracef0 ("menus_restart_tool\n");
  for (window = main_windows; window != NULL; window = window->link)
  if (window->tag == main_window_is_file)
    for (sprite = window->data->file.sprites; sprite != NULL;
        sprite=sprite->link)
      sprite->needsnull = 1;
}

static void stop_insdel_graphics (void)

{ ftracef0 ("stop_insdel_graphics\n");
  toolwindow_current_tool->stop_action (insdel_sprite);
  toolwindow_current_tool = insdel_tool;

  /* now restart the tool if necessary */
  if (toolwindow_current_tool == &tools_textpaint ||
      toolwindow_current_tool == &tools_brushpaint)
    menus_restart_tool ();
}

static void insdel_EOR (void)

{ main_sprite_window *sprw;

  ftracef0 ("insdel_EOR\n");

  for (sprw = insdel_sprite->windows; sprw != NULL; sprw = sprw->link)
  { int xmul = sprw->blobsize.scale_xmul*insdel_sprite->mode.scale_xmul;
    int xdiv = sprw->blobsize.scale_xdiv;
    int ymul = sprw->blobsize.scale_ymul*insdel_sprite->mode.scale_ymul;
    int ydiv = sprw->blobsize.scale_ydiv;
    int more, x0, y0;
    wimp_redrawstr rds;
    wimp_winfo curr;

    curr.w = sprw->window->handle;
    wimpt_noerr (wimp_get_wind_info (&curr));
    rds.w = sprw->window->handle;
    rds.box = main_big_extent;
    wimpt_noerr (wimp_update_wind (&rds, &more));

    x0 = rds.box.x0 - rds.scx;
    y0 = rds.box.y1 - rds.scy + curr.info.ex.y0;

    while (more)
    { os_swi2 (OS_SetColour, 3, -1);
    #if 0 /*replace the following to avoid checking for full-palette modes.
        J R C 22nd Feb 1994*/
      bbc_gcol (3, 127);
      bbc_tint (2, 3); /*27 August 1991*/
    #endif

      if (insdel_rowfield != -1)
      { ftracef0 ("insdel_EOR row\n");
        bbc_rectanglefill (MAX (x0, 0), y0 + Row*ymul/ydiv,
            0x1FFF, (insdel_row - Row)*ymul/ydiv);
      }

      if (insdel_colfield != -1)
      { ftracef0 ("insdel_EOR column\n");
        bbc_rectanglefill (x0 + Column*xmul/xdiv, MAX (y0, 0),
            (insdel_col - Column)*xmul/xdiv, 0x1FFF);
      }

      wimpt_noerr (wimp_get_rectangle (&rds, &more));
    }
  }
}

static void insdeltool_click (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("insdeltool_click\n");

  if ((mpos->bbits & 4) && window->data->sprite.sprite == insdel_sprite)
                           /* only SELECT in appropriate window */
  { int hit = (insdel_pending>>30)&3;
    sprite_area **sarea = &insdel_sprite->file->spritearea;
    sprite_id sid;
    char name [NAME_LIMIT + 1];

    ftracef0 ("perform insdeltool_click\n");

    insdel_pending &= 0x3FFFFFFF;
    sid.tag = sprite_id_name;
    sid.s.name = COPY_N (name, psprite_address (insdel_sprite)->name,
        NAME_LIMIT); /*doesn't flex*/

    if (hit > 1) insdel_pending = -insdel_pending;
    Change_Size (sarea, &sid, insdel_sprite, insdel_pending, hit & 1,
        hit & 1? MIN (Row, insdel_row): MIN (Column, insdel_col));
    menus_ensure_size (sarea, 0);
  }
}

static void insdeltool_null (main_window *window, wimp_mousestr *mpos)

{ ftracef0 ("insdeltool_null\n");
  if (mpos->w == window->handle)
  { int x, y;
    main_scaling_block *ms = &window->data->sprite.sprite->mode;

    tools_mouse_to_extent_coords (window, mpos, &x, &y);
    x /= ms->scale_xmul;
    y /= ms->scale_ymul;
    ftracef2 ("extent coords are (%d, %d)\n", x, y);

    if (x == Column) x = Column + 1;
    if (y == Row)    y = Row    + 1;

    if (x != insdel_col || y != insdel_row)
    { insdel_EOR ();       /* remove old data */
      insdel_col = x; insdel_row = y;

      if (insdel_rowfield != -1)
        dbox_setnumeric (insdel_d, 0, abs (insdel_row - Row));
      if (insdel_colfield != -1)
        dbox_setnumeric (insdel_d, 0, abs (insdel_col - Column));

      insdel_EOR ();       /* EOR on the new */
    }
  }
}

static void insdeltool_redraw (main_window *window, int x0, int y0)

{ main_sprite_window *sprw = &window->data->sprite;

  ftracef0 ("insdeltool_redraw\n");

  if (sprw->sprite->needsnull)
  { int xmul = sprw->blobsize.scale_xmul*insdel_sprite->mode.scale_xmul,
      xdiv = sprw->blobsize.scale_xdiv,
      ymul = sprw->blobsize.scale_ymul*insdel_sprite->mode.scale_ymul,
      ydiv = sprw->blobsize.scale_ydiv;

    os_swi2 (OS_SetColour, 3, -1);
  #if 0 /*replace the following to avoid checking for full-palette modes.
      J R C 22nd Feb 1994*/
    bbc_gcol (3, 127);
    bbc_tint (2, 3); /*27 August 1991*/
  #endif

    if (insdel_rowfield != -1)
    { ftracef0 ("insdeltool_redraw: row\n");
      bbc_rectanglefill (MAX (x0, 0), y0 + Row*ymul/ydiv,
          0x1FFF, (insdel_row - Row)*ymul/ydiv);
    }

    if (insdel_colfield != -1)
    { ftracef0 ("insdeltool_redraw: column\n");
      bbc_rectanglefill (x0 + Column*xmul/xdiv, MAX (y0, 0),
          (insdel_col - Column)*xmul/xdiv, 0x1FFF);
    }
  }
}

static void insdeltool_stop (main_sprite *sprite)

{ ftracef0 ("insdeltool_stop\n");
  if (sprite->needsnull)
  { sprwindow_release_idle_events (sprite);
    insdel_EOR ();        /* get rid of on-screen guff */
  }
}

static toolwindow_block insdel_toolblock =
 { &insdeltool_click,
   &insdeltool_null,
   &insdeltool_redraw,
   &insdeltool_stop,
   NULL
 };

static void start_insdel_graphics (main_sprite *sprite, int rowfield,
    int colfield)

{ main_window *window;

  ftracef0 ("start_insdel_graphics\n");
  insdel_rowfield = rowfield;
  insdel_colfield = colfield;
  insdel_sprite   = sprite;

  if (toolwindow_current_tool != &insdel_toolblock)
      insdel_tool = toolwindow_current_tool;
  spencer (else ftracef0 ("!"))

  insdel_row = Row + 1; insdel_col = Column + 1;

  /* stop the tool in all sprite windows */
  for (window = main_windows; window != NULL; window = window->link)
    if (window->tag == main_window_is_sprite)
      toolwindow_current_tool->stop_action (window->data->sprite.sprite);

  toolwindow_current_tool = &insdel_toolblock;
  sprite->needsnull = 1;

  insdel_EOR ();        /* EOR current data on */
}

void menus_insdel_frig (void)

{ ftracef0 ("menus_insdel_frig\n");
  if (insdel_pending) stop_insdel_graphics ();
  insdel_pending = 0;
}

static void showmag (void *handle)

{ main_sprite_window *sprite = (main_sprite_window *) handle;
  int m, d;
  wimp_wstate wstate;

  ftracef0 ("showmsg\n");
  wimpt_noerr (wimp_get_wind_state (sprite->window->handle, &wstate));
  m = sprite->blobsize.scale_ymul;
  d = sprite->blobsize.scale_ydiv;

  main_current_options.zoom.mul =
      sprite->blobsize.scale_ymul = sprite->blobsize.scale_xmul;
  main_current_options.zoom.div =
      sprite->blobsize.scale_ydiv = sprite->blobsize.scale_xdiv;
  sprwindow_set_work_extent (sprite->window, FALSE);

  /* now scale window size too */
  spencer (ftracef (__FILE__, __LINE__, "psize %d %d %d %d\n",
                      wstate.o.box.x0, wstate.o.box.x1,
                      wstate.o.box.y0, wstate.o.box.y1))
  wstate.o.box.x1 = wstate.o.box.x0 +
     (wstate.o.box.x1-wstate.o.box.x0)*d*main_current_options.zoom.mul/
     (m*main_current_options.zoom.div);
  wstate.o.box.y0 = wstate.o.box.y1 -
     (wstate.o.box.y1-wstate.o.box.y0)*d*main_current_options.zoom.mul/
     (m*main_current_options.zoom.div);
  spencer (ftracef (__FILE__, __LINE__, "nsize %d %d %d %d\n",
                      wstate.o.box.x0, wstate.o.box.x1,
                      wstate.o.box.y0, wstate.o.box.y1))

  /* and keep the same point at the top left */
  wstate.o.x = wstate.o.x*d*main_current_options.zoom.mul/
      (m*main_current_options.zoom.div);
  wstate.o.y = wstate.o.y*d*main_current_options.zoom.mul/
      (m*main_current_options.zoom.div);

  wimpt_noerr (wimp_open_wind (&wstate.o));
}


/**************************
 * Palette handling       *
 **************************/

static void sprite_palette_has_changed (main_sprite *sprite)

{ ftracef0 ("sprite_palette_has_changed\n");
  psprite_set_colour (sprite);
  psprite_set_brush_translation (sprite);

  sprwindow_redisplay (sprite, NULL);
  /*if (sprite->colourhandle != 0)
    main_force_redraw (sprite->colourhandle);*/

  if (sprite->colourdialogue == 0) colours_set_extent (sprite);
  main_set_modified (sprite->file);
}

void menus_set_palette (main_sprite *sprite, int entries, int *palette)

  /*Note: this routine assumes the palette is the right length for the
    sprite.*/

{ BOOL create = palette != NULL;
  char *start, *end;
  int old_size, new_size, diff;
  sprite_area **sarea = &sprite->file->spritearea;
  sprite_header *header;

  ftracef1 ("%s palette\n", create? "Create": "Delete");

  header = psprite_address (sprite);
  old_size = MIN (header->image, header->mask) - sizeof (sprite_header);
  new_size = create? 2*sizeof (int)*entries: 0;
  diff = new_size - old_size;

  ftracef3 ("Sprite \"%.12s\" had %d bytes of palette; wants %d bytes\n",
      header->name, old_size, new_size);

  /*Adjust the area to insert/delete 'diff' bytes at the right
    place for this sprite. The "right place" is the start of the image or the
    start of the mask, whichever comes first.*/
  if (diff > 0 && !menus_ensure_size (sarea, diff))
  { werr (FALSE, msgs_lookup ("PntEG"));
    return;
  }

  header = psprite_address (sprite); /*flex moved?*/
  start  = (char *) header + MIN (header->image, header->mask);
  end    = (char *) *sarea + (*sarea)->freeoff /*end of whole area*/;
  memmove (start + diff, start, end - start);

  if (create)
  { /*Now copy the new palette into the space just made.*/
    int i, *e = (int *) ((char *) header + sizeof (sprite_header));

    for (i = 0; i < entries; i++)
    { *e = *(e + 1) = palette [i];
      e += 2;
  } }

  /*Fix up every pointer in the world.*/
  header->image     += diff;
  header->mask      += diff;
  header->next      += diff;
  (*sarea)->freeoff += diff;

  sprwindow_invalidate (sprite);
  menus_ensure_size (sarea, 0);
  psprite_recalculate_offsets (sprite->file);
  sprite_palette_has_changed (sprite);
}

/*********************************
 *                               *
 *  Sprite window menu handler.  *
 *                               *
 *********************************/

static void Apply_Colour (dboxtcol_colour col, void *handle)

{ main_sprite *sprite = (main_sprite *) handle;
  sprite_header *spr = psprite_address (sprite);
  int *colour = &(&spr->mode + 1) [2*sprite->gcol];

  ftracef0 ("Apply_Colour\n");
  /*Update source of colour.*/
  *colour = *(colour + 1) = col;

  sprite_palette_has_changed (sprite);
}

void menus_sprite_handler (void *handle, char *hit)

{ main_window *window = (main_window *) handle;
  main_sprite_window *sprw = &window->data->sprite;
  main_sprite *sprite = sprw->sprite;

  ftracef0 ("menus_sprite_handler\n");
  ftracef5 ("menu hit is {%d, %d, %d, %d, %d}\n",
      hit [0], hit [1], hit [2], hit [3], hit [4]);

  switch (hit [0])
  { case s_Misc:
      switch (hit [1])
      { case s_Misc_AppInfo:
          if (hit [2]) show_info_box ();
        break;

        case s_Misc_SpriteInfo:
          if (hit [2]) display_sprite_info (sprite);
        break;

        case s_Misc_Print:
          /*FIX G-RO-9923 JRC 15 Oct '91 Print on choosing Print.*/
          menus_print_sprite (sprite, /*ask?*/ hit [2] != 0);
        break;
      }
    break;

    case s_Save:
      switch (hit [1])
      { case s_Save_Sprite:
          ftracef1 ("Sprite save: hit [2] == %d\n", hit [2]);
          if (hit [2] != 0)
          { /*If there is only one sprite, offer to save the whole sprite
              file. This acts as a counterpart to the code that opens a
              sprite window if there is only one sprite. J R C 7th Feb 1995*/
            if (sprite->file->spritearea->number == 1)
              menus_save_file (sprite->file->window, TRUE);
            else
              menus_save_sprite (sprite);
          }
        break;

        case s_Save_Palette:
          if (hit [2] != 0)
          { int size = psprite_palsize (sprite);

            ftracef0 ("Sprite palette save\n");
            myxfersend (0xFED, msgs_lookup ("PntG5"), size,
                &save_sprite_palette, &buffer_sprite_palette, 0, sprite);
          }
        break;
      }
    break;

    case s_Paint:
      switch (hit [1])
      { case s_Paint_ECF: /*rewritten. JRC 4 June 1991*/
        { BOOL open;
          dbox d;

          ftracef0 ("Select E C F\n");
          if ((d = dbox_new ("selectECF")) != NULL)
          { dbox_setfield (d, d_ECF_Sprite, "");

            dbox_raw_eventhandler (d, &help_dboxrawevents,
                (void *) "PntHC");
            dbox_show (d);

            open = TRUE;
            while (open)
            { wimp_i i = dbox_fillin (d);

              ftracef1 ("Got event on icon %d\n", i);

              switch (i)
              { case d_ECF_Ok:
                { char name [13];
                  int ECF, i;
                  main_sprite *ECFsprite;

                  /*Get the selected icon number (0, ..., 3).*/
                  ECF = -1;
                  for (i = 0; i < 4; i++)
                    if (dbox_getnumeric (d, d_ECF_1 + i))
                    { ECF = i;
                      break;
                    }

                  if (ECF != -1)
                  { dbox_getfield (d, d_ECF_Sprite, name, 13);

                    if ((ECFsprite = psprite_find (name, "PntE5b")) != NULL)
                      psprite_setup_ecf (sprite, ECF, ECFsprite);
                  }

                  open = dbox_persist ();
                }
                break;

                case dbox_CLOSE:
                  open = FALSE;
                break;
              }
            }
            dbox_dispose (&d);
          }
        }
        break;

        case s_Paint_Sel_Col:
        { int nc = colours_count (sprite);
          sprite_id sid;
          char name [NAME_LIMIT + 1];
          sprite_maskstate mask;

          ftracef2 ("pick pixel colour %d %d\n", Column, Row);

          sid.tag = sprite_id_name;
          sid.s.name = COPY_N (name, psprite_address (sprite)->name,
              NAME_LIMIT); /*doesn't flex*/

          /*Force a redraw of the colours window, if necessary.*/
          if (sprite->colourhandle != NULL && sprite->colourdialogue == NULL)
            main_force_redraw (sprite->colourhandle);

          if
          ( psprite_hasmask (sprite) &&
            ( wimpt_noerr (sprite_readmask (sprite->file->spritearea, &sid,
                  Column, Row, &mask)),
              mask == sprite_masktransparent
          ) )
          { ftracef0 ("pixel = transparent\n");
            sprite->gcol = nc;
          }
          else
          { sprite_colour colour;

            wimpt_noerr (main_read_pixel (sprite->file->spritearea,
                &sid, Column, Row, &colour));
            ftracef5 ("read pixel (col %d, row %d) c %d, t %d, nc 0x%X\n",
                Column, Row, colour.colour, colour.tint, nc);

            if (nc != 256 || psprite_hastruecolpal (sprite))
              sprite->gcol = colour.colour;
            else
              sprite->gcol =
                  colours_gcol_ttab [colours_gcol_ttab [colours_gcol_ttab
                  [colour.colour]]] << 2 | colour.tint >> 6;
          }

          ftracef1 ("select colour 0x%X\n", sprite->gcol);

          if (sprite->colourdialogue != 0)
          { colourpicker_dialogue dialogue;

            if (sprite->gcol == nc)
            { dialogue.flags = colourpicker_DIALOGUE_TRANSPARENT;
              ftracef0 ("ColourPicker_UpdateDialogue: setting transparent\n");
              os_swi3 (ColourPicker_UpdateDialogue,
                  colourpicker_UPDATE_TRANSPARENT, sprite->colourdialogue,
                  &dialogue);
            }
            else
            { dialogue.colour = colours_entry (nc, sprite->gcol);

              ftracef1 ("ColourPicker_UpdateDialogue: setting RGB colour to 0x%X\n",
                  dialogue.colour);
              os_swi3 (ColourPicker_UpdateDialogue,
                  colourpicker_UPDATE_COLOUR, sprite->colourdialogue,
                  &dialogue);
        } } }
        break;

        case s_Paint_Show_Col:
          ftracef0 ("show colour menu\n");
          colours_create_window (sprite);
          main_current_options.colours.show_colours = TRUE;
        break;

        case s_Paint_Show_Tool:
          ftracef0 ("show tool menu\n");
          toolwindow_display (/*at pointer?*/ TRUE);
          main_current_options.tools.show_tools = TRUE;
        break;

        case s_Paint_Small:
          ftracef0 ("Toggle colour size\n");
          sprite->coloursize =
              sprite->coloursize == colours_SIZE? colours_SIZE/2: colours_SIZE;

          main_current_options.colours.small_colours =
              sprite->coloursize != colours_SIZE;

          colours_set_extent (sprite);
        break;

        case s_Paint_Edit_Pal:
          if (hit [2])
          { sprite_header *spr = psprite_address (sprite);
            int *colour = &(&spr->mode + 1) [sprite->gcol*2];
            wimp_emask emask;

            ftracef0 ("Edit colour\n");
            /* Enable nulls, so slider drags work */
            event_setmask ((wimp_emask) (((emask = event_getmask ()) & ~wimp_EMNULL)));

            dboxtcol (colour, /*allow transparent?*/ FALSE,
                msgs_lookup ("PntW8"), &Apply_Colour, (void *) sprite);

            event_setmask (emask);
          }
        break;
      }
    break;

    case s_Edit:
    { sprite_area **sarea = &sprite->file->spritearea;
      sprite_id sid;
      char name [NAME_LIMIT + 1];

      sid.tag = sprite_id_name;
      sid.s.name = COPY_N (name, psprite_address (sprite)->name, NAME_LIMIT);
        /*doesn't flex*/

      switch (hit [1])
      { case s_Edit_FlipV:
        case s_Edit_FlipH :
          ftracef1 ("flip %c\n", hit [1] == s_Edit_FlipV ? 'x' : 'y');
          wimpt_complain
             ((hit [1] == s_Edit_FlipV? sprite_flip_x: sprite_flip_y)
             (*sarea, &sid));
        break;

        case s_Edit_Rotate:
          ftracef0 ("Rotate\n");
          if (hit [2])
          { int angle, n;

            if (sscanf (rotatebuffer, "%d%n", &angle, &n) == 1 &&
                n == strlen (rotatebuffer))
              psprite_rotate (sprite, angle);
          }
        break;

        case s_Edit_Scale_X:
          ftracef0 ("Scale X\n");
          if (hit [2])
          { double factor = 1.0;
            int n;

            ftracef1 ("menus_sprite_handler: scalebuffer: %s\n",
                scalebuffer);
            if (sscanf (scalebuffer, "%lg%n", &factor, &n) == 1 &&
                n == strlen (scalebuffer) &&
                factor > 0.0)
              psprite_scale (sprite, factor, 1.0);
          }
        break;

        case s_Edit_Scale_Y:
          ftracef0 ("Scale Y\n");
          if (hit [2])
          { double factor = 1.0;
            int n;

            ftracef1 ("menus_sprite_handler: scalebuffer: %s\n",
                scalebuffer);
            if (sscanf (scalebuffer, "%lg%n", &factor, &n) == 1 &&
                n == strlen (scalebuffer) &&
                factor > 0.0)
              psprite_scale (sprite, 1.0, factor);
          }
        break;

        case s_Edit_Shear:
          ftracef0 ("Shear\n");
          if (hit [2])
          { double factor = 1.0;
            int n;

            if (sscanf (shearbuffer, "%lg%n", &factor, &n) == 1 &&
                n == strlen (shearbuffer))
              psprite_shear (sprite, factor);
          }
        break;

        case s_Edit_Adjust:
        { BOOL open;
          int rows, columns;
          psprite_info info;
          dbox d;

          ftracef0 ("adjust size");
          if ((d = dbox_new ("spritesize"))!=0)
          { psprite_read_full_info (sprite, &info);
            rows    = info.height;
            columns = info.width;

            dbox_setnumeric (d, d_Adjust_Cols, columns);
            dbox_setnumeric (d, d_Adjust_Rows, rows);

            dbox_show (d);
            dbox_raw_eventhandler (d, &help_dboxrawevents,
                (void *) "PntHD");

            open = TRUE;
            while (open)
            { wimp_i i = dbox_fillin (d);
              wimp_mousestr mouse_str;
              BOOL adjust;

              ftracef1 ("Got event on icon %d\n", i);

              columns = dbox_getnumeric (d, d_Adjust_Cols);
              rows    = dbox_getnumeric (d, d_Adjust_Rows);
              wimpt_noerr (wimp_get_point_info (&mouse_str));
              adjust = (mouse_str.bbits & 1) != 0;

              switch (i)
              { case d_Adjust_Ok:
                { int width_by, height_by, size_by;

                  if (rows == 0 || columns == 0)
                    werr (FALSE, msgs_lookup ("PntEA"));
                  else
                  { sprwindow_remove_wastage (sprite);

                    /*Adjust the smaller dimension first: then you don't run
                      out of store in an intermediate step.*/

                    psprite_read_full_info (sprite, &info);

                    height_by = rows - info.height;
                    width_by  = columns - info.width;
                    size_by   = psprite_size (columns, rows, info.mode,
                        info.mask, 0) - psprite_size (info.width,
                        info.height, info.mode, info.mask, 0);

                    /*Make sure there's enough space for the new sprite.*/
                    if (!menus_ensure_size (sarea, size_by))
                      werr (FALSE, msgs_lookup ("PntEG"));
                    else
                    { if (height_by < width_by)
                      { /*adjust no of rows*/
                        if (height_by != 0)
                          Change_Size (sarea, &sid, sprite, height_by, 1,
                              height_by > 0? info.height: rows);

                        /*adjust no of columns*/
                        if (width_by != 0)
                          Change_Size (sarea, &sid, sprite, width_by, 0,
                              width_by > 0? info.width: columns);
                      }
                      else
                      { /*adjust no of columns*/
                        if (width_by != 0)
                          Change_Size (sarea, &sid, sprite, width_by, 0,
                              width_by > 0? info.width: columns);

                        /*adjust no of rows*/
                        if (height_by != 0)
                          Change_Size (sarea, &sid, sprite, height_by, 1,
                              height_by > 0? info.height: rows);
                      }

                      menus_ensure_size (sarea, 0);
                      psprite_recalculate_offsets (sprite->file);
                      sprwindow_redisplay (sprite, NULL);
                    }
                  }
                  open = dbox_persist ();
                }
                break;

                case d_Adjust_RowDown:
                  adjust = !adjust;
                /*fall through*/

                case d_Adjust_RowUp:
                  if (adjust)
                  { if (rows > 1)
                      dbox_setnumeric (d, d_Adjust_Rows, rows - 1);
                  }
                  else
                    dbox_setnumeric (d, d_Adjust_Rows, rows + 1);
                break;

                case d_Adjust_ColDown:
                  adjust = !adjust;
                /*fall through*/

                case d_Adjust_ColUp:
                  if (adjust)
                  { if (columns > 1)
                      dbox_setnumeric (d, d_Adjust_Cols, columns - 1);
                  }
                  else
                    dbox_setnumeric (d, d_Adjust_Cols, columns + 1);
                break;

                case dbox_CLOSE:
                  open = FALSE;
                break;
              }
            }
            dbox_dispose (&d);
          }
        }
        break;

        case s_Edit_InsCol:
        case s_Edit_InsRow:
        case s_Edit_DelCol:
        case s_Edit_DelRow:
        { BOOL col = hit [1] == s_Edit_InsCol || hit [1] == s_Edit_DelCol,
            insert = hit [1] == s_Edit_InsCol || hit [1] == s_Edit_InsRow;
          int number = 0 /*for Norcroft*/;

          #if 0 /*dbox on menu hit is against style guide*/
          if (FALSE)
          { ftracef0 ("hit on menu - insert/delete 1 row/column\n");

            number     = 1;
            insdel_row = Row;
            insdel_col = Column;
          }
          else /* Hit is on writable menu */
          #endif

          ftracef0 ("submenu hit - start graphics and show dbox\n");
          menus_insdel_frig ();
          insdel_pending = 0;
          start_insdel_graphics (sprite, col? -1: 1, !col? -1: 1);

          if (hit [2])
          { wimp_i i;

            if ((insdel_d = dbox_new ("number")) == 0)
              return;
            ftracef0 ("dbox made\n");

            dbox_setnumeric (insdel_d, 0, 1);
            dbox_show (insdel_d);
            i = dbox_fillin (insdel_d);
            insdel_pending = dbox_getnumeric (insdel_d, 0);

            if (i != dbox_CLOSE)
            { ftracef0 ("Non-close menu event\n");
              number = insdel_pending;
              insdel_pending = 0;
            }
            else
            { int flags = insert? (col? 4: 5): (col? 6: 7);

              ftracef0 ("Close menu event\n");
              insdel_pending |= flags << 30; /*top two bits are flags*/
              number = 0x80000000;
              insert = col = FALSE; /* A fiddle */
            }
            dbox_dispose (&insdel_d);
          }

          if (!insdel_pending) stop_insdel_graphics ();

          if (hit [2])
          { if (!insert) number = -number;
            ftracef1 ("number %d\n", number);
            if (number != 0x80000000)
              Change_Size (sarea, &sid, sprite, number, !col,
                  !col? MIN (Row, insdel_row): MIN (Column, insdel_col));
            menus_ensure_size (sarea, 0);
        } }
        break;

        case s_Edit_Mask:
        { int create = !psprite_hasmask (sprite);
          char *msg = NULL;
          os_error *error;

          if (sprite == tools_brushsprite_ptr && toolwindow_current_tool == &tools_brushpaint)
            toolwindow_stop_all_tools ();

          ftracef1 ("%s mask\n", create? "Create" : "Delete");
          if (create)
            if (!menus_ensure_size (sarea, psprite_address (sprite)->next))
            { msg = msgs_lookup ("PntEG");
              goto masked;
            }

          if ((error = (create? sprite_create_mask: sprite_remove_mask)
              (*sarea, &sid)) != NULL)
          { msg = error->errmess;
            goto masked;
          }

          if (sprite->colourdialogue == 0) colours_set_extent (sprite);
          menus_ensure_size (sarea, 0);
          sprwindow_invalidate (sprite);

          if (sprite == tools_brushsprite_ptr && toolwindow_current_tool == &tools_brushpaint)
            menus_restart_tool ();

          if (sprite->colourdialogue != 0)
          { colourpicker_dialogue dialogue;

            if (!create)
            { /*Unset transparent if it is currently selected.*/
              dialogue.flags = 0;
              ftracef0 ("ColourPicker_UpdateDialogue: setting "
                  "'transparent'\n");
              if ((error = os_swix3 (ColourPicker_UpdateDialogue,
                  colourpicker_UPDATE_TRANSPARENT, sprite->colourdialogue,
                  &dialogue)) != NULL)
              { msg = error->errmess;
                goto masked;
              }
            }

            /*If creating a mask, set to offering transparent, otherwise to
                not.*/
            dialogue.flags = create?
                colourpicker_DIALOGUE_OFFERS_TRANSPARENT: 0;
            ftracef0 ("ColourPicker_UpdateDialogue: setting 'offers transparent'\n");
            if ((error = os_swix3 (ColourPicker_UpdateDialogue,
                colourpicker_UPDATE_OFFERS_TRANSPARENT,
                sprite->colourdialogue, &dialogue)) != NULL)
            { msg = error->errmess;
              goto masked;
          } }

          /*Fix MED-xxx J R C 21st Jul 1994*/
          if (!create)
          { int nc = colours_count (sprite);

            if (sprite->gcol  == nc) sprite->gcol--;
            if (sprite->gcol2 == nc) sprite->gcol2--;
          }

        masked:
          if (msg != NULL) werr (FALSE, msg);
        }
        break;

        case s_Edit_Palette:
        { int lb_bpp =
              bbc_modevar (psprite_address (sprite)->mode, bbc_Log2BPP);

          menus_set_palette (sprite, ENTRIES (lb_bpp),
              psprite_haspal (sprite)? NULL:
              psprite_std_palettes [sprite->file->use_current_palette? 0: 1]
                [lb_bpp]);
        }
        break;
      }
      psprite_recalculate_offsets (sprite->file);
      sprwindow_redisplay (sprite, NULL);
    }
    break;

    case s_Zoom:
      if (hit [1])
        magnify_select (&sprw->blobsize.scale_xmul,
            &sprw->blobsize.scale_xdiv, 999, 999, showmag, sprw);
    break;

    case s_Grid:
      switch (hit [1])
      { case 0:
          /*Toggle grid*/
          sprw->gridcol =
              sprw->gridcol == 255? main_current_options.grid.colour: 255;

          main_current_options.grid.show = sprw->gridcol != 255;
        break;

        default:
          sprw->gridcol = hit [1] - 1;

          main_current_options.grid.show = TRUE;
          main_current_options.grid.colour = hit [1] - 1;
        break;
      }
      main_force_redraw (window->handle);
    break;
  }
}

static void print_setcorner (dbox d)

{ char realbuf [100];

  ftracef0 ("print_setcorner\n");
  main_set_printer_data (); /*Update menus_print_where if pagesize changed*/
  sprintf (realbuf, "%.2f", menus_print_where.dx/print_scalefactor);
  dbox_setfield (d, d_Print_XCorner, realbuf);
  sprintf (realbuf, "%.2f", menus_print_where.dy/print_scalefactor);
  dbox_setfield (d, d_Print_YCorner, realbuf);
}

static void print_readcorner (dbox d)

{ double t, max;
  char realbuf [100];
  int n;

  ftracef0 ("print_readcorner\n");
  max = 0x7FFFFFFF / print_scalefactor;

  dbox_getfield (d, d_Print_XCorner, realbuf, 100);
  ftracef2 ("readcorner x '%s', %g\n", realbuf, print_scalefactor);
  if (sscanf (realbuf, "%lf%n", &t, &n) == 1 &&
      n == strlen (realbuf))
  { if (t>max) t = max;
    if (t<-max) t = -max;
    menus_print_where.dx = (int) (t*print_scalefactor);
  }

  dbox_getfield (d, d_Print_YCorner, realbuf, 100);
  ftracef2 ("readcorner x '%s', %g\n", realbuf, print_scalefactor);
  if (sscanf (realbuf, "%lf%n", &t, &n) == 1 &&
      n == strlen (realbuf))
  { if (t>max) t = max;
    if (t<-max) t = -max;
    menus_print_where.dy = (int) (t*print_scalefactor);
  }

  ftracef2 ("read corner %d %d\n",
      menus_print_where.dx, menus_print_where.dy);
}


/**********************************************
 * Print Sprite DBox stuff                    *
 **********************************************/

/*FIX G-RO-7139 JRC 17 Oct '91 menus_do_print() split into two parts:
  queue_print() displays the dialogue box (if necessary) and then queues the
  file for later printing by calling xfersend_print(). menus_do_print() actually
  prints the file using options saved at the end of the file.*/

/*FIX G-RO-7139 JRC 17 Oct '91 New function queue_print() queues a file for
  later printing.*/

static int Do_Print(char *filename, void *handle)

{ filename = filename; /*for Norcroft*/
  return menus_do_print (handle)? xfersend_printPrinted: xfersend_printFailed;
}

static BOOL queue_print (dbox d, main_sprite *sprite)

{ psprite_info info;

  ftracef1 ("queue_print, sprite 1 called \"%.12s\"\n",
      psprite_address (sprite)->name);

  if (d != NULL)
  { print_copies           = dbox_getnumeric (d, d_Print_Copies);
    print_landscape        = dbox_getnumeric (d, d_Print_Landscape);
    print_scale.scale_xmul = dbox_getnumeric (d, d_Print_XMul);
    print_scale.scale_xdiv = dbox_getnumeric (d, d_Print_XDiv);
    print_scale.scale_ymul = dbox_getnumeric (d, d_Print_YMul);
    print_scale.scale_ydiv = dbox_getnumeric (d, d_Print_YDiv);
    print_readcorner (d);
  }

  ftracef2 ("landscape: %s; unit: %s\n", WHETHER (print_landscape),
      print_scalefactor == PRINT_INCHES_TO_72000? "inches": "cm");

  psprite_read_full_info (sprite, &info);

  if (!xfersend_print (SPRITE_FILE, info.name, info.size,
      /*saver*/ &save_sprite, /*sender - no point yet*/ NULL,
      /*printer*/ &Do_Print, /*handle*/ sprite))
    return FALSE;

  return TRUE;
}

/*FIX G-RO-7139 JRC 17 Oct '91 New function menus_do_print() prints a given
  file - called when the printer manager sends Message_PrintTypeOdd.*/

BOOL menus_do_print (main_sprite *sprite)

{ BOOL more, done_begin = FALSE, done_select_job = FALSE,
    done_translate = FALSE;
  print_box pbox;
  print_transmatstr transform;
  os_error *err;
  int id, job = 0, oldjob;
  print_pagesizestr psize;
  psprite_info info;
  print_infostr infostr;
  print_box ssize;
  main_ttab *old_ttab = sprite->transtab;
  char *txt = NULL;
  os_regset reg_set;

  ftracef1 ("menus_do_print, sprite 1 called \"%.12s\"\n",
      psprite_address (sprite)->name);

  if (old_ttab->table != 0)
    ftracef3 ("initially, table is '%.4s', 0x%X, '%.4s'\n",
        (char *) &((int *) old_ttab->table) [0],
        ((int *) old_ttab->table) [1],
        (char *) &((int *) old_ttab->table) [2]);

  if ((err = print_info (&infostr)) != NULL)
  { txt = msgs_lookup ("PntE9");
    goto finish;
  }

  if ((err = print_pagesize (&psize)) != NULL)
  { txt = err->errmess;
    goto finish;
  }

  if (print_landscape)
  { transform.xx = 0;
    transform.xy = 0x10000;
    transform.yx = -0x10000;
    transform.yy = 0; /* -90deg rotation, no scaling */
  }
  else
  { transform.xx = 0x10000;
    transform.xy = 0;
    transform.yx = 0;
    transform.yy = 0x10000; /* no rotation, no scaling */
  }
  ftracef2 ("landscape: %s; unit: %s\n", WHETHER (print_landscape),
      print_scalefactor == PRINT_INCHES_TO_72000? "inches": "cm");

  visdelay_begin ();
  done_begin = TRUE;

  /*Open file*/
  reg_set.r [0] = 0x8C;
  reg_set.r [1] = (int) "printer:";
  if ((err = os_find (&reg_set)) != NULL)
  { txt = err->errmess;
    goto finish;
  }
  job = reg_set.r [0];

  if (job == 0)
  { /*In case the FileSwitch bug returns a 0 handle.*/
    ftracef0 ("File 'printer:' not opened sucessfully\n");
    txt = msgs_lookup ("PntWA");
    goto finish;
  }

  if (print_scale.scale_xmul == 0) print_scale.scale_xmul = 1;
  if (print_scale.scale_ymul == 0) print_scale.scale_ymul = 1;
  if (print_scale.scale_xdiv == 0) print_scale.scale_xdiv = 1;
  if (print_scale.scale_ydiv == 0) print_scale.scale_ydiv = 1;

  psprite_read_full_info (sprite, &info);
  ssize.x0 = 0;
  ssize.x1 = info.width*sprite->mode.scale_xmul*print_scale.scale_xmul/
      print_scale.scale_xdiv;
  ssize.y0 = 0;
  ssize.y1 = info.height*sprite->mode.scale_ymul*print_scale.scale_ymul/
      print_scale.scale_ydiv; /* sprite size in OS units*/

  if ((err = print_selectjob (job, NULL, &oldjob)) != NULL)
  { txt = err->errmess;
    goto finish;
  }
  done_select_job = TRUE;

  if ((infostr.features & 1 << 29) != 0)
  { ftracef0 ("printer driver supports PDriver_DeclareFont\n");
    /*No fonts in use. This is a sprite editor!*/
    if ((err = os_swix3 (PDriver_DeclareFont, 0, NULL, 0)) != NULL)
    { txt = err->errmess;
      goto finish;
  } }

  if (print_landscape) menus_print_where.dx += ssize.y1*72000/180;

  ftracef2 ("menus_print_where.dx = %d, menus_print_where.dy = %d\n",
      menus_print_where.dx, menus_print_where.dy);
  if ((err = print_giverectangle (1, &ssize, &transform, &menus_print_where,
      -1)) != NULL)
  { txt = err->errmess;
    goto finish;
  }

  if (print_landscape) menus_print_where.dx -= ssize.y1*72000/180;

  ftracef0 ("drawing page\n");
  if ((err = print_drawpage (print_copies, 0, NULL, &pbox, &more, &id)) !=
      NULL)
  { txt = err->errmess;
    goto finish;
  }

  /*Now generate translation table. Can't use psprite_ttab_for_sprite(),
    because it might not call ColourTrans.*/
  /*J R C 10th Jan 1994 It does now! So use it!!*/
  /*J R C 28th Jan 1994 Now it doesn't again, we use the part of it that
    does.*/
  if ((sprite->transtab = psprite_ttab_new (sprite, -1, (int *) -1)) == NULL)
  { txt = msgs_lookup ("PntEG");
    goto finish;
  }
  done_translate = TRUE;

  while (more)
  { int ID;

    if ((err = psprite_plot_scaled (0, 0, sprite, &print_scale, 0)) != NULL)
    { txt = err->errmess;
      goto finish;
    }

    if ((err = print_getrectangle (&pbox, &more, &ID)) != NULL)
    { txt = err->errmess;
      goto finish;
  } }

finish:
  if (done_translate)
  { ftracef0 ("calling psprite_ttab_delete\n");
    psprite_ttab_delete (sprite->transtab);
  }
  sprite->transtab = old_ttab;

  if (done_select_job)
  { os_error *err1;

    ftracef1 ("calling %s\n", txt == NULL? "print_endjob": "print_abortjob");
    err1 = txt == NULL? print_endjob (job): print_abortjob (job);
    if (txt == NULL && err1 != NULL) txt = err1->errmess;

    ftracef0 ("calling print_selectjob\n");
    err1 = print_selectjob (oldjob, NULL, &oldjob);
    if (txt == NULL && err1 != NULL) txt = err1->errmess;
  }

  if (job != 0)
  { /*close the printer stream*/
    os_error *err1;

    reg_set.r [0] = 0;
    reg_set.r [1] = job;
    ftracef0 ("calling os_find\n");
    err1 = os_find (&reg_set);
    if (txt == NULL && err1 != NULL) txt = err1->errmess;
  }

  if (done_begin)
  { ftracef0 ("calling visdelay_end\n");
    visdelay_end ();
  }

  /* Now it's safe to generate the error at last! (if we've had one) */
  if (txt != NULL)
  { ftracef1 ("menus_do_print got error \"%s\"\n", txt);
    werr (FALSE, txt);
  }
  else
    ftracef0 ("menus_do_print got no error\n");

  return txt == NULL;
}

static BOOL print_box_events (dbox d, void *event, void *h)

{ wimp_mousestr m;

  ftracef0 ("print_box_events\n");
  h = h;
  switch (((wimp_eventstr *) event)->e)
  { case wimp_EBUT:
      wimp_get_point_info (&m);
      if (m.i == d_Print_Landscape || m.i == d_Print_Portrait ||
          m.i == d_Print_Inches    || m.i == d_Print_Cm)
      { int other =
            m.i == d_Print_Landscape? d_Print_Portrait:
            m.i == d_Print_Portrait?  d_Print_Landscape:
            m.i == d_Print_Inches?    d_Print_Cm:    d_Print_Inches;
        dbox_setnumeric (d, m.i,   1);
        dbox_setnumeric (d, other, 0);

        if (m.i == d_Print_Inches || m.i == d_Print_Cm)
        { print_readcorner (d);
          print_scalefactor =
              m.i == d_Print_Inches? PRINT_INCHES_TO_72000: PRINT_CM_TO_72000;
          print_setcorner (d);
        }
        else
          print_landscape = m.i == d_Print_Landscape;

        return TRUE;
      }
    break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
      if (((wimp_eventstr *) event)->data.msg.hdr.action ==
          wimp_MHELPREQUEST)
      { ftracef0 ("Help request for print window\n");
        main_help_message ("PntHB", (wimp_eventstr *) event);
        return TRUE;
      }
    break;
  }

  return FALSE;
}

void menus_print_sprite (main_sprite *sprite, BOOL ask)

{ print_infostr infostr;
  os_error  *noprinter;

  ftracef0 ("menus_print_sprite\n");

  noprinter = print_info (&infostr);
  if (ask)
  { dbox d;

    if ((d = dbox_new ("Printing")) != 0)
    { BOOL open;

      dbox_setfield (d, d_Print_Printer,
          noprinter? msgs_lookup ("PntW9"): infostr.description);
      dbox_setnumeric (d, d_Print_Copies,    print_copies);
      dbox_setnumeric (d, d_Print_Portrait, !print_landscape);
      dbox_setnumeric (d, d_Print_Landscape, print_landscape);
      dbox_setnumeric (d, d_Print_XMul,      print_scale.scale_xmul);
      dbox_setnumeric (d, d_Print_XDiv,      print_scale.scale_xdiv);
      dbox_setnumeric (d, d_Print_YMul,      print_scale.scale_ymul);
      dbox_setnumeric (d, d_Print_YDiv,      print_scale.scale_ydiv);
      dbox_setnumeric (d, d_Print_Inches,
                      print_scalefactor == PRINT_INCHES_TO_72000);
      dbox_setnumeric (d, d_Print_Cm,
                      print_scalefactor == PRINT_CM_TO_72000);
      print_setcorner (d);

      dbox_raw_eventhandler (d, &print_box_events, (void *) sprite);
      dbox_show (d);
      open = TRUE;

      while (open)
      { wimp_i i = dbox_fillin (d);

        switch (i)
        { case d_Print_Print:
            /*FIX G-RO-7139 JRC 17 Oct '91 Call queue_print() instead of
               menus_do_print().*/
            (void) queue_print (d, sprite);
            open = dbox_persist ();
          break;

          case dbox_CLOSE:
            open = FALSE;
          break;
      } }
      dbox_dispose (&d);
  } }
  else
    /*FIX G-RO-7139 JRC 17 Oct '91 Call queue_print() instead of
      menus_do_print().*/
    (void) queue_print (NULL, sprite);
}

void menus_hack_palette (main_sprite *sprite)

{ sprite_header *s = psprite_address (sprite);

  ftracef1 ("menus_hack_palette for \"%.12s\"\n", s->name);
  if (bbc_modevar (s->mode, bbc_Log2BPP) != 3)
              /* dont hack 256 colour ones */
  { int *palstart = &s->mode + 1,
      *palend = (int *) ((char *) s + s->image);

    for (; palstart < palend; palstart++)
    { int t = *palstart & 0xF0F0F000;

      ftracef2 ("was 0x%.8X now 0x%.8X\n",
          *palstart, t | ((t >> 4) & 0xF0F0F00));
      *palstart = t | ((t >> 4) & 0xF0F0F00);
} } }

/***************************************************************************
 *                                                                         *
 *  Sprite file window menu handler.                                       *
 *                                                                         *
 ***************************************************************************/

static BOOL sprite_file_info_events (dbox d, void *event, void *handle )

{ wimp_eventstr *e;

  ftracef0 ("sprite_file_info_events\n");
  handle = handle;
  d      =      d;
  e = (wimp_eventstr *) event;
  if (e->e == wimp_ESEND || e->e == wimp_ESENDWANTACK)
  { if (e->data.msg.hdr.action == wimp_MHELPREQUEST)
    { ftracef0 ("Help request for sprite file info window\n");;
      main_help_message ("PntH9", e);
      return TRUE;
    }
  }
  return FALSE;
}


void menus_file_handler (void *handle, char *hit)

{ main_window *window = (main_window *) handle;

  ftracef0 ("menus_file_handler\n");
  switch (hit [0])
  { case m_Misc:
      switch (hit [1])
      { case m_Misc_Info:
          if (hit [2]) show_info_box ();
        break;

        case m_Misc_File:
          if (hit [2])
          { dbox d;
            sprite_area *sarea = window->data->file.spritearea;

            ftracef0 ("Misc about file\n");
            if ((d = dbox_new ("fileInfo"))!=0)
            { dbox_setfield (d, d_File_Name,
                  window->data->file.filename == NULL?
                  msgs_lookup ("PntF4"): window->data->file.filename);
              dbox_setnumeric (d, d_File_Number, sarea->number);
              dbox_setnumeric (d, d_File_Size, sarea->size);
              dbox_setfield (d, d_File_Mod,
                  yesno (window->data->file.modified));
              dbox_show (d);
              dbox_raw_eventhandler (d, sprite_file_info_events, NULL);
          } }
        break;
      }
    break;

    case m_Save:
      ftracef0 ("File save\n");
      if (hit [1] != 0)
        /*at the dialogue box proper*/
        menus_save_file (window, TRUE);
      else
        /*Click on the menu entry*/
        menus_save_file (window, FALSE);
    break;

    case m_Create:
      if (hit [1]) psprite_create_show (window, -1, "");
    break;

    case m_Sprite:
      if (hit_sprite != NULL)
        switch (hit [1])
        { case m_Sprite_Delete:
          { sprite_area *sarea = hit_sprite->file->spritearea;
#if FIXDELSPR
            main_file *spritefile = hit_sprite->file;
#endif
            sprite_id sid;
            char name [NAME_LIMIT + 1];

            sid.tag = sprite_id_name; /*doesn't flex*/
            sid.s.name = COPY_N (name, psprite_address (hit_sprite)->name,
                NAME_LIMIT);

            ftracef0 ("Edit delete\n");

            /*The next two lines used to be reversed, but it could give a
                fatal error. So do it this way*/
            wimpt_complain (sprite_delete (sarea, &sid));
#if FIXDELSPR
            menus_ensure_size(&spritefile->spritearea,0);
#endif
            psprite_delete (hit_sprite);
            ftracef0("do menus_file_has_changed\n");
            menus_file_has_changed (window);
            ftracef0("do menus_ensure_size(,0)\n");
#if !FIXDELSPR
            menus_ensure_size (&hit_sprite->file->spritearea, 0);
#endif
          }
        break;

        case m_Sprite_Copy:
        case m_Sprite_Rename:
          if (hit [2])
          { sprite_area **sarea = &window->data->file.spritearea;
            sprite_id sid;
            char name [NAME_LIMIT + 1];

            if (strlen (spritenamebuffer) == 0)
            { werr (FALSE, msgs_lookup ("PntE7"));
              break;
            }

            if (hit[1] == m_Sprite_Copy)
              /*Copy*/
              if (menus_sprite_exists (*sarea, spritenamebuffer))
                break;

            sid.tag = sprite_id_name; /*doesn't flex*/
            sid.s.name = COPY_N (name, psprite_address (hit_sprite)->name,
                NAME_LIMIT);

            if (hit [1] == m_Sprite_Copy)
            { /*Copy*/
              char *msg = NULL;
              os_error *error;

              if (!menus_ensure_size (sarea, psprite_address (hit_sprite)->next))
              { msg = msgs_lookup ("PntEG");
                goto copied;
              }

              /*psprite_drop_translation (&hit_sprite->transtab);
                  Don't beleive this. J R C 20th Jul 1994*/
              if ((error = sprite_copy (hit_sprite->file->spritearea,
                  &sid, spritenamebuffer)) != NULL)
              { msg = error->errmess;
                goto copied;
              }

              menus_sprite_new (window, /*hack palette?*/ FALSE);
              /* force summary window to be updated */
              window->data->file.lastwidth = 0;
              main_set_extent (window);

            copied:
              if (msg != NULL) werr (FALSE, msg);
            }
            else
            { /*Rename*/
              if (wimpt_complain (sprite_rename
                  (hit_sprite->file->spritearea, &sid, spritenamebuffer)) !=
                  NULL)
                break;

              menus_file_has_changed (window);
              sprwindow_set_window_titles (hit_sprite);

              /* rename must reset the titles of all the windows open on
                the sprite */
              if (hit_sprite->colourdialogue != NULL)
              { char new_title [80];
                colourpicker_dialogue dialogue;

                dialogue.title = new_title;
                sprintf (new_title, msgs_lookup ("PntW7"), spritenamebuffer);
                ftracef0 ("ColourPicker_UpdateDialogue: setting new title");
                os_swix3 (ColourPicker_UpdateDialogue,
                    colourpicker_UPDATE_TITLE, hit_sprite->colourdialogue,
                    &dialogue);
              }
              else if (hit_sprite->colourhandle != NULL)
              { wimp_winfo winfo;
                wimp_redrawstr redraw_str;
                wimp_wstate wstate;

                winfo.w = hit_sprite->colourhandle;
                wimpt_noerr (wimp_get_wind_info (&winfo));

                sprintf (winfo.info.title.indirecttext.buffer,
                    msgs_lookup ("PntW7"), spritenamebuffer);

                /*Force redraw of the title bar.*/
                wimpt_noerr (wimp_get_wind_state
                    (hit_sprite->colourhandle, &wstate));

                redraw_str.w = hit_sprite->colourhandle;
                wimpt_noerr (wimp_getwindowoutline (&redraw_str));

                redraw_str.w = -1;
                redraw_str.box.y0 = wstate.o.box.y1;
                wimpt_noerr (wimp_force_redraw (&redraw_str));
          } } }
        break;

        case m_Sprite_Save:
          ftracef1 ("File sprite save %x\n", hit_sprite);
          if (hit [2])
            menus_save_sprite (hit_sprite);
        break;

        case m_Sprite_Info:
          ftracef1 ("hit_sprite @ %x\n", hit_sprite);
          if (hit [2])
            display_sprite_info (hit_sprite);
        break;

        case m_Sprite_Print:
          /*FIX G-RO-9923 JRC 15 Oct '91 Print on choosing Print.*/
          menus_print_sprite (hit_sprite, /*ask?*/ hit [2] != 0);
        break;
      }
    break;

    case m_Display:
      switch (hit [1])
      { case m_Display_Name:
          ftracef0 ("Display format icons\n");
          window->data->file.fullinfo = 0;
          main_current_options.display.full_info = FALSE;

          /*force the redraw to change*/
          window->data->file.lastwidth = 0;
          main_force_redraw (window->handle);
        break;

        case m_Display_Full:
        { wimp_winfo curr;

          ftracef0 ("Display format info\n");
          window->data->file.fullinfo = 1;
          main_current_options.display.full_info = TRUE;

          /*Change window width to allow one full item, if it is less.*/
          curr.w = window->handle;
          wimpt_noerr (wimp_get_wind_info (&curr));

          ftracef2 ("current width is %d; need %d\n",
              curr.info.box.x1 - curr.info.box.x0,
              main_FILER_FullInfoWidth);
          if (curr.info.box.x1 - curr.info.box.x0 <
              main_FILER_FullInfoWidth)
          { curr.info.box.x1 = curr.info.box.x0 + main_FILER_FullInfoWidth;
            wimpt_noerr (wimp_open_wind ((wimp_openstr *) &curr));

            /*force the redraw to change*/
            window->data->file.lastwidth = 0;
            main_force_redraw (window->handle);
          }
        }
        break;

        case m_Display_UseDT:
          ftracef0 ("Toggle palette flag\n");
          { main_sprite *sprite;
            main_file *file = &window->data->file;
            file->use_current_palette = !file->use_current_palette;

            psprite_set_colour_info (file);

            if (tools_brushsprite_ptr != NULL &&
                tools_brushsprite_ptr->file == file)
            { psprite_free_brush_blocks ();
              psprite_set_brush_colour_translations ();
            }
            else
              psprite_set_brush_translations (file);

            for (sprite = file->sprites; sprite != NULL;
                sprite = sprite->link)
            { sprwindow_redisplay (sprite, NULL);
              if (sprite->colourhandle != 0 && sprite->colourdialogue == 0)
                main_force_redraw (sprite->colourhandle);
            }

            main_current_options.display.use_desktop_colours =
                file->use_current_palette;
          }
        break;

        default:
          spencer (ftracef (__FILE__, __LINE__, "Display menu %d\n", hit [1]))
        break;
      }
      iconsize_has_changed (window);
    break;
  }
}

/***************************************************************************
 *                                                                         *
 *  Icon menu handler.                                                     *
 *                                                                         *
 ***************************************************************************/

int menus_files_modified (void)

{ int modified = 0;
  main_window *w;

  ftracef0 ("menus_files_modified\n");
  for (w = main_windows; w != 0; w = w->link)
    if (w->tag == main_window_is_file &&
        w->data->file.modified) modified++;
      return modified;
}

int menus_quit_okayed (int modified)

{ char mess [256];

  ftracef0 ("menus_quit_okayed\n");
  sprintf (mess, modified == 1? msgs_lookup ("PntF5"):
      msgs_lookup ("PntF6"), modified);
  return dboxquery_quit (mess) == dboxquery_quit_DISCARD;
}

void menus_icon_proc (void *handle, char *hit)

{ ftracef0 ("menus_icon_proc\n");
  handle = handle;

  switch (hit [0])
  { case i_Info:
      if (hit [1]) show_info_box ();
    break;

    case i_GetScreen:
      ftracef0 ("Grabbing snapshot\n");;
      main_snapshot_show ();
    break;

    case i_Quit:
      if (menus_files_modified () == 0 ||
          menus_quit_okayed (menus_files_modified ()))
      { while (main_windows->link != NULL)
          main_window_delete (main_windows);
        ftracef1 ("Icon exit %d\n", win_activeno ());
        while (win_activeno () > 0)
          win_activedec ();
        m_SUMMARY ();
      }
    break;
  }
}

/*********************************************
 *                                           *
 *  Return updated spritefile menu structure *
 *                                           *
 *********************************************/

static void hack_entry (menu menyoo, int entryno, char *name)

{ int TextWidth = main_FILER_TextWidth;
  wimp_menuhdr *header = (wimp_menuhdr *) menu_syshandle (menyoo);
  wimp_menuitem *entry = (wimp_menuitem *) (header + 1) + entryno - 1;

  ftracef1 ("hack_entry: name '%s'\n", name);

 if (strlen (name) > 10)
     TextWidth = TextWidth - 4;

 header->width = (strlen (name)+1) * (TextWidth);
 if (header->width < (TextWidth)*10)
     header->width = (TextWidth) * 10;

 entry->data.indirecttext.buffer = name;
 entry->data.indirecttext.bufflen = 1;
 entry->data.indirecttext.validstring = NULL;
 entry->iconflags = (wimp_iconflags) (entry->iconflags | wimp_INDIRECT);
}

menu menus_file_maker (void *handle)

{ main_file *file = &((main_window *) handle)->data->file;
  int len;
  char term [2];

  ftracef0 ("spritefile_menu_maker\n");
  if (!event_is_menu_being_recreated ())
  { wimp_mousestr mouse;

    wimpt_noerr (wimp_get_point_info (&mouse));
    hit_sprite = main_pick_sprite ((main_window *) handle, &mouse);

    ftracef1 ("hit_sprite set to %x\n", hit_sprite);
  }
  else
  { main_sprite *sprite;

    for (sprite = file->sprites; sprite != NULL && sprite != hit_sprite;
        sprite = sprite->link);
    hit_sprite = sprite;   /* set to same or zero if sprite gone */
  }

  strcpy (Spritename, msgs_lookup ("PntG1"));
  len = strlen (Spritename);
  term [0] = Spritename [len - 1], term [1] = '\0';
  Spritename [len - 1] = '\0';
  if (hit_sprite != NULL)
  { char *nameptr = psprite_address (hit_sprite)->name;
    int i;

    for (i = 0; i < 12 && nameptr [i] > ' '; i++)
      spritenamebuffer [i] = nameptr [i];
    spritenamebuffer [i] = '\0';
  }
  else
    strcpy (spritenamebuffer, "");

  strcat (Spritename, spritenamebuffer);
  strcat (Spritename, term);
  hack_entry (spritefile_main_menu, m_Sprite, Spritename);

  menu_setflags (spritefile_main_menu, m_Sprite, 0, hit_sprite == NULL);

  menu_setflags (filedisplay_menu, m_Display_Name, !file->fullinfo, 0);
  menu_setflags (filedisplay_menu, m_Display_Full,  file->fullinfo, 0);
  menu_setflags (filedisplay_menu, m_Display_UseDT,
      file->use_current_palette, 0);

  help_register_handler (&help_simplehandler, (void *) "FILER");

  return spritefile_main_menu;
}

/*********************************************
 *                                           *
 *  Return updated sprite menu structure     *
 *                                           *
 *********************************************/

menu menus_sprite_maker (void *handle)

{ main_window *window = (main_window *) handle;
  main_sprite_window *sprw = &window->data->sprite;
  BOOL read_only = sprw->read_only;
  main_sprite *sprite = sprw->sprite;
  int i, no_colours = colours_count (sprite);

  ftracef0 ("menus_sprite_maker\n");

  if (!event_is_menu_being_recreated ())
  { wimp_mousestr mouse;

    wimpt_noerr (wimp_get_point_info (&mouse));
    tools_mouse_to_pixelpos (window, &mouse, &Column, &Row);
    ftracef4 ("row %d, column %d, width %d, height %d\n", Row, Column,
        psprite_address (sprite)->width + 1,
        psprite_address (sprite)->height + 1);
  }

  menu_setflags (sprite_paint_menu, s_Paint_ECF,
      /*tick?*/ FALSE, /*grey?*/ read_only || no_colours > 256);
      /*only allow ECF's to be defined for shallow sprites - a colour picker
          allows no way of selecting them for deep sprites. J R C 9th Feb
          1995*/
  menu_setflags (sprite_paint_menu, s_Paint_Sel_Col,
      /*tick?*/ FALSE, /*grey?*/ read_only);

  menu_setflags (sprite_edit_menu, s_Edit_FlipV,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_FlipH,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Rotate,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Scale_X,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Scale_Y,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Shear,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Adjust,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_InsCol,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_InsRow,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_DelCol,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_DelRow,
      /*tick?*/ FALSE, /*grey?*/ read_only);
  menu_setflags (sprite_edit_menu, s_Edit_Mask,
      /*tick?*/ psprite_hasmask (sprite), /*grey?*/ FALSE);
  menu_setflags (sprite_edit_menu, s_Edit_Palette,
      /*tick?*/ psprite_haspal (sprite),
      /*grey?*/ no_colours > 256 /*was (unsigned) saddr->mode > 255 J R C 6th Oct 1994*/);

  menu_setflags (sprite_main_menu, s_Grid,
      /*tick?*/ sprw->gridcol != 255, FALSE);

  for (i=0; i<16; i++)
    menu_setflags (sprite_colour_menu, i + 1,
        /*tick?*/ sprw->gridcol == i, /*grey?*/ FALSE);

  menu_setflags (sprite_save_menu, s_Save_Palette,
      /*tick?*/ FALSE, /*grey?*/ !psprite_haspal (sprite));
  menu_setflags (sprite_paint_menu, s_Paint_Show_Col,
      /*tick?*/ FALSE,
      /*grey?*/ read_only);
  menu_setflags (sprite_paint_menu, s_Paint_Small,
      /*tick?*/ sprite->coloursize == colours_SIZE/2,
      /*grey?*/ no_colours > 256);
  menu_setflags (sprite_paint_menu, s_Paint_Edit_Pal,
      /*tick?*/ FALSE, /*grey?*/ !(psprite_hastruecolpal (sprite) &&
      0 <= sprite->gcol && sprite->gcol < no_colours));

  /*strcpy (rotatebuffer, "90");
  strcpy (scalebuffer, "1");
  strcpy (shearbuffer, "0")*/

  help_register_handler (&help_simplehandler, (void *) "EDIT");

  return sprite_main_menu;
}

/******************************************
 * Initialise the static menu structures  *
 ******************************************/

static menu make_menu2 (char *titletag, char *bodytag)

{ ftracef0 ("make_menu2\n");
  ftracef2 ("titletag is \"%s\", bodytag is \"%s\"\n", titletag, bodytag);
  return menu_new (msgs_lookup (titletag), msgs_lookup (bodytag));
}

static menu make_menu1 (char *titletag, char *body)

{ ftracef0 ("make_menu1\n");
  ftracef2 ("titletag is \"%s\", body is \"%s\"\n", titletag, body);
  return menu_new (msgs_lookup (titletag), body);
}

void menus_init (void)

{ menu temp1, temp2, temp3, temp4, temp5;

  ftracef0 ("init_menus_init\n");

  spritefile_main_menu = make_menu2 ("Pnt00", "PntM3");

  temp1 = make_menu2 ("PntM4", "PntM5");
  temp2 = make_menu1 ("PntM6", "123456789012");
  menu_make_writeable (temp2, 1, spritenamebuffer, 13, "A~ ");
  menu_submenu (temp1, m_Sprite_Copy, temp2);
  temp2 = make_menu1 ("PntM7", "123456789012");
  menu_make_writeable (temp2, 1, spritenamebuffer, 13, "A~ ");
  menu_submenu (temp1, m_Sprite_Rename, temp2);
  menu_submenu (spritefile_main_menu, m_Sprite, temp1);

  filedisplay_menu = make_menu2 ("PntM8", "PntM9");
  menu_submenu (spritefile_main_menu, m_Display, filedisplay_menu);

  spritefile_misc_menu = make_menu2 ("PntMM", "PntMN");
  menu_submenu (spritefile_main_menu, m_Misc, spritefile_misc_menu);

  ftracef0 ("Creating sprite_menu\n");

  sprite_main_menu = make_menu2 ("Pnt00", "PntMA");
  sprite_misc_menu = make_menu2 ("PntMK", "PntML");
  sprite_save_menu = make_menu2 ("PntMB", "PntMC");

  menu_submenu (sprite_main_menu, s_Misc, sprite_misc_menu);

  menu_submenu (sprite_main_menu, s_Save, sprite_save_menu);

  sprite_paint_menu = make_menu2 ("Pnt00", "PntMD");
  menu_submenu (sprite_main_menu, s_Paint, sprite_paint_menu);

  sprite_edit_menu = make_menu2 ("PntME", "PntMF");
  temp2 = make_menu1 ("PntMG", "?");
  menu_make_writeable (temp2, 1, rotatebuffer, 12, "A0-9\\-");
  menu_submenu (sprite_edit_menu, s_Edit_Rotate, temp2);

  temp3 = make_menu1 ("PntMJ", "?");
  menu_make_writeable (temp3, 1, scalebuffer, 12, "A0-9.eE");
  menu_submenu (sprite_edit_menu, s_Edit_Scale_X, temp3);

  temp4 = make_menu1 ("PntMJ", "?");
  menu_make_writeable (temp4, 1, scalebuffer, 12, "A0-9.eE");
  menu_submenu (sprite_edit_menu, s_Edit_Scale_Y, temp4);

  temp5 = make_menu1 ("PntMJ", "?");
  menu_make_writeable (temp5, 1, shearbuffer, 12, "A0-9\\-.eE");
  menu_submenu (sprite_edit_menu, s_Edit_Shear, temp5);

  menu_submenu (sprite_main_menu, s_Edit, sprite_edit_menu);

  sprite_colour_menu = colourmenu_make (msgs_lookup ("PntMH"), 0);
  menu_submenu (sprite_main_menu, s_Grid, sprite_colour_menu);
}
