/*****************************************************************************
* 
*   audhal.c
* 
*   Client Audio hardware driver external routines
* 
*   Copyright Citrix Systems, Inc. 1997
* 
*   Author: DavidP  12 Jun 97
* 
*   $Log$
*  
*     Rev 1.20   07 May 1998 10:07:34   davids
*  Get rid of warning for CE builds
*  
*     Rev 1.19   Apr 27 1998 11:58:04   DavidT
*  Get audio working on HP handheld PC
*  
*     Rev 1.18   16 Apr 1998 16:20:08   ianr
*  Fix compilation for WINCE
*  
*     Rev 1.17   Apr 02 1998 16:52:32   bills
*  removed the calls to load/unload the adpcm driver
*  
*     Rev 1.16   24 Mar 1998 15:43:50   brada
*  Use debug macro to declare fName
*  
*     Rev 1.15   10 Feb 1998 15:15:58   davidp
*  moved client-side bandwidth limit to main VD
*  
*     Rev 1.14   07 Feb 1998 13:28:40   davidp
*  Fix for LB audio; formatting
*  
*     Rev 1.13   22 Jan 1998 14:46:58   x86fre
*  Interger to DWORD
*  
*     Rev 1.12   Jan 22 1998 14:40:48   xuanh
*  audio bandwidth limit win16 support
*  
*     Rev 1.11   Jan 21 1998 14:55:48   xuanh
*  upate
*  
*     Rev 1.10   Jan 21 1998 14:30:48   xuanh
*  add audio bandwidth limit
*  
*     Rev 1.9   13 Jan 1998 23:22:26   davidp
*  fixed a series of Win16 oopsies from the last put
*  
*     Rev 1.8   13 Jan 1998 23:11:32   davidp
*  Load ACM converter DLL on Win32 (pICAsso Beta 2 item)
*  
*     Rev 1.7   18 Dec 1997 17:54:22   davidp
*  previous changes isolated to Win32
*  
*     Rev 1.6   18 Dec 1997 15:02:46   davidp
*  changes to support ADPCM format
*  
*     Rev 1.5   19 Nov 1997 18:00:10   davidp
*  Tracing change.  This is also the version where trcflags.h changed locations
*  
*     Rev 1.4   17 Oct 1997 19:47:46   davidp
*  code formatting
*  
*     Rev 1.3   09 Oct 1997 16:51:46   davidp
*  Fixed idle detection code
*  
*     Rev 1.2   Oct 09 1997 18:09:24   briang
*  Conversion to MemIni use
*  
*     Rev 1.1   26 Sep 1997 18:31:36   davidp
*  fix for syntax error from PVCS log entry
*  
*     Rev 1.0   26 Sep 1997 18:29:26   davidp
*  Original revision
* 
*****************************************************************************/

#include "windows.h"
#include <stdlib.h>
#include <string.h>

#ifdef WINCE
#include <wcecalls.h>
#endif /* WINCE */

#ifdef WIN32
#include <mmreg.h>
#include <citrix/mmregctx.h>
#include <msacm.h>
#endif

#ifdef WIN16
#include <stdlib.h>
#include <string.h>
#endif


//  Includes
//
#include "wfengapi.h"
#include "client.h"
#include "mem.h"

#include "citrix/ica.h"
#include "citrix/ica-c2h.h"

#include "clib.h"
#include "logapi.h"
#include "miapi.h"

#define AUDIO_HW_DRIVER
#include "../inc/hwapi.h"
#include "drvinfo.h"

#include "../../inc/trcflags.h"

#undef STATIC
#define STATIC static

//////////////////////////////////////////////////////////////////////////////
//   Global Data
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Module interface stuff
//

//  Define audio hardware driver exported procedures
//
PDLLPROCEDURE AudHWProcedures[ AUDHW__COUNT ] =
{
    (PDLLPROCEDURE) audHWModuleLoad,
    (PDLLPROCEDURE) audHWModuleUnload,
    (PDLLPROCEDURE) audHWModuleOpen,
    (PDLLPROCEDURE) audHWModuleClose,
    (PDLLPROCEDURE) audHWModuleInfo,
    (PDLLPROCEDURE) audHWModulePoll,
    (PDLLPROCEDURE) audHWDeviceOpen,
    (PDLLPROCEDURE) audHWDeviceClose,
    (PDLLPROCEDURE) audHWDeviceGetInformation,
    (PDLLPROCEDURE) audHWDeviceSetInformation,
    (PDLLPROCEDURE) audHWDeviceRead,
    (PDLLPROCEDURE) audHWDeviceWrite,
    (PDLLPROCEDURE) audHWDeviceIOCTL,
    (PDLLPROCEDURE) audHWDeviceLastError,
    (PDLLPROCEDURE) audHWDevicePurge
};

//  Define audio hardware driver exported data structure
//
STATIC AUDHWDATA AudHWData = {0};

#if 0
HINSTANCE ghInstance;       // for DllMain

// These give us access to the procedures contained in their loadable
// libraries.  (The header files above use them to set up appropriate macros
// for function calls)
//
STATIC PPLIBPROCEDURE pModuleProcedures = NULL;
STATIC PPLIBPROCEDURE pClibProcedures   = NULL;
STATIC PPLIBPROCEDURE pMouProcedures    = NULL;
STATIC PPLIBPROCEDURE pTimerProcedures  = NULL;
STATIC PPLIBPROCEDURE pLptProcedures    = NULL;
STATIC PPLIBPROCEDURE pXmsProcedures    = NULL;
STATIC PPLIBPROCEDURE pLogProcedures    = NULL;
STATIC PPLIBPROCEDURE pMemIniProcedures = NULL;
STATIC PPLIBPROCEDURE pKbdProcedures    = NULL;
#endif

//////////////////////////////////////////////////////////////////////////////
// data queue management structures and globals
//

// Queue item struct.  The exact contents of this structure will vary with
// the implementation platform.
//
typedef struct _QUEUE_ITEM
{
    HGLOBAL             hGlobalHdr;     // for Win32 mem management
    PVOID               pHdr;           // for Win32 audio interface
    USHORT              cbHdr;          //           "
    PAUDHW_DATA_ITEM    pData;          // data to play
    struct _QUEUE_ITEM* pNext;          // list management
} QUEUE_ITEM, * PQUEUE_ITEM;

PQUEUE_ITEM gpsFreeQueueItemList = NULL;
USHORT      gnQueueBuffers;

//////////////////////////////////////////////////////////////////////////////
// Device table storage

typedef struct _DEVICE
{
    DWORD               hDevice;    // cast this to HWAVEOUT, HMIDIIN, etc.
                                    // as needed
    AUDHW_MEDIA_TYPE    iType;
    BOOL                fReadWrite; // true = write, false = read
    BOOL                fIsOpen;    // is there an active device at this index?
    PQUEUE_ITEM         pFirstData; // first in-progress data chunk
    PQUEUE_ITEM         pLastData;  // last in-progress data chunk
} DEVICE, * PDEVICE;

// set this to whatever you're comfy with
#define MAX_NUM_DEVICES 1   // (for now, sync with # of devices in VDCAM table)

SHORT  giNextDeviceNum;     // Index of next free device in table.  -1 means
                            // the table is full.
static DEVICE gsDevices[MAX_NUM_DEVICES];

#ifdef WIN32
// ACM converter DLL information
HINSTANCE ghAcmDrvInstance;
HACMDRIVERID ghAcmDriverID;
#endif

//////////////////////////////////////////////////////////////////////////////
//   Exported Functions

#ifndef WINCE  //DllMain declared in winbase.h for the CE SDK.  The first parameter is different, generates a warning.
BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved);
#endif

extern int WFCAPI Load( PDLLLINK );

// (the others are declared in hwapi.h)


//////////////////////////////////////////////////////////////////////////////
//   Internal Functions

void FindFirstFreeDeviceIndex( void );

int OpenPCMOutDevice( PHAUDDEVICE phDevice, PAUDHW_FORMATINFO psFormat,
    USHORT fFlags );
int OpenPCMInDevice( PHAUDDEVICE phDevice, PAUDHW_FORMATINFO psFormat,
    USHORT fFlags );
int OpenMidiOutDevice( PHAUDDEVICE phDevice, PAUDHW_FORMATINFO psFormat,
    USHORT fFlags );
int OpenMidiInDevice( PHAUDDEVICE phDevice, PAUDHW_FORMATINFO psFormat,
    USHORT fFlags );

int ReleaseQueueItem( PQUEUE_ITEM pItem );
int GetFreeQueueItem( PQUEUE_ITEM* ppItem );
int DeallocateQueueItem( PQUEUE_ITEM pItem );
int DeallocateAllQueueItems( void );
int AllocateQueueItem( PQUEUE_ITEM* ppNewItem );

int MapFormatTag( USHORT audHWFormatTag, PUSHORT pWinFormatTag );

#ifdef WIN32
BOOL LoadAcmDriver( void );
void UnloadAcmDriver( void );
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  Module-access routines.  These conform to the standard module-access API.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  DllMain - EXTERNAL
//
//  This is called by Windows when the DLL is initialized, thread-attached
//  or -detached, and other times.
//
//  ENTRY:
//    HINSTANCE hDLL        [in]    Handle to this instance
//    DWORD dwReason        [in]    Why this was called (init, attach, etc.)
//    LPVOID lpReserved     [in]    Reserved, do not use
//
//  EXIT:
//    Returns TRUE to indicate successful processing.
//
//////////////////////////////////////////////////////////////////////////////

#if 0
BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{
    ghInstance = hDLL;
    return( TRUE );
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  Load - EXTERNAL
//
//  The CAM VD calls Load to load and link an audio driver.  This routine
//  is specifically referred to by name in the "magic" loading code in the
//  DLL library, so we have to have one.  We'll just delegate it to the real
//  thing.
//
//  ENTRY:
//    PDLLLINK pLink    [out]       Info for linking
//
//  EXIT:
//    CLIENT_STATUS_SUCCESS - no error.  Note that this routine and the other
//      "standard" loadable module routines use the usual CLIENT_STATUS_xxx
//      and CLIENT_ERROR_xxx codes instead of the AUDHW_STATUS/ERROR_xxx
//      codes.
//
//////////////////////////////////////////////////////////////////////////////

extern int WFCAPI
AudHWSnd16Load( PDLLLINK pLink )
{
    return audHWModuleLoad( pLink );
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWModuleLoad - EXTERNAL
//
//  The real McCoy.  This copies our vtable and data pointers out so the
//  caller can access our routines.
//
//  ENTRY:
//    PDLLLINK pLink    [out]       Link data to set
//
//  EXIT:
//    CLIENT_STATUS_SUCCESS - no error.  Note that this routine and the other
//      "standard" loadable module routines use the usual CLIENT_STATUS_xxx
//      and CLIENT_ERROR_xxx codes instead of the AUDHW_STATUS/ERROR_xxx
//      codes.
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWModuleLoad( PDLLLINK pLink )
{
    DeclareFName("audHWModuleLoad")

    TRACE(( TC_CAM, (TT_API1 | TT_INIT), "===%s===", fName ));

    pLink->ProcCount   = AUDHW__COUNT;
    pLink->pProcedures = AudHWProcedures;
    pLink->pData       = &AudHWData;

    // TODO: Any additional load procedures for your driver.  Load any
    // subordinate drivers here.
    //

    return CLIENT_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWModuleUnload - EXTERNAL
//
//  The CAM VD calls this when it's time to unload the driver.
//
//  ENTRY:
//    PDLLLINK pLink    [out]       Link data to reset
//
//  EXIT:
//    CLIENT_STATUS_SUCCESS - no error.  Note that this routine and the other
//      "standard" loadable module routines use the usual CLIENT_STATUS_xxx
//      and CLIENT_ERROR_xxx codes instead of the AUDHW_STATUS/ERROR_xxx
//      codes.
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWModuleUnload( PDLLLINK pLink )
{
    DeclareFName("audHWModuleUnload")

    TRACE(( TC_CAM, TT_API1, "===%s===", fName ));

    pLink->ProcCount   = 0;
    pLink->pProcedures = 0;
    pLink->pData       = NULL;

    return CLIENT_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWModuleOpen - EXTERNAL
//
//  The CAM VD calls this after audHWLoad() to initialize the driver.
//
//  ENTRY:
//    PAUDHW_MOD_OPEN pAudioOpen  [in]    Container for initialization info
//
//  EXIT:
//    CLIENT_STATUS_SUCCESS - no error.  Note that this routine and the other
//      "standard" loadable module routines use the usual CLIENT_STATUS_xxx
//      and CLIENT_ERROR_xxx codes instead of the AUDHW_STATUS/ERROR_xxx
//      codes.
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWModuleOpen( PAUDHW_MOD_OPEN pAudioOpen )
{
    DeclareFName("audHWModuleOpen")
    int i;
    int nToAllocate;
    int rc;
    PQUEUE_ITEM pItem;

    //  Initialize global data
    //
#if 0
    pModuleProcedures = pAudioOpen->pModuleProcedures;
    pClibProcedures   = pAudioOpen->pClibProcedures;
    pMouProcedures    = pAudioOpen->pMouProcedures;
    pTimerProcedures  = pAudioOpen->pTimerProcedures;
    pLptProcedures    = pAudioOpen->pLptProcedures;
    pXmsProcedures    = pAudioOpen->pXmsProcedures;
    pLogProcedures    = pAudioOpen->pLogProcedures;

    pMemIniProcedures = pAudioOpen->pMemIniProcedures;
#endif
    TRACE(( TC_CAM, TT_INIT, "===%s===", fName ));

    gnQueueBuffers    = pAudioOpen->nMaxDataItems;

    // initialize device structures
    //
    for ( i=0 ; i < MAX_NUM_DEVICES ; i++ )
        // this relies on meaning of zero for certain values (e.g. fIsOpen)
        memset(&(gsDevices[i]), 0, sizeof(DEVICE));
    giNextDeviceNum = 0;

    TRACE(( TC_CAM, TT_API3, "%s: preallocating %u buffers for queue pool",
        fName, gnQueueBuffers ));

    nToAllocate = gnQueueBuffers;
    while( nToAllocate > 0 )
    {
        // Get a new one ...
        if ((rc = AllocateQueueItem( &pItem )) != AUDHW_STATUS_SUCCESS)
        {
            TRACE(( TC_CAM, TT_ERROR, "%s: error allocating queue item",
                fName ));
            rc = AUDHW_ERROR_MEM_ALLOC_FAILED;
            goto cleanup_error;
        }

        // ... and put it on the free list
        ReleaseQueueItem( pItem );

        nToAllocate--;
    }
    
    TRACE(( TC_CAM, TT_API3, "%s: preallocated %u buffers for queue pool",
        fName, gnQueueBuffers ));

#ifdef WIN32
    // Load ACM converter DLL
    //
    //LoadAcmDriver();
#endif

    return CLIENT_STATUS_SUCCESS;

cleanup_error:
    if ( pItem != NULL )
        DeallocateQueueItem( pItem );

    DeallocateAllQueueItems();

    return rc;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWModuleClose - EXTERNAL
//
//  The CAM VD calls this to close the driver.
//
//  ENTRY:
//
//  EXIT:
//    CLIENT_STATUS_SUCCESS - no error.  Note that this routine and the other
//      "standard" loadable module routines use the usual CLIENT_STATUS_xxx
//      and CLIENT_ERROR_xxx codes instead of the AUDHW_STATUS/ERROR_xxx
//      codes.
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWModuleClose( void )
{
    DeclareFName("audHWModuleClose")
    int i;

    TRACE(( TC_CAM, TT_API1, "===%s===", fName ));

    // TODO: make sure all devices are closed
    for ( i=0 ; i<MAX_NUM_DEVICES ; i++ )
    {
        // I don't like calling my public functions, but this will have to do
        // for now
        audHWDevicePurge((HAUDDEVICE) i);
        audHWDeviceClose((HAUDDEVICE) i);
    }

    DeallocateAllQueueItems();

#ifdef WIN32
    // Unload ACM converter DLL
    //
    //UnloadAcmDriver();
#endif

    return CLIENT_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWModuleInfo - EXTERNAL
//
//  This routine is called to get information about this module.  This is
//  where the init routines get the module information to send to the host
//  at connect-time.
//
//  The usual convention is for the caller to first call this function with
//  the ByteCount field in the PDLLINFO set to zero.  The driver sets the
//  number to the required buffer size and returns an error.  Then the caller
//  allocates the appropriate buffer size and calls this function again.
//  Weird, no?
//
//  ENTRY:
//    PDLLLINK pLink    [in]      Link between caller and this module.  Unused.
//    PDLLINFO pInfo    [in/out]  Where to put the information.  Caller
//                                allocates the storage.
//
//  EXIT:
//    CLIENT_STATUS_SUCCESS - no error.  Note that this routine and the other
//      "standard" loadable module routines use the usual CLIENT_STATUS_xxx
//      and CLIENT_ERROR_xxx codes instead of the AUDHW_STATUS/ERROR_xxx
//      codes.
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWModuleInfo( PDLLLINK pLink, PDLLINFO pInfo )
{
    DeclareFName("audHWModuleInfo")
    USHORT      cbInfoSize;
    PMODULE_C2H pData;  // the only data this module sends is the header info
    
    TRACE(( TC_CAM, TT_API1, "===%s===", fName ));

    if ( pInfo == NULL )
        return CLIENT_ERROR_NULL_MEM_POINTER;

    cbInfoSize = sizeof(MODULE_C2H);

    if ( pInfo->ByteCount < cbInfoSize )
    {
        // caller is asking for buffer size
        pInfo->ByteCount = cbInfoSize;
        TRACE(( TC_CAM, TT_API3, "%s: Buffer too small", fName ));
        return CLIENT_ERROR_BUFFER_TOO_SMALL;
    }

    pData = (PMODULE_C2H) (pInfo->pBuffer);
    if ( pData == NULL )
        return CLIENT_ERROR_NULL_MEM_POINTER;

    // init default data
    //
    memset( pData, 0, cbInfoSize );
    pData->ByteCount = cbInfoSize;

    // set info goodies
    //
    pData->ModuleClass = Module_SubDriver;
    pData->VersionL    = AUDHW_VERSION_LOW;
    pData->VersionH    = AUDHW_VERSION_HIGH;

    pInfo->ByteCount = cbInfoSize;

    return CLIENT_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWModulePoll - EXTERNAL
//
//  This routine is called by the VD as part of its own poll routine.
//  Here we scan the open devices and set the fDone flag for any
//  AUDHW_DATA_ITEM that has finished playing.
//
//  ENTRY:
//    PDLLPOLL pPoll    [in]    poll information (timing, etc.)
//
//  EXIT:
//    CLIENT_STATUS_SUCCESS - no error.  Note that this routine and the other
//      "standard" loadable module routines use the usual CLIENT_STATUS_xxx
//      and CLIENT_ERROR_xxx codes instead of the AUDHW_STATUS/ERROR_xxx
//      codes.
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWModulePoll( PDLLPOLL pPoll )
{
    DeclareFName("audHWModulePoll")
    int i;
    BOOL fDone;

    BOOL fDataProcessed = FALSE;

    // loop through devices looking for open ones
    for ( i=0 ; i < MAX_NUM_DEVICES ; i++ )
    {
        PDEVICE psDevice;
        PQUEUE_ITEM pItem, pNext;

        // nothing to do if device not open or no data being tracked
        if ( (!gsDevices[i].fIsOpen) || (gsDevices[i].pFirstData == NULL) )
            continue;
        else
            psDevice = &(gsDevices[i]);

        // examine data queue to see if there is any finished data
        pItem = psDevice->pFirstData;
        fDone = FALSE;
        while ( pItem != NULL && !fDone )
        {
            TRACE(( TC_CAM, TT_API3, "%s: there is data to examine in device "
                "%u", fName, i ));

            fDataProcessed = TRUE;

            pNext = pItem->pNext;

            switch( psDevice->iType )
            {
            case PCM:
#ifdef NOTYET
                // TODO: modify this for input vs. output
                // check to see if hardware is finished with this buffer
                if (((PWAVEHDR) (pItem->pHdr))->dwFlags & WHDR_DONE )
                {
                    TRACE(( TC_CAM, TT_API3, "%s: found a completed buffer "
                        "in device %u", fName, i ));

                    // inform VD that this guy is done
                    pItem->pData->fDone = TRUE;
                    pItem->pData = NULL; // it's OK, VD is still tracking this
    
                    // loop and list maintenance
                    waveOutUnprepareHeader((HWAVEOUT) (psDevice->hDevice),
                        (PWAVEHDR) (pItem->pHdr), sizeof(WAVEHDR));
                    ReleaseQueueItem(pItem);
                    pItem = pNext;
                    psDevice->pFirstData = pItem;
                    if ( psDevice->pFirstData == NULL )
                    {
                        // we emptied the queue
                        TRACE(( TC_CAM, TT_API3, "%s: emptied queue for "
                            "device %u", fName, i ));
                        psDevice->pLastData = NULL;
                    }
                }
                else
                {
                    // since this stuff is processed in order, the remaining
                    // guys on the queue are also unfinished, so we just bail
                    fDone = TRUE;
                }
#endif
                break;  // end case PCM

            case Midi:
            default:
                TRACE(( TC_CAM, TT_ERROR, "%s: device type error on device %u "
                    "(type %d)", fName, i, (int) (psDevice->iType) ));
                ASSERT(0, 0);
                return CLIENT_ERROR_INVALID_MODE;   // seems as good as any
                break;
            }
        }
    }

    if ( fDataProcessed )
        return CLIENT_STATUS_SUCCESS;
    else
        return CLIENT_STATUS_NO_DATA;
}


//////////////////////////////////////////////////////////////////////////////
//
//  Device routines.  These functions all share the property that the caller
//  must specify a device handle to operate on (except for audHWDeviceOpen,
//  which is where the caller gets the handle in the first place).  They also
//  all return values from the AUDIO_ERROR/STATUS_xxx domain rather than the
//  CLIENT_ERROR/STATUS domain.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
//  audHWDeviceOpen - EXTERNAL
//
//  Open an audio device
//
//  ENTRY:
//    AUDHW_MEDIA_TYPE  iType       [in]    kind of device wanted
//    BOOL              fReadWrite  [in]    true = write, false = read
//    PAUDHW_FORMATINFO psFormat    [in]    data format information
//    USHORT            fFlags      [in]    flags for this open
//    PHAUDDEVICE       phDevice    [out]   handle to new open device
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS - no error
//    AUDHW_ERROR_xxx      - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWDeviceOpen(
    AUDHW_MEDIA_TYPE    iType,
    BOOL                fReadWrite,
    PAUDHW_FORMATINFO   psFormat,
    USHORT              fFlags,
    PHAUDDEVICE         phDevice )
{
    DeclareFName("audHWDeviceOpen")
    int rc = AUDHW_STATUS_SUCCESS;

    TRACE(( TC_CAM, TT_API1, "===%s===", fName ));

    // make sure we've got space for another device
    //
    if (giNextDeviceNum == -1)
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: tried to exceed maximum number of "
            "devices", fName ));
        return AUDHW_ERROR_TOO_MANY_DEVICES;
    }

    // dispatch to the appropriate subfunction
    switch ( iType )
    {
        case PCM:
            if ( fReadWrite )
                rc = OpenPCMOutDevice( phDevice, psFormat, fFlags );
            else
                rc = OpenPCMInDevice( phDevice, psFormat, fFlags );
            break;
        case Midi:
            if ( fReadWrite )
                rc = OpenMidiOutDevice( phDevice, psFormat, fFlags );
            else
                rc = OpenMidiInDevice( phDevice, psFormat, fFlags );
        default:
            rc = AUDHW_ERROR_INVALID_PARAMETER;
            break;
    }

    return rc;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWDeviceClose - EXTERNAL
//
//  Close an audio device.  This function is not designed to recover
//  gracefully from failure to close the device; it is the caller's
//  responsibility to ensure that the device is in fact ready for closing.
//  For example, the caller should attempt to keep track of what data has been
//  played by the device and not call this function until all the data has
//  been processed (so the device close function doesn't return "still playing
//  data").
//
//  ENTRY:
//    HAUDDEVICE  hDevice   [in]    device to close
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS - no error
//    AUDHW_ERROR_xxx      - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWDeviceClose(
    HAUDDEVICE hDevice )
{
    DeclareFName("audHWDeviceClose")
    int rc = AUDHW_STATUS_SUCCESS;

    TRACE(( TC_CAM, TT_API1, "===%s===", fName ));

    // sanity check
    if ( ! gsDevices[hDevice].fIsOpen )
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: invalid handle", fName ));
        return AUDHW_ERROR_INVALID_HANDLE;
    }

    switch( gsDevices[hDevice].iType )
    {
        case PCM:
#ifdef NOTYET
            // TODO: switch based on input/output
            {
                HWAVEOUT hWaveOut = (HWAVEOUT) (gsDevices[hDevice].hDevice);
                if ((rc = waveOutClose(hWaveOut)) != MMSYSERR_NOERROR)
                {
                    TRACE(( TC_CAM, TT_ERROR, "%s: error closing waveout "
                        "device (code %ld)", fName, rc ));
                    rc = AUDHW_ERROR_DEVICE_CLOSE_FAILED;
                }
                else
                {
                    memset(&(gsDevices[hDevice]), 0, sizeof(DEVICE));
                    FindFirstFreeDeviceIndex();
                    rc = AUDHW_STATUS_SUCCESS;
                }
            }
#endif
            break;
        case Midi:
        default:
            TRACE(( TC_CAM, TT_ERROR, "%s: Whoops!" ));
            ASSERT(0, 0);
            rc = AUDHW_ERROR_DEVICE_CLOSE_FAILED;
            break;
    }

    return rc;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWDeviceGetInformation - EXTERNAL
//
//  Retrieves information from the audio driver.
//
//  ENTRY:
//    HAUDDEVICE hDevice             [in]      target device
//    AUDHW_DEV_INFOCLASS iInformationClass
//                                   [in]      info type to retrieve
//    PVOID      pInformation        [in/out]  information buffer
//    int        cbInformationLength [in]      size of buffer
//    int        cbReturnLength      [out]     size of data returned in buf
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS - no error
//    AUDHW_ERROR_xxx      - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWDeviceGetInformation(
    HAUDDEVICE          hDevice,
    AUDHW_DEV_INFOCLASS iInformationClass,
    PVOID               pInformation,
    int                 cbInformationLength,
    int                 cbReturnLength )
{
    DeclareFName("audHWDeviceGetInformation")
    int rc = AUDHW_STATUS_SUCCESS;

    TRACE(( TC_CAM, TT_API1, "===%s===", fName ));

    // TODO: unscrew this function after buffering surgery

    // TODO: Whatever is necessary to retrieve the information from your
    // hardware (or global vars as appropriate) and return it to the caller
    // in pInformation. Modify the following cases to access your
    // data-acquisition routines.
    //

    switch ( iInformationClass )
    {
        case PCMOutNumChannels:
            break;
        case PCMOutVolume:
            break;
        case PCMOutPosition:
            break;
        case PCMOutPitch:
            break;
        case PCMInNumChannels:
            break;
        case PCMInVolume:
            break;
        case AudioLastError:
            break;
        default:
            rc = AUDHW_ERROR_INVALID_PARAMETER;
            break;
    }

    return( rc );
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWDeviceSetInformation - EXTERNAL
//
//  Sends information to the audio driver.
//
//  ENTRY:
//    HAUDDEVICE hDevice                [in]      target device
//    AUDHW_DEV_INFOCLASS iInformationClass
//                                      [in]      info type to set
//    PVOID      pInformation           [in]      information buffer
//    int        cbInformationLength    [in]      size of buffer
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS - no error
//    AUDHW_ERROR_xxx      - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWDeviceSetInformation(
    HAUDDEVICE          hDevice,
    AUDHW_DEV_INFOCLASS iInformationClass,
    PVOID               pInformation,
    int                 cbInformationLength )
{
    DeclareFName("audHWDeviceSetInformation")
    int rc = AUDHW_STATUS_SUCCESS;

    TRACE(( TC_CAM, TT_API1, "===%s===", fName ));

    // TODO: unscrew this function after buffering surgery

    // TODO: Whatever is necessary to send the information in the pInformation
    // parameter to your hardware. Modify the following cases to access your
    // data-modification routines.
    //

    switch ( iInformationClass )
    {
        case PCMOutNumChannels:
            break;
        case PCMOutVolume:
            break;
        case PCMInNumChannels:
            break;
        case PCMInVolume:
            break;
        case PCMOutPosition:       // read-only, return error
        case PCMOutPitch:          //           "
        case AudioLastError:        //           "
        default:
            rc = AUDHW_ERROR_INVALID_PARAMETER;
            break;
    }

    return( rc );
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWDeviceRead - EXTERNAL
//
//  Read audio data from the audio device.
//
//  Note: We don't do two-way audio yet, so this function will always return
//        AUDHW_ERROR_NOT_IMPLEMENTED.
//
//  ENTRY:
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS - no error
//    AUDHW_ERROR_xxx      - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWDeviceRead( void )
{
    DeclareFName("audHWDeviceRead")

    TRACE(( TC_CAM, TT_API1, "===%s===", fName ));

    return AUDHW_ERROR_NOT_IMPLEMENTED;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWDeviceWrite - EXTERNAL
//
//  Write audio data to the audio device.  
//
//  ENTRY:
//    HAUDDEVICE        hDevice     [in]    target device
//    PAUDHW_DATA_ITEM  pData       [in]    data to write
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS - no error
//    AUDHW_ERROR_xxx      - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWDeviceWrite(
    HAUDDEVICE          hDevice,
    PAUDHW_DATA_ITEM    pData )
{
    DeclareFName("audHWDeviceWrite")
    int rc = AUDHW_STATUS_SUCCESS;
    PQUEUE_ITEM pItem;
    PDEVICE psDevice;

    TRACE(( TC_CAM, TT_API1, "===%s===", fName ));

    // sanity checks
    ASSERT( pData != NULL, 0 );
    if ( (!gsDevices[hDevice].fIsOpen) ||   // dev not open
         (!gsDevices[hDevice].fReadWrite) ) // dev open for read
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: invalid handle", fName ));
        return AUDHW_ERROR_INVALID_HANDLE;
    }
    else
        psDevice = &(gsDevices[hDevice]);

    // get a queue element so we can track this buffer
    //
    if ((rc = GetFreeQueueItem(&pItem)) != AUDHW_STATUS_SUCCESS)
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: error getting queue item", fName ));
        return AUDHW_ERROR_MEM_ALLOC_FAILED;    // not really, but...
    }

    pItem->pData = pData;

    // attempt the operation
    //
    switch( psDevice->iType )
    {
        case PCM:
            TRACE(( TC_CAM, TT_API3, "%s: attempting PCM data write",
                fName ));
#ifdef NOTYET
            // set up and prepare PCM header
            ((PWAVEHDR) pItem->pHdr)->lpData = pData->pBuf;
            ((PWAVEHDR) pItem->pHdr)->dwBufferLength = pData->cbSize;
            if ((rc = waveOutPrepareHeader((HWAVEOUT) (psDevice->hDevice),
                (PWAVEHDR) (pItem->pHdr), sizeof(WAVEHDR)))
                != MMSYSERR_NOERROR)
            {
                TRACE(( TC_CAM, TT_ERROR, "%s: error preparing PCM ouput "
                    "header (code %ld)", fName, rc ));
                rc = AUDHW_ERROR_MEM_PREPARE_FAILED;
            }
            else // prepare successful
            {
                if ((rc = waveOutWrite((HWAVEOUT) (psDevice->hDevice),
                    (LPWAVEHDR) (pItem->pHdr), sizeof(WAVEHDR)))
                    != MMSYSERR_NOERROR)
                {
                    // unprepare the header
                    waveOutUnprepareHeader((HWAVEOUT) (psDevice->hDevice),
                        (PWAVEHDR) (pItem->pHdr), sizeof(WAVEHDR));
                    TRACE(( TC_CAM, TT_ERROR, "%s: error writing to PCM "
                        "device (code %ld)", fName, rc ));
                    rc = AUDHW_ERROR_DEVICE_WRITE_FAILED;
                }
                else
                {
                    TRACE(( TC_CAM, TT_API3, "%s: wrote to PCM device",
                        fName ));
                }
            }
#endif
            break;
        case Midi:
        default:
            TRACE(( TC_CAM, TT_ERROR, "%s: Device type error", fName ));
            break;
    }

    // now enqueue this guy on the device's Data queue so we can track
    // his progress in Poll()
    if (rc == AUDHW_STATUS_SUCCESS)
    {

        pItem->pData->fDone = FALSE;
        if ( psDevice->pFirstData == NULL )
        {
            // first guy on the queue
            TRACE(( TC_CAM, TT_API3, "%s: placing first data item on queue",
                fName ));
            psDevice->pFirstData = pItem;
            psDevice->pLastData = pItem;
        }
        else
        {
            // put him on the tail
            TRACE(( TC_CAM, TT_API3, "%s: appending data item to queue",
                fName ));
            psDevice->pLastData->pNext = pItem;
            psDevice->pLastData = pItem;
        }
    }

    return rc;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWDeviceIOCTL - EXTERNAL
//
//  Perform a low-level IOCTL on the audio device.
//
//  ENTRY:
//    HAUDDEVICE hDevice          [in]      target device
//    USHORT     iCode            [in]      ioctl code
//    PVOID      pInBuf           [in]      input buffer
//    ULONG      cbInBufSize      [in]      input buffer size
//    PVOID      pOutBuf          [out]     output buffer
//    ULONG      cbOutBufSize     [in]      output buffer size
//    PULONG     pcbBytesReturned [out]     num of bytes actually returned
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS - no error
//    AUDHW_ERROR_xxx      - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWDeviceIOCTL(
    HAUDDEVICE  hDevice,
    USHORT      iCode,
    PVOID       iInBuf,
    ULONG       cbInBufSize,
    PVOID       pOutBuf,
    ULONG       cbOutBufSize,
    PULONG      pcbBytesReturned )
{
    DeclareFName("audHWDeviceIOCTL")

    TRACE(( TC_CAM, TT_API1, "===%s===", fName ));

    return AUDHW_ERROR_NOT_IMPLEMENTED;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWDeviceLastError - EXTERNAL
//
//  Get the last error from the audio device.
//  TODO: Track errors per-device?  Right now, this is just a message-
//        generation routine.
//
//  ENTRY:
//    HAUDDEVICE hDevice    [in]    target device
//    USHORT     iError     [in]    error code
//    char*      szMessage  [out]   returned string equivalent
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS - no error
//    AUDHW_ERROR_xxx      - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWDeviceLastError(
    HAUDDEVICE  hDevice,
    USHORT      iError,
    char*       szMessage )
{
    TRACE((TC_CAM, TT_API2, "===audHWDeviceLastError==="));

    switch(iError)
    {
        case AUDHW_ERROR_INVALID_PARAMETER:
            strncpy(szMessage, "Invalid parameter",
                MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_DEVICE_OPEN_FAILED:
            strncpy(szMessage, "Failed to open audio device",
                MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_MEM_ALLOC_FAILED:
            strncpy(szMessage, "Memory allocation failed",
                MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_MEM_LOCK_FAILED:
            strncpy(szMessage, "Memory lock failed",
                MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_MEM_PREPARE_FAILED:
            strncpy(szMessage, "Memory buffer prepare failed",
                MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_DEVICE_WRITE_FAILED:
            strncpy(szMessage, "Failed to write to audio device",
                MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_NOT_IMPLEMENTED:
            strncpy(szMessage, "Feature not implemented", MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_INVALID_HANDLE:
            strncpy(szMessage, "Invalid handle", MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_TOO_MANY_DEVICES:
            strncpy(szMessage, "Maximum number of devices already reached",
                MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_ALREADY_PLAYING:
            strncpy(szMessage, "Sound output device already playing",
                MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_NO_DATA:
            strncpy(szMessage, "No audio data", MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_INVALID_DATA:
            strncpy(szMessage, "Invalid data", MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_INSUFFICIENT_RESOURCES:
            strncpy(szMessage, "Insufficient resources", MAX_ERRORMESSAGE);
            break;
        case AUDHW_ERROR_DEVICE_RESET_FAILED:
            strncpy(szMessage, "Failed to reset audio device",
                MAX_ERRORMESSAGE);
            break;
        default:
            strncpy(szMessage, "Unknown error", MAX_ERRORMESSAGE);
            break;
    }

    return AUDHW_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//
//  audHWDevicePurge - EXTERNAL
//
//  Purge an audio device.  Any buffer currently playing is halted and all
//  pending buffers (including playing ones) are marked as "finished."
//  
//  The purpose of this is to clean out a device's buffers so that sounds
//  may be interrupted or so that the device may be closed when an error
//  is detected.
//
//  ENTRY:
//    HAUDDEVICE  hDevice   [in]    device to close
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS - no error
//    AUDHW_ERROR_xxx      - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int STATIC WFCAPI
audHWDevicePurge(
    HAUDDEVICE hDevice )
{
    DeclareFName("audHWDevicePurge")
#ifdef NOTYET
    HWAVEOUT hWaveOut;
#endif
    int rc;
    PQUEUE_ITEM pItem, pNext;
    PDEVICE psDevice;

    TRACE(( TC_CAM, TT_API2, "===%s===", fName ));

    //// sanity check
    if ( ! gsDevices[hDevice].fIsOpen )
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: Invalid device handle", fName ));
        return AUDHW_ERROR_INVALID_HANDLE;
    }
    else
        psDevice = &(gsDevices[hDevice]);

    //// kill anything currently playing
#ifdef NOTYET
    // (this will need to be modified later for multiple device types)
    hWaveOut = (HWAVEOUT) psDevice->hDevice;
    if ( (rc = waveOutReset(hWaveOut)) != MMSYSERR_NOERROR )
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: error resetting device (code %d)",
            fName, rc ));
        return AUDHW_ERROR_DEVICE_RESET_FAILED;
    }
#endif
    //// mark all pending buffers as "done"

    pItem = psDevice->pFirstData;
    while ( pItem != NULL )
    {
        pNext = pItem->pNext;

        // inform VD that this guy is done
        pItem->pData->fDone = TRUE;
        pItem->pData = NULL; // it's OK, VD is still tracking this

#ifdef NOTYET
        // loop and list maintenance
        waveOutUnprepareHeader((HWAVEOUT) (psDevice->hDevice),
            (PWAVEHDR) (pItem->pHdr), sizeof(WAVEHDR));
#endif
        ReleaseQueueItem(pItem);
        pItem = pNext;
        psDevice->pFirstData = pItem;
        if ( psDevice->pFirstData == NULL )
        {
            // we emptied the queue
            TRACE(( TC_CAM, TT_API3, "%s: emptied queue for device %u", fName,
                hDevice ));
            psDevice->pLastData = NULL;
        }
    }

    return AUDHW_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//
//  Internal helper routines
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  FindFirstFreeDeviceIndex - INTERNAL
//
//  Find the first unoccupied device index in the device array.
//
//  Note: This function has the global side effect of modifying the
//        giNextDeviceNum variable.
//
//  ENTRY:
//
//  EXIT:
//
//////////////////////////////////////////////////////////////////////////////

void FindFirstFreeDeviceIndex(void)
{
    int i = 0;

    while ( i < MAX_NUM_DEVICES && gsDevices[i].fIsOpen )
        i++;

    if ( i == MAX_NUM_DEVICES )
        // didn't find a device, signal full device array with a -1
        giNextDeviceNum = -1;
    else
        giNextDeviceNum = i;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OpenPCMOutDevice - INTERNAL
//
//  Open a PCM output device.  This routine assumes that the caller has
//  verified that there is space in the device table for a new device.
//  If the AUDHW_OPENFLAGS_QUERY flag is set in the fFlags parameter, the
//  device is not actually opened; the function simply indicates with its
//  return value whether or not it _could_ have opened the device.
//
//  Note: For the non-query case, this function has the side effect of
//  modifying the global device table.
//
//  ENTRY:
//    HAUDDEVICE        hDevice     [in]    Handle to device to process
//    PAUDHW_FORMATINFO psFormat    [in]    Format information to open device
//    USHORT            fFlags      [in]    Flags for this open (see
//                                            AUDHW_OPENFLAGS_xxx)
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS  - no error
//    AUDHW_ERROR_xxx       - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int OpenPCMOutDevice(
    PHAUDDEVICE phDevice,
    PAUDHW_FORMATINFO psFormatParam,
    USHORT fFlags )
{
    DeclareFName("OpenPCMOutDevice")
    PDEVICE  pNewDevice;
#ifdef NOTYET
    HWAVEOUT hWaveOut;       // for Windows MM API
    DWORD    dwWinFlags = 0; //           "
#endif
    #if defined(WIN32)
    BYTE     FormatBuffer[sizeof(WAVEFORMATEX) + 8]; // larger than we need
    PWAVEFORMATEX   psFormat = (PWAVEFORMATEX) FormatBuffer;
    MMRESULT        rc;
    #elif defined(WIN16)
    PCMWAVEFORMAT   sFormat;
    UINT            rc;
    #else
    int rc;
    #endif
    
    WORD wFormatTag;

    TRACE(( TC_CAM, TT_API2, "===%s===", fName ));

    pNewDevice = &(gsDevices[giNextDeviceNum]);

    if (MapFormatTag(psFormatParam->wFormatTag, &wFormatTag)
        != AUDHW_STATUS_SUCCESS)
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: unknown format tag", fName ));
        return AUDHW_ERROR_INVALID_PARAMETER;
    }

    #if defined(WIN32)
    psFormat->wFormatTag      = wFormatTag;
    psFormat->nChannels       = psFormatParam->nChannels;
    psFormat->nSamplesPerSec  = psFormatParam->nSamplesPerSec;
    psFormat->nAvgBytesPerSec = psFormatParam->nAvgBytesPerSec;
    psFormat->nBlockAlign     = psFormatParam->nBlockAlign;
    psFormat->wBitsPerSample  = psFormatParam->wBitsPerSample;
    psFormat->cbSize          = psFormatParam->cbSize;
    if ( psFormat->cbSize != 0)
    {
        // TODO: put a check on the value in cbSize
        memcpy( ((PBYTE) psFormat) + sizeof(WAVEFORMATEX), psFormatParam->Extra,
            psFormatParam->cbSize );
    }
	TRACE(( TC_CAM, TT_FORMAT, "%s: WINDOWS VERSION\n"
        "\twFormatTag      = %d\n"
        "\tnChannels       = %d\n"
        "\tnSamplesPerSec  = %ud\n"
        "\tnAvgBytesPerSec = %ud\n"
        "\tnBlockAlign     = %d\n"
        "\twBitsPerSample  = %d\n"
        "\tcbSize          = %d\n",
        fName, psFormat->wFormatTag, psFormat->nChannels,
        psFormat->nSamplesPerSec, psFormat->nAvgBytesPerSec,
        psFormat->nBlockAlign, psFormat->wBitsPerSample, psFormat->cbSize
        ));

#ifndef WINCE
	// This print causes exceptions on the HP Handheld PC because
	// of alignment problems.  Better way of doing when we have
	// time would be to print out each individual extra byte.
	// i.e. #ifdef DEBUG for (i = 0; i < psFormat->cbSize; i++) etc

    if ( psFormat->cbSize )
    {
		TRACE(( TC_CAM, TT_FORMAT, "\tOther:          = 0x%X 0x%X",
			*((PDWORD)((PBYTE) psFormat + sizeof(WAVEFORMATEX))),
			*((PDWORD)((PBYTE) psFormat + sizeof(WAVEFORMATEX))) + sizeof(DWORD)));
	}
#endif	/* !WINCE */

    #elif defined(WIN16)
    sFormat.wf.wFormatTag      = wFormatTag;
    sFormat.wf.nChannels       = psFormatParam->nChannels;
    sFormat.wf.nSamplesPerSec  = psFormatParam->nSamplesPerSec;
    sFormat.wf.nAvgBytesPerSec = psFormatParam->nAvgBytesPerSec;
    sFormat.wf.nBlockAlign     = psFormatParam->nBlockAlign;
    sFormat.wBitsPerSample     = psFormatParam->wBitsPerSample;
    // TODO: does Win16 have WAVEFORMATEX?  If not, how do we use our
    //       adpcm format?
    #endif

#ifdef NOTYET
    // check the flags
    if (fFlags & AUDHW_OPENFLAG_QUERY)
        dwWinFlags |= WAVE_FORMAT_QUERY;
#endif
    TRACE(( TC_CAM, TT_INFO, "%s: %s device for %d kHz, %d channels, "
        "%d bits per sample", fName, fFlags & AUDHW_OPENFLAG_QUERY ?
        "querying" : "opening", psFormatParam->nSamplesPerSec,
        psFormatParam->nChannels, psFormatParam->wBitsPerSample ));

#ifdef NOTYET
    // open the audio device
    #if defined(WIN32)
    if ((rc = waveOutOpen(&hWaveOut, WAVE_MAPPER, psFormat, 0, 0, dwWinFlags))
        != MMSYSERR_NOERROR)
    #elif defined(WIN16)
    if ((rc = waveOutOpen(&hWaveOut, (UINT) WAVE_MAPPER,
        (LPWAVEFORMAT) &sFormat, 0, 0, dwWinFlags))
        != MMSYSERR_NOERROR)
    #endif
    {
        // this isn't really an error if we're just querying, so don't trace
        if (!(fFlags & AUDHW_OPENFLAG_QUERY))
        {
            TRACE(( TC_CAM, TT_ERROR, "%s: Error opening PCM output device "
                "(code %ld)", fName, rc ));
        }
        return AUDHW_ERROR_DEVICE_OPEN_FAILED;
    }
    else
    {
        // success, but were we only querying?
        if (fFlags & AUDHW_OPENFLAG_QUERY)
            return AUDHW_STATUS_SUCCESS;
    }

    // store data and return a handle to it
    pNewDevice->hDevice     = (DWORD) hWaveOut;
    pNewDevice->iType       = PCM;
    pNewDevice->fReadWrite  = TRUE; // write
    pNewDevice->fIsOpen     = TRUE;

    *phDevice = giNextDeviceNum;

    FindFirstFreeDeviceIndex();
#endif
    return AUDHW_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OpenPCMInDevice - INTERNAL
//
//  Open a PCM input device.  This routine assumes that the caller has
//  verified that there is space in the device table for a new device.
//
//  Note: This function has the side effect of modifying the global device
//  table.
//
//  Note: We don't do two-way audio yet so we always return "not implemented."
//
//  ENTRY:
//    HAUDDEVICE        hDevice     [in]    Handle to device to process
//    PAUDHW_FORMATINFO psFormat    [in]    Format information to open device
//    USHORT            fFlags      [in]    Flags for this open (see
//                                            AUDHW_OPENFLAGS_xxx)
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS  - no error
//    AUDHW_ERROR_xxx       - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int OpenPCMInDevice(
    PHAUDDEVICE phDevice,
    PAUDHW_FORMATINFO psFormat,
    USHORT fFlags )
{
    DeclareFName("OpenPCMInDevice")

    TRACE(( TC_CAM, TT_API2, "===%s===", fName ));

    return AUDHW_ERROR_NOT_IMPLEMENTED;
}



//////////////////////////////////////////////////////////////////////////////
//
//  OpenMidiOutDevice - INTERNAL
//
//  Open a MIDI output device.  This routine assumes that the caller has
//  verified that there is space in the device table for a new device.
//
//  Note: This function has the side effect of modifying the global device
//  table.
//
//  Note: We don't do Midi yet so we always return "not implemented."
//
//  ENTRY:
//    HAUDDEVICE        hDevice     [in]    Handle to device to process
//    PAUDHW_FORMATINFO psFormat    [in]    Format information to open device
//    USHORT            fFlags      [in]    Flags for this open (see
//                                            AUDHW_OPENFLAGS_xxx)
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS  - no error
//    AUDHW_ERROR_xxx       - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int OpenMidiOutDevice(
    PHAUDDEVICE phDevice,
    PAUDHW_FORMATINFO psFormat,
    USHORT fFlags )
{
    DeclareFName("OpenMidiOutDevice")

    TRACE(( TC_CAM, TT_API2, "===%s===", fName ));

    return AUDHW_ERROR_NOT_IMPLEMENTED;
}



//////////////////////////////////////////////////////////////////////////////
//
//  OpenMidiInDevice - INTERNAL
//
//  Open a MIDI input device.  This routine assumes that the caller has
//  verified that there is space in the device table for a new device.
//
//  Note: This function has the side effect of modifying the global device
//  table.
//
//  Note: We don't do Midi yet so we always return "not implemented."
//
//  ENTRY:
//    HAUDDEVICE        hDevice     [in]    Handle to device to process
//    PAUDHW_FORMATINFO psFormat    [in]    Format information to open device
//    USHORT            fFlags      [in]    Flags for this open (see
//                                            AUDHW_OPENFLAGS_xxx)
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS  - no error
//    AUDHW_ERROR_xxx       - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int OpenMidiInDevice(
    PHAUDDEVICE phDevice,
    PAUDHW_FORMATINFO psFormat,
    USHORT fFlags )
{
    DeclareFName("OpenMidiInDevice")

    TRACE(( TC_CAM, TT_API2, "===%s===", fName ));

    return AUDHW_ERROR_NOT_IMPLEMENTED;
}


//////////////////////////////////////////////////////////////////////////////
//
//  AllocateQueueItem - INTERNAL
//
//  Allocate a new queue item buffer.  The implementation of this function
//  is platform-dependent.
//
//  ENTRY:
//    PQUEUE_ITEM * ppNewItem   [out]   pointer to newly created item
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS  - no error
//    AUDHW_ERROR_xxx       - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int AllocateQueueItem( PQUEUE_ITEM* ppNewItem )
{
    DeclareFName("AllocateQueueItem")
    PQUEUE_ITEM         pNewItem   = NULL;  // new buffer list entry
    PVOID               pHdr       = NULL;  // new data buffer
    HGLOBAL             hGlobalHdr = NULL;  // for Win32 mem management
    int                 rc;

    TRACE(( TC_CAM, TT_API3, "===%s===", fName ));

    // The Win32 audio subsystem requires that any header or data buffers
    // passed to it have been allocated with GlobalAlloc and locked with
    // GlobalLock.

    // allocate and lock storage for the header
    if ((hGlobalHdr = GlobalAlloc(GMEM_MOVEABLE, AUDHW_DATA_HEADER_SIZE))
        == NULL)
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: error allocating header storage",
            fName ));
        rc = AUDHW_ERROR_MEM_ALLOC_FAILED;
        goto cleanup;
    }
    if ((pHdr = GlobalLock(hGlobalHdr)) == NULL)
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: error locking header storage",
            fName ));
        rc = AUDHW_ERROR_MEM_LOCK_FAILED;
        goto cleanup;
    }

    // we can just use malloc here
    if ((pNewItem = (PQUEUE_ITEM) malloc(sizeof(QUEUE_ITEM)))
        == NULL)
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: error allocating queue item", fName ));
        rc = AUDHW_ERROR_MEM_ALLOC_FAILED;
        goto cleanup;
    }

    pNewItem->hGlobalHdr    = hGlobalHdr;
    pNewItem->pHdr          = pHdr;
    pNewItem->cbHdr         = 0;        // this needs to get set once we know
                                        // whether the data is Midi or PCM
    pNewItem->pData         = NULL;
    pNewItem->pNext         = NULL;

    *ppNewItem = pNewItem;

    return AUDHW_STATUS_SUCCESS;

cleanup:
    if (hGlobalHdr != NULL)
    {
        if (pHdr != NULL)
            GlobalUnlock(hGlobalHdr);
        GlobalFree(hGlobalHdr);
    }
    if (pNewItem != NULL)
        free(pNewItem);

    *ppNewItem = NULL;

    return rc;
}


//////////////////////////////////////////////////////////////////////////////
//
//  DellocateQueueItem - INTERNAL
//
//  Deallocate a queue item buffer.  The implementation of this function
//  is platform-dependent.
//
//  ENTRY:
//    PQUEUE_ITEM pItem     [in]    queue item to be deallocated
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS  - no error
//    AUDHW_ERROR_xxx       - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int DeallocateQueueItem( PQUEUE_ITEM pItem )
{
    DeclareFName("DeallocateQueueItem")

    TRACE(( TC_CAM, TT_API3, "===%s===", fName ));

    // sanity check
    ASSERT( pItem != NULL, 0 );

    // blow away anything that's still here
    if (pItem->hGlobalHdr != NULL)
    {
        if (pItem->pHdr != NULL)
            GlobalUnlock(pItem->hGlobalHdr);
        GlobalFree(pItem->hGlobalHdr);
    }

    free(pItem);

    return AUDHW_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//
//  DeallocateAllQueueItems - INTERNAL
//
//  Deallocate all queue items on the free list.  To be used only for
//  initialization failure and module closedown.
//
//  ENTRY:
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS  - no error
//
//////////////////////////////////////////////////////////////////////////////

int DeallocateAllQueueItems( void )
{
    PQUEUE_ITEM pItem, pNext;

    pItem = gpsFreeQueueItemList;
    while( pItem != NULL )
    {
        pNext = pItem->pNext;
        DeallocateQueueItem( pItem );
        pItem = pNext;
    }

    return AUDHW_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//
//  GetFreeQueueItem - INTERNAL
//
//  Fetch a queue item from the free list.  This item should be assumed to
//  be completely uninitialized.  The function returns an error if there are
//  no remaining free queue items.
//
//  ENTRY:
//    PQUEUE_ITEM * ppItem  [out]    queue item from free list
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS  - no error
//    AUDHW_ERROR_xxx       - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int GetFreeQueueItem( PQUEUE_ITEM* ppItem )
{
    DeclareFName("GetFreeQueueItem")

    TRACE(( TC_CAM, TT_MEM, "===%s===", fName ));

    if (gpsFreeQueueItemList == NULL)
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: no free queue items", fName ));
        return AUDHW_ERROR_INSUFFICIENT_RESOURCES;
    }

    *ppItem = gpsFreeQueueItemList;
    gpsFreeQueueItemList = (*ppItem)->pNext;
    (*ppItem)->pNext = NULL;

    return AUDHW_STATUS_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
//
//  ReleaseQueueItem - INTERNAL
//
//  Return a queue item to the free list.  This may also be used to place
//  newly allocated queue items on the free list.
//
//  ENTRY:
//    PQUEUE_ITEM pItem     [in]    queue item to be released
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS  - no error
//    AUDHW_ERROR_xxx       - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int ReleaseQueueItem( PQUEUE_ITEM pItem )
{
    DeclareFName("ReleaseQueueItem")

    TRACE(( TC_CAM, TT_MEM, "===%s===", fName ));

    // sanity check
    if (pItem == NULL)
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: invalid pointer", fName ));
        ASSERT(0, 0);
        return AUDHW_ERROR_INVALID_PARAMETER;
    }

    pItem->pNext = gpsFreeQueueItemList;
    memset(pItem->pHdr, 0, AUDHW_DATA_HEADER_SIZE);
    gpsFreeQueueItemList = pItem;

    return AUDHW_STATUS_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////////
//
//  MapFormatTag - INTERNAL
//
//  Map an AUDHW format tag to a Windows format tag.
//
//  ENTRY:
//    USHORT    audHWFormatTag  [in]    format tag to map
//    PUSHORT   pWinFormatTag   [out]   corresponding Windows format tag
//
//  EXIT:
//    AUDHW_STATUS_SUCCESS  - no error
//    AUDHW_ERROR_xxx       - otherwise
//
//////////////////////////////////////////////////////////////////////////////

int MapFormatTag( USHORT audHWFormatTag, PUSHORT pWinFormatTag )
{
    int rc = AUDHW_STATUS_SUCCESS;

    ASSERT( pWinFormatTag != 0, 0 );

    switch( audHWFormatTag )
    {
        case AUDHW_FORMAT_LINEAR_PCM:
#ifdef NOTYET
            *pWinFormatTag = WAVE_FORMAT_PCM;
#endif
            break;
#ifdef WIN32
        case AUDHW_FORMAT_CTX_ADPCM:
            *pWinFormatTag = WAVE_FORMAT_CTX_ADPCM;
            break;
#endif
        default:
            rc = AUDHW_ERROR_INVALID_PARAMETER;
            break;
    }

    return rc;
}

#ifdef WIN32

//////////////////////////////////////////////////////////////////////////////
//
//  LoadAcmDriver - INTERNAL
//
//  Loads an ACM converter DLL so that writes to the WAVE_MAPPER device
//  can be done with our custom format(s).
//
//  ENTRY:
//
//  EXIT:
//    TRUE - the driver was loaded
//    FALSE - the driver could not be loaded
//
//////////////////////////////////////////////////////////////////////////////

BOOL LoadAcmDriver( void )
{
    DeclareFName("LoadAcmDriver")
    int rc;
    ACMDRIVERPROC acmDriverProc;
    char szDllName[MAX_INI_LINE];

    TRACE(( TC_CAM, TT_API3, "===%s===", fName ));


    miGetPrivateProfileString( INI_AUDHW_SECTION,
                               INI_AUDHW_CONVERTERNAME,
                               DEF_AUDHW_CONVERTERNAME,
                               szDllName,
                               MAX_INI_LINE );

    if ( (ghAcmDrvInstance = LoadLibrary(szDllName)) == NULL )
    {
        rc = GetLastError();
        TRACE(( TC_CAM, TT_ERROR, "%s: error loading ACM converter module "
            "(code 0x%X)", fName, rc ));
        ghAcmDrvInstance = INVALID_HANDLE_VALUE;
        return FALSE;
    }

    if ( (acmDriverProc =
            (ACMDRIVERPROC) GetProcAddress( ghAcmDrvInstance, "DriverProc" ))
        == NULL )
    {
        rc = GetLastError();
        TRACE(( TC_CAM, TT_ERROR, "%s: error finding ACM converter module "
            "proc address (code 0x%X)", fName, rc ));
        FreeLibrary( ghAcmDrvInstance );
        ghAcmDrvInstance = INVALID_HANDLE_VALUE;
        return FALSE;
    }

    if ( (rc = acmDriverAdd(&ghAcmDriverID,
                    ghAcmDrvInstance,
                    (LPARAM) acmDriverProc,
                    0L,
                    ACM_DRIVERADDF_FUNCTION | ACM_DRIVERADDF_LOCAL))
        != MMSYSERR_NOERROR )
    {
        TRACE(( TC_CAM, TT_ERROR, "%s: error adding ACM converter module "
            "(code 0x%X)", fName, rc ));
        FreeLibrary( ghAcmDrvInstance );
        ghAcmDrvInstance = INVALID_HANDLE_VALUE;
        ghAcmDriverID = INVALID_HANDLE_VALUE;
        return FALSE;
    }

    TRACE(( TC_CAM, TT_INIT, "%s: Loaded ACM converter module", fName ));

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
//
//  UnloadAcmDriver - INTERNAL
//
//  Unloads the ACM converter DLL that was previously loaded in
//  LoadAcmDriver().
//
//  ENTRY:
//
//  EXIT:
//
//////////////////////////////////////////////////////////////////////////////

void UnloadAcmDriver( void )
{
    if ( ghAcmDriverID != INVALID_HANDLE_VALUE )
        acmDriverRemove( ghAcmDriverID, 0L );
    if ( ghAcmDrvInstance != INVALID_HANDLE_VALUE )
        FreeLibrary( ghAcmDrvInstance );
}
#endif // WIN32


