/***************************************************/
/* File   : manager.c                              */
/*                                                 */
/* Purpose: manager window and object functions.   */
/*                                                 */
/* Author : D.T.A.Brown                            */
/*                                                 */
/* History: 23-Jul-98: Created.                    */
/***************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "toolbox.h"
#include "event.h"
#include "wimp.h"
#include "wimplib.h"
#include "window.h"
#include "menu.h"

#include "INI.h"
#include "ICAMgr.h"
#include "list.h"
#include "ica.h"
#include "misc.h"
#include "connection.h"
#include "globals.h"
#include "TBEvents.h"
#include "manager.h"

#define WimpLink_LeftToWorkArea    (0 << 16)
#define WimpLink_LeftToLeft        (1 << 16)
#define WimpLink_LeftToRight       (2 << 16)

#define WimpLink_RightToWorkArea   (0 << 20)
#define WimpLink_RightToLeft       (1 << 20)
#define WimpLink_RightToRight      (2 << 20)

#define WimpLink_TopToWorkArea     (0 << 22)
#define WimpLink_TopToBottom       (1 << 22)
#define WimpLink_TopToTop          (2 << 22)

#define WimpLink_BottomToWorkArea  (0 << 18)
#define WimpLink_BottomToBottom    (1 << 18)
#define WimpLink_BottomToTop       (2 << 18)

#define WimpLink_XScrollToWorkArea (0 << 24)
#define WimpLink_XScrollToLeft     (1 << 24)
#define WimpLink_XScrollToRight    (2 << 24)

#define WimpLink_YScrollToWorkArea (0 << 26)
#define WimpLink_YScrollToBottom   (1 << 26)
#define WimpLink_YScrollToTop      (2 << 26)

#define DESC_XMIN(manager) (manager->app_descxmin)
#define DESC_XMAX(manager) (manager->app_descxmax)
#define SERV_XMIN(manager) (manager->app_servxmin)
#define SERV_XMAX(manager) (manager->app_servxmax)

#define TEXT_ICON_FLAGS_SELECTED    (WimpIcon_Text         |   \
                                     WimpIcon_Filled       |   \
                                     WimpIcon_VCentred     |   \
                                     WimpIcon_Indirected   |   \
                                     WimpIcon_FGColour * 1 |   \
                                     WimpIcon_BGColour * 7)

#define TEXT_ICON_FLAGS_UNSELECTED  (WimpIcon_Text         |   \
                                     WimpIcon_VCentred     |   \
                                     WimpIcon_Indirected   |   \
                                     WimpIcon_FGColour * 7 |   \
                                     WimpIcon_BGColour * 0)

typedef enum{MGR_WFCLIENT,
             MGR_THINWIRE3_0,
             MGR_number} manager_section_types;

/* These entries MUST be in alphabetical order */
static name_to_number mgr_sections[MGR_number] = {{"Thinwire3.0", MGR_THINWIRE3_0},
                                                  {"WFClient",    MGR_WFCLIENT}};

static name_number_mappings mgr_maps = {mgr_sections, MGR_number, MGR_number};

typedef enum{THIN_HRES,
             THIN_VRES,
             THIN_COLOURS,
             THIN_number} thinwire_entry_types;

/* These entries MUST be in alphabetical order */
static name_to_number thinwire_entries[THIN_number] = {
                                                       {"DesiredColor", THIN_COLOURS},
                                                       {"DesiredHRes", THIN_HRES},
                                                       {"DesiredVRes", THIN_VRES},
                                                      };

static name_number_mappings thinwire_maps = {thinwire_entries,THIN_number, THIN_number};

typedef enum{WFCLIENT_CACHE_PATH,
             WFCLIENT_CACHE_SMALLEST,
             WFCLIENT_CACHE_DISKUSE,
             WFCLIENT_number} wfclient_entry_types;

/* These entries MUST be in alphabetical order */
static name_to_number wfclient_entries[WFCLIENT_number] = {
                                                           {"PersistentCacheMinBitmap", WFCLIENT_CACHE_SMALLEST},
                                                           {"PersistentCachePath",      WFCLIENT_CACHE_PATH},
                                                           {"PersistentCacheSize",      WFCLIENT_CACHE_DISKUSE}
                                                          };

static name_number_mappings wfclient_maps = {wfclient_entries, WFCLIENT_number, WFCLIENT_number};

static int manager_redraw_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handler);
static int manager_click_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handler);
static int manager_openwin_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handler);
static int manager_check_connect(ica_manager *manager, ica_connection *item, int xmin, int xmax);
static void manager_set_buttons(ica_manager *manager);
static _kernel_oserror *manager_select_clear(ica_manager *manager);
static _kernel_oserror *manager_start_selection_drag(ica_manager *manager);
static int ica_manager_menu_shown(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle);
static int ica_manager_select_all_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle);
static int ica_manager_select_clear_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle);
static int ica_manager_delete_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle);
static int ica_manager_edit_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle);
static int ica_manager_new_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle);

/*************************************************/
/* ica_manager_init()                            */
/*                                               */
/* Init the manager library.                     */
/*************************************************/

_kernel_oserror *ica_manager_init(void)
{
  _kernel_oserror *e;
  e = event_register_toolbox_handler(-1, MainMenuShowing, ica_manager_menu_shown, NULL);
  if (!e) e = event_register_toolbox_handler(-1, SelectAll, ica_manager_select_all_handler, NULL);
  if (!e) e = event_register_toolbox_handler(-1, SelectClear, ica_manager_select_clear_handler, NULL);
  if (!e) e = event_register_toolbox_handler(-1, ToolbarNew, ica_manager_new_handler, NULL);
  if (!e) e = event_register_toolbox_handler(-1, ToolbarDelete, ica_manager_delete_handler, NULL);
  if (!e) e = event_register_toolbox_handler(-1, ToolbarEdit, ica_manager_edit_handler, NULL);

  return e;
}

/*************************************************/
/* ica_manager_create()                          */
/*                                               */
/* Creates an an ica_manager structure.          */
/*                                               */
/* Returns:    The new structure or NULL if it   */
/*             could not be created.             */
/*************************************************/

ica_manager *ica_manager_create(void)
{
  ObjectId itl, ibl, etl, ebl;
  _kernel_oserror *e;
  ica_manager *manager;

  manager = malloc(sizeof(ica_manager));
  if (!manager) return NULL;

  manager->newconwindow_id = NULL_ObjectId;
  manager->app_descxmin = 0;
  manager->app_descxmax = 640;
  manager->app_servxmin = 640;
  manager->app_servxmax = 1280;
  manager->no_selected  = 0;
  manager->last_selected_item = NOT_AN_ITEM;

  manager->settings.screen_width    = -1;
  manager->settings.screen_height   = -1;
  manager->settings.screen_colours  = 2;
  manager->settings.cache_directory = calloc(1, 1);
  manager->settings.cache_diskuse   = 0;
  manager->settings.cache_smallest  = 1024 * 8;

  manager->ini_head = NULL;
  manager->ini_tail = NULL;
  manager->connect_head = NULL;
  manager->connect_tail = NULL;

  e = toolbox_create_object(0, "RemApp", &manager->mainwindow_id);
  if (e)
  {
    free(manager);
    manager = NULL;
  }
  else
  {
    toolbox_set_client_handle(0, manager->mainwindow_id, manager);
    e = toolbox_create_object(0, "Headings", &manager->headwindow_id);
    if (!e) e = toolbox_set_client_handle(0, manager->headwindow_id, manager);

    if (!e)
    {

      e = event_register_wimp_handler(manager->mainwindow_id,
                                      Wimp_ERedrawWindow,
                                      manager_redraw_handler,
                                      manager);

      if (!e) e = event_register_wimp_handler(manager->mainwindow_id,
                                              Wimp_EMouseClick,
                                              manager_click_handler,
                                              manager);

      if (!e) e = event_register_wimp_handler(manager->mainwindow_id,
                                              Wimp_EOpenWindow,
                                              manager_openwin_handler,
                                              manager);

      if (e)
      {
        event_deregister_toolbox_handlers_for_object(manager->mainwindow_id);
        event_deregister_wimp_handlers_for_object (manager->mainwindow_id);
        toolbox_delete_object(0, manager->mainwindow_id);
        toolbox_delete_object(0, manager->headwindow_id);
        free(manager);
        manager = NULL;
      }
    }
    else
    {
      toolbox_delete_object(0, manager->mainwindow_id);
      free(manager);
      manager = NULL;
    }
  }


  if (!e) e = window_get_tool_bars(15, manager->mainwindow_id, &ibl, &itl, &ebl, &etl);
  if (!e)
  {
    if (ibl != NULL_ObjectId) toolbox_set_client_handle(0, ibl, manager);
    if (itl != NULL_ObjectId) toolbox_set_client_handle(0, itl, manager);
    if (ebl != NULL_ObjectId) toolbox_set_client_handle(0, ebl, manager);
    if (etl != NULL_ObjectId) toolbox_set_client_handle(0, etl, manager);
  }

  return manager;
}

/*************************************************/
/* ica_manager_destroy()                         */
/*                                               */
/* Destroys an an ica_manager structure.         */
/*                                               */
/* Parameters: the structure to destroy.         */
/*************************************************/

void ica_manager_destroy(ica_manager *manager)
{
  if (!manager) return;

  show_error_ret(event_deregister_toolbox_handlers_for_object(manager->mainwindow_id));
  show_error_ret(event_deregister_wimp_handlers_for_object (manager->mainwindow_id));
  show_error_ret(toolbox_delete_object(0, manager->mainwindow_id));

  while(manager->connect_head)
  {
    ica_connection *temp = manager->connect_head;
    ica_connection_unlink(temp,
                          &manager->connect_head,
                          &manager->connect_tail);
    ica_connection_destroy(temp);
  }

  while(manager->ini_head)
  {
    ini_section *temp = manager->ini_head;
    ini_section_unlink(temp, &manager->ini_head, &manager->ini_tail);
    ini_section_destroy(temp);
  }

  if (manager->settings.cache_directory) free(manager->settings.cache_directory);

  free(manager);
}

/*************************************************/
/* manager_get_toolbar_heights()                 */
/*************************************************/

static _kernel_oserror *manager_get_toolbar_heights(ica_manager *manager, int *top, int *bottom)
{
  _kernel_oserror *e;
  ObjectId ibl, itl;
  BBox     extent;

  e = window_get_tool_bars(3, manager->mainwindow_id, &ibl, &itl, NULL, NULL);
  if (e) return e;

  if (top)
  {
    if (itl != NULL_ObjectId && (e = window_get_extent(0, itl, &extent)) == NULL)
      *top = (extent.ymax - extent.ymin) + HEADER_HEIGHT;
    else
      *top = 0;
  }

  if (bottom)
  {
    if (ibl != NULL_ObjectId && (e = window_get_extent(0, ibl, &extent)) == NULL)
    {
      *bottom = extent.ymax - extent.ymin;
    }
    else
    {
      *bottom = 0;
    }
  }

  return NULL;
}

/*************************************************/
/* manager_open_headings_window()                */
/*************************************************/

static _kernel_oserror *manager_open_headings_window(ica_manager *manager)
{
  _kernel_oserror         * e;
  WimpGetWindowStateBlock   state;
  BBox                      extent;
  WindowShowObjectBlock     showblock;
  int                       itlheight;

  if ((e = manager_get_toolbar_heights(manager, &itlheight, NULL)) != NULL)
    return e;
  if ((e = window_get_wimp_handle(0, manager->mainwindow_id, &state.window_handle)) != NULL)
    return e;
  if ((e = wimp_get_window_state(&state)) != NULL)
    return e;
  if ((e = window_get_extent(0, manager->mainwindow_id, &extent)) != NULL)
    return e;

  showblock.visible_area.xmin    = coords_x_toscreen(extent.xmin, (WimpRedrawWindowBlock*)&state);
  showblock.visible_area.xmax    = coords_x_toscreen(extent.xmax, (WimpRedrawWindowBlock*)&state);
  showblock.visible_area.ymin    = state.visible_area.ymax - itlheight;
  showblock.visible_area.ymax    = state.visible_area.ymax - itlheight + HEADER_HEIGHT;
  showblock.xscroll              = 0;
  showblock.yscroll              = 0;
  showblock.behind               = -1;
  showblock.window_flags         = 0;
  showblock.alignment_flags      = WimpLink_TopToTop | WimpLink_BottomToTop;
  showblock.parent_window_handle = state.window_handle;

  return toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
                             manager->headwindow_id,
                             Toolbox_ShowObject_FullSpec,
                             &showblock,
                             manager->mainwindow_id,
                             NULL_ComponentId);
}

/*************************************************/
/* manager_openwin_handler()                     */
/*                                               */
/* Opens the manager window and headings sub     */
/* window.                                       */
/*                                               */
/* Parameters: as WimpEventHandler.              */
/*************************************************/

static int manager_openwin_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handler)
{
  if (show_error_ret(toolbox_show_object(0,
                                         id_block->self_id,
                                         Toolbox_ShowObject_FullSpec,
                                         &(event->open_window_request.visible_area),
                                         id_block->parent_id,
                                         id_block->parent_component)))
    return 1;

  show_error_ret(manager_open_headings_window((ica_manager*)handler));

  return 1;
}

/*************************************************/
/* manager_check_connect()                       */
/*                                               */
/* This function is used to determine whether a  */
/* connection entry is intersected by a bounding */
/* line.                                         */
/*                                               */
/* Parameters: the manager which the entry       */
/*             belongs to;                       */
/*                                               */
/*             the entry;                        */
/*                                               */
/*             the minimum x coord of the        */
/*             selection box;                    */
/*                                               */
/*             the maximum x coord of the        */
/*             selection box.                    */
/*                                               */
/* Returns:    1 if the box intersects the entry */
/*             0 otherwise.                      */
/*************************************************/

static int manager_check_connect(ica_manager *manager, ica_connection *item, int xmin, int xmax)
{
  _kernel_oserror *e;
  int txmin, txmax, width;

  if (xmin > xmax) SWAP(xmin, xmax);

  e = _swix(Wimp_TextOp, _INR(0, 2) | _OUT(0), 1, item->description, 0, &width);
  if (!e && width)
  {
    txmin = DESC_XMIN(manager);
    txmax = MIN(txmin + width + 24, DESC_XMAX(manager));
    if (!(xmax < txmin || xmin > txmax)) return 1;
  }

  e = _swix(Wimp_TextOp, _INR(0, 2) | _OUT(0), 1, item->server, 0, &width);
  if (!e && width)
  {
    txmin = SERV_XMIN(manager);
    txmax = MIN(txmin + width + 24, SERV_XMAX(manager));
    if (!(xmax < txmin || xmin > txmax)) return 1;
  }

  return 0;
}

/*************************************************/
/* manager_draw_items()                          */
/*                                               */
/* Draws a collection of connection entries in   */
/* the current window.                           */
/*                                               */
/* Parameters: the manager;                      */
/*                                               */
/*             the first item to draw;           */
/*                                               */
/*             the last item to draw.            */
/*************************************************/

static _kernel_oserror *manager_draw_items(ica_manager  * manager,
                                           unsigned int   first,
                                           unsigned int   last)
{
  _kernel_oserror * e = NULL;
  ica_connection  * current_connection = manager->connect_head;
  WimpIconBlock     icon_block;
  int               item_no;

  icon_block.data.it.validation  = "";

  item_no = 0;

  while(current_connection &&
        item_no <= last    &&
        !e)
  {
    if (item_no >= first)
    {
      icon_block.data.it.buffer_size = strlen(current_connection->description) + 1;
      icon_block.data.it.buffer = current_connection->description;
      icon_block.flags          = current_connection->app_selected ^ current_connection->app_highlighted ?
                                    TEXT_ICON_FLAGS_SELECTED : TEXT_ICON_FLAGS_UNSELECTED;
      icon_block.bbox.xmin      = DESC_XMIN(manager);
      icon_block.bbox.xmax      = DESC_XMAX(manager);
      icon_block.bbox.ymax      = -(ITEM_HEIGHT * item_no) - 2;
      icon_block.bbox.ymin      = -(ITEM_HEIGHT * item_no) - ITEM_HEIGHT + 2;

      e = wimp_plot_icon(&icon_block);

      icon_block.data.it.buffer_size = strlen(current_connection->server) + 1;
      icon_block.data.it.buffer = current_connection->server;
      icon_block.bbox.xmin      = SERV_XMIN(manager);
      icon_block.bbox.xmax      = SERV_XMAX(manager);
      e = wimp_plot_icon(&icon_block);
    }

    current_connection = current_connection->next;
    item_no++;
  }

  return e;
}

/*************************************************/
/* manager_redraw_handler()                      */
/*                                               */
/* Handles redraw requests for the manager       */
/* window, calling manager_draw_items to do all  */
/* the dirty work.                               */
/*                                               */
/* Parameters: as WimpEventHandler.              */
/*************************************************/

static int manager_redraw_handler(int event_code,
                                  WimpPollBlock *event,
                                  IdBlock *id_block,
                                  void *handler)
{
  _kernel_oserror       * e;
  WimpRedrawWindowBlock   block;
  int                     more;
  int ymin, ymax;
  int first, last;

  block.window_handle = event->redraw_window_request.window_handle;

  e = wimp_redraw_window(&block, &more);
  while(more && !e)
  {
    /* Draw stuff */
    ymax = coords_y_toworkarea(block.redraw_area.ymax, &block);
    ymin = coords_y_toworkarea(block.redraw_area.ymin, &block);

    if (ymax >0) first = 0;
    else         first = -ymax / ITEM_HEIGHT;
    last  = (-ymin) / ITEM_HEIGHT + 1;
    if (last >=0) e = manager_draw_items((ica_manager*)handler, first, last);

    if (!e) e = wimp_get_rectangle(&block, &more);
  }

  show_error_ret(e);

  return 1;
}

/*************************************************/
/* manager_redraw_items()                        */
/*                                               */
/* Forces a redraw of a range of entries in the  */
/* manager window.                               */
/*                                               */
/* Parameters: the manager;                      */
/*                                               */
/*             the first entry;                  */
/*                                               */
/*             the last entry.                   */
/*************************************************/

_kernel_oserror *manager_redraw_items(ica_manager *manager,
                                      unsigned int first,
                                      unsigned int last)
{
  _kernel_oserror *e;
  BBox redraw_box;

  e = window_get_extent(0, manager->mainwindow_id, &redraw_box);
  if (!e)
  {
    redraw_box.ymax = -first * ITEM_HEIGHT;
    redraw_box.ymin = (-last  * ITEM_HEIGHT) - ITEM_HEIGHT;
    e = window_force_redraw(0, manager->mainwindow_id, &redraw_box);
  }

  return e;
}


/*************************************************/
/* manager_set_height()                          */
/*                                               */
/* Sets the height of the manager window based   */
/* on the height of both internal toolbars and   */
/* the number of entries.                        */
/*                                               */
/* Parameters: the manager;                      */
/*************************************************/

static _kernel_oserror *manager_set_height(ica_manager *manager)
{
  _kernel_oserror *e;
  int      bottom_height, top_height;
  int      itemheights = 0;
  BBox     extent;
  ica_connection *curcon;

  curcon = manager->connect_head;
  while(curcon)
  {
    itemheights -= ITEM_HEIGHT;
    curcon = curcon->next;
  }

  e = manager_get_toolbar_heights(manager, &top_height, &bottom_height);
  if (!e)
  {
    e = window_get_extent(0, manager->mainwindow_id, &extent);
    if (!e)
    {
      if (itemheights > -(ITEM_HEIGHT * MIN_HEIGHT)) itemheights = -(ITEM_HEIGHT * MIN_HEIGHT);

      extent.ymax = top_height;
      extent.ymin = itemheights - bottom_height;

      e = window_set_extent(0, manager->mainwindow_id, &extent);
    }
  }
  return e;
}

/*************************************************/
/* manager_show()                                */
/*                                               */
/* Shows the manager window.                     */
/*                                               */
/* Parameters: the manager;                      */
/*************************************************/

_kernel_oserror *manager_show(ica_manager *manager)
{
  WindowShowObjectBlock   showblock;
  BBox                    extent;
  _kernel_oserror *e;

  e = manager_select_clear(manager);
  if (!e)
  {
    e = manager_set_height(manager);
    manager_set_buttons(manager);
    window_get_extent(0, manager->mainwindow_id, &extent);
    showblock.visible_area = extent;
    showblock.behind       = -3;
    showblock.xscroll      = 0;
    showblock.yscroll      = 0;
    e = toolbox_show_object(0, manager->mainwindow_id, Toolbox_ShowObject_FullSpec, &showblock, NULL_ObjectId, NULL_ComponentId);
    if (!e) e = toolbox_show_object(0, manager->mainwindow_id, Toolbox_ShowObject_Centre, NULL, NULL_ObjectId, NULL_ComponentId);
    if (!e) manager_open_headings_window(manager);
  }

  return e;
}

/*************************************************/
/* manager_select_clear()                        */
/*                                               */
/* Unselects all entries in the manager window   */
/* and forces a redraw of the appropriate areas. */
/*                                               */
/* Parameters: the manager;                      */
/*************************************************/

static _kernel_oserror *manager_select_clear(ica_manager *manager)
{
  _kernel_oserror * e = NULL;
  ica_connection  * connect = manager->connect_head;
  int               itemno = 0;

  while(connect && !e)
  {
    if (connect->app_selected)
    {
      connect->app_selected = 0;
      e = manager_redraw_items(manager, itemno, itemno);
    }
    itemno++;
    connect = connect->next;
  }

  manager->no_selected = 0;

  return e;
}

/*************************************************/
/* manager_select_all()                          */
/*                                               */
/* Selects all entries in the manager window     */
/* and forces a redraw of the appropriate areas. */
/*                                               */
/* Parameters: the manager;                      */
/*************************************************/

static _kernel_oserror *manager_select_all(ica_manager *manager)
{
  _kernel_oserror * e = NULL;
  ica_connection  * connect = manager->connect_head;
  int               itemno = 0;

  manager->no_selected = 0;

  while(connect && !e)
  {
    if (!connect->app_selected)
    {
      connect->app_selected = 1;
      e = manager_redraw_items(manager, itemno, itemno);
    }

    manager->no_selected++;

    itemno++;
    connect = connect->next;
  }

  return e;
}

/*************************************************/
/* manager_click_handler()                       */
/*                                               */
/* Handles clicks on in the manager window.      */
/*                                               */
/* Parameters: as ToolboxEventHandler.           */
/*************************************************/

static int manager_click_handler(int event_code,
                                 WimpPollBlock *event,
                                 IdBlock *id_block,
                                 void *handler)
{
  ica_manager *manager = (ica_manager*) handler;
  WimpGetWindowStateBlock state;
  int xpos, ypos;
  int itemno;
  ica_connection *item;

  state.window_handle = event->mouse_click.window_handle;
  if (show_error_ret(wimp_get_window_state(&state)))
    return 1;
  if (show_error_ret(wimp_set_caret_position(state.window_handle, -1, 0, 0, -1, -1)))
    return 1;

  xpos = event->mouse_click.mouse_x + (state.xscroll - state.visible_area.xmin);
  ypos = event->mouse_click.mouse_y + (state.yscroll - state.visible_area.ymax);

  itemno = -(ypos / ITEM_HEIGHT);

  item = ica_connection_get_by_no(manager->connect_head, itemno);

  if (item && manager_check_connect(manager, item, xpos, xpos))
  {
    switch(event->mouse_click.buttons)
    {
      /* Double click with Select */
      case Wimp_MouseButtonSelect:
        if (itemno == manager->last_selected_item)
        {
          item->app_selected = 0;
          if (show_error_ret(manager_redraw_items(manager, itemno, itemno)))
            return 1;
          if (show_error_ret(ica_connection_launch(item)))
            return 1;
          manager->no_selected--;
        }
        break;

      /* Double click with Adjust */
      case Wimp_MouseButtonAdjust:
        if (itemno == manager->last_selected_item)
        {
          if (show_error_ret(ica_connection_launch(item)))
            return 1;
          if (show_error_ret(toolbox_hide_object(0, manager->mainwindow_id)))
            return 1;
        }
        break;

      /* Click with Select */
      case 1024:
        if (!item->app_selected)
        {
          if (show_error_ret(manager_select_clear(manager)))
            return 1;
          item->app_selected = 1;
          if (show_error_ret(manager_redraw_items(manager, itemno, itemno)))
            return 1;
          manager->no_selected = 1;
        }
        manager->last_selected_item = itemno;
        break;

      /* Click with Adjust */
      case 256:
        item->app_selected = !item->app_selected;
        if (show_error_ret(manager_redraw_items(manager, itemno, itemno)))
          return 1;
        manager->last_selected_item = itemno;
        if (item->app_selected) manager->no_selected++;
        else                    manager->no_selected--;
        break;

      default:
        break;
    }
  }
  else
  {
    switch(event->mouse_click.buttons)
    {
      /* Drag with Select */
      case 64:
        if (show_error_ret(manager_select_clear(manager)))
          return 1;
        manager_start_selection_drag(manager);
        break;

      /* Drag with Adjust */
      case 16:
        manager_start_selection_drag(manager);
        break;

      /* Click with Select */
      case 1024:
        if (show_error_ret(manager_select_clear(manager)))
          return 1;
        manager->last_selected_item = NOT_AN_ITEM;
        break;

      /* Click with Adjust */
      case 256:
        manager->last_selected_item = NOT_AN_ITEM;
        break;
    }
  }

  manager_set_buttons(manager);

  return 1;
}

/*************************************************/
/* manager_null_drag_handler()                   */
/*                                               */
/* Handles selection/unselection of items during */
/* a drag.                                       */
/*                                               */
/* Parameters: the manager.                      */
/*************************************************/

static int manager_null_drag_handler(int             event_code,
                                     WimpPollBlock * event,
                                     IdBlock       * id_block,
                                     void          * handle)
{
  WimpGetPointerInfoBlock   pointerblock;
  WimpGetWindowStateBlock   state;
  ica_manager             * manager = (ica_manager*)handle;
  ica_connection          * connect = manager->connect_head;
  int                       itemnomin;
  int                       itemnomax;
  int                       workx;
  int                       itemno = 0;
  int                       xmin;
  int                       xmax;

  if (show_error_ret(wimp_get_pointer_info(&pointerblock)))
    return 1;
  if (show_error_ret(window_get_wimp_handle(0, manager->mainwindow_id, &state.window_handle)))
    return 1;
  if (show_error_ret(wimp_get_window_state(&state)))
    return 1;

  workx = pointerblock.x + (state.xscroll - state.visible_area.xmin);
  itemnomin = -(pointerblock.y + (state.yscroll - state.visible_area.ymax)) / ITEM_HEIGHT;

  if (itemnomin > manager->app_dragitemno)
  {
    itemnomax = itemnomin;
    itemnomin = manager->app_dragitemno;
  }
  else
  {
    itemnomax = manager->app_dragitemno;
  }

  if (workx < manager->app_dragx)
  {
    xmin = workx;
    xmax = manager->app_dragx;
  }
  else
  {
    xmin = manager->app_dragx;
    xmax = workx;
  }

  while(connect)
  {
    if (itemno >= itemnomin &&
        itemno <= itemnomax &&
        manager_check_connect(manager, connect, xmin, xmax))
    {
      if (!connect->app_highlighted)
      {
        connect->app_highlighted = 1;
        show_error_ret(manager_redraw_items(manager, itemno, itemno));
        manager->no_selected++;
      }
    }
    else
    {
      if (connect->app_highlighted)
      {
        connect->app_highlighted = 0;
        show_error_ret(manager_redraw_items(manager, itemno, itemno));
        manager->no_selected--;
      }
    }

    connect = connect->next;
    itemno++;
  }

  manager_set_buttons(manager);

  return 1;
}

/*************************************************/
/* manager_selectdrag_done_handler()             */
/*                                               */
/* Initiates a drag selection.                   */
/*                                               */
/* Parameters: the manager.                      */
/*************************************************/

static int manager_selectdrag_done_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
  ica_manager    * manager = (ica_manager*)handle;
  ica_connection * connect = manager->connect_head;

  while(connect)
  {
    if (connect->app_highlighted)
    {
      connect->app_selected ^= 1;
    }

    connect->app_highlighted = 0;
    connect = connect->next;
  }

  show_error_ret(event_deregister_wimp_handler(NULL_ObjectId,
                                               Wimp_EUserDrag,
                                               manager_selectdrag_done_handler,
                                               manager));

  disable_nulls();
  show_error_ret(event_deregister_wimp_handler(NULL_ObjectId,
                                               Wimp_ENull,
                                               manager_null_drag_handler,
                                               manager));

  return 1;
}


/*************************************************/
/* manager_start_selection_drag()                */
/*                                               */
/* Initiates a drag selection.                   */
/*                                               */
/* Parameters: the manager.                      */
/*************************************************/

static _kernel_oserror *manager_start_selection_drag(ica_manager *manager)
{
  WimpGetPointerInfoBlock   pointerblock;
  WimpGetWindowStateBlock   state;
  WimpDragBox               dragbox;
  _kernel_oserror         * e;
  int                       top_height;
  int                       bottom_height;

  e = wimp_get_pointer_info(&pointerblock);
  if (!e) e = window_get_wimp_handle(0, manager->mainwindow_id, &state.window_handle);
  if (!e) e = wimp_get_window_state(&state);
  if (!e) e = manager_get_toolbar_heights(manager, &top_height, &bottom_height);
  if (!e)
  {
    manager->app_dragx = pointerblock.x + (state.xscroll - state.visible_area.xmin);
    manager->app_dragitemno = -(pointerblock.y + (state.yscroll - state.visible_area.ymax)) / ITEM_HEIGHT;

    dragbox.wimp_window       = state.window_handle;
    dragbox.drag_type         = Wimp_DragBox_DragRubberDash;
    dragbox.dragging_box.xmin = pointerblock.x;
    dragbox.dragging_box.xmax = pointerblock.x;
    dragbox.dragging_box.ymin = pointerblock.y;
    dragbox.dragging_box.ymax = pointerblock.y;

    dragbox.parent_box.xmin   = state.visible_area.xmin;
    dragbox.parent_box.xmax   = state.visible_area.xmax;
    dragbox.parent_box.ymin   = state.visible_area.ymin + bottom_height;
    dragbox.parent_box.ymax   = state.visible_area.ymax - top_height;

    e = event_register_wimp_handler(NULL_ObjectId,
                                    Wimp_EUserDrag,
                                    manager_selectdrag_done_handler,
                                    manager);

    enable_nulls();

    if (!e) e = event_register_wimp_handler(NULL_ObjectId,
                                            Wimp_ENull,
                                            manager_null_drag_handler,
                                            manager);

    if (!e) e = wimp_drag_box(&dragbox);
  }

  return e;
}

/*************************************************/
/* manager_set_buttons()                         */
/*                                               */
/* Greys and ungreys buttons on the managers     */
/* toolbar where appropriate.                    */
/*                                               */
/* Parameters: the manager.                      */
/*************************************************/

static void manager_set_buttons(ica_manager *manager)
{
  _kernel_oserror * e;
  ObjectId          itl;

  e = show_error_ret(window_get_tool_bars(2, manager->mainwindow_id, NULL, &itl, NULL, NULL));

  if (!e && itl != NULL_ObjectId)
  {
    set_gadget_state(itl, MANAGER_TOOLBAR_DELETE,  manager->no_selected >= 1 ? 0 : 1);
    set_gadget_state(itl, MANAGER_TOOLBAR_CONNECT, manager->no_selected == 1 ? 0 : 1);
    set_gadget_state(itl, MANAGER_TOOLBAR_EDIT,    manager->no_selected == 1 ? 0 : 1);
    set_gadget_state(itl, MANAGER_TOOLBAR_COPY,    manager->no_selected == 1 ? 0 : 1);
  }
}

/*************************************************/
/* ica_manager_menu_set()                        */
/*                                               */
/* Called to set the menu entries to (un)greyed  */
/* depending upon the number of selected items.  */
/*                                               */
/* Parameters: the ica_manager to which the menu */
/*             belongs;                          */
/*                                               */
/*             the menus ObjectId.               */
/*************************************************/

_kernel_oserror *ica_manager_menu_set(ica_manager *manager,
                                      ObjectId menu_id)
{
  ObjectId submenu_id;

  menu_set_fade(0, menu_id, MANAGER_MENU_SELECTCLEAR, manager->no_selected > 0 ? 0 : 1);
  menu_set_fade(0, menu_id, MANAGER_MENU_SELECTION,   manager->no_selected > 0 ? 0 : 1);

  if (manager->no_selected == 1)
  {
    menu_set_entry_text(0, menu_id, MANAGER_MENU_SELECTION, "Connection");
    toolbox_create_object(0, "Server", &submenu_id);
  }
  else
  {
    menu_set_entry_text(0, menu_id, MANAGER_MENU_SELECTION, "Selection");
    toolbox_create_object(0, "Selection", &submenu_id);
  }
  menu_set_sub_menu_show(0, menu_id, MANAGER_MENU_SELECTION, submenu_id);
  toolbox_set_client_handle(0, submenu_id, manager);

  return NULL;
}

/*************************************************/
/* ica_manager_menu_shown()                      */
/*                                               */
/* Called when the ica_managers main menu is     */
/* opened.                                       */
/*************************************************/

int ica_manager_menu_shown(int event_code,
                           ToolboxEvent *event,
                           IdBlock *id_block,
                           void *handle)
{
  ica_manager *manager;

  if (show_error_ret(toolbox_get_client_handle(0, id_block->ancestor_id, (void*)&manager)))
    return 1;
  if (show_error_ret(toolbox_set_client_handle(0, id_block->self_id, manager)))
    return 1;
  show_error_ret(ica_manager_menu_set(manager, id_block->self_id));

  return 1;
}

/*************************************************/
/* ica_manager_select_all_handler()              */
/*                                               */
/* Selects all items in the ica_managers display */
/* and modifies the menu and buttons to reflect  */
/* the change.                                   */
/*************************************************/

int ica_manager_select_all_handler(int event_code,
                                   ToolboxEvent *event,
                                   IdBlock *id_block,
                                   void *handle)
{
  ObjectId     menu_id;
  ica_manager *manager;
  if (show_error_ret(toolbox_get_client_handle(0, id_block->self_id, (void*)&manager)))
    return 1;

  manager_select_all(manager);
  toolbox_create_object(0, "Main", &menu_id);
  if (id_block->self_id == menu_id)
  {
    ica_manager_menu_set(manager, id_block->self_id);
  }
  else
  {
    wimp_create_menu((void*)-1, 0, 0);
  }
  manager_set_buttons(manager);

  return 1;
}

/*************************************************/
/* ica_manager_select_clear_handler()            */
/*                                               */
/* Unselects all items in the ica_managers       */
/* display and modifies the menu and buttons to  */
/* reflect the change.                           */
/*************************************************/

int ica_manager_select_clear_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
  ObjectId     menu_id;
  ica_manager *manager;
  if (show_error_ret(toolbox_get_client_handle(0, id_block->self_id, (void*)&manager)))
    return 1;

  manager_select_clear(manager);

  if (show_error_ret(toolbox_create_object(0, "Main", &menu_id)))
    return 1;
  if (id_block->self_id == menu_id)
  {
    ica_manager_menu_set(manager, id_block->self_id);
  }
  else
  {
    wimp_create_menu((void*)-1, 0, 0);
  }
  manager_set_buttons(manager);

  return 1;
}

/*************************************************/
/* ica_manager_delete_selection()                */
/*                                               */
/* Deletes all selected connections in the       */
/* ica_manager structure.                        */
/*                                               */
/* Parameters: the ica_manager structure.        */
/*************************************************/

void ica_manager_delete_selection(ica_manager *manager)
{
  ica_connection *connect, *temp;
  int no, first;
  connect = manager->connect_head;

  no = 0;
  first = -1;

  while(connect)
  {
    temp = connect->next;
    if (connect->app_selected)
    {
      ica_connection_unlink(connect, &manager->connect_head, &manager->connect_tail);
      ica_connection_destroy(connect);
      if (first == -1) first = no;
    }
    connect = temp;
    no++;
  }

  if (first != -1) manager_redraw_items(manager, first, NOT_AN_ITEM);

  manager->no_selected = 0;
  manager_set_buttons(manager);
  manager_set_height(manager);
  show_error_ret(toolbox_show_object(0,
                                     manager->mainwindow_id,
                                     Toolbox_ShowObject_Default,
                                     NULL,
                                     NULL_ObjectId,
                                     NULL_ComponentId));
}

/*************************************************/
/* ica_manager_delete_handler()                  */
/*                                               */
/* calls ica_manager_delete_selection to delete  */
/* items in response to a delete selection       */
/* event.                                        */
/*************************************************/

int ica_manager_delete_handler(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
  ica_manager *manager;
  if (show_error_ret(toolbox_get_client_handle(0, id_block->self_id, (void*)&manager)))
    return 1;

  ica_manager_delete_selection(manager);

  /* Close any open menus */
  wimp_create_menu((void*)-1, 0, 0);

  return 1;
}

/*************************************************/
/* ica_manager_edit_handler()                    */
/*                                               */
/* Calls ica_connection_edit to edit the         */
/* selected connection in response to an edit    */
/* event.                                        */
/*************************************************/

int ica_manager_edit_handler(int event_code,
                             ToolboxEvent *event,
                             IdBlock *id_block,
                             void *handle)
{
  ica_connection * connect;
  ica_manager    * manager;

  if (show_error_ret(toolbox_get_client_handle(0, id_block->self_id, (void*)&manager)))
    return 1;

  if (manager->no_selected == 1)
  {
    connect = ica_connection_get_selected(manager->connect_head);
    if (connect) ica_connection_edit(connect, manager);
  }

  return 1;
}

/*************************************************/
/* ica_manager_new_handler()                     */
/*                                               */
/* Calls ica_connect_new_window to create a new  */
/* `create new connection' window in response to */
/* a `new connection' event.                     */
/*************************************************/

int ica_manager_new_handler(int event_code,
                            ToolboxEvent *event,
                            IdBlock *id_block,
                            void *handle)
{
  ica_manager * manager;
  ComponentId   comp_id;
  ObjectId      obj_id;
  if (show_error_ret(toolbox_get_client_handle(0, id_block->self_id, (void*)&manager)))
    return 1;

  if (manager->newconwindow_id == NULL_ObjectId)
  {
    manager->newconwindow_id = ica_connect_new_window(NULL, manager);
  }
  else
  {
    /* Bring window to front */
    toolbox_get_parent(0, manager->newconwindow_id, &obj_id, &comp_id);
    toolbox_show_object(0,
                        manager->newconwindow_id,
                        Toolbox_ShowObject_Default,
                        NULL,
                        obj_id,
                        comp_id);
  }

  return 1;
}

/*************************************************/
/* ica_manager_write_APPSVR()                    */
/*                                               */
/* This function writes out the connections held */
/* within an ica_manager structure as an APPSVR  */
/* INI file to the passed iostream.              */
/*                                               */
/* Parameters: the manager which contains the    */
/*             connections;                      */
/*                                               */
/*             the output stream.                */
/*************************************************/

_kernel_oserror *ica_manager_write_APPSVR(ica_manager *manager, FILE *out)
{
  ica_connection *connect;
  time_t          timer;

  if (out)
  {
    fprintf(out, ";**********************************************************************\n");
    fprintf(out, ";**\n");
    fprintf(out, ";** APPSVR.INI - Application Server Configuration File.\n");
    fprintf(out, ";**\n");
    fprintf(out, ";** This file contains user settings which define application servers.\n");
    fprintf(out, ";**\n");
    fprintf(out, ";**********************************************************************\n\n");

    fprintf(out, "[ApplicationServers]\n");
    connect = manager->connect_head;
    while(connect)
    {
      fprintf(out, "%s=\n", connect->description);
      connect = connect->next;
    }
    fprintf(out, "\n");

    connect = manager->connect_head;
    while(connect)
    {
      fprintf(out, "[%s]\n",                      connect->description);
      fprintf(out, "InitialProgram=%s\n",         connect->application);
      fprintf(out, "WorkDirectory=%s\n",          connect->working_dir);
      fprintf(out, "Address=%s\n",                connect->server);
      fprintf(out, "PersistentCacheEnabled=%s\n", connect->use_disc_cache ? "on" : "off");
      fprintf(out, "Username=%s\n",               connect->username);
      fprintf(out, "Domain=%s\n",                 connect->domain);
      fprintf(out, "Password=%s\n",               connect->password);
      fprintf(out, "DesiredHRes=%d\n",            connect->screen_width);
      fprintf(out, "DesiredVRes=%d\n",            connect->screen_height);
      fprintf(out, "DesiredColor=%d\n",           connect->screen_colours);
      ini_write_entries(connect->ini_head, out);
      fprintf(out, "\n");

      connect = connect->next;
    }
    time(&timer);
    /* No need for newline, asctime produces one */
    fprintf(out, "; Created : %s", asctime(localtime(&timer)));
  }

  return NULL;
}

/*************************************************/
/* ica_manager_write_WFCLIENT_callback()         */
/*                                               */
/* This function is called by the                */
/* ini_write_sections function at the beginning  */
/* of each new section within an INI file.  It   */
/* is used to write information which is not     */
/* held within the ini structure during the      */
/* course of the program.                        */
/*                                               */
/* Parameters: the ini section which is          */
/*             currently being written;          */
/*                                               */
/*             the output stream;                */
/*                                               */
/*             the ica_manager for which the     */
/*             section is being written.         */
/*************************************************/

static void ica_manager_write_WFCLIENT_callback(ini_section *section,
                                                FILE *outfile,
                                                void *function_param)
{
  ica_manager           * manager      = (ica_manager*)function_param;
  manager_section_types   section_type = (manager_section_types)map_name_to_number(&mgr_maps, section->name);

  switch(section_type)
  {
    case MGR_THINWIRE3_0:
      /* Write entries which belong in section `Thinwire3.0' */
      fprintf(outfile, "DesiredHRES=%d\n", manager->settings.screen_width);
      fprintf(outfile, "DesiredVRES=%d\n", manager->settings.screen_height);
      fprintf(outfile, "DesiredColor=%d\n", manager->settings.screen_colours);
      break;

    case MGR_WFCLIENT:
      /* Write entries which belong in section `WFClient' */
      fprintf(outfile, "PersistentCachePath=%s\n", manager->settings.cache_directory);
      fprintf(outfile, "PersistentCacheMinBitmap=%d\n", manager->settings.cache_smallest);
      fprintf(outfile, "PersistentCacheSize=%d\n", manager->settings.cache_diskuse);
      break;

    case MGR_number:
      /* unrecognised section, write nothing */
      break;
  }
}

/*************************************************/
/* ica_manager_write_WFCLIENT()                  */
/*                                               */
/* This function writes out the global settings  */
/* held within an ica_manager structure as a     */
/* WFCLIENT INI file to the passed iostream.     */
/*                                               */
/* Parameters: the manager which contains the    */
/*             settings;                         */
/*                                               */
/*             the output stream.                */
/*************************************************/

_kernel_oserror *ica_manager_write_WFCLIENT(ica_manager *manager, FILE *out)
{
  time_t          timer;

  if (out)
  {
    fprintf(out, ";**********************************************************************\n");
    fprintf(out, ";**\n");
    fprintf(out, ";** WFCLIENT.INI - WinFrame Client Configuration File.\n");
    fprintf(out, ";**\n");
    fprintf(out, ";** This file contains initialization information for the\n");
    fprintf(out, ";** WinFrame Client program.\n");
    fprintf(out, ";**\n");
    fprintf(out, ";**********************************************************************\n\n");

    /* Write out all ini sections using ica_manager_write_WFCLIENT_callback */
    /* to add entries which are held as data within the ica_manager struct. */
    ini_write_sections(manager->ini_head, out,
                       ica_manager_write_WFCLIENT_callback,
                       manager);

    time(&timer);
    /* No need for newline, asctime produces one */
    fprintf(out, "; Created : %s", asctime(localtime(&timer)));
  }

  return NULL;
}

/*************************************************/
/* ica_manager_get_settings()                    */
/*                                               */
/* Takes the settings from the appropriate INI   */
/* entries and places them in the manager        */
/* structure removing the INI entries that are   */
/* used.                                         */
/*                                               */
/* Parameters: the ica_manager structure.        */
/*************************************************/

_kernel_oserror *ica_manager_get_settings(ica_manager *manager)
{
  ini_section * section;
  ini_entry   * entry, * temp;

  section = ini_section_find(manager->ini_head, "Thinwire3.0");
  if (section)
  {
    entry = section->entry_head;
    while(entry)
    {
      thinwire_entry_types type = (thinwire_entry_types)map_name_to_number(&thinwire_maps, entry->tag);
      temp = entry->next;

      switch(type)
      {
        case THIN_COLOURS:
          manager->settings.screen_colours = atoi(entry->value);
          break;
        case THIN_HRES:
          manager->settings.screen_width = atoi(entry->value);
          break;
        case THIN_VRES:
          manager->settings.screen_height = atoi(entry->value);
          break;
      }

      if (type != THIN_number)
      {
         ini_entry_unlink(entry, &section->entry_head, &section->entry_tail);
         ini_entry_destroy(entry);
      }
      /* If entry is recognised place the data in the manager structure and remove the entry */

      entry = temp;
    }
  }
  else
  {
    /* Create the Thinwire3.0 section so it can be saved later */
    section = ini_section_create("Thinwire3.0");
    if (!section) return misc_error("Insufficient memory");
    ini_section_link(section,
                     &manager->ini_head,
                     &manager->ini_tail,
                     NULL,
                     LIST_BEGIN);
  }

  section = ini_section_find(manager->ini_head, "WFClient");
  if (section)
  {
    entry = section->entry_head;
    while(entry)
    {
      wfclient_entry_types type = (wfclient_entry_types)map_name_to_number(&wfclient_maps, entry->tag);
      temp = entry->next;

      switch(type)
      {
        case WFCLIENT_CACHE_SMALLEST:
          manager->settings.cache_smallest = atoi(entry->value);
          break;
        case WFCLIENT_CACHE_PATH:
          manager->settings.cache_directory = entry->value;
          entry->value = NULL;
          break;
        case WFCLIENT_CACHE_DISKUSE:
          manager->settings.cache_diskuse = atoi(entry->value);
          break;
      }

      if (type != WFCLIENT_number)
      {
         ini_entry_unlink(entry, &section->entry_head, &section->entry_tail);
         ini_entry_destroy(entry);
      }

      entry = temp;
    }
  }
  else
  {
    /* Create the WFClient section so it can be saved later */
    section = ini_section_create("WFCLient");
    if (!section) return misc_error("Insufficient memory");
    ini_section_link(section,
                     &manager->ini_head,
                     &manager->ini_tail,
                     NULL,
                     LIST_BEGIN);
  }

  return NULL;
}
