; TIFF converter

	GBLL	names
names	SETL	{TRUE}
	GBLL	VDEBUG
VDEBUG	SETL	{FALSE}
        GBLA    DFILE
DFILE	SETA	251
	GBLL	old
old	SETL	{FALSE}
;;;	GBLL	ARMdebug
;;;ARMdebug	SETL	{FALSE}
isfirst		EQU	(1:SHL:0)
ishandle	EQU	(1:SHL:1)
reverseit	EQU	(1:SHL:2)
addit		EQU	(1:SHL:24) ; Must be 24; see writeraw
cola0		EQU	(1:SHL:0)
colb1		EQU	(1:SHL:16) ; Must be 16 off from cola0; see enc_findb1

	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	hdr.CVars



; Key:
; (-) means routine doesn't access value at all
; (R) means routine reads value but doesn't squash it
; (W) means routine squashes old value without looking at it
; (R/W) means routine reads old value and then squashes it
; ** CHECK THE APCS routines more carefully
; ** and define clearly what the above means for them
; ** Do the 2D decode routines

Rreasoncode	RN	0	; decode1d:
				; -huntforeol
				; waitforeol (W)
				; decode1d (-)
				; d1drun (-)
				; decode_1dtoraw (-)
;Rbget		RN	0	; decode1d:
;				; fillup (W; preserved across call)
Rreturncode	RN	0	; decode1d:
				; d1drun (W: if error)
				; decode_1dtoraw (W: only at end)
Rfound2D	RN	0	; decode2d:
Rcodelen	RN	0	; encode1d:
				; spool (R/W)
				; encode_rawto1d (W)
Rscalelinein	RN	0	; hscale

Rdecindexcom	RN	1	; decode1d:
				; fillup (R/W)
				; -huntforeol
				; waitforeol (R)
				; decode1d (-)
				; d1drun (-)
				; decode_1dtoraw (W)
Rencword	RN	1	; encode1d:
				; spool (R/W)
				; encode_rawto1d (R/W)
Rscalewidthin	RN	1	; hscale

REOFstatus	RN	2	; decode1d:
				; -huntforeol (W; preserved across call)
				; waitforeol (W; preserved across call)
Rreverse	RN	2	; decode1d:
				; fillup (R)
				; -huntforeol (-)
				; waitforeol (-)
				; decode1d (-)
				; d1drun (-)
				; decode_1dtoraw (W)
				; decode2d:
Rencwordpos	RN	2	; encode1d:
				; spool (R/W)
				; encode_rawto1d (R/W)
Rscalelineout	RN	2	; hscale

;			a4	; huntforeol
Rdecimagewidth	RN	3	; decode1d:
				; decode_1dtoraw (W)
Ra0		RN	3	; decode2d:
Rencimagewidth	RN	3	; encode1d:
				; encode_rawto1d (R/W)
Rscalewidthout	RN	3	; hscale

Rcolb1		RN	4	; decode2d:
Rencwork1	RN	4	; encode1d:
				; spool (W)
				; encode_rawto1d (W)
Rscaleleftover	RN	4	; hscale

Rfound		RN	5	; decode1d:
				; decode1d (W)
				; d1drun (R/W)
				; decode_1dtoraw (R)
Rb1		RN	5	; decode2d:
Rwmakeuptable	RN	5	; encode1d:
				; encode_rawto1d (W)
Rscalebitstogo	RN	5	; hscale

Rrefline	RN	6	; decode2d:
Rencindexraw	RN	6	; encode1d:
				; encode_rawto1d (R/W)

Rcol		RN	7	; decode1d:
				; decode1d (R)
				; d1drun (-)
				; decode_1dtoraw (W)
Rcola0		RN	7	; decode2d:
				; Used identically to col
Rencindexcom	RN	7	; encode1d:
				; spool (R/W)
				; encode_rawto1d (R/W)

Rdecinuse	RN	8	; decode1d:
				; fillup (R/W)
				; -huntforeol
				; waitforeol (R/W)
				; decode1d (R/W)
				; d1drun (-)
				; decode_1dtoraw (W)
Renclend64	RN	8	; encode1d:
				; encode_rawto1d (W)

Rdecword	RN	9	; decode1d:
				; fillup (R/W)
				; -huntforeol
				; waitforeol (R/W)
				; decode1d (R/W)
				; d1drun (-)
				; decode_1dtoraw (W)
Rbtermintable	RN	9	; encode1d:
				; encode_rawto1d (W)

Rlen		RN	10	; decode1d:
				; writeraw (R/W)
				; decode_1dtoraw (-)
Rffound		RN	10	; decode1d:
				; d1drun (W: passed straight on to writeraw)
				; decode_1dtoraw (-)
Renclenword	RN	10	; encode1d:
				; encode_rawto1d (W)

Rdecindexraw	RN	11	; decode1d:
				; writeraw (R/W)
				; decode_1dtoraw (W)
Renclen		RN	11	; encode1d:
				; encode_rawto1d (W)

Rstaticbase	RN	12	; Need to watch out for this wherever used
Raddfirst	RN	12	; decode1d:
				; writeraw (R/W)
				; decode_1dtoraw (W)
Rwtermintable	RN	12	; encode1d:
				; encode_rawto1d (W)

Renccodelen	RN	0
Renccode	RN	0
Rencword	RN	1
Rencwordpos	RN	2
Renc2da0	RN	3
Rencclen	RN	4
Renc2dcola0b1	RN	12
Renc2db1	RN	5
Renc2dh1	RN	5	; Duplicate!
Rencindexraw	RN	6
Rencindexcom	RN	7
Renc2da1	RN	8
Renc2dimagewid	RN	9
Renc2dindexrefraw	RN	10
Renc2db2	RN	11
Renc2dh2	RN	11	; Duplicate!


APCSregsin	RLIST	{r4-r11, lr}
APCSregsout	RLIST	{r4-r11, pc}


Vflag		EQU	1:SHL:28


lpaddedEOL	EQU	8192
lEOL		EQU	8193
lBAD		EQU	8194
lREPMAKE	EQU	8195

lp0		EQU	7

EOLcode		EQU	2_000000000001:SHL:(32-12)
EOLlen		EQU	12
EOLcodelen	EQU	EOLcode			; This is not a valid codelen (len is zero) -- used as special value

treesize	EQU	107
ARMtreesize	EQU	(treesize+1)*4*2	; Each tree entry is one word, and there are 2 colours
treesize2D	EQU	9
ARMtreesize2D	EQU	(treesize2D+1)*4	; No colours this time



	AREA	|C$$data|, DATA


decword		DCD	0
decinuse	DCD	0
decindexcom	DCD	0
decindexraw	DCD	0
decimagewidth	DCD	0
decrefline	DCD	0
;;;decreverse	DCD	0
encword		DCD	0
encwordpos	DCD	0
encindexcom	DCD	0
encindexraw	DCD	0
encimagewidth	DCD	0
encwordposprev	DCD	0
encindexcomprev	DCD	0
encminscan	DCD	0



	AREA	|C$$code|, CODE, READONLY


; Note the code often makes use of the defined ARM behaviour for non-word-aligned LDRs,
; namely that they result in a rotation of the addressed word (i.e. ignoring the lowest
; two bits of the address) such that the addressed byte is rotated into the lowest byte.
;
; Thusly, to get at a 16-bit (halfword) quantity aligned on a halfword boundary
; ( result = * (uint16 *) address ), the following code can be used:
;
;	EOR	temp, address, #2		; Point at the other halfword
;	LDR	result, [temp]			; Get the wanted halfword in the highest two bytes
;	MOV	result, result, LSR#16		; Shift the wanted halfword down
;
; ASR can be used in place of LSR if the quantity is signed.
;
; The shift can often be incorporated into a subsequent instruction, too
; ( sum += * (uint16 *) address ):
;
;	EOR	temp, address, #2		; 1F (on ARM7500)
;	LDR	temp, [temp]			; 1F + 1R + 1I
;	ADD	sum, sum, temp, LSR#16		; 1F
;
; This saves a memory access over the more obvious method:
;
;	LDRB	result, [address, #0]		; 1F + 1R + 1I
;	LDRB	temp, [address, #1]		; 1F + 1R + 1I
;	ADD	result, result, temp, LSL#8	; 1F
;
; This method is even worse if the result is to be added in to another register!
;
; The only case where the obvious method may be better is with writeback
; ( result = * (uint16 *) address++ ):
;
;	LDRB	result, [address], #1		; 1F + 1R + 1I
;	LDRB	temp, [address], #1		; 1F + 1R + 1I
;	ADD	result, result, temp, LSL#8	; 1F
;
; When using the trick when writeback is needed, it is probably worth interleaving to
; try to give a LDR optimiser a chance to catch up a cycle:
;
;	EOR	temp, address, #2		; 1F
;	LDR	temp, [temp]			; 1F + 1R + 1I
;	ADD	address, address, #2		; 1F
;	ADD	sum, sum, temp, LSR#16		; 1F
;
; Wibble.


	MACRO
$label	ExportFn	$name			; For exporting an APCS function, optionally with name
	ROUT

	EXPORT	$name

	[	names
01
	DCB	"$name", 0
	ALIGN
02
	DCD	&ff000000 + %02 - %01
	]

$name

	ROUT
	MEND


	MACRO
$label	fillup					; For calling fillup if needed
$label	CMP	Rdecinuse, #8
	BLHS	fillup
	MEND


fillup

	; Fills Rdecword with (a) byte(s), optionally reversed, either from memory
	; starting at Rdecindexcom or from the file whose handle is Rdecindexcom
	; (if EOF is met (or if any read error occurs), Rdecword is filled with zeroes).
	;
	; The bytes are inserted with the rightmost bit at Rdecinuse.
	; Rdecinuse is then updated; the process is repeated until it becomes less than 8.
	; This routine therefore ensures Rdecword always contains at least 17 bits
	; of info (worst case is when Rdecinuse ends up as 7).
	;
	; Note one byte is always filled in, so this routine should not be called
	; if Rdecinuse is less than 8.  (Well, actually, you could get away with
	; any non-negative value, but...)
	;
        ; Inputs:	Rdecword
        ;		Rdecinuse
        ;		Rdecindexcom
        ;		Raddfirst (b1 set if Rdecindexcom is actually a file handle,
        ;		           b2 set if need to reverse octet)
        ;
        ; Outputs:	Rdecword
	;		Rdecinuse
	;		Rdecindexcom
	;
        ; Corrupts:	lr
        ;
        ; Called:	lots of places, using fillup macro
        ;
        ; Calls:	nothing
        ;
        ; Assumes:	Rdecinuse >= 0

	STMFD	sp!, {r0, lr}

fillup_do
	TST	Raddfirst, #ishandle
	BNE	fillup_fromfile
	LDRB	r0, [Rdecindexcom], #1

fillup_backfromfile
	TST	Raddfirst, #reverseit
	ADRNE	lr, reverse
	LDRNEB	r0, [lr, r0]

	ORR	Rdecword, Rdecword, r0, LSL Rdecinuse
	SUB	Rdecinuse, Rdecinuse, #8
	CMP	Rdecinuse, #8
	BHS	fillup_do

	LDMFD	sp!, {r0, pc}^

fillup_fromfile
	ASSERT	Rdecindexcom = 1		; r1 for XOS_Bget is file handle
	SWI	XOS_BGet
	MOVVS	r0, #0				; Lots of things rely on decword getting filled with zeroes at EOF
	MOVCS	r0, #0				; Also C set if byte not read
	B	fillup_backfromfile

	ROUT


	ExportFn	tifflo_reverse		; byte tifflo_reverse (byte b);

	LDRB    a1, [pc, a1]			; pc points at reverse table
	MOVS    pc, lr

	ROUT

reverse						; This table must, of course, immediately follow
	DCB	&00
	DCB	&80
	DCB	&40
	DCB	&C0
	DCB	&20
	DCB	&A0
	DCB	&60
	DCB	&E0
	DCB	&10
	DCB	&90
	DCB	&50
	DCB	&D0
	DCB	&30
	DCB	&B0
	DCB	&70
	DCB	&F0
	DCB	&08
	DCB	&88
	DCB	&48
	DCB	&C8
	DCB	&28
	DCB	&A8
	DCB	&68
	DCB	&E8
	DCB	&18
	DCB	&98
	DCB	&58
	DCB	&D8
	DCB	&38
	DCB	&B8
	DCB	&78
	DCB	&F8
	DCB	&04
	DCB	&84
	DCB	&44
	DCB	&C4
	DCB	&24
	DCB	&A4
	DCB	&64
	DCB	&E4
	DCB	&14
	DCB	&94
	DCB	&54
	DCB	&D4
	DCB	&34
	DCB	&B4
	DCB	&74
	DCB	&F4
	DCB	&0C
	DCB	&8C
	DCB	&4C
	DCB	&CC
	DCB	&2C
	DCB	&AC
	DCB	&6C
	DCB	&EC
	DCB	&1C
	DCB	&9C
	DCB	&5C
	DCB	&DC
	DCB	&3C
	DCB	&BC
	DCB	&7C
	DCB	&FC
	DCB	&02
	DCB	&82
	DCB	&42
	DCB	&C2
	DCB	&22
	DCB	&A2
	DCB	&62
	DCB	&E2
	DCB	&12
	DCB	&92
	DCB	&52
	DCB	&D2
	DCB	&32
	DCB	&B2
	DCB	&72
	DCB	&F2
	DCB	&0A
	DCB	&8A
	DCB	&4A
	DCB	&CA
	DCB	&2A
	DCB	&AA
	DCB	&6A
	DCB	&EA
	DCB	&1A
	DCB	&9A
	DCB	&5A
	DCB	&DA
	DCB	&3A
	DCB	&BA
	DCB	&7A
	DCB	&FA
	DCB	&06
	DCB	&86
	DCB	&46
	DCB	&C6
	DCB	&26
	DCB	&A6
	DCB	&66
	DCB	&E6
	DCB	&16
	DCB	&96
	DCB	&56
	DCB	&D6
	DCB	&36
	DCB	&B6
	DCB	&76
	DCB	&F6
	DCB	&0E
	DCB	&8E
	DCB	&4E
	DCB	&CE
	DCB	&2E
	DCB	&AE
	DCB	&6E
	DCB	&EE
	DCB	&1E
	DCB	&9E
	DCB	&5E
	DCB	&DE
	DCB	&3E
	DCB	&BE
	DCB	&7E
	DCB	&FE
	DCB	&01
	DCB	&81
	DCB	&41
	DCB	&C1
	DCB	&21
	DCB	&A1
	DCB	&61
	DCB	&E1
	DCB	&11
	DCB	&91
	DCB	&51
	DCB	&D1
	DCB	&31
	DCB	&B1
	DCB	&71
	DCB	&F1
	DCB	&09
	DCB	&89
	DCB	&49
	DCB	&C9
	DCB	&29
	DCB	&A9
	DCB	&69
	DCB	&E9
	DCB	&19
	DCB	&99
	DCB	&59
	DCB	&D9
	DCB	&39
	DCB	&B9
	DCB	&79
	DCB	&F9
	DCB	&05
	DCB	&85
	DCB	&45
	DCB	&C5
	DCB	&25
	DCB	&A5
	DCB	&65
	DCB	&E5
	DCB	&15
	DCB	&95
	DCB	&55
	DCB	&D5
	DCB	&35
	DCB	&B5
	DCB	&75
	DCB	&F5
	DCB	&0D
	DCB	&8D
	DCB	&4D
	DCB	&CD
	DCB	&2D
	DCB	&AD
	DCB	&6D
	DCB	&ED
	DCB	&1D
	DCB	&9D
	DCB	&5D
	DCB	&DD
	DCB	&3D
	DCB	&BD
	DCB	&7D
	DCB	&FD
	DCB	&03
	DCB	&83
	DCB	&43
	DCB	&C3
	DCB	&23
	DCB	&A3
	DCB	&63
	DCB	&E3
	DCB	&13
	DCB	&93
	DCB	&53
	DCB	&D3
	DCB	&33
	DCB	&B3
	DCB	&73
	DCB	&F3
	DCB	&0B
	DCB	&8B
	DCB	&4B
	DCB	&CB
	DCB	&2B
	DCB	&AB
	DCB	&6B
	DCB	&EB
	DCB	&1B
	DCB	&9B
	DCB	&5B
	DCB	&DB
	DCB	&3B
	DCB	&BB
	DCB	&7B
	DCB	&FB
	DCB	&07
	DCB	&87
	DCB	&47
	DCB	&C7
	DCB	&27
	DCB	&A7
	DCB	&67
	DCB	&E7
	DCB	&17
	DCB	&97
	DCB	&57
	DCB	&D7
	DCB	&37
	DCB	&B7
	DCB	&77
	DCB	&F7
	DCB	&0F
	DCB	&8F
	DCB	&4F
	DCB	&CF
	DCB	&2F
	DCB	&AF
	DCB	&6F
	DCB	&EF
	DCB	&1F
	DCB	&9F
	DCB	&5F
	DCB	&DF
	DCB	&3F
	DCB	&BF
	DCB	&7F
	DCB	&FF


	ExportFn	tifflo_fillupcall	; void tifflo_fillupcall (int flags);

	; This is a glue function.
	; flags as per tifflo_decode_1d.

	STMFD	sp!, APCSregsin

	StaticBaseFromSL	Rstaticbase
	STMFD	sp!, {Rstaticbase}

	ASSERT	Rreturncode = a1		; Make sure a1 (flags) won't get squashed
	LDRVar	Rdecindexcom, Rstaticbase, decindexcom
	LDRVar	Rdecword, Rstaticbase, decword
	LDRVar	Rdecinuse, Rstaticbase, decinuse
	MOV	Raddfirst, a1

	fillup

	LDMFD	sp!, {Rstaticbase}
	STRVar	Rdecindexcom, Rstaticbase, decindexcom, lr
	STRVar	Rdecword, Rstaticbase, decword, lr
	STRVar	Rdecinuse, Rstaticbase, decinuse, lr

	LDMFD	sp!, APCSregsout^

	ROUT


	ExportFn	tifflo_eatabitcall	; void tifflo_eatabitcall (int flags);

	; This is a glue function for eating a bit, followed by fillup.
	; flags as per tifflo_decode_1d.

	STMFD	sp!, APCSregsin

	StaticBaseFromSL	Rstaticbase
	STMFD	sp!, {Rstaticbase}

	ASSERT	Rreturncode = a1		; Make sure a1 (flags) won't get squashed
	LDRVar	Rdecindexcom, Rstaticbase, decindexcom
	LDRVar	Rdecword, Rstaticbase, decword
	LDRVar	Rdecinuse, Rstaticbase, decinuse
	MOV	Raddfirst, a1

	MOV	Rdecword, Rdecword, LSL#1
	ADD	Rdecinuse, Rdecinuse, #1
	fillup

	LDMFD	sp!, {Rstaticbase}
	STRVar	Rdecindexcom, Rstaticbase, decindexcom, lr
	STRVar	Rdecword, Rstaticbase, decword, lr
	STRVar	Rdecinuse, Rstaticbase, decinuse, lr

	LDMFD	sp!, APCSregsout^

	ROUT


	ExportFn	tifflo_writeraw		; int tifflo_writeraw (int flags, int len);

	; This is a glue function for writing a raw run length.
	; flags should be inited to -1.

	STMFD	sp!, APCSregsin

	StaticBaseFromSL	Rstaticbase
	STMFD	sp!, {Rstaticbase}

	ASSERT	Rdecindexraw <> a1		; Make sure a1 and a2 won't get squashed
	ASSERT	Rdecindexraw <> a2
	ASSERT	Rlen <> a1
	ASSERT	Rlen <> a2
	ASSERT	Raddfirst = Rstaticbase
	ASSERT	Rstaticbase = r12
	LDRVar	Rdecindexraw, Rstaticbase, decindexraw
	MOV	Rlen, a2
	MOV	Raddfirst, a1
	CMN	Raddfirst, #1			; Compare with -1
	MOVEQ	Raddfirst, #isfirst		; First, not add

        BL	writeraw

	ASSERT	Raddfirst = Rstaticbase
	MOV	a1, Raddfirst			; Return flags
	LDMFD	sp!, {Rstaticbase}
	STRVar	Rdecindexraw, Rstaticbase, decindexraw, lr

	LDMFD	sp!, APCSregsout^

	ROUT


	ExportFn	tifflo_decode_1d	; int tifflo_decode_1d (int flags);

	; Decodes one 1D MH-encoded scan line from decindexcom (sequence of octets to
	; decode) to decindexraw (series of run lengths; points at first free element).
	;
	; If ishandle is set in flags, decindexcom is a file handle, else it is an address.
	; If reverseit is set in flags, octets will be reversed when read.
	;
	; decimagewidth contains the expected image width.
	; decinuse and decword hold some cached bits; this is propagated across calls.
	;
	; @@ Rreverse is free!
	; @@ Could take decindexcom as input parm
	;
	; A non-zero return code indicates an error.
	;
	; -:
	;;;	Rreasoncode (B d1drun (B decode1D (B waitforeol)))
	;;;	REOFstatus (B d1drun (B decode1D (B waitforeol)))
	;;;	Rffound/Rlen (B d1drun/writeraw)
	; R:
	;;;	Rfound (B d1drun (B decode1D))
	; W:
	;;;	Rreturncode (also B d1drun) [a1]
	;;;	Raddfirst (also B writeraw) [r12]
	;;;	Rreverse (also B d1drun (B decode1D (B fillup, waitforeol)))
	;;;	Rdecindexcom (also B d1drun (B decode1D (B fillup, waitforeol)))
	;;;	Rcol (also B d1drun (B decode1D))
	;;;	Rdecword (also B d1drun (B decode1D (B fillup, waitforeol)))
	;;;	Rdecinuse (also B d1drun (B decode1D (B fillup, waitforeol)))
	;;;	Rdecindexraw (also B writeraw)
	;;;	Rdecimagewidth
	; R/W:
	; Calls:
	;	d1drun
	;	writeraw
	; Called:
	;	C

	; Inputs:	decimagewidth
	;		decindexraw
	;		decindexcom
	;		decword
	;		decinuse
	;
	; Outputs:	decindexraw
	;		decword
	;		decinuse
	;		Rreturncode
	;
	; Corrupts:	Rdecimagewidth
	; (i.e. sets)	Rdecindexraw
	;		Rdecindexcom
	;		Rdecword
	;		Rdecinuse
	;		Rcol
	;		Rreturncode
	;		Raddfirst
	;
	; Called:	C
	;
	; Calls:	d1drun (inputs nothing)
	;		       (outputs Rffound, Rreturncode, VS)
	;		       (corrupts Rfound)
	;		=>	decode1d (inputs Rcol)
	;				 (outputs Rfound, Rdecword, Rdecinuse, VS)
	;				 (preserves lr)
	; 			=>	fillup (inputs Rdecword, Rdecinuse, Rdecindexcom, Raddfirst)
	;               		       (outputs Rdecword, Rdecinuse, Rdecindexcom)
	;				       (corrupts lr)
	;		writeraw (inputs Rlen, Raddfirst, Rdecindexraw)
	;			 (outputs Raddfirst, Rdecindexraw)
	;			 (corrupts lr, Rlen)

	STMFD	sp!, APCSregsin

	StaticBaseFromSL	Rstaticbase
	STMFD	sp!, {Rstaticbase}

	ASSERT	Rreturncode = a1		; Make sure a1 (flags) won't get squashed
	LDRVar	Rdecimagewidth, Rstaticbase, decimagewidth
	LDRVar	Rdecindexraw, Rstaticbase, decindexraw
	LDRVar	Rdecword, Rstaticbase, decword
	LDRVar	Rdecinuse, Rstaticbase, decinuse
	LDRVar	Rdecindexcom, Rstaticbase, decindexcom
	MOV	Rcol, #0			; Start as white
	ASSERT	Raddfirst = Rstaticbase		; Rstaticbase = Raddfirst, so safe to squash now
	ADD	Raddfirst, a1, #isfirst		; First, not add

d1DtorawW_do
	BL	d1Drun
	BVS	d1DtorawW_abort			; Return code set by d1drun
	SUB	Rdecimagewidth, Rdecimagewidth, Rffound
	ASSERT	Rffound = Rlen			; d1drun returns Rffound, writeraw reads Rlen
	BL	writeraw
	RSB	Rcol, Rcol, #ARMtreesize/2
	CMP	Rdecimagewidth, #0
	BGT	d1DtorawW_do			; Loop until bitstogo<=0

d1DtorawW_done
	MOVNE	Rreturncode, #05		; If bitstogo!=0, abort with line too long
	MOVEQ	Rreturncode, #00

d1DtorawW_abort
	TST	Raddfirst, #addit               ; Wind forward if we're left in addit mode
	ADDNE	Rdecindexraw, Rdecindexraw, #2
	LDMFD	sp!, {Rstaticbase}
	STRVar	Rdecindexraw, Rstaticbase, decindexraw, lr
	STRVar	Rdecword, Rstaticbase, decword, lr
	STRVar	Rdecinuse, Rstaticbase, decinuse, lr
	LDMFD	sp!, APCSregsout^

	ROUT


d1Drun

	; Decodes a complete 1D MH run length.
	;
	; If an error occurs, the overflow flag is set and Rreturncode gives the error code.
	; @@ Should #defineify return codes
	; @@ If Rffound were preserved, could save a register)
	;
	; Inputs:	nothing
	;
	; Outputs:	Rffound
	;		Rreturncode (if error)
	;		VS if error (not a run length)
	;
	; Corrupts:	Rfound
	;
	; Called:	tifflo_decode_1d
	;
	; Calls:	decode1d (inputs Rcol)
	;			 (outputs Rfound, Rdecword, Rdecinuse, VS)
	;			 (preserves lr)
	; 		=>	fillup (inputs Rdecword, Rdecinuse, Rdecindexcom, Raddfirst)
	;               	       (outputs Rdecword, Rdecinuse, Rdecindexcom)
	;			       (corrupts lr)

	STMFD	sp!, {lr}
	BL	decode1D		; Rfound = first found
	BVS	d1Drun_abort01		; If found non-code, abort with it
	MOV	Rffound, Rfound		; Rffound = first found (intentionally not HS)
	CMP	Rffound, #64		; If found terminating code, terminate with the code
	BLO	d1Drun_done		; else this must be a make-up code
	BL	decode1D		; Rfound = next found
	BVS	d1Drun_abort02		; If found non-code, abort with it
	CMP	Rfound, #64		; If now found terminating code, add this in to previous make-up and terminate
	BLO	d1Drun_nearlydone
	CMP	Rffound, #2560		; At this point we're only allowed a 2560 for first found (repeated make-up)
	BNE	d1Drun_abort03		; Abort with lREPMAKE non-code if this is not the case
	ADD	Rffound, Rffound, Rfound ; Otherwise add in both make-ups, and continue
	BL	decode1D		; Rfound = next next found
	BVS	d1Drun_abort04		; If found non-code, abort with it
d1Drun_nearlydone			; Fall through to adding in the previous length.  Phew!
	ADD	Rffound, Rffound, Rfound
d1Drun_done
	LDMFD	sp!, {lr}
	BICS	pc, lr, #Vflag

d1Drun_abort01				; Aborting on make-up/terminating code seek
	MOV	Rreturncode, #01
d1Drun_abort
	LDMFD	sp!, {lr}
	ORRS	pc, lr, #Vflag

d1Drun_abort02				; Aborting on terminating code seek
	MOV	Rreturncode, #02
	B	d1Drun_abort

d1Drun_abort03				; Aborting on repeated make-up
	MOV	Rreturncode, #03
	MOV	Rfound, #8192		; Force lREPMAKE non-code
	ADD	Rfound, Rfound, #lREPMAKE-8192
	B	d1Drun_abort

d1Drun_abort04				; Aborting on 2560 terminating code seek
	MOV	Rreturncode, #04
	B	d1Drun_abort

	ROUT


decode1D

	; Decodes a single 1D MH run length.
	;
	; Rcol should contain offset from ARMtree of right colour tree (i.e. 0 or ARMtreesize/2).
	; Rdecword and Rdecinuse are updated.
	;
	; The decoded run length is returned in Rfound; if an non-run length is found,
	; it is returned and the overflow flag is set
	;
	; Note hitting padded EOL does *not* cause an EOL hunt.
	;
	; Inputs:	Rcol (0 or ARMtreesize/2)
	;
	; Outputs:	Rfound
	;		Rdecword
	;		Rdecinuse
	;		VS if error (not a run length)
	;
	; Corrupts:	nothing (preserves lr)
	;
	; Called:	d1drun
	;
	; Calls:	fillup (inputs Rdecword, Rdecinuse, Rdecindexcom, Raddfirst)
	;                      (outputs Rdecword, Rdecinuse, Rdecindexcom)
	;		       (corrupts lr)
	;
	; Assumes:	Rdecword filled up

	STMFD	sp!, {lr}

	ADR	lr, ARMtree			; Make lr point to base of appropriate decoding tree...
	ADD	lr, lr, Rcol
	MOV	Rfound, #0			; Start at node 0

decode1D_untilnotpositive
	LDR	Rfound, [lr, Rfound, LSL#2]	; Pick up node halfword pair
	TST	Rdecword, #1:SHL:31		; Select appropriate element of pair, depending on encoded bit...
	MOVEQ	Rfound, Rfound, LSL#16
	MOVS	Rfound, Rfound, ASR#16
	MOV	Rdecword, Rdecword, LSL#1	; Zap the encoded bit...
	ADD	Rdecinuse, Rdecinuse, #1
	BGT	decode1D_untilnotpositive	; Loop until -ve halfword (tree terminator) is found

	RSB	Rfound, Rfound, #0		; Make run length positive
	fillup					; Note the above would never underflow since maximum bit sequence
						; length is 13 but Rdecword always contains at least 17 bits
						; (when Rdecinuse is 7)
	CMP	Rfound, #lpaddedEOL		; Report error status in V
	BGE	decode1D_error
;;;	BEQ	decode1D_paddedEOL

;;;	[ ARMdebug
;;;		CMP	lr, #lEOL-lpaddedEOL
;;;		BEQ	decode1D_EOL
;;;		CMP	lr, #lBAD-lpaddedEOL
;;;		BEQ	decode1D_BAD
;;;	|
;;;		BPL	decode1D_errdone	; If found any other non-run length, it's an error
;;;	]

decode1D_done
	LDMFD	sp!, {lr}			; Return no error...
	BICS	pc, lr, #Vflag

decode1D_error
;;;	BLEQ	waitforEOL			; Wait for EOL bit (or EOF)
;;;	[ ARMdebug
;;;		LDR	lr, Xasgraphics
;;;		CMP	lr, #0
;;;		MOV	lr, r0
;;;		ADREQ	r0, decode1D_paddedEOLstring
;;;		SWIEQ	XOS_Write0
;;;		MOV	r0, lr
;;;	]
;;;	B	decode1D_errdone		; It's an error

;;;decode1D_EOL
;;;	[ ARMdebug
;;;		LDR	lr, Xasgraphics
;;;		CMP	lr, #0
;;;		MOV	lr, r0
;;;		ADREQ	r0, decode1D_EOLstring
;;;		SWIEQ	XOS_Write0
;;;		MOV	r0, lr
;;;	]
;;;decode1D_errdone
	LDMFD	sp!, {lr}			; Return error...
	ORRS	pc, lr, #Vflag

;;;	[ ARMdebug
;;;decode1D_BAD
;;;		MOV	lr, r0
;;;		ADR	r0, decode1D_BADstring
;;;		SWI	XOS_Write0
;;;		MOV	r0, lr
;;;		B	decode1D_errdone
;;;
;;;decode1D_paddedEOLstring
;;;		DCB	"Found padded EOL", 13, 10, 0
;;;		ALIGN
;;;decode1D_EOLstring
;;;		DCB	"Found EOL", 13, 10, 0
;;;		ALIGN
;;;decode1D_BADstring
;;;		DCB	"Found BAD", 13, 10, 0
;;;		ALIGN
;;;	]

	ROUT


	EXPORTVar	decword
	EXPORTVar	decinuse
	EXPORTVar	decindexcom
	EXPORTVar	decindexraw
	EXPORTVar	decimagewidth
	EXPORTVar	decrefline
;;;	EXPORTVar	decreverse
	EXPORTVar	encword
	EXPORTVar	encwordpos
	EXPORTVar	encindexcom
	EXPORTVar	encindexraw
	EXPORTVar	encimagewidth
	EXPORTVar	encwordposprev
	EXPORTVar	encindexcomprev
	EXPORTVar	encminscan


	MACRO
	DCW2	$w1, $w2	; The stupid DCW implementation doesn't handle -ve numbers!
	DCW	$w1:AND:&FFFF, $w2:AND:&FFFF
	MEND

ARMtree
;
; The decoding trees are pairs of halfwords.
; The left element is that to be used if a zero bit is to be decoded;
; the right element is that for a one bit.
; A positive value is a link to another node;
; a negative value is the -ve of a run length to be returned
; (values below -8191 have special meanings).
;
; Tree for 1D MH, colour 0
	DCW2	1, 96
	DCW2	2, 58
	DCW2	3, 40
	DCW2	4, 30
	DCW2	5, 27
	DCW2	6, 25
	DCW2	7, 24
	DCW2	8, 12
	DCW2	9, -8194
	DCW2	10, -8194
	DCW2	11, -8194
	DCW2	-8192, -8193
	DCW2	13, 19
	DCW2	14, 16
	DCW2	-1792, 15
	DCW2	-1984, -2048
	DCW2	17, 18
	DCW2	-2112, -2176
	DCW2	-2240, -2304
	DCW2	20, 21
	DCW2	-1856, -1920
	DCW2	22, 23
	DCW2	-2368, -2432
	DCW2	-2496, -2560
	DCW2	-29, -30
	DCW2	26, -22
	DCW2	-45, -46
	DCW2	28, -13
	DCW2	-23, 29
	DCW2	-47, -48
	DCW2	31, 37
	DCW2	32, 34
	DCW2	-20, 33
	DCW2	-33, -34
	DCW2	35, 36
	DCW2	-35, -36
	DCW2	-37, -38
	DCW2	38, -1
	DCW2	-19, 39
	DCW2	-31, -32
	DCW2	41, 51
	DCW2	42, 45
	DCW2	-12, 43
	DCW2	44, -26
	DCW2	-53, -54
	DCW2	46, 49
	DCW2	47, 48
	DCW2	-39, -40
	DCW2	-41, -42
	DCW2	50, -21
	DCW2	-43, -44
	DCW2	52, -10
	DCW2	53, 55
	DCW2	-28, 54
	DCW2	-61, -62
	DCW2	56, 57
	DCW2	-63, 0
	DCW2	-320, -384
	DCW2	59, 78
	DCW2	60, 68
	DCW2	-11, 61
	DCW2	62, 64
	DCW2	-27, 63
	DCW2	-59, -60
	DCW2	65, -18
	DCW2	66, 67
	DCW2	-1472, -1536
	DCW2	-1600, -1728
	DCW2	69, 74
	DCW2	70, 72
	DCW2	-24, 71
	DCW2	-49, -50
	DCW2	73, -25
	DCW2	-51, -52
	DCW2	75, -192
	DCW2	76, 77
	DCW2	-55, -56
	DCW2	-57, -58
	DCW2	79, -2
	DCW2	80, 85
	DCW2	-1664, 81
	DCW2	82, 83
	DCW2	-448, -512
	DCW2	84, -640
	DCW2	-704, -768
	DCW2	86, 92
	DCW2	87, 89
	DCW2	-576, 88
	DCW2	-832, -896
	DCW2	90, 91
	DCW2	-960, -1024
	DCW2	-1088, -1152
	DCW2	93, -256
	DCW2	94, 95
	DCW2	-1216, -1280
	DCW2	-1344, -1408
	DCW2	97, 103
	DCW2	98, 100
	DCW2	-3, 99
	DCW2	-128, -8
	DCW2	101, -4
	DCW2	-9, 102
	DCW2	-16, -17
	DCW2	104, 107
	DCW2	-5, 105
	DCW2	106, -64
	DCW2	-14, -15
	DCW2	-6, -7

; Tree for 1D MH, colour 1
	DCW2	1, 107
	DCW2	2, 106
	DCW2	3, 105
	DCW2	4, 103
	DCW2	5, 82
	DCW2	6, 57
	DCW2	7, 24
	DCW2	8, 12
	DCW2	9, -8194
	DCW2	10, -8194
	DCW2	11, -8194
	DCW2	-8192, -8193
	DCW2	13, 19
	DCW2	14, 16
	DCW2	-1792, 15
	DCW2	-1984, -2048
	DCW2	17, 18
	DCW2	-2112, -2176
	DCW2	-2240, -2304
	DCW2	20, 21
	DCW2	-1856, -1920
	DCW2	22, 23
	DCW2	-2368, -2432
	DCW2	-2496, -2560
	DCW2	25, 41
	DCW2	26, 32
	DCW2	-18, 27
	DCW2	28, 30
	DCW2	-52, 29
	DCW2	-640, -704
	DCW2	31, -55
	DCW2	-768, -832
	DCW2	33, 38
	DCW2	34, 36
	DCW2	-56, 35
	DCW2	-1280, -1344
	DCW2	37, -59
	DCW2	-1408, -1472
	DCW2	39, -24
	DCW2	-60, 40
	DCW2	-1536, -1600
	DCW2	42, 50
	DCW2	43, 46
	DCW2	-25, 44
	DCW2	45, -320
	DCW2	-1664, -1728
	DCW2	47, 48
	DCW2	-384, -448
	DCW2	49, -53
	DCW2	-512, -576
	DCW2	51, -64
	DCW2	52, 54
	DCW2	-54, 53
	DCW2	-896, -960
	DCW2	55, 56
	DCW2	-1024, -1088
	DCW2	-1152, -1216
	DCW2	58, 70
	DCW2	-13, 59
	DCW2	60, 66
	DCW2	61, 63
	DCW2	-23, 62
	DCW2	-50, -51
	DCW2	64, 65
	DCW2	-44, -45
	DCW2	-46, -47
	DCW2	67, -16
	DCW2	68, 69
	DCW2	-57, -58
	DCW2	-61, -256
	DCW2	71, -14
	DCW2	72, 76
	DCW2	-17, 73
	DCW2	74, 75
	DCW2	-48, -49
	DCW2	-62, -63
	DCW2	77, 80
	DCW2	78, 79
	DCW2	-30, -31
	DCW2	-32, -33
	DCW2	81, -22
	DCW2	-40, -41
	DCW2	83, 84
	DCW2	-10, -11
	DCW2	85, -12
	DCW2	86, 93
	DCW2	-15, 87
	DCW2	88, 91
	DCW2	89, 90
	DCW2	-128, -192
	DCW2	-26, -27
	DCW2	92, -19
	DCW2	-28, -29
	DCW2	94, 100
	DCW2	95, 97
	DCW2	-20, 96
	DCW2	-34, -35
	DCW2	98, 99
	DCW2	-36, -37
	DCW2	-38, -39
	DCW2	101, 0
	DCW2	-21, 102
	DCW2	-42, -43
	DCW2	104, -7
	DCW2	-9, -8
	DCW2	-6, -5
	DCW2	-1, -4
	DCW2	-3, -2



	ExportFn	tifflo_decode_2d	; int tifflo_decode_2d (int flags);

	; Decodes one 2D (M)MR-encoded scan line from decindexcom to decindexraw.
	;
	; -:
	;    Rdecindexcom (B fillup)
	;    Rdecword (B decode2D)
	;    Rdecinuse (B decode2D)
	;    Rfound2D (B decode2D)
	;    Rreverse (B fillup)
	; R:
	; W:
	;    lr
	; R/W:

	STMFD	sp!, APCSregsin

	StaticBaseFromSL	Rstaticbase
	STMFD	sp!, {Rstaticbase}
	LDRVar	Rdecindexraw, Rstaticbase, decindexraw
	LDRVar	Rdecword, Rstaticbase, decword
	LDRVar	Rdecinuse, Rstaticbase, decinuse
	LDRVar	Rdecindexcom, Rstaticbase, decindexcom
	LDRVar	Rrefline, Rstaticbase, decrefline
;;;	LDRVar	Rreverse, Rstaticbase, decreverse
;;;new		MOV	Rdecindexcom, Rstaticbase
	MVN	Ra0, #0				; Start with a0=-1
	MOV	Rcola0, #0			; Start as white
	MOV	Rb1, #0				; Start with b1=0
	MOV	Rcolb1, #0			; Start as white
	ASSERT	Raddfirst = Rstaticbase		; Rstaticbase = Raddfirst, so safe to squash now
	ADD	Raddfirst, r0, #isfirst		; First, not add

d2DtorawW_do

	ADR	lr, ARMtree2D			; Make lr point to base of decoding tree
	MOV	Rfound2D, #0			; Start at node 0

decode2D_untilnotpositive
	LDR	Rfound2D, [lr, Rfound2D, LSL#2]	; Pick up node halfword pair
	TST	Rdecword, #1:SHL:31		; Select appropriate element of pair, depending on encoded bit...
	MOVEQ	Rfound2D, Rfound2D, LSL#16
	MOVS	Rfound2D, Rfound2D, ASR#16
	MOV	Rdecword, Rdecword, LSL#1	; Zap the encoded bit...
	ADD	Rdecinuse, Rdecinuse, #1
	BGT	decode2D_untilnotpositive	; Loop until -ve halfword (tree terminator) is found

	fillup					; Note the above would never underflow since maximum bit sequence
						; length is 7 but Rdecword always contains at least 17 bits
						; (when Rdecinuse is 7)

	LDR	pc, [pc, -Rfound2D, LSL#2]	; - makes code positive
	DCD	0
	DCD	d2DtorawW_EXT
	DCD	d2DtorawW_possEOFB
	DCD	d2DtorawW_PASS
	DCD	d2DtorawW_HOR
	DCD	d2DtorawW_VER
	DCD	d2DtorawW_VER
	DCD	d2DtorawW_VER
	DCD	d2DtorawW_VER
	DCD	d2DtorawW_VER
	DCD	d2DtorawW_VER
	DCD	d2DtorawW_VER

d2DtorawW_domore
	LDR	Rfound2D, [sp]			; Get static base [non-standard reg use]
	LDRVar	lr, Rfound2D, decimagewidth
	CMP	Ra0, lr
	BLT	d2DtorawW_do
	MOVGT	Rreturncode, #07		; If a0>ImageWidth, abort with line too long
	MOVEQ	Rreturncode, #00		; else we're OK

d2DtorawW_done
	TST	Raddfirst, #addit               ; Wind forward if we're left in addit mode
	ADDNE	Rdecindexraw, Rdecindexraw, #2
	LDMFD	sp!, {Rstaticbase}
	STRVar	Rdecindexraw, Rstaticbase, decindexraw, lr
	STRVar	Rdecword, Rstaticbase, decword, lr
	STRVar	Rdecinuse, Rstaticbase, decinuse, lr
	LDMFD	sp!, APCSregsout^


	MACRO
	findb1
	ROUT

	B	%f92;findb1_whiletest		; while ([*]) {
91;findb1_loop
	EOR	lr, Rrefline, #2		; b1 += *refline++;
	LDR	lr, [lr]
;;;	BIC	lr, Rrefline, #2		; lr has hword-aligned address
;;;						;@@LDRoptim?
;;;	LDR	lr, [lr]			; lr now has refline word
;;;	TST	Rrefline, #2			; Check address hword alignment
;;;	MOVEQ	lr, lr, LSL#16			; lr now has refline hword in W1
	ADD	Rrefline, Rrefline, #2
	ADD	Rb1, Rb1, lr, LSR#16
	RSB	Rcolb1, Rcolb1, #ARMtreesize/2	; colb1 = 1 - colb1

92;findb1_whiletest				; };
	CMP	Rb1, Ra0			; [*] (b1 <= a0
	BLE	%b91;findb1_loop
	CMP	Rcolb1, Rcola0			; [*] || colb1 == cola0)
	BEQ	%b91;findb1_loop

	ROUT
	MEND


;	findb1
;90;findb1_do @@ while optim
;	CMP	Rb1, Ra0
;	BGT	%f92;findb1_donemaybe
;91;findb1_notdoneafterall
;	EOR	lr, Rrefline, #2		; Point at the other halfword
;	LDR	lr, [lr]			; End up with wanted halfword in B3-B2 (defined ARM behaviour)
;;;	BIC	lr, Rrefline, #2		; lr has hword-aligned address
;;;						;@@LDRoptim?
;;;	LDR	lr, [lr]			; lr now has refline word
;;;	TST	Rrefline, #2			; Check address hword alignment
;;;	MOVEQ	lr, lr, LSL#16			; lr now has refline hword in W1
;	ADD	Rb1, Rb1, lr, LSR#16		; b1=b1+(hword)!refline
;	ADD	Rrefline, Rrefline, #2		; refline+=2
;	RSB	Rcolb1, Rcolb1, #ARMtreesize/2	; colb1=1-colb1
;	B	%b90;findb1_do
;92;findb1_donemaybe
;	CMP	Rcolb1, Rcola0
;	BEQ	%b91;findb1_notdoneafterall
;	MEND


d2DtorawW_VER					; Rfound2D contains -(disp+lp0)
	ADD	Rfound2D, Rfound2D, #lp0	; Rfound2D contains -disp
	findb1					; found = b1-disp-a0-(a0>>>31)...
	ADD	lr, Rb1, Rfound2D		; lr = b1-disp
	SUB	Rffound, lr, Ra0
	SUBS	Rffound, Rffound, Ra0, LSR#31
;;;	CMP	Rffound, #0			;@@Optim with SUBS
	BLT	d2DtorawW_VERneg		; BLT to allow zero vertical runs
;;;						;@@ BLT or BLE?
	MOV	Ra0, lr				; a0 = b1-disp
	BL	writeraw			; writeraw(found)
	RSB	Rcola0, Rcola0, #ARMtreesize/2	; cola0=1-cola0
	CMP	Rfound2D, #0			; if (disp>0) [i.e. (-disp<0)] rewindb1();
	BGE	d2DtorawW_domore
rewindb1_do
	CMP	Rb1, Ra0			; while (b1>a0) {
	BLE	d2DtorawW_domore		; rewindb1_done
	RSB	Rcolb1, Rcolb1, #ARMtreesize/2	; colb1=1-colb1
	SUB	Rrefline, Rrefline, #2		; refline-=2
	BIC	lr, Rrefline, #2		; b1-=(hword)!refline...
	LDR	lr, [lr]
	TST	Rrefline, #2
	MOVEQ	lr, lr, LSL#16
	SUB	Rb1, Rb1, lr, LSR#16
	B	rewindb1_do			; }
rewindb1_done
	B	d2DtorawW_domore

d2DtorawW_VERneg
	MOV	Rreturncode, #11		; Abort with negative vertical run
	B	d2DtorawW_done


d2DtorawW_PASS
	findb1
	EOR	lr, Rrefline, #2		; b1 = b2 = b1 + *refline++;
	LDR	lr, [lr]
;;;	BIC	lr, Rrefline, #2		; lr has hword-aligned address
;;;	LDR	lr, [lr]			; lr now has refline word
;;;	TST	Rrefline, #2			; Check address hword alignment
;;;						;@@LDRoptim?
;;;	MOVEQ	lr, lr, LSL#16			; lr now has refline hword in W1
	ADD	Rrefline, Rrefline, #2
	ADD	Rb1, Rb1, lr, LSR#16
	RSB	Rcolb1, Rcolb1, #ARMtreesize/2	; colb1 = 1 - colb1; [actually computing colb2]
	SUB	Rffound, Rb1, Ra0		; found = b2 - a0 - (a0>>>31);
	SUB	Rffound, Rffound, Ra0, LSR#31
	MOV	Ra0, Rb1			; a0 = b2;
	BL	writeraw			; writeraw (found);
	MOV	Rlen, #0			; writeraw (0);
	BL	writeraw
	B	d2DtorawW_domore

d2DtorawW_EXT
	MOV	Rreturncode, #08		; Abort with extension code
	B	d2DtorawW_done

d2DtorawW_possEOFB
	MOV	Rreturncode, #09		; Abort with possible EOFB
	B	d2DtorawW_done

;REM      FN1Drun
;REM      !Xa0+=!Xfound+(!Xa0>>>31)
;REM      !Xcol=1-!Xcol
;REM      PROCwriteraw(!Xfound)
d2DtorawW_HOR

	; -:
	;    Rreverse (B fillup)
	;    Rdecindexcom (B fillup)
	;    Rdecword (B decode1D)
	;    Rinuse (B decode1D)
	;    Rrawindex (B writeraw)
	;    Raddfirst (B writeraw)
	; R:
	; W:
	;    Rlen (B writeraw) = Rffound (B d1Drun)
	;    Rfound (B decode1D)
	;    Rffound (B d1Drun)
	;    R0 (if error)
	;    PSR (VS if error (not a run code))
	; R/W:
	;    Ra0
	;    Rcola0

	STMFD	sp!, {Rb1}			; @@Optimise so that Rb1<>Rfound?

	BL	d1Drun
	BVS	horrun_err			; Abort if any sort of error
	ADD	Ra0, Ra0, Ra0, LSR#31		; a0+=found+(a0>>>31)
	ADD	Ra0, Ra0, Rffound
	RSB	Rcola0, Rcola0, #ARMtreesize/2	; cola0=1-cola0
	BL	writeraw			; writelen(found)

	BL	d1Drun
	BVS	horrun_err
	ADD	Ra0, Ra0, Ra0, LSR#31
	ADD	Ra0, Ra0, Rffound
	RSB	Rcola0, Rcola0, #ARMtreesize/2
	BL	writeraw

	LDMFD	sp!, {Rb1}
	B	d2DtorawW_domore

horrun_err					; Aborting on 2D horizontal mode seek
	MOV	Rreturncode, #06
	LDMFD	sp!, {Rb1}
	B	d2DtorawW_done

	ROUT


ARMtree2D
;
; The decoding trees are pairs of halfwords.
; The left element is that to be used if a zero bit is to be decoded;
; the right element is that for a one bit.
; A positive value is a link to another node;
; a negative value is the -ve of a code to be returned.
;
; Tree for 2D M(M)R
	DCW2	1, -7
	DCW2	2, 3
	DCW2	4, -3
	DCW2	-8, -6
	DCW2	5, -2
	DCW2	6, 7
	DCW2	8, 9
	DCW2	-9, -5
	DCW2	-1, 0
	DCW2	-10, -4


writeraw

	; Writes out a raw run length (held in Rlen).
	;
	; If the length is zero, and we're not at the start of the line (the only place
	; where a zero length can legally be written out), then the 'add' flag is toggled and:
	; - if the 'add' flag becomes set, Rdecindexraw is rewound
	; - if the 'add' flag becomes not set, Rdecindexraw is forwarded
	;
	; If the length is not zero, or if we're at the start of the line, then:
	; - if the 'add' flag is set, it is reset and the length already at Rdecindexraw
	;   is added to that in Rlen and then written out to Rdecindexraw
	; - if the 'add' flag is not set, Rlen is written out to Rdecindexraw
	; Then Rdecindexraw is incremented and the 'start of line' flag gets reset.
	;
	; This algorithm essentially allows unlimited zero-length suppression.  E.g.:
	; - 1,0,3,0,0,5,0,0,0,7 is equivalent to 4,12
	; - 0,1,0,3 is equivalent to 0,4
	; - 0,1,0,0,0,0,3 is equivalent to 0,1,3
	; This is important because the encoding routines assume such a zero-suppressed
	; input raw line.
	;
	; Raddfirst contains flag bits:
	; - isfirst set iff we're at the start of the line (and so should allow a zero length)
	; - b22-b23 and b25-b31 should be zero
	; - addit (b24) set iff we need to add rather than rewind
	; It should be initialised with isfirst set and addit clear.
	;
	; Inputs:	Rlen
	;		Raddfirst
	;		Rdecindexraw
	;
	; Outputs:	Raddfirst
	;		Rdecindexraw
	;
	; Corrupts:	lr
	;		Rlen
	;
	; Called:	tifflo_decode_1d
	;		tifflo_writeraw
	;
	; Calls:	nothing

	STMFD	sp!, {lr}

	CMP	Rlen, #0			; If zero length
	TSTEQ	Raddfirst, #isfirst		;    and not start of line,
	BEQ	writeraw_rewindorforward	;    rewind/forward
	TST	Raddfirst, #addit		; If need to add rather than write,
	BNE	writeraw_addit			;    do so!
	BIC	Raddfirst, Raddfirst, #isfirst	; OK, clear start of line flag
writeraw_writeit
	STRB	Rlen, [Rdecindexraw], #1
	MOV	Rlen, Rlen, LSR#8
	STRB	Rlen, [Rdecindexraw], #1
writeraw_done

	LDMFD	sp!, {pc}^

writeraw_addit					; Not expected to be called often, so not tail optimised
	BIC	Raddfirst, Raddfirst, #addit	; Next time we write rather than add
;	LDRB	lr, [Rdecindexraw, #0]		; Now optimised using ARM trick
;	ADD	Rlen, Rlen, lr
;	LDRB	lr, [Rdecindexraw, #1]
;	ADD	Rlen, Rlen, lr, LSL#8
	EOR	lr, Rdecindexraw, #2
	LDR	lr, [lr]
	ADD	Rlen, Rlen, lr, LSR#16
	B	writeraw_writeit

writeraw_rewindorforward			; Not expected to be called often, so not tail optimised
	EOR	Raddfirst, Raddfirst, #addit	; Toggle add/write flag
	MOV	lr, Raddfirst, LSR#22		; Relies on b22-b23 and b25-b31 of Raddfirst being zero
	SUB	lr, lr, #2			; lr = 4 * add - 2
	SUB	Rdecindexraw, Rdecindexraw, lr
	B	writeraw_done

	ROUT


; void tifflo_encode_1d (int insertEOL);

	EXPORT	tifflo_encode_1d

	ROUT
	[ names
01
	DCB	"tifflo_encode_1d", 0
	ALIGN
02
	DCD	&ff000000 + %02 - %01
	]

tifflo_encode_1d

	; Encodes one raw scan line from encindexraw to encindexcom using 1D coding.
	;
	; The line must be exactly encimagewidth pels long.
	; encword and encwordpos contain any leftover information from the previous line.
	; Put EOL at start if requested (1 for EOL, 2 for EOL+1 (1D line in 2D MR coding).
	;
	; encindexcom after call contains the address of the next byte to be written out.
	; Note the leftover byte is actually written at [encindexcom],
	; to ease handling of the last line/padded lines.
	;
	; -:
	; R:
	; W:
	;	Rencwork1 (also B spool)
	;	Rcodelen (also B spool) [a1]
	;	Rwtermintable [Rstaticbase]
	;	Rbtermintable
	;	Rwmakeuptable
	;	Renclen
	;	Renclend64
	;	Renclenword
	;	lr
	; R/W:
	;	Rencword (also B spool)
	;	Rencwordpos (also B spool)
	;	Rencindexcom (also B spool)
	;	Rencindexraw
	;	Rencimagewidth
	; Calls:
	;	spool
	; Called by:
	;	C

	STMFD	sp!, APCSregsin

	StaticBaseFromSL	Rstaticbase
	STMFD	sp!, {Rstaticbase}
	LDRVar	Rencword, Rstaticbase, encword
	LDRVar	Rencwordpos, Rstaticbase, encwordpos
	LDRVar	Rencindexcom, Rstaticbase, encindexcom
	LDRVar	Rencindexraw, Rstaticbase, encindexraw
	LDRVar	Rencimagewidth, Rstaticbase, encimagewidth

	STRVar	Rencwordpos, Rstaticbase, encwordposprev, lr	; Store posn for min scan
	STRVar	Rencindexcom, Rstaticbase, encindexcomprev, lr

	ASSERT	Rcodelen = a1			; Make sure use of a1 is safe (Rcodelen not yet assigned)
	CMP	a1, #0				; 0 = no EOL at the start
	BEQ	tifflo_encode_1d_noEOL
	CMP	a1, #1				; 1 = 1D MH EOL
	MOV	Rcodelen, #EOLcodelen
	ADD	Rcodelen, Rcodelen, #EOLlen	; 2 = 2D MR EOL (EOL + 1)
	ORRNE	Rcodelen, Rcodelen, #1:SHL:19
        ADDNE	Rcodelen, Rcodelen, #1
	BL	spool

tifflo_encode_1d_noEOL
	ASSERT	Rwtermintable = Rstaticbase	; Make sure use of Rstaticbase was safe (Rwtermintable not yet assigned)
	ADR	Rwtermintable, terminwh
	ADR	Rbtermintable, terminbl
	ADR	Rwmakeuptable, makeupwh - 4

moretoencode
	LDR	Renclenword, [Rencindexraw], #4	; Renclenword = white len in W0, black len in W1
	MOV	Renclen, Renclenword, LSL#16	; Renclen = white len in W1, zero in W0
	MOV	Renclen, Renclen, LSR#16	; Renclen = white len in W0, zero in W1
	SUB	Rencimagewidth, Rencimagewidth, Renclen	; Keep track of the number of pels to go
	CMP	Renclen, #64			; If len >= 64, we need a make-up code
	BHS	rawto1D_longwhite
rawto1D_shortwhite
	LDR	Rcodelen, [Rwtermintable, Renclen, LSL#2]
	BL	spool
	CMP	Rencimagewidth, #0
	SUBLE	Rencindexraw, Rencindexraw, #2	; Wind back so that keep good count of encindexraw
	BLE	nomoretoencode

	MOV	Renclen, Renclenword, LSR#16	; Renclen = black len in W0, zero in W1
	SUB	Rencimagewidth, Rencimagewidth, Renclen
	CMP	Renclen, #64
	BHS	rawto1D_longblack
rawto1D_shortblack
	LDR	Rcodelen, [Rbtermintable, Renclen, LSL#2]
	BL	spool
	CMP	Rencimagewidth, #0
	BGT	moretoencode

nomoretoencode
	ASSERT	Rwtermintable = Rstaticbase	; Make sure use Rstaticbase is safe (Rwtermintable no longer needed)
	LDMFD	sp!, {Rstaticbase}
	LDRVar	Rencwork1, Rstaticbase, encindexcomprev	; encwork1 = encindexcomprev
	SUB	lr, Rencindexcom, Rencwork1	; lr = encindexcom-encindexcomprev
	ADD	lr, Rencwordpos, lr, LSL#3	; lr = (encindex-prev)*8+wordpos
	LDRVar	Rencwork1, Rstaticbase, encwordposprev
	SUB	lr, lr, Rencwork1		; lr = (enc-prev)*8+wordpos-wordposprev
	LDRVar	Rencwork1, Rstaticbase, encminscan
	SUBS	Renclen, Rencwork1, lr		; Renclen = number of bits to pad [non-standard reg use];
						; encwork1 can't be used since spool squashes it]
paditout					; Very inefficient...
	MOVGT	Rcodelen, #1			; Rcodelen = '0'
	BLGT	spool
	SUBGTS	Renclen, Renclen, #1
	BGT	paditout

	MOV	Rencwork1, Rencword, LSR#24	; Spoolend
	STRB	Rencwork1, [Rencindexcom]

;@@??	ADD	Rencindexraw, Rencindexraw, #2	; Wind forward for 2D MR EOL guard

	STRVar	Rencword, Rstaticbase, encword, lr
	STRVar	Rencwordpos, Rstaticbase, encwordpos, lr
;@@??	STRVar	Rencindexraw, Rstaticbase, encindexraw, lr ;@@ Don't need this, do we?
	STRVar	Rencindexcom, Rstaticbase, encindexcom, lr

	LDMFD	sp!, APCSregsout^


rawto1D_longwhite
	MOV	Renclend64, Renclen, LSR#6	; Renclend64 = len DIV 64
	CMP	Renclend64, #2560/64		; If >2560 need to insert repeated 2560 makeup code
	LDRHI	Rcodelen, [Rwmakeuptable, #2560/64:SHL:2]
	BLHI	spool						; This does not handle >5120 runs,
	SUBHI	Renclend64, Renclend64, #2560/64		; but maximum run is 4864 (A3 R16) anyway
	LDR	Rcodelen, [Rwmakeuptable, Renclend64, LSL#2]
	BL	spool
	AND	Renclen, Renclen, #&3F		; len = len MOD 64
	B	rawto1D_shortwhite

rawto1D_longblack
	MOV	Renclend64, Renclen, LSR#6
	CMP	Renclend64, #2560/64
	ADRHI	lr, makeupbl - 4		; There are no regs left to permanently store this address,
	LDRHI	Rcodelen, [lr, #2560/64:SHL:2]	; so it gets loaded everytime (we hope black runs >63 are rare anyway)
	BLHI	spool
	SUBHI	Renclend64, Renclend64, #2560/64
	ADR	lr, makeupbl - 4
	LDR	Rcodelen, [lr, Renclend64, LSL#2]
	BL	spool
	AND	Renclen, Renclen, #&3F
	B	rawto1D_shortblack

makeupwh	; Make-up for colour 0
	DCD	&D8000005
	DCD	&90000005
	DCD	&5C000006
	DCD	&6E000007
	DCD	&36000008
	DCD	&37000008
	DCD	&64000008
	DCD	&65000008
	DCD	&68000008
	DCD	&67000008
	DCD	&66000009
	DCD	&66800009
	DCD	&69000009
	DCD	&69800009
	DCD	&6A000009
	DCD	&6A800009
	DCD	&6B000009
	DCD	&6B800009
	DCD	&6C000009
	DCD	&6C800009
	DCD	&6D000009
	DCD	&6D800009
	DCD	&4C000009
	DCD	&4C800009
	DCD	&4D000009
	DCD	&60000006
	DCD	&4D800009
	DCD	&0100000B
	DCD	&0180000B
	DCD	&01A0000B
	DCD	&0120000C
	DCD	&0130000C
	DCD	&0140000C
	DCD	&0150000C
	DCD	&0160000C
	DCD	&0170000C
	DCD	&01C0000C
	DCD	&01D0000C
	DCD	&01E0000C
	DCD	&01F0000C

makeupbl	; Make-up for colour 1
	DCD	&03C0000A
	DCD	&0C80000C
	DCD	&0C90000C
	DCD	&05B0000C
	DCD	&0330000C
	DCD	&0340000C
	DCD	&0350000C
	DCD	&0360000D
	DCD	&0368000D
	DCD	&0250000D
	DCD	&0258000D
	DCD	&0260000D
	DCD	&0268000D
	DCD	&0390000D
	DCD	&0398000D
	DCD	&03A0000D
	DCD	&03A8000D
	DCD	&03B0000D
	DCD	&03B8000D
	DCD	&0290000D
	DCD	&0298000D
	DCD	&02A0000D
	DCD	&02A8000D
	DCD	&02D0000D
	DCD	&02D8000D
	DCD	&0320000D
	DCD	&0328000D
	DCD	&0100000B
	DCD	&0180000B
	DCD	&01A0000B
	DCD	&0120000C
	DCD	&0130000C
	DCD	&0140000C
	DCD	&0150000C
	DCD	&0160000C
	DCD	&0170000C
	DCD	&01C0000C
	DCD	&01D0000C
	DCD	&01E0000C
	DCD	&01F0000C

terminwh	; Termin for colour 0
	DCD	&35000008
	DCD	&1C000006
	DCD	&70000004
	DCD	&80000004
	DCD	&B0000004
	DCD	&C0000004
	DCD	&E0000004
	DCD	&F0000004
	DCD	&98000005
	DCD	&A0000005
	DCD	&38000005
	DCD	&40000005
	DCD	&20000006
	DCD	&0C000006
	DCD	&D0000006
	DCD	&D4000006
	DCD	&A8000006
	DCD	&AC000006
	DCD	&4E000007
	DCD	&18000007
	DCD	&10000007
	DCD	&2E000007
	DCD	&06000007
	DCD	&08000007
	DCD	&50000007
	DCD	&56000007
	DCD	&26000007
	DCD	&48000007
	DCD	&30000007
	DCD	&02000008
	DCD	&03000008
	DCD	&1A000008
	DCD	&1B000008
	DCD	&12000008
	DCD	&13000008
	DCD	&14000008
	DCD	&15000008
	DCD	&16000008
	DCD	&17000008
	DCD	&28000008
	DCD	&29000008
	DCD	&2A000008
	DCD	&2B000008
	DCD	&2C000008
	DCD	&2D000008
	DCD	&04000008
	DCD	&05000008
	DCD	&0A000008
	DCD	&0B000008
	DCD	&52000008
	DCD	&53000008
	DCD	&54000008
	DCD	&55000008
	DCD	&24000008
	DCD	&25000008
	DCD	&58000008
	DCD	&59000008
	DCD	&5A000008
	DCD	&5B000008
	DCD	&4A000008
	DCD	&4B000008
	DCD	&32000008
	DCD	&33000008
	DCD	&34000008

terminbl	; Termin for colour 1
	DCD	&0DC0000A
	DCD	&40000003
	DCD	&C0000002
	DCD	&80000002
	DCD	&60000003
	DCD	&30000004
	DCD	&20000004
	DCD	&18000005
	DCD	&14000006
	DCD	&10000006
	DCD	&08000007
	DCD	&0A000007
	DCD	&0E000007
	DCD	&04000008
	DCD	&07000008
	DCD	&0C000009
	DCD	&05C0000A
	DCD	&0600000A
	DCD	&0200000A
	DCD	&0CE0000B
	DCD	&0D00000B
	DCD	&0D80000B
	DCD	&06E0000B
	DCD	&0500000B
	DCD	&02E0000B
	DCD	&0300000B
	DCD	&0CA0000C
	DCD	&0CB0000C
	DCD	&0CC0000C
	DCD	&0CD0000C
	DCD	&0680000C
	DCD	&0690000C
	DCD	&06A0000C
	DCD	&06B0000C
	DCD	&0D20000C
	DCD	&0D30000C
	DCD	&0D40000C
	DCD	&0D50000C
	DCD	&0D60000C
	DCD	&0D70000C
	DCD	&06C0000C
	DCD	&06D0000C
	DCD	&0DA0000C
	DCD	&0DB0000C
	DCD	&0540000C
	DCD	&0550000C
	DCD	&0560000C
	DCD	&0570000C
	DCD	&0640000C
	DCD	&0650000C
	DCD	&0520000C
	DCD	&0530000C
	DCD	&0240000C
	DCD	&0370000C
	DCD	&0380000C
	DCD	&0270000C
	DCD	&0280000C
	DCD	&0580000C
	DCD	&0590000C
	DCD	&02B0000C
	DCD	&02C0000C
	DCD	&05A0000C
	DCD	&0660000C
	DCD	&0670000C

	LTORG


spool

	; Writes out a bit sequence (held in Rcodelen).
	;
	; Rencword and Rencwordpos and updated, Rencindexcom and [Rencindexcom] too if necessary.
	;
	; -:
	; R:
	; W:
	;	Rencwork1 (or contains len if spooldirect)
	; R/W:
	;	Rcodelen (code in B3-B1 (msb-aligned), len in B0 -- or code in B3-B1 if spooldirect)
	;	Rencword
	;	Rencwordpos
	;	Rencindexcom
	; Calls:
	;	-
	; Called:
	;	tifflo_encode_1d
	; Notes:
	;	PSR preserved

	AND	Rencwork1, Rcodelen, #&FF	; Rencwork1 = len only
	BIC	Rcodelen, Rcodelen, #&FF	; Rcodelen = code only (in B3-B1)

spooldirect

	ORR	Rencword, Rencword, Rcodelen, LSR Rencwordpos	; word = word OR (code>>wordpos)
	ADD	Rencwordpos, Rencwordpos, Rencwork1	; wordpos += len

spoolout
	CMP	Rencwordpos, #8			; while (wordpos>=8) {
						;@@ Optimise this (short-circuit)?
	MOVHS	Rencwork1, Rencword, LSR#24	;    Rencwork1 = word>>24
	STRHSB	Rencwork1, [Rencindexcom], #1	;    ?encindex = word>>24; encindex+=1
	MOVHS	Rencword, Rencword, LSL#8	;    word = word<<8
	SUBHS	Rencwordpos, Rencwordpos, #8	;    wordpos -=8
	BHS	spoolout			; }

	MOVS	pc, lr

	LTORG


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; A macro to do unsigned integer division. It takes four parameters, each of
; which should be a register name:
;
; $Div: The macro places the quotient of the division in this register -
;       ie $Div := $Top DIV $Bot.
;       $Div may be omitted if only the remainder is wanted.
; $Top: The macro expects the dividend in this register on entry and places
;       the remainder in it on exit - ie $Top := $Top MOD $Bot.
; $Bot: The macro expects the divisor in this register on entry. It does not
;       alter this register.
; $Temp:The macro uses this register to hold intermediate results. Its initial
;       value is ignored and its final value is not useful.
;
; $Top, $Bot, $Temp and (if present) $Div must all be distinct registers.
; The macro does not check for division by zero; if there is a risk of this
; happening, it should be checked for outside the macro.

        MACRO
$Label  DIV     $Div,$Top,$Bot,$Temp
        ROUT

        ASSERT  $Top <> $Bot            ; Produce an error if the
        ASSERT  $Top <> $Temp           ; registers supplied are
        ASSERT  $Bot <> $Temp           ; not all different.
        [       "$Div" /= ""
        ASSERT  $Div <> $Top
        ASSERT  $Div <> $Bot
        ASSERT  $Div <> $Temp
        ]

$Label  MOV     $Temp,$Bot              ; Put the divisor in $Temp
        CMP     $Temp,$Top,LSR #1       ; Then double it until
90      MOVLS   $Temp,$Temp,LSL #1      ; 2 * $Temp > $Top.
        CMP     $Temp,$Top,LSR #1
        BLS     %b90
        [       "$Div" /= ""
        MOV     $Div,#0                 ; Initialise the quotient.
        ]

91      CMP     $Top,$Temp              ; Can we subtract $Temp?
        SUBCS   $Top,$Top,$Temp         ; If we can, do so.
        [       "$Div" /= ""
        ADC     $Div,$Div,$Div          ; Double $Div & add new bit
        ]
        MOV     $Temp,$Temp,LSR #1      ; Halve $Temp,
        CMP     $Temp,$Bot              ; and loop until we've gone
        BHS     %b91                    ; past the original divisor.

        ROUT
        MEND
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; void tifflo_scale_line (short int *linein, int widthin
;                        , short int *lineout, int widthout);

	EXPORT	tifflo_scale_line

	ROUT
	[ names
01
	DCB	"tifflo_scale_line", 0
	ALIGN
02
	DCD	&ff000000 + %02 - %01
	]

tifflo_scale_line

	; Scales a scan line from widthin pels to widthout pels.  Short run lengths
	; are not necessarily preserved, but the output line is guaranteed to contain
	; widthout pels exactly.
	;
	; Inputs:	linein
	;		widthin
	;		lineout
	;		widthout
	;
	; Outputs:	nothing
	;
	; Corrupts:	undefined
	; (i.e. sets)
	;
	; Called:	C
	;
	; Calls:	writeraw (inputs Rlen, Raddfirst, Rdecindexraw)
	;			 (outputs Raddfirst, Rdecindexraw)
	;			 (corrupts lr, Rlen)

	STMFD	sp!, APCSregsin

	ASSERT	Rscalelinein = a1		; Check input regs...
	ASSERT	Rscalewidthin = a2
	ASSERT	Rscalelineout = a3
	ASSERT	Rscalewidthout = a4
	ASSERT	Rscaleleftover = 4		; Check work regs...
	ASSERT	Rscalebitstogo = 5
	ASSERT	Rdecindexraw > 5		; Make sure input regs don't clash
	MOV	Rdecindexraw, Rscalelineout
	ASSERT	Raddfirst = Rstaticbase		; Rstaticbase = Raddfirst, so safe to squash now
	MOV	Raddfirst, #isfirst		; First, not add
	MOV	Rscalebitstogo, Rscalewidthin
	CMP	Rscalewidthin, Rscalewidthout	; Take special speedy action if no scaling to do
	BEQ	tifflo_scale_line_not

	MOV	Rscaleleftover, #0

tifflo_scale_line_next
	EOR	lr, Rscalelinein, #2
	LDR	lr, [lr]
	ADD	Rscalelinein, Rscalelinein, #2	; Move on, please...
	MOV	Rlen, lr, LSR#16		; @@ this is not tremendously efficient (1 LDRs per hword), but...
	SUB	Rscalebitstogo, Rscalebitstogo, Rlen			; Keep track of bits to go
	MLA	Rscaleleftover, Rscalewidthout, Rlen, Rscaleleftover	; l = out * len + l
	DIV	Rlen, Rscaleleftover, Rscalewidthin, lr			; len = l / lin, l = l % lin
	BL	writeraw			; Write len out
	CMP	Rscalebitstogo, #0		; More?
	BGT	tifflo_scale_line_next
	B	tifflo_scale_line_done

tifflo_scale_line_not
	EOR	lr, Rscalelinein, #2
	LDR	lr, [lr]
	ADD	Rscalelinein, Rscalelinein, #2	; Move on, please...
	MOV	Rlen, lr, LSR#16		; @@ this is not tremendously efficient (1 LDRs per hword), but...
	SUB	Rscalebitstogo, Rscalebitstogo, Rlen			; Keep track of bits to go
	BL	writeraw			; Write len out
	CMP	Rscalebitstogo, #0		; More?
	BGT	tifflo_scale_line_not

tifflo_scale_line_done
	MOV	lr, #0				; Insert 2D MR EOL guard
	STRB	lr, [Rdecindexraw], #1
	STRB	lr, [Rdecindexraw], #1

	LDMFD	sp!, APCSregsout^

	LTORG


enc_findb1

	; Finds b1 given the current a0, b1, and their colours.
	;
	; Inputs:	Renc2da0
	;		Renc2db1
	;		Renc2dcola0b1
	;		Renc2dindexrefraw
	;		Renc2dimagewid
	;
	; Outputs:	Renc2db1
	;		Renc2dcola0b1
	;		Renc2dindexrefraw
	;
	; Corrupts:	lr
	;
	; Called:	tifflo_encode_2d
	;
	; Calls:	nothing
	;
	; Assumes:	valid everything

	STMFD	sp!, {lr}

	CMP	Renc2db1, Renc2dimagewid		; if (b1 < iw)
	SUBLT	Renc2dindexrefraw, Renc2dindexrefraw,#2	;    --indexrefraw;

enc_findb1_rewind
	CMP	Renc2db1, Renc2da0			; while (b1 > a0) {
	SUBGT	Renc2dindexrefraw, Renc2dindexrefraw, #2 ;   b1 -= *--indexrefraw;
	EORGT	lr, Renc2dindexrefraw, #2
	LDRGT	lr, [lr]
	SUBGT	Renc2db1, Renc2db1, lr, LSR#16
;	LDRGTB	lr, [Renc2dindexrefraw, #-1]!		;    b1 -= *--indexrefraw;
;	SUBGT	Renc2db1, Renc2db1, lr, LSL#8
;	LDRGTB	lr, [Renc2dindexrefraw, #-1]!
;	SUBGT	Renc2db1, Renc2db1, lr
	EORGT	Renc2dcola0b1, Renc2dcola0b1, #colb1	;    colb1 = 1 - colb1;
	BGT	enc_findb1_rewind			; };
	B	enc_findb1_whiletest

enc_findb1_forwind					; while ([*]) {
	EOR	lr, Renc2dindexrefraw, #2		;    b1 += *indexrefraw++;
	LDR	lr, [lr]
	ADD	Renc2dindexrefraw, Renc2dindexrefraw, #2
	ADD	Renc2db1, Renc2db1, lr, LSR#16
;	LDRB	lr, [Renc2dindexrefraw], #1		;
;	ADD	Renc2db1, Renc2db1, lr
;	LDRB	lr, [Renc2dindexrefraw], #1
;	ADD	Renc2db1, Renc2db1, lr, LSL#8
	EOR	Renc2dcola0b1, Renc2dcola0b1, #colb1	;    colb1 = 1 - colb1;

enc_findb1_whiletest					; };
	CMP	Renc2db1, Renc2da0			; [*] (b1 <= a0
	BLE	enc_findb1_forwind
	CMP	Renc2dcola0b1, Renc2dcola0b1, ROR#16	; [*] || colb1 == cola0)
	BEQ	enc_findb1_forwind

	LDMFD	sp!, {pc}^

	LTORG


; void tifflo_encode_2d (int insertEOL);

	EXPORT	tifflo_encode_2d

	ROUT
	[ names
01
	DCB	"tifflo_encode_2d", 0
	ALIGN
02
	DCD	&ff000000 + %02 - %01
	]

tifflo_encode_2d

	; Encodes one raw scan line from encindexraw to encindexcom using 2D coding.
	;
	; The line must be exactly encimagewidth pels long.
	; encword and encwordpos contain any leftover information from the previous line.
	; Put EOL at start if requested (non-zero for EOL+0 (2D line in 2D MR coding).
	;
	; encindexcom after call contains the address of the next byte to be written out.
	; Note the leftover byte is actually written at [encindexcom],
	; to ease handling of the last line/padded lines.
	;
	; Inputs:	encword
	;		encwordpos
	;		encindexcom
	;		encindexraw
	;		encimagewidth
	;		decrefline
	;
	; Outputs:	encword
	;		encwordpos
	;		encindexcom
	;		encwordposprev (not useful)
	;		encindexcomprev (not useful)
	;
	; Corrupts:	@@describe
	; (i.e. sets)
	;
	; Called:	C
	;
	; Calls:	@@describe
	;
	; Assumes:	no runs greater than 5183 in length

	STMFD	sp!, APCSregsin

	StaticBaseFromSL	Rstaticbase
	STMFD	sp!, {Rstaticbase}

	LDRVar	Rencword, Rstaticbase, encword
	LDRVar	Rencwordpos, Rstaticbase, encwordpos
	LDRVar	Rencindexcom, Rstaticbase, encindexcom
	LDRVar	Rencindexraw, Rstaticbase, encindexraw
	LDRVar	Renc2dimagewid, Rstaticbase, encimagewidth
	LDRVar	Renc2dindexrefraw, Rstaticbase, decrefline

	STMFD	sp!, {Rencwordpos}		; Store posn for minscan
	STMFD	sp!, {Rencindexcom}

	ASSERT	Renc2dcola0b1 = Rstaticbase	; Make sure use of Rstaticbase was safe

	ASSERT	Renccode = a1			; Make sure use of a1 is safe (Renccode not yet assigned)
	CMP	a1, #0				; 0 = no EOL at the start
	MOVNE	Renccode, #EOLcode		; 2 = 2D MR EOL (EOL+0)
	MOVNE	Rencclen, #EOLlen + 1		; + 1 for '0'
	BLNE	spooldirect


	MVN	Renc2da0, #0			; a0 = -1;
	EOR	lr, Rencindexraw, #2		; a1 = *encindexraw++;
	LDR	lr, [lr]
	ADD	Rencindexraw, Rencindexraw, #2
	MOV	Renc2da1, lr, LSR#16
;;;@@optim
;	LDRB	Renc2da1, [Rencindexraw], #1	; a1 = *encindexraw++;
;	LDRB	lr, [Rencindexraw], #1
;	ORR	Renc2da1, Renc2da1, lr, LSL#8
	EOR	lr, Renc2dindexrefraw, #2	; b1 = *enc2dindexrefraw++;
	LDR	lr, [lr]
	ADD	Renc2dindexrefraw, Renc2dindexrefraw, #2
	MOV	Renc2db1, lr, LSR#16
;	LDRB	Renc2db1, [Renc2dindexrefraw], #1	; b1 = *encindexraw++;
;	LDRB	lr, [Renc2dindexrefraw], #1
;	ORR	Renc2db1, Renc2db1, lr, LSL#8
	MOV	Renc2dcola0b1, #colb1		; cola0 = 0; colb1 = 1;

enc2d_loop				; for (;;) {

	MOV	Renc2db2, Renc2db1		; b2 = b1;
	CMP	Renc2db1, Renc2dimagewid	; if (b1 < encimagewidth)
	EORLT	lr, Renc2dindexrefraw, #2	;    b2 += *encindexrefraw++;
	LDRLT	lr, [lr]
	ADDLT	Renc2dindexrefraw, Renc2dindexrefraw, #2
	ADDLT	Renc2db2, Renc2db2, lr, LSR#16
;;;@@optim
;	LDRLTB	lr, [Renc2dindexrefraw], #1	;    b2 += *encindexrefraw++;
;	ADDLT	Renc2db2, Renc2db2, lr
;	LDRLTB	lr, [Renc2dindexrefraw], #1
;	ADDLT	Renc2db2, Renc2db2, lr, LSL#8
	CMP	Renc2db2, Renc2da1		; if (b2 < a1)
	BLT	enc2d_pass			;    goto passmode;
	SUB	lr, Renc2da1, Renc2db1		; if (abs (a1 - b1) > 3)
	ADD	lr, lr, #3
	CMP	lr, #6
	BHI	enc2d_hor			;    goto hormode;

enc2d_vert					; On entry, lr contains (a1 - b1 + 3)

	CMP	lr, #0
	MOVEQ	Renccode, #0x04000000		; Spool out 0000010 for V-3
	MOVEQ	Rencclen, #7
	CMP	lr, #1
	MOVEQ	Renccode, #0x08000000		; Spool out 000010 for V-2
	MOVEQ	Rencclen, #6
	CMP	lr, #2
	MOVEQ	Renccode, #0x40000000		; Spool out 010 for V-1
	MOVEQ	Rencclen, #3
	CMP	lr, #3
	MOVEQ	Renccode, #0x80000000		; Spool out 1 for V0
	MOVEQ	Rencclen, #1
	CMP	lr, #4
	MOVEQ	Renccode, #0x60000000		; Spool out 011 for V1
	MOVEQ	Rencclen, #3
	CMP	lr, #5
	MOVEQ	Renccode, #0x0c000000		; Spool out 000011 for V2
	MOVEQ	Rencclen, #6
	CMP	lr, #6
	MOVEQ	Renccode, #0x06000000		; Spool out 0000011 for V3
	MOVEQ	Rencclen, #7
	BL	spooldirect

	CMP	Renc2da1, Renc2dimagewid	; if (a1 >= encimagewidth)
	BGE	enc2d_done			;    break;

	MOV	Renc2da0, Renc2da1		; a0 = a1;
	EOR	Renc2dcola0b1, Renc2dcola0b1, #cola0	; cola0 = 1 - cola0;
	EOR	lr, Rencindexraw, #2		; a1 += *encindexraw++;
	LDR	lr, [lr]
	ADD	Rencindexraw, Rencindexraw, #2
	ADD	Renc2da1, Renc2da1, lr, LSR#16
;;;@@optim
;	LDRB	lr, [Rencindexraw], #1		; a1 += *encindexraw++;
;	ADD	Renc2da1, Renc2da1, lr
;	LDRB	lr, [Rencindexraw], #1
;	ADD	Renc2da1, Renc2da1, lr, LSL#8

	BL	enc_findb1			; tifflo_findb1;
	B	enc2d_loop

enc2d_pass

	MOV	Renccode, #0x10000000		; Spool out 0001
	MOV	Rencclen, #4
	BL	spooldirect

	CMP	Renc2db2, Renc2dimagewid	; if (b2 >= encimagewidth)
	BGE	enc2d_done			;    break;

	MOV	Renc2da0, Renc2db2		; a0 = b2;
	EOR	lr, Renc2dindexrefraw, #2	; b1 = b2 + *encindexrefraw++;
	LDR	lr, [lr]			; // cola0 unchanged
	ADD	Renc2dindexrefraw, Renc2dindexrefraw, #2 ; // a1 unchanged
	ADD	Renc2db1, Renc2db2, lr, LSR#16	; // colb1 unchanged
;;;@@optim
;	LDRB	lr, [Renc2dindexrefraw], #1	; b1 = b2 + *encindexrefraw++;
;	ADD	Renc2db1, Renc2db2, lr		; // cola0 unchanged
;	LDRB	lr, [Renc2dindexrefraw], #1	; // a1 unchanged
;	ADD	Renc2db1, Renc2db1, lr, LSL#8	; // colb1 unchanged
	B	enc2d_loop

enc2d_hor

	STMFD	sp!, {Renc2db1}			; As of now, b1 will be h1 and b2 will be h2
						; No need to preserve b2 since regenerated from b1
						; on loop entry

	SUB	Renc2dh1, Renc2da1, Renc2da0	; h1 = a1 - a0 - (a0 < 0);
	SUB	Renc2dh1, Renc2dh1, Renc2da0, LSR#31

	CMP	Renc2da1, Renc2dimagewid	; if (a1 < encimagewidth)
	EORLT	lr, Rencindexraw, #2		;    h2 = *encindexraw++;
	LDR	lr, [lr]
	ADD	Rencindexraw, Rencindexraw, #2
	MOV	Renc2dh2, lr, LSR#16
;;;@@optim
;	LDRLTB	Renc2dh2, [Rencindexraw], #1	;    h2 = *encindexraw++;
;	LDRLTB	lr, [Rencindexraw], #1
;	ADDLT	Renc2dh2, Renc2dh2, lr, LSL#8	; else
	MOVGE	Renc2dh2, #0			;    h2 = 0;

	ADD	Renc2da0, Renc2da1, Renc2dh2	; a0 = a1 + h2;

	MOV	Renccode, #0x20000000		; Spool out 001
	MOV	Rencclen, #3
	BL	spooldirect

	CMP	Renc2dh1, #64
	BHS	enc2d_longh1
enc2d_shorth1
	TST	Renc2dcola0b1, #cola0		; codelen = cola0 ?
	ADRNEL	lr, terminbl			;    ? terminbl[h1] ;@@ it would be nice not to ADRL
	ADREQL	lr, terminwh			;    : terminwh[h1]
	LDR	Renccodelen, [lr, Renc2dh1, LSL#2]
	BL	spool

	CMP	Renc2dh2, #64
	BHS	enc2d_longh2
enc2d_shorth2
	TST	Renc2dcola0b1, #cola0		; codelen = cola0 ?
	ADRNEL	lr, terminwh			;    ? terminwh[h2]
	ADREQL	lr, terminbl			;    : terminbl[h2]
	LDR	Renccodelen, [lr, Renc2dh2, LSL#2]
	BL	spool

	LDMFD	sp!, {Renc2db1}			; As of now b1 will be b1 and b2 will be b2 again

	CMP	Renc2da0, Renc2dimagewid	; if (a0 >= encimagewidth)
	BGE	enc2d_done			;    break;

	EOR	lr, Rencindexraw, #2		; a1 = a0 + *encindexraw++;
	LDR	lr, [lr]			; // cola0 unchanged
	ADD	Rencindexraw, Rencindexraw, #2
	ADD	Renc2da1, Renc2da0, lr, LSR#16
;;;@@optim
;	LDRB	lr, [Rencindexraw], #1		; a1 = a0 + *encindexraw++;
;	ADD	Renc2da1, Renc2da0, lr		; // cola0 unchanged
;	LDRB	lr, [Rencindexraw], #1
;	ADD	Renc2da1, Renc2da1, lr, LSL#8

	BL	enc_findb1			; tifflo_findb1;
	B	enc2d_loop

enc2d_done				; };

	ASSERT	Renc2db2 = Renclen		; Make sure using enclen is safe

	LDMFD	sp!, {Rencclen}			; Rencclen = encindexcomprev
	SUB	lr, Rencindexcom, Rencclen	; lr = encindexcom-encindexcomprev
	ADD	lr, Rencwordpos, lr, LSL#3	; lr = (encindex-prev)*8+wordpos
	LDMFD	sp!, {Rencclen}			; Rencclen = encwordposprev
	SUB	lr, lr, Rencclen		; lr = (enc-prev)*8+wordpos-wordposprev

	ASSERT	Renc2dcola0b1 = Rstaticbase	; Make sure using Rstaticbase is safe
	LDMFD	sp!, {Rstaticbase}

	LDRVar	Rencclen, Rstaticbase, encminscan
	SUBS	Renclen, Rencclen, lr		; Renclen = number of bits to pad [non-standard reg use];
						; Rencclen can't be used since spool squashes it]

enc2d_pad					; Very inefficient...

	MOVGT	Renccodelen, #1			; Renccodelen == '0'
	BLGT	spool
	SUBGTS	Renclen, Renclen, #1
	BGT	enc2d_pad

	MOV	lr, Rencword, LSR#24		; Spoolend
	STRB	lr, [Rencindexcom]

	STRVar	Rencword, Rstaticbase, encword, lr
	STRVar	Rencwordpos, Rstaticbase, encwordpos, lr
	STRVar	Rencindexcom, Rstaticbase, encindexcom, lr

	LDMFD	sp!, APCSregsout^


enc2d_longh1

	TST	Renc2dcola0b1, #cola0		; codelen = cola0 ?
	ADRNEL	lr, makeupbl - 4		;    ? makeupbl[h1] ;@@ it would be nice not to ADRL
	ADREQL	lr, makeupwh - 4		;    : makeupwh[h1]
	MOV	Rencclen, Renc2dh1, LSR#6	; Rencclen = h1 DIV 64
	CMP	Rencclen, #2560/64		; If >2560 need to insert repeated 2560 makeup code
	LDRHI	Renccodelen, [lr, #2560/64:SHL:2]
	BLHI	spool					; This does not handle >5120 runs,
	SUBHI	Rencclen, Rencclen, #2560/64		; but maximum run is 4864 (A3 R16) anyway
	TST	Renc2dcola0b1, #cola0		; codelen = cola0 ? ;@@ it would be nice not to redo
	ADRNEL	lr, makeupbl - 4		;    ? makeupbl[h1]
	ADREQL	lr, makeupwh - 4		;    : makeupwh[h1]
	LDR	Renccodelen, [lr, Rencclen, LSL#2]
	BL	spool
	AND	Renc2dh1, Renc2dh1, #&3F	; len = len MOD 64
	B	enc2d_shorth1

enc2d_longh2

	TST	Renc2dcola0b1, #cola0		; codelen = cola0 ?
	ADRNEL	lr, makeupwh - 4		;    ? makeupwh[h2] ;@@ it would be nice not to ADRL
	ADREQL	lr, makeupbl - 4		;    : makeupbl[h2]
	MOV	Rencclen, Renc2dh2, LSR#6	; Rencclen = h2 DIV 64
	CMP	Rencclen, #2560/64		; If >2560 need to insert repeated 2560 makeup code
	LDRHI	Renccodelen, [lr, #2560/64:SHL:2]
	BLHI	spool					; This does not handle >5120 runs,
	SUBHI	Rencclen, Rencclen, #2560/64		; but maximum run is 4864 (A3 R16) anyway
	TST	Renc2dcola0b1, #cola0		; codelen = cola0 ? ;@@ it would be nice not to redo
	ADRNEL	lr, makeupwh - 4		;    ? makeupwh[h2]
	ADREQL	lr, makeupbl - 4		;    : makeupbl[h2]
	LDR	Renccodelen, [lr, Rencclen, LSL#2]
	BL	spool
	AND	Renc2dh2, Renc2dh2, #&3F	; len = len MOD 64
	B	enc2d_shorth2

	LTORG


	END
