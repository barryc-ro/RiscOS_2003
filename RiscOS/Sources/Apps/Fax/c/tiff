/*****************************************************************************/
/* File:    main.c                                                           */
/* Purpose: TIFF handling for !Fax application                               */
/* Owner:   Mark RISON                                                       */
/* History: 1997-06-27  MGR   Created                                        */
/*****************************************************************************/

#include "fax/global.h"

#include "faxdebug.h"
#include "mgrlib/usTimer.h"
#include "pdebug.h"
#include "tiff.h"
#include "mgrlib/misc.h"
#include "swis.h"
#include "stdlib.h"

#include <stdio.h>
#include <string.h>

///////////////////////////////////////////////////////////////////////////////
//
// C_Constants

#define LITTLEENDIAN 0
#define BIGENDIAN 1

#define ISADDRESS (0<<1)
#define ISHANDLE (1<<1)
#define REVERSENOT (0<<2)
#define REVERSEIT (1<<2)

///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// C_Typedefs


///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// C_Interns

intern int tiff_wput (FILE *const f, const uint32 w);
intern int tiff_hput (FILE *const f, const uint16 h);
intern int tiff_wget (FILE *const f, uint32 *const w, const int endian);
intern int tiff_hget (FILE *const f, uint16 *const h, const int endian);
intern int tiff_bget (FILE *const f, byte *const b);
intern int tiff_rget (FILE *const f, struct rational *const r, const int endian
                     , const int offset);
intern int tiff_skip (FILE *const f, const int n);

extern void tifflo_fillupcall (int flags);
extern void tifflo_eatabitcall (int flags);
extern int tifflo_decode_1d (int flags);
extern int tifflo_decode_2d (int flags);
extern void tifflo_encode_1d (int insertEOL);
extern void tifflo_encode_2d (int insertEOL);


///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// C_Regionals


///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// C_Enumerations


///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// C_Macros


///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
//
// tiff_open_write
//
// Opens an output TIFF file and writes TIFF header.
// The file pointer is left pointing at the end of the header.
// Note the header initially points to no valid IFD.
//
// This routine is typically followed by tiff_create_ifd
// with previfdptrpos set to 0x00000004.
//
// Inputs:  pathname    (pathname of TIFF file to open)
//
// Outputs: TIFF file
//
// Assumes: nothing
//
// Returns: FILE pointer (NULL if failed -- any created output file is deleted)
//
///////////////////////////////////////////////////////////////////////////////

extern FILE *tiff_open_write (const char *const pathname)
{
   FILE *f;

   f = fopen (pathname, "wb+");
   if (!f) return NULL;

   if (tiff_hput (f, 0x4949)   // We're little-endian
      || tiff_hput (f, 0x002a) // TIFF file identifier
      || tiff_wput (f, 0)      // Offset to first IFD (to be filled later)
      ) {

      fclose (f);
      remove (pathname);
      return NULL;

   }

   return f;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_create_ifd
//
// Creates (but does not fill) a new IFD, pointed at by the previous IFD (or the
// TIFF header), at the current file position (rounded up to an even address if
// necessary).
// The file pointer is left pointing at the end of the IFD.
//
// The nentries and nextra values can be obtained from tiff_get_ifdsize.
//
// This routine is typically followed by image data output to file, itself
// followed by tiff_write_nentries with ifdpos set to the value returned
// by this routine.
//
// Inputs:  f           (pointer to FILE)
//          previfdptrpos (file pointer for previous IFD's pointer to next IFD)
//          nentries    (number of entries in IFD)
//          nextra      (number of extra words in IFD)
//
// Outputs: undefined bytes
//
// Assumes: nothing
//
// Returns: file pointer to IFD (0 if failed)
//
///////////////////////////////////////////////////////////////////////////////

extern long int tiff_create_ifd (FILE *const f, const long int previfdptrpos
                                , const int nentries, const int nextra)
{
   long int currpos;

   currpos = (ftell (f) + 1) & ~1; // Round to next even address

   /* Grumble note: the TIFF 6.0 specification does not clearly define
      what it means by 'word', though it is possible to deduce it means
      '16 bits'... */

   if (fseek (f, previfdptrpos, SEEK_SET)) return 0;

   if (tiff_wput (f, (uint32) currpos)) return 0;

   if (fseek (f, currpos, SEEK_SET)) return 0;

   if (fseek (f, 2L + nentries * 12L + nextra * 4L + 4L, SEEK_CUR)) return 0;

   return currpos;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_write_nentries
//
// Writes IFD's nentries halfword.
// The file pointer is left pointing at the end of the nentries halfword.
//
// This routine is typically followed by calls to tiff_write_entry.
//
// Inputs:  f           (pointer to FILE)
//          ifdpos      (file pointer for IFD)
//          nentries    (number of entries in IFD)
//
// Outputs: IFD nentries halfword
//
// Assumes: nothing
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

extern long int tiff_write_nentries (FILE *const f, const long int ifdpos
                                    , const uint16 nentries)
{
   if (fseek (f, ifdpos, SEEK_SET)) return 1;

   if (tiff_hput (f, nentries)) return 1;

   return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_write_entry
//
// Writes entry.
// The file pointer is left pointing at the end of the entry.
//
// This routine is typically followed by more calls to this routine, and then
// to tiff_write_extra, for the IFD and any extra words.
//
// Inputs:  f           (pointer to FILE)
//          tag         (TIFF tag)
//          type        (TIFF type)
//          count       (TIFF count)
//          value       (TIFF value)
//
// Outputs: IFD entry
//
// Assumes: nothing
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

extern long int tiff_write_entry (FILE *const f
                                 , const uint16 tag, const uint16 type
                                 , const uint32 count, const uint32 value)
{
   if (tiff_hput (f, tag)) return 1;
   if (tiff_hput (f, type)) return 1;
   if (tiff_wput (f, count)) return 1;
   if (tiff_wput (f, value)) return 1;

   return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_write_extra
//
// Writes extra word.
// The file pointer is left pointing at the end of the extra word.
//
// This routine is typically followed by more calls to this routine, and then
// to tiff_create_ifd with previfdptrpos set appropriately (to the file pointer
// for the first tiff_write_extra, which sets the pointer to the next IFD).
//
// Inputs:  f           (pointer to FILE)
//          w           (word)
//
// Outputs: IFD extra word
//
// Assumes: nothing
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

extern long int tiff_write_extra (FILE *const f, const uint32 w)
{
   if (tiff_wput (f, w)) return 1;

   return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_wput
//
// Puts a word.
//
// Inputs:  f           (pointer to FILE)
//          w           (word)
//
// Outputs: word to file
//
// Assumes: nothing
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

intern int tiff_wput (FILE *const f, const uint32 w)
{
   if (fwrite (&w, 4, 1, f) != 1) return 1;

   return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_hput
//
// Puts a halfword (16 bits).
//
// Inputs:  f           (pointer to FILE)
//          h           (halfword)
//
// Outputs: word to file
//
// Assumes: nothing
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

intern int tiff_hput (FILE *const f, const uint16 h)
{
   if (fwrite (&h, 2, 1, f) != 1) return 1;

   return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_stream_in
//
// Streams in an octet of fax message data, and detects EOLs.  If EOL is
// detected, it is removed and the stream is terminated with four NULs.
// The caller should reset the offset to zero in this case.
//
// Note the offset is incremented by 1 even if EOL was found, so
// the number of bits streamed in, excluding leftovers from the previous one, is
// (s->noctets * 8 - 8) + (8 - (eoldata & 0xff)).
//
// Inputs:  rawoctet     (raw (from modem) message octet)
//          encbuff      (buffer for message data)
//          offset       (offset for octet in buffer -- initialise to zero)
//          nzeroes      (internal use (EOL detection) -- initialise to zero)
//
// Outputs: encbuff      (buffer updated)
//          offset       (offset updated)
//          nzeroes      (updated)
//
// Assumes: buffer is big enough
//
// Returns: non-zero if EOL detected:
//             byte 0 contains number of bits past EOL
//             byte 1 contains those bits (last bit in bit 0)
//             byte 2 is non-zero
//             byte 3 is undefined
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_stream_in (unsigned char rawoctet
                          , unsigned char encbuff[], int *const offset
                          , int *const nzeroes)
{
   int leftover = 0;

#ifdef TIMING
   usstart (TIMINGSTREAMIN);
#endif
#ifdef VDEBUGOLD
   usclock_t starttime = usclock ();
   static usclock_t totaltime = 0;
#endif

/*
   // The following magnificent algorithm is no faster then the
   // simple-minded one used below.  Sigh.

   if (rawoctet == 0) {

      encbuff[(*offset)++] = 0;
      *nzeroes += 8;
//      if (totaltime < 5000)
//         PDebug_Printf ("Zero octet; offset now %i, nzeroes now %i\n"
//                       , *offset, *nzeroes);

   } else {

      int firstnonzero, b;

      // Find first non-zero bit starting from the *right* (b0) in the *raw*octet
      // because b0 of the rawoctet is the first transmitted/received
      firstnonzero = rawoctet & (1 + ~rawoctet);

      // Convert to bit number
      if (firstnonzero == 0x01)
         b = 7;
      else if (firstnonzero == 0x02)
         b = 6;
      else if (firstnonzero == 0x04)
         b = 5;
      else if (firstnonzero == 0x08)
         b = 4;
      else if (firstnonzero == 0x10)
         b = 3;
      else if (firstnonzero == 0x20)
         b = 2;
      else if (firstnonzero == 0x40)
         b = 1;
      else  // firstnonzero == 0x80
         b = 0;

      *nzeroes += 7 - b;
      octet = reverse[rawoctet];

//      if (totaltime < 5000)
//         PDebug_Printf ("Octet 0x%.2x; first non-zero at %i, nzeroes now %i\n"
//                       , octet, b, *nzeroes);

      if (*nzeroes < 11) {

         encbuff[(*offset)++] = octet;

//         if (totaltime < 5000)
//            PDebug_Printf ("Not EOL\n");

      } else {

//         if (totaltime < 5000)
//            PDebug_Printf ("EOL!\n");
         encbuff[(*offset)++] = 0;
         encbuff[*offset    ] = 0;
         encbuff[*offset + 1] = 0;
         encbuff[*offset + 2] = 0;
         // 1 << b is the one bit to clear
         leftover = b | (octet & ~(1U << b)) << 8 | 0x10000;

      }

      // Now find first non-zero bit starting from right in *octet*
      // because b0 of the octet is the last transmitted/received
      firstnonzero = octet & (1 + ~octet);

      // Convert to bit number
      if (firstnonzero == 0x01)
         *nzeroes = 0;
      else if (firstnonzero == 0x02)
         *nzeroes = 1;
      else if (firstnonzero == 0x04)
         *nzeroes = 2;
      else if (firstnonzero == 0x08)
         *nzeroes = 3;
      else if (firstnonzero == 0x10)
         *nzeroes = 4;
      else if (firstnonzero == 0x20)
         *nzeroes = 5;
      else if (firstnonzero == 0x40)
         *nzeroes = 6;
      else  // firstnonzero == 0x80
         *nzeroes = 7;

//      if (totaltime < 5000)
//         PDebug_Printf ("Offset now %i, nzeroes now %i\n"
//                       , *offset, *nzeroes);
   }
*/

   if (rawoctet == 0) {

      // All-zero is an easy special case
      encbuff[(*offset)++] = 0;
      *nzeroes += 8;

   } else {

      unsigned char octet;
      int b;

      // Reverse octet into human-friendly order and store
      octet = tifflo_reverse (rawoctet);
      encbuff[(*offset)++] = octet;

      // Scan for EOL
      for (b = 7; b >= 0; --b) {

         if (octet & (1 << b)) {

            // EOL is at least 11 zero bits followed by a one bit
            if (*nzeroes >= 11) {

               encbuff[*offset - 1] = 0;
               encbuff[*offset    ] = 0;
               encbuff[*offset + 1] = 0;
               encbuff[*offset + 2] = 0;
               // 1 << b is the one bit to clear
               leftover = b | (octet & ~(1U << b)) << 8 | 0x10000;

            }

            *nzeroes = 0;

         } else {

            ++*nzeroes;

         }

      }
   }

#ifdef TIMING
   usstop (TIMINGSTREAMIN);
#endif
#ifdef VDEBUGOLD
   totaltime += usclock () - starttime;
   if (leftover && *offset < 3)
      PDebug_Printf ("Time: %u us\n", totaltime / 2);
#endif

   return leftover;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_decode_ccittmh
//
// Decodes a CCITT MH-coded line from file.  The octets should
// have been reversed w.r.t. the modem if imagewidth is positive,
// else imagewidth should be negative.
//
// Inputs:  encfile      (file handle for encoded message data)
//          rawbuff      (buffer for raw message data)
//          imagewidth   (absolute value is expected image width)
//          dword        (for streaming -- initialise to 0)
//          dinuse       (for streaming -- initialise to 24)
//
// Outputs: rawbuff      (buffer updated)
//          dword        (updated)
//          dinuse       (updated)
//
// Assumes: raw buffer is big enough
//          file pointer is not altered between calls (and initialised at start)
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_decode_ccittmh (const uint encfile, short int *const rawbuff
                               , const int imagewidth
                               , uint *const dword, int *const dinuse)
{
   extern uint decword, decindexcom;
   extern int decinuse, decimagewidth;
   extern short int *decindexraw;
   int rc, flags;

   decindexcom = encfile;
   decword = *dword;                   // CCITT MH is byte-aligned
   decinuse = *dinuse;
   decindexraw = rawbuff;

   if (imagewidth >= 0) {

      decimagewidth = imagewidth;
      flags = ISHANDLE | REVERSENOT;

   } else {

      decimagewidth = -imagewidth;
      flags = ISHANDLE | REVERSEIT;

   }

   tifflo_fillupcall (flags);
   rc = tifflo_decode_1d (flags);

   *decindexraw++ = 0;                 // Guard word for EOL for 2D coding
   while (decinuse & 7)                // Dump excess bits in last byte of decline
      tifflo_eatabitcall (flags);

   *dword = decword;                   // Save streaming info
   *dinuse = decinuse;

   return rc;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_decode_1dmh
//
// Decodes a 1D MH-coded line from memory.  The line should be terminated
// by at least 35 zero bits (this is satisfied by tiff_stream_in).
// The octets should have been reversed w.r.t. the modem.
//
// Inputs:  encbuff      (buffer for encoded message data)
//          rawbuff      (buffer for raw message data)
//          eoldata:     (EOL data -- as returned by tiff_stream_in)
//             byte 0 contains number of bits past EOL
//             byte 1 contains those bits (last bit in bit 0)
//             bytes 2 and 3 are ignored
//          imagewidth   (expected image width)
//
// Outputs: rawbuff      (buffer updated)
//
// Assumes: raw buffer is big enough
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_decode_1dmh (byte *const encbuff, short int *const rawbuff
                            , const int eoldata, const int imagewidth)
{
   extern uint decword;
   extern int decinuse, decimagewidth;
   extern byte *decindexcom;
   extern short int *decindexraw;
   int rc;

   decindexcom = encbuff;
   decimagewidth = imagewidth;
   decword = (eoldata & 0xff00)        // Bits past EOL, already shifted by 8 bits
           << (24 - (eoldata & 0xff)); // Shift up so that first bit is bit 31
   decinuse = 24 - (eoldata & 0xff);
   tifflo_fillupcall (0);              // 0 = from memory, no reversing

   decindexraw = rawbuff;
   rc = tifflo_decode_1d (0);

   if (rc == 0) {

      if (decword != 0)                // Should be 0 if EOL correctly reached

         rc = TIFFError_Unexpected_DecWord;

      else

         *decindexraw++ = 0;           // Guard word for EOL for 2D coding

   }

   return rc;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_decode_2dmr
//
// Decodes a 2D MR-coded line from memory.  The line should be terminated
// by at least 35 zero bits (this is satisfied by tiff_stream_in).
// The octets should have been reversed w.r.t. the modem.
//
// Inputs:  encbuff      (buffer for encoded message data)
//          rawbuff      (buffer for raw message data)
//          refrawbuff   (buffer for previous line's raw message data)
//          hunting      (non-zero if previous line's decode failed)
//          eoldata:     (EOL data -- as returned by tiff_stream_in)
//             byte 0 contains number of bits past EOL
//             byte 1 contains those bits (last bit in bit 0)
//             bytes 2 and 3 are ignored
//          imagewidth   (expected image width)
//
// Outputs: rawbuff      (buffer updated)
//
// Assumes: raw buffer is big enough
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_decode_2dmr (byte *const encbuff, short int *const rawbuff
                            , short int *const refrawbuff, const int hunting
                            , const int eoldata, const int imagewidth)
{
   extern uint decword;
   extern int decinuse, decimagewidth;
   extern byte *decindexcom;
   extern short int *decindexraw, *decrefline;
   uint bit1d;
   int rc;

   decindexcom = encbuff;
   decimagewidth = imagewidth;
   decword = (eoldata & 0xff00)        // Bits past EOL, already shifted by 8 bits
           << (24 - (eoldata & 0xff)); // Shift up so that first bit is bit 31
   decinuse = 24 - (eoldata & 0xff);
   tifflo_fillupcall (0);              // 0 = from memory, no reversing

   decindexraw = rawbuff;
   bit1d = decword & 1U << 31;
   tifflo_eatabitcall (0);

   if (bit1d) {

      rc = tifflo_decode_1d (0);

   } else {

      if (hunting)

         rc = TIFFError_Hunting_1D;

      else {

         decrefline = refrawbuff;
         rc = tifflo_decode_2d (0);

      }

   }

   if (rc == 0) {

      if (decword != 0)                // Should be 0 if EOL correctly reached

         rc = TIFFError_Unexpected_DecWord;

      else

         *decindexraw++ = 0;           // Guard word for EOL for 2D coding

   }

   return rc;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_decode_2dmmr
//
// Decodes a 2D MMR-coded line from file.  The octets should
// have been reversed w.r.t. the modem if imagewidth is positive,
// else imagewidth should be negative.
//
// Inputs:  encfile      (file handle for encoded message data)
//          rawbuff      (buffer for raw message data)
//          refrawbuff   (buffer for previous line's raw message data)
//          imagewidth   (absolute value is expected image width)
//          dword        (for streaming -- initialise to 0)
//          dinuse       (for streaming -- initialise to 24)
//
// Outputs: rawbuff      (buffer updated)
//          dword        (updated)
//          dinuse       (updated)
//
// Assumes: raw buffer is big enough
//          file pointer is not altered between calls (and initialised at start)
//
// Returns: non-zero if failed (9 for possible EOFB)
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_decode_2dmmr (const uint encfile, short int *const rawbuff
                             , short int *const refrawbuff, const int imagewidth
                             , uint *const dword, int *const dinuse)
{
   extern uint decword, decindexcom;
   extern int decinuse, decimagewidth;
   extern short int *decindexraw, *decrefline;
   int rc, flags;

#ifdef TIMING
   usstart (TIMINGDECODE2DMMR);
#endif

   decindexcom = encfile;
   decword = *dword;                   // 2D MMR is not byte-aligned
   decinuse = *dinuse;

   if (imagewidth >= 0) {

      decimagewidth = imagewidth;
      flags = ISHANDLE | REVERSENOT;

   } else {

      decimagewidth = -imagewidth;
      flags = ISHANDLE | REVERSEIT;

   }

   tifflo_fillupcall (flags);

   decindexraw = rawbuff;
   decrefline = refrawbuff;
   rc = tifflo_decode_2d (flags);

   *decindexraw++ = 0;                 // Guard word for EOL for 2D coding
                                       //@@ or in tifflo?

   *dword = decword;                   // Save streaming info
   *dinuse = decinuse;

#ifdef TIMING
   usstop (TIMINGDECODE2DMMR);
#endif

   return rc;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_encode_ccittmh
//
// Encodes a CCITT MH-coded line.  The octets are not reversed for the modem.
// The last octet is written out, but encoded data
// may not fill it (unused bits are cleared).
//
// Inputs:  rawbuff      (buffer for raw message data)
//          encbuff      (buffer for encoded message data)
//          imagewidth   (expected image width)
//
// Outputs: encbuff      (buffer updated)
//
// Assumes: buffer is big enough
//
// Returns: number of octets (including the possibly incomplete last one)
//          written to buffer
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_encode_ccittmh (short int *rawbuff, unsigned char *encbuff
                               , const int imagewidth)
{
   extern unsigned char *encindexcom;
   extern short int *encindexraw;
   extern uint encimagewidth;
   extern uint encword, encwordpos, encminscan;

   encword = 0;                  // CCITT MH is byte-aligned
   encwordpos = 0;
   encindexcom = encbuff;
   encindexraw = rawbuff;
   encimagewidth = imagewidth;
   encminscan = 0;               // CCITT MH has no padding
   tifflo_encode_1d (0);         // Encode without EOLs

   return encindexcom - encbuff + (encwordpos != 0); // Correction iff partial byte
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_encode_1dmh
//
// Encodes a 1D MH-coded line.  The octets are not reversed for the modem.
// An EOL is prepended.  The last octet is written out, but encoded data
// may not fill it (the returned value allows streaming).
//
// Inputs:  rawbuff      (buffer for raw message data)
//          encbuff      (buffer for encoded message data)
//          streamdata   (see below; initialise to 0)
//          minscan      (minimum scan line time in bits)
//          imagewidth   (expected image width)
//
// Outputs: encbuff      (buffer updated)
//          streamdata:
//             byte 0 contains number of active bits in EOL
//             byte 1 contains those bits (first bit in bit 7)
//
// Assumes: buffer is big enough
//
// Returns: number of full octets written to buffer
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_encode_1dmh (short int *rawbuff, unsigned char *encbuff
                            , int *const streamdata, const int minscan
                            , const int imagewidth)
{
   extern unsigned char *encindexcom;
   extern short int *encindexraw;
   extern uint encimagewidth;
   extern uint encword, encwordpos, encminscan;

   encword = (*streamdata & 0xff00) << 16;
   encwordpos = *streamdata & 0xff;
   encindexcom = encbuff;
   encindexraw = rawbuff;
   encimagewidth = imagewidth;
   encminscan = minscan;
   tifflo_encode_1d (1);         // Encode with EOLs
   *streamdata = encwordpos | encword >> 16;

   return encindexcom - encbuff;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_encode_2dmr
//
// Encodes a 2D MR-coded line.  The octets are not reversed for the modem.
// An EOL is prepended.  The last octet is written out, but encoded data
// may not fill it (the returned value allows streaming).
//
// Inputs:  rawbuff      (buffer for raw message data)
//          refrawbuff   (buffer for previous line's raw message data)
//          encbuff      (buffer for encoded message data)
//          streamdata   (see below; initialise to 0)
//          minscan      (minimum scan line time in bits)
//          imagewidth   (expected image width)
//          kdata        (parameter K data -- initialise to resn in packed hex)
//
// Outputs: encbuff      (buffer updated)
//          streamdata:
//             byte 0 contains number of active bits in EOL
//             byte 1 contains those bits (first bit in bit 7)
//          kdata        (parameter K data updated)
//
// Assumes: buffer is big enough
//
// Returns: number of full octets written to buffer
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_encode_2dmr (short int *rawbuff, short int *refrawbuff
                            , unsigned char *encbuff, int *const streamdata
                            , const int minscan, const int imagewidth
                            , int *const kdata)
{
   extern unsigned char *encindexcom;
   extern short int *encindexraw;
   extern uint encimagewidth;
   extern uint encword, encwordpos, encminscan;
   extern short int *decrefline;

#ifdef TIMING
   usstart (TIMINGENCODE2DMR);
#endif

   encword = (*streamdata & 0xff00) << 16;
   encwordpos = *streamdata & 0xff;
   encindexcom = encbuff;
   encindexraw = rawbuff;
   encimagewidth = imagewidth;
   encminscan = minscan;

   // B1 of kdata contains K count
   *kdata -= 0x100;              // Decrement K count

   if (*kdata < 0) {             // If gone negative, it's time for a 1D line

      *kdata += ((*kdata & 0x0f) * 2) << 8; // Reload K count
      tifflo_encode_1d (2);      // Encode with (EOL + 1)s

   } else {                      // Otherwise 2D line

      decrefline = refrawbuff; //@@ Cack naming
      tifflo_encode_2d (2);      // Encode with (EOL + 0)s

   }

   *streamdata = encwordpos | encword >> 16;

#ifdef TIMING
   usstop (TIMINGENCODE2DMR);
#endif

   return encindexcom - encbuff;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_encode_2dmmr
//
// Encodes a 2D MMR-coded line.  The octets are not reversed for the modem.
// The last octet is written out, but encoded data
// may not fill it (unused bits are cleared).
//
// Inputs:  rawbuff      (buffer for raw message data)
//          encbuff      (buffer for encoded message data)
//          refrawbuff   (buffer for previous line's raw message data)
//          streamdata   (see below; initialise to 0)
//          imagewidth   (expected image width)
//
// Outputs: encbuff      (buffer updated)
//          streamdata:
//             byte 0 contains number of active bits in EOL
//             byte 1 contains those bits (first bit in bit 7)
//
// Assumes: buffer is big enough
//
// Returns: number of full octets written to buffer
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_encode_2dmmr (short int *const rawbuff, byte *const encbuff
                             , short int *const refrawbuff, int *const streamdata
                             , const int imagewidth)
{
   extern uint encword;
   extern int encwordpos, encimagewidth, encminscan;
   extern byte *encindexcom;
   extern short int *encindexraw;
   extern short int *decrefline;

   encword = (*streamdata & 0xff00) << 16;
   encwordpos = *streamdata & 0xff;
   encindexcom = encbuff;
   encindexraw = rawbuff;
   encimagewidth = imagewidth;
   encminscan = 0;               // 2D MMR has no padding
   decrefline = refrawbuff;      //@@ Cack naming
   tifflo_encode_2d (0);         // Encode without EOLs
   *streamdata = encwordpos | encword >> 16;

   return encindexcom - encbuff;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_open_read
//
// Opens an input TIFF file and reads first part of TIFF header.
// The file pointer is left pointing at the end of the header.
//
// This routine is typically followed by tiff_read_ifd with ifdpos
// set to the value returned by this routine.
//
// Inputs:  pathname    (pathname of TIFF file to open)
//
// Outputs: ifdpos      (file pointer for IFD)
//          endian      (value indicating endianness -- either 0 or 1)
//
// Assumes: nothing
//
// Returns: FILE pointer (NULL if failed (including if invalid header)
//                       -- any opened input file is closed)
//
///////////////////////////////////////////////////////////////////////////////

extern FILE *tiff_open_read (const char *const pathname
                            , long int *const ifdpos, int *const endian)
{
   FILE *f;
   uint32 word;

   f = fopen (pathname, "rb");
   if (!f) return NULL;

   if (tiff_wget (f, &word, LITTLEENDIAN)) {
      fclose (f);
      return NULL;
   }

   if (word == 0x002a4949)
      *endian = LITTLEENDIAN;
   else if (word == 0x2a004949)
      *endian = BIGENDIAN;
   else {
      fclose (f);
      return NULL;
   }

   if (tiff_wget (f, &word, *endian)) {
      fclose (f);
      return NULL;
   }

   *ifdpos = word;

   return f;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_read_ifd
//
// Reads in a TIFF header.
// The file pointer is left pointing at an undefined place.
//
// Inputs:  f           (pointer to FILE)
//          ifdpos      (file pointer to IFD)
//          endian      (endianness)
//
// Outputs: tiffinfo    (IFD info)
//
// Assumes: nentries in IFD is correct (behaviour is to ignore any extra
//                      entries and to accept fewer entries)
//
// Returns: non-zero error code (enum TIFFError) if failed
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_read_ifd (FILE *const f, const long int ifdpos
                         , TIFFInfo *const t, const int endian)
{
   byte temp8;
   uint16 nentries, temp16;
   enum TIFFTag tag;
   enum TIFFType type;
   uint32 count, value;

   if (fseek (f, ifdpos, SEEK_SET)) return 1;

   // Set defaults (use ~0U for those tags which have none)
   t->ImageWidth = ~0U;
   t->ImageLength = ~0U;
   t->BitsPerSample = 1;
   t->Compression = 1;
   t->PhotometricInterpretation = (uint16) ~0U;
   t->FillOrder = 1;
   t->StripOffsets = ~0U;
   t->SamplesPerPixel = 1;
   t->RowsPerStrip = ~0U; // This is a real default
   t->StripByteCounts = ~0U;
   t->XResolution.numerator = ~0U;
   t->XResolution.denominator = ~0U;
   t->YResolution.numerator = ~0U;
   t->YResolution.denominator = ~0U;
   t->T4Options = 0;
   t->T6Options = 0;
   t->ResolutionUnit = 2;
   t->BadFaxLines = ~0U;
   t->CleanFaxData = (uint16) ~0U;
   t->ConsecutiveBadFaxLines = ~0U;

   // Loop over the entries in the IFD
   if (tiff_hget (f, &nentries, endian)) return TIFFError_Read_Error;

   while (nentries--) {

      // Get tag and type
      if (tiff_hget (f, &temp16, endian)) return TIFFError_Read_Error;
      tag = (enum TIFFTag) temp16;
      if (tiff_hget (f, &temp16, endian)) return TIFFError_Read_Error;
      type = (enum TIFFType) temp16;
      if (tag == 0 && type == 0) break; // Short-circuit if hit (unexpected) EOIFD

      // Get count
      if (tiff_wget (f, &count, endian)) return TIFFError_Read_Error;
      if (count == 1) {

         // Read in value; stretch to word size
         // (will get truncated back below, if necessary)
         switch (type) {

            case TIFFType_BYTE:

               if (tiff_bget (f, &temp8)) return TIFFError_Read_Error;
               if (tiff_skip (f, 3)) return TIFFError_Read_Error;
               value = temp8;
               break;

            case TIFFType_SHORT:

               if (tiff_hget (f, &temp16, endian)) return TIFFError_Read_Error;
               if (tiff_skip (f, 2)) return TIFFError_Read_Error;
               value = temp16;
               break;

            case TIFFType_LONG:
            case TIFFType_RATIONAL:

               if (tiff_wget (f, &value, endian)) return TIFFError_Read_Error;
               break;

            default:

               // Don't understand this type; skip over entry
               if (tiff_skip (f, 4)) return TIFFError_Read_Error;
               continue;

         }

      }

      // Note that the chosen parser is maximally permissive and allows
      // e.g. BYTE-type values for BitsPerSample.
      // It also allows RATIONAL-type values for ImageWidth and
      // not RATIONAL-type values for XResolution; these will soon
      // fall over in a (controlled) heap due to e.g. file read errors.

      // Store tag value for those tags we're interested in.
      switch (tag) {

         case TIFFTag_ImageWidth:

            if (count != 1) return TIFFError_Bad_Count;
            t->ImageWidth = value;
            break;

         case TIFFTag_ImageLength:

            if (count != 1) return TIFFError_Bad_Count;
            t->ImageLength = value;
            break;

         case TIFFTag_BitsPerSample:

            if (count != 1) return TIFFError_Bad_Count;
            t->BitsPerSample = value;
            break;

         case TIFFTag_Compression:

            if (count != 1) return TIFFError_Bad_Count;
            t->Compression = value;
            break;

         case TIFFTag_PhotometricInterpretation:

            if (count != 1) return TIFFError_Bad_Count;
            t->PhotometricInterpretation = value;
            break;

         case TIFFTag_FillOrder:

            if (count != 1) return TIFFError_Bad_Count;
            t->FillOrder = value;
            break;

         case TIFFTag_StripOffsets:

            if (count != 1) return TIFFError_Bad_Count;
            t->StripOffsets = value;
            break;

         case TIFFTag_SamplesPerPixel:

            if (count != 1) return TIFFError_Bad_Count;
            t->SamplesPerPixel = value;
            break;

         case TIFFTag_RowsPerStrip:

            if (count != 1) return TIFFError_Bad_Count;
            t->RowsPerStrip = value;
            break;

         case TIFFTag_StripByteCounts:

            if (count != 1) return TIFFError_Bad_Count;
            t->StripByteCounts = value;
            break;

         case TIFFTag_XResolution:

            if (count != 1) return TIFFError_Bad_Count;
            if (tiff_rget (f, &t->XResolution, endian, value))
               return TIFFError_Read_Error;
            break;

         case TIFFTag_YResolution:

            if (count != 1) return TIFFError_Bad_Count;
            if (tiff_rget (f, &t->YResolution, endian, value))
               return TIFFError_Read_Error;
            break;

         case TIFFTag_T4Options:

            if (count != 1) return TIFFError_Bad_Count;
            t->T4Options = value;
            break;

         case TIFFTag_T6Options:

            if (count != 1) return TIFFError_Bad_Count;
            t->T6Options = value;
            break;

         case TIFFTag_ResolutionUnit:

            if (count != 1) return TIFFError_Bad_Count;
            t->ResolutionUnit = value;
            break;

         case TIFFTag_BadFaxLines:

            if (count != 1) return TIFFError_Bad_Count;
            t->BadFaxLines = value;
            break;

         case TIFFTag_CleanFaxData:

            if (count != 1) return TIFFError_Bad_Count;
            t->CleanFaxData = value;
            break;

         case TIFFTag_ConsecutiveBadFaxLines:

            if (count != 1) return TIFFError_Bad_Count;
            t->ConsecutiveBadFaxLines = value;
            break;

         // No default: we just ignore other tags

      }

   }

   return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_wget
//
// Gets a word.
//
// Inputs:  f           (pointer to FILE)
//          endian      (endianness)
//
// Outputs: w           (word)
//
// Assumes: valid endianness
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

intern int tiff_wget (FILE *const f, uint32 *const w, const int endian)
{
   int byte;

   if (endian == LITTLEENDIAN) {

      if ((byte = getc (f)) == EOF) return 1;
      *w = byte & 0xff;
      if ((byte = getc (f)) == EOF) return 1;
      *w |= (byte & 0xff) << 8;
      if ((byte = getc (f)) == EOF) return 1;
      *w |= (byte & 0xff) << 16;
      if ((byte = getc (f)) == EOF) return 1;
      *w |= (byte & 0xff) << 24;

   } else {

      if ((byte = getc (f)) == EOF) return 1;
      *w = (byte & 0xff) << 24;
      if ((byte = getc (f)) == EOF) return 1;
      *w |= (byte & 0xff) << 16;
      if ((byte = getc (f)) == EOF) return 1;
      *w |= (byte & 0xff) << 8;
      if ((byte = getc (f)) == EOF) return 1;
      *w |= byte & 0xff;

   }

   return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_hget
//
// Gets a halfword (16 bits).
//
// Inputs:  f           (pointer to FILE)
//          endian      (endianness)
//
// Outputs: h           (halfword)
//
// Assumes: valid endianness
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

intern int tiff_hget (FILE *const f, uint16 *const h, const int endian)
{
   int byte;

   if (endian == LITTLEENDIAN) {

      if ((byte = getc (f)) == EOF) return 1;
      *h = byte & 0xff;
      if ((byte = getc (f)) == EOF) return 1;
      *h |= (byte & 0xff) << 8;

   } else {

      if ((byte = getc (f)) == EOF) return 1;
      *h = (byte & 0xff) << 8;
      if ((byte = getc (f)) == EOF) return 1;
      *h |= byte * 0xff;

   }

   return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_bget
//
// Gets a byte (8 bits).
//
// Inputs:  f           (pointer to FILE)
//
// Outputs: b           (byte)
//
// Assumes: nothing
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

intern int tiff_bget (FILE *const f, byte *const b)
{
   int byte;

   if ((byte = getc (f)) == EOF) return 1;
   *b = (byte & 0xff);

   return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_rget
//
// Gets a rational (two 32 bits).
// The file pointer is preserved across the call
//
// Inputs:  f           (pointer to FILE)
//          endian      (endianness)
//          offset      (file pointer to rational)
//
// Outputs: r           (struct rational)
//
// Assumes: valid endianness
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

intern int tiff_rget (FILE *const f, struct rational *const r, const int endian
                     , const int offset)
{
   long int currpos;

   currpos = ftell (f);

   if (fseek (f, offset, SEEK_SET)) return 1;

   if (tiff_wget (f, &r->numerator, endian)) return 1;
   if (tiff_wget (f, &r->denominator, endian)) return 1;

   if (fseek (f, currpos, SEEK_SET)) return 1;

   return 0;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_skip
//
// Skips a number of bytes in the TIFF file.
//
// Inputs:  f           (pointer to FILE)
//          n           (number of bytes to skip)
//
// Outputs: nothing
//
// Assumes: nothing
//
// Returns: non-zero if failed
//
///////////////////////////////////////////////////////////////////////////////

intern int tiff_skip (FILE *const f, const int n)
{
   return fseek (f, n, SEEK_CUR);
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_get_ifdsize
//
// Get the number of entries and extra words a given TIFF image type's IFD
// will need.
//
// Inputs:  encoding
//
// Outputs: nentries
//          nextra
//
// Assumes: nothing
//
// Returns: non-zero if image type not recognised
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_get_ifdsize (const TIFFEncoding encoding
                            , int *const nentries, int *const nextra)
{
   switch (encoding) {

      case TIFFEncoding_CCITT:
         *nentries = 16;
         *nextra = 4;
         return 0;

      case TIFFEncoding_T6:
         *nentries = 17; // Note this includes page quality tags;
         *nextra = 4;    // they are handled specially in tiff_close_write.
         return 0;

      case TIFFEncoding_T6_NoPageQuality:
         *nentries = 14;
         *nextra = 4;
         return 0;

   }

   *nentries = 0;
   *nextra = 0;
   return 1;
}


///////////////////////////////////////////////////////////////////////////////
//
// tiff_close_write
//
// Close TIFF file, writing out header.
// Currently only 2D MMR and CCITT MH TIFFs are supported.
//
// If a non-NoPageQuality 2D MMR image is specified, any unset (default)
// page quality tags are not output to the IFD.
//
// Inputs:  t           (pointer to TIFFInfo structure)
//          streamout   (pointer to TIFF FILE)
//          tiffifdptr  (file pointer for TIFF IFD)
//          encword     (encoding leftover; only relevant for 2D MMR)
//
// Outputs: nothing
//
// Assumes: the right IFD size was specified on tiff_create_ifd
//
// Returns: non-zero on error (most likely to be write error)
//
///////////////////////////////////////////////////////////////////////////////

extern int tiff_close_write (TIFFInfo *const t, FILE *const streamout
                            , const long int tiffifdptr, const int encword)
{
   int err, nentries, nentriesactual, nextra, notwritten;

   // Do we need to squeeze out any leftover encoded data or something?
   if ((t->Compression & TIFFEncoding_Mask) == TIFFEncoding_T6) {

      int encwordpos;
      uint eencword;

      // Add EOFB
      encwordpos = encword & 0xff;
      eencword = (encword & 0xff00) << 16;
      eencword |= 0x00100100U >> encwordpos; // This will always fit because encwordpos is always < 8
      encwordpos += 24;

      // Squeeze out last bit of encoded data, if any, and EOFB
      while (encwordpos > 0) {

         if (t->FillOrder != 2)
            putc (eencword >> 24, streamout);
         else
            putc (tifflo_reverse (eencword >> 24), streamout);
         eencword <<= 8;
         encwordpos -= 8;
         ++t->StripByteCounts;

      }

   } // It must be 2 == CCITT MH

   // Get IFD details
   tiff_get_ifdsize ((TIFFEncoding) t->Compression, &nentries, &nextra);

   // Just to be on the safe side...
   if (t->Compression == TIFFEncoding_T6 && nentries != 17
      || t->Compression == TIFFEncoding_T6_NoPageQuality && nentries != 14
      || t->Compression == TIFFEncoding_CCITT && nentries != 16
      || nextra != 4) {

      fclose (streamout);
      return 666;

   }

   // Correct for the $%&@*~&^# possibly missing page quality tags
   nentriesactual = nentries;
   if (t->Compression != TIFFEncoding_T6_NoPageQuality) {
      if (t->BadFaxLines == ~0U) --nentriesactual;
      if (t->CleanFaxData == (uint16) ~0U) --nentriesactual;
      if (t->ConsecutiveBadFaxLines == ~0U) --nentriesactual;
   }

   // Write out TIFF header
   tiff_write_nentries (streamout, tiffifdptr, nentriesactual);
   tiff_write_entry (streamout, TIFFTag_ImageWidth, TIFFType_LONG
                    , 1, t->ImageWidth);
   tiff_write_entry (streamout, TIFFTag_ImageLength, TIFFType_LONG
                    , 1, t->ImageLength);
   tiff_write_entry (streamout, TIFFTag_BitsPerSample, TIFFType_SHORT
                    , 1, 1);
   tiff_write_entry (streamout, TIFFTag_Compression, TIFFType_SHORT
                    , 1, t->Compression & TIFFEncoding_Mask);
   tiff_write_entry (streamout, TIFFTag_PhotometricInterpretation, TIFFType_SHORT
                    , 1, 0);
   tiff_write_entry (streamout, TIFFTag_FillOrder, TIFFType_SHORT
                    , 1, t->FillOrder);
   tiff_write_entry (streamout, TIFFTag_StripOffsets, TIFFType_LONG
                    , 1, (unsigned int) tiffifdptr + 2 + nentries * 12
                       + 4 + nextra * 4);
   tiff_write_entry (streamout, TIFFTag_SamplesPerPixel, TIFFType_SHORT
                    , 1, 1);
   tiff_write_entry (streamout, TIFFTag_RowsPerStrip, TIFFType_LONG
                    , 1, t->ImageLength);
   tiff_write_entry (streamout, TIFFTag_StripByteCounts, TIFFType_LONG
                    , 1, t->StripByteCounts);
   tiff_write_entry (streamout, TIFFTag_XResolution, TIFFType_RATIONAL
                    , 1, (unsigned int) tiffifdptr + 2 + nentries * 12 + 4 + 0);
   tiff_write_entry (streamout, TIFFTag_YResolution, TIFFType_RATIONAL
                    , 1, (unsigned int) tiffifdptr + 2 + nentries * 12 + 4 + 8);
   if ((t->Compression & TIFFEncoding_Mask) == TIFFEncoding_T6)
      tiff_write_entry (streamout, TIFFTag_T6Options, TIFFType_LONG
                       , 1, 0);
   tiff_write_entry (streamout, TIFFTag_ResolutionUnit, TIFFType_SHORT
                    , 1, 2);

   if (t->Compression != TIFFEncoding_T6_NoPageQuality) {
      if (t->BadFaxLines != ~0U)
         tiff_write_entry (streamout, TIFFTag_BadFaxLines, TIFFType_LONG
                          , 1, t->BadFaxLines);
      if (t->CleanFaxData != (uint16) ~0U)
         tiff_write_entry (streamout, TIFFTag_CleanFaxData, TIFFType_SHORT
                          , 1, t->CleanFaxData);
      if (t->ConsecutiveBadFaxLines != ~0U)
         tiff_write_entry (streamout, TIFFTag_ConsecutiveBadFaxLines, TIFFType_LONG
                          , 1, t->ConsecutiveBadFaxLines);
      notwritten = (nentries - nentriesactual) * 3;
   } else
      notwritten = 0; // Number of words not written because page quality tags not present

   // We're done for the entries.  If multipage, set ptrnextIFD here
   tiff_write_extra (streamout, 0x00000000); // Pointer to next IFD

   // Put in any padding due to absence of page quality tags
   while (notwritten--) {
      tiff_write_extra (streamout, 0x00000000);
   }

   // Put in the extra words (resolution rationals)
   tiff_write_extra (streamout, t->XResolution.numerator);
   tiff_write_extra (streamout, t->XResolution.denominator);
   tiff_write_extra (streamout, t->YResolution.numerator);
   tiff_write_extra (streamout, t->YResolution.denominator);

   // Close, checking for any errors
   err = ferror (streamout);
   if (err)
      fclose (streamout);
   else
      err = fclose (streamout);

   return err;
}
