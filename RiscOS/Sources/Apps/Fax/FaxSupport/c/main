/*****************************************************************************/
/* File:    main.c                                                           */
/* Purpose: Main file for FaxInt module                                      */
/* Owner:   Mark RISON                                                       */
/* History: 1997-05-27  MGR   Created                                        */
/*****************************************************************************/

#include "fax/global.h"

#include "cmhg.h"
#include "mgrlib/bufman.h"
#include "mgrlib/irq.h"
#include "preveneer.h"
#include "pdebug.h"
#include "trace.h"

#include <stdio.h>
#include <string.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "mgrlib/misc.h"
#include "mgrlib/types.h"
#include "mgrlib/ascii.h"
#include "mgrlib/usTimer.h"
#include "mgrlib/string.h"


///////////////////////////////////////////////////////////////////////////////
//
// C_Constants

// Number of independent timeouts per port
#define NTIMEOUTS 3

// Used by state machine routines
#define LOOPBACK 1
#define DONE 0

// Used by UpCall handler
#define UpCall_Intercept 0
#define UpCall_PassOn 1

// FTS values
#define FTSpostDCS "5"           // AT+FTS value after DCS transmitted, before AT+FTM for TCF
#define FTSpostCFR "5"           // AT+FTS value after CFR received, before AT+FTM for T.4
#define FTSpostT4 "0"            // AT+FTS value after T.4 transmitted, before AT+FTH for PostMC
// @@ These values are determined by experiement, because there seems to be latency in their  @@
// @@ execution; they should therefore be redetermined every time the modem firmware changes. @@

// Timeout numbers
#define NTimeoutT1 1             // Timeout for initial identification
#define NTimeoutT2 2             // Timeout for command reception
#define NTimeoutT2bis 2          // Timeout for command reception after non-V.21 +FCERROR
#define NTimeoutT4 4             // Timeout for response reception
#define NTimeoutFCSError -1      // Timeout for 200 ms waiting following FCS error (also CRP)
//#define NTimeoutCRP -2           // Timeout for 200 ms waiting following CRP response
#define NTimeoutSF_1stCONNECT -3 // Timeout for CONNECT waiting immediately following AT+FTH=3
#define NTimeoutSF_OKCONNECT -4  // Timeout for OK/CONNECT waiting following AT+FTH=3 then <data>
//#define NTimeoutTCF50msWait -5   // Timeout for OK waiting following AT+FTS waiting for TCF
//#define NTimeoutTCFWait -6       // Timeout for CONNECT waiting following AT+FRM for TCF
//#define NTimeoutTCFCollect -7    // Timeout for collection of TCF
#define NTimeoutRR_HDLCdata -8   // Timeout for collection of HDLC data frame
#define NTimeoutRR_OK -9         // Timeout for OK waiting following AT+FRH=3 then <data>
#define NTimeoutCR_HDLCdata -10  // Timeout for collection of HDLC data frame
#define NTimeoutCR_OK -11        // Timeout for OK waiting following AT+FRH=3 then <data>

// Timeouts (in cs)
#define TimeoutT1 3500
#define TimeoutT2 600
#define TimeoutT2bis 1200
#define TimeoutT4 300
#define TimeoutFCSError 600      // Per 5-2t/T.30 and 5-2s/T.30 should be 300
                                 // @@ except that this fails for long TCFs (e.g. V.17)! @@
//#define TimeoutCRP 300           // As per 5-2s/T.30
#define TimeoutSF_1stCONNECT 100 // Should be instantaneous
#define TimeoutSF_OKCONNECT 1000 // Should be length of frame plus up to about 100 cs (preamble)
#define TimeoutTCF50msWait 100   // Should be 5 cs
#define TimeoutTCFWait 500       // Should be less than 10 cs (but Panasonic broken: 1.5 s!)
#define TimeoutTCFCollect 500    // Should be less than 165 cs
#define TimeoutRR_HDLCdata 300   // As per 5-2s/T.30
#define TimeoutRR_OK 100         // Should be instantaneous
#define TimeoutCR_HDLCdata 300   // As per 5-2s/T.30
#define TimeoutCR_OK 100         // Should be instantaneous

// Timeout slots
#define STimeoutT1 0
#define STimeoutT2 1
#define STimeoutT2bis 1
#define STimeoutT4 1
#define STimeoutFCSError 2
//#define STimeoutCRP 2
#define STimeoutSF_1stCONNECT 2
#define STimeoutSF_OKCONNECT 2
#define STimeoutTCF50msWait 2
#define STimeoutTCFWait 2
#define STimeoutTCFCollect 2
#define STimeoutRR_HDLCdata 2
#define STimeoutRR_OK 2
#define STimeoutCR_HDLCdata 2
#define STimeoutCR_OK 2

///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// C_Typedefs

typedef struct state {
   void *pw;               // Pointer to private word (needed to set up timeouts)
   int port;               // Port (needed by callafter starter and handler)
   uint fileout;           // File handle for writing to modem
   uint bufIDout;          // Buffer handle for writing to modem
   uint filein;            // File handle for reading from modem
   uint bufIDin;           // Buffer handle for reading from modem
   int block;              // Active block
   int blockstate;         // State in block
   int subroutine;         // Active subroutine (0 if none)
   int substate;           // State in subroutine
   int subsubroutine;      // Active subsubroutine (0 if none)
   int ntries;             // Try count
   char response[32];      // Modem response
   int nresponse;          // Modem response count
   char data[256];         // Modem data
                           // (should be big enough for NSF, CSI, DIS, etc.)
   int ndata;              // Modem data count (also used as running count of NULs in TCF)
   int maxNULs;            // Maximum running count of NULs in TCF
   int timedout;           // Timeout number (0 if none)
   int datarate;           // Data rate in bps
   short int minTCF;       // Minimum length of TCF (in ms)
   short int maxTCF;       // Maximum length of TCF (in ms)
   uint imagewidth;        // Input page width for tx
   uint imagelength;       // Input page length for tx
   int dcnrc;              // Return code after DCN sent
   char resnin;            // Input page packed resolution [tx]
   char resnout;           // Output page packed resolution [tx]
   char minscan;           // Minimum scan line time (in ms) [tx]
   int widthout;           // Width out for scaling (pels) [tx]
   int lengthin;           // Length in for scaling (lines) [tx]
   int lengthout;          // Length out for scaling (lines) [tx]
   int chopout;            // Chop length (lines; in terms of input image lines) [tx]
   struct bits {
      uint linked : 1;        // Flag indicating whether linked in
      uint threaded : 1;      // Flag indicating whether upcall threaded
      uint DLErecd : 1;       // Flag indicating <DLE> received (for DLEd data)
      uint II : 1;            // Flag indicating we're in initial ID
      uint X : 1;             // Flag giving the X bit
      uint allowDCS : 1;      // Flag indicating DCS is valid command
      uint allowT4r : 1;      // Flag indicating T.4 is valid and should be reported
      uint allowT4s : 1;      // Flag indicating T.4 is valid and should be swallowed
      uint allowMPS : 1;      // Flag indicating MPS is valid command
      uint allowEOM : 1;      // Flag indicating EOM is valid command
      uint allowEOP : 1;      // Flag indicating EOP is valid command
      uint allowDIS : 1;      // Flag indicating DIS is valid response
      uint wasRTN : 1;        // Flag indicating PMR was RTN
      uint fishy : 1;         // Flag indicating DCS was fishy
      uint twoRTNs : 1;       // Flag indicating two consecutive RTNs have been received so far
      uint firstresp : 1;     // Flag set if the first modem response has not been received so far [tx]
      uint firstframe : 1;    // Flag set if the first frame from remote has not been received so far
   } bits;
   char cmd;               // Command (0 if none)
   char resp;              // Response (0 if none)
   char PMR;               // Post-message response (0 if none)
   char CSI[21];           // Contains CSI (null-terminated)
   char TSI[21];           // Contains TSI         "
   char DIS[11];           // Contains DIS (FIF length in 1st byte, then FIF)
   char DCS[11];           // Contains DCS                 "
   char NSF[11];           // Contains NSF                 "
   char NSS[11];           // Contains NSS                 "
   char FTMTCF[4];         // String to follow "AT+FTM=" when sending TCF
   char FTMT4[4];          // String to follow "AT+FTM=" when sending T.4
   int dillweed; //@@Hack
#ifdef TIMING
   usclock_t dilltime; //@@Hack
   int maxlatency;         // Maximum latency
   int mlblock;            // Maximum latency point pre
   int mlblockstate;
   int mlsubroutine;
   int mlsubstate;
   int mlsubsubroutine;
   int mlblockp;           // Maximum latency point post
   int mlblockstatep;
   int mlsubroutinep;
   int mlsubstatep;
   int mlsubsubroutinep;
   int mlkicks;            // Number of kicks at maximum latency
   int paranoidflags;      // Paranoid check flags:
                           // b0 set if state machine ever kicked with ints on
                           // b1 set if state machine ever kicked when threaded
#endif
} State;

typedef struct timeout {
   void *pw;               // Pointer to private word ** MUST BE THE FIRST ELEMENT **
   int timeout;            // Timeout number
   State *state;           // Pointer to corresponding port's state
//#ifdef PDebug_DEBUG
   int n;                  // Counter
//#endif
} Timeout;

///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// C_Interns

intern void faxint_enter_statemachine (State *s, const void *pw);
intern int faxint_kick_statemachine (State *s);
intern int faxint_tx_initial_identification (State *s);
intern int faxint_tx_pre_message_command (State *s);
intern int faxint_tx_post_message_command (State *s);
intern int faxint_rx_initial_identification (State *s);
intern int faxint_rx_main_loop (State *s);
intern int faxint_sub_response_received (State *s);
intern int faxint_sub_command_received (State *s);
intern int faxint_sub_send_frame (State *s);
intern int faxint_subsub_get_response (State *s);
intern int faxint_subsub_get_DLEddata (State *s);
intern void faxint_strip_SI (State *s, char *SI);
//intern int newbufmodem_put_chars (const uint b, const char *const s, const int n);
//intern int newbufmodem_put_DLEddata (const uint b, const char *const s, const int n);
//intern int newbufmodem_get_char (const uint b);
intern void faxint_generate_dcs (State *s);
intern void faxint_select_datarate (State *s);

///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// C_Regionals

regional State state[NPORTS]; // All elements automatically initialised to zero

regional Timeout timeout[NPORTS][NTIMEOUTS];

regional int pollword[NPORTS + 1] = 0; // One for the Wimp pollword,
                                       // plus one each for each port

// Block routines
regional int (*const blocks[]) (State *s) = {
   NULL,
   faxint_tx_initial_identification, // Note second component is direction of
                                     // overall transaction, not of that block
   faxint_rx_initial_identification,
   faxint_rx_main_loop,
   faxint_tx_pre_message_command,
   faxint_tx_post_message_command
};

// Subroutine routines
regional int (*const subroutines[]) (State *s) = {
   NULL,
   faxint_sub_command_received,
   faxint_sub_response_received,
   faxint_sub_send_frame
};

// Subsubroutine routines
regional int (*const subsubroutines[]) (State *s) = {
   NULL,
   faxint_subsub_get_response,
   faxint_subsub_get_DLEddata
};

#ifdef TIMING
regional int (*usclocksvc) (int r0);
regional int usclockr0;
regional int tmaxgetchar;
#define usTimer_GetAddress 0xc4843
#endif

///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// C_Enumerations

// RISC OS error numbers
enum {
   Error_BadPortNumber = 0x813400,
   Error_CurrentlyLinked,
   Error_BadBlockNumber,
   Error_CurrentlyUnlinked
};

// !Fax info/error codes
#include "fax/RCcodes.h"

// Blocks
enum {
   B_tx_initial_identification = 1,
   B_rx_initial_identification,
   B_rx_main_loop,
   B_tx_pre_message_command,
   B_tx_post_message_command
};

// Block states in tx_initial_identification
enum {
   BS_tii_restart = 1,
   BS_tii_start,
   BS_tii_regetframe,
   BS_tii_getframe,
   BS_tii_gotframe,
   BS_tii_dataswitchover,
   BS_tii_dataswitchoverack
};

// Block states in tx_pre_message_command
enum {
   BS_tpre_start = 1,
   BS_tpre_sendTSI,
   BS_tpre_sendDCS,
//   BS_tpre_wait70ms,
//   BS_tpre_waited70ms,
   BS_tpre_sendTCF,
   BS_tpre_sendingTCF,
   BS_tpre_sentTCF,
   BS_tpre_getframe,
   BS_tpre_gotframe,
   BS_tpre_sendT4,
   BS_tpre_sendingT4,
   BS_tpre_sendDCN, //@@ Could optimise all sendDCNs to one block
   BS_tpre_sentDCN
};

// Block states in tx_post_message_command
enum {
   BS_tpost_start = 1,
   BS_tpost_decidePMC,
   BS_tpost_sendPMC,
   BS_tpost_getframe,
   BS_tpost_gotframe,
   BS_tpost_sendDCN,
   BS_tpost_sentDCN
};

// Block states in rx_initial_identification
enum {
   BS_rii_restart = 1,
   BS_rii_start,
   BS_rii_putframe,
   BS_rii_getframe,
   BS_rii_gotframe,
   BS_rii_dataswitchover
};

// Block states in rx_main_loop
enum {
   BS_rml_restart = 1,
   BS_rml_getframeormsg,
   BS_rml_getframe,
   BS_rml_gotframe,
   BS_rml_gotPMC,
   BS_rml_wait50ms,
   BS_rml_waitTCF,
   BS_rml_startTCF,
   BS_rml_getTCF,
   BS_rml_gotTCF,
   BS_rml_gotT4,
   BS_rml_checkT4,
   BS_rml_T2timeout,
   BS_rml_sendDCN,
   BS_rml_sentDCN
};

// Subroutines
enum {
   S_command_received = 1,
   S_response_received,
   S_send_frame
};

// Subroutine states in sub_command_received
enum {
   SS_cr_start = 1,
   SS_cr_got_CONNECT,
   SS_cr_got_HDLCdata,
   SS_cr_got_OK,
   SS_cr_got_OKafterFRS
};

// Subroutine states in sub_response_received
enum {
   SS_rr_start = 1,
   SS_rr_got_CONNECT,
   SS_rr_got_HDLCdata,
   SS_rr_got_OK,
   SS_rr_got_OKafterFRS
};

// Subroutine states in sub_send_frame
enum {
   SS_sf_start = 1,
   SS_sf_got_1stCONNECT,
   SS_sf_restart,
   SS_sf_got_OKCONNECT
};

// Subroutine returns
enum {
   SR_timeout = -1,
   SR_FCERROR = -2,
   SR_got_DCN = -3,
   SR_FCS_error = -4 // Also used for CRP in response_received
};

// Subsubroutines
enum {
   SS_get_response = 1,
   SS_get_DLEddata
};

// Facsimile (and HDLC) Control Fields
// (reversed, ready for Tx, and as Rxed; b0 clear except for polling FCFs)
#include "FCFs.h"

///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// C_Macros

// This macro starts a timeout.
#define M_start_timeout(type) \
        { \
           PDebug_Printf("%06u  %i  Starting timeout %2i (%4i cs) in slot %i [%i]\n" \
                        , clock (), s->port \
                        , NTimeout ## type, Timeout ## type, STimeout ## type \
                        , ++timeout[s->port][STimeout ## type].n); \
           timeout[s->port][STimeout ## type].pw = s->pw; \
           timeout[s->port][STimeout ## type].timeout = NTimeout ## type; \
           timeout[s->port][STimeout ## type].state = s; \
           _swix (OS_CallAfter, _INR (0, 2), Timeout ## type, faxint_callafter_preentry \
                 , &timeout[s->port][STimeout ## type]); \
        }

// This macro cancels a timeout.
#define M_cancel_timeout(type) \
        { \
           PDebug_Printf("%06u  %i  Cancelling timeout            in slot %i [%i]\n" \
                         , clock (), s->port, STimeout ## type \
                         , timeout[s->port][STimeout ## type].n--); \
           _swix (OS_RemoveTickerEvent, _INR (0, 1), faxint_callafter_preentry \
                  , &timeout[s->port][STimeout ## type]); \
        }

// This macro sets the next blockstate, and enters the modem response getting subsubroutine.
#define M_modem_get_response(p) \
        { \
           s->blockstate = p; \
           s->subsubroutine = SS_get_response; \
           s->nresponse = 0; \
           return LOOPBACK; \
        }

// This macro sets the next blockstate, and enters the modem HDLC data getting subsubroutine.
#define M_modem_get_DLEddata(p) \
        { \
           s->blockstate = p; \
           s->subsubroutine = SS_get_DLEddata; \
           s->ndata = 0; \
           s->bits.DLErecd = FALSE; \
           return LOOPBACK; \
        }

// This macro sets the next substate, and enters the modem response getting subroutine.
#define M_modem_subget_response(p) \
        { \
           s->substate = p; \
           s->subsubroutine = SS_get_response; \
           s->nresponse = 0; \
           return LOOPBACK; \
        }

// This macro sets the next substate, and enters the modem HDLC data getting subroutine.
#define M_modem_subget_DLEddata(p) \
        { \
           s->substate = p; \
           s->subsubroutine = SS_get_DLEddata; \
           s->ndata = 0; \
           s->bits.DLErecd = FALSE; \
           return LOOPBACK; \
        }

// This macro returns a !Fax error.  Any pending callafters are cancelled.
#define M_return_error(e) \
        { \
           int i; \
           for (i = 0; i < NTIMEOUTS; ++i) { \
              PDebug_Printf("%06u  %i  Cancelling timeout            in slot %i [%i]\n" \
                           , clock (), s->port, i \
                           , timeout[s->port][i].n ? timeout[s->port][i].n-- : 0); \
              _swix (OS_RemoveTickerEvent, _INR (0, 1), faxint_callafter_preentry \
                    , &timeout[s->port][i]); \
           } \
           pollword[0] |= 1 << s->port; \
           pollword[s->port + 1] = e; \
           s->bits.linked = FALSE; \
           return DONE; /* Note buffer not flushed here */ \
        }

// This macro sets a !Fax info.  Note no return!
#define M_set_info(i) \
        { \
           pollword[0] |= 1 << s->port; \
           pollword[s->port + 1] = i; \
        }

// This macro avoids silly mistakes...
//newbuf #define modem_put_string(b, s) modem_put_chars (b, s, sizeof s - 1)
#define buffermanager_put_string(b, s) buffermanager_put_block (b, (byte *) s, sizeof s - 1)

// Useful for debugging
#define PDebug_TPPrintf(x) PDebug_Printf ("%06u  %i  " x, clock (), s->port)

///////////////////////////////////////////////////////////////////////////////

#ifdef TRACE
intern int TracePDebug_Printf (FILE* reference, const char* fmt, ...)
{
   va_list ap;

   va_start (ap, fmt);
   PDebug_VPrintf (fmt, ap);
   va_end (ap);
   return 0;

   USE (reference);
}
#endif


///////////////////////////////////////////////////////////////////////////////
//
// faxint_init
//
// Module initialisation entry.
//
// PDebug is initialised and UpCallV is claimed.
//
// Inputs:  pw          (pointer to private word)
//          cmd_tail    (ignored)
//          podule_base (ignored)
//
// Outputs: nothing
//
// Assumes: nothing
//
// Returns: result of OS_Claim for UpCallV
//
///////////////////////////////////////////////////////////////////////////////

extern _kernel_oserror *faxint_init (char *cmd_tail, int podule_base, void *pw)
{
   PDebug_XInit ();
   PDebug_Printf ("FaxSupport initialised\n");

   Trace_SetVerboseLevel (1);
   Trace_SetPrintfFn (TracePDebug_Printf, NULL);
   Trace_IgnoreFunctions ("TracePDebug_Printf");
   Trace_IgnoreFunctions ("faxint_upcall_handler");
   Trace_InterceptFunction (faxint_kick_statemachine);
//   Trace_IgnoreFunctions ("faxint_enter_statemachine");
   Trace_InterceptAllFunctions ();
   Trace_SetVerboseLevel (0);

#ifdef TIMING
   if (_swix (usTimer_GetAddress, _OUT (0) | _OUT (2), &usclockr0, &usclocksvc) != NULL) {
      usclocksvc = NULL;
   }

#if 0
   if (usclocksvc) {
      usclock_t t0, t;
      t0 = usclocksvc (usclockr0);
      t = usclocksvc (usclockr0) - t0;
      printf ("Time for null code is %i us\n", t / 2);
      t0 = usclocksvc (usclockr0);
      _swix (OS_CallAfter, _INR (0, 2), 0x20000, 0x20000, 0x20000);
      _swix (OS_RemoveTickerEvent, _INR (0, 1), 0x20000, 0x20000);
      t = usclocksvc (usclockr0) - t0;
      printf ("Time for callafter/remove is %i us\n", t / 2);
      t0 = usclocksvc (usclockr0);
      _swix (OS_GenerateError, _INR (0, 1), 1, 1);
      t = usclocksvc (usclockr0) - t0;
      printf ("Time for 2-in SWI is %i us\n", t / 2);
      t0 = usclocksvc (usclockr0);
      strcmp (cmd_tail, "CONNECT");
      t = usclocksvc (usclockr0) - t0;
      printf ("Time for strcmp %i us\n", t / 2);
   }
#endif
#endif
/*
{
   State *s = &state[0];
   int i;
   s->DIS[0] = 3;
   s->DIS[1] = 0x00;
   s->DIS[2] = 0xff;
   PDebug_Printf ("\n\nSupport 22 only\n");
   for (i = 0; i < 8; ++i) {
      s->DIS[3] = 0x0a + (i << 4);
      s->resnin = 0x21;
      PDebug_Printf ("\nInput resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
      s->resnin = 0x22;
      PDebug_Printf ("Input resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
      s->resnin = 0x24;
      PDebug_Printf ("Input resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
      s->resnin = 0x44;
      PDebug_Printf ("Input resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
   }
   s->DIS[4] = 0x00;
   s->DIS[5] = 0x00;
   s->DIS[2] = 0xbf;
   s->DIS[0] = 6;
   s->DIS[6] = 0x01 | 0x20;
   PDebug_Printf ("\n\nSupport 24 only, SFMSLT\n");
   for (i = 0; i < 8; ++i) {
      s->DIS[3] = 0x0a + (i << 4);
      s->resnin = 0x21;
      PDebug_Printf ("\nInput resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
      s->resnin = 0x22;
      PDebug_Printf ("Input resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
      s->resnin = 0x24;
      PDebug_Printf ("Input resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
      s->resnin = 0x44;
      PDebug_Printf ("Input resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
   }
   s->DIS[6] = 0x01;
   PDebug_Printf ("\n\nSupport 24 only, not SFMSLT\n");
   for (i = 0; i < 8; ++i) {
      s->DIS[3] = 0x0a + (i << 4);
      s->resnin = 0x21;
      PDebug_Printf ("\nInput resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
      s->resnin = 0x22;
      PDebug_Printf ("Input resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
      s->resnin = 0x24;
      PDebug_Printf ("Input resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
      s->resnin = 0x44;
      PDebug_Printf ("Input resn %.2x, MSLT bits %i\n", s->resnin, i);
      faxint_generate_dcs (s);
   }
}
*/
/*
{
   State ss;
   State *s = &ss;
   strcpy (s->data, "xxx");

#define ts(x) \
   strcpy (s->data + 3, x); \
   strcpy (s->data + 3 + sizeof x - 1, "yy"); \
   s->ndata = 5 + sizeof x - 1; \
   faxint_strip_SI (s, s->TSI); \
   PDebug_Printf ("%s (%i) stripped to %s (%i)\n", s->data, strlen(x), s->TSI, strlen (s->TSI));

   ts ("854527 3221 44+     ");
   ts ("  854527 3221 44+   ");
   ts ("     854527 3221 44+");
   ts ("854527 3221 44+    ");
   ts ("  854527 3221 44+ ");
   ts (" 854527 3221 44+");
   ts ("854527 3221 44+          ");
   ts ("      854527 3221 44+     ");
   ts ("        854527 3221 44+");
   ts ("854527 3221 44+");
   ts ("12345678901234567890");
   ts ("111222333444555666777888999000");
   ts ("111222333444555666777888999000   ");
   ts ("    111222333444555666777888999000");
   ts ("  111222333444555666777888999000   ");
   ts ("123456");
   ts (" 123456");
   ts ("123456 ");
   ts (" 123456 ");
   ts ("                        ");
   ts ("                    ");
   ts ("   ");
   ts ("");
}
*/

   return _swix (OS_Claim, _INR (0, 2), UpCallV, faxint_upcall_entry, pw);

   USE (cmd_tail);
   USE (podule_base);
}


///////////////////////////////////////////////////////////////////////////////
//
// faxint_quit
//
// Module finalisation entry.
//
// Any CallAfters are cancelled, PDebug is finalised
// and UpCallV is released.
//
// Inputs:  pw          (pointer to private word)
//          podule      (ignored)
//          fatal       (ignored)
//
// Outputs: nothing
//
// Assumes: nothing
//
// Returns: result of OS_Release for UpCallV
//
///////////////////////////////////////////////////////////////////////////////

extern _kernel_oserror *faxint_quit (int fatal, int podule, void *pw)
{
   int i, j;

   for (i = 0; i < NPORTS; ++i) {
      for (j = 0; j < NTIMEOUTS; ++j) {
         _swix (OS_RemoveTickerEvent, _INR (0, 1), faxint_callafter_preentry
               , &timeout[i][j]);
      }
   }

   PDebug_Printf ("FaxSupport finalised\n");
   PDebug_XFinal ();

   return _swix (OS_Release, _INR (0, 2), UpCallV, faxint_upcall_entry, pw);

   USE (fatal);
   USE (podule);
}


///////////////////////////////////////////////////////////////////////////////
//
// faxint_swi_handler
//
// SWI handler code.
//
// All registers preserved unless stated otherwise.
//
// Inputs:  pw          (pointer to private word)
//          swi_no      (SWI number withing the chunk)
//          r           (input values of registers R0-R9)
//
// Outputs: depends on SWI
//
// Assumes: depends on SWI
//
// Returns: NULL if handled successfully, otherwise pointer to error block
//
///////////////////////////////////////////////////////////////////////////////

extern _kernel_oserror *faxint_swi_handler (int swi_no, _kernel_swi_regs *r, void *pw)
{
   switch (swi_no) { // This is the number within the chunk


      /////////////////////////////////////////////////////////////////////////
      //
      // SWI_FaxSupport_SetHandles
      //
      // Set file and buffer handles.
      //
      // Inputs:  R0 = port number
      //          R1 = output file handle
      //          R2 = output buffer handle
      //          R3 = input file handle
      //          R4 = input buffer handle
      //
      // Outputs: nothing
      //
      // Assumes: valid port number (else get error)
      //          port not linked (else get error)
      //
      /////////////////////////////////////////////////////////////////////////

      case FaxSupport_SetHandles - FaxSupport_00:
      {
         int port = r->r[0];
         State *s = &state[port];

         if (port >= NPORTS) {

            static _kernel_oserror e = { Error_BadPortNumber,
               "Bad port number"};
            return &e;

         }

         if (s->bits.linked) {

            static _kernel_oserror e = { Error_CurrentlyLinked,
               "Port is currently linked"};
            return &e;

         }

         s->fileout = r->r[1];
         s->bufIDout = buffermanager_get_internalID (r->r[2]);
         s->filein = r->r[3];
         s->bufIDin = buffermanager_get_internalID (r->r[4]);

/*D
         printf("Output buffer %i has ID %.8x; routine %p with workspace at %p.\n"
               , r->r[2], state[r->r[0]].bufIDout
               , buffermanager_service_routine, buffermanager_service_pw);
         printf("Input buffer %i has ID %.8x.\n"
               , r->r[4], state[r->r[0]].bufIDin);
D*/

         return NULL;
      }


      /////////////////////////////////////////////////////////////////////////
      //
      // SWI_FaxSupport_GetPtrPollword
      //
      // Get the address of the Wimp pollword (i.e. the base
      // of the pollword array).
      //
      // Inputs:  nothing
      //
      // Outputs: R0 = address of the Wimp pollword
      //
      // Assumes: nothing
      //
      /////////////////////////////////////////////////////////////////////////

      case FaxSupport_GetPtrPollword - FaxSupport_00:
      {
         r->r[0] = (int) pollword;
         return NULL;
      }


      /////////////////////////////////////////////////////////////////////////
      //
      // SWI_FaxSupport_Start
      //
      // Start a block of modem operations.
      //
      // Inputs:  R0 = port number
      //          R1 = block number
      //          R2 onwards = depends on block number
      //
      // Outputs: nothing
      //
      // Assumes: valid port number (else get error)
      //          port not linked (else get error)
      //          valid block number (else get error)
      //
      /////////////////////////////////////////////////////////////////////////

      case FaxSupport_Start - FaxSupport_00:
      {
         int port = r->r[0];
         int irq_state;
         State *s = &state[port];

         if (port >= NPORTS) {

            static _kernel_oserror e = { Error_BadPortNumber,
               "Bad port number"};
            return &e;

         }

         if (s->bits.linked) {

            static _kernel_oserror e = { Error_CurrentlyLinked,
               "Port is currently linked"};
            return &e;

         }

         // Disable ints so that an modem byte arriving in the middle of
         // initialisation doesn't get lost in/confuse the state machine.
         irq_state = irq_disable ();

         // Set up common things
         s->pw = pw;
         s->port = port;
         s->block = r->r[1];
         s->subroutine = 0;
         s->subsubroutine = 0;
         s->bits.linked = TRUE;
         s->bits.threaded = FALSE;
         s->bits.II = FALSE;
         s->timedout = 0;

         switch (s->block) {


            ///////////////////////////////////////////////////////////////////
            //
            // SWI_FaxSupport_Start_1
            //
            // Starts reception of (NSF) (CSI) DIS in tx.
            //
            // Inputs:  R2 = page to be transmitted's width
            //          R3 = page to be transmitted's length
            //          R4 = page to be transmitted's packed resolution
            //          R5 = pointer to NSS FIF length (can be 0,
            //               should be <= 10) followed by NSS FIF
            //          R6 = pointer to TSI FIF, null-terminated (should be 0 or 20 length),
            //               or NULL
            //
            // Outputs: normally terminates with Info_Send_T4 pollword
            //             when ready for T.4 transmission
            //
            // Assumes: nothing extra
            //
            ///////////////////////////////////////////////////////////////////

            case B_tx_initial_identification:
            {
               PDebug_Printf ("\n%06u  %i  Block %i: receiving (NSF) (CSI) DIS\n"
                             , clock(), port, r->r[1]);

               // Copy page details
               s->imagewidth = r->r[2];
               s->imagelength = r->r[3];
               s->resnin = r->r[4];

               // Copy NSS
               s->NSS[0] = MIN (* (uchar *) r->r[5], sizeof s->NSS - 1);
               memcpy (&s->NSS[1], (void *) (r->r[5] + 1), s->NSS[0]);

               // Copy TSI
               if ((void *) r->r[6]) {
                  strncpy (s->TSI, (void *) r->r[6], sizeof s->TSI - 1);
                  s->TSI[sizeof s->TSI - 1] = NUL;
               } else {
                  s->TSI[0] = NUL;
               }

               // Start state machine
               s->bits.II = TRUE;
               s->bits.X = 1;
               s->blockstate = BS_tii_start;
               s->bits.firstresp = TRUE;
               s->bits.firstframe = TRUE;

               // Initialise the things GetInfo reads
               s->datarate = 0;
               s->CSI[0] = NUL;
               s->DIS[0] = 0;
               s->bits.wasRTN = FALSE; // Because also read in Phase B

               // Start T1 timeout
               M_start_timeout (T1);

#ifdef TIMING
{
               int i;
               for (i = 0; i < NPORTS; ++i) {
                  state[i].maxlatency = 0;
                  state[i].mlkicks = 0;
                  state[i].paranoidflags = 0;
               }
               tmaxgetchar = 0;
}
               usreset ();
#endif

               break;
            }


            ///////////////////////////////////////////////////////////////////
            //
            // SWI_FaxSupport_Start_2
            //
            // Starts transmission of (NSF) (CSI) DIS in rx,
            // then waits for valid response.
            //
            // Inputs:  R2 = pointer to NSF FIF length (can be 0,
            //               should be <= 10) followed by NSF FIF
            //          R3 = pointer to CSI FIF, null-terminated (should be 0 or 20 length),
            //               or NULL
            //          R4 = pointer to DIS FIF length (should be >=3 and <=10)
            //               followed by DIS FIF
            //          R5 = minimum length of TCF (in ms) [short int]
            //          R6 = maximum length of TCF (in ms) [short int]
            //
            // Outputs: normally terminates with Info_Getting_T4 pollword
            //             when speed negotiated and T4 modscheme detected
            //
            // Assumes: nothing extra
            //
            ///////////////////////////////////////////////////////////////////

            case B_rx_initial_identification:
            {
               PDebug_Printf ("\n%06u  %i  Block %i: transmitting (NSF) (CSI) DIS\n"
                             , clock(), port, r->r[1]);

               // Copy NSF
               s->NSF[0] = MIN (* (uchar *) r->r[2], sizeof s->NSF - 1);
               memcpy (&s->NSF[1], (void *) (r->r[2] + 1), s->NSF[0]);

               // Copy CSI
               if ((void *) r->r[3]) {
                  strncpy (s->CSI, (void *) r->r[3], sizeof s->CSI - 1);
                  s->CSI[sizeof s->CSI - 1] = NUL;
               } else {
                  s->CSI[0] = NUL;
               }

               // Copy DIS
               s->DIS[0] = MIN (* (uchar *) r->r[4], sizeof s->DIS - 1);
               memcpy (&s->DIS[1], (void *) (r->r[4] + 1), s->DIS[0]);

               // Copy TCF parameters
               s->minTCF = r->r[5];
               s->maxTCF = r->r[6];

               // Start state machine
               s->bits.II = TRUE;
               s->bits.X = 0;
               s->blockstate = BS_rii_start;
               s->bits.firstresp = FALSE; // We're not expecting any of BUSY etc. at all (only tx is)
               s->bits.firstframe = TRUE;

               // Initialise the things GetInfo reads
               s->datarate = 0;
               s->TSI[0] = NUL;
               s->DCS[0] = 0;

               // Start T1 timeout
               M_start_timeout (T1);

#ifdef TIMING
{
               int i;
               for (i = 0; i < NPORTS; ++i) {
                  state[i].maxlatency = 0;
                  state[i].mlkicks = 0;
                  state[i].paranoidflags = 0;
               }
               tmaxgetchar = 0;
}
               usreset ();
#endif
               break;
            }


            ///////////////////////////////////////////////////////////////////
            //
            // SWI_FaxSupport_Start_3
            //
            // Waits for command after a T.4 page has been received.
            //
            // Inputs:  R2 = post-message response (MCF or RTN)
            //
            // Outputs: normally terminates with Info_Getting_T4 pollword
            //             when speed negotiated and T4 modscheme detected
            //             or with Info_Normal_Termination pollword when
            //             DCN received after EOP/MCF exchange
            //
            // Assumes: nothing extra
            //
            ///////////////////////////////////////////////////////////////////

            case B_rx_main_loop:
            {
               PDebug_Printf ("\n%06u  %i  Block %i: waiting for command\n"
                             , clock(), port, r->r[1]);

               // Copy PMR
               s->PMR = r->r[2];

               // Start state machine
               M_start_timeout (T2);
               s->blockstate = BS_rml_gotT4;
               s->bits.X = 0;
               s->cmd = 0;
               s->bits.allowDCS = s->bits.allowT4r = FALSE;
               s->bits.allowT4s = s->bits.allowMPS = s->bits.allowEOM = s->bits.allowEOP = TRUE;
               s->bits.allowT4s = FALSE; // @@ T4s behaviour not implemented (need Rockwell advice)

               break;
            }


            ///////////////////////////////////////////////////////////////////
            //
            // SWI_FaxSupport_Start_5
            //
            // Does post-message handling in tx.
            //
            // Inputs:  R2 = next page to be transmitted's width
            //               (special value of 0 indicates the previous page
            //               was the last and causes EOP transmission)
            //          R3 = next page to be transmitted's length
            //          R4 = next page to be transmitted's packed resolution
            //          R5 = number of consecutive RTNs received so far (if two RTNs
            //               have been received so far and another is received, this
            //               causes DCN transmission)
            //
            // Outputs: normally terminates with Normal_End_Of_Block pollword
            //             when MCF or RTP received in response to EOP or with
            //             Info_Send_T4 pollword when ready for T.4 transmission
            //             (caller must use FaxSupport_GetInfo 5 to
            //             determine whether RTN was received)
            //
            // Assumes: nothing extra
            //
            ///////////////////////////////////////////////////////////////////

            case B_tx_post_message_command:
            {
               PDebug_Printf ("\n%06u  %i  Block %i: transmitting PostMC\n"
                             , clock(), port, r->r[1]);

               // Copy page details
               s->imagewidth = r->r[2];
               s->imagelength = r->r[3];
               s->resnin = r->r[4];
               s->bits.twoRTNs = r->r[5] == 2;

               // Start state machine
               s->bits.X = 1;
               s->blockstate = BS_tpost_start;

               // Initialise the things GetInfo reads
               // Don't initialise minscan et al. since don't want to squash for MPS/MCF operation
               s->bits.wasRTN = FALSE;

               break;
            }

            default:

               s->bits.linked = FALSE; // This will cause an error to be reported

               break;

         }

         if (!s->bits.linked) {

            // Hm, caller specified unknown block!
            static _kernel_oserror e = { Error_BadBlockNumber,
               "Bad block number"};
            s->bits.linked = FALSE;
            irq_restore (irq_state);
            return &e;

         } else {

            // Give the state machine a kick if there's data in the buffer
            if (buffermanager_get_nused (s->bufIDin) != 0)
               faxint_enter_statemachine (s, pw);

         }

         irq_restore (irq_state);
         return NULL;
      }


      /////////////////////////////////////////////////////////////////////////
      //
      // SWI_FaxSupport_GetInfo
      //
      // Get info pertaining to a given block.
      //
      // Inputs:  R0 = port number
      //          R1 = block number
      //
      // Outputs: R2 onwards = depends on block number
      //
      // Assumes: valid port number (else get error)
      //          valid block number (else get error)
      //
      /////////////////////////////////////////////////////////////////////////

      case FaxSupport_GetInfo - FaxSupport_00:
      {
         int port = r->r[0];
         State *s = &state[port];

         if (port >= NPORTS) {

            static _kernel_oserror e = { Error_BadPortNumber,
               "Bad port number"};
            return &e;

         }

         switch (r->r[1]) {


            ///////////////////////////////////////////////////////////////////
            //
            // SWI_FaxSupport_GetInfo_1
            //
            // Get info on reception of (NSF) (CSI) DIS in phase B tx.
            //
            // Inputs:  nothing extra
            //
            // Outputs: R2 = pointer to stripped CSI
            //          R3 = length of DIS FIF
            //          R4 = pointer to DIS FIF
            //          R5 = datarate
            //
            // Assumes: nothing extra
            //
            ///////////////////////////////////////////////////////////////////

            case B_tx_initial_identification:

               r->r[2] = (int) s->CSI;
               r->r[3] = s->DIS[0];
               r->r[4] = (int) &s->DIS[1];
               r->r[5] = s->datarate;
               return NULL;


            ///////////////////////////////////////////////////////////////////
            //
            // SWI_FaxSupport_GetInfo_2
            //
            // Get info on transmission of (NSF) (CSI) DIS in phase B rx,
            // and wait for valid response.
            //
            // Can also (sneakily!) be used to get hold of generated DCS for
            // phase B tx (the TSI isn't especially illuminating in this case!).
            //
            // Inputs:  nothing extra
            //
            // Outputs: R2 = pointer to stripped TSI
            //          R3 = length of DCS FIF
            //          R4 = pointer to DCS FIF
            //          R5 = datarate
            //          R6 = b0 = 1 if DCS is fishy, 0 otherwise
            //
            // Assumes: nothing extra
            //
            ///////////////////////////////////////////////////////////////////

            case B_rx_initial_identification:

               r->r[2] = (int) s->TSI;
               r->r[3] = s->DCS[0];
               r->r[4] = (int) &s->DCS[1];
               r->r[5] = s->datarate;
               r->r[6] = s->bits.fishy;
               return NULL;


            ///////////////////////////////////////////////////////////////////
            //
            // SWI_FaxSupport_GetInfo_5
            //
            // Get info on transmission post-message handling in tx.
            //
            // Inputs:  nothing extra
            //
            // Outputs: R2 = b0 = 1 if RTN was PMR, 0 otherwise
            //               b1 = 0 if coding is 1D MH, 1 if coding is 2D MR
            //               B1 = minscan (in ms)
            //          R3 = input scaling length (lines)
            //          R4 = output resolution (packed hex)
            //          R5 = output scaling width (pels)
            //          R6 = output scaling length (lines)
            //          R7 = output chop length (lines)
            //
            // Assumes: nothing extra
            //
            ///////////////////////////////////////////////////////////////////

            case B_tx_post_message_command:

                r->r[2] = s->bits.wasRTN
                          + ((s->DCS[2] & 0x80) >> 6)
                          + (s->minscan << 8);
                r->r[3] = s->lengthin;
                r->r[4] = s->resnout;
                r->r[5] = s->widthout;
                r->r[6] = s->lengthout;
                r->r[7] = s->chopout;
                return NULL;

         }
      {
         static _kernel_oserror e = { Error_BadBlockNumber,
            "Bad block number"};
         return &e;
      }
      }


      /////////////////////////////////////////////////////////////////////////
      //
      // SWI_FaxSupport_Acknowledge
      //
      // Acknowledge info/error.
      //
      // If it turns out the info/error being acknowledged is no longer
      // active (e.g. because we've taken so long to acknowledge a frame
      // that the next one has appeared), nothing is done.  This ensures
      // the final info/error is not accidentally acknowledged.
      //
      // Inputs:  R0 = port number
      //          R1 = info/error code to acknowledge
      //
      // Outputs: nothing
      //
      // Assumes: valid port number (else get error)
      //
      /////////////////////////////////////////////////////////////////////////

      case FaxSupport_Acknowledge - FaxSupport_00:
      {
         int irq_state;

         irq_state = irq_disable ();
         if (pollword[r->r[0] + 1] == r->r[1])
            pollword[0] &= ~ (1 << r->r[0]);
         irq_restore (irq_state);

         return NULL;
      }


      /////////////////////////////////////////////////////////////////////////
      //
      // SWI_FaxSupport_Abort
      //
      // Abort.
      //
      // Clean aborts are not implemented
      //
      // Inputs:  R0 = port number
      //          R1 = reserved
      //
      // Outputs: nothing
      //
      // Assumes: valid port number (else get error)
      //
      /////////////////////////////////////////////////////////////////////////

      case FaxSupport_Abort - FaxSupport_00:
      {
         int port = r->r[0], i;
         State *s = &state[port];

         if (port >= NPORTS) {

            static _kernel_oserror e = { Error_BadPortNumber,
               "Bad port number"};
            return &e;

         }

         if (!s->bits.linked) {

            static _kernel_oserror e = { Error_CurrentlyUnlinked,
               "Port is currently unlinked"};
            return &e;

         }

         for (i = 0; i < NTIMEOUTS; ++i) {
            PDebug_Printf("%06u  %i  Cancelling timeout            in slot %i [%i]\n"
                         , clock (), s->port, i
                         , timeout[s->port][i].n ? timeout[s->port][i].n-- : 0);
            _swix (OS_RemoveTickerEvent, _INR (0, 1), faxint_callafter_preentry
                  , &timeout[s->port][i]);
         }
         pollword[0] |= 1 << s->port;
         pollword[s->port + 1] = Error_Aborted;
         s->bits.linked = FALSE;

         return NULL;
      }


      /////////////////////////////////////////////////////////////////////////
      //
      // SWI_FaxSupport_FillInfo
      //
      // Fill in appropriate Wimp_MFaxRC info field for a given return code.
      // Note that to get the "Bad port number" info the port number should
      // be set to zero (else the selfsame error will be returned by this SWI!).
      //
      // Inputs:  R0 = port number
      //          R1 = return code
      //          R2 = pointer to Wimp_MFaxRC info field
      //          R3 = sizeof info field
      //
      // Outputs: R0 = number of bytes written
      //
      // Assumes: nothing
      //
      /////////////////////////////////////////////////////////////////////////

      case FaxSupport_FillInfo - FaxSupport_00:
      {
         int port = r->r[0];
         State *s = &state[port];
         int *info = (int *) r->r[2];
         int sizeofinfo = r->r[3];

         if (port >= NPORTS) {

            static _kernel_oserror e = { Error_BadPortNumber,
               "Bad port number"};
            return &e;

         }

         switch (r->r[1]) {

            case Error_Unsupported_DCS:
            case Error_Contradictory_DCS:
            case Info_Fishy_DCS:

               // Return received DCS
               memcpy (info, s->DCS, MIN (s->DCS[0] + 1, sizeofinfo));
               r->r[0] = MIN (s->DCS[0] + 1, sizeofinfo);

               break;

            case Error_Cannot_Receive:

               // Return received DIS
               memcpy (info, s->DIS, MIN (s->DIS[0] + 1, sizeofinfo));
               r->r[0] = MIN (s->DIS[0] + 1, sizeofinfo);

               break;

            case Info_Switchover_Originate:

               // Return received NSF
               memcpy (info, s->NSF, MIN (s->NSF[0] + 1, sizeofinfo));
               r->r[0] = MIN (s->NSF[0] + 1, sizeofinfo);

               break;

            case Info_Switchover_Answer:

               // Return received NSS
               memcpy (info, s->NSS, MIN (s->NSS[0] + 1, sizeofinfo));
               r->r[0] = MIN (s->NSS[0] + 1, sizeofinfo);

               break;

            case Error_Switchover_Protocol:

               // Return subroutine return and captured HDLC
               if (sizeofinfo >= 5) {

                  *(info + 0) = s->subroutine;
                  *((char *) info + 4) = s->ndata;
                  memcpy ((char *) info + 5, s->data, MIN (s->ndata, sizeofinfo - 5));
                  r->r[0] = 5 + MIN (s->ndata, sizeofinfo - 5);

               } else

                  r->r[0] = 0;

               break;

            case Error_Unexpected_Modem_Response:

               // Return state machine details, followed by modem response
               if (sizeofinfo >= 5 * 4) {

                  *(info + 0) = s->block;
                  *(info + 1) = s->blockstate;
                  *(info + 2) = s->subroutine;
                  *(info + 3) = s->substate;
                  *(info + 4) = s->subsubroutine;
                  r->r[0] = 5 * 4
                          + strxcpy ((char *) (info + 5), s->response, sizeofinfo - 5 * 4);

               } else

                  r->r[0] = 0;

               break;

            case Info_CSI:

               // Return received CSI
               r->r[0] = strxcpy ((char *) info, s->CSI, sizeofinfo);

               break;

            case Info_TSI:

               // Return received TSI
               r->r[0] = strxcpy ((char *) info, s->TSI, sizeofinfo);

               break;

            case Error_Bad_Port_Number:

               // Return maximum valid port number
               if (sizeofinfo >= 4) {

                  *(info + 0) = NPORTS - 1;
                  r->r[0] = 4;

               } else

                  r->r[0] = 0;

               break;

            case Error_T1_Timeout:
            case Error_T2_Timeout:
            case Error_Aborted:
            case Error_Port_In_Use:
            case Error_Tx_Timeout:
            case Error_Ty_Timeout:
            case Error_HDLC_Overflow:

               // Return state machine details
               if (sizeofinfo >= 5 * 4) {

                  *(info + 0) = s->block;
                  *(info + 1) = s->blockstate;
                  *(info + 2) = s->subroutine;
                  *(info + 3) = s->substate;
                  *(info + 4) = s->subsubroutine;
                  r->r[0] = 5 * 4;

               } else

                  r->r[0] = 0;

               break;

            default:

               r->r[0] = 0;
               break;

         }

         return NULL;
      }

#ifdef TIMING
      case 63:
      {
         int port = r->r[0];
         State *s = &state[port];

         if (port >= NPORTS) {

            static _kernel_oserror e = { Error_BadPortNumber,
               "Bad port number"};
            return &e;

         }

         printf ("Maximum latency on port %i is %i us, in block %i, blockstate %i, "
                "subroutine %i, substate %i, subsubroutine %i, going to block %i, blockstate %i, "
                "subroutine %i, substate %i, subsubroutine %i; %i kicks.  "
                "Paranoid flags 0x%x, max get char time %i us.\n"
                , port, s->maxlatency / 2, s->mlblock, s->mlblockstate
                , s->mlsubroutine, s->mlsubstate, s->mlsubsubroutine
                , s->mlblockp, s->mlblockstatep
                , s->mlsubroutinep, s->mlsubstatep, s->mlsubsubroutinep, s->mlkicks
                , s->paranoidflags, tmaxgetchar / 2);

         return NULL;
      }
#endif

   }

   return error_BAD_SWI;
}


///////////////////////////////////////////////////////////////////////////////
//
// faxint_upcall_handler
//
// UpCall handler code.  Enters state machine if UpCall is
// UpCall_DeviceRxDataPresent and file handle corresponds to a linked
// modem input file handle.  Otherwise passes on UpCall.
//
// All registers preserved.
//
// Inputs:  pw          (pointer to private word)
//          r           (input values of registers R0-R9)
//
// Outputs: depends on UpCall
//
// Assumes: depends on UpCall
//
// Returns: UpCall_Intercept if intercepted, otherwise UpCall_PassOn
//
///////////////////////////////////////////////////////////////////////////////

extern int faxint_upcall_handler (_kernel_swi_regs *r, void *pw)
#pragma -s1
{
   int i;

   if (r->r[0] != UpCall_DeviceRxDataPresent)
      return UpCall_PassOn;

   for (i = 0; i < NPORTS; ++i) {

      if (r->r[1] == state[i].filein && state[i].bits.linked) {

         faxint_enter_statemachine (&state[i], pw);
         return UpCall_Intercept;

      }

   }

   return UpCall_PassOn;
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// faxint_enter_statemachine
//
// Enters state machine.  Interrupts are turned off across the call to
// ensure atomicity.
//
// Inputs:  s           (pointer to state structure)
//          pw          (pointer to private word)
//
// Outputs: nothing
//
// Assumes: valid port number
//
// Returns: nothing
//
///////////////////////////////////////////////////////////////////////////////

intern void faxint_enter_statemachine (State *s, const void *pw)
#pragma -s1
{
   int irq_state;

#ifdef TIMING
   usclock_t starttime;
   int smlblock;
   int smlblockstate;
   int smlsubroutine;
   int smlsubstate;
   int smlsubsubroutine;
   int kicks;
   usstart (TIMINGSTATEMACHINE);
#endif

   // Return immediately if threaded (should never happen)
   if (s->bits.threaded) {
#ifdef TIMING
      s->paranoidflags |= 1 << 1;
#endif
      return;
   }

   // Disable interrupts
   irq_state = irq_disable ();
//tracePDebug_Printf (">");

#ifdef TIMING
   // Get state machine state prior to kick(s)
   starttime = usclocksvc ? usclocksvc (usclockr0) : 0;
   smlblock = s->block;
   smlblockstate = s->blockstate;
   smlsubroutine = s->subroutine;
   smlsubstate = s->substate;
   smlsubsubroutine = s->subsubroutine;
   kicks = 1; // Last kick doesn't hit incrementer
#endif

   // Get kicking
   s->bits.threaded = TRUE;
   s->pw = (void *) pw;
   while (faxint_kick_statemachine (s))
#ifdef TIMING
      ++kicks
#endif
      ;
   s->bits.threaded = FALSE;

#ifdef TIMING
   // Store new maximum latency details if found new maximum
   starttime = usclocksvc ? usclocksvc (usclockr0) - starttime : 0;
   if (starttime > s->maxlatency) {
      PDebug_Printf("%06u  %i  *** LATENCY HAS HIT %u us ***\n"
                   , clock (), s->port, starttime / 2);
      s->maxlatency = starttime;
      s->mlblock = smlblock;
      s->mlblockstate = smlblockstate;
      s->mlsubroutine = smlsubroutine;
      s->mlsubstate = smlsubstate;
      s->mlsubsubroutine = smlsubsubroutine;
      s->mlblockp = s->block;
      s->mlblockstatep = s->blockstate;
      s->mlsubroutinep = s->subroutine;
      s->mlsubstatep = s->substate;
      s->mlsubsubroutinep = s->subsubroutine;
      s->mlkicks = kicks;
   }
#endif

#ifdef TIMING
   if ((irq_get_state () & I_Flag) == 0)
      s->paranoidflags |= 1 << 0;
#endif

//tracePDebug_Printf ("<");
   // Restore interrupts
   irq_restore (irq_state);

#ifdef TIMING
   usstop (TIMINGSTATEMACHINE);
#endif
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// faxint_kick_statemachine
//
// Kicks state machine (typically following UpCall).
//
// Inputs:  s           (pointer to state structure)
//
// Outputs: s
//
// Assumes: interrupts are disabled (also assumed by all downstream routines)
//
// Returns: LOOPBACK if should immediately be rekicked, DONE otherwise
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_kick_statemachine (State *s)
#pragma -s1
{
   if (s->subsubroutine) {
      return subsubroutines[s->subsubroutine] (s);
   }

   if (s->subroutine > 0) {
      return subroutines[s->subroutine] (s);
   }

   return blocks[s->block] (s);
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// faxint_callafter_handler
//
// CallAfter handler code.  Used for timeouts.  A timeout normally causes
// <CAN> to be sent to the corresponding port and s->timedout to be set to
// the timeout number, as long as a higher-priority timeout has not already
// occurred for that port.
//
// Inputs:  pw          (pointer to private word)
//          r           (input values of registers R0-R9)
//          faxint_callafter_struct_ptr  (pointer to timeout structure)
//
// Outputs: s->timedout
//          <CAN> to port
//
// Assumes: nothing
//
// Returns: NULL
//
///////////////////////////////////////////////////////////////////////////////

extern _kernel_oserror *faxint_callafter_handler (_kernel_swi_regs *r, void *pw)
#pragma -s1
{
   Timeout *t = (Timeout *) faxint_callafter_struct_ptr;

#ifdef PDebug_DEBUG
   t->n--;
#endif

   if (t->timeout > 1 && t->state->timedout) {

      // A low-priority timeout (such as T2 or T4) should not
      // interrupt a high-priority timeout (such as T1 or T0).

      PDebug_Printf ("%06u  %i  TIMEOUT: T%i (low priority; discarded)\n"
                    , clock (), t->state->port, t->timeout);

   } else {

      PDebug_Printf ("%06u  %i  TIMEOUT: T%i\n"
                    , clock (), t->state->port, t->timeout);
      t->state->timedout = t->timeout;
      buffermanager_put_string (t->state->bufIDout, "\x18"); // Send a <CAN>

   }

   return NULL;
   USE (r);
   USE (pw);
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// faxint_subsub_get_DLEddata
//
// Collects DLEd HDLC data.  The caller should clear s->bits.DLErecd and
// set s->ndata to 0 before calling this subsubroutine.
//
// The data is expected to be terminated with <DLE><ETX>.
//
// The data is placed in s->data; the number of octets collected is placed in s->ndata.
// Note it is not NUL-terminated (and, indeed, can contain NULs).
//
// On overflow, the subroutine simply ends.  The callee can check s->ndata against the
// size of s->data to detect this.
//
// Inputs:  s           (pointer to state structure)
//          s->bits.DLErecd  (indicates whether last char was <DLE>)
//
// Outputs: s
//          s->data
//          s->ndata
//          s->subsubroutine
//
// Assumes: nothing
//
// Returns: LOOPBACK if subsubroutine terminated, DONE otherwise
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_subsub_get_DLEddata (State *s)
#pragma -s1
{
   int character;

   while ((character = buffermanager_get_byte (s->bufIDin)) != -1) {

//D      rresponse[rresppos++] = character;
//D      if (rresppos == sizeof rresponse) --rresppos;

//D   PDebug_Printf ("Data character: %c\n", character);
      if (s->bits.DLErecd) {              // Previous char was a <DLE>

         if (character == ETX) {          // <DLE><ETX> handling

            // Not necessary to reset s->bits.DLErecd since entry macro does this
            s->subsubroutine = 0;         // End of subsubroutine...
            return LOOPBACK;

         }                                // <DLE><DLE> handling; drops through here onwards

         s->bits.DLErecd = FALSE;

      } else if (character == DLE) {

         s->bits.DLErecd = TRUE;
         continue;

      }

      s->data[s->ndata++] = character;

      if (s->ndata == sizeof s->data) {   // Buffer overflow; should never occur

         s->subsubroutine = 0;            // End of subsubroutine...
         return LOOPBACK;
      }
   }
   return DONE;                           // Done for now (need to collect more chars)
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// faxint_subsub_get_response
//
// Collects a modem response.  The caller should set s->nresponse to 0
// before calling this subsubroutine.
//
// The modem response is expected to be formatted as <CR><LF>RESPONSE<CR><LF>,
// so any <LF> received after the first two characters have been received
// marks the end of the response.
//
// The response (excluding the <CR><LF> framing) is placed in s->response;
// it is NUL-terminated.  s->nresponse should not be relied upon.
//
// On overflow, the subroutine simply ends, terminating the string.  The callee
// can check for this by checking the s->data string using strcmp or somesuch.
//
// Inputs:  s           (pointer to state structure)
//
// Outputs: s
//          s->response
//          s->nresponse
//          s->subsubroutine
//
// Assumes: nothing
//
// Returns: LOOPBACK if subsubroutine terminated, DONE otherwise
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_subsub_get_response (State *s)
#pragma -s1
{
   int character;

   while ((character = buffermanager_get_byte (s->bufIDin)) != -1) {

//D      rresponse[rresppos++] = character;
//D      if (rresppos == sizeof rresponse) --rresppos;

//D   PDebug_Printf ("Response character: %c\n", character);

      if (character == XON || character == XOFF)
         continue;

#ifdef TIMING
      if (s->dillweed == 2 && s->nresponse == 0 && character == CR)
         s->dilltime = usclock ();
#endif
      s->response[s->nresponse++] = character;

      if (character == LF) {

         if (s->nresponse > 2) {          // Got the trailing <LF>

            // Terminate response string at the <CR>
            s->response[s->nresponse - 2] = NUL;
            s->subsubroutine = 0;         // End of subsubroutine...
//trace            PDebug_Printf ("!");
#ifdef TIMING
            if (s->dillweed == 2) {
               buffermanager_put_string (s->bufIDout, "AT+FRM=96\r");
               PDebug_Printf ("Time from start of OK to FRM send: %i us\n"
                             , (usclock () - s->dilltime) >> 1);
            }
#else
            if (s->dillweed == 2) {
               buffermanager_put_string (s->bufIDout, "AT+FRM=96\r");
            }
#endif
            return LOOPBACK;

         } else {                         // Got the leading <LF>

            s->nresponse = 0;             // Rewind back to start of buffer

         }

      } else if (s->nresponse == sizeof s->response) {

         // Buffer overflow; should never occur

         // Terminate string to prevent string routines going haywire
         s->response[s->nresponse - 1] = NUL;
         s->subsubroutine = 0;            // End of subsubroutine...
         return LOOPBACK;

      }

   }
//trace   PDebug_Printf ("?");
   return DONE;                           // Done for now (need to collect more chars)
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// faxint_tx_initial_identification
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_tx_initial_identification (State *s)
{
   switch (s->blockstate) {

      case BS_tii_restart:

         // On entry, T1 is active

         buffermanager_put_string (s->bufIDout, "AT+FRH=3\r");

         s->blockstate = BS_tii_start;
         return LOOPBACK;

      case BS_tii_start:

         // On entry, T1 is active and AT+FRH=3 has been sent

         // Clear received frame info
         s->CSI[0] = 0;
         s->DIS[0] = 0;
         s->NSF[0] = 0;

         s->blockstate = BS_tii_getframe;
         return LOOPBACK;

      case BS_tii_regetframe:

         // On entry, T1 is active

         buffermanager_put_string (s->bufIDout, "AT+FRH=3\r");

         s->blockstate = BS_tii_getframe;
         return LOOPBACK;

      case BS_tii_getframe:

         // On entry, T1 is active and AT+FRH=3 has been sent

         s->subroutine = S_command_received;
         s->substate = SS_cr_start;
         s->blockstate = BS_tii_gotframe;
         return LOOPBACK;

      case BS_tii_gotframe:

         // On entry, T1 is still active (else would have hit M_return_error in S_command_received),
         // so no need to check for timeout.

         if (s->subroutine == SR_got_DCN) {

            PDebug_TPPrintf ("Block 1: reporting phase A tx DCN and exiting\n");
            M_return_error (Error_Got_DCN_Atx);

         }

         if (s->subroutine == SR_FCS_error || s->subroutine == SR_FCERROR) {

            PDebug_TPPrintf ("Block 1: trying again...\n");
            s->subroutine = 0; // Clear error
            s->blockstate = BS_tii_restart;
            return LOOPBACK;

         }

         if (s->ndata >= 3 + 5 && s->data[2] == NSF
            && s->data[3] == FAX_NSF_COUNTRYCODE
            && s->data[4] == FAX_NSF_MANUFACTURERCODE) {

            PDebug_TPPrintf ("Block 1: Daytona NSF received\n");
            M_set_info (Info_Got_NSF);
            s->NSF[0] = MIN (s->ndata - 5, sizeof s->NSF - 1);
            memcpy (&s->NSF[1], &s->data[3], s->NSF[0]);

         }

         if (s->ndata >= 0 + 5 && s->data[2] == CSI) {

            faxint_strip_SI (s, s->CSI);
            M_set_info (Info_Got_CSI);

         }

         if (s->ndata >= 3 + 5 && s->data[2] == DIS) {

            s->DIS[0] = MIN (s->ndata - 5, sizeof s->DIS - 1);
            memcpy (&s->DIS[1], &s->data[3], s->DIS[0]);
            M_set_info (Info_Got_DIS);

         }

         if (s->ndata >= 2 && s->data[1] == Control_NonFinal) {

            PDebug_TPPrintf ("Block 1: non-final frame; getting another\n");
            s->blockstate = BS_tii_regetframe;
            return LOOPBACK;

         }

         if (s->NSF[0] && s->NSS[0]
             && (s->NSF[3] & s->NSS[3]) != 0) {

            // @@ The last condition ensures both ends have a common data transfer protocol. @@
            // @@ This check needs to be modified if more than 8 protocols become supported, @@
            // @@ or if a NSF/NSS bit becomes used to indicate something other than a data   @@
            // @@ transfer protocol (e.g. PGP capability).                                   @@
            PDebug_TPPrintf ("Block 1: Sending NSS for data switchover\n");
            M_cancel_timeout (T1);
            buffermanager_put_string (s->bufIDout, "AT+FTH=3\r");
            s->data[0] = 0xff;
            s->data[1] = Control_Final;
            s->data[2] = NSS + s->bits.X;
            memcpy (&s->data[3], &s->NSS[1], s->NSS[0]);
            s->ndata = s->NSS[0] + 3;
            s->subroutine = S_send_frame;
            s->substate = SS_sf_start;
            s->blockstate = BS_tii_dataswitchover;
            M_set_info (Info_Sending_NSS);
            return LOOPBACK;

         }

         if (s->DIS[0] == 0) { // Eeek, DIS not received!

            PDebug_TPPrintf ("Block 1: DIS not received!");
            s->blockstate = BS_tii_restart;
            return LOOPBACK;

         }

         if ((s->DIS[2] & 0x02) == 0) {

            PDebug_TPPrintf ("Block 1: Callee cannot receive!\n");
            s->dcnrc = Error_Cannot_Receive;
            s->block = B_tx_pre_message_command;
            s->blockstate = BS_tpre_sendDCN;
            return LOOPBACK;

         }

         PDebug_TPPrintf ("Block 1: OK, received (NSF) (CSI) DIS; "
                          "entering block 4 sending TSI\n");
         M_cancel_timeout (T1);
         s->bits.II = FALSE;
         s->bits.allowDIS = TRUE;
         s->block = B_tx_pre_message_command;
         s->blockstate = BS_tpre_start;
         return LOOPBACK;

      case BS_tii_dataswitchover:

         // No subroutine return check because S_send_frame only fails and returns on T2 timeout

         PDebug_TPPrintf ("Block 1: Waiting for NSS echo\n");
         M_start_timeout (T4);
         buffermanager_put_string (s->bufIDout, "AT+FRH=3\r");
         s->bits.II = FALSE;
         s->subroutine = S_response_received;
         s->substate = SS_rr_start;
         s->blockstate = BS_tii_dataswitchoverack;
         return LOOPBACK;

      case BS_tii_dataswitchoverack:

// @@ Check subroutine return code?

         if (s->subroutine
            || !(s->ndata >= 3 + 5 && (s->data[2] & ~1) == NSS
                && s->data[3] == FAX_NSF_COUNTRYCODE
                && s->data[4] == FAX_NSF_MANUFACTURERCODE)) {

            PDebug_TPPrintf ("Block 1: Switchover protocol error\n");
            M_return_error (Error_Switchover_Protocol);

         }

         PDebug_TPPrintf ("Block 1: Data originate switchover\n");
         M_return_error (Info_Switchover_Originate);
   }

   return DONE; // Should never be hit; just here to pacify compiler
}


///////////////////////////////////////////////////////////////////////////////
//
// faxint_tx_pre_message_command
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_tx_pre_message_command (State *s)
{
   switch (s->blockstate) {

      case BS_tpre_start:

         // On entry, no timeouts are active

         s->ntries = 0;
         s->blockstate = BS_tpre_sendTSI;
         faxint_generate_dcs (s);
         faxint_select_datarate (s);
         return LOOPBACK;

      case BS_tpre_sendTSI:

         buffermanager_put_string (s->bufIDout, "AT+FTH=3\r");

         if (s->bits.allowDIS && s->TSI[0]) { // s->allowDIS only true on entry from tx_initial_id
                                              // else other end has responded to DCS with CFR/FTT
                                              // (in which case we don't want to waste time
                                              // resending TSI since we know other end has got it)

            s->data[0] = 0xff;
            s->data[1] = Control_NonFinal;
            s->data[2] = TSI + s->bits.X;
            strcpy (&s->data[3], s->TSI); //@@ Assumes sizeof data >= sizeof TSI
            s->ndata = strlen (s->TSI) + 3;
            s->subroutine = S_send_frame;
            s->substate = SS_sf_start;
            M_set_info (Info_Sending_TSI);

         }

         s->blockstate = BS_tpre_sendDCS;
         return LOOPBACK;

      case BS_tpre_sendDCS:

// @@ Need to check subroutine return

         // On entry, AT+FRH=3 has been sent

         s->data[0] = 0xff;
         s->data[1] = Control_Final;
         s->data[2] = DCS + s->bits.X;
         memcpy (&s->data[3], &s->DCS[1], s->DCS[0]);
         s->ndata = s->DCS[0] + 3;
         s->subroutine = S_send_frame;
         s->substate = s->bits.allowDIS && s->TSI[0] ? SS_sf_restart : SS_sf_start;
         s->blockstate = BS_tpre_sendTCF;
         M_set_info (Info_Sending_DCS);
         return LOOPBACK;

/*
      case BS_tpre_wait70ms:

         PDebug_TPPrintf ("TCFWAIT: waiting for 70 ms\n");
         buffermanager_put_string (s->bufIDout, "AT+FTS=7\r");
         M_modem_get_response (BS_tpre_waited70ms);

      case BS_tpre_waited70ms:

         if (strcmp (s->response, "OK") != 0) {

            PDebug_Printf ("%06u  %i  TCFWAIT: unexpected response: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }
         s->blockstate = BS_tpre_sendTCF;
         return LOOPBACK;
*/

      case BS_tpre_sendTCF:

// @@ Need to check subroutine return

         PDebug_TPPrintf ("TCFSEND: sending TCF\n");
         buffermanager_put_string (s->bufIDout, "AT+FTS=" FTSpostDCS ";+FTM=");
         // @@ We want the DCS to TCF delay to be 75 +/- 20 ms @@
         // @@ (see T.30:1996/5note3).                         @@
         // @@ Err on the longer side if necessary.            @@
         buffermanager_put_block (s->bufIDout, (byte *) s->FTMTCF, strlen (s->FTMTCF));
         buffermanager_put_string (s->bufIDout, "\r");
         M_set_info (Info_Sending_TCF);
         M_modem_get_response (BS_tpre_sendingTCF);

// @@ need safety timeout

      case BS_tpre_sendingTCF:
      {
         int i;

         if (strcmp (s->response, "CONNECT") != 0) {

            PDebug_Printf ("%06u  %i  TCFSEND: unexpected response [CONNECT]: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         for (i = 0; i < s->datarate * 3 / 2 / 8 / 50; ++i) {
            buffermanager_put_string (s->bufIDout
                            , "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
                              "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0");
         }
         buffermanager_put_DLEdblock (s->bufIDout, NULL, 0);
         M_modem_get_response (BS_tpre_sentTCF);
      }

// @@ need safety timeout

      case BS_tpre_sentTCF:

         if (strcmp (s->response, "OK") != 0) {

            PDebug_Printf ("%06u  %i  TCFSEND: unexpected response [OK]: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         PDebug_TPPrintf ("TCFSEND: sent TCF\n");
         s->resp = 0;
         M_set_info (Info_Waiting_Pre);
         s->blockstate = BS_tpre_getframe;
         return LOOPBACK;

      case BS_tpre_getframe:

         M_start_timeout (T4);
         buffermanager_put_string (s->bufIDout, "AT+FRH=3\r");
         s->subroutine = S_response_received;
         s->substate = SS_rr_start;
         s->blockstate = BS_tpre_gotframe;
         return LOOPBACK;

      case BS_tpre_gotframe:

         // At this point no timeouts are active

         if (s->subroutine == SR_timeout
            || s->subroutine == SR_FCS_error || s->subroutine == SR_FCERROR) {

            if (++s->ntries < 3) {

               PDebug_TPPrintf ("Block 4: timeout T4 or FCS/FCERROR; "
                                "retransmitting (TSI) DCS TCF\n");
               s->subroutine = s->timedout = 0; // Clear timeout/error
               s->blockstate = BS_tpre_sendTSI;
               return LOOPBACK;

            } else {

               PDebug_TPPrintf ("Block 4: DCS sent thrice\n");
               s->subroutine = s->timedout = 0; // Clear timeout/error
               s->dcnrc = Error_DCS_Thrice;
               s->blockstate = BS_tpre_sendDCN;
               return LOOPBACK;

            }

         }

         if (s->subroutine == SR_got_DCN) {

            PDebug_TPPrintf ("Block 4: reporting phase B rx DCN and exiting\n");
            M_return_error (Error_Got_DCN_Btx);

         }

         if (s->bits.allowDIS) {

            if (s->ndata >= 0 + 5 && s->data[2] == CSI) {

               faxint_strip_SI (s, s->CSI);
               M_set_info (Info_Got_CSI);

            }

            if (s->ndata >= 3 + 5 && s->data[2] == DIS) {

               s->DIS[0] = MIN (s->ndata - 5, sizeof s->DIS - 1);
               s->resp = DIS;
               memcpy (&s->DIS[1], &s->data[3], s->DIS[0]);
               M_set_info (Info_Got_DIS);

            }

         }

         if (s->resp == 0) {

            if (s->ndata >= 0 + 5 && (s->data[2] & ~1) == CFR) {

               s->resp = CFR;
               M_set_info (Info_Got_CFR);
               s->bits.allowDIS = FALSE;

            }

            if (s->ndata >= 0 + 5 && (s->data[2] & ~1) == FTT) {

               s->resp = FTT;
               M_set_info (Info_Got_FTT);
               s->bits.allowDIS = FALSE;

            }

         }


         if (s->ndata >= 2 && s->data[1] == Control_NonFinal) {

            PDebug_TPPrintf ("Block 4: non-final frame; getting another\n");
            s->blockstate = BS_tpre_getframe;
            return LOOPBACK;

         }

         if (s->resp == 0) { // Eeek, no response received!

            if (++s->ntries < 3) {

               PDebug_TPPrintf ("Block 4: PreMR not received; "
                                "retransmitting (TSI) DCS TCF\n");
               s->blockstate = BS_tpre_sendTSI;
               return LOOPBACK;


            } else {

               PDebug_TPPrintf ("Block 4: DCS sent thrice\n");
               s->dcnrc = Error_DCS_Thrice;
               s->blockstate = BS_tpre_sendDCN;
               return LOOPBACK;

            }
         }

         if (s->resp == DIS) {

            // Put this here just in case callee suddenly changes its mind
            if ((s->DIS[2] & 0x02) == 0) {

               PDebug_TPPrintf ("Block 4: Callee cannot receive!\n");
               s->dcnrc = Error_Cannot_Receive;
               s->blockstate = BS_tpre_sendDCN;
               return LOOPBACK;

            }

            if (++s->ntries < 3) {

               PDebug_TPPrintf ("Block 4: got DIS again; "
                                "retransmitting (TSI) DCS TCF\n");
               s->blockstate = BS_tpre_sendTSI;
               return LOOPBACK;

            } else {

               PDebug_TPPrintf ("Block 4: DCS sent thrice\n");
               s->dcnrc = Error_DCS_Thrice;
               s->blockstate = BS_tpre_sendDCN;
               return LOOPBACK;

            }

         }

         if (s->resp == FTT) {

            faxint_select_datarate (s);
            if (s->datarate) {

               PDebug_Printf ("%06u  %i  Block 4: dropping rate to %i bps\n"
                             , clock (), s->port, s->datarate);
               s->ntries = 0;
               s->blockstate = BS_tpre_sendTSI;
               return LOOPBACK;

            } else {

               PDebug_TPPrintf ("Block 4: too slow!\n");
               s->dcnrc = Error_Too_Slow;
               s->blockstate = BS_tpre_sendDCN;
               return LOOPBACK;

            }

         }

         // So we got CFR.  Whee!
         PDebug_TPPrintf ("Block 4: get ready to send T.4\n");
         s->blockstate = BS_tpre_sendT4;
         return LOOPBACK;

      case BS_tpre_sendT4:

         buffermanager_put_string (s->bufIDout, "AT+FTS=" FTSpostCFR ";+FTM=");
         // @@ We want the CFR to T.4 delay to be at least 75 ms @@
         // @@ (see T.30:1996/5.3.2.3).                          @@
         // @@ Err on the longer side if necessary.              @@
         buffermanager_put_block (s->bufIDout, (byte *) s->FTMT4, strlen (s->FTMT4));
         buffermanager_put_string (s->bufIDout, "\r");
         M_modem_get_response (BS_tpre_sendingT4);

// @@ need safety timeout

      case BS_tpre_sendingT4:

         if (strcmp (s->response, "CONNECT") != 0) {

            PDebug_Printf ("%06u  %i  T.4SEND: unexpected response: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         PDebug_TPPrintf ("Block 4: send T.4\n");
         M_return_error (Info_Send_T4);

      case BS_tpre_sendDCN:

         PDebug_TPPrintf ("Block 4: sending DCN\n");
         buffermanager_put_string (s->bufIDout, "AT+FTH=3\r");
         s->data[0] = 0xff;
         s->data[1] = Control_Final;
         s->data[2] = DCN + s->bits.X;
         s->ndata = 3;
         s->subroutine = S_send_frame;
         s->substate = SS_sf_start;
         M_set_info (Info_Sending_DCN);
         s->blockstate = BS_tpre_sentDCN;
         return LOOPBACK;

      case BS_tpre_sentDCN:

// @@ Need to check subroutine return

         M_return_error (s->dcnrc);

   }
   return DONE; // Should never be hit; just here to pacify compiler
}


///////////////////////////////////////////////////////////////////////////////
//
// faxint_tx_post_message_command
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_tx_post_message_command (State *s)
{
   switch (s->blockstate) {

      case BS_tpost_start:

         M_modem_get_response (BS_tpost_decidePMC);

      case BS_tpost_decidePMC:

         if (strcmp (s->response, "OK") != 0) {

            PDebug_Printf ("%06u  %i  Block 5: unexpected response [OK]: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         // Select PMC
         if (s->imagewidth == 0) {

            // Special marker for EOP
            PDebug_TPPrintf ("Block 5: PMC is EOP\n");
            s->cmd = EOP;

         } else {

            char oldDCS[sizeof s->DCS];
#ifdef WDEBUG
            char oldDCSrate; // Only need to preserve data rate across MPS for debug window
            oldDCSrate = s->DCS[2];
#endif

            // Copy old DCS and generate new DCS
            memcpy (oldDCS, s->DCS, sizeof s->DCS);
            oldDCS[2] &= ~0x3c; // Clear data rate bits
            faxint_generate_dcs (s);

            // It's EOM unless DCSs are identical
            PDebug_Printf ("[0] is %i and %i\n", s->DCS[0], oldDCS[0]);
            PDebug_Printf ("[123] is %.2x%.2x%.2x and %.2x%.2x%.2x\n"
                            , s->DCS[1], s->DCS[2], s->DCS[3]
                            , oldDCS[1], oldDCS[2], oldDCS[3]);
            s->cmd = EOM;
            if (s->DCS[0] == oldDCS[0]
               && memcmp (&s->DCS[1], &oldDCS[1], oldDCS[0]) == 0) {
               s->cmd = MPS;
#ifdef WDEBUG
               s->DCS[2] = oldDCSrate;
#endif
            }
#ifdef DEBUG
            if (s->cmd == EOM)
               PDebug_TPPrintf ("Block 5: PMC is EOM\n");
            else
               PDebug_TPPrintf ("Block 5: PMC is MPS\n");
#endif

         }

         s->ntries = 0;
         s->blockstate = BS_tpost_sendPMC;
         return LOOPBACK;

      case BS_tpost_sendPMC:

         PDebug_TPPrintf ("Block 5: sending PMC\n");
         buffermanager_put_string (s->bufIDout, "AT+FTS=" FTSpostT4 ";+FTH=3\r");
         // @@ We want the T.4 to PostMC delay to be 75 +/- 20 ms @@
         // @@ (see T.30:1996/5.3.2.2 and 5note4).                @@
         // @@ Err on the longer side if necessary.               @@
         s->data[0] = 0xff;
         s->data[1] = Control_Final;
         s->data[2] = s->cmd + s->bits.X;
         s->ndata = 3;
         s->subroutine = S_send_frame;
         s->substate = SS_sf_start;
         s->resp = 0;
         if (s->cmd == MPS)
            M_set_info (Info_Sending_MPS);
         if (s->cmd == EOM)
            M_set_info (Info_Sending_EOM);
         if (s->cmd == EOP)
            M_set_info (Info_Sending_EOP);
         s->blockstate = BS_tpost_getframe;
         return LOOPBACK;

      case BS_tpost_getframe:

         M_start_timeout (T4);
         buffermanager_put_string (s->bufIDout, "AT+FRH=3\r");
         s->subroutine = S_response_received;
         s->substate = SS_rr_start;
         s->blockstate = BS_tpost_gotframe;
         M_set_info (Info_Waiting_Post);
         return LOOPBACK;

      case BS_tpost_gotframe:

         if (s->subroutine == SR_timeout
            || s->subroutine == SR_FCS_error || s->subroutine == SR_FCERROR) {

            if (++s->ntries < 3) {

               PDebug_TPPrintf ("Block 5: timeout T4 or FCS/FCERROR; "
                                "retransmitting PMC\n");
               s->subroutine = s->timedout = 0; // Clear timeout/error
               s->blockstate = BS_tpost_sendPMC;
               return LOOPBACK;

            } else {

               PDebug_TPPrintf ("Block 5: PMC sent thrice\n");
               if (s->cmd == MPS)
                  s->dcnrc = Error_MPS_Thrice;
               if (s->cmd == EOM)
                  s->dcnrc = Error_EOM_Thrice;
               if (s->cmd == EOP)
                  s->dcnrc = Error_EOP_Thrice;
               s->subroutine = s->timedout = 0; // Clear timeout/error
               s->blockstate = BS_tpost_sendDCN;
               return LOOPBACK;

            }

         }

         if (s->subroutine == SR_got_DCN) {

            PDebug_TPPrintf ("Block 5: reporting phase D rx DCN and exiting\n");
            M_return_error (Error_Got_DCN_Dtx);

         }

         if (s->resp == 0) {

            if (s->ndata >= 0 + 5 && (s->data[2] & ~1) == MCF) {

               s->resp = MCF;
               M_set_info (Info_Got_MCF);

            }

            if (s->ndata >= 0 + 5
               && ((s->data[2] & ~1) == RTP || (s->data[2] & ~1) == PIP)) {

               s->resp = RTP;
               M_set_info (Info_Got_RTP);

            }

            if (s->ndata >= 0 + 5
               && ((s->data[2] & ~1) == RTN || (s->data[2] & ~1) == PIN)) {

               s->resp = RTN;
               M_set_info (Info_Got_RTN);

            }

         }


         if (s->ndata >= 2 && s->data[1] == Control_NonFinal) {

            PDebug_TPPrintf ("Block 5: non-final frame; getting another\n");
            s->blockstate = BS_tpost_getframe;
            return LOOPBACK;

         }

         if (s->resp == 0) { // Eeek, no response received!

            if (++s->ntries < 3) {

               PDebug_TPPrintf ("Block 5: PostMR not received; "
                                "retransmitting PMC\n");
               s->subroutine = s->timedout = 0; // Clear timeout/error
               s->blockstate = BS_tpost_sendPMC;
               return LOOPBACK;

            } else {

               PDebug_TPPrintf ("Block 5: PMC sent thrice\n");
               if (s->cmd == MPS)
                  s->dcnrc = Error_MPS_Thrice;
               if (s->cmd == EOM)
                  s->dcnrc = Error_EOM_Thrice;
               if (s->cmd == EOP)
                  s->dcnrc = Error_EOP_Thrice;
               s->blockstate = BS_tpost_sendDCN;
               return LOOPBACK;

            }
         }

         M_set_info (Info_Sent_Page_Internal); // This should *not* be used for anything else than
                                               // cosmetics, because could get squashed

         // OK, work through table of PMCs and PMRs...
         if (s->resp == RTN) {

            if (s->bits.twoRTNs) {

               PDebug_TPPrintf ("Block 5: RTN received thrice\n");
               s->dcnrc = Error_RTN_Received_Thrice;
               s->blockstate = BS_tpost_sendDCN;
               return LOOPBACK;

            }

            PDebug_TPPrintf ("Block 5: got RTN; back to B\n");
            s->bits.wasRTN = TRUE;
            s->datarate += 2400; // Correct for data rate drop in faxint_select_datarate
            s->blockstate = BS_tpre_start;
            s->block = B_tx_pre_message_command;
            return LOOPBACK;

         } else {

            s->bits.wasRTN = FALSE;

         }

         // At this point only MCF and RTP are possible responses
         if (s->cmd == EOP) {

            PDebug_TPPrintf ("Block 5: got not RTN after EOP; sending normal DCN\n");
            s->dcnrc = Info_Normal_Termination;
            s->blockstate = BS_tpost_sendDCN;
            return LOOPBACK;

         }

         // At this point only MPS and EOM are possible commands
         if (s->resp == RTP) {

            PDebug_TPPrintf ("Block 5: got RTP after not EOP; back to B at 14400\n");
            s->datarate = 0;
            s->blockstate = BS_tpre_start;
            s->block = B_tx_pre_message_command;
            return LOOPBACK;

         }

         // At this point only MCF is the response (MPS and EOM possible commands)
         if (s->cmd == MPS) {

            PDebug_TPPrintf ("Block 5: got MCF after MPS; back to C\n");
            s->blockstate = BS_tpre_sendT4;
            s->block = B_tx_pre_message_command;
            return LOOPBACK;

         }

         // Well, it must be EOM/MCF...
         PDebug_TPPrintf ("Block 5: got MCF after EOM; back to B\n");
         s->datarate += 2400; // Correct for data rate drop in faxint_select_datarate
         s->blockstate = BS_tpre_start;
         s->block = B_tx_pre_message_command;
         return LOOPBACK;

      case BS_tpost_sendDCN:

         PDebug_TPPrintf ("Block 5: sending DCN\n");
         buffermanager_put_string (s->bufIDout, "AT+FTH=3\r");
         s->data[0] = 0xff;
         s->data[1] = Control_Final;
         s->data[2] = DCN + s->bits.X;
         s->ndata = 3;
         s->subroutine = S_send_frame;
         s->substate = SS_sf_start;
         M_set_info (Info_Sending_DCN);
         s->blockstate = BS_tpost_sentDCN;
         return LOOPBACK;

      case BS_tpost_sentDCN:

// @@ Need to check subroutine return

         M_return_error (s->dcnrc);

   }

   return DONE; // Should never be hit; just here to pacify compiler
}


///////////////////////////////////////////////////////////////////////////////
//
// modem_get_char
//
// Attempts to get a character from a buffer.
//
// Inputs:  b           (internal buffer ID)
//
// Outputs: nothing
//
// Assumes: nothing
//
// Returns: character, or -1 if none available (or error)
//
///////////////////////////////////////////////////////////////////////////////

#if 0
intern int newbufmodem_get_char (const uint b)
#pragma -s1
{
#ifdef TIMING
   int c;
   usclock_t t;
   t = usclocksvc ? usclocksvc (usclockr0) : 0;
   c = buffermanager_get_byte (b);
   t = (usclocksvc ? usclocksvc (usclockr0) : 0) - t;
   if (t > tmaxgetchar) tmaxgetchar = t;
   return c;
#else
   return buffermanager_get_byte (b);
#endif
#if 0
   _kernel_swi_regs r;

   r.r[0] = BufferManager_RemoveByte;
   r.r[1] = (int) b;
   if (buffermanager_call_service (&r, buffermanager_service_routine
                                  , buffermanager_service_pw) & C_Flag)
      return -1;
//D   PDebug_Printf (">%c", r.r[2]);
   return r.r[2];
#endif
}
#pragma -s0
#endif


///////////////////////////////////////////////////////////////////////////////
//
// faxint_sub_command_received
//
// Performs the 'COMMAND REC?' subroutine of fig. 5-2t/30, except that:
// - only ends on frame receipt or an error/timeout; it does not return
//   immediately if e.g. no flag is received
// - a non-DCN disconnect occurs if frames takes longer than 3 s to be read in
//   (so no DCN) -- treated as Ty timeout; otherwise frame size is *not* checked
//   (apart from really long frames which will cause a (terminal) buffer overflow)
// - a non-DCN disconnect occurs if 200 ms silence does not appear within 3 s
//   (so no DCN) -- treated as Ty timeout
//
// T2 is not reset if it timed out (if timed out, callee will proceed back to II,
// or disconnect, depending on whether last command was EOM).
//
// Fatal errors (including Tx and T1 timeouts) return using M_return_error.
//
// On FCS error a 200 ms silence delay is implemented.
// Currently the CRP option is not implemented.
//
// Note the caller has to handle optional frames.
//
// It is up to the callee to reset s->subroutine and/or s->timedout.
//
// Inputs:  s           (pointer to state structure)
//          s->data
//          s->ndata
//          s->timedout
//
// Outputs: s
//          s->subroutine  (0 or SR_timeout (in the case of T2)
//                         or SR_FCERROR or SR_got_DCN or SR_FCS_error)
//
// Assumes: nothing
//
// Returns: LOOPBACK if should immediately be rekicked, DONE otherwise
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_sub_command_received (State *s)
#pragma -s1
{
   switch (s->substate) {

      case SS_cr_start:

         // On entry here, AT+FRH=3 has been sent.
         // T2 timeout is active if not in II.
         // T1 timeout is active if in II.

         PDebug_TPPrintf ("COMMREC: expecting CONNECT\n");
         M_modem_subget_response (SS_cr_got_CONNECT);

      case SS_cr_got_CONNECT:

         // Got response (CONNECT; frame started; flag received).
         // (Could also be getting T.4 (+FCERROR), but then we'll be ignoring T2 anyway.)
         // (Could also be getting BUSY or NO DIALTONE, but then will terminate anyway.)

         if (s->timedout) {

            if (s->timedout == 1) {

               // Don't bother checking modem response.
               // (Should be "NO CARRIER" if immediately following ATDT,
               //  or "OK" if following AT+FRH=3.)

               PDebug_TPPrintf ("COMMREC: T1 timeout [got_CONNECT]\n");
               M_return_error (Error_T1_Timeout);

            } else /* s->timedout == 2 */ {

               // "CONNECT" could occur if timeout abort occurs just as flags are detected.
               // To handle this, drop through; pick up after (truncated) data is sent.
               // Need to watch out, therefore, for a possible 2 in subsequent timeout checks.

               if (strcmp (s->response, "CONNECT") != 0) {

                  // Don't bother checking other modem responses.
                  // (Should be "OK".)

                  PDebug_TPPrintf ("COMMREC: T2 timeout [got_CONNECT]\n");
                  s->subroutine = SR_timeout;
                  return LOOPBACK;

               }

            }

         } else {

            // Reset T2, but only if active (i.e. if not in II).
            if (!s->bits.II) {
               M_cancel_timeout (T2);
               M_start_timeout (T2);
            }

         }

         // At this point there has been either no timeout, or a drop-through T2 timeout

         if (s->bits.firstresp) {

            s->bits.firstresp = FALSE;

            if (strcmp (s->response, "BUSY") == 0) {

               PDebug_Printf ("%06u  %i  COMMREC: busy [got_CONNECT]\n"
                             , clock(), s->port);
               M_return_error (Error_Busy);

            }

            if (strcmp (s->response, "NO ANSWER") == 0) {

               PDebug_Printf ("%06u  %i  COMMREC: no answer [got_CONNECT]\n"
                             , clock(), s->port);
               M_return_error (Error_No_Answer);

            }

            if (strcmp (s->response, "NO CARRIER") == 0) {

               PDebug_Printf ("%06u  %i  COMMREC: no carrier [got_CONNECT]\n"
                             , clock(), s->port);
               M_return_error (Error_No_Carrier);

            }

            if (strcmp (s->response, "NO DIALTONE") == 0) {

               PDebug_Printf ("%06u  %i  COMMREC: no dialtone [got_CONNECT]\n"
                             , clock(), s->port);
               M_return_error (Error_No_Dialtone);

            }

         }

         if (s->bits.firstframe) {

            s->bits.firstframe = FALSE;

            M_set_info (Info_Connected); // ** Note this could get squashed! **

         }

         if (strcmp (s->response, "+FCERROR") == 0) {

            PDebug_TPPrintf ("COMMREC: +FCERROR at V.21\n");
            s->subroutine = SR_FCERROR;
            return LOOPBACK;

         }

         if (strcmp (s->response, "CONNECT") != 0) {

            PDebug_Printf ("%06u  %i  COMMREC: unexpected response [got_CONNECT]: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         PDebug_TPPrintf ("COMMREC: expecting HDLC data\n");
         M_start_timeout (CR_HDLCdata);
         M_modem_subget_DLEddata (SS_cr_got_HDLCdata);

      case SS_cr_got_HDLCdata:

         if (s->timedout && s->timedout != 2) {

            if (s->timedout == 1) {

               PDebug_TPPrintf ("COMMREC: T1 timeout [got_HDLCdata]\n");
               M_return_error (Error_T1_Timeout);

            } else /* s->timedout == CR_HDLCdata */ {

               PDebug_TPPrintf ("COMMREC: Ty timeout [got_HDLCdata]\n");
               M_return_error (Error_Ty_Timeout);

            }

         }

         M_cancel_timeout (CR_HDLCdata);

         // Reset T2, but only if active (i.e. if not in II and not drop-through).
         if (!s->bits.II && s->timedout != 2) {
            M_cancel_timeout (T2); // @@ The T.30 flowcharts do not do this, @@
            M_start_timeout (T2);  // @@ but the T.30 text does (5.4.3.1) @@
         }

         // At this point there has been either no timeout, or a drop-through T2 timeout

         if (s->ndata == sizeof s->data) {

            PDebug_TPPrintf ("COMMREC: HDLC data overflow\n"); // Should never occur
            M_return_error (Error_HDLC_Overflow);

         }

         PDebug_Printf ("%06u  %i  COMMREC: got %i bytes (FIF = 0x%.2x)\n"
                       , clock (), s->port, s->ndata, s->ndata >= 3 ? s->data[2] : 0);
         PDebug_TPPrintf ("COMMREC: expecting OK(/ERROR)\n");
         M_start_timeout (CR_OK);
         M_modem_subget_response (SS_cr_got_OK);

      case SS_cr_got_OK:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK"/"ERROR".)

            if (s->timedout == 1) {

               PDebug_TPPrintf ("COMMREC: T1 timeout [got_OK]\n");
               M_return_error (Error_T1_Timeout);

            } else if (s->timedout == 2) {

               PDebug_TPPrintf ("COMMREC: T2 timeout [got_OK]\n");
               s->subroutine = SR_timeout;
               return LOOPBACK;

            } else /* s->timedout == CR_OK */ {

               PDebug_TPPrintf ("COMMREC: Tx timeout [got_OK]\n");
               M_return_error (Error_Tx_Timeout);

            }

         }

         // @@ Reset T2, but only if active (i.e. if not in II)?

         M_cancel_timeout (RR_OK);

         // At this point there has been no timeout

         if (strcmp (s->response, "ERROR") == 0) {

            PDebug_TPPrintf ("COMMREC: FCS error; waiting for 200 ms silence\n");
            buffermanager_put_string (s->bufIDout, "AT+FRS=20\r");
            M_set_info (Info_FCS_Error);
            M_start_timeout (FCSError);
            M_modem_subget_response (SS_cr_got_OKafterFRS);

         }

         if (strcmp (s->response, "OK") != 0) {

            PDebug_Printf ("%06u  %i  COMMREC: unexpected response [got_OK]: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         if (s->ndata >= 0 + 5 && (s->data[2] & ~1) == DCN) {

            PDebug_TPPrintf ("COMMREC: received DCN\n");
            s->subroutine = SR_got_DCN;
            return LOOPBACK;

         }

         PDebug_TPPrintf ("COMMREC: received frame OK\n");
         s->subroutine = 0;
         return LOOPBACK;

      case SS_cr_got_OKafterFRS:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK".)

            if (s->timedout == 1) {

               PDebug_TPPrintf ("COMMREC: T1 timeout [got_OKafterFRS]\n");
               M_return_error (Error_T1_Timeout);

            } else /* s->timedout == FCSError */ {

               PDebug_TPPrintf ("COMMREC: Ty timeout [got_OKafterFRS]\n");
               M_return_error (Error_Ty_Timeout);

            }

         }

         M_cancel_timeout (FCSError);

         // At this point there has been no timeout

         if (strcmp (s->response, "OK")) {

            PDebug_Printf ("%06u  %i  COMMREC: unexpected response [got_OKafterFRS]: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         // @@ Send CRP here @@

         PDebug_TPPrintf ("COMMREC: frame not received OK\n");
         s->subroutine = SR_FCS_error;
         return LOOPBACK;
   }

   return DONE; // Should never be hit; just here to pacify compiler
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// faxint_sub_response_received
//
// Performs the 'Response received?' subroutine of fig. 5-2s/30, except that:
// - T4 stops when flags are detected (so each frame in a series can be 3 s long)
// - a non-DCN disconnect occurs if frames takes longer than 3 s to be read in
//   (so no DCN) -- treated as Ty timeout; otherwise frame size is *not* checked
//   (apart from really long frames which will cause a (terminal) buffer overflow)
// - a non-DCN disconnect occurs if 200 ms silence does not appear within 3 s
//   (so no DCN) -- treated as Ty timeout
//
// Fatal errors (including Tx and T1 timeouts) return using M_return_error.
//
// On FCS error or CRP (which is treated as a FCS error) a 200 ms silence
// delay is implemented.
//
// Note the caller has to handle optional frames.
//
// It is up to the callee to reset s->subroutine and/or s->timedout.
//
// Inputs:  s           (pointer to state structure)
//          s->data
//          s->ndata
//          s->timedout
//
// Outputs: s
//          s->subroutine  (0 or SR_timeout (in the case of T4)
//                         or SR_FCERROR or SR_got_DCN or SR_FCS_error)
//
// Assumes: nothing
//
// Returns: LOOPBACK if should immediately be rekicked, DONE otherwise
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_sub_response_received (State *s)
#pragma -s1
{
   switch (s->substate) {

      case SS_rr_start:

         // On entry here, AT+FRH=3 has been sent.
         // T4 timeout is active.
         // T1 timeout may be active.

         PDebug_TPPrintf ("RESPREC: expecting CONNECT\n");
         M_modem_subget_response (SS_rr_got_CONNECT);

      case SS_rr_got_CONNECT:

         if (s->timedout) {

            if (s->timedout == 1) {

               // Don't bother checking modem response.
               // (Should be "OK".)

               PDebug_TPPrintf ("RESPREC: T1 timeout [got_CONNECT]\n");
               M_return_error (Error_T1_Timeout);

            } else /* s->timedout == 4 */ {

               // "CONNECT" could occur if timeout abort occurs just as flags are detected.
               // To handle this, drop through; pick up after (truncated) data is sent.
               // Need to watch out, therefore, for a possible 4 in subsequent timeout checks.

               if (strcmp (s->response, "CONNECT") != 0) {

                  // Don't bother checking other modem responses.
                  // (Should be "OK".)

                  PDebug_TPPrintf ("RESPREC: T4 timeout [got_CONNECT]\n");
                  s->subroutine = SR_timeout;
                  return LOOPBACK;

               }

            }

         } else {

            M_cancel_timeout (T4);

         }

         // At this point there has been either no timeout, or a drop-through T4 timeout

         if (s->bits.firstframe) {

            s->bits.firstframe = FALSE;

            M_set_info (Info_Connected); // ** Note this could get squashed! **

         }

         if (strcmp (s->response, "+FCERROR") == 0) {

            PDebug_TPPrintf ("RESPREC: +FCERROR at V.21\n");
            s->subroutine = SR_FCERROR;
            return LOOPBACK;

         }

         if (strcmp (s->response, "CONNECT") != 0) {

            PDebug_Printf ("%06u  %i  RESPREC: unexpected response [got_CONNECT]: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         PDebug_TPPrintf ("RESPREC: expecting HDLC data\n");
         M_start_timeout (RR_HDLCdata);
         M_modem_subget_DLEddata (SS_rr_got_HDLCdata);

      case SS_rr_got_HDLCdata:

         if (s->timedout && s->timedout != 4) {

            if (s->timedout == 1) {

               PDebug_TPPrintf ("RESPREC: T1 timeout [got_HDLCdata]\n");
               M_return_error (Error_T1_Timeout);

            } else /* s->timedout == RR_HDLCdata */ {

               PDebug_TPPrintf ("RESPREC: Ty timeout [got_HDLCdata]\n");
               M_return_error (Error_Ty_Timeout);

            }

         }

         M_cancel_timeout (RR_HDLCdata);

         // At this point there has been either no timeout, or a drop-through T4 timeout

         if (s->ndata == sizeof s->data) {

            PDebug_TPPrintf ("RESPREC: HDLC data overflow\n"); // Should never occur
            M_return_error (Error_HDLC_Overflow);

         }

         PDebug_Printf ("%06u  %i  RESPREC: got %i bytes (FIF = 0x%.2x)\n"
                       , clock (), s->port, s->ndata, s->ndata >= 3 ? s->data[2] : 0);
         PDebug_TPPrintf ("RESPREC: expecting OK(/ERROR)\n");
         M_start_timeout (RR_OK);
         M_modem_subget_response (SS_rr_got_OK);

      case SS_rr_got_OK:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK"/"ERROR".)

            if (s->timedout == 1) {

               PDebug_TPPrintf ("RESPREC: T1 timeout [got_OK]\n");
               M_return_error (Error_T1_Timeout);

            } else if (s->timedout == 4) {

               PDebug_TPPrintf ("RESPREC: T4 timeout [got_OK]\n");
               s->subroutine = SR_timeout;
               return LOOPBACK;

            } else /* s->timedout == RR_OK */ {

               PDebug_TPPrintf ("RESPREC: Tx timeout [got_OK]\n");
               M_return_error (Error_Tx_Timeout);

            }

         }

         M_cancel_timeout (RR_OK);

         // At this point there has been no timeout

         if (strcmp (s->response, "ERROR") == 0) {

            PDebug_TPPrintf ("RESPREC: FCS error; waiting for 200 ms silence\n");
            buffermanager_put_string (s->bufIDout, "AT+FRS=20\r");
            M_set_info (Info_FCS_Error);
            M_start_timeout (FCSError);
            M_modem_subget_response (SS_rr_got_OKafterFRS);

         }

         if (strcmp (s->response, "OK") != 0) {

            PDebug_Printf ("%06u  %i  RESPREC: unexpected response: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         if (s->ndata >= 0 + 5 && (s->data[2] & ~1) == DCN) {

            PDebug_TPPrintf ("RESPREC: received DCN\n");
            s->subroutine = SR_got_DCN;
            return LOOPBACK;

         }

         if (s->ndata >= 0 + 5 && (s->data[2] & ~1) == CRP) {

            PDebug_TPPrintf ("RESPREC: received CRP; waiting for 200 ms silence\n");
            buffermanager_put_string (s->bufIDout, "AT+FRS=20\r");
            M_set_info (Info_Got_CRP);
            M_start_timeout (FCSError);
            M_modem_subget_response (SS_rr_got_OKafterFRS);

         }

         PDebug_TPPrintf ("RESPREC: received frame OK\n");
         s->subroutine = 0;
         return LOOPBACK;

      case SS_rr_got_OKafterFRS:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK".)

            if (s->timedout == 1) {

               PDebug_TPPrintf ("RESPREC: T1 timeout [got_OKafterFRS]\n");
               M_return_error (Error_T1_Timeout);

            } else /* s->timedout == FCSError */ {

               PDebug_TPPrintf ("RESPREC: Ty timeout [got_OKafterFRS]\n");
               M_return_error (Error_Ty_Timeout);

            }

         }

         M_cancel_timeout (FCSError);

         // At this point there has been no timeout

         if (strcmp (s->response, "OK")) {

            PDebug_Printf ("%06u  %i  RESPREC: unexpected response: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         PDebug_TPPrintf ("RESPREC: frame not received OK\n");
         s->subroutine = SR_FCS_error;
         return LOOPBACK;
   }

   return DONE; // Should never be hit; just here to pacify compiler
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// faxint_sub_send_frame
//
// Subroutine to send a frame.  The first frame should go via SS_sf_start;
// any subsequent frames should go via SS_sf_restart.  All frames but the
// last should use Control_NonFinal; the last frame should use Control_Final.
// The data should not contain an FCS (this is inserted automatically by the modem).
//
// Fatal errors (including Tx and T1 timeouts) return using M_return_error.
//
// It is up to the callee to reset s->subroutine and/or s->timedout.
//
// Inputs:  s           (pointer to state structure)
//          s->data
//          s->ndata
//          s->timedout
//
// Outputs: s
//          s->subroutine  (0 or SR_timeout (in the case of T2))
//
// Assumes: only final frame if T2 is active (else T2 abort will fail)
//
// Returns: LOOPBACK if should immediately be rekicked, DONE otherwise
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_sub_send_frame (State *s)
#pragma -s1
{
   switch (s->substate) {

      case SS_sf_start:

         // On entry here, AT+FTH=3 has been sent.
         // T1 timeout may be active.
         // T2 timeout may be active.

         PDebug_TPPrintf ("SENDFRM: expecting CONNECT\n");
         M_start_timeout (SF_1stCONNECT);
         M_modem_subget_response (SS_sf_got_1stCONNECT);

      case SS_sf_got_1stCONNECT:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "CONNECT" (not "NO CARRIER" since that only happens when
            // you abort ATA) since <CAN> is ignored.)

            if (s->timedout == 2) {

               PDebug_TPPrintf ("SENDFRM: T2 timeout [got_1stCONNECT]\n");
               // Drop-through so that abort cleanly

            } else if (s->timedout == 1) {

               PDebug_TPPrintf ("SENDFRM: T1 timeout [got_1stCONNECT]\n");
               M_return_error (Error_T1_Timeout);

            } else /* s->timedout == SF_1stCONNECT */ {

               PDebug_TPPrintf ("SENDFRM: Tx timeout [got_1stCONNECT]\n");
               M_return_error (Error_Tx_Timeout);

            }

         }

         M_cancel_timeout (SF_1stCONNECT);

         // At this point there has been either no timeout, or a T2 timeout

         if (strcmp (s->response, "CONNECT") != 0) {

            PDebug_Printf ("%06u  %i  SENDFRM: unexpected response [got_1stCONNECT]: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         s->substate = SS_sf_restart;
         return LOOPBACK;

      case SS_sf_restart:

         // On entry here, "CONNECT" was the modem response to a AT+FRH=3.
         // T1 timeout may be active.
         // T2 timeout may be active.

         PDebug_Printf ("%06u  %i  SENDFRM: sending %i bytes (FIF = 0x%.2x)\n"
                       , clock (), s->port, s->ndata, s->ndata >= 3 ? s->data[2] : 0);

         if (s->timedout) {

            buffermanager_put_DLEdblock (s->bufIDout, NULL, 0); // So that abort as quickly as possible
            // T1 timeout could have occurred; handled in SS_sf_got_OKCONNECT

         } else {

            buffermanager_put_DLEdblock (s->bufIDout, (byte *) s->data, s->ndata);

         }

#ifdef DEBUG
         if (s->dillweed == 1) {
            s->dillweed = 2;
#ifdef TIMING
            s->dilltime = usclock ();
#endif
         }
#else
         if (s->dillweed == 1) {
            s->dillweed = 2;
         }
#endif

         PDebug_TPPrintf ("SENDFRM: expecting OK/CONNECT\n");
         M_start_timeout (SF_OKCONNECT);
         M_modem_subget_response (SS_sf_got_OKCONNECT);

      case SS_sf_got_OKCONNECT:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK"/"CONNECT" since <CAN> is ignored.)

            if (s->timedout == 2) {

               PDebug_TPPrintf ("SENDFRM: T2 timeout [got_OKCONNECT]\n");
               s->subroutine = SR_timeout; // This will not be a clean abort if "CONNECT"
               return LOOPBACK;

            } else if (s->timedout == 1) {

               PDebug_TPPrintf ("SENDFRM: T1 timeout [got_OKCONNECT]\n");
               M_return_error (Error_T1_Timeout);

            } else /* s->timedout == SF_OKCONNECT */ {

               PDebug_TPPrintf ("SENDFRM: Tx timeout [got_OKCONNECT]\n");
               M_return_error (Error_Tx_Timeout);

            }

         }

         M_cancel_timeout (SF_OKCONNECT);

         // At this point there has been no timeout

         if (s->data[2] == Control_NonFinal && strcmp (s->response, "CONNECT") != 0
            || s->data[2] == Control_Final && strcmp (s->response, "OK") != 0) {

            PDebug_Printf ("%06u  %i  SENDFRM: unexpected response [got_OKCONNECT]: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         PDebug_TPPrintf ("SENDFRM: sent frame OK\n");
         s->subroutine = 0;
         return LOOPBACK;

   }

   return DONE; // Should never be hit; just here to pacify compiler
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// faxint_rx_initial_identification
//
// Block for initial identification in phase B rx.
// If DCS successfully received, proceeds to faxint_rx_main_loop.
//
// Inputs:  s           (pointer to state structure)
//          s->NSF
//          s->CSI
//          s->DIS
//
// Outputs: s
//          s->TSI
//          s->DCS
//
// Assumes: nothing
//
// Returns: LOOPBACK if should immediately be rekicked, DONE otherwise
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_rx_initial_identification (State *s)
#pragma -s1
{
   switch (s->blockstate) {

      case BS_rii_restart:

         // On entry, T1 is active

         buffermanager_put_string (s->bufIDout, "AT+FTH=3\r");

         s->blockstate = BS_rii_start;
         return LOOPBACK;

      case BS_rii_start:

         // On entry, T1 is active and AT+FTH=3 has been sent

         // Initialise the frame sequence
         s->data[0] = 0xff;
         s->data[2] = 0x00;

         s->blockstate = BS_rii_putframe;
         return LOOPBACK;

      case BS_rii_putframe:

         // On entry, T1 is active
         // This is a slightly unusual blockstate in that it returns to itself
         // after S_send_frame, using s->data[2] to keep track of where it is.

         // First frame is NSF, if available
         if (s->data[2] == 0x00) {

            s->data[2] = NSF;
            if (s->NSF[0]) {

               s->data[1] = Control_NonFinal;
               memcpy (&s->data[3], &s->NSF[1], s->NSF[0]);
               s->ndata = s->NSF[0] + 3;
               s->subroutine = S_send_frame;
               s->substate = SS_sf_start;
               M_set_info (Info_Sending_NSF);
               return LOOPBACK;

            }

         }

         // Next frame is CSI, if available
         if (s->data[2] == NSF) {

            s->data[2] = CSI;
            if (s->CSI[0]) {

               s->data[1] = Control_NonFinal;
               strcpy (&s->data[3], s->CSI);
               s->ndata = strlen (s->CSI) + 3;
               s->subroutine = S_send_frame;
               s->substate = s->NSF[0] ? SS_sf_restart : SS_sf_start;
               M_set_info (Info_Sending_CSI);
               return LOOPBACK;

            }

         }

         // Final frame is DIS (mandatory)
         if (s->data[2] == CSI) {

            s->data[2] = DIS;
            s->data[1] = Control_Final;
            memcpy (&s->data[3], &s->DIS[1], s->DIS[0]);
            s->ndata = s->DIS[0] + 3;
            s->subroutine = S_send_frame;
            s->substate = s->NSF[0] || s->CSI[0] ? SS_sf_restart : SS_sf_start;
            M_set_info (Info_Sending_DIS);
            return LOOPBACK;

         }

         // Clear received frame information and wait for response
         PDebug_TPPrintf ("Block 2: OK, transmitted (NSF) (CSI) DIS; waiting for response\n");
         M_set_info (Info_Waiting_DCS);
         s->TSI[0] = NUL; // TSI[0] is NUL if no TSI received
         s->DCS[0] = 0;   // DCS[0] is 0 if no DCS received
         s->NSS[0] = 0;   // NSS[0] is 0 if no NSS received
         s->blockstate = BS_rii_getframe;
         return LOOPBACK;

      case BS_rii_getframe:

         // T1 is still active

         M_start_timeout (T4);
         buffermanager_put_string (s->bufIDout, "AT+FRH=3\r");
         s->subroutine = S_response_received;
         s->substate = SS_rr_start;
         s->blockstate = BS_rii_gotframe;
         return LOOPBACK;

      case BS_rii_gotframe:

         // T1 is still active (if it had died, this would have M_return_errored).
         // T4 is dead, either because a frame was received, or because of timeout.

         if (s->subroutine == SR_timeout) {

            PDebug_TPPrintf ("Block 2: timeout T4; retransmitting (NSF) (CSI) DIS\n");
            s->subroutine = s->timedout = 0; // Clear timeout
            s->blockstate = BS_rii_restart;
            return LOOPBACK;

         }

         if (s->subroutine == SR_got_DCN) {

            PDebug_TPPrintf ("Block 2: reporting phase A rx DCN and exiting\n");
            M_return_error (Error_Got_DCN_Arx);

         }

         if (s->subroutine == SR_FCS_error || s->subroutine == SR_FCERROR) {

            PDebug_TPPrintf ("Block 2: FCS/FCERROR; retransmitting (NSF) (CSI) DIS\n");
            s->subroutine = 0; // Clear error
            s->blockstate = BS_rii_restart;
            return LOOPBACK;

         }

         if (s->ndata >= 3 + 5 && (s->data[2] & ~1) == NSS
            && s->data[3] == FAX_NSF_COUNTRYCODE
            && s->data[4] == FAX_NSF_MANUFACTURERCODE) {

            PDebug_TPPrintf ("Block 2: Daytona NSS received\n");
            M_set_info (Info_Got_NSS);
            s->NSS[0] = MIN (s->ndata - 5, sizeof s->NSS - 1);
            memcpy (&s->NSS[1], &s->data[3], s->NSS[0]);

         }

         if (s->ndata >= 0 + 5 && (s->data[2] & ~1) == TSI) {

            faxint_strip_SI (s, s->TSI);
            M_set_info (Info_Got_TSI);

         }

         if (s->ndata >= 3 + 5 && (s->data[2] & ~1) == DCS) {

            s->DCS[0] = MIN (s->ndata - 5, sizeof s->DCS - 1);
            memcpy (&s->DCS[1], &s->data[3], s->DCS[0]);
            M_set_info (Info_Got_DCS);

         }

         if (s->ndata >= 2 && s->data[1] == Control_NonFinal) {

            PDebug_TPPrintf ("Block 2: non-final frame; getting another\n");
            s->blockstate = BS_rii_getframe;
            return LOOPBACK;

         }

         if (s->NSS[0] && s->NSF[0]) {

            PDebug_TPPrintf ("Block 2: Echoing NSS for data switchover\n");
            M_cancel_timeout (T1);
            buffermanager_put_string (s->bufIDout, "AT+FTH=3\r");
            s->data[0] = 0xff;
            s->data[1] = Control_Final;
            s->data[2] = NSS + s->bits.X;
            memcpy (&s->data[3], &s->NSS[1], s->NSS[0]);
            s->ndata = s->NSS[0] + 3;
            s->subroutine = S_send_frame;
            s->substate = SS_sf_start;
            s->blockstate = BS_rii_dataswitchover;
            M_set_info (Info_Echoing_NSS);
            return LOOPBACK;

         }

         if (s->DCS[0] == 0) { // Eeek, DCS not received!

            PDebug_TPPrintf ("Block 2: DCS not received!\n");
            s->blockstate = BS_rii_restart;
            return LOOPBACK;

         }

         PDebug_TPPrintf ("Block 2: OK, received (TSI) DCS; entering block 3 waiting for TCF\n");
         M_cancel_timeout (T1);
         M_start_timeout (T2);
         s->bits.II = FALSE;
         s->bits.allowDCS = TRUE;
         s->bits.allowT4r = s->bits.allowT4s
            = s->bits.allowMPS = s->bits.allowEOM = s->bits.allowEOP = FALSE;
         s->block = B_rx_main_loop;
         s->blockstate = BS_rml_wait50ms;
         return LOOPBACK;

      case BS_rii_dataswitchover:

         // No subroutine return check because S_send_frame only fails and returns on T2 timeout

         PDebug_TPPrintf ("Block 2: Data answer switchover\n");
         M_return_error (Info_Switchover_Answer);

   }

   return DONE; // Should never be hit; just here to pacify compiler
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// faxint_rx_main_loop
//
// Block for main loop in rx.
// Normal exit is with Info_Getting_T4 or Info_Normal_Termination (after EOP/MCF) pollwords.
//
// DCS is sanity-checked immediately prior to TCF collection.
//
// T4s (swallow T.4 after temp. carrier loss) not yet implemented.
//
// Inputs:  s           (pointer to state structure)
//          s->PMR      (if s->bits.allowMPS/EOM/EOP)
//
// Outputs: s
//          s->TSI      (if s->bits.allowDCS)
//          s->DCS      (if s->bits.allowDCS)
//          s->datarate (if s->bits.allowDCS)
//
// Assumes: nothing
//
// Returns: LOOPBACK if should immediately be rekicked, DONE otherwise
//
///////////////////////////////////////////////////////////////////////////////

intern int faxint_rx_main_loop (State *s)
#pragma -s1
{
   switch (s->blockstate) {

      case BS_rml_restart:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK".)

            s->blockstate = BS_rml_T2timeout;
            return LOOPBACK;

         }

         // If not expecting T.4, jump straight to T.30 fetch
         if (!s->bits.allowT4r && !s->bits.allowT4s) { // @@ T4s behaviour not yet implemented

            s->blockstate = BS_rml_getframe;
            return LOOPBACK;

         }

         PDebug_TPPrintf ("Block 3: waiting for T.4/T.30\n");

         switch ((s->DCS[2] & 0x3c) >> 2) {
            case 0:
               buffermanager_put_string (s->bufIDout, "AT+FRM=24\r");
               break;
            case 2:
               buffermanager_put_string (s->bufIDout, "AT+FRM=48\r");
               break;
            case 1:
               if (s->dillweed)
                  s->dillweed = 0;
               else
               buffermanager_put_string (s->bufIDout, "AT+FRM=96\r");
               break;
            case 3:
               buffermanager_put_string (s->bufIDout, "AT+FRM=72\r");
               break;
            case 6:
               buffermanager_put_string (s->bufIDout, "AT+FRM=121\r");
               break;
            case 10:
               buffermanager_put_string (s->bufIDout, "AT+FRM=122\r");
               break;
            case 4:
               buffermanager_put_string (s->bufIDout, "AT+FRM=145\r");
               break;
            case 8:
               buffermanager_put_string (s->bufIDout, "AT+FRM=146\r");
               break;
            case 11:
               buffermanager_put_string (s->bufIDout, "AT+FRM=74\r");
               break;
            case 9:
               buffermanager_put_string (s->bufIDout, "AT+FRM=98\r");
               break;
            default:
               PDebug_TPPrintf ("EEEEEEK: unsupported DCS datarate!\n");
               M_return_error (Error_Unsupported_DCS);
         }

         M_modem_get_response (BS_rml_getframeormsg);

      case BS_rml_getframeormsg:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK".)

            s->blockstate = BS_rml_T2timeout;
            return LOOPBACK;

         }

         // Will get +FCERROR if V.21 received
         if (strcmp (s->response, "+FCERROR") == 0) {

            PDebug_TPPrintf ("Block 3: waiting for command\n");
            s->blockstate = BS_rml_getframe;
            M_cancel_timeout (T2);   // @@ Attempt to work around Rockwell bug @@
            M_start_timeout (T2bis); // @@ (doesn't always manage to switch over to pick up V.21) @@
            return LOOPBACK;

         }

         // Should get CONNECT otherwise (got T.4 mod scheme)
         if (strcmp (s->response, "CONNECT") != 0) {

            PDebug_Printf ("%06u  %i  Block 3: unexpected response: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         PDebug_TPPrintf ("Block 3: getting T.4\n");
         M_return_error (Info_Getting_T4);

      case BS_rml_getframe:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK".)

            s->blockstate = BS_rml_T2timeout;
            return LOOPBACK;

         }

         buffermanager_put_string (s->bufIDout, "AT+FRH=3\r");
         s->subroutine = S_command_received;
         s->substate = SS_cr_start;
         s->blockstate = BS_rml_gotframe;
         return LOOPBACK;

      case BS_rml_gotframe:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK".)

            s->blockstate = BS_rml_T2timeout;
            return LOOPBACK;

         }

         if (s->subroutine == SR_got_DCN) {

            if (s->cmd != 0 || !s->bits.allowEOP || s->bits.allowEOM) {

               if (s->bits.allowDCS) {

                  PDebug_TPPrintf ("Block 3: reporting phase B rx DCN and exiting\n");
                  M_return_error (Error_Got_DCN_Brx);

               } else {

                  PDebug_TPPrintf ("Block 3: reporting phase D rx DCN and exiting\n");
                  M_return_error (Error_Got_DCN_Drx);

               }

            } else {

               PDebug_TPPrintf ("Block 3: reporting normal termination and exiting\n");
               M_return_error (Info_Normal_Termination);

            }

         }

         if (s->subroutine == SR_FCERROR) {

            PDebug_TPPrintf ("Block 3: reporting unexpected +FCERROR and exiting\n");
            M_return_error (Error_Unexpected_Modem_Response);

         }

         if (s->subroutine == SR_FCS_error) {

            PDebug_TPPrintf ("Block 3: trying again...\n");
            s->subroutine = 0; // Clear error
            s->cmd = 0;
            s->blockstate = BS_rml_getframe;
            return LOOPBACK;

         }

         if (s->bits.allowDCS) {

            if (s->ndata >= 0 + 5 && (s->data[2] & ~1) == TSI) {

               faxint_strip_SI (s, s->TSI);
               M_set_info (Info_Got_TSI);
               s->bits.allowT4s = s->bits.allowT4r
                  = s->bits.allowMPS = s->bits.allowEOM = s->bits.allowEOP = FALSE;

            }

            if (s->ndata >= 3 + 5 && (s->data[2] & ~1) == DCS) {

               s->cmd = DCS;
               s->DCS[0] = MIN (s->ndata - 5, sizeof s->DCS - 1);
               memcpy (&s->DCS[1], &s->data[3], s->DCS[0]);
               M_set_info (Info_Got_DCS);
               s->bits.allowT4s = s->bits.allowT4r
                  = s->bits.allowMPS = s->bits.allowEOM = s->bits.allowEOP = FALSE;

            }

         }

         if (s->ndata == 5) {

            if (s->bits.allowMPS && (s->data[2] & ~0x11) == MPS) {

               s->cmd = MPS;
               M_set_info (Info_Got_MPS);
               s->bits.allowDCS = s->bits.allowT4s = s->bits.allowT4r
                  = s->bits.allowEOM = s->bits.allowEOP = FALSE;

            }

            if (s->bits.allowEOM && (s->data[2] & ~0x11) == EOM) {

               s->cmd = EOM;
               M_set_info (Info_Got_EOM);
               s->bits.allowDCS = s->bits.allowT4s = s->bits.allowT4r
                  = s->bits.allowMPS = s->bits.allowEOP = FALSE;

            }

            if (s->bits.allowEOP && (s->data[2] & ~0x11) == EOP) {

               s->cmd = EOP;
               M_set_info (Info_Got_EOP);
               s->bits.allowDCS = s->bits.allowT4s = s->bits.allowT4r
                  = s->bits.allowMPS = s->bits.allowEOM = FALSE;

            }

         }

         if (s->ndata >= 2 && s->data[1] == Control_NonFinal) {

            PDebug_TPPrintf ("Block 3: non-final frame; getting another\n");
            s->blockstate = BS_rml_getframe;
            return LOOPBACK;

         }

         if (s->PMR == DCN) {

            s->dcnrc = Error_RTN_Sent_Thrice;
            s->blockstate = BS_rml_sendDCN;
            return LOOPBACK;

         }

         if (s->cmd == DCS) {

            s->blockstate = BS_rml_wait50ms;
            return LOOPBACK;

         }

         if (s->cmd == MPS || s->cmd == EOM || s->cmd == EOP) {

            s->blockstate = BS_rml_gotPMC;
            return LOOPBACK;

         }

         PDebug_TPPrintf ("Block 3: no valid command received!\n");
         s->blockstate = BS_rml_getframe;
         return LOOPBACK;

      case BS_rml_gotPMC:

         buffermanager_put_string (s->bufIDout, "AT+FTH=3\r");
         // @@ Need to indicate break so that don't confuse with same page with temp. carrier loss
         // @@ What am I on about?  I think this is to do with T4s.
         s->data[0] = 0xff;
         s->data[1] = Control_Final;
         s->data[2] = s->PMR + s->bits.X;
         s->ndata = 3;
         s->subroutine = S_send_frame;
         s->substate = SS_sf_start;
         s->blockstate = BS_rml_restart;
         if (s->cmd == EOM || s->PMR == RTN) {
            s->bits.allowDCS = TRUE;
            s->bits.allowT4r = FALSE;
         } else if (s->cmd == MPS) {
            s->bits.allowDCS = TRUE; // @@ Common T.30 violation (according to FT) @@
            s->bits.allowT4r = TRUE;
         } else { // EOP
            s->bits.allowDCS = FALSE;
            s->bits.allowT4r = FALSE;
         }
         s->cmd = 0;
         return LOOPBACK;

      case BS_rml_wait50ms:

         // This is the entry point from rx_initial_identification.
         // T2 is active at this point, so don't ever need safety timeouts.

         PDebug_TPPrintf ("TCFWAIT: waiting for 50 ms\n"); // @@ Change to FRS=1?
         buffermanager_put_string (s->bufIDout, "AT+FTS=0\r"); // Note there is an additional latency
// mgr 1998-01-12: Try arguably better technique
//                 Disastrous results with Pace as local modem!
//         PDebug_TPPrintf ("TCFWAIT: waiting for 10 ms silence\n");
//         buffermanager_put_string (s->bufIDout, "AT+FRS=1\r");
         s->cmd = 0;
         M_modem_get_response (BS_rml_waitTCF);

      case BS_rml_waitTCF:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK".)

            s->blockstate = BS_rml_T2timeout;
            return LOOPBACK;

         }

         if (strcmp (s->response, "OK") != 0) {

            PDebug_Printf ("%06u  %i  TCFWAIT: unexpected response: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         // Sanity-check DCS
      {
         int n;

         n = 0;
         if (s->DCS[2] & 0x40) ++n;                       // 200x200
         if (s->DCS[0] >= 6 && (s->DCS[6] & 0x01)) ++n;   // 200x400
         if (s->DCS[0] >= 6 && (s->DCS[6] & 0x04)) ++n;   // 400x400

         if (n > 1) {

            PDebug_TPPrintf ("EEEEEEK: contradictory DCS resolution!\n");
            M_return_error (Error_Contradictory_DCS);

         }

         n = 0;
         if (s->DCS[0] >= 10 && (s->DCS[10] & 0x08)) ++n; // US Letter
         if (s->DCS[0] >= 10 && (s->DCS[10] & 0x10)) ++n; // US Legal

         if (n >= 1 && (s->DCS[3] & 0x03)) {              // Width (A4 is 00)

            PDebug_TPPrintf ("EEEEEEK: contradictory DCS width!\n");
            M_return_error (Error_Contradictory_DCS);

         }

         if (   s->DCS[1]                                 // *Group 1/2 and new-fangled stuff
            || (s->DCS[2] & 0x01)                         // T.4 transmit
            || (s->DCS[2] & 0x02) == 0x00                 // T.4 receive
            || (s->DCS[3] & 0x03) == 0x03                 // Undefined width
            || (s->DCS[3] & 0x0c) == 0x0c                 // Undefined length
            || (s->DCS[0] >= 4 && (s->DCS[4] & 0x77))     // *2400, unc, ECM, *ELM, *G4, MMR
            || (s->DCS[0] >= 5 && (s->DCS[5] & 0x7f))     // *A5/A6
            || (s->DCS[0] >= 6 && (s->DCS[6] & 0x42))     // 300x300, SEP
            || (s->DCS[0] >= 7 && (s->DCS[7] & 0x7f))     // Misc. fancy
            || (s->DCS[0] >= 8 && (s->DCS[8] & 0x7f))     // Misc. fancy
            || (s->DCS[0] >= 9 && (s->DCS[9] & 0x7f))     // Misc. fancy
            || (s->DCS[0] >= 10 && (s->DCS[10] & 0x67))   // Misc. fancy
            ) {

            PDebug_TPPrintf ("EEEEEEK: fishy DCS!\n");
            s->bits.fishy = TRUE;

         } else

            s->bits.fishy = FALSE;
      }

         PDebug_TPPrintf ("TCFGET : getting TCF\n");

         switch ((s->DCS[2] & 0x3c) >> 2) {
            case 0:
               buffermanager_put_string (s->bufIDout, "AT+FRM=24\r");
               s->datarate = 2400;
               break;
            case 2:
               buffermanager_put_string (s->bufIDout, "AT+FRM=48\r");
               s->datarate = 4800;
               break;
            case 1:
               buffermanager_put_string (s->bufIDout, "AT+FRM=96\r");
               s->datarate = 9600;
               break;
            case 3:
               buffermanager_put_string (s->bufIDout, "AT+FRM=72\r");
               s->datarate = 7200;
               break;
            case 6:
            case 10:
               buffermanager_put_string (s->bufIDout, "AT+FRM=121\r");
               s->datarate = 12000;
               break;
            case 4:
            case 8:
               buffermanager_put_string (s->bufIDout, "AT+FRM=145\r");
               s->datarate = 14400;
               break;
            case 11:
               buffermanager_put_string (s->bufIDout, "AT+FRM=73\r");
               s->datarate = 7200;
               break;
            case 9:
               buffermanager_put_string (s->bufIDout, "AT+FRM=97\r");
               s->datarate = 9600;
               break;
            default:
               PDebug_TPPrintf ("EEEEEEK: unsupported DCS datarate!\n");
               M_return_error (Error_Unsupported_DCS);
         }

         M_modem_get_response (BS_rml_startTCF);

      case BS_rml_startTCF:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK".)
            // Don't need to worry about the famous CONNECT just as abort problem,
            // because M_return_error (Error_T2_Timeout) will occur (s->bits.allowEOM == FALSE here).

            s->blockstate = BS_rml_T2timeout;
            return LOOPBACK;

         }

         if (strcmp (s->response, "+FCERROR") == 0) {

            // Hm, must have missed TCF; try to catch new frame
            s->blockstate = BS_rml_getframe;
            return LOOPBACK;

         }

         if (strcmp (s->response, "CONNECT") != 0) {

            PDebug_Printf ("%06u  %i  TCFGET : unexpected response: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         PDebug_TPPrintf ("TCFCOLL: collecting TCF\n");
         M_set_info (Info_Getting_TCF);
         s->bits.DLErecd = FALSE;
         s->blockstate = BS_rml_getTCF;
         s->ndata = s->maxNULs = 0;
         return LOOPBACK;

      case BS_rml_getTCF:
      {
         int character;

         while ((character = buffermanager_get_byte (s->bufIDin)) != -1) {

            if (s->bits.DLErecd) {              // Previous char was a <DLE>

               if (character == ETX) {          // <DLE><ETX> handling

                  M_modem_get_response (BS_rml_gotTCF);

               }                                // <DLE><DLE> handling; drops through here

               s->bits.DLErecd = FALSE;

            } else if (character == DLE) {

               s->bits.DLErecd = TRUE;
               continue;

            }

            if (character == NUL) {

               if (++s->ndata > s->maxNULs)
                  s->maxNULs = s->ndata;

            } else

               s->ndata = 0;

         }

         return DONE;                           // Done for now (need to collect more chars)
      }

      case BS_rml_gotTCF:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK".)

            s->blockstate = BS_rml_T2timeout;
            return LOOPBACK;

         }

         if (strcmp (s->response, "NO CARRIER") != 0) {

            PDebug_Printf ("%06u  %i  TCFGOT : unexpected response: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         s->ndata = s->maxNULs * 80 / (s->datarate / 100);
         PDebug_Printf ("%06u  %i  TCFGOT : got %i consecutive NULs (%i ms)\n"
                       , clock(), s->port, s->maxNULs, s->ndata);

         buffermanager_put_string (s->bufIDout, "AT+FTH=3\r");
         s->data[0] = 0xff;
         s->data[1] = Control_Final;

         if (s->ndata >= s->minTCF && s->ndata <= s->maxTCF) {

            s->data[2] = CFR + s->bits.X;
            s->bits.allowT4r = TRUE;
            PDebug_TPPrintf ("TCFGOT : sending CFR response\n");
            M_set_info (Info_Sending_CFR);

         } else {

            s->data[2] = FTT + s->bits.X;
            s->bits.allowT4r = FALSE;
            PDebug_TPPrintf ("TCFGOT : sending FTT response\n");
            M_set_info (Info_Sending_FTT);

         }

         s->ndata = 3;
         s->subroutine = S_send_frame;
         s->substate = SS_sf_start;
         s->blockstate = BS_rml_restart;
//         s->dillweed = 1;
         M_cancel_timeout (T2); // @@ This is strictly speaking a T.30 violation @@
         M_start_timeout (T2);  // @@ but is useful for long TCFs (e.g. V.17) @@
         return LOOPBACK;

      case BS_rml_gotT4:

         // This is the entry point from B_rx_main_loop.
         // T2 is active at this point, so don't ever need safety timeouts.

         M_modem_get_response (BS_rml_checkT4);

      case BS_rml_checkT4:

         if (s->timedout) {

            // Don't bother checking modem response.
            // (Should be "OK".)

            s->blockstate = BS_rml_T2timeout;
            return LOOPBACK;

         }

         if (strcmp (s->response, "NO CARRIER") != 0) {

            PDebug_Printf ("%06u  %i  CHECKT4: unexpected response: %s\n"
                          , clock(), s->port, s->response);
            M_return_error (Error_Unexpected_Modem_Response);

         }

         s->blockstate = BS_rml_restart;
         return LOOPBACK;

      case BS_rml_T2timeout:

         if (s->cmd != 0 || !s->bits.allowEOM || s->bits.allowEOP) {

            PDebug_TPPrintf ("Block 3: T2 timeout!\n");
            M_return_error (Error_T2_Timeout);

         }

         PDebug_TPPrintf ("Block 3: T2 timeout and last command was EOM; "
                          "restarting Phase B tx\n");
         M_start_timeout (T1);
         s->subroutine = s->timedout = 0; // Clear timeout
         s->datarate = 0;
         s->bits.II = TRUE;
         s->bits.X = 0;
         s->block = B_rx_initial_identification;
         s->blockstate = BS_rii_restart;
         return LOOPBACK;

      case BS_rml_sendDCN:

         PDebug_TPPrintf ("Block 3: sending DCN\n");
         buffermanager_put_string (s->bufIDout, "AT+FTH=3\r");
         s->data[0] = 0xff;
         s->data[1] = Control_Final;
         s->data[2] = DCN + s->bits.X;
         s->ndata = 3;
         s->subroutine = S_send_frame;
         s->substate = SS_sf_start;
         M_set_info (Info_Sending_DCN);
         s->blockstate = BS_rml_sentDCN;
         return LOOPBACK;

      case BS_rml_sentDCN:

// @@ Need to check subroutine return

         M_return_error (s->dcnrc);

   }

   return DONE; // Should never be hit; just here to pacify compiler
}
#pragma -s0


///////////////////////////////////////////////////////////////////////////////
//
// modem_put_chars
//
// Puts characters into a buffer.  No <DLE> escaping.
//
// Inputs:  b           (internal buffer ID)
//          s           (string to put)
//          n           (length of string)
//
// Outputs: nothing
//
// Assumes: nothing
//
// Returns: number of characters not put
//
///////////////////////////////////////////////////////////////////////////////

#if 0
intern int newbufmodem_put_chars (const uint b, const char *const s, const int n)
#pragma -s1
{
   return buffermanager_put_block (b, s, n);
#if 0
   _kernel_swi_regs r;

/*D
   int i;
   for (i = 0; i < n; ++i) {
      rresponse[rresppos++] = s[i];
      if (rresppos == sizeof rresponse) --rresppos;
   }
D*/

//D   PDebug_Printf ("Putting: %s (%i chars)\n", s, n);

   r.r[0] = BufferManager_InsertBlock;
   r.r[1] = (int) b;
   r.r[2] = (int) s;
   r.r[3] = n;
   if (buffermanager_call_service (&r, buffermanager_service_routine
                                  , buffermanager_service_pw) & C_Flag) {
      return r.r[3];
   }
   return 0;
#endif
}
#pragma -s0
#endif

///////////////////////////////////////////////////////////////////////////////
//
// modem_put_DLEddata
//
// Puts characters into a buffer with <DLE> escaping, followed by <DLE><ETX>.
//
// Inputs:  b           (internal buffer ID)
//          s           (string to put)
//          n           (length of string (can be 0 to just put <DLE><ETX>))
//
// Outputs: nothing
//
// Assumes: nothing
//
// Returns: number of characters not put (-1 is returned if <DLE><ETX> weren't put)
//          [not especially useful because <DLE> escaping failed is not marked!]
//
///////////////////////////////////////////////////////////////////////////////

#if 0
intern int newbufmodem_put_DLEddata (const uint b, const char *const s, const int n)
#pragma -s1
{
   return buffermanager_put_DLEdblock (b, s, n);
#if 0
   _kernel_swi_regs r;
   int i;

/*D
   for (i = 0; i < n; ++i) {
      rresponse[rresppos++] = s[i];
      if (rresppos == sizeof rresponse) --rresppos;
   }
D*/

   r.r[0] = BufferManager_InsertByte;
   r.r[1] = (int) b;

   for (i = 0; i < n; ++i) {

      r.r[2] = (int) s[i];
      if (buffermanager_call_service (&r, buffermanager_service_routine
                                     , buffermanager_service_pw) & C_Flag) {
         return n - i;
      }
      if (s[i] == DLE) {
         if (buffermanager_call_service (&r, buffermanager_service_routine
                                        , buffermanager_service_pw) & C_Flag) {
            return n - i;
         }
      }

   }
   r.r[2] = DLE;
   if (buffermanager_call_service (&r, buffermanager_service_routine
                                        , buffermanager_service_pw) & C_Flag) {
      return -1;
   }
   r.r[2] = ETX;
   if (buffermanager_call_service (&r, buffermanager_service_routine
                                        , buffermanager_service_pw) & C_Flag) {
      return -1;
   }
   return 0;
#endif
}
#pragma -s0
#endif


///////////////////////////////////////////////////////////////////////////////
//
// faxint_strip_SI
//
// Strips (removes spaces at either side) and reverses received SI.
// Supports any FIF size, including zero and more than 20.
// If there are more than 20 significant FIF characters, the first 20
// are returned (so the country code gets lost first).
//
// Inputs:  s           (pointer to state structure)
//          SI          (buffer to hold SI)
//
// Outputs: s
//          SI
//
// Assumes: s->ndata >= 5
//
// Returns: nothing
//
///////////////////////////////////////////////////////////////////////////////

intern void faxint_strip_SI (State *s, char *SI)
{
   int istart, iend;

   // Find the index of the first non-space character
   istart = 3; // FIF starts at index 3
   while (istart < s->ndata && s->data[istart] == ' ')
      ++istart;

   // Find the index of the last non-space character (allow up to 20 chars)
   iend = istart + 20 - 1;
   if (iend >= s->ndata - 2) // Last two characters are FCS
      iend = s->ndata - 2 - 1;
   while (iend >= istart && s->data[iend] == ' ')
      --iend;

   // Reverse into SI and terminate
   while (iend >= istart)
      *SI++ = s->data[iend--];
   *SI = NUL;
}


///////////////////////////////////////////////////////////////////////////////
//
// faxint_generate_dcs
//
// Generates DCS from DIS and page to transmit's width, length, and resolution.
// The rate bits are left clear.
//
// Inputs:  s           (pointer to state structure)
//
// Outputs: s
//
// Assumes: s->DIS >= 3
//          DIS has been checked for "Receiver cannot receive", etc.
//          valid s->resnin (0x21, 0x22, 0x24 or 0x44)
//          valid s->imagewidth (1728, 2048, 2432 or double that if s->resnin == 0x44)
//
// Returns: nothing
//
///////////////////////////////////////////////////////////////////////////////

intern void faxint_generate_dcs (State *s)
{
   BOOL cap22 = FALSE, cap24 = FALSE, cap44 = FALSE; // Resolution caps
   BOOL capLt = FALSE, capLg = FALSE; // Page length caps
   BOOL sfhalve; // Set if superfine out and T15.4 = 1/2 T7.7
   BOOL fhalve; // Set if fine or superfine out
//   int resn; // Selected packed resn
//   int minscan; // Selected MSLT in ms
   int normalisedimagewidth; // Image width in pels, normalised to R8
   int normalisedimagelength; // Image length in 1/10 mm, normalised to 3.85
///old   int inputlencode; // Input image length code:
   int inputwidcode; // Input image width code:
   int outputlencapcode; // Output image length cap code:
   int outputwidcapcode; // Output image width cap code:
   int outputlencode; // Output image length code (for scaling):
   int outputlenchopcode; // Output image length code (for chopping):
   int outputwidcode; // Output image width code (for scaling):

#define ImageLt 3
#define ImageA4 4
#define ImageLg 5
#define ImageB4 6
#define ImageA3 7
#define Imageul 8

   static int imagelengths[] = { 0, 0, 0 // Image lengths in 1/10 mm
                               , 2794
                               , 2970
                               , 3556
                               , 3640
                               , 4200
                               , 9999 // Should never be accessed
   };

   // Determine receiver's resn caps
   if (s->DIS[2] & 0x40)
      cap22 = TRUE;
   if (s->DIS[0] >= 6 && (s->DIS[6] & 0x01))
      cap24 = TRUE;
   if (s->DIS[0] >= 6 && (s->DIS[6] & 0x04))
      cap44 = TRUE;

   // Select output resn
   if (s->resnin == 0x22) {

      // If input resn is 22, output resn tried as 22, 24, 44, 21 in sequence
      if (cap22)
         s->resnout = 0x22;
      else if (cap24)
         s->resnout = 0x24;
      else if (cap44)
         s->resnout = 0x44;
      else
         s->resnout = 0x21;

   } else if (s->resnin == 0x24) {

      // If input resn is 24, output resn tried as 24, 44, 22, 21 in sequence
      if (cap24)
         s->resnout = 0x24;
      else if (cap44)
         s->resnout = 0x44;
      else if (cap22)
         s->resnout = 0x22;
      else
         s->resnout = 0x21;

   } else if (s->resnin == 0x44) {

      // If input resn is 44, output resn tried as 44, 24, 22, 21 in sequence
      if (cap44)
         s->resnout = 0x44;
      else if (cap24)
         s->resnout = 0x24;
      else if (cap22)
         s->resnout = 0x22;
      else
         s->resnout = 0x21;

   } else // Input resolution is 21, so just use it without further ado
      s->resnout = 0x21;

   // Determine receiver's MSLT for that resolution
   fhalve = (s->resnout & 0x0f) >= 2;
   sfhalve = (s->resnout & 0x0f) == 4 && s->DIS[0] >= 6 && (s->DIS[6] & 0x20);

   switch ((s->DIS[3] & 0x70) >> 4) {

      case 0: // 20/20

         s->minscan = 20;
         if (sfhalve) s->minscan /= 2;
         break;

      case 1: // 5/5

         s->minscan = 5;
         if (sfhalve) s->minscan /= 2;
         break;

      case 2: // 10/10

         s->minscan = 10;
         if (sfhalve) s->minscan /= 2;
         break;

      case 3: // 20/10

         s->minscan = 20;
         if (fhalve) s->minscan /= 2;
         if (sfhalve) s->minscan /= 2;
         break;

      case 4: // 40/40

         s->minscan = 40;
         if (sfhalve) s->minscan /= 2;
         break;

      case 5: // 40/20

         s->minscan = 40;
         if (fhalve) s->minscan /= 2;
         if (sfhalve) s->minscan /= 2;
         break;

      case 6: // 10/5

         s->minscan = 10;
         if (fhalve) s->minscan /= 2;
         if (sfhalve) s->minscan /= 2;
         break;

      case 7: // 0/0
//      default: // Never hit; just there to prevent compiler warning about minscan used before init
         s->minscan = 0;
         break;

   }

   // Correct for T.30 violation (request 2.5 ms MSLT for superfine)
   if (s->minscan != 0 && s->minscan < 5)
      s->minscan = 5;

   PDebug_Printf ("Min scan, input resn %.2x, output resn %.2x, is %i ms\n"
                 , s->resnin, s->resnout, s->minscan);

   // Initialise output DCS
   s->DCS[1] = 0x00; // No *Group 1/2 or new-fangled stuff

   s->DCS[2] = 0x02; // b10 set, b9 clear, data rate bits clear;
                     // see below for 200x200 and 2D MR

   s->DCS[3] = 0x00; // See below for width, length and MSLT

   s->DCS[4] = 0x00; // *2400 bps, unc, ECM, b28, *ELM, *G4, 2D MMR clear

   s->DCS[5] = 0x00; // *A5/A6 clear

   s->DCS[6] = 0x00; // set metric resolution, 300 x 300, b46, b47 clear;
                     // see below for 200x400 and 400x400

   s->DCS[7] = 0x00; // Miscellaneous fancy clear

   s->DCS[8] = 0x00; // Miscellaneous fancy clear

   s->DCS[9] = 0x00; // Miscellaneous fancy clear

   s->DCS[10] = 0x00; // Miscellaneous fancy clear;
                      // see below for Lt and Lg

   // Insert resolution bits
   if (s->resnout == 0x22)
      s->DCS[2] |= 0x40; // 200x200
   if (s->resnout == 0x24)
      s->DCS[6] |= 0x01; // 200x400
   if (s->resnout == 0x44)
      s->DCS[6] |= 0x04; // 400x400

   // Insert coding bits
   if (s->DIS[2] & 0x80)
      s->DCS[2] |= 0x80; // 2D MR coding

   // Insert MSLT bits
   if (s->minscan == 0)
      s->DCS[3] |= 0x70;
   else if (s->minscan == 5)
      s->DCS[3] |= 0x10;
   else if (s->minscan == 10)
      s->DCS[3] |= 0x20;
   else if (s->minscan != 20) // That should only be 40.  Note 20 is all clear
      s->DCS[3] |= 0x40;

   // Determine input width and length info
   normalisedimagewidth = s->imagewidth * 2 / ((s->resnin & 0xf0) >> 4);
   normalisedimagelength = s->imagelength / (s->resnin & 0x0f) * 1000 / 385;

   if (normalisedimagewidth == 2048)
      inputwidcode = ImageB4;
   else if (normalisedimagewidth == 2432)
      inputwidcode = ImageA3;
   else
      inputwidcode = ImageA4;

   // Determine receiver's width and length caps
   if (s->DIS[0] >= 10 && (s->DIS[10] & 0x08))
      capLt = TRUE;
   if (s->DIS[0] >= 10 && (s->DIS[10] & 0x10))
      capLg = TRUE;
   if ((s->DIS[3] & 0x0c) == 0x08)
      outputlencapcode = Imageul;
   else if ((s->DIS[3] & 0x0c) == 0x04)
      outputlencapcode = ImageB4;
   else {
      outputlencapcode = ImageA4; // This also accepts the invalid 11 combination
   }

   if ((s->DIS[3] & 0x03) == 0x00)
      outputwidcapcode = ImageA4;
   else if ((s->DIS[3] & 0x03) == 0x01)
      outputwidcapcode = ImageB4;
   else
      outputwidcapcode = ImageA3; // This also accepts the official invalid 11 combination

   // RiScalE' (TM) step 1: select width scaling
   if (outputwidcapcode >= inputwidcode)

      // No need to width scale
      outputwidcode = inputwidcode;

   else

      // Need to width scale down
      outputwidcode = outputwidcapcode;

   // RiScalE' (TM) step 2: pick corresponding length scaling
   outputlencode = outputwidcode;

   // Get scaling lengths in and out, here in 1/10 mm -- converted to lines below
   s->lengthin = imagelengths[inputwidcode]; // Yes, inputwidcode
   s->lengthout = imagelengths[outputlencode];

   // RiScalE' (TM) step 3: select chop length
   outputlenchopcode = outputlencapcode;

   // RiScalE' (TM) step 3b: allow chopping into Lg chunks (iff A4 output width and not B4-capable)
   if (capLg && outputwidcode == ImageA4 && outputlenchopcode < ImageLg)

      outputlenchopcode = ImageLg;

   // RiScalE' (TM) step 3c: allow chopping into Lt chunks (iff A4 output width and short enough)

   if (capLt && outputwidcode == ImageA4
      && normalisedimagelength * s->lengthout / s->lengthin // That's output length after scaling
         <= imagelengths[ImageLt] * (1000 + PAGELENTOL) / 1000) // That's Lt length after tolerance

      outputlenchopcode = ImageLt;

   // Insert width bits
   if (outputwidcode == ImageB4) {
      s->DCS[3] |= 0x01;
      s->widthout = 2048; // Here in pels for R8 -- converted to pels for R16 if appropriate below
   } else if (outputwidcode == ImageA3) {
      s->DCS[3] |= 0x02;
      s->widthout = 2432;
   } else { // Must be ImageA4
      // s->DCS[3] != 0x00;
      s->widthout = 1728;
   }
   s->widthout = s->widthout * (s->resnout & 0xf0) >> 4 >> 1;

   // Insert length bits
   if (outputlenchopcode == ImageLt) {
      s->DCS[10] |= 0x08;
      s->chopout = imagelengths[ImageLt]; // Here in 1/10 mm -- converted to lines below
   } else if (outputlenchopcode == ImageLg) {
      s->DCS[10] |= 0x10;
      s->chopout = imagelengths[ImageLg];
   } else if (outputlenchopcode == ImageB4) {
      s->DCS[3] |= 0x04;
      s->chopout = imagelengths[ImageB4];
   } else if (outputlenchopcode == Imageul) {
      s->DCS[3] |= 0x08;
      s->chopout = 0; // Special value to indicate ul (so no chopping)
   } else { // Must be ImageA4
      // s->DCS[3] != 0x00;
      s->chopout = imagelengths[ImageA4];
   }

   // Now calculate chopout in lines
   s->chopout = s->chopout * s->lengthin / s->lengthout * (s->resnin & 0x0f) * 385 / 1000;

   // Now calculate scaling lengths in and out in lines
   s->lengthin = s->lengthin * (s->resnin & 0x0f) * 385 / 1000;
   s->lengthout = s->lengthout * (s->resnout & 0x0f) * 385 / 1000;

   PDebug_Printf ("Normalised page: %i pel x %i 1/10 mm, %i x ? code\n"
                 , normalisedimagewidth, normalisedimagelength
                 , inputwidcode);///old, inputlencode);
   PDebug_Printf ("Input given: %i pel x %i pel\n"
                 , s->imagewidth
                 , s->imagelength);
   PDebug_Printf ("Output page caps: %i x %i code\n"
                 , outputwidcapcode, outputlencapcode);
   PDebug_Printf ("Output page chosen: %i x %i code, chop %i code\n"
                 , outputwidcode, outputlencode, outputlenchopcode);
   PDebug_Printf ("Width scaling: %i -> %i pels\n"
                 , s->imagewidth, s->widthout);
   PDebug_Printf ("Length scaling: %i -> %i lines; chopping at %i input lines\n"
                 , s->lengthin, s->lengthout, s->chopout);

#ifdef RiSCRAPPY

   // Determine input width and length info
   normalisedimagewidth = s->imagewidth * 2 / ((s->resnin & 0xf0) >> 4);
   normalisedimagelength = s->imagelength / (s->resnin & 0x0f) * 1000 / 385;

   if (normalisedimagelength <= 2822)
      inputlencode = ImageLt;
   else if (normalisedimagelength <= 3000)
      inputlencode = ImageA4;
   else if (normalisedimagelength <= 3592)
      inputlencode = ImageLg;
   else if (normalisedimagelength <= 3676)
      inputlencode = ImageB4;
   else if (normalisedimagelength <= 4242)
      inputlencode = ImageA3;
   else
      inputlencode = Imageul;

   if (normalisedimagewidth == 2048)
      inputwidcode = ImageB4;
   else if (normalisedimagewidth == 2432)
      inputwidcode = ImageA3;
   else
      inputwidcode = ImageA4;

    if (inputwidcode != ImageA4) { // Lt and Lg are only valid with A4 width
      if (inputlencode == ImageLt) // Else promote Lt to A4
         inputlencode = ImageA4;
      if (inputlencode == ImageLg) // and Lg to B4
         inputlencode = ImageB4;
   }

   PDebug_Printf ("Normalised page: %i pel x %i 1/10 mm, %i x %i code\n"
                 , normalisedimagewidth, normalisedimagelength
                 , inputwidcode, inputlencode);
   PDebug_Printf ("Input given: %i pel x %i pel\n"
                 , s->imagewidth
                 , s->imagelength);

   // Determine receiver's width and length caps
   if (s->DIS[0] >= 10 && (s->DIS[10] & 0x08))
      capLt = TRUE;
   if (s->DIS[0] >= 10 && (s->DIS[10] & 0x10))
      capLg = TRUE;
   if ((s->DIS[3] & 0x0c) == 0x08)
      outputlencapcode = Imageul;
   else if ((s->DIS[3] & 0x0c) == 0x04)
      outputlencapcode = ImageB4;
   else {
      outputlencapcode = ImageA4; // This also accepts the invalid 11 combination
      if (capLg)
         outputlencapcode = ImageLg;
   } // Note machine must be capable of A4, so ImageLg is not a valid outputlencapcode

   if ((s->DIS[3] & 0x03) == 0x00)
      outputwidcapcode = ImageA4;
   else if ((s->DIS[3] & 0x03) == 0x01)
      outputwidcapcode = ImageB4;
   else
      outputwidcapcode = ImageA3; // This also accepts the official invalid 11 combination

   PDebug_Printf ("Output page caps: %i x %i code\n"
                 , outputwidcapcode, outputlencapcode);

   // Apply the funky algorithm!
   if (inputlencode <= outputlencapcode && inputwidcode <= outputwidcapcode) {

      PDebug_Printf ("Scheme 1: fits\n");
      outputwidcode = inputwidcode;
      outputlencode = inputlencode;

      // Don't use Lt if not explicitly supported by other end, use A4
      if (outputlencode == ImageLt && !capLt)
         outputlencode = ImageA4;
      // Don't use Lg if not explicitly supported by other end, use B4
      if (outputlencode == ImageLg && !capLg)
         outputlencode = ImageB4;
      // Don't use A3, use ul
      if (outputlencode == ImageA3)
         outputlencode = Imageul;

   } else if (/*inputlencode > outputlencapcode && */inputwidcode <= outputwidcapcode) {

      PDebug_Printf ("Scheme 2: too long\n");
      outputwidcode = inputwidcode;
      outputlencode = outputlencapcode;

   } else {

      PDebug_Printf ("******************\nAWOOOGA!  Scheme not implemented yet!\n***********\n");
      PDebug_Printf ("Scheme 3 or 4\n");
      outputwidcode = outputwidcapcode;
      outputlencode = outputlencapcode;

   }

   PDebug_Printf ("Output page chosen: %i x %i code\n"
                 , outputwidcode, outputlencode);

   // Insert width bits
   if (outputwidcode == ImageB4) {
      s->DCS[3] |= 0x01;
      s->widthout = 2048; // Here in pels for R8 -- converted to pels for R16 if appropriate below
   } else if (outputwidcode == ImageA3) {
      s->DCS[3] |= 0x02;
      s->widthout = 2432;
   } else { // Must be ImageA4
      // s->DCS[3] != 0x00;
      s->widthout = 1728;
   }
   s->widthin = s->widthout * (s->resnin & 0xf0) >> 4 >> 1;
   s->widthout = s->widthout * (s->resnout & 0xf0) >> 4 >> 1;

   // Insert length bits
   if (outputlencode == ImageLt) {
      s->DCS[10] |= 0x08;
      s->lengthout = 2794; // Here in 1/10 mm -- converted to lines below
   } else if (outputlencode == ImageLg) {
      s->DCS[10] |= 0x10;
      s->lengthout = 3556;
   } else if (outputlencode == ImageB4) {
      s->DCS[3] |= 0x04;
      s->lengthout = 3640;
   } else if (outputlencode == Imageul) {
      s->DCS[3] |= 0x08;
      s->lengthout = 0; // Special value to indicate ul
   } else { // Must be ImageA4
      // s->DCS[3] != 0x00;
      s->lengthout = 2970;
   }
   s->chopout = s->lengthout * (s->resnin & 0x0f) * 385 / 1000; //@@Verify that this is always
                                                 //@@bigger than lengthin for no chop situations
   s->lengthout = s->lengthout * (s->resnout & 0x0f) * 385 / 1000;

#endif

   // Insert extend bits and set DCS length
   s->DCS[0] = s->DIS[0];
   if (s->DIS[0] > 3)
      s->DCS[3] |= 0x80;
   if (s->DIS[0] > 4)
      s->DCS[4] |= 0x80;
   if (s->DIS[0] > 5)
      s->DCS[5] |= 0x80;
   if (s->DIS[0] > 6)
      s->DCS[6] |= 0x80;
   if (s->DIS[0] > 7)
      s->DCS[7] |= 0x80;
   if (s->DIS[0] > 8)
      s->DCS[8] |= 0x80;
   if (s->DIS[0] > 9)
      s->DCS[9] |= 0x80;
   if (s->DIS[0] > 10)
      s->DCS[0] = 10;

{
   int i;

   PDebug_Printf ("Resulting DCS:");

   for (i = 1; i <= s->DCS[0]; ++i) {

      PDebug_Printf (" 0x%.2x", s->DCS[i]);

   }

   PDebug_Printf (".\n");
}
}


///////////////////////////////////////////////////////////////////////////////
//
// faxint_select_datarate
//
// Selects a datarate, given the previous data rate.  The new data rate is
// written into DCS.  The appropriate strings for TCF and T.4 AT+FTM are set.
//
// A previous data rate of 0 results in selection of the highest rate possible.
// A data rate of 0 returned is the "Too slow" error.
//
// Inputs:  s           (pointer to state structure)
//
// Outputs: s
//
// Assumes: s->DIS >= 3
//          s->FTM buffers large enough (4 characters)
//
// Returns: nothing
//
///////////////////////////////////////////////////////////////////////////////

intern void faxint_select_datarate (State *s)
{
   int disratecaps;

   // Get DIS data rate capabilities:
   //    0 = V.27 f
   //    1 = V.29
   //    2 = V.27
   //    3 = V.27, V.29
   //    7 = *V.27, V.29, V.33
   //   11 = V.27, V.29, V.33, V.17
   disratecaps = (s->DIS[2] & 0x3c) >> 2;
   if (disratecaps > 3 && disratecaps != 7) // If reserved/not used pattern, assume V.17
      disratecaps = 11;

   s->DCS[2] &= ~0x3c; // Zero DCS data rate bits

   if (s->datarate == 0)
      s->datarate = 14400;
   else
      s->datarate -= 2400;

   while (s->datarate > 0) {

      if (s->datarate == 14400) { // switch not used because couldn't break out easily

         if (disratecaps == 11) {

            strcpy (s->FTMTCF, "145");
            strcpy (s->FTMT4, "146");
            s->DCS[2] |= 8 << 2;
            break;

         }

         if (disratecaps == 7) {

            strcpy (s->FTMTCF, "145");
            strcpy (s->FTMT4, "145");
            s->DCS[2] |= 4 << 2;
            break;

         }

      }

      if (s->datarate == 12000) {

         if (disratecaps == 11) {

            strcpy (s->FTMTCF, "121");
            strcpy (s->FTMT4, "122");
            s->DCS[2] |= 10 << 2;
            break;

         }

         if (disratecaps == 7) {

            strcpy (s->FTMTCF, "121");
            strcpy (s->FTMT4, "121");
            s->DCS[2] |= 6 << 2;
            break;

         }

      }

      if (s->datarate == 9600) {

         if (disratecaps == 11) {

            strcpy (s->FTMTCF, "97");
            strcpy (s->FTMT4, "98");
            s->DCS[2] |= 9 << 2;
            break;

         }

         if (disratecaps != 0 && disratecaps != 2) {

            strcpy (s->FTMTCF, "96");
            strcpy (s->FTMT4, "96");
            s->DCS[2] |= 1 << 2;
            break;

         }

      }

      if (s->datarate == 7200) {

         if (disratecaps == 11) {

            strcpy (s->FTMTCF, "73");
            strcpy (s->FTMT4, "74");
            s->DCS[2] |= 11 << 2;
            break;

         }

         if (disratecaps != 0 && disratecaps != 2) {

            strcpy (s->FTMTCF, "72");
            strcpy (s->FTMT4, "72");
            s->DCS[2] |= 3 << 2;
            break;

         }

      }

      if (s->datarate == 4800) {

         if (disratecaps != 0 && disratecaps != 1) {

            strcpy (s->FTMTCF, "48");
            strcpy (s->FTMT4, "48");
            s->DCS[2] |= 2 << 2;
            break;

         }

      }

      if (s->datarate == 2400) {

         if (disratecaps != 1) {

            strcpy (s->FTMTCF, "24");
            strcpy (s->FTMT4, "24");
            s->DCS[2] |= 0 << 2;
            break;

         }

      }

      s->datarate -= 2400; // No joy; try dropping rate

   }
}
