/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.drawTextC
 * Purpose: handling draw text columns
 * History: IDJ: 06-Feb-92: prepared for source release
 *
 */

/*
 * To handle errors, we do a prescan just after the file has been loaded to
 * check that all special sequences are valid. Errors are reported at this
 * stage. During rendering, errors that could not be trapped earlier are
 * passed back up as far as possible.
 *
 * Fonts: when the file is being verified, we make sure that there is at least
 * one font that can be loaded, and report and error if there is not. The
 * handle for this font is used as the default, and also for sections where the
 * font is unrecognised.
 *
 * When reading text, we must create a temporary store so that we can verify it
 * and find the number of columns. There is thus a short term overhead of
 * memory equal to the size of the text file.
 *
 * To get the underlining and vertical move state at the start of each output
 * line, some extra control sequences have to be inserted.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
/* #define isdigit(c) (c) >= '0' && (c) <= '9' */

#include "h.os"
#include "h.bbc"
#include "h.font"
#include "h.sprite"

#include "h.DrawIntern.drawfile1"
#include "h.drawfdiag"
#include "h.DrawIntern.drawfile2"
#include "h.drawferror"

extern BOOL Draw_memoryError; /* Must be defined elsewhere! */
extern int gWimpVersion;  /* RSP [21424] */
extern int MinMax(int MinVal, int expression, int MaxVal);

/*--------------------Macros, types, and globals ----------------------------*/

#define scaleupXX(xx)            ((int)((xx) * wr_dr_scalefactor_x))
#define scaleupYY(xx)            ((int)((xx) * wr_dr_scalefactor_y))
#define scaleupX(xx)           ((int)(orgx + (xx) * wr_dr_scalefactor_x))
#define scaleupY(xx)           ((int)(orgy + (xx) * wr_dr_scalefactor_y))

/* Symbolic values for text alignment */
typedef enum {alignLeft, alignRight, alignCentre, alignDouble} wr_draw_align;

#define wr_draw_text_maxFonts 99

/* Font usage counter - more convenient for this to be global */
static int *wr_draw_usedFont  /*[256] RSP now points to a local */;

/* Symbolic codes for font manager operations */
#define wr_draw_font_vmove     11
#define wr_draw_font_colour    18
#define wr_draw_true_font_colour 19
#define wr_draw_font_comment   21
#define wr_draw_font_underline 25
#define wr_draw_font_setfont   26

/* Symbolic codes for \escape codes */
#define wr_draw_ch_backSlash 0
#define wr_draw_ch_semicolon 1
#define wr_draw_ch_minus     2
#define wr_draw_ch_newline   3
#define wr_draw_ch_A         4
#define wr_draw_ch_B         5
#define wr_draw_ch_C         6
#define wr_draw_ch_D         7
#define wr_draw_ch_F         8
#define wr_draw_ch_L         9
#define wr_draw_ch_M         10
#define wr_draw_ch_P         11
#define wr_draw_ch_U         12
#define wr_draw_ch_V         13
#define wr_draw_ch_other     14

/* Total length of underline and vmove sequences */
#define wr_draw_insert 7
/* maximum length of a control sequence, to avoid writing off end of chunk */
/* really the value should be 7 and we should test when writing LMP font comments */
#define wr_draw_maxTrailer 20

/* Structure representing the parameter state at the start of an output line */
typedef struct
{
  int        leading, paraLeading;  /* In font units */
  int        lmargin, rmargin;      /* In font units */
  font       defaultFont;
  int        under1, under2;
  int        vmove;
  wr_draw_align align;
} wr_draw_linedata;


/* Macro for matching terminators */
#define isTerm(c) (c == '\n' || c == '/')

/* Globals used for address and maximum length of current chunk */
static char *wr_chunk;
static int  wr_chunkLen;

#define wr_draw_bigvalue 1 << 28  /* A large positive value */

/*
 Function    : wr_draw_findIndex
 Purpose     : to convert a set of text character set into a set of small integers
 Parameters  : input character
             : lookup table
 Returns     : index of character in the lookup table
 Description : searchs the lookup for the character, returning the index or
               table length if not located
*/

static int wr_draw_findIndex(int ch, char *lookup)
{
    int nextch;
    char *p;

    for (p = lookup; nextch = *(p++), nextch && ch != nextch; ) ;
    return p - lookup - 1;
}


/*
 Function    : wr_draw_text_findParent
 Purpose     : find the parent of a text column
 Parameters  : pointer to text area column (as an column pointer)
 Returns     : object pointer
 Description : looks backwards in steps of the size of the header until it
               finds the parent tag.
*/

static wr_draw_objptr wr_draw_text_findParent(wr_draw_textcolhdr *from)
{
    wr_draw_objptr parent;

    while (from->tag == wr_draw_OBJTEXTCOL) from -= 1;

    parent.textcolp = from;               /* Minor type fiddle here */
    return(parent);
}

/*
 Function    : wr_draw_text_findEnd
 Purpose     : find end section of a text area
 Parameters  : header pointer
 Returns     : pointer to end section
 Description : skips over the columns and returns a pointer to the end object
*/

static wr_draw_textareaend *wr_draw_text_findEnd(wr_draw_objptr hdrptr)
{
    wr_draw_textcolhdr *column;

    column = &(hdrptr.textareastrp->column);
    while (column->tag == wr_draw_OBJTEXTCOL) column++;
    return ((wr_draw_textareaend *)column);
}

/*
 Function    : wr_draw_text_getFontNum
 Purpose     : get a one or two digit font number
 Parameters  : pointer to string (first of which is a digit)
               OUT: font number
 Returns     : pointer to next character
 Description : read either one or two characters are forms a font number
               from them. Update over optional terminating /
*/

static char *wr_draw_text_getFontNum(char *text, int *fontNumber)
{
    unsigned int ch;
    int num = *(text++) - '0';

    ch = *text - '0';
    if (ch < 10)  /* unsigned test shows if ch isdigit */
    {
       num = num * 10 + ch;
       text++;
    }
    *fontNumber = num;
    return text;
}

/*
 Function    : wr_draw_text_getNum
 Purpose     : get an unsigned integer out of a string
 Parameters  : pointer to string
               pointer to int
 Returns     : updated pointer (after trailing spaces so next can be tested)
 Description : skip leading space; read an integer, skip trailing space.
*/

static char *wr_draw_text_getNum(char *p, int *to)
{
    unsigned int ch;

    while ((ch = *(p++)) == ' ');      /* skip over leading spaces */

    *to = atoi(p - 1);

    while ((ch = *(p++)) - '0' < 10);  /* skip any -, then to end of number */
    while (ch == ' ')
        ch = *(p++);                   /* skip over trailing spaces */
    return p - 1;
}

/*
 Function    : wr_draw_text_setFont
 Purpose     : locate and record font
 Parameters  : pointer to start of font definition sequence
               pointer to fonts array
 Returns     : new input pointer (character after newline)
 Description : this is used to handle the font definition sequence. The input
               has the form:
                <digit*><name><space><pointsize><newline>.
               or:
                <digit*><name><space><pointsize><space><pointwidth><newline>.

               NO LONGER USED DURING VERIFICATION
               This routine can also be called during verification, since we
               try to make sure that there is at least one valid font. Since
               this can happen before any scalefactor is set up, for a drop
               onto the icon bar, if the scalefactor is 0, we pretend it is 1.
*/

static char *wr_draw_text_setFont(char *in, font *fonts)
{
    int      fontNumber;
    char     *name;
    char     *end;
    char     displaced;
    int      pointVal;
    int      scaleSize;
    int      scaleWidth;
    font     fontHandle;

    /* Get font number */
    while (*in == ' ') in += 1;
    in = wr_draw_text_getFontNum(in, &fontNumber);

    /* Skip leading spaces in font name */
    while (*in == ' ') in++;

    /* Find end of font name */
    for (name = in; *in != ' ' ; in++) ;
    displaced = *in;
    *in = '\0';

    /* Get point size, and maybe width */
    end = wr_draw_text_getNum(in + 1, &pointVal);
    scaleSize  = (int)((pointVal * 16) * wr_dr_scalefactor_y);
    if (isdigit(*end))
    {
        end = wr_draw_text_getNum(end, &pointVal);
        scaleWidth = (int)((pointVal * 16) * wr_dr_scalefactor_x);
    }
    else
        scaleWidth = scaleSize;

#ifdef EASI
    if (wr_font_find(name, scaleWidth, scaleSize, 0, 0, &fontHandle) == 0 && fontHandle != 0)
#else
    if (FontFind(&fontHandle, name, scaleWidth, scaleSize) == 0 && fontHandle != 0)
#endif
    {
        /* Record font reference, handle and size */
        fonts[fontNumber] = fontHandle;
        wr_draw_usedFont[fontHandle] += 1;
    }
    else
    {
        fonts[fontNumber] = -1;
    }

    *in = displaced;
    return end + 1;   /* the + 1 is to skip over / or \n */
}

/* Colour handling SWIs */
#define SWI_ColourTrans_ReturnFontColour 0x4074e
#define SWI_ColourTrans_SetFontColour    0x4074f
wr_os_error *displ_settruefontcol(font fonth, wr_draw_coltyp foregrd,
                                           wr_draw_coltyp backgrd);

/*
 Function    : wr_draw_text_setColour
 Purpose     : set colour for a given r, g, b value
 Parameters  : r, g, b intensities (as a palette entry, i.e. BBGGRRxx)
               (foreground and background)
 Returns     : void
 Description : selects the best colour for the given font and rgb values.
*/

static void  wr_draw_text_setColour(int colour, int backcolour)
{
#ifdef EASI
    wr_os_regset r;

    r.r[0] = 0;
    r.r[1] = backcolour;
    r.r[2] = colour;
    r.r[3] = 14;

    /* Set the best approximation to the given colours */
    wr_os_swi(SWI_ColourTrans_SetFontColour, &r);
#else
  wr_displ_settruefontcol(0, colour, backcolour);
#endif
}

/*
 Function    : wr_draw_text_setup_colour
 Purpose     : set a gcol for a given r, g, b value
 Parameters  : r, g, b intensities (as a palette entry, i.e. BBGGRRxx)
               (foreground and background)
               pointer into string to place colour sequence at
 Returns     : updated output pointer
 Description : finds the best gcol value for text, and puts this into a colour
               change sequence in the string
*/

static char *wr_draw_text_setup_colour(int colour, int backcolour, char *out)
{
    wr_os_regset r;
    int *ip;

    r.r[0] = 0;
    r.r[1] = backcolour;
    r.r[2] = colour;
    r.r[3] = 14;

    /* Set the best approximation to the given colours */
    wr_os_swi(SWI_ColourTrans_ReturnFontColour, &r);

    r.r[0] = wr_draw_font_colour;
    for (ip = r.r; ip < r.r + 4; )
      *(out++) = *(ip++);
    return out;

#ifdef EASI
    wr_chunk[out++] = wr_draw_font_colour;
    wr_chunk[out++] = (char)(r.r[1] & 0xff);
    wr_chunk[out++] = (char)(r.r[2] & 0xff);
    wr_chunk[out] = (char)(r.r[3] & 0xff);
#endif
}

/* Static variables - used for the forground and background RGB values last
   seen. We need to hold these statically, because both are needed to set a
   colour, and it is not always easy to find the last values. See at the start
   of rendering from the object colours
 */

static wr_draw_coltyp wr_draw_text_fg, wr_draw_text_bg;

/*
 Function    : wr_draw_setVmove
 Purpose     : set vertical move
 Parameters  : buffer pointer
               move in points
 Returns     : updated pointer
*/

static char *wr_draw_setVmove(char *out, int move)
{
    int i;

    move = (move << 8) | wr_draw_font_vmove;
    for (i = 0; i < 4; i++, move >>= 8)
      *(out++) = move;
    return out;

#ifdef EASI
    wr_chunk[out++] = wr_draw_font_vmove;
    wr_chunk[out++] = move & 0xff;
    wr_chunk[out++] = (move & 0xff00) >> 8;
    wr_chunk[out++] = (move & 0xff0000) >> 16;
#endif
}

/*
 Function    : wr_draw_setLMPstate
 Purpose     : set state on L, M and P commands; skip hyphens
 Parameters  : pointer into source string, at L, M or P
               state data
 Returns     : pointer to rest of string
 Description : sets the state on an L, M or P command, either in the original
               string, or when processing the output. Skips hyphens, which can
               appear in output comments.
*/

static char *wr_draw_setLMPstate(char *p, wr_draw_linedata *state)
{
    int i;

    switch (wr_draw_findIndex(*(p++), "LPM"))
    {
        case 0:  /* 'L' */
            p = wr_draw_text_getNum(p, &i);
            state->leading = wr_draw_pointsToFont(i);
            break;

        case 1: /* 'P' */
            p = wr_draw_text_getNum(p, &i);
            state->paraLeading = wr_draw_pointsToFont(i);
            break;

        case 2: /* 'M' */
            p = wr_draw_text_getNum(p, &i);
            state->lmargin = wr_draw_pointsToFont(i);
            p = wr_draw_text_getNum(p, &i);
            state->rmargin = wr_draw_pointsToFont(i);
            break;

        default:  /* Skip hyphen comment terminator */
            break;
    }

    return (p + 1);  /* + 1 to skip - or / or \n */
}

/*
 Function    : wr_draw_text_allocate
 Purpose     : allocate memory for string
 Parameters  : pointer to string
 Returns     : TRUE if memory can be allocated
 Description : this calculates the size of a buffer large enough to hold the
               string that will be generated by get String.

               NO POINT ADDING EXTRA SPACE FOR THINGS THAT ARE SHORTER!
               Only worry about \- and \V, as well as \n at the end of controls
               which should not be regarded as paragraph terminators!

               The size <= number of characters up to \<nl>, <nl><nl>, <nl>\0, \0.
               + total length of numbers in \L sequences
               + total length of numbers in \P sequences
               + total length of numbers in \M sequences
               + number of \V sequences * 2
               + number of \U sequences
               + number of \C sequences * 6 (now RSP)
               + number of \B sequences * 6 (was 2)
               + number of \- sequences
               + space for terminator and initial settings
               
               This does not allow for the string getting broken by a \A --
               but this is hard to test for, because of the initial case.

               Memory is then allocated if the current space is not large
               enough. If not, we don't report an error, but we do return
               FALSE.
*/

static BOOL  wr_draw_text_allocate(char *from)
{
    int  extra = 10     /* terminator, initial colour, underline, vmove */
                    + wr_draw_maxTrailer;
    char *at;
    BOOL getOut = FALSE;
    int ch;

    /* Look for \ and newline */
    at = from;
    while (!getOut)
    {
        at += strcspn(at, "\n\\");
        ch = *(at++);
        if (ch == '\\')
            switch (wr_draw_findIndex(*(at++), "\\;-\nABCDFLMPUV"))
            {
                case wr_draw_ch_U:  /* generates underline + 2, ie. same size or smaller */
                    if (*at == '.')    /* no \n terminator in this case */
                        break;
                case wr_draw_ch_L:  /* generates comment L<>\n ie same size */
                case wr_draw_ch_M:
                case wr_draw_ch_P:
                case wr_draw_ch_B:  /* generates col + 7 bytes, ie. same size or smaller */
                case wr_draw_ch_C:
                case wr_draw_ch_D:  /* no output */
                case wr_draw_ch_F:
                    at += strcspn(at, "\n/") + 1;
                    break;
                case wr_draw_ch_semicolon:  /* comment needs to absorb the final \n */
                    at += strcspn(at, "\n") + 1;
                    break;
                case wr_draw_ch_minus:  /* generates comment - \n, ie 1 larger than source */
                case wr_draw_ch_V:      /* generates vMove + 3, which is 1 more unless -ve */
                    extra += 1;
                    break;
                case wr_draw_ch_newline:
                    getOut = TRUE;
                    break;
            }
        else if (ch != '\n' || (*at == '\n'))  /* \0 or \n\n */
            getOut = TRUE;
    }
#ifdef EASI
    do
    {
        at += strcspn(at, "\n\\");
        if (*at == '\\')
        {
            switch (wr_draw_findIndex(*(++at), "\\;-\nABCDFLMPUV"))
            {
                case wr_draw_ch_L:
                case wr_draw_ch_M:
                case wr_draw_ch_P:
                    extra += 2 + strcspn(at, "\n/");
                    at += strcspn(at, "\n/") + 1;
                    break;
                case wr_draw_ch_B:
                case wr_draw_ch_C:
                    extra += 6; /* RSP [21424] from 2; */
                    at += strcspn(at, "\n/") + 1;
                    break;
                case wr_draw_ch_U:
                    extra += 1;
                    if (*(++at) != '.') at += strcspn(at, "\n/");
                    at += 1;
                    break;
                case wr_draw_ch_minus:
                    extra += 1;
                    at += 1;
                    break;
                case wr_draw_ch_V:
                    extra += 2;
                    if (*(++at) == '-') at += 2; else at += 1;
                    break;
                case wr_draw_ch_newline:
                    getOut = TRUE; break;
            }
        }
        else if (*at == '\n')
        {
            getOut = (*(++at) == '\n');
        }
    } while (*at != '\0' && !getOut);
#endif
    if ((extra = extra + at - from) > wr_chunkLen)
    {
       int flexCode = 0;

        /* Allocate new memory, or extend existing memory, in 1k units */
        wr_chunkLen = ((extra / 1024) + 1) * 1024;

        if (wr_chunk == NULL)
        {
          if (wr_Draw_allocator)
            flexCode = wr_Draw_allocator((void **)&wr_chunk, wr_chunkLen);
        }
        else
        {
          if (wr_Draw_extender)
            flexCode = wr_Draw_extender((void **)&wr_chunk, wr_chunkLen);
        }
        Draw_memoryError = (flexCode == 0);
    }

    return (TRUE);
}


/*
 Function    : wr_draw_text_getString
 Purpose     : get a cleaned string
 Parameters  : pointer to input string
               pointer to font array
               IN/OUT: line state data
 Returns     : pointer to rest of string (NULL on error)
 Description : this takes the string from the current location up to the end
               of the paragraph or to a change in the align and builds a string
               that is closer to what the font manager can handle. Some further
               processing will still be necessary. Sequences that cannot
               immediately be coded up are replaced by font manager comment
               sequences. The output string is terminated by a null character.
               If the break was caused by a paragraph break, the null is
               preceded by a newline.
               The interpretation proceeds as follows:
               1. control characters are deleted, except for tab, which is
                  replaced by a space.
               2. All other characters are copied, except '\', which is
                  interpreted according to the next character, and newline
                  (see below)
               3. \\ is replaced by \
               4. \; .. <newline> is deleted (comment).
               5. \F<digit*><name><space><size><space><width><newline> defines
                  a font. The font reference is recorded in a table, and a
                  font handle generated for it. The handle is logged, so
                  we can lose it later. Both the size and width are in points.
                  The font name may have leading spaces.
               6. \<digit*> inserts a font change sequence.
               7. \L<number><newline> is replaced by a comment containing the
                  number and the newline - the rendition code must look for
                  this to determine the leading.
               8. \V[-]<digit> is replaced by a vertical move sequence, in
                  scaled units.
               9. \Ax sets the align flag. Note that if any characters appear
                  before this, the string is terminated just before it. x = L
                  (left), R (right), C (centre), D (justified both sides).
                  Other characters are ignored; the string is not terminated in
                  this case.
               10. \U<number1><space><number2><newline> starts underlining.
                   \U. (no newline) turns underlining off (so does \U with
                   <number2> = 0)
               11a.\C<numberR><space><numberG><space><numberB><newline>
                 b.\B<numberR><space><numberG><space><numberB><newline>
                   Both of these generate a colour change sequence in the
                   string.
               12. \D<number><newline> is skipped.
               13. \P<number><newline> is treated as for \L.
               14. \- is replaced a comment.
               15. \<newline> forces a line break, but not a paragraph break.
               16. \M<L><spaces><R><newline> replaced by a margin setting
                   comment.
               17. \other: (never occurs - gets weeded out in verify)
               18. newline: before any printable text, this causes a paragraph
                   space to be inserted. In the body of text, a sequence of n
                   newlines cause n-1 paragraph spaces. A single newline is
                   ignored, except that if it is not preceded or followed by
                   a space (or tab), it generates a space in the output.

               Any command may be terminated by '/'. Where the command would
               normally be terminated by a newline, it replaced the newline.

               Note that \ sequences are case sensitive.
               <digit*> is interpreted as a number consisting of either one or
               two digits, depending on whether the character following the
               first digit is numeric or not.

               When there is an error in the font, the previous font persists.
               There is guaranteed to be a least some text in a valid font, as
               a result of the verification. Any characters before the first
               font change are skipped, including newlines; however, we must
               retain all leading, etc. changes. The default font contains -1
               until we see a good font. The last font seen is returned for the
               next default font.
               If the wr_chunk of text gets too long, we force a line break in a
               rather ugly way: this ought never to happen.

               Before the first call, the \! version string must have been
               skipped.

               Those commands which affect only the state data, if they occur
               at the start of a paragraph, are applied here, rather than
               producing anything in the output string.
*/

/* Macro for skipping optional terminator */
#define wr_draw_text_termSkip(match, in) if (*(match) == '/') in += 1

static char *wr_draw_text_getString(char *in, font *fonts, wr_draw_linedata *state)
{
    int  getOut = FALSE;       /* Deep break */
    font currentFont;          /* Last font seen (default initially) */
    int  printing = FALSE;     /* TRUE when a print character seen */
    char *out;                 /* Pointer in output buffer */
    int  ch;
    char *wr_chunkLimit;          /* end, minus a bit for long control seq */

    /* Allocate space for wr_chunk */
    if (!wr_draw_text_allocate(in))
        return (NULL);

    currentFont = state->defaultFont;
    out = wr_chunk + wr_draw_insert;
    wr_chunkLimit = wr_chunk + wr_chunkLen - wr_draw_maxTrailer;

    /* Process end of string, or until we break out */
    while (!getOut && (ch = *(in++)) != 0 && out < wr_chunkLimit)
    {
        if (ch != '\\')
        {
            if (currentFont != -1)  /* Skip chars before first valid font */
            {
                if (ch == '\n')
                {
                    /* Newline - paragraph break if either followed by another
                       newline, or if it is the first printable character */
                    if (!printing || (ch = *(in++)) == '\n')
                    {
                        /* Paragraph termination */
                        *(out++) = ch;
                        getOut = TRUE;
                    }
                    else
                    {
                        /* Newline not preceded or followed by a space generates a space */
                       if (*(out - 1) != ' ' && ch != ' ' && ch != '\t')
                           *(out++) = ' ';
                       in--;
                    }
                }
                else if (ch >= ' ' || (ch == '\t' && (ch = ' ', TRUE)))
                                        /* Ordinary character: copy */
                                        /* or tab -> space and copy */
                { 
                  *(out++) = ch;
                  printing = TRUE;
                }
            }
            /* else skip other controls */
        }
        else                                        /* \ -> special sequence */
        {
            ch = *(in++);
            /* clauses ending in 'break' still need to test for a '/', while those
               ending in 'continue' have already stepped in past the terminator */
            switch (wr_draw_findIndex(ch, "\\;-\nABCDFLMPUV"))
            {
                case wr_draw_ch_backSlash:                   /* \\ : replace by \ */
                    if (currentFont != -1)
                    { 
                       *(out++) = ch;
                       printing = TRUE;
                    }
                    break;
                case wr_draw_ch_semicolon:                   /* \; : delete to newline */
                    while (*(in++) != '\n') ;
                    continue;
                case wr_draw_ch_minus:                       /* \-: soft hyphen */
                    *(out++) = wr_draw_font_comment;
                    *(out++) = '-';
                    *(out++) = '\n';
                    break;
                case wr_draw_ch_newline:                      /* \<nl> : split string */
                    getOut = TRUE;
                    break;
                case wr_draw_ch_A:       /* \A : align sequence; maybe break string */
                {
                    /* If we have done any output, break on an align */
                    if (printing)
                    {
                        /* Step back over \A sequence */
                        in -= 2;
                        getOut = TRUE;
                        continue;
                    }
                    /* Get align code */
                    state->align = wr_draw_findIndex(*(in++), "LRCD");
                    /* L = alignLeft, R = alignRight, C = alignCentre, D = alignDouble */
                    break;  
                }
                case wr_draw_ch_B:
                case wr_draw_ch_C:                           /* \B, \C: colour change */
                    {
                        int rgb[3];
                        int *col;
                        int res;

                        sscanf(in, "%d %d %d", rgb, rgb + 1, rgb + 2);

                        res = 0;
                        for (col = rgb + 2; col >= rgb; col--)  /* b, g then r */
                          res = (res << 8) + MinMax(0, *col, 255);  /* build up 00bbggrr */
                        res = res << 8;

                        if (ch == 'C')
                            wr_draw_text_fg = res;
                        else
                            wr_draw_text_bg = res;

                        if (gWimpVersion < 316)
                        {
                          out = wr_draw_text_setup_colour(wr_draw_text_fg, wr_draw_text_bg, out);
                        }
                        else  /* RSP [21424] */
                        {
                          /* use true colour sequence type 19, r, g, b, R, G, B, max(14) */
                          memcpy(out + 3, &wr_draw_text_fg, 4);
                          out = (char *)memcpy(out, &wr_draw_text_bg, 4);
                          *out = wr_draw_true_font_colour;
                          *(out + 7) = 14;  /* anti alias range */
                          out += 8;
                        }
                    }
                    /* run on to scan for term / or nl */
                case wr_draw_ch_D:
                    in = strpbrk(in, "\n/") + 1;
                    continue;
                case wr_draw_ch_F:                     /* \F : handle font definition */
                    in = wr_draw_text_setFont(in, fonts);
                    continue;
                case wr_draw_ch_L:
                case wr_draw_ch_M:
                case wr_draw_ch_P:               /* \L, \P, \M */
                    in--;
                    if (printing)
                    {
                        *(out++) = wr_draw_font_comment;
                        while (!isTerm(*in))
                             *(out++) = *in++;
                        *(out++) = '\n';
                    }
                    else
                    {
                        in = wr_draw_setLMPstate(in, state);
                    }
                    continue;
                case wr_draw_ch_U:                   /* \U : start or end underlining */
                    /* Output underline sequence */
                    *(out++) = wr_draw_font_underline;
                    if (*in != '.')
                    {
                        int shift, thick;

                        /* Fetch two number from string */
                        sscanf(in, "%d %d", &shift, &thick);
                        in = strpbrk(in, "\n/") + 1;

                        /* RSP: shift = scaleupYY(shift);
                        thick = scaleupYY(thick); NB scaling the font
                                          size is all that is needed */

                        *(out++) = MinMax(-128, shift, 127);
                        *(out++) = MinMax(0, thick, 255);
                        continue;
                    }
                    /* Turn underlining off */
                    *(out++) = 0;
                    *(out++) = 0;
                    in++;
                    break;
                case wr_draw_ch_V:                              /* \V : vertical move */
                {
                    int sign = 1000;    /* sign and conversion factor */
                    int points;

                    ch = *(in++);
                    if (ch == '-')
                    {
                        sign = -1000;
                        ch = *(in++);
                    }
                    points = scaleupYY((ch - '0') * sign);
                    out = wr_draw_setVmove(out, points);
                    break;
                }
                default:
                    if (!isdigit(ch))
                        continue;
                    {
                        int fontNumber;
                        in = wr_draw_text_getFontNum(in - 1, &fontNumber);

                        /* \<number> : font selection */
                        if (fonts[fontNumber] != -1)
                        {
                            if (currentFont == -1 || !printing)
                            {
                                currentFont = fonts[fontNumber];
                                if (wr_font_setfont(currentFont) != NULL)
                                    return (NULL);
                            }
                            else
                            {   /* Font change sequence */
                                *(out++) = wr_draw_font_setfont;
                                *(out++) = currentFont = fonts[fontNumber];
                            }
                        }
                        /* else:  Bad font: no change */
                    }
                    break;
            }
            if (*in == '/')
                in++;
        }
    }

    *out = '\0';
    state->defaultFont = currentFont;
    return (in);
}

/*
 Function    : wr_draw_text_getLine
 Purpose     : extract an output line of text from a wr_chunk
 Parameters  : offset into wr_chunk
               error block pointer
               scaled max. width
               OUT: actual width (scaled)
               OUT: character displaced from split location
 Returns     : offset to rest of wr_chunk (-1 on error)
 Description : a split location for the line is found.

               Try to split at a space; if this is not possible, we allow
               splitting at any character. Then we backspace from the given
               position, to a soft hyphen, if any, and split there. The scan
               back stops at the start of the string or at a preceding space.
              
               When we use a hyphen, a hyphen character is written over the 
               comment character, and a null placed over the character that
               follows it. The displaced character is then returned
               as the comment character. The code that restores the displaced
               character must make special allowance for this.
*/

static int  wr_draw_text_getLine(offset, error, width, trueWidth, displaced)
    int      offset;
    wr_os_error **error;
    int      width;
    int      *trueWidth;
    char     *displaced;
{
    wr_font_string fs;
    int         next = -1;
    int         i, space, hyphen, term;

    /* Width may be too small: produce a null string */
    if (width <= 0)
    {
        *displaced = wr_chunk[offset];
        wr_chunk[offset] = '\0';
        return (0);
    }

    /* Find where to split string */
    fs.x     = width;
    fs.y     = wr_draw_bigvalue;
    fs.split = 32;
    fs.term  = wr_draw_bigvalue;
    fs.s     = wr_chunk + offset;

    if ((*error = wr_font_strwidth(&fs)) != NULL)
        return(-1);

    /* Check that we were able to split the string at a space */
    if (fs.term == 0)
    {
        /* Split anywhere */
        fs.x     = width;
        fs.y     = wr_draw_bigvalue;
        fs.split = -1;
        fs.term  = wr_draw_bigvalue;
        fs.s     = wr_chunk + offset;
        if ((*error = wr_font_strwidth(&fs)) != NULL)
            return(-1);
    }

    /* Find hyphenation location, unless whole word fits */
    if (wr_chunk[term = offset + fs.term] != '\n' && wr_chunk[term] != '\0')
    {
        for (i = space = hyphen = offset ; i < term ; )
        {
            switch (wr_chunk[i])
            {
                case wr_draw_font_setfont: i += 2; break;
                case wr_draw_font_vmove: case wr_draw_font_colour: i += 4; break;
                case wr_draw_true_font_colour: i += 8 /* RSP [21424] */; break;
                case wr_draw_font_underline: i += 3; break;
                case wr_draw_font_comment:
                   if (wr_chunk[i+1] != '-')
                   {
                       while (wr_chunk[i++] != '\n');
                   }
                   else
                   {
                       hyphen = i;
                       i += 2;
                   }
                   break;
               case ' ': space = i++; break;
               default : i += 1; break;
           }
        }

        if (hyphen > offset && hyphen > space)
        {
            /* Insert the hyphen, and set the special displaced character */
            wr_chunk[hyphen] = '-';
            next = hyphen + 1;
            *displaced  = wr_draw_font_comment;
            wr_chunk[next] = '\0';

            /* Recalculate true width */
            fs.x     = width;
            fs.y     = wr_draw_bigvalue;
            fs.split = -1;
            fs.term  = wr_draw_bigvalue;
            fs.s     = wr_chunk + offset;
            if ((*error = wr_font_strwidth(&fs)) != NULL)  return (-1);
            term = offset + fs.term;
        }
    }

    /* Break at the termination location, if we didn't hyphenate */
    if (next == -1)
    {
        /* Backtrack over spaces */
        next = term;
        if (wr_chunk[next] == ' ')
        {
            while (wr_chunk[--next] == ' ') ;
            next += 1;
        }

        /* Split the string */
        *displaced  = wr_chunk[next];
        wr_chunk[next] = '\0';

        /* Recalculate the exact width, if spaces were found */
        if (next != term)
        {
          fs.x     = width;
          fs.y     = wr_draw_bigvalue;
          fs.split = -1;
          fs.term  = wr_draw_bigvalue;
          fs.s     = wr_chunk + offset;
          if ((*error = wr_font_strwidth(&fs)) != NULL)  return (-1);
        }
    }
    *trueWidth = fs.x;

    return (next);
}

/*
 Function    : wr_draw_text_newColumn
 Purpose     : set parameters for a new column
 Parameters  : column pointer
               pointer to bounding box to set (font units)
               OUT: base y location
 Returns     : void
 Description : sets the parameters from the header of the given column.
*/

static void wr_draw_text_newColumn(column, box, basey)
    wr_draw_textcolhdr *column;
    wr_draw_bboxtyp *box;
    int *basey;
{
    wr_draw_bboxtyp *bbox;
    bbox = &(column->bbox);

    box->x0 = wr_draw_drawToFont(bbox->x0);
    box->y0 = wr_draw_drawToFont(bbox->y0);
    box->x1 = wr_draw_drawToFont(bbox->x1);
    *basey = box->y1 = wr_draw_drawToFont(bbox->y1);
}


/*
 Function    : wr_draw_text_paintCheck
 Purpose     : check that text will be painted within a given region
 Parameters  : wr_chunk offset
               y base (unscaled, font units)
               clip box (in font units, no origin shift, scaled)
               region box (in font units, unscaled)
 Returns     : symbolic code (see below)
 Description : finds the string bbox, and makes sure that it does not protrude
               beyond the limits of the given region box. If text overlaps the
               top of the box, we should not render it - however, the font and
               colour changes (etc.) must still be executed. If the text sticks
               out below the bottom of the box, either in position or as a
               result of descenders, we should move to a new column.
               Source level clipping is also carried out here; the x test for
               this is an approximation.

               If the string is empty, we force a move to the next area,
               since we certainly can't plot it in this one.

               The return codes are:
                OK - go ahead with paint
                SKIP - text is too tall to fit in box, or is clipped
                LOW - text is too low: new column needed
*/

#define wr_draw_paint_OK   0
#define wr_draw_paint_SKIP 1
#define wr_draw_paint_LOW  2

static int wr_draw_text_paintCheck(int offset, int y, wr_draw_bboxtyp *clip, wr_draw_bboxtyp *box)
{
    wr_font_info fi;

    /* Check base position is ok, and that the text is non-empty */
    if (y <= box->y0 || strlen(wr_chunk+offset) == 0)
        return (wr_draw_paint_LOW);
    y = scaleupYY(y);

    /* Get a bounding box for the string, and check it against boxes */
    wr_font_stringbbox(wr_chunk+offset, &fi);
    if (fi.miny + y < scaleupYY(box->y0))
        return (wr_draw_paint_LOW);

    if (fi.maxy + y > scaleupYY(box->y1)
        || scaleupXX(box->x1) < clip->x0 || scaleupXX(box->x0) > clip->x1 
        || fi.maxy + y < clip->y0 || fi.miny + y > clip->y1)
    {
        char *t;  /* Text index */

        /* Implement special sequences */
        for (t = wr_chunk + offset ; ; )
        {
            /* int c1, c2, c3; */
            wr_os_regset r;
            int fgbg[2];

            switch (*(t++))
            {
                case '\0':
                    return (wr_draw_paint_SKIP);
                case wr_draw_font_colour:
                   /* c1 = *(t++);
                    c2 = *(t++);
                    c3 = *(t++);
                    wr_font_setcolour(0, c1, c2, c3); */
                    r.r[0] = 0;
                    r.r[1] = *(t++);
                    r.r[2] = *(t++);
                    r.r[3] = *(t++);
                    wr_os_swix(0x40092 /* SetFontColours */, &r);
                    break;
                case wr_draw_font_vmove:
                    t += 3;
                    break;
                case wr_draw_font_comment:
                    while (*(t++) != '\n') ;
                    break;
                case wr_draw_true_font_colour:   /* RSP [21424] */
                    fgbg[0] = 0;
                    memcpy(((char *)&fgbg) + 1, t, 6);
                    wr_draw_text_setColour(fgbg[1] << 8, fgbg[0]);
/*
                    c1 = *(t++);
                    c2 = *(t++);
                    c3 = *(t++);
                    bg = ((((c3 << 8) | c2) << 8) | c1) << 8;
                    c1 = *(t++);
                    c2 = *(t++);
                    c3 = *(t++);
                    fg = ((((c3 << 8) | c2) << 8) | c1) << 8;
                    wr_draw_text_setColour(fg, bg);
*/
                    t += 7;
                    break;
                case wr_draw_font_underline:
                    t += 2;
                    break;
                case wr_draw_font_setfont:
                    wr_font_setfont((font)*(t++));
                    break;
            }
        }
    }
    return (wr_draw_paint_OK);
}

/*
 Function    : wr_draw_text_paint
 Purpose     : paint the current line
 Parameters  : wr_chunk offset
               displaced character from line
               left limit, right limit
               align code
               true width
               x origin
               y location (origin + offset)
 Returns     : os error, or NULL
 Description : the text is plotted with appropriate alignment. Before this is
               done, we measure its bounding box, and it any part of it lies
               outside the given box, then nothing is painted. This is NOT the
               same as the check for a new column -- it is a test that avoids
               problems with redraw. We can be sure that it fits horizontally.
*/

static wr_os_error *wr_draw_text_paint(int offset,
                          char displace,
                          int x0, int x1, 
                          wr_draw_align align,
                          int trueWidth,
                          int orgx, int y)
    /*int  offset;
    char displace;
    int  x0, x1;
    wr_draw_align align;
    int  trueWidth, orgx, y;*/
{
    wr_os_error *err = NULL;
    int      x;
    int      plotType = wr_font_ABS;

    /* Get plot point, allowing for alignment and scaling */
    if (align == alignDouble && displace != '\0' && displace != '\n')
        plotType |= wr_font_JUSTIFY;

    if (align == alignRight)
        x = (int)(wr_dr_scalefactor_x * x1 - trueWidth);
    else if (align == alignCentre)
        x = (int)((wr_dr_scalefactor_x * (x1 + x0) - trueWidth)/2);
    else
    {
        if (plotType & wr_font_JUSTIFY)
        {
            /* Do move for the alignment box */
            wr_bbc_move((int)wr_draw_fontToOS(scaleupX(x1)),
                     (int)wr_draw_fontToOS(y));
        }
        x = scaleupXX(x0);
    }

    /* Paint the text, unless empty. */
    if (wr_chunk[offset])
#ifdef EASI
        err = wr_font_paint(wr_chunk+offset, plotType, orgx+x, y);
#else
        err = FontPaint(wr_chunk+offset, plotType, orgx+x, y);
#endif
    return (err);
}

#ifdef EASI
/*
 Function    : wr_draw_textPatchup
 Purpose     : patchup when exiting wr_draw_textArea
 Parameters  : void
 Returns     : void
 Description : frees the wr_chunk if need be, and releases all the fonts
*/

static void wr_draw_textPatchup()
{
    int  i;

    if (wr_chunk && wr_Draw_freer) wr_Draw_freer((void **) &wr_chunk);

    if (wr_draw_usedFont == 0) 
    {
       wr_draw_usedFont = malloc(256 * sizeof(int));
       for (i = 0; i < 256; i++) wr_draw_usedFont[i] = 0;
    }

    /* Lose all the fonts */
    for (i = 0 ; i < 256 ; i++)
    {
        while (wr_draw_usedFont[i] > 0)
        {
            wr_font_lose((font)i);
            wr_draw_usedFont[i] -= 1;
        }
    }
}
#endif

/*
 Function    : wr_draw_text_stateScan
 Purpose     : scan for state parameters
 Parameters  : pointer to wr_chunk
               start offset in wr_chunk
               end offset in wr_chunk
               pointer to state data block
 Returns     : void
 Description : called after a line has been output to note the state parameters
               that will apply to the next line.
               Affects underline, vertical move, margin and line/paragraph
               spacing state.
*/

static void wr_draw_text_stateScan(int start, int end, wr_draw_linedata *state)
{
    char *p;
    char *q = wr_chunk + end;

    for (p = wr_chunk + start; p < q; )
    {
        switch (*(p++))
        {
            case wr_draw_font_setfont: p++; break;
            case wr_draw_true_font_colour: p += 7 /* RSP [21424] */; break;
            case wr_draw_font_vmove:
                state->vmove += *p + *(p + 1) << 8 + *(p + 2) << 16;
            case wr_draw_font_colour:
                p += 3;
                break;
            case wr_draw_font_underline:
                state->under1 = *(p++);
                state->under2 = *(p++);
                break;
            case wr_draw_font_comment:
                p = wr_draw_setLMPstate(p, state);
                break;
/*          default: do nothing */
        }
    }
}

/*
 Function    : wr_draw_textArea
 Purpose     : create a text area object
 Parameters  : object pointer
               x, y origin (bottom left)
               clipping box in scaled font units
               os error pointer
 Returns     : TRUE if ok
 Description : creates a text area as follows:
               the font tables are initialised, and some other defaults set up.
               Then we draw as much as possible in each column, and continue
               until either the end of the text is reached, or all the columns
               are full.
               Within each column, we grab a wr_chunk, i.e. up to a newline break,
               and then progressively split it into lines, using the font
               manager. When we run out of space for a line, we move to a new
               column, resetting the bounding box and position parameters.
               Newlines at the start of a new column are not output (this
               happens without need for a special case from the way paintCheck
               works).
               When all text has been painted, we lose the fonts.
               A colour change to the given initial colour is inserted before
               the first string.

               On an error, FALSE is returned, with the os error pointer set,
               or with NULL for an internal error.

               Calculations are done throughout in 1/72000 inch units rather
               than draw units.

               Before each physical output line, the vertical move and
               underline must be set up.
*/

static BOOL wr_draw_textArea(wr_draw_objptr hdrptr, int orgx, int orgy, wr_draw_bboxtyp *clip,
                                                                    wr_os_error **error)
{
    int      i, y;
    char     *text;
    wr_os_error *err;
    BOOL     newColumn = FALSE;
    font     fonts[wr_draw_text_maxFonts+1];
    wr_draw_bboxtyp     box;
    wr_draw_textareaend *endptr = wr_draw_text_findEnd(hdrptr);
    wr_draw_textcolhdr  *column = &(hdrptr.textareastrp->column);
    wr_draw_linedata    state;

    /* Find start colours and save them */
    wr_draw_text_fg = endptr->textcolour;
    wr_draw_text_bg = endptr->backcolour;
    if (wr_draw_text_fg == TRANSPARENT)
      wr_draw_text_fg = wr_draw_text_bg;

    /* Set default state data */
    state.defaultFont = -1;
    state.leading     = wr_draw_pointsToFont(10);
    state.paraLeading = wr_draw_pointsToFont(10);
    state.lmargin     = wr_draw_pointsToFont(1);
    state.rmargin     = wr_draw_pointsToFont(1);
    state.align       = alignLeft;
    state.under1      = state.under2 = 0;
    state.vmove       = 0;

    /* Set initial colour */
    wr_draw_text_setColour(wr_draw_text_fg, wr_draw_text_bg);

    /* Some size constants and initial position */
    orgx = wr_draw_drawToFont(orgx);
    orgy = wr_draw_drawToFont(orgy);

    /* Initialise arrays and defaults */
    for (i = 0 ; i <= wr_draw_text_maxFonts; i++)
        fonts[i] = -1;

    /* Point to text and skip ID string (guaranteed present) */
    for (text = &(endptr->text[0]) ; !isTerm(*text) ; text++) ;

    /* Load parameters for first column */
    wr_draw_text_newColumn(column++, &box, &y);

    /* While there is text to process */
    while (*text)
    {
        int  c = wr_draw_insert;        /* Offset in wr_chunk */

        /* Select default font, if any */
        if (state.defaultFont != -1 && 
            (err = wr_font_setfont(state.defaultFont)) != NULL)
        {
            *error = err;
            return (FALSE);
        }

        /* Set up wr_chunk */
        if ((text = wr_draw_text_getString(text, fonts, &state)) == NULL)
        {
            /* Error in wr_chunk: probably too long */
            *error = NULL;
            return (FALSE);
        }

        /* Ensure wr_chunk is not empty */
        if (wr_chunk[c] != '\0' && wr_chunk[c] != '\n')
        {
            int  trueWidth, scaledWidth, x0, x1, next;
            char displaced;

            /* Loop over each line in the wr_chunk */
            while (wr_chunk[c] != '\0' && wr_chunk[c] != '\n')
            {
                /* If necessary, move to a new column */
                if (newColumn)
                {
                    if (column->tag == wr_draw_OBJTEXTCOL)
                    {
                        /* Find new column parameters */
                        wr_draw_text_newColumn(column++, &box, &y);
                        newColumn = FALSE;
                    }
                    else /* No more columns */
                    {
                        return (TRUE);
                    }
                }

                /* Shift the box sides to allow for the margin */
                x0 = box.x0 + state.lmargin;
                x1 = box.x1 - state.rmargin;

                /* Insert the state data into the string (yukky) */
                c -= wr_draw_insert;       /* Guaranteed to be enough room */
                wr_chunk[c]   = wr_draw_font_underline;
                wr_chunk[c+1] = state.under1;
                wr_chunk[c+2] = state.under2;
                wr_draw_setVmove(wr_chunk+c+3, state.vmove);

                /* Get line */
                scaledWidth = scaleupXX(x1 - x0);
                if ((next = wr_draw_text_getLine(c, error, scaledWidth,
                                              &trueWidth, &displaced)) == -1)
                {
                    return (FALSE);
                }

                /* Set new base position */
                y -= state.leading;

                /* Plot if we are still in box (may fail with descenders) */
                switch (wr_draw_text_paintCheck(c, y, clip, &box))
                {
                    case wr_draw_paint_OK:
                    {
                        if (state.defaultFont != -1 &&
                            (err = wr_draw_text_paint(c, displaced, x0, x1,
                                    state.align, trueWidth, orgx, scaleupY(y)))
                             != NULL)
                        {
                            return (FALSE);
                        }
                        /* Fall into skip case */
                    }
                    case wr_draw_paint_SKIP:
                        wr_draw_text_stateScan(c, next, &state);
                        c = (displaced == ' ') ? next + 1 :
                            (displaced == wr_draw_font_comment) ? next + 2 : next;
                        while (wr_chunk[c] == ' ') c++;   /* Skip extra spaces */
                        break;

                    case wr_draw_paint_LOW:
                        newColumn = TRUE;
                        c += wr_draw_insert; /* Teeny fiddle */
                        break;
                }

                /* Restore split character, allowing for hyphens */
                if (displaced == wr_draw_font_comment)
                {
                    wr_chunk[next-1] = wr_draw_font_comment;
                    wr_chunk[next]   = '-';
                }
                else
                    wr_chunk[next] = displaced;

                /* At the end of a paragraph, shift by para leading */
                if (displaced == '\n') y -= state.paraLeading;
            }
        }
        else
        {
            /* wr_chunk is empty - treat it as a null paragraph */
            y -= state.paraLeading;
        }
    }

    *error = NULL;
    return (TRUE);
}

#ifdef EASI
/*
 Function    : wr_draw_verifyTextArea
 Purpose     : check text area definition
 Parameters  : pointer to start
               OUT: error code
               OUT: error location
               OUT: number of columna
 Returns     : TRUE if ok
 Description : check that all special sequences in the object are OK.

               The default font is set to the number of the first font seen.
               If an error occurs, we return immediately - means checking is
               minimal, but avoids a plethora of messages.

               All texts must start with an ID line of the form:
               \! <number><newline>, where <number> is the text area
               version. If the first character is not a backslash, we prepend
               a standard header.

               The only error that is 'non-fatal' is the font warning.

               The text must end with a newline. Ensuring this is so
               simplified some tests later (i.e. no need to test for hitting
               end of the string as well as terminator).
*/

BOOL wr_draw_verifyTextArea(char *text, int *errcode, char **location, int *columns)
{
    char *end;
    font fonts[wr_draw_text_maxFonts+1]; /* Font table: digit->fontHandle */
    int  seenColumns = FALSE;
    int  handle;

    end = text + strlen(text);
    *columns = 1;
    *location = text;

    /* Check ID heading */
    if (*text++ != '\\' || *text++ != '!')
    {
        *errcode = wr_draw_CorruptTextArea;
        return (FALSE);
    }
    else
    {
        int  version = -1, offset;

        if (wr_draw_getNum(0, text, &version, TRUE, &offset) != wr_draw_numOK
            || version != wr_draw_text_VERSION)
        {
            *errcode = wr_draw_TextAreaVersion;
            return (FALSE);
        }
        text += offset;
    }

    /* Ensure clean termination so we don't need to check for null later */
    if (*(end - 1) != '\n')
    {
        *errcode = wr_draw_MissingNewline;
        return (FALSE);
    }

    /* Look for special sequence */
    while (text < end && *(text += strcspn(text, "\\\n")) != '\0')
    {
        if (*text == '\n')
        {
            text    += 1;
            continue;
        }

        *location = text+1;

        switch (*(++text))
        {
            case '-': case '\\':
                text += 1; break;
            case '\n':
                text += 1; break;
            case ';':                                           /* \;: skip */
                while (*text++ != '\n') ;
                break;
            case 'A':               /* \A: must be followed by L, R, C or D */
                if (strchr("LRCD", *(++text)) == NULL)
                {
                    *errcode = wr_draw_BadAlign;
                    return (FALSE);
                }
                if (*(++text) == '/') text += 1;
                break;
            case 'B':
            case 'C':             /* \B or \C followed by three numbers */
            {
                int  i;

                if (wr_draw_getNum (1, text, NULL, FALSE, &i) != wr_draw_numMORE
                    || wr_draw_getNum(i, text, NULL, FALSE, &i) != wr_draw_numMORE
                    || wr_draw_getNum(i, text, NULL, FALSE, &i) != wr_draw_numOK)
                {
                    *errcode = wr_draw_BadTerminator;
                    return (FALSE);
                }
                text += i;
                break;
            }
            case 'D':                             /* \D: get no. of columns */
            {
                if (seenColumns)
                {
                    *errcode = wr_draw_ManyDCommands;
                    return (FALSE);
                }
                else
                {   int i;
                    if (wr_draw_getNum(1, text, columns, FALSE, &i) != wr_draw_numOK)
                    {
                        *errcode = wr_draw_BadTerminator;
                        return (FALSE);
                    }
                    else
                    {
                        seenColumns = TRUE;
                        text += i;
                    }
                }
                break;
            }
            case 'F':                          /* \F: check font definition */
            {
                int fontNum;
                char *fontDefText;

                while (*(++text) == ' ') ;
                text = wr_draw_text_getFontNum(fontDefText = text, &fontNum);
                if (fontNum == -1)
                {
                    *errcode = wr_draw_BadFontNumber;
                    return (FALSE);
                }
                else
                {
                    int  sizeTerm, i;

                    /* Skip to a non-space, i.e. to start of name */
                    while (text < end && *text == ' ') text += 1;

                    /* Look for terminating space, i.e. to end of name */
                    while (text < end && *text != ' ') text += 1;
                    if (*text != ' ')
                    {
                        *errcode = wr_draw_UnexpectedCharacter;
                        return (FALSE);
                    }

                    if ((sizeTerm = wr_draw_getNum(0, text, NULL, FALSE, &i))
                                      == wr_draw_numMORE)
                    {
                        /* Read second number */
                        if (wr_draw_getNum(i, text, NULL, FALSE, &i) !=wr_draw_numOK)
                        {
                            *errcode = wr_draw_BadFontWidth;
                            return (FALSE);
                        }
                    }
                    else if (sizeTerm == wr_draw_numBAD)
                    {
                        *errcode = wr_draw_BadFontSize;
                        return (FALSE);
                    }

                    /* Try to load the font */
                    wr_draw_text_setFont(fontDefText, fonts, &handle);

#ifdef EASI
                    if (handle != -1) wr_font_lose(handle);
#else
                    if (handle != -1) FontLose(handle);
#endif
                    text += i;
                }
                break;
            }
            case 'L': case 'P':  /* \L, \P: must be followed by <number><nl> */
            {
                int  i;

                if (wr_draw_getNum(1, text, NULL, FALSE, &i) != wr_draw_numOK)
                {
                    *errcode = wr_draw_BadTerminator;
                    return (FALSE);
                }
                text += i;
                break;
            }
            case 'M':               /* \M: check numbers */
            {   int i;

                if (wr_draw_getNum(1, text, NULL, FALSE, &i) != wr_draw_numMORE
                    || wr_draw_getNum(i, text, NULL, FALSE, &i) != wr_draw_numOK)
                {
                    *errcode = wr_draw_BadTerminator;
                    return (FALSE);
                }
                text += i;
                break;
            }
            case 'U':               /* \U: \U. or \U<n1><space><n2> */
                if (*(++text) != '.')
                {   int i;

                    if (wr_draw_getNum(0, text, NULL, TRUE, &i) != wr_draw_numMORE
                        || wr_draw_getNum(i, text, NULL, FALSE, &i) != wr_draw_numOK)
                    {
                        *errcode = wr_draw_BadTerminator;
                        return (FALSE);
                    }
                    text += i;
                }
                break;
            case 'V':        /* \V: must be followed by -<digit> or <digit> */
                if (*(++text) == '-') text += 1;
                if (!isdigit(*text++))
                {
                    *errcode = wr_draw_NonDigitV;
                    return (FALSE);
                }
                if (*(++text) == '/') text += 1;
                break;
            default:                               /* \<other>: digits only */
                if (!isdigit(*text))
                {
                    *errcode = wr_draw_BadEscape;
                    return (FALSE);
                }
                else
                {
                    int fontNumber;
                    text = wr_draw_text_getFontNum(text, &fontNumber);
                    if (fontNumber == -1)
                    {
                        *errcode = wr_draw_BadFontNumber;
                        return (FALSE);
                    }
                    if (*text == '/') text += 1;
                }
                break;
        }
    }

    if (*columns < 1)
    {
        *errcode = wr_draw_FewColumns;
        return (FALSE);
    }

    return (TRUE);
}
#endif

/*
 Function    : wr_do_objtextarea
 Purpose     : render a text area object
 Parameters  : header pointer
               x, y origins
               clipping box in data base coordinates
 Returns     : wr_os_error or Null
 Description : draw the object. Clipping is carried out on a line by line
               basis, in the paiting check -- it is most convenient to have the
               clipping box in scaled font units at this point, but without the
               origin shift applied.
*/

wr_os_error *wr_do_objtextarea(wr_draw_objptr hdrptr, int orgx, int orgy,
                                             wr_draw_bboxtyp *clip)
{
    wr_os_error *err;
    int  i;
    int  *p;
    int  usedFonts[256];

    /* Convert clipping box into screen coordinates */
    clip->x0 = scaleupXX(wr_draw_drawToFont(clip->x0));
    clip->y0 = scaleupYY(wr_draw_drawToFont(clip->y0));
    clip->x1 = scaleupXX(wr_draw_drawToFont(clip->x1));
    clip->y1 = scaleupYY(wr_draw_drawToFont(clip->y1));

    wr_chunk = NULL;
    wr_chunkLen = 0;

    wr_draw_usedFont = usedFonts;
    for (p = usedFonts; p < usedFonts + 256; )
        *(p++) = 0;

    wr_draw_textArea(hdrptr, orgx, orgy, clip, &err); /* No error check */

    /* in-line wr_draw_textPatchup() */
    if (wr_chunk && wr_Draw_freer)
        wr_Draw_freer((void **)&wr_chunk);

    /* Lose all the fonts */
    for (i = 0; i < 256; i++)
    {
        int occurances = usedFonts[i];

        while (occurances-- > 0)
#ifdef EASI
            wr_font_lose((font)i);
#else
            FontLose((font)i);
#endif
    }
    wr_draw_usedFont = NULL;
    return(err);
}

/*
 Function    : wr_do_objtextcol
 Purpose     : render a text column object
 Parameters  : header pointer
               x, y origins
               cliiping box in data base coordinates
 Returns     : wr_os_error or Null
 Description : find the parent and render it
*/

wr_os_error *wr_do_objtextcol(wr_draw_objptr hdrptr, int orgx,int orgy, wr_draw_bboxtyp *clip)
{
    return wr_do_objtextarea(wr_draw_text_findParent(hdrptr.textcolp), orgx, orgy, clip);
}

#ifdef EASI
extern BOOL wr_drawtextc_init(void);

extern BOOL wr_drawtextc_init(void)
{
    return ((wr_draw_usedFont = malloc(256*sizeof(int))) !=0);
}
#endif
