/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title:  c.drawCheck
 * Purpose: check a draw file
 * History: IDJ: 06-Feb-92: prepared for source release
 *
 */




/*
 *
 * Checks a Draw file held in a buffer, and reports any problems, with the
 * offset from the start of the buffer. No error is flagged on an unknown
 * object type.
 *
 * The (global) ok flag can indicate no error, recoverable error or fatal
 * error.
 * A fatal error is generally some sort of mistake in an object size.
 * On a fatal error, we return as soon as possible. The returned buffer
 * location need not be sensible.
 *
 * Note that the code here must be changed if there are any changes in the
 * internal structure of an object.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "os.h"
#include "sprite.h"
#include "bbc.h"
#include "font.h"
#include "drawmod.h"
#include "wimpt.h"
#include "trace.h"

#include "h.DrawIntern.drawfile1"
#include "drawferror.h"

/*-------------------------------------------------------------------------*/
/* Common stuff - both shift and check                                     */

/* Types for check/shift functions */
typedef void wr_check_shift_fn(wr_draw_objptr object);

typedef struct
{
    wr_draw_tagtyp  tag;                /* Tag */
    int          sizelow, sizehigh;  /* Bounds on size */
    BOOL         box;                /* Flag - object has a bbox */
    wr_check_shift_fn *fn;              /* Function to call, or NULL */
} wr_check_shift_table;

/* Macro to help declare them */
#define wr_check_shift_fn(name)  void name(wr_draw_objptr object)

/*-------------------------------------------------------------------------*/
/* Code for checking Draw files                                         */

/* Errors are represented as an integer. The type wr_draw_error1 must be made
   consistent with these values; we do not include the header file here, to
   avoid the DrawFile module invading the Draw source
 */
static int wr_errorCode;
static int wr_errorLocation;
#define error(code, at, level) {wr_errorCode = code; wr_errorLocation = (int)at; \
                                wr_check_ok |= level;}

/* Error levels */
#define OK_OK    0
#define OK_ERROR 1
#define OK_FATAL 2

/* Flag for indicating errors */
static int wr_check_ok;

/* 'Infinite' size value */
#define wr_check_BIG (0x7fffffff)

/* Status flags */
static BOOL wr_check_fontSeen, wr_check_textSeen;

/* Forward reference */
wr_draw_objptr wr_check_object(wr_draw_objptr object);

/*
 Function    : wr_check_bbox
 Purpose     : check a bounding box
 Parameters  : bounding box pointer
 Returns     : void
 Description : checks that the coordinate in the box are in the right order.
*/

static int  wr_check_bbox(wr_draw_bboxtyp *box)
{
    if (box->x0 > box->x1 || box->y0 > box->y1)
        /*error(wr_draw_BBoxWrong, (char *)box, OK_ERROR)*/
        return 1;
    else
        return 0;
}

/*
 Function    : wr_check_text
 Purpose     : check a string
 Parameters  : pointer to string
               maximum length
 Returns     : length of string
 Description : check the string for control characters, etc.
*/

static int wr_check_text(char *buffer, int length)
{
    int  i;
    int  c;

    for (i = 0 ; i < length ; i++)
    {
        if (buffer[i] == 0) return (i);

        c = (int)buffer[i];
        if (!((31 < c && c < 127) || (127 < c && c <= 255)))
            error(wr_draw_BadCharacter, buffer, OK_ERROR)
    }

    return (length);
}

/*
 Function    : wr_check_size
 Purpose     : check an object size
 Parameters  : object size
               lower bound
               upper bound (may be 'wr_check_BIG' for any size)
               pointer to location for error report
 Returns     : void
*/

static void wr_check_size(int size, int low, int high, char *where)
{
    if (size < low)
        error(wr_draw_ObjectTooSmall, where, OK_FATAL)
    if (size > high)
        error(wr_draw_ObjectTooLarge, where, OK_FATAL)
    if (size & 3 != 0)
        error(wr_draw_ObjectNotMult4, where, OK_FATAL)
}

/*
 Function    : wr_check_overrun
 Purpose     : check for data overrun
 Parameters  : remaining object size
               pointer to current location for error report
 Returns     : void
 Description :
*/

static void wr_check_overrun(int size, char *where)
{
    if (size < 0)
        error(wr_draw_ObjectOverrun, where, OK_FATAL)
}

/*--------------------------------------------------------------------------*/

/*
 Function    : wr_check_<object>
 Purpose     : general object check routines
 Parameters  : pointer to start of object
 Returns     : void
*/

/* Font table: check we have only one, that it is after text, and that there
   is no rubbish at the end of it
 */

static wr_check_shift_fn(wr_check_fontList)
{
    int fontNum;
    int ptr  = 8;              /* Skip over type and size */
    int size;

    size = object.fontlistp->size;

    if (wr_check_fontSeen)
        error(wr_draw_ManyFontTables, object.bytep, OK_ERROR)
    if (wr_check_textSeen)
        error(wr_draw_LateFontTable, object.bytep, OK_ERROR)

    wr_check_fontSeen = TRUE;

    while (ptr < size)
    {
        if ((fontNum = (int)object.bytep[ptr++]) == 0) break;
        ptr += wr_check_text(object.bytep+ptr, wr_check_BIG);
    }

    wr_check_overrun(size - ptr, object.bytep + ptr);
}

/* Text: check style, text */
static wr_check_shift_fn(wr_check_textObject)
{
    int  ptr;

    wr_check_textSeen = TRUE;

    if (object.textp->textstyle.reserved8 != 0
        || object.textp->textstyle.reserved16 != 0)
        error(wr_draw_BadTextStyle, object.bytep, OK_ERROR)
    ptr = sizeof(wr_draw_textstrhdr) + wr_check_text(object.textp->text, wr_check_BIG);

    wr_check_overrun(object.textp->size - ptr, object.bytep + ptr);
}

/* Path: check elements of path. Must start with move, and have a line or
   curve in it somewhere */
static wr_check_shift_fn(wr_check_pathObject)
{
    path_eleptr path;
    int  extra;
    int  lineSeen = FALSE;

    path.move = wr_address_pathstart(object);

    if (path.move->tag.tag != Draw_PathMOVE)
        error(wr_draw_MoveMissing, object.bytep, OK_ERROR)

    do
    {
        switch (path.move->tag.tag)
        {
            case Draw_PathTERM : break;
            case Draw_PathMOVE : path.bytep += sizeof(path_movestr)  ; break;
            case Draw_PathCLOSE: path.bytep += sizeof(path_closestr) ; break;
            case Draw_PathCURVE: path.bytep += sizeof(path_curvestr);
                                 lineSeen = TRUE; break;
            case Draw_PathLINE : path.bytep += sizeof(path_linestr);
                                 lineSeen = TRUE; break;
            default:
                error(wr_draw_BadPathTag, path.bytep, OK_FATAL)
                return;
        }
    } while (path.move->tag.tag != Draw_PathTERM);

    if (!lineSeen)
        error(wr_draw_NoPathElements, object.bytep, OK_ERROR)

    extra = object.pathp->size - 
                  (path.bytep - object.bytep + sizeof(path_termstr));
    if (extra > 0)
        error(wr_draw_PathExtraData, object.bytep, OK_FATAL)
    else
        wr_check_overrun(extra, path.bytep);
}

/* Sprite: check size (based on minimum size for a sprite definition),
   and sprite header block */
static wr_check_shift_fn(wr_check_spriteObject)
{
    int  spriteSize;

    spriteSize = object.spritep->sprite.next;
    if (object.spritep->size - sizeof(wr_draw_objhdr) < spriteSize)
     error(wr_draw_BadSpriteSize, object.bytep, OK_FATAL)
}

static wr_check_shift_fn(wr_check_groupObject)
{
    char *end;

    end = object.bytep + object.groupp->size;
    object.bytep += sizeof(wr_draw_groustr);

    while ((wr_check_ok & OK_FATAL) == 0 && object.bytep < end)
        object = wr_check_object(object);
}


/* Text column: check size and tag. TRUE if it was a text column */
static BOOL wr_check_textColumn(wr_draw_textcolhdr *column)
{
    if (column->tag == 0) return (FALSE);
    else if ((column->tag & 0xff) != wr_draw_OBJTEXTCOL) /* RSP */
    {
        error(wr_draw_BadTextColumnEnd, column, OK_FATAL)
        return (FALSE);
    }

    wr_check_size(column->size, sizeof(wr_draw_textcolhdr), sizeof(wr_draw_textcolhdr), 
               (char *)column);
    return((wr_check_ok & OK_FATAL) == 0);
}

/* Text area: check size and verify using text column code */
static wr_check_shift_fn(wr_check_textArea)
{
    int  columns, actualColumns;
    wr_draw_objptr column, area;
    int code;
    char *location;

    for (column.textcolp = &(object.textareastrp->column), actualColumns = 0 ;
         wr_check_ok != OK_FATAL && wr_check_textColumn(column.textcolp) ;
         column.bytep += sizeof(wr_draw_textcolhdr), actualColumns += 1) ;

    if (!wr_draw_verifyTextArea(sizeof(wr_draw_textareastrend) + column.bytep,
         &code, &location, &columns) || columns < 1)
     {
       error(code, location, OK_ERROR)
     }
    else if (columns != actualColumns)
    {
        error(wr_draw_ColumnsMismatch, object.bytep, OK_ERROR)
    }
    else /* Ensure reserved words are zero */
    {
        area.bytep = column.bytep;
        if (area.textareaendp->blank1 != 0 || area.textareaendp->blank2 != 0)
            error(wr_draw_NonZeroReserved, object.bytep, OK_ERROR)
    }
}

/*-------------------------------------------------------------------------*/

/*
 Function    : wr_check_fileHeader
 Purpose     : check Draw file header
 Parameters  : object pointer
 Returns     : pointer to object after header
 Description : checks the file header for:
   - not being an Draw file
   - bad version
   - bad bbox
*/

static wr_draw_objptr wr_check_fileHeader(wr_draw_objptr object)
{
    int drawName = 0x77617244;      /* the text 'Draw' as an integer */

    if (object.wordp[0] != drawName)
    {
        error(wr_draw_NotDrawFile, 0, OK_FATAL)
    }
    else
    {
        if (object.filehdrp->majorstamp > majorformatversionstamp)
        {
            error(wr_draw_VersionTooHigh, 0, OK_FATAL)
        }
    }

    object.bytep += sizeof(wr_draw_fileheader);
    return (object);
}

/*
 Data Group  : functions descriptions table
 Description :
*/

static wr_check_shift_table wr_check_functions[] =
{
 {wr_draw_OBJFONTLIST, sizeof(wr_draw_fontliststrhdr), wr_check_BIG, FALSE, 
   wr_check_fontList},
 {wr_draw_OBJTEXT,     sizeof(wr_draw_textstrhdr),     wr_check_BIG, TRUE,
   wr_check_textObject},
 {wr_draw_OBJPATH,     sizeof(wr_draw_pathstrhdr),     wr_check_BIG, TRUE,
   wr_check_pathObject},
 {wr_draw_OBJSPRITE,   sizeof(wr_draw_spristrhdr),     wr_check_BIG, TRUE,
   wr_check_spriteObject},
 {wr_draw_OBJGROUP,    sizeof(wr_draw_groustr),        wr_check_BIG, TRUE,
   wr_check_groupObject},
 {wr_draw_OBJTEXTAREA, sizeof(wr_draw_textareastrhdr), wr_check_BIG, TRUE,
   wr_check_textArea},
 {-1,               0,  0,         FALSE, NULL}
};

#define MAXZOOMFACTOR 8
#define wr_check_draw_text_oneColumn(obj)  \
(*(int *)(obj.bytep + sizeof(wr_draw_textareahdr) + sizeof(wr_draw_textcolhdr)) == 0)

static void wr_check_bound_minmax(int x, int y, wr_draw_bboxtyp *boundp)
{
  if (x < boundp->x0) boundp->x0 = x;
  if (x > boundp->x1) boundp->x1 = x;
  if (y < boundp->y0) boundp->y0 = y;
  if (y > boundp->y1) boundp->y1 = y;
}
 
static wr_os_error *wr_check_draw_displ_font_stringpixbbox(font fonth, char *ptr,
                                        wr_draw_bboxtyp *boundp)
{ wr_os_error *err = 0;
  wr_draw_bboxtyp bound;
  int x,y, x2,y2;

  bound.x0 = bound.y0 = INT_MAX;
  bound.x1 = bound.y1 = INT_MIN;
  x = y = 0;

  while (*ptr)
  { wr_font_info info;
    wr_os_regset r;
 
    err = wr_font_charbbox(fonth, *ptr, wr_font_OSCOORDS, &info);
/*
    err = wr_font_converttoos(x,y, &x2, &y2);
*/
    r.r[1] = x;
    r.r[2] = y;
    wr_os_swix(0x40088 /* wr_font_ConverttoOS */, &r);
    x2 = r.r[1];
    y2 = r.r[2];

    if (x2+info.minx < bound.x0) bound.x0 = x2+info.minx;
    if (y2+info.miny < bound.y0) bound.y0 = y2+info.miny;
    if (x2+info.maxx > bound.x1) bound.x1 = x2+info.maxx;
    if (y2+info.maxy > bound.y1) bound.y1 = y2+info.maxy;

    { wr_font_string fs;
      fs.s = ptr;
      fs.x = fs.y = INT_MAX;   /*?????*/
      fs.split = -1;
      fs.term = 1;

      err = wr_font_strwidth(&fs);

      x += fs.x; y += fs.y;
      ptr++;
    }
  }

  *boundp = bound;
  return(err);
}

static void wr_check_bound_text(wr_draw_objptr object, wr_draw_bboxtyp *bbox)
{
  wr_os_error *err = 0;
  font      fonth;
  char     *text;

  text = &(object.textp->text[0]);

  if(object.textp->textstyle.fontref)
  {
#ifdef EASI
    if (err = wr_font_find("System",
                        MAXZOOMFACTOR*object.textp->fsizex/40,
                        MAXZOOMFACTOR*object.textp->fsizey/40,
                        0,0, &fonth), !err)
#else
    if (err = FontFind(&fonth, "System",
                        MAXZOOMFACTOR*object.textp->fsizex/40,
                        MAXZOOMFACTOR*object.textp->fsizey/40), !err)
#endif
    {
      err = wr_check_draw_displ_font_stringpixbbox(fonth, text, bbox);
#ifdef EASI
      wr_font_lose(fonth);
#else
      FontLose(fonth);
#endif
      if (!err)
      { /* Calculate actual bbox in Draw units */
        bbox->x0 = (bbox->x0 << 8) / MAXZOOMFACTOR + object.textp->coord.x;
        bbox->x1 = (bbox->x1 << 8) / MAXZOOMFACTOR + object.textp->coord.x;
        bbox->y0 = (bbox->y0 << 8) / MAXZOOMFACTOR + object.textp->coord.y;
        bbox->y1 = (bbox->y1 << 8) / MAXZOOMFACTOR + object.textp->coord.y;

        return;
      }
    }
  }

/* Either text is in system font, OR an unfound fancy font (so rendered in  */
/* system font) or some font manager call went bang, so..                   */
/* Return BBox for system font. Assumes character base line is row 7 (of 8) */
/* Calculate actual bbox in Draw units */

  bbox->x0 = object.textp->coord.x;
  bbox->x1 = object.textp->coord.x + object.textp->fsizex*
                                                   strlen(object.textp->text);

  /* Assume char base line is row 7 (of 8) */
  bbox->y1 = object.textp->coord.y + 7*object.textp->fsizey/8;
  bbox->y0 = bbox->y1 - object.textp->fsizey;

  return;
}

static wr_draw_dashstr *wr_draw_obj_dashstart(wr_draw_objptr object)
{
#ifdef EASI
  return (object.pathp->pathstyle.joincapwind & packmask_dashed) ? &object.pathp->data : 0;
#else
  return wr_address_dashstart(object);
#endif
}

static wr_drawmod_pathelemptr wr_draw_obj_pathstart(wr_draw_objptr hdrptr)
{
  wr_drawmod_pathelemptr pathptr;

#ifdef EASI
  if (hdrptr.pathp->pathstyle.joincapwind & packmask_dashed)
    pathptr.wordp =
             &(hdrptr.pathp->data.dashelements[hdrptr.pathp->data.dashcount]);
  else
    pathptr.bytep = (char *)&hdrptr.pathp->data;

#else
  pathptr.bytep = (char *)wr_address_pathstart(hdrptr);
#endif
  return pathptr;
}


extern void wr_displ_unpackpathstyle(wr_draw_objptr hdrptr, wr_draw_jointspec *jspecp);

static void wr_check_draw_displ_unpackpathstyle(wr_draw_objptr hdrptr,
                                wr_drawmod_capjoinspec *jspecp)
{
#ifdef EASI
  wr_draw_pathstyle style = hdrptr.pathp->pathstyle;

  jspecp->join       = (style.joincapwind & packmask_join);
  jspecp->leadcap     = (style.joincapwind & packmask_endcap) >> packshft_endcap;
  jspecp->trailcap   = (style.joincapwind & packmask_startcap) >> packshft_startcap;
  jspecp->reserved8      = 0;
  jspecp->mitrelimit     = 0xA0000; /* Mitre limit=10.0 (postscript default) */
  jspecp->lead_tricap_w  =
  jspecp->trail_tricap_w = style.tricapwid << 4;
  jspecp->lead_tricap_h  =
  jspecp->trail_tricap_h = style.tricaphei << 4;
#else
  wr_displ_unpackpathstyle(hdrptr, (wr_draw_jointspec *)jspecp);
#endif
}


static wr_drawmod_transmat wr_MaxZoomMatrix = { MAXZOOMFACTOR*65536, 0,
                                         0, MAXZOOMFACTOR*65536,
                                         0, 0};

static void wr_check_bound_path(wr_draw_objptr object)
{
 #define FillStyle (fill_PFlatten | fill_PThicken | fill_PFlatten | \
                   fill_FBint | fill_FNonbint | fill_FBext)
  wr_drawmod_line        linestyle;
  wr_drawmod_options     options;
  wr_drawmod_pathelemptr pathptr = wr_draw_obj_pathstart(object);

  /* Set up line style */
  linestyle.flatness     = 200/MAXZOOMFACTOR;
  linestyle.thickness    = object.pathp->pathwidth;
  linestyle.dash_pattern = (wr_drawmod_dashhdr *)wr_draw_obj_dashstart(object);
  wr_check_draw_displ_unpackpathstyle(object, &linestyle.spec);

  /* Set up options to get box */
  options.tag      = tag_box;
  options.data.box = (wr_drawmod_box *)&object.pathp->bbox;

  wr_wimpt_noerr(wr_drawmod_processpath(pathptr, FillStyle, &wr_MaxZoomMatrix,
                                   &linestyle, &options, NULL));

#define RoundUp(i) (int)((double)(i)/MAXZOOMFACTOR+0.5)
  /* Bounding box for path at maximum magnification, so scale down */
  object.pathp->bbox.x0 = RoundUp(object.pathp->bbox.x0);
  object.pathp->bbox.y0 = RoundUp(object.pathp->bbox.y0);
  object.pathp->bbox.x1 = RoundUp(object.pathp->bbox.x1);
  object.pathp->bbox.y1 = RoundUp(object.pathp->bbox.y1);

  /* Zero length paths produce a funny BBox, so merge MoveTo(x,y) into BBox */
  wr_check_bound_minmax(pathptr.move2->x, pathptr.move2->y,
                        &(object.pathp->bbox)); 
}

static void wr_check_bound_objtextcol(wr_draw_objptr object)
{ object=object;}

static void wr_check_bound_objtextarea(wr_draw_objptr object)
{
    wr_draw_textcolhdr *column;
    wr_draw_bboxtyp    *bbox;
    
    /* Point to first column, and get its box */
    column = &(object.textareastrp->column);
    bbox = &(object.textareastrp->bbox);
    bbox->x0 = column->bbox.x0;
    bbox->y0 = column->bbox.y0;
    bbox->x1 = column->bbox.x1;
    bbox->y1 = column->bbox.y1;
  
    /* Form union of boxes */
    while (((++column)->tag & 0xff) == wr_draw_OBJTEXTCOL)  /* RSP */
    {
        if (column->bbox.x0 < bbox->x0) bbox->x0 = column->bbox.x0;
        if (column->bbox.y0 < bbox->y0) bbox->y0 = column->bbox.y0;
        if (column->bbox.x1 > bbox->x1) bbox->x1 = column->bbox.x1;
        if (column->bbox.y1 > bbox->y1) bbox->y1 = column->bbox.y1;
    }
 
        /* Apply a small shift to the box, if there is more than one column */
    if (!wr_check_draw_text_oneColumn(object))
    {
        bbox->x0 -= (36<<8);
        bbox->y0 -= (36<<8);
        bbox->x1 += (36<<8);
        bbox->y1 += (36<<8);
    }
}

static void wr_check_bound_sprite(wr_draw_objptr object)
{
#ifdef WRONG
    ** RSP 16/06/93 do not move origin and unzoom the sprite! **
    int XEigFactor = wr_bbc_modevar(object.spritep->sprite.mode, wr_bbc_XEigFactor);
    int YEigFactor = wr_bbc_modevar(object.spritep->sprite.mode, wr_bbc_YEigFactor);
    int pixsizex = 0x100 << XEigFactor;
    int pixsizey = 0x100 << YEigFactor;

    sprite_id id;
    sprite_info info ;

    id.tag    = sprite_id_addr;
    id.s.addr = &object.spritep->sprite;

    (void)sprite_readsize((sprite_area*)0xFF, /* this op needs no spArea */
                          &id,                /* pass address of sprite  */
                          &info               /* result block            */
                         );

    object.spritep->bbox.x0 = 0;
    object.spritep->bbox.y0 = 0;
    object.spritep->bbox.x1 = pixsizex * info.width;
    object.spritep->bbox.y1 = pixsizey * info.height;
#endif

tracef4("sprite BBox is (%d,%d,%d,%d) \n", object.spritep->bbox.x0,
                                           object.spritep->bbox.y0,
                                           object.spritep->bbox.x1,
                                           object.spritep->bbox.y1
                        );

}


/*
 Function    : wr_check_fix_bbox
 Purpose     : fix up a bounding box
 Parameters  : pointer to object data
 Returns     : void
*/

static void wr_check_fix_bbox(wr_draw_objptr object)
{
  switch(/* object.objhdrp->tag RSP test only the byte */ *object.bytep)
  {
    case wr_draw_OBJTEXT:
      wr_check_bound_text(object, &(object.textp->bbox));
      break;

    case wr_draw_OBJPATH:
      wr_check_bound_path(object);
      break;

    case wr_draw_OBJSPRITE:
      wr_check_bound_sprite(object);
      break;

    case wr_draw_OBJGROUP:
    {  int i;
       int start = sizeof(wr_draw_groustr);
       int limit = object.objhdrp->size;
       wr_draw_objptr objptr;
       wr_draw_bboxtyp bound;

       bound.x0 = bound.y0 = INT_MAX;
       bound.x1 = bound.y1 = INT_MIN;

       for (i = start; i < limit; i += objptr.objhdrp->size)
       {
         objptr.bytep = object.bytep+i;
         wr_check_fix_bbox(objptr);
         wr_check_bound_minmax(objptr.objhdrp->bbox.x0,
                            objptr.objhdrp->bbox.y0, &bound);
         wr_check_bound_minmax(objptr.objhdrp->bbox.x1,
                            objptr.objhdrp->bbox.y1, &bound);
        }

        object.groupp->bbox.x1 = bound.x1;
        object.groupp->bbox.y1 = bound.y1;
        object.groupp->bbox.x0 = bound.x0;
        object.groupp->bbox.y0 = bound.y0;

        break;
    }
  
    case wr_draw_OBJTEXTCOL:
      wr_check_bound_objtextcol(object);
      break;

    case wr_draw_OBJTEXTAREA:
      wr_check_bound_objtextarea(object);
      break;

  }
} 
/*
 Function    : wr_check_object
 Purpose     : check an Draw object
 Parameters  : pointer to object data
 Returns     : pointer to next object
*/

wr_draw_objptr wr_check_object(wr_draw_objptr object)
{
    wr_draw_tagtyp type;
    wr_check_shift_table *c;

    type = /* object.objhdrp->tag RSP */ *object.bytep;

    for (c = wr_check_functions ; c->tag != -1 ; c++)
    {
        if (c->tag == type)
        {
            /* Check size */
            wr_check_size(object.objhdrp->size, c->sizelow, c->sizehigh,
                       object.bytep);
            if (wr_check_ok & OK_FATAL)
                object.bytep = NULL;
            else
            {
                /* Check bbox */
                if (c->box) 
                  if(type == wr_draw_OBJGROUP ||  /* RSP t6 for ArtWorks */
                         wr_check_bbox(&(object.objhdrp->bbox)))
                    wr_check_fix_bbox(object);

                /* Additional checks */
                if (c->fn) (c->fn)(object);
            }
            break;
        }
    }

    object.bytep += object.objhdrp->size;
    return (object);
}

/*
 Function    : wr_check_Draw_object
 Purpose     : check an individual object (for DrawFile module)
 Parameters  : object pointer
               OUT: error code
               OUT: error location
 Returns     : TRUE if object is OK
*/

BOOL wr_check_Draw_object(wr_draw_objptr object, int *code, int *location)
{
    wr_check_fontSeen = wr_check_textSeen = FALSE;
    wr_check_ok       = OK_OK;

    wr_check_object(object);

    if (wr_check_ok == OK_OK)
      return (TRUE);
    else
    {
      *code     = wr_errorCode;
      *location = wr_errorLocation;
      return (FALSE);
    }
}

/*
 Function    : wr_check_Draw_file
 Purpose     : check Draw file (for DrawFile module)
 Parameters  : pointer to buffer
               length of buffer
               OUT: code, location
 Returns     : TRUE if ok
*/

BOOL wr_check_Draw_file(char *buffer, int length, int *code, int *location)
{
    wr_draw_objptr object;
    char *end = buffer + length;

    wr_check_fontSeen = wr_check_textSeen = FALSE;
    wr_check_ok       = OK_OK;
    object.bytep   = buffer;
    object         = wr_check_fileHeader(object);

    while ((wr_check_ok & OK_FATAL) == 0 && object.bytep < end)
        object = wr_check_object(object);

    if (wr_check_ok == OK_OK)
    {
      return (TRUE);
    }
    else
    {
        *code     = wr_errorCode;
        *location = wr_errorLocation - (int)buffer;
        return (FALSE);
    }
}


#ifdef EASI
/*-------------------------------------------------------------------------*/
/* Code for shifting files                                                 */

/* Globals to hold the current base */
static int shift_x, shift_y;

/* Forward reference */
wr_draw_objptr shift_object(wr_draw_objptr object);

/*
 Function    : shift_coord
 Purpose     : shift a coordinate
 Parameters  : pointer to x (y assumed to be 1 word after x)
 Returns     : void
*/

static void shift_coord(int *at)
{
    at[0] += shift_x;
    at[1] += shift_y;
}

/*
 Function    : shift_bbox
 Purpose     : shift a bounding box
 Parameters  : box pointer
 Returns     : void
 Description : shifts each coordinate
*/

static void  shift_bbox(wr_draw_bboxtyp *box)
{
    box->x0 += shift_x;
    box->y0 += shift_y;
    box->x1 += shift_x;
    box->y1 += shift_y;
}

/* Text - shift base location */
static wr_check_shift_fn(shift_textObject)
{
    shift_coord(&(object.textp->coord.x));
}

/* Path: shift each element of path */
static wr_check_shift_fn(shift_pathObject)
{
    path_eleptr path;

    path.move = wr_address_pathstart(object);
    do
    {
        switch (path.move->tag.tag)
        {
            case Draw_PathTERM:
                path.bytep += sizeof(path_termstr); break;
            case Draw_PathMOVE: 
                shift_coord(&(path.move->x)); 
                path.bytep += sizeof(path_movestr); break;
            case Draw_PathLINE:
                shift_coord(&(path.line->x));
                path.bytep += sizeof(path_linestr); break;
            case Draw_PathCLOSE:
                path.bytep += sizeof(path_closestr); break;
            case Draw_PathCURVE:
                shift_coord(&(path.curve->x1));
                shift_coord(&(path.curve->x2));
                shift_coord(&(path.curve->x3));
                path.bytep += sizeof(path_curvestr); break;
        }
    } while (path.move->tag.tag != Draw_PathTERM);
}

/* Group - recurse on contents */
static wr_check_shift_fn(shift_groupObject)
{
    char *end;

    end = object.bytep + object.groupp->size;
    object.bytep += sizeof(wr_draw_groustr);

    while (object.bytep < end)
        object = shift_object(object);
}


/* Text area: shift each column */
static wr_check_shift_fn(shift_textArea)
{
    /* Point to first column */
    for (object.bytep += sizeof(wr_draw_textareahdr) ; 
         /* object.objhdrp->tag RSP */ *object.bytep == wr_draw_OBJTEXTCOL ;
         object.bytep += sizeof(wr_draw_textcolhdr))
    {
        shift_bbox(&(object.textcolp->bbox));
    }
}

/* Functions table - size fields are not used */
static wr_check_shift_table shift_functions[] =
{
 {wr_draw_OBJFONTLIST, 0, 0, FALSE, NULL},
 {wr_draw_OBJTEXT,     0, 0, TRUE,  shift_textObject},
 {wr_draw_OBJPATH,     0, 0, TRUE,  shift_pathObject},
 {wr_draw_OBJSPRITE,   0, 0, TRUE,  NULL},
 {wr_draw_OBJGROUP,    0, 0, TRUE,  shift_groupObject},
 {wr_draw_OBJTEXTAREA, 0, 0, TRUE,  shift_textArea},
 {-1,               0, 0, FALSE, NULL}
};

/*
 Function    : shift_object
 Purpose     : shift an arc draw object
 Parameters  : object pointer
 Returns     : pointer to next object
*/

wr_draw_objptr shift_object(wr_draw_objptr object)
{
    wr_draw_tagtyp type;
    wr_check_shift_table *s;

    type = /* object.objhdrp->tag RSP */ *object.bytep;

    for (s = shift_functions ; s->tag != -1 ; s++)
    {
        if (s->tag == type)
        {
            /* Shift bbox */
            if (s->box) shift_bbox(&(object.objhdrp->bbox));

            /* Additional shifting */
            if (s->fn) (s->fn)(object);
            break;
        }
    }

    object.bytep += object.objhdrp->size;
    return (object);
}

/*
 Function    : shift_Draw_file
 Purpose     : transform all coordinates to a new origin
 Parameters  : pointer to buffer
               buffer length
               x base, y base
 Returns     : void
 Description : this shifts all coordinates in the Draw file held in the
               buffer to the given base. It uses code similar to the checking
               code to follow the structure of the file.
               Assumes the buffer has already been checked.
*/

void shift_Draw_file(char *buffer, int length, int xMove, int yMove)
{
    wr_draw_objptr object;
    char *end = buffer + length;

    shift_x = xMove;
    shift_y = yMove;

    object.bytep = buffer;
    shift_bbox(&object.filehdrp->bbox);    

    object.bytep = buffer + sizeof(wr_draw_fileheader);

    while (object.bytep < end)
        object = shift_object(object);
}
#endif

#include <ctype.h>
#include "h.drawfdiag"
#include "h.DrawIntern.drawfile2"

#define isTerm(c) (c == '\n' || c == '/')
#define wr_draw_text_maxFonts 99
#define wr_draw_numOK    0
#define wr_draw_numBAD   1
#define wr_draw_numMORE 2

/*
 Function    : wr_draw_getNum
 Purpose     : get an unsigned integer out of a string
 Parameters  : offset into string
               pointer to string
               pointer to int (NULL -> no assignment)
               flag: TRUE if negative numbers are allowed
               OUT: updated offset
 Returns     : termination code (see below)
 Description : skip leading space; read an integer, skip trailing space.
               Sets the termination code on the basis of what was read, as
               follows: OK: number read ok, terminator was \n or /
                            (output pointer is character after terminator)
                        BAD: no number could be read, or invalid terminator
                        MORE: number read ok, terminator was another digit
                              (output pointer points to digit)
               The string is accessed via offsets to avoid flex block problems.
*/

static int wr_draw_getNum(int from, char *base, int *to, BOOL negative, int *rest)
{
    char *p = base + from;
    unsigned int ch;
    int valu;

    do
    {
        ch = *(p++);
    }
    while (ch == ' ');                 /* skip spaces */

    if (negative && ch == '-')         /* skip '-' if allowed */
        ch = *(p++);
    else
        negative = FALSE;

    valu = ch - '0';
    if (((unsigned int)valu) >= 10)                    /* is it not a digit? */
        return (wr_draw_numBAD);

    while ((ch = *(p++) - '0') < 10)
        valu = valu * 10 + ch;         /* skip to end of number */
    if (to)
        *to = (negative ? -valu : valu);

    ch += '0';
    while (ch == ' ')
        ch = *(p++);                   /* skip over trailing spaces */

    *rest = (p - base);
    if (ch - '0' < 10)                 /* followed by another number */
    {
        *rest -= 1;
        return (wr_draw_numMORE);
    }
    if (isTerm(ch))                    /* end of line or a / */
        return (wr_draw_numOK);
    return (wr_draw_numBAD);
}

/*
 Function    : wr_draw_verifyTextArea
 Purpose     : check text area definition
 Parameters  : pointer to start
               OUT: error code
               OUT: error location
               OUT: number of columna
 Returns     : TRUE if ok
 Description : check that all special sequences in the object are OK.

               The default font is set to the number of the first font seen.
               If an error occurs, we return immediately - means checking is
               minimal, but avoids a plethora of messages.

               All texts must start with an ID line of the form:
               \! <number><newline>, where <number> is the text area
               version. If the first character is not a backslash, we prepend
               a standard header.

               The only error that is 'non-fatal' is the font warning.

               The text must end with a newline. Ensuring this is so
               simplified some tests later (i.e. no need to test for hitting
               end of the string as well as terminator).
*/

BOOL wr_draw_verifyTextArea(char *text, int *errcode, char **location, int *columns)
{
    char *end;
    int  seenColumns = FALSE;
    int  handle;

    end = text + strlen(text);
    *columns = 1;
    *location = text;

    /* Check ID heading */
    if (*text++ != '\\' || *text++ != '!')
    {
        *errcode = wr_draw_CorruptTextArea;
        return (FALSE);
    }
    else
    {
        int  version = -1, offset;

        if (wr_draw_getNum(0, text, &version, TRUE, &offset) != wr_draw_numOK
            || version != wr_draw_text_VERSION)
        {
            *errcode = wr_draw_TextAreaVersion;
            return (FALSE);
        }
        text += offset;
    }

    /* Ensure clean termination so we don't need to check for null later */
    if (*(end - 1) != '\n')
    {
        *errcode = wr_draw_MissingNewline;
        return (FALSE);
    }

    /* Look for special sequence */
    while (text < end && *(text += strcspn(text, "\\\n")) != '\0')
    {
        if (*text == '\n')
        {
            text    += 1;
            continue;
        }

        *location = text+1;

        switch (*(++text))
        {
            case '-': case '\\':
                text += 1; break;
            case '\n':
                text += 1; break;
            case ';':                                           /* \;: skip */
                while (*text++ != '\n') ;
                break;
            case 'A':               /* \A: must be followed by L, R, C or D */
                if (strchr("LRCD", *(++text)) == NULL)
                {
                    *errcode = wr_draw_BadAlign;
                    return (FALSE);
                }
                if (*(++text) == '/') text += 1;
                break;
            case 'B':
            case 'C':             /* \B or \C followed by three numbers */
            {
                int  i;

                if (wr_draw_getNum (1, text, NULL, FALSE, &i) != wr_draw_numMORE
                    || wr_draw_getNum(i, text, NULL, FALSE, &i) != wr_draw_numMORE
                    || wr_draw_getNum(i, text, NULL, FALSE, &i) != wr_draw_numOK)
                {
                    *errcode = wr_draw_BadTerminator;
                    return (FALSE);
                }
                text += i;
                break;
            }
            case 'D':                             /* \D: get no. of columns */
            {
                if (seenColumns)
                {
                    *errcode = wr_draw_ManyDCommands;
                    return (FALSE);
                }
                else
                {   int i;
                    if (wr_draw_getNum(1, text, columns, FALSE, &i) != wr_draw_numOK)
                    {
                        *errcode = wr_draw_BadTerminator;
                        return (FALSE);
                    }
                    else
                    {
                        seenColumns = TRUE;
                        text += i;
                    }
                }
                break;
            }
            case 'F':                          /* \F: check font definition */
            {

                while (*(++text) == ' ');
                if (!isdigit(*text))
                {
                    *errcode = wr_draw_BadFontNumber;
                    return (FALSE);
                }
                else
                {
                    char *fontName;
                    int  i, size, width;

                    text++;
                    if (isdigit(*text))
                         text++;

                    /* Skip to a non-space, i.e. to start of name */
                    while (*text == ' ')
                         text++;
                    fontName = text;

                    /* Look for terminating space, i.e. to end of name */
                    while (*text != ' ')
                        text++;
                    if (*text != ' ')
                    {
                        *errcode = wr_draw_UnexpectedCharacter;
                        return (FALSE);
                    }
                    switch (wr_draw_getNum(0, text, &size, FALSE, &i))
                    {
                        case wr_draw_numMORE:
                            /* Read second number */
                            if (wr_draw_getNum(i, text, &width, FALSE, &i) == wr_draw_numOK)
                                break;
                            *errcode = wr_draw_BadFontWidth;
                            return (FALSE);
                        case wr_draw_numBAD:
                            *errcode = wr_draw_BadFontSize;
                            return (FALSE);
                        case wr_draw_numOK:
                            width = size;
                            break;
                    }
                    /* Try to load the font - why? */
                    *text = 0;
#ifdef EASI
                    if (wr_font_find(fontName, width * 16, size * 16, 0, 0, &handle) == 0 &&
                                                              handle != 0)
                        wr_font_lose(handle);
#else
                    if (FontFind(&handle, fontName, width * 16, size * 16) == 0 &&
                                                              handle != 0)
                        FontLose(handle);
#endif
                    *text = ' ';   /* replace */
                    text += i;
                }
                break;
            }
            case 'L': case 'P':  /* \L, \P: must be followed by <number><nl> */
            {
                int  i;

                if (wr_draw_getNum(1, text, NULL, FALSE, &i) != wr_draw_numOK)
                {
                    *errcode = wr_draw_BadTerminator;
                    return (FALSE);
                }
                text += i;
                break;
            }
            case 'M':               /* \M: check numbers */
            {   int i;

                if (wr_draw_getNum(1, text, NULL, FALSE, &i) != wr_draw_numMORE
                    || wr_draw_getNum(i, text, NULL, FALSE, &i) != wr_draw_numOK)
                {
                    *errcode = wr_draw_BadTerminator;
                    return (FALSE);
                }
                text += i;
                break;
            }
            case 'U':               /* \U: \U. or \U<n1><space><n2> */
                if (*(++text) != '.')
                {   int i;

                    if (wr_draw_getNum(0, text, NULL, TRUE, &i) != wr_draw_numMORE
                        || wr_draw_getNum(i, text, NULL, FALSE, &i) != wr_draw_numOK)
                    {
                        *errcode = wr_draw_BadTerminator;
                        return (FALSE);
                    }
                    text += i;
                }
                break;
            case 'V':        /* \V: must be followed by -<digit> or <digit> */
                if (*(++text) == '-') text += 1;
                if (!isdigit(*text++))
                {
                    *errcode = wr_draw_NonDigitV;
                    return (FALSE);
                }
                if (*(++text) == '/') text += 1;
                break;
            default:                               /* \<other>: digits only */
                if (!isdigit(*text))
                {
                    *errcode = wr_draw_BadEscape;
                    return (FALSE);
                }
                text++;
                if (isdigit(*text))
                    text++;
                if (*text == '/')
                    text++;
                break;
        }
    }

    if (*columns < 1)
    {
        *errcode = wr_draw_FewColumns;
        return (FALSE);
    }

    return (TRUE);
}
