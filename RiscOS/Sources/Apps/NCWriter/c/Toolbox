/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

// Toolbox routines
// -------------------------------------------------------------------------

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>

#include "swis.h"
#include "kernel.h"

#include "colourtran.h"
#include "visdelay.h"
#include "wimp.h"
#include "os.h"
#include "font.h"
#include "pointer.h"

// hopefully temporary!!
#include "bbc.h"

#include "Toolbox.h"

void DeObscureCursor();

static sprite_area *wr_resspr__area = (sprite_area *) 1; /*defaults to using the wimp sprite pool*/
GrafPtr thePort;
char *gRsrcIndex[26] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static char **gRsrcOptions[26] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static int gVduVars[8];
#ifdef NETWP
    NetVars gNet;
    Rect gSafeArea;
#endif
#ifdef TRACE
static int currentWindow = 0;
#endif

// *************************************************************************
// COORDINATE MANIPULATION FUNCTIONS
// *************************************************************************

#pragma -s1
/* stack checks off */

void AddPt(Point &srcPt, Point &dstPt)
     { dstPt.h += srcPt.h; dstPt.v += srcPt.v; }

// -------------------------------------------------------------------------
void SubPt(Point &srcPt, Point &dstPt)
     { dstPt.h -= srcPt.h; dstPt.v -= srcPt.v; }

// -------------------------------------------------------------------------
void SetPt(Point &pt, Coordinate h, Coordinate v)
     { pt.h = h; pt.v = v; }

// -------------------------------------------------------------------------
bool EqualPt(Point &pt1, Point &pt2)
     { return (pt1.h == pt2.h && pt1.v == pt2.v); }

// -------------------------------------------------------------------------
void SetRect(Rect &r, Coordinate left, Coordinate top, Coordinate right,
                      Coordinate bottom)
     { r.left = left; r.top = top; r.right = right; r.bottom = bottom; }

// -------------------------------------------------------------------------
void ClearRect(Rect &r)
     { r.left = r.top = r.right = r.bottom = 0; }

// -------------------------------------------------------------------------
void OffsetRect(Rect &r, Coordinate dh, Coordinate dv)
     { r.left += dh; r.right += dh; r.top += dv; r.bottom += dv; }

// -------------------------------------------------------------------------
void InsetRect(Rect &r, Coordinate dh, Coordinate dv)
     { r.top += dv; r.bottom -= dv; r.left += dh; r.right -= dh; }

// -------------------------------------------------------------------------
bool PtInRect(Point &pt, Rect &r)
     { return((pt.v >= r.top) && (pt.v < r.bottom) &&
              (pt.h >= r.left) && (pt.h < r.right)); }
// 09/01/91 the '<=' changed to '<'

// -------------------------------------------------------------------------
bool EmptyRect(Rect &r)
     { return (r.right <= r.left || r.bottom <= r.top); }

// -------------------------------------------------------------------------
bool EqualRect(Rect &rectA, Rect &rectB)
     { return (rectA.top == rectB.top && rectA.bottom == rectB.bottom &&
              rectA.left == rectB.left && rectA.right == rectB.right); }

// -------------------------------------------------------------------------
Coordinate LengthRect(Rect &r, VHSelect vhs)
{
/* 21/07/92
   return((r.botRight)->vh[vhs] - (r.topLeft)->vh[vhs]);
*/
   return ((int *)&r)[vhs + 2] - ((int *)&r)[vhs];
}

// -------------------------------------------------------------------------
void Pt2Rect(Point &topleft, Point &botright, Rect &dstRect)
{
   int tlv = topleft.v;
   int brv = botright.v;
   int tlh;
   int brh;

   if (tlv < brv)
   {
     dstRect.top = tlv;
     dstRect.bottom = brv;
   }
   else
   {
     dstRect.top = brv;
     dstRect.bottom = tlv;
   }
   tlh = topleft.h;
   brh = botright.h;
   if (tlh < brh)
   {
     dstRect.left = tlh;
     dstRect.right = brh;
   }
   else
   {
     dstRect.left = brh;
     dstRect.right = tlh;
   }
/* 21/07/92 the above is 16 compared with 24 below
   dstRect.top = (topleft.v < botright.v ? topleft.v : botright.v);
   dstRect.bottom = (topleft.v > botright.v ? topleft.v : botright.v);
   dstRect.left = (topleft.h < botright.h ? topleft.h : botright.h);
   dstRect.right = (topleft.h > botright.h ? topleft.h : botright.h);
*/
}


// -------------------------------------------------------------------------
void UnionRect(Rect &src1, Rect &src2, Rect &dstRect)
{
   dstRect.top = (src1.top < src2.top ? src1.top : src2.top);
   dstRect.left = (src1.left < src2.left ? src1.left : src2.left);
   dstRect.bottom = (src1.bottom > src2.bottom ? src1.bottom : src2.bottom);
   dstRect.right = (src1.right > src2.right ? src1.right : src2.right);

/* 21/07/92
   dstRect.top = Min(src1.top, src2.top);
   dstRect.left = Min(src1.left, src2.left);
   dstRect.bottom = Max(src1.bottom, src2.bottom);
   dstRect.right = Max(src1.right, src2.right);
*/
}


// -------------------------------------------------------------------------
void MoveRect(Rect &dstRect, const Rect &srcRect)
{
   dstRect = srcRect;
}


// -------------------------------------------------------------------------
void PinRect(Rect &r, Point &pt)
{
   if (pt.h < r.left)
      pt.h = r.left;
   else if (pt.h > r.right)
      pt.h = r.right;

   if (pt.v < r.top)
      pt.v = r.top;
   else if (pt.v > r.bottom)
      pt.v = r.bottom;
}


// -------------------------------------------------------------------------
static bool ValidateRect(Rect &dstRect)
{
//   if (dstRect.bottom <= dstRect.top || dstRect.right <= dstRect.left)
   if (EmptyRect(dstRect))
   {
      ClearRect(dstRect);
      return(FALSE);
   }
   return(TRUE);
}

// ----------------------------------------------------------------
bool SectRect(Rect &src1, Rect &src2, Rect &dstRect)
{
   dstRect.top = (src1.top > src2.top ? src1.top : src2.top);
   dstRect.left = (src1.left > src2.left ? src1.left : src2.left);
   dstRect.bottom = (src1.bottom < src2.bottom ? src1.bottom : src2.bottom);
   dstRect.right = (src1.right < src2.right ? src1.right : src2.right);
   return(ValidateRect(dstRect));
}

// ----------------------------------------------------------------
void BoxToQDRect(const wr_wimp_box &box, Rect &rect, int originOffset)
{
  rect.left = OStoQD(box.x0);
  rect.top = -OStoQD(box.y1) + originOffset;
  rect.right = OStoQD(box.x1);
  rect.bottom = -OStoQD(box.y0) + originOffset;
};

// ----------------------------------------------------------------
void QDRectToBox(const Rect &rect, wr_wimp_box &box, int originOffset)
{
  box.x0 = QDtoOS(rect.left);
  box.y0 = -QDtoOS(rect.bottom - originOffset);
  box.x1 = QDtoOS(rect.right);
  box.y1 = -QDtoOS(rect.top - originOffset);
};
#pragma -s0

/* *************************************************************************
// STRING HANDLING FUNCTIONS
// ************************************************************************/

// written in Support.s
//wr_os_error *NumToString(int theNum, char *theStr)
//{
//   return(wr_os_swi3((wr_os_X | OS_ConvertInteger4), theNum, int(theStr), 254));
//}


void StringToNum(char *theStr, int &theNum)
{
   sscanf(theStr, "%d", &theNum);
}

// *************************************************************************
// new object handler
// *************************************************************************

extern PFVV _new_handler = 0;

extern void *operator new(long size)
{
  void *p;

  while ((p = NewHandle(unsigned(size))) == NULL )
  {
    if(_new_handler)
      (*_new_handler)();          // we need to avoid recursion!!!
    else
    {
#ifdef TRACE
      wr_werr(FALSE, "Newhandle cannot get %d bytes", size);
#endif
      return NULL;
    }
  }
#ifdef ZERO_OBJ
  return memset(p, 0, size);        // 06/09/90 clear whole object
#else
  return p;
#endif
}

extern PFVV set_new_handler(PFVV handler)
{
  PFVV rr = _new_handler;
  _new_handler = handler;
  return rr;
}

extern void operator delete(void *p)
{
  DisposIfHandle(p);
}

// -------------------------------------------------------------------------
int DrawAlloc(void **anchor, int n)
{
  *anchor = NewHandle(n);
  return (MemError() == noErr);
}


int DrawExtend(void **anchor, int n)
{
  SetHandleSize(anchor, n);
  return (MemError() == noErr);
}


void DrawFree(void ** anchor)
{
  ClearHandle(anchor);
}


// *************************************************************************
// SCREEN MEASUREMENT ROUTINES
// *************************************************************************

// 25/05/90 - find the eigen values for a given mode
// -------------------------------------------------------------------------
void SetSpriteSize(wr_os_regset *r, int *spritesize)
{
  // on entry registers are as set by wr_wimp_spriteop;
  // r6 is mode, r3 is x size, r4 is y size
  wr_os_regset r1;

  r1.r[0] = r->r[6];
  for (int i = 0; i <= 1; i++)
  {
    r1.r[1] = i + 4;           /* 4 for x-eig, 5 for y-eig values */
    wr_wimpt_noerr(wr_os_swix(OS_ReadModeVariable, &r1));
    spritesize[i] = r->r[i + 3] << r1.r[2];
  }
}


// ----------------------------------------------------------------
// measure the current size of the screen

void ResetModeVariables()
{
   gVduVars[0] = 11;   // screen x
   gVduVars[1] = 12;   // screen y
   gVduVars[2] = 4;    // x-eigen
   gVduVars[3] = 5;    // y-eigen
   gVduVars[4] = 3;    // NColour
   //   gVduVars[5] = 10;   // Log2BPC
   gVduVars[5] = -1;   // terminator

   wr_wimpt_noerr(wr_os_swi2(OS_ReadVduVariables | wr_os_X,
                                      (int)gVduVars, (int)gVduVars));
   //   gVduVars[8] = gVduVars[5];             // 30/11/95 read Log2BPC
   gVduVars[5] = (gVduVars[1] + 1) << gVduVars[3];  // 21/07/92 quick access to ScreenHeight
   gVduVars[6] = gVduVars[2] + 2;  // 06/07/95 2 extra QD eigen values
   gVduVars[7] = gVduVars[3] + 2;
#ifdef NETWP
   // ModeFiles_MonitorType (SWI &4D480)
   // ----------------------------------

   // Read the current monitor type.
   // On entry
   //         R0 = 0 (flags)
   // On exit
   //         R0 = monitor type
   //                 0 = PAL
   //                 3 = VGA
   //                 8 = NTSC

   // ModeFiles_SafeArea (SWI &4D481)
   // -------------------------------

   // Read the safe area of the current mode based on the display type.
   // On entry
   //         R0 = 0 (flags)
   // On exit
   //         R0 = x min (in OS units)
   //         R1 = y min (in OS units)
   //         R2 = x max (in OS units)
   //         R3 = y max (in OS units)

   {
#define OS_Pointer 0x64
#define ModeFiles_SafeArea 0x4D481
     wr_os_regset r1;

     r1.r[0] = 0;
     if (wr_os_swix(ModeFiles_SafeArea, &r1) != NULL)
        SetRect(gSafeArea, 0, 0, ScreenWidth(), ScreenHeight());
     else
        BoxToQDRect(*((wr_wimp_box *)r1.r), gSafeArea, ScreenHeight());

     if (gNet.TV != 1)   // read 'real' versions of pointer and tv
     {
        // read interlace bit
        r1.r[0] = -1;
        r1.r[1] = 0;
        wr_wimpt_noerr(wr_os_swix(OS_ReadModeVariable, &r1));
        gNet.TV = r1.r[2] & 0x100;          // ... to control anti-twitter

        // see if mouse present
        //if (gNet.WimpVsn <= 366 || wr_os_swi1r(OS_Pointer | wr_os_X, 2, &gNet.Pointer) != NULL)
        // gNet.Pointer = 2;
     }
   }
#endif
}

// ----------------------------------------------------------------
static int ScreenDimension(int inc)
{
   return (gVduVars[inc] + 1) << gVduVars[inc + 6];   // use gV[6/7] rather than OStoQD
}

// ----------------------------------------------------------------
int ScreenWidth()
{
  return ScreenDimension(0);
}

// ----------------------------------------------------------------
int ScreenHeight()
{
  return ScreenDimension(1);
}

// ----------------------------------------------------------------
int GetVLineThickness()
{
  return OStoQD(1) << gVduVars[2];
}

// ----------------------------------------------------------------
int GetHLineThickness()
{
  return OStoQD(1) << gVduVars[3];
}

// ----------------------------------------------------------------
void OStoQDPt3(Point &aPoint, int xCoord, int yCoord)
{
  SetPt(aPoint, OStoQD(xCoord), OStoQD(gVduVars[5] - yCoord));
}

// ----------------------------------------------------------------
void QDPttoOS3(Point &aPoint, int &xCoord, int &yCoord)
{
  xCoord = QDtoOS(aPoint.h);
  yCoord = gVduVars[5] - QDtoOS(aPoint.v);
}

// ----------------------------------------------------------------
int RoundToPixel(int coord, VHSelect vhs)
{
  int eig = gVduVars[3 - vhs];

  return ((coord + (1 << eig) - 1) >> eig) << eig;
}

// ----------------------------------------------------------------
int TruncateToPixel(int coord, VHSelect vhs)
{
  int eig = gVduVars[3 - vhs];

  return (coord >> eig) << eig;
}

// *************************************************************************
// GRAFPORT MANAGEMENT ROUTINES
// *************************************************************************

void GrafPort::SetUp(wr_wimp_wind *window, int userRef)
{
  memset((char *)this + 4, 0, sizeof(GrafPort) - 4);
  // for (int i = 4; i < sizeof(GrafPort) - 4; i++)
  //   *(((char *)this) + i) = 0;
  // fXOrigin = 0;
  // fYOrigin = 0;
  fWindowRef = userRef;
  // fHasCaret = FALSE;
  // fInDrawing = FALSE;
  // fMinWorkAreaSize.h = 0;
  // fMinWorkAreaSize.v = 0;
  // copy box, x and y offsets and flags
  if (window != NULL)
  {
     fWindowShown = (window->flags & wr_wimp_REDRAW_OK) != 0;  // 21/06/90
     memcpy(&fWindowInfo.o.box, window, 32);
     fWindowInfo.o.behind = -1;   // i.e. open on top
     // clear the reserved flags and those created dynamically
     fWindowInfo.flags &= 0xff001fff;
     memcpy(&fClipBox, window, sizeof(wr_wimp_box));
     BoxToQDRect(window->ex, fWorkAreaRect, 0);
     SetQD();
     SetQDClip();

     theBackColour = window->colours[wr_wimp_WCWKAREABACK];
     if (theBackColour == 255)
       theBackColour = window->colours[wr_wimp_WCWKAREAFORE];
  }
  else // printer port
  {
    // theBackColour = kWhite; // always use white, whatever the window says
    fWindowShown = TRUE; // safe value?
  }
}


#pragma -s1
/* stack checks off */
void GrafPort::LocalToGlobal(Point &pt)
{
  pt.h += OStoQD(fWindowInfo.o.box.x0) - fXOrigin;
//  pt.v += ScreenHeight() - OStoQD(fWindowInfo.o.box.y1) - fYOrigin;
  pt.v += OStoQD(gVduVars[5] - fWindowInfo.o.box.y1) - fYOrigin;
}

void GrafPort::GlobalToLocal(Point &pt)
{
  pt.h += fXOrigin - OStoQD(fWindowInfo.o.box.x0);
//  pt.v += fYOrigin - ScreenHeight() + OStoQD(fWindowInfo.o.box.y1);
  pt.v += fYOrigin + OStoQD(fWindowInfo.o.box.y1 - gVduVars[5]);
}

void GrafPort::LocalToBox(Rect &r, wr_wimp_box &box)
{
  box.x0 = QDtoOS(r.left - fXOrigin) + fWindowInfo.o.box.x0;
  box.y0 = -QDtoOS(r.bottom - fYOrigin) + fWindowInfo.o.box.y1;
  box.x1 = QDtoOS(r.right - fXOrigin) + fWindowInfo.o.box.x0;
  box.y1 = -QDtoOS(r.top - fYOrigin) + fWindowInfo.o.box.y1;
}

void GrafPort::SetRedrawStr(wr_wimp_redrawstr *r)
{
  fWindowShown = TRUE;  // once set, stays set. Now do not ignore InvalRects
  fWindowInfo.o.x = r->scx;    // ????
  fWindowInfo.o.y = r->scy;
  fClipBox = r->g;
  SetQDClip();  // reset clip rect in port
}

// call after a change to the OS view of the port
void GrafPort::SetQD()
{
  BoxToQDRect(fWindowInfo.o.box, fPortRect, ScreenHeight());
  OffsetRect(fPortRect, fXOrigin - fPortRect.left, fYOrigin - fPortRect.top);
}

void GrafPort::SetQDClip()
{
#ifdef NEVER
  BoxToQDRect(fClipBox, fClipRect, ScreenHeight());
  GlobalToLocal(*fClipRect.topLeft);
  GlobalToLocal(*fClipRect.botRight);
#else
  //BoxToQDRect(fClipBox, fClipRect, 0);
  fClipRect.left = OStoQD(fClipBox.x0);
  fClipRect.top = -OStoQD(fClipBox.y1);
  fClipRect.right = OStoQD(fClipBox.x1);
  fClipRect.bottom = -OStoQD(fClipBox.y0);
  OffsetRect(fClipRect, fXOrigin - OStoQD(fWindowInfo.o.box.x0),
                        fYOrigin + OStoQD(fWindowInfo.o.box.y1));
#endif
}

// call after a change to the QuickDraw view of the port
void GrafPort::SetOS()
{
#ifdef TRACE
  if (fPortRect.left != fXOrigin || fPortRect.top != fYOrigin)
    RealSysBeep();
#endif
  LocalToBox(fPortRect, fWindowInfo.o.box);
}

void GrafPort::SetOrigin(int h, int v)
{
  OffsetRect(fPortRect, h - fXOrigin, v - fYOrigin);
  OffsetRect(fClipRect, h - fXOrigin, v - fYOrigin);
  fXOrigin = h;
  fYOrigin = v;
}

/*
void GrafPort::SetZooming()
{
  int xFactor, yFactor;

  // set the font manager's internal scale factor
  wr_wimpt_noerr(wr_font_setscalefactor(40000 / fXZoom, 40000 / fYZoom));

  // use it to reset the draw translation matrix zoom elements
  wr_wimpt_noerr(wr_font_converttoos(0x640000, 0x640000, &xFactor, &yFactor));
  fTransMat[0] = xFactor << 8;
  fTransMat[1] = 0;
  fTransMat[2] = 0;
  fTransMat[3] = -yFactor << 8;

  // set the origin in draw's translation matrix. This doubles up as
  // origin in plotting which does not use the draw module.
  // use the last values set by set origin???
//  wr_font_converttopoints( 0, 1024, &fTransMat[4], &fTransMat[5]); // ???
}

void GrafPort::SetZoomPercentage(int x, int y)
{
  fXZoom = x;
  fYZoom = y;
  SetZooming();
};
*/
#pragma -s0
/* stack checks on */

// ----------------------------------------------------------------
static void SetColourAndMode(int colour, int mode)
{
  // 02/09/96 [27057] do an unsigned test (number of colours is 0xffffffff in 16M colour modes)
  if ((unsigned int)gVduVars[4] >= 63 && mode == 3)
  {
    wr_os_regset r;
    wr_wimp_palettestr palette;
    
    wr_wimpt_noerr(wr_wimp_readpalette(&palette));
    // palette.c[colour].word = (~palette.c[colour].word) & 0xFFFFFF00;
    r.r[0] = (~palette.c[colour].word) & 0xFFFFFF00;
    r.r[3] = 0;
    r.r[4] = mode;       /* GCol action (3) */
    wr_wimpt_noerr(wr_os_swix(0x40743 /*ColourTrans_SetGCOL*/, &r)) ;
    // wr_wimpt_noerr(colourtran_setGCOL(palette.c[colour], 0, mode, &newGcol));
  }
  else
    wr_wimp_setcolour(colour + (mode << 4));
}


// ----------------------------------------------------------------
// Plot at pen position (h, v) in the current
// focussed view. h and v in view coordinates (deci-points)
void GrafPort::PlotCommand(int command, int h, int v)
{
  if ((command & 3) != 0)          // 16/07/93 it is a move
    SetColourAndMode(pnCol, pnMode);

  if((command & 7) < 4)
  {
    wr_wimpt_noerr(wr_os_swi3(OS_Plot | wr_os_X, command, QDtoOS(h), -QDtoOS(v)));  // relative
  }
  else
    wr_wimpt_noerr(wr_os_swi3(OS_Plot | wr_os_X, command,
      QDtoOS(h - fXOrigin) + fWindowInfo.o.box.x0,
     -QDtoOS(v - fYOrigin) + fWindowInfo.o.box.y1));       // absolute position
}

#pragma -s1
/* stack checks off */
// ----------------------------------------------------------------
// 06/07/90 added in work area scroll position
void GrafPort::QDToWorkAreaPt(Point &pt)
{
  pt.h -= (fXOrigin - OStoQD(fWindowInfo.o.x));
  pt.v -= (fYOrigin + OStoQD(fWindowInfo.o.y));
}

// ----------------------------------------------------------------
void GrafPort::WorkAreaToQDPt(Point &pt)
// 06/07/90 added in work area scroll position
{
  pt.h += fXOrigin - OStoQD(fWindowInfo.o.x);
  pt.v += fYOrigin + OStoQD(fWindowInfo.o.y);
}


// convert from screen coordinates to work area for the port
void GrafPort::QDToWorkAreaRect(Rect &r)
{
  QDToWorkAreaPt(*r.topLeft);
  QDToWorkAreaPt(*r.botRight);
}

// ... and vice versa
void GrafPort::WorkAreaToQDRect(Rect &r)
{
  WorkAreaToQDPt(*r.topLeft);
  WorkAreaToQDPt(*r.botRight);
}

void GrafPort::SetClipRect(Rect &clipRect)
{
  SetQDClip();   // 14/07/92 reset fClipRect from wimp redraw info
  SectRect(fClipRect, clipRect, fClipRect);  // 14/07/92
  // 14/07/92 MoveRect(fClipRect, clipRect);

  // 18/03/96 do in Focus: fClipRect.bottom += GetHLineThickness(); 
                 // 07/07/92 let views access following pixel via VisibleRect
}
#pragma -s0
/* stack checks on */

static void DefineGraphicsWindow(wr_wimp_box &box)
{
  char command[9];
  char *cptr = command;

#ifdef TRACE
//  box.x0 = ((((box.x0 >> gVduVars[2]) << gVduVars[8]) & 0xfffffff8) >> gVduVars[8]) << gVduVars[2];
//  box.x1 = (((((box.x1 >> gVduVars[2]) << gVduVars[8]) & 0xfffffff8) >> gVduVars[8]) << gVduVars[2]) - 1;
//  box.y0 = (box.y0 >> gVduVars[3]) << gVduVars[3];
//  box.y1 = ((box.y1 >> gVduVars[3]) << gVduVars[3]) - 1;
#endif

  *(cptr++) = 24; // define graphics window
  for (int i = 0; i < 4; i++)
  {
    unsigned int boxwd = ((unsigned)((int *)&box)[i]);

    *(cptr++) = boxwd & 0xff;
    *(cptr++) = boxwd >> 8;
  }
  wr_wimpt_noerr(wr_os_swi2(OS_WriteN | wr_os_X, (int)command, 9));
}

static int gClipVars[5] = { 128, 129, 130, 131, -1 };
static wr_wimp_box gSavedClip;

#pragma -s1
/* stack checks off */
void GrafPort::SetVDUClip(Rect &clipRect)
{
  wr_wimp_box box;

  if (fWindowRef == 0)
    gSavedClip = fClipBox;  // 24/07/92 for printing
  else
  {
    wr_wimpt_noerr(wr_os_swi2(OS_ReadVduVariables | wr_os_X,
                                      (int)gClipVars, (int)&gSavedClip));
    gSavedClip.x0 <<= gVduVars[2];
    gSavedClip.y0 <<= gVduVars[3];
    gSavedClip.x1 <<= gVduVars[2];
    gSavedClip.y1 <<= gVduVars[3];
  }
  
  LocalToBox(clipRect, box);
//  box.x0 = Max(box.x0, fClipBox.x0);
//  box.y0 = Max(box.y0, fClipBox.y0);
  box.x1 = Min(box.x1, fClipBox.x1 - (fWindowRef == 0 ? 0 : (1 << gVduVars[2])));
  box.y1 = Min(box.y1, fClipBox.y1 - (fWindowRef == 0 ? 0 : (1 << gVduVars[3])));
              // 24/07/92 do not inset by screen pixel when printing ...
              // however need to inset on screen to avoid drawing on menu edges

  // 24/07/92 because of the above inset it is possible to generate an 'inverted' box
  box.x0 = MinMax(fClipBox.x0, box.x0, box.x1);
  box.y0 = MinMax(fClipBox.y0, box.y0, box.y1);
  
  DefineGraphicsWindow(box);
}

// common up the interiors of these two functions
void GrafPort::RestoreVDUClip()
{
  DefineGraphicsWindow(gSavedClip);
}

void GrafPort::SetHugeClip()
// set clipping rect so VisibleRect does not do anything
{
#ifdef NEVER
  if (fInDrawing)  // 14/07/92
    SetQDClip();
  else
    MoveRect(fClipRect, fPortRect);         // not in redraw
#endif
  if (!fInDrawing)
    fClipBox = fWindowInfo.o.box;
  SetQDClip();
}

static void DoRectAction(GrafPort *self, Rect &r)
{
  wr_wimp_box box;
  int width;
  int height;

  self->LocalToBox(r, box);

  // should use Draw routines
  box.x0 = TruncateToPixel(box.x0, h);
  box.y0 = TruncateToPixel(box.y0, v);
  box.x1 = TruncateToPixel(box.x1, h);
  box.y1 = TruncateToPixel(box.y1, v);

  width = box.x1 - box.x0 - 1;
  height = box.y1 - box.y0 - 1;
  if (height >= 0 && width >= 0)
    wr_bbc_rectanglefill(box.x0, box.y0, width, height);
}

void GrafPort::InvertRect(Rect &aRect)
{
  Rect intersect;

//  if (!EmptyRect(aRect))
  if (SectRect(fClipRect, aRect, intersect))
  {
    SetColourAndMode(7 /* black */, 3 /* eor */);

    DoRectAction(this, intersect);       // 28/07/95 [26039] aRect);
  }
}

void GrafPort::LocalToWABox(Rect &rect, wr_wimp_box &box)
{
#ifdef NEVER
  Rect temp;
  int vLt = GetVLineThickness();
  int hLt = GetHLineThickness();

  MoveRect(temp, rect);
  OffsetRect(temp, OStoQD(fWindowInfo.o.x) - fXOrigin,
       -OStoQD(fWindowInfo.o.y) - fYOrigin);
  temp.left -= vLt;
  temp.right += vLt; // 08/10/90 test!!!
  temp.top -= hLt;   // 07/10/90 put back in (see UTextEdit)
  QDRectToBox(temp, box, 0);
#else
  box.x0 = QDtoOS(rect.left - fXOrigin) + fWindowInfo.o.x;
  box.y0 = -QDtoOS(rect.bottom - fYOrigin) + fWindowInfo.o.y;
  box.x1 = QDtoOS(rect.right - fXOrigin) + fWindowInfo.o.x;
  box.y1 = -QDtoOS(rect.top - fYOrigin) + fWindowInfo.o.y;
#endif
}
#pragma -s0
/* stack checks on */

void GrafPort::InvalRect(Rect &badRect)
{
#ifdef TRACE
  if (currentWindow != 0)
  {
    SysBeep(0);
    currentWindow = 0;
  }
//  else
#endif
  if (fWindowShown && !EmptyRect(badRect))
  {
    wr_wimp_redrawstr r;

    LocalToWABox(badRect, r.box);

    // 06/07/92 round out to include border pixels
    r.box.x1 = RoundToPixel(r.box.x1, h);
    r.box.y1 = RoundToPixel(r.box.y1, v);
    r.box.x0 = TruncateToPixel(r.box.x0, h);
    r.box.y0 = TruncateToPixel(r.box.y0, v);

    r.w = GetHandle();
    if (r.w != 0)     // its the print port - someone should have checked before this!
      wr_wimpt_noerr(wr_wimp_force_redraw(&r));
  }
}

#pragma -s1
/* stack checks off */
void GrafPort::ValidRect(Rect &goodRect)
// 14/07/92 new
{
  if (fWindowShown)
  {
    wr_wimp_box box;

    LocalToBox(goodRect, box);
//    LocalToWABox(goodRect, box);

    fClipBox.y1 = box.y0;
    fClipRect.top = goodRect.bottom;
  }
}

void PenNormal()
{
   thePort->BackPat(thePort->BackgroundCol());
   // put setcolour call in inline version
   thePort->PenMode(/*patOr*/ 0);
   PenPat(kBlack);
}

/*
void PenSize(int hSize, int vSize)
{
}
*/

void GrafPort::EraseRect(Rect &r)
{
  Rect intersect;

  if (SectRect(fClipRect, r, intersect))
  {
    wr_wimp_setcolour(bkCol);  // background colour
    DoRectAction(this, intersect);       // 28/07/95 [26039] r);
    wr_wimp_setcolour(pnCol);  // restore colour
  }
}

void GrafPort::FrameRect(Rect &r)
{
  // 11/07/90 - new vsn of framerect (based on one prev. in pictedit)
  wr_wimp_box box;
  wr_os_regset regs;
  Rect intersect;

  // 28/07/95 [26039] Reduce to just outside the window (to handle rects > 32768 os units)
  intersect.top = fPortRect.top - 40;
  intersect.left = fPortRect.left - 40;
  intersect.bottom = fPortRect.bottom + 40;
  intersect.right = fPortRect.right + 40;
  if (SectRect(intersect, r, intersect))
  {
    SetColourAndMode(pnCol, pnMode);

    LocalToBox(intersect, box);
    regs.r[0] = 4;
    regs.r[1] = box.x0;
    regs.r[2] = box.y0;
    wr_os_swix(OS_Plot, &regs);
    regs.r[0] = 5 + 8;
    regs.r[1] = box.x1 - 1;
    wr_os_swix(OS_Plot, &regs);
    regs.r[2] = box.y1 - 1;
    wr_os_swix(OS_Plot, &regs);
    regs.r[1] = box.x0;
    wr_os_swix(OS_Plot, &regs);
    regs.r[2] = box.y0;
    wr_os_swix(OS_Plot, &regs);
  }
}

void GrafPort::PaintRect(Rect &r)
{
  Rect intersect;

  if (SectRect(fClipRect, r, intersect))
  {
    wr_wimp_setcolour(pnCol);  // foreground colour
    DoRectAction(this, intersect);       // 28/07/95 [26039] r);
  }
}

void MoveTo(int h, int v)
  { thePort->MoveTo(h, v); }

// Move the pen position relative to last point by (dh, dv) in the port
void Move(int dh, int dv)
  { thePort->Move(dh, dv); }

// Draw a line to absolute position (h, v). SrcMode ???
void LineTo(int h, int v)
  { thePort->LineTo(h, v); }

// Draw a line relative to last point by (dh, dv) in the
void Line(int dh, int dv)
  { thePort->Line(dh, dv); }

void PenPat(Pattern pat)
{
  thePort->PenPat(pat);
  // xwr_wimp_set_colour(pat);
  wr_wimpt_noerr(wr_wimp_setcolour(pat));
}

void BackPat(Pattern pat)
  { thePort->BackPat(pat); }

void PenMode(int mode)
  { thePort->PenMode(mode); }

void ClipRect(Rect &clipRect)
{
  thePort->SetClipRect(clipRect);
}

void SetOrigin(int h, int v)
{
  thePort->SetOrigin(h, v);
}

void InvertRect(Rect &aRect)
{
  thePort->InvertRect(aRect);
}

void InvalRect(Rect &badRect)
{
  thePort->InvalRect(badRect);
}

void EraseRect(Rect &r)
{
  thePort->EraseRect(r);
}

void FrameRect(Rect &r)
{
  thePort->FrameRect(r);
}

void PaintRect(Rect &r)
{
  thePort->PaintRect(r);
}
#pragma -s0
/* stack checks on */

#ifdef OBS_CURS
static wr_wimp_mousestr gMousePosn;
static char gObscured = FALSE;
static wr_wimp_w gTargetWindow;
#endif

static char *gLastShape = NULL;

void InitCursor()
{
#ifdef OBS_CURS
   gObscured = FALSE;
#endif
   SetCursor(NULL);   // 28/03/93 do gLastShape test:   wr_pointer_reset_shape();
}

char *GetCursor(int rsrcID)
{
   return GetRsrc(rsrcID, 'p');
// 28/03/93 ??   return (temp == NULL ? "ud 1 1" : temp);
}

char *GetLastCursor()
{
   return gLastShape;
}

bool ForceCursor(char *pointerInfo)
{
  char name[12];
  int activeX;
  int activeY;
  sprite_id spr;

  gLastShape = pointerInfo;
  if (pointerInfo == NULL)
    wr_pointer_reset_shape();
  else
  {
    spr.tag = sprite_id_name;
    spr.s.name = name;
    strcpy(name, "ptr_");
    sscanf(pointerInfo, "%s %d %d", &name[4], &activeX, &activeY);
    wr_wimpt_noerr(wr_pointer_set_shape(wr_resspr_area(), &spr, activeX, activeY));
  }
  return TRUE;
}

bool SetCursor(char *pointerInfo)
{
#ifdef OBS_CURS
  CheckObscure();
  if (!gObscured)
#endif
  if (pointerInfo != gLastShape) // 18/12/92
     return ForceCursor(pointerInfo);
  return TRUE;
}

void ObscureCursor()
{
#ifdef OBS_CURS
  // set cursor to hidden & remember its position
  if (!gObscured)
  {
    wr_wimpt_noerr(wr_wimp_get_point_info(&gMousePosn));
    if (gTargetWindow >= 0 && gTargetWindow == gMousePosn.w &&
                                                      gMousePosn.i == -1)
    {
      int x = 0;
      int y = 0;

      wr_wimpt_noerr(wr_os_byte(106, &x, &y));
//      SetCursor("blank 0 0");
      gObscured = TRUE;
    }
  }
#endif
}

void DeObscureCursor()
{
#ifdef OBS_CURS
  if (gObscured)
    InitCursor();
#endif
}

void CheckObscure()
{
#ifdef OBS_CURS
  // restore cursor if position changes
  wr_wimp_mousestr posn;

  if (gObscured)
  {
    wr_wimpt_noerr(wr_wimp_get_point_info(&posn));
    if (memcmp(&posn, &gMousePosn, sizeof(wr_wimp_mousestr)) != 0)
      gObscured = FALSE;
  }
#endif
}

typedef struct {
  short x0, y0, x1, y1;
} ShortBox;

void ConstrainMouseToBox(int x0, int x1, int y0, int y1)
{
  ShortBox margBox;
  char mouseBlock[9];

  margBox.x0 = x0;
  margBox.x1 = x1;
  margBox.y0 = y0;
  margBox.y1 = y1;
  mouseBlock[0] = 1;
  memcpy(&mouseBlock[1], &margBox, 8);
  wr_wimpt_noerr(wr_os_word(21, mouseBlock)); /* mouse box */
}

void HideCursor()
{
  SetCursor("blank 0 0");

  // make the mouse rectangle infinite
  ConstrainMouseToBox(0xffff8000, 0x7fff, 0xffff8000, 0x7fff);
}

void ShowCursor()
{
  // make the mouse rectangle the screen
  ConstrainMouseToBox(0, QDtoOS(ScreenWidth()), 0, gVduVars[5]); // QDtoOS(ScreenHeight()));
  wr_pointer_reset_shape();
}

// *************************************************************************
// WINDOW MANAGEMENT ROUTINES
// *************************************************************************

void WindowRecord::SetOpenStr(wr_wimp_openstr *openStr)
{
  memcpy(&fWindowInfo.o, openStr, sizeof(wr_wimp_openstr));
  SetQD();
}

void WindowRecord::SizeWindow(int width, int height, bool update)
// NB the sizes are for the interior of the window (not including
// the title and scroll bars)
{
  fPortRect.right = fPortRect.left + Min(width,
                           fWorkAreaRect.right - fWorkAreaRect.left);
  fPortRect.bottom = fPortRect.top + Min(height,
                           fWorkAreaRect.bottom - fWorkAreaRect.top);
  SetOS();
  if (update && fWindowInfo.o.w > 0)
    OpenWindow();
}

void WindowRecord::SelectWindow()
{
  fWindowInfo.o.behind = -1;
  OpenWindow();
}

void WindowRecord::GetWindowState()
{
  wr_wimpt_noerr(wr_wimp_get_wind_state(fWindowInfo.o.w, &fWindowInfo));
  SetQD();
}

void WindowRecord::OpenWindow()
{
#ifdef TRACE
  volatile wr_os_error *err;
#endif
  wr_wimpt_noerr(wr_wimp_open_wind(&fWindowInfo.o));
  // set flags from window info
#ifdef TRACE
  if ((err =
#endif
  wr_wimp_get_wind_state(fWindowInfo.o.w, &fWindowInfo)
#ifdef TRACE
          ) != NULL)
    gVduVars[5] /= currentWindow
#endif
  ;
  SetQD();
}

void WindowRecord::CloseWindow()
{
  wr_wimpt_noerr(wr_wimp_close_wind(fWindowInfo.o.w));

  // better to just clear the shown flag??
  wr_wimpt_noerr(wr_wimp_get_wind_state(fWindowInfo.o.w, &fWindowInfo));
}

#ifdef TRACE
bool WindowRecord::IsShown()
{
  return ((fWindowInfo.flags & wr_wimp_WOPEN) != 0);
}
#endif


void WindowRecord::MoveWindow(int screenX, int screenY)
// NB the coordinates are for global bounds (not the work area but the
// window itself, including the title
{
  Rect temp = fPortRect;

  OffsetRect(temp, screenX - fPortRect.left,
                        screenY + GetTitleBarDepth() - fPortRect.top);
  QDRectToBox(temp, fWindowInfo.o.box, ScreenHeight());
}


int WindowRecord::GetScrollBarWidth()
{
  return ((fWindowInfo.flags & wr_wimp_WVSCR) != 0 ?
              OStoQD(kScrollBarWidth) : 0);
}

int WindowRecord::GetTitleBarDepth()
{
  return ((fWindowInfo.flags & wr_wimp_WTITLE) != 0 ?
              OStoQD(kTitleBarDepth) : 0);
}

int WindowRecord::GetScrollBarDepth()
{
  return ((fWindowInfo.flags & wr_wimp_WHSCR) != 0 ?
              OStoQD(kScrollBarDepth) : 0);
}

void WindowRecord::GetTranslation(Point &translation)
{
  SetPt(translation, OStoQD(fWindowInfo.o.x), -OStoQD(fWindowInfo.o.y));
}

void WindowRecord::ResetWorkArea(Rect &extentRect)
{
  wr_wimp_redrawstr r;
  Rect newExtent;
  Rect minExtent;

  MoveRect(newExtent, fPortRect);
  // ensure work extent is not made smaller than current window
  OffsetRect(newExtent, extentRect.left - newExtent.left,
                        extentRect.top - newExtent.top);
  UnionRect(extentRect, newExtent, newExtent);

  // 25/07/90 also ensure work area does not get smaller than minimum
  SetRect(minExtent, 0, 0, fMinWorkAreaSize.h, fMinWorkAreaSize.v);
  OffsetRect(minExtent, extentRect.left, extentRect.top);
  UnionRect(minExtent, newExtent, newExtent);

  if (!EqualRect(newExtent, fWorkAreaRect))
  {
    r.w = fWindowInfo.o.w;
    // 07/03/96 round and truncate when not on pixel boundary, caused box size 1 pixel short
    minExtent.left = TruncateToPixel(newExtent.left, h - 4);
    minExtent.right = minExtent.left + (newExtent.right - newExtent.left);
    minExtent.top = RoundToPixel(newExtent.top, v - 4);
    minExtent.bottom = minExtent.top + (newExtent.bottom - newExtent.top);
    QDRectToBox(minExtent, r.box, 0);

    // round the sizes to nearest pixel
    r.box.x1 = RoundToPixel(r.box.x1, h);
    // 07/03/96    r.box.y1 = RoundToPixel(r.box.y1, v);
    // 07/03/96    r.box.x0 = TruncateToPixel(r.box.x0, h);
    r.box.y0 = TruncateToPixel(r.box.y0, v);
    if (r.w != -1)
      wr_wimpt_noerr(wr_wimp_set_extent(&r));
      // else set up params ready for next open ???
    MoveRect(fWorkAreaRect, newExtent);     // 25/07/90
  }
}
extern int gSender;

void WindowRecord::ResetScroll(Point &newTranslation)
{
  int newX = QDtoOS(newTranslation.h);
  int newY = -QDtoOS(newTranslation.v);

  // if window open and translation changed
  if ((fWindowInfo.flags & wr_wimp_WOPEN) != 0 && 
        (fWindowInfo.o.x != newX || fWindowInfo.o.y != newY))
  {
    GetWindowState();
    fWindowInfo.o.x = newX;
    fWindowInfo.o.y = newY;
    if (gSender == 0)      // 23/10/92 frig!!!!
    OpenWindow();
  }
}

void WindowRecord::SetWorkAreaToWindow()
{
  SetPt(fMinWorkAreaSize, fPortRect.right - fPortRect.left,
                                       fPortRect.bottom - fPortRect.top);
}

void WindowRecord::SetWorkAreaToScreen()
{
  SetPt(fMinWorkAreaSize, ScreenWidth() - GetScrollBarWidth() - (GetVLineThickness() * 2),
       ScreenHeight() - GetTitleBarDepth() - GetScrollBarDepth() - (GetHLineThickness() * 2));
}

void WindowRecord::SetMinWorkArea(Point &minSize)
{
  fMinWorkAreaSize = minSize;
}

// -------------------- Caret Handling Routines ------------------------

#define HIDDEN 0x02000000
void WindowRecord::SaveCaret()
// called at the start of every get rectangle loop
{
  wr_wimp_caretstr caret;
   
  fInDrawing = TRUE;
#ifdef TRACE
  currentWindow = GetHandle();
#endif
  wr_wimpt_noerr(wr_wimp_get_caret_pos(&caret));
  if (caret.w == GetHandle())         // its ours! -> save/hide the caret
    caretHeight = caretHeight | HIDDEN;
}

void WindowRecord::RestoreCaret(bool forceOn)
{
  wr_wimp_caretstr caret;
   
  if (forceOn)
  {
#ifdef TRACE
    currentWindow = 0;
#endif
    fInDrawing = FALSE;
    SetHugeClip();
  }
  wr_wimpt_noerr(wr_wimp_get_caret_pos(&caret));
  if (caret.w == GetHandle() && caret.i == -1)            // its ours!
    if (forceOn || (caretHeight & HIDDEN) == 0)
                                      // end of redraw or it is visible now
    {
      caret.x = caretX;
      caret.y = caretY;
      caret.height = (caretHeight &= ~HIDDEN);
      caret.i = -1;
      caret.index = 0;
      if (caret.height != 0) // 22/05/90 see if this stops invalidating wndw
        wr_wimpt_noerr(wr_wimp_set_caret_pos(&caret));
    }
}

void WindowRecord::LocateCaret(Point &location, int height)
{
  if (height == 0)
  {
    // height = caretHeight & 0xFFFF;     // extract existing size
    height = 1;
    caretHeight &= 0xff000000;
    caretX = -8196;                     // 21/08/90 force off work area
  }
  else   // 09/04/92 set other colour if -ve
  {
    if (height < 0)
    {
      caretHeight = (caretHeight & 0xFF000000) | 0x040a0000;
      height = -height;
    }
    else
      caretHeight &= 0xFB000000;  // set to default colour
    caretX = QDtoOS(location.h - fXOrigin - GetVLineThickness()) + fWindowInfo.o.x;
  }
  // 19/05/91 move caret left
  caretY = -QDtoOS(location.v - fYOrigin - 1) + fWindowInfo.o.y;
  caretHeight |= QDtoOS(height + 3);  // set ht
  RestoreCaret(FALSE);        // if caret is hidden, wait for end of redraw
}

bool WindowRecord::HasInputFocus()
{
  // 05/09/96 [27061] may be wrong if Gain/Lose caret is late: return fHasCaret;

  wr_wimpt_noerr(wr_wimp_get_wind_state(fWindowInfo.o.w, &fWindowInfo));
  return (fWindowInfo.flags & wr_wimp_WFOCUS);
}

#pragma -s1
/* stack checks off */
void WindowRecord::SetCaretStr(wr_wimp_caretstr &caret)
{
   caret.w = GetHandle();
   caret.x = caretX;
   caret.y = caretY;
   caret.height = caretHeight;
   caret.i = -1;
   caret.index = 0;
}
#pragma -s0

void WindowRecord::SetCaret()
 // 30/07/90 force caret on in last place specified,
 // rather than via parameters
{
   wr_wimp_caretstr caret;

   caretHeight &= ~HIDDEN;     // make visible
   SetCaretStr(caret);
   wr_wimpt_noerr(wr_wimp_set_caret_pos(&caret));
}

void WindowRecord::LoseCaret(wr_wimp_caretstr &caretStr)
{
#ifdef OBS_CURS
  gObscured = FALSE;
  gTargetWindow = -1;
#endif
  fHasCaret = FALSE;
}

void WindowRecord::GainCaret(wr_wimp_caretstr &caretStr)
{
#ifdef OBS_CURS
  gObscured = FALSE;
  gTargetWindow = caretStr.w;
#endif
  fHasCaret = TRUE;
}

// *************************************************************************
// MISCELLANEOUS ROUTINES
// *************************************************************************

static char *rsrc_search(int code, char *strings, int idx)
{
   char *next;

   if (strings != NULL)
      for(; next = strings, next += *(strings++), next >= strings; strings = next)
      {
         if (*(strings++) == code && (idx < 0 || *(strings++) == idx))
            return strings;
      }
   return NULL;
}

char *rsrc_next(int code, char *prev)
{
   prev -= 2;
   return rsrc_search(code, prev + *prev, -1);
}

static char *rsrc_lookup1(int code, int type, int idx)
{
   return rsrc_search(code, gRsrcIndex[type - 'a'], idx);
}

char *GetString(int rsrcID)
{
   return GetRsrc(rsrcID, 'c');
}

char *RealGetResource(int rsrcID)
{
   return GetRsrc(rsrcID, 'r');
}

char *GetResourceName(int rsrcID)  // 22/04/94 [21700] new for RealGetResInfo
{
   return GetRsrc(rsrcID, 'q');
}

char *GetRsrcMisc(int code)
{
   return GetRsrc(code, 'x');
}

char *GetRsrcErr(int code)
{
   return GetRsrc(code, 'e');
}

char *GetRsrcOption(int code)
// code 'a' maps to resource o1, ...
{
   code -= 'a';

   if (gRsrcOptions[code] != NULL)
      return *(gRsrcOptions[code]);

   return GetRsrc(code + 1, 'o');
}

void SetRsrcOption(int code, char **newOpt)
// 26/08/94
{
   gRsrcOptions[code - 'a'] = newOpt;
}

char *GetRsrc(int code, int type)
{
   return rsrc_lookup1(code, type, -1);
}

void RealSysBeep()
{
  wr_os_swi0(OS_WriteI + 7 | wr_os_X);
}

/* now in ASM
int TickCount()
{
  wr_os_regset r;

  wr_os_swix(OS_ReadMonotonicTime, &r);
  return r.r[0];
}
*/

char *GetIndString(int rsrcID, int strIndex)
{
   return rsrc_lookup1(rsrcID, 's', strIndex);
}

/* 22/04/94 [21700]
void RealGetResInfo(char *res, char *buff)
{
   char *nPtr = strchr(res, '¤');

   if (nPtr == NULL)
      buff[0] = 0;
   else
      strcpy(buff, nPtr + 1);
}
*/

// ******************** Date / Time ********************
static wr_os_error *ConvertDateTimeFmt(char *fmtStr, char *buffer)
{
   char time[5];
   wr_os_error *err;

   time[0] = 3;   // OS_Word 14,3 - read real time
   wr_wimpt_noerr(wr_os_word(14, time));
   if (fmtStr == NULL)
     fmtStr = "???";
   err = wr_os_swi4(OS_ConvertDateAndTime | wr_os_X,
                                 (int)time, (int)buffer, 254, (int)fmtStr);
   if (err != NULL)
     strcpy(buffer, "???");    // 28/01/92
   return err;
}


wr_os_error *IUTimeString(TimeForm format, char *buffer)
{
   return ConvertDateTimeFmt(GetRsrc(format, 't'), buffer);
}


wr_os_error *IUDateString(DateForm format, char *custom, char *buffer)
{
   if (format != customDate)
      custom = GetRsrc(format, 'd');

   return ConvertDateTimeFmt(custom, buffer);
}

wr_os_error *JSRead(char *name, char *buffer)
{
   wr_os_regset r;
   wr_os_error *err;

   r.r[0] = (int)name;
   r.r[1] = (int)buffer;
   r.r[2] = 254;
   r.r[3] = 0;
   r.r[4] = 3;
   if ((err = wr_os_swix(OS_ReadVarVal, &r)) == NULL)
     buffer[r.r[2]] = 0;
   return err;
}

StringHandle NewString(char *theString)
{
   StringHandle hdl = (theString == NULL ? NULL :         // 17/05/92 allow null param
                        StringHandle(NewHandle(strlen(theString) + 1)));

   return (hdl == NULL ? NULL : StringHandle(strcpy(hdl, theString)));
}

#if TALK == 2
// 15/02/93 [20700] new routines for speech
int gPep = 0;

int Speaking()
{
  int ready;
  wr_os_error *err;

  if (gPep == 2)
  {
    err = wr_os_swi1r(0x0004ad80 | wr_os_X, 0, &ready);
    ready++;
  }
  else
  {
    err = wr_os_swi1r(0x00042B80 | wr_os_X, 0, &ready);

    if (err != 0)
    {
      err = wr_os_swi1r(0x00081785 | wr_os_X, 3, &ready);
      gPep = TRUE;
    }
    else
    {
      ready++;
      gPep = FALSE;
    }
  }
  if (err != 0)
    return -1;
  return ready;
}


void Speak(char *theWord)
{
  if (theWord[0] != 0)
  {
    if (gPep == 2)
      wr_os_swi4(0x0004ad83 | wr_os_X, (int)theWord, 0, 0, 0);
    else if (gPep)
      wr_os_swi3(0x00081780 | wr_os_X, (int)theWord, -13, 0);
    else
      wr_os_swi1(0x00042B83 | wr_os_X, (int)theWord);
  }
}
#endif

sprite_area *wr_resspr_area(void)
{
   return wr_resspr__area;
}

void wr_resspr_setarea(void *area)
{
   wr_resspr__area = (sprite_area *)area;
}

// =========================================================================
void ReadSpriteSize(wr_os_regset *r, Point &spriteSize)
{
   int eigVals[2];

   // Get Mode in R6, h-size in R3, v-size in R4
   r->r[0] = 40 + 512;
   FailOSErr(wr_os_swix(OS_SpriteOp, r));

   SetSpriteSize(r, eigVals);
   SetPt(spriteSize, eigVals[0], eigVals[1]); // OStoQD(eigVals[0]), OStoQD(eigVals[1]));
}

// =========================================================================
wr_os_error *SelectSprite(wr_os_regset *r, char *spriteName)
{
   r->r[0] = 24 + 256;
   r->r[1] = (int)wr_resspr__area;  // wr_resspr_area();
   r->r[2] = (int)spriteName;
   return wr_os_swix(OS_SpriteOp, r);
}

// =========================================================================
void InitPlot(wr_os_regset *r, char *spriteName, Point &spriteSize)
{
   // get pointer to sprite (from spritename)
   FailOSErr(SelectSprite(r, spriteName));

   ReadSpriteSize(r, spriteSize);
   spriteSize.h = OStoQD(spriteSize.h);
   spriteSize.v = OStoQD(spriteSize.v);
}

// =========================================================================
void PlotIt(wr_os_regset *r, int h, int v)
{
   Point dest;
   wr_os_error *err;

   dest.h = h;
   dest.v = v;
   thePort->LocalToGlobal(dest);

   // set up x and y coords in r3 and r4
   QDPttoOS(dest, r->r[3], r->r[4], ScreenHeight());
   r->r[0] = 52 + 512;
   err = wr_os_swix(OS_SpriteOp, r);
   DisposIfHandle(Handle(r->r[7]));
   FailOSErr(err);
}

#define ColourTrans_SelectTable 0x40740
static int gSelectTabFlags = 0x13;       // probably not accessed

// =========================================================================
void SetPlot(wr_os_regset *r, int *sFactors, char *pixTrans, int col1)
// pixTrans parameter should be removed, the data in it is not used
{
   int XorMask;
   int paltab[256];
   int palentries;
   int *to;
   int *from;
   _kernel_swi_regs r1, r2;
   int ttSize;
   wr_os_error *err;

   r1.r[0] = r->r[6];                   /* save sprite mode */

   // set up scale factors & pixel translation for current mode
   r->r[0] = 0x200;
   r->r[6] = (int)sFactors;
   r->r[7] = (int)pixTrans;
   FailOSErr(wr_os_swix(Wimp_ReadPixTrans, r));

   XorMask = ((unsigned int)gVduVars[4] > 15 && (r->r[5] & 7) == 3 ? 0xffffff00 : 0);
           // reverse cols if plot mode = Xor in 256 mode, so Xor on white (-1) works

   to = paltab;
   r1.r[1] = (int)paltab;
   r1.r[2] = -1;                       /* dest mode = current mode */
   r1.r[3] = -1;                       /* dest pal  = current pal  */
   ttSize = 16;

   // not RISC OS3.10, need to create a palette (size no more than 16 entries)
   palentries = (((sprite_header *)r->r[2])->image - sizeof(sprite_header)) / 8;
   if (palentries == 0)
   {
      // in case no palette on the sprite, set up default with white and col1

      XorMask ^= col1;
      while (to < paltab + 16)
      {
         *(to++) = 0xffffff00;    // white
         *(to++) = XorMask;       // col1 colour (modified if necessary)
      }
   }
   else
   {
      // copy the first of each pair of palette entries from the sprite to paltab
      from = (int *)((sprite_header *)r->r[2] + 1);

      while (to < paltab + palentries)
      {
         *to++ = (*from) ^ XorMask;    // invert colour if it will be xor-ed in 256 cols
         from += 2;
      }
   }
   if (gWimpVersion >= 316)
   {
     r1.r[4] = 0;                      /* request table size  */
     r1.r[5] = gSelectTabFlags;        /* flags: sprite ptr, use current palette, */
                                       /* and call r7 function passing r6 value */ 
     if (_kernel_swi(ColourTrans_SelectTable, &r1, &r2) == NULL)
       ttSize = r2.r[4];               /* sets r4 to size needed for table */
     else
       r1.r[5] = gSelectTabFlags = 3;  /* if failed we better unset the 'words' flag */
   }

   r->r[7] = r1.r[4] = (int)NewCheckedHandle(ttSize);   // pointer for generated table
   if ((err = (wr_os_error *)_kernel_swi(ColourTrans_SelectTable, &r1, &r2)) != NULL)
   {
     DisposIfHandle(Handle(r1.r[4]));
     FailOSErr(err);
   }
}
 
/**************************************************************************/
extern char *gDirName;
void AppSpriteName(char *buffer)
{
   char *p = gDirName;
   char *strt = buffer;

   for (;;)
   {
     if ((*(strt++) = *(p++)) == '.')
     {
       if (*p == 0) // string ends with a '.'
       {
         *(strt - 1) = 0;
         return;
       }
       strt = buffer;
     }
   } 
}

/**************************************************************************/
int ReportError(wr_os_error *errmsg, int flags)
// 22/02/94 [21415] if b8 of flags set, all the flags have already been set
// otherwise set b8 and set type to warning
{
   wr_os_regset r;
#ifndef NETWP
   char ourSpriteName[32];
#endif

#ifdef TRACE
#define SelectJob     0x00080145
//   wr_os_swi2(SelectJob | wr_os_X, NULL, NULL);
#endif
#ifdef NETWP
   r.r[3] = 0;  // no sprite in alert dialogue
#else
   r.r[3] = (int)(gDirName == NULL ? 0 : (AppSpriteName(ourSpriteName), ourSpriteName));
#endif
   r.r[0] = (int)errmsg;
   r.r[1] = 0x7fffffff & ((gWimpVersion >= 322 && r.r[3] != 0 ?
                       ((flags & 0x100) == 0 ? flags | 0x500 : flags) : flags & 0xff));
   r.r[2] = (int)wr_wimpt_programname();
   r.r[4] = 1;
   r.r[5] = (int)GetRsrc(errmsg->errnum, 'b');    // flags < 0 ? ... : 0;
   wr_wimpt_noerr(wr_os_swix(Wimp_ReportError, &r));
   return r.r[1];  // return user button clicked
}

/**************************************************************************/
wr_os_error *Sendmessage(wr_wimp_msgaction action, wr_wimp_msgstr *msg, int msgsize)
{
  msg->hdr.size = msgsize;       // round up to mult of 4 ?
  msg->hdr.action = action;
  msg->hdr.your_ref = msg->hdr.my_ref;
  return wr_wimp_sendmessage(wr_wimp_ESEND, msg, msg->hdr.task);
}

wr_os_error *SendmessageWantAck(wr_wimp_msgaction action, wr_wimp_msgstr *msg, int msgsize, int *myRef)
{
  wr_os_error *err;

  msg->hdr.size = msgsize;       // round up to mult of 4 ?
  msg->hdr.action = action;
  msg->hdr.your_ref = msg->hdr.my_ref;
  err = wr_wimp_sendmessage(wr_wimp_ESENDWANTACK, msg, msg->hdr.task);
  *myRef = msg->hdr.my_ref;      /* filled in by wimp. */
  return err;
}

wr_os_error *Broadcast(wr_wimp_msgaction action, wr_wimp_msgstr *msg, int msgsize)
{
  msg->hdr.size = msgsize;       // round up to mult of 4 ?
  msg->hdr.action = action;
  msg->hdr.your_ref = 0;
  return wr_wimp_sendmessage(wr_wimp_ESEND, msg, 0);
}

wr_os_error *BroadcastWantAck(wr_wimp_msgaction action, wr_wimp_msgstr *msg, int msgsize)
{
  msg->hdr.size = msgsize;       // round up to mult of 4 ?
  msg->hdr.action = action;
  msg->hdr.your_ref = 0;
  return wr_wimp_sendmessage(wr_wimp_ESENDWANTACK, msg, 0);
}

wr_os_error *AckMessage(wr_wimp_msgstr *msg)
{
  msg->hdr.your_ref = msg->hdr.my_ref;
  return wr_wimp_sendmessage(wr_wimp_EACK, msg, msg->hdr.task);
}

