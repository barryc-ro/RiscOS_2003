/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include "UTextDoc.h"

#define trackDrop 3

#define kSubSectionStr "§"
#define kAtStr 204

#ifdef TABLES
int gIDdrag = I_('d', 'r', 'a', 'g');
int gIDstru = I_('s', 't', 'r', 'u');
#endif

typedef struct TDiscSelection
{
  long anchorPos;
  long activeEndPos;
  bool endStructure;
  int saveLevel;
  int popup;
  int base;
  TViewId viewId;
} TDiscSelection;

typedef int TDiscCursor;

typedef struct TDiscNode
{
  TCurrency currency;
  int clickCount;
} TDiscNode;

// ------------------------------------------------------------------------
bool IsLastNode(TCursorNode node)
{
  return (node == NULL ? TRUE : node->IsLast());
}


// ------------------------------------------------------------------------
_TCursorNode::_TCursorNode(TCurrency currency, IDType identifier,
                                                  VPoint &mousePt) : ()
{
#ifndef ZERO_OBJ
  fCursor = NULL;
  fSavedNode = NULL;
#endif
  fCurrency = currency;
  fIdentifier = identifier;
  fClickCount = 1;
  fMousePt = mousePt;      // added 02/11/90 for arrow keys
}


// ------------------------------------------------------------------------
void _TCursorNode::Free()
{
  FreeIfObject(fSavedNode);
  _TObject::Free();
}

#ifdef TRACE
// ------------------------------------------------------------------------
void _TCursorNode::Adjust(TCharPos pos, int delta)
{
}                                                
#endif

// ------------------------------------------------------------------------
TCursorNode _TCursorNode::GetCursorTarget()
{
  return fCursor->GetTarget();
}

// ------------------------------------------------------------------------
int _TCursorNode::GetColNum()
{
  TCursorNode nextNode;

  nextNode = GetNext();
  if (nextNode == NULL)
    return(0);
  return Max(1, ((TViewId *)&nextNode->fIdentifier)->tag.fColNum);
                                       // 10/05/91
}


// ------------------------------------------------------------------------
TCursorNode _TCursorNode::GetNext()
{
  TCursor cursor = fCursor;
  int index = GetIndex();

  return (cursor->GetSize() == index ? NULL :
                              TCursorNode(cursor->At(index + 1)));
}


// ------------------------------------------------------------------------
TCursorNode _TCursorNode::GetPrevious()
{
  TCursor cursor = fCursor;
  int index = GetIndex() - 1;

  return (index == 0 ? NULL : TCursorNode(cursor->At(index)));
}


// ------------------------------------------------------------------------
int _TCursorNode::GetIndex()
{
  return(fCursor->GetEqualItemNo(this));
}


// ------------------------------------------------------------------------
bool _TCursorNode::IsLast()
{
  return TCursorNode(fCursor->Last()) == this;
}


// ------------------------------------------------------------------------
bool _TCursorNode::IsAnchorLast()
{
  return (fCursor == fCursor->fSelection->fAnchor ? IsLast() : FALSE);
}


// ------------------------------------------------------------------------
void _TCursorNode::SetClickCount(int clickCount, TSubView view, bool rightEdge)
{
  if (fClickCount < 3 || clickCount <= fClickCount) // 19/03/91 from <
  {
    fClickCount = clickCount;
    if (clickCount > 1)
      view->ClickAgain(this, rightEdge);
  }
}


// ------------------------------------------------------------------------
bool _TCursorNode::Equal(TCursorNode node)
{
  return (node != NULL && fCurrency == node->fCurrency);
}


// ------------------------------------------------------------------------
bool _TCursorNode::IsCursor(TCursorNode node)
{
  return(Equal(node) && (IsLast() ? node->IsLast() : GetNext()->IsCursor(node->GetNext())));
}


// ------------------------------------------------------------------------
void _TCursorNode::Collapse()
{
  TCursorNode nextNode;

  nextNode = GetNext();
  if (nextNode != NULL)
  {
    nextNode->Collapse();
    nextNode->fCursor->DeleteTarget();
  }
}


// ------------------------------------------------------------------------
void _TCursorNode::Copy(TCursorNode cursorNode)
{
  fSavedNode = NULL;
  fClickCount = cursorNode->fClickCount;
  fCurrency = cursorNode->fCurrency;
  fIdentifier = cursorNode->fIdentifier;
  fMousePt = cursorNode->fMousePt;
}


// ------------------------------------------------------------------------
long _TCursorNode::DoNeedDiskSpace(long dataForkBytes)
{
  return dataForkBytes - int(sizeof(_TCursorNode)) + int(sizeof(TDiscNode));
}


// ------------------------------------------------------------------------
void _TCursorNode::DoWrite(int aRefNum, long remainder)
{
  TDiscNode discNode;

  discNode.currency = fCurrency;
  discNode.clickCount = fClickCount;
  FWrite(aRefNum, sizeof(TDiscNode), &discNode);
  FWrite(aRefNum, remainder - sizeof(_TCursorNode), this + 1);
}


// ------------------------------------------------------------------------
void _TCursorNode::DoRead(int aRefNum, long remainder, int version)
{
  TDiscNode discNode;

  FRead(aRefNum, sizeof(TDiscNode), &discNode);

  fCurrency = discNode.currency;
  fClickCount = discNode.clickCount;
  fIdentifier = kNewCursor;
  fCursor = NULL;                     // not needed ?
  fSavedNode = NULL;
  FRead(aRefNum, remainder - sizeof(_TCursorNode), this + 1);
}


// ------------------------------------------------------------------------
_TCursor::_TCursor(TSelection itsSelection)
{
#ifndef ZERO_OBJ
  fChanged = FALSE;
#endif
  fSelection = itsSelection;
}


// ------------------------------------------------------------------------
void _TCursor::Free()
{
  FreeAll();
  _TList::Free();
}


// ------------------------------------------------------------------------
static void CopyNode(TCursor cursor, TCursorNode node, int* index)
{
  node->Copy(cursor->GetNode(*index));
  *index = *index + 1;
}

// ------------------------------------------------------------------------
void _TCursor::Copy(TCursor cursor)
{
  int index = 1;
  Each(cursor, (DoToObject)CopyNode, &index);   // 02/02/94 pass as 1st param: , Cursor);
}


// ------------------------------------------------------------------------
static bool IsNotCursorNode(TCursor cursor, TCursorNode node, int *index)
{
  bool  IsNotCursorNode_r;
  IsNotCursorNode_r = !node->IsCursor(TCursorNode(cursor->At(*index)));
  *index = *index - 1;
  return(IsNotCursorNode_r);
}

// ------------------------------------------------------------------------
bool _TCursor::IsCursor(TCursor cursor)
{
  int index = GetSize();

  return (index == cursor->GetSize() &&
    LastThat(cursor, (TestObject)IsNotCursorNode, &index) == 0);
}


// ------------------------------------------------------------------------
static TCursorNode DoClone(TCursorNode self, TCursorNode node, TCursor aCursor,
                                                    volatile TCursorNode *failedNode)
{
  TCursorNode cursNode;
  volatile TCursorNode tempNode;

  cursNode = TCursorNode(node->ShallowClone());
  *failedNode = cursNode;
  if (cursNode != NULL)
  {
    // cursNode->fSavedNode = NULL;       // set NULL in case DoClone fails
    if (cursNode->fSavedNode != NULL)      // 08/07/93 [20969] clone saved nodes too
    {
      cursNode->fSavedNode = DoClone(cursNode, cursNode->fSavedNode, aCursor, &tempNode);
      if (cursNode->fSavedNode == NULL)   // ShallowClone or nested DoClone failed
      {
        ClearObject(tempNode);
        return NULL;
      }
    }
    if (self != NULL)                  // 08/07/93 [20969] use self to indicate recursive call
      cursNode->fCursor = aCursor;     // reset owner pointer
    else
      aCursor->AddTarget(cursNode);     // 01/10/91
  }
  return cursNode;
}


// ------------------------------------------------------------------------
TObject _TCursor::ShallowClone()
{
  volatile TCursor aCursor = NULL;
  volatile TCursorNode failedNode = NULL;
  int index;
  FailInfo fi;

  CatchFailures(&fi);
  aCursor = new _TCursor(fSelection);
  for (index = 1; index <= GetSize(); index++)
  {
    TCursorNode node = TCursorNode(At(index));

    FailNIL(DoClone(NULL, node, aCursor, &failedNode));
  }
  // Each(NULL, (DoToObject)DoClone, aCursor, &failedNode);
  Success(&fi);

  return aCursor;

  // ********** exception handler **********
Rescue:
  FreeIfObject(aCursor);
  FreeIfObject(failedNode);  // 21/07/96 free node set up on the stack & not yet Added to aCursor
  return NULL; // 21/07/96 ShallowClone is expected to return: ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TCursor::InsertSubNodes(TCursorNode node)
{
  TCursorNode savedNode;

  node->fCursor = this;
  savedNode = node->fSavedNode;
  node->fSavedNode = NULL;
  if (savedNode != NULL)
    InsertSubNodes(savedNode);
  InsertFirst(node);
}


// ------------------------------------------------------------------------
void _TCursor::InitialCursor(TMainView view, TCurrency startCurrency, long posn)
{
  TTextDocument document;
  TCursorNode cursNode;
  TCurrency currency;
  TCurrency child;
  TStructure structure;
  TFormat format;
#ifdef FN
  TCurrency noteSetParent; // fn1
#endif

  document = TTextDocument(view->fDocument);
  if (startCurrency <= 0) // 28/05/90 - this block added
  {
    cursNode = new _TCursorNode(gNullCurrency, kNewCursor, gZeroVPt);
    cursNode->fCursor = this;
    structure = document->GetStructureReadOnly(document->fBody); // 19/03/91 RW
    structure->ExtendCursor(cursNode, document->fBody, -startCurrency, TRUE, TRUE);
                  // 18/07/96 -startCurrency for startCurrency < 0 so -2 can be passed (to text)
    FreeIfObject(cursNode);
  }
  else
  {
    currency = startCurrency;
    child = (posn == -1 ? -1 : 0);   // 06/09/92    child.fValue = (fromRight ? -1 : 0);
#ifdef FN
    noteSetParent = gNullCurrency;
#endif
    do
    {
      structure = document->GetStructureReadOnly(currency); // 19/03/91 RW
      format = view->GetFormatReadOnly(currency); // 19/03/91 RW
#ifdef FN
      if (structure->GetKind() == kFootnote)
        noteSetParent = structure->GetNoteContainer(currency); // fn1
#endif
      cursNode = format->InitialCursor(currency, child, posn); // 24/03/92
      posn = 0;                // 06/09/92
      child = currency;
      InsertSubNodes(cursNode);
      // cursNode->fCursor = this;
      // InsertFirst(cursNode);
#ifdef FN
      currency = ((structure->GetKind() == kNoteSet && noteSetParent != 0) ?
         noteSetParent : structure->fParent); // fn1
#else
      currency = structure->fParent;
#endif
    } while (currency != kNull);
  }
}


// ------------------------------------------------------------------------
void _TCursor::NewCursor(TCurrency startCurrency, TView view, VPoint &mousePoint1)
{
  TTextDocument document;
  TMainView mainView;
  TCursorNode cursNode;
  TCurrency currency;
  TCurrency child;
  TStructure structure;
  TFormat format;
  VRect viewExtent;
  VPoint mousePoint = mousePoint1;      // 11/04/91
#ifdef FN
  TCurrency noteSetParent; // fn1
#endif

  // 09/01/91 for ensuring clicking on picture edges selects the picture
  view->GetExtent(viewExtent);
  TSubView(view)->LocalToMainRect(viewExtent); // 16/09/91 only botright used
  if (mousePoint.h == viewExtent.right) mousePoint.h--;
  if (mousePoint.v == viewExtent.bottom) mousePoint.v--;

  mainView = TSubView(view)->fMainView;
  document = TTextDocument(view->fDocument);
  currency = startCurrency;
  child = 0;
#ifdef FN
  noteSetParent = 0; // fn1
#endif
  do
  {
    structure = document->GetStructureReadOnly(currency); // 19/03/91 RW
    format = mainView->GetFormatReadOnly(currency); // 19/03/91 RW
#ifdef FN
    if (structure->GetKind() == kFootnote)
      noteSetParent = structure->GetNoteContainer(currency); // fn1
#endif
    // 20/02/94 call clickonce here rather than in each GetTheCursor
    if (child == 0)
      cursNode = TSubView(view)->ClickOnce(mousePoint);
    else
      cursNode = format->GetTheCursor(view, mousePoint, child);
    if (cursNode == NULL)
    {
      FreeAll();
      break;
    }
    child = currency;
    // cursNode->fCursor = this;       // unnecessary? - done in ISN
    InsertSubNodes(cursNode); // 25/07/90  InsertFirst(cursNode);
#ifdef FN
    currency = ((structure->GetKind() == kNoteSet && noteSetParent != 0) ?
      noteSetParent : structure->fParent); // fn1
#else
    currency = structure->fParent;
#endif
    view = view->fSuperView;
    fSelection->fViewId.fId = kNewCursor;   // 10/09/91 view->fIdentifier;
  } while (currency != kNull);
}

/* ------------------------------------------------------------------------
int _TCursor::GetClickCount()
{
  return(GetTarget()->fClickCount);
}
*/

// ------------------------------------------------------------------------
TCursorNode _TCursor::GetTarget()
{
  return(TCursorNode(At(fSize)));
}


// ------------------------------------------------------------------------
TCursorNode _TCursor::GetNode(int index)
{
  return(TCursorNode(At(index)));
}


// ------------------------------------------------------------------------
void _TCursor::SetClickCount(int clickCount, TSubView view, bool rightEdge)
{
  GetTarget()->SetClickCount(clickCount, view, rightEdge);
}


// ------------------------------------------------------------------------
void _TCursor::ClickAgain(TSubView view, bool rightEdge)
{
  TCursorNode target;

  target = GetTarget();
  target->SetClickCount(target->fClickCount + 1, view, rightEdge);
}


// ------------------------------------------------------------------------
void _TCursor::AddTarget(TCursorNode target)
{
  target->fCursor = this;    // 01/10/91 do before InsertLast
  InsertLast(target);
}


// ------------------------------------------------------------------------
void _TCursor::DeleteTarget()
{
  TObject lastNode;

  lastNode = Last();
  Delete(lastNode);
  FreeIfObject(lastNode);
}


// ------------------------------------------------------------------------
void _TCursor::SetNode(int index, TCursorNode node)
{
  node->fCursor = this;   // 18/07/93 moved before AtPut
  AtPut(index, node);
}


// ------------------------------------------------------------------------
void _TCursor::Connect(TMainView mainView)
{
  PObj offEnd = fPtrToList + fSize;

  for (PObj node = fPtrToList; node != offEnd; node++)
  {
    mainView->GetFormatReadOnly(TCursorNode(*node)->fCurrency)->
                                           ResetCursor(TCursorNode(*node));
  }

/* 04/06/92 failed connecting cursor into matrices pasted in-line in text
  TCursorNode node;
  TCurrency currency;
  TFormat format;

  if (GetSize() > 1)   // 03/03/92 new block
  {
    node = TCursorNode(At(GetSize() - 1));
    currency = node->fCurrency;
    if (Curr_fType(currency) == kTextStruct
#ifdef MATHS
       || Curr_fType(currency) == kMathStruct
#endif
      )
      mainView->GetFormatReadOnly(currency)->ResetCursor(node);
  }
  node = TCursorNode(Last());
  currency = node->fCurrency;
  format = mainView->GetFormatReadOnly(currency);
  format->ResetCursor(node);
*/
  if (fSelection->fAnchor == this)                               // 10/09/91
    fSelection->fViewId.fId = TCursorNode(First())->fIdentifier; // 03/04/91
}


// ------------------------------------------------------------------------
void _TCursor::SaveNodes(int level)
{
  TCursorNode node, me;
  int index;

  me = TCursorNode(At(level));
  for (index = level; index <= GetSize(); index++)
  {
    node = TCursorNode(At(index));
#ifdef TRACE
    if (node->fSavedNode != NULL)
      SysBeep(0);  // hit this:  Assert(node->fSavedNode == NULL, 401);
                   // on select document, move cursor left, reselect document
#endif
    // 11/10/96 leaving handles: node->fSavedNode = node->GetNext();
    ReplaceObject(node->fSavedNode, node->GetNext());    
  }
  node = TCursorNode(me->Clone());
#ifdef TRACE
  Assert(node->fSavedNode == me->fSavedNode, 402);    // surely next line redundant ?
#endif
  node->fSavedNode = me->fSavedNode;
  me->fSavedNode = node;
  for (index = GetSize(); index >= level + 1; index--)
  {
    node = TCursorNode(At(index));
    Delete(node);
  }
}


// ------------------------------------------------------------------------
void _TCursor::RestoreNodes(int level)
{
  TCursorNode node, me;

  node = TCursorNode(At(level));
  me = node->fSavedNode;
  if (me != 0)
  {
    node->Collapse();
    node->Copy(me);
    node = me->fSavedNode;
    me->fSavedNode = NULL;
    FreeIfObject(me);
    while (node != NULL)
    {
      me = node->fSavedNode;  // 22/05/90 - RestoreNodes bug regarding planting NULL sorted out.
      node->fSavedNode = NULL;
      InsertLast(node);
      node = me;
    }
  }
}


// ------------------------------------------------------------------------
_TSelection::_TSelection(TTextDocument itsDocument) : (sizeof(TLevelInfo))
{
  fDocument = itsDocument;
#ifndef ZERO_OBJ
  fChanged = FALSE;
  fTarget = 0;
  fPopup = 0;
  fBase = 0;
  fAnchor = NULL;
  fActiveEnd = NULL;
  fCursor = FALSE;
  fCrossOver = FALSE;
  fStyleChanges = NULL;
  fUndoChanges = NULL;
  fReformatType = kSelNormal;
  fSaveLevel = 0;
  fAppliedChgs = gNullCurrency;
  fStyleToUpdate = gNullCurrency;
  fEndStructure = FALSE;
  fKeyExtend = FALSE;
#endif
  fViewId.fId = kNewCursor;
}


// ------------------------------------------------------------------------
void _TSelection::Free()
{
  FreeIfObject(fAnchor);
  FreeIfObject(fActiveEnd);
  FreeIfObject(fStyleChanges);
  FreeIfObject(fUndoChanges);
#ifndef SUPER
  fDocument->ResetTextHandler();    // 01/04/92
#endif
  _TArray::Free();
}


// ------------------------------------------------------------------------
TStructure _TSelection::GetStructureReadWrite(TCurrency currency)
{
  return fDocument->GetStructureReadWrite(currency);
}


// ------------------------------------------------------------------------
TStructure _TSelection::GetStructureReadOnly(TCurrency currency)
{
  return fDocument->GetStructureReadOnly(currency);
}

#ifdef MATHS
// ------------------------------------------------------------------------
bool _TSelection::CanEndStruct(TLevelInfo &levelInfo)
{
  int parentType;

  if (levelInfo.fPart != 1)
    return FALSE;
  if (levelInfo.fKind != kText && levelInfo.fKind != kMaths) // 31/01/92 maths back for tables
    return TRUE;
  parentType = Curr_fType(GetStructureReadOnly(levelInfo.fStructure)->fParent);
  return (levelInfo.fKind == kText ?
              parentType == kMathStruct :
              parentType != kTableStruct);
                         // 24/01/92 || parentType == kTextStruct);
}


// ------------------------------------------------------------------------
// 12/01/92 new
bool _TSelection::AnInLine(TLevelInfo &levelInfo)
{
  TStructure s;

  // 30/4/92 search up thru the structure
  s = GetStructureReadOnly(levelInfo.fStructure);
  return s->IsPartOf((1 << kText) | (1 << kMaths));    // 24/01/94 passed a set of TStyleTypes
}
#else
#define AnInLine(A) 0
#endif

// ------------------------------------------------------------------------
TObject _TSelection::ShallowClone()
{
  TSelection aSelection = TSelection(_TArray::ShallowClone());

  if (aSelection != NULL)
  {
    TCursor aCursor;
    int failed = FALSE;

    aSelection->fStyleChanges = NULL;
    aSelection->fUndoChanges = NULL;

    if (aSelection->fAnchor != NULL)
    {
      aCursor = TCursor(aSelection->fAnchor->ShallowClone());
      if (aCursor == NULL)
        failed = TRUE;
      else
        aCursor->fSelection = aSelection;
      aSelection->fAnchor = aCursor;
    }
    if (aSelection->fActiveEnd != NULL)
    {
      aCursor = TCursor(aSelection->fActiveEnd->ShallowClone());
      if (aCursor == NULL)
        failed = TRUE;
      else
        aCursor->fSelection = aSelection;
      aSelection->fActiveEnd = aCursor;
    }
    if (failed)
    {
      FreeIfObject(aSelection);
      aSelection = NULL;
    }
  }
  return aSelection;
}

// ------------------------------------------------------------------------
static void AdjustEnd(TCursor anEnd, TCurrency currency, TCharPos pos, int delta)
{
  TCursorNode target = anEnd->GetTarget();

  if (target->fCurrency == currency)
    target->Adjust(pos, delta);
}

// ------------------------------------------------------------------------
void _TSelection::Adjust(TCurrency currency, TCharPos pos, int delta)
{
  AdjustEnd(fAnchor, currency, pos, delta);
  if (!fCursor)
    AdjustEnd(fActiveEnd, currency, pos, delta);
}


#ifndef SUPER
// 07/08/95 [26042] and [26044] test fCursor == 1 in Deferred tests (2 means that para
// has been treated as all sel for Plain, etc.; see TTextDocument->InstallStyleChange)

// ------------------------------------------------------------------------
bool _TSelection::DeferredStyle(TCurrency style, TStyleFormat &changes)
{
  TStyleFormat format;

  format = fDocument->ActiveMainView()->GetStyleReadOnly(style);
  if (fCursor == 1 && (format->fDefined & kEmphasis) != 0)  // 08/02/91 from emphattrs
  {
    changes = GetCurrentChanges(FALSE);
         // 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted
    if ((format->fDefined & kEmphasis) && !(changes->fDefined & kEmphasis))
    {
      ReplaceObject(changes, TStyleFormat(format->Clone()));
      fStyleChanges = changes;
    }
    else
      changes->ApplyOverride(format, gNullCurrency, TRUE);
    return TRUE;
  }
  changes = NULL;
  return FALSE;
}


// ------------------------------------------------------------------------
bool _TSelection::DeferredChanges(TStyleFormat &changes)
{
  changes = fStyleChanges;
  return ((fCursor & 1) == 1 && fStyleChanges != NULL && (fStyleChanges->fDefined & kEmphasis));
/* 13/11/92 see fix in TTextDocument->InstallStyleChange
  if (fCursor && fStyleChanges != NULL &&
       (fStyleChanges->fDefined & kEmphasis))  // 22/03/91
  {
    changes = fStyleChanges;
    return TRUE;
  }
  changes = NULL;
  return FALSE;
*/
}


// ------------------------------------------------------------------------
bool _TSelection::DeferredToggleChanges(TStyleFormat &changes)
{
  TStyleFormat undoChanges;

/* 01/12/92 problem if fDefined is zero, and fDefinedInMaths, etc contains attrs
  if (fCursor && (fStyleChanges != NULL) && (fUndoChanges != NULL) && 
     ((fStyleChanges->fDefined & ~emphasisAttrs) == 0) &&
     ((fUndoChanges->fDefined & ~emphasisAttrs) == 0))
*/
  if (fCursor == 1 && ((fStyleChanges != NULL && (fStyleChanges->fDefined & kEmphasis)) ||
         (fUndoChanges != NULL && (fUndoChanges->fDefined & kEmphasis))))
// 03/08/95 Maybe should be && after all (for emphasis chg, para chg (eg. justify) then Undo)
//          but accept a style with no changes at all as an emphasis
//  if (fCursor == 1 && ((fStyleChanges != NULL && 
//                    (fStyleChanges->fDefined == 0 || (fStyleChanges->fDefined & kEmphasis))) &&
//         (fUndoChanges != NULL &&
//                    (fUndoChanges->fDefined == 0 || (fUndoChanges->fDefined & kEmphasis)))))
// 19/01/94 [21351] should be || not &&
// 19/01/94            fStyleChanges != NULL && fUndoChanges != NULL && 
// 19/01/94               (fStyleChanges->fDefined & kEmphasis) &&
// 19/01/94               (fUndoChanges->fDefined & kEmphasis))
  {
    undoChanges = fStyleChanges;
    fStyleChanges = fUndoChanges;
    fUndoChanges = undoChanges;
    changes = fStyleChanges;
    DoSetupLevels();   // 20/01/94 [21352] to get right menu after toggle Plain
    fDocument->SetCurrentStyle();
             // 19/01/94 [21351] Use right style in menus after undo deferred change
    return TRUE;
  }
  changes = NULL;
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
void _TSelection::InitialCursor(TMainView view, TCurrency target, long posn)
{
  FailInfo fi;

  fAnchor = new _TCursor(this);
  CatchFailures(&fi);
  fAnchor->InitialCursor(view, target, posn);
  fCursor = TRUE;
  fChanged = TRUE;
  fPopup = 0;
  fBase = 0;
  fReformatType = kSelSlow;
  fSaveLevel = 0;
  SetTarget();
  Success(&fi);
  view->SetTheCursor(TRUE);
  return;
// *********** exception handler **********
Rescue:
  ClearObject(fAnchor);
  fCursor = FALSE;
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TSelection::InitialSelection(TMainView view, TCurrency anchor, TCurrency activeEnd)
{
  // 13/04/94 caller frees 'this' on failure, so catching failures here is unnecessary

  fAnchor = new _TCursor(this);
  fAnchor->InitialCursor(view, anchor, 0);
  fActiveEnd = new _TCursor(this);
  fActiveEnd->InitialCursor(view, activeEnd, -1);
  fCursor = FALSE;
  fChanged = TRUE;
  fPopup = 0;
  fBase = 0;
  fSaveLevel = 0;
  fReformatType = kSelSlow; // 28/05/90
}


// ------------------------------------------------------------------------
void _TSelection::PushLevel()
{
  if (fReformatType == kSelSaveAll || fReformatType == kReformatAll)
  {
    fTempLevel = fPopup;
    SelectLevel(GetSize() - fBase + 1);    // 18/05/93 [20879]
  }
}


// ------------------------------------------------------------------------
void _TSelection::PopLevel()
{
  if (fReformatType == kSelSaveAll || fReformatType == kReformatAll)
    SelectLevel(fTempLevel);
  fReformatType = kSelNormal;
}


// ------------------------------------------------------------------------
bool _TSelection::MatchesCurrency(PLevelInfo theInfo, TCurrency currency)
{
    return (theInfo->fStructure == currency);
}

// ------------------------------------------------------------------------
int _TSelection::FindLevelInfo(TCurrency currency, int &index, TLevelInfo &levelInfo)
{
  int  FindLevelInfo_r;

  index = LastThat(this, (TestItem)_TSelection::MatchesCurrency, currency);
  if (index == 0)
    FindLevelInfo_r = 1;
  else
  {
    Get(index, &levelInfo);
    if (index == fPopup)
      FindLevelInfo_r = 0;
    else if (index < fPopup)
      FindLevelInfo_r = 1;
    else
    {
      if (index - 1 == fPopup
#ifdef TABLES
        || (index - 2 == fPopup && levelInfo.fKind == kColumns)
                                    // 08/11/90 extra test added
#endif
            )
      {
        GetLevelInfo(&levelInfo);
        if (levelInfo.fStructure == currency)
          FindLevelInfo_r = 0;
        else
          FindLevelInfo_r = -1;
      }
      else
        FindLevelInfo_r = -1;
    }
  }
  return(FindLevelInfo_r);
}

#ifdef TABLES
// ------------------------------------------------------------------------
void _TSelection::SelectCurrency(TCurrency currency)
{
  int level = LastThat(this, (TestItem)_TSelection::MatchesCurrency, currency);

  if (level > 0)
    SelectLevel(level);
}
#endif

// ------------------------------------------------------------------------
TStyleFormat _TSelection::GetStyle(int level, TMainView mainView,
         Fixed &leftLimit, Fixed &rightLimit, int &textDirection, char *name)
{
  TStyleFormat theStyle;
  TLevelInfo levelInfo;
  TStructure structure;
  TFormat format;
  bool ignoreTabs;
  int index;
  int partStyleType;

  index = abs(level);
  Get(index, &levelInfo);

  if (levelInfo.fPart < 0)
  {
    index++;
    Get(index, &levelInfo);
  }
  textDirection = 0;     // 04/07/94 for backwards text
  leftLimit = 0;
  rightLimit = 0;
  ignoreTabs = level > 0 && (levelInfo.fPart == 1
#ifdef MATHS
           || levelInfo.fKind == kMaths     // 12/01/92
#endif
           ) && levelInfo.fKind != kText;
  partStyleType = GetStructureReadOnly(levelInfo.fStructure)->
                GetPartStyleType(levelInfo.fPart, levelInfo.fCustom); // 10/03/94
  theStyle = TStyleFormat(mainView->GetPrototype(partStyleType & 0x7f));
#ifdef TABLES
  if (partStyleType >= 128)
  {
    // 28/03/95 [24008] moved down: theStyle->fDefined |= kHasAdornment;
                       // 10/03/94 frig part styles for dialogue too
    partStyleType = 7 - levelInfo.fPart;
  }
  else
    partStyleType = -1;
#endif

  level = index;
  for (index = GetSize(); index >= level; index--)
  {
    Get(index, &levelInfo);

    if (levelInfo.fPart >= 0
#ifdef TABLES
         && (levelInfo.fPart != partStyleType || index != level + 1)
         // 10/03/94 && ... for tables, do not apply row & col part styles on top of each other
#endif
            )
    {
      bool applyRuler;

#ifdef TABLES
      // 28/03/95 [24008] move setting of kHasAdornment down, so it is only set while
      // applying the part changes (if any). Otherwise dialogue showed the borders changes
      // on the table, enclosing section, etc. if there were no explicit part changes.
      if (partStyleType > 0 && index == level)
        theStyle->fDefined |= kHasAdornment; // 10/03/94 frig part styles for dialogue too
#endif
      structure = GetStructureReadOnly(levelInfo.fStructure);
      if (index != level || (levelInfo.fPart != 1
#ifdef MATHS
                   && levelInfo.fKind != kMaths
#endif
                  )) // 7/5/92, 05/03/91 extra test
      {
        format = mainView->GetFormatReadOnly(levelInfo.fStructure);
        format->GetMarginLimits(structure, levelInfo.fPart, levelInfo.fCustom,
                                                    leftLimit, rightLimit);
      }
      else if (AnInLine(levelInfo)) // 6/5/92
        leftLimit = -1;

      if (ignoreTabs)
        applyRuler = (index == level && levelInfo.fPart == 1);
      else if (levelInfo.fStyle != 0)
        applyRuler = (Curr_fType(levelInfo.fStyle) == kTextStyleStruct
#ifdef MATHS
           || Curr_fType(levelInfo.fStyle) == kMathStyleStruct
#endif
            );
      else if (levelInfo.fChanges != 0)
        applyRuler = (Curr_fType(levelInfo.fChanges) == kTextStyleStruct
#ifdef MATHS
           || Curr_fType(levelInfo.fChanges) == kMathStyleStruct
#endif
            );
      else
         applyRuler = FALSE;

      if (levelInfo.fStyle != 0)
        theStyle->ApplyOverride(mainView->GetStyleReadOnly(levelInfo.fStyle), levelInfo.fStyle,
                                                                                   applyRuler);
      if (levelInfo.fChanges != 0)
        theStyle->ApplyOverride(mainView->GetStyleReadOnly(levelInfo.fChanges), 0, applyRuler);

      if ((levelInfo.fPart == 1 || levelInfo.fKind != kText) && theStyle->fTextFont != 0)
      {
        // ignore text emphasis
        textDirection = (fDocument->SetCurrentFont(PFontStyle(&theStyle->fTextFont)) << 24)
                                                                          >> 31;
      }
    }
  }
  if (name != NULL)            // 16/07/96 only get name if needed (for dialogue)
    strcpy(name, levelInfo.fStyle == 0 ? GetString(kUntitledStr) :
                             fDocument->GetStyleReadOnly(levelInfo.fStyle)->fStylename);

  if (leftLimit < 0 || (levelInfo.fKind >= kWhiteSpace && levelInfo.fKind <= kFooter) ||
                                                             levelInfo.fKind == kPageFiller)
  {
    // 18/09/90 indicate that there should be no tabs, etc.
    leftLimit = 0;
    rightLimit = 0;
    theStyle->SetLeftMargin(-1);
    theStyle->SetRightMargin(-1);
    theStyle->SetIndentation(-1);
    theStyle->ReduceSize(0);
  }
  else
    theStyle->ClearDeletes();     // 16/07/96 else added - (no point calling if size == 0)
  return theStyle;
}


// ------------------------------------------------------------------------
int _TSelection::PopUpLevel()
{
  return (PLevelInfo(At(fPopup))->fPart < 0 ? 1 : fPopup);
}


// ------------------------------------------------------------------------
void _TSelection::SetCurrentStyle(TMainView mainView)
{
  TStyleFormat theStyle;
  Fixed leftLimit, rightLimit;
  int direction;

  theStyle = GetStyle(PopUpLevel(), mainView, leftLimit, rightLimit, direction, NULL);
  mainView->SetCurrentStyle(theStyle, leftLimit, rightLimit, direction);
}

#ifdef TABLES
// ------------------------------------------------------------------------
static void SetupMenuText(CmdNumber cmd, char *name)
{
  Str255 menuText;

  strcpy255(menuText, GetString(cmd));
  Substitute(menuText, name);
  SetCmdName(cmd, menuText);
}
#endif

// ------------------------------------------------------------------------
void _TSelection::SelectLevel(int level)
{
  TCursor Cursor;
  TCursorNode anchor, activeEnd;
  TCurrency currency;
  TStructure structure;
  TWindow window;
  TStyleTypes kind;
  TLevelInfo levelInfo;
  int part;
  TMainView view;
  int origLevel = level;
#ifdef FN
  TCursorNode anchorX, activeEndX; // fn1
#endif

#ifdef DRAGDROP
  if (fSize == 0)
    return;              // 11/03/93 stop it falling over when paste arrives quickly!
#endif

  if (level >= 0)
  {
    // 14/04/94 carry on anyway if level -ve
    if (MemSpaceIsLow())   // 29/05/92 FailSpaceIsLow() - possible cause of failure to commit
      return;
    level = level + fBase - 1;              // 08/02/91
  }
  if (level != fPopup)
  {
    if (level < 0)
    {
      if (level == -2) // 27/11/91 added if stmt to get rid of endStructure if set
      {
        if (!fEndStructure)
          return;
        level = fBase;
        fEndStructure = FALSE;
      }
      else
        level = fPopup;                     // 25/01/91 Experiment
    } 
    view = fDocument->ActiveMainView();
    window = view->GetWindow();
    if (fPopup != fBase)                    // fBase for 1
    {
      fAnchor->RestoreNodes(fTarget);
      if (!fCursor)
      {
        activeEnd = fActiveEnd->GetNode(fTarget);
        if (activeEnd->fSavedNode == NULL)
        {
          ClearObject(fActiveEnd);
          // fActiveEnd->Free();
          // fActiveEnd = NULL;
          fCursor = TRUE;
        }
        else
          fActiveEnd->RestoreNodes(fTarget);
      }
      // 14/04/94 if level was -1, this is Commit getting the new selection rebuilt after
      // the structure has been committed, which means that levelinfo (particularly
      // custom values for Tables) is now incorrect, and must be be reset from the cursors.
      // Unfortunately, the user may have selected a new level between the DoIt and commit
      // so we need to add the following DoResetLevels call here after the nodes have
      // been restored back to their original state. NB Calling DoSetupLevels at the of
      // this procedure will change the selected level, as the nodes will have been saved!
      if (origLevel == -1)  // 14/04/94 [21610] 
      {
#ifdef TRACE
        int oldSize = GetSize();
#endif

        DoResetLevels(FALSE);
#ifdef TRACE
        Assert(oldSize == GetSize(), 941);  // DoResetLevels(F) must preserve # levels
#endif
      }
    }
    fPopup = level;
    Get(level, &levelInfo);

    fTarget = levelInfo.fLevel;
    if (level > fBase)                     // 08/02/91 1 for fBase
    {
      fAnchor->SaveNodes(levelInfo.fLevel);
      if (!fCursor)
        fActiveEnd->SaveNodes(levelInfo.fLevel);
      else
      {
        // 08/07/93 [20969] After the fix to clone saved nodes we need to stop this
        // clone cloning saved nodes, as this is how it knows to reset fCursor above
        TCursorNode lastNode = TCursorNode(fAnchor->Last());
        TCursorNode saveSavedNode = lastNode->fSavedNode;

        lastNode->fSavedNode = NULL;
        Cursor = TCursor(fAnchor->ShallowClone());
        lastNode->fSavedNode = saveSavedNode;
        // 03/07/96 move failure test after restore (although Clone can (wrongly) fail!)
        fActiveEnd = TCursor(FailNIL(Cursor));
        fCursor = FALSE;
      }
      anchor = fAnchor->GetNode(levelInfo.fLevel);
#ifdef FN
      anchorX = anchor->fSavedNode;
      anchor->fSavedNode = NULL;
#endif
      if (fCursor)
        activeEnd = anchor;
      else
        activeEnd = fActiveEnd->GetNode(levelInfo.fLevel);
#ifdef FN
      activeEndX = activeEnd->fSavedNode;
      activeEnd->fSavedNode = NULL;
#endif
      anchor->fClickCount = 3; // 29/4/92
      activeEnd->fClickCount = 3; // 29/4/92 
      currency = anchor->fCurrency;
      structure = GetStructureReadOnly(currency);
      structure->SelectPart(anchor, activeEnd, levelInfo.fPart, levelInfo.fCustom); // 12/01/92
#ifdef FN
      anchor = fAnchor->GetNode(levelInfo.fLevel);
#ifdef TRACE
      Assert(anchor->fSavedNode == NULL || anchor->fSavedNode == anchorX, 403);
#endif
      anchor->fSavedNode = anchorX;
      activeEnd = fActiveEnd->GetNode(levelInfo.fLevel);
#ifdef TRACE
      Assert(activeEnd->fSavedNode == NULL || activeEnd->fSavedNode == activeEndX, 404);
#endif
      activeEnd->fSavedNode = activeEndX;
#endif
      structure->GetSelectionKind(anchor, activeEnd, kind, part, levelInfo.fCustom);
      AtPut(level, &levelInfo);
    }
    fChanged = TRUE;
    if (origLevel >= 0)           // 04/03/94 only clear if real select level - to
    {                             // avoid freeing textEvents fStyleChanges
      ClearObject(fStyleChanges); // 25/1/94 [21359] clear slave
      // DoSetupMenus(FALSE);
    }
    // else
    //   DoSetupMenus(2);       // 07/04/94 [21610] pass true if level -1 to force rebuild
                                // 13/04/94 pass 2 to not reselect level though
    DoSetupMenus(FALSE);  // 13/04/94 [21610] did not work (reselects level on Commit)
  }
}


// ------------------------------------------------------------------------
void _TSelection::LoadStyle(PLevelInfo levelInfo)
{
  TStructure structure;

  structure = GetStructureReadOnly(levelInfo->fStructure);
  levelInfo->fStyle = structure->GetPartStyle(abs(levelInfo->fPart),
                                                levelInfo->fCustom, levelInfo->fChanges);
}

// ------------------------------------------------------------------------
void _TSelection::DoSetupLevels()
{
  DoResetLevels(TRUE);
}

// ------------------------------------------------------------------------
void _TSelection::DoResetLevels(bool resetLevel)
// old DoSetupLevels with a parameter
{
  int currTarget;
  int index;
  TStructure structure;
  TCursorNode node1, node2;
  TStyleTypes kind;
  TLevelInfo levelInfo;
  int part;
  Rect custom;

  ReduceSize(0);
  SetTarget(); // ie. fTarget = GetTarget(fAnchor, fActiveEnd);
  node1 = fAnchor->GetNode(fTarget);
  if (fCursor)
    node2 = node1;
  else
    node2 = fActiveEnd->GetNode(fTarget);

  structure = GetStructureReadOnly(node1->fCurrency);
  structure->GetSelectionKind(node1, node2, kind, part, custom);
  currTarget = (part < 0 ? fTarget : fAnchor->GetSize());

  for (index = currTarget; index >= 1; index--)
  {
    node1 = fAnchor->GetNode(index);
    if (fCursor)
      node2 = node1;
    else
    {
      if (index <= fActiveEnd->GetSize())          // 08/02/91
      {
        node2 = fActiveEnd->GetNode(index);
        if (node2->fCurrency != node1->fCurrency)
          node2 = NULL;
      }
      else
        node2 = NULL;
    }

    {
      // prev. BuildLevel() local proc
      int level = index;
      TCurrency currency = node1->fCurrency;
      int pos;

      structure = GetStructureReadOnly(currency);
      structure->GetSelectionKind(node1, node2, levelInfo.fKind, part, custom);

      levelInfo.fStructure = currency;
      levelInfo.fLevel = index;
      // levelInfo.fKind = kind;
      levelInfo.fStyle = 0;
      levelInfo.fChanges = 0;

      /* 12/01/92 block moved to (virtual) TStructure.InsertLevelInfo */
      pos = GetSize() + 1;      // 29/01/92
      structure->InsertLevelInfo(this, levelInfo, part, custom, level, currTarget);
      if (level == fTarget)      // 29/01/92
        fPopup = pos;
      // end BuildLevel() local proc
    }
  }
  if (resetLevel)   // 14/04/94 [21610] do not reset fBase, fPopup gets reset by caller
    fBase = fPopup;
  Each(this, (DoToItem)_TSelection::LoadStyle);
}

#ifdef TABLES
// ------------------------------------------------------------------------
void BuildName(TLevelInfo *levelInfo, char* name)
{
  int count;
  Str255 temp;

  if (levelInfo->fKind == kSection)
  {
    temp[0] = 0;
    for (count = 1; count <= (levelInfo->fLevel - 2); count ++)
    {
      strcat255(temp, kSubSectionStr);
    }
    strcat255(temp, name);
    strcpy(name, temp);
  }
}

// ------------------------------------------------------------------------
void _TSelection::BuildMenu(PLevelInfo levelInfo, MenuHandle *selectMenu)
{
  int resId;
  int resIdx;
  char *resName;
  int inLen;
  Str255 nameBuff;

  resId = kSelectStrings + int(levelInfo->fKind);
  // FailNIL(GetIndString(resId, 1));
  inLen = 0;
  if (levelInfo->fPart < 0)
  {
    if (levelInfo->fMsgNum < 0)
    {
      resIdx = 0;
    }
    else
    {
      strcpy(nameBuff, GetString(31));
      inLen = strlen(nameBuff);
      resIdx = levelInfo[1].fMsgNum;
    }
  }
  else
  {
    resIdx = levelInfo->fMsgNum;
  }
  resName = GetIndString(resId, resIdx + 1);
  if (resName && inLen > 0)
    nameBuff[inLen++] = tolower(*(resName++)); // 23/07/92 Acorn capitalisation for menus

  strcpy(nameBuff + inLen, resName ? resName : "?");
  
  BuildName(levelInfo, nameBuff);
  AppendMenuItem(selectMenu, nameBuff);
}
#endif


// ------------------------------------------------------------------------
TStyleTypes _TSelection::DoSetupMenus(bool resetLevel)
{
  int index;
#ifdef TABLES
  MenuHandle* selectMenu;
  Str255 nameBuff;
  TStyleTypes kind;     // 22/07/92
  TStructTypes styleType;     // 22/07/92
#endif
  TLevelInfo levelInfo;
  TWindow window;

  window = TMainView(fDocument->ActiveMainView())->GetWindow();
  // 27/04/92 moved out of fChanged condition
  // NB!!! above not really correct, should be window under menu button!!!
#ifdef TABLES
  selectMenu = GetResMenu(cmSelection);
  DelMenuItems(selectMenu, 1);
#endif

  if (fChanged && (fPopup <= fBase || resetLevel))      // oldPopup <= 1
    DoSetupLevels();
  else
    Each(this, (DoToItem)_TSelection::LoadStyle); // 17/09/90 from LoadMenuStyle

#ifdef TABLES
  for (index = fBase; index <= fSize; index++)
    BuildMenu(PLevelInfo(At(index)), selectMenu);  // 08/02/91 loop for Each...
  if (fEndStructure)
    DisableMenu(cmSelection);                    // 11/06/91
#endif

  if (fChanged)
  {
    if (fEndStructure)
    {
      fPopup = GetSize() - fPopup;
      fSaveLevel = fPopup + 1;
      index = fSaveLevel;
    }
    else
      index = fPopup;

    while ( Get(index, &levelInfo),
#ifdef MATHS
      !CanEndStruct(levelInfo) // 12/01/92
#else
      levelInfo.fKind == kText || levelInfo.fPart != 1
#endif
     ) index++;

#ifdef TABLES
    if (fEndStructure)
    {
      strcpy(nameBuff, GetString(kAtStr));
      CmdToName(cEndStruct, nameBuff + strlen(nameBuff));
      window->WriteText(gIDdrag, nameBuff);
    }

    strcpy(nameBuff, GetIndString(kSelectStrings + levelInfo.fKind,
         (levelInfo.fMsgNum > 0 ? // 27/04/92 for End Expression
                     levelInfo.fMsgNum : abs(levelInfo.fPart)) + 1));
    BuildName(&levelInfo, nameBuff);
    nameBuff[0] = tolower(nameBuff[0]);   // 23/07/92 for Acorn menu capitalisation
    SetupMenuText(cEndStruct, nameBuff);
#endif
    fChanged = FALSE;
  }

  // setting the check mark always done, rather than just when fChanged
#ifdef TABLES
  index = (fEndStructure ? fSaveLevel : fPopup - fBase + 1);
  // 27/04/92. 19/05/92 need to reset popup always in case after Ctrl-E, Ctrl-F1
  GetItem(*selectMenu, index, nameBuff);
  window->WriteText(gIDstru, nameBuff);
  CheckItem(*selectMenu, index, TRUE);  // tick the item selected

  // 22/07/92 find out the kind value to go in the xxx styles menu
  GetLevelInfo(&levelInfo);
  styleType = GetStructureReadOnly(levelInfo.fStructure)->
            GetPartStyleType(levelInfo.fPart, levelInfo.fCustom) & 0x7f;  // 10/03/94
  if (styleType == kTextStyleStruct)
    kind = kText;
  else if (styleType == kMathStyleStruct)
    kind = kMaths;
  else
    kind = levelInfo.fKind;
  if (fDocument->fStyleSheet != NULL)
    fDocument->fStyleSheet->SetUpStyleMenu(this, kind);  // 22/07/92 extra param
  SetupMenuText(cSelStyleName, GetIndString(kSelectStrings + kind, 2));

  Enable(cEndStruct, index < GetSize());
  Enable(cSaveStyle, !(fEndStructure || levelInfo.fChanges == 0));
  return kind;
#else
  return kText;
#endif
}

#ifdef TABLES
// ------------------------------------------------------------------------
void _TSelection::ReformatAndDoMenus(int refmtType)
{
  fReformatType = refmtType;
  fDocument->Reformat();
  fDocument->HighlightSelection(HLOn, TRUE);
  DoMenus(FALSE);
}
#endif

// ------------------------------------------------------------------------
void _TSelection::DoMenus(bool reset)
{
  fChanged = TRUE;
  DoSetupMenus(reset);
  fDocument->SetCurrentStyle();
}

// ------------------------------------------------------------------------
bool _TSelection::ChangeStyleAttrs(TMainView view, CmdNumber attrsCmd)
{
  bool  ChangeStyleAttrs_r = FALSE;
  TStyleFormat theChanges;
  TStyleFormat theStyle;
  TStyleTypes theType;
  Fixed ll, rl;
  int direction;
  TCurrency saveChgs;
  bool canType;
  TStructure theStructure;
  TLevelInfo *levelInfo;
  int level = PopUpLevel();

  levelInfo = PLevelInfo(At(level));    // 08/02/91 level for fpopup
  saveChgs = levelInfo->fChanges;
  levelInfo->fChanges = 0;
  theType = levelInfo->fKind;
  theStructure = GetStructureReadOnly(levelInfo->fStructure);
  canType = theStructure->CanType();

  theStyle = GetStyle(level, view, ll, rl, direction, NULL);    // 08/02/91 level for fpopup
  PLevelInfo(At(level))->fChanges = saveChgs;       // ditto
  theChanges = GetCurrentChanges(TRUE);
     // 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted
  if (fUndoChanges != NULL)
  {
#ifdef TABLES
    switch (attrsCmd)
    {
    case cChangeStyle:
      ChangeStyleAttrs_r = theStyle->ChangeStyleAttrs(fDocument, theChanges, theType);
            // 18/06/92 levelInfo->fPart == 1 ? theType : kText);
            // 18/06/92 to stop Text dialog if maths insertion/part
       break;
     case cTypeSpec:
       ChangeStyleAttrs_r = theStyle->ChangeTypeSpec(fDocument, theChanges);
       break;
     case cBorders:
       ChangeStyleAttrs_r = theStyle->ChangeBorders(fDocument, theChanges,
#ifdef FN
              levelInfo->fPart == 1 ? theType : 0); // 17/05/93 [20877] only if all kNoteSet
#else
              theType); // fn1
#endif
       break;
     case cSpacing:
       ChangeStyleAttrs_r = theStyle->ChangeSpacing(fDocument, theChanges, canType);
       break;
    }
#else
#if SIDEBAR == 1
    if (attrsCmd == cSizeDialog)
      ChangeStyleAttrs_r = theStyle->ChangeBorders(fDocument, theChanges, -1); // fn1
    else
#endif
    if (attrsCmd == cBorders)
      ChangeStyleAttrs_r = theStyle->ChangeBorders(fDocument, theChanges, theType); // fn1
#endif
  }
  else
    ChangeStyleAttrs_r = FALSE;

  FreeIfObject(theStyle);
  SetCurrentStyle(view);
  return(ChangeStyleAttrs_r);
}

// ------------------------------------------------------------------------
void _TSelection::ResetMenus(PLevelInfo levelInfo)
{
  if (levelInfo->fKind == kText && levelInfo->fPart == 2)
  {
    EndClick();
    fCrossOver = FALSE;
  }
  else if (fDocument->GetNewSelection() == this) // 21/01/94 [21352] avoid if not 'real' sel
  {
    fChanged = TRUE;
    DoSetupMenus(FALSE);
  }
}

// ------------------------------------------------------------------------
void _TSelection::DoInstall(TCurrency currency, long pos,
                                   TCursorNode anchor, TCursorNode activeEnd, CmdNumber cmd)
{
  TStructure subStructure;
  int part;
  Rect custom;
  TStyleTypes kind;

  subStructure = GetStructureReadWrite(currency);
  subStructure->GetSelectionKind(anchor, activeEnd, kind, part, custom);
  subStructure->InstallStyleChange(currency, fStyleChanges, abs(part), custom, cmd);
}

// ------------------------------------------------------------------------
void _TSelection::InstallStyleChange(TRulerDef theChanges, CmdNumber cmd) // 6/5/92
{
  TLevelInfo levelInfo;
  TStructure structure;

  GetLevelInfo(&levelInfo);
  structure = GetStructureReadWrite(levelInfo.fStructure);

  fStyleChanges = TStyleFormat(theChanges);

  if (levelInfo.fPart > 0 || structure->HasCompositeStyle())
    structure->InstallStyleChange(levelInfo.fStructure, fStyleChanges,
                Max(1, levelInfo.fPart), levelInfo.fCustom, cmd); // 22/4/92
  else
  {
    TCursorNode anchor, activeEnd;
    TCurrency currency;

    anchor = GetAnchorOwner();
    activeEnd = GetActiveOwner();
    currency = anchor->fCurrency;
#ifdef TRACE
    Assert(currency == levelInfo.fStructure, 189); // see below
#endif
    structure->Iterate(currency, anchor, activeEnd, TRUE, this,
             DoStep(_TSelection::DoInstall), cmd);   // 29/04/92 cmd missing
  }

  fReformatType = kSelStyleChgd;
  ResetMenus(&levelInfo);                      // 16/06/91
}


// ------------------------------------------------------------------------
TStyleFormat _TSelection::GetCurrentChanges(bool forDialog)
// 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted
// 08/03/94 [21446] Pass forDialog as 2 when getting changes for a ruler reformat indicating
// for levelInfo.fPart: and fCursor:   part is to be set to:
//              2       must be F?      -1 ( +1 removes current para style)
//              1       must be F?      +1 ( -1 makes tab jump back to original)
//             -1       TRUE            either -1 or +1 seems to work
//             -1       FALSE           -1 ( +1 removes current para style)
//                                      NB. -1 needs a fix in IsAllSelected in UTextEdit
//                                      otherwise it fails if you drag across whole para
//             -2       TRUE            either -1 or +1 seems to work
//             -2       FALSE           -1 ( +1 removes current para style)
// for negPart & forDialog < 2, try to do what it did before
// NB the value of forDialog is ignored if fStyleChanges is already set (even though it
// was set up with a different value of forDialog). So really fStyleChanges needs to be
// 'unslaved', but since the TextHandler seems to keep a copy of the pointer to the style,
// resetting fStyleChanges may be rather traumatic.
{
  TCurrency currency;
  TFormat format;
  TLevelInfo levelInfo;
  int part;

  if (fStyleChanges == NULL)      // save doing else branch : && !MemSpaceIsLow())
  {
    int negPart;                  // gets set when selection over multiple paragraphs/cells
    int level;

    FailSpaceIsLow();             // save doing else branch
    // 27/05/92 fPopup != 1 && added so tabs can be moved & deleted
    level = (fPopup != 1 && PLevelInfo(At(fPopup))->fPart < 0 ?
                                     negPart = 1 : (negPart = 0, fPopup));
    Get(level, &levelInfo);
    currency = levelInfo.fStructure;
    format = fDocument->ActiveMainView()->GetFormatReadOnly(currency);

    // [21075] 12/10/93 for bold emphasis in bold para, etc. do not want to reset part
    // so add parameter to indicate this is a call to set up "Changes" box in a dialogue
    if (forDialog == 1 && fCursor && levelInfo.fPart < 0)    // 14/10/93 forDialog
      part = -levelInfo.fPart; 
           // 25/01/94 [21359] part = 1; avoid getting para changes after click in emphasis!
    else if (negPart)
      part = -1;
    else if (forDialog == 1 && levelInfo.fPart < 0)
               // 25/01/94 [21359] fCursor == F for part of emphasis, but need to test
               // negPart first for deleting tabs over a selection of paragraphs
      part = -levelInfo.fPart;
    else if (forDialog == 2 && levelInfo.fPart != 1 &&    // 07/02/94 [21446]
                     Curr_fType(currency) == kTextStruct) // 03/05/94 [21718]
      part = -1;
    else
      part = levelInfo.fPart;

    fStyleChanges = format->GetNewStyle(currency, part, levelInfo.fCustom);
                               // NB this Fails rather than return NULL
    if (negPart)
      fStyleChanges->fTimeStamp = 0;  // 22/05/92 new test
  }

  ReplaceObject(fUndoChanges, TStyleFormat(fStyleChanges->ShallowClone()));
  return fStyleChanges;
}

// ------------------------------------------------------------------------
void _TSelection::MoveCursor(int arrowKey, EventInfo &info, TMainView mainView)
{
  TFormat format;
  TCursorNode node;
  // bool formatAction = (arrowKey == chCaseSwap); // 22/6/92
  TCursor anc;
#ifdef NETWP
  TCursor cursor;
#endif
  FailInfo fi;

  if (fEndStructure)
  {
    // fn2    GetEndStructure()->Collapse();
    // fn2    fEndStructure = FALSE;
    SysBeep(0); // fn2
    return;     // fn2
  }
#ifdef NETWP
  if (fKeyExtend)
    cursor = TCursor((fKeyExtend == 1 ? fAnchor : fActiveEnd)->ShallowClone());
        // clone and save (active end if tracking the anchor (ie gone left from start position))
  else
    cursor = NULL;
#endif
  if (!mainView->fCursor)        // 09/07/91 test MainView (for pics)
  {
#ifdef NETWP
    if (cursor)
      SetTheCursor(fKeyExtend - 1);  // to activeEnd/anchor if fKeyExtend == 1/2
    else
#endif
    {
      fDocument->HighlightSelection(HLOff, TRUE);
      SetTheCursor((arrowKey & 0x0f) == 0x0f /* up */ || (arrowKey & 0x0f) == 0x0c /* left */);
      mainView->SetTheCursor(TRUE);  // 04/07/91 for caret in idle
    }
    fAnchor->Connect(mainView);    // 19/03/91 
    // moved up - leave if key extend: mainView->SetTheCursor(TRUE);
    info.affectsMenus = TRUE;      // 08/07/91 for selection menu
  }

  anc = TCursor(fAnchor->Clone());
  CatchFailures(&fi);

  // 01/06/91 loop while same arrow key pressed to speed up auto repeats
  do
  {
    node = GetAnchorTarget();
    format = mainView->GetFormatReadOnly(node->fCurrency);
    format->MoveCursor(node, arrowKey, info);
  }
  while (
#if SIDEBAR == 1
          // 12/01/96 avoid auto-repeat when F6 remains held as that causes
          // cursor to skip forward one or more words too far when only speaking first
           arrowKey != chSpeak &&
#endif
           TestNextKey(arrowKey));

  // mainView->ScrollSelectionIntoView(this);
  // Success(&fi);                              // 11/08/92
  // FreeIfObject(anc);                         // 11/08/92

  // 22/6/92 reformat after Case change
  if (arrowKey == chCaseSwap)
  {
    mainView->fSelection = this;
    fReformatType = kReformatLine; // 30/6/92
    fDocument->UpdateChangeCount(1);
    fDocument->Reformat();
    info.affectsMenus = TRUE;      // 15/07/92
    // mainView->ScrollSelectionIntoView(this);
        // 20/06/94 [22001] add SSIV: maybe call above should be moved after this clause???
  }
  // end reformat

  // 01/07/96 moved after reformat for case swap in case of failure in clause
  mainView->ScrollSelectionIntoView(this);   // show anchor position
  Success(&fi);                              // 11/08/92
  FreeIfObject(anc);                         // 11/08/92

#ifdef NETWP
  if (cursor)
  {
    if (ComesBefore(fAnchor, cursor))
    {
      fActiveEnd = cursor;
      fKeyExtend = 2;     // tracking end is the anchor
    }
    else
    {
      if (ComesBefore(cursor, fAnchor))
      {
        fActiveEnd = fAnchor;
        fAnchor = cursor;
      }
      fKeyExtend = 1;
    }
    if (fActiveEnd != NULL)
    {
      fCursor = FALSE;
      mainView->SetTheCursor(FALSE);
      info.affectsMenus = TRUE;
    }
    else
    {
      // new fAnchor and other end (cursor) at same position: set back to an insertion point
      FreeIfObject(cursor);
      fDocument->HighlightSelection(HLOff, TRUE);
      mainView->SetTheCursor(TRUE);  // 04/07/91 for caret in idle
    }
  }
#endif

  SetTarget();
#ifdef NETWP
  if (fActiveEnd != NULL)
    fDocument->SetTextHandler();    // needs to be done after SetTarget
#endif
  if (info.affectsMenus)
    DoMenus(TRUE);
#ifdef NEVER
  // 14/07/95 [21604] stops highlight being put on picture even though 'selected'
  if (!fCursor)                   // 16/06/91
#endif
    Highlight(mainView, TRUE);
  return;

Rescue:                        // 11/08/92 reset on failure
#ifdef NETWP
  FreeIfObject(cursor);
#endif
  ReplaceObject(fAnchor, anc);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TSelection::EndStructure()
{
  TCursorNode anchor;
  TLevelInfo levelInfo;
  TStructure structure;
  int level;
  int offset;

  if (fEndStructure)
    level = fSaveLevel;
  else
    level = fPopup;

  while(Get(level, &levelInfo), 
#ifdef MATHS
   !CanEndStruct(levelInfo) // 12/01/92
#else
  levelInfo.fKind == kText || levelInfo.fPart != 1 // 25/07/90
#endif
    ) level++;
  offset = GetSize() - level;
  anchor = fAnchor->GetNode(levelInfo.fLevel);
  anchor->Collapse();

  structure = GetStructureReadOnly(levelInfo.fStructure);
#ifdef FN
  if (structure->GetKind() == kFootnote)
  {
    // 27/09/94 [22029] change to get rid of FindNoteReference
    TCursor saveAnchor;
    TCurrency noteRef = structure->GetNoteReference();
    TMainView mainView = fDocument->ActiveMainView();

    saveAnchor = fAnchor;
    InitialCursor(mainView, noteRef, levelInfo.fStructure);  // 06/09/92
    FreeIfObject(saveAnchor);
    fEndStructure = FALSE;
    mainView->ClearViewSlave();
#ifdef MATHS
    structure = GetStructureReadOnly(noteRef); // 29/4/92
    // 29/4/92 test for footnote inside maths
    if (/* structure->fParent != 0 && */ Curr_fType(structure->fParent) == kMathStruct)
    {
      fEndStructure = FALSE;
      gEventInfo.affectsMenus = TRUE;
      for (int i = 1; i <= 2; i++)
        MoveCursor(/* 0x18d */ 0x0d, gEventInfo, mainView); // right arrow
    }
    else
#endif
      DoSetupMenus(TRUE);
  }
  else
#endif
  {
    structure->EndStructure(levelInfo.fStructure, anchor, levelInfo.fPart, levelInfo.fCustom);
    ClearObject(fActiveEnd);
    fCursor = TRUE;
    fChanged = TRUE;
#ifdef MATHS
    // 12/01/92 new block
    if (structure->fParent != 0 && (Curr_fType(structure->fParent) == kMathStruct ||
                             Curr_fType(structure->fParent) == kTextStruct))
    {
      fEndStructure = FALSE;
      gEventInfo.affectsMenus = TRUE;
      MoveCursor(/* 0x18d */ 0x0d, gEventInfo, fDocument->ActiveMainView()); // right arrow
    }
    else
#endif
    {
      fEndStructure = TRUE;
      fPopup = offset;
      DoSetupMenus(FALSE);
    }
#ifdef FN
    // 18/02/94 the only thing you can do after End Note Set is End Document so go there
    if (structure->GetKind() == kNoteSet)
      EndStructure();
#endif
  }
}


// ------------------------------------------------------------------------
void _TSelection::DoSetStyle(TCurrency currency, long pos,
                    TCursorNode anchor, TCursorNode activeEnd, TCurrency* style, CmdNumber cmd)
{
  int part;
  Rect custom;
  TStyleTypes kind;
  TStructure subStructure;

  subStructure = GetStructureReadWrite(currency);
  subStructure->GetSelectionKind(anchor, activeEnd, kind, part, custom);
  if (part > 0 || subStructure->HasCompositeStyle())
    subStructure->SetStyle(currency, *style, abs(part), custom, cmd);
  else
    subStructure->Iterate(currency, anchor, activeEnd, TRUE, this,
                                      DoStep(_TSelection::DoSetStyle), style, cmd);
}


// ------------------------------------------------------------------------
void _TSelection::SetStyle(TCurrency style, CmdNumber cmd)
{
  TCursorNode anchor, activeEnd;
  TLevelInfo levelInfo;
  TStructure structure;

  GetLevelInfo(&levelInfo);
  anchor = GetAnchorOwner();
  activeEnd = GetActiveOwner();

  structure = GetStructureReadWrite(levelInfo.fStructure);
  if (levelInfo.fPart > 0 || structure->HasCompositeStyle())
    structure->SetStyle(levelInfo.fStructure, style, 
        Max(1, levelInfo.fPart), levelInfo.fCustom, cmd); // 22/4/92
  else
    structure->Iterate(levelInfo.fStructure, anchor, activeEnd, TRUE, this,
      DoStep(_TSelection::DoSetStyle), &style, cmd);    // 29/04/92 cmd missing

  fReformatType = kSelStyleChgd;
  ResetMenus(&levelInfo);
}


// ------------------------------------------------------------------------
void _TSelection::DoToggle(TCurrency currency, long pos,
                                    TCursorNode anchor, TCursorNode activeEnd, CmdNumber cmd)
{
  int part;
  Rect custom;
  TStructure subStructure;
  TStyleTypes kind;

  subStructure = GetStructureReadWrite(currency);
  subStructure->GetSelectionKind(anchor, activeEnd, kind, part, custom);
  if (part > 0 || subStructure->HasCompositeStyle())
    subStructure->ToggleStyle(abs(part), custom, cmd);
  else
    subStructure->Iterate(currency, anchor, activeEnd, TRUE, this,
                                                       DoStep(_TSelection::DoToggle), cmd);
}


// ------------------------------------------------------------------------
void _TSelection::ToggleStyle(CmdNumber cmd)
{
  TCursorNode anchor, activeEnd;
  TStructure structure;
  TLevelInfo levelInfo;

  GetLevelInfo(&levelInfo);
  anchor = GetAnchorOwner();
  activeEnd = GetActiveOwner();

  structure = GetStructureReadWrite(levelInfo.fStructure);
  if (levelInfo.fPart > 0 || structure->HasCompositeStyle())
    structure->ToggleStyle(Max(1, levelInfo.fPart), levelInfo.fCustom, cmd);
  else
    structure->Iterate(levelInfo.fStructure, anchor, activeEnd, TRUE, this,
           DoStep(_TSelection::DoToggle), cmd);

  fReformatType = kSelStyleChgd;
  ResetMenus(&levelInfo);
}


// ------------------------------------------------------------------------
void _TSelection::DoToggle2(TCurrency currency, long pos,
                                     TCursorNode anchor, TCursorNode activeEnd, CmdNumber cmd)
{
  int part;
  Rect custom;
  TStyleTypes kind;
  TStructure subStructure;

  subStructure = GetStructureReadWrite(currency);
  subStructure->GetSelectionKind(anchor, activeEnd, kind, part, custom);
  subStructure->ToggleChanges(abs(part), custom, cmd); 
}


// ------------------------------------------------------------------------
void _TSelection::ToggleChanges(CmdNumber cmd)
{
  TCursorNode anchor, activeEnd;
  TStructure structure;
  TStyleFormat undoChanges;
  TLevelInfo levelInfo;

  undoChanges = fStyleChanges;
  fStyleChanges = fUndoChanges;
  fUndoChanges = undoChanges;
  GetLevelInfo(&levelInfo);
  anchor = GetAnchorOwner();
  activeEnd = GetActiveOwner();

  structure = GetStructureReadWrite(levelInfo.fStructure);
  if (levelInfo.fPart > 0 || structure->HasCompositeStyle())
    structure->ToggleChanges(Max(1, levelInfo.fPart), levelInfo.fCustom, cmd);
  else
    structure->Iterate(levelInfo.fStructure, anchor, activeEnd, TRUE, this,
                                                  DoStep(_TSelection::DoToggle2), cmd);

  fReformatType = kSelStyleChgd;
  ResetMenus(&levelInfo);
}


// ------------------------------------------------------------------------
void _TSelection::DoCommit(TCurrency currency, long pos,
                                TCursorNode anchor, TCursorNode activeEnd, TCommand command)
{
  int part;
  Rect custom;
  TStyleTypes kind;
  TStructure subStructure;

  subStructure = GetStructureReadWrite(currency);
  subStructure->GetSelectionKind(anchor, activeEnd, kind, part, custom);
  if (part > 0 || subStructure->HasCompositeStyle()
#ifdef TRACE
          || subStructure->fUndoChanges != 0       // maybe a way round problem below
#endif
           )
    subStructure->CommitStyle(currency, command, abs(part), custom);
  else
  {
    subStructure->Iterate(currency, anchor, activeEnd, TRUE, this,
                                                  DoStep(_TSelection::DoCommit), command);
    // There is a problem with Tables here. If the selection is at the start of a table,
    // and ends outside the table, an InstallStyleChange and any DoToggle2 above calls
    // substructure to set/toggle its fields. When called here though, because part < 0,
    // (which it always seems to be with TColumnStructure::GetSelectionKind), it commits
    // the cells, but not the structure itself! 01/06/96 try clearing the Undo fields.
    subStructure->fUndoChanges = 0;
  }
}


// ------------------------------------------------------------------------
void _TSelection::CommitStyle(TCommand command)
{
  TCursorNode anchor, activeEnd;
  TStructure structure;
  TLevelInfo levelInfo;

  ClearObject(fStyleChanges);
  ClearObject(fUndoChanges);
  if (command != TCommand(-1))
  {
    GetLevelInfo(&levelInfo);
    anchor = GetAnchorOwner();
    activeEnd = GetActiveOwner();

    structure = GetStructureReadWrite(levelInfo.fStructure);
    if (levelInfo.fPart > 0 || structure->HasCompositeStyle())
      structure->CommitStyle(levelInfo.fStructure, command,
                                             Max(1, levelInfo.fPart), levelInfo.fCustom);
    else
      structure->Iterate(levelInfo.fStructure, anchor, activeEnd, TRUE, this,
                                             DoStep(_TSelection::DoCommit), command);
  }
}


// ------------------------------------------------------------------------
static bool ContainsCurrency(TObject null, TCursorNode node, TCurrency currency)
{
  return(currency == node->fCurrency);
}

// ------------------------------------------------------------------------
void _TSelection::GetNodes(TCurrency currency, TCursorNode &anchor, TCursorNode &activeEnd)
{
  TCursorNode node;

  node = TCursorNode(fAnchor->LastThat(NULL, (TestObject)ContainsCurrency, currency));
  anchor = node;
  if (!fCursor)
  {
    node = TCursorNode(fActiveEnd->LastThat(NULL, (TestObject)ContainsCurrency, currency));
  }
  activeEnd = node;
}

// ------------------------------------------------------------------------
void _TSelection::SetTarget()
{
  fTarget = GetTarget(fAnchor, fActiveEnd);
}

// ------------------------------------------------------------------------
int _TSelection::GetTarget(TCursor cursor1, TCursor cursor2)
{
  int index;
  int cursorLevel = 0; // 26/04/90 for safety
  TCursorNode cursNode;
  TCurrency theCurrency;

  if (cursor2 == NULL) 
    cursorLevel = cursor1->GetSize();
  else
  {
    for (index = 1; index <= cursor1->GetSize(); index++)
    {
      cursNode = cursor1->GetNode(index);
#ifdef TRACE
      Assert(cursNode, 188);
#endif
      theCurrency = cursNode->fCurrency;
      if (index > cursor2->GetSize())
        break;
      else
      {
        cursNode = cursor2->GetNode(index);
        if (theCurrency == cursNode->fCurrency)
          cursorLevel = index;
        else
          break;
      }
    }
  }
  return(cursorLevel);
}

// ------------------------------------------------------------------------
void _TSelection::GetLevelInfo(PLevelInfo info)
{
  Get(fPopup, info);
}

// ------------------------------------------------------------------------
TCursorNode _TSelection::GetEndStructure()
{
  TLevelInfo levelInfo;

  Get(fSaveLevel, &levelInfo);
  return(fAnchor->GetNode(levelInfo.fLevel));
}

// ------------------------------------------------------------------------
TCursorNode _TSelection::GetAnchorOwner()
{
  return(fCursor ? fAnchor->GetTarget() : fAnchor->GetNode(fTarget));
}

// ------------------------------------------------------------------------
TCursorNode _TSelection::GetActiveOwner()
{
  return (fCursor ? GetAnchorTarget() : fActiveEnd->GetNode(fTarget));
}

// ------------------------------------------------------------------------
TCursorNode _TSelection::GetAnchorTarget()
{
  return fAnchor->GetTarget();
}

// ------------------------------------------------------------------------
TCursorNode _TSelection::GetActiveTarget()
{
  return fActiveEnd->GetTarget();
}

// ------------------------------------------------------------------------
TCursorNode _TSelection::GetActiveRoot()
{
  return TCursorNode((fCursor ? fAnchor : fActiveEnd)->First());
}

// ------------------------------------------------------------------------
TCursorNode _TSelection::GetAnchorRoot()
{
  return TCursorNode(fAnchor->First());
}

// ------------------------------------------------------------------------
TCursor _TSelection::GetTheCursor()
{
  return (fCursor ? fAnchor : NULL);
}

// ------------------------------------------------------------------------
void _TSelection::SingleClick(TSubView view, VPoint &mousePoint)
{
  TCurrency theCurrency;
  FailInfo fi;

  fAnchor = new _TCursor(this);
  CatchFailures(&fi);
  theCurrency = view->GetStructure();
  fAnchor->NewCursor(theCurrency, view, mousePoint);
  Success(&fi);
  fCursor = TRUE;
  fChanged = TRUE;      // 13/05/94 [21806] ensure menus correctly set up if we get
                        // a menu event before Endclick
  fCrossOver = FALSE;
  SetTarget();
  return;

  // ********* exception handler **********
Rescue:
  Free();
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TSelection::ClickAgain(TSubView view)
{
  // 28/04/92 trap cases where cursors out of sync with view because a drag got in
  if (!fCursor)
  {
    if (GetActiveTarget()->fCurrency != view->fStructure)
    {
      ClearObject(fActiveEnd);
      fCursor = TRUE;
    }
    else if (GetAnchorTarget()->fCurrency != view->fStructure)
    {
      ReplaceObject(fAnchor, fActiveEnd);
      fCursor = TRUE;
    }
  }
  // 28/04/92 end of trap

  if (fCursor)
  {
    // FailNIL(fActiveEnd = TCursor(fAnchor->Clone()));
    fAnchor->MakeClone(&fActiveEnd);
    fCursor = FALSE;
  }
  fAnchor->ClickAgain(view, FALSE);
  fActiveEnd->ClickAgain(view, TRUE);
  SetTarget();
}


// ------------------------------------------------------------------------
void _TSelection::ExtendClick(TSubView view, VPoint &mousePoint)
{
  TCursor cursor;
  TCursor cursorR;
  TCurrency theCurrency;
  int clicks;
  FailInfo fi;

  // Create & init a Cursor object
  cursor = new _TCursor(this);

  CatchFailures(&fi);
  // Create new active end
  theCurrency = view->GetStructure();
  cursor->NewCursor(theCurrency, view, mousePoint);

  if (cursor->GetSize() > 0)
  {
    clicks = GetAnchorTarget()->fClickCount;       // GetClickCount();
    if (clicks == 1)
    {
      if (fCrossOver)                         // 18/04/91 swap cursors
      {
        TCursor cursorS = fAnchor;

        fAnchor = fActiveEnd;
        fActiveEnd = cursorS;
        fCrossOver = FALSE;
      }
      if (cursor->IsCursor(fAnchor))
      {
        view->fMainView->ClearHighlighting(TRUE);
        ClearObject(cursor);
        fCursor = TRUE;
      }
      else
        fCursor = FALSE;
      ReplaceObject(fActiveEnd, cursor);
    }
    else
    {
      view = view->fMainView->FindCursorView(cursor->GetTarget()); // 29/4/92
      cursorR = TCursor(cursor->Clone());
      cursorR->SetClickCount(clicks, view, TRUE);
      cursor->SetClickCount(clicks, view, FALSE);
      if (ComesBefore(fActiveEnd, cursorR) ||
                   (!fCrossOver && ComesBefore(fAnchor, cursorR)))
      {
        FreeIfObject(cursor);
        if (fCrossOver)
        {
          DoClone(fActiveEnd, FALSE);  // 01/10/91
          view = view->fMainView->FindCursorView(GetAnchorTarget()); // 21/03/91
          fAnchor->SetClickCount(clicks, view, FALSE);
        }
        fCrossOver = FALSE;
        ReplaceObject(fActiveEnd, cursorR);
      }
      else if (ComesBefore(cursor, fAnchor) ||
                        (fCrossOver && ComesBefore(cursor, fActiveEnd)))
      {
        FreeIfObject(cursorR);
        if (!fCrossOver)
        {
          DoClone(fAnchor, TRUE);  // 01/10/91
          view = view->fMainView->FindCursorView(GetActiveTarget()); // 21/03/91
          fActiveEnd->SetClickCount(clicks, view, TRUE);
        }
        fCrossOver = TRUE;
        ReplaceObject(fAnchor, cursor);
      }
      else
      {
        FreeIfObject(cursor);
        FreeIfObject(cursorR);
      }
    }
  }
  Success(&fi);
  SetTarget();
  return;

  // *********** exception handler *****************
Rescue:
  Free();
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TSelection::EndClick()
{
  // TCursorNode owner;

  fChanged = TRUE;
  // not used: owner = GetAnchorOwner();
  if (!fCursor)
  {
    if (GetAnchorTarget()->fClickCount == 1 && ComesBefore(fActiveEnd, fAnchor))
    {
      TCursor cursor = fAnchor;

      fAnchor = fActiveEnd;
      fActiveEnd = cursor;
      fCrossOver = TRUE;
    }
  }
  DoSetupMenus(TRUE);  // 08/02/91 for DoSetupLevels();
}


// ------------------------------------------------------------------------
void _TSelection::Highlight(TMainView mainView, bool redraw)
{
  TCursorNode anchor, activeEnd, temp;
  TCursorNode owner;
  TStructure structure;

  anchor = GetAnchorRoot();
  owner = GetAnchorOwner();
  structure = GetStructureReadOnly(owner->fCurrency);
  if (fCursor && structure->CanType())  // 18/09/90 CanType() added
  {
    mainView->SetTheCursor(TRUE);
    activeEnd = NULL;
  }
  else
  {
    mainView->SetTheCursor(FALSE);
    if (fCursor)
      activeEnd = anchor;
    else
    {
      activeEnd = GetActiveRoot();
      if (structure->SwapNodes(owner, GetActiveOwner()))
      {
        temp = anchor;
        anchor = activeEnd;
        activeEnd = temp;
      }
    }
  }

  if (fCursor && mainView->Focus())
    GetAnchor()->Connect(mainView); // ensure the caret moved to correct position after a redraw

  mainView->HighlightSelection(anchor, activeEnd, redraw);
}


// ------------------------------------------------------------------------
void _TSelection::SetTheCursor(bool atAnchor)
{
  if (!fCursor)
  {
    if (atAnchor)
    {
      fAnchor->SetClickCount(1, NULL, FALSE);
      ClearObject(fActiveEnd);
    }
    else
    {
      fActiveEnd->SetClickCount(1, NULL, TRUE);
      ReplaceObject(fAnchor, fActiveEnd);
    }
    fActiveEnd = NULL;
    fCursor = TRUE;
    fChanged = TRUE;
    fCrossOver = FALSE;      // 05/03/91
    SetTarget();
  }
}


// ------------------------------------------------------------------------
void _TSelection::ToggleState(TCommand command)
{
  TCursorNode anchorRoot;
  TCursorNode activeRoot;
  TStructure structure;
  TCurrency currency;

  anchorRoot = GetAnchorRoot();
  activeRoot = GetActiveRoot();
  currency = anchorRoot->fCurrency;
  structure = GetStructureReadWrite(currency);
  structure->ToggleState(currency, anchorRoot, activeRoot, command);
  fReformatType = kSelSlow;
  fChanged = TRUE;
}


// ------------------------------------------------------------------------
bool _TSelection::ComesBefore(TCursor cursorL, TCursor cursorR)
{
  int index;
  TStructure owner;
  TCursorNode nodeL, nodeR;

  index = GetTarget(cursorL, cursorR);
  nodeL = cursorL->GetNode(index);
  nodeR = cursorR->GetNode(index);
  owner = GetStructureReadOnly(nodeL->fCurrency);
  return(owner->SwapNodes(nodeR, nodeL));
}


// ------------------------------------------------------------------------
void _TSelection::DoClone(TCursor cursor, bool activeEnd)
{
  ReplaceObject(activeEnd ? fActiveEnd : fAnchor, TCursor(cursor->Clone()));
}


// ------------------------------------------------------------------------
void _TSelection::UpdateScopeLeft(TCursor cursor, bool doRight) // 07/02/94 new method
{
  if (fCursor)
  {
    fActiveEnd = TCursor(fAnchor->Clone());
    fCursor = FALSE;
  }

  if (cursor != NULL)
  {
    if (doRight && ComesBefore(fActiveEnd, cursor))  // 07/02/94 test for right update
        DoClone(cursor, TRUE);
    else if (ComesBefore(cursor, fAnchor))
        DoClone(cursor, FALSE);
  }
}


// ------------------------------------------------------------------------
void _TSelection::UpdateScope(TCursor cursor)
{
  UpdateScopeLeft(cursor, TRUE);
}


// ------------------------------------------------------------------------
void _TSelection::GetNodesToReformat(TCursorNode &start, TCursorNode &finish)
{
  start = GetAnchorRoot();
  finish = GetActiveRoot();
}

// ------------------------------------------------------------------------
#ifdef THESAURUS
TCommand _TSelection::FindSynonym()
{
  // could pass 2 cursors when more than one word selected
  TCursorNode anchorNode = GetAnchorOwner();

  fDocument->GetStructureReadOnly(anchorNode->fCurrency)->
                                        FindSynonym(anchorNode, anchorNode);
  return gNoChanges;
}
#endif


// ------------------------------------------------------------------------
static void ComputeDiscSpace(TObject null, TCursorNode node, long* dataForkBytes)
{
  *dataForkBytes += node->NeededDiskSpace();
}

// ------------------------------------------------------------------------
long _TSelection::DoNeedDiskSpace(long dataForkBytes)
{
  dataForkBytes = sizeof(TDiscSelection);    // TSelection is not overridden
  if (fAnchor != 0)
    fAnchor->Each(NULL, (DoToObject)ComputeDiscSpace, &dataForkBytes);
  if (fActiveEnd != 0)
    fActiveEnd->Each(NULL, (DoToObject)ComputeDiscSpace, &dataForkBytes);
  return dataForkBytes;
}


// ------------------------------------------------------------------------
static void DoSave(TObject null, TCursorNode node, int aRefNum)
{
  node->WriteObject(aRefNum, -1);
}


// ------------------------------------------------------------------------
static void SaveCursor(TCursor aCursor, int aRefNum)
{
  if (aCursor != NULL)
    aCursor->Each(NULL, (DoToObject)DoSave, aRefNum);
}

// ------------------------------------------------------------------------
void _TSelection::DoWrite(int aRefNum, long remainder)
{
  TDiscSelection discSelection;

  // 13/02/92 MUST NOT CALL THINGS WHICH DO FAILSPACEISLOW!!!  SelectLevel(-2);
  // ... NOW MUST NOT SAVE DOCS WITH ENDSTRUCTURE SET
  discSelection.anchorPos = (fAnchor == NULL ? -1 : fAnchor->GetSize());
  discSelection.activeEndPos = (fActiveEnd == NULL ? -1 : fActiveEnd->GetSize());
  discSelection.endStructure = fEndStructure;
  discSelection.saveLevel = fSaveLevel;
  discSelection.viewId = fViewId;
  discSelection.popup = fPopup;        // 08/02/91 2 new fields
  discSelection.base = fBase;

  FWrite(aRefNum, sizeof(TDiscSelection), &discSelection);

  SaveCursor(fAnchor, aRefNum);
  SaveCursor(fActiveEnd, aRefNum);
}


// ------------------------------------------------------------------------
TCursor _TSelection::LoadCursor(long cursorPos, int aRefNum, int version)
{
  TCursor  aCursor;
  FailInfo fi;
      
  if (cursorPos == -1)
    return NULL;

  aCursor = new _TCursor(this);
  CatchFailures(&fi);

#ifdef VERS0
  if (version == 0)
    // version 0 saves the count of nodes here
    FRead(aRefNum, sizeof(TDiscCursor), &cursorPos);
#endif

  while (cursorPos > 0)
  {
    TCurrency currency;
    TStructure structure;
    TCursorNode node;
    long tempPos;

    GetFPos(aRefNum, tempPos); // save as file pos will be changed
    FRead(aRefNum, sizeof(TCurrency), &currency);
    structure = GetStructureReadOnly(currency);
    node = structure->NewCursorNode();
    node->ReadObject(aRefNum, tempPos, version);
//    node->fCursor = aCursor;
//    aCursor->InsertLast(node);
    aCursor->AddTarget(node);   // 01/10/91

    cursorPos--;
  }

  Success(&fi);
  return aCursor;

// ******* exception handler *************
Rescue:
  FreeIfObject(aCursor);
  // aCursor->Free();
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TSelection::DoRead(int aRefNum, long remainder, int version)
{
  TDiscSelection discSelection;
  long position;

  FRead(aRefNum, sizeof(TDiscSelection), &discSelection);

  fAnchor = LoadCursor(discSelection.anchorPos, aRefNum, version);
  fActiveEnd = LoadCursor(discSelection.activeEndPos, aRefNum, version);

  GetFPos(aRefNum, position);    // save file pos

  // 19/02/92 new to recover a cursor if doc saved with end struct set
  if (discSelection.endStructure
#ifdef TRACE
         || fAnchor == NULL || fAnchor->fSize == 0  // 07/05/93
#endif
      )
  {
    ClearObject(fAnchor);
    ClearObject(fActiveEnd);
    InitialCursor(fDocument->ActiveMainView(), gNullCurrency, 0);
    DoSetupLevels();
    fDocument->SetCurrentStyle();
  }
  else
  {
    fEndStructure = discSelection.endStructure;
    fSaveLevel = discSelection.saveLevel;
    fViewId = discSelection.viewId;
    fPopup = discSelection.popup;             // 08/02/91 2 new fields
    fBase = discSelection.base;

    fCursor = (fActiveEnd == NULL);
    // 14/05/91 in case saved with selection in hidden header/footer
    // fAnchor->GetNode(1)->fIdentifier = fViewId.fId;
    // if (fActiveEnd != NULL)
    //   fActiveEnd->GetNode(1)->fIdentifier = fViewId.fId;
    // 17/02/94 replace 3 lines above - will set anchor twice if fActiveEnd == NULL
    GetAnchorRoot()->fIdentifier = fViewId.fId;
    GetActiveRoot()->fIdentifier = fViewId.fId;

    SetTarget();
    fChanged = TRUE;
    fStyleChanges = NULL;
    fUndoChanges = NULL;
  }
  SetFPos(aRefNum, position);    // restore if corrupted above
}

#ifdef TRACE
// ------------------------------------------------------------------------
void _TSelection::DoReadArrayPart(int aRefNum, int version)
{
  // nothing is saved for the array part
}


// ------------------------------------------------------------------------
void _TSelection::DoWriteArrayPart(int aRefNum)
{
  // nothing is saved for the array part
}
#endif

// ------------------------------------------------------------------------
static bool HasMouse(TObject null, TView theView, VPoint* mousePoint, TSubView* mouseView)
{
  // 18/09/90 - uses LastSubViewThat rather than FirstSubViewThat
  VPoint aPoint;
  TSubView foundView;

  aPoint = *mousePoint;
  theView->SuperToLocal(aPoint);
  if (theView->IsViewEnabled() &&               // 11/06/93 [20934] ensure view enabled
              theView->ContainsMouse(aPoint))
  {
    *mousePoint = aPoint;
    foundView = TSubView(theView->LastSubViewThat(NULL,
                        (TestSubView)HasMouse, mousePoint, mouseView));
    if (foundView == NULL || *mouseView == NULL)
      *mouseView = foundView;

    return TRUE;
  }

  return FALSE;
}

// ------------------------------------------------------------------------
#ifdef DRAGDROP
// THE ORIGINAL TSELECTOR METHODS FOLLOW THE #ELSE
bool _TSelection::InCurSelection(TCursor node)
{
  if (fTarget <= node->GetSize())
  {
    TCursorNode anchorNode = fAnchor->GetNode(fTarget);
    TCursorNode nodeAtTarget = node->GetNode(fTarget);

    if (anchorNode->fCurrency == nodeAtTarget->fCurrency)
    {
      return GetStructureReadOnly(nodeAtTarget->fCurrency)->
            WithinSelection(anchorNode, fCursor ? anchorNode : fActiveEnd->GetNode(fTarget),
                                        nodeAtTarget);
    }
  }
  return FALSE;
}

// ------------------------------------------------------------------------
_TSelector::_TSelector(TMainView itsMainView, TSubView itsSubView) :
        (cMouseCommand, itsMainView->fDocument, itsMainView,
                                           itsMainView->GetScroller(FALSE))
{
  TTextDocument doc = TTextDocument(itsMainView->fDocument);

  fSubView = itsSubView;
#ifdef FN
  fInitialView = itsSubView;  // 17/05/93 [20878]
#endif
#ifndef ZERO_OBJ
  fDragDrop = 0;
  fConstraintSel = NULL;
  fGhostCursor = NULL;
  fPasteView = NULL;
  fClickCount = 0;
#endif
}

// ------------------------------------------------------------------------
void _TSelector::Free()
{
  FreeIfObject(fConstraintSel);
  FreeIfObject(fGhostCursor);
  _TCommand::Free();
}


#ifdef FN
// ------------------------------------------------------------------------
static TCurrency IsViewPartOfFN(TTextDocument theDocument, TSubView theView)
// 11/06/93 [20929] prohibit dragging to left edge of footnote from outside
{
  TStructure structure = theDocument->GetStructureReadOnly(theView->fStructure);

  return (structure->GetKind() == kFootnote ?
                  theView->fStructure : structure->IsPartOf(1 << kFootnote));
                  // 24/01/94 IsPartOf passed a set of TStyleTypes
}

// ------------------------------------------------------------------------
static bool CanAddToSelection(TTextDocument theDocument, TSubView anchorView,
        TSubView targetView)
{
//  TCurrency s1 = theDocument->GetStructureReadOnly(anchorView->fStructure)->IsPartOf(kFootnote);
//  TCurrency s2 = theDocument->GetStructureReadOnly(targetView->fStructure)->IsPartOf(kFootnote);
  TCurrency s1 = IsViewPartOfFN(theDocument, anchorView);  // 11/06/93 [20929]
  TCurrency s2 = IsViewPartOfFN(theDocument, targetView);  // 11/06/93 [20929]

  if (s1 == 0 && s2 == 0) // 15/7/92
    return theDocument->GetStructureReadOnly(targetView->fStructure)->GetKind() != kNoteSet;
  return s1 == s2;
}
#endif

// ------------------------------------------------------------------------
TCommand _TSelector::TrackMouse(TrackPhase aTrackPhase, VPoint &anchorPoint,
VPoint &previousPoint, VPoint &nextPoint, bool mouseDidMove, EventInfo &info)
{
  // TCommand theTracker;
  TTextDocument theDocument;
  TSelection theSelection;
  bool singleClicked;
  bool extendPress = FALSE;

  // drag entering another window
  if (aTrackPhase == trackPress && info.theClickCount == 0)
  {
//    fMouseMoved = TRUE;
    // read info.trackingKey to see what is on the clipboard
    if (fDragDrop == 0)
      // we are entering a new window
      fDragDrop = info.trackingKey; 
      // else we are re-entering the originator
    aTrackPhase = trackMove;  // avoid the trackpress initialisations
  }
  // theTracker = this;
  theDocument = TTextDocument(fChangedDocument);

  if (info.rightButton && aTrackPhase == trackPress)
  {
    aTrackPhase = trackMove;
    // 18/04/91 2 lines added for commiting adjust clicks
    theDocument->DoneTyping();
    theSelection = theDocument->CloneSelection();
#ifdef FN
    fInitialView = TSubView(fView->FindSubView(theSelection->GetAnchorTarget()->fIdentifier));
                                                  // 17/05/93 [20878]
#endif
    extendPress = TRUE;  // 27/10/93 [21101]
  }
  theSelection = theDocument->GetNewSelection();

  switch (aTrackPhase)
  {
  case trackPress:
    // 13/07/90 to avoid problems of a double click hitting 2 different views
    singleClicked = (info.theClickCount == 1);
    theDocument->DoneTyping();        // 28/01/91 moved from below
    if (!singleClicked)
    {
      // 28/04/92 test for non-cursor to avoid same problem if a move got in
      if (theSelection->GetAnchorOwner()->fCurrency != fSubView->fStructure)
        singleClicked = TRUE;
    }
    if (singleClicked || info.theClickCount != 2)
    {
      TMainView(fView)->TrackingMouse();    // 15/04/91 moved from ctor
      theDocument->EndInteractive();  // 19/10/90
      ClearObject(fPasteSelection);
      // FreeIfObject(fPasteSelection);
      // fPasteSelection = NULL;
      fPasteView = NULL;
      ClearObject(fConstraintSel);
      // FreeIfObject(fConstraintSel);
      // fConstraintSel = NULL;
      theSelection = theDocument->GetNewSelection(); 
      if (!theSelection->fCursor || fDragDrop)
      {
        if (!fDragDrop)
          fConstraintSel = TSelection(theSelection->ShallowClone());

        if (fDragDrop || fConstraintSel != NULL)
        {
          TSelection newSel = new _TSelection(theDocument);
     
          newSel->SingleClick(fSubView, nextPoint);
          
          if (fDragDrop && theSelection->InCurSelection(newSel->GetAnchor()))
          {
            fDragDrop = 0; // found out pic inside current selection
            //FailNIL(fConstraintSel = TSelection(theSelection->Clone()));
            theSelection->MakeClone(&fConstraintSel);
          }

          if (fDragDrop) // clicked on a picture, make it the selection in case drag/drop
          {
            if (theDocument->fSelectionChanged)
              FreeIfObject(theSelection);
            theSelection = newSel;
            theDocument->fNewSelection = newSel;
            newSel = NULL;
            theDocument->fSelectionChanged = TRUE;
            // !!! do before tracking?
            TMainView(fView)->ClearHighlighting(TRUE);
            theSelection->EndClick();
            theSelection->Highlight(fSubView->fMainView, kRedraw); 
            theDocument->SetCurrentStyle();
            theDocument->SetTextHandler();
          }
          else
            theSelection = newSel;

          if (fConstraintSel == NULL)
            // FailNIL(fConstraintSel = TSelection(theSelection->Clone()));
            theSelection->MakeClone(&fConstraintSel);
          if (fConstraintSel->InCurSelection(theSelection->GetAnchor())
#if SIDEBAR == 1
             && GetRsrcOption('s') == NULL  // suppress D&D with s option
#endif
              )
            fDragDrop = theDocument->GetSelectionFlags();
          if (fDragDrop)
          {
            TCursorNode root = fConstraintSel->GetAnchorRoot();
            TSubView ownerView = TMainView(fView)->FindCursorView(root);
            TCursorNode owner1;
            TCursorNode owner2;

            SetRect(TMainView(fView)->fZoomBox, MAXLONGINT, MAXLONGINT, 0, 0);
            // passing 2 for redraw param causes SetHighlight to generate fZoomBox
            // ownerView->SetHighlight(root, fConstraintSel->GetActiveRoot(), 2, FALSE);
            TMainView(fView)->HighlightSelection(root, fConstraintSel->GetActiveRoot(), 2);
                       // 21/06/96 use root rather than owner to avoid crash on split views
            MoveRect(fInitialRect, TMainView(fView)->fZoomBox);

            fFeedbackBox = wr_wimp_USER_FIXED; // blue dashed box
            info.trackingKey = fDragDrop;
                       // inform application this is a drag and indicate what is selected
#ifdef DRAWSAVE
            TMainView(fView)->InPage(anchorPoint); // tell it which page to save
#endif
            owner1 = fConstraintSel->GetAnchorOwner();
            owner2 = fConstraintSel->GetActiveOwner();
            if (owner1->GetNext() != NULL && owner2->GetNext() != NULL)
            {
              TCurrency c1 = owner1->GetNext()->fCurrency;
              TCurrency c2 = owner2->GetNext()->fCurrency;

              owner1->Collapse();
              owner2->Collapse();
              theDocument->GetStructureReadOnly(c1)->
                ExtendCursor(owner1, c1, FALSE, TRUE, FALSE);
              theDocument->GetStructureReadOnly(c2)->
                ExtendCursor(owner2, c2, TRUE, TRUE, FALSE);
            }
            fGhostCursor = newSel;
            // SetCursor(GetCursor(13));
          }
          else
            FreeIfObject(newSel);
        }        
      }
      
      if (!fDragDrop && info.theClickCount == 1)
      {
        TMainView(fView)->ClearHighlighting(TRUE);
        theSelection = theDocument->StartNewSelection();
        theSelection->SingleClick(fSubView, nextPoint);
      }
    }
    else
      theSelection->ClickAgain(fSubView);
    fClickCount = info.theClickCount;
    break;

  case trackMove:
    {
      VPoint mousePoint = nextPoint;
      TSubView mouseView = NULL;
      TView sv = fView->LastSubViewThat(NULL, (TestSubView)HasMouse,
                                                       &mousePoint, &mouseView);
      if (sv != NULL && mouseView != NULL)
      {
        // 18/01/94 [21347], [21348] whole of dragdrop clause outside FindViewToTrack test
        if (fDragDrop)
        {
          fSubView = mouseView;
          ReplaceObject(fGhostCursor, new _TSelection(theDocument));
          // FreeIfObject(fGhostCursor);
          // fGhostCursor = new _TSelection(theDocument);
          fGhostCursor->SingleClick(fSubView, nextPoint);
          fGhostCursor->fViewId.fId =
                  TCursorNode(fGhostCursor->fAnchor->First())->fIdentifier;
                  // 13/08/93 [21024] To reformat & build views for drops in H/F
          if (mouseDidMove)
          {
            fMouseMoved = TRUE;
            ClearObject(fPasteSelection);
            // FreeIfObject(fPasteSelection);
            if ((fConstraintSel != NULL &&       // no constraint or outside orig selection
                fConstraintSel->InCurSelection(fGhostCursor->GetAnchor()))
                // 18/10/93 [21089] move down dragging non-picture test after InCurSelection
                // 28/4/93 test to prevent non-pict being dropped on a pict
                || (Curr_fType(mouseView->fStructure) == kPictStruct &&
                     (fDragDrop & ~(kSpriteSelected + kDrawSelected)) != 0))
            {
              // 2/5/93 moved back inside selection (or over a pict when dragging non-pict)
              // fPasteSelection = NULL;
              ClearObject(fGhostCursor);
              // FreeIfObject(fGhostCursor);
            }
            else 
            {
              fPasteSelection = fGhostCursor;
              fPasteView =            // 30/07/93 needs to be ghost target not: fSubView;
                TSubView(fSubView->FindSubView(fGhostCursor->GetAnchorOwner()->fIdentifier));
              fGhostCursor = NULL;
            }
          }      
        }
        else
        {
          // not drag drop, so can do test for selection extended into h/f footnotes, etc.
          // 18/09/90 inline:  FindViewToTrack(nextPoint, targetView,
          //                                   *((TViewId *)&anchor->fIdentifier));
          TViewId lastViewId;

          lastViewId.fId = theSelection->GetAnchorRoot()->fIdentifier;

          if (           // test above: sv != NULL && mouseView != NULL &&
            lastViewId.tag.fSubId == PViewId(&sv->fIdentifier)->tag.fSubId &&
            (lastViewId.tag.fSubId == 0 ||
                      lastViewId.tag.fColNum == PViewId(&sv->fIdentifier)->tag.fColNum)
#ifdef FN
            && CanAddToSelection(theDocument, fInitialView /*anchVw*/, mouseView) // [20878]
#endif
            )
          // end inline FindViewToTrack
          {
            fSubView = mouseView;
            theSelection->ExtendClick(fSubView, nextPoint);

            // 27/10/93 [21101] With delayed dragging we cannot rely on TrackFeedback doing
            // the work before a redraw gets in (eg extend click with a menu up)
            if (extendPress)
              theSelection->Highlight(fSubView->fMainView, TRUE);
          }
        }
      }
    }
    break;

  case trackRelease:
    if (fDragDrop && InsideHysteresis(anchorPoint, nextPoint))
    {
      fDragDrop = 0;
      if (fClickCount == 1)
      {
        TMainView(fView)->ClearHighlighting(TRUE);
        // it is really a click not a drag
        if (fGhostCursor != NULL)
        {
          if (theDocument->fSelectionChanged)
            FreeIfObject(theSelection);
          theDocument->fSelectionChanged = TRUE;
          theDocument->fNewSelection = fGhostCursor;
          theSelection = TSelection(fGhostCursor); // do not remove this line...
          fGhostCursor = NULL;
        }
      }
    }
    if (!fDragDrop)
    {
      if (fClickCount >= 3)
      {
        // TMainView(fView)->ClearHighlighting(TRUE);   // 29/09/93
        theSelection->ClickAgain(fSubView);
        // 09/04/93 TrackFeedback(anchorPoint, nextPoint, TRUE, FALSE);        
      }
      theSelection->EndClick();
      theSelection->Highlight(fSubView->fMainView, kRedraw);    // 09/04/93 put caret back?
      theDocument->SetCurrentStyle();
      theDocument->SetTextHandler();
#if SIDEBAR == 1
      fSubView->DoEndClick();
#endif
    }
    return gNoChanges;

  case trackDrop:       // 06/01/95 [23024] generic handling of drops (moved from UApplicat)
    {
      TObject pasteSel = fPasteSelection;

      if (pasteSel == NULL)
        return gNoChanges;     // 08/03/95 [24001] needs gNoChanges to tidy up in UApp

      fPasteSelection = NULL;       // ensure not freed, since handed over to Move command
      return gApplication->DoMakeMoveCommand(pasteSel, theDocument, kMoveCommand);
    }
  }
  return this;
}


// ------------------------------------------------------------------------
void _TSelector::TrackFeedback(VPoint &anchorPoint, VPoint &nextPoint, bool turnItOn,
         bool mouseDidMove)
{
  if (fDragDrop)
  {
    SetCursor(GetCursor(13));
    if (mouseDidMove && fPasteSelection != NULL && fPasteView->Focus())
    {
      TCursorNode cursorNode = TSelection(fPasteSelection)->GetAnchorOwner();

      fPasteView->DrawGhostCaret(cursorNode);
      gPointerAltered |= 2;  // 17/08/95 [26062] while dragging, once ghost on, stays on
    }
  }
  else if (turnItOn)
    TTextDocument(fChangedDocument)->GetNewSelection()->Highlight(fSubView->fMainView, TRUE);
}

#else

// ------------------------------------------------------------------------
_TSelector::_TSelector(TMainView itsMainView, TSubView itsSubView) :
        (cMouseCommand, itsMainView->fDocument, itsMainView,
                                           itsMainView->GetScroller(FALSE))
{
//  fInfo = info;
  fSubView = itsSubView;
#ifdef FN
  fInitialView = itsSubView;  // 17/05/93 [20878]
#endif
// 20/10/92  fTrackNonMovement = TRUE;
//  fViewConstrain = FALSE;
//  itsMainView->TrackingMouse();
}


#ifdef FN
// ------------------------------------------------------------------------
static bool CanAddToSelection(TTextDocument theDocument, TSubView anchorView,
        TSubView targetView)
{
                 // 24/01/94 IsPartOf passed set of TStyleTypes
  TCurrency s1 = theDocument->GetStructureReadOnly(anchorView->fStructure)->
                 IsPartOf(1 << kFootnote);
  TCurrency s2 = theDocument->GetStructureReadOnly(targetView->fStructure)->
                 IsPartOf(1 << kFootnote);

  if (s1 == 0 && s2 == 0) // 15/7/92
    return theDocument->GetStructureReadOnly(targetView->fStructure)->GetKind() != kNoteSet;
  return s1 == s2;
}
#endif

// ------------------------------------------------------------------------
TCommand _TSelector::TrackMouse(TrackPhase aTrackPhase, VPoint &anchorPoint,
VPoint &previousPoint, VPoint &nextPoint, bool mouseDidMove, EventInfo &info)
{
  TCommand theTracker;
  TTextDocument theDocument;
  TSelection theSelection;
  bool singleClicked;

  theTracker = this;
  theDocument = TTextDocument(fChangedDocument);

  if (info.rightButton && aTrackPhase == trackPress)
  {
    aTrackPhase = trackMove;
    // 18/04/91 2 lines added for commiting adjust clicks
    theDocument->DoneTyping();
    theSelection = theDocument->CloneSelection();
#ifdef FN
    fInitialView = TSubView(fView->FindSubView(theSelection->
                              GetAnchorTarget()->fIdentifier));  // 17/05/93 [20878]
#endif    
  }
  theSelection = theDocument->GetNewSelection();

  switch (aTrackPhase)
  {
  case trackPress:
    // 13/07/90 to avoid problems of a double click hitting 2 different views
    singleClicked = (info.theClickCount == 1);
    theDocument->DoneTyping();        // 28/01/91 moved from below
    if (!singleClicked)
    {
      // 28/04/92 test for non-cursor to avoid same problem if a move got in
      if (theSelection->GetAnchorOwner()->fCurrency != fSubView->fStructure)
        singleClicked = TRUE;
    }
    if (singleClicked)
    {
      TMainView(fView)->TrackingMouse();    // 15/04/91 moved from ctor
      theDocument->EndInteractive();  // 19/10/90
      TMainView(fView)->ClearHighlighting(TRUE);
      theSelection = theDocument->StartNewSelection();
      theSelection->SingleClick(fSubView, nextPoint);
    }
    else
      theSelection->ClickAgain(fSubView);
    break;

  case trackMove:
    // 18/09/90 inline:  FindViewToTrack(nextPoint, targetView,
    //                                   *((TViewId *)&anchor->fIdentifier));
    {
      TViewId lastViewId;

      lastViewId.fId = theSelection->GetAnchorRoot()->fIdentifier;
      VPoint mousePoint = nextPoint;
      TSubView mouseView = NULL;
      TView sv = fView->LastSubViewThat(NULL, (TestSubView)HasMouse,
                                    &mousePoint, &mouseView);

      if (sv != NULL && mouseView != NULL &&
        lastViewId.tag.fSubId ==
                              PViewId(&sv->fIdentifier)->tag.fSubId &&
        (lastViewId.tag.fSubId == 0 || lastViewId.tag.fColNum ==
                              PViewId(&sv->fIdentifier)->tag.fColNum)
#ifdef FN
        && CanAddToSelection(theDocument, fInitialView /*anchorView*/, mouseView) // [20878]
#endif
    )
    // end inline FindViewToTrack
      {
        fSubView = mouseView;
        theSelection->ExtendClick(fSubView, nextPoint);
      }
    }
    break;

  case trackRelease:
    theSelection->EndClick();
    theDocument->SetCurrentStyle();
    theDocument->SetTextHandler();
    theTracker = gNoChanges;
    break;
  }

  return theTracker;
}


// ------------------------------------------------------------------------
void _TSelector::TrackFeedback(VPoint &anchorPoint, VPoint &nextPoint, bool turnItOn, bool mouseDidMove)
{
//  TTextDocument theDocument;
  TSelection theSelection;

  if (turnItOn)
  {
// 14/02/91 use fChangedDocument instead of fSubView->fDocument
//    theDocument = TTextDocument(fSubView->fDocument);
//    theSelection = theDocument->GetNewSelection();
    theSelection = TTextDocument(fChangedDocument)->GetNewSelection();
    theSelection->Highlight(fSubView->fMainView, TRUE);
  }
}
#endif
