/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

//
//  fDocument
//    || fBody
//    ||
//    \/
//  Body(kDocument)   <============||
//    ||   /\                    Body(kNoteSet)  <--- GetNoteCollector()
//    \/   ||                      ||   /\
//  Body(kChapter)...              \/   ||
//    ||   /\         fReference Body(kFootnote)...
//    \/   ||             |====    ||   /\
//  Body(kList, etc)...   ||       \/   ||
//    ||   /\             ||     Paragraphs(etc)...
//    \/   ||             ||
//  Paragraphs(etc)... <===|
//
//                             kChapter/kDocument <-- GetNoteContainer(noteCurr) 
//

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include "font.h"

#include "UBodyEdit.h"
#include "PBodyEdit.h"
#include "UTextComm.h"
#include "DrawIFace.h"


#define GetBodyKind() fKind

#ifdef FN
#define cFNPage       92
#define cFNEndDoc     93
#define cFNEndChap    94
#define cFNNumbers    95
#define cFNSymbols    96
#define cFNStartNum   97
#define cFNStartNumMenu 98
#endif

#define kSaveStyleDlgID 15
#define kRuleDescrs 40

// rsrc msg with start chapter popup
#define kStartChapterText 36
#define mHeaderAlign 37
#define kStyleAttributes 206
#define cListChanges 452
   /* for use in GetString - Chapter dlg header == xxx Style Attributes */
#define kIntroTxt 39
#define TopLeftCaption(x) (((1 << x) & 6) != 0) 
#define BotRightCaption(x) (((1 << x) & 9) != 0) 
#define TOGGLESTATE(x) x ^= 1
#define NULLorMinus1(x) ((unsigned int)x + 1 <= 1)
#define TestInHF(str) (str->fKind == kHeader || str->fKind == kFooter || str->IsPartOf((1 << kHeader) | (1 << kFooter)))

#define kPageTurnover 0x8000
#define InSet2(X, A, B) ((((1 << (31 - (A))) | (1 << (31 - (B)))) << (X)) < 0)
#define InSet3(X, A, B, C) ((((1 << (31 - (A))) | (1 << (31 - (B))) | (1 << (31 - (C)))) << (X)) < 0)
// this constant is used in the SaveStyleDlg to set up the
// max size of the array to hold the structure types
#define kPopupSize 40

typedef struct TBodyViewDrawList
   {
      unsigned a;
      unsigned b;
      unsigned c;
      unsigned d;
      unsigned e;
      unsigned f;
      unsigned g;
      unsigned h;
   } TBodyViewDrawList;


typedef struct TBodyIterateList
   {
      unsigned a;
      unsigned b;
      unsigned c;
      unsigned d;
      unsigned e;
      unsigned f;
      unsigned g;
      unsigned h;
   } TBodyIterateList;

#ifdef FN
typedef struct TNoteBreak
   {
      int nextNoteNum;
      TObject noteBreakIn;
      TObject noteBreakOut;
      bool first;
   } TNoteBreak;

static TCurrency gNoteContainer;
static TArray gBreakStack; // 22/4/92

static void CollapseBreakStack(int newSize)
// 27/04/92 new to clear up break stack break objects
{
  int oldSize = gBreakStack->fSize;

  for (int i = newSize + 1; i <= oldSize; i++)
  {
    TNoteBreak *noteInfo = (TNoteBreak *)gBreakStack->At(i);

    if (noteInfo->noteBreakOut != noteInfo->noteBreakIn)
      FreeIfObject(noteInfo->noteBreakIn);
    FreeIfObject(noteInfo->noteBreakOut);
  }
  gBreakStack->ReduceSize(newSize);
}

void ReallocBreakStack()
/* move gBreakStack array handle down store (e.g. after document free) */
{
  ReAllocHandle(&gBreakStack->fPtrToArray);
}
#endif

// ++++++++++++++++++++++++ Start of Structure ++++++++++++++++++++++++++


typedef TCurrency TBDiscNode;


// ------------------------------------------------------------------------
void IUBodyEditor()
{
#ifdef FN
// 22/4/92
  gBreakStack = new _TArray(sizeof(TNoteBreak));
#endif
}


// ------------------------------------------------------------------------
static int FirstVisibleFrom(TBodyStructure body, int index)
 // 19/03/91 new
{
  int realFirst = index;

  while (realFirst <= body->_GetSize() &&           // 04/04/91
                        body->GetItemState(realFirst) == kHidden)
    realFirst++;

  return realFirst;
}


// ------------------------------------------------------------------------
void _TBodyStructure::IBodyStructure(TCurrency itsParent, TCurrency itsStyle,
                                                       TStyleTypes itsKind)
{
   fKind = itsKind;
   _TStructure::IStructure(itsParent, itsStyle);
}


// ------------------------------------------------------------------------
_TBodyStructure::_TBodyStructure(TTextDocument itsDocument, TStyleTypes itsKind)
         : (itsDocument, sizeof(TBodyItem))
{
   fKind = itsKind;
   fLastHit = 1;
   fCaption = kBtmCaption;

#ifndef ZERO_OBJ
   fLinkedBody = NULL;
   fLinkedBodyC  = 0;
   fDeletions = FALSE;
   fCanSplit = FALSE;
   fHeadingType = kNoHeading;
   // fn1
   fChapEndNotes = FALSE;
   fAutoNumber = FALSE;
   fFootnotes = gNullCurrency;
   fReference = gNullCurrency;
#endif
}

// ------------------------------------------------------------------------
long _TBodyStructure::DoNeedDiskSpace(long dataForkBytes)
{
  return _TStructure::DoNeedDiskSpace(dataForkBytes + 13 /* fn1 */ -
     fSize * (int(sizeof(TBodyItem)) - int(sizeof(TCurrency)) - 2) - /* 19/08/92 fn: - 2 */
               int(sizeof(_TBodyStructure)) + int(sizeof(_TStructure)));
}

// ------------------------------------------------------------------------
void _TBodyStructure::DoRead(int aRefNum, long remainder, int version)
{
#ifdef VERS0
  if (version == 0)
    _TStructure::DoRead(aRefNum, remainder, version);        // the whole lot
  else
#endif
  {
    // fn1 footnotes in version 2
    char buffer[13];

    _TStructure::DoRead(aRefNum, sizeof(_TStructure), version);   // the inherited bits

    FRead(aRefNum, (version == 1 ? 3 : 13), buffer);
    UnpackRecord((version == 1 ? 0x15 : 0x555),
                 (version == 1 ? "\x01\x03\x01\x07\x01\x13" : 
                                 "\x01\x03\x01\x07\x01\x13\x01\x03\x01\x03\x08"), 
                 buffer, NULL, &fKind);

#ifdef TRACE
    Assert(fStyle != 0, 955);
#endif
// _TBodyStructure is not overridden:    FRead(aRefNum, remainder - sizeof(_TBodyStructure), this + 1);
  }
}

// ------------------------------------------------------------------------
void _TBodyStructure::DoWrite(int aRefNum, long remainder)
{
  // fn1 extra fields for notes

  char buffer[13];

  _TStructure::DoWrite(aRefNum, sizeof(_TStructure));  // inherited bits

  PackRecord(0x555, "\x01\x03\x01\x07\x01\x13\x01\x03\x01\x03\x08", &fKind, buffer);
  FWrite(aRefNum, 13, buffer);

// not needed:  _TStructure::DoWrite(aRefNum, remainder - sizeof(_TBodyStructure), this + 1);
}

// ------------------------------------------------------------------------
void _TBodyStructure::DoReadArrayPart(int aRefNum, int version)
{
  TBodyItem item;

  SetPermHandleSize(&fPtrToArray, fSize * sizeof(TBodyItem));

#ifdef VERS0
  if (version == 0)
  {
    FRead(aRefNum, fSize * sizeof(TBodyItem), fPtrToArray);
                                               // read the array
    for (int i = fSize - 1; i >= 0; i--)
    {
      TBodyItem *anItem = (TBodyItem *)fPtrToArray + i;

      // 13/03/91 correct any wrong flags
      anItem->fState = kShown;
      anItem->fNew = FALSE;
      anItem->fAffected = FALSE;
      anItem->fGone = FALSE;
    }
  }
  else
#endif
  {
    FRead(aRefNum, fSize * (version == 1 ? sizeof(TCurrency) : 6), fPtrToArray);
                                               // fn1
                                               // read the compressed array
    // 17/08/92 initialise once
    item.fState = kShown;
    item.fNew = FALSE;
    item.fAffected = FALSE;
    item.fGone = FALSE;        
    item.fNoteNumber = 0;
    item.spare = 0;

    for (int i = fSize - 1; i >= 0; i--)
    {
      // fn1 changed for footnotes
      if (version == 1)
        item.fCurrency = ((TCurrency *)fPtrToArray)[i];
      else
        memcpy(&item, (char *)fPtrToArray + (i * 6), 6);
      // 19/08/92 get bits into consistent state
#ifdef TRACE
      if (GetStructureReadOnly(item.fCurrency)->fParent == 0)
      {
        SysBeep(0);
        Delete(i + 1);
        fDocument->fNeedsReformat = TRUE;
      }
      else
#endif
      {
        item.fState = kShown;
        item.fNew = FALSE;
        item.fAffected = FALSE;
        item.fGone = FALSE;
        ((TBodyItem *)fPtrToArray)[i] = item;
      }
    }
  }
}

// ------------------------------------------------------------------------
void _TBodyStructure::DoWriteArrayPart(int aRefNum)
{
   // write the array elements
  for (int i = 0; i < fSize; i++)
    FWrite(aRefNum, 6 /* fn1 was sizeof(TCurrency) */, ((TBodyItem *)fPtrToArray) + i);
}


// ------------------------------------------------------------------------
bool _TBodyStructure::CanTypeFast(TCurrency childCurr)
{
  // 18/06/95 [26018] return FALSE if typing in chapter or doc heading (for HF updating)
  if (fHeadingType != kNoHeading && fKind <= kChapter && GetBodyItem(1) == childCurr)
    return FALSE;
  return TRUE;
}

// ------------------------------------------------------------------------
TStyleTypes _TBodyStructure::GetKind()
{
  return fKind;
}


// ------------------------------------------------------------------------
int _TBodyStructure::_GetSize()
{
  return fSize + (fLinkedBodyC > 0 ? fLinkedBody->fSize : 0);
}


// ------------------------------------------------------------------------
Ptr _TBodyStructure::_At(int index)
{
  return (index > fSize && fLinkedBodyC > 0 ? 
                              fLinkedBody->At(index - fSize) : At(index));
}


// ------------------------------------------------------------------------
int _TBodyStructure::InsertBefore(int index, Ptr item)
{
  if (index > fSize + 1 && fLinkedBodyC > 0)
    return fLinkedBody->InsertBefore(index - fSize, item);

  return _TArray::InsertBefore(index, item);
}


// ------------------------------------------------------------------------
void _TBodyStructure::Delete(int index)
{
//  if (index > fSize && fLinkedBodyC > 0)
//    fLinkedBody->Delete(index - fSize)
  _TArray::Delete(index);
}


// ------------------------------------------------------------------------
void _TBodyStructure::SetChanged(TCurrency currency, TCurrency child, bool state)
// 16/06/91 new
{
  int index = FindBodyItem(child);

  PItemFormat(fDocument->ActiveMainView()->GetFormatReadWrite(currency)->
                                        At(index))->fChanged = state;
#ifdef FN
  // 17/05/94 [21807] mark the para containing the note if a correction is made in a footnote
  if (fReference != gNullCurrency)
    GetStructureReadOnly(fReference)->SetChanged(fReference, gNullCurrency, state);

  // 17/05/94 [21807] if a body in a footnote, keep marking until reference & noteset found
  if (IsPartOf(1 << kNoteSet))
    _TStructure::SetChanged(currency, child, state);
#endif
}

// ------------------------------------------------------------------------
void _TBodyStructure::SetAffected(int index, bool state)
// 17/08/92 new
{
  PBodyItem(_At(index))->fAffected = state;
}

// ------------------------------------------------------------------------
void _TBodyStructure::SetGone(int index, bool state)
// 17/08/92 new
{
  PBodyItem bodyItem = PBodyItem(_At(index));

  if (state)
  {
    bodyItem->fGone = TRUE;
    bodyItem->fState = kHidden;
  }
  else
  {
    bodyItem->fGone = FALSE;
    bodyItem->fState = kShown;
  }
}

// ------------------------------------------------------------------------
TCurrency _TBodyStructure::GetBodyItem(int itemNum)
{
   return (PBodyItem(_At(itemNum))->fCurrency);
}


// ------------------------------------------------------------------------
int _TBodyStructure::FindBodyItem(TCurrency item)
{
  int f_Index, b_Index, last;

  last = _GetSize();
  b_Index = fLastHit;
  if (b_Index == 0 || b_Index > last)
    b_Index = last;

  f_Index = b_Index + 1;
  fLastHit = 0;

  do
  {
    if (b_Index > 0)
    {
      if (PBodyItem(_At(b_Index))->fCurrency == item)
      {
        fLastHit = b_Index;
        break;
      }
      b_Index--;
    }
    if (f_Index <= last)
    {
      if (PBodyItem(_At(f_Index))->fCurrency == item)
      {
        fLastHit = f_Index;
        break;
      }
      f_Index++;
    }
  } while (f_Index <= last || b_Index > 0);

  return(fLastHit);
}


// ------------------------------------------------------------------------
bool _TBodyStructure::IsEmpty() // 25/07/90 - new mac method
{
  return (_GetSize() == 1
          ? (GetStructureReadOnly(GetBodyItem(1)))->IsEmpty()
          : FirstThatIsVisible(1) == 0 );      // 18/04/91  FALSE);
}


// ------------------------------------------------------------------------
bool _TBodyStructure::CanIndent(TCurrency currency)
{
  int index;
  TCurrency prev;
  bool CanIndent_r;

  index = FindBodyItem(currency);
  if (index == 2 && fHeadingType != kNoHeading)
    CanIndent_r = FALSE;
  else if (index > 1)
  {
    index --;
    while (index >= 1 && GetItemState(index) == kHidden)
      index --;

    if (index == 0)
      CanIndent_r = FALSE;
    else if (index == 1)
      CanIndent_r = (fHeadingType == kNoHeading || fKind == kList);   // 23/09/92
    else
    {
      prev = GetBodyItem(index);
      CanIndent_r = (Curr_fType(prev) == kTextStruct);
    }
  }
  else
    CanIndent_r = (fHeadingType != kNoHeading || fKind == kList);

  return CanIndent_r;
}


// ------------------------------------------------------------------------
void _TBodyStructure::DoSelTextIteration(TCurrency currency, long pos,
         TCursorNode anchor,TCursorNode activeEnd, char* selectedText)
{
  TStructure structToSearch;

  structToSearch = GetStructureReadOnly(currency);
  structToSearch->GetSelectedText(currency, anchor, activeEnd, selectedText);
  if (strlen(selectedText) >= 254)
    FailNoFail();
}


// ------------------------------------------------------------------------
void _TBodyStructure::Iterate(TCurrency currency, TCursorNode anchor,
                              TCursorNode activeEnd, bool fromAnchor,
                              TObject obj, DoStep procToDo, ...)
{
  int startIndex, endIndex;
  int index;
  TCursorNode anchorN, activeEndN;
  TBodyIterateList *args = (TBodyIterateList *)((char *)&procToDo + sizeof(procToDo));

  anchorN = (anchor == NULL ? NULL : anchor->GetNext());
  if (anchorN == NULL)
    startIndex = 1;
#ifdef FN
  else if (anchorN->fCurrency == GetNoteCollector())
    startIndex = -1;      // doNotes = TRUE;
#endif
  else
    startIndex = FindBodyItem(TBodyCursor(anchor)->GetBodyItem());

  activeEndN = (activeEnd == NULL ? NULL : activeEnd->GetNext());
  if (activeEndN == NULL)
    endIndex = _GetSize();
#ifdef FN
  else if (activeEndN->fCurrency == GetNoteCollector())
    endIndex = -1;   // doNotes = TRUE;
#endif
  else
  {
    endIndex = FindBodyItem(TBodyCursor(activeEnd)->GetBodyItem());
    if (gFormatting > 0 && fKind != kNoteSet)                // 30/4/92
    {
      while (endIndex < _GetSize() && (IsNewItem(endIndex + 1) ||
                PBodyItem(_At(endIndex + 1))->fAffected))
                      // 08/02/93 [20618] || affected: del thru sections to list
      {
        endIndex++;
        activeEndN = NULL;
        // 29/09/92 frig to stop passing wrong cursor,
        // e.g. when a section including table pasted into an empty doc
      }
    }
  }

#ifdef FN
  if (startIndex < 0 || endIndex < 0)            // doNotes)
    procToDo(obj, GetNoteCollector(), 0, anchorN, activeEndN, *args);  
  else
#endif
  if (fromAnchor)
  {
    // 14/10/96 reformat the item before (in case it has a Word style border)
    if (gFormatting > 0 && fKind != kNoteSet && FirstVisibleFrom(this, 1) < startIndex)
    {
      TReformatTypes saveRfmt = 0;
      TSelection seln = NULL;

      if (anchor != NULL)
      {
        seln = anchor->fCursor->fSelection;
        saveRfmt = seln->fReformatType;
        seln->fReformatType = kReformatBorders;
      }
      for (index = startIndex; --index > 0; )
      {
        PBodyItem itm = PBodyItem(_At(index));

        if (itm->fState == kShown)
        {
          if (Curr_fType(itm->fCurrency) == kTextStruct)
            procToDo(obj, itm->fCurrency, index, NULL, NULL, *args);
          break;
        }
      }
      if (seln)
        seln->fReformatType = saveRfmt;
    }

    for (index = startIndex; index <= endIndex; index++)
    {
      procToDo(obj, GetBodyItem(index), index, anchorN,    // next1,
                               index == endIndex ? activeEndN : NULL, *args);
      anchorN = NULL;    // shorter than setting next1 each time round loop
    }

    if (gFormatting > 0 && fKind != kNoteSet && endIndex < _GetSize()) // 30/4/92, 25/07/90
    {
      TReformatTypes saveRfmt = 0;
      TSelection seln = NULL;

      index = endIndex + 1;
      if (anchor != NULL && activeEnd != NULL && FirstVisibleFrom(this, 1) != index)
             // 23/09/92 new block, 28/09/93 [21058] but dont ignore if possible heading
      {
        seln = anchor->fCursor->fSelection;

        saveRfmt = seln->fReformatType;
        seln->fReformatType = kReformatIndent;
      }

      while (index < _GetSize())
      {
        PBodyItem itm = PBodyItem(_At(index));

        if (itm->fState == kShown)
        {
          if (Curr_fType(itm->fCurrency) == kTextStruct)
            procToDo(obj, itm->fCurrency, index, NULL, NULL, *args);
          break;
        }
        index++;
      }
      if (seln != NULL)     // 23/09/92 new block
        seln->fReformatType = saveRfmt;
    }
  }
  else
  {
    // Searching backwards in Find case (the only use for this at the moment)
    for (index = endIndex; index >= startIndex; index--)
    {
      procToDo(obj, GetBodyItem(index), index, index == startIndex ? anchorN : NULL,
                                                              activeEndN, *args);
      activeEndN = NULL;   // 2nd and subsequent iterations, pass NULL
    }
  }
}


// ------------------------------------------------------------------------
void _TBodyStructure::IteratePart(TCurrency currency, int part, Rect &custom,
      TStructure pasteStruct, TCurrency pasteCurr, TTextDocument clipDoc,
                                  TObject obj, DoPartStep procToDo, ...)
{
  int start = 1; // 26/04/90 - new values put in to stop warning
  int finish = 0; // and ensure that the loop does not occur if part != (1,2,3)
  int index;
  TBodyIterateList *args =
      (TBodyIterateList *)((char *)&procToDo + sizeof(procToDo)); // 24/04/91

  if (part != kWholeBody && GetBodyKind() == kFigure)
  {
    if (TopLeftCaption(fCaption))
      part = kBodyPart + kHeadingPart - part;
             // (part == kHeadingPart ? kBodyPart : kHeadingPart);
  }

  switch (part)
  {
  case kHeadingPart:
//    start = 1;
    finish = 1;
    break;

  case kBodyPart:
    start = 1 + int(fHeadingType != kNoHeading);  // 03/05/90 - new
//    finish = _GetSize();
    // 22/04/91 run into next case
  case kWholeBody:
//    start = 1;
    finish = _GetSize();
    break;
  }

   for (index = start; index <= finish; index++)
     procToDo(obj, GetBodyItem(index), index, *args);

// The following needs to be removed! was 16/05/94 [21724]
//#ifdef FN
//   if (fKind == kDocument && part == kWholeBody && gFormatting > 0)
//     procToDo(obj, fFootnotes, 0, *args);
//#endif
}


// ------------------------------------------------------------------------
void _TBodyStructure::SetItem(int oldIndex, int newIndex, TCurrency currency,
                                      bool isPaste)
{
  TBodyItem newItem;

  newItem.fCurrency = currency;
  newItem.fState = kShown;
  newItem.fNew = TRUE;
  newItem.fGone = TRUE;
  newItem.fAffected = FALSE;
  newItem.fNoteNumber = 0;        // 17/08/92 was un-initialised
  newItem.spare = 0;

  if (isPaste)                      // 23/05/91
  {
    SetGone(oldIndex, TRUE);        // 17/08/92
    InsertBefore(newIndex, &newItem);
  }
  else
  {
    InsertBefore(fSize == 0 ? 1 : Min(2, newIndex), &newItem);  // 09/08/95 [26049]
        // avoid crash when copying a selection of only fig caption plus following text
  }
}


// ------------------------------------------------------------------------
void _TBodyStructure::InsertSubStructure(int isPaste,
                      TTextDocument sourceDoc, TCurrency parent,
                      TCurrency &currency, long &before)  // 25/07/90
{
  TBodyItem newItem;
  FailInfo fi;

  if (fKind == kFigure)
  {
    // 18/04/91 figures redone
    CatchFailures(&fi);
    if (_GetSize() == 0 && isPaste)    // 05/03/91 isPaste test remvd; 12/09/91 back
    {
// 18/08/92  int savefCaption = fCaption; // 12/09/91 for pasted figures with fCaption != 0

      InitNewStructure(fParent, parent, fStyle, kFigure, TRUE, NULL);  // 24/03/92
// 18/08/92      fCaption = savefCaption;     // reinstate original position
    }
    if (before == 1 || before == 2)  // 14/08/92 common up
    {
      SetItem(before, before + (before >> 1), currency, isPaste);
      before = 0;
    }
//    if (before == 1)
//    {
//      SetItem(1, 1, currency, isPaste);
//      before = 0;
//    }
//    else if (before == 2)
//    {
//      SetItem(2, 3, currency, isPaste);
//      before = 0;
//    }
    else
    {
      if (before == -1)
      {
        int caption = (BotRightCaption(fCaption) ? 2 : 1);

//      if (currency.cgf_31.fType == kPictStruct || currency.cgf_31.fType == kTableStruct ||
//                currency.cgf_31.fType == kMathStruct)    // 16/09/91 from != kTextStruct
        if (InSet3(Curr_fType(currency), kPictStruct, kTableStruct, kMathStruct))
          caption = 3 - caption;
        SetItem(caption, caption == 2 ? 3 : 1, currency, isPaste);
        before = (caption == 2 ? -2 : -4);
      }
      else if (before < 0)
      {
        before = abs(before) - 1;
        if (before == 1)
          SetItem(1, 1, currency, isPaste);
        else
          SetItem(3, 4, currency, isPaste);
        before = 0;
      }
      else
        FailGeneral(isPaste && sourceDoc != fDocument ? kPasteAlert : kFigureAlert);
    }
    // 31/3/93 [21003] DRAGDROP: This was always missing
    // 03/08/93 [20970] moved into the right branch
    if (!InSet3(Curr_fType(currency), kPictStruct, kTableStruct, kMathStruct))
      SetPastePosition(currency, -1);
    Success(&fi);
  }
  else
  {
    newItem.fCurrency = currency;
    if (isPaste)                     // 17/08/92 test rather than newItem.fGone = isPaste
    {
      newItem.fState = kShown;
      newItem.fNew = TRUE;
      newItem.fAffected = FALSE;
      newItem.fGone = TRUE;          // 12/03/91
      newItem.fNoteNumber = 0;       // 17/08/92 was uninitialised
      newItem.spare = 0;
    }
    else
    {
      newItem.fState = kShown;
      newItem.fNew = TRUE;
      newItem.fAffected = FALSE;
      newItem.fGone = FALSE;         // 12/03/91
      newItem.fNoteNumber = 0;       // 17/08/92 was uninitialised
      newItem.spare = 0;
    }
    if (before <= 0)
      InsertLast(&newItem);
    else
    {
      InsertBefore(before, &newItem);
      before ++;
    }
    SetPastePosition(currency, -1);             // 10/09/92
  }
  return;

Rescue:
  { // 18/04/91 rescue added
    TBodyItem item;

    for (int index = GetSize(); index >= 1; index--)
    {
      Get(index, &item);
      if (item.fState == kHidden)
      {
        if (item.fAffected)
        {
          TStructure structure = GetStructureReadWrite(item.fCurrency);

          structure->ToggleState(item.fCurrency, NULL, NULL, NULL);
          structure->Commit(item.fCurrency, NULL, NULL, NULL, FALSE);
        }
        ResetItemState(index);
      }
      else if (item.fNew)
      {
        if (isPaste && sourceDoc != fDocument)            // 23/05/91
          fDocument->DeleteCurrency(item.fCurrency);
        Delete(index);
      }
    }
  }
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
bool _TBodyStructure::GetItemState(int itemNum)
{
   return PBodyItem(_At(itemNum))->fState;
}


// ------------------------------------------------------------------------
bool _TBodyStructure::IsNewItem(int itemNum)
{
   return PBodyItem(_At(itemNum))->fNew;
}


// ------------------------------------------------------------------------
void _TBodyStructure::ResetItemState(int itemNum)
{
  PBodyItem bodyItem = PBodyItem(_At(itemNum));

  bodyItem->fState = kShown;
  bodyItem->fNew = FALSE;
  bodyItem->fAffected = FALSE;
  bodyItem->fGone = FALSE;         // 19/02/91
}


// ------------------------------------------------------------------------
void _TBodyStructure::Show(TCurrency currency, bool state)
{
  // 28/01/91 - new mac method
  PBodyItem(_At(FindBodyItem(currency)))->fState = state;
}


// ------------------------------------------------------------------------
bool _TBodyStructure::IsShown(TCurrency currency, TCurrency child)
{
  return _TStructure::IsShown(currency, child) && // 25/11/91 extra test
                   (child == 0 ||  // 12/05/93 [20863] test child == fNullCurrency
                                       GetItemState(FindBodyItem(child)));
}


// ------------------------------------------------------------------------
bool _TBodyStructure::CanLink(TCurrency currency)
{
  PBodyItem body = PBodyItem(_At(FindBodyItem(currency)));

  return body->fAffected &&
// 13/05/91       (body->fState ||
              Curr_fType(body->fCurrency) != kPictStruct;
                                    // 19/02/91 from fState
                                    // 21/03/91 from fAffected
                                    // 04/04/91 && ftype == text
                                    // 18/04/91 from == kTextStruct
}


// ------------------------------------------------------------------------
TCurrency _TBodyStructure::GetLink()
{
  // 28/01/91 - new mac method
  return fLinkedBodyC;
}

#ifdef TRACE
// ------------------------------------------------------------------------
bool _TBodyStructure::HasCompositeStyle()
{
   return FALSE;
}
#endif

// ------------------------------------------------------------------------
int _TBodyStructure::FirstThatIsVisible(int fromIndex)
{
  int theSize = _GetSize();

  for (int i = fromIndex; i <= theSize; i++)
    if (PBodyItem(_At(i))->fState)
      return i;
  return 0;
}


// ------------------------------------------------------------------------
int _TBodyStructure::LastThatIsVisible()
{
  for (int i = _GetSize(); i >= 1; i--)
    if (PBodyItem(_At(i))->fState)
      return i;
  return 0;
}


// ------------------------------------------------------------------------
void _TBodyStructure::GetPartInfo(TCurrency partCurrency, int &part,
                                  Rect &custom)
{
  int index;

  ClearRect(custom);
  if (GetBodyKind() == kFigure)
  {
    index = FindBodyItem(partCurrency);
    part = (index == (BotRightCaption(fCaption) ? 1 : 2) ?
                                 kHeadingPart : kBodyPart);      // 05/03/91
  }
  else
  {
    part = kBodyPart;
    index = FirstThatIsVisible(1);

    if (GetBodyItem(index) == partCurrency)
    {
      if (fHeadingType != kNoHeading)
        part = kHeadingPart;
    }
  }
}


// ------------------------------------------------------------------------
// 16/08/93 [20930] Override to only insert the kWholeBody entry when non-caption part
// is selected, rather than return 'wrong' value from GetSelectionKind, (which makes
// paste go wrong because it is fooled into thinking the non-caption is all selected)
void _TBodyStructure::InsertLevelInfo(TSelection selection, TLevelInfo &levelInfo, int part,
                        Rect &custom, int level, int currTarget)
{
  if (fKind == kFigure && part == kBodyPart && custom.top < 0)
  {
    levelInfo.fMsgNum = levelInfo.fPart = kWholeBody;
    levelInfo.fCustom = custom;
    selection->InsertLast(&levelInfo);
  }
  else
    _TStructure::InsertLevelInfo(selection, levelInfo, part, custom, level, currTarget);
}


// ------------------------------------------------------------------------
void _TBodyStructure::GetSelectionKind(TCursorNode anchor,
         TCursorNode activeEnd, TStyleTypes &kind, int &part, Rect &custom)
{
  TCurrency item1, item2;
  int index;  // 25/07/90

  kind = fKind;
  ClearRect(custom);
  if (anchor == NULL || activeEnd == NULL)
    part = -kWholeBody;                     // 16/06/91 from +
  else
  {
    TStructure structure1;
    TStructure structure2;

    item1 = TBodyCursor(anchor)->GetBodyItem();
    item2 = TBodyCursor(activeEnd)->GetBodyItem();

    if (kind == kFigure)          // 28/11/90 whole conditional added
    {
      int body;

      structure1 = GetStructureReadOnly(item1);
      if (item1 == item2)
      {
        bool allSel = structure1->AllSelected(item1, anchor->GetNext(),
                                                activeEnd->GetNext());

        index = FindBodyItem(item1);
        body = (BotRightCaption(fCaption) ? FirstThatIsVisible(1) :
                              LastThatIsVisible());  // 18/04/91 for 1 : 2
        // 16/08/93 [20930] Return the correct part, rather than kWholeBody when 
        // the non-caption part is selected, to stop paste being fooled into thinking
        // the non-caption is all selected.
        // part = (index == body ? (custom.top = -1, kWholeBody) :
        //                                  (allSel ? -kBodyPart : kBodyPart));
        if (index == body)
          custom.top = -1;
        part = (allSel ? -kBodyPart : kBodyPart);
      }
      else
      {
        structure2 = GetStructureReadOnly(item2);
        if (structure1->AllSelected(item1, anchor->GetNext(), NULL) &&
                structure2->AllSelected(item2, NULL, activeEnd->GetNext()))
          part = -kWholeBody;
        else
          part = kWholeBody;
      }
    }
    else
    {
      part = kBodyPart;
      custom.top = anchor->GetColNum();
//    s = fSize + 1;  // 25/07/90
//      index = _FirstThat(this, (TestItem)_TBodyStructure::TestVisible);

#ifdef TABLES
      index = FirstThatIsVisible(1);
      if (index == 0             // 07/07/93 [20968] frig to stop crashing ...
            // the note is still hidden until the end of Reformat which calls this at start
#ifdef FN
                        || item1 == GetNoteCollector()
#endif
              )
        part = kBodyPart;
      else
      {
        int endIdx = LastThatIsVisible();                 // 06/07/93 [20964]

        if (GetBodyItem(index) == item1)    // anchor in 1st item
        {
// 06/07/93 [20964] if (_GetSize() > index && GetBodyItem(_GetSize()) == item2)
          if (endIdx > index && GetBodyItem(endIdx) == item2)
          {
            structure1 = GetStructureReadOnly(item1);
            structure2 = GetStructureReadOnly(item2);
            if (structure1->AllSelected(item1, anchor->GetNext(), NULL) &&
                  structure2->AllSelected(item2, NULL, activeEnd->GetNext()))
              part = -kWholeBody;
            else if (fHeadingType == kNoHeading)
              part = kBodyPart; // 05/02/93 [20608] seln menu when drag from doc strt to end
            else
              part = kWholeBody;
          }
          else
          {
            if (item1 == item2 && fHeadingType != kNoHeading)
            {
              structure1 = GetStructureReadOnly(item1);
              if (structure1->AllSelected(item1, anchor->GetNext(),
                                                        activeEnd->GetNext()))
                part = -kHeadingPart;
              else
                part = kHeadingPart;
            }
          }
        }
        else if (fHeadingType != kNoHeading &&
                        GetBodyItem(index + 1) == item1 &&
                        GetBodyItem(endIdx) == item2)
            // 06/07/93 [20964] anchor in 1st item of body after heading && activeEnd at end
        {
          // anchor in 2nd entry
          structure1 = GetStructureReadOnly(item1);
          structure2 = GetStructureReadOnly(item2);
          if (structure1->AllSelected(item1, anchor->GetNext(), NULL) &&
                structure2->AllSelected(item2, NULL, activeEnd->GetNext()))
            part = -kBodyPart;
          else
            part = kBodyPart;
        }
      }
#endif
    }
  }
}


// ------------------------------------------------------------------------
void _TBodyStructure::SelectPart(TCursorNode anchor, TCursorNode activeEnd, int part,
                                             Rect &custom)  // 13/01/92 custom added
{
  TStructure subStruct;
  TCurrency subStructCur;
  int index;             // 01/08/90 declaration and use new
  int s = 0;
  int itsIdx;

  index = FirstThatIsVisible(1);      // 01/03/94 - 1;
  if (fKind == kFigure)
  {
    int caption;
    int body;               // 18/04/91 calculated

    if (BotRightCaption(fCaption))
    {
      caption = LastThatIsVisible();
      body = index;  // 01/03/94 + 1;
    }
    else
    {
      caption = index;  // 01/03/94 + 1;
      body = LastThatIsVisible();
    }
    itsIdx = (part == kBodyPart ? caption : (part == kHeadingPart ? body : -1));
                 // > 0 means part index has already been calculated
  }
#ifdef FN
  else if (fKind == kNoteSet)
  {
    // 01/03/94 [21426] note sets have no heading so can treat kBodyPart as whole body
    // however must only select those parts of the note set with same note container
    itsIdx = 0;  // 0 means look for same container FindBodyItem(child);
  }
#endif
  else
    itsIdx = -1;  // -1 means do the full search

  if (anchor != NULL)
  {
    int strtIndex;

    if (itsIdx > 0)           // its a figure part, worked out above
      strtIndex = itsIdx;
#ifdef FN
    else if (itsIdx == 0)     // 01/03/94 [21426] scan back to container start
    {
      TCurrency myNoteCr = 0;

      strtIndex = FindBodyItem(TBodyCursor(anchor)->fBodyItem);
      for (index = strtIndex; index > 0; index--)
      {
        if (GetItemState(index) == kShown)
        {
          TCurrency noteItem = GetBodyItem(index);
          TCurrency noteCr = DoGetNoteContainer(noteItem);
              // TBodyStructure(GetStructureReadOnly(noteItem))->GetNoteContainer(noteItem);

          if (myNoteCr == 0)
            myNoteCr = noteCr;      // set up on first time through
          if (myNoteCr == noteCr)   // found a note which same collector (or is same note)
            strtIndex = index;      // remember lowest found in collector
        }
      }
    }
#endif
    else
    {
      // 08/02/91 search for the index from after the heading (if anything follows)
      if (part != kBodyPart || fHeadingType == kNoHeading || _GetSize() <= index ||
                                     (strtIndex = FirstThatIsVisible(index + 1)) == 0)
        strtIndex = index;   // failed to find anything else, so use the only item present
                             // 24/08/93 [21031] getsize test to stop out of range index
    }
    subStructCur = GetBodyItem(strtIndex);
    subStruct = GetStructureReadOnly(subStructCur);
    TBodyCursor(anchor)->SetBodyItem(subStructCur); // fn1
    subStruct->ExtendCursor(anchor, subStructCur, FALSE, TRUE, FALSE); // 05/03/91 F
  }

  if (activeEnd != NULL)
  {
    if (itsIdx > 0)           // its a figure part, worked out above
      index = itsIdx;
#ifdef FN
    else if (itsIdx == 0)     // 01/03/94 [21426] scan forward to container end
    {
      TCurrency myNoteCr = 0;

      index = FindBodyItem(TBodyCursor(activeEnd)->fBodyItem);
      for (int endIndex = index; endIndex <= _GetSize(); endIndex++)
      {
        if (GetItemState(endIndex) == kShown)
        {
          TCurrency noteItem = GetBodyItem(endIndex);
          TCurrency noteCr = DoGetNoteContainer(noteItem);
              // TBodyStructure(GetStructureReadOnly(noteItem))->GetNoteContainer(noteItem);

          if (myNoteCr == 0)
            myNoteCr = noteCr;      // set up on first time through
          if (myNoteCr == noteCr)   // found a note which same collector (or is same note)
            index = endIndex;       // remember last matched
        }
      }
    }
#endif
    else if (part != kHeadingPart)
      index = LastThatIsVisible();
    // else index has already been set up to the heading index
    subStructCur = GetBodyItem(index);
    subStruct = GetStructureReadOnly(subStructCur);
    TBodyCursor(activeEnd)->SetBodyItem(subStructCur); //fn1
    subStruct->ExtendCursor(activeEnd, subStructCur, TRUE, TRUE, FALSE);  // 05/03/91 F
  }
}


// ------------------------------------------------------------------------
void _TBodyStructure::InitNewStructure(TCurrency parent, TCurrency currency,
     TCurrency newStyle, TStyleTypes styleType, bool initialise, TStructureCmd command)
// 24/03/92 last 2 params
{
  // 25/07/90 - rewritten
  TBodyStyle style;
  TBodyItem bodyItem;
  TCurrency newPara;
//  TStyleStructure styleStruct;
  TDiscObject obj;

//  styleStruct = fDocument->GetStyle(newStyle, kReadOnly);
  IBodyStructure(parent, newStyle, styleType); //07/09/90 last par
  if (fKind == kFigure)
  {
    TMainView mv = fDocument->ActiveMainView();

    // 18/08/92 new test to try to match figure to its style & changes
    if (Curr_fType(fChanges) != kBodyStyleStruct ||
      ((style = TBodyStyle(mv->GetStyleReadOnly(fChanges)))->fDefinedInBody & kCaption) == 0)
        style = TBodyStyle(mv->GetStyleReadOnly(newStyle));
  }
  else
    style = NULL;

  if (!initialise)    // 24/03/92
  {
    if (style != NULL)
      fCaption = style->tag.fCaption;
  }
  else
  {
    int structType = kTextStruct;

    styleType = kText;
    // 2 calls of Init1 in_line
    for (int i = 0; i <= (fKind == kFigure); i++)
    {
      newPara = fDocument->NewCurrency(structType, obj);
      TStructure(obj)->InitNewStructure(currency, newPara, gNullCurrency,
                        styleType, TRUE, NULL);   // 24/03/92 ?

      bodyItem.fCurrency = newPara;
      bodyItem.fState = kShown;
      bodyItem.fNew = TRUE;
      bodyItem.fAffected = FALSE;
      bodyItem.fGone = FALSE;              // 19/02/91
      bodyItem.fNoteNumber = 0;            // 17/08/92 was uninitialised
      bodyItem.spare = 0;
      InsertFirst(&bodyItem);
      structType = kPictStruct;
      styleType = kPict;
    }
    if (style != NULL)
      SwapFigure(style->tag.fCaption);
  }
}

// ------------------------------------------------------------------------
void _TBodyStructure::CopySubStructure (TCurrency currency,
                TStructure structure, int index1, int index2, long &pos)
{
  TCurrency c;
  TStructure copyStruct;
//  TBodyItem bodyItem;
  int index;

  for (index = index1; index <= index2; index++)
  {
    c = GetBodyItem(index);    // 17/08/92
//    Get(index, &bodyItem);
//    c = bodyItem.fCurrency;
    copyStruct = GetStructureReadWrite(c);
    if (Curr_fType(c) == kBodyStruct)           // 17/09/92
      TBodyStructure(copyStruct)->fDeletions = TRUE;
    copyStruct->fParent = currency;
    structure->InsertSubStructure(
            1,          // 23/05/91 structure->GetBodyKind() != kFigure,
            fDocument, currency, c, pos);
//    bodyItem.fState = kHidden;
//    bodyItem.fGone = TRUE;
//    AtPut(index, &bodyItem);
    SetGone(index, TRUE);    // 17/08/92
  }
}

// ------------------------------------------------------------------------
static void AddToParent(TBodyStructure parent, TCurrency currency, long &pos)
{
  static TBodyItem bodyItem = {0, kShown, TRUE, TRUE, TRUE, 0, 0};
                                                         // 17/08/92 init 2 extra fields

  bodyItem.fCurrency = currency;
//  bodyItem.fState = kShown;
//  bodyItem.fNew = TRUE;
//  bodyItem.fAffected = TRUE;
//  bodyItem.fGone = TRUE;

  parent->InsertBefore(pos++, &bodyItem);
//  pos++;
}

// ------------------------------------------------------------------------
static void DoFindEnds(TObject null, TCurrency currency, long posn,
                                 TCurrency *newStart, TCurrency *newEnd)
{ // usually only one item, at most 2 for figures
  if (*newStart == 0)
    *newStart = currency;
  else
    *newEnd = currency;
}

// ------------------------------------------------------------------------
void _TBodyStructure::DoDelete(TCurrency currency, long posn)
{
  fDocument->DeleteCurrency(currency);
}

// ------------------------------------------------------------------------
TCurrency _TBodyStructure::GetEnd(TCurrency currency, bool start)
{
  return FindEnd(start ? 1 : GetSize(), start);
}

// ------------------------------------------------------------------------
TCurrency _TBodyStructure::FindEnd(int index, bool start)
{
  TCurrency item = GetBodyItem(index);
  TStructure structure = GetStructureReadOnly(item);

  return structure->GetEnd(item, start);
}

// ------------------------------------------------------------------------
void _TBodyStructure::NewStructure(TCurrency currency, TCursorNode anchor,
           TCursorNode activeEnd, TCurrency subStruct, TCurrency subStyle,
           TStyleTypes styleType, TNewStructureCmd command)
// 24/03/92  CmdNumber command, TCurrency &newStart, TCurrency &newEnd)
{
  // 25/07/90 - rewritten
  // 07/03/91 - rewritten again
  // 18/04/91 - figure handling redone

  TCurrency parentCurrency;
  volatile TCurrency cStruct1;
  volatile TCurrency cStruct3;
  TBodyStructure parent;
  TBodyStructure struct1;
  int index, startIndex, endIndex;
  long endPos, pos, startPos;
  TStructure struct2;
  TStructure temp;
  bool ip;
#ifdef TABLES
  TBodyStructure struct3;
  TDiscObject obj;
  bool goneUp;
#else
#define goneUp FALSE
#endif
  bool insertBlankPara;
  bool addPict;
  volatile int hideMe;   // 14/08/92 made an int - the index of 'me'
  bool topLevel;
  TStyleTypes kind;
//  TBodyItem bodyItem;
  TCurrency newStart;
  TCurrency newEnd;
  CmdNumber cmdNum = command->fCmdNumber; // 24/03/92
  bool isEndStruct = anchor->fCursor->fSelection->fEndStructure; // fn2
  FailInfo fi;

  newStart = 0;
  cStruct1 = 0;
  newEnd = 0;
  hideMe = 0;
  struct2 = (cmdNum == cRemoveStruct ? NULL : GetStructureReadWrite(subStruct));
  cStruct3 = 0;
  startIndex = FindBodyItem(TBodyCursor(anchor)->GetBodyItem());
  endIndex = FindBodyItem(TBodyCursor(activeEnd)->GetBodyItem());
  temp = GetStructureReadOnly(TBodyCursor(anchor)->GetBodyItem());
  ip = isEndStruct ||   // 24/06/93 [20957] do not include endstruct-ed struct, empty or not
            (anchor->IsCursor(activeEnd) &&
            !((temp->IsEmpty() || fKind == kFigure) && cmdNum != cParagraph))
                 // 26/03/91 &&.. 16/06/91 || .. 14/08/92 stop adding new objects in figure
       || (temp->GetKind() == kFigure && cmdNum == cParagraph);  // 10/02/92

  if (cmdNum == cPicture || cmdNum == cEquation)
    addPict = fKind != kFigure && !temp->IsEmpty();
  else if (cmdNum >= cPageFiller && cmdNum <= cColBreak)    // 02/07/93 [20958] wh. space
    addPict = TRUE;
  else
    addPict = FALSE;

//  addPict =
//       (cmdNum = cPicture || cmdNum == cEquation) && fKind != kFigure && !temp->IsEmpty();
                                          // 13/01/92 equation test 14/08/92 put in fig test
  // 01/05/91 new bool and conditional
  insertBlankPara = (startIndex < endIndex && temp->GetKind() != kText &&
                             cmdNum != cRemoveStruct);
  if (insertBlankPara && !isEndStruct /*fn2*/ && temp->InSecondHalf(anchor->GetNext()))
  {
    startIndex++;
    ResetCursor(anchor, startIndex, FALSE, FALSE);
    temp = GetStructureReadOnly(TBodyCursor(anchor)->GetBodyItem());
    if (temp->GetKind() == kText)
      insertBlankPara = FALSE;
  }
  kind = GetBodyKind();
  // 08/07/91 topLevel added for Endstruct after figures/lists in section
  topLevel = kind == kDocument || kind == kHeader || kind == kFooter
#ifdef FN
  || kind == kNoteSet || kind == kFootnote
#endif
  ;
#ifdef TABLES
  if (isEndStruct) // fn2
    goneUp = (cmdNum == cSection) && !topLevel;
  else if (topLevel)
    goneUp = FALSE;
  else
  {
    goneUp = TRUE;
    switch (cmdNum)
    {
      case cRemoveStruct: 
          ip = FALSE;
          break;
      case cChapter:
          if (command->fStyleCurrency == 0)  // 20/06/93 [20949]
            subStyle = fStyle;
          break;
      case cSection: 
          if (kind == kChapter || kind == kFigure)
            goneUp = FALSE;
          break;
      case cList: 
          if (kind == kChapter || kind == kFigure || kind == kSection)
            goneUp = FALSE;
          break;
      case cPageFiller:     // 23/05/91 new clause
      case cWhiteSpace:
          goneUp = (fKind == kFigure || startIndex == 1) &&
                          !temp->InSecondHalf(anchor->GetNext());
          break;
      case cFigure:         // 18/04/91 new clause, 27/07/94 [22012] ban selected chapters
          if (fKind != kChapter && AllSelected(currency, anchor, activeEnd))
          {
            parent = TBodyStructure(GetStructureReadOnly(fParent));
            parent->NewStructure(fParent, anchor->GetPrevious(),
                    activeEnd->GetPrevious(), subStruct, subStyle, styleType,
                    command);    // 24/03/92 , newStart, newEnd);
// works w/o this on Mac:   command->SetStartEnd(newStart, newEnd); // 24/03/92 ???
            return;
          }
          if (temp->GetKind() == kPict)
            ip = FALSE;
          // run into default
      default:
          goneUp = FALSE;
    }
  }
#endif

  if (goneUp)
  {
#ifdef TRACE
    Assert(Curr_fType(fParent) == kBodyStruct, 194);
#endif
    parent = TBodyStructure(GetStructureReadWrite(fParent));
    parentCurrency = fParent;
    endPos = parent->FindBodyItem(currency);
  }
  else
  {
    parent = this;
    parentCurrency = currency;
    endPos = FindBodyItem(TBodyCursor(anchor)->GetBodyItem());
  }
  startPos = endPos;

  // make adjustments for insertion point case
  if (ip || addPict)                // 05/07/91 || ..
  {
    ip = TRUE;     // 19/10/93 [21090] Force the ip path below (to stop Undo failing)
    if (temp->InSecondHalf(anchor->GetNext()))
    {
      startIndex++;
      endIndex = startIndex;
      if (!goneUp)
      {
        endPos++;
        startPos = endPos;
      }
    }
  }

  CatchFailures(&fi);

  // get a new structure for the start and copy stuff into it
  if (goneUp)
  {
    if (startIndex > 1 && startIndex <= GetSize())
    {
      cStruct1 = fDocument->NewCurrency(Curr_fType(currency), obj);
      struct1 = TBodyStructure(obj);
      struct1->fKind = GetBodyKind();
      struct1->fStyle = fStyle;
      struct1->fChanges = fChanges;      // 04/07/91
      struct1->fParent = fParent;
      pos = -1;
      CopySubStructure(cStruct1, struct1, 1, startIndex - 1, pos);
      AddToParent(parent, cStruct1, endPos);
      hideMe = endPos;        // 14/08/92 from TRUE
    }
    else if (endIndex > GetSize())
    {
      startPos++;
      endPos++;
    }
  }

  // now do the middle bit according to cmdNum
  if (cmdNum == cRemoveStruct) // move all this stuff to my parent
  {
    hideMe = endPos;     // 14/08/92 save in case zeroised
    CopySubStructure(parentCurrency, parent, startIndex, endIndex, endPos);
    if (endPos == 0)     // 14/08/92 it was a figure
    {
      endPos = hideMe + 1;
      hideMe = 2;        // 14/08/92 'me' inserted at position 2 in either case
    }
    else
      hideMe = endPos;
    newStart = FindEnd(startIndex, TRUE);
    newEnd = FindEnd(endIndex, FALSE);
    endIndex++;
  }
  else if (ip)
  {
    struct2->InitNewStructure(parentCurrency, subStruct, subStyle, styleType,TRUE, command);
                                              // 24/03/92 i/f
    AddToParent(parent, subStruct, endPos);
    struct2->IteratePart(subStruct, 1, gZeroRect, NULL, gNullCurrency, NULL,
           this, (DoPartStep)DoFindEnds, &newStart, &newEnd);
    if (newStart == 0)
      newStart = subStruct;
    if (gSelNewStructs && cmdNum != cParagraph)   // 14/07/93 [20982] Select new structures
      newEnd = subStruct;
    if (!goneUp)                           // 26/03/91 new statement
      endPos--;
  }
  else // move this stuff to new structure and put that in parent
  {
    struct2->InitNewStructure(parentCurrency, subStruct, subStyle, styleType, insertBlankPara
#ifdef MATHS
          || Curr_fType(subStruct) == kMathStruct  // 13/01/92  from !insertBlankPara
#endif
      , command);   // 24/03/92 pass command too
    pos = -1;
    // 19/10/93 [21090] unnecessary as addPict always FALSE now:  if (!addPict) // 05/07/91
      CopySubStructure(subStruct, struct2, startIndex, endIndex, pos);
    AddToParent(parent, subStruct, endPos);
    newStart = parent->FindEnd(endPos - 1, TRUE);     // 03/04/91 use parent

    if (gSelNewStructs)           // 14/07/93 [20982] Select new structures
      newEnd = subStruct;
    else if (!anchor->IsCursor(activeEnd) || styleType == kFigure) // 04/04/91 fig
      newEnd = parent->FindEnd(endPos - 1, FALSE);    // 03/04/91 use parent

    if (goneUp)
      hideMe = endPos;        // 14/08/92 from TRUE
    else
      endPos = Max(startPos, FindBodyItem(TBodyCursor(activeEnd)->GetBodyItem()));
                         // 14/08/92 Max for failing to commit until 'next but one' command
    endIndex++;
   }

  if (goneUp)
  {
    if (endIndex <= GetSize())
    {
      cStruct3 = fDocument->NewCurrency(Curr_fType(currency), obj);
      struct3 = TBodyStructure(obj);
      struct3->InitNewStructure(fParent, cStruct3, fStyle, fKind,
                       startIndex != 1 && fHeadingType != kNoHeading, command);
      struct3->fChanges = fChanges;      // 04/07/91

      pos = -1;
      CopySubStructure(cStruct3, struct3, endIndex, GetSize(), pos);
      AddToParent(parent, cStruct3, endPos);
      hideMe = endPos;        // 14/08/92 from TRUE
    }
    else if (!hideMe)
      endPos--;
  }

  // sort out the selection
  if (goneUp)
  {
    anchor = anchor->GetPrevious();
    activeEnd = activeEnd->GetPrevious();
  }
  parent->ResetCursor(anchor, startPos, FALSE, TRUE);
  parent->ResetCursor(activeEnd, endPos, TRUE, TRUE);
  if (hideMe)
  {
    parent->SetGone(hideMe, TRUE);        // 17/08/92
    parent->SetAffected(hideMe, TRUE); // 20/09/93 [21045] mark so not ignored by ToggleState
  }
  Success(&fi);
  command->SetStart(newStart);
  command->SetEnd(newEnd);
  return;

Rescue:
  if (cStruct1 != 0)
  {
    index = parent->FindBodyItem(cStruct1);
    if (index != 0)
      parent->Delete(index);
    fDocument->DeleteCurrency(cStruct1);
  }

  if (cmdNum != cRemoveStruct)
  {
    index = parent->FindBodyItem(subStruct);
    if (index != 0)
      parent->Delete(index);
    if (ip)
      struct2->IteratePart(subStruct, 1, gZeroRect, NULL, gNullCurrency, NULL,
                          this, (DoPartStep)_TBodyStructure::DoDelete);
    else
      struct2->ReduceSize(0);
  }

  if (cStruct3 != 0)
  {
    index = parent->FindBodyItem(cStruct3);
    if (index != 0)
      parent->Delete(index);
    fDocument->DeleteCurrency(cStruct3);
  }

  if (hideMe)                                // 18/04/91 test added
  {
    index = parent->FindBodyItem(currency);
    parent->ResetItemState(index);
  }
  for (index = 1; index <= GetSize(); index++)
  {
    struct1 = TBodyStructure(GetStructureReadWrite(GetBodyItem(index)));  // 17/08/92
    struct1->fParent = currency;
    SetGone(index, FALSE);    // 17/08/92
    /* 17/08/92 including this seems to cause problems!
    if (cmdNum == cRemoveStruct)
    {
      int index1 = parent->FindBodyItem(currency);
      if (index1 != 0)
        parent->Delete(index1);
    }
    */
  }
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TBodyStructure::EndStructure(TCurrency currency, TCursorNode anchor,
                                   int part, Rect &custom)
{
  TCurrency bodyItem;
  TStructure subStruct;

  // 25/07/90 - rewritten
  bodyItem = GetBodyItem(_GetSize());
  TBodyCursor(anchor)->SetBodyItem(bodyItem);                   // 03/04/91
  subStruct = GetStructureReadOnly(bodyItem);
  subStruct->ExtendCursor(anchor, bodyItem, TRUE, TRUE, FALSE); // 05/03/91 F
}


// ------------------------------------------------------------------------
void _TBodyStructure::GetControlChars(TStructure caller, TCursorNode cursor, ControlCharSet &controls)
{
  if (fKind == kFigure && caller != this)     // 11/07/91 && ...
    controls &= ~(1 << chReturn);
#ifdef FN
  else if (fKind == kNoteSet && caller == this)
    controls = (1 << 5);     // 15/07/93 [20984] - disable all typing
//    controls &= ~((1 << chReturn) | (1 << chBackspace) | 1);
#endif
}

// ------------------------------------------------------------------------
#ifdef DRAGDROP
void _TBodyStructure::DoMarkToTop(TCurrency currency, TCurrency child)
{ // [20870] 13/5/93
  // 08/06/93 [20928] Undo remove structure, etc. regression: fDeletions = TRUE;
  if (fDeletions == 0 && Curr_fType(child) == kBodyStruct)           // 04/10/93 [21067]
    fDeletions = TBodyStructure(GetStructureReadOnly(child))->fDeletions;
  if (child != 0)
    SetAffected(FindBodyItem(child), TRUE);
#ifdef FN
  if (fKind != kNoteSet)
    _TStructure::DoMarkToTop(currency, child);
  else if (child != gNullCurrency)
  {
    // 18/02/94 [21408] need to mark affected chapters when chapter endnotes affected
    TCurrency noteCr = DoGetNoteContainer(child);
          // TBodyStructure(GetStructureReadOnly(child))->GetNoteContainer(child);

    if (noteCr != fParent)    // nothing to do if note container is the document body
      _TStructure::DoMarkToTop(noteCr, gNullCurrency);
                   // mark the chapter inside my parent (which is the document body)
  }
#else
  _TStructure::DoMarkToTop(currency, child);
#endif
}

#else
// ------------------------------------------------------------------------
void _TBodyStructure::DeleteToTop(TCursorNode cursorNode)
{
  fDeletions = TRUE;
  if (fParent != 0
#ifdef FN
      && fKind != kNoteSet
#endif
     )
  {
    TBodyStructure myParent =
             TBodyStructure(GetStructureReadWrite(fParent));

    if (myParent->HandleKeypress(chUp, cursorNode->GetPrevious()))
      myParent->SetAffected(myParent->FindBodyItem(cursorNode->fCurrency), TRUE); // 17/08/92
//    PBodyItem(myParent->At(myParent->FindBodyItem(cursorNode->fCurrency)))->
//                                    fAffected = TRUE; // 19/03/91
  }
}
#endif

// ------------------------------------------------------------------------
// 23/7/92 new
static int NextInBody(TBodyStructure self, int index)
{
  while (index++, index <= self->GetSize() && PBodyItem(self->At(index))->fState == kHidden) ;
  return index;
}

// ------------------------------------------------------------------------
// 06/07/93 [20945]
static int PrevInBody(TBodyStructure self, int index)
{
  while (index--, index > 0 && PBodyItem(self->At(index))->fState == kHidden) ;
  return index;
}

// ------------------------------------------------------------------------
bool _TBodyStructure::HandleKeypress(int ch, TCursorNode cursorNode)
{
  TCurrency bodyItem;
  int bodyIndex;
  TStructure myParent;
  TStructure subBody;
  TCursorNode nextNode;
  TBodyItem newItem;
  TCursor cursor;
  TCurrency firstHalf;
  TCurrency lastHalf;
  bool HandleKeypress_r;

  HandleKeypress_r = TRUE;
#ifndef DRAGDROP
  if (ch == chUp)          // 21/02/91
  {
    DeleteToTop(cursorNode);
    return TRUE;
  }
#endif
  bodyItem = TBodyCursor(cursorNode)->GetBodyItem();
  bodyIndex = FindBodyItem(bodyItem);
  // 22/6/92 added FwdDelete
  if (ch == chBackspace || ch == chFwdDelete || ch == chLeft || ch == chRight)    // 23/05/91
  {
    if (fKind == kFigure)
               // 17/09/91 new clause to stop crash on Delete out of captions
    {
      SysBeep(0);
      HandleKeypress_r = FALSE;
    }
    else if ((PrevInBody(this, bodyIndex) == 0 &&         // 06/07/93 [20945]
              (ch == chBackspace || ch == chLeft)) ||
             (NextInBody(this, bodyIndex) > GetSize() && //23/7/92
                (ch == chFwdDelete || ch == chRight))) // 22/6/92
    {
      if (fParent == 0
#ifdef FN
          || fKind == kFootnote
#endif
         )
      {
        SysBeep(0);
        HandleKeypress_r = FALSE;
      }
      else
      {
        myParent = GetStructureReadWrite(fParent);
        subBody = GetStructureReadOnly(bodyItem);
        // 9/2/93 [20618] bs thru sections into list
        lastHalf = subBody->GetLink();
        if ((ch == chBackspace || ch == chLeft) && 
                (subBody->IsEmpty() || lastHalf > 0)) // 23/7/92
        {
          SetGone(bodyIndex, TRUE);       // 17/08/92
          SetAffected(bodyIndex, TRUE);
          if (lastHalf > 0)
          {
            TCursor oldCursor1;
            int index1;

            cursor = cursorNode->fCursor;
            oldCursor1 = TCursor(cursor->Clone());
            nextNode = oldCursor1->GetNode(cursorNode->GetIndex());
            ResetCursor(nextNode, index1 = FindBodyItem(lastHalf), FALSE, FALSE);
            subBody->LinkStructure(cursorNode->GetNext(), nextNode->GetNext(), 2);
                                                 // 22/04/93 for maths: TRUE);
            SetGone(index1, FALSE);
            FreeIfObject(oldCursor1);
          }
        }
        // end of [20618]
        if (IsEmpty()) // 22/6/92 conditional rewritten
        {
          if (ch == chBackspace)
            ch = chLeft;
          else if (ch == chFwdDelete)
            ch = chRight;
        }
        else if (ch == chLeft)
          ch = chBackspace;              // 01/05/91 new else
        else if (ch == chRight)
          ch = chFwdDelete;
        if (!myParent->HandleKeypress(ch, cursorNode->GetPrevious()))
        {
          // 16/06/91 new block
          HandleKeypress_r = FALSE;
          if (subBody->IsEmpty())
            SetGone(bodyIndex, FALSE);       // 17/08/92
        }
      }
    }
    else if (ch == chLeft || ch == chBackspace)
    {
      // 28/01/91 new block
      TCursor oldCursor = NULL;
      int index = bodyIndex;

      cursor = cursorNode->fCursor;
      lastHalf = bodyItem;
      if (ch == chBackspace)
      {
        oldCursor = TCursor(cursor->Clone());
        subBody = GetStructureReadWrite(bodyItem);
        lastHalf = subBody->GetLink();
        if (lastHalf > 0)
        {
          // 08/02/93 subBody->LinkStructure(cursorNode->GetNext(), NULL, TRUE, link);
          // 08/02/93 [20618] moved down & pass nextNode->GetNext()
          nextNode = oldCursor->GetNode(cursorNode->GetIndex());
          ResetCursor(nextNode, index = FindBodyItem(lastHalf), FALSE, FALSE);
          subBody->LinkStructure(cursorNode->GetNext(), nextNode->GetNext(), 2);
                                                 // 22/04/93 for maths: TRUE);
        }
        else
          lastHalf = bodyItem;
        
      }
      SetGone(bodyIndex, TRUE);        // 17/08/92
      SetAffected(bodyIndex, TRUE);    // 17/08/92

      bodyIndex = PrevInBody(this, bodyIndex);     // 06/07/93 [20945] was bodyIndex - 1
      {
        PBodyItem bodyItem2 = PBodyItem(_At(bodyIndex));

        bodyItem2->fAffected = TRUE;
        firstHalf = bodyItem2->fCurrency;
// 18/04/91        subBody = GetStructureReadOnly(bodyItem2->fCurrency);  // 04/04/91
      }
      ResetCursor(cursorNode, bodyIndex, TRUE, FALSE);      // 05/03/91 F
      cursor->fChanged = TRUE;
          // 18/04/91   next block added
      if (ch == chBackspace) // 22/6/92
      {
        subBody = GetStructureReadOnly(firstHalf);
        if (subBody->CanJoin(lastHalf))      // 01/05/91 from bodyItem
        {
          LinkSelection(TCursorNode(cursor->First()),
                                   TCursorNode(oldCursor->First()), FALSE);
          fDeletions = TRUE;            // 01/10/93 [21062] Undo did not toggle join
        }
        else
          SetGone(index, FALSE);
//        {
//          PBodyItem bodyItemPlus1 = PBodyItem(_At(index)); // 1/6/92

//          bodyItemPlus1->fState = kShown;
//          bodyItemPlus1->fGone = FALSE;
//        }
        FreeIfObject(oldCursor);      // 08/04/91
      }
//      if (subBody->GetBodyKind() != kText || subBody->GetLink() == 0)
//        PBodyItem(_At(bodyIndex + 1))->fGone = FALSE;        // 04/04/91
//      fDeletions = TRUE;
#ifdef DRAGDROP
      {
        // 13/10/93 Simple MarkToTop no good when HandleKeyPress passed up the levels
        TCurrency targetCurr = TCursorNode(cursorNode->fCursor->Last())->fCurrency;

        GetStructureReadWrite(targetCurr)->MarkToTop(targetCurr);
      }
      // MarkToTop(cursorNode->fCurrency);
#else
      DeleteToTop(cursorNode);
#endif
    }
    else if (ch == chRight || ch == chFwdDelete) // 22/6/92 new block
    {
      TCursor oldCursor;
      int index = NextInBody(this, bodyIndex); // 23/7/92
      
      cursor = cursorNode->fCursor;
      firstHalf = bodyItem;
      oldCursor = TCursor(cursor->Clone());
      subBody = GetStructureReadWrite(bodyItem);
      ResetCursor(oldCursor->GetNode(cursorNode->GetIndex()), index, FALSE, FALSE);
      lastHalf = GetBodyItem(index);
      SetAffected(bodyIndex, TRUE);     // 17/08/92
                                        //      PBodyItem(At(bodyIndex))->fAffected = TRUE;
      SetGone(index, TRUE);             // 17/08/92
                                        // 17/08/92  bodyItem2 = PBodyItem(At(index));
                                        //           bodyItem2->fState = kHidden;
                                        //           bodyItem2->fGone = TRUE;
      SetAffected(index, TRUE);         // 17/08/92
                                        //           bodyItem2->fAffected = TRUE;
      if (subBody->CanJoin(lastHalf) && ch == chFwdDelete)     // [20990] && not empty
      {
        LinkSelection(TCursorNode(cursor->First()), TCursorNode(oldCursor->First()), FALSE);
        cursor->fChanged = TRUE; // 23/7/92
        fDeletions = TRUE;              // 01/10/93 [21062] Undo did not toggle join
      }
      else
      {
        SetGone(index, FALSE);          // 17/08/92
                                        //        bodyItem2->fState = kShown;
                                        //        bodyItem2->fGone = FALSE;
        if (ch == chRight)              // 14/7/92 Prev item all gone & not linked
          SetGone(bodyIndex, TRUE);
                                        //        {
                                        //          bodyItem2 = PBodyItem(At(bodyIndex));
                                        //          bodyItem2->fState = kHidden;
                                        //          bodyItem2->fGone = TRUE; 
                                        //        }
        ResetCursor(cursor->GetNode(cursorNode->GetIndex()), index, FALSE, FALSE);
      }
      FreeIfObject(oldCursor);
#ifdef DRAGDROP
      MarkToTop(cursorNode->fCurrency);
#else
      DeleteToTop(cursorNode);
#endif
    }
  }
  else if (ch == chReturn || ch == chLineFeed)  // 24/03/92 for sh-Return in Maths
  {
    cursor = cursorNode->fCursor;
    cursor->fChanged = TRUE;
    nextNode = cursorNode->GetNext();
    subBody = GetStructureReadWrite(bodyItem);
    subBody->Split(nextNode, firstHalf, lastHalf, TRUE);
    // 25/04/91 new block
    if (firstHalf != 0)
    {
      cursor = TCursor(cursor->Clone());
      nextNode = cursor->GetNode(cursorNode->GetIndex());
      ResetCursor(nextNode, bodyIndex, FALSE, FALSE);
      TBodyCursor(cursorNode)->SetSplitCursor(nextNode);
    }

    TBodyCursor(cursorNode)->SetBodyItem(lastHalf);
//    PBodyItem(At(bodyIndex))->fAffected = TRUE;      // 19/02/91
    SetAffected(bodyIndex, TRUE);  // 17/08/92
    newItem.fCurrency = lastHalf;
    if (fLinkedBodyC == 0)    // 17/08/92 instead of assigning to fAffected
    {
      newItem.fState = kShown;
      newItem.fNew = TRUE;
      newItem.fAffected = TRUE;
      newItem.fGone = FALSE;      // 19/02/91
      newItem.fNoteNumber = 0;
      newItem.spare = 0;
    }
    else
    {
      newItem.fState = kShown;
      newItem.fNew = TRUE;
      newItem.fAffected = FALSE;
      newItem.fGone = FALSE;      // 19/02/91
      newItem.fNoteNumber = 0;
      newItem.spare = 0;
    }
    InsertBefore(NextInBody(this, bodyIndex), &newItem);     // [20865] 13/5/93
#ifdef MATHS
    HandleKeypress_r = chReturn; // 28/07/93 [20998] so Body ToggleState knows to un-Split 
#endif
  }
  else
    SysBeep(0);

  return HandleKeypress_r;
}


// ------------------------------------------------------------------------
void _TBodyStructure::ExtendCursor(TCursorNode cursorNode,
      TCurrency currency, bool fromRight, bool toBottom, bool keepInvisibles)
{
  TBodyCursor newNode;
  int index = (keepInvisibles ? (fromRight ? _GetSize() : 1) : 
              (fromRight ? LastThatIsVisible() : FirstThatIsVisible(1)));
                            // 05/03/91 extra keepInvisibles test
  TCurrency bodyItem = GetBodyItem(index);
#ifdef FN
  TCursor cursor = cursorNode->fCursor;
#endif
//       _FirstThat(this, (TestItem)_TBodyStructure::TestVisible));
        
#ifdef FN
  if (fKind == kFootnote)
  {
    cursor->FreeAll();
    cursor->InitialCursor(fDocument->ActiveMainView(), currency, fromRight ? -1 : 0);
                                                /* fromRight, 0 06/09/92 */
    newNode = TBodyCursor(cursor->GetTarget());
  }
  else
#endif
  {
    newNode = new _TBodyCursor(currency, IDType(kNewCursor), bodyItem, gZeroVPt);
    cursorNode->fCursor->AddTarget(newNode);
  }
  if (toBottom)
  {
    TStructure structure = GetStructureReadOnly(bodyItem);
    structure->ExtendCursor(newNode, bodyItem, fromRight, TRUE, keepInvisibles); // 05/03/91 extra param
  }
}


// ------------------------------------------------------------------------
void _TBodyStructure::ResetCursor(TCursorNode cursor, long insertionPos,
                                  bool fromRight, bool keepInvisibles)
{
  // 25/07/90 - rewritten

  TCurrency currency;
  TStructure item;

  cursor->Collapse();
  if (insertionPos == 0)
  {
    fromRight = FALSE;
    currency = GetBodyItem(1);
  }
  else if (insertionPos <= -1 || insertionPos > _GetSize())
  {
    fromRight = TRUE;
    currency = GetBodyItem(_GetSize());
  }
  else
    currency = GetBodyItem(insertionPos);

  TBodyCursor(cursor)->SetBodyItem(currency);
  item = GetStructureReadOnly(currency);
  item->ExtendCursor(cursor, currency, fromRight, TRUE, keepInvisibles); // 05/03/91 extra param
}


// ------------------------------------------------------------------------
TCursorNode _TBodyStructure::NewCursorNode()
{
  return new _TBodyCursor(gNullCurrency, kNoIdentifier, gNullCurrency,
                                                             gZeroVPt);
}


// ------------------------------------------------------------------------
bool _TBodyStructure::SwapNodes(TCursorNode anchor, TCursorNode activeEnd)
{
  int anchorBody;
  int activeBody;
  TCurrency nextCurr = TBodyCursor(anchor)->GetBodyItem();

  anchorBody = FindBodyItem(nextCurr);
  activeBody = FindBodyItem(TBodyCursor(activeEnd)->GetBodyItem());

  // 11/10/93 Test next level for drag and drop WithinSelection, before start of body seln
  if (anchorBody == activeBody && (anchor = anchor->GetNext()) != NULL &&
                                                (activeEnd = activeEnd->GetNext()) != NULL)
    return GetStructureReadOnly(nextCurr)->SwapNodes(anchor, activeEnd);
  return (activeBody == 0 ? FALSE : anchorBody > activeBody);
                                         // 28/01/91 activeBody test added
}


// ------------------------------------------------------------------------
bool _TBodyStructure::LinkStructure(TCursorNode anchor, TCursorNode activeEnd, bool cmdDone)
// 09/02/93 replaced by func result:, bool &link)
{
  TCurrency currency;
  int index;
  int link = FALSE;

  if (activeEnd != NULL)
    currency = activeEnd->fCurrency;
  else
    currency  = 0;

  if (fLinkedBodyC == 0)
  {
    if (currency != 0)
    {
      if (CanJoin(currency))
      {
        TBodyStructure linkStructure;

        fLinkedBodyC = currency;
        linkStructure = TBodyStructure(GetStructureReadWrite(currency));
        fLinkedBody = linkStructure;
        // in-line fLinkedBody->Each(LinkToMe);
        for (index = 1; index <= linkStructure->GetSize(); index++)
        {
          TStructure subStructure;
          TBodyItem bodyItem1;

          linkStructure->Get(index, &bodyItem1);
          subStructure = GetStructureReadWrite(bodyItem1.fCurrency);
          subStructure->fParent = anchor->fCurrency;
          fDocument->DeleteFormatData(currency, 1);
          bodyItem1.fNew = TRUE;
          linkStructure->AtPut(index, &bodyItem1);
        }
        link = TRUE;
      }
      else
        fLinkedBodyC = -1;
    }
  }
  else
  {
    if (fLinkedBodyC != -1)
    {
      // in-line fLinkedBody->Each(UnlinkFromMe);
      for (index = 1; index <= fLinkedBody->GetSize(); index++)
      {
        TStructure subStructure;
        TBodyItem bodyItem;

        fLinkedBody->Get(index, &bodyItem);
        subStructure = GetStructureReadWrite(bodyItem.fCurrency);
        subStructure->fParent = currency;
// 13/10/93 the following messes up Redo of paste a section into selection of several paras in a list
//        if (!bodyItem.fAffected) // 9/2/93 [20618] bs thru sections into list
//          bodyItem.fState = kShown;
        bodyItem.fNew = TRUE;
        fLinkedBody->AtPut(index, &bodyItem);
        fDocument->DeleteFormatData(anchor->fCurrency, fSize + 1);
      }
      fLinkedBodyC  = 0;
    }
    fLinkedBody = NULL;
  }
  return link;  // 09/03/93
}


// ------------------------------------------------------------------------
bool _TBodyStructure::CanJoin(TCurrency item)
{
  return fKind == GetStructureReadOnly(item)->GetKind(); // 19/03/91
}

// ------------------------------------------------------------------------
// 21/8/92
void _TBodyStructure::DoPasteErrorRecovery(TCurrency currency, long endPos,
                TStructureCmd cmd)
{
  int newItem;
  TStructure structure;
  TCurrency curr;

  if (endPos < 0) // 24/8/92
    endPos = GetSize();
  // 24/08/92 more accurate implementation of FirstThat(IsNewItem)
  for (newItem = 1; newItem <= fSize; newItem++)
  {
    PBodyItem pbi = PBodyItem(At(newItem));

    if (pbi->fNew || pbi->fState == kHidden)
    {
      while (endPos >= newItem)
      {
        pbi = PBodyItem(At(endPos));

        if (pbi->fNew)
        {
          curr = GetBodyItem(endPos);
          structure = GetStructureReadWrite(curr);
          structure->Commit(curr, NULL, NULL, cmd, TRUE);  // 11/09/92 pass cmd
          Delete(endPos);
        }
        else if (pbi->fState == kHidden)
          ResetItemState(endPos);
        endPos--;
      }
      break;
    }
  }
}

// ------------------------------------------------------------------------
void _TBodyStructure::DoPasteFromClipboard(TCurrency currency,
      TCursorNode anchor, TCursorNode activeEnd, TTextDocument clipDocument,
      bool replace, TStructureCmd cmd)
{
  int splitIndex;
  int splitIndex1;
  volatile TCurrency splitItem;
  volatile TCurrency splitItem1;
  TCurrency splitItem2;
  volatile TStructure subBody;
  TBodyItem bodyItem;
  TBodyCursor node;
  bool resetAnchor, resetActive, sameSubBody;
  TCurrency saveBodyItem;     // 25/09/92
  FailInfo fi; // 21/8/92
  volatile bool splitDone = FALSE; // 21/8/92
  bool splitPath = FALSE; // 28/9/92
  int DDadjustment = 0; // 2/5/93
  long ignore;
  bool doFromRight;  // 06/10/93

  saveBodyItem = 0;
  resetActive = resetAnchor = FALSE;      // 24/09/92
  if (activeEnd->fCurrency == anchor->fCurrency)
    sameSubBody = TBodyCursor(anchor)->GetBodyItem() ==
                            TBodyCursor(activeEnd)->GetBodyItem();
  else
    sameSubBody = FALSE;

  if (replace)
    node = TBodyCursor(anchor);
  else
    node = TBodyCursor(activeEnd);
  splitItem = node->GetBodyItem();
  splitIndex = FindBodyItem(splitItem);

  // 09/09/92 for reformat selection after paste across paragraphs
  if (replace)
  {
    if (activeEnd == NULL || activeEnd->fCurrency != currency)
      splitIndex1 = MAXLONGINT;
    else
      splitIndex1 = FindBodyItem(TBodyCursor(activeEnd)->GetBodyItem());
  }
  else
    splitIndex1 = splitIndex;

  CatchFailures(&fi); // 21/8/92
  if (GetItemState(splitIndex) == kShown)
  {
    subBody = GetStructureReadWrite(splitItem);
    if (subBody->IsEmpty() || fKind == kFigure)
    {
      SetGone(splitIndex, TRUE);    // 17/08/92
      resetAnchor = TRUE;                                // 09/09/92
      resetActive = sameSubBody && (fKind != kFigure);   // 09/09/92 sameSubBody &&
      splitItem1  = 0;
    }
    else
    {
      resetAnchor = subBody->Split(node->GetNext(), splitItem, splitItem1, FALSE);
                                           // 08/10/93 [21067] return value - See Split
      splitDone = splitItem != 0 && splitItem1 != 0; // 21/8/92
      splitPath = TRUE; // 28/9/92
      resetActive = (!replace || sameSubBody) && splitItem != 0; // 09/09/92 && ...
    }
  }
  else
  {
    resetAnchor = TRUE;    // 24/09/92 replacement for above
    splitItem1 = 0;
  }

  doFromRight = !splitDone;                    // 06/10/93
  splitItem2 = splitItem1;                      // 09/09/92
  if (splitItem != 0 && splitItem2 != 0)
  {
    SetAffected(splitIndex, TRUE);    // 17/08/92
    bodyItem.fCurrency = splitItem2;
    bodyItem.fState = kShown;
    bodyItem.fNew = TRUE;
    bodyItem.fAffected = TRUE;
    bodyItem.fGone = TRUE;                           // 18/04/91 FALSE;
    bodyItem.fNoteNumber = 0;                        // 17/08/92 was uninitialised
    bodyItem.spare = 0;
    InsertBefore(splitIndex + 1, &bodyItem);
    resetActive = TRUE;                              // 09/09/92
    TBodyCursor(activeEnd)->SetBodyItem(splitItem2);
    TBodyCursor(activeEnd)->fCurrency = currency;
  }
  else if (resetActive && splitItem2 == 0)
  {
    int index;

    // 09/09/92 splitIndex to index NB use splitItem2 to avoid corrupting splitItem1
    splitItem2 = TBodyCursor(activeEnd)->GetBodyItem();
    index = FindBodyItem(splitItem2);
#ifdef DRAGDROP
    if (cmd->fCmdNumber == cMove && !splitPath)
    {
      splitItem2 |= 0x8000;
      DDadjustment = 1;
    }
    else
#endif
    if (++index > _GetSize())
      splitItem2  = 0;
    else
      splitItem2 = GetBodyItem(index);
#ifdef DRAGDROP
    if (cmd->fCmdNumber == cMove)
      DDadjustment = -1;
#endif
    TBodyCursor(activeEnd)->SetBodyItem(splitItem2);
    TBodyCursor(activeEnd)->fCurrency = currency;
  }
  else if (splitItem == 0)
  {
    resetAnchor = TRUE;
    splitIndex = FindBodyItem(TBodyCursor(anchor)->GetBodyItem());
#ifdef DRAGDROP
    if (cmd->fCmdNumber == cMove)
    {
      TCurrency c;
      splitItem2 = TBodyCursor(activeEnd)->GetBodyItem();
      c = splitItem2 | 0x8000;
      resetActive = TRUE;
      doFromRight = FALSE;                        // 06/10/93
      TBodyCursor(activeEnd)->SetBodyItem(c);
    }
#endif
  }
  else if (splitPath && splitItem != 0 && splitItem1 == 0) // 28/9/92,19/09/92 new clause
  {
    resetAnchor = FALSE;
    saveBodyItem = TBodyCursor(anchor)->GetBodyItem();    // 25/09/92
    TBodyCursor(anchor)->SetBodyItem(splitIndex == _GetSize()? 
                                        gNullCurrency: GetBodyItem(splitIndex + 1)); // 25/9/92
    TBodyCursor(anchor)->fCurrency = currency;
  }

  _TStructure::PasteFromClipboard(currency, anchor, activeEnd, clipDocument, &ignore, cmd);

  if (fKind == kFigure)                            // 18/04/91 new clause
  {
    ResetCursor(anchor, 1, FALSE, FALSE);
    ResetCursor(activeEnd, GetSize(), TRUE, FALSE);
  }
  else if (resetAnchor)
    ResetCursor(anchor, splitIndex, /* 08/10/93 [21067] FALSE */ resetAnchor == 2,
                                             TRUE); // ! FALSE);
  else if (saveBodyItem != 0)
    TBodyCursor(anchor)->SetBodyItem(saveBodyItem);    // 25/09/92

  if (resetActive)          // 09/09/92 new clause
  {
    if (splitItem2 == 0)
      splitIndex = GetSize();
    else
      splitIndex = FindBodyItem(splitItem2) + DDadjustment;
    if (splitIndex > splitIndex1)
      ResetCursor(activeEnd, splitIndex, doFromRight, // FALSE, wrong but best of two evils!
              /* FALSE 28/09/92 paste tab at end into empty doc  TRUE, */ FALSE);
  }
  Success(&fi);
  cmd->fHasSplit |= splitDone;      // 28/09/92
//  fCanSplit |= splitDone * 2;     // 24/09/92
  return;
Rescue:
  if (splitDone)
    subBody->DoJoin(splitItem, splitItem1);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
int _TBodyStructure::AtEnds(TCursorNode cursorNode)
{
  TCurrency splitItem;
  TStructure subBody;
  int splitIndex;
  int pos;

  if (fKind == kFigure)
    return 1;
  if (fDeletions == 1 && !fCanSplit)        // 05/10/93: == 1 (not cleared by cMove)
    return 1;
  splitItem = TBodyCursor(cursorNode)->GetBodyItem();
  splitIndex = FindBodyItem(splitItem);
  subBody = GetStructureReadWrite(splitItem);
  pos = subBody->AtEnds(cursorNode->GetNext());
  if ((splitIndex == 1 && pos == -1) || (splitIndex == GetSize() && pos == 1))
    return pos;
  return 0;
}


// ------------------------------------------------------------------------
int _TBodyStructure::Split(TCursorNode cursorNode, TCurrency &newStart,
                                   TCurrency &newEnd, bool keepEmptyStart)
{
  TDiscObject obj;
  volatile TBodyStructure newBody;
  int splitIndex;
  TCurrency splitItem;
  TCurrency splitItem1;
  TStructure subBody;
  int index;
  FailInfo fi;
  TBodyItem bodyItem;
  int Split_r = 0;

  if (fKind == kFigure)
    return _TStructure::Split(cursorNode, newStart, newEnd, keepEmptyStart);

  newStart = TBodyCursor(cursorNode)->fCurrency;
  splitItem = TBodyCursor(cursorNode)->GetBodyItem();
  splitIndex = FindBodyItem(splitItem);
  subBody = GetStructureReadWrite(splitItem);
  newBody = NULL;
  if (fDeletions == 1 && !fCanSplit)        // 05/10/93: == 1 (not cleared by cMove)
  {
    newEnd = 0;
    subBody->Split(cursorNode->GetNext(), splitItem, splitItem1, keepEmptyStart);
    if (splitItem != 0 && splitItem1 != 0)
    {
      bodyItem.fCurrency = splitItem1;
      bodyItem.fState = kShown;
      bodyItem.fNew = TRUE;
      bodyItem.fAffected = FALSE;
      bodyItem.fGone = FALSE;
      bodyItem.fNoteNumber = 0;            // 17/08/92 was uninitialised
      bodyItem.spare = 0;
      InsertBefore(splitIndex + 1, &bodyItem);
// 09/09/92      TBodyCursor(cursorNode)->SetBodyItem(splitItem1);
    }
  }
  else
  {
    // 11 to 18/10/93 split sensibly after Clear (it would be easier if a blank para was
    // not left around sometimes - when a para is cleared, but not other times)

    if (GetItemState(splitIndex) != kShown)
    {
      if (splitIndex == 1)                             // cleared from start
        splitItem = 0;
      else
      {
        splitItem1 = 0;
        if (FirstThatIsVisible(splitIndex) == 0)    // if all rest to end cleared
          splitIndex = GetSize();
      }
    }
    else if (splitIndex < GetSize() && FirstThatIsVisible(splitIndex + 1) == 0)
    {
      // if all rest cleared
      splitIndex = GetSize();
      splitItem1 = 0;
    }
    else
      // 11 to 18/10/93 end
      Split_r = subBody->Split(cursorNode->GetNext(), splitItem, splitItem1, keepEmptyStart);

    if (splitIndex == 1 && splitItem == 0)
    {
      newEnd = newStart;
      newStart = 0;
    }
    else
    {
      CatchFailures(&fi);       // 11/10/93 moved from before Split
      newEnd = fDocument->NewCurrency(kBodyStruct, obj);
      newBody = TBodyStructure(obj);
      newBody->fStyle = fStyle;
      newBody->fChanges = fChanges;
      newBody->fParent = fParent;
      newBody->fKind = fKind;
      newBody->fLastHit = 1;
      newBody->fHeadingType = fHeadingType;
      newBody->fCaption = kBtmCaption;
      for (index = GetSize(); index > splitIndex; index--)
      {
        GetLast(&bodyItem);
        Delete(GetSize());
        bodyItem.fNew = TRUE;
        // 10/10/93 [21067] may have been set by clear!: bodyItem.fAffected = FALSE;
        subBody = GetStructureReadWrite(bodyItem.fCurrency);
        subBody->fParent = newEnd;
        fDocument->DeleteFormatData(newStart, index);
        newBody->InsertFirst(&bodyItem);
      }
      // in-line UpdateHalves();
      {
        if (splitItem1 == 0)
        {
          if (newBody->GetSize() > 0)
          {
            newBody->GetFirst(&bodyItem);
            splitItem1 = bodyItem.fCurrency;
          }
          else
          {
            fDocument->DeleteCurrency(newEnd);
            newEnd = 0;
          }
        }
        else
        {
          Get(splitIndex, &bodyItem);
          bodyItem.fCurrency = splitItem1;
          bodyItem.fNew = TRUE;
          bodyItem.fAffected = TRUE;          // 19/02/91 from FALSE
          subBody = GetStructureReadWrite(splitItem1);
          subBody->fParent = newEnd;
          newBody->InsertFirst(&bodyItem);
          if (splitItem == 0)
          {
            // 09/10/93 [21067] end up with same entry in body twice after Undo
            // .. replaced by delete it SetGone(splitIndex, TRUE);
            Delete(splitIndex);
            fDocument->DeleteFormatData(newStart, splitIndex);
            Split_r = 2;
          }
          else
          {
            bodyItem.fCurrency = splitItem;
            bodyItem.fNew = FALSE;
            AtPut(splitIndex, &bodyItem);
          }
        }
      }
      // end in-line UpdateHalves();

// 09/09/92      if (newEnd > 0)
// 09/09/92      {
// 09/09/92        TBodyCursor(cursorNode)->SetBodyItem(splitItem1);
// 09/09/92        TBodyCursor(cursorNode)->fCurrency = newEnd;
// 09/09/92      }
      Success(&fi);
    }
  }
  return Split_r;

Rescue:
  if (newBody != NULL)
  {
    for (index = 1; index <= newBody->GetSize(); ++index)
    {
      newBody->GetFirst(&bodyItem);
      newBody->Delete(1);
      bodyItem.fNew = TRUE;
      subBody = GetStructureReadWrite(bodyItem.fCurrency);
      subBody->fParent = newStart;
      InsertLast(&bodyItem);
    }
    fDocument->DeleteCurrency(newEnd);
  }
  newStart = 0;
  newEnd = 0;
  ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
// 21/8/92
bool _TBodyStructure::DoJoin(TCurrency myCurrency, TCurrency currencyToJoin)
{
  FailInfo fi;
  TBodyStructure bodyToJoin;
  volatile int lastIndex;
  int index;

  lastIndex = GetSize();   // 03/08/93 move above GetStructure in case it fails
  CatchFailures(&fi);
  bodyToJoin = TBodyStructure(GetStructureReadOnly(currencyToJoin));
  
  for (index = 1; index <= bodyToJoin->GetSize(); index++)
  {
    TBodyItem bodyItem;

    bodyToJoin->Get(index, &bodyItem);
    InsertLast(&bodyItem);
  }
  Success(&fi);
  return TRUE;

Rescue:
  for (index = GetSize(); index > lastIndex; index--)
    Delete(index);
  return FALSE;
}

// ------------------------------------------------------------------------
bool _TBodyStructure::Join(TCurrency myCurrency)
{
  TCurrency bodyToJoin;

  if (fLinkedBodyC <= 0)    // 29/09/92 test for -1 too ???
    return FALSE;
  bodyToJoin = fLinkedBodyC;
  fLinkedBody = 0;
  fLinkedBodyC  = 0;
  return DoJoin(myCurrency, bodyToJoin);
}


// ------------------------------------------------------------------------
#ifdef DRAGDROP
// ================= ORIGINAL CLEAR FOLLOWS #ELSE =============================
bool _TBodyStructure::Clear(TCursorNode anchor, TCursorNode activeEnd,
                    TClearTypes clearType, /* returns bool &gone, */ int &ch)
{
  bool gone;        // 26/05/94 now func result
  int firstIndex;
  int lastIndex;
  int index;
  TCurrency currency1;
  TCurrency currency2;
  TStructure subBody1;
  TStructure subBody2;
  TCursorNode anchorNext;
  TCursorNode activeNext;
  TCursorNode nextNode;
  bool fromRight;
  TDiscObject obj;
  TBodyItem bodyItem;
  bool clearAndCR;
  bool singleItem;
  bool figPartOrNoteStuff = FALSE;
  // TStructure parent = this;
#ifdef FN
//  bool doNotes = FALSE;
#endif
//  bool clearedByPaste = clearType == kClearedByPaste;

  gone = FALSE;
  clearAndCR = ch == chReturn;
//  subBody1Gone = TRUE;

//  figPartOrNoteStuff =
//#ifdef FN
//                       fKind == kNoteSet || fKind == kFootnote ||
//#endif
//                       IsPartOf((1 << kFigure));
// 24/01/94 IsPartOf passed a set of TStyleTypes
// 18/02/94 use IsPartOf as it is not FN only
//  while (parent->fParent != 0)      // 23/05/91 new loop
//  {
//    parent = GetStructureReadOnly(parent->fParent);
//    if (parent->GetBodyKind() == kFigure)
//    {
//      figPartOrNoteStuff = TRUE;
//      break;
//    }
//  }

  if (clearType == kClearedByMove)            // 05/10/93
    fDeletions = 2;
  else
    fDeletions = TRUE;

  if (anchor == NULL)
  {
    firstIndex = 1;
    anchorNext = NULL;
    currency1 = GetBodyItem(1);
//    subBody1 = GetStructureReadWrite(currency1);
  }
  else
  {
    anchorNext = anchor->GetNext();
    currency1 = TBodyCursor(anchor)->GetBodyItem();
#ifdef FN
    if (currency1 == GetNoteCollector())
      firstIndex = -1;       // doNotes = TRUE;
    else
#endif
      firstIndex = FindBodyItem(currency1);

    // 20/05/94 [21815], [21816] in figures and notes we must ensure that the whole lot
    // is not cleared. What should happen is that the first leaf in the first body in the
    // first body, in the ..., is not just marked as hidden. figPartOrNoteStuff is set in
    // this case. Attempts such as passing chClear through to the notes, and setting
    // figPartOrNoteStuff wherever we were in a figure are unnecessary and may cause
    // crashes by not clearing things in the middle of the selection.
#ifdef FN
    if (fKind == kNoteSet)
      figPartOrNoteStuff = TRUE;
    else
#endif
    if (firstIndex == 1)
      figPartOrNoteStuff = IsPartOf((1 << kFigure)
#ifdef FN
                       | (1 << kNoteSet) | (1 << kFootnote)
#endif
                        );
  }
  subBody1 = GetStructureReadWrite(currency1);

  if (activeEnd == NULL)
  {
    lastIndex = _GetSize();
    activeNext = NULL;
    currency2 = GetBodyItem(lastIndex);
    subBody2 = GetStructureReadWrite(currency2);
  }
  else
  {
    activeNext = activeEnd->GetNext();
    currency2 = TBodyCursor(activeEnd)->GetBodyItem();
    lastIndex = FindBodyItem(currency2);
    subBody2 = GetStructureReadWrite(currency2);
    fCanSplit = FALSE;
    if (clearType == kClearedByPaste)           // 09/09/92 for paste across paragraphs
    {
      if (fParent != 0)
      {
        if (subBody1->fParent == subBody2->fParent)
          fCanSplit = TRUE;
      }
      else if (subBody1 == subBody2)
          fCanSplit = TRUE;
    }
  }

#ifdef FN
  if (firstIndex < 0)  // if (doNotes)
  {
    if (ch == chBackspace && clearType == kClearedByPaste) 
                    // 18/02/94 [21409] do not reset if a Return, 20/05/94 [21815]
      ch = chClear;  // 11/12/92 for select whole footnote & paste a word?
    gone = subBody1->Clear(anchorNext, activeNext, clearType, ch);
  }
  else
#endif
  {
    bool subBody1Gone;
    bool subBody2Gone = TRUE;

    if (firstIndex == lastIndex)
      nextNode = activeNext;
    else
      nextNode = NULL;

    if (subBody1->AllSelected(currency1, anchorNext, nextNode) && !figPartOrNoteStuff)
    {
      if (anchor == NULL || GetBodyKind() == kFigure)     // 05/03/91 2nd test
      {
        /* subBody1Gone = */ subBody1->Clear(anchorNext, nextNode, clearType, ch);
        SetAffected(firstIndex, TRUE);  // 17/08/92
        subBody1Gone = TRUE;
      }
      else if (clearAndCR || ch != chBackspace || nextNode == NULL) // 22/6/92
      {
        int subBody1Kind;

#ifdef TRACE
        if (clearAndCR)
          Assert(ch != chBackspace, 453);  // clearAndCR test a waste of space
#endif
        subBody1Gone = subBody1->Clear(anchorNext, nextNode, clearType, ch);
        SetAffected(firstIndex, TRUE);  // 17/08/92
        subBody1Kind = subBody1->GetKind();
        if (clearAndCR) // 22/6/92
          ch = chClear;
        if (subBody1Kind == kFigure
#ifdef TABLES
                  || subBody1Kind == kColumns
#endif
             ) // 11/07/91
          clearAndCR = FALSE;                                    // 11/07/91
        // 08/06/93 [20924] else
        // 08/06/93 [20924]   subBody1Gone = clearType == kClearedByMove;
      }
      else
        subBody1Gone = TRUE;
    }
    else
    {
      subBody1Gone = subBody1->Clear(anchorNext, nextNode, clearType, ch);
      if (figPartOrNoteStuff)
        subBody1Gone = FALSE;
      SetAffected(firstIndex, TRUE);   // 17/08/92
    }

// 17/09/92   if (fCanSplit && subBody1Gone)
//      fCanSplit = FALSE;

    if (lastIndex > firstIndex)
    {
      bool isAllSelected = subBody2->AllSelected(currency2, NULL, activeNext);

      singleItem = FALSE;
      if (!isAllSelected || !clearAndCR)              // 21/02/91 new test
      {
        subBody2Gone = subBody2->Clear(NULL, activeNext, clearType, ch);
        SetAffected(lastIndex, TRUE);   // 17/08/92
      }
      if (isAllSelected)
      {
        subBody2Gone = TRUE;
        if (clearAndCR)
          ch = chClear;
      }
    }
    else
    {
      subBody2Gone = subBody1Gone;
      singleItem = TRUE;
    }

    if (GetBodyKind() == kFigure && (firstIndex == lastIndex || subBody2Gone != subBody1Gone))
      subBody2Gone = subBody1Gone = FALSE;

    gone = subBody1Gone && subBody2Gone && lastIndex - firstIndex + 1 == _GetSize();

#ifdef FN
    if (gone && (fKind == kFootnote))
    {
#ifdef TRACE
      Assert(0, 452);     // test seems a waste of time
#endif
      gone = FALSE;
      subBody1Gone = FALSE;
    }
#endif

    for (index = firstIndex + !subBody1Gone; index <= lastIndex - !subBody2Gone; index++)
      SetGone(index, TRUE);   // 17/08/92

    if (!gone)
    {
      if (anchor != NULL && subBody1Gone && clearType == kNormalClear)
      {
        anchor->Collapse();
        if (firstIndex > 1)
                        // 08/02/91 && subBody2Gone &&
                        // (subBody1 != subBody2 || firstIndex == _GetSize()))
        {
          firstIndex = firstIndex - 1;
          fromRight = TRUE;
          singleItem = TRUE;
        }
        else
        {
          firstIndex = lastIndex + subBody2Gone;
          singleItem = FALSE;                        // 21/03/91
          fromRight = FALSE;
        }
        currency1 = GetBodyItem(firstIndex);
        TBodyCursor(anchor)->SetBodyItem(currency1);
        subBody2 = GetStructureReadOnly(currency1);
        SetAffected(firstIndex, subBody2->GetKind() != kPict);  // 17/08/92
        subBody2->ExtendCursor(anchor, currency1, fromRight, TRUE, FALSE); // 05/03/91
      }
                       // 19/03/91 singleItem for anchor != activeEnd
      if (!singleItem && lastIndex < _GetSize() && activeEnd != NULL && subBody2Gone)
      {
        if (clearType == kNormalClear)
        {
          activeEnd->Collapse();
          currency1 = GetBodyItem(lastIndex + 1);
          SetAffected(lastIndex + 1, !subBody1Gone);  // 17/08/92
                                  // 3/12/91 undo deleted 1st chapter screwed 2nd chapter
                                  // 21/03/91 from TRUE 27/06/91 from FALSE
          TBodyCursor(activeEnd)->SetBodyItem(currency1);
          subBody2 = GetStructureReadOnly(currency1);
          subBody2->ExtendCursor(activeEnd, currency1, TRUE, TRUE, FALSE);
        }
      }
    }
#ifdef FN
    if (fKind == kDocument) // [20863] 12,17/5/93 added !doNotes 10/02/94 remv!doNotes
      ShowHideNotes();
#endif
  }
  // 18/02/94 [21409] this block moved out one level so done if doNotes
  if ((fKind == kDocument || fKind == kHeader || fKind == kFooter) &&
                         clearType != kClearedByPaste) // 27/4/93 was kNormalClear
    // 18/02/94 [21409] will call LinkSelection twice & unlink the 2nd time... but only
    // 18/02/94 in Chapter endnotes, because non-chapter notes exited w/o doing this test
    // 18/02/94 #ifdef FN
    // 18/02/94         || fKind == kNoteSet
    // 18/02/94 #endif
  {
    if (gone)
    {
      currency1 = fDocument->NewCurrency(kTextStruct, obj);
      TStructure(obj)->InitNewStructure(anchor->fCurrency, currency1, gNullCurrency, kText,
                           TRUE, NULL);  // 24/03/92 last param added
      bodyItem.fCurrency = currency1;
      bodyItem.fState = kShown;
      bodyItem.fNew = TRUE;
      bodyItem.fAffected = FALSE;     // 05/07/91 back to FALSE
      bodyItem.fGone = TRUE;          // 21/03/91 from FALSE
      bodyItem.fNoteNumber = 0;       // 17/08/92 was uninitialised
      bodyItem.spare = 0;
      if (clearAndCR)
        ch = chBackspace;
      PBodyItem(_At(1))->fState = kHidden;
      InsertFirst(&bodyItem);
      ResetCursor(anchor, 0, FALSE, FALSE);       // 05/03/91 False param
    } 
    else
      LinkSelection(anchor, activeEnd, FALSE);
  }
  return gone;
}

#else

// ------------------------------------------------------------------------
void _TBodyStructure::Clear(TCursorNode anchor, TCursorNode activeEnd,
                                          TClearTypes clearType, bool &gone, int &ch)
{
  int firstIndex;
  int lastIndex;
  int index;
  TCurrency currency1;
  TCurrency currency2;
  TStructure subBody1;
  TStructure subBody2;
  bool subBody1Gone;
  bool subBody2Gone;
  TCursorNode anchorNext;
  TCursorNode activeNext;
  TCursorNode nextNode;
  bool fromRight;
  TDiscObject obj;
  TBodyItem bodyItem;
  bool clearAndCR;
  bool singleItem;
  bool figPartOrNoteStuff = FALSE;
  TStructure parent = this;
#ifdef FN
  bool doNotes = FALSE;
//  bool noteStuff;
#endif

  gone = FALSE;
  clearAndCR = ch == chReturn;
  subBody1Gone = TRUE;
  subBody2Gone = TRUE;

#ifdef FN
  figPartOrNoteStuff =
       IsPartOf(1 << kFigure) != 0 || fKind == kNoteSet || fKind == kFootnote;
       // 24/01/94 IsPartOf passed a set of TStyleTypes
#else
  while (parent->fParent != 0)      // 23/05/91 new loop
  {
    parent = GetStructureReadOnly(parent->fParent);
    if (parent->GetBodyKind() == kFigure)
    {
      figPartOrNoteStuff = TRUE;
      break;
    }
  }
#endif

  fDeletions = TRUE;

  if (anchor == NULL)
  {
    firstIndex = 1;
    anchorNext = NULL;
    currency1 = GetBodyItem(1);
    subBody1 = GetStructureReadWrite(currency1);
  }
  else
  {
    anchorNext = anchor->GetNext();
    currency1 = TBodyCursor(anchor)->GetBodyItem();
#ifdef FN
    if (currency1 != GetNoteCollector())
      firstIndex = FindBodyItem(currency1);
    else
      doNotes = TRUE;
#else
    firstIndex = FindBodyItem(currency1);
#endif
    subBody1 = GetStructureReadWrite(currency1);
  }

  if (activeEnd == NULL)
  {
    lastIndex = _GetSize();
    activeNext = NULL;
    currency2 = GetBodyItem(lastIndex);
    subBody2 = GetStructureReadWrite(currency2);
  }
  else
  {
    activeNext = activeEnd->GetNext();
    currency2 = TBodyCursor(activeEnd)->GetBodyItem();
    lastIndex = FindBodyItem(currency2);
    subBody2 = GetStructureReadWrite(currency2);
    fCanSplit = FALSE;
    if (clearType == kClearedByPaste)           // 09/09/92 for paste across paragraphs
    {
      if (fParent != 0)
      {
        if (subBody1->fParent == subBody2->fParent)
          fCanSplit = TRUE;
      }
      else if (subBody1 == subBody2)
          fCanSplit = TRUE;
    }
// 09/09/92    fCanSplit = (clearedByPaste && currency1 == currency2);
  }

#ifdef FN
  if (doNotes)
  {
    ch = chClear;      // 11/12/92 for select whole footnote & paste a word ???
    subBody1->Clear(anchorNext, activeNext, clearType, gone, ch);
  }
  else
#endif
  {
    if (firstIndex == lastIndex)
      nextNode = activeNext;
    else
      nextNode = NULL;

    if (subBody1->AllSelected(currency1, anchorNext, nextNode) && !figPartOrNoteStuff)
//#ifdef FN
//        && !noteStuff
//#endif
    {
      if (anchor == NULL || GetBodyKind() == kFigure)     // 05/03/91 2nd test
      {
        subBody1->Clear(anchorNext, nextNode, clearType, subBody1Gone, ch);
        SetAffected(firstIndex, TRUE);  // 17/08/92
        subBody1Gone = TRUE;
      }
      else if (clearAndCR || ch != chBackspace || nextNode == NULL) // 22/6/92
         // 19/02/91 || (!clearedByPaste &&
         // ( /* 08/02/91 subBody1->GetBodyKind() == kText || */ nextNode == NULL)))
      {
        int subBody1Kind;

        subBody1->Clear(anchorNext, nextNode, clearType, subBody1Gone, ch);
        SetAffected(firstIndex, TRUE);  // 17/08/92
        subBody1Kind = subBody1->GetBodyKind();
        if (clearAndCR) // 22/6/92
          ch = chClear;
        if (subBody1Kind == kFigure || subBody1Kind == kColumns) // 11/07/91
          clearAndCR = FALSE;                                    // 11/07/91
        else
          subBody1Gone = FALSE;
      }
      else
        subBody1Gone = TRUE;
    }
    else
    {
      subBody1->Clear(anchorNext, nextNode, clearType, subBody1Gone, ch);
      if (figPartOrNoteStuff)
//#ifdef FN
//          || noteStuff
//#endif
        subBody1Gone = FALSE;
      SetAffected(firstIndex, TRUE);   // 17/08/92
    }

// 17/09/92   if (fCanSplit && subBody1Gone)
//      fCanSplit = FALSE;

    if (lastIndex > firstIndex)
    {
      bool isAllSelected = subBody2->AllSelected(currency2, NULL, activeNext);

      singleItem = FALSE;
      if (!isAllSelected || !clearAndCR)              // 21/02/91 new test
      {
        subBody2->Clear(NULL, activeNext, clearType, subBody2Gone, ch);
//        PBodyItem(_At(lastIndex))->fAffected = TRUE;
        SetAffected(lastIndex, TRUE);   // 17/08/92
      }
      if (isAllSelected)
      {
        subBody2Gone = TRUE;
        if (clearAndCR)
          ch = chClear;
      }
    }
    else
    {
      subBody2Gone = subBody1Gone;
      singleItem = TRUE;
    }

    if (GetBodyKind() == kFigure &&
                (firstIndex == lastIndex || subBody2Gone != subBody1Gone))
      subBody2Gone = subBody1Gone = FALSE;

    gone = subBody1Gone && subBody2Gone &&
                                  lastIndex - firstIndex + 1 == _GetSize();

#ifdef FN
    if (gone && (fKind == kFootnote))
    {
      gone = FALSE;
      subBody1Gone = FALSE;
    }
#endif

    for (index = firstIndex + !subBody1Gone;
                              index <= lastIndex - !subBody2Gone; index++)
      SetGone(index, TRUE);   // 17/08/92

    if (!gone)
    {
      if (anchor != NULL && subBody1Gone && clearType == kNormalClear)
      {
        anchor->Collapse();
        if (firstIndex > 1)
                        // 08/02/91 && subBody2Gone &&
                        // (subBody1 != subBody2 || firstIndex == _GetSize()))
        {
          firstIndex = firstIndex - 1;
          fromRight = TRUE;
          singleItem = TRUE;
        }
        else
        {
          firstIndex = lastIndex + subBody2Gone;
          singleItem = FALSE;                        // 21/03/91
          fromRight = FALSE;
        }
// 16/06/91 moved down:   PBodyItem(_At(firstIndex))->fAffected = TRUE;       // 05/03/91 new
        currency1 = GetBodyItem(firstIndex);
        TBodyCursor(anchor)->SetBodyItem(currency1);
        subBody2 = GetStructureReadOnly(currency1);
        SetAffected(firstIndex, subBody2->GetBodyKind() != kPict);  // 17/08/92
//        PBodyItem(_At(firstIndex))->fAffected = (subBody2->GetBodyKind() != kPict);
                          // 05/03/91 new  16/06/91 = (..) from = TRUE
        subBody2->ExtendCursor(anchor, currency1, fromRight, TRUE, FALSE); // 05/03/91
      }
                       // 19/03/91 singleItem for anchor != activeEnd
      if (!singleItem && lastIndex < _GetSize() && activeEnd != NULL &&
                           subBody2Gone && clearType == kNormalClear)
      {
        activeEnd->Collapse();
        currency1 = GetBodyItem(lastIndex + 1);
        SetAffected(lastIndex + 1, !subBody1Gone);  // 17/08/92
//        PBodyItem(_At(lastIndex + 1))->fAffected = !subBody1Gone;
                                  // 3/12/91 undo deleted 1st chapter screwed 2nd chapter
                                  // 21/03/91 from TRUE 27/06/91 from FALSE
        TBodyCursor(activeEnd)->SetBodyItem(currency1);
        subBody2 = GetStructureReadOnly(currency1);
        subBody2->ExtendCursor(activeEnd, currency1, TRUE, TRUE, FALSE);
      }
    }
#ifdef FN
    if (!doNotes && fKind == kDocument) // [20863] 12/5/93, 17/5/93 added !doNotes
      ShowHideNotes();
#endif
    if ((fKind == kDocument || fKind == kHeader || fKind == kFooter
#ifdef FN
         || fKind == kNoteSet
#endif
       ) && clearType != kClearedByPaste) // 27/4/93 was kNormalClear
    {
      if (gone)
      {
        currency1 = fDocument->NewCurrency(kTextStruct, obj);
        TStructure(obj)->InitNewStructure(anchor->fCurrency, currency1, gNullCurrency, kText,
                           TRUE, NULL);  // 24/03/92 last param added
        bodyItem.fCurrency = currency1;
        bodyItem.fState = kShown;
        bodyItem.fNew = TRUE;
        bodyItem.fAffected = FALSE;     // 05/07/91 back to FALSE
        bodyItem.fGone = TRUE;          // 21/03/91 from FALSE
        bodyItem.fNoteNumber = 0;       // 17/08/92 was uninitialised
        bodyItem.spare = 0;
        if (clearAndCR)
          ch = chBackspace;
        PBodyItem(_At(1))->fState = kHidden;
        InsertFirst(&bodyItem);
        ResetCursor(anchor, 0, FALSE, FALSE);       // 05/03/91 False param
      } 
      else
        LinkSelection(anchor, activeEnd, FALSE);
    }
  }
}
#endif

// ------------------------------------------------------------------------
bool _TBodyStructure::InSecondHalf(TCursorNode cursor)
{
  TCursorNode child;
  TStructure item;
  int index;

  if (_GetSize() == 1)
  {
    child = cursor->GetNext();
#ifdef TRACE
    Assert(child, 30);
#endif
    item = GetStructureReadOnly(child->fCurrency);
    return item->InSecondHalf(child);
  }

  index = FindBodyItem(TBodyCursor(cursor)->GetBodyItem());
  return index > ((_GetSize() + 1) / 2); // 25/07/90 & 01/05/91 + 1
}


// ------------------------------------------------------------------------
void _TBodyStructure::GivePastePosition(TCursorNode cursor,
                                        long &startPos, long &endPos)
{
  TCurrency currency;

  startPos = -1;
  if (Curr_fType(cursor->fCurrency) == kBodyStruct)
    currency = TBodyCursor(cursor)->GetBodyItem();
  else
    currency  = 0;

  if (currency == 0)
    endPos = -1;
#ifdef DRAGDROP
  else if (currency & 0x8000)
  {
    currency &= ~0x8000;
    TBodyCursor(cursor)->SetBodyItem(currency);
    endPos = FindBodyItem(currency);
  }
#endif
  else
  {
    endPos = FindBodyItem(currency);
    // 17/09/92 new loop
    while (endPos > 1 && GetItemState(endPos - 1) == kHidden)
      endPos--;
  }
}


// ------------------------------------------------------------------------
int _TBodyStructure::CanDoPaste(TCurrency currency,
                                   TStructure dataToPaste, int numOfItems)
{
  TStyleTypes pasteKind;
  TStyleTypes myKind;

  // 05/03/91 returns changed
  if (fKind == kDocument)
    return 1;
  // 05/10/93  if (!_TStructure::IsShown(myCurrency, gNullCurrency))        // 25/04/91
  // 05/10/93    return 0;
  pasteKind = dataToPaste->GetKind();
  myKind = GetBodyKind();
  
  if (pasteKind == kSection && myKind == kSection)
    return -1;
  if (pasteKind == kList && myKind == kList)
    return -1;
  if (pasteKind == kSection && myKind == kList)       // 18/04/91
    return 0;
  return (pasteKind != kChapter || (myKind == kFigure && numOfItems == 1));
}


// ------------------------------------------------------------------------
bool _TBodyStructure::AllSelected(TCurrency currency, TCursorNode anchor,
                                  TCursorNode activeEnd)
{
  TCurrency subCurrency;
  TStructure subStruct;
  bool selected = FALSE;

  if (anchor == NULL)
    selected = TRUE;
  else
  {
    subCurrency = TBodyCursor(anchor)->GetBodyItem();
    if (FindBodyItem(subCurrency) == 1)             // 28/01/91 new clause
    {
      subStruct = GetStructureReadOnly(subCurrency);
      selected = subStruct->AllSelected(subCurrency, anchor->GetNext(), NULL);
    }
  }

  if (activeEnd != NULL)
  {
    subCurrency = TBodyCursor(activeEnd)->GetBodyItem();
    if (FindBodyItem(subCurrency) == _GetSize())             // 28/01/91 new clause
    {
      subStruct = GetStructureReadOnly(subCurrency);
      selected = selected &&
            subStruct->AllSelected(subCurrency, NULL, activeEnd->GetNext());
    }
    else
      selected = FALSE;
  }
  return selected;
}


// ------------------------------------------------------------------------
void _TBodyStructure::ToggleState(TCurrency currency, TCursorNode anchor,
                             TCursorNode activeEnd, TCommand command)
{
  int firstIndex;
  int lastIndex;
  int index;
  TCurrency subCurrency1;
  TCurrency subCurrency2;
  TStructure subBody1;
  TStructure subBody2;
  TCursorNode nextAnchor;
  TCursorNode nextActive;
  TCursorNode nextNode;
  bool paste, action;
  TBodyItem bodyItem;
  bool deletions;
//  bool clearText;
  bool splitText;
//  bool isAllSelected;
//  bool typing;
#ifdef FN
//  bool doNotes = FALSE;
#endif

  if (command->fCmdNumber == cRemoveStruct && fDeletions)
    return;         // 17/09/92

  splitText = (command->fCmdNumber == cTypingReturn);
                                // Mac picks up fChar field of command
//  clearText = splitText || command->fCmdNumber == cClear ||
//                                      command->fCmdNumber == cCut;
                     // Mac tests fChar field of command for chClear
  subBody1 = NULL;
  subBody2 = NULL;
  if (anchor == NULL)
  {
    subCurrency1 = GetBodyItem(1);
    nextAnchor = NULL;
    firstIndex = 1;
  }
  else
  {
    nextAnchor = anchor->GetNext();
    subCurrency1 = TBodyCursor(anchor)->GetBodyItem();
#ifdef FN
    if (subCurrency1 == GetNoteCollector())
      firstIndex = -1;   // doNotes = TRUE;
    else
#endif
      firstIndex = FindBodyItem(subCurrency1);
  }

  if (activeEnd == NULL)
  {
    lastIndex = fSize;
    subCurrency2 = GetBodyItem(lastIndex);
    nextActive = NULL;
  }
  else
  {
    subCurrency2 = TBodyCursor(activeEnd)->GetBodyItem();
    fLastHit = 0;                           // 08/02/91 force full search
    lastIndex = FindBodyItem(subCurrency2);
    nextActive = activeEnd->GetNext();
    if (lastIndex > fSize)
    {
      lastIndex = fSize;
      nextActive = NULL;
    }
  }

  subBody1 = GetStructureReadWrite(subCurrency1);
#ifdef FN
  if (firstIndex < 0)       // doNotes)
  {
    subBody1->ToggleState(subCurrency1, nextAnchor, nextActive, command);
  }
  else
#endif
  {
    Get(firstIndex, &bodyItem);
    if (firstIndex == lastIndex)
      nextNode = nextActive;
    else
    {
      nextNode = NULL;
// 11/02/91    if (splitText)
// 11/02/91      clearText = FALSE;
    }

    // 08/02/91 conditional moved from below next one
#ifdef DRAGDROP
    if (bodyItem.fAffected)
#else
    if (bodyItem.fAffected || !fDeletions)
#endif
      subBody1->ToggleState(subCurrency1, nextAnchor, nextNode, command);

//  isAllSelected = subBody1->AllSelected(subCurrency1, nextAnchor, nextNode);
//  typing = subBody1->CanType();
//  if ((isAllSelected && !clearText && typing) || (!typing && !isAllSelected))
                                                   // 15/02/91 || condition
    if (bodyItem.fGone)                            // 19/02/91
    {
//    bodyItem.fState = !bodyItem.fState;
      TOGGLESTATE(bodyItem.fState);  // 14/08/92
      if (bodyItem.fState == kShown)
        subBody1->fParent = currency;
      AtPut(firstIndex, &bodyItem);
    }

    firstIndex = firstIndex + 1;

    if (lastIndex >= firstIndex)
    {
      subBody2 = GetStructureReadWrite(subCurrency2);
      Get(lastIndex, &bodyItem);

      // 08/02/91 conditional moved from below next one
#ifdef DRAGDROP
      if (bodyItem.fAffected)
#else
      if (bodyItem.fAffected || !fDeletions)
#endif
        subBody2->ToggleState(subCurrency2, NULL, nextActive, command);

//    if (subBody2->AllSelected(subCurrency2, NULL, nextActive) &&
//                         (bodyItem.fAffected || subBody2->CanType()))
      if (bodyItem.fGone)                            // 19/02/91
      {
//      bodyItem.fState = !bodyItem.fState;
        TOGGLESTATE(bodyItem.fState);  // 14/08/92
        if (bodyItem.fState == kShown)
          subBody2->fParent = currency;
        AtPut(lastIndex, &bodyItem);
      }
      lastIndex = lastIndex - 1;
    }

    for (index = firstIndex; index <= lastIndex; ++index)
    {
      Get(index, &bodyItem);
      subBody2 = GetStructureReadWrite(bodyItem.fCurrency);
      TOGGLESTATE(bodyItem.fState);  // 14/08/92
      if (bodyItem.fState == kShown)
        subBody2->fParent = currency;
      if (bodyItem.fAffected)   // 18/04/91 out again || !fDeletions)  // 05/03/91 2nd test
        subBody2->ToggleState(bodyItem.fCurrency, NULL, NULL, command);
      AtPut(index, &bodyItem);
    }
  }
  if (fKind == kDocument || fKind == kHeader || fKind == kFooter)
// 18/02/94 [21409] will call LinkSelection twice & unlink the 2nd time - See clear
// and moved out by 1 block level
// 18/02/94 #ifdef FN
// 18/02/94         || fKind == kNoteSet
// 18/02/94 #endif
  {
    paste = command->fCmdNumber == cPaste;
#ifdef DRAGDROP
    deletions = fDeletions;  // && !paste; [21006] 02/08/93 ?????? regresses real paste!! 
                 // if paste is TRUE, it forces a LinkSelection which is wrong, if for
                 // example, an equation is pasted between 2 paragraphs or vice versa
#else
    deletions = fDeletions;
#endif
    action = command->fCmdDone;
    if (paste)
      action = !action;
    else if (splitText)
    {
      action = !action;
      deletions = TRUE;
    }
    if ((deletions && !paste) ||
                       ((!deletions || TStructureCmd(command)->fHasSplit) && paste))
                                   /* 28/09/92 fHasSplit for fCanSplit */
      LinkSelection(anchor, activeEnd, action);
  }
#ifdef FN
//    14/06/93 [20939] needs to be done after note references correctly set by Reformat
//    if (!doNotes && command->fCmdDone && fKind == kDocument) // [20863] 12/5/93
//      ShowHideNotes();
#endif
}


// ------------------------------------------------------------------------
void _TBodyStructure::Commit(TCurrency currency, TCursorNode anchor,
               TCursorNode activeEnd, TCommand command, bool freeParts)
{
  int firstIndex;
  int lastIndex;
  int index;
  TCurrency subCurrency1;
  TCurrency subCurrency2;
  TCurrency link;
  TStructure subBody;
  TStructure subBody1;
  TStructure subBody2;
  TCursorNode nextAnchor;
  TCursorNode nextActive;
  TCursorNode nextNode;
  TBodyItem bodyItem;
#ifdef FN
//  bool doNotes = FALSE;
#endif

  if (_GetSize() == 0)
    return;            // 28/09/93 [21055] nothing to do after paste failure calls Commit

  subBody1 = NULL;
  subBody2 = NULL;
  link  = 0;
  Join(currency);
  if (anchor == NULL)
  {
    firstIndex = 1;
    subCurrency1 = GetBodyItem(1);
    nextAnchor = NULL;
  }
  else
  {
    nextAnchor = anchor->GetNext();
    subCurrency1 = TBodyCursor(anchor)->GetBodyItem();
#ifdef FN
    if (subCurrency1 == GetNoteCollector())
      firstIndex = -1;      // doNotes = TRUE;
    else
#endif
      firstIndex = FindBodyItem(subCurrency1);
  }

  if (activeEnd == NULL)
  {
    lastIndex = _GetSize();
    subCurrency2 = GetBodyItem(lastIndex);
    nextActive = NULL;
  }
  else
  {
    subCurrency2 = TBodyCursor(activeEnd)->GetBodyItem();
    lastIndex = FindBodyItem(subCurrency2);
    nextActive = activeEnd->GetNext();
  }

#ifdef FN
  if (firstIndex < 0)         // doNotes)
  {
    subBody1 = GetStructureReadWrite(subCurrency1);
    subBody1->Commit(subCurrency1, nextAnchor, nextActive, command, freeParts);
  }
  else
#endif
  {
    if (!freeParts)         // 05/03/91 extra test
    {
      subBody1 = GetStructureReadWrite(subCurrency1);

      if (firstIndex == lastIndex)
        nextNode = nextActive;
      else
        nextNode = NULL;

    //  if (!subBody1->AllSelected(subCurrency1, nextAnchor, nextNode) &&
    //                                         subBody1->CanType())  //  15/02/91
      if (!PBodyItem(At(firstIndex))->fGone)      // 19/02/91
      {
        ResetItemState(firstIndex);
        firstIndex = firstIndex + 1;
        link = subBody1->GetLink();
        // 27/11/91 wasnt committing body contents at anchor
        subBody1->Commit(subCurrency1, nextAnchor, nextNode, command, FALSE);  
     }
// 27/11/91 moved above subBody1->Commit(subCurrency1, nextAnchor, nextNode, command, FALSE);

      if (lastIndex >= firstIndex && GetItemState(lastIndex) == kShown)
      {
        subBody2 = GetStructureReadWrite(subCurrency2);
    //    if (!subBody2->AllSelected(subCurrency2, NULL, nextActive))
        if (!PBodyItem(At(lastIndex))->fGone)      // 19/02/91
        {
          ResetItemState(lastIndex);
          lastIndex = lastIndex - 1;
        }
        subBody2->Commit(subCurrency2, NULL, nextActive, command, FALSE);
      }
    }

    for (index = lastIndex; index >= firstIndex; --index)
    {
      Get(index, &bodyItem);
      if (freeParts || bodyItem.fState == kHidden)   // 05/03/91 freeParts
      {
        Delete(index);
        if (bodyItem.fCurrency != link)
        {
          subBody = GetStructureReadWrite(bodyItem.fCurrency);
          if (subBody->fParent == currency)
          {
// 27/11/91 if (subBody != subBody1 && subBody != subBody2)  // 19/03/91 moved in condition
            if (subBody != subBody2)  // 27/11/91 wasnt committing body contents at anchor
              subBody->Commit(bodyItem.fCurrency, NULL, NULL, command, TRUE);
            fDocument->DeleteCurrency(bodyItem.fCurrency);
          }
        }
        else
          fDocument->DeleteCurrency(bodyItem.fCurrency);
        fDocument->DeleteFormatData(currency, index);
      }
      else
      {
        // 12/10/93 either new fAffected test needed or fGone should be set in more cases?
        if (bodyItem.fGone || bodyItem.fAffected)
          GetStructureReadWrite(bodyItem.fCurrency)->
                       Commit(bodyItem.fCurrency, NULL, NULL, command, FALSE);
        ResetItemState(index);
      }
    }
  }
  fLastHit = 1;
  fDeletions = FALSE;
  fCanSplit = FALSE;
}


// ------------------------------------------------------------------------
void _TBodyStructure::SwapFigure(TCaption caption)
{
  TBodyItem bodyItem1;
  TBodyItem bodyItem2;

  if ((TopLeftCaption(caption) && BotRightCaption(fCaption)) ||
     (TopLeftCaption(fCaption) && BotRightCaption(caption)))
  {
    Get(1, &bodyItem1);
    Get(2, &bodyItem2);
    AtPut(2, &bodyItem1);
    AtPut(1, &bodyItem2);
    fCaption = caption;
  }
}

// ------------------------------------------------------------------------
void _TBodyStructure::SetStyle(TCurrency currency, TCurrency style, int part,
                                                     Rect &custom, CmdNumber cmd)
{
  _TStructure::SetStyle(currency, style, part, custom, cmd);

  if (part == 1 && fKind == kFigure)
  {
    TStyleFormat theStyle = fDocument->ActiveMainView()->GetStyleReadOnly(style);
    if ((TBodyStyle(theStyle)->fDefinedInBody & kCaption) != 0)
    {
      TCaption newCaption = TBodyStyle(theStyle)->tag.fCaption;
      SwapFigure(newCaption);
    }
  }
}

// ------------------------------------------------------------------------
void _TBodyStructure::InstallStyleChange(TCurrency currency,
                   TStyleFormat theChanges, int part, Rect &custom, CmdNumber cmd)
{
  TCaption newCaption = -1;

  if (part == 1 && fKind == kFigure)
  {
    if ((TBodyStyle(theChanges)->fDefinedInBody & kCaption) != 0)
    {
      newCaption = TBodyStyle(theChanges)->tag.fCaption;
    }
    else         // 06/02/91 for delete changes case
    {
      TBodyStyle theStyle = TBodyStyle(fDocument->ActiveMainView()->GetStyleReadOnly(fStyle));
      newCaption = theStyle->tag.fCaption;
      if (newCaption <= kTopCaption)      // 23/09/94 [22028] dont lose ][ after save changes
        TBodyStyle(theStyle)->fDefinedInBody |= kHeadingChgd;
                     // really to get the ruler ] [ marks cleared
    }
  }
  _TStructure::InstallStyleChange(currency, theChanges, part, custom, cmd);

  if (newCaption >= 0)
    SwapFigure(newCaption);
}


// ------------------------------------------------------------------------
void _TBodyStructure::ToggleStyle(int part, Rect& custom, CmdNumber cmd) // 6/5/92
{
  _TStructure::ToggleStyle(part, custom, cmd); // 22/4/92
  if (part == 1 && fKind == kFigure)
  {
    TStyleFormat theStyle = fDocument->ActiveMainView()->GetStyleReadOnly(fStyle);
    if ((TBodyStyle(theStyle)->fDefinedInBody & kCaption) != 0)
    {
      TCaption newCaption = TBodyStyle(theStyle)->tag.fCaption;
      SwapFigure(newCaption);
    }
  }
}

// ------------------------------------------------------------------------
void _TBodyStructure::ToggleChanges(int part, Rect& custom, CmdNumber cmd)
{
  _TStructure::ToggleChanges(part, custom, cmd);
  if (part == 1 && fKind == kFigure)
  {
    TStyleFormat clonedStyle;
    TBodyStyle theStyle = TBodyStyle(GetStyleFormat(&clonedStyle));
    int defined;
    TCaption newCaption;

    // TStyleFormat theStyle = fDocument->ActiveMainView()->GetStyleReadOnly(fStyle);

    // theStyle = TStyleFormat(theStyle->Clone());
    // if (fChanges != 0)
    // {
    //   TStyleFormat changes = fDocument->ActiveMainView()->GetStyleReadOnly(fChanges);
    //   theStyle->ApplyOverride(changes, gNullCurrency, TRUE);
    // }
    defined = theStyle->fDefinedInBody;
    newCaption = theStyle->tag.fCaption;
    FreeIfObject(clonedStyle);
    if ((defined & kCaption) != 0)
      SwapFigure(newCaption);
    // if ((TBodyStyle(theStyle)->fDefinedInBody & kCaption) != 0)
    // {
    //   TCaption newCaption = TBodyStyle(theStyle)->tag.fCaption;
    //   SwapFigure(newCaption);
    // }
    // FreeIfObject(theStyle);
  }
}

// ------------------------------------------------------------------------
int _TBodyStructure::GetAlienTerm(long pos, TCursorNode anchor,
                                TCursorNode activeEnd)
{
  return 1;
}


#ifdef FN
// ------------------------------------------------------------------------
// 17/05/93 [20876] - left in but done in TStructure::CopyToClipboard
TStructure _TBodyStructure::CloneForPaste(TCurrency currency, TTextDocument targetDoc)
{
  return _TStructure::CloneForPaste(currency, targetDoc);
}

// ------------------------------------------------------------------------
void _TBodyStructure::MakeNoteCollector(TCurrency currency)
{
  TDiscObject obj;
  TBodyStructure notes;

  fFootnotes = fDocument->NewCurrency(kBodyStruct, obj);
  fDocument->fFootnotes = fFootnotes;     // ensure document has Collector curr
  notes = TBodyStructure(obj);
  notes->fKind = kNoteSet;
  notes->fParent = currency; 
  notes->fStyle = fDocument->GetStyleAtLevel0(kNoteSet);
}

// ------------------------------------------------------------------------
void _TBodyStructure::AddNote(TCurrency owner, TCurrency note)
{
  TBodyItem bodyItem;

  if (fKind == kNoteSet)
  {
    int ni, nn; // 30/4/92

    bodyItem.fState = kShown;
    bodyItem.fNew = TRUE;
    bodyItem.fAffected = FALSE;
    bodyItem.fGone = FALSE;
    bodyItem.fNoteNumber = 0;
    bodyItem.spare = 0;
    bodyItem.fCurrency = note;
    Insert(&bodyItem);
    // 30/4/92 added to put a number in of correct width for formatting
    ni = FindBodyItem(note);
    if (ni == fSize || (nn = GetNoteNum(ni + 1)) == 1)
      nn = (ni == 1 ? 1: GetNoteNum(ni - 1) + 1);

    do  // 20/12/93 [21202] added to add 1 to rest for endnotes
    {
      SetNoteNum(ni, nn);
      ni++;
    }
    while (ni <= fSize && GetNoteNum(ni) == (nn++));
  }
  else if (fFootnotes != 0)
  {
    TStructure noteStruct = GetStructureReadWrite(note);
    
    noteStruct->fParent = fFootnotes;
    TBodyStructure(noteStruct)->fReference = owner;
    GetStructureReadWrite(fFootnotes)->AddNote(owner, note);
  }
  else
    _TStructure::AddNote(owner, note);
}


// ------------------------------------------------------------------------
static int GoUp1(TTextDocument doc, TCurrency *c1, TCurrency *c2)
{
  TStructure structure1;
  TStructure structure2;

  if ((*c1) == (*c2))
  {
    do
    {
       structure1 = doc->GetStructureReadOnly(*c1);
       c1--;
       c2--;
    }
    while ((*c1) == (*c2));
    return structure1->GetOrder(*c1, *c2);
  }
  
  structure1 = doc->GetStructureReadOnly(*c1);
  structure2 = doc->GetStructureReadOnly(*c2);
  if (structure1->fParent != 0)
  {
    c1++;
    (*c1) = structure1->fParent;
  }
  if (structure2->fParent != 0)
  {
    c2++;
    (*c2) = structure2->fParent;
  }
  return GoUp1(doc, c1, c2);
}

// ------------------------------------------------------------------------
int _TBodyStructure::Compare(Ptr item1, Ptr item2)
{
  int pos;
  TCurrency c1[40];
  TCurrency c2[40];

  c1[0] = PBodyItem(item1)->fCurrency;
  c1[1] = TBodyStructure(GetStructureReadOnly(PBodyItem(item1)->fCurrency))->fReference;
  c2[0] = PBodyItem(item2)->fCurrency;
  c2[1] = TBodyStructure(GetStructureReadOnly(PBodyItem(item2)->fCurrency))->fReference;
  pos = GoUp1(fDocument, c1 + 1, c2 + 1);
  if (pos < 0)
    return kALessThanB;
  if (pos > 0)
    return kAGreaterThanB;
#ifdef TRACE
  Assert(0, 299);
#endif
  return kAEqualB;          // 25/03/92 missing
}

// ------------------------------------------------------------------------
int _TBodyStructure::GetOrder(TCurrency c1, TCurrency c2)
// 22/4/92 replaces GetNoteIndex
{
  return FindBodyItem(c1) - FindBodyItem(c2);
}

// ------------------------------------------------------------------------
TNumberStyle _TBodyStructure::GetNoteNumber(TCurrency currency, TCurrency note, char *number)
{
  if (fKind == kNoteSet)
  {
    TBodyFormat bodyFormat = 
      TBodyFormat(fDocument->ActiveMainView()->GetFormatReadOnly(currency));
    int n = GetNoteNum(FindBodyItem(note));

    if (bodyFormat->fNumberStyle == kNumeric && !bodyFormat->fEndNotes)
      n = n + fDocument->fFirstFootnote;
    return ConvertNumber(bodyFormat->fNumberStyle, n, number);
  }
  if (fFootnotes != 0)
    return GetStructureReadOnly(fFootnotes)->GetNoteNumber(fFootnotes, note, number);
  return _TStructure::GetNoteNumber(currency, note, number);
}

// ------------------------------------------------------------------------
void _TBodyStructure::SetNoteNum(int itemNum, int noteNum)
{
  PBodyItem(At(itemNum))->fNoteNumber = noteNum;
}

// ------------------------------------------------------------------------
int _TBodyStructure::GetNoteNum(int itemNum)
{
  return PBodyItem(At(itemNum))->fNoteNumber;
}

// ------------------------------------------------------------------------
void _TBodyStructure::ShowNote(TCurrency currency, bool state)
{
  if (fKind == kNoteSet)
    Show(currency, state);
  else if (fFootnotes != 0)
    GetStructureReadWrite(fFootnotes)->ShowNote(currency, state);
  else
    _TStructure::ShowNote(currency, state);
}

// ------------------------------------------------------------------------
void _TBodyStructure::DeleteNote(TCurrency currency, TCurrency note, TCommand command)
{
  if (fKind == kNoteSet)
  {
    int index = FindBodyItem(note);
    
    if (index > 0) // 22/4/92
    {
      GetStructureReadWrite(note)->Commit(note, NULL, NULL, command, TRUE);
                          // 22/12/92 delete the paragraphs in the note too
      Delete(index);
      fDocument->DeleteCurrency(note);
      fDocument->DeleteFormatData(currency, index);
    }
  }
  else if (fFootnotes != 0)
    GetStructureReadWrite(fFootnotes)->DeleteNote(fFootnotes, note, command);
  else
    _TStructure::DeleteNote(currency, note, command);
}

// ------------------------------------------------------------------------
// [20863] 12/5/93 new method
void _TBodyStructure::ShowHideNotes(void)
{
  if (fFootnotes != 0)       // 16/06/93 [20939] for clip documents
  {
    TBodyStructure nc = TBodyStructure(GetStructureReadWrite(fFootnotes));
  
    for (int i = 1; i <= nc->GetSize(); i++)
    {
      PBodyItem bi;
      TCurrency ref;

      bi = PBodyItem(nc->At(i));
      ref = TBodyStructure(GetStructureReadOnly(bi->fCurrency))->fReference;
      bi->fState = GetStructureReadOnly(ref)->IsShown(ref, bi->fCurrency);
    }
  }
}

// ------------------------------------------------------------------------
TCurrency _TBodyStructure::GetNoteCollector(void)
{
  if (fFootnotes != 0)
    return fFootnotes;
  return _TStructure::GetNoteCollector();
}

// ------------------------------------------------------------------------
TCurrency _TBodyStructure::GetLastNote(void)
{
  if (fFootnotes != 0)
  {
    TStructure bs = GetStructureReadOnly(fFootnotes);

    return (bs->fSize == 0 ? gNullCurrency : PBodyItem(bs->At(bs->fSize))->fCurrency);
                         // 19/05/92 test for empty & return gNullCurrency
  }
  return _TStructure::GetLastNote();  
}

// ------------------------------------------------------------------------
void _TBodyStructure::ProtoInit(TCurrency currency)
{
  if (fKind == kFootnote)
    fReference = currency;
  else if (fKind == kDocument)
    MakeNoteCollector(currency);
}

// ------------------------------------------------------------------------
//void _TBodyStructure::FindNoteReference(TCurrency currency, TCursorNode &node)
//{
//  if (fFootnotes != 0)
//    _TStructure::FindNoteReference(currency, node);
//  else
//  {
//    node->fCurrency = fReference;
//    GetStructureReadOnly(fReference)->FindNoteReference(currency, node);
//  }
//}

// ------------------------------------------------------------------------
TCurrency _TBodyStructure::GetNoteReference()
{
  return fReference;
}

// ------------------------------------------------------------------------
bool _TBodyStructure::IsNoteCollector(void)
{
// 07/05/94 as all uses are of the form: IsNoteCollector || (fKind == kDocument), combine
// the test, which results in:

  return (fKind == kDocument || (fKind == kChapter && 
            TBodyStructure(GetStructureReadOnly(fParent))->fChapEndNotes));

//  return (fKind == kDocument && !fChapEndNotes) ||
//         (fKind == kChapter && 
//            TBodyStructure(GetStructureReadOnly(fParent))->fChapEndNotes);
}

// ------------------------------------------------------------------------
TCurrency _TBodyStructure::GetNoteContainer(TCurrency currency)
{
  if (fKind == kFootnote)
    return DoGetNoteContainer(fReference);
       // GetStructureReadOnly(fReference)->GetNoteContainer(fReference);
  if (IsNoteCollector())          // || fKind == kDocument)
    return currency;
  return _TStructure::GetNoteContainer(currency);
}

// ------------------------------------------------------------------------
// 29/4/92 new to find refernces to notes 9 and 99
void _TBodyStructure::GetReferenceTo9and99(TCurrency note,
        TCurrency &ref9, TCurrency &ref99)
{
  int item = FindBodyItem(note) + 1;
  int n = 0;

  ref9 = 0;
  ref99 = 0;
  while (item <= fSize)
  {
    int n1 = GetNoteNum(item);
    
    if (n1 == 9)
    {
      SetNoteNum(item, 10);
      ref9 = TBodyStructure(GetStructureReadOnly(GetBodyItem(item)))->fReference;
    }
    else if (n1 == 99)
    {
      SetNoteNum(item, 100);
      ref99 = TBodyStructure(GetStructureReadOnly(GetBodyItem(item)))->fReference;
    }
    else if (n1 < n)
      break;
    n = n1;
    item++;
  }
}

#else
// ------------------------------------------------------------------------
void _TBodyStructure::ClearNoteCollector()
// 10/05/95 [25012] clear fFootnotes in clip doc
{
  fFootnotes = 0;
}
#endif

// +++++++++++++++++++++++++ Start Of Format ++++++++++++++++++++++
// Copyright © 1989  icon Technology Limited. All rights reserved.

// ------------------------------------------------------------------------
_TBodyBreak::_TBodyBreak(int itemSize) : (itemSize)
{
#ifndef ZERO_OBJ
   fDepth = 0;
   fHeadingBreak = NULL;
#endif
//   fAlign = -2; // 29/05/90
}

// ------------------------------------------------------------------------
// made non-method so can be used to tidy the on-stack TColumnBreak in Fit rescue
static void FreeBodyBreak(TObject ignore, PColumnBreak colBreak)
{
  FreeIfObject(colBreak->fBreak);
#ifdef FN
  if (colBreak->fNoteBreakIn != colBreak->fNoteBreakOut)
    FreeIfObject(colBreak->fNoteBreakOut);
  FreeIfObject(colBreak->fNoteBreakIn);
#endif
}

// ------------------------------------------------------------------------
void _TBodyBreak::Free()
{
  FreeIfObject(fHeadingBreak);
  Each(this, (DoToItem)FreeBodyBreak);
  _TArray::Free();
}

/* ------------------------------------------------------------------------
int _TBodyBreak::GetDepth()
{
  return fDepth;
}
*/

#ifdef NEVER
#ifdef FN
// ------------------------------------------------------------------------
TObject _TBodyBreak::ShallowClone()
{
  FailInfo fi;
  TObject hb = NULL;
  int index;
  volatile TBodyBreak theClone = TBodyBreak(_TArray::ShallowClone());

  // FailNIL(theClone);
  if (theClone != NULL)
  {
    if (fHeadingBreak != NULL)
      hb = fHeadingBreak->ShallowClone();

    CatchFailures(&fi);
    for (index = 1; index <= theClone->fSize; index++)
    {
      PColumnBreak cb = PColumnBreak(theClone->At(index));
      TObject sb = cb->fNoteBreakIn;

      if (cb->fBreak != NULL)
      {
        cb->fBreak = cb->fBreak->Clone();
        // FailNIL(cb->fBreak); 
      }
      if (cb->fNoteBreakIn != NULL)
      {
        cb->fNoteBreakIn = cb->fNoteBreakIn->Clone();
        // FailNIL(cb->fNoteBreakIn);
      }
      if (sb != cb->fNoteBreakOut && cb->fNoteBreakOut != NULL)
      {
        cb->fNoteBreakOut = cb->fNoteBreakOut->Clone();
        // FailNIL(cb->fNoteBreakOut);
      }
    }
    Success(&fi);

    theClone->fHeadingBreak = hb;
  }
  return theClone;

Rescue:
  for (int idx = 1; idx <= theClone->fSize; idx++)
  {
    PColumnBreak cb = PColumnBreak(theClone->At(idx));
    PColumnBreak ocb = PColumnBreak(At(idx));

    if (cb->fBreak != ocb->fBreak)
      FreeIfObject(cb->fBreak);
    if (cb->fNoteBreakIn != ocb->fNoteBreakIn)
      FreeIfObject(cb->fNoteBreakIn);
    if (cb->fNoteBreakOut != ocb->fNoteBreakOut)
      FreeIfObject(cb->fNoteBreakOut);
  }
  FreeIfObject(hb);
  FreeIfObject(theClone);
  ContinueFailure(&fi);
}
#endif
#else
// ------------------------------------------------------------------------
TObject _TBodyBreak::ShallowClone()
{
  TBodyBreak theClone = TBodyBreak(_TArray::ShallowClone());

  if (theClone != NULL)
  {
    int failed = FALSE;

    if (fHeadingBreak != NULL)
    {
      theClone->fHeadingBreak = fHeadingBreak->ShallowClone();
      if (theClone->fHeadingBreak == NULL)
        failed = TRUE;
    }

    for (int index = 1; index <= theClone->fSize; index++)
    {
      PColumnBreak cb = PColumnBreak(theClone->At(index));

      if (cb->fBreak != NULL)
      {
        cb->fBreak = cb->fBreak->ShallowClone();
        if (cb->fBreak == NULL)
          failed = TRUE;
      }
#ifdef FN
      TObject sb = cb->fNoteBreakIn;
      if (sb != NULL)
      {
        cb->fNoteBreakIn = sb->ShallowClone();
        if (cb->fNoteBreakIn == NULL)
          failed = TRUE;
      }
      if (sb != cb->fNoteBreakOut && cb->fNoteBreakOut != NULL)
      {
        cb->fNoteBreakOut = cb->fNoteBreakOut->ShallowClone();
        if (cb->fNoteBreakOut == NULL)
          failed = TRUE;
      }
#endif
    }
    if (failed)
    {
      FreeIfObject(theClone);
      theClone = NULL;
    }
  }
  return theClone;
}
#endif

// ------------------------------------------------------------------------
void _TBodyBreak::SetDepth(int colNum, int depth)
{
  fDepth = Max(fDepth, depth);
  PColumnBreak(At(colNum))->fColDepth = depth;
}


// ------------------------------------------------------------------------
static TBodyBreak NewBodyBreak()
{
  return new _TBodyBreak(sizeof(TColumnBreak));
}


// ------------------------------------------------------------------------
_TBodyFormat::_TBodyFormat(TMainView itsView) : (itsView, sizeof(TItemFormat))
{
#ifndef ZERO_OBJ
  fHDepth = 0;
  fWidth = 0;
  fEndNotes = FALSE; // fn1
  fColBreaks = NULL;
  fStyleChanged = FALSE;
  fNumCols = 0;
  fPageNumber = 0;
  fNumberStyle = kNumeric; // fn1
#endif
  fColSepRule.fPen = kOnePtPen;
  fColSepRule.fRule = kNoRule;
  fColSepRule.fShort = FALSE; // 21/07/92 adding these gives better code!
}


// ------------------------------------------------------------------------
void _TBodyFormat::Free()
{
  FreeIfObject(fColBreaks);
  _TFormat::Free();
}
// fn1 new value
#define packedFmtSize 21
// fn1 old value
#define packedFmtSize1 28 

// ------------------------------------------------------------------------
long _TBodyFormat::DoNeedDiskSpace(long dataForkBytes)
{
  return _TFormat::DoNeedDiskSpace(dataForkBytes + packedFmtSize + 
    int(sizeof(Fixed)) * (fNumCols + 1) - int(sizeof(_TBodyFormat)) + int(sizeof(_TFormat)));
}

// ------------------------------------------------------------------------
void _TBodyFormat::DoRead(int aRefNum, long remainder, int version)
// replacement for InitBodyFormat
{
#ifdef VERS0
  if (version == 0)
  {
    _TFormat::DoRead(aRefNum, remainder, version);        // the whole lot
    fColBreaks = NULL;
  }
  else
#endif
  {
    // fn1 changed for notes
    char buffer[packedFmtSize1];

    _TFormat::DoRead(aRefNum, sizeof(_TFormat), version);   // the inherited bits

    if (version == 1)
    {
      // 31/01/92 forgot to remove fColNotes & fEndNotes
      FRead(aRefNum, packedFmtSize1, buffer);
      UnpackRecord(0x15, "\x02\x02\x02\x02\x05\x07", buffer, NULL, &fHDepth);
      UnpackRecord(0x05, "\x09\x2b\x02\x02", buffer + 17, NULL, &fColSep);
    }
    else
    {
      FRead(aRefNum, packedFmtSize, buffer);
      UnpackRecord(0x555, "\x02\x02\x02\x02\x05\x0B\x09\x2b\x02\x02\x01\x03",
                 buffer, NULL, &fHDepth);
    }

#ifdef TRACE      
    Assert(fNumCols < 20, 876);  // 31/01/92
#endif
    FRead(aRefNum, (fNumCols + 1) * sizeof(Fixed), fColOffsets);

// _TBodyFormat is not overridden:  FRead(aRefNum, remainder - sizeof(_TBodyStructure), this + 1);
  }
}

// ------------------------------------------------------------------------
void _TBodyFormat::DoWrite(int aRefNum, long remainder)
{
  char buffer[packedFmtSize];

  _TFormat::DoWrite(aRefNum, sizeof(_TFormat));  // inherited bits

  PackRecord(0x555, "\x02\x02\x02\x02\x05\x0B\x09\x2b\x02\x02\x01\x03", // fn1
                                                         &fHDepth, buffer);
  FWrite(aRefNum, packedFmtSize, buffer);
  FWrite(aRefNum, (fNumCols + 1) * sizeof(Fixed), fColOffsets);

// _TBodyFormat is not overridden:  FWrite(aRefNum, remainder - sizeof(_TBodyStructure), this + 1);
}

// ------------------------------------------------------------------------
TCursorNode _TBodyFormat::InitialCursor(TCurrency currency, TCurrency child, long posn)
{
#ifdef FN
  int idx = 1;
  TBodyStructure body = TBodyStructure(GetStructureReadOnly(currency));

  if (child == 0 || (idx = body->GetSize(), child == -1))
  {

    child = body->GetBodyItem(/* child == 0 ? 1 : body->GetSize()*/ idx);
  }
#endif
  return new _TBodyCursor(currency, IDType(kNewCursor), child, gZeroVPt);
}


// ------------------------------------------------------------------------
void _TBodyFormat::GetMarginLimits(TStructure structure, int part, Rect &custom, Fixed &leftLimit, Fixed &rightLimit)
{
  // TCurrency styleCurrency;
  TBodyStyle bodyStyle;
  // TBodyStyle bodyChanges;
  TBodyStyle clonedStyle;
  int secondPart;                // 09/04/91

  bodyStyle = TBodyStyle(structure->GetStyleFormat(&clonedStyle));
  // styleCurrency = structure->fStyle;
  // bodyStyle = TBodyStyle(GetStyleReadOnly(styleCurrency));
  // styleCurrency = structure->fChanges;
  // if (styleCurrency != 0)
  // {
  //   bodyStyle = TBodyStyle(bodyStyle->Clone());
  //   bodyChanges = TBodyStyle(GetStyleReadOnly(styleCurrency));
  //   bodyStyle->ApplyOverride(bodyChanges, gNullCurrency, TRUE);
  // }

  do
  {
    int structKind = structure->GetKind();

    secondPart = 0;
    if (structKind == kFigure)
    {
      TCaption caption;

      if (part == kWholeBody && custom.top < 0)
        secondPart = kHeadingPart;        // 04/04/91 need to go round twice
      caption = TBodyStructure(structure)->fCaption;
      if (TopLeftCaption(caption) && part != kWholeBody)    // 04/04/91
        part = kBodyPart + kHeadingPart - part;      // swap kBodyPart <=> kHeadingPart
    }

    switch (part)
    {
    case kWholeBody:  // 24/07/90 - instead of 1
      leftLimit += bodyStyle->GetLeftMargin();
      rightLimit += bodyStyle->GetRightMargin();
      break;

    case kHeadingPart:  // 24/07/90 - instead of 2
      leftLimit += bodyStyle->GetHeadingLM(fWidth, gZeroVRect);
      rightLimit += bodyStyle->GetHeadingRM(fWidth, gZeroVRect);
      break;

    case kBodyPart:  // 24/07/90 - instead of 3
      leftLimit += bodyStyle->GetColumnLM(fWidth, custom.top, gZeroVRect, fFlags);
      rightLimit += bodyStyle->GetColumnRM(fWidth, custom.top, gZeroVRect, fFlags);
    }
    // 09/04/91 put into a 1 or 2 iteration loop
    part = secondPart;
  } while (secondPart > 0);

  // if (styleCurrency != 0)    // was cloned above
  //   FreeIfObject(bodyStyle);
  FreeIfObject(clonedStyle);
}


// ------------------------------------------------------------------------
TCursorNode _TBodyFormat::GetTheCursor(TView view, VPoint &mousePoint, TCurrency child)
{
// 20/02/94 child == 0 no longer passed
//  return (child == 0 ?
//    TBodyCursor(TSubView(view)->ClickOnce(mousePoint)) :
  return
    new _TBodyCursor(TSubView(view)->GetStructure(), view->fIdentifier, child, mousePoint);
}


// ------------------------------------------------------------------------
bool _TBodyFormat::GetChanged(int index)
{
  return PItemFormat(At(index))->fChanged;
}


// ------------------------------------------------------------------------
void _TBodyFormat::InstallHdgChanges(TBodyStructure body, TCurrency currency)
{
  TBodyStyle styleFormat;

  styleFormat = TBodyStyle(fMainView->GetStyleReadWrite(currency));

  if (styleFormat->fHeadingType == kSideHeading)
  {
    styleFormat->ReduceSize(0);
    // set column marks at 1/8 inch on either side of 1:3 or 3:1 split
    DoColumnsChange(styleFormat, fWidth * ((styleFormat->fDefinedInBody & kCaption) != 0 &&
                       styleFormat->tag.fCaption == kRightCaption ? 3 : 1) - (90 * 4), 180 * 4);

    // TFTabInfo tab;
    // Fixed stop;
    // bool rightCaption = ((styleFormat->fDefinedInBody & kCaption) != 0 &&
    //                          styleFormat->tag.fCaption == kRightCaption);
    // stop = ToFixed(fWidth) / 4;
    // if (rightCaption)
    //   stop *= 3;
    // stop += (90 * kFix1);
    // tab.fStop = stop;
    // tab.fOwner  = 0;
    // tab.fDeleted = FALSE;
    // tab.fKind = kLeftCol;
    // tab.fFiller[0] = 0;
    // tab.fMark = ' ';
    // styleFormat->InsertLast(&tab);
    // tab.fStop = stop - (180 * kFix1);          // 0x120000 on the mac
    // tab.fKind = kRightCol;
    // styleFormat->InsertFirst(&tab);
  }
  styleFormat->fDefinedInBody &= ~kHeadingChgd;
  styleFormat->fDefined |= kRuler;
}


// ------------------------------------------------------------------------
THFVisibility _TBodyFormat::GetHFVisibility(TCurrency currency)
// new 06/09/90
{
   TBodyStyle bodyStyle = TBodyStyle(GetCompositeStyle(currency));
   THFVisibility vis =
          (bodyStyle != NULL ? bodyStyle->GetHFVisibility() : kHFAllPages);

   FreeIfObject(bodyStyle);
   return vis;
}


// ------------------------------------------------------------------------
// fn1 params changed
// 11/5/93 added ref
TChangeTypes _TBodyFormat::FormatNote(TCurrency note, TCurrency ref, TReformatVars *v)
{
#ifdef FN
  TChangeTypes formatNote_r;
#endif

#ifdef AUTONUM
  if (note <= 2)
  {
    // special case (nothing to do with notes) to return current index in body
    // maybe could keep running value of index in v while reformatting?
    int posInBody = 0;
    int itemNum = 0;
    PBodyItem item;

    do
    {
      item = PBodyItem(v->body->_At(++itemNum));
      if (Curr_fType(item->fCurrency) == kTextStruct)  // only update the number if a para
        posInBody += item->fState;
    }
    while (item->fCurrency != ref);

    // return v->bodyStyle->fRomanPages ? -posInBody : posInBody;
    return (int)ExpandLabel(posInBody, note == 2 ? v->bodyStyle->fAutoCustom : "%1");
  }
#endif
#ifdef FN
  v->hasNotes = TRUE;
  if (v->body->IsNoteCollector())      // || v->body->fKind == kDocument)
  {
    TCurrency footnotes = v->body->GetNoteCollector();
    TTextDocument document = TTextDocument(fMainView->fDocument);
    TSelection saveSelection = document->fSelection;      // GetSelection(FALSE);
    TSelection noteSelection;
    TCursorNode noteAnchor, noteActive;
    TBodyFormat noteSetFormat;
    TBodyStructure noteSetStruct = TBodyStructure(GetStructureReadOnly(footnotes));

    // 17/12/93 removed unsafe doing this until whole reformat finished
    // (may be pasting a whole load of paras containing notes not just 1)
    // 17/12/93 bool call9etc = noteSetStruct->IsNewItem(noteSetStruct->FindBodyItem(note));
    // if (call9etc)   // 29/4/92, 16/12/93 [21148] moved down
    //   FormatNotes9and99(v->currency, note, noteSetStruct);

    noteSelection = document->InitialSelection(fMainView, note, note);  // 09/05/94 [21726]
    TBodyStructure(document->GetStructureReadWrite(note))->ProtoInit(ref); // 11/5/93
    // 09/05/94 [21726] noteSelection should be the one just created, not fNewSelection!
    // 09/05/94 fMainView->fSelection = noteSelection = document->GetNewSelection();
    // 16/05/94 [21725] copy over fields needed for Reformat
    noteSelection->fReformatType = saveSelection->fReformatType;
    noteSelection->fAppliedChgs = saveSelection->fAppliedChgs;
    noteSelection->fStyleToUpdate = saveSelection->fStyleToUpdate;
    noteSelection->fEditedStyles = saveSelection->fEditedStyles;
    fMainView->fSelection = noteSelection;
    noteSelection->GetNodes(footnotes, noteAnchor, noteActive);
    noteSetFormat = TBodyFormat(GetFormatReadOnly(footnotes)); // 22/6/92
    noteSetFormat->fEndNotes = v->bodyStyle->tag.docStyle.fEndNotes;
    noteSetFormat->fNumberStyle = (v->bodyStyle->tag.docStyle.fAutoNumber ? kNumeric: kCharSeq);
    formatNote_r = noteSetFormat->Reformat(footnotes, noteAnchor, noteActive, 
                                                    v->widthCol, -1, PStdNoteVars(v));   
    // 17/12/93 if (call9etc)    // 16/12/93 [21148] needs to be called after proper reformat
    // 17/12/93  FormatNotes9and99(v->currency, note, noteSetStruct);
    fMainView->fSelection = document->fSelection = saveSelection;   // restore saved sel
    FreeIfObject(noteSelection);                 // ... and free the temp selection created
  }
  else
    formatNote_r = CallNoteFunc(v->origProc, note, ref); // 11/5/93
  return formatNote_r;
#else
  return kNoChg;
#endif
}


// ------------------------------------------------------------------------
void _TBodyFormat::ReformatItem(int index, int width, TCursorNode anchor,
                                  TCursorNode activeEnd, TReformatVars *v)
{
  TItemFormat newItem;

  if (MemSpaceIsLow())
    TTextDocument(fMainView->fDocument)->Purge();
#ifdef FN
  if (index == 0)
  {
    TCurrency subBodyCur = v->body->GetNoteCollector();
    TFormat subBody = GetFormatReadWrite(subBodyCur);

    v->response = subBody->Reformat(subBodyCur, anchor, activeEnd, width, -1,
                                                     PStdNoteVars(v->origProc));
    fHasChanged = TRUE;
  }
  else
#endif
  {
    v->subBodyCur = v->body->GetBodyItem(index);
    UpdateProgress();

// 17/05/94 [21807] if (fMainView->fSelection->fReformatType == kReformatChgs)
// 17/05/94 [21807]   if ((Curr_fType(v->subBodyCur) == kTextStruct && !GetChanged(index)) ||
// 17/05/94 [21807]              Curr_fType(v->subBodyCur) == kPictStruct)
// 17/05/94 [21807]       return;
    // 17/05/94 [21807] need to test all types as changed (pictures will not be marked?!)
    if (fMainView->fSelection->fReformatType == kReformatChgs &&
                   Curr_fType(v->subBodyCur) != kBodyStruct && !GetChanged(index))
      return;

    if (v->body->IsNewItem(index))   // 29/01/91
    {
      newItem.fAscentOrContainer = 0;
      newItem.fDescent = 0;
      newItem.fSpBefore = 0;
      newItem.fSpAfter = 0;
      newItem.fMustFit = FALSE; // fn1
      if (index > GetSize())
        InsertLast(&newItem);
      else
        InsertBefore(index, &newItem);
      PBodyItem(v->body->_At(index))->fNew = FALSE;   // 29/01/91
    }

    if (v->body->GetItemState(index) == kShown)
    {
      v->subBody = GetFormatReadWrite(v->subBodyCur);
      SetResult(this, v->subBody, v->subBodyCur, index,
              v->subBody->Reformat(v->subBodyCur, anchor, activeEnd, width, -1,
              PStdNoteVars(v)), v);
    }
    else       // 03/02/91 else restored
    {
      PItemFormat(At(index))->fChanged = TRUE;
      SetHasChanged(TRUE);
      v->response = kHeightChg;
    }
  }
  if (MemSpaceIsLow())
    TTextDocument(fMainView->fDocument)->Purge();  // 10/06/91 added
}


// ------------------------------------------------------------------------
void _TBodyFormat::DoReformatSel(TCurrency currency, long posn, TCursorNode anchor,
                                          TCursorNode activeEnd, TReformatVars* v)
{
  int width;

  if (
#ifdef FN
      posn != 0 && // 12/11/93 [21118] new (calculated heading width when passed a footnote)
#endif
         v->headingType != kNoHeading && posn <= FirstVisibleFrom(v->body, 1))
  {
    if (v->body->GetBodyKind() <= kChapter)
      fMainView->RedrawHeaderFooter(3); // 18/06/95 redraw headers and footers

    width = v->bodyStyle->GetHeadingWidth(v->fitToWidth, v->ruleWidths);
  }
  else
    width = v->widthCol;

  ReformatItem(posn, width, anchor, activeEnd, v);
}


// ------------------------------------------------------------------------
void _TBodyFormat::DoReformatPart(TCurrency currency, long posn, TReformatVars* v)
{
  DoReformatSel(currency, posn, NULL, NULL, v);
}


// ------------------------------------------------------------------------
void _TBodyFormat::SetResult(TBodyFormat bodyFmt, TFormat subBodyFmt, TCurrency subBodyCur,
              int index, TChangeTypes result, TReformatVars *v)
{
  long asc, desc;
  int ab, bl;
  TItemFormat newItem;
  TItemFormat *item;
#ifdef FN
  TCurrency noteCollector = gNullCurrency;
#endif

  if (index > GetSize())
  {
    newItem.fAscentOrContainer = 0;
    newItem.fDescent = 0;
    newItem.fSpBefore = 0;
    newItem.fSpAfter = 0;
    newItem.fMustFit = FALSE; // fn1
    InsertLast(&newItem);
  }

  item = PItemFormat(At(index));

  asc = 0;       // 01/07/92
  v->subBody->GetDepth(asc, desc);
#ifdef FN
  if (asc < 0 && v->body->GetBodyKind() == kNoteSet)
  {
    noteCollector = GetStructureReadOnly(v->subBodyCur)->GetNoteContainer(v->subBodyCur);
    item->fAscentOrContainer = -Curr_fRecnum(noteCollector);
  }
  else
#endif
  item->fAscentOrContainer = asc;
  item->fDescent = desc;
  v->subBody->GetSpacing(ab, bl);
  item->fSpBefore = ab;
  item->fSpAfter = bl;
  if (result != kNoChg)
  {
    item->fChanged = TRUE;
    bodyFmt->SetHasChanged(TRUE);
#ifdef FN
    // 01/03/94 [21426] flag note container with changes in note area, so that all the
    // views in different chapter end notes are redraw automatically
    if (noteCollector != gNullCurrency)
    {
      TStructure theNoteCollector = GetStructureReadOnly(noteCollector);

      if (theNoteCollector->fParent != gNullCurrency)   // test it is not the document
        GetStructureReadWrite(theNoteCollector->fParent)->
           SetChanged(theNoteCollector->fParent, noteCollector, TRUE);
    }
#endif
  }
  item->fMustFit = (item->fMustFit || v->hasNotes || (asc < 0)); // fn1
  v->hasNotes = FALSE;

  if (int(result) > int(v->response))
    v->response = result;
}

// ------------------------------------------------------------------------
TChangeTypes _TBodyFormat::Reformat(TCurrency currency, TCursorNode anchor,
           TCursorNode activeEnd, int fitToWidth, Fixed gapHalf, PStdNoteVars origProc)
{
  TReformatVars v;
  TRuleType colSepRule;
  int numCols, numCols2;
  int cn;
  Fixed colOffset;
  FailInfo fi;  // 24/07/90 - new
  bool widthChanged;
  int backwards;

  v.styleFormat = NULL;  // 24/07/90 - new
  CatchFailures(&fi);    // 24/07/90 - new

  v.vars.obj = this;          // 06/09/90 done here just the once
  v.vars.procToDo = (DoNote) _TBodyFormat::FormatNote;
  v.fitToWidth = fitToWidth;
  v.currency = currency; // 29/4/92
  v.origProc = origProc;
  widthChanged = fWidth != fitToWidth;
  fWidth = fitToWidth;
  v.body = TBodyStructure(GetStructureReadWrite(currency));

  if (!PreFormat(currency, v.part, v.custom, v.ruleWidths, v.styleFormat, v.response, gapHalf))
  {
    FreeIfObject(v.styleFormat);
    return(v.response);
  }
  v.bodyStyle = TBodyStyle(v.styleFormat);

  if ((v.bodyStyle->fDefinedInBody & kHeadingChgd) != 0)
  {
    if (v.body->fChanges != 0)
      InstallHdgChanges(v.body, v.body->fChanges);
    else
      InstallHdgChanges(v.body, v.body->fStyle);
    ReplaceObject(v.styleFormat, GetCompositeStyle(currency));
    // FreeIfObject(v.styleFormat);
    // v.styleFormat = GetCompositeStyle(currency);
    v.bodyStyle = TBodyStyle(v.styleFormat);
  }

  backwards = fFlags;

  if (v.body->fKind == kDocument)
  {
    // 08/12/94 done in TDStructu: SetSpacing(0, 0);    // 13/04/94 [21620] ignore any spacing set on document
#ifdef FN
    v.body->fAutoNumber = v.bodyStyle->tag.docStyle.fAutoNumber;
    v.body->fChapEndNotes = v.bodyStyle->tag.docStyle.fEndChapter;
#endif
  }
#ifdef FN
  else if (v.body->fKind == kChapter)
  {
    TBodyStructure bs = TBodyStructure(GetStructureReadOnly(v.body->fParent));

    v.bodyStyle->tag.docStyle.fAutoNumber = bs->fAutoNumber;
    v.bodyStyle->tag.docStyle.fEndNotes = bs->fChapEndNotes;
  }
  else if (v.body->fKind == kNoteSet && anchor != NULL && v.part == 1)
    v.part = 0;  // 16/05/94 [21725] if formatting note area - only do the 1 note in anchor
                 // not each one once per footnote reference
#endif
#ifdef AUTONUM
  else if (v.body->fKind == kList && (fMainView->fSelection->fReformatType == kSelSlow ||
                            fMainView->fSelection->fReformatType == kReformatPaste ||
                            fMainView->fSelection->fReformatType == kReformatLine))
                                        // && autonumbered (TBS!!!)
    activeEnd = NULL;                 // reformat all the way to end of numbered list
#endif

  v.widthCol = v.bodyStyle->GetColumnWidth(fitToWidth, v.ruleWidths, backwards);
  v.headingType = v.bodyStyle->GetHeadingType();
  v.body->fHeadingType = v.headingType; // 03/05/90 - new
  v.hasNotes = FALSE;
  gFormatting++; // 11/04/91 - new

  if (v.part > 0 || widthChanged)
  {
    // in-line ReformatRules
    colSepRule = v.bodyStyle->GetColSepRule();  // 29/05/90 - this block is all new
    fColSepRule = colSepRule;
    fStyleChanged = TRUE;
    if (colSepRule.fRule == kNoRule)
      fNumCols = 0;
    else
    {
      numCols = v.bodyStyle->GetTotalColumns() + int(v.headingType == kSideHeading) - 1;
      fNumCols = numCols;
      fColSep = v.bodyStyle->GetGutterWidth();
      if (v.headingType != kSideHeading)
      {
        fSideSep = 0;
        cn = 1;
      }
      else
      {
        colOffset = v.bodyStyle->GetSideSep();
        fSideSep = colOffset;
        cn = 0;
      }

      numCols2 = numCols;
      for (numCols = 1; numCols <= numCols2; numCols++)
      {
        colOffset =
             v.bodyStyle->GetColumnLM(fitToWidth, numCols + cn, v.ruleWidths, backwards);
        if ((cn == 1) || (numCols > 1))
          fColOffsets[numCols] = colOffset - fColSep;
        else
          fColOffsets[numCols] = colOffset - fSideSep;
      }
    }
  // end ReformatRules
  }

  if (v.part == 0)
  {
    v.splitCursor = 0;
    if (anchor != 0)
    {
      v.splitCursor = TBodyCursor(anchor)->GetSplitCursor();
      if (v.splitCursor != 0)
      {
        v.saveAnchor = anchor;
        anchor = v.splitCursor;
      }
    }

    v.body->Iterate(currency, anchor, activeEnd, TRUE, this, (DoStep)_TBodyFormat::DoReformatSel, &v);
    if (v.splitCursor != 0)
      TBodyCursor(v.saveAnchor)->FreeSplitCursor();
  }
  else if (v.part > 0)
  {
    v.body->IteratePart(currency, v.part, v.custom, NULL, gNullCurrency,
               NULL, this, (DoPartStep)_TBodyFormat::DoReformatPart, &v);
    if (v.part == 1)
      v.response = kHeightChg;
  }

  Success(&fi);  // 24/07/90 - NEW
  gFormatting--;  // 11/04/91
  FreeIfObject(v.styleFormat);
  // 29/01/91 new in-line IncrementDepth
  {
    int depth = 0;

    for (int index = 1; index <= fSize; index++)
    {
      PItemFormat format = PItemFormat(At(index));

      if (index <= v.body->_GetSize() && v.body->GetItemState(index) == kShown)
                                             // 27/09/93 [21046] check index in range
                                             // for too many fn body formats
      {
        depth += format->fSpBefore + format->fDescent + format->fSpAfter;
        if (!format->fMustFit)
        {
          depth += format->fAscentOrContainer;
#ifdef TRACE
          Assert(v.body->fKind != kNoteSet, 832); // make sure not adding in a currency
#endif
        }
      }
      else
      {
        format->fDescent = 0;
#ifdef FN
        // 17/11/93 [21125] Endnotes use fAscent as something completely different! 
        if (v.body->fKind != kNoteSet)
#endif
          format->fAscentOrContainer = 0;
      }
    }
    if (depth != fDescent)
    {
      fDescent = depth;
      v.response = kHeightChg;
    }
  }
  // in-line IncrementDepth
#ifdef FN
  if (v.body->fKind == kDocument)
    v.body->ShowHideNotes();         // [20939] 14/06/93 rather than in ToggleState
  else if (v.body->fKind == kNoteSet)
  {
    // 26/09/94 can load old docs with more formats than structs - try to do a repair
    while (v.body->_GetSize() < GetSize())
      Delete(GetSize());
  }
#endif
#ifdef TRACE
  while (v.body->_GetSize() < GetSize())
  {
    // 18/09/96 after load repair can end up with more formats than structs - try to do a repair
    SysBeep(0);
    Delete(GetSize());
  }
#endif
  return(v.response);
Rescue:
  // 24/07/90 - new
  gFormatting--; // 11/04/91
  FreeIfObject(v.styleFormat);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TBodyFormat::MyNotifyHeading(TCurrency itsHeading, TStyleTypes
     itsTypes, int startPage, bool useRomanNumbers, PStdFitNoteVars lVars)
{
  // 06/09/90 new
  CallNotifyHeading(((TFitVars *)lVars)->headingProc, itsHeading, itsTypes, startPage, useRomanNumbers);
}

// ------------------------------------------------------------------------
static bool KeepSpaceBefore(TBodyStructure body, THeadingTypes headingType,
              int numCols, int index)
{
  if (headingType == kFullHeading /* 19/03/91 && index == 2*/)
  {
    int realFirst = FirstVisibleFrom(body, 1);
    int realSecond = (realFirst < body->_GetSize() ?   // 21/03/91 test
                      FirstVisibleFrom(body, realFirst + 1) : 0);

    return (index == realSecond ? numCols == 1 : FALSE);
  }

  if (headingType == kSideHeading)
    return body->GetBodyKind() == kFigure;
/*
  if (headingType == kNoHeading && index <= FirstVisibleFrom(body, 1))
    return numCols == 1;     // 18/12/92 balanced list within headingless section

  if (headingType == kColHeading && index <= FirstVisibleFrom(body, 1))
    return numCols == 1;
*/
  if ((headingType == kNoHeading || headingType == kColHeading)
                                              && index <= FirstVisibleFrom(body, 1))
    return numCols == 1;
#ifdef FN
  return body->fKind == kNoteSet;
#else
  return FALSE;
#endif
}


// ------------------------------------------------------------------------
bool _TBodyFormat::FitItem(TColumnBreak &currBreak, int &colDepth,
                       int &itemDepth, int &whiteSpace, bool keepSpBefore,
                       bool &noneFits, TFitVars *v)
{
  TItemFormat itemFormat;
  TCurrency bodyCurrency;
  TFormat subBody;
  TObject nextBreak;
  int depth;
  int childMaxAvailable = v->childMaxAvailable;    // 01/10/93

  noneFits = FALSE;
// 29/05/90  currBreak.fBreak = NULL;
  Get(currBreak.fIndex, &itemFormat);

#ifdef FN
  if (fEndNotes)
  {
    v->pageOverflow = TRUE;
    if (-itemFormat.fAscentOrContainer != Curr_fRecnum(gNoteContainer))
    {
      if (Curr_fRecnum(gNoteContainer) != 1)
      {
//        FitItem_r = FALSE;
        noneFits = TRUE;
        currBreak.fIndex--;
        v->pageOverflow = FALSE;
      }
      return v->pageOverflow;    // FitItem_r
    }
  }
#endif

  // 25/02/94 moved down depth = itemFormat.fAscentOrContainer + itemFormat.fDescent - 
  //                          (v->useBreakObject ? currBreak.fDepth : 0);
  if (v->body->GetItemState(currBreak.fIndex) == kHidden)  // 29/01/91
    return -1;              // 16/02/93 [20702] TRUE;  // (FitItem_r);

//  if (depth <= 0)  // 04/02/93 if let through, thinks none fits
//    return TRUE;

  if (keepSpBefore)
  {
    int spaceB = itemFormat.fSpBefore * (v->firstPass ? v->numCols : 1);  // 18/12/92

    if (colDepth == childMaxAvailable)
      childMaxAvailable = childMaxAvailable - spaceB;
          // 01/10/93 we are forcing space before, so reduce maximum that will be available
    colDepth = colDepth - spaceB;    // itemFormat.fSpBefore;
    whiteSpace = whiteSpace + spaceB;   // itemFormat.fSpBefore;
  }

#ifdef FN
  if (v->bodyKind == kNoteSet && currBreak.fBreak == NULL) // fn2
  {
    currBreak.fNextNoteNum++;
    v->body->SetNoteNum(currBreak.fIndex, currBreak.fNextNoteNum);
  }
#endif

  // pass 0 to first Fit on page to implement 'Start on new page', then set to 1
  v->splitLeaf = v->itemFitted;                // 06/06/93 [20918]
  v->itemFitted = 1;                           // 06/06/93 [20918]

  if (itemFormat.fMustFit || v->useBreakObject || 
              (depth = itemFormat.fAscentOrContainer + itemFormat.fDescent) > colDepth)
              // 25/02/94 depth assignment moved down, and because v->useBreakObject must
              // be false,  - (v->useBreakObject ? currBreak.fDepth : 0) is not needed
              // itemFormat.fMustFit ensures fAscentOrContainer is an ascent
  {
    int saveDepth = colDepth;
    int gaps = 0;   // 21/12/93 [21204] was uninitialised
#ifdef FN
// 22/4/92
    int thisNoteSpace = 0;  // 21/05/93 [20890]
    bool dummy;
    int oldSize;
#endif

    bodyCurrency = (v->body)->GetBodyItem(currBreak.fIndex);
    subBody = GetFormatReadOnly(bodyCurrency);
    nextBreak = currBreak.fBreak;
// 08/02/91    currBreak.fDepth = colDepth;

#ifdef FN
    oldSize = gBreakStack->fSize;
    if (Curr_fType(bodyCurrency) == kBodyStruct)
      FitNote(gNullCurrency, dummy, thisNoteSpace, v);
    //dummy = (Curr_fType(bodyCurrency) == kBodyStruct &&
    //            FitNote(gNullCurrency, dummy, thisNoteSpace, v));
    // [20871] 13/5/93  next 8 lines for: thisNoteSpace = abs(Min(v->myNoteSpaceUsed, 0));
    if (v->firstPass || v->bodyKind == kDocument)
    {
      thisNoteSpace = v->noteSpaceUsed;  // 21/05/93 [20890] = 0;
    }
    else
    {
      thisNoteSpace = Min(v->myNoteSpaceUsed, -1);
      if (!v->lastCol)
        thisNoteSpace = abs(thisNoteSpace);
    }
    noneFits = !subBody->Fit(v->pageNumber, bodyCurrency, colDepth, thisNoteSpace,    
      /* v-> 01/10/93 */
      childMaxAvailable, nextBreak, gaps, v->splitLeaf,      // [20914] childMA
      PStdFitNoteVars(v), PStdFitNoteVars(v));
    CollapseBreakStack(oldSize);
#else
    noneFits = !subBody->Fit(v->pageNumber, bodyCurrency, colDepth, v->myNoteSpaceUsed,
      /* v-> 01/10/93 */
      childMaxAvailable, nextBreak, gaps, v->splitLeaf,      // [20914] childMA
      PStdFitNoteVars(v), PStdFitNoteVars(v));
       // 09/05/92 last 6 same as FN call above?
#endif
    // 01/06/93 moved down after new test v->useBreakObject = FALSE; // 24/07/90 - new
    if (colDepth == MAXLONGINT)           // 26/05/93 LONG: means Forced page break
    {
      v->pageBreakFound = TRUE;
      colDepth = 0;
    }
    if ((noneFits && colDepth != 0) || saveDepth == 0)
      // 19/11/92 colDepth != 0; noneFits means not all fitted; colDepth == 0 some fitted
      // 16/12/92 unfortunately Fit above may pass in colDepth == 0, and that gets returned!
    {
      if (currBreak.fBreak == NULL)
                        // 01/06/93 new test since currBreak.fIndex == 0 means finished
      {
#ifdef FN
        if (v->bodyKind == kNoteSet) // fn2
          currBreak.fNextNoteNum--;
#endif
        currBreak.fIndex--;               // 07/11/90
      }
      colDepth = saveDepth + whiteSpace; // fn1
      // 27/11/91 added 4 lines for fig caption on left prob
      if (nextBreak != TObject(-1))
      {
        ClearObject(nextBreak);
        // FreeIfObject(nextBreak);
        // nextBreak = NULL;
      }
#ifdef TRACE
      if (!noneFits)
        SysBeep(0);
#endif
      noneFits = TRUE;    // 02/07/93 F after page filler
    }
    else
    {
      noneFits = FALSE;    // 19/11/92 - for test below
      currBreak.fDepth = saveDepth - colDepth;
#ifdef FN
      if (saveDepth == colDepth)   // 01/06/93 only notes fitted, so do not reduce colDepth
      {
        itemFormat.fSpBefore = 0;
        itemFormat.fSpAfter = 0;
      }
      currBreak.fDepth -= thisNoteSpace;
      v->myNoteSpaceUsed += thisNoteSpace;
#endif
      currBreak.fGapCount += gaps;
    }
    v->useBreakObject = FALSE;           // 01/06/93 moved down after new test
    currBreak.fBreak = nextBreak; // 27/11/91 moved from above: fig caption on left prob
    if (nextBreak != NULL || noneFits || v->pageBreakFound)
             // 24/07/90 - added nonefits case; 21/11/90 added pageBr case
    {
      whiteSpace = 0;
      itemDepth = itemFormat.fSpBefore + currBreak.fDepth;       // 21/02/91
      return FALSE;
    }
  }
  else
  {
#ifdef FN
    v->splitLeaf = FALSE;
#endif
    currBreak.fBreak = NULL;  // 29/05/90
    currBreak.fDepth = depth; // 24/07/90 - new
    currBreak.fGapCount++;    // 16/06/91
    colDepth = colDepth - depth;
  }
  itemDepth = itemFormat.fSpBefore + currBreak.fDepth + itemFormat.fSpAfter;
  colDepth = colDepth - itemFormat.fSpAfter;
  whiteSpace = itemFormat.fSpAfter;
  return TRUE;
}

// ------------------------------------------------------------------------
bool _TBodyFormat::FitNote(TCurrency note, bool &allFits, int &noteSpaceAvailable, TFitVars* v)
{
#ifdef FN
  bool fitNote_r = TRUE; // 22/4/92
  TNoteBreak noteInfo; // 22/4/92

  if (v->body->IsNoteCollector())     // || v->bodyKind == kDocument)
  {
    // 22/4/92 added 2 conditions to deal with the gBreakStack
    if (note == 0)
    {
      noteInfo.nextNoteNum = 0;
      if (v->currBreak.fNoteBreakIn != NULL)
        noteInfo.noteBreakIn = v->currBreak.fNoteBreakIn->ShallowClone();
      else
        noteInfo.noteBreakIn = NULL;
      if (v->currBreak.fNoteBreakOut != NULL)
        if (v->currBreak.fNoteBreakIn != v->currBreak.fNoteBreakOut)
          noteInfo.noteBreakOut = v->currBreak.fNoteBreakOut->ShallowClone();
        else
          noteInfo.noteBreakOut = noteInfo.noteBreakIn;
      else
        noteInfo.noteBreakOut = NULL;
      noteInfo.first = v->firstNote;
      gBreakStack->InsertLast(&noteInfo);
    }
    else if (note == -1)
    {
      gBreakStack->GetLast(&noteInfo);
      gBreakStack->Delete(gBreakStack->fSize);
      if (v->currBreak.fNoteBreakIn != v->currBreak.fNoteBreakOut)
        FreeIfObject(v->currBreak.fNoteBreakIn);
      v->currBreak.fNoteBreakIn = noteInfo.noteBreakIn;
      FreeIfObject(v->currBreak.fNoteBreakOut);
      v->currBreak.fNoteBreakOut = noteInfo.noteBreakOut;
      v->firstNote = noteInfo.first;
    }
    else
    {
      TCurrency footnotes = v->body->GetNoteCollector();
      TBodyFormat noteSet = 
        TBodyFormat(GetFormatReadOnly(footnotes));

      if (noteSet->fEndNotes)
      {
        allFits = TRUE;
        v->endNotes = TRUE; // 22/4/92
        fitNote_r = TRUE;
      }
      else
      {
        int saveSpaceAvailable = noteSpaceAvailable;
        TObject noteBreak = v->currBreak.fNoteBreakOut;
        int dummy = 0;       // 21/05/93 [20890]
        int gaps = !v->firstNote; // 21/12/93 [21204] pass in to indicate rule space ignored
        bool fitLeaf = 0;          // 06/06/93 [20918]

        if (!gaps)    // v->firstNote)
        {
          if (noteSpaceAvailable <= noteSet->fSpBefore)
          {
            allFits = FALSE;
            return FALSE;
          }
          noteSpaceAvailable -= noteSet->fSpBefore;
        }
        if (!gaps /*v->firstNote*/ && noteBreak != NULL && noteSet->fNumberStyle == kCharSeq)
        {
          TBodyBreak nb = TBodyBreak(noteBreak);
          PColumnBreak(nb->At(nb->fSize))->fNextNoteNum = 0;
        }
        v->firstNote = FALSE;
        if (noteSet->Fit(v->pageNumber, footnotes, noteSpaceAvailable, dummy,
                       v->childMaxAvailable - saveSpaceAvailable + noteSpaceAvailable,
                           // 06/06/93 [20914] childMA
                           // 10/12/92 rather than: noteSpaceAvailable,
                       noteBreak, gaps, fitLeaf,
                       PStdFitNoteVars(v), PStdFitNoteVars(v)))
        {
          if (v->currBreak.fNoteBreakOut != v->currBreak.fNoteBreakIn)
            FreeIfObject(v->currBreak.fNoteBreakOut);
          v->currBreak.fNoteBreakOut = noteBreak;
          allFits = !fitLeaf;
          fitNote_r = TRUE;
        }
        else
        {
#ifdef TRACE
          if (noteSpaceAvailable == 0)             // beep if any fitted
            SysBeep(0);
#endif
//        if (noteSpaceAvailable == 0)             // 10/12/92 some fitted ???
//          v->currBreak.fNoteBreakOut = noteBreak;
//        else
          noteSpaceAvailable = saveSpaceAvailable;
          if (noteBreak != v->currBreak.fNoteBreakOut)  // 22/12/92 leaving handles
            FreeIfObject(noteBreak);
          allFits = FALSE;
          fitNote_r = FALSE;
        }
      }
    }
  }
  else
  {
    // 16/05/93 [20871] set noteSpaceAvailable to its proper value while fitting note
    // by dividing by the number of columns

    if (v->firstPass)        // && v->bodyKind != kDocument)     // ?? !v->endNotes)
    {
#ifdef TRACE
      if (v->bodyKind == kDocument || (v->endNotes && v->numCols > 1))
        SysBeep(0);
//      if (v->noteSpaceUsed != 0)
//        SysBeep(0);
//      else
#endif
      noteSpaceAvailable /= v->numCols;
               // 28/05/93 [20904] reduce to amount of note space really available
    }

    fitNote_r = CallFitNoteProc(v->fitNoteProc, note, allFits, noteSpaceAvailable);

    // 16/05/93 [20871] set noteSpaceAvailable back to value for fitting columns
    // ... i.e. original value - (space reserved for the notes)
    if (v->firstPass)
#ifdef TRACE
//      if (v->noteSpaceUsed == 0)
#endif
      noteSpaceAvailable *= v->numCols;
              // 28/05/93 [20904] multiply up what remains for space available in first pass
  }
  return fitNote_r;
#else
  return TRUE;
#endif
}

#ifdef FN
// ------------------------------------------------------------------------
void _TBodyFormat::FitEndNotes(int &spaceForNotes, TFitVars* v)
{
  if (v->body->IsNoteCollector())       // || v->bodyKind == kDocument)
  {
    TCurrency footnotes = v->body->GetNoteCollector();
    int noteSpace = 0; // 22/4/92

    if (footnotes == 0)
      return;

    // noteFmt = TBodyFormat(GetFormatReadWr(footnotes));  // 12/09/94 not RW unless EndNotes
    if (TBodyFormat(GetFormatReadOnly(footnotes))->fEndNotes)
    {
      TBodyFormat noteFmt = TBodyFormat(GetFormatReadWrite(footnotes));
      TObject noteBreak = v->currBreak.fNoteBreakIn;
      TObject madeBreak = noteBreak; // fn2
      int splitLeaf = 0;  // 06/06/93 [20918] pass in 'starting page' to Fit
      int gaps = 0;       // 21/12/93 [21204] means rules should be added in

      gNoteContainer = v->currency;
      if (noteBreak == NULL)
      {
        int index;
        bool found = FALSE;
        TBodyBreak newBreak;
        TColumnBreak breakData;

        // 23/05/93 [20892] if (spaceForNotes > noteFmt->fSpBefore)
        // 02/03/94 [21434] moved down:  spaceForNotes -= noteFmt->fSpBefore;
        // 23/05/93 [20892] else
        // 23/05/93 [20892]   return;
        
        for (index = 1; index <= noteFmt->fSize; index++)
          if (-PItemFormat(noteFmt->At(index))->fAscentOrContainer ==
                                                          Curr_fRecnum(v->currency) &&
            TBodyStructure(GetStructureReadOnly(footnotes))->GetItemState(index) == kShown)
                                      // 24/05/93 [20893], 17/11/93 [21125] fix was wrong
          {
            found = TRUE;
            break;
          }
        if (!found)                 // 23/05/93 [20892] || newBreak == NULL)
          return;
        spaceForNotes -= noteFmt->fSpBefore;  // 02/03/94 [21434] do after return
        newBreak = NewBodyBreak();
        newBreak->fNoteStart = TRUE;     // 21/12/93 [21203] tell view to add spBefore
        breakData.fIndex = index - 1;
        breakData.fBreak = NULL;
        breakData.fDepth = 0;
        breakData.fNextNoteNum = 0;
        breakData.fNoteBreakIn = NULL;
        breakData.fNoteBreakOut = NULL;
        newBreak->InsertLast(&breakData);
        noteBreak = newBreak;
        v->currBreak.fNoteBreakIn = newBreak;
      }
      if (noteFmt->Fit(v->pageNumber, footnotes, spaceForNotes, noteSpace, // 22/4/92
            v->childMaxAvailable, noteBreak,  // 06/06/93 [20914]
            gaps,                         // 21/12/93 [21204] never read: v->gapCount,
            splitLeaf,                    // 06/06/93 [20918] from: v->allFits (not used!)
            PStdFitNoteVars(v), PStdFitNoteVars(v)) )
      {
        if (noteBreak != NULL)
        {
          v->currBreak.fNoteBreakOut = noteBreak;
          v->pageOverflow = spaceForNotes == 0;
        }
        else
        {
          v->currBreak.fNoteBreakOut = noteFmt->fColBreaks;
          noteFmt->fColBreaks = NULL;
          v->pageOverflow = FALSE;
        }
      }
      else
      {
        FreeIfObject(noteBreak);
        if (madeBreak == NULL)
        {
          ClearObject(v->currBreak.fNoteBreakIn);
          // FreeIfObject(v->currBreak.fNoteBreakIn);
          // v->currBreak.fNoteBreakIn = NULL;
        }
        v->pageOverflow = TRUE;
        spaceForNotes += noteFmt->fSpBefore; 
      }
    }
  }
}
#endif

// ------------------------------------------------------------------------
static void UpdateColBreak(PColumnBreak currBreak, TFitVars *v)
// 11/09/91 new
{
  if (v->body->GetBodyKind() == kFigure &&
                       v->body->GetItemState(currBreak->fIndex) == kHidden)
    currBreak->fIndex++;
}

// ------------------------------------------------------------------------
bool _TBodyFormat::FitBody(TColumnBreak &currBreak, int &colDepth, TFitVars *v)
// 28/05/93 [20902] interface changed returns TRUE if something fitted
{
  bool somethingFitted = FALSE;  // 28/05/93
  bool noneFits = TRUE;  // 16/02/93 safety
  int itemDepth;
  bool keepSpBefore = KeepSpaceBefore(v->body, v->headingType, v->numCols,
            currBreak.fIndex);                            // 15/02/91

  if ((v->headingType == kColHeading && currBreak.fIndex == 1) ||
      (v->headingType == kFullHeading && currBreak.fIndex == 2)) // 07/06/93
  {
    int fititemResult;

    if (v->headingType == kColHeading)
    {
      UpdateColBreak(&currBreak, v);   // 11/09/91
      if (FitItem(currBreak, colDepth, itemDepth, v->whiteSpace, keepSpBefore, noneFits, v))
      {
        currBreak.fIndex ++;
        keepSpBefore = TRUE;
        somethingFitted = TRUE;  // 28/05/93 [20902]
      }
      else
      {
        if (v->spaceAvailable == v->maxAvailable)
          return FALSE;  // 28/05/93

        if (currBreak.fBreak != TObject(-1))    // 08/04/91 free in FNF case too
          FreeIfObject(currBreak.fBreak);
        currBreak.fBreak = NULL;
        FailNoFail();     // Fail(v);
      }
    }

// 16/02/93   if (currBreak.fIndex <= GetSize())
// 16/02/93   {
// 16/02/93 [20702] redundant now      UpdateColBreak(&currBreak, v);   // 11/09/91
    fititemResult = 0;   // to stop compiler warning
    // 16/02/93 [20702] return -ve value for hidden FitItem, and then ignore hidden items
    while (currBreak.fIndex <= GetSize() && (fititemResult = FitItem(currBreak,
                 colDepth, itemDepth, v->whiteSpace, keepSpBefore, noneFits, v)) < 0)
        currBreak.fIndex++;
    if (currBreak.fIndex <= GetSize())       // 16/02/93 moved down
    {
      if (fititemResult != 0)
      {
        currBreak.fIndex ++;
        keepSpBefore = TRUE;
        somethingFitted = TRUE;  // 28/05/93 [20902]
      }
      else
      {
        if (v->body->GetBodyKind() == kFigure && v->spaceAvailable < v->maxAvailable)
                      // 10/09/91 for fig captions over page 01/10/91 for big pictures
          FailNoFail();
        if (noneFits)
        {
          if (v->spaceAvailable == v->maxAvailable)     // 09/09/91 new test
          {
            if (currBreak.fBreak == TObject(-1))
              currBreak.fBreak = NULL;
          }
          else
          {
            if (currBreak.fBreak == NULL)
              FailNoFail();     // Fail(v);
            if (currBreak.fBreak != TObject(-1))
              FreeIfObject(currBreak.fBreak);            // 08/04/91
            currBreak.fBreak = NULL;
          }
        }
        return somethingFitted || !noneFits;
      }
    }
    else if (noneFits)
      FailNoFail();     // Fail(v);
  }

  while (currBreak.fIndex <= GetSize())
  {
#ifdef TRACE
    Assert(currBreak.fIndex <= v->body->_GetSize(), 816);
#endif
    if (v->body->GetItemState(currBreak.fIndex) != kHidden) // fn2
    {
      if (!FitItem(currBreak, colDepth, itemDepth,
                                     v->whiteSpace, keepSpBefore, noneFits, v))
      {
        if (currBreak.fBreak == TObject(-1))
        {
          currBreak.fBreak = NULL;
          v->pageBreakFound = TRUE;       // 07/06/93 [20918]
        }
#ifdef FN
        if (v->bodyKind == kNoteSet)
        {
          if (noneFits && fEndNotes && currBreak.fIndex == 0) // 26/10/92 v->pageOverflow)
            v->origSpaceAvail = 0;               // for first note does not fit
          v->splitLeaf = !noneFits; // fn2
        }
#endif
        return somethingFitted || !noneFits;  // 28/05/93 [20902]
      }
      somethingFitted = TRUE;  // 28/05/93 [20902]
#ifdef FN
      if (v->bodyKind == kNoteSet && !fEndNotes)
        return TRUE;
#endif
    }
    currBreak.fIndex++;
    keepSpBefore = TRUE;
  }
  // dropped out of loop so all fitted
#ifdef FN
  if (fEndNotes)
    v->pageOverflow = FALSE;
#endif
  currBreak.fIndex = 0;
  colDepth += v->whiteSpace;
  return TRUE;
}


// ------------------------------------------------------------------------
// SetupBreakObject is called with:
// firstCol  forBody
// TRUE      FALSE    At the start of Fit
// TRUE      FALSE    At the start when fitting first column
// FALSE     FALSE    When fitting subsequent columns
// TRUE      TRUE!    After fitting a (side or column) heading

void _TBodyFormat::SetupBreakObject(bool firstCol, TFitVars *v, bool forBody)
{
  TColumnBreak lastBreak;

  if (firstCol)
  {
    bool allFullHeading = (v->headingType != kSideHeading &&
                 TBodyBreak(v->breakInfo)->fHeadingBreak != NULL);    // 06/06/93 [20917]

#ifdef FN
    if (!forBody)      // 12/11/93 [21114] stop clearing heading breaks
    {
      v->currBreak.fNextNoteNum = 0;
      v->currBreak.fNoteBreakIn = NULL;
      v->currBreak.fNoteBreakOut = NULL;
    }
#endif
    if (v->breakObject == 0)
    {
      v->useBreakObject = FALSE;  // 24/07/90 - new
      ClearObject(v->currBreak.fBreak);
      // FreeIfObject(v->currBreak.fBreak);          // 17/08/92 leaving handle
      // v->currBreak.fBreak = NULL; // 29/05/90
      v->currBreak.fIndex = (forBody && !allFullHeading && GetSize() > 1 ? 2 : 1);
                                               // 06/06/93 [20917] 2 for sideHead
      v->currBreak.fDepth = 0;
    }
    else
    {
      if (forBody || TBodyBreak(v->breakObject)->fHeadingBreak == NULL)
      {
        TBodyBreak(v->breakObject)->GetLast(&lastBreak);
        // ReplaceObject(v->currBreak.fBreak, lastBreak.fBreak);
        if (v->currBreak.fBreak != lastBreak.fBreak)
          FreeIfObject(v->currBreak.fBreak);     // 17/08/92 leaving handle
        v->currBreak.fBreak = lastBreak.fBreak;  // 29/05/90
        v->currBreak.fDepth = lastBreak.fDepth;
        v->currBreak.fIndex = lastBreak.fIndex;
#ifdef FN
        v->currBreak.fNextNoteNum = lastBreak.fNextNoteNum;
        if (lastBreak.fNoteBreakOut != NULL)
        {
          // FailNIL(v->currBreak.fNoteBreakIn = lastBreak.fNoteBreakOut->Clone());
          lastBreak.fNoteBreakOut->MakeClone(&v->currBreak.fNoteBreakIn);
          TBodyBreak(v->currBreak.fNoteBreakIn)->fDepth = 0;  // 21/12/93 ???
        }
        v->currBreak.fNoteBreakOut = v->currBreak.fNoteBreakIn;
#endif
        if (v->currBreak.fBreak == NULL && !allFullHeading)  // 07/06/93 not if fullHeading
                                      // 07/06/93 && v->currBreak.fIndex < GetSize())  
                           // 06/06/93 [20917] moved up and test removed
        {
          // ??? if (!forBody)    // 09/06/93
            v->currBreak.fDepth = 0;                         // 21/11/90 added
          v->currBreak.fIndex++;
        }
      }
      else  // 15/05/91 new else for setting up for heading
      {
        v->currBreak.fBreak = TBodyBreak(v->breakObject)->fHeadingBreak;
        v->currBreak.fDepth = TBodyBreak(v->breakObject)->fDepth;
        v->currBreak.fIndex = 1;        
      }
      v->useBreakObject = (v->currBreak.fBreak != NULL);
// 06/06/93 I guess the && !forBody was to avoid this clause if the else above was executed
//      if (!v->useBreakObject && !forBody)     // 23/05/91 && added
//                // 08/02/91 && TBodyBreak(v->breakObject)->fAlign == -2)
//      {
//        v->currBreak.fDepth = 0;                         // 21/11/90 added
//        v->currBreak.fIndex++;
//      }
    }
  }
  else
  {
    TBodyBreak(v->breakInfo)->GetLast(&v->currBreak);

    // 07/11/90 3 new
    v->useBreakObject = (v->currBreak.fBreak != NULL);
    if (!v->useBreakObject)
      v->currBreak.fIndex++;
#ifdef FN
    if (v->currBreak.fNoteBreakOut != NULL)
    {
      // FailNIL(v->currBreak.fNoteBreakIn = v->currBreak.fNoteBreakOut->Clone());
      v->currBreak.fNoteBreakOut->MakeClone(&v->currBreak.fNoteBreakIn);
      TBodyBreak(v->currBreak.fNoteBreakIn)->fDepth = 0;  // 21/12/93 ???
    }
    v->currBreak.fNoteBreakOut = v->currBreak.fNoteBreakIn;
#endif
  }
  v->currBreak.fGapCount = -1;
}


// ------------------------------------------------------------------------
bool _TBodyFormat::FitHeading(TColumnBreak &currBreak, int &headingDepth,
                                                  int &colDepth, TFitVars *v)
{
  bool noneFits;
  int savedColDepth;
  bool atHeading = (currBreak.fIndex == 1);
#ifdef FN
  int savedmyNoteSpaceUsed;
#endif
  int lastVisible;  // 23/08/93

  headingDepth = 0;
  if (atHeading)         // 07/11/90 test added
  {
    fHDepth = 0;
    currBreak.fIndex = FirstVisibleFrom(v->body, 1);
  }

  // 06/09/90 start of new clause for page numbers
  if (/*v->bodyKind == kDocument ||*/ v->bodyKind <= kChapter)
  {
    int pageNum = 0;
    TCurrency currency;

    if (atHeading && v->currBreak.fBreak == NULL)    // 15/12/94 [23020] && only at start
    {
      // 15/12/94 [23020] avoid setting doc start page on page 2 when first thing
      // in the document overflows the first page (so atHeading is TRUE)
#ifdef TRACE
      if (v->bodyKind == kDocument)
        Assert(v->pageNumber == 1, 600);
#endif
      pageNum = fPageNumber;
      if (v->bodyKind == kDocument && pageNum <= 0)
        pageNum = 1;

      if (v->headingType != kNoHeading)
        currency = v->body->GetBodyItem(currBreak.fIndex);
      else
        currency = -1;
    }
    else
      currency = 0;

    if (v->bodyKind == kDocument)  // do 'document' call now, needs to be first on page
       CallNotifyHeading(v->headingProc, currency, kDocument, pageNum,
                                                v->bodyStyle->fRomanPages);
    else
    {
      // 15/06/95 [26014] move call of CallNotifyHeading until we are sure chapter fits!
      v->headingCurr = currency;
      v->startBodyPageNumber = pageNum;
    }
  }
  // 06/09/90 end of clause

  if (!atHeading || (v->headingType == kNoHeading || v->headingType == kColHeading))
    return FALSE;    // 06/06/93

  savedColDepth = colDepth;
  lastVisible = v->body->LastThatIsVisible();    // 23/08/93
#ifdef FN
  savedmyNoteSpaceUsed = v->myNoteSpaceUsed;
#endif
  if (FitItem(currBreak, colDepth, headingDepth, v->whiteSpace,
     v->headingType == kFullHeading || v->bodyKind == kFigure, noneFits, v))
                                 // 05/03/91 extra test for kFigure
  {
#ifdef FN
    if ((
#ifdef TEST
        v->noteSpaceUsed > 0 ||     // 10/05/94 w/o this heading with fnotes at the bottom
                                    // of col 1 of a 2-col chapter get a -ve size heading
#endif
        !v->firstPass
    ) && v->bodyKind != kDocument)  // 12/11/93 [21119] && ... ???????
    {
      headingDepth = headingDepth - savedmyNoteSpaceUsed + v->myNoteSpaceUsed;   // 19/08/93
    }
#endif
    fHDepth = headingDepth;
    if (currBreak.fIndex == lastVisible)       // 23/08/93 GetSize())
      headingDepth = -1;
    else
    {
      SetupBreakObject(TRUE, v, TRUE);

      if (currBreak.fIndex > lastVisible)
      {
        currBreak.fIndex = lastVisible;
        headingDepth = -1;
      }
      else
      {
        if (v->headingType == kSideHeading)
        {
          colDepth = savedColDepth;      
          v->minDepth = Max(v->minDepth, headingDepth);  // 20/08/93 multicol side headings
          headingDepth = 0;
        }
#ifdef FN
        else if (v->bodyKind == kDocument)
          colDepth += v->myNoteSpaceUsed - savedmyNoteSpaceUsed;
#endif
      }
    }
  }
  else
  {
    if (v->spaceAvailable == v->maxAvailable || !v->firstPass)  // 15/11/93 only fail if 1st
    {
      fHDepth = headingDepth;
      v->breakInfo->fHeadingBreak = currBreak.fBreak;   // 14/05/91
      currBreak.fBreak = NULL;                          // 07/06/93 [20922] so wont free it
      if (v->headingType == kFullHeading || currBreak.fIndex == lastVisible) // 23/08/93 GetSize())
      {
        headingDepth = -1;        // no body to fit
        // 06/06/93 [20917]       SetupBreakObject(TRUE, v, TRUE);    // 14/05/91
      }
      else
      {
        // 06/06/93 [20917]       currBreak.fIndex++;
        // 07/06/93 [20922]       currBreak.fBreak = NULL;  // 14/05/91
        headingDepth = 0;
        // 12/11/93 [20932] (redone) postpone: colDepth = savedColDepth;
      }
      SetupBreakObject(TRUE, v, TRUE);   // 06/06/93 [20917]

      // 07/06/93 new clause for side heading with more pages than body
      if (currBreak.fIndex > lastVisible)   // 23/08/93 GetSize())
      {
        // 12/11/93 [20932] do not reset coldepth here as notes and size heading overlap
        // 12/11/93 if (headingDepth == 0)
        // 12/11/93    colDepth -= fHDepth;    // 09/06/93
        currBreak.fIndex = lastVisible;      // 23/08/93 GetSize();
        headingDepth = -1;        // body already fitted
      }
      else if (headingDepth == 0)
        colDepth = savedColDepth; // 12/11/93 [20932] only reset if not returning hdDep = -1
    }
    else
    {
      if (currBreak.fBreak != TObject(-1))
        FreeIfObject(currBreak.fBreak);
      currBreak.fBreak = NULL;
      FailNoFail();    // Fail(v);
    }
  }
  return TRUE; // 06/06/93
}


// ------------------------------------------------------------------------
// fn1 new params added
bool _TBodyFormat::Fit(int pageNumber, TCurrency currency,
   int &spaceAvailable, int &noteSpaceUsed, int maxAvailable, TObject &breakObject,
   int &gapCount, bool &splitLeaf, PStdFitNoteVars headingProc, PStdFitNoteVars fitNoteProc)
{
  TFitVars v;
  FailInfo fi;
  bool fillLastPage; // fn1
  int align;              // 26/05/93
  CntlAdornment borders;  // 26/05/93
  TRuleType ruleType;     // 26/05/93
  int ruleTopBottom;      // 26/05/93
  bool Fit_r = TRUE;             // 26/05/93 [20905]
  bool addFN;

  v.vars.obj = this;
  v.vars.procToDo = (DoFitNote) _TBodyFormat::FitNote;
  v.vars.procForHeading = (DoNotifyHeading)_TBodyFormat::MyNotifyHeading;
  v.pageBreakFound = FALSE;

  v.bodyStyle = NULL;
  v.pageNumber = pageNumber;
  v.currency = currency;
  v.spaceAvailable = spaceAvailable;
  v.maxAvailable = maxAvailable;
  v.breakObject = breakObject;
  v.fitNoteProc = fitNoteProc;
  v.headingProc = headingProc;
  // 15/06/95 [26014] flag to indicate whether notify heading proc to be called
  v.headingCurr = -2;
  v.splitLeaf = splitLeaf;
  v.currBreak.fBreak = NULL;                          // 17/08/92
#ifdef FN
  v.currBreak.fNoteBreakIn = NULL;  // 12/04/94 [21619] in case fail in GetCompositeStyle
  v.currBreak.fNoteBreakOut = NULL;
  v.myNoteSpaceUsed = 0;
  v.noteSpaceUsed = noteSpaceUsed;
// 21/12/93 was only an output parameter, and now only needed in Fit  v.gapCount = gapCount;
  v.firstNote = TRUE;
  v.endNotes = FALSE; // 22/4/92
  v.lastCol = FALSE;  // 23/7/92
#endif

  v.pageOverflow = FALSE;
  v.itemFitted = splitLeaf;       // 06/06/93 [20918] on entry == 0 for first thing on page
  ClearObject(fColBreaks);
  // FreeIfObject(fColBreaks);
  // fColBreaks = NULL;
  v.body = TBodyStructure(GetStructureReadOnly(currency)); // 19/03/91 RW
  v.bodyKind = v.body->GetBodyKind();
  v.breakInfo = NewBodyBreak();
#ifdef FN
  if (v.bodyKind == kNoteSet && !fEndNotes)
    TBodyBreak(v.breakInfo)->fNoteStart = TRUE;    // 21/12/93 [21203]
#endif

  CatchFailures(&fi);

  v.bodyStyle = TBodyStyle(GetCompositeStyle(currency));
  v.numCols = v.bodyStyle->GetTotalColumns();  // 19/05/92 moved up
  v.headingType = v.bodyStyle->GetHeadingType();
  v.balanced = v.bodyStyle->GetBalanced();
  // 26/05/93 v.justify = (v.bodyStyle)->GetJustify();
  v.minDepth = Min(spaceAvailable, 480);  // 15/07/91
                    // 23/05/90 - set the min column depth (from 48 to 480)
  GetBorderInfo(v.ruleWidths, borders, ruleType);  // 26/05/93

  ruleTopBottom = (
#ifdef FN
               gapCount ? 0 :       // 21/12/93 [21204]
#endif
               FixRound(v.ruleWidths.top + v.ruleWidths.bottom));
                      // 26/05/93, 21/12/93 [21204] on input TRUE means rule space has
                      // already been deducted (the note area has Fit called on it for each
                      // note on the page, and so should only add the rules once)

  v.origSpaceAvail = spaceAvailable - ruleTopBottom; // 08/04/91, 26/05/93
  SetupBreakObject(TRUE, &v, FALSE);      // 06/06/93 moved up

  if (v.currBreak.fBreak == NULL && v.currBreak.fIndex == 1 &&  // 06/06/93 at start
     (v.bodyKind == kChapter || v.bodyKind == kSection) && v.bodyStyle->GetNewPage(align))
  {
    if (    // v.spaceAvailable < maxAvailable - fSpBefore // 09/09/92 - spBf (looped)
        v.splitLeaf != 0 ||   // 06/06/93 [20918] && not first thing on page
                          (pageNumber > 1 && v.breakObject == NULL &&
                          ((align < 0 && Odd(v.pageNumber)) ||
                           (align > 0 && !Odd(v.pageNumber)))))
    {
      breakObject = TObject(-1);
      Success(&fi);
      // spaceAvailable = MAXLONGINT; // 06/06/93 [20918]
      goto ExitFit;
      // FreeIfObject(v.breakInfo);
      // FreeIfObject(v.bodyStyle);
      // return FALSE;
    }
  }

// 20/5/92 moved from after ComputeTotalColDepth
// fillLastPage = (v.bodyKind == kDocument || v.bodyKind == kHeader || v.bodyKind == kFooter)
//         && v.numCols == 1 && spaceAvailable != MAXLONGINT;
//                    // 25/11/92 (H/F), 18/5/92, fn1, 12/08/93 [21023] not on Re-Fit H/F
  addFN = TRUE;
  {
    // previously ComputeTotalColDepth() local proc
    bool atStart1;
#ifdef FN
    bool dummy;
    int dummy1;
#define MYNOTESPACEUSED v.myNoteSpaceUsed
#else
#define MYNOTESPACEUSED 0
#endif

    v.firstPass = TRUE;
    v.whiteSpace = 0;
    // 06/06/93 moved up: SetupBreakObject(TRUE, &v, FALSE);

    // 20/08/93 for footnotes in heading - multiply moved before fitting heading
    // v.colDepth = v.spaceAvailable;
    v.colDepth = v.spaceAvailable - ruleTopBottom;    // 26/05/93
    // 04/06/93 treat borders round page like a smaller page
    v.childMaxAvailable = maxAvailable - ruleTopBottom;   // 06/06/93 [20915]
#ifdef FN
    //      v.pageOverflow = v.currBreak.fNoteBreakOut != NULL;  // 14/05/91
    if (v.bodyKind == kDocument && v.numCols > 1)
      FitNote(gNullCurrency, dummy, dummy1, &v);    // 22/4/92
#endif
    atStart1 = v.currBreak.fIndex;

#ifdef FN
// 24/10/93 [21096] need to multiply by numCols for notes in side heading too, so might as
// well do for all cases as no heading and colheading not affected by FitHeading
// 24/10/93 [21096]    if (v.headingType == kFullHeading)
//    {
//      v.colDepth *= v.numCols;
//      v.childMaxAvailable *= v.numCols;
//    }
#endif
    FitHeading(v.currBreak, v.headingDepth, v.colDepth, &v);
    v.pageOverflow = v.breakInfo->fHeadingBreak != NULL;  // 06/06/93 [20916] moved up
    if (v.headingDepth < 0)                    // 21/02/91 new clause
    {
      // there is no body left to fit
#ifdef FN
      // 20/08/93 reduce back to compensate for change in numCols
// 24/10/93 [21096] need to divide by numCols for notes in side heading too
// 24/10/93 [21096]      if (v.headingType == kFullHeading)
//      {
//        v.myNoteSpaceUsed /= v.numCols;
//        v.colDepth /= v.numCols;
//      }
#endif
      v.numCols = 1;
      v.headingDepth = fHDepth;
      v.origColDepth = v.colDepth; // 01/07/91 uninit (v.headingDepth added back at end)
      // 06/06/93 [20916] moved up: v.pageOverflow = v.breakInfo->fHeadingBreak != NULL;
#ifdef FN
      FitEndNotes(v.colDepth, &v);   // 04/06/93 [20911]
#endif
    }
    else
    {
      {
// 14/03/94 #ifdef FN
// 24/10/93 [21096] need to multiply by numCols for notes in side heading too
// 24/10/93 [21096]      if (v.headingType != kFullHeading)
//#else
        {
          v.colDepth *= v.numCols;    // 26/05/93
          v.childMaxAvailable *= v.numCols;      // 06/06/93 [20915]
        }
// 14/03/94 #endif
// 26/10/93 ?????        v.origColDepth = v.colDepth + MYNOTESPACEUSED;
                               // 18/08/93 [21028] add notespace used in centred heading
        v.origColDepth = v.colDepth;
#ifdef TEST
        if (v.noteSpaceUsed <= 0)      // 10/05/94 w/o this can end up with a side heading
                                       // with fnotes in 2 cols giving a -ve colDepth
#endif
          v.colDepth -= MYNOTESPACEUSED;

#ifdef FN
        v.noteSpaceUsed *= v.numCols;
                // 21/10/93 [21095] for fns in sections in multicolumn sections
#endif
        // 28/05/93 [20905] do not return FALSE from Fit if nothing to fit
        Fit_r = FitBody(v.currBreak, v.colDepth, &v);            // 28/05/93 , 1);
#ifdef FN
        v.noteSpaceUsed /= v.numCols;      // 21/10/93 [21095] restore
#endif

        if (v.currBreak.fIndex > 0)
        {
// 02/09/91 replaced by following:         v.pageOverflow = TRUE;
#ifdef FN
          if (v.bodyKind == kNoteSet)
          {
            if (!fEndNotes)
              v.pageOverflow = FALSE;
          }
          else
#endif
          v.pageOverflow = !v.pageBreakFound ||
                FirstVisibleFrom(v.body, v.currBreak.fIndex + 1) <= GetSize();
          // Fit_r = FALSE;
        }
        else
        {
          if (atStart1 == 1 && v.headingType == kSideHeading &&
                           v.origColDepth - v.colDepth <= fHDepth) // 20/08/93 *
          {
            v.origColDepth /= v.numCols;            // 16/16/91
            v.colDepth = v.origColDepth - fHDepth;  // 29/05/90
            v.numCols = 1;                                        // 29/05/90
            addFN = FALSE;  // 09/06/93 [20928] compensate for below
          }
          v.currBreak.fIndex = GetSize();
#ifdef FN
          FitEndNotes(v.colDepth, &v);
#endif
        }
        v.firstPass = FALSE;
      }
    }

#ifdef FN
// 18/5/92 moved from else branch above, 22/4/92
    if (v.bodyKind == kDocument && v.numCols == 1)
    {
      v.myNoteSpaceUsed = 0;
      CollapseBreakStack(0);      // 27/04/92
    }
#endif
    // end of ComputeTotalColDepth() local proc
  }

  gapCount = 1;
  // 20/5/92 moved from after ComputeTotalColDepth, 23/08/93 moved back so footnotes go at
  // the bottom of page when FitHeading returns a -ve size above, but test addFN so the
  // other case where v.numCols is set to 1 fails the test
  fillLastPage = (v.bodyKind == kDocument || v.bodyKind == kHeader || v.bodyKind == kFooter)
         && v.numCols == 1 && spaceAvailable != MAXLONGINT && addFN;
                    // 25/11/92 (H/F), 18/5/92, fn1, 12/08/93 [21023] not on Re-Fit H/F
  if (v.numCols == 1)
  {
     if (v.bodyKind != kFigure || v.headingType != kSideHeading)
       gapCount = v.currBreak.fGapCount + 1;          // 16/06/91
     v.breakInfo->InsertLast(&v.currBreak);
#ifdef FN
     if (v.bodyKind == kNoteSet && breakObject != NULL)
       v.origColDepth += TBodyBreak(breakObject)->GetDepth();
// 22/4/92 new stmts
     v.origColDepth -= v.colDepth;
     if (v.noteSpaceUsed != 0)              // 21/05/93 [20890]
     {
       if (v.noteSpaceUsed > 0)      // not last col
       {
         // 21/05/93 [20890] if on second pass of parent we do not want to grab note space
         v.noteSpaceUsed = v.myNoteSpaceUsed;
         v.myNoteSpaceUsed = 0;
       }
       else
         v.noteSpaceUsed = 0;
     }
     if (addFN && v.bodyKind != kDocument)
       v.origColDepth -= v.myNoteSpaceUsed;
     v.breakInfo->SetDepth(1, v.origColDepth);
#else
     v.breakInfo->SetDepth(1, v.origColDepth - v.colDepth);
#endif
     if (/* v.pageOverflow || 04/05/94 [21719] */ fillLastPage) // fn1
       v.breakInfo->fDepth = v.spaceAvailable - MYNOTESPACEUSED; // 20/05/93 [20888]
     else
       v.breakInfo->fDepth += ruleTopBottom + v.headingDepth;   // 12/02/91, 26/05/93
     if (v.pageBreakFound)
       v.spaceAvailable = -1;
     else
#ifdef FN
     if (fillLastPage || (v.pageOverflow && v.bodyKind == kNoteSet && fEndNotes))
       v.spaceAvailable = 0;
     else
#endif
       v.spaceAvailable = v.colDepth;
  }
  else
  {
    // previously ComputeColumnBreaks() local proc
// 27/11/91    bool overflow = FALSE; // 26/04/90 new - should not occur
    int colNum;
    int colsLeft;
    int maxDepth;
    int atStart;
    int thisDepth;
#ifdef FN
// 22/4/92
    int saveNoteSpace;
    bool dummy;
    int lastColNoteSpace;
// 18/5/92 moved from IF below, 22/4/92
    TCurrency c;

    v.myNoteSpaceUsed /= v.numCols;       // 28/05/93 [20904]
    lastColNoteSpace = v.myNoteSpaceUsed; // [20871] 18/5/93
    c = -1;
    FitNote(c, dummy, saveNoteSpace, &v);
#endif
    // 06/09/90 7 lines added
    if (/* 18/5/92 cant happen, v.numCols == 1 || */ v.balanced)
    {
      if (v.currBreak.fIndex < fSize && !v.pageBreakFound)   // 07/06/93 [20918]
        v.colDepth = 0;
      ClearObject(v.currBreak.fBreak);
      // FreeIfObject(v.currBreak.fBreak);
      // v.currBreak.fBreak = NULL;
    }
#ifdef FN
    FreeIfObject(v.currBreak.fNoteBreakOut);
// 12/11/93 done at start of SetupBreakObject:   v.currBreak.fNoteBreakOut = NULL;
#endif
    SetupBreakObject(TRUE, &v, FALSE);
    atStart = v.currBreak.fIndex;

#ifdef FN
// 22/4/92
    if (v.bodyKind != kDocument)
    {
      saveNoteSpace = v.myNoteSpaceUsed;
      // 08/06/93 ???
      v.myNoteSpaceUsed = -v.myNoteSpaceUsed;
    }
    else
    {
      saveNoteSpace = 0;
// 08/06/93 ??? stops heading with notes fitting ??
      v.myNoteSpaceUsed = 0;
    }
// 08/06/93 ???      v.myNoteSpaceUsed = -v.myNoteSpaceUsed;  // 08/06/93 ??
#endif
// 22/4/92 conditional simplified
    maxDepth = v.spaceAvailable - ruleTopBottom;        // 26/05/93
    if (v.colDepth <= 0 || !v.balanced)
    {
      v.colDepth = v.spaceAvailable - v.headingDepth - ruleTopBottom   // 26/05/93
#ifdef FN
// 22/4/92
                   - saveNoteSpace
#endif
      ;
      v.balanced = FALSE;
// 11/02/91      v.spaceAvailable = v.colDepth; // 03/05/90 - new
    }
    else
    {
#ifdef FN
      // 19/05/93 [20871] avoid o/lap with big footnote and less than 3 lines of text
      if (v.minDepth > maxDepth - saveNoteSpace)
        v.minDepth = maxDepth - saveNoteSpace;
#endif
      v.colDepth = Max(v.minDepth, (v.origColDepth - v.colDepth + v.numCols - 1) / v.numCols
#ifdef FN
// 22/4/92
                   - saveNoteSpace
#endif
      );
    }

    // v.origColDepth = v.colDepth;
    v.colDepth = Min(v.colDepth + v.headingDepth, v.spaceAvailable + MYNOTESPACEUSED);
    // 20/08/93 v.colDepth = v.colDepth + v.headingDepth;
    v.itemFitted = splitLeaf;             // 06/06/93 [20918] == 0 for first thing on page
    v.childMaxAvailable =
          (v.itemFitted == 0 ? v.colDepth :  // 08/07/93 [20925] thats all you will ever get
                 maxAvailable - ruleTopBottom);  // 06/06/93 [20915]
    v.whiteSpace = 0;
    FitHeading(v.currBreak, v.headingDepth, v.colDepth, &v);
    v.origColDepth = v.colDepth;    // 20/08/93
#ifdef FN
    if (v.bodyKind == kDocument)      // 12/11/93 fn in doc headings
    {
      v.colDepth -= v.myNoteSpaceUsed;
      //saveNoteSpace = Max(saveNoteSpace, v.myNoteSpaceUsed);
      v.myNoteSpaceUsed = 0; 
    }
#endif
    v.pageOverflow = TRUE; // 27/11/91 col break in balanced cols problem
    v.pageBreakFound = FALSE;          // 07/06/93 [20918] reset for second pass
    Fit_r = TRUE;      // 28/05/93 [20905] do not return FALSE from Fit if nothing to fit
    for (colNum = 1; colNum <= v.numCols; colNum++)
    {
      bool someFits;
      bool testSideDepth = FALSE;  // 22/10/93

      // 27/11/91 col break in balanced cols problem   overflow = TRUE;
      // fn1     if (v.currBreak.fNote != 0)
      // fn1       FitNote(v.currBreak.fNote, kColNote, v.colDepth, &v);
      someFits = FitBody(v.currBreak, v.colDepth, &v);   // 28/05/93 [20902] , colNum);

      if (v.currBreak.fIndex == 0 && someFits)  // 27/03/95 [24005] && somefits  ...
                      // to stop no-heading body which none fitted ending up down the
                      // path thinking it all fitted!
      {
        // the body fitted
        v.currBreak.fIndex = GetSize();
        // 27/11/91 col break in balanced cols problem  overflow = FALSE;
        v.pageOverflow = v.breakInfo->fHeadingBreak != NULL; // 25/10/93 [21097] FALSE;
                                   // 27/11/91 col break in balanced cols problem
#ifdef FN
        FitEndNotes(v.colDepth, &v);
        if (v.pageOverflow)
          colsLeft = v.numCols - colNum;
        else
#endif
        {
          if (atStart == 1 && v.headingType == kSideHeading)
            testSideDepth = TRUE;
// 22/10/93 in [21095] doc, need to test fHDepth after real column depth calculated below
//        if (atStart && v.headingType == kSideHeading &&
//                                             fHDepth > v.origColDepth - v.colDepth)
//          v.colDepth = v.origColDepth - fHDepth;    // 19/02/91
          colsLeft = 0; // 03/05/90 - new
        }
#ifdef TRACE
//        if (!someFits)    // 27/03/95 [24005] see above
//          SysBeep(0);  // should have fitted something if v.currBreak.fIndex == 0?
#endif
      }
      else
      {
#ifdef TRACE
        if (v.currBreak.fIndex == 0)    // 27/03/95 [24005] see above
          SysBeep(0);  // before 27/03/95, used to go into the above branch
#endif
        colsLeft = (v.pageBreakFound ? 0 : v.numCols - colNum);  // 06/09/90

        // 28/05/93 [20902] if none managed to fit after 1st col, do not set up a null break
        if (!someFits)
        {
          Fit_r = FALSE;  // 28/05/93 [20905] do not return FALSE from Fit if nothing to fit
          if (colNum > 1)
            break;
        }
      }

      v.breakInfo->InsertLast(&v.currBreak);
      thisDepth = v.origColDepth - v.colDepth;
#ifdef FN
      if (v.bodyKind == kDocument)
      {
        // 19/05/93 ??? balanced doc with fns ??        thisDepth -= v.myNoteSpaceUsed;
        saveNoteSpace = Max(saveNoteSpace, v.myNoteSpaceUsed);
        v.myNoteSpaceUsed = 0; 
      }
      else if (v.lastCol)     // [20871] 18/5/93
        thisDepth -= lastColNoteSpace + v.myNoteSpaceUsed;
                // [20899] add v.myNoteSpaceUsed, it may not have all been used on 2nd pass
#endif
      // 22/10/93 in [21095] doc, now can safely test fHDepth > column depth (thisDepth)
      if (testSideDepth && fHDepth > thisDepth)
        thisDepth = fHDepth;

      v.breakInfo->SetDepth(colNum, thisDepth);

      if (colsLeft <= 0)
        break;       // 01/06/93

      if (v.balanced)
      {
        v.colDepth = ((v.origColDepth * colsLeft) + v.colDepth + colsLeft - 1) / colsLeft;
        if (v.colDepth > v.origColDepth)
          v.colDepth = Min(v.colDepth, v.origSpaceAvail -
#ifdef FN
                            saveNoteSpace -     // 01/06/93 [20910]
#endif
                            v.headingDepth - ruleTopBottom);      // 26/05/93
        v.origColDepth = v.colDepth;
      }

      if (colNum < v.numCols)
      {
        v.colDepth = v.origColDepth;
        SetupBreakObject(FALSE, &v, FALSE);
        if (colNum == (v.numCols - 1))
        {
          v.colDepth = maxDepth - v.headingDepth
#ifdef FN
// 23/7/92, 22/4/92, 15/12/92, 13/05/93 [20871] put back, test for kDocument
               - (v.bodyKind == kDocument ? 0 : saveNoteSpace + v.myNoteSpaceUsed)
#endif
          ;
#ifdef FN
          lastColNoteSpace -= saveNoteSpace + v.myNoteSpaceUsed; // [20871] 18/5/93 
          v.lastCol = TRUE; // 23/7/92  
#endif
          v.origColDepth = v.colDepth;
          v.childMaxAvailable = maxAvailable - ruleTopBottom;    // 08/06/93 [20925]
        }
      }
    }
#ifdef FN
// 22/4/92
    if (v.bodyKind != kDocument)
      v.myNoteSpaceUsed += saveNoteSpace;
    else
    {
      //???v.breakInfo->fDepth += v.myNoteSpaceUsed;      // 09/06/93 for justified doc level
      v.myNoteSpaceUsed = 0;   // 19/05/93 [20871] messes up justification: saveNoteSpace;
    }
#endif
// 27/11/91 col break in balanced cols problem v.pageOverflow = (v.pageOverflow || overflow);
    v.breakInfo->fDepth = (
// 08/08/94 [22015] #ifdef FN
          v.bodyKind == kDocument && !v.balanced ? maxDepth :
                               // 19/05/93 [20871] balanced 17/12/92 replaces test below
// 08/08/94 [22015] #endif
         (v.pageOverflow && !v.pageBreakFound ? // 07/06/93 [20918] do not fill if page break
#ifdef FN
                (v.breakInfo->fDepth + v.headingDepth == 0 ? 0 :           // 01/06/93
#endif
                         maxDepth - MYNOTESPACEUSED       // 22/4/92
#ifdef FN
    // 28/05/93 [20903] distribute half the spare space to just above the footnotes
    // - (MYNOTESPACEUSED != 0 ? (maxDepth - MYNOTESPACEUSED - v.breakInfo->fDepth) / 2 : 0)
                                                    )
#endif
               : v.breakInfo->fDepth + v.headingDepth));
    if (v.breakInfo->fDepth > 0)
      v.breakInfo->fDepth += ruleTopBottom;  // [20908] only add rules if something there

// 22/4/92, 17/12/92 got it wrong for continuation footnotes in > 1 column
//    if (v.bodyKind == kDocument)
//      v.breakInfo->fDepth += v.myNoteSpaceUsed;

#ifdef FN
     // 25/10/93
     if (v.noteSpaceUsed != 0)              // 21/05/93 [20890]
     {
       if (v.noteSpaceUsed > 0)      // not last col
       {
         // 21/05/93 [20890] if on second pass of parent we do not want to grab note space
         v.noteSpaceUsed = v.myNoteSpaceUsed;
         v.myNoteSpaceUsed = 0;
       }
       else
         v.noteSpaceUsed = 0;
     }
#endif

    v.spaceAvailable = (v.pageBreakFound ? -1 :
        (v.pageOverflow ? 0 : v.origSpaceAvail - v.breakInfo->fDepth - MYNOTESPACEUSED));

    // end of ComputeColumnBreaks() local proc

    // 21/10/93 in same doc as [21095], enclosing view size is too big - we need to return
    // the noteSpaceUsed parameter with the same value as the numCols == 1 case. However as
    // noteSpaceUsed & myNoteSpaceUsed are not used again, the code can be simplified to:
// 25/10/93    v.noteSpaceUsed = 0;
  }

  v.breakInfo->fHDepth = fHDepth;  // 02/03/94 [21121] remember in break, format fHDepth
                                   // will get overwritten if heading goes over page break

  if (v.pageOverflow
#ifdef FN
     || (v.bodyKind == kNoteSet && !fEndNotes)
#endif
     )
    v.breakObject = v.breakInfo;
  else
  {
    v.breakObject = NULL;
    fColBreaks = v.breakInfo;
  }
  Fit_r = Fit_r || (v.spaceAvailable < v.origSpaceAvail);
           // 28/05/93 [20905] do not return FALSE from Fit if nothing (except notes) to fit
  Success(&fi);                     // 06/09/90

  if (v.headingCurr != -2)  // 15/06/95 [26014] do call only if headed chapter fitted
    CallNotifyHeading(v.headingProc, v.headingCurr, v.bodyKind,
                                         v.startBodyPageNumber, v.bodyStyle->fRomanPages);
  spaceAvailable = v.spaceAvailable;
#ifdef FN
  noteSpaceUsed = v.noteSpaceUsed + v.myNoteSpaceUsed; // fn1
//  splitLeaf = v.splitLeaf; // fn1
#endif
  splitLeaf = v.splitLeaf;
  breakObject = v.breakObject;
  FreeIfObject(v.bodyStyle);
#if defined FN && defined TRACE
  Assert(v.bodyKind != kDocument || gBreakStack->GetSize() == 0, 927);  // 12/04/94 [21619]
#endif
  return Fit_r;

Rescue:
// 12/04/94 [21619] if (fi.error != 0)
// 12/04/94 [21619]   ContinueFailure(&fi);

  breakObject = NULL;                    // 07/11/90
  spaceAvailable = v.origSpaceAvail;
ExitFit:
  // 15/02/91 removed from Fail procedure
  FreeIfObject(v.breakInfo);
  FreeIfObject(v.bodyStyle);

#ifdef FN
  if (v.bodyKind == kDocument)
    CollapseBreakStack(0);      // 12/04/94 [21619] leaving break object handles after fail
#endif

  // 12/09/94 may have copied fields of currBreak into array of callers break objects
  // so there is a double free
  //FreeBodyBreak(NULL, &v.currBreak);  // 12/04/94 [21619] also leaving break object handles

  // 12/04/94 [21619] moved down (left breakInfo & bodyStyle in heap on failmemspace)
//  if (fi.error != 0)
//    ContinueFailure(&fi);
  ContinueIfFail(&fi);
  return FALSE;
}

// ------------------------------------------------------------------------
int _TBodyFormat::BorderCompatibility()
{
  return kBodyStruct;
}

// ------------------------------------------------------------------------
CntlAdornment _TBodyFormat::MergeAdornment(TCurrency currency, CntlAdornment adornment,
                                                  TRuleType ruleType)
{
  TStructure bodyItem = GetStructureReadOnly(currency);
  TBodyStructure bodyStruct = TBodyStructure(GetStructureReadOnly(bodyItem->fParent));
  int index = bodyStruct->FindBodyItem(currency);
  int idx;

  // see what we did with the previous visible item in the body
  for (idx = index; (--idx) > 0; )
  {
    if (bodyStruct->GetItemState(idx) != kHidden)
    {
      TFormat lastFmt = GetFormatReadOnly(bodyStruct->GetBodyItem(idx));

      if (*((int *)&lastFmt->fRules) == *((int *)&ruleType) &&
                      (lastFmt->fAdorn & adnBtmHidden) != 0 &&
            GetFormatReadOnly(currency)->BorderCompatibility() == lastFmt->BorderCompatibility())
        adornment = (adornment & ~adnLineTop) | adnTopHidden;
      break;
    }
  }
  // test against next visible item in body
  for (idx = index; (++idx) <= bodyStruct->_GetSize(); )
  {
    if (bodyStruct->GetItemState(idx) != kHidden)
    {
      TCurrency nextCurrency = bodyStruct->GetBodyItem(idx);
      TFormat nextFmt = GetFormatReadOnly(nextCurrency);
      TStyleFormat theStyle = nextFmt->GetCompositeStyle(nextCurrency);
      int defined = theStyle->fDefined;

      if ((adornment & adnLineBottom) != 0 && *(defined & kHasAdornment ?
          (int *)&theStyle->fOwnRuleType : (int *)&theStyle->fRuleType) == *((int *)&ruleType) &&
            ((defined & kHasAdornment ? theStyle->fOwnAdornment : theStyle->fAdornment) &
                                                                   adnLineTop) != 0 &&
            GetFormatReadOnly(currency)->BorderCompatibility() == nextFmt->BorderCompatibility())
        adornment = (adornment & ~adnLineBottom) | adnBtmHidden;
      FreeIfObject(theStyle);
      break;
    }
  }  
  return adornment;
}

// ------------------------------------------------------------------------
int _TBodyFormat::ReAlign(TCurrency currency, int pageNumber, TObject breakObj)
{
  TFormat format;
  TColumnBreak breakInfo;
  TBodyStructure body;

  if (breakObj == NULL)           // 03/10/91
    return -1;

  TBodyBreak(breakObj)->GetLast(&breakInfo);    // 29/01/91 moved out
  
  body = TBodyStructure(GetStructureReadOnly(currency)); // 03/04/91
  if (breakInfo.fBreak == NULL)
    return (breakInfo.fIndex <= 0 ||                     // 27/03/95
            breakInfo.fIndex >= GetSize() ||             // 04/09/91 >= for ==
         GetChanged(breakInfo.fIndex) ||                 // 03/10/91
         GetChanged(breakInfo.fIndex + 1) ||
       body->GetItemState(breakInfo.fIndex + 1) == kHidden ||
       body->GetItemState(breakInfo.fIndex) == kHidden ? -1 : 0);
            // 19/03/91 from -1; 03/04/91 || test added 09/05/91 GetSize test
            // 08/07/91 fIndex test

  if (breakInfo.fIndex >= body->GetSize() || body->GetItemState(breakInfo.fIndex) == kHidden)   // 26/03/91
    return -1;     // 04/09/91 breakInfo.fIndex >= GetSize() added; 24/06/94 body-> added
#ifdef FN
  // 22/12/92 back wrap a footnote, get paginator to start on previous page
  if (breakInfo.fNoteBreakOut != NULL)
  {
    TColumnBreak noteBreakInfo;

    TBodyBreak(breakInfo.fNoteBreakOut)->GetLast(&noteBreakInfo);
    if (GetFormatReadOnly(TBodyStructure(GetStructureReadOnly(body->GetNoteCollector()))->
                GetBodyItem(noteBreakInfo.fIndex))->fHasChanged)
      return -1;
  }
#endif
  currency = body->GetBodyItem(breakInfo.fIndex);
  format = GetFormatReadOnly(currency);
  return format->ReAlign(currency, pageNumber, breakInfo.fBreak);
}


// ------------------------------------------------------------------------
void _TBodyFormat::GetDepth(long &ascent, long &descent)
{
  ascent = -1;
  descent = fDescent;
}


// ------------------------------------------------------------------------
void _TBodyFormat::SetWidth(TCurrency currency, int newWidth) // 24/07/90
{
  fWidth = newWidth;
}


// ------------------------------------------------------------------------
int _TBodyFormat::GetMinWidth()
{
  return(fWidth);
}


// ------------------------------------------------------------------------
int _TBodyFormat::GetWidth()
{
  return(fWidth);
}


// ------------------------------------------------------------------------
void _TBodyFormat::MoveCursor(TCursorNode cursor, int arrowKey,
                                                       EventInfo &info)
{
  TCurrency myCurr = cursor->fCurrency;
  TBodyStructure structure = TBodyStructure(GetStructureReadOnly(myCurr));
  TCurrency item = TBodyCursor(cursor)->GetBodyItem();
  int index = structure->FindBodyItem(item);
  VPoint mousePt;                            // save this to put back in new cursor
  VPoint *cursMouse;
  int arrowKey1 = arrowKey & 0x7f;
  bool fromEnd = ((arrowKey & 0x0f) == 0x0f /* up */ ||
                           (arrowKey & 0x0f) == 0x0c /* left */);
  bool docStartEnd = FALSE;
  TCursorNode target;
  TCursor theCursor;                           // 06/05/93 [20853]
  TCurrency itsCurr;

  // 10/02/93 [21293] compensate for moving up and down into things with diff margins
  cursMouse = &cursor->GetCursorTarget()->fMousePt;
  cursMouse->h += FixRound(ZoomFixed(fLeftMargin));
  mousePt = *cursMouse;

  if (arrowKey1 >= 0x2e)                       // Ctrl up/down: start/end of document
  {
    docStartEnd = TRUE;
    if (structure->fParent != 0)
    {
      SendToParent(cursor, arrowKey, info, structure); // 21/11/91
      return;
    }
    fromEnd = 0x2f - arrowKey1;          // TRUE for Ctrl-down
    if (fromEnd)
    {
      index = structure->_GetSize() + 1;     // scan back from end for last non hidden
//      while (structure->GetItemState(index) == kHidden) {index--;}
    }
    else                                 // Ctrl up: start of document
    {
      index = 0;     // and drop onto fromEnd test: 1;
//      while (structure->GetItemState(index) == kHidden) {index++;}
    }
  }
//  else
  if (fromEnd)             // up or left
  {
//    if (index == 1)
//    {
//        SendToParent(cursor, arrowKey, info, structure); // 21/11/91
//        return;
//    }
    do                  // 08/02/91 new loop for index--
    {
      index--;
      if (index == 0)
      {
        SendToParent(cursor, arrowKey, info, structure); // 21/11/91
        return;
      }
    } while (structure->GetItemState(index) == kHidden);
  }
  else                           // down or right
  {
//    if (index == structure->_GetSize())                   // 05/03/91
//    {
//      SendToParent(cursor, arrowKey, info, structure); // 21/11/91
//      return;
//    }
    do
    {
      index++;
      if (index > structure->_GetSize())
      {
        SendToParent(cursor, arrowKey, info, structure); // 21/11/91
        return;
      }
    } while (structure->GetItemState(index) == kHidden);
  }
  theCursor = cursor->fCursor;      // 06/05/93 [20853] cursor may be freed by ResetCursor
  structure->ResetCursor(cursor, index, fromEnd, FALSE);
  target = theCursor->GetTarget();  // 06/05/93 [20853] from : = cursor->fCursor->...

  // 10/02/93 [21293] compensate for moving up and down into bodies with diff margins
  cursor = target;
  do
  {
    itsCurr = cursor->fCurrency;
    if (Curr_fType(itsCurr) == kBodyStruct)
      mousePt.h -= FixRound(ZoomFixed(GetFormatReadOnly(itsCurr)->fLeftMargin));
    cursor = cursor->GetPrevious();
  }
  while (myCurr != itsCurr && cursor != NULL);

  target->fMousePt = mousePt;
  info.affectsMenus = TRUE;
  if (!docStartEnd)
    GetFormatReadOnly(target->fCurrency)->MoveCursor(target, arrowKey, info);
}


// ------------------------------------------------------------------------
//void _TBodyFormat::SetScaledLocation(VPoint &scaledLocation, VPoint &relLocation)
//{
//  scaledLocation = relLocation;
//  ZoomVPt(scaledLocation);
//}


// ------------------------------------------------------------------------
bool _TBodyFormat::CanHaveView(int item, TBodyStructure body)
{
  return 
#ifdef FN
    item == 0 ||
#endif
    body->GetItemState(item);
}

// ------------------------------------------------------------------------
TSubView _TBodyFormat::MakeView(
    TCurrency currency, TViewId viewId, // Fixed itsSlop, VPoint &
    Fixed itsVSlop, TView itsSuperView, TView itsNextView, VPoint &itsLocation,
    TObject startBreak, TObject endBreak)
{
//  bool ignore;

  return HandleView(TRUE, currency, viewId, /* itsSlop, */ itsVSlop, itsSuperView,
              NULL, itsNextView, itsLocation, TBodyBreak(startBreak), TBodyBreak(endBreak),
              FALSE, TRUE, NULL);        // &ignore);

}


// ------------------------------------------------------------------------
// fn1 this replaces DeleteSubViews

static void DeleteIfNotUpdated(TObject ignore, TSubView view, bool makeTheView,
                                    bool *hasEnabledSubviews)   // 11/06/93 [20934]
{
  if (view->fUpdated)
    view->fUpdated = FALSE;
  else if (!makeTheView)
  {
    view->ForceRedraw();
    FreeIfObject(view);
    // view->Free();
    return;
  }
  if (view->IsViewEnabled())          // 11/06/93 [20934]
    *hasEnabledSubviews = TRUE;
}


// ------------------------------------------------------------------------
static int GetSubView(int start, TCurrency item, TSubView &view, TSubView itsView)
{
  // 19/11/90 use CountSubViews instead of GetSize
  int subViewCount = itsView->CountSubViews();

  for (int index = start; index <= subViewCount; index++)
  {
    TSubView aView = itsView->SubViewAt(index);

    if (aView->GetStructure() == item)
    {
      view = aView;
      return index;
    }
  }
  view = NULL;
  return 0;
}
 

// ------------------------------------------------------------------------
bool _TBodyFormat::UpdateSubBody(int colNum, int index, // VPoint &
         Fixed itsVSlop, TObject startBreak, TObject endBreak, TViewVars* v, int itemDepth,
         bool *changes, bool inNotes) // fn1 added inNotes
{ // DeleteSubViews is no longer used. The fUpdated view field is now used.
  // This method has been extensively modified. The changes are not specific
  // to footnotes, but arose as a result of implementing footnotes.
  bool  UpdateSubBody_r;
  int   oldIndex; // fn1 was viewIndex2;

  UpdateSubBody_r = TRUE;
  oldIndex = v->viewIndex1; // fn1
  v->viewIndex1 = GetSubView(v->viewIndex1, v->subBody, v->itemView, v->itsView);
  if (v->viewIndex1 > 0) // fn1
  {
    if (CanHaveView(index, v->body) /* && (itemDepth > 0) */)
    {
      int svc;

      v->itemView->SetColNum(colNum);
      v->itemView->fUpdated = TRUE;
      svc = v->itsView->CountSubViews(); // 23/7/92
      v->subBodyFmt = GetFormatReadOnly(v->subBody);
      if (v->subBodyFmt->UpdateView(v->subBody, v->itemView,
              v->scaledLocation, itsVSlop, startBreak, endBreak,
                                v->invalidate, v->updateAll) && index > 0) // fn1
      {
        PItemFormat(At(index))->fChanged = TRUE;  // 04/04/91 test func
        *changes = TRUE;        //09/09/91
      }
      if (v->itsView->CountSubViews() < svc) // 23/7/92 UpdateView killed v->itemView
      {
        v->itemView = NULL;
        v->viewIndex1 = oldIndex - 1;
                      // 17/12/92 there may be a note in the way:   v->viewIndex1--;
      }
    }
    else
    {
      UpdateSubBody_r = FALSE;
      v->itemView = NULL; // 23/7/92
    }
    v->viewIndex1++;
  }
  else if (CanHaveView(index, v->body))
  {
    TViewId viewId;
    int csv;

    if (oldIndex > (csv = v->itsView->CountSubViews()) || inNotes) // fn1
    {
      // 10/12/92 ?     oldIndex = v->itsView->CountSubViews(); // fn1
      v->viewIndex1 = csv + 2; // fn1
      v->itemView = NULL;
    }
    else
    {
      v->itemView = v->itsView->SubViewAt(oldIndex); // fn1
      v->viewIndex1 = oldIndex + 1; // fn1
    }
    v->subBodyFmt = GetFormatReadOnly(v->subBody);
    viewId.fNumId = 0;
    viewId.tag.fColNum = colNum;
    v->itemView = v->subBodyFmt->MakeView(v->subBody, viewId, /* 0, */ itsVSlop,
           v->itsView, v->itemView, v->scaledLocation, startBreak, endBreak);
    if (v->itemView == NULL)
    {
      v->viewIndex1 = oldIndex;     // 10/12/92 so continuation footnote view will be found
      UpdateSubBody_r = FALSE;
    }
    else
    {
      v->itemView->ForceRedraw();
      v->itemView->fUpdated = TRUE; // fn1
    }
  }
  else
  {
    UpdateSubBody_r = FALSE;
    v->itemView = NULL; // 23/7/92
    v->viewIndex1 = oldIndex; // fn1
  }

  return(UpdateSubBody_r);
}


// ------------------------------------------------------------------------
bool _TBodyFormat::UpdateView(
             TCurrency currency, TSubView itsView, VPoint &itsLocation, // VPoint &
             Fixed itsVSlop, TObject startBreak,
             TObject endBreak, bool invalidate, bool updateAll)  // 24/07/90
{
  TViewId itsViewId;
  bool changes;

  itsViewId.fNumId = 0;
  HandleView(FALSE, currency, itsViewId, /* 0, */ itsVSlop, itsView->fSuperView, // NULL,
         TBodyView(itsView), NULL, itsLocation,
         TBodyBreak(startBreak), TBodyBreak(endBreak), invalidate, updateAll, &changes);
  return changes;
}

// ------------------------------------------------------------------------
TSubView _TBodyFormat::HandleView(
    bool makeTheView, TCurrency currency, TViewId itsViewId, // Fixed itsSlop, VPoint &
    Fixed itsVSlop, TView itsSuperView, TBodyView itsView, TView itsNextView,
    VPoint &itsLocation1, TBodyBreak startBreak, TBodyBreak endBreak, bool invalidate,
    bool updateAll, bool *changes)          // 23/05/91 combined
{
  TBodyStyle bodyStyle;
  TObject itemStart;
  TObject itemEnd;
  int spBefore;
  int spAfter;
  Rect ruleRect;
  CntlAdornment borders;
  TRuleType ruleType;
  VRect ruleWidths;
  bool atStart = (NULLorMinus1(startBreak) || startBreak->fHeadingBreak != NULL);
  int hOffsetOriginal;
  TViewVars v;
  VPoint itsLocation;   // = itsLocation1;
  FailInfo fi;

  itemStart = NULL;    // to stop compiler warning
  v.itsView = itsView;
  v.invalidate = invalidate;
  v.updateAll = updateAll;

  GetViewBorders(startBreak, endBreak, ruleRect, spBefore, spAfter);
  if (NULLorMinus1(endBreak))
    endBreak = fColBreaks;

  GetBorderInfo(ruleWidths, borders, ruleType);
  hOffsetOriginal = FixRound(GetLeftMargin() - ruleWidths.left);
  itsLocation.v = itsLocation1.v;
  itsLocation.h = itsLocation1.h + ZoomInt(hOffsetOriginal); // 03/05/90

  if (makeTheView)
    fHasChanged = FALSE;
  else
  {
    *changes = FALSE;
    itsView->Locate(itsLocation.h, itsLocation.v, invalidate);
  }
  if (updateAll)
  {
    int colMaxDepth;
    THeadingTypes headingType;
    VPoint bodySize;

    v.body = TBodyStructure(GetStructureReadOnly(currency));
    bodyStyle = TBodyStyle(GetCompositeStyle(currency));

    CatchFailures(&fi);
    headingType = bodyStyle->GetHeadingType();

    Assert(endBreak, 31);
    colMaxDepth = endBreak->GetDepth();
    bodySize.v = colMaxDepth;
    if (bodySize.v != 0)
    {
      bool balance;
      bool justify;
      bool hasEnabledSubviews;
      bool done;
      int numCols;
      int hOffset1;
      TColumnBreak colEnd;

#ifdef FN
      // 21/12/93 [21203] see if at start of Endnotes:
      // ... !atStart protects from startBreak being NULL or -1
      if (!atStart && startBreak->fNoteStart)
        spBefore = fSpBefore;
#endif
      bodySize.v += spBefore + spAfter;
      hOffset1 = FixRound(GetRightMargin() - ruleWidths.right);
      bodySize.h = fWidth - hOffsetOriginal - hOffset1;     // 11/09/91 use original
      ZoomVPt(bodySize);
      if (makeTheView)
      {
        itsView = new _TBodyView(itsSuperView, fMainView, TSubView(itsNextView),
                    itsLocation, bodySize, currency, spBefore, spAfter); // 25/02/9,atStart);
        itsSuperView->AddSubView(itsView);
        if (itsSuperView == fMainView)
          itsView->fIdentifier = itsViewId.fId;            // 25/04/91
        else
          itsView->SetColNum(itsViewId.tag.fColNum);       // 25/04/91
      
        // 25/02/94 HandleView_r = bodyView;
      }
      else
      {
        itsView->Resize(bodySize.h, bodySize.v, invalidate);
        // 25/02/94 bodyView = TBodyView(v.itsView);
        itsView->SetSpacing(spBefore, spAfter);
      }
      itsView->fFirstPage = atStart;            // 21/02/91 25/02/94 moved down
      itsView->fJustified = FALSE;              // 20/06/91
      itsView->fHDepth = (endBreak->fHeadingBreak == NULL ?
                   endBreak->fHDepth : endBreak->fDepth);   // 02/03/94 [21121] copy to view
      if (atStart)
      {
        colEnd.fIndex = 1;
        colEnd.fBreak = NULL;
#ifdef FN
        colEnd.fNoteBreakIn = NULL;
        colEnd.fNoteBreakOut = NULL;
#endif
      }
      else
        startBreak->GetLast(&colEnd);

      v.viewIndex1 = 1;
      v.itemView = NULL;
      colMaxDepth -= FixRound(ruleWidths.top + ruleWidths.bottom);
      if (headingType == kFullHeading && atStart)
        colMaxDepth -= fHDepth;     // use fHDepth in break object ???
      numCols = bodyStyle->GetTotalColumns(); // 29/05/90
      justify = (numCols == 1 && v.body->fKind != kDocument ? FALSE :
                    bodyStyle->GetJustify());       // 13/05/93 [20873]
      balance = bodyStyle->GetBalanced();           // 13/05/93 [20873] moved down
      done = FALSE;

      for (int colNum = 1; colNum <= numCols && !done; colNum++)
      {
        int startIndex;
        int endIndex;
        // VPoint relLocation;
        Fixed relVLocation;
        Fixed incr;
        bool sepHeading;
        TColumnBreak colStart;

        colStart = colEnd;
        startIndex = colStart.fIndex;
        if (colStart.fBreak == NULL && (!atStart || colNum > 1))
          startIndex++;
        endBreak->Get(colNum, &colEnd);
        endIndex = colEnd.fIndex;
        done = (endBreak->fSize == colNum);
        if (startIndex == 1 && (headingType == kSideHeading || headingType == kFullHeading))
        {
          while (!CanHaveView(startIndex, v.body))
            startIndex++;
          sepHeading = TRUE;
        }
        else
          sepHeading = FALSE;

        // if body is justified & caller is not justfying, set incr to gap size between items
        if (justify && itsVSlop == 0 && colEnd.fGapCount && (endIndex < fSize || balance))
        {
          incr = ToFixed(colMaxDepth - colEnd.fColDepth) / colEnd.fGapCount;
          incr = ZoomFixed(incr);
          itsView->fJustified = TRUE;
        }
        else
        {
          // if (colEnd.fGapCount > 0) // 11/01/94 (see [20941]) stop incr being added at end
          //  incr = itsVSlop.h;
          // itsVSlop.h *= colEnd.fGapCount;
          // itsVSlop.v = itsVSlop.h;
          incr = itsVSlop;                 // use gap count passed by the caller
        }
        // relLocation.v = spBefore + FixRound(ruleWidths.top);
        relVLocation = ToFixed(spBefore) + ruleWidths.top;
        if (sepHeading)
        {
          v.subBody = v.body->GetBodyItem(startIndex);
          v.subBodyFmt = GetFormatReadOnly(v.subBody);
          // relLocation.h = FixRound(bodyStyle->GetHeadingLM(fWidth, ruleWidths));
          // SetScaledLocation(v.scaledLocation, relLocation);
          v.scaledLocation.v = FixRound(ZoomFixed(relVLocation));
          v.scaledLocation.h =
                    FixRound(ZoomFixed(bodyStyle->GetHeadingLM(fWidth, ruleWidths)));

          // 14/05/91 set itemStart & itemEnd and pass to UpdateSubBody
          itemStart = (NULLorMinus1(startBreak) ? NULL : startBreak->fHeadingBreak);
          itemEnd = (NULLorMinus1(endBreak) ? NULL : endBreak->fHeadingBreak);
          if (makeTheView)
          {
            itsViewId.tag.fColNum = 0;
            v.itemView = v.subBodyFmt->MakeView(v.subBody, itsViewId, /* 0, vSlop */ 0,
                                       itsView, 0, v.scaledLocation, itemStart, itemEnd);
          }
          else
            UpdateSubBody(0, startIndex, 0 /* vSlop */, itemStart, itemEnd, &v,
                                                     0, changes, FALSE);

          if (headingType == kSideHeading && itemStart != NULL) // 14/05/91
          {
            startBreak->GetLast(&colStart);
            startIndex = colStart.fIndex;
            if (colStart.fBreak == NULL)
              startIndex++;
          }
          else
            startIndex++;     // 19/03/91 from = 2;
        }
        if (headingType == kFullHeading && atStart)
        {
          // relLocation.v += fHDepth;
          relVLocation += ToFixed(fHDepth);
        }
        relVLocation = ZoomFixed(relVLocation);
        v.scaledLocation.h = 
            FixRound(ZoomFixed(bodyStyle->GetColumnLM(fWidth, colNum, ruleWidths, fFlags)));
                                                             // 19/07/94 bwds fns

        // relLocation.h = FixRound(relHLocation);
        // SetScaledLocation(v.scaledLocation, relLocation);

        // 18/12/92 init condition moved from loop so gets done if makeView & first is hidden
        if (startIndex <= endIndex)
        {
          bool keepSpBefore = KeepSpaceBefore(v.body, headingType, numCols, startIndex);

          itemStart = colStart.fBreak;
          if (itemStart == NULL && !keepSpBefore)
            itemStart = TObject(-1);
        }

        for (int index = startIndex; index <= endIndex; index++)
        {
#ifdef FN
          // 25/02/94 [21423] when doing endnotes, filter out those which do not belong to
          // the current container (which is the currency in itsViews fSuperview)
          if (fEndNotes && -PItemFormat(At(index))->fAscentOrContainer !=
                            Curr_fRecnum(TSubView(itsView->fSuperView)->fStructure))
            continue;
#endif
          if (!makeTheView || CanHaveView(index, v.body))
          {
            v.subBody = v.body->GetBodyItem(index);
            if (index == endIndex)
            {
              itemEnd = colEnd.fBreak;
              if (itemEnd == NULL && !TestInHF(v.body))
                // [26020] -1 causes last subview in HF to be updated, when maybe not reformated
                itemEnd = TObject(-1);
            }
            else
              itemEnd = NULL;

            v.scaledLocation.v = FixRound(relVLocation);
            if (makeTheView)
            {
              v.subBodyFmt = GetFormatReadOnly(v.subBody);
              itsViewId.tag.fColNum = colNum;
              v.itemView = v.subBodyFmt->MakeView(v.subBody, itsViewId, /* 0, */ incr,
                                    itsView, NULL, v.scaledLocation, itemStart, itemEnd);
            }

            if (makeTheView || UpdateSubBody(colNum, index, incr,
                            itemStart, itemEnd, &v, 0, changes, FALSE))
            {
              itemStart = NULL;  // 18/12/92 only reset if entry not hidden
              if (v.itemView != NULL) // 14/7/92 ignore empty views
              {
                // v.scaledLocation.v += v.itemView->fSize.v;
                relVLocation += ToFixed(v.itemView->fSize.v);

                // if (itsVSlop.h != 0 || itsVSlop.v != 0)
                //  itsVSlop.h -= (colSpExtra.v - colSpExtra.h);

                // [20941] 15/06/93, 04/05/94 [21719] reinstated test to stop last sub view
                // absorbing the slop, and thus making its size too deep, resulting
                // in the bottom border being displaced down by the size of the slop
                // but needs to be done after the slop contribution from last view has been
                // deducted
                if (index < endIndex && incr > 0 && colEnd.fGapCount > 0)
                {
                  relVLocation += incr;
                  itsView->BodyViewChangedSize(FixRound(incr), invalidate);
                  colEnd.fGapCount--;
                }
              }
            }
            else if (itemStart != TObject(-1))    // 18/12/92
              itemStart = NULL;
            // sepHeading = FALSE;
          }
        }
#ifdef FN
        if (colEnd.fNoteBreakIn != colEnd.fNoteBreakOut)
        {
          v.subBody = v.body->GetNoteCollector();
          v.subBodyFmt = GetFormatReadOnly(v.subBody);
          if (!TBodyFormat(v.subBodyFmt)->fEndNotes)
          {
            long temp = TBodyBreak(colEnd.fNoteBreakOut)->GetDepth();

            if (colEnd.fNoteBreakIn != NULL)
              temp -= TBodyBreak(colEnd.fNoteBreakIn)->GetDepth();
            temp += v.subBodyFmt->fSpBefore + ruleRect.bottom;
            // 04/06/93 [20913] add rule depth
            // 19/05/93 [20871] temp = fMainView->ZoomFixed(temp);
            // 19/05/93 [20871] v.scaledLocation.v = itsView->fSize.v - temp;
            // [20901] bodySize.v is already zoomed
            v.scaledLocation.v = bodySize.v - itsView->ZoomFixed(temp); // 20/05/93 [20889]
            // colSpExtra.h = 0; 
            // colSpExtra.v = 0;
            // 08/05/94 incr = 0;
              // 17/11/93 [21124] avoid passing to the note area if footnotes ... & endnotes
          }
          else
            v.scaledLocation.v = FixRound(relVLocation);
          if (makeTheView)
          {
            v.itemView = v.subBodyFmt->MakeView(v.subBody, itsViewId, /* 0, itsVSlop */ 0,
               itsView, NULL, v.scaledLocation, colEnd.fNoteBreakIn, colEnd.fNoteBreakOut);
            // 08/05/94 itsVSlop changed to 0, so at least consistant in make & update!
            // v.viewIndex1++;
            // 15/12/92 did not update v.viewIndex1 so creating > 1 new col reused same view
            if (v.itemView)        // 19/05/94 [21814]
               v.itemView->fUpdated = TRUE;
#ifdef TRACE
            else
              v.itemView = NULL;    // so can put a stop on this line
#endif
          }
          else
            UpdateSubBody(colNum, 0, 0,  // 08/05/94 incr - endnotes do not update gapcount!
                colEnd.fNoteBreakIn, colEnd.fNoteBreakOut, &v, 0, changes, FALSE); // TRUE);
        }
#endif
      }

      // fn1      if (!makeTheView)
      // fn1        DeleteSubViews(v.lastView, (v.itsView)->CountSubViews(), v.itsView);
      hasEnabledSubviews = FALSE;     // 11/06/93 [20934]
      itsView->EachSubview(this, (DoToSubView)DeleteIfNotUpdated, makeTheView,
                                      &hasEnabledSubviews); // 11/06/93 [20934]
      itsView->ViewEnable(hasEnabledSubviews, FALSE);   // 18/02/93 [20706] , [20934]
      // 18/02/93 [20706]      itsView->fViewEnabled = (itsView->CountSubViews() != 0);
            // 18/02/93 [20706] fViewEnabled is now a mask indicating buttons it responds to
            // 26/11/91 stop crash when click on an (empty) left hand page before chap page
    }
    else if (itsView != NULL)
      itsView->fUpdated = FALSE;    // 27/05/93 [20897] view  needs to be removed
    Success(&fi);      // 11/06/91
Rescue:
    FreeIfObject(bodyStyle);
    ContinueIfFail(&fi);
  }
  return itsView;  // 25/02/94 HandleView_r;
//Rescue:
//  FreeIfObject(bodyStyle);
//  ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
bool _TBodyFormat::ContainsCursor(TCurrency currency, TObject startBreak,
                                     TObject endBreak, TCursorNode cursor)
{
  bool  ContainsCursor_r;
  TObject break1, break2;
  TObject break11 = NULL, break22 = NULL;   // 07/06/93 [20919]
  TColumnBreak breakInfo;
  TBodyStructure body;
  TCurrency subBody;
  TFormat subBodyFmt;
  int index;
  int startIndex;
  int endIndex;
  TCurrency child;
//#ifdef FN
//  bool inNotes = FALSE;
//#endif

  ContainsCursor_r = FALSE;
  body = TBodyStructure(GetStructureReadOnly(currency)); // 19/03/91 RW
  child = TBodyCursor(cursor)->GetBodyItem();
  if (startBreak == NULL)
  {
    startIndex = 1;
    break1 = NULL;
  }
  else
  {
    // 07/06/93 [20919] treat the heading & body seperately, not in one loop
    // which does not work if the heading extends over a page break

    break11 = TBodyBreak(startBreak)->fHeadingBreak;
    //if (TBodyBreak(startBreak)->fHeadingBreak != NULL)
    //{
    // 07/06/93 [20919] startIndex = 1;
    //  break11 = TBodyBreak(startBreak)->fHeadingBreak;
    //}
    // 07/06/93 [20919] else
    TBodyBreak(startBreak)->GetLast(&breakInfo);
    startIndex = breakInfo.fIndex;
    break1 = breakInfo.fBreak;
    if (break1 == NULL /* 27/03/91 && startIndex > 1 */)         // 23/11/90
      startIndex++;
  }

  if (endBreak == NULL) // fn1
    endBreak = fColBreaks;

#ifdef TRACE
  if (endBreak == NULL)     // 04/09/96 endBreak/fColBreaks both NULL after Word import
    SysBeep(0);
  else
#endif
  {
    break22 = TBodyBreak(endBreak)->fHeadingBreak;
    if (break22 != NULL)   // TBodyBreak(endBreak)->fHeadingBreak != NULL) // fn1
    {
      // 07/06/93 [20919] endIndex = 1;
      // break22 = TBodyBreak(endBreak)->fHeadingBreak;
      if (startBreak == NULL)    // 07/06/93 [20919]
        startIndex = 2;          // if the heading overflows do not start with body index 1!
    }
    // 07/06/93 [20919] else
    TBodyBreak(endBreak)->GetLast(&breakInfo);
    endIndex = breakInfo.fIndex;
    break2 = breakInfo.fBreak;
#ifdef FN
    // 22/4/92
    // inNotes = cursor->GetNext()->fCurrency == 
    //                                     body->GetNoteCollector();
    if (cursor->GetNext()->fCurrency == body->GetNoteCollector())
    {
      // 22/4/92 block revamped
      TCurrency noteCollector = body->GetNoteCollector();
      TBodyBreak eb = TBodyBreak(endBreak);

      subBodyFmt = GetFormatReadOnly(noteCollector);
      for (int b = 1; b <= eb->fSize; b++)
      {
        TColumnBreak bi;

        eb->Get(b, &bi);
        if (bi.fNoteBreakIn != bi.fNoteBreakOut &&
              subBodyFmt->ContainsCursor(noteCollector, bi.fNoteBreakIn, 
                  bi.fNoteBreakOut, cursor->GetNext()))
          ContainsCursor_r = TRUE;
      }
    }
    else
#endif
    {
      // 07/06/93 [20919] NB this now excludes the heading if it has either start or end breaks
      for (index = startIndex; index <= endIndex; index++)
      {
        subBody = body->GetBodyItem(index);
        if (subBody == child)
        {     // 1/8/90 modified from 27/07/90 modified from 26/07/90 version
          if ((index == startIndex && break1 != NULL) || (index == endIndex && break2 != NULL))
          {
            if (startIndex != endIndex)
            {
              if (index == startIndex)
                break2 = NULL;
              else
                break1 = NULL;
            }
            subBodyFmt = GetFormatReadOnly(subBody);
            ContainsCursor_r =
                       subBodyFmt->ContainsCursor(subBody, break1, break2, cursor->GetNext());
          }
          else
            ContainsCursor_r = TRUE;
          break;
        }
      }
    }
    // 07/06/93 [20919] new bit to see if cursor in the (continued) bit of the heading
    if (!ContainsCursor_r && (break11 != NULL || break22 != NULL))
    {
      subBody = body->GetBodyItem(1);
      if (subBody == child)
      {
        subBodyFmt = GetFormatReadOnly(subBody);
        ContainsCursor_r =
                   subBodyFmt->ContainsCursor(subBody, break11, break22, cursor->GetNext());
      }
    }
  }
  return(ContainsCursor_r);
}


// ------------------------------------------------------------------------
void _TBodyFormat::DoClearFlags(PItemFormat itemFmt, TBodyStructure body,
                                                                int *index, int hf)
{
  TCurrency subBody;
  TFormat subBodyFmt;

  (*index) ++;
  if (itemFmt->fChanged)
  {
    itemFmt->fChanged = FALSE;
    subBody = body->GetBodyItem(*index);
    if (hf ||     // 18/06/95 [26020] clear all change flags at end of ReformatHeaderFooter
              Curr_fType(subBody) != kTextStruct)  // 06/09/90 ignore paras
    {
      subBodyFmt = GetFormatReadOnly(subBody);  // 21/03/91 RW
      subBodyFmt->ClearChangedFlags(subBody, hf);
    }
  }
}


// ------------------------------------------------------------------------
void _TBodyFormat::ClearChangedFlags(TCurrency currency, int hf)
{
  TBodyStructure body;
  int index = 0;

  SetHasChanged(FALSE);
  fStyleChanged = FALSE; // 29/05/90
  body = TBodyStructure(GetStructureReadOnly(currency));       // 21/03/91 RW
  Each(this, (DoToItem)_TBodyFormat::DoClearFlags, body, &index, hf);
#ifdef FN
  // 17/05/94 [21807] clear any flags in the footnotes
  if (body->fFootnotes != gNullCurrency)
    GetFormatReadOnly(body->fFootnotes)->ClearChangedFlags(body->fFootnotes, hf);
#endif
}


#ifdef NEVER
// ------------------------------------------------------------------------
#ifdef FN
// 29/4/92 new
TChangeTypes _TBodyFormat::FormatNote1(TCurrency note, TCurrency ref, // 11/5/93
        TReformatVars *v)
{
  return kNoChg;
}

void _TBodyFormat::FormatNotes9and99(TCurrency currency, TCurrency note,
        TBodyStructure noteSetStructure)
{
  TCurrency ref9;
  TCurrency ref99;
  TTextDocument doc = TTextDocument(fMainView->fDocument);
  TSelection saveSel = doc->GetSelection(FALSE);
  TStdNoteVars v;

  noteSetStructure->GetReferenceTo9and99(note, ref9, ref99);
  v.obj = this;
  v.procToDo = (DoNote) _TBodyFormat::FormatNote1;
  for (int n = 1; n <= 2; n++, ref9 = ref99)
    if (ref9 != 0)
    {
      TSelection refSel;
      TCursorNode anchor, activeEnd;

      doc->InitialSelection(fMainView, ref9, ref9);
      refSel = doc->GetNewSelection();
      // refSel->fReformatType = 12; // 17/12/93 KReformat9and99
      fMainView->fSelection = refSel;
      refSel->GetNodes(currency, anchor, activeEnd);
      Reformat(currency, anchor, activeEnd, fWidth, -1, &v);
      FreeIfObject(refSel);
    }
  doc->fSelection = saveSel;
  fMainView->fSelection = saveSel;
}
#endif
#endif

// +++++++++++++++++++++ Start of TBodyView +++++++++++++++++++++++++++++++

// ------------------------------------------------------------------------
_TBodyView::_TBodyView(TView itsSuperView, TMainView itsMainView,
            TSubView itsNextView, VPoint &itsLocation, VPoint &itsSize,
            TCurrency itsStructure, int itsSpBefore, int itsSpAfter)
            // 25/02/94 bool itsFirstPage)
          : (itsMainView->fDocument, itsSuperView, itsMainView, itsNextView,
             itsLocation, itsSize,
             // sizeVariable, sizeVariable,
             itsStructure, itsSpBefore, itsSpAfter)
{
// 25/02/94  fFirstPage = itsFirstPage;
#ifndef ZERO_OBJ
  fJustified = FALSE;
#endif
}


// ------------------------------------------------------------------------
void _TBodyView::BodyViewChangedSize(int deltaV, bool invalidate)
{
  if (!fJustified)            // 20/06/91
  {
// 04/05/94 [21720] just changing fSize was not getting updated views borders redrawn
//    fSize.v += delta.v;
//    fSize.h += delta.h;
    Resize(fSize.h, fSize.v + deltaV, invalidate);
    TSubView(fSuperView)->BodyViewChangedSize(deltaV, invalidate);
  }
}

// ------------------------------------------------------------------------
void _TBodyView::DoRuleAction(TBodyStructure bodyStructure, TBodyFormat bodyFormat, TObject obj, TheDrawProc doAction, ...)
{
  // 29/05/90
  int colNum;
  Rect extent;
  int hDepth;
  Fixed sepWidth;
  Fixed lineWidth;
  Fixed offset;
  VRect ruleWidths;
  CntlAdornment borders;
  TRuleType ruleType;
  va_list ap;
  TBodyViewDrawList args;

  va_start(ap, doAction);
  args = va_arg(ap, TBodyViewDrawList);
  va_end(ap);

  bodyFormat->GetBorderInfo(ruleWidths, borders, ruleType);
  if (ruleWidths.top != 0)
    ruleWidths.top = ZoomFixed(ruleWidths.top);

  if (ruleWidths.bottom != 0)
    ruleWidths.bottom = ZoomFixed(ruleWidths.bottom);

  lineWidth = GetBorderWidth(adnLineLeft, adnLineLeft, bodyFormat->fColSepRule);
  GetQDExtent(extent);
  if (ruleWidths.top > 0)              // 25/04/91
    extent.top += FixRound(ruleWidths.top) + fSpBefore;
  hDepth = fHDepth;   // 02/03/94 [21121] use views fHDepth: hDepth = bodyFormat->fHDepth;
  if (fFirstPage && hDepth > 0 && bodyStructure->fHeadingType != kSideHeading)
  {
    hDepth = ZoomInt(hDepth);
    extent.top += hDepth;
  }
  if (ruleWidths.bottom > 0)            // 25/04/91
    extent.bottom = extent.bottom - FixRound(ruleWidths.bottom) - fSpAfter;
  for (colNum = 1; colNum <= bodyFormat->fNumCols; colNum++)
  {
    offset = ZoomFixed(bodyFormat->fColOffsets[colNum]);
    extent.left = FixRound(offset);
    if ((colNum == 1) && (bodyStructure->fHeadingType == kSideHeading))
    {
      sepWidth = bodyFormat->fSideSep;
      if ((bodyFormat->fNumCols == 1) || (sepWidth < bodyFormat->fColSep))
      {
//        offset = FixDiv(sepWidth - lineWidth, kFix1 * 2);
        offset = (sepWidth - lineWidth) / 2;
//        offset = Max(offset, sepWidth - FixMul(lineWidth, kFix1 * 3));
        offset = Max(offset, sepWidth - (lineWidth * 3));
      }
      else
        offset = sepWidth - (bodyFormat->fColSep + lineWidth) / 2;
//        offset = sepWidth - FixDiv(bodyFormat->fColSep + lineWidth, kFix1 * 2);
                             // 10/05/94 [31732] move position back by lineWidth
    }
    else
    {
      sepWidth = bodyFormat->fColSep;
//      offset = FixDiv(sepWidth - lineWidth, kFix1 * 2);
      offset = (sepWidth - lineWidth) / 2;
    }
    extent.right = extent.left + FixRound(sepWidth);
    if ((extent.bottom > extent.top) && (lineWidth <= sepWidth))
      doAction(obj, extent, FixRound(ZoomFixed(offset)), args);
  }
}


// ------------------------------------------------------------------------
void _TBodyView::DrawItsChanges(TSubView view, TBodyStructure bodyStruct,
                 TBodyFormat bodyFmt, bool invalidate, bool installChanges)
{
//#ifdef FN
//  if (view->fStructure == bodyStruct->GetNoteCollector())
//    view->DrawChanges(invalidate, installChanges);
//  else
//#endif
//  if (bodyFmt->GetChanged(bodyStruct->FindBodyItem(view->GetStructure())))
//    view->DrawChanges(invalidate, installChanges);

  if (
#ifdef FN
            view->fStructure == bodyStruct->GetNoteCollector() ||
#endif
            bodyFmt->GetChanged(bodyStruct->FindBodyItem(view->GetStructure())))
    view->DrawChanges(invalidate, installChanges);
}


// ------------------------------------------------------------------------
void _TBodyView::DrawChanges(bool invalidate, bool installChanges)
{
//  TCurrency body;
  TBodyFormat bodyFmt;
  TBodyStructure bodyStruct;
//  Rect extent;

//  body = GetStructure();
  bodyFmt = TBodyFormat(GetMyFormatReadOnly());
  bodyStruct = TBodyStructure(GetStructureReadOnly(GetStructure()));  // 19/03/91 RW

// 09/09/91  if (bodyFmt->fHasChanged)
  {
// 29/05/90    bodyStruct = TBodyStructure(GetStructureReadOnly(body));
    EachSubview(this, (DoToSubView)_TBodyView::DrawItsChanges, bodyStruct, bodyFmt, invalidate, installChanges);
  }

  if (bodyFmt->fStyleChanged) // 29/05/90
  {
    GetQDExtent(fUpdateExtent);
//    fUpdateExtent = extent;
  }
  _TSubView::DrawChanges(invalidate, installChanges);
}


// ------------------------------------------------------------------------
void _TBodyView::DoDraw(Rect &extent, int offset, TBodyFormat bodyFmt)
{
  DrawRule(v, extent.left + offset, extent.top, extent.bottom, bodyFmt->fColSepRule);
}

void _TBodyView::Draw(Rect &area)
{
  // 29/05/90
//  TCurrency body;
  TBodyFormat bodyFmt;
  TBodyStructure bodyStruct;

//  body = GetStructure();
  bodyFmt = TBodyFormat(GetMyFormatReadOnly());
  bodyStruct = TBodyStructure(GetStructureReadOnly(GetStructure()));  // 19/03/91 RW
  _TSubView::Draw(area);
  if (bodyFmt->fNumCols > 0)
  {
    DoRuleAction(bodyStruct, bodyFmt, this, (TheDrawProc) _TBodyView::DoDraw, bodyFmt);
  }
#ifdef FN
  else if (fFirstPage && bodyStruct->fKind == kFootnote) // fn2
  {
    char fn[6];
    TBodyStyle bodyStyle;
//    int fx, fy;
    Fixed asc1, asc2, desc1, leading;
    long asc, desc, v;
    TFormat firstItem;
    TCurrency body = GetStructure();
    TFontStyle fontStyle;
    int backwardsFont;

    bodyStruct->GetNoteNumber(body, body, fn);
    bodyFmt = TBodyFormat(fMainView->GetFormatReadOnly(bodyStruct->fParent));
    bodyStyle = TBodyStyle(bodyFmt->GetCompositeStyle(bodyStruct->fParent));
    fontStyle.fTextFont = bodyStyle->fTextFont;
    // 18/05/94 fix for bug in TW2.06 where noteset has no defined font bit
    if (fontStyle.fTextFont == 0)
      fontStyle.fTextFont = TTextDocument(fDocument)->GetFNum(bodyStyle->fFontName);
    fontStyle.fTextSizeX = ZoomInt(bodyStyle->fTextSizeX * 2 / 3);
    fontStyle.fTextSizeY = ZoomInt(bodyStyle->fTextSizeY * 2 / 3);
    fontStyle.fTextFace = bodyStyle->fTextFace;
    backwardsFont = bodyStruct->TextFont(&fontStyle);
    // 15/04/93 only do one Measure (at 2/3rds normal size)
    //    fx = fMainView->ZoomInt(bodyStyle->fTextSizeX);
    //    fy = fMainView->ZoomInt(bodyStyle->fTextSizeY);
    //    bodyStruct->TextFont(bodyStyle->fTextFont, fx, fy);
    //    TextFace(bodyStyle->fTextFace);
    TextColour(bodyStyle->fColour, TRUE);
    MeasureFont(asc2, desc1, leading);
    asc1 = asc2 * 3 / 2;
    firstItem = fMainView->GetFormatReadOnly(SubViewAt(1)->GetStructure());
    asc = 0;     // 01/07/92
    firstItem->GetDepth(asc, desc);
    asc = ZoomInt(asc);
    v = Max(asc, FixRound(asc1)) + SubViewAt(1)->fSpBefore - FixRound(asc1 - asc2);
    PaintText(fn, wr_font_OSCOORDS, backwardsFont ? fSize.h : 0, v + fSpBefore);
    FreeIfObject(bodyStyle);
  }
#endif
}


// ------------------------------------------------------------------------
static bool OwnsCursor(TObject null, TSubView view, TCursorNode cursor, int* lastIndex)
{
  TSubView subView;

  *lastIndex = *lastIndex + 1;
  return(view->ContainsCursor(cursor, cursor, subView));
}


// ------------------------------------------------------------------------
void _TBodyView::SetHighlight(TCursorNode anchor, TCursorNode activeEnd, bool redraw,
                              bool noteSelection) // fn1
{
  int firstIndex;
  int index;
  int lastIndex;
  TSubView view;
  TCursorNode cursor;
  TCursorNode cursor1, cursor2;
  bool cleared;
#ifdef FN
  bool test;
  bool canHilite = TRUE;
  TBodyStructure structure = TBodyStructure(
            // 18/07/93 unnecessary!!! TTextDocument(fMainView->fDocument)->
                          GetStructureReadOnly(fStructure));

  if (structure->GetBodyKind() == kDocument)
    test = !structure->fChapEndNotes;
  else if (structure->GetBodyKind() == kChapter)
    test = TBodyStructure(structure->GetStructureReadOnly(structure->fParent))->fChapEndNotes;
  else
    test = FALSE;
#endif

  cleared = FALSE;
  if ((fSubViews == NULL))
    return;

  if (anchor == NULL)
    firstIndex = 1;
  else if (anchor == Ptr(-1))
  {
    firstIndex = CountSubViews() + 1;
    cleared = TRUE;
  }
  else
  {
    cursor = anchor->GetNext();
    lastIndex = 0;
    view = TSubView(FirstSubViewThat(NULL, (TestSubView)OwnsCursor, cursor, &lastIndex));
//    Assert(view, kNoSubView);
    if (view == NULL)   // 19/08/92
    {
      view = this;
#ifdef TRACE
      SysBeep(0);
#endif
    }
    firstIndex = lastIndex;
  }

  if (activeEnd == 0)
    lastIndex = CountSubViews();
  else if (activeEnd == Ptr(-1))
  {
    lastIndex = 1;
    cleared = TRUE;
  }
  else if (anchor == activeEnd)
    lastIndex = firstIndex;
  else
  {
    cursor = activeEnd->GetNext();
    lastIndex = 0;
    view = TSubView(FirstSubViewThat(NULL, (TestSubView)OwnsCursor, cursor, &lastIndex));
//    Assert(view, kNoSubView);
    if (view == NULL)   // 19/08/92
    {
      view = this;
#ifdef TRACE
      SysBeep(0);
#endif
    }
  }
  for (index = 1; index <= firstIndex-1; index++)
  {
    view = SubViewAt(index);
    if (view->Selected())
      view->SetHighlight(TCursorNode(-1), NULL, redraw, noteSelection); // fn1
  }

  for (index = firstIndex; index <= lastIndex; index ++)
  {
    cursor1 = NULL;
    cursor2 = NULL;
    if (index == firstIndex)
    {
      if (NULLorMinus1(anchor))
        cursor1 = anchor;
      else
        cursor1 = anchor->GetNext();
    }

    if (index == lastIndex)
    {
      if (NULLorMinus1(activeEnd))
        cursor2 = activeEnd;
      else
        cursor2 = activeEnd->GetNext();
    }

    view = SubViewAt(index);
#ifdef FN
    if (test)
    {
      TStructure str = // 18/07/93 unnecessary !!! TTextDocument(fMainView->fDocument)->
                                  GetStructureReadOnly(view->fStructure);

      if (noteSelection && 
           (str->GetKind() == kNoteSet || str->IsPartOf(1 << kNoteSet) != 0))
                                // 24/01/94 IsPartOf passed a set of TStyleTypes
        canHilite = TRUE;
      else if (!noteSelection && 
           !(str->GetKind() == kNoteSet || str->IsPartOf(1 << kNoteSet) != 0))
                                     // 24/01/94 IsPartOf passed set of TStyleTypes
        canHilite = TRUE;
      else
        canHilite = FALSE;
    }
    if (canHilite)
#endif
    view->SetHighlight(cursor1, cursor2, redraw, noteSelection); // fn1
  }

  for (index = lastIndex + 1; index <= CountSubViews(); index++)
  {
    view = SubViewAt(index);
    if (view->Selected())
      view->SetHighlight(NULL, TCursorNode(-1), redraw, noteSelection); // fn1
  }
#ifdef DRAGDROP
  if (redraw != 2)         // 29/09/93 [21060] for safety
#endif
    Select(!cleared);
}

#ifdef TRACE
// ------------------------------------------------------------------------
void _TBodyView::ScrollCursorIntoView(TCursorNode cursor)
{
  // does not scroll
}
#endif

// ------------------------------------------------------------------------
int _TBodyView::GetPointerShape(Point &localPoint)
{
  // 14/05/90 - changed so that there is an I-Beam over the main view
  return iBeamCursor;    // SetCursor(GetCursor(iBeamCursor));
}

#ifdef TABLES
// ------------------------------------------------------------------------
static void DoChapIteration(TBodyStructure structure, TCurrency currency, long pos,
         TCursorNode anchor, TCursorNode activeEnd, bool *chapterFound)
{
  if (Curr_fType(currency) == kBodyStruct)
  {
    TBodyStructure subStruct = TBodyStructure(structure->GetStructureReadOnly(currency));

    if (subStruct->GetBodyKind() == kChapter && subStruct->IsShown(currency, gNullCurrency))
      *chapterFound = TRUE;
  }
}


// ------------------------------------------------------------------------
static bool ChapInSelection(TBodyStructure structure, TSelection selection,
                          TCurrency currency)
// 23/06/93 [20926] this and DoChapIteration to see if a chapter in the selection
{
  bool chapterFound = FALSE;

  structure->Iterate(currency, TCursorNode(selection->GetAnchorRoot()),
                               TCursorNode(selection->GetActiveRoot()),
                               TRUE, structure, (DoStep)DoChapIteration, &chapterFound);
  return chapterFound;
}
#endif

// ------------------------------------------------------------------------
void _TBodyView::DoSetupMenus()
{
  TTextDocument document;
  TBodyStructure structure;
  TStyleTypes kind;
  bool hf;
  bool endStruct; // fn1
  TSelection selection; // fn1
// 25/03/92 not used  TStyleFormat docStyle; // fn1

  _TSubView::DoSetupMenus();
  document = TTextDocument(fDocument);
  structure = TBodyStructure(GetStructureReadOnly(fStructure));
  kind = structure->GetBodyKind();
  selection = document->GetNewSelection(); // fn1
  endStruct = selection->fEndStructure; // fn1
  hf = (kind == kHeader || kind == kFooter
#ifdef FN
      || kind == kNoteSet || kind == kFootnote
#endif
       );
  if (hf || kind <= kFigure /*kind == kDocument || kind == kChapter || kind == kSection ||
                                     kind == kFigure || kind == kList*/)
  {
#ifdef TABLES
    if (!endStruct) // fn1
      Enable(cRemoveStruct, (!hf) && kind != kDocument); // 18/04/91 allow if Figure
#endif

    if (kind != kFigure)
    {
#ifdef FN
      bool notNoteSet = (kind != kNoteSet);
#else
#define notNoteSet TRUE
#endif
#ifdef TABLES
// 11/01/94      EnableMenu(cmStructureStyle);  // 20/06/93 [20949] styles on structure cmds

      // 23/06/93 [20926] only allow chapter if insertion point, not in header/footer/fn
      // or selection in document, provided selection does not include a chapter
      // or chapter
      int chapsInSel = (kind == kDocument && !selection->fCursor ?
                           ChapInSelection(structure, selection, fStructure) : FALSE);
      // 19/05/94 [21705] also stop Sections & lists when selection contains chapters
      // 23/05/94 [21810] also stop chapter anywhere in h/f or footnote area
      EnableStructCmd(cChapter, kind == kChapter || (!hf && !chapsInSel &&
                !structure->IsPartOf(1 << kNoteSet | 1 << kHeader | 1 << kFooter)));
      EnableStructCmd(cSection, (!hf) && kind != kList && !chapsInSel);
      EnableStructCmd(cSubList, kind == kList);
      EnableStructCmd(cSubSection, kind == kSection &&
                             structure->GetLevel() < kMaxLevels - kBaseBodyStyle - 1);
      EnableStructCmd(cList, notNoteSet && !chapsInSel);
      EnableStructCmd(cTable, notNoteSet);
      EnableStructCmd(cFigure, notNoteSet && !chapsInSel);
         // 27/07/94 [22012] check chap all selected (in NewStructure): && kind != kChapter
         // 19/05/94 [21705] not chap and no chaps in sel
      EnableStructCmd(cPicture, notNoteSet);
#endif
      EnableCmd(cParagraph);
#ifdef MATHS
      EnableStructCmd(cEquation, notNoteSet);             // 15/01/92
#endif
      if (endStruct)  // 25/05/93 [20896] enabled by (any) text, so dim if Endstr
      {
        DisableCmd(cCurrTime);
        DisableCmd(cCurrDate);
      }
      else
      {
// 18/04/91     Enable(cRemoveStruct, (!hf) && kind != kDocument);
#ifdef TABLES
        bool notHf = !hf;

        EnableCmd(cWhiteSpace);
        Enable(cColBreak, notHf);    // 20/01/94 [21353] (!hf) && kind != kDocument);
        Enable(cPageBreak, notHf);
        Enable(cPageFiller, notHf);      // 03/05/91
#endif
#ifdef FN
#endif
// 25/05/93 [20896] enabled if any text, and disable here if necessary
//        EnableCmd(cCurrTime);          // 07/09/90 following enables added
//        EnableCmd(cCurrDate);
//        if (kind == kHeader || kind == kFooter)
//        // enable cDocTitle, cChapTitle, cPageNum, cPageCount, cChapCount, cContText
//          for (int cmdNo = cDocTitle; cmdNo <= cChapCount; cmdNo++)
//            EnableCmd(cmdNo);
      }
      if (endStruct || (kind != kHeader && kind != kFooter))  // 25/05/93 [20896]
      {
        for (int cmdNo = cDocTitle; cmdNo <= cPageCount; cmdNo++)
          DisableCmd(cmdNo);
        // not used DisableCmd(cContText);
        DisableCmd(cChapCount);
      }
#ifdef TABLES
      if (/*kind == kDocument ||*/ kind <= kChapter)
      {
        char buff[10];
        int startPage = TBodyFormat(GetMyFormatReadOnly())->fPageNumber;

        SetCmdName(cSetPageNumMenu, GetIndString(38, 2 - kind)); // (kind == kDocument) + 1));

        if (startPage == 0)
          buff[0] = 0;
        else
          sprintf(buff, "%d", startPage & (kPageTurnover - 1));
        SetCmdName(cSetPageNumber, buff);
        EnableCmd(cSetPageNumber);
        // 02/05/95 Enable(cSetPageNumMenu, TRUE);   // 14/02/92
      }
      else
        DisableCmd(cSetPageNumber);    // 02/05/95 Enable(cSetPageNumMenu, FALSE);   // 14/02/92
#endif
#ifdef FN
      if (hf)
        DisableCmd(cFootNote);   // 25/05/93 [20896] already enabled by (any) textView
      // 25/05/93 [20896] Enable(cFootNote, !hf);
// [20876] 17/05/93 moved to UTextComm
// [20876]      if (kind == kFootnote || kind == kNoteSet)
// [20876]      {
// [20876]        DisableCmd(cChangeStyle);
// [20876]        DisableCmd(cCut);
// [20876]        DisableCmd(cCopy);
// [20876]        DisableCmd(cPaste);
// [20876]        if (kind == kNoteSet)
// [20876]          DisableCmd(cClear);
// [20876]        else // if (kind == kFootnote)
// [20876]          Enable(cClear, !selection->fCursor);
// [20876]      }
      if (kind == kDocument)
      {
        // 05/02/93 [20616] Get ticks on Footnote menu on the right entry when no footnotes
        TBodyStyle bodyStyle = TBodyStyle(fMainView->GetStyleReadOnly(structure->fStyle));
        TBodyStyle changes;
        char ticks[5];
        int defined;
        int i;

        if (structure->fChanges != 0)
        {
          changes = TBodyStyle(fMainView->GetStyleReadOnly(structure->fChanges));
          defined = changes->fDefinedInBody;
        }
        else
        {
          changes = bodyStyle;   // safety as defined = 0 stops changes being accessed
          defined = 0;
        }

        for (i = 0; i < 5; i++)
          ticks[i] = FALSE;
        if (((defined & kEndNotes) ? changes : bodyStyle)->tag.docStyle.fEndNotes)
        {
          if (((defined & kCollector) ? changes : bodyStyle)->tag.docStyle.fEndChapter)
            ticks[2] = TRUE;
          else
            ticks[1] = TRUE;
        }
        else
          ticks[0] = TRUE;

        if (((defined & kAutoNumber) ? changes : bodyStyle)->tag.docStyle.fAutoNumber)
          ticks[3] = TRUE;
        else
          ticks[4] = TRUE;
        for (i = 0; i < 5; i++)
          EnableCheck(cFNPage + i, TRUE, ticks[i]);
        EnableCmd(cFNStartNum);
        NumToString(document->fFirstFootnote + 1, ticks);
        SetCmdName(cFNStartNum, ticks);
      }
#endif
#if !defined TABLES || defined NETWP
      EnableCmd(cSelectAll);  // 18/10/94 Select all for TalkWrite
#endif
    }
  }
}


// ------------------------------------------------------------------------
void _TBodyView::GetTrackLimits(TSubView subView, VRect &picLimits,
                                              TwoBools repositionInLine)
{
  StdGetTrackLimits(subView, picLimits, repositionInLine);
}

#ifdef TABLES
// ------------------------------------------------------------------------
TCommand _TBodyView::DoSetPageNumber(TTextDocument document,
                                               int kindOfStructure)
{
  char menuText[12];
  int theNum = 0;      // zero will make chapter carry on from previous one

  CmdToName(cSetPageNumber, menuText);
  if (menuText[0] != 0)
  {
    StringToNum(menuText, theNum);
    if (theNum == 0)
      theNum = kPageTurnover;   // 02/05/95 allow zero page number
  }
  return (new _TPageNumberCmd(document, fMainView, fStructure, theNum));
}
#endif

// ------------------------------------------------------------------------
TCommand _TBodyView::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
  TTextDocument document;
  TBodyStructure structure;
  CmdNumber theCmdNumber; // 20/06/93 [20949]
#ifdef TABLES
  int kindOfStruct;
  TCurrency currency;
  FailInfo fi;
  volatile TArray arrayOfStyleChanges;
#endif

  document = TTextDocument(fDocument);

  // 25/07/90 - next line new
  structure = TBodyStructure(GetStructureReadOnly(fStructure));
#ifdef TABLES
  kindOfStruct = structure->GetBodyKind();
#endif

#ifdef TABLES
  // 08/08/90 - create table cmd if you click on the table top level menu
  if (aCmdNumber == cNewTableMenu)
    aCmdNumber = cTable;
#endif

  theCmdNumber = aCmdNumber; // 20/06/93 [20949]
#ifdef TABLES
  // 20/06/93 [20949] for structure commands created with style
  if (aCmdNumber < 0 && MenuForNegCmd(aCmdNumber) == cmStructureStyle)
    aCmdNumber = document->fLastStructCmdNum;
                           // the actual command set up when side menu built
#endif

  switch (aCmdNumber)
  {
#ifdef TABLES
  // 26/11/93 [21132] allow adjust commands for all buttons using resources
  case cBarChangeStyle:            // 06/07/93 adj click on the Style on the icon bar
    theCmdNumber = cChangeStyle;   // 03/10/96 [27098] not aCmdNumber
  case cSaveStyle:
    if (!CmdEnabled(theCmdNumber))
      return gNoChanges;
    if (theCmdNumber == cChangeStyle)
      break;           // handled by the document
    {
      TSaveStyleDlg aDialogView;
      bool changeAll;
      Str255  name;
      TSelection selection;
      TStyleFormat changes;
      IDType choice;

      aDialogView = TSaveStyleDlg(NewTemplateWindow(kSaveStyleDlgID, fDocument));
      selection = document->GetNewSelection();
      aDialogView->SetSelection(selection);
      changes = selection->GetCurrentChanges(TRUE);
          // 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted

      aDialogView->SetAttrs(NULL, changes, TRUE);
      aDialogView->SetDescription();

      choice = aDialogView->PoseModally(cSaveStyle);
      changeAll = aDialogView->GetInfo(name);
      aDialogView->Close();
      if (choice == gIDOKbn)
      {
        TEditedStyles editedStyles;
        TEditStylesCmd aCmd; 

        if (changeAll)
          return new _TApplyChangesCmd(document, 1);
        {
          int level = selection->fPopup;
          TLevelInfo levelInfo;
          TStyleStructure styleStruct;

          do
          {
            selection->Get(level, &levelInfo);
            level++;
#ifdef MATHS
            editedStyles.fEmphasis = ((levelInfo.fKind == kText || levelInfo.fKind == kMaths) &&
                                                    levelInfo.fPart >= 2);  // 13/01/92
#else
            editedStyles.fEmphasis = (levelInfo.fKind == kText &&
                                                    levelInfo.fPart == 2);
#endif
          } while (levelInfo.fPart != 1 && !editedStyles.fEmphasis);     // 20/03/91 from <= 0

          editedStyles.fAction = -1;
          strcpyn(editedStyles.fName, name, defNameLen);
          editedStyles.fCmdKey = 0;
          editedStyles.fPart = levelInfo.fPart;
          MoveRect(editedStyles.fCustom, levelInfo.fCustom);
          editedStyles.fBaseChanges = levelInfo.fChanges;
          editedStyles.fNewStyle =
                               editedStyles.fBaseStyle = levelInfo.fStyle;
          document->CloneStyle(document, fMainView, FALSE, FALSE, // 8/4/92
                                              editedStyles.fNewStyle);
          styleStruct = document->GetStyleReadWrite(editedStyles.fNewStyle);
          styleStruct->SetName(editedStyles.fName);  // 22/04/94
          // 19/03/91 save part style changes on save style
          editedStyles.fOverrides = fMainView->GetStyleReadOnly(editedStyles.fBaseChanges);
          arrayOfStyleChanges = new _TArray(sizeof(TEditedStyles));
        
          CatchFailures(&fi);
          arrayOfStyleChanges->InsertFirst(&editedStyles);
          document->fStyleSheet->AddStyle(editedStyles.fName,
           levelInfo.fKind == kHeader || levelInfo.fKind == kFooter ? kDocument : levelInfo.fKind,
             // 01/08/95 [26041] treat h/f styles as kDoc to put in same menu with no dup F-keys
                       editedStyles.fEmphasis, editedStyles.fNewStyle, editedStyles.fCmdKey);
          aCmd = new _TEditStylesCmd(document, arrayOfStyleChanges);
          Success(&fi);
          return aCmd;
        }
      }
    }
    return gNoChanges;

  case cChapter:
    if (kindOfStruct == kDocument ||
                   (kindOfStruct == kChapter && !document->GetNewSelection()->fEndStructure))
      return new _TNewStructureCmd(document, theCmdNumber, GetStructure());
    break;
#endif

  case cParagraph:
#ifdef TABLES
  case cWhiteSpace:
  case cPageFiller:
#endif
    // 23/06/93 [20956] ban white space as well as cParagraph in figures
    if (structure->GetBodyKind() == kFigure)
      break;
    // 23/06/93 else run on to create a NewStructureCmd
#ifdef TABLES
  case cSection:
  case cSubSection:
  case cList:
  case cSubList:
  case cTable:
  case cFigure:
#ifdef MATHS
  case cEquation:
#endif
  case cPicture:
  case cRemoveStruct:
#endif
    return new _TNewStructureCmd(document, theCmdNumber, fStructure);

#ifdef TABLES
  case cPageBreak:
  case cColBreak:
    if (structure->GetBodyKind() != kFigure)      // 23/06/93 [20956] stop breaks in Figures
    {
      // 21/03/91 send up if necessary
      TSelection selection = document->GetNewSelection();
      TCursorNode anchor;
      TCursorNode activeEnd;
      TStructure subBody;
      int index;

      selection->GetNodes(fStructure, anchor, activeEnd);
      currency = TBodyCursor(anchor)->GetBodyItem();
      subBody = document->GetStructureReadOnly(currency);
      index = structure->FindBodyItem(currency);

      if (index > 1 || subBody->InSecondHalf(anchor->GetNext()) ||
                           structure->fParent == 0) // 25/03/91
        return new _TBreakCommand(aCmdNumber, document, fStructure);
    }
    break;

  case cSetPageNumber:
// 08/02/91    if (kindOfStruct == kDocument || kindOfStruct == kChapter)
    return DoSetPageNumber(document, kindOfStruct);
#endif

#ifdef FN
  case cFNStartNum:
  case cFNPage:
  case cFNEndDoc:
  case cFNEndChap:
  case cFNNumbers:
  case cFNSymbols:
    {
      TBodyStyle theStyle;
      TSelection selection;

      document->CommitStyle(TCommand(-1));
      document->CommitLastDocCommand();        // 16/04/93 from CommitLastCommand
      selection = document->GetSelection(TRUE);
      selection->fReformatType = kReformatAll;
      selection->PushLevel();
      theStyle = TBodyStyle(document->GetCurrentChanges(FALSE));
            // 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted
      if (aCmdNumber <= cFNEndChap)
      {
        theStyle->fDefinedInBody |= kEndNotes | kCollector;
        theStyle->tag.docStyle.fEndNotes = aCmdNumber != cFNPage;
        theStyle->tag.docStyle.fEndChapter = aCmdNumber == cFNEndChap;
      }
      else if (aCmdNumber == cFNStartNum)
      {
        char menuText[16];

        CmdToName(cFNStartNum, menuText);
        document->fFirstFootnote = atoi(menuText) - 1;
        // theStyle->fDefinedInBody |= 0x2000;
        aCmdNumber = cFNStartNumMenu;     // for undo message
      }
      else
      {
        theStyle->fDefinedInBody |= kAutoNumber;
        theStyle->tag.docStyle.fAutoNumber = aCmdNumber == cFNNumbers;
      }
      return new _TStyleCommand(document, aCmdNumber, theStyle);
    }
#endif

#if !defined TABLES || defined NETWP
  case cSelectAll:  // 18/10/94 Select all for TalkWrite
    if (structure->fParent == gNullCurrency)
    {
#ifdef NETWP
      TSelection oldSel = document->fSelection;
      TSelection newSel = document->StartNewSelection();
      TSelection sel = document->InitialSelection(fMainView, 0, -2);

      ReplaceObject(document->fNewSelection, sel);
      document->fSelection = oldSel;
      document->ScrollAndReset();
#else
      TSelection sel = document->GetNewSelection();

      document->SelectLevel(sel->GetSize() + 1 - sel->fBase);
#endif
      return gNoChanges;
    }
#endif
  }
  return _TSubView::DoMenuCommand(info, theCmdNumber);  // 03/10/96 [27098] not aCmdNumber

#ifdef TABLES
Rescue:
    FreeIfObject(arrayOfStyleChanges);
    ContinueFailure(&fi);
#endif
}


// ------------------------------------------------------------------------
TCommand _TBodyView::DoKeyCommand(int aKeyCode, EventInfo &info)
{
  if (aKeyCode == chReturn)
  {
#ifdef FN
    TStyleTypes kind = TBodyStructure(GetStructureReadOnly(fStructure))->GetBodyKind();

    if (kind == kNoteSet || kind == kFootnote)
      return gNoChanges;
#endif
    return DoMenuCommand(info, cParagraph);
  }

  return _TSubView::DoKeyCommand(aKeyCode, info);
}


// ------------------------------------------------------------------------
TCursorNode _TBodyView::ClickOnce(VPoint &mousePoint) // 25/07/90 - new mthd
{
  TSubView nearestView;
  long deltaMin;
  TBodyCursor myNode;
  TCursorNode subNode;
  VPoint newMouse;

  nearestView = NULL;
  deltaMin = MAXLONGINT;
  EachSubview(this, (DoToSubView)_TBodyView::TestNearestToMouse, &mousePoint,
              &newMouse, &deltaMin, &nearestView);
  myNode = new _TBodyCursor(fStructure, fIdentifier, nearestView->fStructure,
                                                                newMouse);

#ifdef TRACE
  Assert(nearestView, 445);
#endif
  subNode = nearestView->ClickOnce(newMouse);
  myNode->SetBodyItem(subNode->fCurrency);
  myNode->fSavedNode = subNode;
  return myNode;
}


// ------------------------------------------------------------------------
_TBodyCursor::_TBodyCursor(TCurrency currency, IDType identifier,
    TCurrency bodyItem, VPoint &mousePt) : (currency, identifier, mousePt)
{
  fBodyItem = bodyItem;
#ifndef ZERO_OBJ
  fSplitCursor = NULL;
#endif
}

#ifdef TRACE
// ------------------------------------------------------------------------
void _TBodyCursor::SetBodyItem(TCurrency item)
{
  fBodyItem = item;
}

// ------------------------------------------------------------------------
void _TBodyCursor::SetSplitCursor(TCursorNode cursor)
{
  fSplitCursor = cursor;
}
#endif


// ------------------------------------------------------------------------
void _TBodyCursor::FreeSplitCursor()
{
  // 10/12/90 free cursor rather than just a node to avoid losing handles
  register TCursor cursorCopy = fSplitCursor->fCursor;

  fSplitCursor = NULL;
  FreeIfObject(cursorCopy);
//  cursorCopy->Free();
}


// ------------------------------------------------------------------------
void _TBodyCursor::Copy(TCursorNode cursorNode)
{
  fBodyItem = TBodyCursor(cursorNode)->fBodyItem;
  fSplitCursor = NULL;
  _TCursorNode::Copy(cursorNode);
}


// ------------------------------------------------------------------------
bool _TBodyCursor::Equal(TCursorNode node)
{
  return (fBodyItem == TBodyCursor(node)->fBodyItem &&
                               _TCursorNode::Equal(node));
}


// ------------------------------------------------------------------------
long _TBodyCursor::DoNeedDiskSpace(long dataForkBytes)
{
  return _TCursorNode::DoNeedDiskSpace(sizeof(fBodyItem) +
              sizeof(_TCursorNode) - sizeof(_TBodyCursor) + dataForkBytes);
}


// ------------------------------------------------------------------------
void _TBodyCursor::DoWrite(int aRefNum, long remainder)
{
  _TCursorNode::DoWrite(aRefNum, sizeof(_TCursorNode));

  FWrite(aRefNum, sizeof(fBodyItem), &fBodyItem);
}


// ------------------------------------------------------------------------
void _TBodyCursor::DoRead(int aRefNum, long remainder, int version)
{
  _TCursorNode::DoRead(aRefNum, sizeof(_TCursorNode), version);

  fSplitCursor = NULL;
  FRead(aRefNum, sizeof(fBodyItem), &fBodyItem);
}


// ------------------------------------------------------------------------
_TBodyStyleStruct::_TBodyStyleStruct(TTextDocument document,
                                      TStyleTypes kind) : (document, kind)
{}


// ------------------------------------------------------------------------
void _TBodyStyleStruct::IBodyStyleStruct(TStyleTypes kind, char* name, TCurrency heading)
{
  TPartStyles partStyles;

  partStyles.fStyle = heading;
  IStyleStructure(kind, name);
  PutPartStyles(2, gZeroRect, partStyles);
  partStyles.fStyle  = 0;
  PutPartStyles(3, gZeroRect, partStyles);
}


/* ------------------------------------------------------------------------
TCurrency _TBodyStyleStruct::GetHeadingStyle()
{
  TPartStyles partStyles;
  GetPartStyles(2, gZeroRect, partStyles);
  return partStyles.fStyle;
}


// ------------------------------------------------------------------------
TCurrency _TBodyStyleStruct::GetBodyStyle()
{
  TPartStyles partStyles;
  GetPartStyles(3, gZeroRect, partStyles);
  return partStyles.fStyle;
}
*/

// ------------------------------------------------------------------------
_TBodyStyle::_TBodyStyle()
{
#ifndef ZERO_OBJ
  fDefinedInBody = 0;
  fJustify = FALSE;
  fHeadingType = kNoHeading;
  fBalanced = FALSE;
  fNewPage = FALSE;
  fBodyAlignment = 0;
  fScale = eInches;
  fRomanPages = FALSE;
#endif
  fColSepRule.fPen = kOnePtPen;
  fColSepRule.fRule = kNoRule;
  fColSepRule.fShort = FALSE; // 21/07/92 adding these gives better code!
  fHFVisibility = kHFAllPages;
  tag.fCaption = kBtmCaption;

  fDefined |= (kHasAdornment | kHasSpaceBefore |
               kHasSpaceAfter | kHasMargins);  // 25/07/90
}

typedef struct TOldBodyFlds
{
   Attributes fDefinedInBody;
   bool fJustify;
   THeadingTypes fHeadingType;
   TRuleType fColSepRule;
   bool fBalanced;
   bool fNewPage;
   int fBodyAlignment;
   TScale fScale;
   THFVisibility fHFVisibility;
   bool fRomanPages;
   TCaption fCaption;
//   int fill1;         // 26/03/92:  v2 seems to need us to read in 8 more bytes!
//   int fill2;         // 26/03/92  ... in v1 and v3 the last fld packs to 4?
} TOldBodyFlds;

// ------------------------------------------------------------------------
long _TBodyStyle::DoNeedDiskSpace(long dataForkBytes)
{
//#ifdef AUTONUM
  dataForkBytes -= (sizeof(fAutoCustom) - ((fDefinedInBody / kAutoCustomSize) & 0x1f));
//#endif
  return _TStyleFormat::DoNeedDiskSpace(dataForkBytes);
}

// ------------------------------------------------------------------------
void _TBodyStyle::DoRead(int aRefNum, long remainder, int version)
{
  // assumes nothing overrides this    
#ifdef FN
  if (version == 2)  // 26/03/92: v2 is for unreleased early versions of TW
  {
//#ifdef AUTONUM
    _TStyleFormat::DoRead(aRefNum, remainder - int(sizeof(fAutoCustom)) + 8, 2);
           // now there is extra room, read the 8 rubbish bytes into fAutoCustom
    fAutoCustom[0] = 0;
//#else
//    long pos;
//    // 31/01/92 version 1 has just fCaption, not the struct at the end
//    _TStyleFormat::DoRead(aRefNum, sizeof(_TStyleFormat), version);
//    FRead(aRefNum, sizeof(TOldBodyFlds), &fDefinedInBody);
//    GetFPos(aRefNum, pos);    // 28/3/92
//    SetFPos(aRefNum, pos + 8); // 28/3/92 resynch by 8 bytes
//#endif
  }
  else
#endif
  {
//#ifdef AUTONUM
    remainder -= sizeof(fAutoCustom);    // 14/10/94 ignore fAutoCustom field added
//#endif
    _TStyleFormat::DoRead(aRefNum, remainder, 2);     // 26/03/92
    // the inherited read - pass v=2 so TStyleFormat only has to worry about 1 & 2
//#ifdef AUTONUM
    FRead(aRefNum, (fDefinedInBody / kAutoCustomSize) & 0x1f, fAutoCustom);
//#endif
  }
}

// ------------------------------------------------------------------------
void _TBodyStyle::DoWrite(int aRefNum, long remainder)
{
//#ifdef AUTONUM
  remainder -= (sizeof(fAutoCustom) - ((fDefinedInBody / kAutoCustomSize) & 0x1f));
//#endif

  _TStyleFormat::DoWrite(aRefNum, remainder);
}

// ------------------------------------------------------------------------
void _TBodyStyle::IRes(char* &itsResource)
{
  int strOffset;

  _TStyleFormat::IRes(itsResource);

  sscanf(itsResource, " %x %d %d %d %d %x %n ",
         &fDefinedInBody, &fJustify, &fHeadingType,
         &fBalanced, &fNewPage, &tag, &strOffset);
  OffsetPtr(itsResource, strOffset);

  //  fColSepRule.fRule = kNoRule;
  //  fColSepRule.fPen = kOnePtPen;
  //  fColSepRule.fShort = FALSE; // 21/07/92 adding this gives better code!
  //  fRomanPages = FALSE;
  //  fHFVisibility = kHFAllPages;
  if (!fNewPage)
    fBodyAlignment = -2;
}


// -------------------------------------------------------------------------
bool _TBodyStyle::IsStyleMember(int matchType)
{
  return (matchType & (TStyleFormatType | TRulerDefType | TBodyStyleType)) != 0;
}


static char gStyleDlgIds[] = {
 /* kDocument */   kChapterDlgID,
 /* kChapter */    kChapterDlgID,
 /* kSection */    kChapterDlgID,
 /* kList */       kListStyleDlgID,
 /* kFigure */     kFigureDlg,
 /* kColumns */    0,
 /* kMaths */      0,
 /* kPict */       0,
 /* kText */       kTextAttrsDlgID,
 /* kWhiteSpace */ 0,
 /* kPageBreak */  0,
 /* kColBreak */   0,
 /* kHeader */     kChapterDlgID,
 /* kFooter */     kChapterDlgID,
 /* kDocTitle */   0,
 /* kChapTitle */  0,
 /* kPageNum */    0,
 /* kPageCount */  0,
 /* kCurrTime */   0,
 /* kCurrDate */   0,
 /* kContText */   0,
 /* kChapCount */  0,
 /* kPageFiller */ 0,               // 17/06/92
 /* kNoteSet */    kTextAttrsDlgID, // 17/06/92 so can delete changes
 /* kFootnote */   kTextAttrsDlgID, // 17/06/92
 /* kMatrix */     0,
};

// -------------------------------------------------------------------------
int _TBodyStyle::GetChangeDlg(TStyleTypes theType)
  // 18/06/92
{
  return gStyleDlgIds[theType];
}


// -------------------------------------------------------------------------
int _TBodyStyle::NumOfAttrs(int ignore)
{
  if ((fDefinedInBody & ~(kHeadingChgd | (kAutoCustomSize * 31))) != 0)
    return 1;
  return _TStyleFormat::NumOfAttrs(ignore);
}


// -------------------------------------------------------------------------
void _TBodyStyle::DeleteAttribute(TStyleFormat changes, int attrNum)
// 04/01/91 at the moment delete all the attributes (but preserve AutoCustomSize)
{
  TBodyStyle(changes)->fDefinedInBody &= (kAutoCustomSize * 31); // 21/10/94 from = 0;
  _TStyleFormat::DeleteAttribute(changes, attrNum);
}


// ------------------------------------------------------------------------
//bool _TBodyStyle::AllTextAttrs()
//{
//  return (fDefinedInBody == 0 && (fDefined & kRuler) == 0);
//}


// ------------------------------------------------------------------------
bool _TBodyStyle::CanAddTabs()
{
  return FALSE;
}


// ------------------------------------------------------------------------
bool _TBodyStyle::GetNewPage(int &align)
{
  // start chapter     | fNewPage | fBodyAlignment
  //-------------------+----------+---------------
  // immediately:      | FALSE    |   -2 (or 0)
  // on next page:     | TRUE     |    0
  // on rt hand page:  | TRUE     |    1
  // on lt hand page:  | TRUE     |   -1

  align = fBodyAlignment;
  return fNewPage;
}


/* ------------------------------------------------------------------------
THeadingTypes _TBodyStyle::GetHeadingType()
{
  return fHeadingType;
}


// ------------------------------------------------------------------------
bool _TBodyStyle::GetJustify()
{
  return fJustify;
}


// ------------------------------------------------------------------------
bool _TBodyStyle::GetBalanced()
{
  return fBalanced;
}


// ------------------------------------------------------------------------
char _TBodyStyle::GetBullet()
{
  return fBullet;
}


// ------------------------------------------------------------------------
TRuleType _TBodyStyle::GetColSepRule()
{
  return fColSepRule;
}


// ------------------------------------------------------------------------
THFVisibility _TBodyStyle::GetHFVisibility()
{
  return fHFVisibility;
}
*/

// ------------------------------------------------------------------------
int _TBodyStyle::GetHeadingWidth(int containerWidth, VRect &ruleWidths)
{
  if (fHeadingType == kNoHeading || fHeadingType == kColHeading)
    return GetColumnWidth(containerWidth, ruleWidths, 0);
  // backwards is a bit of a waste of time, since this never gets called with
  // kNoHeading & GetColumnWidth ignores backwards if kColHeading

  return FixRound((fHeadingType == kFullHeading ?
              GetWidth(containerWidth) - ruleWidths.right :
              PFTabInfo(At(1))->fStop - GetLeftMargin()) - ruleWidths.left);
              // 07/09/90 - ruleWidths.left instead of + ruleWidths.left
}


// ------------------------------------------------------------------------
Fixed _TBodyStyle::GetSideSep()
{
  return (fHeadingType == kSideHeading ? abs(PFTabInfo(At(2))->fStop - PFTabInfo(At(1))->fStop) : 0);
}


// ------------------------------------------------------------------------
Fixed _TBodyStyle::GetFxColWidth(int containerWidth, VRect &ruleWidths, int backwards)
{
  int numCols;
  Fixed bodyWidth = GetWidth(containerWidth) - ruleWidths.left - ruleWidths.right;
  Fixed lm = GetLeftMargin();
  
  // in-line: bodyWidth = GetBodyWidth(containerWidth, ruleWidths);
  if (fHeadingType == kSideHeading)
    bodyWidth += lm - PFTabInfo(At(2))->fStop;
  else
  {
    Fixed indent = GetIndentation();

#ifdef FN
    if (backwards)    // 19/07/94 treat indentation on RHS for fns
    {
      Fixed rm = GetRightMargin();

      if (indent > rm)
        bodyWidth += rm - indent;
    }
    else
#endif
    {
      if (indent > lm)
        bodyWidth += lm - indent;
    }
  }
  numCols = GetTotalColumns();
  if (numCols == 1)
    return bodyWidth;

  return (bodyWidth - (numCols - 1) * GetGutterWidth()) / numCols;
}

// ------------------------------------------------------------------------
int _TBodyStyle::GetColumnWidth(int containerWidth, VRect &ruleWidths, int backwards)
{
  return FixRound(GetFxColWidth(containerWidth, ruleWidths, backwards));
}


// ------------------------------------------------------------------------
Fixed _TBodyStyle::GetColumnLM(int containerWidth, int colNum, VRect &ruleWidths,
                                                             int backwards)
{
  int numCols;
  Fixed offset;

  offset = ruleWidths.left;
  if (fHeadingType == kSideHeading)
    offset += PFTabInfo(At(2))->fStop - GetLeftMargin();
  else if (!backwards)
    offset += Max(0, GetIndentation() - GetLeftMargin()); // 8/4/92 + fn1

  numCols = GetTotalColumns();
  if (numCols == 1)
    return offset;

  return offset +
    (GetFxColWidth(containerWidth, ruleWidths, backwards) + GetGutterWidth()) * (colNum - 1);
}


// ------------------------------------------------------------------------
Fixed _TBodyStyle::GetColumnRM(int containerWidth, int colNum, VRect &ruleWidths,
                                                             int backwards)
{
  Fixed offset = ruleWidths.right;
  int numCols;

#ifdef FN
  if (backwards)
    offset += Max(0, GetIndentation() - GetRightMargin());  // 19/07/94 add bwds for fns
#endif
  numCols = GetTotalColumns();
  if (numCols == 1)               // or (numCols == colNum) ?
    return offset;

  return offset +
       (GetFxColWidth(containerWidth, ruleWidths, backwards) + GetGutterWidth()) *
                            (numCols - colNum);
}


// ------------------------------------------------------------------------
Fixed _TBodyStyle::GetHeadingLM(int containerWidth, VRect &ruleWidths)
{
  return ruleWidths.left;
}


// ------------------------------------------------------------------------
Fixed _TBodyStyle::GetHeadingRM(int containerWidth, VRect &ruleWidths)
{
  Fixed  GetHeadingRM_r;

  if (fHeadingType == kSideHeading)
    GetHeadingRM_r = ToFixed(containerWidth) - (PFTabInfo(At(1)))->fStop + ruleWidths.right - GetRightMargin();
  else if (fHeadingType == kFullHeading)
    GetHeadingRM_r = ruleWidths.right;
  else
    GetHeadingRM_r = GetColumnRM(containerWidth, 1, ruleWidths, 0);
         // backwards not needed as cannot select heading for a footnote

  return(GetHeadingRM_r);
}


// ------------------------------------------------------------------------
void _TBodyStyle::Copy(TRulerDef newStyle)
{ // new 07/09/90

  _TStyleFormat::Copy(newStyle);

  if (newStyle->IsStyleMember(TBodyStyleType))           // 01/04/92
    memcpy(((char *)newStyle) + sizeof(_TStyleFormat),   // to newStyle
         ((char *)this) + sizeof(_TStyleFormat),         // from self
         sizeof(_TBodyStyle) - sizeof(_TStyleFormat));
}


// ------------------------------------------------------------------------
void _TBodyStyle::ApplyOverride(TRulerDef derivative, TCurrency currency, bool applyRuler)
{
  bool isBodyStyle = derivative->IsStyleMember(TBodyStyleType);

  if (isBodyStyle)
  {
    if (TBodyStyle(derivative)->fDefinedInBody & kBalanced)
    {
      fDefinedInBody |= kBalanced;
      fBalanced = TBodyStyle(derivative)->fBalanced;
    }

    if (TBodyStyle(derivative)->fDefinedInBody & kJustify)
    {
      fDefinedInBody |= kJustify;
      fJustify = TBodyStyle(derivative)->fJustify;
    }

    if (TBodyStyle(derivative)->fDefinedInBody & kColSepRule) // 29/05/90
    {
      fDefinedInBody |= kColSepRule;
      fColSepRule = TBodyStyle(derivative)->fColSepRule;
    }

    if (TBodyStyle(derivative)->fDefinedInBody & kHeadingType)
    {
      fDefinedInBody |= kHeadingType;
      fHeadingType = TBodyStyle(derivative)->fHeadingType;
      if (TBodyStyle(derivative)->fDefinedInBody & kHeadingChgd)
        fDefinedInBody |= kHeadingChgd;
    }

    if (TBodyStyle(derivative)->fDefinedInBody & kPageAlign)
    {
      fDefinedInBody |= kPageAlign;
      fBodyAlignment = TBodyStyle(derivative)->fBodyAlignment;
      fNewPage = TBodyStyle(derivative)->fNewPage;
    }

    if (TBodyStyle(derivative)->fDefinedInBody & kHFVisibility) // 07/09/90
    {
      fDefinedInBody |= kHFVisibility;
      fHFVisibility = TBodyStyle(derivative)->fHFVisibility;
    }

    if (TBodyStyle(derivative)->fDefinedInBody & kRomanPages) // 07/09/90
    {
      fDefinedInBody |= kRomanPages;
      fRomanPages = TBodyStyle(derivative)->fRomanPages;
    }

    if (TBodyStyle(derivative)->fDefinedInBody & kCaption)
    {
      fDefinedInBody |= kCaption;
      tag.fCaption = TBodyStyle(derivative)->tag.fCaption;
    }
#ifdef FN
    if (TBodyStyle(derivative)->fDefinedInBody & kEndNotes)
    {
      fDefinedInBody |= kEndNotes;
      tag.docStyle.fEndNotes = TBodyStyle(derivative)->tag.docStyle.fEndNotes;
    }
    if (TBodyStyle(derivative)->fDefinedInBody & kAutoNumber)
    {
      fDefinedInBody |= kAutoNumber;
      tag.docStyle.fAutoNumber = TBodyStyle(derivative)->tag.docStyle.fAutoNumber;
    }
    if (TBodyStyle(derivative)->fDefinedInBody & kCollector)
    {
      fDefinedInBody |= kCollector;
      tag.docStyle.fEndChapter = TBodyStyle(derivative)->tag.docStyle.fEndChapter;
    }
    if (TBodyStyle(derivative)->fDefinedInBody & kSuperior)
    {
      fDefinedInBody |= kSuperior;
      tag.fSuperior = TBodyStyle(derivative)->tag.fSuperior;
    }
#endif
//#ifdef AUTONUM
    if (TBodyStyle(derivative)->fDefined & kBullet)
      SetAutoCustom(TBodyStyle(derivative)->fAutoCustom);
//#endif
    // 16/11/93 [21115] do not copy column markers if derivative has them
    if ((TBodyStyle(derivative)->fDefinedInBody & kHeadingType) != 0)
      ReduceSize(0);
  }

  _TStyleFormat::ApplyOverride(derivative, currency, applyRuler);

// 16/11/93 [21115]  if (isBodyStyle)                                  // 10/02/91
// 16/11/93 [21115]    if ((TBodyStyle(derivative)->fDefinedInBody & kHeadingType) &&
// 16/11/93 [21115]                                    fHeadingType != kSideHeading)
// 16/11/93 [21115]      ReduceSize(0);
}


// ------------------------------------------------------------------------
bool _TBodyStyle::Match(TStyleFormat theStyle)
{
  if (_TStyleFormat::Match(theStyle) &&
      fDefinedInBody == TBodyStyle(theStyle)->fDefinedInBody &&
    ((fDefinedInBody & kBalanced) == 0 ||
        fBalanced == TBodyStyle(theStyle)->fBalanced) &&
    ((fDefinedInBody & kColSepRule) == 0 ||
        (fColSepRule.fRule == TBodyStyle(theStyle)->fColSepRule.fRule &&
                 fColSepRule.fPen == TBodyStyle(theStyle)->fColSepRule.fPen)) &&
    ((fDefinedInBody & kJustify) == 0 ||
        fJustify == TBodyStyle(theStyle)->fJustify) &&
    ((fDefinedInBody & kHeadingType) == 0 ||
        fHeadingType == TBodyStyle(theStyle)->fHeadingType) &&
    ((fDefinedInBody & kPageAlign) == 0 ||
        fBodyAlignment == TBodyStyle(theStyle)->fBodyAlignment) &&
    ((fDefinedInBody & kHFVisibility) == 0 ||
        fHFVisibility == TBodyStyle(theStyle)->fHFVisibility) &&
    ((fDefinedInBody & kRomanPages) == 0 ||
        fRomanPages == TBodyStyle(theStyle)->fRomanPages) &&
    ((fDefinedInBody & kCaption) == 0 ||
        tag.fCaption == TBodyStyle(theStyle)->tag.fCaption)
#ifdef FN
       &&
    ((fDefinedInBody & kEndNotes) == 0 ||
        tag.docStyle.fEndNotes == TBodyStyle(theStyle)->tag.docStyle.fEndNotes) &&
    ((fDefinedInBody & kAutoNumber) == 0 ||
        tag.docStyle.fAutoNumber == TBodyStyle(theStyle)->tag.docStyle.fAutoNumber) &&
    ((fDefinedInBody & kCollector) == 0 ||
        tag.docStyle.fEndChapter == TBodyStyle(theStyle)->tag.docStyle.fEndChapter) &&
    ((fDefinedInBody & kSuperior) == 0 ||
        tag.fSuperior == TBodyStyle(theStyle)->tag.fSuperior)
#endif
//#ifdef AUTONUM
       &&
    ((fDefined & kBullet) == 0 ||
        strncmp(fAutoCustom, TBodyStyle(theStyle)->fAutoCustom, sizeof(fAutoCustom)) == 0)
//#endif
        )
    return TRUE;
  return FALSE;

}


// ------------------------------------------------------------------------
void _TBodyStyle::GetDescription(char* description)
{
#ifdef TABLES
  int attr;
  char *key;
  char val[40];
  int strNum;
#endif

  _TStyleFormat::GetDescription(description);

#ifdef TABLES
  strNum = 0;
  for (attr = kBalanced; attr <= kSuperior; attr <<= 1) // 07/09/09 limit
  {
    strNum ++;
    if ((fDefinedInBody & attr) != 0)
    {
      key = GetIndString(kBodyStyleStrs, strNum);
      val[0] = 0;
      switch (strNum)  // 06/11/92 attr)
      {
      case 1:  // 06/11/92 kBalanced:
        strcpy(val, GetIndString(kOnOffStrs, int(fBalanced) + 1));
        break;

      case 2:  // 06/11/92 kColSepRule:
        strcpy(val, GetIndString(kRuleDescrs, OldRuleType(fColSepRule)));  // 20/10/91
        break;

      case 3:  // 06/11/92 kJustify:
        strcpy(val, GetIndString(kOnOffStrs, int(fJustify) + 1));
        break;

      case 4:  // 06/11/92 kHeadingType:
        if (fDefinedInBody & kCaption)
          key = NULL;                       // 06/02/91 suppress if figure
        break;

      case 5:  // 06/11/92 kPageAlign:
        break;

#ifdef FN
// fn1 must update this 06/11/92 the work done; the following 2 have no text
      case 12:  // 06/11/92 kCollector:                      // 07/09/90
      case 13:  // 06/11/92 kSuperior:
#endif
      case 6:  // 06/11/92 kHeadingChgd:
        key = NULL;
        break;

      case 7:  // 06/11/92 kHFVisibility:                    // 07/09/90
        // set up values!!!
        break;

      case 8:  // 06/11/92 kRomanPages:                      // 07/09/90
        break;

      case 9:  // 06/11/92 kCaption:
        strcpy(val, GetIndString(53, tag.fCaption));
        break;

      case 10:  // 06/11/92 kEndNotes:
        break;

      case 11:  // 06/11/92 kAutoNumber:                      // 07/09/90
        break;
      }
      AppendAttr(key, val, description);
      // prev. AppendAttr local proc
      // if (key[0] != 0 &&
      //              strlen(description) + strlen(key) + strlen(val) < 252)
      // {
      //   if (description[0] == 0)
      //     strcpy(description, key);
      //   else
      //     sprintf(description + strlen(description), " + %s", key);

      //   if (val[0] != 0)
      //       sprintf(description + strlen(description), ":%s", val);
      // }
      // end of AppendAttr() local proc
    }
  }
#endif
}


// ------------------------------------------------------------------------
bool _TBodyStyle::ChangeStyleAttrs(TTextDocument theDocument, TStyleFormat theChanges, TStyleTypes theType)
{
#if defined TABLES && !defined NETWP
  TTypeSpecDlg listDialogView;

  if (theType == kList)
  {
    // 04/06/90 - list bit is all new
    listDialogView = TTypeSpecDlg(NewTemplateWindow(kListStyleDlgID, theDocument));
    listDialogView->InitialiseTypeSpecDlg(); // set up the font lists

    listDialogView->SetAttrs(this, theChanges, TRUE);

    // listDialogView->fIdleFreq = 0; // 26/03/91 - get validating done immediately
    return PoseDialog(listDialogView, cListChanges, theDocument); // 12/05/94 [21733] cList
  }
#endif
  return _TStyleFormat::ChangeStyleAttrs(theDocument, theChanges, theType);
}

//#ifdef AUTONUM
// ------------------------------------------------------------------------
char *_TBodyStyle::GetAutoCustom()
{
  return fAutoCustom;
}

// ------------------------------------------------------------------------
void _TBodyStyle::SetAutoCustom(char *str)
{
  int aclen = 0;

  for (char *p = str; *(p++); aclen += kAutoCustomSize) {}
  fDefinedInBody = (fDefinedInBody & ~(kAutoCustomSize * 31)) | aclen;

  strncpy(fAutoCustom, str, sizeof(fAutoCustom));
}
//#endif

#ifdef TABLES

#define kColsID I_('C', 'o', 'l', 's')
#define kfSepID I_('f', 'S', 'e', 'p')
#define kpSepID I_('p', 'S', 'e', 'p')
#define kBal0ID I_('B', 'a', 'l', '0')
#define kJuscID I_('J', 'u', 's', 'c')
#define kAutoID I_('A', 'u', 't', 'o')
#define kRomeID I_('R', 'o', 'm', 'e')
#define kRuleID I_('R', 'u', 'l', 'e')
#define kPageID I_('P', 'a', 'g', 'e')
/*
static IDType gChapIDs[10] = {
         I_('C', 'o', 'l', 's'),
         I_('f', 'S', 'e', 'p'),
         I_('p', 'S', 'e', 'p'),
         I_('B', 'a', 'l', '0'),
         I_('J', 'u', 's', 'c'),
         I_('A', 'u', 't', 'o'),
         I_('R', 'o', 'm', 'e'),
         I_('R', 'u', 'l', 'e'),
         I_('P', 'a', 'g', 'e'),
         0};
*/
static IDType gLookTab[5] = {
         I_('N', 'o', 'h', 'd'),
         I_('S', 'd', 'h', 'd'),
         I_('F', 'l', 'h', 'd'),
         I_('C', 'l', 'h', 'd'),
         0};

#define gIDStTx I_('S', 't', 'T', 'x')
static int gUnitsSave;  // assumes no nested dialogue calls

// ------------------------------------------------------------------------
_TChapterDlgHpr::_TChapterDlgHpr(TDialogView theDialog,
    TStyleFormat theStyle, TStyleFormat theChanges, TStyleTypes theType) :
        (theDialog, theStyle, theChanges, theType)
{
  TArray chapterPopupArray;
  TScrollingList popup;
  Str255 theText;
  int customPoints;
  TScale scale;
  TWindow theWindow;
  TFixedPtText colSep;

  strcpy(theText, GetIndString(kSelectStrings + int(theType), 2));
  strcat(theText, GetString(kStyleAttributes));

  // 13/06/90 - get the units list with no custom field
  // 15/01/91 - get the units to use the ruler scale values
  theWindow =
    TTextDocument(theDialog->fDocument)->ActiveMainView()->GetWindow();

  customPoints = theWindow->GetScaleUnits(h, scale);

  popup = TScrollingList(theDialog->FindSubView(kpSepID));
#ifdef TRACE
  Assert(popup, 21);
#endif
  gUnitsSave = MinMax(1, scale, 7);
  popup->HaveArray(NewTextArray(32), gUnitsSave);
  colSep = TFixedPtText(theDialog->FindSubView(kfSepID));
#ifdef TRACE
  Assert(colSep, 21);
#endif
  colSep->SetLimits(720 * kFix1, 0, FALSE);           /*   1 inch???   */
  colSep->SetScale(scale, customPoints, FALSE);

  popup = TScrollingList(theDialog->FindSubView(kPageID));
#ifdef TRACE
  Assert(popup, 21);
#endif

  chapterPopupArray = NewTextArray(theType == kHeader ||
                     theType == kFooter ? mHeaderAlign : kStartChapterText);

    // 03/05/90 - if its a section delete the last 2 items in the array
  if (theType == kSection)
    chapterPopupArray->ReduceSize(2); // leave first 2 items in the array

  popup->HaveArray(chapterPopupArray, 1);

    // 31/05/90 - make the chapter/section dlog say chapter or section   
  theDialog->SetTitle(theText);       // 20/12/90 was SetTitleForDoc
  theDialog->WriteText(gIDStTx, GetIndString(kIntroTxt,
               theType <= kSection ? theType + 1 : theType - kHeader + 4));
}


// ------------------------------------------------------------------------
void _TChapterDlgHpr::WriteToDialog(TView aDialogView, CmdNumber aCmd)
{
  // TNumberText numCols;
  TControl checkBox;
  // TControl heading;
  TScrollingList popup;
  int val;
  TBodyStyle styleFormat;
  int uSave = gUnits;

  gUnits = gUnitsSave;

  _TStyleDlgHelper::WriteToDialog(aDialogView, aCmd);

  gUnits = uSave;
  styleFormat = TBodyStyle(TTypeSpecDlg(aDialogView)->fStyleFormat);
  // numCols = TNumberText(aDialogView->FindSubView(kColsID));
  // numCols->SetValue(styleFormat->GetTotalColumns(), kRedraw);
  aDialogView->WriteValueRedraw(kColsID, styleFormat->GetTotalColumns());

  SetColumns(TTextAttrsDlg(aDialogView), kRedraw);

  aDialogView->WriteCheckBox(kAutoID, styleFormat->fAutoIndent);

  checkBox = TControl(aDialogView->FindSubView(kRomeID));
#ifdef TRACE
  Assert(checkBox, 21);
#endif
  if (/* fType == kDocument ||*/ fType <= kChapter)
    checkBox->SetState(styleFormat->fRomanPages, kRedraw);
  else
    checkBox->Show(FALSE, kRedraw);

  if (fType == kHeader || fType == kFooter)
    val = styleFormat->fHFVisibility + 1;
  else
  {
    val = 1;
    switch (styleFormat->fBodyAlignment + 2)
    {
      case 1: val += 1;
      case 3: val += 1;
      case 2: val += 1;
    }
  }

  // popup = TScrollingList(aDialogView->FindSubView(kPageID));
  popup = TScrollingList(aDialogView->WriteValueNoRedraw(kPageID, val));
#ifdef TRACE
  Assert(popup, 21);
#endif
  if (fType == kDocument)
    popup->Show(FALSE, kRedraw);                      // 07/09/90
    
  // popup->SetValue(val, kDontRedraw);
  popup->ScrollListTo(val, kRedraw);
  // 21/04/95 heading = 
  aDialogView->WriteCheckBox(gLookTab[styleFormat->fHeadingType], TRUE);
  //if (heading != NULL)
  //  heading->DoChoice(heading, mRadioHit);
}


// ------------------------------------------------------------------------
void _TChapterDlgHpr::SetColumns(TTypeSpecDlg dlg, bool redraw)
{
  TFixedPtText colSep;
  TScrollingList popup;
  TControl checkBal;
  TBodyStyle bodyStyle;
  TNumberText cols;
  bool oneCol;
  TRulePicture rules;
//  bool state;

  bodyStyle = TBodyStyle(dlg->fStyleFormat);
  colSep = TFixedPtText(dlg->FindSubView(kfSepID));
#ifdef TRACE
  Assert(colSep, 21);
#endif
  popup = TScrollingList(dlg->FindSubView(kpSepID));
#ifdef TRACE
  Assert(popup, 21);
#endif

  cols = TNumberText(dlg->FindSubView(kColsID));
#ifdef TRACE
  Assert(cols, 21);
#endif

  oneCol = (cols->GetValue() == 1);

  // 11/06/90 - rules block is new
  rules = TRulePicture(dlg->FindSubView(kRuleID));
#ifdef TRACE
  Assert(rules, 21);
#endif
  rules->SetCurrentRule(bodyStyle->fColSepRule); // , kRedraw);
  rules->DimState((oneCol && (bodyStyle->fHeadingType != kSideHeading)), redraw);

  if (oneCol)
  {
    dlg->fCurrentEditText = NULL; // 15/06/90 force vals to doselectedittext to be different
    dlg->DoSelectEditText(cols);  // 14/06/90 get caret out of a deselected box
  }

  colSep->SetPoints(bodyStyle->GetGutterWidth(), redraw);
  dlg->WriteCheckBox(kJuscID, bodyStyle->fJustify);
  checkBal = dlg->WriteCheckBox(kBal0ID, bodyStyle->fBalanced);

  checkBal->DimState(oneCol, redraw);
  popup->DimState(oneCol, redraw);
  colSep->DimState(oneCol, FALSE);
}


// ------------------------------------------------------------------------
void _TChapterDlgHpr::DoChoice(TView origView, int itsChoice)
{
  TBodyStyle bodyStyle = TBodyStyle(TheDlg()->fStyleFormat);
  TBodyStyle bodyChanges = TBodyStyle(TheDlg()->fChanges);
  int itsHdType;
  int itsIdType;
  int uSave = gUnits;

  gUnits = gUnitsSave;

//  itsIdType = LookupID(origView->fIdentifier, gChapIDs);
  itsIdType = origView->fIdentifier;
  if (itsIdType == kColsID)
  {
    bodyChanges->fDefined |= kRuler;
    bodyChanges->SetTotalColumns(TNumberText(origView)->GetValue());
    ResetStyle();
    SetColumns(TheDlg(), kRedraw);    
  }
  else if (itsIdType == kfSepID)
  {
    bodyChanges->fDefined |= kRuler;
    bodyChanges->SetGutterWidth(TFixedPtText(origView)->fCurrentValue);
    ResetStyle();
  }
  else if (itsIdType == kpSepID)
  {
    gUnits = gUnitsSave = TScrollingList(origView)->GetCurrentItem();
    ResetStyle();
  }
  else if (itsIdType == kBal0ID)
  {
    bodyChanges->fDefinedInBody |= kBalanced;
    bodyChanges->fBalanced = TCheckBox(origView)->IsOn();
    ResetStyle();
  }
  else if (itsIdType == kJuscID)
  {
    bodyChanges->fDefinedInBody |= kJustify;
    bodyChanges->fJustify = TCheckBox(origView)->IsOn();
    ResetStyle();
  }
  else if (itsIdType == kAutoID)
  {
    fChanges->fDefined |= kAutoIndent;
    bodyChanges->fAutoIndent = TCheckBox(origView)->IsOn();
    ResetStyle();
  }
  else if (itsIdType == kRomeID)
  {
    TBodyStyle(fChanges)->fDefinedInBody |= kRomanPages;
    bodyChanges->fRomanPages = TCheckBox(origView)->IsOn();
    ResetStyle();
  }
  else if (itsIdType == kRuleID)
  {
//???    _TTextAttrsDlg::DoChoice(origView, itsChoice);
    bodyChanges->fDefinedInBody |= kColSepRule;
    bodyChanges->fColSepRule = TRulePicture(origView)->GetCurrentRule();
    ResetStyle();
  }
  else if (itsIdType == kPageID)
  {
    TScrollingList list = TScrollingList(origView);
    int theVal = list->GetCurrentItem();

    if (fType == kHeader || fType == kFooter)
    {  // 07/09/90 new clause for Header/footers
      bodyChanges->fDefinedInBody |= kHFVisibility;
      bodyChanges->fHFVisibility = theVal - 1;
    }
    else
    {
      int newVal;

      bodyChanges->fDefinedInBody |= kPageAlign;
      bodyChanges->fNewPage = TRUE;
      bodyChanges->fBodyAlignment = 0;
      newVal = 0;
      switch (theVal)
      {
        case 1: bodyChanges->fNewPage = FALSE;
                newVal -= 2;
        case 2: newVal -= 1;
        case 3: newVal += 2;
        case 4: bodyChanges->fBodyAlignment = newVal - 1;
      }
    }
    ResetStyle();
  }
  else if ((itsHdType = LookupID(origView->fIdentifier, gLookTab)) >= 0)
  {
    IDType id = gLookTab[bodyStyle->fHeadingType];
    if (id != origView->fIdentifier)
    {
      TControl heading = TControl(TheDlg()->FindSubView(id));

      heading->HiliteState(FALSE, TRUE);
      bodyChanges->fDefinedInBody |= (kHeadingType | kHeadingChgd);
      bodyChanges->fHeadingType = itsHdType;
      ResetStyle();
      SetColumns(TheDlg(), TRUE);
    }
  }
  else
    _TStyleDlgHelper::DoChoice(origView, itsChoice);

  gUnits = uSave;
}
#endif

#ifdef TABLES

static IDType gFigIDs[5] = {
        I_('b', 't', 'm', '0'),
        I_('t', 'o', 'p', '0'),
        I_('L', 'e', 'f', 't'),
        I_('r', 'i', 't', 'e'),
        0};

// ------------------------------------------------------------------------
_TFigureDlgHpr::_TFigureDlgHpr(TDialogView theDialog, TStyleFormat theStyle,
                             TStyleFormat theChanges, TStyleTypes theType) :
                                  (theDialog, theStyle, theChanges, theType)
{}


// ------------------------------------------------------------------------
void _TFigureDlgHpr::DoChoice(TView origView, int itsChoice)
{
  int caption = LookupID(origView->fIdentifier, gFigIDs);

  if (caption >= 0)
  {
    TBodyStyle changes = TBodyStyle(fChanges);

    // 21/04/95 TheDlg()->WriteCheckBox(gFigIDs[TBodyStyle(TheDlg()->fStyleFormat)->tag.fCaption], FALSE);
    TControl(origView)->SetState(TRUE, kRedraw);
    changes->fDefinedInBody |= (kCaption | kHeadingType | kHeadingChgd);
                                    // why kHeadingType | kHeadingChgd ???
    changes->tag.fCaption = caption;
    changes->fHeadingType =
                 (caption >= kLeftCaption ? kSideHeading : kColHeading);
                                      // 02/04/91 kLeft or kRight caption
    ResetStyle();
  }
  else
    _TStyleDlgHelper::DoChoice(origView, itsChoice);
}


// ------------------------------------------------------------------------
void _TFigureDlgHpr::WriteToDialog(TView aDialog, CmdNumber aCmd)
{
  _TStyleDlgHelper::WriteToDialog(aDialog, aCmd);
  //for (int i = 0; i < 4; i++)
  //  aDialog->WriteCheckBox(gFigIDs[i],
  //         TBodyStyle(TTextAttrsDlg(aDialog)->fStyleFormat)->tag.fCaption == i);
  aDialog->WriteCheckBox(gFigIDs[TBodyStyle(TTextAttrsDlg(aDialog)->fStyleFormat)->tag.fCaption],
                         TRUE);
}
#endif


// ********************* Methods of TPageNumberCmd ************************
#ifdef TABLES
_TPageNumberCmd::_TPageNumberCmd(TTextDocument itsDocument,
        TMainView itsView, TCurrency itsCurrency, int itsPageNumber) :
           (cSetPageNumMenu, itsDocument, NULL, NULL)
{
  fBodyFormat = itsCurrency;
  fOldPageNumber = itsPageNumber;
  fMainView = itsView;
}


void _TPageNumberCmd::DoIt()
{
  int t;
  TBodyFormat bodyFormat = TBodyFormat(fMainView->GetFormatReadWrite(fBodyFormat));

  t = bodyFormat->fPageNumber;
  bodyFormat->fPageNumber = fOldPageNumber;
  fOldPageNumber = t;
  fMainView->RedrawHeaderFooter(3);     // 18/06/95 [26020] redraw headers and footers
  fMainView->fPages->Paginate(1, FALSE);  // get fPages page info rebuilt with new number
}


void _TPageNumberCmd::UndoIt()
{
  DoIt();
}


void _TPageNumberCmd::RedoIt()
{
  DoIt();
}
#endif

#ifdef TABLES
// ********************* Methods of TBreakCommand ************************
// added 07/09/90
_TBreakCommand::_TBreakCommand(CmdNumber itsCmdNumber,
                   TTextDocument itsDocument, TCurrency itsCurrency) :
          (itsDocument, itsCmdNumber, itsCurrency) {}


TCurrency _TBreakCommand::NewPara(TBodyStructure body, long index)
{
  TCurrency currency;
  TStructure obj;
  long oldIndex = index;   // 14/08/92 pass this so index not zeroised by InsertSubStructure

  currency = fDocument->NewCurrency(kTextStruct, obj);
  obj->InitNewStructure(fStructure, currency, gNullCurrency, kText, TRUE, NULL); // 24/03/92
  body->InsertSubStructure(0, fDocument, fStructure, currency, oldIndex);  // 14/08/92
//  PBodyItem(body->At(index < 0 ? body->GetSize() : index - 1))->fGone = TRUE; // 19/03/91
  PBodyItem(body->At(index < 0 ? body->GetSize() : index))->fGone = TRUE; // 14/08/92
                                            // 23/06/93 [20954] 2nd index for oldIndex
  return currency;
}


void _TBreakCommand::DoCommand(TSelection selection)
{
  TCursorNode anchor, activeEnd;
  TStructTypes structType;
  TStyleTypes styleType;
  TBodyStructure body;
  TCurrency currency;
  int first, last;
  long index;

  FailSpaceIsLow();
  if (CmdToStruct(fCmdNumber, styleType, structType))
  {
    TStructure subBody;

    selection->UpdateScope(NULL);
    selection->GetNodes(fStructure, anchor, activeEnd);
    body = TBodyStructure(fDocument->GetStructureReadWrite(fStructure));
    currency = TBodyCursor(anchor)->GetBodyItem();
    subBody = fDocument->GetStructureReadOnly(currency);
    index = body->FindBodyItem(currency);
    first = index;
    if (subBody->InSecondHalf(anchor->GetNext()) /* 19/03/91 || index == 1 */)
      first++;
    else
      NewPara(body, index);
    index++;
    // insert a magic pic for the break
    last = index;

    // inline InsertMagicPic(index);
    {
      TStructure obj;
      TCurrency pictStyle;

      currency = fDocument->NewCurrency(kPictStruct, obj);
      pictStyle = fDocument->GetStyleAtLevel(styleType, body->GetLevel());
      obj->InitNewStructure(fStructure, currency, pictStyle, styleType, FALSE, NULL);// 24/03/92
      body->InsertSubStructure(0, fDocument, fStructure, currency, index);
      PBodyItem(body->At(last))->fGone = TRUE;  // 14/08/92 index may be zeroised!
#ifdef DRAGDROP
      body->MarkToTop(fStructure);
#endif
      index = last + 1;  // 14/08/92
    }
    // end inline InsertMagicPic

    // 14/11/90 index is incremented by InsertMagicPic! -      index++;
    // find object after the break
    if (index <= body->fSize)
    {
      currency = body->GetBodyItem(index);             // 21/03/91 new contents
      subBody = fDocument->GetStructureReadOnly(currency);
      fNewStart = subBody->GetEnd(currency, TRUE);
    }
    else
    {
      fNewStart = NewPara(body, -1);
      last = index;
    }
    selection->fReformatType = kSelSlow;
    body->ResetCursor(anchor, first, FALSE, TRUE);     // 05/03/91 T
    body->ResetCursor(activeEnd, last, TRUE, TRUE);    // 05/03/91 T
    fDocument->ResetSelection(selection);
  }
}
#endif

#ifdef TABLES
// ------------------------------------------------------------------------
_TApplyChangesCmd::_TApplyChangesCmd(TTextDocument itsDocument, int theMenu) :
                                 (cSaveStyle, itsDocument, NULL, NULL)
{
  FailInfo fi;

  fDocument = itsDocument;
  fMenu = theMenu;
#ifndef ZERO_OBJ
  fChangesToApply  = 0;
  fUpdateStyle  = 0;
  fStyleFmt = NULL;
  fSelection = NULL;
  fSavedStyles = NULL;
#endif
  CatchFailures(&fi);
  fSavedStyles = NewList();      // 11/02/91 fSavedStyles & rescue added
  Success(&fi);
  return;

Rescue:
  _TCommand::Free();          // nothing to do in _TApplyChangesCmd::Free
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TApplyChangesCmd::Free()
{
  fDocument->CommitStyle(this); // 29/5/92
  fDocument->GetSelection(TRUE); // 29/5/92
  FreeIfObject(fStyleFmt);
  if (fSavedStyles != NULL)
    fSavedStyles->FreeList();
  _TCommand::Free();
}


// ------------------------------------------------------------------------
static void ChangesApplyOverride(TApplyChangesCmd self, int part, Rect &custom,
         TCurrency partStyle, TStyleStructure styleStructure, TMainView view, int * ignore)
{
  TPartStyles pStyles;
  TStyleFormat theStyle, theChanges, aCopy;

  styleStructure->GetPartStyles(part, custom, pStyles);
  if (pStyles.fStyle != 0)
  {
    theChanges = view->GetStyleReadWrite(partStyle);
    theStyle = view->GetStyleReadOnly(pStyles.fStyle);
    aCopy = TStyleFormat(theStyle->Clone());
    theStyle->ApplyOverride(theChanges, partStyle, TRUE);
  }
  else
  {
    pStyles.fStyle = partStyle;
    aCopy = NULL;
    styleStructure->PutPartStyles(part, custom, pStyles);
  }
  self->fSavedStyles->InsertLast(aCopy);
}


// ------------------------------------------------------------------------
void _TApplyChangesCmd::DoIt()
{
  TSelection selection;
  TLevelInfo levelInfo;
  int level;
  TStyleStructure styleStructure;
  TStyleStructure changesStructure;
  TStyleFormat styleFormat, styleChanges;
  TMainView view;
  TCurrency theStyle;
  int ignored = 0;

  selection = fDocument->GetSelection(TRUE);
  fSelection = selection;
  view = fDocument->ActiveMainView();

  // this needs to be a selection method!!!! and needs to match the menu setup
  level = selection->fPopup;
  // 18/07/93 done on next line!!!  selection->Get(level, &levelInfo);
  do
  {
    selection->Get(level, &levelInfo);
    level = level + 1;
  }
  while (levelInfo.fPart != 1 &&
             (levelInfo.fPart != 2 || levelInfo.fKind != kText)); // 03/04/91

  if (levelInfo.fKind == kText)
    level = level + fMenu - 1;
  fChangesToApply = levelInfo.fChanges;     // 03/04/91
  selection->Get(level - 1, &levelInfo);
  fLevelInfo = levelInfo;
  styleStructure = NULL;
  theStyle = levelInfo.fStyle;
  fUpdateStyle = theStyle;

  styleFormat = view->GetStyleReadWrite(theStyle);
  fStyleFmt = TStyleFormat(styleFormat->Clone());
  styleChanges = view->GetStyleReadOnly(fChangesToApply);
  styleFormat->ApplyOverride(styleChanges, theStyle, TRUE);

  changesStructure = fDocument->GetStyleReadOnly(fChangesToApply);
  styleStructure = fDocument->GetStyleReadOnly(theStyle);
  changesStructure->ForAllPartsDo(this, (DoToStyles)ChangesApplyOverride, styleStructure,
                                                                          view, &ignored);

  selection->fAppliedChgs = fChangesToApply;
  selection->fStyleToUpdate = fUpdateStyle;
  selection->ReformatAndDoMenus(kSelSaveAll);
}


// ------------------------------------------------------------------------
void _TApplyChangesCmd::DoRestoreStyle(int part, Rect &custom,
         TCurrency partStyle, TStyleStructure styleStructure,
         TMainView view, int *next)
{  
  TPartStyles pStyles;
  TStyleFormat theStyle, oldStyle, aCopy;

  styleStructure->GetPartStyles(part, custom, pStyles);
  if (pStyles.fStyle != 0)
  {
    theStyle = view->GetStyleReadOnly(pStyles.fStyle);
    oldStyle = TStyleFormat(fSavedStyles->At(*next));
    if (oldStyle != NULL)
    {
      aCopy = TStyleFormat(theStyle->Clone());
      view->SetStyle(pStyles.fStyle, oldStyle);
    }
    else
    {
      aCopy = NULL;
      pStyles.fStyle = 0;
      styleStructure->PutPartStyles(part, custom, pStyles);
    }
  }
  else
  {
    pStyles.fStyle = partStyle;
    aCopy = NULL;
    styleStructure->PutPartStyles(part, custom, pStyles);
  }
  fSavedStyles->AtPut(*next, aCopy);
  (*next)++;
}


// ------------------------------------------------------------------------
void _TApplyChangesCmd::UndoIt()
{
  TStyleStructure styleStructure;
  TStyleStructure changesStructure;
  TStyleFormat styleFormat, aCopy;
  TMainView view = fDocument->ActiveMainView();
  TCurrency theStyle;
  int next;

  theStyle = fLevelInfo.fStyle;
  styleStructure = NULL;

  styleFormat = view->GetStyleReadWrite(theStyle);
  aCopy = TStyleFormat(styleFormat->Clone());
  view->SetStyle(theStyle, fStyleFmt);
  fStyleFmt = aCopy;

  changesStructure = fDocument->GetStyleReadOnly(fChangesToApply);
  styleStructure = fDocument->GetStyleReadOnly(theStyle);
  next = 1;
  changesStructure->ForAllPartsDo(this,
       (DoToStyles)_TApplyChangesCmd::DoRestoreStyle, styleStructure, view, &next);

  fDocument->ResetSelection(fSelection);  // 10/05/94 [21726] discard any fNewSeln
  fDocument->SetTextHandler();            // 10/05/94 [21726]

  fSelection->fAppliedChgs = fChangesToApply;
  fSelection->fStyleToUpdate = fUpdateStyle;
  fSelection->ReformatAndDoMenus(kSelSaveAll);
}


// ------------------------------------------------------------------------
void _TApplyChangesCmd::RedoIt()
{
  UndoIt();
}
#endif

#ifdef TABLES
// ------------------------------------------------------------------------
_TEditStylesCmd::_TEditStylesCmd(TTextDocument itsDocument,
           TArray itsEditedStyles) : (cSaveStyle, itsDocument, NULL, NULL)
{
//  fViewConstrain = FALSE; // 28/01/94 [21368]
  fDocument = itsDocument;
  fEditedStyles = itsEditedStyles;
}


// ------------------------------------------------------------------------
void _TEditStylesCmd::DoFree(PEditedStyles edits)
{
  if (edits->fAction <= 0)
  {
    FreeIfObject(edits->fOverrides);
// 25/07/92 checks in DelCurr    if (edits->fNewStyle != 0)
      fDocument->DeleteCurrency(edits->fNewStyle);
  }
}


// ------------------------------------------------------------------------
void _TEditStylesCmd::Free()
{
  fDocument->CommitStyle(this); // 29/5/92
  fDocument->GetSelection(TRUE); // 29/5/92
  if (fEditedStyles != NULL)
  {
    fEditedStyles->Each(this, (DoToItem)_TEditStylesCmd::DoFree);
    FreeIfObject(fEditedStyles);
    // fEditedStyles->Free();
  }
  _TCommand::Free();
}


// ------------------------------------------------------------------------
void _TEditStylesCmd::Commit(void)
{
  ClearObject(fEditedStyles);
  // fEditedStyles->Free();
  // fEditedStyles = NULL;
  _TCommand::Commit();
}


// ------------------------------------------------------------------------
static void EditStylesApplyOverride(TObject self, int part, Rect &custom,
         TCurrency partStyle, TStyleStructure styleStructure, TMainView view, int *ignore)
{
  TPartStyles pStyles;
  TStyleFormat theStyle, theChanges;

  styleStructure->GetPartStyles(part, custom, pStyles);
  if (pStyles.fStyle != 0)
  {
    theChanges = view->GetStyleReadWrite(partStyle);
    theStyle = view->GetStyleReadOnly(pStyles.fStyle);
    theStyle->ApplyOverride(theChanges, partStyle, TRUE);
  }
  else
  {
    pStyles.fStyle = partStyle;
    styleStructure->PutPartStyles(part, custom, pStyles);
  }
}

// ------------------------------------------------------------------------
void _TEditStylesCmd::DoProcess(PEditedStyles edits, bool *needsReformat)
{
  TStyleStructure styleStructure;
  TStyleFormat styleFormat;
  TPartStyles partStyles;
  TDiscObject obj;
  bool b;
  TMainView mainView = fDocument->ActiveMainView();

  *needsReformat = TRUE;
  if (edits->fPart == 1 || edits->fEmphasis)
  {
    styleFormat = mainView->GetStyleReadWrite(edits->fNewStyle);
    if (edits->fEmphasis)
      b = styleFormat->MergeEmphasisAttrs(edits->fOverrides, TRUE);
    else
    {
      TStyleStructure newStruct = fDocument->GetStyleReadWrite(edits->fNewStyle);
      TStyleStructure chgStruct = fDocument->GetStyleReadWrite(edits->fBaseChanges);
      int ignored;

      styleFormat->ApplyOverride(edits->fOverrides, edits->fNewStyle, TRUE);
      chgStruct->ForAllPartsDo(this, (DoToStyles)EditStylesApplyOverride, newStruct,
                   mainView, &ignored);
    }
  }
  else
  {
    styleStructure = fDocument->GetStyleReadWrite(edits->fNewStyle);
    styleStructure->GetPartStyles(edits->fPart, edits->fCustom, partStyles);
    if (partStyles.fStyle == 0)
      partStyles.fStyle = fDocument->NewCurrency(kTextStyleStruct, obj);
    styleFormat = mainView->GetStyleReadWrite(partStyles.fStyle);
    styleFormat->ApplyOverride(edits->fOverrides, gNullCurrency, TRUE);
    styleStructure->PutPartStyles(edits->fPart, edits->fCustom, partStyles);
  }
  edits->fOverrides = NULL;
// This call should be here, but need a fKind field in TEditedStyles ?
//  fDocument->fStyleSheet->AddStyle(edits->fName, fKind,
//                       edits->fEmphasis, edits->fNewStyle, edits->fCmdKey);
  edits->fName[0] = 0;
}


// ------------------------------------------------------------------------
void _TEditStylesCmd::DoIt()
{
  TSelection selection;
  bool needsReformat;

  selection = fDocument->GetSelection(TRUE);
  needsReformat = FALSE;
  fEditedStyles->Each(this, (DoToItem)_TEditStylesCmd::DoProcess, &needsReformat);
  if (needsReformat)
  {
    selection->fEditedStyles = fEditedStyles;
    selection->ReformatAndDoMenus(kReformatEdits);
  }
}


// ------------------------------------------------------------------------
void _TEditStylesCmd::RedoIt()
{
  UndoIt();
}


// ------------------------------------------------------------------------
void _TEditStylesCmd::UndoProcess(PEditedStyles edits, bool *needsReformat)
{
  TStyleInfo info;

  *needsReformat = edits->fBaseChanges != 0;
  info.fDocCurrency = edits->fNewStyle;
  fDocument->fStyleSheet->FindStyleInfo("", info);
  if (info.fName[0] != 0)        // found
  {
    strcpy(edits->fName, info.fName);
    info.fName[0] = 0;
    fDocument->fStyleSheet->ChangeStyleInfo("", info);       // delete it ???
  }
  else
    fDocument->fStyleSheet->AddStyle(edits->fName,
             fDocument->GetStyleReadOnly(info.fDocCurrency)->fType,
                               edits->fEmphasis, info.fDocCurrency, 0);
}


// ------------------------------------------------------------------------
void _TEditStylesCmd::UndoIt()
{
  bool needsReformat;
  TSelection selection;

  needsReformat = FALSE;
  fEditedStyles->Each(this, (DoToItem)_TEditStylesCmd::UndoProcess, &needsReformat);
  if (needsReformat)
  {
    selection = fDocument->GetSelection(FALSE);
    fDocument->ResetSelection(selection);  // 10/05/94 [21726] discard any fNewSeln
    fDocument->SetTextHandler();           // 10/05/94 [21726]
    selection->fEditedStyles = fEditedStyles;
    selection->ReformatAndDoMenus(kReformatEdits);
  }
}
#endif

// ------------------------------------------------------------------------
void _TBodyStructure::GetSelectedText(TCurrency currency, TCursorNode anchor,
                                    TCursorNode activeEnd, char* selectedTxt)
{
  FailInfo fi;

  // if the string gets too long, then fail. This gets caught in the rescue
  // bit which just exits out.  If the error/message != 0 then there was a
  // proper failure so do a ContinueFailure

  CatchFailures(&fi);
  Iterate(currency, anchor, activeEnd, TRUE, this,
                 (DoStep)_TBodyStructure::DoSelTextIteration, selectedTxt);
  Success(&fi);
//  return;
// +++++++++ Rescue ++++++++++
Rescue:
//  if ((fi.error != 0) || (fi.message != 0))
//    ContinueFailure(&fi);
  ContinueIfFail(&fi);
}
