/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "swis.h"

#include "UPagesVew.h"
#include "PPagesVew.h"

#define kSlop 40
#define kHalfVGap 90
#define kScrollEdge 16
               // minimum strip of grey at left and right of pages
// string list containing inches, centimetres, etc.
#define kShortUnitStrings 32
#define kScrollerBackGround 3
const CntlAdornment kPageFrame =
    adnLineRight | adnLineBottom | adnLineLeft | adnLineTop | adnShadow;
#define ScaleToPC(A) ((A) > 180 ? (A) - 156 : (A) + 100)

#define mvie I_('m', 'v', 'i', 'e')
#define reft I_('r', 'e', 'f', 't')
#define lscp I_('l', 's', 'c', 'p')
#define gPgSu I_('P', 'g', 'S', 'u')
#define pges I_('p', 'g', 'e', 's')
#define flft I_('f', 'h', 'o', 'r')
#define ftop I_('f', 'v', 'e', 'r')
#define frgt I_('s', 'h', 'o', 'r')
#define fbtm I_('s', 'v', 'e', 'r')
#define plft I_('p', 'h', 'o', 'r')
#define ptop I_('p', 'v', 'e', 'r')
#define prgt I_('t', 'h', 'o', 'r')
#define pbtm I_('t', 'v', 'e', 'r')
#define pght I_('p', 'g', 'h', 't')
#define pgwd I_('p', 'g', 'w', 'd')
#define rdhf I_('r', 'd', 'h', 'f')
#define rdma I_('r', 'd', 'm', 'a')
#define lrhd I_('l', 'r', 'h', 'd')
#define lrft I_('l', 'r', 'f', 't')
#define fwid I_('f', 'w', 'i', 'd')
#define pwid I_('p', 'w', 'i', 'd')
#define fhyt I_('f', 'h', 'y', 't')
#define phyt I_('p', 'h', 'y', 't')
#define Mtyp I_('M', 't', 'y', 'p')
#define rone I_('r', 'o', 'n', 'e')
#define rtwo I_('r', 't', 'w', 'o')
#define crop I_('c', 'r', 'o', 'p')
#define plim I_('p', 'l', 'i', 'm')
#define scal I_('s', 'c', 'a', 'l')
#define rflc I_('r', 'f', 'l', 'c')
#define bkfr I_('b', 'k', 'f', 'r')
#define sect I_('s', 'e', 'c', 't')
#define secs I_('s', 'e', 'c', 's')
#define scud I_('s', 'c', 'u', 'd')

// structure of data written to disc
typedef struct {
  bool sameInterior;
  bool showGuides;                // 25/06/90
  VRect margins;
  TPrint printRec;
  } TPageDiscInfo;

static int gPaperSizeBtns[] = { fwid, fhyt, 0 };
static int gDlgBtns[] = { crop, plim, bkfr, rflc, sect, 0 };

static int Div10(Fixed f)
{
  return FromFixed(f * 100);
}


// ==================== methods for TPagesView ============================
_TPagesView::_TPagesView(TDocument itsDocument, TView itsSuperView,
                 char * &itsParams) : (itsDocument, itsSuperView, itsParams)
{
#ifndef ZERO_OBJ
  fDoBoxZoom = 0;
#endif
  fUserHdMargin = fHeaderMargin;
  fUserFtMargin = fFooterMargin;
  fTotalPages = 1;
  fShowGuides = TRUE;

  // Do not Use AttachPrintHandler - that will try to check the margins
  // etc., which, if this is an old document, have not been read yet!
  fPrintHandler = new _TPagesPrintHandler(itsDocument, this, itsParams);
}


// ------------------------------------------------------------------------
void _TPagesView::DoReadData(int aRefNum, long &position)
{
  TPageDiscInfo viewInfo;
  TPagesPrintHandler pHndlr = TPagesPrintHandler(fPrintHandler);

  SetFPos(aRefNum, position);
  FRead(aRefNum, sizeof(TPageDiscInfo), &viewInfo);
  pHndlr->fSameInterior = viewInfo.sameInterior;
  fShowGuides = viewInfo.showGuides;                // 25/06/90
  memcpy(pHndlr->fHPrint, &viewInfo.printRec, sizeof(TPrint));
#ifdef TRACE
  Assert(sizeof(TPrint) == sizeof(TPrintWords), 111);  // just checking!
#endif
  if (pHndlr->fHPrint->hPages == 0) // [26024] old format (before pamphlet printing)
    THPrintWords(pHndlr->fHPrint)->features = NEWFEATURES;
//  MoveRect(pHndlr->fPageAreas.theMargins, viewInfo.margins);
  MoveRect(pHndlr->fRawMargins, viewInfo.margins);

  position += sizeof(TPageDiscInfo);
  _TMainView::DoReadData(aRefNum, position);
  fUserHdMargin = fHeaderMargin;   // 04/10/90 otherwise headers & footers
  fUserFtMargin = fFooterMargin;   // corrupted later by DoPrinterChanged!
}


// ------------------------------------------------------------------------
void _TPagesView::DoWriteIndex(int aRefNum, long &position)
{
  TPageDiscInfo viewInfo;
  TPagesPrintHandler pHndlr = TPagesPrintHandler(fPrintHandler);

  viewInfo.sameInterior = pHndlr->fSameInterior;
  viewInfo.showGuides = fShowGuides;                // 25/06/90
  memcpy(&viewInfo.printRec, pHndlr->fHPrint, sizeof(TPrint));
  if (TTextDocument(fDocument)->fMergeIndex > 0)
    viewInfo.printRec.merge = 1;   // 10/12/93 [21133] ensure no merge when printed
//  MoveRect(viewInfo.margins, pHndlr->fPageAreas.theMargins);
  MoveRect(viewInfo.margins, pHndlr->fRawMargins);

  SetFPos(aRefNum, position);          // needed?
  FWrite(aRefNum, sizeof(TPageDiscInfo), &viewInfo);
  position += sizeof(TPageDiscInfo);
  _TMainView::DoWriteIndex(aRefNum, position);
}


// ------------------------------------------------------------------------
void _TPagesView::DoNeedDiskSpace(long &dataForkBytes)
{
  dataForkBytes += sizeof(TPageDiscInfo);
  _TMainView::DoNeedDiskSpace(dataForkBytes);
}


// ------------------------------------------------------------------------
void _TPagesView::GetPaperArea(int page, VRect &paperArea)
{
  TPagesPrintHandler(fPrintHandler)->GetPaperArea(page, paperArea);
}


// ------------------------------------------------------------------------
//void _TPagesView::GetPageSize(VPoint &pageSize)
//{
//  Rect aRect;

//  TStdPrintHandler(fPrintHandler)->_TStdPrintHandler::ZoomARect(aRect,
//           TStdPrintHandler(fPrintHandler)->fPageAreas.theInterior);

//  RectSizeToPt(aRect, pageSize);
//}


// ------------------------------------------------------------------------
void _TPagesView::PageInteriorChanged(Rect &newInterior)
{
  _TMainView::PageInteriorChanged(newInterior);

  fOldHeaderMargin = fHeaderMargin;
  fOldFooterMargin = fFooterMargin;
}


// ------------------------------------------------------------------------
void _TPagesView::SetScaleOrigins(int pageNum)
{
  TPagesPrintHandler(fPrintHandler)->SetScaleOrigins(pageNum);
}


// ------------------------------------------------------------------------
void _TPagesView::DoPrinterChanged(void)
{
  if (fPrintHandler != NULL)
  {
    // 24/08/95 [26020] ensure warning given if margin size reduced below existing max content
    if (fHeaderMaxSize <= fHeaderMargin)
      fHeaderMaxSize = fUserHdMargin;
    fHeaderMargin = fUserHdMargin;

    if (fFooterMaxSize > fUserFtMargin)    // < fFooterMargin) // 24/08/95 [26020] do for footers
      fFooterMaxSize = fUserFtMargin;
    fFooterMargin = fUserFtMargin;
  }

  _TMainView::DoPrinterChanged();
  if (fPrintHandler != NULL && (fOldHeaderMargin != fHeaderMargin ||
       fOldFooterMargin != fFooterMargin ||
       TTextDocument(fDocument)->fLRHeaderFooterChg))
  {
    // 19/06/91 pass unzoomed value
    PageInteriorChanged(TStdPrintHandler(fPrintHandler)->fPageAreas.theInterior);
    DoPagination();  // 12/09/90 ????
  }
  DoChoice(this, mPrinterChanged);
}


// ------------------------------------------------------------------------
void _TPagesView::ShowReverted()
{
  // 26/07/90 - new mac method
  fHLDesired = HLOn;
  DoPagination();
  // 10/06/95 moved up: fHLDesired = HLOn;
}


// ------------------------------------------------------------------------
void _TPagesView::DoPagination()
{
  int startPage, endPage;
  int strips = (fPrintHandler != NULL ?
                 TPagesPrintHandler(fPrintHandler)->fPageStrips.v : 0);

  _TMainView::DoPagination();
  if (GetVisiblePageRange(startPage, endPage)) // 29/01/93 [20604] from if (Focus())
  {
    //                     Rect aRect;
    // 29/01/93 [20604]    GetVisibleRect(aRect);
    // 29/01/93 [20604]    GetPageRange(aRect, startPage, endPage);

    // 08/11/93 [21108] old views left around after window resize changes number of strips
    if (fPrintHandler != NULL && TPagesPrintHandler(fPrintHandler)->fPageStrips.v != strips)
      DeleteSubViews();

    MakeViewsForPages(startPage, endPage);
  }
}


// ------------------------------------------------------------------------
void _TPagesView::AdjustSize(void)
{
  VPoint newSize;
  int oldPageTotal;
  VRect rectToInval;
  int invalPage;
  int oldWidth;
  TWindow window;

  newSize = fSize;
  invalPage = fSize.v;
  oldWidth = fSize.h;
  oldPageTotal = fTotalPages;
  fTotalPages = GetPageMax();
  ComputeSize(newSize);
  if ((newSize.h != oldWidth
      // 07/03/96 when going between 1 and 2 column layout - do before resize (which may scroll)
      && (!gPrinting && oldPageTotal != fTotalPages && (oldPageTotal == 1 || fTotalPages == 1) &&
           (window = GetWindow()) != NULL ? (window->ForceRedraw(), TRUE) : TRUE)
       ) || newSize.v != invalPage)
  {
    Resize(newSize.h, newSize.v, !gPrinting);
    // 09/06/95 [26012] need to refresh when >2 pages deleted in 2-col format
    if (oldPageTotal > fTotalPages && !Odd(fTotalPages))
      invalPage = newSize.v;
    else if (oldPageTotal >= fTotalPages || Odd(oldPageTotal))
    {
      DoPagination();
      invalPage = 0;
    }
  }
  else if (oldPageTotal == fTotalPages)
    invalPage = 0;
  if (invalPage)
  {
    // invalidate bottom right page area, (off view if only 1 col of pages)
    Pt2VRect(gZeroVPt,
               TPagesPrintHandler(fPrintHandler)->fViewPerPage, rectToInval);
    OffsetRect(rectToInval, rectToInval.right, invalPage - rectToInval.bottom);
    InvalidVRect(rectToInval);
    DoPagination();   // 20/11/92 force views to be made
  }
  if (oldPageTotal != fTotalPages)
    DoChoice(this, mPageTotalChanged);
  SetScaleOrigins(TPagesPrintHandler(fPrintHandler)->fActivePage);
}


// ------------------------------------------------------------------------
void _TPagesView::Locate(VCoordinate h, VCoordinate v, bool invalidate)
{
  VCoordinate oldLoc = fLocation.h;

  _TMainView::Locate(h, v, invalidate && !gPrinting);
                     // 18/06/90 do not force redraw on Locate for printing
  if (h != oldLoc)
    SetScaleOrigins(TPagesPrintHandler(fPrintHandler)->fActivePage);
}


// ------------------------------------------------------------------------
void _TPagesView::SetMagnification(Fixed factor)
{
  TWindow window;

  if (!gPrinting && (window = GetWindow()) != NULL)
    window->ForceRedraw();  // 15/06/90 do not force redraw on zoom for printing

  _TMainView::SetMagnification(factor);
  TPagesPrintHandler(fPrintHandler)->SetMagnification(factor);
  //if (fSuperView != NULL && !gPrinting)
  //  fSuperView->ForceRedraw();
  //                   // 15/06/90 do not force redraw on zoom for printing
}

#ifdef TABLES
// ------------------------------------------------------------------------
void _TPagesView::DoBoxZoom(int setOn)
// 13/10/92 param changed to int - now holds id of cursor
{
  fDoBoxZoom = setOn;
}
#endif

#if defined TABLES || defined DRAWSAVE
// ------------------------------------------------------------------------
TView _TPagesView::DoHandleCursor(VPoint &theMouse)
{
  if (fDoBoxZoom)
    return NULL;
  return _TMainView::DoHandleCursor(theMouse);
  //Point qdPoint;

  //return (fDoBoxZoom && Focus() && 
  //             (ViewToQDPt(theMouse, qdPoint), GetPointerShape(qdPoint)) ?
  //                            this : _TMainView::HandleCursor(theMouse));
}
#endif

// ------------------------------------------------------------------------
int _TPagesView::GetPointerShape(Point &localPoint)
{
#if defined TABLES || defined DRAWSAVE
  return (fDoBoxZoom ? InPage(localPoint) : 0);
    // (SetCursor(GetCursor(fDoBoxZoom /* crossCursor */))) : FALSE);
#else
  return FALSE;
#endif
}


// ------------------------------------------------------------------------
void _TPagesView::ScrollToPage(int page)
{
//  VRect pageExterior;
  TScroller scroller;

//  GetPaperArea(page, pageExterior);
  scroller = GetScroller(TRUE);
//  if (scroller != NULL)
//    scroller->ScrollBy(0, pageExterior.top - scroller->GetTranslation(v), kRedraw);
//    // 22/09/93 [21050] scroller->ScrollTo(pageExterior.left, pageExterior.top, kRedraw);
  if (scroller != NULL & fPrintHandler != NULL)
    fPrintHandler->ScrollToInterior(scroller, page);
}


// ------------------------------------------------------------------------
Fixed _TPagesView::SetHeaderFooter(Fixed newMargin, bool header)
{
  Fixed oldHeader;

  if (header)
  {
    oldHeader = fUserHdMargin;
    fOldHeaderMargin = fHeaderMargin;
    fUserHdMargin = newMargin;
  }
  else
  {
    oldHeader = fUserFtMargin;
    fOldFooterMargin = fFooterMargin;
    fUserFtMargin = newMargin;
  }
  return oldHeader;
}

// ------------------------------------------------------------------------
void _TPagesView::DoSetupMenus(void)
{
  _TMainView::DoSetupMenus();

  EnableCheck(cShowGuides, TRUE, fShowGuides);
  EnableCheck(cShowPictures, TRUE, fShowPictures & 1);
#ifdef INDEX
  EnableCheck(cShowIndexEntries, TRUE, fShowPictures >> 1);
#endif
}


// ------------------------------------------------------------------------
TCommand _TPagesView::DoMenuCommand( EventInfo &info, CmdNumber aCmdNumber)
{
  if (aCmdNumber == cPrint)
    CompletePagination();                   // 04/04/91

  if (aCmdNumber >= cShowGuides && aCmdNumber <= cShowIndexEntries)
  {
    if (aCmdNumber == cShowGuides)
      fShowGuides ^= 1;
    else
      fShowPictures ^= (aCmdNumber - cShowGuides);  
                       // Xor with 1 or 2 for 131 and 132 (for show Index entries)
    ForceRedraw();
    return gNoChanges;
  }
  return _TMainView::DoMenuCommand(info, aCmdNumber);
}


// ------------------------------------------------------------------------
void _TPagesView::FitPageToScroller(VPoint &minSize)
{
  int numPages = GetPageMax();

#ifdef TRACE
  if (fTotalPages != numPages)
    SysBeep(0);
  // Assert(GetPageMax() == fTotalPages, 401);  // is call needed?
  Assert(fPages, 403);
#endif
  // 11/06/95 open up to full width if possible when paginating
  if (numPages > 1 - fPages->fPaginate && fSuperView != NULL &&
           fSuperView->fSize.h >= (minSize.h + kScrollEdge /* GetVLineThickness() */) * 2) 
  {
    minSize.h *= 2;
    numPages = ((numPages / 2) + 1);
  }
  minSize.v *= numPages;
}


// ------------------------------------------------------------------------
void _TPagesView::CalcMinSize(VPoint &minSize)
{
  minSize = fPrintHandler->fViewPerPage;
  FitPageToScroller(minSize);
}


// ------------------------------------------------------------------------
void _TPagesView::GetPrintExtent(VRect &printExtent)
{
  printExtent.top = printExtent.left = 0;
  _TPagesView::CalcMinSize(*((VPoint *)&printExtent.bottom));
}

// ------------------------------------------------------------------------
void _TPagesView::GetPageRange(Rect &area, int &startPage, int &endPage)
{
  TPagesPrintHandler(fPrintHandler)->DoGetPageRange(area, startPage, endPage);
}


// ------------------------------------------------------------------------
int _TPagesView::InPage(Point &thePoint)
{
  // Point strips;
  Rect pageInterior;
  int startPage;
  int endPage;

  Pt2Rect(thePoint, thePoint, pageInterior);
  GetPageRange(pageInterior, startPage, endPage);
  if (startPage != endPage && thePoint.h > fPrintHandler->fViewPerPage.h)
    startPage++;
  //  DoCalcPageStrips(strips);
  //  page = thePoint.v / fPrintHandler->fViewPerPage.v + 1;
  //  if (strips.v == 2)
  //    page = Max(1, (page * 2) - 2 + (thePoint.h > fPrintHandler->fViewPerPage.h));
  fDownPage = startPage;
  GetPaperArea(startPage, pageInterior);
  return (PtInVRect(thePoint, pageInterior) ? fDoBoxZoom : 0);
}


// ------------------------------------------------------------------------
void _TPagesView::DrawAdornment(Rect &area)
{
  int page;
  int startPage;
  int endPage;
  Rect aRect;

  _TMainView::DrawAdornment(area);
  if (fShowGuides && !gPrinting)
  {
    GetPageRange(area, startPage, endPage);
    PenNormal();
    PenPat(kLtGreyPat);
    for (page = startPage; page <= endPage; page++)
    {
      GetPageInterior(page, aRect);
      // 01/05/90 to avoid clashes with adorn
      // InsetRect(aRect, -GetVLineThickness(), 0); // 21/04/91 -GetHLineThickness());
      // aRect.top = aRect.top - 8;
      InsetRect(aRect, -GetVLineThickness(), -GetHLineThickness());  // 04/03/96 back again
      FrameRect(aRect);

      // See MainView::GetTrackLimits which is similar
      if (fHeaderMargin != 0)
      {
        aRect.top += FixRound(ZoomFixed(fHeaderMargin)) + 8;
        MoveTo(aRect.left, aRect.top);
        LineTo(aRect.right, aRect.top);
      }
      if (fFooterMargin != 0)
      {
        aRect.bottom -= FixRound(ZoomFixed(fFooterMargin));
        MoveTo(aRect.left, aRect.bottom);
        LineTo(aRect.right, aRect.bottom);
      }
    }
  }
}


#ifdef TABLES
// ====================== methods for TZoomTracker ======================
_TZoomTracker::_TZoomTracker(TPagesView thePagesView) :
           (cNoCommand, 0, thePagesView, thePagesView->GetScroller(TRUE))
{
  fViewConstrain = TRUE;
  fConstrainsMouse = TRUE;
  fFeedbackBox = 6;   // set to 6 for dotted rubber band 
  thePagesView->GetPaperArea(thePagesView->fDownPage, fConstrainingRect);
}


// ------------------------------------------------------------------------
TCommand _TZoomTracker::TrackMouse(TrackPhase aTrackPhase,
          VPoint &anchorPoint, VPoint &previousPoint, VPoint &nextPoint,
          bool mouseDidMove,  EventInfo &info)
{
  TCommand  TrackMouse_r;
  VRect zoomBox;

  TrackMouse_r = this;
  if (aTrackPhase == trackRelease)
  {
    Pt2VRect(anchorPoint, nextPoint, zoomBox);
    OffsetVRect(zoomBox, -(fConstrainingRect.left),-(fConstrainingRect.top));
    TPagesView(fView)->fZoomBox = zoomBox;
    fView->DoChoice(fView, mBoxZoom);
    InitCursor();
    TrackMouse_r = gNoChanges;
  }
  return(TrackMouse_r);
}


// ------------------------------------------------------------------------
void _TZoomTracker::TrackConstrain(VPoint &anchorPoint,
                                  VPoint &previousPoint, VPoint &nextPoint)
{
  PinVRect(fConstrainingRect, nextPoint);
}
#endif

// ====================== methods of TPagesPrintHandler ==================
_TPagesPrintHandler::_TPagesPrintHandler(TDocument itsDocument,
                 TView itsView, char * &itsParams) : (itsDocument, itsView)
{
//  int strOffset;

  fOwnPrintRecord = TRUE;
//  sscanf(itsParams, "%d %d %d %d %d %n", &fPageAreas.theMargins.top,
//                &fPageAreas.theMargins.left, &fPageAreas.theMargins.bottom,
//                &fPageAreas.theMargins.right, &fSameInterior, &strOffset);
//  OffsetPtr(itsParams, strOffset);
//  for (int *i = &fPageAreas.theMargins.top; i < &fPageAreas.theMargins.top + 4; )
  for (int *i = &fRawMargins.top; i < &fRawMargins.top + 4; )
    *(i++) = ReadInt(itsParams);
  fSameInterior = ReadInt(itsParams);

  fHalfGap = kHalfVGap; // half the gap between pages (3pts above and below)
#ifndef ZERO_OBJ
#ifdef TABLES
  fVScale = NULL;
#endif
  fHScale = NULL;
#endif
  fActivePage = 1;
  fStartPage = 1;
  fZoomFactor = kFix1;

  // 24/08/90 to use print driver paper if margins larger than our default
// 05/07/95 fHPrint already set by TStdPrintHandler ctor:  if (ValidatePrintRecord())
  {
    fHPrint->iDev = kNeverInitialized;     // do a quiet reset if necessary in margin checker
    MoveRectsToLandscape();
    CheckMargins(TRUE);
  }
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::Free(void)
{
  if (!fOwnPrintRecord)
  {
    fHPrint = NULL;
    fLastPrinterName = NULL;
  }
  _TStdPrintHandler::Free();
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::SetMagnification(Fixed newFactor)
{
  if (newFactor != fZoomFactor)
  {
    fZoomFactor = newFactor;
    ZoomARect(fQDPaper, fPageAreas.thePaper);
    ZoomARect(fQDInterior, fPageAreas.theInterior);
    fView->DoPrinterChanged();
  }
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::ZoomARect(Rect &dstRect, Rect &srcRect)
 {
  int *p = (int *)&dstRect;
  int *q = (int *)&srcRect;

  for (int i = 0; i < 4; i++)
    *(p++) = FixMul(*(q++), fZoomFactor) / 100;
//  dstRect.top = FixMul(srcRect.top, fZoomFactor) / 100;
//  dstRect.left = FixMul(srcRect.left, fZoomFactor) / 100;
//  dstRect.bottom = FixMul(srcRect.bottom, fZoomFactor) / 100;
//  dstRect.right = FixMul(srcRect.right, fZoomFactor) / 100;
}

// ------------------------------------------------------------------------
static void UnioniseFrame(TPagesPrintHandler self, TSubView theSubView, VRect *extension)
{
  // 16/10/96 [27110] set amount by which subviews extend outside 'normal' page interior
  if (theSubView->fLeftExtension < extension->left)
    extension->left = theSubView->fLeftExtension;
  if (theSubView->fRightExtension > extension->right)
    extension->right = theSubView->fRightExtension;
}

// ------------------------------------------------------------------------
void _TPagesPrintHandler::MakeViewsForPrinting(int aPageNumber, VRect *extension)
{
  bool oldGP = gPrinting;    // 17/11/92

  TPagesView(fView)->fPages->PurgePages(aPageNumber, aPageNumber); // 03/04/91
  gPrinting = TRUE;
  TPagesView(fView)->MakeViewsForPages(aPageNumber, aPageNumber);
  gPrinting = oldGP;
  gApplication->InvalidateFocus();  // 17/11/92

  // 16/10/96 [27110] for Word tables and overdeep footers
  if (extension != NULL)
  {
    ClearRect(*extension);
    fView->EachSubview(this, (DoToSubView)UnioniseFrame, extension);
    extension->bottom = 
            Max(0, (TPagesView(fView)->fFooterSize - TPagesView(fView)->fFooterMargin) / 10)  +
              Max(0, fPageAreas.theInterior.bottom - fPageAreas.theInk.bottom);
  }
}


// ------------------------------------------------------------------------
bool _TPagesPrintHandler::CheckMargins(int checkInk)
// all calculations performed in millipoints (without any zooming)
{
  Rect paper;
  Rect ink;
  Rect margins;
  int hMinGp = 72000;
  int vMinGp = 72000;
  int overLap;

  MoveRect(paper, fPageAreas.thePaper);
  MoveRect(ink, fPageAreas.theInk);
  MoveRect(margins, fPageAreas.theMargins);

  overLap = paper.right - paper.left - margins.left - hMinGp;
  if (overLap < 0)
    margins.left += overLap;
  margins.left = MinMax(checkInk ? -paper.left : 0, margins.left, ink.right - hMinGp - paper.left);

  overLap = paper.bottom - paper.top - margins.top - vMinGp;
  if (overLap < 0)
    margins.top += overLap;
  margins.top = MinMax(checkInk ? -paper.top : 0, margins.top, ink.bottom - vMinGp - paper.top);

  overLap = paper.right - paper.left + margins.right - margins.left - hMinGp;
  if (overLap < 0)
    margins.right -= overLap;
  if (checkInk && ink.right - paper.right - margins.right < 0)
      margins.right = -(paper.right - ink.right);

  overLap = paper.bottom - paper.top + margins.bottom - margins.top - vMinGp;
  if (overLap < 0)
    margins.bottom -= overLap;
  if (checkInk && ink.bottom - paper.bottom - margins.bottom < 0)
      margins.bottom = -(paper.bottom - ink.bottom);

  if (!EqualVRect(margins, fPageAreas.theMargins))
  {
    // 29/06/95 ???? fView->DoPrinterChanged(); // 27/3/90, in case never told of current ones
    if (checkInk && fHPrint->iDev != kNeverInitialized)  // 24/08/90
    {
      int button = Alert(phMarginsChanged, wr_wimp_EOK | wr_wimp_ECANCEL | 16);       // 20/08/90

      if (button == kCancelDlog)        // 29/06/95 allow continue & cancel
        return -1;
      if (button == kYesButton)    // continue without resetting
        return FALSE;
    }
    MoveRect(fPageAreas.theMargins, margins);
    for (int i = 0; i < 4; i++)
      ((int *)&fRawMargins)[i] = (((int *)&margins)[i] * ScaleToPC(fHPrint->scalePc)) / 100;
    return TRUE;
  }
  return FALSE;
}

#ifdef NEVER
// ------------------------------------------------------------------------
bool _TPagesPrintHandler::CheckMargins(void)
// all calculations performed in millipoints (without any zooming)
{
  Rect paper;
  Rect ink;
  Rect margins;
  int hMinGp = 72000;
  int vMinGp = 72000;
  int overLap;

  MoveRect(paper, fPageAreas.thePaper);
  MoveRect(ink, fPageAreas.theInk);
  MoveRect(margins, fPageAreas.theMargins);

  overLap = paper.right - paper.left + margins.right - margins.left - hMinGp;
  if (overLap < 0)
    margins.left += overLap;
  margins.left = MinMax(-paper.left, margins.left, ink.right - hMinGp -
                                                               paper.left);

  overLap = paper.bottom - paper.top + margins.bottom - margins.top - vMinGp;
  if (overLap < 0)
    margins.top += overLap;
  margins.top = MinMax(-paper.top, margins.top, ink.bottom - vMinGp -
                                                                paper.top);

  overLap = paper.right - paper.left + margins.right - margins.left - hMinGp;
  if (overLap < 0)
    margins.right -= overLap;
  if (ink.right - paper.right - margins.right < 0)
    margins.right = -(paper.right - ink.right);

  overLap = paper.bottom - paper.top + margins.bottom - margins.top - vMinGp;
  if (overLap < 0) {
    margins.bottom -= overLap;
  }
  if (ink.bottom - paper.bottom - margins.bottom < 0)
    margins.bottom = -(paper.bottom - ink.bottom);

  if (!EqualVRect(margins, fPageAreas.theMargins))
  {
    // 29/06/95 ???? fView->DoPrinterChanged(); // 27/3/90, in case never told of current ones
    if (fHPrint->iDev != kNeverInitialized)  // 24/08/90
    {
      int button = Alert(phMarginsChanged, wr_wimp_EOK | wr_wimp_ECANCEL | 16);          // 20/08/90

      if (button == kCancelDlog)        // 29/06/95 allow continue & cancel
        return -1;
      if (button == kYesButton)    // continue without resetting
        return FALSE;
    }
    MoveRect(fPageAreas.theMargins, margins);
    return TRUE;
  }
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
void _TPagesPrintHandler::HaveScales(TRulerScale theHScale
#ifdef TABLES
          , TRulerScale theVScale
#endif
          )
{
#ifdef TABLES
  fVScale = theVScale;
#endif
  fHScale = theHScale;
  SetScaleOrigins(fActivePage);
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::SetScaleOrigins(int page)
{
  fActivePage = page;

  if (!gPrinting && fHScale != NULL    // 17/11/92 test not printing
#ifdef TABLES
          && fVScale != NULL
#endif
          )
  {
    VRect interiorRect;

    GetInterior(page, interiorRect);

#ifdef NEVER
    // these adjustments need to match the relative displacements between
    // the scrolled-to positions of the panes and main window in the local
    // function OpenPane in UScaledWn; added 8/5/90
    OffsetVRect(interiorRect,
#ifdef TABLES
                fVScale->fSize.h == 0 ? 0 : -GetVLineThickness(),
#else
                0,
#endif
                -GetHLineThickness() * 3);   // ZZ should be unnecessary
#endif
    OffsetVRect(interiorRect, fView->fLocation.h, fView->fLocation.v);
    fHScale->SetLimits(interiorRect);
#ifdef TABLES
    fVScale->SetLimits(interiorRect);
#endif
  }
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::GetInterior(int page, VRect &pageInterior)
{
  pageInterior = fQDInterior;
  if (!Odd(page) && !fSameInterior)
  {
    int hOffset = fQDPaper.right + fQDPaper.left - pageInterior.right - pageInterior.left;

    pageInterior.left += hOffset;
    pageInterior.right += hOffset;
  }
  PageToViewRect(page, pageInterior);
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::GetPaperArea(int page, VRect &paperArea)
// 26/07/90 use line thickness instead of decipoints
{
  paperArea = fQDPaper;
  PageToViewRect(page, paperArea);
}

// ------------------------------------------------------------------------
void _TPagesPrintHandler::GetViewedInterior(int page, Rect &pageInterior, TScroller scroller)
{
  Rect nextPageInterior;

  GetInterior(page, pageInterior);
  GetInterior(fPageStrips.h == 1 ? 1 : page + 1, nextPageInterior);
                             // fPageStrips.h == 1: single page
  UnionRect(pageInterior, nextPageInterior, pageInterior);
#ifdef NETWP
  if (scroller->fWindowPtr != NULL)
  {
    wr_wimp_box *box = scroller->fWindowPtr->GetPortBox();

//    pageInterior.left += Min(0, OStoQD(box->x0) + scroller->fLocation.h - SafeLeft());
//    pageInterior.top +=
//                Min(0, ScreenHeight() - OStoQD(box->y1) + scroller->fLocation.v - SafeTop());
//    pageInterior.right = pageInterior.left + Min(OStoQD(box->x1), SafeRight()) -
//                       Max(OStoQD(box->x0) + scroller->fLocation.h, SafeLeft());
    // bottom not used (yet!)
    OffsetRect(pageInterior, Min(0, OStoQD(box->x0) + scroller->fLocation.h - SafeLeft()),
                 Min(0, ScreenHeight() - OStoQD(box->y1) + scroller->fLocation.v - SafeTop()));
  }
#endif
  InsetRect(pageInterior, -32, -32);
}

// ------------------------------------------------------------------------
void _TPagesPrintHandler::ScrollToInterior(TScroller scroller, int page)
{
  Rect pageInterior;

  GetViewedInterior(page, pageInterior, scroller);
  scroller->ScrollTo(pageInterior.left, pageInterior.top);
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::PageToViewRect(int page, VRect &viewRect)
{
  Point pagePt;

  GetPageOrigin(page, pagePt);
  OffsetVRect(viewRect, pagePt.h + GetVLineThickness(), pagePt.v);
        // the additional line thickness is needed because the print extent left
        // origin is set to the view left, rather than (correctly) being the 'white'
        // area of the page, which is one pixel in to allow for the page frame
}


#define edgeGap 40
#define adornAmt 30
// ------------------------------------------------------------------------
Fixed _TPagesPrintHandler::GetZoomToFit(VPoint &pageDisplaySize,
                                        int pagesAcross, int maxZoomFactor)
{
  Fixed vFit;
  Fixed hFit;
  VPoint paperSize;

  // 10/06/91 Return 10 times the factors
  RectSizeToPt(fPageAreas.thePaper, paperSize);
  vFit = FixDiv((pageDisplaySize.v - Max(edgeGap + adornAmt, fHalfGap * 2)) *
                             1000, paperSize.v);
  hFit = FixDiv((pageDisplaySize.h - (edgeGap + (adornAmt * pagesAcross))) *
                             1000, paperSize.h * pagesAcross);

  return Min(Max(Min(vFit, hFit), FixDiv(1, maxZoomFactor)),
                                               ToFixed(maxZoomFactor));
}


// ------------------------------------------------------------------------
int _TPagesPrintHandler::MinMaxPageNumber(int testVal)
{
  if (fStartPage == 0)   // FRIG!!! to recognise margin dlog
    return 1;
  if (TPagesView(fView)->fPages->fPaginate && testVal != MAXLONGINT)
    return testVal;    // do not do Min with pageCount
  return (TPagesView(fView)->fPages->fPageCount < 1 ? 1 :
     MinMax(1, testVal, TPagesView(fView)->fPages->fPageCount));  // Min(testVal, GetPageMax())
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::GetPageOrigin(int pageNumber, Point &origin)
{
  origin.h = fPrintExtent.left - fQDPaper.left +
             (fPageStrips.v == 1 || !Odd(pageNumber) ? 0 : fViewPerPage.h);
  origin.v = fPrintExtent.top - fQDPaper.top + fHalfGap + fViewPerPage.v *
             (fPageStrips.v == 1 ? pageNumber - 1 : pageNumber / 2);
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::CalcViewPerPage(VPoint &amtPerPage)
{
  int vLine = GetVLineThickness();

  SetVPt(amtPerPage, LengthRect(fQDPaper, h) + (3 * vLine),
                    // 12/06/95 [26013] RoundUp(..., vLine), makes h too wide &
                    // leaves a pixel gap between side-by-side pages
       LengthRect(fQDPaper, v) + Max(3 * GetHLineThickness(), fHalfGap * 2));
                         // i.e. Max(Margin dialogue depth, pages view depth)
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::CalcPageStrips(Point &pageStrips)
{
#ifdef TRACE
  pageStrips.v = (fPrintExtent.right -
      fPrintExtent.left + fViewPerPage.h - 1) / fViewPerPage.h;
  pageStrips.h = (fPrintExtent.bottom -
      fPrintExtent.top + fViewPerPage.v - 1) / fViewPerPage.v;
  Assert(pageStrips.v == fPageStrips.v && pageStrips.h == fPageStrips.h, 404);
#endif
  pageStrips.h = fPageStrips.h;
  pageStrips.v = fPageStrips.v;
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::PrintPage(int aPageNumber)
// Set up port origin to top left of paper ink,
// make necessary views for the page & 'draw' to printer.
{
  Point pageOrigin;

  GetPageOrigin(aPageNumber, pageOrigin);

  SetOrigin(pageOrigin.h /* + GetVLineThickness() ??? */, pageOrigin.v);
  // do the setorigin here, rather than set globals
  MakeViewsForPrinting(aPageNumber, NULL);
  fView->DrawContents();
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::RedoPageBreaks()
{
  VPoint oldViewPerPage; // , viewPerPage;
  Rect oldInterior;
  bool interiorChanged;

  oldViewPerPage = fViewPerPage;
  fView->DoCalcViewPerPage(fViewPerPage);
  // ?? SetPrintExtent();   // now uses fViewPerPage
  MoveRect(oldInterior, fQDInterior);
  // oldViewPerPage = fViewPerPage;
  SetPageInterior();     // sets fQDInterior for kUsualPages
  // fView->DoCalcViewPerPage(fViewPerPage);
  // fViewPerPage = viewPerPage;
  // this is what SetMargins does: SetPageInterior(kUsualPages);
  interiorChanged = !EqualRect(oldInterior, fQDInterior);
  //if (interiorChanged)
  //{
  //  // 19/06/91 pass unzoomed value; did use fQDInterior
  //  fView->PageInteriorChanged(fPageAreas.theInterior);
  //}
  //if (interiorChanged || !EqualVPt(oldViewPerPage, fViewPerPage))
  //  fView->AdjustSize();
  // in-line: SetPrintExtent();   // now uses fViewPerPage
  fView->GetPrintExtent(fPrintExtent);
  // inline original version: CalcPageStrips(fPageStrips);
  fPageStrips.v = (fPrintExtent.right -
       fPrintExtent.left + fViewPerPage.h - 1) / fViewPerPage.h;
  fPageStrips.h = (fPrintExtent.bottom -
       fPrintExtent.top + fViewPerPage.v - 1) / fViewPerPage.v;
  // move after setting up strips
  if (interiorChanged || TTextDocument(fDocument)->fLRHeaderFooterChg) // 23/06/95 [26027]
    // 19/06/91 pass unzoomed value; did use fQDInterior
    fView->PageInteriorChanged(fPageAreas.theInterior);
  if (interiorChanged || !EqualVPt(oldViewPerPage, fViewPerPage))
    fView->AdjustSize();
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::GetPageBlock(Rect &area, int &startPage, int &endPage)
// like DoGetPageRange but may return phantom pages (page 0 and pages > max)
{
  VCoordinate pageDepth;
  VRect printExtent;
  int firstPage;
  int lastPage;

  fView->GetPrintExtent(printExtent);  // if paginating this may be different to fPrintExtent
  pageDepth = fViewPerPage.v;
  firstPage = (area.top - printExtent.top) < pageDepth ? 0 :
                               ((area.top - printExtent.top) / pageDepth);
  lastPage = (area.bottom - printExtent.top) < pageDepth ? 0 :
                               (area.bottom - printExtent.top) / pageDepth;
  if (fViewPerPage.h < (printExtent.right - printExtent.left))
  {
    firstPage = firstPage * 2 - 1;
    lastPage = lastPage * 2;
  }
  startPage = firstPage + 1;
  endPage = lastPage + 1;
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::DoGetPageRange(Rect &area, int &startPage, int &endPage)
{
  GetPageBlock(area, startPage, endPage);
  if (startPage < fStartPage)
    startPage = fStartPage;
  endPage = MinMaxPageNumber(endPage);
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::DrawPrintFeedback(Rect &area)
{
  VRect testRect;
  int page;
  int startPage;
  int endPage;
  // Point oneOne;
  int lineWidth = GetVLineThickness();
  int lineHeight = GetHLineThickness();

  PenNormal();
  DoGetPageRange(area, startPage, endPage);
  for (page = startPage; page <= endPage; page++)
  {
    GetPaperArea(page, testRect);
    // extend page area by 1 or 2 pixels for shadowed border
    testRect.top -= lineHeight;
    testRect.left -= lineWidth;
    testRect.bottom += (lineHeight * 2);
    testRect.right += (lineWidth * 2);
    // test to see if adorn drawing really required ???
    // only draw if intersects, and not completely contained in interior??
    // SetPt(oneOne, 1, 1);
    fView->Adorn(testRect, kPageFrame);
  }
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::InstallPrintJob(THandler job, bool install)
{
  // new 14/06/90
  _TStdPrintHandler::InstallPrintJob(job, install);

  // 17/11/92 set gPrinting to stop AdjustSize resizing the window and resetting
  // the scroll position. Set fLastBlink and to stop selected picture
  // views redrawing themselves on the screen during zoom from 100%
  gPrinting = TRUE;

  if (install)
  {
    fSavedZoom = fZoomFactor;
    TPagesView(fView)->SetMagnification(kFix1);
    gPrinting = FALSE;
    gApplication->InvalidateFocus();
  }
  else
  {
    SetPageInterior();
                         // 15/06/90 - so RedoPageBreaks matches interiors
    TPagesView(fView)->RebuildViews(fSavedZoom);
  }
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::InvalEvenPages(void)
{
  int i;
  VRect aVRect;

  MoveRect(aVRect, fPrintExtent);
  if (fPageStrips.v == 1)
  {
    for (i = 1; i <= fPageStrips.h / 2; i++)
    {
      aVRect.top = aVRect.top + fViewPerPage.v;
      aVRect.bottom = aVRect.top + fViewPerPage.v;
      fView->InvalidVRect(aVRect);
      aVRect.top = aVRect.bottom;
    }
  }
  else
  {
    aVRect.right = aVRect.left + fViewPerPage.h;
    fView->InvalidVRect(aVRect);
  }
}


// ------------------------------------------------------------------------
TCommand _TPagesPrintHandler::ResetForPaperChange()
{
  fPrinterDev = kNeverInitialized;    // force a view resize if changed
  CheckPrinter(FALSE);
  return gNoChanges;
}

// ------------------------------------------------------------------------
void _TPagesPrintHandler::DoSetupMenus(void)
{
  _TStdPrintHandler::DoSetupMenus();
  EnableCmd(cPageSetup);
  EnableCmd(cPaperSetup);    // 21/06/94 [26024]
}


// ------------------------------------------------------------------------
void _TPagesPrintHandler::WriteToDialog(TView aDialogView, CmdNumber aCmd)
{
  if (aCmd == cPageSetup)
  {
    TMarginDialog marginView = TMarginDialog(aDialogView->FindSubView(gPgSu));
                                     // 24/07/92 margin dialogue is a subview of dialogue

    // clone self for use by the margin dialogue, and divert ReadFrom & WriteTo to clone
    if (marginView != NULL)
      marginView->DoWriteToDialog(this, aDialogView);
  }
  else
    _TStdPrintHandler::WriteToDialog(aDialogView, aCmd);
}


// ------------------------------------------------------------------------
TCommand _TPagesPrintHandler::ReadFromDialog(TView aDialogView, CmdNumber aCmd, IDType itsID)
{
  if (aCmd == cPageSetup)
  {
    TMarginDialog marginView = TMarginDialog(aDialogView->FindSubView(gPgSu));
                                            // 24/07/92 margin dialogue is a subview

    if (marginView != NULL)
      return marginView->DoReadFromDialog(this, aDialogView);
  }
  return _TStdPrintHandler::ReadFromDialog(aDialogView, aCmd, itsID);
}


// ------------------------------------------------------------------------
TCommand _TPagesPrintHandler::DoMenuCommand(EventInfo &info,
                                               CmdNumber aCmdNumber)
{
  if (aCmdNumber == cPageSetup || aCmdNumber == cPaperSetup)  // 21/06/95 [26024] test for paper
  {
    // ??? do the warning for printer driver paper different to configured value ???
    // fLastCheckedPrinter = 0;
    CheckPrinter(FALSE);          // do here as we cannot Undo it at the moment

    return DoDialogue(this, cPageSetup,
                     aCmdNumber == cPaperSetup ? kPaperDialog : kMarginsDialog, -1);
  }
  else
    return _TStdPrintHandler::DoMenuCommand(info, aCmdNumber);
}


// ==================== methods of TScaleScroller =========================
_TScaleScroller::_TScaleScroller(TDocument itsDocument, TView itsSuperView,
               char * &itsParams) : (itsDocument, itsSuperView, itsParams)
{
#ifndef ZERO_OBJ
  fHScroller = NULL;
  fVScroller = NULL;
#endif
}

#ifdef NEVER
// ------------------------------------------------------------------------
void _TScaleScroller::CentreSubview(TView theSubView, bool invalidate)
{
  VCoordinate spare =
              Max(4 * GetVLineThickness(), fSize.h - theSubView->fSize.h);

  theSubView->Locate((spare / 4) * 2, theSubView->fLocation.v, invalidate);
}
#endif


// ------------------------------------------------------------------------
TView _TScaleScroller::FindPageView()
{
  if (fSubViews != NULL)
  {
    // 15/07/94 scan through the subviews looking for the main view
    TView *aView = (TView *)(fSubViews->fPtrToList);
    TView *lastView = aView + fSubViews->fSize;

    while (aView < lastView)
      if ((*(aView++))->fIdentifier == mvie)
        return *(aView - 1);
  }
  return NULL;
}


// ------------------------------------------------------------------------
void _TScaleScroller::CalcMinSize(VPoint &minSize)
// added 8/5/90
{
  SetVPt(minSize, fSuperView->fSize.h - fLocation.h,
                              fSuperView->fSize.v - fLocation.v);
}


// ------------------------------------------------------------------------
void _TScaleScroller::SetScrollLimits(VRect &scrollLimit)
{
  VRect newLimit = scrollLimit;
  TView mainView = FindPageView();

  // the scroller is slightly wider than the pages view
  if (mainView != NULL)
  {
    // Point pageStrips;
    Point vpp;
    // int vlt4 = GetVLineThickness() * 4;

#ifdef TRACE
    Assert(fWindowPtr, 406);
#endif
//    mainView->DoCalcPageStrips(pageStrips);
    mainView->DoCalcViewPerPage(vpp);
    newLimit.top = 0;
    newLimit.left = 0;
    newLimit.bottom = mainView->fSize.v;
    newLimit.right = mainView->fSize.h + kScrollEdge * 2;  // vlt4;

    // if single strip, and more than 1 page, and two will fit: allow room for two across
    // 08/11/93 [21106] if room on screen and not already doubled 06/03/96 test for > 1 page
    //    if (pageStrips.v == 1 && pageStrips.h > 1 &&    
    if (vpp.h == mainView->fSize.h && vpp.v < mainView->fSize.v && newLimit.right +
             mainView->fSize.h <= ScreenWidth() - fWindowPtr->GetScrollBarWidth() - fLocation.h)
                      // 05/03/96  OStoQD(kScrollBarWidth), and subtract vert. scale width
      newLimit.right += mainView->fSize.h;  // 05/03/96 instead of doubling (NOT incl 4 * vlts)

    OffsetRect(newLimit, Min(newLimit.right - fSize.h, -kScrollEdge * 2 /* vlt4 */) >> 1, 0);
           // create 'negative' area allowing scroll 'backwards' of at least kScrollEdge pixels
  }

  _TScroller::SetScrollLimits(newLimit);

  if (fHScroller != NULL)
  {
    VRect hLimit;

    SetRect(hLimit, newLimit.left, 0,
                    Max(newLimit.right, newLimit.left + fHScroller->fSize.h) + fLocation.h,
                    fHScroller->fScrollLimit.bottom);
                    // need to increase by the depth of the v scroller if shown, so...
                    // 3/5/90 add in location to allow room for window to be resized outwards 
    fHScroller->SetScrollLimits(hLimit);
  }
#ifdef TABLES
  if (fVScroller != NULL)
  {
    VRect vLimit;

    SetRect(vLimit, 0, newLimit.top, fVScroller->fScrollLimit.right,
                    Max(newLimit.bottom, newLimit.top + fVScroller->fSize.v) + fLocation.v);
                    // need to increase by the width of the h scroller if shown
    fVScroller->SetScrollLimits(vLimit);
  }
#endif
}

// ------------------------------------------------------------------------
void _TScaleScroller::DoScroll(VCoordinate deltaH, VCoordinate deltaV)
{
  _TScroller::DoScroll(deltaH, deltaV);

  if (fWindowPtr != NULL)
  {
    VPoint newTranslation;

    fWindowPtr->GetTranslation(newTranslation);

    if (fHScroller != NULL)
      fHScroller->ScrollTo(newTranslation.h, 0);
#ifdef TABLES
    if (fVScroller != NULL)
      fVScroller->ScrollTo(0, newTranslation.v);
#endif
  }

#ifdef TRACE
  Assert(FindPageView(), 176);
#endif
  FindPageView()->DoPagination(); // 26/07/90
}


// ------------------------------------------------------------------------
void _TScaleScroller::SubViewChangedSize(TView theSubView, VPoint &delta)
{
  if (theSubView->fIdentifier == mvie && !gPrinting)
  {
    SetScrollLimits(gZeroRect);
#ifdef NEVER
    bool needRedraw = TRUE;  // TPagesView(theSubView)->NotPrinting();

    if (delta.h != 0)
      CentreSubview(theSubView, needRedraw);
#endif
  }
}


// ------------------------------------------------------------------------
void _TScaleScroller::Resize(VCoordinate width, VCoordinate height,
                                                            bool invalidate)
{
  VCoordinate oldWidth;
  TView mainView;

  oldWidth = fSize.h;
  _TScroller::Resize(width, height, invalidate);
  if (oldWidth != width && (mainView = FindPageView()) != NULL)
  {
    mainView->AdjustSize();
#ifdef NEVER
    CentreSubview(mainView, invalidate);
#endif
  }
}


// ------------------------------------------------------------------------
void _TScaleScroller::Draw(Rect &area)
{
  TView firstSubview = FindPageView();
  TPagesPrintHandler itsPrintHandler =
        TPagesPrintHandler(firstSubview == NULL ? NULL : firstSubview->fPrintHandler);

  if (itsPrintHandler != NULL)
  {
    int lineWidth = GetVLineThickness();
    int lineHeight = GetHLineThickness();
    int startPage;
    int endPage;
    int page;
    int leftWhiteRect;
    int rightWhiteRect;
    VRect subViewFrame;
    Rect rectToErase = area;

    firstSubview->GetFrame(subViewFrame);
    leftWhiteRect = subViewFrame.left + lineWidth;
    rightWhiteRect = subViewFrame.right - (lineWidth * 2);
    BackPat(kScrollerBackGround);
    rectToErase.left = rightWhiteRect;
    EraseRect(rectToErase);             // erase to right of view
    rectToErase.left = area.left;       // 05/03/96 0; may be at negative scroll position now
    rectToErase.right = leftWhiteRect;
    EraseRect(rectToErase);             // erase to left of view
    // set up for clearing/drawing pages strip down the middle
    rectToErase.left = leftWhiteRect;
    rectToErase.right = rightWhiteRect;
    rectToErase.top = 0;

    itsPrintHandler->GetPageBlock(area, startPage, endPage);
       // really should change area to printHandler fView coordinates but
       // only uses area top and bottom, and fView top is at location zero!
    for (page = startPage; page <= endPage; page++)
    {
      VRect testRect;

      itsPrintHandler->GetPaperArea(page, testRect);
      OffsetRect(testRect, subViewFrame.left, subViewFrame.top); // now my coords
      InsetRect(testRect, 0, -lineHeight);   // quick frig to Mode 12 (why is it leaving gap??? )
      if (testRect.top > rectToErase.top)
      {
        // need grey page divider across top of page area
        rectToErase.bottom = testRect.top;
        EraseRect(rectToErase);
        rectToErase.top = testRect.bottom;
      }
      if (page != 0 && page <= itsPrintHandler->MaxPageNumber())
      {
        // draw a normal (white) page
        PenNormal();
        if (testRect.right < rightWhiteRect)
          testRect.right =
              RoundToPixel(testRect.right, h - 4); // RoundUp(testRect.right, lineWidth);
            // 12/06/95 [26013] compensate by widening left hand page to fill gap
      }
      else
      {
        // page zero or past top page, draw in grey, and extend because no adorn on top
        testRect.right += (lineWidth * 2);
        testRect.left -= lineWidth;
      }
      EraseRect(testRect);
      BackPat(kScrollerBackGround);
    }
    rectToErase.bottom = area.bottom;
    EraseRect(rectToErase);      // fill in centre strip to bottom of area
    PenNormal();
  }
  else
    EraseRect(area);
}

// ------------------------------------------------------------------------
TCommand _TScaleScroller::DoCommandKey(int chcode, EventInfo &info)
{
  // 10/07/95 [26036] scroll to page 1 interior
  if (IsViewEnabled() && chcode == 30)  /* HOME (old action for ^^ key) */
  {
    TView firstSubview = FindPageView();
    TPrintHandler itsPrintHandler = (firstSubview == NULL ? NULL : firstSubview->fPrintHandler);

    if (itsPrintHandler != NULL)
    {
      itsPrintHandler->ScrollToInterior(this, 1);
      return gNoChanges;
    }
  }
  return _TScroller::DoCommandKey(chcode, info);
}

// ==================== methods of TMarginDialog ==========================
// ------------------------------------------------------------------------
_TMarginDialog::_TMarginDialog(TDocument itsDoc, TView itsSuperV,
                         char* &itsParams) : (itsDoc, itsSuperV, itsParams)
{
#ifndef ZERO_OBJ
  fHeaderFooter = FALSE;
#endif

// fTargetArea, fHeaderMargin and fFooterMargin are set in DoInitialisation
}


// ------------------------------------------------------------------------
void _TMarginDialog::SetTheScale(IDType fTxt, TScale theScale, int theCustomPts)
{
  TFixedPtText theFixedPtText;
  TScrollingList thePopUp;
  int menuId;
  IDType pop;

  theFixedPtText = TFixedPtText(FindSubView(fTxt));
  if (theFixedPtText != NULL)
    theFixedPtText->SetScale(theScale, theCustomPts, kDontRedraw);
  menuId = (theScale == eInches ? 1 : theScale);
  pop = (fTxt & 0xffffff) | ('p' << 24);
  thePopUp = TScrollingList(FindSubView(pop));
  if (thePopUp != NULL)
    thePopUp->HaveArray(NewTextArray(kShortUnitStrings), menuId);
}


// ------------------------------------------------------------------------
TCommand _TMarginDialog::ResetForPaperChange()
{
  return TPagesPrintHandler(fPrintHandler)->ResetForPaperChange();
}


// ------------------------------------------------------------------------
void _TMarginDialog::ReadPrintValues(TPagesPrintHandler aPrintHandler)
{
  fOriginalVals.fMargins = aPrintHandler->fRawMargins; // aPrintHandler->fPageAreas.theMargins;
  fOriginalVals.fSameInterior = aPrintHandler->fSameInterior;
  memcpy(&fOriginalVals.fPrintRec, aPrintHandler->fHPrint, sizeof(TPrint));
}


// ------------------------------------------------------------------------
void _TMarginDialog::DoWriteToDialog(TPagesPrintHandler aPrintHandler, TView aDialogView)
// called from WriteToDialog; if first time (no print handler) copies the items
// which may be changed into local variables, and installs a clone of the handler.
{
  TView pageView;
  TScale theScale;
  int theCustomPts;
  TRulerScale ruler;
  int viewId1;
  int viewId2;

  if (fPrintHandler == NULL)
  {
    // first time through - set up a clone of the handler
    ReadPrintValues(aPrintHandler);
    fOriginalVals.fHeaderMargin = TPagesView(aPrintHandler->fView)->fUserHdMargin;
    fOriginalVals.fFooterMargin = TPagesView(aPrintHandler->fView)->fUserFtMargin;
    fOriginalVals.fLeftRightHdr = TTextDocument(aPrintHandler->fDocument)->fLeftRightHdr;
    fOriginalVals.fLeftRightFtr = TTextDocument(aPrintHandler->fDocument)->fLeftRightFtr;

    // clone the print handler (carefully for failures)
    aPrintHandler = TPagesPrintHandler(aPrintHandler->Clone());
    fPrintHandler = aPrintHandler;
    aPrintHandler->fLastPrinterName = NULL;
    aPrintHandler->fHPrint = NULL;
    aPrintHandler->fView = this;
    aPrintHandler->fHalfGap = 0;
    aPrintHandler->fStartPage = 0;
    aPrintHandler->fHPrint = THPrint(NewCheckedHandle(sizeof(TPrint)));
    TDialogView(aDialogView)->SetReadWriteHandler(aPrintHandler);  // redivert msgs to clone

    // set up the unit 'popups' in a horizontal, then vertical iterations
    // note these are set up once and for all, not reset by Adjust-Cancel
    ruler = aPrintHandler->fHScale;
    aPrintHandler->fHScale = NULL;
    viewId1 = flft;
    viewId2 = frgt;

    for (int i = 0;;)
    {
      theScale = gUnits;
      theCustomPts = gCustomPoints;
      if (ruler != NULL)
      {
        theScale = ruler->GetScale();
        theCustomPts = ruler->GetCustomPoints();
      }
      SetTheScale(viewId1, theScale, theCustomPts);
      SetTheScale(viewId2, theScale, theCustomPts);
      SetTheScale(gPaperSizeBtns[i], theScale, theCustomPts); // [26024] for paper dialogue

      i++;
      if (i == 2)
        break;

      // set up for the second iteration
#ifdef TABLES
      // StartWrite uses same units in h and v directions
      ruler = aPrintHandler->fVScale;
#endif
      aPrintHandler->fVScale = NULL;
      viewId1 = ftop;
      viewId2 = fbtm;
    }
    SetIdleFreq(0);   // for cursor setting
  }

  // restore values from fOriginal, where placed by initialisation or last OK in WriteToDialog
  memcpy(aPrintHandler->fHPrint, &fOriginalVals.fPrintRec, sizeof(TPrint));
  fHeaderMargin = fOriginalVals.fHeaderMargin;
  fFooterMargin = fOriginalVals.fFooterMargin;
  aPrintHandler->fSameInterior = fOriginalVals.fSameInterior;
  // MoveRect(aPrintHandler->fPageAreas.theMargins, fOriginalVals.fMargins);
  MoveRect(aPrintHandler->fRawMargins, fOriginalVals.fMargins);
  ResetForPaperChange();

  // set up the fields in the dialogue
  aDialogView->WriteCheckBox(reft, !fOriginalVals.fSameInterior);
  aDialogView->WriteCheckBox(lscp, fOriginalVals.fPrintRec.landscape);
  {
    TControl writable; // = TControl(aDialogView->FindSubView(scal));

    // if (writable)
    //   writable->SetValue(ScaleToPC(fOriginalVals.fPrintRec.scalePc), kRedraw);
    aDialogView->WriteValueRedraw(scal, ScaleToPC(fOriginalVals.fPrintRec.scalePc));

    writable = SetDimState(scud, (fOriginalVals.fPrintRec.options & kAllowSections) == 0);
    if (writable)
      TControl(writable->fSuperView)->
                    SetValue((fOriginalVals.fPrintRec.vPages >> 2) + 1, kRedraw);
  }
  // 12/09/90 initialise the H/F check boxes
  aDialogView->WriteCheckBox(lrhd, fOriginalVals.fLeftRightHdr);
  aDialogView->WriteCheckBox(lrft, fOriginalVals.fLeftRightFtr);
  // 22/06/95 [26024] set up pamphlet and crop mark values
  aDialogView->WriteCheckBox(fOriginalVals.fPrintRec.hPages == 1 ? rone : rtwo, TRUE);
  for (int ip = 0; gDlgBtns[ip] != 0; ip++)
    aDialogView->WriteCheckBox(gDlgBtns[ip], fOriginalVals.fPrintRec.options & (1 << ip)); 

  pageView = FindSubView(pges);
  if (pageView)
    pageView->GetFrame(fTargetArea);

  ResetPrintHandler();  // sets up zoom, fixed point boxes and limits
}


// ------------------------------------------------------------------------
TCommand _TMarginDialog::DoReadFromDialog(TPagesPrintHandler aPrintHandler, TView aDialogView)
{
  TControl writable = TControl(aDialogView->FindSubView(scal));

  if (writable)
  {
    // update values not done by DoChoice before the DoSetLimitsCall
    int newScale = writable->GetValue();
    int oldScale = ScaleToPC(fOriginalVals.fPrintRec.scalePc);

    if (newScale != oldScale)
    {
      aPrintHandler->fHPrint->scalePc = newScale - 100;
      fHeaderMargin = (fHeaderMargin * oldScale) / newScale;
      fFooterMargin = (fFooterMargin * oldScale) / newScale;
    }
  }
  writable = TControl(aDialogView->FindSubView(secs));
  if ((fOriginalVals.fPrintRec.options & kAllowSections) != 0 && writable)
    aPrintHandler->fHPrint->vPages = (aPrintHandler->fHPrint->vPages & 3) |
                                          ((writable->GetValue() - 1) << 2);

  aPrintHandler->MoveRectsToLandscape();
  DoSetLimits(kRedraw);        // adjust my h/f margins if too small

  // update fOriginals with field values - most of values will have been stored by DoChoice
  ReadPrintValues(aPrintHandler);
  fOriginalVals.fHeaderMargin = fHeaderMargin;
  fOriginalVals.fFooterMargin = fFooterMargin;
  writable = TControl(aDialogView->FindSubView(lrhd));   // do not use TestCheckBox!
  if (writable)
    fOriginalVals.fLeftRightHdr = writable->IsOn();
  writable = TControl(aDialogView->FindSubView(lrft));   // do not use TestCheckBox!
  if (writable)
    fOriginalVals.fLeftRightFtr = writable->IsOn();
  return new _TMarginCommand(TTextDocument(aPrintHandler->fDocument), &fOriginalVals);
}


// ------------------------------------------------------------------------
void _TMarginDialog::DimOut(IDType id)
{
  SetDimState(id, fHeaderFooter);
}


// ------------------------------------------------------------------------
void _TMarginDialog::DoChoice(TView origView, int itsChoice)
{
  Rect rectToInval;
  Rect paper;
  IDType itsId;
  IDType currentTextId;
  Fixed itsNewValue;
  Fixed itsOldValue;

  itsId = origView->fIdentifier;
  paper = TPagesPrintHandler(fPrintHandler)->fQDPaper;
  if (itsChoice == mFixedPtTextHit)
  {
    bool pageSizeChange = FALSE;

    itsNewValue = TFixedPtText(origView)->GetPoints();
    int btnNum = LookupID(itsId, gPaperSizeBtns);

    // 27/06/95 new test for change paper height and width fields
    if (btnNum >= 0)       // itsId == fwid || itsId == fhyt)
    {
      int orientn = TPagesPrintHandler(fPrintHandler)->fHPrint->landscape == btnNum;
                                                                        // (itsId == fhyt);

      pageSizeChange = TRUE;
      itsOldValue = LengthRect(TPagesPrintHandler(fPrintHandler)->fHPrint->rPaper, orientn);
      itsNewValue = itsNewValue / 10;
      ((int *)&TPagesPrintHandler(fPrintHandler)->fHPrint->rPaper.bottom)[orientn] =
                   ((int *)&TPagesPrintHandler(fPrintHandler)->fHPrint->rPaper.top)[orientn] +
                                                                             itsNewValue;
    }
    else if (fHeaderFooter)
    {
      if (itsId == ftop)
      {
        itsOldValue = fHeaderMargin;
        fHeaderMargin = itsNewValue;
      }
      else
      // 26/04/90 must be fbtm: if (itsId == fbtm)
      {
        itsOldValue = fFooterMargin;
        fFooterMargin = itsNewValue;
      }
    }
    else
    { 
      VRect *rawMargins = &TPagesPrintHandler(fPrintHandler)->fRawMargins;
      int i;

      if (itsId == ftop)
        i = 0;
      else if (itsId == flft)
        i = 1;
      else
      {
        itsNewValue = -(itsNewValue);
        if (itsId == fbtm)
          i = 2;
        else
          i = 3;    // must be frgt
      }

      itsOldValue = ((int *)&TPagesPrintHandler(fPrintHandler)->fPageAreas.theMargins)[i] * 10;
      ((int *)&TPagesPrintHandler(fPrintHandler)->fPageAreas.theMargins)[i] = Div10(itsNewValue);
      ((int *)&TPagesPrintHandler(fPrintHandler)->fRawMargins)[i] =
            FixMul(itsNewValue, ScaleToPC(TPagesPrintHandler(fPrintHandler)->fHPrint->scalePc));
    }
    if (itsOldValue != itsNewValue)
    {
      if (pageSizeChange)  // 27/06/95 new test for change paper height and width fields
      {
        TPagesPrintHandler(fPrintHandler)->fHPrint->iDev = kExplicitPaper;
        ResetForPaperChange();
      }
      else if (fHeaderFooter)
        DoSetLimits(kDontRedraw);
      else
      {
        if (TPagesPrintHandler(fPrintHandler)->CheckMargins(FALSE) == TRUE)
          DoSetLimits(kDontRedraw);
        // TPagesPrintHandler(fPrintHandler)->SetZoomedMargins();
        TPagesPrintHandler(fPrintHandler)->SetPageInterior();
      }
      if (fTargetArea.left != fTargetArea.right)    // 22/09/95 check it has mini-page view
      {
        MoveRect(rectToInval, paper);
        PageToDialogRect(0, rectToInval);
        InvalidRect(rectToInval);
        MoveRect(rectToInval, paper);
        PageToDialogRect(1, rectToInval);
        InvalidRect(rectToInval);
      }
    }
  }
  else if (itsChoice == mCheckBoxHit)
  {
    bool viewSetting = TControl(origView)->IsOn();

    if (itsId == lscp)
    {
      // toggle landscape & redraw!!!
      TPagesPrintHandler(fPrintHandler)->fHPrint->landscape = viewSetting;
            // = !TPagesPrintHandler(fPrintHandler)->fHPrint->landscape;
      // ?? ResetForPaperChange();
      // TPagesPrintHandler(fPrintHandler)->fPrinterDev = kNeverInitialized;
      // TPagesPrintHandler(fPrintHandler)->CheckPrinter();
      TPagesPrintHandler(fPrintHandler)->SetPageInterior();
      // ResetForPaperChange();
    }
    else if (itsId == reft)
    {
      // reflect margins
      TPagesPrintHandler(fPrintHandler)->fSameInterior = viewSetting ^ 1;
      // ResetForPaperChange();   // new for margins (a reflect change may invalidate limits)
      // MoveRect(rectToInval, paper);
      // PageToDialogRect(0, rectToInval);
      // InvalidRect(rectToInval);
    }
    else
    {
      // crop marks & show margins buttons
      int maskNum = LookupID(itsId, gDlgBtns);

      if (maskNum >= 0)
      {
        TPagesPrintHandler(fPrintHandler)->fHPrint->options =
           (TPagesPrintHandler(fPrintHandler)->fHPrint->options & ~(1 << maskNum)) |
                                                             (viewSetting << maskNum);
        if (itsId == sect)
          SetDimState(scud, viewSetting ^ 1);
      }
      // ResetForPaperChange();
    }
    ResetForPaperChange();
  }
  else if (itsChoice == mRadioHit)
  {
    if (origView->fSuperView->fIdentifier == Mtyp)  // 21/06/95 [26024]
    {
      TDialogView aDlgView = TDialogView(GetDialogView());   // 24/07/92

      if (aDlgView->fCurrentEditText != NULL)
        currentTextId = aDlgView->fCurrentEditText->fIdentifier;
      else
         currentTextId = ftop;
      if (aDlgView->DeselectCurrentEditText())
      {
        fHeaderFooter = (itsId == rdhf);
#ifdef NEVER
        TPagesPrintHandler(fPrintHandler)->CheckMargins(); // sort out somewhere else!!!
#endif
        DoSetLimits(kRedraw);
        if (fHeaderFooter && (currentTextId == flft || currentTextId == frgt))
          currentTextId = ftop;
        aDlgView->SelectEditText(currentTextId /*, TRUE */);
        DimOut(flft);
        DimOut(plft);
        DimOut(frgt);
        DimOut(prgt);
        DimOut(reft);
        UpdateVRect(fTargetArea);  // 07/07/95 do full redraw
        // PenNormal();
        // DoInUpdate(fTargetArea, (DrawProc)_TMarginDialog::FramePageInterior, 1, TRUE);
                         // 03/08/92 avoid draw outside dialogue window
      }
    }
    else // a pamphlet button
    {
      if ((itsId == rtwo) == (TPagesPrintHandler(fPrintHandler)->fHPrint->hPages == 1))
      {
        TPagesPrintHandler(fPrintHandler)->fHPrint->hPages = 1 + (itsId == rtwo);
        ResetForPaperChange();
      }
    }
  }
  _TView::DoChoice(origView, itsChoice);    // 24/07/92 from _TDialogView::
  // 02/09/93 See UDialog DoChoice: if (itsChoice == mPopupHit || 
  if (itsChoice == mScrollingListAdjust || itsChoice == mScrollingListHit ||
                                                    itsChoice == mFixedPtTextHit)
    SetPageSize();
}


#if SIDEBAR == 1
#define SHOWNPAGES 1
#else
#define SHOWNPAGES 2
#endif
// ------------------------------------------------------------------------
void _TMarginDialog::ResetPrintHandler(void)
{
  VPoint pageDisplaySize;
  Fixed theZoomFactor;

  RectSizeToPt(fTargetArea, pageDisplaySize);
  if (pageDisplaySize.h != 0)
  {
    theZoomFactor = TPagesPrintHandler(fPrintHandler)->
                  GetZoomToFit(pageDisplaySize, SHOWNPAGES, 20); // 04/10/94 [23002]
    TPagesPrintHandler(fPrintHandler)->SetMagnification(theZoomFactor / 10);
  }
  DoSetLimits(kRedraw);
}

#define MilliToFixed(A) (A) * 10
// ------------------------------------------------------------------------
void _TMarginDialog::DoSize(Fixed dimension, IDType first, IDType units,
                                               IDType text, IDType scale)
{
  char param1[30];
  char param0[30];
  Str255 buffer;
  TFixedPtText theFixedPtText;
  TScrollingList thePopup;

  theFixedPtText = TFixedPtText(FindSubView(first));
  if (theFixedPtText != NULL)
  {
    CvtUnitsToStr(dimension, theFixedPtText->fScale,
                  theFixedPtText->fCustomPoints, eNoConstraint, 0, param0);
    thePopup = TScrollingList(FindSubView(units));
    if (thePopup != NULL)
    {
      thePopup->GetItemText(thePopup->GetCurrentItem(), param1);
      // stop silly values like 4c6cc being generated
      {
        int aChar = (theFixedPtText->fScale == eCiceros ? 'c' :
                       (theFixedPtText->fScale == ePicas ? 'p' : 'x'));
                                          // 'x' is impossible in a value
        if (strchr(param0, aChar) != NULL)
          param1[0] = 0;
      }
      sprintf(buffer, "%s%s", param0, param1);

      WriteText(scale, param1);
      WriteText(text, buffer);
    }
  }
}


// ------------------------------------------------------------------------
void _TMarginDialog::SetPageSize(void)
{
  Rect *paper = &TStdPrintHandler(fPrintHandler)->fPageAreas.thePaper;
  Rect *margins = &TStdPrintHandler(fPrintHandler)->fPageAreas.theMargins;
  Fixed dimension;

  dimension =
    MilliToFixed(paper->bottom - paper->top - margins->top + margins->bottom);
  if (fHeaderFooter)
    dimension = dimension - (fHeaderMargin + fFooterMargin);
  DoSize(dimension, ftop, ptop, pght, pbtm);
  DoSize(MilliToFixed(paper->right - paper->left - margins->left +
                                  margins->right), flft, plft, pgwd, prgt);
}


// ------------------------------------------------------------------------
Fixed _TMarginDialog::SetMarginBox(IDType id, Fixed itsVal, int itsMin,
                                        int itsMax, bool redraw)
// itsMin & itsMax are in millipoints; itsVal is fixed decipoints
{
  TFixedPtText theFixedPtText;
  Fixed minValue;
  Fixed maxValue;
  Fixed theValue;

  minValue = MilliToFixed(itsMin);
  maxValue = Max(MilliToFixed(itsMax - 72000), minValue);
  theValue = MinMax(minValue, itsVal, maxValue);
  theFixedPtText = TFixedPtText(FindSubView(id));
  if (theFixedPtText != NULL)
  {
    theFixedPtText->SetLimits(maxValue, minValue, TRUE);
    theFixedPtText->SetPoints(theValue, redraw);
  }
  return theValue;
}


// ------------------------------------------------------------------------
void _TMarginDialog::DoSetLimits(bool redraw)
{
  TPagesPrintHandler prHdlr = TPagesPrintHandler(fPrintHandler);
  Rect *paper = &prHdlr->fPageAreas.thePaper;
  Rect *margins = &prHdlr->fPageAreas.theMargins;
  // #1 Rect *ink = &prHdlr->fPageAreas.theInk;

  SetMarginBox(flft, MilliToFixed(margins->left), 0,  // #1 -paper->left,
                     paper->right - paper->left + margins->right, redraw);
  SetMarginBox(frgt, MilliToFixed(-margins->right), 0, // #1 paper->right - ink->right,
                     paper->right - paper->left - margins->left, redraw);

  // need to check h/f even if not editting them: if (fHeaderFooter)
  {
    Fixed theValue;
    // bool hfReset = FALSE;
    int pgDepth = paper->bottom - paper->top + margins->bottom - margins->top;

    theValue = SetMarginBox(ftop, fHeaderMargin, 0,
                         pgDepth - Div10(fFooterMargin), redraw);
    // if (fHeaderMargin != theValue)
    //   hfReset = TRUE;
    fHeaderMargin = theValue;
    theValue = SetMarginBox(fbtm, fFooterMargin, 0,
                         pgDepth - Div10(fHeaderMargin), redraw);
    fFooterMargin = theValue;
    // keep quiet if (hfReset)
  }
  if (!fHeaderFooter)
  {
    int hfMargin = Div10(fHeaderMargin + fFooterMargin);

    SetMarginBox(ftop, MilliToFixed(margins->top), 0, // #1 -paper->top,
               paper->bottom - paper->top + margins->bottom - hfMargin, redraw);
    SetMarginBox(fbtm, MilliToFixed(-margins->bottom), 0, // #1 paper->bottom - ink->bottom,
               paper->bottom - paper->top - margins->top - hfMargin, redraw);
  }

  // 21/06/95 [26024] set page dimensions
  for (int i = 1; i >= 0; i--)
  {
    SetMarginBox(gPaperSizeBtns[i],
             MilliToFixed(LengthRect(prHdlr->fHPrint->rPaper, prHdlr->fHPrint->landscape == i)),
             144000, (MAXLONGINT / 100), redraw);
    SetLimitRect(i);
  }
  // SetMarginBox(fhyt, MilliToFixed(LengthRect(*paper, landscape)), 144000,
  //                                      (MAXLONGINT / 10), redraw);

  SetPageSize();
}


// ------------------------------------------------------------------------
void _TMarginDialog::DoPrinterChanged(void)
{
  _TView::DoPrinterChanged();   // 24/07/92 from _TDialogView::
  ResetPrintHandler();
#ifdef PRO
  UpdateVRect(fTargetArea);    // less flicker
#else
  InvalidVRect(fTargetArea);
#endif
  DoSetLimits(kRedraw);
}


// ------------------------------------------------------------------------
void _TMarginDialog::GetPrintExtent(VRect &printExtent)
{
  VPoint perPage;
  int lineWidth = GetVLineThickness();
  int lineHeight = GetHLineThickness();
  
  RectSizeToPt(TPagesPrintHandler(fPrintHandler)->fQDPaper, perPage);
  perPage.h = (perPage.h + ((SHOWNPAGES + 1) * lineWidth)) * SHOWNPAGES; // 04/10/94 [23002]
  perPage.v += 3 * lineHeight;
  SetRect(printExtent, 0, 0, perPage.h, perPage.v);
  OffsetRect(printExtent, (fTargetArea.right + fTargetArea.left - perPage.h) / 2,
                          (fTargetArea.bottom + fTargetArea.top - perPage.v) / 2 + lineHeight);
#ifdef NEVER
  MoveRect(printExtent, fTargetArea);
  SetVPt(*printExtent.topLeft,
        (printExtent.right + printExtent.left - perPage.h) / 2,
        (printExtent.bottom + printExtent.top - perPage.v + (2 * lineHeight)) / 2);
  AddVPt(*printExtent.topLeft, perPage);
  *printExtent.botRight = perPage;
#endif
}


// ------------------------------------------------------------------------
void _TMarginDialog::SetLimitRect(int page)
{
  // 27/07/95 new to set up the grey rects marking the limits of the ink
  Rect *limRect = &fLimitRect[page];
  THPrint printRec = TPagesPrintHandler(fPrintHandler)->fHPrint;
  int landscape = printRec->landscape;
#ifdef TABLES
  int cropCentring[2];
#endif

  *limRect = TPagesPrintHandler(fPrintHandler)->fPageAreas.theInk;
  // if right hand of pair move ink rect left
  if (printRec->hPages > 1)
  {
    if (Odd(page))
      OffsetRect(*limRect, TPagesPrintHandler(fPrintHandler)->fPageAreas.thePaper.left -
                           TPagesPrintHandler(fPrintHandler)->fPageAreas.thePaper.right, 0);
  }
  else if ((printRec->options & kSingleSide) == 0 && !Odd(page))
                                      // page == 0 (left hand page, move ink to top right)
  {
     int adjust = LengthRect(printRec->rPaper, landscape ^ 1) -
                         LengthRect(gPrinterDetails->rPaper, landscape ^ 1);

     if (adjust != 0)  // scale down difference
     {
       adjust = (adjust * 100) / ScaleToPC(printRec->scalePc);
       OffsetRect(*limRect, adjust, 0);
    }
  }
#ifdef TABLES
  OffsetForCropMarks(printRec, cropCentring);
  OffsetRect(*limRect, Odd(page) || printRec->hPages > 1 ? -cropCentring[landscape] :
                            cropCentring[landscape], -cropCentring[landscape ^ 1]);
#endif
  TPagesPrintHandler(fPrintHandler)->ZoomARect(*limRect, *limRect);
}


// ------------------------------------------------------------------------
void _TMarginDialog::PageToDialogRect(int page, Rect &theRect)
{
#if SIDEBAR == 1
//  page = 0;
#endif
  TPagesPrintHandler(fPrintHandler)->PageToViewRect(page, theRect);
}


// ------------------------------------------------------------------------
int _TMarginDialog::ScaleHFMargin(Fixed theMargin)
{
  return FixRound(FixMul(theMargin, TPagesPrintHandler(fPrintHandler)->fZoomFactor));
}

// ------------------------------------------------------------------------
static void DrawAMargin(int linePos, Rect &pageInterior, bool plusLine)
{
  int lineThickness = GetVLineThickness();

  if (plusLine)
    linePos = RoundToPixel(linePos + 1, v - 4);
  MoveTo(pageInterior.left + lineThickness, linePos);
  LineTo(pageInterior.right - (lineThickness * 2), linePos);
}


// ------------------------------------------------------------------------
void _TMarginDialog::DrawFoot(Rect &pageInterior, Fixed theMargin)
{
  DrawAMargin(pageInterior.bottom - theMargin, pageInterior, FALSE);
}


// ------------------------------------------------------------------------
void _TMarginDialog::DrawHead(Rect &pageInterior, Fixed theMargin)
{
  DrawAMargin(pageInterior.top + theMargin, pageInterior, TRUE);
}


// ------------------------------------------------------------------------
void _TMarginDialog::DrawInteriorFrame(int page)
{
  Rect tempRect;
  Rect pageRect;
  THPrint printRec = TPagesPrintHandler(fPrintHandler)->fHPrint;

  MoveRect(pageRect, TPagesPrintHandler(fPrintHandler)->fQDPaper);
  PageToDialogRect(page, pageRect);
  InsetRect(pageRect, -GetVLineThickness(), 0);
  MoveRect(tempRect, pageRect);
#ifdef TABLES
  if (printRec->options & kShowMargins)
  {
    tempRect = fLimitRect[page];
    PageToDialogRect(page, tempRect);
    if (SectRect(tempRect, pageRect, tempRect))
    {
      // draw in the grey margins between the two rects
      BackPat(3);
      for (int i = 0; i <  4; i++)
      {
        int saveEdge = ((int *)&pageRect)[i];

        ((int *)&pageRect)[i] = ((int *)&tempRect)[(i + 2) & 3];
        EraseRect(pageRect);
        ((int *)&pageRect)[i] = saveEdge;
      }
    }
    if (page == 0)
      PenPat(5);
  }
#endif
  BackPat(kWhite);    // 25/04/91
  EraseRect(tempRect);
  FrameRect(pageRect);

  // in-line: FramePageInterior(page, TRUE);
  GetPageInterior(page, tempRect);
  PenNormal();
  PenPat(kLtGreyPat);
  if (fHeaderFooter)
  {
    FrameRect(tempRect);
    if (page != 0)
      PenNormal();
  }
  DrawHead(tempRect, ScaleHFMargin(fHeaderMargin));
  DrawFoot(tempRect, ScaleHFMargin(fFooterMargin));
  if (!fHeaderFooter)
  {
    if (page != 0)
      PenNormal();
    FrameRect(tempRect);
  }
}


// ------------------------------------------------------------------------
void _TMarginDialog::Draw(Rect &area)
{
#ifdef LATER
  char command[5];
  char *p = (char *)NewHandle(80000);
  wr_os_regset regs;

  ((int *)p)[0] = 80000;
  ((int *)p)[2] = 16;
  wr_os_swi2(0x2e, 9 + 256, (int)p);
  regs.r[0] = 16 + 256;
  regs.r[1] = (int)p;
  regs.r[2] = (int)"bonzo";
  regs.r[3] = 0;
  thePort->LocalToBox(fTargetArea, *((wr_wimp_box *)&regs.r[4]));
  wr_os_swi(0x2e, &regs);

  regs.r[0] = 60 + 256;
  regs.r[1] = (int)p;
  regs.r[2] = (int)"bonzo";
  regs.r[3] = 0;
  wr_os_swi(0x2e, &regs);

  command[0] = 29;
  command[1] = (-regs.r[4]) & 0xff;
  command[2] = (-regs.r[4]) >> 8;
  command[3] = (-regs.r[5]) & 0xff;
  command[4] = (-regs.r[5]) >> 8;
  wr_wimpt_noerr(wr_os_swi2(OS_WriteN | wr_os_X, (int)command, 5));
  
#endif
  PenNormal();
  DrawInteriorFrame(1);
#if SIDEBAR != 1
  PenPat(kLtGreyPat);
  DrawInteriorFrame(0);
#endif
#ifdef LATER

  regs.r[0] = 60 + 256;
  regs.r[1] = (int)p;
  regs.r[2] = 0;
  regs.r[3] = 0;
  wr_os_swi(0x2e, &regs);

  regs.r[0] = 34 + 256;
  regs.r[1] = (int)p;
  regs.r[2] = (int)"bonzo";
  thePort->LocalToBox(fTargetArea, *((wr_wimp_box *)&regs.r[3]));
  regs.r[5] = 0;
  wr_os_swi(0x2e, &regs);
  DisposHandle(p);
#endif
}

#ifdef TABLES
// ------------------------------------------------------------------------
TCommand _TMarginDialog::ResizePage(int pageWidth, int pageHeight)
{
  // just set the size, reset below will centre within the ink
  TPagesPrintHandler(fPrintHandler)->fHPrint->rPaper.bottom =
                     TPagesPrintHandler(fPrintHandler)->fHPrint->rPaper.top + pageHeight;
  TPagesPrintHandler(fPrintHandler)->fHPrint->rPaper.right =
                     TPagesPrintHandler(fPrintHandler)->fHPrint->rPaper.left + pageWidth;
  TPagesPrintHandler(fPrintHandler)->fHPrint->iDev = kExplicitPaper;
  return ResetForPaperChange();
}

// ------------------------------------------------------------------------
TCommand _TMarginDialog::SetPageToDefault()
{
  TPagesPrintHandler(fPrintHandler)->fHPrint->rPaper = gPrinterDetails->rPaper;
  // reset the ink too? it could be different to current if different value saved in doc
  TPagesPrintHandler(fPrintHandler)->fHPrint->rPage = gPrinterDetails->rPage;
  TPagesPrintHandler(fPrintHandler)->fHPrint->iDev = kNoDevice;  // check again when printing?
  return ResetForPaperChange();
}
#endif

// ------------------------------------------------------------------------
TCommand _TMarginDialog::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
#ifdef TABLES
  int pageWidth = 2381400;
  int pageHeight = 3367980;

  switch (aCmdNumber)
  {
    case cA5:
      pageHeight >>= 1;
      pageHeight ^= pageWidth;
      pageWidth ^= pageHeight;
      pageHeight ^= pageWidth;
    case cA4:
      pageHeight >>= 1;
      pageHeight ^= pageWidth;
      pageWidth ^= pageHeight;
      pageHeight ^= pageWidth;
    case cA3:
      pageHeight >>= 1;
      pageHeight ^= pageWidth;
      pageWidth ^= pageHeight;
      pageHeight ^= pageWidth;
    case cA2:
      pageHeight >>= 1;
      pageHeight ^= pageWidth;
      pageWidth ^= pageHeight;
      pageHeight ^= pageWidth;
    case cA1:
      pageHeight >>= 1;
      pageHeight ^= pageWidth;
      pageWidth ^= pageHeight;
      pageHeight ^= pageWidth;
    case cA0:
      return ResizePage(pageWidth, pageHeight);

    case cDfltPageSize:
      return SetPageToDefault();

    default:
      return _TView::DoMenuCommand(info, aCmdNumber);
  }
#else
  return _TView::DoMenuCommand(info, aCmdNumber);
#endif
}


// ------------------------------------------------------------------------
TMousePosition _TMarginDialog::CheckMousePosition(Point &theMouse)
{
  Rect tempRect;
  Rect testRect;

  GetPageInterior(1, tempRect);
  InsetRect(tempRect, -kSlop, -kSlop);
  if (fHeaderFooter)
  {
    MoveRect(testRect, tempRect);
    testRect.top += ScaleHFMargin(fHeaderMargin);
    testRect.bottom = testRect.top + (kSlop * 2);
    if (PtInRect(theMouse, testRect))
      return kHeaderMargin;
    MoveRect(testRect, tempRect);
    testRect.bottom -= ScaleHFMargin(fFooterMargin);
    testRect.top = testRect.bottom - (kSlop * 2);
    if (PtInRect(theMouse, testRect))
      return kFooterMargin;
  }
  else if (PtInRect(theMouse, tempRect))
  {
    InsetRect(tempRect, kSlop * 2, kSlop * 2);
    if (PtInRect(theMouse, tempRect))
      return kPageInterior;
    if (theMouse.h >= tempRect.left && theMouse.h < tempRect.right)
      return kHorizMargin;
    if (theMouse.v < tempRect.top || theMouse.v >= tempRect.bottom)
      return kInCorner;
    return kVertMargin;
  }
  return kOutsidePage;
}


// ------------------------------------------------------------------------
TCommand _TMarginDialog::DoMouseCommand(Point &theMouse, EventInfo &info)
{
  TMousePosition pos;

#ifdef DRAGDROP
  if (info.theClickCount <= 0)
    pos = kOutsidePage;
  else
#endif
    pos = CheckMousePosition(theMouse);

  switch (pos)
  {
    case kOutsidePage:
      return gNoChanges;
    case kHeaderMargin:
    case kFooterMargin:
      return new _THFTracker(this, pos & 1);  // TRUE for Header
    default:
      DoSetLimits(kDontRedraw);
      return new _TMarginTracker(this);
  }
}


// ------------------------------------------------------------------------
int _TMarginDialog::GetPointerShape(Point &localPoint)
{
  TMousePosition pos = CheckMousePosition(localPoint);
  int cursorId;

  switch (pos)
  {
    case kHeaderMargin:
    case kFooterMargin:
    case kHorizMargin:
      cursorId = kUpDnArrowCursor;
      break;
    case kPageInterior:
      cursorId = kHandCursor;
      break;
    case kVertMargin:
      cursorId = kLtRtArrowCursor;
      break;
    case kInCorner:
      cursorId = kFourArrowCursor;
      break;
    default:
      cursorId = -1;  // system cursor
      // return FALSE;
  }
  // SetCursor(GetCursor(cursorId));
  return cursorId;  // TRUE;
}


// ===================== methods of TMarginCommand =========================
_TMarginCommand::_TMarginCommand(TTextDocument doc, TMarginData *data) :
                                       (cPageSetupChanges, doc, NULL, NULL)
{
  fPrintHandler = TPagesPrintHandler(doc->fDocPrintHandler);

  // make a copy of the print handler & view fields which may be changed
  memcpy(&fChangedData, data, sizeof(TMarginData));
}


// ------------------------------------------------------------------------
void  _TMarginCommand::Free()
{
  TTextDocument(fChangedDocument)->CommitLRHeaderFooter(kPageHeader);
  TTextDocument(fChangedDocument)->CommitLRHeaderFooter(kPageFooter);

  _TCommand::Free();
}


// ------------------------------------------------------------------------
void _TMarginCommand::ResetSelection(bool hfSwitched)
// 12/09/90 new method when selection in h/f which is destroyed/rebuilt
{
  TTextDocument document = TTextDocument(fChangedDocument);

  if (hfSwitched) // fLeftRightHdr != fxLeftRightHdr || fLeftRightFtr != fxLeftRightFtr)
  {
    // 05/09/95 [26020]
    TSelection selection = document->GetNewSelection();
    TCursorNode anchor = selection->GetAnchorRoot();
    TViewId viewId;
    bool hf = kPageFooter;
    bool leftRightHF;
    TCurrency newCurr;
    TCurrency leftHF;
    TCurrency rightHF;

    viewId.fId = anchor->fIdentifier;
    switch (viewId.tag.fSubId)
    {
      case 1:
        hf = kPageHeader;
      case 2:
        leftRightHF = document->GetHeaderFooter(hf, leftHF, rightHF);
        newCurr = (leftRightHF && !Odd(viewId.tag.fColNum) ? leftHF : rightHF);
        if (newCurr != anchor->fCurrency)
        {
          TStructure structure;

          anchor->fCurrency = newCurr;
          document->HighlightSelection(HLOff, TRUE); // 23/11/95 [27001]
          selection->SetTheCursor(TRUE);             // 23/11/95 [27001] in case a selection
          structure = document->GetStructureReadOnly(newCurr);
          structure->ResetCursor(anchor, -1, TRUE, FALSE);     // 05/03/91
          // 23/11/95 [27001] do after call: document->ScrollSelectionIntoView();
          // 23/11/95 [27001] done in SetTheCursor: selection->fChanged = TRUE;
                              // 05/09/95 get body currency in LevelInfo set correctly
          return;     // 29/05/91 save 2 identical elses
        }
    } 
  }
  document->SetTextHandler();    // ???
  // 23/11/95 [27001] do after call: document->ScrollSelectionIntoView();      // 29/05/91
}


// ------------------------------------------------------------------------
void _TMarginCommand::DoIt()
{
  TTextDocument document = TTextDocument(fChangedDocument);
  TPagesPrintHandler itsPrintHandler;
//  TCurrency currency;
  bool   tempBool;
  bool   needInval;
  bool   hfSwitched;
  VRect  tempMargins;
  TPrint tempRec;

  document->GetSelection(TRUE);  // 12/09/90

  // sort out the different LR headers and footers; this can leave the document
  // with different L & R currencies, but the user has requested they are the
  // same. This is sorted out by Free, which releases the left hand one
  fChangedData.fLeftRightHdr = document->SetHeaderFooter(kPageHeader, fChangedData.fLeftRightHdr);
  fChangedData.fLeftRightFtr = document->SetHeaderFooter(kPageFooter, fChangedData.fLeftRightFtr);
  hfSwitched = document->fLRHeaderFooterChg;

  // now toggle the print record and the print handler data (margins & sameInterior)
  itsPrintHandler = fPrintHandler;
  memcpy(&tempRec, itsPrintHandler->fHPrint, sizeof(TPrint));
  memcpy(itsPrintHandler->fHPrint, &fChangedData.fPrintRec, sizeof(TPrint));
  memcpy(&fChangedData.fPrintRec, &tempRec, sizeof(TPrint));

//  needInval = EqualVRect(itsPrintHandler->fPageAreas.theMargins, fChangedData.fMargins);
  needInval = EqualVRect(itsPrintHandler->fRawMargins, fChangedData.fMargins);
  if (needInval)
  {
    if (fChangedData.fSameInterior == itsPrintHandler->fSameInterior)
      needInval = FALSE;
  }
  else
  {
    MoveRect(tempMargins, itsPrintHandler->fRawMargins);
    MoveRect(itsPrintHandler->fRawMargins, fChangedData.fMargins);
    MoveRect(fChangedData.fMargins, tempMargins);
  }
  if (itsPrintHandler->fSameInterior != fChangedData.fSameInterior)
  {
    tempBool = itsPrintHandler->fSameInterior;
    itsPrintHandler->fSameInterior = fChangedData.fSameInterior;
    fChangedData.fSameInterior = tempBool;
    document->fLRHeaderFooterChg = 2;  // 23/06/95 [26027] force rebuild of h/f views
  }

  // toggle the header and footer margins with those in the PagesView
  fChangedData.fHeaderMargin = TPagesView(itsPrintHandler->fView)->
                                  SetHeaderFooter(fChangedData.fHeaderMargin, TRUE);
  fChangedData.fFooterMargin = TPagesView(itsPrintHandler->fView)->
                                  SetHeaderFooter(fChangedData.fFooterMargin, FALSE);

  // need to redraw the left hand pages if no other chang than to switch reflect state
  if (needInval)
    itsPrintHandler->InvalEvenPages();

  ResetSelection(hfSwitched);               // 12/09/90, 23/11/95 [27001] moved up
  itsPrintHandler->ResetForPaperChange();   // force a view resize if changed
  // 23/11/95 [27001] moved up: ResetSelection(hfSwitched);
  document->ScrollSelectionIntoView();      // 23/11/95 [27001] moved out of ResetSelection
}


// ------------------------------------------------------------------------
void _TMarginCommand::UndoIt(void)
{
  _TMarginCommand::DoIt();
}


// ------------------------------------------------------------------------
void _TMarginCommand::RedoIt(void)
{
  _TMarginCommand::DoIt();
}

// ====================== methods of TMarginTracker =======================
static int ScaleUp(Fixed f, TPagesPrintHandler prHdlr)
{
  return FromFixed(f * ScaleToPC(prHdlr->fHPrint->scalePc));
}

// ------------------------------------------------------------------------
_TMarginTracker::_TMarginTracker(TMarginDialog marginDialog) :
              (cNoCommand, NULL, marginDialog->FindSubView(pges), NULL)
{
  TFixedPtText cgf_128 = TFixedPtText(marginDialog->FindSubView(flft));
  TFixedPtText cgf_129 = TFixedPtText(marginDialog->FindSubView(ftop));
  TFixedPtText cgf_130 = TFixedPtText(marginDialog->FindSubView(frgt));
  TFixedPtText cgf_131 = TFixedPtText(marginDialog->FindSubView(fbtm));
  TPagesPrintHandler prHdlr = TPagesPrintHandler(marginDialog->fPrintHandler);

  // 20/10/92  fTrackNonMovement = TRUE;
  //  fViewConstrain = FALSE;
  fMarginDialog = marginDialog;
  MoveRect(fMargins, prHdlr->fRawMargins);
  fLeftLimit = ScaleUp(cgf_128->fMaximum, prHdlr);
  fTopLimit = cgf_129->fMaximum; // ScaleUp(cgf_129->fMaximum, prHdlr);
  fRightLimit = ScaleUp(-cgf_130->fMaximum, prHdlr);
  fBottomLimit = -cgf_131->fMaximum;    // ScaleUp(-cgf_131->fMaximum, prHdlr);
}


// ------------------------------------------------------------------------
void _TMarginTracker::PutTrackerIntoPage()
{
  // put the mouse into the margin page, and then constrain it to the screen
  VRect frame;
  wr_wimp_box box;

  fMarginDialog->Focus();
  fMarginDialog->GetPageInterior(1, frame);
  thePort->LocalToBox(frame, box);
  ConstrainMouseToBox(box.x0, box.x1, box.y0, box.y1);

  ShowCursor(); // this constrains to the screen as well...
}


// ------------------------------------------------------------------------
TCommand _TMarginTracker::TrackMouse(TrackPhase aTrackPhase,
           VPoint &anchorPoint, VPoint &previousPoint, VPoint &nextPoint,
           bool mouseDidMove, EventInfo &info)
{
  TCommand  TrackMouse_r;
  VPoint movement;
  TPagesPrintHandler thePrintHandler;
  Rect tempRect;

  TrackMouse_r = this;
  thePrintHandler = TPagesPrintHandler(fMarginDialog->fPrintHandler);
  if (aTrackPhase == trackPress)
  {
    fMarginDialog->GetPageInterior(1, tempRect);
    InsetRect(tempRect, kSlop, kSlop);
    OffsetRect(tempRect, -fMarginDialog->fTargetArea.left,
                                           -fMarginDialog->fTargetArea.top);
    fInCentre = PtInRect(anchorPoint, tempRect);
    fLeft = (anchorPoint.h < tempRect.left);
    fTop = (anchorPoint.v < tempRect.top);
    fRight = (anchorPoint.h > tempRect.right);
    fBottom = (anchorPoint.v > tempRect.bottom);
    HideCursor();
  }
  else if (aTrackPhase == trackRelease)
  {
    PutTrackerIntoPage();
    TrackMouse_r = gNoChanges;
  }
  if (mouseDidMove)
  {
    // register Rect *margins = &thePrintHandler->fPageAreas.theMargins;
    register Rect *margins = &thePrintHandler->fRawMargins;

    movement = nextPoint;
    SubVPt(anchorPoint, movement);
    movement.h = movement.h * 100;      // convert deci to milliPoints
    movement.v = movement.v * 100;
    if (fInCentre)
    {
      if (movement.h > 0)
        movement.h = Min(movement.h, fRightMin - fMargins.right);
      else
        movement.h = Max(movement.h, fLeftMin - fMargins.left);
      if (movement.v > 0)
        movement.v = Min(movement.v, fBottomMin - fMargins.bottom);
      else
        movement.v = Max(movement.v, fTopMin - fMargins.top);
      MoveRect(*margins, fMargins);
      OffsetVRect(*margins, movement.h, movement.v);
    }
    else
    {
      if (fLeft)
        margins->left =
            MinMax(fLeftMin, fMargins.left + movement.h, fLeftLimit);
      if (fTop)
        margins->top =
            MinMax(fTopMin, fMargins.top + movement.v, ScaleUp(fTopLimit, thePrintHandler));
      if (fRight)
        margins->right =
            MinMax(fRightLimit, fMargins.right + movement.h, fRightMin);
      if (fBottom)
        margins->bottom =
            MinMax(ScaleUp(fBottomLimit, thePrintHandler), fMargins.bottom + movement.v, fBottomMin);
    }
//    thePrintHandler->SetZoomedMargins();
    thePrintHandler->MoveRectsToLandscape();  // to scale the raw margins
    thePrintHandler->SetPageInterior();
  }
  if (aTrackPhase == trackRelease)
  {
#ifdef NEVER
    PenNormal();
    PenMode(patXor);
#endif
    TrackFeedback(anchorPoint, nextPoint, TRUE, TRUE);
  }
  return(TrackMouse_r);
}


// ------------------------------------------------------------------------
void _TMarginTracker::TrackFeedback(VPoint &anchorPoint, VPoint &nextPoint,
                                         bool turnItOn, bool mouseDidMove)
{
  if (mouseDidMove)
  {
    fMarginDialog->Focus();
    fMarginDialog->Draw(gZeroRect);       // parameter not used
    fMarginDialog->DoSetLimits(kRedraw);  // moved from TrackFeedback
  }
}


// ======================== methods of THFTracker =========================
_THFTracker::_THFTracker(TMarginDialog marginDialog, bool header) :
                                              (marginDialog)
{
  fTop = header;
  fOrigMargin =
      (header ? marginDialog->fHeaderMargin : marginDialog->fFooterMargin);
}


// ------------------------------------------------------------------------
TCommand _THFTracker::TrackMouse(TrackPhase aTrackPhase, VPoint &anchorPoint,
                VPoint &previousPoint, VPoint &nextPoint, bool mouseDidMove,
                EventInfo &info)
{
  TCommand  TrackMouse_r;
  VPoint movement;
  TPagesPrintHandler thePrintHandler;

  TrackMouse_r = this;
  thePrintHandler = TPagesPrintHandler(fMarginDialog->fPrintHandler);
  if (aTrackPhase == trackPress)
    HideCursor();
  else if (aTrackPhase == trackRelease)
  {
    PutTrackerIntoPage();
    TrackMouse_r = gNoChanges;
  }
  if (mouseDidMove)
  {
    register TMarginDialog marginDialog = fMarginDialog;

    movement = nextPoint;
    SubVPt(anchorPoint, movement);
    movement.v = ToFixed(movement.v);
    if (fTop)
      marginDialog->fHeaderMargin =
                 MinMax(MilliToFixed(fTopMin), movement.v + fOrigMargin,
                             fTopLimit);
    else
      marginDialog->fFooterMargin =
               -MinMax(fBottomLimit, movement.v - fOrigMargin,
                             MilliToFixed(fBottomMin));
  }
  if (aTrackPhase == trackRelease)
  {
    PenNormal();
    PenMode(patXor);
    TrackFeedback(anchorPoint, nextPoint, TRUE, TRUE);
  }
  return(TrackMouse_r);
}
