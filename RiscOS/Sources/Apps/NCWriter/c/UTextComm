/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdlib.h>
#include <ctype.h>

#include "win.h"

#include "UTextComm.h"
#include "UPictEdit.h"
#include "UClipBrd.h"
#include "UScaledWn.h"
#include "PTextComm.h"
#ifdef INDEX
#include "UIndex.h"
#endif

extern int GetMenuColour(MenuHandle theMenu, int item);

#define kSetDateFormatDlg 31
#define kUpdateIndexDlg 46
#define kAddToIndexDlg 47
#define kColourDlg 40
#define cFindSynonym 118
#define cAutoKern 472
#define cFNStartNumMenu 98

#ifdef TABLES
#define kCstr I_('C', 's', 't', 'r')
#define kChgs I_('C', 'h', 'g', 's')
#define kFixt I_('F', 'i', 'x', 't')
#define kBarFieldMsg 213
#define TestInHF(str) str->IsPartOf((1 << kHeader) | (1 << kFooter))

static bool gCtrlF1 = FALSE;     // 23/04/92

// ------------------------------------------------------------------------
_TSetDateFmtCmd::_TSetDateFmtCmd(TTextDocument itsDocument,
        DateForm dateFormat, TimeForm timeFormat, bool alwaysUpdate,
        char *customText) :
                     (cSetDateFormat, itsDocument, NULL, NULL)
{
//  fDocument = itsDocument;
  fOldDateFormat = dateFormat;
  fOldTimeFormat = timeFormat;
  fOldAlwaysUpdate = alwaysUpdate;
#ifndef ZERO_OBJ
  fOldCustomDate[0] = 0;
#endif
  if (customText != NULL)
    strcpy255(fOldCustomDate, customText);
}


// ------------------------------------------------------------------------
void _TSetDateFmtCmd::DoIt()
{
  TTextDocument document = TTextDocument(fChangedDocument);
  TSelection selection = document->GetSelection(TRUE);
  DateForm t1;
  TimeForm t4;
  int t2;
  char *temp = NULL;

  selection->fReformatType = kReformatMacros;
  t1 = document->fDateFormat;
  document->fDateFormat = fOldDateFormat;
  fOldDateFormat = t1;
  t4 = document->fTimeFormat;
  document->fTimeFormat = fOldTimeFormat;
  fOldTimeFormat = t4;

  if (fOldCustomDate[0] != 0)
    FailNIL(temp = (char *)NewString(fOldCustomDate));

  if (document->fCustomDate != NULL)
    strcpy255(fOldCustomDate, document->fCustomDate);
  else
    fOldCustomDate[0] = 0;
  // now overwrite fDocument->fCustomDate (do not do it until FailNIL passed)
  DisposIfHandle(document->fCustomDate);
  document->fCustomDate = temp;

  // 17/10/94 [23008] seems to have (always?) been missing
  t2 = fOldAlwaysUpdate;
  fOldAlwaysUpdate = document->fAlwaysUpdate;
  document->fAlwaysUpdate = t2;

  document->Reformat();
  document->HighlightSelection(HLOn, FALSE);
}

// ------------------------------------------------------------------------
void _TSetDateFmtCmd::UndoIt()
{
  DoIt();
}

// ------------------------------------------------------------------------
void _TSetDateFmtCmd::RedoIt()
{
  DoIt();
}
#endif


// ------------------------------------------------------------------------
_TFindCommand::_TFindCommand(CmdNumber cmd, TMainView mainView, char *findText)
                            : (cmd, mainView->fDocument, NULL, NULL)
{
  strcpy255(fFindText, findText);
  strcpy255(fReplaceText, mainView->fReplaceText);
  fWholeWord = mainView->fWholeWord;
  fCaseSensitive = mainView->fCaseSensitive;
  fSearchBackwards = mainView->fSearchBackwards;
#ifndef ZERO_OBJ
  fSaveSelection = NULL;
  fSelection = NULL;
  fStructure = NULL;
  fCurrency = gNullCurrency;
#endif
  fCanUndo = (cmd != cReplaceAll);
}


// ------------------------------------------------------------------------
void _TFindCommand::Free()
{
  TStructure structure;
  TCurrency currency;
  TCursorNode anchor, activeEnd;
  TSelection selection;
  TTextDocument doc = TTextDocument(fChangedDocument);

  if (fCmdNumber == cReplace)
  {
    selection = (fCmdDone ? doc->GetSelection(FALSE) : fSaveSelection);
                                            // 18/04/91 restore if !fCmdDone
    anchor = selection->GetAnchorOwner();
    activeEnd = selection->GetActiveOwner();
    currency = anchor->fCurrency;
    structure = doc->GetStructureReadWrite(currency);
    // 28/04/93 structure->UndoReplace(currency, anchor, activeEnd, TRUE);
    structure->Commit(currency, anchor, activeEnd, this, FALSE);  // 28/04/93 do in-line
  }
  selection = doc->GetSelection(TRUE);
  FreeIfObject(fSaveSelection);
  _TCommand::Free();
}


// ------------------------------------------------------------------------
void _TFindCommand::Commit()
{
  // 28/05/90 - new method
}


// ------------------------------------------------------------------------
void _TFindCommand::Parse(char *outPtr)  // 18/07/93 now copies from fFindText
{
  char *inPtr = fFindText;
  int c;

  gErrorParm3 = inPtr;   // 01/06/95 [26009] save original for use in dialogue
  do {
    c = *(inPtr++);
    if (c == '@')
    {
      c = *(inPtr++);     // pick up qualifier
      if (c == 't')
        c = chTab;
      else if (c == 'v')
        c = chLineFeed;
      else if (c == 'n')
        c = chReturn;
      else if (c != '@' && c != '?')
      {
        inPtr--;
        c = '@';   // reset to the '@'
      }
    }
    else if (c == '?')
      c = 1;
    *(outPtr++) = c;
  } while (c != 0);
}

// ------------------------------------------------------------------------
void _TFindCommand::ReplaceText(TSelection hitSelection, bool replace)
{
  TStructure structure;
  TCurrency currency;
  TCursorNode anchor, activeEnd;
  TTextDocument doc = TTextDocument(fChangedDocument);
  bool replaceAll = fCmdNumber == cReplaceAll;

  hitSelection->SetTarget();
  if (replace)
  {
    anchor = hitSelection->GetAnchorOwner();
    activeEnd = hitSelection->GetActiveOwner();
    currency = anchor->fCurrency;
    structure = doc->GetStructureReadWrite(currency);
    structure->DoReplace(currency, anchor, activeEnd, fReplaceText, replaceAll);
    fCausesChange = TRUE;                 // 04/06/91 wait until certain
  }
  if (replaceAll)
    hitSelection->SetTheCursor(FALSE);      // kill selection
  doc->ResetSelection(hitSelection);
  ClearObject(fSelection);
}

// ------------------------------------------------------------------------
void _TFindCommand::DoFindText(bool replace)
{
  TSelection hitSelection;
  TSelection hotSelection;
  TCursorNode startPoint;
  Str255 findText;
  bool searchResult;
  TTextDocument doc = TTextDocument(fChangedDocument);
  FailInfo fi;

  BeginProgress();            // 25/02/91
  hitSelection = new _TSelection(doc);
  CatchFailures(&fi);
  if (fSearchBackwards != replace)                         // 10/05/91 !
    startPoint = fSelection->GetAnchorRoot();
  else
    startPoint = fSelection->GetActiveRoot();
  Parse(findText);
  EnableEscape();
  searchResult = fStructure->DoSearch(fCurrency, startPoint, hitSelection, findText,
                       fWholeWord, fCaseSensitive, fSearchBackwards, FALSE);
  if (searchResult)
  {
    doc->HighlightSelection(HLOff, TRUE);
    ReplaceText(hitSelection, replace);
    hotSelection = hitSelection;      // 13/11/90 do not now free on failure
    hitSelection = NULL;
    if (replace)
    {
      hotSelection->fReformatType = kSelSlow;
      doc->Reformat();
      hotSelection->SetTheCursor(fReplaceText[0] == 0 ? TRUE : fSearchBackwards);
    }
    doc->ScrollAndReset();
    hotSelection->DoMenus(FALSE);
  }
  else
  {
    fCanUndo = FALSE;
    SysBeep(0);
  }
  Success(&fi);               

// +++++++++++++ exception handler
Rescue:
  DisableEscape();
  HideProgress();              // 25/02/91
  FreeIfObject(hitSelection);
  ContinueIfFail(&fi);
}


// ------------------------------------------------------------------------
void _TFindCommand::DoReplaceAll()
{
  // 28/05/90 - new method
  TSelection selection;
  volatile TSelection hitSelection;
  TCursorNode startPoint;
  Str255 findText;
  bool finished;
  long numOfItems;
  volatile int replacements = 0;
  TTextDocument doc = TTextDocument(fChangedDocument);
  FailInfo fi;

  doc->EndInteractive();
  hitSelection = NULL;
  CatchFailures(&fi);
  doc->HighlightSelection(HLOff, TRUE);    // 18/04/91
  doc->InitialSelection(doc->ActiveMainView(), 0, 0); // 06/09/92
  Parse(findText);
  numOfItems = fStructure->CountSelectedItems(gNullCurrency, NULL, NULL, FALSE);
  ShowProgress(numOfItems);
  EnableEscape();
  finished = FALSE;
  do
  {
    selection = doc->GetNewSelection();
    startPoint = selection->GetAnchorRoot();
    hitSelection = new _TSelection(doc);
    if (fStructure->DoSearch(fCurrency, startPoint, hitSelection, findText,
      fWholeWord, fCaseSensitive, /*14/11/90 fSearchBackwards*/ FALSE, TRUE))
    {
      hitSelection->fReformatType = kReformatChgs;
      ReplaceText(hitSelection, TRUE);
      hitSelection = NULL;                    // 14/11/90 in case of failure
      FreeIfObject(selection);
      replacements++;
      doc->UpdateChangeCount(1);        // 04/06/91
    }
    else
    {
      FreeIfObject(hitSelection);
      hitSelection = NULL;                        // 14/11/90
      finished = TRUE;
      if (fSelection != NULL)                  // 07/06/91 none found
      {
        doc->ResetSelection(fSelection); // restore original
        FreeIfObject(selection);               // and free unused one
      }
    }
  } while (!finished);

  Success(&fi);
  // run on into Rescue
Rescue:   // 04/06/91 do not leave uncompleted by Cancel in middle
  FreeIfObject(hitSelection);
  if (fi.message == 0)
     fi.message = fCmdNumber | (msgCmdErr << 16);
  ErrorAlert(fi.error, fi.message);

  selection = doc->GetNewSelection();
  DisableEscape();
  HideProgress();                                 // 10/09/90
  if (fReplaceText[0] == 0)
    selection->SetTheCursor(TRUE);
  doc->Reformat();
  doc->ScrollAndReset();
  selection->DoMenus(FALSE);
}


// ------------------------------------------------------------------------
void _TFindCommand::DoIt()
{
  TSelection selection;
  TStructure structure;
  TCurrency currency;
  TTextDocument doc = TTextDocument(fChangedDocument);

  selection = doc->GetSelection(TRUE);
  fSelection = selection;
  // FailNIL(fSaveSelection = TSelection(selection->Clone()));
  selection->MakeClone(&fSaveSelection);
  currency = doc->fBody;
  fCurrency = currency;
  structure = doc->GetStructureReadOnly(currency);
  fStructure = structure;
  fCausesChange = FALSE;        // 04/06/91 will be reset if change made
  if (fCmdNumber == cReplaceAll)
    DoReplaceAll();
  else if (fCmdNumber == cReplace)
    DoFindText(TRUE);
  else
    DoFindText(FALSE);
}


// ------------------------------------------------------------------------
void _TFindCommand::UndoIt()
{
  TSelection selection;
  TStructure structure;
  TCurrency currency;
  TCursorNode anchor, activeEnd;
  TTextDocument doc = TTextDocument(fChangedDocument);

  doc->HighlightSelection(HLOff, TRUE);
  selection = doc->GetSelection(FALSE);
  if (fCausesChange)
  {
    if (fCmdNumber == cReplace)
    {
      anchor = selection->GetAnchorOwner();
      activeEnd = selection->GetActiveOwner();
      currency = anchor->fCurrency;
      structure = doc->GetStructureReadWrite(currency);
      structure->ToggleState(currency, anchor, activeEnd, this);
      selection->fReformatType = kSelSlow;
      doc->Reformat();
    }
  }
  doc->ResetSelection(fSaveSelection); // 28/05/90
  fSaveSelection = selection;
  doc->ScrollAndReset();
  fSaveSelection->fChanged = TRUE;
  doc->SetCurrentStyle();
}


// ------------------------------------------------------------------------
void _TFindCommand::RedoIt()
{
  UndoIt();
}


// ------------------------------------------------------------------------
_TStyleCommand::_TStyleCommand(TTextDocument itsDocument, CmdNumber cmd,
                      TStyleFormat newStyle) : (cmd, itsDocument, NULL, NULL)
{
  fDocument = itsDocument;
  fStyle = newStyle;
#ifdef FN
  if (cmd == cFNStartNumMenu)
    fCanUndo = FALSE;
#endif
}


// ------------------------------------------------------------------------
void _TStyleCommand::Free()
{
  TSelection selection;
  fDocument->CommitStyle(this);
  selection = fDocument->GetSelection(TRUE);
  _TCommand::Free();
}


// ------------------------------------------------------------------------
void _TStyleCommand::DoIt()
{
  fDocument->InstallStyleChange(fStyle, fCmdNumber); // 6/5/92
}


// ------------------------------------------------------------------------
void _TStyleCommand::RedoIt()
{
  UndoIt();
}


// ------------------------------------------------------------------------
void _TStyleCommand::UndoIt()
{
  fDocument->ToggleChanges(fCmdNumber); // 6/5/92
}

#ifdef TABLES
// ------------------------------------------------------------------------
_TSelStyleCommand::_TSelStyleCommand(TTextDocument itsDocument, TCurrency style)
               : (cStyleChange, itsDocument, 0, 0)
{
  fDocument = itsDocument;
  fStyle = style;
}


// ------------------------------------------------------------------------
void _TSelStyleCommand::Free()
{
  TSelection selection;
  fDocument->CommitStyle(this);
  selection = fDocument->GetSelection(TRUE);
  _TCommand::Free();
}


// ------------------------------------------------------------------------
void _TSelStyleCommand::DoIt()
{
  TSelection selection;
  selection = fDocument->GetSelection(TRUE);
  fDocument->SetStyle(fStyle, fCmdNumber); // 6/5/92
}


// ------------------------------------------------------------------------
void _TSelStyleCommand::RedoIt()
{
  fDocument->ToggleStyle(fCmdNumber); // 6/5/92
}


// ------------------------------------------------------------------------
void _TSelStyleCommand::UndoIt()
{
  RedoIt();
}
#endif

// ------------------------------------------------------------------------
_TTypingCommand::_TTypingCommand(TTextDocument itsDocument, TTextEvent itsTextHandler,
                                         int itsFirstCh) : (cTyping, itsDocument)
{
  fChar = itsFirstCh;
  fTextHandler = itsTextHandler;
  fSelectionReset = itsDocument->GetNewSelection()->fChanged;
#ifndef ZERO_OBJ
  fUndoCommand = 0;
  fCursor = 0;
  fDoneTyping = FALSE;
#endif
}


// ------------------------------------------------------------------------
void _TTypingCommand::DoneTyping()
{
  fDoneTyping = TRUE;
  UpdateChangeScope();
}


// ------------------------------------------------------------------------
void _TTypingCommand::UpdateChangeScope()
{
  // the following is not required because the whole table gets selected when doing
  // an Undo/Redo a typing command in tables anyway
  // 07/02/94 if (fChanges->GetAnchorOwner()->fCurrency.cgf_31.fType != kTableStruct) // 08/11/91
  // 28/06/91 condition for redo clear table row/cols
    fChanges->UpdateScope(fCursor);          // 22/11/90
}


// ------------------------------------------------------------------------
void _TTypingCommand::Free()
{
  if (!fDoneTyping)
  {
    UpdateChangeScope();
    fTextHandler->fTypingCommand = NULL;
  }

  _TStructureCmd::Free();
}


// ------------------------------------------------------------------------
void _TTypingCommand::DoIt()
{
  TSelection selection;
  TCursorNode activeEnd;
  TCursorNode anchor;
  TStructure owner;
  bool clearToDo;
  int ch = fChar;

  selection = fDocument->GetSelection(TRUE);
  fUndoSelection = TSelection(selection->ShallowClone());
  fChanges = TSelection(selection->ShallowClone());
  fCursor = selection->GetTheCursor();

  clearToDo = (fCursor == 0);
  if (clearToDo)
  {
    activeEnd = selection->GetActiveRoot();
    anchor = selection->GetAnchorRoot();

    owner = fDocument->GetStructureReadWrite(activeEnd->fCurrency);
    fDocument->HighlightSelection(HLOff, TRUE);
    /* allGone = */ owner->Clear(anchor, activeEnd, kNormalClear, ch);

    fChanges->UpdateScope(selection->GetAnchor()); // 26/07/90
    fChanges->UpdateScope(selection->GetActiveEnd()); // 26/07/90
    fDocument->ResetSelection(fChanges);
    fDocument->GetNewSelection()->fReformatType = kSelSlow; // 21/11/91
    fDocument->Reformat();
    fDocument->ResetSelection(selection); // down to here new 24/07/90
    selection->SetTheCursor(fChar != chReturn || ch == chClear); // 28/01/91 from TRUE
    if (fChar == chReturn && ch != chReturn)
    {
      TCurrency currency = selection->GetAnchorTarget()->fCurrency;
      selection->GetAnchor()->Free();
      selection->fAnchor = NULL;
      selection->InitialCursor(fDocument->ActiveMainView(), currency, /* FALSE, 06/09/92 */ 0);
    }
    fCursor = selection->GetTheCursor();
    fDocument->ActiveMainView()->SetTheCursor(TRUE);
    fDocument->ScrollSelectionIntoView(); // 04/03/92 tab & clear at top of page
  }

  if ((fChar != chBackspace && fChar != chFwdDelete) || !clearToDo) // 17/05/91
  {
    if (!clearToDo || fChar != chReturn || ch == chReturn)
    {
#ifdef MATHS
      int origChar = fChar;
#endif

#ifdef DRAGDROP
      // 27/07/93 avoid this every keystroke
      TCurrency currency = fCursor->GetTarget()->fCurrency;

      fDocument->GetStructureReadWrite(currency)->MarkToTop(currency);
#endif
      DoType(fChar);
#ifdef MATHS
      if (origChar != fChar)      // 28/07/93 [20998]
        ch = fChar;        // change Lf into CR if Body split, to get cTypingReturn in Undo
#endif
    }
    else
      fDocument->ScrollSelectionIntoView(); // 12/07/91 <Rtn> on Table
  }
  else
  {
    fDocument->DoneTyping(); // 30/07/90 - fix obscure backspace bugs
    selection->fChanged = TRUE;
    // 21/01/94 do at end: selection->DoSetupLevels();
    // 21/01/94 do at end: fDocument->SetCurrentStyle();
    fDocument->HighlightSelection(HLOn, TRUE); // 26/07/90
  }
  if (clearToDo)
  {
    selection->DoSetupLevels();
    fDocument->SetCurrentStyle();
         // 21/01/94 [21352] need to reset menus after type a char into selected emphasis
  }
  fChar = ch;      // 28/01/91
}


// ------------------------------------------------------------------------
void _TTypingCommand::UndoIt()
{
  TTypingCommand tempCmd;

  ObscureCursor();              // 19/05/91
  fDocument->EndInteractive();  // 19/10/90
  UpdateChangeScope();

  if (fChar == chReturn)
    fCmdNumber = cTypingReturn;   // !!! So BodyEditor can Toggle it !!!
  else if (fChar == chClear)
    fCmdNumber = cClear;          // !!! so BodyEditor can Toggle it !!!

  _TStructureCmd::UndoIt();

  fChanges->SetTarget();          // 26/02/92 for redo del matrix in matrix
  fCmdNumber = cTyping;           // Restore it
  tempCmd = fUndoCommand;
  fUndoCommand = TTypingCommand(fTextHandler->fTypingCommand);
  fTextHandler->fTypingCommand = tempCmd;
  fDoneTyping = (tempCmd == 0);
}


// ------------------------------------------------------------------------
static TChangeTypes DoTextCommNote(TObject null, TCurrency note, TCurrency ref, // 11/5/93
         PStdNoteVars pars)
{
  return kNoChg;
}

// ------------------------------------------------------------------------
static TCurrency GetTargetLink(TStructure theStruct)
{
  TCurrency link;

  while ((link = theStruct->GetLink()) == 0 && theStruct->fParent != 0)
    theStruct = theStruct->GetStructureReadOnly(theStruct->fParent);
  return link;
}

// ------------------------------------------------------------------------
bool _TTypingCommand::DoType(int ch)
{
  TStructure target;
  TStructure oldTarget;
  TFormat targetFmt; // 28/05/90
  TCurrency currency;
  TCurrency oldCurr; // 14/7/92
  TSelection selection; // 14/7/92
  TCursorNode cursor;
#ifndef SUPER
  TStyleFormat changes;
  CmdNumber cmdNum; // 6/5/92
#endif
  TTextDocument document;
  bool resetStyle;
  TChangeTypes result;  // 28/05/90 - from here new
  TSubView targetView;
  TMainView mainView;
  TStdNoteVars v;  // fn1 07/08/90 - reformat interface changed
  FailInfo fi;
  bool DoType_r = FALSE;
  bool hasChars;
  bool handled;
  int theChar;

  ObscureCursor();             // 19/05/91
  resetStyle = FALSE;
  mainView = fDocument->ActiveMainView(); // 28/05/90
  cursor = fCursor->GetTarget();
  currency = cursor->fCurrency;
  target = fDocument->GetStructureReadWrite(currency);
  oldTarget = target;         // 20/06/91
  oldCurr = currency; // 14/7/92
  fCursor->fChanged = FALSE;

  CatchFailures(&fi);

  mainView->SetPageInfo(fCursor->fSelection);  // 28/01/91 if in HF, set it up

#ifndef SUPER
  changes = fTextHandler->fStyleChanges;
  cmdNum = fTextHandler->fStyleCmd; // 6/5/92
#endif
  theChar = ch;

  do
  {
#if defined TABLES && defined SPELL
    if (fDocument->InsertChar(theChar, cursor))
      DoType_r = TRUE;
#else
#if TALK == 2
    if (fDocument->fInteractive && theChar != chBackspace && !isalnum(theChar))
      target->DoSpeak(cursor);       // 15/02/93 [20700] speak when non alpha typed
#endif
#endif
    // 20/06/90 in-line DirectionChange: ensure scope always widened
    if ((fChar == chBackspace) != (theChar == chBackspace))
      fChanges->UpdateScopeLeft(fCursor, FALSE);  // 07/02/94 only update on left, right gets
                // set by Toggle/Commit, etc. & avoids cursor off end after type then delete
    fChar = theChar; // 24/07/90 - part of DirectionChange proc (expanded out here)

    handled = target->HandleKeypress(theChar, cursor);
#ifdef MATHS
    if (handled > 1)       // 28/07/93 [20998]
      fChar = handled;     // change Lf into CR if Body split, to get cTypingReturn in Undo
#endif
    theChar &= 0x1ff;       // 30/06/95 for smart quotes
    hasChars = (theChar >= 0x020 && theChar <= 0x0ff && theChar != 0x07f);

#ifndef NETWP
    // 15/09/94 send any keys from keyboard buffer too
    fDocument->SendKeyToUtil(theChar);
#endif

    if (hasChars && handled 
#ifndef SUPER
                && changes == NULL
#endif
       )
    {
      hasChars = TestNextKeyNonCntrl(&theChar);
    }
    else
      hasChars = FALSE;                       // no key to handle
  }
  while (hasChars);

  theChar = fChar;                           // 16/06/91 restore last saved

  // 16/06/91 reset variables after backspace, fwdDelete
  if (theChar == chBackspace || theChar == chFwdDelete) // 22/6/92
  {
    TCurrency link; // 23/7/92

    cursor = fCursor->GetTarget();
    currency = cursor->fCurrency;
    target = fDocument->GetStructureReadWrite(currency);
    link = GetTargetLink(target); // 23/7/92
    if (theChar == chFwdDelete && link > 0) // 23/7/92, 22/6/92
    {
      TCursor newCurs = new _TCursor(fChanges);

      newCurs->InitialCursor(mainView, link, -1); // 06/09/92 TRUE, 0); // 23/7/92
      fChanges->fActiveEnd = newCurs;
      fChanges->fCursor = FALSE;  
    }
  }

  if (handled)
  {
#ifndef SUPER
    if (changes != NULL)
    {
      document = TTextDocument(fDocument);
      if (!(theChar == chBackspace || theChar == chReturn))
      {
        fChanges->UpdateScope(fCursor);
        fChanges->fStyleChanges = changes;
        fChanges->DoSetupLevels();
        fChanges->InstallStyleChange(fChanges->fStyleChanges, cmdNum); // 6/5/92, 11/01/91
        fChanges->fStyleChanges = NULL;
      }
      
     document->CommitStyle(NULL);
    }
#endif

    if (fCursor->fChanged 
#ifndef SUPER
        || changes != NULL
#endif
        )
    {
      fCursor->fSelection->fReformatType = 
        (ch == chReturn || ch == chFwdDelete 
#ifndef SUPER
                || changes != NULL 
#endif
                        ? kSelSlow: kReformatLine);
                // 30/6/92, 1/7/92, 23/7/92, 21/09/92 (|| changes - for Plain Justification)
      resetStyle = TRUE;
    }
    
    selection = fCursor->fSelection; // 14/7/92
    if (theChar != chReturn &&
            target == oldTarget &&  // [20862] 11/5/93 need full rfmt on join paras with fns
            target->CanTypeFast(currency))    // 18/06/95 [26018] pass currency
    {
      v.obj = NULL;
      v.procToDo = DoTextCommNote;
      mainView->fSelection = selection;
      targetFmt = mainView->GetFormatReadWrite(currency);
      result = targetFmt->Reformat(currency, cursor, cursor, -1, -1, &v);
      // [20862] 11/5/93 redundant test which did not work properly with join paras with fns
      // if (target != oldTarget)
      //   result = kHeightChg;    // 20/06/91
      if (result == kWidthChg)
      {
        targetView = mainView->FindCursorView(cursor);
        if (targetView == NULL)      // 03/03/92 for fast typing close to end of last page
        {
          fDocument->ScrollSelectionIntoView();
          targetView = mainView->FindCursorView(cursor);
          Assert(targetView, 167);
        }
        targetView->DrawChanges(FALSE, TRUE);
        mainView->NotifyDep(currency, targetView);   // 27/06/91
      }
    }
    else
      result = kNoChg;

    if (theChar == chReturn || result != kWidthChg || !target->CanTypeFast(currency)) // [26018]
    {
      TCursor saveCursor;

      // 14/7/92 test del out of table/matrix
      if ((ch == chBackspace || ch == chFwdDelete) &&
           oldTarget->fParent != target->fParent) // 17/09/92 && test redone
      {
        saveCursor = selection->GetAnchor();
        selection->InitialCursor(mainView, oldCurr, -1); // 06/09/92 TRUE, 0);
        if (ch == chBackspace)
        {
          selection->fActiveEnd = selection->GetAnchor();
          selection->fAnchor = saveCursor;
        }
        else
          selection->fActiveEnd = saveCursor;
        selection->fCursor = FALSE;
      }
      else
        saveCursor = NULL;
      selection->SetTarget();
          // 24/09/93 [21054] reset fTarget before possibly crashing in ReformatHeaderFooter
      fDocument->Reformat();
      if (saveCursor != NULL) // 14/7/92
        selection->SetTheCursor(ch == chBackspace);

      if (!target->CanTypeFast(gNullCurrency))   // 02/05/91 to update ruler in tables
                   // 18/06/95 [26018] returns False to redo menus in Maths(wrong!)/Tables
        DoType_r = TRUE;
      resetStyle = TRUE;     // 02/05/91 replaces following 2 to get BS
                             // over page to reset scales for page
    }
    fChanges->SetTarget(); // 6/3/92 fixes delete structure then return
    fDocument->ScrollSelectionIntoView();
    if (result == kStructChg)    // 02/03/92 for paras with widgets over breaks
    {
      targetView = mainView->FindCursorView(cursor);
#ifdef TRACE
      Assert(targetView, 1670);
#endif
      mainView->NotifyDep(currency, targetView);
    }
    if (!target->CanType())
      fDocument->HighlightSelection(HLOn, TRUE);     // 20/06/91
    if (resetStyle)
    {
      fCursor->fSelection->DoMenus(fSelectionReset);
#ifdef SUPER
      DoType_r = TRUE;
#endif
    }
  }
  Success(&fi);
  fSelectionReset = FALSE;  // 25/11/92
  return (DoType_r || theChar == chBackspace);

Rescue:
  UndoIt();
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
_TTextEvent::_TTextEvent(TTextDocument itsDocument) : (itsDocument)
{
#ifndef ZERO_OBJ
  fTypingCommand = 0;
  fTextSizeX = 0;
  fTextSizeY = 0;
  fLastCh = CHR(0);
#endif
}

#ifdef INDEX
// ------------------------------------------------------------------------
static void CountRecs(TObject null, TRecordIndex aRecord, TRecordHandler handler,
                                            int *totalRecs)
{
  (*totalRecs)++;
}

// ------------------------------------------------------------------------
void CountRecords(TRecordHandler recHandler, int *totalRecs)
{
  *totalRecs = 0;
  recHandler->ForAllRecordsDo(NULL, (DoToRecord)CountRecs, totalRecs);
}
#endif

// ------------------------------------------------------------------------
void _TTextEvent::DoSetupMenus()
{
  TRulerDef theStyle;
  TMainView mainView;
  int theSizeX;
  int theSizeY;
#ifdef TABLES
  int textFace;
  int allowScripts = TRUE;
#endif
#if defined MATHS || defined INDEX
  TCurrency currency;
  TCursorNode activeNode;
#endif
  TCursorNode anchorNode;
  int oldFace;
  TStyleTypes selnKind;
#ifdef TRACE
  TStyleFormat theStyleDb;
#endif

  _TTextHandler::DoSetupMenus();
  if (!MemSpaceIsLow())
  {
    mainView = fDocument->ActiveMainView();
    theStyle = mainView->GetCurrentStyle(NULL);   // theStyle, leftLimit, rightLimit);
#ifdef TRACE
    theStyleDb = TStyleFormat(theStyle);
#endif
    oldFace = TStyleFormat(theStyle)->fTextFace;  // 19/10/92
#ifndef SUPER
    if (fStyleChanges != NULL)
      TStyleFormat(theStyle)->ApplyOverride(fStyleChanges, gNullCurrency, FALSE);
#endif
    selnKind = fSelection->DoSetupMenus(TRUE);
#ifdef TABLES
    EnableCmd(cSetDateFormat);
    EnableCmd(cGotoSelection);
#endif

    if (fSelection->fEndStructure)   // 12/01/92 do not return immediately
    {
#if defined MATHS || defined INDEX
      activeNode = fSelection->GetEndStructure();
      anchorNode = activeNode;
#endif
    }
    else
    {
#ifdef FN
      TStyleTypes kind;
#endif

      anchorNode = fSelection->GetAnchorOwner();

#ifdef FN
      // 17/05/93 [20876] move footnote disables/enables from BodyEdit here
      kind = fDocument->GetStructureReadOnly(anchorNode->fCurrency)->GetKind();
#endif
      EnablePasteCmd();          // 26/06/96, 28/01/91 moved after end struct
      if (!fSelection->fCursor)  // 31/03/92 moved back from before inherited method
                                 // 17/03/93 moved after endStructure test
      {
        EnableCmd(cCopy);
#ifdef FN
        if (kind == kNoteSet)     // 17/05/93 [20876]
          DisableCmd(cPaste);     // 23/05/94 [21817] do not allow paste into note set
        else
#endif
        {
          EnableCmd(cCut);
          EnableCmd(cClear);
        }
      }

#ifdef FN
      if (kind != kFootnote)     // 17/05/93 [20876]
#endif
      {
        if (selnKind != kText || CmdEnabled(cSaveStyle))      // 18/08/93 [] ???
          EnableCmd(cChangeStyle); // 09/07/90 should be disabled if paragraph ???
      }
      SetTextMenus(TStyleFormat(theStyle), fDocument, theSizeX, theSizeY);
      fTextSizeX = theSizeX;
      fTextSizeY = theSizeY;
      // 19/11/93 [21127] Find commands moved to MainView

#ifdef THESAURUS
      // 08/03/93 [20802]
      if (gThesaurus && Curr_fType(anchorNode->fCurrency) == kTextStruct)
        EnableCmd(cFindSynonym);
#endif
#if defined MATHS || defined INDEX
      activeNode = fSelection->GetActiveOwner();
#endif
#ifdef TABLES
      // 04/04/94 moved from TDDoc - do not enable if either node in Maths
      textFace = ((TStyleFormat(theStyle)->fDefined & kFace) ?
                                          TStyleFormat(theStyle)->fTextFace : 0);
      EnableCheck(cSuperscript, TRUE, textFace & kSuperscript);
      EnableCheck(cSubscript, TRUE, textFace & kSubscript);
      EnableCheck(cAutoKern, gWimpVersion >= 316
#ifdef FN
           && kind != kMaths
#endif
              , textFace & kKerning);  // 19/07/94
#endif
#ifdef TABLES
      // 19/05/91 for MailMerge
      if (gCtrlF1)    // 13/06/93 && !fSelection->fEndStructure)
      {
        TWindow window = gApplication->GetActiveWindow();

        window->WriteText(gIDstru, GetString(kBarFieldMsg));
      }
#endif
    }
    // 19/10/92 reset the face in the main view so the next DoSetupMenus does not toggle off
    TStyleFormat(theStyle)->fTextFace = oldFace;
#if defined MATHS || defined INDEX
#if defined INDEX && !defined NETWP
    {
      int totalRecs;

      SetBookmarkMenu(fDocument, 0);  // in case no text set up
      CountRecords(fDocument->fStructureHandlers[kIndexRefStruct], &totalRecs);
      Enable(cUpdateIndex, totalRecs > (fDocument->fBookmarkRec != 0));
    }
#endif
    // 12/01/92 call the structures in the command chain to do enables
    currency = anchorNode->fCurrency;
    {
      TStructure structure = fDocument->GetStructureReadOnly(currency);
#if defined INDEX && !defined NETWP
      char key[256];

      key[0] = 0;
      structure->GetSelectedText(currency, anchorNode, activeNode, key);
      SetCmdName(cAddBookmark, key);
#endif
      structure->DoSetupMenus(currency, anchorNode, activeNode);
    }
#endif
  }
}

// ------------------------------------------------------------------------
void _TTextEvent::WriteToDialog(TView aDialogView, CmdNumber aCmd)
{
  if (aCmd == cColour)   //  [20815] colour dialogue
  {
    TRulerDef theStyle;

    theStyle = fDocument->ActiveMainView()->GetCurrentStyle(NULL);   // wrong?!!
    fColour = TStyleFormat(theStyle)->fColour;
    ResetFields(TDialogView(aDialogView), kRedraw);
    SetColPatch(TDialogView(aDialogView), kRedraw);
  }
}

// -------------------------------------------------------------------------
bool _TTextEvent::SetupDynamicMenu(CmdNumber aCmdNumber, int menuNum, bool create)
{
  return _TTextHandler::SetupDynamicMenu(aCmdNumber, menuNum, create);
}

// ------------------------------------------------------------------------
TCommand _TTextEvent::ReadFromDialog(TView aDialogView, CmdNumber aCmd, IDType choice)
{
  if (aCmd == cColour)             // [20815]
    return fDocument->MakeStyleCommand(DoColourChange, fColour);

  return gNoChanges;
}

// [20815] Do our own colour dialogue rather than using RISC_OSlib one
static IDType gColIds[3] = {I_(0, 'b', 'l', 'u'), I_(0, 'g', 'r', 'e'), I_(0, 'r', 'e', 'd')};
static IDType gSlidIds[3] = {I_('b', 'l', 'u', 's'), I_('g', 'r', 'e', 's'),
                                                     I_('r', 'e', 'd', 's')};
#define gIDpcol I_('p', 'c', 'o', 'l')
                      // 26/10/93 'scol' causes havoc in TDialogView::DoChoice!
#define gIDtcol I_('t', 'c', 'o', 'l')

// ------------------------------------------------------------------------
void _TTextEvent::ResetFields(TDialogView dialogue, bool redraw)
{
   for (int i = 0; i < 3; i++)
   {
      int this_col = (fColour >> (24 - i * 8)) & 255;

      // TControl(dialogue->FindSubView(gColIds[i]))->SetValue(((this_col * 100) + 127) / 255,
      //                                                                          redraw);
      // TControl(dialogue->FindSubView(gSlidIds[i]))->SetValue(this_col, redraw);
      dialogue->WriteValue(gColIds[i], ((this_col * 100) + 127) / 255, redraw);
      dialogue->WriteValue(gSlidIds[i], this_col, redraw);
   }
}

// ------------------------------------------------------------------------
void _TTextEvent::SetColPatch(TDialogView dialogue, bool redraw)
{
   TColourPatch showCol = TColourPatch(dialogue->FindSubView(gIDpcol));

   if (showCol != NULL)
      showCol->SetColour(fColour, redraw);
}

// ------------------------------------------------------------------------
void _TTextEvent::DoChoice(TView origView, int itsChoice)
{
   TDialogView dialogue = TDialogView(origView->GetDialogView());

   if (dialogue->fIdentifier == gIDtcol)
   {
      IDType hitIdentifier = origView->fIdentifier;
      int new_colour;
      int i;

      new_colour = 0;
      if (itsChoice == mSliderHit || itsChoice == mDownArrowHit ||
                                     itsChoice == mUpArrowHit || itsChoice == mControlHit)
      {
         int icon_val = TControl(origView)->GetValue();
         IDType otherID;
         // TControl otherControl;

         otherID = (itsChoice == mSliderHit ? hitIdentifier >> 8 : (hitIdentifier << 8) | 's');
         dialogue->WriteValueRedraw(otherID, itsChoice == mSliderHit ?
                          ((icon_val * 100) + 127) / 255 : ((icon_val * 255) + 50) / 100);

         for (i = 0; i < 3; i++)
           new_colour = (new_colour | dialogue->ReadValue(gSlidIds[i], 0)) << 8;
         fColour = new_colour;
      }
      else if (itsChoice == mScrollingListAdjust || itsChoice == mScrollingListHit)
      {
         int colours[20];
         int icon_idx;

         icon_idx = TControl(origView)->GetValue();
         FailOSErr(wr_wimp_readpalette((wr_wimp_palettestr *)colours)); 
                             // 02/11/93 use wr_wimp_rp rather than swi

         // wr_os_swi2(0x600E5, 0, (int) &colours) ;      /* XWimp_ReadPalette */
         /* copy hi-nibbles into lo-nibbles */
         // new_colour = colours[icon_idx] & 0xF0F0F000;
         // new_colour |= ((new_colour >> 4) & 0x0F0F0F00);
         fColour = colours[icon_idx] & 0xffffff00;
         ResetFields(dialogue, kRedraw);
      }
      else
        dialogue = NULL;

      if (dialogue != NULL)
         SetColPatch(dialogue, kRedraw);
   }
   _TTextHandler::DoChoice(origView, itsChoice);
}

#ifdef TABLES
#define kTimeID I_('T', 'i', 'm', 'e')
#define kLock   I_('L', 'o', 'c', 'k')
#define kDateID I_('D', 'a', 't', 'e')

static int dateFmtIds[] = { I_('S', 'h', 'r', 't'), I_('A', 'b', 'r', 'v'),
                            I_('L', 'o', 'n', 'g'), I_('C', 'u', 's', 't') };
static int timeFmtIds[] = { I_('h', 'm', '2', '4'), I_('h', 'm', '1', '2') };

// ------------------------------------------------------------------------
TCommand _TTextEvent::DoSetDateFormat()
{
  TDialogView aDialogView;
  TControl radio;
  TimeForm timeFormat;
  DateForm dateFormat;
  Str255 str;
  Str255 str1;
  TControl custText;

  // !!! move to WriteToDialog

  FailSpaceIsLow();   // !!! wrong place, should test during MenuSetup !!!
  aDialogView = TDialogView(NewTemplateWindow1(kSetDateFormatDlg));
  for (dateFormat = shortDate; dateFormat <= customDate; dateFormat++)
  {
    radio = aDialogView->WriteCheckBox(dateFmtIds[dateFormat],
                             dateFormat == fDocument->fDateFormat);
    if (dateFormat != customDate)
    {
#ifdef TRACE
      Assert(radio, 21);
#endif
      IUDateString(dateFormat, NULL, str);
      radio->SetText(str, kRedraw);
    }
  }

  if (fDocument->fCustomDate == NULL)
  {
    if (JSRead("SYS$DateFormat", str) != NULL)
      str[0] = 0;       // if fails to read, set test to empty
  }
  else
    strcpy255(str, fDocument->fCustomDate);

  custText = aDialogView->WriteText(kCstr, str);

  for (timeFormat = hm24; timeFormat <= hm12; timeFormat++)
  {
    radio = aDialogView->WriteCheckBox(timeFmtIds[timeFormat],
                             timeFormat == fDocument->fTimeFormat);
#ifdef TRACE
    Assert(radio, 21);
#endif
    IUTimeString(timeFormat, str);
    radio->SetText(str, kRedraw);
  }

  aDialogView->WriteCheckBox(kChgs, fDocument->fAlwaysUpdate);
  aDialogView->WriteCheckBox(kFixt, !fDocument->fAlwaysUpdate);
  if (aDialogView->PoseModally(cSetDateFormat) != gIDCncl)
  {
    TCluster cluster = TCluster(aDialogView->FindSubView(kDateID));
    IDType id;
    bool alwaysUpdate;
    wr_os_error *err = NULL;

#ifdef TRACE
    Assert(cluster, 21);
#endif
    id = cluster->ReportCurrent();
    for (dateFormat = shortDate; dateFormat <= customDate; dateFormat++)
      if (id == dateFmtIds[dateFormat])
        break;
    str[0] = 0;
    if (dateFormat == customDate)
    {
      custText->GetText(str);
      err = IUDateString(dateFormat, str, str1);  // 28/01/92 test for failure
      wr_wimpt_complain(err);      // 22/02/94
    }

    cluster = TCluster(aDialogView->FindSubView(kTimeID));
#ifdef TRACE
    Assert(cluster, 21);
#endif
    id = cluster->ReportCurrent();
    timeFormat = (id == timeFmtIds[1]);

    cluster = TCluster(aDialogView->FindSubView(kLock));
#ifdef TRACE
    Assert(cluster, 21);
#endif
    alwaysUpdate = (cluster->ReportCurrent() == kChgs);

    if (err == NULL &&
        (fDocument->fDateFormat != dateFormat ||
         fDocument->fTimeFormat != timeFormat ||
         fDocument->fAlwaysUpdate != alwaysUpdate ||
         (dateFormat == customDate && (fDocument->fCustomDate == NULL ||
                                strcmp(fDocument->fCustomDate, str) != 0))))
     {
       aDialogView->Close();
       return new _TSetDateFmtCmd(fDocument, dateFormat, timeFormat,
                                                alwaysUpdate, str);
     }
  }
  aDialogView->Close();
  return gNoChanges;
}
#endif

static int gLastModel = -1;
static int gCurrentPickerWindow;
static TDocument gCurrentPickerDoc;
static int gTransientPicker;

// ------------------------------------------------------------------------
static bool PickHandler(wr_wimp_eventstr *e, void *handle)
{
   if (e->e == wr_wimp_ESEND || e->e == wr_wimp_ESENDWANTACK)
   {
      wr_wimp_msgstr *msg = &e->data.msg;

      if (gCurrentPickerWindow == e->data.msg.data.words[0])
      {
         switch (msg->hdr.action)
         {
            case Message_ColourPickerChoice:    // OK pressed
               if (e->data.msg.data.words[3] >= 4)
                  gLastModel = e->data.msg.data.words[4];
               gApplication->PerformCommand(TTextDocument(handle)->
                         MakeStyleCommand(DoColourChange, e->data.msg.data.words[2]));
               return TRUE;

            case Message_ColourPickerCloseDialogueRequest:     // window cancel
               ClosePicker(TDocument(handle));
               return TRUE;
         }
      }
   }
   return FALSE;
}

// ------------------------------------------------------------------------
void ClosePicker(TDocument doc)
{
  // new proc for [22005]
  if (gCurrentPickerWindow != 0 && doc == gCurrentPickerDoc)
  {
     if (!gTransientPicker)
       FailOSErr(wr_os_swi2(0x47703 | wr_os_X, 0, gCurrentPickerWindow));
     gCurrentPickerWindow = 0;
     wr_win_remove_unknown_event_processor(PickHandler, doc);
  }
}

// ------------------------------------------------------------------------
TCommand _TTextEvent::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
  TTextDocument document = fDocument;

  if (aCmdNumber < 0)
  {
    int aMenu;
    int item;
    MenuHandle theMenu;

    aMenu = CmdToMenuItem(aCmdNumber, item);
    theMenu = *GetResMenu(aMenu);
    switch (aMenu)
    {
#ifdef TABLES
    case cmStyle:   // 11/06/90 - for clicking on emphasis entries in the Text menu
    case cmSelStyle:
      return document->DoStyleChange(aCmdNumber); // aMenu, item);
#endif
#if defined TABLES && ! defined NETWP
    case cmLanguage:  // actually the country menu on the Archimedes
      {
        char countryName[20];

        GetItem(theMenu, item, countryName);
        return document->MakeStyleCommand(DoLanguageChange, GetCountryNumber(countryName));
                 // 20/11/91 "None" handled as a command
      }
#endif

    // 15/03/91 resurrect the font menu
    case cmFontMenu:
    case cmFontSubmenu:       // 04/11/92 make the font menu semi-heirarchic
      {
        int fontNum;
        char aName[120];
        char *p = aName;

        // 04/11/92 for heirarchic dynamic font menus
        if (aMenu == cmFontSubmenu)
        {
          p += strlen(strcpyn(aName, GetMenuTitle(aMenu), 12)) + 1;
                           // pointer to termination of name, which may be "(Regular)"
        }
        GetItem(theMenu, item, p);  // 04/11/92 now read in after font name
        if (aMenu == cmFontSubmenu && strcmp(p, GetString(kDefaultFontStr)) != 0)
           *(p - 1) = '.';                         // add a '.' between title and the rest
        fontNum = document->GetFNum(aName);
        return document->MakeStyleCommand(DoFontChange, fontNum);
      }

#ifdef NETWP
    case cmColour:
      {
        int idx = GetMenuColour(theMenu, item);
        int colours[20];

        wr_wimpt_noerr(wr_wimp_readpalette((wr_wimp_palettestr *)colours)); 
        return document->MakeStyleCommand(DoColourChange, colours[idx] & 0xffffff00);
      }
#endif
    }
  }
  else switch (aCmdNumber)
  {
  // 04/04/93 Common UPicture & TextComm commands done in TDDoc
  case cParagraph:
    if (!fSelection->fEndStructure)
      return DoKeyCommand(chReturn, info);
    break;

#if TALK == 2
  case cSpeakWord:  // 15/02/93 [20700]
    return DoKeyCommand(chSpeak, info);
#endif

#ifdef THESAURUS
  // 08/03/93 [20802]
  case cFindSynonym:
    return fSelection->FindSynonym();
#endif

#if !defined TABLES || defined NETWP
  // StartWrite line spacing
  case cSingleLine:
  case cOneHalfline:
  case cDoubleLine:
    {
      int leading = (aCmdNumber - cSingleLine) / 4;

      if (leading != 0)
      {
        TStyleFormat compStyle;
        Fixed fontAscent, fontDescent, fontLeading;
    
        compStyle = TStyleFormat(document->ActiveMainView()->GetCurrentStyle(NULL));
        document->SetCurrentFont(PFontStyle(&compStyle->fTextFont));
        MeasureFont(fontAscent, fontDescent, fontLeading);
        fontAscent += fontDescent + fontLeading;
        if (aCmdNumber == cOneHalfline)
          fontAscent = fontAscent * 3 / 2;
        else
          fontAscent *= 2;
        leading -= 1;
        leading |= FixRound(fontAscent) & 0xfffffffe;    
      }
      return document->MakeStyleCommand(DoLineSpacing, leading);
    }
#endif

  // 17/06/93 [20947] put underline command in EW & TW
  case cUnderline:
    return document->MakeStyleCommand(DoUnderline, kUnderline);

#if defined TABLES && ! defined NETWP
  case cNoLanguage:
    return document->MakeStyleCommand(DoLanguageChange, 0);
#endif

#ifdef TABLES
  case cGotoSelection:
    document->ActiveMainView()->ScrollSelectionIntoView(fSelection);
    return gNoChanges;

  case cSetDateFormat:
    return DoSetDateFormat();
#endif

  case cBold:
  case cItalic:
//#ifdef SUPERCOMM
//  case cTextSuperscript:
//  case cTextSubscript:
//#endif
    return document->MakeStyleCommand(DoFaceChange, (aCmdNumber - cBold) / 4);

  case cPlain:
    return document->MakeStyleCommand(RemoveEmphasis, 0);

#ifdef TABLES
  case cAutoKern:
    return document->MakeStyleCommand(DoKernChange, cAutoKern);

  case cUpperCase:
  case cMixedCase:
  case cLowerCase:
  case cTitleCase:
    return document->MakeStyleCommand(DoCaseChange, aCmdNumber - cMixedCase);

  case cHyphenation:
    return document->MakeStyleCommand(DoHyphenate, 0);
#endif

  case cColour:
    {
      char *rsrc = GetRsrcOption('c');
      int model = '0';

      if (rsrc == NULL || (model = rsrc[0]) != '-')
      {
        int colPars[11];
        wr_wimp_eventstr *e = info.event;
        char title[50];
        wr_os_regset r;

        ClosePicker(gCurrentPickerDoc);          // 08/07/94 [22005]
        memset(colPars, 0, 44);          // 08/07/94 [22004] last 2 params reversed!
        if (e->e == wr_wimp_ESEND || e->e == wr_wimp_ESENDWANTACK)    // must be menu warning
        {
          /* this is a dbox that is actually part of the menu tree. */
          colPars[2] = e->data.msg.data.words[1];
          colPars[5] = e->data.msg.data.words[2];
          r.r[0] = 3;  // that is what !Draw passes
        }
        else
        {
          wr_wimp_mousestr m;

          wr_wimpt_noerr(wr_wimp_get_point_info(&m));
          colPars[2] = m.x - 48;     // 21/03/96 [27022] x/y coordinates were reversed
          colPars[5] = m.y + 48;
          r.r[0] = 0;         // transient = FALSE;
        }
        gTransientPicker = r.r[0];   // remember whether transient
        CmdToName(cColour, title);
        colPars[1] = (int)title;   // title
        colPars[8] =
            TStyleFormat(fDocument->ActiveMainView()->GetCurrentStyle(NULL))->fColour;
        colPars[9] = 4;      // (gLastModel >= 0 ? 4 : 0);            // remaining size
        colPars[10] = (gLastModel >= 0 ? gLastModel : model - '0');

        // open transient picker dialogue
        r.r[1] = (int)colPars;
        if (wr_os_swix(0x47702, &r) == NULL)
        {
           wr_win_add_unknown_event_processor(PickHandler, fDocument);
           gCurrentPickerWindow = r.r[0];
           gCurrentPickerDoc = fDocument;  // [22005]
           return gNoChanges;
        }
      }
    }
    return DoDialogue(this, aCmdNumber, kColourDlg, -1);

#if defined INDEX && !defined NETWP
  case cAddToIndexI:     // adj on add index button
    if (CmdEnabled(aCmdNumber))
      break;
    aCmdNumber = cUpdateIndex;
  case cAddToIndex:
  case cUpdateIndex:
    {
      THandler helper = new _TIndexDlgHelper(fDocument);
      TCommand cmd = DoDialogue(helper, aCmdNumber,
                            aCmdNumber == cUpdateIndex ? kUpdateIndexDlg : kAddToIndexDlg, -1);

      FreeIfObject(helper);
      return cmd;
    }
#endif

  default:
    if (aCmdNumber >= cWriteableSize && aCmdNumber <= cHighestText)
    {
      char menuText[20];
      int theSize;

      CmdToName(aCmdNumber, menuText);
      if (aCmdNumber == cWriteableSize)  // 16/05/91 allow n.m & check value
      {
        Fixed pts;

        if (CvtStrToPoints(menuText, ePoint16, 12, 0, pts) != kValidValue ||
                 (theSize = (FixMul(16, pts) + 5) / 10, theSize < 1))  // 19/01/94 round up
          return gNoChanges;
      }
      else
      {
        theSize = atoi(menuText) << 4;             // convert to 1/16ths
      }
      return (theSize ?
          document->MakeStyleCommand(DoSizeChange, theSize) : gNoChanges);
    }
  }

  if (aCmdNumber != cUndo && aCmdNumber != cUndoDescription)  // 01/12/92 && ...
    document->CommitStyle(TCommand(-1));
  return _TTextHandler::DoMenuCommand(info, aCmdNumber);
}


// ------------------------------------------------------------------------
TCommand _TTextEvent::DoCommandKey(int chcode, EventInfo &info)
// 19/05/92 new for ^F1 handling
{
#ifdef TABLES
  if (chcode == 0x1a1)  // Ctrl-F1
  {
    gCtrlF1 = !gCtrlF1;
    info.affectsMenus = TRUE;
    fSelection->DoSetupLevels();
    return gNoChanges;
  }
#endif

  return _TTextHandler::DoCommandKey(chcode, info); 
}

// ------------------------------------------------------------------------
TCommand _TTextEvent::DoKeyCommand(int ch, EventInfo &info)
{
  TCommand  DoKeyCommand_r;

#ifdef TABLES
  // 19/05/92 MailMerge keyboard shortcut for selecting from menu
  if (gCtrlF1)
  {
    CmdNumber cmd = ch - '1';

    gCtrlF1 = FALSE;
    if ((ch >= '1' && ch <= '9') ||
                     (cmd = ch - 'a' + 9, ch >= 'a' && ch <= 'z') ||
                     (cmd = ch - 'A' + 9, ch >= 'A' && ch <= 'Z'))
    {
      int aMenu;
      int anItem;
      int totalItems;

      aMenu = CmdToMenuItem(cMergeSide, anItem);  // the item before the fields
      totalItems = CountMItems(*GetResMenu(aMenu));
      // check if key within the menu & the entry is not the dummy disabled one
      if (anItem + cmd < totalItems &&
          (cmd = CmdFromMenuItem(aMenu, anItem + cmd), CmdEnabled(cmd)))
        return _TTextEvent::DoMenuCommand(info, cmd);
    }
    info.affectsMenus = TRUE;
    SysBeep(0);
    return gNoChanges;
  }
#endif

  if (ch >= 0x180 && ch < 0x200)              // 30/06/95 for smart quotes
    return _TTextHandler::DoKeyCommand(ch, info);   // 06/04/94

  DoKeyCommand_r = gNoChanges;

#ifdef FN
  if ((fControlChars & (1 << 5)) != 0)           // [20984] note body selected
#endif
  {
    if ((ch < 32) && (fControlChars & (1 << ch)) != 0)
      return _TTextHandler::DoKeyCommand(ch, info);

    if (fTypingCommand == NULL)
    {
      if (fSelection->fEndStructure)
      {
        if (ch == chReturn)
          DoKeyCommand_r = DoMenuCommand(info, cParagraph);
        else
          SysBeep(0);
      }
      else
        DoKeyCommand_r = DoMakeTypingCommand(ch, info);
    }
    else
    {
      // 12/07/91 new block to commit after joining 2 paras
      // 04/10/93 [21062] moved from DoType (where it did not, eg MarkToTop) so here it will
      // set DoneTyping as well as forcing a Commit
      if ((ch == chReturn || ch == chFwdDelete) && GetTargetLink(fDocument->  // 23/7/92
          GetStructureReadOnly(fSelection->GetAnchorOwner()->fCurrency)) != 0)
      {
        DoneTyping();
        DoKeyCommand_r = DoMakeTypingCommand(ch, info);
      }
      else if (ch == chBackspace || TypingAllowed())   // 05/08/92 test backspace .. even if
                                                  // Typing not Allowed it seems to do b/s
      {
        if (fLastCh == chReturn)    // 16/06/91 instead of ch
        {
          DoneTyping();
          DoKeyCommand_r = DoMakeTypingCommand(ch, info);
        }
        else
          info.affectsMenus = TTypingCommand(fTypingCommand)->DoType(ch);
      }
      else
        fTypingCommand = NULL;
    }
    fLastCh = ch;  // 16/06/91: moved down
  }
  return DoKeyCommand_r;
}


// ------------------------------------------------------------------------
TCommand _TTextEvent::DoMakeTypingCommand(int ch, EventInfo &info)
{
#ifndef MATHS
  if (!fCanType)
  {
    SysBeep(0);
    return gNoChanges;
  }

//  if (ch != chBackspace && !TypingAllowed())   // 03/08/92 order swapped to stop Beep on BS
//    return gNoChanges;

  // 21/03/91 do not overtype if selection changed
  if (ch != chBackspace)
  {
    if (!TypingAllowed())   // 03/08/92 moved into bs test to stop Beep on BS
      return gNoChanges;

    if (!fSelection->fCursor)
    {
#ifdef DRAGDROP
      TCommand lastCommand = fDocument->fLastCommand;
#else
      TCommand lastCommand = gLastCommand;
#endif

      if (!fDocument->fSelectionChanged && lastCommand != NULL &&
#ifndef DRAGDOP
                 lastCommand->fChangedDocument == fDocument &&  // 17/04/91
#endif
                 lastCommand->fCausesChange && lastCommand->fCmdDone)
      {
        fDocument->HighlightSelection(HLOff, TRUE);
        fSelection = fDocument->CloneSelection();                       // 17/04/91
        // fSelection = fDocument->GetNewSelection();
        fSelection->SetTheCursor(FALSE);
        fDocument->ActiveMainView()->SetTheCursor(TRUE);
        if (gSelNewStructs)           // 14/07/93 [20982] Select new structures
          fSelection->DoMenus(TRUE);
      }
    }
  }

  if (!fSelection->fCursor && info.event->e == wr_wimp_EKEY)
  {
    CmdNumber cmdNum = cCut;

    if (info.event->data.key.chcode == 127 || (cmdNum = cCopy, ch == chFwdDelete))
      return fDocument->DoMenuCommand(info, cmdNum);   // 24/08/94 [22018]
  }

  fDocument->ScrollSelectionIntoView();
  if ((ch < 32) && (fControlChars & (1 << ch)) != 0)   // 12/07/91
    return _TTextHandler::DoKeyCommand(ch, info);
  fTypingCommand = new _TTypingCommand(fDocument, this, ch);
  return fTypingCommand;
#else
  return gNoChanges;
#endif
}


// ------------------------------------------------------------------------
void _TTextEvent::DoneTyping()
{
  register TTypingCommand typeCom = TTypingCommand(fTypingCommand);

  if (typeCom != NULL)
  {
    fTypingCommand = NULL;
    typeCom->DoneTyping();
  }
}
