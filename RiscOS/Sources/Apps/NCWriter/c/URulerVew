/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <locale.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include "os.h"
#include "akbd.h"
#include "swis.h"
#include "bbc.h"
#include "dbox.h"

#include "UDialog.h"
#include "URulerVew.h"

#define kSlop 80

#define kRtIndentation (kIndentation + 1)
#define kSpriteHot 24
#define kHot (kSpriteHot * kFix1)
        // distance from sprite left to active point

IDType gRuleIDs[4] = { I_('s', 'c', 'r', 'o'), I_('v', 's', 'c', 'a'),
                       I_('w', 'e', 'l', 'l'), I_('r', 'u', 'l', 'e')};

static IDType gTabIds[4] = { I_('l', 't', 'a', 'b'), I_('r', 't', 'a', 'b'),
                             I_('c', 't', 'a', 'b'), I_('d', 't', 'a', 'b')};

#define gIDtabs I_('t', 'a', 'b', 's')
#define gIDgrey I_('g', 'r', 'e', 'y')
#define gIDhalf I_('h', 'a', 'l', 'f')

#ifdef TABLES
#define gIDrmov I_('r', 'm', 'o', 'v')
#define gIDfPos I_('f', 'P', 'o', 's')
#define gIDDecP I_('D', 'e', 'c', 'P')
#define gIDTFil I_('T', 'F', 'i', 'l')
#define gIDpPos I_('p', 'P', 'o', 's')

// ids for kLeftTab, kCentreTab, kRightTab, kMarkTab; plus move left
static int tabViewIds[] = { I_('L', 'R', 'a', 'd'), I_('C', 'R', 'a', 'd'),
    I_('R', 'R', 'a', 'd'), I_('D', 'R', 'a', 'd'), I_('l', 'm', 'o', 'v'), 0};
#endif

// -------------------------------------------------------------------------
_TTabView::_TTabView(TView superview,
                     TRulerScale itsRulerView,
                     Fixed itsPosition,
                     TTabType itsKind,
                     int defIdx)
                     : (superview, gZeroVPt, GetIndString(3, itsKind))
{
   VPoint itsLocation;

   itsRulerView->LocateOnRuler(itsPosition, itsLocation);
   Locate(itsLocation.h, itsLocation.v, FALSE);

   fSelect = (itsKind >= 20);
   fItsKind = itsKind;
   fRulerView = itsRulerView;
#ifndef ZERO_OBJ
   fInTabWell = FALSE;
#endif
   fDefIndex = defIdx;
   fRulerOffset = itsPosition;
}


// -------------------------------------------------------------------------

_TTabView::_TTabView(TDocument itsDocument,
                     TView itsSuperView, 
                     char* &params)
                     : (NULL, itsSuperView, params)
{
   fItsKind = fIcon; // 13/03/96 ReadInt(params);
   fIcon = 0;     // 13/03/96 bit of a frig; last param already read into fIcon by TSprite ctor

   fSelect = (fItsKind >= 20);
   fInTabWell = (itsSuperView->fIdentifier == gIDwell);
   fRulerView = TRulerScale(GetWindow()->FindSubView(gIDrule));
   fNextHandler = fRulerView;
#ifndef ZERO_OBJ
   fDefIndex = 0;
   fRulerOffset = 0;
#endif
}


// -------------------------------------------------------------------------
void _TTabView::Open()
{
   // 29/04/91 moved from ctor
   int myRgt = fLocation.h + fSize.h;

   if (fInTabWell && myRgt > fSuperView->fSize.h)
     fSuperView->fSize.h = myRgt;

   _TSprite::Open();
}


// -------------------------------------------------------------------------
void _TTabView::GetTabInfo(TFTabInfo &tabInfo)
{
   TRulerDef theRulerDef;

   if (fDefIndex != 0)
      fRulerView->fRulerDef->Get(fDefIndex, &tabInfo);
   else
   {
      ITabInfo(tabInfo);
      tabInfo.fStop = fRulerOffset;

      if (fItsKind < kLeftMargin)
      {
         tabInfo.fKind = TTabKind(fItsKind);
         if (!fInTabWell)
         {
            theRulerDef = fRulerView->fRulerDef;
            if (theRulerDef != 0)
               theRulerDef->GetTabInfo(tabInfo.fKind,tabInfo.fStop,tabInfo);
         }
      }
   }
}


// -------------------------------------------------------------------------
void _TTabView::SelectState(bool state, bool redraw)
{
   CheckThis();
   if (state != fSelect)
   {
      if (redraw && fShown && Focus())
      {
         Plot(gZeroPt, plotXor);
      }
      else
         redraw = FALSE;

      fSelect = state;

      if (redraw)
         Plot(gZeroPt, plotXor);
   }
}


// -------------------------------------------------------------------------
void _TTabView::TotalUp(TTabView theTab, int &selectedTotal, bool &userTabsOnly)
{
   if (theTab->fSelect && theTab->IsShown())
   {
      selectedTotal++;
      userTabsOnly = (userTabsOnly && (int(theTab->fItsKind) <= int(kMarkTab)));
   }
}


// -------------------------------------------------------------------------
static void ResetTabViews(TRulerScale self, TTabView theTab, TView origView)
{
  // 29/02/96 [] Added - seems to have been omitted in conversion from Mac in 1991
  if (theTab != origView )
    theTab->SelectState(FALSE, kRedraw);
}


// -------------------------------------------------------------------------
TCommand _TTabView::DoMouseCommand(Point &theMouse, EventInfo &info)
{
   VPoint      viewPt;
   bool        needTracker;
   bool        newState;
   int         selectedTotal = 0;
   bool        userTabsOnly = TRUE;
   int         i;

#ifdef TABLES
   if (info.theClickCount > 1 && !info.rightButton)
   {
      SelectState(!fInTabWell, kRedraw);
      fRulerView->EachSubview(this, (DoToSubView)_TTabView::TotalUp,
                                                      &selectedTotal, &userTabsOnly);
      return fRulerView->DoDialog(selectedTotal > 1 ? cMultiTabMove :
                                                      cGetTabInfo + fInTabWell, this);
   }
#endif

#ifdef DRAGDROP
   if (info.theClickCount > 0)     // 23/03/93 ignore dragdrop tracker
#endif
   {
      TWindow theWindow = GetWindow();

      needTracker = TRUE;

      // deselect others in the tab well (even though Adjust used)
      for (i =  0; i < 4; i++)
      {
         TTabView wellTab = TTabView(theWindow->FindSubView(gTabIds[i])); // 22/05/91

         if (wellTab != NULL)
           ResetTabViews(NULL, wellTab, this);
      }
      newState = IsSelected();
      QDToViewPt(theMouse, viewPt);
      if (fInTabWell)
      {
         fRulerView->EnsureTarget();
         fRulerView->DoChoice(this, mSicnHit);
         newState = TRUE;
         viewPt.h -= 3;     // 10/04/91 frig for dragging out of well
      }
      else if (info.rightButton)
      {
         if (newState)
         {
            needTracker = FALSE;
            fRulerView->SelectTab(this, FALSE);
         }
         newState = !newState;
      }
      else if (!newState)
      {
         DoChoice(this, mSicnHit);    // deselect the others on ruler
         newState = TRUE;
      }

      SelectState(newState, kRedraw);
      if (needTracker)
      {
         fRulerView->SelectTab(this, TRUE);
         fRulerView->EachSubview(this, (DoToSubView)_TTabView::TotalUp,
                              &selectedTotal, &userTabsOnly);
         return new _TTabTracker(fRulerView, this, viewPt, userTabsOnly);
      }
   }
   return(gNoChanges);
}


// -------------------------------------------------------------------------
_TTabPosition::_TTabPosition(TDocument itsDocument,
                             TView itsSuperView,
                             char* &params)
                           : (itsDocument, itsSuperView, params)
{
#ifndef ZERO_OBJ
   fRulerView = NULL;
   fTabDialog = NULL;
   fHaveWarned = FALSE;
#endif
}


// -------------------------------------------------------------------------
TValidationResults _TTabPosition::ValValue()
{
#ifdef TABLES
   TConstraints constraint;
   Fixed        fixedVal;
   Fixed        fixedPts = fCurrentValue;
   bool         negated = FALSE;
   bool         absolute = FALSE;
   int          idx;
   TFTabInfo    info;
   TSelType     selType;

   if (fTabDialog != NULL)
   { 
      register TTabDialog tabDia = fTabDialog;
  
      absolute = tabDia->fAbsolute;
      if ((tabDia->fCurrentRadio != NULL) &&
          (tabDia->fCurrentRadio->fIdentifier == tabViewIds[4]))
      {
         fixedPts = -(fixedPts);
         negated = TRUE;
      }
   }
   fixedVal = fixedPts;
   if (fRulerView != NULL)
   { 
      register TRulerScale rulView = fRulerView;

      if (absolute && (rulView->fRulerDef != 0))
      {
         selType = rulView->fSelectionDef->GetSelCmdIndex();
         idx = 0;
         if (selType == kColOnly)
         {
            info = fTabDialog->fSavedInfo;
            idx = rulView->fRulerDef->IsPresent(info);
         }
         fixedVal = rulView->fRulerDef->ConstrainTab(fixedVal, idx, selType,
                             rulView->GetRulerWidth(), 0, rulView->fTextDirection);
      }
      else
         rulView->ConstrainTabs(fixedVal, constraint);
   }
   if (fixedPts != fixedVal)
   {
      if (negated)
         fixedVal = -(fixedVal);
      SetPoints(fixedVal, kRedraw);
      fHaveWarned = TRUE;
      if ((fixedPts > fixedVal) != negated)
         return(kValueTooLarge);
      else 
         return(kValueTooSmall);
   }
#endif
   return(kValidValue);
}

#ifdef TABLES
// -------------------------------------------------------------------------
void _TTabPosition::SetConstrainer(TRulerScale theConstrainer, TTabDialog tabDialog)
{
   fRulerView = theConstrainer;
   fTabDialog = tabDialog;
}
#endif


#ifdef TABLES
// -------------------------------------------------------------------------
_TTabDialog::_TTabDialog(TDocument itsDocument, TView itsSuperView, char* &params) : (itsDocument, itsSuperView, params)
{
#ifndef ZERO_OBJ
   fCurrentRadio = NULL;
#endif
}


// -------------------------------------------------------------------------
void _TTabDialog::HaveTabInfo(CmdNumber aCmdNumber, TRulerScale theRuler, TFTabInfo &tabInfo, VCoordinate origin)
{
   TScale scale = theRuler->fScale;
   int    menuId;
   char   aStr[2];
   TabFiller filler;   // put a terminator on filler

   fAbsolute = (aCmdNumber != cMultiTabMove);
   if (scale == eInches)
      menuId = 1;
   else
      menuId = int(scale);

   fScalePopup = TScrollingList(FindSubView(gIDpPos));
   if (fScalePopup != NULL) {
      fScalePopup->SetValue(menuId, kRedraw);
      fScalePopup->ScrollListTo(menuId, kRedraw);
   }
   strcpyn(filler, tabInfo.fFiller, kFillerLen);
   fTabFiller = WriteText(gIDTFil, filler);

   aStr[0] = tabInfo.fMark;
   aStr[1] = '\0';
   fDecTabChar = WriteText(gIDDecP, aStr);

   fPositionView = TTabPosition(FindSubView(gIDfPos));
   if (fPositionView != NULL)
   {
      if (fAbsolute)                       // 10/04/91
        fPositionView->SetOrigin(origin);
      fPositionView->SetScale(scale, theRuler->fCustomPoints, kDontRedraw);
      if (((aCmdNumber >= cLeftMarginDialog) && (aCmdNumber <= cTabChange))
          || (aCmdNumber == cGetTabInfo))
         fPositionView->SetPoints(tabInfo.fStop, kRedraw);
      fPositionView->SetConstrainer(theRuler, this);
   }

   if (tabInfo.fKind != kNoTab)
      // ids for kLeftTab, kCentreTab, kRightTab, kMarkTab
      fCurrentRadio = (TRadio)WriteCheckBox(tabViewIds[tabInfo.fKind], TRUE);

   fSavedInfo = tabInfo;
}


// -------------------------------------------------------------------------
void _TTabDialog::ReInitPosition()
{
   if (fPositionView != NULL)
      DoSelectEditText(fPositionView /* , TRUE */);
}


// -------------------------------------------------------------------------
void _TTabDialog::ReadTabInfo(TFTabInfo &tabInfo)
{
   char aStr[20];
//   IDType radID; 

   if (fPositionView != NULL)
      tabInfo.fStop = fPositionView->GetValue();
   if (fTabFiller != NULL)
   {
      fTabFiller->GetText(aStr);
      strncpy(tabInfo.fFiller, aStr, kFillerLen);
   }
   if (fDecTabChar != NULL)
   {
      fDecTabChar->GetText(aStr);
      if (strlen(aStr) > 0)
         tabInfo.fMark = aStr[0];
   }
   if (fCurrentRadio != NULL)
   {
      int btn = LookupID(fCurrentRadio->fIdentifier, tabViewIds);

      if (btn >= 0)        // in the tabViewIds list (not 'rmov')
      {
        if (btn < 4)
          tabInfo.fKind = btn;
        else
          tabInfo.fStop = -(tabInfo.fStop);      // radID == 'lmov'
      }
   }  
}


// -------------------------------------------------------------------------
void _TTabDialog::DimDecTab(int dimOut)
{
   if (dimOut && (fCurrentEditText == fDecTabChar))
      DoSelectEditText(fPositionView);
   fDecTabChar->DimState(dimOut, kRedraw);
}


// -------------------------------------------------------------------------
void _TTabDialog::DoChoice(TView origView, int itsChoice)
{
   if (itsChoice == mRadioHit)
   {
      if (fDecTabChar != 0)
         DimDecTab(origView->fIdentifier != tabViewIds[3]);
      fCurrentRadio = TRadio(origView);
      if ((origView->fIdentifier == gIDrmov) ||
                                (origView->fIdentifier == tabViewIds[4]))
         fPositionView->ForceRevalidation();
   }
   _TDialogView::DoChoice(origView, itsChoice);
}
#endif


// -------------------------------------------------------------------------
// 28/02/96    -- Layout of the Horizontal Ruler Pane --
//
// This is the modified layout now that the ruler pane is borderless, and needs to
// draw its own line under the bottom of the tab area.
//
// Top               _____________________________________________________ 0
//                   
//
//                   |           |           |             |            |
//                   _____________________________________________________ 160 or 152
// fRulerRect.top    _____________________________________________________ 176
//
//
//
// bottom line       _____________________________________________________ 304
// fRulerRect.bottom _____________________________________________________ 320 or 312
//
// The template size is 320 (40 or 20 pixels). If hi-res and not anti-twittering,
// the size is reduced by 1 pixel so there is only a one pixel line at bottom.
// The top of the ruler should always be 176 (which is the size when the ruler
// is shrunk down to hide the tab area). The ruler scale markings are built above
// this fixed position (1 pixel bottom line, and fixed size ruler divisions) in the
// 11 or 22 pixels above.
// Below fRulerRect.top is the area for the tab sprites which is 128 deep (fInset - 16)
// which must correspond to the height defined for the tab sprites.
// below that is drawn the base line. For anti-twittering it is 2 pixels deep. A dark
// line on top and a light line underneath, so the anti-twittering module has a line
// to use within the window. Of course in low-res, the line will take the whole space
// anyway
// -------------------------------------------------------------------------


// -------------------------------------------------------------------------
_TRulerScale::_TRulerScale(TDocument itsDocument,
                           TView itsSuperView,
                           char * & params)
                           : (itsDocument, itsSuperView, params)
{
#ifndef ZERO_OBJ
   fRulerDef = NULL;
   fSelectionDef = NULL;
   fLastCommand = NULL;
   fOrigin = 0;
   fTabDragPosition = NULL;
   fTarget = NULL;
   fActiveTab = NULL;
   fLeftEdge = 0;
   fRightEdge = 0;
   fTextDirection = 0;
   fWhichWay = v;
#endif
   fMousePosition = MAXLONGINT;

   fInset = ReadInt(params);
   *((int *)&fScaleMetrics) = ReadHex(params);
   fScale = gUnits;
   fCustomPoints = gCustomPoints;
   fMagnification = kFix1;
   itsSuperView->GetExtent(fRulerRect);

   if (fIdentifier == gIDvsca)
      fRulerRect.left = fRulerRect.right;
   else
   {
#ifdef NEWRULE
      // 20/01/91 plug in ruler
      THandler scroller;

      scroller = itsSuperView->GetWindow()->FindSubView(gIDscro);
      if (scroller != NULL)
      {
         fNextHandler = scroller->fNextHandler;
         scroller->fNextHandler = this;
      }
#endif
      fRulerRect.top = fRulerRect.bottom - fInset;
      fWhichWay = h;
   }
}

// -------------------------------------------------------------------------
void _TRulerScale::Free()
{
   MakeActive(FALSE);      // 24/05/90 free keyuphandler & fSelectionDef
   FreeIfObject(fSelectionDef);    // 06/06/91 MakeActive does not free fS.d.
   FreeIfObject(fRulerDef);

   _TScroller::Free();
}

// -------------------------------------------------------------------------
TCommand _TRulerScale::MakeDelCmd()
{
   return new _TTabDeleteCommand(this);
}


// -------------------------------------------------------------------------
void _TRulerScale::LocateOnRuler(Fixed rulerPosition, VPoint &location)
{
   SetVPt(location, FixRound(FixMul(rulerPosition, fMagnification) - kHot + fLeftEdge),
                                  fRulerRect.top); // ZZ + 16);
}


// -------------------------------------------------------------------------
Fixed _TRulerScale::LocToOffset(VPoint &location)
{
   return(FixDiv(ToFixed(((VCoordinate *)&location)[fWhichWay]) + kHot - fLeftEdge,
                                                                     fMagnification));
}


// -------------------------------------------------------------------------
void _TRulerScale::EnsureTarget()
{
   TWindow theWindow = GetWindow();

   if (theWindow->fTarget != this)
   {
      fTarget = theWindow->fTarget;
      fHLDesired = HLOff;
      theWindow->SetTarget(this);
      // ??? 21/01/91      ForceRedraw();
   }
   if (fSelectionDef == NULL)
      InitSelection();
   if (CountSubViews() == 0)
      InstallTabViews(TRUE);
   theWindow->fWindowRecord.LocateCaret(gZeroPt, 0);     // 22/05/91
}


// -------------------------------------------------------------------------
void _TRulerScale::InitSelection()
{
   ReplaceObject(fSelectionDef, new _TRulerDef(-1, -1, -1));
}


// -------------------------------------------------------------------------
void _TRulerScale::MakeActive(int entering)
{
   if (entering)
      InitSelection();
   else 
   {
      InstallTabViews(FALSE);
      if (fActiveTab != NULL)
         fActiveTab->SelectState(FALSE, kRedraw);
      fActiveTab = NULL;
   }
}


// -------------------------------------------------------------------------
void _TRulerScale::SetLimits(VRect &edges)
{
   VCoordinate oldLeft = fLeftLimit;
   VCoordinate oldRight = fRightLimit;

   fLeftLimit = edges.topLeft->vh[fWhichWay];
   fRightLimit = edges.botRight->vh[fWhichWay];
   if (oldLeft != fLeftLimit || oldRight != fRightLimit)
   {
      // 02/09/94 do AddInvVRect in case called in redraw: ForceRedraw();
      VRect viewRect;

      GetExtent(viewRect);
      AddInvalidVRect(viewRect);
      ShowSelection();
      RelocateTabs();
   }
}


// ------------------------------------------------------------------------
void _TRulerScale::SubViewChangedSize(TView theSubView, VPoint &delta)
{
   // 11/06/90 - new to stop tab creation resizing ruler work area
}


// -------------------------------------------------------------------------
void _TRulerScale::DrawTheLine(VRect &extentRect)
{
  if (fMousePosition != MAXLONGINT)
  {
    if (fWhichWay == h)
    {
      int lineThick = GetHLineThickness();
      int lineDepth = Min(fRulerRect.top - lineThick, extentRect.bottom) - extentRect.top; // ZZ

      if (lineDepth > 0)
      {
        MoveTo(fMousePosition, extentRect.top + lineThick);
        Line(0, lineDepth - lineThick);
      }
    }
    else
    {
      MoveTo(0, fMousePosition);
      Line(extentRect.right, 0);
    }
  }
}

#ifdef TABLES
// -------------------------------------------------------------------------
void _TRulerScale::DrawMouseLine(int position, VRect *extentRect)
{
  {
    int oldPosition = fMousePosition;

    PenMode(patXor);
    PenPat(15);                            // 04/09/90 draw in cyan
    DrawTheLine(*extentRect);
    fMousePosition = position;
    DrawTheLine(*extentRect);
    fMousePosition = oldPosition;
  }
}


// -------------------------------------------------------------------------
void _TRulerScale::DrawMousePosition(int position)
{
  // new 4/6/90
  if (Focus())
  {
    VPoint tempPt;

    tempPt.h = position;
    tempPt.v = position;
    thePort->GlobalToLocal(tempPt);
    position = tempPt.vh[fWhichWay];

    if (position != fMousePosition)
    {
      VRect scaleRect;

      GetExtent(scaleRect);
      NoNH_DoInUpdate(scaleRect, (DrawProc)_TRulerScale::DrawMouseLine,
                                                     position, &scaleRect);
      fMousePosition = position;
    }
  }
  else
    fMousePosition = MAXLONGINT;
}
#endif


// ------------------------------------------------------------------------
void _TRulerScale::DoHighlightSelection(HLState fromHL, HLState toHL)
{
#ifdef TABLES
   VRect scaleRect;
   int position = fMousePosition;

   fMousePosition = MAXLONGINT;    // suppress erasing the old position
   GetExtent(scaleRect);
   NoNH_DoInUpdate(scaleRect, (DrawProc)_TRulerScale::DrawMouseLine,
                                                     position, &scaleRect);
   fMousePosition = position;      // restore current position
#endif
}

// -------------------------------------------------------------------------
VCoordinate _TRulerScale::GetConversionOrigin(void)
{
  return fOrigin -
    FixRound(FixDiv(fLeftEdge - ToFixed(fLeftLimit), fMagnification));
}

#ifdef TABLES
// -------------------------------------------------------------------------
void _TRulerScale::ResetOrigin()
{
   if (fOrigin != 0)
   {
      fOrigin = 0;
      ForceRedraw();
   }
}


// -------------------------------------------------------------------------
void _TRulerScale::SetScaleOrigin(long origin)
{
   origin = FixDiv(origin - TruncateToPixel(fLeftLimit, fWhichWay - 4), fMagnification);
                              // 04/03/96 ZZ trunc
   if (fOrigin != origin)     // 01/03/96 avoid redraw if no change
   {
      fOrigin = origin;
      ForceRedraw();
   }
}
#endif

// -------------------------------------------------------------------------
bool _TRulerScale::PtInRulerRect(VPoint &thePoint, Fixed slop,
                                                        bool checkMargins)
{
   bool inHorizStrip = ((fRulerRect.top - slop < thePoint.v) &&
                    (fRulerRect.bottom + slop >= thePoint.v));

   if (checkMargins)
      return(inHorizStrip && (FixRound(fLeftEdge) - slop) < thePoint.h && 
                             (FixRound(fRightEdge) + slop) >= thePoint.h);
   else
      return inHorizStrip;
}


// -------------------------------------------------------------------------
int _TRulerScale::IsRulerShown()
{
   return (fWhichWay == h && fRulerRect.top < fRulerRect.bottom);
   // replaced by faster test: return(!EmptyVRect(fRulerRect));
}


// -------------------------------------------------------------------------
void _TRulerScale::Resize(VCoordinate width, VCoordinate height, int invalidate)
{
   if (fWhichWay == h)
     fRulerRect.bottom = height;
     // NB be careful to pass height as rulerRect.top to get sRulerShown to return FALSE
   else
     fRulerRect.left = width;    // 08/03/96 used as right edge of vertical scale

   _TScroller::Resize(width, height, invalidate);
   // if (fWhichWay == h)
   //   fRulerRect.bottom = fSize.v;
}


// -------------------------------------------------------------------------
void _TRulerScale::SetScrollLimits(VRect &scrollLimit)
{
   _TScroller::SetScrollLimits(scrollLimit);

   // 4/6/90 fRulerRect should extend the whole width, not just fSize
   if (fWhichWay == h)
   {
     fRulerRect.right = Max(fScrollLimit.right, fSize.h);
          // 12/07/90 fSize can be bigger than scroll limit when zoomed down
     fRulerRect.left = fScrollLimit.left;    // 06/03/96 ZZ
   }
}


#ifdef TABLES
// -------------------------------------------------------------------------
void _TRulerScale::WriteToDialog(TView aDialogView, CmdNumber aCmd)
{
   TTabDialog aDialog = TTabDialog(aDialogView);

   aDialog->HaveTabInfo(aCmd, this, aDialog->fSavedInfo, GetConversionOrigin());
}


// -------------------------------------------------------------------------
TCommand _TRulerScale::ReadFromDialog(TView aDialogV, CmdNumber aCmd, IDType itsID)
{
  TTabDialog aDialogView = TTabDialog(aDialogV);

  if (itsID == gIDOKbn)
  {
    TFTabInfo aTab, bTab;
    bool changed;

    bTab = aDialogView->fSavedInfo;
    aTab = bTab;
    aDialogView->ReadTabInfo(aTab);
 
    changed = (aTab.fStop != bTab.fStop || aTab.fKind != bTab.fKind ||
               strncmp(aTab.fFiller, bTab.fFiller, kFillerLen) != 0 ||
               aTab.fMark != bTab.fMark);

    // this following bit is for adding tabs, with the ability to
    // CANCEL all of the ones added - reinstated 24/05/91

    if (aCmd == cNewTabDialog && wr_dbox_persist())
    {
      if (changed)
      {
        TTabView newTab;

        fSelectionDef->InstallTab(aTab);
        aDialogView->fMenuTreeExists = 0;
        // 31/05/91 frig to stop DoSetupMenus being called and deleting tabs

        //     inline BuildTab(aTab.fKind, aTab.fStop);
        newTab = new _TTabView(this, this, aTab.fStop, int(aTab.fKind), 0);
        AddSubView(newTab);  // 14/07/94 [22006] leaves handle
        newTab->SelectState(TRUE, kDontRedraw);
        newTab->DrawContents();
        //     end inline BuildTab
        aDialogView->fSavedInfo = aTab;
      }
      aDialogView->ReInitPosition();
      return gNoChanges;
    }

    if (aCmd == cNewTabDialog || changed)
    {
      if (aCmd >= cLeftMarginDialog && aCmd <= cColMarkMove)
        aDialogView->fSavedInfo = aTab;

      return(MakeCommand(aCmd, TRUE, TRUE, bTab.fStop, aTab, FALSE, kRedraw));
    }    
  }
  return gNoChanges;
}


// -------------------------------------------------------------------------
static void SetTheTab(TObject null, TTabView aTab, TTabView *theTab)
{
   if (aTab->fSelect)
     *theTab = aTab;
}

// -------------------------------------------------------------------------
TCommand _TRulerScale::DoDialog(CmdNumber aCmdNumber, TTabView theTab)
{
   TTabDialog aDialogView;
   TFTabInfo bTab;
   TFTabInfo aTab;
   IDType dlogRes;
   TRulerDef oldSelection = 0;
   int dlogId;

   if (aCmdNumber == cNewTabDialog)
   {
      oldSelection = fSelectionDef;
      fSelectionDef = NULL;
      InitSelection();
      DrawTabs();
   }

   if (CountSubViews() == 0)
      InstallTabViews(TRUE);

   if ((theTab == NULL) && (aCmdNumber == cGetTabInfo))
      EachSubview(NULL, (DoToSubView)SetTheTab, &theTab);

   if ((theTab != NULL) && (aCmdNumber != cMultiTabMove))
      theTab->GetTabInfo(bTab);
   else
      ITabInfo(bTab);

   if (aCmdNumber == cGetTabInfo)
   {
      aCmdNumber = cLeftMarginDialog + int(fSelectionDef->GetSelCmdIndex());
      if (aCmdNumber == cLeftMarginDialog - 1)
         return(gNoChanges);  // 04/07/94 nothing selected, avoid spurious tab move dialogue
   }

   dlogId = (aCmdNumber == cMultiTabMove ?
     kMoveDialog : (aCmdNumber == cNewTabDialog || aCmdNumber == cTabChange ?
     kNewTabDialog : kMiscTabDialog));
   aDialogView = TTabDialog(NewTemplateWindow1(dlogId));
   {
      // 24/05/90 - added idle freq. so that ciceros/picas will work ok
      if (dlogId == kNewTabDialog)
        aDialogView->SetIdleFreq(1);

      // set up the title for the dialog
      aDialogView->SetTitle(GetString(aCmdNumber));
      aDialogView->SetReadWriteHandler(this);

      AvoidRuler(aDialogView);
      aDialogView->HaveTabInfo(aCmdNumber, this, bTab,
                     GetConversionOrigin() /* 17/01/90 fOrigin */);
      aTab = bTab;
      dlogRes = aDialogView->PoseModally(aCmdNumber);

      aDialogView->Close(); // 12/07/90 moved from below in case of failure
      if (dlogRes != gIDOKbn && aCmdNumber == cNewTabDialog)
      {
         ReplaceObject(fSelectionDef, oldSelection);
         oldSelection = NULL;
         UpdateView();
         if (fActiveTab != NULL)
            fActiveTab->SelectState(TRUE, kRedraw);
      }
   }

   FreeIfObject(oldSelection);
   return(gNoChanges);
}
#endif


// -------------------------------------------------------------------------
TCommand _TRulerScale::MakeCommand(CmdNumber aCmdNumber, int inRulerRect,
           int mouseDidMove, Fixed oldStop, TFTabInfo &newInfo,
           bool adjust, int redraw)
{
   if (fRulerDef == NULL)
      return(gNoChanges);

   if ((fActiveTab != NULL) || (aCmdNumber == cNewTabDialog))
   {
      if (inRulerRect)
      {
         if (aCmdNumber != cNewTabDialog)
            InitSelection();
         if (fSelectionDef->IsPresent(newInfo) == 0)
            fSelectionDef->InstallTab(newInfo);
         return new _TTabCreateCommand(this, adjust);
      }
   }
   else
   {
      if (inRulerRect)
      {
         if (mouseDidMove)
         {
            if ((aCmdNumber == cTabChange) && (fSelectionDef->fSize > 0))
               return new _TTabChangeCommand(this, newInfo);

            return (fLastCommand = new _TTabMoveCommand(this, 
             /*(aCmdNumber == cMoveByKey),*/ newInfo.fStop - oldStop));
         }
      }
      else
         return(MakeDelCmd());
   }
   return(gNoChanges);
}


// -------------------------------------------------------------------------
int _TRulerScale::CanAddTabs()
{
   if (fRulerDef == NULL)
     return FALSE;
   return fRulerDef->CanAddTabs();
}


// -------------------------------------------------------------------------
void _TRulerScale::DoSetupMenus()
{
   int selectedTotal = 0;
   int userTotal = 0;
   int anyToDelete;
   int canCreate;

   _TScroller::DoSetupMenus();
   if ((fRulerDef != NULL) && (fSelectionDef != NULL))
      fSelectionDef->GetSelTotals(fRulerDef, selectedTotal, userTotal);
   anyToDelete = (selectedTotal == userTotal) && (userTotal > 0);

   Enable(cTabDelete, anyToDelete);
   Enable(cClear, anyToDelete);
   Enable(cMultiTabMove, selectedTotal > 0);
   Enable(cGetTabInfo, selectedTotal == 1);
   canCreate = CanAddTabs();
   Enable(cNewTabDialog, canCreate);

#ifdef NEWRULE
// moved from UScaledWn
  if (IsRulerShown())
  {
    TView tabWell;
    bool wellEnabled;

    ShowSelection();
    DrawTabs();
    tabWell = GetWindow()->FindSubView(gIDwell); // 26/07/90 - tabwell block new
    if (tabWell != NULL)
    {
      wellEnabled = tabWell->IsViewEnabled();
      if (wellEnabled != canCreate)
      {
        tabWell->ViewEnable(!wellEnabled, FALSE);
        tabWell->Show(!wellEnabled, TRUE);
      }
    }
  }
#endif
}


// -------------------------------------------------------------------------
TCommand _TRulerScale::DoMenuCommand(EventInfo& info, CmdNumber aCmdNumber)
{
   switch (aCmdNumber)
   {
      case cClear:
      case cTabDelete:
         return MakeDelCmd();
#ifdef TABLES
      case cMultiTabMove:
      case cGetTabInfo:
         return(DoDialog(aCmdNumber, NULL));
      case cNewTabDialog:
         {
            TTabView basedOn = fActiveTab;
            if (basedOn == NULL)
            {
               basedOn = TTabView(GetWindow()->FindSubView(I_('l', 't', 'a', 'b')));
               InstallTabViews(FALSE);
            }
            else
               basedOn->SelectState(FALSE, kRedraw);
            return(DoDialog(aCmdNumber, basedOn));
         }
#endif
      default:
         return(_TScroller::DoMenuCommand(info, aCmdNumber));
   }
}


// -------------------------------------------------------------------------
void _TRulerScale::DoChoice(TView origView, int itsChoice)
{
   if (itsChoice == mSicnHit)
   {
      InitSelection();
      EachSubview(this, (DoToSubView)ResetTabViews, origView);
                // 29/02/96 [] deselect all bar the original view
   }
   _TScroller::DoChoice(origView, itsChoice);
}



// -------------------------------------------------------------------------
bool _TRulerScale::HandleMouseDown(VPoint &theMouse, EventInfo &info,
                                   TCommand &theCommand)
{
#ifdef DRAGDROP
   if (info.theClickCount == 0)  // 22/03/93 ignore if drag from another window
     return FALSE;
#endif
   if (IsRulerShown())
   {
      if (fRulerDef != 0)
      {
         EnsureTarget();
// 22/05/91         LoseTheCaret();
      }
   }
   return(_TScroller::HandleMouseDown(theMouse, info, theCommand));
}


#define reasonableMiss (4 * kFix1)
// -------------------------------------------------------------------------
bool _TRulerScale::ValidToClick(VPoint &viewPt)
{
   Fixed hPosition;
   Fixed startPosition;

   if ((fRulerDef != 0) && PtInRulerRect(viewPt, kSlop, TRUE))
   {
      startPosition = LocToOffset(viewPt);
      hPosition = fRulerDef->ConstrainTab(startPosition, 0, kTabOnly, GetRulerWidth(), 0, fTextDirection);
      return((abs(hPosition - startPosition) < reasonableMiss));
   }
   return(FALSE);
}


// -------------------------------------------------------------------------
TCommand _TRulerScale::DoMouseCommand(Point& theMouse, EventInfo& info)
{
   TRulerTracker aRulerTracker;
   VPoint viewPt;
   VPoint clickPt;

   QDToViewPt(theMouse, viewPt);
   if (fActiveTab != NULL)
   {
      fActiveTab->SelectState(FALSE, kRedraw);
      if (ValidToClick(viewPt))
      {
         SetVPt(clickPt, 17, viewPt.v - fRulerRect.top); // 10/04/91 new pos of tab
         return new _TTabTracker(this, fActiveTab, clickPt, TRUE);
      }
      fActiveTab = NULL;
   }
   else if (IsRulerShown())
   {
      Rect *constrainRect;

      if (!info.rightButton)                   // 11/05/91
         DoChoice(this, mSicnHit);
      aRulerTracker = new _TRulerTracker(this);
      constrainRect = &aRulerTracker->fConstrainingRect;
      MoveRect(*constrainRect, fRulerRect);
      constrainRect->top = constrainRect->bottom =
          constrainRect->top + fInset - 16;  // ZZ fix bottom corner of rubber band box
      return aRulerTracker;
   }
   return gNoChanges;
}


/* -------------------------------------------------------------------------
TCommand _TRulerScale::DoKeyCommand(int aKeyCode, EventInfo &info)
{
   TCommand DoKeyCommand_result = gNoChanges;
   TFTabInfo newInfo;
   TScale units;
   int customPts;
   TConstraints constraint;
   Str255 aStr;
   Fixed hPosition;
   Fixed oldPos;
   Fixed origPos;
   Fixed rulerWidth;
   int idx;
   TSelType selType;
   int selectedTotal;
   int userTotal;

   if ((fRulerDef != NULL) && (fActiveTab == NULL))
   {
      selectedTotal = 0;
      userTotal = 0;
      rulerWidth = GetRulerWidth();
      if (fSelectionDef != NULL)
         fSelectionDef->GetSelTotals(fRulerDef, selectedTotal, userTotal);
      if ((selectedTotal == userTotal) && (userTotal > 0) &&
                    ((aKeyCode == chBackspace) || (aKeyCode == chClear))) 
         return(MakeDelCmd());
      else if ((aKeyCode == chLeft) || (aKeyCode == chRight))
      {
         origPos = 0;
         if (selectedTotal == 1)
         { 
            if (fSelectionDef->fSize == 1)
               origPos = (PFTabInfo(fSelectionDef->At(1)))->fStop;
            else if (fSelectionDef->fLeftMargin >= 0)
               origPos = fRulerDef->GetLeftMargin();
            else if (fSelectionDef->fIndentation >= 0)
               origPos = fRulerDef->GetIndentation();
            else
               origPos = rulerWidth - fRulerDef->GetRightMargin();
         }
         if (aKeyCode == chLeft)
         {
            hPosition = origPos - kFix1;
            constraint = eConstrainToPrevious;
         }
         else
         {
            hPosition = origPos + kFix1;
            constraint = eConstrainToNext;
         }

         if (!info.theOptionKey)
            constraint = eNoConstraint;
         units = GetScale();
         customPts = fCustomPoints;
         CvtUnitsToStr(hPosition, units, customPts,
                                               constraint, fOrigin, aStr);
         if (info.theOptionKey)
            CvtStrToPoints(aStr, units, customPts, fOrigin, hPosition);
         oldPos = hPosition;
         if (selectedTotal == 1)
         {
            selType = fSelectionDef->GetSelCmdIndex();
            idx = 0;
            if (selType == kColOnly)
            {
               fSelectionDef->Get(1, &newInfo);
               idx = fRulerDef->IsPresent(newInfo);
            }
            hPosition = fRulerDef->ConstrainTab(hPosition, idx,
                        fSelectionDef->GetSelCmdIndex(), rulerWidth, 0);
         }
         else
            ConstrainTabs(hPosition, constraint);

         if (oldPos == hPosition)
         {
            newInfo.fStop = hPosition;
            if ((gLastCommand != 0) && (gLastCommand == fLastCommand)
                                       && fLastCommand->fByKey)
            {
               if (selectedTotal != 1)
                  CvtUnitsToStr(fLastCommand->fUndoIncrement + hPosition,
                            units, customPts, constraint, fOrigin, aStr);
                                                             
               DrawTabDragPos(aStr);
               fLastCommand->ExtendMove(newInfo.fStop - origPos);
            }
            else
            {
               DrawTabDragPos(aStr);
               DoKeyCommand_result = MakeCommand(cMoveByKey, TRUE, TRUE, 
                                        origPos, newInfo, FALSE, kRedraw);
            }
         }
      }
      else
         DoKeyCommand_result = _TScroller::DoKeyCommand(aKeyCode, info);
   }
   else
     DoKeyCommand_result = _TScroller::DoKeyCommand(aKeyCode, info);
   return DoKeyCommand_result;
}
*/


// -------------------------------------------------------------------------
void _TRulerScale::DrawTabDragPos(char *theStr)
{
#ifdef TABLES
   if (fTabDragPosition == NULL)
      fTabDragPosition = TControl(GetWindow()->FindSubView(gIDdrag));
   if (fTabDragPosition != NULL)
      fTabDragPosition->SetText(theStr, TRUE);
#endif
}


// -------------------------------------------------------------------------
void _TRulerScale::AvoidRuler(TWindow aWindow)
{
   Point myGlobalBottom;
   Rect windGlobBounds;
   int gap;

   if (Focus())
   {
      SetPt(myGlobalBottom, 0, fSize.v + 100);
      thePort->LocalToGlobal(myGlobalBottom);
      gap = ScreenHeight() - myGlobalBottom.v;
      aWindow->GetGlobalBounds(windGlobBounds);

      if (gap > windGlobBounds.bottom)
         aWindow->Locate(windGlobBounds.left, myGlobalBottom.v +
                                              windGlobBounds.top, FALSE);
   }
}


// -------------------------------------------------------------------------
void _TRulerScale::SetScale(TScale scale, int customPoints, int redraw)
{
   fScale = scale;
   fCustomPoints = customPoints;
   if (redraw)
      ForceRedraw();
}


// -------------------------------------------------------------------------
int _TRulerScale::GetRulerPaneDepth(bool rulerShown, bool scalesShown)
{
   if (rulerShown)
      return fRulerRect.top + fInset - (IsTV() ? 0 : 8); // ruler + scales
      // allow room for 2 lines at bottom for TV
   if (scalesShown)
      return fRulerRect.top;           // just scales
   return 0;
}


// -------------------------------------------------------------------------
Fixed _TRulerScale::GetRulerWidth()
{
   return(FixDiv(fRightEdge - fLeftEdge, fMagnification));
}


// -------------------------------------------------------------------------
void _TRulerScale::SetMagnification(Fixed magnification)
{
   if (fMagnification != magnification)
   {
      fMagnification = magnification;
      ForceRedraw();
      RelocateTabs();
   }
}


#ifdef TABLES
#define HORIZ (whichWay == h)
#else
#define HORIZ 1
#endif

#ifdef NETWP
static g3D = TRUE;
#else
#define g3D g3Dicons
#endif

// -------------------------------------------------------------------------
static void DrawDiv(VHSelect whichWay, Fixed divPos, int divLineH,
                                                         int rulerRectTop)
{
   if (divLineH != 0)
   {
      divPos = FromFixed(divPos);
      if (g3D)
         thePort->PenPat(5);
      if (HORIZ)
      {
         thePort->MoveTo(divPos, rulerRectTop);
         thePort->Line(0, divLineH);
      }
      else
      {
         thePort->MoveTo(rulerRectTop, divPos);
         thePort->Line(divLineH, 0);
      }
      if (g3D)
      {
         thePort->PenPat(0);
         if (HORIZ)
         {
            thePort->Move(GetVLineThickness(), -divLineH);
            thePort->Line(0, divLineH);
         }
         else
         {
            thePort->Move(-divLineH, GetHLineThickness());
            thePort->Line(divLineH, 0);
         }
         // 16/07/93 move out of loop PenNormal();
      }
   }
}


// -------------------------------------------------------------------------
extern wr_os_error *wr_displ_setVDU5charsize(int xsize, int ysize, int xspace, int yspace);
extern void wr_dr_recoverScreenState(int status);
extern int wr_dr_setScreenState(void);

char gOurDigits[] = {
0x2d, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
0x30, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x00,
0x31, 0x60, 0x20, 0x20, 0x20, 0x70, 0x00, 0x00, 0x00,
0x32, 0x70, 0x88, 0x10, 0x20, 0xf8, 0x00, 0x00, 0x00,
0x33, 0x70, 0x88, 0x30, 0x88, 0x70, 0x00, 0x00, 0x00,
0x34, 0x10, 0x30, 0x50, 0xf8, 0x10, 0x00, 0x00, 0x00,
0x35, 0xf8, 0x80, 0xf0, 0x08, 0xf0, 0x00, 0x00, 0x00,
0x36, 0x30, 0x40, 0xf0, 0x88, 0x70, 0x00, 0x00, 0x00,
0x37, 0xf8, 0x10, 0x20, 0x40, 0x40, 0x00, 0x00, 0x00,
0x38, 0x70, 0x88, 0x70, 0x88, 0x70, 0x00, 0x00, 0x00,
0x39, 0x70, 0x88, 0x78, 0x08, 0x30, 0x00, 0x00, 0x00, 0 };

// ------------------------------------------------------------------------
static void SaveChars(char *buff)
{
  for (int i = 0; gOurDigits[i] != 0; i += 9)
  {
    buff[i] = gOurDigits[i];
    wr_wimpt_noerr(wr_os_word(10, buff + i));
  }
}

// ------------------------------------------------------------------------
static void ResetChars(char *buff)
{
  for (int i = 0; gOurDigits[i] != 0; i += 9)
  {
    wr_bbc_vdu(23);
    wr_bbc_vdu(gOurDigits[i]);
    for (int j = 1; j < 9; j++)
      wr_bbc_vdu(buff[j + i]);
  }
}

#define HYSTART 8
// -------------------------------------------------------------------------
void _TRulerScale::Draw(Rect &area)
{
   Rect       viewRect;
   int        i, j, k;
   TScalePars scalePars = gScalePars[fScale];
   int        firstMajor, lastMajor;
   Fixed      majDivGap, minDivGap;
   int        numPos, factorCount;
   Fixed      origin = ToFixed(FixMul(fOrigin, fMagnification) + fLeftLimit);
   int        labFrequency;
   int        numberFreq;
   int        minDivPos, majDivPos;
   int        minorDivs = scalePars.minorDivs;
   char       buffer[10];
   int        originOffset;
   int        rulerRectTop;
   int        minDivHt = fScaleMetrics.minDivHt;
   int        midDivHt = fScaleMetrics.midDivHt;
   bool       threeD = g3D;
   VHSelect   whichWay = fWhichWay;
   int        status = wr_dr_setScreenState();
   char       chBuff[sizeof(gOurDigits)];
   int        vlt = GetVLineThickness();
   int        hlt = GetHLineThickness();

   PenNormal();

   // 24/08/94 [22019]
   SaveChars(chBuff);
   ResetChars(gOurDigits);    // lo-res
   wr_displ_setVDU5charsize(64 / vlt, 128 / hlt, 48 / vlt, 8);

   if (HORIZ)
      rulerRectTop = fRulerRect.top; // ZZ + hlt;
   else
      rulerRectTop = fRulerRect.left; // ZZ + vlt;

   if (!HORIZ || area.top < rulerRectTop)
   {
      /* start drawing, first lines along the edges the length of the area */
      if (HORIZ)
      {
         if (threeD)
         {      
            /* set ruler background to lt grey */
            QDToViewRect(area, viewRect);
            // 29/07/93 thePort->PenPat(1);
            viewRect.bottom = rulerRectTop - 32;
            // 29/07/93 thePort->PaintRect(viewRect);
            viewRect.top = viewRect.bottom;
            viewRect.bottom = rulerRectTop;
            thePort->PenPat(2);     // 01/03/96 from 3 to differentiate from mainview b/g
            thePort->PaintRect(viewRect);
            PenNormal();
         }
         thePort->MoveTo(area.left, rulerRectTop);
         thePort->Line(area.right - area.left, 0);
         // origin -= ToFixed(vlt);   // 01/03/96 ZZ compensate for page guide left out-set
      }
      else
      {
         if (g3D)
         {      
            /* set ruler background to lt grey */
            QDToViewRect(area, viewRect);
            // 29/07/93 thePort->PenPat(1);
            viewRect.right = rulerRectTop - 28;
            // 29/07/93 thePort->PaintRect(viewRect);
            viewRect.left = viewRect.right;
            viewRect.right = rulerRectTop;
            thePort->PenPat(2);     // 01/03/96 from 3 to differentiate from mainview b/g
            thePort->PaintRect(viewRect);
            PenNormal();
         }
         thePort->MoveTo(rulerRectTop - vlt, area.top);   // ZZ -vlt
         thePort->Line(0, area.bottom - area.top);
         // origin += ToFixed(hlt * 3);  // 24/01/91; 21/04/91 =- to =+, 01/03/96 ZZ
      }
      QDToViewRect(area, viewRect);
      if (fScale == eCustom)
         majDivGap = ToFixed(fCustomPoints * 10);  // held in fixed deciPoints!
      else
         CvtStrToPoints("1", fScale, fCustomPoints, 0, majDivGap);
      majDivGap = FixMul(
                   FixMul(majDivGap, ToFixed(scalePars.factor)), fMagnification);
      minDivGap = majDivGap / ((minorDivs + 1) * (scalePars.midiDivs + 1));

      /* find the major divisions bounding the area to be drawn */
      originOffset = ToFixed((HORIZ ? viewRect.left : viewRect.top) -
                    fScaleMetrics.labelOffset) - origin;
      firstMajor = originOffset / majDivGap;
      if (originOffset < 0) firstMajor--;  // fix for Acorns funny division

      // 20/01/91 compensate for long numbers encroaching from left
      if (HORIZ)
      {
        NumToString(firstMajor * scalePars.factor, buffer);
        firstMajor -= ToFixed(strlen(buffer) * vlt * 8) / majDivGap;
      }

      lastMajor = (ToFixed((HORIZ ? viewRect.right :
          viewRect.bottom + (hlt * 8 /* for BBC char */))
                     + fScaleMetrics.labelOffset) - origin) / majDivGap;

      /* reduce scale frequency when zoomed */
      if (fMagnification * 4 <= kFix1)
         numberFreq = scalePars.numberFreq4;
      else if (fMagnification * 2 <= kFix1)
         numberFreq = scalePars.numberFreq2;
      else
         numberFreq = scalePars.numberFreq;

      {
         int t = (HORIZ ? vlt : hlt);
         int minGap = FromFixed(minDivGap);

         if (minGap < (t * 3))
            minDivHt = 0;   /* turn them off */
         else if (minGap <= (t * 4))        // 14/07/92 turn off 3d
            g3D = FALSE;
         minGap = FromFixed((minorDivs + 1) * minDivGap);
         if (minGap < (t * 3))
            midDivHt = 0;   /* turn them off too */
         else if (minGap <= (t * 4))        // 14/07/92 turn off 3d
            g3D = FALSE;
      }

      numPos = (labFrequency = numberFreq) == 0 ? 0 :
                                            RoundUp(firstMajor, labFrequency);
      factorCount = firstMajor * scalePars.factor;
      majDivPos = (firstMajor * majDivGap) + origin;

      for (i = firstMajor; i <= lastMajor; i++)
      {
         /* --- draw a major division line (with optional labelling) -- */
         DrawDiv(fWhichWay, majDivPos, -fScaleMetrics.majDivHt, rulerRectTop);
         PenNormal();       // 16/07/93 see DrawDiv

         if (i == numPos)       /* we are due for a label at this division */
         {
            NumToString(i * scalePars.factor, buffer);
            if (HORIZ)
              thePort->Move( (g3D ? 0 : 8) +
                (i < 0 ? -fScaleMetrics.labelOffset : 0) - fScaleMetrics.labelOffset,
                       // 24/08/94 [22019] -fScaleMetrics.labelOffset,
                        - rulerRectTop + (HYSTART * 2) + fScaleMetrics.majDivHt); // ZZ * 3
            else
              thePort->Move(-(strlen(buffer) * vlt * 6),
                              // - fRulerRect.right + fScaleMetrics.majDivHt,
                              -(fScaleMetrics.labelOffset + (g3D ? hlt : 0)));
            wr_wimpt_noerr(wr_bbc_stringprint(buffer));
            numPos +=labFrequency;
         }
         factorCount += scalePars.factor;

         /* synchronise pointers to avoid creeping rounding errors */
         minDivPos = majDivPos;
         majDivPos += majDivGap;

         for (j = 0; j <= scalePars.midiDivs; j++)
         {
            for (k = 0; k < minorDivs; k++)
               /* ----- draw a minor division ----- */
               DrawDiv(fWhichWay, (minDivPos += minDivGap),
                                  -minDivHt, rulerRectTop);

            if (j != scalePars.midiDivs)
               /* ----- draw a midi division ----- */
               DrawDiv(fWhichWay, (minDivPos += minDivGap),
                                  -midDivHt, rulerRectTop);
         }
         PenNormal();       // 16/07/93 see DrawDiv
      }
   }
   // 24/08/94 [22019]
   ResetChars(chBuff);
   wr_dr_recoverScreenState(status);

   if (area.bottom >= rulerRectTop)  // Endline tests if vertical scale
      Endline();
//#ifdef TABLES
//   i = fMousePosition;
//   fMousePosition = MAXLONGINT;      // get line drawn at current position
//   DrawMouseLine(i, &area);
//   fMousePosition = i;
//#endif
   g3D = threeD;
}


// -------------------------------------------------------------------------
void _TRulerScale::DrawTheTab(TTabType kind, Fixed itsOffset, bool selected)
{
   if (selected && GetWindow()->fTarget != this)
     selected = FALSE;  // 21/01/91 Experiment???

   // 29/02/96 drawSelected now always TRUE:  if (!selected || drawSelected)
   {
      Rect itsExtent;
      VPoint itsLoc;

      SetVPt(itsLoc, FixRound(itsOffset) - kSpriteHot, fRulerRect.top);
                                                      /* ZZ + 16 - GetHLineThickness() */
      SetRect(itsExtent, 0, 0, kSpriteHot * 2, fInset);
      OffsetRect(itsExtent, itsLoc.h, itsLoc.v);
      if (VisibleRect(itsExtent))  // VisibleRect corrupts itsExtent
      {
        TSprite aSprite = new _TSprite(NULL, gZeroVPt, GetIndString(3, int(kind)));

        aSprite->HiliteState(selected);
        aSprite->Plot(itsLoc, plotOr);
        aSprite->Free();
      }
   }
}


// -------------------------------------------------------------------------
void _TRulerScale::Endline()
{
   if (IsRulerShown() && Focus())
   {
      int i;
      Rect theRect;
      Fixed multFactor;
      Fixed lmPos;
      Fixed rmPos;
      Fixed aTabPos;
      TRulerDef selectionDef;
      int lmSelected;
      int rmSelected;
      int inSelected;
      int rulerLineWidth;
      // bool rulerSelected = (TWindow(thePort->GetWindowRef())->fTarget == this);

      PenNormal();  // ZZ
      selectionDef = fSelectionDef;
      ViewToQDRect(fRulerRect, theRect);   // same as MoveRect!
      rulerLineWidth = theRect.right - theRect.left;
      theRect.bottom = theRect.top + fInset - 16;  // ZZ
      // ZZ theRect.top += GetHLineThickness();

      theRect.right = FixRound(fLeftEdge);
      PenPat(ltGray);
      PaintRect(theRect);
      theRect.left = theRect.right;
      theRect.right = RoundToPixel(FixRound(fRightEdge), h);  // 01/03/96 round to pix
      PenPat(0);         // 29/07/93
      PaintRect(theRect);    // 29/07/93
      theRect.left = theRect.right;
      theRect.right = fRulerRect.right;
      PenPat(ltGray);
      PaintRect(theRect);
#ifdef NETWP
      if (IsTV())
      {
        // ZZ draw a lighter line along bottom of tab area
        PenPat(4);
        MoveTo(fRulerRect.left, theRect.bottom + 16);
        Line(rulerLineWidth, 0);
      }
#endif
      // ZZ draw a line along bottom of tab area
      PenPat(6);
      MoveTo(fRulerRect.left, theRect.bottom + 8);
      Line(rulerLineWidth, 0);

      multFactor = fMagnification;
      if (fRulerDef == NULL)
        lmPos = rmPos = aTabPos = -1;
      else
      {
         lmPos = fRulerDef->GetLeftMargin();
         rmPos = fRulerDef->GetRightMargin();
         aTabPos = fRulerDef->GetIndentation();
         if (multFactor != kFix1)
         {
            lmPos = FixMul(lmPos, multFactor);
            rmPos = FixMul(rmPos, multFactor);
            if (aTabPos >= 0)
               aTabPos = FixMul(aTabPos, multFactor);
         }
      }
      if (selectionDef == 0)
         lmSelected = rmSelected = inSelected = FALSE;
      else
      { 
         lmSelected = (selectionDef->GetLeftMargin() >= 0);
         rmSelected = (selectionDef->GetRightMargin() >= 0);
         inSelected = (selectionDef->GetIndentation() >= 0);
      }

      if (lmPos >= 0) // 26/07/90
        DrawTheTab(kLeftMargin, fLeftEdge + lmPos, lmSelected);

      if (rmPos >= 0) // 26/07/90
        DrawTheTab(kRightMargin, fRightEdge - rmPos, rmSelected);

      if (aTabPos >= 0)
         DrawTheTab(kIndentation - fTextDirection,
              fTextDirection ? fRightEdge - aTabPos : fLeftEdge + aTabPos, inSelected);

      for (i = 1; i <= fRulerDef->GetSize(); ++i)
      {
         TFTabInfo tabInfo;

         fRulerDef->Get(i, &tabInfo);
         aTabPos = tabInfo.fStop;
         if (multFactor != kFix1)
            aTabPos = FixMul(aTabPos, multFactor);
         if (fLeftEdge + aTabPos <= fRightEdge)
            DrawTheTab(int(tabInfo.fKind), fLeftEdge + aTabPos,
                           selectionDef != NULL && selectionDef->IsPresent(tabInfo));
      }
   }
}


// -------------------------------------------------------------------------
void _TRulerScale::DrawTabs()
  // This gets called in Idle, on mouse clicks, etc., as well as on redraws
  // so needs to go through the screen update process instead of just
  // drawing directly onto the screen. On the Mac it is drawn via a bitmap.
{
#ifdef NETWP
   if (IsTV())
   {
     Rect viewRect;

     ViewToQDRect(fRulerRect, viewRect);
     viewRect.top -= 8;   // extend up so line above anti-twittered
     UpdateVRect(viewRect);
   }
   else
#endif
     DoInUpdate(fRulerRect, (DrawProc)_TRulerScale::Endline);
}


// -------------------------------------------------------------------------
void _TRulerScale::ShowSelection()
{
   TRulerDef compositeStyle;
   Fixed limits[3];

   fLeftEdge = ToFixed(fLeftLimit);
   fRightEdge = ToFixed(fRightLimit);
   ClearObject(fRulerDef);
#ifdef NEWRULE
   {
     TMainView mvie = TMainView(GetWindow()->FindSubView(I_('m', 'v', 'i', 'e')));

     compositeStyle = NULL;
     if (mvie != NULL)
       compositeStyle = mvie->GetCurrentStyle(limits);
   }
#else
   compositeStyle = TMainView(fNextHandler)->GetCurrentStyle(limits);
#endif
   if (compositeStyle != NULL && (compositeStyle->fDefined & kRuler))
   {
      if (fMagnification != kFix1)
      {
         limits[0] = FixMul(limits[0], fMagnification);
         limits[1] = FixMul(limits[1], fMagnification);
      }
      fLeftEdge += limits[0];
      fRightEdge -= limits[1];
      fTextDirection = limits[2];     // 04/07/94
      fRulerDef = TRulerDef(compositeStyle->ShallowClone());
#ifdef DRAGDROP
      if (fDocument->fLastCommand != NULL && fDocument->fLastCommand == fLastCommand)
#else
      if ((gLastCommand != 0) && (gLastCommand == fLastCommand))
#endif
         fLastCommand->UpdateRulerDef();
   }
   else
   {
      fRulerDef = NULL;
   }

   if (CountSubViews() != 0)   // fSubViews != NULL && fSubViews->fSize != 0)
      InstallTabViews(FALSE);
}


// -------------------------------------------------------------------------
static void ClearTab(TObject null, TView theSubView)
{
   FreeIfObject(theSubView);
}

// -------------------------------------------------------------------------
void _TRulerScale::ReselectView(TTabView aTab)
{
   TFTabInfo info;
   bool      selIt;

   switch (aTab->fItsKind) 
   {
   case kLeftMargin: selIt = (fSelectionDef->GetLeftMargin() >= 0);
            break;
   case kRightMargin: selIt = (fSelectionDef->GetRightMargin() >= 0);
            break;
   case kIndentation:
   case kRtIndentation:
            selIt = (fSelectionDef->GetIndentation() >= 0);
            break;
   default: aTab->GetTabInfo(info);
            selIt = (fSelectionDef->IsPresent(info) != 0);
   }

   aTab->SelectState(selIt, kDontRedraw);
   if (!selIt)
   {
      fSubViews->Delete(aTab);
      fSubViews->InsertFirst(aTab);
   }
}

// -------------------------------------------------------------------------
void _TRulerScale::BuildATab(TTabType kind, Fixed position, int defIdx)
{
   TTabView newTab;

   newTab = new _TTabView(this, this, position, kind, defIdx);
   if (kind == kIndentation - fTextDirection)
   {
      newTab->fIdentifier = gIDhalf;      // 20/01/91 frig for ContainsMouse
   }
   // 27/02/96 a bit silly!: newTab->fSize.v = fSize.v - newTab->fLocation.v;
   AddSubView(newTab);
   if (fSelectionDef != NULL)
      ReselectView(newTab);
}


// -------------------------------------------------------------------------
void _TRulerScale::InstallTabViews(bool activating)
{
   int i;
   TFTabInfo tabInfo;
   Fixed indent;
   Fixed limitLoc;
   register TRulerDef rule = fRulerDef;

   EachSubview(NULL, (DoToSubView)ClearTab);
   if (activating && (fRulerDef != NULL))
   { 
      indent = rule->GetIndentation();
      limitLoc = GetRulerWidth();  // 22/03/91; - rule->GetRightMargin();
      for (i = 1; i <= rule->GetSize(); ++i)
      {
         rule->Get(i, &tabInfo);
         if (tabInfo.fStop <= limitLoc)
            BuildATab(int(tabInfo.fKind), tabInfo.fStop, i);
      }
      if (indent >= 0)
      {
         if (fTextDirection != 0)
           BuildATab(kRtIndentation, limitLoc - indent, 0);
         else
           BuildATab(kIndentation, indent, 0);
      }
      BuildATab(kLeftMargin, rule->GetLeftMargin(), 0);
      BuildATab(kRightMargin, limitLoc - rule->GetRightMargin(), 0);
   }
}


// -------------------------------------------------------------------------
void _TRulerScale::DoRelocation(TView aView, Fixed limitLoc)
{
   VPoint newLocation;

   if (/* Member(aView, _TTabView) */ TRUE)
   {
      register TTabView view = TTabView(aView);

      if (view->fItsKind == kRightMargin)
         view->fRulerOffset = limitLoc;
      if (view->fRulerOffset > GetRulerWidth()) // 22/03/91 limitLoc) 
         SetVPt(newLocation, -200, 0);
      else
         LocateOnRuler(view->fRulerOffset, newLocation);
      Locate(newLocation.h, newLocation.v, kDontRedraw);
   }
}


// -------------------------------------------------------------------------
void _TRulerScale::RelocateTabs()
{
   Fixed limitLoc = 0; // 26/04/90 set for safety

   if (fRulerDef != 0)
      limitLoc = GetRulerWidth() - fRulerDef->GetRightMargin();
   EachSubview(this, (DoToSubView)_TRulerScale::DoRelocation, limitLoc);
}


// -------------------------------------------------------------------------
void _TRulerScale::SelectTab(TTabView theTab, bool selected)
{
   TFTabInfo tabinfo;

   fLastCommand = NULL;
   if (theTab->fInTabWell)
   {
      if (selected)
         fActiveTab = theTab;
      else if (fActiveTab == theTab)
         fActiveTab = NULL;
   }
   else if (fSelectionDef != NULL)
   {
      register TRulerDef rule = fSelectionDef;
      register TTabView  view = theTab;

      fActiveTab = NULL;
      if (view->IsShown())
      {
         switch (view->fItsKind)
         {
         case kLeftMargin:
            rule->SetLeftMargin(selected ? Max(0, view->fRulerOffset) : -1);
            break;
         case kRightMargin:
            rule->SetRightMargin(selected ? Max(0, 
                           GetRulerWidth() - view->fRulerOffset) : -1);
            break;
         case kIndentation:
         case kRtIndentation:
            rule->SetIndentation(selected ? Max(0, (GetRulerWidth() & fTextDirection) +
                                               (view->fRulerOffset ^ fTextDirection)) : -1);
            break;
         default:
            view->GetTabInfo(tabinfo);
            if (selected && (rule->IsPresent(tabinfo) == 0))
               rule->InstallTab(tabinfo);         // insert if not there
            else if (!selected && rule->IsPresent(tabinfo) != 0)
               rule->DeleteTab(tabinfo);          // delete if not wanted
                                                  // 24/07/90 .. and present
         }
      }
   }
}


// -------------------------------------------------------------------------
void _TRulerScale::LimitSelectedTab(Fixed position,int idx,TSelType tabType,
                                          Fixed offset, Fixed& target)
{
   Fixed thisPosition;

   thisPosition = fRulerDef->ConstrainTab(position, idx, tabType,
                              GetRulerWidth(), fSelectionDef, fTextDirection);
   if (thisPosition != position)
   {
      if (offset >= 0)
         target = Min(target, offset + thisPosition - position);
      else
         target = Max(target, offset + thisPosition - position);
   }
}

// -------------------------------------------------------------------------
void _TRulerScale::ConsTabs(Fixed &offset)
{
   Fixed target = offset;
   Fixed rulerWidth = GetRulerWidth();;
   int i;
   TFTabInfo info;
   register TRulerDef sel = fSelectionDef;

   fRulerDef->MoveSelection(fSelectionDef, offset, fTextDirection);
   fSelectionDef->OffsetSelection(offset, FALSE, fTextDirection);

   if (sel->fLeftMargin >= 0)
      LimitSelectedTab(fRulerDef->GetLeftMargin(),0, kLMOnly, offset,target);
   if (sel->fIndentation >= 0)
      LimitSelectedTab((rulerWidth & fTextDirection) +
              (fRulerDef->GetIndentation() ^ fTextDirection), 0, kIndOnly, offset, target);
   if (sel->fRightMargin >= 0)
      LimitSelectedTab(rulerWidth - fRulerDef->GetRightMargin(),
                                                 0, kRMOnly, offset, target);
   for (i = 1; i <= sel->fSize; ++i)
   {
      sel->Get(i, &info);
      if (info.fKind <= kMarkTab)
         LimitSelectedTab(info.fStop, 0, kTabOnly, offset, target);
      else
         LimitSelectedTab(info.fStop, fRulerDef->IsPresent(info),
                                                kColOnly, offset, target);
   }

   fRulerDef->MoveSelection(fSelectionDef, -(offset), fTextDirection);
   fSelectionDef->OffsetSelection(-(offset), FALSE, fTextDirection);
   offset = target;
}


// -------------------------------------------------------------------------
void _TRulerScale::ConstrainTabs(Fixed &offset, TConstraints &constraint)
{
   Fixed target;
   target = offset;

   if (fRulerDef != 0)
      ConsTabs(target);
   if (target > offset)
      constraint = eConstrainToNext;
   else if (target < offset)
      constraint = eConstrainToPrevious;

   while (target != offset)
   {
      offset = target;
      ConsTabs(target);
   }
   offset = target;
}

// -------------------------------------------------------------------------
bool _TRulerScale::DoHelp(IDType msgID, EventInfo &info, VPoint &theMouse)
// new 15/08/90
{
  if (PtInRulerRect(theMouse, 0, TRUE))
    msgID = gIDtabs;
  else if (PtInRulerRect(theMouse, 0, FALSE))
    msgID = gIDgrey;

  return _TView::DoHelp(msgID, info, theMouse);
}

// -------------------------------------------------------------------------
void _TRulerScale::UpdateView()
{
   InstallTabViews(FALSE);
   DrawTabs();
}


// -------------------------- TRulerTracker ------------------------------
_TRulerTracker::_TRulerTracker(TRulerScale rulerView)
              : (cNoCommand, 0, rulerView, rulerView->GetScroller(FALSE))
{
   fViewConstrain = TRUE;
   fConstrainsMouse = TRUE;
   fFeedbackBox = 6;   // set to 6 for dotted rubber band 
   fRulerScale = rulerView;
   fInRuler = TRUE;
   fMainScroller = TScroller(rulerView->GetWindow()->FindSubView(gIDscro));
}


// -------------------------------------------------------------------------
static void ToggleTab(TObject null, TTabView aTab,
               VCoordinate leftOfDrag, VCoordinate rightOfDrag)
{
   VCoordinate activePt;
   int newState;

   activePt = aTab->fLocation.h + 3;
   if (activePt >= leftOfDrag && activePt <= rightOfDrag)
   {
      newState = !aTab->IsSelected();
      aTab->SelectState(newState, kRedraw);
      aTab->fRulerView->SelectTab(aTab, newState);
   }
}


// -------------------------------------------------------------------------
TCommand _TRulerTracker::TrackMouse(TrackPhase aTrackPhase,
       VPoint &anchorPoint, VPoint &previousPoint, VPoint &nextPoint,
       bool mouseDidMove, EventInfo &info)
{
   VCoordinate leftOfDrag;
   VCoordinate rightOfDrag;

   if (aTrackPhase == trackPress)
      anchorPoint.v = fRulerScale->fRulerRect.top; // ZZ + GetHLineThickness();
   else if (aTrackPhase == trackRelease)
   {
      leftOfDrag = Min(anchorPoint.h, nextPoint.h);
      rightOfDrag = Max(anchorPoint.h, nextPoint.h);
      if (leftOfDrag != rightOfDrag)
         fView->EachSubview(NULL, (DoToSubView)ToggleTab, leftOfDrag, rightOfDrag);
      return(gNoChanges);
   }
   return(this);
}


// -------------------------------------------------------------------------
void _TRulerTracker::TrackConstrain(VPoint &anchorPoint,
                                 VPoint &previousPoint, VPoint &nextPoint)
{
   nextPoint.v = fRulerScale->fRulerRect.top + fRulerScale->fInset - 17;
                              // ZZ fRulerScale->fRulerRect.bottom - 1;
}


// -------------------------------------------------------------------------
void _TRulerTracker::AutoScroll(VCoordinate deltaH, VCoordinate deltaV)
{
   if (fMainScroller != NULL && fInRuler)
      fMainScroller->ScrollBy(deltaH, 0);
}

// ---------------------------- TTabTracker --------------------------------

_TTabTracker::_TTabTracker(TRulerScale rulerView, TTabView theTabView,
                  VPoint &itsMouseDown, int allowDeletion) : (rulerView)
{
   fTabView = theTabView;
   fMouseOffset = itsMouseDown;
#ifndef ZERO_OBJ
   fAdjust = FALSE;
   fPositionStr[0] = 0;
   fOn = FALSE;
#endif
   fFeedbackBox = 7;   // we do our own track feedback
   fAllowDeletion = allowDeletion;
   fOutsideRuler = TRUE;
   fViewConstrain = FALSE;  // needs to reset to F, as TRulerTracker sets T
}


// -------------------------------------------------------------------------
TCommand _TTabTracker::TrackMouse(TrackPhase aTrackPhase,
           VPoint &anchorPoint, VPoint &previousPoint, VPoint &nextPoint,
           bool mouseDidMove, EventInfo &info)
{
   VPoint newLocation;
   TFTabInfo tabInfo;
   int releasedOnRuler;
   register TRulerScale rulerView;
   TConstraints constraint;
   VPoint origPos;

   if (aTrackPhase == trackPress)
   {
#ifdef NETWP
      // Did redraw all the selected tabs in any case - but fOn approach leaves an
      // anti-twitter halo when tab moved. Also not quite right for 2 overlapping
      // tabs, as Xor knocks out the common bit
      if (IsTV() && !fTabView->fInTabWell)
      {
         fTabView->fRulerView->DrawTabs();   // did pass FALSE (only draw unselected tabs)
         fView->Focus();
         fOn = FALSE;
      }
      else
#endif
        fOn = TRUE;    // 29/02/96 - better way than redrawing all the non-selected tabs?
      fAdjust = info.rightButton;   // 11/05/91
   }
   else if (aTrackPhase == trackRelease)
   {
      rulerView = fTabView->fRulerView;
      releasedOnRuler = rulerView->PtInRulerRect(nextPoint, kSlop, TRUE);
      newLocation = nextPoint;
      SubVPt(fMouseOffset, newLocation);
//      if (releasedOnRuler)
//         TrackFeedback(anchorPoint, nextPoint, FALSE, TRUE);
      fTabView->GetTabInfo(tabInfo);
      rulerView->LocateOnRuler(tabInfo.fStop, origPos);
      mouseDidMove = (origPos.h + fMouseOffset.h != nextPoint.h);
      tabInfo.fStop = rulerView->LocToOffset(newLocation) - fTabView->fRulerOffset;
      if (!fTabView->fInTabWell)
        rulerView->ConstrainTabs(tabInfo.fStop, constraint); // 01/07/91
      if (fTabView->fInTabWell && (rulerView->fTabDragPosition != 0))
         rulerView->fTabDragPosition->SetText("", kRedraw);
      return(rulerView->MakeCommand(cTabMove, releasedOnRuler,
                        mouseDidMove, 0, tabInfo, fAdjust, kDontRedraw));
   }
   else if (aTrackPhase == trackMove)
   {
      nextPoint.h -= fMouseOffset.h - kSpriteHot;      // 02/05/91
      fRulerScale->DrawTabDragPos(fPositionStr);
   }
   return(this);
}


// -------------------------------------------------------------------------
void _TTabTracker::PlotItsFeedback(TTabView theTab, VPoint &nextPoint)
{
   if (theTab->fSelect)
   {
      VPoint offset = theTab->fLocation;
      Point pt;

      SubVPt(fTabView->fLocation, offset);
      AddVPt(nextPoint, offset);
      VPtToPt(offset, pt);
      theTab->Plot(pt, plotXor);
   }
}


// -------------------------------------------------------------------------
void _TTabTracker::TrackFeedback(VPoint &anchorPoint, VPoint &nextPt,
                                         bool turnItOn, bool mouseDidMove)
{
   VPoint nextPoint = nextPt;

   SubVPt(fMouseOffset, nextPoint);
   if (mouseDidMove)
   {
      if (fTabView->fInTabWell)
      {
         Point pt;

         pt.h = nextPoint.h;
         pt.v = nextPoint.v;
         if (turnItOn)
           fTabView->Plot(pt, plotOr);
         else
         {
           VRect extent;

           fTabView->GetExtent(extent);
           OffsetRect(extent, pt.h, pt.v);
           EraseRect(extent);
           fRulerScale->Draw(extent);
           fRulerScale->AddInvalidVRect(extent);  // 29/07/93 avoid erasing the background
         }
      }
      else if (turnItOn != fOn)   // 03/03/96 its already on (first call of TrackFeedback)
      {
         fOn = turnItOn;
         fTabView->fRulerView->EachSubview(this,
                (DoToSubView)_TTabTracker::PlotItsFeedback, &nextPoint);
      }
#ifdef TRACE
      else
        nextPoint = nextPt;
#endif
   }
}


// -------------------------------------------------------------------------
long _TTabTracker::ConstrainInRule(long hCoord, 
        TRulerScale rulerView, TConstraints &constraint, VPoint &anchorPoint)
{
   Fixed hOffset;
   Fixed hPosition;
   Fixed startPosition;
   VPoint itsLocation;

   SetVPt(itsLocation, hCoord - fMouseOffset.h, 0);
   hPosition = rulerView->LocToOffset(itsLocation);
   if (fTabView->fInTabWell)
   {
      if (rulerView->fRulerDef != NULL)
      {
         startPosition = hPosition;
         hPosition = rulerView->fRulerDef->ConstrainTab(hPosition, 0,
                       kTabOnly, rulerView->GetRulerWidth(), 0, rulerView->fTextDirection);
         if (hPosition > startPosition)
            constraint = eConstrainToNext;
         else if (hPosition < startPosition)
            constraint = eConstrainToPrevious;
      }
   }
   else
   {
      SetVPt(itsLocation, anchorPoint.h - fMouseOffset.h, 0);
      startPosition = rulerView->LocToOffset(itsLocation);
      hOffset = hPosition - startPosition;
      rulerView->ConstrainTabs(hOffset, constraint);
      hPosition = hOffset + startPosition;
   }
   rulerView->LocateOnRuler(hPosition, itsLocation);
   return(itsLocation.h + fMouseOffset.h);
}


// -------------------------------------------------------------------------
void _TTabTracker::TrackConstrain(VPoint &anchorPoint, VPoint &previousPoint, VPoint &nextPoint)
{
   TRulerScale rulerView = fRulerScale;
   VCoordinate rulerOrigin = fRulerScale->GetConversionOrigin();
   VPoint nearestLoc;
   Fixed points;
   Fixed oldPoints;
   TScale units;
   int customPts;
   TConstraints constraint;
   int inRuler = rulerView->PtInRulerRect(nextPoint, kSlop, fOutsideRuler);
   Str255 aStr;
   bool map;

   fInRuler = inRuler;
   if (inRuler)
      fOutsideRuler = FALSE;
   if (inRuler || (!fAllowDeletion))
   {
      nextPoint.v = fMouseOffset.v + rulerView->fRulerRect.top; // ZZ + 16;
      nextPoint.h = ConstrainInRule(nextPoint.h, rulerView, constraint,
                                                     anchorPoint);
      constraint = eConstrainToNearest;
      nearestLoc = nextPoint;
      SubVPt(fMouseOffset, nearestLoc);
      units = rulerView->fScale;
      customPts = rulerView->fCustomPoints;
      // 23/07/90 - constrain tab movement if SHIFT key pressed - not ADJUST
      map = wr_akbd_pollsh();
      if (!map)
         constraint = eNoConstraint;
      oldPoints = rulerView->LocToOffset(nearestLoc);
      CvtUnitsToStr(oldPoints, units, customPts, constraint,
                                                      rulerOrigin, aStr);
      if (map)
      {
         if (CvtStrToPoints(aStr, units, customPts, rulerOrigin, points) ==
                                                               kValidValue)
         {
            rulerView->LocateOnRuler(points, nearestLoc);
            nextPoint.h = nearestLoc.h + fMouseOffset.h;
            if (ConstrainInRule(nextPoint.h, rulerView, 
                   constraint, anchorPoint) != nextPoint.h)
            {
               CvtUnitsToStr(oldPoints, units, customPts,
                                           constraint, rulerOrigin, aStr);
               if (CvtStrToPoints(aStr,units,customPts,rulerOrigin,points) ==
                                                               kValidValue)
               {
                  rulerView->LocateOnRuler(points, nearestLoc);
                  nextPoint.h = nearestLoc.h + fMouseOffset.h;
               }
            }
         }
      }
      strncpy(fPositionStr, aStr, kMaxConvLen);
   }
   else
      fPositionStr[0] = 0;
}   


// -------------------------------------------------------------------------
_TTabCommand::_TTabCommand(CmdNumber itsCmdNumber, TRulerScale itsRulerView)
               : (itsCmdNumber, itsRulerView->fDocument, itsRulerView, 0)
{
   fSavedActive = itsRulerView->fActiveTab;
#ifndef ZERO_OBJ
   fSavedSelection = NULL;
   fDoItDone = FALSE; // 26/07/90
#endif
   if ((fChanges = TRulerDef(itsRulerView->fSelectionDef->ShallowClone())) == NULL)
   {
      _TCommand::Free();
      FailOutOfMem();
   }
   fChanges->fDefined |= kRuler;
}


// -------------------------------------------------------------------------
void _TTabCommand::Free()
{
   if (TRulerScale(fView)->fLastCommand == this)
      TRulerScale(fView)->fLastCommand = NULL;

   TTextDocument(fChangedDocument)->CommitStyle(this); // 26/07/90
   FreeIfObject(fChanges);
   FreeIfObject(fSavedSelection);

   _TCommand::Free();
}


// -------------------------------------------------------------------------
void _TTabCommand::UndoIt()
{
   DoIt();
}


// -------------------------------------------------------------------------
void _TTabCommand::RedoIt()
{
   UndoIt();
}


// -------------------------------------------------------------------------
void _TTabCommand::FireReformat()
{
   TRulerDef currentStyle;
   TTextDocument theDocument = TTextDocument(fView->fDocument);

   // 26/07/90 - new fDoItdone field
   if (fDoItDone)
     theDocument->ToggleChanges(fCmdNumber); // 6/5/92
   else
   {
     currentStyle = theDocument->GetCurrentChanges(2);  // 07/02/94 [21446] TRUE);
        // 14 & 25/10/93 Change i/f to indicate whether dialogue style "Changes" wanted
     currentStyle->ApplyOverride(fChanges, gNullCurrency, TRUE);
     theDocument->InstallStyleChange(currentStyle, fCmdNumber); // 6/5/92
     fDoItDone = TRUE;
   }
}


// -------------------------------------------------------------------------
void _TTabCommand::UpdateView()
{
   TRulerScale(fView)->UpdateView();
}


// -------------------------------------------------------------------------
_TTabMoveCommand::_TTabMoveCommand(TRulerScale itsRulerView, Fixed increment) :
  (((int((itsRulerView->fSelectionDef)->GetSelCmdIndex()) + cLeftMarginDialog) == cTabChange ?
      cTabMove :
      (int((itsRulerView->fSelectionDef)->GetSelCmdIndex()) + cLeftMarginDialog)), itsRulerView)
{
   fIncrement = increment;
   fUndoIncrement = increment;
   fKeyIncrement = increment;
}


// -------------------------------------------------------------------------
void _TTabMoveCommand::DoIt()
{
   TRulerDef rulerSel = TRulerScale(fView)->fSelectionDef;

   if (rulerSel != NULL)
   {
      TRulerScale(fView)->fRulerDef->MoveSelection(rulerSel, fIncrement,
                              TRulerScale(fView)->fTextDirection);
      rulerSel->OffsetSelection(fIncrement, TRUE, TRulerScale(fView)->fTextDirection);
      UpdateView();
   }
   // if (!fByKey)
   //   FireTotalChange();
   {
      // in-line FireTotalChange()

      if (fChanges->fSize == 0)
         fChanges->OffsetSelection(fKeyIncrement, TRUE, TRulerScale(fView)->fTextDirection);
      else
      {
         TRulerDef tempDef;

         fChanges->ClearDeletes();
         tempDef = TRulerDef(fChanges->Clone());
         tempDef->OffsetSelection(fKeyIncrement, TRUE, TRulerScale(fView)->fTextDirection);
         fChanges->SetDelState(TRUE);
         fChanges->ApplyOverride(tempDef, gNullCurrency, TRUE);
         FreeIfObject(tempDef);
      }
      fKeyIncrement = 0;
      FireReformat();
   }
   rulerSel = TRulerScale(fView)->fSelectionDef;
   if (rulerSel != NULL)
     fSavedSelection = TRulerDef(rulerSel->Clone());
}


// -------------------------------------------------------------------------
void _TTabMoveCommand::UndoIt()
{
//   fByKey = FALSE;
   fIncrement = -(fUndoIncrement);
   fKeyIncrement = fKeyIncrement + fIncrement;
   fUndoIncrement = fIncrement;
   ReplaceObject(TRulerScale(fView)->fSelectionDef, fSavedSelection);
   // FreeIfObject(TRulerScale(fView)->fSelectionDef);
   // TRulerScale(fView)->fSelectionDef = fSavedSelection;
   DoIt();
}


// -------------------------------------------------------------------------
void _TTabMoveCommand::UpdateRulerDef()
{
   TRulerDef rulerDef;

   if (fKeyIncrement != 0)
   {
      rulerDef = TRulerScale(fView)->fRulerDef;
      if (rulerDef != 0)
      {
         fChanges->ClearDeletes();
         fChanges->SetDelState(TRUE);
         rulerDef->ApplyOverride(fChanges, gNullCurrency, TRUE);
         TRulerScale(fView)->fSelectionDef->fDefined |= kRuler;
         rulerDef->ApplyOverride(TRulerScale(fView)->fSelectionDef,
                                           gNullCurrency, TRUE);
         fChanges->SetDelState(FALSE);
      }
   }
}

#ifdef NEVER
// -------------------------------------------------------------------------
void _TTabMoveCommand::FireTotalChange()
{
   if (fChanges->fSize == 0)
      fChanges->OffsetSelection(fKeyIncrement, TRUE, TRulerScale(fView)->fTextDirection);
   else
   {
      TRulerDef tempDef;

      fChanges->ClearDeletes();
      tempDef = TRulerDef(fChanges->Clone());
      tempDef->OffsetSelection(fKeyIncrement, TRUE, TRulerScale(fView)->fTextDirection);
      fChanges->SetDelState(TRUE);
      fChanges->ApplyOverride(tempDef, gNullCurrency, TRUE);
      FreeIfObject(tempDef);
   }
   fKeyIncrement = 0;
   FireReformat();
}
#endif

// -------------------------------------------------------------------------
_TTabChangeCommand::_TTabChangeCommand(TRulerScale itsRulerView, TFTabInfo &newInfo) :
                                                                (cTabChange, itsRulerView)
{
   fChangedInfo = newInfo;
}


// -------------------------------------------------------------------------
void _TTabChangeCommand::DoIt()
{
   TFTabInfo newInfo;
   TFTabInfo oldInfo;
   register TRulerScale scl = TRulerScale(fView);

   fChanges->ClearDeletes();
   fChanges->Get(1, &oldInfo);

   scl->fRulerDef->DeleteTab(oldInfo);
   newInfo = fChangedInfo;
   fChangedInfo = oldInfo;
   scl->fRulerDef->InstallTab(newInfo);
   if (scl->fSelectionDef != NULL)
      scl->fSelectionDef->AtPut(1, &newInfo);

   fChanges->AtPut(1, &newInfo);
   oldInfo.fDeleted = TRUE;
   fChanges->InstallTab(oldInfo);
   UpdateView();
   FireReformat();
}


// -------------------------------------------------------------------------
_TTabCreateCommand::_TTabCreateCommand(TRulerScale itsRulerView, bool adjust) :
                                                            (cTabCreate, itsRulerView)
{
   fShiftDown = adjust;
}


// -------------------------------------------------------------------------
void _TTabCreateCommand::DoIt()
{
   fChanges->SetDelState(fCmdDone);
   TRulerScale(fView)->fRulerDef->ApplyOverride(fChanges, gNullCurrency, TRUE);
   UpdateView();
   FireReformat();
   if (fSavedActive != NULL)
   {
      bool setActivetab = fShiftDown || fCmdDone;

      fSavedActive->SelectState(setActivetab, kRedraw);
      TRulerScale(fView)->SelectTab(fSavedActive, setActivetab);
      if ((!fCmdDone) && fShiftDown)
         TRulerScale(fView)->InitSelection();
      // 24/05/91 make user click in doc part
      if (setActivetab)
        TRulerScale(fView)->EnsureTarget();
   }
}


// -------------------------------------------------------------------------
_TTabDeleteCommand::_TTabDeleteCommand(TRulerScale itsRulerView) : (cTabDelete, itsRulerView)
{
   // null procedure
}


// -------------------------------------------------------------------------
void _TTabDeleteCommand::DoIt()
{
   fChanges->SetDelState(!fCmdDone);
   TRulerScale(fView)->fRulerDef->ApplyOverride(fChanges, gNullCurrency, TRUE);
   UpdateView();
   FireReformat();
}
