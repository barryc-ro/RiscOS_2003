/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdlib.h>
#include <stdio.h>

#include "swis.h"
#include "akbd.h"
#include "wimp.h"
#include "font.h"

#include "UTextDoc.h"

#ifdef TABLES
#include "UPopup.h"
#endif

extern void DoBordersChange(TStyleFormat self, TRuleType ruleType, CntlAdornment adornment);

// the subsection leading string (it is a string, not a char)
#define kSubSectionStr "§"

// this contains the msg to be used for the default font parts (eg. Trinity.Medium.Default)
#define kDefaultFontStyle 208
#define ePoint10 10

#define kRuleDescrs 40

#if SIDEBAR == 1 || defined TABLES
#ifdef TABLES
static int fontListIds[3] = { I_('T', 'y', 'p', 'e'),
                              I_('W', 'e', 'i', 'g'),
                              I_('S', 't', 'y', 'l') };
static int fontfaceIds[] = { I_('n', 'o', 'r', 'm'),
                              I_('u', 'n', 'd', 'e'),
                              I_('s', 't', 'r', 'k'),
                              0 };
//static IDType XYsizeIds[] = { I_('w', 'i', 'T', 'x'), I_('h', 'g', 'T', 'x') };

//static IDType kIdDef0 = I_('D', 'e', 'f', '0');
//static IDType kIdBelo = I_('B', 'e', 'l', 'o');
//static IDType kIdAbuv = I_('A', 'b', 'u', 'v');
//static IDType kIdFix0 = I_('F', 'i', 'x', '0');
//static IDType kIdLine = I_('L', 'i', 'n', 'e');
//static IDType kIdCust = I_('C', 'u', 's', 't');
//static IDType kIdface = I_('f', 'a', 'c', 'e');
//static IDType kIdBULL = I_('B', 'U', 'L', 'L');
//static IDType kIdTry0 = I_('T', 'r', 'y', '0');
//static IDType kIdDel0 = I_('D', 'e', 'l', '0');
//static IDType kIdAttr = I_('A', 't', 't', 'r');
//static IDType kIdAtab = I_('A', 't', 'a', 'b');

#define kIdwiTx I_('w', 'i', 'T', 'x')
#define kIdhgTx I_('h', 'g', 'T', 'x')
#define kIdDef0 I_('D', 'e', 'f', '0')
#define kIdBelo I_('B', 'e', 'l', 'o')
#define kIdAbuv I_('A', 'b', 'u', 'v')
#define kIdFix0 I_('F', 'i', 'x', '0')
#define kIdLine I_('L', 'i', 'n', 'e')
#define kIdCust I_('C', 'u', 's', 't')
#define kIdface I_('f', 'a', 'c', 'e')
#define kIdBULL I_('B', 'U', 'L', 'L')
#define kIdTry0 I_('T', 'r', 'y', '0')
#define kIdDel0 I_('D', 'e', 'l', '0')
#define kIdAttr I_('A', 't', 't', 'r')
#define kIdAtab I_('A', 't', 'a', 'b')
#else
#define kIdStrU I_('S', 't', 'r', 'U')
#endif
#define kIdtrTx I_('t', 'r', 'T', 'x')
#endif

#define kIdRule I_('R', 'u', 'l', 'e')
#define kIdAdrn I_('A', 'd', 'r', 'n')
#define kIdName I_('N', 'a', 'm', 'e')

#define kIdTop0 gTDDIds[0]
#define kIdLeft gTDDIds[1]
#define kIdBotm gTDDIds[2]
#define kIdRite gTDDIds[3]
#define kIdShdw gTDDIds[4]
#define kIdFN   gTDDIds[5]
 // the following and the zero must be kept in the order required by borders DoChoice
static IDType gTDDIds[7] = { I_('T', 'o', 'p', '0'),
                             I_('L', 'e', 'f', 't'),
                             I_('B', 'o', 't', 'm'),
                             I_('R', 'i', 't', 'e'),
                             I_('S', 'h', 'd', 'w'),
                             I_('F', 'n', 'o', 't'),
                             0 };

#ifdef AUTONUM
static IDType gRads[] =
      { I_('b', 'l', 'c', 'h'), I_('a', 'u', 't', 'o'), I_('c', 'u', 's', 't'), 0 };
static int gCurrentTry = 0;

#define MAXEXPAND 100
// ------------------------------------------------------------------------
char *ExpandLabel(int number, char *format)
{
  char *outp = (char *)malloc( MAXEXPAND + 28);
  char *endp = outp + MAXEXPAND;
  int chr;

  for ( ; outp < endp && (chr = *(format++)) != 0; )
  {
    if (chr == '%')
    {
      int lcase = 0;

      *outp = 0;
      switch (*(format++))
      {
        case 0:
          goto fin;

        case 'a':
          lcase = 32;
        case 'A':
          do
          {
            *(outp++) = 'A' + lcase + (number - 1) % 26;
            number = number - 26;
          }
          while (number > 0);
          continue;

        case 'I':
          lcase = 1;
        case 'i':
          lcase++;
        case '1':
          Roman(number, outp, lcase);
          outp += strlen(outp);
          continue;

        case '2':
          lcase = 0x86;
          break;

        case '3':
          lcase = 0x96;
          break;

        case '4':
          lcase = 0xac;
          break;

        case '5':
          lcase = 0xb6;
          break;

        case '6':
          lcase = 0xc0;
          break;

        case '7':
          lcase = 0xca;
          break;

        case '>':                // 16/12/94 [23021] %> to right justify
          *(outp++) = 21;
          chr = 21;
          break;

        case '{':
          number += (atoi(format) - 1);    // 10/05/96 [27026] %{n} start number
          while (*(format++) != '}' && *format != 0) {}
          continue;
      }
      if (lcase != 0)
        chr = lcase + (number - 1) % 10;
    }
    *(outp++) = chr;
  }
  *outp = 0;
fin:
  return endp - MAXEXPAND;
}
#endif

// ------------------------------------------------------------------------
_TStyleAttrsCommand::_TStyleAttrsCommand(TTextDocument itsDocument,
   CmdNumber itsCmdNumber, TRulerDef theChanges) :
                              (itsCmdNumber, itsDocument, NULL, NULL)
{
  fDocument = itsDocument;
  fChanges = theChanges;
}


// ------------------------------------------------------------------------
void _TStyleAttrsCommand::Free()
{
  fDocument->CommitStyle(this);
  fDocument->GetSelection(TRUE);
  _TCommand::Free();
}


// ------------------------------------------------------------------------
void _TStyleAttrsCommand::DoIt()
{
  fDocument->GetSelection(TRUE);        // commit selection
  fDocument->InstallStyleChange(fChanges, fCmdNumber); // 6/5/92
}


// ------------------------------------------------------------------------
void _TStyleAttrsCommand::RedoIt()
{
  UndoIt();
}


// ------------------------------------------------------------------------
void _TStyleAttrsCommand::UndoIt()
{
  fDocument->ToggleChanges(fCmdNumber); // 6/5/92
}


// ------------------------------------------------------------------------
_TAdornCluster::_TAdornCluster(TDocument itsDocument, TView itsSuperView, char* &itsParams)
                            : (itsDocument, itsSuperView, itsParams)
{
#ifndef ZERO_OBJ
  fBorders = 0;
  fFootnotes = FALSE; // fn1
#endif
// TCluster::  IRes(itsDocument, itsSuperView, itsParams);
}


// ------------------------------------------------------------------------
void _TAdornCluster::DoChoice(TView origView, int itsChoice)
{
  int itsAdType = LookupID(origView->fIdentifier, gTDDIds);

  if (itsAdType >= 0)
  {
    // adnLineTop, adnLineLeft, adnLineBottom, adnLineRight or adnShadow (+ Footnote rule)
    // DoAdornment(itsAdType < 4 ? 1 << itsAdType : adnShadow); in-line
    AdornPieces adnType = (itsAdType < 4 ? 1 << itsAdType : adnShadow);
    CntlAdornment adornment;

    adornment = fBorders;
    adornment ^= adnType;
    SetAdornment(adornment, TRUE, fFootnotes); // fn1
    _TCluster::DoChoice(this, mAdorned);
  }
  else if (itsChoice == mSelPicture)
    _TCluster::DoChoice(this, mAdorned);
}


// ------------------------------------------------------------------------
void _TAdornCluster::GetRuleType(TRuleType &ruleType)
{
  TRulePicture rules;

  rules = TRulePicture(FindSubView(kIdRule));
#ifdef TRACE
  Assert(rules, 21);
#endif
  ruleType = rules->GetCurrentRule();
}


// ------------------------------------------------------------------------
void _TAdornCluster::SetRuleType(TRuleType ruleType)
{
  TRulePicture rules;
  rules = TRulePicture(FindSubView(kIdRule));
#ifdef TRACE
  Assert(rules, 21);
#endif
  rules->SetCurrentRule(ruleType); // , TRUE);
  rules->ForceRedraw();              // 15/01/91
}


// ------------------------------------------------------------------------
void _TAdornCluster::GetAdornment(CntlAdornment &adornment)
{
  adornment = fBorders;
}


// ------------------------------------------------------------------------
void _TAdornCluster::SetAdornment(CntlAdornment adornment, bool redraw, 
                                  bool footnotes)
{
  TCheckBox shdwIcon;
#ifdef FN
  TCheckBox fnIcon;
#endif
  bool dimmed;

  fBorders = adornment;
  fFootnotes = footnotes; // fn1
  shdwIcon = TCheckBox(FindSubView(kIdShdw));
#ifdef FN
  fnIcon = TCheckBox(FindSubView(kIdFN));
  if (footnotes)
  {
    shdwIcon->Show(FALSE, redraw);
    shdwIcon = fnIcon;
  }
  else
    fnIcon->Show(FALSE, redraw);
#endif
#ifdef TRACE
  Assert(shdwIcon, 21);
#endif

  dimmed = (adnShadow & adornment) / adnShadow;
  shdwIcon->HiliteState(dimmed, redraw);
  for (int i = 0; i < 4; i++)
  {
    TControl checkBox = SetDimState(gTDDIds[i], dimmed);

    if (checkBox)
      checkBox->SetState(((adornment >> i) & 1) | dimmed, redraw);
  }
}

#if SIDEBAR == 1 || defined TABLES
// ------------------------------------------------------------------------
static TControl GetTryTextSizes(TDialogView self, wr_os_regset *r)
{
  TControl tryText = TControl(self->FindSubView(kIdtrTx));

  if (tryText != NULL && tryText->fFont >= 0)
  {
    r->r[0] = tryText->fFont;
    r->r[3] = 0;            // r3 used as magic number on Risc_OS3
    FailOSErr(wr_os_swix(Font_ReadDefn, r));
    return tryText;
  }
  return NULL;
}
#endif

#ifdef TABLES
// ------------------------------------------------------------------------
_TTextAttrsDlg::_TTextAttrsDlg(TDocument doc, TView super, char* &pars) :
                                   (doc, super, pars)
{}

// ------------------------------------------------------------------------
void _TTextAttrsDlg::Free()
{
  FreeIfObject(fStyleFormat);
  _TTypeSpecDlg::Free();
}


// ------------------------------------------------------------------------
int _TTextAttrsDlg::DoSetDescription(char *prefix)
{
  Str255 desc;

  strcpy(desc, prefix);
  fChanges->GetDescription(desc);
  WriteText(kIdAttr, desc);
  return desc[0] == 0;
}

// ------------------------------------------------------------------------
int _TTextAttrsDlg::SetDescription()
{
  return DoSetDescription("");
}


// ------------------------------------------------------------------------
void _TTextAttrsDlg::DoChoice(TView origView, int itsChoice)
{
  _TTypeSpecDlg::DoChoice(origView, itsChoice); // 14/06/90 - zapped else...
}


// ------------------------------------------------------------------------
void _TTextAttrsDlg::ResetStyle()
{
  int noChanges;

  if (fStyleFormat->MergeEmphasisAttrs(fChanges, TRUE)) {}
  //    SetTextMenus(fStyleFormat, fParagraph, fTextSizeX, fTextSizeY);

  noChanges = SetDescription();

  // dim out the Delete changes button if necessary
  // 23/07/96 [27030] test for insertion in emphasis
  SetDimState(kIdDel0, noChanges | (fParagraph && (fChanges->fDefined & kEmphasis) != 0));
}


// ------------------------------------------------------------------------
void _TTextAttrsDlg::SetAttrs(TStyleFormat itsStyleFormat, TStyleFormat itsChanges, bool para)
{
  itsStyleFormat->MakeClone(&fStyleFormat);
  fStyleFormat->ApplyOverride(itsChanges, gNullCurrency, TRUE);
  fChanges = itsChanges;
  fParagraph = para;
}


// ------------------------------------------------------------------------
_TTypeSpecDlg::_TTypeSpecDlg(TDocument itsDocument, TView itsSuperView,
             char* &itsParams) : (itsDocument, itsSuperView, itsParams)
{
#ifndef ZERO_OBJ
  fStyleFormat = NULL;
  fChanges = NULL;
  fParagraph = FALSE;
  fTextSizeX = 0;
  fTextSizeY = 0;
#endif
  SetIdleFreq(0);  // 15/11/90 to get the size fields read before pressing TRY
}


// ------------------------------------------------------------------------
void _TTypeSpecDlg::InitialiseTypeSpecDlg()  // 07/06/90 - new method
{
  int i;

  // 10/09/90 use loop instead of 3 times in line
  // create the 3 arrays from the system font tree
  // i == 0 : build up the main font list array...
  // i == 1 : font weight list
  // i == 2 ; font style list
  for (i = 0; i < 3; i++)
  {
    TPopup popup = TPopup(FindSubView(fontListIds[i]));
#ifdef TRACE
    Assert(popup, 21);
#endif
    // set up Font menu
    MenuHandle *fontMenu = GetResMenu(popup->fMenuID);
    DelMenuItems(fontMenu, 1);

    if (i == 0)
    {
      // this bit only for the font name array
      FontTree *ptr;

      CheckInstalledFonts();                         // 20/05/91
      ptr = (FontTree *) gFontHead.info.childPtr;
      while (ptr != NULL)
      {
        AppendMenuItem(fontMenu, ptr->fonttext);
        ptr = (FontTree*) ptr->info.brotherPtr;
      }
    }
  }
  SetReadWriteHandler(this);
}


// ------------------------------------------------------------------------
void _TTypeSpecDlg::PullOutFontInfo(char* fontName, int *sizes)
{
  // this returns the font name and size entered from the dialog
  char *match = "";
  TFixedPtText sizeBox;
  TControl aspectBox;
  int i;

  for (i = 0; i < 3; i++)
  {
    TPopup fontNameList = TPopup(FindSubView(fontListIds[i]));
    char buffer[24];

    fontNameList->GetText(buffer);
    if (strcmp(buffer + 1, match) == 0)
      break;
    if (i == 0)
      strcpy(fontName, buffer + 1);   // that is the name copied
    else
    {
      buffer[0] = '.';
      strcat(fontName, buffer);       // that is .name copied
    }
    match = GetString(kDefaultFontStr + i * 3);
  }

  sizes[1] = fTextSizeY;
  if ((sizeBox = TFixedPtText(FindSubView(kIdhgTx))) != NULL)
    sizes[1] = (sizeBox->GetPoints() * 16) / (kFix1 * 10);

  sizes[0] = fTextSizeX;
  if ((aspectBox = TFixedPtText(FindSubView(kIdwiTx))) != NULL)
    sizes[0] = (aspectBox->GetValue() * sizes[1]) / 100;  // 21/03/94 Aspect ratio
//  for (i = 0; i < 2; i++)
//  {
//    TFixedPtText sizeBox = TFixedPtText(FindSubView(XYsizeIds[i]));

//    if (sizeBox != NULL)
//      *(sizes++) = (sizeBox->GetPoints() * 16) / (kFix1 * 10);
//  }
}


// ------------------------------------------------------------------------
void _TTypeSpecDlg::SetPopup(TControl pop, int fontSel, int weightSel)
{
  // rebuild the scrolling list
  MenuHandle *theMenu = GetResMenu(TPopup(pop)->fMenuID);
  Str255 oldName;
  int itemToSet;
  FontTree* ptr = (FontTree*) gFontHead.info.childPtr;
  bool hasDefault;

  itemToSet = TPopup(pop)->GetCurrentItem();
  if (itemToSet <= 0)  // 20/05/91
    oldName[0] = 0;
  else
    TPopup(pop)->GetItemText(itemToSet, oldName);
  DelMenuItems(theMenu, 1);
  /*Get the pointer to the item's weight. The list is in alphabetical
      order so just count to the value of the list fCurrentValue field */
  for (int n = 1; n < fontSel; n++)
    ptr = (FontTree *) ptr->info.brotherPtr;

  hasDefault = (ptr->info.terminal);
  ptr = (FontTree*) ptr->info.childPtr;

  if (weightSel != 0 && ptr == NULL)
     AppendMenuItem(theMenu, GetString(kDefaultFontStyle));
  else
  {
    if (weightSel != 0)
    {
       for (int n = hasDefault + 1; n < weightSel; n++)
          ptr = (FontTree *) ptr->info.brotherPtr;
       hasDefault = (ptr->info.terminal);
       ptr = (FontTree*) ptr->info.childPtr;
    }
    if (hasDefault)
      AppendMenuItem(theMenu, GetString(weightSel == 0 ?
                              kDefaultFontStr : kDefaultFontStyle));
    while (ptr != NULL)
    {
      int idx = AppendMenuItem(theMenu, ptr->fonttext);

      if (strcmp(ptr->fonttext, oldName) == 0)
        itemToSet = idx;    // 07/09/94 CountMItems(*theMenu);
      ptr = (FontTree *) ptr->info.brotherPtr;
    }
  }
  if (itemToSet > CountMItems(*theMenu))
    itemToSet = 1;
  TPopup(pop)->SetCurrentItem(itemToSet, kRedraw);
}


// ------------------------------------------------------------------------
void _TTypeSpecDlg::DoChoice(TView origView, int itsChoice)
{
  TPopup styleList;
  TPopup fontNameList;
  TPopup weightList;
  FontTree* ptr = (FontTree*) gFontHead.info.childPtr;

  switch (itsChoice)
  {
    case mControlHit:
      if ((origView->fIdentifier >> 16) == (('s' << 8) | 'i')) // 07/08/90 - size id
      {
        // clicked on one of the point size boxes
        int newSize;
        TFixedPtText numbTxt;
        Str255 theStr;

        TControl(origView)->GetText(theStr);
        StringToNum(theStr, newSize);
        newSize = ToFixed(newSize) * 10;
//        for (int i = 0; i < 2; i++)
//        {
//          numbTxt = TFixedPtText(FindSubView(XYsizeIds[i]));
//          if (numbTxt != NULL)
//            numbTxt->SetPoints(newSize, kRedraw);
//        }
        if ((numbTxt = TFixedPtText(FindSubView(kIdhgTx))) != NULL)
          numbTxt->SetPoints(newSize, kRedraw);
      }
      else if (origView->fIdentifier == kIdTry0)
      {
        SetTryText(TRUE);
        // clicked on the Try button so pull out the font info...
      }
      break;

#ifdef NEVER
  // 21/03/94 not needed with aspect ratio
  case mFixedPtTextHitDown:
  case mFixedPtTextHitUp:
      if (wr_akbd_pollsh())  // SHIFT key pressed so change other numbertext
      {
        for (int i = 0; i < 2; i++)
          if (origView->fIdentifier == XYsizeIds[i])
          {
            TFixedPtText numbTxt = TFixedPtText(FindSubView(XYsizeIds[1 - i]));

            if (numbTxt != NULL)
              numbTxt->IncrementValue(itsChoice);
          }
      }
      break;
#endif

    case mPopupHit:
#ifdef AUTONUM
      // 16/12/94 [23021] popup on custom text
      if (origView->fIdentifier == I_('c', 't', 'x', 't'))
      {
        WriteText(origView->fIdentifier,
                          GetRsrcMisc(TPopup(origView)->GetCurrentItem() + 40));
        //for (IDType *i = gRads; *i; i++)
        //  WriteCheckBox(*i, *i == gRads[2]);
        WriteCheckBox(gRads[2], TRUE);  // 21/04/95
        SelectEditText(origView->fIdentifier);
      }
      else
#endif
      if (origView->fIdentifier == fontListIds[1] ||
                               origView->fIdentifier == fontListIds[0])
      {
        bool hasDefault = FALSE;
        fontNameList = TPopup(FindSubView(fontListIds[0]));
        weightList = TPopup(FindSubView(fontListIds[1]));
        styleList = TPopup(FindSubView(fontListIds[2]));

        if (origView->fIdentifier == fontListIds[0])
        {
          // rebuild the weight scrolling list
          SetPopup(weightList, fontNameList->GetCurrentItem(), 0);
        }
        // rebuild the style scrolling list
        SetPopup(styleList, fontNameList->GetCurrentItem(),
                                          weightList->GetCurrentItem());
      }
      break;

#ifdef AUTONUM
    case mRadioHit:
      SelectEditText(origView->fIdentifier == gRads[2] ?
                                 I_('c', 't', 'x', 't') : I_('b', 't', 'x', 't'));
      break;
#endif
  }

  _TDialogView::DoChoice(origView, itsChoice);  // 14/06/90 - moved
                                                // from default option
}


// ------------------------------------------------------------------------
void _TTypeSpecDlg::ResetStyle()
{
  fStyleFormat->MergeEmphasisAttrs(fChanges, FALSE);
#ifdef TRACE
  Assert((fStyleFormat->fDefined & kSize) != 0, 1010);
#endif
  fTextSizeX = ((fStyleFormat->fDefined & kSize) != 0 ? fStyleFormat->fTextSizeX : 12 * 16);
  fTextSizeY = ((fStyleFormat->fDefined & kSize) != 0 ? fStyleFormat->fTextSizeX : 12 * 16);
}


// ------------------------------------------------------------------------
void _TTypeSpecDlg::SetAttrs(TStyleFormat itsStyleFormat, TStyleFormat itsChanges, bool paragraph)
{
  TFixedPtText sizeTxt;

  fParagraph = paragraph;
  fStyleFormat = itsStyleFormat;
  fChanges = itsChanges;

#ifdef TRACE
  Assert((fStyleFormat->fDefined & kSize) != 0, 1011);
#endif
  fTextSizeX = fStyleFormat->fTextSizeX;
  fTextSizeY = fStyleFormat->fTextSizeY;
  WriteValueRedraw(kIdwiTx, (fTextSizeX * 100) / fTextSizeY); // 21/03/94 set Aspect ratio

  if ((sizeTxt = TFixedPtText(FindSubView(kIdhgTx))) != NULL)
  {
    sizeTxt->SetScale(ePoint16, sizeTxt->fCustomPoints, kDontRedraw);
    sizeTxt->SetLimits(FixPointVal(1280), FixPointVal(40), TRUE);
    sizeTxt->SetPoints((fTextSizeY * kFix1 * 10) / 16, kRedraw);
  }

  ResetStyle();
}


// ------------------------------------------------------------------------
bool _TTypeSpecDlg::DoIdle(IdlePhase phase)
{
  // 08/02/91 need to reset the font handles to stop ROM crashing
  // 26/10/94 on RISC_OS2
  if (phase == idleBegin && gWimpVersion < 300)
    SetTryText(FALSE);

  return _TDialogView::DoIdle(phase);
}


// ------------------------------------------------------------------------
void _TTypeSpecDlg::SetTryText(bool fromDlg)
{
  // 08/01/91 experiment to see if we can stop real-font icons crashing
  TControl tryText;
  char fontName[64];
  wr_os_regset r;

  tryText = TControl(FindSubView(kIdtrTx));
  if (tryText != NULL)
  {
#ifdef AUTONUM
    TCluster bullClust = TCluster(FindSubView(I_(0, 0, 0, 'b')));

    if (bullClust)
    {
      int theBullet = LookupID(bullClust->ReportCurrent(),gRads);
      char *hdl;
      char theText[32];

      switch (theBullet)
      {
        case 0:
          TControl(FindSubView(I_('b', 't', 'x', 't')))->GetText(theText);
          break;

        case 2:
          TControl(FindSubView(I_('c', 't', 'x', 't')))->GetText(theText);
          break;

        default:
          strcpy(theText, "%1");
      }
      if (fromDlg)
        gCurrentTry = (gCurrentTry == 10 ? 1 : gCurrentTry + 1);
      hdl = ExpandLabel(gCurrentTry, theText);
      tryText->SetText(hdl, 2);     // 16/12/94 2 to rejustify: kRedraw);
      free(hdl);
    }
#endif
    r.r[1] = (int)fontName;
    if (fromDlg)
      PullOutFontInfo(fontName, r.r + 2);      // r.r[2], r.r[3]);
    else if (GetTryTextSizes(this, &r) == NULL)
      return;

    tryText->SetFont(fontName, r.r[2], r.r[3]);
  }
}

// ------------------------------------------------------------------------
TCommand _TTypeSpecDlg::DoKeyCommand(int chcode, EventInfo &info)
{
  SetTryText(FALSE);
  return _TDialogView::DoKeyCommand(chcode, info);
}

// ------------------------------------------------------------------------
TCommand _TTypeSpecDlg::ReadFromDialog(TView aDialog, CmdNumber aCmd, IDType itsId)
{
  if (aCmd != cChangeStyle)       // 03/10/90
  {
    // it is OK on font selector or list selector (else a Changes...) command
    char fontName[60];
    int sizes[2];   // sizeX, sizeY;
    int textFont;

    PullOutFontInfo(fontName, sizes);    // sizeX, sizeY);

    strcpy((fIdentifier == kIdBULL ? fChanges->fBulletFontName :
               fChanges->fFontName), fontName); // 12/06/90 - bullet fnt
#ifdef TRACE
    Assert(fDocument, 33);
#endif
    textFont = TTextDocument(fDocument)->GetFNum(fontName);

    if (fIdentifier == kIdBULL)  // 01/06/90 - these bits new for bullets
    {
      char theText[32];
      int  theBullet;
      bool autoBullet = TestCheckBox(kIdAtab);
                 // TControl(FindSubView(kIdAtab))->IsOn();   // [20981]

#ifdef AUTONUM
      int autoChanged = FALSE;

      switch (theBullet = 
                LookupID(TCluster(FindSubView(I_(0, 0, 0, 'b')))->ReportCurrent(), gRads))
      {
        case 0:
          TControl(FindSubView(I_('b', 't', 'x', 't')))->GetText(theText);
          theBullet = (theText[0] < 32 ? 0 : theText[0]);
          break;

        case 2:
          TControl(FindSubView(I_('c', 't', 'x', 't')))->GetText(theText);
          autoChanged = strcmp(fStyleFormat->GetAutoCustom(), theText);
          break;
      }
#else
#define autoChanged FALSE
      TControl(FindSubView(kIdtrTx))->GetText(theText);
      theBullet = (theText[0] < 32 ? 0 : theText[0]);
#endif
        
      if (fStyleFormat->fBulletFont != textFont ||
          fStyleFormat->fAutoBullet != autoBullet ||    // [20981]
          fStyleFormat->fBullet != theBullet || autoChanged)
      {          
        // bullet font name or bullet character has changed...
        fChanges->fDefined |= kBullet;
        fChanges->fBulletFont = textFont;
        fChanges->fAutoBullet = autoBullet;     // [20981]
        fChanges->fBullet = theBullet;
#ifdef AUTONUM
        if (theBullet == 2)
          fChanges->SetAutoCustom(theText);
#endif
      }
    }
    else
    {
      int chg;

      // 23/05/90 - put if clause round changes setting
      if ((fStyleFormat->fDefined & kSize) && ((fStyleFormat->fTextSizeX != sizes[0]) ||
             (fStyleFormat->fTextSizeY != sizes[1])))
      {
        // size has changed...
        fChanges->fDefined |= (kSize | kEmphasis);  // 04/07/91 | KEmph
        fChanges->fTextSizeX = sizes[0];
        fChanges->fTextSizeY = sizes[1];
      }

      // 31/05/90 - the font name is ALWAYS in the style - it will be the default name if not
      // overridden - the TextFont field, however, will be 0 if it is not overridden

      if ((fStyleFormat->fDefined & kFont) && (fStyleFormat->fTextFont != textFont))
      {
        //  font name/weight/style has changed...
        fChanges->fDefined |= (kFont | kEmphasis);  // 04/07/91 | KEmph
        //        strcpy(fChanges->fFontName, fontName);
        fChanges->fTextFont = textFont;
      }

      // 01/06/90 - textface underline/strikeout added
      chg = LookupID(TCluster(FindSubView(kIdface))->ReportCurrent(), fontfaceIds);
      if ((fStyleFormat->fDefined & kFace) && (fStyleFormat->fTextFace & 3) != chg)
      {
        fChanges->fDefined |= (kFace | kEmphasis);  // 04/07/91 | KEmph

        // get rid of any settings in changes and set the new one
        fChanges->fTextFace = (fChanges->fTextFace & ~(kUnderline | kStrikeOut)) | 
                      (chg == 0 ? (kUnderline | kStrikeOut) : chg);
                              // [20983] explicit set normal is both underline and strikout
      }
    }

    ResetStyle();
  }
  return new _TStyleAttrsCommand(TTextDocument(fDocument), aCmd, fChanges);
}


// ------------------------------------------------------------------------
void _TTypeSpecDlg::WriteToDialog(TView aDialog, CmdNumber aCmd)
{
  TPopup list;
  int            typePos = 1;
  int            weightPos = 1;
  int            stylePos = 1;
  Str255         buffer;
  FontTree*      ptr = (FontTree*) gFontHead.info.childPtr;
  char*          dot;
  char*          name;
  char*          offset = buffer; // 26/04/90 point offset to buffer
  bool           hasDefault = FALSE;
  int            textFont;

  {
    // 11/11/90 get changes reset
    TTextDocument doc = TTextDocument(fDocument);

    doc->CommitLastDocCommand();        // 16/04/93 from CommitLastCommand
    doc->CommitStyle(TCommand(-1));
    fChanges = TStyleFormat(doc->GetCurrentChanges(TRUE));
        // 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted

  }

  SetAttrs(fStyleFormat, fChanges, fParagraph);

  // show the name of the bullet font if it is a bullet dialog - 01/06/90
  if ((fIdentifier == kIdBULL) && (fStyleFormat->fBulletFont != 0))
    textFont = fStyleFormat->fBulletFont;
  else
    textFont = fStyleFormat->fTextFont;
  name = TTextDocument(fDocument)->GetFName(textFont);
  strcpy(buffer, name);

  // from the font string, get the array elements to hilite
  dot = strchr(buffer, '.');
  name = buffer;
  if (dot != NULL)
  {
    offset = dot + 1;
    dot[0] = 0; // change the . into a terminator
  }
  while ((ptr != NULL) && (strcmp(name, ptr->fonttext) != 0))
  {
    ptr = (FontTree*) ptr->info.brotherPtr;
    typePos ++;
  }
#ifdef TRACE
  Assert(ptr, 34);
#endif

  if (dot != NULL)
  {
    dot = strchr(offset, '.');
    hasDefault = ptr->info.terminal;
    ptr = (FontTree*) ptr->info.childPtr;
    name = offset;
    if (dot != NULL)
    {
      offset = dot + 1;
      dot[0] = 0; // change the . into a terminator
    }
    while ((ptr != NULL) && (strcmp(name, ptr->fonttext) != 0))
    {
      ptr = (FontTree*) ptr->info.brotherPtr;
      weightPos ++;
    }
    if ((ptr != NULL) && (hasDefault)) weightPos ++;
#ifdef TRACE
    Assert(ptr, 34);
#endif

    if (dot != NULL)
    {
      name = offset;
      hasDefault = ptr->info.terminal;
      ptr = (FontTree*) ptr->info.childPtr;
      while ((ptr != NULL) && (strcmp(name, ptr->fonttext) != 0))
      {
        ptr = (FontTree*) ptr->info.brotherPtr;
        stylePos ++;
      }
      if ((ptr != NULL) && (hasDefault)) stylePos ++;
#ifdef TRACE
      Assert(ptr, 34);
#endif
    }
  }

  list = TPopup(FindSubView(fontListIds[0]));
  list->SetCurrentItem(typePos, kRedraw);
  DoChoice(list, mPopupHit); // this gets the weight list redrawn

  list = TPopup(FindSubView(fontListIds[1]));
  list->SetCurrentItem(weightPos, kRedraw);
  DoChoice(list, mPopupHit); // this gets the style list redrawn

  list = TPopup(FindSubView(fontListIds[2]));
  list->SetCurrentItem(stylePos, kRedraw);

  if (fIdentifier == kIdBULL)
  {
    // if it is a bullet dialog, set the bullet char text as appropriate - 01/06/90
    char blk[2];
    
    blk[0] = fStyleFormat->fBullet;
    blk[1] = 0;
#ifdef AUTONUM
    int autoNum = 0;
    TControl ctxt;

    if (fStyleFormat->fBullet == 1 || fStyleFormat->fBullet == 2)
    {
      blk[0] = 0x8f;
      autoNum = fStyleFormat->fBullet;
    }
    //for (IDType *i = gRads; *i; i++)
    //  WriteCheckBox(*i, *i == gRads[autoNum]);
    WriteCheckBox(gRads[autoNum], TRUE);
    WriteText(I_('b', 't', 'x', 't'), blk);
    ctxt = WriteText(I_('c', 't', 'x', 't'), fStyleFormat->GetAutoCustom());
    if (autoNum == 2)
    {
      DoSelectEditText(ctxt);
      fReserved = TRUE;
    }
    //ctxt = TControl(FindSubView(I_('s', 'a', 'm', 'p')));
    //if (ctxt != NULL)
    //  TPopup(ctxt)->SetCurrentItem(1, kRedraw);
#endif
    WriteText(kIdtrTx, blk);
    WriteCheckBox(kIdAtab, fStyleFormat->fAutoBullet);
  }
  else
  {
    // if it is a normal font dialog, show the underline/strikeout button setting - 01/06/90
    // TControl radBut;
    IDType id;
    
    id = fontfaceIds[(fStyleFormat->fTextFace & 3) % 3]; // set to norm in case both get set

    //radBut = 
    WriteCheckBox(id, TRUE);
    // 21/04/95 if (radBut != NULL)
    //  radBut->DoChoice(radBut, mRadioHit);
  }

  SetTryText(TRUE);
}
#endif


// ------------------------------------------------------------------------
// --------  TSpacingDlg
// ------------------------------------------------------------------------
_TSpacingDlg::_TSpacingDlg(TDocument itsDoc, TView itsSuperV, char* &itsParams)
                                           : (itsDoc, itsSuperV, itsParams)
{}

#if SIDEBAR == 1
static char gStdSizes[] = {0, 8, 10, 12, 14, 18, 24, 28, 36, 48, 72, 255 };

static void SetNewTitle(TSpacingDlg self, int newSize)
{
  char buff[40];

  sprintf(buff, GetRsrcMisc(30), newSize >> 4);
  self->SetTitle(buff);
}

#endif

// ------------------------------------------------------------------------
bool _TSpacingDlg::DoIdle(IdlePhase phase)
{
#if SIDEBAR == 1
  // 08/02/91 need to reset the font handles to stop ROM crashing
  if (phase == idleBegin && gWimpVersion < 300)
  {
    TControl tryText;
    wr_os_regset r;
    char fontName[64];

    r.r[1] = (int)fontName;
    tryText = GetTryTextSizes(this, &r);
    if (tryText != NULL)
      tryText->SetFont(fontName, r.r[2], r.r[2]);
  }
#endif

  return _TDialogView::DoIdle(phase);
}

// ------------------------------------------------------------------------
void _TSpacingDlg::DoChoice(TView origView, int itsChoice)
{
#if defined TABLES && !defined NETWP
  TFixedPtText editText;
  TCheckBox checkBox;

  if (origView->fIdentifier == kIdCust)
  {
    int val;

    checkBox = TCheckBox(origView);
    editText = TFixedPtText(FindSubView(kIdLine));

    if (!checkBox->IsOn())
      val = 0;
    else
    {
      val = FromFixed(editText->GetPoints());
      if (val == 0)
        val = -1;
    }
    DoLineSpacing(fChanges, val);
    ResetStyle(FALSE);       // 21/02/91 do not reset sp above & below
  }
  else if (origView->fIdentifier == kIdFix0)
  {
    checkBox = TCheckBox(origView);
    if ((fChanges->fDefined & kLeading) == 0)
      DoLineSpacing(fChanges, fStyleFormat->fLeading);
    fChanges->fFixedHeight = (fChanges->fFixedHeight & 0xfffffffe) | checkBox->IsOn();
  }
  else
#endif
#if SIDEBAR == 1
  if (origView->fIdentifier == kIdStrU)
  {
    TControl tryText;
    wr_os_regset r;
    char fontName[64];

    r.r[1] = (int)fontName;
    tryText = GetTryTextSizes(this, &r);

    if (tryText != NULL)
    {
      int newSize;

      if (wr_akbd_pollsh())
      {
        if (itsChoice == mUpArrowHit)
          newSize = Min(r.r[2] + 16, 128 * 16);
        else
          newSize = Max(r.r[2] - 16, 4 * 16);
      }
      else
      {
        char *p;

        if (itsChoice == mUpArrowHit)
        {
          for (p = gStdSizes; r.r[2] >= (newSize = *p * 16); p++) {}
          if (newSize > 72 * 16)
            newSize = 72 * 16;
        }
        else
        {
          for (p = gStdSizes + 11; r.r[2] <= (newSize = *p * 16); p--) {}
          if (newSize < 8 * 16)
            newSize = 8 * 16;
        }
      }
      if (newSize != r.r[2])
      {
        tryText->SetFont(fontName, newSize, newSize);
        SetNewTitle(this, newSize);
      }
    }
  }
  else
#endif
  if (itsChoice == mAdorned)
  {
    TRuleType ruleType;

    TAdornCluster(origView)->GetRuleType(ruleType);
    WriteText(kIdName, GetIndString(kRuleDescrs, OldRuleType(ruleType))); // 22/10/91
  }

  _TDialogView::DoChoice(origView, itsChoice);  // 15/06/90 - do this no matter
}


#ifdef TABLES
// ------------------------------------------------------------------------
void _TSpacingDlg::ResetStyle(bool resetSp)
{
  TFixedPtText abuv, belo;

  fStyleFormat->ApplyOverride(fChanges, gNullCurrency, FALSE);
  abuv = TFixedPtText(FindSubView(kIdAbuv));
  if (resetSp)
  {
    belo = TFixedPtText(FindSubView(kIdBelo));
#ifdef TRACE
    Assert(abuv && belo, 21);
#endif
    fAbovePts = 0;
    if (fStyleFormat->fDefined & kHasSpaceBefore)
    {
      if (fStyleFormat->fDefined & kOwnSpaceBefore)
        fAbovePts = fStyleFormat->fOwnSpaceBefore;
    }
    else
    {
// 17/06/92
#ifdef EDITSTYLES
      if (fStyleFormat->fDefined & kSpaceBefore)
#endif
        fAbovePts = fStyleFormat->fSpaceBefore;
    }
    abuv->SetPoints(ToFixed(fAbovePts), FALSE);

    fBelowPts = 0;
    if (fStyleFormat->fDefined & kHasSpaceAfter)
    {
      if (fStyleFormat->fDefined & kOwnSpaceAfter)
        fBelowPts = fStyleFormat->fOwnSpaceAfter;
    }
    else
    {
// 17/06/92
#ifdef EDITSTYLES
      if (fStyleFormat->fDefined & kSpaceAfter)
#endif
        fBelowPts = fStyleFormat->fSpaceAfter;
    }
    belo->SetPoints(ToFixed(fBelowPts), FALSE);
  }

  fLeading = 0;
  if (fCanType)
  {
    TControl checkBox;

    WriteCheckBox(kIdFix0, Odd(fStyleFormat->fFixedHeight)); 

    // 25/05/90 - picspacing dialog does not have line height
    checkBox = WriteCheckBox(kIdCust, fStyleFormat->fLeading != 0);
    if (checkBox != NULL)
    {
      // prev. setlineheight local procedure
      TFixedPtText editText;
      bool newState = FALSE;
      Fixed fontAscent, fontDescent, fontLeading;  // 29/04/91
      TTextDocument document = TTextDocument(fDocument);
      
      editText = TFixedPtText(FindSubView(kIdLine));
#ifdef TRACE
      Assert(editText, 21);
#endif
//    fStyleFormat->UpdateFontMetrics();         // 16/04/91
      // 29/04/91 following 2 calls replace fStyleFormat->UpdateFontMetrics
      document->SetCurrentFont(PFontStyle(&fStyleFormat->fTextFont));
      MeasureFont(fontAscent, fontDescent, fontLeading);
      if (fStyleFormat->fLeading < 0)
      {
        // 11/07/90 - get the auto leading from the font
        fChanges->fLeading = FixRound(fontLeading + fontAscent + fontDescent);

        fLeading = fChanges->fLeading;
        DoSelectEditText(editText);
      }
      else if (fStyleFormat->fLeading > 0)
      {
        bool editEnabled = editText->IsViewEnabled();
        
        if (!editEnabled)
          DoSelectEditText(editText);
        fLeading = fStyleFormat->fLeading;      // 21/02/91 ??
      }
      else
      {
        // 11/07/90 - get the auto leading from the font
        fLeading = FixRound(fontLeading + fontAscent + fontDescent);
        
        newState = TRUE;
        // 15/06/90 - get the edit put into the abuv box
        if (fCurrentEditText == editText)
          DoSelectEditText(abuv);
      }
      editText->DimState(newState, kRedraw);
      editText->ForceRevalidation(); // 12/07/90
      editText->SetPoints(ToFixed(fLeading), FALSE);
    }
  }
}


// ------------------------------------------------------------------------
void _TSpacingDlg::SetAttrs(TStyleFormat itsStyleFormat, TStyleFormat itsChanges, bool canType)
{
  TFixedPtText theText;

  fStyleFormat = itsStyleFormat;
  fChanges = itsChanges;
  fCanType = canType;

  // 23/05/90 - set up the fixed pt text scales & limits
  // 19/11/90 - scale units set to ePoint10, so decimal value displayed

  theText = TFixedPtText(FindSubView(kIdAbuv));
  theText->SetScale(ePoint10, theText->fCustomPoints, kDontRedraw);
  theText->SetLimits(ToFixed(256 * 10), ToFixed(0), TRUE);

  theText = TFixedPtText(FindSubView(kIdBelo));
  theText->SetScale(ePoint10, theText->fCustomPoints, kDontRedraw);
  theText->SetLimits(ToFixed(256 * 10), ToFixed(0), TRUE);

  // 25/05/90 - picspacing has no 'Line' field
  theText = TFixedPtText(FindSubView(kIdLine));

  if (theText != NULL)
  {
    theText->SetScale(ePoint10, theText->fCustomPoints, kDontRedraw);
    theText->SetLimits(ToFixed(256 * 10), ToFixed(0), TRUE);

    // 10/07/90 - make sure there is a font there and it is set up
    //            so that the auto leading can be easily found.
    //            The else leading = 0 bit is to check if there are
    //            cases when a font name is not present (should not be)
/* 29/04/91 gets set in ResetStyle
    if (fStyleFormat->fFontName[0] != 0)
      fStyleFormat->UpdateFontMetrics();
    else
      fStyleFormat->fFontLeading = 0;
*/
  }
}
#endif


// ------------------------------------------------------------------------
void _TSpacingDlg::WriteToDialog(TView aDialogView, CmdNumber aCmd)
{
  TTextDocument doc = TTextDocument(fDocument);

  DECLARE(aDialogView);
  {
    // 11/11/90 get changes reset

    doc->CommitLastDocCommand();        // 16/04/93 from CommitLastCommand
    doc->CommitStyle(TCommand(-1));
    fChanges = TStyleFormat(doc->GetCurrentChanges(TRUE));
       // 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted
  }

#ifdef TABLES
  if (aCmd == cSpacing)
  {
    SetIdleFreq(0);        // 19/11/90 for validation of fixed pt fields
    ResetStyle(TRUE);     // 21/02/91 reset all values
  }
  else
#endif
#if SIDEBAR == 1
  if (aCmd == cSizeDialog)
  {
    TControl tryText = TControl(FindSubView(kIdtrTx));

    fStyleFormat->ApplyOverride(fChanges, gNullCurrency, FALSE);
    tryText->SetFont(doc->GetFName(fStyleFormat->fTextFont),
                       fStyleFormat->fTextSizeX, fStyleFormat->fTextSizeX);
    SetNewTitle(this, fStyleFormat->fTextSizeX);
    SetIdleFreq(0);        // for RISC_OS2 font icon bug
  }
  else
#endif
  {
    // aCmd == cBorders || aCmd == cNoteBorders
    TAdornCluster bordersCntl;
    TRuleType ruleType;
    CntlAdornment adornment;

    bordersCntl = TAdornCluster(FindSubView(kIdAdrn));
#ifdef TRACE
    Assert(bordersCntl, 21);
#endif

    // fStyleFormat->fDefined |= fChanges->fDefined & kHasAdornment;   // 09/02/93 [20621]
    // 12/11/90 try to get dialogue with accumulated changes after Adjust!!!
    fStyleFormat->ApplyOverride(fChanges, gNullCurrency, FALSE);
    if ((fStyleFormat->fDefined & kHasAdornment) != 0)
    {
      ruleType = fStyleFormat->fOwnRuleType;
      adornment = fStyleFormat->fOwnAdornment;
#ifdef FN
      if (aCmd == cNoteBorders && ruleType.fShort == 1)
        adornment = (adornment & ~adnLineTop) | adnShadow;
#endif
    }
    else
    {
      ruleType = fStyleFormat->fRuleType;
      adornment = fStyleFormat->fAdornment;
    }
    bordersCntl->SetRuleType(ruleType);

    bordersCntl->SetAdornment(adornment, FALSE, aCmd == cNoteBorders);
    WriteText(kIdName, GetIndString(kRuleDescrs, OldRuleType(ruleType))); // 21/10/91
  }
}


#if SIDEBAR == 1
// ------------------------------------------------------------------------
static CmdNumber DoSizeChange(TStyleFormat theStyle, int newSize)
{
  theStyle->fDefined |= (kSize | kEmphasis);  // 04/07/91 | KEmph
  theStyle->fTextSizeX = newSize;
  theStyle->fTextSizeY = newSize;
  return cSizeChange;
}
#endif

// ------------------------------------------------------------------------
TCommand _TSpacingDlg::ReadFromDialog(TView aDialogView, CmdNumber aCmd, IDType itsId)
{
  TAdornCluster bordersCntl;
  TRuleType     ruleType;
  CntlAdornment adornment;
  TCommand      theCommand = gNoChanges;
  DECLARE(aDialogView);
  DECLARE(itsId);

#ifdef TABLES
  if (aCmd == cSpacing)
  {
    TFixedPtText theText;
    int val;

    theText = TFixedPtText(FindSubView(kIdAbuv));
    val = FromFixed(theText->GetPoints());  // 10/07/90
    if (val != fAbovePts)
    {
      // value has been altered
      fChanges->SetSpaceBefore(val);
    }

    theText = TFixedPtText(FindSubView(kIdBelo));
    val = FromFixed(theText->GetPoints());  // 10/07/90
    if (val != fBelowPts)
    {
      // the value has changed
      fChanges->SetSpaceAfter(val);
    }

    theText = TFixedPtText(FindSubView(kIdLine));
    if (theText != NULL)          // 25/05/90 - picspacing has no line box
    {
      val = FromFixed(theText->GetPoints());  // 10/07/90
      if (val != fLeading)
        DoLineSpacing(fChanges, (TestCheckBox(kIdCust) ? val : 0));
    }
  }
  else
#endif
#if SIDEBAR == 1
  if (aCmd == cSizeDialog)
  {
    wr_os_regset r;
    char fontName[64];

    r.r[1] = (int)fontName;
    if (GetTryTextSizes(this, &r) != NULL)
      return TTextDocument(fDocument)->MakeStyleCommand(DoSizeChange, r.r[2]);
  }
  else
#endif
  {
    // aCmd == cBorders || aCmd == cNoteBorders
    bordersCntl = TAdornCluster(FindSubView(kIdAdrn));
    bordersCntl->GetRuleType(ruleType);
    bordersCntl->GetAdornment(adornment);
#ifdef FN
    if (aCmd == cNoteBorders && (adornment & adnShadow) != 0)
    {
      ruleType.fShort = 1;
      adornment = (adornment & ~adnShadow) | adnLineTop;
    }
#endif
    DoBordersChange(fChanges, /* fStyleFormat, */ ruleType, adornment);
//    if ((fStyleFormat->fDefined & kHasAdornment) != 0 ||
//                     (fChanges->fDefined & kHasAdornment) != 0)
//    {
//      fChanges->fDefined |= (kOwnAdornment | kHasAdornment);
//#ifdef FN
//      if (aCmd == cNoteBorders && (adornment & adnShadow) != 0)
//      {
//        ruleType.fShort = 1;
//        adornment = (adornment & ~adnShadow) | adnLineTop;
//      }
//#endif
//      fChanges->fOwnAdornment = adornment;
//      fChanges->fOwnRuleType = ruleType;
//      if (((adnShadow) & adornment) != 0)
//        fChanges->fOwnAdornment |= (adnLineTop | adnLineLeft | adnLineBottom | adnLineRight);
//    }
//    else
//    {
//      fChanges->fDefined |= kAdornment;
//      fChanges->fAdornment = adornment;
//      fChanges->fRuleType = ruleType;
//      if (((adnShadow) & adornment) != 0)
//        fChanges->fAdornment |= (adnLineTop | adnLineLeft | adnLineBottom | adnLineRight);
//    }
  }
  fChanges->fDefined &= ~kEmphasis;    // 07/08/95 [26043] apply borders, etc after deferred chg
  return new _TStyleAttrsCommand(TTextDocument(fDocument), aCmd, fChanges);
}


#ifdef TABLES
// ------------------------------------------------------------------------
// ---------------- TSaveStyleDlg
// ------------------------------------------------------------------------
_TSaveStyleDlg::_TSaveStyleDlg(TDocument itsDoc, TView itsSuperV, char* &itsParams) :
                                         (itsDoc,itsSuperV,itsParams)
{}


// ------------------------------------------------------------------------
void _TSaveStyleDlg::SetSelection(TSelection selection)
{
  fSelection = selection;
}


// ------------------------------------------------------------------------
void _TSaveStyleDlg::SetAttrs(TStyleFormat itsStyleFormat, TStyleFormat itsChanges, bool para)
{
  TLevelInfo levelInfo;
  int level;
  Str255 name;
  Fixed lm, rm;
  int direction;
  TControl statText;
  TControl editText;
  Str255 styleStr;

  statText = TControl(FindSubView(kIdDef0));
  editText = TControl(FindSubView(kIdName));
#ifdef TRACE
  Assert(statText && editText, 21);
#endif

  fSelection->GetLevelInfo(&levelInfo);
  strcpy255(name, GetIndString(kSelectStrings + int(levelInfo.fKind), abs(levelInfo.fPart) + 1));
  BuildName(&levelInfo, name);
  strcpy255(styleStr, GetString(kSaveStyleStrs)); // fn1
  Substitute(styleStr, name);
  statText->SetText(styleStr, kRedraw);

  FreeIfObject(fStyleFormat);
  level = fSelection->fPopup;
  while (levelInfo.fKind != kText && levelInfo.fPart != 1)
    fSelection->Get(++level, &levelInfo);
  
  itsStyleFormat = fSelection->GetStyle(level, TTextDocument(fDocument)->ActiveMainView(),
                                      lm, rm, direction, fName);  // 09/11/92
  {
    TStyleInfo info;

    info.fDocCurrency = 0;
    TTextDocument(fDocument)->fStyleSheet->FindStyleInfo(fName, info);

    if (TTextDocument(fDocument)->fBodyStyles[kCurrTextStyle] == info.fDocCurrency)
      fName[0] = 0;                // 31/01/91 leave blank if paragraph style name
  }
  // 22/04/94 [21700] GetResourceName replaces GetResInfo
  // 09/04/96 look up name in style sheet & check currency (as default style name chgd for Word)
  // if (strcmp(fName, (char *)GetResourceName(kParaId)) == 0)
  //    fName[0] = 0;                // 31/01/91 leave blank if paragraph style name
  editText->SetText(fName, TRUE);

  // 10/07/91 _TTextAttrsDlg::SetAttrs clones 1st param into fStyleFormat
  _TTextAttrsDlg::SetAttrs(itsStyleFormat, itsChanges, para);
  FreeIfObject(itsStyleFormat);
}


// ------------------------------------------------------------------------
int _TSaveStyleDlg::SetDescription()
{
  return DoSetDescription(fName);

  // Str255 desc;

  // strcpy(desc, fName);
  // fChanges->GetDescription(desc);
  // WriteText(kIdAttr, desc);
  // return FALSE;
}


// ------------------------------------------------------------------------
bool _TSaveStyleDlg::CanDismiss(IDType dismissing)
{
  bool  CanDismiss_r;
  char name[80];
  TStyleInfo info;

  CanDismiss_r = _TDialogView::CanDismiss(dismissing);
  if (CanDismiss_r)
  {
    bool sameName = GetInfo(name);             // 23/04/91 i/f changed
    int msg = 0;

    if (name[0] == 0)
    {
      msg = kNoNameAlert;
    }
    else if (!sameName)
    {
      TTextDocument(fDocument)->fStyleSheet->FindStyleInfo(name, info);
      if (info.fName[0] != 0)   // found in style sheet
        msg = kDupNameAlert;
    }
    if (msg != 0)
    {
      ErrorAlert(msg, 0);
      SelectEditText(kIdName);
      CanDismiss_r = FALSE;
    }
  }
  return (CanDismiss_r);
}


/* ------------------------------------------------------------------------
void _TSaveStyleDlg::SetEditTextItem(TControl editText, char* name)
{
  editText->SetText(name, TRUE);
}
*/

// ------------------------------------------------------------------------
void _TSaveStyleDlg::DoChoice(TView origView, int itsChoice)
{
   _TDialogView::DoChoice(origView, itsChoice);
}


// ------------------------------------------------------------------------
bool _TSaveStyleDlg::GetInfo(char* name)
{
  // 07/06/90 - checkbox removed and changeAll changed
  // 23/04/91 interface changed to remove level & return func result
  TControl editText;
  char nameBuff[80];

  editText = TControl(FindSubView(kIdName));

  editText->GetText(nameBuff);
  strcpy(name, nameBuff + strspn(nameBuff, " "));             // 25/04/91
  return (strcmp(fName, name) == 0);
}
#endif


// =========================================================================
// 06/03/94 moved here so can draw the rules rather than use a sprite
_TRulePicture::_TRulePicture(TDocument itsDoc, TView itsSuperV, char* &params) 
                          : (itsDoc, itsSuperV, params)
{
//   int  strOffset;

#ifndef ZERO_OBJ
   fFirstRowDepth = 0;
#endif

//   sscanf(params, " %d %d %n", &fLimit.h, &fLimit.v, &strOffset);
//   OffsetPtr(params, strOffset);

   fLimit.h = ReadInt(params);
   fLimit.v = ReadInt(params);
   fDefChoice = mSelPicture;
   fSector.h = -1;
   fSector.v = -1;
   fMaximum = fLimit.h * fLimit.v - 1;
}


// -------------------------------------------------------------------------
void _TRulePicture::SetCurrentRule(TRuleType theRule)
{
//   Point sectorPt;
   int ruleIdx = OldRuleType(theRule);

   SetValue(ruleIdx, kDontRedraw);
//  if (fVertical)
//    SetPt(fSector, ruleIdx / fLimit.v, ruleIdx % fLimit.v);
//  else
//    SetPt(fSector, ruleIdx % fLimit.h, ruleIdx / fLimit.h);
//                    // 14/06/90 - change flimit.v to flimit.h
   SetPt(fSector, ruleIdx % fLimit.h, ruleIdx / fLimit.h);

   RealHiliteState(TRUE);
}


// -------------------------------------------------------------------------
TRuleType _TRulePicture::GetCurrentRule()
{
//  TRuleType noRule;

//  fCommandGap = 0;
//  fStartCmd = 0;
//  return (fSector.h == -1 && fSector.v == -1 ?
//                               (noRule.fRule = kTotalRules, noRule) :
//                               NewRuleType(GetCmdNumber()));
  return TRuleType(NewRuleType(fCurrentValue));
}

// -------------------------------------------------------------------------
void _TRulePicture::GetSectorBox(VRect &rect, Point &sector)
{
  rect.left = 0;
  rect.top = fFirstRowDepth;
  rect.right = fSize.h / fLimit.h;
  rect.bottom = fFirstRowDepth + (fSize.v - fFirstRowDepth) / fLimit.v;

  OffsetRect(rect, rect.right * sector.h, rect.bottom * sector.v);
}

// -------------------------------------------------------------------------
void _TRulePicture::RealHiliteState(bool state)
{
   if (fSector.h >= 0 && fSector.v >= 0)
   {
     VRect  rect;

     GetSectorBox(rect, fSector);
     fHilite = state;      // so the DrawContents() method will know 
                         // if it has to invert the rect or not...
     if (Focus())
       UpdateVRect(rect);
  }
}

// -------------------------------------------------------------------------
void _TRulePicture::HiliteTheCell(VPoint &mousePoint)
{
  // this routine takes a view mouse point and calculates which cell
  // of a SelPic it is in. If it is in a different one than previous,
  // remove the previous one and plot the new one

  Point currPos;

//  if (fStartCmd != 0)
//    SetPt(currPos, -1, -1);
//  else
  currPos = fSector;

  if (IsShown() && (!IsDimmed()) &&
      mousePoint.h >= 0 && mousePoint.v >= fFirstRowDepth &&
      mousePoint.h < fSize.h && mousePoint.v < fSize.v)
  {
    currPos.h = (mousePoint.h * fLimit.h) / fSize.h;
                                         // (fSize.h + fHLInset.h);
    currPos.v = ((mousePoint.v - fFirstRowDepth) * fLimit.v) / fSize.v;
                                         // (fSize.v + fHLInset.v);
  }

  if ((currPos.h != fSector.h) || (currPos.v != fSector.v))
  {
    // the cursor has changed position so delete last hilite & do new
    SetValue(currPos.v * fLimit.h + currPos.h, kDontRedraw);
    HiliteState(FALSE, kRedraw);
    fSector = currPos;
    HiliteState(TRUE, kRedraw);
  }
}

// -------------------------------------------------------------------------
TCommand _TRulePicture::TrackMouse(TrackPhase thePhase, VPoint &anchor,
         VPoint &previous, VPoint &next, bool mouseDidMove, EventInfo &info)
{
  HiliteTheCell(next);

//  if (fStartCmd == 0)
    DoChoice(this, fDefChoice);  // 12/06/90 - send a DoChoice if it is a rulepicture
  return gNoChanges;
}

// -------------------------------------------------------------------------
void _TRulePicture::Draw(Rect &area)
{
  Point sector;
  Rect rect;
  Rect temp;
  wr_wimp_icon theIc;

  for (int i = 0; i <= fMaximum; i++)
  {
    SetPt(sector, i % fLimit.h, i / fLimit.h);
    GetSectorBox(rect, sector);
    if (SectRect(area, rect, temp))
    {
      thePort->LocalToWABox(rect, theIc.box);
      theIc.flags = wr_wimp_IBORDER | wr_wimp_ITEXT | wr_wimp_INDIRECT | wr_wimp_IFILLED |
                                (wr_wimp_IFORECOL * 7);  // 21/03/94 black border
      theIc.data.indirecttext.buffer = "";
      if (i == fCurrentValue && !IsDimmed())
      {
        theIc.flags += 0x30000000;
        theIc.data.indirecttext.validstring = "r2";
      }
      else
      {
        theIc.flags += 0x10000000;
        theIc.data.indirecttext.validstring = "r1";
      }
      if (!g3Dicons)
        theIc.data.indirecttext.validstring = (char *)-1; // 21/03/94 turn off raised border
      theIc.data.indirecttext.bufflen = 1;
      wr_wimpt_noerr(wr_wimp_ploticon(&theIc));
      InsetRect(rect, 40, 40);
      PenNormal();
      XFrameRect(rect, NewRuleType(i), adnLineTop | adnLineLeft, (kFix1 * 3) / 2);
    }
  }
}
