/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <string.h>

#include "os.h"
#include "wimp.h"
#include "akbd.h"
#include "event.h"

#include "UScaledWn.h"

#define Message_AllWindowsClosed 0x4d301

const int kHorizScroll = 200;

#define cWritableZoom 700
#define cZoomMin 701
#define cZoomMax 706
#define cMenuByKey 176
#define cZoomUp 177
#define cZoomDown 178
#define cNewDocTitle 180
#define cPgLeft 804
#define cPgRight 805
#define cPgUp 806
#define cPgDn 807
#define cHome 790
#define cEnd 791
#define cShowHideButtons 816

#define kPaletteAndLine 178
// #define kGreekPalDepth 512   /* 528 */

// for the zoom factor size
#define kMaxZoom 10

// msg num with text: Current page %d of %d
#define kShowPageText 210

#define gIDperc I_('p', 'e', 'r', 'c')
#define gIDicbr I_('i', 'c', 'b', 'r')
#define gIDzFit I_('z', 'F', 'i', 't')
#define gIDpgno I_('p', 'g', 'n', 'o')
#define gIDpgtx I_('p', 'g', 't', 'x')
#define gIDprct I_('p', 'r', 'c', 't')

#ifdef TABLES
#define gIDxsca I_('x', 's', 'c', 'a')
#endif

#ifdef MATHS
#define gIDsymp I_('s', 'y', 'm', 'p')
#define gIDsscr I_('s', 's', 'c', 'r')
#define gIDmbut I_('m', 'b', 'u', 't')
#endif

#define GetWindowVBorder() 0
// ------------------------------------------------------------------------
_TScaledWindow::_TScaledWindow(TDocument itsDocument,
                               TView itsSuperView, char* &params)
                             : (itsDocument, itsSuperView, params)
{
#ifndef ZERO_OBJ
  fHScale = NULL;
#ifdef TABLES
  fVScale = NULL;
  fActionBox = NULL;
#endif
  fMainView = NULL;
  fIconBarPane = NULL;
#ifdef MATHS
  fGreekPalView = NULL;
#endif
#if defined TABLES || defined DRAWSAVE
  fBoxZoom = 0;
#endif
  fZoomToFit = FALSE;
#endif
  fZoomNum = 1;
  fZoomDenom = 1;
}


#ifdef NETWP
// -------------------------------------------------------------------------
static void ResetIconBounds(wr_wimp_icreate *ic, wr_wimp_box *newBox)
{
  ic->i.box = *newBox;
}

// ------------------------------------------------------------------------
static void MoveControl(TScroller scrl, int id, int inset, int vPos)
{
  TControl theControl = TControl(scrl->FindSubView(id));

  if (theControl)
  {
    wr_wimp_box newBox;
    VRect frame;
    int newRight = SafeRight() - SafeLeft() - inset;

    if (vPos != -1)
      theControl->Locate(newRight - theControl->fSize.h, vPos, TRUE);
    else
      theControl->Resize(newRight - theControl->fLocation.h, theControl->fSize.v, FALSE);
    theControl->GetFrame(frame);
    QDRectToBox(frame, newBox, 0);
    theControl->ChangeDeletedIcon(theControl->fIconNum, int(&newBox), (DoToIcon)ResetIconBounds);
    // Could use Wimp_ResizeIcon - but does not save much code
  }
}

// ------------------------------------------------------------------------
static void ResizeIconBar(TWindow iconBarPane)
{
  if (!WindowBorder())
  {
    // Scroll the buttons into safe area, and adjust right hand ones
    TScroller scrl;

    if (iconBarPane && (scrl = TScroller(iconBarPane->FindSubView(I_(0, 0, 'i', 'c')))) != NULL)
    {
      wr_wimp_openstr *iconOpen = (wr_wimp_openstr *)&iconBarPane->fWindowRecord;
      int temp1 = OStoQD(iconOpen->box.y1 - iconOpen->box.y0 - iconOpen->y); // bit below origin
      Point translation;
      int xtra = 0;
      Rect r;

      SetRect(r, -SafeLeft(), -SafeTop(), ScreenWidth() - SafeLeft(), OStoQD(IsTV() ? 168 : 144));
                            // 05/09/96 [27061] new template depth
      scrl->SetScrollLimits(r);

      scrl->ScrollTo(r.left, r.top);
      scrl->GetTranslations(translation);
      iconBarPane->Resize(iconBarPane->fSize.h, temp1 - translation.v, FALSE);

      if (SafeRight() - SafeLeft() < 4080)
      {
        // need to move the close button down to row 2

        // and shrink the right edge of the status line
        xtra = 432;
      }
      MoveControl(scrl, I_('c', 'l', 'o', 's'), 56, xtra ? (IsTV() ? 476 : 320) : 64);
      // MoveControl(scrl, I_('p', 'g', 'u', 'p'), 40 + xtra, 336);
      // MoveControl(scrl, I_('p', 'g', 'd', 'n'), 216 + xtra, 336);
      MoveControl(scrl, I_('d', 'r', 'a', 'g'), xtra ? (IsTV() ? 476 : 320) : 56, -1);
      if (IsTV())
      {
        MoveControl(scrl, I_('u', 'n', 'd', 'o'), 0, -5000);
        MoveControl(scrl, I_('p', 'r', 'n', 't'), 0, -5000);
        MoveControl(scrl, I_('u', 'n', 'd', 'l'), 0, -5000);
      }
    }
  }
}
#endif

// ------------------------------------------------------------------------
void _TScaledWindow::Open()
// Set up the rest of the fields now that all views have been added
{
  fIconBarPane = TWindow(FindSubView(gIDicbr));
#ifdef TABLES
  fVScale = TRulerScale(FindSubView(gIDvsca));
#endif
  fHScale = TRulerScale(FindSubView(gIDrule));

  _TWindow::Open();

#ifdef TABLES
  fActionBox = FindSubView(gIDxsca);   // 22/06/90 moved after Open, because
       // its size is used by OpenWindow and has not been set correctly yet
#endif

  if (fScroller != NULL)
  {
    TScaleScroller(fScroller)->fHScroller = fHScale;
#ifdef TABLES
    TScaleScroller(fScroller)->fVScroller = fVScale;
#endif
  }
#ifdef NETWP
  ResizeIconBar(fIconBarPane);
#endif
#if SIDEBAR == 1
  // add Font list menu for menus on the button bar
  fIconBarPane->fMenuData =
         new _TMenu(cmFontMenu, this, NULL, fIconBarPane->fWindowRecord.GetHandle());
#endif
}

// ------------------------------------------------------------------------
void _TScaledWindow::Close()
{
#ifdef NETWP
  int msg[6];
#endif

  _TWindow::Close();

#ifdef NETWP
  // 29/08/96 [27054] Send message on window close
  msg[5] = 0;  // flags (all zero)
  Broadcast(Message_AllWindowsClosed, (wr_wimp_msgstr *)msg, 24);
#endif
}

// ------------------------------------------------------------------------
typedef enum TPaneID { hiddenBar, mainWindow, vertScale, horzScale, symbPane, iconBar,
                        mathsBtns, windOnTop } TPaneID;

static void OpenPane(TPaneID paneID, wr_wimp_w hdl, wr_wimp_openstr *open,
                   TWindow *windows, int iconBarDepth, Point &actionBoxSize)
{
  // NB. iconBarDepth is combined button bar and symbol (greek palette) pane size in Maths!
  wr_wimp_openstr o;
  TWindow thePane = windows[paneID];
  int vLocation = 0;
  int hLocation = 0;
  bool sety0 = FALSE;
  VRect aVRect;

  if (thePane->fScroller != NULL)
    aVRect = thePane->fScroller->fScrollLimit;

  o.w = thePane->fWindowRecord.GetHandle();   // hdl;
  o.box = open->box;
  o.x = 0;                  /* don't scroll sideways    */
  o.y = 0;                  /* don't scroll vertically! */
  o.behind = open->behind;

  switch (paneID)
  {
#ifdef MATHS
    case symbPane:
    {
      TView lastSv = TView(thePane->fScroller->fSubViews->Last());

      aVRect.right = Max(lastSv->fSize.h + lastSv->fLocation.h, OStoQD(o.box.x1 - o.box.x0));
      thePane->fScroller->SetScrollLimits(aVRect);
      thePane->fWindowRecord.GetWindowState();
      o.x = ((wr_wimp_openstr *)&thePane->fWindowRecord)->x;  // preserve x-scroll posn
      o.box.y1 -= QDtoOS(iconBarDepth - thePane->fSize.v - GetHLineThickness());
                                // 24/06/93 [] more dynamic than: QDtoOS(kIconRowDepth + 4);
      sety0 = TRUE;             // set the bottom to the top minus pane size
      break;
    }
#endif

    case hiddenBar:
      o.behind = -3;
    case iconBar:
#if SIDEBAR == 1
      if ((thePane->fSizeDeterminer >> 4) == sizeVariable)
        o.box.x1 = Min(o.box.x1, o.box.x0 + thePane->fWindowRecord.GetPortBox()->x1 -
                        thePane->fWindowRecord.GetPortBox()->x0);
      else
#endif
      {
        // 26/02/96 [] Allow sideways scrolling button pane for all products if Resources set up
        Point translation;

        thePane->fWindowRecord.GetTranslation(translation);
        o.x = QDtoOS(translation.h);
        o.y = -QDtoOS(translation.v);
        sety0 = TRUE;             // set the bottom to the top minus pane size
      }
      break;

#ifdef MATHS
    case mathsBtns:
      hLocation = QDtoOS(GetVLineThickness());
      o.box.x1 = QDtoOS(thePane->fSize.h);
      if (o.box.x0 > 0)                  // stay on screen if possible like !Draw
        o.box.x0 = Max(hLocation, o.box.x0 - o.box.x1 - hLocation);
      o.box.x1 += o.box.x0;
      hLocation = OStoQD(o.box.x0 - open->box.x0);
      
      vLocation = TScaledWindow(windows[mainWindow])->fScroller->fLocation.v;
      o.box.y1 -= QDtoOS(vLocation);
      o.box.y0 =  o.box.y1 - QDtoOS(thePane->fSize.v);
      break;
#endif

    case vertScale:
      aVRect.bottom = 64 * 1024;  // something big
      thePane->fScroller->SetScrollLimits(aVRect);
      vLocation = iconBarDepth + actionBoxSize.v;
      o.box.y1 -= QDtoOS(vLocation);
      if (o.box.y0 < 0)
        o.box.y0 = 0;        // 13/03/96 WIMP tries to force on-screen on first open
      o.box.x1 = o.box.x0 + QDtoOS(thePane->fSize.h);
      o.y = open->y;                 /* match scroll up and down */
      break;

    case horzScale:
      aVRect.right = 64 * 1024;  // something big
      thePane->fScroller->SetScrollLimits(aVRect);
      vLocation = iconBarDepth;
      o.box.y1 -= QDtoOS(vLocation);
#ifdef TABLES
      // hLocation = actionBoxSize.h == 0 ? 0 : actionBoxSize.h /* + GetVLineThickness() */;
      hLocation = actionBoxSize.h;      // ZZ
#else
      hLocation =
#if SIDEBAR == 1
         (windows[iconBar]->fSizeDeterminer >> 4) == sizeVariable ?
            windows[iconBar]->fSize.h + GetVLineThickness() :
#endif
            0;
#endif
      o.box.x0 += QDtoOS(hLocation);
      o.x = open->x;             // match scroll sideways
      sety0 = TRUE;              // set the bottom to the top minus pane size
      break;
  }

  if (sety0)
    o.box.y0 = Max(o.box.y1 - QDtoOS(thePane->fSize.v), o.box.y0);

  SetVPt(thePane->fLocation, hLocation, vLocation);   // rather than Locate(h, v, kDontRedraw)
  thePane->fWindowRecord.SetOpenStr(&o);
  if (o.w != -1)
  {
    thePane->OpenWindow();   // do a dummy run, then open iconbar pane first
    if (o.behind == -3)
      thePane->fWindowRecord.SetBehind(-3);
  }
}

// ------------------------------------------------------------------------
//                       open the main window                            //
// ------------------------------------------------------------------------
/*              Code for handling the 'pane window'

 * The 'main' window contains the main scrolling work area
 * The 'pane' window sits on top of it, moving wherever the main window goes
 *
 * The code below should should the basic algorithm.
 * Here is a 'plain English' description of why it does what it does:
 *
 *    We want to open the pane window on top of the main window, using the
 *    coordinates of where the main ends up (not necessarily the same as
 *    where it is asked to open, because of bounding constraints).
 *
 *    Thus we would like to open the main window first, then read off its
 *    coordinates and bhandle (using wr_wimp_getwindowstate) and open the pane
 *    with suitable coordinate modifications.
 *
 *    Unfortunately this results in the pane window typically being redrawn
 *    continuously as the window is dragged round the screen, since the main
 *    is first opened above the pane, and then the pane is opened above the
 *    main.
 *
 *    The first check, then, is to open the main window behind the pane, if
 *    it turns out that it is to be opened just above it.
 *
 *    The next problem is that since the two windows are 'sliding' over one
 *    another as they move, it is likely that a small strip of the main
 *    window next to the pane window will have to be redrawn quite often, as
 *    it is slightly obscured by the pane window before reappearing as the
 *    pane window's position is updated.
 *
 *    The cure for this is to open the pane window first if the main window
 *    is moving in the direction of the pane.  This eliminates unnecessary
 *    redraws of the main window, which can be extremely important if the
 *    contents of the main window are complicated.  Note that since the
 *    final coordinates of the main window are not known for sure until
 *    after it has been opened itself, it is still necessary to open the
 *    pane window after the main window has been opened (but this does not
 *    usually cause any overhead at all).
 *
 *    Finally, an extra check has to be made for the case where the main
 *    window is 'sent to the back', since the bhandle setting here is equal
 *    to -2, rather than to the handle of the rearmost window on the
 *    screen.  Thus, when the pane window is opened after the main window,
 *    it must not use the bhandle of -2, since this would cause it to be
 *    opened behind the main window!  The solution is to read back the
 *    actual bhandle of the main window by calling wr_wimp_getwindowstate.
 */

// ------------------------------------------------------------------------
static int WindowAbove(int *handles, TPaneID id)
{
   for (id++; id < windOnTop; id++)
      if (handles[id] != -1)
      {
#ifdef TRACE
         wr_wimp_wstate panestate;

         wr_wimpt_noerr(wr_wimp_get_wind_state(handles[id], &panestate));  // get pane state
         Assert((panestate.flags & wr_wimp_WOPEN) != 0, 298);
#endif
         return handles[id];
      }
   return handles[windOnTop];
}

// ------------------------------------------------------------------------
static int FindStackTop(int *handles, int bhind)
/* work up wimp's window stack until a window which is not ours is found */
{
   wr_wimp_wstate panestate;

   if (bhind != -1)
      for (TPaneID i = mathsBtns; i >= hiddenBar; i--)
      {
         if (handles[i] == bhind)            // its one of our panes
         {
            wr_wimpt_noerr(wr_wimp_get_wind_state(bhind, &panestate));  // get pane state
            if (panestate.o.behind == bhind)
               return -1;    // stop looping?
            return FindStackTop(handles, panestate.o.behind);
         }
      }
   return bhind;
}

// ------------------------------------------------------------------------
int _TScaledWindow::GetMainViewTop()
{
   int iconBarDepth = (fIconBarPane && fIconBarPane->fWindowRecord.GetBehind() != -3 ?
                                                               fIconBarPane->fSize.v : 0);

#ifdef MATHS
   return iconBarDepth + (fGreekPalView ? fGreekPalView->fSize.v + GetHLineThickness() * 2 : 0);
#else
#if SIDEBAR == 1
   if ((fIconBarPane->fSizeDeterminer >> 4) == sizeVariable)  // fSizeDeterminerV
     return 0;
#endif
   return iconBarDepth;  // 01/04/93 [20822] template size for StartWrite
#endif
}

// ------------------------------------------------------------------------
void _TScaledWindow::OpenWindow()
{
   TPaneID       i;
   wr_wimp_openstr *open = (wr_wimp_openstr *)&fWindowRecord;
   Point         actionBoxSize;
   int           iconV;
   int           handles[windOnTop + 1];
   TWindow       windows[windOnTop];
   wr_wimp_wstate   mainstate;
   char         *tt;
   int           j;

   // initialise all to NULL, except the first which is set to this
   ((TWindow *)memset(windows, 0, sizeof(windows)))[mainWindow] = this;
#ifdef TABLES
   windows[vertScale] = TWindow(fVScale->fSuperView);
#endif
   windows[horzScale] = TWindow(fHScale->fSuperView);
#ifdef NETWP
   if (fFrameless && !WindowBorder())
   {
     Resize(ScreenWidth(), ScreenHeight(), kDontRedraw);
#ifdef TABLES
     windows[vertScale]->
        Resize(fVScale->fRulerRect.right + SafeLeft(), windows[vertScale]->fSize.v, kDontRedraw);
#endif
   }
#endif
#ifdef MATHS
   windows[symbPane] = fGreekPalView;
   {
      TWindow mathsBtnsPane = TWindow(FindSubView(gIDmbut));

      if (mathsBtnsPane->IsShown())
         windows[mathsBtns] = mathsBtnsPane;
   }
#endif
   windows[fIconBarPane->fWindowRecord.GetBehind() == -3 ? hiddenBar : iconBar] = fIconBarPane;

   // initialise all to -1, except first which contains main window handle
   memset(handles, -1, sizeof(handles));

   for (i = hiddenBar; i < windOnTop; i++)
      if (windows[i])
         handles[i] = windows[i]->fWindowRecord.GetHandle();

   wr_wimpt_noerr(wr_wimp_get_wind_state(handles[mainWindow], &mainstate)); // get original state

#ifdef TABLES
   // 21/06/90 by invalidating the action box, the wimp will not scroll it.
   if (fActionBox != NULL)
   {
      actionBoxSize = fActionBox->fSize;  // else the action box is now sized
      _TScaledWindow::AboutToScroll(OStoQD(mainstate.o.x - open->x),
                                                          OStoQD(open->y - mainstate.o.y));
   }
   else
#endif
      actionBoxSize.h = actionBoxSize.v = 0;    // this is the first open ...

   iconV = GetMainViewTop();
   // NB. iconV is combined button bar and symbol (greek palette) pane size in Maths!

   for (int pass = 1; pass >= 0; pass--)
   {
     if (pass != 0 && open->behind == -2)       // sent to back
     {
        _TWindow::OpenWindow();
        handles[windOnTop] = open->behind;  /* open panes between window and one above */
     }
     else
     {
       int diffX = open->box.x0 - mainstate.o.box.x0;

       if (pass != 0)
       {
         tt = NULL;
         handles[windOnTop] = FindStackTop(handles, open->behind);  // find window above stack
         if (handles[windOnTop] == -1)    // 13/10/93 show icbar under menu/wdw
         {
           if (diffX < 0)     // going left
             tt = "\x006\x002";
           else
             tt = "";

           if (open->box.y1 > mainstate.o.box.y1)   // up
           {
             if (diffX < 0)                        // going up and left
               tt = "\x006\x005\x004\x003\x002";
             else
               tt = "\x005\x004\x003";            // going up and right
           }
         }
       }
       else
       {
         tt = "\x006\x005\x004\x003\x002";          // not moved or going up left (or not top)
         if (handles[windOnTop] == -1)        // 13/10/93
         {
           if (open->box.y1 < mainstate.o.box.y1)        // down
           {
              if (diffX < 0)                             // going down left
                 tt = "\x006\x002\x003\x004\x005";
              else
                 tt = "\x002\x003\x004\x005\x006";       // going down right
           }
           else if (diffX > 0)
              tt = "\x005\x004\x003\x002\x006";          // going up right
         }
       }
       if (tt != NULL)
         for (j = 0; ; j++)
         {
            i = tt[j];
            if (windows[i])     // 09/07/96 open pane 0 (hiddenBar) too if necessary
            {
               open->behind = WindowAbove(handles, i);
               OpenPane(i, handles[i], open, windows, iconV, actionBoxSize);
            }
            if (i == 0)
              break;
         }

       fWindowRecord.SetBehind(WindowAbove(handles, mainWindow));
       _TWindow::OpenWindow();
     }
   }
#ifdef NEVER
   if (open->behind == -2)   
   {
      _TWindow::OpenWindow();
      handles[windOnTop] = open->behind;  /* open panes between window and one above */
   }
   else
   {
      int diffX = open->box.x0 - mainstate.o.box.x0;

      handles[windOnTop] = FindStackTop(handles, open->behind);  // find window above stack

      if (handles[windOnTop] == -1)    // 13/10/93 show icbar under menu/wdw
      {
        if (diffX < 0)     // going left
           tt = "\x006\x002";
        else
           tt = "";

        if (open->box.y1 > mainstate.o.box.y1)   // up
        {
           if (diffX < 0)                        // going up and left
              tt = "\x006\x005\x004\x003\x002";
           else
              tt = "\x005\x004\x003";            // going up and right
        }
        for (j = 0; ; j++)
        {
           i = tt[j];
           if (windows[i])      // 09/07/96 open pane 0 (hiddenBar) too if necessary
           {
              open->behind = WindowAbove(handles, i);
              OpenPane(i, handles[i], open, windows, iconV, actionBoxSize);
           }
           if (i == 0)
             break;
        }
      }
      fWindowRecord.SetBehind(WindowAbove(handles, mainWindow));
      _TWindow::OpenWindow();
   }

   tt = "\x006\x005\x004\x003\x002";          // not moved or going up left (or not top)
   if (handles[windOnTop] == -1)        // 13/10/93
   {
     if (open->box.y1 < mainstate.o.box.y1)        // down
     {
        if (open->box.x0 < mainstate.o.box.x0)     // going down left
           tt = "\x006\x002\x003\x004\x005";
        else
           tt = "\x002\x003\x004\x005\x006";       // going down right
     }
     else if (open->box.x0 > mainstate.o.box.x0)
        tt = "\x005\x004\x003\x002\x006";          // going up right
   }

   for (j = 0; ; j++)
   {
      i = tt[j];
      if (windows[i])
      {
         open->behind = WindowAbove(handles, i);
         OpenPane(i, handles[i], open, windows, iconV, actionBoxSize);
      }
      if (i == 0)
        break;
   }

   fWindowRecord.SetBehind(WindowAbove(handles, mainWindow));
   _TWindow::OpenWindow();
#endif

#ifdef TABLES
   if (actionBoxSize.h != 0)
   {
      fActionBox->Locate(0, iconV /* + GetHLineThickness() */, kDontRedraw);
   }
#endif
   if (fMainView != NULL)
   {
      // 12/06/95 do not bother if window size and scroll offsets unchanged
      if (mainstate.o.box.x1 - mainstate.o.box.x0 != open->box.x1 - open->box.x0 ||
          mainstate.o.box.y1 - mainstate.o.box.y0 != open->box.y1 - open->box.y0 ||
          mainstate.o.x != open->x || mainstate.o.y != open->y)
        fMainView->DoPagination(); // 27/07/90
#ifdef NEVER
      // 04/09/96 [27066] removed
      else
        wr_wimp_sendmessage(wr_wimp_ENULL, (wr_wimp_msgstr *)open, 0);
      // Attempt to stop other apps which rely on Nulls (eg !Alarm) freezing while
      // window is stationary, but the mouse held down (when Wimp just keeps sending
      // ignored open messages). Unfortunately getting a Null event between setting
      // the caret in a new window, and getting the gained caret message causes our
      // DoIdle to reset the caret back to the original window!
#endif
      SetZoomPercentage();  // 10/03/93 [20806] set up nnn% in icon bar after 3d change
   }
}

// ------------------------------------------------------------------------
void _TScaledWindow::GetSettings(bool &greekShown, bool &rulerShown,
                                  bool &scalesShown, bool &buttonsShown)
{
#ifdef MATHS
   TWindow mathsBtnsPane = TWindow(FindSubView(gIDmbut));

   greekShown = FALSE;
   if (mathsBtnsPane != NULL && mathsBtnsPane->IsShown())
      greekShown = 3;
   if (fGreekPalView != NULL)
      greekShown ^= 2;
#else
   greekShown = FALSE;
#endif

   rulerShown = (TWindow(fHScale->fSuperView)->fWindowRecord.GetHandle() !=
                  kNoWindow && fHScale->IsRulerShown());
   scalesShown =
#ifdef TABLES
      (TWindow(fVScale->fSuperView)->fWindowRecord.GetHandle() != kNoWindow);
#else
      FALSE;
#endif
   buttonsShown = (fIconBarPane != NULL && fIconBarPane->fWindowRecord.GetBehind() != -3);
}


// ------------------------------------------------------------------------
void _TScaledWindow::OrganiseInterior(bool scalesShown, bool rulerShown,
                                           bool greekPalShown, bool buttonsShown)
{
#ifdef TABLES
   TView        vScale;
#endif
   TView        hScale;
   int          rulerSize;
   GrafPtr      rulerGraf;
#ifdef TABLES
   bool         scaleClosed;
   int          mainViewLeft;
#else
#define mainViewLeft 0
#endif
   int          mainViewTop;
#ifdef MATHS
   TWindow mathsBtns = TWindow(FindSubView(gIDmbut));
#endif

#ifdef TABLES
   vScale = fVScale->fSuperView;
#endif
   hScale = fHScale->fSuperView;

#ifdef MATHS
   if (greekPalShown == 1 || greekPalShown == 2)    // 28/06/93 split into 2 bits 
   {
      if (fGreekPalView == NULL)
      {
         fGreekPalView = TWindow(FindSubView(gIDsymp));
         if (fGreekPalView != NULL)
         {
            PlaceBehindPane(fGreekPalView);
            fGreekPalView->Open();
         }
#ifdef NEVER
         // 07/03/96 ?? should test for fGreekPalView == NULL & not use built-in literals!
         fGreekPalView->Resize(fGreekPalView->fSize.h, kGreekPalDepth - 16, kRedraw);
#endif
      }
   }
   else
   {
      if (fGreekPalView != NULL)
      {
         TScroller(fGreekPalView->FindSubView(gIDsscr))->ScrollTo(0, 0);
         fGreekPalView->Close();
      }
      fGreekPalView = NULL;
   }

   if (greekPalShown == 1 || greekPalShown == 3)
   {
      if (mathsBtns && mathsBtns->fWindowRecord.GetHandle() == -1)
         mathsBtns->Open();
      mathsBtns->Show(TRUE, FALSE);
   }
   else
      mathsBtns->Show(FALSE, FALSE);
#endif
   if (fIconBarPane != NULL)
   {
     int buttonsClosed = (fIconBarPane->fWindowRecord.GetBehind() == -3);

     if (buttonsClosed == buttonsShown)
     {
       if (buttonsClosed)       // then open it
       {
         fIconBarPane->fWindowRecord.SetBehind(-1);
         //ResizeIconBar(fIconBarPane);
       }
       else
       {
         fIconBarPane->fWindowRecord.SetBehind(-3);
       }
     }
   }
   mainViewTop = GetMainViewTop();

   // change the ruler next (along with horizontal scales)
   rulerSize = fHScale->GetRulerPaneDepth(rulerShown, scalesShown);

   rulerGraf = hScale->GetGrafPort();
   if (rulerSize == 0)
   {
      // the ruler is not there so get rid of window resource
      if (rulerGraf != NULL)
         hScale->Close();
   }
   else
   {
      // either the ruler or scales is shown - Resize the window to the
      // appropriate size and then show it

      if (rulerGraf == NULL)
         hScale->Open();
      hScale->Resize(/* hScale-> */ fSize.h, rulerSize, rulerGraf != NULL); // 28/02/96 [] ZZ
      // ZZ     rulerSize += GetHLineThickness();    // 30/06/93
   }
   mainViewTop += rulerSize;

#ifdef TABLES
   mainViewLeft = (scalesShown ? vScale->fSize.h + GetWindowVBorder() : 0);
                           // 31/08/94 [22021] +GLT so main view in sync with ruler

   // change the vertical scales next
   scaleClosed = (vScale->GetGrafPort() == NULL);
   if (scaleClosed == scalesShown)
   {
      if (scaleClosed)
      {
         vScale->Open();
         SetIdleFreq(0);                // 4/6/90 turn on idle routine
      }
      else
      {
         vScale->Close();
         SetIdleFreq(kMaxIdleTime);       // 4/6/90 turn off cursor tracker
         fVScale->fMousePosition = MAXLONGINT;  // faster than fVScale->DrawMousePosition
         fHScale->DrawMousePosition(MAXLONGINT);  // and undraw the mouse pos line
      }
   }

   // add an action box (or clear it out if there is not one)
   fActionBox->Resize(mainViewLeft, rulerSize, kRedraw);
#endif

   if (fScroller != NULL)
   {
      // 3/5/90 to get scroller resized to fit in what is visible
#if SIDEBAR == 1
      if ((fIconBarPane->fSizeDeterminer >> 4) == sizeVariable)   // fSizeDeterminerV
        fScroller->Locate(fIconBarPane->fSize.h + GetVLineThickness(), mainViewTop, kRedraw);
      else
#endif
        fScroller->Locate(mainViewLeft, mainViewTop, kRedraw);
      fScroller->AdjustSize();
#ifdef NETWP
//      ResetScrollUnits(fScroller, fIconBarPane);
#endif
   }
#ifdef NETWP
   TTextDocument(fDocument)->ScrollSelectionIntoView();
#endif
}


// ------------------------------------------------------------------------
void _TScaledWindow::ConnectMainView(TPagesView theMainView, TScaledWindowTemplatePtr pars)
{
  fZoomToFit = pars->zoomFit;
  fZoomNum = pars->zoomNum;
  fZoomDenom = pars->zoomDenom;

  SetPageView(theMainView);

  fHScale->SetScale(pars->hScale, pars->hCustomPoints, kDontRedraw);
  fHScale->fOrigin = pars->hOrigin;
#ifdef TABLES
  fVScale->SetScale(pars->vScale, pars->vCustomPoints, kDontRedraw);
  fVScale->fOrigin = pars->vOrigin;
#endif
  if (fZoomToFit)
    fWindowRecord.SetWorkAreaToScreen();   // 04/06/93 [20912]
#ifdef NEVER
  if (fScroller != NULL)
    TScaleScroller(fScroller)->CentreSubview(theMainView, kDontRedraw);
#endif
  DoZoom();

  OrganiseInterior(
#ifdef NETWP
          WindowBorder() ? pars->scalesShown : FALSE,
#else
#ifdef TABLES
          pars->scalesShown,
#else
          FALSE,
#endif
#endif
          WindowBorder() ? pars->rulerShown : FALSE,
          pars->greekPalShown,
          TRUE);    // 04/07/96 always show toolbar initially: HasPointer() != 0);
  // following scroll moved after OrgInt so scrollers location set up for ScrToInt
  if (fScroller != NULL)
  {
    if (pars->vTranslation < 0)
    {
      if (theMainView->fPrintHandler != NULL)
        theMainView->fPrintHandler->ScrollToInterior(fScroller, 1);
    }
    else
      fScroller->ScrollTo(pars->hTranslation, pars->vTranslation);
  }
#ifndef TABLES
  {
    // 09/10/92 get tabwell state so DoSetUpMenus resets it for StartWrite
    TView tabWell = FindSubView(gIDwell);

    if (tabWell != NULL)
      TControl(tabWell)->fDimmed = pars->rulerShown;
  }
#endif
  OpenWindow();
}


// ------------------------------------------------------------------------
void _TScaledWindow::WriteRes(TScaledWindowTemplatePtr pars)
{
  int temp;

  if (fScroller == NULL)
    pars->hTranslation = pars->vTranslation = 0;
  else
  {
    Point translation;

    fScroller->GetTranslations(translation);
    pars->hTranslation = translation.h;
    pars->vTranslation = translation.v;
//    pars->hTranslation = fScroller->GetTranslation(h);
//    pars->vTranslation = fScroller->GetTranslation(v);
  }
  GetSettings(pars->greekPalShown, pars->rulerShown, pars->scalesShown, temp);
  pars->zoomNum = fZoomNum;
  pars->zoomDenom = fZoomDenom;
  pars->zoomFit = fZoomToFit;

  pars->hScale = fHScale->GetScale();
  pars->hCustomPoints = fHScale->GetCustomPoints();
  pars->hOrigin = fHScale->fOrigin;
#ifdef TABLES
  pars->vScale = fVScale->GetScale();
  pars->vCustomPoints = fVScale->GetCustomPoints();
  pars->vOrigin = fVScale->fOrigin;
#else
  pars->vScale = FALSE;
  pars->vCustomPoints = fHScale->GetCustomPoints();
  pars->vOrigin = 0;
#endif  
}

// ------------------------------------------------------------------------
void _TScaledWindow::AboutToScroll(VCoordinate deltaH, VCoordinate deltaV)
{
  fHasScrolled = TRUE;           // 12/05/91 less code than inherited call
#ifdef TABLES
  if (fActionBox != NULL)
  {
    Rect frame;

    // 18/01/91 by invalidating the sprite, the wimp will not scroll it
    fActionBox->ForceRedraw();

    // 01/08/95 [26040] invalidate where action box contents end up in main window
    // as they were being left after a 'diagonal scroll' (by adjust drag on scroll bars)
    // 12/03/96 also invalidate top left corner of main view when autoscrolling at bottom right
    fActionBox->GetFrame(frame);       // get into my coords
    OffsetRect(frame, deltaH, deltaV); // offset to where the contents will be scrolled
    InvalidRect(frame);
  }
#endif
}

// ------------------------------------------------------------------------
void _TScaledWindow::SetPageView(TPagesView theMainView)
{
  TView mainParent;
  TPrintHandler aPrintHandler;

  fMainView = theMainView;
#ifndef NEWRULE
  fHScale->fNextHandler = theMainView;
#ifdef TABLES
  fVScale->fNextHandler = theMainView;
#endif
#endif

  FailNIL(mainParent = FindSubView(gIDscro));    // FailNIL not ideal - but should never happen
  theMainView->SetMagnification(FixDiv(fZoomNum, fZoomDenom));
  aPrintHandler = theMainView->fPrintHandler;
  if (aPrintHandler != NULL)
    TPagesPrintHandler(aPrintHandler)->HaveScales(fHScale
#ifdef TABLES
                   , fVScale
#endif
                   );
  mainParent->AddSubView(theMainView);
}


// ------------------------------------------------------------------------
void _TScaledWindow::Redraw(EventInfo &info)
{
  _TWindow::Redraw(info);
}

// ------------------------------------------------------------------------
void _TScaledWindow::DrawFeedback(Point &mousePt)
{
#ifdef TABLES
  if (fVScale->GetGrafPort() != NULL)  // 04/04/96 no longer reliable:-  if (fIdleFreq == 0)
  {
    TWindow ptrWind = (gWindowWithPointer == NULL ? NULL : gWindowWithPointer->GetWindow());
    // 23/04/91 turn off tracking unless cursor over this window

    fHScale->DrawMousePosition(ptrWind == this ? mousePt.h : MAXLONGINT);
    fVScale->DrawMousePosition(ptrWind == this ? mousePt.v : MAXLONGINT);
  }
#endif
}

// ------------------------------------------------------------------------
int _TScaledWindow::GetPointerShape(Point &localPoint)
{
  return -1; // 22/03/96 use dfault pointer if none of my subviews has claimed
}


// ------------------------------------------------------------------------
bool _TScaledWindow::DoIdle(IdlePhase phase)
{
#ifdef TABLES
  if (phase != idleEnd)
  {
    wr_wimp_mousestr mouseInfo;
    Point qdMouse;

    GetMouseInfo(&mouseInfo);
    OStoQDPt(mouseInfo.x, mouseInfo.y, qdMouse, ScreenHeight());
    DrawFeedback(qdMouse);
  }
#endif
  return _TWindow::DoIdle(phase);
}


// ------------------------------------------------------------------------
void _TScaledWindow::WriteToDialog(TView aDialogView, CmdNumber aCmd)
{
   TNumberText hNumberText;

#ifdef TABLES
   if (aCmd == cScaleUnits || aCmd == cHScaleUnits || aCmd == cVScaleUnits)
   {
      TRulerScale scale = (aCmd == cVScaleUnits ? fVScale : fHScale);

      aDialogView->WriteCheckBox(scale->GetScale() + I_(0, 0, 'B', '0'), TRUE);
      aDialogView->WriteValueRedraw(I_('C', 'u', 's', 't'), scale->GetCustomPoints());
   }
   else
#endif
   if (aCmd == cGotoPage)
   {
#define kHalfVGap 90
      int      currPage;
      int      endPage;
      Rect     visArea;
      char     text[60];
      
      fScroller->GetQDExtent(visArea);
      OffsetRect(visArea, 0, kHalfVGap);  // 11/08/95 ignore grey area at bottom of previous page
      fMainView->GetPageRange(visArea, currPage, endPage);
      endPage = fMainView->GetPageMax();
      hNumberText = TNumberText(aDialogView->FindSubView(gIDpgno));
      if (hNumberText != NULL)
      {
         hNumberText->fMaximum = endPage;
         hNumberText->SetValue(currPage, kDontRedraw);
      }
      sprintf(text, GetString(kShowPageText), currPage, endPage);
      aDialogView->WriteText(gIDpgtx, text);
   }
   else if (aCmd == cZoomGeneral)
   {
      TPagesPrintHandler printHdlr;
      TControl btn6 = TControl(aDialogView->FindSubView(I_('z', 'm', 'p', '6')));

      // 20/03/94 Initialise to current value for Style Guide
      aDialogView->WriteValueRedraw(gIDperc, ZoomPercent());

      if (btn6 != NULL && fMainView != NULL && 
                   (printHdlr = TPagesPrintHandler(fMainView->fPrintHandler)) != NULL)
      {
        int width = LengthRect(printHdlr->fPageAreas.thePaper, h);
        char buff[11];

        if (printHdlr->fSameInterior)
          width += LengthRect(printHdlr->fPageAreas.theMargins, h);
        else
          width -= 2 * Min(printHdlr->fPageAreas.theMargins.left,
                                 -printHdlr->fPageAreas.theMargins.right);
        if (width > 0)
        {
          int numerator;

#ifdef NETWP
          if (fScroller->fWindowPtr != NULL)
          {
            wr_wimp_box *box = fScroller->fWindowPtr->GetPortBox();

            numerator = Min(OStoQD(box->x1), SafeRight()) -
                         Max(OStoQD(box->x0) + fScroller->fLocation.h, SafeLeft());
          }
          else
#endif
            numerator = fScroller->fSize.h;
          // numerator = fSize.h - fWindowRecord.GetScrollBarWidth() + 96;
                             // 12/02/96 from - 64: use correct width when no scroll bar
          //#ifdef TABLES
          // if (fVScale != NULL && fVScale->GetGrafPort() != NULL)
          //  numerator -= (fVScale->fSize.h + GetVLineThickness()); // subtract vert scale width
          //#endif
          sprintf(buff, "%i%%", MinMax(10, ((numerator - 64) * 10000) / width, 999));
          btn6->SetText(buff, kRedraw);  // [26037]
        }
      }
   }
}


// ------------------------------------------------------------------------
TCommand _TScaledWindow::ReadFromDialog(TView aDialogView, CmdNumber aCmd,
                                                               IDType itsID)
{
   if (aCmd == cZoomGeneral)
   {
      fZoomNum = aDialogView->ReadValue(gIDperc, 100);
      fZoomDenom = 100;
      // 03/06/91 folowing moved so Adjust works immediately
      if (itsID == gIDzFit)
      {
        fZoomToFit = TRUE;
        fWindowRecord.SetWorkAreaToScreen();   // 25/07/90
        CheckZoom();
        aDialogView->WriteValueRedraw(gIDperc, ZoomPercent());
      }
      else if (itsID != gNoIdentifier)           // 20/08/90 for Escape 26/04/93 gNoIde..
      {
        fZoomToFit = FALSE;
        fWindowRecord.SetWorkAreaToWindow();   // 25/07/90
        DoZoom();
      }
   }
   else if (aCmd == cGotoPage)          // 11/10/93 allow adjust click on GotoPage dlog
   {
     fMainView->ScrollToPage(aDialogView->ReadValue(gIDpgno, 1));
   }
#ifdef TABLES
   else if (aCmd == cScaleUnits || aCmd == cHScaleUnits || aCmd == cVScaleUnits)
   {
      TScale radId = TScale((TCluster(aDialogView->FindSubView(I_(0, 0, 0, 'U')))->
                                                      ReportCurrent() & 0x0ff) - '0');
      int numberText = aDialogView->ReadValue(I_('C', 'u', 's', 't'), 12);

      if (aCmd != cVScaleUnits)
         fHScale->SetScale(radId, numberText, kRedraw);
      if (aCmd != cHScaleUnits)
         fVScale->SetScale(radId, numberText, kRedraw);
   }
#endif
   return gNoChanges;
}


// ------------------------------------------------------------------------
Fixed _TScaledWindow::ZoomPercent()
{
  return FixDiv(fZoomNum, fZoomDenom * (kFix1 / 100));
}

// ------------------------------------------------------------------------
void _TScaledWindow::SetZoomPercentage()
{
  // 10/03/93 [20806] set up the zoom factor field on the iconrow in the window
  Fixed zoomFactor = ZoomPercent();
  char aStr[12];

  sprintf(aStr, "%d%%", zoomFactor);
  WriteText(gIDprct, aStr);
}

// ------------------------------------------------------------------------
void _TScaledWindow::HandleZoomCommand(CmdNumber aCmdNumber)
{
  fZoomToFit = FALSE;
  fWindowRecord.SetWorkAreaToWindow();   // 25/07/90
  if (aCmdNumber == cZoomIn && (fZoomNum < fZoomDenom * kMaxZoom))
  {
    if (fZoomNum < fZoomDenom * (kMaxZoom / 2))
    {
      if (Odd(fZoomDenom))
         fZoomNum = fZoomNum + fZoomNum;
      else
         fZoomDenom = fZoomDenom / 2;
    }
    else
    {
      fZoomNum = 999;
      fZoomDenom = 100;
    }
    DoZoom();
  }
  else if ((aCmdNumber == cZoomOut) && (fZoomDenom < fZoomNum * kMaxZoom))
  {
    if (fZoomDenom < fZoomNum * (kMaxZoom / 2))
    {
      if (Odd(fZoomNum))
        fZoomDenom = fZoomDenom + fZoomDenom;
      else
        fZoomNum = fZoomNum / 2;
    }
    else
    {
      fZoomNum = 1;
      fZoomDenom = kMaxZoom;
    }
    DoZoom();
  }
}


// ------------------------------------------------------------------------
static void ZoomScale(TRulerScale rulerView, Fixed zoomFactor)
{
  if (rulerView != NULL)
    rulerView->SetMagnification(zoomFactor);
}

// ------------------------------------------------------------------------
void _TScaledWindow::DoZoom()
{
// 10/03/93 [20806] Set up the zoom percentage in common with ::Open
  Fixed zoomFactor = FixDiv(fZoomNum, fZoomDenom);
  VPoint scrollPos;
  VPoint scrollLimit;

  SetZoomPercentage();

  if (fScroller != NULL)
  { 
    BeginProgress();        // 29/04/91

    // SetVPt(scrollLimit, fScroller->fScrollLimit.right, fScroller->fScrollLimit.bottom);
    RectSizeToPt(fScroller->fScrollLimit, scrollLimit);

    // SetVPt(scrollPos, fScroller->GetTranslation(h), fScroller->GetTranslation(v));
    fScroller->GetTranslations(scrollPos);
    fMainView->SetMagnification(zoomFactor);
    if (scrollLimit.v != 0 && scrollLimit.h != 0)
    {
      TPrintHandler aPrintHandler = fMainView->fPrintHandler;
      int hPos;
      int vPos;
      Rect pageInterior;

      // 04/07/96 Try to scroll back to page interior (going to larger zoom which fills screen)
      if (aPrintHandler != NULL)
        TPagesPrintHandler(aPrintHandler)->GetViewedInterior(1, pageInterior, fScroller);
      else
        ClearRect(pageInterior);
#define TOPADJUST 40
      hPos = FixMul(scrollPos.h,
           FixDiv(fScroller->fScrollLimit.right - fScroller->fScrollLimit.left, scrollLimit.h));
      vPos = TOPADJUST + FixMul(scrollPos.v - TOPADJUST,
           FixDiv(fScroller->fScrollLimit.bottom - fScroller->fScrollLimit.top, scrollLimit.v));
      fScroller->ScrollTo(Max(hPos, pageInterior.left), Max(vPos, pageInterior.top));
    }

    ZoomScale(fHScale, zoomFactor);
#ifdef TABLES
    ZoomScale(fVScale, zoomFactor);
#endif

    fScroller->SetScrollParameters((zoomFactor < 1504 ? 40 : (zoomFactor > 2976 ? 160 : 80)),
#ifdef NETWP
            FixMul(zoomFactor, 155),   // line height for 14pt text
#else
            FixMul(zoomFactor, 153),   // line ht for 12pt text with 2pt below
#endif
            0, fZoomToFit);
    //fScroller->fScrollUnit.h = (zoomFactor < 150 ? 40 : (zoomFactor >= 300 ? 160 : 80));
    //fScroller->fConstrain[v] = fZoomToFit; // 10/06/91 full pg up/dn if ZTFit
    fMainView->DoPagination(); // 26/07/90
    HideProgress();            // 29/04/91
  }
}

// ------------------------------------------------------------------------
void _TScaledWindow::CheckZoom()
{
  int oldNum;
  int oldDenom;

  if (fZoomToFit && fScroller != NULL)
  {
    oldNum = fZoomNum;
    fZoomNum = TPagesPrintHandler(fMainView->fPrintHandler)->
                                          GetZoomToFit(fScroller->fSize, 1, 10);
    oldDenom = fZoomDenom;
    fZoomDenom = 10000;
    if (oldDenom != fZoomDenom || oldNum != fZoomNum)
      DoZoom();
  }
}

#if defined TABLES || defined DRAWSAVE
// ------------------------------------------------------------------------
void _TScaledWindow::SetBoxZoom(int setOn)
{
  fBoxZoom = (fBoxZoom == setOn ? 0 : setOn); // 01,08/12/93 cancel if on
  fMainView->DoBoxZoom(fBoxZoom);
}
#endif

#ifdef TABLES
// ------------------------------------------------------------------------
void _TScaledWindow::DoZoomBoxChoice(TView origView)
{
   VRect zoomBox;
   VRect interior;
   Fixed oldZoom;
   VPoint boxSize;

   zoomBox = TPagesView(origView)->fZoomBox;
   if ((!EmptyVRect(zoomBox)) && (fScroller != NULL))
   { 
      oldZoom = FixDiv(fZoomNum, fZoomDenom);
      RectSizeToPt(zoomBox, boxSize);
      fZoomDenom = 100;
      fZoomNum = Min(999, Max(10, FixMul(Min(
               FixMul(FixDiv(fScroller->fSize.h, boxSize.h), oldZoom),
               FixMul(FixDiv(fScroller->fSize.v, boxSize.v), oldZoom)), 100)));
      fZoomToFit = FALSE;
      DoZoom();
      oldZoom = FixDiv(FixDiv(fZoomNum, fZoomDenom), oldZoom);
      TPagesView(origView)->GetPaperArea(TPagesView(origView)->fDownPage,
                                         interior);
      while (origView != fScroller)
      {
        OffsetVRect(interior, origView->fLocation.h, origView->fLocation.v);
        origView = origView->fSuperView;
      }
      fScroller->ScrollTo(interior.left + FixMul(zoomBox.left, oldZoom),
                 interior.top + FixMul(zoomBox.top, oldZoom));
   }
}
#endif

// ------------------------------------------------------------------------
void _TScaledWindow::DoChoice(TView origView, int itsChoice)
{
  TDialogView dialogView;

  switch (itsChoice)
  {
    case mPrinterChanged:
      CheckZoom();
      break;

#ifdef TABLES
    case mBoxZoom:
      DoZoomBoxChoice(origView);
      break;

    case mControlHit:
      if (origView->fIdentifier == I_('C', 'u', 's', 't'))
      {
        origView->fSuperView->WriteCheckBox(I_(0, 0, 'B', '8'), TRUE);
        break;
      }
      // else run into default case
#endif

    default:
      dialogView = TDialogView(origView->GetWindow());
      if ((origView->fIdentifier & 0xfffffff0) == I_('z', 'm', 'p', '0'))
      {
        char buff[12];
        char *percPtr;

        TControl(origView)->GetText(buff);
        percPtr = strchr(buff, '%');
        if (percPtr != NULL)
          percPtr[0] = 0;
        dialogView->WriteText(gIDperc, buff)->Validate(FALSE);
        // 20/03/94 use Validate to copy value to fCurrentValue for redraw after Adj-Cancel
      }
      else
        _TWindow::DoChoice(origView, itsChoice);
  }
}

// ------------------------------------------------------------------------
void _TScaledWindow::SubViewChangedSize(TView theSubView, VPoint &delta)
{
  // base method is null: _TWindow::SubViewChangedSize(theSubView, delta);
  if (theSubView == fScroller)
    CheckZoom();
}

// ------------------------------------------------------------------------
static void EnableIt(TObject null, TView subV, bool state)
{
  subV->ViewEnable(state, kRedraw);
}

// ------------------------------------------------------------------------
void _TScaledWindow::DoSetupMenus()
{
  bool greekShown;
  bool rulerShown;
  bool scalesShown;
  TView tabWell;
  bool wellEnabled;
  int temp;

  _TWindow::DoSetupMenus();

  GetSettings(greekShown, rulerShown, scalesShown, temp);

#ifdef TABLES
  EnableCheck(cShowHideScales, TRUE, scalesShown);
#endif
  Enable(cGotoPage, bool(fScroller));
  EnableCheck(cShowHideRuler, TRUE, rulerShown);

#ifndef NEWRULE
  if (rulerShown)
  {
    fHScale->ShowSelection();
    fHScale->DrawTabs();
#ifdef TABLES
    tabWell = FindSubView(gIDwell); // 26/07/90 - tabwell block new
    if (tabWell != NULL)
    {
      // 25/10/93 Avoid enabling the tab well itself so it is not selected by clicks off tabs
      wellEnabled = TControl(tabWell)->IsDimmed(); // !tabWell->IsViewEnabled();
      if (wellEnabled == fHScale->CanAddTabs())
      {
        TControl(tabWell)->fDimmed = !wellEnabled; // tabWell->ViewEnable(wellEnabled, TRUE);
        tabWell->EachSubview(NULL, (DoToSubView)EnableIt, wellEnabled);
      }
    }

    if (fHScale != fTarget && fHScale->CanAddTabs())
      EnableCmd(cNewTabDialog);
#endif
  }
#ifndef TABLES
  // 09/10/92 Disable the tab well in !StartWrite if ruler hidden - nothing can be done
  tabWell = FindSubView(gIDwell);
  if (tabWell != NULL)
  {
    // 25/10/93 Avoid enabling the tab well itself so it is not selected by clicks off tabs
    wellEnabled = TControl(tabWell)->IsDimmed();  // !tabWell->IsViewEnabled();
    if (wellEnabled == (rulerShown && fHScale->CanAddTabs()))
    {
      TControl(tabWell)->fDimmed = !wellEnabled;  // tabWell->ViewEnable(wellEnabled, TRUE);
      tabWell->EachSubview(NULL, (DoToSubView)EnableIt, wellEnabled);
    }
  }
#endif
#endif
#ifdef MATHS
  EnableCheck(cGreekIcon, TRUE, greekShown == 1);
  EnableCheck(cShowGreekPal, TRUE, (6 >> greekShown) & 1);
  EnableCheck(cShowMathBtns, TRUE, (10 >> greekShown) & 1);
#endif
#ifdef TABLES
  EnableCmd(cScaleUnits);
#endif
#if !defined TABLES || defined NETWP
  TScale units = fHScale->GetScale();
  EnableCheck(cInches, TRUE, units == eInches);
  EnableCheck(cCentimetres, TRUE, units == eCentimetres);
  EnableCheck(cMillimetres, TRUE, units == eMillimetres);
#endif

#ifdef NETWP
  int oneTicked = 0;
  int maxZoom = 0;
  int dummy;

  for (int j = cZoomMax; j >= cWritableZoom; j--)
    if (CmdToMenuItem(j, dummy) >= 0)
    {
      char menuText[20];
      int tickit;

      tickit = FALSE;
      if (j == cWritableZoom)
      {
        if (oneTicked)
          *menuText = 0;
        else
        {
          sprintf(menuText, "%d%%", ZoomPercent());
          tickit = TRUE;
        }
        SetCmdName(j, menuText);
      }
      else
      {
        int menuDenom;
        int currNum;

        CmdToName(j, menuText);
        currNum = fZoomNum * 100;
        menuDenom = atoi(menuText) * fZoomDenom;
        if (menuDenom == currNum)
          tickit = oneTicked = TRUE;

        // 23/08/96 [27047] dim zoom buttons at end of range
        if (maxZoom == 0)
        {
          maxZoom = 1;
          Enable(cZoomUp, menuDenom > currNum);
        }
        if (j == cZoomMin)
          Enable(cZoomDown, menuDenom < currNum);
      }
      EnableCheck(j, TRUE, tickit);
    }
  EnableCmd(cCloseWindow);
  EnableCmd(cMenuByKey);
  EnableCmd(cHelp);
  // EnableCmd(cZoomUp);
  // EnableCmd(cZoomDown);
  EnableCmd(cPgLeft);
  EnableCmd(cPgRight);
  EnableCmd(cPgUp);
  EnableCmd(cPgDn);
  EnableCmd(cNewDocTitle);
  SetCmdName(cNewDocTitle, fDocument->GetNickName());
#endif
  EnableCheck(cShowHideButtons, TRUE, temp);
  Enable(cZoomIn, fZoomNum * 100 < fZoomDenom * ((kMaxZoom * 100) - 1));
  Enable(cZoomOut, fZoomNum * kMaxZoom > fZoomDenom);
#ifdef TABLES
  EnableCheck(cBoxZoom, TRUE, fBoxZoom == crossCursor);  // 09/02/96 [27019]
#endif

  // new - the zoom % dialog box
  EnableCmd(cZoomGeneral);
#ifdef DRAWSAVE
  EnableCheck(cSaveDraw, TRUE, drawCursor == fBoxZoom);  // 08/12/93
#endif
}


// ------------------------------------------------------------------------
void _TScaledWindow::PlaceBehindPane(TWindow wdw)
{
  // sort out odd case when window opens above button bar
  if (fIconBarPane)
    wdw->fWindowRecord.SetBehind(fIconBarPane->fWindowRecord.GetHandle());
}

#ifdef NETWP
// ------------------------------------------------------------------------
static void FakeCloseWindow(int w)
{
  wr_wimp_eventstr e;

  CloseCurrentMenu();   // avoid leaving menu showing after adj click on menu
  e.e = wr_wimp_ECLOSE;
  e.data.o.w = w;
  wr_wimpt_fake_event(&e);
}

// ------------------------------------------------------------------------
static TCommand SendURL()
{
// Help messages to the browser
// ----------------------------

//   +0  = 47 + len help URL rounded up to multiple of 4
//   +12 = 0
//   +16 = 0x4AF80
//   
//   +20 = 0
//   +24 = 27
//   +28 = 0
//   +32 = 0
//   +36 = 20
//   
//   +40 .. 
//         "__help", 0
//   +47 .."file:/NCHelp:NCWriter/index.html"
//         help URL, null terminated
  wr_wimp_msgstr msg;

  msg.data.words[0] = 0;
  msg.data.words[1] = 27;     // 28/08/96 [27048] rather than 47 in Help broadcast to Browser

  msg.data.words[2] = 0;
  msg.data.words[3] = 0;
  msg.data.words[4] = 20;     // 28/08/96 [27048] rather than 40 in Help broadcast to Browser
  strcpy(msg.data.chars + 20, "__help");
  strcpy(msg.data.chars + 27, GetString(96));
  Broadcast(0x4AF80, &msg, (strlen(msg.data.chars + 28) + 52) & 0xfffffffc);
  return gNoChanges;
}
#endif

// ------------------------------------------------------------------------
TCommand _TScaledWindow::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
  bool greekShown;
  bool scalesShown;
  bool rulerShown;
  int buttonsShown;
  // int buttonsWereShown;
  int dialogID = 0;

  GetSettings(greekShown, rulerShown, scalesShown, buttonsShown);
  // buttonsWereShown = buttonsShown;

  // *** NB cases which need dialogues set dialogID, those which reset pane settings
  // break, the rest return gNoChanges ***
  switch (aCmdNumber)
  {
#ifdef TABLES
    case cShowHideScales:
      scalesShown = !scalesShown;
      break;
#endif

    case cShowHideRuler:
      rulerShown = !rulerShown;
      if (!rulerShown && fTarget == fHScale)
        SetTarget(fHScale->fTarget);
      break;

#ifdef DRAWSAVE
    case cSaveDraw:         // 12/10/92
      SetBoxZoom(drawCursor);
      return gNoChanges;
#endif

#ifdef TABLES
    case cBoxZoom:
      SetBoxZoom(crossCursor);
      return gNoChanges;
#endif

#ifdef TABLES
    case cScaleUnits:
      if (fVScale->fWindowPtr && fVScale->fWindowPtr->GetHandle() == info.windowID)
        aCmdNumber = cVScaleUnits;
      else if (fHScale->fWindowPtr && fHScale->fWindowPtr->GetHandle() == info.windowID)
        aCmdNumber = cHScaleUnits;
      dialogID = kScalePrefView;
      break;
#endif
#if !defined TABLES || defined NETWP
    case cInches:
    case cCentimetres:
    case cMillimetres:
      fHScale->SetScale(TScale(aCmdNumber == cInches ? 0 : (aCmdNumber - cInches) / 4 + 1),
                        12 /* custom */, kRedraw);
      if (rulerShown)
        return gNoChanges;
      rulerShown = TRUE;
      break;
#endif

    case cGotoPage:
      dialogID = kGotoPage;
      break;

    case cZoomGeneral:
      dialogID = kZoomDlog;
      break;

    case cZoomIn:
    case cZoomOut:
      HandleZoomCommand(aCmdNumber);
      return gNoChanges;

#ifdef MATHS
    case cShowGreekPal:
    case cShowMathBtns:
      greekShown ^= (aCmdNumber - cShowGreekPal + 2);
      break;

    case cGreekIcon:
      greekShown = (greekShown ^ 1) & 1;
      break;
#endif

#ifdef NETWP
    case cHelp:
      return SendURL();

    case cMenuByKey:
      {
          // F2 - pop up main menu - simulate menu press over menu button
        TControl mb = TControl(FindSubView(I_('m', 'e', 'n', 'u')));

        if (mb)
        {
          if (mb->IsOn())
          {
            mb->HiliteState(FALSE, kRedraw);
            wr_event_clear_current_menu();
          }
          else
          {
            info.event->data.but.m.x = QDtoOS(SafeLeft());
            info.event->data.but.m.y = 0x10000;
            info.event->data.but.m.w = mb->fWMgrWindow;
            info.event->data.but.m.i = mb->fIconNum;
            mb->FakeMenuEvent(info);
          }
        }
      }
      return gNoChanges;

    case cCloseWindow:  // 20/02/96 close window as a command
      FakeCloseWindow(fWindowRecord.GetHandle());
      return gNoChanges;


    case cZoomDown:
    case cZoomUp:
      {
        char menuText[20];
        int newZoom = 0;
        int thisZoom = 0;

        if (wr_akbd_pollsh())
          aCmdNumber = aCmdNumber ^ (cZoomDown ^ cZoomUp);    // switch meaning if <shift> key
        if (aCmdNumber == cZoomUp)
        {
          for (int ci = cZoomMax; ci >= cZoomMin; ci--)
            if (CmdToMenuItem(ci, buttonsShown) >= 0)
            {
              CmdToName(ci, menuText);
              thisZoom = atoi(menuText);
              if (fZoomNum * 100 < thisZoom * fZoomDenom)
                newZoom = thisZoom;
            }
        }
        else
        {
          for (int ci = cZoomMin; CmdToMenuItem(ci, buttonsShown) >= 0; ci++)
          {
            CmdToName(ci, menuText);
            thisZoom = atoi(menuText);
            if (fZoomNum * 100 > thisZoom * fZoomDenom)
              newZoom = thisZoom;
          }
        }
        if (newZoom != 0)
        {
          fZoomNum = newZoom;
          fZoomDenom = 100;
          DoZoom();
        }
        return gNoChanges;
      }

    case cHome:
    case cEnd:
        // 23/08/96 [27045] 2 Commands for Scroll Home/To End (for Adjust click up/down)
    case cPgUp:
    case cPgDn:
      return fTarget->DoCommandKey(0x19f + cPgUp - aCmdNumber, info);

    case cPgLeft:
    case cPgRight:
      info.affectsMenus = FALSE;
      fScroller->ScrollStep(aCmdNumber == cPgLeft ? -2 : 2, 0);
      return gNoChanges;

    case cNewDocTitle:
      {
        char menuText[36];

        CmdToName(cNewDocTitle, menuText);
        fDocument->SetNickName(menuText);
      }
      return _TWindow::DoMenuCommand(info, cSaveWord);
      // 12/09/96 [27082] return gNoChanges;
#endif

    case cShowHideButtons:
      buttonsShown = !buttonsShown;
      break;

    case cRevert:
      /* 31/08/94 [22020] set up the 'behind' window to the pane's   */
      /* handle, to stop the whole window going to the back when the */
      /* doc is reverted with different scale options set            */
      /* then run on into the inherited method to do the work        */
      fWindowRecord.SetBehind(fWindowRecord.GetHandle());
                // 09/07/96 open at same window stack level (experiment)
      // if (buttonsWereShown)
      //   PlaceBehindPane(this);

    default:
      // 10/02/96 [27021] zoom menu
      if ((aCmdNumber < 0 && MenuForNegCmd(aCmdNumber) == cmZoom) ||
                             (aCmdNumber >= cWritableZoom && aCmdNumber <= cZoomMax))
      {
        char menuText[20];

        CmdToName(aCmdNumber, menuText);
        if (*menuText)     // do not reset zoom on an empty field
        {
          fZoomDenom = 100;
          fZoomNum = MinMax(10, atoi(menuText), 999);
          DoZoom();
        }
        return gNoChanges;
      }

      if (fHScale != NULL && aCmdNumber >= cTabMove && aCmdNumber <= cMultiTabMove)
        return fHScale->DoMenuCommand(info, aCmdNumber);

      return _TWindow::DoMenuCommand(info, aCmdNumber);
  }

  if (dialogID != 0)
    return DoDialogue(this, aCmdNumber, dialogID, -1);

  // *** the only cases which get here alter the pane settings ***
  OrganiseInterior(scalesShown, rulerShown, greekShown, buttonsShown);

  //if (buttonsWereShown)
  //  PlaceBehindPane(this);
  fWindowRecord.SetBehind(fWindowRecord.GetHandle()); // 09/07/96 open at same window stack level
    /* set up the 'behind' window to the pane's handle, to stop the */
    /* whole window going to the back when the scales are closed    */

  OpenWindow();
  return gNoChanges;
}


// ------------------------------------------------------------------------
void _TScaledWindow::SetTarget(THandler newTarget)
{
  if (fTarget != newTarget)
  {
    if (fTarget == fHScale)
      fHScale->MakeActive(FALSE);
    _TWindow::SetTarget(newTarget);
    if (newTarget == fHScale)
      fHScale->MakeActive(TRUE);
  }
  else
    _TWindow::SetTarget(newTarget);
}


// ------------------------------------------------------------------------
static bool ClickInView(TView theView, VPoint &theMouse)
{
   VPoint subViewPt = theMouse;

   theView->SuperToLocal(subViewPt);
   return(theView->ContainsMouse(subViewPt));
}


// ------------------------------------------------------------------------
bool _TScaledWindow::HandleMouseDown(VPoint &theMouse, EventInfo &info,
                                     TCommand &theCommand)
{
  bool HandleMouseDown_r = FALSE;
  bool wantsTheMouse = TRUE;

#ifdef DRAGDROP
  if (info.theClickCount > 0)  // 22/03/93 ignore if drag from another window
#endif
  {
#ifdef TABLES
    if (fActionBox->IsShown() && ClickInView(fActionBox, theMouse))
    {
      if (info.theClickCount > 1)
      {
        fVScale->ResetOrigin();
        fHScale->ResetOrigin();
      }
      else
      {
        theCommand = new _TScaleCommand(this,
                fActionBox->fSize.h, fActionBox->fLocation.v + 
                fActionBox->fSize.v);
      }
      info.affectsMenus = FALSE;  // 01/03/96
      wantsTheMouse = FALSE;
      HandleMouseDown_r = TRUE;
    }
    else
#endif
    if (fTarget == fHScale && ClickInView(fScroller, theMouse))
    {
      SetTarget(fHScale->fTarget);
    }
    else if (theMouse.v < kPaletteAndLine)
      gApplication->SetupTheMenus();
  }

  if (wantsTheMouse)
     HandleMouseDown_r = _TWindow::HandleMouseDown(theMouse,info,theCommand);

#ifdef DRAGDROP
  if (info.theClickCount > 0)  // 22/03/93 ignore if drag from another window
#endif
  {
#if defined TABLES || defined DRAWSAVE
    SetBoxZoom(0);
#endif
    fWindowRecord.SetCaret();  // 30/07/90 get window to gain caret wherever clicked !!!
  }
  return HandleMouseDown_r;
}


// ------------------------------------------------------------------------
int _TScaledWindow::GetScaleUnits(VHSelect direction, TScale &units)
{
#ifdef TABLES
  TRulerScale scale = (direction == h ? fHScale : fVScale);
#else
  TRulerScale scale = fHScale;
#endif

  if (scale == NULL)
    return _TWindow::GetScaleUnits(direction, units);

  units = scale->GetScale();
  return scale->GetCustomPoints();
}


// *************************************************************************
TCommand _TScaledWindow::DoKeyCommand(int aKeyCode, EventInfo &info)
// 16/01/92 new
{
#ifdef TABLES
  return (aKeyCode == chEnter ?
    fTarget->DoMenuCommand(info, cEndStruct) :
       _TWindow::DoKeyCommand(aKeyCode, info));
#else
  return _TWindow::DoKeyCommand(aKeyCode, info);
#endif
}

#ifdef TABLES
// ------------------------------------------------------------------------
_TScaleCommand::_TScaleCommand(TView theView, long hOrigin,
                      long vOrigin) : (cNoCommand, NULL, theView, NULL)
{
  fHOrigin = hOrigin;
  fVOrigin = vOrigin;
}

// ------------------------------------------------------------------------
static void SetScale(VPoint &thePoint, TRulerScale theScale,
                     VHSelect direction)
{
   TView aView = theScale;
   VPoint temp = thePoint;

   while (aView != NULL)
   {
      aView->SuperToLocal(temp);
      aView = aView->fSuperView;
   }
   theScale->SetScaleOrigin(temp.vh[direction]);
}

// ------------------------------------------------------------------------
TCommand _TScaleCommand::TrackMouse(TrackPhase aTrackPhase,
                                    VPoint &anchorPoint,
                                    VPoint &previousPoint,
                                    VPoint &nextPoint, bool mouseDidMove,
                                    EventInfo &info)
{
  TCommand  TrackMouse_r = this;

  if (aTrackPhase == trackPress)
     HideCursor();
  else if (aTrackPhase == trackRelease)
  {
    ShowCursor();
    if (nextPoint.v >= fVOrigin)
    {
      // nextPoint.v -= (GetHLineThickness() - 9);        // 21/04/91, ZZ 01/03/96 was * 3
         // Need to be careful to coordinate with Ruler scroll & SetScaleOrigins
      SetScale(nextPoint, TScaledWindow(fView)->fVScale, v);
    }
    if (nextPoint.h >= fHOrigin)
    {
      SetScale(nextPoint, TScaledWindow(fView)->fHScale, h);
    }
    TrackMouse_r = gNoChanges;
  }
  return TrackMouse_r;
}


// ------------------------------------------------------------------------
void _TScaleCommand::TrackFeedback(VPoint &anchorPoint, VPoint &nextPoint,
                                   bool turnItOn, bool mouseDidMove)
{
  if (mouseDidMove)
  {
    // routine to display lines from dragging from topleft box (scales)
    PenNormal();
    PenPat(15);                        // 04/09/90 use nice blue colour
    PenMode(patXor);

    MoveTo(0, nextPoint.v);
    if (nextPoint.v >= fVOrigin || nextPoint.h < fHOrigin)
       Line(100000, 0);
    MoveTo(nextPoint.h, 0);
    if (nextPoint.h >= fHOrigin || nextPoint.v < fVOrigin)
       Line(0, 100000);
  }
}
#endif
