/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "UTextDoc.h"
#include "USaveDraw.h"
#include "UTextComm.h"
#include "UClipBrd.h"

// new for Talk/Utilities
#include "TalkMsgs.h"
#include "win.h"

extern FontTree *AllocFontTreeNode(int namePartLen, char *name);
extern int GetMenuColour(MenuHandle theMenu, int item);
extern wr_os_error *FontFind(int *handle, char *name, int xsize, int ysize);
extern void FontLose(int handle);

#ifndef NETWP
int gEnableKeys;
TList gControlBlockList;
#endif

#define cAlignForce        119
#define cStartKeySelection 808
//#define kOldestSupported 3
#define kOldestSupported   4

#ifdef PRO
#define kCurrentVersion 11
#else
#define kCurrentVersion 10
  // non-pro version means no numbered lists or indexing.
  // version 11 means there may (or may not be). NB test in
  // DoRead must be changed if this convention is changed
#endif

// fn1 new version
// #if defined AUTONUM || defined INDEX
// #define kCurrentVersion 9
// #else
// #define kCurrentVersion 8
// #endif
// version = 3;             // 31/01/91
// version = 4;             // 02/03/91 - data compressed
// version = 5;             // 02/03/91 - word counts
// version = 6;             // 1992 - maths and footnotes
// version = 7;             // 1992 - aligned equations
// version = 8;             // 17/05/92 - MailMerge
                            // 05/08/92 NB version 8 may have spurious maths
// version = 9;             // 12/10/94 - Auto-numbering, indexes, cross-references
                            //            kTextStruct records Ver=2
// version = 10/11;         // 02/05/95 - Start footnote num
                            //            root/fraction text styles + force reformat

typedef TDiscPosition TStructureRecords[kMathStyleStruct - kTextStruct + 1];

// 18/09/90 more fields added
typedef struct TDocRecord
{
  int version;
  union {
    struct {
      unsigned numberOfViews:7;
      unsigned substitutedFonts:1;
      unsigned customDateLength:8;
      unsigned contTextLength:8;
      unsigned leftRightHdr:1;
      unsigned leftRightFtr:1;
      unsigned interactive:1;
      unsigned alwaysUpdate:1;
      unsigned /*DateForm*/ dateFormat:2;
      unsigned /*TimeForm*/ timeFormat:2;
    } bits;
    struct {
      char c0;
      char customDateLen;
      char contTextLen;
      char c3;
    } chars;
  } u1;
  unsigned int numLevels:16;
  unsigned int bookmarkRec:16;
  TCurrency body;
  TCurrency leftHeader;
  TCurrency rightHeader;
  TCurrency leftFooter;
  TCurrency rightFooter;
  TStructureRecords structureHandlers;
  TCurrency italicStyle;   // 11/01/92
  TCurrency greekStyle;    // 11/01/92
  TCurrency symbolsStyle;  // 11/01/92
  TDiscPosition pictureHandler;
  TBodyStyles bodyStyles;
  TCurrency emphStyle;
  long formatPosition;
  TStatistics statistics;
  union {
    struct {
      unsigned mergeTitleLen:16; // 17/05/92
      unsigned mergeFileLen:8;   // 17/05/92
      unsigned mergeHeadings:8;  // 17/05/92
    } bits;
    struct {
      char mergeTitleLen0;
      char mergeTitleLen1;
      char mergeFileLen;
      char mergeHeadings;
    } chars;
    int merge;
  } u2;
  TCurrency footnoteBody;     // 19/04/95 replacing ref in every body
  int firstFootnote;          // 19/04/95 allow for notes to start other than with 1
  int spareZero1;
  int spareZero2;
} TDocRecord;

static bool gMarkingFailed;              // 18/03/91 & all references

// ------------------------------------------------------------------------
void SetTextMenus(TStyleFormat theStyle, TTextDocument theDoc, int &theTextSizeX, int &theTextSizeY)
{
  bool hasCase;
  int i;
  TAlignment myAlign;
  int textFace;
  char menuText[40];

#ifdef TABLES
  EnableCmd(cTypeSpec);
  EnableCmd(cSelStyleName);    // 16/02/94 [21400] does need to be enabled as now dynamic
// 13/06/93 [20937] no effect on Arc:  Enable(cSelStyleName, CountMItems(*GetResMenu(cmSelStyle)) > 0);  // 07/06/90 - new
#else
#if SIDEBAR == 1
  EnableCmd(cSizeDialog);
#endif
#endif

// 27/04/92 always true:  if (paragraph)
  {
#ifdef TABLES
    EnableCmd(cSpacing);
#endif
    EnableCmd(cBorders);
  }

  // enable the colour menu
#ifdef NETWP
  {
    int nearest = 7;
    MenuHandle m = *GetResMenu(cmColour);

    if ((theStyle->fDefined & kColour) != 0 && (theStyle->fColour & 0xffffff00) != 0 )
    {
      wr_wimp_palettestr palette;
      wr_os_regset r;

      wr_wimpt_noerr(wr_wimp_readpalette(&palette));
      r.r[0] = theStyle->fColour;
      r.r[1] = 12;      // a 16 colour mode
      r.r[2] = (int)&palette;
      wr_wimpt_noerr(wr_os_swix(0x40745 /*ColourTrans_ReturnGCOLForMode*/, &r));
      nearest = r.r[0];
    }
    for (i = CountMItems(m); i > 0; i--)
    {
      EnableItem(m, i);
      if (GetMenuColour(m, i) == nearest)
        CheckItem(m, i, TRUE);
    }
  }
#endif
  Enable(cColour, ((theStyle->fDefined & kColour) != 0));

  // enable Larger and Smaller text sizes
  if ((theStyle->fDefined & kSize) != 0)
  {
    theTextSizeX = theStyle->fTextSizeX;
// 06/04/92    Enable(cLarger, theTextSizeX < (127 * 16));
    theTextSizeY = theStyle->fTextSizeY;
// 06/04/92    Enable(cSmaller, theTextSizeX > (4 * 16));
  }
  else
  {
    theTextSizeX = (12 * 16);
    theTextSizeY = (12 * 16);
  }
#ifdef TABLES
  hasCase = ((theStyle->fDefined & kCaps) != 0);
  // 10/07/91 use loop
  for (i = kMixedCase; i <= kInitialCaps; i++)
  {
    EnableCheck(cMixedCase + i, TRUE, hasCase && (theStyle->fTextCaps == i));
             /* gCaseCmds[i] */ 
  }
  // 25/10/90 add hyphenation as a ticked item to menus
  EnableCheck(cHyphenation, TRUE, (theStyle->fDefined & kHyphenate) &&
                                                    theStyle->fHyphenate);
#endif
  EnableCmd(cPlain);      // 31/01/91 ??? Tick it

  textFace = ((theStyle->fDefined & kFace) ? theStyle->fTextFace : 0);
  EnableCheck(cBold, TRUE, textFace & kBold);
  EnableCheck(cItalic, TRUE, textFace & kItalic);
// 04/03/94 [21432] sub/super should not enable when selection over multiple equations
// so moved to UTextComm
  EnableCheck(cUnderline, TRUE, (textFace & 3) == kUnderline);
                                  // 17/06/93 [20947] underline in EW & TW
#if !defined TABLES || defined NETWP
  // 24/08/92 enable these while waiting for real thing in StartWrite

  EnableCheck(cSingleLine, TRUE, theStyle->fLeading == 0);
  EnableCheck(cOneHalfline, TRUE, theStyle->fLeading != 0 && !(theStyle->fLeading & 1));
  EnableCheck(cDoubleLine, TRUE, theStyle->fLeading != 0 && (theStyle->fLeading & 1));
#endif
#ifndef TABLES
  EnableCheck(cBorderOne, TRUE, 
       (theStyle->fDefined & kAdornment) && (theStyle->fAdornment & adnShadow));
#endif

  myAlign = ((theStyle->fDefined & (kHasAlignment | kOwnAlignment)) ==
            (kHasAlignment | kOwnAlignment) ? theStyle->fOwnAlignment : theStyle->fAlignment);
// 16/06/92 only for Mac dialogues? bool hasAlign = ((theStyle->fDefined & kAlignment) != 0);

  for (i = kAlignLeft; i <= kFill; i++)
    EnableCheck(cAlignLeft + i, TRUE, myAlign == i);

#ifdef TABLES
  EnableCheck(cAlignForce, TRUE, myAlign == kAlignForce);  // [26067]
#endif
#if defined TABLES && ! defined NETWP
  // 05/11/92 for dynamic language (Country) menu
  theDoc->fCurrentMenuLanguage = (theStyle->fDefined & kLanguage) != 0 ?
                                                       theStyle->fLanguage : -2;
  EnableCmd(cLanguageMenu);  // 11/01/94
#endif

  theDoc->fCurrentMenuFont = theStyle->fTextFont;  // 03/11/92
  EnableCmd(cFontMenu);   // 11/01/94

  // 19/01/94 [21349] Set current value in writable menu text if it does not match std vals
  hasCase = theStyle->fTextSizeX == theStyle->fTextSizeY;   // 19/01/94
  for (i = cLowestText; i <= cHighestText; i++)
  {
    int theSize;
    bool isTicked;

    CmdToName(i, menuText);
    StringToNum(menuText, theSize);
    theSize <<= 4;                      // convert to 1/16ths
    isTicked = hasCase && (theSize == theStyle->fTextSizeX);
                                        // 19/01/94 && theSize == theStyle->fTextSizeY);
    EnableCheck(i, TRUE, isTicked);
    if (isTicked)
      hasCase = FALSE;                  // 19/01/94 leave writable field blank if any ticked
  }
  {
    CvtUnitsToStr((ToFixed(theStyle->fTextSizeY) >> 4) * 10,
                                      ePoint16, 12, eNoConstraint, 0, menuText);
  }
#ifdef NETWP
  {
    TWindow window = theDoc->ActiveMainView()->GetWindow();

    if (menuText[0] != 0)
      strcat(menuText, "pt");
    window->WriteText(I_('c', 'f', 's', 'z'), menuText);
    if (theStyle->fTextFont)
      window->WriteText(I_('c', 'f', 'n', 't'), theDoc->GetFName(theStyle->fTextFont));
  }
#endif
  if (!hasCase)                          // 19/01/94 nothing ticked and X == Y sizes
    menuText[0] = 0;
  SetCmdName(cWriteableSize, menuText);
  EnableCheck(cWriteableSize, TRUE, hasCase);
}

// ------------------------------------------------------------------------
int _TTextDocument::SetCurrentFont(PFontStyle fontStyle)
//int fontNum, int fontXSize, int fontYSize)
{
  // 13/10/92 new - simplify method to avoid lots of calls to MAFont_SetCurrentFont
  if (fFontList->fSize == 0)    // test for call from TDSel loading with endStructure set
  {
#ifdef TRACE
    SysBeep(0);
#endif
    return 0;
  }

  // 30/01/95 inline: (FontTree *)fFontList->At(fontStyle->fTextFont);
  return MAFont_SetCurrentFont(
           (FontTree *)*(PObj(fFontList->fPtrToList) + fontStyle->fTextFont - 1), fontStyle);
}

#ifdef MATHS

TFont gFont;

// ------------------------------------------------------------------------
int _TTextDocument::GetEmphasisStyle(TFont itsFont)
{
  TCurrency curr;

  curr = 0;
  switch (itsFont)
  {
  case eSymbol:
    curr = fGreekStyle;
    break;
  case eRoman:
    break;
  case eItalic:
    curr = fItalicStyle;
    break;
  default:
    curr = fSymbolsStyle;
  }
  return Curr_fRecnum(curr);
}

// ------------------------------------------------------------------------
char *_TTextDocument::FontName(int fontRefNum)
{
  FontTree *ptr = (FontTree *)fFontList->At(fontRefNum);

  // 21/08/95 [26057] do not use -1 any more: if ((int)ptr <= 0)
  if (ptr == NULL)
    return NULL;                // 16/11/92 avoid crash if font not present

  while (ptr->info.parentPtr != NULL)  // the top parent ptr == NULL
     ptr = (FontTree*) ptr->info.parentPtr;
  return ptr->fonttext;
}

// ------------------------------------------------------------------------
bool _TTextDocument::FontIsSymbol(int theFont)
{
  TCurrency emphStyleCurrency;
  TStyleFormat emphStyle;
  TStyleFormat builtInSymbol;
  TMainView mainView;

  if (theFont == 0)
    return FALSE;  // or check fStyle ?

  emphStyleCurrency = Curr_Set(theFont, kTextStyleStruct);

  if (emphStyleCurrency == fItalicStyle)
    return FALSE;

  if (emphStyleCurrency == fGreekStyle ||
                   emphStyleCurrency == fSymbolsStyle)
    return TRUE;

  mainView = ActiveMainView();
  emphStyle = mainView->GetStyleReadOnly(emphStyleCurrency);
  if ((emphStyle->fDefined & kFont) == 0)
    return FALSE;
  builtInSymbol = mainView->GetStyleReadOnly(fSymbolsStyle);

  return FontName(emphStyle->fTextFont) == FontName(builtInSymbol->fTextFont);
}

#endif

// ------------------------------------------------------------------------
TCurrency RecToCurrency(int recNum)
{
  TCurrency currency;

//  currency.fValue = 0;
//  if (recNum > 0)
//  {
//    currency.cgf_31.fType = kTextStyleStruct;
//    currency.cgf_31.fRecnum = recNum;
//  }
  if ((currency = recNum << 16) != 0)
    currency |= kTextStyleStruct;
  return currency;
}


// ------------------------------------------------------------------------
#define DeclareFont   0x00080155
static void DeclareUsedFont(TObject null, char **fontname)
{
  wr_wimpt_noerr(wr_os_swi3(DeclareFont | wr_os_X, 0, (int)*fontname, 2)); // 29/10/94 [23012] 0->2
}

// ------------------------------------------------------------------------
void _TTextDocument::DeclarePrinterFonts()
{
  // 02/03/94 [21426] always use gMasterList in EW & SW
  gMasterList->Each(NULL, (DoToItem)DeclareUsedFont);
  FreeMasterList();

  // end of list call in case (ever?) no fonts used
  FailOSErr(wr_os_swi3(DeclareFont | wr_os_X, 0, 0, 0));
}

// ------------------------------------------------------------------------
char* _TTextDocument::GetFName(int fontRefNum)
{
  // from a font number in fFontList, this returns the full arc font pathname
#ifdef TRACE
  if (fontRefNum <= 0 || fontRefNum > fFontList->GetSize())
    Assert(0, 68);
#endif

  if (fontRefNum != fLastFontRefNum)
  {
    // go and build up the new string
    FontTree *ptr = (FontTree *) fFontList->At(fontRefNum);

#ifdef TRACE
    Assert(ptr, 69);
#endif
    if (ptr->info.terminal == 2)  // 19/04/96 it is a missing font (pointing up to default font)
      ptr = (FontTree *)ptr->info.parentPtr;
    // 21/08/95 [26057] if (ptr == (FontTree *) -1)
    //   strcpy(fLastFontName, GetString(kDefaultFontMsg));
    // else
    GenerateFontName(ptr, fLastFontName);
    fLastFontRefNum = fontRefNum;
  }

  // if the lastfontnum equalled fontrefnum, the fLastFontName already points to the proper name.
  // if the numbers didnt equal, the flastfontname field will now point to a built up name

  return fLastFontName;
}

// ------------------------------------------------------------------------
static FontTree *GetDefaultFont(char *theName, int msg)
// 08/10/92 common up the 2 cases, now that GetFNum fails if no default font
// 10/02/94 pass 'printing' to stop the message on reloading a spooled print file
{
  FontTree *ptr = GetAddrOfLeafNode(GetString(kDefaultFontMsg));
  FontTree *substitute;

  if (ptr == NULL)       // 03/10/94 ? || ptr == (FontTree *)(-1))
  {
    Alert(phNoDefaultFontMsg, wr_wimp_EOK);
    FailNoFail();
  }
  if (msg && Alert(msg, wr_wimp_EOK | wr_wimp_ECANCEL | 16, theName) != kYesButton)
    FailNoFail();

  // 19/04/96 return a font name block with a special terminal value, so that original name
  // can be recovered (and thus does not need to be kept in the style until it is saved)
  // Done for Word7 fonts, but generally applicable
  substitute = AllocFontTreeNode(strlen(theName), theName);
  substitute->info.parentPtr = ptr;  // so things like FontName find 'Trinity'
  substitute->info.terminal = 2;     // special value
  return substitute;                 // rather than ptr
}

// -------------------------------------------------------------------------
static bool AlreadyInFontList(TObject null, FontTree *fontNameBlock, char *theName)
{
  // 19/06/96 check for presence of missing fonts (added when the specified font not found)
  if (fontNameBlock->info.terminal == 2 && strcmp(theName, fontNameBlock->fonttext) == 0)
    return TRUE;
  return FALSE;
}

#if defined WORD7 && defined TRACE
// ------------------------------------------------------------------------
void _TTextDocument::FindSubstituteFont(FontTree *ptr, char *data)
{
}
#endif

#ifdef NETWP
#define SetFontKind(a,b) {}
#else
// ------------------------------------------------------------------------
static void SetFontKind(FontTree *ptr, char *fontname)
{
  int handle;
#define Font_ReadEncodingFilename 0x400a5

  if ((ptr->info.backwards & ~kBackwards) == 0)  // unknown whether this is a symbol font
  {
    int isSymbolFont = 2;

    if (FontFind(&handle, fontname, 12*16, 12*16) == NULL)
    {
      wr_os_regset r;
      wr_os_error *err;
      char buffer[512];

      r.r[0] = handle;
      r.r[1] = (int)buffer;
      r.r[2] = 512;
      err = wr_os_swix(Font_ReadEncodingFilename, &r);
      FontLose(handle);
      if (err == NULL && strcmp(strrchr(buffer, '.') + 1, "Latin1") != 0)
      {
        wr_os_filestr f;

        f.action = 17;
        f.name = buffer;
        err = wr_os_file(&f);
        if (err == NULL && f.action == 1)    // encoding exists
          isSymbolFont = 1;
      }
    }
    ptr->info.backwards |= isSymbolFont;
  }
}
#endif

// ------------------------------------------------------------------------
int _TTextDocument::GetFontNumber(char *theName, char *data)
{
  FontTree *ptr;
  int       theFontNum;

  if (theName[0] == 0)      // 04/09/92 CloneStyle calls with empty names!
    return 0;

  ptr = GetAddrOfLeafNode(theName);

  // 19/04/96 check for missing font seen already
  if (ptr == NULL)
    ptr = (FontTree *)fFontList->FirstThat(NULL, (TestObject)AlreadyInFontList, theName);

  if (ptr == NULL)
  {
    ptr = GetDefaultFont(theName, (fPrinterScrap | (fFileType - gMainFileType)) ? 0 :
                             phShouldSubFonts);
                     // returns default font or fails; 19/09/94 [22026] test gMainFileType
#ifdef WORD7
    FindSubstituteFont(ptr, data);
#endif
    if (fPrinterScrap != 1)
      fPrinterScrap = 2;   // 03/10/94 [23000] fPrinterScrap == 2 means font substituted
  }
#ifdef NEVER
  // 17/06/96 Select font now tries to find a plain (regular) font face
  // 04/11/92 ensure we have a terminal name by extending down the first child limb
  while (!ptr->info.terminal)
    ptr = (FontTree *)ptr->info.childPtr;
#endif

  theFontNum = fFontList->GetSameItemNo(TObject(ptr));

  if (theFontNum == 0)
  {
    // the value is currently not in the list so add it to the list
    SetFontKind(ptr, theName);
    fFontList->InsertLast(TObject(ptr));
    theFontNum = fFontList->GetSize();
  }

  return theFontNum;
}

// ------------------------------------------------------------------------
int _TTextDocument::GetFNum(char *theName)
{
  return GetFontNumber(theName, NULL);
}

// -------------------------------------------------------------------------
// the style name & number is passed in, wanting to be associated with its
// position in the font table - if the style name/number is not there then
// add it onto the list

void _TTextDocument::AddStyleFontToTable(char *styleFontname, int styleNumber)
{
#ifdef TRACE
  Assert(styleNumber, 71);
#endif
  // if (fFontList->GetSize() < styleNumber)
  {
    // if the table is not big enough, extend it, initialising to NULL
    for (int n = fFontList->GetSize(); n < styleNumber; n++)
      fFontList->InsertLast(TObject(NULL));
  }

  if (fFontList->At(styleNumber) == NULL)
  {
    // the style ref has not been initialised yet. If we cannot find the addr of
    // a style name then substitute default font.
    Ptr ptr = Ptr(GetAddrOfLeafNode(styleFontname));

    if (ptr == NULL)   // 21/08/95 [26057] new block - remember first unfound font name
    {
      ptr = GetDefaultFont(styleFontname, 0);
                            // fails (if Trinity not found) or returns the default font
      if (fLastFontRefNum == 0)
      {
         strcpyn(fLastFontName, styleFontname, 39);
         fLastFontRefNum = phShouldSubFonts;
      }
      else
         fLastFontRefNum = phMissingFontMsg;  // message for more than 1 missing font
    }
    SetFontKind((FontTree *)ptr, styleFontname);
    fFontList->AtPut(styleNumber, TObject(ptr));  // 21/08/95 [26057] put in default font not -1
  }
}

// -------------------------------------------------------------------------
static void GetAllStylesFromMainView(TObject null, TMainView mainView)
{
  mainView->ForEachHandlerGetStyle();
}

// -------------------------------------------------------------------------
int _TTextDocument::BuildFontRefTable()
{
  CheckInstalledFonts();        // 19/05/91 in case reqd fonts just installed

  // call method to return each style found in the document, which is
  // checked against AddStyleFontToTable method above
  fLastFontRefNum = 0;          // 21/08/95 [26057] use as a flag for missing fonts.
  fMainViewList->Each(NULL, (DoToObject)GetAllStylesFromMainView);

  if (fLastFontRefNum == 0)
    return FALSE;               // 21/08/95 [26057] new test for no substituted fonts

  // if the user does not want to continue then do a failure
  // 21/08/95 [26057] put name of (first found) missing font in alert mssage
  free(GetDefaultFont(fLastFontName, fPrinterScrap ? 0 : fLastFontRefNum));
                                // 08/10/92 fails if no default or user says No
  fLastFontRefNum = 0;          // restore back for proper use
  if (fPrinterScrap != 1)
    fPrinterScrap = 2;          // 03/10/94 [23000] fPrinterScrap == 2 means font substituted
  fNeedsReformat = TRUE;
  return TRUE;  // needs Reformatting
}


// ------------------------------------------------------------------------
_TTextDocument::_TTextDocument(OSType itsFileType) : (itsFileType)
{
  FailInfo fi;

#ifndef ZERO_OBJ
  TStructTypes index;
  int n;

  fStyleSheet = NULL;
  fBody = 0;
  fSelection = NULL;
  fNewSelection = NULL;
  fMainViewList = NULL;
  fSelectionChanged = FALSE;
  fTextHandler = NULL;
  fFontList = NULL;
  fLastFontRefNum = 0;
  fLastFontName = NULL;
  fNeedsReformat = FALSE;

  for (n = kMinBodyStyles; n <= kMaxLevels; ++n)
    fBodyStyles[n] = 0;
  for (index = kTextStruct; index <= kMathStyleStruct; index++)
    fStructureHandlers[index] = NULL;

  fPictureHandler = NULL;
  fLeftRightHdr = FALSE;
  fLeftRightFtr = FALSE;
  fLeftHeader = 0;
  fRightHeader = 0;
  fLeftFooter = 0;
  fRightFooter = 0;
  fLRHeaderFooterChg = FALSE;
  fTimeFormat = hm24;
  fDateFormat = shortDate;
  fCustomDate = NULL;
  fInteractive = FALSE;
  fPurging = FALSE;
  fStatistics = {0, 0, 0};
  fItalicStyle = 0;      // 11/01/92
  fGreekStyle = 0;       // 11/01/92
  fSymbolsStyle = 0;     // 11/01/92
  fAlignList = NULL;            // 24/03/92
  fLastStructCmdNum = 0;        // 20/06/93 [20949]
// MMerge init 13/5/92
  fMergeDoc = NULL;
  fMergeActive = FALSE;
  fMergeIndex = 0;
  fMergeTitles = NULL;
  fMergeFileName = NULL;
// end MMerge
  fControlBlockList = NULL;    // Talk/Utility data
  fFirstFootnote = 0;
#endif
  fHeadings = 1;    // MMerge 13/05/92
  fVersion = kCurrentVersion;   // 18/06/91 original creation version
#ifndef TABLES
  fTimeFormat = hm12;                                // 04/03/94 use 12hr StartWrite
  fDateFormat = customDate;
#endif
  fAlwaysUpdate = TRUE;
  fNumLevels = 0 + kBaseBodyStyle; // 10/02/92 two extra for footnotes; 6;

  CatchFailures(&fi);
#ifndef TABLES
  fCustomDate = NewString(GetRsrc(customDate, 'd'));  // 04/03/94 use d3 for StartWrite
#endif
  fMainViewList = NewList();
  fFontList = NewList();
  fStyleSheet = new _TStyleSheet(this);
  fLastFontName = (char *)NewCheckedHandle(40);
                   // leave enough space to fit in the font name
  Success(&fi);
  return;

// ********** exception handler *****
Rescue:
  _TTextDocument::Free();
  ContinueFailure(&fi);
}


// -------------------------------------------------------------------------
static void ReleaseDefaultFonts(TObject null, FontTree *fontNameBlock)
{
  // 19/06/96 release the substitute font info blocks (added when the specified font not found)
  if (fontNameBlock->info.terminal == 2)
  {
#ifdef WORD7
    free(fontNameBlock->info.brotherPtr);
#endif
    free(fontNameBlock);
  }
}


// ------------------------------------------------------------------------
void _TTextDocument::FreeSubfields()
// 19/05/92 for the common code in Free & FreeData
{
  ClearObject(fSelection);
  ClearObject(fNewSelection);
  ClearHandle(&fCustomDate);
  ClearObject(fMergeDoc);
  ClearHandle(&fMergeTitles);
  if (gErrorParm3 != fMergeFileName)
    DisposIfHandle(fMergeFileName);   // 02/11/92 temp fudge - need to free later
  fMergeFileName = NULL;
  if (fControlBlockList != NULL)
    fControlBlockList->FreeList();     // Talk/Utility data
  fControlBlockList = NULL;            // 08/11/95 reset for Revert
  fFontList->Each(NULL, (DoToObject)ReleaseDefaultFonts);   // 19/06/96
}


// ------------------------------------------------------------------------
void _TTextDocument::Free()
{
  DisposIfHandle(fLastFontName);
  ClearObject(fMainViewList);  // so main views do not try to remove themselves
  FreeIfObject(fStyleSheet);
  FreeSubfields();     // 26/05/92
  FreeIfObject(fFontList);
  ClearObject(fAlignList);
  FreeIfObject(fTextHandler);           // 01/04/92 moved down
  _TDocument::Free();
}


// ------------------------------------------------------------------------
static void FreeIt(TObject null, TMainView view)
{
   FreeIfObject(view);
}


void _TTextDocument::FreeData()
{
  int n;

  fMainViewList->Each(NULL, (DoToObject)FreeIt);
  ReplaceObject(fStyleSheet, new _TStyleSheet(this));

  FreeSubfields();     // 26/05/92
  fBody = 0;
  fSelectionChanged = FALSE;
  fNumLevels = 0 + kBaseBodyStyle;  // 10/02/92 2 extra for footnotes; 6;  // 30/05/90
  fFontList->DeleteAll();
  for (n = kMinBodyStyles; n <= kMaxLevels; n++)
    fBodyStyles[n] = 0;
  fAlignList->FreeEntries();        // 26/03/92
#ifdef MATHS
  // 22/09/92 ensure 3 maths styles are recreated after Revert to empty
  fItalicStyle = 0;
  fGreekStyle = 0;
  fSymbolsStyle = 0;
#endif

  _TDocument::FreeData();
}

#ifdef DRAGDROP
// ------------------------------------------------------------------------
int _TTextDocument::GetSelectionFlags()
{
  TSelection selection = GetNewSelection();
  TCursorNode anchor = selection->GetAnchorOwner();
  TCursorNode activeEnd = selection->GetActiveOwner();
  if (anchor)
  {
    TCurrency currency = anchor->fCurrency;

    return GetStructureReadOnly(currency)->FindWhatsSelected(currency, anchor, activeEnd);
                         // 12/10/94 from RW
  }
  return 0;
}
#endif

// ------------------------------------------------------------------------
void _TTextDocument::InstallTitle(TWindow aWindow, int percentage)
{
  _TDocument::InstallTitle(aWindow, ActiveMainView()->ZoomInt(100));
}


// -------------------------------------------------------------------------
TStyleFormat _TTextDocument::GetChanges()
// 26/03/93 moved from UTextComm
{
  TRulerDef changes;
  TSelection selection;

  CommitLastDocCommand();        // 16/04/93 from CommitLastCommand
  selection = GetSelection(TRUE);
  changes = GetCurrentChanges(FALSE);
       // 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted
  changes->fDefined &= ~kEmphasis;          // 04/07/91
  return TStyleFormat(changes);
}

// -------------------------------------------------------------------------
TCommand _TTextDocument::MakeStyleCommand(TStyleSetter setter, int par1)
{
  TStyleFormat theStyle;
  CmdNumber cmd;

  theStyle = GetChanges();
  cmd = setter(theStyle, par1);
  if (cmd == cFontChange)
    strcpy(theStyle->fFontName, GetFName(theStyle->fTextFont));     // get rid of this!!
  return new _TStyleCommand(this, cmd, theStyle);
}

#ifdef TABLES
// -------------------------------------------------------------------------
static CmdNumber MergeEmph(TStyleFormat theStyle, int emphStyle)
{
  theStyle->MergeEmphasisAttrs(TStyleFormat(emphStyle), FALSE);
  theStyle->fDefined |= kEmphasis;  // 04/07/91 | KEmph
  return cStyleChange;
}

// -------------------------------------------------------------------------
TCurrency _TTextDocument::GetStyleFromMenu(CmdNumber cmd, bool &emph)
                               // int menuNumber, int item)
// 20/06/93 [20949] common up DoStyleChange and structure style side menu
// 15/02/94 returns emph, so not dependant on which menu selected
{
  DefName name;
  TStyleInfo info;

  CmdToName(cmd, name);          // 15/02/94 use cmd rather than menuNumber and item
  fStyleSheet->FindStyleInfo(name, info);
  emph = info.fEmphasis;         // 15/02/94 new return to avoid testing menu number
  return info.fDocCurrency;
}

// -------------------------------------------------------------------------
TCommand _TTextDocument::DoStyleChange(CmdNumber cmd) // int menuNumber, int item)
{
  TStyleFormat emphStyle;
  bool emph;
  TCurrency styleCurrency = GetStyleFromMenu(cmd, emph); // menuNumber, item);

  if (!emph)               // 15/02/94 menuNumber == cmSelStyle)
    return new _TSelStyleCommand(this, styleCurrency);

  // 28/01/91 new bit for applying emphasis styles
  emphStyle = ActiveMainView()->GetStyleReadOnly(styleCurrency);
  return MakeStyleCommand(MergeEmph, (int)emphStyle);

// 04/04/93  theStyle = GetChanges();
// 04/04/93  theStyle->MergeEmphasisAttrs(emphStyle, FALSE);
// 04/04/93  theStyle->fDefined |= kEmphasis;  // 04/07/91 | KEmph
// 04/04/93  return new _TStyleCommand(this, cStyleChange, theStyle);
}
#endif

// -------------------------------------------------------------------------
static CmdNumber DoAlignChange(TStyleFormat theStyle, int alignment)
{
  return theStyle->ChangeAlign(alignment);
}

#ifndef TABLES
// ------------------------------------------------------------------------
static CmdNumber DoBorderOne(TStyleFormat theStyle, int currAdorn)
{
  if ((theStyle->fDefined & kHasAdornment) != 0)
  {
    theStyle->fDefined |= (kOwnAdornment | kHasAdornment);
    if (currAdorn & adnShadow)    // 05/05/94 currAdorn for theStyle->fOwnAdornment
      theStyle->fOwnAdornment = 0;
    else
      theStyle->fOwnAdornment =
               adnShadow | adnLineTop | adnLineLeft | adnLineBottom | adnLineRight;
    // theStyle->fOwnRuleType.fPen = kOnePtPen;
    // theStyle->fOwnRuleType.fRule = k1Thn;
    // theStyle->fOwnRuleType.fShort = FALSE;
    theStyle->fOwnRuleType = gDefaultPen;
  }
  else
  {
    theStyle->fDefined |= kAdornment;
    if (currAdorn & adnShadow)    // 05/05/94 currAdorn for theStyle->fAdornment
      theStyle->fAdornment = 0;
    else
      theStyle->fAdornment =
               adnShadow | adnLineTop | adnLineLeft | adnLineBottom | adnLineRight;
    // theStyle->fRuleType.fPen = kOnePtPen;
    // theStyle->fRuleType.fRule = k1Thn;
    // theStyle->fRuleType.fShort = FALSE;
    theStyle->fRuleType = gDefaultPen;
  }
  return cBorderOne;
}
#endif


// -------------------------------------------------------------------------
TCommand _TTextDocument::DoKeyCommand(int ch, EventInfo &info)
{
  if (ch >= 0x180
#if TALK == 0
      && ch != chSpeak
#endif
     )               // an arrow key, F6 (if SPEECH) or F7
  {
    // 06/04/94 Combined from picture & textevent DoKeyCommands
#if TALK == 1 && !defined NETWP
    if (ch == chSpeak)
      SendKeyToUtil(ch);
    else
#endif
    {
      if (ch == chCaseSwap) // 23/6/92
      {
        CommitLastDocCommand();        // 16/04/93 from CommitLastCommand
        GetSelection(TRUE);
      }
      else
      {
        CloneSelection();
      }
      SetTextHandler();
      info.affectsMenus = FALSE;                      // 20/06/91
      GetNewSelection()->MoveCursor(ch, info, ActiveMainView());
      DoneTyping();
      EndInteractive();
    }
    return gNoChanges;
  }
  return _TDocument::DoKeyCommand(ch, info);
}

// -------------------------------------------------------------------------
TCommand _TTextDocument::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
// 04/04/93 Common UPicture & TextComm commands done here
  switch (aCmdNumber)
  {
  case cCut:
  case cCopy:
  case cClear:                     // 10/07/90 new
    return new _TCutCopyCommand(this, aCmdNumber);

  case cPaste:
    {
      TDocument clipDoc = RequestClipDocument(); // [20811] global c/b

      return (clipDoc == NULL ? gNoChanges :  // no clip doc, or need to wait for it
#ifdef DRAGDROP
        gApplication->MakeMoveCommand(GetNewSelection(), clipDoc, kPasteCommand)
#else
        new _TPasteCommand(this, TTextDocument(clipDoc), kPasteCommand)
#endif
      );
    }

#ifdef TABLES
  case cEndStruct:
      if (CmdEnabled(cEndStruct))
         EndStructure();
      return gNoChanges;
#endif

#ifdef TABLES
  case cAlignForce:    // [26067] disabled for all except text
    aCmdNumber = cAlignLeft + kAlignForce;
#endif
  case cAlignLeft:
  case cAlignRight:
  case cAlignCentre:
  case cFullJustify:   // disabled for pictures
    {
      bool enabled;
      bool ticked;

      GetMenuState(aCmdNumber, enabled, ticked);
      return MakeStyleCommand(DoAlignChange, ticked ? kAlignAuto : aCmdNumber - cAlignLeft);
    }

#ifndef TABLES
  case cBorderOne:
    {
      // 05/05/94 [21722] pass the current style, so borders removed if already on
      TStyleFormat currStyle = ActiveMainView()->fCurrentStyle;

      return MakeStyleCommand(DoBorderOne, (currStyle->fDefined & kHasAdornment) != 0 ?
                                    currStyle->fOwnAdornment : currStyle->fAdornment);
    }
#endif
#ifdef NETWP
  case cStartKeySelection:
    {
      TSelection sel = GetNewSelection();

      sel->fKeyExtend = !sel->fKeyExtend;
    }
    break;
#endif
#if SIDEBAR == 1
  case cSizeDialog:    // StartWrite kids size dialogue
#endif
  case cBorders:
#ifdef TABLES
  case cTypeSpec:
  case cSpacing:
#endif
     // 09/05/94 [21727]     CommitLastDocCommand();
#ifdef TABLES
  case cChangeStyle:
#endif
      CommitLastDocCommand();  // 09/05/94 [21727] commit before resetting fSelection below
      GetSelection(TRUE);       // 16/04/91 - but was not done when picture selected?
      ChangeStyleAttrs(aCmdNumber);
      return gNoChanges;  // cmd has been done in PoseModally
  }
  return _TDocument::DoMenuCommand(info, aCmdNumber);
}


// -------------------------------------------------------------------------
// MMerge 13/5/92
bool _TTextDocument::MergeActive()
{
  return fMergeActive;
}

// ------------------------------------------------------------------------
static void DoPurgeFmt(TObject null, TMainView view, TCurrency itsCurrency)
{
  TRecordHandler recHandler = view->fFormatHandlers[Curr_fType(itsCurrency)];

//  recHandler->PurgeRecord((unsigned int)itsCurrency.fValue >> 16);
  recHandler->PurgeRecord(Curr_fRecnum(itsCurrency));
}


// ------------------------------------------------------------------------
void _TTextDocument::PurgeCurrency(TCurrency itsCurrency)
{
  if (fPurging)
  {
    TRecordHandler recHandler = fStructureHandlers[Curr_fType(itsCurrency)];

    recHandler->PurgeRecord(Curr_fRecnum(itsCurrency));
    fMainViewList->Each(NULL, (DoToObject)DoPurgeFmt, itsCurrency);
  }
}

// ------------------------------------------------------------------------
bool _TTextDocument::LockCurrency(TCurrency currency, bool state)
{
  TRecordHandler recHandler = fStructureHandlers[Curr_fType(currency)];

  return recHandler->SetRecordLock(Curr_fRecnum(currency), state);
}


// ------------------------------------------------------------------------
void _TTextDocument::PurgePicture(int recnum, bool setPurging)
{
  if (setPurging || fPurging)      // 15/07/91 extra param setPurging
    fPictureHandler->PurgeRecord(recnum);
}

// =========================== TAssocList ==============================
_TAssocList::_TAssocList() : (sizeof(void *))
{
}


#define kRecNumSize 2
// ------------------------------------------------------------------------
void _TAssocList::DoRead(int aRefNum, long remainder, int version)
{
  long transfer = sizeof(int);
  int totalEntries;
  int totalSize = 0;

  for(;;)
  {
    SetPermHandleSize(&fPtrToArray, totalSize + transfer);
    FRead(aRefNum, transfer, (char *)fPtrToArray + totalSize);
    totalSize += transfer;
    memcpy(&totalEntries, (char *)fPtrToArray + totalSize - sizeof(int), sizeof(int));
    if (totalEntries == 0)
      return;
    transfer = totalEntries * kRecNumSize + sizeof(int);
  }
}


// ------------------------------------------------------------------------
void _TAssocList::DoWrite(int aRefNum, long remainder)
{
  if (fSize == 0)
    FWrite(aRefNum, sizeof(int), &gZeroRect);
  else
    FWrite(aRefNum, GetHandleSize(fPtrToArray), &fPtrToArray);
}


// ------------------------------------------------------------------------
long _TAssocList::DoNeedDiskSpace(long dataForkBytes)
{
  return (fSize == 0 ? sizeof(int) : GetHandleSize(fPtrToArray));
}


// ------------------------------------------------------------------------
void _TAssocList::DoReadArrayPart(int aRefNum, int version)
{
}


// ------------------------------------------------------------------------
void _TAssocList::DoWriteArrayPart(int aRefNum)
{
}


// ------------------------------------------------------------------------
void _TAssocList::Free(void)
{
  FreeEntries();
  _TArray::Free();
}


// ------------------------------------------------------------------------
void _TAssocList::ClearEntry(void **entry)
{
  DisposIfHandle(*entry);
}


// ------------------------------------------------------------------------
void _TAssocList::FreeEntries(void)
{
  Each(this, (DoToItem)_TAssocList::ClearEntry);
  ReduceSize(0);
}


// ------------------------------------------------------------------------
#ifdef MATHS
// 24/03/92 overridden
void _TAssocList::CheckAlign(TCurrency currency)
{
}

// ------------------------------------------------------------------------
void _TAssocList::DrawChanges()
{
}
#endif

// ------------------------------------------------------------------------
_TStyleSheet::_TStyleSheet(TTextDocument document) : (sizeof(TStyleInfo))
{
  fDocument = document;
}


// ------------------------------------------------------------------------
void _TStyleSheet::DoWrite(int aRefNum, long remainder)
{
  _TArray::DoWrite(aRefNum, sizeof(_TArray));  // do not save fDocument fld
}


// ------------------------------------------------------------------------
void _TStyleSheet::DoRead(int aRefNum, long remainder, int version)
{
  _TArray::DoRead(aRefNum, sizeof(_TArray), version);
}

// ------------------------------------------------------------------------
void _TStyleSheet::DoReadArrayPart(int aRefNum, int version)
{
  int count = fSize * sizeof(TStyleInfo);

  SetPermHandleSize(&fPtrToArray, count);

#ifdef VERS0
  if (version == 0)
    FRead(aRefNum, count, fPtrToArray);
  else
#endif
  {
    char buffer[7];
    char *ptr = (char *)fPtrToArray;

    for (int i = 0; i < fSize; i++)
    {
      PStyleInfo styleInfo = PStyleInfo(ptr);

      memset(ptr, 0, sizeof(TStyleInfo));
      FRead(aRefNum, 7, buffer);
      UnpackRecord(0x155, "\x01\x03\x01\x03\x01\x7\x01\x01\x02", buffer + 1,
                                                   NULL, &styleInfo->fType);
      FRead(aRefNum, buffer[0], styleInfo->fName);
      if (fDocument->fStructureHandlers[Curr_fType(styleInfo->fDocCurrency)])
        ptr += sizeof(TStyleInfo);   // 20/05/92 delete the entry if no rec handler
    }
    count = ptr - (char *)fPtrToArray;
    fSize = count / sizeof(TStyleInfo);
    SetPermHandleSize(&fPtrToArray, count);
  }
}


// ------------------------------------------------------------------------
void _TStyleSheet::DoWriteArrayPart(int aRefNum)
{
  char buffer[7 + sizeof(DefName)];

  for (int i = 0; i < fSize; i++)
  {
    PStyleInfo styleInfo = PStyleInfo(fPtrToArray) + i;

    buffer[0] = strlen(styleInfo->fName);
    PackRecord(0x155, "\x01\x03\x01\x03\x01\x7\x01\x01\x02",
                                          &styleInfo->fType, buffer + 1);
    strcpy(buffer + 7, styleInfo->fName);
    FWrite(aRefNum, 7 + buffer[0], buffer);

    fDocument->SetUsedStyles(styleInfo->fDocCurrency);
  }
}


// ------------------------------------------------------------------------
long _TStyleSheet::DoNeedDiskSpace(long dataForkBytes)
{
  int needed = sizeof(_TArray);

  for (int i = 0; i < fSize; i++)
  {
    PStyleInfo styleInfo = PStyleInfo(fPtrToArray) + i;

    needed += strlen(styleInfo->fName) + 7 - sizeof(TStyleInfo);
  }
  return _TArray::DoNeedDiskSpace(needed);
}


// ------------------------------------------------------------------------
static bool TestStyle2(TObject null, PStyleInfo info, char *name, int curr)
{
  if (name[0] == 0)
    return info->fDocCurrency == curr;
  
  return (strcmp(name, info->fName) == 0);
}


// ------------------------------------------------------------------------
bool _TStyleSheet::HasStyle(PStyleInfo theInfo, TLevelInfo *levelInfo)
{
  return (theInfo->fDocCurrency == levelInfo->fStyle);
}

// ------------------------------------------------------------------------
int _TStyleSheet::FindCmdKeySet(TStyleTypes kind, bool emphasis)
{
  int keyMask = 0;
  PStyleInfo info;
  PStyleInfo limit;

  for (info = PStyleInfo(fPtrToArray), limit = info + fSize; info < limit; info++)
  {
    if (kind == info->fType
            // || (info->fType == kDocument && (kind == kHeader || kind == kFooter))
             && emphasis == info->fEmphasis && info->fCmdKey > 0)
      keyMask |= 1 << (info->fCmdKey - 1);
  }
  return keyMask;
}

// ------------------------------------------------------------------------
int _TStyleSheet::CountStyles(TStyleTypes kind, bool emphasis)
{
  int count = 0;
  PStyleInfo info;
  PStyleInfo limit;

  for (info = PStyleInfo(fPtrToArray), limit = info + fSize; info < limit; info++)
  {
    if (kind == info->fType && emphasis == info->fEmphasis)
      count++;
  }
  return count;
}

#ifdef TABLES
// ------------------------------------------------------------------------
void _TStyleSheet::TestStyle(PStyleInfo styleInfo, MenuHandle *emphMenu, MenuHandle *styleMenu, TStyleTypes kind, TCurrency styleCurr)
{
  if (styleInfo->fType == kind ||
    (styleInfo->fType == kDocument && (kind == kHeader || kind == kFooter))
#ifdef MATHS
       || (kind == kMaths && styleInfo->fEmphasis)  // 11/01/92
#endif
     )
  {
    MenuHandle *theMenu = NULL;
    int theKey = 0;
    int theQual = ctrl_key | fn_key;
    int entry = 0;

    if (styleInfo->fEmphasis)
    {
      theMenu = emphMenu;

#ifdef MATHS
      // 28/01/92 set shift-F6,7,8 for built in emphasis
      for (int i = 0; i < 3; i++)
        if (styleInfo->fDocCurrency == (&fDocument->fItalicStyle)[i])
        {
          if (i == 0)    // do not tick italic here - it is not really a style
            return;
          if (theMenu == GetResMenu(cmStyle)) // 16/02/94 add only a tick if not doing the pop-up
          {
            int anItem;

            CmdToMenuItem(cPlain, anItem);
            entry = anItem + i + 2;
            goto fon;
          }
          // add and put on the command key if generating the tool bar pop-up
          theKey = i + 6;
          theQual = shift_key | fn_key;
          goto fin;
        }
#endif

      // 02/07/92 for old docs which did not use -ve fCmdKey value
      if (styleInfo->fCmdKey < 128)     // because held in a byte
      {
#ifdef MATHS
        if (styleInfo->fCmdKey <= 2)    // 05/07/93 from 3, + 5 to make room for Bold
          theKey = styleInfo->fCmdKey + 6;  // ctrl-F7 - F8
#else
        if (styleInfo->fCmdKey <= 3)
          theKey = styleInfo->fCmdKey + 5;  // ctrl-F6 - F8
#endif
      }
      else                    // 02/07/92 zero or 'negative'
      {
        theKey = (-styleInfo->fCmdKey) & 0xff;
        theQual = shift_key | fn_key;
      }
    }
    else if (styleInfo->fName[0] != 0) // 07/06/90
    {
      theMenu = styleMenu;
      if (styleInfo->fCmdKey <= 3)
        theKey = styleInfo->fCmdKey + 8;  // F9 - F11
    }
#ifdef MATHS
fin:
#endif
    if (theMenu != NULL)
    {
      entry = AppendMenuItem(theMenu, styleInfo->fName);  // index of just added entry
      // 07/09/94 use return from AppendMenuItem: entry = CountMItems(*theMenu);
      if (theKey != 0 && styleMenu != GetResMenu(cmStructureStyle)) // 16/02/94 change test
                 // emphMenu != NULL)         // [20949] emphMenu is NULL for side menu
        SetMenuKey(*theMenu, entry, theKey, theQual);
    }
#ifdef MATHS
fon:
#endif
    if (theMenu != NULL)
      CheckItem(*theMenu, entry, styleInfo->fDocCurrency == styleCurr); // 07/05/92
  }
}
#endif

#ifdef TABLES
// ------------------------------------------------------------------------
void _TStyleSheet::SetUpStyleMenu(TSelection selection, TStyleTypes kind)
{
#ifdef NETWP
//  TWindow window = selection->fDocument->ActiveMainView()->GetWindow();

//  if (fDocument->fTitle)
//    window->WriteText(gIDdrag, fDocument->fTitle);
#else
  // 22/07/92 passed in: TStyleTypes kind;
  TLevelInfo levelInfo;
  Str255 styleName;
  int anItem;
  TCurrency styleCurr;
  MenuHandle *emphMenu;

  styleCurr = 0;

  emphMenu = GetResMenu(cmStyle);
  CmdToMenuItem(cPlain, anItem);
#ifdef MATHS
  DelMenuItems(emphMenu, anItem + 5);   // 03/07/93
#else
  DelMenuItems(emphMenu, anItem + 1);
#endif

  // 07/05/92 set up menu moved down so we can tick if necessary

  if (!selection->fEndStructure)
  {
    // scan through the level info building a style name for the button bar
    int sz;

#ifdef MATHS
    if (kind == kMaths || kind == kText)  // 16/02/94 test inside endstructure
    {
      // 16/02/94 do not enable built-in emphasis unless maths or text selected
      EnableItem(*emphMenu, anItem + 3);
      EnableItem(*emphMenu, anItem + 4);
    }
#endif
    sz = selection->GetSize();

    for (int index = selection->fPopup; index <= sz; index++)
    {
      char *textToSet = NULL;
      bool isEmphasis;
      TStyleFormat emphStyle = NULL;

      selection->Get(index, &levelInfo);
      // if (index == selection->fPopup && levelInfo.fPart != 1)
      //  allSelected = FALSE;

      if (levelInfo.fPart < 0)
      {
        // 20/01/94 [21352] Get buttons and menus set for deferred styles
        emphStyle = fDocument->fTextHandler->fStyleChanges;
        if (emphStyle != NULL && fDocument->fTextHandler->fStyleCmd != cPlain)
        {
          // simulate an emphasis entry for a deferred style
          fDocument->ActiveMainView()->
                         FindStyle(emphStyle, kTextStyleStruct, levelInfo.fStyle);
          levelInfo.fChanges = 0;
          isEmphasis = TRUE;
        }
        else
          continue;    // if not an emphasis, and fPart -ve, go round again
      }
      else
      {
#ifdef MATHS
        isEmphasis = ((levelInfo.fKind == kText || // 11/01/92 test selected maths term parts
         (levelInfo.fKind == kMaths && index == selection->fPopup)) && levelInfo.fPart >= 2);
#else
        isEmphasis = (levelInfo.fKind == kText && levelInfo.fPart == 2);
#endif
      }
      if (levelInfo.fKind >= kWhiteSpace && levelInfo.fKind <= kColBreak ||
                   levelInfo.fKind == kPageFiller)     // 05/04/91
      {
        textToSet = styleName;
        styleName[0] = 0;
      }
      else if ((levelInfo.fStyle != 0 && levelInfo.fPart == 1) || isEmphasis)
      {
        int styleIndex = FirstThat(this, (TestItem)_TStyleSheet::HasStyle, &levelInfo);
        bool addStar = FALSE;

        if (styleIndex > 0)
        {
          TStyleInfo styleInfo;

          Get(styleIndex, &styleInfo);
          strcpy255(styleName, styleInfo.fName);

          if (levelInfo.fChanges != 0) // 07/05/92 if (hasChanges)
            addStar = TRUE;       // strcat255(styleName, " *");
          textToSet = styleName;
        }
        else if (isEmphasis)
        {
          styleName[0] = 0;
          if (levelInfo.fChanges != 0)
            emphStyle = fDocument->ActiveMainView()->
                                                    GetStyleReadOnly(levelInfo.fChanges);
          if (emphStyle)
          {
            // 24/04/93 [20834] output style message rather than "Untitled"
            emphStyle->GetEmphasisDescription(styleName);
            addStar = (emphStyle->fDefined & ~(kFace | kEmphasis));   // 21/01/94 [21354]
          }

          if (styleName[0] != 0)
            textToSet = styleName;
          else
            textToSet = GetString(kUntitledStr);  // not a face change
        }
        if (addStar)
          strcat255(styleName, " *");
      }
      if (textToSet != NULL)
      {
        TWindow window = selection->fDocument->ActiveMainView()->GetWindow();
        // NB!!! could be wrong window. It should be one under menu button!!!

        if (levelInfo.fChanges == 0) 
          styleCurr = levelInfo.fStyle;  // 07/05/92 set styleCurr
        window->WriteText(gIDdrag, textToSet);
        break;
      }
    }
    Each(this, (DoToItem)_TStyleSheet::TestStyle, emphMenu, NULL /* styleMenu - dynamic */,
                                                      kind, styleCurr);
                             // 07/05/92 pass styleCurr, 13/06/93 [20937] not if endstruct
  }
  else
    styleCurr = -1;                  // 16/02/94 entries should be dimmed
  fDocument->fCurrentKind = kind;    // 16/02/94 for setting up dynamic style menu
  fDocument->fCurrentStyleCurr = styleCurr; // 16/02/94 for ticking dynamic style menu

  fDocument->SetupDynamicMenu(cBarChangeStyle, cmSelStyle, TRUE);
          // 15/03/94 set up an enable menu so ^F9, etc get pickedep & pass anything but
          // cSelStyleName for the command, so emphasis styles are added, so that adjust
          // clicks on the button bar menu correspond to the menu
#endif
  }
#endif


// ------------------------------------------------------------------------
void _TStyleSheet::AddStyle(char *name, TStyleTypes kind, bool emphasis,
                                       TCurrency currency, int cmdKey)
{
  TStyleInfo styleInfo;
  unsigned int cmdKeys;
  int newCmdKey;

  strcpyn(styleInfo.fName, name, defNameLen);  // 17/05/96 trunc long Word7 names
  styleInfo.fType = kind;
  styleInfo.fEmphasis = emphasis;
  styleInfo.fPadCurrency = 0;
  styleInfo.fDocCurrency = currency;
  if (cmdKey <= 0)    // 28/01/92 do not allocate key for built-in emphasis
  {
#ifdef WORD7
    if (cmdKey < 0)
      styleInfo.fPadCurrency = 1;  // use spare field as a flag to indicate Word7 sprms applied
#endif
    
    cmdKeys = FindCmdKeySet(kind, emphasis); 
    // 17/05/96 [27028] allocate function key number 33 to 33rd onwards, not zero (gives ^F8)
    for (newCmdKey = 1; Odd(cmdKeys); cmdKeys >>= 1, newCmdKey++) {}
    //if (cmdKeys != 0xffffffff)  // ie there is at least one spare
    //  do
    //  {
    //  } while (cmdKeys & (1 << (newCmdKey++)));
    styleInfo.fCmdKey = newCmdKey;
  }
  else
    styleInfo.fCmdKey = -cmdKey;

  InsertLast(&styleInfo);         // 31/01/91 ? from Insert
}


// ------------------------------------------------------------------------
void _TStyleSheet::ChangeStyleInfo(char* name, TStyleInfo &info)
{
  int index = FirstThat(this, (TestItem)TestStyle2, name,
                                  info.fDocCurrency);  // 26/01/91

  if (index == 0)
  {
    InsertLast(&info);
  }
  else if (info.fName[0] == 0)
  {
    Delete(index);
  }
  else
  {
    AtPut(index, &info);
  }
}


// ------------------------------------------------------------------------
int _TStyleSheet::FindStyleInfo(char* name, TStyleInfo &info)
{
  int index;

  index = FirstThat(this, (TestItem)TestStyle2, name,
                                  info.fDocCurrency);  // 26/01/91
  if (index == 0)
    info.fName[0] = 0;
  else
    Get(index, &info);
  return index;
}


// ------------------------------------------------------------------------
static void DoPurgeFormats(TObject null, TMainView view)
{
   view->Purge();
}

static void DoPurge(TObject null, TRecordIndex recNum, TRecordHandler handler)
{
  handler->PurgeRecord(recNum);
}

void _TTextDocument::Purge()
{
  fPurging = TRUE;          // 11/03/91 needs CatchFailures!!!
  fStructureHandlers[kTextStruct]->ForAllRecordsDo(NULL, (DoToRecord)DoPurge);
  fPictureHandler->ForAllRecordsDo(NULL, (DoToRecord)DoPurge);
#ifdef INDEX
  fStructureHandlers[kIndexRefStruct]->ForAllRecordsDo(NULL, (DoToRecord)DoPurge);
#endif
  fMainViewList->Each(NULL, (DoToObject)DoPurgeFormats);
  fPurging = FALSE;
}


// ------------------------------------------------------------------------
void _TTextDocument::DoSetUsed(int part, Rect &custom, TCurrency partStyle)
{
  GetStyleReadWrite(partStyle)->fUsed = TRUE;
}


// ------------------------------------------------------------------------
void _TTextDocument::SetUsedStyles(TCurrency currency)
{
  FailInfo fi;

  if (fStructureHandlers[Curr_fType(currency)])     // 20/05/92 TW => EW => Save
  {  
    CatchFailures(&fi);
    if (!fPurging && currency != 0)
    {
      TStyleStructure style = GetStyleReadWrite(currency);

      style->fUsed = TRUE;
      style->ForAllPartsDo(this, (DoToStyles)_TTextDocument::DoSetUsed,
                                              NULL, NULL, NULL);
    }
    Success(&fi);
  }
  return;

Rescue:
  gMarkingFailed = TRUE;    // set flag to stop deleting styles & continue
}

// ------------------------------------------------------------------------
static Size GetHandleSpace(Handle h)
{
  return (h == NULL ? 0 : GetHandleSize(h) - 1); // 17/05/92 avoid saving 0 byte
}

// ------------------------------------------------------------------------
static void ComputeSpace(TObject null, TMainView view, long* dataForkBytes)
{
  view->DoNeedDiskSpace(*dataForkBytes);
}

// ------------------------------------------------------------------------
// Talk/Utility data
static void DoWriteCB(TTextDocument doc, TControlBlock controlBlock, int aRefNum)
{
  controlBlock->DoWrite(aRefNum);
}

// ------------------------------------------------------------------------
static void DoNeedCB(TTextDocument doc, TControlBlock controlBlock, long *needed)
{
  controlBlock->DoNeedDiskSpace(needed);
}

// ------------------------------------------------------------------------
void _TTextDocument::DoNeedDiskSpace(long &dataForkBytes)
{
  TStructTypes index;
  TRecordHandler nextHandler;

  dataForkBytes += sizeof(TDocRecord) + 
                       GetHandleSpace(fCustomDate) +
                       GetHandleSpace(fMergeTitles) +  // 17/05/92 MailMerge
                       GetHandleSpace(fMergeFileName) +  // 17/05/92 MailMerge
              fSelection->_TSelection::DoNeedDiskSpace(0 /* not used */);

  if (fAlignList != NULL)
    dataForkBytes += fAlignList->NeededDiskSpace();  // 20/08/92

  if (fStyleSheet != NULL)
    dataForkBytes += fStyleSheet->NeededDiskSpace();

  for (index = kTextStruct; index <= kMathStyleStruct; index++)
  {
    nextHandler = fStructureHandlers[index];
    if (nextHandler != NULL)
      dataForkBytes += nextHandler->DiscSpaceNeeded() + nextHandler->GetIndexSize();
  }
  
  // 02/05/90 - pic bit new
  if (fPictureHandler != NULL)
    dataForkBytes += fPictureHandler->DiscSpaceNeeded() + fPictureHandler->GetIndexSize();

  fMainViewList->Each(NULL, (DoToObject)ComputeSpace, &dataForkBytes);

  if (fControlBlockList != NULL)
    fControlBlockList->Each(this, (DoToObject)DoNeedCB, &dataForkBytes);
                                                 // Talk/Utility data
  _TDocument::DoNeedDiskSpace(dataForkBytes);
}


// ------------------------------------------------------------------------
static void SaveFormatIndex(TObject null, TMainView view, int aRefNum,
                            long* position)
{
  view->DoWriteIndex(aRefNum, *position);
}


// ------------------------------------------------------------------------
static void SaveFmtRecord(TObject ignore, TRecordHandler fmtHandler, TRecordIndex recNum,
                                                              int aRefNum)
{
  fmtHandler->SaveRecord(recNum, aRefNum, TRUE);
}

// ------------------------------------------------------------------------
static void SaveRHRecord(TObject ignore, TRecordIndex recNum, TRecordHandler handler,
                                                              int aRefNum)
{
  handler->SaveRecord(recNum, aRefNum, TRUE);

  if (handler->fSlaves != NULL)
    handler->fSlaves->Each(ignore, (DoToObject)SaveFmtRecord, recNum, aRefNum);
}

// ------------------------------------------------------------------------
static long SaveRHData(TRecordHandler recHandler, long &position, int aRefNum)
{
  long oldPos;

  if (recHandler == NULL)
    return 0;        // 19/05/92 return 0 if no handler not current position

  oldPos = position;
  position += recHandler->GetIndexSize();
  SetEOF(aRefNum, position);
  SetFPos(aRefNum, position);
  recHandler->ForAllRecordsDo(NULL, (DoToRecord)SaveRHRecord, aRefNum);
  GetFPos(aRefNum, position);
  recHandler->SaveIndex(aRefNum, oldPos);
  return oldPos;
}


// ------------------------------------------------------------------------
static void DeleteIfUnused(TObject null, TRecordIndex recNum,
                                              TRecordHandler nextHandler)
{
  FailInfo fi;
  TStyleStructure style;

  CatchFailures(&fi);
  style = TStyleStructure(nextHandler->GetRecordObject(recNum, kReadWrite));

  if (!style->fUsed && !gMarkingFailed)
    nextHandler->DeleteRecord(recNum);
  else                                  // 17/10/91 do not mark deleted styles
    style->fUsed = FALSE;
  Success(&fi);

  // 19/03/91 carry on .. cannot fail in Save
Rescue: ;
}

// ------------------------------------------------------------------------
static void DeleteUnusedStyles(TRecordHandler nextHandler)
{
  if (nextHandler != NULL)
    nextHandler->ForAllRecordsDo(NULL, (DoToRecord)DeleteIfUnused);
}

/* ------------------------------------------------------------------------
  Document structure on Disc

  These are first, though written last (position is set to their end)
    TDocRecord - document options
    CustomDate - may be length zero (length is held in TDocRecord)
    MergeTitles - may be length zero (length is held in TDocRecord)
    MergeFileName - may be length zero (length is held in TDocRecord)

  The following write variable length data from the appropriate object
    AlignList
    Selection
    StyleSheet

  For each (of 11) record handlers:
        kTextStruct,
        kPictStruct,
        kMathStruct,
        kTableStruct,
        kBodyStruct,
        kIndexRefStruct,
        kTextStyleStruct,
        kPictStyleStruct,
        kColumnsStyleStruct,
        kBodyStyleStruct,
        kMathStyleStruct
    structure record index (12 byte header followed by 8 bytes per record disc addr/length)
    For each record:
      structure record
      followed by its format record

  For PictureHandler record handler
    For each record:
      length, type and picture

  Control blocks for utilities

formatPosition->
  View type (4 bytes) currently always 1
  Window options in a TScaledWindowTemplate
  Margins, printrec, etc in a TPageDiscInfo
  Main view options and format record index disc addrs in a TViewRecord
    which for each contains the disc addr of each index or 0 if no index
  For each (of the above 11) record handlers
    format record index (12 byte header with disc addr/lengths saved above)
*/
void _TTextDocument::DoWrite(int aRefNum, TSaveInfo *saveInfo)
{
  TDocRecord docRecord;
  TStructTypes index;
  TRecordHandler nextHandler;
  long position;
  int custDateLen;
  int mergeTitleLen;
  int mergeFileLen;

  ActiveMainView()->CompletePagination();

  memset(&docRecord, 0, sizeof(TDocRecord));  // 02/05/95 ensure holes zero filled
  docRecord.version = kCurrentVersion;
  docRecord.body = fBody;
  docRecord.leftHeader = fLeftHeader;
  docRecord.rightHeader = fRightHeader;
  docRecord.leftFooter = fLeftFooter;
  docRecord.rightFooter = fRightFooter;
  docRecord.emphStyle = fEmphasisStyle;
  docRecord.italicStyle = fItalicStyle;         // 11/01/92
  docRecord.greekStyle = fGreekStyle;           // 11/01/92
  docRecord.symbolsStyle = fSymbolsStyle;       // 11/01/92
  custDateLen = GetHandleSpace(fCustomDate);
  mergeTitleLen = GetHandleSpace(fMergeTitles);
  mergeFileLen = GetHandleSpace(fMergeFileName);   // 17/05/92
  position = sizeof(TDocRecord) + custDateLen + mergeTitleLen + mergeFileLen;
  docRecord.u2.merge = (((fHeadings << 8) + mergeFileLen) << 16) + mergeTitleLen;
  // docRecord.mergeTitleLen = mergeTitleLen;
  // docRecord.mergeFileLen = mergeFileLen;
  // docRecord.mergeHeadings = fHeadings;  // 17/05/92
// 02/05/95  for (index = kTextStruct; index <= kMathStyleStruct; index++)
// 02/05/95    docRecord.structureHandlers[index] = 0;
// 02/05/95  docRecord.pictureHandler = 0;
  docRecord.numLevels = fNumLevels;
  docRecord.bookmarkRec = fBookmarkRec;
  memcpy(docRecord.bodyStyles, fBodyStyles, sizeof(docRecord.bodyStyles));

  //18/06/91 save current set of statistics
  docRecord.statistics = fStatistics;
  if (fVersion < 5)
    docRecord.statistics.fWords = -1;
  else
  {
    fStructureHandlers[kTextStruct]->UpdateStatistics(&docRecord.statistics);
#ifdef MATHS
    fStructureHandlers[kMathStruct]->UpdateStatistics(&docRecord.statistics);  // 19/02/92
#endif
  }
  docRecord.statistics.fLines |= 0x40000000;  // 05/08/92 this doc does not have duff maths

// 17/05/92 set above:  position = sizeof(TDocRecord) + docRecord.customDateLength;
// 24/03/92 done by WriteObject  FailOSErr(SetEOF(aRefNum, position));
  fAlignList->WriteObject(aRefNum, position);   // 24/03/92
  GetNewSelection()->WriteObject(aRefNum, -1);  // 24/03/92 follow AlignList
  if (fStyleSheet != NULL)
    fStyleSheet->WriteObject(aRefNum, -1);
  GetFPos(aRefNum, position);
  gMarkingFailed = FALSE;
  SetUsedStyles(fEmphasisStyle);           // 20/03/91
  for (index = kTextStruct; index <= kMathStyleStruct; index++)
  { 
    nextHandler = fStructureHandlers[index];
    if (index >= kTextStyleStruct)
      DeleteUnusedStyles(nextHandler);
    docRecord.structureHandlers[index] = SaveRHData(nextHandler, position, aRefNum);
  }
  docRecord.pictureHandler = SaveRHData(fPictureHandler, position, aRefNum);

  // 28/04/94 [21713] control block data moved before format indices, as at the end of
  // document it is impossible to distinguish it from garbage left by a failure
  if (fControlBlockList != NULL)
  {
    SetFPos(aRefNum, position);
    fControlBlockList->Each(this, (DoToObject)DoWriteCB, aRefNum);
    GetFPos(aRefNum, position);
  }
  docRecord.formatPosition = position;
  docRecord.u1.chars.c0 = fMainViewList->fSize + (fNeedsReformat << 7);
  docRecord.u1.chars.customDateLen = custDateLen;
  docRecord.u1.chars.contTextLen = 0;      // 19/10/90 for later
  docRecord.u1.chars.c3 = (((((((((fTimeFormat << 2) + fDateFormat) << 1) + fAlwaysUpdate)
           << 1) + fInteractive) << 1) + fLeftRightFtr) << 1) + fLeftRightHdr;
#ifdef FN
  docRecord.footnoteBody = fFootnotes;       // left as zero if StartWrite
  docRecord.firstFootnote = fFirstFootnote;
#endif
// 02/05/95  docRecord.spareZero1 = 0;
// 02/05/95  docRecord.spareZero2 = 0;
  // docRecord.numberOfViews = fMainViewList->fSize;
  // docRecord.substitutedFonts = fNeedsReformat;
  // docRecord.customDateLength = custDateLen;
  // docRecord.contTextLength = 0;      // 19/10/90 for later
  // docRecord.leftRightHdr = fLeftRightHdr;
  // docRecord.leftRightFtr = fLeftRightFtr;
  // docRecord.interactive = fInteractive;
  // docRecord.alwaysUpdate = fAlwaysUpdate;
  // docRecord.dateFormat = fDateFormat;
  // docRecord.timeFormat = fTimeFormat;
  fMainViewList->Each(NULL, (DoToObject)SaveFormatIndex, aRefNum, &position);

  SetFPos(aRefNum, 0 /* 03/03/91 startPos */);
  FWrite(aRefNum, sizeof(TDocRecord), &docRecord);

    // 20/09/90 save custom date after docRecord
  FWrite(aRefNum, custDateLen, fCustomDate);
    // 17/05/92 write out the values of the merge fields names and title
  FWrite(aRefNum, mergeTitleLen, fMergeTitles);
  FWrite(aRefNum, mergeFileLen, fMergeFileName);

// 03/03/91  FailOSErr(SetFPos(aRefNum, position));
}


/* ------------------------------------------------------------------------
 * Different from Mac, in that the document data has a count of main views,
 * and each main view is preceded by a integer view code, which is passed
 * to DoCreateMainView in order to create the appropriate type of main view.
 */

#ifdef TRACE
// ------------------------------------------------------------------------
TMainView _TTextDocument::DoCreateMainView(int viewType)
{
  // 25/06/80 overridden in TExpressn
  return NULL;
}


#ifdef SPELL
// ------------------------------------------------------------------------
void _TTextDocument::BeginSpell(int language)
{
}


// ------------------------------------------------------------------------
void _TTextDocument::Spell(TCurrency currency, TCharPos charPos,
                                   Ptr token, int tokenLen)
{
}

// ------------------------------------------------------------------------
void _TTextDocument::Hyphenate(int language, char *first, char *last)
//24/10/90 new, overridden by TExpressionDocument
{
}


// ------------------------------------------------------------------------
bool _TTextDocument::InsertChar(int ch, TCursorNode cursor)
{
  return FALSE;
}

// ------------------------------------------------------------------------
void _TTextDocument::EndInteractive()
{
}
#endif
#endif

// ------------------------------------------------------------------------
static Handle ReadStringField(int aRefNum, int fldLen)
{
  if (fldLen != 0)
  {
    Handle newField;

    newField = NewCheckedHandle(fldLen + 1);
    FRead(aRefNum, fldLen, newField);
    ((char *)newField)[fldLen] = 0;
    return newField;
  }
  return NULL;
}


// ------------------------------------------------------------------------
void _TTextDocument::DoRead(int aRefNum, TWhyMaking forPrinting)
{
  TDocRecord docRecord;
  TStructTypes index;
  TRecordHandler nextHandler;
  long selPosition;
  long position;
  long adjust = 0; // fn1
// 03/03/91  long count;

// 01/05/91 do in TDocument:  fDataRefnum = aRefNum;
// 03/03/91  _TDocument::DoRead(aRefNum, forPrinting);
// 03/03/91  FailOSErr(GetFPos(aRefNum, position));
  FRead(aRefNum, sizeof(TDocRecord), &docRecord);
  if (docRecord.version < kOldestSupported ||
#ifdef PRO
         docRecord.version > kCurrentVersion)
#else
         docRecord.version > kCurrentVersion + 1)  // non-pro can allow 1 greater version
                                                   // i.e. the corresponding PRO version
#endif
  {
    Alert(phNewerDocument, wr_wimp_EOK);
    FailNoFail();
  }

  if (docRecord.version < 6) // fn1: bodyStyles field in the middle needs expanding
  {
    memmove(&docRecord.pictureHandler, 
            &docRecord.structureHandlers[kMathStyleStruct],
            sizeof(TDocRecord) - ((char *)&docRecord.pictureHandler - (char *)&docRecord));
    docRecord.structureHandlers[kMathStyleStruct] = NULL;
    // 04/08/92 set empty record handler entries to zero
    for (index = kTextStruct; index < kMathStyleStruct; index++)
    { 
      if (docRecord.structureHandlers[index + 1] == docRecord.structureHandlers[index])
        docRecord.structureHandlers[index] = 0;
    }
    docRecord.italicStyle/* 08/04/92 fItalicStyle */ = 0;          // 11/01/92
    docRecord.greekStyle/* 08/04/92 fGreekStyle */ = 0;           // 11/01/92
    docRecord.symbolsStyle/* 08/04/92 fSymbolsStyle */ = 0;         // 11/01/92
    memmove(&docRecord.bodyStyles[8], 
            &docRecord.bodyStyles[6],
            sizeof(TDocRecord) - ((char *)&docRecord.bodyStyles[8] - (char *)&docRecord));
    docRecord.bodyStyles[kCurrNoteStyle] = docRecord.bodyStyles[kCurrNoteSetStyle] 
                                         = gNullCurrency;
    // docRecord.numLevels += 2;  // 29/07/92 test in GetStyleAtLevel went haywire
    adjust = 24;
    fNumLevels = docRecord.numLevels + 2;
  }
  else
    fNumLevels = docRecord.numLevels;

  fBody = docRecord.body;
  fLeftRightHdr = docRecord.u1.bits.leftRightHdr;
  fLeftRightFtr = docRecord.u1.bits.leftRightFtr;
  fLeftHeader = docRecord.leftHeader;
  fRightHeader = docRecord.rightHeader;
  fLeftFooter = docRecord.leftFooter;
  fRightFooter = docRecord.rightFooter;
  fBookmarkRec = docRecord.bookmarkRec;
  fDateFormat = docRecord.u1.bits.dateFormat;
  fTimeFormat = docRecord.u1.bits.timeFormat;
  fAlwaysUpdate = docRecord.u1.bits.alwaysUpdate;
  fInteractive = docRecord.u1.bits.interactive;
  fEmphasisStyle = docRecord.emphStyle ;
  fItalicStyle = docRecord.italicStyle;         // 11/01/92
  fGreekStyle = docRecord.greekStyle;           // 11/01/92
  fSymbolsStyle = docRecord.symbolsStyle;       // 11/01/92
  memcpy(fBodyStyles, docRecord.bodyStyles, sizeof(fBodyStyles));

  for (int j = 0; j <= kMaxLevels; j++)
    if (fBodyStyles[j] != 0 && fStructureHandlers[Curr_fType(fBodyStyles[j])] == NULL)
      fBodyStyles[j] = 0;       // 20/05/92 clear if no rec handler

  selPosition = sizeof(TDocRecord) - adjust;

  //18/06/91 load version and hopefully, a set of statistics
  fVersion = docRecord.version;
  if (docRecord.version < 5)
  {
    selPosition -= sizeof(TStatistics);
  }
  else
  {
    fStatistics = docRecord.statistics;
    if (docRecord.statistics.fWords < 0 && docRecord.version == 5) // 21/04/92
      fVersion = 4;
  }

  if (docRecord.version < 8) // 17/05/92 MailMerge
  {
    fHeadings = 1;
    selPosition -= 4;   // for 4 extra bytes on the end of TDocRecord
  }

  if (docRecord.version < 10) // 02/05/95 Start footnote, footnote body curr, 2 zeros
  {
#ifdef FN
    fFootnotes = 0;        // 02/05/95 replacing ref in every body
    fFirstFootnote = 0;    // 02/05/95 reset to default in case changed then Reverted
#endif
    selPosition -= 16;     // for 16 extra bytes on the end of TDocRecord
  }
#ifdef FN
  else
  {
    fFootnotes = docRecord.footnoteBody;
    fFirstFootnote = docRecord.firstFootnote;
  }
#endif

  if (docRecord.version < kCurrentVersion)  // 17/05/92 was 6 but needs to be updated each time!
    SetFPos(aRefNum, selPosition);

  if (docRecord.u1.chars.customDateLen > 0)
  {
    DisposIfHandle(fCustomDate);       // 06/04/94 [21603] leaving handle in StartWrite
    fCustomDate = (char *)ReadStringField(aRefNum, docRecord.u1.chars.customDateLen);
    selPosition += docRecord.u1.chars.customDateLen;
  }

  if (docRecord.version >= 8)
    // 17/05/92 MailMerge: read in the merge string data (if any) after the custom data
  {
    int mergeTitleLen = docRecord.u2.bits.mergeTitleLen;
    int mergeFileLen = docRecord.u2.chars.mergeFileLen;
    selPosition += mergeTitleLen + mergeFileLen;
    fMergeTitles = StringHandle(ReadStringField(aRefNum, mergeTitleLen));
    fMergeFileName = StringHandle(ReadStringField(aRefNum, mergeFileLen));
    fHeadings = docRecord.u2.chars.mergeHeadings;  // 17/05/92
  }

  for (index = kTextStruct;
       index <= kMathStyleStruct;
       index++)
  { 
    nextHandler = fStructureHandlers[index];

    if (nextHandler != NULL)
    {
      int fileIndexPos = docRecord.structureHandlers[index];

      if (fileIndexPos != 0)  // 15/01/92 may be zero if old doc had no handler
      {
        nextHandler->LoadIndex(fileIndexPos);
      }
    }
  }

  if (fPictureHandler != NULL)      // should never be NULL!
  {
    long int controlPos;

    fPictureHandler->LoadIndex(docRecord.pictureHandler);

    // new block for saving Talk/Utility data
    controlPos = docRecord.pictureHandler +
            fPictureHandler->DiscSpaceNeeded() + fPictureHandler->GetIndexSize();
                        // find the end of the pictures

    // 28/04/94 [21713] save control data after pic handler, not at the end
    SetFPos(aRefNum, controlPos);  // 16/05/95 if there are pix, fpos needs setting
    while (controlPos < docRecord.formatPosition)
    {
      TControlBlock controlBlock;

      if (fControlBlockList == NULL)
        fControlBlockList = NewList();
      controlBlock = new _TControlBlock();
      fControlBlockList->InsertLast(controlBlock);
      controlBlock->DoRead(this, aRefNum, 1);
      controlBlock->DoNeedDiskSpace(&controlPos);
      if (docRecord.version < 10 && controlBlock->fBlockType != 1)
      {
        // 16/05/95 discard garbage blocks produced on version 9 or less
        fControlBlockList->Delete(controlBlock);
        FreeIfObject(controlBlock);
      }
    }
  }

  // 24/03/92
  if (docRecord.version >= 7)
  {
    fAlignList->ReadObject(aRefNum, selPosition, 1);
    GetFPos(aRefNum, selPosition);
  }

  position = docRecord.formatPosition;
  fNeedsReformat = docRecord.u1.bits.substitutedFonts;

  // 25/06/90 read view type and create it
//  fMainViewList->Each(NULL, LoadFormats, aRefNum, &position);

  SetFPos(aRefNum, position);
  for (int i = 0; i < docRecord.u1.bits.numberOfViews; i++)
  {
    int viewType;
    TMainView aMainView;

    FRead(aRefNum, 4, &viewType);
#ifdef TRACE
    if (viewType != 1)
    {
      SysBeep(0);
      aMainView = DoCreateMainView(1);
      ActivateMainView(aMainView);
      break;
    }
#endif
    aMainView = DoCreateMainView(viewType);
    ActivateMainView(aMainView);
    position += 4;
    aMainView->DoReadData(aRefNum, position);
  }
  // 25/06/90 end of new bit

  bool hasMaths = Repair(fStructureHandlers[kMathStruct],
           (docRecord.statistics.fLines & 0x40000000) == 0 ? docRecord.version : 0);
                                                       // 04/08/92 for corrupt TW docs
  if (FALSE
#ifndef MATHS
     || hasMaths
#endif
#ifndef TABLES
     || fStructureHandlers[kTableStruct] == NULL ||
       fStructureHandlers[kTableStruct]->DiscSpaceNeeded() > 0 // fail if tables in StartWr
#endif
#ifndef PRO
     || (fStructureHandlers[kIndexRefStruct] != NULL &&
          fStructureHandlers[kIndexRefStruct]->DiscSpaceNeeded() > 0)
#endif
     )
       FailGeneral(34);    // fail if maths records found by EasiWriter, etc.

#ifdef MATHS
  if (hasMaths && docRecord.version < 10)
    fNeedsReformat |= 2;    // 02/05/95 reformat v9 and prev for root metrics change
#endif

#ifndef PRO
  // !!! CHECK THIS at next format change. Need to cope with version 11, 13 (with auto)
  // when new current non-pro version is 10, 12, 14, ...
  if (docRecord.version >= 9 && Odd(docRecord.version))
    fNeedsReformat |= 2;    // 03/05/95 reformat so auto-numbering can be failed
#endif

  fSelection = new _TSelection(this);
  fSelection->ReadObject(aRefNum, selPosition, docRecord.version > 3);
  if (fStyleSheet != NULL)
    fStyleSheet->ReadObject(aRefNum, -1, docRecord.version > 3);
}


/* ------------------------------------------------------------------------
void _TTextDocument::SetBody(TCurrency itsBody)
{
  fBody = itsBody;
}
*/

// ------------------------------------------------------------------------
static int ComputeLevelForStyle(int level, TStyleTypes styleType)
{
  // 02/05/90 - the case structure added
  switch (styleType)
  {
    case kText       : level = kCurrTextStyle; break;
    case kPict       :  // 18/09/90 3 extra cases
    case kWhiteSpace :
    case kPageBreak  :
    case kPageFiller :  // 11/04/91
    case kColBreak   : level = kCurrPictStyle; break;
#ifdef TABLES
    case kColumns    : level = kCurrColumnsStyle; break;
#endif
    case kFigure     : level = kCurrFigureStyle; break;
    case kList       : level = kCurrListStyle; break;
#ifdef MATHS
    // 17/06/92 math level 0 -> cell, 1 -> display, >= 2 -> inline
    case kMaths      : level = (level == 1 ?  kCurrMathsStyle : kMaxLevels - 1); break;
    case kMatrix     : level = kMaxLevels; break;    // 17/06/92
#endif
#ifdef FN
    case kNoteSet    : level = kCurrNoteSetStyle; break;
    case kFootnote   : level = kCurrNoteStyle; break;
#endif
// 15/02/91    case kSection    : level = Max(2 + 6, level + 6); break;
                                  /* 6 added as list is 0-21 not -6-15 */
//    default       : level += 5;  // 31/05/90 - prev.: level --;
    default         : level += (kBaseBodyStyle - 1);  // 10/02/92 2 extra for notes
  }
  return level;
}

// ------------------------------------------------------------------------
TCurrency _TTextDocument::GetStyleAtLevel0(TStyleTypes styleType)
{
  return GetStyleAtLevel(styleType, 0);
}

// ------------------------------------------------------------------------
TCurrency _TTextDocument::GetStyleAtLevel(TStyleTypes styleType, int level)
{
  level = ComputeLevelForStyle(level, styleType);

  if (level == fNumLevels)
  {
    TCurrency currency = fBodyStyles[fNumLevels - 1];
    TStyleStructure styleStruct = GetStyleReadOnly(currency);
    TStyleStructure copyOfStyleStruct;
    char *name;
    int i;
    char depth[6];
    int minRequired;

    CloneStyle(this, /* ActiveMainView() */ NULL, FALSE, FALSE, currency); // 8/4/92
    copyOfStyleStruct = GetStyleReadWrite(currency);
    name = strcpy(copyOfStyleStruct->fStylename, styleStruct->fStylename);
    // name = copyOfStyleStruct->fStylename;
    NumToString(fNumLevels - kBaseBodyStyle - 1 /* 10/02/92 two for notes 7 */, depth);
    minRequired = defNameLen - strlen(depth);
    i = strlen(name);
    while (i > 1 && isdigit(name[i - 1]))
      i--;
    if (i > minRequired)
      i = minRequired;
    strcpy(name + i, depth);
    fStyleSheet->AddStyle(name, styleType, FALSE, currency, 0);
    fBodyStyles[fNumLevels] = currency;
    fNumLevels++;
  }
  return(fBodyStyles[level]);
}

#ifdef EDITSTYLES
// ------------------------------------------------------------------------
void _TTextDocument::PutStyleAtLevel(int level, TCurrency style, TStyleTypes styleType)
{
  fBodyStyles[ComputeLevelForStyle(level, styleType)] = style;
}


// ------------------------------------------------------------------------
void _TTextDocument::ResetStyleForLevel(TCurrency newStyle,
                                  TCurrency oldStyle)  // new 25/01/91
{
  for (int n = kMinBodyStyles; n <= fNumLevels; n++)
    if (fBodyStyles[n] == oldStyle)
    {
      fBodyStyles[n] = newStyle;
      break;
    }
}
#endif

// ------------------------------------------------------------------------
static TSelection InitialSelOrCur(bool sel, TMainView mainView, long startCurr, long param2)
{
  TSelection aSelection;
  TTextDocument doc = TTextDocument(mainView->fDocument);
  FailInfo fi;

  aSelection = new _TSelection(doc);
  CatchFailures(&fi);
  if (sel)
    aSelection->InitialSelection(mainView, startCurr, param2);
  else
    aSelection->InitialCursor(mainView, startCurr, param2);
  aSelection->DoSetupLevels();
  Success(&fi);
  CancelDoubleClick();      // 10/05/94 [21731]
  return doc->fSelection = aSelection;

// ********* exception handler ********
Rescue:
  FreeIfObject(aSelection);
  // aSelection->Free();
  ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
TSelection _TTextDocument::InitialCursor(TMainView mainView, TCurrency target, long posn)
{
  return InitialSelOrCur(FALSE, mainView, target, posn);
}


// ------------------------------------------------------------------------
TSelection _TTextDocument::InitialSelection(TMainView mainView, long startCurr, long endCurr)
{
  return InitialSelOrCur(TRUE, mainView, startCurr, endCurr);
}

// ------------------------------------------------------------------------
void _TTextDocument::ScrollSelectionIntoView()
{
  ActiveMainView()->ScrollSelectionIntoView(fSelectionChanged ?
                               fNewSelection : fSelection);
}

// ------------------------------------------------------------------------
void _TTextDocument::ScrollAndReset()
{
  ScrollSelectionIntoView();
  SetTextHandler();
  HighlightSelection(HLOn, TRUE);
}

// ------------------------------------------------------------------------
TSelection _TTextDocument::StartNewSelection()
{
  if (fNewSelection != NULL)
  {
    fSelectionChanged = FALSE;
    ClearObject(fNewSelection);
  }
  fNewSelection = new _TSelection(this);
  fSelectionChanged = TRUE;
#ifndef SUPER
  fTextHandler->fStyleChanges = NULL;
#endif
  return fNewSelection;
}


// ------------------------------------------------------------------------
TSelection _TTextDocument::GetNewSelection()
{
  return (fSelectionChanged ? fNewSelection : fSelection);
}


// ------------------------------------------------------------------------
TSelection _TTextDocument::GetSelection(bool commitIt)
{
  if (commitIt)
  {
    if (fSelectionChanged)
    {
      ReplaceObject(fSelection, fNewSelection);
      // FreeIfObject(fSelection);
      // fSelection = fNewSelection;
      fNewSelection = NULL;
      fSelectionChanged = FALSE;
    }
  }
  return fSelection;
}


// ------------------------------------------------------------------------
void _TTextDocument::ResetSelection(TSelection selection)
{
  if (fSelectionChanged)
  {
    if (selection == NULL)
      HighlightSelection(HLOff, TRUE);
    ClearObject(fNewSelection);
    // fNewSelection->Free();
    // fNewSelection = NULL;
    fSelectionChanged = FALSE;
  }

  CancelDoubleClick();      // 10/05/94 [21731]
  ActiveMainView()->ClearViewSlave();

  if (selection != NULL)
  {
    fSelection = selection;
    fSelection->SetTarget();
  }
  else
    ScrollSelectionIntoView();  // 28/05/90
}


// ------------------------------------------------------------------------
void _TTextDocument::DoSetStyle(TMainView view)
{
  (fSelectionChanged ? fNewSelection : fSelection)->SetCurrentStyle(view);
}


// ------------------------------------------------------------------------
void _TTextDocument::SetCurrentStyle()
{
  fMainViewList->Each(this, (DoToObject)_TTextDocument::DoSetStyle);
}


// ------------------------------------------------------------------------
TRulerDef _TTextDocument::GetCurrentChanges(bool forDialog)
{
  // 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted
  return (fSelectionChanged ? fNewSelection : fSelection)->GetCurrentChanges(forDialog);
}


// ------------------------------------------------------------------------
bool _TTextDocument::ChangeStyleAttrs(CmdNumber attrsCmd)
{
  bool  ChangeStyleAttrs_r;
  TMainView mainView = ActiveMainView();

  ChangeStyleAttrs_r = GetNewSelection()->ChangeStyleAttrs(mainView, attrsCmd);
  HighlightSelection(HLOn, FALSE);    // 28/08/90 TRUE -> FALSE

  return ChangeStyleAttrs_r;
}


// ------------------------------------------------------------------------
void _TTextDocument::ReformatForStyle(bool setHL, bool clearView)
{
  FailInfo fi;

  Reformat();
  CatchFailures(&fi);                   // 13/06/91
  fSelection->SelectLevel(-1);          // 25/01/91
  if (clearView)
    ActiveMainView()->ClearViewSlave(); // 25/04/91
  ScrollSelectionIntoView();            // 11/04/91
  Success(&fi);
  goto Complete;

Rescue:
  ErrorAlert(fi.error, msgReformFailed);
  if (MemSpaceIsLow())
    Purge();
Complete:
  HighlightSelection(HLOn, setHL);      // 11/04/91 from FALSE
                                        // 28/08/90 TRUE -> FALSE
  SetCurrentStyle();                    // 23/05/91
}

#ifdef SUPER
// ------------------------------------------------------------------------
void _TTextDocument::InstallStyleChange(TRulerDef theChange, CmdNumber cmd)
{
  GetSelection(TRUE)->InstallStyleChange(theChange, cmd);
  HighlightSelection(HLOff, FALSE);
  ReformatForStyle(FALSE, FALSE);
}

// ------------------------------------------------------------------------
void _TTextDocument::SetStyle(TCurrency style, CmdNumber cmd)
{
  GetSelection(TRUE)->SetStyle(style, cmd);
  HighlightSelection(HLOff, FALSE);
  ReformatForStyle(TRUE, TRUE);
}

// ------------------------------------------------------------------------
void _TTextDocument::ToggleStyle(CmdNumber cmd)
{
  ResetSelection(NULL);
  fSelection->ToggleStyle(cmd);   // ActiveMainView(), cmd);
  ReformatForStyle(FALSE, TRUE);
}

// ------------------------------------------------------------------------
void _TTextDocument::ToggleChanges(CmdNumber cmd)
{
  ResetSelection(NULL);
  fSelection->ToggleChanges(/* ActiveMainView(), */ cmd);
  ReformatForStyle(FALSE, TRUE);
}

// ------------------------------------------------------------------------
void _TTextDocument::CommitStyle(TCommand command)
{
  fSelection->CommitStyle(command);
}

#else

// ------------------------------------------------------------------------
void _TTextDocument::InstallStyleChange(TRulerDef theChange, CmdNumber cmd) // 6/5/92
{
  TStyleFormat changes = TStyleFormat(theChange);
  TSelection selection = GetSelection(TRUE);
  TCurrency curr;

  // 07/08/95 set fCursor = 2 for really a cursor, but treat as para for sake of deferred styles
  if (selection->fCursor)
    selection->fCursor = (cmd == cPlain &&
        (curr = selection->GetAnchorOwner()->fCurrency, Curr_fType(curr) == kTextStruct) &&
        GetStructureReadOnly(curr)->IsEmpty() && fTextHandler->fStyleChanges == NULL ? 2 : 1);
            // 08/02/93 [20617] allow plain on an empty paragraph - for StartWrite
            // 01/12/93 [21140] ensure a paragraph, not maths

  if (selection->DeferredChanges(changes))
// 07/08/95 [26044] setting fCursor = 2 replaces the following
//    && (cmd != cPlain ||
//       (curr = selection->GetAnchorOwner()->fCurrency, Curr_fType(curr) != kTextStruct) ||
//         !GetStructureReadOnly(curr)->IsEmpty())
  {
    fTextHandler->fStyleChanges = changes;
    fTextHandler->fStyleCmd = cmd; // 6/5/92
    // 20/01/94 [21352] Get Plain to reset menus by setting levelInfo without emphasis
    // moved from UTextComm, where it freed the style which had been copied on-stack
    if (cmd == cPlain)          // 20/06/93 sort out buttons after Plain
    {
      selection->DoSetupLevels();
      SetCurrentStyle();
    }
  }
  else
  {
    // 13/11/92 changes to get underline + centre justn type combo to work
    Attributes defined = 0;

    if (changes != NULL && changes == fTextHandler->fStyleChanges)
    {
      defined = (changes->fDefined & emphasisAttrs) | kEmphasis;
      changes->fDefined &= ~emphasisAttrs;
      if (selection->fCursor)
        selection->fCursor = 3;  // 07/08/95 [26042] set fCursor = 3
                                 // for Bold, Centre Just & Undo to have an effect; so toggle
                                 // calls structure->ToggleState, Commit applies deferred chg
    }
    else
      fTextHandler->fStyleChanges = NULL;
    selection->InstallStyleChange(theChange, cmd);

    HighlightSelection(HLOff, FALSE);    // 28/08/90 TRUE -> FALSE
    ReformatForStyle(FALSE, FALSE);        // 23/05/91
    // 13/11/92 more of above fix
    if (fTextHandler->fStyleChanges != NULL)
      changes->fDefined = defined;
  }
}

// ------------------------------------------------------------------------
void _TTextDocument::SetStyle(TCurrency style, CmdNumber cmd) // 6/5/92
{
  TSelection selection;
  TStyleFormat changes;

  selection = GetSelection(TRUE);
  if (selection->DeferredStyle(style, changes))
    fTextHandler->fStyleChanges = changes;
  else
  {
    selection->SetStyle(style, cmd); // 22/4/92
    HighlightSelection(HLOff, FALSE);    // 01/05/91 reinstated
    ReformatForStyle(TRUE, TRUE);        // 23/05/91
  }
}

// ------------------------------------------------------------------------
void _TTextDocument::ToggleStyle(CmdNumber cmd) // 6/5/92
{
  TStyleFormat changes;

  ResetSelection(NULL);
  if (fSelection->DeferredToggleChanges(changes))
    fTextHandler->fStyleChanges = changes;
  else
  {
    fSelection->ToggleStyle(cmd);         // 22/4/92
    ReformatForStyle(FALSE, TRUE);        // 23/05/91
  }
}


// ------------------------------------------------------------------------
void _TTextDocument::ToggleChanges(CmdNumber cmd) // 6/5/92
{
  TStyleFormat changes;

  ResetSelection(NULL);
  fTextHandler->fStyleCmd = -fTextHandler->fStyleCmd;  // 20/01/94 stop cmd being cPlain
  if (fSelection->DeferredToggleChanges(changes))
    fTextHandler->fStyleChanges = changes;
  else
  {
    fSelection->ToggleChanges(cmd);       // 22/4/92
    ReformatForStyle(FALSE, TRUE);        // 23/05/91
  }
}


// ------------------------------------------------------------------------
void _TTextDocument::CommitStyle(TCommand command)
{
  TStyleFormat changes; // waste of time, overwritten by DefChgs = fSelection->fStyleChanges; 

  if (fSelection->DeferredChanges(changes) && (command != NULL))
    return;
  
  ResetTextHandler(); // 6/5/92
  fSelection->CommitStyle(command);
}

#endif

// ------------------------------------------------------------------------
static void DoCommit(TObject null, TMainView view)
{
  view->PaginateOnCommit();
}

static void DoStructCommit(TTextDocument doc, TSelection changes, TCommand command)
// 28/09/93 [21055] new to get called from recovery when SelectLevel not needed
{
  TCursorNode activeEnd;
  TCursorNode anchor;
  TStructure owner;
  TCurrency currency;

  activeEnd = changes->GetActiveRoot();
  anchor = changes->GetAnchorRoot();
  currency = activeEnd->fCurrency;
  owner = doc->GetStructureReadWrite(currency);
  owner->Commit(currency, anchor, activeEnd, command, FALSE);
}

void _TTextDocument::Commit(TSelection changes, TCommand command)
{
  TSelection selection;

  DoStructCommit(this, changes, command);
  selection = GetSelection(TRUE);
  selection->SelectLevel(-1);           // 25/11/91 rebuild custom values for delete col
                           // (which it will provided the selection fPopup is unchanged)
#ifdef DRAGDROP
  if (command->fCmdNumber != cMove)
#endif
  fMainViewList->Each(NULL, (DoToObject)DoCommit);
}


// ------------------------------------------------------------------------
TSelection _TTextDocument::CloneSelection()
{
  if (fNewSelection == NULL)
  {
    fNewSelection = TSelection(fSelection->Clone());
    fSelectionChanged = TRUE;
  }
  return fNewSelection;   // 21/07/96 return something useful
}


// ------------------------------------------------------------------------
void _TTextDocument::SelectLevel(int level)
{
  CloneSelection();                   // 03/04/91
  EndInteractive();
  HighlightSelection(HLOff, TRUE);
  DoneTyping();                       // 22/11/90 moved
  GetNewSelection()->SelectLevel(level);
  ScrollSelectionIntoView();    // 09/08/90 - this was missing (is on mac)
      // fixes case of selecting a chapter which contains a table
  SetCurrentStyle();
  HighlightSelection(HLOn, TRUE);
}


#ifdef TABLES
// ------------------------------------------------------------------------
void _TTextDocument::EndStructure()
{
  TSelection selection;

  CommitLastDocCommand();        // 16/04/93 from CommitLastCommand
  selection = GetSelection(TRUE);
  HighlightSelection(HLOff, TRUE);
  selection->EndStructure();
  ScrollAndReset();
  SetCurrentStyle();
}
#endif

// ------------------------------------------------------------------------
void _TTextDocument::SetTextHandler()
{
  if (fTextHandler != NULL)                     // 09/05/91 none in clip doc
    fTextHandler->SetTarget(fSelectionChanged ? fNewSelection : fSelection);
}


// ------------------------------------------------------------------------
void _TTextDocument::UnsetTextHandler()
{
  if (fTextHandler != NULL)
    fTextHandler->fNextHandler = this;
}


#ifndef SUPER
// ------------------------------------------------------------------------
void _TTextDocument::ResetTextHandler()
{
//  fTextHandler->ResetTarget(fSelection);
  if (fTextHandler != NULL)                   // 03/04/92
  {
    fTextHandler->fStyleChanges = NULL;       // 01/04/92
    fTextHandler->fStyleCmd = 0; // 6/5/92
  }
}
#endif

// ------------------------------------------------------------------------
void _TTextDocument::DoneTyping()
{
  fTextHandler->DoneTyping();
}


// ------------------------------------------------------------------------
void _TTextDocument::HighlightSelection(HLState HLDesired, bool redraw)
{
  TMainView view = ActiveMainView();

#ifdef VIEWACT
  redraw = (redraw && view->fViewActive);
#endif
  if (HLDesired == HLOn)
    GetNewSelection()->Highlight(view, redraw);
  else
    view->ClearHighlighting(redraw);
}


// ------------------------------------------------------------------------
void _TTextDocument::Reformat()
{
  int index;
  TCursorNode start, finish;
  TReformatTypes reformatType;
  TMainView mv = ActiveMainView();
  int sz;
  volatile TSelection selection;
  FailInfo fi;

#ifdef TRACE
  Assert(fSelection, 700);
#endif
  reformatType = fSelection->fReformatType;
  selection = NULL;
  CatchFailures(&fi);
  if (reformatType == kSelSaveAll || 
           reformatType == kReformatAll ||
           reformatType == kReformatChgs || 
           reformatType == kReformatMacros ||
           reformatType == kReformatEdits)
           // 25/01/91, 1/7/92 extra test for kReformatEdits !!!
  {
    if (reformatType == kReformatAll || reformatType == kReformatChgs)
        // 13/06/95 [26017] make temp seln for kReformatChgs for spellChk cursor in h/f
    {
      selection = fSelection;        // 03/04/91 save seln & CatchFailures
      InitialSelection(mv, 0, -1)->fReformatType = reformatType;
          // 21/04/92 need to test this case in MakeViewsForPage
    }
    start = NULL;
    finish = NULL;
  }
  else
  {
    fSelection->PushLevel();
    fSelection->GetNodesToReformat(start, finish);
    selection = TSelection(-1);  // use selection as flag to avoid making pushed volatile
  }

  mv->Reformat(fSelection, start, finish);
  sz = fMainViewList->GetSize();
  for (index = 2; index <= sz; index++)
    TMainView(fMainViewList->At(index))->ReformatDuringIdle(start, finish);
  Success(&fi);

Rescue:
  // 13/06/95 do same restoration for fail & no fail
  if (selection == TSelection(-1))
    fSelection->PopLevel();
  else
  {
    if (selection != NULL)
    {
      ReplaceObject(fSelection, selection);
      SetTextHandler();           // 01/05/91
    }
  }
  fSelection->fReformatType = kSelNormal; // 01/05/91 moved from inside else
  ContinueIfFail(&fi);
}


// ------------------------------------------------------------------------
TCurrency _TTextDocument::NewCurrency(TStructTypes itsType, TDiscObject &itsObject)
{
  return Curr_Set(fStructureHandlers[itsType]->NewRecordObject(itsObject), itsType);
}


// ------------------------------------------------------------------------
void _TTextDocument::DeleteCurrency(TCurrency itsCurrency)
{
  if (itsCurrency != 0)  // 25/07/92 avoid crashes in exception hdlrs
  {
    TRecordHandler recHandler = fStructureHandlers[Curr_fType(itsCurrency)];

    recHandler->DeleteRecord(Curr_fRecnum(itsCurrency));
  }
}

#ifdef MATHS
// ------------------------------------------------------------------------
bool _TTextDocument::IsMathSymbol(int recNum)
{
  return (recNum == Curr_fRecnum(fGreekStyle) || recNum == Curr_fRecnum(fSymbolsStyle));
}
#endif

// ------------------------------------------------------------------------
static void DoDelete(TObject null, TMainView view, TCurrency currency, int index)
{
  TFormat format = view->GetFormatReadWrite(currency);
  format->DeleteFormatData(index);
}

void _TTextDocument::DeleteFormatData(TCurrency currency, int index)
{
  fMainViewList->Each(NULL, (DoToObject)DoDelete, currency, index);
}

// ------------------------------------------------------------------------
// 27/01/91 new
int _TTextDocument::ConvertAndCloneStyle(TTextDocument sourceDoc,
                                                       int styleNum)
{
  TCurrency curr = RecToCurrency(styleNum);

  CloneStyle(sourceDoc, /* sourceDoc->ActiveMainView() */ NULL, TRUE, FALSE, curr); // 8/4/92
  return Curr_fRecnum(curr);
}

// 02/02/94 [21376] rewritten to match part styles too
// ------------------------------------------------------------------------
void _TTextDocument::DoCloneStyle(PPartStyles theItem, TTextDocument clipDoc,
                                  int matchParts)
{
  RealCloneStyle(theItem->fStyle, clipDoc, matchParts);
}

// ------------------------------------------------------------------------
void _TTextDocument::MatchStyle(int index, TRecordHandler styles,
      TStyleFormat clipStyleFormat, TStyleStructure clipStyleStruct, TCurrency *currency)
{
  TStyleFormat styleFormat = TStyleFormat(styles->GetRecordObject(index, kReadOnly));

  if (styleFormat->Match(clipStyleFormat))
  {
    // 02/02/94 as well as matching the style, we need the following tests to see
    // if the part styles (if any) held in the style structure all match as well
    // Start by getting the structure corresponding to the style format just matched:
    TStyleStructure styleStruct =
                      TStyleStructure(styles->fMaster->GetRecordObject(index, kReadOnly));
    TMainView clipView;

    if (styleStruct->fSize != clipStyleStruct->fSize)
      return;                                 // reject if different number of parts
    clipView = clipStyleStruct->fDocument->ActiveMainView();
    for (int part = 1; part <= styleStruct->fSize; part++)
    {
      TCurrency myPartStyle = PPartStyles(styleStruct->At(part))->fStyle;
      TCurrency clipPartStyle = PPartStyles(clipStyleStruct->At(part))->fStyle;

      if (myPartStyle != 0 && clipPartStyle != 0)
      {
        if (!ActiveMainView()->GetStyleReadOnly(myPartStyle)->
                                      Match(clipView->GetStyleReadOnly(clipPartStyle)))
          return;                      // there were part styles but they did not match
      }
      else if ((myPartStyle | clipPartStyle) != 0)
        return;                        // one or other was not a null currency
    }
    // we have dropped out of the part style comparison without any mismatches
    *currency = Curr_Set(index, 0);            // prepare the currency w/o the type

    if (styleStruct->fStylename[0] != 0)  // 04/02/91 pick a named style if possible
      FailNoFail();   // jump out of loop having found what we are looking for
  }
}

// ------------------------------------------------------------------------
void _TTextDocument::RealCloneStyle(TCurrency &currency, TTextDocument clipDoc,
                                      int findMatch) // 02/02/94 changed interface
       // the last param is the old findMatch * 2 + matchParts
{
  if (currency != 0)
  {
    volatile TStyleStructure styleStruct1;
    volatile TStyleFormat styleFormat1;
    TStructTypes itsType = Curr_fType(currency);
    TCurrency newStyle;
    TMainView mainView = ActiveMainView();
    TStyleStructure styleStruct = clipDoc->GetStyleReadOnly(currency);
    TStyleFormat styleFormat = clipDoc->ActiveMainView()->GetStyleReadOnly(currency);
    FailInfo fi;

    newStyle = 0;
    styleStruct1 = NULL;
    styleFormat1 = NULL;

    CatchFailures(&fi);

    if (findMatch >= 2)
    {
      // search through the style handler for 'this' document looking to match the style
      TRecordHandler styles = mainView->fFormatHandlers[itsType];

      styles->ForAllRecordsDo(this, (DoToRecord)_TTextDocument::MatchStyle, styleFormat,
                                                         styleStruct, &newStyle);
      // 03/07/91 for paste, try to find one with same name and type if no match found
      if (newStyle == 0 && fStyleSheet != NULL)    // not matched
      {
        TStyleInfo info;

        fStyleSheet->FindStyleInfo(styleStruct->fStylename, info);
        if (info.fName[0] != 0 && styleStruct->fType == info.fType) // name & type match
          newStyle = info.fDocCurrency;
      }
    }
    if (newStyle == 0)
    {
      // not found so far, so proceed with cloning
      TDiscObject obj;

      // FailNIL(styleStruct1 = TStyleStructure(styleStruct->Clone()));
      styleStruct->MakeClone(&styleStruct1);

      if (clipDoc == this)            // (mainView == view)
        styleStruct1->fStylename[0] = 0;   // lose any name if cloned from 'this' document

      // FailNIL(styleFormat1 = TStyleFormat(styleFormat->Clone()));
      styleFormat->MakeClone(&styleFormat1);
      styleFormat1->fTimeStamp = UniqueNumber();          // 11/02/91 && 04/05/92
      newStyle = NewCurrency(itsType, obj);
      SetStyleStructure(newStyle, styleStruct1);
      styleStruct = styleStruct1;      // 25/02/92 in case of further failure
      styleStruct1 = NULL;             // ditto
      styleFormat1->fTextFont = GetFNum(styleFormat1->fFontName); // 30/11/90
      if (styleFormat1->fDefined & kBullet)
        styleFormat1->fBulletFont = GetFNum(styleFormat1->fBulletFontName); // 01/03/91
      mainView->SetStyle(newStyle, styleFormat1);
      styleFormat1 = NULL;             // 25/02/92 in case of further failure
      // done at end: currency = newStyle;
      if (findMatch >= 2 && fStyleSheet != NULL && styleStruct->fStylename[0] != 0)
      {
        fStyleSheet->AddStyle(styleStruct->fStylename, styleStruct->fType,
                    (styleFormat->fDefined & kEmphasis) != 0, newStyle, 0);
      }
      styleStruct->Each(this, (DoToItem)_TTextDocument::DoCloneStyle, clipDoc, 0);
      // On the Mac the theory is that the last parameter is (findMatch == 1 ? 2 : 0)
      // i.e. matchParts ? findMatch : FALSE so that on InstallStyleChange it clones
      // the main style but matches the part styles if possible
    }
    Success(&fi);
    // ++++++++ run into exception handler
Rescue:
    FreeIfObject(styleStruct1);      // 25/02/92 from 2 * DisposIfHandle()
    FreeIfObject(styleFormat1);
    ContinueIfFail(&fi);  // a real failure
    currency = newStyle | itsType;
  }
}


// ------------------------------------------------------------------------
TDiscObject _TTextDocument::GetPicture(int recnum)
{
  FailInfo fi;
  TDiscObject picture;

  CatchFailures(&fi);
  picture = TDiscObject(fPictureHandler->GetRecordObject(recnum, kReadOnly));
  Success(&fi);
  return picture;

Rescue:
  // 12/06/91 see if we can purge any other pictures
  fPictureHandler->ForAllRecordsDo(NULL, (DoToRecord)DoPurge);
  return TDiscObject(fPictureHandler->GetRecordObject(recnum, kReadOnly));
}


// ------------------------------------------------------------------------
// 04/05/90 - changed this method - get the record handler to add the pic
int _TTextDocument::AddNewPictureObject(TDiscObject &picture)
{
  return fPictureHandler->NewRecordObject(picture);
}


// ------------------------------------------------------------------------
void _TTextDocument::ReplacePicture(int recnum, TDiscObject picture)
{
  fPictureHandler->ReplaceRecordObject(recnum, picture);
}


// ------------------------------------------------------------------------
void _TTextDocument::DeletePicture(int recnum)
{
  fPictureHandler->DeleteRecord(recnum);
}


// ------------------------------------------------------------------------
void _TTextDocument::AddStructure(int isPaste, TStructure structure,
        long &beforeItem, TCurrency itsParent, TTextDocument document,
        TCurrency &itsCurrency)
{
  TStructure parent;
  TCurrency currency;
  // TMainView view;
  TDiscObject obj;
  FailInfo fi;

  itsCurrency = NewCurrency(Curr_fType(itsCurrency), obj);
  CatchFailures(&fi);  // 10/01/94 [21225]
  structure->fDocument = this;    // 10/01/94 [21225]
  SetStructure(itsCurrency, structure);
  if (itsParent == 0)
    fBody = itsCurrency;
  else if (beforeItem < MAXLONGINT) // fn1 test added
  {
    parent = GetStructureReadWrite(itsParent);
    parent->InsertSubStructure(isPaste, document, itsParent,
                               itsCurrency, beforeItem); // 26/07/90
  }
  Success(&fi);  // 10/01/94 [21225]
  if (itsCurrency != 0)
  {
    bool ignoreStyle = FALSE;        // 30/04/93

    // 10/01/94 [21225] moved up: structure->fDocument = this;
    structure->fParent = itsParent; // fn1 moved from above
    if (itsParent == 0 && structure->GetKind() == kDocument)      
    {
       ignoreStyle = isPaste;    // 30/04/93 need to clone all styles if not pasting
                                 // in case clipboard saved as document
      if (!isPaste)
      {
#ifdef FN
        if (structure->GetNoteCollector() != 0) // 24/4/92
          // make the note collector in the clip doc
        {
          structure->ProtoInit(itsCurrency);
          // clone the default noteSet style for the clip note collector
          currency = document->GetStyleAtLevel0(kNoteSet);
          CloneStyle(document, /* view */ NULL, TRUE, FALSE, currency); // 8/4/92
          GetStructureReadWrite(structure->GetNoteCollector())->fStyle = currency;
        }
#else
        structure->ClearNoteCollector();   // 10/05/95 [25012] clear fFootnotes in clip doc
#endif
      }
    }
    if (ignoreStyle)
    {
      // 30/04/93 moved from above: no need to copy document style to clipboard
      // 29/4/92, 09/05/91 do not copy document style ... but set up to default (rec 1)
      structure->fStyle = Curr_Set(1, Curr_fType(structure->fStyle));
      structure->fChanges = 0;
    }
    else
    {
      currency = structure->fStyle;
      // for CSV pasting:
      if (currency == 0)
        currency = GetStyleAtLevel0(structure->GetKind());
      else
        CloneStyle(document, /* view */ NULL, TRUE, FALSE, currency);
      structure->fStyle = currency;
      currency = structure->fChanges;
      CloneStyle(document, /* view */ NULL, TRUE, FALSE, currency);
      structure->fChanges = currency;
    }
  }
  return;

  // 10/01/94 [21225] leaving records
Rescue:
  DeleteCurrency(itsCurrency);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
TSubView _TTextDocument::FindActiveView(TCursorNode cursor)
{
  TMainView mainView;
  TSubView subView;

  mainView = ActiveMainView();
  subView = mainView->FindCursorView(cursor);
  if (subView == NULL)
  {
    mainView->MakeSelectedViews(TCursorNode(cursor->fCursor->First()), NULL);
    subView = mainView->FindCursorView(cursor);
  }
  return subView;
}


// ------------------------------------------------------------------------
void _TTextDocument::AddMainView(TView aView)
{
  fMainViewList->InsertLast(aView);
}


// ------------------------------------------------------------------------
void _TTextDocument::DeleteMainView(TView viewToDelete)
{
  if (fMainViewList != NULL)
    fMainViewList->Delete(viewToDelete);
}


// ------------------------------------------------------------------------
void _TTextDocument::ActivateMainView(TView viewToActivate)
{
  fMainViewList->Delete(viewToActivate);
  fMainViewList->InsertFirst(viewToActivate);
}


// ------------------------------------------------------------------------
TMainView _TTextDocument::ActiveMainView()
{
  CheckThis();
  return(TMainView(fMainViewList->First()));
}


// ------------------------------------------------------------------------
void _TTextDocument::MakeHeaderFooter(TCurrency itsStyle)
{
  TCurrency currency;
  TStructure body;
  TDiscObject obj;

  FailSpaceIsLow();

  for (int hf = kHeader; hf <= kFooter; hf++)
  {
    currency = NewCurrency(kBodyStruct, obj);
    body = TStructure(obj);
    body->InitNewStructure(gNullCurrency, currency, itsStyle, hf, TRUE, NULL);
    ((TCurrency *)&fLeftFooter)[kFooter - hf] = currency;
    ((TCurrency *)&fRightFooter)[kFooter - hf] = currency;
  }
  //  currency = NewCurrency(kBodyStruct, obj);
  //  body = TStructure(obj);
  //  body->InitNewStructure(gNullCurrency, currency, itsStyle, kHeader, TRUE, NULL);
  //  fLeftHeader = currency;
  //  fRightHeader = currency;

  //  // same for footers
  //  currency = NewCurrency(kBodyStruct, obj);
  //  body = TStructure(obj);
  //  body->InitNewStructure(gNullCurrency, currency, itsStyle, kFooter, TRUE, NULL);
  //  fLeftFooter = currency;
  //  fRightFooter = currency;
}


// ------------------------------------------------------------------------
bool _TTextDocument::GetHeaderFooter(bool theHeader, TCurrency &currencyL,
                                           TCurrency &currencyR)
{
  currencyL = ((TCurrency *)&fLeftFooter)[theHeader];
  currencyR = ((TCurrency *)&fRightFooter)[theHeader];
  return ((bool *)&fLeftRightFtr)[theHeader];
}

// ------------------------------------------------------------------------
bool _TTextDocument::SetHeaderFooter(bool theHeader, bool newDifferent)
{
  bool oldDifferent = ((bool *)&fLeftRightFtr)[theHeader];

  if (newDifferent != oldDifferent)
  {
    if (newDifferent)
    {
      if (((TCurrency *)&fLeftFooter)[theHeader] == ((TCurrency *)&fRightFooter)[theHeader])
        ((TCurrency *)&fLeftFooter)[theHeader] =
                       CloneHeaderFooter(((TCurrency *)&fLeftFooter)[theHeader]);
    }
    ((bool *)&fLeftRightFtr)[theHeader] = newDifferent;
    fLRHeaderFooterChg = TRUE;
  }
  return oldDifferent;
}


// ------------------------------------------------------------------------
void _TTextDocument::CommitLRHeaderFooter(bool theHeader)
{
  // 23/06/95 checks is h/fs have gone from different to same L & R
  fLRHeaderFooterChg = FALSE;
  if (((TCurrency *)&fLeftFooter)[theHeader] !=
                 ((TCurrency *)&fRightFooter)[theHeader] &&
                                       !((bool *)&fLeftRightFtr)[theHeader])
  {
    TCurrency temp = ((TCurrency *)&fLeftFooter)[theHeader];

    ((TCurrency *)&fLeftFooter)[theHeader] = ((TCurrency *)&fRightFooter)[theHeader];
    DisposeHeaderFooter(temp);
  }
}


// ------------------------------------------------------------------------
TCurrency _TTextDocument::CloneHeaderFooter(TCurrency currency)
{
  volatile TCurrency theCopy;
  TStructure structure;
  long pos;
  TCurrency theClone;
  FailInfo fi;

  structure = GetStructureReadOnly(currency);
  CatchFailures(&fi);
  theCopy = fBody;
  pos = -1;
#ifdef DRAGDROP
  structure->CopyToClipboard(currency, NULL, NULL, NULL, this, gNullCurrency, pos);
#else
  structure->CopyToClipboard(currency, NULL, NULL, this, gNullCurrency, pos);
#endif
  theClone = fBody;
  fBody = theCopy;
  Success(&fi);
  return theClone;

Rescue:
  DisposeHeaderFooter(fBody);
  fBody = theCopy;
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TTextDocument::DoDispose(TCurrency currency, long pos)
{
  DisposeHeaderFooter(currency);
}


// ------------------------------------------------------------------------
void _TTextDocument::DisposeHeaderFooter(TCurrency currency)
{
  TStructure structure = GetStructureReadWrite(currency);

  structure->IteratePart(currency, 1, gZeroRect, NULL, gNullCurrency, NULL,
                       this, (DoPartStep)_TTextDocument::DoDispose);
  DeleteCurrency(currency);
}


// ------------------------------------------------------------------------
TStructure _TTextDocument::GetStructure(TCurrency itsCurrency, bool readOnly)
{
  TRecordHandler structures;
#ifdef TRACE
  Assert(itsCurrency != 0, kNullCurrency1);
  Assert(Curr_fType(itsCurrency) <= kBodyStruct, 72);
#endif
  structures = fStructureHandlers[Curr_fType(itsCurrency)];
  return TStructure(structures->GetRecordObject(Curr_fRecnum(itsCurrency), readOnly));
}

// ------------------------------------------------------------------------
TStructure _TTextDocument::GetStructureReadOnly(TCurrency itsCurrency)
{
  return GetStructure(itsCurrency, kReadOnly);
}

// ------------------------------------------------------------------------
TStructure _TTextDocument::GetStructureReadWrite(TCurrency itsCurrency)
{
  return GetStructure(itsCurrency, kReadWrite);
}

#ifdef FN
// ------------------------------------------------------------------------
TStructure _TTextDocument::GetParentReadOnly(TCurrency itsCurrency)
{
  return GetStructureReadOnly(GetStructureReadOnly(itsCurrency)->fParent);
}
#endif

#ifdef INDEX
// ------------------------------------------------------------------------
TIndexStructure _TTextDocument::GetIndexStructure(int recNum, int rw)
{
  return TIndexStructure(fStructureHandlers[kIndexRefStruct]->GetRecordObject(recNum, rw));
}

// ------------------------------------------------------------------------
TIndexStructure _TTextDocument::GetIndexStructureReadOnly(int recNum)
{
  return GetIndexStructure(recNum, kReadOnly);
}

// ------------------------------------------------------------------------
TIndexStructure _TTextDocument::GetIndexStructureReadWrite(int recNum)
{
  return GetIndexStructure(recNum, kReadWrite);
}

// ------------------------------------------------------------------------
TIndexStructure _TTextDocument::GetBookmarkReadOnly()
{
  return GetIndexStructureReadOnly(fBookmarkRec);
}
#endif

// ------------------------------------------------------------------------
void _TTextDocument::SetStructure(TCurrency currency, TStructure aStructure)
{
  TRecordHandler structures = fStructureHandlers[Curr_fType(currency)];

  structures->ReplaceRecordObject(Curr_fRecnum(currency), aStructure);
}


// ------------------------------------------------------------------------
TStyleStructure _TTextDocument::GetStyle(TCurrency itsCurrency, bool readOnly)
{
  TRecordHandler structures;

#ifdef TRACE
  Assert(itsCurrency != 0, kNullCurrency2);
  Assert(Curr_fType(itsCurrency) >= kTextStyleStruct && Curr_fType(itsCurrency) <= kMathStyleStruct, 72);
#endif
  structures = fStructureHandlers[Curr_fType(itsCurrency)];
  return TStyleStructure(structures->GetRecordObject(Curr_fRecnum(itsCurrency), readOnly));
}

TStyleStructure _TTextDocument::GetStyleReadOnly(TCurrency itsCurrency)
{
  return GetStyle(itsCurrency, kReadOnly);
}

TStyleStructure _TTextDocument::GetStyleReadWrite(TCurrency itsCurrency)
{
  return GetStyle(itsCurrency, kReadWrite);
}

// ------------------------------------------------------------------------
TObject _TTextDocument::GetPrototype(TStructTypes itsType)
{
#ifdef TRACE
  Assert(itsType <= kMathStyleStruct, 708);
#endif
  return fStructureHandlers[itsType]->GetPrototype();
}


// ------------------------------------------------------------------------
void _TTextDocument::SetStyleStructure(TCurrency currency, TStyleStructure aStyle)
{
  aStyle->fDocument = this;        // 02/02/94 may have been cloned from clip doc
  fStructureHandlers[Curr_fType(currency)]->
                ReplaceRecordObject(Curr_fRecnum(currency), aStyle);
}

#ifdef SPELL
// ------------------------------------------------------------------------
void _TTextDocument::DoSpellCheck(bool checkAll)
{
  TSelection selection;
  TStructure body;
  TCursorNode anchor;
  TCursorNode activeEnd;
  int numOfItems;
  TCurrency bodyCurr;
  TCurrency bodies[5];
  int i;

  for (i = 0; i < 5; i++)
    bodies[i] = 0;
  // 27/03/91 ensure we check the thing the selection is in
  if (checkAll)
  {
    bodies[0] = fBody;
    bodies[1] = fRightHeader;
    bodies[2] = (fLeftRightHdr ? fLeftHeader : 0);
    bodies[3] = fRightFooter;
    bodies[4] = (fLeftRightFtr ? fLeftFooter : 0);
    anchor = NULL;
    activeEnd = NULL;
  }
  else
  {
    selection = GetSelection(TRUE);
    activeEnd = selection->GetActiveRoot();
    anchor = selection->GetAnchorRoot();
    bodies[0] = anchor->fCurrency;
  }
  for (i = 0; i < 5; i++)
  {
    bodyCurr = bodies[i];
    if (bodyCurr != 0)
    {
      body = GetStructureReadOnly(bodyCurr); // 19/03/91 RW
      numOfItems = body->CountSelectedItems(bodyCurr, anchor, activeEnd, FALSE);
      ShowProgress(numOfItems);
      body->DoSpellCheck(bodyCurr, anchor, activeEnd);
      HideProgress();
    }
  }
}
#endif

#ifdef TABLES
// -------------------------------------------------------------------------
THandler _TTextDocument::CreateAHandler(TDialogView theDialog,
    TStyleFormat theStyle, TStyleFormat theChanges, TStyleTypes theType)
{
  return new _TStyleDlgHelper(theDialog, theStyle, theChanges, theType);
}
#endif

#ifdef MATHS
// 24/03/92 new
// -------------------------------------------------------------------------
void _TTextDocument::CheckAlign(TCurrency currency)
// flag the alignment set as needing recalculation
{
  if (Curr_fType(currency) == kMathStruct)
    fAlignList->CheckAlign(currency);
}
#endif

// ------------------------------------------------------------------------
static void AppendFontName(MenuHandle *aMenuHandle,
                                          char *menuText, char *styleName)
{
  int idx = AppendMenuItem(aMenuHandle,
                      menuText[0] == 0 ? GetString(kDefaultFontStr) : menuText);

  if (styleName != NULL && strcmp(menuText, styleName) == 0)
    CheckItem(*aMenuHandle, idx, TRUE);   // 07/09/94 use idx for CountMItems(*aMenuHandle)
}


// ------------------------------------------------------------------------
static void SetFontMenu(MenuHandle *aMenuHandle, FontTree *ptr,
                                        char *baseName, char *styleName)
{
  // work recursively until a terminal name found
  char fontName[48];

  while (ptr != NULL)
  {
    FontTree *childPtr = (FontTree *)ptr->info.childPtr;

    strcpy(fontName, baseName);
    if (baseName[0] != 0)
      strcat(fontName, ".");
    strcat(fontName, ptr->fonttext);

    if (childPtr != NULL)
    {
      if (ptr->info.terminal)
        AppendFontName(aMenuHandle, fontName, styleName);    // terminal name

      SetFontMenu(aMenuHandle, childPtr, fontName, styleName);// non terminal
    }
    else
      AppendFontName(aMenuHandle, fontName, styleName);      // terminal name

    ptr = (FontTree *)ptr->info.brotherPtr;
  }
}

// ------------------------------------------------------------------------
// new 03/11/92
bool _TTextDocument::SetupDynamicMenu(CmdNumber aCmdNumber, int menuNum, bool create)
{
  MenuHandle *theMenu = GetResMenu(menuNum);

  if (menuNum == cmFontSubmenu || (menuNum == cmFontMenu && (CheckInstalledFonts(), TRUE)))
  {
    DelMenuItems(theMenu, 1);
    if (create)
    {
      FontTree *ptr = (FontTree *)gFontHead.info.childPtr;
      char *styleName = fCurrentMenuFont > 0 ? GetFName(fCurrentMenuFont) : NULL;
                                                  // the one that needs to be ticked
      char aName[40];

      if (menuNum == cmFontMenu)
      {
        // this bit only for the font name array
        int nItem = 1;    // 16/01/94 0;
        char *p;

        // copy the font name 
        if (styleName != NULL)
        {
          for (p = aName; *styleName > 32 && *styleName != '.'; p++, styleName++)
            *p = *styleName;
          *p = 0;
          styleName = aName;
        }

        while (ptr != NULL)
        {
          AppendFontName(theMenu, ptr->fonttext, styleName);
          if (WindowBorder() && ptr->info.childPtr)
            SetDynamic(*theMenu, nItem, cmFontSubmenu); // 16/01/94 avoid menu private fields
          ptr = (FontTree *)ptr->info.brotherPtr;
          nItem++;
        }
      }
      else
      {
        int aMenu;
        int item;

        aMenu = CmdToMenuItem(aCmdNumber, item);
        GetItem(*GetResMenu(aMenu), item, aName);
        // 11/06/93 use SetMenuTitle: strncpy((*theMenu)->hdr.title, aName, 12);
        SetMenuTitle(*theMenu, aName);  // copy the hit item to submenu title
        while (ptr != NULL)
        {
          item--;
          if (item == 0)  // we have the matching entry - append the submenu data
          {
            // set styleName to be a pointer to termination of the font name
            item = strlen(aName);
            if (styleName != NULL && strncmp(styleName, aName, item) == 0)
                     // there is a tickable entry and its family name matches the style name
            {
              styleName += item;
              if (*styleName == '.')
                styleName++;
            }
            else
              styleName = NULL;  // do not put a tick in submenu

            if (ptr->info.terminal)
              AppendFontName(theMenu, "", styleName);   // add (Regular)
            SetFontMenu(theMenu, (FontTree *)ptr->info.childPtr, "", styleName);
            break;
          }
          ptr = (FontTree *)ptr->info.brotherPtr;
        }
      }
    }
  }
#if defined TABLES && ! defined NETWP
  else if (menuNum == cmLanguage)  // 05/11/92 dynamic Country menu (with sort)
  {
    DelMenuItems(theMenu, 2);
    if (create)
    {
      char countryName[kMaxLangNameLen + 1];
      int lang = fCurrentMenuLanguage;  // -2 for not defined, -1 for dimmed, 0 for None

      EnableCheck(cNoLanguage, TRUE, lang == 0);
      for (int item = 1; item <= 79; item++)
      {
        if (GetCountryName(item, countryName))
        // 21/11/91 implement sorted language menu
        {
           int mm = AddSortedCountry(theMenu, countryName, 1);  // 1 to ignore None in sort

           if (lang == item)
             CheckItem(*theMenu, mm, TRUE);
         }
      }
    }
  }
#endif
#ifdef TABLES
  else if (menuNum == cmStructureStyle || menuNum == cmSelStyle)
         // 20/06/93 [20949] styles on structure entry, 16/02/94 [21400] dynamic styles menu
  {
    DelMenuItems(theMenu, 1);
    if (create)
    {
      if (menuNum == cmSelStyle)
      {
        // 15/02/94 do Format->Styles menu dynamically, so can get different
        // variations from menu over button rather than standard menu
        // Note this uses fCurrentKind and fCurrentStyleCurr set up in DoSetupMenus
        // Need to call TestStyle, to get main style items then emphasis ones
        fStyleSheet->Each(fStyleSheet, (DoToItem)_TStyleSheet::TestStyle, NULL,
                theMenu, fCurrentKind, fCurrentStyleCurr);
        if (aCmdNumber != cSelStyleName)
        {
          // it is the pop-up on the icon bar
          int stdStyles = CountMItems(*theMenu);

          fStyleSheet->Each(fStyleSheet, (DoToItem)_TStyleSheet::TestStyle, theMenu,
                NULL, fCurrentKind, fCurrentStyleCurr);
          // if any emphasis styles added, add ---------
          if (stdStyles > 0 && stdStyles != CountMItems(*theMenu))
            SetSeparator(*theMenu, stdStyles); // 16/02/94 new menu function
        }
        if (fCurrentStyleCurr == -1)   // endstructure
          DisableMenu(cmSelStyle);
      }
      else
      {
        TStructTypes structType;
        TStyleTypes styleType;

        fLastStructCmdNum = aCmdNumber;        // 20/06/93 [20949]
        if (CmdToStruct(aCmdNumber, styleType, structType))
          fStyleSheet->Each(fStyleSheet, (DoToItem)_TStyleSheet::TestStyle, NULL, theMenu,
                                                         styleType, 0);
      }
    }
  }
#endif
  else
    return _TDocument::SetupDynamicMenu(aCmdNumber, menuNum, create);  // 10/02/96
  return TRUE;
}

// =========================== TStructureCmd ==============================
_TStructureCmd::_TStructureCmd(CmdNumber itsCmd, TTextDocument itsDocument) :
                                          (itsCmd, itsDocument, NULL, NULL)
{
  fDocument = itsDocument;
#ifndef ZERO_OBJ
  fChanges = NULL;
  fUndoSelection = NULL;
//  ClearRect(fCustom);  // 24/03/92
  fPosn = 0;
  fNewStart = 0;  // 08/09/92 moved from TNewStructureCmd
  fNewEnd = 0;
//  fSetCursor = FALSE;    // [20982]
#ifdef DRAGDROP
  fPastedObj = 0;
#endif
  fHasSplit = FALSE;
#endif
  fStructureChgd = TRUE;
}


// ------------------------------------------------------------------------
void _TStructureCmd::Free()
{
  if (fChanges != NULL)
    fDocument->Commit(fChanges, this);
  if (fUndoSelection != fChanges)         // 24/08/92
    FreeIfObject(fUndoSelection);
  FreeIfObject(fChanges);
  _TCommand::Free();
}


// ------------------------------------------------------------------------
static void DoUndo(TStructureCmd self, bool commit)
// 28/09/93 [21055] Undo with a parameter to commit (stops grabbing more mem after failure)
{
  TSelection selection;

  if (self->fStructureChgd)
  {
    TPages pages = self->fDocument->ActiveMainView()->fPages;  // 05/10/92

    self->fDocument->HighlightSelection(HLOff, TRUE);   // FALSE???
    selection = self->fDocument->GetSelection(FALSE);
    self->fDocument->ResetSelection(self->fChanges);
    self->fChanges->ToggleState(self);
#ifdef TRACE
    Assert (self->fChanges->fReformatType == kSelSlow, 832);
// 09/05/92 done in TSelection::ToggleState:    fChanges->fReformatType = kSelSlow;
#endif
    if (commit)                // 28/09/93 [21055]
      DoStructCommit(self->fDocument, self->fChanges, self);
    else
      self->fDocument->Reformat();
    self->fDocument->ResetSelection(self->fUndoSelection);

    if (commit)                // 28/09/93 [21055] now reformat after commit
      self->fDocument->Reformat();
    while (pages->fPageToDraw > 0)      // 05/10/92
      pages->DoIdle();
    self->fUndoSelection->SelectLevel(-2); // 27/11/91 get rid of endStructure if set
    self->fUndoSelection->fChanged = TRUE;
    self->fDocument->ScrollSelectionIntoView();
    self->fDocument->HighlightSelection(HLOn, TRUE);  // 20/06/91 frm FALSE
                 // if set to False, Undo Structure->Picture with
                 // some text selected does not put highlight back
                                         // 25/04/91 from TRUE

    if (commit)                // 28/09/93 [21055] tidy up ready for the Free()
    {
      if (selection != self->fChanges)         // 24/08/92
        FreeIfObject(self->fChanges);
      self->fChanges = NULL;
    }
    self->fUndoSelection = selection;
    self->fDocument->SetCurrentStyle();
  }
}


// ------------------------------------------------------------------------
void _TStructureCmd::DoIt()
{
  TSelection selection;
  volatile TSelection selectionClone;  // 16/09/92
  FailInfo fi;

  selection = fDocument->GetSelection(TRUE);
  fDocument->EndInteractive();
// 08/02/91  fDocument->ScrollSelectionIntoView(TRUE);
  if (fStructureChgd)
  {
    fUndoSelection = selection;
    fDocument->HighlightSelection(HLOff, TRUE);  // FALSE???
  }
  selectionClone = TSelection(selection->Clone());

  CatchFailures(&fi);
  DoCommand(selectionClone);                                 // 16/09/92 pass clone
  // 16/09/92 selectionClone is either in document or no longer required
  if (fDocument->GetSelection(FALSE) != selectionClone)
    FreeIfObject(selectionClone);
  selectionClone = NULL;

  if (fStructureChgd)
  {
    selection = fDocument->GetNewSelection();  // 11/08/92 moved up
    fChanges = selection;                      // 11/08/92 moved up
    FailSpaceIsLow();           // 24/08/92 moved here so Commit called by Free if failure
    fDocument->Reformat();
    DoPostCommand();

    selection = fDocument->GetNewSelection();
    fDocument->ScrollSelectionIntoView();
    fDocument->HighlightSelection(HLOn, TRUE);  // FALSE???
    if (!gSelNewStructs)           // 14/07/93 [20982] Select new structures
      selection->DoMenus(TRUE);    // this should have been done by all the DoPostCommands
  }
  FailSpaceIsLow();         // 03/08/92 hopefully stop failures in Commit
  Success(&fi);
  return;

// *********** exception handler *********
Rescue:
  if (fDocument->GetSelection(FALSE) != selectionClone)
    FreeIfObject(selectionClone);         // 16/09/92

  if (fStructureChgd)
  {
    if (fChanges != NULL)      // 11/08/92 new block for failures after DoCommand
    {
      fDocument->ActiveMainView()->DeleteSubViews();  // may have failed in making views
      fCmdDone = !fCmdDone;    // 11/08/92 - tested by ToggleState
      DoUndo(this, TRUE);
      // UndoIt();
      fCmdDone = !fCmdDone;    // 11/08/92 - reset it
    }
    else  // it failed in DoCommand
    {
      fDocument->ResetSelection(fUndoSelection);
      fUndoSelection = NULL;      // do not free in Free
      fDocument->HighlightSelection(HLOn, TRUE);      // FALSE??? // 26/07/90
      fDocument->SetTextHandler();  // 28/05/90
    }
  }
  ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
void _TStructureCmd::UndoIt()
{
  DoUndo(this, FALSE);
}

// ------------------------------------------------------------------------
void _TStructureCmd::RedoIt()
{
  UndoIt();
}

#ifdef TRACE
// ------------------------------------------------------------------------
void _TStructureCmd::DoCommand(TSelection selection)
{
  NotYetImplemented("TStructureCmd::DoCommand");
}

// ------------------------------------------------------------------------
void _TStructureCmd::DoPostCommand(void)
{
  NotYetImplemented("TStructureCmd::DoPostCommand");
}

#ifdef DRAGDROP
// ------------------------------------------------------------------------
void _TStructureCmd::SetDropCurrency(TCurrency currency)
{
}

// ------------------------------------------------------------------------
TCurrency _TStructureCmd::GetDropCurrency(void)
{
  return 0;
}
#endif
#endif

// ------------------------------------------------------------------------
_TTextHandler::_TTextHandler(TTextDocument itsDocument) : (NULL)
{
  fDocument = itsDocument;
#ifndef ZERO_OBJ
  fSelection = 0;
  fCanType = FALSE;
  fControlChars = 0;
#ifndef SUPER
  fStyleChanges = NULL;
  fStyleCmd = 0; // 6/5/92
#endif
#endif
}


/* 01/04/92 ------------------------------------------------------------------------
void _TTextHandler::ResetTarget(TSelection selection)
{
}
*/

// ------------------------------------------------------------------------
void _TTextHandler::SetTarget(TSelection selection)
{
  TView view;
  TCurrency currency;
  TStructure target;
  TCursorNode targetNode;
  ControlCharSet controls;
  TWindow wdw;

  fSelection = selection;
  if (selection == NULL) // 28/05/90 - this blk new
  {
    view = fDocument->ActiveMainView();
    wdw = view->GetWindow();
    wdw->SetTarget(fDocument);
  }
  else
  {
    if (selection->fEndStructure)
      targetNode = selection->GetEndStructure();
    else
      targetNode = selection->GetAnchorOwner();

    currency = targetNode->fCurrency;
    target = fDocument->GetStructureReadOnly(currency); // 21/03/91 RW
    view = fDocument->FindActiveView(targetNode);
    if (view == NULL /* 25/11/91 avoid Assert: && selection->fViewId.tag.fSubId != 0 */)
    {
      view = fDocument->ActiveMainView();
      fCanType = FALSE;
    }
    else
    {
// 25/11/91     Assert(view != 0, kNoView1);
      fCanType = target->CanType();
    }
    // 17/02/94 [21398] get selection viewId set up so Reformat does H/Fs for OLE in H/Fs
    if (selection->fViewId.fId == kNewCursor)
      selection->fViewId.fId = selection->GetAnchorRoot()->fIdentifier;

#ifdef VIEWACT
    if (!TSubView(view)->fMainView->fViewActive)
      wdw = NULL;
    else
#endif
      wdw = view->GetWindow();

    if (fCanType)
    {
      fNextHandler = view;
      if (wdw != NULL)
        wdw->SetTarget(this);
      controls = ((1 << chBackspace) | (1 << chLineFeed) |
           (1 << chReturn) | (1 << chTab) | (1 << chFwdDelete)
           /* | (1 << chInsert) */);
      target->GetControlChars(target, targetNode, controls);
      fControlChars = ~controls;  // ie ffffffff - controls -- 01/06/90
    }
    else if (wdw != NULL)
      wdw->SetTarget(view);
  }
}

#ifdef TRACE
// ------------------------------------------------------------------------
void _TTextHandler::DoneTyping()
{
  NotYetImplemented("TTextHandler::DoneTyping");
}
#endif

// *************************************************************************
#ifndef NETWP
// -------------------------------------------------------------------------
static bool CanUpdateBlock(TTextDocument doc, TControlBlock controlBlock, wr_wimp_msgstr *msg)
{
  if (msg->data.words[0] == controlBlock->fBlockType)
    return TRUE;
  return FALSE;
}
#endif 

#if TALK == 1
// -------------------------------------------------------------------------
static int FindWordAtCursor(TTextDocument doc, wr_wimp_msgstr *msg, int word0, int word1)
{
  // get word at caret and return it
  EventInfo info;
  TSelection selection;
  TSelection selectionClone = NULL;
  TCursorNode cursor;
  int wordLen;
  int arrowKey = 0;

  msg->data.words[0] = word0;
  msg->data.words[1] = word1;

  app_GetEventInfo(&info, (wr_wimp_eventstr *)((char *)msg - 4));
  if (word1 >= 0)
  {
    doc->CloneSelection();
    doc->DoneTyping();
    word1 &= 0x0ff;
    if ((msg->data.words[1] & 0x100) != 0)
    {
      // word1 &= 0x0ff;
      if (word1 == 2 || word1 == 8)
        arrowKey = 0x19f;  // move to start of sentance
      else if (word1 == 4)
        arrowKey = 0x1af;  // move to start of document
      msg->data.words[1] &= 0xfffffeff;
    }
  }
  selection = doc->GetNewSelection();
  if (word1 == 8 || (word0 < 0 && (arrowKey = 0x18c, TRUE)))
  {
    selectionClone = selection = TSelection(selection->Clone());
    // arrowKey = 0x18c;  // move back one position
  }
  cursor = selection->GetAnchorTarget();
  if (arrowKey != 0)
  {
    TMainView mainView = doc->ActiveMainView();

    selection->SetTheCursor(TRUE);
    if (arrowKey == 0x18c)
      mainView->GetFormatReadOnly(cursor->fCurrency)->
                             MoveCursor(cursor, arrowKey, info);  // secret move
    else
      selection->MoveCursor(arrowKey, info, mainView);  // else redraw it
    cursor = selection->GetAnchorTarget();
    if (word1 >= 0 && word1 < 2)
    {
      mainView->GetFormatReadOnly(cursor->fCurrency)->
                              MoveCursor(cursor, 0x19d, info); // mv to end of wd
      cursor = selection->GetAnchorTarget();
    }
  }
  if (word1 >= 2) // 8 too? && word1 <= 5) // (word1 & 0xfffffffe) == 4)
  {
    // 15/01/96 move over blank lines in speak whole document/sentence.
    selection->MoveCursor(0x185, info, doc->ActiveMainView());
    cursor = selection->GetAnchorTarget();
  }
  wordLen = doc->GetStructureReadOnly(cursor->fCurrency)->GetWordAtCaret(cursor,
                 selectionClone ? doc->GetNewSelection()->GetAnchorTarget() : NULL, msg);
  // if (word0 < 0)
  FreeIfObject(selectionClone);
  return wordLen;
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
static void DoesOwnKey(TTextDocument doc, TControlBlock controlBlock, int chcode, int mask)
{
  wr_wimp_msgstr msg;
  TControlBlock docControlBlock;

  // if there is a controlBlock for the current block type in the document, use that
  // otherwise use the default controlBlock in the application
  msg.data.words[0] = controlBlock->fBlockType;
  if (doc->fControlBlockList != NULL &&
         (docControlBlock = TControlBlock(doc->fControlBlockList->
                           LastThat(doc, (TestObject)CanUpdateBlock, &msg))) != NULL)
    controlBlock = docControlBlock;

  if (controlBlock->OwnsKey(mask))
  {
#if TALK == 1
    // 20/09/94 message now includes the current word if likely to be needed by talker
    int wordLen = (chcode >= 256 || isalnum(chcode) ? 0 :
                                       FindWordAtCursor(doc, &msg, -1, -1));

    msg.hdr.size = (wordLen == 0 ? 32 : ((36 + wordLen) / 4) * 4) + controlBlock->fDataSize;
    memmove(msg.data.chars + 12 + controlBlock->fDataSize, msg.data.chars + 12, wordLen + 1);
#else
    msg.hdr.size = controlBlock->fDataSize + 32;
#endif
    msg.data.words[1] = chcode;
    msg.hdr.action = EasiWrite_DoKeyCommand;
    msg.hdr.my_ref = 0;  // not a specific reply
    controlBlock->SendReply(doc, &msg);
  }
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
void _TTextDocument::SendKeyToUtil(int chcode)
{
   int mask = (chcode >= 0x100 ? 0x100 : __ctype[chcode]);

   if ((mask & fEnableKeys) != 0)
      gControlBlockList->Each(this, (DoToObject)DoesOwnKey, chcode, mask);
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
static void SetControlBlockMenus(TObject ignore, TControlBlock controlBlock,
                                           int *enabledKeys, int forDoc)
{
   controlBlock->DoSetUpMenus(forDoc, enabledKeys);
}
#endif

// -------------------------------------------------------------------------
void _TTextDocument::DoSetupMenus()
{
#ifdef NETWP
  _TDocument::DoSetupMenus();
  EnableCheck(cStartKeySelection, TRUE, GetNewSelection()->fKeyExtend);
#else
  gEnableKeys = 0;   // TApplication will set up key mask for 'default' documents

  _TDocument::DoSetupMenus();

  fEnableKeys = gEnableKeys;
  if (fControlBlockList != NULL)
    fControlBlockList->Each(this, (DoToObject)SetControlBlockMenus, &fEnableKeys, TRUE);
#endif
}

#ifndef NETWP
// -------------------------------------------------------------------------
static bool CanReplyToMsg(TTextDocument doc, TControlBlock controlBlock,
                  wr_wimp_msgstr *msg, int blockType)
{
   if (blockType == controlBlock->fBlockType)
      return controlBlock->SendReply(doc, msg);
   return FALSE;
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
static void GetDocMenuData(TObject ignore, TTextDocument doc, wr_wimp_msgstr *msg,
                                                   wr_wimp_t sender, int blockType)
// msg is a UtilityStarting message, so go through each open doc with block type
{
   msg->hdr.task = sender;
   if (doc->fControlBlockList != NULL)
     doc->fControlBlockList->LastThat(doc, (TestObject)CanReplyToMsg, msg, blockType);
}
#endif

#ifndef NETWP
typedef struct THitData
{
   TTextDocument doc;
   TControlBlock controlBlock;
   int msgId;
   int adjust;
}  THitData;
typedef THitData *PHitData;

// -------------------------------------------------------------------------
static bool HitHandler(wr_wimp_eventstr *e, void *handle)
{
   bool handled = FALSE;   /* unknown not dealt with */
   int testRef = (e->e == wr_wimp_EACK ? e->data.msg.hdr.my_ref : e->data.msg.hdr.your_ref);

   if (testRef == PHitData(handle)->msgId)
   {
      // its our reply or (maybe) not an 17, 18, 19 msg
      TTextDocument doc = PHitData(handle)->doc;
      TControlBlock controlBlock = PHitData(handle)->controlBlock;

      if (e->e == wr_wimp_ESEND || e->e == wr_wimp_ESENDWANTACK)
      {
         wr_wimp_msgstr *msg = &e->data.msg;

         switch (msg->hdr.action)
         {
            case EasiWrite_DoSetupMenusAck:
               // update the menu data unless just an acknowlegement
               if (msg->hdr.size > 20)
                 controlBlock->UpdateMenus(doc, msg);
               if (PHitData(handle)->adjust)
                 ResetMenu();
               // if adjust ResetMenu();
               handled = TRUE;
               break;

            case EasiWrite_UtilityQueryAck:  // Ok to continue, there is something out there
               // msg->data.words[0] = 0;
               memcpy(msg->data.words + 1, controlBlock->fData, controlBlock->fDataSize);
               // msg->hdr.size = controlBlock->fDataSize + 24;
               // msg->hdr.action = EasiWrite_DoSetupMenus;
               // msg->hdr.your_ref = msg->hdr.my_ref;
               // wr_wimp_sendmessage(wr_wimp_ESENDWANTACK, msg, msg->hdr.task);
               SendmessageWantAck(EasiWrite_DoSetupMenus, msg,
                                     controlBlock->fDataSize + 24, &PHitData(handle)->msgId);
               // PHitData(handle)->msgId = msg->hdr.my_ref;
               return TRUE;
         }
      }
      else if (e->e == wr_wimp_EACK)
      {
         /* bounced HandleHit etc. */
         switch (e->data.msg.hdr.action)
         {
            case EasiWrite_DoSetupMenus:  // Oh dear! Maybe should remove menu entries
               controlBlock->UpdateMenus(doc, NULL);
            case EasiWrite_UtilityQuery:
               handled = TRUE;
               break;
         }
      }

      if (handled)
      {
         wr_win_remove_unknown_event_processor(HitHandler, handle);
         DisposIfHandle(handle);
      }
   }
   return handled;
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
static void MakeHitHandler(TTextDocument doc, TControlBlock controlBlock, wr_wimp_msgstr *msg)
// message of msg can be HandleHit or GiveMenuData
{
  wr_wimp_mousestr m;
  Handle handle = NewHandle(sizeof(THitData));

  wr_wimpt_noerr(wr_wimp_get_point_info(&m));
  PHitData(handle)->doc = doc;
  PHitData(handle)->controlBlock = controlBlock;
  PHitData(handle)->adjust = wr_wimp_BRIGHT & m.bbits;

  msg->hdr.your_ref = 0;
  wr_wimp_sendmessage(wr_wimp_ESENDWANTACK, msg, msg->hdr.task);
                         // send to task/broadcast recorded delivery
  PHitData(handle)->msgId = msg->hdr.my_ref;
  wr_win_add_unknown_event_processor(HitHandler, handle);
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
static void Adieu()
{
  /*---- tell the world I am no longer here ---*/
  wr_wimp_msgstr msg;

#ifdef MATHS
  msg.data.words[0] = 4;  // TechWriter closing
#else
#ifdef TABLES
  msg.data.words[0] = 2;  // EasiWriter closing
#else
#if SIDEBAR == 1
  msg.data.words[0] = 1;  // TalkWrite closing
#else
  msg.data.words[0] = 8;  // StartWrite closing
#endif
#endif
#endif
  wr_wimpt_noerr(Broadcast(EasiWrite_AppnClosing, &msg, sizeof(wr_wimp_msghdr) + 4));
}
#endif

// -------------------------------------------------------------------------
_TTextApplication::_TTextApplication(OSType itsMainFileType) : (itsMainFileType)
{
#ifndef NETWP
   gControlBlockList = NewList();
   atexit(Adieu);
#endif
}

#ifndef NETWP
// -------------------------------------------------------------------------
static bool DoesOwnCommand(TObject ignore, TControlBlock controlBlock, CmdNumber aCmdNumber)
{
  return controlBlock->OwnsCommand(aCmdNumber);
}
#endif

// -------------------------------------------------------------------------
TCommand _TTextApplication::UnrecognisedCommand(EventInfo &info, CmdNumber aCmdNumber)
{
#ifdef NETWP
   return _TApplication::UnrecognisedCommand(info, aCmdNumber);
#else
   wr_wimp_msgstr msg;

   msg.hdr.task = 0;  // send as a broadcast
   if (info.document != NULL)
   {
      TControlBlock controlBlock;

      controlBlock = TControlBlock(TTextDocument(info.document)->fControlBlockList->
                       LastThat(NULL, (TestObject)DoesOwnCommand, aCmdNumber));
      if (controlBlock == NULL)
         controlBlock = TControlBlock(gControlBlockList->
                       LastThat(NULL, (TestObject)DoesOwnCommand, aCmdNumber));
 
      if (controlBlock != NULL)
      {
         msg.data.words[1] = aCmdNumber;
         msg.hdr.action = EasiWrite_DoMenuCommand;
         msg.hdr.my_ref = 0;  // not a specific reply
         controlBlock->SendReply(TTextDocument(info.document), &msg);
         return gNoChanges;
      }
   }
   msg.data.words[0] = aCmdNumber;
   wr_wimpt_noerr(Broadcast(EasiWrite_HandleHit, &msg, 24));
   return gNoChanges;
#endif
}

// -------------------------------------------------------------------------
void _TTextApplication::DoSetupMenus()
{
#ifdef NETWP
   _TApplication::DoSetupMenus();
#else
   // gEnableKeys should be zeroised at start of document DoSetupMenus() method
   // and then saved as a document field at the end of the method
   int ignore;

   _TApplication::DoSetupMenus();

   // enable/disable menu entries for icon bar, ignore keys for icon bar setting
   gControlBlockList->Each(NULL, (DoToObject)SetControlBlockMenus, &ignore, FALSE);

   // enable/disable menu entries for a document with no controls of its own
   // these will obviously be overwritten by the document DoSetupMenus if necessary
   gControlBlockList->Each(NULL, (DoToObject)SetControlBlockMenus, &gEnableKeys, TRUE);
#endif
}

// -------------------------------------------------------------------------
bool _TTextApplication::HandleMsgEvent(EventInfo &info)
{
#ifdef NETWP
   return _TApplication::HandleMsgEvent(info);
#else
   wr_wimp_msgstr *msg = &info.event->data.msg;
   int aMenu = 1;
   int anItem;
   wr_wimp_t sender = 0;
   int blockType;
   int sendText = FALSE;

   switch (msg->hdr.action)
   {
      case EasiWrite_UtilityStarting:    // 17/03/94 set for utility menu setup
        aMenu = CmdToMenuItem(msg->data.words[1], anItem);
        sender = msg->hdr.task;   // for EasiWrite_UtilityStarting reply to sender

      case EasiWrite_UtilityClosing:
        if (aMenu >= 0)
        {
          blockType = msg->data.words[0];
          // this controlBlock will hold the default options, icon bar menu settings
          // and the menu settings corresponding to the default setting
          TControlBlock controlBlock = TControlBlock(gControlBlockList->
                                 LastThat(this, (TestObject)CanUpdateBlock, msg));

          if (!controlBlock)
          {
             controlBlock = new _TControlBlock();
             gControlBlockList->InsertLast(controlBlock);
          }

          // copy default block & request menu data for the default document case
          controlBlock->SetData(TTextDocument(-1), msg);

          // for each open document, if it contains matching data, getmenudata
          gDocList->Each(this, (DoToObject)GetDocMenuData, msg, sender, blockType);

          msg->hdr.size = 20;   // request the application menu data
          msg->hdr.task = sender;
          // response message already set to EasiWrite_DoSetupMenus
          MakeHitHandler(NULL, controlBlock, msg);
          // send me the icon bar menu data corresponding to options in utility

          // mark Application menu for update
          RenameDocument();   // set gIconBarIsSetup = FALSE;
          FinishIdle(); // ensure menus set up on next idle
          return TRUE;  // affects menus in current window (should not get an idle
                        // until all the above messages have been responded to!)
        }
        break;

      case EasiWrite_UpdateControlBlock:
        // utility has sent a request to update control block for this document
        if (msg->hdr.size > 24)
        {
          TTextDocument doc = TTextDocument(msg->data.words[2]);

          // ensure we have a document with the supplied handle
          if (gDocList->GetSameItemNo(doc))
          {
            TControlBlock controlBlock;

            if (doc->fControlBlockList == NULL)
            {
              doc->fControlBlockList = NewList();
              controlBlock = NULL;
            }
            else
              controlBlock = TControlBlock(doc->fControlBlockList->
                                 LastThat(this, (TestObject)CanUpdateBlock, msg));
            if (!controlBlock)
            {
              // create a new control block if none found
              controlBlock = new _TControlBlock();
              doc->fControlBlockList->InsertLast(controlBlock);
            }
            controlBlock->SetData(doc, msg);
          }
          return TRUE;
        }           
        RenameDocument(); // set gIconBarIsSetup to indicate the icon bar menu needs updating
        break;

#if TALK == 1
#define EasiWrite_MoveCursor 0x83250
      case EasiWrite_GetText:
        sendText = TRUE;
      case EasiWrite_MoveCursor:
        {
          TTextDocument doc = TTextDocument(msg->data.words[2]);

          // ensure we have a document with the supplied handle
          if (gDocList->GetSameItemNo(doc))
          {
            if (!sendText)
            {
              // move by amount in msg
              //if (msg->data.words[0] != 0)
                doc->GetNewSelection()->MoveCursor(0x18d, info, doc->ActiveMainView());
              sendText = msg->data.words[1];
              msg->data.words[0] = 1;
              msg->data.words[1] |= 1;
            }
            if (sendText)
            {
              // get word at caret and return it
              int temp = gPrinting;
              int wordLen;

              if ((msg->data.words[1] & 0xff) == 8)
                gPrinting = TRUE;  // frig to suppress cursor movement
              wordLen = FindWordAtCursor(doc, msg, msg->data.words[0], msg->data.words[1]);
              gPrinting = temp;
              // msg->hdr.size = (wordLen == 0 ? 20 : ((36 + wordLen) / 4) * 4);
              // msg->hdr.action = EasiWrite_PutText;
              // wr_wimpt_noerr(wr_wimp_sendmessage(wr_wimp_ESEND, msg, msg->hdr.task));
              wr_wimpt_noerr(Sendmessage(EasiWrite_PutText, msg,
                       wordLen == 0 ? 20 : ((36 + wordLen) / 4) * 4));
            }
          }
        }
        break;
#endif

      default:
        return _TApplication::HandleMsgEvent(info);
   }
   info.affectsMenus = FALSE;      // 11/05/90
   return FALSE;
#endif
}

// *************************************************************************
_TControlBlock::_TControlBlock() : ()
{
#ifndef ZERO_OBJ
   fMenuData[0] = NULL;  // menu data for icon bar
   fMenuData[1] = NULL;  // menu data corresponding to fData
   fEnableKeystrokes = 0;
   fIgnored = 0;
   fDataSize = 0;
   fBlockType = 0;
#endif
}

// -------------------------------------------------------------------------
void _TControlBlock::Free()
{
#ifndef NETWP
   DisposIfHandle(fMenuData[0]);
   DisposIfHandle(fMenuData[1]);
#endif
   _TObject::Free();
}

#ifndef NETWP
// -------------------------------------------------------------------------
void _TControlBlock::SetData(TTextDocument doc, wr_wimp_msgstr *msg)
// called when a UtilityStarting, or UpdateControlBlock sent
// doc may be -1 if default menu data (for future and current 'new' docs) is required
{
   if (fDataSize == 0)
   {
      if (msg->hdr.size >= 32)
      {
        fDataSize = msg->hdr.size - 32;    // this is the first call
        SetHandleSize(&this, sizeof(_TControlBlock) - sizeof(fData) + fDataSize);
      }
      fBlockType = msg->data.words[0];
   }
   msg->hdr.action = EasiWrite_DoSetupMenus;
   memcpy(fData, msg->data.words + 3, fDataSize);
   SendReply(doc, msg);
          // give me back the menu data corresponding to saved options
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
void _TControlBlock::UpdateMenus(TTextDocument forDoc, wr_wimp_msgstr *msg)
// extract the menu encoding from a EasiWrite_DoSetupMenusAck, release data is msg == NULL
// forDoc == NULL for icon bar menu, -1 for default doc menu, or document it applies to
{
   int handleSize;
   Handle newData;
   Handle *menuPtr = &fMenuData[forDoc != NULL];
   Handle oldData = *menuPtr;

   if (msg == NULL)
   {
     newData = NULL;
     fEnableKeystrokes = 0;
   }
   else
   {
     if (forDoc != NULL)     // avoid icon bar message overwriting doc key flags
       fEnableKeystrokes = msg->data.words[0];

     handleSize = msg->hdr.size - 24;
     newData = NewHandle(handleSize);
     if (newData != NULL)
       newData = memcpy(newData, msg->data.words + 1, handleSize);
   }
   *menuPtr = newData;
   DisposIfHandle(oldData);
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
int _TControlBlock::SendReply(TTextDocument doc, wr_wimp_msgstr *msg)
{
   if (msg->hdr.action == EasiWrite_DoSetupMenus)
   {
      // msg->data.words[0] = 0;
      memcpy(msg->data.words + 1, fData, fDataSize);
      msg->hdr.size = fDataSize + 24;
      MakeHitHandler(doc, this, msg);   // send menu data corresponding to saved options
   }
   else
   {
      // EasiWrite_DoMenuCommand, EasiWrite_DoKeyCommand,
      if (msg->hdr.action != EasiWrite_DoKeyCommand)   // size set up in DoesOwnKey
        msg->hdr.size = fDataSize + 32;
      msg->data.words[0] = (int)fBlockType;
      msg->data.words[2] = (int)doc;
      memcpy(msg->data.words + 3, fData, fDataSize);
      msg->hdr.your_ref = msg->hdr.my_ref;
      wr_wimp_sendmessage(wr_wimp_ESEND, msg, 0);
   }
   return TRUE;
}
#endif

// -------------------------------------------------------------------------
void _TControlBlock::DoRead(TTextDocument doc, int aRefNum, int version)
{
#ifndef NETWP
   wr_wimp_msgstr msg;
#endif

   FRead(aRefNum, 2, &fDataSize);
   FRead(aRefNum, fDataSize, fData);
   SetHandleSize(&this, sizeof(_TControlBlock) - sizeof(fData) + fDataSize);
#ifndef NETWP
   msg.hdr.action = EasiWrite_UtilityQuery;
   msg.hdr.size = 24;
   msg.hdr.task = 0;    // send as broadcast
   msg.data.words[0] = fBlockType;
   MakeHitHandler(doc, this, &msg);  // get (any) listening utility to set menus from block
#endif
}

// -------------------------------------------------------------------------
void _TControlBlock::DoWrite(int aRefNum)
{
   FWrite(aRefNum, fDataSize + 2, &fDataSize);
}

// -------------------------------------------------------------------------
void _TControlBlock::DoNeedDiskSpace(long *neededSpace)
{
   *neededSpace += fDataSize + 2;
}

#ifndef NETWP
typedef struct TMenuEncoding
{
  unsigned int cmdNum:16;
  unsigned int flag7:1;
  unsigned int flag6:1;
  unsigned int flag5:1;
  unsigned int flag4:1;
  unsigned int flag3:1;
  unsigned int flag2:1;
  unsigned int ticked:1;
  unsigned int enabled:1;
  unsigned int entryLen:8;
} TMenuEncoding;

// -------------------------------------------------------------------------
void _TControlBlock::DoSetUpMenus(int forDoc, int *enableKeys)
{
   char *p = (char *)fMenuData[forDoc];

   *enableKeys |= fEnableKeystrokes;

   if (p != NULL)
   {
     void *endPtr = p + GetHandleSize(p);

     while (p < endPtr)
     {
       int entryLen;
       TMenuEncoding *menuData = (TMenuEncoding *)p;

       p += 4;
       EnableCheck(menuData->cmdNum, menuData->enabled, menuData->ticked);
       entryLen = menuData->entryLen - 4;
       if (entryLen > 0)
       {
         char buffer[200];

         strcpyn(buffer, p, entryLen);
         p += entryLen;
         SetCmdName(menuData->cmdNum, buffer);
       }
     }
   }
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
bool _TControlBlock::OwnsCommand(int aCmdNumber)
{
   char *p = (char *)(fMenuData[1]);

   if (p != NULL)
   {
      void *endPtr = p + GetHandleSize(p);

      while (p < endPtr)
      {
         TMenuEncoding *menuData = (TMenuEncoding *)p;

         if (menuData->cmdNum == aCmdNumber && menuData->enabled)
            return TRUE;
         p += menuData->entryLen;
      }
   }
   return FALSE;
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
bool _TControlBlock::OwnsKey(int mask)
{
   if ((fEnableKeystrokes & mask) != 0)
      return TRUE;

   return FALSE;
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
void ReallocControlBlocks()
{
   for (int i = 0; i < gControlBlockList->GetSize(); i++)
   {
      TControlBlock *controlBlock = (TControlBlock *)gControlBlockList->fPtrToList + i;

      ReAllocHandle(controlBlock);
      ReAllocHandle((*controlBlock)->fMenuData);
      ReAllocHandle((*controlBlock)->fMenuData + 1);
   }

   gControlBlockList->ReAllocate();
}
#endif
