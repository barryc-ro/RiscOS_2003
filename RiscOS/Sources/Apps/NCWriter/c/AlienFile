/************************************************************************/
/* © Icon Technology, Ltd, 1996.                                        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "drawfdiag.h"
#include "drawfobj.h"
#include "drawftypes.h"
#include "swis.h"
#include "win.h"
#include "event.h"

#include "UTextEdit.h"
#include "UBodyEdit.h"
#include "UPictEdit.h"
#include "UMathEdit.h"
#include "UClipBrd.h"
#include "UExpressn.h"
#include "UColEdit.h"
#include "UTablEdit.h"
#include "DrawIFace.h"
#include "PDocument.h"
    /* 12/10/92 should not use this */
#ifdef INDEX
#include "UIndex.h"
#endif

#ifdef WORD7
#include "MSWord.h"
    // if overlaid, have to duplicate table in each referencing overlay!
char ggMacToArc[128] = {
0xc4, 0xc5, 0xc7, 0xc9, 0xd1, 0xd6, 0xdc, 0xe1, 0xe0, 0xe2, 0xe4, 0xe3, 0xe5, 0xe7, 0xe9, 0xe8,
0xea, 0xeb, 0xed, 0xec, 0xee, 0xef, 0xf1, 0xf3, 0xf2, 0xf4, 0xf6, 0xf5, 0xfa, 0xf9, 0xfb, 0xfc,
0x9c, 0xb0, 0xa2, 0xa3, 0xa7, 0x8f, 0xb6, 0xdf, 0xae, 0xa9, 0x8d, 0xb4, 0xa8, 0xd7, 0xc6, 0xd8,
0xb2, 0xb1, 0xb9, 0xb3, 0xa5, 0xb5, 0xf0, 0xd0, 0xde, 0xfe, 0xbc, 0xaa, 0xba, 0xfd, 0xe6, 0xf8,
0xbf, 0xa1, 0xac, 0x80, 0xbe, 0x83, 0x84, 0xab, 0xbb, 0x8c, 0xa0, 0xc0, 0xc3, 0xd5, 0x9a, 0x9b,
0x97, 0x98, 0x94, 0x95, 0x90, 0x91, 0xf7, 0xa6, 0xdd, 0xff, 0xbd, 0xa4, 0x92, 0x93, 0x9e, 0x9f,
0x9d, 0xb7, 0x86, 0x96, 0x8e, 0xc2, 0xca, 0xc1, 0xcb, 0xc8, 0xcd, 0xce, 0xcf, 0xcc, 0xd3, 0xd4,
0x81, 0xd2, 0xda, 0xdb, 0xd9, 0x88, 0xad, 0x89, 0xaf, 0x8a, 0x8b, 0x85, 0xb8, 0x82, 0x87, 0x99 };

static char ggWindowsToArc[] = "\x83\x9e\x9f\x96\x8c\x9c\x9d\x86\x8e\x81\x92\x9a\x84\x87\x88\x89\x90\x91\x94\x95\x8f\x97\x98\x99\x8d\x82\x93\x9b\x8a\x8b\x85";

#define Load2Byte(i2, p) { i2 = *(p++); i2 += (*(p++) << 8); }
#endif

#define kUnitsArrayID 4

#define kEditFileReturn 10
#define kEditFileLF 13
#define kFormFeed ('\f')
#define kNoScrapFound 32
#define kRecvFailed 33

// -----------------------------------------------------------------------
typedef struct TEmphInfo
{
  int startRun;
  int endRun;
  TStyleFormat style;
  int type;
} TEmphInfo;

typedef enum
{
 recv_state_Ask,
 recv_state_Talk,
 recv_state_Done,
 recv_state_Broken
} recv_stateval;

/* 15/03/93 removed the use of static data - except for fileissafe (which needs doing) */
typedef struct TransferData
{
  char *recv_buffer;
  int recv_buffersize;
  recv_stateval recv_state;
  int recv_msgid;
  int origMsg[10]; // words 1-10 incl of DataSave in case need to resend a DataSaveAck
} TransferData;

static TObject gBouncedSeln = NULL;
static int     gBouncedType = 0;

#ifdef PRO
static char gMaxLineLenStr[4];
static char gTextLfStr[4];
static char gTextCrStr[4];
static char gTabExpandStr[4] = "8";
static char *gMaxLineLen = NULL;
static char *gTextLf = NULL;
static char *gTextCr = NULL;
static char *gTabExpand = NULL;
#endif

extern bool wr_check_Draw_file(char *buffer, int length, int *code, int *location);

// ------------------------------------------------------------------------
void InitAlienFile()
{
#ifdef PRO
   char *aRsrc;

   aRsrc = GetRsrcOption('e');
   if (aRsrc != NULL)
      gTextCr = strncpy(gTextCrStr, aRsrc, 4);
   SetRsrcOption('e', &gTextCr);

   aRsrc = GetRsrcOption('k');
   if (aRsrc != NULL)
      gTextLf = strncpy(gTextLfStr, aRsrc, 4);
   SetRsrcOption('k', &gTextLf);

   aRsrc = GetRsrcOption('t');
   if (aRsrc != NULL)
      gTabExpand = strncpy(gTabExpandStr, aRsrc, 4);
   SetRsrcOption('t', &gTabExpand);

   aRsrc = GetRsrcOption('m');
   if (aRsrc != NULL)
      gMaxLineLen = strncpy(gMaxLineLenStr, aRsrc, 4);
   SetRsrcOption('m', &gMaxLineLen);
#endif
}

// =========================================================================
// EXTERNAL RAM/FILE LOADING (when a file dropped on you - 08/05/90)
// =========================================================================
// 27/06/90 rewritten to overcome a suspected problem in wr_wimp_transferblock
// when passed a buffer in our heap area

#define ABIT 1024

typedef struct TBufferData
{
  char buff[ABIT];  // intermediate buffer, as heap block causes problem
  Handle *hdl;
  int hdlLength;
} TBufferData;


/**************************************************************************/
static bool RamBufferProcessor(char** buffer, int* size)
{
  TBufferData *buff = (TBufferData *)*buffer;
  int nextToCopy = buff->hdlLength;

  buff->hdlLength += *size;
  if (buff->hdlLength > GetHandleSize(*buff->hdl))
    SetHandleSize(buff->hdl, buff->hdlLength);
  if (MemError() == memFullErr)
    return FALSE;

  memmove((char *)(*buff->hdl) + nextToCopy, *buffer, *size);
  return TRUE;
}

/**************************************************************************/
static void create_diag(wr_draw_diag *diag, char *creator, wr_draw_bboxtyp *bbox)
{
  wr_draw_fileheader *hdrptr = (wr_draw_fileheader *)diag->data;
  char *p;

  /* Create file header */
  strncpy(hdrptr->title, "DrawÉ", 12);  // majorformatversionstamp 201, minor 0
//  hdrptr->majorstamp = majorformatversionstamp;
//  hdrptr->minorstamp = minorformatversionstamp;
  p = strncpy(hdrptr->progident, creator, 12);
  for (p += 11; *p == 0; p--)
    *p = ' ';

  memcpy(&hdrptr->bbox, bbox, 16);

  /* Record length field */
  diag->length = sizeof(wr_draw_fileheader);
}

/**************************************************************************/
static void SendScrapMsg(wr_wimp_eventstr *e)
{
   /* called if we cannot handle file sent by RAM, or our RAMFetch was bounced */
   wr_os_regset r;

   /* ask for Wimp$Scrap transfer */
   /* first check that variable exists */
   r.r[0] = (int) "Wimp$Scrap";
   r.r[1] = NULL;
   r.r[2] = -1;
   r.r[3] = 0;
   r.r[4] = 0 ;    /* 12/07/92 don't use 3 cos buffer size unsigned for macro expansion */
   wr_os_swix(OS_ReadVarVal, &r);

   if (r.r[2] == 0)
      ErrorAlert(kNoScrapFound, msgPlainMsg);
                       // free processor if installed: FailGeneral(kNoScrapFound);
   else
   {
      /* reply with a DataSaveAck message */
      strcpy(e->data.msg.data.datasaveok.name, "<Wimp$Scrap>");
      e->data.msg.data.datasaveok.estsize = -1; /* file is not safe with us */
      Sendmessage(wr_wimp_MDATASAVEOK, &e->data.msg,
                                       sizeof(wr_wimp_msghdr) + sizeof(wr_wimp_msgdatasaveok));
   }
}


/**************************************************************************/
static void recv_sendRAMFETCH(TransferData *transfer, wr_wimp_eventstr *e)
/* 15/03/93 parameters to avoid statics being overwritten */
{
  // convert RAMTransmit/DataSave to RAMFetch message

  e->data.msg.data.ramfetch.addr = transfer->recv_buffer;
  e->data.msg.data.ramfetch.nbytes = transfer->recv_buffersize;
  SendmessageWantAck(wr_wimp_MRAMFETCH, &e->data.msg,
            sizeof(wr_wimp_msghdr) + sizeof(wr_wimp_msgramfetch), &transfer->recv_msgid);
}

/***********************************************************
 * The handler that doimport does most of its work through *
 ***********************************************************/

static BOOL recv_unknown_events(wr_wimp_eventstr *e, void *handle)
{
  TransferData *transfer = (TransferData *)handle;

  if ((e->e == wr_wimp_ESEND || e->e == wr_wimp_ESENDWANTACK) &&
      e->data.msg.hdr.your_ref == transfer->recv_msgid &&
      e->data.msg.hdr.action == wr_wimp_MRAMTRANSMIT)
  {
    if (e->data.msg.data.ramtransmit.nbyteswritten == transfer->recv_buffersize)
    {
      /* other end has filled our buffer; better try and allocate some more space */
      if (RamBufferProcessor(&transfer->recv_buffer, &transfer->recv_buffersize))
      {
        /* can go on */
        recv_sendRAMFETCH(transfer, e);
        transfer->recv_state = recv_state_Talk;
      }
      else
      {
        /* users buffer processor failed: break down */
        transfer->recv_state = recv_state_Broken;
      }
    }
    else
    {
      /* final ramtransmit; set done state */
      transfer->recv_buffersize = e->data.msg.data.ramtransmit.nbyteswritten;
      transfer->recv_state = recv_state_Done;
    }
  }
  else if (e->e == wr_wimp_EACK && e->data.msg.hdr.my_ref == transfer->recv_msgid)
  {
    /* our ramfetch bounced */
    /* got our message back */
    if (transfer->recv_state == recv_state_Ask)
    {
      memcpy(&e->data.msg.hdr.task, transfer->origMsg, 40);   // restore orig DataSave msg
      SendScrapMsg(e);
    }
    else
    {
      /* tell the user the protocol fell down */
      /*   wr_werr(0, "Data transfer failed."); */
      ErrorAlert(kRecvFailed, msgPlainMsg);
                    // free installed u_e_processor: FailGeneral(kRecvFailed);
    }
    transfer->recv_state = recv_state_Broken;
  }
  else
    return FALSE;

  return TRUE;
}

/**************************************************************************/
static int DoRamImport(char *buf)
{
  TransferData transfer; 
  wr_wimp_eventstr *e = wr_wimpt_last_event();      // make a local copy of last event

/* Receives data into the buffer; calls the buffer processor if the buffer
   given becomes full. Returns TRUE if the transaction completed sucessfully.
   A buffer or size of zero means the data will be transferred via a file, as
   it will if the sender can't cope with buffering  */

  memcpy(transfer.origMsg, &e->data.msg.hdr.task, 40);  // preserve vital part of DataSave msg
  wr_win_add_unknown_event_processor(recv_unknown_events, &transfer);

  transfer.recv_buffer = buf;
  transfer.recv_buffersize = ABIT;
  recv_sendRAMFETCH(&transfer, e);
  transfer.recv_state = recv_state_Ask;
  // xferrecv_setfileissafe(FALSE);

  do
  {
    wr_event_process();
  } while (transfer.recv_state < recv_state_Done);

  wr_win_remove_unknown_event_processor(recv_unknown_events, &transfer);

  return (transfer.recv_state == recv_state_Done ? transfer.recv_buffersize : -1 );
}

// ------------------------------------------------------------------------
// 27/10/92 added startOffset handling to save having to Munge stuff at start later
static int ReadInExternalFile(Handle *h, int estSize, char *fileName, int startOffset)
{
  int finalSize;

  if (fileName == NULL)
  {
    TBufferData aBuff;  // intermediate buffer, as heap block causes problem
    char *aBuffPtr = aBuff.buff;

    // increase buffer up to the initial size required
    // 27/10/92 only do if RAM transfer, other branch uses file size
    estSize += startOffset;
    if (GetHandleSize(*h) < estSize)
      SetPermHandleSize(h, estSize);
    aBuff.hdl = h;
    aBuff.hdlLength = startOffset;
    // try to do a ram transfer
    if ((finalSize = DoRamImport(aBuffPtr)) < 0)
      FailNoFail();  // 27/06/90 the other end cannot do ram transfer
    RamBufferProcessor(&aBuffPtr, &finalSize);     // finish off
    finalSize = aBuff.hdlLength;
  }
  else
  {
    // read in the whole file into the handle
    int refNum;
    long realSize;

    OpenFile(fileName, refNum, kAccessRead);

    // 18/07/90 use file size rather than estimate
    GetEOF(refNum, realSize);
    finalSize = realSize + startOffset;  // 27/10/92 + startOffset
    if (finalSize > GetHandleSize(*h))
    {
      wr_wimpt_noerr(CloseFile(refNum));  // 03/03/94 [21437] in case of failure
      DisposHandle(*h);
      FailNIL(*h = NewHandle(finalSize));
      OpenFile(fileName, refNum, kAccessRead);  // 03/03/94 [21437] reopen again
    }
    FRead(refNum, finalSize, (char *)(*h) + startOffset);  // 27/10/92 + startOffset
    wr_wimpt_noerr(CloseFile(refNum));  // added 10/5/90
  }

  // if the buffer is too big, reduce it to the size of the data loaded
  if (GetHandleSize(*h) > finalSize)
    SetHandleSize(h, finalSize);

  return finalSize;  // return the size of the buffer transferred
}


// ------------------------------------------------------------------------
// 27/10/92 pass size and name rather than a scrap handle
static int CvtSpriteToDrawFile(TPictObject pictObj, int estSize, char *fileName)
{
  // first create an empty diagram for inserting the sprite into
  int finalSize;
  sprite_area *spriteFile;
  wr_draw_spristrhdr *sprihdr;
  sprite_header *firstSprite;
  char *buffer;
  int firstSpriteSize;
  wr_os_regset r;
  Point spriteSize;

  ReadInExternalFile((Handle *)&(pictObj->fDrawDiagStr.data), estSize, fileName,
                      sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr));
                                   // read in file into handle with gap for headers
  // now we will not move the handle, take a copy
  buffer = (char *)pictObj->fDrawDiagStr.data;
  spriteFile = (sprite_area *)
                     (buffer + sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr) - 4);
  if (spriteFile->number < 1)
    FailNoFail();                                        // fail if no sprites

  firstSprite = (sprite_header *)((char *)spriteFile + spriteFile->sproff);
                                                // get position of first sprite in buffer
  r.r[1] = 0xff;  // ??
  r.r[2] = (int)firstSprite;
#if SIDEBAR == 1
  spriteSize.h = spriteSize.v = 0;
  for (int spNo = spriteFile->number; spNo > 0; spNo--)
  {
    Point spriteSize1;

    ReadSpriteSize(&r, spriteSize1);
    r.r[2] = r.r[2] + ((sprite_header *)r.r[2])->next;
    if (spriteSize1.h > spriteSize.h)
      spriteSize.h = spriteSize1.h;
    if (spriteSize1.v > spriteSize.v)
      spriteSize.v = spriteSize1.v;
  }
  firstSpriteSize = spriteFile->freeoff - spriteFile->sproff; // 17/10/95 action sprites
  pictObj->fContinuous = (spriteFile->number == 2 ? 0 : 1);
  // pictObj->fSpeed = 0;
#else
  ReadSpriteSize(&r, spriteSize);
  firstSpriteSize = firstSprite->next;
#endif

  sprihdr = (wr_draw_spristrhdr *)(buffer + sizeof(wr_draw_fileheader));
  sprihdr->tag = wr_draw_OBJSPRITE;
  sprihdr->size = sizeof(wr_draw_spristrhdr) + firstSpriteSize;
  sprihdr->bbox.x0 = 0;
  sprihdr->bbox.y0 = 0;
  sprihdr->bbox.x1 = wr_draw_screenToDraw(spriteSize.h);  // info.width * eigX);
                                 // 25/05/90 - multiply sprite by its defined mode eig
  sprihdr->bbox.y1 = wr_draw_screenToDraw(spriteSize.v);  // info.height * eigY);

  /* Copy in the new data - in-line wr_draw_createObject */
  create_diag(&pictObj->fDrawDiagStr, gProgName, &sprihdr->bbox);

  finalSize = sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr) + firstSpriteSize;
  // pull down first sprite over header
  memmove((char *)spriteFile + 4, firstSprite, firstSpriteSize);

  // scrap any sprites loaded after the 1st one
  SetHandleSize((Handle *)&(pictObj->fDrawDiagStr.data), finalSize);
  pictObj->fSprite = TRUE;   // 25/05/90 - the structure is a sprite so tell it that it is!
  return finalSize;
}

typedef struct
{ wr_draw_tagtyp    tag;       /* 1 word  */  
  wr_draw_sizetyp   size;      /* 1 word  */   
  wr_draw_bboxtyp   bbox;      /* 4 words */ 
  int            imagex;
  int            imagey;
  int            pixdensityx;
  int            pixdensityy;
  int            matrix[6];
  int            imagelen;
  /* followed by image and padding to word */
} wr_draw_JPEGstrhdr;

// ------------------------------------------------------------------------
static int CvtJPEGToDrawFile(TPictObject pictObj, int estSize, char *fileName)
{
  // first create an empty diagram for inserting the JPEG into
  int finalSize;
  char *JPEGFile;
  wr_draw_JPEGstrhdr *JPEGhdr;
  char *buffer;
  wr_os_regset r;

  estSize = ReadInExternalFile((Handle *)&(pictObj->fDrawDiagStr.data), estSize, fileName,
                      sizeof(wr_draw_fileheader) + sizeof(wr_draw_JPEGstrhdr));
  estSize -= sizeof(wr_draw_fileheader) + sizeof(wr_draw_JPEGstrhdr);
                                   // read in file into handle with gap for headers
  // now we will not move the handle, take a copy
  buffer = (char *)pictObj->fDrawDiagStr.data;
  JPEGFile = (buffer + sizeof(wr_draw_fileheader) + sizeof(wr_draw_JPEGstrhdr));

  r.r[0] = 1;
  r.r[1] = (int)JPEGFile;
  r.r[2] = estSize;
  FailOSErr(wr_os_swix(0x49980 /* JPEG_Info */, &r));
  JPEGhdr = (wr_draw_JPEGstrhdr *)(buffer + sizeof(wr_draw_fileheader));
  JPEGhdr->tag = 16;     // wr_draw_OBJJPEG;
  JPEGhdr->size = sizeof(wr_draw_JPEGstrhdr) + ((estSize + 3) / 4) * 4;
  JPEGhdr->bbox.x0 = 0;
  JPEGhdr->bbox.y0 = 0;
  JPEGhdr->bbox.x1 = wr_draw_screenToDraw(QDtoOS(r.r[2] * GetVLineThickness()));
  JPEGhdr->imagex = JPEGhdr->bbox.x1;
  JPEGhdr->bbox.y1 = wr_draw_screenToDraw(QDtoOS(r.r[3] * GetHLineThickness()));
  JPEGhdr->imagey = JPEGhdr->bbox.y1;
  JPEGhdr->pixdensityx = r.r[4];
  JPEGhdr->pixdensityy = r.r[5];
  JPEGhdr->matrix[0] = (0x10000 * r.r[4]) / 90;   // 02/09/96 [27059] scale by bpp value
  JPEGhdr->matrix[1] = 0;
  JPEGhdr->matrix[2] = 0;
  JPEGhdr->matrix[3] = (0x10000 * r.r[5]) / 90;   // 02/09/96 [27059] scale by bpp value
  JPEGhdr->matrix[4] = 0;
  JPEGhdr->matrix[5] = 0;
  JPEGhdr->imagelen = estSize;

  /* Copy in the new data - in-line wr_draw_createObject */
  create_diag(&pictObj->fDrawDiagStr, gProgName, &JPEGhdr->bbox);

  finalSize = sizeof(wr_draw_fileheader) + JPEGhdr->size;

  // probably unnecessary, but extend handle to cover up to 3 round-up bytes at end of image
  SetHandleSize((Handle *)&(pictObj->fDrawDiagStr.data), finalSize);
  pictObj->fSprite = 2;
  return finalSize;
}

#ifdef FILMS
#define FILMSTART (sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr) + sizeof(sprite_header))

static char gAnimTypes[4] = {2, 3, 1, 0};
// ------------------------------------------------------------------------
static int CvtAnimToDrawFile(TPictObject pictObj, int finalSize)
{
  // Set up the Film wrapped in a psuedo-draw file type object so that all the
  // initialisation is done just the once
  // The format is Draw header / Draw Sprite header / sprite header / film
  // The draw sprite header is given a funny type so it will not be accidentally
  // treated as a sprite, as any palette & actual sprite bit map are not done until
  // the object needs to be rendered - see PictView::Draw
  char *acef;
  char *drawFile;
  wr_draw_spristrhdr *sprihdr;
  sprite_header *tempSprite;
  int *pale;
  int *rate;
  char *speechText;
  wr_os_regset r1;

  pictObj->fDrawDiagStr.length = finalSize;
  drawFile = (char *)pictObj->fDrawDiagStr.data;
  sprihdr = (wr_draw_spristrhdr *)(drawFile + sizeof(wr_draw_fileheader));
  tempSprite = (sprite_header *)(sprihdr + 1);
  acef = (char *)pictObj->FindFilmChunk('FECA');  // ACEF
  if (acef == NULL)
    FailGeneral(47);
  pictObj->fContinuous = gAnimTypes[(((int *)acef)[9] >> 2) & 3];
  rate = (int *)pictObj->FindFilmChunk('ETAR');  // RATE
  if (rate != NULL)
  {
    pictObj->fRate = *rate;
    pictObj->fRate = rate[1];
    pictObj->fVSyncs = rate[2];
  }
  speechText = pictObj->FindFilmChunk('KLAT');  // TALK
  if (speechText != NULL)
    strcpyn(pictObj->fText, speechText, kTalkTextLength - 1);
  r1.r[0] = tempSprite->mode = ((int *)acef)[7];     /*  Mode sprite was defined in */
  r1.r[1] = 4;
  wr_wimpt_noerr(wr_os_swix(OS_ReadModeVariable, &r1));
  tempSprite->width = ((int *)acef)[5] >> r1.r[2];     /*  Width in pixels */
  r1.r[1] = 9;       // bits per pixel in mode of film
  wr_wimpt_noerr(wr_os_swix(OS_ReadModeVariable, &r1));
  tempSprite->rbit = (tempSprite->width << r1.r[2]) - 1; /* Last bit used (RH of row)*/
  tempSprite->width = tempSprite->rbit >> 5;
  tempSprite->rbit = tempSprite->rbit - (tempSprite->width << 5);
  r1.r[1] = 5;       // y-eig
  wr_wimpt_noerr(wr_os_swix(OS_ReadModeVariable, &r1));
  tempSprite->height = (((int *)acef)[6] >> r1.r[2]) - 1;  /*  Height in scanlines-1 */
  strcpy(tempSprite->name, "temp_sprite");  /*  Sprite name                          */
  tempSprite->lbit = 0;      /*  First bit used (left end of row)  */
  pale = (int *)pictObj->FindFilmChunk('ELAP');  // PALE
  tempSprite->image =     /*  Offset to sprite image               */
  tempSprite->mask = sizeof(sprite_header) + (pale ? (pale[-1] - 36) * 2 : 0);
                          /*  Offset to transparency mask */
  tempSprite->next = ((tempSprite->width + 1) * (tempSprite->height + 1)) * 4 +
                                     tempSprite->image;  /*  Offset to next sprite   */

  sprihdr->tag = 99;       // stop it being rendered
  sprihdr->size = finalSize - sizeof(wr_draw_fileheader);  // make it a valid draw file length
  sprihdr->bbox.x0 = 0;
  sprihdr->bbox.y0 = 0;
  sprihdr->bbox.x1 = wr_draw_screenToDraw(((int *)acef)[5]);
  sprihdr->bbox.y1 = wr_draw_screenToDraw(((int *)acef)[6]);
  create_diag(&pictObj->fDrawDiagStr, gProgName, &sprihdr->bbox);  // fill in Draw header

  return finalSize;
}

// ------------------------------------------------------------------------
static int CvtFILMToDrawFile(TPictObject pictObj, int estSize, char *fileName)
{
  estSize = ReadInExternalFile(&pictObj->fDrawDiagStr.data, estSize, fileName, FILMSTART);
  pictObj->fSprite = 7;
  return CvtAnimToDrawFile(pictObj, estSize);
}

// ------------------------------------------------------------------------
static int CvtACEToDrawFile(TPictObject pictObj, int estSize, char *fileName)
{
  estSize = ReadInExternalFile(&pictObj->fDrawDiagStr.data, estSize, fileName,
              FILMSTART + 8);
  ((int *)pictObj->fDrawDiagStr.data)[FILMSTART / 4] = 'FECA';
  ((int *)pictObj->fDrawDiagStr.data)[FILMSTART / 4 + 1] = estSize - FILMSTART;
  pictObj->fSprite = 8;
  return CvtAnimToDrawFile(pictObj, estSize);
}
#endif

#define DUMMYSZ 32

// ------------------------------------------------------------------------
TCommand _TExpressionDocument::DoPaste(AppFile *appFile, int estSize,
                                     TPasteCommandType type, TObject pasteSelection)
{
  // 08/05/90 - new method to the arc, called as a result of CanPaste()
  // 14/05/90 - moved from TextEvent as pics can be either from a picview
  // or inline from a text handler
  // 26/06/90 - new version which avoids creating clip documents ...
  // 27/06/90 - and supports copying via wimp$scrap if RAM transfer not on.

  volatile TExpressionDocument theDocument;
  volatile Handle        scrapHandle;
// 20/05/91 volatile 
  int           refNum;
//  volatile
  TPictObject      pictObj;
  TCommand         pasteCommand;
  FailInfo         fi;
  TExpressionView  clipView;
  TCurrency        mainCurrency;
  TPictStructure   pictStruct;
  int              picRec;
  int              finalSize;

  theDocument = NULL;
  scrapHandle = NULL;

  CatchFailures(&fi);

  if (appFile->fType == kExpressionFile || appFile->fType == kStationeryPad)
  {
    if (appFile->fName == NULL)    // 11/05/92 null for ""
    {
      // We want this to get bounced by the other end. This will happen if
      // the other end is Expression, and then we will be called back with
      // an invitation to read from <wimp$scrap>. If not, we cannot do much
      // about it, and nothing should happen.

#ifdef DRAGDROP
      gBouncedSeln = pasteSelection;
      gBouncedType = type;
#endif
      SendScrapMsg(wr_wimpt_last_event());
      FailNoFail();                  // to get out without creating a command
    }
    else
    {
#ifdef DRAGDROP
      if (pasteSelection == NULL && gBouncedSeln != NULL)
      {
        pasteSelection = gBouncedSeln;
        gBouncedSeln = NULL;
        type = gBouncedType;
      }
#endif
      OpenFile(appFile->fName, refNum, kAccessRead);
                              // 04/07/90 open paste files as read only
      theDocument = TExpressionDocument(gApplication->DoMakeDocument(kTWScrapType, FALSE));
      theDocument->fDataRefnum = refNum;  // 20/05/91 moved from TDDoc
      theDocument->DoRead(refNum, FALSE);
#ifdef DRAGDROP
      if (pasteSelection != NULL)
      {
        ClearObject(theDocument->fSelection);
        // setting fSelection to NULL frig to let MoveCopy know it is a clip doc
        theDocument->fFileType = I_('c', 'l', 'i', 'p');
      }
#endif
    }
  }
  else
  {
    // it is not an expression file, so we need to build a document with
    // a structure containing an object of the type passed
    theDocument = TExpressionDocument(gApplication->DoMakeDocument(appFile->fType, FALSE));
    clipView = TExpressionView(theDocument->DoCreateMainView(1));
    mainCurrency = theDocument->DoInitialStyles(clipView, NULL);

    if (appFile->fType == kDrawFile || appFile->fType == kSpriteFile ||
#ifdef FILMS
                appFile->fType == kFilm || appFile->fType == kACE ||
#endif
                appFile->fType == kJPEGFile)
    {
      // read in a draw file here...
      picRec = theDocument->AddNewPictureObject(pictObj);

      if (appFile->fType == kSpriteFile)           // sprite
        finalSize = CvtSpriteToDrawFile(pictObj, estSize, appFile->fName);
      else if (appFile->fType == kJPEGFile)        // JPEG
        finalSize = CvtJPEGToDrawFile(pictObj, estSize, appFile->fName);
#ifdef FILMS
      else if (appFile->fType == kFilm)
        finalSize = CvtFILMToDrawFile(pictObj, estSize, appFile->fName);
      else if (appFile->fType == kACE)
        finalSize = CvtACEToDrawFile(pictObj, estSize, appFile->fName);
#endif
      else
        finalSize = ReadInExternalFile(&(pictObj->fDrawDiagStr.data),   // Draw file
                                         estSize, appFile->fName, 0);
#if SIDEBAR == 1
      if (appFile->fName != NULL
#ifdef FILMS
                 && appFile->fType != kFilm
#endif
        )
      {
        char *lastDot = strrchr(appFile->fName, '.');

        strcpyn(pictObj->fText, lastDot ? lastDot + 1 : appFile->fName, kTalkTextLength - 1);
      }
#endif

      {
#ifndef NETWP
        int code, location;

        // verify the drawing now  05/11/92 wr_draw_verify_diag in-line
        if (!wr_check_Draw_file((char *)pictObj->fDrawDiagStr.data,
                  finalSize, &code, &location))
        {
          wr_werr(0, GetRsrcErr(21), code, location);
          FailNoFail();
        }
#endif
        // 07/04/94 [21607] check for nothing in Draw file
        if (EmptyRect(*((Rect *)&((wr_draw_fileheader *)pictObj->fDrawDiagStr.data)->bbox)))
          FailGeneral(45);
      }
      pictObj->fDrawDiagStr.length = finalSize;
      pictStruct = TPictStructure(theDocument->GetStructureReadWrite(mainCurrency));
      pictStruct->fPicture = picRec;
    }
    else
    {
      // 26/09/91 new block to see if there is an empty table containing insertion
      TSelection selection = GetNewSelection();
      TCursorNode anchor = selection->GetAnchorTarget();
      TStructure targetStructure = GetStructureReadOnly(anchor->fCurrency);
      TCurrency tableCurr = targetStructure->fParent;
      int makeStruct = cNoCommand;

      if (appFile->fType == kTextFile && selection->fCursor &&
                  targetStructure->GetKind() == kText && tableCurr != 0)
      {
        targetStructure = GetStructureReadOnly(tableCurr);
        if (targetStructure->GetKind() == kColumns && targetStructure->IsEmpty())
          makeStruct = cTable;     // 25/09/91 to force a tab-based table to be built
      }
      scrapHandle = NewCheckedHandle(estSize);   // empty handle for text
#ifdef THESAURUS
      // 01/03/93 Generate a Paste Command for words returned by DeskTop Thesaurus
      if (type == kSynonymReturned)
      {
        strncpy((char *)scrapHandle, appFile->fName, estSize);
      }
      else
#endif
        ReadInExternalFile((Handle *)&scrapHandle, estSize, appFile->fName, 0);
      theDocument->DoReadTextFile((Handle *)&scrapHandle, makeStruct, FALSE, gNullCurrency);
      DisposIfHandle(scrapHandle);
      scrapHandle = NULL;     // 03/08/92
    }
  }

  // create the paste command
  FailSpaceIsLow();          // 03/08/92 may have filled up store so no room to do anything
#ifdef DRAGDROP
  pasteCommand = gApplication->MakeMoveCommand(
          pasteSelection == NULL ? GetNewSelection() : TSelection(pasteSelection),
          theDocument, type);
#else
  pasteCommand = new _TPasteCommand(this, theDocument, type);
#endif

  Success(&fi);

  return pasteCommand;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Rescue:
  DisposIfHandle(scrapHandle);
  FreeIfObject(theDocument);
  ContinueFailure(&fi);
}

#ifdef TABLES
// ------------------------------------------------------------------------
static void FillEmptyCells(TTextDocument self, PCellItem cellStruct,
             int row, int column, /* TStructure table,*/ TCurrency tableCurr)
{
  cellStruct->undoState = 0;
  cellStruct->rowChange = 0;
  if (cellStruct->cell == 0 && !cellStruct->hidden)
  {
    TDiscObject rec;
    TCurrency textCurrency = self->NewCurrency(kTextStruct, rec);
    TTextStructure para = TTextStructure(rec);

    para->InitNewStructure(tableCurr, textCurrency, 0, kText, TRUE, NULL); // 26/03/92
    cellStruct->cell = textCurrency;
  }
}

// ------------------------------------------------------------------------
static void DoFillEmptyCells(TTextDocument self, TTableStructure structure, TCurrency tableCurr)
{
  // scan though the table and replace empty cells with empty paras
  TCellRect allCells;

  structure->GetAllCells(allCells);
  structure->ForSelectedCellsDo(self, allCells, (Action)FillEmptyCells, tableCurr);
}
#endif

// ------------------------------------------------------------------------
#ifdef PRO
static char *CheckCR(int crType, char *textPosInScrap, char *textEnd, int cr)
{
  switch (crType)
  {
    case 2:   // Cr Lf
      if (cr == kEditFileReturn && textPosInScrap < textEnd)
        cr = *(textPosInScrap++);
      else
        cr = 0;
    case 1:  // Lf
      if (cr == kEditFileLF)
        return textPosInScrap;
      break;

    case 3:  // Lf Cr
      if (cr == kEditFileLF && textPosInScrap < textEnd)
        cr = *(textPosInScrap++);
      else
        cr = 0;
    case 0:  // Cr
      if (cr == kEditFileReturn)
        return textPosInScrap;
      break;
  }
  return NULL;
}
#endif

// ------------------------------------------------------------------------
static char *IdentifyReturn(char *textPosInScrap, char *textEnd, int &ourCR)
{
  int cr = ourCR;
#ifdef PRO
  int crType = gTextCr ? *gTextCr : '0';
  char *newPos = textPosInScrap;

  if (crType >= '4')
  {
    newPos = CheckCR(crType - '4', newPos, textEnd, cr);
    if (newPos && textPosInScrap < textEnd)
      cr = *(newPos++);
    else
      newPos = NULL;
  }
  if (newPos)
    newPos = CheckCR(crType & 3, newPos, textEnd, cr);
  if (newPos)
  {
    ourCR = chReturn;
    return newPos;  // recognised as one of our CRs
  }
  crType = gTextLf ? *gTextLf : '1';
  cr = ourCR;
  newPos = CheckCR(crType & 3, textPosInScrap, textEnd, cr);
  if (newPos)
  {
    ourCR = chLineFeed;
    return newPos;  // recognised as one of our LFs
  }
#endif
  if (cr == kEditFileReturn)
    ourCR = chReturn;
  else
    ourCR = chLineFeed;
  return textPosInScrap;
}

#ifdef WORD7
// ------------------------------------------------------------------------
char gSprmSizes[] =
{
  sprmIllegal,
  sprmIllegal,
  sprmShort,
  sprmVar,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmVar,
  sprmByte,
  sprmByte,
  sprmVar,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmLong,
  sprmWord,
  sprmWord,
  sprmTabs,
  sprmByte,
  sprmByte,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmByte,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmByte,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmByte,
  sprmWord,
  sprmShort,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmByte,
  sprmByte,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmBit,
  sprmBit,
  sprmBit,
  sprmVar,
  sprmShort,
  sprmLong,
  sprmBit,
  sprmShort,
  sprm3Byte,
  sprmVar,
  sprmBit,
  sprmIllegal,
  sprm2Byte,
  sprmIllegal,
  sprmIllegal,
  sprmShort,
  sprmVar,
  sprmVar,
  sprm0Byte,
  sprmIllegal,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmWord,
  sprmByte,
  sprm3Byte,
  sprmWord,
  sprmWord,
  sprmByte,
  sprmWord,     // 99 wrongly(?) documented as sprmByte,
  sprmByte,
  sprmWord,     // 101 wrongly(?) documented as sprmByte,
  sprmByte,
  sprmVar,
  sprmByte,
  sprmVar,
  sprmVar,
  sprmShort,
  sprmVar,
  sprmShort,
  sprmShort,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmBit,
  sprmBit,
  sprmByte,
  sprmLenPlus12,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmByte,
  sprmByte,
  sprmVar,
  sprmIllegal,
  sprmIllegal,
  sprm3Byte,
  sprm3Byte,
  sprmByte,
  sprmByte,
  sprmWord,
  sprmWord,
  sprmByte,
  sprmByte,
  sprmWord,
  sprmWord,
  sprmByte,
  sprmByte,
  sprmShort,
  sprmShort,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmByte,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmByte,
  sprmByte,
  sprmWord,
  sprmWord,
  sprmByte,
  sprmIllegal,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmIllegal,
  sprmWord,
  sprmWord,
  sprmWord,
  sprmByte,
  sprmByte,
  sprm12Byte,
  sprmVar,
  sprmWord,
  sprmVarLong,
  sprmVarLong,
  sprm4Byte,
  sprm5Byte,
  sprm4Byte,
  sprmWord,
  sprm4Byte,
  sprmWord,
  sprmWord,
  sprm5Byte,
  sprm4Byte
};

// ------------------------------------------------------------------------
short int gLids[] =
{
 0x0400, // 0 Default
 0x0809, // 1 UK
 0x0000, // 2 Master
 0x0000, // 3 Compact
 0x0410, // 4 Italy
 0x040a, // 5 Spain
 0x040c, // 6 France
 0x0407, // 7 Germany
 0x0816, // 8 Portugal
 0x0000, // 9 Esperanto
 0x0408, // 10 Greece
 0x041d, // 11 Sweden
 0x040b, // 12 Finland
 0x0000, // 13
 0x0406, // 14 Denmark
 0x0414, // 15 Norway
 0x040f, // 16 Iceland
 0x0c0c, // 17 Canada1
 0x0c0c, // 18 Canada2
 0x0c0c, // 19 Canada
 0x041f, // 20 Turkey
 0x0401, // 21 Arabic
 0x0000, // 22 Ireland  (Not understood by Microsoft)
 0x0404, // 23 Hong Kong
 0x0419, // 24 Russia
 0x0419, // 25 Russia2
 0x040d, // 26 Israel
 0x080a, // 27 Mexico
 0x0000, // 28 LatinAm
 0x0000, // 29
 0x0000, // 30 Austria
 0x080c, // 31 Belgium
 0x0411, // 32 Japan
 0x0000, // 33 MiddleEast
 0x0413, // 34 Netherlands
 0x100c, // 35 Switzerland
 0x0000, // 36 Wales  (Not understood by Microsoft)
 0x0000, // 37
 0x0000, // 38
 0x0000, // 39
 0x0000, // 40
 0x0000, // 41
 0x0000, // 42
 0x0000, // 43
 0x0000, // 44
 0x0000, // 45
 0x0000, // 46
 0x0000, // 47
 0x0409, // 48 USA
};

int gWordColTab[] = {
  0,
  0,           // black
  0xffbb0000,  // blue
  0xffff0000,  // cyan
  0x00ff0000,  // green
  0xff00ff00,  // magenta
  0x0000ff00,  // red
  0xccffff00,  // yellow
  0xffffff00,  // white
  0x99440000,  // dk blue
  0xbbbb4400,  // dk cyan
  0x00885500,  // dk green
  0xbb00bb00,  // dk magenta
  0x0000bb00,  // dk red
  0x00ffff00,  // dk yellow
  0x88888800,  // dk gray
  0xcccccc00,  // lt gray
};

static struct 
{
  int  fInStruct; // command number of structure to contain next paragraph
  char fTtp;      // row mark cell
  char fLvlAnm;   // 0 for no numbering; 1-9 for buller/autonum level;
                  // 10 for numbering; 11 for bullet; 12 for unnumbered and do not update number
  char fOle2;     // 1 if pic is an OLE object
  char grpflhdt;  // Header/footer flags in sepx
  Fixed dyaHdrTop; // positions of header and footers in sepx
  Fixed dyaHdrBottom;
  char hfDone;    // Header/footer flags in sepx
  char fSpec;     // special character in CHP (character properties)
  char chSym;     // special symbol character
  char fChsDiff;  // use a different character set
  int  chse;      // character set for this run (if fChsDiff set)
  int  fcPic;     // file location of a picture
  int  pgnStart;  // start number for chap/doc
  char fPpc;      // indicates absolute vertical positioning
  char pgnRestart; // whether to restart page numbers for chap/doc
  char fTitlePage; // Sep header/footer on 1st page of chap/doc?
  char fEvenSpace; // Sep columns - possible side heading if 2 column
  int  firstColumn; // first col of side heading in twips
  int  firstGap;  // inter column gap for side heading
  int  fPcVert;   // absolute position vertically
  int  hpsPos;    // superscript/subscript (-ve) or displacement of in-line picture
} gWordFields;

static TStyleFormat gNormalStyle;
static gIndentation;         // save to end of style as Word indents are relative to LMarg
static MS_STSHI *gSheetHdr;  // pointer to my copy of header
static char *gSheet;         // pointer to actual sheet (following hdr in memory)
static MS_FFN *gFontInfo;
static TExpressionDocument gMainDoc;
static char *gNextSection;
static char *gNextSED;
static char *gNextFn;
static char *gNextEndn;
static TStructure gParentStruct;
static TCurrency gParentCurr;
static int gFieldsOffset;      // plcffldMom or plcffldHdr fields info for current subdoc
static int gFieldsCount;       // fcffldMom or fcffldHdr fields info for current subdoc
static int gTextOffset;        // text offset for current subdoc
static char gTableBorders[12];

// ------------------------------------------------------------------------
static TEmphInfo *InsertPhraseEntry(TEmphInfo *paraEmphs, TEmphInfo *info)
{
  if (paraEmphs == NULL)
    paraEmphs = (TEmphInfo *)FailNIL(NewEmptyHandle());
  InsertIntoHandle(&paraEmphs, MAXLONGINT /* at end */, info, sizeof(TEmphInfo));
  return paraEmphs;
}

// ------------------------------------------------------------------------
static TEmphInfo *AddWordPicture(TEmphInfo *paraEmphs, int startRun)
{
  TEmphInfo info;

  info.startRun = startRun;
  info.endRun = gWordFields.fcPic;
  info.style = TStyleFormat(gWordFields.hpsPos);  // vertical adjust in halfPts
  info.type = kWidgetPhrase;
  return InsertPhraseEntry(paraEmphs, &info);
}

// ------------------------------------------------------------------------
static TEmphInfo *InsertMacroPhrase(TEmphInfo *paraEmphs, int startRun, int macro)
{
  TEmphInfo info;

  info.startRun = startRun;
  info.endRun = startRun + 1;
  info.style = TStyleFormat(macro);
  info.type = kMacroPhrase;
  return InsertPhraseEntry(paraEmphs, &info);
}

#ifdef FN
// ------------------------------------------------------------------------
static TEmphInfo *AddFnRef(TEmphInfo *paraEmphs, TStructure doc, int startRun, int refPos)
{
  TEmphInfo info;
  TCurrency noteSet = doc->GetNoteCollector();

  if (noteSet != 0)
  {
    TDiscObject obj;
    long structPos;
    TBodyStructure noteSetStruct;

    info.startRun = startRun;
    info.style = NULL;
    info.type = kNotePhrase;
    info.endRun = doc->fDocument->NewCurrency(kBodyStruct, obj);
    TStructure(obj)->InitNewStructure(noteSet, info.endRun,
          doc->fDocument->fBodyStyles[kCurrNoteStyle], kFootnote, FALSE, NULL);
    structPos = -1;
    noteSetStruct = TBodyStructure(doc->fDocument->GetStructureReadWrite(noteSet));
    noteSetStruct->InsertSubStructure(0, NULL, noteSet, info.endRun, structPos);

    // 09/09/96 [27071] save the footnote or endnote file so it can be identified later
    ((int *)(noteSetStruct->At(noteSetStruct->fSize)))[1] |= (refPos << 4);
    return InsertPhraseEntry(paraEmphs, &info);
  }
  return paraEmphs;
}
#endif


// ------------------------------------------------------------------------
static TEmphInfo *AddAnEmphasis(TEmphInfo *paraEmphs, int endRun, TEmphInfo *emphInfo)
{
  if (emphInfo->style != NULL && emphInfo->startRun != endRun)
  {
    emphInfo->endRun = endRun;
    emphInfo->type = kTextPhrase;
    paraEmphs = InsertPhraseEntry(paraEmphs, emphInfo);
  }
  else
    FreeIfObject(emphInfo->style);    // style (if any) will not be needed for an emphasis
  emphInfo->style = NULL;             // do not try to free it now on failure
  emphInfo->startRun = endRun;
  return paraEmphs;
}

// ------------------------------------------------------------------------
static char *SkipAWord(char *p)
{
  while (*(p++) == ' ') {}
  while (*(p++) > ' ') {}
  return p;
}

// ------------------------------------------------------------------------
static char *SkipField(char *textPosInScrap, char *fibPos, TEmphInfo **paraEmphs, int startRun,
                                                 TExpressionDocument doc, TEmphInfo *emphInfo)
{
  int ch;
  int sub = 0;
  int fieldType = -1;
  int macro = -1;      // 08/09/96 [27070]

  if (paraEmphs != NULL)      // safer not to try nested macros, - just skip on inner iterations
  {
    int fldPos = (textPosInScrap - fibPos - gTextOffset) - 1;
    int fldCount = gFieldsCount - 4;

    for (char *p = fibPos + gFieldsOffset; fldCount > 0; fldCount -= 6, p += 4)
    {
      int pos;

      memcpy(&pos, p, 4);
      if (pos == fldPos)
      {
        fieldType = *(fibPos + gFieldsOffset + gFieldsCount - fldCount / 3 + 1);
        if (fieldType == MS_FldDate)
          macro = kNewDate;
        else if (fieldType == MS_FldTitle)
          macro = kDocumentTitle;
        else if (fieldType == MS_FldCreateDate)
          macro = kDate;
        else if (fieldType == MS_FldTime)
          macro = kTime;     // use kTime rather than kNewTime to preserve text set by Word
        else if (fieldType == MS_FldPageNumber)
          macro = kPageNumber;
        else if (fieldType == MS_FldDocPages)
          macro = kPagesInDocument;
        else if (fieldType == MS_FldSecPages)
          macro = kPagesInChap;
        else
        {
          if (fieldType == MS_FldSymbol)
          {
            // something like: [13]SYMBOL 211 \f "Symbol" \s 12 \h[15]
            int fontNum;
            TStyleFormat origStyle = emphInfo->style;

            if (origStyle)
              origStyle = TStyleFormat(origStyle->Clone());
            *paraEmphs = AddAnEmphasis(*paraEmphs, startRun, emphInfo);
            emphInfo->style = origStyle ? TStyleFormat(origStyle->Clone()) : new _TStyleFormat();
            textPosInScrap = SkipAWord(textPosInScrap);
            sub = strtol(textPosInScrap, NULL, 0);  // 29/09/96, allow 0xnn hex
            textPosInScrap = SkipAWord(textPosInScrap) - 1;  // position at char after value

            for (;;)
            {
              while ((ch = *(textPosInScrap++)) == ' ') {}

              if (ch < ' ')
                break;
              if (ch == '\\')
              {
                ch = tolower(*(textPosInScrap++));
                if (ch  == 'f')
                {
                  int term = ' ';
                  char *p;
                  MS_FFN fontInfo;

                  memset(&fontInfo, 0, 6);
                  while ((ch = *(textPosInScrap++)) == ' ') {}
                  if (ch == '\"')
                  {
                    term = ch;
                    ch = *(textPosInScrap++);
                  }
                  p = fontInfo.szFfn;
                  while (ch != term)
                  {
                    *(p++) = ch;
                    ch = *(textPosInScrap++);
                  }
                  *p = 0;
                  fontInfo.cbFfnM1 = (p - (char *)fontInfo.szFfn) + 6;
                  fontNum = doc->GetFontNumber(fontInfo.szFfn, (char *)&fontInfo);
                  DoFontChange(emphInfo->style, fontNum);
                  strcpy(emphInfo->style->fFontName, fontInfo.szFfn);
                }
                else if (ch == 's')
                  DoSizeChange(emphInfo->style, atoi(textPosInScrap) * 16);
              }
              else
                textPosInScrap = SkipAWord(textPosInScrap);  // soak up font size/unknown switch
            }
            textPosInScrap--;
            *paraEmphs = AddAnEmphasis(*paraEmphs, startRun + 1, emphInfo);
            emphInfo->style = origStyle;
            macro = 0;
          }
          break;
        }
        sub = 1;  // include everything to endmark in the macro phrase
        *paraEmphs = InsertMacroPhrase(*paraEmphs, startRun, macro);
        break;
      }
      if (pos > fldPos)
        break;
    }
  }
  if (fieldType == MS_FldMacroButton || fieldType == MS_FldGotoButton)
  {
    while (*(textPosInScrap++) == ' ') {}
    if (*(textPosInScrap - 1) == MS_FldBegin)
      textPosInScrap = SkipField(textPosInScrap, fibPos, NULL, startRun, doc, emphInfo) + 1;
    textPosInScrap = SkipAWord(textPosInScrap);
    textPosInScrap = SkipAWord(textPosInScrap);
    if (*textPosInScrap == MS_FldEnd)
      textPosInScrap--;
  }
  else
  {
    // Skip to either immediately before the sep, or if there is no sep to just before the endmark
    while (ch = *(textPosInScrap++), ch != MS_FldEnd)
    {
      if (ch == MS_FldBegin)
        textPosInScrap = SkipField(textPosInScrap, fibPos, NULL, startRun, doc, emphInfo) + 1;
      if (ch == MS_FldSep && paraEmphs != NULL) // && macro < 0)
          // 08/09/96 [27070] process everything not done explicitly above:
          // 08/09/96 [27070] (fieldType == MS_FldCreateIndex || fieldType == MS_FldCreateTOC))
         break;
    }
    textPosInScrap--;
  }
  *(textPosInScrap - 1) = sub;  // friggy way of telling caller the substitute character
  return textPosInScrap;
}

// ------------------------------------------------------------------------
static char *DoTabSettings(TStyleFormat self, char *sprm, int tabDel)
{
  int tabsToHandle = *(sprm++);
  int i;
  TFTabInfo tabInfo;

  ITabInfo(tabInfo);
  for (i = 0; i < tabsToHandle; i++)
  {
    int dxaAdd;

    Load2Byte(dxaAdd, sprm);
    tabInfo.fStop = dxaAdd * (kFix1 / 2);
    if (tabDel)
      ((int *)&tabInfo)[2] |= 0x10000;   //   tabInfo.fDeleted = TRUE;
    else
    {
      MS_TBD tabDesc;

      *((char *)&tabDesc) = *(sprm - i - 2 + tabsToHandle * 2);
      if (tabDesc.jc > kMarkTab)
        continue;                // cannot add a Bar tab?
      tabInfo.fKind = tabDesc.jc;
      tabInfo.fFiller[0] = "\x00.-__.."[tabDesc.tic];
    }
    self->InstallTab(tabInfo);
    self->fDefined |= kRuler;      // 17/10/96 [27111]
  }
  return sprm;
}

// ------------------------------------------------------------------------
static void DoWordBorders(TStyleFormat self, int sprmCode, int borderCode)
{
  if (borderCode != 0xffff)    // not mensioned in spec!
  {
    MS_BRC spec = *((MS_BRC *)&borderCode);
    TRuleType res;
    CntlAdornment adornment;
    int dxpLineWidth;

    adornment = ((self->fDefined & kHasAdornment) ? self->fOwnAdornment : self->fAdornment) |
                     (1 << (sprmCode - sprmPBrcTop)) | (adnShadow * spec.fShadow) | adnWordStyle;
    res.fShort = 0;
    res.fRule = k1Thn;
    res.fPen = 0;
    dxpLineWidth = spec.dxpLineWidth;
    if (dxpLineWidth <= 5)
    {
      dxpLineWidth *= 7500;
      switch (spec.brcType)
      {
      case 0:
        res.fRule = kNoRule;
        break;
      case 1:
        break;
      case 2:
        dxpLineWidth *= 2;
        break;
      default:
        res.fRule = k2Thn;
      }
    }
    else
      dxpLineWidth = kOnePtPen >> spec.brcType;
         // brcType, dxpLineWidth == 2, 6 for hairline, otherwise 0, 6/7 (not mensioned in spec!)
    res.fPen = dxpLineWidth;
    DoBordersChange(self, res, adornment);
  }
//  switch (spec.brcType)
//  {
//    case 0:
//      oldFmt = kNoRuleX;
//      break;
//    case 1:
//      oldFmt = "\x000\x002\x003\x004\x004\x004\x001\x001"[dxpLineWidth];
//      break;
//    case 2:
//      oldFmt = "\x000\x003\x004\x004\x004\x004\x002\x002"[dxpLineWidth];
//      break;
//    default:
//      oldFmt = (dxpLineWidth ? kSingleSinglePair : kNoRuleX);
//  }
//  DoBordersChange(self, NewRuleType(oldFmt), adornment);
}

// ------------------------------------------------------------------------
static void SetWordBorders(TStyleFormat self, int sprmCode, int borderCode)
{
  if (borderCode)
    DoWordBorders(self, sprmCode, borderCode);
}

// ------------------------------------------------------------------------
void _TExpressionDocument::FindSubstituteFont(FontTree *ptr, char *data)
{
  if (data)
  {
    MS_FFN *fontInfo = (MS_FFN *)data;
    char *fontName = fontInfo->szFfn;
#ifdef TRACE
    char *altName = fontName + fontInfo->ibszAlt;
#endif
    char *found = NULL;
    void *wordFontData;
    int i;

    for (i = fontInfo->ibszAlt; ; i = 0)
    {
      char *rsrc;

      for (int rsrcIdx = 1; (rsrc = GetRsrc(rsrcIdx, 'g')) != NULL; rsrcIdx++)
        if (strncmp(fontName, rsrc, strlen(rsrc)) == 0)
          found = GetRsrc(rsrcIdx, 'n');
      if (i == 0)
        break;
      fontName += i;
    }
    if (found)
    {
      FontTree *newPtr = GetAddrOfLeafNode(found);

      if (newPtr)
        ptr->info.parentPtr = newPtr;
    }
    if (ptr->info.brotherPtr == NULL)
    {
      int dataSize = fontInfo->cbFfnM1 + 1;

      wordFontData = malloc(dataSize);
      if (wordFontData)
        ptr->info.brotherPtr = memcpy(wordFontData, data, dataSize);
    }
  }
}

// ------------------------------------------------------------------------
static int DoFontCode(TStyleFormat self, int ftc, int style, int bullet)
{
  char *p = (char *)gFontInfo;
  int fontInfoSize;
  int fontIndex = 0;
  char *fontInStyle = (bullet ? self->fBulletFontName : self->fFontName);

  Load2Byte(fontInfoSize, p);

  for (int idx = 0; p < (char *)gFontInfo + fontInfoSize; idx++)
  {
    MS_FFN *fontInfo = (MS_FFN *)p;

    if (idx == ftc)
    {
      fontIndex = gMainDoc->GetFontNumber(fontInfo->szFfn, (char *)fontInfo);
      strcpyn(fontInStyle, fontInfo->szFfn, 35);
      break;
    }
    p += fontInfo->cbFfnM1 + 1;
  }
  return fontIndex;
}

// ------------------------------------------------------------------------
static char *ApplySprm(TStyleFormat style, int sprmCode, char *sprm, char *sprmsEnd)
{
  // sprmsEnd is where the data actually ends. Zeroes may have been clipped off the
  // end, and these need to be re-instated if the projected length is longer than
  // the actual end of the sprm. Below assumes that on entry sprmsEnd >= sprm
  int sprmLen = 0x10000;

  if (sprmCode < sizeof(gSprmSizes))        // legal range of values
  {
    int sprmLenType;

    sprmLen = (sprm == sprmsEnd ? 0 : *(sprm++));
    sprmLenType = gSprmSizes[sprmCode];
    switch (sprmLenType)
    {
      case sprmIllegal:
        sprmLen = 0x10000;
        break;

      case sprmLenPlus12:
        sprmLen += 12;
        break;

      case sprmTabs:
        // normal count byte (may be too small if 255)
        if (sprmLen == 255)
        {
          // fortunately in this case, both counts must be > 0, so no need to worry about padding
          sprmLen = *sprm * 4 + 1;               // itbdDelMax allocation (see P.41)
          sprmLen += *(sprm + sprmLen) * 3 + 1;  // add in the size of itbdAddMax array
        }
        break;

      case sprmVar:
        break;                           // sprmLen in single byte already set up

      case sprmVarLong:
        sprmLen--;                       // the length is 2-byte count - 1
        if (sprm < sprmsEnd)
          sprmLen += *(sprm++) * 256;    // add in hi-byte of 2-byte count
        break;

      default:
        sprm--;                          // there was no count byte
        sprmLen = sprmLenType;
    }
  }
  if (sprmLen != 0x10000)
  {
    char *sprmPtr;

    if (sprmLen > sprmsEnd - sprm)
    {
      sprmPtr = (char *)malloc(sprmLen);
      if (sprmPtr == NULL)
        return sprm + sprmLen;      // cannot do this one - not enough memory

      // move and zero fill - take care if code above modified (assumes sprmsEnd >= sprm)
      sprmPtr = (char *)memcpy(memset(sprmPtr, 0, sprmLen), sprm, sprmsEnd - sprm);
    }
    else
      sprmPtr = sprm;
    style->ApplyWordSprm(sprmCode, sprmPtr, sprmLen);
    if (sprmPtr != sprm)
      free(sprmPtr);
  }
#ifdef TRACE
  else
    SysBeep(0);   // an unknown code, cease processing
#endif
  return sprm + sprmLen;   // pointer to next
}


// ------------------------------------------------------------------------
static void ApplyStyleSprms(TStyleFormat style, int len, char *sprms)
{
  char *sprmsEnd = sprms + len;
  int oldIndent = style->GetIndentation();
  int oldOffset = oldIndent - style->GetLeftMargin();
  int newIndent;

  gIndentation = MAXLONGINT;
  while (sprmsEnd > sprms)
  {
    int sprmCode = *(sprms++);

    if (sprmCode != 0)   // picked up the filler (included in the len for some reason?)
     sprms = ApplySprm(style, sprmCode, sprms, sprmsEnd);
#ifdef TRACE
    else if (sprmsEnd != sprms || !Odd((int)sprms))
      SysBeep(0);
       // we have gone astay somewhere - this is not the padding caused by using a word count
#endif
  }
  if (oldIndent >= 0 || (style->fDefined & kHasMargins) == 0)  // dont set indent on tables, etc.
  {
    newIndent = style->GetLeftMargin() +
                    (gIndentation != MAXLONGINT ? gIndentation : oldOffset);
    if (newIndent != oldIndent)
    {
      style->fDefined |= (kIndent | kRuler);
      style->SetIndentation(Max(0, newIndent));
    }
  }
}

#define CREATE 1
#define SEARCH 0
// ------------------------------------------------------------------------
static TCurrency DoStyleSheet(TExpressionDocument self, int idx, TStyleFormat emphStyle)
{
  // idx = index to search for
  char *fp = gSheet;

  if (fp)
  {
    TCurrency DoStyleSheet_r = gNullCurrency;
    volatile TStyleFormat vStyle = NULL;
    FailInfo fi;
    int istd;

    CatchFailures(&fi);

    for (istd = 0; istd < gSheetHdr->cstd; istd++)
    {
      int styleLength;

      Load2Byte(styleLength, fp);
      if (styleLength != 0)
      {
        if (idx == istd)    // the one we wanted
        {
          unsigned int isEmphasis;
          MS_STD style;

          memset(&style, 0, sizeof(style));
          memcpy(&style, fp, Min(8, gSheetHdr->cbSTDBaseInFile));
          isEmphasis = style.sgc - 1;

          if (isEmphasis < 2)     // discard unknown style types
          {
            char *stzName = fp + gSheetHdr->cbSTDBaseInFile + 1;
            char *grupx = stzName + stzName[-1] + 1;
            int basedOn = style.istdBase;
            TMainView mainView = (self ? self->ActiveMainView() : NULL);
            TStyleInfo info;

            if (!gSheetHdr->fStdStyleNamesWritten && style.sti != stiUser)
              stzName = GetRsrc(style.sti, 'u');     // see binary file format P28

            // Add named style and synonyms to our style sheet
            do
            {
              char *syn = strchr(stzName, ',');
              TCurrency styleCurr;
              TDiscObject rec;
              char *upx = grupx;
              TStyleFormat styleFormat;
              int styleSheetIdx;

              if (syn != NULL)
                *syn = 0;   // overwrite comma temporarily

              styleSheetIdx = (self ? self->fStyleSheet->FindStyleInfo(stzName, info) : 0);
              if (styleSheetIdx != 0)    // name already in our style sheet
              {
                styleCurr = info.fDocCurrency;
                if (info.fPadCurrency)
                {
                  DoStyleSheet_r = styleCurr;
                  goto Successful;    // we have already built the entry, so return currency
                }
                // ... else style already present so must be built-in style name to be modified
                PStyleInfo(self->fStyleSheet->At(styleSheetIdx))->fPadCurrency = 1;
#if !defined NETWP
// && !defined TRACE
                if (style.sti == stiNormal)
                {
                  // 'Normal' style changes are applied to the document (and h/fs)
                  styleFormat = gNormalStyle;
                }
                else
#endif
                  styleFormat = mainView->GetStyleReadWrite(styleCurr);
              }
              else if (self == NULL)     // 23/09/96 [] support istd sprms
              {
                if (basedOn != istdNil)
                   DoStyleSheet(self, basedOn, emphStyle);
                styleCurr = 1;  // dummy value to stop it being added to style sheet
                styleFormat = emphStyle;
              }
              else if (style.sti == stiNormalChar)
              {
                styleCurr = self->fEmphasisStyle;
                if (self->fNormalCharStyleDone)
                {
                  DoStyleSheet_r = styleCurr;
                  goto Successful;
                }
                self->fNormalCharStyleDone = TRUE;
                styleFormat = mainView->GetStyleReadWrite(styleCurr);
              }
              else
              {
                if (basedOn == istdNil ||
                     (styleCurr = DoStyleSheet(self, basedOn, emphStyle)) == 0)
                                      // gone horribly wrong if styleCurr not found!
                {
                  styleFormat = new _TStyleFormat();
                  // modify properties to match Word nil style!!!
                }
                else
                {
                  styleFormat = TStyleFormat(mainView->GetStyleReadOnly(styleCurr)->Clone());
                }
                vStyle = styleFormat;
                styleCurr = gNullCurrency;
              }
              for (int cupx = Min(style.cupx /* # of entries in grupx */, 2 - isEmphasis);
                                                                   cupx > 0; cupx--)
              {
                int cbUPX;

                if (Odd((int)upx))
                  upx++;
                Load2Byte(cbUPX, upx);
                if (cupx == 2)
                {
                  // *upx (short) contains an istd which seems be identical to current istd
                  upx += 2;
                  cbUPX -= 2;
                }
                ApplyStyleSprms(styleFormat, cbUPX, upx);
                upx += cbUPX;
              }
              styleFormat->fDefined |= (isEmphasis * kEmphasis);
                                 // set kEmphasis for styles marked as Word emphasis (allows
                                 // matching of Maths built-in emphasis styles in AddInStyle)
              if (styleCurr == gNullCurrency)
              {
                styleCurr = self->NewCurrency(kTextStyleStruct, rec);
                TStyleStructure(rec)->IStyleStructure(kText, styleSheetIdx == 0 ? stzName : "");
                mainView->SetStyle(styleCurr, styleFormat);
                vStyle = NULL;
                self->fStyleSheet->AddStyle(stzName, kText, isEmphasis, styleCurr,
#ifdef MATHS
                                strcmp(GetResourceName(kBoldId), stzName) == 0 ? 9 :
#endif
                                                                                 -1);
              }
              if (DoStyleSheet_r == gNullCurrency)
                DoStyleSheet_r = styleCurr;  // return currency of the main style name
              if (syn != NULL)
                *(syn++) = ',';   // replace comma
              stzName = syn;      // NULL or pointer to next synonym
            }
            while (stzName != NULL);
            break;
          }
        }
        fp += styleLength;
      }
    }
Successful:
    Success(&fi);
    return DoStyleSheet_r;
Rescue:
    FreeIfObject(vStyle);
    ContinueFailure(&fi);
  }
  return gNullCurrency;
}

// ------------------------------------------------------------------------
void _TStyleFormat::ApplyWordSprm(int sprmCode, char *sprm, int sprmLen)
{
  int parm = 0;

  if (sprmLen == 1)
    parm = *sprm;
  else if (sprmLen <= 4)
    memcpy(&parm, sprm, sprmLen);

  // first do ones which use the parameter directly
  if (sprmCode == sprmPJc)
    ChangeAlign(TAlignment(parm));
  else if (sprmCode == sprmCFBold)
    DoFaceChange(this, 0);            // !!! need to do properly (use parameter value) !!!
  else if (sprmCode == sprmCFItalic)
    DoFaceChange(this, 1);            // ditto
  else if (sprmCode == sprmCFCaps)
    DoCaseChange(this, kUppercase);   // ditto
  else if (sprmCode == sprmCKul || sprmCode == sprmCFStrike)
    DoUnderline(this, sprmCode == sprmCKul ? kUnderline : kStrikeOut);
  else if (sprmCode == sprmCHps)
    DoSizeChange(this, parm * 8);   // convert from half to sixteenths of a point
  else if (sprmCode == sprmCLid)
  {
    int country;

    for (country = 48; country > 0 && gLids[country] != parm; country--) {}
    DoLanguageChange(this, country);
  }
  else if (sprmCode == sprmPTtp)
    gWordFields.fTtp = *sprm;
  else if (sprmCode == sprmPFInTable)
  {
    if (gWordFields.fInStruct != 0 && *sprm)
      gWordFields.fInStruct = cTable;         // create a table structure
  }
#ifdef TRACE
  else if (sprmCode == sprmPFKeep)
  {
    // cannot support this
  }
  else if (sprmCode == sprmPFKeepFollow)
  {
    // cannot support this (although headings try to keep following para on same page)
  }
#endif
  else if (sprmCode == sprmPChgTabsPapx)
  {
    sprm = DoTabSettings(this, sprm, TRUE); // delete tabs
    DoTabSettings(this, sprm, FALSE);       // add tab settings
  }
  else if (sprmCode >= sprmPBrcTop && sprmCode <= sprmPBrcRight)
  {
    int borderCode;

    Load2Byte(borderCode, sprm);
    DoWordBorders(this, sprmCode, borderCode);
  }
  else if (sprmCode == sprmPBrcBetween)
  {
  }
  else if (sprmCode == sprmPDyaLine)
  {
    // 11/10/96 support line spacing
    int multiLine = parm >> 16;

    parm = (parm << 16) >> 17;  // twips to signed deci-pts
    if (parm < 0)
    {
      parm = -parm;
      fFixedHeight = TRUE;
    }
    else if (multiLine)
      fFixedHeight = 4;    // multiline...
    else
      fFixedHeight = 2;    // at least...
    DoLineSpacing(this, parm);
  }
  else if (sprmCode == sprmPFNoAutoHyph)
  {
    fDefined |= kHyphenate;
    fHyphenate = FALSE;
  }
  else if (sprmCode == sprmCPicLocation)
  {
    gWordFields.fSpec = 1;
    gWordFields.fcPic = parm;
  }
  else if (sprmCode == sprmCFOle2)
  {
    gWordFields.fOle2 = parm;
  }
  else if (sprmCode == sprmCFtc)
  {
    if ((fTextFont = DoFontCode(this, parm, 0, FALSE)) != 0)
      fDefined |= kFont;
#ifdef TRACE
    else
      SysBeep(0);  // strange font code
#endif
  }
  else if ((sprmCode == sprmPNLvlAnm && (gWordFields.fLvlAnm = parm, TRUE))
                                                       || sprmCode == sprmPAnld)
  {
    // Auto-number list descriptor or Auto-number level number (not picked up by body)
    if (gWordFields.fInStruct != 0)
      gWordFields.fInStruct = cList;
  }
  else if (sprmCode == sprmCIco)
  {
    if ((unsigned int)parm < 17)
      DoColourChange(this, gWordColTab[parm]);
  }
  else if (sprmCode == sprmPPc)
  {
    // removed (not correct way of doing it) gWordFields.fPpc = parm & 0x30;
    // change horiz and/or vert position codes (only vert at the moment)
  }
#ifdef TRACE
  else if (sprmCode == sprmPDxaWidth)
  {
    // absolute width of para
  }
  else if (sprmCode == sprmPWr)
  {
    // wrap code for vertical objects
  }
  else if (sprmCode == sprmPWHeightAbs)
  {
    // height of absolute object?
  }
  else if (sprmCode == sprmPDxaFromText)
  {
    // horizontal distance to be maintained between text and absolute object
  }
  else if (sprmCode == sprmPFWidowControl)
  {
    // 1 to stop widowed lines being placed at start of page
  }
#endif
  else if (sprmCode == sprmCIstd)
  {
    DoStyleSheet(NULL, parm, this);
  }
  else if (sprmCode == sprmCChse)
  {
    gWordFields.fChsDiff = *(sprm++);
    Load2Byte(gWordFields.chse, sprm);
  }
  else if (sprmCode == sprmCFSpec)
    gWordFields.fSpec = *sprm;
  else if (sprmCode == sprmCSymbol)
  {
    int ftcSym;   // font code for sym !!!!

    Load2Byte(ftcSym, sprm);
    if ((fTextFont = DoFontCode(this, ftcSym, 0, FALSE)) != 0)
      fDefined |= kFont;
#ifdef TRACE
    else
      SysBeep(0);  // strange font code
#endif
    gWordFields.chSym = *sprm;
    gWordFields.fSpec = 1;
  }
  else if (sprmCode == sprmCFSmallCaps)
  {
    DoCaseChange(this, kUppercase);
    // can only do this if a size defined
    if ((fDefined & kSize) != 0)
      DoSizeChange(this, (fTextSizeY * 3) / 4);
  }
  else if (sprmCode == sprmCHpsKern)
  {
    DoKernChange(this, 0);
  }
  else
  {
    // the following have a signed parameter (so convert from 2-byte unsigned)
    parm = (parm << 16) >> 16;     // extend sign

    if (sprmCode == sprmCHpsPos)
      gWordFields.hpsPos = parm;
      // DoFaceChange(this, parm < 0 ? 3 : 2);  // 2 for superscript; 3 for subscript
                        // cannot use the value of parm (raise/lower by half points)
    else
    {
      // the following have a parameter in twips (20th of a point) so mult by .500 for Fixed
      if (sprmCode >= sprmPDxaRight && sprmCode <= sprmPDxaLeft1)
      {
        Fixed fixParm = ((parm << 16) >> 16) * (kFix1 / 2);  // convert twips to fixed deci-Pts
        int bits = 0;

        if (sprmCode == sprmPDxaRight)
        {
          SetRightMargin(fixParm);
          bits = kRightMgn | kRuler;
        }
        else if (sprmCode == sprmPDxaLeft)
        {
          SetLeftMargin(fixParm);
          bits = kLeftMgn | kRuler;
        }
        else // if (sprmCode == sprmPDxaLeft1)
          gIndentation = fixParm;        // pity we cant save offset & add in at runtime
        fDefined |= bits;
      }
      else
      {
        // the following have a parameter in twips (20th of a point) so divide by 2 for deci-Pts
        parm = parm / 2;
        if (sprmCode == sprmPDyaBefore)
          SetSpaceBefore(parm);
        else if (sprmCode == sprmPDyaAfter)
          SetSpaceAfter(parm);
        else if (sprmCode == sprmPDyaAbs)
        {
          gWordFields.fPcVert = parm;   // absolute position y
        }
#ifdef TRACE
        else if (sprmCode == sprmPDxaAbs)
        {
          // absolute position x
        }
        else
          parm = parm;  // unprocessed sprm
#endif
      }
    }
  }
}

#ifdef TABLES
static TTableStructure gTableLastRow;
// ------------------------------------------------------------------------
void _TColumnStyleFormat::ApplyWordSprm(int sprmCode, char *sprm, int sprmLen)
{
  if (sprmCode == sprmTJc)
  {
  }
  else if (sprmCode == sprmPFInTable)
  {
    if (*sprm)
      gWordFields.fInStruct = 0;  // stay in table
  }
  else if (sprmCode == sprmTDxaGapHalf)
  {
    fDefined |= kRuler;
    SetGutterWidth(((*(sprm + 1) << 8) + *sprm) * 500);
  }
  else if (sprmCode == sprmPFKeepFollow)
  {
    // not ideal, but if any paragraph in table has property, assume whole table kept together
    fDefinedInStyle |= kKeepTogether;
    fKeepTogether = *sprm;
  }
  else if (sprmCode == sprmTFCantSplit)
  {
    // not what CantSplit means - in Word it means do not split text within a row!
    // fDefinedInStyle |= kKeepTogether;
    // fKeepTogether = *sprm;
  }
  else if (sprmCode == sprmTDefTable)
  {
    char *sprmEnd = sprm + sprmLen;
    int itcMac = *(sprm++);
    int spanStart = 0;
    int borderCode;
    int leftEdge;
    TTableStructure tabStruct = TTableStructure(gParentStruct);
    char *cellArrayLimit = sprm + (itcMac + 1) * 2;
    int origSize;
    int failed = FALSE;
    volatile TStyleFormat vStyle = NULL;
    FailInfo fi;

    Load2Byte(leftEdge, sprm);    // first is left of first column, ie left margin
    leftEdge = ((leftEdge << 16) >> 16) * (kFix1 / 2); // - GetGutterWidth();
    //if (leftEdge >= 0)
    {
      // Word can pass negative values for left of first cell
      fDefined |= (kLeftMgn | kRuler);
      SetLeftMargin(leftEdge);
    }
    //else
    //  SetLeftMargin(leftEdge);
    origSize = fSize;
    if (origSize != 0 && itcMac != origSize)
      failed = TRUE;             // get out of table (number of cols differ)

    while (sprm < cellArrayLimit)
    {
      TFTabInfo tabInfo;
      int dxaAdd;

      ITabInfo(tabInfo);

      Load2Byte(dxaAdd, sprm);
      tabInfo.fStop = dxaAdd * (kFix1 / 2);
      tabInfo.fKind = kGutter;
      if (origSize == 0)
        InstallTab(tabInfo);       // first row
      else if (!IsPresent(tabInfo))
        failed = TRUE;             // get out of table (col positions differ on subsequent row)
    }

    if (tabStruct->fSize == 0)
    {
      // copy across last row from from failed table
      int colTot;
      int colIdx;

#ifdef TRACE
      Assert(gTableLastRow, 802);
#endif
      colTot = gTableLastRow->fNumberOfColumns;
      for (colIdx = 1; colIdx <= colTot; )
      {
        PCellItem cellToCopy = gTableLastRow->AtRowCol(gTableLastRow->fNumberOfRows, colIdx);
        int spanCount = cellToCopy->spanCount;

        if (cellToCopy->cell == gNullCurrency)  // do not copy any 'blanks' at row end
          break;
        cellToCopy->spanCount = 0;       // zeroise, to avoid being doubled below
        tabStruct->GetStructureReadWrite(cellToCopy->cell)->fParent = gParentCurr;
        for ( ; spanCount >= 0 && colIdx <= colTot; colIdx++, spanCount--)
          tabStruct->InsertLast(gTableLastRow->AtRowCol(gTableLastRow->fNumberOfRows, colIdx));
      }
      tabStruct->fNumberOfColumns = colIdx - 1;
      ClearObject(gTableLastRow);
      SetSpaceBefore(0);
    }

    CatchFailures(&fi);

    {
      int topBord = 0;
      int botBord = 0;
      int lastRtBord;

      for (char *temp = sprm; temp < sprmEnd; )
      {
        temp += 2;
        Load2Byte(borderCode, temp);
        topBord = (topBord == 0 || topBord == borderCode ? borderCode : -1);
        temp += 2;
        Load2Byte(borderCode, temp);
        botBord = (botBord == 0 || botBord == borderCode ? borderCode : -1);
        temp += 2;
      }
      if (topBord > 0 || botBord > 0)
      {
        Rect custom;

        vStyle = new _TStyleFormat();
        vStyle->fDefined = kHasAdornment;
        SetRect(custom, tabStruct->fNumberOfRows, tabStruct->fNumberOfRows, itcMac, 1);
        if (topBord > 0)
          DoWordBorders(vStyle, sprmPBrcTop, topBord);
        if (botBord > 0)
          DoWordBorders(vStyle, sprmPBrcBottom, botBord);
        tabStruct->InstallStyleChange(gParentCurr, vStyle, kRowPart, custom, cNoCommand);
        ClearObject(vStyle);
      }
      lastRtBord = 0;
      for (int column = 1; column <= itcMac && sprm < sprmEnd; column++)
      {
        int spanInfo;

        Load2Byte(spanInfo, sprm);
        if ((spanInfo & 1) != 0)    // span start cell
          spanStart = column;
        else if ((spanInfo & 2) != 0 && spanStart != 0)    // a spanned cell
        {
          PCellItem item = tabStruct->AtRowCol(tabStruct->fNumberOfRows, column);

          item->hidden = TRUE;
          tabStruct->fDocument->DeleteCurrency(item->cell);
          item->cell = gNullCurrency;
          tabStruct->AtRowCol(tabStruct->fNumberOfRows, spanStart)->spanCount++;
        }
        else
          spanStart = 0;

        PCellItem aCell = tabStruct->AtRowCol(tabStruct->fNumberOfRows,
                                          spanStart == 0 ? column : spanStart);
        if (aCell->cell != 0)
        {
          TStructure cell = tabStruct->GetStructureReadWrite(aCell->cell);

          vStyle = (spanStart == 0 || spanStart == column || cell->fChanges == 0 ?
                     new _TStyleFormat() :
                     TStyleFormat(cell->fDocument->ActiveMainView()->
                                                    GetStyleReadOnly(cell->fChanges)->Clone()));

          Load2Byte(borderCode, sprm);
          if (topBord < 0)                      // skip top - if done above
            SetWordBorders(vStyle, sprmPBrcTop, borderCode);
          Load2Byte(borderCode, sprm);
          if (lastRtBord == 0)
            SetWordBorders(vStyle, sprmPBrcLeft, borderCode);
          Load2Byte(borderCode, sprm);
          if (botBord < 0)                      // skip bottom - if done above
            SetWordBorders(vStyle, sprmPBrcBottom, borderCode);
          Load2Byte(borderCode, sprm);
          lastRtBord = borderCode;
          SetWordBorders(vStyle, sprmPBrcRight, borderCode);
          cell->InstallStyleChange(aCell->cell, vStyle, 1, gZeroRect, cNoCommand);
          ClearObject(vStyle);
        }
        else
          sprm += 8;                      // skip border definition
      }
    }
    Success(&fi);

    if (failed)
    {
      int rowNum;

      gWordFields.fInStruct = cTable;               // mark as finished that table
#ifdef TRACE
      Assert(gTableLastRow == NULL, 803);
#endif
      gTableLastRow = TTableStructure(tabStruct->Clone()); // save last row for reentry

      // prune off last row, and any spare columns added because last row was wider than others
      tabStruct->fNumberOfRows--;
      tabStruct->ReduceSize(tabStruct->fNumberOfColumns * tabStruct->fNumberOfRows);
      while (TRUE)
      {
        for (rowNum = 1; rowNum <= tabStruct->fNumberOfRows; rowNum++)
        {
          PCellItem cellToTest = tabStruct->AtRowCol(rowNum, tabStruct->fNumberOfColumns);

          if (cellToTest->cell != 0 || cellToTest->hidden)
            return;                                      // all done
        }
        for (rowNum = 1; rowNum <= tabStruct->fNumberOfRows; rowNum++)
        {
          tabStruct->AtRowCol(rowNum, tabStruct->fNumberOfColumns)->hidden = TRUE;
        }
        tabStruct->CommitColumn(gParentCurr, tabStruct->fNumberOfColumns, NULL, NULL, NULL);
      }
    }
Rescue:
    FreeIfObject(vStyle);
    ContinueIfFail(&fi);
  }
  else if (sprmCode == sprmTTableBorders)
  {
    memcpy(gTableBorders, sprm, 12);
  }
  else if (sprmCode == sprmTTableHeader)
  {
    // 23/08/96 [27046] support import of Word table headings
    TTableStructure(gParentStruct)->
            AtRowCol(TTableStructure(gParentStruct)->fNumberOfRows, 1)->heading = TRUE;
  }
  else if (sprmCode == sprmTTlp)
  {
  }
//  else
//    _TStyleFormat::ApplyWordSprm(sprmCode, sprm, sprmLen);
}
#endif

// ------------------------------------------------------------------------
void _TBodyStyle::ApplyWordSprm(int sprmCode, char *sprm, int sprmLen)
{
  int parm = 0;

  if (sprmLen == 1)
    parm = *sprm;
  else if (sprmLen <= 4)
    memcpy(&parm, sprm, sprmLen);

  if (sprmCode == sprmSNfcPgn)
  {
    fDefinedInBody |= kRomanPages;
    fRomanPages = (unsigned int)(parm - 1) < 2;
  }
  else if (sprmCode == sprmSFEndnote)
  {
    //tag.docStyle.fEndNotes = parm;
    //fDefinedInBody |= kEndNotes;
    // 09/09/96 [27071] this means: 0 - place footnotes at the end of page, 1 at end of section
    tag.docStyle.fEndChapter = parm;
    fDefinedInBody |= kCollector;
  }
  else if (sprmCode == sprmSPgnStart)
  {
    // start number for chap/doc
    gWordFields.pgnStart = parm;
  }
  else if (sprmCode == sprmSFPgnRestart)
  {
    // start number for chap/doc
    gWordFields.pgnRestart = parm;
  }
  else if (sprmCode == sprmSCcolumns)
  {
    fDefined |= kRuler;
    SetTotalColumns(parm + 1);
    // really should look at the section type to decide balance!!!
    fDefinedInBody |= kBalanced;
    fBalanced = TRUE;
  }
  else if (sprmCode == sprmSDxaColWidth)
  {
    if ((parm & 0xff) == 0)
      gWordFields.firstColumn = parm >> 8; // first col of side heading in twips
  }
  else if (sprmCode == sprmSDxaColSpacing)
  {
    if ((parm & 0xff) == 0)              // if column 1, set ...
      gWordFields.firstGap = parm >> 8;  // inter column gap for side heading
  }
  else if (sprmCode == sprmSFEvenlySpaced)
  {
    gWordFields.fEvenSpace = parm;   // do not do side heading unless even spacing set off
  }
  else if (sprmCode == sprmSDxaColumns)
  {
    fDefined |= kRuler;
    SetGutterWidth(parm * 500);
  }
  else if (sprmCode == sprmSLBetween)
  {
    fColSepRule.fRule = k1Thn;
    fColSepRule.fPen = kOnePtPen;
    fColSepRule.fShort = FALSE;
    fDefinedInBody |= kColSepRule;
  }
  else if (sprmCode == sprmSVjc)
  {
    fJustify = (parm == 2);  // full vert justify
    fDefinedInBody |= kJustify;
  }
  else if (sprmCode == sprmSBkc)
  {
    int newVal = 0;

    fDefinedInBody |= kPageAlign;
    fNewPage = TRUE;
    fBodyAlignment = 0;
    switch (parm)
    {
      case 0: fNewPage = FALSE;    // immediately
              newVal -= 2;
      case 1:
      case 2: newVal -= 1;                      // next page
      case 3: newVal += 2;                      // even pg
      case 4: fBodyAlignment = newVal - 1;  // odd pg
    }
  }
  else if (sprmCode == sprmPNLvlAnm)
  {
    gWordFields.fLvlAnm = parm;             // hopefully set before tested below
    gWordFields.fInStruct = 0;  // force the test to be based on the level change
    // set up fBullet now as sometimes there is no following sprmPAnld
    if (gWordFields.fLvlAnm == 12)
    {
            // make a sublist (no bullet). Is this what LvlAnm == 12 means? (not in spec)
#ifdef AUTONUM
      fBullet = 2;
#else
      fBullet = ' ';
#endif
      fDefined |= kBullet;
    }
  }
  else if (sprmCode == sprmPAnld)
  {
    // Auto-number list descriptor
    MS_ANLD anld;
    char *ans = anld.rgchAnld;

    memcpy(&anld, sprm, sizeof(MS_ANLD));

    // 10/09/96 [27076] if gWordFields.fInStruct still set, there was no sprmPNLvlAnm,
    // so assume an implicit one with value zero
    if (gWordFields.fInStruct != 0)
    {
      gWordFields.fInStruct = 0;
      gWordFields.fLvlAnm = 0;
    }
    if (gWordFields.fLvlAnm == 0)
      fBullet = 0;
    else if (gWordFields.fLvlAnm != 12)     // fLvlAnm == 12 handled above
    {
#ifdef AUTONUM
      fBullet = 2;
      if (gWordFields.fLvlAnm <= 10)   // auto-number
      {
        int cnt = anld.cbTextBefore;

        if (anld.iStartAt != 1)
        {
          int startNumLen;
          char tBuff[8];

          NumToString(anld.iStartAt, tBuff);
          startNumLen = strlen(tBuff);
          cnt += startNumLen + 3;
          *((char *)memmove(ans + startNumLen + 3, ans, 28 - startNumLen) - 1) = '}';
          ans[0] = '%';
          ans[1] = '{';
          strncpy(ans + 2, tBuff, startNumLen);
        }
        if (cnt + anld.cbTextAfter == 0)
        {
          if (anld.nfc != 255)         // 20/09/96 [27092] leave empty if no number
            fBullet = 1;   // plain auto-number
          *ans = 0;
        }
        else if (anld.nfc != 255)
        {
          char *p;

          cnt = Min(29, cnt);
          p = ans + cnt;
          p = (char *)memmove(p + 2, p, 29 - cnt);
          *(--p) = (anld.nfc >= 5 ? '1' : "1IiAa"[anld.nfc]);
          *(--p) = '%';
        }
      }
      ans[31] = 0;
      if (anld.jc == 2 && strlen(ans) < 30)
        strcat(ans, "%>");                            // rt just
      if (anld.dxaSpace > 0 && strlen(ans) < 31)
        strcat(ans, " ");
      // convert from windows character set
      for (char *q = ans; ; )
      {
        unsigned int ch = *(q++);

        if (ch == 0)
          break;
        ch -= 0x81;
        if (ch < 0xa0 - 0x81)
          *(q - 1) = ggWindowsToArc[ch];
      }
      SetAutoCustom(ans);
#endif
    }
    fBulletFont = DoFontCode(this, anld.ftc, 0, TRUE);
    fDefined |= kBullet;
    fAutoBullet = TRUE;
  }
#ifdef TRACE
  // probably cannot do these
  else if (sprmCode == sprmSScnsPgn)
  {
  }
  else if (sprmCode == sprmSOlstAnm)
  {
  }
  else if (sprmCode == sprmSDMPaperReq)
  {
  }
#endif
  else
  {
    // the following have a parameter in twips (20th of a point) so mult by .500 for Fixed
    TPagesPrintHandler prHdlr = TPagesPrintHandler(gMainDoc->fDocPrintHandler);
    Fixed fixParm = ((parm << 16) >> 16) * (kFix1 / 20);
                                // convert twips to fixed points with sign extension

    if (sprmCode == sprmSXaPage || sprmCode == sprmSYaPage)
    {
      if ((sprmCode == sprmSXaPage) != (prHdlr->fHPrint->landscape))
        prHdlr->fHPrint->rPaper.right = prHdlr->fHPrint->rPaper.left + fixParm;
      else
        prHdlr->fHPrint->rPaper.bottom = prHdlr->fHPrint->rPaper.top + fixParm;
    }
    else if (sprmCode == sprmSDxaLeft)
    {
      prHdlr->fRawMargins.left = fixParm;
    }
    else if (sprmCode == sprmSDxaRight)
    {
      prHdlr->fRawMargins.right = -fixParm;
    }
    else if (sprmCode == sprmSBOrientation)
    {
      prHdlr->fHPrint->landscape = (parm != 0);  // parm may be 2!
    }
    // not correct!!!!
    // else if (sprmCode == sprmSDzaGutter)
    // {
    //   fDefined |= kRuler;
    //   SetGutterWidth(fixParm);
    // }
    else
    {
      if (!gWordFields.hfDone)
      {
        if (sprmCode == sprmSDyaTop)  // 08/10/96 only do next 2 before h/f size calcs done
        {
          prHdlr->fRawMargins.top = fixParm;
        }
        else if (sprmCode == sprmSDyaBottom)
        {
          prHdlr->fRawMargins.bottom = -fixParm;
        }
        else if (sprmCode == sprmSGprflhdt)
        {
          gWordFields.grpflhdt = parm;            // headers and footers flags (P51)
          //if ((parm & 0x30) != 0)
          //{
          //  fHFVisibility = kHFAllBut1stPage;
          //  fDefinedInBody |= kHFVisibility;
          //}
        }
        else if (sprmCode == sprmSFTitlePage)
        {
          gWordFields.fTitlePage = parm;
        }
        else if (sprmCode == sprmSDyaHdrTop)
        {
          gWordFields.dyaHdrTop = fixParm;       // header offset
        }
        else if (sprmCode == sprmSDyaHdrBottom)
        {
          gWordFields.dyaHdrBottom = fixParm;    // footer offset
        }
      }
    }
  }
//    _TStyleFormat::ApplyWordSprm(sprmCode, sprm, sprmLen);
}

// ------------------------------------------------------------------------
void _TPictStyle::ApplyWordSprm(int sprmCode, char *sprm, int sprmLen)
{
  if (sprmCode == sprmPicBrcl)
  {
  }
//  else
//    _TStyleFormat::ApplyWordSprm(sprmCode, sprm, sprmLen);
}

// ------------------------------------------------------------------------
static char *LocateBIN(MS_FIB *fib, char *fibPos, int kind, int offset)
{
  // locate the BIN for the paragraph (kind = 1) (page 25) or character (kind = 0)
  MS_FIBpair *pr = (MS_FIBpair *)&fib->fcPlcfbteChpx;
  int tabLen = pr[kind].lcbFld;

  if (tabLen != 0)
  {
    char *p = fibPos + pr[kind].fcFld;
    int entriesPresent = (tabLen - 4) / 6;
    char *q;
    int runEnd;
    int binPage;

#ifdef TRACE
    if ((&fib->cpnBteChp)[kind] > entriesPresent)
      SysBeep(0);
#endif

    q = p + entriesPresent * 4 + 2;  // point at -1th entry
    do
    {
      q += 2;
      p += 4;
      memcpy(&runEnd, p, 4);
    }
    while (offset >= runEnd);
    Load2Byte(binPage, q);          // the FKP (formatted disk page offset)

    return fibPos + binPage * 512;
  }
  return NULL;
}
#endif

// ------------------------------------------------------------------------
static TCurrency InsertPic(TExpressionDocument self, TCurrency parentCurr, TStructure doc,
                            int picKind
#ifdef WORD7
                            , void *msPicPtr, int userAlignV
#endif
                                       )
{
  TDiscObject picRec;
  TCurrency picCurrency = self->NewCurrency(kPictStruct, picRec);
  TCurrency pictStyle = self->GetStyleAtLevel0(picKind);

  TPictStructure(picRec)->
       InitNewStructure(parentCurr, picCurrency, pictStyle, picKind, FALSE, NULL);
  if (doc)
  {
    long picPos = -1;

    doc->InsertSubStructure(0, NULL, parentCurr, picCurrency, picPos);
  }
#ifdef WORD7
  if (picKind != kPageBreak)
  {
    TPictStyle picChanges = new _TPictStyle();
    FailInfo fi;

    CatchFailures(&fi);

    if (msPicPtr)
    {
      // create a sprite object to hold the data fDrawDiagStr & set fSprite
      // and set fPicture in structure. Set fUserAlign?? (not for in-line anyway)!
      TPictObject pictObj;
      wr_draw_spristrhdr *sprihdr;
      int lenTo4;
      int xZoom;
      int yZoom;
      MS_PIC msPic;

      memcpy(&msPic, msPicPtr, sizeof(MS_PIC));    // copy as may not be word aligned
      lenTo4 = ((msPic.lcb + 3) >> 2) << 2;
      TPictStructure(picRec)->fUndoPicture =       // for quirk in picture/text relationship
        TPictStructure(picRec)->fPicture = self->AddNewPictureObject(pictObj);
      SetPermHandleSize(&pictObj->fDrawDiagStr.data,
                       sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr) + lenTo4);
      sprihdr = (wr_draw_spristrhdr *)(pictObj->fDrawDiagStr.data + sizeof(wr_draw_fileheader));
      sprihdr->tag = 77;
      sprihdr->size = sizeof(wr_draw_spristrhdr) + lenTo4;
      sprihdr->bbox.x0 = 0;
      sprihdr->bbox.y0 = 0;
      sprihdr->bbox.x1 = msPic.dxaGoal * 32;  // convert twips to draw units
      sprihdr->bbox.y1 = msPic.dyaGoal * 32;

      create_diag(&pictObj->fDrawDiagStr, gProgName, &sprihdr->bbox);
      pictObj->fDrawDiagStr.length = sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr) + lenTo4;
      memcpy(pictObj->fDrawDiagStr.data + sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr),
                                                                          msPicPtr, msPic.lcb);
      pictObj->fSprite = 9;
      yZoom = msPic.my;
      if (yZoom != 1000)
      {
        picChanges->fScaleFactor.v = yZoom / 10;
        picChanges->fDefinedInPict |= kVScale;
      }
      xZoom = msPic.mx;
      if (xZoom != 1000)
      {
        picChanges->fScaleFactor.h = xZoom / 10;
        picChanges->fDefinedInPict |= kHScale;
      }
      if (msPic.dxaCropLeft != 0)
      {
        picChanges->fCropRect.left = FromFixed(msPic.dxaCropLeft * xZoom / 2);
        picChanges->fDefinedInPict |= kLeftCrop;
      }
      if (msPic.dyaCropTop != 0)
      {
        picChanges->fCropRect.top = FromFixed(msPic.dyaCropTop * yZoom / 2);
        picChanges->fDefinedInPict |= kTopCrop;
      }
      if (msPic.dxaCropRight != 0)
      {
        picChanges->fCropRect.right = FromFixed(msPic.dxaCropRight * xZoom / 2);
        picChanges->fDefinedInPict |= kRightCrop;
      }
      if (msPic.dyaCropBottom != 0)
      {
        picChanges->fCropRect.bottom = FromFixed(msPic.dyaCropBottom * yZoom / 2);
        picChanges->fDefinedInPict |= kBtmCrop;
      }
      if (msPic.brcTop)
        DoWordBorders(picChanges, sprmPBrcTop, msPic.brcTop);
      if (msPic.brcLeft)
        DoWordBorders(picChanges, sprmPBrcLeft, msPic.brcLeft);
      if (msPic.brcBottom)
        DoWordBorders(picChanges, sprmPBrcBottom, msPic.brcBottom);
      if (msPic.brcRight)
        DoWordBorders(picChanges, sprmPBrcRight, msPic.brcRight);
      if (userAlignV)
      {
        picChanges->fUserAlign.v = userAlignV * (-5);   // convert to deci-pts
        picChanges->fDefinedInPict |= kUserAlign;
      }
      TPictStructure(picRec)->fBaseLine = -1; // Word pix sit on baseline
#ifndef NETWP
      // Use ImageFs to convert to a RISC_OS format
      {
        wr_os_filestr f;

        // Write the picture data to Wimp$Scrap file
        if (memcmp((char *)msPicPtr + msPic.cbHeader + 18,
                                                    "\x14\x00\x00\x00\x26\x06\x0f", 8) == 0)
        {
          f.start = (int)msPicPtr + msPic.cbHeader + 18 + 68;
          f.loadaddr = 0xfd5;       // Mac PICT
        }
        else
        {
          f.start = (int)msPicPtr + msPic.cbHeader;
          f.loadaddr = 0xb2f;       // Windows Metafile
        }
        f.end = f.start + msPic.lcb;
        f.action = 10;
        f.name = "<Wimp$ScrapDir>.WordPic";
        FailOSErr(wr_os_file(&f));

        // Read it back
        f.action = 17;
        FailOSErr(wr_os_file(&f));
        if (f.action == 3)
        {
          wr_os_filestr f1;
          int oldLen = GetHandleSize(pictObj->fDrawDiagStr.data);
          int addLen;

          f1.action = 17;
          f1.name = "<Wimp$ScrapDir>.WordPic.*";
          FailOSErr(wr_os_file(&f1));

          addLen = f1.start;
          SetHandleSize(&pictObj->fDrawDiagStr.data, oldLen + addLen);
          if (!MemError() && (f1.loadaddr & 0x000fff00) == kDrawFile * 256)
          {
            // insert conversion in the Draw file
            f1.action = 16;
            f1.loadaddr = (int)pictObj->fDrawDiagStr.data + oldLen;
            f1.execaddr = 0;
            FailOSErr(wr_os_file(&f1));
            addLen -= 40;
            memmove((char *)pictObj->fDrawDiagStr.data + oldLen,
                   (char *)pictObj->fDrawDiagStr.data + oldLen + 40, addLen);
            SetHandleSize(&pictObj->fDrawDiagStr.data, oldLen + addLen);
            if (*((int *)pictObj->fDrawDiagStr.data + (oldLen / 4)) == 13)  // transformed sprite
              for (int ii = 2; ii <= 11; ii++)
                *((int *)pictObj->fDrawDiagStr.data + (oldLen / 4) + ii) *= 16;
            pictObj->fDrawDiagStr.length += addLen;
            pictObj->fSprite = 0;
          }
        }
        f.action = 6;   // delete file
        FailOSErr(wr_os_file(&f));
      }
#endif
    }
    else
    {
      picChanges->fDefinedInPict |= kBtmCrop;
      picChanges->fCropRect.bottom = 160 - gWordFields.fPcVert;
    }
    TPictStructure(picRec)->InstallStyleChange(picCurrency, picChanges, 1, gZeroRect, cNoCommand);
    Success(&fi);

Rescue:
    FreeIfObject(picChanges);
    ContinueIfFail(&fi);
  }
#endif
  return picCurrency;
}

// ------------------------------------------------------------------------
static char *ReadAlienText(TExpressionDocument self, char *textPosInScrap, char *textEnd,
                 TCurrency parentCurr, int makeStruct, bool aNewDocument,
#ifdef WORD7
                 MS_FIB *fib, char *fibPos, int listLvl,
#endif
                 int sep)
{
  char *startPosInScrap;
  char *posInOutput;
  int ch = chReturn;
  int lastChar = chReturn;  // so can detect CSV comment at start or after a CR
  bool inText = FALSE;      // used as flag in CSVs
  bool softNL = FALSE;
  int row = 1;
  int column = 0;
  bool newRow = FALSE;
  bool formFeed;
  TEmphInfo emphInfo;
  OSType fileType = self->fFileType;
  TStructure doc = self->GetStructureReadWrite(parentCurr);
  TEmphInfo *paraEmphs = NULL;
  TEmphInfo **pEmphs = &paraEmphs;   // compiler objects to paraEmphs being volatile
#ifdef WORD7
  int charLim = 256;  // for fast test on each character
  TCurrency paraStyleCurr;
  volatile TStyleFormat paraChanges = NULL;
  volatile TStyleFormat structChanges = NULL;
  volatile TStyleFormat styleCopy = NULL;
  volatile TStyleFormat aStyle = NULL;
  int nextSection = 0;
  int fieldLevel = 0;
#ifdef FN
  int nextFn = 0;
#endif
  int endOfRun;
  TStructTypes structType = kTextStruct;
  TCurrency lastSpAfter = 0;   // copy last space after from para to enclosing struct
  TMainView mv = self->ActiveMainView();
#endif
  FailInfo fi;

  if (makeStruct)
  {
    TDiscObject structRec;
    long structPos;
    TStyleTypes styleType;
    TCurrency structCurr;

    CmdToStruct(makeStruct, styleType, structType);
    structCurr = self->NewCurrency(structType, structRec);
    TStructure(structRec)->InitNewStructure(parentCurr, structCurr, 0, styleType, FALSE, NULL);
    structPos = -1;
    doc->InsertSubStructure(0, NULL, parentCurr, structCurr, structPos); // 24/04/96 why was it 1?
    doc = TStructure(structRec);  // now insert paras into the struct
    parentCurr = structCurr;
    if (aNewDocument)
      doc->fStyle = self->GetStyleAtLevel(styleType, 1);
#ifdef WORD7
    if (fileType == kMSWord)
    {
      structChanges = TStyleFormat(mv->
                         GetPrototype(structType + (structType >= kTableStruct ? 5 : 6)));
      if (makeStruct == cTable)
      {
        TColumnStyleFormat(structChanges)->fKeepTogether = FALSE;   // Word default setting
        TColumnStyleFormat(structChanges)->fAutomatic = FALSE;      // Word default setting
        TColumnStyleFormat(structChanges)->fDefinedInStyle |= (kKeepTogether | kAutomatic);
      }
    }
#endif
  }
#ifdef WORD7
  else if (fileType == kMSWord)
  {
    structChanges = new _TBodyStyle();
  }
#endif

  CatchFailures(&fi);

#ifdef WORD7
  memset(gTableBorders, 255, 12);
                           // default borders for a table (assumes Word has no nested tables)
  if (fileType == kMSWord)
  {
    // init flags set when processing sepx
    gWordFields.fEvenSpace = 1;
    gWordFields.pgnStart = 1;         // 11/10/96
    gWordFields.pgnRestart = 0;
    gWordFields.firstColumn = 2880;   // twips
    gWordFields.firstGap = 720;

    // title page (set hidden first in header/footer style?)
    if (gWordFields.fTitlePage && (doc->GetKind() == kHeader || doc->GetKind() == kFooter))
    {
      TBodyStyle(structChanges)->fHFVisibility = kHFAllBut1stPage;
      TBodyStyle(structChanges)->fDefinedInBody |= kHFVisibility;
    }
    memcpy(&nextSection, gNextSection, 4);
    while (textPosInScrap - fibPos - fib->fcMin >= nextSection)   // 04/09/96 [27065] from if
    {
      int fcSepx;

      gNextSection += 4;
      memcpy(&nextSection, gNextSection, 4);
      if (textEnd > nextSection + fibPos + fib->fcMin)
        textEnd = nextSection + fibPos + fib->fcMin;  // 08/10/96 [27102]
      memcpy(&fcSepx, gNextSED + 2, 4);
      gNextSED += 12;  // sizeof MS_SED
      if (fcSepx != -1)
      {
        // apply section sprms to document/chapter style
        char *sprmPtr = fibPos + fcSepx;
        int sprmLen;

        Load2Byte(sprmLen, sprmPtr);
        ApplyStyleSprms(structChanges, sprmLen, sprmPtr);
        if (doc->GetKind() <= kChapter)
        {
          //int startPgn = 1;

          //if ((gWordFields.pgnStart && (startPgn = gWordFields.pgnStart, TRUE)) ||
          //      gWordFields.pgnRestart)
          //  TBodyFormat(mv->GetFormatReadOnly(parentCurr))->fPageNumber = startPgn;
          // 11/10/96 it seems restart overrides pgnStart
          if (gWordFields.pgnRestart)
            TBodyFormat(mv->GetFormatReadOnly(parentCurr))->fPageNumber = gWordFields.pgnStart;
          if (structChanges->fTotalColumns == 2 && gWordFields.fEvenSpace == 0)
          {
            structChanges->fTotalColumns = 0;
            TBodyStyle(structChanges)->fDefinedInBody |= kHeadingType;
            TBodyStyle(structChanges)->fHeadingType = kSideHeading;
            DoColumnsChange(structChanges, gWordFields.firstColumn * 2, gWordFields.firstGap * 2);
          }
        }
      }
    }
#ifdef FN
    memcpy(&nextFn, memcmp(gNextFn, gNextEndn, 4) > 0 ? gNextEndn : gNextFn, 4);
#endif
  }
#endif

  while (
#ifdef WORD7
        ClearObject(paraChanges),
#endif
        DisposIfHandle(paraEmphs),
        paraEmphs = NULL,
        textPosInScrap < textEnd)
  {
    // build a paragraph
    int paraSize;

#ifdef WORD7
    gWordFields.fInStruct = (makeStruct == 0 ? cChapter : makeStruct);
                    // chapter exit is handled by finding section marks, not sprm properties!
    gWordFields.fTtp = gWordFields.fLvlAnm = gWordFields.fPpc = 0;
    // gWordFields.fCurrLvl = listLvl;
#endif
    formFeed = FALSE;
    posInOutput = startPosInScrap = textPosInScrap;
                   // reset pointers first time through & after a CR
    emphInfo.style = NULL;
#ifdef WORD7
    endOfRun = 0;
    paraStyleCurr = 0;

    if (fileType == kMSWord)
    {
      // locate the BIN for the paragraph (see page 25)
      int paraStart = startPosInScrap - fibPos;
      char *binPage = LocateBIN(fib, fibPos, 1, paraStart);

      if (binPage != NULL)
      {
        char *p;
        char *q;
        int runEnd;
        int crun;
        int cw;
        int istd = 0;
#ifdef TRACE
        int pSz = (fib->nFib == 45 ? 1 : 7);
#else
#define pSz 7
#endif

        p = binPage;
        crun = p[511];
        q = p + (crun * 4) + 4 - pSz;  // point a -1th 7-byte BX entry (only first byte needed!)
        do
        {
          q += pSz;
          p += 4;
          memcpy(&runEnd, p, 4);     // probably OK to assume 32-bit aligned
        }
        while (paraStart >= runEnd);

        if (*q == 0)
        {
          // normal style properties (istd == 0)?
          cw = 1;          // obviously no grpprl to apply
        }
        else
        {
          p = binPage + *q * 2;   // pointer to PAPX structure
          cw = *(p++);            // count of short words in PAPX as this is in FKP not STSH
          Load2Byte(istd, p);     // index to style descriptor for paragraph (NB short aligned)
          // p now points to list of sprms (grpprl) for modifying style descriptor
          // which has a length of (cw - 1) * 2, with a possible zero padding byte
#ifdef TRACE
          if (fib->nFib == 45)
          {
            cw--;
            p += 2;
          }
#endif
        }
        paraStyleCurr = DoStyleSheet(self, istd, NULL);

        styleCopy = NULL;
        if (cw > 1)          // there are changes (grpprl) to apply
        {
          cw = cw * 2 - 2;

          if (makeStruct)
          {
            // set up static vars rather than passing as params all the way to table Sprm analysis
            gParentStruct = doc;
            gParentCurr = parentCurr;
            styleCopy = TStyleFormat(structChanges->Clone());
            ApplyStyleSprms(structChanges, cw, p);
          }
          paraChanges = new _TStyleFormat();
          ApplyStyleSprms(paraChanges, cw, p);
          // sets gWordFields.fInStruct, .fTtp, fLvlAnm
        }
        // to be correct, DoStyleSheet should set cellFlag if appropriate ...
        // assuming it is possible to have a cellFlag set in the style sheet!!!?
        if (gWordFields.fInStruct != cChapter && (gWordFields.fInStruct != 0 ||
                   (gWordFields.fInStruct = cList, gWordFields.fLvlAnm != (listLvl & 15))))
        {
          int level = listLvl & 15;

          if (styleCopy)
          {
            ReplaceObject(structChanges, styleCopy);
                                      // these styles changes may be corrupted by other level
            styleCopy = NULL;
          }
          if ((gWordFields.fLvlAnm < level && (level < 10 || gWordFields.fLvlAnm < 10)) ||
                (gWordFields.fLvlAnm >= 10 && (listLvl & (1 << gWordFields.fLvlAnm)) != 0) ||
                 (gWordFields.fInStruct == makeStruct && gWordFields.fLvlAnm == level))
                                                  // exit from this level of structure
          {
            textEnd = textPosInScrap;   // satisfy end of loop condition after freeing styles
                                        // exit out as that was the end of the table/body!
          }
          else
          {
            // process the nested structure, starting at the paragraph start we just found
            textPosInScrap = ReadAlienText(self, textPosInScrap, textEnd, parentCurr,
                                           gWordFields.fInStruct, TRUE, fib, fibPos,
                (gWordFields.fLvlAnm >= 10 ? gWordFields.fLvlAnm  | (1 << gWordFields.fLvlAnm) :
                       (gWordFields.fLvlAnm > level) + level) | (listLvl & 0xffffffe0), sep);
          }
          continue;                      // paraChanges should be freed at start of loop
        }
        ClearObject(styleCopy);
      }
    }
#endif

    /* process each character (and any qualifiers) in the following loop    */
    /* NB. it performs an in-situ edit, so be careful input not overwritten */
    /* -------------------------------------------------------------------- */
    do
    {
#ifdef WORD7
      // Check to see if we have reached a point where the CHP style changes (or are at start)

      if (fileType == kMSWord)
      {
        int currPos = textPosInScrap - fibPos;

        if (currPos >= endOfRun)
        {
          // find the CHPX which refer to the current position, and set endOfRun to the
          // offset where a style change will be next needed
          char *plcfbte = LocateBIN(fib, fibPos, 0, currPos);

          gWordFields.fSpec = gWordFields.fChsDiff = gWordFields.hpsPos = gWordFields.fOle2 = 0;
               // NB the setting of endOfRun forces this initialisation at start of every para!

          if (plcfbte != NULL)
          {
            long *rgfc = (long *)plcfbte;  // pointer to min/max offset of each run
            int rgb;
            char *chpx;

            while (currPos >= endOfRun)
            {
              endOfRun = *(rgfc++);     // probably OK to assume 32-bit aligned
            }

            rgb = *(plcfbte + plcfbte[511] * 4 + (rgfc - (long *)plcfbte) + 2);
            paraEmphs = AddAnEmphasis(paraEmphs, posInOutput - startPosInScrap, &emphInfo);
                             // write away the outstanding emphasis

            // Prepare the emphasis style for the following run of characters in emphInfo
            if (rgb == 0 || rgb == 255)        // 21/10/96 undocumented feature rgb == 255
            {
#ifdef TRACE
              if (rgb == 255)
                SysBeep(0);
#endif
              emphInfo.style = NULL;           // plain - so no emphasis over this bit
            }
            else
            {
              chpx = plcfbte + rgb * 2;  // points to count byte/chpx encoding
              emphInfo.style = new _TStyleFormat();
#ifdef TRACE
              if (fib->nFib == 45)
                ApplyStyleSprms(emphInfo.style, *chpx - 2, chpx + 3);
              else
#endif
              ApplyStyleSprms(emphInfo.style, *chpx, chpx + 1);
              // may set CHP props in gWordFields.fSpec, .fChsDiff, .chse, .chSym

              if (gWordFields.hpsPos && (*textPosInScrap != MS_PicMark || !gWordFields.fSpec))
                // any setting of hpsPos is a superscript, not a picture raise/lower
                DoFaceChange(emphInfo.style, gWordFields.hpsPos < 0 ? 3 : 2);
                                             // 2 = super; 3 = subscript
#ifdef TRACE
//              if ((emphInfo.style->fDefined & ~kEmphasis) == 0)
//                ClearObject(emphInfo.style);
#endif
            }
          }
          charLim = (gWordFields.fChsDiff ? gWordFields.chse : fib->chse) ? 128 : 129;
                                              // Mac convert all above character code 128
        }
#ifdef FN
        // 23/09/96 [27095] Handle non-automatic numbered footnotes
        if (currPos == nextFn + fib->fcMin)
        {
          char *nxtFnPtr;

          if (!gWordFields.fSpec)
          {
            *textPosInScrap = MS_FnRefMark;
            gWordFields.fSpec = TRUE;
          }
          // update pointer to next footnote or endnote
          currPos -= fib->fcMin;
          if (memcmp(&currPos, gNextFn, 4) == 0)
          {
            gNextFn += 4;
            nxtFnPtr = gNextFn;
          }
          else
          {
            gNextEndn += 4;
            nxtFnPtr = gNextEndn;
          }
          memcpy(&nextFn, nxtFnPtr, 4);
        }
#endif
      }
#endif

      ch = *(textPosInScrap++);

#ifdef TABLES
      if (makeStruct == cTable && newRow)
      {
        row++;
        column = 0;
        newRow = FALSE;
      }
#endif

      /* CSV file type */
      /* ------------- */
      if (fileType == kCSV)
      {
        bool anEscape;

        // 02/11/92 ignore comment lines
        if (ch == '#' && lastChar == chReturn)
        {
          while (textPosInScrap < textEnd &&
               (ch = *(textPosInScrap++), ch != kEditFileReturn && ch != kEditFileLF))
          {}
          ch = chReturn;
          while (textPosInScrap < textEnd &&
               (ch = *(textPosInScrap++), ch == kEditFileReturn || ch == kEditFileLF))
          {}
        }
        // 02/11/92 handle \escapes
        if (ch == '\\' && textPosInScrap < textEnd - 1)
        {
          anEscape = TRUE;
          ch = *(textPosInScrap++);
          if (ch == 'n')
            ch = chLineFeed;
          else if (ch == 't')
            ch = chTab;
          else if (ch == 'x' && textPosInScrap < textEnd - 2)
          {
            ch =  (*(textPosInScrap++) & 0x0f) << 4;
            ch |= (*(textPosInScrap++) & 0x0f);
          }
          // else take char after \ untranslated
        }
        else if (anEscape = FALSE, inText)
        {
          if (ch == '\"')
            inText = FALSE;
        }
        else if (ch == '\"')
          inText = TRUE;
        else if (ch == ',')
        {
          if (textPosInScrap != textEnd)  // 02/06/92 else update below
            column++;
          ch = chReturn;
        }
        else if (ch == kEditFileReturn || ch == kEditFileLF)
        {
          // remove blank lines and CR/LF etc.
          while (textPosInScrap < textEnd &&
               (ch = *textPosInScrap, ch == kEditFileReturn || ch == kEditFileLF))
            textPosInScrap++;
          ch = chReturn;
          if (textPosInScrap != textEnd)  // 02/06/92 else update below
            column++;
          newRow = TRUE;
        }
        if (textPosInScrap == textEnd)
          column++;         // 02/06/92 there is no return to update column
        // if (anEscape || ch != '\"' || (lastChar == '\"' && inText))
        //   *(posInOutput++) = ch;
        if (!anEscape && ch == '\"' && (lastChar != '\"' || !inText))
        {
          lastChar = ch;
          continue;     // do not output the quotes
        }
        lastChar = (anEscape ? 0 : ch);
        // save all except " unless a double, when a single " is stored
      }
      else
      {
#ifndef NETWP
        if (fileType == kFirstWordFile)
        {
          /* FirstWord+ File type */
          /* -------------------- */

          if (ch == kEditFileReturn)
             ch = chReturn;
          if (ch >= 0x1e || (ch == chReturn && !softNL))
          {
            softNL = (ch == 0x2d /* hyphen */ || ch == 0x1e /* space */);
            if (ch == 0x1e)
              ch = ' ';
          }
          else if (ch == 0x19 || ch == 0x1c || ch == 0x1d) // soft NL precursors
          {
            softNL = TRUE;
            continue;     // do not output a char
          }
          else
          {
            softNL = FALSE;
            if (ch == 0x0b || ch == 0x1b)
              textPosInScrap++;   // ignore next char
            else if (ch == 0x18)
              while (textPosInScrap < textEnd && *(textPosInScrap++) != 0x18) {}
                                               // ignore to terminating 0x18
            else if (ch == 0x0c)
              formFeed = TRUE;     // 27/04/95 [25009] unconditional page break
            ch = ' ';     // stop it thinking it is a return in test below
            continue;     // do not output a char
          }
        }
        else
#endif
#ifdef WORD7
        if (fileType == kMSWord)
        {
          if (ch == MS_Return)
          {
            if (makeStruct == cTable)
              ch =  chLineFeed;   // Word allows a set of paragraphs within a cell!
          }
          else if (ch == MS_NRqdHyphen)
          {
            continue;     // would be nice to preserve them!!!
          }
          else if (ch == chTab)
          {
          }
          else if (gWordFields.fSpec)  // the ch codes above are not special, below may be
          {
            // these are the meanings when fSpec set
            int macro = 0;

            // build a kMacroPhrase
            if (ch == MS_PageNumber)
            {
              macro = kPageNumber;
            }
            else if (ch == MS_CurrentDateAbbrev || ch == MS_CurrentDate ||
                                                            ch == MS_CurrentDateLong)
            {
              macro = kNewDate;
            }
            else if (ch == MS_CurrentTime || ch == MS_CurrentTimeOld ||
                                                            ch == MS_CurrentTimeAbbrev)
            {
              macro = kNewTime;
            }
            else if (ch == MS_SymbolChar)
            {
              ch = gWordFields.chSym;   // ch from sprmCSymbol - should not be translated????
            }
            else if (ch == MS_PicMark)
            {
              if (gWordFields.fOle2)    // 10/09/96 [27075] ignore OLE pics at the moment
              {
#ifdef TRACE
                SysBeep(0);
#endif
                continue;
              }
              paraEmphs = AddWordPicture(paraEmphs, posInOutput - startPosInScrap);
              ch = chWidget;
            }
#ifdef FN
            else if (ch == MS_FnRefMark)
            {
              paraEmphs = AddFnRef(paraEmphs, doc, posInOutput - startPosInScrap,
                                textPosInScrap - fibPos);
              ch = chWidget;
            }
#endif
            else if (ch == MS_EmSpace || ch == MS_EnSpace)  // not in spec!
            {
              ch = ' ';   
            }
            else if (ch == MS_FldBegin)
            {
              textPosInScrap = SkipField(textPosInScrap, fibPos, fieldLevel > 0 ? NULL :
                                  &paraEmphs, posInOutput - startPosInScrap, self, &emphInfo);
                // SkipField sets character in overwritable scrap
              ch = *(textPosInScrap - 1);
              if (ch > 1)
              {
                textPosInScrap++;        // it is a 'Symbol' - step over the field end mark
                *(posInOutput++) = ch;   // insert untranslated?
              }
              else if (ch != 0 || fieldLevel > 0) // it is a recognised macro or is nested in one
                fieldLevel++;
              continue;
            }
            else if (ch == MS_FldEnd)
            {
              if (fieldLevel > 0)
              {
                fieldLevel--;
                if (fieldLevel == 0)
                {
                  // update the last macro phrase with saved length
                  TEmphInfo *lastEmph =
                                 (TEmphInfo *)((char *)paraEmphs + GetHandleSize(paraEmphs));

                  for (; lastEmph--, (lastEmph >= paraEmphs
#ifdef TRACE
                                    || (SysBeep(0), FALSE)
#endif
                              ); )
                  {
                    if (lastEmph->type == kMacroPhrase)
                    {
                      int currPos = posInOutput - startPosInScrap;

                      if (lastEmph->startRun == currPos)
                      {
                        *(posInOutput++) = '?';
                        currPos++;
                      }
                      lastEmph->endRun = currPos;
                      break;
                    }
                  }
                }
              }
              continue;   // ignore - OK assuming field nesting is OK
            }
            else
            {
              continue;   // To do or cannot do
            }
            if (macro != 0)
            {
              paraEmphs = InsertMacroPhrase(paraEmphs, posInOutput - startPosInScrap, macro);
              ch = ' ';
            }
          }
          else if (ch == MS_PageBreak)
          {
            // if there is an entry in section table, it is a section mark (see page 22)
            if (textPosInScrap < textEnd)  // 08/10/96 [27102] textEnd now set to end of section
            {
              formFeed = TRUE;
              break;    // do not save a Return : ch = chReturn;
            }
            // textEnd now set to end of section to cause exit back to chapter level:
            // 8/10/96 [27102] textEnd = textPosInScrap = textPosInScrap - 1;
            if (posInOutput == startPosInScrap)
              break;       // 8/10/96 do not save a blank para just for section mark (as Word)
            ch = chReturn;
          }
          else if (ch == MS_LineBreak)
          {
            ch = chLineFeed;
          }
          else if (ch == MS_NBrkHyphen)
          {
            *(posInOutput++) = 173;  // better than nothing (remember to convert back!)
            continue;                // do not try to convert if from Mac/Windows code again
          }
          else if (ch == MS_LineFeed)
          {
            // seems to appear as CR/LF in old docs
            continue;     // ignore it
          }
#ifdef TABLES
          else if (ch == MS_CellMark)
          {
            if (gWordFields.fTtp)  // end of row
            {
              newRow = TRUE;
              break;             // we do not want this dummy cell saved
            }
            sep = ch;            // (else) increment column & treat as end of paragraph
          }
#endif
          else if (ch == MS_ColBreak)
          {
            continue;   // To do!!!
          }
          else if (ch < 32 || ch == 127)
          {
#ifdef TRACE
            SysBeep(0);
#endif
            ch = ' ';
          }
        }
        else
#endif
        {
          /* Plain Text File type */
          /* -------------------- */

          if (ch == kEditFileReturn || ch == kEditFileLF)
          {
            int cr = ch;

            // 27/04/95 [25009] recognise different combos of CR & LF
            textPosInScrap = IdentifyReturn(textPosInScrap, textEnd, cr);
            ch = cr;
            if (ch == chReturn && textPosInScrap < textEnd && *textPosInScrap == kFormFeed)
            {
              formFeed = TRUE;
              textPosInScrap++;
            }
          }
          else if (ch == kFormFeed)
          {
            formFeed = TRUE;
            ch = chReturn;
          }
          else if ((ch < 32 && ch != chTab) || ch == 127) // 17/07/90 - leave in tabs
            ch = chSpace;
        }

        /* FirstWord+ or Text to become formatted as a table */
        /* ------------------------------------------------- */
        if (makeStruct == cTable)
        {
          if (ch == sep)           // 26/05/92 only allow one of comma or tab
                                   // which will be a tab if any tabs in file
          {
            column++;
            ch = chReturn;
          }
          else if (textPosInScrap == textEnd || ch == chReturn)
          {
            column++;
            newRow = TRUE;
          }
        }
      }
#ifdef WORD7
      // Test for characters that need conversion from an alien character set.
      // Variable charLim is set so that a single fast test (which will fail in normal
      // circumstances) can be made. This is done at the end, so that any 'symbol'
      // character (taken from gWordFields.chSym) is converted too. Doing this
      // makes the assumption that all the codes tested above are less than charLim!
      if (ch >= charLim)
      {
        // Need to test for Symbol charset!!!
        if (charLim == 128)
          ch = ggMacToArc[ch - 128];
        else if (ch <= 0x9f)
          ch = ggWindowsToArc[ch - 129]; // 16/09/96 [27085] for quotes, bullet and em-dash, etc.
      }
#endif
      *(posInOutput++) = ch;
    }
    while (ch != chReturn && textPosInScrap < textEnd);

    /* create the paragraph if we are at the end of the block/paragraph */
    /* ---------------------------------------------------------------- */
    paraSize = posInOutput - startPosInScrap;

#ifdef WORD7
    if (fileType == kMSWord)
    {
      paraEmphs = AddAnEmphasis(paraEmphs, paraSize, &emphInfo);  // finish off last emphasis
    }
#define PARASTYLECURR paraStyleCurr
#else
#define PARASTYLECURR 0
#endif

    if (*startPosInScrap == 0x1f)
      {} // skip 1stWord+ format lines for time being
    else if (paraSize > 0)
    {
      TTextStructure para;
      TDiscObject rec;
      TCurrency textCurrency = self->NewCurrency(kTextStruct, rec);
      long pos;

#ifdef WORD7
      lastSpAfter = textCurrency;
      if (gWordFields.fPpc == 0x20)
        InsertPic(self, parentCurr, doc, kWhiteSpace, NULL, 0);
#endif
      para = TTextStructure(rec);
      para->InitNewStructure(parentCurr, textCurrency, PARASTYLECURR, kText, FALSE, NULL);
#ifdef WORD7
#ifdef TRACE
      if (fileType == kMSWord)
      {
        TStyleFormat xxx = self->ActiveMainView()->GetStyleReadOnly(PARASTYLECURR);
      }
#endif
      if (paraChanges)
        para->
            _TStructure::InstallStyleChange(textCurrency, paraChanges, 1, gZeroRect, cNoCommand);
#endif
      // if we are not copying in a full para, create an extra
      // space for inserting a CR
      if (textPosInScrap == textEnd)
      {
        if (ch != chReturn)
        {
          para->fTempFlag = "\x01\x00\x02"[aNewDocument];  // 10/01/95 2 for intelligent
          // should not set fTempFlag for aNewDocument: (aNewDocument == 2 ? 2 : TRUE);
          paraSize++;
        }
      }

      // copy in the text block
      ChangeHandleSize(&para->fPtrToArray, paraSize);
      memmove(para->fPtrToArray, startPosInScrap, paraSize);
      para->fCount = paraSize;
      para->fFree = 0;

      // insert a CR char at the end of the paragraph
      ((char*) para->fPtrToArray)[paraSize - 1] = chReturn;

      // plug the paragraph into the document
#ifdef TABLES
      pos = (makeStruct == cTable ? PackTwoShorts(row, column) : -1);
#else
      pos = -1;
#endif
      doc->InsertSubStructure(0, NULL, parentCurr, textCurrency, pos); // 27/07/90
      if (paraEmphs != NULL)
      {
        TEmphInfo *currEmph = paraEmphs;
        TEmphInfo *emphTabEnd = paraEmphs + GetHandleSize(paraEmphs) / sizeof(TEmphInfo);

        for (; currEmph < emphTabEnd; currEmph++)
        {
          TPhrase phrase;

          phrase.fCharPos = currEmph->startRun;
          phrase.fNumChars = 1;
          phrase.fKind = currEmph->type;
          phrase.tag.paste.fOriginalPhrase = 0;  // do not leave uninitialised

          if (phrase.fKind == kTextPhrase)
          {
            para->InstallStyleChange(textCurrency, currEmph->style, 1,
                                                  *((Rect *)currEmph), cNoCommand);
            ClearObject(currEmph->style);
          }
#ifdef WORD7
          else
          {
#ifdef FN
            if (phrase.fKind == kNotePhrase)
            {
              phrase.tag.fRecNum = currEmph->endRun;
              TBodyStructure(self->GetStructureReadWrite(currEmph->endRun))->fReference =
                                                                        textCurrency;
            }
            else
#endif
            if (phrase.fKind == kMacroPhrase)
            {
              phrase.tag.macro.fMacroType = (int)currEmph->style;
              phrase.tag.macro.fMergeField = 0;
              phrase.fNumChars = currEmph->endRun - phrase.fCharPos;
            }
            else // if (phrase.fKind == kWidgetPhrase)
            {
              phrase.tag.fRecNum = InsertPic(self, textCurrency, NULL, kPict,
                                  (MS_PIC *)(fibPos + currEmph->endRun), (int)currEmph->style);
            }
            para->Insert(&phrase);
          }
#endif
        }
      }
    }
    // 27/04/95 [25009] output a page filler
    if (formFeed && makeStruct != cTable)
      InsertPic(self, parentCurr, doc, kPageBreak
#ifdef WORD7
                   , NULL, 0
#endif
        );

    // if this was not a clip doc, might be an idea to purge here
  }

#ifdef WORD7
  if (structChanges)
  {
    if (makeStruct == cTable)
    {
      int borderCode;
      Rect custom;
      char *sprm = gTableBorders;

      // first apply borders round the table itself
      for (int boSprm = sprmPBrcTop; boSprm <= sprmPBrcRight; boSprm++)
      {
        Load2Byte(borderCode, sprm);
        DoWordBorders(structChanges, boSprm, borderCode);
      }
      SetRect(custom, TTableStructure(doc)->fNumberOfRows - 1, 1,
                                            TTableStructure(doc)->fNumberOfColumns, 1);
      for (int part = kRowPart; part >= kColPart; part--)
      {
        Load2Byte(borderCode, sprm);
        if (borderCode != 0xffff && custom.left != 0 && custom.right != 0)
        {
          aStyle = new _TStyleFormat();
          aStyle->fDefined = kHasAdornment;
          DoWordBorders(aStyle, sprmPBrcRight - part + kColPart, borderCode);
          TTableStructure(doc)->
                        InstallStyleChange(parentCurr, aStyle, part, custom, cNoCommand);
          ClearObject(aStyle);
        }
        custom.left++;
        custom.right--;
      }
#ifdef TABLES
      if (gTableLastRow != NULL)
        structChanges->SetSpaceAfter(0);
#endif
    }
    else if (lastSpAfter != 0)
    {
      aStyle = mv->GetFormatReadOnly(lastSpAfter)->GetCompositeStyle(lastSpAfter);
      if ((aStyle->fDefined & kSpaceAfter) != 0)
        structChanges->SetSpaceAfter(aStyle->fSpaceAfter);
           // !!! copy to parent, because EasiWriter suppresses space after on last para in body
      ClearObject(aStyle);
    }

    // add in a bullet font if necessary, as old versions require fBulletFont to be specified
    if (structChanges->fBulletFont == 0 && (structChanges->fDefined & kBullet) != 0)
      structChanges->fBulletFont = ((structChanges->fDefined & kFont) ? structChanges->fTextFont :
             self->GetFNum(strcpy(structChanges->fBulletFontName, GetString(kDefaultFontMsg))));

    if (structChanges->NumOfAttrs(0)) // InstallStyleChange clears fChanges if we do not do this!
      doc->InstallStyleChange(parentCurr, structChanges, 1, gZeroRect, cNoCommand);
  }
  FreeIfObject(structChanges);

#endif

  Success(&fi);

#ifdef TABLES
  if (makeStruct == cTable)
  {
    DoFillEmptyCells(self, TTableStructure(doc), parentCurr);
      // scan through the table and replace empty cells with empty paras
  }
  else
#endif
  if ((ch == chReturn
#ifdef WORD7
      && fileType != kMSWord) ||
      (doc->fSize == 0 && fileType == kMSWord
#endif
        ))
  {
    // 13/07/90 create an empty paragraph at the end if the last char is a CR
    TDiscObject blankRec;
    TCurrency blankCurrency = self->NewCurrency(kTextStruct, blankRec);
    long blankPos;

    TTextStructure(blankRec)->InitNewStructure(parentCurr, blankCurrency, 0, kText, TRUE, NULL);
    blankPos = -1;
    doc->InsertSubStructure(0, NULL, parentCurr, blankCurrency, blankPos); // 27/07/90
  }
#ifdef TRACE
  if (doc->fSize == 0)
    SysBeep(0);
#endif
  return textPosInScrap;

  // ********* Rescue clause *********
Rescue:
  if ((paraEmphs = *pEmphs) != NULL)
  {
    TEmphInfo *currEmph = paraEmphs;
    TEmphInfo *emphTabEnd = paraEmphs + GetHandleSize(paraEmphs) / sizeof(TEmphInfo);

    for (; currEmph < emphTabEnd; currEmph++)
    {
      if (currEmph->type == kTextPhrase)
        FreeIfObject(currEmph->style);
    }
    DisposIfHandle(paraEmphs);
  }
  FreeIfObject(emphInfo.style);
#ifdef WORD7
  FreeIfObject(aStyle);
  FreeIfObject(styleCopy);
  FreeIfObject(structChanges);
  FreeIfObject(paraChanges);
#endif
  ContinueFailure(&fi);
}

#ifdef WORD7
// ------------------------------------------------------------------------
static int DecodeOLE(void *scrapHandle)
{
  // Attempt to Extract Word7 file from OLE2.0 wrapping
  char *theFile = (char *)scrapHandle + 512;
  MS_ControlPage *controlPage = (MS_ControlPage *)scrapHandle;
  MS_StreamHeader *rootPage = (MS_StreamHeader *)(theFile + controlPage->rootPage * 512);
  int indexblocks = controlPage->indexPageCount;
  void *cp = NewCheckedHandle(indexblocks * 512);
  int *indexHdl = (int *)cp;
  int ip;
  int found;
  int streamSize = 0;
  int rootSize = 0;
  volatile int *subIndex = NULL;
  volatile int *modIndex = NULL;
  int *subPtr;
  int subPage;
  int pg;
  FailInfo fi;

  CatchFailures(&fi);

  // read in the whole of the set of blocks containing page map entries
  for (ip = 0; ip < indexblocks; ip++)
    cp = (char *)memcpy(cp, theFile + controlPage->indexPages[ip] * 512, 512) + 512;

  // look for the stream entry for WordDocument:
  for (pg = controlPage->rootPage; pg >= 0; pg = indexHdl[pg])
  {
    MS_StreamHeader *wordDocPage = (MS_StreamHeader *)(theFile + pg * 512);
    MS_StreamHeader *wordDocPageEnd = wordDocPage + 4;

    for (; wordDocPage < wordDocPageEnd; wordDocPage++)
    {
      int nc;

      for (int ap = 0; (nc = "WordDocument"[ap]) != 0; ap++)
        if (nc != wordDocPage->title[ap])
          break;
      if (ap == 12 && wordDocPage->titleLen == 26 && streamSize == 0)
      {
        // open the first Word doc found (there may be more than one!)
        streamSize = wordDocPage->streamLen;
        ip = wordDocPage->streamPage;
      }
      if (wordDocPage->slCode == 2)     // not root entry itself & has sensible streamLen ???
        rootSize -= ((wordDocPage->streamLen + 63) >> 6) << 6;
    }
  }
  if (streamSize == 0)
    FailGeneral(48);     // (no WordDocument stream found)

  // copy the subIndex map (before consolidation of file which tramples over original)
  subIndex = (int *)FailNIL(NewEmptyHandle());
  for (subPage = controlPage->subIndexPage; subPage >= 0; subPage = indexHdl[subPage])
    subIndex = (int *)AppendToHandle(subIndex, 512, theFile + subPage * 512);

  // sum the size of entries in the subindex map
  for (subPtr = (int *)((char *)subIndex + GetHandleSize(subIndex)); subPtr > subIndex; )
    if (*(--subPtr) != -1)
      rootSize += 64;

  if (rootSize < 0)   // the main stream cannot be included in the count (so use main map)
    found = -2;
  else
  {
    found = ip;       // the main stream is mixed with others and ip is the subIndex map index
    ip = rootPage->streamPage;
  }

  // make a indirection table of where blocks have been moved
  modIndex = (int *)NewCheckedHandle(indexblocks * 512);
  for (pg = 0; pg < indexblocks * 128; pg++)
    modIndex[pg] = pg * 512;

  // follow chain of 512-byte blocks from ip, moving down in memory to consolidate stream
  for (cp = scrapHandle; ip >= 0; ip = indexHdl[ip])
  {
    cp = (char *)memcpy(cp, theFile + modIndex[ip], 512) + 512;
    memmove((char *)cp + 512, cp, theFile - (char *)cp + modIndex[ip]);
    for (int x = 0; x < ip; x++)
      modIndex[x] += 512;
  }

  if (found >= 0)
  {
    // the main stream is embedded within the other streams in 64-byte chunks
    ip = found;            // start 64-byte block within subIndex map
    for (cp = scrapHandle; ip >= 0; ip = subIndex[ip])
      cp = (char *)memcpy(cp, (char *)scrapHandle + ip * 64, 64) + 64;
  }

  Success(&fi);

Rescue:
  DisposIfHandle(indexHdl);
  DisposIfHandle(subIndex);
  DisposIfHandle(modIndex);
  ContinueIfFail(&fi);
  return (char *)cp - (char *)scrapHandle;
}
#endif

// ------------------------------------------------------------------------
void _TExpressionDocument::DoReadTextFile(Handle *scrapHandle1, bool makeTable,
                                                    bool aNewDocument, TCurrency hfStyle)
{
  Handle scrapHandle = *scrapHandle1;
  char *textPosInScrap;
  char *textEnd;
  OSType fileType = fFileType;   // 11/05/92 was param
  int sep = ',';
#ifdef WORD7
  int totalSections = 1;
  TPagesPrintHandler prHdlr = TPagesPrintHandler(fDocPrintHandler);
#ifdef FN
  int bigOffset = MAXLONGINT;
#endif
#ifdef TRACE
  volatile MS_FIB *fib = NULL;
  volatile MS_DOP *docInfo = NULL;
  MS_FIB **t1 = (MS_FIB **)&fib;
  MS_DOP **t2 = (MS_DOP **)&docInfo;
#else
  MS_FIB fibStruct;
  MS_FIB *fib = &fibStruct;
  MS_STSHI sheetHdrStruct;
  MS_DOP docInfoStruct;
  MS_DOP *docInfo = &docInfoStruct;
#endif
  FailInfo fi;
#endif

#ifdef TRACE
  Assert(fileType == kTextFile || fileType == kFirstWordFile || fileType == kMSWord ||
                                              fileType == kCSV, 42);
#endif

  BuildFontRefTable();

#ifdef WORD7
  gSheet = NULL;
  gMainDoc = this;
  gNormalStyle = NULL;
#ifdef TABLES
  gTableLastRow = NULL;
#endif
#ifdef TRACE
  gSheetHdr = NULL;
#endif

  CatchFailures(&fi);

  if (fileType == kMSWord)
  {
    TCurrency parentCurr;
    int hdrSize;
    int ihdd;

#define fibPos ((char *)scrapHandle)
    int fileSize = (*(int *)scrapHandle == 0xe011cfd0 ? DecodeOLE(scrapHandle) : 0);

#ifdef TRACE
    fib = (MS_FIB *)NewCheckedHandle(sizeof(MS_FIB));
#endif
    memcpy(fib, (char *)scrapHandle, Min(394, GetHandleSize(scrapHandle)));
#ifdef TRACE
    if (fib->nFib == 45)
    {
      char *fibP = (char *)&fib->fcStshfOrig;
      char *inP = (char *)scrapHandle + 88;
      char *fibEndP = (char *)&fib->wSpare4Fib;

      for (; fibP < fibEndP; )
      {
        *(fibP++) = *(inP++);
        *(fibP++) = *(inP++);
        *(fibP++) = *(inP++);
        *(fibP++) = *(inP++);
        *(fibP++) = *(inP++);
        *(fibP++) = *(inP++);
        *(fibP++) = 0;
        *(fibP++) = 0;
      }
      fibP = (char *)memcpy(fibP + 2, inP, 10);
      memset(fibP + 10, 0, sizeof(MS_FIB) - 404);
    }
    else
#endif
    memcpy(&fib->pnChpFirst, (char *)scrapHandle + 394, 288);
    if (fib->wident != 42460)
      FailGeneral(50);
    else if (fib->fComplex || fib->fEncrypted)
      FailGeneral(49);     // cannot read this

    // Attempt to Extract Word7 file from OLE2.0 wrapping - shrink file to given size
#ifdef TRACE
    if (GetHandleSize(scrapHandle) < fib->fbMac)
      SysBeep(0);
    else
#endif
    {
      if (fileSize > 0 && fileSize < fib->fbMac)
        // 03/09/96 [27063]: (fileSize < fib->fbMac || fileSize > ((fib->fbMac + 511) >> 9) << 9))
        FailGeneral(51);     // gone wrong somewhere
      SetHandleSize(scrapHandle1, fib->fbMac);
    }
    scrapHandle = *scrapHandle1;

    aNewDocument = TRUE;
    gFontInfo = (MS_FFN *)(fibPos + fib->fcSttbfffn);

    // find section change position
    totalSections = fib->lcbPlcfsed / 16;
#ifdef TRACE
    totalSections = Max(1, totalSections); // Word2
#endif
    gNextSection = fibPos + fib->fcPlcfsed;
    gNextSED = gNextSection + (totalSections + 1) * 4;
    gNextFn = (fib->lcbPlcffndRef ? fibPos + fib->fcPlcffndRef : (char *)&bigOffset);
    gNextEndn = (fib->lcbPlcfendRef ? fibPos + fib->fcPlcfendRef : (char *)&bigOffset);

    // Read in the document info (DOP)
    hdrSize = fib->lcbDop;
#ifdef TRACE
    docInfo = (MS_DOP *)NewCheckedHandle(sizeof(MS_DOP));
#endif
    if (hdrSize > 0)
      memcpy(docInfo, fibPos + fib->fcDop, Min(hdrSize, sizeof(MS_DOP)));
    if (hdrSize < sizeof(MS_DOP))
      memset((char *)docInfo + hdrSize, 0, sizeof(MS_DOP) - hdrSize);
    if (fib->nFib < 103)
    {
      // copy compatibility options
      ((char *)docInfo)[84] = ((char *)docInfo)[8];
      ((char *)docInfo)[85] = ((char *)docInfo)[9];
    }
    fDfltTab = docInfo->dxaTab * 500;   // 17/10/96 [27112] default tab width
    fFirstFootnote = docInfo->nFtn - 1;
    prHdlr->fSameInterior = docInfo->fMirrorMargins ^ 1;
    prHdlr->fHPrint->rPaper.right = prHdlr->fHPrint->rPaper.left + (12240 * 50);
    prHdlr->fHPrint->rPaper.bottom = prHdlr->fHPrint->rPaper.top + (15840 * 50);
    prHdlr->fRawMargins.right = -(prHdlr->fRawMargins.left = 1800 * 50);
    prHdlr->fRawMargins.bottom = -(prHdlr->fRawMargins.top = 1440 * 50);
    prHdlr->fHPrint->background = TRUE; // Always b/g ????

    // --- read the Style Sheet (STSH) ---
#ifdef TRACE
    gSheetHdr = (MS_STSHI *)NewCheckedHandle(sizeof(MS_STSHI));
#else
    gSheetHdr = &sheetHdrStruct;
#endif
    memset(gSheetHdr, 0, sizeof(MS_STSHI));
    gWordFields.hfDone = FALSE;     // flag to indicate we have done one set of header/footers
    gNormalStyle = new _TStyleFormat();
    if (fib->lcbStshf != 0)
    {
      int cbStshi = 4;
      char *fp = fibPos + fib->fcStshf;

      if (fib->nFib >= 67)
        Load2Byte(cbStshi, fp);   // later versions have a count (else assume 4 bytes)

      memcpy(&gSheetHdr->cstd, fp, Min(cbStshi, sizeof(MS_STSHI) - 2));
      fp += cbStshi;     // points to (count preceeding) STD
#ifdef TRACE
      if (fib->nFib == 45)
        gSheet = NULL;
      else
#endif
      gSheet = fp;
      // add all the entries in the STSH to our Style Sheet (so unused ones are not lost)
      for (int istd = 0; istd < gSheetHdr->cstd; istd++)
        DoStyleSheet(this, istd, NULL);
    }
    fMainViewList->Each(this, (DoToObject)_TExpressionDocument::ConnectView);

    ihdd = "\x00\x04\x04\x08\x04\x08\x08\x0c"[(docInfo->grpflhdt >> 5) & 7];
                   // number of h/f bytes to skip at start (which we cannot handle)

    gWordFields.grpflhdt = 0;       // h/f flags set by sepx when section processed
    gWordFields.dyaHdrTop = 36000;    // positions of header and footers in sepx
    gWordFields.dyaHdrBottom = 36000;
    gWordFields.fTitlePage = 0;
    gFieldsOffset = fib->fcPlcffldMom;
    gFieldsCount = fib->lcbPlcffldMom;
    gTextOffset = fib->fcMin;
    textPosInScrap = fibPos + fib->fcMin;
    textEnd = textPosInScrap + fib->ccpText;
    sep = MS_CellMark;
    parentCurr = fBody;

    while (TRUE)
    {
      // maybe set these changes up in the document body->fChanges style?
      TBodyStructure bodyStruct = TBodyStructure(GetStructureReadWrite(parentCurr));
      TMainView mv = ActiveMainView();
      TBodyStyle bodyStyle;
      int hddPos[2];

      if (bodyStruct->fStyle == gNullCurrency)  // [27108] no header/footer in clipboard document
        break;
      bodyStyle = TBodyStyle(mv->GetStyleReadWrite(bodyStruct->fStyle));
#ifndef NETWP
      bodyStyle->ApplyOverride(gNormalStyle, gNullCurrency, TRUE);
#endif

      // set Word defaults in doc style (p33/4)
      // bodyStyle->fTextSizeX = bodyStyle->fTextSizeY = 10 * 16;      // hps = 20
      // spacing (lspd.fMultiLinespace == 1 && lspd.dyaLine == 240) is also our default(P41)
      bodyStyle->tag.docStyle.fEndNotes = (docInfo->fpc == 0 || fib->lcbPlcfendRef);
                                             // 09/09/96 [27071] ... or endnotes present
      bodyStyle->tag.docStyle.fEndChapter = (docInfo->epc == 0);
      if (docInfo->fAutoHyphen)
      {
        bodyStyle->fHyphenate = TRUE;
        bodyStyle->fDefined |= kHyphenate;
      }
      if (fib->lid >= 999)
      {
        int country;

        for (country = 48; country > 0 && gLids[country] != fib->lid; country--) {}
        bodyStyle->fLanguage = country;
      }
      else
        bodyStyle->fLanguage = 0;                                     // lid = 0x0400

      // do all the sections on first pass through the loop
      for (; totalSections > 0 && textPosInScrap < textEnd; totalSections--)
                                   // 03/09/96 [27062] text test
      {
        int grpflhdt;

        textPosInScrap = ReadAlienText(this, textPosInScrap, textEnd, parentCurr,
                                makeTable, aNewDocument, (MS_FIB *)fib, fibPos, 0, sep);

        makeTable = cChapter;
        grpflhdt = gWordFields.grpflhdt;
        if (!gWordFields.hfDone && (grpflhdt || totalSections == 1))
               // we have the first section with a header/footer or have reached last section
        {
          int hasHF = (grpflhdt & 0x03);
          TDiscObject obj;

          fRightHeader = fLeftHeader = NewCurrency(kBodyStruct, obj);
          TStructure(obj)->InitNewStructure(gNullCurrency, fLeftHeader, hfStyle,
                                                                   kHeader, !hasHF, NULL);
          if (hasHF)
          {
            // need to reserve space for header
            // 28/08/96 [27049] was wrong way round for headers
            TPagesView(mv)->fUserHdMargin =
                                      (prHdlr->fRawMargins.top - gWordFields.dyaHdrTop) * 10;
            prHdlr->fRawMargins.top = gWordFields.dyaHdrTop;
            if (docInfo->fFacingPages)
            {
              fLeftHeader = NewCurrency(kBodyStruct, obj);
              TStructure(obj)->InitNewStructure(gNullCurrency, fLeftHeader, hfStyle,
                                                                  kHeader, hasHF != 3, NULL);
              fLeftRightHdr = TRUE;
            }
          }
          hasHF = (grpflhdt & 0x0c);
          fLeftFooter = fRightFooter = NewCurrency(kBodyStruct, obj);
          TStructure(obj)->InitNewStructure(gNullCurrency, fLeftFooter, hfStyle,
                                                                   kFooter, !hasHF, NULL);
          if (hasHF)
          {
            // need to reserve space for footer
            TPagesView(mv)->fUserFtMargin =
                               -(gWordFields.dyaHdrBottom + prHdlr->fRawMargins.bottom) * 10;
            prHdlr->fRawMargins.bottom = -gWordFields.dyaHdrBottom;
            if (docInfo->fFacingPages)
            {
              fLeftFooter = NewCurrency(kBodyStruct, obj);
              TStructure(obj)->InitNewStructure(gNullCurrency, fLeftFooter, hfStyle,
                                                               kFooter, hasHF != 0x0c, NULL);
              fLeftRightFtr = TRUE;
            }
          }
          gWordFields.hfDone = TRUE;
        }
      }
      // now that the sections have been done set up to process header/footers for a
      // section (although we can only handle the first that was found with h/fs)
      totalSections = 1;
      makeTable = FALSE;
      gFieldsOffset = fib->fcPlcffldHdr;
      gFieldsCount = fib->lcbPlcffldHdr;
      gTextOffset = fib->fcMin + fib->ccpText + fib->ccpFtn;

      if ((gWordFields.grpflhdt & 0x01) != 0)
      {
        parentCurr = fLeftHeader;
        gWordFields.grpflhdt &= (fLeftHeader == fRightHeader ? (ihdd += 4, ~0x03) : ~0x01);
      }
      else if ((gWordFields.grpflhdt & 0x02) != 0)
      {
        parentCurr = fRightHeader;
        gWordFields.grpflhdt &= ~0x02;
      }
      else if ((gWordFields.grpflhdt & 0x04) != 0)
      {
        parentCurr = fLeftFooter;
        gWordFields.grpflhdt &= (fLeftFooter == fRightFooter ? (ihdd += 4, ~0x0c) : ~0x04);
      }
      else if ((gWordFields.grpflhdt & 0x08) != 0)
      {
        parentCurr = fRightFooter;
        gWordFields.grpflhdt &= ~0x08;
      }
      else
        break;

      textPosInScrap = fibPos + gTextOffset;                  // start h/f text
      // textEnd = textPosInScrap + ((int *)(fibPos + fib->fcPlcfhdd))[ihdd + 1] - 1;
      // textPosInScrap += ((int *)(fibPos + fib->fcPlcfhdd))[ihdd];
      memcpy(hddPos, fibPos + fib->fcPlcfhdd + ihdd, 8); // 18/09/96 [27088] align!
      textEnd = textPosInScrap + hddPos[1] - 1;
      textPosInScrap += hddPos[0];
      ihdd += 4;
    }
#ifdef FN
    // 09/09/96 [27071] look up each note in the note area to see if it appears
    // in the list of footnotes or endnotes
    if (fib->lcbPlcfendRef || fib->lcbPlcffndRef)
    {
      TBodyStructure noteSet = TBodyStructure(GetStructureReadWrite(fFootnotes));

      for (int idx = 1; idx <= noteSet->GetSize(); idx++)
      {
        char *endnPos;
        int noteOffset;
        int fnIdx;
        int refPos;
        int fnText[2];
        int found = FALSE;
        int refLimit = fib->lcbPlcffndRef / 6;
        char *textPtr = fibPos + fib->fcPlcffndTxt;
        TBodyItem bodyItem;

        noteSet->Get(idx, &bodyItem);
        noteOffset = (((int *)&bodyItem)[1] >> 4) - fib->fcMin - 1;
        gFieldsOffset = fib->fcPlcffldFtn;
        gFieldsCount = fib->lcbPlcffldFtn;
        gTextOffset = fib->fcMin + fib->ccpText;
        endnPos = fibPos + fib->fcPlcffndRef;

        // search through footnotes then endnotes looking for an offset matching 'noteOffset'
        for (int endnote = FALSE; endnote <= 1; endnote++)
        {
          for (fnIdx = 0; !found && fnIdx < refLimit; fnIdx++)
          {
            memcpy(&refPos, endnPos, 4);
            endnPos += 4;
            if (noteOffset == refPos)
            {
              memcpy(fnText, textPtr + (fnIdx * 4), 8);
              textEnd = fibPos + gTextOffset;
              textPosInScrap = textEnd + fnText[0] + 1;      // start fn text proper
              textEnd += fnText[1];
              if (textPosInScrap == textEnd)
                textPosInScrap--;     // [27115] cannot deal with completely empty footnotes
              ReadAlienText(this, textPosInScrap, textEnd, bodyItem.fCurrency,
                                            0, TRUE, (MS_FIB *)fib, fibPos, 0, ',');
              found = TRUE;
            }
          }
          // set up for second iteration (the endnotes)
          refLimit = fib->lcbPlcfendRef / 6;
          endnPos = fibPos + fib->fcPlcfendRef;
          gFieldsOffset = fib->fcPlcffldEdn;
          gFieldsCount = fib->lcbPlcffldEdn;
          gTextOffset = fib->fcMin + fib->ccpText +
                                     fib->ccpFtn + fib->ccpHdr + fib->ccpMcr + fib->ccpAtn;
          textPtr = fibPos + fib->fcPlcfendTxt;
        }
#ifdef TRACE
        Assert(found, 397);
#endif
        // restore the field we used to hold the note position
        bodyItem.fState = kShown;
        bodyItem.fNew = TRUE;
        bodyItem.fAffected = FALSE;
        bodyItem.fGone = FALSE;
        bodyItem.fNoteNumber = 0;
        bodyItem.spare = 0;
        noteSet->AtPut(idx, &bodyItem);
      }
    }
#endif
    prHdlr->MoveRectsToLandscape();
  }
  else
#endif
  {
    textPosInScrap = (char *)scrapHandle;
    textEnd = ((char *)scrapHandle) + GetHandleSize(scrapHandle);
#ifdef TABLES
    /* Build a Table structure immediately under the main body of the document */
    /* ----------------------------------------------------------------------- */
    if (makeTable)
    {
      // check if we have a comma or tab sep list
      for (; textPosInScrap < textEnd; )
        if (*(textPosInScrap++) == chTab)
        {
          sep = chTab;
          break;
        }
    }
    if (fileType == kCSV)
      makeTable = cTable;
#endif
    ReadAlienText(this, (char *)scrapHandle, textEnd, fBody, makeTable, aNewDocument,
#ifdef WORD7
                  NULL, NULL, 0,
#endif
                  sep);
  }

#ifdef WORD7
  Success(&fi);

Rescue:

  ClearObject(gNormalStyle);
#ifdef TABLES
  ClearObject(gTableLastRow);
#endif
#ifdef TRACE
  DisposIfHandle(docInfo);
  DisposIfHandle(fib);
  DisposIfHandle(gSheetHdr);
#endif
  ContinueIfFail(&fi);
#endif
}

// ------------------------------------------------------------------------
// 29/07/92 common bits of DoReadAlienFile and DoReadRamFile
void _TExpressionDocument::ReadTextFile(Handle *scrapHandle,
                                        TWhyMaking forPrinting, TCurrency hfStyle)
{
  DoReadTextFile(scrapHandle, forPrinting == kForMerge ? cTable : 0,
                                forPrinting == kSynonymReturned ? 2 : 1, hfStyle);
  // 10/01/95 pass 2 for intelligent paste (when word dragged from dialogue to text)
  // 16/07/90 - TRUE param so that if a text file without a CR is dropped
  // onto the iconbar, the CR is put in at the end. Otherwise the file is
  // read in as per normal

  SetHandleEmpty(scrapHandle);
  // 16/07/90 - get the document selected for reformating it
  if (forPrinting != kForMerge && forPrinting != kSynonymReturned)
  {
    TSelection selection = InitialSelection(ActiveMainView(), 0, -1);
#ifdef TRACE
    TSelection tempsel = selection;
#endif

    selection->fReformatType = kReformatAll;
#ifdef WORD7
    if (fFileType == kMSWord)            // 29/04/96
      fDocPrintHandler->CheckPrinter(FALSE);     // apply page size changes
    else
#endif
    {
      fMainViewList->Each(this, (DoToObject)_TExpressionDocument::ConnectView); // 12/07/90
      MakeHeaderFooter(hfStyle);      // 25/10/90
    }
    Reformat();  // 13/07/90  - need to reformat a new dropped-on file
    selection = GetNewSelection();
#ifdef TRACE
    Assert(tempsel == selection, 692);  // is GetNewSelection() needed???
#endif
    selection->SetTheCursor(TRUE);   // 11/12/90
    selection->DoSetupLevels();      // 11/12/90
    SetCurrentStyle();
  }
}

// ------------------------------------------------------------------------
void _TExpressionDocument::DoReadAlienFile(int aRefNum, TWhyMaking forPrinting)
{
  volatile Handle scrapHandle;
  TExpressionView pagesView;
  long estSize;
  TCurrency hfStyle;
  FailInfo fi;

  scrapHandle = NULL;

  CatchFailures(&fi);

  pagesView = TExpressionView(DoCreateMainView(1));
  ActivateMainView(pagesView);
  DoInitialStyles(pagesView, &hfStyle);
  SetFPos(aRefNum, 0);
  GetEOF(aRefNum, estSize);
  scrapHandle = NewCheckedHandle(estSize);
  FRead(aRefNum, estSize, scrapHandle);

  ReadTextFile((void **)&scrapHandle, forPrinting, hfStyle);
  DisposIfHandle(scrapHandle);

  Success(&fi);
  return;

// ++++++++++++++++++++++++++++++++++++++++++++++
Rescue:
  DisposIfHandle(scrapHandle);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TExpressionDocument::ReadFromRamFile(AppFile &anAppFile, TWhyMaking forPrinting)
{
  volatile Handle  scrapHandle = NULL;
  TExpressionView  pagesView;
  TCurrency        hfStyle;
  FailInfo         fi;

  // bounce RAM transfer of EasiDocs - we cannot handle these
  if (anAppFile.fType == kExpressionFile || anAppFile.fType == kStationeryPad)
  {
    SendScrapMsg(wr_wimpt_last_event());
    FailNoFail();
  }
  // at the moment we can only read text-like files via RAM
  _TDocument::ReadFromRamFile(anAppFile, forPrinting); // 11/05/92 extra value for merge doc
 
  pagesView = TExpressionView(DoCreateMainView(1));
  ActivateMainView(pagesView);  // 29/07/92 do the same as DoReadAlienFile
  DoInitialStyles(pagesView, &hfStyle);

  CatchFailures(&fi);

  scrapHandle = NewCheckedHandle(anAppFile.fEstSize);
  if (forPrinting == kSynonymReturned)
    strncpy((char *)scrapHandle, anAppFile.fName, anAppFile.fEstSize);
  else
    ReadInExternalFile((Handle *)&scrapHandle, anAppFile.fEstSize, anAppFile.fName, 0);

  ReadTextFile((void **)&scrapHandle, forPrinting, hfStyle);
  // NB this does:  selection->DoSetupLevels();  which original did not

  DisposIfHandle(scrapHandle);

  Success(&fi);
  return;

Rescue:
  DisposIfHandle(scrapHandle);
  ContinueFailure(&fi);
}

#if defined DRAWSAVE || ((defined CONT || defined INDEX) && !defined NETWP)
// ------------------------------------------------------------------------
int _TExpressionDocument::GetAlienSpace(int draw, Rect *drawRect)
{
  char buffer[kStdSenderBuffer];    // 28/02/94 int maxBuf = 2048;
  int GetAlienSpace_r;
  TSender sender = NULL;
  FailInfo fi;

  CatchFailures(&fi);

#ifdef DRAWSAVE
  if (draw == TRUE)
  {
    sender = new _TSender(buffer, NULL, 0x1000);  // make different from real file type
    gWindowWithPointer = NULL;
    InitCursor();
    DoSaveDraw(sender, *drawRect, FALSE);
    gMasterList->SendMasterList();       // output the full master fonts list to get its size
  }
#endif
#if (defined CONT || defined INDEX) && !defined NETWP
  if (draw == FALSE)
  {
    sender = new _TFancyTextSender(buffer, NULL, NULL);
    ActiveMainView()->fPages->WriteContents(sender);
  }
#endif

  Success(&fi);
  GetAlienSpace_r = sender->GetSpaceUsed();
  FreeIfObject(sender);
  return GetAlienSpace_r;

Rescue:
  FreeIfObject(sender);
  ContinueFailure(&fi);
}
#endif

#ifdef DRAWSAVE
// ------------------------------------------------------------------------
void _TExpressionDocument::SaveDrawInit(TSender sender, VRect &box)
{
  char buff[80];  // min draw file size is 40, so this should be plenty for this
  wr_draw_bboxtyp bbox;
  wr_draw_diag dd;

  // create a big buffer, switch output and draw box
  bbox.x0 = 0;
  bbox.y0 = 0;
  bbox.x1 = (box.right - box.left) * 64;
  bbox.y1 = (box.bottom - box.top) * 64;
  dd.data = buff;
  create_diag(&dd, gProgName, &bbox);   // create empty diagram
  sender->SendString(buff, dd.length);
}


static GrafPort gDrawPort;
// ------------------------------------------------------------------------
void _TExpressionDocument::DoSaveDraw(TSender sender, Rect &drawRect, bool saving)
{
  // 12/10/92 save draw file to disc
  wr_wimp_redrawstr r;
  TExpressionView mainView = TExpressionView(ActiveMainView());
  Fixed savedZoom;
  Rect zRect;

  gSender = sender;
  savedZoom = mainView->fZoomFactor;
//  MoveRect(zRect, mainView->fZoomBox);
  MoveRect(zRect, drawRect);
  gDrawPort.SetUp(NULL, 0);
//  SetPort(&gDrawPort);
  if (saving && savedZoom != kFix1)
  {
    Rect interior;
    int downPage = mainView->fDownPage;

    mainView->GetPaperArea(downPage, interior);
    OffsetRect(zRect, -interior.left, -interior.top);
    zRect.top = FixDiv(zRect.top, savedZoom);
    zRect.left = FixDiv(zRect.left, savedZoom);
    zRect.bottom = FixDiv(zRect.bottom, savedZoom);
    zRect.right = FixDiv(zRect.right, savedZoom);
    gPrinting = TRUE;  // 15/11/92 moved up to stop picture highlighting
    mainView->SetMagnification(kFix1);
    gApplication->InvalidateFocus();

//?    SetPageInterior(kUsualPages);
    mainView->MakeViewsForPages(downPage, downPage);
    gPrinting = FALSE;  // 15/11/92 moved up to stop picture highlighting
    mainView->GetPaperArea(downPage, interior);
    OffsetRect(zRect, interior.left, interior.top);
    DoNeedDrawSpace(zRect);  // 14/12/92 do an extra pass to reset deleted maths views
    gSender = sender;   // 14/12/92 and reset gSender
  }
  SaveDrawInit(sender, zRect);
  if (saving)
    gMasterList->SendMasterList();         // output the font list as first record

  mainView->Focus();
  QDRectToBox(zRect, r.g, 0);
  r.scx = -r.g.x0;    // ????
  r.scy = -r.g.y0;
  SetPort(&gDrawPort);
  gDrawPort.SetRedrawStr(&r);
  gPrinting = TRUE;
  mainView->DrawContents();
//  gPrinting = FALSE;

  mainView->RebuildViews(savedZoom);
}

// ------------------------------------------------------------------------
int _TExpressionDocument::DoNeedDrawSpace(Rect &drawRect)
{
  return GetAlienSpace(TRUE, &drawRect);
}

// ====================== methods for TSaveDrawTracker ======================
// ------------------------------------------------------------------------
TCommand _TSaveDrawTracker::TrackMouse(TrackPhase aTrackPhase,
          VPoint &anchorPoint, VPoint &previousPoint, VPoint &nextPoint,
          bool mouseDidMove,  EventInfo &info)
{
  if (aTrackPhase == trackRelease)
  {
    Pt2VRect(anchorPoint, nextPoint, TPagesView(fView)->fZoomBox);
    gSaveDocCommand->fChangedDocument = fView->fDocument;
    gSaveDocCommand->fCmdNumber = cSaveDraw;
    return gSaveDocCommand;
    // put up a dialogue and save
  }
  return this;
}
#endif

#ifndef NETWP
#if defined CONT || defined INDEX
typedef struct TContentsInfo
{
  TSender sender;
  Handle  funcNameList;
  int     pageNum;
  TObject startBreak;
  TObject endBreak;
  int     level;
  int     subset;
  long    pos;
} TContentsInfo;

// ------------------------------------------------------------------------
int _TExpressionDocument::GetContentsSize(void)
{
  return GetAlienSpace(FALSE, NULL);
}

// ------------------------------------------------------------------------
static void WriteChildContents(TFormat self, TCurrency currency, long pos,
               TCursorNode anchor, TCursorNode activeEnd, TContentsInfo *info,
               TObject startBreak, TObject endBreak)
{
  TFormat subBodyFmt = self->GetFormatReadOnly(currency);
  int level = info->level;
  int subset = info->subset;

  info->startBreak = startBreak;
  info->endBreak = endBreak;
  info->pos = pos;
  subBodyFmt->WriteContents(currency, info);
  info->level = level;
  info->subset = subset;
}

// ------------------------------------------------------------------------
void _TFormat::WriteContents(TCurrency currency, void *saveInfo)
{
  GetStructureReadOnly(currency)->Iterate(currency, NULL, NULL, TRUE, this,
                 DoStep(WriteChildContents), (TContentsInfo *)saveInfo, NULL, NULL);
}

// ------------------------------------------------------------------------
static void DoCellSave(TTableFormat self, PCellItem cellStruct, int row, int column,
          TContentsInfo *info)
{
  if (!cellStruct->hidden && cellStruct->cell != gNullCurrency)
  {
    WriteChildContents(self, cellStruct->cell, PackTwoShorts(row, column),
                                                  NULL, NULL, info, NULL, NULL);
  }
}

// ------------------------------------------------------------------------
void _TTableFormat::WriteContents(TCurrency currency, void *saveInfo)
{
  TTableStructure tableStruct = TTableStructure(GetStructureReadOnly(currency));
  TContentsInfo *info = (TContentsInfo *)saveInfo;
  TTableBreak startBreak = TTableBreak(info->startBreak);
  TTableBreak endBreak = TTableBreak(info->endBreak);
  TCellRect cellCoords;

  tableStruct->GetAllCells(cellCoords);
  if (startBreak != NULL)
    cellCoords.startRow = startBreak->GetBreakRow();
  if (endBreak != NULL)
    cellCoords.endRow = endBreak->GetBreakRow() - 1;
  tableStruct->ForSelectedCellsDo(this, cellCoords, (Action)DoCellSave, info);
}

// ------------------ BodyEdit methods ------------------------------------
void _TBodyFormat::WriteSubContents(TBodyStructure body, int index,
                          void *saveInfo, TObject startBreak, TObject endBreak)
{
  TCurrency subBody = body->GetBodyItem(index);

  if (
#ifdef INDEX
        body->fDocument->fSaveCmd != cSaveContents ||
#endif
        Curr_fType(subBody) == kBodyStruct ||
        (body->fHeadingType != kNoHeading && index == 1 && startBreak == NULL))
  {
    WriteChildContents(this, subBody, 0, NULL, NULL, (TContentsInfo *)saveInfo,
                       startBreak, endBreak);
  }
}

// ------------------------------------------------------------------------
void _TBodyFormat::WriteContents(TCurrency currency, void *saveInfo)
{
  int startIndex;
  int endIndex;
  TContentsInfo *info = (TContentsInfo *)saveInfo;
  TBodyBreak startBreak = TBodyBreak(info->startBreak);
  TBodyBreak endBreak = TBodyBreak(info->endBreak);
  TTextDocument doc = TTextDocument(fMainView->fDocument);
  TObject break1;
  TObject break2;
  TObject break11;  // break objects for the heading
  TObject break22;
  TBodyStructure body;
  TColumnBreak breakInfo;
#ifdef FN
  TObject noteBreakIn;
#endif

  if (MemSpaceIsLow())
    doc->Purge();

  body = TBodyStructure(GetStructureReadOnly(currency));
  if (startBreak == NULL)
  {
    startIndex = 1;
    break1 = NULL;
    break11 = NULL;
#ifdef FN
    noteBreakIn = NULL;
#endif
  }
  else
  {
    break11 = TBodyBreak(startBreak)->fHeadingBreak;
    TBodyBreak(startBreak)->GetLast(&breakInfo);
    startIndex = breakInfo.fIndex;
    break1 = breakInfo.fBreak;
    if (break1 == NULL)
      startIndex++;
#ifdef FN
    noteBreakIn = breakInfo.fNoteBreakOut;  // 10/08/95 [26051] END of prev page: fNoteBreakIn
#endif
  }
  if (endBreak == NULL)
    endBreak = fColBreaks;
#ifdef TRACE
  Assert(endBreak, 999);
#endif
  break22 = TBodyBreak(endBreak)->fHeadingBreak;
  if (break22 != NULL)
  {
    if (startBreak == NULL)
      startIndex = 2;       // if the heading overflows do not start with body index 1!
  }
  TBodyBreak(endBreak)->GetLast(&breakInfo);
  endIndex = breakInfo.fIndex;
  break2 = breakInfo.fBreak;

  info->level++;

  if (
#ifdef INDEX
      doc->fSaveCmd != cSaveContents ||
#endif
      body->fKind <= kChapter ||
     (doc->fSaveContentsSet <= info->subset && (info->subset = 0, body->fKind == kSection)))
  {
    if (break11 != NULL || break22 != NULL)
      WriteSubContents(body, 1, info, break11, break22);

    for (int index = startIndex; index <= endIndex; index++)
      WriteSubContents(body, index, info,
             (index == startIndex ? break1 : NULL), (index == endIndex ? break2 : NULL));
  }
#if defined FN && defined INDEX
  if (doc->fSaveCmd != cSaveContents &&
                   noteBreakIn != breakInfo.fNoteBreakOut)
  {
    // Write index entries from the footnotes for current page

    TCurrency subBody = body->GetNoteCollector();

    WriteChildContents(this, subBody, 0, NULL, NULL, (TContentsInfo *)saveInfo,
                          noteBreakIn, breakInfo.fNoteBreakOut);
  }
#endif
}


// ------------------ TextEdit method -------------------------------------

void _TTextFormat::WriteContents(TCurrency currency, void *saveInfo)
{
  TContentsInfo *info = (TContentsInfo *)saveInfo;
  TPageData pageData;
  TTextStructure body = TTextStructure(GetStructureReadOnly(currency));
  TSender sender = info->sender;
  TTextDocument doc = TTextDocument(fMainView->fDocument);
  // int lineLen;
  char str[40];

  pageData.pageNum = info->pageNum;
  fMainView->fPages->GetPageInfo(&pageData);
#ifdef INDEX
  if (doc->fSaveCmd != cSaveContents)
  {
    int tempIdx;
    TCurrency homeCurr = currency;
    TTextBreak sb = TTextBreak(info->startBreak);
    int startPos = (sb == NULL ? 0 :
                 ((tempIdx = LineToPart(this, sb->BreakPart()) + 1) > fSize ?
                                          MAXLONGINT : PLinePart(At(tempIdx))->fCharPos));

    for (int i = 1; i <= body->fSize; i++)
    {
      PPhrase phr = PPhrase(body->At(i));

      if (phr->fKind == kIndexRefPhrase)
      {
        if (phr->fCharPos >= startPos)
        {
          TIndexStructure indexStruct =
                           doc->GetIndexStructureReadWrite(phr->tag.indexRef.fIndexRec);
                  // ??? could be readOnly if never purged while index saving

          for (int j = 0; j < indexStruct->fSize; j++)
          {
            PIndexRef p = PIndexRef(indexStruct->fPtrToArray) + j;

            if (p->fHomeCurrency == homeCurr)
            {
              p->fNumberFormat = pageData.romanPages;
              p->fPageNumber = pageData.pageNum;
              break;
            }
          }
        }
        homeCurr += 256;
      }
      else if (phr->fKind == kWidgetPhrase && phr->fCharPos >= startPos)
      {
        WriteChildContents(this, phr->tag.fRecNum, 0, NULL, NULL, (TContentsInfo *)saveInfo,
                       NULL, NULL);
      }
    }
  }
  else
#endif
  {
    if (doc->fTabContents)
      for (int i = info->level; i > 2; i--)
        sender->SendChar(chTab);

    body->WriteTextLine(sender, 0, body->fCount);
    sender->SendChar(chTab);
    Roman(pageData.pageNum, str, pageData.romanPages); // F = NumToString, T = lcRoman
    sender->SendCString(str);
    sender->SendParaBreak();
  }
}
#endif
#else
void _TFormat::WriteContents(TCurrency currency, void *saveInfo)
{}
void _TTableFormat::WriteContents(TCurrency currency, void *saveInfo)
{}
void _TBodyFormat::WriteContents(TCurrency currency, void *saveInfo)
{}
void _TTextFormat::WriteContents(TCurrency currency, void *saveInfo)
{}
#endif

#if defined INDEX && !defined NETWP
#define kSeeRef kIndexRefStruct
// ------------------------------------------------------------------------
static void BuildSortList(TObject null, TRecordIndex aRecord, TRecordHandler handler,
                                 int *totalRecs, char **sortArray, bool symbols)
{
  TIndexStructure indexStructure =
                     TIndexStructure(handler->GetRecordObject(aRecord, kReadOnly));
  char *theRecordKey = indexStructure->GetKey();

  if (*theRecordKey != 1 && symbols == (NameToCmdLetter(theRecordKey) == cIndexSymbol))
  {
    for (int i = 1; i <= indexStructure->fSize; i++)
    {
      PIndexRef thisEntry = PIndexRef(indexStructure->At(i));

      if (thisEntry->fHomeCurrency < 0x10000 ||
                                      Curr_fType(thisEntry->fHomeCurrency) != kSeeRef)
      {
        *(sortArray + *totalRecs) = theRecordKey;
        (*totalRecs)++;
        break;
      }
    }
  }
}

extern void SortHook();

// ------------------------------------------------------------------------
static void GenerateIndex(TTextDocument doc, TSender sender)
{
  TRecordHandler recHandler = doc->fStructureHandlers[kIndexRefStruct];
  int totalRecs;
  char **sortArray;
  int currLetter = 0;
  int workspace;
  int sym;
  FailInfo fi;

  CountRecords(recHandler, &totalRecs);
  sortArray = (char **)NewCheckedHandle(totalRecs * 4);

  CatchFailures(&fi);

  for (sym = 1; sym >= 0; sym--)
  {
    totalRecs = 0;
    recHandler->ForAllRecordsDo(NULL, (DoToRecord)BuildSortList, &totalRecs, sortArray, sym);
    
    wr_wimpt_noerr(wr_os_swi4(OS_HeapSort | wr_os_X, totalRecs, int(sortArray),
             gWimpVersion >= 300 ? (int)SortHook : 4, (int)&workspace));
    for (int i = 0; i < totalRecs; i++)
    {
      char *thisKey = sortArray[i];
      int recNum;
      TIndexStructure indexStructure;
      int qualItem;
      int cmd = NameToCmdLetter(thisKey);

      if (cmd != currLetter)
      {
        char title[32];

        currLetter = cmd;
        CmdToName(cmd, title);
        sender->SendCString(title);
        sender->SendParaBreak();
      }
      recNum = FindRecordForKey(recHandler, thisKey);
      qualItem = (recNum << 16) + kSeeRef;
      indexStructure = TIndexStructure(recHandler->GetRecordObject(recNum, kReadOnly));
      sender->SendCString(thisKey);

      for (int j = 1; j <= indexStructure->fSize; )
      {
        // scan through all the qualifier entries for the given subject key
        PIndexRef ref = PIndexRef(indexStructure->At(j));
        int qualIdx = ref->fIndexInText;
        char *qualifier = indexStructure->GetTextOffset(qualIdx);
        bool first;
        bool see = TRUE;
        int jFirst = j;
        int lastPage;
        int thisPage;

        first = TRUE;
        if (qualifier[0] != 0)              // it is a named qualifier
        {
          if (j == 1)
            sender->SendParaBreak();   // but no references from main key
          sender->SendChar(chTab);
          sender->SendCString(qualifier);
        }

        // sort the page numbers from the references and eliminate duplicates
        lastPage = 0;
        while (TRUE)
        {
          int numFmt = 0;
          char page[20];

          thisPage = MAXLONGINT;
          // scan through all the page refs belonging to the current qualifier
          for (j = jFirst; j <= indexStructure->fSize &&
                 (ref = PIndexRef(indexStructure->At(j)),
                     qualIdx == ref->fIndexInText && ref->fHomeCurrency >= 0x10000); j++)
          {
            if (ref->fPageNumber > lastPage && thisPage >= ref->fPageNumber)
            {
              thisPage = ref->fPageNumber;
              numFmt = ref->fNumberFormat;
            }
          }
          if (thisPage == MAXLONGINT)      // there were no pages higher than last output
            break;
          page[0] = ' ';
          Roman(thisPage, page + 1, numFmt);
          if (!first)
            sender->SendChar(',');
          first = FALSE;
          sender->SendCString(page);
          lastPage = thisPage;
        }

        // scan through the 'see' references for the current qualifier
        while (qualIdx == ref->fIndexInText)
        {
          if (ref->fHomeCurrency < 0x10000)
          {
            // it is a reference to another index entry
            // N.B. there is a deficiency: multiple sees to a single record are not sorted!!!
            TIndexStructure xref =
                 TIndexStructure(recHandler->GetRecordObject(ref->fHomeCurrency, kReadOnly));
            char *xQual;
            int strIndex;

            if (see)
            {
              if (first && (j == 1 || qualifier[0] != 0 || j != jFirst))
                strIndex = 1;          // " see "
              else
              {
                if (qualifier[0] != 0)
                {
                  sender->SendParaBreak();
                  sender->SendChar('\t');
                }
                else if (!first)
                  sender->SendParaBreak();
                sender->SendChar('\t');
                strIndex = 2;          // "see also "
              }
            }
            else
              strIndex = 3;            // " and "
            sender->SendCString(GetIndString(54, strIndex));
            see = FALSE;
            first = FALSE;
            sender->SendCString(xref->GetKey());

            // now look for qualifier: see xRef (xQual)
            xQual = xref->GetQualifier(qualItem);
            if (xQual[0] != 0)
            {
              sender->SendCString(" (");
              sender->SendCString(xQual);
              sender->SendChar(')');
            }
            qualItem += 256;
          }
          j++;
          if (j > indexStructure->fSize)
            break;
          ref = PIndexRef(indexStructure->At(j));
        }
        
        sender->SendParaBreak();
      }
    }
  }
  Success(&fi);
Rescue:
  DisposIfHandle(sortArray);
  ContinueIfFail(&fi);
}
#endif

#if (defined CONT || defined INDEX) && !defined NETWP
// ------------------ TDViews method -------------------------------------
void _TPages::WriteContents(TSender sender)
{
  TCurrency body;
  TFormat bodyFmt;
  TContentsInfo info;
  TObject startBreak = NULL;
  TTextDocument doc = TTextDocument(fView->fDocument);

  doc->CommitLastDocCommand();  // 19/12/94
  info.sender = sender;
  fView->CompletePagination();
  body = doc->fBody;
  bodyFmt = fView->GetFormatReadOnly(body);
  for (int pageNum = 1; pageNum <= fSize; pageNum++)
  {
    info.startBreak = startBreak;
    startBreak = info.endBreak = PPageInfo(At(pageNum))->fBreak;
    info.pageNum = pageNum;
    info.level = 0;
    info.subset = 1;
    bodyFmt->WriteContents(body, &info);
  }
#ifdef INDEX
  if (doc->fSaveCmd != cSaveContents)
    GenerateIndex(doc, sender);
#endif
}
#endif

// ------------------------------------------------------------------------
_TFancyTextSender::_TFancyTextSender(char *buffer, TDispatcher dispatcher,
              TTextDocument printDoc)
                                       : (buffer, dispatcher, kTextFile)
{
  if (printDoc)
  {
    fLineLength = 72;   // calculate from page setup
    fExpandTabs = 8;
  }
  else
  {
    char *thisOpt;

    thisOpt = GetRsrcOption('m');

    fLineLength = (thisOpt ? atoi(thisOpt) : 0);
    thisOpt = GetRsrcOption('t');
    fExpandTabs = (thisOpt ? atoi(thisOpt) : 0);
  }
}

// ------------------------------------------------------------------------
void _TFancyTextSender::SendChar(int ch)
{
  if (fExpandTabs)
  {
    if (ch == chTab)
    {
      int linepos = fSpaceRequired + fBufferUsed - fLastLineEnd;
      int spaces = fExpandTabs - (linepos % fExpandTabs);

      if (fLineLength > 0)
      {
        int charsLeft = fLineLength - fBufferUsed;

        if (charsLeft == 0)    // tab will wrap to next line
        {
          // recalc spaces based on where tab will end up on the following line
          spaces = fExpandTabs -
               (fLineStart == 0 ? 0 : (fBufferUsed - fLineStart) % fExpandTabs);
        }
        else if (charsLeft < spaces)
          spaces = charsLeft;
      }
      for (; spaces > 1; spaces--)
        _TSender::SendChar(' ');
      ch = ' ';   // output final space and set eol/flags below
    }
    else if (ch == chReturn || ch == chLineFeed)
      fLastLineEnd = fSpaceRequired + fBufferUsed + 1;
  }

  _TSender::SendChar(ch);

  if (fLineLength > 0)
  {
    if (ch == chReturn || ch == chLineFeed)
    {
      WriteBuffer();
      fLineStart = 0;
    }
    else if (fBufferUsed > fLineLength)
    {
      int newLineStart = (fLineStart > 0 ? fLineStart : fLineLength);
                  // move max line length if no natural break
      int remd = fBufferUsed - newLineStart;

      fBufferUsed = newLineStart;

      WriteBuffer();    // write out fBufferUsed (up to after last space)
      SendLineBreak();  // should zeroise fLineStart & fBufferUsed

      // move unsent data down to bottom of buffer
      memmove(fBuffer, fBuffer + newLineStart, remd);
      fBufferUsed = remd;
    }
    else if (ch == ' ')
      fLineStart = fBufferUsed;
  }
}

#if defined PRO && !defined NETWP
// ------------------------------------------------------------------------
static IDType gRadios[] =
      { I_(  0,   0, 'C', 'r'), I_(  0,   0, 'L', 'f'), I_('C', 'r', 'L', 'f'),
        I_('L', 'f', 'C', 'r'), 0 };

// ------------------------------------------------------------------------
static void SetCuster(TView aDialogView, IDType clusterId, int idx)
{
   TCluster aClust = TCluster(aDialogView->FindSubView(clusterId));

   if (aClust)
     aClust->WriteCheckBox(gRadios[(idx - '0') & 3], TRUE);  // 21/04/95
}

// ------------------------------------------------------------------------
static int GetCuster(TView aDialogView, IDType clusterId)
{
   TCluster aClust = TCluster(aDialogView->FindSubView(clusterId));

   return (aClust ? LookupID(aClust->ReportCurrent(), gRadios) : 0);
}

// ------------------------------------------------------------------------
void DoChoicesChoice(TApplication app, TView origView, int itsChoice)
{
   TView aDialogView = origView->GetDialogView();

   if (origView->fIdentifier == I_('D', 'f', 'l', 't'))
   {
      char *maxLineLen = gMaxLineLen;
      char *textLf = gTextLf;
      char *textCr = gTextCr;
      char *tabExpand = gTabExpand;

      // reset the options to defaults
      gMaxLineLen = NULL;
      gTextLf = NULL;
      gTextCr = NULL;
      gTabExpand = NULL;
      WriteToChoicesDialog(app, aDialogView);
      gMaxLineLen = maxLineLen;
      gTextLf = textLf;
      gTextCr = textCr;
      gTabExpand = tabExpand;
   }
   else                                 // must be I_('l', 'i', 'n', 'l')
     aDialogView->WriteCheckBox(I_('M', 'a', 'x', 'l'), TRUE);
}

// ------------------------------------------------------------------------
void WriteToChoicesDialog(TApplication app, TView aDialogView)
{
   char *thisOption = GetRsrcOption('m');

   aDialogView->WriteValueRedraw(I_('l', 'i', 'n', 'l'), thisOption ? atoi(thisOption) : 72);
   aDialogView->WriteCheckBox(I_('M', 'a', 'x', 'l'), int(thisOption));
   thisOption = GetRsrcOption('e');
   aDialogView->WriteCheckBox(I_(0, 'D', 'b', 'l'), thisOption ? (*thisOption - '0') >> 2 : 0);
   SetCuster(aDialogView, I_(0, 'e', 'o', 'p'), thisOption ? *thisOption : '0');
   thisOption = GetRsrcOption('k');
   SetCuster(aDialogView, I_(0, 'e', 'o', 'l'), thisOption ? *thisOption : '1');
   thisOption = GetRsrcOption('t');
   aDialogView->WriteCheckBox(I_('X', 't', 'a', 'b'), int(thisOption));
}

// ------------------------------------------------------------------------
TCommand SaveChoicesToFile()
{
   char buf[512];
   char filenameBuf[512];
   wr_os_filestr f;
   char *p = buf;

   // update Choices file
   for (int i = 'a'; i <= 'z'; i++)
   {
      char *rsrc = GetRsrcOption(i);               // get option string

      if (rsrc != NULL)
      {
         *(p++) = i;                               // save code letter
         p = strcpy(p, rsrc);
         p += strlen(p);                           // copy rsrc string
         *(p++) = ' ';                             // add space
      }
   }

   CreateChoiceDir(filenameBuf);   // 20/02/96 [27021] Save to Choices$Write if available
   strcat(filenameBuf, "Choices");
   f.start = (int)buf;
   f.end = (int)p - 1; // knock off the added space
   f.action = (f.start >= f.end ? 6 : 10);    // delete if none else save new contents
   f.name = filenameBuf;
   f.loadaddr = 0xfff;       // text file
   FailOSErr(wr_os_file(&f));
   return gNoChanges;
}

// ------------------------------------------------------------------------
TCommand ReadFromChoicesDialog(TApplication app, TView aDialogView, CmdNumber aCmd, IDType icnId)
{
   // e0-7 for End of para representation (default e0)
   // k0-3 for end of line representation (default k1)
   // t[n] for expand tabs (default 8)
   // mn   for maximum text line length
   int setBtn = GetCuster(aDialogView, I_(0, 'e', 'o', 'p'));

   if (aDialogView->TestCheckBox(I_(0, 'D', 'b', 'l')))
      setBtn += 4;
   if (setBtn == 0)
     gTextCr = NULL;
   else
     NumToString(setBtn, gTextCr = gTextCrStr);

   setBtn = GetCuster(aDialogView, I_(0, 'e', 'o', 'l'));
   if (setBtn == 1)
     gTextLf = NULL;
   else
     NumToString(setBtn, gTextLf = gTextLfStr);

   gTabExpand = (aDialogView->TestCheckBox(I_('X', 't', 'a', 'b')) ? gTabExpandStr : NULL);
     
   if (aDialogView->TestCheckBox(I_('M', 'a', 'x', 'l')))
   {
     // set on
     NumToString(aDialogView->ReadValue(I_('l', 'i', 'n', 'l'), 72),
                                                         gMaxLineLen = gMaxLineLenStr);
   }
   else
     gMaxLineLen = NULL;  // set opt to null

#ifndef NETWP
   if (icnId == I_('S', 'a', 'v', 'e'))  // otherwise choices are only set locally
     return SaveChoicesToFile();
#endif
   return gNoChanges;
}
#endif

