/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "drawmod.h"
#include "akbd.h"

#include "UTextDoc.h"
#include "PTextComm.h"
#include "DrawIFace.h"

#define kHeaderMarginsTooSmall 15
#define kFooterMarginsTooSmall 17
#define kSearchDlgID 19
#define kPageTurnover 0x8000

typedef TDiscPosition TFormatRecords[kMathStyleStruct + 1];

typedef struct TViewRecord
{
  TFormatRecords formatHandlers;
  long formatPosition;
  int nextViewId;
  Fixed headerMargin;
  Fixed footerMargin;
  int pageCount;
  bool viewActive;
  bool showPictures;   // 25/06/90
} TViewRecord;

const CntlAdornment CntlFrame =
                 (adnLineTop | adnLineLeft | adnLineBottom | adnLineRight);

#define kAll0 I_('A', 'l', 'l', '0')
#define kRepl I_('R', 'e', 'p', 'l')
#define kOKbn I_('O', 'K', 'b', 'n')

#define kFind gTVIds[0]
#define kChng gTVIds[1]
#define kWord gTVIds[2]
#define kCase gTVIds[3]
#define kRev0 gTVIds[4]

static IDType gTVIds[] = {I_('F', 'i', 'n', 'd'),
                          I_('C', 'h', 'n', 'g'),
                          I_( 0,  'S', 'c', 'h'),
                          I_('C', 'a', 's', 'e'),
                          I_('R', 'e', 'v', '0') };

TRuleType gDefaultPen = {kOnePtPen, k1Thn, FALSE};

static TRuleType gNewPens[] = {
        {kOnePtPen, kNoRule, FALSE},        // kNoRuleX,
        {kOnePtPen / 4, k1Thn, FALSE},      // kHairLine,
        {kOnePtPen / 2, k1Thn, FALSE},      // kHalfPtRule,
        {kOnePtPen, k1Thn, FALSE},          // kSinglePtRule,
        {kOnePtPen * 2, k1Thn, FALSE},      // kDoublePtRule,
        {kOnePtPen, k2Thn, FALSE},          // kSingleSinglePair,
        {kOnePtPen / 2, kThkThn, FALSE},    // kSingleHalfPair,
        {kOnePtPen / 2, kThnThk, FALSE},    // kHalfSinglePair,
        {kOnePtPen, kThkThn, FALSE},        // kDoubleSinglePair,
        {kOnePtPen, kThnThk, FALSE},        // kSingleDoublePair,
        {kOnePtPen, kTotalRules, FALSE}};   // kTotalRulesX  

// -------------------------------------------------------------------------
TRuleType NewRuleType(TOldRuleType oldFmt)
{
#ifdef NEVER
  int pen = kOnePtPen;
  TLineType rule = k1Thn;
  TRuleType res;

  switch(oldFmt)
  {
    case kNoRuleX:          rule = kNoRule; break;
    case kDoublePtRule:     pen = pen * 8;   // * 2; break;
    case kHairLine:         pen = pen / 2;   // / 4; break;
    case kHalfPtRule:       pen = pen / 2;   // break;
    case kSinglePtRule:     break;
    case kSingleSinglePair: rule = k2Thn; break;   // 19/04/91
    case kSingleHalfPair:   pen = pen / 2;   // rule = kThkThn; break;
    case kDoubleSinglePair: rule = kThkThn; break;
    case kHalfSinglePair:   pen = pen / 2;   // rule = kThnThk; break;
    case kSingleDoublePair: rule = kThnThk; break;
    case kTotalRulesX:      rule = kTotalRules;
  }
  res.fShort = 0;
  res.fPen = pen;
  res.fRule = rule;
  return res;
#endif
  return gNewPens[oldFmt];
}

// -------------------------------------------------------------------------
TOldRuleType OldRuleType(TRuleType newFmt)
{
  int pen = newFmt.fPen;
  unsigned int penSize = kOnePtPen;

  switch (newFmt.fRule)
  {
    case kNoRule:
      return kNoRuleX;
    case k1Thn:
      if (pen > penSize)
        return kDoublePtRule;
      if (pen > (penSize >> 1))
        return kSinglePtRule;
      if (pen > (penSize >> 2))
        return kHalfPtRule;
      return kHairLine;
      //if (pen == penSize)
      //  return kSinglePtRule;
      //penSize = penSize >> 1;
      //if (pen == penSize)
      //  return kHalfPtRule;
      //penSize = penSize >> 1;
      //if (pen == penSize)
      //  return kHairLine;
      //return kDoublePtRule;
    case k2Thn:
      return kSingleSinglePair;
    case kThnThk:
      if (pen >= penSize)
        return kSingleDoublePair;
      return kHalfSinglePair;
    case kThkThn:
      if (pen >= penSize)
        return kDoubleSinglePair;
      return kSingleHalfPair;
    default:
      return kTotalRulesX;
  }
}

#ifdef DRAWSAVE
// ------------------------------------------------------------------------
// 28/10/92 draw lines rather than rects with gaps
static int *AddSubpath(int *thePath, bool line, int h, int v)
{
  if (line || thePath[0] != path_move_2)
    thePath += 3;
  thePath[0] = (line ? path_lineto : path_move_2);
  thePath[1] = h;
  thePath[2] = v;
  return thePath;
}
#endif

// ------------------------------------------------------------------------
static void DrawAdornRect(Rect &qdBox, int inset, int penSize,
                   CntlAdornment adornment, Fixed zoomFactor)
{
  int                    path[50];
  wr_drawmod_pathelemptr    ptr;
  wr_drawmod_line           line;
  wr_drawmod_transmat       trans;
  int                    zoom;
  Point                  offset;
  Rect                   box;
  int                    lineThickness;
  int                    vLineThickness;
  int                    multiplyer;
#ifdef DRAWSAVE
  int                   *thePath = path;
#endif

  if (penSize == 0)
    return;  // 04/06/90 - do not do anything if the pen is 0 line thickness

  // ---------- sort out the coordinate system
  zoom = FixMul(zoomFactor, 0x010000);
#ifdef DRAWSAVE
  if (gSender)
  {
    // 03/02/94 [21378] clip rects for Save as Draw
    if (!SectRect(*thePort->GetClipRect(), qdBox, box))
      return;
    for (int i = 0; i < 4; i++)
    {
      if (((int *)&qdBox)[i] != ((int *)&box)[i])
        adornment &= ~(adnLineTop << i);
    }
    if ((adornment & (adnLineTop | adnLineLeft | adnLineBottom | adnLineRight)) == 0)
      return;
  }
  else
#endif
    MoveRect(box, qdBox);

  // ---------- unzoom the box
  multiplyer = (kFix1 << 6) / zoomFactor;
  if ((kFix1 << 6) % zoomFactor == 0)
  {
    // 17/09/91 faster (and more accurate for more than 233 pages)
    box.left   *= multiplyer;
    box.right  *= multiplyer;
    box.top    *= multiplyer;
    box.bottom *= multiplyer;
    lineThickness = GetHLineThickness() * multiplyer;
    vLineThickness = GetVLineThickness() * multiplyer;
  }
  else
  {
    box.left   = FixDiv(box.left, zoomFactor) << 6; // 27/04/90 use FixDiv
    box.right  = FixDiv(box.right, zoomFactor) << 6;
    box.top    = FixDiv(box.top, zoomFactor) << 6;
    box.bottom = FixDiv(box.bottom, zoomFactor) << 6;
    lineThickness = FixDiv(GetHLineThickness() << 6, zoomFactor);
    vLineThickness = FixDiv(GetVLineThickness() << 6, zoomFactor);
  }

  // --------- inset the rect so that it is inside the view
//  inset += Max(0, (penSize - lineThickness) / 2);         // 30/04/90 test!
//  vInset += Max(0, (penSize - vLineThickness) / 2);       // 30/04/90 test!
//  inset += penSize / 2;                        // 13/02/91
//  vInset += penSize / 2;                       // 13/02/91

  // 08/06/90 - to get adorning done correctly...
  box.top += ((adornment & adnLineTop) ?
                  inset + Max(0, (penSize - lineThickness) / 2) : 0);
  box.bottom -= ((adornment & adnLineBottom) ? inset + penSize / 2 : 0);
  box.left += ((adornment & adnLineLeft) ?
                  inset + Max(0, (penSize - vLineThickness) / 2) : 0);
  box.right -= ((adornment & adnLineRight) ? inset + penSize / 2 : 0);

  // --------- set up the path for drawing
#ifdef DRAWSAVE
  // 28/10/92 avoid use of path_gapto and path_closegap for saved draw files
  thePath[0] = path_move_2;
  thePath[1] = box.left;
  thePath[2] = box.top;
  thePath = AddSubpath(thePath, adornment & adnLineTop, box.right, box.top);
  thePath = AddSubpath(thePath, adornment & adnLineRight, box.right, box.bottom);
  thePath = AddSubpath(thePath, adornment & adnLineBottom, box.left, box.bottom);
  thePath = AddSubpath(thePath, adornment & adnLineLeft, box.left,
           box.top - ((adornment & adnLineTop) ? penSize / 2 : 0));
  if (thePath[0] != path_move_2)
    thePath += 3;
  thePath[0] = 0;
  thePath[1] = (50 - (thePath - path)) * 4;
#else
  path[0] = path_move_2;
  path[1] = box.left;
  path[2] = box.top;
  path[3] = ((adornment & adnLineTop) ? path_lineto : path_gapto);
  path[4] = box.right;
  path[5] = box.top;
  path[6] = ((adornment & adnLineRight) ? path_lineto : path_gapto);
  path[7] = box.right;
  path[8] = box.bottom;
  path[9] = ((adornment & adnLineBottom) ? path_lineto : path_gapto);
  path[10] = box.left;
  path[11] = box.bottom;
  path[12] = ((adornment & adnLineLeft) ? path_closeline : path_closegap);
  path[13] = 0;
  path[14] = (50 - 17) * 4;
#endif
  ptr.wordp = path;

  // --------- set up the line style
  line.flatness = 0;   // !!! ??? check up on this - probably change
  line.thickness = (gPrinting || penSize >= lineThickness ? penSize : 0); 
                                   // 27&30/04/90 avoid missing borders
  line.spec.join = 0;  // Mitred
  line.spec.leadcap = 0;  // 28/10/92 use projecting square ends, now we have open paths
  line.spec.trailcap = 0; // 28/10/92
  line.spec.reserved8 = 0;
  line.spec.mitrelimit = 0x0fff0000;
  // 28/10/92 fill in n/a fields for triangular caps
  line.spec.lead_tricap_w = 0x0100;     /* "width" of leading triangular caps */
  line.spec.lead_tricap_h = 0x0100;     /* "height of leading triangular caps */
  line.spec.trail_tricap_w = 0x0100;    /* "width" of trailing triangular caps */
  line.spec.trail_tricap_h = 0x0100;    /* "height" of trailing  triangular caps */
  line.dash_pattern = NULL;

  // ---------- transformation matrix
  offset = gZeroPt;
  thePort->LocalToGlobal(offset);
  trans[0] = zoom;
  trans[1] = 0;
  trans[2] = 0;
  trans[3] = -zoom;
  trans[4] = offset.h << 6;
  trans[5] = (ScreenHeight() - offset.v) << 6;

  // ---------- do the draw
  FailOSErr(DrawStroke(ptr, 0, &trans, &line));
}


static char shadowWidths[11] = {0, 8, 8, 10, 20, 20, 20, 20, 20, 20, 0};
                                  // 05/07/91 hairline(1): 4 -> 8
// gives shadow width in deci-points

// ------------------------------------------------------------------------
Fixed GetBorderWidth(AdornPieces border, CntlAdornment adornment,
                                                        TRuleType ruleType)
{
  Fixed width = 0;

  if ((border & adornment) != 0)
  {
    static char lineWidths[11] = {0, 20, 20, 20, 30, 40, 40, 40, 50, 50, 0};
//    static char lineWidths[11] = {0, 1, 5, 10, 20, 30, 25, 25, 40, 40, 0};
             // 25/03/91 reduce to real line width without extra for space

    width = ToFixed(lineWidths[OldRuleType(ruleType)]);
/*
    switch (ruleType)
    {
    case kHairLine:         width = FixPointVal(20); break;
    case kHalfPtRule:       width = FixPointVal(20); break;
    case kSinglePtRule:     width = FixPointVal(20); break;
    case kDoublePtRule:     width = FixPointVal(30); break;
    case kSingleSinglePair: width = FixPointVal(40); break;
    case kSingleHalfPair:   width = FixPointVal(40); break;
    case kHalfSinglePair:   width = FixPointVal(40); break;
    case kDoubleSinglePair: width = FixPointVal(50); break;
    case kSingleDoublePair: width = FixPointVal(50);
    }
*/
    if ((adornment & adnShadow) && (border & (adnLineRight | adnLineBottom)))
      width += ToFixed(shadowWidths[OldRuleType(ruleType)]);
/*
    {
      switch (ruleType)
      {
      case kHairLine:     width += FixPointVal(10); break;
      case kHalfPtRule:   width += FixPointVal(10); break;
      case kSinglePtRule: width += FixPointVal(10); break;
      default:            width += FixPointVal(20);
      }
    }
*/
  }

  return(width);
}

/*  kNoRule, kHairLine, kHalfPtRule, kSinglePtRule, kDoublePtRule,
    kSingleSinglePair, kSingleHalfPair, kHalfSinglePair, kDoubleSinglePair,
    kSingleDoublePair, kTotalRules */ 

static char lineWidths[11] =  {0, 1, 2, 4, 8, 4, 4, 2, 8, 4, 0};
static char line2Widths[11] = {0, 0, 0, 0, 0, 4, 2, 4, 4, 8, 0};
static char lineInsets[11] =  {0, 0, 0, 0, 0, 8, 8, 6, 12, 8, 0};

// ------------------------------------------------------------------------
Fixed GetBorderThickness(AdornPieces border, CntlAdornment adornment,
                                                        TRuleType ruleType)
// 16/07/91 return real line width without extra for space
{
  Fixed width = 0;

  if ((border & adornment) != 0)
  {
    int idx = OldRuleType(ruleType);

    width = ToFixed(lineWidths[idx] + line2Widths[idx] + (lineInsets[idx] * 2));
    if ((adornment & adnShadow) && (border & (adnLineRight | adnLineBottom)))
      width += ToFixed(shadowWidths[idx]);
  }

  return(width);
}

// ------------------------------------------------------------------------
void GetBorderThicknessRect(Rect &ruleWidths, CntlAdornment ruleBorders,
                                                        TRuleType ruleType)
{
  ruleWidths.top = GetBorderThickness(adnLineTop, ruleBorders, ruleType);
  ruleWidths.bottom = GetBorderThickness(adnLineBottom, ruleBorders, ruleType);
  ruleWidths.right = GetBorderThickness(adnLineRight, ruleBorders, ruleType);
  ruleWidths.left = GetBorderThickness(adnLineLeft, ruleBorders, ruleType);
}

// ------------------------------------------------------------------------
static void DrawTheRule(VHSelect vhs, int lh, int lv, int lto, TRuleType ruleType, Fixed factor)
{
  // 08/06/90 - new proc to draw line between columns - v0.1
  Rect area;
  CntlAdornment adnType;
  int thickness;
  int oldRule = OldRuleType(ruleType);

  thickness = (line2Widths[oldRule] != 0 ?
               lineInsets[oldRule] + line2Widths[oldRule] : lineWidths[oldRule]);
  thickness *= 160;

  area.left = lh;
  area.top = lv;
  area.right = area.left + (vhs == v ? thickness : lto - lh);
  area.bottom = area.top + (vhs == h ? thickness : lto - lv);
  adnType = (vhs == v ? adnLineLeft : adnLineTop);

//  if (point1)
//    DrawAdornRect(area, 0, 160, adnType, factor);
//  else
  {
    DrawAdornRect(area, 0, lineWidths[oldRule]  * 160,
                                            adnType, factor);
    if (line2Widths[oldRule] != 0)
      DrawAdornRect(area, lineInsets[oldRule] * 160,
         line2Widths[oldRule] * 160, adnType & CntlFrame, factor);
  }
}


// ------------------------------------------------------------------------
void XFrameRect(Rect& area, TRuleType ruleType,
               CntlAdornment itsAdornment, int zoomFactor)
{
#ifdef FN
    if (ruleType.fShort == 1 && itsAdornment == adnLineTop)
      area.right = area.left + LengthRect(area, h) / 6;
#endif
//  if (point1)
//  {
//    DrawAdornRect(area, 0, 160, itsAdornment, zoomFactor);
//  }
//  else
  {
    int oldRule = OldRuleType(ruleType);
/*  kNoRule, kHairLine, kHalfPtRule, kSinglePtRule, kDoublePtRule,
    kSingleSinglePair, kSingleHalfPair, kHalfSinglePair, kDoubleSinglePair,
    kSingleDoublePair, kTotalRules */ 


/*
    switch (ruleType)
    {
      case kHairLine:
        lineWidth = 1; break;
      case kHalfPtRule:
        lineWidth = 2; break;
      case kDoublePtRule:
        lineWidth = 8; break;
      case kHalfSinglePair:
        lineWidth = 2; break;
      case kDoubleSinglePair:
        lineWidth = 8; break;
    }
*/
    DrawAdornRect(area, 0, lineWidths[oldRule] /* quarter points */ * 160,
                                            itsAdornment, zoomFactor);
/*
    lineWidth = 0;
    switch (ruleType)
    {
      case kSingleSinglePair:
        lineWidth = 4;
        break;
      case kSingleHalfPair:
        lineWidth = 2;
        break;
      case kHalfSinglePair:
        lineWidth = 4;
        lineInset = 6;
        break;
      case kDoubleSinglePair:
        lineWidth = 4;
        lineInset = 12;
        break;
      case kSingleDoublePair:
        lineWidth = 8;
    }
*/
    if (line2Widths[oldRule] != 0)
      DrawAdornRect(area, lineInsets[oldRule] * 160,
         line2Widths[oldRule] * 160, itsAdornment & CntlFrame, zoomFactor);
  }
}


void SetSillyRect(Rect &rectToSet)
{
   // 16/05/90 - isolate occurrances of this. Needs to move to TDViews (hdr)
   // ClearRect(rectToSet);
   rectToSet.left = rectToSet.right = 0;
   rectToSet.top = MAXLONGINT;
   rectToSet.bottom = -rectToSet.top;  // 23/04/92 avoid recognising as sensible if top reset
}

// ------------------------------------------------------------------------
_TSubView::_TSubView(TDocument itsDocument, TView itsSuperView, TMainView itsMainView,
     TSubView itsNextView, VPoint &itsLocation, VPoint &itsSize,
     // SizeDeterminer itsHSizeDet, SizeDeterminer itsVSizeDet,
     TCurrency itsStructure, int itsSpBefore, int itsSpAfter)
     //  : (NULL, itsSuperView, itsLocation, itsSize, itsHSizeDet, itsVSizeDet)
       : (itsSuperView, itsLocation, itsSize, sizeVariable)
{
  FailInfo fi;

  CatchFailures(&fi);          // 11/06/91 GetBorderInfo can fail
  fStructure = itsStructure;
  fMainView = itsMainView;
  fNextView = itsNextView;
  SetSillyRect(fUpdateExtent);
  // 03/05/92 set fSp.. directly to avoid forceRedraw in ctor???
//  SetSpacing(itsSpBefore, itsSpAfter);
  fSpBefore = ZoomInt(itsSpBefore);
  fSpAfter= ZoomInt(itsSpAfter);
  GetBorderInfo(fAdornRect, fAdornment, fRuleType);
#ifndef ZERO_OBJ
// fn1 fDrawnChanges = FALSE;
  fUpdated = FALSE; /* fn1 */
  fSelected = FALSE;
#endif
  Success(&fi);
  // set fDocument now, rather than by passing to ctor to stop view being
  // added to the document view list
  fDocument = itsDocument;
  return;

Rescue:
  _TView::Free();
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
_TSubView::_TSubView(TDocument itsDocument, TView itsSuperView,
                char* &itsParams) : (itsDocument, itsSuperView, itsParams)
{
#ifndef ZERO_OBJ
  fStructure = 0;
  fMainView = NULL;
  fNextView = NULL;
  ClearRect(fUpdateExtent);
  fSpBefore = 0;
  fSpAfter = 0;
  ClearRect(fAdornRect);
  fAdornment = 0;
// fn1 fDrawnChanges = FALSE;
  fUpdated = FALSE; /* fn1 */
  fSelected = FALSE;
#endif
  fRuleType.fPen = 1;
  fRuleType.fRule = k1Thn;
}


// ------------------------------------------------------------------------
void _TSubView::Free()
{
  TWindow myWindow = GetWindow();
  THandler last = NULL;

  // 02/02/91 ensure target chain not corrupted
  if (myWindow != NULL)
    for (THandler current = myWindow->fTarget;
                    current != myWindow && current != NULL; last = current,
                                current = current->fNextHandler)
      if (current == this)
      {
        if (last == NULL)
          myWindow->SetTarget(fNextHandler);
        else
        last->fNextHandler = fNextHandler;
        fNextHandler = NULL; // stops THandler having to do this all again
      }

  if (fMainView != NULL)
  {
    fMainView->RegisterDep(gNullCurrency, this); // 17/09/92 , FALSE);      // 04/03/92
    if (fMainView->fSlavedSubView == this)
      fMainView->ClearViewSlave();
  }
  _TView::Free();
}


// ------------------------------------------------------------------------
void _TSubView::Delete()
{
  // 04/05/90 - new method
  Free();
}

// ------------------------------------------------------------------------
void _TSubView::GetExtendedFrame(VRect &itsFrame)
{
  GetFrame(itsFrame);
  itsFrame.left += fLeftExtension;
  itsFrame.right += fRightExtension;
}

// ------------------------------------------------------------------------
void _TSubView::SubViewExtended(TView theSubView)
{
  // 16/10/96 [27107] set up extended frame for Word tables outside superview bounds.
  // Really there should be a way of resetting the extensions (for after deleting an
  // extended view). NB. the case of zooming down is sorted automatically because all
  // the subviews of the mainview are thrown away and reinserted and mainview itself
  // tends not to be extended.
  int rtExt;
  TSubView callUp = NULL;
  VRect subFrame;

  theSubView->GetExtendedFrame(subFrame);
  if (subFrame.left < fLeftExtension)
  {
    fLeftExtension = subFrame.left;
    callUp = fMainView;
  }
  rtExt = subFrame.right - fSize.h;
  if (rtExt > fRightExtension)
  {
    fRightExtension = rtExt;
    callUp = fMainView;
  }
  if (callUp != NULL)
    TSubView(fSuperView)->SubViewExtended(this);
}

// ------------------------------------------------------------------------
void _TSubView::SubViewChangedSize(TView theSubView, VPoint &delta)
{
  SubViewExtended(theSubView); // 16/10/96 [27107]
}

// ------------------------------------------------------------------------
void _TSubView::DrawRule(VHSelect vhs, int lh, int lv, int lto, TRuleType ruleType)
{
  // 08/06/90 - new mac method
  Fixed factor;
  // bool point1;

  PenNormal();
  if (fMainView != NULL)
    factor = fMainView->GetZoomFactor();
  else
    factor = kFix1;

  // point1 = FALSE;
  DrawTheRule(vhs, lh, lv, lto, ruleType, factor);
}


// ------------------------------------------------------------------------
void _TSubView::Adorn(Rect &area, CntlAdornment itsAdornment)
{
  if (itsAdornment != 0)
  {
    bool shadowed;  // , point1;
    Fixed factor;
    TRuleType rule = fRuleType;
    Rect shadowArea;

    PenNormal();
    if (fMainView != NULL)
    { 
      factor = fMainView->GetZoomFactor();
    }
    else
    {
      // it is the page, so pass a zoom factor of 1 and
      // a 1pt ruletype
      rule = gDefaultPen;
      // rule.fPen = kOnePtPen;
      // rule.fRule = k1Thn;
      // rule.fShort = FALSE;   // 21/04/92
      factor = kFix1;
    }

    // point1 = (itsPenSize.h == 0 || itsPenSize.v == 0);
    shadowed = (adnShadow & itsAdornment);

    MoveRect(shadowArea, area);
    if (shadowed)
    {
      int shadowWidth;
      int offset;
      int hOffset;
      int vOffset;

      // inset the original rectangle slightly if necessary
      shadowWidth = (/* point1 ? 10 : */ shadowWidths[OldRuleType(rule)]);
      offset = FixMul(shadowWidth, factor);
      if (gPrinting) // 04/07/91
      {
        vOffset = hOffset = offset;
      }
      else
      {
        hOffset = TruncateToPixel(offset, h - 4);
        vOffset = TruncateToPixel(offset, v - 4);
#ifdef TRACE
        int lineWid = GetVLineThickness();
        Assert(hOffset == ((offset /* + (lineWid / 2) */) / lineWid) * lineWid, 882);
        lineWid = GetHLineThickness();
        Assert(vOffset == ((offset /* + (lineWid / 2) */) / lineWid) * lineWid, 881);
#endif
      }
      // needs doing for printer too !!!!
      shadowArea.right -= hOffset;
      shadowArea.bottom -= vOffset;

      XFrameRect(shadowArea, rule, itsAdornment, factor);
      // just draw the bottom/right edges of an offset box
      OffsetRect(shadowArea, hOffset, vOffset);
      DrawAdornRect(shadowArea, 0, shadowWidth << 6, // synch with above !!!
                           (adnLineRight | adnLineBottom), factor);
    }
    else
      XFrameRect(shadowArea, rule, itsAdornment, factor);
  }
}


// ------------------------------------------------------------------------
TCommand _TSubView::DoMouseCommand(Point &theMouse, EventInfo &info)
// 27/10/91 save having the same in UColEdit, UBodyEdit, UTextEdit, etc
{
  if (fMainView == NULL)
    return _TView::DoMouseCommand(theMouse, info);

  return new _TSelector(fMainView, this);
}

#ifdef TABLES
// ------------------------------------------------------------------------
void _TSubView::EnableStructCmd(CmdNumber aCmdNumber, bool enableIt)
{
  // 20/06/93 - new method
  TStructTypes structType;
  TStyleTypes styleType;

  Enable(aCmdNumber, enableIt);
  if (CmdToStruct(aCmdNumber, styleType, structType))
  {
    int tot = TTextDocument(fDocument)->fStyleSheet->CountStyles(styleType, FALSE);

    SetDynamicSubmenu(aCmdNumber, aCmdNumber == cSubSection || tot > 1 ? cmStructureStyle : 0);
         // 11/02/96 add style submenu for Subsection - better to frig in a Section Style1 !!
  }
}
#endif

/// ------------------------------------------------------------------------
void _TSubView::Select(bool on)
{
  fSelected = on;
}


// ------------------------------------------------------------------------
TStructure _TSubView::GetStructureReadOnly(TCurrency currency)
{
  return TTextDocument(fDocument)->GetStructureReadOnly(currency);
}


// ------------------------------------------------------------------------
TFormat _TSubView::GetMyFormatReadOnly()
{
  return fMainView->GetFormat(fStructure, kReadOnly);
}

#if SIDEBAR == 1
// ------------------------------------------------------------------------
bool _TSubView::DoAnimate(TSubView view, TCurrency currency)
{
  return view->AnimateView(currency);
}

// ------------------------------------------------------------------------
bool _TSubView::AnimateView(TCurrency currency)
{
  return (int)FirstSubViewThat(this, (TestSubView)_TSubView::DoAnimate, currency);
}
#endif

#ifdef TRACE
#if SIDEBAR == 1
// ------------------------------------------------------------------------
void _TSubView::DoEndClick()
{
}
#endif

// ------------------------------------------------------------------------
void _TSubView::SetupMacros()
{
  // 28/01/91 - new method
}


// ------------------------------------------------------------------------
void _TSubView::BodyViewChangedSize(int deltaV, bool invalidate)
// 17/06/91 new
{
}

// ------------------------------------------------------------------------
void _TSubView::GetTrackLimits(TSubView subView, VRect &picLimits, TwoBools repositionInLine)
{
  NotYetImplemented("TSubview.GetTrackLimits");
}

// ------------------------------------------------------------------------
int _TSubView::GetCaretSize(Point &pos, TCursorNode cursorNode)
{
  return 0;
}

// ------------------------------------------------------------------------
void _TSubView::ClickAgain(TCursorNode cursor, bool rightEdge)
{
}


// ------------------------------------------------------------------------
TCursorNode _TSubView::ClickOnce(VPoint &mousePoint)
{
  // 26/07/90
  NotYetImplemented("TSubview.clickonce");
  return(NULL);
}


// ------------------------------------------------------------------------
void _TSubView::SetHighlight(TCursorNode anchor, TCursorNode activeEnd, bool redraw,
bool noteSelection) // fn1
{
  NotYetImplemented("TSubView::SetHighlight");
}
#endif

// ------------------------------------------------------------------------
void _TSubView::ScrollCursorIntoView(TCursorNode cursor)
{
  VRect cursExtent;
  int cDepth;
  Point pos;
  TSubView newTarget;    // 10/11/95 target (self) can get reset in the guts of Connect
                         // for text views, so on D&D into part of para on next page
                         // it is not safe to use self - use fSlavedSubView instead

  cursor->fCursor->Connect(fMainView);
  newTarget = fMainView->fSlavedSubView;
  if (newTarget != NULL)
  {
    cDepth = newTarget->GetCaretSize(pos, cursor);
#ifdef MATHS
    cDepth = abs(cDepth);
#endif
    SetRect(cursExtent, pos.h - 420, pos.v - cDepth, pos.h + 420, pos.v);
    newTarget->DoRevealRect(cursExtent);
  }
}


// ------------------------------------------------------------------------
void _TSubView::StdGetTrackLimits(TSubView subView, VRect &picLimits,
                                                 TwoBools repositionInLine)
{
  // 20/09/90 - common GetTrackLimits for BodyViews and TableViews
  // seems silly to copy it out identically
  VRect extent;

  subView->GetExtent(extent);
  subView->LocalToMainRect(extent);
  if ((repositionInLine & 2) != 0)              // reposition)
    MoveRect(picLimits, extent);
  else
  {
    TSubView(fSuperView)->GetTrackLimits(this, picLimits, repositionInLine);
    picLimits.left = extent.left;
    picLimits.right = extent.right;
  }
}


// ------------------------------------------------------------------------
void _TSubView::Resize(VCoordinate width, VCoordinate height, bool invalidate)
{
  int newWidth = width;
  int newHeight = height;
  int pseudoBottom = fAdornRect.bottom + fSpAfter;    // 25/03/91 + spAfter

  if (fSize.h < width)
    fSize.h -= fAdornRect.right;
  else if (fSize.h > width)
    width -= fAdornRect.right;

  if (fSize.v < height)
    fSize.v -= pseudoBottom;
  else if (fSize.v > height)
  {
    height -= pseudoBottom;
    fSize.v += GetHLineThickness();
           // 07/07/92 ensure pixel below view redrawn when made less deep
  }

  _TView::Resize(width, height, invalidate);

  fSize.h = newWidth;
  fSize.v = newHeight;
}

// ------------------------------------------------------------------------
void _TSubView::LocalToMainRect(VRect &theRect)
{
  if (fMainView != NULL)
  {
//#ifdef TRACE
// Better fix is to get header subview before the body subview (otherwise bottom pixel not drawn)
//    if (TSubView(fSuperView)->fMainView == NULL)    // [26020] get last line of hf drawn
//    {
//      TViewId viewId;

//      viewId.fId = fIdentifier;
//      if (viewId.tag.fSubId == 1)
//        theRect.bottom = Min(theRect.bottom, fSize.v - GetHLineThickness());
//    }
//#endif
    OffsetRect(theRect, fLocation.h, fLocation.v);
    TSubView(fSuperView)->LocalToMainRect(theRect);
  }
}


// ------------------------------------------------------------------------
TSubView _TSubView::SubViewAt(int index)
{
  return(TSubView(fSubViews->At(index)));
}


// ------------------------------------------------------------------------
void _TSubView::AddSubView(TView theSubView)
{
  TViewId viewId;
  int index;

  viewId.tag.fColNum = 0;
  viewId.tag.fSubId = TSubView(theSubView)->fMainView->GetNextViewId();

  theSubView->fIdentifier = viewId.fId;
  _TView::AddSubView(theSubView);

  SubViewExtended(theSubView);       // 16/10/96 [27107]
    
  if (TSubView(theSubView)->fNextView != NULL)
  {
#ifdef TRACE
    Assert(fSubViews->Last() == theSubView, 397);
#endif
    // fSubViews->Delete(fSubViews->Last());
    fSubViews->Delete(theSubView);
    index = fSubViews->GetEqualItemNo(TSubView(theSubView)->fNextView);
    fSubViews->InsertBefore(index, theSubView);
    TSubView(theSubView)->fNextView = NULL;
  }
}


// ------------------------------------------------------------------------
// 12/01/91 moved from TextEdit so can be used by Maths
bool _TSubView::HasCursor(TSubView view, TCursorNode subCursor,
                                 TCursorNode target, TSubView *subView)
{
  return view->ContainsCursor(subCursor, target, *subView);
}


// ------------------------------------------------------------------------
bool _TSubView::ContainsCursor(TCursorNode cursor, TCursorNode target,
                                     TSubView &subView)
{
  bool  ContainsCursor_r = FALSE;
  TCursorNode subCursor;

  subView = NULL;
  if (fStructure == cursor->fCurrency)
  {
    cursor->fIdentifier = fIdentifier;
    subCursor = cursor->GetNext();
    ContainsCursor_r = ((subCursor == 0) ||
      (FirstSubViewThat(this, (TestSubView)_TSubView::HasCursor,
                                         subCursor, target, &subView) != 0));
    if (cursor == target)
      subView = this;
  }
  return(ContainsCursor_r);
}


// ------------------------------------------------------------------------
void _TSubView::SetColNum(short mainId)
{
  PViewId(&fIdentifier)->tag.fColNum = mainId;
}


#ifdef DRAGDROP
// ------------------------------------------------------------------------
static void DoSpritePlot(TObject ignore, int height, Point *pos)
{
  PlotSprite(*pos, height, "ghost");
}

// ------------------------------------------------------------------------
void _TSubView::DrawGhostCaret(TCursorNode cursorNode)
{
  int height;
  Point pos;

  height = GetCaretSize(pos, cursorNode);
#ifdef MATHS
  height = abs(height);  // 18/07/94 abs as maths is -ve
#endif
  NoNH_DoInUpdate(*thePort->GetVisRect(), (DrawProc)DoSpritePlot, height, &pos);
}
#endif

// ------------------------------------------------------------------------
void _TSubView::DoRevealRect(VRect &cursExtent)
// called by text and maths to work out limits of scroll
{
  VRect extent;

  GetExtent(extent);
  SectVRect(cursExtent, extent, cursExtent);
  OffsetRect(extent, -cursExtent.left, -cursExtent.top);  // normalise to cursor topleft
  RevealRect(cursExtent, extent);
}

#ifdef NEVER
// ------------------------------------------------------------------------
void _TSubView::GetCursorExtent(TCursorNode cursor, VRect &cursExtent,
                                                           VRect &extent)
// 20/06/91 now implemented  27/06/91 extents switched
{
  GetExtent(cursExtent);
  LocalToMainRect(cursExtent);
  ClearRect(extent);
}
#endif

// ------------------------------------------------------------------------
void _TSubView::SetSpacing(int spBefore, int spAfter)
{
  spBefore = ZoomInt(spBefore);
  spAfter= ZoomInt(spAfter);

  // 12/11/90 try to get new space invalidated
  if (fSpBefore != spBefore || fSpAfter != spAfter)
  {
    if (!gPrinting)          // 02/09/91
      ForceRedraw();
    fSpBefore = spBefore;
    fSpAfter = spAfter;
  }
}


// ------------------------------------------------------------------------
void _TSubView::GetBorderInfo(Rect &ruleRect, CntlAdornment &borders, TRuleType &ruleType)
{
  TFormat format;
  VRect ruleWidths;
//  unsigned int indent;
//  unsigned int lm;

  format = GetMyFormatReadOnly();
  format->GetBorderInfo(ruleWidths, borders, ruleType);

// 30/06/94 use format->GetLeftLimit()
//  indent = format->GetIndentation();   // 10/12/93 [21145] for maths, indent is -1
//  lm = format->GetLeftMargin();
//  ruleWidths.left = (indent > lm ? lm : indent) - ruleWidths.left;
  ruleWidths.left = format->GetLeftLimit() - ruleWidths.left;
       // [21145] Min(format->GetLeftMargin(), format->GetIndentation()) - ruleWidths.left;
  ruleWidths.right = format->GetRightLimit() - ruleWidths.right;  // 30/06/94 GetRightMargin
  ZoomVRect(ruleWidths);

  for (int *p = ((int *)&ruleWidths) + 3; p >= (int *)&ruleWidths; p--)
    *p = FixRound(*p);
  MoveRect(ruleRect, ruleWidths);
}


// ------------------------------------------------------------------------
void _TSubView::TestNearestToMouse(TSubView view, VPoint *mousePoint,
         VPoint *newMouse, long *deltaMin, TSubView *nearestView)
{
  if (view->IsViewEnabled())        // 11/06/93 [20934] avoid clicking on empty body views
  {
     // 05/03/91 changed
    VRect extent;
    VPoint deltaPt, nearPt;
    long delta;

    view->GetFrame(extent); // 31/07/90 - prev. getextent
    LocalToMainRect(extent);
    nearPt = *mousePoint;
    PinVRect(extent, nearPt);
    deltaPt = nearPt;
    SubVPt(*mousePoint, deltaPt);
    delta = deltaPt.h * deltaPt.h + deltaPt.v * deltaPt.v;
//    delta = abs(deltaPt.h) + abs(deltaPt.v) * 4096;// 14/01/94 [21340] bias to h for tables
    if (delta < *deltaMin)
    {
      *deltaMin = delta;
      *nearestView = view;
      // 4/5/93 pin mouse at bottom right of last subView -- for clicking at end of doc
      // Not too clever when there are footnotes
      if (view == fSubViews->Last() && mousePoint->v > extent.bottom)
      {
        nearPt.h = extent.right;
// 14/01/94 [21340] not needed ?
        nearPt.v = extent.bottom;
      }
      *newMouse = nearPt;
    }
  }
}


// ------------------------------------------------------------------------
void _TSubView::AddChangedExtent(Rect &extent)
{
  if (fUpdateExtent.top > extent.top)
    fUpdateExtent.top = extent.top;
  if (fUpdateExtent.bottom < extent.bottom)
    fUpdateExtent.bottom = extent.bottom;
}


// ------------------------------------------------------------------------
void _TSubView::GetAdornRect(Rect &adornRect)
{
  // 04/05/90 - new mac method
  GetQDExtent(adornRect);

  // 13/10/96 extend borders to top/bottom if joined to frame below/above
  if ((fAdornment & adnTopHidden) == 0)
    adornRect.top += fSpBefore; // 28/05/90
  if ((fAdornment & adnBtmHidden) == 0)
    adornRect.bottom -= fSpAfter; // 28/05/90
}


// ------------------------------------------------------------------------
void _TSubView::DoGetAdornRect(Rect &adornRect)
{
  Rect ruleRect;
  CntlAdornment borders;
  TRuleType ruleType;

  _TSubView::GetAdornRect(adornRect);
  GetBorderInfo(ruleRect, borders, ruleType);
  adornRect.left += ruleRect.left;
  adornRect.right -= ruleRect.right;
}


// ------------------------------------------------------------------------
void _TSubView::DrawChanges(bool invalidate, bool installChanges)
{
  Rect extent;
  Rect QDExtent;
  Rect borders;
  CntlAdornment adornment;
  TRuleType rule;
  bool doBorders = FALSE;

  GetBorderInfo(borders, adornment, rule);
  if (adornment != 0 || fAdornment != 0)
  {
    if (rule.fPen != fRuleType.fPen || rule.fRule != fRuleType.fRule ||
#ifdef FN
        rule.fShort != fRuleType.fShort ||
#endif
                    adornment != fAdornment || !EqualRect(borders, fAdornRect))
    {
      fRuleType = rule;
      fAdornRect = borders;
      fAdornment = adornment;
      doBorders = TRUE;
    }
  }
  if (Focus())
  {
    GetQDExtent(QDExtent);
    fUpdateExtent.left = QDExtent.left;
    fUpdateExtent.right = QDExtent.right;

    MoveRect(extent, fUpdateExtent);
    if (extent.top < extent.bottom)
    {
      if (fSpBefore == extent.top - borders.top)
        extent.top = 0;
      if (fSpAfter == QDExtent.bottom - extent.bottom - borders.bottom)
        extent.bottom = QDExtent.bottom;
      extent.bottom += GetHLineThickness();
          // 07/07/92 redraw pixel immediately below view of last line redrawn

      AddInvalidVRect(extent);
    }
    // 12/11/90 sort out invalidation of borders
    if (doBorders)
      AddInvalidVRect(QDExtent);
  }
  SetSillyRect(fUpdateExtent);  // 29/08/95 [26020] sometimes not 'cleared'
}


// ------------------------------------------------------------------------
bool _TSubView::CanAdornSelf()
// 22/01/91 new proc
{
  return TRUE;
}


// ------------------------------------------------------------------------
void _TSubView::Draw(Rect &area)
{
  SetSillyRect(fUpdateExtent);
}


// ------------------------------------------------------------------------
void _TSubView::DrawAdornment(Rect &area)
// 06/07/92 new to draw borders after the text so not erased by rubout
{
  Rect extent;

  if (fAdornment != 0 &&        // 16/07/93 speed test
      fMainView != NULL && TSubView(fSuperView)->CanAdornSelf())
  {
    GetAdornRect(extent);         // 04/05/90 - new to mac
    DrawBorders(area, extent);
  }
}


// ------------------------------------------------------------------------
void _TSubView::DrawBorders(Rect &area, Rect &itsExtent)
{
  if (fAdornment != 0)
  { 
    // Point penSize;
    Rect clip;
    // Rect extent;

    // MoveRect(extent, itsExtent);

    if (SectRect(itsExtent, area, clip))
    {
      // SetPt(penSize, 1, 1);
      Adorn(itsExtent, fAdornment);
    }
  }
}


// ------------------------------------------------------------------------
bool _TSubView::DoHelp(IDType msgID, EventInfo &info, VPoint &theMouse)
{
  TStructure structure;

#ifdef NETWP
  wr_wimp_msgstr* msg = &info.event->data.msg;
  char *p = msg->data.helpreply.text;

  CmdToName(809, p);   // the text of "Title" menu
  p += strlen(p);
  *(p++) = ':';
  *(p++) = ' ';
  strcpy(p, fDocument->GetNickName());
  return SendHelpReply(msg);
#endif
  // 09/08/90 - new method to get the help messages varying depending on
  // what type of view you are over

  if (fStructure != 0)  // 10/08/90
  {
    structure = GetStructureReadOnly(fStructure);
    msgID = I_('S', 't', '0', '0') + structure->GetKind();
  }

  return _TView::DoHelp(msgID, info, theMouse);
}

// 03/07/91 four envelopes for calling MainView zoom methods
// ------------------------------------------------------------------------
void _TSubView::ZoomPt(Point &itsPoint)
{
  fMainView->ZoomPt(itsPoint);
}


// ------------------------------------------------------------------------
void _TSubView::ZoomRect(Rect &itsRect)
{
  fMainView->ZoomRect(itsRect);
}


// ------------------------------------------------------------------------
int _TSubView::ZoomInt(int itsNum)
{
  return fMainView->ZoomInt(itsNum);
}


// ------------------------------------------------------------------------
Fixed _TSubView::ZoomFixed(Fixed itsNum)
{
  return fMainView->ZoomFixed(itsNum);
}


// ------------------------------------------------------------------------
void _TSubView::InvalBorders(Rect &area, Rect &extent)
{
  // 29/08/90 modified to just return the extent inside the borders, so
  // that DoDraw does not erase the adornment
  Fixed wleft, wright;

  wleft = ZoomFixed(GetBorderWidth(adnLineLeft, fAdornment, fRuleType));
  wright = ZoomFixed(GetBorderWidth(adnLineRight, fAdornment, fRuleType));
 
  extent.top += fSpBefore + fAdornRect.top;
  extent.left += fAdornRect.left + FixRound(wleft);
  extent.bottom = extent.bottom - fSpAfter - fAdornRect.bottom;
  extent.right = extent.right - fAdornRect.right - FixRound(wright);
}


// ------------------------------------------------------------------------
void _TSubView::SetupMenus()
{
  // 25/05/93 [20896] These commands were enabled by UBodyEdit, but did not get picked up
  // if there was no text view on command chain. Now enabled here & may be disabled by body
  for (int cmdNo = cDocTitle; cmdNo <= cChapCount; cmdNo++)
    EnableCmd(cmdNo);
#ifdef FN
  EnableStructCmd(cFootNote, TRUE);
#endif
#if !defined TABLES || defined NETWP
  EnableCmd(cSelectParagraph);  // 18/10/94
#endif
  _TSubView::DoSetupMenus();
}

// ------------------------------------------------------------------------
_TMainView::_TMainView(TDocument itsDoc, TView itsSuper, char* &itsParams)
                    : (itsDoc, itsSuper, itsParams)
{
#ifndef ZERO_OBJ
  TStructTypes index;
#endif
//  int    count;
//  int    strOffset;
//  bool   viewActive;
  FailInfo fi;

  fSlavedIdentifier = kNoIdentifier;
  fZoomFactor = kFix1;
  fShowPictures = TRUE;  // 26/06/90
  fViewsDeleted = TRUE;

#ifndef ZERO_OBJ
  fDependencies = NULL:
  fSlavedSubView = NULL;
  fPages = NULL;
  fCursor = FALSE;
  fLastBlink = 0;
  fFirstPaginated = 0;
  fInteriorSize = gZeroVPt;
  fDrawing = FALSE;
  fSelection = NULL;
  fCurrentStyle = NULL;
  fLeftLimit = 0;
  fRightLimit = 0;
  fOldHeaderMargin = 0;
  fOldFooterMargin = 0;
  fHeaderMaxSize = 0;
  fFooterMaxSize = 0;
  fHeaderSize = 0;
  fFooterSize = 0;

  fFindText[0] = 0;
  fReplaceText[0] = 0;
  fWholeWord = FALSE;
  fCaseSensitive = FALSE;
  fSearchBackwards = FALSE;
  fRedrawHeaderFooter = FALSE;

  for (index = kTextStruct; index <= kMathStyleStruct; index++)
    fFormatHandlers[index] = NULL;
  fHeaderMargin = 0;
  fFooterMargin = 0;
#endif
  fNextViewId = 3;         // 01/02/91

//  sscanf(itsParams, " %d %d %d %n ", &fNextViewId, &fHeaderMargin, &fFooterMargin, &strOffset);
//  OffsetPtr(itsParams, strOffset);

  CatchFailures(&fi);
  fPages = new _TPages(this, 0);
  fDependencies = new _TArray(sizeof(TDependency));
  Success(&fi);
#ifdef VIEWACT
  fViewActive = TRUE;  // 28/05/90
#endif
  SetIdleFreq(0);
  return;
Rescue:
  _TSubView::Free();
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TMainView::Free()
{
  TArray savedDependencies = fDependencies;

  FreeIfObject(fPages);
  FreeIfObject(fCurrentStyle);
  TTextDocument(fDocument)->DeleteMainView(this);
  for (TStructTypes index = kTextStruct; index <= kMathStyleStruct; index++)
  {
    register TRecordHandler aHdlr = fFormatHandlers[index];

    if (aHdlr != NULL)
      TTextDocument(fDocument)->RemoveRecordHandler(aHdlr);
  }
  _TSubView::Free();
  FreeIfObject(savedDependencies);       // 27/06/91
}


// ------------------------------------------------------------------------
void _TMainView::RebuildViews(Fixed savedZoom)
// 18/11/92
{
  SetMagnification(savedZoom);
  gPrinting = FALSE;  // 15/11/92 moved after SetMag to stop picture highlighting
  gApplication->InvalidateFocus();
  fLastBlink = 1;
  DoPagination();  // rebuild views w/o highlight
  fLastBlink = 0;
  TTextDocument(fDocument)->HighlightSelection(HLOn, FALSE);
                            // 15/11/92 restore highlighting after zoom with no redraw
}

// ------------------------------------------------------------------------
bool _TMainView::RegisterDep(TCurrency currency, TSubView view /*, bool viewPos */)
// 27/06/91 new proc
// 22/3/92 made to return bool
{
  int depSize = fDependencies->GetSize();
  bool RegisterDep_r = FALSE; // 22/3/92

  if (view == NULL)
  {
    bool done1 = FALSE;

    for (int index = depSize; index >= 1; index--)
    {
      PDependency entry = PDependency(fDependencies->At(index));

      if (entry->fCurrency == currency)
      {
        done1 = TRUE;
        fDependencies->Delete(index);
      }
    }
    if (done1)
    {
      fLastBlink = 1;        // 22/6/92 prevents MakeSelectedViews highlighting
      DoPagination();        // 03/07/91
      fLastBlink = 0;        // 22/6/92
    }
  }
  else if (currency == 0)
  {
    for (int index = depSize; index >= 1; index--)
    {
      PDependency entry = PDependency(fDependencies->At(index));

      if (entry->fView == view)
      {
        fDependencies->Delete(index);
        RegisterDep_r = TRUE; // 22/3/92
        break;       // 02/07/91 put inside the block
      }
    }
  }
  else
  {
    TDependency newDep;

    for (int index = 1; index <= depSize; index++)
    {
      PDependency entry = PDependency(fDependencies->At(index));

      if (entry->fView == view && entry->fCurrency == currency)
        return RegisterDep_r;  // 21/04/92
    }
    newDep.fView = view;
    newDep.fCurrency = currency;
// 17/09/92    newDep.fViewPos = viewPos;                  // 04/03/92
    fDependencies->InsertFirst(&newDep);
  }
  return RegisterDep_r;    // 21/04/92
}

// ------------------------------------------------------------------------
void _TMainView::NotifyDep(TCurrency currency, TSubView view)
// 27/06/91 new proc
{
  // 03/03/92 need to refind since the DoIdle can delete the view entry!
  for (bool firstTime = TRUE; firstTime >= 0; firstTime--)
  {
    PDependency entry = PDependency(fDependencies->fPtrToArray);

    for (int index = 1; index <= fDependencies->GetSize(); index++, entry++)
    {
      if (entry->fView != view && entry->fCurrency == currency)
      {
        if (firstTime)              // 03/03/92
          fPages->DoIdle();         // 18/02/92 for pics wrapping back fast
        else
          entry->fView->DrawChanges(TRUE, TRUE);
          // 18/02/92      noneFound = FALSE;
      }
    }
  }
}

// ------------------------------------------------------------------------
// 17/09/92 new
int _TMainView::FirstRegisteredPage(TCurrency currency)
{
  int pageNum = MAXLONGINT;
  int depSize = fDependencies->GetSize();
  PDependency entry = PDependency(fDependencies->fPtrToArray);

  for (int index = 1; index <= depSize; index++, entry++)
  {
    if (entry->fCurrency == currency)
    {
      TSubView view = entry->fView;
      TViewId id;

      while (view->fSuperView != this)
        view = TSubView(view->fSuperView);
      id.fNumId = view->fIdentifier;
      pageNum = Min(pageNum, id.tag.fColNum);
    }
  }
  return pageNum;
}

// ------------------------------------------------------------------------
// 18/02/92 new
int _TMainView::IsRegistered(TCurrency currency)
{
  int depSize = fDependencies->GetSize();
  PDependency entry = PDependency(fDependencies->fPtrToArray);

  for (int index = 1; index <= depSize; index++, entry++)
  {
    if (entry->fCurrency == currency)
      return index;
  }
  return 0;
}


// ------------------------------------------------------------------------
// 29/01/93 for [20604] - commonly used sequence of calls
bool _TMainView::GetVisiblePageRange(int &startPage, int &endPage)
{
  bool GetVisiblePageRange_r = Focus();
  Rect qdr;

  if (GetVisiblePageRange_r)
  {
    GetQDExtent(qdr);
    VisibleRect(qdr);
    GetPageRange(qdr, startPage, endPage);
  }
  return GetVisiblePageRange_r;
}


// ------------------------------------------------------------------------
// search through all the styles in the main view, returning them to the Document

void _TMainView::GetStyleFontNameAndNumber(TRecordIndex recNum, TRecordHandler handler)
{
  TStyleFormat style = TStyleFormat(handler->GetRecordObject(recNum, kReadOnly));
  if (style->fDefined & kFont)
    TTextDocument(fDocument)->AddStyleFontToTable(style->fFontName, style->fTextFont);
  if (style->fDefined & kBullet)
    TTextDocument(fDocument)->AddStyleFontToTable(style->fBulletFontName, style->fBulletFont);
}


// ------------------------------------------------------------------------
void _TMainView::ForEachHandlerGetStyle()
{
  TRecordHandler nextHandler;

  // 27/03/91 from kTextStyleStruct not kStyleStruct
  for (int index = kTextStyleStruct; index <= kMathStyleStruct; index++)
  {
    nextHandler = fFormatHandlers[index];
    if (nextHandler != NULL)
      nextHandler->ForAllRecordsDo(this, (DoToRecord)_TMainView::GetStyleFontNameAndNumber);
  }
}


// ------------------------------------------------------------------------
void _TMainView::TrackingMouse()
{
  fPages->Reset(TRUE, NULL);          // 18/04/91 & 14/05/94 added params
}


// ------------------------------------------------------------------------
void _TMainView::MakeSelectedViews(TCursorNode anchor, TCursorNode activeEnd)
{
  fPages->MakeSelectedViews(anchor, activeEnd);
}


// ------------------------------------------------------------------------
void _TMainView::MakeViewsForPages(int startPage, int endPage)
{
  int pageNum;
  int numPages;
  TSelection selection;
  FailInfo fi;

  if (!fDrawing)
  {
// 26/05/92    bool needsViews = FALSE;

    fDrawing = TRUE;
    CatchFailures(&fi);
    fPages->PaginateTo(endPage);
    fDrawing = FALSE;
    Success(&fi); // 26/07/90
    numPages = GetPageMax();
    if (endPage > numPages)
      endPage = numPages;     // 21/10/91 avoid endPage too large
    if (numPages < endPage)
    {
      numPages = endPage - numPages;
      endPage = endPage - numPages;
      startPage = startPage - numPages;
    }
    for (pageNum = startPage; pageNum <= endPage; pageNum++)
    {
// 26/05/92      if (!PPageInfo(fPages->At(pageNum))->fHasView)
// 26/05/92        needsViews = TRUE;
      fPages->MakeView(pageNum, FALSE);  // 08/04/92
    }

    selection = TTextDocument(fDocument)->GetNewSelection();

//    if (selection->fReformatType != kReformatAll)
          // 21/04/92 stop highlighting all on page interior change size
      // 02/07/91 optimise if PaginateTo has done the work
      // 26/05/92 not making a view in HandleAPage means needsViews gets set
      // to TRUE and crashes on Undo paste > 3 pages worth
      if (/* needsViews || */ fLastBlink == 0 && fViewActive && !gPrinting)
                                   // 22/11/90 use fLastBlink as flag
        selection->Highlight(this, TRUE);
                                     // 12/11/90 2nd param: FALSE -> TRUE
                                     // for ScrollSelection problems

    if (fViewsDeleted && !gPrinting && GetWindow() != NULL) // 18/11/92 && !gPrinting
    {
      fViewsDeleted = FALSE;
      selection->DoSetupMenus(TRUE);
                     // 02/05/91 added to get init ruler set for columns
      TTextDocument(fDocument)->SetCurrentStyle();  // 02/05/91 moved down
      TTextDocument(fDocument)->SetTextHandler();   // 04/07/91 ditto for EndStruct on save
    }
    Focus();
  }
  return;

// ++++++++++++++++++++++++
Rescue:
  fDrawing = FALSE;
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
static void DoClear(TObject null, TSubView view, bool redraw)
{
  view->SetHighlight(TCursorNode(-1), NULL, redraw, FALSE); // fn1
}

void _TMainView::ClearHighlighting(bool redraw)
{
  if (!fCursor)
    EachSubview(NULL, (DoToSubView)DoClear, redraw);
}


// ------------------------------------------------------------------------
void _TMainView::HighlightSelection(TCursorNode anchor, TCursorNode activeEnd, bool redraw)
{
  // 17/09/90 do not bother if there no H/Fs on page
  TViewId viewId = anchor->fCursor->fSelection->fViewId;

  if (viewId.tag.fSubId == 0 || FindSubView(viewId.fId) != NULL)
    fPages->HighlightSelection(anchor, activeEnd, redraw);
}


// ------------------------------------------------------------------------
void _TMainView::AddFormatHandler(TStructTypes itsType, TRecordHandler itsHandler)
{
  fFormatHandlers[itsType] = itsHandler;
}


// ------------------------------------------------------------------------
TRulerDef _TMainView::GetCurrentStyle(Fixed *limits)
// 19/01/94 new interface
{
  if (limits != NULL)
  {
    *(limits++) = fLeftLimit;
    *(limits++) = fRightLimit;
    *limits = fTextDirection;
  }
  return fCurrentStyle;
}


// ------------------------------------------------------------------------
void _TMainView::SetCurrentStyle(TStyleFormat theStyle, Fixed leftLimit, Fixed rightLimit,
                                 int textDirection)
{
  fLeftLimit = leftLimit;
  fRightLimit = rightLimit;
  fTextDirection = textDirection;   // 04/07/94 for backwards text
  ReplaceObject(fCurrentStyle, theStyle);
  // FreeIfObject(fCurrentStyle);
  // fCurrentStyle = theStyle;
}


// ------------------------------------------------------------------------
int _TMainView::GetNextViewId()
{
  int  GetNextViewId_r = fNextViewId;

  fNextViewId = (fNextViewId >= MAXINT ? 2 : fNextViewId) + 1; // 21/04/92 >= for corrupt docs
  return GetNextViewId_r;
}


// ------------------------------------------------------------------------
void _TMainView::SetTheCursor(bool on)
{
  fCursor = on;
}

// ------------------------------------------------------------------------
void _TMainView::RedrawHeaderFooter(int setting)
{
  fRedrawHeaderFooter = setting;
}

// ------------------------------------------------------------------------
bool _TMainView::DoIdle(IdlePhase phase)
{
  SetIdleFreq(0);         // 21/03/96 call me again soon please (unless changed)

  if (phase != idleEnd)
  {
    FailInfo fi;

    CatchFailures(&fi);
    if (phase == idleBegin)
    {
      WindowRecord *wdw = &GetWindow()->fWindowRecord;

      if (wdw->HasInputFocus())
      {
        if (fCursor)
          wdw->SetCaret();
        else
          wdw->LocateCaret(gZeroPt, 0);
      }
#ifdef MATHS
      if (TTextDocument(fDocument)->fAlignList != NULL)
        TTextDocument(fDocument)->fAlignList->DrawChanges();  // 24/03/92
#endif
    }
    else  // 09/07/91 in case of failure last time, to avoid going straight back in
    {
      if (fRedrawHeaderFooter)       // 17/09/90 new clause
      {
        Reformat(TTextDocument(fDocument)->GetNewSelection(), NULL, TCursorNode(-1));
        fRedrawHeaderFooter = FALSE;
      }
      fPages->DoIdle();
    }
    Success(&fi);
Rescue:
    MarkDamagedDoc(&fi, fDocument);  // 22/02/94 with CatchFailures to pick up Assertions
  }
  return _TSubView::DoIdle(phase);
}


// ------------------------------------------------------------------------
void _TMainView::GetPageInfo(TPageData *pageInfo)
// 17/09/90 new method
{
  memcpy(pageInfo, &fPageInfo, sizeof(TPageData));
}


// ------------------------------------------------------------------------
int _TMainView::GetPageMax()
{
  return Max(1, fPages->fPageCount);
             // 17/07/90 - force a page on initialisation
}


// ------------------------------------------------------------------------
void _TMainView::ClearViewSlave()
{
  fSlavedIdentifier = kNoIdentifier;
  fSlavedSubView = NULL;
// 28/01/91  fPages->Reset();
}


// ------------------------------------------------------------------------
static bool HasGotTheCursor(TObject null, TSubView view, TCursorNode cursor,
                      TCursorNode aCursorNode, TSubView* theSubView)
{
  TViewId pageID;

  pageID.fId = aCursorNode->fIdentifier;
  if (pageID.tag.fSubId == 0 ||
           pageID.tag.fColNum == PViewId(&view->fIdentifier)->tag.fColNum)
    return(view->ContainsCursor(aCursorNode, cursor, *theSubView));
  return FALSE;
}

// ------------------------------------------------------------------------
TSubView _TMainView::FindCursorView(TCursorNode cursor)
{
  TSubView aSubView;
  TSubView theSubView;
  IDType identifier;
  TCursorNode aCursorNode;

  identifier = cursor->fIdentifier;

//  if ((fSlavedIdentifier == identifier) && (identifier != kNoIdentifier))
//  {
//    if (fSlavedSubView != NULL &&
//     (!fSlavedSubView->ContainsCursor(cursor, cursor, theSubView)
//                                       || fSlavedSubView != theSubView))
//      fSlavedIdentifier = kNoIdentifier;
//  }

//  if (fSlavedIdentifier != identifier)
  // 17/02/94 test rewritten - forces search if identifier == kNoIdentifier
  if (identifier == kNoIdentifier ||
     identifier != fSlavedIdentifier ||
     fSlavedSubView == NULL ||
     !fSlavedSubView->ContainsCursor(cursor, cursor, theSubView) ||
     fSlavedSubView != theSubView)
  {
    aCursorNode = TCursorNode(cursor->fCursor->First());
    theSubView = NULL;
    aSubView = TSubView(FirstSubViewThat(NULL, (TestSubView)HasGotTheCursor,
                      cursor, aCursorNode, &theSubView));
    fSlavedSubView = theSubView;
    if (theSubView != NULL)
      fSlavedIdentifier = theSubView->fIdentifier;
    else
      ClearViewSlave();
  }
  return fSlavedSubView;
}


// ------------------------------------------------------------------------
//static void ActivateTheSubView(TObject null, TView theSubView, bool entering)
//{
//  theSubView->Activate(entering);
//}

// ------------------------------------------------------------------------
//void _TMainView::Activate(bool entering)
//{
//  if (entering)
//  {
//    fHLDesired = HLOn;
//#ifdef VIEWACT
//    fViewActive = TRUE;
//#endif
//    TTextDocument(fDocument)->ActivateMainView(this);
//  }
//  else
//  {
//    if (fCursor && DoIdle(idleEnd))
//      fHLDesired = HLDim;
//  }

//  EachSubview(NULL, (DoToSubView)ActivateTheSubView, entering);
//#ifdef VIEWACT
//  if (!entering)
//    fViewActive = FALSE;
//#endif
//}


// ------------------------------------------------------------------------
TStyleFormat _TMainView::GetStyleReadOnly(TCurrency currency)
{
  return TStyleFormat(GetFormatReadOnly(currency));
}


// ------------------------------------------------------------------------
TStyleFormat _TMainView::GetStyleReadWrite(TCurrency currency)
{
  return TStyleFormat(GetFormatReadWrite(currency));
}


// ------------------------------------------------------------------------
TStyleFormat _TMainView::GetStyle(TCurrency currency, bool readOnly)
{
  return TStyleFormat(GetFormat(currency, readOnly));
}


// ------------------------------------------------------------------------
TFormat _TMainView::GetFormatReadWrite(TCurrency currency)
{
  return GetFormat(currency, kReadWrite);
}


// ------------------------------------------------------------------------
TFormat _TMainView::GetFormatReadOnly(TCurrency currency)
{
  return GetFormat(currency, kReadOnly);
}


// ------------------------------------------------------------------------
bool _TMainView::LockCurrency(TCurrency currency, bool state)
{
  TRecordHandler recHandler = fFormatHandlers[Curr_fType(currency)];

  return recHandler->SetRecordLock(Curr_fRecnum(currency), state);
}


// ------------------------------------------------------------------------
TFormat _TMainView::GetFormat(TCurrency currency, bool readOnly)
{
  TRecordHandler formats;

  formats = fFormatHandlers[Curr_fType(currency)];
  return TFormat(formats->GetRecordObject(Curr_fRecnum(currency), readOnly));
}


// ------------------------------------------------------------------------
void _TMainView::NewStyle(TCurrency currency, char* &itsResource)
{
  TStyleFormat theStyle;

  theStyle = GetStyleReadWrite(currency);
  theStyle->IRes(itsResource);

  // 14/11/91 get changes to resource bullet font noted
  if (theStyle->fFontName[0] != 0)
    theStyle->fTextFont = 
       TTextDocument(fDocument)->GetFNum(theStyle->fFontName);
  if (theStyle->fBulletFontName[0] != 0)
    theStyle->fBulletFont = 
       TTextDocument(fDocument)->GetFNum(theStyle->fBulletFontName);
}


// ------------------------------------------------------------------------
TObject _TMainView::GetPrototype(TStructTypes itsType)
{
  TRecordHandler formats;

#ifdef TRACE
  Assert(itsType <= kMathStyleStruct, 709);
#endif
  formats = fFormatHandlers[itsType];
  return formats->GetPrototype();
}

// ------------------------------------------------------------------------
static bool HasNoPartStyles(TStyleStructure styleStruct)
{
   // 11/05/94 [21803] reject match if has (non-empty) part styles

   for (int index = 1; index <= styleStruct->fSize; index++)
     if (PPartStyles(styleStruct->At(index))->fStyle != 0)
       return FALSE;
  return TRUE;
}

// ------------------------------------------------------------------------
static void CompareStyle(TTextDocument doc, int index, TRecordHandler styles,
      TStructTypes itsType, TStyleFormat theStyle, TCurrency* currency)
{
  // 28/01/94 [21369] itsType -ve: do not find named styles in non-emphasis InstalStyleChange
  TStyleFormat styleFormat = TStyleFormat(styles->GetRecordObject(index, kReadOnly));

  if (styleFormat->Match(theStyle) &&  // 11/05/94 [21803] reject match if has part styles
       HasNoPartStyles(TStyleStructure(styles->fMaster->GetRecordObject(index, kReadOnly))))
  {
    *currency = Curr_Set(index, itsType < 0 ? itsType + 100 : itsType);
    // currency->fValue = (itsType < 0 ? itsType + 100 : itsType) | (index << 16);
    // 04/02/91 pick a named style if possible ... 28/01/94 unless called from FindAnonStyle
    if ((itsType < 0) == (doc->GetStyleReadOnly(*currency)->fStylename[0] == 0))
      FailNoFail();   // jump out of loop having found what we are looking for
  }
}

// ------------------------------------------------------------------------
int _TMainView::FindAnonStyle(TStyleFormat theStyle, TStructTypes itsType, TCurrency &curr)
{
  // 28/01/94 returns 1 if an unnamed match found, else 0 (currency will be last named or 0)

  return FindStyle(theStyle, itsType - 100, curr);
}

// ------------------------------------------------------------------------
int _TMainView::FindStyle(TStyleFormat theStyle, TStructTypes itsType, TCurrency &currency)
{
  // itsType >= 0: returns 1 if named style found, 0 if unnamed or no style found
  // itsType < 0: returns 1 if an unnamed match found, 0 otherwise

  TRecordHandler styles;
  FailInfo  fi;

  CatchFailures(&fi);
  currency = 0;
  styles = fFormatHandlers[itsType < 0 ? itsType + 100 : itsType];
  styles->ForAllRecordsDo(fDocument, (DoToRecord)CompareStyle, itsType, theStyle, &currency);
  Success(&fi);
  return 0;

Rescue:
//  if (fi.error != 0)
//    ContinueFailure(&fi);   // a real failure
  ContinueIfFail(&fi);   // pass on a real failure
  return 1;
}


// ------------------------------------------------------------------------
void _TMainView::SetStyle(TCurrency currency, TStyleFormat aStyle)
{
  TRecordHandler styles;
  styles = fFormatHandlers[Curr_fType(currency)];
  styles->ReplaceRecordObject(Curr_fRecnum(currency), aStyle);
}


// ------------------------------------------------------------------------
void _TMainView::DeleteSubViews()
{
  TTextDocument(fDocument)->UnsetTextHandler();
  fPages->DeletePageViews();
  fPages->Reset(FALSE, NULL);            // 18/04/91 & 14/05/91 added params
  fViewsDeleted = TRUE;
}


// ------------------------------------------------------------------------
void _TMainView::SetMagnification(Fixed factor)
{
  if (factor != fZoomFactor)
  {
    ClearHighlighting(FALSE);
    fZoomFactor = factor;
#ifndef TABLES
    fDocument->InstallTitleInWindows(); // 15/04/93 [20833]
#endif
    DeleteSubViews();
  }
}


// ------------------------------------------------------------------------
void _TMainView::ZoomPt(Point &itsPoint)
{
  if (fZoomFactor != kFix1)
  { 
    itsPoint.h = FixMul(itsPoint.h , fZoomFactor);
    itsPoint.v = FixMul(itsPoint.v , fZoomFactor);
  }
}


// ------------------------------------------------------------------------
void _TMainView::ZoomRect(Rect &itsRect)
{
  if (fZoomFactor != kFix1)
  { 
    itsRect.top = FixMul(itsRect.top , fZoomFactor);
    itsRect.left = FixMul(itsRect.left , fZoomFactor);
    itsRect.bottom = FixMul(itsRect.bottom , fZoomFactor);
    itsRect.right = FixMul(itsRect.right , fZoomFactor);
  }
}


// ------------------------------------------------------------------------
int _TMainView::ZoomInt(int itsNum)
{
  return (fZoomFactor == kFix1 ? itsNum : FixMul(itsNum, fZoomFactor));
}


// ------------------------------------------------------------------------
Fixed _TMainView::ZoomFixed(Fixed itsNum)
{
//  return FixMul(itsNum, fZoomFactor);
  return ZoomInt(itsNum);
}


// 07/07/94 redone with located view doing the Connect and scroll, avoiding
// the problem of text having to estimate where the caret is going to end up!
// ------------------------------------------------------------------------
void _TMainView::ScrollSelectionIntoView(TSelection selection)
{
  if (Focus())
  {
    TSubView view;
    TCursorNode owner = selection->GetAnchorOwner();

    // 17/04/94 remove test which relies on state of fSlavedSubView, since if it
    // is null and selection->fViewId is not set up, MakeSelectedViews is liable
    // to crash, almost certainly if the anchor is in a header or footer
    view = FindCursorView(owner);
    if (view == NULL)      /* 17/04/94 fSlavedSubView == NULL || */ 
    {
      MakeSelectedViews(selection->GetAnchorRoot(), selection->GetActiveRoot());
      if (selection->fViewId.tag.fSubId == 0 || FindSubView(selection->fViewId.fId) != NULL)
      {
        view = FindCursorView(owner);
#ifdef TRACE
        Assert(view, 67);
#endif
      }
    }
    else
      fPages->Reset(TRUE, selection);              // 14/05/91 else added
    if (view)
      view->ScrollCursorIntoView(owner);
  }
  TTextDocument(fDocument)->SetTextHandler();
}

// ************************ Header and Footer Reformatting ******************************
//
// Firstly the following are the things that cause changes to the headers and footers
// and how they informed and end up calling Reformat (and then ReformatHeaderFooter).
// a) Fast path typing in the header/footer. DoType calls SetPageInfo which sets
//    fRedrawHeaderFooter to header/footer as appropriate. All the views for the h/f are
//    redrawn in Idle. (We now stop DrawChanges clearing change flags until finished).
// b) Other reformats in a Header or Footer call MainView::Reformat. All the h/fs with
//    views are reformatted and redrawn. (see below)
// c) Typing in a document or chapter heading. This is now forced down the slow path in
//    Body::CanTypeFast, gets trapped by DoReformatSel and sets fRedrawHeaderFooter to
//    do both headers and footers in idle.
// d) Changing document or chapter start page number. Also sets fRedrawHeaderFooter to
//    do both headers and footers in idle.
// e) Change which causes pagination, possibility of adding another page, moving heading
//    to next page, etc. This also sets fRedrawHeaderFooter to do both head and footers.
// f) H/f margins reset (without changing the main body size, which will be case (e)).
//    This also sets fRedrawHeaderFooter to do both head and footers.
//
// All except (b) set fRedrawHeaderFooter. This causes MainView::Reformat to be called
// with activeEnd set to -1 indicating fRedrawHeaderFooter contains which to reformat,
// otherwise, ie. when MainView::Reformat is called directly in case (b), the selection
// indicates which of header or footer needs doing. MainView::Reformat, which sets flags
// in fPages indicating that the header and/or footer needs Refitting, initialises page
// start to 1 and zeroises the current depth counts to zero. All the h/fs which have
// views are reformatted, their depth calculated with Fit, and the views updated.
// In subsequent idles, pagination is completed and spare page views may be built. When
// the headers and footers for these pages are created, we call DoReformat rather than
// Reformat to avoid clearing the current h/f depths for the existing views. Finally we
// now include an extra task at the end of idle which calls ReformatHeaderFooter for
// each of the pages which does NOT have a view. This passes a subview parameter of -1
// indicating we do not want to create or update views, just reformat and compute the
// depth of the h/fs. Finally the maximum depth fields are updated, so we can detect if
// a h/f depth has shrunk below the specified margin - to give a warning if it again
// exceeds the margin.
// **************************************************************************************

// ------------------------------------------------------------------------
static void HFNote(TObject null, TCurrency note, TCurrency ref, // 11/5/93
        /* fn1 TNoteType noteType, */
                        PStdNoteVars v)
{}

static void HFNotifyHeading(TObject null, TCurrency itsHeading,
                        TStyleTypes itsType, int startPage,
                        bool useRomanNumbers, PStdFitNoteVars v)
{}

static void HFFitNote(TObject null, TCurrency note, bool &allFits, /* fn1 */
                        /* fn1 TNoteType noteType, */
                        int &noteSpaceAvailable, PStdFitNoteVars v)
{}

// ------------------------------------------------------------------------
void _TMainView::SetPageInfo(TSelection selection)
{
  // called when about to type in fast path
  if (selection->fViewId.tag.fSubId != 0)  {
    RedrawHeaderFooter(selection->fViewId.tag.fSubId); // [26020] only reformat the changed h or f
    // fRedrawHeaderFooter = TRUE;
    fPageInfo.pageNum = selection->fViewId.tag.fColNum;
    fPages->GetPageInfo(&fPageInfo);
    TSubView(TTextDocument(fDocument)->fTextHandler->fNextHandler)->SetupMacros();
  }
}

#ifdef TRUE
#define HF(a) ((int *)&a)[hfIdx]
// [26020] rewritten (may be called when no view, to check h/f depth)
// ------------------------------------------------------------------------
int _TMainView::ReformatHeaderFooter(TCursorNode anchor, TCursorNode activeEnd,
                                           TSubView pageView, TViewId viewId, TSubView bodyView)
{
  int ReformatHeaderFooter_r;
  int pn = viewId.tag.fColNum;                       // current page number
  int hfIdx = viewId.tag.fSubId - 1;
  TTextDocument document = TTextDocument(fDocument);
  Fixed hf;
  TCurrency body;
  TCurrency currencyL;
  TFormat bodyFmt;
  bool canShow;
  VRect pageInterior;

  fPageInfo.pageNum = pn;
  fPages->GetPageInfo(&fPageInfo);
  if (document->GetHeaderFooter(viewId.tag.fSubId == 1, currencyL, body) && !Odd(pn))
    body = currencyL;  // 22/06/95 add check for different before accessing left currency
  bodyFmt = GetFormatReadWrite(body);
  switch (bodyFmt->GetHFVisibility(body))
  {
  case kHFAllPages:
    canShow = TRUE;
    break;
  case kHFAllBut1stPage:
    canShow = (pn > 1);
    break;
  case kHFAllChap:
    canShow = (fPageInfo.pageType != kDocPage);
    break;
  case kHFAllBut1stChap:
    canShow = (fPageInfo.pageType != kChapTitlePage);  // 24/04/92
    break;
  default:
    canShow = (fPageInfo.pageType == kChapTitlePage);  //  case kHF1stChap:
  }

  GetPageInterior(pn, pageInterior);
  hf = FixRound(ZoomFixed(HF(fHeaderMargin)));
  if (hfIdx == 0)
    pageInterior.bottom = pageInterior.top + hf;
  else
    pageInterior.top = pageInterior.bottom - hf;

  ReformatHeaderFooter_r = 0;     // no change in subview indexing (unless overwritten below)
  if (canShow)
  {
    TObject breakObj = NULL;
    TStdNoteVars vRef;

    vRef.obj = this;
    vRef.procToDo = (DoNote)HFNote;
    bodyFmt->Reformat(body, anchor, activeEnd, FixRound(fInteriorSize.h * 10), -1, &vRef);
    {
      int totalSpace = FixRound(HF(fHeaderMargin));
      int space;

      do
      {
        int gaps = 0;   // 21/12/93 [21204]
        int dummy = 0;  // 21/05/93 [20890]
        bool dummyB = FALSE;
        TStdFitNoteVars vFit;

        space = totalSpace;
        ClearObject(breakObj);
        vFit.obj = this;
        vFit.procForHeading = (DoNotifyHeading)HFNotifyHeading;
        vFit.procToDo = (DoFitNote)HFFitNote;
        bodyFmt->Fit(pn, body, space, dummy, space, breakObj, gaps, dummyB, &vFit, &vFit);
        space = (space == 0 ? HF(fHeaderMargin) : ToFixed(totalSpace - space));
                                   // 10/11/95 avoid fixed rounding error when fits first time
        totalSpace = MAXLONGINT;   // 12/08/93 [21023] MAXINT could be too small?
                                 // ... and need to test this case explicitly in Body::Fit
      }
      while (breakObj != NULL);

      if (HF(fHeaderSize) < space)
        HF(fHeaderSize) = space;
      if (HF(fHeaderMaxSize) <= HF(fHeaderMargin) && space > HF(fHeaderMargin))
      {
        HF(fHeaderMaxSize) = space;  // stop another alert until fHFMaxSize set below fHFMargin
#ifndef NETWP
        // 29/08/96 [27051] suppress message (as nothing can be done on NC WP)
        if (!gPrinting)
          Alert(phHeaderMarginsTooSmall + hfIdx, wr_wimp_EOK | 16 | 0x300);
#endif
      }
    }
    if (pageView == NULL)
    {
      // [26020] insert before main body view. Avoid problem of header redraw rect encroaching
      // into body view, main view being drawn first in Update, and validating the area above
      // so the header that is being typed into is not drawn at all
      pageView = bodyFmt->MakeView(body, viewId, 0, this, hfIdx == 0 ? bodyView : NULL,
                          *pageInterior.topLeft, NULL, breakObj);
      if (pageView != NULL) // 13/01/94 [21338] may be NULL if just hidden
      {
        if (!gPrinting)
          pageView->ForceRedraw();       // 08/11/93 [21107] ensure redrawn
        ReformatHeaderFooter_r = 1 - hfIdx;  // +1 for header being inserted before body view
      }
    }
    else if (pageView != TSubView(-1))   // -1 means we are just fitting, not making views
    {  
      bodyFmt->UpdateView(body, pageView, *pageInterior.topLeft, 0,
                              NULL, NULL, TRUE, TRUE);
      if (!gPrinting)                    // 01/05/92 can crash doing invalidate in printing
        pageView->DrawChanges(activeEnd == NULL ? 2 + (anchor == NULL) : TRUE, FALSE);
                       // [26020] pass different values for text drawing/flag clearing
      // [26020] do not clear flags yet: bodyFmt->ClearChangedFlags(body, TRUE); // 11/02/92
    }
  }
  else
  {
    if (!gPrinting)                    // 06/07/95 can crash doing invalidate in printing
      InvalidVRect(pageInterior);
    if (pageView != TSubView(-1))      // -1 means we are just fitting, not making views
    {
      if (pageView != NULL)
        ReformatHeaderFooter_r = hfIdx - 1;  // -1 if header, causing view before current to go
      FreeIfObject(pageView);          // 29/4/92
    }
  }
  if (anchor != NULL)  // 17/02/94 [21399] not yet set for D&D: && fPages->fAnchorPage == pn
    document->SetTextHandler();
  return ReformatHeaderFooter_r;  // 07/09/95 return number of views created/destroyed
}

#else
// ------------------------------------------------------------------------
void _TMainView::ReformatHeaderFooter(TCursorNode anchor,
  TCursorNode activeEnd, TSubView pageView, TViewId viewId)
// 17/09/90 new method
{
  TCurrency body;
  TFormat bodyFmt;
  TChangeTypes result;
  TObject breakObj;
  int space;
  TTextDocument document;
  VRect pageInterior;
  Fixed hf;
  THFVisibility visibility;
  TCurrency currencyL;
  TPageData pageInfo;
  VPoint pageSize;
  int pn;
  bool canShow;
  
  GetPageSize(pageSize);
  pn = viewId.tag.fColNum;
  GetPageInterior(pn, pageInterior);
  document = TTextDocument(fDocument);
  if (document->GetHeaderFooter(viewId.tag.fSubId == 1, currencyL, body) && !Odd(pn))
    body = currencyL;  // 22/06/95 add check for different before accessing left currency
#ifdef TRACE
  currencyL = (Odd(pn) || !((bool *)&document->fLeftRightFtr)[viewId.tag.fSubId == 1] ?
   (viewId.tag.fSubId == 1 ? document->fRightHeader : document->fRightFooter) :
   (viewId.tag.fSubId == 1 ? document->fLeftHeader : document->fLeftFooter));
  Assert(body == currencyL, 951);  // check the old way (with || mod) gives same result
#endif
  bodyFmt = GetFormatReadWrite(body);
  visibility = bodyFmt->GetHFVisibility(body);
  pageInfo.pageNum = pn;
  fPages->GetPageInfo(&pageInfo);
  fPageInfo = pageInfo;
  switch (visibility)
  {
  case kHFAllPages:
    canShow = TRUE;
    break;
  case kHFAllBut1stPage:
    canShow = (pn > 1);
    break;
  case kHFAllChap:
    canShow = (pageInfo.pageType != kDocPage);
    break;
  case kHFAllBut1stChap:
    canShow = (pageInfo.pageType != kChapTitlePage);  // 24/04/92
    break;
//  case kHF1stChap:
  default:
    canShow = (pageInfo.pageType == kChapTitlePage);
  }
  if (viewId.tag.fSubId == 1)
  {
// 14/12/92    msg = kHeaderMarginsTooSmall;
    hf = fHeaderMargin;
  }
  else
  {
// 14/12/92    msg = kFooterMarginsTooSmall;
    hf = fFooterMargin;
  }
  space = FixRound(hf);
  hf = ZoomFixed(hf);
  if (viewId.tag.fSubId == 2)
    pageInterior.top = pageInterior.bottom - FixRound(hf);
  if (canShow)
  {
    TStdNoteVars vRef;
    // VPoint vSlop;

    // vSlop.v = 0;
    // vSlop.h = 0;
    vRef.obj = this;
    vRef.procToDo = (DoNote)HFNote;
#ifdef TRACE
    if (pageSize.h != fInteriorSize.h / 100)  // FixRound(fInteriorSize.h * 10))
      SysBeep(0);
#endif
    result = bodyFmt->Reformat(body, anchor, activeEnd, pageSize.h, -1, &vRef);
    breakObj = NULL;
    {
      TStdFitNoteVars vFit;
      int gaps = 0;   // 21/12/93 [21204]
      int dummy = 0;  // 21/05/93 [20890]
      bool dummyB; /* fn1 */

      vFit.obj = this;
      vFit.procForHeading = (DoNotifyHeading)HFNotifyHeading;
      vFit.procToDo = (DoFitNote)HFFitNote;
      /* fn1 new params */
      dummyB = 0;        // 06/06/93 [20918]
      bodyFmt->Fit(pn, body, space, dummy, space, breakObj, gaps, dummyB, &vFit, &vFit);
      if (breakObj != NULL)
      {
        space = MAXLONGINT;       // 12/08/93 [21023] MAXINT could be too small?
                                  // ... and need to test this case explicitly in Body::Fit
        ClearObject(breakObj);
        // FreeIfObject(breakObj);   // 19/11/92 leaving handles
        // breakObj = NULL;
        /* fn1 new params */
        gaps = 0;     // 21/12/93 [21204]
        dummy = 0;    // 21/05/93 [20890]
        dummyB = 0;        // 06/06/93 [20918]
        bodyFmt->Fit(pn, body, space, dummy, space, breakObj, gaps, dummyB, &vFit, &vFit);
      }
    }
    if (pageView == NULL)
    {
      pageView = bodyFmt->MakeView(body, viewId, /* 0, vSlop */ 0, this, NULL,
                          *pageInterior.topLeft, NULL, breakObj);
      if (!gPrinting && pageView != NULL) // 13/01/94 [21338] may be NULL if just hidden
        pageView->ForceRedraw();          // 08/11/93 [21107] ensure redrawn
    }
    else  
    {  
      bodyFmt->UpdateView(body, pageView, *pageInterior.topLeft, 0,   // vSlop,
                              NULL, NULL, TRUE, TRUE);
      if (!gPrinting)                    // 01/05/92 can crash doing invalidate in printing
        pageView->DrawChanges(TRUE, FALSE);
      bodyFmt->ClearChangedFlags(body, TRUE);  // 11/02/92 stop flashing page after height change
    }
  }
  else
  {
    if (viewId.tag.fSubId == 1)
      pageInterior.bottom = pageInterior.top + FixRound(hf);
    if (!gPrinting)                    // 06/07/95 can crash doing invalidate in printing
      InvalidVRect(pageInterior);
    FreeIfObject(pageView); // 29/4/92
  }
  if (anchor != NULL)  // 05/09/91 anchor test
     // 17/02/94 [21399] for D&D anchor page is not yet set: && fPages->fAnchorPage == pn
    TTextDocument(fDocument)->SetTextHandler();
}
#endif

// ------------------------------------------------------------------------
static TChangeTypes DoThisNote(TObject null, TCurrency note, TCurrency ref, // 11/5/93
        /* fn1 TNoteType noteType,*/ void* pars)
{
  return kNoChg /* fn1 TRUE */;
}

// ------------------------------------------------------------------------
bool _TMainView::TestRegistered(TCursorNode cursorNode, int *pageOffset)
{
  return (*pageOffset = FirstRegisteredPage(cursorNode->fCurrency)) != MAXLONGINT;
}

// ------------------------------------------------------------------------
void _TMainView::DoReformat(TSelection selection, TCursorNode anchor, TCursorNode activeEnd)
{
  TFormat format;
  TStructure structure;
  TCurrency currency;
//  VPoint pageSize;
//  TSubView targetView;
  int pageNum;
  TChangeTypes result;
  TCursor anchorCurs = NULL; // 26/04/90 for safety
  TCursor activeCurs = NULL; // 26/04/90 for safety
  TStdNoteVars v;
  int numOfItems;
  int hfId = selection->fViewId.tag.fSubId;
  int pageOffset = 0;   // 04/03/92

  if (hfId == 0)
  {
    // reformat main body
    //    GetPageSize(pageSize);
    fSelection = selection;
    if (anchor == NULL)
    {
      currency = TTextDocument(fDocument)->fBody;
      pageNum = 1;                                      // 03/04/91
    }
    else
    {
      currency = anchor->fCurrency;
      anchorCurs = anchor->fCursor;
      activeCurs = activeEnd->fCursor;
      pageNum = Max(1, selection->fViewId.tag.fColNum);   // 03/04/91
      if (pageNum > 1 && anchorCurs->
              LastThat(this, (TestObject)_TMainView::TestRegistered, &pageOffset) != NULL)
        pageOffset = pageNum - pageOffset;
      else
        pageOffset = 0;
    }
    if (activeEnd != Ptr(-1))    // ignore if only doin Header/Footer
    {
      format = GetFormatReadWrite(currency);
      structure = format->GetStructureReadWrite(currency);
      numOfItems = structure->CountSelectedItems(currency, anchor, activeEnd,
                                              TRUE);  // 22/04/91 xtra param
      ShowProgress(numOfItems);
      v.obj = this;
      v.procToDo = (DoNote)DoThisNote;
      result = format->Reformat(currency, anchor, activeEnd,
                                               FixRound(fInteriorSize.h * 10), -1, &v);
      HideProgress();
      if (fDocument->fFileType != kTWScrapType)    // 22/04/91 do not paginate scrap docs
      {
        if (result >= kHeightChg || anchor == NULL)   // 09/05/93 [20855] from ==
        {
#ifdef DRAGDROP
          int pn;

          if (pageNum > 1)
            fPages->PaginateTo(pageNum - 1);    // 19/07/91 for structs
          pn = fPages->Paginate(pageNum, TRUE);
          fFirstPaginated = (fFirstPaginated == 0 ? pn : Min(fFirstPaginated, pn));
#else
          if (pageNum > 1)
            fPages->PaginateTo(pageNum - 1);    // 19/07/91 for structs
          // 27/11/92 fFirstPaginated = pageNum;
          fFirstPaginated = fPages->Paginate(pageNum, TRUE);
          // 27/11/92 set fFirstPaginated from returned value that Paginate started at
#endif
        }
        else if (result == kWidthChg && anchorCurs->IsCursor(activeCurs))
        {
          fPages->DrawView(pageNum, FALSE, TRUE); // 6/5/92 26/06/92 t,t from f,t
          fPages->ClearChangedFlags(); // 6/5/92
        }
        else if (result != kNoChg)
        {
          fPages->DrawChanges(pageNum - pageOffset);    // 04/03/92
        }
      }
    }

    if (anchor == NULL) // do everything
    {
      if (fHeaderMargin != 0)
        hfId |= 1;
      if (fFooterMargin != 0)
        hfId |= 2;
    }
  }

  for (int subId = 1; subId <= 2; subId++)
    if ((hfId & subId) != 0)
    {
      // inline ProcessHeaderFooters(subId)
      int svn;
      TCurrency currs[2];
      bool different;
      TSelection saveSel;
      TViewId viewId;
      int page;
      FailInfo fi;

      if (activeEnd == TObject(-1))
        activeEnd = NULL;
      different = TTextDocument(fDocument)->GetHeaderFooter(2 - subId, currs[0], currs[1]);
      saveSel = fSelection;
      CatchFailures(&fi);
      fSelection = selection;
      svn = 1;
      while (svn <= CountSubViews())
      {
        TSubView bodyView = TSubView(SubViewAt(svn));

        viewId.fId = bodyView->fIdentifier;

        if (viewId.tag.fSubId == 0 &&
           (anchor == NULL || !different || Odd(anchor->fIdentifier) == Odd(viewId.tag.fColNum)))
        {
          viewId.tag.fSubId = subId;
          svn += ReformatHeaderFooter(anchor, activeEnd, TSubView(FindSubView(viewId.fId)),
                                                                      viewId, bodyView);
        }
        svn++;
      }
#ifdef TRUE
      // 08/95 [26020] clear flags in format now that reformat complete. (is this OK as we
      // may still need to reformat those headers and footers with no view?)
      for (page = 1; page >= 0; page--)
      {
        if (anchor == NULL || Odd(anchor->fIdentifier) == page)
        {
          TFormat bodyFmt = GetFormatReadWrite(currs[page]);

          bodyFmt->ClearChangedFlags(currs[page], TRUE);  // [26020] instead of inside refHF loop
          if (!different)
            break;
        }
      }
#endif
      Success(&fi);

Rescue:
      fSelection = saveSel;
      ContinueIfFail(&fi);
      // end inline ProcessHeaderFooters(subId)
    }
#ifdef NEVER
  for (int subId = 1; subId <= 2; subId++)
    if ((hfId & subId) != 0)
    {
      // inline ProcessHeaderFooters(subId)
      TSelection saveSel;
      int svn = 1;
      bool different;
      TCurrency cL, cR;
      int action;
      FailInfo fi;

      // 23/11/90 2 tests added
      if (activeEnd == TObject(-1))
        activeEnd = NULL;

      if (anchor == NULL)
        action = 0;
      else
      {
        TViewId viewId;

        viewId.fId = anchor->fIdentifier;
        TTextDocument(fDocument)->
                           GetHeaderFooter(subId == 1, cL, cR, different);
        action = (different ? (Odd(viewId.tag.fColNum) ? 1 : 2) : 0);
      }
      // 23/11/90 end of 2 tests

      saveSel = fSelection;
      CatchFailures(&fi);
      fSelection = selection;
      while (svn <= CountSubViews())
      {
        // inline DoHeaderFooter(SubViewAt(svn));
        TViewId viewId;

        viewId.fId = SubViewAt(svn)->fIdentifier;

        if (viewId.tag.fSubId == 0)
        {
          // 23/11/90 doIt and test added
          bool doIt = (action == 0 ? TRUE :
                            (action == 1 ? Odd(viewId.tag.fColNum) :
                                          !Odd(viewId.tag.fColNum)));
          if (doIt)
          {
            viewId.tag.fSubId = subId;
            ReformatHeaderFooter(anchor, activeEnd,
                             TSubView(FindSubView(viewId.fId)), viewId);
          }
        }
        // end inline DoHeaderFooter(SubViewAt(svn));

        svn++;
      }
      Success(&fi);

Rescue:
      fSelection = saveSel;
      ContinueIfFail(&fi);
      // end inline ProcessHeaderFooters(subId)
    }
#endif
}


// ------------------------------------------------------------------------
void _TMainView::Reformat(TSelection selection, TCursorNode anchor, TCursorNode activeEnd)
{
  // 24/08/95 [26020] kick off Idle check of header/footer size if H/F changed or
  // something done in main body which affects h/f (redraw explicitly set)
  int setting = (activeEnd == TCursorNode(-1) ?
                                  fRedrawHeaderFooter : selection->fViewId.tag.fSubId);

  if ((setting & 1) != 0)
    fHeaderSize = 0;          // sizes will get recalculated in idle
  if ((setting & 2) != 0)
    fFooterSize = 0;
  if (fHeaderMargin == 0)     // do not try to fit empty h/fs
    setting &= ~1;
  if (fFooterMargin == 0)
    setting &= ~2;
  fPages->fFitHeaderFooter = setting;
  fPages->fFitHeaderFooterPage = 1;

  DoReformat(selection, anchor, activeEnd);
}


// ------------------------------------------------------------------------
void _TMainView::ReformatDuringIdle(TCursorNode anchor, TCursorNode activeEnd)
{
}


// ------------------------------------------------------------------------
void _TMainView::CompletePagination()
{
  while (fPages->fPaginate)
    fPages->DoIdle();
}


// ------------------------------------------------------------------------
void _TMainView::PaginateOnCommit()
{
  FailInfo fi;

              // 24/08/92 if this propagates a failure, document has probably had it ...
  CatchFailures(&fi);

  if (fFirstPaginated > 0)
  {
           // 19/07/91 and added Min: && fFirstPaginated <= fPages->GetSize())
// 27/11/92    fPages->Paginate(MinMax(1, fFirstPaginated - 1, fPages->GetSize()), FALSE);
// 27/11/92 fFirstPaginated is now the proper value to pass to paginate
    fPages->Paginate(fFirstPaginated, FALSE);
    fPages->PaginateTo(fPages->fActiveEndPage);  // 09/09/91 added
  }
//  else if (fPages->fPageToDraw > 0)         // 05/10/92
//    fPages->DoIdle();

  fFirstPaginated = 0;  // 09/05/91 do regardless
  Success(&fi);
Rescue:                   // 24/08/92 ... so return as normal on paginator fail
  return;
}


// ------------------------------------------------------------------------
static void DoThePurge(TObject null, TRecordIndex recnum, TRecordHandler handler)
{
  handler->PurgeRecord(recnum);
}

void _TMainView::Purge()
{
  fFormatHandlers[kTextStruct]->ForAllRecordsDo(NULL, (DoToRecord)DoThePurge);
}


// ------------------------------------------------------------------------
void _TMainView::DoNeedDiskSpace(long &dataForkBytes)
{
  TStructTypes index;
  TRecordHandler nextHandler;

  dataForkBytes += sizeof(TViewRecord);
  for (index = kTextStruct; index <= kMathStyleStruct; index++)
  {
    nextHandler = fFormatHandlers[index];
    if (nextHandler != NULL)
    { 
      dataForkBytes += nextHandler->DiscSpaceNeeded() + nextHandler->GetIndexSize();
    }
  }
}


// ------------------------------------------------------------------------
void _TMainView::DoWriteIndex(int aRefNum, long &position)
{
  TViewRecord viewRecord;
  long startPos;
  TStructTypes index;
  TRecordHandler nextHandler;
  long count;

  startPos = position;

//  for (index = kTextStruct; index <= kMathStyleStruct; index++) 
//    viewRecord.formatHandlers[index] = 0;

  position += sizeof(TViewRecord);
  SetEOF(aRefNum, position);
  for (index = kTextStruct; index <= kMathStyleStruct; index++)
  { 
    nextHandler = fFormatHandlers[index];
    if (nextHandler != NULL)
    { 
      viewRecord.formatHandlers[index] = position;
      nextHandler->SaveIndex(aRefNum, viewRecord.formatHandlers[index]);
      GetFPos(aRefNum, position);
    }
    else
      viewRecord.formatHandlers[index] = 0;  // 05/08/92 do here rather than own loop above
  }
  viewRecord.formatPosition = position;
  viewRecord.nextViewId = fNextViewId;
  viewRecord.headerMargin = fHeaderMargin;
  viewRecord.footerMargin = fFooterMargin;
  viewRecord.pageCount = GetPageMax();
  viewRecord.viewActive = fViewActive;
  viewRecord.showPictures = fShowPictures;     // 25/06/90

  SetFPos(aRefNum, /* fsFromStart, */ startPos);
  count = sizeof(TViewRecord);
  FWrite(aRefNum, count, &viewRecord);
}


// ------------------------------------------------------------------------
void _TMainView::DoReadData(int aRefNum, long &position)
{
  TViewRecord viewRecord;
  TStructTypes index;
  TRecordHandler nextHandler;
  long count;
  int version = TTextDocument(fDocument)->fVersion; // fn1

  SetFPos(aRefNum, /* fsFromStart, */ position);
  count = sizeof(TViewRecord);
  FRead(aRefNum, count, &viewRecord);

  if (version < 6) // fn1
  {
    memmove(&viewRecord.formatPosition, 
            &viewRecord.formatHandlers[kMathStyleStruct],
            sizeof(TViewRecord) - ((char *)&viewRecord.formatPosition - (char *)&viewRecord));
    viewRecord.formatHandlers[kMathStyleStruct] = NULL;
  }

  for (index = kTextStruct; 
       index <= kMathStyleStruct;
       index++)
  { 
    nextHandler = fFormatHandlers[index];
    if (nextHandler != NULL)
    {
      int fileIndexPos = viewRecord.formatHandlers[index];

      if (fileIndexPos != 0)      // 15/01/92
        nextHandler->LoadIndex(fileIndexPos);
    }
  }
  position = viewRecord.formatPosition;
  fNextViewId = viewRecord.nextViewId;
  fHeaderMargin = viewRecord.headerMargin;
  fFooterMargin = viewRecord.footerMargin;
  fPages->fPageCount = viewRecord.pageCount;   // overwrite the wrong value
                                               // passed to the creator
  fShowPictures = viewRecord.showPictures;     // 25/06/90
  fPages->fPaginate = TRUE;
#ifdef VIEWACT
  fViewActive = viewRecord.viewActive;
#endif
}


// ------------------------------------------------------------------------
void _TMainView::PageInteriorChanged(Rect &newInterior)
{
  VPoint oldSize;
  TSelection selection;

  selection = TTextDocument(fDocument)->GetSelection(TRUE);
  oldSize = fInteriorSize;
  RectSizeToPt(newInterior, fInteriorSize);

  if (oldSize.h != 0)
  {
    bool lrHeaderFooterChg = TTextDocument(fDocument)->fLRHeaderFooterChg;

    TTextDocument(fDocument)->fLRHeaderFooterChg = FALSE;
    if (oldSize.h != fInteriorSize.h)
    {
      DeleteSubViews(); // 26/07/90
      selection->fReformatType = kReformatAll;
      TTextDocument(fDocument)->Reformat();
    }
    else if (oldSize.v != fInteriorSize.v ||
       fOldHeaderMargin + fOldFooterMargin != fHeaderMargin + fFooterMargin)
    {
      DeleteSubViews(); // 26/07/90
      fPages->Paginate(1, TRUE);
    }
    // 17/09/90 new clause added
    else if (lrHeaderFooterChg)
    {
      DeleteSubViews();
#ifdef TRUE
      if (lrHeaderFooterChg == 1)
        return;
      // 27/06/95 [26020] is ForceRedraw necessary??? certainly not for fLRHeaderFooterChg
#endif
    }
    else
      // 2/12/91 force H/F to be updated in case only page moved
      if (fHeaderMargin != 0 || fFooterMargin != 0)    // [26020]
        RedrawHeaderFooter(3);
      // fRedrawHeaderFooter = (fHeaderMargin != 0) || (fFooterMargin != 0);
  }
  ForceRedraw();
}

#ifdef TRACE
// ------------------------------------------------------------------------
void _TMainView::GetPageRange(Rect &area, int &startPage, int &endPage)
{
  NotYetImplemented("TMainView::GetPageRange");
}


// ------------------------------------------------------------------------
void _TMainView::SetScaleOrigins(int pageNum)
{
}
#endif


// ------------------------------------------------------------------------
void _TMainView::GetTrackLimits(TSubView subView, VRect &picLimits,
                                                 TwoBools repositionInLine)
{
  // 03/05/90 - new mac method
  int pageNum;
  TViewId viewId;
  int topInterior;
  int botInterior;

  viewId.fId = subView->fIdentifier;
  pageNum = viewId.tag.fColNum;
  GetPageInterior(pageNum, picLimits);
  // 22/04/91 add limits while in headers/footers
  topInterior = picLimits.top + FixRound(ZoomFixed(fHeaderMargin));
  botInterior = picLimits.bottom - FixRound(ZoomFixed(fFooterMargin));
  if (viewId.tag.fSubId == 1)
    picLimits.bottom = topInterior;
  else if (viewId.tag.fSubId == 2)
    picLimits.top = botInterior;
  else
  {
    picLimits.top = topInterior;
    picLimits.bottom = botInterior - 1;
  }
}


// ------------------------------------------------------------------------
void _TMainView::DoSetupMenus()
{
  // 19/11/93 moved from UTextComm so menu enabled when picture selected
  TSelection selection = TTextDocument(fDocument)->GetNewSelection();

  if (!selection->fEndStructure && selection->GetAnchorRoot()->fCurrency ==
                            TTextDocument(fDocument)->fBody)  // 10/05/91 not h/f
  {
    EnableCmd(cFindReplace);
    if (fFindText[0] != 0) // 08/03/93 better than strlen() > 0 (twice)
    {
      EnableCmd(cFindSame);   // 08/03/93 Enable(, strlen(mainView->fFindText) > 0);
      if (Curr_fType(selection->GetAnchorOwner()->fCurrency) == kTextStruct)
        EnableCmd(cReplace);
              // 08/03/93 Enable(cReplace, strlen(mainView->fFindText) > 0 &&
              // fSelection->GetAnchorOwner()->fCurrency.cgf_31.fType == kTextStruct);
    }
    if (!selection->fCursor)
      EnableCmd(cFindSelection);
  }

  _TSubView::DoSetupMenus();
}

#ifdef TABLES
// ------------------------------------------------------------------------
static TCommand SelectPopup(TMainView mv, bool selUp)
{
  TTextDocument doc = TTextDocument(mv->fDocument);
  MenuHandle *selectMenu;

  gApplication->SetWindowForMenus(mv->GetWindow());  // 10/10/96 [27104] ensure correct popup set
  gApplication->SetupTheMenus();

  selectMenu = GetResMenu(cmSelection);

  for (int index = CountMItems(*selectMenu) - 2 + selUp; index >= selUp; index--)
  {
    bool enabled;
    bool ticked;

    GetMenuState(CmdFromMenuItem(cmSelection, index), enabled, ticked);
    if (ticked && enabled)
    {
      doc->SelectLevel(index + 2 * (1 - selUp));
      break;
    }
  }
  return gNoChanges;
}
#endif

// ------------------------------------------------------------------------
TCommand _TMainView::DoCommandKey(int chcode, EventInfo &info)
{
#if defined TABLES && !defined NETWP
  bool selUp = FALSE;

  if (chcode == wr_akbd_Fn11 || (selUp = TRUE, chcode == wr_akbd_Sh+wr_akbd_Fn11))
    return SelectPopup(this, selUp);
#endif

  return _TView::DoCommandKey(chcode, info);
}

// ------------------------------------------------------------------------
// 26/11/93 [21127] Find handling moved from UTextComm
void _TMainView::WriteToDialog(TView aDialogView, CmdNumber aCmd)
{
  if (aCmd == cFindReplace)
  {
    aDialogView->WriteText(kFind, fFindText);
    aDialogView->WriteText(kChng, fReplaceText);

    aDialogView->WriteCheckBox(kWord, fWholeWord);
    aDialogView->WriteCheckBox(kCase, fCaseSensitive);
    aDialogView->WriteCheckBox(kRev0, fSearchBackwards);
  }
  _TSubView::WriteToDialog(aDialogView, aCmd);
}

// ------------------------------------------------------------------------
TCommand _TMainView::ReadFromDialog(TView aDialogView, CmdNumber aCmd, IDType choice)
{
  if (aCmd == cFindReplace)
  {
    for (int idPtr = 0; idPtr < 5; idPtr++)
    {
      TControl control = TControl(aDialogView->FindSubView(gTVIds[idPtr]));

      if (idPtr < 2)
        control->GetText(fFindText + (idPtr * 256));
      else
        (&fWholeWord)[idPtr - 2] = control->IsOn();
    }
    if (choice != kAll0 || fFindText[0] != 0)             // 14/05/91
      return DoFindReplaceAction(
               choice == kOKbn ? cFind : (choice == kRepl ? cReplace : cReplaceAll));
         // findStr, replaceStr, choice, wholeWord, caseSensitive, searchBackwards);
  }
  return _TSubView::ReadFromDialog(aDialogView, aCmd, choice);
}

// ------------------------------------------------------------------------
TCommand _TMainView::DoFindReplace()
{
  return DoDialogue(this, cFindReplace, kSearchDlgID, 0xffffffef);   // 22/05/91 ignore f4
}

// ------------------------------------------------------------------------
TCommand _TMainView::DoFindReplaceAction(CmdNumber cmd)
{
  return new _TFindCommand(cmd, this, fFindText);
}

// ------------------------------------------------------------------------
TCommand _TMainView::DoFindSame()
{
  return DoFindReplaceAction(cFind);
}

// ------------------------------------------------------------------------
TCommand _TMainView::DoReplace()
{
  return DoFindReplaceAction(cReplace);
}

// ------------------------------------------------------------------------
TCommand _TMainView::DoFindSelection()
{
  TSelection selection;
  TCursorNode anchor, activeEnd;
  TCurrency currency;
  Str255 selectedText;

  selectedText[0] = 0;
  selection = TTextDocument(fDocument)->GetNewSelection();
  anchor = selection->GetAnchorOwner();
  activeEnd = selection->GetActiveOwner();
  currency = anchor->fCurrency;
  GetStructureReadOnly(currency)->GetSelectedText(currency, anchor, activeEnd, selectedText);
  if (selectedText[0] == 0)
  {
    SysBeep(0);
    return gNoChanges;
  }
  strcpy(fFindText, selectedText);
  return DoFindSame();
}


// ------------------------------------------------------------------------
// 10/07/91 Mk 2
TCommand _TMainView::DoMenuCommand(EventInfo &info, CmdNumber aCmd)
{
#ifdef TABLES
  if (aCmd == cBarSelect)     // 17/06/93 select up/down for click on structure on button bar
    return SelectPopup(this, info.rightButton);

  if (aCmd < 0)
  {
    int aMenu, anItem;

    aMenu = CmdToMenuItem(aCmd, anItem);
    if (aMenu == cmSelection && anItem >= 1)
    {
      TTextDocument(fDocument)->SelectLevel(anItem);
      return gNoChanges;
    }
  }
  else
#endif
  switch (aCmd)
  {
  case cFindReplace:
    FailSpaceIsLow();         // 10/09/90
    return DoFindReplace();

  case cReplace:
    return DoReplace();

  case cFindSelection:
    return DoFindSelection();

  case cFindSame:
    if (fFindText[0] != 0)     // 02/12/93 [21140] check if command enabled from button bar
      return DoFindSame();
  }
  return _TSubView::DoMenuCommand(info, aCmd);
}


// ------------------------------------------------------------------------
#ifdef DRAGDROP
bool _TMainView::InPage(Point &thePoint)
// 23/04/93 TPagesView version sets fDownPage which is needed for DrawSaving
{
  return FALSE;  // overridden
}
#endif

// ------------------------------------------------------------------------
_TPages::_TPages(TMainView view, int pageCount) : (sizeof(TPageInfo))
{
#ifndef ZERO_OBJ
  fPageToDraw = 0;
  fAnchor = 0;
  fActiveEnd = 0;
  fActiveEndPage = 0;
#endif
  fView = view;
  fAnchorPage = 1;
  fPageToUpdate = 1;
  fPageCount = pageCount;
  fPaginate = (pageCount > 0);
  fDraw = fPaginate;
}


// ------------------------------------------------------------------------
void _TPages::FreeBreak(PPageInfo pageInfo)
{
   FreeIfObject(pageInfo->fBreak);
}


// ------------------------------------------------------------------------
void _TPages::Free()
{
  Each(this, (DoToItem)_TPages::FreeBreak);
  _TArray::Free();
}


// ------------------------------------------------------------------------
void _TPages::Reset(bool visiblePage, TSelection selection)
{
//  Rect area;

  fAnchorPage = 1;
  fActiveEndPage = 0;
  fAnchor = NULL;
  fActiveEnd = NULL;
  // 18/04/91 next block new for optimising click searching
  if (visiblePage)
  {
    if (selection == NULL)
    {
      int endPage;

      fView->GetVisiblePageRange(fAnchorPage, endPage);
    }
    else
    {
      fAnchor = selection->GetAnchorRoot();
      fActiveEnd = selection->GetActiveRoot();
      fAnchorPage = PViewId(&fAnchor->fIdentifier)->tag.fColNum;
      fActiveEndPage = PViewId(&fActiveEnd->fIdentifier)->tag.fColNum;
      fView->SetScaleOrigins(fAnchorPage);
    }
  }
}


// ------------------------------------------------------------------------
void _TPages::GetPageInfo(TPageData *pageData)
// 18/09/90 new method
{
  int pnStart = pageData->pageNum;
  bool titlePageFound = FALSE;
  bool pageNumFound = FALSE;                           // 11/04/91

  pageData->docTitle = fDocumentTitle;
  pageData->pageType = kDocPage;
  pageData->docLength = fPageCount;
  pageData->chapLength = 0;
  pageData->romanPages = FALSE;
  
  for (int pn = pnStart; pn > 0; pn--)
  {
    PPageInfo thisPageInfo = PPageInfo(At(pn));
    int thisPageNumber = thisPageInfo->fPageNum & (kPageTurnover - 1);  // 02/05/95 [25008]

    if (!titlePageFound)                                   // 11/04/91
      pageData->chapTitle = (pn == pnStart ?
        thisPageInfo->fPageChapterTitle : thisPageInfo->fChapterTitle);
           // 11/02/92 for current page set to first found chapter title
    // 28/11/90 following rehashed
    if (thisPageInfo->fChapPage)
    {
      if (!titlePageFound)
        pageData->chapLength++;
      if (pageData->chapTitle != 0 && !titlePageFound)
      {
        titlePageFound = TRUE;
        pageData->romanPages = thisPageInfo->fRomanNumbers;
        pageData->pageType = (pnStart == pn ? kChapTitlePage : kChapPage);
      }
      if (titlePageFound && !pageNumFound && thisPageInfo->fPageNum > 0)  // 11/04/91
      {
        pageData->pageNum += thisPageNumber - pn;
        pageNumFound = TRUE;
      }
    }
    else if (pn == 1)
    {
      pageData->pageNum += thisPageNumber - 1;
      if (!titlePageFound)                                 // 10/05/91
        pageData->romanPages = thisPageInfo->fRomanNumbers;
    }
  }
  for (pn = pnStart + 1; pn <= fSize; pn++)
  {
    PPageInfo thatPageInfo = PPageInfo(At(pn));

    if (thatPageInfo->fChapPage && thatPageInfo->fChapterTitle == 0)
      pageData->chapLength++;
    else
      return;
  }
}


// ------------------------------------------------------------------------
// common up code from DoIdle and PaginateTo
void _TPages::HandleAPage()   // bool paginateToCode)
{
  if (fPageToUpdate > 0)
  {
    UpdateView(fPageToUpdate, 2);
    if (fDraw)
      DrawView(fPageToUpdate, TRUE, FALSE);
  }
  if (fPaginate)
    fPageToUpdate++;
  else
  {
    ClearChangedFlags();

    // 26/05/92 see MakeViewsForPages for Undo Paste on > 3 page tables/ 3 pages of paras
    // 23/3/92  if (!(PPageInfo(At(fPageToUpdate)))->fHasView)
    //            MakeView(fPageToUpdate, FALSE);
    if (fDraw)      // we do not need to redraw hf on Commit???
      fView->RedrawHeaderFooter(3);       // [26020] from TRUE (end of pagination)
    // fView->fRedrawHeaderFooter = TRUE; 
    fPageToUpdate = 0;
  }
}


// ------------------------------------------------------------------------
void _TPages::PurgePages(int before, int after)
{
  for (int pageNum = 1; pageNum <= fSize; pageNum++)
  {
    if ((pageNum < before || pageNum > after) &&
      // 18/11/92 this is only done while printing, so why do we need another page worth of
      // views if not printing that page?            pageNum != fAnchorPage &&
               PPageInfo(At(pageNum))->fHasView)
    {
      // 18/11/92 set fViewsDeleted so menus, text handler reset after printing
      if (pageNum == fAnchorPage)
      {
        TTextDocument(fView->fDocument)->UnsetTextHandler();
        //?? fPages->Reset(FALSE, NULL);            // 18/04/91 & 14/05/91 added params
        fView->fViewsDeleted = TRUE;
      }
      DeleteView(pageNum, TRUE);  // TRUE instead of setting gPurging round call
    }
  }
}

// ------------------------------------------------------------------------
static bool MakeAPageView(TPages self, int pageNum)
{
  if (pageNum <= self->fSize && pageNum > 0 && !MemSpaceIsLow() &&
                                        !PPageInfo(self->At(pageNum))->fHasView)
  {
     self->MakeView(pageNum, TRUE);      // 08/04/92 tell it in idle
     return TRUE;
  }
  return FALSE;
}

// ------------------------------------------------------------------------
void _TPages::DoIdle()
{
  int firstPage, lastPage;
  int pageNum;
#define lowOnSpace FALSE
  //  bool lowOnSpace = FALSE;   // 05/08/92 carry on   MemSpaceIsLow();

  fView->SetIdleFreq(fView->fIdleFreq + 500);             // 08/07/91 in case of failure
  if (fPageToDraw > 0 && !lowOnSpace)
  {
    // 03/03/92 We may not have finished paginating yet, and furthermore may not
    // have paginated the page we want to draw. However, if this happens DrawChanges
    // forces a PaginateTo fPageToDraw, so all should be well. After that
    // fPageToDraw should be equal fPageToUpdate.
    if (fPageToDraw <= fSize)    // 28/08/90
    {
      DrawChanges(fPageToDraw);  // 28/08/90 from DrawView(fPageToDraw, TRUE)
    }
    if (fPageToDraw > fSize)
    {
      fPageToDraw = 0;
      ClearChangedFlags();
    }
    else if (fPageToDraw == fPageToUpdate) 
      fPageToDraw = 0;
  }
  else if (fPaginate && !lowOnSpace)
  {
#ifdef TRACE
    Assert(fPageToUpdate, 109);
#endif
    FitPage(fPageToUpdate);     // 16/06/91 from HandleAPage
  }
  else if (!gPrinting)
  {
    if (fView->GetVisiblePageRange(firstPage, lastPage))
           // 30/04/92 do not throw views if printing
           // 29/01/93 [20604] use GetVisiblePageRange: && fView->Focus())
    {
      bool pageDeleted = FALSE;

      // 29/01/93 [20604]    fView->GetVisibleRect(visRect);
      // 29/01/93 [20604]    fView->GetPageRange(visRect, firstPage, lastPage);
      for (pageNum = 1; pageNum <= fSize; pageNum++)
      {
        if ((pageNum <= firstPage - 2 || pageNum >= lastPage + 2) &&
               pageNum != fAnchorPage && pageNum != fActiveEndPage
                                && PPageInfo(At(pageNum))->fHasView)
                              // 22/05/91 do not delete activeendpage
        {
          pageDeleted = TRUE;
          //        gPurging = TRUE;
          DeleteView(pageNum, TRUE);
          //        gPurging = FALSE;
          break;
        }
      }

      if (!pageDeleted)
      {
        if (MakeAPageView(this, lastPage + 1))
        {}
        else if (MakeAPageView(this, firstPage - 1))
        {}
        else if (fFitHeaderFooter)     // [26020]
        {
          TViewId viewId;
          TSelection saveSel = fView->fSelection;

          fView->fSelection = TTextDocument(fView->fDocument)->GetNewSelection();
                                                           // sounds wrong - check it!!!
          if (fFitHeaderFooterPage > fSize)
          {
             // we have done all the header footer depth recalculations
             // reset the 'Max' values (may now be less than space allocated), so
             // if they go over limit again, you will get another warning
             fView->fHeaderMaxSize = fView->fHeaderSize;
             fView->fFooterMaxSize = fView->fFooterSize;
             fFitHeaderFooter = 0;
          }
          else
          {
            if (!PPageInfo(At(fFitHeaderFooterPage))->fHasView)
            {
              // Fit header/footer for page if it has no views (those with views are done earlier)
              for (int i = 1; i <= 2; i++)
                if ((i & fFitHeaderFooter) != 0)
                {
                  viewId.tag.fSubId = i;
                  viewId.tag.fColNum = fFitHeaderFooterPage;
              
                  fView->ReformatHeaderFooter(NULL, NULL /* ??? */, TSubView(-1), viewId, NULL);
                }
            }
            fFitHeaderFooterPage++;
          }
          fView->fSelection = saveSel;
        }
        else
        {
#ifdef NETWP
          char *longWait = GetString(95);
          int wait = (longWait ? atoi(longWait) : 50);
#else
          int wait = 50;
#endif

          fView->SetIdleFreq(wait);   // 21/03/96 from 0 - we have done everything possible
          return;
        }
      }
    }
  }
  fView->SetIdleFreq(0);      // 08/07/91 in case of success (with maybe more to do)
}


// ------------------------------------------------------------------------
static void DoClearDrawnFlags(TObject null, TSubView view)
{
  view->fUpdated = FALSE; // fn1
  view->EachSubview(NULL, (DoToSubView)DoClearDrawnFlags);
}

// ------------------------------------------------------------------------
static void DoClearChangedFlags(TMainView view, TCurrency currency)
{
  if (currency != 0)
    view->GetFormatReadOnly(currency)->ClearChangedFlags(currency,
                     TTextDocument(view->fDocument)->fBody != currency); // 21/03/91 RW
}

// ------------------------------------------------------------------------
void _TPages::ClearChangedFlags()
{
  TMainView view = fView;
  TTextDocument document = TTextDocument(view->fDocument);

  DoClearChangedFlags(view, document->fBody);
  DoClearChangedFlags(view, document->fRightHeader);
  if (document->fLeftRightHdr)
    DoClearChangedFlags(view, document->fLeftHeader);
  DoClearChangedFlags(view, document->fRightFooter);
  if (document->fLeftRightFtr)
    DoClearChangedFlags(view, document->fLeftFooter);
  view->EachSubview(NULL, (DoToSubView)DoClearDrawnFlags);
}


// ------------------------------------------------------------------------
void _TPages::DrawChanges(int fromPage)
{
  int firstVisible, lastVisible;

  do
  {
    UpdateView(fromPage, TRUE);         // 19/03/91 TRUE added
    DrawView(fromPage, TRUE, FALSE);    // 6/5/92
    fromPage++;
  }
  while (fromPage <= fAnchorPage);

// 02/03/93 [20803] DrawChanges while paginating make DoIdle in NotifyDep update wrong page
//  if (!fPaginate)
    fPageToDraw = fromPage;

  // 29/01/93 [20604] ensure all views on visible pages UpdateView-ed
  if (fView->GetVisiblePageRange(firstVisible, lastVisible))
    while (fromPage <= lastVisible)
    {
      UpdateView(fromPage, TRUE);
      fromPage++;
    }
}

// ------------------------------------------------------------------------
void _TPages::DrawItsChanges(TSubView theView, int pageNum, 
        bool invalidate, bool installChanges) // 6/5/92
{
  // 01/02/96 [27011] when installChanges set, ReformatHeaderFooter will not yet have been
  // done, so calling DrawChanges on the feader or footer views can show wrong text, or
  // even crash. The (!install || ...) test is intended to stop the call of DrawChanges
  // until the ReformatHF comes along, which it should if fRedrawHeaderFooter is set

  if (PViewId(&theView->fIdentifier)->tag.fColNum == pageNum && (!installChanges ||
          (PViewId(&theView->fIdentifier)->tag.fSubId & fView->fRedrawHeaderFooter) == 0))
    theView->DrawChanges(invalidate, installChanges); // 6/5/92
}

// ------------------------------------------------------------------------
void _TPages::DrawView(int pageNum, bool invalidate, bool installChanges)
{
  if (pageNum <= GetSize() && PPageInfo(At(pageNum))->fHasView)
    fView->EachSubview(this, (DoToSubView)_TPages::DrawItsChanges, pageNum, 
        invalidate, installChanges); // 6/5/92
}


// ------------------------------------------------------------------------
int _TPages::Paginate(int fromPage, bool draw)
{
//  TObject breakObj;
  TCurrency body;
  TFormat bodyFmt;
  int oldStart = fromPage;
  int firstVisible, lastVisible;

  if (fromPage > 1)  // 28/05/90 - this blk new
  {
    body = TTextDocument(fView->fDocument)->fBody;
    bodyFmt = fView->GetFormatReadOnly(body);

    // 27/11/92 test against fSize as well - for Undo delete more than 1 page from the end
    while (fromPage > 1 && (fromPage - 1 > fSize ||
              bodyFmt->ReAlign(body, fromPage, PPageInfo(At(fromPage - 1))->fBreak) < 0))
      fromPage--;
  }
  fPageToDraw = 0;
  fDraw = draw;
  fPaginate = TRUE;

  // 12/07/90 try to avoid problems after failure
  fPageToUpdate = fromPage;

  // 02/03/93 [20803] Another case where visible following page views out of sync with format
  if (fView->GetVisiblePageRange(firstVisible, lastVisible) && oldStart < lastVisible)
    oldStart = lastVisible;

  while (fPaginate && fPageToUpdate <= oldStart)    // oldStart from fAnchorPage
                                     // 29/11/90 loop to the insertion point
  {
/* 24/08/92 unfortunately, if 'MemSpaceIsLow' backspacing fails
    if (MemSpaceIsLow())           // 03/02/91 do not fail on Commit path
      break;
*/
    FitPage(fPageToUpdate);
  }
  return fromPage;  // 27/11/92 return the page it actually fitted
}


// ------------------------------------------------------------------------  
void _TPages::UpdateViewsOnPage(TSubView theView, int pageNum, bool updateAll)
{
  TObject startPage, endPage;
  VRect pageInterior;
  TCurrency body;
  TFormat bodyFmt;
  Fixed hm;
  TViewId pageId;

  pageId.fId = theView->fIdentifier;

  if (pageId.tag.fColNum == pageNum && pageId.tag.fSubId == 0) // 18/09/90
  {
    // VPoint vSlop;

    // vSlop.v = 0;
    // vSlop.h = 0;
    fView->GetPageInterior(pageNum, pageInterior);
    if (pageNum == 1)
      startPage = NULL;
    else
      startPage = PPageInfo(At(pageNum - 1))->fBreak;
    endPage = (PPageInfo(At(pageNum)))->fBreak;

    if ((hm = fView->fHeaderMargin) != 0)
      pageInterior.top += FixRound(fView->ZoomFixed(hm));
                                                // added zooming 17/04/90

    body = TTextDocument(fView->fDocument)->fBody;
    bodyFmt = fView->GetFormatReadOnly(body);

    bodyFmt->UpdateView(body, theView, *pageInterior.topLeft, 0,   // vSlop,
                     startPage, endPage, TRUE, updateAll);  // 26/07/90
  }
}


// ------------------------------------------------------------------------
void _TPages::UpdateView(int pageNum, bool updateAll)
{
#ifdef TRACE
  Assert(pageNum <= GetSize() || fPageCount == 0, kNoPage);
#endif
  if (fPageCount == 0 && pageNum == 1)
  {
    if (fSize >= 1 && !PPageInfo(At(1))->fHasView)
      MakeView(1, FALSE);     // 08/04/92 call not allowed to fail
  }
  else if (PPageInfo(At(pageNum))->fHasView)
  {
    if (/* !fDraw && */ updateAll < 2) // 5/10/92 to prevent recursion thru FitPage, 18/09/90
      PaginateTo(pageNum);
    fView->EachSubview(this, (DoToSubView)_TPages::UpdateViewsOnPage,
                                                     pageNum, updateAll != 0); // 5/10/92
  }
}


// ------------------------------------------------------------------------
void _TPages::NotifyHeading(TCurrency itsHeading, TStyleTypes itsType,
             int startPage, bool useRomanNumbers, TPagesLocVars *lvars)
// 18/09/90 new
{
// 11/02/92 moved below:  lvars->heading = -1;   // 28/09/90 from gNullCurrency;
  lvars->chapPage = FALSE;
  lvars->romanNums = useRomanNumbers;
  if (startPage != 0)           // 02/10/90 do not let chapter corrupt doc
    lvars->spn = startPage;
  if (itsType == kDocument)
  {
    if (itsHeading != 0)             // 21/02/91
      fDocumentTitle = itsHeading;
  }
  else if (itsType == kChapter)
  {
    if (itsHeading != 0 || lvars->heading < 0)
      lvars->heading = itsHeading;  // 11/02/92 set to the last found
    if (lvars->pageHeading <= 0)   // 11/02/92 set first heading on page
      lvars->pageHeading = itsHeading;
    lvars->chapPage = TRUE;
  }
}


// ------------------------------------------------------------------------
static void DoFitTheNote(TObject obj, TCurrency note,
                 bool &allFits, /* fn1 */
                 /* fn1 TNoteType noteType, */
                 int &noteSpaceAvailable, void *pars)
// 03/08/90 extra params added
{
}

void _TPages::FitPage(int pageNum)
{
  int spaceAvailable;
  TFormat bodyFmt;
//  VPoint pageSize;
  TCurrency body;
  bool fits;
  TObject pageBreak;     // 24/05/93 [20894]
  TPageInfo pageInfo;
  int index;
  TPagesLocVars lvars;
  int gaps = 0;  // 21/12/93 [21204]
  int dummy = 0; // 21/05/93 [20890]
  bool dummyB = 0; /* fn1 */   // 06/06/93 [20918]
  FailInfo fi;                    // 24/05/93 [20894]

  body = TTextDocument(fView->fDocument)->fBody;
  bodyFmt = fView->GetFormatReadOnly(body);
//  fView->GetPageSize(pageSize);
  spaceAvailable = FixRound(fView->fInteriorSize.v * 10 -
                                           fView->fHeaderMargin - fView->fFooterMargin);
  if (pageNum == 1)
    pageBreak = 0;
  else
  {
    Get(pageNum - 1, &pageInfo);
    pageBreak = pageInfo.fBreak;
  }

  // 06/08/90 - fit interface changed
  lvars.v.obj = this;

  // 11/02/92 initialise here rather than in NotifyHeading for multi-col Doc
  lvars.heading = -1;   // 28/09/90 from gNullCurrency;
  lvars.pageHeading = -1;     // 11/02/92
  lvars.v.procToDo = (DoFitNote)DoFitTheNote;
  lvars.v.procForHeading = (DoNotifyHeading)_TPages::NotifyHeading;
  lvars.spn = 0;                       // 02/10/90 init in case not set
  /* fn1 added params */
  fits = bodyFmt->Fit(pageNum, body, spaceAvailable, dummy, spaceAvailable,
                                     pageBreak, gaps, dummyB, &lvars.v, &lvars.v);

  // 15/11/92 initialise fields once
  pageInfo.fHasView = FALSE;
  if (pageNum <= GetSize())
  {
    Get(pageNum, &pageInfo);
    FreeIfObject(pageInfo.fBreak);            // 28/01/91
  }
  pageInfo.fChapterTitle = lvars.heading;
  pageInfo.fPageChapterTitle = lvars.pageHeading;
  pageInfo.fChapPage = lvars.chapPage;
  pageInfo.fPageNum = lvars.spn;
  pageInfo.fRomanNumbers = lvars.romanNums;
  pageInfo.fBreak = pageBreak;

  if (fits && pageBreak == NULL)
  {
    fPageCount = pageNum;

    if (pageNum > GetSize())
      InsertLast(&pageInfo);
    else
    {
      AtPut(pageNum, &pageInfo);
      // 29/11/90 throw deleted breaks and views
      for (index = GetSize(); index >= pageNum + 1; index--)
      {
        Get(index, &pageInfo);
        pageInfo.fChapterTitle = 0; // 18/09/90
        FreeIfObject(pageInfo.fBreak);            // 28/01/91
        DeleteView(index, FALSE);
      }
      ReduceSize(pageNum);    // 29/11/90
    }
    fPaginate = FALSE;
    HandleAPage();       // 16/06/91
    fDraw = FALSE;
    if (fAnchorPage > fSize)
      fAnchorPage = fSize;          // 08/02/91
#ifdef VIEWACT
    {
      bool sveViewActive = fView->fViewActive; // 18/09/90 restore setting

      // 30/07/90 following 3 lines added
      fView->fViewActive = FALSE;
      fView->AdjustSize();
      fView->fViewActive = sveViewActive;
      // 30/07/90 end of addition
    }
#else
    fView->fLastBlink = 1; // 22/11/90 use fLastBlink a flag for fViewActive
    fView->AdjustSize();
    fView->fLastBlink = 0;
#endif
  }
  else
  {
    if (pageNum > GetSize())
    {
      CatchFailures(&fi);    // 24/05/93 [20894]
      InsertLast(&pageInfo);
      Success(&fi);          // 24/05/93 [20894]
    }
    else
      AtPut(pageNum, &pageInfo);
    HandleAPage();
  }
  return;

Rescue:                      // 24/05/93 [20894] rescue to free break objects
  FreeIfObject(pageInfo.fBreak);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TPages::PaginateTo(int pageNum)
{
  if (fPaginate)
  {
    int pagesToDo = pageNum - fPageToUpdate + 1;  // 03/08/92 + 1

    if (pagesToDo > 0)      // 02/03/93 [20803]
    {
      ShowProgress(pagesToDo);

      while (fPaginate && (fPageToUpdate <= pageNum))
      {
        if (MemSpaceIsLow())
          TTextDocument(fView->fDocument)->Purge();            // 11/06/91
// 03/08/92 failing kills BodyEditor & must not fail in Commit!!!      FailSpaceIsLow();
        FitPage(fPageToUpdate);
        UpdateProgress();
      }
      HideProgress();
    }
  }
}

// ------------------------------------------------------------------------
// 22/03/91 clear out old (failed) view
static void DeleteFailedView(TObject null, TSubView view, IDType pageId)
{
  if (view->fIdentifier == pageId)
                               // 10/06/91 frm fIdentifier == kNoIdentifier)
    FreeIfObject(view);
}


// ------------------------------------------------------------------------
void _TPages::MakeView(int pageNum, bool inIdle)
// 08/04/92 extra param - true if making reserve pages in idle
{
#ifdef TRACE
  Assert(pageNum, 111);
#endif
  if ((PPageInfo(At(pageNum)))->fHasView)
  {
    UpdateView(pageNum, FALSE); // 19/03/91
  }
  else
  {
    TObject startPage, endPage;
    VRect pageInterior;
    TCurrency body;
    TFormat bodyFmt;
    TSubView pageView;
    volatile TViewId pageId;
    Fixed marg[2];
    TSelection selection = NULL;
    int i;
    FailInfo fi;

    fView->GetPageInterior(pageNum, pageInterior);
    //  width = pageInterior.right - pageInterior.left;
    // 18/09/90 extra bits in following to set up selection for Header/Footer
    marg[1] = fView->fFooterMargin;
    if ((marg[0] = fView->fHeaderMargin) != 0 || marg[1] != 0)
    {
      int hms;
      // int fms;

      selection = new _TSelection(TTextDocument(fView->fDocument));
      selection->fReformatType = kReformatAll;
      hms = FixRound(fView->ZoomFixed(marg[0]));
      pageInterior.top += hms;
      // fms = FixRound(fView->ZoomFixed(marg[1]));
    }
    else
    {
      selection = NULL;
      // hms = 0;
      // fms = 0;
    }
    if (pageNum == 1)
      startPage = NULL;
    else
      startPage = PPageInfo(At(pageNum - 1))->fBreak;
    endPage = PPageInfo(At(pageNum))->fBreak;

    body = TTextDocument(fView->fDocument)->fBody;
    bodyFmt = fView->GetFormatReadOnly(body);
    CatchFailures(&fi);
    pageId.tag.fColNum = pageNum;       // 25/04/91 pass viewId to MakeView
    pageId.tag.fSubId = 0;
    pageView = bodyFmt->MakeView(body, pageId, 0,
                         fView, 0, *pageInterior.topLeft, startPage, endPage);
    if (inIdle)
      FailSpaceIsLow();   // 08/04/92 do not grab all reserve in idle
    Success(&fi);
    if (pageView != NULL) // 28/05/90 - if.. block put in
    {
      PPageInfo(At(pageNum))->fHasView = TRUE;
    }
    // 18/09/90 now make header/footer views
    for (i = 0; i <= 1; i++)
      if (marg[i] > 0)
      {
        selection->fViewId.tag.fColNum = pageNum;
        selection->fViewId.tag.fSubId = i + 1;
        fView->DoReformat(selection, NULL, NULL); // [26020] use DoReformat (avoid h/f Fit check)
                  // really this should just make the h/f for the specified page, NOT reformat,
                  // fit and update views for ALL the header/footers with views!!!
                  // The failure path needs revising too!
      }
    FreeIfObject(selection);
    return;
Rescue:
    fView->EachSubview(NULL, (DoToSubView)DeleteFailedView, pageId.fId);
    FreeIfObject(selection);
    if (inIdle)
      return;       // 08/04/92 do not put out messages in idle
    ContinueFailure(&fi);
  }
}


// ------------------------------------------------------------------------
static void DoTheDelete(TObject null, TSubView aView)
{
  // 03/05/90 - new to mac
  // ??? aView->ForceRedraw(); ???
  aView->EachSubview(NULL, (DoToSubView)DoTheDelete);
  aView->Delete();
}

static void DeleteFromPage(TObject null, TSubView theView, int pageNum)
{
  if (PViewId(&theView->fIdentifier)->tag.fColNum == pageNum)
  {
    if (!TTextDocument(theView->fDocument)->fPurging ||      // 15/07/91 g->f
            PViewId(&theView->fIdentifier)->tag.fSubId == 0) // 19/03/91
    {
      DoTheDelete(NULL, theView);
    }
    else
      theView->Free();  // 26/03/91 still free header views on zoom
  }
}


// ------------------------------------------------------------------------
void _TPages::DeleteView(int pageNum, bool setPurging)
{
  if (setPurging)
    TTextDocument(fView->fDocument)->fPurging = TRUE; // 15/07/91 do once here
  fView->EachSubview(NULL, (DoToSubView)DeleteFromPage, pageNum);
  PPageInfo(At(pageNum))->fHasView = FALSE;
  if (setPurging)
    TTextDocument(fView->fDocument)->fPurging = FALSE;
}


// ------------------------------------------------------------------------
void _TPages::DeletePageViews()
{
  for (int pageNum = 1; pageNum <= fSize; pageNum++)
  {
    if (PPageInfo(At(pageNum))->fHasView)
      DeleteView(pageNum, FALSE);
  }
}

// ------------------------------------------------------------------------
int _TPages::FindPageWithCursor(TCursorNode cursor, bool anchor)
// 05/09/91 new
{
  int pageNum = (anchor ? fAnchorPage : fActiveEndPage);

  if (fSize == 0 || HasTheCursor(pageNum, cursor))
    return pageNum;
  pageNum = 1;
  if (HasTheCursor(pageNum, cursor))
    return pageNum;
  return 0;
}

// ------------------------------------------------------------------------
bool _TPages::HasTheCursor(int &pageNum, TCursorNode cursor)
{
  TObject endPage;
  TObject startPage;
  bool fromStart;
  TCurrency body;
  TFormat bodyFmt;

  body = TTextDocument(fView->fDocument)->fBody;
  bodyFmt = fView->GetFormatReadOnly(body);
  PaginateTo(pageNum);
  pageNum = Min(fSize, pageNum);                   // 22/05/91
  fromStart = (pageNum <= 1);
  if (fromStart)
  {
    pageNum = 1;
    startPage = NULL;
  }
  else
    startPage = PPageInfo(At(pageNum - 1))->fBreak;
  while (pageNum <= Max(fPageToUpdate, fPageCount))
  {
    endPage = PPageInfo(At(pageNum))->fBreak;
    if (bodyFmt->ContainsCursor(body, startPage, endPage, cursor))
    {
      MakeView(pageNum, FALSE);  // 08/04/92 not a call which can fail
      return TRUE;
    }
    else if (!fromStart && fPaginate)       // 18/09/90 new test
      break;
    startPage = endPage;
    pageNum++;   // 06/08/92
    PaginateTo(pageNum);
  }
  return FALSE;
}


// ------------------------------------------------------------------------
void _TPages::MakeSelectedViews(TCursorNode anchor, TCursorNode activeEnd)
// 18/09/90 rewritten
{
  int cursorSlave;
  TViewId pageId;

  pageId.fId = anchor->fIdentifier;

  if (pageId.tag.fSubId == 0)
  {
    cursorSlave = FindPageWithCursor(anchor, TRUE);
    Assert(cursorSlave > 0, 113);
    fAnchorPage = cursorSlave;

    if (activeEnd == NULL || !fView->Focus())
                          // 10/02/93 [20604] stop crash on windowless doc with selection
      fActiveEndPage = fAnchorPage;
    else
    {
      cursorSlave = FindPageWithCursor(activeEnd, FALSE);
      Assert(cursorSlave > 0, 114);
      fActiveEndPage = cursorSlave;
    }
  }
  else
  {
    // 29/11/94 [23016] make valid page and write back
    if (!fPaginate)
      pageId.tag.fColNum = MinMax(1, pageId.tag.fColNum, fSize);
    anchor->fIdentifier = pageId.fId;

    fAnchorPage = pageId.tag.fColNum;
    fActiveEndPage = fAnchorPage;
    if (fPaginate)
      PaginateTo(fAnchorPage);
    else
      MakeView(fAnchorPage, FALSE);  // 08/04/92 not a call which can fail
  }

  anchor->GetCursorTarget()->fIdentifier = kNewCursor;  // 03/04/91
  anchor->fCursor->Connect(fView);
  if (activeEnd != NULL)
  {
    activeEnd->GetCursorTarget()->fIdentifier = kNewCursor;  // 03/04/91
    activeEnd->fCursor->Connect(fView);
  }
  fAnchor = anchor;
  fActiveEnd = activeEnd;
  fView->SetScaleOrigins(fAnchorPage);
}


// ------------------------------------------------------------------------
void _TPages::HighlightAPage(int pageNum, TCursorNode anchor, TCursorNode activeEnd, 
bool redraw, bool noteSelection) // fn1
{
  TSubView pageView;
  TViewId pageId;

  if (anchor != NULL && anchor != TCursorNode(-1))   // 18/09/90 new test
                                                     // 16/06/91 & -1
    pageId.fId = anchor->fIdentifier;
  else
  {
    pageId.fNumId = 0;
    pageId.tag.fColNum = pageNum;
  }

  pageView = TSubView(fView->FindSubView(pageId.fId));
// 03/07/91 allow deleted views for page: Assert(pageView, 15);
  if (pageView != NULL && pageView->Focus())  // why Focus???
  {
    pageView->SetHighlight(anchor, activeEnd, redraw, noteSelection); // fn1
  }
}


// ------------------------------------------------------------------------
void _TPages::HighlightVisiblePages(bool redraw)
{
  int page1, pageN;
//  Rect qdr;
  TCursorNode cursor1, cursor2;
  bool noteSelection = FALSE; // fn1

  if (fActiveEndPage == 0)
    return;

// 29/01/93 [20604] use GetVisiblePageRange:   fView->Focus();
// 29/01/93 [20604]  fView->GetVisibleRect(qdr);
// 29/01/93 [20604]  fView->GetPageRange(qdr, page1, pageN);

#ifdef FN
  if (fAnchor != NULL &&
    TTextDocument(fView->fDocument)->GetStructureReadOnly(
             fAnchor->GetCursorTarget()->fCurrency)->IsPartOf(1 << kNoteSet) != 0)
                             // 24/01/94 IsPartOf passed a set of TStyleTypes
     noteSelection = TRUE;
#endif

  if (fView->GetVisiblePageRange(page1, pageN))   // 29/01/93 [20604] use new method
  {
    // prev. RebuildHighlight() local proc
    for (int pageNum = page1; pageNum <= pageN; pageNum++)
    {
      cursor1 = NULL;
      cursor2 = NULL;
      if (pageNum < fAnchorPage)
        cursor1 = TCursorNode(-1);
      else if (pageNum == fAnchorPage)
        cursor1 = fAnchor;
      if (pageNum > fActiveEndPage)
        cursor1 = TCursorNode(-1);       // 20/06/91
      else if (pageNum == fActiveEndPage)
        cursor2 = fActiveEnd;
      HighlightAPage(pageNum, cursor1, cursor2, redraw, noteSelection); // fn1
    }
  }
}


// ------------------------------------------------------------------------
void _TPages::HighlightSelection(TCursorNode anchor, TCursorNode activeEnd, bool redraw)
{
  if (activeEnd != NULL || fActiveEndPage == 0)
    MakeSelectedViews(anchor, activeEnd);
  if (activeEnd != NULL)
    HighlightVisiblePages(redraw);
}

/*
Have a TPages method for returning both break objects
*/

