/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

// 28/10/94 Index handler

#include <ctype.h>
#include <stdio.h>

#include "UIndex.h"
#include "UPopup.h"
#include "UTextEdit.h"
#include "PTextComm.h"

#define cmKeyIndex     49
#define cmReferences   50
#define cmQualIndex    51
#define cmIndexLetters 52
#define kSeeRef kIndexRefStruct

/*
  fHomeCurrency:
       1->0xffff means the record number in the index record handler of a X-ref
       >= 0x10000 a back-reference to the phrase or index entry
       phrase: text currency + (phrase number * 256) so bottom byte is always zero
       index entry: record number * 0x10000 + (qualifier index * 256) + kSeeRef
  fIndexInText:
        is index into the text for the qualifier (which may be "")
        this includes the page number and format which is inserted just before Save Index
*/

// ------------------------------------------------------------------------
static void DeleteIndexRecord(TRecordHandler handler, int recNum)
{
  if (TTextDocument(handler->fDocument)->fBookmarkRec == recNum)
    TTextDocument(handler->fDocument)->fBookmarkRec = 0;
  handler->DeleteRecord(recNum);
}


// ------------------------------------------------------------------------
void _TTextStructure::UpdateIndexRef(int index, int inc)
{
#ifdef TRACE
  Assert(fFirstOffset == 0, 600);
#endif
  if (fDocument != NULL)    // test for records not yet in rec handler in copy to clipboard
  {
    PPhrase endPhr = PPhrase(fPtrToArray) + fSize;
    PPhrase pphr;
    int numBefore = 0;
    TIndexStructure indexStruct;

    for (pphr = PPhrase(fPtrToArray) + index - 1; pphr >= PPhrase(fPtrToArray); pphr--)
      if (pphr->fKind == kIndexRefPhrase)
        numBefore++;

    for (pphr = PPhrase(fPtrToArray) + index; pphr < endPhr; pphr++)
      if (pphr->fKind == kIndexRefPhrase && (indexStruct =
         fDocument->GetIndexStructure(pphr->tag.indexRef.fIndexRec, kReadWrite + 2)) != NULL)
                   // need a better way of doing this!!!
      {
        for (int i = 1; i <= indexStruct->fSize; i++)
        {
          PIndexRef indexRef = PIndexRef(indexStruct->At(i));

          if (indexRef->fHomeCurrency >= 0x10000 &&
                               Curr_fType(indexRef->fHomeCurrency) == kTextStruct &&
                 fDocument->GetStructureReadOnly(indexRef->fHomeCurrency) == this &&
                 ((indexRef->fHomeCurrency >> 8) & 0xff) == numBefore)
          {
            indexRef->fHomeCurrency += (inc * 256);
            break;
          }
        }
        numBefore++;
      }
  }
}

// ------------------------------------------------------------------------
void _TTextStructure::InsertIndexRef(int index)
{
  UpdateIndexRef(index - 1, 1);
}

// ------------------------------------------------------------------------
void _TTextStructure::RemoveIndexRef(int index)
{
  UpdateIndexRef(index, -1);
}

typedef struct TClipTemp
{
  char *key;
  char *qual;
  int otherEnd;
} TClipTemp;

// ------------------------------------------------------------------------
void _TTextStructure::CopyIndexPhraseToClipboard(TCurrency currency, PPhrase phr,
                     TTextDocument sourceDocument, int j)
{
  TIndexStructure indexStruct =
                   sourceDocument->GetIndexStructureReadOnly(phr->tag.indexRef.fIndexRec);
  TClipTemp *clipTemp = (TClipTemp *)NewCheckedHandle(sizeof(TClipTemp));

  clipTemp->key = indexStruct->GetKey();
  clipTemp->qual = indexStruct->GetQualifier(Curr2HomeCurr(PPhrase(At(j)), currency));
  clipTemp->otherEnd = phr->tag.indexRef.fOtherEnd;
  phr->tag.paste.fPadding = (int)clipTemp;
}

// ------------------------------------------------------------------------
static void FindKey1(TObject null, TRecordIndex aRecord, TRecordHandler handler,
                                            char *key, int *newIdx)
{
  if (*newIdx == 0)    // not found yet
  {
    TIndexStructure indexStructure =
                      TIndexStructure(handler->GetRecordObject(aRecord, kReadOnly));

    if (strncmp(indexStructure->GetKey(), key, kKeyMaxLen) == 0)
      *newIdx = aRecord;
  }
}

// ------------------------------------------------------------------------
int FindRecordForKey(TRecordHandler recHandler, char *key)
{
  int newIdx = 0;

  if (*key == 1)
    return TTextDocument(recHandler->fDocument)->fBookmarkRec;
  recHandler->ForAllRecordsDo(NULL, (DoToRecord)FindKey1, key, &newIdx);
  return newIdx;
}

// ------------------------------------------------------------------------
static int CreateIndexRec(char *key, char *qual, TTextDocument doc, TCurrency homeCurr)
{
  TRecordHandler recHandler = doc->fStructureHandlers[kIndexRefStruct];
  int newIdx;
  TIndexStructure indexStructure;

  newIdx = FindRecordForKey(recHandler, key);

  if (newIdx == 0)      // no key match anywhere
  {
    newIdx = recHandler->NewRecordObject(indexStructure);
    indexStructure->SetKey(strlen(key), key);
    if (*key == 1)
      TTextDocument(recHandler->fDocument)->fBookmarkRec = newIdx;
  }
  else
    indexStructure = TIndexStructure(recHandler->GetRecordObject(newIdx, kReadWrite));
  indexStructure->InsertEntry(newIdx, homeCurr, qual);
  return newIdx;
}

// ------------------------------------------------------------------------
void _TTextStructure::PasteIndexRef(PPhrase phr, TCurrency currency, TTextDocument clipDoc)
{
  TClipTemp *indexInfo = (TClipTemp *)phr->tag.paste.fPadding;

  phr->tag.indexRef.fOtherEnd = indexInfo->otherEnd;
  phr->tag.indexRef.fIndexRec = CreateIndexRec(indexInfo->key, indexInfo->qual,
                                            clipDoc, Curr2HomeCurr(phr, currency));
  DisposIfHandle(indexInfo);
}

// ------------------------------------------------------------------------
TCurrency _TTextStructure::Curr2HomeCurr(PPhrase phrase, TCurrency curr)
{
  PPhrase aPhrase;

#ifdef TRACE
  Assert(fFirstOffset == 0, 601);
#endif
  for (aPhrase = PPhrase(fPtrToArray); aPhrase < phrase; aPhrase++)
    if (aPhrase->fKind == kIndexRefPhrase)
      curr += 256;
  return curr;
}

// ------------------------------------------------------------------------
int _TTextStructure::AddIndexRef(TCurrency curr, TSelection selection)
{
  TCursorNode anchor = selection->GetAnchorOwner();
  TCursorNode activeEnd = selection->GetActiveOwner();
  TCharPos anchorPos = TTextCursor(anchor)->GetCharPos();
  TCharPos caret = TTextCursor(activeEnd)->GetCharPos();
  int firstCh;
  int newPhraseIdx;
  TPhrase phrase;

  phrase.fCharPos = anchorPos;
  phrase.fKind = kIndexRefPhrase;
  // filled in later: phrase.tag.indexRef.fIndexRec = recordIdx;
  phrase.tag.indexRef.fOtherEnd = caret - anchorPos;
  firstCh = GetChar(anchorPos);
  anchorPos++;
  InsertChar(firstCh, anchorPos);
  phrase.fNumChars = 1;
  UpdatePhrases(anchorPos, 1, FALSE, FALSE);
  newPhraseIdx = Insert(&phrase);
  NewEditPhrase(phrase.fCharPos, 1, FALSE);
  NewEditPhrase(anchorPos, 1, TRUE);
  MarkToTop(curr);
  return Curr2HomeCurr(PPhrase(At(newPhraseIdx)), curr);
}

// ------------------------------------------------------------------------
void _TTextStructure::HideIndexRef(TCurrency curr, PPhrase phrase)
{
  int firstCh;
  int phrasePos = phrase->fCharPos;

  firstCh = GetChar(phrasePos);
  UpdatePhrases(phrasePos + 1, 1, FALSE, FALSE);
         // the + 1 extends emphases at same position, rather than moving them right
  phrase->fCharPos = phrasePos + 1;
  phrase->fNumChars = 1;
         // ... but do need to move the index phrase into deletion phrase & reset numChars
  InsertChar(firstCh, phrasePos);         // may move phrase! so do after using it
  NewEditPhrase(phrasePos, 1, FALSE);     // insertion over original first letter
  NewEditPhrase(phrasePos + 1, 1, TRUE);  // deletion phrase over index & letter copy
  MarkToTop(curr);
}

// ------------------------------------------------------------------------
void _TTextStructure::DeleteIndexRef(PPhrase phr, TCurrency currency)
{
  int recNum = phr->tag.indexRef.fIndexRec;
  TIndexStructure indexStruct;

  currency = Curr2HomeCurr(phr, currency);
  indexStruct = fDocument->GetIndexStructure(recNum, kReadWrite + 2);
  if (indexStruct)    // 09/08/95 avoid fail in Commit with corrupt documents
  {
    indexStruct->DeleteEntry(currency);
    if (indexStruct->fSize == 0)
      DeleteIndexRecord(fDocument->fStructureHandlers[kIndexRefStruct], recNum);
  }
}

// ------------------------------------------------------------------------
void _TTextStructure::ResetIndexRef(PPhrase phr, TCurrency srcCurrency, TCurrency currency)
{
  TIndexStructure indexStruct;
  TIndexRef indexRef;

  indexStruct = fDocument->GetIndexStructureReadWrite(phr->tag.indexRef.fIndexRec);
  indexStruct->RemoveEntry(srcCurrency, &indexRef);
  indexRef.fHomeCurrency = Curr2HomeCurr(phr, currency);
  indexStruct->Insert(&indexRef);
}


// ************************************************************************
_TIndexStructure::_TIndexStructure(TTextDocument itsDocument, TIndexKind kind)
                              : (sizeof(TIndexRef))
{
  fDocument = itsDocument;
  fKind = kind;
}

// ------------------------------------------------------------------------
long _TIndexStructure::DoNeedDiskSpace(long dataForkBytes)
{
  return _TArray::DoNeedDiskSpace(dataForkBytes -
                  (int(sizeof(_TIndexStructure)) - int(sizeof(_TArray))) + 3 +
                  GetHandleSize(fPtrToArray) - fSize * int(sizeof(TIndexRef)));
}

// ------------------------------------------------------------------------
void _TIndexStructure::DoRead(int aRefNum, long remainder, int version)
{
  _TArray::DoRead(aRefNum, remainder -
             (int(sizeof(_TIndexStructure)) - int(sizeof(_TArray))) + 1, version);
              // the inherited read w/o top 3 bytes of fKind + fDocument
}

// ------------------------------------------------------------------------
void _TIndexStructure::DoWrite(int aRefNum, long remainder)
{
  _TArray::DoWrite(aRefNum, remainder -
             (int(sizeof(_TIndexStructure)) - int(sizeof(_TArray))) + 1);
}

// ------------------------------------------------------------------------
void _TIndexStructure::DoReadArrayPart(int aRefNum, int version)
{
  long count = 0;

  FRead(aRefNum, 2, &count);
  if (count != 0)
  {
    SetPermHandleSize(&fPtrToArray, count);
    FRead(aRefNum, count, fPtrToArray); // read the array
  }
}

// ------------------------------------------------------------------------
void _TIndexStructure::DoWriteArrayPart(int aRefNum)
{
  int count = GetHandleSize(fPtrToArray);

  FWrite(aRefNum, 2, &count);          // write the array length in 2 bytes
  FWrite(aRefNum, count, fPtrToArray); // write the array
}

// ------------------------------------------------------------------------
int _TIndexStructure::Compare(Ptr item1, Ptr item2)
{
  int item1idx = PIndexRef(item1)->fIndexInText;
  int item2idx = PIndexRef(item2)->fIndexInText;
  int Compare_r;

  if (PIndexRef(item1)->fHomeCurrency < 0x10000 && *GetTextOffset(item1idx) == 0)
    item1idx = MAXLONGINT;
  if (PIndexRef(item2)->fHomeCurrency < 0x10000 && *GetTextOffset(item2idx) == 0)
    item2idx = MAXLONGINT;
  Compare_r = item1idx - item2idx;

  if (Compare_r == 0)
  {
    if (PIndexRef(item1)->fHomeCurrency < 0x10000)
    {
      if (PIndexRef(item2)->fHomeCurrency >= 0x10000)
        Compare_r = 1;
      else
      {
        TIndexStructure r1 =
                   fDocument->GetIndexStructureReadOnly(PIndexRef(item1)->fHomeCurrency);
        TIndexStructure r2 =
                   fDocument->GetIndexStructureReadOnly(PIndexRef(item2)->fHomeCurrency);

        Compare_r = MyCompare(r1->GetKey(), r2->GetKey());  // sort on See ref names
      }
    }
    else if (PIndexRef(item2)->fHomeCurrency < 0x10000)
      Compare_r = -1;
    else
      Compare_r = PIndexRef(item1)->fHomeCurrency - PIndexRef(item2)->fHomeCurrency;
  }
  return Compare_r;
}

// ------------------------------------------------------------------------
char *_TIndexStructure::GetTextOffset(int n)
{
  return (char *)fPtrToArray + (fSize * sizeof(TIndexRef)) + n;
}


// ------------------------------------------------------------------------
void _TIndexStructure::SetKey(int textlen, char *text)
{
  InsertSlice(0, text, textlen + 1);
}

// ------------------------------------------------------------------------
char *_TIndexStructure::GetKey()
{
  return GetTextOffset(0);
}

// ------------------------------------------------------------------------
void _TIndexStructure::ResetBackRef(TCurrency homeCurrency, TCurrency myRef, int inc)
{
  TIndexStructure homeRec;

  homeRec = fDocument->GetIndexStructureReadWrite(homeCurrency);

  for (int k = 0; k < homeRec->fSize; k++)
  {
    PIndexRef indexEntry = PIndexRef(homeRec->fPtrToArray) + k;

    if (indexEntry->fHomeCurrency == myRef)
    {
      indexEntry->fHomeCurrency += inc;
      break;
    }
  }
}

// ------------------------------------------------------------------------
void _TIndexStructure::RemoveEntry(TCurrency currency, PIndexRef indexRef)
{
  for (int i = 0; i < fSize; i++)
  {
    PIndexRef indexEntry = PIndexRef(fPtrToArray) + i;

    if (indexEntry->fHomeCurrency == currency)
    {
      *indexRef = *indexEntry;
      Delete(i + 1);
      return;
    }
  }
#ifdef TRACE
  SysBeep(0);
#endif
}

// ------------------------------------------------------------------------
void _TIndexStructure::DeleteIt(int idx)
// delete the entry with homeCurrency 'currency', reset the text pointers if the
// only one which references the string
{
  PIndexRef indexEntry = PIndexRef(At(idx));

  int oldTextIdx = indexEntry->fIndexInText;
  int oldLen = strlen(GetTextOffset(oldTextIdx)) + 1;

  Delete(idx);

  // reset the text pointers
  if (oldLen > 1)   // its too complicated to take out the zero for unqualified refs!
  {
    for (int i = 0; i < fSize; i++)
    {
      PIndexRef indexEntry = PIndexRef(fPtrToArray) + i;
      int indexInText = indexEntry->fIndexInText;

      if (indexInText == oldTextIdx)
        return;                                  // another entry points to qualifier

      if (indexInText > oldTextIdx)
        indexEntry->fIndexInText -= oldLen;
    }
    DeleteSlice(oldTextIdx + fSize * sizeof(TIndexRef), oldLen);
  }
}

// ------------------------------------------------------------------------
void _TIndexStructure::DeleteEntry(TCurrency currency)
// find the entry for supplied home currency, delete it and any see reference to it
{
  for (int i = 0; i < fSize; i++)
  {
    PIndexRef indexEntry = PIndexRef(fPtrToArray) + i;

    if (indexEntry->fHomeCurrency == currency)
    {
      DeleteIt(i + 1);
      if (Curr_fType(currency) == kSeeRef)
      {
        // delete the see reference to me
        int homeRecNum = ((unsigned int)currency) >> 16;
        int qualItem = (homeRecNum << 16) + kSeeRef;
        TIndexStructure homeRec = fDocument->GetIndexStructureReadWrite(homeRecNum);
        int homeIdx = (((unsigned int)currency) >> 8) & 255;
        int idxToDel = 0;   // 24/11/95

        for (int ii = 0; ii < homeRec->fSize; ii++)
        {
          PIndexRef indexEntry = PIndexRef(homeRec->fPtrToArray) + ii;

          if (indexEntry->fHomeCurrency < 0x10000)
          {
            if (homeIdx == 0)
              idxToDel = ii + 1;   // 24/11/95 homeRec->DeleteIt(ii + 1);
            else if (homeIdx < 0)
              homeRec->ResetBackRef(indexEntry->fHomeCurrency, qualItem, -256);

            qualItem += 256;
            homeIdx--;
          }
        }
        if (idxToDel > 0)
          homeRec->DeleteIt(idxToDel);   // 24/11/95 avoid deleting element inside loop
      }
      break;
    }
  }
}


// ------------------------------------------------------------------------
int _TIndexStructure::InsertEntry(int myRecNum, TCurrency currency, char *text)
{
  // inserting or replacing
  int unfound = 1;
  char *p;
  char *e = (char *)fPtrToArray + GetHandleSize(fPtrToArray);
  int newLen = strlen(text) + 1;
  TIndexRef indexRef;
  int qualItem;
  int insertIdx;
  PIndexRef ir;

  // NB MyCompare strips off leading punctuation

  // find if there are any refs to the new text already
  for (p = GetKey(); p += strlen(p) + 1, p < e; )
  {
    if (MyCompare(p, text) >= 0) 
                  // matched or just past point where new text needs to be added
    {
      unfound = strcmp(p, text);    // we will insert text if not (exactly?) the same
      break;
    }
  }
  indexRef.fHomeCurrency = currency;
  indexRef.fIndexInText = p - (char *)fPtrToArray - fSize * sizeof(TIndexRef);
  indexRef.fNumberFormat = 0;
  indexRef.fPageNumber = 0;

  if (unfound)
  {
    InsertSlice(p - (char *)fPtrToArray, text, newLen);

    // update the qualifier string pointers
    for (int i = 0; i < fSize; i++)
    {
      PIndexRef indexEntry = PIndexRef(fPtrToArray) + i;

      if (indexEntry->fIndexInText >= indexRef.fIndexInText)
        indexEntry->fIndexInText += newLen;
    }
  }

  // find last home currency before new insert
  qualItem = (myRecNum << 16) + kSeeRef;
  for (ir = PIndexRef(fPtrToArray) + fSize; --ir >= PIndexRef(fPtrToArray); )
    if (ir->fHomeCurrency < 0x10000)
      qualItem += 256;

  insertIdx = Insert(&indexRef);

  // need to go b/wds so we do not end up with duplicate back refs during loop
  // only need to process the entries after the one just inserted, which leaves its
  // home currency in qualItem
  for (ir = PIndexRef(fPtrToArray) + fSize; --ir >= PIndexRef(fPtrToArray) + insertIdx; )
    if (ir->fHomeCurrency < 0x10000)
    {
      qualItem -= 256;
      if (currency < 0x10000)    // if we have inserted a see reference, adjust backrefs
        ResetBackRef(ir->fHomeCurrency, qualItem, 256);
    }

  return qualItem;
}

// ------------------------------------------------------------------------
char *_TIndexStructure::GetQualifier(TCurrency currency)
{
  // search for a match and return its text
  for (int i = 0; i < fSize; i++)
  {
    PIndexRef p = PIndexRef(fPtrToArray) + i;

    if (p->fHomeCurrency == currency)
      return GetTextOffset(p->fIndexInText);
  }
  return "";
}

// ------------------------------------------------------------------------
bool _TIndexStructure::IsShown(PIndexRef iref)
{
  // search for a match and return its text
  TCurrency homeCurrency = iref->fHomeCurrency;
  TStructure homeStruct = fDocument->GetStructure(homeCurrency, kReadOnly + 2); // for corruptions

  if (homeStruct)
    return homeStruct->IsShown(homeCurrency & 0xffff00ff, (homeCurrency & 0xff00) + 256);
  return FALSE;
}

#ifndef NETWP
// ************************************************************************
_TIndexCommand::_TIndexCommand(CmdNumber cmd, TTextDocument itsDocument, char *key,
char *qualifier, TCurrency homeCurrency, int updateIdx, TCurrency oldCurrency, char *seeQual)
                                               : (cmd, itsDocument)
{
  // cmd: Add, Update or Delete (Find is not a command)
  // key is the text of the main entry
  // qualifier is the text of its qualifier (or "" if none)
  // homeCurrency is either the text currency + phrase index * 256, i.e. if >= 0x10000
  //              or the number of the record containing the See... key
  // seeQual is the qualifier for the See... entry (or "" if none) if homeCurrency < 0x10000
  // updateIdx: for update or delete is the record number containing the selected entry
  // oldCurrency: the home currency in the updateIdx record of the selected entry
  fSourceCurrency = homeCurrency;
  fUpdateIdx = updateIdx;
  fOldCurrency = oldCurrency;
  strncpy(fKey, key, kKeyMaxLen);
  strncpy(fQualifier, qualifier, kQualifierMaxLen);
  strncpy(fSeeTextQual, seeQual, kQualifierMaxLen);
#ifndef ZERO_OBJ
  fRemoveOnFree = 0;
#endif
}

// ------------------------------------------------------------------------
static void CommitHandler(TRecordHandler recHandler, unsigned int recNum)
{
  TIndexStructure rec;

  if ((recNum - 1) < 0xffff &&
    (rec = TIndexStructure(recHandler->GetRecordObject(recNum, kReadOnly + 2))) != NULL &&
     rec->fSize == 0)
  {
    DeleteIndexRecord(recHandler, recNum);
  }
}

// ------------------------------------------------------------------------
void _TIndexCommand::Free()
{
  TRecordHandler recHandler =
                TTextDocument(fChangedDocument)->fStructureHandlers[kIndexRefStruct];
  int handlerRec = FindRecordForKey(recHandler, fKey);
  int sourceRec = fSourceCurrency;

  _TStructureCmd::Free();

  // must not access this objects fields now
  CommitHandler(recHandler, handlerRec);
  CommitHandler(recHandler, sourceRec);
}

// ------------------------------------------------------------------------
void _TIndexCommand::Commit()
{
  _TStructureCmd::Commit();
}

// ------------------------------------------------------------------------
void _TIndexCommand::DoPostCommand()
{
  TTextDocument doc = TTextDocument(fChangedDocument);
  TSelection selection = doc->GetSelection(FALSE);

  doc->ResetSelection(TSelection(selection->Clone()));
}

// ------------------------------------------------------------------------
static PPhrase HomeCurr2Phrase(TTextStructure textStruc, TCurrency sourceCurrency)
{
  int phrIdx = (((unsigned int)sourceCurrency) >> 8) & 255;

  for (int i = 1; i <= textStruc->fSize; i++)
  {
    PPhrase phr = PPhrase(textStruc->At(i));

    if (phr->fKind == kIndexRefPhrase)
    {
      if (phrIdx == 0)
        return phr;
      phrIdx--;
    }
  }
  return NULL;
}

// ------------------------------------------------------------------------
void _TIndexCommand::DoCommand(TSelection selection)
{
  // create or update the appropriate TIndexStructure
  TTextDocument doc = TTextDocument(fChangedDocument);

  if (fCmdNumber == cAddBookMenu && *fKey == 1 && *fQualifier == 0 && doc->fBookmarkRec)
  {
    // see if there is already a blank entry (to delete)
    TIndexStructure index = doc->GetBookmarkReadOnly();
                                 // doc->GetIndexStructureReadOnly(doc->fBookmarkRec);

    if (index->fSize > 0)
    {
      PIndexRef firstRef = PIndexRef(index->At(1));

      // 09/08/95 [26047] Use firstRef->fIndexInText instead of 2 as delete does not tidy
      // properly. A preceeding delete untitled bookmark will leave a zero byte at offset 2
      if (*index->GetTextOffset(firstRef->fIndexInText) == 0)  // first entry is untitled!
      {
        TTextStructure textStruct;
        PPhrase phr;
        TCurrency homeCurr = firstRef->fHomeCurrency;

        textStruct = TTextStructure(doc->GetStructureReadWrite(homeCurr));
        phr = HomeCurr2Phrase(textStruct, homeCurr);
        textStruct->DeleteIndexRef(phr, homeCurr & 0xffff00ff);
#ifdef TRACE
        Assert(textStruct->fFirstOffset == 0, 602);
#endif
        textStruct->Delete((phr - PPhrase(textStruct->fPtrToArray)) + 1);
      }
    }
  }

  selection->fReformatType = kReformatLine;      // redraw para for 'show indexes'

  if (fSourceCurrency >= 0x10000 || (fUpdateIdx != 0 && Curr_fType(fOldCurrency) != kSeeRef))
  {
    TCursorNode anchor = selection->GetAnchorOwner();
    TCurrency startCurrency = anchor->fCurrency;
    TStructure structure =
            TTextDocument(fChangedDocument)->GetStructureReadWrite(startCurrency);

    // recalculate things which may have been changed by Commit, using selection
    if (Curr_fType(startCurrency) == kTextStruct && fUpdateIdx != 0)
                          // preserve fUpdateIdx if adding bookmark over index or v.v.
    {
      fUpdateIdx = (fCmdNumber == cRemoveBookmark ? 1 : 0);  // find bookmarks for delete bookmark
      startCurrency = TTextStructure(structure)->GetIndexPhraseAt(startCurrency,
                                        TTextCursor(anchor)->GetCharPos(), fUpdateIdx);
      if (startCurrency != 0)
      {
        if (fSourceCurrency  >= 0x10000)
          fSourceCurrency = startCurrency;    // preserve if converting a text ref to see...
        fOldCurrency = startCurrency;
      }
    }

    if (fSourceCurrency >= 0x10000 && *fKey != 0)   // fCmdNumber != cDeleteIndex)
    {
      if (fUpdateIdx == 0 || Curr_fType(fOldCurrency) == kSeeRef)
      {
        fSourceCurrency = TTextStructure(structure)->
                           AddIndexRef(fSourceCurrency & 0xffff00ff, selection);
      }
    }
    else if (fUpdateIdx != 0 && Curr_fType(fOldCurrency) == kTextStruct)
    {
      // delete or update a text ref to see... ref

      TTextStructure(structure)->HideIndexRef(fOldCurrency & 0xffff00ff, 
               HomeCurr2Phrase(TTextStructure(structure), fOldCurrency));
           //phr);
    }
  }
  doc->ResetSelection(selection);
  DoUndoAction();
}

// ------------------------------------------------------------------------
void _TIndexCommand::DoUndoAction()
{
  // the basic operation (where the selected item may be nothing) is:
  // copy into local storage enough to recreate the 'selected' item
  // delete the 'selected' item
  // with the command fields build a new entry
  // ensure text now points at the created entry
  // make that the 'selected' item (set fUpdateIdx & fOldCurrency)
  // copy the local storage into the command fields

  TRecordHandler recHandler;
  // int temp = fUpdateIdx;
  int recordIdx = 0;
  int qualItem = 0;
  unsigned int oldSourceCurr = 0;
  char key[kKeyMaxLen];
  char qualifier[kQualifierMaxLen];
  char seeTextQual[kQualifierMaxLen];

  *key = *qualifier = *seeTextQual = 0;
  if (fUpdateIdx != 0)
  {
    // there is an entry to delete
    TIndexStructure oldStructure =
                   TTextDocument(fChangedDocument)->GetIndexStructureReadWrite(fUpdateIdx);
    TIndexStructure seeingStructure = oldStructure;

    strncpy(qualifier, oldStructure->GetQualifier(fOldCurrency), kQualifierMaxLen);
    oldSourceCurr = fOldCurrency;
    if (Curr_fType(oldSourceCurr) == kSeeRef)
    {
      // it is a see... entry, so we need to extract the referencing info
      int seeingRec = oldSourceCurr >> 16;
      int homeIdx = (oldSourceCurr >> 8) & 255;

      seeingStructure =
              TTextDocument(fChangedDocument)->GetIndexStructureReadOnly(seeingRec);
      strncpy(seeTextQual, qualifier, kQualifierMaxLen);
      oldSourceCurr = fUpdateIdx;      // seeingRec;

      for (int ii = 0; ii < seeingStructure->fSize; ii++)
      {
        PIndexRef indexEntry = PIndexRef(seeingStructure->fPtrToArray) + ii;

        if (indexEntry->fHomeCurrency < 0x10000)
        {
          if (homeIdx == 0)
          {
            strncpy(qualifier,
                seeingStructure->GetTextOffset(indexEntry->fIndexInText), kQualifierMaxLen);
            break;
          }
          homeIdx--;
        }
      }
    }
    strncpy(key, seeingStructure->GetKey(), kKeyMaxLen);
    // now we can delete the selected item
    oldStructure->DeleteEntry(fOldCurrency);
  }

  // now find the record to update, creating one if necessary
  if (*fKey)
  {
    TIndexStructure indexStructure;

    recHandler = TTextDocument(fChangedDocument)->fStructureHandlers[kIndexRefStruct];
    recordIdx = FindRecordForKey(recHandler, fKey);
    if (recordIdx == 0)
    {
      // need to create a record
      fRemoveOnFree = TRUE;
      recordIdx = recHandler->NewRecordObject(indexStructure);
      indexStructure->SetKey(strlen(fKey), fKey);
      if (*fKey == 1)
        TTextDocument(recHandler->fDocument)->fBookmarkRec = recordIdx;
    }
    else
      indexStructure =
                 TTextDocument(fChangedDocument)->GetIndexStructureReadWrite(recordIdx);

    // now create a new entry with the command fields
    qualItem = indexStructure->InsertEntry(recordIdx, fSourceCurrency, fQualifier);
    if (fSourceCurrency >= 0x10000)
    {
      // reset the index record number in the text phrase
      TTextStructure textStruct;
      PPhrase phr;

      qualItem = fSourceCurrency;
      textStruct = TTextStructure(TTextDocument(fChangedDocument)->
                                               GetStructureReadWrite(qualItem));
      phr = HomeCurr2Phrase(textStruct, qualItem);
      if (phr != NULL)
        phr->tag.indexRef.fIndexRec = recordIdx;  // reset to 'current' record
    }
    else
    {
      // a see reference, so add in the backward reference
      TIndexStructure seeStructure =
              TTextDocument(fChangedDocument)->GetIndexStructureReadWrite(fSourceCurrency);

      seeStructure->InsertEntry(fSourceCurrency, qualItem, fSeeTextQual);
      recordIdx = fSourceCurrency;
    }
  }

  // now set up for the next toggle
  fUpdateIdx = recordIdx;

  fSourceCurrency = oldSourceCurr;
  fOldCurrency = qualItem;

  strncpy(fQualifier, qualifier, kQualifierMaxLen);
  strncpy(fKey, key, kKeyMaxLen);
  strncpy(fSeeTextQual, seeTextQual, kQualifierMaxLen);
}

// ------------------------------------------------------------------------
void _TIndexCommand::UndoIt()
{
  DoUndoAction();
  _TStructureCmd::UndoIt();
}

// ************************************************************************
_TIndexDlgHelper::_TIndexDlgHelper(TTextDocument doc) : (doc)
{
  fDocument = doc;
#ifndef ZERO_OBJ
  fStartCurrency = 0;
  fUpdateIdx = 0;
  fDlogDepth = 0;
#endif
}

#define kRuleDescrs 40

// ------------------------------------------------------------------------
TCommand _TIndexDlgHelper::ReadFromDialog(TView aDialog, CmdNumber aCmd, IDType itsId)
{
  char key[kKeyMaxLen];
  char qualifier[kQualifierMaxLen];
  TCurrency startCurr = fStartCurrency;
  TControl keyBtn = TControl(aDialog->FindSubView(I_(0, 'k', 'e', 'y')));

  keyBtn->GetText(key);
  if (itsId == I_('f', 'i', 'n', 'd') && fStartCurrency >= 0x10000)
  {
    TMainView mv = fDocument->ActiveMainView();

    fKeepFields = TRUE;
    return new _TFindCommand(cFind, mv, *fSelectedText ? fSelectedText : key);
  }

  TControl(aDialog->FindSubView(I_(0, 'q', 'a', 'l')))->GetText(qualifier);

  if (itsId == I_(0, 'd', 'e', 'l'))
  {
    aCmd = cDeleteIndex;
    *key = 0;
    fStartCurrency = 0;  // it could be invalidated by Commit?
  }
  else if (*key == 0)
    return gNoChanges;
  if (aCmd == cAddToIndex || fUpdateIdx != 0)
    return new _TIndexCommand(aCmd, fDocument, key, qualifier,
             startCurr, aCmd == cAddToIndex ? 0 : fUpdateIdx, fOldCurrency, fSeeTextQual);
  return gNoChanges;
}

// ------------------------------------------------------------------------
static void DimOK(TDialogView dlg, int newState)
{
  dlg->SetDimState(gIDOKbn, newState);
}

// ------------------------------------------------------------------------
void _TIndexDlgHelper::WriteToDialog(TView aDialog, CmdNumber aCmd)
{
  TSelection selection = fDocument->GetNewSelection();
  TCursorNode activeEnd = selection->GetActiveOwner();
  TCursorNode anchor = selection->GetAnchorOwner();
  TCurrency startCurrency = anchor->fCurrency;
  TStructure structure;

  *fSelectedText = 0;
  if (fDlogDepth == 0)
    fDlogDepth = aDialog->fSize.v;
  fNextHandler = aDialog;

  fStartCurrency = startCurrency;
  structure = fDocument->GetStructureReadOnly(startCurrency);

  if (Curr_fType(startCurrency) == kTextStruct)
  {
    fUpdateIdx = 0;
    fOldCurrency = TTextStructure(structure)->GetIndexPhraseAt(startCurrency,
                                        TTextCursor(anchor)->GetCharPos(), fUpdateIdx);
    
    structure->GetSelectedText(startCurrency, anchor, activeEnd, fSelectedText);
  }
  if (aCmd == cAddToIndex)
  {
    TheDlg()->WriteText(I_('f', 'i', 'n', 'd'),
                            GetIndString(54, *fSelectedText == 0 ? 7 : 8));
    DimOK(TheDlg(), fUpdateIdx != 0);
  }

  if (fKeepFields)
    fKeepFields = FALSE;
  else
    SetDialog(fSelectedText, aCmd);
}

// -------------------------------------------------------------------------
static void BuildQualMenu(TPopup origView, TRecordIndex aRecord, TRecordHandler handler,
              char *key, int *selectedRec)
{
  TIndexStructure indexStructure =
                      TIndexStructure(handler->GetRecordObject(aRecord, kReadOnly));

  if (strcmp(indexStructure->GetKey(), key) == 0)
  {
    MenuHandle* theMenu = GetResMenu(cmQualIndex);
    int lastIdx = -1;
    int state = 0;

    if (origView->fIdentifier == I_('p', 'q', 'a', 'l'))
      AppendMenuItem(theMenu, GetIndString(kRuleDescrs, 0));  // "None"

    if (selectedRec)
      *selectedRec = aRecord;
    for (int i = 1; i <= indexStructure->fSize; i++)
    {
      PIndexRef iRef = PIndexRef(indexStructure->At(i));
      int thisIdx = iRef->fIndexInText;

      if (iRef->fHomeCurrency >= 0x10000 && Curr_fType(iRef->fHomeCurrency) == kSeeRef &&
                              origView->fIdentifier == I_('p', 's', 'e', 'l'))
        continue;

      if (thisIdx != lastIdx)
      {
        char *qualText = indexStructure->GetTextOffset(thisIdx);

        if (qualText[0] != 0)
        {
          int item = AppendMenuItem(theMenu, qualText);

          if (origView->fIdentifier == I_('p', 's', 'e', 'l'))
            SetDynamic(*theMenu, item, 50);
          state = 1;
        }
        else if (origView->fIdentifier == I_('p', 's', 'e', 'l'))
        {
          int item = AppendMenuItem(theMenu, GetIndString(54, state == 0 ? 4 : 2));

          SetDynamic(*theMenu, item, 50);
        }
        lastIdx = thisIdx;
      }
    }
  }
}

// -------------------------------------------------------------------------
CmdNumber NameToCmdLetter(char *key)
{
  int cmd;

  if (isdigit(*key))
    cmd = cIndexDigits;
  else
  {
    cmd = SearchMenu(GetResMenu(cmIndexLetters), key, 2);
    if (cmd >= 3 && MyCompare(key, "\\") < 0)
      cmd += cIndexDigits;
    else
      cmd = cIndexSymbol;
  }
  return cmd;
}

// -------------------------------------------------------------------------
static void BuildIndexMenu(TPopup origView, TRecordIndex aRecord, TRecordHandler handler,
              MenuHandle *theMenu, CmdNumber theCmd)
{
  TIndexStructure indexStructure =
                      TIndexStructure(handler->GetRecordObject(aRecord, kReadOnly));
  char *key;

  if (indexStructure->fSize > 0 && (key = indexStructure->GetKey(), *key != 1))
  {
    int setMenu = 1;    // 0 means no menu, 2 means make it dynamic

    if (theCmd != 0 && NameToCmdLetter(key) != theCmd)
      return;

    if (origView->fIdentifier != I_('p', 'k', 'e', 'y'))
    {
      setMenu = 0;

      for (int i = 1; i <= indexStructure->fSize; i++)
      {
        PIndexRef thisEntry = PIndexRef(indexStructure->At(i));

        if (thisEntry->fHomeCurrency < 0x10000 ||
          (Curr_fType(thisEntry->fHomeCurrency) != kSeeRef && indexStructure->IsShown(thisEntry)))
        {
          setMenu = 1;
          if (indexStructure->GetTextOffset(thisEntry->fIndexInText)[0] != 0
                         || origView->fIdentifier == I_('p', 's', 'e', 'l'))
          {
            setMenu = 2;
            break;
          }
        }
      }
    }
    if (setMenu != 0)
    {
      int item = AddSortedCountry(theMenu, key, 0);

      if (setMenu > 1)
        SetDynamic(*theMenu, item, cmQualIndex);  // make dynamic if any qualifiers
    }
  }
}

// ------------------------------------------------------------------------
void _TIndexDlgHelper::SetDialog(char *selectedText, CmdNumber aCmd)
{
  TDialogView dlg = TheDlg();
  int newResize = fDlogDepth;
  TIndexStructure indexStructure = NULL;
  char *newQual;
  char newText[kKeyMaxLen + kQualifierMaxLen + 4];

  *newText = 0;
  newQual = newText;
  if (fUpdateIdx != 0)
  {
    indexStructure = fDocument->GetIndexStructureReadOnly(fUpdateIdx);
    if (Curr_fType(fOldCurrency) == kSeeRef)
    {
      int homeIdx;

      strcpy(newText, indexStructure->GetKey());
      newQual = indexStructure->GetQualifier(fOldCurrency);
      strncpy(fSeeTextQual, newQual, kQualifierMaxLen);
      if (*newQual)
        sprintf(newText + strlen(newText), " (%s)", newQual);
      indexStructure = fDocument->GetIndexStructureReadOnly(((unsigned int)fOldCurrency) >> 16);

      homeIdx = (fOldCurrency >> 8) & 255;
      for (int ii = 0; ii < indexStructure->fSize; ii++)
      {
        PIndexRef indexEntry = PIndexRef(indexStructure->fPtrToArray) + ii;

        if (indexEntry->fHomeCurrency < 0x10000)
        {
          if (homeIdx == 0)
          {
            newQual = indexStructure->GetTextOffset(indexEntry->fIndexInText);
            break;
          }
          homeIdx--;
        }
      }
    }
    else
      newQual = indexStructure->GetQualifier(fOldCurrency);
  }
  else if (aCmd == cUpdateIndex)
    newResize = OStoQD(64);

  DimOK(dlg, fUpdateIdx != 0 && aCmd == cAddToIndex);

  dlg->WriteText(I_(0, 'k', 'e', 'y'), indexStructure ?
                                      indexStructure->GetKey() : selectedText);
  dlg->WriteText(I_(0, 'q', 'a', 'l'), newQual);
  dlg->WriteText(I_(0, 's', 'e', 'e'), newText);
  dlg->Resize(dlg->fSize.h, newResize, kRedraw);
}

// -------------------------------------------------------------------------
static void EnableLettersMenu(TPopup origView, TRecordIndex aRecord, TRecordHandler handler)
{
  TIndexStructure indexStructure =
                      TIndexStructure(handler->GetRecordObject(aRecord, kReadOnly));
  char *key = indexStructure->GetKey();
  int cmd = NameToCmdLetter(key);

  if (*key != 1)
    EnableCmd(cmd);
}

// ------------------------------------------------------------------------
static void BuildLettersMenu(TRecordHandler recHandler)
{
  DisableMenu(cmIndexLetters);
  recHandler->ForAllRecordsDo(NULL, (DoToRecord)EnableLettersMenu);
}

// ------------------------------------------------------------------------
void GotoPhrase(TTextDocument doc, TCurrency oldCurrency)
{
  TTextStructure textStruct;
  PPhrase phr;

  textStruct = TTextStructure(doc->GetStructureReadOnly(oldCurrency));
  phr = HomeCurr2Phrase(textStruct, oldCurrency);

  if (phr != NULL)    // which it should be!
  {
    TSelection hitSelection;
    TSelection selection;
    int startPos = phr->fCharPos;
    int endPos = phr->tag.indexRef.fOtherEnd;
    TTextCursor node;
    TCurrency textCurr = oldCurrency & 0xffff00ff;

    doc->HighlightSelection(HLOff, TRUE);
    doc->DoneTyping();
    hitSelection = new _TSelection(doc);
    selection = doc->GetSelection(TRUE);
    if (endPos == 0)
      hitSelection->InitialCursor(doc->ActiveMainView(), textCurr, 0);
    else
    {
      hitSelection->InitialSelection(doc->ActiveMainView(), textCurr, textCurr);
      hitSelection->SetTarget();
    }
    node = TTextCursor(hitSelection->GetAnchorTarget());
    textStruct->ResetCursor(node, startPos, FALSE, FALSE);  // adjusts start for deletions
    // node->SetCharPos(startPos);
    if (endPos != 0)
    {
      startPos = node->GetCharPos();
      node = TTextCursor(hitSelection->GetActiveTarget());
      node->SetCharPos(endPos + startPos);
    }
    //doc->HighlightSelection(HLOff, TRUE);
    doc->ResetSelection(hitSelection);
    FreeIfObject(selection);
    doc->ScrollAndReset();
    hitSelection->DoMenus(FALSE);
  }
}

// ------------------------------------------------------------------------
void _TIndexDlgHelper::DoChoice(TView origView, int itsChoice)
{
  TRecordHandler recHandler = fDocument->fStructureHandlers[kIndexRefStruct];

  if (itsChoice == mPopupSelect)
    fCurrentPopup = origView;
  else if (itsChoice == mPopupHit)
  {
    char theText[kQualifierMaxLen];
    int menuNum = TPopup(origView)->fMenuID;
    int hitIdx = TPopup(origView)->GetCurrentItem();

    if (menuNum == cmQualIndex && hitIdx == 1)
     theText[0] = 0;
    else
      TPopup(origView)->GetItemText(hitIdx, theText);
    if (origView->fIdentifier == I_(0, 's', 'e', 'e'))
    {
      fStartCurrency = FindRecordForKey(recHandler, theText);
      *fSeeTextQual = 0;
      DimOK(TheDlg(), FALSE);
    }
    if (origView->fIdentifier != I_('p', 's', 'e', 'l'))
      TheDlg()->WriteText(origView->fIdentifier & 0x00ffffff, theText);
  }
  else if (itsChoice == mPopupSubHit)
  {
    int aMenu;
    int item;
    CmdNumber hitCmd = TPopup(origView)->fHitCommand;
    char newText[kKeyMaxLen + kQualifierMaxLen + 4];

    aMenu = CmdToMenuItem(hitCmd, item);
    if (aMenu == cmQualIndex && origView->fIdentifier == I_(0, 's', 'e', 'e'))
    {
      CmdToName(fCurrSubject, newText);
      fStartCurrency = FindRecordForKey(recHandler, newText);
      CmdToName(hitCmd, fSeeTextQual);
      sprintf(newText + strlen(newText), " (%s)", fSeeTextQual);
      TheDlg()->WriteText(origView->fIdentifier, newText);
      DimOK(TheDlg(), FALSE);
    }
    else if (aMenu == cmReferences)
    {
      TIndexStructure indexStructure =
                      TIndexStructure(recHandler->GetRecordObject(fSelectedRec, kReadOnly));
      int i;
      PIndexRef p;

      for (i = fFirst; ; i++)
      {
        p = PIndexRef(indexStructure->fPtrToArray) + i;
        if (p->fHomeCurrency < 0x10000 || Curr_fType(p->fHomeCurrency) != kSeeRef)
        {
          item--;
          if (item == 0)
            break;
        }
      }

      fStartCurrency = p->fHomeCurrency;
      if (p->fHomeCurrency < 0x10000)
      {
        int backCurr = (fSelectedRec << 16) + kSeeRef;
        // char *seeQual;

        for (; i--, i >= 0; )
        {
          PIndexRef pref = PIndexRef(indexStructure->fPtrToArray) + i;

          if (pref->fHomeCurrency < 0x10000)
            backCurr += 256;
        }
        fOldCurrency = backCurr;
        fUpdateIdx = p->fHomeCurrency;
        // indexStructure =
        //            TIndexStructure(recHandler->GetRecordObject(fUpdateIdx, kReadOnly));
        // strcpy(newText, indexStructure->GetKey());
        // seeQual = indexStructure->GetQualifier(backCurr);
        // strncpy(fSeeTextQual, seeQual, kQualifierMaxLen);
        // if (*seeQual)
        //  sprintf(newText + strlen(newText), " (%s)", seeQual);
      }
      else
      {

        fOldCurrency = p->fHomeCurrency;
        fUpdateIdx = fSelectedRec;
        GotoPhrase(fDocument, fOldCurrency);
      }
      SetDialog("", cUpdateIndex);
    }
    else
    {
      CmdToName(hitCmd, newText);
      if (origView->fIdentifier != I_('p', 's', 'e', 'l'))
        TheDlg()->WriteText(origView->fIdentifier & 0x00ffffff, newText);
      if (origView->fIdentifier == I_(0, 's', 'e', 'e'))
      {
        fStartCurrency = FindRecordForKey(recHandler, newText);
        *fSeeTextQual = 0;
        DimOK(TheDlg(), FALSE);
      }
    }
  }
  else if (itsChoice == mPopupSetup)
  {
    int menuNum = TPopup(origView)->fMenuID;

    if (menuNum == cmKeyIndex || menuNum == cmQualIndex)
    {
      MenuHandle* theMenu = GetResMenu(menuNum);

      DelMenuItems(theMenu, 1);      // menuNum == cmQualIndex ? 2 : 1);

      if (menuNum == cmKeyIndex)
      {
        recHandler->ForAllRecordsDo(origView, (DoToRecord)BuildIndexMenu, theMenu, 0);
      }
      else
      {
        TDialogView aDialogView = TheDlg();
        char key[kKeyMaxLen];

        TControl(aDialogView->FindSubView(I_(0, 'k', 'e', 'y')))->GetText(key);
        recHandler->ForAllRecordsDo(origView, (DoToRecord)BuildQualMenu, key, NULL);
      }
      
      if (CountMItems(*theMenu) == 0)
      {
        AppendMenuItem(theMenu, GetIndString(kRuleDescrs, 0));  // "None"
        DisableItem(*theMenu, 1);
      }
    }
    else if (menuNum == cmIndexLetters)
      BuildLettersMenu(recHandler);
  }
}

// -------------------------------------------------------------------------
bool _TIndexDlgHelper::SetupDynamicMenu(CmdNumber aCmdNumber, int menuNum, bool create)
{
  TRecordHandler recHandler = fDocument->fStructureHandlers[kIndexRefStruct];

  if (menuNum == cmQualIndex)
  {
    char key[kKeyMaxLen];

    DelMenuItems(GetResMenu(menuNum), 1);
    CmdToName(aCmdNumber, key);
    recHandler->ForAllRecordsDo(fCurrentPopup, (DoToRecord)BuildQualMenu, key, &fSelectedRec);
    fCurrSubject = aCmdNumber;
  }
  else if (menuNum == cmReferences)
  {
    int idx = 0;
    int lastIdx = -1;
    TIndexStructure indexStructure =
                      TIndexStructure(recHandler->GetRecordObject(fSelectedRec, kReadOnly));
#ifndef TRACE
    MenuHandle* theMenu = GetResMenu(cmReferences);
#endif
    int anItem;

    CmdToMenuItem(aCmdNumber, anItem);
#ifdef TRACE
    DelMenuItems(GetResMenu(cmReferences), 1);
#else
    DelMenuItems(theMenu, 1);
#endif

    for (int i = 1; i <= indexStructure->fSize; i++)
    {
      PIndexRef indexRef = PIndexRef(indexStructure->At(i));
      int thisIdx = indexRef->fIndexInText;

      if (indexRef->fHomeCurrency >= 0x10000 && Curr_fType(indexRef->fHomeCurrency) == kSeeRef)
        continue;

      if (thisIdx != lastIdx)
      {
        anItem--;
        if (anItem == 0)
          fFirst = i - 1;
        lastIdx = thisIdx;
      }
      if (anItem == 0)
      {
        char buff[20];
        TCurrency homeCurr = indexRef->fHomeCurrency;
        char *text = NULL;

        if (homeCurr < 0x10000)
          text = GetIndString(54, 5);      // "See ..."
        else if (Curr_fType(homeCurr) != kSeeRef)
        {
          sprintf(buff, GetIndString(54, 6), ++idx);     // "Ref. #%i"
          text = buff;
        }
        if (text != NULL)
#ifdef TRACE
          AppendMenuItem(GetResMenu(cmReferences), text);
#else
          AppendMenuItem(theMenu, text);
#endif
      }
    }
  }
  else if (menuNum == cmKeyIndex)
  {
    MenuHandle* theMenu = GetResMenu(menuNum);

    DelMenuItems(theMenu, 1);
    recHandler->ForAllRecordsDo(fCurrentPopup, (DoToRecord)BuildIndexMenu, theMenu, aCmdNumber);
  }
  return FALSE;
}

// -------------------------------------------------------------------------
void SetBookmarkMenu(TTextDocument doc, TCurrency homeCurr)
{
  MenuHandle *theMenu;
  int menuNum;
  int menuIdx;

  menuNum = CmdToMenuItem(cRemoveBookmark, menuIdx);
  theMenu = GetResMenu(menuNum);
  menuIdx++;
  DelMenuItems(theMenu, menuIdx);
  if (doc->fBookmarkRec != 0)
  {
    TIndexStructure indexStructure = doc->GetBookmarkReadOnly();

    for (int i = 1; i <= indexStructure->fSize; i++)
    {
      PIndexRef iref = PIndexRef(indexStructure->At(i));

      if (indexStructure->IsShown(iref))
      {
        char *qualText = indexStructure->GetTextOffset(iref->fIndexInText);
        int item = AppendMenuItem(theMenu,
                                  *qualText == 0 ? GetString(kUntitledStr) : qualText);

        if (homeCurr == iref->fHomeCurrency)
        {
          CheckItem(*theMenu, item, TRUE);
          EnableCmd(cRemoveBookmark);
          DisableCmd(cAddBookmark);
        }
      }
    }
  }
  if (CountMItems(*theMenu) < menuIdx)
  {
    AppendMenuItem(theMenu, GetIndString(kRuleDescrs, 0));  // "None"
    DisableItem(*theMenu, menuIdx);
  }
}
#endif
