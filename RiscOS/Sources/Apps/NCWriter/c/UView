/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "msgs.h"
#include "swis.h"

#include "Support.h"

#define kToBeOpened 8

// ------------------------------------------------------------------------
void OffsetPtr(char * &p, int offset)
{
  p = p + offset;
}


// ------------------------------------------------------------------------
int ReadInt(char * &itsParams)
{
   return strtol(itsParams, &itsParams, 10);
}


// ------------------------------------------------------------------------
int ReadHex(char * &itsParams)
{
   return strtoul(itsParams, &itsParams, 16);
}


// ------------------------------------------------------------------------
static char gConvBuff[12];
Fixed ReadFixed(char* &itsParams)
{
  // read a points value into fixed deci-pts
  char *ip;
  char *op = gConvBuff;

  for (ip = itsParams; (*op = *(ip++)) <= 0x20; ) {}   // skip up to 1st non-space
  if (*op == '-')
  {
    itsParams = ip;                                    // return pointer after '-'
    return -1;
  }
  for (; (*(++op) = *(ip++)) > 0x20; ) {}              // copy up to space/control
  *(op++) = '0';
  *(op++) = '0';
  *(op++) = '0';
  *(op++) = '0';
  *op = 0;
  itsParams = ip - 1;                                  // return pointer to terminator
  return atoi(gConvBuff);
}

// ------------------------------------------------------------------------
void ReadString(char * &itsParams, char *stringItem)
{
   char *p;

   for (p = itsParams; (*stringItem = *(p++)) <= 0x20; ) {}

   for (; (*(++stringItem) = *(p++)) > 0x20; ) {}
   *stringItem = 0;
   itsParams = p - 1;    // return pointer to terminator
}


// ------------------------------------------------------------------------
IDType ReadID(char * &itsParams)
{
   char *p;
   IDType id;

   for (p = itsParams; (id = *(p++)) <= '&'; ) {}

   for ( ; *p > '&'; )
     id = (id << 8) | *(p++);
   itsParams = p;
   return id;
}

// ------------------------------------------------------------------------
bool VisibleRect(Rect &r)
{
  return SectRect(r, *thePort->GetClipRect(), r);
}


// ------------------------------------------------------------------------
_TView::_TView(
    TView itsSuperView, VPoint &itsLocation, VPoint &itsSize, SizeDeterminer itsSizeDet) :
                                                                    (itsSuperView)
{
  fLocation = itsLocation;
  fSize = itsSize;
  IView(NULL, itsSuperView);
  fSizeDeterminer = itsSizeDet * 17 + kToBeOpened;
}


// ------------------------------------------------------------------------
_TView::_TView(TDocument itsDocument, TView itsSuperView, char * &itsParams):
        (itsSuperView)
{
  int flagChar;

  IView(itsDocument, itsSuperView);

  fIdentifier = ReadID(itsParams);

  // flag = ! means use standard values: sizeFixed, sizeFixed, toBeOpened, enabled L & R
  //        # means hex digit follows with v & h size definers, toBeOpened, enabled L & R
  //        % means hex digit follows with v & h size definers, toBeOpened, not enabled
  flagChar = *(itsParams++);
  if (flagChar != '!')
  {
    int sizeDet = *(itsParams++);  // read the next (hex) character

    if (sizeDet > '9')
      sizeDet = sizeDet - 'a' + '9' + 1;
    fSizeDeterminer = ((sizeDet & 0x0c) << 2) + (sizeDet & 0x03) + kToBeOpened;
    if (flagChar != '#')
      fViewEnabled = 0;  // 18/02/93 [20706] else leave it at default
  }
  ComputeSize(fSize);
}


// ------------------------------------------------------------------------
void _TView::IView(TDocument itsDocument, TView itsSuperView)
{
  FailInfo fi;

  fSuperView = itsSuperView;
#ifndef ZERO_OBJ
  fSubViews = NULL;
  fPrintHandler = NULL;
  fLocation = gZeroVPt;
  fSize = gZeroVPt;
#endif
  fDocument = itsDocument;
  fSizeDeterminer = sizeFixed * 17 + kToBeOpened;
  fHLDesired = HLOff;
  fIdentifier = gNoIdentifier;
  fShown = TRUE;
  fViewEnabled = wr_wimp_BRIGHT | wr_wimp_BLEFT;     // 18/02/93 [20706] TRUE;

  if (itsDocument != NULL)
  {
    CatchFailures(&fi);
    itsDocument->AddView(this);
    Success(&fi);
  }
  return;

// ****************** Exception handler **********************
Rescue:
  /* Call my Free method, not the general one for the object, as */
  /* inherited object's fields will not yet be initialised!      */
  _TView::Free();
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TView::Free()
{
#ifdef TRACE
  Assert(fDocument == NULL || fDocument->fLastCommand == NULL ||
              fDocument->fLastCommand->fView != this, 743);
#endif
  // 02/05/90 erroneous test which set window fTarget to fNextHandler remvd
  if (IsFocused())
    gApplication->InvalidateFocus();
  if (fSubViews != NULL)
    fSubViews->FreeList();
  fSubViews = NULL;
  if (fSuperView != NULL)
    fSuperView->RemoveSubView(this);
  if (fDocument != NULL)
    fDocument->DeleteView(this);
  FreeIfObject(fPrintHandler);
  if (gTracker != NULL && gTracker->fView == this)
     ClearObject(gTracker);     // 27/01/94 [21365] not very elegant!

  _THandler::Free();
}


// ------------------------------------------------------------------------
void _TView::AddSubView(TView theSubView)
{
  GrafPtr itsGrafPort;
  FailInfo fi;

  if (theSubView != NULL)
  {
     CatchFailures(&fi);
     if (fSubViews == NULL)
     {
        fSubViews = new _TList;
     }
     fSubViews->InsertLast(theSubView);
     Success(&fi);
     theSubView->fSuperView = this;
     if (theSubView->fNextHandler == NULL)
       theSubView->fNextHandler = this;
     itsGrafPort = GetGrafPort();
     if (itsGrafPort != NULL)
       theSubView->BeInPort(itsGrafPort);
     if (theSubView->fNextHandler == NULL)
       theSubView->fNextHandler = this;
  }
  return;

Rescue:
  // 11/06/91 rule is that once passed to AddSubView, superview is
  // responsible for it, so we must free it if it has not been 'adopted'
  FreeIfObject(theSubView);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TView::AdjustSize()
{
  VPoint newSize;

  newSize = fSize;
  ComputeSize(newSize);
  if (newSize.h != fSize.h || newSize.v != fSize.v)
  {
     Resize(newSize.h, newSize.v, TRUE);
     DoPagination();
  }
}


// ------------------------------------------------------------------------
void _TView::AttachPrintHandler(TPrintHandler itsPrintHandler)
{
  fPrintHandler = itsPrintHandler;
  DoCheckPrinter();
}


// ------------------------------------------------------------------------
void _TView::NotifySubView(TView theSubView, GrafPtr itsPort)
{
   theSubView->BeInPort(itsPort);
}


// ------------------------------------------------------------------------
void _TView::BeInPort(GrafPtr itsPort)
{
  EachSubview(this, (DoToSubView)_TView::NotifySubView, itsPort);
}


// ------------------------------------------------------------------------
void _TView::CalcMinSize(VPoint &minSize)
{
  minSize = fSize;
}


// ------------------------------------------------------------------------
void _TView::CloseSubView(TView theSubView)
{
   theSubView->Close();
}


// ------------------------------------------------------------------------
void _TView::Close()
{
#ifdef DRAGDROP
#else
  if (gLastCommand != NULL && gLastCommand->fView == this)
  {
    gApplication->CommitLastCommand();
  }
#endif
  EachSubview(this, (DoToSubView)_TView::CloseSubView);
}


// ------------------------------------------------------------------------
void _TView::ComputeSize(VPoint &newSize)
{
  VCoordinate dimension;
  VHSelect vhs;
  VPoint minSize;
  SizeDeterminer sd = fSizeDeterminer >> 4;

  CalcMinSize(minSize);
  for (vhs = v; vhs <= h; ++vhs)
  {
     dimension = ((VCoordinate *)&minSize)[vhs];
     switch (sd)
     {
     case sizeFixed:
        dimension = ((VCoordinate *)&fSize)[vhs];
        break;
     case sizeRelSuperView:
        dimension = ((VCoordinate *)&newSize)[vhs];
        break;
     case sizeSuperView:
        if (fSuperView != NULL)
          dimension = ((VCoordinate *)&fSuperView->fSize)[vhs];
        break;
     case sizePage:
        if (fPrintHandler != NULL)
          dimension = ((VCoordinate *)&fPrintHandler->fViewPerPage)[vhs];
        break;
     case sizeFillPages:
        if (fPrintHandler != NULL)
          dimension = RoundUp(((VCoordinate *)&minSize)[vhs],
            ((VCoordinate *)&fPrintHandler->fViewPerPage)[vhs]);
        break;
     }
     ((VCoordinate *)&newSize)[vhs] = dimension;
     sd = fSizeDeterminer & 0x07;
  }
}


// ------------------------------------------------------------------------
bool _TView::ContainsMouse(VPoint &theMouse)
{
  VRect extent;

  GetExtent(extent);
  if (fIdentifier == I_('h', 'a', 'l', 'f'))
     extent.bottom = (extent.bottom + extent.top) / 2;
     // 20/01/91 frig for indentations
  return (IsShown() && PtInVRect(theMouse, extent));
}


// ------------------------------------------------------------------------
int _TView::CountSubViews()
{
  return (fSubViews != NULL ? fSubViews->GetSize() : 0);
}


// ------------------------------------------------------------------------
void _TView::DoCalcPageStrips(Point &pageStrips)
{
  fPrintHandler->CalcPageStrips(pageStrips);
}


// ------------------------------------------------------------------------
void _TView::DoCalcViewPerPage(VPoint &viewPerPage)
{
  viewPerPage = fSize;
  fPrintHandler->CalcViewPerPage(viewPerPage);
}


// ------------------------------------------------------------------------
void _TView::DoCheckPrinter()
{
  fPrintHandler->CheckPrinter(FALSE);  // this is only called from AttachPrintHandler
}


// ------------------------------------------------------------------------
void _TView::DoChoice(TView origView, int itsChoice)
{
  if (fSuperView != NULL)
    fSuperView->DoChoice(origView, itsChoice);
}


// ------------------------------------------------------------------------
void _TView::DoDrawPrintFeedback(Rect &area)
{
  if (fPrintHandler != NULL)
    fPrintHandler->DrawPrintFeedback(area);
}


// ------------------------------------------------------------------------
TCommand _TView::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
  return (fPrintHandler != NULL && ((aCmdNumber >= cPrFileBase && aCmdNumber <= cPrFileMax)) ?
                 fPrintHandler->DoMenuCommand(info, aCmdNumber) :
                 _THandler::DoMenuCommand(info, aCmdNumber) );
}


// ------------------------------------------------------------------------
bool _TView::HandleID(TView theSubView, EventInfo *info, TCommand *aCmd)
{
  // 18/02/93 [20706] fViewEnabled is now a 3-bit mask to indicate which buttons
  // the view is enabled for, so that pop-ups can respond to menu clicks, while
  // other views normally ignore them - used to just test theSubView->fViewEnabled

  return ((info->event->data.but.m.bbits & theSubView->fViewEnabled) != 0 ?
                    theSubView->HandleControlClick(*info, *aCmd) :
                    theSubView->_TView::HandleControlClick(*info, *aCmd));
}


// ------------------------------------------------------------------------
bool _TView::HandleControlClick(EventInfo &info, TCommand &aCommand)
{
  return (bool)FirstSubViewThat(this, (TestSubView)_TView::HandleID, &info, &aCommand);
                                          // 19/03/96 less code/stack: != NULL;
}


// ------------------------------------------------------------------------
bool _TView::GetViewFromIconNum(TView theSubView, wr_wimp_i i, TView *foundView)
{
  return (int)(*foundView = theSubView->ViewFromWimpIcon(i));
}


// ------------------------------------------------------------------------
TView _TView::ViewFromWimpIcon(wr_wimp_i theIcon)
{
  TView foundView;

  if (theIcon != -1 &&
      FirstSubViewThat(this, (TestSubView)_TView::GetViewFromIconNum, theIcon, &foundView))
    return foundView;

  return NULL;
}


// ------------------------------------------------------------------------
IDType _TView::IDFromWimpIcon(wr_wimp_i theIcon)
{
  TView foundView = ViewFromWimpIcon(theIcon);

  return (foundView == NULL ? gNoIdentifier : foundView->fIdentifier);
}

#ifdef TRACE
// ------------------------------------------------------------------------
TCommand _TView::DoMouseCommand(Point &theMouse, EventInfo &info)
{
  return gNoChanges;
}
#endif

// ------------------------------------------------------------------------
void _TView::DoPagination()
{
  if (fPrintHandler != NULL)
    fPrintHandler->RedoPageBreaks();
}


// ------------------------------------------------------------------------
void _TView::DoPrinterChanged()
{
  if (fPrintHandler != NULL)
    fPrintHandler->PrinterChanged();
}


// ------------------------------------------------------------------------
void _TView::DoSetupMenus()
{
  _THandler::DoSetupMenus();
  if (fPrintHandler != NULL)
    fPrintHandler->DoSetupMenus();
}

#ifdef TRACE
// ------------------------------------------------------------------------
int _TView::GetPointerShape(Point &localPoint)
{
  return FALSE;
}


// ------------------------------------------------------------------------
void _TView::Adorn(Rect &area, CntlAdornment itsAdornment)
{
}


// ------------------------------------------------------------------------
void _TView::DoHighlightSelection(HLState fromHL, HLState toHL)
{
}


// ------------------------------------------------------------------------
void _TView::Draw(Rect &area)
{
}


// ------------------------------------------------------------------------
void _TView::DrawAdornment(Rect &area)
{
}


// ------------------------------------------------------------------------
void _TView::PageInteriorChanged(Rect &newInterior)
{
}


// ------------------------------------------------------------------------
void _TView::SubViewChangedSize(TView theSubView, VPoint &delta)
{
}
#endif

// ------------------------------------------------------------------------
void _TView::DrawContents()
#ifdef NETWP
{
  DrawView(FALSE);
}


// ------------------------------------------------------------------------
void _TView::DrawView(bool highlight)
#endif
{
  if (Focus())
  {
     bool printing;
     int totalSubViews;
     bool clipRes;
     Rect visRect;
     Rect savedClip;
     Point savedOrigin;

     GetQDExtent(visRect);
     clipRes = VisibleRect(visRect);
     printing = gPrinting;
     // 18/03/96 the clip rect should be within the visible part of window, so Sect unnecessary! 
     // 15/10/96 always TRUE:  if (printing || clipRes)
     // (SectRect(visRect, *thePort->GetVisRect(), visRect)))
#ifdef TRACE
     // Assert(printing || clipRes, 838);
#endif
     {
#ifdef NETWP
        if (!highlight)
#endif
          if (clipRes)
            Draw(visRect);

        if ((totalSubViews = CountSubViews()) > 0)
        {
           savedOrigin = *thePort->GetPortRect()->topLeft;
                        // MoveRect(savedOrigin, *thePort->GetPortRect());
           MoveRect(savedClip, *thePort->GetClipRect());

           for (int i = 1; i <= totalSubViews; i++)
           {
              VRect itsFrame;
              TView theSubView = TView(fSubViews->At(i));

              // an additional check has been added to see if the subview is in the
              // same window as its parent. If not, its own window will redraw it.
              if (theSubView->IsShown() && theSubView->GetGrafPort() == thePort)
              {
                 theSubView->GetExtendedFrame(itsFrame);
                 if (printing || SectRect(itsFrame, savedClip, itsFrame))
                 {
                   // 11/05/91 savedClip from GetVisRect
#ifdef NETWP
                   theSubView->DrawView(highlight);
#else
                   theSubView->DrawContents();
#endif
                   // restore the focus state
                   SetOrigin(savedOrigin.h, savedOrigin.v);
                   SetClip(savedClip);
                   gFocusedView = this;
                 }
              }
           }
        }
#ifdef NETWP
        if (!highlight)
#endif
          if (clipRes)
            DrawAdornment(visRect);     // 06/07/92
        Focus();                    // 06/07/92 in case changed
        if (!printing)
        {
#ifdef NETWP
           if (highlight)
#endif
             DoHighlightSelection(HLOff, fHLDesired);
#ifdef NETWP
           else
#endif
           {
             if (clipRes && fPrintHandler != NULL)
               DoDrawPrintFeedback(visRect);
             // 20/05/90 if tracking this view, redraw any tracker feedback
             if (gTracker != NULL && gTracker->fView == this)
               app_DrawFeedback(NULL, TRUE, TRUE);
           }
        }
     }
  }
}


// ------------------------------------------------------------------------
TView _TView::FindSubView(IDType itsIdentifier)
{
  // 27/09/90 faster version
  int totalSubViews;

  if (fIdentifier == itsIdentifier)
    return this;

  totalSubViews = CountSubViews();

  for (int i = 1; i <= totalSubViews; i++)
  {
    TView foundView = TView(fSubViews->At(i))->FindSubView(itsIdentifier);

    if (foundView != NULL)
      return foundView;
  }
  return NULL;
}


// ------------------------------------------------------------------------
bool _TView::Focus()
{
  VRect visRect;
  VRect myFrame;

  if (IsFocused())
     return TRUE;

  if (gCurrPrintHandler != NULL && gCurrPrintHandler->fView == this)
  {
     gFocusedView = this;
     return TRUE;
  }
  if (fShown && FocusOnSuperView())
  {
     // successful superview focus
     gFocusedView = this;

     /* see if the view's area intersects the box being redrawn */
     GetExtendedFrame(myFrame);                // get view rect rel to superview

     if (SectVRect(myFrame, *thePort->GetClipRect(), visRect))
     {
       // my frame is visible in the clipping rect for my superview
       visRect.bottom += GetHLineThickness();
          // 18/03/96 to replace what was in Toolbox...: fClipRect.bottom += GetHLineThickness(); 
          // 07/07/92 ... to let views access following pixel via VisibleRect
       SetClip(visRect);          // 20/07/92 aRect);
       thePort->OffsetOrigin(-fLocation.h, -fLocation.v);
       return TRUE;
     }
  }
  gApplication->InvalidateFocus();
  return FALSE;
}


// ------------------------------------------------------------------------
bool _TView::FocusOnSuperView()
{
  return (gPrinting ? TRUE :
                     (fSuperView != NULL ? fSuperView->Focus() : FALSE));
}


// ------------------------------------------------------------------------
void _TView::ForceRedraw()
{
  VRect extent;

  GetExtent(extent);
  extent.bottom += GetHLineThickness();    // 14/07/92 should be in TSubview!
  InvalidVRect(extent);
}


// ------------------------------------------------------------------------
bool _TView::IsFocused()
{
  return (gFocusedView == this);
}


// ------------------------------------------------------------------------
TWindow _TView::GetDialogView()
{
  return (fSuperView != NULL ? fSuperView->GetDialogView() : NULL);
}


// ------------------------------------------------------------------------
void _TView::GetExtent(VRect &itsExtent)
{
  itsExtent.top = 0;
  itsExtent.left = 0;
  itsExtent.bottom = fSize.v;
  itsExtent.right = fSize.h;
}


// ------------------------------------------------------------------------
void _TView::GetFrame(VRect &itsFrame)
{
  itsFrame.top = fLocation.v;
  itsFrame.left = fLocation.h;
  itsFrame.right = itsFrame.left + fSize.h;
  itsFrame.bottom = itsFrame.top + fSize.v;
}


// ------------------------------------------------------------------------
void _TView::GetExtendedFrame(VRect &itsFrame)
{
  GetFrame(itsFrame);
}


// ------------------------------------------------------------------------
GrafPtr _TView::GetGrafPort()
{
  return (gPrinting ? thePort :
           (fSuperView == NULL ? NULL : fSuperView->GetGrafPort()));
}


// ------------------------------------------------------------------------
void _TView::GetPrintExtent(VRect &printExtent)
{
  GetExtent(printExtent);
}


// ------------------------------------------------------------------------
void _TView::GetPageInterior(int page, VRect &pageInterior)
{
  fPrintHandler->GetInterior(page, pageInterior);
}


// ------------------------------------------------------------------------
TScroller _TView::GetScroller(bool immediateSuperView)
{
  if (fSuperView != NULL)
  {
    TScroller aScroller = fSuperView->GetScroller(immediateSuperView);

    if (!immediateSuperView || aScroller == fSuperView)
      return aScroller;
  }
  return NULL;
}


// ------------------------------------------------------------------------
TWindow _TView::GetWindow()
{
  return (fSuperView != NULL ? fSuperView->GetWindow() : NULL);
}


// ------------------------------------------------------------------------
bool _TView::TestMouse(TView theSubView, VPoint &theMouse)
{
   VPoint subViewPt;

   subViewPt = theMouse;
   theSubView->SuperToLocal(subViewPt);
   if (theSubView->ContainsMouse(subViewPt) && theSubView->HandleCursor(subViewPt))
     return TRUE;
   return FALSE;
}

// ------------------------------------------------------------------------
TView _TView::DoHandleCursor(VPoint &theMouse)
{
   return LastSubViewThat(this, (TestSubView)_TView::TestMouse, &theMouse);
}

// ------------------------------------------------------------------------
TView _TView::HandleCursor(VPoint &theMouse)
{
  TView handlingView;
  int cursorId;

  handlingView = DoHandleCursor(theMouse);
  if (handlingView == NULL && IsViewEnabled() && Focus() &&
                                          (cursorId = GetPointerShape(theMouse)) != 0)
  {
     SetCursor(GetCursor(cursorId));
     return this;
  }
  return handlingView;
}

// ------------------------------------------------------------------------
bool _TView::CheckMouse(TView theSubView, VPoint &theMouse,
                  EventInfo &info, TCommand &theCommand)
{
   VPoint subViewPt;

   subViewPt = theMouse;
   theSubView->SuperToLocal(subViewPt);
   return (theSubView->ContainsMouse(subViewPt) ?
     theSubView->HandleMouseDown(subViewPt, info, theCommand):
     FALSE);
}


// ------------------------------------------------------------------------
bool _TView::HandleMouseDown(VPoint &theMouse, EventInfo &info,
                                   TCommand &theCommand)
{
  bool  HandleMouseDown_r;
  TView viewThatHandledMouse;
  Point theQDMouse;

  theCommand = gNoChanges;
  viewThatHandledMouse = LastSubViewThat(this, (TestSubView)_TView::CheckMouse,
                     &theMouse, &info, &theCommand);
  if (viewThatHandledMouse != NULL)
    HandleMouseDown_r = TRUE;
  else if (IsViewEnabled() && Focus())
  {
    ViewToQDPt(theMouse, theQDMouse);
    theCommand = DoMouseCommand(theQDMouse, info);
    HandleMouseDown_r = TRUE;
  }
  else
    HandleMouseDown_r = FALSE;
  return(HandleMouseDown_r);
}


// ------------------------------------------------------------------------
void _TView::InvalidRect(Rect &r)
{
  if (Focus())
  {
    VisibleRect(r);
    InvalRect(r);
  }
}


// ------------------------------------------------------------------------
void _TView::InvalidVRect(VRect &viewRect)
{
  InvalidRect(viewRect);
}


typedef struct TUpdateList
   {
      unsigned a;
      unsigned b;
   } TUpdateList;

// ------------------------------------------------------------------------
void _TView::DoInUpdate(Rect &rectToUpdate, DrawProc procToDo, ...)
{
  // 20/05/90 new proc to avoid proliferation of update loops
  // 25/05/90 failure handling added
  // 13/05/91 cheat va_args
  if (Focus())
  {
    WindowRecord *aWindRec;
    wr_wimp_redrawstr r;
    int more;
    TUpdateList *args = (TUpdateList *)((char *)&procToDo + sizeof(procToDo));

    if (gInRedraw)
      procToDo(this, *args);       // we are already in an update/draw cycle
    else
    {
      FailInfo fi;

      gInRedraw = TRUE;
      gInUpdate = -1;                 // 25/06/92 from TRUE
      aWindRec = WindowPeek(thePort);
      aWindRec->SaveCaret();
      r.w = aWindRec->GetHandle();
      thePort->LocalToWABox(rectToUpdate, r.box);
      wr_wimpt_noerr(wr_wimp_update_wind(&r, &more));

      while (more != 0)
      {
        // set up the clip rect, etc. for drawing
        aWindRec->SetRedrawStr(&r);

        CatchFailures(&fi);
        procToDo(this, *args);
#ifdef NETWP
        if (IsTV())
          wr_os_swi4(NH_AntiTwitter + XOS_Bit, r.g.x0, r.g.y0, r.g.x1 - r.g.x0, r.g.y1 - r.g.y0);
#endif
        Success(&fi);

#ifdef TRACE
        goto noRescue;
#endif

Rescue: // If anything goes wrong while drawing (which should not happen too
        // often) we are in a mess. Rather than stick up a dialog, which will
        // cause a redraw, and probably fail again, it seems better to just
        // carry on, in the hope that the user can save the document.
#ifdef TRACE
        SysBeep(1);     // to warn us that something is amiss
noRescue:
#endif
        MarkDamagedDoc(&fi, fDocument);  // 22/02/94 to pick up Assertions
        if (wr_wimp_get_rectangle(&r, &more) != NULL)
          more = 0;
      }
      aWindRec->RestoreCaret(TRUE);
      gInRedraw = FALSE;
      gInUpdate = FALSE;     // 14/04/92
    }
  }
}

#ifdef NETWP
// ------------------------------------------------------------------------
void _TView::NoNH_DoInUpdate(Rect &rectToUpdate, DrawProc procToDo, ...)
{
  TUpdateList *args = (TUpdateList *)((char *)&procToDo + sizeof(procToDo));
  int temp = gNet.TV;

  gNet.TV = FALSE;
  DoInUpdate(rectToUpdate, procToDo, *args);
  gNet.TV = temp;
}
#endif

// ------------------------------------------------------------------------
static void DrawTheContents(TView theView)
// 20/05/90 needed because CFront does not support passing of virtual funcs 
{
  theView->DrawContents();
}

// ------------------------------------------------------------------------
void _TView::UpdateVRect(VRect &viewRect)
{
  // 20/05/90 now uses DoInUpdate
  DoInUpdate(viewRect, (DrawProc)DrawTheContents);
}


// ------------------------------------------------------------------------
bool _TView::IsShown()
{
  return fShown;
}


// ------------------------------------------------------------------------
bool _TView::IsViewEnabled()
{
  return fViewEnabled != 0;  // 18/02/93 [20706] fViewEnabled no longer a bool
}


// ------------------------------------------------------------------------
void _TView::LocalToSuper(VPoint &thePoint)
{
  AddVPt(fLocation, thePoint);
}


// ------------------------------------------------------------------------
void _TView::LocalToWindow(VPoint &thePoint)
{
  TView aView;

  aView = this;
  while (aView->fSuperView != NULL)
  {
    aView->LocalToSuper(thePoint);
    aView = aView->fSuperView;
  }
}


// ------------------------------------------------------------------------
void _TView::SuperToLocal(VPoint &thePoint)
{
  SubVPt(fLocation, thePoint);
}


// ------------------------------------------------------------------------
void _TView::WindowToLocal(VPoint &thePoint)
{
  if (fSuperView != NULL)
  {
    fSuperView->WindowToLocal(thePoint);
    // 17/10/96 [27061] moved out of condition: 
    SuperToLocal(thePoint);
  }
  // SuperToLocal(thePoint);
}


// ------------------------------------------------------------------------
void _TView::Locate(VCoordinate hCoord, VCoordinate vCoord, bool invalidate)
{
  if (hCoord != fLocation.h || vCoord != fLocation.v)
  {
     if (invalidate)
        ForceRedraw();
     fLocation.h = hCoord;
     fLocation.v = vCoord;
     gApplication->InvalidateFocus();
     if (invalidate)
       ForceRedraw();
     // 06/03/96 does nothing
     // if (fSuperView != NULL)
     //   fSuperView->SubViewMoved(this);
     // EachSubview(this, (DoToSubView)_TView::TellSubView, invalidate);
  }
}


// ------------------------------------------------------------------------
void _TView::OpenSubView(TView theSubView)
{
  if (theSubView->IsToBeOpened())
    theSubView->Open();
}


// ------------------------------------------------------------------------
void _TView::Open()
{
  EachSubview(this, (DoToSubView)_TView::OpenSubView);
}


// ------------------------------------------------------------------------
void _TView::RemoveSubView(TView theSubView)
{
  if (fSubViews != NULL)
    fSubViews->Delete(theSubView);
/* 02/02/91 unnecessary as only called from Free
  if (theSubView->fNextHandler == this)
    theSubView->fNextHandler = NULL;
  theSubView->fSuperView = NULL;
*/
}


// ------------------------------------------------------------------------
void _TView::InformSubView(TView theSubView, VPoint &delta, bool invalidate)
{
   theSubView->SuperViewChangedSize(delta, invalidate);
}


// ------------------------------------------------------------------------
void _TView::Resize(VCoordinate width, VCoordinate height, bool invalidate)
{
  VPoint delta;
  VRect myFrame;

  if (fSize.h != width || fSize.v != height)
  {
     SetVPt(delta, width - fSize.h, height - fSize.v);
     GetFrame(myFrame);
     fSize.h = width;
     fSize.v = height;
     gApplication->InvalidateFocus();
     if (invalidate && IsShown() && FocusOnSuperView())
     {
        VRect tempRect;
        VCoordinate newBottom = myFrame.top + height;
        VCoordinate newRight = myFrame.left + width;
        VCoordinate minBottom = Min(myFrame.bottom, newBottom);

        if (newRight != myFrame.right)
        {
          SetVRect(tempRect, Min(myFrame.right, newRight), myFrame.top,
            Max(myFrame.right, newRight), minBottom);
          VisibleRect(tempRect);
          InvalRect(tempRect);
        }
        if (newBottom != myFrame.bottom)
        {
          SetVRect(tempRect, myFrame.left, minBottom,
            newBottom > myFrame.bottom ? newRight : myFrame.right,
            Max(myFrame.bottom, newBottom));
          VisibleRect(tempRect);
          InvalRect(tempRect);
        }
     }
     if (fSuperView != NULL)
       fSuperView->SubViewChangedSize(this, delta);
     EachSubview(this, (DoToSubView)_TView::InformSubView, &delta, invalidate);
  }
}


// ------------------------------------------------------------------------
void _TView::RevealRect(VRect &rectToReveal, VRect &minToSee)
{
  int loc = fLocation.h;

  rectToReveal.left += loc;
  rectToReveal.right += loc;
  loc = fLocation.v;
  rectToReveal.bottom += loc;
  rectToReveal.top += loc;
  if (fSuperView != NULL)
    fSuperView->RevealRect(rectToReveal, minToSee);
}


// ------------------------------------------------------------------------
static void ShowSubV(TObject null, TView subV, bool state)
{
  subV->ViewShown(state);
}


// ------------------------------------------------------------------------
void _TView::ViewShown(bool state)
{
  EachSubview(NULL, (DoToSubView)ShowSubV, state && fShown);
}


// ------------------------------------------------------------------------
void _TView::Show(bool state, bool redraw)
{
  if (state != fShown)
  {
     if (redraw)
     {
        fShown = TRUE;
        ForceRedraw();
     }
     if ((!state) && IsFocused())
       gApplication->InvalidateFocus();
     fShown = state;
     ViewShown(state);
  }
}


// ------------------------------------------------------------------------
void _TView::RevertSubView(TView theSubView)
{
   theSubView->ShowReverted();
}


// ------------------------------------------------------------------------
void _TView::ShowReverted()
{
  AdjustSize();
  ForceRedraw();
  EachSubview(this, (DoToSubView)_TView::RevertSubView);
}


// ------------------------------------------------------------------------
void _TView::SuperViewChangedSize(VPoint &delta, bool invalidate)
{
  VPoint newSize;
  bool needsResizing;
  VHSelect vhs;
  SizeDeterminer sd = fSizeDeterminer >> 4;

  needsResizing = FALSE;
  newSize = fSize;
  for (vhs = v; vhs <= h; vhs++)
  {
    if (sd == sizeSuperView || sd == sizeVariable)
                                      // sizeVariable added 8/5/90
      needsResizing = TRUE;
    else if (sd == sizeRelSuperView)
    {
      ((VCoordinate *)&newSize)[vhs] += ((VCoordinate *)&delta)[vhs];
      needsResizing = TRUE;
    }
    sd = fSizeDeterminer & 0x07;
  }
  if (needsResizing)
  {
    ComputeSize(newSize);
    Resize(newSize.h, newSize.v, invalidate);
    DoPagination();
  }
}


// ------------------------------------------------------------------------
void _TView::AddInvalidVRect(VRect &viewRect)
// added 17/05/90 & updated 30/05/90
{
  if (Focus())
  {
    Rect r;
    TWindow myWindow;

    ViewToQDRect(viewRect, r);
    // VisibleRect(r);
    // 01/05/92 for safety, ignore if printing (windowRef == NULL)
    if (VisibleRect(r) && (myWindow = TWindow(thePort->GetWindowRef())) != NULL)
    {
      thePort->QDToWorkAreaRect(r);
      myWindow->InvalidateArea(r);
    }
  }
}


// ------------------------------------------------------------------------
void _TView::ViewEnable(bool state, bool redraw)
{
  // potential problem if popup is disabled then enabled, it will loose menu bit
  fViewEnabled = state ? wr_wimp_BRIGHT | wr_wimp_BLEFT : 0; // 18/02/93 [20706] state;
  if (redraw)
    ForceRedraw();
}


// ------------------------------------------------------------------------
bool _TView::FindViewMouseIn(TView theSubView, VPoint &theMouse,
                  EventInfo &info)
{
   VPoint subViewPt;

   subViewPt = theMouse;
   theSubView->SuperToLocal(subViewPt);
   return (theSubView->ContainsMouse(subViewPt) ?
     theSubView->HandleHelp(subViewPt, info) :
     FALSE);
}


// ------------------------------------------------------------------------
bool _TView::HandleHelp(VPoint &theMouse, EventInfo &info)
{
  TView viewThatHandledMouse = LastSubViewThat(this,
          (TestSubView)_TView::FindViewMouseIn, &theMouse, &info);

  return (viewThatHandledMouse == NULL ? DoHelp(fIdentifier, info, theMouse) : TRUE);
}


// ------------------------------------------------------------------------
bool _TView::DoHelp(IDType msgID, EventInfo &info, VPoint &theMouse)
{
  wr_wimp_msgstr* msg = &info.event->data.msg;
  bool stop = FALSE;
  VPoint superPoint;
  char workspace[200];

  if (msgID == gNoIdentifier)
    msgID = fIdentifier;

  if (msgID != gNoIdentifier)
  {
    char tempBuf[8];
    char *text = msg->data.helpreply.text;
    int i;
    char *p;

    // 11/03/93 [20809] allow ids < 4 characters
    for (i = 0, p = ((char *)&msgID) + 3; p >= (char *)&msgID; p--)
      if (*p != 0)
        tempBuf[i++] = *p;
    tempBuf[i] = 0;

    if (GetHelpString(tempBuf, workspace) != NULL)
    {
      int helpLen;
#ifndef NETWP
      int textLen;
      int stopGap;
#endif

      helpLen = strlen(workspace);
      // 14/02/94 \R should not have been expanded by us so, for help on a view, ...
      if (workspace[0] == '\\')         // knock off start of "\R....|M...." messages
      {
        p = strchr(workspace, '|');

        if (p != NULL)
        {
          p = p + 2;
          helpLen = helpLen - (p - workspace);     // subtract the initial part of message
          memmove(workspace, p, helpLen);
        }
      }
#ifdef NETWP
      strcpy(text, workspace);
      stop = TRUE;
#else
      textLen = strlen(text);
      stopGap = (textLen == 0 ? 1 : 3);
      if (workspace[helpLen - 1] == '.')     // stop if a '.' at end of message
      {
        stop = TRUE;
        helpLen--;
      }
      if (textLen + helpLen <= sizeof(wr_wimp_msghelpreply) - 1 - stopGap)
      {
        memmove(text + helpLen + stopGap, text, textLen + 1); // move up to make room
        memcpy(text, workspace, helpLen);
        memcpy(text + helpLen, ".|M", stopGap);
      }
#endif
    }
  }

  if (stop || fSuperView == NULL)
    return SendHelpReply(msg);

  superPoint = theMouse;
  LocalToSuper(superPoint);
  return fSuperView->DoHelp(gNoIdentifier, info, superPoint);
}


// ------------------------------------------------------------------------
void _TView::PreOpenSubView(TView theSubView)
{
   theSubView->PreOpen();
}


// ------------------------------------------------------------------------
void _TView::PreOpen()
{
  // Open & BeInPort should make this unnecessary
  EachSubview(this, (DoToSubView)_TView::PreOpenSubView);
}


// ------------------------------------------------------------------------
void _TView::DrawFeedback(Point &mousePt)
// 23/04/91 new method
{
  if (fSuperView != NULL)
    fSuperView->DrawFeedback(mousePt);
}


// ------------------------------------------------------------------------
TControl _TView::WriteCheckBox(IDType id, bool setTo)
{
  TControl checkBox;

  if ((checkBox = TControl(FindSubView(id))) != NULL)
    checkBox->SetState(setTo, kRedraw);

  return checkBox;
}

// ------------------------------------------------------------------------
bool _TView::TestCheckBox(IDType id)
{
  TControl theFld = TControl(FindSubView(id));

  return (theFld == NULL ? FALSE : theFld->IsOn());
}

// ------------------------------------------------------------------------
TControl _TView::SetDimState(IDType id, bool state)
{
  TControl theControl;

  if ((theControl = TControl(FindSubView(id))) != NULL)
    theControl->RealDimState(state);

  return theControl;
}

// ------------------------------------------------------------------------
TControl _TView::WriteText(IDType id, char *setTo)
{
  return WriteTruncText(id, setTo, cutRight);
}

// ------------------------------------------------------------------------
TControl _TView::WriteTruncText(IDType id, char *setTo, TruncType trunc)
{
  TControl textControl;

  if ((textControl = TControl(FindSubView(id))) != NULL)
  {
    textControl->fTruncateMode = trunc;
    textControl->SetText(setTo, kRedraw);
  }
  return textControl;
}

// ------------------------------------------------------------------------
TControl _TView::WriteValueRedraw(IDType id, int newValue)
{
  return WriteValue(id, newValue, kRedraw);
}

// ------------------------------------------------------------------------
TControl _TView::WriteValueNoRedraw(IDType id, int newValue)
{
  return WriteValue(id, newValue, kDontRedraw);
}

// ------------------------------------------------------------------------
TControl _TView::WriteValue(IDType id, int newValue, bool redraw)
{
  TControl theControl;

  if ((theControl = TControl(FindSubView(id))) != NULL)
    theControl->SetValue(newValue, redraw);

  return theControl;
}

// ------------------------------------------------------------------------
int _TView::ReadValue(IDType id, int deflt)
{
  TControl theControl;

  if ((theControl = TControl(FindSubView(id))) != NULL)
    return theControl->GetValue();

  return deflt;
}

// ------------------------------------------------------------------------
bool _TView::IsToBeOpened()
{
  return fSizeDeterminer & kToBeOpened;
}

// ------------------------------------------------------------------------
void _TView::SetToBeOpened(bool toBeOpened)
{
  fSizeDeterminer = (toBeOpened ? fSizeDeterminer | kToBeOpened :
                                             fSizeDeterminer & ~kToBeOpened);
}

// ------------------------------------------------------------------------
void _TView::DrawFilledRect(VRect &aRect, int new_colour, int action)
{
   wr_os_regset r;

   r.r[0] = new_colour;   /* BBGGRRxx    */
   r.r[3] = 256;          /* 256 - use ECFs */
   r.r[4] = action;       /* GCol action */

   if (Focus())
   {
      // drawmod_pathelemptr ptr;
      int path[30];
      wr_wimp_box box;

      thePort->LocalToBox(aRect, box);
      path[0]  = path_move_2;
      path[9]  = path[6] = path[3] = path_lineto;
      path[12] = path_closeline;
      path[13] = 0;
      path[14] = (30 - 15) * 4;
      path[10] = path[1] = box.x0 * 256;
      path[5]  = path[2] = box.y1 * 256;
      path[7]  = path[4] = box.x1 * 256;
      path[11] = path[8] = box.y0 * 256;

      wr_wimpt_noerr(wr_os_swix(0x40743 /*ColourTrans_SetGCOL*/, &r));

      r.r[0] = (int)path;
      r.r[1] = (int)fill_Default;
      r.r[2] = 0;
      r.r[3] = 0;
      wr_wimpt_noerr(wr_os_swix(0x00040702 /* Draw_Fill */, &r));
   }
}
