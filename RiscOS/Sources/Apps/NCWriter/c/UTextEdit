/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>

#include "akbd.h"
#include "font.h"

#include "Hyph.h"
#include "UTextEdit.h"

#define kMSWord         (0x0ae6)

//=========================================================================
//                             fTempFlag
//                             ---------
// In clip documents:
//   When a text file is read in, if end of file has no CR, fTempFlag = 1
//   or fTempFlag = 2 (intelligent paste) for a word dragged from Thesaurus.
//   When a clip document is sent (global clipboard?) the state of fTempFlag
//   is saved and restored from the CR position of the last paragraph.
//   GetStatistics for a scrap doc do not include final CR in count
//   Set to 2 (intelligent) or 1 (no CR) on copy to clipboard
//   Check in CanDoPaste to see if can be inserted or needs a split first
// for clip documents too?:
//   On GetSelectionEndPos, if all selected and fTempFlag set, the CR is omitted.
//   On paste test fTempFlag == 2 for intelligent paste, then set to 1
//
// Set on clear part of replace word from Thesaurus to indicate case of word
//   On paste from Thesaurus, fTempFlag = case of original word, then set to 1
//
// Set on clear with CR
//   Tested on LinkStructure to see if clear (with CR) to avoid joining (locks)
//
// Set if a style change applies to an emphasis or is cPlain (rec locked)
//   Tested on ToggleChanges
//   Tested on Commit Style, and cleared (rec unlocked)
//
// When a spell correction is made, a Replace all (or a style change installed?),
// fTempFlag is set to 1 so that the subsequent kReformatChgs knows which paras
// to reformat.
// If Reformatting, ignore recs without fTempflag if kReformatType == kReformatChgs
// and clear
//
// Commit sets to zero (rec unlocked)
//
//=========================================================================

extern char gPrefixes[];
extern int gLastFontHandle;

typedef struct TStringBBox {
  int x_space_offset;
  int y_space_offset;
  int x_letter_offset;
  int y_letter_offset;
  int split_char;
  wr_wimp_box bbox;
} TStringBBox;

static TStringBBox gStringBBox = {0,0,0,0,-1,{0,0,0,0}};

#define FIXLOC TRUE
#define kTeX            (0x02a7)

// static Fixed gStyleSpaceExtra;        // made into a gStyle field
#ifdef INDEX
static int gShowIndexEntries;
#endif

#define _TSortedStructure _TStructure
#define kNoLanguage 0
#define kTextIncrement 16
                     // 30/12/90 from an increment value of 10

// 08/03/94 (need to be moved to .h) to recognise Tab commands
#define cTabMove           80
#define cMultiTabMove      90

// 24/10/90 new end-of-line constants

#define kForward 1
#define kBackward -1

typedef union TEmphasis
{
  Rect fCustom;
  struct {
    TCharPos fStartPos, fEndPos;
    int fFirstLine;
  } tag;
} TEmphasis;

#ifdef TeX
int gTeXfile = kTeX;
#endif

static TTextStructure gMainStruct;
static TTextStructure gLinkStruct;
static TCharPos gDelPos;
static Size gDelCount;
static char gLastCh;
static char gMarkCh;
static int gPhraseIdx;
static TActivePhrase gActivePhrase;
static TStyle gCompositeStyle;
static TStyle gStyle;
static int gExtraInsert;   // [26020] for CursorReformat algorithm flaw

// ------------------------------------------------------------------------
//inline char *TextStart(TTextStructure self)
//{
//  return (char *)self->fPtrToArray + self->fOffset;
//}
#define TextStart(a) ((char *)a->fPtrToArray + a->fOffset)

// ------------------------------------------------------------------------
inline int HiWord(long lwrd)
{
  return ((unsigned long)lwrd) >> 16;
}

// ------------------------------------------------------------------------
inline int LoWord(long lwrd)
{
  return ((unsigned long)(lwrd << 16)) >> 16;
}

// ------------------------------------------------------------------------
void StringConvertCase(char *chPtr, int stringLen, TTextCaps chCase)
{
  if (chCase != kMixedCase)
  {
    char *lastCh = chPtr + stringLen;
    int last = 0;             // ensure first InitCaps is upper

    if (chCase == kLowerCase)
      last = 65;              // force lower case translation

    for (; chPtr < lastCh; chPtr++)
    {
      *chPtr = (last <= 32 ? toupper(*chPtr) : tolower(*chPtr));

      if (chCase == kInitialCaps)
        last = *chPtr;
    }
  }
}

#ifdef TRUE
// faster version 95
// ------------------------------------------------------------------------
static void SetTextGlobals(TTextStructure mainStruct)
{
  int delPhrase1, delPhrase2;

  gMainStruct = mainStruct;
  gLinkStruct = NULL;
  delPhrase1 = mainStruct->FindDeletionPhrase();
  if (delPhrase1 > 0)
  {
    PPhrase cgf_114 = PPhrase(mainStruct->At(delPhrase1));

    gDelPos = cgf_114->fCharPos;
    gDelCount = cgf_114->fNumChars;
    if (mainStruct->fLinkStruct > 0)
    {
#ifdef TRACE
      Assert(mainStruct->fCount == gDelPos + gDelCount, 622);
#endif
      gLinkStruct = TTextStructure(mainStruct->GetStructureReadWrite(mainStruct->fLinkStruct));
      delPhrase2 = gLinkStruct->FindDeletionPhrase();
      if (delPhrase2 > 0)
      {
#ifdef TRACE
        Assert(PPhrase(gLinkStruct->At(delPhrase2))->fCharPos == 0, 621);
#endif
        gDelCount += PPhrase(gLinkStruct->At(delPhrase2))->fNumChars;
      }
    }
  }
  else
  {
#ifdef TRACE
    Assert(mainStruct->fLinkStruct <= 0, 620);
#endif
    gDelPos = MAXLONGINT;
    gDelCount = 0;
  }
}
#else
// ------------------------------------------------------------------------
static void SetTextGlobals(TTextStructure mainStruct)
{
  // int insPhrase;
  int delPhrase1, delPhrase2;
  TCurrency linkStruct;

  gMainStruct = mainStruct;
  delPhrase1 = mainStruct->FindDeletionPhrase();
  linkStruct = mainStruct->fLinkStruct;
  if (linkStruct <= 0)               // 24/01/91 from ==
  {
    gLinkStruct = NULL;
    delPhrase2 = 0;
  }
  else
  {
    gLinkStruct = TTextStructure(mainStruct->GetStructureReadWrite(linkStruct));
    delPhrase2 = gLinkStruct->FindDeletionPhrase();
  }

  if (delPhrase1 == 0 && delPhrase2 == 0)
  {
    gDelPos = MAXLONGINT;
    gDelCount = 0;
  }
  else
  {
    if (delPhrase1 > 0)
    {
      PPhrase cgf_114 = PPhrase(gMainStruct->At(delPhrase1));
      gDelPos = cgf_114->fCharPos;
      gDelCount = cgf_114->fNumChars;

      if (delPhrase2 > 0)
        gDelCount += PPhrase(gLinkStruct->At(delPhrase2))->fNumChars;
    }
    else
    {
      PPhrase cgf_115 = PPhrase(gLinkStruct->At(delPhrase2));
      gDelPos = cgf_115->fCharPos;
      gDelCount = cgf_115->fNumChars;
      // the above gDelPos looks wrong! can it ever get here??
    }
  }
}
#endif

#ifdef INDEX
// ------------------------------------------------------------------------
int _TTextStructure::GetIndexPhr(TCurrency curr, TCharPos charPos, int &updateIdx)
{
  PPhrase aPhrase;
  PPhrase endPhr;

  // 28/06/95 add fFirstOffset
  for (aPhrase = PPhrase((char *)fPtrToArray + fFirstOffset), endPhr = aPhrase + fSize;
                                                              aPhrase < endPhr; aPhrase++)
    if (aPhrase->fKind == kIndexRefPhrase)
    {
      if (aPhrase->fCharPos == charPos && updateIdx ==
                (aPhrase->tag.indexRef.fIndexRec == fDocument->fBookmarkRec))
      {
        updateIdx = aPhrase->tag.indexRef.fIndexRec;
        return curr;
      }
      curr += 256;
    }

  if (this != gLinkStruct && gLinkStruct != NULL)
    return gLinkStruct->GetIndexPhr(fLinkStruct, charPos - fCount, updateIdx);
  updateIdx = 0;
  return 0;
}

// ------------------------------------------------------------------------
int _TTextStructure::GetIndexPhraseAt(TCurrency curr, TCharPos charPos, int &updateIdx)
{
  // updateIdx passed in == 0 to not find bookmark phrases
  SetTextGlobals(this);
  if (charPos >= gDelPos)
    charPos += gDelCount;
  return GetIndexPhr(curr, charPos, updateIdx);
}
#endif

#ifdef TRACE
// ------------------------------------------------------------------------
void _TTextStructure::AtPut(int index, Ptr newItem)
{
  if (index > 1)
    Assert(Compare(At(index - 1), newItem) < 0, 811);
  if (index < fSize && Compare(At(index + 1), newItem) <= 0)
    SysBeep(0);
  _TStructure::AtPut(index, newItem);
}
#endif

#ifdef THESAURUS
// ------------------------------------------------------------------------
static void SendWordToThesaurus(int charPos)
{
  wr_wimp_msgstr msg;
  int i;
  int ch;

  // msg.hdr.size = 256;
  // msg.hdr.task = 0;
  // msg.hdr.your_ref = 0;
  // msg.hdr.action = Message_ThesaurusReply;
  for (i = 0; isalnum(ch = gMainStruct->GetChar(i + charPos)); i++)
    msg.data.chars[i] = ch;
  msg.data.chars[i] = 0;
  // wr_wimpt_noerr(wr_wimp_sendmessage(wr_wimp_ESEND, &msg, 0));
  wr_wimpt_noerr(Broadcast(Message_ThesaurusReply, &msg, 256));
}

// ------------------------------------------------------------------------
void _TTextStructure::FindSynonym(TCursorNode anchor, TCursorNode activeEnd)
{
  int pos = TTextCursor(anchor)->GetCharPos();

  SetTextGlobals(this);
  while (pos > 0 && isalnum(GetChar(pos - 1)))
    pos--;
  SendWordToThesaurus(pos);
}
#endif

// ------------------------------------------------------------------------
static bool CurFindWord(TTextStructure structure, TCharPos &cp, int direction)
{
//  bool found = FALSE;
  int start = cp;
  int ch;

  // deal with white space (space, tabs and LFs)
  do
  {
    if (direction == kBackward)
    {
      if (cp < 0)
        return TRUE;
      cp = Min(cp, structure->fCount - 1 - gDelCount +
                                 (gLinkStruct == NULL ? 0 : gLinkStruct->fCount));
                                 // 08/02/91 -1 02/09/92 - gDelCount and gLinkStruct
    }

    ch = structure->GetChar(cp /*, ch*/);
    if (ch == chReturn && direction == kForward)
      return TRUE;

    if (ch <= chSpace
#if SIDEBAR == 1
//            && ch != 0
#endif
          )
      structure->MoveCursor(cp, direction);
    else
    {
      if (cp == start && direction == kBackward)
        structure->MoveCursor(cp, -1);
      else
        break;   // found = TRUE;
    }
  } while (TRUE);      // (!found);

//  found = FALSE;
  // scan to appropriate end of the word
  do
  {
    if (cp == 0 && direction == kBackward)
      break;    // found = TRUE;
    else
    {
      ch = structure->GetChar(cp /*, ch*/);
      if (ch <= chSpace
#if SIDEBAR == 1
//            && ch != 0
#endif
          )
      {
        if (direction == kBackward)
          structure->MoveCursor(cp, 1);   // gone too far past start
        break;   // found = TRUE;
      }
      else
      {
#if SIDEBAR == 1
        if (ch == 0x100)     // hit widget
        {
          if (direction == kForward && start == cp)
            structure->MoveCursor(cp, 1);   // set past end
          break;
        }
#endif
        structure->MoveCursor(cp, direction);
      }
    }
  } while (TRUE);       // (!found);

  return FALSE;
}

#if TALK == 1
// ------------------------------------------------------------------------
int _TTextStructure::GetWordAtCaret(TCursorNode anchor, TCursorNode activeEnd,
                                                                 wr_wimp_msgstr *msg)
{
  TCharPos pos;
  TCharPos startPos;
  char *cp;
  char *theWord = (char *)&msg->data.words[3];
  int ch;

//  startPos = 
  pos = TTextCursor(anchor)->GetCharPos();
//  if (msg->data.words[0] > 0    // if > 0 we are at the start of word moved to by F6
//#if SIDEBAR == 1
//     && GetChar(pos) != 0x100     // not just in front of a widget to speak
//#endif
//          )
//    pos++;
  ch = GetChar(pos);
  if (msg->data.words[0] > 0 && ch == chReturn)
    return 0;                // presumably last move was to the end of doc
#if SIDEBAR == 1
  if (ch != 0x100)           // not just in front of a widget to speak
#endif
  {
    if (pos > 0)
    {
      // ch = GetChar(pos - 1);
      // if (ch == chReturn)
      //   return 0;                // presumably last F6 moved to the end of doc
      ch = GetChar(pos - 1);
      if ((ch & 0xff) > 0x20)
      {
        // not positioned at start of a word
        CurFindWord(this, pos, kBackward);
        if (pos < 0 || GetChar(pos) <= 0x20)
          pos++;
      }
    }
//#if SIDEBAR == 1
//    else if (msg->data.words[0] > 0)
//      pos = startPos;  // put it back again if tab, etc.
//#endif
  }
  startPos = pos;
  if (activeEnd != NULL && activeEnd->fCurrency == anchor->fCurrency &&
                             (msg->data.words[1] & 0xff) == 8)
    pos = TTextCursor(activeEnd)->GetCharPos();
#if SIDEBAR == 1
  else if (msg->data.words[1] > 0 && (msg->data.words[1] & 0xff) != 1)
                                                    // send as much as possible
  {
    for ( ; (ch = GetChar(pos), (ch >= 0x20 && ch <= 0xff)); MoveCursor(pos, 1)) {}
    // if (ch == chReturn)
      MoveCursor(pos, 1);
  }
#endif
  else
    for ( ; GetChar(pos) > 0x20; MoveCursor(pos, 1)) {}

  for (cp = theWord; startPos < pos && cp < (char *)&msg->data.words[58] + 3; startPos++)
  {
    *(cp++) = GetChar(startPos);
    if (*(cp - 1) == 0)
#if SIDEBAR == 1
    {
      if (cp > theWord + 1 && (msg->data.words[1] < 0 ||
                   (msg->data.words[1] & 0xff) != 1 && (msg->data.words[1] & 0x200) == 0))
        *(cp - 1) = 1;  // send up to and inc stopper so not confused with middle of word
      else
      {
        TPhrase phrase;

        if (GetPhraseAt(startPos, phrase, kWidgetPhrase) > 0 &&
                                                 cp < (char *)&msg->data.words[50])
        {
          *(cp - 1) = ' ';
          cp += GetStructureReadOnly(phrase.tag.fRecNum)->
                                  AddTextToSpeak(phrase.tag.fRecNum, cp);
          *(cp++) = ' ';
          msg->data.words[1] |= 0x200;  // 09/01/96 avoid updating cursor for widget text
        }
      }
    }
#else
      cp--;
#endif
  }
  *cp = 0;
  UpdateCaretByWord(anchor, msg);

//  if (msg->data.words[1] >= 0)
//  {
//    EventInfo info;
//    TMainView mainView = fDocument->ActiveMainView();

//    app_GetEventInfo(&info, (wr_wimp_eventstr *)((char *)msg - 4));
//    anchor->fCursor->fSelection->MoveCursor(0x186, info, mainView);
//    if (msg->data.words[0] == 0)
//      msg->data.words[0] = 1;  // so if at end of doc, next call will recognise end
//  }
  return cp - theWord;
}
#endif

#if TALK == 2
// ------------------------------------------------------------------------
bool _TTextStructure::SayWord(TCharPos pos)
{
   char theWord[255];
   char *cp;
   int ready;

   if ((ready = Speaking()) != 0)
      return ready;                  // either talking or no module

   if (pos > 0 && GetChar(pos - 1) > 0x20)
   {
      CurFindWord(this, pos, kBackward);
      if (pos < 0 || GetChar(pos) <= 0x20)
         pos++;
   }
   for (cp = theWord; (*cp = GetChar(pos)) > 0x20; pos++, cp++) {}
   *cp = 0;
   Speak(theWord);
   return 0;
}

// ------------------------------------------------------------------------
void _TTextStructure::DoSpeak(TCursorNode cursor)
{
  TCharPos pos = TTextCursor(cursor)->GetCharPos();

  SetTextGlobals(this);
  if (pos == 0 || isalnum(GetChar(pos - 1)))
    while (SayWord(pos) > 0) {}
}
#endif

// ------------------------------------------------------------------------
//static 
Fixed SetGStyle(TLinePart &linePart, TMainView mainView)
{
   Fixed slop;

   gStyle.fcTextFont = linePart.fTextFont;
   gStyle.fcTextSizeX = linePart.fTextSizeX;
   gStyle.fcTextSizeY = linePart.fTextSizeY;
   gStyle.fcTextFace = (linePart.fTextFace & ~kBackwards);  // b/wds set by font
   gStyle.fcColour = linePart.fColour;
   gStyle.fcTextCaps = linePart.tag.cgf_35.fTextCaps;
   slop = linePart.fSlop;

   if (mainView != NULL) // && mainView->Zoomed())
   {
      gStyle.fcTextSizeX = mainView->ZoomInt(gStyle.fcTextSizeX);
      gStyle.fcTextSizeY = mainView->ZoomInt(gStyle.fcTextSizeY);
      slop = mainView->ZoomFixed(slop);
   }
   return slop;
}

// ------------------------------------------------------------------------
// new funcs for hyphenation
static bool IsLineBreak(int val)
{
  return (val >= kModifiedHyphen && val <= kLineBreak);
}


// ------------------------------------------------------------------------
static void SetLineExtent(Rect &extent, VPoint &itsSize, VPoint &itsLocation)
{
  // 29/05/90 - synchronise line extent with screen pixels vertically
  extent.top = itsLocation.v;
  extent.bottom = itsSize.v + itsLocation.v;
  extent.left = itsLocation.h;
  extent.right = itsSize.h + itsLocation.h;
}

// ------------------------------------------------------------------------
#define TestInHF(str) str->IsPartOf((1 << kHeader) | (1 << kFooter))

#define CaseMask(ch) (!caseSensitive && isupper(ch) ? tolower(ch) : ch)
#define widg 0
#define wild 1

// ------------------------------------------------------------------------
static bool QuickFind(Ptr itsTarget, Handle itsText, long &itsStart, long &itsEnd, bool caseSensitive, bool direction)
{
  char *findText = (char *)itsTarget;
  int len = strlen(findText);
  int ch;
  char firstChr;
  char *startOfBlock;
  char *endOfBlock;
  char *ptInText;
  int pt, n;
  int dir = (direction ? 1 : -1);
  bool found = FALSE;
  bool allSearched = FALSE;

  // skip out the wildcards first, if there is any, till we reach the 1st REAL character
  for (n = 0; (ch = findText[n]) == wild; n++) {}
  // while (findText[n] == wild)
  //  { n++; }
  firstChr = CaseMask(ch);

  startOfBlock = ((char*) itsText) + (direction ? itsStart : itsEnd);
  endOfBlock = ((char*) itsText) + (direction ? itsEnd : itsStart) - len;
  ptInText = (direction ? startOfBlock : endOfBlock);

  do
  {
    if (firstChr == 0)  // match string is all wild cards
      found = (ptInText >= startOfBlock && ptInText <= endOfBlock);
    else
      while (ptInText >= startOfBlock && ptInText <= endOfBlock)
      {
        ch = ptInText[n];
        if (CaseMask(ch) == firstChr)
        {
          found = TRUE;
          break;
        }
        ptInText += dir;
      }

    if (found)
    {
      // do full comparison (including wildcards) so no widget match!
      for (pt = 0; (pt < len) && found; pt++)
      {
        int ch1 = ptInText[pt];

        if (ch1 == widg || (ch = findText[pt], ch != wild && CaseMask(ch1) != CaseMask(ch)))
          found = FALSE;
      }
      if (!found)
        ptInText += dir;
    }
    else
      allSearched = TRUE;
  } while (!allSearched && !found);

  itsStart = (direction ? itsStart : itsEnd);
  itsStart += ptInText - startOfBlock;
  itsEnd = itsStart + len;

  return found;
}


// ------------------------------------------------------------------------
static inline bool InLeftPunct(char ch)
{
     // [20886] 20/4/93 & 8/4/92; 20/12/94 test \x009\x00A with < 32 test to use gPrefixes
  return (ch == 0 ? FALSE :
        (ch < 32 ? TRUE: int(strchr(gPrefixes, ch))));
}

static inline bool InRightPunct(char ch)
{
                  // [20886] 20/4/93 & 8/4/92
  return (ch == 0 ? FALSE : int(strchr(" /.,!\?;:)]}\"\'\x091\x095\x009\x00A\x00D", ch)));
}


// ------------------------------------------------------------------------
void IUTextEditor()
{
  gMainStruct = 0;
  gLinkStruct = 0;
  gDelPos = MAXLONGINT;
  gDelCount = 0;
  gLastCh = chUndef;
  gMarkCh = chNoMark;
  gPhraseIdx = -1;
  gActivePhrase.fCurrency = 0;          // 24/10/91 from gNullCurrency;
}


// ------------------------------------------------------------------------
_TTextStructure::_TTextStructure(TTextDocument itsDocument)
                                          : (itsDocument, sizeof(TPhrase))
{
#ifndef ZERO_OBJ
  fCount = 0;
  fFree = 0;
  fTempFlag = FALSE;
  fLinkStruct = 0;

  fOffset = 0;
  fUndoSize = 0;
  fFirstOffset = 0;
#endif
  fUndoOffset = -1; // 17/05/90 - set to -1 instead of 0 as 0 is a valid
                    // value for when a ToggleChanges gets done.
}


// ------------------------------------------------------------------------
int _TTextStructure::Compare(Ptr item1, Ptr item2)
{
  if (PPhrase(item1)->fCharPos != PPhrase(item2)->fCharPos)
    return PPhrase(item1)->fCharPos - PPhrase(item2)->fCharPos;
#if !defined TABLES || defined NETWP
  if (PPhrase(item1)->fKind != PPhrase(item2)->fKind)
    return PPhrase(item1)->fKind - PPhrase(item2)->fKind;
  // 24/10/94 [22030] stop an empty phrase being placed after a non-empty one at same charpos
  if (PPhrase(item1)->fNumChars == 0 && PPhrase(item2)->fNumChars != 0)
    return -1;
  if (PPhrase(item1)->fNumChars != 0 && PPhrase(item2)->fNumChars == 0)
    return 1;
  return 0;
#else
  return PPhrase(item1)->fKind - PPhrase(item2)->fKind;
#endif
}


// ------------------------------------------------------------------------
int _TTextStructure::GetFirstOffset(int start)
{
  return start + fFirstOffset;
}


// ------------------------------------------------------------------------
int _TTextStructure::InsertBefore(int index, Ptr item)
{
  int res;

#ifdef INDEX
  if (PPhrase(item)->fKind == kIndexRefPhrase)
    InsertIndexRef(index);
#endif
  res = _TSortedStructure::InsertBefore(index, item);

  // 20/09/90 safer to do after in case of failure
  fOffset += sizeof(TPhrase);
  if (fUndoOffset > fFirstOffset || (fUndoOffset == fFirstOffset && fSize == 1))
    fUndoOffset += sizeof(TPhrase);
  return res;
}


// ------------------------------------------------------------------------
void _TTextStructure::Delete(int index)
{
#ifdef INDEX
  PPhrase pphr = PPhrase(At(index));

  if (pphr->fKind == kIndexRefPhrase)
    RemoveIndexRef(index);
#endif
  _TSortedStructure::Delete(index);

  fOffset -= sizeof(TPhrase);
  if (fUndoOffset > fFirstOffset)
    fUndoOffset -= sizeof(TPhrase);
}

#define kCompPhraseSize 11
#define kCompTextStruct 4

// ------------------------------------------------------------------------
long _TTextStructure::DoNeedDiskSpace(long dataForkBytes)
{
//#ifdef AUTONUM
  return _TStructure::DoNeedDiskSpace(dataForkBytes + fCount +
#ifdef AUTONUM
       int(fOffset - AutoNumberOffset(this)) +  // this will be zero if not autonum
#endif
     kCompTextStruct + 1 - fSize * (int(sizeof(TPhrase)) - kCompPhraseSize) -
         int(sizeof(_TTextStructure)) + int(sizeof(_TStructure)));
//#else
//  return _TStructure::DoNeedDiskSpace(fCount + dataForkBytes +
//     kCompTextStruct - fSize * (int(sizeof(TPhrase)) - kCompPhraseSize) -
//         int(sizeof(_TTextStructure)) + int(sizeof(_TStructure)));
//#endif
}


// ------------------------------------------------------------------------
void _TTextStructure::DoRead(int aRefNum, long remainder, int version)
{
  {
    char buffer[kCompTextStruct];

    _TStructure::DoRead(aRefNum, sizeof(_TStructure), version);   // the inherited bits

    FRead(aRefNum, kCompTextStruct, buffer);
    UnpackRecord(0x0a, "\x04\x03\x19\x01\x03", buffer, NULL, &fLinkStruct);
    fOffset = fSize * sizeof(TPhrase);
#ifdef TRACE
    if (fStyle)
    {
      Assert(Curr_fType(fStyle) == kTextStyleStruct, 707);
    }
    else
      SysBeep(0);    // 01/06/95 rather than give assertion
#endif
    if (version >= 2)
    {
      FRead(aRefNum, 1, buffer);
#ifdef AUTONUM
      fOffset += buffer[0];
#else
      if (buffer[0] != 0)
        FailGeneral(34);    // fail if autonumbers found by StartWrite
#endif
    }
    fUndoOffset = -1;
    // fFree will be reset to zero, but DoReadArrayPart handles that.
  }
}


// ------------------------------------------------------------------------
void _TTextStructure::DoWrite(int aRefNum, long remainder)
{
  char buffer[kCompTextStruct + 1];

  _TStructure::DoWrite(aRefNum, sizeof(_TStructure));  // inherited bits

  PackRecord(0x0a, "\x04\x03\x19\x01\x03", &fLinkStruct, buffer);

//#ifdef AUTONUM
#ifdef AUTONUM
  buffer[kCompTextStruct] = fOffset - AutoNumberOffset(this);
#else
  buffer[kCompTextStruct] = 0;
#endif
  FWrite(aRefNum, kCompTextStruct + 1, buffer);
//#else
//  FWrite(aRefNum, kCompTextStruct, buffer);
//#endif
#ifdef TRACE
  Assert(fUndoOffset == -1 && fOffset == fSize * sizeof(TPhrase) + buffer[kCompTextStruct], 999);
  Assert(fDocument->fFileType == kTWScrapType || fTempFlag == 0, 998);
          // 13/06/95 fTempFlag should be cleared by commit / record locked to prevent purging
#endif
}

#ifdef TRACE
void BeepBreak()
{}
#endif

// ------------------------------------------------------------------------
void _TTextStructure::DoReadArrayPart(int aRefNum, int version)
{
  int txtOffset = fSize * sizeof(TPhrase);
//#ifdef AUTONUM
  long count = fOffset + fCount;
//#else
//  long count = txtOffset + fCount;
//#endif
  char *ptrToCR;

  SetPermHandleSize(&fPtrToArray, count);

  {
    char buffer[kCompPhraseSize];

    memset(fPtrToArray, 0, txtOffset);    // 11/03/91
    for (int i = 0; i < fSize; i++)
    {

      FRead(aRefNum, kCompPhraseSize, buffer);
      UnpackRecord(0x55, "\x03\x01\x03\x01\x01\x03\x04\x04",
                                       buffer, NULL, (TPhrase *)fPtrToArray + i);
#ifdef TRACE
      if (((TPhrase *)fPtrToArray)[i].fKind == kEditPhrase)
      {
        BeepBreak();
        // recovery: ((TPhrase *)fPtrToArray)[i].fNumChars = 0;
      }
#endif
    }
//#ifdef AUTONUM
    FRead(aRefNum, count - txtOffset,
                   (char *)fPtrToArray + txtOffset);  // read the auto number and text chars
//#else
//    FRead(aRefNum, fCount, (char *)fPtrToArray + txtOffset); // read the text chars
//#endif

    // fix corrupted docs until we find the cause
    if (fCount == 0)
    {
#ifdef TRACE
      int repl = fSize + '0';
      SysBeep(0);
#endif
      fSize = 0;  // 25/11/91 remove any phrases
      fOffset = 0; // ditto
#ifdef TRACE
      count = 2;  // 25/11/91 from count++
#else
      count = 1;  // 25/11/91 from count++
#endif
      fCount = count;  // 25/11/91 from 1
      SetPermHandleSize(&fPtrToArray, count);
#ifdef TRACE
      ((char *)fPtrToArray)[0] = repl;
#endif
    }
    ptrToCR = (char *)fPtrToArray + count - 1;
    if (*ptrToCR <= 2)                           // 13/08/93 [21016] recover fTempFlag
      fTempFlag = *ptrToCR;
    *ptrToCR = chReturn;
  }
}

// ------------------------------------------------------------------------
void _TTextStructure::DoWriteArrayPart(int aRefNum)
{
  char buffer[kCompPhraseSize];
  char *ptrToCR;

  for (int i = 0; i < fSize; i++)
  {
    PPhrase phrase = (TPhrase *)((char *)fPtrToArray + fFirstOffset) + i; // 10/02/92 + 1st offset
    if (phrase->fKind == kTextPhrase)
    {
       fDocument->SetUsedStyles(RecToCurrency(phrase->tag.txt.fStyle));
       fDocument->SetUsedStyles(RecToCurrency(phrase->tag.txt.fChanges));
    }
    PackRecord(0x55, "\x03\x01\x03\x01\x01\x03\x04\x04",
                                     phrase, buffer);
    FWrite(aRefNum, kCompPhraseSize, buffer);      // write the compressed array
  }
  ptrToCR = TextStart(this) + fCount - 1;   // 13/08/93
  if (fDocument->fFileType == kTWScrapType)
    *ptrToCR = fTempFlag;                                  // 13/08/93 [21016] save fTempFlag
// use shorter code if not Autonum. AutoNumberOffset must = fOffset
#ifdef AUTONUM
  {
    int autoOffset = AutoNumberOffset(this);

    FWrite(aRefNum, fCount + fOffset - autoOffset,
                             (char *)fPtrToArray + autoOffset);   // write the text bytes
  }
#else
#ifdef TRACE
  Assert(AutoNumberOffset(this) == fOffset, 974);
#endif
  FWrite(aRefNum, fCount, TextStart(this));      // write the text bytes
                     // 10/02/92 compensate for Commit not having been done
#endif
  *ptrToCR = chReturn;
}

// ------------------------------------------------------------------------
void _TTextStructure::AboutToRewrite(void *buffer, int buffLen)
{
  int arraySize = 0;
  char *currPos =  (char *)buffer + _TTextStructure::DoNeedDiskSpace(
                         sizeof(_TTextStructure) - fSize * sizeof(TPhrase));

#ifdef TRACE
   Assert(fSize == 0 && fCount == 0, 841);  // fSize should be removed above!!
#endif
   // position at start of array data: assumes _TTextStructure not overridden!

  _TStructure::AboutToRewrite(buffer, buffLen);

  memcpy(&arraySize, buffer, 2);   // the array count is first 2 bytes

  for (int i = 0; i < arraySize; i++)
  {
    TPhrase phrase;

    memset(&phrase, 0, sizeof(TPhrase));                // 28/03/91
    UnpackRecord(0x55, "\x03\x01\x03\x01\x01\x03\x04\x04",
                                             currPos, NULL, &phrase);
    currPos += kCompPhraseSize;

    if (phrase.fKind == kTextPhrase)
    {
       fDocument->SetUsedStyles(RecToCurrency(phrase.tag.txt.fStyle));
       fDocument->SetUsedStyles(RecToCurrency(phrase.tag.txt.fChanges));
    }
#ifdef TRACE
    else if (phrase.fKind == kEditPhrase)
      Assert(0, 174);
#endif 
  }
}

#ifdef FN
// ------------------------------------------------------------------------
int _TTextStructure::WriteAlienFootnote(int charPos, TSender sender, int fileType)
{
  int idx = FindPhraseGen(charPos, kNotePhrase);

  if (idx <= 0)
    return 0;
  {
    int bytesNeeded;
    TCursorNode noteAnchor;
    TCursorNode noteActiveEnd;
    TStructure subStruct;
    TCurrency noteCurrency = PPhrase(At(idx))->tag.fRecNum;
    volatile TCursorNode cursNode = new _TCursorNode(noteCurrency, kNewCursor, gZeroVPt);
    TCursorNode cursNodeCopy = cursNode;
    volatile TSelection aSelection = NULL;
    int oldProgress = HoldProgress(0);  // 12/04/94 do not update hourglass in note
    FailInfo fi;

    CatchFailures(&fi);

    // set up a cursor pointing to just before the CR at the end of the note:
    aSelection = new _TSelection(fDocument);
    aSelection->fAnchor = new _TCursor(aSelection);
    aSelection->fAnchor->InsertSubNodes(cursNode);
    cursNode = NULL;         //  now responsibility of the anchor cursor
    subStruct = GetStructureReadOnly(noteCurrency);
    subStruct->ExtendCursor(cursNodeCopy, noteCurrency, 2, TRUE, FALSE); // 2 means before CR
    aSelection->GetNodes(noteCurrency, noteAnchor, noteActiveEnd); // ExtendCur freed nodes!
    bytesNeeded = 2;

    if (sender != NULL)
    {
#ifdef TeX
      if (fileType == gTeXfile)    /* TeX */
        SendAlienFile(subStruct->fDocument, noteCurrency, NULL, noteAnchor, sender);
      else
#endif
      {
        sender->SendChar('«');
        subStruct->WriteAlienData(noteCurrency, NULL, noteAnchor, sender, this,
                                                          NULL, NULL, 0);
        sender->SendChar('»');
      }
    }
    else
    {
      subStruct->DoNeedAlienSpace(noteCurrency, NULL, noteAnchor, fileType, &bytesNeeded);
    }
    Success(&fi);

    FreeIfObject(aSelection);
    /* SetTextGlobals(this);  // crap - needed because FreeBuffer tests vs gMainStruct! */
    HoldProgress(oldProgress);                              // restore progress after note
    return bytesNeeded;

Rescue:
    FreeIfObject(aSelection);
    FreeIfObject(cursNode);
    ContinueFailure(&fi);
  }
}
#endif

// ------------------------------------------------------------------------
int _TTextStructure::WriteTextLine(TSender sender, TCharPos cp1, TCharPos cp2)
{
  volatile Handle textStructBuffer = NULL;
  int paraSize = cp2 - cp1;
  char* charPtr;
  int ch;
  int placeInOrig;
  int finalCR;
  FailInfo fi;

#ifdef TRACE
  Assert(fFirstOffset == 0, 607);
#endif
  CatchFailures(&fi);
  IsEmpty();   // SetTextGlobals(this);
#ifdef AUTONUM
  if (cp1 == 0 && (placeInOrig = AutoNumberOffset(this)) < fOffset)
  {
    // assume any auto number to be saved too
    for (charPtr = (char *)fPtrToArray + placeInOrig; (ch = *(charPtr++)) != 0; )
    {
      if (ch >= 32)    // 02/05/95 remove 0x15 Rt just comment chars
        sender->SendChar(ch);
    }
    // 02/05/95 sender->SendString((char *)fPtrToArray + placeInOrig, fOffset - placeInOrig - 1);
    sender->SendChar(chTab);
  }
#endif
  charPtr = GetBuffer(cp1, MAXLONGINT, kLineBreakMixed, textStructBuffer, NULL);
                                                  // paraSize for MAXLONGINT???
  finalCR = charPtr[paraSize - 1] == chReturn;
  paraSize -= finalCR;                 // do not process the final CR in loop

  // zonk thru our buffer changing LFs and removing widget chrs (or expanding notes)
  for (placeInOrig = 0; placeInOrig < paraSize; placeInOrig++)
  {
    ch = charPtr[placeInOrig];
    if (ch == chLineFeed)
    {
#ifdef CONT
      if (fDocument->fSaveCmd == cSaveContents) // 11/08/95 Avoid 0d in Contents output
        sender->SendChar(' ');
      else
#endif
        sender->SendLineBreak();  // ch = chReturn;
    }
    else if (ch != chWidget)
      sender->SendChar(ch);
    else
    {
#ifdef FN
#ifdef CONT
      if (fDocument->fSaveCmd != cSaveContents)      // [22027]
#endif
      {
        WriteAlienFootnote(placeInOrig + cp1, sender, 0);
      }
#endif
    }
  }
  Success(&fi);
  FreeBuffer(textStructBuffer);
  return finalCR;

Rescue:
  FreeBuffer(textStructBuffer);
  ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
void _TTextStructure::WriteAlienData(TCurrency currency, TCursorNode anchor,
          TCursorNode activeEnd, TSender sender, TStructure parent,
          TCursorNode parentAnchor, TCursorNode parentActiveEnd, long pos)
{
  TCharPos cp1, cp2;

  cp1 = GetSelectionStartPos(anchor, activeEnd);
  cp2 = GetSelectionEndPos(anchor, activeEnd);

  if (WriteTextLine(sender, cp1, cp2))
  {
    // Final CR has not been processed, see if it should become CR or Tab (after cell)
    if (activeEnd != NULL || parent == NULL ||
                     parent->GetAlienTerm(pos, parentAnchor, parentActiveEnd) >= 0)
    {
      sender->SendParaBreak();
    }
    else
    {
      sender->SendChar(chTab);
    }
  }
}


// ------------------------------------------------------------------------
void _TTextStructure::DoNeedAlienSpace(TCurrency currency,
  TCursorNode anchor, TCursorNode activeEnd, int fileType, int *bytesNeeded)
{
  TCharPos cp1, cp2;
  int numOfWidgets = 0;
  char* charPtr;
  Handle textStructBuffer;
  int paraSize;

  cp1 = GetSelectionStartPos(anchor, activeEnd);
  cp2 = GetSelectionEndPos(anchor, activeEnd);
  paraSize = cp2 - cp1;

  // 20/07/90 - reduce the paragraph size by the number of widgets there are
  IsEmpty();   // SetTextGlobals(this);
#ifdef AUTONUM
  if (cp1 == 0)
    // assume any auto number to be saved too
    *bytesNeeded += (fOffset - AutoNumberOffset(this));
#endif
  charPtr = GetBuffer(cp1, MAXLONGINT, kLineBreakMixed, textStructBuffer, NULL);
                         // 24/10/90 ignore any hyphens
  for (int n = 0; n < paraSize; n++)
  {
    int ch = charPtr[n];

    // 31/07/92 make the test the same as above - not just ch == chWidget
    if (ch == chWidget)
    {
      // 27/04/93 [20884]        || (ch == chReturn && activeEnd != NULL) 
#ifdef FN
      // could test save command is not cSaveContents, but that does not call DoNeedAlSp
      // [22027]
      *bytesNeeded += WriteAlienFootnote(n, NULL, fileType);
#endif
      numOfWidgets++;
    }
  }
  FreeBuffer(textStructBuffer);

  *bytesNeeded += (paraSize - numOfWidgets);
}

// ------------------------------------------------------------------------
void _TTextStructure::MarkForReformatChgs(TCurrency currency)
{
  // 13/06/95 [26016] new to stop recs marked with fTempFlag being purged
  // after spell checking or replace all
  fTempFlag = TRUE;
  SetChanged(currency, gNullCurrency, TRUE);
  fDocument->LockCurrency(currency, TRUE);
}


#if defined MATHS || defined INDEX
// ------------------------------------------------------------------------
void _TTextStructure::DoSetupMenus(TCurrency currency, TCursorNode anchor,
                                                       TCursorNode activeEnd)
// 12/01/92 new - disable maths if text is target
{
  _TStructure::DoSetupMenus(currency, anchor, activeEnd); // 29/06/92

#ifdef MATHS
  for (int i = cIntegralOp; i <= cExpression; ++i)
    EnableCmd(i);

// 01/06/92 Enable the operators and the following in the above loop
//  EnableCmd(cSuperscript);  // 24/03/92
//  EnableCmd(cSubscript);  // 24/03/92
//  EnableCmd(cFraction);  // 24/03/92
//  EnableCmd(cRoot);  // 24/03/92
//  EnableCmd(cDelimiters);  // 24/03/92
//  EnableCmd(cMatrix);  // 24/03/92
//  EnableCmd(cExpression);
  EnableCmd(cNewMatrix);  // 14/04/92
  DisableCmd(cAbove);
  DisableCmd(cBelow);
  EnableCmd(cFunction);  // 24/03/92
  DisableCmd(cText);
  DisableCmd(cSetAlignment);
// 24/03/92  Enable(cEqnNumber, FALSE);

  EnableCmd(cContourInt1);                   // 01/06/92
  EnableCmd(cContourInt2);                   // 01/06/92
  EnableCmd(cContourInt3);                   // 01/06/92

#if defined TABLES && ! defined NETWP
// 11/01/94  EnableMenu(cmLanguage);  // 28/04/92 may be turned off if inside maths
  EnableCmd(cLanguageMenu); // 11/01/94
#endif
#endif
#if defined INDEX && !defined NETWP
  {
    int charpos = TTextCursor(anchor)->GetCharPos();
    int updateIdx = 1;
    int homeCurr;

    SetTextGlobals(this);
    homeCurr = GetIndexPhraseAt(currency, charpos, updateIdx);

    if (GetChar(charpos) >= 32)
    {
      EnableCmd(cAddBookmark);
      EnableCmd(cAddToIndex);
    }
    SetBookmarkMenu(fDocument, homeCurr);
    updateIdx = 0;
    homeCurr = GetIndexPhraseAt(currency, charpos, updateIdx);
    Enable(cAddToIndexI, !homeCurr && anchor != activeEnd);
  }
#endif
}
#endif

#ifdef MATHS
// ------------------------------------------------------------------------
// 13/01/92 new
void _TTextStructure::EndStructure(TCurrency currency, TCursorNode anchor,
                                          int part, Rect &custom)
{
  TTextEdge edge;

  anchor->Collapse();
  TTextCursor(anchor)->GetEdge(edge);
  SetTextGlobals(this);
  edge.fCharPos = fCount;
  if (gLinkStruct != NULL)
    edge.fCharPos -= gDelCount;
  edge.fPixelPos = MAXLONGINT;     // 10/02/94 from MAXINT
  edge.fPartNum = fDocument->ActiveMainView()->GetFormatReadOnly(currency)->fSize;
  TTextCursor(anchor)->SetEdge(edge);
}
#endif

// ------------------------------------------------------------------------
TStyleTypes _TTextStructure::GetKind()
{
  return(kText);
}


// ------------------------------------------------------------------------
bool _TTextStructure::CanIndent(TCurrency currency)
{
  // 29/05/90 - new mac method
  return (GetStructureReadOnly(fParent))->CanIndent(currency);
}


// ------------------------------------------------------------------------
bool _TTextStructure::CanLink(TCurrency currency)
{
  // 24/01/91 - new mac method
  return FALSE;
}


// ------------------------------------------------------------------------
TCurrency _TTextStructure::GetLink()
{
  // 24/01/91 - new mac method
  return fLinkStruct;
}


// ------------------------------------------------------------------------
bool _TTextStructure::IsShown(TCurrency currency, TCurrency child)
// 14/05/91 new
{
  if (_TStructure::IsShown(currency, child))
  {
    // int ins;
    // int del;
    // int startDel;
    // int endDel;
    PPhrase aPhrase;
    int lim, lim0; // [20863] 12/5/93 added
#ifdef INDEX
    int indexPos = 0;
#endif

    if (child == 0 || FindDeletionPhrase() == 0)                       // 20/05/91
      return TRUE;
    SetTextGlobals(this);
    lim0 = GetSize(); // [20863] 12/5/93 added
    lim = lim0 + (gLinkStruct == NULL ? 0 : gLinkStruct->GetSize()); // [20863] 12/5/93 added
    for (int i = 1; i <= lim /* [20863] was GetSize() */ ; i++)
    {
      aPhrase = PPhrase(i <= lim0 ? At(i) : gLinkStruct->At(i - lim0)); // [20863] 12/5/93
      int offset = (i <= lim0 ? 0 : fCount); // [20863] 12/5/93 added
      if ((
#ifdef INDEX
            (aPhrase->fKind == kIndexRefPhrase && (indexPos += 256, child == indexPos)) ||
#endif
           ((aPhrase->fKind == kWidgetPhrase 
#ifdef FN
            || aPhrase->fKind == kNotePhrase // [20863] 12/5/93
#endif
          ) &&
          aPhrase->tag.fRecNum == child)) &&     // 20/05/91
          aPhrase->fCharPos + offset >= gDelPos &&
                        // [21137] 01/12/93 startDel && // [20863] 12/5/93 added + offset
          aPhrase->fCharPos + offset < gDelPos + gDelCount)
                        // [21137] 01/12/93 endDel) // [20863] 12/5/93 added + offset
        return FALSE;
    }
    return TRUE;
    // end inline HasDeletedWidget
  }
  return FALSE;
}


// ------------------------------------------------------------------------
bool _TTextStructure::IsEmpty()
{
  // 25/07/90 - new mac method
  Size numChars;

  SetTextGlobals(this);
  numChars = fCount - gDelCount;
  if (gLinkStruct != NULL)
    numChars += gLinkStruct->fCount;

  return (numChars <= 1);
}


// ------------------------------------------------------------------------
void _TTextStructure::IteratePart(TCurrency currency, int part, Rect &custom,
   TStructure pasteStructure, TCurrency pasteCurrency, TTextDocument clipDocument,
                                  TObject obj, DoPartStep procToDo, ...)
{
   if (fSize != 0)
   {
      char *args = (char *)&procToDo + sizeof(procToDo);
      char *p = (char *)GetFirstOffset((int)fPtrToArray);

      for (int i = 1; i <= fSize; i++)
      {
         if (PPhrase(p)->fKind == kWidgetPhrase)
            procToDo(obj, PPhrase(p)->tag.fRecNum, PPhrase(p)->fCharPos,
                                             *(TTextIteratePartList *)args);
         p += fItemSize;
      }
   }
// 23/05/91 new
   if (pasteCurrency != 0)
   {
// 14/06/93 [20933] see PastePhrase:    if (!TTextStructure(pasteStructure)->fTempFlag)
     {
        long pos = -1;

        pasteStructure->InsertSubStructure(1, clipDocument, pasteCurrency,
                                                pasteCurrency, pos);
     }
   }
}

// ------------------------------------------------------------------------
// 30/09/91 new for getting highlighted positions in cells 
int _TTextStructure::GetSelectionStartPos(TCursorNode anchor, TCursorNode activeEnd)
{
  return (anchor == NULL
#ifdef TABLES
                 || (activeEnd == NULL && Curr_fType(fParent) == kTableStruct)
#endif
          ? 0 : TTextCursor(anchor)->GetCharPos());
}

// ------------------------------------------------------------------------
int _TTextStructure::GetSelectionEndPos(TCursorNode anchor, TCursorNode activeEnd)
// 30/09/91 new for getting highlighted positions in cells 
{
  return (activeEnd == NULL
#ifdef TRACE
// what??              || (anchor == NULL && Curr_fType(fParent) == kTableStruct)
#endif
       ? (fTempFlag ? fCount - 1 : fCount) : TTextCursor(activeEnd)->GetCharPos());
           // 15/03/93 [20707] test fTempFlag
}

#ifdef DRAGDROP
// ------------------------------------------------------------------------
int _TTextStructure::WhatsSelected(TCurrency currency,
                               TCursorNode anchor, TCursorNode activeEnd)
{
  TCharPos cp1 = GetSelectionStartPos(anchor, activeEnd);
  TCharPos cp2 = GetSelectionEndPos(anchor, activeEnd);
  TCharPos textStart = cp1;
  int index = 1;
  int flags = 0;
  TCursorNode ancNext;  // = NULL;
  TCursorNode actNext;  // = NULL;
  TCurrency ancNextCurr;
  TCurrency actNextCurr;

  if (!IsLastNode(anchor))     // if (anchor != NULL && !anchor->IsLast())
  {
    ancNext = anchor->GetNext();
    ancNextCurr = ancNext->fCurrency;
  }
  else
  {
    ancNext = NULL;
    ancNextCurr = 0;
  }
  if (!IsLastNode(activeEnd))  //  if (activeEnd != NULL && !activeEnd->IsLast())
  {
    actNext = activeEnd->GetNext();
    actNextCurr = actNext->fCurrency;
    cp2++;
  }
  else
  {
    actNext = NULL;
    actNextCurr = 0;
  }

  SetTextGlobals(this);
  for ( ; ; )
  {
     TPhrase phrase;
     int inc = phrase.fNumChars;

     index = GetPhrase(index, phrase);
     if (index == 0)
        break;
     index++;
     inc = phrase.fNumChars;
     if (phrase.fCharPos + inc > cp1 && phrase.fCharPos < cp2)
     {
        if (phrase.fKind == kWidgetPhrase)
        {
           TCurrency widgetCurr = phrase.tag.fRecNum;
           flags |= GetStructureReadOnly(widgetCurr)->FindWhatsSelected(widgetCurr,
                              ancNextCurr == widgetCurr ? ancNext : NULL,
                              actNextCurr == widgetCurr ? actNext : NULL);
           SetTextGlobals(this);
        }
#ifdef FN
        else if (phrase.fKind == kNotePhrase)
        {
           flags |= kFootnoteSelected;
        }
#endif
        else
           inc = 0;
        if (textStart + inc == phrase.fCharPos + inc)
           textStart += inc;
     }
  }
  if (textStart < cp2)
     flags |= kTextSelected;
  return flags;
}
#endif


// ------------------------------------------------------------------------
void _TTextStructure::PastePhrase(TPhrase *pphrase, long before,
                                   TTextDocument sourceDoc, int offset,
                                   TCurrency parent, bool addPhrase
#ifdef DRAGDROP
                                   , int isPaste
#endif
                                   ) // fn1
{
  TPhrase phrase;

  // If whole para has been pasted into non-text, there is only 1 call with addPhrase FALSE
  // If text has been embedded in a paragraph, the first call with addPhrase TRUE just
  // inserts in the phrases from the clipboard. A second call will then be made which goes
  // through all the phrases, which updates only those pasted (fOriginalPhrase == 0)

  // 14/06/93 [20933] leave phrases alone which did not originate from clipboard
  // 25/08/93 [21035] logic reversed so dropping document on a window can be recognised
  if (pphrase->tag.paste.fOriginalPhrase != 0)
  {
#ifdef TRACE
    if (addPhrase)
      SysBeep(0);
#endif
    if (pphrase->tag.paste.fOriginalPhrase == -1)     // it is an original phrase, reset it
      pphrase->tag.paste.fOriginalPhrase = 0;
    return;
  }

  memcpy(&phrase, pphrase, sizeof(TPhrase));
  phrase.fCharPos += before - offset;       // 25/04/91 offset passed in
#ifdef FN
  if (phrase.fKind == kNotePhrase)
  {
    if (IsPartOf((1 << kFootnote) | (1 << kHeader) | (1 << kFooter)) == 0)
          // 21/01/94 [21356] test for drag/paste into header or footer too
    {
      if (addPhrase)         // 14/06/93 [20933] do DoPasteBody later if AddPhrase
         Insert(&phrase);
      else
      {        
        long pos = MAXLONGINT;
        int level = 0;
        TCurrency noteCollector = GetNoteCollector();
        TStructure collectorStruct = GetStructureReadWrite(noteCollector);
        TCurrency pastedNote;
        TPasteSaveArea saveArea;        // 11/05/93 [20864]
      
        SavePastePosition(&saveArea);   // 11/05/93 [20864]
        collectorStruct->DoPasteBody(phrase.tag.fRecNum, pos, 
                  sourceDoc, &pos, noteCollector, &pastedNote, &level,
#ifdef DRAGDROP
                  isPaste
#endif
                  );
        RestorePastePosition(&saveArea);  // 11/05/93 [20864]
        phrase.tag.fRecNum = pastedNote;        
        memcpy(pphrase, &phrase, sizeof(TPhrase));
        _TStructure::AddNote(parent, pastedNote);
      }
    }
    else
    {
      // 20/05/93 [20881] paste a footnote ref into a footnote
      *(TextStart(this) + phrase.fCharPos) = 0x20;  // remove 0 byte

      if (!addPhrase)
        pphrase->fNumChars = 0;                                   // remove phrase at end
    }
  }
  else
#endif
  {
//    03/11/94 moved into addPhrase else branch
//    if (phrase.fKind == kTextPhrase && !addPhrase)  // 14/06/93 [20933] not if addPhrase
//    {
//      if (phrase.tag.txt.fStyle != 0)
//        phrase.tag.txt.fStyle = fDocument->ConvertAndCloneStyle(sourceDoc,
//                                                   phrase.tag.txt.fStyle);
//      if (phrase.tag.txt.fChanges != 0)
//        phrase.tag.txt.fChanges = fDocument->ConvertAndCloneStyle(sourceDoc,
//                                                   phrase.tag.txt.fChanges);
//    }
    if (addPhrase)
      Insert(&phrase);
    else
    {
      // 14/06/93 [20933] moved down: clone styles of kTextPhrase not if addPhrase
      if (phrase.fKind == kTextPhrase)
      {
        if (phrase.tag.txt.fStyle != 0)
          phrase.tag.txt.fStyle = fDocument->ConvertAndCloneStyle(sourceDoc,
                                                   phrase.tag.txt.fStyle);
        if (phrase.tag.txt.fChanges != 0)
          phrase.tag.txt.fChanges = fDocument->ConvertAndCloneStyle(sourceDoc,
                                                   phrase.tag.txt.fChanges);
      }
      memcpy(pphrase, &phrase, sizeof(TPhrase));
#ifdef INDEX
      if (phrase.fKind == kIndexRefPhrase)
        PasteIndexRef(pphrase, parent, fDocument);
#endif
    }
  }
}


// ------------------------------------------------------------------------
bool _TTextStructure::IsMacroPhase(PPhrase phr)
{
  // 13/09/90 - method new to mac
  return (phr->fKind == kMacroPhrase);
}


// ------------------------------------------------------------------------
bool _TTextStructure::IsFirstWidgetPhraseForPaste(PPhrase phr, TCurrency currency)
{
  // return (phr->fKind == kWidgetPhrase && (phr->tag.fRecNum.cgf_31.fRecnum & 0x8000) != 0);
  if (phr->fKind == kWidgetPhrase && phr->tag.fRecNum < 0)
  {
    phr->tag.fRecNum = currency;  // 11/08/93 do here, rather than after call
    return TRUE;
  }
  return FALSE;
}

// ------------------------------------------------------------------------
static void MarkOriginalPhrase(TTextStructure self, TPhrase *pphrase)
{
  // 25/08/93 [21035] New: ensure all the original phrases have non-zero fOriginalPhrase
  if (pphrase->tag.paste.fOriginalPhrase == 0)
    pphrase->tag.paste.fOriginalPhrase = -1;
}

// ------------------------------------------------------------------------
void _TTextStructure::InsertSubStructure(int isPaste,
                      TTextDocument sourceDoc, TCurrency parent,
                      TCurrency &currency, long &before)
{
  TTextStructure textToPaste;
  long textLen;
  char *sourcePtr;
  int cp2;
  int offset, addToLeft, addToRight;
  TPhrase widgetPhrase;
  int pn;

  if (currency == parent)    // 29/11/90 frig for emph styles
  {
    // fn1 changed to use PastePhrase instead of CloneEmphases: saves some code
    offset = before;
    Each(this, (DoToItem)_TTextStructure::PastePhrase,
         before, sourceDoc, offset, parent, FALSE, isPaste);
#ifdef FN
    DeleteEmptyPhrases(kAnyPhrase);   // 20/05/93 [20881]
#endif
    // fn1 end
  }
  else if (Curr_fType(currency) == kTextStruct)
  {
    FailSpaceIsLow();
    textToPaste = TTextStructure(GetStructureReadOnly(currency));
    textLen = textToPaste->fCount - 1;
    addToLeft = addToRight = 0;
    cp2 = fOffset + before;
#ifdef TRACE
    Assert(fFirstOffset == 0 && textToPaste->fFirstOffset == 0, 608);
#endif
    if (textToPaste->fTempFlag == kIntelligent && isPaste)
    {
      int prevCh;

      prevCh = before - 1;
      if (isPaste == cPaste)  // 04/03/94 [21441] but NOT if cMove
      {
        // 05/08/93 [20978] need SetTextGlobals for gDelpos test (paste after clearing word)
        SetTextGlobals(this);
        if (before > gDelPos)
          prevCh -= gDelCount;
        // prevCh = before - (before > gDelPos ? gDelCount + 1 : 1);
      }
      if (prevCh >= 0 && !InLeftPunct(*(TextStart(this) + prevCh)))
        addToLeft = 1;
      if (!InRightPunct(*((char *)fPtrToArray + cp2)))
        addToRight = 1;
    }

    sourcePtr = (char *)textToPaste->fPtrToArray + textToPaste->fOffset;
#ifdef THESAURUS
    StringConvertCase(sourcePtr, textLen, fTempFlag);
#endif
    textLen += addToLeft + addToRight;
    InsertSlice(cp2, sourcePtr - addToLeft, textLen);
    sourcePtr = (char *)fPtrToArray + cp2;
    if (addToLeft == 1)
      *sourcePtr = chSpace;
    if (addToRight == 1)
      *(sourcePtr + textLen - 1) = chSpace;
    fCount += textLen;
    UpdatePhrases(before, textLen, TRUE, FALSE); // 23/09/92 extra param
        // 16/7/92 back to TRUE cos pasting after macro fails 10/02/92 from FALSE);
    if (isPaste)
      NewEditPhrase(before, textLen, FALSE);  // 09/04/92 moved up

    // 25/08/93 [21035] Mark original phrases in a paragraph into which phrases
    // are being pasted with non-zero fOriginalPhrase rather than vice versa
    Each(this, (DoToItem)MarkOriginalPhrase);
    textToPaste->Each(this, (DoToItem)_TTextStructure::PastePhrase,
                  before, sourceDoc, -addToLeft, parent, TRUE, isPaste); // fn1
    JoinPhrases();
    // 21/4/93 [20883] removed block to cope with styles of para inserted in para
    fDocument->DeleteCurrency(currency);
    currency = 0;
    before += textLen;
    fTempFlag = TRUE;         // 27/06/91
    SetPastePosition(parent, before);    // 10/09/92
  }
  else
  {
    // widgets - 03/05/90 - new to mac
    pn = FirstThat(this, (TestItem)_TTextStructure::IsFirstWidgetPhraseForPaste, currency);
    if ((isPaste) && (pn == 0))
    {
      UpdatePhrases(before, 1, TRUE, FALSE); // 25/09/92 T,F for paste widget over 2 paras
      widgetPhrase.fCharPos = before;
      widgetPhrase.fNumChars = 1;
      widgetPhrase.fKind = kWidgetPhrase;
      widgetPhrase.tag.fRecNum = currency;
      Insert(&widgetPhrase);
      NewEditPhrase(before, 1, FALSE);
      InsertChar(chWidget, before);
      before++;
      SetPastePosition(currency, -1);    // 10/09/92
    }
// 11/08/93 else might as well do in IsFirstWidgetPhraseForPaste
//    else
//    {
//      Get(pn, &widgetPhrase);
//      widgetPhrase.tag.fRecNum = currency;
//      AtPut(pn, &widgetPhrase);
//    }
  }
}

#ifdef FN
// ------------------------------------------------------------------------
static void DoFindStart(TObject null, TCurrency currency, long posn,
                                 TCurrency *newStart)
{
  if (*newStart == 0)
    *newStart = currency;
}
#endif

static char gStyleLookup[] = { kDocumentTitle, kChapterTitle, kPageNumber,
    kPagesInDocument, kNewTime, kNewDate, kContinuationText, kPagesInChap };
// for:                        kDocTitle,      kChapTitle,    kPageNum,
//  kPageCount,      kCurrTime, kCurrDate, kContText,        kChapCount

// ------------------------------------------------------------------------
int _TTextStructure::InitNewPhrase(TCurrency currency, TCurrency subStruct,
 TCurrency subStyle, TStyleTypes styleType, TStructureCmd command, int charPos)
{
  TPhrase phrase;
  int chToInsert;
  int incr = 0; // 13/5/92

  phrase.fCharPos = charPos;
  phrase.fKind = kMacroPhrase;

// MMerge 13/5/92 added condition and replaced 1s by incr
// 07/07/92 moved so does not go down either of following paths
  if (command->fCmdNumber < 0)
  {
    char str[255];
    char *p = str;

    CmdToName(command->fCmdNumber, str + 1);
    phrase.tag.macro.fMergeField = fDocument->GetFieldNumber(str + 1);
    phrase.tag.macro.fMacroType = kMergeField;
    str[0] = '«';
    strcat(str, "»");
    for (int cp = phrase.fCharPos; *p; incr++)
      InsertChar(*p++, cp++);
  }
  else
  {
#if defined MATHS || defined FN
    if (styleType >= kDocTitle && styleType <= kChapCount)  // 17/06/92 safer test
    {
#endif
      phrase.tag.macro.fMergeField = 0; // MMerge 13/5/92
      phrase.tag.macro.fMacroType = gStyleLookup[styleType - kDocTitle]; // 13/5/92 MMerge
      chToInsert = ' ';
#if defined MATHS || defined FN
    }
// fn1 code added to this part & 24/03/92 updated for columns and cursor setting
//17/06/92 if (styleType == kMaths || styleType == kColumns || command->fCmdNumber == cFootNote)
    else
    {
      TStructure structure = GetStructureReadWrite(subStruct);
      structure->
        InitNewStructure(currency, subStruct, subStyle, styleType, TRUE, command);
      phrase.tag.fRecNum = subStruct;

#ifdef FN
      if (command->fCmdNumber == cFootNote)
      {
        TCurrency newStart;

        newStart = 0;
        structure->IteratePart(subStruct, 1, gZeroRect, NULL, gNullCurrency,
          NULL, this, (DoPartStep)DoFindStart, &newStart);
        command->SetStart(newStart);
        command->SetPositionData(0);  // 06/09/92, 
        // 11/11/93 [21118] 0 from -1 to stop messing up deferred style changes at start
        // of footnote - but would be fixed by 21117 change anyway
        phrase.fKind = kNotePhrase;
      }
      else
#endif
        phrase.fKind = kWidgetPhrase;

      chToInsert = chWidget;  // 22/4/92 needs a different number for fn, 9/7/92 was '1'
    }
#endif
    incr = 1;
    InsertChar(chToInsert, phrase.fCharPos);
  }
  phrase.fNumChars = incr;
  UpdatePhrases(phrase.fCharPos, incr, FALSE, FALSE); // 23/09/92 extra param
  Insert(&phrase);
  NewEditPhrase(phrase.fCharPos, incr, FALSE);
// end MMerge chgs

#ifdef FN
  if (command->fCmdNumber == cFootNote)      // fn1 added if clause
    AddNote(currency, subStruct);
#endif
  return incr;
}

// ------------------------------------------------------------------------
void _TTextStructure::NewStructure(TCurrency currency, TCursorNode anchor,
          TCursorNode activeEnd, TCurrency subStruct, TCurrency subStyle,
          TStyleTypes styleType, TNewStructureCmd command)
          // 24/03/92 CmdNumber command, TCurrency &newStart, TCurrency &newEnd)
{
  int incr;
  TCharPos caret;  // 07/09/92 = TTextCursor(anchor)->GetCharPos();      // 23/05/91
#ifdef MATHS
  TCurrency widgetCurr;

  widgetCurr = 0;   // 04/09/92
#endif

  caret = TTextCursor(activeEnd)->GetCharPos();    // 07/09/92 put new struct after seln
  if (!anchor->IsCursor(activeEnd))
  {
    TCharPos anchorPos = TTextCursor(anchor)->GetCharPos();

    if (anchorPos == caret)                  // 14/09/92
      caret++;
#ifdef MATHS
    if (anchorPos == caret - 1)
    {
      int pn = FindPhrase(anchorPos);

      if (pn != 0 && command->fCmdNumber != cFootNote && subStruct != 0)
      {
        // pass widget into new structure
        widgetCurr = PPhrase(At(pn))->tag.fRecNum;
        NewEditPhrase(anchorPos, 1, TRUE);
      }
    }
#endif
  }

  incr = InitNewPhrase(currency, subStruct, subStyle, styleType, command,
          Min(fCount - 1, caret)); // 21/07/92 common up code

#ifdef MATHS
  if (widgetCurr != 0)   // 04/09/92
  {
    GetStructureReadWrite(subStruct)->
      InsertSubStructure(0, fDocument, subStruct, widgetCurr, command->fPosn);
//    ResetCursor(anchor, caret, FALSE, FALSE);  // 07/09/92 so widget gets commited
  }
#endif

  TTextCursor(activeEnd)->SetCharPos(caret + incr);       // 23/05/91 fm macroPh
  activeEnd->Collapse();                                  // 14/09/92 macro with widget sel
}


// ------------------------------------------------------------------------
void _TTextStructure::InitNewStructure(TCurrency parent, TCurrency currency,
   TCurrency newStyle, TStyleTypes styleType, bool initialise, TStructureCmd command)
{
  if (newStyle == 0)
    newStyle = fDocument->GetStyleAtLevel0(kText);  // 22/11/90 pick dflt
  IStructure(/*fDocument,*/ parent, newStyle);
  if (initialise)             // 24/03/92
  {
    InsertChar(chReturn, 0);  // 25/07/90
#ifdef MATHS
    if (command != NULL)
    {
      if (command->fCmdNumber == cParagraph || command->fCmdNumber == cText)
        command->SetStart(currency);
      else
      {
        TStyleTypes styleType;
        TStructTypes structType;
        TCurrency subStruct;
        TCurrency subStyle;

        if (CommandToStruct(command->fCmdNumber, styleType, structType))
        {
          TDiscObject obj;
          int level;

          subStruct = fDocument->NewCurrency(structType, obj);
          level = GetLevel();
#ifdef TRACE
          Assert(styleType != kSection && command->fCmdNumber != cSection, 900);
               // prove code below unnecessary
#endif
          if (styleType == kSection && level == 1)
            level = 2;
          else if (command->fCmdNumber == cSection && level > 2)
            level--;
          subStyle = fDocument->GetStyleAtLevel(styleType, level);
        }
        else
        {
          subStruct = 0;
          subStyle = 0;
        }
        InitNewPhrase(currency, subStruct, subStyle, styleType, command, 0);
                                            // 21/07/92 common up code
      }
    }
#endif
  }
}


// ------------------------------------------------------------------------
bool _TTextStructure::HandlesEdit(PPhrase thisPhrase, TCharPos cp, Size len, bool deletions)
// new 20/06/90
{
//  register PPhrase thisPhrase = PPhrase(At(index));

  if (thisPhrase->fKind == kEditPhrase)
  {
#ifdef TRACE
    Assert(thisPhrase->tag.fDeletions != deletions, 174);
#endif
    if (thisPhrase->fCharPos == cp && thisPhrase->fNumChars == len)
    {
      // invert this phrase
      thisPhrase->tag.fDeletions = deletions;
      return TRUE;
    }
  }
  return FALSE;
}

// ------------------------------------------------------------------------
void _TTextStructure::NewEditPhrase(TCharPos cp, Size len, bool deletions)
{
// 20/06/90 modified to prevent conflicting phrases from occuring
  if (FirstThat(this, (TestItem)_TTextStructure::HandlesEdit, cp, len, deletions) == 0)
  {
    TPhrase phrase;

    phrase.fKind = kEditPhrase;
    phrase.fCharPos = cp;
    phrase.fNumChars = len;
    phrase.tag.fDeletions = deletions;

    Insert(&phrase);
  }
}


// ------------------------------------------------------------------------
bool _TTextStructure::UpdateStatistics(int increment, PStatistics stats)
{
  if (increment != 0)
  {
    int charCount = fCount;
    int wordCount = 0;
    bool inWord = FALSE;
    char *cp = TextStart(this);
    char *final = cp + charCount;

    for (; cp < final; cp++)
    {
      if (*cp == chWidget)
      {
        inWord = FALSE;
        charCount--;
      } else if (*cp <= chSpace)
        inWord = FALSE;
      else if (!inWord)
      {
        inWord = TRUE;
        wordCount++;
      }
    }

#ifdef FN
#ifdef TRACE
    Assert(fFirstOffset == 0, 609);
#endif
    // 12/10/94 count footnotes (which looked like widgets above)
    for (PPhrase phr = PPhrase(fPtrToArray) + fSize - 1; phr >= PPhrase(fPtrToArray); phr--)
      if (phr->fKind == kNotePhrase)
        charCount++;
#endif

#ifdef AUTONUM
    charCount += (fOffset - AutoNumberOffset(this));   // maybe total up these elsewhere??
#endif

    // 15/03/93 [20707] get the count right for save clipboard as text
    if (fTempFlag && fDocument->fFileType == kTWScrapType)
      charCount--;

    if (increment < 0)
    {
      charCount = -charCount;
      wordCount = -wordCount;
    }
    
    stats->fCharacters += charCount;
    stats->fWords += wordCount;
  }
  return TRUE;
}


// ------------------------------------------------------------------------
int _TTextStructure::FindEditPhrase(bool doDeletions)
{
  PPhrase phr;
  int pos;

  // 28/06/95 add fFirstOffset for safety, (if non-zero hopefully there should be no edit phrases)
  for (phr = PPhrase((char *)fPtrToArray + fFirstOffset), pos = 1; pos <= fSize; phr++, pos++)
    if (phr->fKind == kEditPhrase)
    {
      if (phr->tag.fDeletions == doDeletions)
        return pos;
    }
  return 0;
}

// ------------------------------------------------------------------------
int _TTextStructure::FindInsertionPhrase()
{
  return FindEditPhrase(FALSE);
}


// ------------------------------------------------------------------------
int _TTextStructure::FindDeletionPhrase()
{
  return FindEditPhrase(TRUE);
}


// ------------------------------------------------------------------------
void _TTextStructure::ChangePhraseLen(int pn, int amount)
{
  PPhrase(At(pn))->fNumChars += amount;
}


// ------------------------------------------------------------------------
void _TTextStructure::ChangePhrasePos(int pn, int amount)
{
  // 25/07/90 - rewritten

  TPhrase phrase;

  Get(pn, &phrase);
  phrase.fCharPos += amount;
#ifdef TRACE
  Assert(phrase.fCharPos >= 0, 175);
#endif
  Delete(pn);
  Insert(&phrase);
}


#ifndef SUPER
#if !defined TABLES || defined NETWP
static int gInsertDone;
#endif
// ------------------------------------------------------------------------
void _TTextStructure::DoInsertions(PPhrase phr, TCharPos cp, int amount,
                        bool includeEdits, TCharPos endDel)
{
  TCharPos endPos;
  bool extendMacros = includeEdits >> 1;   // 23/09/92 split 2 bools passed as one

  includeEdits &= 1;                       // 23/09/92
  if (phr->fKind == kEditPhrase && !includeEdits) 
    return;
  endPos = phr->fCharPos + phr->fNumChars;

#if !defined TABLES || defined NETWP
  // 30/09/94 [22030] extend phrase if pointing to an empty text phrase
  if (cp == phr->fCharPos)
  {
    if (phr->fCharPos == 0 && phr->fKind == kTextPhrase && gInsertDone == 0)
      phr->fNumChars += amount;
    else
      phr->fCharPos += amount;
    gInsertDone = 1;
  }
  else if (cp < phr->fCharPos)
#else
  if (cp <= phr->fCharPos)
#endif
    phr->fCharPos += amount;
  else if (cp < endPos)
    phr->fNumChars += amount;
  else if (cp == endPos && endPos != endDel && phr->fKind != kWidgetPhrase
#ifdef INDEX
                                           && phr->fKind != kIndexRefPhrase
#endif
     )
  {
    bool macroOrNote = FALSE;

    if ((phr->fKind == kMacroPhrase
#ifdef FN
               || phr->fKind == kNotePhrase
#endif
           ) && (macroOrNote = TRUE, extendMacros))
      phr->fNumChars += amount;
    else if (!macroOrNote)
    {
#ifdef MATHS
        // && !fDocument->IsMathSymbol(phr->tag.txt.fStyle)   // 8/4/92
        // && !fDocument->IsMathSymbol(phr->tag.txt.fChanges) // 24/9/92
      if (!fDocument->FontIsSymbol(phr->tag.txt.fStyle) &&
          !fDocument->FontIsSymbol(phr->tag.txt.fChanges))
#endif
      phr->fNumChars += amount;
    }
  }
}
#else
 /* #ifdef SUPER */
// ------------------------------------------------------------------------
void _TTextStructure::DoInsertions(PPhrase phr, TCharPos cp, int amount,
                 bool includeEdits, TCharPos endDel, PPhrase &last1, PPhrase &del1)
{
  TCharPos endPos;
  bool extendMacros = includeEdits >> 1;   // 23/09/92 split 2 bools passed as one

  includeEdits &= 1;                       // 23/09/92
  if (phr->fKind == kEditPhrase && !includeEdits) 
    return;
  endPos = phr->fCharPos + phr->fNumChars;
  if (cp < phr->fCharPos)
    phr->fCharPos += amount;
  else if (cp == phr->fCharPos)
  {
    if (phr->fNumChars == 0)
    {
      TCharPos endPos1 = (last1 == NULL ? -1 : last1->fCharPos + last1->fNumChars - amount);
      if (phr->tag.txt.fStyle == 0)
        del1 = phr;
      else
        phr->fNumChars += amount;
      if (endPos1 == cp)
        last1->fNumChars -= amount;
    }
    else
      phr->fCharPos += amount;
  }
  else if (cp < endPos)
    phr->fNumChars += amount;
  else if (cp == endPos && endPos != endDel && phr->fKind != kWidgetPhrase)
              // 17/09/90 & 10/05/91 & 24/9/92 rewritten tests
  {
    if (extendMacros && (phr->fKind == kMacroPhrase
#ifdef FN
      || phr->fKind == kNotePhrase
#endif
      ))
      phr->fNumChars += amount;
    else if (phr->fKind != kMacroPhrase
#if defined MATHS || defined FN
        && phr->fKind != kNotePhrase
    // fn1 added test for notePhrase
#ifndef TRACE
#ifdef MATHS
        && !fDocument->IsMathSymbol(phr->tag.txt.fStyle)   // 8/4/92
        && !fDocument->IsMathSymbol(phr->tag.txt.fChanges) // 24/9/92
#endif
#endif
#endif
      )
      phr->fNumChars += amount;
  }
  last1 = phr;
}
#endif

// ------------------------------------------------------------------------
void _TTextStructure::DoDeletions(PPhrase  phr, TCharPos cp, int amount,
                        bool includeEdits)
{
  TCharPos endPos;

  if (phr->fKind == kEditPhrase && !includeEdits) 
    return;

  endPos = phr->fCharPos + phr->fNumChars;
  if (cp <= phr->fCharPos)
    phr->fCharPos += amount;
  else if (cp <= endPos)        // 19/03/91 for big caret
    phr->fNumChars += amount;
}


// ------------------------------------------------------------------------
void _TTextStructure::RealUpdatePhrases(TCharPos cp, int amount, bool includeEdits)
{
  if (amount > 0)
  {
    // 10/05/91 FindEditPhrase new, and new last parameter
    // int ins;
    int del;
    PPhrase thePhrase;
#ifdef SUPER
    PPhrase del1 = NULL;
    PPhrase last1 = NULL;
#endif

    del = FindDeletionPhrase();
#if !defined TABLES || defined NETWP
    gInsertDone = FALSE;    // 25/10/94 [22030] only let the first text phrase be extended
#endif
    Each(this, (DoToItem)_TTextStructure::DoInsertions, cp, amount,
          includeEdits,
          del > 0 ? (thePhrase = PPhrase(At(del)),
                      thePhrase->fCharPos + thePhrase->fNumChars) : -1
#ifdef SUPER
          , &last1, &del1
#endif
         );
#ifdef SUPER
    if (del1 != NULL)
      Delete(FindPhraseGen(del1->fCharPos, del1->fKind));
#endif
  }
  else if (amount < 0)
    Each(this, (DoToItem)_TTextStructure::DoDeletions, cp, amount, includeEdits & 1);
                                                 // 23/09/92 split 2 bools passed as one
}


// ------------------------------------------------------------------------
void _TTextStructure::DeleteEmptyPhrases(bool deleteType)
{
  PPhrase p;
  int n;

  for (n = GetSize(); n >= 1; n--)
  {
    p = PPhrase(At(n));
    if (p->fNumChars == 0
#if !defined TABLES || defined NETWP
        && p->fKind != deleteType    // [22030]
#endif
#ifdef SUPER
        || p->tag.txt.fStyle == 0
#endif
        )
      Delete(n);
  }
}


// ------------------------------------------------------------------------
void _TTextStructure::JoinPhrases()
{
  int pn;
  int pnL = 0; // 26/04/90 value set for safety
  TPhrase phraseL, phraseR;
  TPhrase phrase;

  pn = 1;
  while (pn <= GetSize())
  {
    Get(pn, &phraseL);
    pnL = pn;
    pn ++;
    if (phraseL.fKind == kTextPhrase)
      break;
  }

  while (pn <= GetSize())
  {
    Get(pn, &phraseR);
    if (phraseR.fKind == kTextPhrase)
    {
      // 16/06/91 whole lot of changes
      if (phraseL.fCharPos + phraseL.fNumChars >= phraseR.fCharPos)
      {
        if (phraseL.tag.txt.fStyle == phraseR.tag.txt.fStyle &&
          phraseL.tag.txt.fChanges == phraseR.tag.txt.fChanges)
        {
          Delete(pn);  // 25/06/96 [22030] moved up to avoid AtPut trace checks causing problems
          if (phraseL.fCharPos + phraseL.fNumChars == phraseR.fCharPos)
          {
            phraseL.fNumChars += phraseR.fNumChars;
            AtPut(pnL, &phraseL);
          }
#ifdef TRACE
          else if (phraseL.fCharPos + phraseL.fNumChars < phraseR.fCharPos + phraseR.fNumChars)
            SysBeep(0);    // sounds like something amiss if they overlap?
#endif
          // Delete(pn);
          continue;
        }
        else
        {
          phrase = phraseL;
          phraseL.fNumChars = phraseR.fCharPos - phraseL.fCharPos;
          // messes up <return> at rt. hand end of an emphasis
          //#if !defined TABLES || defined NETWP
          //    if (phraseL.fNumChars == 0)    // 25/06/96 [22030] (more): remove empty phrase
          //      {
          //        Delete(pnL);
          //        pn--;
          //      }
          //      else
          //#endif
          AtPut(pnL, &phraseL);
          phrase.fCharPos = phraseR.fCharPos + phraseR.fNumChars;
          phrase.fNumChars -= (phraseL.fNumChars + phraseR.fNumChars);
          if (phrase.fNumChars > 0)
          {
            // int insertPos = Insert(&phrase);

            // pn++;
#ifdef TRACE
            // Assert(insertPos == pn, 604);    // sounds like something amiss?
                  // 'phrase' has not been inserted where expected so pnL will be wrong below
#endif
            pn = Insert(&phrase);     // 27/08/96 [27050] - can hit assertion above
            phraseL = phrase;
          }
          else
            phraseL = phraseR;
          pnL = pn;
        }
      }
      else
      {
        phraseL = phraseR;
        pnL = pn;
      }
    }
    pn++;
  }
}


// ------------------------------------------------------------------------
void _TTextStructure::ReplaceMacroText(TCharPos cp, char *macroText)
// 17/09/90 new
{
  TPhrase phrase;
  int pn, n, lenMacroText;
  // 11/10/94 int ins, del;
  TTextStructure structToUpdate;
  int phraseType;

  SetTextGlobals(this);    // waste of time - 'this' is always gMainStruct!
  pn = GetPhraseAt(cp, phrase, kMacroPhrase);  // 27/09/90 extra param
  if (pn > 0 && cp == phrase.fCharPos)
               // 23/08/95 [26020] to get us out of a hole, as a result of redrawing a h/f
               // which has not yet been reformatted (this is done in Idle except for the
               // one which is being typed into!) Can result from resizing h/f, causing
               // invalidate, then typing a few extra keys before the redraw comes through.
  {
#ifdef TRACE
    Assert(/* pn > 0 && */ phrase.fKind == kMacroPhrase, 85);
#endif
    phraseType = phrase.tag.macro.fMacroType;
    if (phraseType == kNewDate || phraseType == kNewTime)
    {
      // -- Why not use At()->..fMacroType = kTime/Date??
      PPhrase(At(pn))->tag.macro.fMacroType = phraseType - 1;
      // Get(pn, &phrase);           // 25/04/91
      // phrase.tag.macro.fMacroType = (phraseType == kNewTime ? kTime : kDate);
      // AtPut(pn, &phrase);
    }
    if (cp + phrase.fNumChars > gDelPos)
      cp += gDelCount;

    lenMacroText = strlen(macroText);
    n = lenMacroText - phrase.fNumChars;
    if (gLinkStruct == NULL || cp < fCount)
      structToUpdate = this;
    else   // must be after a deletion, cannot be part of a deletion
    {
      structToUpdate = gLinkStruct;
      cp -= fCount;
    }
    Munger(&structToUpdate->fPtrToArray, cp + structToUpdate->fOffset, NULL, phrase.fNumChars,
                      macroText, lenMacroText);

    FailMemError();
    structToUpdate->fCount += n;

    if (n != 0)
    {
      structToUpdate->UpdatePhrases(cp + 1, n, TRUE, TRUE);  // 11/10/94 [23007]
      // 11/10/94 test below invalid as cp has already been normalised to structToUpdate!
      // if (gLinkStruct == NULL || cp < fCount)
      //   UpdatePhrases(cp + 1, n, TRUE, TRUE); // 23/09/92 extra param
      // else
      //   gLinkStruct->UpdatePhrases(cp + 1 - fCount, n, TRUE, TRUE); // 23/09/92 extra param
      gExtraInsert += n;   // [26020] See CursorReformat
    }
    SetTextGlobals(this);  // 22/03/91 in case deletions phrase moved, then why not in clause?
  }
}


// ------------------------------------------------------------------------
void _TTextStructure::GetMacroText(TCharPos cp, char *macroText)
// 17/09/90 new
{
  TPhrase phrase;
  int nc, phrasePos;
  TTextStructure structToUpdate;

  SetTextGlobals(this);
  phrase.fCharPos = -1; // 23/08/95 [26020] ensure test below consistent (when no assertion)
  phrasePos = GetPhraseAt(cp, phrase, kMacroPhrase); // 27/09/90 extra param
#ifdef TRACE
  Assert(phrasePos > 0 && phrase.fKind == kMacroPhrase, 183);
#endif
  if (phrase.fCharPos != cp)      // 03/02/92 macro has wrapped so cp is pointing to remainder
    *macroText = 0;    // set empty string
  else
  {
    nc = phrase.fNumChars;
    if (cp + nc > gDelPos)
      cp += gDelCount;
    if (gLinkStruct == NULL || cp < fCount)
      structToUpdate = this;
    else   // must be after a deletion, cannot be part of a deletion
    {
      structToUpdate = gLinkStruct;
      cp -= fCount;
    }
    ((char *)memcpy(macroText, TextStart(structToUpdate) + cp, nc))[nc] = 0;
  }
}


// ------------------------------------------------------------------------
char *_TTextStructure::GetBuffer(TCharPos charPos, Size numChars, int eol, Handle &handle,
                                                                int *bufferSize)
{
  char *GetBuffer_r;
  bool needBuffer = TRUE;
  int delta = 1;
  int maxAvail;
  int slice;
  char *slicePtr;   // only used in first path when slice non-zero
  TTextCaps chCase = (eol == kLineBreakMixed ? kMixedCase : gStyle.fcTextCaps);
  TCharPos endChar = (numChars == MAXLONGINT ? numChars : numChars + charPos);

  if (eol == kNormalHyphen || eol == kModifiedHyphen)
    delta -= eol;                      // 2 (or 3 for modified)
  else if (chCase == kMixedCase)
    needBuffer = FALSE;

  maxAvail = (gLinkStruct == NULL ? fCount : gLinkStruct->fCount + fCount);
  GetBuffer_r = (gLinkStruct == NULL ? TextStart(this) : TextStart(gLinkStruct) - fCount);

  if (charPos < gDelPos && endChar > gDelPos)
  {
    // straddles deletion: need join two parts on either side
    needBuffer = TRUE;
    slicePtr = TextStart(this) + charPos;  // start slice must be in original struct
    slice = gDelPos - charPos;             // length from charPos to start deletion
    // GetBuffer_r points to second slice (length: numChars - slice)
    GetBuffer_r += gDelPos + gDelCount;
    maxAvail -= gDelCount;
  }
  else
  {
    // completely before deletion; or completely after - in original structure or link
    if (endChar <= gDelPos)
      GetBuffer_r = TextStart(this);   // completely before, must be in original struct
    else
      charPos = Min(maxAvail - 1, charPos + gDelCount);
                      // increment by delCount, but ensure at least last char available
    slicePtr = NULL;
    slice = 0;        // only one slice copied below
    GetBuffer_r += charPos;
  }

  maxAvail -= charPos;
  // 17/06/95 [26019] as well as MAXLONGINT, numChars may be off end (eg FindWordWrap)
  if (numChars > maxAvail)
    numChars = maxAvail;
  numChars += delta;
  if (needBuffer)
  {
    char *hyphenPtr;
    char *buffer;

    buffer = (char *)NewCheckedHandle(numChars);
    if (slice != 0)
      buffer = (char *)memcpy(buffer, slicePtr, slice);
    memcpy(buffer + slice, GetBuffer_r, numChars - slice);
    hyphenPtr = buffer + numChars - delta;
    if (eol == kNormalHyphen)
      *(hyphenPtr++) = '-';
    else if (eol == kModifiedHyphen)
    {
      // 20/10/94 [23010] German hyphenation
      if (*hyphenPtr == 'k' && *(hyphenPtr - 1) == 'c')        // 20/10/94 ck to k-k
      {
        *(hyphenPtr - 1) = 'k';
        numChars--;                  // really only 1 extra char stored
      }
      else
        hyphenPtr++;                                        // 20/10/94 xx to xx-x
      *(hyphenPtr++) = '-';
    }
    *hyphenPtr = 0;
    StringConvertCase(buffer, numChars, chCase);
    GetBuffer_r = buffer;
    handle = buffer;
  }
  else
    handle = NULL;    // now return NULL in handle parameter if nothing to be freed
                   // and GetBuffer_r is already set to the text in the fPtrToArray

  if (bufferSize)
    *bufferSize = numChars - 1;
  return GetBuffer_r;
}


// ------------------------------------------------------------------------
void _TTextStructure::MoveCursor(TCharPos &cp, int amount)
{
  TPhrase phrase;

  cp += amount;
  // fn1 added test for notePhrase
  if ((GetPhraseAt(cp, phrase, kMacroPhrase) > 0
#ifdef FN
       || GetPhraseAt(cp, phrase, kNotePhrase) > 0
#endif
        ) && cp != phrase.fCharPos)
  {
    cp = phrase.fCharPos;
    if (amount > 0)
      cp += phrase.fNumChars;
  }
}


// ------------------------------------------------------------------------
int _TTextStructure::GetChar(TCharPos cp)
{
  TTextStructure structure;

  if (cp >= gDelPos)
    cp += gDelCount;

  if (cp - fCount >= 0)
  {
    cp -= fCount;
    structure = gLinkStruct;
    // 30/01/95 replace Assertion: the cursor char pos during MailMerge preview is
    // not updated so can pass an off-end value from DoSetUpMenus
    if (structure == NULL)
    {
#ifdef TRACE
      SysBeep(0);      // something (else) wrong if not called from DoSetUpMenus
#endif
      return chReturn;
    }
  }
  else
    structure = this;
#if SIDEBAR == 1
  int ch = *(TextStart(structure) + cp);
  return (ch == 0 ? 0x100 : ch);
#else
  return *(TextStart(structure) + cp);
#endif
}


// ------------------------------------------------------------------------
int _TTextStructure::FindPhraseGen(TCharPos cp, TPhraseKind kind)
{
  static TPhrase testPhrase;

  testPhrase.fCharPos = cp;
  testPhrase.fKind = kind;
  testPhrase.fNumChars = 1;      // 24/10/94 since fNumChars tested in Search
  return Search(&testPhrase);
// 02/04/92  return(Search(this, (TestPtr)_TTextStructure::DoFindPhrase, cp, kind));
}

// ------------------------------------------------------------------------
int _TTextStructure::FindPhrase(TCharPos cp) // 02/04/92 , TPhraseKind kind)
{
  return FindPhraseGen(cp, kWidgetPhrase);
}


// ------------------------------------------------------------------------
bool _TTextStructure::NearestToCP(PPhrase phr, TCharPos charPos, int offset)
{
#ifdef INDEX
  if (phr->fKind == kIndexRefPhrase)
    return FALSE;
#endif
  // 17/09/92 test gDelPos set
  if (gDelPos >= 0 && (phr->fCharPos + offset >= gDelPos) &&
                           (phr->fCharPos + offset + phr->fNumChars <= gDelPos + gDelCount))
    return FALSE;

  if ((phr->fCharPos + offset <= charPos) &&
         (phr->fCharPos + offset + phr->fNumChars > charPos) && (phr->fKind != kEditPhrase))
    return TRUE;

  return (phr->fCharPos + offset > charPos && phr->fKind != kEditPhrase);
}


// ------------------------------------------------------------------------
bool _TTextStructure::ContainsCP(PPhrase phr, TCharPos charPos, int offset,
              TPhraseKind kind)
// 27/09/90 new routine so macros are definitely picked up
{
#ifdef INDEX
  if (phr->fKind == kIndexRefPhrase && kind != kIndexRefPhrase)
    return FALSE;
#endif
  // 17/09/92 test gDelPos set
  if (gDelPos >= 0 && phr->fCharPos + offset >= gDelPos &&
      phr->fCharPos + offset + phr->fNumChars <= gDelPos + gDelCount)
    return FALSE;

  return ((phr->fCharPos + offset <= charPos &&
          phr->fCharPos + offset + phr->fNumChars > charPos &&
          ((kind != kTextPhrase && kind == phr->fKind) ||
          (kind == kAnyTextPhrase && phr->fKind == kTextPhrase))) || // 23/09/92 any text phr
          (phr->fCharPos + offset < charPos &&
          phr->fCharPos + offset + phr->fNumChars >= charPos &&
          kind == kTextPhrase && kind == phr->fKind));
                   // 20/06/91 new || and kind vs kTextPhrase test
}


// ------------------------------------------------------------------------
int _TTextStructure::GetPhraseAt(TCharPos cp, TPhrase &phrase, TPhraseKind kind)
{
  // 03/05/90 - most of this routine changed to == mac vsn
  TTextStructure textStruct;
  TCharPos charPos;
  int pn;
  int index;
//  bool found;
  int offset;
  TestItem procToCall = (kind == kAnyPhrase ?
             (TestItem)_TTextStructure::NearestToCP :
             (TestItem)_TTextStructure::ContainsCP);  // 27/09/90

//  found = FALSE;
  textStruct = gMainStruct;
  charPos = cp;
  index = 0;
  offset = 0;
  if (charPos >= gDelPos)
    charPos += gDelCount;  // 29/05/90

  while (TRUE)      // (!found)
  {
    pn = textStruct->FirstThat(this, procToCall, charPos, offset, kind);
    if (pn > 0)
    {
      return GetPhrase(index + pn, phrase);       // index =
      //found = TRUE;
    }
    // else if (offset == 0 && gLinkStruct != NULL)
    if (offset != 0 || gLinkStruct == NULL)
      return 0;
    // {
      textStruct = gLinkStruct;
      offset = fCount;
      index = GetSize();
    // }
    // else
    // {
    //   found = TRUE;
    //   index = 0;
    // }
  }

//  return(index);
}

#ifdef SUPER
// ------------------------------------------------------------------------
int _TTextStructure::GetPhrase1(int index, TPhrase &phrase, int direction)
{
  TTextStructure textStruct;
  TCharPos delEnd;
  int phraseNum;
  bool found;

  found = FALSE;
  while (!found)
  {
    if (index > 0 && index <= GetSize())
    {
      textStruct = gMainStruct;
      phraseNum = index;
    }
    else if (index > 0 && gLinkStruct != 0 && index <= (GetSize() + gLinkStruct->GetSize()))
    {
      textStruct = gLinkStruct;
      phraseNum = index - GetSize();
    }
    else
    {
      index = direction;
      break; // out of while loop...
    }

    textStruct->Get(phraseNum, &phrase);
    index += direction;

    if (phrase.fKind != kEditPhrase)
    {
      if (textStruct == gLinkStruct)
        phrase.fCharPos += gMainStruct->fCount;   // 17/09/90 gMain for text
      if (gDelCount > 0)
      {
        delEnd = gDelPos + gDelCount;
        if ((phrase.fCharPos >= gDelPos) && (phrase.fCharPos < delEnd))
        {
          phrase.fNumChars = Max(0, phrase.fNumChars - (delEnd - phrase.fCharPos));
          if (phrase.fCharPos > gDelPos)
            phrase.fCharPos = gDelPos;  // 25/07/90
        }
        else if ((phrase.fCharPos < gDelPos) && (phrase.fCharPos + phrase.fNumChars > gDelPos))
          phrase.fNumChars -= Min(gDelCount, phrase.fCharPos + phrase.fNumChars - gDelPos);
        else if (phrase.fCharPos >= delEnd)
          phrase.fCharPos -= gDelCount;
        found = phrase.fNumChars > 0;
      }
      else
        found = TRUE;
    }
  }
  return(index - direction);
}

// ------------------------------------------------------------------------
int _TTextStructure::GetPhrase(int index, TPhrase &phrase)
{
  return GetPhrase1(index, phrase, 1);
}

#else
// ------------------------------------------------------------------------
int _TTextStructure::GetPhrase(int index, TPhrase &phrase)
{
  TTextStructure textStruct;
  TCharPos delEnd;
  int phraseNum;
  bool found;

  found = FALSE;
  while (!found)
  {
    if (index <= GetSize())
    {
      textStruct = gMainStruct;
      phraseNum = index;
    }
    else if ((gLinkStruct != 0) && (index <= (GetSize() + gLinkStruct->GetSize())))
    {
      textStruct = gLinkStruct;
      phraseNum = index - GetSize();
    }
    else
    {
      index = 1;
      break; // out of while loop...
    }

    textStruct->Get(phraseNum, &phrase);
    index++;

    if (phrase.fKind != kEditPhrase)
    {
      if (textStruct == gLinkStruct)
        phrase.fCharPos += gMainStruct->fCount;   // 17/09/90 gMain for text
      if (gDelCount > 0)
      {
        delEnd = gDelPos + gDelCount;
        if ((phrase.fCharPos >= gDelPos) && (phrase.fCharPos < delEnd))
        {
          phrase.fNumChars = Max(0, phrase.fNumChars - (delEnd - phrase.fCharPos));
          if (phrase.fCharPos > gDelPos)
            phrase.fCharPos = gDelPos;  // 25/07/90
        }
        else if ((phrase.fCharPos < gDelPos) && (phrase.fCharPos + phrase.fNumChars > gDelPos))
          phrase.fNumChars -= Min(gDelCount, phrase.fCharPos + phrase.fNumChars - gDelPos);
        else if (phrase.fCharPos >= delEnd)
          phrase.fCharPos -= gDelCount;
#if !defined TABLES || defined NETWP
        found = (phrase.fNumChars > 0);
#endif
      }
#if !defined TABLES || defined NETWP
      else
        found = TRUE;    // 30/09/94 [22030] return empty phrase as found
#else
      found = (phrase.fNumChars > 0);
#endif
    }
  }
  return(index - 1);
}
#endif

// ------------------------------------------------------------------------
void _TTextStructure::SelectPart(TCursorNode anchor, TCursorNode activeEnd,
                    int part, Rect &custom)
{
  TTextEdge edge;
  TPhrase phrase;

  SetTextGlobals(this);       // 05/04/91
  if (anchor != NULL)
  {
    if (part == 2)
    {
      TTextCursor(anchor)->GetEdge(edge);
      CP2Phrase(edge.fCharPos, TRUE, phrase);
    }
    else
      phrase.fCharPos = 0;

    edge.fCharPos = phrase.fCharPos;
    edge.fPixelPos = 0;
    edge.fPartNum = 1;

    TTextCursor(anchor)->SetEdge(edge);
//    TTextCursor(anchor)->SetRightEdge(edge);
  }

  if (activeEnd != NULL)
  {
    if (part == 2)
      phrase.fCharPos += phrase.fNumChars;
    else
    {
      phrase.fCharPos = fCount /* - 1 24/01/91 */;
      if (gLinkStruct != NULL)
        phrase.fCharPos += gLinkStruct->fCount;         // 05/04/91
      phrase.fCharPos -= gDelCount;                    // 05/04/91
    }

    edge.fCharPos = phrase.fCharPos;
    edge.fPixelPos = MAXLONGINT;     // 10/02/94 from MAXINT
    edge.fPartNum = MAXINT;

    TTextCursor(activeEnd)->SetEdge(edge);
//    TTextCursor(activeEnd)->SetRightEdge(edge);
  }
}


// ------------------------------------------------------------------------
void _TTextStructure::ResetCursor(TCursorNode cursor, long insertionPos,
                       bool fromRight, bool keep)
{
  int pn;

  cursor->Collapse();
  SetTextGlobals(this);

  // 25/09/92 do not find widget in the deletions phrase
  if (insertionPos - fromRight < gDelPos || insertionPos - fromRight >= gDelPos + gDelCount)
    pn = FindPhrase(insertionPos - fromRight);
  else
    pn = 0;
      // 25/09/92 do not find phrase after a deletions phrase with insertionPos before it

  if (insertionPos > gDelPos)
    insertionPos -= gDelCount;       // 05/02/91 for paste into selection

  TTextCursor(cursor)->fEdge.fPartNum = 0;
  if (pn > 0)
  {
    TCurrency currency = PPhrase(At(pn))->tag.fRecNum;
    GetStructureReadOnly(currency)->ExtendCursor(cursor, currency, fromRight, TRUE, keep);
    insertionPos -= fromRight;
  }
  TTextCursor(cursor)->SetCharPos(insertionPos);
}


// ------------------------------------------------------------------------
void _TTextStructure::ExtendCursor(TCursorNode cursorNode,
               TCurrency currency, bool fromRight, bool toBottom, bool keep)
{
  TTextCursor newNode;
  TCursor cursor;
  TTextEdge edge;

  if (fromRight)
  {
    SetTextGlobals(this);
    edge.fCharPos = fCount +
              (gLinkStruct == NULL ? 0 : gLinkStruct->fCount) - gDelCount; // 05/04/91 - delcount
    if (fromRight == 2)
      edge.fCharPos--;       // [22027] to avoid saving CR in save footnote refs as text
                             // ... and 'Select all' paragraphs for NCWriter
    edge.fPixelPos = MAXLONGINT;     // 10/02/94 from MAXINT
    edge.fPartNum = MAXINT;
  }
  else
  {
    edge.fCharPos = 0;
    edge.fPixelPos = -1;     // 10/02/94 for resetting mousePt: 0;
    edge.fPartNum = 0;       // 02/11/90 from 1 for arrow keys
  }

  newNode = new _TTextCursor(currency, kNewCursor, edge, FALSE, gZeroVPt);
  cursor = cursorNode->fCursor;
  cursor->AddTarget(newNode);
}


// ------------------------------------------------------------------------
TCursorNode _TTextStructure::NewCursorNode()
{
  TTextEdge   edge;

  edge.fCharPos = 0;
  edge.fPixelPos = -1;     // 10/02/94 for resetting mousePt: 0;
  edge.fPartNum = 0;
  return new _TTextCursor(gNullCurrency, kNoIdentifier, edge, FALSE, gZeroVPt);
}


// ------------------------------------------------------------------------
bool _TTextStructure::LinkStructure(TCursorNode anchor, TCursorNode activeEnd, bool cmdDone)
// 09/02/93, bool &link)
{
  TCharPos cp;
  int delPhrase;    // insPhrase,
  TCurrency currency;
  bool link = FALSE;

  currency = (activeEnd == NULL ? 0 : activeEnd->fCurrency);

  if (fLinkStruct == 0)
  {
    if (currency != 0 && CanJoin(currency) && !fTempFlag)
    {
      link = TRUE;
      fDocument->LockCurrency(anchor->fCurrency, TRUE);    // 12/03/91
      fDocument->LockCurrency(currency, TRUE);
      fLinkStruct = currency;
      TTextStructure(GetStructureReadOnly(currency))->
                       UpdateWidgetParents(gNullCurrency, anchor->fCurrency);  // 14/05/91
      delPhrase = FindDeletionPhrase();
      if (delPhrase == 0)
      {
        NewEditPhrase(fCount - 1, 1, TRUE);
        if (TTextCursor(anchor)->GetCharPos() == fCount)
          TTextCursor(anchor)->ChangeCharPos(-1);
      }
      else
      {
        register PPhrase cgf_58 = PPhrase(At(delPhrase));
        if (cgf_58->fCharPos + cgf_58->fNumChars < fCount)
          cgf_58->fNumChars ++;
      }
    }
    else
      fLinkStruct = -1;
  }
  else if (fLinkStruct != -1)
  {
    // 24/01/91 extra tests and cursorNode to anchor
    if ((fLinkStruct >> 16) == -2)
    //if (fLinkStruct.cgf_31.fRecnum == 0xfffe)       // 23/10/91 -2 does not work
      link = FALSE;
    else if ((fLinkStruct >> 16) == -1)
    // else if (fLinkStruct.cgf_31.fRecnum == 0xffff)  // 23/10/91 -1 does not work
      link = !cmdDone;
    else
    {
      TTextStructure(GetStructureReadOnly(fLinkStruct))->
                     UpdateWidgetParents(gNullCurrency, fLinkStruct);  // 14/05/91      
      fLinkStruct = 0;
      cp = TTextCursor(anchor)->GetCharPos();
      if (cp == fCount)
        TTextCursor(anchor)->ChangeCharPos(-1);
      else
      {
        delPhrase = FindDeletionPhrase();
        if (delPhrase > 0)
        {
          register PPhrase phrase = PPhrase(At(delPhrase));

          if (phrase->fCharPos + phrase->fNumChars == fCount)
            phrase->fNumChars--;
        }
      }
    }
  }
  else
    fLinkStruct = 0;

  return link;
}


// ------------------------------------------------------------------------
bool _TTextStructure::SwapNodes(TCursorNode anchor, TCursorNode activeEnd)
{ // 29/4/92 rewritten to handle widgets properly
  TCharPos cp1 = TTextCursor(anchor)->GetCharPos();
  TCharPos cp2 = TTextCursor(activeEnd)->GetCharPos();

  if (cp1 == cp2)
// 26/05/92   return (anchor->GetNext() != NULL && activeEnd->GetNext() == NULL);
    return (!anchor->IsLast() && activeEnd->IsLast());
  return(cp1 > cp2);
}


// ------------------------------------------------------------------------
static bool IsAllSelected(Rect &custom, long count, CmdNumber cmd)
{
  // 08/03/94 [21448] Tab commands do nothing (except crash on Undo) if you drag
  // over over a whole paragraph, rather than select it by treble click or Select menu.
  // This forces the former case not to be treated as AllSelected
#ifdef NETWP
  return FALSE;
#else
  if (cmd >= cTabMove && cmd <= cMultiTabMove)
    count++;

  return (((TEmphasis *)&custom)->tag.fStartPos == 0 &&
            ((TEmphasis *)&custom)->tag.fEndPos >= count - 1);
#endif
}

// ------------------------------------------------------------------------
#ifdef MATHS
void _TTextStructure::MakePhrase(TPhrase &newPhrase, TCharPos startPos, TCharPos endPos,
      TPhraseStyle styleKind, TMakePhraseData &pars, bool testCancelMathSymbol)
{
  pars.testCancelMathSymbol = testCancelMathSymbol;
  DoMakePhrase(newPhrase, startPos, endPos, styleKind, pars);
}
#else
#define MakePhrase(a, b, c, d, e, f) DoMakePhrase(a, b, c, d, e)
// i.e. ignore the last parameter which is only for maths
#endif

// ------------------------------------------------------------------------
void _TTextStructure::DoMakePhrase(TPhrase &newPhrase, TCharPos startPos,
            TCharPos endPos, TPhraseStyle styleKind, TMakePhraseData &pars)
{
  newPhrase.fCharPos = startPos;
  newPhrase.fNumChars = endPos - startPos;
  newPhrase.tag.txt.fUndoStyle = 0;
  newPhrase.tag.txt.fUndoChanges = 0;
  newPhrase.fKind = kTextPhrase;
  // 05/05/93 common up pars.cancel part of kLocalChanges and kLocalMerged
  if (styleKind == kLocalCurrent)
  {
    newPhrase.tag.txt.fStyle = pars.phrase.tag.txt.fStyle;
    newPhrase.tag.txt.fChanges = pars.phrase.tag.txt.fChanges;
  }
  else
  {
    // styleKind kLocalChanges or kLocalMerged:
    if (pars.cancel)
    {
#ifdef MATHS
      // 8/4/92 when Plain applied to a symbol it removes the italic, but leaves it as Symbol
      if (pars.testCancelMathSymbol && (fDocument->FontIsSymbol(pars.phrase.tag.txt.fStyle)
               || fDocument->FontIsSymbol(pars.phrase.tag.txt.fChanges)))
            // 25/01/94 fDocument->IsMathSymbol(pars.phrase.tag.txt.fStyle))
      {
        newPhrase.tag.txt.fStyle = Curr_fRecnum(fDocument->fSymbolsStyle);
            // 25/01/94 fDocument->MakePlainStyle(pars.phrase.tag.txt.fStyle);
        newPhrase.tag.txt.fChanges = 0;
      }
      else
#endif
      {
#ifdef SUPER
        newPhrase.tag.txt.fStyle = 0;
        newPhrase.tag.txt.fChanges = 0;
#else
        newPhrase.fCharPos = -1;
#endif
      }
    }
    else
    {
      int namedStyle;
      int pars_fStyle;
      TCurrency emphasis = 0;
      TStyleFormat styleFormat = NULL;

      if (styleKind == kLocalChanges)
      {
        // 28/01/94 [21369] FindStyle returns 1 if it finds a named style
        namedStyle = pars.view->FindStyle(pars.theChanges, kTextStyleStruct, emphasis);

        pars_fStyle = 0;
        if (emphasis == 0)  // not found at all
          styleFormat = TStyleFormat(pars.theChanges->Clone());
      }
      else
      {
        TStyleFormat styleChanges;
   
        if (pars.phrase.tag.txt.fChanges > 0)
        {
          styleChanges =
                   pars.view->GetStyleReadOnly(RecToCurrency(pars.phrase.tag.txt.fChanges));
          
          styleChanges = TStyleFormat(styleChanges->Clone());
          if (styleChanges->fTimeStamp == pars.theChanges->fTimeStamp)
          {
            // new block to fix bug in delete changes for emphasis styles
            FreeIfObject(styleChanges);
            if (pars.theChanges->fDefined == kEmphasis)
            {
              // 22/06/93 [20950] common up code with case below
              // newPhrase.tag.txt.fChanges = 0;
              // newPhrase.tag.txt.fStyle = pars.phrase.tag.txt.fStyle;
              // if (fDocument->fEmphasisStyle.cgf_31.fRecnum == pars.phrase.tag.txt.fStyle)
              //  newPhrase.fCharPos = -1;
              // return;
              goto SetRemovePhrase;
            }
            styleChanges = TStyleFormat(pars.theChanges->Clone());            
          }
          else if (!styleChanges->MergeEmphasisAttrs(pars.theChanges, TRUE))
          {
            // 22/06/93 [20950] need to test for fDocument->fEmphasisStyle ??
            // newPhrase.tag.txt.fChanges = 0;
            // newPhrase.tag.txt.fStyle = pars.phrase.tag.txt.fStyle;
            // if (newPhrase.tag.txt.fStyle == 0)
            //   newPhrase.fCharPos = -1;         //  13/11/92 pars.phras WITH problem?
            FreeIfObject(styleChanges);       // 21/09/92 leaving handle?
            goto SetRemovePhrase;
          }
        }
        else
        {
          styleChanges = TStyleFormat(pars.theChanges->Clone());
        }

        if (pars.phrase.tag.txt.fStyle > 0)
        {
          styleFormat = pars.view->GetStyleReadOnly(RecToCurrency(pars.phrase.tag.txt.fStyle));
          styleFormat = TStyleFormat(styleFormat->Clone());
          if (!styleFormat->MergeEmphasisAttrs(styleChanges, TRUE))
          {
            pars.phrase.tag.txt.fChanges = 0;
            pars.phrase.tag.txt.fStyle = 0;
            FreeIfObject(styleChanges);
            newPhrase.fCharPos = -1;
            FreeIfObject(styleFormat);
            return;
          }
        }
        FreeIfObject(styleFormat);
        namedStyle = pars.view->FindStyle(styleChanges, kTextStyleStruct, emphasis);
        // 28/01/94 [21369] FindStyle returns 1 if it finds a named style
        pars_fStyle = pars.phrase.tag.txt.fStyle;
        if (emphasis == 0)  // not found at all
          styleFormat = styleChanges;
        else
          FreeIfObject(styleChanges);                   // 21/09/92 leaving handle
      }
      if (emphasis == 0)
      {
        TDiscObject newObj;

        emphasis = fDocument->NewCurrency(kTextStyleStruct, newObj);
        styleFormat->fTimeStamp = UniqueNumber();            // 18/09/92
        pars.view->SetStyle(emphasis, styleFormat);
      }
      emphasis = Curr_fRecnum(emphasis);
      if (pars_fStyle > 0)
      {
        newPhrase.tag.txt.fStyle = pars_fStyle;
        newPhrase.tag.txt.fChanges = emphasis;
      }
      else if (namedStyle)
      {
        newPhrase.tag.txt.fStyle = emphasis;
        newPhrase.tag.txt.fChanges = 0;
      }
      else
      {
        newPhrase.tag.txt.fStyle = Curr_fRecnum(fDocument->fEmphasisStyle);
        newPhrase.tag.txt.fChanges = emphasis;       // 04/02/91 use default emph style
      }
    }
  }
  return;

SetRemovePhrase:
  newPhrase.tag.txt.fChanges = 0;
  newPhrase.tag.txt.fStyle = pars.phrase.tag.txt.fStyle;
#ifdef TRACE
  Assert(newPhrase.tag.txt.fStyle != 0, 888);   // is zero test necessary??
#endif
  if (newPhrase.tag.txt.fStyle == Curr_fRecnum(fDocument->fEmphasisStyle) ||
                                       newPhrase.tag.txt.fStyle == 0)
    newPhrase.fCharPos = -1;
  return;
}


// ------------------------------------------------------------------------
bool _TTextStructure::Overlaps(PPhrase phrase, int *overlapKind,
                                        TCharPos cStart, TCharPos cEnd)
{
  bool  Overlaps_r = TRUE;
  *overlapKind = 0;

  if (phrase->fKind != kTextPhrase)
    Overlaps_r = FALSE;
  else if (cStart < phrase->fCharPos)
  {
    if (cEnd > phrase->fCharPos + phrase->fNumChars)
      *overlapKind = 4;
    else if (cEnd == phrase->fCharPos + phrase->fNumChars)
      *overlapKind = 3;
    else if (cEnd > phrase->fCharPos)
      *overlapKind = 2;
    else if (cEnd == phrase->fCharPos)
      *overlapKind = 1;
    else
      Overlaps_r = FALSE;
  }
  else if (cStart == phrase->fCharPos)
  {
    if (cEnd > phrase->fCharPos + phrase->fNumChars)
      *overlapKind = 7;
    else if (cEnd == phrase->fCharPos + phrase->fNumChars)
      *overlapKind = 6;
    else
      *overlapKind = 5;
  }
  else if (cStart < phrase->fCharPos + phrase->fNumChars)
  {
    if (cEnd > phrase->fCharPos + phrase->fNumChars)
      *overlapKind = 10;
    else if (cEnd == phrase->fCharPos + phrase->fNumChars)
      *overlapKind = 9;
    else
      *overlapKind = 8;
  }
#ifdef SUPER
  else if (cStart == phrase->fCharPos + phrase->fNumChars && cStart == cEnd)
    *overlapKind = 9;
#endif
  else
    Overlaps_r = FALSE;

  return(Overlaps_r);
}


// ------------------------------------------------------------------------
void _TTextStructure::InstallStyleChange(TCurrency currency, TStyleFormat theChanges,
                                                   int part, Rect &custom, CmdNumber cmd)
{
  int pn;
  TCharPos cStart;
  TCharPos cEnd;
  int ins;
  TPhrase phraseL;
  TPhrase phraseC;
  TPhrase phraseR;
  int overlapKind;
  Attributes defined;
  bool done;
  bool isEmphasis;
  bool allSel;

  ins = FindInsertionPhrase();
  allSel = IsAllSelected(custom, fCount, cmd) && ins == 0;

  if (allSel && cmd != cPlain)
  {
    _TSortedStructure::InstallStyleChange(currency, theChanges, 1, gZeroRect, cmd);
  }
  else
  {
    int doPhrases;
    TMakePhraseData pars;

    pars.theChanges = theChanges;
    pars.cancel = (cmd == cPlain);
    // 26/01/94 [21362] do not apply deferred change to deletions phrase (for palette click
    // with a seln). What "if (cEnd - cStart - (ins > 0) > 0)" means is a mystery, but if
    // it is attempting to recognise deferred changes, it will be wrong for fast typing!
    cStart = ((TEmphasis *)&custom)->tag.fStartPos; // 25/07/90

    if (ins > 0)
    {
      // apply change to character(s) just inserted, more than 1 if typing fast
      Get(ins, &pars.phrase);
      cEnd = pars.phrase.fCharPos + pars.phrase.fNumChars;
          // 26/01/94 this will be different from custom value if typing Cleared a selection
    }
    else
    {
      // apply change to what is in the selection
      pars.phrase.fNumChars = 0;
      cEnd = ((TEmphasis *)&custom)->tag.fEndPos;     // 25/07/90
    }
    if (cEnd != cStart && ins == 0)
                // there is a selection - so do not pass emphasis up to parent if emphasis?
    {
      if ((theChanges->fDefined & emphasisAttrs) != 0)
        theChanges->fDefined |= kEmphasis;
    }
    defined = theChanges->fDefined;
    isEmphasis = (defined & kEmphasis);
    pars.view = fDocument->ActiveMainView();
    if ((!pars.cancel && ((defined & ~emphasisAttrs) || !isEmphasis || defined == 0)) ||
           (allSel && pars.cancel)) 
                 // 22/4/92 test cancel, 21/09/92 deferred cancel of Justification
    {
      long saveStamp = theChanges->fTimeStamp;     // 18/04/91

      fTempFlag = TRUE;
      if (isEmphasis || pars.cancel) // 1/4/92 test cancel
      {
        theChanges->fDefined &= ~emphasisAttrs;
        // 24/09/93 [21044] moved down: theChanges->ReduceSize(0);
      }

      if (fChanges != 0)          // 19/04/91 test before zeroising
      {
        TStyleFormat myChanges = pars.view->GetStyleReadOnly(fChanges);

        if (myChanges->fTimeStamp != theChanges->fTimeStamp ||
                 (isEmphasis && theChanges->NumOfAttrs(kRuler) > 0)) // 02/03/92 new || ...
        {
          theChanges->fTimeStamp = 0;                 // 18/04/91
          // 24/09/93 [21044] moved down - losing tabs when creating an emphasis
          if (isEmphasis || pars.cancel) // 1/4/92 test cancel
            theChanges->ReduceSize(0);       // 27/01/93 [20602] avoid the 1024 tab problem
        }
      }

      _TSortedStructure::InstallStyleChange(currency, theChanges, 1, gZeroRect, cmd);

      theChanges->fTimeStamp = saveStamp;         // 18/04/91
      if (isEmphasis || pars.cancel)
      {
        theChanges->fDefined = (defined & emphasisAttrs);
        // 27/01/93 [20602] done before InstallSC:        theChanges->ReduceSize(0);
        doPhrases = TRUE;
      }
      else
        doPhrases = FALSE;    // 26/04/96 instead of return (and not do new code at end)
    }
    else
      doPhrases = TRUE;
    if (doPhrases)            // 26/04/96 there is more to do
    {
#if !defined TABLES || defined NETWP
      DeleteEmptyPhrases(kAnyPhrase);   // 27/06/96 [22030] more (loops if finds empty case 7)
#endif
      fDocument->LockCurrency(currency, TRUE);       // 12/03/91
#ifdef TRACE
      Assert(fUndoSize == 0 && fUndoOffset < 0 && fFirstOffset == 0, 771); // check commit state
#endif
      // 12/12/90 delay updating fUndoOffset as Insert updates it
      // 28/06/95 [26030] avoid assigning fUndoOffset with orig value of fOffset (for numbered
      // lists fOffset is greater than fSize * sizeof(TPhrase), and probably not even word
      // aligned), also make more resilient to memory failure by duplicating phrases in one go
      int temp = fSize * sizeof(TPhrase);

      InsertSlice(0, NULL, temp);        // fail before resetting fields if not room for all
      fOffset += temp;
      fUndoOffset = temp;
      fUndoSize = fSize;

      while(TRUE)
      {
        done = TRUE;
        overlapKind = 0;
        pn = FirstThat(this, (TestItem)_TTextStructure::Overlaps, &overlapKind, cStart, cEnd);
        if (pn != 0)
        {
          Get(pn, &pars.phrase);
          Delete(pn);
        }
        phraseL.fCharPos = -1;
        phraseR.fCharPos = -1;

        switch (overlapKind)
        {
        case 0:
          // phraseL.fCharPos = -1;
          MakePhrase(phraseC, cStart, cEnd, kLocalChanges, pars, FALSE);
          // phraseR.fCharPos = -1;
          break;

        case 1:
          MakePhrase(phraseL, cStart, pars.phrase.fCharPos, kLocalChanges, pars, FALSE);
          phraseC = pars.phrase;
          // phraseR.fCharPos = -1;
          break;

        case 2:
          MakePhrase(phraseL, cStart, pars.phrase.fCharPos, kLocalChanges, pars, FALSE);
          MakePhrase(phraseC, pars.phrase.fCharPos, cEnd, kLocalMerged, pars, TRUE);
          MakePhrase(phraseR, cEnd, pars.phrase.fCharPos + pars.phrase.fNumChars,
                                                            kLocalCurrent, pars, FALSE);
          break;

        case 3:
          MakePhrase(phraseL, cStart, pars.phrase.fCharPos, kLocalChanges, pars, FALSE);
        case 6:
          MakePhrase(phraseC, pars.phrase.fCharPos, cEnd, kLocalMerged, pars, TRUE);
          // phraseR.fCharPos = -1;
          break;

        case 4:
          MakePhrase(phraseL, cStart, pars.phrase.fCharPos, kLocalChanges, pars, FALSE);
        case 7:
          MakePhrase(phraseC, pars.phrase.fCharPos,
                pars.phrase.fCharPos + pars.phrase.fNumChars, kLocalMerged, pars, TRUE);
          done = FALSE;
          // phraseR.fCharPos = -1;
          // cStart = pars.phrase.fCharPos + pars.phrase.fNumChars;
          break;

        case 5:
          // phraseL.fCharPos = -1;
          MakePhrase(phraseC, pars.phrase.fCharPos, cEnd, kLocalMerged, pars, FALSE);
          MakePhrase(phraseR, cEnd, pars.phrase.fCharPos + pars.phrase.fNumChars,
                                                           kLocalCurrent, pars, TRUE);
          break;

        // case 6:
          // phraseL.fCharPos = -1;
          // MakePhrase(phraseC, pars.phrase.fCharPos, cEnd, kLocalMerged, pars, TRUE);
          // phraseR.fCharPos = -1;
          // break;

        // case 7:
          // done = FALSE;
          // phraseL.fCharPos = -1;
          // MakePhrase(phraseC, pars.phrase.fCharPos,
          //     pars.phrase.fCharPos + pars.phrase.fNumChars, kLocalMerged, pars, TRUE);
          // phraseR.fCharPos = -1;
          // cStart = pars.phrase.fCharPos + pars.phrase.fNumChars;
          // break;

        case 8:
          MakePhrase(phraseL, pars.phrase.fCharPos, cStart, kLocalCurrent, pars, FALSE);
          MakePhrase(phraseC, cStart, cEnd, kLocalMerged, pars, TRUE);
          MakePhrase(phraseR, cEnd, pars.phrase.fCharPos + pars.phrase.fNumChars,
                                                            kLocalCurrent, pars, FALSE);
          break;

        case 9:
          MakePhrase(phraseL, pars.phrase.fCharPos, cStart, kLocalCurrent, pars, FALSE);
          MakePhrase(phraseC, cStart, cEnd, kLocalMerged, pars, TRUE);
          // phraseR.fCharPos = -1;
          break;

        case 10:
          MakePhrase(phraseL, pars.phrase.fCharPos, cStart, kLocalCurrent, pars, FALSE);
          MakePhrase(phraseC, cStart, pars.phrase.fCharPos + pars.phrase.fNumChars,
                                                              kLocalMerged, pars, TRUE);
          done = FALSE;
          // phraseR.fCharPos = -1;
          // cStart = pars.phrase.fCharPos + pars.phrase.fNumChars;
          break;
        }

        // previously local proc AddNewPhrases() on mac...
        if (phraseL.fCharPos >= 0)
          Insert(&phraseL);
        if (phraseC.fCharPos >= 0)
          Insert(&phraseC);
        if (phraseR.fCharPos >= 0)
          Insert(&phraseR);

        if (done)
          break;
        cStart = pars.phrase.fCharPos + pars.phrase.fNumChars;
      }
      JoinPhrases();
      theChanges->fDefined = defined;
    }
#ifdef WORD7
    if (cmd == cNoCommand)
      CommitStyle(currency, NULL, part, custom);   // do not leave in Undo state for cNoCommand
#endif
  }
}


// ------------------------------------------------------------------------
void _TTextStructure::ToggleStyle(int part, Rect &custom, CmdNumber cmd)
{
  if (part == 1 && fUndoStyle != 0)
    _TSortedStructure::ToggleStyle(part, custom, cmd);
  else
    ToggleChanges(part, custom, cmd);
}


// ------------------------------------------------------------------------
void _TTextStructure::ToggleChanges(int part, Rect &custom, CmdNumber cmd)
{
  int temp;

  if (!fTempFlag && IsAllSelected(custom, fCount, cmd) && FindInsertionPhrase() == 0)
    _TSortedStructure::ToggleChanges(1, gZeroRect, cmd);
  else
  {
    if (fTempFlag)
      _TSortedStructure::ToggleChanges(1, gZeroRect, cmd);

    if (fUndoOffset != -1)
    {
      TCharPos cStart = ((TEmphasis *)&custom)->tag.fStartPos;
      TCharPos cEnd = ((TEmphasis *)&custom)->tag.fEndPos;
 
      temp = fUndoSize;
      fUndoSize = fSize;
      fSize = temp;
      temp = fUndoOffset;
      fUndoOffset = fFirstOffset;
      fFirstOffset = temp;

      // 19/1/92 process widgets; 28/01/92 fix loop end test
      for( int index = 1; index <= fSize; index++)
      {
        TPhrase phrase;

        Get(index, &phrase);
        if (phrase.fKind == kWidgetPhrase && cStart <= phrase.fCharPos 
                  && cEnd > phrase.fCharPos)
        {
          TStructure widget = GetStructureReadWrite(phrase.tag.fRecNum);

          widget->ToggleChanges(1, gZeroRect, cmd);
        }
      }
   }
  }
}


// ------------------------------------------------------------------------
void _TTextStructure::CommitStyle(TCurrency currency, TCommand command, int part, Rect &custom)
{
#ifdef SUPER
  TSelection s1, s2;
#endif

  fDocument->LockCurrency(currency, FALSE);       // 12/03/91

  if (!fTempFlag && IsAllSelected(custom, fCount, command ? command->fCmdNumber : cTabMove) &&
                                                      FindInsertionPhrase() == 0)
    _TSortedStructure::CommitStyle(currency, command, 1, gZeroRect);
  else
  {
    if (fTempFlag)
    {
      _TSortedStructure::CommitStyle(currency, command, 1, gZeroRect);
      fTempFlag = FALSE;
    }
    if (fUndoOffset != -1)
    {
      TCharPos cStart = ((TEmphasis *)&custom)->tag.fStartPos; // 19/1/92
      TCharPos cEnd = ((TEmphasis *)&custom)->tag.fEndPos;     // 19/1/92
      int lenToDelete = fUndoSize * sizeof(TPhrase);

      // 28/06/95 better do the deletions the same way as the insertion, otherwise index refs may
      //          be deleted when they should not
      DeleteSlice(fUndoOffset, lenToDelete);  // 28/06/95 faster than deleting individual phrases
      fOffset -= lenToDelete;
      fFirstOffset = 0;
      fUndoSize = 0;
      fUndoOffset = -1;

      if (command != NULL)
      {
        // 26/04/96 command should only be NULL when called from InstallStyleChange with
        // cNoCommand, in which case any widgets should be in a commited state already
        for (int index = 1; index <= fSize; index++)
        {
          TPhrase phrase;
        
          Get(index, &phrase);
          if (phrase.fKind == kWidgetPhrase &&
                          cStart <= phrase.fCharPos && cEnd > phrase.fCharPos)
          {
            TStructure widget = GetStructureReadWrite(phrase.tag.fRecNum);

            widget->CommitStyle(phrase.tag.fRecNum, command, 1, gZeroRect);
          }
        }
      }
    }
#ifdef SUPER
    s1 = fDocument->GetSelection(FALSE);
    s2 = fDocument->GetNewSelection();
    if (!s2->fCursor || !s2->GetAnchorOwner()->Equal(s1->GetAnchorOwner()))
      DeleteEmptyPhrases(kAnyPhrase);
#endif
  }
}


// ------------------------------------------------------------------------
//====================== non-DRAGDROP archived ===========================
bool _TTextStructure::Clear(TCursorNode anchor, TCursorNode activeEnd,
                            TClearTypes clearType, /* return bool &gone,*/ int &ch)
{
  bool gone;
  TCharPos startPos;
  TCharPos endPos;
  bool oneWidget;
  int pn;
  int pn1;
  Size numDeleted;
  // TCurrency wc;
  // TStructure widget;
  bool widgetGone;
  bool doWidgets = FALSE;   // added 25/04/91
  bool intelligent = FALSE;

  startPos = (anchor == NULL ? 0 : (doWidgets = TRUE, TTextCursor(anchor)->GetCharPos()));
  endPos = (activeEnd == NULL ? fCount - /* 1 [21224] */ (clearType != kClearedByMove || startPos > 0) : 
                // 30/07/93 - 1: stop leaving uncommited empty paras when drag > 2 paras
                // 23/08/93 startPos > 0, so Return left when drag starts in middle of para
       (doWidgets = TRUE,
        intelligent = TTextCursor(activeEnd)->fClickCount == 2 && ch == chBackspace &&
               (clearType == kNormalClear || clearType == kClearedByMove),
        Min(TTextCursor(activeEnd)->GetCharPos(), 
        fCount - (clearType != kClearedByPaste || ch != chBackspace)))); // 22/6/92
                                              // 24/01/91 was - 1
#ifdef THESAURUS
  if (clearType == kClearWord && anchor != NULL && activeEnd != NULL)
  {
    //kMixedCase, kUppercase, kLowerCase, kInitialCaps;
    char *theText = TextStart(this);
    int caseOfWord = kMixedCase;  // 10/01/95 [23026] make no text 'mixed case': kUppercase;
    int firstChar = 0;

    while (startPos > 0 && isalnum(theText[startPos - 1]))
      startPos--;
    while (endPos < fCount - 1 && isalnum(theText[endPos]))
      endPos++;
    for (int i = startPos; i < endPos; i++)
    {
      if (i == startPos && isupper(theText[i]))
        caseOfWord = kUppercase;
      else if (caseOfWord == kUppercase && islower(theText[i]))
        caseOfWord = kInitialCaps;
    }
    //if (caseOfWord == kMixedCase && isupper(theText[startPos]))
    //  caseOfWord = kInitialCaps;
    TTextCursor(anchor)->SetCharPos(startPos);
    TTextCursor(activeEnd)->SetCharPos(endPos);
    fTempFlag = caseOfWord;
  }
  else
    fTempFlag = kMixedCase;
#endif
  numDeleted = endPos - startPos;
//  oneWidget = (startPos == endPos && anchor != NULL && !anchor->IsLast() &&
//       anchor->fCurrency == activeEnd->fCurrency); // 17/09/92 3 extra tests
                      // 18/11/93 [21126] test wrong for drag from just before into widget
  oneWidget = FALSE;
  if (!IsLastNode(anchor))
  {
    if (numDeleted == 0)
      oneWidget = TRUE;   // node following anchor and anchor is first => both ends in widget
    pn = FindPhrase(startPos /* 02/04/92 , kWidgetPhrase */);
    if (pn != 0)
    {
      // 2/4/92 force all of partially selected widgets to clear 07/04/92 reinstated
      // wc = PPhrase(At(pn))->tag.fRecNum;
      // widget = GetStructureReadWrite(PPhrase(At(pn))->tag.fRecNum);
      if (oneWidget /* 17/09/92 && activeEnd != NULL */)
      {
        widgetGone = GetStructureReadWrite(PPhrase(At(pn))->tag.fRecNum)->
                     Clear(anchor->GetNext(), activeEnd->GetNext(), clearType, ch);
        if (!widgetGone)
        {
          startPos++;
          numDeleted--; // 25/07/90 NB this is equivalent to numDeleted = -1;
        }
      }
      else
        widgetGone = TRUE;
      if (widgetGone)
      {
        numDeleted = Max(1, numDeleted);
        if (anchor != NULL) // 9/7/92
          anchor->Collapse();
        if (oneWidget && activeEnd != NULL)
        {
          activeEnd->Collapse();
          if (anchor != activeEnd)
            TTextCursor(activeEnd)->ChangeCharPos(1); // 18/11/93 [21126] so toggle finds it
        }
      }
    }
    pn++;   // 25/04/91
  }
  else
    pn = 1;

  if (!oneWidget && (pn1 = FindPhrase(endPos) - 1) >= 0 && !IsLastNode(activeEnd))
  {
    endPos++;
    // 18/11/93 Max is a waste of space: numDeleted = Max(1, numDeleted + 1);
    numDeleted++;                        // 24/01/91 + 1 added
    if (clearType != kClearedByPaste)    // 25/09/92 if we collapse, GivePastePos is wrong
      activeEnd->Collapse();             // 25/07/90
  }
  else
    pn1 = GetSize();   // 25/04/91

  // 25/04/91 new block
  if (doWidgets)
    for (; pn <= pn1; pn++)
    {
      PPhrase phrase = PPhrase(At(pn));

      if (phrase->fKind == kWidgetPhrase && phrase->fCharPos > startPos &&
                                                 phrase->fCharPos < endPos)
        /* widgetGone = */
        GetStructureReadWrite(phrase->tag.fRecNum)->Clear(NULL, NULL, clearType, ch); 
    }

  gone = (numDeleted >= fCount /* 24/01/91 - 1 */);

  if (ch == chReturn && anchor != NULL && (gone || activeEnd == NULL))
  {
#ifdef TRACE
    Assert(!gone, 451); // if never hit, gone test is redundant
#endif
    ch = chBackspace;
    fTempFlag = TRUE;
  }
  else if (intelligent)
  {
    while (endPos < fCount - 1 && *(TextStart(this) + endPos) == chSpace)
    {
      endPos++;
      intelligent = FALSE;
      numDeleted++;
    }
    while (intelligent && startPos > 0 && 
           *(TextStart(this) + startPos - 1) == chSpace)
    {
      numDeleted++;
      startPos--;
    }
    if (anchor != NULL) 
      TTextCursor(anchor)->SetCharPos(startPos);
    TTextCursor(activeEnd)->SetCharPos(endPos);
  }

  if (numDeleted > 0)
  {
    NewEditPhrase(startPos, numDeleted, TRUE);
  }
  return gone;
}


// ------------------------------------------------------------------------
static void MarkWidget(TObject null, PPhrase phr)
{
  if (phr->fKind == kWidgetPhrase)
  {
    phr->tag.fRecNum = Curr_Set(-Curr_fRecnum(phr->tag.fRecNum),
                                          Curr_fType(phr->tag.fRecNum));
  }
}

// ------------------------------------------------------------------------
void _TTextStructure::DoCopyEmphasis(PPhrase phrase, TTextDocument clipDocument)
{
  if (phrase->fKind == kTextPhrase)
  {
    if (phrase->tag.txt.fStyle != 0)
      phrase->tag.txt.fStyle = clipDocument->ConvertAndCloneStyle(fDocument,
                                                  phrase->tag.txt.fStyle);
    if (phrase->tag.txt.fChanges != 0)
      phrase->tag.txt.fChanges = clipDocument->ConvertAndCloneStyle(fDocument,
                                                  phrase->tag.txt.fChanges);
  }
  else
    MarkWidget(NULL, phrase);
  phrase->tag.paste.fOriginalPhrase = 0;
  // 25/08/93 [21035], 14/06/93 [20933] so things from c/b can be recognised in PastePhrase
}

// ------------------------------------------------------------------------
// fn1 name changed to include ...AndNotes + extra param
void _TTextStructure::DoCopyWidgetsAndNotes(PPhrase phrase, TTextDocument clipDocument,
                                            TCurrency clipCurrency, TStructure structure)
{
  TStructure widget;
  TCurrency currency;

  if (phrase->fKind == kWidgetPhrase)
  {
    currency = Curr_Set(-Curr_fRecnum(phrase->tag.fRecNum), Curr_fType(phrase->tag.fRecNum));
    widget = GetStructureReadOnly(currency); // 19/03/91 RW
#ifdef DRAGDROP
    widget->CopyToClipboard(currency, /* next1, next2, 25/09/92 see above */
                NULL, NULL, NULL, clipDocument, clipCurrency, phrase->fCharPos);
#else
    widget->CopyToClipboard(currency, /* next1, next2, 25/09/92 see above */
                NULL, NULL, clipDocument, clipCurrency, phrase->fCharPos);
#endif
  }
#ifdef FN
  else if (phrase->fKind == kNotePhrase)
  {
    TCurrency noteCollector = structure->GetNoteCollector();
    TStructure noteStruct = GetStructureReadOnly(phrase->tag.fRecNum);
#ifdef DRAGDROP   
    noteStruct->CopyToClipboard(phrase->tag.fRecNum, NULL, NULL, NULL, clipDocument,
        noteCollector, -22);        // 17/05/93 [20876] from -1
#else
    noteStruct->CopyToClipboard(phrase->tag.fRecNum, NULL, NULL, clipDocument,
        noteCollector, -22);        // 17/05/93 [20876] from -1
#endif
    phrase->tag.fRecNum = structure->GetLastNote();
    clipDocument->GetStructureReadWrite(phrase->tag.fRecNum)->ProtoInit(clipCurrency);
  }
#endif
#ifdef INDEX
  else if (phrase->fKind == kIndexRefPhrase)
  {
    TTextStructure(structure)->PasteIndexRef(phrase, clipCurrency, clipDocument);
  }
#endif
}

// ------------------------------------------------------------------------
// ================== THE non-DRAGDROP archived ==========================
void _TTextStructure::CopyToClipboard(TCurrency currency, TCursorNode anchor,
        TCursorNode activeEnd, TCursorNode dropNode,
        TTextDocument clipDocument, TCurrency clipParent, long pos)
{
  TTextStructure structure;
  TCurrency clipCurrency;
  FailInfo fi;
  TCharPos cp1, cp2;
//  int ch1, ch2;
//  CharsPtr cp;
  TCursorNode next1 = NULL;
  TCursorNode next2 = NULL;
  bool intelligent = FALSE;

  if (activeEnd != NULL)
  {
    next1 = activeEnd->GetNext();
    intelligent = TTextCursor(activeEnd)->fClickCount == 2;
    cp2 = TTextCursor(activeEnd)->GetCharPos();
    if (next1 != NULL)
      cp2++;                    // 25/09/92 copy widgets at end of selection
  }
  else
    cp2 = fCount;

  if (anchor != NULL)
  {
    next2 = anchor->GetNext();
    cp1 = TTextCursor(anchor)->GetCharPos();
  }
  else
  { 
    intelligent = FALSE;
    cp1 = 0;
  }

  if (dropNode != NULL && dropNode->fCurrency == currency)
    TTextCursor(dropNode)->fEdge.fPartNum = 0;

  // 21/02/91 new condition
  if (next1 != NULL && next2 != NULL &&
                   next1->fCurrency == next2->fCurrency)
  {
    TStructure widget = GetStructureReadOnly(next1->fCurrency); // 19/03/91 RW

    clipCurrency = clipParent;
    widget->CopyToClipboard(next1->fCurrency, next2, next1, dropNode, clipDocument,
                                    clipCurrency, pos); // 12/01/92 1 & 2 swapped
  }
  else
  {
    structure = TTextStructure(Clone());
    structure->fDocument = NULL;       // 06/12/94 do now rather than later
    CatchFailures(&fi);     // 28/09/92 moved after Clone

    if (cp2 < fCount)
    {
      structure->DeleteText(cp2, fCount - cp2 - 1);
      for (int i = structure->fSize; i >= 1; i--)
      {
        // inline:   n = structure->LastThat(this,
        //   (TestItem)_TTextStructure::DeleteAfterCP, structure, cp2);
        PPhrase phr = PPhrase(structure->At(i));
        bool ret = (phr->fCharPos <= cp2);    // save before Delete

        if (phr->fCharPos >= cp2)
          structure->Delete(i);
        else
        {
          if (phr->fCharPos + phr->fNumChars > cp2)
            phr->fNumChars = cp2 - phr->fCharPos;
        }
        if (ret)
          break;
      }
    }
#ifndef INDEX
    if (cp1 > 0)      // force through this branch even if from start
#endif
    {
      structure->DeleteText(0, cp1);
      // inline: n = structure->LastThat(this,
      //              (TestItem)_TTextStructure::DeleteBeforeCP, structure, cp1);
      for (int j = structure->fSize; j >= 1; j--)
      {
        PPhrase phr = PPhrase(structure->At(j));

        if (phr->fCharPos >= cp1)
        {
          phr->fCharPos -= cp1;
#ifdef TRACE
          // 26/04/93 must not put edit phrases on clipboard (d/d only?)
          Assert(phr->fKind != kEditPhrase, 777);
#endif
#ifdef INDEX
          // only need to test in this branch because fNumChars is 1 for index phrase
          if (phr->fKind == kIndexRefPhrase)
            CopyIndexPhraseToClipboard(currency, phr, fDocument, j);
#endif
        }
        else if ((phr->fCharPos + phr->fNumChars) > cp1)
        {
          phr->fNumChars = phr->fNumChars - (cp1 - phr->fCharPos);
          phr->fCharPos = 0;
#ifdef TRACE
          Assert(phr->fKind != kEditPhrase, 778);
#endif
        }
        else
          structure->Delete(j);
      }
    }

// 15/03/93 [20707] set tempflag on last of several, as well as seln in single para
    structure->fTempFlag = (intelligent ? kIntelligent : (activeEnd != NULL && cp2 < fCount)
#ifdef MATHS
            || Curr_fType(fParent) == kMathStruct
                  // 02/08/93 [21007] do not treat dragged in-line text as a paragraph
#endif
                                                                );
// 15/03/93 from: structure->fTempFlag = (anchor != NULL && structure->fCount != cp2 - cp1);

    structure->Each(this, (DoToItem)_TTextStructure::DoCopyEmphasis, clipDocument);
    clipCurrency = currency;
    clipDocument->AddStructure(0, structure, pos, clipParent, fDocument, clipCurrency);
    Success(&fi);
// fn1 changed name of iterator + added param
    structure->Each(this, (DoToItem)_TTextStructure::DoCopyWidgetsAndNotes,
// 28/09/92         &anchor, &activeEnd,
                    clipDocument, clipCurrency, structure);
  }
  return;
// ++++++++++++++++++++++++++++++++++++++
Rescue:
  FreeIfObject(structure);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
TStructure _TTextStructure::CloneForPaste(TCurrency currency, TTextDocument targetDoc)
{
  TTextStructure newStruct;

  newStruct = TTextStructure(Clone());
  newStruct->Each(NULL, (DoToItem)MarkWidget);
#ifdef INDEX
  for (int j = 1; j <= fSize; j++)
  {
    PPhrase phr = PPhrase(newStruct->At(j));

    if (phr->fKind == kIndexRefPhrase)
      newStruct->CopyIndexPhraseToClipboard(currency, phr, fDocument, j);
  }
#endif
  return newStruct;
}


// ------------------------------------------------------------------------
void _TTextStructure::GivePastePosition(TCursorNode cursor, 
                                        long &startPos, long &endPos)
{
  // 25/07/90 - rewritten
  startPos = Min(TTextCursor(cursor)->GetCharPos() + (1 - cursor->IsLast()),
                   // 25/09/92 adjust pos for widget at the end of selection when pasting
               fCount - 1);
  endPos = startPos;
}


// ------------------------------------------------------------------------
bool _TTextStructure::InSecondHalf(TCursorNode cursor)
{
  return (TTextCursor(cursor)->GetCharPos() + (1 - cursor->IsLast()) >= (fCount / 2));
                  // 21/10/92 treat char pos as being after a selected widget (picture)
}


#ifndef MATHS
// 29/07/93 if maths, handled in TStructure
// ------------------------------------------------------------------------
int _TTextStructure::CanDoPaste(TCurrency currency,
                                   TStructure dataToPaste, int numOfItems)
{
  // 05/03/91 numOfItems > 1 incorporated in test
  if (// 05/10/93 !IsShown(myCurrency, gNullCurrency) ||       // 25/04/91 extra param
      numOfItems > 1 ||
      Curr_fType(currency) == kBodyStruct ||
#ifdef TABLES
      Curr_fType(currency) == kTableStruct ||     // 25/07/90
#else
#if SIDEBAR != 1
                     // 01/11/95 go back to in-line pictures for TalkWrite
      (Curr_fType(currency) == kPictStruct && fCount == 1) ||  // 02/03/94 [21439]
#endif
#endif
      (Curr_fType(currency) == kTextStruct && 
        /* 28/4/93 [20885] fCount > 1 && don't allow a para to paste in an empty para */
      !TTextStructure(dataToPaste)->fTempFlag))    // 25/04/91 reverse test
    return 0;
  return 1;
}
#endif


#ifdef MATHS
// ------------------------------------------------------------------------
bool _TTextStructure::CanPasteInLine()
// new 11/01/92
{
  return fTempFlag;
}
#endif

// ------------------------------------------------------------------------
bool _TTextStructure::AllSelected(TCurrency currency,
                                  TCursorNode anchor, TCursorNode activeEnd)
{
  TCharPos cp1, cp2;

  cp1 = (anchor == NULL ? 0 : Min(fCount - 1, TTextCursor(anchor)->GetCharPos()));
  cp2 = (activeEnd == NULL ? fCount : TTextCursor(activeEnd)->GetCharPos());

  return (cp2 - cp1 >= fCount/* 24/01/91 - 1 */);  // 25/07/90
}


// ------------------------------------------------------------------------
//========================= non-DRAGDROP archived ==========================
void _TTextStructure::ToggleState(TCurrency currency, TCursorNode anchor,
                                  TCursorNode activeEnd, TCommand command)
{
  int insertions;
  int deletions;
  TCharPos startPos, endPos;
  TCharPos startDel = MAXLONGINT, endDel = MAXLONGINT;
  bool doWidgets;
  PPhrase insPhr = NULL;
  PPhrase delPhr = NULL; // fn1
  int pn;
  int pn1;
  TCurrency dc;
  bool dragDrop = command->fCmdNumber == cMove && 
         (dc = TStructureCmd(command)->GetDropCurrency()) != 0 &&
            (dc == currency ||
             GetStructureReadOnly(dc)->IsPartOf(1 << kText) == currency);
             // 24/01/94 IsPartOf passed a set of TStyleTypes
  bool undo = command->fCmdDone;
#ifdef EXPERIMENT
  TCurrency inWidget;

  inWidget = 0;
#endif
  insertions = FindInsertionPhrase();
  deletions = FindDeletionPhrase();

  if (insertions > 0)
  {
    delPhr  = PPhrase(At(insertions)); // fn1 & yes it should be delPhr
    if (!dragDrop)
      delPhr->tag.fDeletions = !delPhr->tag.fDeletions;
    if (undo == dragDrop)       // shorter than ((!undo && !dragDrop) || (undo && dragDrop))
    {
      startDel = delPhr->fCharPos;
      endDel = startDel + delPhr->fNumChars;
    }
  }

  if (deletions > 0)
  {
    insPhr = PPhrase(At(deletions)); // fn1 & yes it should be insPhr
    if (!dragDrop)
      insPhr->tag.fDeletions = !insPhr->tag.fDeletions; // fn1    
    if (undo != dragDrop)    // shorter than ((undo && !dragDrop) || (!undo && dragDrop))
    {
      startDel = insPhr->fCharPos;
      endDel = startDel + insPhr->fNumChars;
    }
  }
#ifdef EXPERIMENT
  if (!IsLastNode(anchor) && !IsLastNode(activeEnd))  // 23/11/93 [21130] and both in widget
  {
    startPos = 0;
    endPos = fCount - 1;
    pn = 1;
    pn1 = GetSize();
    doWidgets = TRUE;
    inWidget = anchor->GetNext()->fCurrency;
  }
  else
#endif
{
  doWidgets = (insertions > 0 || deletions > 0); // 13/01/92

  startPos = (anchor == NULL ? 0 : TTextCursor(anchor)->GetCharPos());
  endPos = (activeEnd == NULL ? fCount - 1 : TTextCursor(activeEnd)->GetCharPos());

  if (startPos > startDel)
  {
    int delLen = endDel - startDel;
    startPos += delLen;
    endPos += delLen;
  }

// case of dropping a widget to left of drag selection: drag cursors out by size of insertion
  if (dragDrop && undo && deletions > 0 && startPos >= insPhr->fCharPos)
                                             // 11/08/93 [21022] >= for > in startpos test
  {
    startPos += insPhr->fNumChars;
    endPos += insPhr->fNumChars;
  }
  else if (dragDrop && !undo && insertions > 0 && startPos >= delPhr->fCharPos)
                                             // 11/08/93 [21022] >= for > in startpos test
  {
    startPos += delPhr->fNumChars;
    endPos += delPhr->fNumChars;
  }

  // find start and end phrase numbers

  if ((pn = FindPhrase(startPos)) == 0)
    pn = 1;

  if (startPos == endPos || (pn1 = FindPhrase(endPos)) == 0)
    pn1 = GetSize();
}

  for (int i = pn; i <= pn1; i++)
  {
    PPhrase phrase = PPhrase(At(i));

#ifdef EXPERIMENT
    if (phrase->fKind == kWidgetPhrase &&
            (phrase->tag.fRecNum == inWidget ||
              (inWidget == 0 &&
                phrase->fCharPos >= startPos && phrase->fCharPos <= endPos)))
#else
    if (phrase->fKind == kWidgetPhrase &&
                phrase->fCharPos >= startPos && phrase->fCharPos <= endPos)
#endif
    {
      TCurrency wc = phrase->tag.fRecNum;
      TCursorNode ancNext = NULL;
      TCursorNode actNext = NULL;
      bool toggleIt = (phrase->fCharPos == endPos ? startPos == endPos : doWidgets);
                        // if at the end of range only toggle if cursor in widget

      if (!IsLastNode(anchor))         // if (anchor != NULL && !anchor->IsLast())
      {
        ancNext = anchor->GetNext();
        if (ancNext->fCurrency == wc)
          toggleIt = TRUE;
        else
          ancNext = NULL;
      }
      if (!IsLastNode(activeEnd))       // if (activeEnd != NULL && !activeEnd->IsLast())
      {
        actNext = activeEnd->GetNext();
        if (actNext->fCurrency == wc)
          toggleIt = TRUE;
        else
          actNext = NULL;
      }
      // if (toggleIt && (wc.cgf_31.fRecnum & 0x8000) == 0)
      if (toggleIt && wc >= 0)        // 16/09/92 toggle after paste fail
      {
        TStructure wStructure = GetStructureReadWrite(wc);

        if (deletions > 0 && phrase->fCharPos >= insPhr->fCharPos && 
          phrase->fCharPos < insPhr->fCharPos + insPhr->fNumChars)
            wStructure->fParent = currency;
        if (wStructure->fParent == currency) // 07/09/92 test if still mine
          wStructure->ToggleState(wc, ancNext, actNext, command);
      }
    }
  }
}


// ------------------------------------------------------------------------
void _TTextStructure::RemoveDeletions(PPhrase phr, TCurrency currency, // fn1
       PPhrase delPhrase, TCommand command)
{
  TCharPos endPos;
  TCharPos endDeletions = delPhrase->fCharPos + delPhrase->fNumChars;

  if (phr->fKind != kEditPhrase)
  {
    endPos = phr->fCharPos + phr->fNumChars;   // 24/01/91 - 1 added; 25/04/91 out again
    if ((phr->fCharPos >= delPhrase->fCharPos) && (phr->fCharPos < endDeletions))
    {
      phr->fNumChars = Max(0, phr->fNumChars - (endDeletions - phr->fCharPos));
      phr->fCharPos = delPhrase->fCharPos;      // 08/02/91
#ifdef FN
      if (phr->fKind == kNotePhrase)
        DeleteNote(currency, phr->tag.fRecNum, command);  // 21/12/92 pass command
#endif
#ifdef INDEX
      if (phr->fKind == kIndexRefPhrase)
        DeleteIndexRef(phr, currency);
#endif
    }
    else if ((endPos >= delPhrase->fCharPos) && (endPos < endDeletions))
    {
      phr->fNumChars -= (endPos - delPhrase->fCharPos); // 25/04/91 + numInserts;
    }
    else if (phr->fCharPos < delPhrase->fCharPos && endPos >= endDeletions)
    {
      // 25/04/91 extra else if test
      phr->fNumChars -=  delPhrase->fNumChars;
    }
    else if (phr->fCharPos >= endDeletions)  // 02/05/90 - new to mac
      phr->fCharPos -= delPhrase->fNumChars;  // 02/05/90 - new to mac
  }
}


// ------------------------------------------------------------------------
// fn1 changed name to include ...AndNotes, added currency
void _TTextStructure::RemoveWidgetsAndNotes(PPhrase phr, TCurrency currency,
         TCommand command)
{
  if (phr->fKind == kWidgetPhrase)
  {
    TCurrency widgetCurr = phr->tag.fRecNum;
    TStructure widgetStruct = GetStructureReadWrite(widgetCurr);

#ifdef TRACE
    if (widgetStruct->fParent != currency)
    {
      SysBeep(0); // 13/08/96 for corruption (improper widget duplication) after paste
    }
    else
#endif
    {
      widgetStruct->Commit(widgetCurr, NULL, NULL, command, TRUE); // 25/04/91
      fDocument->DeleteCurrency(widgetCurr);
    }
  }
#ifdef FN
  else if (phr->fKind == kNotePhrase)
    DeleteNote(currency, phr->tag.fRecNum, command);
#endif
#ifdef INDEX
  else if (phr->fKind == kIndexRefPhrase)
    DeleteIndexRef(phr, currency);
#endif
}


// ------------------------------------------------------------------------
void _TTextStructure::DoDeleteWidget(TCurrency currency, TCharPos pos, TPhrase &delPhrase,
     TCurrency widgetCurr, TCursorNode startCursor, TCursorNode endCursor, TCommand command)
{
  // if ((widgetCurr.cgf_31.fRecnum & 0x8000) == 0) // 16/09/92 commit after paste fail
  if (widgetCurr >= 0) // 16/09/92 commit after paste fail
  {
    TStructure widgetStruct = GetStructureReadWrite(widgetCurr);
                // for safety see if deleted??? (rather than rely on prototypes fParent)

    if (widgetStruct->fParent == currency)
    {
      bool freeParts = FALSE;

      // Inline DeletedWidget
      if (pos >= delPhrase.fCharPos && pos < delPhrase.fCharPos + delPhrase.fNumChars)
        freeParts = TRUE;
      widgetStruct->Commit(widgetCurr, startCursor, endCursor, command, freeParts);

      if (freeParts)
        fDocument->DeleteCurrency(widgetCurr);
    }
  }
}

// ------------------------------------------------------------------------
void _TTextStructure::Commit(TCurrency currency, TCursorNode anchor,
                   TCursorNode activeEnd, TCommand command, bool freeParts)
{
  int insertions;
  int deletions;
  TPhrase delPhrase;
//  TPhrase insPhrase;
  TCursorNode nextAnchor;
  TCursorNode nextActiveEnd;
  TCurrency startWidget;
  TCurrency endWidget;
//  TCharPos endDeletions;
//  TStructure startWidgetStruct;
//  TStructure endWidgetStruct;
  TCharPos startPos;
  TCharPos endPos;
  int pn;
  int pn1;
// 06/08/93 [21018]  bool doWidgets = FALSE;
  TCurrency startPosCurr;

  fDocument->LockCurrency(currency, FALSE);       // 12/03/91
  if (freeParts)
// fn1 changed iterator name, added currency to call
    Each(this, (DoToItem)_TTextStructure::RemoveWidgetsAndNotes, currency, command);
  else
  {
    int offset = 0;   // 15/09/92 do like ToggleState
    TCharPos startWidgetPos = 0;  // 23/11/93 [21022] startPos but allowing for deletions

    fTempFlag = FALSE;
    startWidget = 0;
    endWidget = 0;
    startPosCurr = 0;      // 18/09/92
    nextAnchor = NULL;
    nextActiveEnd = NULL;
    // 25/04/91 4 new initialisations
    startPos = 0;
    endPos = fCount - 1;
    pn = 1;
    pn1 = GetSize();

    insertions = FindInsertionPhrase();
    deletions = FindDeletionPhrase();

    if (insertions > 0)       // 15/09/92
    {
      PPhrase insPhr = PPhrase(At(insertions));

      offset = insPhr->fCharPos + insPhr->fNumChars;
    }

    if (deletions > 0)
    {
      Get(deletions, &delPhrase);
      offset = Max(offset, delPhrase.fCharPos + delPhrase.fNumChars);
    }
    else
      delPhrase.fCharPos = MAXLONGINT;

    if (anchor != NULL)
    {
      // 06/08/93 [21018]      doWidgets = TRUE;
      nextAnchor = anchor->GetNext();
      // startPos = TTextCursor(anchor)->GetCharPos(); // 18/09/92 rather than inside test
      if (nextAnchor != NULL)
      {
        startWidgetPos = startPos = TTextCursor(anchor)->GetCharPos();
        if (startWidgetPos >= delPhrase.fCharPos)    // 23/11/93 [21022] set startWidgetPos
          startWidgetPos += delPhrase.fNumChars;
        pn = FindPhrase(startPos /* 02/04/92 , kWidgetPhrase */) + 1; // 25/04/91
        startWidget = nextAnchor->fCurrency;
      }
    }

    if (activeEnd != NULL)
    {
// 06/08/93 [21018]      doWidgets = TRUE;
      // endPos = Min(Max(TTextCursor(activeEnd)->GetCharPos(), offset - 1), fCount - 1);// 15/09/92
      nextActiveEnd = activeEnd->GetNext();
      if (nextActiveEnd != NULL)
      {
        endPos = Min(Max(TTextCursor(activeEnd)->GetCharPos(), offset - 1), fCount - 1);// 15/09/92
// 15/09/92        endPos = TTextCursor(activeEnd)->GetCharPos(); // 25/04/91
// 15/09/92        if (deletions > 0 && endPos >= delPhrase.fCharPos)   // 03/03/92 new test
// 15/09/92          endPos += delPhrase.fNumChars;
        pn1 = FindPhrase(endPos /* 02/04/92 , kWidgetPhrase */) - 1; // 2/4/92 was endPos - 1
        if (pn1 < 0)
          pn1 = GetSize();     // 15/09/92 set to end
        endWidget = nextActiveEnd->fCurrency;
      }
    }

    // 25/04/91 new block
    // 06/08/93 [21018] left uncommited widgets after DoJoin!   if (doWidgets)
    if (deletions > 0 || insertions > 0)    // 06/08/93 [21018] same test as in Toggle??
      for (; pn <= pn1; pn++)
      {
        PPhrase phrase = PPhrase(At(pn));

        if (phrase->fKind == kWidgetPhrase && phrase->fCharPos >= startPos && // 22/09/92 >
                     phrase->fCharPos < endPos)
          DoDeleteWidget(currency, phrase->fCharPos, delPhrase, phrase->tag.fRecNum,
                                        NULL, NULL, command);
      }

    if (deletions > 0)
    {
      // 25/04/91      Get(deletions, &delPhrase);
      // 15/09/92     if (insertions > 0)
      // moved up       Get(insertions, &insPhrase);
      Each(this, (DoToItem)_TTextStructure::RemoveDeletions, currency, &delPhrase,
           command);  // 12/06/90 - delphrase & put on fn1 added currency
      // 25/04/91           startWidget, endWidget, &nextAnchor, &nextActiveEnd,
      // 25/04/91           insertions > 0 ? insPhrase.fNumChars : 0);
      DeleteText(delPhrase.fCharPos, delPhrase.fNumChars);
    }

    if (insertions > 0)
    {
      Delete(insertions);
      if (insertions < deletions)
        deletions --;
    }

    if (deletions > 0)
      Delete(deletions);

    if (nextAnchor != NULL)
    {
      TCursorNode rhend;

      if (startWidget == endWidget)
      {
        rhend = nextActiveEnd;
        nextActiveEnd = NULL;
      }
      else
        rhend = NULL;

      DoDeleteWidget(currency, startWidgetPos, delPhrase, startWidget,
               nextAnchor, rhend, command);  // 23/11/93 [21022] use startWidgetPos
    }

    if (nextActiveEnd != NULL)
       DoDeleteWidget(currency, endPos, delPhrase, endWidget,
               NULL, nextActiveEnd, command);   // 28/08/92 swap NULL & nextActiveEnd

#if !defined TABLES || defined NETWP
    // 30/09/94 [22030] do not delete empty text phrase after line split
    // 18/07/96 try to be specific to preserving empty emphasis phrase left after <Return>
    DeleteEmptyPhrases(command && command->fCmdNumber == cTyping && activeEnd && !anchor ? 
                         kTextPhrase : kAnyPhrase);
#else
    DeleteEmptyPhrases(kAnyPhrase);
#endif
    // 03/08/93 [21004] need to commit the text that is being joined! So do Join in-line
                        // 11/11/93 otherwise widgets may get doubly deleted after Join
    if (fLinkStruct > 0)      // NB. recnum is at top of word
    {
      DoJoin(currency, fLinkStruct);
      Commit(currency, NULL, NULL, command, freeParts);
    }
    fLinkStruct = 0;
    JoinPhrases();        // 18/07/96 join phrases after cut, delete, D&D away
  }
}


// ------------------------------------------------------------------------
bool _TTextStructure::CanTypeFast(TCurrency childCurr)
{
  // 18/06/95 [26018] for text, childCurr is my currency; lets body decide if in a chapter
  // or document heading, so we need to reformat and redraw headers and footers.
  // Text is the only one that passes descision up to the parent, so while you cannot have
  // text within text we know that this is the call from DoType, not from a child.
  return (GetStructureReadOnly(fParent))->CanTypeFast(childCurr); // 19/03/91 RW
}

#ifdef TABLES
// ------------------------------------------------------------------------
static int InsertSmartChar(TTextStructure self, TCharPos cp, int ch)
{
  if (ch >= 0x200)
  {
    if ((ch & 0x200) != 0)
    {
      *(TextStart(self) + cp - 1) = ch >> 16;  // not first, so replace it and continue
      return -1;
    }
    ch = ch >> 16;  // return smart char conversion to be inserted
  }
  return ch;
}
#endif

// ------------------------------------------------------------------------
bool _TTextStructure::HandleKeypress(int ch, TCursorNode cursorNode)
{
  TCursorNode widgetCursor;
  TCharPos cp;
  int len;
  TStructure myParent;
  TStructure widget;
  TCurrency widgetCurrency;
  TCurrency xWidgetCurrency;
  int pn;
  int insPhrase;
  int delPhrase;
  TPhrase phrase;
  bool inEmphasis;
  int incr;
  bool HandleKeypress_r;
  bool readKey = FALSE;        // 04/06/91

do {        // 04/06/91
  HandleKeypress_r = TRUE; // 29/05/90
  SetTextGlobals(this);    // 17/05/91 FwdDel
  cp = TTextCursor(cursorNode)->GetCharPos();

  // 04/06/91 it is going to parent; exit as if it never unbuffered ch
  if (readKey && ch == chBackspace &&
       (cp == 0 || (cp >= fCount && fCount == 1)))
  {
    UndoGetNextKey();
    return TRUE;
  }
  if (cp >= fCount)
  {
    cp = fCount - 1;
    TTextCursor(cursorNode)->SetCharPos(cp);
  }

  insPhrase = FindInsertionPhrase();
  delPhrase = FindDeletionPhrase();
  if (ch == chBackspace || ch == chFwdDelete ||
                                 ch == chLeft || ch == chRight) // 23/05/91
  {
    // NB if this condition changes the test for UndoGetNextKey needs to be
    // changed the same way
    // 9/7/92 added if stmt to deal with bs after fwdDel in table
    if (delPhrase != 0 && cp > gDelPos && (ch == chLeft || ch == chBackspace))
    {
      cp = gDelPos;
      TTextCursor(cursorNode)->SetCharPos(cp);
    }
    if (cp == 0 && ch != chFwdDelete && cursorNode->IsLast()) // 17/7/92
    {
      ch = (IsEmpty()? chLeft: chBackspace);
      return GetStructureReadWrite(fParent)->
                             HandleKeypress(ch, cursorNode->GetPrevious());
    }
    else if (cp + gDelCount >= fCount - 1 && ch == chFwdDelete && 
                cursorNode->IsLast()) // 17/7/92, 17/05/91
    { // 22/6/92 pass FwdDelete to parent
      ch = (IsEmpty()? chRight: chFwdDelete);
      return GetStructureReadWrite(fParent)->
                             HandleKeypress(ch, cursorNode->GetPrevious());
    }
    else
    {
      if (ch == chRight || ch == chFwdDelete)      // 24/6/92, 23/05/91
      {
        incr = 0;
      }
      else
      {
        incr = cursorNode->IsLast(); // 24/6/92
      }
      pn = GetPhraseAt(cp - incr, phrase, kWidgetPhrase);   // 16/06/91
      if (pn > 0)
      {
        widgetCursor = TTextCursor(cursorNode)->GetNext();
        if (widgetCursor != NULL)
        {
          xWidgetCurrency = widgetCursor->fCurrency;
          cursorNode->Collapse();
          if (ch == chFwdDelete || ch == chRight) // 24/6/92
          {
            if (ch == chFwdDelete)            // 15/09/92 cursor after fwd del widget
              TTextCursor(cursorNode)->ChangeCharPos(1); // 24/6/92, 19/1/92
            TTextCursor(cursorNode)->SetChange(
                TTextCursor(cursorNode)->GetChange() + 1); // 24/6/92, 21/02/92
          }
          TTextCursor(cursorNode)->fCursor->fChanged = TRUE; // 19/1/92
        }
        else
          xWidgetCurrency = 0;

        // 02/05/90 - this bit is new to the mac
        if (xWidgetCurrency != 0) // 24/6/92
        {
          if (ch == chLeft || ch == chRight) // 24/6/92
          {
            if (delPhrase == 0)
              NewEditPhrase(cp - incr, 1, TRUE);   // 17/05/91 incr for 1
            else
            {
              ChangePhraseLen(delPhrase, 1);
              if (ch == chLeft) // 22/6/92
                ChangePhrasePos(delPhrase, -1);
            }
          }
        }
        else
        {
          widgetCurrency = PPhrase(At(pn))->tag.fRecNum;
          widget = GetStructureReadWrite(widgetCurrency); // 17/7/92 RO, 19/03/91 RW
          if (ch == chBackspace) // 22/6/92
            TTextCursor(cursorNode)->ChangeCharPos(-1);
          widget->ExtendCursor(cursorNode, widgetCurrency, incr != 0, /* 19/1/92 */
                FALSE, FALSE); // 05/03/91 F
          return widget->HandleKeypress(ch, cursorNode->GetNext()); // 23/05/91 fm backspace
          // 24/06/92 do not assign to HandleKeypress_r, that makes it go round loop again
        }
      }
      else
      {
        int incrLen;

        // 17/09/90 for whole of following block: len for 1
        pn = GetPhraseAt(cp - incr, phrase, kMacroPhrase); // 27/09/90 extra par
#ifdef FN
        if (pn == 0)
        {
          pn = GetPhraseAt(cp - incr, phrase, kNotePhrase);
          if (pn > 0)
            ShowNote(phrase.tag.fRecNum, kHidden);
        }
#endif
        len = (pn > 0 ? phrase.fNumChars : 1);
        incrLen = -(len * incr);   // 25/01/94
        inEmphasis = CP2Phrase(cp, TRUE, phrase); // 25/07/90
        if (insPhrase > 0 && incr != 0)
        {
          UpdatePhrases(cp, -len, FALSE, FALSE); // 23/09/92 extra param
          ChangePhraseLen(insPhrase, -len);
          DeleteText(cp - len, len);
          if (delPhrase > insPhrase)
            ChangePhrasePos(delPhrase, -len);
        }
        else
        {
          if (delPhrase == 0)
            NewEditPhrase(cp + incrLen, len, TRUE);  // 17/05/91 - incr, 25/01/94 incrLen
          else
          {
            ChangePhraseLen(delPhrase, len);    // 17/09/90 len for 1
            ChangePhrasePos(delPhrase, incrLen); // 25/01/94 -(len * incr));   // 17/09/90 -len for -1
          }
        }
        TTextCursor(cursorNode)->ChangeCharPos(incrLen); // 25/01/94 -(len * incr));
        TTextCursor(cursorNode)->SetChange(TTextCursor(cursorNode)->GetChange() - len); // 21/02/92
        TTextCursor(cursorNode)->SetReverseWrap(TRUE);
        DeleteEmptyPhrases(kAnyPhrase);
        cursorNode->fCursor->fChanged = (inEmphasis ||
                      CP2Phrase(Min(cp + incrLen, gDelPos), TRUE, phrase));
                // 25/01/94 [21358] add incrlen so menus set up when b/s to end of emphasis
                                     // 17/05/91 Min from cp - 1
      }
    }                                      
  }
  else if (ch == chReturn)
  {
    myParent = GetStructureReadWrite(fParent);
    TTextCursor(cursorNode)->SetReverseWrap(TRUE);
    TTextCursor(cursorNode)->SetChange(0);
    HandleKeypress_r = myParent->HandleKeypress(chReturn, cursorNode->GetPrevious());
  }
  else
  {
    if (!cursorNode->IsLast())
    {
      cursorNode->Collapse();
      cp++;
      TTextCursor(cursorNode)->SetCharPos(cp);
    }
#ifdef TABLES
    if ((ch = InsertSmartChar(this, cp, ch)) < 0)   // 03/07/95 [26023]
    {
      cursorNode->fCursor->fSelection->fReformatType = kReformatLine; // for mono-spaced fonts
#ifdef TRACE
      Assert(insPhrase, 828);
#endif
    }
    else
#endif
    {
      TTextCursor(cursorNode)->SetReverseWrap(ch == chSpace);

      TTextCursor(cursorNode)->ChangeCharPos(1);
      TTextCursor(cursorNode)->SetChange(TTextCursor(cursorNode)->GetChange() + 1); // 21/02/92
      InsertChar(ch, cp);             // 20/05/91
      UpdatePhrases(cp, 1, FALSE, FALSE);      // 23/09/92 extra param
      if (delPhrase > 0)
        ChangePhrasePos(delPhrase, 1);
      if (insPhrase == 0)
      {
        NewEditPhrase(cp, 1, FALSE);
#ifdef SUPER
        cursorNode->fCursor->fChanged = TRUE;
#endif
      }
      else
        ChangePhraseLen(insPhrase, 1);
    }
  }
  readKey = TRUE;  // 04/06/91 indicate not first time through
}
        // 04/06/91 end of loop test
  while(HandleKeypress_r && (ch == chBackspace || ch == chFwdDelete) &&
                                                         TestNextKey(ch));
    
  return HandleKeypress_r;  // 29/05/90
}


// ------------------------------------------------------------------------
void _TTextStructure::ResetPhrase(PPhrase phrase, TCharPos IP, bool deleteWidgetPhrase)
{
  if (IP <= phrase->fCharPos)
  {
    if (phrase->fKind == kWidgetPhrase && deleteWidgetPhrase)
      DeleteChar(IP);
    phrase->fNumChars = 0;
  }
  else if (IP < phrase->fCharPos + phrase->fNumChars)
    phrase->fNumChars = IP - phrase->fCharPos;
}

#ifdef INDEX
static TCurrency gSrcCurrency;
static TCurrency gDestCurrency;
#endif

// ------------------------------------------------------------------------
void _TTextStructure::MovePhrase(PPhrase pphr, TCharPos IP, TTextStructure newStruct)
{
  TPhrase phrase;

  memcpy(&phrase, pphr, sizeof(TPhrase));
  if (IP <= phrase.fCharPos)
  {
    int newIdx;

    phrase.fCharPos -= IP;
    newIdx = newStruct->Insert(&phrase);
#ifdef INDEX
    if (phrase.fKind == kIndexRefPhrase)
      newStruct->ResetIndexRef(PPhrase(newStruct->At(newIdx)),
                           Curr2HomeCurr(pphr, gSrcCurrency), gDestCurrency);
#endif
  }
#if !defined TABLES || defined NETWP
  else if (IP - (phrase.fKind == kTextPhrase) < phrase.fCharPos + phrase.fNumChars)
                                     // 30/09/94 [22030] split text phrases over to new para
#else
  else if (IP < phrase.fCharPos + phrase.fNumChars)
#endif
  {
    phrase.fNumChars += phrase.fCharPos - IP;      // 17/09/90 add charpos
    phrase.fCharPos = 0;
    newStruct->Insert(&phrase);
  }
}

// ------------------------------------------------------------------------
void _TTextStructure::UpdateWidgetParents(TCurrency sourceCurrency, TCurrency newParent)
{
  for (int i = 1; i <= GetSize(); i++)
  {
    PPhrase phrase = PPhrase(At(i));

    if (phrase->fKind == kWidgetPhrase
#ifdef FN
               || phrase->fKind == kNotePhrase
#endif
                )
    {
      TStructure structure = GetStructureReadWrite(phrase->tag.fRecNum);

#ifdef FN
       // 14/06/93 [20938] sort out reference from footnote to para before calling GetOrder
      if (phrase->fKind == kNotePhrase)
        structure->ProtoInit(newParent);
      else
#endif
        structure->fParent = newParent;
    }
//#ifdef INDEX
//    else if (phrase->fKind == kIndexRefPhrase && sourceCurrency != newParent)
//    {
//      ResetIndexRef(phrase, sourceCurrency, newParent);
//    }
//#endif
  }
}

// ------------------------------------------------------------------------
int _TTextStructure::AtEnds(TCursorNode cursorNode)
{
  if (TTextCursor(cursorNode)->GetCharPos() == 0)
    return -1;
  if (TTextCursor(cursorNode)->GetCharPos() >= fCount - 1)
    return 1;
  return 0;
}

// ------------------------------------------------------------------------
int _TTextStructure::Split(TCursorNode cursorNode, TCurrency &newStart,
                                 TCurrency &newEnd, bool keepEmptyStart)
{
  TTextCursor textCursor;
  TTextEdge edge;
  volatile TTextStructure newStruct;
  TDiscObject newRecord;
  TCharPos IP;
  bool deleteWidgetPhrase;
  int delPhrase;
  bool endGone;
  bool redoCursor = FALSE;  // 10/02/94 common up cursor reset
  FailInfo fi;

  newStruct = NULL;
  textCursor = TTextCursor(cursorNode);
  textCursor->GetEdge(edge);
  delPhrase = FindDeletionPhrase();
  if (fLinkStruct == 0 && delPhrase > 0)
  {
    PPhrase phrase = PPhrase(At(delPhrase));
    endGone = phrase->fCharPos + phrase->fNumChars >= fCount - 1;
  }
  else
    endGone = FALSE;

  if (fLinkStruct != 0)
  {
    newStart = textCursor->fCurrency;
    if (fLinkStruct > 0)
    {
      newEnd = fLinkStruct;
      newStruct = TTextStructure(GetStructureReadWrite(fLinkStruct));
      // fLinkStruct.cgf_31.fRecnum = (keepEmptyStart ? -2: -1);     // 07/10/93
      fLinkStruct = Curr_Set(keepEmptyStart ? -2 : -1, Curr_fType(fLinkStruct));
      PPhrase(At(delPhrase))->fNumChars--;
    }                                     
    else
    {
      newEnd = fDocument->NewCurrency(kTextStruct, newRecord);
      newStruct = TTextStructure(newRecord);
      newStruct->fStyle = fStyle;
      newStruct->fChanges = fChanges;
      newStruct->fParent = fParent;
      newStruct->InsertChar(chReturn, 0);
      fLinkStruct = Curr_Set(-1, 0);
    }
    redoCursor = TRUE;
  }
  // 19/10/93 [21091] if selection covers both start need to do end test first
  // ... otherwise fLinkStruct is not set and an Undo will try to link this to next para
  else if ((textCursor->GetCharPos() >= fCount - 1 || endGone) && !keepEmptyStart)
  {
    newStart = textCursor->fCurrency;
    newEnd = 0;
    fLinkStruct = Curr_Set(-2, Curr_fType(fLinkStruct));
  }
  // 19/10/93 [21091] test moved down after end test
  else if (edge.fCharPos == 0 && !keepEmptyStart)
  {
    newStart = 0;
    newEnd = textCursor->fCurrency;
  }
  else
  {
    CatchFailures(&fi);
    newStart = textCursor->fCurrency;
    newEnd = fDocument->NewCurrency(kTextStruct, newRecord);
    newStruct = TTextStructure(newRecord);
    newStruct->fStyle = fStyle;
    newStruct->fChanges = fChanges;
    newStruct->fParent = fParent;
#if !defined TABLES || defined NETWP
#else
    // 30/09/94 [22030] force paras into splitting text phrases
    if (textCursor->GetCharPos() >= fCount - 1)
    {
      newStart = 0;           //25/04/91
      newStruct->InsertChar(chReturn, 0);
    }
    else
#endif
    {
      // previously BuildNewEnd() local procedure
      {
        Size numToMove;
        TCursorNode widgetNode = NULL;
        int widgetPhraseNum;

        IP = textCursor->GetCharPos();
        widgetPhraseNum = FindPhrase(IP /* 02/04/92 , kWidgetPhrase */);
        if (widgetPhraseNum > 0)
        {
          widgetNode = textCursor->GetNext();
          if (widgetNode == 0)
            widgetPhraseNum = 0;
          else
            IP++;                  // 12/02/91 was always done
        }
        numToMove = fCount - IP;
        ChangeHandleSize(&(newStruct->fPtrToArray), numToMove);
        FailSpaceIsLow();
        memcpy(TextStart(newStruct), TextStart(this) + IP, numToMove);
        newStruct->fCount = numToMove;
        deleteWidgetPhrase = FALSE;
#ifdef INDEX
        gSrcCurrency = newStart;
        gDestCurrency = newEnd;
#endif
        Each(this, (DoToItem)_TTextStructure::MovePhrase, IP, newStruct);
#if !defined TABLES || defined NETWP
        newStruct->JoinPhrases();  // 25/10/94 [22030]
#endif
        if (widgetPhraseNum > 0)
        {
          // previously SplitWidget() local procedure
          TCurrency startWidget;
          TCurrency endWidget;
          TStructure widget;
          TPhrase widgetPhrase;

          Get(widgetPhraseNum, &widgetPhrase);
          if (widgetNode != NULL)
          {
            widget = GetStructureReadWrite(widgetPhrase.tag.fRecNum);
            widget->Split(widgetNode, startWidget, endWidget, keepEmptyStart);
            if ((startWidget == 0) || (endWidget > 0))
            {
              deleteWidgetPhrase = (startWidget == 0);

              widgetPhrase.fCharPos = 0;
              widgetPhrase.fNumChars = 0;
              widgetPhrase.fKind = kWidgetPhrase;
              widgetPhrase.tag.fRecNum = endWidget;

              newStruct->Insert(&widgetPhrase);
              newStruct->InsertChar(chWidget, 0);
              newStruct->UpdatePhrases(0, 1, FALSE, FALSE); // 23/09/92 extra param
              if (!deleteWidgetPhrase)
                newStruct->NewEditPhrase(0, 1, FALSE);
              else
                IP --;
            }
          }
          else
          {
            deleteWidgetPhrase = TRUE;
            widgetPhrase.fCharPos = 0;
            widgetPhrase.fNumChars = 0;
            newStruct->Insert(&widgetPhrase);
            newStruct->InsertChar(chWidget, 0);
            newStruct->UpdatePhrases(0, 1, FALSE, FALSE); // 23/09/92 extra param
            IP --;
          }
        }
        FailSpaceIsLow();
      }
      // end of BuildNewEnd() local procedure

      // previously BuildNewStart() local procedure
      {
        int insPhrase1;
        // int delPhrase;

        ChangeHandleSize(&fPtrToArray, -(fCount - IP));
        fCount = IP;
        Each(this, (DoToItem)_TTextStructure::ResetPhrase, IP, deleteWidgetPhrase);
#if !defined TABLES || defined NETWP
        DeleteEmptyPhrases(IP > 0 ? kAnyPhrase : kTextPhrase);
                  // 30/09/94 [22030] press return at start of line with emphasis
#else
        DeleteEmptyPhrases(kAnyPhrase);
#endif
        InsertChar(chReturn, IP);
        insPhrase1 = FindInsertionPhrase();
        if (insPhrase1 == 0)
          NewEditPhrase(IP, 1, FALSE);
        else
          ChangePhraseLen(insPhrase1, 1);
      }
      // end of local proc BuildNewStart...
      newStruct->UpdateWidgetParents(newStart, newEnd);
    }
    redoCursor = keepEmptyStart;
    Success(&fi);
  }
  if (redoCursor)      // 10/02/94 common up 2 cursor reset blocks
  {
    edge.fCharPos = 0;
    edge.fPixelPos = 0;
    edge.fPartNum = 1;

    textCursor->fIdentifier = kNewCursor;
    textCursor->SetEdge(edge);
    textCursor->fCurrency = newEnd;
  }
  return 0;

// ++++++++++ exception handler ++++++++++++++
Rescue:
  if (newStruct != NULL)
    fDocument->DeleteCurrency(newEnd);
  newStart = 0;
  newEnd = 0;
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TTextStructure::CopyPhrase(PPhrase pphr)
{
  TPhrase phrase;
  int newIdx;

  memcpy(&phrase, pphr, sizeof(TPhrase));
  phrase.fCharPos += fCount;
  newIdx = Insert(&phrase);
#ifdef INDEX
  if (phrase.fKind == kIndexRefPhrase)
  {
    TTextStructure textToJoin = TTextStructure(GetStructureReadWrite(gSrcCurrency));
    ResetIndexRef(PPhrase(At(newIdx)), textToJoin->Curr2HomeCurr(pphr, gSrcCurrency),
                                                                       gDestCurrency);
  }
#endif
}

// ------------------------------------------------------------------------
// 21/8/92
bool _TTextStructure::DoJoin(TCurrency myCurrency, TCurrency currencyToJoin)
{
  FailInfo fi;
  volatile TTextStructure textToJoin;
  volatile bool gotSpace;
  int lastPhraseIndex;
//  char ch;
  int incr = GetChar(fCount - 1 /*, ch*/) == chReturn? 1 : 0;

  gotSpace = FALSE;
  textToJoin = NULL;
  CatchFailures(&fi);
  textToJoin = TTextStructure(GetStructureReadWrite(currencyToJoin));
  ChangeHandleSize(&fPtrToArray, textToJoin->fCount - incr);
  gotSpace = TRUE;
// 05/08/92 it always crashes if this fails - so take our chances:  FailSpaceIsLow();
  memcpy(TextStart(this) + fCount - incr, TextStart(textToJoin), textToJoin->fCount);
  lastPhraseIndex = GetSize();
#ifdef INDEX
  gSrcCurrency = currencyToJoin;
  gDestCurrency = myCurrency;
#endif
  textToJoin->Each(this, (DoToItem)_TTextStructure::CopyPhrase);
  fCount += textToJoin->fCount - incr;
  Success(&fi);
  textToJoin->UpdateWidgetParents(currencyToJoin, myCurrency);      // 14/05/91

  fLinkStruct  = 0;
  // 23/06/93 [20951] Commit(myCurrency, NULL, NULL, NULL, FALSE);
  return(TRUE);
// +++++++++++++++++++ EXCEPTION HANDLER ++++++++++++++++++
Rescue:
  if (gotSpace)
    ChangeHandleSize(&fPtrToArray, -textToJoin->fCount);
  return(FALSE);
}


// ------------------------------------------------------------------------
bool _TTextStructure::CanJoin(TCurrency item)
{
  return((Curr_fType(item) == kTextStruct));
}


// ------------------------------------------------------------------------
TRunType _TTextStructure::GetTextRun(TCharPos itsCharPos, Size &itsNumChars, TCurrency &itsObject)  // , TRunType &itsRunType)
{
  TPhrase phrase;
  int phraseNum;
  TCharPos nextEndPos;
  TRunType multiLine = kMarkCh;

  if (gLastCh == gMarkCh || (multiLine = kBeginStyle, gLastCh < 32))
  {
    if (gLastCh == chReturn)
      multiLine = kEOT;
    if (gLastCh == chTab)
      multiLine = kTabField;
    if (gLastCh == chLineFeed)
      multiLine = kEOL;

    if (multiLine != kBeginStyle)
    {
      itsNumChars = 0;
      itsObject = 0;
      gLastCh = chUndef;
      gMarkCh = chNoMark;
      gPhraseIdx = -1;
      // itsRunType = multiLine;
      return multiLine;
    }
  }
  if (gPhraseIdx < 0)
  {
    phraseNum = GetPhraseAt(itsCharPos, phrase, kAnyPhrase); // extra param
    gActivePhrase.fCurrency = 0;            // [20847] 27/4/93 must be null if gPhraseIdx -ve
  }
  else
    // 18/02/92 for 2 widgets in an emphasis
    while (phraseNum = GetPhrase(gPhraseIdx + 1, phrase),
           phraseNum > 0 && (phrase.fCharPos + phrase.fNumChars <= itsCharPos
#ifdef INDEX
           || phrase.fKind == kIndexRefPhrase
#endif
           ))
       gPhraseIdx++;

  multiLine = kMacro;    // 25/10/91
  // 04/07/91 moved out of above clause for wd wrap of phrase containing pic
  if ((phraseNum > 0) && (itsCharPos > phrase.fCharPos))
  {
    phrase.fNumChars -= (itsCharPos - phrase.fCharPos);
    phrase.fCharPos = itsCharPos;
    if (phrase.fNumChars <= 0)
      phraseNum = 0;
    else
      multiLine = kMacroOVL;    // 25/10/91
  }

  // 24/01/91 moved from end
  if (gActivePhrase.fCurrency != 0)
  {
    if (gActivePhrase.fEndPos == itsCharPos)
    {
      itsNumChars = 0;
      itsObject = gActivePhrase.fCurrency;
      gActivePhrase.fCurrency = 0;        // 24/01/91 gNullCurrency;
      // itsRunType = kEndStyle;
      return kEndStyle;
    }
  }

  if ((phraseNum > 0) && (phrase.fCharPos == itsCharPos))
  {
    TRunType itsRunType;

    gPhraseIdx = phraseNum; // 02/05/90
    if (phrase.fKind == kTextPhrase)
    {
      gActivePhrase.fCurrency = (phrase.tag.txt.fStyle << 16) + phrase.tag.txt.fChanges;
      gActivePhrase.fNumChars = phrase.fNumChars;
      gActivePhrase.fEndPos = itsCharPos + gActivePhrase.fNumChars;
      itsObject = gActivePhrase.fCurrency;

      itsNumChars = 0;
      itsRunType = kBeginStyle;
    }
    else
    {
      itsNumChars = phrase.fNumChars;
      if (phrase.fKind == kWidgetPhrase)      // 17/09/90 widget case
      {
        itsObject = phrase.tag.fRecNum;
        itsRunType = kWidget;
      }
#ifdef FN
      else if (phrase.fKind == kNotePhrase)
      {
        itsObject = phrase.tag.fRecNum;
        itsRunType = kNote;
      }
#endif
      else                                    // 17/09/90 macro case
      {
        itsObject =                    // MMerge 13/5/92
          (phrase.tag.macro.fMacroType << 16) + phrase.tag.macro.fMergeField;
        itsRunType = multiLine;               // 25/10/91 from kMacro
      }
    }
    return itsRunType;
  }

  if (gActivePhrase.fCurrency != 0)
  {
    nextEndPos = gActivePhrase.fEndPos;
    if (phraseNum == 0)
    {
      phrase.fCharPos = nextEndPos;
      phraseNum = 1;
    }
  }
  else
    nextEndPos = MAXLONGINT;

  if (phraseNum > 0)
    itsNumChars = Min(nextEndPos, phrase.fCharPos) - itsCharPos;
  else
    itsNumChars = MAXLONGINT;
  // itsRunType = kMeasureRun;
  return kMeasureRun;
}


// ------------------------------------------------------------------------
int _TTextStructure::SetFontAndFace(bool drawing)
{
  register TStyle *cgf_84 = &gStyle;
  int backwards = TextFont(PFontStyle(&cgf_84->fcTextFont));

  TextColour(cgf_84->fcColour, drawing);
  return backwards;
}

// ------------------------------------------------------------------------
bool _TTextStructure::ClickOnce(int &pixelOffset, Fixed slop, int eol, TCharPos &charPos,
         Size numChars, int numOfSpaces, int partWidth)
{
  CharsPtr charPtr;
  Handle buffer;
  bool leftSide;

  if (!SetFontAndFace(FALSE))
    partWidth = 0;   // if backwards text, need to measure from rhs of part
  charPtr = GetBuffer(charPos, numChars, eol, buffer, NULL);
                                    // 27/10/94 [23013] &numChars);
  //if (IsHyphen(eol))
  //  numChars -= eol;
  pixelOffset -= partWidth;
  charPos = Pixel2Char(charPtr, numChars, slop, pixelOffset,
                                               numOfSpaces, leftSide, pixelOffset);
  pixelOffset += partWidth;
  FreeBuffer(buffer);
  return leftSide;
}


// ------------------------------------------------------------------------
static int PartToLine(TTextFormat para, int partNum)
{
  int pn;
  int ln = 0;

  for (pn = 1; pn <= partNum; pn++)
  {
    if (PLinePart(para->At(pn))->fEOL <= kLineBreak)
      ln++;
  }        
  return ln;
}

// ------------------------------------------------------------------------
// 08/11/94 static 
int LineToPart(TTextFormat para, int lineNum)
{
  int pn;

  for (pn = 1; pn <= para->fSize; pn++)
  {
    if (PLinePart(para->At(pn))->fEOL <= kLineBreak)
    {
      lineNum--;
      if (lineNum == 0)
        return pn;
    }
  }        
  return para->fSize;
}


// ------------------------------------------------------------------------
bool _TTextStructure::Fit(TCharPos itsFirstChar, int eol, Size &itsNumChars,
                                     Size &itsNumSpaces, Fixed &itsWidth)
{
  // 20/10/94 new version using return from GetBuffer
  CharsPtr charPtr;
  Handle buffer;
  int numCharsRqd;
  int saveNumReq = itsNumChars;
  int i;
  register char *p;

#ifdef TRACE
  Assert(itsNumChars >= 0, 198);
#endif
  SetFontAndFace(FALSE);

  charPtr = GetBuffer(itsFirstChar, itsNumChars, eol, buffer, &itsNumChars);

  // do a pre-scan searching for a breaking char
  // 13/01/94 limit raised from 200 to 400 and fast path loop
  p = charPtr;
  {
#define SCANLIMIT 400
    char *pp = p + Min(SCANLIMIT, itsNumChars);
    int savedCh = *pp;

    // 01/09/94 [22022] if (GetHandleSize(buffer) - itsFirstChar > SCANLIMIT)
    // test can access off end of handle/heap as itsFirstChar is a character offset
    // and there may be phrases before the chars at the start of the handle

    *pp = 0;
      
    if (gMarkCh < 32)   // do faster 3 instruction loop
    {
      for (; *(p++) >= 32; ) {}
      p--;
    }
    else
    {
      for (; *p >= 32 && *p != gMarkCh; p++) {}
    }
    *pp = savedCh;
  }
  numCharsRqd = p - charPtr;
  itsNumChars = FitText(charPtr, numCharsRqd, itsWidth);

  gLastCh = charPtr[itsNumChars];

  // count number of spaces before break
  itsNumSpaces = 0;
  for (i = 0; i < itsNumChars; i++)
    if (charPtr[i] == chSpace)
      itsNumSpaces++;

  // 29/01/93 [20603] uses charPtr which points into buffer in U/case: FreeBuffer(buffer);
  if (itsNumChars == saveNumReq)          // 25/09/90 do not absorb cr
    gLastCh = charPtr[itsNumChars - 1];
  else if (gLastCh == chReturn || gLastCh == chLineFeed)
    itsNumChars++;          // Cr & Lf are included in the last run
  FreeBuffer(buffer);       // 29/01/93 [20603] moved after charPtr use
  return itsNumChars < numCharsRqd;
}

#ifdef INDEX
static gBgCol = 15;
#endif

// ------------------------------------------------------------------------
void _TTextStructure::Draw(TLinePart &linePart, Rect &extent, Rect &rubOut)
{
  CharsPtr charPtr;
  Handle buffer;
  Size itsNumChars = linePart.fNumChars;  // 27/07/92
  int eol = linePart.fEOL;                // 27/07/92
  int justify = gStyle.fcSpaceExtra;   // from gStyle.fcAlignment != kAlignLeft for backwards

  // done in TFormat::Draw SetFontAndFace(TRUE);

  charPtr = GetBuffer(linePart.fCharPos, itsNumChars, eol, buffer, &itsNumChars);
  //if (IsHyphen(eol))
  //  itsNumChars -= eol;

  // 27/07/92 fudge to strip the trailing space from the end of string
  // because ink-jet printer driver justifies preceeding text over it
  if (gPrinting && justify)
  {
    int offset;

    for (offset = itsNumChars; offset > 0 && charPtr[offset - 1] == ' '; offset--) {}
    if (offset < itsNumChars)
    {
      // when printing there is no zooming so hopefully OK to use format values
      extent.right = extent.left +
        Char2Pixel(charPtr, itsNumChars, linePart.fSlop, offset, 0, 
                 linePart.tag.cgf_35.fNumSpaces);  // must be a text or macro line part
      itsNumChars = offset;
    }
  }
#ifdef INDEX
  if (gShowIndexEntries)
  {
    PPhrase aPhrase;
    PPhrase endP;
    int leftPos = linePart.fCharPos;
    int rightPos = leftPos + itsNumChars;
    int indexFound = FALSE;
    int zoomedSlop = justify * linePart.tag.cgf_35.fNumSpaces * 10;

    for (aPhrase = PPhrase((char *)fPtrToArray + fFirstOffset), endP = aPhrase + fSize;
                                                          aPhrase < endP; aPhrase++)
      if (aPhrase->fKind == kIndexRefPhrase)
      {
        int amt = aPhrase->tag.indexRef.fOtherEnd;
        char *p;
        int start;
        Rect partExtent;
        Rect rub;
        int tLen;
        int phrasePos = aPhrase->fCharPos;

        if (phrasePos >= gDelPos)
        {
          phrasePos -= gDelCount;
          if (phrasePos < gDelPos)
            continue;                 // ignore if hidden
        }
        indexFound = TRUE;
        if (phrasePos + amt <= leftPos ||
                        aPhrase->tag.indexRef.fIndexRec == fDocument->fBookmarkRec)
          continue;
        if (phrasePos >= rightPos)
          break;
        MoveRect(partExtent, extent);
        MoveRect(rub, rubOut);
        p = charPtr;
        start = phrasePos - leftPos;
        if (start > 0)
        {
          tLen = Char2Pixel(p, itsNumChars, zoomedSlop /* linePart.fSlop */, start, 0,
                                            linePart.tag.cgf_35.fNumSpaces);
          partExtent.right = partExtent.left + tLen;
          extent.left += tLen;
          rub.right = partExtent.right;
          rubOut.left = rub.right;
          DrawText(p, start, partExtent, rub, gStyle.fcAscent, justify);
          MoveRect(partExtent, extent);
          MoveRect(rub, rubOut);
          p += start;
          leftPos += start;
        }
        else
        {
          amt += start;
          start = 0;
        }
        if (amt > itsNumChars - start)
          amt = itsNumChars - start;
        tLen = Char2Pixel(p, itsNumChars, zoomedSlop /* linePart.fSlop */, amt, 0,
                                            linePart.tag.cgf_35.fNumSpaces);
        partExtent.right = partExtent.left + tLen;
        rub.right = Min(rubOut.right, partExtent.right + extent.bottom - extent.top);
        rubOut.left = rub.right;
        rub.left = partExtent.right;
        if (gInUpdate)
        {
          EraseRect(rub);
          BackPat(gBgCol);   // ready for rub out
        }
        else
        {
          PenPat(gBgCol);
          PaintRect(partExtent);
        }
        TextColour(gStyle.fcColour, gBgCol);     // coloured bg
        extent.left += tLen;
        MoveRect(rub, partExtent);
        DrawText(p, amt, partExtent, rub, gStyle.fcAscent, justify);
        PenNormal();
        leftPos += amt;
        itsNumChars = rightPos - leftPos;
        charPtr = p + amt;
        TextColour(gStyle.fcColour, TRUE);          // normal bg
      }
    gShowIndexEntries &= indexFound;  // turn off if none in this view
  }
#endif
  if (itsNumChars >= 0)         // [26020] itsNumChars sometimes ends up -ve!?
    DrawText(charPtr, itsNumChars, extent, rubOut, gStyle.fcAscent, justify);
  FreeBuffer(buffer);
}

#ifdef FN
// ------------------------------------------------------------------------
bool _TTextStructure::DoSearchFootnote(PPhrase phr, long searchStart,
       long searchEnd, TSelection hitSelection, char *findText, bool wholeWord,
       bool caseSensitive, bool searchBackwards, bool changeAll)
{
  if (phr->fKind == kNotePhrase)
  {
    if (phr->fCharPos >= searchStart && phr->fCharPos < searchEnd)
    {
      TCurrency noteCurrency = phr->tag.fRecNum;
      TStructure subStruct = GetStructureReadOnly(noteCurrency);

      if (subStruct->DoSearch(noteCurrency, NULL, hitSelection, findText, wholeWord,
              caseSensitive, searchBackwards, changeAll))
        return TRUE;
    }
  }
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
bool _TTextStructure::DoSearch(TCurrency currency, TCursorNode startPoint,
                   TSelection hitSelection, char* findText, bool wholeWord,
                   bool caseSensitive, bool searchBackwards, bool changeAll)
{
  long startSearch;
  long endSearch, endSearch1;
  TTextCursor node;
  Handle buffer;
  Ptr charPtr;
  bool found;
  // bool outOfLoop;
#ifdef FN
  long startSearch1;
#endif
  OffsetTable offsets;

  FailIfEscape();                    // 04/06/91
  endSearch = (searchBackwards ? 0 : fCount);
  startSearch = (startPoint != NULL ? TTextCursor(startPoint)->GetCharPos() :
                             (searchBackwards ? fCount : 0));
#ifdef FN
  startSearch1 = startSearch;
#endif

  if (startSearch == 0)
    UpdateProgress();           // 17/09/90
  SetTextGlobals(this);
  endSearch1 = endSearch; // 25/07/90
  charPtr = GetBuffer(0, MAXLONGINT, kLineBreakMixed, buffer, NULL);  // 24/10/90 param

  // 25/07/90 - next loop is new
  // outOfLoop = FALSE;
  do {
    found = QuickFind(findText, charPtr, startSearch, endSearch,
                      caseSensitive, !searchBackwards);
    if (!found || !wholeWord)
      break; // outOfLoop = TRUE;
    if (startSearch == endSearch) // 08/04/94 [20611] stop loop on empty word find
    {
      found = FALSE;
      break;
    }
    FindWord((char*) charPtr, fCount, startSearch, TRUE, NULL, &offsets);
    if (offsets.offFirst == startSearch && offsets.offSecond == endSearch)
      break;  // exit loop with found = TRUE;
    if (searchBackwards)
      startSearch--;
    else
      startSearch = endSearch;
    endSearch = endSearch1;
  } while (TRUE);   // (!outOfLoop);

  FreeBuffer(buffer);  // 26/09/94

#ifdef FN
  {
    // 27/09/94 [22029] search through the para looking at notes between start and any match
    int oldState = fDocument->LockCurrency(currency, TRUE);
    int fnFound =  (searchBackwards ?
        LastThat(this, (TestItem)_TTextStructure::DoSearchFootnote, found ? endSearch : 0,
                   startSearch1, hitSelection, findText, wholeWord,
                   caseSensitive, searchBackwards, changeAll):
        FirstThat(this, (TestItem)_TTextStructure::DoSearchFootnote, startSearch1,
                   found ? endSearch : fCount, hitSelection, findText, wholeWord,
                   caseSensitive, searchBackwards, changeAll));

    fDocument->LockCurrency(currency, oldState);
    if (fnFound)
      return TRUE;
  }
#endif

  if (found)
  {
    TMainView mainView = fDocument->ActiveMainView();

    if (startSearch == endSearch) // 08/04/94 [20612] stop ending up with invisible seln
      hitSelection->InitialCursor(mainView, currency, 0);
    else
    {
      hitSelection->InitialSelection(mainView, currency, currency);
      hitSelection->SetTarget();
      node = TTextCursor(hitSelection->GetActiveTarget());
      node->SetCharPos(endSearch);
    }
    node = TTextCursor(hitSelection->GetAnchorTarget());
    node->SetCharPos(startSearch);
#ifdef TRACE
    Assert(fTempFlag == 0 || changeAll, 990);  // following assignment is waste of time.
            // It will be reset later by DoReplace, & it is wrong if set and !changeAll
#endif
    fTempFlag = changeAll;
  }

  // moved up: FreeBuffer(buffer);
  return found;
}

// ------------------------------------------------------------------------
void _TTextStructure::DoGetSelectedText(TCharPos cp1, TCharPos cp2, char *selectedText)
{
  int currLen = strlen(selectedText);
  int numToMove = Min(254 - currLen, cp2 - cp1);

#ifdef INDEX
  char *buffer;
  char *charPtr;

  SetTextGlobals(this);
  charPtr = GetBuffer(cp1, numToMove, kLineBreakMixed, buffer, NULL);
  selectedText = (char *)memcpy(selectedText + currLen, charPtr, numToMove);
  FreeBuffer(buffer);
#else
  selectedText = (char *)memcpy(selectedText + currLen, TextStart(this) + cp1, numToMove);
#endif
  selectedText[numToMove] = 0;
}


// ------------------------------------------------------------------------
void _TTextStructure::GetSelectedText(TCurrency currency, TCursorNode anchor,
                                    TCursorNode activeEnd, char* selectedText)
{
  // (much!) faster version when nothing selected
  TCharPos cp1, cp2;

  if (anchor == NULL)
    cp1 = 0;
  else
    cp1 = TTextCursor(anchor)->GetCharPos();
  if (activeEnd == NULL)
    cp2 = fCount - 1; // MMerge 13/5/92 -- added - 1, actually was a bug
  else
    cp2 = TTextCursor(activeEnd)->GetCharPos();
  if (cp2 > cp1)
    DoGetSelectedText(cp1, cp2, selectedText);
}


// ------------------------------------------------------------------------
void _TTextStructure::DoReplace(TCurrency currency, TCursorNode anchor,
              TCursorNode activeEnd, char* replaceText, bool replaceAll)
{
  long textLen, hitLen;
  TCharPos anchorCP, activeEndCP;
  bool atCR;

  FailSpaceIsLow();
  anchorCP = TTextCursor(anchor)->GetCharPos();
  activeEndCP = TTextCursor(activeEnd)->GetCharPos();
  atCR = (activeEndCP == fCount);
  activeEndCP -= atCR;                  // 20/11/90 stop it removing CR
  textLen = strlen(replaceText);

  if (textLen > 0)  // 29/05/90 if.. new
  {
    InsertSlice(fOffset + activeEndCP, replaceText, textLen);
//    Munger(&fPtrToArray, fOffset + activeEndCP, NULL, 0, replaceText, textLen);
    fCount += textLen;
    NewEditPhrase(activeEndCP, textLen, FALSE);
    UpdatePhrases(activeEndCP /* + 1 16/09/92 */, textLen, FALSE, FALSE); // 23/09/92 extra param
  }
  hitLen = activeEndCP - anchorCP;
  if (hitLen > 0)
    NewEditPhrase(anchorCP, hitLen, TRUE);
  activeEndCP = anchorCP + textLen + atCR;       // 20/11/90 to compensate
  TTextCursor(activeEnd)->SetCharPos(activeEndCP);
  if (replaceAll)
    Commit(currency, NULL, NULL, NULL, FALSE);       // 05/03/91
  MarkForReformatChgs(currency);  // 13/06/95 [26016] lock record so fTempflag not lost
  // fTempFlag = TRUE; // 05/03/91 moved
  // SetChanged(currency, gNullCurrency, TRUE);             // 16/06/91
}


// ------------------------------------------------------------------------
TCharPos _TTextStructure::SkipLeadingSpaces(TCharPos itsFirstChar)
{
  while (/* 13/01/94 itsNumChars > 0 && */ GetChar(itsFirstChar) == chSpace)
  {
    itsFirstChar++;
    //13/01/94 itsNumChars --;
  }
  return itsFirstChar;
}


// ------------------------------------------------------------------------
void _TTextStructure::InsertChar(char itsChar, TCharPos itsInsertion)
{
  char *p;

  if (fFree == 0)
  {
    ChangeHandleSize(&fPtrToArray, kTextIncrement);
    fFree = kTextIncrement;
  }
  p = TextStart(this) + itsInsertion;
#ifdef TRACE
  Assert(fCount >= itsInsertion, 717);
#endif
  memmove(p + 1, p, fCount - itsInsertion);
  p[0] = itsChar;
  fFree--;
  fCount++;
  if (itsChar == chReturn && fFree > 0)          // 17/09/90
  {
    ChangeHandleSize(&fPtrToArray, -fFree);
    fFree = 0;
  }
}


// ------------------------------------------------------------------------
void _TTextStructure::DeleteChar(TCharPos itsInsertion)
{
  DeleteText(itsInsertion, 1);
//  Munger(&fPtrToArray, fOffset + itsInsertion, 0, 1, Ptr(-1), 0);
//  fCount--;
}


// ------------------------------------------------------------------------
void _TTextStructure::DeleteText(TCharPos itsFirstChar, Size numToDelete)
{
  fCount -= numToDelete;
  DeleteSlice(fOffset + itsFirstChar, numToDelete);
//  Munger(&fPtrToArray, fOffset + itsFirstChar, 0, numToDelete, Ptr(-1), 0);
}

// #define kFieldDelims [chTab, chLineFeed, chReturn]

// ------------------------------------------------------------------------
//void _TTextStructure::ScanTabField(TCharPos itsFirstChar, char itsMark, TCharPos &endOfField)
//{
//  int ch;

//  endOfField = itsFirstChar;
//  do {
//    endOfField ++;
//    ch = GetChar(endOfField /*, ch*/);
//  } while ((ch != itsMark) && ((ch != chTab) || (ch != chLineFeed) || (ch != chReturn)));
//}


#ifdef DASHES
// ------------------------------------------------------------------------
static bool TestForHyph(char *testChar)
// 09/07/92 new
{
  int ch = *testChar;

  return (ch == '-' || (ch >= 0x97 && ch <= 0x99));
}
#endif

// ------------------------------------------------------------------------
int _TTextStructure::FindWordWrap(TCharPos lineStart, TCharPos charPos, int &charCount)
{
  // 20/10/94 another new version for hyphenation
  char *charPtr;
  Handle buffer;
  int count;
  OffsetTable offsets;
  int hyphenation;

  // 20/10/94 done by caller: charPos -= lineStart;
  count = charPos + 32;
  charPtr = GetBuffer(lineStart, count, kLineBreakMixed, buffer, NULL);
  FindWord(charPtr, count, charPos, TRUE, Ptr(-1), &offsets);
  count = offsets.offFirst;
  hyphenation = kLineBreak;
#ifdef DASHES
  if (gStyle.fcHyphenate && gStyle.fcLanguage != kNoLanguage)
  {
    char *first = charPtr + count;
    char *last = charPtr + offsets.offSecond - 1;

    if ((count > 0 && TestForHyph(first - 1)) || TestForHyph(last + 1))
    {
      // 29/11/91 do not attempt to hyphenate words already hyphenated
    }
    else
    {
      int limit;
      int rank = 2;   // should be 2 or at most 3!
      int bestOffset = -1;
      int offset;

      fDocument->Hyphenate(gStyle.fcLanguage, first, last);

      // look at hyphenations before total of chars that fitted
      limit = charPos - count - 2;
      for (int n = 0; n < hyph_index && (offset = hyphens[n].offset) <= limit; n++)
      {
        int hyphenVal = hyphens[n].value;

        if ((hyphenVal & 0x80) == 0 &&            // ignore if questionable
             ((hyphenVal & 0x40) == 0 || offset < limit))  // or german double over end
        {
          if ((hyphenVal & 0x0f) <= (rank & 0x0f))
          {
            rank = hyphenVal;
            bestOffset = offset;
          }
        }
      }
      if (bestOffset >= 0)         // a hyphenation point was found with rank 2 or better
      {
        count = offsets.offFirst + bestOffset + 1;
        // 20/10/94 [23010] test for German ck hyphenation for k-k
        if ((rank & 0x40) != 0 || (gStyle.fcLanguage == 7 &&
                   *(charPtr + count - 1) == 'c' && *(charPtr + count) == 'k'))
          hyphenation = kModifiedHyphen;
        else
          hyphenation = kNormalHyphen;
      }
    }
  }
#endif
  FreeBuffer(buffer);
  charCount -= (charPos - count);
  return hyphenation;
}


// ------------------------------------------------------------------------
void _TTextStructure::FindTextSelect(TTextCursor cursor, TCharPos lineStart, TCharPos lineLen, bool rightEdge)
{
  CharsPtr charPtr;
  Handle buffer;
//  bool over32K;
  TCharPos charPos;
  OffsetTable offsets;
  TPhrase phrase;

  if (cursor->fClickCount == 2)
  {
    TCharPos cp; // 21/5/92

    charPos = cursor->GetCharPos();
    // 16/11/92 moved down (see below):    charPos -= lineStart;
    cp = charPos - !cursor->GetLeftSide(); // 21/5/92
 // 21/5/92 added if stmt to deal with macros/notes
    if (GetPhraseAt(cp, phrase, kMacroPhrase) > 0
#ifdef FN
       || GetPhraseAt(cp, phrase, kNotePhrase) > 0
#endif
       )
    {
      offsets.offFirst = phrase.fCharPos;
      offsets.offSecond = phrase.fCharPos + phrase.fNumChars;
    }
    else
    {
      // 23/02/94 pass kLineBreakMixed instead: gStyle.fcTextCaps = kMixedCase;
      charPtr = GetBuffer(lineStart, lineLen, kLineBreakMixed, buffer, NULL);
      FindWord(charPtr, lineLen, charPos - lineStart, cursor->GetLeftSide(), 0, &offsets);
        // 16/11/92 - lineStart (macro on 1st line selected clicking on 2nd, 3rd, etc)

      offsets.offFirst += lineStart;
      offsets.offSecond += lineStart; // 21/5/92
      FreeBuffer(buffer);
    }
  }
  else
  {
    offsets.offFirst = 0;
    offsets.offSecond = (gLinkStruct == NULL ? 0 : gLinkStruct->fCount) +
                fCount /* 26/11/90 - 1 */ - gDelCount;
  }

  // 02/05/90 - this bit new
  if (rightEdge)
    cursor->SetCharPos(offsets.offSecond);
  else
    cursor->SetCharPos(offsets.offFirst);
//  cursor->Set2CharPos(offsets.offFirst, offsets.offSecond);
}

#ifdef SUPER
// ------------------------------------------------------------------------
bool _TTextStructure::CP2Phrase(TCharPos cp, bool bothEnds, TPhrase &phrase)
{
  int pn = fSize;

  if (fLinkStruct != 0)
  {
    SetTextGlobals(this);
    pn += gLinkStruct->fSize;
  }
  while (pn > 0)
  {
    pn = GetPhrase1(pn, phrase, -1);
    if (pn > 0)
    {
      if (phrase.fKind == kTextPhrase &&
          phrase.fCharPos <= cp &&
          cp < phrase.fCharPos + phrase.fNumChars + bothEnds)
        return TRUE;
      pn--;
    }
  }
  return FALSE;
}

#else

// ------------------------------------------------------------------------
bool _TTextStructure::CP2Phrase(TCharPos cp, bool bothEnds, TPhrase &phrase)
{
  int pn = 1;

  while (pn > 0)
  {
    pn = GetPhrase(pn, phrase);
    if (pn > 0)
    {
      // 14/09/90 CharPosInRange: easier to use the 0/1 value of bothEnds
      if (phrase.fKind == kTextPhrase &&  phrase.fCharPos <= cp &&
          cp < phrase.fCharPos + phrase.fNumChars + bothEnds)
        return TRUE;
      pn++;
    }
  }
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
void _TTextStructure::GetSelectionKind(TCursorNode anchor,
          TCursorNode activeEnd, TStyleTypes &kind, int &part, Rect &custom)
{
  TEmphasis *emphasis = (TEmphasis *)&custom;
  // TEmphasis emphasis;
  TPhrase phrase;

  SetTextGlobals(this);
  kind = kText;
  part = 1;
  ClearRect(emphasis->fCustom);
  if (anchor == NULL || activeEnd == NULL)
  {
#ifdef NETWP
    if (anchor != NULL)
      emphasis->tag.fFirstLine = 1;
#endif
    emphasis->tag.fStartPos = GetSelectionStartPos(anchor, activeEnd);
    emphasis->tag.fEndPos = GetSelectionEndPos(anchor, activeEnd);
    if (emphasis->tag.fStartPos == 0 && emphasis->tag.fEndPos == fCount)
      part = -1;
    // else
    //   part = 1;
  }
  else if (TTextCursor(anchor)->IsCursor(activeEnd))
  {
    emphasis->tag.fStartPos = TTextCursor(anchor)->GetCharPos();
    emphasis->tag.fEndPos = emphasis->tag.fStartPos; // 25/07/90
    if (
        (fDocument->fTextHandler->fStyleChanges == NULL ||   // 20/01/94 [21352] !plain
        fDocument->fTextHandler->fStyleCmd != cPlain) &&     // 20/01/94
        CP2Phrase(emphasis->tag.fStartPos, TRUE, phrase))
    {
      if 
#ifdef SUPER
         ((phrase.fCharPos == emphasis->tag.fStartPos &&
             (phrase.fNumChars > 0 || phrase.tag.txt.fStyle == 0)
#else
#if !defined TABLES || defined NETWP
         // 30/09/94 [22030] pick up empty style phrase (should test fKind??? )
         (phrase.fCharPos == emphasis->tag.fStartPos &&
          (phrase.fCharPos > 0 || phrase.fKind != kTextPhrase || phrase.tag.txt.fStyle == 0)
#else
         (phrase.fCharPos == emphasis->tag.fStartPos
#endif
#endif
#ifdef MATHS
          // 25/01/94 || fDocument->IsMathSymbol(phrase.tag.txt.fStyle)
          || fDocument->FontIsSymbol(phrase.tag.txt.fStyle)
          || fDocument->FontIsSymbol(phrase.tag.txt.fChanges)
#endif
         )
      {
        // part = 1;
      }
      else
        part = 2;
    }
    // else
    //   part = 1;
  }
  else
  {
    int count = fCount + (gLinkStruct == NULL ? 0 : gLinkStruct->fCount) - gDelCount;

    emphasis->tag.fStartPos = TTextCursor(anchor)->GetCharPos();
    emphasis->tag.fEndPos = TTextCursor(activeEnd)->GetCharPos();
    if (CP2Phrase(emphasis->tag.fStartPos, FALSE, phrase))
    {
      if (emphasis->tag.fStartPos == phrase.fCharPos &&
                               emphasis->tag.fEndPos == phrase.fCharPos + phrase.fNumChars)
        part = -2;
      else
        part = 2;
    }
    else if (emphasis->tag.fStartPos == 0 && emphasis->tag.fEndPos == count)
      part = -1;
    else
    {
      if (!IsLastNode(activeEnd))                  // if (!activeEnd->IsLast())
        emphasis->tag.fEndPos++;
      // part = 1;
    }
  }
  // MoveRect(custom, emphasis.fCustom);
}


// ------------------------------------------------------------------------
TCurrency _TTextStructure::GetPartStyle(int part, Rect &custom, TCurrency &itsChanges)
{
  TCurrency itsStyle;

  if (part == 1
#ifdef NETWP
      && ((TEmphasis *)&custom)->tag.fFirstLine == 0
#endif
                )
    itsStyle = _TSortedStructure::GetPartStyle(part, custom, itsChanges);
  else
  {
    TPhrase phrase;
    int startPos;
    int endPos;

    SetTextGlobals(this);
    startPos = ((TEmphasis *)&custom)->tag.fStartPos;
    endPos = ((TEmphasis *)&custom)->tag.fEndPos;
    //if (CP2Phrase(endPos, TRUE, phrase) &&
    //          (startPos == endPos || CP2Phrase(startPos, FALSE, phrase)))
    if (CP2Phrase(startPos, startPos == endPos, phrase))
    {
      // 17/07/96 [27034] order of CP2Phrases swapped to extract style from LH (2nd) phrase
      // and bothends set to FALSE so buttons reflect state at start of selection if there is one
      itsChanges = RecToCurrency(phrase.tag.txt.fChanges);
      itsStyle = RecToCurrency(phrase.tag.txt.fStyle);
    }
    else  // 18/11/94 [23015] do not return structure styles for part when no part selected?
          // in the hope that the style set will ignore doubly applies styles
    {
      itsChanges = 0;
      itsStyle = 0;
    }
  }
  return itsStyle;
}

// ------------------------------------------------------------------------
// 29/4/92 new to handle emphasis in GetCompositeStyle properly
void _TTextStructure::GetPartInfo(TCurrency partCurrency, int &part,
                                    Rect &custom)
{
  int pn = 1;
  TPhrase phr;
  TEmphasis *emphasis = (TEmphasis *)&custom;

  SetTextGlobals(this);
  while (pn = GetPhrase(pn, phr), pn > 0)
  {
    if (phr.fKind == kWidgetPhrase && phr.tag.fRecNum == partCurrency)// 6/5/92
    {
      pn = GetPhraseAt(phr.fCharPos, phr, kAnyTextPhrase);  // 23/09/92 from kTextPhrase
      break;
    }
    pn++;
  }
  part = 2;
  if (pn == 0)
  {
    emphasis->tag.fStartPos = MAXINT;
    emphasis->tag.fEndPos = MAXINT;
  }
  else
  {
    emphasis->tag.fStartPos = phr.fCharPos;
    emphasis->tag.fEndPos = phr.fCharPos + phr.fNumChars;
  }
}

#ifdef SPELL
// ------------------------------------------------------------------------
static int FindToken(int &scp, char *cp, char *endPt, char * &token)
{
  for (token = cp + scp; token < endPt && *token <= 0x20; token++, scp++)
  {}
  for (cp = token; cp < endPt && *cp > 0x20; cp++)
  {}
  return cp - token;
}

// ------------------------------------------------------------------------
int _TTextStructure::CheckPhrase(TCurrency currency, int scp, int ecp,
                                   int lang, int &phraseIdx, int start, int limit)
// 23/11/92 checks from scp to ecp; It does this in two bits, the first using language lang,
// the second is done by calling itself to process the phrase following. This following
// phrase will be one representing a language change (i.e. emphasis with language, or macro
// and widget phrases which have no language) searched for starting at phraseIdx. Either
// of these two parts may be empty. This is repeated to the end of the supplied phrase.
{
  char *cp = TextStart(this);
  TMainView view = fDocument->ActiveMainView();

  while (scp < ecp)
  {
    int nextLanguage = kNoLanguage;
    PPhrase phrase;

    // look for a phrase which affects the language
    // phrase will be NULL if no suitable phrase found
    while (phrase = NULL, phraseIdx <= fSize)
    {
      TStyleFormat styleFmt;

      phrase = PPhrase(At(phraseIdx));
      if (phrase->fCharPos >= ecp)
      {
        phrase = NULL;    // it is not within the current scope, so just check to ecp
        break;
      }
      phraseIdx++;
#ifdef INDEX
      if (phrase->fKind == kIndexRefPhrase)
      {
        // ignore these
      }
      else
#endif
      if (phrase->fKind == kTextPhrase)
      {
        if (phrase->tag.txt.fChanges > 0)
        {
          styleFmt = view->GetStyleReadOnly(RecToCurrency(phrase->tag.txt.fChanges));
          if ((styleFmt->fDefined & kLanguage) != 0)
          {
            nextLanguage = styleFmt->fLanguage;
            break;
          }
        }
        if (phrase->tag.txt.fStyle > 0)
        {
          styleFmt = view->GetStyleReadOnly(RecToCurrency(phrase->tag.txt.fStyle));
          if ((styleFmt->fDefined & kLanguage) != 0)
          {
            nextLanguage = styleFmt->fLanguage;
            break;
          }
        }
      }
      else if (phrase->fKind == kEditPhrase) // || phrase->tag.fDeletions)
      {
        // 31/01/94 stop @ end of ins phrase
        // 05/01/95 but not for spurious insertion phrases which loop if limit becomes < ecp
        int newLim = phrase->fCharPos + phrase->fNumChars;

        if (newLim >= ecp)
          limit = newLim;
      }
      else
        break;     // treat macros as no language, widgets have their own language
      // edit phrases should only occur in interactive checking, and only insertions
      // should be in the selection passed to check. These are treated as transparent.
    }

    // spell check up to start of any found phrase, with the paragraph language
    {
      int tokenLen;
      // char *endPt = cp + (phrase == NULL ? ecp : Min(ecp, phrase->fCharPos));
      char *endPt = cp + (phrase == NULL ? limit : phrase->fCharPos); // 29/11/93
      char *token;

      fDocument->BeginSpell(lang);
             // 29/11/93 test scp < ecp why?
      while (scp < ecp && (tokenLen = FindToken(scp, cp, endPt, token), tokenLen != 0))
      {
        FailIfEscape();
        if (lang != kNoLanguage && scp + tokenLen >= start)
          fDocument->Spell(currency, scp, token, tokenLen);
        scp += tokenLen;
      }
    }

    // spell check the phrase (if found), with its own language
    if (phrase != NULL)
    {
      if ((phrase->fKind == kWidgetPhrase || phrase->fKind == kNotePhrase) && scp >= start)
                                                      // 16/07/93 [20987] check >= start
        GetStructureReadOnly(phrase->tag.fRecNum)->
                                    DoSpellCheck(phrase->tag.fRecNum, NULL, NULL);
      scp = CheckPhrase(currency, scp, Min(ecp, phrase->fCharPos + phrase->fNumChars),
                   nextLanguage, phraseIdx, start, phrase->fCharPos + phrase->fNumChars);
                                       // 03/12/93 pass phrase end for second level
    }
  }
  return ecp;
}


// ------------------------------------------------------------------------
void _TTextStructure::DoSpellCheck(TCurrency currency, TCursorNode anchor,
                                                   TCursorNode activeEnd)
{
  int start = GetSelectionStartPos(anchor, activeEnd);
//  int scp = 0;
  int ecp = GetSelectionEndPos(anchor, activeEnd) - IsLastNode(activeEnd) + 1;
  int phraseIdx = 1;

  // if (activeEnd != NULL && !activeEnd->IsLast())
  // if (!IsLastNode(activeEnd))          // 22/11/92 check text in widgets at end
  //  ecp++;

  CheckPhrase(currency, 0, ecp, fLanguage, phraseIdx, start, fCount);
                                       // 03/12/93 pass fCount as limit at top level
}
#endif

#ifdef FN
// ------------------------------------------------------------------------
int _TTextStructure::GetOrder(TCurrency c1, TCurrency c2) 
// 22/4/92 replaced GetNoteIndex
{
  int n1 = 0, n2 = 0;

  for (int c = 0; c <= 1; c++)
  {
    for (int n = 1; n <= fSize; n++)
    {
      PPhrase phr = PPhrase(At(n));

      if (phr->fKind == kNotePhrase || phr->fKind == kWidgetPhrase)
      {
        if (phr->tag.fRecNum == (c == 0? c1 : c2))
        {
          if (c == 0)
            n1 = n;
          else
            n2 = n;
          break;
        }
      }
    }
  }
  return n1 - n2;
}
#endif


// +++++++++++++++++++++++++++++++++++ Start of Format +++++++++++++++++++


// ------------------------------------------------------------------------
_TTextBreak::_TTextBreak(int itsBreakPart, int itsDepth, int itsNextNote)
{
  fbreakPart = itsBreakPart;
  fDepth = itsDepth;
  fNextNote = itsNextNote;
}


// ------------------------------------------------------------------------
int _TTextBreak::BreakPart()
{
  return(fbreakPart);
}


// ------------------------------------------------------------------------
int _TTextBreak::Depth()
{
  return(fDepth);
}


// ------------------------------------------------------------------------
int _TTextBreak::NextNote()
{
  return(fNextNote);
}


// ========================== TTextFormat =================================
_TTextFormat::_TTextFormat(TMainView itsView) : (itsView, sizeof(TLinePart))
{
#ifndef ZERO_OBJ
  fSetWidth = 0;
  fMinWidth = 0;
#endif
}

#define kWidthFlag 0x40000000
#define sizeYBit      0x08000

static char gLineMap[] =
  "\x03\x01\x03\x01\x02\x02\x02\x02\x02\x02\x02\x02\x01\x03\x02\x02\x03\x01\x03\x01\x04\x03\x01\x02\x01\x01\x01\x01\x02\x02\x02";

static unsigned int ComputeMask(PLinePart previous, PLinePart current)
{
   unsigned int flags = FindMask((char *)previous, (char *)current, gLineMap, 0x3eb5d5d5);
                         // from 0x3eb5d555 for FIXLOC
#ifdef FIXLOC
   // see if location.h differs after 32-bit comparison set 0x10 bit if either set
   return (flags & 0xffffff7f) | ((flags & 0x80) >> 1);
#else
   return flags;
#endif
}

void _TTextFormat::LinePartInit(PLinePart initPart)
{
  memset(initPart, 0, sizeof(TLinePart));
  initPart->fAscent = fAscent;
  initPart->fDescent = fDescent;
  initPart->fNumChars = 1;
  initPart->fTextSizeX = 0x0c0;
  initPart->fTextSizeY = 0x0c0;
  initPart->fTextFont = 1;
  initPart->fEOL = kEndOfPara;
}

static char gFmtMap[] =
  "\x01\x01\x02\x01\x01\x02\x01\x01\x02\x01\x01\x02\x02\x01\x01\x02\x01\x01\x02\x01\x01\x01\x03\x01\x03\x04\x04\x02\01\x01\x04";

static struct {
  int fSpBefore;
  int fSpAfter;
  Size fAscent;
  Size fDescent;
  Fixed fLeftMargin;
  Fixed fRightMargin;
  Fixed fIndentation;
  char /* TAlignment */ fAlign;
  char fFiller1;
  char fFiller2;
  char fFlags;
  CntlAdornment fAdorn;
  TRuleType fRules;
  bool fHasChanged;
  int fSetWidth;
  int fMinWidth;
  } gFmtMaster = {20,20,107,27,0,0,0,0,0,0,0,0,{kOnePtPen, k1Thn, FALSE},0,0,0};
                // 21/07/92

// ------------------------------------------------------------------------
unsigned int _TTextFormat::GetFmtMask()
{
  gFmtMaster.fMinWidth = fSetWidth;     // these are normally (always) equal

  return FindMask((char *)&fSpBefore, (char *)&gFmtMaster.fSpBefore, gFmtMap,
             // 21/10/94 save fHasChanged too when set in purging
             // TTextDocument(fMainView->fDocument)->fPurging ? 0x7ebff6db : 
             0x7abfffdb);     // 14/08/95 [26060] descent > 16bits: 0x7abff6db);
}

// ------------------------------------------------------------------------
long _TTextFormat::DoNeedDiskSpace(long dataForkBytes)
{
  TLinePart initPart;
  PLinePart previous = &initPart;
  PLinePart current;
  unsigned int flags;
  int arrayTotal = 0;
  int fmtTotal = SumRecord(GetFmtMask(), gFmtMap) + 4;

  LinePartInit(previous);

  for (int i = 0; i < fSize; i++)
  {
    current = ((TLinePart *)fPtrToArray) + i;
    flags = ComputeMask(previous, current);
    arrayTotal += SumRecord(flags, gLineMap) + 4;
    previous = current;
  }
                            // NB the inherited - inherited DoNeedDiskSpace
  return _TArray::DoNeedDiskSpace(dataForkBytes + arrayTotal + fmtTotal -
     fSize * int(sizeof(TLinePart)) - int(sizeof(_TTextFormat)) + int(sizeof(_TArray)));
}

// ------------------------------------------------------------------------
void _TTextFormat::DoRead(int aRefNum, long remainder, int version)
{
  // assumes nothing overrides _TTextFormat & we do TFormat part too
  unsigned int flags;

#ifdef VERS0
  if (version == 0)
    _TFormat::DoRead(aRefNum, remainder, version);    // the inherited read
  else
#endif
    _TArray::DoRead(aRefNum, sizeof(_TArray), version);
                                        // the inherited - inherited read

  FRead(aRefNum, sizeof(unsigned int), &flags);
                         // also ignores old fZoomFactor if version 0

#ifdef VERS0
  if (version != 0)
#endif
  {
    char buffer[48];
    int reqSize = SumRecord(flags, gFmtMap);

    FRead(aRefNum, reqSize, buffer);
    UnpackRecord(flags, gFmtMap, buffer, &gFmtMaster, &fSpBefore);
    if ((flags & kWidthFlag) == 0)
      fMinWidth = fSetWidth;
    fFlags = (flags >> 24) & kBackwards;   // 28/06/94 top flag bit is backward text flag
  }
}

// ------------------------------------------------------------------------
void _TTextFormat::DoWrite(int aRefNum, long remainder)
{
  struct{
    unsigned int flags;
    char buffer[48];
  } discData;
  int reqSize;

  _TArray::DoWrite(aRefNum, sizeof(_TArray));   // inherited inherited call

  discData.flags = GetFmtMask();
  reqSize = PackRecord(discData.flags, gFmtMap, (char *)&fSpBefore, discData.buffer);
  discData.flags |= (fFlags << 24);  // 28/06/94 set backward text flag

  FWrite(aRefNum, reqSize + 4, &discData);
}

// ------------------------------------------------------------------------
void _TTextFormat::DoReadArrayPart(int aRefNum, int version)
{
  SetPermHandleSize(&fPtrToArray, fSize * sizeof(TLinePart));

#ifdef VERS0
  if (version == 0)
  {
    for (int i = 0; i < fSize; i++)
    {
      PLinePart current = (TLinePart *)fPtrToArray + i;
      FRead(aRefNum, sizeof(TLinePart), current); // read the array part
      if (current->fPartType == kTextPart || current->fPartType == kMacroPart)
        current->tag.cgf_35.fFiller = 0;  // 05/03/91 to zeroise filler
    }
  }
  else
#endif
  {
    char buffer[sizeof(TLinePart)];
    unsigned int flags;
    int reqSize;
    TLinePart initPart;
    PLinePart previous = &initPart;
    PLinePart current;
    Fixed nextLocH = 0;       // 01/02/95 [23029]
    int temp;

    LinePartInit(previous);

    for (int i = 0; i < fSize; i++)
    {
      current = ((TLinePart *)fPtrToArray) + i;

      FRead(aRefNum, sizeof(unsigned int), &flags);
      reqSize = SumRecord(flags, gLineMap);

      FRead(aRefNum, reqSize, buffer);        // read the compressed array
      UnpackRecord(flags, gLineMap, buffer, previous, current);
      current->fDescent = (current->fDescent << 16) >> 16;  // 02/05/91 sign
      current->fSlop = (current->fSlop << 8) >> 8;          // 23/09/91 sign
      current->fLocation.h = (current->fLocation.h << 16) >> 16;   // 06/10/93 [21068] sign
#ifdef FIXLOC
      // NB. DoNeedDiscSpace must return the same length as the original record. Because
      // fLocation.h is rounded down, it is possible for the current and previous values
      // to be the same, but the flags to say they are different. When DNDS works out the
      // flags again by comparing the rounded versions, it does not set the flag bit and
      // calculates a smaller length. This smaller length is put into the record handler
      // by PurgeRecord, causing the end of the record to be overwritten during saving.
      temp = previous->fLocation.h;
      previous->fLocation.h = nextLocH;   // do not update current yet!
      if ((flags & 0x40) != 0)            // 01/02/95 [23029] location.h changed
      {
        if (current->fLocation.h == temp)
          nextLocH += 1;                  // 01/02/95 [23029] ensure really different
        else
          nextLocH = ToFixed(current->fLocation.h);
      }
      // else if flag not set nextLocH must contain the Fixed length of current.fLoc.h
      // 01/02/95 [23029] previous->fLocation.h = ToFixed(previous->fLocation.h);
#endif
      // if (fHasChanged)
      //  current->fChanged = TRUE;     // 21/10/94 saved with fHasChanged set when purging
// 30/10/92 clearing may cause DoNeedDiscSpace to get diff answer current->fTextFace &= 0xff;
                       // 27/08/92 may have been saved as 3 bytes with rubbish in 2 & 3
#ifdef TRACE
      if (i == fSize - 1 && current->fEOL != kEndOfPara)
      {
        long file_position;

        GetFPos(aRefNum, file_position);
        SysBeep(0);
        // repaired below: current->fEOL = kEndOfPara;
      }
      else if (current->fEOL > 1)
      {
        SysBeep(0);
        current->fEOL = current->fEOL | 0xffffff00;
      }
#endif
      previous = current;
    }

    // 01/02/95 [23029] repair formats with end chopped off
    if (previous->fEOL != kEndOfPara)
      previous->fEOL = kEndOfPara;
                        // anything we should do about following stuff (numSpaces, etc.)?

#ifdef FIXLOC
    previous->fLocation.h = nextLocH;  // [23029] finish off by updating last
    // 01/02/95 [23029] previous->fLocation.h = ToFixed(previous->fLocation.h);
#endif
  }
}


// ------------------------------------------------------------------------
void _TTextFormat::DoWriteArrayPart(int aRefNum)
{
  TLinePart initPart;
  PLinePart previous = &initPart;
  PLinePart current;
  struct{
    unsigned int flags;
    char buffer[sizeof(TLinePart)];
  } discData;
  int reqSize;

  LinePartInit(previous);

   // write the array elements
  for (int i = 0; i < fSize; i++)
  {
    Fixed temp;

    current = (TLinePart *)fPtrToArray + i;
    discData.flags = ComputeMask(previous, current);
#ifdef FIXLOC
    temp = current->fLocation.h;
    if ((discData.flags & 0x40) != 0)  // fLocation.h changed
      current->fLocation.h = FixRound(temp);    // save it in old unfixed format
#endif
    reqSize = PackRecord(discData.flags, gLineMap, current, discData.buffer);

#ifdef FIXLOC
    current->fLocation.h = temp;     // restore original Fixed value
#endif
    FWrite(aRefNum, reqSize + 4, &discData);
    previous = current;
  }
}

// ------------------------------------------------------------------------
int _TTextFormat::GetEOL(int partNum)
{
  // 12/02/92 protect from view parts getting out of sync
#ifdef TRACE
  Assert(partNum > 0 && partNum <= fSize, 956);
  // if (partNum == fSize && PLinePart(At(fSize))->fEOL != kEndOfPara)
  //  SysBeep(0);  // change to >= below ???
#endif
  return (partNum > fSize ? kEndOfPara : PLinePart(At(partNum))->fEOL);
}


// ------------------------------------------------------------------------
bool _TTextFormat::GetChanged(int index)
{
  // 13/01/91 index > fSize for wrapping at end of columns
  return(index == 0 || index > fSize ? fHasChanged : PLinePart(At(index))->fChanged);
}


// ------------------------------------------------------------------------
void _TTextFormat::SetChanged(int index, bool changed)
{
  // 14/09/90 - rewritten again

  if (index == 0)
  {
    for (int pn = 1; pn <= fSize; pn++)
      PLinePart(At(pn))->fChanged = TRUE;         // 21/11/90 loop added
    SetHasChanged(TRUE);
  }
  else if (index < 0)
  {
    for (int pn = 1; pn <= fSize; pn++)
      if (PLinePart(At(pn))->fChanged)
        return;
    SetHasChanged(FALSE);
    ClearChangedFlags(gNullCurrency, FALSE);  // 10/02/92 added to clear widgets
            // last param (hf) FALSE as cannot have a body in text in header/footer
  }
  else
    PLinePart(At(index))->fChanged = changed;
}


// ------------------------------------------------------------------------
void _TTextFormat::SetMacro(int partNum, PLinePart linePart, Handle macroText)
{
  if (partNum <= fSize)
  {
    // 2/12/91 fixes bug when typing on 3rd line of H/F
    linePart->fChanged = PLinePart(At(partNum))->fChanged;
    AtPut(partNum, linePart);
  }
  else
  {
    // 2/12/91 fixes bug when typing on 3rd line of H/F
    linePart->fChanged = FALSE;
    InsertLast(linePart);                     // 03/04/91
  }

  if (linePart->fPartType == kMacroPart)       // 03/04/91
    gMainStruct->ReplaceMacroText(linePart->fCharPos, (char *)macroText);
}


// ------------------------------------------------------------------------
void _TTextFormat::Draw(int partNum, Rect &extent, Rect &rubOut)
{
  TLinePart linePart;

  Get(partNum, &linePart);

  SetGStyle(linePart, fMainView);  // 15/05/90
  gStyle.fcAscent = ZoomInt(linePart.fAscent);
  // 06/09/95 replaced by fcSpaceExtra: gStyle.fcAlignment = fAlign;
  // 17/06/94 for backwards text (using new font manager interface)
  gStyle.fcSpaceExtra = (linePart.tag.cgf_35.fNumSpaces == 0 || linePart.fSlop == 0 ? 0 :
         ZoomInt(linePart.fSlop / (linePart.tag.cgf_35.fNumSpaces * 10)));  // for backwards

  gMainStruct->SetFontAndFace(TRUE);       // 22/12/94 moved up (done in both branches)

  if (linePart.fPartType == kFillerPart || 
      linePart.fPartType == kBulletPart
#ifdef FN
      || linePart.fPartType == kNotePart
#endif
     )
  {
    int fillLen = 1;
    char *filler = NULL;
#ifdef FN
    char noteRef[6];

    if (linePart.fPartType == kNotePart)
    {
      filler = noteRef;
      gMainStruct->GetNoteNumber(gNullCurrency, linePart.tag.cgf_34.fRecNum, filler);
      fillLen = strlen(filler);
    }
    else
#endif
    {
      if (linePart.fPartType == kFillerPart)
      {
        int numTabs = strlen(linePart.tag.fTabFiller);

        if (numTabs != 0)
        {
          fillLen = linePart.fNumChars * numTabs;
          filler = (char *)NewHandle(fillLen + 1);

          if (filler != NULL)
          {
            filler[0] = 0;
            for (int n = 1; n <= linePart.fNumChars; n++)
            {
              strcat(filler, linePart.tag.fTabFiller);
            }
          }
        }
      }
      else
      {
        filler = linePart.tag.fBullet;
#ifdef AUTONUM
        if (filler[0] == 1 || filler[0] == 2)
        {
          TTextStructure structure = gMainStruct;

          filler = (char *)structure->fPtrToArray + AutoNumberOffset(structure);
          fillLen = strlen(filler);
        }
#endif
      }

      extent.left += FixRound(ZoomFixed(linePart.fSlop));  // right justify filler/bullets
    }

    if (filler != NULL)
    {
      DrawText(filler, fillLen, extent, rubOut, gStyle.fcAscent, 0);  // TRUE) for backwards
                                                  // 22/04/91 add rubOut
      if (linePart.fPartType == kFillerPart)
        DisposHandle(filler);
    }
    else if (!gPrinting)                      // 19/04/91
      EraseRect(rubOut);                      // 02/05/91
  }
  else
    gMainStruct->Draw(linePart, extent, rubOut);  // 22/04/91 add rubOut
}


// ------------------------------------------------------------------------
// 30/11/90 use space totals rather than widths
int _TTextFormat::JustifyLine(int firstPart, bool adjust, Fixed widthChange)
{
  int partNum;
  int spaceTotal;
  Fixed fullWidth;
  Fixed totalSlop;
  int tabNum;
  int lineEnd;
  bool canJustify;
  int JustifyLine_r;

  tabNum = firstPart;
  spaceTotal = 0;
  fullWidth = 0;        // 28/06/94
  partNum = firstPart;
  do
  {
    // calculate number of spaces and width after last tab, set tabNum to last tab
    register PLinePart cgf_139 = PLinePart(At(partNum));

    if (cgf_139->fPartType == kTextPart || cgf_139->fPartType == kMacroPart)
    {
      if (cgf_139->tag.cgf_35.fTab)
      {
        tabNum = partNum;
        spaceTotal = 0;
      }
      spaceTotal += cgf_139->tag.cgf_35.fNumSpaces;
    }
    else if (cgf_139->fPartType == kBulletPart)       // [20981]
    {
      tabNum = partNum + 1;
    }
    fullWidth += (cgf_139->fWidth + cgf_139->fSlop);    // 28/06/94

    partNum++;
    lineEnd = cgf_139->fEOL;
  } while (lineEnd > kLineBreak);       // 24/10/90 kLineBreak for 0

  canJustify = IsLineBreak(lineEnd);    // 24/10/90 call instead of == 0
  JustifyLine_r = partNum; // 25/07/90

  TAlignment paraAlign = fAlign;
  int backwards = Backwards();

  if (paraAlign == kAlignForce)    // [26067]
  {
    paraAlign = kFill;
    canJustify = TRUE;
  }

  // 10/06/94 Rewrite for backward text
  if (adjust)
  {
    // if adjust set, this is the fast path which simply adjusts the line parts
    // by widthChange, the change in line width when a table col is resized, for example
    // With backward text, strictly we should always loop down to firstPart, but as
    // things stand (no tabs in tables) tabNum is always equal to firstPart
    // This is only called if align is right, centre or fill

    if (paraAlign != kAlignLeft && (backwards || paraAlign != kFill))
    {
      if (paraAlign == kAlignCentre)
        widthChange = widthChange / 2;
#ifndef FIXLOC
      widthChange = FixRound(widthChange);  // yukk, as fLocation.h should be a Fixed too!!!
#endif
      while ((--partNum) >= tabNum)
      {
        register PLinePart cgf_139a = PLinePart(At(partNum));

        cgf_139a->fLocation.h += widthChange;
        cgf_139a->fChanged = TRUE;
        SetHasChanged(TRUE);
      }
    }
  }
  else
  {
    // This moves any line parts after the last tab, which are affected by centre or
    // right justification (or left justification when left aligned backwards text)
    // For parts after the last tab, justify by adjusting their horizontal location
    // for parts up to last tab, mark as changed if they have a slop value
    // With this rewrite, all we need is the unused 'width' value from LineReformat
    // If that was passed in, we could just use that as totalSlop and avoid the
    // following messy calculation (provided AdjustLastPart correctly updates width)
    PLinePart tabPart;
    PLinePart lastPart;
    PLinePart part;
    Fixed adjust;

//    if (backwards)
//      fullWidth = tabPart->fLocation.h + tabPart->fWidth - GetLeftMargin();
//    else
//      fullWidth = ToFixed(fSetWidth) - GetRightMargin() - tabPart->fLocation.h;
//    totalSlop = fullWidth - partWidths;
    totalSlop = widthChange - fullWidth;   // widthChange with adjust false is orig. width

    // work out the adjustment to be applied to parts
    if (paraAlign == (backwards & kAlignRight) ||  // fwd: == leftAlign or Bwd: == rightAlign
             (paraAlign == kFill && (backwards || !canJustify || spaceTotal == 0)))
                     // 09/09/94 left justify if fully just with no spaces
      adjust = 0;
    else if (paraAlign == kAlignCentre)
      adjust = totalSlop / 2;
    else
      adjust = totalSlop;
    adjust ^= backwards;   // negate if b/wds text

    tabPart = PLinePart(At(tabNum));
    lastPart = PLinePart(fPtrToArray) + partNum - 2;
    // mark slop as -1 so we can tell which have been adjusted
    for (part = lastPart; part >= tabPart; part--)
      part->fSlop = -1;

    // work backwards through the line parts applying adjustment & marking changes
    Fixed lastLocation = 0x10000000;  // big for the location of the last part processed
    while (TRUE)
    {
      // because view parts are not necessarily in the same order as format parts,
      // this must perform serial processing by position (backwards from rh end)
      Fixed currDistance = MAXLONGINT;
      PLinePart cgf_140 = NULL;

      part = lastPart;
      do
      {
        if (part->fSlop == -1)     // not processed
        {
          Fixed distance = lastLocation - part->fLocation.h;

          if (distance < currDistance)
          {
            cgf_140 = part;
            currDistance = distance;
          }
        }
        part--;
      }
      while (part >= tabPart);
      if (cgf_140 == NULL)
        break;
      if (paraAlign == kFill && canJustify &&
           (cgf_140->fPartType == kTextPart || cgf_140->fPartType == kMacroPart) &&
                                        cgf_140->tag.cgf_35.fNumSpaces > 0)
                                 // 17/09/92 does not fully justify merge insertions
      {
        cgf_140->fChanged = TRUE;       // 23/09/91
        SetHasChanged(TRUE);            // 23/09/91
        cgf_140->fSlop = (totalSlop * cgf_140->tag.cgf_35.fNumSpaces) / spaceTotal;
        // space total must be non-zero because fNumSpaces > 0 for this part alone
        adjust -= cgf_140->fSlop;
      }
      else
        cgf_140->fSlop = 0;
      // 22/06/94 LineReformat now always clears fSlop
      // else if (cgf_140->fSlop != 0)
      // {
      //   cgf_140->fChanged = TRUE;
      //   SetHasChanged(TRUE);
      //   cgf_140->fSlop = 0;
      // }
      if (adjust != 0)
      {
        cgf_140->fLocation.h += adjust;
        cgf_140->fChanged = TRUE;
        SetHasChanged(TRUE);
      }
      lastLocation = cgf_140->fLocation.h;
    }
  }
  return(JustifyLine_r); // 25/07/90
}


// ------------------------------------------------------------------------
bool _TTextFormat::ContainsWordBreak(PLinePart linePart,
                      TPartType *lastPartType, TCharPos *charPos, bool* tabField)
{
  *lastPartType = linePart->fPartType;
  if (linePart->fCharPos <= *charPos)
  {
    *tabField = (*lastPartType == kFillerPart);
    if (*lastPartType == kTextPart || *tabField || *lastPartType == kMacroPart)
           // 36/08/93 [21036] || *lastPartType == kWidgetPart || *lastPartType == kNotePart
      return TRUE;
    *charPos = linePart->fCharPos - 1;
  }
  return FALSE;
}

// ------------------------------------------------------------------------
bool _TTextFormat::DoAlignTab(int index, TFTabInfo &tabInfo, Fixed tabSpace,
            Fixed &width, Fixed &location)
{
  // called with non-left tabs, after the next part has been measured, to reset
  // the widths and locations of the affected parts
  Fixed f;
  int lp;

#ifdef TRACE
  Assert(tabInfo.fKind != 10, 995);
#endif
  f = 0;
  lp = index - 1;
  while (lp >= 1)
  {
    register PLinePart cgf_148 = PLinePart(At(lp));

    if (cgf_148->fPartType == kFillerPart)
    {
       SetGStyle(*cgf_148, NULL);      // 10/08/95 [26050] set correct font before measure
       gMainStruct->SetFontAndFace(FALSE);  // 10/08/95
       break;
    }
    f += cgf_148->fWidth;        // 14/09/90 moved from before break
    lp --;
  }
  if (tabInfo.fKind == kCentreTab)
    f = f / 2;

  if ((f = tabSpace - f) < 0)          // 19/07/93 [20992] force into CTF with zero width
    f = 0;

  CompleteTabFiller(f, lp, tabInfo);

//  if (f < tabSpace)
  if (f > 0)
  {
    // f = tabSpace - f;
    // CompleteTabFiller(f, lp /* 14/09/90 - 1 */ , tabInfo);
    width -= f;
    if (fFlags)
    {
      f = -f;
      lp--;      // adjust location of filler too
    }
    location += f;
#ifndef FIXLOC
    f = FixRound(f);
#endif
    for (lp = lp + 1; lp <= index - 1; lp++)     // 14/09/90 from lp + 1
    {
      PLinePart(At(lp))->fLocation.h += f;
    }
  }
  return FALSE;
}


// ------------------------------------------------------------------------
int _TTextFormat::CompleteLine(int response, int index, int indexStart,
                  Fixed widthStart, bool formatAll,
                  TChangeTypes &result, TCharPos &charPos)
{
  PLinePart linePart;
  int partNum;
  int lineWidth;
  int maxAscent;
  // int maxDescent = 0;
  int lastAscent;
  // int lastDescent;
  int v;
  PLinePart lastLinePart = PLinePart(At(index - 1));
  Fixed maxLeftPos = lastLinePart->fLocation.h;    // for backwards text

  // 10/02/92 & 17/02/92 new to strip spaces
  // 25/02/94 not much point testing here:  if (index > 1)
  if (lastLinePart->fPartType == kTextPart)
  {
    // SkipTrailingSpaces in-line
    int skipped = 0;

    while (lastLinePart->fNumChars > skipped &&
                               gMainStruct->GetChar(charPos - 1) == chSpace)
    {
      skipped++;
      charPos--;
    }
    if (skipped > 0)
    {
      lastLinePart->fNumChars -= skipped;
      AdjustLastPart(index - 1, response, charPos);
    }
  }
  maxAscent = gCompositeStyle.fcAscent;     // 06/01/94 [21717] from gStyle which is wrong
  for (int pass = 0; pass <= 1; pass++)
  {
    int ascent;
    int descent;

    lastAscent = gCompositeStyle.fcAscent;     // 06/01/94 [21717] from gStyle
    // lastDescent = gStyle.fcDescent;

    for (partNum = indexStart; partNum <= index - 1; partNum++)
    {
      bool scriptPart = TRUE;

      linePart = PLinePart(At(partNum));

      if (kSubscript & linePart->fTextFace)
        ascent = linePart->fAscent - (lastAscent / 8);
        // avoid lastDescent: ascent = linePart->fAscent - (lastDescent / 3);
      else if (linePart->fPartType == kNotePart || (kSuperscript & linePart->fTextFace))
        ascent = (lastAscent / 3) + linePart->fAscent;
      else
      {
        scriptPart = FALSE;
        ascent = lastAscent = linePart->fAscent;
        // lastDescent = linePart->fDescent;
      }
      descent = linePart->fDescent + linePart->fAscent - ascent;

      if (pass == 0)
      {
        if ((linePart->fPartType != kWidgetPart && !scriptPart) || !gStyle.fcFixedHeight)
        {
          if (ascent > maxAscent) maxAscent = ascent;
          // if (descent > maxDescent) maxDescent = descent;   // [20834]
        }
      }
      else
      {
        v = maxAscent - ascent;

        if (linePart->fLocation.v != v)
           // [20834]                 && cgf_150->fPartType != kNotePart
        {
          linePart->fChanged = TRUE;
          SetHasChanged(TRUE);
          linePart->fLocation.v = v;
          if (result < kStructChg)
                            // 19/02/92 footnote change, but needed for back wrap widgets
            result = kStructChg;   // 29/05/90
        }
      }
    }
  }

  if (widthStart == MAXLONGINT)           // FixPointVal(MAXINT))
  {
    if (fFlags)
    {
      // compensate for starting the line with location set to 0
      for (partNum = indexStart; partNum <= index - 1; partNum++)
        PLinePart(At(partNum))->fLocation.h -= maxLeftPos;   // maxLeftPos is -ve!
    }
    // 04/07/91 loop for opt return in table
    fSetWidth = 0;
    for (partNum = 1; partNum < index; partNum++)
    {
      register PLinePart cgf_151 = PLinePart(At(partNum));

#ifdef FIXLOC
      // work out in fixed, then round at the end
      lineWidth = cgf_151->fLocation.h + cgf_151->fWidth + GetRightMargin();
      fSetWidth = Max(fSetWidth, Max(lineWidth, cgf_151->fWidth)); // 19/03/91 Max
#else
      lineWidth = cgf_151->fLocation.h + FixRound(cgf_151->fWidth + GetRightMargin());
      fSetWidth = Max(fSetWidth, Max(lineWidth, FixRound(cgf_151->fWidth))); // 19/03/91 Max?
#endif
    }
    widthStart = fSetWidth - GetRightMargin() - GetLeftMargin();
#ifdef FIXLOC
    fSetWidth = FixRound(fSetWidth);
#endif
    fMinWidth = fSetWidth;
  }

  PLinePart(At(index - 1))->fEOL = response;  // 24/10/90 was in conditional

  if (fAlign != (fFlags >> 6) || formatAll)   // fAlign != alignLeft (rt for Bwd)
    JustifyLine(indexStart, FALSE, widthStart);   // 0); // 29/06/94 pass line width

  gPhraseIdx = -1;
  return response;
}


// ------------------------------------------------------------------------
void _TTextFormat::CompleteTabFiller(Fixed gap, int lpn, TFTabInfo &tabInfo)
{
  Fixed fillerWidth;
  int numCopies = 1;
  int backwards = 0;

  if (tabInfo.fFiller[0] == 0)       // 19/07/93 [20992] avoid filler test
  {
    fillerWidth = gap;
    // numCopies = 1;
  }
  else
  {
    // 20/07/93 [20993] Rewritten avoiding the (erroneous) assumption that n characters
    // are n times wider than one
    TabFiller filler;   // put a terminator on filler

    strcpyn(filler, tabInfo.fFiller, kFillerLen);
    fillerWidth = DoMeasure(filler, gStyle, FALSE);

    if (gap < fillerWidth)    // cannot fit 1
    {
      numCopies = 0;
      fillerWidth = 0;
    }
    else
    {
      char buff[kFillerLen * 2 + 1];
      Fixed x2;

      strcat(strcpy(buff, filler), filler);
      x2 = DoMeasure(buff, gStyle, FALSE);          // width of two sets of filler

      if (x2 > fillerWidth)                         // avoid any posibility of zero div
      {
        int copies = ((gap - fillerWidth) / (x2 - fillerWidth));
        Fixed remdr = ((gap - fillerWidth) % (x2 - fillerWidth));

        numCopies += copies;
        fillerWidth = gap - remdr;
      }
      backwards = GetTextDirection();
    }
  }

  {
    register PLinePart cgf_144 = PLinePart(At(lpn));
    // fillerWidth = FixMul(fillerWidth, ToFixed(numCopies));

    if (!cgf_144->fChanged)
    {
      if (cgf_144->fWidth != fillerWidth || cgf_144->fNumChars != numCopies ||
                         (cgf_144->fTextFace & kBackwards) != backwards)
      {
        cgf_144->fChanged = TRUE;
        SetHasChanged(TRUE);
      }
    }
    cgf_144->fTextFace = (cgf_144->fTextFace & ~kBackwards) | backwards;
    cgf_144->fNumChars = numCopies;

    // 27/06/94 instead of moving fLocation, set fSlop to be the amount to ignore at start
    cgf_144->fWidth = gap;     // 27/06/94 avoid holes in vLineparts (for clickOnce-ing)
    if (tabInfo.fKind == kLeftTab || // 20/07/93 [20293] avoid overwriting rt just tabfiller
                       (fFlags && tabInfo.fKind != kRightTab))
    {
      // the tab filler is to be right justified in its part extent
      cgf_144->fSlop = gap - fillerWidth;
      cgf_144->fWidth = fillerWidth;     // compensate (since vPart width is fWidth + fSlop)
    }
  }
}

extern void FontStringBBox(int, char *, int, TStringBBox *);

// ------------------------------------------------------------------------
Fixed _TTextFormat::DoMeasure(char* str, TStyle &theStyle, bool forBullet)
{
  TFontStyle fontstyle;
  // font_info strBox;

  fontstyle.fTextFont = (forBullet ? theStyle.fcBulletFont : theStyle.fcTextFont);
  fontstyle.fTextSizeX = theStyle.fcTextSizeX;
  fontstyle.fTextSizeY = theStyle.fcTextSizeY;
  fontstyle.fTextFace = (forBullet ? 0 : (theStyle.fcTextFace & ~kBackwards));  // 12/07/93
  TextFont(&fontstyle);
  TextColour(theStyle.fcColour, FALSE);

  // 17/04/92 shorter & probably a bit quicker
  // 08/95 use new FontMgr i/f: FailOSErr(font_stringbbox(str, &strBox));
  FontStringBBox(gLastFontHandle, str, 0, &gStringBBox);    // 02/09/96 [27058] extra parameter
  return (gStringBBox.bbox.x1 + gStringBBox.bbox.x0) * 10;    // Cvt MilliPts to Fixed DeciPts
}


// ------------------------------------------------------------------------
static void InitLinePart(TStyle &style, TLinePart &linePart, Fixed location, 
                  TPartType partType) // fn1
{
  linePart.fSlop = 0;
#ifdef FIXLOC
  linePart.fLocation.h = location;
#else
  linePart.fLocation.h = FixRound(location);
#endif
  linePart.fLocation.v = 0;
  linePart.fEOL = 1;
  linePart.fNumChars = 0;
  linePart.fAscent = style.fcAscent;
  linePart.fDescent = style.fcDescent;
  linePart.fTextFont = style.fcTextFont;
  linePart.fTextSizeX = style.fcTextSizeX;
  linePart.fTextSizeY = style.fcTextSizeY;
  linePart.fTextFace = style.fcTextFace;  // kBackwards bit will be clear
  linePart.fColour = style.fcColour;
  linePart.fChanged = TRUE;
  linePart.fPartType = partType; // fn1
}


// ------------------------------------------------------------------------
void _TTextFormat::InitBullet(PLinePart linePart, Fixed location)
                                   // 07/06/94 Fixed &location, Fixed &width)
{
  Fixed bulletWidth;
  Fixed partWidth;
  int backwards = Backwards();   // -1 for bw, 0 for fwds
  char *bullet;
  int bulletFont;

  // 07/06/94 measure moved before init line part (for backwards text)
  bullet = linePart->tag.fBullet;
  bullet[0] = gCompositeStyle.fcBullet;
  bullet[1] = 0;
#ifdef AUTONUM
  if (gCompositeStyle.fcBullet <= 2)
  {
    TTextStructure structure = gMainStruct;

    bullet = (char *)structure->fPtrToArray + AutoNumberOffset(structure);
  }
#endif
  bulletFont = gCompositeStyle.fcBulletFont;
  partWidth = bulletWidth = DoMeasure(bullet, gCompositeStyle, bulletFont);
        // 08/04/96 allow gCompositeStyle.fcBulletFont of zero to mean paragraph font & style
  // 15/07/93 [20981]; also centre between margins, not indentations
  if (gCompositeStyle.fcAutoBullet || (unsigned int)(fAlign - backwards - 1) <= kAlignCentre)
          // fAlign == kAlignRight || fAlign == kAlignCentre)
  {
    Fixed margin = (&fLeftMargin)[-backwards];  // gCompositeStyle.fcRuler->GetLeftMargin();
            // 30/06/94 using the style margins was wrong (for bulleted paras with borders)

    if (fIndentation /* location */ + bulletWidth < margin)
      bulletWidth = margin - fIndentation /* location */;
  }
  InitLinePart(gCompositeStyle, *linePart, location - (backwards & bulletWidth),
                                                                           kBulletPart);
  linePart->fTextFont = bulletFont ? bulletFont : gCompositeStyle.fcTextFont;
         // 08/04/96 allow gCompositeStyle.fcBulletFont of zero to mean paragraph font & style
#ifdef AUTONUM
  if (strchr(bullet, 21) != NULL)
    backwards ^= -1;    // [23021] reverse justification if bullet contains comment
#endif
  linePart->fSlop = (bulletWidth - partWidth) & backwards;
                              // slop is non-zero to rt justify when backwards
  linePart->fWidth = bulletWidth - linePart->fSlop;
  linePart->fCharPos = 0;            // 11/07/90 - new
  linePart->fTextFace = 0; // 07/06/90 - we do not want an underlined bullet etc.
  SetHasChanged(TRUE);
}

#ifdef AUTONUM
// ------------------------------------------------------------------------
static bool AutoNumberReset(TTextFormat self, TCurrency myCurrency, PStdNoteVars origProc)
{
  TTextStructure structure = gMainStruct;
  int origLen = structure->fOffset - AutoNumberOffset(structure);
  int newLen;
  char *str = NULL;

  if (gStyle.fcBullet == 1 || gStyle.fcBullet == 2)
  {
    str = (char *)CallNoteFunc(origProc, gStyle.fcBullet, myCurrency); // 10/10/94 frig
    if (str == NULL)
      return FALSE;               // went down the fast path
    
    newLen = strlen(str) + 1;
  }
  else
    newLen = 0;

  if (newLen == origLen && memcmp(TextStart(structure) - origLen, str, newLen) == 0)
  {
    free(str);
    return FALSE;
  }

  Munger(&structure->fPtrToArray, structure->fOffset - origLen, NULL, origLen, str, newLen);
  free(str);
  FailMemError();
  structure->fOffset += (newLen - origLen);
  return TRUE;
}
#endif

// ------------------------------------------------------------------------
void _TTextFormat::SetStyles(long emphasis, bool footnote) // fn1
{
  TStyleFormat theStyle;
  TTextDocument document = TTextDocument(fMainView->fDocument);
  int basicEmph = HiWord(emphasis);
  int changeEmph;
  TEmphasisType emphType = footnote ? kFootnoteEmphasis : kNormalEmphasis;
// 14/04/93#ifdef SUPER
// 14/04/93  bool scripted = FALSE;
// 14/04/93#endif

  memcpy(&gStyle, &gCompositeStyle, sizeof(TStyle));
  if (basicEmph != 0)
  {
    theStyle = GetStyleReadOnly(RecToCurrency(basicEmph));
// 14/04/93#ifdef SUPER
// 14/04/93    scripted = (kFace & theStyle->fDefined) && !(kSize & theStyle->fDefined) &&
// 14/04/93        ((kSuperscript | kSubscript) & theStyle->fTextFace);
// 14/04/93#endif
    theStyle->SelectStyle(document, gStyle, emphType);
  }

  changeEmph = LoWord(emphasis);
  if (changeEmph != 0)
  {
// 14/04/93#ifdef MATHS
// 14/04/93    int savedFont = gStyle.fcTextFont;
// 14/04/93#endif

    theStyle = GetStyleReadOnly(RecToCurrency(changeEmph));
// 14/04/93#ifdef SUPER
// 14/04/93    if (scripted)
// 14/04/93      scripted = !(kSize & theStyle->fDefined);
// 14/04/93    else
// 14/04/93      scripted = (kFace & theStyle->fDefined) && !(kSize & theStyle->fDefined) &&
// 14/04/93        ((kSuperscript | kSubscript) & theStyle->fTextFace);
// 14/04/93#endif
#ifdef MATHS
    // 28/04/92 was corrupting styles by losing the font
    if (basicEmph != 0 && document->IsMathSymbol(basicEmph))
                                   // stop emphasis being overriden with diff font
       emphType = kSymbolEmphasis;
#endif
    theStyle->SelectStyle(document, gStyle, emphType);
// 14/04/93#ifdef MATHS
// 14/04/93    // 28/04/92 was corrupting styles by losing the font
// 14/04/93    if (basicEmph != 0 && document->IsMathSymbol(basicEmph)
// 14/04/93          && (theStyle->fDefined & kFont) != 0)
// 14/04/93      gStyle.fcTextFont = savedFont;
// 14/04/93#endif
  }
// 14/04/93#if defined FN || defined SUPER
// 14/04/93  if (footnote
// 14/04/93#ifdef SUPER
// 14/04/93        || scripted
// 14/04/93#endif
// 14/04/93     )
// 14/04/93  {
// 14/04/93    Fixed leading, asc, desc;

// 14/04/93    gStyle.fcTextSizeX = gStyle.fcTextSizeX * 2 / 3;
// 14/04/93    gStyle.fcTextSizeY = gStyle.fcTextSizeY * 2 / 3;
// 14/04/93    document->SetCurrentFont(gStyle.fcTextFont, gStyle.fcTextSizeX, gStyle.fcTextSizeY);
// 14/04/93    MeasureFont(asc, desc, leading);
// 14/04/93    gStyle.fcAscent = FixRound(asc);
// 14/04/93    gStyle.fcDescent = FixRound(desc);
// 14/04/93  }
// 14/04/93#endif
}


// ------------------------------------------------------------------------
void _TTextFormat::UpdateLineParts(TLinePart &linePart, int newPartIndex, int lastPart)
{
  // 29/05/90 - new method
  if (newPartIndex > 0)
  {
    if (newPartIndex > lastPart)              // 23/01/91 from GetSize())
    {
      linePart.fChanged = 2;                  // 22/10/93 [21094] ensure fChanged not cleared
      InsertBefore(newPartIndex, &linePart);  // 23/01/91 from InsertLast
    }
    else
      AtPut(newPartIndex, &linePart);
  }
}

// ------------------------------------------------------------------------
Fixed _TTextFormat::AdjustForDirectionChange(int index, int partDirection, Fixed fitWidth)
{
  // 27/06/94 new function for backwards text; If the current line part direction
  // is opposite to the paragraph flow, scan back looking for preceeding parts
  // which also go in the reverse direction and adjust
  Fixed partLoc = 0;

  if ((fFlags ^ partDirection) != 0)
  {
    // this part is in the opposite direction to the text flow
    PLinePart linePt = PLinePart(fPtrToArray) + index - 2;
    int backwards = Backwards();

    while(linePt >= PLinePart(fPtrToArray) && linePt->fEOL > kLineBreak &&
      (linePt->fTextFace & kBackwards) == partDirection && linePt->fPartType != kFillerPart)
    {
      partLoc -= (linePt->fWidth ^ backwards);
      linePt->fLocation.h += (fitWidth ^ backwards);
      linePt--;
    }
  }
  return partLoc;
}

// ------------------------------------------------------------------------
void _TTextFormat::AdjustLastPart(int index, int hyphenation, int charPos)
{
  Size numChars;
  register PLinePart cgf_155 = PLinePart(At(index));
  Fixed oldWidth = cgf_155->fWidth;     // for backwards

  SetGStyle(*cgf_155, NULL);
  cgf_155->fNumChars = charPos - cgf_155->fCharPos;
  numChars = cgf_155->fNumChars;

  cgf_155->fWidth = MAXLONGINT;
  gMainStruct->Fit(cgf_155->fCharPos, hyphenation,
               numChars, cgf_155->tag.cgf_35.fNumSpaces, cgf_155->fWidth);
  cgf_155->fChanged = TRUE;
  oldWidth = cgf_155->fWidth - oldWidth;
  if (fFlags)
#ifdef FIXLOC
    cgf_155->fLocation.h -= oldWidth;   // for backwards
#else
    cgf_155->fLocation.h -= FixRound(oldWidth);   // for backwards
#endif
  AdjustForDirectionChange(index, GetTextDirection(), oldWidth);
}

// ------------------------------------------------------------------------
#ifdef FN
TChangeTypes _TTextFormat::FormatNote(TCurrency note, TCurrency ref, // 11/5/93 [20860]
        TTextReformatVars* v)
{
#ifdef AUTONUM
  if (note > 2)
#endif
    v->hasNote = 1;
  return CallNoteFunc(v->origProc, note, ref);  // 11/5/93
}
#endif

// ------------------------------------------------------------------------
static TChangeTypes InSaveGlobals(TCurrency myCurrency, TFormat widget,
      TCurrency runObject, TCursorNode anchor, TCursorNode activeEnd, PStdNoteVars v)
{
  TChangeTypes response;
  TTextStructure saveMainStruct = gMainStruct;
  int savePhraseIdx = gPhraseIdx;
  TActivePhrase saveActivePhrase = gActivePhrase;
  int lastCh = gLastCh;       // 07/02/92
  TStyle compStyle = gCompositeStyle; // 27/08/92 save gCompositeStyle ...

  gPhraseIdx = -1;
#ifdef FN
  if (widget == NULL)
    response = CallNoteFunc(v, runObject, myCurrency);
  else
#endif
  {
    response = widget->Reformat(runObject, anchor, activeEnd, 0, -1, v);
    widget->SetWidth(runObject, widget->GetWidth());
  }
  SetTextGlobals(saveMainStruct);
  gPhraseIdx = savePhraseIdx;
  gActivePhrase = saveActivePhrase;
  gLastCh = lastCh;       // 07/02/92
  gCompositeStyle = compStyle;                // 27/08/92 ... and restore
  return response;
}

// ------------------------------------------------------------------------
static bool BeforeTheTab(TObject ignore, PFTabInfo tabInfo, Fixed location, PFTabInfo tInfo)
// 15/06/94 new for backwards
{
  return (tabInfo->fStop < location ? (int)memcpy(tInfo, tabInfo, sizeof(TFTabInfo)) : 0);
}

// ------------------------------------------------------------------------
static bool AfterTheTab(TObject ignore, PFTabInfo tabInfo, Fixed location, PFTabInfo tInfo)
// 15/06/94 new for backwards
{
  return (tabInfo->fStop > location ? (int)memcpy(tInfo, tabInfo, sizeof(TFTabInfo)) : 0);
}

// ------------------------------------------------------------------------
int _TTextFormat::LineReformat(TCurrency myCurrency, int &index, int lastPart /*numParts*/,
          /* int &numChars,*/ TCursorNode anchor, TCursorNode activeEnd, Fixed width,
          PStdNoteVars origProc, TChangeTypes &result)
{
// 17/06/95 [26020] Preserve setting of fChanged on line parts. This is so after a reformat
// of the header or footer, subsequent LineReformats still have changes marked even though
// there are no differences from the first reformat. Before it was possible get no changes
// marked from LineReformat, causing H/F view parts to be left out of sync with format parts

  int  LineReformat_r = kWidthChg;   // in case it loops !
  Size runLength;
  TRunType runType;
  TCurrency runObject;
  long emphasis;
  bool reformatted;
  TLinePart linePart;
  Fixed location;
  TCharPos charPos;
  TCharPos lineStart;
  int indexStart;
  int indexStart1;  // 25/02/94
  Fixed widthStart;
  Fixed widthStart1;
  Fixed origWidth = width;  // 05/07/94
  TFTabInfo tabInfo;
  bool alignTab;
  bool tabField;
  Fixed tabSpace;
  bool formatAll;
  // 10/02/94 lastPart passed as param as a replacement  for numParts: int lastPart;
  int oldLineDepth;
  int loopLim = 1024;
  int backwards = Backwards();

#ifdef FN
  TChangeTypes footNoteRes;
  int footCount;        // 10/05/93 [20861]
#endif

  formatAll = fHasChanged || anchor == NULL || activeEnd == NULL; // 14/05/91
  // lastPart = (numParts < MAXINT ? index + numParts - 1 : fSize); // 23/01/91
  if (result == kNoChg) // 07/06/90 - changed from != kHeightChg
    result = kWidthChg;     // 02/05/90 - on mac

  // 07/06/94 optimise loop to find the index of the first part on the current line
  // by scanning back to part at the end of the previous line (if any)
  charPos = 0;
  location = fIndentation;
   // (backwards ? GetLeftMargin() : fIndentation); // 14/06/94 ignore backwd indent?
  for (; index > 1; index--)
  {
    register PLinePart cgf_163 = PLinePart(At(index - 1));

    if (cgf_163->fEOL <= kLineBreak)
    {
      charPos = cgf_163->fCharPos +
                (cgf_163->fPartType == kFillerPart ? 1 : cgf_163->fNumChars);
      if (cgf_163->fEOL >= kModifiedHyphen)     // faster than: IsLineBreak(cgf_163->fEOL)
      {
        gLastCh = chUndef;                      // 18/08/93 [21026] if gLastCh == tab, next
                                                // run increments over following char, and
                                                // fails if that is the Return at the end
        charPos = gMainStruct->SkipLeadingSpaces(charPos); // 13/01/94, runLength);
      }
      location = (&fLeftMargin)[-backwards];    // GetLeftMargin();
      break;        // break out of loop, otherwise keep scanning back to start of line
    }
  }

  if (width > 0)
  {
    width = width - location - (&fRightMargin)[backwards];  // left margin when backwards
    width = Max(width, FixPointVal(180));                   // 01/07/91
    if (backwards)
      location = width + fLeftMargin;                       // location set to rh edge
  }
  else
  {
    width = MAXLONGINT;        // FixPointVal(MAXINT);   // 19/02/92 make anything fit
    if (backwards)
      location = 0;     // sort out locations in CompleteLine
  }

  // 19/11/92 moved after bullet handling:  widthStart = width;
  widthStart = width;    // 29/06/94 now widthStart1 set after bullet
  {
    int lineAsc;
    int lineDesc;

#ifdef FN
    footCount =      // 10/05/93 [20861]
#endif
      GetLineDepth(index, lineAsc, lineDesc, indexStart); // 20/02/92 added
    oldLineDepth = lineAsc + lineDesc;                  // 20/02/92 added
  }
  lineStart = charPos;
  indexStart = index;
  runObject  = 0;
  emphasis = 0;             // 23/01/91 not gNullCurrency;
//  runType = kEOT;
  reformatted = FALSE;
  alignTab = FALSE;
  tabField = FALSE;
  tabSpace = 0;

#ifdef FN
  footNoteRes = kNoChg; // fn1
#endif

  /*********************************************/
  /*      Measure Bullet at start of line      */
  /*********************************************/

  if (charPos == 0)
  {
#ifdef AUTONUM
    int numberReset = AutoNumberReset(this, myCurrency, origProc);
#else
#define numberReset FALSE
#endif

    if (gStyle.fcBullet != 0)
    {
      // DoBullet local proc
      int bulletPartWidth;

      // all this does is copy gCompositeStyle to gStyle!?  SetStyles(emphasis, FALSE);
      if (index > lastPart || formatAll || numberReset ||
          (Get(index, &linePart),
             linePart.fPartType != kBulletPart ||
             linePart.tag.fBullet[0] != gCompositeStyle.fcBullet ||
             linePart.fTextFont != gCompositeStyle.fcBulletFont ||
             linePart.fColour != gCompositeStyle.fcColour ||       // 29/08/90
             linePart.fTextSizeX != gCompositeStyle.fcTextSizeX ||
             linePart.fTextSizeY != gCompositeStyle.fcTextSizeY ||
             linePart.fAscent != gCompositeStyle.fcAscent ||
             linePart.fDescent != gCompositeStyle.fcDescent ||
             linePart.fLocation.h != (location - (backwards & linePart.fWidth))))
                                                            // 15/07/93 [20981]
        InitBullet(&linePart, location);    // 07/06/94, width);

      UpdateLineParts(linePart, index, lastPart); // 29/06/94 replace 2 * AtPut & InsertBef
      // 07/06/94 not done in InitBullet, so update location & width
      bulletPartWidth = linePart.fWidth + linePart.fSlop;
      location += (bulletPartWidth ^ backwards);
      width -= bulletPartWidth;
      index++;
    }
  }

  /**************************************************/
  /*  Start of main loop fitting parts on the line  */
  /**************************************************/

  widthStart1 = width;  // 19/11/92 looped in a bullet list as width was incremented
  indexStart1 = index;
  do
  {
    int thePartType = kTextPart;  // 14/09/90 so we can drop into MeasureRun
    int theResponse = kEndOfPara;         // so we can drop into kEOT case
    int incr = 0;
#ifdef FN
    bool doFit = TRUE; // 22/4/92
#else
#define doFit TRUE
#endif

    runType = gMainStruct->GetTextRun(charPos, runLength, runObject);
    switch (runType)
    {
    /****************/
    case kBeginStyle:
    /****************/
      emphasis = runObject;
      break;

#ifdef FN
    /****************/
    case kNote:
    /****************/
    // inline DoFootnote
    {
      char fnNum[6];
      TTextDocument myDoc = gMainStruct->fDocument;
  
      SetStyles(emphasis == 0 ? Curr_fRecnum(myDoc->fEmphasisStyle) :
                       emphasis, TRUE);   // 16/04/93 force size reset

      // 07/06/94 compute fn width before InitLinePart
      gMainStruct->GetNoteNumber(myCurrency, runObject, fnNum);
      linePart.fWidth = DoMeasure(fnNum, gStyle, FALSE);
      InitLinePart(gStyle, linePart, location - (linePart.fWidth & backwards), kNotePart);
      linePart.fCharPos = charPos;
      linePart.fNumChars = 1; // 14/7/92
      linePart.fTextFace |= GetTextDirection(); // set b/wds flag in line part
      linePart.tag.cgf_34.fRecNum = runObject;
      linePart.tag.cgf_34.fHasNote = 0; // fn2
      if (linePart.fWidth > width) // 22/4/92 note does not fit!
      {
        PLinePart p;

        runLength = -1;
        index--;
        p = PLinePart(At(index));
        charPos = p->fCharPos;  // 29/04/94 [21715] for hyphenation
        if (p->fPartType == kTextPart)
        {
          // try to hyphenate/break the footnoted word
          // charPos = p->fCharPos;
          runLength = p->fNumChars;   // 29/04/94 [21715] for hyphenation
          doFit = FALSE;
          goto measure;
        }
        // give up and put the footnote on the next line
        theResponse = kLineBreak;
        goto DoComplete;
      }
      else
      {
        width -= linePart.fWidth;
        location += (linePart.fWidth ^ backwards);
        charPos++;
        if (index > lastPart)
          InsertBefore(index, &linePart);
        else
          AtPut(index, &linePart);
        index++;
// 11/5/93   if (fMainView->fSelection->fReformatType != 12) // 17/12/93 kReformat9and99
        {
          int oldFmtState;
          int oldStructState;
          int oldProgress = HoldProgress(0);  // 12/04/94 do not update hourglass in note

          oldStructState = myDoc->LockCurrency(myCurrency, TRUE);
                                              // 11/04/94 [21615] fn body may purge
          oldFmtState = fMainView->LockCurrency(myCurrency, TRUE);  // 11/04/94 [21615]
          if (InSaveGlobals(myCurrency, NULL, runObject, NULL, NULL, origProc) >= kHeightChg)
                                                   // 11/5/93, 09/05/93 [20855] from ==
             footNoteRes = kHeightChg;
          myDoc->LockCurrency(myCurrency, oldStructState);   // 11/04/94 [21615]
          fMainView->LockCurrency(myCurrency, oldFmtState);  // 11/04/94 [21615]
          HoldProgress(oldProgress);         // 12/04/94 [21616] restore progress after note
        }
      }
      break; // 22/4/92
    }
#endif

    /****************/
    case kMacro:
    case kMacroOVL:    // 25/10/90 new clause
    /****************/
      // inline DoMacro() proc
      {
        if (runType == kMacro)
        {
          TTextDocument document = TTextDocument(fMainView->fDocument);
          TPageData pageInfo;
          Str255 str;
          bool replace;
          TCurrency theTitle;
          int theNumber = -1;
          bool aDate = TRUE;     // 05/02/93 [20615]
          TTextStructure saveMe = gMainStruct;   // 31/01/95 needed for 2 clauses
         
          theTitle = 0;
          fMainView->GetPageInfo(&pageInfo);
          replace = TRUE;
          switch (TMacroType(runObject >> 16)) // MMerge 13/5/92
          {
            case kTime:
              aDate = FALSE;
            case kDate:
              if (!(document->fAlwaysUpdate &&
                        (document->fReformatDates || TestInHF(gMainStruct))))
                            /* 30/01/94 TestInHF(this, myCurrency)))) */
                                    // 05/02/93 [20615] update dates on loading stationery
              {
                replace = FALSE;
                break;
              }
              // else drop on through
            case kNewDate:
              if (aDate)
              {
                // 28/01/92 blows up after failure in Reformat:       FailOSErr(
                IUDateString(document->fDateFormat, document->fCustomDate, str);
                break;
              }
              // else drop on through
            case kNewTime:
              // 28/01/92 blows up after failure in Reformat:      FailOSErr(
              IUTimeString(document->fTimeFormat, str);
              break;

            case kDocumentTitle:
              theTitle = pageInfo.docTitle;
              // drop on through
            case kChapterTitle:
              if (theTitle == 0)
                theTitle = pageInfo.chapTitle;
            // case kSectionTitle:
            //   if (theTitle == 0)
            //     theTitle = pageInfo.sectTitle;
              if (theTitle > 0)
              {
                TStructure structure = GetStructureReadOnly(theTitle);

                theTitle = structure->GetEnd(theTitle, TRUE);
                if (Curr_fType(theTitle) != kTextStruct)
                  theTitle = 0;
              }

              if (theTitle <= 0)
                str[0] = 0;
              else
              {
                // 23/02/94 Rewritten to
                //   i) [21416] do not stop when a widget found (avoiding strncpy)
                //  ii) [21417] use GetBuffer - so caps expanded and deletions not included
                // iii) [bonus] stop tidily on a word break if > 254 characters
                TTextStructure textStruct = TTextStructure(GetStructureReadOnly(theTitle));
                // 31/01/95 needed for 2 clauses TTextStructure saveMe = gMainStruct;
                Handle buffer;
                char *charPtr;
                char *lastSpace;

                SetTextGlobals(textStruct);
                charPtr = textStruct->
                               GetBuffer(0, MAXLONGINT, kLineBreakMixed, buffer, NULL);
                lastSpace = str;
                for (char *p = lastSpace; p < str + 254; )
                {
                  int ch = *(charPtr++);
                  if (ch <= 32)
                  {
                    lastSpace = p;
                    if (ch == chReturn)
                      break;
                    ch = ' ';
                  }
                  *(p++) = ch;
                }
                *(lastSpace) = 0;
                FreeBuffer(buffer);
                // 30/01/95 done for all clauses: SetTextGlobals(saveMe);
              }
              break;

#ifdef AUTONUM
            case 12:
              theNumber = CallNoteFunc(origProc, gNullCurrency, myCurrency); // 10/10/94 frig
              if (theNumber < 0)
              {
                 theNumber = -theNumber;
                 pageInfo.romanPages = TRUE;
              }
              else if (theNumber > 0)
                 pageInfo.romanPages = FALSE;
              else
                 replace = FALSE;      // went down the fast path
#endif
            case kPageNumber:
#ifdef AUTONUM
              if (theNumber < 0)
#endif
                theNumber = pageInfo.pageNum;
              // drop on through
            case kPagesInDocument:
              if (theNumber < 0)
                theNumber = pageInfo.docLength;
              // drop on through
            case kPagesInChap:
              if (theNumber < 0)
                theNumber = pageInfo.chapLength;
              Roman(theNumber, str, pageInfo.romanPages); // F for NumToString, T for lcRoman
              // if (pageInfo.romanPages)
              //   Roman(theNumber, str, kLowerRoman);
              // else
              //   NumToString(theNumber, str);
              break;

            // case kContinuationText:
            //   NotYetImplemented("Continuation Text");
            //   break;

            case kMergeField: // MMerge 13/5/92
              {
                int fieldIndex = runObject & 0xffff;
                
                if (!document->MergeActive())
                {
                  int fn;

                  gMainStruct->GetMacroText(charPos, str);
                  fn = document->GetFieldNumber(str);
                  if (fn != fieldIndex) // field number must be reset
                  {
                    int pn;
                    TPhrase phrase;

                    if (fn > 0)
                    {
                      pn = gMainStruct->GetPhraseAt(charPos, phrase, kMacroPhrase);
                      phrase.tag.macro.fMergeField = fn;
                      gMainStruct->AtPut(pn, &phrase);
                      fieldIndex = fn;
                    }
                    document->GetFieldValue(fieldIndex, str);
                  }
                }
                else
                  document->GetFieldValue(fieldIndex, str);
              }
              break;

            default:
              replace = FALSE;        // 10/10/94 pity this was not done originally
              break;
          }
          SetTextGlobals(saveMe);      // 30/01/95 done for all clauses
          if (replace)
          {
            int lengthOfMacro;
            if (str[0] == 0)
            {
                str[0] = chSpace;
                str[1] = 0;
            }
            gMainStruct->ReplaceMacroText(charPos, str);
            lengthOfMacro = strlen(str);
            incr = lengthOfMacro - runLength;
            runLength = lengthOfMacro;
          }
        }
        else
          incr = runLength;     // 25/10/91
        thePartType = kMacroPart;
      }
      // no break
    /****************/
    case kMeasureRun:
    /****************/
      // prev. DoMeasureRun() local procedure
#ifdef FN
measure: // fn1
#endif
      SetStyles(emphasis, FALSE); // fn1
      if (index <= GetSize())
        Get(index, &linePart);
// 03/09/92 pass to InitLinePart:      linePart.fPartType = thePartType;
                                       // if not a macro this is kTextPart
      // prev. MeasureRun() local procedure
      {
        bool wordWrap = TRUE;
        TPartType lastPartType;
        Size numSpaces;
        TLinePart oldPart;
        int newPartIndex = index;        // 18/06/94 this is set in both branches
        int hyphenation = kLineBreak;    // 24/10/90 new var

        // 24/08/93 [21034] this should be inside doFit test
        // InitLinePart(gStyle, linePart, location, thePartType);
        if (doFit) // 22/4/92 FALSE if the footnote at word end causes wrap
        {
          Fixed fitWidth = width;

          wordWrap = gMainStruct->Fit(charPos, kLineBreak,
                              runLength, numSpaces, fitWidth); // 24/10/90 extra param

          if (wordWrap && index == indexStart1 && runLength == 0)
          {
            runLength = 1;    // ??? 25/02/94 try and get at least 1 character on the line
            fitWidth = width;
          }
          width -= fitWidth;
          Fixed partLoc = 
            AdjustForDirectionChange(index, GetTextDirection(), fitWidth); // backwards

          // init line part moved after width (and thus location) of part computed
          InitLinePart(gStyle, linePart, location + partLoc - (fitWidth & backwards), thePartType);
          linePart.fCharPos = charPos;
          linePart.fWidth = fitWidth;
          linePart.fNumChars = runLength;
          linePart.fTextFace |= GetTextDirection(); // set b/wds flag in line part
          linePart.tag.cgf_35.fNumSpaces = numSpaces;
          linePart.tag.cgf_35.fTextCaps = gStyle.fcTextCaps;
          linePart.tag.cgf_35.fTab = tabField;
          linePart.tag.cgf_35.fFiller = 0;   // 05/03/91 clear hole

          if (runLength > 0)
          {
            location += (fitWidth ^ backwards);
            if (index > GetSize())
            {
              oldPart = linePart;
            }
            else
            {
              Get(index, &oldPart);
              // Is this just to get fChanged set? linePart.fSlop = oldPart.fSlop;
              linePart.fLocation.v = oldPart.fLocation.v;
            }
          }
        }
        //else
        //{
        //  moved up: newPartIndex = index;       // 24/08/93 [21034]
        //  wordWrap = TRUE; // 22/4/92
        //}

        if (runLength > 0 || wordWrap)  // 23/01/91 moved out of above condition
        {
          index++;
          charPos += runLength;

          if (wordWrap)
          {
            lastPartType = linePart.fPartType; // 14/09/90 instead of kTextPart
            if (lastPartType == kTextPart || lastPartType == kMacroPart) // || 03/02/92
              hyphenation = gMainStruct->
                                FindWordWrap(lineStart, charPos - lineStart, runLength);
            else
              runLength = 0;

            if (linePart.fCharPos + runLength <= lineStart)  // 24/08/93 [21034]
            {
              if (linePart.fNumChars != 0)                // 24/08/93 [21033] (with else)
                UpdateLineParts(linePart, newPartIndex, lastPart); // 29/05/90
              else
                index--;
              index--;  // 02/03/92 from index = indexStart1;     // 19/04/91
              // 31/07/90 tabField = FALSE;
            }
            else
            {
              charPos = linePart.fCharPos + runLength;
// 29/04/94 [21715]
//              if (doFit) // 22/4/92
//                charPos = linePart.fCharPos + runLength;
//              else // 22/4/92 added else
//              {
//                charPos += runLength;
//                newPartIndex = index;
//              }
              if (runLength < 0) // 22/4/92 was <=
              {
               // 28/05/91  result = kStructChg;          // 14/09/90 get out of fast path
                newPartIndex--;
                index = newPartIndex;
                while (!ContainsWordBreak(PLinePart(At(index)),
                        &lastPartType, &charPos, &tabField))
                  index--;
                if (newPartIndex > lastPart && newPartIndex > index)
                  do
                  {
                    Delete(index + 1);
                    newPartIndex--;
                  } while (newPartIndex != Max(lastPart, index));

                Get(index, &oldPart);      // 29/05/91 added
                if (oldPart.fChanged)
                  oldPart.fWidth = -1;     // 29/05/91 leave fChanged set
              }
              else if (runLength == 0)
              {
                lastPartType = kWidgetPart;    // so will be marked as changed???
                index -= 2;
                // compensate for adjusting previous parts, now that current part removed
                AdjustForDirectionChange(index + 1, linePart.fTextFace & kBackwards,
                                                          -linePart.fWidth); // backwards
              }
              else
              {
                UpdateLineParts(linePart, newPartIndex, lastPart); // 29/05/90
                index = index - 1;
              }

              if (lastPartType == kTextPart || lastPartType == kMacroPart) // 03/02/92
                AdjustLastPart(index, hyphenation, charPos);
            }
            index++;
#ifdef TRACE
            Assert(index >= 2, 806);   // 25/02/94 should be at least 2!!!
#endif
            if (alignTab)
              alignTab = DoAlignTab(index, tabInfo, tabSpace, width, location);
            LineReformat_r = CompleteLine(hyphenation, index, indexStart,
                         widthStart, formatAll, result, /*numChars,*/ charPos);
            reformatted = TRUE;
          }
          else // redundant test: if (runLength > 0)   // 14/09/90 added test for empty line
          {
            UpdateLineParts(linePart, newPartIndex, lastPart);
          }

          if (index > 1)
          {
            // prev. TestIfChanged(index) local proc
            int partNum = index - 1;
            PLinePart newPart = PLinePart(At(partNum));

            if (oldPart.fPartType == newPart->fPartType)
            {
              if ((newPart->fWidth                      == oldPart.fWidth) &&
                  (newPart->fLocation.h                 == oldPart.fLocation.h) &&
                  (newPart->fNumChars                   == oldPart.fNumChars) &&
                  (newPart->fCharPos                    == oldPart.fCharPos) &&
                  (newPart->fTextFont                   == oldPart.fTextFont) &&
                  (newPart->fTextSizeX                  == oldPart.fTextSizeX) &&
                  (newPart->fTextSizeY                  == oldPart.fTextSizeY) &&
                  (newPart->fTextFace                   == oldPart.fTextFace) &&
                  (newPart->fColour                     == oldPart.fColour) &&
                  (newPart->tag.cgf_35.fTextCaps        == oldPart.tag.cgf_35.fTextCaps) &&
                  (newPart->fAscent + newPart->fDescent == oldPart.fAscent + oldPart.fDescent) &&
                  (newPart->tag.cgf_35.fTab             == oldPart.tag.cgf_35.fTab) &&
                   oldPart.fSlop == 0)   // fSlop test forces change w/o complicating JustifyLine
              {
#ifdef TRACE
                Assert(newPart->fChanged, 405);  // if never hit, can just set to false
#endif
                newPart->fChanged = newPart->fChanged == 2 ||  // 22/10/93 [21094] inserted
#ifdef TRUE
                 oldPart.fChanged ||    // [26020] re-reformat for different view HF
#endif
                      formatAll || fMainView->fSelection->fReformatType == kReformatLine;
              //  || (anchor != NULL && TTextCursor(anchor)->GetCharPos() >= newPart->fCharPos &&
              //     TTextCursor(anchor)->GetCharPos() < newPart->fCharPos + newPart->fNumChars);
                linePart.fChanged = newPart->fChanged;
              }
            }
            else if (result < kHeightChg)      // 09/05/93 [20855] from !=
              result = kStructChg;
            // end of TestIfChanged(index) local proc

            if (partNum > lastPart && result < kStructChg)   // partNum for index - 1
                             // 19/02/92 footnote change, but needed for back wrap widgets
              result = kStructChg;

#ifdef TRACE
// hit!     Assert((linePart.fChanged != 0) == (newPart->fChanged != 0), 406);  // avoid copy to linepart.fCh?
#endif
            if (linePart.fChanged)
              SetHasChanged(TRUE);
          }
        }
      }
      // end of MeasureRun() local procedure
      // 25/05/94 [21430] do not update for kMacroPartOVL: thePartType == kMacroPart
      if (runType == kMacro && gActivePhrase.fCurrency != 0)
      {
        gActivePhrase.fNumChars += incr;
        gActivePhrase.fEndPos += incr;
      }
      // 16/06/91 repl by above: gActivePhrase.fEndPos = Max(gActivePhrase.fEndPos, charPos);
      tabField = FALSE;
      // end of DoMeasureRun() local procedure
      break;

    /****************/
    case kTabField:
    /****************/
      // prev. DoTab() local proc
      {
        bool found;
        Fixed margin;

        emphasis = 0;    // 11/04/91
        if (alignTab)
           alignTab = DoAlignTab(index, tabInfo, tabSpace, width, location);

        if (backwards)
        {
          found = gStyle.fcRuler->LastThat(this, (TestItem)BeforeTheTab, location, &tabInfo);
          margin = origWidth - fRightMargin;
          if (location > margin)
          { 
            if (found == 0 || tabInfo.fStop < margin)
            {
              tabInfo.fStop = margin;
              tabInfo.fKind = kRightTab;
              tabInfo.fFiller[0] = 0;
              found = TRUE;
            }
          }
        }
        else
        {
          // inline: found = gStyle.fcRuler->FindTab(location + kFix1, tabInfo);
          found = gStyle.fcRuler->FirstThat(this, (TestItem)AfterTheTab, location, &tabInfo);
          margin = fLeftMargin;
          if (location < margin)
          { 
            if (found == 0 || tabInfo.fStop > margin)
            {
              tabInfo.fStop = margin;
              tabInfo.fKind = kLeftTab;
              tabInfo.fFiller[0] = 0;
              found = TRUE;
            }
          }
        }
        if (found)
        {
          tabSpace = (tabInfo.fStop - location) ^ backwards;   // negate if b/wds so +ve
          if (tabSpace > width)
            width += (&fRightMargin)[backwards];
                    // release margin if tab after/before right/left margin
          if (tabSpace > width)
            found = FALSE;
        }

        if (!found)
        {
          Fixed quadSpace;
          Fixed fromEdge = (backwards ? widthStart1 - location : location - 
                   Min(gStyle.fcRuler->GetIndentation(), gStyle.fcRuler->GetLeftMargin()));

          tabInfo.fFiller[0] = 0;  // 29/05/90
#ifdef NETWP
          quadSpace = gMainStruct->fDocument->fDfltTab;
          if (quadSpace == 0)
            quadSpace = 360000;  // 17/10/96 [27112] Word uses 1/2 inch default
#else
          quadSpace = DoMeasure("MMMM", gCompositeStyle, FALSE);
#endif
          tabSpace = quadSpace - (fromEdge % quadSpace); // a lot faster!!
          if (tabSpace > width)
            tabSpace = width;                 // 22/03/91
        }
        else if (tabInfo.fKind == (backwards & kRightTab))  // left (or right if b/wds) tab
          found = FALSE;     // found == FALSE now means call CompleteTabFiller

        // in-line:
        //  PrimeTabFiller(linePart,location,tabInfo,index,formatAll,charPos);
        {
          InitLinePart(gStyle, linePart,
                         location - (backwards && !found ? tabSpace : 0), kFillerPart);
          linePart.fWidth = 0;
          linePart.fCharPos = charPos;  // 31/07/90 - new
          strcpyn(linePart.tag.fTabFiller, tabInfo.fFiller, kFillerLen);

          if (index > lastPart)              // 23/01/91 GetSize())
            InsertBefore(index, &linePart);  // 23/01/91 from InsertLast
          else
          {
            // prev. TestIfChanged(index) local proc
            {
              int partNum = index;
              register PLinePart cgf_145 = PLinePart(At(partNum));

              if (linePart.fPartType == cgf_145->fPartType)
              {
                linePart.fWidth = cgf_145->fWidth;
                linePart.fNumChars = cgf_145->fNumChars;
                if ((cgf_145->fTextFont != linePart.fTextFont) ||
                    (cgf_145->fTextSizeX != linePart.fTextSizeX) ||
                    (cgf_145->fTextSizeY != linePart.fTextSizeY) ||
                    (cgf_145->fColour != linePart.fColour) ||
                    ((cgf_145->fTextFace & ~kBackwards) != linePart.fTextFace) ||
                    strncmp(cgf_145->tag.fTabFiller, linePart.tag.fTabFiller, kFillerLen))
                                     // 24/05/91 put in the condition
                {
                  // do nothing
                }
                else
                  linePart.fChanged = formatAll;
              }
              else if (result < kHeightChg)      // 09/05/93 [20855] from !=
                result = kStructChg;
            }
            // end of TestIfChanged(index) local proc
            AtPut(index, &linePart);
          }
          if (linePart.fChanged)
            SetHasChanged(TRUE);
          index ++;
        }
        // end in-line PrimeTabFiller

        if (!found)              // LeftTab or RightTab (going b/wds) or quad tab
        {
          // we can complete the action now as we have all the info to do any tab filler
          width -= tabSpace;
          location += tabSpace ^ backwards;
          CompleteTabFiller(tabSpace, index - 1, tabInfo);
        }
        else
        {
          // wait until DoAlignTab on the next time around!
          if (tabInfo.fKind == kMarkTab)
            gMarkCh = tabInfo.fMark;
          alignTab = TRUE;
        }
        tabField = TRUE;
        charPos++;
        // end of DoTab() local proc
      }
      break;

    /****************/
    case kMarkCh:
    /****************/
      alignTab = DoAlignTab(index, tabInfo, tabSpace, width, location);
      // no break;

    /****************/
    case kEndStyle:
    /****************/
      emphasis = 0;    // 23/01/91 not gNullCurrency;
      break;

    /****************/
    case kWidget:
    /****************/
      // prev. DoWidget() local proc
      {
        TFormat widget;
        Fixed widgetWidth;
        TChangeTypes response;
        TCursorNode node1, node2;
        // TCurrency curr1, curr2;
        long asc, desc;
        bool sameWidget = FALSE;  // [20866] 12/05/93
#ifdef FN
        TTextReformatVars v;

        v.vars.obj = this;          // 06/09/90 done here just the once
        v.vars.procToDo = (DoNote) _TTextFormat::FormatNote;
        // [20866] 11/5/93  v.hasNote = 0;
        v.origProc = origProc;
#endif
        if (index <= GetSize())
        {
          Get(index, &linePart);
          // [20866] 12/05/93 see if dealing with same widget
#ifdef FN
          v.hasNote = linePart.tag.cgf_34.fHasNote; // [20866] 11/5/93
#endif
          if (linePart.fPartType == kWidgetPart &&
               linePart.tag.cgf_34.fRecNum == runObject)
            sameWidget = TRUE;
        }
        else
        {
          linePart.fPartType = kWidgetPart;       // 04/03/92 new else
          linePart.tag.cgf_34.fRecNum = 0; // 03/09/92
        }
        widget = GetFormatReadWrite(runObject);
        node1 = (anchor == NULL ? NULL : anchor->GetNext());
        if (node1 == NULL || node1->fCurrency != runObject)
          node1 = NULL;
        node2 = (activeEnd == NULL ? NULL : activeEnd->GetNext());
        if (node2 == NULL || node2->fCurrency != runObject)
          node2 = NULL;
        // curr1 = (node1 == NULL ? 0 : node1->fCurrency);
        // curr2 = (node2 == NULL ? 0 : node2->fCurrency);
        // if (formatAll || curr1 == runObject || curr2 == runObject || !sameWidget)
        if (formatAll || node1 || node2 || !sameWidget)
               // [20866] 11/5/93 force reformat if not same widget to set hasNotes properly
        {
#ifdef FN
          v.hasNote = 0; // [20866] 11/5/93
          response =
            InSaveGlobals(myCurrency, widget, runObject, node1, node2, PStdNoteVars(&v));
#else
          response = InSaveGlobals(myCurrency, widget, runObject, node1, node2, origProc);
#endif
          result = (response < kStructChg ? kStructChg : response); // 18/02/92
          // 20/02/92 new loop
          if (!formatAll && result >= kHeightChg)  // 09/05/93 [20855] from ==
            for (int n = index + 1; n <= GetSize(); n++)
              SetChanged(n, TRUE);
        }
        else
        {
          response = kNoChg;
        }
        widgetWidth = ToFixed(widget->GetWidth());
        theResponse = kLineBreak;
        if (widgetWidth <= width || width == widthStart1)   // it fits or first thing on line
        {
          linePart.fWidth = widgetWidth;
          linePart.fSlop = 0;
          asc = (gStyle.fcAscent - gStyle.fcDescent) / 2;  // 01/07/92 the minus-height
          widget->GetDepth(asc, desc);
          linePart.fAscent = asc;
          linePart.fDescent = (gStyle.fcFixedHeight ? gStyle.fcDescent : desc);
          linePart.fTextFont = 0;
          linePart.fTextSizeX = 0;
          linePart.fTextSizeY = 0;
          linePart.fTextFace = 0;
          linePart.fColour = 0;
          linePart.fCharPos = charPos;
          charPos++;
          linePart.fNumChars = 1;
          linePart.fEOL = 1;
#ifdef FIXLOC
          Fixed newLoc = location - (widgetWidth & backwards);
#else
          linePart.fLocation.h = FixRound(location);
#endif
          // 02/06/92 avoid setting linePart.fLocation.v = 0 if only moved sideways
          if (formatAll || response != kNoChg || index > GetSize() || !sameWidget)
                    // 12/05/93 sameWidget worked out above
                    // linePart.fPartType != kWidgetPart ||
                    // linePart.tag.cgf_34.fRecNum != runObject)
                    // 03/09/92 2 new tests for deleting everything in front of widget
          {
            linePart.fLocation.v = 0;
            linePart.fChanged = TRUE;
          }
#ifdef FIXLOC
          else if (newLoc != linePart.fLocation.h)
            linePart.fChanged = TRUE;
          linePart.fLocation.h = newLoc;
#else
          else if (linePart.fLocation.h != PLinePart(At(index))->fLocation.h)
            linePart.fChanged = TRUE;
#endif
          if (linePart.fChanged)
            SetHasChanged(TRUE);
          // 04/03/92 for tabs & macros
          if (result < kHeightChg &&      // 09/05/93 [20855] from !=
                               linePart.fPartType != kWidgetPart)
            result = kStructChg;
          linePart.fPartType = kWidgetPart;
          linePart.tag.cgf_34.fRecNum = runObject;
#ifdef FN
          linePart.tag.cgf_34.fHasNote = v.hasNote;
#else
          linePart.tag.cgf_34.fHasNote = 0;
#endif
          location += (widgetWidth ^ backwards);
          width -= widgetWidth;
          if (index > lastPart)            // 23/01/91  from GetSize())
            InsertBefore(index, &linePart); // 23/01/91  from insertLast
          else
            AtPut(index, &linePart);
          index++;
        }
        else     // widget does not fit on line
          goto DoComplete;
      }
      break;

    /****************/
    case kEOL:
    /****************/
      theResponse = kLineFeed;
      result = kStructChg;             // 03/04/91 for opt return
      // no break

    /****************/
    case kEOT:
    /****************/
DoComplete:
      if (alignTab)
        alignTab = DoAlignTab(index, tabInfo, tabSpace, width, location);
      LineReformat_r = CompleteLine(theResponse, index, indexStart,
                   widthStart, formatAll, result, /*numChars,*/ charPos);
      reformatted = TRUE;
      break;
    }
  } while (!reformatted && (loopLim--) > 0);

#ifdef FN
// 09/05/93 [20855]  if (footNoteRes == kHeightChg)
// 09/05/93 [20855]    result = kHeightChg;
  if (footNoteRes >= kHeightChg)
    result = footNoteRes;
#endif

  // 23/01/91 new loop
  for (int idx = lastPart; idx >= index; idx--)
    Delete(idx);

  Assert(loopLim > 0, 192);

  // 20/02/92 added conditional to trigger Fit on a line height change
  // 5/10/92 added oldLineDepth test to stop HeightChgd being returned unnec after clear (BS/FwdDel)
  if (result < kHeightChg &&      // 09/05/93 [20855] from !=
                     fMainView->IsRegistered(myCurrency) && oldLineDepth > 0)
  {
    int lineAsc1;
    int lineDesc1;
#ifdef FN
    int footCount1 =      // 10/05/93 [20861]
#endif
      GetLineDepth(indexStart, lineAsc1, lineDesc1, indexStart);

    if (oldLineDepth != lineAsc1 + lineDesc1
#ifdef FN
                 || footCount1 != footCount  // 10/05/93 [20861]
#endif
       )
      result = kHeightChg;
  }
  if (result < kHeightChg &&      // 09/05/93 [20855] from !=
                             (index != lastPart + 1))
    result = kStructChg;
  return(LineReformat_r);
}

#ifdef TRACE
static gStartVal;
#endif
// ------------------------------------------------------------------------
TCharPos _TTextFormat::GetNextLineStart(int partNum, int *numParts, bool after)
// 17/02/92 new 21/02/92 extra param
{
  int index;
  TCharPos charPos;

  if (partNum > fSize)
  {
    *numParts = 0;
    charPos = -1;
  }
  else
  {
    PLinePart part;
    int brk;

    *numParts = 1;
    index = partNum;
    while ((brk = GetEOL(index)) > kLineBreak)
    {
      index++;
      (*numParts)++;
    }
    if (after || index == fSize)
    {
      part = PLinePart(At(index));
      charPos = part->fCharPos + part->fNumChars;
      if (IsLineBreak(brk))
      {
        // 13/01/94 int num = MAXINT;

        charPos = gMainStruct->SkipLeadingSpaces(charPos);  // 13/01/94, num);
        if (index + after == fSize + 1)
                // 13/01/94 [21335] after == T && index == fSize && not at end of para
        {
#ifdef TRACE
          Assert(gStartVal != charPos, 927);  // if equal you will have no end of para part!
#endif
          return -1;
        }
      }
    }
    else
      charPos = PLinePart(At(index + 1))->fCharPos;
  }
  return charPos;
}


// ------------------------------------------------------------------------
void _TTextFormat::CursorReformat(TCurrency currency, TCursorNode anchor,
                        TCursorNode activeEnd, int fitToWidth, 
                        PStdNoteVars origProc, TChangeTypes &result)
{
  int partNum;
  int firstPart;
  int index;
  int change;
  Fixed lineWidth;
  int response;
  TTextEdge IP;
  bool revWrap;
  int numParts;
  int eol;
  int sz;
  TCharPos nextLineStart;
  int saveExtraInsert;

  // 29/05/90 - method totally changed

  TTextCursor(anchor)->GetEdge(IP);
  partNum = Max(1, Min(GetSize(), IP.fPartNum));

// [20953] set after next loop: firstPart = partNum;
  change = TTextCursor(anchor)->GetChange();
  TTextCursor(anchor)->SetChange(0);            // 25/04/91

  if (change < 0)
  {
    // 21/07/93 [20953] the above went wrong if change went through > 1 line part
    // e.g. deleting quickly through Shift-return. Also needs to reset partNum to
    // start part of line you end up on, not the one you start from.
    PLinePart cgf_165;

#ifdef TRACE
    if (change != -1)
      BeepBreak();
#endif
    while (cgf_165 = PLinePart(At(partNum)),
          (cgf_165->fCharPos > IP.fCharPos + int(cgf_165->tag.cgf_35.fTab)))
      partNum--;
  }
  firstPart = partNum;

  eol = 1;

  while (partNum > 1)
  {
    eol = PLinePart(At(partNum - 1))->fEOL;
    if (eol > kLineBreak)                     // 24/10/90 kLineBreak for 0
      partNum--;
    else
      break;
  }

  // 09/07/91 find if wrap needed
  if (partNum > 1 &&
             (TTextCursor(anchor)->GetReverseWrap() || IsLineBreak(eol)))
  {
    TCharPos endPos = IP.fCharPos;

    if (change > 0)
      endPos -= change;
    revWrap = TRUE;
    for (int cp = PLinePart(At(partNum))->fCharPos; cp < endPos; cp++)
    {
      if (!InWordSyms(gMainStruct->GetChar(cp)
#if SIDEBAR == 1
                             & 0x0ff
#endif
                     , BreakTable(-1)))
      {
        revWrap = FALSE;
        break;
      }
    }
  }
  else
    revWrap = FALSE;

  if (revWrap /* 15/02/91 && IsLineBreak(PLinePart(At(partNum -1))->fEOL) */)
  {
    do
    {
      partNum --;
    } while (partNum != 1 && PLinePart(At(partNum -1))->fEOL > kLineBreak);
  }
  sz = GetSize();
  for (index = partNum; index <= sz; index++)
  {
    register PLinePart pl = PLinePart(At(index));

    if (index == firstPart)
      pl->fNumChars += change;
    else if (index > firstPart)
      pl->fCharPos += change;
  }

  lineWidth = ToFixed(fitToWidth);
  response = 0;

  saveExtraInsert = gExtraInsert;
        // [26020] if macro expansion size change matches the number of characters inserted, the
        // algorithm for determining that reformatting parts can stop, finishes prematurely
  do
  {
#ifdef TRACE
    gStartVal =
#endif
    nextLineStart = GetNextLineStart(partNum, &numParts, FALSE);
    gExtraInsert = 0;   // [26020]
    response = LineReformat(currency, partNum, partNum + numParts - 1 /* numParts */,
                         /* numChars,*/ anchor, activeEnd, lineWidth, origProc, result);
    if ((nextLineStart == GetNextLineStart(partNum - 1, &numParts, TRUE) && gExtraInsert == 0) ||
                                         revWrap)
    {
      if (revWrap)
        revWrap = FALSE;
      else if (response >= 0)
        response = -MAXINT;
    }
  } while (response > kEndOfPara);
    // 30/04/92 did not work: && (response != kLineFeed || partNum > fSize)); // 29/04/92 

  gExtraInsert = saveExtraInsert;          // [26020] restore in case nested
  if (response == kEndOfPara)              // 24/10/90 kEndOfPara for -1
    ReduceSize(partNum - 1);
#ifdef TRACE
  {
    TCurrency lastCurr;
    PLinePart testPart;

    lastCurr = -9;
    for (int x = 1; x <= fSize; x++)
    {
      testPart = PLinePart(At(x));
      if (testPart->fPartType == kWidgetPart)
      {
        Assert(lastCurr != testPart->tag.cgf_34.fRecNum
         || testPart->tag.cgf_34.fRecNum == 0 , 567);
        lastCurr = testPart->tag.cgf_34.fRecNum;
      }
    }
  }
#endif
}


// ------------------------------------------------------------------------
int _TTextFormat::GetLineDepth(int index, int &theAscent, int &theDescent, int &numParts)
{
  PLinePart linePart;
  int fnCount = 0;
  int ascent = 0;
  int descent = 0;

  numParts = 0;

  while (index <= fSize &&
    (
      numParts++,
      linePart = PLinePart(At(index)),
      // 25/07/90 - added Min() bit below
      //  ascent = Max(ascent, linePart->fAscent + Min(linePart->fLocation.v, 0)),
      //  descent = Max(descent, linePart->fDescent),
      ascent = Max(ascent, linePart->fAscent + linePart->fLocation.v),
      descent = Max(descent, linePart->fDescent + linePart->fAscent + linePart->fLocation.v),
#ifdef FN
      fnCount += (linePart->fPartType == kWidgetPart && linePart->tag.cgf_34.fHasNote) ||
                     linePart->fPartType == kNotePart,   // 10/05/93 [20861]
#endif
      linePart->fEOL > kLineBreak
    ))
    index++;
  theAscent = ascent;
  theDescent = descent - ascent;
  return fnCount;       // 10/05/93 [20861]
}


// ------------------------------------------------------------------------
void _TTextFormat::Reset(TCursorNode node, TCurrency currency)
{
  TTextEdge IP;

  if (node == NULL || node->fCurrency != currency ||
                                !node->IsLast())  // 13/01/92 last test added
    return;

  TTextCursor(node)->GetEdge(IP);

  // 20/11/92 Rewritten to produce a similar value to ResetCursor when widget wrapped
  if (IP.fPartNum != 0)  // do (constant) test outside, rather than in LastThat
    IP.fPartNum = LastThat(this, (TestItem)_TTextFormat::ContainsCharPos2, IP.fCharPos);
                          // can use ContainsCharPos2 instead of ContainsCharPos
  if (IP.fPartNum <= 0)
    IP.fPartNum = 1;
  else if (node->IsLast())    // 20/11/92 this is the new test which may reset partnum
  {
    PLinePart p = PLinePart(At(IP.fPartNum));

    if (p->fPartType == kWidgetPart)
      IP.fPartNum = Max(1, IP.fPartNum + (p->fCharPos == IP.fCharPos ? - 1 : 1));
  }
  TTextCursor(node)->SetEdge(IP);
}


// ------------------------------------------------------------------------
bool _TTextFormat::HasLinePart(PLinePart linePart, TCharPos charPos)
{
  return (linePart->fCharPos + linePart->fNumChars >= charPos && linePart->fCharPos < charPos);
}

#ifdef FN
// ------------------------------------------------------------------------
static int CountNotes(TTextFormat format)
{
  int count = 0;
  for (int n = 1; n <= format->fSize; n++)
  {
    PLinePart p = PLinePart(format->At(n)); // [20866] 11/5/93 2lines
    if (p->fPartType == kNotePart || (p->fPartType == kWidgetPart && p->tag.cgf_34.fHasNote))
      count++;
  }
  return count;
}
#endif

// ------------------------------------------------------------------------
TChangeTypes _TTextFormat::Reformat(TCurrency currency, TCursorNode anchor,
     TCursorNode activeEnd, int fitToWidth, Fixed gapHalf, PStdNoteVars origProc)
{
  TChangeTypes  Reformat_r;
  int partNum;
  Fixed lineWidth;
  TStyleFormat itsTextStyle;
  long asc1, desc1;
  long asc2;
  long desc2;
  TCharPos charPos;
  TChangeTypes result;
  int part;
  Rect custom;
  VRect ruleWidths;
  int oldPartCount;
  bool fastPath;  // 29/05/90
#ifdef FN
  int numNotes;
#endif

  gLastCh = chUndef;    // 18/07/91 RSP left set by Failure

  if ((anchor != NULL) && (TTextCursor(anchor)->fReformat > kWidthChg))  
        // [20849] 27/4/93 && anchor->IsCursor(activeEnd)
  {
    Reformat_r = TTextCursor(anchor)->fReformat;
    TTextCursor(anchor)->fReformat = kNoChg;
  }
  else
  {
    SetHasChanged(FALSE);
    oldPartCount = GetSize();
    _TTextFormat::GetDepth(asc1, desc1);
    fastPath = (fitToWidth < 0);
    if (PreFormat(currency, part, custom, ruleWidths, itsTextStyle, result, gapHalf))
    {
#ifdef FN
      numNotes = CountNotes(this);
#endif
      SetTextGlobals(TTextStructure(GetStructure(currency)));  // Need to make ReadOnly!
      // Set flag for overall backwards text // fFlags = 
      itsTextStyle->SelectStyle(TTextDocument(fMainView->fDocument),
                 gCompositeStyle, kNoEmphasis);   // 29/04/91 document param added

      if (fitToWidth > 0)
      {
        SetHasChanged((fHasChanged || ((part > 0) && (fSetWidth != fitToWidth))));
        fSetWidth = fitToWidth;
        fMinWidth = fSetWidth;
      }
      else if (fastPath)
        fitToWidth = fSetWidth;  // 29/05/90
      else
        fSetWidth = 0;           // 19/03/91

      memcpy(&gStyle, &gCompositeStyle, sizeof(TStyle));
      if ((anchor == activeEnd) && (anchor != NULL) && (part == 0))
      {
        CursorReformat(currency, anchor, activeEnd, fitToWidth, origProc, result);
      }
      else
      {
        if ((anchor == NULL) || (anchor->fCurrency != currency) || (part != 0))
          partNum = 1;
        else
        {
          partNum = TTextCursor(anchor)->GetPartNum();
          if (partNum == MAXINT)
          {
            charPos = TTextCursor(anchor)->GetCharPos();
            partNum = FirstThat(this, (TestItem)_TTextFormat::HasLinePart, charPos);
          } 
          partNum = Max(1, partNum - 1);
        }

        do {
          lineWidth = ToFixed(fitToWidth);
        } while (LineReformat(currency, partNum, fSize, anchor, activeEnd,
                    lineWidth, origProc, result) != kEndOfPara);
        ReduceSize(partNum - 1);
        if (anchor != NULL)                // 12/07/91 reverse wrap in emph
          TTextCursor(anchor)->SetChange(0);
      }

      // prev. CalcDepth(asc2, desc2) local proc
      {
        int partNum = 1;
        int lastPart = GetSize();

        asc2 = FixRound(ruleWidths.top);
        desc2 = FixRound(ruleWidths.bottom);

        do
        {
          int asc;
          int desc;
          int numParts;

          GetLineDepth(partNum, asc, desc, numParts);
          if (partNum == 1)
          {
            asc2 += asc;
            asc = 0;
          }
          desc2 += (asc + desc);
          partNum += numParts;
        } while (partNum <= lastPart);
      }
      // end of CalcDepth(asc2, desc2) local proc

      SetDepth(asc2, desc2);

      if (result < kHeightChg)  // 09/05/93 [20855]
      {
        if (asc1 + desc1 != asc2 + desc2 || gLinkStruct != NULL)
          result = kHeightChg;
        else if (asc1 != asc2)
          result = kAscentChg;
      }

      if (part == 0)
      {
        Reset(anchor, currency);
        if (anchor != activeEnd)
          Reset(activeEnd, currency);
      }
      // 23/09/92 moved into this block from after FreeIfObject
#ifdef FN
      if (numNotes != CountNotes(this))
        result = kFootnoteChg;           // 09/05/93 [20855] from kHeightChg
      else
#endif
      if (result == kWidthChg &&
       (oldPartCount != GetSize() || part > 0))
                  // 14/11/91 removed || !gMainStruct->CanTypeFast()))
                  // 14/03/91 - added fittowidth replaced by CanTypeFast
                  // 16/06/91 from part != 0
        result = kStructChg;
      if (fastPath && anchor != NULL)            // 24/05/91 && test
        TTextCursor(anchor)->fReformat = result; // 29/05/90
    }

    FreeIfObject(itsTextStyle);

    Reformat_r = result;
  }
  return(Reformat_r);
}

#ifdef TABLES
// ------------------------------------------------------------------------
static bool TestStyles(TObject ignored, TEditedStyles *edits, PPhrase phrase,
                                                        TSelection selection)
{
  // 17/05/94 like tdstruct version, changed to return TRUE if the structure updated
  //  bool TestStyles_r = TRUE;

  if (edits->fEmphasis)
  {
    if ((unsigned int)edits->fAction <= 1 ||    // action == 0 or 1
              (edits->fAction < 0 && edits->fBaseChanges != 0 &&
            (phrase->tag.txt.fChanges == Curr_fRecnum(edits->fBaseChanges) ||
         phrase->tag.txt.fUndoChanges == Curr_fRecnum(edits->fBaseChanges))))
    {
      if (Curr_fRecnum(edits->fBaseStyle) == phrase->tag.txt.fStyle)
      {
        phrase->tag.txt.fUndoStyle = phrase->tag.txt.fStyle;
        phrase->tag.txt.fStyle = Curr_fRecnum(edits->fNewStyle);
        if (edits->fAction != 1 &&
                    phrase->tag.txt.fChanges == Curr_fRecnum(edits->fBaseChanges))
        {
          phrase->tag.txt.fUndoChanges = phrase->tag.txt.fChanges;
          phrase->tag.txt.fChanges = 0;
        }
        return TRUE;
      }
      if (Curr_fRecnum(edits->fBaseStyle) == phrase->tag.txt.fUndoStyle)
      {
        phrase->tag.txt.fStyle = phrase->tag.txt.fUndoStyle;
        if (edits->fAction == 1)
          phrase->tag.txt.fUndoStyle = 0;
        else
          phrase->tag.txt.fChanges = phrase->tag.txt.fUndoChanges;
        return TRUE;
      }
    }
  }
  return FALSE;
}
#endif

#ifdef FN
// ------------------------------------------------------------------------
// 16/05/94 [21807] See whether we need to reformat further because of chgs in a footnote
static bool IsWidgetOrFnPhrase(TTextStructure structure, PPhrase phr)
{
  return phr->fKind == kNotePhrase
#ifdef MATHS
       || (phr->fKind == kWidgetPhrase && Curr_fType(phr->tag.fRecNum) == kMathStruct)
#endif
        ;
}
#endif

// ------------------------------------------------------------------------
bool _TTextFormat::PreFormat(TCurrency currency, int &part, Rect &custom,
          VRect &ruleWidths, TStyleFormat &theStyle, TChangeTypes &result, Fixed gapHalf)
{
  bool  PreFormat_r;
  TSelection selection;
  TReformatTypes reformatType;
  TTextStructure structure;

  PreFormat_r = FALSE;  // 29/05/90
  selection = fMainView->fSelection;
  reformatType = selection->fReformatType;
  theStyle = NULL;
  result = kNoChg;
  structure = TTextStructure(GetStructureReadOnly(currency));       // 17/05/94 RW
                           // 15/10/90 moved so that fLanguage can be set
  if (reformatType == kReformatMacros)
  {
    if (structure->FirstThat(structure, (TestItem)_TTextStructure::IsMacroPhase) > 0)
      PreFormat_r = _TFormat::PreFormat(currency, part, custom, ruleWidths,
                                    theStyle, result, gapHalf);
  }
#ifdef TABLES
  else if (reformatType == kSelSaveAll)
  {
    bool chgd;
    TStyleFormat changes;

    // 13/05/91 do not free myself!   if (MemSpaceIsLow())
    //                                  document->Purge();
    changes = GetStyleReadOnly(selection->fAppliedChgs);
    //    selection->GetSaveStyles(oldStyle, newStyle);
    chgd = FALSE;
    if (changes->fDefined & kEmphasis)
    {
      // in-line DoApplyChanges
      int sz = structure->GetSize();  // 29/05/90

      for (int pn = 1; pn <= sz; pn++)
      {
        register PPhrase phrase = PPhrase(structure->At(pn));
        if (phrase->fKind == kTextPhrase) // 22/6/92 fix to avoid leaving unused style #
        {
          if (phrase->tag.txt.fStyle == Curr_fRecnum(selection->fStyleToUpdate)
#ifdef MATHS
               // 03/08/92 conditional on MATHS 16/05/94: TTextDocument(fMainView->fDocument)
             && !structure->fDocument->IsMathSymbol(phrase->tag.txt.fStyle)
#endif
               )
          {
            int appliedChg = Curr_fRecnum(selection->fAppliedChgs);

            chgd = TRUE;
            if (phrase->tag.txt.fChanges == appliedChg)
            {
              GetStructureReadWrite(currency);     // 17/05/94 mark RW if really changed
              phrase->tag.txt.fChanges = 0;
              phrase->tag.txt.fUndoChanges = appliedChg;
            }
            else if (phrase->tag.txt.fUndoChanges == appliedChg)
            {
              GetStructureReadWrite(currency);     // 17/05/94 mark RW if really changed
              phrase->tag.txt.fUndoChanges = 0;
              phrase->tag.txt.fChanges = appliedChg;
            }
          }
          else if (phrase->tag.txt.fChanges == Curr_fRecnum(selection->fStyleToUpdate))
            chgd = TRUE;   // 22/6/92 check if changes matches & reformat if it does
            // else chgd =
            // (chgd || phrase->tag.txt.fChanges == Curr_fRecnum(selection->fStyleToUpdate));
        }
      }
      // end in-line DoApplyChanges
    }
    else
      chgd = TRUE;

    if (chgd)
      PreFormat_r = _TFormat::PreFormat(currency, part, custom, ruleWidths,
                                                         theStyle, result, gapHalf);
  }
  else if (reformatType == kReformatEdits)
  {
    // 13/05/91 do not free myself!   if (MemSpaceIsLow())
    //                                  document->Purge();
    // in-line DoApplyStyleEdits
    int sz = structure->GetSize();  // 29/05/90

    for (int pn = 1; pn <= sz; pn++)
    {
      register PPhrase phrase = PPhrase(structure->At(pn));

      if (phrase->fKind == kTextPhrase && 
        selection->fEditedStyles->FirstThat(this, (TestItem)TestStyles, phrase, selection))
          GetStructureReadWrite(currency); // 17/05/94 mark as RW only if the phrase updated
    }
    // end in-line DoApplyStyleEdits
    PreFormat_r = _TFormat::PreFormat(currency, part, custom, ruleWidths,
                                                         theStyle, result, gapHalf);
  }
#endif
  else
  {
    if (reformatType != kReformatChgs || structure->fTempFlag
#ifdef FN
            // 16/05/94 [21807] need to reformat (possible) changes in footnotes too
           || structure->FirstThat(structure, (TestItem)IsWidgetOrFnPhrase)
#endif
           )
    {
      PreFormat_r = _TFormat::PreFormat(currency, part, custom, ruleWidths,
                                theStyle, result, gapHalf);
      if (reformatType == kReformatChgs)
      {
        if (structure->fTempFlag)
          SetHasChanged(TRUE);  // 25/07/90 - NEW if.. clause
        structure->fTempFlag = FALSE;
      }
      else if (reformatType == kSelSlow)          // 25/03/91 new clause
        part = 1;
    }
  }

  // set up language field in structure
  if (theStyle != NULL)
  {
    // 17/05/94 Only do RW if the structure really needs changing!
    if (structure->fLanguage != theStyle->fLanguage)
      TTextStructure(GetStructureReadWrite(currency))->fLanguage = theStyle->fLanguage;

    if ((theStyle->fDefined & kBullet) != 0 &&
                   GetStructure(structure->fParent)->GetKind() != kList)
      theStyle->fDefined &= ~kBullet;          // 15/02/91 remove bullet
  }
  return(PreFormat_r);
}


// ------------------------------------------------------------------------
TTextBreak _TTextFormat::EstablishTextBreak(int index, int amountThatFits, int nextNoteIdx)
{
  return new _TTextBreak(PartToLine(this, index - 1), amountThatFits, nextNoteIdx);
}


// ------------------------------------------------------------------------
#ifdef FN
// 22/4/92 added noteSpace param
bool _TTextFormat::FitNotes(int index, int numParts, int pageNumber,
                            int maxAvailable, bool &cantFitNotes, 
                            int &nextNoteIdx, int &noteSpaceUsed, int noteSpace,
                            int &spaceAvailable, PStdFitNoteVars origProc)
{
  bool  FitNotes_r = TRUE;
  int saveSpaceAvailable;
  int partNum;
  bool allFits;
  int origNoteSpace; // 22/4/92

  cantFitNotes = TRUE;
  nextNoteIdx = index;
  for (partNum = index; partNum <= index + numParts - 1; partNum++)
  {
    register PLinePart part = PLinePart(At(partNum));

    if (part->fPartType == kNotePart)
    {
      saveSpaceAvailable = spaceAvailable;
      // noteSpace = 0 on 1st pass, +ve on second pass unless last col when -ve
      if (noteSpace > 0) // 22/4/92
        spaceAvailable = noteSpace;
      else if (noteSpace < 0) // [20871] 13/5/93
        spaceAvailable = Min(spaceAvailable, -noteSpace); // 23/7/92
      origNoteSpace = spaceAvailable; // 22/4/92
      if (!CallFitNoteProc(origProc, part->tag.cgf_34.fRecNum,
                   allFits, spaceAvailable))
      {
        FitNotes_r = FALSE;
        spaceAvailable = saveSpaceAvailable;   // [20871] 19/5/93 
        break;
      }
      cantFitNotes = FALSE;
      noteSpaceUsed += origNoteSpace - spaceAvailable; // 22/4/92
      if (noteSpace > 0) // 22/4/92
      {
        noteSpace = Max(1, noteSpace - origNoteSpace + spaceAvailable); // 01/06/93 [20906]
        spaceAvailable = saveSpaceAvailable;
      }
      else if (noteSpace < 0)  // [20871] 13/5/93 added cond
      {
        noteSpace = Min(-1, noteSpace + origNoteSpace - spaceAvailable); // 01/06/93 [20906]
        spaceAvailable = saveSpaceAvailable - noteSpaceUsed;
      }
      if (allFits)
        nextNoteIdx = partNum + 1;
      else
      {
        FitNotes_r = FALSE;
        break;
      }
    }
    else if (part->fPartType == kWidgetPart && part->tag.cgf_34.fHasNote == 1) // fn2 else branch
    {
      int gaps;
      TObject breakObj = NULL;
      TCurrency rn = part->tag.cgf_34.fRecNum;

      saveSpaceAvailable = spaceAvailable;
      if (noteSpace != 0) // [20871] 13/5/93 was >, 29/4/92
        spaceAvailable = abs(noteSpace); // [20871] 13/5/93 was noteSpace
      if (GetFormatReadOnly(rn)->
            Fit(pageNumber, rn, spaceAvailable,
                noteSpaceUsed, -abs(maxAvailable), breakObj, gaps, allFits,
                origProc, origProc) ) // 29/4/92
        cantFitNotes = FALSE;
      else
        return FALSE;
      spaceAvailable = saveSpaceAvailable; // 29/4/92
      if (noteSpace == 0) // 29/4/92
        spaceAvailable -= noteSpaceUsed;
      FreeIfObject(breakObj);
    }
  }
  return FitNotes_r;
}
#endif

// ------------------------------------------------------------------------
// fn1 added new params
bool _TTextFormat::Fit(int pageNumber, TCurrency currency,
        int &spaceAvailable, int &noteSpaceUsed, int maxAvailable, TObject &breakObject,
        int &gapCount, bool &splitLeaf, PStdFitNoteVars headingProc, PStdFitNoteVars origProc)
{
  bool  Fit_r;
  int index;
  int firstIndex;
  TTextBreak textBreak;
  TTextStructure textStruct;
  int numPhrases;
  int nextNoteIdx; // fn1
  int numParts;
  int asc, desc;
  int amountThatFits;
  CntlAdornment borders;
  TRuleType ruleType;
  VRect ruleWidths;
  int ruleDepth;
#ifdef FN
  bool cantFitNotes;  // 19/05/93
  int noteSpace = noteSpaceUsed; // 22/4/92
#endif
  int amountThatFitted;

  noteSpaceUsed = 0; // 22/4/92
  Fit_r = TRUE;
  gapCount = 1;      // 16/06/91
  textStruct = TTextStructure(GetStructureReadOnly(currency)); // 19/03/91 RW
  GetBorderInfo(ruleWidths, borders, ruleType);

  ruleDepth = FixRound(ruleWidths.top + ruleWidths.bottom);
  numPhrases = textStruct->GetSize();
  if (breakObject == NULL)
  {
// fn1 changed index to firstIndex
    firstIndex = 1;  
    nextNoteIdx = 1; // fn1
    amountThatFits = 0;
  }
  else
  {
// fn1 changed index to firstIndex
    firstIndex = LineToPart(this, TTextBreak(breakObject)->BreakPart()) + 1;  // 12/02/91
    nextNoteIdx = TTextBreak(breakObject)->NextNote(); // fn1
    amountThatFits = TTextBreak(breakObject)->Depth();
  }

#ifdef FN
  index = Min(firstIndex, nextNoteIdx); // fn1
#else
  index = firstIndex;      // 14/05/92
#endif
  amountThatFitted = amountThatFits;   // 17/09/92
// 10/12/92 avoid corrupting this until necessary: spaceAvailable -= ruleTop;
  textBreak = NULL;

  do {
    GetLineDepth(index, asc, desc, numParts);
#ifdef FN
    if (index < firstIndex)
    {
      // 22/4/92
      if (!FitNotes(index, numParts, pageNumber, maxAvailable, cantFitNotes,
                 nextNoteIdx, noteSpaceUsed, noteSpace, spaceAvailable, origProc))
      {
        // 18/05/93 use firstIndex rather than index which has been reduced to line start
        if (cantFitNotes)
          Fit_r = FALSE;     // 01/06/93 return FALSE if none of the notes fitted
        else
        {
          firstIndex = index + numParts;             // 18/05/93 [20875]: index += numParts;
          textBreak = EstablishTextBreak(firstIndex, // 18/05/93 [20875]: index,
                                      amountThatFits, nextNoteIdx);
        }
        break;
      }
      amountThatFitted -= noteSpaceUsed;
           // 07/12/92 so if next (non-footnote) will not fit, a break object is returned
    }
    else
#endif
    {
      int lineDepth = (maxAvailable >= 0 ? asc + desc + ruleDepth: 0); // 01/06/93
      // lineDepth += ruleDepth; // 10/12/92 fit rules with first line fitted

      if (lineDepth > spaceAvailable)
      {
        // 20/11/92 big widgets need to be forced in if there will never be more available
        if (spaceAvailable == abs(maxAvailable))
        {
          amountThatFits = spaceAvailable - ruleDepth;  // 10/12/92 - rules
          spaceAvailable = 0;  // 10/12/92 big matrices in footnote loop
          index += numParts;
          nextNoteIdx = index;
        }
        if (amountThatFits > amountThatFitted)
        {
          // 30/11/92 do not return a break object if big picture at end of para
          if (index <= GetSize())
            textBreak = EstablishTextBreak(index, amountThatFits, nextNoteIdx);
        }
        else
          Fit_r = FALSE;
        break;
      }
      else
      {
        int savedAmountThatFits = amountThatFits;

        // The current line will fit on the page!
        spaceAvailable -= lineDepth;
        if (lineDepth > 0)                          // 01/06/93
          amountThatFits += lineDepth - ruleDepth;
        ruleDepth = 0;           // 10/12/92
#ifdef FN
        // 22/4/92
        if (!FitNotes(index, numParts, pageNumber, maxAvailable, 
                      cantFitNotes, nextNoteIdx, noteSpaceUsed, noteSpace,
                      spaceAvailable, origProc))
        {
          // But all the footnotes on the line will not fit
          // See if any line of the footnote fitted, if not do not fit the current line
          if (cantFitNotes && spaceAvailable + lineDepth < abs(maxAvailable)) // 08/12/92
          {
            amountThatFits = savedAmountThatFits;
                  // 06/05/93 [20850] [20899] from: amountThatFits = amountThatFits;
            spaceAvailable += lineDepth; 
            if (amountThatFits <= amountThatFitted && noteSpaceUsed == 0)
            {
                  // 28/05/93 [20899] could not fit any note & that was the first line tried
              Fit_r = FALSE;
              break;
            }
          }
          else
            index += numParts;

          textBreak = EstablishTextBreak(index, amountThatFits, nextNoteIdx);
          break;
        }
#endif
      }
    }
    index += numParts;
    nextNoteIdx = index;  // 17/09/92
  } while (index <= GetSize());

  breakObject = textBreak;
#ifdef FN
// 22/4/92, 21/05/93 [20890]
//  if (noteSpace < 0)         // 21/05/93 [20890] from > 0 - only on last column
//    spaceAvailable -= noteSpaceUsed;
#endif
  splitLeaf = breakObject != NULL; // fn1
  return(Fit_r);
}


// ------------------------------------------------------------------------
int _TTextFormat::GetMinWidth()
{
  return(abs(fMinWidth)); // 25/07/90 - added abs()
}


// ------------------------------------------------------------------------
void _TTextFormat::SetWidth(TCurrency currency, int newWidth)
{
  // 25/07/90 - method rewritten

  int partNum;
  Fixed widthChange;

  if (newWidth != fSetWidth)
  {
    widthChange = ToFixed(newWidth - fSetWidth);
    fSetWidth = newWidth;
    if (fAlign != kAlignLeft || fFlags)
    {
      partNum = 1;
      do {
        partNum = JustifyLine(partNum, TRUE, widthChange);
      } while (partNum <= GetSize());
    }
  }
}


// ------------------------------------------------------------------------
int _TTextFormat::GetWidth()
{
  return(fSetWidth);
}


// ------------------------------------------------------------------------
static bool ContainsWidget(TTextFormat obj, PLinePart part, TTextEdge *edge,
                                TCurrency child)
{
  edge->fCharPos = part->fCharPos; // 2/4/92 was + 1
  return part->fPartType == kWidgetPart && part->tag.cgf_34.fRecNum == child;
}


// ------------------------------------------------------------------------
TCursorNode _TTextFormat::InitialCursor(TCurrency currency, TCurrency child, long posn)
{
  TTextEdge edge;
 
  edge.fPixelPos = -1;           // 06/09/92 was uninitialised in last branch
                                 // 10/02/94 use -1 instead of 0, so mouse pos will be reset
  edge.fPartNum = 0;             // 08/09/92 hopefully reset!
  if (child == -1)         // 05/03/91 new condition
  {
    edge.fCharPos = MAXLONGINT;
    edge.fPixelPos = MAXLONGINT;     // 10/02/94 from MAXINT
  }
  else if (child == 0)
  {
    TTextStructure structure = TTextStructure(GetStructureReadOnly(currency));
#ifdef FN
    // 27/09/94 [22029] see if a footnote currency, place just before or after it
    // replaces FindNoteReference
    int absPos = abs(posn);       // -ve for search bwds
    int index = 1;
    PPhrase phr;

    if (absPos > 0x10000 && // 12/05/95 better test for body currency: absPos != kBodyStruct &&
                      Curr_fType(absPos) == kBodyStruct)
                                        // 05/01/95 test not really position 4 (kBodyStruct)
    {
      do {
        phr = PPhrase(structure->At(index++));
      } while (phr->fKind != kNotePhrase || phr->tag.fRecNum != absPos);
      posn = phr->fCharPos + (posn >= 0);
      edge.fPixelPos = 0;
    }
#endif
    // 09/09/92 adjust for paste into selection
    SetTextGlobals(structure);
    if (posn > gDelPos)
      posn -= gDelCount;
    edge.fCharPos = posn;    // 08/09/92 from 0
  }
  else
    edge.fPartNum = FirstThat(this, (TestItem)ContainsWidget, &edge, child);

  return new _TTextCursor(currency, kNewCursor, edge, FALSE, gZeroVPt);
}


// ------------------------------------------------------------------------
bool _TTextFormat::ContainsCharPos2(PLinePart linePart, TCharPos charPos)
{
#ifdef BWDSEXPERIMENT
  return ((charPos > linePart->fCharPos || linePart->fCharPos == 0) && linePart->fPartType != kBulletPart);
#else
  return (charPos >= linePart->fCharPos && linePart->fPartType != kBulletPart);
#endif
}


// ------------------------------------------------------------------------
void _TTextFormat::ResetEdge(TTextEdge &edge, TTextView view, int partNum,
                                TCharPos charPos, TCursorNode cursor)
{
  TLinePart linePart;
  int savePos;
  int textLimit;
  Fixed newPixPos;

  Get(partNum, &linePart);
// [21388] moving arrow up/down after arrowing left off start or right off end
// 09/02/94  savePos = edge.fPixelPos;      // 16/06/91
// 09/02/94  if (savePos == MAXINT)
// 09/02/94    savePos = 0;
  edge.fPartNum = partNum;

  // 11/11/93 [21116] stop cursor going after CR, which stops deferred style changes working
  textLimit = linePart.fCharPos + linePart.fNumChars;
  if (charPos == MAXLONGINT || (linePart.fEOL == kEndOfPara && charPos >= textLimit))
  {
    // 11/11/93 [21116] subtract 1 for the CR in last line part if a cursor
    charPos = textLimit - (cursor->fCursor->fSelection->fCursor != 0);
                         // 22/10/96 [27117] fCursor is no longer a boolean!
    edge.fCharPos = charPos;
  }
  newPixPos = ZoomFixed(linePart.fWidth + linePart.fSlop);

  if (linePart.fPartType == kFillerPart || linePart.fPartType == kWidgetPart)
    edge.fPixelPos = FixRound(Backwards() & newPixPos);
  else
  {
    TPhrase phrase;

    // 13/09/90 - if clause new
    if (linePart.fPartType == kMacroPart)
      if (charPos > linePart.fCharPos && charPos < linePart.fCharPos + linePart.fNumChars &&
        gMainStruct->GetPhraseAt(charPos, phrase, kMacroPhrase) > 0)  // 25/10/91 wrapped macros
    {
      charPos = linePart.fCharPos + phrase.fNumChars;
      edge.fCharPos = charPos;
      edge.fPartNum = LastThat(this, (TestItem)_TTextFormat::ContainsCharPos2, charPos);
                                                       // 25/10/91 for wrapped macros
    }
    savePos = edge.fPixelPos;      // 09/02/94 [21388]

    {
      // 09/06/94 inline gMainStruct->Measure()
      CharsPtr charPtr;
      Handle buffer;
      TCharPos numChars = linePart.fNumChars;
      int eol = linePart.fEOL;
      TCharPos offset = charPos - linePart.fCharPos;
      Fixed slop = SetGStyle(linePart, fMainView);
      int newNumCh;

      if (!gMainStruct->SetFontAndFace(FALSE))
        newPixPos = 0;               // zeroise if current part not backwards text

      charPtr = gMainStruct->GetBuffer(linePart.fCharPos, numChars, eol, buffer, &newNumCh);
      if (offset == numChars)
        offset = newNumCh;
      edge.fPixelPos = Char2Pixel(charPtr, numChars, slop,
                 offset > numChars ? numChars : offset, 0, linePart.tag.cgf_35.fNumSpaces);
      edge.fPixelPos += FixRound(newPixPos);
      FreeBuffer(buffer);
    }
    if (fFlags == 0)    // the following fudge does not work with backwards
    {
      if (linePart.fEOL == kEndOfPara &&
                        charPos - linePart.fCharPos == linePart.fNumChars)
        edge.fPixelPos += GetVLineThickness();
      else if (linePart.fEOL == kLineFeed &&
                        charPos - linePart.fCharPos == linePart.fNumChars - 1)
        edge.fPixelPos -= GetVLineThickness();
    }

    // [21388] if cursor moved to start or end of line, fix mouse pos (it would be better
    // to add the indentation of the view - but how does the format find that?)
    // 10/02/94 from MAXINT
    cursor->fMousePt.h = (savePos == MAXLONGINT || savePos < 0 ?
                edge.fPixelPos + FixRound(ZoomInt(linePart.fLocation.h)) :
                cursor->fMousePt.h + edge.fPixelPos - savePos);
    // 09/02/94 [21388] cursor->fMousePt.h += edge.fPixelPos - savePos;      // 16/06/91
  }
}


// ------------------------------------------------------------------------
void _TTextFormat::ResetCursor(TCursorNode cursor)
{
  TCurrency currency;
  int partNum;
  TCharPos charPos;
  TTextView view;
  TTextEdge edge;

//  PLinePart linePart;

  currency = cursor->fCurrency;
  charPos = TTextCursor(cursor)->GetCharPos();

  if (!cursor->IsLast() && 
        TTextCursor(cursor)->GetPartNum() == 0 && charPos > 0)  // 22/4/92 & 03/03/92
    charPos--;

  view = (cursor->fIdentifier == kNewCursor ? NULL :
                          TTextView(fMainView->FindCursorView(cursor)));
  
  if (view != NULL && cursor->fCursor->fSelection->fViewId.tag.fSubId != 0) // HF
  // 26/03/91 EXPERIMENT for diff length H/Fs !!!!
      view->SetupMacros();

  partNum = LastThat(this, (TestItem)_TTextFormat::ContainsCharPos2, charPos);

  TTextCursor(cursor)->GetEdge(edge);
  if (partNum == 0)
  {
    if (edge.fPartNum <= fSize)    // 11/07/91 for cursor in hidden spaces
      partNum = edge.fPartNum;
    else
      partNum = GetSize();
  }
  else if (cursor->IsLast()) // fn1 new if clause ???
  {
    PLinePart p = PLinePart(At(partNum));

    if (p->fPartType == kWidgetPart)
      partNum = Max(1, partNum + (p->fCharPos == charPos ? -1 : 1)); // 30/3/92
  }
  if (edge.fPartNum != partNum)
  {
    edge.fPartNum = partNum;
    if (edge.fPixelPos > 0)
      edge.fPixelPos = 0;   // 09/02/94 [21382] or MAXLONGINT ? clear old pix pos unless new
    TTextCursor(cursor)->SetEdge(edge);
    view = NULL; // 20/11/92 look for it again if part number changed
  }
  if (view == NULL)
    view = TTextView(fMainView->FindCursorView(cursor));
  if (view == NULL)
    return;                    // instead of Assert

  SetTextGlobals(TTextStructure(GetStructureReadOnly(currency))); // 19/03/91 RW
  ResetEdge(edge, view, partNum, charPos, cursor);
  TTextCursor(cursor)->SetEdge(edge);
  LocateCaret(cursor, view);  // 18/07/94 Draw caret - new method
}


// ------------------------------------------------------------------------
TCharPos _TTextFormat::ClickOnce(int partNum, int &clickPoint, int partWidth, bool &leftSide)
{
  TLinePart linePart;
  TCharPos charPos;

  Get(partNum, &linePart);
  if (linePart.fPartType == kFillerPart   // 21/5/92 || linePart.fPartType == kMacroPart
#ifdef FN  
        || linePart.fPartType == kNotePart
#endif
       )  // 13/09/90
  {
    leftSide = TRUE; // 21/5/92 FALSE;
    charPos = linePart.fCharPos;
  }
  else
  {
    bool ls = leftSide;                   // 21/5/92
    Fixed slop = SetGStyle(linePart, fMainView);  // 15/05/90

    charPos = linePart.fCharPos;
    leftSide = gMainStruct->ClickOnce(clickPoint, slop, linePart.fEOL, charPos,
                      linePart.fNumChars, linePart.tag.cgf_35.fNumSpaces, partWidth);
    if (linePart.fPartType == kMacroPart) // 21/5/92
      leftSide = ls; 
    charPos = linePart.fCharPos + charPos;
  }
  return charPos;
}


// ------------------------------------------------------------------------
bool _TTextFormat::ContainsCharPos3(PLinePart linePart, TCharPos charPos)
{
//  register PLinePart linePart = PLinePart(At(index));

  return (((charPos >= linePart->fCharPos &&
            charPos <= linePart->fCharPos + linePart->fNumChars -
                                         (linePart->fEOL == kLineFeed)) ||
            charPos == 0) &&
           !(linePart->fPartType == kBulletPart ||
             linePart->fPartType == kWidgetPart ||
             linePart->fPartType == kFillerPart)); // 26/07/90
}


// ------------------------------------------------------------------------
void _TTextFormat::ClickAgain(TTextCursor cursor, TTextView view, bool rightEdge)
{
  // 02/05/90 - rhs edge stuff removed
  TCharPos charPos;
  TCharPos lineLen;
  TTextEdge edge;

  cursor->GetEdge(edge);
  charPos = edge.fCharPos;
  // prev GetLineBounds() local proc
  // 21/10/94 set up charPos and lineLen ready for GetBuffer, scanning back and forth
  // to ensure we have NOT got a hyphenation at start or end
  {
    int partNum;
    int eol;

    partNum = edge.fPartNum;
    while (partNum > 1)
    {
      eol = PLinePart(At(partNum - 1))->fEOL;
      if (eol == kLineBreak || eol <= kLineFeed)       // 21/10/94 <= kModifiedHyphen)
        break;
      partNum--;
    }
    charPos = PLinePart(At(partNum))->fCharPos;
    partNum = edge.fPartNum;
    do
    {
      register PLinePart cgf_188 = PLinePart(At(partNum));

      lineLen = cgf_188->fCharPos + cgf_188->fNumChars - charPos;
      eol = cgf_188->fEOL;
      partNum++;
    }
    while (eol != kLineBreak && eol > kLineFeed);
    // 24/10/90 new version
    //    lineLen = 0;
    //    do {
    //      register PLinePart cgf_188 = PLinePart(At(partNum));
    //      bool addOne = FALSE;

    //      if (cgf_188->fPartType != kBulletPart)
    //      {
    //        if (cgf_188->fPartType == kFillerPart)  // 06/02/91 add 1 for the tab
    //          lineLen += 1;
    //        else
    //          lineLen += cgf_188->fNumChars;
    //      }
    //      eol = cgf_188->fEOL;
    //      partNum ++;
    //    } while (eol != kLineBreak && eol >= kModifiedHyphen);  // 24/10/90 for eol > 0
  }
  // end of GetLineBounds() local proc
#if TALK == 2
  if (gMainStruct->fDocument->fInteractive && cursor->fClickCount == 2 &&
                                rightEdge && wr_wimpt_last_event()->e == wr_wimp_EBUT)
    while (gMainStruct->SayWord(edge.fCharPos) > 0) {}
#endif
  gMainStruct->FindTextSelect(cursor, charPos, lineLen, rightEdge);
  cursor->GetEdge(edge);
//  cursor->GetRightEdge(rightEdge);
  charPos = edge.fCharPos;
  edge.fPartNum = FirstThat(this, (TestItem)_TTextFormat::ContainsCharPos3, charPos);
//  charPos = rightEdge.fCharPos;
//  rightEdge.fPartNum = FirstThat(this, (TestItem)_TTextFormat::ContainsCharPos3, charPos);
// 22/11/90  GetPixelOffset(edge, view, charPos);
//  GetPixelOffset(rightEdge, view, charPos);
  cursor->fLeftSide = !rightEdge;              // 19/03/91
  cursor->SetEdge(edge);
//  cursor->SetRightEdge(rightEdge);
#ifdef THESAURUS
  // 08/03/93 [20802]
  if (gThesaurus && wr_akbd_pollctl() &&
          cursor->fClickCount == 2 && !rightEdge && wr_wimpt_last_event()->e == wr_wimp_EBUT)
    SendWordToThesaurus(charPos);
#endif
}


// ------------------------------------------------------------------------
// 05/11/90 new for arrow keys
// 10/04/94 returns lastPart.fCharPos + lastPart.fNumChars;
// and remove TLinePart *firstPart, TLinePart *lastPart
int _TTextFormat::GetLine(int pn, int &fpn, int &lpn)
{
  TLinePart *lastPart;

  fpn = pn;
  while (fpn > 1 && PLinePart(At(fpn - 1))->fEOL > 0)
    fpn--;

  lpn = pn;
  while (lpn <= fSize && PLinePart(At(lpn))->fEOL > 0)
    lpn++;

  lastPart = PLinePart(At(lpn));
  return lastPart->fCharPos + lastPart->fNumChars;  // 10/04/94
}


// ------------------------------------------------------------------------
// The idea of this is to find a suitable location for the cursor in the line
// starting with fpn. As there may be several parts, we need to scan through
// using the mouse point to decide which one, then find a suitable character
// position. This needs to be chosen so that ResetCursor does not choose
// to put the cursor on the next line (as frequently happened before) otherwise
// the cursor gets "stuck" when moving up.

void _TTextFormat::FindNearestEdge(TCursorNode cursor,
      TTextStructure structure, int fpn, VPoint &mousePt, TTextEdge &edge)
{
  // 09/02/94 [21386] this is NOT view indentation! int lm = FixRound(GetLeftMargin());
  bool offEnd = FALSE;
  Fixed n;
  TLinePart firstPart;
  Fixed slop = 0;
  Fixed mpt = ToFixed(mousePt.h);
  Fixed partWidth;
  int backwards = Backwards();

  while (TRUE)
  {
    Get(fpn, &firstPart);
    partWidth = firstPart.fWidth + firstPart.fSlop;
#ifdef FIXLOC
    n = ZoomFixed(firstPart.fLocation.h + partWidth - (partWidth & backwards));
                   // 20/06/94 [22002] add in slop (for up/down cursor in justified lines)
#else
    n = ZoomFixed(/* lm + */ ToFixed(firstPart.fLocation.h) + firstPart.fWidth);
#endif
    if ((n ^ backwards) > (mpt ^ backwards) && firstPart.fPartType == kTextPart) // 19/02/91
    {
      slop = SetGStyle(firstPart, fMainView);
      break;
    }
    if (firstPart.fEOL <= kLineBreak)
    {
      offEnd = TRUE;
      break;
    }
    fpn++;
  }
  if (!backwards)
    n -= ZoomFixed(partWidth);      // n now is offset of start of part
  edge.fPixelPos = FixRound(mpt - n);
  edge.fPartNum = fpn;
  if (offEnd)
  {
    // 27/10/94 [23013] redone fix, with hyphens adjustment needed whichever branch
    //int newPos;

    //newPos = firstPart.fCharPos + firstPart.fNumChars;
    // 10/03/93 [20807] stuck up arrow key on shift return lines
    //edge.fCharPos = (structure->GetChar(newPos - 1) <= chLineFeed ? newPos - 1 : newPos);
    edge.fCharPos = firstPart.fCharPos + firstPart.fNumChars;
  }
  else
  {
    edge.fCharPos = firstPart.fCharPos;
    TTextCursor(cursor)->fLeftSide = structure->ClickOnce(edge.fPixelPos, slop,
           firstPart.fEOL, edge.fCharPos, firstPart.fNumChars,
           firstPart.tag.cgf_35.fNumSpaces, FixRound(ZoomFixed(partWidth)));
    edge.fCharPos += firstPart.fCharPos;
  }
  // 27/10/94 [23013] stuck up arrow key on shift return lines & hyphens & non-space breaks
  // these are the conditions when ResetCursor will try to choose the following line
  if (edge.fCharPos == firstPart.fCharPos + firstPart.fNumChars &&
             ((firstPart.fEOL >= kLineFeed && firstPart.fEOL < kLineBreak) ||
                 (fpn < fSize && PLinePart(At(fpn + 1))->fCharPos == edge.fCharPos)))
    edge.fCharPos--;

  TTextCursor(cursor)->SetEdge(edge);
  ResetCursor(cursor);   // 20/06/91, 10/03/93 call here rather than after both calls
  cursor->fMousePt.h = mousePt.h;  // 09/02/94 [21387] preserve h if moving up or down
}


#define mvSpeak1    0x05
#define mvSpeak     0x06
#define mvCaseSwap  0x07
#define mvLeft      0x0c
#define mvRight     0x0d
#define mvDown      0x0e
#define mvUp        0x0f

#define mvShftLeft  0x1c
#define mvShftRight 0x1d

// two values which cannot be obtained from keyboard, but used in speech
#define mvShftDown  0x1e
#define mvShftUp    0x1f

#define mvCtrlLeft  0x2c
#define mvCtrlRight 0x2d
#define mvCtrlDown  0x2e
#define mvCtrlUp    0x2f
// ------------------------------------------------------------------------
void _TTextFormat::MoveCursor(TCursorNode cursor, int arrowKey, EventInfo &info)
{
  TTextStructure structure;
//  TLinePart firstPart;
  TLinePart lastPart;
  TTextEdge edge;
  VPoint mousePt;
  int partEnd;
//  int lineWidth;
  int fpn;
  int lpn;
  int pn1;
  TPhrase phrase;
  bool stp;        // 11/02/94 flag to indicate whether call to parent
  int originalKey = arrowKey;    // 14/06/94 for backwards

  TTextCursor(cursor)->GetEdge(edge);
  if (arrowKey >= 0x180 && fFlags)
                      // && edge.fPartNum > 0 && edge.fPartNum <= fSize &&
                      // (PLinePart(At(edge.fPartNum))->fTextFace & kBackwards) != 0)
  {
    if ((arrowKey & 0x0f) == 0x0c)
      arrowKey++;
    else if ((arrowKey & 0x0f) == 0x0d)
      arrowKey--;
  }
  arrowKey &= 0x7f; // -= 0x180;  // avoid 2 instructions to load literals in comparisons
  structure = TTextStructure(arrowKey == mvCaseSwap ?
    GetStructureReadWrite(cursor->fCurrency) : GetStructureReadOnly(cursor->fCurrency));
                                                       // 11/02/94 RO <=> RW
  SetTextGlobals(structure);
//  TTextCursor(cursor)->GetEdge(edge);

  // 13/01/92 new block for arrows in widgets
  if (!cursor->IsLast())
  {
    TCurrency wCurr = cursor->GetNext()->fCurrency;
    bool onRight;
    int incr;

    cursor->Collapse();
    if (arrowKey == mvLeft || arrowKey == mvRight) // left or right
    {
      pn1 = structure->GetPhraseAt(edge.fCharPos, phrase, kWidgetPhrase);
      onRight = (pn1 == 0 || wCurr != phrase.tag.fRecNum);
      if (arrowKey == mvLeft && onRight)  // left arrow
        incr = -1;
      else if (arrowKey == mvRight && !onRight)   // right arrow
        incr = 1;
      else
        incr = 0;
      TTextCursor(cursor)->ChangeCharPos(incr);
      Reset(cursor, cursor->fCurrency);  // 20/11/92 adjust part if wrapped widget
      info.affectsMenus = TRUE;
      return;
    }
  }
  // 13/01/92 end new block
  mousePt = cursor->fMousePt;
  stp = FALSE;
  pn1 = 0;
  if (!info.affectsMenus)
  {
#ifdef INDEX
    if (structure->GetPhraseAt(edge.fCharPos, phrase, kIndexRefPhrase) != 0 || !CmdEnabled(cAddToIndex))
      info.affectsMenus = TRUE;
    else
#endif
      pn1 = structure->GetPhraseAt(edge.fCharPos, phrase, kTextPhrase);
  }
//pn1 = (info.affectsMenus ? 0 : structure->GetPhraseAt(edge.fCharPos, phrase, kTextPhrase));

  if (arrowKey >= mvCtrlDown)                   // Ctrl up and down: move to ends of doc
  {
    stp = TRUE;
    // SendToParent(cursor, arrowKey, info, structure); // 21/11/91
  }
  else if (arrowKey >= mvCtrlLeft)             // Ctrl left or right
  {
    if (arrowKey == mvCtrlLeft)                 // move to start of para
    {
      if (edge.fCharPos == 0)
        stp = TRUE;
      else
        edge.fCharPos = 0;
        // 10/02/94 [21389]      mousePt.h -= edge.fPixelPos;
    }
    else
    {
      partEnd = GetLine(fSize, fpn, lpn);  // , &firstPart, &lastPart);
      if (edge.fCharPos >= partEnd - 1)       // 13/01/94 [21334] >
        stp = TRUE;
      else
        edge.fCharPos = partEnd; // 08/02/91 - 1;
        // 10/02/94 [21389]      mousePt.h = mousePt.h - edge.fPixelPos + lineWidth;
    }
    if (!stp)
    //  SendToParent(cursor, arrowKey, info, structure); // 21/11/91
    //else
    {
      TTextCursor(cursor)->SetEdge(edge);
      ResetCursor(cursor);                   // 11/02/94 [21391] ScrollSelIntoV may not work
      // 10/02/94 [21389]    cursor->fMousePt = mousePt;
    }
  }
  else if (arrowKey >= mvShftLeft)  // shift left or right (move word)
  {
#if TALK == 1
    TCharPos cpStart = edge.fCharPos;
#endif
    int direction = kForward;

    if (arrowKey == mvShftLeft
#if TALK == 1
        || arrowKey == mvShftUp   // shift up (move back sentance)
#endif
       )     // shift-left
    {
      if (edge.fCharPos == 0)
        stp = TRUE;
      else
      {
        if (edge.fPartNum == MAXINT)
          edge.fCharPos--;
        direction = kBackward;
      }
    }
    else  // shift-right
    {
      partEnd = GetLine(fSize, fpn, lpn);  // , &firstPart, &lastPart);
      if (edge.fCharPos >= partEnd - 1)
        stp = TRUE;
      else
      {
        if (edge.fPartNum == 0)
          edge.fPartNum = 1;
      }
    }
    if (stp || CurFindWord(structure, edge.fCharPos, direction))
      stp = TRUE;
      // SendToParent(cursor, arrowKey, info, structure); // 21/11/91
    else
    {
#if TALK == 1
      if (arrowKey == mvShftUp)   // shift up (move back sentance)
      {
        TCharPos cp;
        int ch;
        int lastch = 0;

        while(TRUE)
        {
          cp = edge.fCharPos;
          while ((ch = structure->GetChar(cp)) > 0x20)
          {
            lastch = ch;
            structure->MoveCursor(cp, kForward);
          }
          if (cp < cpStart && (lastch == '.' || lastch == '!' || lastch == '?'))
          {
            // 23/12/95 not good  idea - loops so removed
            // while (structure->GetChar(cp) <= 0x20)
            //   structure->MoveCursor(cp, kForward);
            edge.fCharPos = cp;
            break;
          }
          if ((stp = CurFindWord(structure, edge.fCharPos, direction)) != 0)
          {
            edge.fCharPos = 0;
            break;
          }
        }
      }
#endif
      TTextCursor(cursor)->SetEdge(edge);
      ResetCursor(cursor);
    }
  }
  else if (arrowKey >= mvDown)  // up or down
  {
    int pn;

    if (arrowKey == mvUp)  // up
    {
      if (edge.fPartNum == MAXINT)
        pn = fSize;       // just entered from parent
      else
      {
        GetLine(edge.fPartNum, fpn, lpn);   // , &firstPart, &lastPart);
        pn = fpn - 1;  // pn = 0 on the first line
      }
    }
    else  // down
    {
      if (edge.fPartNum == 0)
        pn = 1;       // just entered from parent
      else
      {
        GetLine(edge.fPartNum, fpn, lpn);  // , &firstPart, &lastPart);
        pn = lpn + 1;     // pn = fSize + 1 on the last line
      }
    }
    if (pn == 0 || pn > fSize)
      stp = TRUE;
      // SendToParent(cursor, arrowKey, info, structure); // 21/11/91
    else
    {
      GetLine(pn, fpn, lpn);  // , &firstPart, &lastPart);
      FindNearestEdge(cursor, structure, fpn, mousePt, edge);
      // 10/03/93 in FNEd:    ResetCursor(cursor);
    }
  }
  else if (arrowKey == mvLeft) // left
  {
    if (edge.fCharPos == 0)
    {
#if SIDEBAR == 1
//      if (originalKey < 0x200)
#endif
        stp = TRUE;
      // SendToParent(cursor, arrowKey, info, structure); // 21/11/91
    }
    else
    {
      structure->MoveCursor(edge.fCharPos, -1);
      if (structure->GetPhraseAt(edge.fCharPos, phrase, kWidgetPhrase) > 0)
      {
        edge.fPartNum--;
        TTextCursor(cursor)->SetEdge(edge);
        GetStructureReadOnly(phrase.tag.fRecNum)->
                ExtendCursor(cursor, phrase.tag.fRecNum, Backwards() + 1, TRUE, FALSE);
        cursor = cursor->GetCursorTarget();
        GetFormatReadOnly(cursor->fCurrency)->MoveCursor(cursor, 
                                    originalKey /* arrowKey + 0x180 */, info);
        info.affectsMenus = TRUE;
      }
      else
      {
        Get(Min(fSize, edge.fPartNum), &lastPart);         // 20/05/91 Min
        if (edge.fCharPos < lastPart.fCharPos)
          edge.fPartNum--;
        TTextCursor(cursor)->SetEdge(edge);
        Reset(cursor, cursor->fCurrency);  // 20/11/92 adjust part if wrapped widget
      }
    }
  }
  else if (arrowKey == mvRight || arrowKey == mvCaseSwap) // 22/6/92 right, case change
  {
    if (edge.fPartNum > 0)
    {
      if (structure->GetPhraseAt(edge.fCharPos, phrase, kWidgetPhrase) > 0)
      {
        GetStructureReadOnly(phrase.tag.fRecNum)->
                ExtendCursor(cursor, phrase.tag.fRecNum, fFlags >> 7, TRUE, FALSE);
        cursor = cursor->GetCursorTarget();
        GetFormatReadOnly(cursor->fCurrency)->MoveCursor(cursor,
                                       /* 0x18d */ originalKey, info); // 24/6/92
        info.affectsMenus = TRUE;
      }
      else
      {
#if TALK == 1 && !defined NETWP
        int RTSTEP = 1;

        if ((info.event->e == wr_wimp_ESEND || info.event->e == wr_wimp_ESENDWANTACK) &&
               info.event->data.msg.hdr.action == EasiWrite_MoveCursor)
        {
           // move by # chars specified in event
           RTSTEP = info.event->data.msg.data.words[0];
        }
#else
#define RTSTEP 1
#endif
        structure->MoveCursor(edge.fCharPos, RTSTEP);
        if (edge.fPartNum >= fSize)            // 03/03/92 new clause for big cursor
        {
          Get(fSize, &lastPart);
          lastPart.fCharPos += lastPart.fNumChars;
        }
        else
          Get(edge.fPartNum + 1, &lastPart);

        if (edge.fCharPos >= lastPart.fCharPos) // 03/03/92 + lastPart.fNumChars)
          edge.fPartNum++;

        if (edge.fPartNum > fSize)
        {
          arrowKey = mvRight;
          stp = TRUE;
          // SendToParent(cursor, arrowKey, info, structure); // 22/6/92, 21/11/91
#if TALK == 1
          TTextCursor(cursor)->SetEdge(edge); // in case end of doc
#endif
        }
        else
        {
          if (arrowKey == mvCaseSwap) // 22/6/92 do case change
          {
            char *p;

            p = TextStart(structure) + edge.fCharPos - 1;
            *p = (islower(*p)? toupper(*p): tolower(*p));
          }
          TTextCursor(cursor)->SetEdge(edge);
          Reset(cursor, cursor->fCurrency);  // 20/11/92 adjust part if wrapped widget
        }
      }
    }
    else
    {
      edge.fPartNum = 1;
      TTextCursor(cursor)->SetEdge(edge);     // 14/05/91
    }
  }
#if TALK != 0
  else if (arrowKey <= mvSpeak)
  {
    int theCh;

    partEnd = GetLine(fSize, fpn, lpn);
    if (edge.fCharPos >= partEnd)         // - 1 09/03/93 say last wd
      stp = TRUE;
    else
    {
      if (edge.fPartNum != 0)  // 09/03/93 moved after end of line test
      {
        int theCh;

#if TALK == 2
        while (structure->SayWord(edge.fCharPos) > 0) {}
        while (TestNextKey(chSpeak)) {}
#endif
#if SIDEBAR == 1
        if (arrowKey == mvSpeak)
#endif
        {
          // move to the end of the current word
          theCh = structure->GetChar(edge.fCharPos);
          if (theCh > 0x20)
            CurFindWord(structure, edge.fCharPos, kForward);
        }
      }
      else
        edge.fPartNum = 1;

      // put the cursor at the next word start (if any)
      while ((theCh = structure->GetChar(edge.fCharPos)) <= 0x20)
      {
        if (theCh == 0x0d)
        {
          TTextCursor(cursor)->SetCharPos(edge.fCharPos + 1); // 09/03/93
          stp = TRUE;
          break;
        }
        edge.fCharPos++;
      }
      if (!stp)
      {
        TTextCursor(cursor)->SetEdge(edge);
        ResetCursor(cursor);
      }
    }
  }
#endif
  if (stp)
  {
    SendToParent(cursor, arrowKey, info, structure);
                       // 11/02/94 common up calls and restore code for arrow keys
    info.affectsMenus = TRUE;
  }
  else if (!info.affectsMenus)   // 27/03/95 else added for safety
  {
    // info.affectsMenus = (pn1 != structure->GetPhraseAt(edge.fCharPos, phrase, kTextPhrase));
    if (pn1 != structure->GetPhraseAt(edge.fCharPos, phrase, kTextPhrase)
#ifdef INDEX
          || structure->GetChar(TTextCursor(cursor)->GetCharPos()) < 32  // need to grey menu
#endif
          )
      info.affectsMenus = TRUE;
  }
}


// ------------------------------------------------------------------------
TCharPos _TTextFormat::GetCharPos(int partNum)
{
  return(PLinePart(At(partNum))->fCharPos);
}


// ------------------------------------------------------------------------
int _TTextFormat::GetNumChars(int partNum)
{
  return(PLinePart(At(partNum))->fNumChars);
}


// ------------------------------------------------------------------------
TCurrency _TTextFormat::GetRecNum(int partNum)
{
  // 02/05/90 - new method to mac
  return PLinePart(At(partNum))->tag.cgf_34.fRecNum;
}

// ------------------------------------------------------------------------
// 15/7/92 HandleView called
TSubView _TTextFormat::MakeView(
      TCurrency currency, TViewId viewId, // Fixed itsSlop, VPoint &
      Fixed itsVSlop, TView itsSuperView, TView itsNextView,
      VPoint &itsLocation, TObject startBreak, TObject endBreak)
{
  // bool ignore;

  return HandleView(TRUE, currency, viewId, /* itsSlop, itsVSlop,*/ itsSuperView,
                  NULL, itsNextView, itsLocation, startBreak, endBreak,
                  FALSE, TRUE, NULL);    // &ignore);
}

// ------------------------------------------------------------------------
// 15/7/92 HandleView called
bool _TTextFormat::UpdateView(
     TCurrency currency, TSubView itsView, VPoint &itsLocation, // VPoint &
     Fixed itsVSlop, TObject startBreak, TObject endBreak, bool invalidate, bool updateAll)
{
  TViewId itsViewId;
  bool changes;

  itsViewId.fNumId = 0;
  HandleView(FALSE, currency, itsViewId, /* 0, itsVSlop, */ NULL, itsView, NULL,
         itsLocation, startBreak, endBreak, invalidate, updateAll, &changes);
  return changes;
}

// ------------------------------------------------------------------------
TSubView _TTextFormat::DeleteWidgets(int index, TCurrency recnum, TSubView itsView)
{
  // 02/05/90 new method on mac
  TSubView view;

  view = itsView->SubViewAt(index);
  while (view->fStructure != recnum)
  {
    view->Free();
    view = itsView->SubViewAt(index);
  }

  return view;
}


// ------------------------------------------------------------------------
static bool IsWidgetForPart(TObject ignored, TSubView aView, TCurrency curr)
{
  // 02/05/90 new method on mac
  return (aView->GetStructure() == curr);
}

// ------------------------------------------------------------------------
TSubView _TTextFormat::HandleView(bool makeTheView, TCurrency currency,
                  TViewId itsViewId, // Fixed itsSlop, VPoint &itsVSlop,
                  TView itsSuperView, TSubView itsView,
                  TView itsNextView, VPoint &itsLocation1,
                  TObject startBreak, TObject endBreak, bool invalidate,
                  bool updateAll, bool *changes)
{
  VPoint itsLocation;
  VPoint location;
  VPoint paraSize;
  TLinePart linePart;
  Size lineOffset;
  int partNum;
  int startPart;
  int endPart;
  VPoint partSize;
  long ascent;
  long descent;
  bool doChange = FALSE;
  int numParts;
  TStructure textStructure;
  int spBefore;
  int spAfter;
  Rect ruleRect;
  TSubView widgetView;
  TSubView widgetView1;
  TFormat widget;
  int widgetIndex;
  bool isHF;
  int sign;
  int lineNumber;
  TTextView newView = NULL;
  FailInfo fi;

  // itsVSlop.v = 0;
  // itsVSlop.h = 0;
  itsLocation = itsLocation1;

  if (makeTheView)
    doChange = TRUE;
  else
  {
    *changes = fHasChanged;
    itsView->Locate(itsLocation.h, itsLocation.v, invalidate);
  }

  textStructure = GetStructureReadOnly(currency);
  GetViewBorders(startBreak, endBreak, ruleRect, spBefore, spAfter);
  _TTextFormat::GetDepth(ascent, descent);

  if (startBreak == NULL || (startBreak == TObject(-1) /* POINTER -1 */))
  {
    lineNumber = 1;                                        
    startPart = 1;
    paraSize.v = ascent + descent;
  }
  else
  {
    lineNumber = TTextBreak(startBreak)->BreakPart() + 1;
    startPart = LineToPart(this, lineNumber - 1) + 1;
    paraSize.v = ascent + descent - TTextBreak(startBreak)->Depth();
  }

  if (endBreak == NULL || endBreak == TObject(-1))
    endPart = GetSize();
  else
  {
    endPart = LineToPart(this, TTextBreak(endBreak)->BreakPart());
    if (startBreak != NULL && startBreak != TObject(-1) && 
          startPart - 1 == endPart
#ifdef FN
          && TTextBreak(endBreak)->Depth() > TTextBreak(startBreak)->Depth()
                               // 07/12/92 test for paras containing only fn continuation
#endif
    )
      endPart = startPart;
    else
    {
      paraSize.v = paraSize.v - (ascent + descent - TTextBreak(endBreak)->Depth()) +
            ruleRect.top + ruleRect.bottom;   // 20/10/92 add in rules on 1st page
    }
  }
  paraSize.v = paraSize.v + spBefore + spAfter;

  if (makeTheView && endPart < startPart)
    return NULL;

  paraSize.h = fSetWidth;
  ZoomVPt(paraSize);

  if (makeTheView)
  {
    newView = new _TTextView(itsSuperView, fMainView, TSubView(
         itsNextView), itsLocation, paraSize, currency, spBefore, spAfter);
    itsSuperView->AddSubView(newView);
    newView->SetColNum(itsViewId.tag.fColNum);
    itsView = newView;
  }
  else
  {
    itsView->Resize(paraSize.h, paraSize.v, invalidate); // 25/07/90
    TTextView(itsView)->SetSpacing(spBefore, spAfter);
  }

  CatchFailures(&fi);
  
  if (startBreak != NULL || endBreak != NULL)
  {
    doChange = TRUE;
    fMainView->RegisterDep(currency, itsView /* 17/09/92, startBreak != NULL*/);
  }
  else if (!makeTheView)
    doChange = fMainView->RegisterDep(gNullCurrency, itsView /* 17/09/92, FALSE */);

  lineOffset = spBefore + ruleRect.top;
  // 21/06/93 ascent = 0;
  descent = 0;
  widgetIndex = 0;
  numParts = endPart - startPart + 1;

  if (fHasChanged || doChange)
  {
    if (!makeTheView)
      TTextView(itsView)->DeleteLineParts(startPart);
    isHF = TestInHF(textStructure);   /* 30/01/94 TestInHF(this, currency); */

    for (partNum = startPart; partNum <= endPart; partNum++)
    {
      Get(partNum, &linePart);
      
      if (linePart.fPartType == kWidgetPart)
        widgetIndex ++;

      if (doChange || linePart.fChanged)
      {
        int backwards = linePart.fTextFace & kBackwards;

        sign = (linePart.fChanged ? -1 : 1);
        doChange = TRUE;
        location.h = linePart.fLocation.h;
        location.v = linePart.fLocation.v + lineOffset;
        partSize.h = linePart.fWidth + linePart.fSlop;
        partSize.v = linePart.fAscent + linePart.fDescent;

        ZoomVPt(location);
#ifdef FIXLOC
        location.h = FixRound(location.h);  // 21/06/94 round after zooming
#endif
        ZoomVPt(partSize);
        partSize.h = FixRound(partSize.h);   // 21/06/94 do after zooming

        if (linePart.fPartType == kTextPart ||
            linePart.fPartType == kFillerPart ||
            linePart.fPartType == kBulletPart ||
            linePart.fPartType == kMacroPart
#ifdef FN
            || linePart.fPartType == kNotePart
#endif
           )  // 13/09/90 extra for macros
        {
          Str255 macroText;
          PLinePart macroPart = NULL;

          if (isHF || linePart.fPartType == kMacroPart)
          {
            macroPart = &linePart;
            if (linePart.fPartType == kMacroPart)
            {
              TTextStructure(textStructure)->GetMacroText(linePart.fCharPos, macroText);
              if (macroText[0] == 0) 
                macroPart = NULL;
            }
            else
            {
              macroText[0] = 0;
            }
          }

          if (makeTheView)
            TTextView(itsView)->AddLinePart(partNum, linePart.fPartType,
                         partSize, location, lineNumber, backwards);
          else if (TTextView(itsView)->ChangeLinePart(sign * partNum, linePart.fPartType,
                         partSize, location, lineNumber, backwards))
            *changes = TRUE;
          if (macroPart != NULL)      // 03/04/91, 21/06/94 moved out of both above calls
            TTextView(itsView)->SetMacroPart(partNum, *macroPart, macroText);
        }
        else if (makeTheView)
        {
          // VPoint vSlop;

          // vSlop.v = 0;
          // vSlop.h = 0;
          TTextView(itsView)->AddLinePart(partNum, linePart.fPartType, /* 0,*/ partSize,
              location, lineNumber, backwards); // NULL, NULL);
          widget = GetFormatReadOnly(linePart.tag.cgf_34.fRecNum);
          widgetView = widget->MakeView(linePart.tag.cgf_34.fRecNum, itsViewId, /* 0, vSlop*/
                                          0, itsView, 0, location, NULL, NULL);
        }
        else if (linePart.fPartType == kWidgetPart)
        {
          if (TTextView(itsView)->ChangeLinePart(sign * partNum, linePart.fPartType,
              /* 0, */ partSize, location, lineNumber, 0))   // , NULL, NULL))
            *changes = TRUE;
          widgetView = TSubView(itsView->FirstSubViewThat(this,
              (TestSubView)IsWidgetForPart, linePart.tag.cgf_34.fRecNum));
          if (linePart.fChanged || widgetView == NULL)
          {
            // VPoint vSlop;

            // vSlop.v = 0;
            // vSlop.h = 0;
            widget = GetFormatReadOnly(linePart.tag.cgf_34.fRecNum);
            if (widgetView == NULL)
            {
              TViewId itsViewId;

              if (widgetIndex > itsView->CountSubViews())
                widgetView1 = NULL;
              else
                widgetView1 = itsView->SubViewAt(widgetIndex);
              itsViewId.fId = itsView->fIdentifier;
              widgetView = widget->MakeView(linePart.tag.cgf_34.fRecNum, itsViewId,
                       /* 0, vSlop */ 0, itsView, widgetView1, location, NULL, NULL);
              // FailNIL(widgetView);
            }
            else
            {
              widgetView = DeleteWidgets(widgetIndex,
                                      linePart.tag.cgf_34.fRecNum, itsView);
              widget->UpdateView(linePart.tag.cgf_34.fRecNum, widgetView, location, 0, // vSlop,
                                NULL, NULL, invalidate, updateAll);
            }
          }
          else
          {
            widgetView = DeleteWidgets(widgetIndex,
                                      linePart.tag.cgf_34.fRecNum, itsView);
            widgetView->Locate(location.h, location.v, TRUE);
          }
        }
      }
      // 21/06/93 ascent = Max(ascent, linePart.fAscent + Min(linePart.fLocation.v, 0));
      descent = Max(descent, linePart.fAscent + linePart.fDescent + linePart.fLocation.v);
      if (linePart.fEOL <= kLineBreak)
      {
        lineOffset += descent;      // 21/06/93 
        // 21/06/93 lineOffset = lineOffset + ascent + descent;
        // 21/06/93 ascent = 0;
        descent = 0;
        lineNumber++;
      }
      if (linePart.fEOL == kEndOfPara)
      {
        if (endPart != partNum)
        {
          ReduceSize(partNum);     // 23/08/95 [26020] avoid leaving 'spare' format parts
          numParts -= (endPart - partNum);
        }
        break;
      }
    }

    if (!makeTheView)
    {
      widgetIndex ++;
      while (widgetIndex <= itsView->CountSubViews())
      {
        widgetView = itsView->SubViewAt(widgetIndex);
        widgetView->Free();
      }

      if (numParts == 0)
        itsView->Free();
      else
      {
#ifdef TRACE
        Assert(numParts <= TTextView(itsView)->fVLineParts->fSize, 444);
#endif
        TTextView(itsView)->SetPartCount(numParts);
      }
    }
#ifdef TRACE
    else
      Assert(numParts == TTextView(itsView)->fVLineParts->fSize, 444);
#endif
  }
  Success(&fi);
  return newView;

// ++++++++++++++++++ exception handler ++++++++++++++++++++++++
Rescue:
  FreeIfObject(newView);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TTextFormat::GetLinePart(TCurrency currency, int partNum,
      VRect &extent, /* Fixed &slop, */ TLinePart *macroPart, char *macroText)
{
  TLinePart linePart;
  VPoint partSize;

  Get(partNum, &linePart);

  {
    // The following resets the left and right of 'extent' from the linePart
    // location, width and slop, preserving the top and bottom
    VPoint partLocation;

    partSize.h = FixRound(linePart.fWidth + linePart.fSlop);
    partSize.v = linePart.fAscent + linePart.fDescent;
    ZoomVPt(partSize);

    partSize.v = extent.bottom - extent.top;
      // this may be wrong!!! However if not done the extent.bottom is wrong
#ifdef FIXLOC
    partLocation.h = FixRound(ZoomFixed(linePart.fLocation.h));
#else
    partLocation.h = ZoomInt(linePart.fLocation.h);
#endif
    partLocation.v = extent.top;
    SetLineExtent(extent, partSize, partLocation);

    // 13/09/90 new block for macros
    if (TestInHF(gMainStruct) ||      /* 30/01/94 TestInHF(this, currency) || */
                 linePart.fPartType == kMacroPart) // 05/04/91
    {
      *macroPart = linePart;
      if (linePart.fPartType == kMacroPart)
      {
        TTextStructure(GetStructureReadOnly(currency))->
                     GetMacroText(linePart.fCharPos, macroText); // 19/03/91 RW
        if (macroText[0] == 0)                    // 03/02/92
          macroPart->fCharPos = -1;
      }
      else
        macroText[0] = 0;
   }
   else
     macroPart->fCharPos = -1;                    // 18/04/91
  }
}


// ------------------------------------------------------------------------
bool _TTextFormat::ContainsCursor(TCurrency currency, TObject startBreak,
                                       TObject endBreak, TCursorNode cursor)
{
// 13/09/90 rewritten to use char pos instead of partnums
// 15/7/92 rewritten again because of fns

  int charPos = Min(MAXLONGINT - 1, TTextCursor(cursor)->GetCharPos()); // 03/04/91
  int startChar = 0;
  int endChar = MAXLONGINT;

  if (startBreak != NULL)
  {
    int lpn = LineToPart(this, TTextBreak(startBreak)->BreakPart()) + 1;

    if (lpn > fSize)
      startChar = MAXLONGINT;
    else
    {
      PLinePart p = PLinePart(At(lpn));

      startChar = p->fCharPos;
      // 20/11/92 for double click of wd at end of page followed by widget on next page
      // .. treating the cursor as being on second page
      if (cursor->IsLast() && p->fPartType == kWidgetPart)
        startChar++;
    }
  }

  if (endBreak != NULL)
  {
    int lpn = LineToPart(this, TTextBreak(endBreak)->BreakPart()) + 1;
    
    if (lpn <= fSize)
    {
      PLinePart p = PLinePart(At(lpn));

      endChar = p->fCharPos;

      // 20/11/92 for double click of wd at end of page followed by widget on next page
      // .. treating the cursor as being on second page
      if (cursor->IsLast() && p->fPartType == kWidgetPart)
        endChar++;  // make it find it on first page
    }
  }
  return (startChar <= charPos && charPos < endChar);
}


// ------------------------------------------------------------------------
void _TTextFormat::DoClearFlags(PLinePart linePart, int hf)
{
  linePart->fChanged = FALSE;
  if (linePart->fPartType == kWidgetPart)
  {
    TCurrency curr = linePart->tag.cgf_34.fRecNum;
    TFormat widgetFmt = GetFormatReadWrite(curr); // ReadOnly?: change flags not saved ?
                                                    // they are for text when purging!!
    widgetFmt->ClearChangedFlags(curr, hf);
  }
}


// ------------------------------------------------------------------------
void _TTextFormat::ClearChangedFlags(TCurrency currency, int hf)
{
  Each(this, (DoToItem)_TTextFormat::DoClearFlags, hf);
  SetHasChanged(FALSE);
}


// +++++++++++++++++++++++++ Start of View +++++++++++++++++++++++++++++++

// ------------------------------------------------------------------------
_TTextView::_TTextView(TView itsSuperView, TMainView itsMainView,
    TSubView itsNextView, VPoint &itsLocation, VPoint &itsSize,
    TCurrency itsStructure, int itsSpBefore, int itsSpAfter) :
          (itsMainView->fDocument, itsSuperView, itsMainView, itsNextView,
           itsLocation, itsSize, itsStructure, itsSpBefore, itsSpAfter)
{
  FailInfo fi;

#ifndef ZERO_OBJ
  fVLineParts = NULL;
  fMacroParts = NULL;
  CatchFailures(&fi);
  fStartSelect.fCharPos = 0;
  fStartSelect.fPixelPos = 0;
  fStartSelect.fPartNum = 0;
  fEndSelect.fCharPos = 0;
  fEndSelect.fPixelPos = 0;
  fEndSelect.fPartNum = 0;
#else
  CatchFailures(&fi);
#endif
  fVLineParts = new _TArray(sizeof(TVLinePart));
  Success(&fi);
  return;
// +++++++++++++++ exception handler +++++++++++++++++++
Rescue:
  _TSubView::Free();
  ContinueFailure(&fi);
}


void _TTextView::FreeMacroHandles(PMacroPart macroPart)
 // 14/09/90 new
{
  DisposIfHandle(macroPart->fMacroStructure);
}


// ------------------------------------------------------------------------
void _TTextView::Free()
{
  FreeIfObject(fVLineParts);

   // 14/09/90 free any macro array and embedded handles
  if (fMacroParts != NULL)
  {
    fMacroParts->Each(this, (DoToItem)_TTextView::FreeMacroHandles);
    fMacroParts->Free();
  }

  _TSubView::Free();
}


// ------------------------------------------------------------------------
void _TTextView::Delete()
{
  TTextDocument(fDocument)->PurgeCurrency(fStructure);

  _TSubView::Delete();
}


// ------------------------------------------------------------------------
bool _TTextView::HasPartNum(PVLinePart vLinePart, int partNum)
{
  return (vLinePart->fLinePart == partNum);
}


// ------------------------------------------------------------------------
bool _TTextView::ContainsCursor(TCursorNode cursor, TCursorNode target, TSubView &subView)
{
  bool  ContainsCursor_r;
  int partNum;

  subView = 0;
  ContainsCursor_r = FALSE;
  if (fStructure == cursor->fCurrency)
  {
    partNum = TTextCursor(cursor)->GetPartNum();
    if (fVLineParts->FirstThat(this, (TestItem)_TTextView::HasPartNum, partNum) > 0)
    {
      cursor->fIdentifier = fIdentifier;
      // 17/02/94 avoid GetNext call if possible: subCursor = cursor->GetNext();
      ContainsCursor_r = (cursor->IsLast() || // ((subCursor == 0) ||
          FirstSubViewThat(this, (TestSubView)_TSubView::HasCursor,
                               cursor->GetNext() /* subCursor */, target, &subView) != 0);
      if (cursor == target)
        subView = this;
    }
  }
  return(ContainsCursor_r);
}


// ------------------------------------------------------------------------
void _TTextView::SetupMacros()
  // 28/01/91 - new method
{
  if (fMacroParts != NULL)          // 03/04/91
  {
    TTextFormat textFormat =
               TTextFormat(fMainView->GetFormatReadWrite(fStructure));
  
    SetTextGlobals(TTextStructure(textFormat->GetStructureReadWrite(fStructure)));
    for (int i = 1; i <= fVLineParts->fSize; i++)
    {
      PVLinePart vLinePart = PVLinePart(fVLineParts->At(i));

// 03/04/91      if (vLinePart->fPartType == kMacroPart)
      {
        TLinePart linePart;
        Handle macroText;
        int mn = fMacroParts->FirstThat(this, (TestItem)_TTextView::HasMacroPartNum,
                        vLinePart->fLinePart);

        if (mn > 0)                    // 05/04/91
        {
          PMacroPart foundPart = PMacroPart(fMacroParts->At(mn));

          linePart = foundPart->fMacroFormat;
          macroText = foundPart->fMacroStructure;
//        GetMacroPart(vLinePart->fLinePart, linePart, macroText);
          textFormat->SetMacro(vLinePart->fLinePart, &linePart, macroText);
        }
      }
    }
  }
}


// ------------------------------------------------------------------------
bool _TTextView::HasMacroPartNum(PMacroPart macroPart, int partNum)
{
  return (macroPart->fPartNum == partNum);
}


// ------------------------------------------------------------------------
void _TTextView::SetMacroPart(int partNum, TLinePart &linePart,
                                                      char *macroText)
{
  PMacroPart foundPart;
  TMacroPart macroPart;
  int mn;

  if (fMacroParts == NULL)
    fMacroParts = new _TArray(sizeof(TMacroPart));
  if (macroText[0] == 0)
    macroPart.fMacroStructure = NULL;          // 03/04/91
  else
    macroPart.fMacroStructure = Handle(FailNIL(NewString(macroText)));

  mn = fMacroParts->FirstThat(this, (TestItem)_TTextView::HasMacroPartNum,
                        partNum);

  foundPart = (mn == 0 ? &macroPart : PMacroPart(fMacroParts->At(mn)));
  foundPart->fMacroFormat = linePart;

  if (mn == 0)
  {
    macroPart.fPartNum = partNum;
    fMacroParts->InsertLast(&macroPart);
  }
  else
  {
    // 23/08/95 redundant: foundPart = PMacroPart(fMacroParts->At(mn));
    DisposIfHandle(foundPart->fMacroStructure);
    foundPart->fMacroStructure = macroPart.fMacroStructure;
  }
}

// ------------------------------------------------------------------------
void _TTextView::AddLinePart(int partNum, TPartType partType,
              VPoint &itsSize, VPoint &itsLocation,
              int itsLineNumber, int rtToLeft)
{
  TVLinePart vLinePart;

  vLinePart.fLinePart = partNum;
  vLinePart.fPartType = partType;
  vLinePart.fChanged = TRUE;        // 16/07/91
  vLinePart.fLineNumber = itsLineNumber;  // 27/02/92
  vLinePart.fBackwards = rtToLeft; // 21/06/94
  SetLineExtent(vLinePart.fExtent, itsSize, itsLocation);
  fVLineParts->InsertLast(&vLinePart);
}


// ------------------------------------------------------------------------
void _TTextView::DeleteLineParts(int beforePart)
{
  // 03/05/90 - widgets added
  int pn;
  TVLinePart linePart;
  TCurrency currency;
  TSubView view;
  TTextFormat textFormat;

  if ( beforePart > 1)                             // 18/04/91 extra test
    for (pn = fVLineParts->GetSize(); pn >= 1; pn--)
    {
      fVLineParts->Get(pn, &linePart);
      if (linePart.fLinePart < beforePart)
      {
        if (linePart.fPartType == kWidgetPart)
        {
          textFormat = TTextFormat(GetMyFormatReadOnly());
          currency = textFormat->GetRecNum(linePart.fLinePart);

          view = TSubView(FirstSubViewThat(this, (TestSubView)IsWidgetForPart, currency));
          FreeIfObject(view);
        }
        fVLineParts->Delete(pn);
      }
    }
  if (fMacroParts != NULL)      // 14/09/90
  {
    // 07/06/91 need to free macros   fMacroParts->ReduceSize(0);
    // for (pn = fMacroParts->GetSize(); pn >= 1; pn--)
    //  DisposIfHandle(Handle(PMacroPart(fMacroParts->At(pn))->fMacroStructure));
    fMacroParts->Each(this, (DoToItem)_TTextView::FreeMacroHandles);// 22/08/95 use existing code
    fMacroParts->ReduceSize(0);
  }
}

// ------------------------------------------------------------------------
bool _TTextView::ChangeLinePart(int partNum, TPartType partType,
                 /* Fixed itsSlop,*/ VPoint &itsSize, VPoint &itsLocation,
                 int itsLineNumber, int rtToLeft)
                          // PLinePart macroLinePart, char *macroText) // 27/02/92
{
  TVLinePart vLinePart;
  int count;

  vLinePart.fChanged = (partNum < 0 ? (partNum = -partNum, TRUE) : FALSE);  // 03/02/92 TRUE;
  vLinePart.fLinePart = partNum;     // 03/02/92
  vLinePart.fPartType = partType; // 20/02/92
  vLinePart.fBackwards = rtToLeft; // 21/06/94
  SetLineExtent(vLinePart.fExtent, itsSize, itsLocation); 
  vLinePart.fLineNumber = itsLineNumber;  // 27/02/92

  count = fVLineParts->GetSize();
  if (count == 0)                                 // 15/11/90 new test
  {
    vLinePart.fChanged = TRUE;  // 18/02/92
    fVLineParts->InsertLast(&vLinePart);
  }
  else
  {
    int firstPart;
    int index = Max(1, partNum - PVLinePart(fVLineParts->At(1))->fLinePart + 1);
    // 27/02/92 rest of block new
    // in-line DoChange(index);

    if (index > fVLineParts->GetSize())
    {
      vLinePart.fChanged = TRUE;
      fVLineParts->InsertLast(&vLinePart);
    }
    else
    {
      PVLinePart nextLinePart = PVLinePart(fVLineParts->At(index));

      if (itsLineNumber < nextLinePart->fLineNumber)
      {
        vLinePart.fChanged = TRUE;
        fVLineParts->InsertBefore(index, &vLinePart);
      }
      else
        for(;;)
        {
          if (itsLineNumber > nextLinePart->fLineNumber)
          {
            // only delete if not last, so can atput over last one
            if (index < fVLineParts->GetSize())
            {
              fVLineParts->Delete(index);
              nextLinePart = PVLinePart(fVLineParts->At(index));
            }
            else
            {
              vLinePart.fChanged = TRUE;
              fVLineParts->AtPut(index, &vLinePart);
              break;
            }
          }
          else
          {
            if (!vLinePart.fChanged &&
                      !EqualVRect(vLinePart.fExtent, nextLinePart->fExtent))
              vLinePart.fChanged = TRUE;
            fVLineParts->AtPut(index, &vLinePart);
            break;
          }
        }
    }
    // end in-line DoChange(index);

    firstPart = PVLinePart(fVLineParts->At(1))->fLinePart - 1;
    for (int n = index; n <= fVLineParts->fSize; n++)
      PVLinePart(fVLineParts->At(n))->fLinePart = firstPart + n;
  }
  return vLinePart.fChanged;
}


// ------------------------------------------------------------------------
void _TTextView::SetPartCount(int numParts)
{
  fVLineParts->ReduceSize(numParts);
}


// ------------------------------------------------------------------------
void _TTextView::GetAdornRect(Rect &adornRect)
{
  DoGetAdornRect(adornRect);
}


// ------------------------------------------------------------------------
void _TTextView::DrawUpdateExtent(Rect &updateExtent)
{
  if (updateExtent.top < updateExtent.bottom)
  {
    Rect QDExtent;

    GetQDExtent(QDExtent);
    updateExtent.right = QDExtent.right;

    InsetRect(updateExtent, 0, -GetHLineThickness());  // 25/06/92 ensure all pixels redrawn
    // 25/06/92 deraw from main view down, rather than self, for guides and neigbouring views
    LocalToMainRect(updateExtent);
    fMainView->UpdateVRect(updateExtent);

    SetSillyRect(updateExtent);
  }
}

// ------------------------------------------------------------------------
static bool EitherChanged(TTextFormat textFormat, TVLinePart *vLinePart)
{
  return (vLinePart->fChanged ? TRUE : textFormat->GetChanged(vLinePart->fLinePart));
}

// ------------------------------------------------------------------------
void _TTextView::DrawChanges(bool invalidate, bool installChanges)
{
  TTextFormat textFormat;
  int partNum;
  int numLines;
  int svn;
  VRect viewExtent;
  Rect QDExtent;
  Rect updateExtent;
  TWindow myWindow;
  bool upSet;
  int lastRight = 0;  // set to the offset of the rhs of the last unchanged part on the line
  int lineLimit;
  int macroParts;
  bool doInvalidate = invalidate;  // [26020] a value of 3 - can clear change flags in h/f

#ifdef MATHS
  numLines = 1;   // 23/04/92 see if this speeds things up!
#else
  numLines = 2;
#endif
  // 04/03/92  if (Focus() && (myWindow = TWindow(thePort->GetWindowRef())) != NULL)
#ifdef TRUE
  if (invalidate >= 2)
  {
    invalidate = 0;     // [26020] update HF view if possible to avoid redraw
    numLines = 20;      // [26020] reformat from idle marks all parts changed for some reason!
                        // so try to stop it doing an invalidate
  }
  else
#endif
  if ((myWindow = GetWindow()) != NULL)
  {
    // 04/03/92  textFormat = TTextFormat(fMainView->GetFormat(GetStructure(), kReadOnly));
    if (myWindow->fTarget->fNextHandler != this)
      invalidate = TRUE;
  }
  // 04/03/92 the rest needs to be done whether or not Focussed
  textFormat = TTextFormat(GetMyFormatReadOnly());    // should be kReadWrite surely!!!???

  svn = 1; // 03/05/90 - new to mac
  partNum = 1;
  lineLimit = fVLineParts->GetSize();

  SetSillyRect(updateExtent);  // 12/05/91 moved up
  // 23/04/91 in-line TestChanged
  //  if (!invalidate)                           // 22/09/92 word wrap after widget
  for (; partNum <= lineLimit; partNum++)
  {
    register TVLinePart *vLinePart = PVLinePart(fVLineParts->At(partNum));

    if (EitherChanged(textFormat, vLinePart))
      break;

    if (vLinePart->fPartType == kWidgetPart)  // 13/05/91 !b && .. remvd
      svn++;

    // 12/05/91 set top of highest part in line containing change
    if (textFormat->GetEOL(vLinePart->fLinePart) <= kLineBreak)
    {
      updateExtent.top = MAXLONGINT;
      lastRight = 0;
    }
    else
    {
      updateExtent.top = Min(updateExtent.top, vLinePart->fExtent.top);
      if (!textFormat->fFlags)      // make sure update extent left set to zero (could do better!)
        lastRight = vLinePart->fExtent.right;
    }
  }
  // 01/03/92    if (redraw)
  // 01/03/92    {
  // 01/03/92      updateExtent.top = MAXLONGINT;         // 12/05/91
  // 01/03/92      svn = 1; // 03/05/90 - new to Mac
  // 01/03/92      partNum = 1;
  // 01/03/92      SetSillyRect(fUpdateExtent);
  // 01/03/92    }
  SetTextGlobals(TTextStructure(textFormat->GetStructureReadWrite(fStructure)));

  // 03/02/92 need to update all parts before doing any drawing
  macroParts = (fMacroParts == NULL ? 0 : fMacroParts->fSize); // 04/02/92
  if (installChanges)
    for (int pn = partNum; pn <= lineLimit; pn++)
    {
      register TVLinePart *thePart = PVLinePart(fVLineParts->At(pn));

      if (/* 01/03/92 redraw ||*/
          !invalidate || macroParts != 0 || EitherChanged(textFormat, thePart))
      {
        TLinePart linePart;
        Str255 macro;

        textFormat->GetLinePart(fStructure, thePart->fLinePart,
                     thePart->fExtent, /* thePart->fSlop,*/ &linePart, macro);
        if (linePart.fCharPos >= 0)                  // 18/04/91
          SetMacroPart(thePart->fLinePart, linePart, macro);
      }
    }
  // 03/02/92 end of new install changes loop

  upSet = FALSE;            // 13/05/91 lhs of 1st line update rect set
  for (; partNum <= lineLimit; partNum++)
  {
    register TVLinePart *thePart = PVLinePart(fVLineParts->At(partNum));

    if (/* 01/03/92 (redraw && invalidate) ||*/ // 04/02/92 NB on Mac is : redraw || !invalidate
            doInvalidate || // 25/08/92 backspace out an inline pict, extent only line height
            EitherChanged(textFormat, thePart))
            // 05/02/92 avoid updating just because macros somewhere?
            // || (installChanges && macroParts != 0))      // 18/04/91 & 04/02/92
    {
      MoveRect(viewExtent, thePart->fExtent);
      ViewToQDRect(viewExtent, QDExtent);
      QDExtent.top = Min(QDExtent.top, updateExtent.top);    // 12/05/91

      if (thePart->fPartType == kWidgetPart)
      {
        TSubView widgetView = SubViewAt(svn++);

        widgetView->Locate(viewExtent.left, viewExtent.top, FALSE);
        // 20/02/92 for borders???    if (!invalidate)                     // 10/02/92
          widgetView->DrawChanges(invalidate, installChanges); // 29/01/92
        AddChangedExtent(QDExtent);

        // if we try to update the current line, Draw clears the changed
        // extent, so the picture will not be redrawn. The safest way
        // then seems to be to abandon trying to update the current line
        // or pair of lines, and get it all done by the redraw event.
        if (updateExtent.top < updateExtent.bottom)
          AddChangedExtent(updateExtent);
        invalidate = TRUE;
        SetSillyRect(updateExtent);
      }
      else if (invalidate)
      {
        AddChangedExtent(QDExtent);
      }
      else // draw directly, so build up the update extent
      {
        // 22/04/92 move rubout down a pixel
        updateExtent.top = Min(updateExtent.top, viewExtent.top);
        // 07/10/90 - add in a pixel to the top of the rect to be updated.
        // This is not totally correct, but we cannot afford to inval the top
        // row of pixels, which could be shared with another view, especially
        // in the case of adjacent lines of text, where the extra row of pixels
        // would cause the line above to be redrawn too.
        updateExtent.bottom = Max(updateExtent.bottom, viewExtent.bottom);
        if (!upSet)
          updateExtent.left = lastRight;       // 21/05/91
        upSet = TRUE;
      }
      // 01/03/92 redraw always false        if (!invalidate || !redraw)
      {
        if (thePart->fLinePart <= textFormat->fSize
#ifdef TRUE
           && (!TestInHF(gMainStruct) || doInvalidate == 3)     // [26020] do not clear format
                         // formatting the next HF will probably find no changes
                         // and end up with its view out of sync with format
#endif
                    )
                  // 29/03/94 [21600] stop crash if fmt parts out of sync with view in h/f
          textFormat->SetChanged(thePart->fLinePart, FALSE);
        thePart->fChanged = FALSE;         // 16/07/91
      }
    }
    else if (thePart->fPartType == kWidgetPart)  /* 29/01/92 -new */
      svn++;

    if (!invalidate && textFormat->GetEOL(thePart->fLinePart) <= kLineBreak)    // at line end
    {
//      numLines--;
//      if (numLines == 1 && updateExtent.left != 0)
//        DrawUpdateExtent(updateExtent);  // 13/05/91 do 1st line now
//      
//      if (numLines == 0)   // we have run out of our 2 redrawn lines
//      {
//        invalidate = TRUE;
//        DrawUpdateExtent(updateExtent);
//      }
      if (((numLines--) == 0 && (invalidate = TRUE, TRUE)) || updateExtent.left != 0)
        DrawUpdateExtent(updateExtent);
    }
  }
  textFormat->SetChanged(-1, FALSE);  // 22/08/95 [26020] clear flags before draw
  DrawUpdateExtent(updateExtent);
//  textFormat->SetChanged(-1, FALSE);
  _TSubView::DrawChanges(invalidate, installChanges);
}


// ------------------------------------------------------------------------
static void DoTheErase(int left, int top, int right, int bottom)
{
  Rect rectToErase;
  Rect temp;

  if (gInUpdate)  /* 24/06/92 was !gPrinting) if not in update background cleared */
  {
    SetRect(rectToErase, left, top, right, bottom);
    if (SectRect(rectToErase, *thePort->GetClipRect(), temp))
      EraseRect(rectToErase);  // 24/06/92 do not erase intersection - loses bottom pixels
                               // 21/06/94 use GetClipRect to save passing area as parameter
  }
}


// ------------------------------------------------------------------------
int _TTextView::DrawTextLine(Rect &area, int startPart, TTextFormat textFormat, VRect &extent)
{
  PVLinePart vLinePart;      // current view part being drawn
  int lineTop;
  int lineBottom;
  int lastRight = -1;
  Rect rubOut;
  int lastPart = startPart;
  int currPos = -1;
  int lastMatch = 0;

  // find the number of parts in the line
  for (int fmtPart = PVLinePart(fVLineParts->At(startPart))->fLinePart;
                      textFormat->GetEOL(fmtPart) > kLineBreak; fmtPart++, lastPart++) {}

  lineBottom = lineTop = extent.top;

  while (TRUE)
  {
    Rect QDExtent;
    int QDtop;
    int currentNearest = MAXLONGINT;
    int secondNearest = MAXLONGINT;
    int moreSegments = -1;
    int matched = -1;
    PVLinePart secondPart = NULL;

    vLinePart = NULL;
    // Find the next leftmost part on the current line. Because of zero width parts,
    // we look at the mid-point of the parts, so a zero width part will be processed
    // before a non-zero width part at the same location. (strictly should divide
    // all distances by 2, but unnecessary as we are just comparing positions).
    // The lastMatch test is to avoid looping if we had 2 zero width parts at the
    // same location.

    for (int vPart = startPart; vPart <= lastPart; vPart++)
    {
      PVLinePart thisVPart = PVLinePart(fVLineParts->At(vPart));
      int distance = (thisVPart->fExtent.left + thisVPart->fExtent.right) - currPos;

      if (distance > 0 || (distance == 0 && vPart > lastMatch))
      {
        moreSegments++;
        if (distance < currentNearest)
        {
          secondNearest = currentNearest;
          secondPart = vLinePart;
          currentNearest = distance;
          vLinePart = thisVPart;
          matched = vPart;
        }
        else
        {
          if (distance < secondNearest)
          {
            secondNearest = distance;
            secondPart = thisVPart;
          }
        }
      }
    }
    if (vLinePart == NULL)
      break;

    currPos = vLinePart->fExtent.left + vLinePart->fExtent.right;
    lastMatch = matched;
    // draw each part
    ViewToQDRect(vLinePart->fExtent, QDExtent);

    QDtop = QDExtent.top;
    MoveRect(rubOut, QDExtent);   // 22/04/91
    rubOut.bottom += GetHLineThickness();  // 24/06/92 rub out all pixels at bottom of text
    if (lastRight >= 0)
    {
      DoTheErase(lastRight, lineTop, rubOut.left, lineBottom);
      rubOut.left = lastRight;    // 22/04/91
    }
    if (vLinePart->fPartType != kWidgetPart && // moreSegments && 
             secondPart != NULL && secondPart->fPartType != kWidgetPart)
              // && lastSegment > kLineBreak &&
              // PVLinePart(fVLineParts->At(i + 1))->fPartType != kWidgetPart)
              // there is a non widget part to the right!!!!
    {
      // rub out an extra bit for italic encroachment 18/05/95 exclude rt. margin release tabs
      rubOut.right = (rubOut.right > extent.right ? rubOut.right + rubOut.bottom - rubOut.top :
                    Min(extent.right, rubOut.right + rubOut.bottom - rubOut.top));
    }
    lastRight = rubOut.right;
    // Erase the parts of the current line not in a line part
    if (QDtop < lineTop) // extent goes above previous highest
    {
      // 24/06/92 never move lineTop up, or can erase pixels already drawn
      // 24/06/92      DoTheErase(extent.left, QDtop, rubOut.left, lineTop);
      // 24/06/92      lineTop = QDtop;
    }
    else
      // do the bit above the current line part
      DoTheErase(rubOut.left, lineTop, rubOut.right, QDtop);

    if (rubOut.bottom > lineBottom) // extent goes below previous lowest
    {
      // erase from view edge up to edge of line part
      DoTheErase(extent.left, lineBottom, rubOut.left, rubOut.bottom);
      lineBottom = rubOut.bottom;
    }
    else
      // do the bit under the current line part
      DoTheErase(rubOut.left, rubOut.bottom, rubOut.right, lineBottom);

    rubOut.top = lineTop;
    rubOut.bottom = lineBottom;
    if (!moreSegments)
      DoTheErase(rubOut.right, lineTop, extent.right, lineBottom);  // erase to line end

    vLinePart->fChanged = FALSE;     // 03/02/92
    if (vLinePart->fPartType != kWidgetPart)
    {
      Rect temp;

      // 25/03/91 whole clause moved out of SectRect test
      MoveRect(temp, QDExtent);        // 12/06/91
      temp.right = rubOut.right;       // 12/06/91 rubOut was being ignored
      if (SectRect(temp, area, temp))
      {
        textFormat->Draw(vLinePart->fLinePart, QDExtent, rubOut);

        // validate area drawn
        if (gInUpdate && !moreSegments)   // 14/07/92
          thePort->ValidRect(rubOut);
      }
    }
  }
  extent.top = lineBottom;
  return lastPart + 1;
}

// ------------------------------------------------------------------------
void _TTextView::Draw(Rect &area)
{
  int i = 1;
  TTextFormat textFormat = TTextFormat(GetMyFormatReadOnly());
  VRect extent;

  _TSubView::Draw(area);

  GetExtent(extent);
  InvalBorders(area, extent);  // 29/08/90 indent by the adornment
  // 21/06/94 only do extent.left: InsetVRect(extent, GetVLineThickness(), 0);
  extent.left += GetVLineThickness();  // only inset left (avoid adding back)

  SetupMacros();         // 03/04/91
  SetTextGlobals(TTextStructure(GetStructureReadOnly(fStructure)));

#ifdef INDEX
  gShowIndexEntries = (fMainView->fShowPictures >> 1) && !gPrinting;
#endif
  while (i <= fVLineParts->fSize)
    i = DrawTextLine(area, i, textFormat, extent);
}


// ------------------------------------------------------------------------
int _TTextView::GetCaretSize(Point &pos, TCursorNode cursorNode)
{
  // new 22/04/93 for common bit of ghost and real carets
  Rect          viewExtent;
  TVLinePart    vLinePart;
  TTextEdge     edge;
  int           partNum;

  TTextCursor(cursorNode)->GetEdge(edge);
  partNum = edge.fPartNum;
  GetViewPart(partNum, vLinePart);
  MoveRect(viewExtent, vLinePart.fExtent);
  if (edge.fPixelPos == (vLinePart.fBackwards ? viewExtent.right - viewExtent.left: 0))
  {
    // 11/02/94 [21385] this test moved from after partNum > ...(1) test
    if (vLinePart.fPartType == kWidgetPart && edge.fCharPos > 0)
      viewExtent.left = viewExtent.right;      // 26/08/93 [21037] for consecutive widgets
    else if (partNum > PVLinePart(fVLineParts->At(1))->fLinePart)
    {
      GetViewPart(partNum - 1, vLinePart);
      if ((vLinePart.fPartType == kTextPart || vLinePart.fPartType == kMacroPart) &&
          // 27/06/94 test for != FillerPart && != BulletPart too & tidy up test
          // vLinePart.fPartType != kWidgetPart && vLinePart.fPartType != kNotePart &&
                                             // 26/08/93 [21037] notepart was on Mac
          vLinePart.fExtent.bottom > viewExtent.top)
            // && (edge.fPixelPos != 0 || !vLinePart.fBackwards))
      {
        viewExtent.left = (vLinePart.fBackwards ? vLinePart.fExtent.left :
                                                  vLinePart.fExtent.right) - edge.fPixelPos;
        viewExtent.top = vLinePart.fExtent.top;
        viewExtent.bottom = vLinePart.fExtent.bottom;
      }
    }
  }
  SetPt(pos, viewExtent.left + edge.fPixelPos, viewExtent.bottom);
  return viewExtent.bottom - viewExtent.top;
}


// ------------------------------------------------------------------------
void _TTextView::DoSetupMenus()
{
  SetupMenus();      // 10/06/93 [20896] common up with Maths
}


// ------------------------------------------------------------------------
TCommand _TTextView::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
#ifdef TABLES
  if (aCmdNumber == cSuperscript || aCmdNumber == cSubscript)
    return TTextDocument(fDocument)->
                MakeStyleCommand(DoFaceChange, aCmdNumber - cSuperscript + 2);
#endif
#ifdef MATHS
  if (aCmdNumber == cNewMatrix)
    aCmdNumber = cMatrix;        // 14/04/92
#endif
  // check for cDocTitle to cChapCount inclusive
  if ((aCmdNumber >= cDocTitle && aCmdNumber <= cChapCount)
      || (aCmdNumber < 0 && MenuForNegCmd(aCmdNumber)  == cmMerge)
                               // MMerge 13/5/92 && check in Merge menu 16/05/92
#ifdef FN
      || (aCmdNumber == cFootNote)
#endif
#ifdef MATHS
      || (aCmdNumber >= cIntegralOp && aCmdNumber <= cExpression) ||
        aCmdNumber == cFunction ||      // 24/03/92 remv cAbove, cBelow
        (aCmdNumber >= cContourInt1 && aCmdNumber <= cContourInt3) // 01/06/92
#endif
    )
  {
    SetupMacros();
    return (new _TNewStructureCmd(TTextDocument(/*fMainView->*/fDocument),
                                               aCmdNumber, GetStructure()));
  }
#ifdef NETWP
  if (aCmdNumber == cSelectParagraph)
  {
    TSelection theSelection = TTextDocument(fDocument)->GetNewSelection();

    theSelection->ClickAgain(this);
    theSelection->ClickAgain(this);
    // simulate a triple click: does not matter if double or triple already
    theSelection->SelectLevel(-1);
    theSelection->Highlight(fMainView, TRUE);
    return gNoChanges;
  }
#else
#ifndef TABLES
  if (aCmdNumber == cSelectParagraph)
  {
    int anItem;
    TLevelInfo levelInfo;

    if (TTextDocument(fDocument)->GetNewSelection()->
                                FindLevelInfo(fStructure, anItem, levelInfo) <= 0)
      TTextDocument(fDocument)->SelectLevel(anItem);
    return gNoChanges;
  }
#endif
#endif
  return _TSubView::DoMenuCommand(info, aCmdNumber);
}


// ------------------------------------------------------------------------
int _TTextView::CountViewParts()
{
  return fVLineParts->GetSize();
}

// ------------------------------------------------------------------------
static bool ReturnPartForNum(TObject ignore, PVLinePart vLinePart, PVLinePart pt)
{
  if (vLinePart->fLinePart == pt->fLinePart)
    return (bool)memcpy(pt, vLinePart, sizeof(TVLinePart));  // save a Get after finding it

  return FALSE;
}

// ------------------------------------------------------------------------
void _TTextView::GetViewPart(int partNum, TVLinePart &viewPart)
{
  viewPart.fLinePart = partNum;
#ifdef TRACE
  int index =
#endif
    fVLineParts->FirstThat(this, (TestItem)ReturnPartForNum, &viewPart);
#ifdef TRACE
  Assert(index, 820);
#endif
}


// ------------------------------------------------------------------------
void _TTextView::DoHighlightSelection(HLState fromHL, HLState toHL)
{
  if (Selected() && fromHL != toHL)
  {
    HighlightParts(fStartSelect, fEndSelect, toHL == HLOn);
    // unnecessary: fHLDesired = toHL;
  }
}


// ------------------------------------------------------------------------
void InvertTheExtent(TView theView, Rect *extent)
{
  InvertRect(*extent);
}

// ------------------------------------------------------------------------
void _TTextView::HighlightParts(TTextEdge &first1, TTextEdge &last1,
                                                                bool turnOn)
{
  Rect extent;
  int firstPart;
  int  pn;
  TVLinePart viewPart;
  TTextEdge first = first1;
  TTextEdge last = last1;
  Rect viewExtent;
  PVLinePart part1 = PVLinePart(fVLineParts->At(1));
  TPartType part1Type = part1->fPartType;           // 25/04/91
  int numParts = fVLineParts->GetSize();            // 26/04/91

  GetQDExtent(viewExtent);
  firstPart = part1->fLinePart - 1;
  for (pn = first.fPartNum; pn <= last.fPartNum; pn++)
  {
    if (pn - firstPart <= fVLineParts->GetSize())
    {
      fVLineParts->Get(pn - firstPart, &viewPart);
      ViewToQDRect(viewPart.fExtent, extent);
      if (EmptyRect(extent))
      {
        if (numParts == 1)
        {
          extent.left = viewExtent.left;
          extent.right = viewExtent.right;
        }
        else if (part1Type == kBulletPart && pn == 2)
          extent.right = viewExtent.right;
      }
      else
      {
        int origLeft = extent.left;

        if (viewPart.fPartType == kWidgetPart)    // 04/08/92 big picture hilite out of view
          SectRect(extent, viewExtent, extent);
        else
        if (pn == last.fPartNum)
                /* && viewPart.fPartType != kWidgetPart 04/08/92 now redundant */
        {
          if (last.fPixelPos != MAXLONGINT)     // 10/02/94 from < MAXINT
          {
            if (viewPart.fBackwards)
              extent.left += last.fPixelPos;
            else
              extent.right = last.fPixelPos + extent.left;
          }
          else // 10/02/94 if (last.fPixelPos == MAXLONGINT)
          {
            if (viewPart.fBackwards)
              extent.left = viewExtent.left;
            else
              extent.right = viewExtent.right;
          }
        }
        if (pn == first.fPartNum)
        {
          if (viewPart.fBackwards)
          {
            if (first.fCharPos != 0)
              extent.right = first.fPixelPos + origLeft;
          }
          else
            extent.left += first.fPixelPos;
        }
      }
#ifdef DRAGDROP
      if (turnOn == 2)
      {
        LocalToMainRect(extent);
        UnionRect(fMainView->fZoomBox, extent, fMainView->fZoomBox);
      }
      else
#endif
        NoNH_DoInUpdate(extent, (DrawProc)InvertTheExtent, &extent);
    }
  }
}


// ------------------------------------------------------------------------
bool _TTextView::IsSelectedWidget(PVLinePart part, int* widgetIndex,
                                  TTextEdge* endSelect)
{
  // 25/07/90 - new local proc in mac

//  PVLinePart part = PVLinePart(fVLineParts->At(index));

  if (part->fPartType == kWidgetPart)
  {
    (*widgetIndex)++;
    return (part->fLinePart == endSelect->fPartNum);
  }
  return FALSE;
}

// ------------------------------------------------------------------------
void _TTextView::MoveLeftOrRight(TTextEdge &edge, bool goLeft)
{
  // 03/02/91 normalise index to vLineParts
  int firstPart = PVLinePart(fVLineParts->At(1))->fLinePart - 1;

  // This is IsWidget(...) in-line
  if (PVLinePart(fVLineParts->At(edge.fPartNum - firstPart))->fPartType == kWidgetPart)
  {
    if (goLeft)
    {
      if (edge.fPartNum - firstPart > 1)  // 08/0/94
      {
        edge.fPartNum--;
        // 27/08/93 [21039] fPixelPos is displacement from start of part not start of line!
        edge.fPixelPos =
          LengthRect(PVLinePart(fVLineParts->At(edge.fPartNum - firstPart))->fExtent, h);
          // [21039] PVLinePart(fVLineParts->At(edge.fPartNum - firstPart))->fExtent.right;
      }
    }
    else
    {
      edge.fPartNum++;
      edge.fPixelPos = 0;
    }
  }
}

// ------------------------------------------------------------------------
void _TTextView::SetWidgetHighlight(TCursorNode anchor, TCursorNode activeEnd,
                                               bool redraw, TTextEdge *endSelect)
{
  int widgetIndex = 0;

  fVLineParts->FirstThat(this,
        (TestItem)_TTextView::IsSelectedWidget, &widgetIndex, endSelect);
  if (widgetIndex != 0)
    SubViewAt(widgetIndex)->SetHighlight(anchor, activeEnd, redraw, FALSE);
}

// ------------------------------------------------------------------------
void _TTextView::SetHighlight(TCursorNode anchor, TCursorNode activeEnd,
                              bool redraw, bool noteSelection) // fn1
{
  TTextEdge startSelect;
  TTextEdge endSelect;
  bool cleared, doWidget;
  bool wasAllWidget;
  int firstPart;
  int lastPart;
  TVLinePart viewPart;
  // TSubView widgetView;
  TCursorNode n1, n2;
  // int widgetIndex;
  PVLinePart linePrt;
  bool emptyPara;

  cleared = FALSE;
  linePrt = PVLinePart(fVLineParts->At(1));
  firstPart = linePrt->fLinePart;
  if (linePrt->fPartType == kBulletPart)
    firstPart++;
  linePrt = PVLinePart(fVLineParts->At(fVLineParts->GetSize()));
  lastPart = linePrt->fLinePart;
  emptyPara = (firstPart == lastPart && EmptyVRect(linePrt->fExtent));
  wasAllWidget = (fStartSelect.fPartNum == MAXINT); // 04/02/91 > lastPart);
  if (anchor == NULL)
  {
    startSelect.fCharPos = 0;
    startSelect.fPartNum = firstPart;
    startSelect.fPixelPos = 0;
    n1 = NULL;  // 25/07/90
  }
  else if (anchor == TCursorNode(-1))
  {
    startSelect.fCharPos = MAXINT;
    startSelect.fPartNum = lastPart;
    startSelect.fPixelPos = MAXLONGINT;     // 10/02/94 from MAXINT
    cleared = TRUE;
    n1 = TCursorNode(-1); // 25/07/90
  }
  else
  {
    TTextCursor(anchor)->GetEdge(startSelect);
    n1 = anchor->GetNext(); // 25/07/90
  }

  if (activeEnd == TCursorNode(-1))
  {
    endSelect.fCharPos = 0;
    endSelect.fPartNum = firstPart;
    endSelect.fPixelPos = 0;
    cleared = TRUE;
    n2 = TCursorNode(-1); // 25/07/90
  }
  else if (activeEnd == NULL || emptyPara)
  {
    endSelect.fCharPos = MAXINT;
    endSelect.fPartNum = lastPart;
    endSelect.fPixelPos = MAXLONGINT;     // 10/02/94 from MAXINT
    n2 = NULL;
  }
  else
  {
    TTextCursor(activeEnd)->GetEdge(endSelect);
    n2 = activeEnd->GetNext(); // 25/07/90
    if (n2 != NULL) // 8/4/92
      endSelect.fCharPos++;
  }

  // 25/07/90 - next block is all new
  if (cleared)
  {
    doWidget = wasAllWidget;  // 23/01/91 was (fStartSelect.fPartNum > lastPart);
    if (doWidget)
      endSelect.fPartNum = fEndSelect.fPartNum;  // 19/04/91 was startSelect.
  }
  else if (startSelect.fPartNum == endSelect.fPartNum)
  {
    GetViewPart(startSelect.fPartNum, viewPart);
    doWidget = (viewPart.fPartType == kWidgetPart);
    if (doWidget)
      startSelect.fPartNum = MAXINT;  // 04/02/91 lastPart + 1;
  }
  else if (wasAllWidget)       // 23/01/91 new block
  {
    int partNum = fEndSelect.fPartNum;

    SetWidgetHighlight(TCursorNode(-1), NULL, redraw, &fEndSelect);
    // widgetIndex = 0;
    // fVLineParts->FirstThat(this,
    //    (TestItem)_TTextView::IsSelectedWidget, &widgetIndex, &fEndSelect);
    // widgetView = SubViewAt(widgetIndex);
    // widgetView->SetHighlight(TCursorNode(-1), NULL, redraw, FALSE); // fn1
    fStartSelect.fPartNum = partNum;
    doWidget = FALSE;
  }
  else
    doWidget = FALSE;

  if (doWidget) // 09/01/91 moved from in redraw & focus condition
  {
    if (fEndSelect.fPartNum > 0)
    {
      if (!wasAllWidget) // 29/4/92 remove old sel
        HighlightParts(fStartSelect, fEndSelect, TRUE);
      else if (fEndSelect.fPartNum != endSelect.fPartNum)
              // 08/11/95 deselect any another picture in the same paragraph
      {
        SetWidgetHighlight(TCursorNode(-1), NULL, redraw, &fEndSelect);
        // widgetIndex = 0;
        // fVLineParts->FirstThat(this,
        //    (TestItem)_TTextView::IsSelectedWidget, &widgetIndex, &fEndSelect);
        // if (widgetIndex != 0)
        // {
        //   widgetView = SubViewAt(widgetIndex);
        //   widgetView->SetHighlight(TCursorNode(-1), NULL, redraw, FALSE); // fn1
        // }
      }
    }
    SetWidgetHighlight(n1, n2, redraw, &endSelect);
    // widgetIndex = 0;
    // fVLineParts->FirstThat(this,
    //    (TestItem)_TTextView::IsSelectedWidget, &widgetIndex, &endSelect);
    // if (widgetIndex != 0)    // 19/11/92 crashes on Undo change which makes widget wrap
    // {
    //   widgetView = SubViewAt(widgetIndex);
    //   widgetView->SetHighlight(n1, n2, redraw, FALSE); // fn1
    // }
  }
  else if (redraw && Focus())
  {
    if (!Selected() && !cleared)
    {
      HighlightParts(startSelect, endSelect, 
#ifdef DRAGDROP
         redraw == 2 ? 2 :            // 29/09/93 [21060] got 3*click highlighting wrong
#endif
         TRUE);
    }
    else if (Selected() && (cleared 
#ifdef DRAGDROP
        || redraw == 2
#endif
        ))
      HighlightParts(fStartSelect, fEndSelect, redraw); // 25/04/91 FALSE);
    else
    {
      if (startSelect.fCharPos < fStartSelect.fCharPos)
      {
        if (!wasAllWidget)
          MoveLeftOrRight(fStartSelect, TRUE);
        HighlightParts(startSelect, fStartSelect, FALSE); // 25/04/91 TRUE);
        wasAllWidget = FALSE; // 29/4/92
      }
      else if (startSelect.fCharPos > fStartSelect.fCharPos)
      {
        MoveLeftOrRight(startSelect, TRUE);
        HighlightParts(fStartSelect, startSelect, FALSE);
        wasAllWidget = FALSE; // 29/4/92
      }
      if (endSelect.fCharPos > fEndSelect.fCharPos)
      {
        if (!wasAllWidget)
          MoveLeftOrRight(fEndSelect, FALSE);
        HighlightParts(fEndSelect, endSelect, FALSE); // 25/04/91 TRUE);
      }
      else if (endSelect.fCharPos < fEndSelect.fCharPos)
      {
        MoveLeftOrRight(endSelect, FALSE);
        HighlightParts(endSelect, fEndSelect, FALSE);
      }
      else if (wasAllWidget) // 29/4/92 added else
        HighlightParts(startSelect, endSelect, FALSE);
    }
  }

#ifdef DRAGDROP
  if (redraw != 2)
#endif
  {
    if (cleared)
    {
      fStartSelect.fPartNum = lastPart + 1; // 07/09/92 + 1 to stop rehilite on Select widget
      fStartSelect.fCharPos = MAXINT;
      fEndSelect.fPartNum = firstPart;
      fEndSelect.fCharPos = 0;
      fHLDesired = HLOff;
    }
    else
    {
      fStartSelect = startSelect;
      fEndSelect = endSelect;
#ifdef VIEWACT
      if (fMainView->fViewActive)
#endif
//    if (redraw)                 // 15/01/91 make like pictures
        fHLDesired = HLOn;
    }
    Select(!cleared);
  }
}


// ------------------------------------------------------------------------
void _TTextView::GetTrackLimits(TSubView subView, VRect &picLimits,
                                             TwoBools repositionInText)
{
  // 03/05/90 - new method to mac
  VRect extent;
  TFormat format;
  long asc, desc;
//  Fixed lm, rm;

  if (repositionInText == 3)       // reposition && inText)
  {
    subView->GetExtent(extent);
    subView->LocalToMainRect(extent);
//    subView->LocalToMainView(*extent.topLeft);
//    subView->LocalToMainView(*extent.botRight);
    MoveRect(picLimits, extent);
    format = fMainView->GetFormatReadOnly(subView->fStructure);
    asc = 0;        // 01/07/92
    format->GetDepth(asc, desc);
    picLimits.top -= ZoomFixed(desc);
    picLimits.bottom += ZoomFixed(asc);
  }
  else
  {
    repositionInText &= 1;
    TSubView(fSuperView)->GetTrackLimits(this, picLimits, repositionInText);
                                                       // FALSE, inText);
    if (repositionInText)        // inText)
    {
      format = GetMyFormatReadOnly();  // 29/05/90 - this blk is new
      picLimits.left += FixRound(ZoomFixed(format->GetLeftMargin()));
      picLimits.right -= FixRound(ZoomFixed(format->GetRightMargin()));
    }
  }
}

#ifdef TRACE
// ------------------------------------------------------------------------
bool _TTextView::CheckMouse(TView theSubView, VPoint &theMouse,
                  EventInfo &info, TCommand &theCommand)
{
   VPoint subViewPt;

   subViewPt = theMouse;
   theSubView->SuperToLocal(subViewPt);
   return (theSubView->ContainsMouse(subViewPt) ?
     theSubView->HandleMouseDown(subViewPt, info, theCommand):
     FALSE);
}


// ------------------------------------------------------------------------
bool _TTextView::HandleMouseDown(VPoint &theMouse, EventInfo &info,
                                   TCommand &theCommand)
{
  bool  HandleMouseDown_r;
  TView viewThatHandledMouse;
  Point theQDMouse;

  HandleMouseDown_r = FALSE;
  theCommand = gNoChanges;
  viewThatHandledMouse = LastSubViewThat(this, (TestSubView)_TTextView::CheckMouse,
                     &theMouse, &info, &theCommand);
  if (viewThatHandledMouse != NULL)
    HandleMouseDown_r = TRUE;
  else
    if (IsViewEnabled() && Focus()) {
      ViewToQDPt(theMouse, theQDMouse);
      theCommand = DoMouseCommand(theQDMouse, info);
      HandleMouseDown_r = TRUE;
  }
  return(HandleMouseDown_r);
}
#endif

// ------------------------------------------------------------------------
void _TTextView::ClickAgain(TCursorNode cursor, bool rightEdge)
{
  TTextFormat textFormat;

  textFormat = TTextFormat(GetMyFormatReadOnly());
  
  SetTextGlobals(TTextStructure(GetStructureReadOnly(fStructure))); // 19/03/91 RW
  textFormat->ClickAgain(TTextCursor(cursor), this, rightEdge);
}


// ------------------------------------------------------------------------
// [21384] rewritten to handle properly dragging into the space below line parts
TCursorNode _TTextView::ClickOnce(VPoint &mousePoint)
{
  PVLinePart vLinePart;
  PVLinePart lastPart;
  PVLinePart startPart;
  PVLinePart endPart;
  TTextFormat textFormat = TTextFormat(GetMyFormatReadOnly());
  Rect lineExtent;
//  bool offLeft;
  bool offRight;     // 27/06/94 now really 'offBottom'
  bool leftSide;
  VPoint clickPoint;
  Rect extent;
  TTextEdge textEdge;
  int part;

  SetTextGlobals(TTextStructure(GetStructureReadOnly(fStructure)));

  // Get the mouse point in same coordinate system as line extents
  GetExtent(extent);
  LocalToMainRect(extent);
  clickPoint.h = mousePoint.h - extent.left;
  clickPoint.v = mousePoint.v - extent.top;

  // first find the line we are on and set startPart and endPart to parts on that line

  // ClearRect(lineExtent);         // form the union of all the line extents
  // lineExtent.left = MAXLONGINT;  // 27/06/94 avoid left being set to 0 for rt justified
//  offLeft = FALSE;
  offRight = FALSE;
  leftSide = FALSE;
  startPart = endPart = NULL;
  vLinePart = PVLinePart(fVLineParts->fPtrToArray);  // &vlp->At(1)
  lastPart = vLinePart + fVLineParts->fSize;
  for (; vLinePart < lastPart; vLinePart++)
  {
    if (startPart == NULL)       // starting a new line
    {
      startPart = vLinePart;
      MoveRect(lineExtent, vLinePart->fExtent);
                              // 27/06/94 avoid left being set to 0 for rt justified lines
    }
    else
      UnionRect(lineExtent, vLinePart->fExtent, lineExtent);
    if (textFormat->GetEOL(vLinePart->fLinePart) <= kLineBreak)
    {
      // end of line, see if mouse in the current union of line extents
      if (clickPoint.v < lineExtent.bottom)
      {
        // we have found the line containing the mouse
        if (clickPoint.h < lineExtent.left)
        {
          clickPoint.h = lineExtent.left;       // force
          // offLeft = TRUE;
        }
        if (clickPoint.h >= lineExtent.right)
        {
          clickPoint.h = lineExtent.right;  // pick up in off right case - 1;
          // offRight = TRUE;
        }
        endPart = vLinePart;
        break;
      }
      startPart = NULL;
    }
  }

  if (startPart == NULL)   // off bottom - treat this as off right of last part
  {
    vLinePart = lastPart - 1;
    offRight = TRUE;
  }
  else
  {
    // Now go through the clicked-on line again to find the nearest or hit part
    // Even though offLeft set, we need to do this because of bullets!
    int nearestRight = MAXLONGINT;
    PVLinePart nearPart = NULL;

    vLinePart = startPart;
    do
    {
      Rect *viewExtent = &vLinePart->fExtent;

      // 07/06/94 need to test against left size for backwards typing
      if ((clickPoint.h >= viewExtent->left && clickPoint.h < viewExtent->right))
                                                      //     || vLinePart == endPart)
      {
        // we have located the part 'containing' the mouse
        if (vLinePart->fPartType == kBulletPart)
        {
          clickPoint.h = viewExtent->right;
//          offLeft = FALSE;
        }
        else if (vLinePart->fPartType == kFillerPart ||
                 vLinePart->fPartType == kMacroPart
#ifdef FN
              || vLinePart->fPartType == kNotePart
#endif
               )
        {
          // 21/5/92 changed conditional for clicking on macros etc
          if (clickPoint.h * 2 >= viewExtent->left + viewExtent->right)
            clickPoint.h = viewExtent->right;
          else
          {
            clickPoint.h = viewExtent->left;
            leftSide = TRUE;
          }
        }
        PinVRect(*viewExtent, clickPoint);
        break;
      }
      // 27/06/94 there may be holes in line; find rightmost before click point
      if (unsigned(clickPoint.h - viewExtent->right) < nearestRight)
      {
        nearestRight = clickPoint.h - (viewExtent->left + viewExtent->right) / 2;
                               // use rect centre so zero rects are to right
        nearPart = vLinePart;
      }
      vLinePart++;
    }
    while (vLinePart <= endPart || (vLinePart = nearPart, offRight = TRUE, FALSE));
  }

  // finish off by building the cursor

  part = textEdge.fPartNum = vLinePart->fLinePart;

  if (vLinePart->fPartType == kWidgetPart)
  {
    textEdge.fCharPos = textFormat->GetCharPos(part);
    textEdge.fPixelPos = 0;
  }
  else if (offRight)
  {
    textEdge.fCharPos = textFormat->GetCharPos(part) + (textFormat->fFlags ? 0 :
             textFormat->GetNumChars(part) - (textFormat->GetEOL(part) < kModifiedHyphen));
    textEdge.fPixelPos = LengthVRect(vLinePart->fExtent, h);
  }
  else
  {
    int pixelPos;

    pixelPos = clickPoint.h - vLinePart->fExtent.left;
    SetupMacros();    // 28/01/91
    textEdge.fCharPos = textFormat->ClickOnce(part, pixelPos,
                                        LengthRect(vLinePart->fExtent, h), leftSide);
    textEdge.fPixelPos = pixelPos;
  }
  return new _TTextCursor(fStructure, fIdentifier, textEdge, leftSide, clickPoint);
}


// ------------------------------------------------------------------------
_TTextCursor::_TTextCursor(TCurrency curr,
                           IDType id,
                           TTextEdge &edge,
                           bool leftSide,
                           VPoint &mousePt)
                        : (curr, id, mousePt)
{
  fEdge = edge;
//  fRightEdge = rightEdge;
  fLeftSide = leftSide;
#ifndef ZERO_OBJ
  fReverseWrap = FALSE;
  fChange = 0;
  fReformat = kNoChg; // 29/05/90
#endif
}


// ------------------------------------------------------------------------
void _TTextCursor::GetEdge(TTextEdge &edge)
{
  edge = fEdge;
}


/* ------------------------------------------------------------------------
int _TTextCursor::GetChange()
{
  return fChange;
}
*/

/* ------------------------------------------------------------------------
bool _TTextCursor::GetReverseWrap()
{
  return fReverseWrap;
}
*/

/* ------------------------------------------------------------------------
bool _TTextCursor::GetLeftSide()
{
  return fLeftSide;
}
*/

/* ------------------------------------------------------------------------
// 18/07/93 made inline
TCharPos _TTextCursor::GetCharPos()
{
  return fEdge.fCharPos;
}
*/

/* ------------------------------------------------------------------------
int _TTextCursor::GetPartNum()
{
  return fEdge.fPartNum;
}
*/

// ------------------------------------------------------------------------
void _TTextCursor::Copy(TCursorNode cursorNode)
{
  fEdge = TTextCursor(cursorNode)->fEdge;
//  fRightEdge = TTextCursor(cursorNode)->fRightEdge;
  fLeftSide = TTextCursor(cursorNode)->fLeftSide;
  fReverseWrap = TTextCursor(cursorNode)->fReverseWrap;
  fChange = 0;
  fReformat = TTextCursor(cursorNode)->fReformat; // 29/05/90
  _TCursorNode::Copy(cursorNode);
}


// ------------------------------------------------------------------------
bool _TTextCursor::Equal(TCursorNode node)
{
  return (node != NULL && fCurrency == node->fCurrency &&
                              fEdge.fCharPos == TTextCursor(node)->fEdge.fCharPos);
}


// ------------------------------------------------------------------------
void _TTextCursor::Adjust(TCharPos pos, int delta)
{
  if (fEdge.fCharPos > pos)
    fEdge.fCharPos += delta;
}


// ------------------------------------------------------------------------
void _TTextCursor::SetCharPos(TCharPos pos)
{
  fEdge.fCharPos = pos;
// 12/02/92 this was screwing up formatting after Ctrl-arrows:  fEdge.fPartNum = 1; // 25/07/90 - prev set to 0
//  fRightEdge.fCharPos = rightPos;
}


// ------------------------------------------------------------------------
void _TTextCursor::ChangeCharPos(int amount)
{
  fEdge.fCharPos += amount;
//  fRightEdge.fCharPos += amount;
// 07/02/92  fChange = (amount > 0 ? fChange + 1: amount);         // 25/04/91 > 0 test
// 21/02/92  fChange += amount;   // 07/02/92 for buffered (fast) deletes
}


/* ------------------------------------------------------------------------
void _TTextCursor::SetChange(int change)
{
  fChange = change;
}
*/

/* ------------------------------------------------------------------------
void _TTextCursor::SetReverseWrap(bool couldWrap)
{
  fReverseWrap = couldWrap;
}
*/

// ------------------------------------------------------------------------
void _TTextCursor::SetEdge(TTextEdge &edge)
{
  fEdge = edge;
}


// ------------------------------------------------------------------------
long _TTextCursor::DoNeedDiskSpace(long dataForkBytes)
{
  return _TCursorNode::DoNeedDiskSpace(sizeof(fEdge) - sizeof(_TTextCursor) +
                         sizeof(_TCursorNode) + dataForkBytes);
}


// ------------------------------------------------------------------------
void _TTextCursor::DoWrite(int aRefNum, long remainder)
{
  _TCursorNode::DoWrite(aRefNum, sizeof(_TCursorNode) + sizeof(fEdge));

// 09/06/94 FWrite(aRefNum, sizeof(fEdge), &fEdge);
}


// ------------------------------------------------------------------------
void _TTextCursor::DoRead(int aRefNum, long remainder, int version)
{
  fReformat = kNoChg; // 29/05/90
  _TCursorNode::DoRead(aRefNum, sizeof(_TCursorNode) + sizeof(fEdge), version);

// 09/06/94  FRead(aRefNum, sizeof(fEdge), &fEdge);
}
