/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include "os.h"
#include "swis.h"
#include "akbd.h"

#include "Support.h"
#include "PDocument.h"
#include "DrawIFace.h"
#include "PApplicat.h"

#define PDriver_SelectDriver (0x80158)
#define kTextFile       (0x0fff)
#define kStationeryPad  (0x0d00)
#define kMSWord         (0x0ae6)

extern struct {
   char *contents;
   int   fileHandle;
   long  filePos;
   long  eof;
} gRAMFile;

// 26/04/94 [21709] int gSaveInRAMMax = 0;  // 06/07/92
static int gNumUntitled = 0;

typedef struct {
   unsigned int discAddress : 28;
   unsigned int isPurgable  : 1;
   unsigned int isLocked    : 1;
   unsigned int isDirty     : 1;
   unsigned int isInStore   : 1;
} flagsAndAddr;

typedef flagsAndAddr *flgAndAddr;

typedef struct {
   union {
      unsigned int asWord;
      flagsAndAddr asStruct;
   } topWord;
   union {
      unsigned int  discLength;
      TDiscObject   theData;
   } data;
} TDiscRecord;

#define info  topWord.asStruct
#define wInfo topWord.asWord

#define kIndexUnit sizeof(TDiscRecord)
#define kIncrement 10
#define bzRevert   12

#define purgableMask    0x10000000
#define inStoreMask     0x80000000
#define inStoreAndDirty 0xc0000000
// static const flagsAndAddr inStoreMask     = { 0,0,0,1 };
// static const flagsAndAddr inStoreAndDirty = { 0,0,1,1 };

typedef TDiscRecord  *PDiscRecords;

typedef struct {
   long startAddress;
   long slotLength;
} TFreeExtentsRecord;

typedef TFreeExtentsRecord *PFreeExtents;

typedef unsigned int       *PRecPosns;

typedef struct {
   unsigned int recordSize;
   unsigned int totalRecords:24;
   unsigned int handlerVersion:8;
   unsigned int freeIndex;
} TDumpIndex;


// TSaveDocCommand ========================================================
// ------------------------------------------------------------------------
void _TSaveDocCommand::DoIt()
{
   fChangedDocument->Save(fCmdNumber);
}


// ------------------------------------------------------------------------
void _TSaveDocCommand::Free()
{
  // do not free this, it is global
}


// TRevertDocCommand ======================================================
// ------------------------------------------------------------------------
void _TRevertDocCommand::DoIt()
{
   // 25/06/90 put up a better message for 'reverting to untitled document'
   if (Alert(fChangedDocument->fSaveExists ? phRevert : phRevertToEmpty,
                              -1, fChangedDocument->fTitle) == kYesButton)
   {
      FailInfo fi;

      CatchFailures(&fi);
      fChangedDocument->Revert();
      Success(&fi);
Rescue:
      fChangedDocument->ShowReverted();
      ContinueIfFail(&fi);
   }
}


// ------------------------------------------------------------------------
_TRevertDocCommand::_TRevertDocCommand(CmdNumber itsCmd, TDocument itsDoc)
                                     :(itsCmd, itsDoc, NULL, NULL)
{
   fCanUndo = FALSE;
   fCausesChange = FALSE;
}


// ###################  TRECORDHANDLER ####################################
// ------------------------------------------------------------------------
_TRecordHandler::_TRecordHandler(TDocument itsDocument,
                TRecordHandler master, TDiscObject prototype, int version)
{
   FailInfo fi;

   fDocument      = itsDocument;
   fMaster        = master;
#ifndef ZERO_OBJ
   fSlaves        = NULL;
   fRecordList    = NULL;
   fNewFilePosns  = NULL;
   fPrototype     = NULL;    // 14/08/90 if creator fails, do not free proto
   fFreeRecordIdx = 0;
   fDiscVersion = 0;
#endif
   fCurrentVersion = version;

   CatchFailures(&fi);

   AllocateEmptyHandle(&fRecordList);
   AllocateEmptyHandle(&fNewFilePosns);

   itsDocument->InstallRecordHandler(this);
   if (master != NULL)
      master->InstallSlave(this);
         
   Success(&fi);
   fPrototype = prototype;
   return;

// ************************** Exception Handler *******************
Rescue:
   _TRecordHandler::Free();  // force a call to the destructor
   ContinueFailure(&fi);     // and call the previous exception handler
}


// ------------------------------------------------------------------------
void _TRecordHandler::PurgeRecord(TRecordIndex recordToPurge)
{
  TDiscObject dataHandle;
  TDiscRecord theRecordInfo;
  volatile long slotAddress;
  int refNum;
  FailInfo fi;

#ifdef TRACE
  Assert(recordToPurge < (GetHandleSize(fRecordList) / kIndexUnit), 44);
#endif
  theRecordInfo = PDiscRecords(fRecordList)[recordToPurge];
  if (theRecordInfo.info.isInStore &&
                         (refNum = fDocument->fDataRefnum) != kNoFileRefnum)
  {
    slotAddress = -1;
    if (theRecordInfo.data.theData == NULL)
    {
#ifdef TRACE
      if ((fMaster == NULL) ||
       ((PDiscRecords(fMaster->fRecordList)[recordToPurge].info.isInStore) &&
       (PDiscRecords(fMaster->fRecordList)[recordToPurge].data.theData == NULL)))
        Assert(0, 45);
#endif
    }
    else if (!theRecordInfo.info.isLocked)
    {
       long discLength;

       dataHandle = theRecordInfo.data.theData;
       discLength = dataHandle->NeededDiskSpace();
       theRecordInfo.data.discLength = discLength;
       if (theRecordInfo.info.isDirty)
       {
          CatchFailures(&fi);
          slotAddress = fDocument->FindFreeSlot(discLength);
          theRecordInfo.info.discAddress = slotAddress;

          gSavingDoc = fDocument;  // temp for repairing styles
          dataHandle->WriteObject(refNum, slotAddress);
#ifdef TRACE
          long temp;

          GetFPos(refNum, temp);
          Assert(temp == discLength + slotAddress, 715);
#endif
          Success(&fi);
          dataHandle->UpdateStatistics(1, &fDocument->fStatistics);
       }
       dataHandle->Free();
       theRecordInfo.info.isInStore = FALSE;
       PDiscRecords(fRecordList)[recordToPurge] = theRecordInfo;
    }
  }
  return;
// ************** exception handler *******************************
Rescue:

  if (slotAddress >= 0)
     fDocument->AddToFreeExtents(slotAddress, theRecordInfo.data.discLength);
}


// ------------------------------------------------------------------------
void _TRecordHandler::UpdateStatistics(PStatistics stats)
{
   TRecordIndex maxRecIdx = GetHandleSize(fRecordList) / kIndexUnit;
   TRecordIndex theRecIdx = 1;

   while (theRecIdx < maxRecIdx)
   {
      register PDiscRecords ref = PDiscRecords(fRecordList) + theRecIdx;

      if ((ref->wInfo & inStoreAndDirty) == inStoreAndDirty &&
                                              ref->data.theData != NULL)
        ref->data.theData->UpdateStatistics(1, stats);
      theRecIdx++;
   };
}


// ------------------------------------------------------------------------
void _TRecordHandler::FreeRecHdlr(TRecordHandler item)
{
   item->Free();            /* force a call to the item's destructor */
}


void _TRecordHandler::Free()
{
   TRecordIndex maxRecIdx;
   TRecordIndex theRecIdx;

   maxRecIdx = GetHandleSize(fRecordList) / kIndexUnit;
   theRecIdx = 1;
   while (maxRecIdx > theRecIdx)
   {
      register TDiscRecord *ref = PDiscRecords(fRecordList) + theRecIdx;

      if ((ref->info.isInStore) && (ref->data.theData != NULL))
         ref->data.theData->Free();
      theRecIdx++;
   }
   DisposIfHandle(fRecordList);
   DisposIfHandle(fNewFilePosns);
   fDocument->DeInstallRecordHandler(this);
   if (fMaster != NULL)
      fMaster->RemoveSlave(this);

   if (fSlaves != NULL)
   {
      fSlaves->Each(this, (DoToObject)_TRecordHandler::FreeRecHdlr);
      fSlaves->Free();
   }
   
   FreeIfObject(fPrototype);

   _TObject::Free();
}


// ------------------------------------------------------------------------
TDiscObject _TRecordHandler::GetPrototype()
{
   return TDiscObject(fPrototype->Clone());
}


// ------------------------------------------------------------------------
void _TRecordHandler::InstallSlave(TRecordHandler slave)
{
#ifdef TRACE
   Assert(fMaster == NULL, 46);
#endif

   if (fSlaves == NULL)
      fSlaves = new _TList();
   
   fSlaves->InsertLast(slave);
}


// ------------------------------------------------------------------------
void _TRecordHandler::RemoveSlave(TRecordHandler slave)
{
   if (fSlaves != NULL)
      fSlaves->Delete(slave);
}


// ------------------------------------------------------------------------
long _TRecordHandler::GetRecordLength(TRecordIndex aRecord)
{
   register TDiscRecord *ref = PDiscRecords(fRecordList) + aRecord;
   long itsLength;

#ifdef TRACE
   Assert(aRecord < (GetHandleSize(fRecordList) / kIndexUnit), 44);
#endif

   if (ref->info.isInStore)
   {
      itsLength = 0;
      if (ref->data.theData == NULL)
      {
#ifdef TRACE
         if ((fMaster == NULL) ||
         (((PDiscRecords(fMaster->fRecordList) + aRecord)->info.isInStore) &&
         (((PDiscRecords(fMaster->fRecordList) + aRecord)->data.theData) == NULL)))
            Assert(0, 48);
#endif

      }
      else
      {
         itsLength = ref->data.theData->NeededDiskSpace();
      }
   }
   else
      itsLength = ref->data.discLength;

   return itsLength;
}


// ------------------------------------------------------------------------
long _TRecordHandler::SaveRecord(TRecordIndex aRecord, int aRefNum,
                                BOOL savePositions)
{
   long     filePos;
   register TDiscRecord theRecordInfo = (PDiscRecords(fRecordList))[aRecord];
   Handle   theDataHandle;
   long     nChars;
   FailInfo fi;

#ifdef TRACE
   Assert(aRecord < (GetHandleSize(fRecordList) / kIndexUnit), 44);
#endif

   GetFPos(aRefNum, filePos);
   if (savePositions)
     (PRecPosns(fNewFilePosns))[aRecord] = filePos;

   if (theRecordInfo.info.isInStore)
   {
#ifdef TRACE
     if ( (fMaster != NULL) &&
     (((PDiscRecords(fMaster->fRecordList) + aRecord)->info.isInStore) &&
     ((PDiscRecords(fMaster->fRecordList) + aRecord)->data.theData == NULL)))
        Assert(0, 49);
#endif

      if (theRecordInfo.data.theData != NULL) 
      {
          gSavingDoc = fDocument;  // temp for repairing styles
         // 29/08/90 if not uninstantiated slave ...
         // get the object to copy itself to the file
         theRecordInfo.data.theData->WriteObject(aRefNum, filePos);
#ifdef TRACE
         long temp;

         GetFPos(aRefNum, temp);
         Assert(temp - filePos == theRecordInfo.data.theData->NeededDiskSpace(), 716);
#endif
      }
   }
   else if (fDiscVersion == fCurrentVersion ||
         theRecordInfo.info.discAddress >= fDocument->GetRevertSize())
   {
      // copy the record from document to 'aRefNum' file
      // 18/03/91 break into nK chunks if NewHandle fails
#ifdef MATHS
#define kTransBuffSize (6 * 1024)
#else
#define kTransBuffSize (2 * 1024)
#endif
      int amount = kTransBuffSize;
      char tempBuff[kTransBuffSize];
      void *ptr = tempBuff;
      int currDiscAd = theRecordInfo.info.discAddress;

      nChars = theRecordInfo.data.discLength;
      theDataHandle = NULL;
      if (nChars > kTransBuffSize)
         theDataHandle = NewHandle(nChars);
      if (theDataHandle != NULL)
      {
         ptr = theDataHandle;
         amount = nChars;
      }

      while (nChars > 0)
      {
         if (amount > nChars)
            amount = nChars;
         CatchFailures(&fi);
         fDocument->ReadRecord(ptr, currDiscAd, amount);
         Success(&fi);
         fPrototype->AboutToRewrite(ptr, amount);  // 05/03/91
         FWrite(aRefNum, amount, ptr);
         currDiscAd += amount;                     // 09/04/91 inc disc addr
         nChars -= amount;
      }
      DisposIfHandle(theDataHandle);
   }
   else          // 02/03/91
   {
      TDiscObject theObject = GetPrototype();

      gSavingDoc = fDocument;  // temp for repairing styles
      theObject->ReadObject(fDocument->fDataRefnum,
                          theRecordInfo.info.discAddress, fDiscVersion);
      theObject->WriteObject(aRefNum, -1);
      theObject->Free();
   }

   return(filePos);

// ************************** Exception Handler *******************
Rescue:

#ifdef TRACE
   wr_werr(0, "failed reading record number %d", aRecord);
#endif

   DisposIfHandle(theDataHandle);
   ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
int _TRecordHandler::RelinkFreeChain()
  // 16/03/91 new
{
  int head = 0;

  if (fMaster == NULL)
  {
    int tail = 0;
    int lastRec = GetHandleSize(fRecordList) / kIndexUnit;

    for (int i = 1; i < lastRec; i++)
    {
      register PDiscRecords thisRec = PDiscRecords(fRecordList) + i;

      if (thisRec->info.isInStore && thisRec->data.theData == NULL)
      {
        // the entry is free, so chain it into free list
        if (head == 0)
          head = i;
        else
          PDiscRecords(fRecordList)[tail].wInfo = inStoreMask | i;
        tail = i;
      }
    }
    if (tail != 0)
      PDiscRecords(fRecordList)[tail].wInfo = inStoreMask;
  }

  return head;
}


// ------------------------------------------------------------------------
int _TRecordHandler::TidyUpFreeChain()
  // 24/07/90 to remove spare (free) entries from a record handler ready
  // for a save to disc. The original is not altered, and it is up to the
  // calling routine to sort out the pointer from the last free entry,
  // which will index off the end of the array of records
{
  if (fMaster != NULL)
    return fMaster->TidyUpFreeChain();
  else
  {
    int indexSize = GetHandleSize(fRecordList);
    register PDiscRecords thisRec;

    while (indexSize > kIndexUnit &&
      (thisRec = PDiscRecords(fRecordList) + (indexSize / kIndexUnit) - 1,
      thisRec->info.isInStore && thisRec->data.theData == NULL))
    {
      indexSize -= kIndexUnit;
    }
    return Max(indexSize, kIndexUnit);  // in case handle size zero
  }
}


// ------------------------------------------------------------------------
void _TRecordHandler::SaveIndex(int aRefNum, long position)
{
   TDumpIndex            redTape;
   TDiscRecord           buffer;
   long                  i = sizeof(TDumpIndex);
   long                  recLen = kIndexUnit;
   int                   maxRec = TidyUpFreeChain();

   redTape.recordSize = maxRec;
   redTape.totalRecords = 0;
   redTape.handlerVersion = fCurrentVersion;
   redTape.freeIndex = 0;
   SetFPos(aRefNum, position);
   FWrite(aRefNum, i, &redTape);

   maxRec = maxRec / kIndexUnit;
   for (i = 1; i < maxRec; i++)
   {
      PDiscRecords ref = (PDiscRecords(fRecordList) + i);
      flagsAndAddr flg = flgAndAddr(fNewFilePosns)[i];

#ifdef TRACE
      if (!ref->info.isInStore || ref->data.theData != NULL)
         // see if save posn == -1, i.e. this record never saved & not free
         Assert(*(((int *)fNewFilePosns) + i) != -1, 50);
#endif

      buffer.info = flg;
      if (ref->info.isInStore)
      {
         if (ref->data.theData == NULL)
         {
            buffer = *ref;
            if (buffer.info.discAddress >= maxRec)
               buffer.info.discAddress = 0;                      // 24/07/90
         }
         else
            buffer.data.discLength =
                            ref->data.theData->NeededDiskSpace();
      }
      else if (fDiscVersion == fCurrentVersion ||
                      ref->info.discAddress >= fDocument->GetRevertSize())
         buffer.data.discLength = ref->data.discLength;
      else          // 02/03/91
      {
         TDiscObject theObject = GetPrototype();

         theObject->ReadObject(fDocument->fDataRefnum,
                                      ref->info.discAddress, fDiscVersion);
         buffer.data.discLength = theObject->NeededDiskSpace();
         theObject->Free();
      }
      FWrite(aRefNum, recLen, &buffer);
   }
}


// ------------------------------------------------------------------------
void _TRecordHandler::UpdateIndex(TRecordIndex aRecord, TRecordHandler same)
{
  PRecPosns recPosns = PRecPosns(fNewFilePosns);
  register PDiscRecords ref = (PDiscRecords(fRecordList) + aRecord);

#ifdef TRACE
   Assert((int)recPosns[aRecord] >= 0, 51);
#endif

   ref->info.discAddress = recPosns[aRecord];
}


// ------------------------------------------------------------------------
void _TRecordHandler::SwitchFiles()
{
   fDiscVersion = fCurrentVersion;                 // 05/03/91
   ForAllRecordsDo(this, (DoToRecord)_TRecordHandler::UpdateIndex);
}


// ------------------------------------------------------------------------
void _TRecordHandler::LoseHandles(TRecordIndex aRecord, TRecordHandler same)
{
   register PDiscRecords ref = PDiscRecords(fRecordList) + aRecord;

   if (ref->info.isInStore)
      FreeIfObject(ref->data.theData);
}


// ------------------------------------------------------------------------
void _TRecordHandler::Reverting()
{
   ForAllRecordsDo(this, (DoToRecord)_TRecordHandler::LoseHandles);

   fFreeRecordIdx = 0;
   SetHandleEmpty(&fRecordList);
   SetHandleEmpty(&fNewFilePosns);
}


// ------------------------------------------------------------------------
void _TRecordHandler::LoadIndex(long position)
{
   TDumpIndex redTape;
   long       posSize;

   fDocument->ReadRecord(&redTape, position, sizeof(TDumpIndex));

   posSize = (redTape.recordSize / kIndexUnit) * 4;
   SetPermHandleSize(&fRecordList, redTape.recordSize);

   fDiscVersion = redTape.handlerVersion;
   if (redTape.recordSize > 0)
      fDocument->ReadRecord((char *)fRecordList + kIndexUnit,
                            position + sizeof(TDumpIndex),
                            redTape.recordSize - kIndexUnit);

   fFreeRecordIdx = RelinkFreeChain();  // 16/03/91

   SetPermHandleSize(&fNewFilePosns, posSize);
      // 24/07/90 moved here so fRecordList set up if this should fail
#ifdef TRACE
   for (int i = 1; i < posSize / 4; i++)
   {
      PRecPosns(fNewFilePosns)[i] = -1;
   }
#endif
}


// ------------------------------------------------------------------------
static TRecordIndex InitIdxBlock(Handle *recordList, Handle *recPosns,
                                                long oldSize, long newSize)
{
   TRecordIndex lastNewEntry = newSize / kIndexUnit;
   TRecordIndex firstNewEntry = Max(1, oldSize / kIndexUnit);
   long         posSize = lastNewEntry * 4;
   long         i;

   SetPermHandleSize(recordList, newSize);

   lastNewEntry--;

   for (i = firstNewEntry; i <= lastNewEntry; i++)
   {
      register PDiscRecords ref = (PDiscRecords(*recordList) + i);

      ref->wInfo = inStoreMask | (i == lastNewEntry ? 0 : i + 1);
      ref->data.theData = NULL;
   }

   SetPermHandleSize(recPosns, posSize); // 24/07/90 moved after recList init

#ifdef TRACE
   for (i = firstNewEntry; i <= lastNewEntry; i++)
      PRecPosns(*recPosns)[i] =  -1;
#endif

   return(firstNewEntry);
}


// ------------------------------------------------------------------------
void _TRecordHandler::InitIndex()
{
#ifdef TRACE
   Assert(GetHandleSize(fRecordList) == 0, 53);
   Assert(fMaster, 54);
#endif

   InitIdxBlock(&fRecordList, &fNewFilePosns, 0, 
                                     GetHandleSize(fMaster->fRecordList));
}


// ------------------------------------------------------------------------
TRecordIndex _TRecordHandler::NextRecIndex()
{
   long         oldTableSize;
   long         newTableSize;
   TRecordIndex newRecIdx = fFreeRecordIdx;

   if (newRecIdx == 0)
   {
      oldTableSize = GetHandleSize(fRecordList);
      newTableSize = oldTableSize + (kIncrement * kIndexUnit);
      newRecIdx = InitIdxBlock(&fRecordList, &fNewFilePosns, oldTableSize,
                                                           newTableSize);
      if (fSlaves != NULL)
         fSlaves->Each(this, (DoToObject)_TRecordHandler::AddMoreEntries, newTableSize);
   }

   fFreeRecordIdx = (PDiscRecords(fRecordList)+newRecIdx)->info.discAddress;
   return newRecIdx;
}


// ------------------------------------------------------------------------
void _TRecordHandler::AddMoreEntries(TRecordHandler recHdlr,long newTableSize)
{
   InitIdxBlock(&recHdlr->fRecordList, &recHdlr->fNewFilePosns,
                GetHandleSize(recHdlr->fRecordList), newTableSize);
}


// ------------------------------------------------------------------------
void _TRecordHandler::DeleteRecord(TRecordIndex recordToDelete)
{
   TRecordIndex recordToDel = recordToDelete;

#ifdef TRACE
   Assert(recordToDelete < (GetHandleSize(fRecordList) / kIndexUnit), 44);
   Assert(fMaster == NULL, 57);
#endif

   DelRecord(this, recordToDel);
   if (fSlaves != NULL)
      fSlaves->Each(this, (DoToObject)_TRecordHandler::DelRecord, recordToDel);
   fFreeRecordIdx = recordToDel;
}


// ------------------------------------------------------------------------
void _TRecordHandler::LoadAndRmveExtent(int discAddress, int discLength)
{
   if (fPrototype->UpdateStatistics(0, NULL))
   {
      // 17/06/91 read in the record to see 
      volatile TDiscObject theObject = NULL;
      FailInfo fi;

      CatchFailures(&fi);          // must not fail in Commit

      theObject = GetPrototype();

      theObject->ReadObject(fDocument->fDataRefnum,
                 discAddress, fCurrentVersion == fDiscVersion ||
                 discAddress >= fDocument->GetRevertSize() ?
                                         fCurrentVersion : fDiscVersion);
      Success(&fi);
      theObject->UpdateStatistics(-1, &fDocument->fStatistics);
Rescue:
      FreeIfObject(theObject);
   }
   fDocument->AddToFreeExtents(discAddress, discLength);
}

// ------------------------------------------------------------------------
void _TRecordHandler::RmveRecord(int theInfo, TDiscObject theObj)
{
   if (!((flagsAndAddr *)&theInfo)->isDirty)
   {
      long rSiz = theObj->NeededDiskSpace();

      fDocument->AddToFreeExtents(((flagsAndAddr *)&theInfo)->discAddress, rSiz);
      theObj->UpdateStatistics(-1, &fDocument->fStatistics);
   }
}


// ------------------------------------------------------------------------
void _TRecordHandler::DelRecord(TRecordHandler recHdlr,
                                                   TRecordIndex recordToDel)
{
   TDiscRecord theRecordInfo =
                          (PDiscRecords(recHdlr->fRecordList))[recordToDel];

#ifdef MATHS
   if (recHdlr->fPrototype != NULL)
      recHdlr->fPrototype->DeleteAssociations(recordToDel);  // 24/03/92
#endif
   if (theRecordInfo.info.isInStore)
   {
     if (theRecordInfo.data.theData != NULL)
     {
       recHdlr->RmveRecord(theRecordInfo.wInfo, theRecordInfo.data.theData);
       theRecordInfo.data.theData->Free();
     }
#ifdef TRACE
     else
       Assert(recHdlr != this, 58);
#endif
   }
   else
   {
      recHdlr->LoadAndRmveExtent(theRecordInfo.info.discAddress, theRecordInfo.data.discLength);
   }
   theRecordInfo.wInfo = inStoreMask | fFreeRecordIdx;
   theRecordInfo.data.theData = NULL;
   PDiscRecords(recHdlr->fRecordList)[recordToDel] = theRecordInfo;
}


// ------------------------------------------------------------------------
void _TRecordHandler::ReplaceRecordObject(TRecordIndex aRecord, 
                                                     TDiscObject newObject)
{
   TDiscRecord theRecordInfo;

#ifdef TRACE
   Assert(newObject, 59);
   Assert(aRecord < GetHandleSize(fRecordList) / kIndexUnit, 44);
#endif

   theRecordInfo = (PDiscRecords(fRecordList))[aRecord];
   if (theRecordInfo.info.isInStore)
   {
      if (theRecordInfo.data.theData == NULL)
      {
#ifdef TRACE
       if ((fMaster == NULL) ||
       (((PDiscRecords(fMaster->fRecordList)+aRecord)->info.isInStore) &&
       ((PDiscRecords(fMaster->fRecordList)+aRecord)->data.theData == NULL)))
         Assert(0, 60);
#endif
         theRecordInfo.info.isDirty = TRUE;
      }
      else
      {
         RmveRecord(theRecordInfo.wInfo, theRecordInfo.data.theData);
         theRecordInfo.info.isDirty = TRUE;
#ifdef TRACE
         Assert(theRecordInfo.data.theData != newObject, 61);
#endif
         theRecordInfo.data.theData->Free();
      }
   }
   else
   {
      LoadAndRmveExtent(theRecordInfo.info.discAddress, theRecordInfo.data.discLength);
      theRecordInfo.wInfo = inStoreAndDirty;
   }
   theRecordInfo.data.theData = newObject;

   PDiscRecords(fRecordList)[aRecord] = theRecordInfo;
}

#ifdef TRACE
static void breaker() {}
#endif

// ------------------------------------------------------------------------
TDiscObject _TRecordHandler::GetRecordObject(TRecordIndex aRecord, bool readOnly)
{
   // 16/12/93 Allow user to indicate record may not exist by adding 2 to readOnly
   TDiscRecord theRecordInfo;
   volatile TDiscObject theObject;
   FailInfo    fi;

#ifdef TRACE
   if (!Odd(readOnly)) breaker();
#endif

   if (readOnly >= 2 && (aRecord == 0 || aRecord >= GetHandleSize(fRecordList) / kIndexUnit))
     return NULL;
#ifdef TRACE
   Assert(aRecord < GetHandleSize(fRecordList) / kIndexUnit, 44);
#endif

   theRecordInfo = (PDiscRecords(fRecordList))[aRecord];
   if (!theRecordInfo.info.isInStore)
   {
      theObject = GetPrototype();

      CatchFailures(&fi);

      theObject->ReadObject(fDocument->fDataRefnum,
         theRecordInfo.info.discAddress, fCurrentVersion == fDiscVersion ||
         theRecordInfo.info.discAddress >= fDocument->GetRevertSize() ?
                                         fCurrentVersion : fDiscVersion);
#ifdef MATHS
      theObject->SetAssociations(aRecord);   // 24/03/92
#endif
      Success(&fi);
      theRecordInfo.info.isDirty   = FALSE;
      theRecordInfo.data.theData   = theObject;
      theRecordInfo.info.isInStore = TRUE;
      PDiscRecords(fRecordList)[aRecord] = theRecordInfo;
   }
   else if (theRecordInfo.data.theData == NULL)
   {
      PDiscRecords masterRec;

      if (
#ifndef TRACE
          readOnly >= 2 &&
#endif
          (fMaster == NULL ||
            (masterRec = PDiscRecords(fMaster->fRecordList) + aRecord,
               masterRec->info.isInStore && masterRec->data.theData == NULL)))
#ifndef TRACE
          return NULL;
#else
      {
         if (readOnly >= 2)
            return NULL;
         SysBeep(0);
      }
#endif
      theRecordInfo.data.theData = GetPrototype();
      theRecordInfo.wInfo = inStoreAndDirty;
      PDiscRecords(fRecordList)[aRecord] = theRecordInfo;
   }
   if (!(Odd(readOnly) || (theRecordInfo.info.isDirty)))
   {
      long rSiz;

      theRecordInfo.info.isDirty = TRUE;
      rSiz = theRecordInfo.data.theData->NeededDiskSpace();
      fDocument->AddToFreeExtents(theRecordInfo.info.discAddress, rSiz);
      PDiscRecords(fRecordList)[aRecord] = theRecordInfo;
      theRecordInfo.data.theData->
                           UpdateStatistics(-1, &fDocument->fStatistics);
   }
   return(theRecordInfo.data.theData);

// ************************** Exception Handler *******************
Rescue:
   FreeIfObject(theObject);
   ContinueFailure(&fi);     // and call the previous exception handler
}


// ------------------------------------------------------------------------
TRecordIndex _TRecordHandler::NewRecordObject(TDiscObject& theObject)
{
   TRecordIndex newRecIdx;
   FailInfo     fi;
   register PDiscRecords ref;

   theObject = GetPrototype();
   CatchFailures(&fi);

   newRecIdx = NextRecIndex();
   ref = PDiscRecords(fRecordList) + newRecIdx;

#ifdef TRACE
   Assert(fMaster == NULL, 63);
#endif

   ref->wInfo = inStoreAndDirty;
   ref->data.theData = theObject;

   Success(&fi);
   return newRecIdx;

// ************************** Exception Handler *******************
Rescue:
   ClearObject(theObject);
   ContinueFailure(&fi);     // call the previous exception handler
}


typedef struct TEachList
   {
      unsigned a;
      unsigned b;
      unsigned c;
      unsigned d;
      unsigned e;
      unsigned f;
      unsigned g;
      unsigned h;
   } TEachList;

// ------------------------------------------------------------------------
void _TRecordHandler::ForAllRecordsDo(TObject obj, DoToRecord procToDo, ...)
{
   TRecordIndex maxRecIdx = GetHandleSize(fRecordList) / kIndexUnit;
   TRecordIndex theRecIdx = 1;
   char         *args = (char *)&procToDo + sizeof(procToDo);

   while (theRecIdx < maxRecIdx)
   {
      register PDiscRecords ref = PDiscRecords(fRecordList) + theRecIdx;

      if (!(ref->info.isInStore && ref->data.theData == NULL))
         (procToDo)(obj, theRecIdx, this, *(TEachList *)args);
      theRecIdx++;
   };
}


// ------------------------------------------------------------------------
long _TRecordHandler::GetIndexSize()
{
//return sizeof(TDumpIndex) + Max(0,GetHandleSize(fRecordList) - kIndexUnit);
  return sizeof(TDumpIndex) + TidyUpFreeChain() - kIndexUnit;
                                // 24/07/90 ignore free entries on the end
}


// ------------------------------------------------------------------------
void _TRecordHandler::SumSpaceRequired(TRecordIndex aRecord,
            TRecordHandler same, int* totalSize)
{
   *totalSize += GetRecordLength(aRecord);
}


long _TRecordHandler::DiscSpaceNeeded()
{
   long totalSize = 0;

   ForAllRecordsDo(this, (DoToRecord)_TRecordHandler::SumSpaceRequired, &totalSize);
   return totalSize;
}


// ------------------------------------------------------------------------
bool _TRecordHandler::SetRecordLock(TRecordIndex aRecord, bool newSetting)
{
  bool ret_r;
  register PDiscRecords ref = PDiscRecords(fRecordList) + aRecord;

  ret_r = ref->info.isLocked;
  ref->info.isLocked = newSetting;
  return ret_r;
}


// ###################  TDOCUMENT  ########################################
// ------------------------------------------------------------------------
_TDocument::_TDocument(OSType itsFileType)
                    // 03/02/93 [20607] ,bool keepsDataOpen, bool stationery)
                    : (gApplication)
   // itsFileType is the type of file which the document will be read from
   // or kTWScrapType for documents created to hold scrap
   // [20607] stationery, etc now set when file is read. This sets up the
   // document object variables to the state they should be when creating
   // an empty document, so they will be reset by ReadFromFile.
{
   FailInfo fi;

   fFileType = itsFileType;  // used to decide how to handle file during read
                             // ... eg. if a Word document, or a kTWScrapType
   fFileSizeChanged = eofUnknown;
   // 03/02/92 [20607] set when file read:  fStationery = stationery;
#ifndef ZERO_OBJ
   fRevertSize = 0;
   fFreeExtents = 0;
   fRecordHandlers = 0;
   fRAMfile = FALSE;
   fDamaged = FALSE;
   fStationery = FALSE;     // 03/02/92
   fStationeryName = NULL;
   fCannotRevert = FALSE;
   fWindowList = NULL;
   fViewList = NULL;
   fDocPrintHandler = NULL;
   fTitle = NULL;
   fNickName = NULL;
#ifdef SHAREPRINT
   fPrintInfo = NULL;
#endif
   fSaveExists = FALSE;   // really means that fTitle is a file name, not <untitled>
   fChangeCount = 0;
   fPrinterScrap = FALSE;
   fDataOpen = FALSE;     // still connected to a file, so may not all be in memory
   fSavePrintInfo = FALSE;
#endif
   fDataRefnum = kNoFileRefnum;
#ifdef SHAREPRINT
   fSharePrintInfo = FALSE;
#endif
   fModDate[0] = 3;   // OS_Word 14,3 - read real time
   wr_wimpt_noerr(wr_os_word(14, fModDate));

   CatchFailures(&fi);

   fRecordHandlers = NewList();
   AllocateEmptyHandle(&fFreeExtents);
   fWindowList = NewList();
   fViewList = NewList();

   Success(&fi);
   return;

// ------------------------------------------------------------------------
Rescue:
   _TDocument::Free();
   ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TDocument::FreeAHandler(TRecordHandler handler)
{
   handler->Free();
}


// ------------------------------------------------------------------------
void _TDocument::Free()
{
   TList theRecList = fRecordHandlers;

   if (theRecList != NULL)
      theRecList->Each(this, (DoToObject)_TDocument::FreeAHandler);
   DisposIfHandle(fFreeExtents);
   gApplication->DeleteDocument(this);
   FreeFile();
   if (fWindowList != NULL)
      fWindowList->FreeList();
   if (fViewList != NULL)
      fViewList->FreeList();
#ifdef SHAREPRINT
   if (fSharePrintInfo)
      DisposIfHandle(fPrintInfo);
#endif
   DisposIfHandle(fTitle);
   if (fNickName != fTitle)
     DisposIfHandle(fNickName);
   DisposIfHandle(fStationeryName);  // 17/03/91

   FreeIfObject(theRecList);

   _THandler::Free();    // call inherited method
}


// ------------------------------------------------------------------------
void _TDocument::AddView(TView aView)
{
   fViewList->InsertLast(aView);
}


// ------------------------------------------------------------------------
void _TDocument::AddWindow(TWindow aWindow)
{
   fWindowList->InsertLast(aWindow);
}


// ------------------------------------------------------------------------
void _TDocument::DeleteView(TView viewToDelete)
{
   fViewList->Delete(viewToDelete);
}


// ------------------------------------------------------------------------
void _TDocument::DeleteWindow(TWindow windowToDelete)
{
   fWindowList->Delete(windowToDelete);
}

// ------------------------------------------------------------------------
TCommand _TDocument::SaveImmediately()
{
  // for saving files without going through saveas
//  long neededBlocks = 0;
  TSaveInfo fileInfo;

//  CommitLastDocCommand();       // 19/03/93 to get the right disc space
//  DoNeedDiskSpace(neededBlocks);

  fileInfo.msg = NULL;
  fileInfo.selection = NULL;
  fileInfo.filename = fTitle;
  fileInfo.filetype = fFileType;
  fileInfo.fileIsSafe = TRUE;
  fileInfo.print = FALSE;
  Saver(&fileInfo, -1);   // 14/07/96 get saver to calculate: neededBlocks);
  return gNoChanges;
}

// ------------------------------------------------------------------------
TCommand _TDocument::DoMenuCommand(EventInfo &eventInfo, CmdNumber aCmdNumber)
{
   if (aCmdNumber >= cPrFileBase && aCmdNumber <= cPrFileMax)
   {
      return (fDocPrintHandler != NULL ?
         fDocPrintHandler->DoMenuCommand(eventInfo ,aCmdNumber) : gNoChanges);
   }
#if DEMO == 0
   // 05/05/94 [21721] Save changed documents on shutdown
   if ((aCmdNumber == cSaveFileShutdown && fChangeCount > 0) ||
            (aCmdNumber == cSaveFileImmediately && (aCmdNumber = cSave, TRUE)))
                  // 06/04/93 [20825] do not ignore untitled doc saves
   {
      if (fSaveExists)
        return SaveImmediately();
   }
#endif
   if (IsFileCommand(aCmdNumber))
   {
      if (eventInfo.menuClickedOn)
        eventInfo.event->e = wr_wimp_ENULL;  // stop event clobbering next dbox poll
      gSaveDocCommand->fChangedDocument = this;
      gSaveDocCommand->fCmdNumber = aCmdNumber;
      return(gSaveDocCommand);
   }
   if (aCmdNumber == cRevert)
   {
      TRevertDocCommand aRevertDocCommand;

      aRevertDocCommand = new _TRevertDocCommand(aCmdNumber, this);
      return(aRevertDocCommand);
   }
#ifdef DRAGDROP
   if (aCmdNumber == cUndoDescription || aCmdNumber == cUndo)
   {
      gAppnCommands[kUndoRedoCommand]->fChangedDocument = this;
      return gAppnCommands[kUndoRedoCommand];
   }
#endif
   eventInfo.document = this;  // 23/03/94 so unrecognised commands know target doc
   return(_THandler::DoMenuCommand(eventInfo, aCmdNumber));
}


// ------------------------------------------------------------------------
void _TDocument::DoSetupMenus()
{
   int i;
#ifdef DRAGDROP
   int newMenuState;
   MenuHandle *theMenu;
   char undoText[32];
#endif

   _THandler::DoSetupMenus();
   for (i = cSave; i <= cSaveLast; i++)
      EnableCmd(i);

   Enable(cRevert, fChangeCount != 0 && !fCannotRevert);
#if SIDEBAR == 1
   SetIndCmdName(cRevert, fSaveExists + bzRevert);    // 04/10/94 [23003]
#endif

#ifdef DRAGDROP
   // 11/01/94 SetUndoText in-line
   theMenu = GetResMenu(cmUndo);
   DelMenuItems(theMenu, 1);    // delete the old name

   if (fLastCommand != NULL && fLastCommand->fCanUndo)
   {
      // 11/01/94 EnableCmd(cUndoDescription);
      EnableCmd(cUndo);
      CmdToName(fLastCommand->fCmdNumber, undoText);
      AppendMenuItem(theMenu, undoText);
      newMenuState = (fLastCommand->fCmdDone ? bzUndo : bzRedo);
   }
   else
   {
      // we cannot undo the item so grey out the leaf name
      DisableCmd(cUndo);
      DisableCmd(cUndoDescription);    // for NETWP, so button dimmed
      newMenuState = bzCantUndo;
   }
   SetIndCmdName(cUndo, newMenuState);     // undo/redo/cant undo
#endif

   if (fDocPrintHandler != NULL && gSetUpWindow != NULL)
        // 22/03/96 == TRUE:   && !gSetUpWindow->fTarget->HandlesPrintingCommands())
      fDocPrintHandler->DoSetupMenus();
}


// ------------------------------------------------------------------------
void _TDocument::GetLeafName(char *leafname)
{
   char *p;
   char *q = leafname;

   for (p = fTitle + 1 - fSaveExists; (*(q++) = *p) != 0; p++)
      if (*p == '.')
        q = leafname;

   if (!fSaveExists)
      *(q - 2) = 0;
#ifdef NETWP
   else
     for (p = q - 5; q > p && q > leafname; )
       if (*(--q) == '/')      // DOS suffix deliminator
       {
         *q = 0;
         break;
       }
#endif
}


#ifdef TRACE
// ------------------------------------------------------------------------
void _TDocument::DoMakeWindows()
{
}

// ------------------------------------------------------------------------
void _TDocument::DoInitialState()
{
}


// ------------------------------------------------------------------------
void _TDocument::DoRead(int aRefNum, TWhyMaking forPrinting)
{
}


// ------------------------------------------------------------------------
void _TDocument::DoWrite(int aRefNum, TSaveInfo *saveInfo)
{
}


// ------------------------------------------------------------------------
// 22/06/92 declare fonts used to print driver
void _TDocument::DeclarePrinterFonts()
{
}

// ------------------------------------------------------------------------
void _TDocument::Save(CmdNumber itsCmdNumber)
{
  // 16/03/93 now virtual & moved to UExpressn
}

#ifdef DRAGDROP
// ------------------------------------------------------------------------
void _TDocument::SaveData(wr_wimp_msgstr *msg, CmdNumber cmd)
{
  // 18/03/93 new virtual for responding to drops
}
#endif

// ------------------------------------------------------------------------
void _TDocument::DoNeedDiskSpace(long &dataForkBytes)
{
  // always overridden
}

// *************************************************************************
bool _TDocument::CanPaste(int fileType)
{
  return FALSE;
}

// *************************************************************************
// MMerge methods 13/5/92
void _TDocument::StartPrinting()
{
}

// *************************************************************************
void _TDocument::GetFieldValue(int fieldNumber, char *value)
{
}

// *************************************************************************
int _TDocument::GetFieldNumber(char *name)
{
  return 0;
}

// *************************************************************************
bool _TDocument::HasMergeFile()
{
  return FALSE;
}
// End of MMerge methods

// *************************************************************************
void _TDocument::PipePicture()
{
}

// ------------------------------------------------------------------------
bool _TDocument::ShowAWindow(TWindow aWindow)
{
//   You will have to open the window yourself. fOpenInitially has been
//   hijacked by NewTemplateWindow.
//   if (aWindow->fOpenInitially)
//      aWindow->Open();
   return(FALSE);
}
#endif

// ------------------------------------------------------------------------
void _TDocument::ReadFromRamFile(AppFile &anAppFile, TWhyMaking forPrinting)
{
  fCannotRevert = TRUE;
  fChangeCount = 1;
}


// ------------------------------------------------------------------------
bool _TDocument::KeepOpen()
{
   TFileInfo fileInfo;
   char *rm = GetRsrcOption('r');

   GetFileInfo(fTitle, fileInfo);
   fileInfo.FileModDate(fModDate);
   return fileInfo.GetFileSize() >= (rm ? atoi(rm) : 20) * 1024;
               // 26/04/94 [21709] gSaveInRAMMax * 1024;
               // 19/09/94 [22025] default changed from 0 to 20K
}

// ------------------------------------------------------------------------
void _TDocument::ReadFromFile(AppFile &anAppFile, TWhyMaking forPrinting)
{
   int dataRefnum;
   bool isRevert = (anAppFile.fName == NULL);
   char *det = GetRsrcMisc(5);  // 25/06/91
   bool doDetach;
   bool safeFile;

   fSaveExists = TRUE;  // 24/06/96 moved up: fTitle is, or will be set in either branch
                        // and needs to be set correctly for the file leaf to be found
   if (isRevert)
     doDetach = !fDataOpen;
   else
   {
     doDetach = (anAppFile.fType != gMainFileType ||
         forPrinting == kForMerge ? TRUE : wr_akbd_pollctl() ^ (det != NULL && det[0] != '~'));
                // 25/06/91, 17/02/92 cancel the effect when opening a stationery pad
                // 14/05/92 ... or for a MailMerge file
      SetTitle(anAppFile.fName);

      // 20/05/92 moved up as load failures reset to current date
      if (!KeepOpen())
        doDetach = TRUE;
   }
   anAppFile.fName = fTitle;    // 27/3/90, do in both cases; appFile.fName
                                // points to the eventInfo, so corrupted by
                                // any alerts, etc. during DoRead.
   dataRefnum = kNoFileRefnum;

   safeFile = anAppFile.fFileIsSafe;
   if (!safeFile)                 // scrapFile)
      doDetach = TRUE;

   if (isRevert)          // added 24/3/90, because Revert failed
   {
      dataRefnum = fDataRefnum;
      SetFPos(dataRefnum, 0);
   }
   else
      // 18/02/93 [20704] RWX access for protected disc check
      FailOSErr(MAOpenFile(anAppFile.fName, dataRefnum,
                              doDetach ? kAccessRead : kAccessReadWriteX));
   // fSaveExists = TRUE;
   fChangeCount = 0;    // moved 02/04/90 as DoRead may update fChangeCount
   fDataRefnum = dataRefnum;  // 01/05/91 moved from TDDoc
   fDataOpen = TRUE;    // 03/03/93 [20804] moved up: Failure in DoRead loses file timestamp
   DoRead(dataRefnum, forPrinting);
   GetRevertSize();     // 12/09/94 read size of the file before it is possibly closed

   if (doDetach)
   {
      DetachFromFile();
      // 21/10/92 save selection via scrap not marked     if (!doDetach)
      if (!safeFile)
        fChangeCount = 1;
   }
   // 03/03/93 [20804]  else // if (!isRevert)
   // 03/03/93 [20804] moved up in case of failure in DoRead:     fDataOpen = TRUE;

   if (fDataOpen)
      dataRefnum = kNoFileRefnum;
   else
      fDataRefnum = kNoFileRefnum;

   wr_wimpt_noerr(CloseFile(dataRefnum));

   if ((anAppFile.fType != gMainFileType // was if (fStationery) ... but this caters for all files
#ifdef NETWP
            && anAppFile.fType != kMSWord && anAppFile.fType != kTextFile
#endif
        ) || !safeFile)
   
   {
      fSaveExists = FALSE;
      if (!isRevert)
      {
         if (anAppFile.fType == kStationeryPad && safeFile)     // !scrapFile)
         {
            // copy the doc title to stationery
            DisposIfHandle(fStationeryName);
            fStationery = TRUE;
            fStationeryName = fTitle;
            fTitle = NULL;
            anAppFile.fName = NULL;
         }
         else
           fCannotRevert = TRUE;     // 03/02/92 stop revert unles TW or pad file

         if (forPrinting != kForPrinting) // 19/01/94 [21332] stop overwriting fPrinterScrap
         {
            UntitledName();
         }
      }
   }
}


// ------------------------------------------------------------------------
void _TDocument::UntitledName()
{
   char noName[40];

   sprintf(noName, GetRsrcMisc(15), ++gNumUntitled);
   SetTitle(noName);
}


/* ------------------------------------------------------------------------
void _TDocument::ShowWindows()
{
   fWindowList->LastThat(this, (TestObject)_TDocument::ShowAWindow);
}
*/

// ------------------------------------------------------------------------
void _TDocument::InstallTitle(TWindow aWindow, int percentage)
{
   aWindow->SetTitleForDoc(fTitle, percentage, fChangeCount);
}


// ------------------------------------------------------------------------
void _TDocument::SetTitle(char *aTitle)
{
   char nameBuffer[512];

   // move after possible failure: DisposIfHandle(fTitle);
   if (strcmp("<Printer$Scrap>", aTitle) == 0)
   {
      int countName = 511;

      FailOSErr(ReadExpression(nameBuffer, "<Printer$Scrap>", &countName));
      nameBuffer[countName] = 0;
      aTitle = nameBuffer;
      fPrinterScrap = TRUE;
   }
   else if (fPrinterScrap == TRUE)   // 03/10/94 [23000] safety - probably redundant, but
                                     // avoid leaving it set at 1 so will not delete file
      fPrinterScrap = FALSE;

   DisposIfHandle(fTitle);
   FailNIL(fTitle = NewString(aTitle));

   InstallTitleInWindows();
#ifdef NETWP
   GetLeafName(nameBuffer);
   SetNickName(nameBuffer);
#else
   fNickName = fTitle;
#endif
}


// ------------------------------------------------------------------------
void _TDocument::UpdateChangeCount(int deltaCount)
{
   fChangeCount += deltaCount;
   if (fChangeCount < 2)
      InstallTitleInWindows();
}


// ------------------------------------------------------------------------
void _TDocument::DoInstallTitle(TWindow aWindow)
{
   InstallTitle(aWindow, 0);
}


// ------------------------------------------------------------------------
void _TDocument::InstallTitleInWindows()
{
   fWindowList->Each(this, (DoToObject)_TDocument::DoInstallTitle);
}


// ------------------------------------------------------------------------
bool _TDocument::CanClose()   // returns TRUE if doc can be freed
{
   if (fChangeCount != 0)
   {
      int reply;
#ifdef NETWP
      //char leaf[60];

      //GetLeafName(leaf);
      char *leaf = GetNickName();
#else
      char *leaf = fTitle;
#endif

      reply = Alert(phSaveChanges, -2, leaf);

      // 18/02/93 [20705] May update file date stamp when changes discarded,
      // save to another file or app quit via the Task Mgr
      if (reply == kCancelDlog)
        return FALSE;
      if (reply == kYesButton)
      {
#ifdef NETWP
      if (fSaveExists)
         Save(cSaveWord);
      else
#endif
         Save(cSave);
         if (fChangeCount != 0)     // 27/05/93 [20898] only refuse if save failed
           return FALSE;
      }
      // 24/02/93 fChangeCount is, or should be set to, zero after CanClose returns TRUE
      //    fChangeCount = 0;   // 18/02/93 [20705] if not Cancel, so FreeFile will restore stamp
      // 22/02/93 do it after Save which can fail & user may save to temp
   }
   return TRUE;
}


// ------------------------------------------------------------------------
void _TDocument::CommitLastDocCommand()
{
#ifdef DRAGDROP
   if (fLastCommand != NULL)
   {
      if (fLastCommand->fChangesClipboard)
         gApplication->CommitLastCommand();  // now only commits clipboard
        
      if (fLastCommand->fCmdDone)
         fLastCommand->Commit();
      fLastCommand->Free();
      fLastCommand = NULL;
   }
#else
   if (gLastCommand != NULL && gLastCommand->fChangedDocument == this)
      gApplication->CommitLastCommand();
#endif
}


// ------------------------------------------------------------------------
void _TDocument::CloseAWindow(TWindow aWindow)
{
   aWindow->Close();
}


// ------------------------------------------------------------------------
void _TDocument::Close(bool queryTheClose)
{
   if (queryTheClose)
   {
     if (!CanClose())
       FailNoFail();
   }
   // 24/02/93 set fChangeCount = 0 here if CanClose returns TRUE:   else
   // 18/02/93 [20705] get FreeFile to update file date stamp when app quit via the Task Mgr
   fChangeCount = 0;
 
   CommitLastDocCommand();
   fWindowList->Each(this, (DoToObject)_TDocument::CloseAWindow);
   Free();
}


// ------------------------------------------------------------------------
int _TDocument::Saver(TSaveInfo *saveInfo, long neededBlocks)
{
#if DEMO == 1
   Alert(phNoDemoSave, wr_wimp_EOK);
   return TRUE;
#else
   char *filename = saveInfo->filename;
   FailInfo fi;
   Str255 tempName;  // should use a heap block?
   char *directory = NULL;
   char **dirPtr = &directory;
   int oldDataRef = fDataRefnum;
   bool safeToDelete = saveInfo->fileIsSafe && (
#ifdef NETWP
                 saveInfo->filetype == kMSWord ||    // but not text files
#endif
                 saveInfo->filetype == gMainFileType);
                         // 09/07/93 [20972] moved up to stop SaveViaTemp on non-EW files
   TFileInfo fileInfo;

   CommitLastDocCommand();       // 18/02/91
   CatchFailures(&fi);

   // in-line:  RequestFileName(filename);

   // open the file to save to in order to make sure it is not
   // already open by another application (or ourselves)

   GetFileInfo(filename, fileInfo);
   if (fileInfo.TypeOfFile() != fileNotFound)
   {
      int file_handle;

      fileInfo.CheckType();   // fail if a directory
      if (fileInfo.fInfo.end & 8)
        FailGeneral(31);
#ifdef NEVER
      // 08/03/95 [24002] failed even when a protected file is unprotected
      // what good is it testing the 'source' doc refnum to see if it has write access??
      if (fDataRefnum != kNoFileRefnum)
      {
         wr_os_regset r;

         r.r[0] = 254;             // write open file seq file ptr
         r.r[1] = fDataRefnum;
         FailOSErr(wr_os_args(&r));
         if ((r.r[0] & 0xc0) == 0x40)  // 25/06/91 read only
           FailGeneral(31);
      }
#endif
      // openfile fails if we already have it open
      if (MAOpenFile(filename, file_handle, kAccessReadWrite) == NULL &&
          /* 25/06/91 if locked we can get another curr */
                                               file_handle != fDataRefnum)
      {
         int reply = (strrchr(filename, '.') != NULL && // 10/02/94 no alert for $Scrap files
               (fDataOpen || strcmp(filename, fStationery ? fStationeryName : fTitle)) ?
                   Alert(phShouldOverwrite, -1,
#ifdef NETWP
                                            fNickName
#else
                                            filename
#endif
                                               ) : kYesButton);
              // 15/07/92 do not ask if RAM - 05/02/93 [20613] ... if same name

         wr_wimpt_noerr(CloseFile(file_handle));
         if (reply != kYesButton)
           FailNoFail();
      }
   }
   // end in-line:  RequestFileName(filename);

   // should we go through all this if there is no file called "filename"?

   if (safeToDelete)   // 06/04/93 [20826] may lose original on ram file save: && fDataOpen)
     directory = strrchr(filename, '.');
   if (directory != NULL)
   {
      char *aName = tmpnam(NULL);
      char *uniqueName = strrchr(aName, '.');
      // wr_os_regset r;
      int x = 0, y;

      wr_os_byte(161, &x, &y);       // 12/09/94 read station number

      uniqueName = (uniqueName == NULL ? aName : uniqueName + 1);
      directory[0] = 0;  // terminate filename at final '.'

      // 02/03/94 [21431] use the station id to make name unique for a network
      // if (wr_os_swix(0x40040 /* NetFS_ReadFSNumber */, &r) != NULL)
      //   r.r[0] = r.r[1] = 0;
      sprintf(tempName, "%s.%c%02x%.5s",
                        filename,              // directory.
                        'x',                   // - (r.r[1] & 15),   // x - net number
                        /* r.r[0] & 255 */ y,  // xx two hex digits station
                        uniqueName + 3);       // rest of uniqueName
                        // [20897] shorten name to 8 for IBM discs
      // sprintf(tempName, "%s.%.8s", filename, uniqueName);
      directory[0] = '.';
   } else
      strcpy255(tempName, filename);

#ifdef NETWP
   fWindowList->Each(this, (DoToObject)DisplayHelpText, GetString(94));  // Saving ... message
#endif
   if (neededBlocks < 0)
     DoNeedDiskSpace(neededBlocks);    // wrong for non-EW file types??
   // create a file of size (neededBlocks) to see if there is room for 2 copies
   FailOSErr(Create(tempName, saveInfo->filetype, neededBlocks));
               // creates a file of size x (does not OPEN it!)
               // 02/04/91 FailOSErr to prevent save stationery, etc. saving over open file

   // we managed to create a file of required size
   gRAMFile.eof = neededBlocks;    // 12/09/94 [22023]
   if (safeToDelete)
   {
      MakeNewCopy(tempName, saveInfo);
      SaveViaTemp(tempName, directory == NULL ? NULL : filename);   // room for 2 copies
   }
   else
      MakeNewCopy(filename, saveInfo); // 16/08/90 just write to it - (it is a scrap file)

   Success(&fi);
   if (safeToDelete) // 09/07/93 [20972] moved up: && saveInfo->filetype == gMainFileType)
   {
      // 16/06/93 [20944] Do not do SavedOn for non EW files (now allow Word files too)
      fSaveExists = TRUE;
      if (strcmp(fTitle, filename) != 0)
      {
         SetTitle(filename);
         RenameDocument();    // 05/02/93 [20612] get icon bar menu updated
      }
      UpdateChangeCount(-fChangeCount); // equiv to: fChangeCount = 0;
#ifdef NETWP
      if (saveInfo->filetype == gMainFileType)    // always TRUE for non-NETWP
#endif
        SavedOn(filename);
      fStationery = FALSE;
      fFileType = saveInfo->filetype;  // the file type actually saved (for a Revert)
   }
   return TRUE;

// ++++++++++ Exception handler ++++++++++++++++++++++
Rescue:
   if (oldDataRef != kNoFileRefnum && fDataRefnum == kNoFileRefnum)
      OpenAFile(filename, fDataRefnum);  // 25/06/91 restore
   if (*dirPtr != NULL)
      DeleteFile(tempName);  // delete the garbage name file
#ifdef NETWP
   if (saveInfo->filetype == kMSWord && fi.error != 0)
     return 2;     // want message suppressed, and caller to try saving in native format
#endif
   if (fi.message == 0)
      fi.message = msgSaveFailed;
   return DoRescue(fi);                // 03/08/92
#endif
}


// ------------------------------------------------------------------------
void _TDocument::DetachRecord(TRecordIndex aRecord, TRecordHandler handler)
{
   TDiscRecord theRecordInfo = (PDiscRecords(handler->fRecordList))[aRecord];

   if (!theRecordInfo.info.isInStore)
      handler->GetRecordObject(aRecord, kReadOnly);
}


// ------------------------------------------------------------------------
void _TDocument::DetachHandler(TRecordHandler aHandler)
{                   
   aHandler->ForAllRecordsDo(this, (DoToRecord)_TDocument::DetachRecord);
}


// ------------------------------------------------------------------------
void _TDocument::DetachFromFile()
{
   fDataOpen = FALSE;
   fRecordHandlers->Each(this, (DoToObject)_TDocument::DetachHandler);
}



// ------------------------------------------------------------------------
void _TDocument::RevertView(TView aView)
{
   aView->ShowReverted();
}


// ------------------------------------------------------------------------
void _TDocument::ShowReverted()
{
   fViewList->Each(this, (DoToObject)_TDocument::RevertView);
}


// ------------------------------------------------------------------------
void _TDocument::Revert()
{
   FailInfo fi;
   bool reread = fSaveExists | fStationery;   // 17/03/91 rvt to stationery

   CatchFailures(&fi);

   // 17/03/91 fail if the file cannot be opened - needs to be done before FreeData
   if (reread && !fDataOpen)
   {
      // a RAM copy, so need to (try to) reopen the file, read only as will detach later
      int dataRefnum;
      TFileInfo fileInfo;
      char stamp[6];
      char *filename;

      // avoid timestamp test if pad so can revert after Save Stationery to original pad
      if (fStationery)
         filename = fStationeryName;
      else
      {
         // 05/02/93 [20611] fail if timestamp changed
         filename = fTitle;
         GetFileInfo(filename, fileInfo);
         fileInfo.FileModDate(stamp);
         if (memcmp(stamp, fModDate, 5))
            FailGeneral(37);
      }

      OpenFile(filename, dataRefnum, kAccessRead);
                                  // fStationery ? kAccessRead : kAccessReadWrite);
      fDataRefnum = dataRefnum;   // set up currency for ReadFromFile
   }

   CommitLastDocCommand();

   FreeData();
   if (reread)
   {
      AppFile anAppFile;

      anAppFile.fName = NULL;
      anAppFile.fFileIsSafe = TRUE;
      anAppFile.fType = fFileType;
      anAppFile.fEstSize = -1;                 // 18/02/91
      ReadFromFile(anAppFile, kForDisplay);
   }
   else
   {
      DoInitialState();
   }
   UpdateChangeCount(-fChangeCount);      // to clear * from window
                                          // 1/8/90 moved from above
   Success(&fi);
   return;

// +++++++++++++ exception handler ++++++++++++++++++++++
Rescue:
   if (fi.message == 0)
      gErrorParm3 = GetNickName();
   FailNewMessage(&fi, msgRevertFailed);
   // 07/06/91 done in FNM   ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TDocument::FreeFile()
{
   if (fFileSizeChanged == eofChanged)
      SetFileSize(fRevertSize);

   wr_wimpt_noerr(CloseFile(fDataRefnum));
            // 01/05/91 so catch failures can be removed from ReadFromFile
   fDataRefnum = kNoFileRefnum;   // 25/06/91
   if (fDataOpen)
   {
      if (fChangeCount == 0 && fSaveExists)
         SetFileStamp(fTitle, fModDate, 0);
   }
   // 19/06/91 do not leave files around after scrap print
   if (fPrinterScrap == TRUE)     // 03/01/94 [23000]
     DeleteFile(fTitle);
}


// ------------------------------------------------------------------------
static void FreeHandlerData(TObject self, TRecordHandler aHandler)
{
  aHandler->Reverting();
}

// -------------------------------------------------------------------------
void _TDocument::FreeData()
{
   fRecordHandlers->Each(this, (DoToObject)FreeHandlerData);
}


#ifdef PRO
// 09/12/93 to set and reset destination print driver
// -------------------------------------------------------------------------
void _TDocument::SendPostscript(char *filename)
{
   wr_os_regset r;
   FailInfo fi;

   r.r[0] = 0;
   FailOSErr(wr_os_swix(PDriver_SelectDriver, &r));  // select Postscript

   CatchFailures(&fi);

   SetLastPrintChange();
   fDocPrintHandler->CheckPrinter(TRUE);     // 19/04/94 for save as postscript
   fDocPrintHandler->Print(filename);

   Success(&fi);

Rescue:
   wr_os_swix(PDriver_SelectDriver, &r);  // select original
   SetLastPrintChange();
   fDocPrintHandler->CheckPrinter(FALSE);   // 24/05/94
   ContinueIfFail(&fi);
}
#endif

// ------------------------------------------------------------------------
void _TDocument::MakeNewCopy(char *filename, TSaveInfo *saveInfo)
{
   volatile int dataRefnum;
   FailInfo fi;

   dataRefnum = kNoFileRefnum;

   // do we need the following? the existing file type may be wrong though
   FailOSErr(Create(filename, saveInfo->filetype));
   CatchFailures(&fi);                                

   BeginProgress();                             // 30/05/91
   if (saveInfo->print)   // 04/12/93 allow for background printing
   {
     if (fDocPrintHandler != NULL)
     {
#ifdef PRO
       if (saveInfo->print == 2)
         SendPostscript(filename);
       else
#endif
#ifdef TRACE
       if (saveInfo->print == 3)   // Draft printing
       {
         OpenAFile(filename, dataRefnum);
         DoWrite(dataRefnum, saveInfo);
       }
       else
#endif
       fDocPrintHandler->Print(filename);
     }
   }
   else
   {
     OpenAFile(filename, dataRefnum);
     if (!fDataOpen && saveInfo->filetype == gMainFileType &&  // 08/05/96 only for main type
                       (gRAMFile.contents = (char *)NewHandle(gRAMFile.eof)) != NULL)
     {
       gRAMFile.fileHandle = dataRefnum;
       gRAMFile.eof = gRAMFile.filePos = 0;
     }
     DoWrite(dataRefnum, saveInfo);
     gRAMFile.fileHandle = 0;
     if (gRAMFile.contents != NULL)
       FWrite(dataRefnum, gRAMFile.eof, gRAMFile.contents);
   }
   Success(&fi);

// +++++++++++++ exception handler ++++++++++++++++++++++
Rescue:
   gRAMFile.fileHandle = 0;
   ClearHandle(&gRAMFile.contents);
   HideProgress();
   wr_wimpt_noerr(CloseFile(dataRefnum));
   if (fi.error != 0)
   {
     DeleteFile(filename);
     ContinueFailure(&fi);
   }
}


// ------------------------------------------------------------------------
void _TDocument::SwitchHandler(TRecordHandler aHandler)
{                   
   aHandler->SwitchFiles();
}

// ------------------------------------------------------------------------
void _TDocument::SavedOn(char *filename)
{
   // title reset & update change count moved to before the call (for Save as Word)
   if (KeepOpen() || fDataOpen)
   {
     int dataRefnum;

     OpenAFile(filename, dataRefnum);
     fDataRefnum = dataRefnum;            // safer to wait to ensure no fail before updating?
     fCannotRevert = FALSE;               // 17/03/91 Can now revert

     // moved to after call: fStationery = FALSE;
     // moved to after call: fFileType = gMainFileType;

     fRecordHandlers->Each(this, (DoToObject)_TDocument::SwitchHandler);
     fRevertSize = ReadFileSize();
     fFileSizeChanged = eofKnown;
     SetHandleEmpty(&fFreeExtents);

     fDataOpen = TRUE;
   }
}

// ------------------------------------------------------------------------
// 22/02/94 [21414] Avoid deleting the original file when saving one that may be damaged
static wr_os_error *CantBackup(char *filename)
{
  char bakName[512];
  int nameLen = strlen(filename);
  char *lastDot;

  strcpy(bakName, filename);
  lastDot = strrchr(bakName, '.');
  if (bakName + nameLen >= lastDot + 11)
    nameLen--;
  strcpy(bakName + nameLen, "!");
  if (strcmp(filename, bakName) == 0)
    return (wr_os_error *)1;  // this rename works if names the same, but next Rename will fail
  return Rename(filename, bakName);
}

// ------------------------------------------------------------------------
void _TDocument::SaveViaTemp(char *tempName, char *filename)
{
   if (filename != NULL)
     fChangeCount = 0;  // 22/02/93 [20705] so save to different file original not stamped
   FreeFile();

   if (filename != NULL)
   {
      wr_os_filestr f;

      f.action = 17;
      f.name = filename;
      FailOSErr(wr_os_file(&f));
      if (!fDamaged || CantBackup(filename))
        FailOSErr(DeleteFile(filename));
      FailOSErr(Rename(tempName, filename));
      if (f.action == 1)    // 25/06/91 original exists so set access back
      {
        f.end &= 0x3b;
        f.action = 4;
        FailOSErr(wr_os_file(&f));
      }
   }
} 


// ------------------------------------------------------------------------
void _TDocument::RemoveRecordHandler(TRecordHandler aHandler)
{
   if (fRecordHandlers->GetSameItemNo(aHandler) != 0)
      aHandler->Free();
}


// ------------------------------------------------------------------------
void _TDocument::DeInstallRecordHandler(TRecordHandler aHandler)
{
   fRecordHandlers->Delete(aHandler);
}


// ------------------------------------------------------------------------
void _TDocument::ReadRecord(Handle data, long filePos, long nChars)
{
   if (fDataRefnum == kNoFileRefnum)  // ie file handle == 0
      FailNoFail();

   SetFPos(fDataRefnum, filePos);
   FRead(fDataRefnum, nChars, data);
}


// ------------------------------------------------------------------------
void _TDocument::InstallRecordHandler(TRecordHandler aHandler)
{
   fRecordHandlers->InsertLast(aHandler);
}


// ------------------------------------------------------------------------
void _TDocument::AddToFreeExtents(long discAddress, long discLength)
{
   const slotSize = sizeof(TFreeExtentsRecord);

   long i;
   long limit;
   long fileSize;
   int  matches;
   TFreeExtentsRecord newEntry;

   if (discAddress >= GetRevertSize())
   {
      matches = 0;
      i = 0;
      limit = GetHandleSize(fFreeExtents) / slotSize;
      do {
         i++;
      } while ((i <= limit) &&     // 23/10/90 condition changed round
          ((PFreeExtents(fFreeExtents) + i - 1)->startAddress <= discAddress));
     
      if (i > 1)
      {
         register PFreeExtents ref = PFreeExtents(fFreeExtents)+(i-2);

         if ((ref->startAddress + ref->slotLength) == discAddress)
         {
            matches = 1;
            ref->slotLength += discLength;
         }
      }
      if (i <= limit)
      {
         register PFreeExtents ref = PFreeExtents(fFreeExtents) + i - 1;

         if ((discAddress + discLength) == ref->startAddress)
         {
            matches++;
            if (matches == 1)
            {
               ref->startAddress -= discLength;
               ref->slotLength += discLength;
            }
            else
            {
               (PFreeExtents(fFreeExtents)+(i-2))->slotLength +=
                                                           ref->slotLength;
            }
         }
      }
      else
      {
         fileSize = ReadFileSize();
         if ((discAddress + discLength) == fileSize)
         {
            if (matches == 0)
               fileSize -= discLength;
            else
            {
               fileSize -= (PFreeExtents(fFreeExtents) + (i - 2))->slotLength;
               i--;
            }
            SetFileSize(fileSize);
            matches++;
         }
      }
      if (matches == 0)
      {
         newEntry.startAddress = discAddress;
         newEntry.slotLength = discLength;
         InsertIntoHandle(&fFreeExtents, (i - 1) * slotSize, &newEntry, slotSize);
      }
      else if (matches == 2)
         DeleteFromHandle(&fFreeExtents, (i - 1) * slotSize, slotSize);
   }
}


// ------------------------------------------------------------------------
void _TDocument::SetFileSize(long newSize)
{
   if (fDataRefnum != kNoFileRefnum)
   {
      GetRevertSize();
      // if (fFileSizeChanged == eofUnknown)
      //    fRevertSize = ReadFileSize();
      SetEOF(fDataRefnum, newSize);
      if (newSize == fRevertSize)
         fFileSizeChanged = eofKnown;
      else
         fFileSizeChanged = eofChanged;
   }
}


// ------------------------------------------------------------------------
long _TDocument::ReadFileSize()
{
   long fileSize = 0;

   if (fDataRefnum != kNoFileRefnum)
      GetEOF(fDataRefnum, fileSize);
   return(fileSize);
}


// ------------------------------------------------------------------------
long _TDocument::GetRevertSize()
{
   if (fFileSizeChanged == eofUnknown)
   {
      fRevertSize = ReadFileSize();
      fFileSizeChanged = eofKnown;
   }
   return(fRevertSize);
}


// ------------------------------------------------------------------------
void _TDocument::OpenAgain() // 03/02/93 CmdNumber itsCmdNumber, TDocument openingDoc)
{
   TWindow window = TWindow(fWindowList->First());

   window->Select();
   FailNoFail();
}


// ------------------------------------------------------------------------
const int slotSize = sizeof(TFreeExtentsRecord);

unsigned int _TDocument::FindFreeSlot(unsigned int discLengthRequired)
{
  int i;
  int limit;
  int workVar;
  int targetSlot = 0; // 26/04/90 for safety
  int smallestGap;
  unsigned int FindFreeSlot_r;

  i = 0;
  smallestGap = -1;
  limit = GetHandleSize(fFreeExtents) / slotSize;
  if (limit > 0)
    do
    {
      workVar = PFreeExtents(fFreeExtents)[i].slotLength - discLengthRequired;
                       // 23/10/90 freeExtents numbered from 0
      if (workVar >= 0)
      {
        if ((smallestGap < 0) || (workVar < smallestGap))
        {
          smallestGap = workVar;
          targetSlot = i;
        }
      }
      i++;
    } while ((i != limit) && (smallestGap != 0));

  if (smallestGap < 0)
  {
    FindFreeSlot_r = ReadFileSize();
    SetFileSize(FindFreeSlot_r + discLengthRequired);
  }
  else
  {
    FindFreeSlot_r = PFreeExtents(fFreeExtents)[targetSlot].startAddress;
    if (smallestGap == 0)
      DeleteFromHandle(&fFreeExtents, targetSlot * slotSize, slotSize);
    else
    {
      PFreeExtents(fFreeExtents)[targetSlot].startAddress += discLengthRequired;
      PFreeExtents(fFreeExtents)[targetSlot].slotLength = smallestGap;
    }
  }

  return(FindFreeSlot_r);
}

#ifdef TRACE
// *************************************************************************
TCommand _TDocument::DoPaste(AppFile *file, int estSize,
                                        TPasteCommandType type, TObject pasteSelection)
{
  return gNoChanges;
}
#endif

// *************************************************************************
TDocument _TDocument::RequestClipDocument()
{
#ifdef DRAGDROP
  // return NULL if no clip doc, or needs to wait
  if (gClipView == NULL)
  {
    wr_wimp_msgstr msg;

    msg.data.datasave.w = TWindow(fWindowList->First())->fWindowRecord.GetHandle();
    BroadcastPasteRequest(msg);
    return NULL;
  }
#endif
  return gClipView->fDocument;
}


// *************************************************************************
// 13/12/93 new method
THPrint _TDocument::GetPrintRec()
{
  if (fDocPrintHandler != NULL)
    return fDocPrintHandler->GetPrintRec();
  return NULL;
}

// *************************************************************************
// 04/12/93 new virtual method which can be overridden by mailmerge loop
bool _TDocument::Print(char *filename)
{
   TPrintHandler aPrintHandler = fDocPrintHandler;

   if (aPrintHandler != NULL)
   {
      TSaveInfo fileInfo;

      aPrintHandler->CheckPrinter(FALSE);   // called when file dropped on printer
      if (filename == NULL || (fileInfo.filetype = aPrintHandler->GetPrintFileType()) == 0)
        return aPrintHandler->Print(NULL);

      fileInfo.msg = NULL;
      fileInfo.filename = filename;
      fileInfo.fileIsSafe = FALSE;
      fileInfo.print = TRUE;
      Saver(&fileInfo, 0);
   }
   return TRUE;
}

#ifdef NETWP
// *************************************************************************
void _TDocument::SetNickName(char *nickname)
{
  if (fNickName != fTitle)
    DisposIfHandle(fNickName);

  FailNIL(fNickName = StringHandle(NewString(nickname)));

  for (char *p = (char *)fNickName; *p != 0; p++)
    if (*p == ' ')
      *p = 160;    // replace spaces by hard spaces 
}
#endif

// *************************************************************************
static void CheckDamage(TRecordHandler handler, TRecordIndex aRecord, TRecordHandler same,
                  bool *realMaths, int version)
{
  if (version == 8)
  {
    // can tell if real maths by fSize (1st 2 bytes) == 0
    TDiscRecord theRecordInfo = (PDiscRecords(handler->fRecordList))[aRecord];
    char buffer[4];

    handler->fDocument->ReadRecord(buffer, theRecordInfo.info.discAddress, 2);
    if (buffer[0] == 0 && buffer[1] == 0)
      *realMaths = TRUE;
    else
    {
      handler->fDocument->
        AddToFreeExtents(theRecordInfo.info.discAddress, theRecordInfo.data.discLength);
      theRecordInfo.wInfo = inStoreMask | handler->fFreeRecordIdx;
      theRecordInfo.data.theData = NULL;
      PDiscRecords(handler->fRecordList)[aRecord] = theRecordInfo;
      handler->fFreeRecordIdx = aRecord;
    }
  }
  else
    *realMaths = TRUE;
}


// ------------------------------------------------------------------------
bool Repair(TRecordHandler handler, int version)
// 04/08/92 delete duff (table) records in the maths record hdlr from docs converted from v5
{
  bool realMaths = FALSE;    // set TRUE if there are any real records

  handler->ForAllRecordsDo(handler, (DoToRecord)CheckDamage, &realMaths, version);
  return realMaths;
}
