/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include "UTablEdit.h"
#include "UTextComm.h"
#include <stdlib.h>

typedef struct TSpanInfo *PSpanInfo;

typedef struct TSpanInfo
{
  int spanStart;
  int spanDistribute;
  int spanEnd;
  Fixed slopStart;
  Fixed spanWidth;
} TSpanInfo;

// --------- global variables ----------------------
static Fixed      gLeftLimit, gRightLimit;
static TSpanStack gSpanStack;

// ------------------------------------------------------------------------
inline PCellItem GetStructureAt(TColumnStructure structure, int row, int column)
{
  return structure->AtRowCol(row, column);
}

// ------------------------------------------------------------------------
void IUTBFormat(void)
{
  gSpanStack = new _TSpanStack(sizeof(TSpanInfo));
}


// ------------------------------------------------------------------------
int _TSpanStack::Compare(Ptr item1, Ptr item2)
{
  int  Compare_r;

  if ((Compare_r = PSpanInfo(item1)->spanEnd - PSpanInfo(item2)->spanEnd) == 0)
    Compare_r = PSpanInfo(item1)->spanWidth - PSpanInfo(item2)->spanWidth;
  return(Compare_r);
}


// ------------------------------------------------------------------------
_TTableFormat::_TTableFormat(TMainView itsView)
                          : (itsView, sizeof(TTableFormatData))
{
  fAscent = 0;
#ifndef ZERO_OBJ
  fDepth = 0;
  fWidth = 0;
  fMinWidth = 0;
  fHeadingDepth = 0;
  fSpare = 0; // fn1
  fMaxRowDepth = 0;
  fHasFootnotes = FALSE;
  fKeepTogether = FALSE;
#endif
}


// ------------------------------------------------------------------------
TCursorNode _TTableFormat::InitialCursor(TCurrency currency, TCurrency child, long posn)
{
  TColCursorNode cursor = new _TColCursorNode(currency, kNewCursor, gZeroVPt);
  TColumnStructure s = TColumnStructure(GetStructureReadOnly(currency));

  if (child == 0)
    child = s->AtRowCol(1, 1)->cell;
  else if (child == -1)
    child = s->AtRowCol(s->fNumberOfRows, 
         s->FindMasterCell(s->fNumberOfRows, s->fNumberOfColumns))->cell;

  cursor->SetCell(child);

  return cursor;
}


// ------------------------------------------------------------------------
TCursorNode _TTableFormat::GetTheCursor(TView view, VPoint &mousePoint,
                                        TCurrency child)
{
  TColCursorNode cursor;

// 20/02/94 child == 0 not now passed
//  if (child == 0)
//    cursor = TColCursorNode(TTableView(view)->ClickOnce(mousePoint));
//  else
//  {
    cursor = TColCursorNode(InitialCursor(
             TTableView(view)->GetStructure(), child, 0)); // 24/03/92
    cursor->fIdentifier = view->fIdentifier;
    cursor->fLastRow = TTableView(view)->fLastRow;
//  }

  return cursor;
}


// ------------------------------------------------------------------------
void _TTableFormat::DoClearFlags(PCellItem cellItem, TMainView mainView, int hf)
{
  TCurrency cell = cellItem->cell;

  if (cell != 0)
    mainView->GetFormatReadOnly(cell)->ClearChangedFlags(cell, hf); //21/03/91 RW
}


// ------------------------------------------------------------------------
void _TTableFormat::ClearChangedFlags(TCurrency currency, int hf)
{
  TTableStructure table;

  if (!fHasChanged) return; // 6/5/92
  SetHasChanged(FALSE);
  table = TTableStructure(GetStructureReadOnly(currency));        // 21/03/91 RW
  table->Each(this, (DoToItem)_TTableFormat::DoClearFlags, fMainView, hf);
}


// ------------------------------------------------------------------------
void _TTableFormat::DeleteFormatData(int index)
{
  if (index > 0)
    DeleteColumn(index);
  else
    Delete(-index);
}


// ------------------------------------------------------------------------
bool _TTableFormat::ContainsCursor(TCurrency currency, TObject startBreak,
                                   TObject endBreak, TCursorNode cursor)
{
  bool  ContainsCursor_r;
  int startRow;
  int endRow;
  int cursorRow;
  TTableStructure table;

  if (cursor->fCurrency != currency)
    ContainsCursor_r = FALSE;
  else
  {
    table = TTableStructure(GetStructureReadOnly(currency));
    startRow = 1;
    if (startBreak != NULL)
      startRow = TTableBreak(startBreak)->GetBreakRow();
    endRow = MAXINT;
    if (endBreak != NULL)
      endRow = TTableBreak(endBreak)->GetBreakRow();
    cursorRow = TColCursorNode(cursor)->GetRow(table);
    if (table->IsHeadingRow(cursorRow))
      cursorRow = TColCursorNode(cursor)->fLastRow;
    ContainsCursor_r = ((cursorRow >= startRow) && (cursorRow < endRow));
  }

  return ContainsCursor_r;
}


// ------------------------------------------------------------------------
void _TTableFormat::GetMarginLimits(TStructure structure, int part,
                    Rect &custom, Fixed &leftLimit, Fixed &rightLimit)
{
  TTableStructure table = TTableStructure(structure);
  int index;
  TCellRect allCells;
  int spanCount;

  // bool cloned;
  // TCurrency styleCurrency;
  // styleCurrency = structure->fStyle;
  // TColumnStyleFormat tableStyle = TColumnStyleFormat(GetStyleReadOnly(styleCurrency));
  // cloned = FALSE;
  // styleCurrency = structure->fChanges;
  // if (styleCurrency != 0)
  // {
  //   TColumnStyleFormat tableChanges;

  //   tableStyle = TColumnStyleFormat(tableStyle->Clone());
  //   cloned = TRUE;
  //   tableChanges = TColumnStyleFormat(GetStyleReadOnly(styleCurrency));
  //   tableStyle->ApplyOverride(tableChanges, gNullCurrency, TRUE);
  // }
  // if (cloned)
  //   tableStyle->Free();

  table->GetAllCells(allCells);
  if (part == kAllCols)
  {
    PCellRect r = PCellRect(&custom);

    leftLimit += GetLeftMargin();
    rightLimit += GetRightMargin();
    gLeftLimit = leftLimit;
    gRightLimit = rightLimit;
    if (!EqualRect(custom, *((Rect *)&allCells)) &&
                               (r->endCol != r->startCol || r->endRow != r->startRow))
      leftLimit = -MAXLONGINT;
  }
  else if (part == kAllColsBody) // 29/5/92 added clause to hide margins
  {
    if (EqualRect(custom, *((Rect *)&allCells)) &&
                               (table->fNumberOfRows > 1 || table->fNumberOfColumns > 1))
      leftLimit = -MAXLONGINT;
  }
  else if (leftLimit != -1)        // 15/10/96 [27107] for Word Tables >= 0)
  { 
    PCellRect r = PCellRect(&custom);

       // 17/06/91 new loop; 10/05/96 for hidden cols? need to avoid incrementing off the end
    while (r->startCol < table->fNumberOfColumns && GetColWidth(r->startCol) == 0)
    {
      r->startCol++;
      r->endCol++;
    }
    leftLimit = gLeftLimit + GetColLtEdge(r->startCol) + fSpare;
    rightLimit = gRightLimit + fSpare;   // 13/05/96 [27027] add in inter column gap half
    spanCount = (GetStructureAt(table, r->startRow, r->startCol))->spanCount;
    for (index = table->fNumberOfColumns; index >= r->endCol + spanCount + 1; index--)
      rightLimit += GetColWidth(index);
  }
}


// ------------------------------------------------------------------------
int _TTableFormat::GetMinWidth(void)
{
#ifdef MATHS
  return fMinWidth + (100 * fNumberOfColumns) - 90 + 
         FixRound(fLeftMargin + fRightMargin);  // 13/01/92, 15/12/92 borders round matrices
#else
  return fMinWidth;
#endif
}


// ------------------------------------------------------------------------
void _TTableFormat::SetRealWidth(PCellItem cellStruct, int row, int column)
{
  TFormat child;
  int cellWidth;

  if (!cellStruct->hidden)
  {
    child = GetFormatReadWrite(cellStruct->cell);
    if (cellStruct->spanCount == 0)
    {
      cellWidth = FixRound(Curr_fType(cellStruct->cell) == kTableStruct ?
            GetColWidth(column) : GetColumnSubWidth(cellStruct->cell, column, child->fAlign));
    }
    else
    {
#ifdef MATHS
      // 01/05/92 get spanners centred in Matrices by giving them all the spanned space
      if (Curr_fType(cellStruct->cell) == kMathStruct)
      {
        cellWidth = FixRound(GetColRtEdge(column + cellStruct->spanCount - 1) -
                 GetColLtEdge(column) + GetColMinWidth(column + cellStruct->spanCount));
      }
      else
#endif
        cellWidth = child->GetMinWidth();   // 22/01/91 replacement for above
    }
    if (cellWidth == 0)
      cellWidth = 10;     // 1 pt.
    child->SetWidth(cellStruct->cell, cellWidth);
  }
}


// ------------------------------------------------------------------------
void _TTableFormat::DoSetRealWidth(PCellItem cellStruct, int row, int column)
{
  SetRealWidth(cellStruct, row, column);
}


// ------------------------------------------------------------------------
void _TTableFormat::SetWidth(TCurrency currency, int newWidth)
{
  TColumnStructure structure;
  TCellRect allCells;

  newWidth -= FixRound(fLeftMargin + fRightMargin);  // 15/12/92 borders round matrices
  if (fWidth == 0 || (newWidth != fWidth && newWidth > fMinWidth))
  {
    structure = TColumnStructure(GetStructure(currency));
    Distribute(structure, 1, structure->fNumberOfColumns,
                                            ToFixed(newWidth - fMinWidth));
    structure->GetAllCells(allCells);
    structure->ForSelectedCellsDo(this, allCells, (Action)_TTableFormat::DoSetRealWidth);
#ifdef MATHS
    // 29/07/92 for spanners > width of non spanners the width needs increasing
    if (structure->fCellKind == kMaths)
    {
      int newMinWidth =  Max(FromFixed(GetColRtEdge(fNumberOfColumns)), newWidth);

      if (fWidth != 0)
        fWidth = newMinWidth;
      fMinWidth = newMinWidth + 90 - (100 * fNumberOfColumns);  
    }
    else
#endif
      fWidth = newWidth;
  }
}

#define arrowUp 0x0f
#define arrowLeft 0x0c
#define arrowDown 0x0e
#define arrowRight 0x0d
// ------------------------------------------------------------------------
void _TTableFormat::MoveCursor(TCursorNode cursor, int arrowKey,
                                                        EventInfo & info)
{
//  TTextDocument document = TTextDocument(fMainView->fDocument);
  TTableStructure structure =
    TTableStructure(GetStructureReadOnly(cursor->fCurrency));
  int row;
  int initCol;
  int column;
  VPoint mousePt;
  int direction = (arrowKey & 0x0f);
  bool fromEnd = (direction == arrowUp || direction == arrowLeft);
  TCursorNode target;
  TFormat format;

  TColCursorNode(cursor)->GetRowCol(structure, row, column);
  initCol = column;
  mousePt = cursor->GetCursorTarget()->fMousePt;
                                  // save this to put back in new cursor
//  if (arrowKey == 0x1ae || arrowKey == 0x1af)         // Ctrl up and down
  if ((arrowKey & 0x7f) >= 0x2e)         // Ctrl up and down, send to document body
    row = 0;
  else
  // 02/05/91 all calls of FindMasterCell added
  if (direction == arrowUp)
  {
    do
    {
      row--;
    } while(row > 0 && structure->RowColHidden(row, TRUE));
  }
  else if (direction == arrowLeft)
  {
    // 22/12/93 [21205], [21206] skip over any following hidden column
    do
    {
      column--;
      if (column == 0)
      {
        column = structure->fNumberOfColumns;
        row--;
      }
    }
    while (row > 0 && structure->AtRowCol(row, column)->hidden);
  }
  else if (direction == arrowDown)
  {
    do
    {
      row++;
    } while(row <= structure->fNumberOfRows && structure->RowColHidden(row, TRUE));
  }
  else // if (direction == arrowRight)
  {
    // 22/12/93 [21205] skip over any following hidden column
    do
    {
      column++;
      if (column > structure->fNumberOfColumns)
      {
        column = 1;
        row++;
      }
    }
    while (row <= structure->fNumberOfRows && structure->AtRowCol(row, column)->hidden);

  }
  if (row == 0 || row > structure->fNumberOfRows || column == 0 ||
              column > structure->fNumberOfColumns)
  {
    SendToParent(cursor, arrowKey, info, structure); // 21/11/91
    return;
  }
  column = structure->FindMasterCell(row, column);
         // 09/07/91 use FindNextVisible, then FindMasterCell at end
  structure->ResetCursor(cursor, PackTwoShorts(row, column), fromEnd, FALSE);
  target = cursor->GetCursorTarget();
  if (direction >= arrowDown && initCol == column)   // 09/07/91
    target->fMousePt = mousePt;
  format = GetFormatReadOnly(target->fCurrency);
  format->MoveCursor(target, arrowKey, info);
  info.affectsMenus = TRUE;
}


// ------------------------------------------------------------------------
int _TTableFormat::GetWidth(void)
{
  return (fWidth != 0 ? fWidth : GetMinWidth());  // 13/01/92 GMW from fMinWidth
}

// ------------------------------------------------------------------------
int _TTableFormat::BorderCompatibility()
{
  return -fNumberOfColumns;  // only match with tables with the same number of columns
}

// ------------------------------------------------------------------------
bool _TTableFormat::PreFormat(TCurrency currency, int &part, Rect &custom,
          VRect &ruleWidths, TStyleFormat &theStyle, TChangeTypes &result, Fixed gapHalf)
{
  bool  PreFormat_r;
  TSelection selection;
  TReformatTypes reformatType;

  selection = fMainView->fSelection;
  reformatType = selection->fReformatType;
  PreFormat_r = _TColFormat::PreFormat(currency, part, custom, ruleWidths,
                                       theStyle, result, gapHalf);

  if (reformatType == kReformatPaste || reformatType == kSelSlow ||
        reformatType == kSelStyleChgd || reformatType == kReformatAll) // 07/08/95 [26045] kRAll
    part = 1;

  return PreFormat_r;
}


// ------------------------------------------------------------------------
// fn1
TChangeTypes _TTableFormat::DoTableNote(TCurrency note, TCurrency ref, // 11/5/93
        TLocalTableReformat* v)
{
#ifdef FN
  v->noteFound = TRUE;
  return CallNoteFunc(v->refNoteProc, note, ref); // 11/5/93
#else
  return kNoChg;
#endif
}


// ------------------------------------------------------------------------
void _TTableFormat::CheckRowHeight(PCellItem cellStruct, int row,
                                   int column, TChangeTypes *result)
{
  TFormat child;
  long cellAscent;
  long cellDescent;
  int spBefore, spAfter;

  if (*result < kHeightChg)      // 09/05/93 [20855] from !=
  {
    cellAscent = 0;    // 01/07/92 always initialise
    cellDescent = 0;   // 01/07/92 initialise
    if (!cellStruct->hidden)
    {
      child = GetFormatReadWrite(cellStruct->cell);
      child->GetDepth(cellAscent, cellDescent);
      child->GetSpacing(spBefore, spAfter);
      cellAscent += spBefore;
      cellDescent += spAfter;
    }

    { 
      register TTableFormatData *cgf_37 = PTableFormatData(At(row));
      if ((cgf_37->ascent != cellAscent) || (cgf_37->descent < cellDescent))
        *result = kHeightChg;
    }
  }
}


// ------------------------------------------------------------------------
void _TTableFormat::MeasureRow(PCellItem cellStruct, int row, int column)
{
  TFormat child;
  long cellAscent;
  long cellDescent;
  int spBefore, spAfter;

  cellAscent = 0;     // 01/07/92 initialised always
  cellDescent = 0;
  if (!cellStruct->hidden)
  {
    child = GetFormatReadWrite(cellStruct->cell);
    child->GetDepth(cellAscent, cellDescent);
    child->GetSpacing(spBefore, spAfter);
    cellAscent += spBefore;
    cellDescent += spAfter;
  }

  { 
    register TTableFormatData *cgf_36 = PTableFormatData(At(row));

    if (cgf_36->ascent < cellAscent)
      cgf_36->ascent = cellAscent;
    if (cgf_36->descent < cellDescent)
      cgf_36->descent = cellDescent;
  }
}


// ------------------------------------------------------------------------
void _TTableFormat::ReformCells(PCellItem cellStruct, int row, int column,
                TCursorNode startCursor, TCursorNode endCursor, TChangeTypes *result,
                TLocalTableReformat *v)
{
  TFormat child;
  Fixed cellWidth;
  int i;
  TChangeTypes cellResult;

  if (cellStruct->hidden)
  {
  }
  else
  {
    cellWidth = 0;
    for (i = 0; i <= cellStruct->spanCount; i++)
      cellWidth += GetColWidth(i + column);
    cellWidth = Min(cellWidth, v->fitWidth - GetColLtEdge(column)) - fSpare * 2;
    child = GetFormatReadWrite(cellStruct->cell);
#ifdef FN
    v->noteFound = FALSE;
#endif
    v->currentRow = row;
    v->vars.obj = this;
    v->vars.procToDo = (DoNote) _TTableFormat::DoTableNote;
    cellResult = child->Reformat(cellStruct->cell, startCursor, endCursor, FixRound(cellWidth),
                 fSpare, PStdNoteVars(v));
#ifdef FN
    if (v->noteFound)
      PTableFormatData(At(row))->rowHasFootnote = TRUE;
#endif
    if (cellResult > *result)
      *result = cellResult;
  }
}


// ------------------------------------------------------------------------
void _TTableFormat::GetColChanges(PCellItem cellStruct, int row, int column,
         int *changedCol, TChangeTypes *result, TCursorNode startCursor, TCursorNode endCursor,
         TLocalTableReformat *v)
{
  TFormat child;
  Fixed oldWidth;
  Fixed newWidth;
  TAlignment oldAlign;
  Fixed colWidth;
  TCursorNode sc, ec;
  TChangeTypes cellResult;
  int widthForRefmt;

  if (cellStruct->hidden)
  {
    if (cellStruct->colChange)
    {
      if (*changedCol == 0 || *changedCol > column)
      {
        *changedCol = column;
        *result = kHeightChg;
      }
    }
    else if (cellStruct->rowChange)
      *result = kHeightChg;
  }
  else
  {
    child = GetFormatReadWrite(cellStruct->cell);
    oldWidth = ToFixed(child->GetMinWidth());
    oldAlign = child->fAlign;
    v->currentRow = row;
    if (startCursor != NULL && startCursor->fCurrency == cellStruct->cell)
    {
      sc = startCursor;
      ec = endCursor;
    }
    else
    {
      sc = NULL;
      ec = NULL;
    }
    widthForRefmt = 0;    // inline: GetWidthForReformat(FixRound(v->fitWidth), cellStruct, row,
                          // column, TColumnStyleFormat(v->composite)); // 19/09/90
#ifdef FN
    v->noteFound = FALSE;
#endif
    v->vars.obj = this;
    v->vars.procToDo = (DoNote) _TTableFormat::DoTableNote;
    cellResult = child->Reformat(cellStruct->cell, sc, ec, widthForRefmt, -1,
                                                    PStdNoteVars(v));
#ifdef FN
    if (v->noteFound)
    {
      PTableFormatData(At(row))->rowHasFootnote = TRUE;
      // 09/05/93 [20855]     if (cellResult == kHeightChg) // 30/6/92
      // 09/05/93 [20855]       v->notesChgdHt = TRUE; 
    }
#endif
    if (cellResult > *result)
      *result = cellResult;
    // 29/11/94 [23017] &&.. losing repaginate at end of reformat (by resetting from
    //          kHeightChg to kStructChg), when it should have been left at kFootnoteChg
    if (cellStruct->rowChange && *result < kHeightChg)
      *result = kHeightChg;
    newWidth = ToFixed(child->GetMinWidth());
    colWidth = GetColumnSubWidth(cellStruct->cell, column, child->fAlign);   // 07/11/90
    if (cellStruct->colChange || ((newWidth < oldWidth) &&
        (oldWidth >= colWidth)) || (newWidth > colWidth) ||
        (oldAlign != child->fAlign) || cellStruct->spanCount > 0)
                // 19/11/91 cellStruct->spanCount > 0 for updating view size on typing
    {
      if (*changedCol == 0 || *changedCol > column)
        *changedCol = column;
    }
  }
}

// ------------------------------------------------------------------------
TStyleFormat _TTableFormat::GetRowColStyle(int part, int rowCol, TTableStructure structure)
{
  TCurrency styleCurr;
  TCurrency changesCurr;
  Rect custom;
  TStyleFormat theStyle;
  TStyleFormat theComposite;

  // 27/01/94 [21357] TableStructure::GetPartStyle written to adjust custom for hidden rows
  SetRect(custom, rowCol, rowCol, rowCol, rowCol);
  styleCurr = structure->GetPartStyle(part, custom, changesCurr);

  if (styleCurr == 0 && changesCurr == 0)
    theComposite = NULL;
  else
  {
    theComposite = TStyleFormat(fMainView->GetPrototype(kTextStyleStruct));

    theComposite->fDefined |= kHasAdornment;         // 14/01/91

    if (styleCurr != 0)
    {
      theStyle = GetStyleReadOnly(styleCurr);
      theComposite->ApplyOverride(theStyle, styleCurr, TRUE);
    }
    if (changesCurr != 0)
    {
      theStyle = GetStyleReadOnly(changesCurr);
      theComposite->ApplyOverride(theStyle, gNullCurrency, TRUE);
    }
  }
  return theComposite;
}

// ------------------------------------------------------------------------
static void InitRowStyleData(PTableFormatData data)
{
  data->adornment = 0;
  data->ruleType.fRule = kNoRule;
  data->ruleType.fPen = kOnePtPen;
  data->ruleType.fShort = FALSE;  // 21/07/92
  data->topBorder = 0;
  data->btmBorder = 0;
}

// ------------------------------------------------------------------------
TChangeTypes _TTableFormat::Reformat(TCurrency currency, TCursorNode anchor,
        TCursorNode activeEnd, int fitToWidth, Fixed gapHalf, PStdNoteVars refNoteProc)
{
  TLocalTableReformat v;
  int i;
  int rowDepth;
  TTableStructure structure;
  int numberOfCols;
  int rowsToAdd;
  TTableFormatData newCellFormat;
  TColumnStyleFormat tableStyle;
  int cn;
  TCursorNode startCursor;
  TCursorNode endCursor;
  int changedCol;
  long notesInSel;
  long oldDepth;
  Fixed columnLimit;
  Fixed cellWidth;
  TCellRect cellCoords;
  TCellRect allCells;
  PCellItem cellStruct;
  TFormat aChild;
  int part;
  Rect custom;
  VRect ruleWidths;
  TChangeTypes result;
  Fixed oldWidth;
  bool keepTogetherChgd;
  int oldHeadingDepth;

  v.fitToWidth = fitToWidth;
  v.refNoteProc = refNoteProc;

  // 09/05/93 [20855]  v.notesChgdHt = FALSE;

  oldDepth = fDepth;
  oldWidth = (fitToWidth == 0 ? 0 :
       ToFixed(fWidth) - GetLeftMargin() - GetRightMargin());

  fWidth = fitToWidth;
  structure = TTableStructure(GetStructureReadOnly(currency));
  if (!PreFormat(currency, part, custom, ruleWidths, v.composite, result, gapHalf))
  {
    FreeIfObject(v.composite);
    return result;
  }
#ifdef MATHS
  // 29/04/92 stop matrix columns being anything other than centred?
  if (structure->fCellType == kMathStruct)
    fAlign = kAlignCentre;
#endif
  keepTogetherChgd = fKeepTogether != TColumnStyleFormat(v.composite)->fKeepTogether;
  if (keepTogetherChgd)
    fKeepTogether = !fKeepTogether;

  startCursor = NULL;
  endCursor = NULL;
  tableStyle = TColumnStyleFormat(v.composite);

  structure->GetAllCells(cellCoords);
  rowsToAdd = Max(0, cellCoords.endRow - fSize);
  numberOfCols = cellCoords.endCol;
  SetNumberOfCols(numberOfCols, tableStyle);

  if (rowsToAdd > 0)
  {
    newCellFormat.ascent = 0;
    newCellFormat.descent = 0;
    newCellFormat.tableNoteDepth = 0;
    newCellFormat.rowHasFootnote = FALSE;
    InitRowStyleData(&newCellFormat);  // 24/11/91 common up initialisation

    for (i = 1; i <= rowsToAdd; i++)
      InsertLast(&newCellFormat);
  }

  if (part == 0 && structure->GetSelectedCells(cellCoords, anchor, activeEnd) == kWithinCell)
  {
    startCursor = anchor->GetNext();
    endCursor = activeEnd->GetNext();
  }
  else
  {
    structure->GetAllCells(cellCoords); // 04/10/91 to reformat after deleting > 1 row
    for (cn = 1; cn <= numberOfCols; cn++)
      for (i = kAlignLeft; i <= kFill; i++)
        SetColumnSubWidth(gNullCurrency, cn, i, -1);
  }

  notesInSel = 0;
  for (i = cellCoords.startRow; i <= cellCoords.endRow; i++)
  { 
    register TTableFormatData *tfd = PTableFormatData(At(i));

    notesInSel += int(tfd->rowHasFootnote);
    tfd->rowHasFootnote = FALSE;
  }

  if (notesInSel != 0)
  {
    cellCoords.startCol = 1;
    cellCoords.endCol = numberOfCols;
  }

  if (oldDepth != -1)
  {
    for (i = cellCoords.startRow; i <= cellCoords.endRow; i++)
    {
      if (structure->IsHeadingRow(i))
        oldDepth = -1;
    }
  }

  changedCol = 0;
  if (part == 1)    
    structure->GetAllCells(allCells);       // 03/04/91
  else if (part > 1)
    MoveRect(*((Rect *)&allCells), custom);
  else
    ClearRect(*((Rect *)&allCells));

  for (i = 1; i <= allCells.endRow; i++)
  {
    // inline SetRowBorder(i)
    TStyleFormat rowStyle = GetRowColStyle(kRowPart, i, structure);
    PTableFormatData data = PTableFormatData(At(i));
    bool borderSet = FALSE;

    if (rowStyle != NULL)
    {
      if (data->ruleType.fRule != rowStyle->fOwnRuleType.fRule ||
           data->ruleType.fPen != rowStyle->fOwnRuleType.fPen ||
               data->adornment != rowStyle->fOwnAdornment)
        result = kHeightChg;

      if ((rowStyle->fDefined & kOwnAdornment) != 0)
      {
        data->adornment = rowStyle->fOwnAdornment;
        data->ruleType = rowStyle->fOwnRuleType;
        data->topBorder = FixRound(GetBorderWidth(adnLineTop, data->adornment, data->ruleType));
        data->btmBorder = FixRound(GetBorderWidth(adnLineBottom, data->adornment, data->ruleType));
        borderSet = TRUE;
      }
    }
    // 24/11/91 set the border sizes to zero if rowStyle is NULL
    if (!borderSet)
      InitRowStyleData(data);   // 24/11/91 common up initialisation
    FreeIfObject(rowStyle);
  }
  for (i = 1; i <= allCells.endCol; i++)
  {
    // inline SetColBorder(i)
    TRuleType itsRuleType;
    CntlAdornment itsAdornment;
    TStyleFormat colStyle = GetRowColStyle(kColPart, i, structure);
    bool borderSet = FALSE; // 29/5/92

    if (colStyle != NULL)
    {
      if (changedCol == 0)
      {
        GetColBorders(i, itsRuleType, itsAdornment);
        if (itsRuleType.fRule != colStyle->fOwnRuleType.fRule ||
             itsRuleType.fPen != colStyle->fOwnRuleType.fPen ||
                 itsAdornment != colStyle->fOwnAdornment)
          changedCol = i;
      }
      if ((colStyle->fDefined & kOwnAdornment) != 0)
      {
        SetColBorders(i, colStyle->fOwnRuleType, colStyle->fOwnAdornment);
        borderSet = TRUE; // 29/5/92
      }
      FreeIfObject(colStyle);
    }
    if (!borderSet) // 29/5/92     
    {
      itsRuleType.fRule = kNoRule;
      SetColBorders(i, itsRuleType, 0);
    }
  }

  // 23/01/91 new block inserted to set fRCBorderEnds
  ClearRect(fRCBorderEnds);
  structure->GetAllCells(allCells);
  for (i = 1; i <= allCells.endRow; i++)
  {
    PTableFormatData data = PTableFormatData(At(i));

    fRCBorderEnds.left = Max(fRCBorderEnds.left, FixRound(
                                 GetBorderWidth(adnLineLeft, data->adornment, data->ruleType)));
    fRCBorderEnds.right = Max(fRCBorderEnds.right, FixRound(
                                 GetBorderWidth(adnLineRight, data->adornment, data->ruleType)));
  }
  for (i = 1; i <= allCells.endCol; i++)
  {
    TRuleType rcRuleType;
    CntlAdornment rcAdornment;

    GetColBorders(i, rcRuleType, rcAdornment);
    fRCBorderEnds.top = Max(fRCBorderEnds.top, FixRound(
                                 GetBorderWidth(adnLineTop, rcAdornment, rcRuleType)));
    fRCBorderEnds.bottom = Max(fRCBorderEnds.bottom, FixRound(
                                 GetBorderWidth(adnLineBottom, rcAdornment, rcRuleType)));   
  }
  if (fitToWidth != 0)
  {
    fitToWidth = ToFixed(fitToWidth);
    v.fitWidth = fitToWidth - GetLeftMargin() - GetRightMargin();
  }

  if (tableStyle->GetAuto())
  {
    structure->ForSelectedCellsDo(this, cellCoords, (Action)_TTableFormat::GetColChanges,
                                             &changedCol, &result, startCursor, endCursor, &v);
    if (changedCol == 0 && oldWidth == v.fitWidth)
    {
      if (result < kHeightChg && result != kStructChg && part <= 0)
                                                         // 09/05/93 [20855] from != kHeightChg
        result = kWidthChg;
    }
    else
    {
      if (result == kWidthChg)
        result = kStructChg;

      if (changedCol <= 1)
      {
        changedCol = 1;
        columnLimit = 0;
      }
      else
      {
        columnLimit = GetColumnLimit(changedCol - 1);
        for (cn = 1; cn < changedCol; cn++)
        {
          // Get column border width
          TRuleType itsRuleType;
          CntlAdornment itsAdornment;

          GetColBorders(cn, itsRuleType, itsAdornment);
          
          columnLimit += GetBorderWidth(adnLineLeft, itsAdornment, itsRuleType) +
                         GetBorderWidth(adnLineRight, itsAdornment, itsRuleType);
        }
      }
      for (cn = changedCol; cn <= numberOfCols; cn++)
      {
        cellWidth = 0;
        for (i = kAlignLeft; i <= kFill; i++)
          SetColumnSubWidth(gNullCurrency, cn, i, -1);

        for (i = 1; i <= fSize; i++)
        {
          cellStruct = GetStructureAt(structure, i, cn);
          if (!cellStruct->hidden && cellStruct->spanCount == 0)
          {
            Fixed cellMinWidth;

            aChild = GetFormatReadOnly(cellStruct->cell);
            cellMinWidth = ToFixed(aChild->GetMinWidth());
            cellWidth = Max(cellWidth, cellMinWidth);
            SetColumnSubWidth(cellStruct->cell, cn, aChild->fAlign, cellMinWidth);
          }
        }
        {
          // Get column border width
          TRuleType itsRuleType;
          CntlAdornment itsAdornment;

          GetColBorders(cn, itsRuleType, itsAdornment);
          
          columnLimit += cellWidth + GetBorderWidth(adnLineLeft, itsAdornment, itsRuleType) +
                                     GetBorderWidth(adnLineRight, itsAdornment, itsRuleType);
        }
      }
      if (v.fitWidth > 0)
        Distribute(structure, 1, numberOfCols, v.fitWidth - columnLimit);
#ifdef NEVER
      // need to do something like this to get correct MinWidth for long spanners in matrices
      else
      {
        int xxx, yyy;

        Distribute(structure, 1, numberOfCols, 0);
        xxx = GetColumnLimit(fNumberOfColumns);
        yyy = GetColRtEdge(fNumberOfColumns);
      }
#endif
      fMinWidth = FixRound(columnLimit) + fRCBorderEnds.left + fRCBorderEnds.right;
    }
    structure->ForSelectedCellsDo(this, changedCol != 0 || rowsToAdd > 0 ? allCells : cellCoords,
                                                   (Action)_TTableFormat::DoSetRealWidth);
  }
  else
  {
    // 13/05/96 [27027] Implement maually resized table column widths
    Fixed prevRtEdge;

    fSpare = Max(10000, v.composite->GetGutterWidth());  // at least 1pt. ?
    for (prevRtEdge = 0, i = 1; i <= numberOfCols; i++)
    {
      PColFormatData info = InfoAt(i);

      info->columnRtEdge = tableStyle->ColPosition(i);
      info->columnLimit = info->columnRtEdge - prevRtEdge;
      for (int al = kAlignLeft; al <= kFill; al++)
        info->columnSubWidths[al] = info->columnLimit;
      prevRtEdge = info->columnRtEdge;
    }
    fRightMargin = fitToWidth - prevRtEdge - fLeftMargin;
    structure->ForSelectedCellsDo(this, cellCoords, (Action)_TTableFormat::ReformCells,
                                                        startCursor, endCursor, &result, &v);
  }

  structure->ForSelectedCellsDo(this, cellCoords, (Action)_TTableFormat::CheckRowHeight, &result);

  if (rowsToAdd > 0)
    structure->GetAllCells(cellCoords);
  cellCoords.startCol = 1;
  cellCoords.endCol = numberOfCols;
  for (i = cellCoords.startRow; i <= cellCoords.endRow; i++)
  { 
    register TTableFormatData *fmtData = PTableFormatData(At(i));

    fmtData->ascent = 0;
    fmtData->descent = 0;
  }
  structure->ForSelectedCellsDo(this, cellCoords, (Action)_TTableFormat::MeasureRow);
  fDepth = FixRound(ruleWidths.top + ruleWidths.bottom) +
                                                fRCBorderEnds.top + fRCBorderEnds.bottom;
  oldHeadingDepth = fHeadingDepth;
  fHeadingDepth = 0;
  fMaxRowDepth = 0;
  fHasFootnotes = FALSE;
  for (i = 1; i <= fSize; i++)
  {
    register TTableFormatData *fmtData = PTableFormatData(At(i));

    rowDepth = fmtData->ascent + fmtData->descent + fmtData->topBorder + fmtData->btmBorder;
    fDepth += rowDepth;
    if (fmtData->rowHasFootnote)
      fHasFootnotes = TRUE;

    if (structure->IsHeadingRow(i))
      fHeadingDepth += rowDepth;
    else if (rowDepth > fMaxRowDepth)
      fMaxRowDepth = rowDepth;
  }

#ifdef MATHS
  if (fSize == 1)
    fAscent = PTableFormatData(At(1))->ascent;   // 26/07/92 keep baseline for single row
  else
#endif
    fAscent = fDepth / 2;
  fDescent = fDepth - fAscent;

  if (oldDepth != fDepth || keepTogetherChgd || oldHeadingDepth != fHeadingDepth) 
                              // 17/09/92 keepTogether, 14/12/92 for undo Column heading change
    result = kHeightChg;
  else if (result == kHeightChg)    // kFootnoteChg is not reset to kStructChg
    result = kStructChg;

  SetHasChanged(TRUE);
  FreeIfObject(v.composite);
  return result;
}


// ------------------------------------------------------------------------
void _TTableFormat::Distribute(TColumnStructure colStruct, int firstCol,
                               int lastCol, Fixed spare)
{
  int r, c, i;
  Fixed cellWidth;
  Fixed columnLimit;
  Fixed prevRtEdge;
  int numberOfColumns;
  PCellItem cellStruct;
  TFormat aChild;
  Fixed slop;
  Fixed runningSlop;
  Fixed excess;
  TSpanInfo spanInfo;
  Fixed spanLimit;

  numberOfColumns = lastCol - firstCol + 1;
  for (c = firstCol; c <= lastCol; c++)
  {
    if (HiddenCol(c, colStruct) && numberOfColumns > 1) // 07/04/91 && safety
      numberOfColumns--;
  }

  slop = FixDiv(spare, ToFixed(numberOfColumns));
  runningSlop = 0;
  if (firstCol == 1)
  {
    prevRtEdge = 0;
    columnLimit = 0;
  }
  else
  {
    prevRtEdge = (InfoAt(firstCol - 1))->columnRtEdge;
    columnLimit = GetColumnLimit(firstCol - 1);
  }

  for (c = firstCol; c <= lastCol; c++)
  {
    if (HiddenCol(c, colStruct))
    {
      SetColumnLimit(c, columnLimit);
      InfoAt(c)->columnRtEdge = prevRtEdge;
    }
    else
    {
      cellWidth = 0;
      for (r = 1; r <= fSize; r++)
      {
        cellStruct = GetStructureAt(colStruct, r, c);
        if (!cellStruct->hidden)
        {
          aChild = GetFormatReadOnly(cellStruct->cell);
          if (cellStruct->spanCount == 0)
            cellWidth = Max(cellWidth, ToFixed(aChild->GetMinWidth()));
          else
          {
            spanInfo.spanStart = c;
            spanInfo.spanDistribute = c;
            spanInfo.spanEnd = c + cellStruct->spanCount;
            spanInfo.slopStart = runningSlop;
            spanInfo.spanWidth = GetColWidth(c) - GetColMinWidth(c);
            switch (fAlign)
            {
              case kAlignLeft:
              case kFill:
                spanInfo.spanWidth = 0;
                break;
              case kAlignCentre:
                spanInfo.spanWidth /= 2;
            }
            spanInfo.spanWidth += ToFixed(aChild->GetMinWidth()) +
                (GetColMinWidth(c) - GetColumnSubWidth(cellStruct->cell, c, aChild->fAlign)) / 2;
            gSpanStack->Insert(&spanInfo);
          }
        }
      }
      columnLimit += cellWidth;
      SetColumnLimit(c, columnLimit);
      {
        PColFormatData info = InfoAt(c);
        info->columnRtEdge = prevRtEdge + cellWidth + slop;
        // 22/01/91 new test
        if (info->adornment != 0)
          info->columnRtEdge +=
            GetBorderWidth(adnLineLeft, info->adornment, info->ruleType) +
              GetBorderWidth(adnLineRight, info->adornment, info->ruleType);
        prevRtEdge = info->columnRtEdge;
      }
      runningSlop += slop;
      if (gSpanStack->fSize > 0)
      {
        gSpanStack->GetFirst(&spanInfo);
        while (c == spanInfo.spanEnd)
        {
          register TSpanInfo *cgf_49 = &spanInfo;

          if (cgf_49->spanStart == 1)
            spanLimit = 0;
          else
            spanLimit = (InfoAt(cgf_49->spanStart - 1))->columnRtEdge;
          spanLimit += cgf_49->spanWidth;
          excess = spanLimit - prevRtEdge;
          if ((excess > 0) && (cgf_49->spanDistribute <= c))
          {
            _TColFormat::Distribute(colStruct, cgf_49->spanDistribute, cgf_49->spanEnd,
                   excess + runningSlop - cgf_49->slopStart);
            runningSlop += excess;
            prevRtEdge = (InfoAt(cgf_49->spanEnd))->columnRtEdge;
            if (lastCol > cgf_49->spanEnd)
              slop = FixDiv(spare - runningSlop, ToFixed(lastCol - cgf_49->spanEnd));
            for (i = 2; i <= gSpanStack->fSize; i++)
            { 
              register TSpanInfo *cgf_50 = PSpanInfo(gSpanStack->At(i));
            
              cgf_50->spanDistribute = c + 1;
              cgf_50->slopStart = runningSlop;
            }
          }
          gSpanStack->Delete(1);
          if (gSpanStack->fSize > 0)
            gSpanStack->GetFirst(&spanInfo);
          else
            break;
        }
      }
    }
  }
  gSpanStack->ReduceSize(0);
}

// ------------------------------------------------------------------------
#ifdef FN
void _TTableFormat::FitFootnotes(PCellItem cellStruct, int row, int column,
                                  TLocalTableFitVars* v)
{
  if (!cellStruct->hidden && !v->cantFitNotes)  // [20852] && ... ignore after fit fail
  {
    int gaps;
    bool allFits;
#ifdef TRACE
    int lotsAvailable = v->spaceAvailable;
#endif
    int thisNoteSpace = (v->oldNoteSpace <= 0 ? v->spaceAvailable : v->oldNoteSpace) -
                           v->noteSpaceUsed;

      // noteSpace = 0 on 1st pass, +ve on second pass unless last col when -ve
    if (!GetFormatReadOnly(cellStruct->cell)->
          Fit(v->pageNumber, cellStruct->cell, v->spaceAvailable,
              thisNoteSpace, -abs(v->maxAvailable), // breakObj,
              v->noteBreak, gaps, allFits,
              v->suppliedHeadingProc, v->suppliedFitNoteProc) ||
                                                            v->noteBreak != NULL)
      v->cantFitNotes = column;   // 06/05/93 [20852] now returns column stopped on
    v->noteSpaceUsed += thisNoteSpace;
#ifdef TRACE
    if (lotsAvailable != v->spaceAvailable)
      SysBeep(0);
#endif
  }       
}
#endif


// ------------------------------------------------------------------------
// fn1 params changed
bool _TTableFormat::Fit(int pageNumber, TCurrency currency,
                     int &spaceAvailable, int &noteSpaceUsed, int maxAvailable,
                     TObject &breakObject, int &gapCount, bool &splitLeaf, 
                     PStdFitNoteVars suppliedHeadingProc,
                     PStdFitNoteVars suppliedFitNoteProc)
{
  bool  Fit_r;
  int nextRow;
  int nextCol;
  int i;
  bool headingReserved;
  int rowDepth;
  bool oneDone;
  bool noRoom;
  int spaceUsed = spaceAvailable;
  TLocalTableFitVars v;
  VRect ruleWidths;
  CntlAdornment borders;
  TRuleType ruleType;
  int saveSpace; // fn1
#ifdef FN
  bool hasFootnote;
  int noteDepth = 0;      // 25/03/92 not initialised

  // 01/06/93 moved up so 'fast-path' returns noteSpaceUsed as zero
  v.oldNoteSpace = noteSpaceUsed; // 22/6/92
  noteSpaceUsed = 0;              // 01/06/93
  splitLeaf = FALSE;              // 01/06/93
#else
#define noteDepth 0
#endif  

  v.structure = TTableStructure(GetStructureReadOnly(currency));
  gapCount = 1;         // 17/06/91
  if (breakObject != NULL)
  {
    nextRow = TTableBreak(breakObject)->GetBreakRow();
    nextCol = TTableBreak(breakObject)->GetBreakCol();  // [20853]
  }
  else    // no break, start of table
  {
    if (spaceUsed >= fDepth && !fHasFootnotes)
    {
      spaceAvailable -= fDepth;
      return TRUE;  // all fits in available space
    }
    if (spaceUsed < maxAvailable) // the table does not start at the top of a page
    {
      if (spaceUsed < fDepth && maxAvailable >= fDepth && fKeepTogether)
        return FALSE;  // keep together & wont fit on this && will fit on next

      // 31/01/94 [21370] new loop to calculate heading depth plus following row depth
      // on the first page. This is different to fHeadingDepth which is the depth on
      // the second and subsequent pages
#define NONHEADS 1
       // NONHEADS is the number of non heading lines to be fitted after heading
      //    if (spaceUsed < fHeadingDepth)
      //      return FALSE;
      if (fHeadingDepth > 0)
      {
        int currDepth = 0;
        int headingDepth = 0;
        int thisIsHeading = 0;

        for (nextRow = 1; nextRow <= fSize; nextRow++)
        {
          TTableFormatData *row = PTableFormatData(At(nextRow));

          currDepth += (row->ascent + row->descent + row->topBorder + row->btmBorder);
          thisIsHeading = v.structure->IsHeadingRow(nextRow) ? NONHEADS : thisIsHeading - 1;
          if (thisIsHeading >= 0)
            headingDepth = currDepth;
        }
        if (spaceUsed < headingDepth)
          return FALSE;  // cannot fit first page headings plus NONHEADS rows
      }
    }
    nextRow = 1;
    nextCol = 0; // [20853]
  }

  v.vars.obj = this;
#ifdef FN
  v.pageNumber = pageNumber;
  v.maxAvailable = maxAvailable;
  v.noteSpaceUsed = 0;
  v.cantFitNotes = FALSE;
#endif
  v.suppliedHeadingProc = suppliedHeadingProc;
  v.suppliedFitNoteProc = suppliedFitNoteProc;

  Fit_r = TRUE;
  headingReserved = FALSE;
  v.structure->GetAllCells(v.rowCells);
  GetBorderInfo(ruleWidths, borders, ruleType);
  oneDone = FALSE;
  noRoom = FALSE;
  v.spaceAvailable = spaceUsed;         // 01/06/93

#ifdef FN
  if (nextCol > 0)
  {
    // 07/05/93 [20852] finish off the footnotes from line at end of last page
//    v.noteSpaceUsed = 0;
//    v.cantFitNotes = FALSE;
    v.noteBreak = TTableBreak(breakObject)->fBreakObject;  // 01/06/93
    v.rowCells.startRow = nextRow - 1;
    v.rowCells.endRow = nextRow - 1;
    v.rowCells.startCol = nextCol;
    v.structure->ForSelectedCellsDo(this, v.rowCells,
                            (Action)_TTableFormat::FitFootnotes, &v);
    v.rowCells.startCol = 1;
    nextCol = v.cantFitNotes;
    noteDepth += v.noteSpaceUsed;
    oneDone = TRUE;                       // 01/06/93
  }
  if (nextCol > 0)   // 01/06/93 notes took all the available space
  {
    noRoom = TRUE;
    nextRow++;       // to compensate for the 1 subtracted when making the break object
  }
  else
#endif
  {
#ifdef FN
    v.noteBreak = NULL;  // 01/06/93
    if (nextRow <= fSize)  // 01/06/93 continuation notes not on last row
#endif
      v.spaceAvailable = spaceUsed - FixRound(ruleWidths.top) - fRCBorderEnds.top
               - FixRound(ruleWidths.bottom) - fRCBorderEnds.bottom; // 27/09/91 do always
  }
#ifdef FN
  if (v.oldNoteSpace == 0)
    v.spaceAvailable -= v.noteSpaceUsed;
#endif

  while (nextRow <= fSize && !noRoom)     // 01/06/93 test at loop start
  {
    register TTableFormatData *cgf_52 = PTableFormatData(At(nextRow));

#ifdef FN
    hasFootnote = cgf_52->rowHasFootnote;
#endif
    rowDepth = cgf_52->ascent + cgf_52->descent + cgf_52->topBorder + cgf_52->btmBorder;

    if (rowDepth > 0)
    {
      if (!headingReserved)
      {
        if (breakObject == NULL)  // 31/01/94 [21372] only fit heading notes on first page
        {
#ifdef FN
          saveSpace = v.spaceAvailable; // fn1, 30/6/92
          v.spaceAvailable -= fHeadingDepth; // 30/6/92
          for (i = 1; i <= nextRow - 1; i++)
          {
            v.cantFitNotes = FALSE;  // 07/05/93 [20852]
            if (PTableFormatData(At(i))->rowHasFootnote && v.structure->IsHeadingRow(i))
            {
              v.rowCells.startRow = i;
              v.rowCells.endRow = i;
              v.noteSpaceUsed = 0;  // 07/05/93 do not reset in loop????
              // 07/05/93 [20852] v.cantFitNotes = TRUE;
              v.structure->ForSelectedCellsDo(this, v.rowCells, 
                                (Action)_TTableFormat::FitFootnotes, &v);
            }
            // 07/05/93 [20852] else
            // 07/05/93 [20852]   v.cantFitNotes = FALSE;
          }
          v.spaceAvailable = saveSpace; // fn1, 30/6/92

          if (v.cantFitNotes)
            v.noteSpaceUsed = spaceAvailable;
          else
            noteDepth += v.noteSpaceUsed;
#endif
        }
        // 31/01/94 [21372] if (breakObject != NULL)     // 17/06/91 new test
        else
        {
          if (v.spaceAvailable >= fHeadingDepth + rowDepth) // 31/01/94 [21372] + NOTESPACEUSED)
          {
            v.spaceAvailable -= fHeadingDepth; // 25/03/92
          }
          else
          {
            TTableBreak(breakObject)->SetIgnoreHeading();
          }
        }
        headingReserved = TRUE;
      }
      if (v.spaceAvailable >= rowDepth)
      {
        saveSpace = v.spaceAvailable; // fn1, 30/6/92
        v.spaceAvailable -= rowDepth;
#ifdef FN
        v.noteSpaceUsed = 0; // 22/6/92
        v.cantFitNotes = FALSE;  // 06/05/93 [20852] logic changed
        if (hasFootnote)
        {
          v.rowCells.startRow = nextRow;
          v.rowCells.endRow = nextRow;
          // 06/05/93 [20852] logic changed v.cantFitNotes = TRUE
          // 22/6/92 v.noteSpaceUsed = 0;
          v.structure->ForSelectedCellsDo(this, v.rowCells,
                                (Action)_TTableFormat::FitFootnotes, &v);
        }
        // 06/05/93 [20852] else
        // 06/05/93 [20852]   v.cantFitNotes = FALSE;

        noRoom = v.cantFitNotes;                      // 01/06/93 get out of loop
        
        if (noRoom && v.noteSpaceUsed == 0)
                                  // 07/05/93 [20852] && failed to fit any fn part
        {
          v.spaceAvailable = saveSpace; // 22/6/92
          v.cantFitNotes = 0;                  // 07/05/93 [20852]
        }
        else
        {
          if (noRoom)        // get some of note in, set nextRow for break object
            nextRow ++;
          noteDepth += v.noteSpaceUsed;
          v.spaceAvailable = saveSpace - rowDepth; // 22/6/92
          if (v.oldNoteSpace == 0) // 22/6/92
             v.spaceAvailable -= v.noteSpaceUsed;
          oneDone = TRUE;
        }
#else
        oneDone = TRUE;
#endif
      }
      else
        noRoom = TRUE;
    }
    nextRow++;
  };    // 01/06/93 test at start of loop: while ((nextRow <= fSize) && !noRoom);

#ifdef FN
  noteSpaceUsed = noteDepth; // 22/6/92 
  if (v.oldNoteSpace < 0) // 22/6/92, 23/05/93 [20891]
    v.spaceAvailable -= noteSpaceUsed; // 30/6/92
  else if (v.oldNoteSpace > 0)
    noteDepth = 0;              // 01/06/93 avoid adding it back into break object size
  nextCol = v.cantFitNotes;     // 07/05/93 [20852]
#else
  nextCol = 0;   // 07/05/93 [20852]
#endif

  if (!oneDone)
  {
    // 07/05/93 [20852] v.spaceAvailable = 0;
    Fit_r = FALSE;
  }

  if (breakObject != NULL)
    TTableBreak(breakObject)->SetDepthBelow(spaceUsed - v.spaceAvailable - noteDepth);

  breakObject = (noRoom && oneDone ? (
#ifdef FN
                                      splitLeaf = TRUE,      // 01/06/93 ? like text if break
#endif
    new _TTableBreak(nextRow - 1,
                     nextCol,             // 07/05/93 [20852] put failing fn col in break
#ifdef FN
                     v.noteBreak,         // 01/06/93
#else
                     NULL,
#endif
                     spaceUsed - v.spaceAvailable - noteDepth, 0)) : NULL);
  spaceAvailable = v.spaceAvailable;
  return Fit_r;
}


// ------------------------------------------------------------------------
void _TTableFormat::GetDepth(long &ascent, long &descent)
{
  if (fSize == 1)
    ascent = fAscent;     // 26/07/92 keep baseline for 1-row table
  else
    ascent += fAscent;    // 01/07/92 pass in minus-height from maths/text
  descent = fDepth - ascent;
}


// ------------------------------------------------------------------------
void _TTableFormat::CheckMakeSubviews(PCellItem cellStruct, int row, int column,
             TTableUpdateViewData *data, int* subViewIndex, VRect* areaToUpdate,
             long *rowDepth, bool heading)
// 07/08/95 use subViewIndex == NULL as indicating MakeView call
{
  int i;
  TFormat cellFormat;
  long cellAscent;
  long cellDescent;
  VPoint childLocation;
  TSubView subView;
  long subViewCurrency;
  int totalSubviews;
  int cellSpBefore, cellSpAfter;
  VRect cellRect;
  bool freeOrUpdate = FALSE;
  TList theSubViews;

  theSubViews = data->itsView->fSubViews;  // hope fSubViews is not null!
// 07/08/95 use subViewIndex == NULL as indicating MakeView call
//  subView = NULL;
//  totalSubviews = theSubViews->GetSize();
//  subViewCurrency = 0;
//  if (totalSubviews >= *subViewIndex)
//  {
//    subView = TSubView(theSubViews->At(*subViewIndex));
//    subViewCurrency = subView->fStructure;
//  }
  totalSubviews = data->itsView->CountSubViews();
  subView = (subViewIndex != NULL && totalSubviews >= *subViewIndex ?
                                    TSubView(theSubViews->At(*subViewIndex)) : NULL);
  subViewCurrency = (subView != NULL ? subView->fStructure : 0);

  if (row != data->lastRow)
  {
    register TTableFormatData *cgf_54 = PTableFormatData(At(row));

    data->lastRow = row;
    *rowDepth = cgf_54->topBorder + cgf_54->ascent;
    data->base = data->depth + *rowDepth;
    data->depth = data->base + cgf_54->descent + cgf_54->btmBorder;
    *rowDepth += cgf_54->descent + cgf_54->btmBorder;
    // 02/10/91 ensure bottoms verticals in framed tables invalidated
    if (row == data->itsView->fLastRow)
      *rowDepth += FixRound(data->ruleWidths.bottom);
  }

  // 22/02/94 use cellFormat == NULL rather than cellHidden as flag to stop warning
  if (cellStruct->hidden)
    cellFormat = NULL;
  else
  {
    Fixed colOffset;
    Fixed colOffsetFull;

    cellFormat = GetFormatReadOnly(cellStruct->cell); // 19/03/91 RW
    colOffsetFull = colOffset = 0;
    if (fSpare == 0)
    {
      switch(fAlign)
      {
        case kAlignLeft:
        case kFill:
          break;
        default:
          colOffsetFull = colOffset = GetColWidth(column) - GetColMinWidth(column);
          if (fAlign == kAlignCentre)
            colOffset /= 2;
      }
#ifdef MATHS
      if (Curr_fType(cellStruct->cell) == kMathStruct)   // 24/02/92 
      {
        register TTableFormatData *cgf_59a = PTableFormatData(At(row));
        int spBefore, spAfter;

        cellFormat->GetSpacing(spBefore, spAfter);
        cellFormat->SetDepth(cgf_59a->ascent - spBefore, cgf_59a->descent - spAfter);
      }
      else
#endif
      if (cellFormat->fAlign == kFill || Curr_fType(cellStruct->cell) == kTableStruct)
                                              // 11/04/91 || ...
      {
        if (cellFormat->fFlags == 0)    // 29/06/94 for backwards text
          colOffset = 0;
        else
          colOffset = colOffsetFull;
      }
      else if (cellStruct->spanCount == 0)
        colOffset += (GetColMinWidth(column) -
                GetColumnSubWidth(cellStruct->cell, column, cellFormat->fAlign)) / 2;
      else if (cellFormat->fAlign == kAlignCentre ||
                     cellFormat->fAlign == kAlignRight) // 23/01/91 new clause
      {
        Fixed spanOffset = 0;
        Fixed rightOffset;

        for (int i = 0; i <= cellStruct->spanCount; i++)
          spanOffset += GetColWidth(column + i);

        if (fAlign == kAlignRight)
          rightOffset = 0;
        else
        {
          rightOffset = GetColWidth(column + cellStruct->spanCount) -
                               GetColMinWidth(column + cellStruct->spanCount);
          if (fAlign == kAlignCentre)
            rightOffset /= 2;
        }
        spanOffset = spanOffset - colOffset - rightOffset -
                                        ToFixed(cellFormat->GetMinWidth());
        if (cellFormat->fAlign == kAlignCentre)
          spanOffset /= 2;
        colOffset = colOffset + spanOffset;
      }
    }
    cellAscent = 0;   // 01/07/92
    cellFormat->GetDepth(cellAscent, cellDescent);
    cellFormat->GetSpacing(cellSpBefore, cellSpAfter);
    SetVPt(childLocation, FixRound(colOffset + GetColLtEdge(column) + fSpare +
                data->ruleWidths.left) + fRCBorderEnds.left,
                data->base - cellAscent - cellSpBefore + fRCBorderEnds.top);
                                            // 11/03/94 [21452] + borderEnds.top
    cellRect.top = childLocation.v;
    cellRect.left = childLocation.h;
    cellRect.right = cellRect.left + FixRound(GetColWidth(column));
    cellRect.bottom = cellRect.top + *rowDepth;
    if (row == data->lastRow)       // 11/03/94 [21453] get column border bottoms redrawn
      cellRect.bottom += fRCBorderEnds.bottom;
    ZoomVPt(childLocation);
    ZoomVRect(cellRect);
  }
  if (subViewCurrency == cellStruct->cell)
  {
    if (subViewCurrency != 0)
      freeOrUpdate = TRUE;
  }
  else
  {
    if (subViewIndex != NULL) // 07/08/95 use subViewIndex == NULL as indicating MakeView call
    {
      i = *subViewIndex;
      while (i < totalSubviews && subViewCurrency != cellStruct->cell)
      {
        i++;
        subViewCurrency = TSubView(theSubViews->At(i))->fStructure;
      }
    }

    if (subViewCurrency == cellStruct->cell)     // 07/08/95 will fail for MakeView call
    {
      do {
        subView = TSubView(theSubViews->At(*subViewIndex));
        subViewCurrency = subView->fStructure;
        if (subViewCurrency != cellStruct->cell)
        {
          UnionVRect(*areaToUpdate, cellRect, *areaToUpdate); // 22/01/91      
          subView->Free();
          subView = NULL;
        }
      } while (subViewCurrency != cellStruct->cell);

      freeOrUpdate = TRUE;
    }
    else
    {
      if (cellFormat != NULL) // !cellHidden)
      {
        TViewId viewId;

        viewId.fNumId = 0;
        subView = cellFormat->MakeView(cellStruct->cell, viewId, /* 0, vSlop */ 0,
                                    data->itsView, subView, childLocation, 0, 0);
        UnionVRect(*areaToUpdate, cellRect, *areaToUpdate); // 22/01/91
      }
    }
  }

  if (freeOrUpdate)
  {
    if (cellFormat == NULL)  // cellHidden)
    {
      subView->Free();
      subView = NULL;
    }
    else
      cellFormat->UpdateView(cellStruct->cell, subView, childLocation, 0, // vSlop,
                                                 0, 0, FALSE, TRUE);
    UnionVRect(*areaToUpdate, cellRect, *areaToUpdate); // 22/01/91      
  }

  if (cellFormat != NULL)  // !cellHidden)
  {
    if (subViewIndex)
      *subViewIndex = *subViewIndex + 1;

    // 12/08/92 register column heading cells
    if (heading)      // 22/02/94 move into cellFormat != NULL block: && !cellHidden)
      fMainView->RegisterDep(cellStruct->cell, subView /*, TRUE 17/09/92 */);
  }
}


// ------------------------------------------------------------------------
bool _TTableFormat::UpdateView(
     TCurrency currency, TSubView itsView, VPoint &itsLocation1, // VPoint &
     Fixed itsVSlop, TObject startBreak, TObject endBreak, bool invalidate, bool updateAll)
{
  int i;
  TTableStructure structure;
  TCellRect rowCells;
  TCellRect headCells;
  TTableUpdateViewData data;    // 12/08/92 struct for following 5 locals
//  long depth;
//  long base;
//  int lastRow;
//  VRect ruleWidths;
  bool includeHeadings;
  VPoint itsSize;
  int subViewIndex;
  Rect ruleRect;
  CntlAdornment borders;
  TRuleType ruleType;
  int hOffset;
  int hOffset1;
  int spBefore, spAfter;
  long rowDepth;  // 02/10/91 = 0;
  VRect areaToUpdate;
  VPoint itsLocation = itsLocation1;
  bool hasGrown;
  bool UpdateView_r = FALSE;

  // itsVSlop.v = 0;          // 17/06/91
  // itsVSlop.h = 0;
  ClearRect(areaToUpdate);
  GetViewBorders(startBreak, endBreak, ruleRect, spBefore, spAfter);
  structure = TTableStructure(GetStructureReadOnly(currency));
  structure->GetAllCells(rowCells);
#ifdef MATHS
  // 07/04/92 text ignores space above for widgets, so now tables can
  //          end up in-line the space frig needs to be done here too
  if (Curr_fType(structure->fParent) == kTextStruct)
  {
    spBefore = 0;
    spAfter = 0;
  }
#endif
  includeHeadings = FALSE;
  data.depth = fDepth;
  if ((startBreak != NULL) && (startBreak != TObject(-1)))
  {
    TTableBreak(startBreak)->GetDepths(data.base, data.depth);
    rowCells.startRow = TTableBreak(startBreak)->GetBreakRow();
    includeHeadings = TTableBreak(startBreak)->IncludeHeading();
  }
// 27/09/91  else
// 27/09/91    depth += spBefore;

  if (endBreak != NULL && endBreak != TObject(-1))
  {
    TTableBreak(endBreak)->GetDepths(data.depth, data.base);
    rowCells.endRow = TTableBreak(endBreak)->GetBreakRow() - 1;
  }
// 27/09/91  else
    data.depth += spAfter + spBefore;

  fMainView->RegisterDep(startBreak != NULL || endBreak != NULL ?
                                         currency : gNullCurrency, itsView);  // 17/09/92
  GetBorderInfo(data.ruleWidths, borders, ruleType);
  hOffset = FixRound(GetLeftMargin() - data.ruleWidths.left);
  itsLocation.h += ZoomInt(hOffset);

  itsView->Locate(itsLocation.h, itsLocation.v, invalidate);

  // 23/05/91 7 lines moved out of fHasChanged condition
  hOffset1 = FixRound(GetRightMargin() - data.ruleWidths.right);
  itsSize.h = GetWidth() - hOffset - hOffset1;   // 30/09/91 do not use zoomed value
                                     // 15/12/92 GetWidth for fWidth
  itsSize.v = data.depth;
  ZoomVPt(itsSize);
  hasGrown = !EqualVPt(itsSize, itsView->fSize);
               // 17/06/91 new test - 25/06/91 avoid corrupting fHasChanged
  itsView->Resize(itsSize.h, itsSize.v, invalidate);
  itsView->SetSpacing(spBefore, spAfter);        // 08/02/91

  // 04/12/92 a better solution may be for the view fields not to need resetting
  // when the structure is committed! However this should solve the problem of
  // deleting some rows, then pasting an incompatible selection, which commits
  // the structure (reducing the number of rows), but does not call Reformat to
  // update the view with the new start an end rows.
  if (TTableView(itsView)->fFirstRow != rowCells.startRow)
  {
    hasGrown = TRUE;                     // 14/09/92 check row start change
    TTableView(itsView)->fFirstRow = rowCells.startRow;
  }
  TTableView(itsView)->fLastRow = rowCells.endRow;

  if (fHasChanged || hasGrown)
  {
    // 02/10/91 only ruleWidths.left is used from here, so re-use top and bottom
    data.ruleWidths.bottom -= GetBorderThickness(adnLineBottom, borders, ruleType);
// 04/12/92    TTableView(itsView)->fFirstRow = rowCells.startRow;
// 04/12/92    TTableView(itsView)->fLastRow = rowCells.endRow;
    subViewIndex = 1;
    UpdateView_r = TRUE;       // 09/09/91
    data.depth = spBefore + ruleRect.top;
    data.lastRow = 0;
    rowDepth = 0;           // 08/02/91
    data.itsView = TTableView(itsView);  // 12/08/92
    data.itsView->fHeadingSuppressed = includeHeadings;      // 31/01/94 [21373]
    if (includeHeadings)
    {
      structure->GetAllCells(headCells);
      for (i = 1; i <= rowCells.startRow - 1; i++)
      {
        if (structure->IsHeadingRow(i))
        {
          headCells.startRow = i;
          headCells.endRow = i;
          structure->ForSelectedCellsDo(this, headCells,
                      (Action)_TTableFormat::CheckMakeSubviews,
                      &data, &subViewIndex, &areaToUpdate, &rowDepth, TRUE); // 12/08/92
        }
      }
    }

    structure->ForSelectedCellsDo(this, rowCells,
           (Action)_TTableFormat::CheckMakeSubviews,
           &data, &subViewIndex, &areaToUpdate, &rowDepth, FALSE); // 12/08/92 extra param
    for (i = itsView->fSubViews->GetSize(); i >= subViewIndex; i--)
    {
      itsView->fSubViews->At(i)->Free();
    }

    if (invalidate)
      itsView->InvalidVRect(areaToUpdate);
  }
  return UpdateView_r;        // 09/09/91 from FALSE;
}


// ------------------------------------------------------------------------
TTableView _TTableFormat::NewTableView(TView itsSuperView, TMainView itsMainView, TView itsNextView, VPoint &itsLocation, VPoint &itsSize, TCurrency itsCurrency, int itsSpBefore, int itsSpAfter)
{
  return new _TTableView(itsSuperView, itsMainView, itsNextView, itsLocation, itsSize, itsCurrency, itsSpBefore, itsSpAfter);
}


// ------------------------------------------------------------------------
TSubView _TTableFormat::MakeView(
        TCurrency currency, TViewId viewId, // Fixed itsSlop, VPoint &
        Fixed itsVSlop, TView itsSuperView, TView itsNextView,
        VPoint &itsLocation1, TObject startBreak, TObject endBreak)
{
  TSubView  MakeView_r;
  TTableStructure structure;
  VPoint itsSize;
  TTableUpdateViewData data;    // 12/08/92 struct for following 5 locals
  int i;
  bool includeHeadings;
  TCellRect rowCells;
  TCellRect headCells;
  int spBefore;
  int spAfter;
  Rect ruleRect;
  CntlAdornment borders;
  TRuleType ruleType;
  int hOffset;
  int hOffset1;
  VPoint itsLocation = itsLocation1;
  VRect aRect;
  long rowDepth;

  // itsVSlop.v = 0;                       // 17/06/91
  // itsVSlop.h = 0;
  GetViewBorders(startBreak, endBreak, ruleRect, spBefore, spAfter);
  structure = TTableStructure(GetStructureReadOnly(currency));
  structure->GetAllCells(rowCells);
#ifdef MATHS
  // 07/04/92 text ignores space above for widgets, so now tables can
  //          end up in-line the space frig needs to be done here too
  if (Curr_fType(structure->fParent) == kTextStruct)
  {
    spBefore = 0;
    spAfter = 0;
  }
#endif
  includeHeadings = FALSE;
  data.depth = fDepth;
  if ((startBreak != NULL) && (startBreak != TObject(-1)))
  {
    TTableBreak(startBreak)->GetDepths(data.base, data.depth);
    rowCells.startRow = TTableBreak(startBreak)->GetBreakRow();
    includeHeadings = TTableBreak(startBreak)->IncludeHeading();
  }

  if ((endBreak != NULL) && (endBreak != TObject(-1)))
  {
    TTableBreak(endBreak)->GetDepths(data.depth, data.base);
    rowCells.endRow = TTableBreak(endBreak)->GetBreakRow() - 1;
  }
  if (data.depth == 0)   // 01/06/93 making a view if only continuation notes present
    return NULL;

  data.depth += spAfter + spBefore;

  GetBorderInfo(data.ruleWidths, borders, ruleType);
  hOffset = FixRound(GetLeftMargin() - data.ruleWidths.left);
  hOffset1 = FixRound(GetRightMargin() - data.ruleWidths.right);
  SetVPt(itsSize, GetWidth() - hOffset - hOffset1, data.depth);
  ZoomVPt(itsSize);
  hOffset = ZoomInt(hOffset);
  itsLocation.h += hOffset;

  data.itsView = NewTableView(itsSuperView, fMainView, itsNextView, itsLocation, itsSize,
                                                              currency, spBefore, spAfter);
  itsSuperView->AddSubView(data.itsView);
  data.itsView->SetColNum(viewId.tag.fColNum);       // 25/04/91
  if (startBreak != NULL || endBreak != NULL)
    fMainView->RegisterDep(currency, data.itsView);  // 17/09/92
  MakeView_r = data.itsView;
  data.itsView->fFirstRow = rowCells.startRow;
  data.itsView->fLastRow = rowCells.endRow;
  data.itsView->fHeadingSuppressed = includeHeadings;      // 31/01/94 [21373]
  data.depth = spBefore + ruleRect.top;   // 07/08/95 now in CheckMakeSvs: + fRCBorderEnds.top;
  data.lastRow = 0;
  ClearRect(aRect);
  if (includeHeadings)
  {
    structure->GetAllCells(headCells);
    for (i = 1; i <= rowCells.startRow - 1; i++)
    {
      if (structure->IsHeadingRow(i))
      {
        headCells.startRow = i;
        headCells.endRow = i;
        structure->ForSelectedCellsDo(this, headCells,
              (Action)_TTableFormat::CheckMakeSubviews, &data, NULL,
              &aRect, &rowDepth, TRUE);
      }
    }
  }

  structure->ForSelectedCellsDo(this, rowCells,
              (Action)_TTableFormat::CheckMakeSubviews, &data, NULL,
              &aRect, &rowDepth, FALSE);
           // 07/08/95 (Action)_TTableFormat::MakeSubviews, &data, FALSE);
  return MakeView_r;
}


// ------------------------------------------------------------------------
_TTableBreak::_TTableBreak(int breakRow, int breakCol,
          TObject breakObj, int depthAbove, int headingNoteSize)
                        : ()
{
  fBreakRow = breakRow;
  fBreakCol = breakCol;                  // 06/05/93 [20853] for fn
  fBreakObject = breakObj;               // 01/06/93
  fHeadingNoteDepth = headingNoteSize;
  fIncludeHeading = TRUE;
  fViewDepthAbove = depthAbove;
#ifndef ZERO_OBJ
  fViewDepthBelow = 0;
#endif
}


// ------------------------------------------------------------------------
void _TTableBreak::Free(void)
// 01/06/93 new method
{
  FreeIfObject(fBreakObject);
  _TObject::Free();
}


// ------------------------------------------------------------------------
int _TTableBreak::GetBreakRow(void)
{
  return fBreakRow;
}


// ------------------------------------------------------------------------
int _TTableBreak::GetBreakCol(void)
// 06/05/93 [20853] for fn
{
  return fBreakCol;
}


// ------------------------------------------------------------------------
int _TTableBreak::GetHeadNoteDepth(void)
{
  return fHeadingNoteDepth;
}


// ------------------------------------------------------------------------
bool _TTableBreak::IncludeHeading(void)
{
  return fIncludeHeading;
}


// ------------------------------------------------------------------------
void _TTableBreak::SetIgnoreHeading(void)
{
  fIncludeHeading = FALSE;
}


// ------------------------------------------------------------------------
void _TTableBreak::SetDepthBelow(int depthBelow)
{
  fViewDepthBelow = depthBelow;
}


// ------------------------------------------------------------------------
void _TTableBreak::GetDepths(long &depthAbove, long &depthBelow)
{
  depthAbove = fViewDepthAbove;
  depthBelow = fViewDepthBelow;
}


// ------------------------------------------------------------------------
_TTableStructure::_TTableStructure(TDocument itsDocument
                              /*, TCurrency itsParent, TCurrency itsStyle*/)
                : (itsDocument, /* itsParent, itsStyle,*/ kTextStruct, kText)
{
}


// ------------------------------------------------------------------------
void _TTableStructure::InitNewStructure(TCurrency parent, TCurrency currency,
       TCurrency newStyle, TStyleTypes styleType, bool initialise, TStructureCmd command)
{
  TCellItem newCell;

  IStructure(/*fDocument,*/ parent, newStyle);
#ifdef MATHS
  if (command != NULL && command->fCmdNumber == cMatrix)   // 24/03/92
  {
    fCellType = kMathStruct;    // default cell type for a matrix
    fCellKind = kMaths;
  }
#endif
  if (initialise)   // 24/03/92
  {
    MakeNewCell(newCell, kColumnWise, currency);
    fNumberOfRows = 1;
    fNumberOfColumns = 1;
    InsertLast(&newCell);
    if (command != NULL)
      command->SetStart(newCell.cell);  // 24/03/92
  }
}


// ------------------------------------------------------------------------
void _TTableStructure::InsertInNewTable(PCellItem cellStruct, int row,
  int column, TCurrency subStruct, PCellRect coords, TStructure newStruct)
{
  TCurrency c;
  TStructure copyStruct;
  long pos;
  TStyleTypes newStructType = newStruct->GetKind();

  c = cellStruct->cell;
  if (!cellStruct->hidden)      // 07/01/94 [21219]
  {
    if (newStructType == kColumns)  // 07/01/94 [21221] leaving orphans
    {
      copyStruct = GetStructureReadWrite(c);
      copyStruct->fParent = subStruct;
    }
    if (coords->endRow == 0)    // 07/01/94 [21219] remember first no hidden cell
    {
      coords->endRow = row;
      coords->endCol = column;
    }
  }
  if (newStructType == kColumns)  // 07/01/94 [21221]
  {
    pos = PackTwoShorts(row - coords->startRow + 1, column - coords->startCol + 1);
    newStruct->InsertSubStructure(0, fDocument, subStruct, c, pos);
  }
}


// ------------------------------------------------------------------------
void _TTableStructure::NewStructure(TCurrency currency, TCursorNode anchor,
            TCursorNode activeEnd, TCurrency subStruct, TCurrency subStyle,
            TStyleTypes styleType, TNewStructureCmd command)
// 24/03/92   CmdNumber command, TCurrency &newStart, TCurrency &newEnd)
{
  TStructure newStruct, anchorStruct;
//  bool empty;
//  bool gone;
  TCellRect coords;
  TCellRect coords1;                 // 07/01/94 [21219] updated over hiddens
//  TSelShape selShape;
  int ch = chClear;                  // 24/02/92 chBackspace;   // 22/01/91
//  TCurrency oldCell;
  TCurrency newStart;
  bool notNewTable;
//  PCellItem cellItem;

  newStruct = GetStructureReadWrite(subStruct);
  anchorStruct = GetStructureReadOnly(TColCursorNode(anchor)->GetCell());
//  empty = (!anchor->Equal(activeEnd) || anchorStruct->IsEmpty());
  notNewTable = newStruct->GetKind() != kColumns;
  newStruct->InitNewStructure(currency, subStruct, subStyle,
            styleType, notNewTable /* 07/01/94 [21221] from FALSE */, command); // 24/03/92
  /* selShape = */ GetSelectedCells(coords, anchor, activeEnd);
  coords1 = coords;
  coords1.endRow = 0;
  ForSelectedCellsDo(this, coords,
                   (Action)_TTableStructure::InsertInNewTable,
                   subStruct, &coords1, newStruct);
  // 07/01/94 [21219]  oldCell = AtRowCol(coords1.startRow, coords1.startCol)->cell;
  newStart = (notNewTable ? subStruct : AtRowCol(coords1.endRow, coords1.endCol)->cell);
  Clear(anchor, activeEnd, kClearedByPaste/* 24/02/92 selShape == kWithinCell, gone */, ch);

  // 07/01/94 [21219]  AtRowCol(coords1.startRow, coords1.startCol)->cell = subStruct;
  AtRowCol(coords1.endRow, coords1.endCol)->cell = subStruct;
  ResetCursor(anchor,PackTwoShorts(coords.startRow, coords.startCol), FALSE, TRUE);
  ResetCursor(activeEnd, PackTwoShorts(coords.endRow, coords.endCol), TRUE, TRUE);
  // [21221] newStart = (newStruct->GetKind() == kColumns ? oldCell : subStruct);

  command->SetStart(newStart);
                    // 24/03/92 should get done in initnewstructure!!!
}


// ------------------------------------------------------------------------
//bool _TTableStructure::CanTypeFast(void)
//{
//  return FALSE;
//}


// ------------------------------------------------------------------------
// 17/7/92 new
TStructTypes _TTableStructure::GetPartStyleType(int part, Rect& custom)
{
  if (part == 1)
    return Curr_fType(fStyle);
  if (GetKind() == kMatrix)
    return kMathStyleStruct;
  if (part == kRowPart || part == kColPart)
    return kTextStyleStruct + 128;// 10/03/94 new frig to get kHasAdornment set in new style
  return kTextStyleStruct;
}

// ------------------------------------------------------------------------
TCurrency _TTableStructure::GetPartStyle(int part, Rect &custom1, TCurrency &itsChanges)
{
   // 27/01/94 [21357] ignore hidden rows and columns
  Rect custom;
  int *cellItem = &custom.top;   // i.e. startRow
  int *cellEnd;
  bool isRow = TRUE;

  MoveRect(custom, custom1);      // 11/03/94 do not corrupt input param

  if (part != kAllColsBody)       // 11/03/94 custom is zero rect for kAllColsBody!
  {
    if (part != kRowPart)
    {
      cellItem += 2;   // increment to startCol
      isRow = FALSE;
    }

    if (RowColHidden(*cellItem, isRow))  // 11/03/94 return no style for hidden row/col
    {
      itsChanges = gNullCurrency;
      return gNullCurrency;
    }
#ifdef TRACE
    // Assert(*cellItem == *(cellItem + 1), 814);
                               // 11/03/94 if never hit, loop below can be replaced
#endif
    for (cellEnd = cellItem + 2; cellEnd != cellItem; cellItem++)
      *cellItem = GetRowColNumber(*cellItem, isRow);  // adjust for hidden rows/cols
  }
  return _TStructure::GetPartStyle(part, custom, itsChanges);
}

// ------------------------------------------------------------------------
bool _TTableStructure::CallNextCell(TCurrency currency, int ch,
                                     TCursorNode cursorNode, bool fromRight)
{ // 22/6/92 new
  TStructure structure = GetStructureReadWrite(currency);
  long ip;
  int r, c;
  
  cursorNode->Collapse();
  // 15/7/92 changed to used ResetCursor & deal with spanners correctly
  FindCell(currency, r, c);
  ip = PackTwoShorts(r,c);
  ResetCursor(cursorNode, ip, fromRight, FALSE);
  // end change
  if (ch == chBackspace || ch == chFwdDelete)
    return structure->HandleKeypress(ch, cursorNode->GetNext());
  return TRUE;
}

// ------------------------------------------------------------------------
void _TTableStructure::HideRow(bool gone, int row)
{
  if (!gone) return;

  for (int c = 1; c <= fNumberOfColumns; c++)
  {
    PCellItem cellStruct = AtRowCol(row, c);

    cellStruct->hidden = TRUE;
    cellStruct->rowChange = TRUE;
  }
}

// ------------------------------------------------------------------------
bool _TTableStructure::EndOfTable(TCursorNode cursorNode, bool &gone, 
                                int &ch, int r1, int r)
{
  bool EndOfTable_r = FALSE;
  bool allGone = FALSE; // 14/7/92

  gone = FALSE;
  if (r1 != r)
  {
    gone = TRUE;
    int c;

    for (c = 1; c <= fNumberOfColumns; c++)
    {
      PCellItem p = AtRowCol(r1, c); // 14/7/92
      if (!p->hidden && !GetStructureReadOnly(p->cell)->IsEmpty()) // 14/7/92
      {
        gone = FALSE;
        break;
      }
    }
    // 14/7/92 new if stmt
    c = 1;
    if (r == 0)
    {
      EndOfTable_r = TRUE;
      r = fNumberOfRows;
      FindNextVisible(r, c, -1);
      allGone = (r == 1);
    }
    else if (r > fNumberOfRows)
    {
      EndOfTable_r = TRUE;
      r = 1;
      FindNextVisible(r, c, 1);
      allGone = (r == fNumberOfRows);
    }
    if (gone)
    {
      cursorNode->fCursor->fSelection->fReformatType = kSelSlow;

      if (ch == chBackspace)
      {
        if (allGone) // 14/7/92
          ch = chLeft;
      }
      else if (ch == chFwdDelete)
      {
        if (allGone) // 14/7/92
          ch = chRight;
      }
    }
    // 15/09/92 do outside gone test
    if (EndOfTable_r && !allGone) // 14/7/92
    {
      if (ch == chLeft)
        ch = chBackspace;
      else if (ch == chRight)
        ch = chFwdDelete;
    }
  }
  return EndOfTable_r;
}

// ------------------------------------------------------------------------
bool _TTableStructure::HandleKeypress(int ch, TCursorNode cursorNode)
{ // 22/6/92 rewritten to handle delete
  TCursorNode nextNode;
  TCurrency currency;
  bool gone;
  int r, r1, c;
  bool chBackLeft = (ch == chBackspace || ch == chLeft);

  if (!chBackLeft && ch != chFwdDelete && ch != chRight)
    return FALSE;
   
  nextNode = cursorNode->GetNext();
  currency = TColCursorNode(cursorNode)->GetCell();
  if (nextNode == NULL)
    return CallNextCell(currency, ch, cursorNode, chBackLeft); // 9/7/92

  FindCell(currency, r, c);
  r1 = r;

  // 15/12/93 [21146] new clause for table deleted from table
  if (Curr_fType(currency) != fCellType && ch >= chLeft)
  {
// Nice try, but the typing command may have got a cursor pointing at the deleted cell!
//    TStructure structure = GetStructureReadWrite(currency);
//    TCommand theCmd = TTextEvent(fDocument->fTextHandler)->fTypingCommand;
//    bool cmdState = theCmd->fCmdDone;
//    TDiscObject cellObject;
//    
//    theCmd->fCmdDone = TRUE;
//    GetStructureReadWrite(currency)->Commit(currency, NULL, NULL, theCmd, TRUE);
//    theCmd->fCmdDone = cmdState;

//    currency = fDocument->NewCurrency(fCellType, cellObject);
//    TStructure(cellObject)->InitNewStructure(cursorNode->fCurrency,
//                                 currency, gNullCurrency, fCellKind, TRUE, NULL);
//    AtRowCol(r, c)->cell = currency;
    Alert(phTableInTable, wr_wimp_EOK);
    return FALSE;
  }
  else if (chBackLeft)
  {
    if (c == 1)
    {
      r--;
      FindNextVisible(r, c, -1); // 30/6/92
      c = fNumberOfColumns;
    }
    else
      c--;
    if (r > 0) // 16/7/92
      c = FindMasterCell(r, c);
  }
  else
  { // 16/7/92 added loop for chFwdDelete || chRight
    bool found;
    do
      if (c >= fNumberOfColumns)
      {   
        found = TRUE;  
        r++;
        FindNextVisible(r, c, 1); // 30/6/92
        c = 1;
      }
      else
      {
        c += AtRowCol(r, c)->spanCount + 1;
        found = c <= fNumberOfColumns;
      }
    while (!found);
  }
  if (EndOfTable(cursorNode, gone, ch, r1, r))
  {
    if (GetStructureReadWrite(fParent)->HandleKeypress(ch, cursorNode->GetPrevious()))
    {
      HideRow(gone, r1);
      return TRUE;
    }
    return FALSE;
  }
  HideRow(gone, r1);
  currency = AtRowCol(r, c)->cell; // 16/7/92
  TColCursorNode(cursorNode)->SetCell(currency);
  return CallNextCell(currency, ch, cursorNode, chBackLeft); // 15/12/93
 // (ch == chLeft || ch == chBackspace));
}


// ------------------------------------------------------------------------
void _TTableStructure::GetControlChars(TStructure caller, TCursorNode cursor,
                                       ControlCharSet &controls)
{
// 21/11/91  if (caller != this)                              // 11/07/91
  controls &= ~((1 << chReturn) | (1 << chTab)); // 07/08/90
}


// ------------------------------------------------------------------------
void IUTableView(void)
{
}


// ------------------------------------------------------------------------
_TTableView::_TTableView(TView itsSuperView, TMainView itsMainView,
                         TView itsNextView, VPoint &itsLocation,
                         VPoint &itsSize, TCurrency itsCurrency,
                         int itsSpBefore, int itsSpAfter)
                       : (itsSuperView, itsMainView, TSubView(itsNextView),
                          itsLocation, itsSize, itsCurrency,
                          itsSpBefore, itsSpAfter)
{
}


// ------------------------------------------------------------------------
_TTableView::_TTableView(TDocument itsDoc, TView itsSuper, char* &itsPars)
                      : (itsDoc, itsSuper, itsPars)
{
}

// ------------------------------------------------------------------------
void _TTableView::DrawCellBorders(TView cellView, Rect *area,
   TTableStructure table, TTableFormat format, Rect *extent, int extentLeft,
   int *bottomArray)
// 23/01/91 new local method
{
  Rect cellExtent;
  int rn;
  int cn;
  int sc;
  Fixed offset;

  if (TSubView(cellView)->fAdornment != 0)
  {
    TTableFormatData *formatData;
    PColFormatData info;

// 01/10/91 no longer needed:    TSubView(cellView)->GetFrame(cellExtent);
    table->FindCell(TSubView(cellView)->fStructure, rn, cn);
    if (cn == 1)
      cellExtent.left = extent->left;
    else
    {
      info = format->InfoAt(cn);
      cellExtent.left = extentLeft +
        FixRound(ZoomFixed(format->InfoAt(cn - 1)->columnRtEdge +
          GetBorderThickness(adnLineLeft, info->adornment, info->ruleType)));
          // for FixRound(ZoomFixed(format->GetColLtEdge(cn))) + extentLeft);
    }
    sc = table->AtRowCol(rn, cn)->spanCount;
    if (cn + sc == format->fNumberOfColumns)
      cellExtent.right = extent->right;
    else
    {
      info = format->InfoAt(cn + sc);
      offset = ZoomFixed(format->GetColRtEdge(cn + sc) -
         GetBorderThickness(adnLineRight, info->adornment, info->ruleType));
                  // 16/07/91  GetBorderThickness for  GetBorderWidth
      cellExtent.right = FixRound(offset) + extentLeft;
    }
    formatData = PTableFormatData(format->At(rn));
/*
    cellExtent.top += ZoomInt(formatData->topBorder); // 01/10/91 add in row border depth
    cellExtent.bottom -= ZoomInt(formatData->btmBorder); // 01/10/91 add in row border depth
    if (rn == fFirstRow)
      cellExtent.top = extent->top;
    else
      cellExtent.top = cellExtent.top - ZoomInt(formatData->topBorder -
        FixRound(GetBorderThickness(adnLineTop, formatData->adornment,
          formatData->ruleType)));
*/
//    if (rn == fFirstRow)
//      cellExtent.top = extent->top;
//    else
      cellExtent.top = bottomArray[rn - 1] +
         ZoomInt(FixRound(GetBorderThickness(adnLineTop,
                                          formatData->adornment, formatData->ruleType)));
    if (bottomArray[rn] == bottomArray[fLastRow]) // 24/11/92 rn == fLastRow fails on commit
      cellExtent.bottom = extent->bottom;
    else
      cellExtent.bottom = bottomArray[rn] -
          ZoomInt(FixRound(GetBorderThickness(adnLineBottom,
                                          formatData->adornment, formatData->ruleType)));
/*
    if (rn == fLastRow)
      cellExtent.bottom = extent->bottom;
    else
      cellExtent.bottom = cellExtent.bottom + ZoomInt(formatData->btmBorder -
        FixRound(GetBorderThickness(adnLineBottom, formatData->adornment,
          formatData->ruleType)));
*/
    fRuleType = TSubView(cellView)->fRuleType;
    fAdornment = TSubView(cellView)->fAdornment;
    DrawBorders(*area, cellExtent);
/*
    cellExtent.left = extent->left + FixRound(offset);
    sc = table->AtRowCol(rn, cn)->spanCount;
    info = format->InfoAt(cn + sc);
    offset = format->GetColRtEdge(cn + sc) -
            GetBorderWidth(adnLineRight, info->adornment, info->ruleType);
    offset = ZoomFixed(offset);
    cellExtent.right = extent->left + FixRound(offset);
    fRuleType = TSubView(cellView)->fRuleType;
    fAdornment = TSubView(cellView)->fAdornment;
    DrawBorders(*area, cellExtent);
*/
  }
}

// ------------------------------------------------------------------------
void _TTableView::Draw(Rect &area)
{
  _TColumnsView::Draw(area);
}


// ------------------------------------------------------------------------
void _TTableView::DrawAdornment(Rect &area)
{
  // 03/07/92 moved from Draw
  TRuleType saveRuleType;
  CntlAdornment saveAdornment;
  Rect extent;
  int extentLeft;
  TTableStructure table;
  TTableFormat format;
  VRect ruleWidths;
  CntlAdornment ruleBorders;
  TRuleType ruleType;
  int depth;
  int *bottomArray;
  bool firstRowDone;           // 24/11/92
  int lastRow;                 // 24/11/92

  _TColumnsView::DrawAdornment(area);

  firstRowDone = FALSE;
  table = TTableStructure(GetStructureReadOnly(fStructure));
  format = TTableFormat(GetMyFormatReadOnly());
  FailNIL(bottomArray = (int *)NewHandle((format->fSize + 1) * sizeof(int)));   // 01/10/91
  GetQDExtent(extent);
  format->GetBorderInfo(ruleWidths, ruleBorders, ruleType);
  extentLeft = extent.left + FixRound(ZoomInt(ruleWidths.left));
  depth =  FixRound(ZoomInt(ruleWidths.top)) + fSpBefore;
  // 16/07/91 use line thicknesses rather than line + inset for drawing
  GetBorderThicknessRect(ruleWidths, ruleBorders, ruleType);
  ZoomVRect(ruleWidths);
  extent.left += FixRound(ruleWidths.left);
  extent.right -= FixRound(ruleWidths.right);
  depth = // 13/05/96 ??? FixRound(ruleWidths.top) + fSpBefore
             depth + ZoomInt(format->fRCBorderEnds.top);
  extent.top += depth;           // 11/03/94 [21452] move down by borderEnds
  extent.bottom -= FixRound(ruleWidths.bottom) + fSpAfter; // 16/07/91
  bottomArray[0] = extent.top;   // 01/10/91
  saveRuleType = fRuleType;
  saveAdornment = fAdornment;

  // 24/11/92 get real last row in view
  for (lastRow = Min(format->fSize, fLastRow); lastRow > 1; lastRow--)
    if (!table->AtRowCol(lastRow, 1)->hidden)
      break;

  for (int rn = 1; rn <= format->fSize; rn++)
  {
    if ((rn >= fFirstRow && rn <= fLastRow) || (table->IsHeadingRow(rn) && fHeadingSuppressed))
                          // 31/01/94 [21373] only include headings if present in view
    {
      Rect rowExtent;
      TRuleType ruleType;
      CntlAdornment adornment;
      int rowDepth;
      PTableFormatData data = PTableFormatData(format->At(rn));

      ruleType = data->ruleType;
      adornment = data->adornment;
      rowDepth = ZoomInt(data->topBorder + data->ascent + data->descent + data->btmBorder);

      // 24/11/92 need to extend the borders up and down when first and last in the view
      if (!firstRowDone)
      {
        bottomArray[rn - 1] = extent.top;
      }
      firstRowDone = TRUE;
      depth += rowDepth;

      if (adornment != 0)
      {
        MoveRect(rowExtent, extent);
        rowExtent.top = bottomArray[rn - 1];  // depth;   // 22/01/91 from += topBorder
        if (rn != lastRow)             // 24/11/92 test for last
          rowExtent.bottom = depth;    // rowExtent.top + rowDepth;
        fRuleType = ruleType;
        fAdornment = adornment;
        DrawBorders(area, rowExtent);
      }
    }
    bottomArray[rn] = depth;   // 01/10/91
  }
  // 23/01/91 call added
  EachSubview(this, (DoToSubView)_TTableView::DrawCellBorders, &area,
               table, format, &extent, extentLeft, bottomArray); // 16/07/91 extent.left);
  DisposHandle(bottomArray);   // 01/10/91
  fRuleType = saveRuleType;
  fAdornment = saveAdornment;
// end of Draw
}


// ------------------------------------------------------------------------
void _TTableView::DoSetupMenus(void)
{
  bool isAllSelected;
  TCursorNode anchor;
  TCursorNode activeEnd;
  TStructure table;
  TSelection selection;

  _TColumnsView::DoSetupMenus();

  table = GetStructureReadOnly(fStructure);
  selection = TTextDocument(fDocument)->GetNewSelection();
  selection->GetNodes(fStructure, anchor, activeEnd);
  isAllSelected = table->AllSelected(fStructure, anchor, activeEnd);
  EnableCheck(cTableHeading, TRUE, fHeadingState);
  EnableCmd(cTableNote);
  Enable(cSection, isAllSelected);
  DisableCmd(cSubList);
  DisableCmd(cSubSection);
  Enable(cList, isAllSelected);
  EnableCmd(cTable);
  Enable(cFigure, isAllSelected);
  DisableCmd(cParagraph);
  EnableCmd(cPicture);       // 19/09/90 from FALSE
}


// ------------------------------------------------------------------------
TCommand _TTableView::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
  if (aCmdNumber == cTableHeading)
    return new _TTableHeadingCommand(TTextDocument(fDocument), fMainView,
                                                 fStructure, fHeadingState);

  return _TColumnsView::DoMenuCommand(info, aCmdNumber);
}


// ------------------------------------------------------------------------
TCommand _TTableView::DoKeyCommand(int ch, EventInfo &info)
{
  if (ch == chReturn || ch == chTab)
    return DoMenuCommand(info, ch == chReturn? cKeyAddRow : cKeyAddColumn);

  return _TColumnsView::DoKeyCommand(ch, info);
}


// ------------------------------------------------------------------------
void _TTableView::DoHighlight(TSubView view, TTableStructure table,
     Rect* cellRect, bool redraw, TCursorNode cursor1, TCursorNode cursor2)
{
  Point cellPt;

  table->FindCell(view->fStructure, cellPt.v, cellPt.h);

  if (cellPt.h < cellRect->left || cellPt.h > cellRect->right ||
      cellPt.v < cellRect->top  || cellPt.v > cellRect->bottom)
  {
    if (view->Selected())
      view->SetHighlight(TCursorNode(-1), 0, redraw, FALSE);
  }
  else
  {
    if (cursor1 != NULL && cursor1->fCurrency == view->fStructure &&
        cursor2 != NULL && cursor2->fCurrency == view->fStructure)
      view->SetHighlight(cursor1, cursor2, redraw, FALSE);
    else
      view->SetHighlight(NULL, NULL, redraw, FALSE);
  }
}

#ifdef TRUE
// ------------------------------------------------------------------------
static bool ContainsCurrency(TObject null, TCursorNode node, TCurrency currency)
{
  return currency == node->fCurrency;
}

// ------------------------------------------------------------------------
void _TTableView::SetHighlight(TCursorNode anchor, TCursorNode activeEnd,
                                              bool redraw, bool noteSelection)
{
  if (fSubViews != NULL)
  {
    TTableStructure table;
    bool selected;
    TCursorNode cursor1 = NULL;
    TCursorNode cursor2 = NULL;
    Rect cellRect;

    table = TTableStructure(GetStructureReadOnly(fStructure));

    if (anchor == TCursorNode(-1) || activeEnd == TCursorNode(-1)) // 20/7/92
    {
      ClearRect(cellRect);
      selected = FALSE;
    }
    else
    {
#ifdef NEVER
      TSelection sel = TTextDocument(fDocument)->GetNewSelection();
      TLevelInfo levelInfo;
      int part;

      if (sel->FindLevelInfo(fStructure, part, levelInfo) == 0)
      {
        cellRect.top = levelInfo.fCustom.top/*startRow*/;
        cellRect.bottom = levelInfo.fCustom.left/*endRow*/;
        cellRect.left = levelInfo.fCustom.bottom/*startCol*/;
        cellRect.right = levelInfo.fCustom.right/*endCol*/;
#ifdef TRACE
        if (levelInfo.fPart == kRowPart)
          SysBeep(0);      // FindLevelInfo never finds rows?
        else if (part == kColPart)
        {
          if (cellRect.top != 1 || cellRect.bottom != table->fNumberOfRows)
            SysBeep(0);
        }
#endif
      }
      else
#endif
      {
        TCursorNode tableCursor1;
        TCursorNode tableCursor2;
        int t;

        SetRect(cellRect, 1, 1, table->fNumberOfColumns, table->fNumberOfRows); // 23/7/92
        // sel->GetNodes(fStructure, tableCursor1, tableCursor2);
        tableCursor1 = TCursorNode(fMainView->fPages->fAnchor->fCursor->
                                LastThat(NULL, (TestObject)ContainsCurrency, fStructure));
        if (tableCursor1 != NULL)
          TColCursorNode(tableCursor1)->GetRowCol(table, cellRect.top, cellRect.left);
#ifdef TRACE
        Assert(anchor == tableCursor1 || anchor == NULL, 932);
#endif
        tableCursor2 = TCursorNode(fMainView->fPages->fActiveEnd->fCursor->
                                LastThat(NULL, (TestObject)ContainsCurrency, fStructure));
        if (tableCursor2 != NULL)
          TColCursorNode(tableCursor2)->GetRowCol(table, cellRect.bottom, cellRect.right);
#ifdef TRACE
        Assert(activeEnd == tableCursor2 || activeEnd == NULL, 933);
#endif
        if (cellRect.left > cellRect.right)
        {
          // switch round
          t = cellRect.left;
          cellRect.left = cellRect.right;
          cellRect.right = t;
        }
        if (cellRect.top > cellRect.bottom)
        {
          // switch round
          t = cellRect.top;
          cellRect.top = cellRect.bottom;
          cellRect.bottom = t;
        }
      }
      if (anchor != NULL)
        cursor1 = anchor->GetNext();
      if (activeEnd != NULL)
        cursor2 = activeEnd->GetNext();
      selected = TRUE;
    }

    EachSubview(this, (DoToSubView)_TTableView::DoHighlight, table, &cellRect, redraw,
                                                              cursor1, cursor2);
    Select(selected);
  }
}
#else
// ------------------------------------------------------------------------
static bool OwnsTableCursor(TObject null, TSubView view,
                     int* lastIndex, TCursorNode cursor)
{
  TSubView subView;

  *lastIndex = *lastIndex + 1;
  return view->ContainsCursor(cursor, cursor, subView);
}


// ------------------------------------------------------------------------
void _TTableView::SetHighlight(TCursorNode anchor, TCursorNode activeEnd,
                                              bool redraw, bool noteSelection)
{
  Rect cellRect;
  Rect cellRect1;
  int firstIndex;
  int lastIndex;
  TSubView view;
  TCursorNode cursor;
  TCursorNode cursor1, cursor2;
  bool cleared;
  TTableStructure table;
  int t;
  int spanOffset1 = 0;
  int spanOffset2 = 0;

  cleared = FALSE;
  if (fSubViews == NULL)
    return;

  table = TTableStructure(GetStructureReadOnly(fStructure));
  // 23/7/92 removed - not quite right
  // 11/09/91 start split column highlight problem
#ifdef NEVER
  int tp,l,b,r;

  sel->GetNodes(fStructure, cursor1, cursor2);

  if (cursor1 == NULL)
  {
    tp = 1;
    l = 1;
  }
  else
    TColCursorNode(cursor1)->GetRowCol(table, tp, l);

  if (cursor2 == NULL)
  {
    b = table->fNumberOfRows;
    r = table->fNumberOfColumns;
  }
  else
    TColCursorNode(cursor2)->GetRowCol(table, b, r);

  cellRect1.top = Min(tp, b);
  cellRect1.bottom = Max(tp, b);
  cellRect1.left = Min(r, l);
  cellRect1.right = Max(r, l);
#endif
  // 11/09/91 end split column highlight problem
  SetRect(cellRect1, 1, 1, table->fNumberOfColumns, table->fNumberOfRows); // 23/7/92
  cursor1 = NULL;
  cursor2 = NULL;
  if (anchor == NULL)
    firstIndex = 1;
  else if (anchor == TCursorNode(-1))
  {
    firstIndex = CountSubViews() + 1;
    cleared = TRUE;
  }
  else
  {
    TColCursorNode(anchor)->GetRowCol(table, cellRect1.top, cellRect1.left); // 23/7/92
    cursor = anchor->GetNext();
    spanOffset1 = TColCursorNode(anchor)->GetSpanOffset();    // 27/06/91
    lastIndex = 0;
    view = TSubView(FirstSubViewThat(NULL, (TestSubView)OwnsTableCursor, &lastIndex, cursor));
    Assert(view, kNoSubView);
    firstIndex = lastIndex;
    cursor1 = cursor;
  }

  if (activeEnd == NULL)
    lastIndex = CountSubViews();
  else if (activeEnd == TCursorNode(-1))
  {
    lastIndex = 1;
    cleared = TRUE;
  }
  else
  {
    TColCursorNode(activeEnd)->GetRowCol(table, cellRect1.bottom, cellRect1.right); // 23/7/92
    cursor = activeEnd->GetNext();
    spanOffset2 = TColCursorNode(activeEnd)->GetSpanOffset();    // 27/06/91
    if (anchor == activeEnd)
      lastIndex = firstIndex;
    else
    {
      lastIndex = 0;
      view = TSubView(FirstSubViewThat(NULL, (TestSubView)OwnsTableCursor, &lastIndex, cursor));
      Assert(view, kNoSubView);
    }
    cursor2 = cursor;
  }

  if (anchor == TCursorNode(-1) || activeEnd == TCursorNode(-1)) // 20/7/92
    ClearRect(cellRect);
  else
  { 
    view = SubViewAt(firstIndex);
    table->FindCell(view->fStructure, cellRect.top, cellRect.left);
    cellRect.left += spanOffset1;                             // 27/06/91
    view = SubViewAt(lastIndex);
    table->FindCell(view->fStructure, cellRect.bottom, cellRect.right);
    if (activeEnd == NULL)
      cellRect.right = cellRect1.right;              // 02/07/96 for spanned btm/left cell
    else
      cellRect.right += spanOffset2;                 // 27/06/91
// 11/09/91 start pt 2 of split column highlight problem
    if (cellRect1.left > cellRect.left)
      cellRect.left = cellRect1.left;
    if (cellRect1.right < cellRect.right)
      cellRect.right = cellRect1.right;
    if (cellRect1.top > cellRect.top)
      cellRect.top = cellRect1.top;
    if (cellRect1.bottom < cellRect.bottom)
      cellRect.bottom = cellRect1.bottom;
// 11/09/91 end pt 2 of split column highlight problem
    if (cellRect.left > cellRect.right)
    {
      t = cellRect.left;
      cellRect.left = cellRect.right;
      cellRect.right = t;
    }
    if (cellRect.top > cellRect.bottom)
    {
      t = cellRect.top;
      cellRect.top = cellRect.bottom;
      cellRect.bottom = t;
    }
  }

  EachSubview(this, (DoToSubView)_TTableView::DoHighlight, table, &cellRect, redraw, cursor1, cursor2);
  Select(!cleared);
}
#endif

/* ------------------------------------------------------------------------
// 12/01/92 see _TSubView::HasCursor
static bool HasTableCursor(TObject null, TSubView view, TCursorNode subCursor, TCursorNode target, TSubView* subView)
{
  return view->ContainsCursor(subCursor, target, *subView);
}
*/

#ifdef TRACE
// ------------------------------------------------------------------------
bool _TTableView::CanAdornSelf()
// 22/01/91 new proc
{
  return FALSE;
}

// ------------------------------------------------------------------------
void _TTableView::ScrollCursorIntoView(TCursorNode cursor)
{
  // does not scroll
}
#endif

// ------------------------------------------------------------------------
bool _TTableView::ContainsCursor(TCursorNode cursor, TCursorNode target,
                                 TSubView &subView)
{
  bool  ContainsCursor_r;
  TCursorNode subCursor;
  TTableStructure tableStruct;

  subView = 0;
  ContainsCursor_r = FALSE;
  if (fStructure == cursor->fCurrency)
  {
    tableStruct = TTableStructure(GetStructureReadOnly(cursor->fCurrency));
    if (tableStruct->IsHeadingRow(TColCursorNode(cursor)->GetRow(tableStruct)))
    {
      subView = 0;
      ContainsCursor_r = FALSE;
      if (fStructure == cursor->fCurrency)
      {
        if ((fFirstRow <= TColCursorNode(cursor)->fLastRow) && (fLastRow >= TColCursorNode(cursor)->fLastRow))
        {
          cursor->fIdentifier = fIdentifier;
          subCursor = cursor->GetNext();
          ContainsCursor_r = (subCursor == NULL || FirstSubViewThat(this, (TestSubView)_TSubView::HasCursor, subCursor, target, &subView) != 0);
          if (cursor == target)
            subView = this;
        }
      }
    }
    else
      ContainsCursor_r = _TColumnsView::ContainsCursor(cursor, target, subView);
  }

  return ContainsCursor_r;
}


// ------------------------------------------------------------------------
void _TTableView::GetTrackLimits(TSubView subView, VRect &picLimits,
                                          TwoBools repositionInText)
{
  StdGetTrackLimits(subView, picLimits, repositionInText);
}



// ------------------------------------------------------------------------
_TTableHeadingCommand::_TTableHeadingCommand(TTextDocument itsDocument,
           TMainView itsMainView, TCurrency itsCurrency, bool headingState)
         : (cTableHeading, itsDocument, NULL, NULL)
{
#ifndef ZERO_OBJ
  fSelection = 0;
#endif
  fNewSetting = !headingState;
  fMainView = itsMainView;
  fCurrency = itsCurrency;
}


// ------------------------------------------------------------------------
void _TTableHeadingCommand::SetHeading(PCellItem cellStruct, int row, int column)
{
  if (!cellStruct->hidden)
  {
    if (fCmdDone)
    {
      cellStruct->heading = cellStruct->undoState;
    }
    else
    {
      cellStruct->undoState = cellStruct->heading;
      cellStruct->heading = fNewSetting;
    }
  }
}


// ------------------------------------------------------------------------
void _TTableHeadingCommand::DoIt(void)
{
  TCursorNode anchorNode;
  TCursorNode activeNode;
  TTableStructure table;
  TCellRect cellCoords;
  TSelShape ignore;

  if (fSelection == 0)
    fSelection = TTextDocument(fChangedDocument)->GetSelection(TRUE);
  TTextDocument(fChangedDocument)->HighlightSelection(HLOff, TRUE);
  fSelection->GetNodes(fCurrency, anchorNode, activeNode);
// 27/06/91  TColCursorNode(anchorNode)->SetEditAction(cTableHeading);
  table = TTableStructure(TTextDocument(fChangedDocument)->GetStructureReadWrite(fCurrency));
  ignore = table->GetSelectedCells(cellCoords, anchorNode, activeNode);

  cellCoords.startCol = 1;
  cellCoords.endCol = 1;

  table->ForSelectedCellsDo(this, cellCoords, (Action)_TTableHeadingCommand::SetHeading);

  TTextDocument(fChangedDocument)->Reformat();
  TTextDocument(fChangedDocument)->ScrollSelectionIntoView();
  TTextDocument(fChangedDocument)->HighlightSelection(HLOn, TRUE);
  TTextDocument(fChangedDocument)->fSelection->fChanged = TRUE;
  TTextDocument(fChangedDocument)->SetCurrentStyle();

  FailSpaceIsLow();
}


// ------------------------------------------------------------------------
void _TTableHeadingCommand::UndoIt(void)
{
   _TTableHeadingCommand::DoIt();
}


// ------------------------------------------------------------------------
void _TTableHeadingCommand::RedoIt(void)
{
   _TTableHeadingCommand::DoIt();
}
