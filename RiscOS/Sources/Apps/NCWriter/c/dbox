/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Modified for use on the Network Computer */

/* Title: > c.dbox
 * Purpose: System-independent dialog boxes.
 * History: IDJ: 05-Feb-92: prepared for source release
 *
 */

#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <limits.h>
#include "swis.h"

#include "trace.h"
#include "werr.h"
#include "os.h"
#include "akbd.h"
#include "wimp.h"
#include "wimpt.h"
#include "win.h"
#include "menu.h"
#include "event.h"
#include "dbox.h"
#include "alarm.h"

#include "CToolBox.h"
#include "PackTempl.h"

#ifdef NETWP
extern struct {
    int top;
    int left;
    int bottom;
    int right; } gSafeArea;
#endif
extern wr_os_error *FontFind(int *handle, char *name, int xsize, int ysize);
extern void FontLose(int handle);

sqTemplData gSqTemplates;
#ifdef TABLES
char gSmartValString[32] = "Pptr_write;r0;A~";
#endif
bool SendHelpReply(wr_wimp_msgstr *msg);

typedef struct template_font
{
  int sizeX;
  int sizeY;
  char fontName[40];
} template_font;

typedef struct wr_dbox__str {
  struct wr_dbox__str *next;  /* if user wants to link dboxes into a list */
  wr_wimp_w w;                /* only used in live dialog boxes */
  int posatcaret;          /* Every time it is shown, it appears "near" the
                            * caret. 
                            */
  int showing;
  wr_wimp_caretstr caretstr;   /* save between fillin's. */
  wr_dbox_handler_proc eventproc;
  void *eventprochandle;
  wr_dbox_raw_handler_proc raweventproc;
  void *raweventprochandle;
  
  wr_dbox_field field;     /* button last pressed */
  int fieldwaiting;     /* a button waiting to be picked up */
  int eventdepth;       /* for delaying disposal */
  int disposepending;
  int staticdlog;       /* RSP [20819] - TRUE if not hanging off menu tree */

  char name[12];
  char *workspace;
  int workspacesize;
  wr_wimp_wind window;
  /* any icons follow directly after this. */
} wr_dbox__str;
/* Abstraction: a dbox is really a wr_dbox__str*. */


/* -------- Miscellaneous. -------- */

/* 14/11/91 release font handles */
static void ReleaseFont(wr_wimp_iconflags flags)
{
  if ((flags & 0x040) != 0)     /* contains anti-aliased font */
    /* wr_wimpt_noerr(font_lose((font)(((unsigned)flags) >> 24))); */
    FontLose(((unsigned)flags) >> 24);
}

static void wr_dbox__dispose(dbox d)
{
  int i;

  ReleaseFont(d->window.titleflags);
  for (i = 0; i < d->window.nicons; i++)
    ReleaseFont(((wr_wimp_icon *)(&d->window + 1))[i].flags);
  if (d->workspacesize != 0)
    DisposIfHandle(d->workspace);
  DisposIfHandle(d);
}

static void wr_dbox__dodispose(dbox d)
{
  if (d->w != -1)     /* 28/06/93 not yet created */
  {
    wr_win_register_event_handler(d->w, 0, 0);
    wr_event_attachmenu(d->w, 0, 0, 0);
    if (d->showing)
      wr_win_activedec();
    wr_wimpt_noerr(wr_wimp_delete_wind(d->w));
  }
  wr_dbox__dispose(d);
}


/* -------- Finding Icons. -------- */

/* useful icon flag masks, for searching for specific icon types */
#define BUTTON_IFLAGS (15 * wr_wimp_IBTYPE)
#define wr_wimp_BWRITABLEDRAG 14
#define WRITABLE_IFLAGS ((wr_wimp_iconflags)(wr_wimp_BWRITABLEDRAG * wr_wimp_IBTYPE))
/* RSP #define WRITABLE_IFLAGS (wr_wimp_BWRITABLE * wr_wimp_IBTYPE) */
#define CLICK_IFLAGS ((wr_wimp_iconflags)(wr_wimp_BCLICKDEBOUNCE * wr_wimp_IBTYPE))
#define AUTO_IFLAGS (wr_wimp_BCLICKAUTO * wr_wimp_IBTYPE)
#define RELEASE_IFLAGS (wr_wimp_BSELREL * wr_wimp_IBTYPE)
#define ONOFF_IFLAGS (wr_wimp_BSELDOUBLE * wr_wimp_IBTYPE)
#define ONOFF2_IFLAGS (wr_wimp_BCLICKSEL * wr_wimp_IBTYPE)
#define MENU_IFLAGS (wr_wimp_BSELNOTIFY * wr_wimp_IBTYPE)

static int wr_dbox__findselectableicon(dbox d, wr_wimp_iconflags mask, wr_wimp_iconflags settings, wr_wimp_i *j)
/* Rather like SWI WhichIcon, but only finds the first. Returns 0 if not
found. */
{
  for (; (*j)<d->window.nicons; (*j)++)
  {
    /* next 4 lines - RSP */
    wr_wimp_icon i;
    wr_wimpt_noerr(wr_wimp_get_icon_info(d->w, *j, &i));
    if ((i.flags & (mask | wr_wimp_INOSELECT)) == settings)
      return(1);
  };
  return(0);
}

static int wr_dbox__findselectableiconbefore(dbox d,
  wr_wimp_iconflags mask, wr_wimp_iconflags settings, wr_wimp_i *j)
/* Does not look at the current icon. */
{
  while ((*j) != 0)
  {
    /* next 4 lines - RSP */
    wr_wimp_icon i;
    wr_wimpt_noerr(wr_wimp_get_icon_info(d->w, (--(*j)), &i));
    if ((i.flags & (mask | wr_wimp_INOSELECT)) == settings)
      return(1);
  };
  return(0);
}

/* -------- Icons and Fields. -------- */

static wr_wimp_i wr_dbox__fieldtoicon(wr_dbox_field f)
{
  return(f);
}

/* static 31/05/92 */
wr_wimp_icon *wr_dbox__iconhandletoptr(dbox d, wr_wimp_i i)
{
  return(((wr_wimp_icon*) (&d->window + 1)) + i);
}

static wr_wimp_icon *wr_dbox__fieldtoiconptr(dbox d, wr_dbox_field f)
{
  return(wr_dbox__iconhandletoptr(d, wr_dbox__fieldtoicon(f)));
}

static wr_wimp_iconflags wr_dbox__ibutflags(wr_wimp_icon *i)
{
  return (wr_wimp_iconflags)(i->flags & BUTTON_IFLAGS);
}

static wr_dbox_fieldtype wr_dbox__iconfieldtype(wr_wimp_icon *i)
{
  switch (wr_dbox__ibutflags(i)) {
  case AUTO_IFLAGS:
  case RELEASE_IFLAGS:
  case CLICK_IFLAGS:
  case MENU_IFLAGS:
    return(wr_dbox_FACTION);
  case ONOFF_IFLAGS:
  case ONOFF2_IFLAGS:
/*    return(wr_dbox_FONOFF);  RSP 24/05/91 - needs to tell us too */
    return(wr_dbox_FACTION);
  case WRITABLE_IFLAGS:
    return(wr_dbox_FINPUT);
  default:
    return(wr_dbox_FOUTPUT);
  };
}

/* static int wr_dbox__min(int a, int b) {if (a<b) return(a); else return(b);} */

#ifdef NEVER
void wr_dbox_fadefield (dbox d, wr_dbox_field f)
{

  /* set shaded bit in iconflags */
  wr_wimpt_noerr(wr_wimp_set_icon_state (d->w, wr_dbox__fieldtoicon(f),
                                   wr_wimp_INOSELECT, wr_wimp_INOSELECT));
}

void  wr_dbox_unfadefield (dbox d, wr_dbox_field f)
{

  /* unset shaded bit in iconflags */
  wr_wimpt_noerr(wr_wimp_set_icon_state(d->w, wr_dbox__fieldtoicon(f), 
                                  0, wr_wimp_INOSELECT));
}
#endif

void wr_dbox_setfield(dbox d, wr_dbox_field f, char *value)
{
  wr_wimp_icon *i = wr_dbox__fieldtoiconptr(d, f);

  if ((i->flags & wr_wimp_ITEXT) == 0)
  {
    /* Allowed, has no effect */
  }
  else
  {
    wr_wimp_caretstr caret;

    if ((i->flags & wr_wimp_INDIRECT) != 0)
    {
      strcpyn(i->data.indirecttext.buffer, value, i->data.indirecttext.bufflen - 1);
      /* memcpy(i->data.indirecttext.buffer, value,
        wr_dbox__min(i->data.indirecttext.bufflen - 1,
                  strlen(value) + 1));
      i->data.indirecttext.buffer[i->data.indirecttext.bufflen - 1] = 0; */
    }
    else
    {
      memcpy(i->data.text, value, 12);
      i->data.text[11] = 0;
    };

    /* ensure that the caret moves correctly if it's in this icon */

    wr_wimpt_noerr(wr_wimp_get_caret_pos(&caret)) ;

    if (caret.w == d->w && caret.i == wr_dbox__fieldtoicon(f))
    {
     int l = strlen((i->flags & wr_wimp_INDIRECT) != 0 ?
                       i->data.indirecttext.buffer : i->data.text) ;

     if (caret.index > l) caret.index = l ;
     caret.height = caret.x = caret.y -1 ;   /* calc from index */
     wr_wimpt_noerr(wr_wimp_set_caret_pos(&caret)) ;
    }

    /* prod it, to cause redraw */
    wr_wimpt_noerr(wr_wimp_set_icon_state(d->w, wr_dbox__fieldtoicon(f),
                            (wr_wimp_iconflags)0, (wr_wimp_iconflags)0));
  };
}

void wr_dbox_getfield(dbox d, wr_dbox_field f, char *buffer, int size)
{
  wr_wimp_icon *i = wr_dbox__fieldtoiconptr(d, f);
  int j = 0;
  char *from;
  if ((i->flags & wr_wimp_ITEXT) == 0) 
  {
    tracef0("GetField of non-text.");
    /* Allowed, returns "". */
  } 
  else 
  {
    if ((i->flags & wr_wimp_INDIRECT) != 0) 
    {
      while (i->data.indirecttext.buffer[j] >= 32) {j++;};
      from = i->data.indirecttext.buffer;
    } 
    else 
    {
      while (i->data.text[j] >= 32 && j < 11) {j++;};
      from = &i->data.text[0];
    }
    if (j > size) j = size;
    tracef3("GetField copies %i from %i to %i.\n",
      j, (int) from, (int) buffer);
    (void) memcpy(buffer, from, j);
  }
  buffer[j] = 0;
  tracef1("GetField returns %s.\n", (int) buffer);
}

static int wr_dbox__fieldlength(dbox d, wr_dbox_field f)
{
  char a[255];
  wr_dbox_getfield((dbox) d, f, a, 255);
  tracef1("got field %i in FieldLength.\n", f);
  return(strlen(a));
}

#ifdef NEVER
void wr_dbox_setnumeric(dbox d, wr_dbox_field f, int n)
{
  char a[20];
  wr_wimp_icon *i = wr_dbox__fieldtoiconptr(d, f);
  wr_dbox_fieldtype ftype = wr_dbox__iconfieldtype(i);

  switch (ftype) 
  {
     case wr_dbox_FONOFF:
     case wr_dbox_FACTION:
         if (n)
           wr_wimpt_noerr(wr_wimp_set_icon_state(d->w, wr_dbox__fieldtoicon(f),
             wr_wimp_ISELECTED, wr_wimp_ISELECTED));
         else
           wr_wimpt_noerr(wr_wimp_set_icon_state(d->w, wr_dbox__fieldtoicon(f),
             0, wr_wimp_ISELECTED));
         break;

     default:
         sprintf(a, "%i", n);
         wr_dbox_setfield((dbox) d, f, a);
  }
}

int wr_dbox_getnumeric(dbox d, wr_dbox_field f)
{
  char a[20];
  int n;
  int i;
  int neg;
  int fail;
  wr_wimp_icon *iptr = wr_dbox__fieldtoiconptr(d, f);
  wr_wimp_icon icon;

  if (wr_dbox__iconfieldtype(iptr) == wr_dbox_FONOFF) 
  {
    wr_wimpt_noerr(wr_wimp_get_icon_info(d->w, wr_dbox__fieldtoicon(f), &icon));
    if ((icon.flags & wr_wimp_ISELECTED) != 0) 
    {
      n = 1;
    } 
    else 
    {
      n = 0;
    }
  } 
  else 
  {
    wr_dbox_getfield((dbox) d, f, a, 20);
    tracef1("wr_dbox_getnumeric on '%s'\n",(int) a) ;
    n = 0;
    i = 0;
    neg = 0;
    fail = 0;
    while (1) 
    {
      if (fail || a[i] == 0) {break;}
      if (a[i] == '-') 
      {
        if (neg || (n!=0)) {fail = 1;} else {neg = 1;}
      } 
      else if ((a[i] >= '0') && (a[i] <= '9')) 
      {
        n = n * 10 + a[i] - '0';
      } 
      else {
        tracef1("wr_dbox_getnumeric fails with %d\n",a[i]) ;
        fail = 1;
      }
      i++;
    }
    if (neg) n = -n;
    if (fail) n = 0;
  }
  return(n);
}
#endif

/* -------- Arrival of events from DBoxes. -------- */

wr_dbox_field wr_dbox_get(dbox d)
{
  d->fieldwaiting = 0;
  return(d->field);
}

wr_dbox_field wr_dbox_read(dbox d)
{
  return(d->field);
}

void wr_dbox_eventhandler(dbox d, wr_dbox_handler_proc handler, void* handle)
{
  d->eventproc = handler;
  d->eventprochandle = handle;
}

void wr_dbox_raw_eventhandler(dbox d, wr_dbox_raw_handler_proc handler, void *handle)
{
  d->raweventproc = handler;
  d->raweventprochandle = handle;
}

/* -------- Processing Wimp Events. -------- */

static void wr_dbox__buttonclick(dbox d, wr_dbox_field f)
{
  tracef1("Button click icon %i.\n", f);
  d->field = f;
  d->fieldwaiting = 1;
  if (d->eventproc != 0) 
  {
    tracef0("obeying user event proc.\n");
    d->eventdepth++;
    d->eventproc((dbox) d, d->eventprochandle);
    d->eventdepth--;
    if (d->disposepending && d->eventdepth == 0) 
    {
      tracef0("delayed dispose of DBox.\n");
      wr_dbox__dodispose(d);
    }
  }
}

static BOOL wr_dbox__hitbutton(dbox d, int button)
/* A button is an action button or an on/off switch. "button" counts only
such interesting buttons, button==0 -> the first one in the DBox. Find the
right icon. If an action, do it. If on/off, flip it. If button is too big, do
nothing. */
{
  wr_wimp_icon *i;
  int j = 0; /* counts icons */
  wr_dbox_fieldtype f;
  wr_wimp_icon icon;
  BOOL icon_found = FALSE;

  for (j=0; j<d->window.nicons; j++) 
  {
    i = wr_dbox__iconhandletoptr(d, j);
    f = wr_dbox__iconfieldtype(i);
    if (f == wr_dbox_FACTION || f == wr_dbox_FONOFF) 
    {
      if (button == 0) 
      {
        /* this is the right one */
        if (f == wr_dbox_FACTION) 
        {
          tracef1("buttonclick %i.\n", j);
          wr_dbox__buttonclick(d, j);
        } 
        else 
        {
          /* on/off button */
          tracef1("Flip on/off %i.\n", j);
          (void) wr_wimp_get_icon_info(d->w, j, &icon);
          if ((icon.flags & wr_wimp_ISELECTED) != 0) 
          {
            wr_wimpt_noerr(wr_wimp_set_icon_state(d->w, j, wr_wimp_ISELECTED, (wr_wimp_iconflags)0));
          } 
          else 
          {
            wr_wimpt_noerr(wr_wimp_set_icon_state(d->w, j, wr_wimp_ISELECTED, wr_wimp_ISELECTED));
          }
          /* inverted the select bit. */
        }
        icon_found = TRUE;
        break;
      }
      else 
      {
        /* right sort, but not this one. keep going. */
        button--;
      }
    } 
    else 
    {
      /* not the right sort of icon: keep going. */
    }
  }

  return icon_found;
}

static void wr_dbox__wr_wimp_event_handler(wr_wimp_eventstr *e, void *handle)
{
  dbox d = (dbox) handle;
  wr_wimp_caretstr c;
  wr_wimp_icon *i;
  wr_wimp_i j;
  char target;
  wr_wimp_icon ii;

  if (d->raweventproc != 0) 
  {
    BOOL done;
    tracef0("client-installed raw event handler.\n");
    d->eventdepth++;
    done = (d->raweventproc)(d, (void*) e, d->raweventprochandle);
    d->eventdepth--;
    if (d->disposepending && d->eventdepth == 0) 
    {
      tracef0("delayed dispose of DBox.\n");
      wr_dbox__dodispose(d);
      return;
    } 
    else if (done) 
    { 
      /* this event has been processed. */
      return;
    }
  }

  switch (e->e) 
  {
     case  wr_wimp_ECLOSE:
         wr_dbox__buttonclick(d, wr_dbox_CLOSE); /* special button code */
         break;
     case wr_wimp_EOPEN:
         wr_wimpt_noerr(wr_wimp_open_wind(&e->data.o));
         break;
     case wr_wimp_EBUT:
         if ((wr_wimp_BMID & e->data.but.m.bbits) != 0) 
         {
           /* ignore it. */
           /* It will already have been intercepted (by Events) if there's
           a menu, otherwise we're not interested anyway. */
         } 
         else if (e->data.but.m.i != (wr_wimp_i) -1) 
         {
           /* ignore clicks not on icons. */
           i = wr_dbox__iconhandletoptr(d, e->data.but.m.i);
           if (wr_dbox__iconfieldtype(i) == wr_dbox_FACTION) 
           {
             /* avoid spurious double-click from on/off button! */
             wr_dbox__buttonclick(d, e->data.but.m.i);
           }
         }
         break;
     case wr_wimp_EKEY:
         wr_wimpt_noerr(wr_wimp_get_caret_pos(&c));
         switch (e->data.key.chcode) 
         {
            case wr_akbd_Fn+1:
            case wr_akbd_Fn+2:
            case wr_akbd_Fn+3:
            case wr_akbd_Fn+4:
            case wr_akbd_Fn+5:
            case wr_akbd_Fn+6:
            case wr_akbd_Fn+7:
            case wr_akbd_Fn+8:
            case wr_akbd_Fn+9:
                /* if fnkey matches icon number, do action, else pass it on
                 * as a hotkey stroke
                 */
                if (!wr_dbox__hitbutton(d, e->data.key.chcode - (wr_akbd_Fn+1)))
                  wr_wimp_processkey(e->data.key.chcode);
                break;
               
            case 13: /* return key */
                /* RETURN key to activate OK button 03/09/93 [20818] */
                /* 09/08/95 test that button is not dimmed */
                wr_wimpt_noerr(wr_wimp_get_icon_info(d->w, 0, &ii));
                if ((ii.flags & wr_wimp_INOSELECT) == 0)
                  wr_dbox__buttonclick(d, 0); /* should be first action button! */
#ifdef NEVER
                c.i++;
                if (c.i >= d->window.nicons ||
                    c.i < 0 ||
                    0==wr_dbox__findselectableicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &c.i)
                     /* find a writable button */
                   )
                {
                  wr_dbox__buttonclick(d, 0); /* should be first action button! */
                } 
                else 
                {
                  c.height = -1;
                  c.index = wr_dbox__fieldlength(d, c.i);
                  tracef2("Setting caret in icon %i index=%i.\n",
                    c.i, c.index);
                  wr_wimpt_noerr(wr_wimp_set_caret_pos(&c));
                }
#endif
                break;
            case 27: /* ESC key */
                wr_dbox__buttonclick(d, wr_dbox_CLOSE);
                break;
            case 394: /* TAB key 03/09/93 [20818] */
            case 398: /* DOWN key */
                if (c.i == (wr_wimp_i) -1) 
                {
                  /* do nothing */
                } 
                else 
                {
                  c.i++;
                  if (c.i >= d->window.nicons ||
                      !wr_dbox__findselectableicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &c.i))
                  {
                    c.i = 0;
                    if (wr_dbox__findselectableicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &c.i)) 
                    {
                      /* bound to find at least the one you started on. */
                    }
                  }
                  c.height = -1;
                  c.index = wr_dbox__fieldlength(d, c.i);
                  wr_wimpt_noerr(wr_wimp_set_caret_pos(&c));
                }
                break;
            case 410: /* Sh-TAB key 03/09/93 [20818] */
            case 399: /* UP key */
                if (c.i == (wr_wimp_i) -1) 
                {
                  /* do nothing */
                } 
                else 
                {
                  if (!wr_dbox__findselectableiconbefore(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &c.i))
                  {
                    c.i = d->window.nicons;
                    if (wr_dbox__findselectableiconbefore(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &c.i))
                    {
                      /* bound to find at least the one you started on. */
                    }
                  }
                  c.height = -1;
                  c.index = wr_dbox__fieldlength(d, c.i);
                  wr_wimpt_noerr(wr_wimp_set_caret_pos(&c));
                }
                break;
            default:
                /* If not to a field and this is a letter, try matching it
                with the first chars of action buttons in this DBox. */
                if (e->data.key.chcode >= 'a' &&
                    e->data.key.chcode <= 'z')
                {
                  e->data.key.chcode -= 'a'-'A';
                }
                if (e->data.key.chcode >= 'A' && e->data.key.chcode <= 'Z') 
                {
                  for (j=0; j<d->window.nicons; j++) 
                  {
                    tracef1("trying icon %i.\n", j);
                    i = wr_dbox__iconhandletoptr(d, j);
                    if ((i->flags & wr_wimp_ITEXT) != 0
                    && wr_dbox__iconfieldtype(i) == wr_dbox_FACTION) 
                    {
                      char *targetptr;
                      BOOL found = FALSE;

                      if ((i->flags & wr_wimp_INDIRECT) != 0) 
                      {
                        targetptr = &i->data.indirecttext.buffer[0];
                      } 
                      else 
                      {
                        targetptr = &i->data.text[0];
                      }

                      while (1) 
                      {
                        target = *targetptr++;
                        if (target == 0) break;
                        if (target == e->data.key.chcode) 
                        {
                          tracef2("clicking on %i, %i.\n", j, target);
                          wr_dbox__buttonclick(d, j);
                          found = TRUE;
                          break;
                        }
                        if (target >= 'A' && target <= 'Z') break;
                      }
                      if (found) break;
                      tracef2("no: target=%i,code=%i.\n",
                        target, e->data.key.chcode);
                    }
                  }
                } 
                else 
                {
                  tracef1("Key code %i ignored.\n", e->data.key.chcode);
                  wr_wimp_processkey(e->data.key.chcode);
                }
            }
            break;
#ifdef NEVER
       /* 11/02/93 [20701] supply a minimum of help for dialogues not under our control */
       case wr_wimp_ESEND:
       case wr_wimp_ESENDWANTACK:
           if (e->data.msg.hdr.action == wr_wimp_MHELPREQUEST)
           {
             char buff[15];

             strcpy(buff, d->name)[strcspn(buff, "_")] = 0;
             if (GetHelpString(buff, e->data.msg.data.helpreply.text) != NULL)
               SendHelpReply(&e->data.msg);
           }
           break;
#endif
     default:
         /* do nothing */
         tracef3("DBoxes ignored event %i %i %i.\n",
           e->e, e->data.o.w, e->data.menu[1]);
  }
}

static void SetBox(wr_wimp_box *box, sqIcon x, sqIcon y)
{
  box->x0 = x.coord.offset;
  box->x1 = box->x0 + x.coord.width;
  box->y0 = y.coord.offset;
  box->y1 = box->y0 + y.coord.width;
}


static sqIcon *XpandIcon(bool threeD, wr_wimp_iconflags *flags, wr_wimp_icondata *icon,
                                   sqIcon *sq, char **indirData)
{
  /* unpack into icon */
  int textLen;
  int IST = ((*flags & wr_wimp_INDIRECT) >> 6) |
                                 (*flags & (wr_wimp_ISPRITE | wr_wimp_ITEXT));
  char *namePtr;

  icon->indirecttext.buffer = 0;
  icon->indirecttext.validstring = 0;
  icon->indirecttext.bufflen = 0;
  if (threeD)   /* 31/05/92 add border validation codes to icons while unpacking */
  {
    textLen = 0;
    switch (IST) {
      case 5:
      case 7:
        /* indirected, text; sq[0] = text/bufflen; sq[1] = offset of valn; */
        textLen = sq->ch[1];
        icon->indirecttext.buffer = *indirData;
        memcpy(icon->indirecttext.buffer, sq->ch + 2, textLen);
        icon->indirecttext.buffer[textLen] = 0x0d;
        icon->indirecttext.bufflen = sq->ch[0] + 1;  /* held as n - 1 */
        *indirData += icon->indirecttext.bufflen;
        sq += (textLen + 5) / 4;
        icon->indirecttext.validstring = *indirData;
        if (*flags & wr_wimp_INOSELECT)
        {
          /* there was no validation string, so create one with to hold r0 */
          if (IST == 7)                   /* 12/07/93 for cluster labels */
            icon->indirecttext.validstring = (char *)-1;
          else
          {
            strcpy(icon->indirecttext.validstring, "r0");
            *indirData += 3;
          }
          *flags = (wr_wimp_iconflags)(*flags & ~wr_wimp_INOSELECT);
        }
        else
        {
          /* copy the existing validation string, and append ";r0" */
          namePtr = gSqTemplates.text + sq->aWord;
#ifdef TABLES
          if (strncmp(namePtr, gSmartValString, 10) == 0 && namePtr[10] < 32)
            icon->indirecttext.validstring = gSmartValString;  /* [26023] */
          else
#endif
          {
            for(; *namePtr >= 32; namePtr++, (*indirData)++)
              **indirData = *namePtr;
            strcpy(*indirData, ";r0");
            *indirData += 4;
          }
          sq++;
        }
        break;
        
      case 6:
        /* sprite; sq[0] = length/offset of sprite name; sq[1] = cntrl */
        icon->indirectsprite.name = gSqTemplates.text + sq->coord.offset;
        icon->indirectsprite.nameisname = sq->coord.width;
        sq++;
        icon->indirectsprite.spritearea = wr_resspr_area() /* 31/05/92 (void *)sq->aWord*/;
        /* mark 'our' sprites as IST = 6 in template so we can mix with wimp sprites */
        sq++;
        break;
    }
  }
  else
  {
    switch (IST) {
      case 1:
      case 2:
      case 3:
        if (*flags & wr_wimp_INOSELECT)
        {
          icon->text[0] = 0x0d;
          *flags = (wr_wimp_iconflags)(*flags & ~wr_wimp_INOSELECT);
        }
        else
        {
          textLen = sq->ch[0];
          /* copy the data into the icon */
          memcpy(icon->text, sq->ch + 1, textLen);
          icon->text[textLen] = 0x0d;
          sq += (textLen / 4) + 1;
        }
        break;

      case 5:
      case 7:
        /* indirected, text; sq[0] = text/bufflen; sq[1] = offset of valn; */
        textLen = sq->ch[1];
        icon->indirecttext.buffer = *indirData;
        memcpy(icon->indirecttext.buffer, sq->ch + 2, textLen);
        icon->indirecttext.buffer[textLen] = 0x0d;
        icon->indirecttext.bufflen = sq->ch[0] + 1;  /* held as n - 1 */
        *indirData += icon->indirecttext.bufflen;
        sq += (textLen + 5) / 4;
        if (*flags & wr_wimp_INOSELECT)
        {
          icon->indirecttext.validstring = (char *)-1;
          *flags = (wr_wimp_iconflags)(*flags & ~wr_wimp_INOSELECT);
        }
        else
        {
          namePtr = gSqTemplates.text + sq->aWord;
          icon->indirecttext.validstring = (
#ifdef TABLES
             strncmp(namePtr, gSmartValString, 10) == 0 && namePtr[10] < 32 ? gSmartValString :
#endif
                        namePtr);
          sq++;
        }
        break;
        
      case 6:
        /* 14/06/92 format same as t1-3 */
        icon->indirectsprite.name = *indirData;
        textLen = icon->indirectsprite.nameisname = sq->ch[0];
        memcpy(*indirData, sq->ch + 1, textLen);
        (*indirData)[textLen] = 0;
        *indirData += textLen + 1;
        sq += (textLen / 4) + 1;
        icon->indirectsprite.spritearea = wr_resspr_area() /* 31/05/92 (void *)sq->aWord*/;
#ifdef NEVER
        /* sprite; sq[0] = length/offset of sprite name; sq[1] = cntrl */
        icon->indirectsprite.name = gSqTemplates.text + sq->coord.offset;
        icon->indirectsprite.nameisname = sq->coord.width;
        sq++;
        icon->indirectsprite.spritearea = wr_resspr_area() /* 31/05/92 (void *)sq->aWord*/;
        /* mark 'our' sprites as IST = 6 in template so we can mix with wimp sprites */
        sq++; 
#endif
        break;

       default:
         break;
    }
  }
  if ((*flags & 0x040) != 0)     /* contains anti-aliased font 13/11/91 */
  {
    int font = (((unsigned)*flags) >> 24);
    template_font *fontDesc = ((template_font *)gSqTemplates.text) + font - 1;
    wr_os_error *err = FontFind(&font, fontDesc->fontName, fontDesc->sizeX, fontDesc->sizeY);

    if (err == NULL)      
      *flags = (wr_wimp_iconflags)((font << 24) | (*flags & 0x00ffffff));
    else
      *flags = (wr_wimp_iconflags)(0x0f000000 | (*flags & 0x00ffffbf));
  }
  return sq;
}

/* -------- New and Dispose. -------- */

dbox wr_dbox_find_template(char *name)
{
  sqTemplate *found = gSqTemplates.windowTemplates;
  int i;

  for (i = 0; i < gSqTemplates.numTemplates; i++, found++)
  {
    if (strncmp(name, found->name, 12) == 0)
    {
      dbox to = (dbox)NewHandle(sizeof(wr_dbox__str) +
                                        sizeof(wr_wimp_icon) * found->nicons);
      wr_wimp_wind *out;
      sqIcon *iconIndex;
      wr_wimp_icon *iconPtr;
      char *indirData;

      if (to == NULL)
        return NULL;

      to->w = -1;     /* 28/06/93 so dispose can detect that window not opened */
      /* --- copy relevant stuff from template --- */
      strncpy (to->name, found->name, 12);
      to->workspacesize = found->indirectReq + 1;  /* to stop malloc failng */
      indirData = to->workspace = (char *)NewHandle(to->workspacesize);
      if (to->workspace == NULL) {
        DisposIfHandle(to);
        return NULL;
      }
      to->next = 0;
      to->eventproc = 0;
      to->raweventproc = 0;
      to->disposepending = 0;
      to->eventdepth = 0;
      to->fieldwaiting = 0;
      to->field = 0;
      to->showing = 0;

      /* now start by unpacking the window data */
      out = &to->window;
      SetBox(&out->box, found->b[0], found->b[1]);  /* screen coords of work area */
      out->scx = 0;
      out->scy = 0;           /* scroll bar positions */
      out->behind = -1;          /* handle to open window behind, or -1 if top */
      out->flags = (wr_wimp_wflags)(found->flags); /* word of flag bits defined above */
              /* & (gNet.TV ? ~2 : -1) to prevent window drag */
      memcpy(out->colours, found->colours, 8);    /* colours: index using wr_wimp_wcolours. */
      SetBox(&out->ex, found->e[0], found->e[1]); /* maximum extent of work area */
      out->titleflags = found->titleflags;        /* icon flags for title bar */
      out->workflags = (wr_wimp_iconflags)(wr_wimp_IBTYPE * (found->windbutton & 0x0f));
                                                  /* just button type relevant */
      out->spritearea = wr_resspr_area();
                          /* 0->use the common sprite area */
                          /* 1->use the wimp sprite area */
      out->minsize = found->minsize;            /* two 16-bit OS-unit fields, (width/height)
                             giving min size of window. 0->use title. */
      out->nicons = found->nicons;             /* no. of icons in window */
      iconIndex = XpandIcon(FALSE, &out->titleflags, &out->title,
            gSqTemplates.icons + found->iOffset, &indirData); /* title icon data */

      /* then unpack each lot of icon data - (safe to reuse i) */
      iconPtr = (wr_wimp_icon *)&out[1];
      for (i = 0; i < found->nicons; i++, iconPtr++)
      {
        SetBox(&iconPtr->box, iconIndex[0], iconIndex[1]);
        iconPtr->flags = iconIndex[2].flags;
        iconIndex = XpandIcon(g3Dicons, &iconPtr->flags, &iconPtr->data,
                                             iconIndex + 3, &indirData);
      }
#ifdef OURTRACE
      if (indirData - to->workspace > to->workspacesize)
        RealSysBeep();
#endif
      return to;
    }
  }
  wr_werr(FALSE, "Template %s not found", name);
  return NULL;
}

dbox wr_dbox_create_wind(dbox d)
{
  wr_wimp_i j;

  d->posatcaret = (wr_wimp_WTRESPASS & d->window.flags) != 0;
  d->window.flags = (wr_wimp_wflags)(d->window.flags & ~wr_wimp_WTRESPASS);

  /* 14/07/92 add scroll bars if necessary */
  if (strncmp(d->name, "IconBar", 7) == 0)  /* temp - this is not a real dlog */
  {
    if (gWimpVersion > 300)
    {
      int i;
      wr_wimp_icon *ic = (wr_wimp_icon *)(&d->window + 1);  /* ptr to first icon */

      d->window.colours[3] = 1;  /* 20/07/92 set icon background to light grey for 3D */
      for (i = 0; i < d->window.nicons; i++, ic++)
        if ((ic->flags & (wr_wimp_ITEXT | wr_wimp_IFONT | 0xf0000000)) == wr_wimp_ITEXT)
          ic->flags = (wr_wimp_iconflags)(ic->flags | wr_wimp_IBACKCOL);
                                           /* set white text bgnd to lt grey */
    }
  }
  else
  {
    int vduVars[5];
    int vduReplies[5];

    vduVars[0] = 11;   /* screen x */
    vduVars[1] = 12;   /* screen y */
    vduVars[2] = 4;    /* x-eigen */
    vduVars[3] = 5;    /* y-eigen */
    vduVars[4] = -1;   /* terminator */
    wr_wimpt_noerr(wr_os_swi2(OS_ReadVduVariables | wr_os_X,
                                      (int)vduVars, (int)vduReplies));
    if (d->window.box.x1 - d->window.box.x0 > ((vduReplies[0] + 1) << vduReplies[2]))
    {
      d->window.flags = (wr_wimp_wflags)(d->window.flags | wr_wimp_WSIZE | wr_wimp_WHSCR);
      d->window.ex.x1 = d->window.box.x1 - d->window.box.x0;
    }
    if (d->window.box.y1 - d->window.box.y0 > ((vduReplies[1] + 1) << vduReplies[3]))
    {
      d->window.flags = (wr_wimp_wflags)(d->window.flags | wr_wimp_WSIZE | wr_wimp_WVSCR);
      d->window.ex.y0 = d->window.box.y0 -  d->window.box.y1;
    }
  }
  /* 14/07/92 end */

  { wr_os_error *er;
    er = wr_wimp_create_wind(&d->window, &d->w);
    if (er != 0) {
      wr_werr(FALSE, &er->errmess[0]);
      wr_dbox__dispose(d);
      return 0;
    };
  };
  wr_win_register_event_handler(d->w, wr_dbox__wr_wimp_event_handler, d);
  tracef0("Template created.\n");
  j = 0;
#ifdef NEVER
  if (wr_dbox__findselectableicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &j))
  {
    /* there is a writable icon to be found. */
    tracef1("Set caret in icon %i.\n", j);
    /* Default setting, used in FillIn */
    d->caretstr.w = d->w;
    d->caretstr.i = j;
    d->caretstr.x = 0;
    d->caretstr.y = 0;
    d->caretstr.height = -1;
    d->caretstr.index = INT_MAX;
  };
#else
  if (wr_dbox__findselectableicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &j))
  {
    d->caretstr.i = j;
    d->caretstr.height = -1;
  }
  else 
  {
    d->caretstr.i = -1;        /* [20859] not 0 */
    d->caretstr.height = 0;
  }
  d->caretstr.w = d->w;
  d->caretstr.x = 0;
  d->caretstr.y = 0;
  d->caretstr.index = INT_MAX;
#endif
  return d;
}

dbox wr_dbox_new(char *name)
{
  dbox d = wr_dbox_find_template(name);

  if (d != NULL)
    /* wr_werr(FALSE, msgs_lookup("dbox1:Not enough memory to create dialogue box -- increase wimpslot")); 11/07/92
  else */
    d = wr_dbox_create_wind(d);
  return d;
}

void wr_dbox_free(dbox d)
{
  wr_dbox__dispose(d);
}

wr_wimp_wind *wr_dbox_wind(dbox d)
{
  return &d->window;
}

static wr_wimp_w wr_dbox__submenu = 0;

static void wr_dbox__doshow(dbox d, BOOL isstatic)
/* This is complicated by the following case: if the show is as a result
of a submenu message (e.g. that was the last message received) then we
open the dbox as a submenu rather than as a standalone window. */
{
  wr_wimp_mousestr m;
  wr_wimp_openstr o;
  wr_wimp_eventstr *e;

  if (d->showing) return;
  d->showing = TRUE;
  wr_win_activeinc();

  e = wr_wimpt_last_event();
  if (e->e == wr_wimp_ESEND && e->data.msg.hdr.action == wr_wimp_MMENUWARN) 
  {
    /* this is a dbox that is actually part of the menu tree. */
    tracef0("opening submenu dbox.\n");
    d->staticdlog = FALSE;   /* RSP */
    wr_dbox__submenu = d->w; /* there's only ever one. */
    wr_wimp_create_submenu(
      (wr_wimp_menustr*) d->w,
      e->data.msg.data.words[1],
      e->data.msg.data.words[2]);
  } 
  else 
  {
    d->staticdlog = TRUE;   /* RSP */
    o.w = d->w;
    o.box = d->window.box;
    if (d->posatcaret) 
    {
#ifdef NEVER
      /* 20/03/96 only scale dialog goes here & that is never activated by key */
      /* move to near the caret. */
      if (e->e == wr_wimp_EKEY)    /* wr_wimpt_last_event_was_a_key()) */
      {
        wr_wimp_caretstr c;
        wr_wimp_wstate s;

        tracef0("Move DBox to near caret.\n");
        wr_wimpt_noerr(wr_wimp_get_caret_pos(&c));
        if (c.w != (wr_wimp_w) -1)
        {
          wr_wimpt_noerr(wr_wimp_get_wind_state(c.w, &s));
          c.x = c.x + (s.o.box.x0 - s.o.x);
          c.y = c.y + (s.o.box.y1 - s.o.y);
        }
        m.x = c.x + 100; /* a little to the right */
        m.y = c.y - 120; /* a little down */
      } 
      else
#endif
      {
#ifdef NETWP
        int safeTop;
#endif

        wr_wimpt_noerr(wr_wimp_get_point_info(&m));
        m.x -= 48; /* try to be a bit into it. */
        m.y += 48;
#ifdef NETWP
        safeTop = ((ScreenHeight() - gSafeArea.top) >> 2) - 40 /* kTitleBarDepth */;

        if (m.y > safeTop)
          m.y = safeTop;
#endif
      }
      o.box.y0 = m.y - (o.box.y1 - o.box.y0);
      o.box.x1 = m.x + (o.box.x1 - o.box.x0);
      o.box.y1 = m.y;
      o.box.x0 = m.x;
    }
    o.x = d->window.scx;
    o.y = d->window.scy;
    o.behind = (wr_wimp_w) -1;

    if (isstatic) 
    {
      wr_wimpt_noerr(wr_wimp_open_wind(&o));
    } 
    else 
    {
      wr_dbox__submenu = d->w; /* there's only ever one. */
      wr_wimp_create_menu((wr_wimp_menustr*) d->w, o.box.x0, o.box.y1);
    }

    tracef0("Dialog box shown.\n");
  }
}

void wr_dbox_show(dbox d)
{
  wr_dbox__doshow(d, FALSE);
}

void wr_dbox_showstatic(dbox d)
{
  wr_dbox__doshow(d, TRUE);
}

void wr_dbox_hide(dbox d)
{
  tracef0("wr_dbox_hide.\n");
  if (! d->showing) 
  {
    tracef0("wr_dbox_hide, not showing.\n");
  } 
  else 
  {
    d->showing = FALSE;
    wr_win_activedec();
    if (d->w == wr_dbox__submenu) 
    {
      wr_wimp_wstate ws;
      tracef0("hiding submenu dbox.\n");
      wr_wimpt_noerr(wr_wimp_get_wind_state(d->w, &ws));
      wr_dbox__submenu = 0;
      if ((ws.flags & wr_wimp_WOPEN) == 0) 
      {
        /* The dbox has been closed: presumably by the wimp. */
        /* Thus, there is nothing more to do. */
      } 
      else 
      {
        /* The dbox was closed without the menu tree knowing about it. */
        wr_event_clear_current_menu();
        /* That will cause the menu system to close the dbox. */
      }
    } 
    else 
    {
      tracef0("hiding non-submenu dbox.\n");
      wr_wimpt_noerr(wr_wimp_close_wind(d->w));
    }
  }
}

void wr_dbox_dispose(dbox *dd)
{
  dbox d = *dd;
  if (d->eventdepth != 0) 
  {
    d->disposepending = 1;
  } 
  else 
  {
    if (d->showing) wr_dbox_hide(d);
    wr_dbox__dodispose(d);
  }
}

/* -------- Event processing. -------- */

/* We cheerfully allow the caret to go elsewhere, but we intercept any
keystroke events and divert them to the dbox. This allows e.g. find commands
to see where in the text they've got to so far. dboxes with no fill-in fields
do not even try to get the caret. */

static wr_dbox_field wr_dbox_fillin_loop(dbox d)
{
  wr_wimp_eventstr e;
  int harmless;
  wr_dbox_field result;
  wr_wimp_wstate ws;

  while (1) 
  {
    int null_at;
    if (wr_alarm_next(&null_at) && (wr_event_getmask() & wr_wimp_EMNULL) != 0)
        wr_wimpt_complain(wr_wimp_pollidle((wr_wimp_emask)(wr_event_getmask() & ~wr_wimp_EMNULL), &e, null_at));
    else 
        wr_wimpt_complain(wr_wimp_poll(wr_event_getmask(), &e));

    if (d->w == wr_dbox__submenu) 
    {
      wr_wimpt_noerr(wr_wimp_get_wind_state(d->w, &ws));
      if ((ws.flags & wr_wimp_WOPEN) == 0) 
      {
        tracef0("dbox has been closed for us!.\n");
        wr_wimpt_fake_event(&e); /* stuff it back in the queue */
        if (e.e == wr_wimp_EREDRAW) wr_event_process();
        return wr_dbox_CLOSE;
      }
    }

    switch (e.e) 
    {
       case wr_wimp_ENULL:
       case wr_wimp_EREDRAW:
       case wr_wimp_EPTRENTER:
       case wr_wimp_EPTRLEAVE:
       case wr_wimp_ESCROLL:
       case wr_wimp_EOPEN:
       case wr_wimp_ELOSECARET:
       case wr_wimp_EGAINCARET:
       case wr_wimp_EUSERDRAG:
       case wr_wimp_EACK:      /* RSP 23/03/93 closes window when SaveAs dropped on itself */
           harmless = TRUE;
           break;
       case wr_wimp_EMENU:
           harmless = d->staticdlog;   /* RSP [20819] harmless if popup selected */
           break;
       case wr_wimp_ECLOSE:
           harmless = e.data.o.w == d->w;
           break;
       case wr_wimp_EKEY:
           /* Intercept all key events. */
           if (e.data.key.c.w != d->w) 
           {
             e.data.key.c.w = d->w;
             e.data.key.c.i = (wr_wimp_i) -1;
           }
           harmless = 1;
           break;
       case wr_wimp_EBUT:
           harmless = FALSE;
           if (e.data.but.m.w == d->w)
             harmless = TRUE;
           /* RSP */
#ifdef NEVER
           else if ((e.data.but.m.bbits & (wr_wimp_BRIGHT | wr_wimp_BMID | wr_wimp_BLEFT)) == 0 &&
                                             e.data.but.m.w >= 0 && e.data.but.m.i >= 0)
           {
             /* ignore a drag event on another window's button (click-drag type) */
             wr_wimp_icon state;

             wr_wimpt_noerr(wr_wimp_get_icon_info(e.data.but.m.w, e.data.but.m.i, &state));
             if ((state.flags & (wr_wimp_IBTYPE * 15)) == wr_wimp_IBTYPE * 6)
               harmless = TRUE;
           }
#endif
           else if ((e.data.but.m.bbits & ((wr_wimp_BRIGHT | wr_wimp_BMID | wr_wimp_BLEFT) * 16)) != 0)
           /* ignore drag event if double click on one window brings up a dbox under mouse */
             harmless = TRUE;
           else
           {
             /* 31/08/93 allow clicks on a pane window as harmless */
             wr_wimp_wstate s;
             wr_wimp_w overMain;

             wr_wimpt_noerr(wr_wimp_get_wind_state(d->w, &s));

             for ( ;; )
             {
               overMain = s.o.behind;
               if (overMain <= 0 ||
                  (wr_wimpt_noerr(wr_wimp_get_wind_state(overMain, &s)),
                                         (s.flags & wr_wimp_WPANE) == 0))
                 break;     /* not harmless if on top or not a pane */
               if (overMain == e.data.but.m.w)
               {
                 harmless = TRUE;
                 /* 31/08/93 simulate OK press when double click on Select button */
                 if ((e.data.but.m.bbits & wr_wimp_BLEFT) != 0)
                   wr_dbox__buttonclick(d, 0);
                 break;
               }
             }
           }
           break;

       case wr_wimp_ESEND:
       case wr_wimp_ESENDWANTACK:
           harmless = TRUE;
           if (e.data.msg.hdr.action == wr_wimp_MPREQUIT) harmless = FALSE;
           break;
       default:
           harmless = 0;
    }

    wr_wimpt_fake_event(&e); /* stuff it back in the queue */
    if (harmless) 
    {
      wr_event_process();
    } 
    else 
    {
      result = wr_dbox_CLOSE;
      break;
    }
    /* And keep going round until he presses a button. */
    if (d -> fieldwaiting) {result = wr_dbox_get((dbox) d); break;}
  } /* loop */

  return(result);
}

wr_dbox_field wr_dbox_fillin(dbox d)
{
  wr_wimp_i j;

  j = 0;
#ifdef NEVER
  if (wr_dbox__findselectableicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &j)) 
  {
    tracef1("Set caret in icon %i.\n", j);
    d->caretstr.i = j;
    d->caretstr.x = 0;
    d->caretstr.y = 0;
    d->caretstr.height = -1;
    d->caretstr.index = wr_dbox__min(d->caretstr.index, wr_dbox__fieldlength(d, j));
    /* w, i already set up. */
    d->caretstr.index = wr_dbox__fieldlength(d, j);
    wr_wimpt_noerr(wr_wimp_set_caret_pos(&d->caretstr));
  }
#else
  if (wr_dbox__findselectableicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &j)) 
  {
    d->caretstr.i = j;
    d->caretstr.x = 0;
    d->caretstr.y = 0;
    d->caretstr.height = -1;
    /* waste of time! d->caretstr.index = wr_dbox__min(d->caretstr.index, wr_dbox__fieldlength(d, j)); */
    /* w, i already set up. */
    d->caretstr.index = wr_dbox__fieldlength(d, j);
  }
  j = 0;
  if (wr_dbox__findselectableicon(d, CLICK_IFLAGS, CLICK_IFLAGS, &j)) 
    wr_wimpt_noerr(wr_wimp_set_caret_pos(&d->caretstr));
#endif

  return wr_dbox_fillin_loop(d);
}

wr_dbox_field wr_dbox_fillin_fixedcaret(dbox d)
{
#ifdef NEVER
   wr_wimp_i j;
   wr_wimp_caretstr caret;

   j = 0;
   wr_wimpt_noerr(wr_wimp_get_caret_pos(&caret));
   if (wr_dbox__findselectableicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &j))
   {
      if (caret.w != wr_dbox_syshandle(d))
      {
         d->caretstr.i = j;
         d->caretstr.x = 0;
         d->caretstr.y = 0;
         d->caretstr.height = -1;
         d->caretstr.index = wr_dbox__fieldlength(d, j);
         wr_wimpt_noerr(wr_wimp_set_caret_pos(&d->caretstr));
      }
   }
#endif
   return wr_dbox_fillin_loop(d);
}

#ifdef NEVER
wr_dbox_field wr_dbox_popup(char *name, char *message)
{
  wr_dbox_field result;
  dbox d = wr_dbox_new(name);
  wr_dbox_setfield(d, 1, message);
  wr_dbox_show(d);
  result = wr_dbox_fillin(d);
  wr_dbox_dispose(&d);
  return(result);
}
#endif

BOOL wr_dbox_persist(void)
{
  wr_wimp_mousestr m;
  wr_wimpt_noerr(wr_wimp_get_point_info(&m));
  return (m.bbits & wr_wimp_BRIGHT) != 0;
}


/* -------- System Hook. -------- */

int wr_dbox_syshandle(dbox d)
{
  return(d->w);
}

/* -------- Initialisation. -------- */
/* end */
