/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdlib.h>

#include "drawfdiag.h"
#include "drawfobj.h"
#include "drawftypes.h"

#include "UTextEdit.h"
#include "UBodyEdit.h"
#include "UPictEdit.h"
#ifdef MATHS
#include "UMathEdit.h"
#endif
#include "UExpressn.h"
#include "UColEdit.h"
#include "UTablEdit.h"
#include "MSWord.h"

#define FIB101 4

typedef struct TWordStateData
{
  TStructure  parent;
  TCurrency   ignore1;
  long        pos;
  TCursorNode anchor;
  TCursorNode activeEnd;
  void       *ignore2;
  TCursorNode parentAnchor;
  TCursorNode parentActiveEnd;
} TWordStateData;

typedef TWordStateData *PWordStateData;

typedef struct TSed
{
  int textOffset;
  union {
    TCurrency sectCurr;
    int sectFP;
  } u;
  int hfOffsets[6];
} TSed;

typedef TSed *PSed;

typedef struct TParaPos
{
  int textOffset;
  TCurrency paraCurr;
} TParaPos;

typedef TParaPos *PParaPos;

typedef struct TFldPos
{
  int textOffset;
  int fldSepmark;
  int fldEndmark;
  int fieldType;
} TFldPos;

typedef TFldPos *PFldPos;

typedef enum TGrpx { kCHPX, kPAPX, kSEPX, kTABX } TGrpx;
   // kTABX is passed for PAPX when doing dummy cell at the end of a table row

static char ggArcToWindows[] = "\x8a\x9a\x81\x8d\x9f\x88\x8e\x8f\x90\x9d\x9e\x85\x99\x89\x95\x91\x92\x8b\x9b\x93\x94\x84\x96\x97\x98\x8c\x9c\x86\x87\x82\x83";

static int gCurrListLevel;

// ------------------------------------------------------------------------
Handle AppendToHandle(Handle handle, int insertLength, void *insertString)
{
  InsertIntoHandle(&handle, MAXLONGINT /* at end */, insertString, insertLength);
  return handle;
}

// ------------------------------------------------------------------------
static int CvtCharToWindows(int ch)
{
  unsigned int adjCh = ch - 0x81;

  if (adjCh < 0xa0 - 0x81)
    return ggArcToWindows[adjCh];
  return ch;
}

// ------------------------------------------------------------------------
static Handle StoreSprm(Handle handle, int sprmCode, int sprmVal)
{
  int sprmLen = gSprmSizes[sprmCode];
  char buff[8];
  char *p = buff;

#ifdef TRACE
  if (sprmLen > 4 && sprmCode != sprmCPicLocation)
    SysBeep(0);
  else
#endif
  {
    *(p++) = sprmCode;
    if (sprmLen > 4)
      *(p++) = (sprmLen = 4);
    p = (char *)memcpy(p, &sprmVal, sprmLen);
    handle = AppendToHandle(handle, p - buff + sprmLen, buff);
  }
  return handle;
}

// -----------------------------------------------------------------------
static int ConvertBorderCode(TRuleType rules)
{
  int dxpLineWidth;
  MS_BRC spec;

  dxpLineWidth = (rules.fPen + 7490) / 7500;
  if (dxpLineWidth > 5)
  {
    dxpLineWidth = dxpLineWidth >> 1;
    spec.brcType = 2;       // thick border
  }
  else
    spec.brcType = "\x00\x01\x03\x03\x03"[rules.fRule];
  spec.dxpLineWidth = dxpLineWidth;
  spec.fShadow = 0;
  spec.ico = 0;
  spec.dxpSpace = 1;

  return *(int *)&spec;
}


// -----------------------------------------------------------------------
static int GetBorderCode(TStyleFormat self)
{
  TRuleType rules;

  if (self->fDefined & kHasAdornment)
    rules = self->fOwnRuleType;
  else
    rules = self->fRuleType;
  return ConvertBorderCode(rules);
}


// -----------------------------------------------------------------------
static Handle StoreBorderSprm(TStyleFormat self, Handle handle)
{
  CntlAdornment adorn;
  int spec;

  spec = GetBorderCode(self);
  if (self->fDefined & kHasAdornment)
    adorn = self->fOwnAdornment;
  else
    adorn = self->fAdornment;
  spec = spec | ((adorn & adnShadow) >> 2);   // spec.fShadow = adorn / adnShadow;
  for (int adn = 0; adn < 4; adn++)
    if (((adorn >> adn) & 1) != 0) 
      handle = StoreSprm(handle, sprmPBrcTop + adn, spec);

  return handle;
}

// ------------------------------------------------------------------------
_TWordSender::_TWordSender(char *buffer, TMainView mainView)
                                       : (buffer, NULL, kMSWord)
{
  fMainView   = mainView;
  fParaBreak  = '1';
  fLineBreak  = '0';
#ifndef ZERO_OBJ
  fSepx       = NULL;
#endif
  // allocate handles needed to save, in increasing size order, so that we can tell if we
  // have run out of memory by just testing the last allocated.
  fSed        = NewEmptyHandle();
  fPapx       = NewEmptyHandle();
  fFnRefs     = NewEmptyHandle();
  fFnTxts     = NewEmptyHandle();
  fStyleIndex = NewEmptyHandle();
  fPix        = NewEmptyHandle();
  fFldPos     = NewEmptyHandle();
  fFib        = NewHandle(sizeof(MS_FIB));
  // if NewHandle worked for fFib, it must have worked for other handles!
  if (fFib == NULL)
  {
    _TWordSender::Free();
    FailOutOfMem();
  }
  memset(fFib, 0, sizeof(MS_FIB));
  ((MS_FIB *)fFib)->wident = 42460;
  ((MS_FIB *)fFib)->nFib =
  ((MS_FIB *)fFib)->nFibBack =
#ifdef FIB101
                               101;              // FIB version
#else
                               104;
#endif
  ((MS_FIB *)fFib)->nProduct = 41101;            // Product version (changed from 49231 11/09/96)
#ifdef NETWP
  ((MS_FIB *)fFib)->lid = 0x0409;                // language stamp (USA)
#else
  ((MS_FIB *)fFib)->lid = gLids[GetDefaultCountry() & 0x7f];  // 16/09/96 [27084]
#endif
  ((MS_FIB *)fFib)->fcMin =  0x300;
}

// ------------------------------------------------------------------------
void _TWordSender::Free(void)
{
  DisposIfHandle(fFib);
  DisposIfHandle(fSed);
  DisposIfHandle(fPapx);
  DisposIfHandle(fStyleIndex);
  DisposIfHandle(fFnRefs);
  DisposIfHandle(fFnTxts);
  DisposIfHandle(fPix);
  DisposIfHandle(fSepx);
  DisposIfHandle(fFldPos);
  _TSender::Free();
}

// ------------------------------------------------------------------------
void _TWordSender::SetDispatcher(TDispatcher dispatcher, char *buffer)
{
  fSpaceRequired = 0;
  fDispatcher = dispatcher;
  fBuffer = buffer;
}

// ------------------------------------------------------------------------
int _TWordSender::SaveCurrChange(int objCurr, Handle *h)
{
  TParaPos pp;

  pp.paraCurr = objCurr;
  pp.textOffset = GetSpaceUsed();
  InsertIntoHandle(h, MAXLONGINT, &pp, sizeof(pp));
  return 0;
}

// ------------------------------------------------------------------------
int _TWordSender::StyleChange(int paraCurr)
{
  // only build list on pass 1?
  return SaveCurrChange(paraCurr, &fPapx);
}

// ------------------------------------------------------------------------
void _TWordSender::SendFIB()
{
  SendString((char *)fFib, 394);
  SendString((char *)fFib + 396, sizeof(MS_FIB) - 396);

  // pad to 768 bytes with zeroes
  for (int i = sizeof(MS_FIB) - 2; i < 0x300; i++)
    SendChar(0);
}

//          if (fHFVisibility == kHFAllBut1stPage)    // 10/10/96 add support for title page
//          {
//            sprmCode = sprmSFTitlePage;
//            sprmVal = 1;
//          }

static int gWordDefaultPage[] = {12240, 15840, 1800, 1800, 1440, 1440, 720, 720};
// ------------------------------------------------------------------------
void _TWordSender::SetSepx(TCurrency sectCurr, int *hfOffsets)
{
  TFormat fmt = fMainView->GetFormatReadOnly(sectCurr);
  volatile TStyleFormat style = fmt->GetCompositeStyle(sectCurr);
  int kind = fmt->GetStructureReadOnly(sectCurr)->GetKind();
  FailInfo fi;

  CatchFailures(&fi);

  fSepx = NewEmptyHandle();
  if (fSepx)
  {
    TPagesPrintHandler prHdlr;
    int startPage = TBodyFormat(fmt)->fPageNumber;
    int pageLayout[8];
    int ihdd = 0;

    // set flags for headers/footers present in section
    for (int ii = 0; ii < 6; ii++)
      if (hfOffsets[ii] >= 0)
        ihdd |= (1 << ii);
    if (ihdd != 0)
      fSepx = StoreSprm(fSepx, sprmSGprflhdt, ihdd);

    if (((unsigned int)startPage) > 1)
      fSepx = StoreSprm(fSepx, sprmSPgnStart, startPage & 0x7fff);  // explicitly set pgn
    if (startPage != 0)
      fSepx = StoreSprm(fSepx, sprmSFPgnRestart, 1);  // explicitly set pgn restart
    prHdlr = TPagesPrintHandler(fMainView->fDocument->fDocPrintHandler);
    if ((ihdd = prHdlr->fHPrint->landscape) != 0)
      fSepx = StoreSprm(fSepx, sprmSBOrientation, 2);
                  // set to landscape (10/09/96 [27074] using 2 seems to work - spec is wrong?)
    // 10/09/96 [27073] Need to swap the page dimensions round for landscape
    pageLayout[ihdd] = prHdlr->fHPrint->rPaper.right - prHdlr->fHPrint->rPaper.left;
    pageLayout[1 - ihdd] = prHdlr->fHPrint->rPaper.bottom - prHdlr->fHPrint->rPaper.top;
    pageLayout[2] = prHdlr->fRawMargins.left;
    pageLayout[3] = -prHdlr->fRawMargins.right;
    // 28/08/96 [27049] header margins measured wrongly
    pageLayout[6] = prHdlr->fRawMargins.top;
    pageLayout[4] = pageLayout[6] + fMainView->fHeaderMargin / 10;
    pageLayout[7] = -prHdlr->fRawMargins.bottom;
    pageLayout[5] = pageLayout[7] + fMainView->fFooterMargin / 10;
    for (int i = 0; i < 8; i++)
    {
      int twips = pageLayout[i] / 50;

      if (twips != gWordDefaultPage[i])
        fSepx = StoreSprm(fSepx, sprmSXaPage + i +
                                  (i < 6 ? 0 : (sprmSDyaHdrTop - sprmSXaPage - 6)), twips);
    }

    // save remaining style properties for the section
    fSepx = style->ReturnWordSprm(fSepx, kind, kSEPX);
  }
  Success(&fi);

Rescue:
  FreeIfObject(style);
  ContinueIfFail(&fi);
}

// ------------------------------------------------------------------------
Handle _TWordSender::SaveFPK(int rgbxSize)
{
  int freeSpace = 0;
  int grpxLen;
  int *rgfc;
  int previous;
  PParaPos posTable;
  PParaPos xLimit;
  int startPageNum;
  int savedPages = 0;
  int whiteSpace = 0;
  volatile Handle pageTable = NewEmptyHandle();   // we can manage memory failure below
  int phrNum = 1;
  int paraStart;
  TGrpx grpType = (rgbxSize == 1 ? kCHPX : kPAPX);
  int runStart;
  int runLimit = 0;
  int oldRunStart = 0;
  int pageTableEntry[2];
  char fpk[512];
  volatile TStyleFormat style = NULL;
  volatile Handle papxp = NULL;
  FailInfo fi;

  CatchFailures(&fi);

  xLimit = PParaPos((char *)fPapx + GetHandleSize(fPapx));
#ifdef TRACE
  Assert(xLimit > PParaPos(fPapx), 989); // there must be at least one entry
#endif
  startPageNum = GetSpaceUsed() >> 9;  // current page number
  paraStart = previous = 0x300;
  for (posTable = PParaPos(fPapx); ; )
  {
    // initialise FPK on entry and after saving a full block
    rgfc = (int *)&fpk;
    rgfc = (int *)memset(rgfc, 0, 512);
    *(rgfc++) = previous;
    freeSpace = 508;
    grpxLen = 1;

    if (pageTable != NULL)  // this will be saved as the index array later
    {
      // build up a double array one of 4-byte start/end offsets in page; other 2-byte page nums
      pageTableEntry[0] = startPageNum + savedPages;
      pageTable = AppendToHandle(pageTable, 6, pageTableEntry);
      if (!MemError())
      {
        savedPages++;
        ((int *)memmove((int *)pageTable + savedPages, (int *)pageTable + savedPages - 1,
                                      savedPages * 2))[-1] = previous;
      }
    }

    for ( ; posTable < xLimit;
        oldRunStart = runLimit = 0, phrNum = 1, paraStart = posTable->textOffset + 1, posTable++)
    {
      TStructure paraStruct;
      int textOffset = posTable->textOffset + 1;
      int iter;
      int paraSize;
      int phraseAdjust;
      TCurrency paraCurr = posTable->paraCurr;

      paraCurr &= 0xffff00ff;
      if (Curr_fType(paraCurr) != kTextStruct)
      {
        whiteSpace = paraCurr;
///        if (grpType == kCHPX)
          continue;           // non-paragraph entry (which gets paraStart set correcty)
      }
      paraStruct = fMainView->GetStructureReadOnly(paraCurr);
      paraSize = paraStruct->fSize;
      if (grpType == kCHPX)
        paraSize++;            // force an extra iteration in loop below to add final emphasis
      else
        phrNum = paraSize;   // the following loop is done once for paragraphs

      // if successful, increment the phrase number ready for next iteration
      for ( ; phrNum <= paraSize; whiteSpace = 0, phrNum += iter,
              paraStart -= phraseAdjust, oldRunStart = (iter ? runLimit : runStart))
      {
        int grpxOffset = 0;
        TCurrency styleCurr = 0;   // paraStruct->fStyle;
        TCurrency changesCurr = paraStruct->fChanges;
        TCurrency emphChanges = 0;
        int picAddr = -1;
        int stdi;

        iter = 1;
        phraseAdjust = 0;
        runStart = oldRunStart;

        if (grpType == kCHPX)
        {
          if ((posTable->paraCurr & 0xff00) == 0)
          {
#ifdef FN
            // First see if we are doing a footnote (and therefore need to mark the note number)
            if (whiteSpace && fMainView->GetStructureReadOnly(whiteSpace)->GetKind() == kFootnote)
            {
              iter = 0;
              picAddr = -2;    // output an fSpec and superscript sprm
              phraseAdjust = 1;
              textOffset = previous + 1;
            }
            else
#endif

            {
              PPhrase phrase;
              PPhrase endPhr;

              if (phrNum > paraStruct->fSize) // case for end of para (add a plain run to end)
              {
                textOffset = posTable->textOffset + 1;     // end of text position
                if (previous >= textOffset)
                  continue;   // already done - should exit out of loop

                runLimit = TTextStructure(paraStruct)->fCount;

                // a 'paragraph' style run is needed up to the end of text
                iter = 0;    // go round again with phrNum == 0 on next iteration if FPK is full
              }
              else
              {
                // scan through paragraph struct looking for emphasis phrases
                PPhrase aPhrase = PPhrase(paraStruct->At(phrNum));
                int emphStart;

                if (aPhrase->fKind != kTextPhrase)
                  continue;     // ignore non-text phrases when finding next emphasis run

                emphStart = paraStart + aPhrase->fCharPos;
                if (emphStart > previous)
                {
                  // add in a new 'paragraph' emphasis to fill in the hole
                  textOffset = emphStart;
                  iter = 0;               // go round again with same phrase on next iteration
                  runLimit = aPhrase->fCharPos;
                }
                else
                {
                  styleCurr = RecToCurrency(aPhrase->tag.txt.fStyle);
                  if (styleCurr == TTextDocument(fMainView->fDocument)->fEmphasisStyle)
                    styleCurr = (PWordStyleIndex(fStyleIndex) + istdNormalChar)->styleCurr;
                  emphChanges = RecToCurrency(aPhrase->tag.txt.fChanges);
                  // runStart may have been moved past the emphasis start if it contains a macro
                  if (runStart < aPhrase->fCharPos)
                    runStart = aPhrase->fCharPos;
                  runLimit = aPhrase->fCharPos + aPhrase->fNumChars;
                  textOffset = emphStart + aPhrase->fNumChars;
                  if (textOffset < previous)
                  {
                    if (runLimit < runStart)
                      runLimit = runStart;
                    continue;   // emphasis embedded in macro - cannot handle this case yet
                  }
                }
              }
              // we have a run of text with the same (or no) emphasis
              // need to check if any widget, footnote or macro occurs in it
              // The text in the paragraph is bounded by runStart -> runLimit.
              phrase = PPhrase(paraStruct->fPtrToArray);
              endPhr = phrase + paraStruct->fSize;

              for (; phrase < endPhr && phrase->fCharPos < runLimit; phrase++)
              {
                if (phrase->fCharPos + phrase->fNumChars > runStart &&
                           (phrase->fKind == kWidgetPhrase ||
#ifdef FN
                            phrase->fKind == kNotePhrase ||
#endif
                            phrase->fKind == kMacroPhrase))
                {
                  if (phrase->fCharPos > runStart)
                  {
                    // process the text run up to start of (widget, not or macro) phrase
                    runStart = phrase->fCharPos;
                    textOffset = paraStart + phrase->fCharPos;
                  }
                  else if (phrase->fKind == kWidgetPhrase)
                  {
                    int hdlSize = GetHandleSize(fPix);
                    int ii;

                    whiteSpace = phrase->tag.fRecNum;    // so pict style changes output below
                    for (ii = 0; ii < hdlSize; ii += sizeof(TParaPos))
                    {
                      PParaPos picEntry = PParaPos((char *)fPix + ii);

                      if ((picEntry->paraCurr & 0xffff00ff) == whiteSpace)
                      {
                        picAddr = picEntry->textOffset;
                        break;
                      }
                    }
                    runStart = phrase->fCharPos + phrase->fNumChars;
                    textOffset = paraStart + runStart;
                    if (picAddr < 0)   // no entry for picture found - treat as 'other' phrase
                    {
                      // probably a maths phrase which gets ignored at the moment!
                      phraseAdjust = phrase->fNumChars;
                      textOffset -= phraseAdjust;
                      continue;
                    }
                  }
#ifdef FN
                  else  if (phrase->fKind == kNotePhrase)
                  {
                    picAddr = -2;    // output an fSpec and superscript sprm
                    runStart = phrase->fCharPos + phrase->fNumChars;
                    textOffset = paraStart + runStart;
                  }
#endif
                  else                // 24/09/96 [27096] handle macro phrase
                  {
                    int hdlSize = GetHandleSize(fFldPos);
                    int kk;

                    // locate the field pos entry to find the adjustment to the text offsets
                    for (kk = 0; kk < hdlSize; kk += sizeof(TFldPos))
                    {
                      PFldPos fldEntry = PFldPos((char *)fFldPos + kk);

                      if (previous >= fldEntry->textOffset && previous <= fldEntry->fldEndmark)
                      {
                        if (previous == fldEntry->textOffset ||
                            previous == fldEntry->fldSepmark || previous == fldEntry->fldEndmark)
                        {
                          picAddr = -3;    // output an fSpec
                          textOffset = previous + 1;
                          if (previous == fldEntry->fldEndmark)
                          {
                            runStart = phrase->fCharPos + phrase->fNumChars;
                            // after macro: assumes no overlapping/nested notes/macros/widgets
                            phraseAdjust = phrase->fNumChars - 1;
                          }
                          else
                            phraseAdjust = -1;
                        }
                        else
                        {
                          if (previous < fldEntry->fldSepmark)  // fails test if no sep mark
                            textOffset = fldEntry->fldSepmark;
                          else
                            textOffset = fldEntry->fldEndmark;
                          phraseAdjust = previous - textOffset;
                        }
                        break;
                      }
                    }
#ifdef TRACE
                    if (kk >= hdlSize)
                      SysBeep(0);   // entry matching phrase not found in fFldPos table!
#endif
                  }
                  iter = 0;  // keep processing this emphasis until all enclosed macros done
                  break;
                }
              }
            }
          }
          if (previous >= textOffset)
            continue;
            // nothing to do case: end of emphasis coinciding with end of note/macro/widget
        }
        else /// if (!whiteSpace)
        {
          // for a paragraph set up paragraph style and changes
          styleCurr = paraStruct->fStyle;
        }

        // look up style in the Style Sheet index
        for (stdi = 0; stdi < fStyleSheetCount; stdi++)
          if (styleCurr == 0 || (PWordStyleIndex(fStyleIndex) + stdi)->styleCurr == styleCurr)
          {
            // build a chpx/papx from changes
            Handle papx = NewHandle(grpType * 2 + 1);

            if (papx)
            {
              int papxLength;
              int savePapx;

              papxp = papx;   // for mem failures (papxp gets freed)
              if (grpType != kCHPX)
              {
                if ((posTable->paraCurr & 0x0ff00) == 0x400)
                {
                  // 11/09/96 [27091] dummy paragraph inserted after table at end of document
                  changesCurr = 0;
                }
                else /// if (!whiteSpace)
                {
                  // output any 'structure' sprms (when in table or in list)
                  TFormat fmt = fMainView->GetFormatReadOnly(paraStruct->fParent);
                  TStructure parentStruct = fmt->GetStructureReadOnly(paraStruct->fParent);

                  style = fmt->GetCompositeStyle(paraStruct->fParent);
                  if (Odd(posTable->paraCurr >> 8))      // end cell of table row
                    papx = TTableFormat(fmt)->ReturnWordTabSprm(papx, paraCurr, style);
                  else
                  {
                    gCurrListLevel = parentStruct->fUndoStyle;
                       // 23/09/96 [27093] See TBodyStructure::SendBodyWordData for List levels
#ifdef TRACE
                    papx = style->ReturnWordSprm(papx, parentStruct->GetKind(), kPAPX);
                    ClearObject(style);
                    style = fMainView->GetFormatReadOnly(paraCurr)->GetCompositeStyle(paraCurr);
#endif
                    papx = style->ReturnWordSprm(papx, parentStruct->GetKind(), kPAPX);
                  }
                  ClearObject(style);
                }
              }
              else if (stdi != istdNormalChar && styleCurr != 0)
                papx = StoreSprm(papx, sprmCIstd, stdi);    // non-std character style

              if (whiteSpace)
              {
                TStructure lastStr = fMainView->GetStructureReadOnly(whiteSpace);
                TStyleTypes lastKind = lastStr->GetKind();

#ifdef FN
                if (lastKind != kFootnote)
#endif
                  if (lastStr->fChanges)
                    papx = fMainView->GetStyleReadOnly(lastStr->fChanges)->
                                                    ReturnWordSprm(papx, lastKind, grpType);
              }
              // add props from changes
              if (picAddr != -1)    // changesCurr == -1)
              {
                papx = StoreSprm(papx, picAddr < 0 ? sprmCFSpec : sprmCPicLocation,
                                                         picAddr < 0 ? 1 : picAddr);
#ifdef FN
                if (picAddr == -2)
                  papx = StoreSprm(papx, sprmCIss, 1);  // [27094] footnotes are superscripted
#endif
              }
              if (picAddr < 0)  // 09/10/96 apply emphasis to all but pictures // else
              {
                TCurrency normal = 0;

#ifdef NETWP
                if (grpType == kCHPX &&
                     (PWordStyleIndex(fStyleIndex) + stiNormal)->styleCurr == paraStruct->fStyle)
                  normal = paraStruct->fStyle; // Apply 'Normal' style changes to paragraph
#endif
                if (normal != 0 || changesCurr != 0 || emphChanges != 0)
                {
                  style = TStyleFormat(fMainView->GetPrototype(kTextStyleStruct));
                  if (normal != 0)
                    style->ApplyOverride(fMainView->GetStyleReadOnly(normal), 0, 0);
                  if (changesCurr != 0)
                    style->ApplyOverride(fMainView->GetStyleReadOnly(changesCurr), 0, 0);
                  if (emphChanges != 0)
                    style->ApplyOverride(fMainView->GetStyleReadOnly(emphChanges), 0, 0);
                  papx = style->ReturnWordSprm(papx,
                    Curr_fType(paraStruct->fParent) == kTableStruct ? kColumns : kText, grpType);
                  ClearObject(style);
                }
              }

              papxLength = GetHandleSize(papx);
              if (grpType == kCHPX)
                savePapx = ((char *)papx)[0] = papxLength - 1;
              else
              {
                ((char *)papx)[0] = papxLength >> 1;
                ((char *)papx)[1] = stdi & 255;
                ((char *)papx)[2] = stdi >> 8;
                savePapx = stdi | (papxLength - 3);  // stdi != istdNormal or some grpx added
              }
              if (savePapx)
              {
                char *grpx;
                int grpLen;

                // search for similar; if found, set grpxOffset
                for (grpx = fpk + 512 - grpxLen ; grpx < fpk + 510; grpx += grpLen)
                {
                  if (memcmp(grpx, papx, papxLength) == 0)
                  {
                    grpxOffset = (grpx - fpk) >> 1;
                    break;
                  }
                  grpLen = grpx[0] + 1;
                  if (grpType == kCHPX)
                    grpLen += Odd(grpLen);
                  else
                    grpLen *= 2;
                }
                // else try to fit it in
                if (grpxOffset == 0)
                {
                  if (grpType == kCHPX)
                    grpxLen = grpxLen + papxLength + Odd(grpxLen + papxLength);
                  else
                    grpxLen = (grpxLen == 1 ? 0 : grpxLen) + (((char *)papx)[0] + 1) * 2;

                  if (freeSpace - rgbxSize - 4 >= grpxLen)
                    grpxOffset =
                      ((char *)memcpy(fpk + 512 - grpxLen, papx, papxLength) - fpk) >> 1;
                }
              }
              DisposIfHandle(papx);
              papxp = NULL;
            }
            break;
          }
#ifdef TRACE
        if (stdi == fStyleSheetCount)
          SysBeep(0);      // fStyle not found in the style sheet!
#endif

        if (grpType == kCHPX && fpk[511] != 0 && fpk[fpk[511] * 5 + 3] == grpxOffset)
        {
          previous = textOffset;
          *(rgfc - 1) = previous;     // just update the end of the existing run
        }
        else
        {
          int moveLen;

          freeSpace -= (rgbxSize + 4);
          if (freeSpace < grpxLen)     // it will not fit (and leave room for crun + grpx)
            break;
          moveLen = fpk[511] * rgbxSize;
          memmove(rgfc + 1, rgfc, moveLen);  // move up following data
          previous = textOffset;
          *(rgfc++) = previous;
          fpk[511]++;
          fpk[(fpk[511] + 1) * 4 + moveLen] = grpxOffset;
                                 // pointer to chpx/papx structure for para
        }
        // whiteSpace = 0;
      }   // end of 'emphasis' loop
      if (freeSpace < grpxLen)     // it will not fit
        break;
    }   // end of loop per paragraph entry in para position table
    if (freeSpace == 508)      // nothing added to save
      break;
    SendString(fpk, 512);
  }
  Success(&fi);
  return pageTable;

Rescue:
  DisposIfHandle(pageTable);
  DisposIfHandle(papxp);
  FreeIfObject(style);
  ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
void _TWordSender::SendSepx(char *limit)
{
  PSed sedTable;

  for (sedTable = PSed(fSed); sedTable < PSed(limit); sedTable++)
  {
    int sepxSize;

    SetSepx(sedTable->u.sectCurr, sedTable->hfOffsets);
    sepxSize = (fSepx ? GetHandleSize(fSepx) : 0);
    if (sepxSize == 0)
      sedTable->u.sectFP = -1;
    else
    {
      int currentFP = GetSpaceUsed();
      int pageEnd = ((currentFP + 511) >> 9) << 9;

      if (currentFP + sepxSize > pageEnd)  // will not fit in this page
        for (; currentFP < pageEnd; currentFP++)
          SendChar(0);
      sedTable->u.sectFP = currentFP;
      SendString((char *)&sepxSize, 2);
      SendString((char *)fSepx, sepxSize);
    }
    ClearHandle(&fSepx);
  }
}

// ------------------------------------------------------------------------
void _TWordSender::AddStyleIndex(PWordStyleIndex idxEntry)
{
  fStyleSheetCount++;
  InsertIntoHandle(&fStyleIndex, MAXLONGINT /* at end */, idxEntry, sizeof(TWordStyleIndex));
}

// ------------------------------------------------------------------------
void _TWordSender::BuildStyleSheetIndex()
{
  TStyleSheet styleSheet = TTextDocument(fMainView->fDocument)->fStyleSheet;
  PStyleInfo info;
  PStyleInfo sheetLimit;

  SetHandleEmpty(&fStyleIndex);
  for (fStyleSheetCount = 0; ; )
  {
    // goes round this loop with fStyleSheetCount == 0 -> 14 to do the fixed position
    // styles. On the final iteration, the loop below outputs ALL the remaining styles.
    TWordStyleIndex idxEntry;

    idxEntry.styleCurr = 0;
    idxEntry.sti = stiUser;     // will get overwritten if a built-in style

    for (info = PStyleInfo(styleSheet->fPtrToArray), sheetLimit = info + styleSheet->fSize;
                                                                  info < sheetLimit; info++)
    {
      if (info->fType == kText)
      {
        char *rsrcName;
        int sti = stiUser;

        if (info->fDocCurrency ==
                   TTextDocument(fMainView->fDocument)->fBodyStyles[kCurrTextStyle])
          sti = stiNormal;     // Paragraph Style treated specially
        else
        {
          for (int temp = 0; (rsrcName = GetRsrc(temp, 'u')) != NULL; temp++)
          {
            if (strcmp(rsrcName, info->fName) == 0)
            {
              sti = temp;
              break;
            }
          }
        }
        if (fStyleSheetCount >= 15)
        {
          if (sti <= 9 || sti == stiNormalChar)
            continue;  // we have done that one
        }
        else
        {
          // a fix position sti - output in order
          if (sti != fStyleSheetCount && (sti != stiNormalChar ||
                                                 fStyleSheetCount != istdNormalChar))
            continue;
        }
        idxEntry.sti = sti;
        idxEntry.styleCurr = info->fDocCurrency;
        AddStyleIndex(&idxEntry);
      }
    }
    if (fStyleSheetCount >= 15)
      break;
    if (idxEntry.styleCurr == 0)           // missing fixed pos style
    {
      if (fStyleSheetCount == istdNormalChar)
      {
        idxEntry.styleCurr = TTextDocument(fMainView->fDocument)->fEmphasisStyle;
        idxEntry.sti = stiNormalChar;
      }
      AddStyleIndex(&idxEntry);
    }
  }
}

// ------------------------------------------------------------------------
void _TWordSender::SaveStyleSheet()
{
  int stdi;
  MS_STSHI stsh;
#define pap_x pcx[0]
#define chp_x pcx[1]
  Handle pcx[2];      // hopefully making array avoids marking as volatile
  FailInfo fi;
#ifdef TRACE
  

#endif
  pap_x = chp_x = NULL;
  stsh.STSHI_size = 14;
  stsh.cstd = fStyleSheetCount;     // counted on first pass
  stsh.cbSTDBaseInFile = 8;
  stsh.fStdStyleNamesWritten = 1;
  stsh.unnamed = 0;
  stsh.stiMaxWhenSaved = 75;
  stsh.istdMaxFixedWhenSaved = 15;
  stsh.nVerBuiltInNamesWhenSaved = 0;
  stsh.ftcStandardChpStsh = 0;
  SendString((char *)&stsh, sizeof(MS_STSHI));

  CatchFailures(&fi);

  for (stdi = 0; stdi < fStyleSheetCount; stdi++)
  {
    PWordStyleIndex stshEntry = PWordStyleIndex(fStyleIndex) + stdi;

    if (stshEntry->styleCurr == 0)
      SendString((char *)&stshEntry->styleCurr, 2); // missing entry in fixed part
    else
    {
      TStyleInfo info;
      MS_STD style;
      char *styleName;
      int styleNameLen;
      TStyleFormat styleFmt;
      int styleLen;

      info.fDocCurrency = stshEntry->styleCurr;
      if (TTextDocument(fMainView->fDocument)->fStyleSheet->FindStyleInfo("", info) == 0)
      {
        // something wrong if not 'normalChar'!
        info.fEmphasis = (stdi == istdNormalChar);
        styleName = GetRsrc(stshEntry->sti, 'u');
      }
      else if (stshEntry->styleCurr ==
                         TTextDocument(fMainView->fDocument)->fBodyStyles[kCurrTextStyle])
      {
        info.fDocCurrency =
          fMainView->GetStructureReadOnly(TTextDocument(fMainView->fDocument)->fBody)->fStyle;
        styleName = GetRsrc(0, 'u');  // 'Normal' for doc style
      }
      else
        styleName = info.fName;
      styleNameLen = strlen(styleName);
      styleLen = sizeof(style) + (((styleNameLen + 1) >> 1) << 1);
      styleFmt = fMainView->GetStyleReadOnly(info.fDocCurrency);
      // plus length(s) UPX
      if (!info.fEmphasis)
      {
        // pap_x = FailNIL(NewHandle(0));
        AllocateEmptyHandle(&pap_x);
        pap_x = styleFmt->_TStyleFormat::ReturnWordSprm(pap_x, kText, kPAPX);
                                                                 // treat as paragraph style
        styleLen += (((GetHandleSize(pap_x) + 5) >> 1) << 1);
      }
      AllocateEmptyHandle(&chp_x);
      chp_x = styleFmt->_TStyleFormat::ReturnWordSprm(chp_x, kText, kCHPX);
      styleLen += (((GetHandleSize(chp_x) + 5) >> 1) << 1);
      SendString((char *)&styleLen, 2);
      style.sti = stshEntry->sti;
      style.fScratch = 0;
      style.fInvalHeight = 1;
      style.fHasUpe = 0;
      style.fMassCopy = 0;
      style.sgc = info.fEmphasis + 1;
      style.istdBase = stiNil;
      style.cupx = 2 - info.fEmphasis;
      style.istdNext = stdi;
      style.bchUpe = styleLen;
      SendString((char *)&style, sizeof(style));

      // send the style name with a count byte before, padded to even byte boundary after
      SendString((char *)&styleNameLen, 1); // rather than SendChar(ch) where ch may be converted
      SendString(styleName, styleNameLen);
      SendString((char *)&gZeroRect, Odd(styleNameLen) + 1);

      // send 1 or 2 UPXs
      for (int x = info.fEmphasis; x < 2; x++)
      {
        int xLen = GetHandleSize(pcx[x]);
        int temp = (1 - x) * 2 + xLen;    // plus length of UPX

        SendString((char *)&temp, 2);
        if (x == 0)
        {
          // for paragraph sprms
          SendString((char *)&stdi, 2);  // the istd 
        }
        SendString((char *)pcx[x], xLen);
        ClearHandle(pcx + x);
        if (Odd(xLen))
          SendChar(0);
      }
    }
  }
  Success(&fi);
  return;

Rescue:
  DisposIfHandle(pap_x);
  DisposIfHandle(chp_x);
  ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
void _TWordSender::SendFontNameStrings()
{
  TList fontList = TTextDocument(fMainView->fDocument)->fFontList;
  int temp;
  char buffer[68];

  for (temp = 1; temp <= fontList->fSize; temp++)
  {
    MS_FFN ffn;
    FontTree *ptr = (FontTree *)fontList->At(temp);
    int famNameLen;
    int fontNameLen;
    char *rsrc;

    ffn.cbFfnM1 = 0;           // Total length of FFN - 1.
    ffn.flags = 2;
    ffn.wWeightLo = 0x90;      // LS part of Base weight of font.
    ffn.wWeightHi = 0x01;      // MS part of Base weight of font.
    ffn.chs = 0;               // Character set identifier.
    ffn.ibszAlt = 0;           // Index into ffn.szFfn to the name of the alternate font.
    if (ptr == NULL)
      strcpy(buffer, GetString(kDefaultFontMsg));
    else if (ptr->info.terminal == 2)
    {
      if (ptr->info.brotherPtr != NULL)
      {
        SendString((char *)ptr->info.brotherPtr, ((MS_FFN *)ptr->info.brotherPtr)->cbFfnM1 + 1);
        continue;
      }
      strcpy(buffer, ptr->fonttext);
    }
    else
      GenerateFontName(ptr, buffer);

    // 09/09/96 [27072] Convert RISC_OS font names in new documents to equivalent Word names
    famNameLen = strlen(buffer);
    fontNameLen = famNameLen + 1;
    rsrc = strchr(buffer, '.');

    if (rsrc)
      famNameLen -= strlen(rsrc);    // length up to first '.' or the end of string

    for (int rsrcIdx = 1; (rsrc = GetRsrc(rsrcIdx, 'n')) != NULL; rsrcIdx++)
      if (strncmp(buffer, rsrc, famNameLen) == 0)   // test for match up to '.'
      {
        rsrc = GetRsrc(rsrcIdx, 'g');               // corresponding Word font or "-"
        if (rsrc && rsrc[0] != '-')
        {
          // a match found - store the RISC_OS name as the alternative font
          ffn.ibszAlt = strlen(rsrc) + 1;  // Index into ffn.szFfn to the name of the R_OS font
          memmove(buffer + ffn.ibszAlt, buffer, fontNameLen);
          fontNameLen += ffn.ibszAlt;
          strcpy(buffer, rsrc);
          break;
        }
      }

    ffn.cbFfnM1 = fontNameLen + 5;
    SendString((char *)&ffn, 6);
    SendString(buffer, fontNameLen);
  }
}

// ------------------------------------------------------------------------
#define MS_PIC_HDR (sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr) + 58)

void _TWordSender::SendPix()
{
  int hdlSize = GetHandleSize(fPix);

  for (int i = 0; i < hdlSize; i += sizeof(TParaPos))
  {
    PParaPos picEntry = PParaPos((char *)fPix + i);
    TCurrency curr = picEntry->paraCurr;
    TPictStructure pictStr = TPictStructure(fMainView->GetStructureReadOnly(curr));
    TPictObject pict = pictStr->GetPicture();
    MS_PIC msPic;

    picEntry->textOffset = GetSpaceUsed();
    if (pict && pict->fSprite == 9)
    {
      TPictFormat pictFmt;
      wr_draw_spristrhdr *sprihdr;
      int xZoom;
      int yZoom;
      int spec;
      CntlAdornment adorn;

      memcpy(&msPic, pict->fDrawDiagStr.data + MS_PIC_HDR - 58, sizeof(MS_PIC));
      sprihdr = (wr_draw_spristrhdr *)(pict->fDrawDiagStr.data + sizeof(wr_draw_fileheader));
      msPic.dxaGoal = (sprihdr->bbox.x1 - sprihdr->bbox.x0) >> 5;  // convert draw units to twips
      msPic.dyaGoal = (sprihdr->bbox.y1 - sprihdr->bbox.y0) >> 5;
      pictFmt = TPictFormat(fMainView->GetFormatReadOnly(curr));
      xZoom = pictFmt->fScaleFactor.h * 10;
      msPic.mx = xZoom;
      msPic.dxaCropLeft = (pictFmt->fCropRect.left * 2000) / xZoom;
      msPic.dxaCropRight = (pictFmt->fCropRect.right * 2000) / xZoom;
      yZoom = pictFmt->fScaleFactor.v * 10;
      msPic.my = yZoom;
      msPic.dyaCropTop = (pictFmt->fCropRect.top * 2000) / yZoom;
      msPic.dyaCropBottom = (pictFmt->fCropRect.bottom * 2000) / yZoom;
      spec = ConvertBorderCode(pictFmt->fRules);
      adorn = pictFmt->fAdorn;
      spec = spec | ((adorn & adnShadow) >> 2);
      msPic.brcTop = ((adorn & (adnLineTop | adnShadow | adnTopHidden)) ? spec : 0);
      msPic.brcLeft = ((adorn & (adnLineLeft | adnShadow)) ? spec : 0);
      msPic.brcBottom = ((adorn & (adnLineBottom | adnShadow | adnBtmHidden)) ? spec : 0);
      msPic.brcRight = ((adorn & (adnLineRight | adnShadow)) ? spec : 0);
      SendString((char *)&msPic, 58);          // 58 is the real size of MS_PIC (ends mid-word)
      SendString(pict->fDrawDiagStr.data + MS_PIC_HDR, pict->fDrawDiagStr.length - MS_PIC_HDR);
      ((MS_FIB *)fFib)->fHasPic = 1;
    }
#ifdef TRACE
    else
    {
      SysBeep(0);
    }
#endif
  }
}

// ------------------------------------------------------------------------
void _TWordSender::SendDocProps()
{
  TTextDocument document = TTextDocument(fMainView->fDocument);
  TFormat fmt = fMainView->GetFormatReadOnly(document->fBody);
  char *limit;
  TBodyStyle docStyle;
  MS_DOP dop;

  limit = (char *)memcpy((char *)&dop + 52,
         "\x04\0\x83\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x21\x03\0\0\0", 36);
  limit = (char *)memset(limit - 36, 0, 36);
  limit[16] = 1;
  limit = (char *)memcpy(limit - 16,
         "\x22\x00\x04\x00\x31\x08\x8c\x18\x00\x00\xd0\x02\x00\x00\x68\x01", 16);
  dop.nFtn = document->fFirstFootnote + 1;
  dop.fMirrorMargins = TPagesPrintHandler(document->fDocPrintHandler)->fSameInterior ^ 1;
                                   // 11/09/96 [27081] support mirrored page margins
  docStyle = TBodyStyle(fmt->GetCompositeStyle(document->fBody));
  if (docStyle->tag.docStyle.fEndNotes)
    dop.fpc = 0;
  if (docStyle->tag.docStyle.fEndChapter)
    dop.epc = 0;
  if (docStyle->fHyphenate)
    dop.fAutoHyphen = 1;
  if (document->fDfltTab != 0)
    dop.dxaTab = FromFixed(document->fDfltTab * 2);  // 17/10/96 [27112]
  FreeIfObject(docStyle);   // cannot fail while object on stack, so no need to catch failures
  dop.fFacingPages = document->fLeftRightHdr | document->fLeftRightFtr;
  SendString(limit, sizeof(MS_DOP) - FIB101);
}

// ------------------------------------------------------------------------
static int SendBlankHF()
{
  return -1;  // needs to be: GetSpaceUsed() - temp;
}

// ------------------------------------------------------------------------
int _TWordSender::SendFieldPosns(int startCP, int lenCP, int limit)
{
  // 25/09/96 [27096] Support 'fields' on Word export
  int hdlSize = GetHandleSize(fFldPos);
  int kk;
  int oneDone = 0;
  int offs;
  PFldPos fldEntry;

  for (kk = 0; kk < hdlSize; kk += sizeof(TFldPos))
  {
    fldEntry = PFldPos((char *)fFldPos + kk);

    // check textOffset in range startCP -> (startCP + lenCP)
    offs = fldEntry->textOffset - startCP;
    if ((unsigned int)offs < lenCP)
    {
      SendString((char *)&offs, 4);
      if (fldEntry->fldSepmark >= 0)
      {
        offs = fldEntry->fldSepmark - startCP;
        SendString((char *)&offs, 4);
      }
      offs = fldEntry->fldEndmark - startCP;
      SendString((char *)&offs, 4);
      oneDone = 1;
    }
  }
  if (oneDone)
  {
    // fields table needs a limit terminator
    offs = limit - startCP;
    SendString((char *)&offs, 4);
  }
  // repeat the process, adding a 2-byte field descriptor for each field delimiter
  for (kk = 0; kk < hdlSize; kk += sizeof(TFldPos))
  {
    fldEntry = PFldPos((char *)fFldPos + kk);

    offs = fldEntry->textOffset - startCP;
    if ((unsigned int)offs < lenCP)
    {
      int hasSep = 0;

      _TSender::SendChar(MS_FldBegin);
      _TSender::SendChar(fldEntry->fieldType);
      if (fldEntry->fldSepmark >= 0)
      {
        _TSender::SendChar(MS_FldSep);
        _TSender::SendChar(255);
        hasSep = 0x80;
      }
      _TSender::SendChar(MS_FldEnd + 0x80);
                   // add 0x80 (not in spec) to stop Word displaying the field names
      _TSender::SendChar(hasSep);
    }
  }
  return GetSpaceUsed();
}

// ------------------------------------------------------------------------
void _TWordSender::SendWordData()
{
  MS_FIB *fib = ((MS_FIB *)fFib);
  char *limit;
  PSed sedTable;
  int temp;
  Handle binPages[2];    // cc objects to volatile variables
  FailInfo fi;

  binPages[kCHPX] = binPages[kPAPX] = NULL;
  CatchFailures(&fi);

  fib->ccpText = GetSpaceUsed() - fib->fcMin; // length of main doc text stream

#ifdef FN
  // do footnotes
  SendWordFile(TExpressionDocument(fMainView->fDocument),
                 TExpressionDocument(fMainView->fDocument)->fFootnotes, NULL, NULL, this);
  temp = GetSpaceUsed();
  fib->ccpFtn = (temp - fib->ccpText - fib->fcMin);
#else
  temp = GetSpaceUsed();
#endif

  // header/footer text
  limit = (char *)fSed + GetHandleSize(fSed);
  for (sedTable = PSed(fSed); sedTable < PSed(limit); sedTable++)
  {
    TExpressionDocument doc = TExpressionDocument(fMainView->fDocument);
    TBodyFormat sectFmt = TBodyFormat(fMainView->GetFormatReadOnly(sedTable->u.sectCurr));
    THFVisibility vis = sectFmt->GetHFVisibility(sedTable->u.sectCurr);

    memset(sedTable->hfOffsets, 255, 24);
    if (fMainView->fHeaderMargin > 0)
    {
      if ((doc->fLeftRightHdr | doc->fLeftRightFtr) != 0 && vis != kHF1stChap)
      {
        sedTable->hfOffsets[0] = GetSpaceUsed() - temp;
        SendWordFile(doc, doc->fLeftHeader, NULL, NULL, this);
      }
      sedTable->hfOffsets[1] = GetSpaceUsed() - temp;
      SendWordFile(doc, doc->fRightHeader, NULL, NULL, this);
    }
    if (fMainView->fFooterMargin > 0)
    {
      if ((doc->fLeftRightHdr | doc->fLeftRightFtr) != 0 && vis != kHF1stChap)
      {
        sedTable->hfOffsets[2] = GetSpaceUsed() - temp;
        SendWordFile(doc, doc->fLeftFooter, NULL, NULL, this);
      }
      sedTable->hfOffsets[3] = GetSpaceUsed() - temp;
      SendWordFile(doc, doc->fRightFooter, NULL, NULL, this);
    }
    if (fMainView->fHeaderMargin > 0)
    {
      if (vis == kHFAllBut1stChap)
      {
        sedTable->hfOffsets[4] = SendBlankHF();
      }
      else if (vis == kHF1stChap)
      {
        sedTable->hfOffsets[4] = sedTable->hfOffsets[0];
        sedTable->hfOffsets[0] = -1;
      }
    }
    if (fMainView->fFooterMargin > 0)
    {
      if (vis == kHFAllBut1stChap)
      {
        sedTable->hfOffsets[5] = SendBlankHF();
      }
      else if (vis == kHF1stChap)
      {
        sedTable->hfOffsets[5] = sedTable->hfOffsets[2];
        sedTable->hfOffsets[2] = -1;
      }
    }
  }
  fib->ccpHdr = temp;
  temp = GetSpaceUsed();
  if (temp > fib->ccpHdr)
  {
    SendParaBreak();  // see p50
    InsertPapxCr(temp);         // 19/09/96 [27090] Insert a papx entry for dummy paragraph
    temp++;
  }
  fib->ccpHdr = temp - fib->ccpHdr;
  if (temp > fib->ccpText + fib->fcMin)
  {
    SendParaBreak();  // see p77
    InsertPapxCr(temp);         // 19/09/96 [27090] Insert a papx entry for dummy paragraph
    temp++;
  }
  fib->fcMac = temp;

  BuildStyleSheetIndex();

  // SEPX data
  SendSepx(limit);

  // pictures
  SendPix();

  // embedded objects

  // FKPs for CHPs
  // first add zeroes up to next page boundary and set fib->pnChpFirst to new page number
  temp = GetSpaceUsed();
  temp -= (fib->pnChpFirst = ((temp + 511) >> 9)) << 9;
  for (; temp < 0; temp++)
    SendChar(0);

  binPages[kCHPX] = SaveFPK(1);

  // FKPs for PAPs
  fib->pnPapFirst = GetSpaceUsed() >> 9;   // already padded to page boundary
  fib->cpnBteChp = fib->pnPapFirst - fib->pnChpFirst;
  binPages[kPAPX] = SaveFPK(7);

  // set up start of style sheet and size/number of pages in papx (already padded to page)
  fib->fcStshf = fib->fcStshfOrig = GetSpaceUsed();
  fib->cpnBtePap = (fib->fcStshf >> 9) - fib->pnPapFirst;

  // Style sheet
  SaveStyleSheet();
  fib->fcPlcffndRef = GetSpaceUsed();
  fib->lcbStshf = fib->lcbStshfOrig = fib->fcPlcffndRef - fib->fcStshf;

#ifdef FN
  // footnote refs (fib->fcPlcffndRef set up above)
  temp = GetHandleSize(fFnRefs);
  if (temp != 0)
  {
    int fnnum;

    SendString((char *)fFnRefs, temp);
    fnnum = fib->ccpText + fib->ccpFtn + fib->ccpHdr + 1;   // p50
    SendString((char *)&fnnum, 4);
    temp >>= 2;
    fib->lcbPlcffndRef = temp * 6 + 4;
    for (fnnum = 1; fnnum <= temp; fnnum++)
      SendString((char *)&fnnum, 2);
  }
#endif

  // footnote text pos
  fib->fcPlcffndTxt = fib->fcPlcffndRef + fib->lcbPlcffndRef;

#ifdef FN
  temp = GetHandleSize(fFnTxts);
  if (temp != 0)
  {
    int idx;
    int endOffsets[2];

    for (idx = 0; idx < temp; idx += 4)
      *(int *)((char *)fFnTxts + idx) -= (fib->ccpText + fib->fcMin);  // get offset in fn area
    SendString((char *)fFnTxts, temp);
    endOffsets[1] = fib->ccpFtn;        // 19/09/96 [27088]
    endOffsets[0] = fib->ccpFtn - 1;
    SendString((char *)endOffsets, 8);
    // SendString((char *)&fib->ccpFtn, 4);
    // idx = fib->ccpFtn + 1;
    // SendString((char *)&idx, 4);
    fib->lcbPlcffndTxt = temp + 8;
  }
#endif

  // annotations
  fib->fcPlcfandRef = fib->fcPlcffndTxt + fib->lcbPlcffndTxt;
  fib->fcPlcfandTxt = fib->fcPlcfandRef;

  // section table
  fib->fcPlcfsed = fib->fcPlcfandTxt;
  for (sedTable = PSed(fSed); sedTable < PSed(limit); sedTable++)
    SendString((char *)&sedTable->textOffset, 4);
  temp = fib->fcMac - 0x300;
  SendString((char *)&temp, 4);

  for (sedTable = PSed(fSed); sedTable < PSed(limit); sedTable++)
  {
    int m1 = -1;

    SendString((char *)&gZeroRect, 2);
    SendString((char *)&sedTable->u.sectFP, 4);
    SendString((char *)&gZeroRect, 2);
    SendCString("\xff\xff\xff\xff");   
        // 10/09/96 [27074] Send -1 for Mac Print rec so that paper orientation is not ignored
  }
  fib->fcpgdMother.fcPgd = GetSpaceUsed();
  fib->lcbPlcfsed = fib->fcpgdMother.fcPgd - fib->fcPlcfsed;

  fib->fcpgdMother.fcBkd = fib->fcpgdMother.fcPgd;

  // paragraph height table (not written by third parties)
  fib->fcPlcfphe = fib->fcpgdMother.fcPgd;
  fib->fcPlcfsea = fib->fcPlcfphe;
  fib->fcPlcfpad = fib->fcPlcfsea;

  // glossary name string table and entry text position table
  fib->fcPlcfglsy = fib->fcSttbfglsy = fib->fcPlcfpad;

  // header text position table
  fib->fcPlcfhdd = fib->fcPlcfglsy;
  for (sedTable = PSed(fSed); sedTable < PSed(limit); sedTable++)
  {
    int *hfOffsets = sedTable->hfOffsets;
    int *hfOffsetsEnd = hfOffsets + 6;

    for (; hfOffsets < hfOffsetsEnd; hfOffsets++)
      if (*hfOffsets >= 0)
        SendString((char *)hfOffsets, 4);
  }
  SetHandleEmpty(&fSed);  // finished with sed data for this pass
  temp = GetSpaceUsed();
  if (temp > fib->fcPlcfhdd)      // save the end of last header, plus end of hdd text positions
  {
    int endHdd = fib->ccpHdr - 1;

    SendString((char *)&endHdd, 4);
    endHdd += 3;
    SendString((char *)&endHdd, 4);
    temp += 8;
    fib->lcbPlcfhdd = temp - fib->fcPlcfhdd;
  }

  // bin table for CHP FKPs
  fib->fcPlcfbteChpx = temp;
  if (binPages[kCHPX])
    SendString((char *)binPages[kCHPX], GetHandleSize(binPages[kCHPX]) - 2);
  ClearHandle(&binPages[kCHPX]);
  fib->fcPlcfbtePapx = GetSpaceUsed();
  fib->lcbPlcfbteChpx = fib->fcPlcfbtePapx - fib->fcPlcfbteChpx;

  // bin table for PAP FKPs
  if (binPages[kPAPX])
    SendString((char *)binPages[kPAPX], GetHandleSize(binPages[kPAPX]) - 2);
  ClearHandle(&binPages[kPAPX]);
  fib->fcSttbfffn = GetSpaceUsed();
  fib->lcbPlcfbtePapx = fib->fcSttbfffn - fib->fcPlcfbtePapx;

  // table of font name strings
  SendString((char *)&fib->lcbSttbfffn, 2);
  SendFontNameStrings();

  fib->fcPlcffldMom = GetSpaceUsed();
  fib->lcbSttbfffn = fib->fcPlcffldMom - fib->fcSttbfffn;

  // table of field positions (main doc)
  fib->fcPlcffldHdr = SendFieldPosns(fib->fcMin, fib->ccpText, fib->fcMac);
  fib->lcbPlcffldMom = fib->fcPlcffldHdr - fib->fcPlcffldMom;

  // table of field positions (header subdoc)
  fib->fcPlcffldFtn =
           SendFieldPosns(fib->fcMin + fib->ccpText + fib->ccpFtn, fib->ccpHdr, fib->fcMac);
  fib->lcbPlcffldHdr = fib->fcPlcffldFtn - fib->fcPlcffldHdr;

  // table of field positions (footnote subdoc)
  fib->fcPlcffldAtn = SendFieldPosns(fib->fcMin + fib->ccpText, fib->ccpFtn, fib->fcMac);
  fib->lcbPlcffldFtn = fib->fcPlcffldAtn - fib->fcPlcffldFtn;

  // table of field positions (annotation subdoc)
  // size left as zero as no annotations yet

  // table of field positions (macro subdoc)
  fib->fcPlcffldMcr = fib->fcPlcffldAtn;

  // table of bookmark name strings
  fib->fcSttbfbkmk = fib->fcPlcffldMcr;

  // table recording beginning CPs of bookmarks
  fib->fcPlcfbkf = fib->fcSttbfbkmk;

  // table recording limit CPs of bookmarks
  fib->fcPlcfbkl = fib->fcPlcfbkf;

  // recording of command data structures
  fib->fcCmds = fib->fcPlcfbkl;

  // macro text position table

  // table of macro name strings

  // data structure recording the print environment
  fib->fcPrDrvr = fib->fcPrEnvPort = fib->fcPrEnvLand = fib->fcCmds;

  // window state structure
  fib->fcWss = fib->fcPrDrvr;

  // document properties record
  fib->fcDop = fib->fcWss;
  SendDocProps();
  fib->lcbDop = sizeof(MS_DOP);

  // table of associated strings
  fib->fcSttbfAssoc = fib->fcDop + sizeof(MS_DOP);

  // name of original (for autosave)
  fib->fcAutosaveSource = 0;

  fib->fbMac = GetSpaceUsed();

  SetHandleEmpty(&fPapx);
  SetHandleEmpty(&fFnRefs);
  SetHandleEmpty(&fFnTxts);
  SetHandleEmpty(&fPix);
  SetHandleEmpty(&fFldPos);

  Success(&fi);
  return;

Rescue:
  DisposIfHandle(binPages[kPAPX]);
  DisposIfHandle(binPages[kCHPX]);
  ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
void _TWordSender::SendWordSpecial(int ch)
{
  int cp = GetSpaceUsed() - 0x300;

  InsertIntoHandle(&fFnRefs, MAXLONGINT, &cp, 4);
  _TSender::SendChar(-ch);
}

// ------------------------------------------------------------------------
void _TWordSender::SendChar(int ch)
{
  if (ch < 0)
    SendWordSpecial(ch);
  else if (ch == chLineFeed)
    _TSender::SendChar(MS_LineBreak);
  else
  {
    unsigned int adjCh = ch - 0x81;

    if (adjCh < 0xa0 - 0x81)
      ch = ggArcToWindows[adjCh];    // 16/09/96 [27085] for quotes, bullet and em-dash, etc
    _TSender::SendChar(ch);
  }
}

// ------------------------------------------------------------------------
void _TWordSender::InsertPapxCr(int paraPos)
{
  TParaPos pp;
  PParaPos prevPp = PParaPos((char *)fPapx + GetHandleSize(fPapx) - sizeof(pp));

  // find preceeding paragraph entry - it does not matter which one in this case
  while (Curr_fType(prevPp->paraCurr) != kTextStruct && prevPp != PParaPos(fPapx))
    prevPp--;
  pp.textOffset = paraPos;
  pp.paraCurr = (prevPp->paraCurr & 0xffff00ff) | 0x400;
  InsertIntoHandle(&fPapx, MAXLONGINT, &pp, sizeof(pp));
}

// -----------------------------------------------------------------------
static int WriteSectionMark(TWordSender sender, TCurrency currency)
{
  TSed sed;
  int hdlSize;

  sed.textOffset = sender->GetSpaceUsed() - 0x300;
  sed.u.sectCurr = currency;
  hdlSize = GetHandleSize(sender->fSed);
  if (hdlSize == 0 ||
      ((TSed *)((char *)sender->fSed + hdlSize - sizeof(TSed)))->textOffset != sed.textOffset)
  {
    // ignore a chapter/section at very start of doc
    if (hdlSize != 0)
    {
      sender->SendParaBreak();                // 09/10/96 works better with cr before section end
      sender->InsertPapxCr(sed.textOffset + 0x301); // ... and insert a papx entry for dummy para
      sender->SendChar(MS_PageBreak);
      sed.textOffset += 2;
    }
    InsertIntoHandle(&sender->fSed, MAXLONGINT /* at end */, &sed, sizeof(TSed));
    return TRUE;
  }
  return FALSE;
}

// ------------------------------------------------------------------------
static void DoSendWordData(TStructure self, TCurrency currency, long pos,
      TCursorNode anchor, TCursorNode activeEnd, PWordSaveItems info,
      TCursorNode parentAnchor, TCursorNode parentActiveEnd)
{
  TWordSender sender = TWordSender(info->sender);
  TStructure aStruct = TTextDocument(info->mainView->fDocument)->GetStructureReadOnly(currency);
  int last = aStruct->SendAlienData(currency, info, &self);

  if (self != NULL)
  {
    int kind = self->GetKind();

    if (kind == kColumns)
    {
      int spanCount = self->GetAlienTerm(pos, parentAnchor, parentActiveEnd);
      int limit = abs(spanCount);

      do
      {
        sender->SendChar(MS_CellMark);
        limit--;
      } while (limit > 0 && (sender->StyleChange(currency | 0x200), TRUE)); // indicates spanner

      if (spanCount >= 0)
      {
        sender->StyleChange(currency | 0x100); // so Word output knows that was the end of row
        sender->SendChar(MS_CellMark);
      }
    }
    else if (kind == kDocument || kind == kHeader || kind == kFooter
#ifdef FN
                      || kind == kNoteSet     // 18/09/96 [27089] Cr after note areas
#endif
                       )
    {
      if (pos == self->GetSize())
      {
        int textOffset;
        PParaPos prevPp =
               PParaPos((char *)sender->fPapx + GetHandleSize(sender->fPapx) - sizeof(TParaPos));

        textOffset = prevPp->textOffset + 1;
        if ((prevPp->paraCurr & 0x100) != 0 ||  // 10/09/96 if last thing is the end of a table
          (Curr_fType(prevPp->paraCurr) != kTextStruct /* &&
                                 (sender->SendParaBreak(), TRUE)*/))
                                                           // 09/10/96 ... or pic, etc.
        {
          sender->InsertPapxCr(textOffset);
          textOffset++;
        }
        sender->SendParaBreak();            // very end of document (insert return regardless)
        if (kind != kDocument)
        {
          // end of header/footer seems to need whole lotta extra undocumented stuff
          sender->SendParaBreak();            // Word seems to like 2 0ds at the end of HFs
          sender->InsertPapxCr(textOffset);
        }
      }
      else
      {
        if (aStruct->GetKind() <= kSection)   // end of Chapter/section at document level
          WriteSectionMark(sender, currency); // section mark if chap/sect not at end of doc
        else
        {
          if (last != 0)       // a body or para (which has outstanding terminator to do)
          {
            TCurrency followingItem = TBodyStructure(self)->GetBodyItem(pos + 1);

            // check next item for section (in which case it will store appropriate terminator)
            if (Curr_fType(followingItem) != kBodyStruct ||
                 TTextDocument(info->mainView->fDocument)->
                                   GetStructureReadOnly(followingItem)->GetKind() > kSection)
              sender->SendParaBreak();            // insert (last was a para) or non-section
          }
        }
      }
    }
    else if (Curr_fType(aStruct->fParent) == kBodyStruct)      // kind <= kFigure)
    {
      if (pos == self->GetSize() || Curr_fType(currency) == kPictStruct)
        return; // leave responsibility to calling body if at the end of a body

      if (kind <= kSection && TBodyStructure(self)->fHeadingType == kSideHeading && pos == 1)
        sender->SendChar(MS_ColBreak);
      else
        sender->SendParaBreak();
    }
    else if (last != 0)
      sender->SendChar(last);
  }
}

// -----------------------------------------------------------------------
int _TStructure::SendStructWordData(TCurrency currency, PWordSaveItems info, void *state)
{
  Iterate(currency, PWordStateData(state)->anchor, PWordStateData(state)->activeEnd, TRUE, this,
               DoStep(DoSendWordData), info, PWordStateData(state)->anchor,
               PWordStateData(state)->activeEnd);
  return 0;
}

#define kBitFont           0
#define kBitSize           1
#define kBitFace           2
#define kBitEmphasis       3
#define kBitCaps           4
#define kBitAlignment      5
#define kBitLeading        6
#define kBitSpaceBefore    7
#define kBitSpaceAfter     8
#define kBitRuler          9
#define kBitLeftMgn        10
#define kBitRightMgn       11
#define kBitIndent         12
#define kBitTabs           13
#define kBitCols           14
#define kBitColSep         15
#define kBitAdornment      16
#define kBitHyphenate      17
#define kBitLanguage       18
#define kBitColour         19
#define kBitOwnSpaceBefore 20
#define kBitOwnSpaceAfter  21
#define kBitOwnAdornment   22
#define kBitOwnAlignment   23
#define kBitHasSpaceBefore 24
#define kBitHasSpaceAfter  25
#define kBitHasAdornment   26
#define kBitHasAlignment   27
#define kBitAutoIndent     28
#define kBitBullet         29
#define kBitOwnMargins     30
#define kBitHasMargins     31

// -----------------------------------------------------------------------
static Handle StoreTabSprm(TStyleFormat self, Handle handle)
{
  int delTot = 0;
  int addTot = 0;
  char buffer[254];
  short tdel[50];
  short tadd[50];
  char tds[50];
  char *p;

  for (int i = 1; i <= self->fSize; i++)
  { 
    PFTabInfo inf = PFTabInfo(self->At(i));

    if (inf->fKind <= kMarkTab)
    {
      if (inf->fDeleted)
      {
        tdel[delTot++] = (inf->fStop / 500);
      }
      else
      {
        int filler;
        char *p = inf->fFiller;

        while ((filler = *(p++)) == ' ') {}   // skip any leading spaces
        if (filler == '.')
          filler = 1;
        else if (filler == '-')
          filler = 2;
        else if (filler == '_')
          filler = 3;
        else if (filler != 0)
          filler = 4;
        tds[addTot] = inf->fKind + (filler << 3);
        tadd[addTot++] = (inf->fStop / 500);
      }
    }
  }
  p = buffer;
  *(p++) = sprmPChgTabsPapx;
  *(p++) = delTot * 2 + addTot * 3 + 2;
  *(p++) = delTot;
  p = (char *)memcpy(p, tdel, delTot * 2) + delTot * 2;
  *(p++) = addTot;
  p = (char *)memcpy(p, tadd, addTot * 2) + addTot * 2;
  memcpy(p, tds, addTot);
  return AppendToHandle(handle, buffer[1] + 2, buffer);
}

// -----------------------------------------------------------------------
static int FindWordColor(int colour)
{
  wr_os_regset r;

  if ((colour & 0xffffff00) == 0)
    return -1;        // Black => Auto?

  r.r[0] = colour;
  r.r[1] = 12;      // a 16 colour mode
  r.r[2] = (int)(gWordColTab + 1);
  wr_wimpt_noerr(wr_os_swix(0x40745 /*ColourTrans_ReturnGCOLForMode*/, &r));
  return r.r[0];
}

// -----------------------------------------------------------------------
Handle _TStyleFormat::ReturnWordSprm(Handle handle, int type, int sprmKind)
{
  int defined = fDefined;
  int bitnum;
  int attr;
  Fixed leftMargin;
  Fixed rightMargin;
  Fixed indentation;

  if (type == kList)
  {
    // ????
    // fDefined &= ~kHasMargins;    // take margins from inherited list (body) style
    defined |= kSpaceAfter;
    defined |= kSpaceBefore;
  }
  leftMargin = GetLeftMargin();
  rightMargin = GetRightMargin();
  indentation = GetIndentation();
  fDefined = defined;
  if (leftMargin >= 0)
    defined |= kLeftMgn;
  if (rightMargin >= 0)
    defined |= kRightMgn;
  if (indentation >= 0)
    defined |= kIndent;
  if (GetSize() > 0)
    defined |= kTabs;

  for (attr = kFont, bitnum = 0; attr <= kBullet; attr = (attr << 1), bitnum++)
    if ((defined & attr) != 0)
    {
      int keyId = 0;
      int value = 1;
      Fixed fixValue = -1;

      switch (bitnum)  // 06/11/92 attr)
      {
      case kBitFont:
        value = fTextFont - 1;
        // 02/09/96 [27056]: if (value != 0)
          keyId = sprmCFtc;
        break;

      case kBitSize:
        value = fTextSizeY >> 3;
        // 02/09/96 [27056]: if (value != 20)
          keyId = sprmCHps;
        break;

      case kBitColour:
        value = FindWordColor(fColour) + 1;
        // 02/09/96 [27056]: if (value != 0)
          keyId = sprmCIco;
        break;

      case kBitFace:
        if (sprmKind == kCHPX)
        {
          if (fTextFace & kBold)
            handle = StoreSprm(handle, sprmCFBold, 0x81);
          if (fTextFace & kItalic)
            handle = StoreSprm(handle, sprmCFItalic, 0x81);
          if (fTextFace & (kSuperscript | kSubscript))
            handle = StoreSprm(handle, sprmCHpsPos, fTextFace & kSuperscript ? 6 : -6);
          value = fTextFace & 3;
          if (value == kUnderline)
            keyId = sprmCKul;
          else if (value == kStrikeOut)
            keyId = sprmCFStrike;
          else
            keyId = 0;
          value = 0x81;
        }
        break;

      case kBitCaps: 
        if (fTextCaps == kUppercase)
          keyId = sprmCFCaps;
        break;

      case kBitOwnAlignment:
      case kBitAlignment:
        value = (bitnum == kBitAlignment ? int(fAlignment) : int(fOwnAlignment));
        if (value != kAlignLeft)
          keyId = sprmPJc;
        break;

      case kBitLeading:              // 11/10/96 support line spacing
        value = fLeading * 2;
        if (value != 0)
          keyId = sprmPDyaLine;
        if (Odd(fFixedHeight))
          value = -value;
        value &= 0x0000ffff;
        value |= ((fFixedHeight & 4) << 14);
        break;

      case kBitOwnSpaceBefore:
      case kBitSpaceBefore:
        value = (bitnum == kBitSpaceBefore ? fSpaceBefore : fOwnSpaceBefore) * 2;
        if (value != 0)
          keyId = sprmPDyaBefore;
        break;

      case kBitOwnSpaceAfter:
      case kBitSpaceAfter:
        value = (bitnum == kBitSpaceAfter ? fSpaceAfter : fOwnSpaceAfter) * 2;
        if (value != 0)
          keyId = sprmPDyaAfter;
        break;

      case kBitRuler:
        break;

      case kBitLeftMgn:
        fixValue = leftMargin;
        if (fixValue != 0)
          keyId = sprmPDxaLeft;
        break;

      case kBitRightMgn:
        fixValue = rightMargin;
        if (fixValue != 0)
          keyId = sprmPDxaRight;
        break;

      case kBitIndent:
        fixValue = indentation;
        if (leftMargin >= 0)
          fixValue -= leftMargin;
        if (fixValue != 0)
          keyId = sprmPDxaLeft1;
        break;

      case kBitTabs:
        if (sprmKind == kPAPX)
          handle = StoreTabSprm(this, handle);
        break;

      case kBitCols:
        break;

      case kBitColSep:
        break;

      case kBitOwnAdornment:
      case kBitAdornment:
        if (sprmKind == kPAPX && type != kColumns) // table cell borders are sent in sprmTDefTable
          handle = StoreBorderSprm(this, handle);
        break;

      case kBitHyphenate:
        if (fHyphenate == 0)
          keyId = sprmPFNoAutoHyph;
        break;

      case kBitLanguage:
        value = gLids[fLanguage];
        // 02/09/96 [27056]: if (value != 0)
          keyId = sprmCLid;
        break;

      case kBitAutoIndent:
        break;

      case kBitBullet:
        // keyId = kBulletStr;
        break;
      }
      if ((keyId > 0 && keyId < sprmCFStrikeRM && sprmKind == kPAPX) ||
           (keyId >= sprmCFStrikeRM && keyId <= sprmCFObj && sprmKind == kCHPX))
        handle = StoreSprm(handle, keyId, fixValue == -1 ? value : FromFixed(fixValue * 2));
    }
  return handle;
}

// -----------------------------------------------------------------------
int _TTextStructure::SendTextWordData(TCurrency currency, PWordSaveItems info, void *state)
{
  TWordSender sender = TWordSender(info->sender);
  PPhrase phrase = PPhrase(fPtrToArray);
  PPhrase endPhr = phrase + fSize;
  char *textStart = (char *)phrase + fOffset;
  char *p = textStart;
  char *endP;
  int cp = 0;

#ifdef TRACE
  Assert(fFirstOffset == 0, 607);
#endif
  for (; phrase < endPhr; phrase++)
  {
    // send unsent text before the phrase
    for (endP = textStart + phrase->fCharPos; p < endP; )
      sender->SendChar(*(p++));

    if (phrase->fKind == kWidgetPhrase)
    {
      SendWordFile(fDocument, phrase->tag.fRecNum, NULL, NULL, sender);
                   //PWordStateData(state)->anchor, PWordStateData(state)->activeEnd, sender);
      p++;      // skip widget marker
    }
#ifdef FN
    else if (phrase->fKind == kNotePhrase)
    {
      sender->SendChar(-2);   // insert MS_FnRefMark
      p++;  // skip note marker
    }
#endif
    else if (phrase->fKind == kMacroPhrase)
    {
      TFldPos fldPos;
      int wordFieldType;

      fldPos.fldSepmark = -1;
      switch (phrase->tag.macro.fMacroType)
      {
        case kDate:
          fldPos.fldSepmark = 0;
          wordFieldType = MS_FldCreateDate;
          break;

        case kNewDate:
          wordFieldType = MS_FldDate;
          break;

        case kTime:
          fldPos.fldSepmark = 0;
        case kNewTime:
          wordFieldType = MS_FldTime;
          break;

        case kDocumentTitle:
        case kChapterTitle:
        case kSectionTitle:
          wordFieldType = MS_FldTitle;
          break;

        case kPageNumber:
          wordFieldType = MS_FldPageNumber;
          break;

        case kPagesInDocument:
          wordFieldType = MS_FldDocPages;
          break;

        case kPagesInChap:
          wordFieldType = MS_FldSecPages;
          break;

        //case kMergeField:
        //  break;

        default:
          continue;
      } 
      fldPos.textOffset = sender->GetSpaceUsed();
      sender->_TSender::SendChar(MS_FldBegin);
      sender->_TSender::SendChar(' ');
      fldPos.fieldType = wordFieldType;
      sender->_TSender::SendCString(GetRsrc(wordFieldType, 'j'));
      sender->_TSender::SendChar(' ');
      if (fldPos.fldSepmark == 0)
      {
        fldPos.fldSepmark = sender->GetSpaceUsed();
        sender->_TSender::SendChar(MS_FldSep);
        sender->SendString(p, phrase->fNumChars);
      }
      fldPos.fldEndmark = sender->GetSpaceUsed();
      sender->_TSender::SendChar(MS_FldEnd);
      InsertIntoHandle(&sender->fFldPos, MAXLONGINT, &fldPos, sizeof(TFldPos));
      p += phrase->fNumChars;      // skip macro text
    }
  }
  for (endP = textStart + fCount - 1; p < endP; )    // ignore the final CR
  {
    int ch = *(p++);
    sender->SendChar(ch);
  }
  sender->StyleChange(currency);
  return MS_Return;

#ifdef NEVER
  TCharPos cp1, cp2;
  TSender sender = info->sender;

  cp1 = GetSelectionStartPos(PWordStateData(state)->anchor, PWordStateData(state)->activeEnd);
  cp2 = GetSelectionEndPos(PWordStateData(state)->anchor, PWordStateData(state)->activeEnd);

  // WriteTextLine(info->sender, cp1, cp2);
  volatile Handle textStructBuffer = NULL;
  int paraSize = cp2 - cp1;
  char* charPtr;
  int ch;
  int placeInOrig;
  FailInfo fi;

  IsEmpty();   // SetTextGlobals(this);
  charPtr = GetBuffer(cp1, MAXLONGINT, kLineBreakMixed, textStructBuffer, NULL);
                                                  // paraSize for MAXLONGINT???
  if (charPtr[paraSize - 1] == chReturn)
    paraSize--;                 // do not process the final CR in loop

  CatchFailures(&fi);

  // zonk thru our buffer changing LFs and removing widget chrs (or expanding notes)
  for (placeInOrig = 0; placeInOrig < paraSize; placeInOrig++)
  {
    ch = charPtr[placeInOrig];
    if (ch == chLineFeed)
    {
        sender->SendLineBreak();  // ch = chReturn;
    }
    else if (ch != chWidget)
      sender->SendChar(ch);
    else
    {
      int idx = FindPhraseGen(placeInOrig + cp1, kWidgetPhrase);

      if (idx != 0)
      {
        TCurrency widgetCurr = PPhrase(At(idx))->tag.fRecNum;
        TAlienSaveItems alienSaveInfo;

        alienSaveInfo.sender = sender;
        alienSaveInfo.mainView = fDocument->ActiveMainView();
        alienSaveInfo.funcNameList = NULL;
        GetStructureReadOnly(widgetCurr)->SendAlienData(widgetCurr, &alienSaveInfo, NULL);
                // beware that last parameter cannot be used when calling in-line pic (or Maths)
      }
#ifdef FN
      {
        int idx = FindPhraseGen(placeInOrig + cp1, kNotePhrase);

        if (idx > 0)
          sender->SendChar(-2);   // insert MS_FnRefMark
      }
#endif
    }
  }
  Success(&fi);
  FreeBuffer(textStructBuffer);

  TWordSender(info->sender)->StyleChange(currency);
  return MS_Return;

Rescue:
  FreeBuffer(textStructBuffer);
  ContinueFailure(&fi);
#endif
}

#ifdef MATHS
// -----------------------------------------------------------------------
int _TMathStructure::SendMathWordData(TCurrency currency, PWordSaveItems info, void *state)
{
  if (state)                         // 06/09/96 [27069] ignore in-line maths for time being
    return SendStructWordData(currency, info, state);
  return 0;
}
#endif

// -----------------------------------------------------------------------
int _TBodyStructure::SendBodyWordData(TCurrency currency, PWordSaveItems info, void *state)
{
  TWordSender sender = TWordSender(info->sender);

  if (fKind == kDocument || (fKind <= kSection && fParent == fDocument->fBody))
  {
    WriteSectionMark(sender, currency);
  }
  else if (fKind == kList)
  {
    // 23/09/96 [27093] use fUndoStyle as a temporary location for calculating list level
    TStructure parent = fDocument->GetStructureReadOnly(fParent);

    if (parent->GetKind() == kList)
    {
      if (parent->fUndoStyle == 10)
        parent->fUndoStyle = 1;
      fUndoStyle = parent->fUndoStyle + 1;
    }
    else
     fUndoStyle = 10;
  }
#ifdef FN
  else if (fKind == kFootnote)
  {
    int cp = sender->GetSpaceUsed();

    InsertIntoHandle(&sender->fFnTxts, MAXLONGINT, &cp, 4);
    sender->SendChar(MS_FnRefMark);           
    sender->StyleChange(currency);  // so StoreFPK can identify footnote text
  }
#endif
  SendStructWordData(currency, info, state);
  return MS_Return;
}

// -----------------------------------------------------------------------
Handle _TBodyStyle::ReturnWordSprm(Handle handle, int type, int sprmKind)
{
  if (type <= kSection && sprmKind == kSEPX)
  {
    int totColsM1 = ((fDefinedInBody & kHeadingType) != 0 && fHeadingType == kSideHeading) ? 1 :
                                                        GetTotalColumns() - 1;

    if (totColsM1)
      handle = StoreSprm(handle, sprmSCcolumns, totColsM1);

    for (int attr = 0; attr < 10; attr++)
    {
      int sprmCode = 0;
      int sprmVal = 0;

      if ((fDefinedInBody & (1 << attr)) != 0)
      {
        switch (attr)
        {
        case 0:  // kBalanced:
          break;

        case 1:  // kColSepRule:
          if (fColSepRule.fRule != kNoRule)
          {
            sprmCode = sprmSLBetween;
            sprmVal = 1;
          }
          break;

        case 2:  // kJustify:
          if (fJustify)
          {
            sprmCode = sprmSVjc;
            sprmVal = 2;
          }
          break;

        case 3:  // kHeadingType:
          if (fHeadingType == kSideHeading)
          {
            handle = StoreSprm(handle, sprmSFEvenlySpaced, 0);
            handle = StoreSprm(handle, sprmSDxaColWidth, GetHeadingWidth(0, gZeroRect) << 9);
            handle = StoreSprm(handle, sprmSDxaColSpacing, (GetSideSep() / 500) << 8);
            //sprmCode = sprmSDxaColWidth;
            //sprmVal = ;
          }
          // set part style???
          break;

        case 4:   // kPageAlign
          if (!fNewPage || (fBodyAlignment != -2 && fBodyAlignment != 0))
          {
            sprmCode = sprmSBkc;
            if (fNewPage)
              sprmVal = (fBodyAlignment > 0 ? 3 /* next even page */ : 4 /* odd page */);
          }
          break;

        case 5:   // kHeadingChgd:
          break;

        case 6:   // kHFVisibility
          break;

        case 7:   // kRomanPages
          if (fRomanPages)
          {
            sprmCode = sprmSNfcPgn;
            sprmVal = 2;
          }
          break;

        case 8:  // kCaption:
          break;

        case 9:  // kEndNotes:
          if (!tag.docStyle.fEndNotes)
            sprmCode = sprmSFEndnote;
          break;

        // case 10:  // kAutoNumber
        //  break;
        }
        if (sprmCode)
          handle = StoreSprm(handle, sprmCode, sprmVal);
      }
    }
  }
#ifdef AUTONUM
  else if (type == kList && sprmKind == kPAPX)
  {
    // Auto-number list descriptor
    MS_ANLD anld;
    char buff[sizeof(MS_ANLD) + 2];
    char *ans = anld.rgchAnld;
    int lvl = 11;             // bullet
    int currListLevel = Min(gCurrListLevel, 10);  // 23/09/96 [27093]

    memset(&anld, 0, sizeof(MS_ANLD));
    anld.nfc = 255;
    anld.iStartAt = 1;
    anld.fHang = 1;
    if (fBullet == 1)
    {
      anld.nfc = 0;    // plain autonumber
      lvl = currListLevel;
    }
    else if (fBullet == 2)
    {
      int chr;
      char *format = fAutoCustom;
      int after = FALSE;

      if (*format == 0)
        lvl = 12;       // 20/09/96 [27092] blank bullets => level 12 (not in spec)
      else
        for ( ; (chr = *(format++)) != 0; )
        {
          if (chr == '%')
          {
            int nfc = 0;

            switch (*(format++))
            {
              case 0:
                format--;
                break;

              case '>':                // %> to right justify
                anld.jc = 2;
                continue;

              case '{':
                anld.iStartAt = atoi(format);    // 10/05/96 [27026] %{n} start number
                while (*(format++) != '}' && *format != 0) {}
                continue;

              case 'a': nfc++;
              case 'A': nfc++;
              case 'i': nfc++;
              case 'I': nfc++;
              case '1':
              default:
                anld.nfc = nfc;
                after = TRUE;
                lvl = currListLevel;          // an auto number
                continue;
            }
          }
          *(ans++) = CvtCharToWindows(chr);
          ((char *)&anld)[after + 1]++;
        }
    }
    else
    {
      if (fBullet != 0)
      {
        ans[0] = CvtCharToWindows(fBullet);
                                 // 01/10/96 for saving 'native EW' bullet lists
        anld.cbTextBefore = 1;
      }
    }
    // anld.dxaIndent = FromFixed(fLeftMargin * 2);  // need para indents!!!!
    anld.ftc = fBulletFont - 1;
    buff[0] = sprmPAnld;
    buff[1] = sizeof(MS_ANLD);
    memcpy(buff + 2, &anld, sizeof(MS_ANLD));
    handle = StoreSprm(handle, sprmPNLvlAnm, lvl);
    handle = AppendToHandle(handle, sizeof(MS_ANLD) + 2, buff);
    // ???? List indents     handle = _TStyleFormat::ReturnWordSprm(handle, type, sprmKind);
  }
#endif
  return handle;
}

// -----------------------------------------------------------------------
int _TColumnStructure::SendColWordData(TCurrency currency, PWordSaveItems info, void *state)
{
  return SendStructWordData(currency, info, state);
}

// -----------------------------------------------------------------------
static Handle SetTableCellFlag(Handle handle)
{
  return StoreSprm(handle, sprmPFInTable, 1);
}

// -----------------------------------------------------------------------
Handle _TColumnStyleFormat::ReturnWordSprm(Handle handle, int type, int sprmKind)
{
  if (sprmKind == kPAPX)
    return SetTableCellFlag(handle);

  return handle;
}

// -----------------------------------------------------------------------
static char *StoreShort(char *p, int value)
{
  *(p++) = value & 255;
  *(p++) = value >> 8;
  return p;
}

// -----------------------------------------------------------------------
Handle _TTableFormat::ReturnWordTabSprm(Handle handle, TCurrency curr, TStyleFormat style)
{
  TStructure childStruct = GetStructureReadOnly(curr);
  TTableStructure tabStruct = TTableStructure(GetStructureReadOnly(childStruct->fParent));
  char tDef[390];
  char *p;
  char *q;
  int row;
  int column;
  int lastSavedCol = 0;
  int offset = GetLeftMargin();
  int cols = Min(32, fNumberOfColumns);   // Word limit of 32 cols
  int matches;
  int spec;
  int adn;
  TCurrency masterCell;
  int spanLimit;
  volatile TStyleFormat rowColStyle = NULL;
  volatile TStyleFormat cellColStyle = NULL;
  TRuleType dfltRowRuleType;
  TRuleType dfltColRuleType;
  FailInfo fi;

  CatchFailures(&fi);

  handle = SetTableCellFlag(handle);
  handle = StoreSprm(handle, sprmPTtp, 1);

  dfltRowRuleType = dfltColRuleType = gDefaultPen;
  rowColStyle = GetRowColStyle(kRowPart, tabStruct->fNumberOfRows, tabStruct);
  matches = FALSE;
  if (rowColStyle == NULL || (rowColStyle->fOwnAdornment & ~adnWordStyle) == 0)
  {
    matches = TRUE;
    // find out whether all the rows except the last have the same same bottom border
    for (row = 1; row < tabStruct->fNumberOfRows; row++)
    {
      ReplaceObject(rowColStyle, GetRowColStyle(kRowPart, row, tabStruct));
      if (rowColStyle && (rowColStyle->fDefined & kOwnAdornment) &&
         (rowColStyle->fOwnAdornment & ~(adnWordStyle | adnLineBottom)) == 0 &&
                  (row == 1 || (*(int *)&rowColStyle->fOwnRuleType == *(int *)&dfltRowRuleType)))
        dfltRowRuleType = rowColStyle->fOwnRuleType;
      else
      {
        matches = FALSE;
        break;
      }
    }
    if (matches)
    {
      // do the same for column styles
      ReplaceObject(rowColStyle,
                             GetRowColStyle(kColPart, tabStruct->fNumberOfColumns, tabStruct));
      if (rowColStyle == NULL || (rowColStyle->fOwnAdornment & ~adnWordStyle) == 0)
      {
        for (column = 1; column < tabStruct->fNumberOfColumns; column++)
        {
          ReplaceObject(rowColStyle, GetRowColStyle(kColPart, column, tabStruct));
          if (rowColStyle && (rowColStyle->fDefined & kOwnAdornment) &&
                (rowColStyle->fOwnAdornment & ~(adnWordStyle | adnLineRight)) == 0 &&
                (column == 1 || (*(int *)&rowColStyle->fOwnRuleType == *(int *)&dfltColRuleType)))
            dfltColRuleType = rowColStyle->fOwnRuleType;
          else
          {
            matches = FALSE;
            break;
          }
        }
      }
    }
  }
  ClearObject(rowColStyle);
  tabStruct->FindCell(curr, row, column);
  if (tabStruct->IsHeadingRow(row))
    handle = StoreSprm(handle, sprmTTableHeader, 1);
  if (matches)
  {
    // store the default borders (sprmTTableBorders)
    CntlAdornment adorn;

    spec = GetBorderCode(style);
    p = tDef;
    *(p++) = sprmTTableBorders;
    if (style->fDefined & kHasAdornment)
      adorn = style->fOwnAdornment;
    else
      adorn = style->fAdornment;
    for (adn = 0; adn < 4; adn++)
      p = StoreShort(p, ((adorn >> adn) & 1) != 0 ? spec : 0);
    p = StoreShort(p, ConvertBorderCode(dfltRowRuleType));
    p = StoreShort(p, ConvertBorderCode(dfltColRuleType));

    handle = AppendToHandle(handle, 13, tDef);
  }
  rowColStyle = (matches ? NULL : GetRowColStyle(kRowPart, row, tabStruct));
  p = (char *)memset(tDef + 4, 0, 316);
  q = p + cols * 2 + 2;
  masterCell = gNullCurrency;
  spanLimit = 0;

  for (column = 1; column <= cols; column++)
  {
    PCellItem cellItem = tabStruct->AtRowCol(row, column);
    int tc;

    if (cellItem->cell == 0)
      tc = 2;          // fMerged
    else
    {
      masterCell = cellItem->cell;
      spanLimit = cellItem->spanCount + column;
      if (cellItem->spanCount > 0)
        tc = 1;          // fFirstMerged
      else
        tc = 0;
    }
    if (tc)
    {
      lastSavedCol = column;
      *q = tc;
    }
    q += 2;
    if (!matches)
    {
      cellColStyle = GetRowColStyle(kColPart, column, tabStruct);

      if (cellColStyle && (cellColStyle->fDefined & kOwnAdornment) != 0)
      {
        int colBorder = GetBorderCode(cellColStyle);

        if ((cellColStyle->fOwnAdornment & adnLineTop) != 0)
          StoreShort(q + 2, colBorder);
        if ((cellColStyle->fOwnAdornment & adnLineBottom) != 0)
          StoreShort(q + 6, colBorder);
      }
      ClearObject(cellColStyle);

      if (rowColStyle && (rowColStyle->fDefined & kOwnAdornment) != 0)
      {
        int rowBorder = GetBorderCode(rowColStyle);

        if ((rowColStyle->fOwnAdornment & adnLineTop) != 0)
          StoreShort(q, rowBorder);
        if ((rowColStyle->fOwnAdornment & adnLineBottom) != 0)
          StoreShort(q + 4, rowBorder);
      }
      lastSavedCol = column;
    }
    if (masterCell)
    {
      int adornEdges;
      TFormat cellFmt = GetFormatReadOnly(masterCell);

      cellColStyle = cellFmt->GetCompositeStyle(masterCell);
#ifdef TRACE
      if (cellColStyle->fAdornment != cellFmt->fAdorn)
        SysBeep(0);
      if (*(int *)(cellColStyle->fDefined & kHasAdornment ? &cellColStyle->fOwnRuleType :
                               &cellColStyle->fRuleType) != *(int *)&cellFmt->fRules)
        SysBeep(0);
#endif
      adornEdges = cellColStyle->fAdornment;
      if (column < spanLimit)
        adornEdges &= ~adnLineRight;
      if (tc == 2)
        adornEdges &= ~adnLineLeft;
      spec = GetBorderCode(cellColStyle);
      // store the borders of the cell, possibly overwriting the row / column styles
      for (adn = 0; adn < 4; adn++)
      {
        if ((cellColStyle->fDefined & kAdornment) && ((adornEdges >> adn) & 1))
        {
          StoreShort(q, spec);
          lastSavedCol = column;
        }
        q += 2;
      }
      ClearObject(cellColStyle);
    }
    else
      q += 8;

    p = StoreShort(p, FromFixed(offset * 2));
    offset += GetColWidth(column);
  }
  StoreShort(p, FromFixed(offset * 2));
  ClearObject(rowColStyle);

  Success(&fi);

  tDef[0] = sprmTDefTable;
  offset = cols * 2 + lastSavedCol * 10 + 4;
  p = StoreShort(tDef + 1, offset);       // NB count is 1 more than stored param size
  *p = cols;
  handle = StoreSprm(handle, sprmTDxaGapHalf, FixRound(fSpare * 2));
  return AppendToHandle(handle, offset + 2, tDef);

Rescue:
  FreeIfObject(cellColStyle);
  FreeIfObject(rowColStyle);
  ContinueFailure(&fi);
}

// -----------------------------------------------------------------------
int _TPictStructure::SendPictWordData(TCurrency currency, PWordSaveItems info, void *state)
{
  TWordSender sender = TWordSender(info->sender);
  int ch;

  if (fPicKind == kPageBreak || fPicKind == kPageFiller)
    ch = MS_PageBreak;      // page break !!!
  else if (fPicKind == kPict)
  {
    // 04/09/96 [27067] suppress output of non-imported pictures
    TPictObject pict = GetPicture();

    if (pict && pict->fSprite != 9)     // TEMP until we can save non-imported pix
      return 0;
    ch = MS_PicMark;       // normal picture (in-line!!!)
  }
  else
    ch = 0;
  sender->SaveCurrChange(currency, IsInLine() ? &sender->fPix : &sender->fPapx);
  if (ch)
    sender->SendChar(ch);
  return 0;
}

// -----------------------------------------------------------------------
Handle _TPictStyle::ReturnWordSprm(Handle handle, int type, int sprmKind)
{
  if (type == kWhiteSpace && sprmKind != kCHPX)
  {
    int size = 160;

    if (fDefinedInPict & kTopCrop)
      size -= fCropRect.top;
    if (fDefinedInPict & kBtmCrop)
      size -= fCropRect.bottom;
    handle = StoreSprm(handle, sprmPPc, 0xe0);
    handle = StoreSprm(handle, sprmPDyaAbs, size * 2);
  }
  else if (sprmKind == kCHPX)
  {
    if (fUserAlign.v != 0)
      handle = StoreSprm(handle, sprmCHpsPos, -(fUserAlign.v / 5));
  }
  return handle;
}

// -----------------------------------------------------------------------
void SendWordFile(TTextDocument doc, TCurrency currency,
                          TCursorNode anchor, TCursorNode activeEnd, TSender sender)
{
  TAlienSaveItems alienSaveInfo;

  alienSaveInfo.sender = sender;
  alienSaveInfo.mainView = doc->ActiveMainView();
  alienSaveInfo.funcNameList = NULL;
  DoSendWordData(NULL, currency, -1, anchor, activeEnd, &alienSaveInfo, NULL, NULL);
}
