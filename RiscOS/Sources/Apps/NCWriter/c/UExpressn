/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#include "os.h"
#include "swis.h"
#include "drawfdiag.h"
#include "drawfobj.h"
#include "drawftypes.h"
#include "win.h"
#include "event.h"
#include "alarm.h"
#include "kernel.h"

// hopefully temporary
#include "bbc.h"

#if DEMO == 0 && ! defined TRACE && ACORNSP == 1
#include "SP.h"
#endif

//#include "UDialog.h"
#include "UCommon.h"
#include "URulerVew.h"
#include "UTextEdit.h"
#include "UBodyEdit.h"
#include "UClipBrd.h"
#include "UTextComm.h"
#if defined CONT || defined INDEX
#include "UIndex.h"
#endif
#include "UPictEdit.h"
#include "PTextComm.h"
#include "PDocument.h"
#include "PApplicat.h"
#include "PBodyEdit.h"
#include "UExpressn.h"
#ifdef SPELL
#include "PSpellChk.h"
#endif
#ifdef TABLES
#include "UPopup.h"
#endif
#include "UColEdit.h"
#include "UTablEdit.h"
#include "UMathEdit.h"
#ifdef MATHS
#include "UMathEvt.h"
#endif
#include "MenuStruct.h"
#ifdef DRAWSAVE
#include "DrawIFace.h"
#endif

#if SIDEBAR == 1
extern int gSplashOver = 0;
#endif

#define PDriver_SelectDriver (0x80158)
#define kUnitsArrayID 4
#define nc gNullCurrency
#define kEditFileReturn 10
#define kEditFileLF 13
#define kMergeDlg 38
#define kNotTable 35
#define kMergeFileEmpty 36
#define kRecvDied 46
#define kUntitledFile 202
#define kNoFields 207
#define kLongestFieldName 31
#define kSaveAs 39
#define kSaveAsNS 41
#define kSaveContents 45
#define gIdundo I_('u', 'n', 'd', 'o')
#define gIdfnam I_('f', 'n', 'a', 'm')
#define gIdvers I_('v', 'e', 'r', 's')
#define gIdicon I_('i', 'c', 'o', 'n')
#define gIdsel  I_( 0,  's', 'e', 'l')

char *gMergePrefix;
char gPadName[32];
char *gPadNamePtr = NULL;
int gTeXInstalled = FALSE;

typedef struct TSaveHandle *PSaveHandle;
typedef struct TSaveHandle
{
   TExpressionDocument doc;
   TSelection          selection;
   int                 msgId;
   CmdNumber           saveCmdNum;
   bool                bounceRam;
   int                 filetype;
   wr_wimp_w           closeWind;
   long                estsize;
   TExpressionDocument clearDoc;
   bool                print;
} TSaveHandle;

#if WORDBANK == 1
#if TALK == 1 && !defined NETWP
// -------------------------------------------------------------------------
static bool DoesOwnKey(TObject ignore, TControlBlock controlBlock)
{
  return controlBlock->OwnsKey(0x200);
}
#endif

// ------------------------------------------------------------------------
bool _TWordListDlg::DoIdle(IdlePhase phase)
{
  if (phase == idleBegin)
  {
    TWindow actWind = gApplication->GetActiveWindow();

    SetDimState(I_('A', 'd', 'd', '1'), actWind == NULL);
#if TALK == 1 && !defined NETWP
    SetDimState(I_('S', 'p', 'e', 'k'),
                       gControlBlockList->LastThat(NULL, (TestObject)DoesOwnKey) == NULL);
#endif
  }
#if TALK == 2
  SetDimState(I_('S', 'p', 'e', 'k'), Speaking() < 0);
#endif
  return _TDialogView::DoIdle(phase);
}
#endif

// -------------------------------------------------------------------------
#ifdef DRAGDROP
TCommand _TExpressionApplication::MakeMoveCommand(TObject pasteSelection,
                                             TDocument sourcedoc, TPasteCommandType type)
{
  if (type <= kSynonymReturned)
     return new _TPasteCommand(TSelection(pasteSelection)->fDocument,
                                                    TTextDocument(sourcedoc), type);
  if (TSelection(pasteSelection)->fDocument == TTextDocument(sourcedoc))
     return new _TMoveCopyCommand(TSelection(pasteSelection)->fDocument, NULL,
        TSelection(pasteSelection), type == kMoveCommand && CmdEnabled(cClear));
                                // 23/05/94 [21814] move -> copy if clear not allowed
  return new _TMoveCopyCommand(TSelection(pasteSelection)->fDocument,
       TTextDocument(sourcedoc), TSelection(pasteSelection), FALSE);
                  // !!! should be type == kMoveCommand);
}
#endif

// ------------------------------------------------------------------------
static void ResetUndo(TObject ignore, TWindow aWindow)
{
   // [21105] 05/11/93 get source window undo button redrawn when Shift Drag between windows
   // TControl undoBtn = TControl(aWindow->FindSubView(gIdundo));

   // if (undoBtn != NULL)
   //   undoBtn->DimState(FALSE, kRedraw);
   aWindow->SetDimState(gIdundo, FALSE);
}

// -------------------------------------------------------------------------
void ClearDragSelection(TDocument doc)
{
   if (CmdEnabled(cClear))  // 23/05/94 [21814] move -> copy if clear not allowed
   {
      gApplication->PerformCommand(new _TCutCopyCommand(TTextDocument(doc), cClear));
      doc->fWindowList->Each(NULL, (DoToObject)ResetUndo);      // [21105] 05/11/93
   }
}


#ifdef TABLES
// 07/12/93 [21133] New for spooled printing
// -------------------------------------------------------------------------
int _TExpressionDocument::MergeRows()
{
   return TColumnStructure(fMergeDoc->GetStructureReadOnly(fMergeData))->fNumberOfRows;
}
#endif

#define gRun I_(' ', 'n', 'u', 'R')

// -------------------------------------------------------------------------
static bool wr_xfersend__pipe_unknowns(wr_wimp_eventstr *e, void *handle)
{
   bool handled = FALSE;   /* unknown not dealt with */
   int testRef = (e->e == wr_wimp_EACK ? e->data.msg.hdr.my_ref : e->data.msg.hdr.your_ref);

   if (testRef == PSaveHandle(handle)->msgId)
   {
      // its our reply or (maybe) not an 17, 18, 19 msg
      wr_wimp_w w = PSaveHandle(handle)->closeWind;
      TExpressionDocument doc = PSaveHandle(handle)->doc;

      if (e->e == wr_wimp_ESEND || e->e == wr_wimp_ESENDWANTACK)
      {
         TSaveInfo info;

         info.msg = NULL;
         info.filetype = PSaveHandle(handle)->filetype;
         info.selection = PSaveHandle(handle)->selection;
         info.fileIsSafe = FALSE;  // alien ram save always is unsafe
         info.print = PSaveHandle(handle)->print;

         switch (e->data.msg.hdr.action)
         {
            case wr_wimp_MRAMFETCH:
               if (!PSaveHandle(handle)->bounceRam)
               {
                  // Receiver wants to do an in-core transfer, and we can do this.
                  info.filename = NULL;
                  doc->AlienSaver(0, &info, e);
                  handled = TRUE;
               }
               break;

            // 07/12/93 [21133] New for spooled printing
            case wr_wimp_MDATASAVEOK:    // otherwise known as DataSaveAck(2)
               info.filename = e->data.msg.data.datasaveok.name;
#ifdef TRACE
               Assert(info.filetype == e->data.msg.data.datasaveok.type, 837);
#endif
               if (e->data.msg.data.datasaveok.estsize >= 0)
                  info.fileIsSafe = TRUE;

               if (info.filetype == kExpressionFile)
                  info.print = FALSE;   // do not spool print here
               doc->Saver(&info, PSaveHandle(handle)->estsize);
               PSaveHandle(handle)->selection = TSelection(info.selection);
                           // 01/08/94 [22014] info.selection may have been freed by Saver!
               wr_wimpt_noerr(SendmessageWantAck(wr_wimp_MDATALOAD,
                      &e->data.msg, e->data.msg.hdr.size, &PSaveHandle(handle)->msgId));

               // 09/11/93 we still need a DATALOADOK or this bounced: handled = TRUE;
               return TRUE;       // 09/11/93 we have handled this event but leave the
                                  // handler to pick up the DATALOADOK or bounced DATALOAD

            case wr_wimp_MPrintFile: // 04/02/94 [21379] avoid spooling on ROS_2
                                  // if we get this we are on RISC_OS2 (else not enabled)
               if (gWimpVersion >= 300)
                 break;      // ignore on ROS_3 (for safety)

            case wr_wimp_MPrintTypeOdd:    // 25/11/93 [21133] print w/o putting file in queue
               if (PSaveHandle(handle)->filetype != kExpressionFile)
                  return TRUE;
               if (PSaveHandle(handle)->saveCmdNum == cNoCommand)   // print selection
               {
#ifdef TRACE
                  Assert(doc->fFileType == kTWScrapType, 917);
#endif
                  // 07/12/93 [20843] save selection to printer needs reformat/paginate
                  doc->fFileType = 0; // anything but kTWScrapType
                  doc->DoReformat(kReformatAll, 0);
                  doc->ActiveMainView()->CompletePagination();
               }
               doc->Print(NULL);
               wr_wimpt_noerr(Sendmessage(e->data.msg.hdr.action + 1, &e->data.msg,
                                                                         e->data.msg.hdr.size));
                                          // wr_wimp_MPrintTypeOdd => wr_wimp_MPrintTypeKnown;
                                          // or wr_wimp_MPrintFile => wr_wimp_MWillPrint
               // run into handled = TRUE case

            case wr_wimp_MDATALOADOK:
               handled = TRUE;
               break;
         }
      }
      else if (e->e == wr_wimp_EACK)
      {
         /* bounced DATASAVE or (09/11/93) DATALOAD (01/12/93) etc. */
         switch (e->data.msg.hdr.action)
         {
            case wr_wimp_MDATALOAD:
               wr_os_cli("%remove <Wimp$Scrap>");
               // 21/08/95 Suppress error (temporarily, hopefully) !StrongEd bounces DATALOAD
               // then sends an ACK later! (obviously it does a Poll before replying)
               // ErrorAlert(kRecvDied, msgPlainMsg);
                         // output message "Data transfer failed: Receiver died"
            case wr_wimp_MDATASAVE:
               break;
               
            case Message_PrintSave:
               // 07/12/93 [21133] New for spooled printing
               // go ahead and try to print anyway as the PRM suggests
               doc->Print(NULL);
               break;

            case wr_wimp_MDATAOPEN:
               e->data.msg.data.datasaveok.type = gRun;
#define StartTask           0x000400DE
               wr_os_swi1(wr_os_X | StartTask, (int)&e->data.msg.data.datasaveok.type);
               break;

            default:
               return FALSE; // not dealt with here
         }
         handled = TRUE;
         w = 0;                         // do not close the SaveAs window
         FreeIfObject(PSaveHandle(handle)->selection);
#ifdef DRAWSAVE
         FreeMasterList();    // 11/11/93 leaving handles on SaveAsDraw dragged nowhere
#endif
      }

      if (handled)
      {
         if (PSaveHandle(handle)->saveCmdNum != cSaveClip)
                   // 26/06/96 'doc' (clipboard doc) may have been freed by Clipboard Task
         {
            bool resetPrHdlr = TRUE;
            THPrint prData;

#ifdef TABLES
            // initiate the print of the next mailmerge if not yet finished
            // 07/12/93 [21133] New for spooled printing
            if (doc->fMergeIndex > 0)
            {
               if (doc->MergeRows() >= doc->fMergeIndex)
               {
                  doc->Save(cPrint);
                  resetPrHdlr = FALSE;
               }
               else
                  doc->DoMerge(-1); // finished
            }
#endif
            if (resetPrHdlr && (prData = doc->GetPrintRec()) != NULL)  // 09/12/93 [21133]
            {
               // if finished the print, set up for 1 copy of whole doc
               prData->firstPg = 1;
               prData->copies = 1;
            }
         }

         if (w)
            wr_wimpt_noerr(wr_wimp_sendwmessage(wr_wimp_ECLOSE, (wr_wimp_msgstr*) &w, w, -1));

         if (PSaveHandle(handle)->saveCmdNum == cNoCommand)
            // its a clip doc containing the selection
            FreeIfObject(doc);

         if (PSaveHandle(handle)->clearDoc)
            ClearDragSelection(PSaveHandle(handle)->clearDoc);

         wr_win_remove_unknown_event_processor(wr_xfersend__pipe_unknowns, handle);
         DisposIfHandle(handle);
      }
   }
   return handled;
}

// ------------------------------------------------------------------------
_TFileIcon::_TFileIcon(TDocument doc, TView supV, char* &pars) : (doc, supV, pars)
{
   fDragType = 0;   // dotted blue box (04/12/94 0 for solid drag)
}

// ------------------------------------------------------------------------
void _TFileIcon::SetUp(TExpressionDocument fileDoc, int filetype, CmdNumber cmdNumber)
{
   fFileDoc = fileDoc;
   fCmdNumber = cmdNumber;
   fFiletype = filetype;
   DrawFileIcon(filetype);  // fileicon(fWMgrWindow, fIconNum, filetype);
}

// ------------------------------------------------------------------------
void _TFileIcon::DoAction(wr_wimp_msgstr *msg, wr_wimp_w w)
{
   TView theSaveDialogue = GetDialogView();
#ifdef NEVER
   TSaveInfo saveInfo;
   char *oOpt;
   char buff[512];
#endif

#ifdef CONT
  if (fCmdNumber == cSaveContents)
  {
    fFileDoc->fSaveContentsSet = TCluster(theSaveDialogue->FindSubView(I_(0, 0, 0, 'a')))->
                                                 ReportCurrent() - I_(0, 0, 'b', '0');
    fFileDoc->fTabContents = theSaveDialogue->TestCheckBox(I_('t', 'l', 'e', 'v'));
  }
#endif
   fFileDoc->SetUpSave(fCmdNumber, TControl(theSaveDialogue->FindSubView(gIdfnam)), fFiletype,
                                                                     msg, w);
#ifdef NEVER
   // 05/06/95 new bit for 'Easy Save'
   saveInfo.filename = buff;
   buff[0] = 0;
   oOpt = GetRsrcOption('o');
   if (oOpt != NULL && *oOpt != '-')
     strcpy(buff, oOpt);
#ifdef NETWP
   // save unprefixed filenames by the path of the file which originally loaded WP
   else if (gFinderFilename != NULL)
     strrchr(strcpy(buff, gFinderFilename), '.')[1] = 0;
#endif
   saveInfo.filename = saveInfo.filename + strlen(saveInfo.filename);
   TControl(theSaveDialogue->FindSubView(gIdfnam))->GetText(saveInfo.filename);
   if (strrchr(saveInfo.filename, '.') == NULL)  // no dot
     saveInfo.filename = buff;        // use name prefixed by o-option path
   saveInfo.msg = msg;
   saveInfo.filetype = fFiletype;
   saveInfo.fileIsSafe =
#ifdef NETWP
                  fCmdNumber == cSaveWord ||
#endif
                  fCmdNumber == cSave;  // ??? relevant ?? (sort of - but could be improved)
                  // ideally should be set to TRUE, then to false if not dragged to filer
                  // or selection saved. doc->Saver should do the definitive test on filetype!
   fFileDoc->DoSaveSend(&saveInfo, fCmdNumber, w);
                       // fills in size, your_ref, estsize, type and leaf
#endif
}

// ------------------------------------------------------------------------
TCommand _TFileIcon::TrackMouse(TrackPhase thePhase, VPoint &anchor,
        VPoint &previous, VPoint &next, bool mouseDidMove, EventInfo &info)
{
   if (thePhase == trackPress)
      fAdjustClicked = info.rightButton;         // rename this field!
   else if (thePhase == trackRelease)
   {
      wr_wimp_mousestr mousestr;

      wr_wimp_get_point_info(&mousestr);

      if (mousestr.w != -1)
      {
         wr_wimp_msgstr msg;

         msg.hdr.action = 0;     // just to fail Message_DragClaim test in DoSaveSend
         msg.hdr.my_ref = 0;     // copied to your_ref
         msg.data.datasave.w = mousestr.w;
         msg.data.datasave.i = mousestr.i;
         msg.data.datasave.x = mousestr.x;
         msg.data.datasave.y = mousestr.y;
         msg.data.words[4] = 0;            // set no flags

         // fFileDoc->DoSaveSend(&saveInfo, fCmdNumber, fAdjustClicked ? 0: w);
         DoAction(&msg, fAdjustClicked ? 0 : fWMgrWindow);
                       // do not close if dragged with adjust
                       // fills in msg.size, your_ref, estsize, type and leaf
      }
   }
   return gNoChanges;
}

// ------------------------------------------------------------------------
void _TExpressionDocument::SetUpSave(CmdNumber itsCmdNumber, TControl userText, 
                             int filetype, wr_wimp_msgstr *msg, wr_wimp_w w)
{
   TSaveInfo saveInfo;
   char *suff;
   char buff[512];
#ifdef NETWP
   //TWindow wdw = ActiveMainView()->GetWindow();
   wr_os_error *err;

   err = wr_os_cli("EnsureLine_EnsureLine");  // [27114]
   //wdw->ForceRedraw();
   if (err != NULL && err->errnum != 0xd6)
   {
     err->errnum = 1;
     FailOSErr(err);
   }
#endif
   // 05/06/95 new bit for 'Easy Save'
   saveInfo.msg = msg;
   saveInfo.filetype = filetype;
   saveInfo.filename = buff;
   buff[0] = 0;
   suff = GetRsrcOption('o');
   if (suff != NULL && *suff != '-')
     strcpy(buff, suff);
#ifdef NETWP
   else if (JSRead("NCWriter$SavePath", buff) == NULL) // 18/10/96 [27113] use save path variable
     {}
   else if (fSaveExists)
     strrchr(strcpy(buff, fTitle), '.')[1] = 0;
   else if (gFinderFilename != NULL)
     // save unprefixed filenames by the path of the file which originally loaded WP
     strrchr(strcpy(buff, gFinderFilename), '.')[1] = 0;
#endif
   saveInfo.filename = saveInfo.filename + strlen(saveInfo.filename);
#ifdef NETWP
   if (!userText)
      strcpy(saveInfo.filename, GetNickName());
   else
#endif
      userText->GetText(saveInfo.filename);
#ifdef NETWP
   suff = NULL;
   switch (itsCmdNumber)
   {
     case cSaveWord:
       saveInfo.filetype = kMSWord;
       // 29/08/96 [27053] Suppress suffix: suff = "DOC";
       break;
     case cSaveText:
       saveInfo.filetype = kTextFile;
       suff = "TXT";
       break;
     case cSave:
     case cSaveStationery:
       saveInfo.filetype = kExpressionFile;
       suff = "NCW";
       break;
   }
   if (suff)
      strcat(strcat(saveInfo.filename, "/"), suff);
#endif
   if (strrchr(saveInfo.filename, '.') == NULL)  // no dot
     saveInfo.filename = buff;        // use name prefixed by o-option/path
   saveInfo.fileIsSafe =
#ifdef NETWP
                itsCmdNumber == cSaveWord ||
#endif
                itsCmdNumber == cSave;  // ??? relevant ?? (sort of - but could be improved)
                // ideally should be set to TRUE, then to false if not dragged to filer
                // or selection saved. doc->Saver should do the definitive test on filetype!
#ifdef NETWP
   if (DoSaveSend(&saveInfo, itsCmdNumber, w) == 2)
      Save(cSave);      // try again with our filetype - should not fail this time
#else
   DoSaveSend(&saveInfo, itsCmdNumber, w);
                       // fills in size, your_ref, estsize, type and leaf
#endif
}


// -------------------------------------------------------------------------
int _TExpressionDocument::AlienSaver(int aRefNum, TSaveInfo *info, wr_wimp_eventstr *e)
// e == NULL indicates send to file
{
#if DEMO == 1
  Alert(phNoDemoSave, wr_wimp_EOK);
  ClearObject(info->selection);  // 18/07/94 leaving handle on text save in demo version
#else
  char buffer[kStdSenderBuffer]; // 28/02/94 avoid malloc area
  FailInfo fi;
  volatile TSender sender;
  volatile TDispatcher dispatcher;
#ifdef TeX
/* TeX */
  volatile Handle prologFile;
  volatile Handle fontMapFile;
#endif
#if defined DRAWSAVE || defined CONT || defined INDEX || defined WORD7
  TExpressionView mv = TExpressionView(ActiveMainView());
#endif

  if (e == NULL)
  {
    dispatcher = new _TDiscDispatcher(aRefNum);
  }
  else
    dispatcher = new _TRamDispatcher(e);

  CatchFailures(&fi);

  sender = NULL;
#ifdef TeX
/* TeX */
  prologFile = NULL;
  fontMapFile = NULL;
#endif

#ifdef DRAWSAVE
  if (info->selection == NULL)
  {
    sender = new _TSender(buffer, dispatcher, info->filetype);
    dispatcher = NULL;
    DoSaveDraw(sender, mv->fZoomBox, TRUE);
  }
  else
#endif
#if (defined CONT || defined INDEX) && !defined NETWP
  if (fSaveCmd == cSaveContents || fSaveCmd == cSaveIndex)
  {
    sender = new _TFancyTextSender(buffer, dispatcher, NULL);
    dispatcher = NULL;
    mv->fPages->WriteContents(sender);
  }
  else
#endif
  {
    TCursorNode anchor, activeEnd;
    TCurrency currency;
    TSelection selection = TSelection(info->selection);
    // TTextDocument theDoc = (selection ? selection->fDocument : this);

    if (/*selection == NULL || */ selection->fAnchor == NULL)      // 11/09/92, 21/06/96
    {
      anchor = NULL;
      activeEnd = NULL;
      currency = selection->fDocument->fBody;
    }
    else
    {
      anchor = selection->GetAnchorOwner();
      activeEnd = selection->GetActiveOwner();
      currency = anchor->fCurrency;
    }
#ifdef TeX
/* TeX */
    if (info->filetype == gTeXfile)
    {
      sender = new _TTeXSender(buffer, NULL, info->filetype);

      TTeXSender(sender)->fTeXCoding = (char *)LoadTeXFile("TeXcoding", FALSE);
      prologFile = LoadTeXFile("TeXprolog", -1);
      TTeXSender(sender)->fFuncNameList = LoadTeXFile("TeXfuncs", FALSE);
      fontMapFile = LoadTeXFile("TeXfontmap", FALSE);

      // do loads first, (they could go in init overlay if unsqueeze needed)

      TTeXSender(sender)->fEncodingList = new _TEncodingList();
      TTeXSender(sender)->ReadFontMap(fontMapFile);
      fontMapFile = NULL;

      // --- Pass 1 ---
      TTeXSender(sender)->SendHeaderFooter(this);
      SendAlienFile(this, currency, anchor, activeEnd, sender);
      DeclareTeXFontSets(TTeXSender(sender), this);

      // --- Pass 2 ---
      TTeXSender(sender)->SetDispatcher(dispatcher);
      dispatcher = NULL;
      TTeXSender(sender)->SendProlog(prologFile, this);
      prologFile = NULL;
      DeclareTeXFonts(TTeXSender(sender), this);
      DeclareTeXFontSets(TTeXSender(sender), this);
      TTeXSender(sender)->SendHeaderFooter(this);
      SendAlienFile(this, currency, anchor, activeEnd, sender);
      TTeXSender(sender)->Bye();
    }
    else
#endif
    {
#ifdef WORD7
      if (info->filetype == kMSWord)
      {
        // --- Pass 1 ---
        // sender = new _TWordSender(buffer, mv);
        // TWordSender(sender)->SendFIB();
        // SendWordFile(this, currency, anchor, activeEnd, sender);
        // TWordSender(sender)->SendWordData();

        // --- Pass 2 ---
        sender = fSender;
        fSender = NULL;
        TWordSender(sender)->SetDispatcher(dispatcher, buffer);
        dispatcher = NULL;
        TWordSender(sender)->SendFIB();
        SendWordFile(this, currency, anchor, activeEnd, sender);
        TWordSender(sender)->SendWordData();
      }
      else
#endif
      {
        TStructure structure;

        if (info->filetype == kTextFile)
          sender = new _TFancyTextSender(buffer, dispatcher,
#ifdef TRACE
                                       info->print == 3 ? this :    // Draft print
#endif
                                       NULL);
        else
          sender = new _TSender(buffer, dispatcher, info->filetype);
        dispatcher = NULL;
        structure = selection->fDocument->GetStructureReadOnly(currency);
        structure->WriteAlienData(currency, anchor, activeEnd, sender, NULL, NULL, NULL, -1);
      }
    }
  }
  sender->Flush();
  Success(&fi);
  //  run in to rescue

Rescue:
#ifdef TeX
/* TeX */
  DisposIfHandle(prologFile);
  DisposIfHandle(fontMapFile);
#endif
  FreeMasterList();           // does not matter if not set up!?
  FreeIfObject(dispatcher);
  FreeIfObject(sender);
  ClearObject(info->selection);
#if defined WORD7 && defined NETWP
  if (info->filetype == kMSWord && fi.error == memFullErr)
    ContinueFailure(&fi);
#endif
  if (fi.error != 0)
    return DoRescue(fi);
#endif
  return TRUE;
}

// ------------------------------------------------------------------------
void _TExpressionDocument::DoWrite(int aRefNum, TSaveInfo *saveInfo)
{
  if (saveInfo->filetype != kExpressionFile && saveInfo->filetype != kStationeryPad)
  {
    AlienSaver(aRefNum, saveInfo, NULL);    // Fail if returns FALSE?
  }
  else
  {
#ifdef TRACE
    Assert(fSelection != NULL, 647);
#endif
    _TTextDocument::DoWrite(aRefNum, saveInfo);
  }
}

// ------------------------------------------------------------------------
OSType _TExpressionDocument::GetSelectionFileType()
{
#ifdef DRAGDROP
  int flags = GetSelectionFlags();

  return (flags == kSpriteSelected ? kSpriteFile :
                (flags == kDrawSelected ? kDrawFile :
                  (flags == kJPEGSelected ? kJPEGFile :
#ifdef FILMS
                    (flags == kFilmSelected ? kFilm :
                       (flags == kACESelected ? kACE : kExpressionFile)))));
#else
                               kExpressionFile)));
#endif
#else
  TSelection selection = GetNewSelection();
  TLevelInfo levelInfo;

  selection->GetLevelInfo(&levelInfo);

  if (levelInfo.fKind == kPict)
  {
    TPictStructure structure = TPictStructure(GetStructureReadOnly(levelInfo.fStructure));
    TPictObject pict = structure->GetPicture();

    if (pict != NULL)
      return (pict->fSprite ? (pict->fSprite == 1 ? kSpriteFile : kJPEGFile) : kDrawFile);
  }

  return kExpressionFile;
#endif
}

// ------------------------------------------------------------------------
void _TExpressionDocument::DoNeedDiskSpace(long &dataForkBytes)
{
  if (fSelection != NULL)   // why this test???
    _TTextDocument::DoNeedDiskSpace(dataForkBytes);
#ifdef TRACE
  else
    SysBeep(0);
#endif
}

#ifdef TABLES
// ------------------------------------------------------------------------
THPrint _TExpressionDocument::CanDoMerge()
{
   THPrint prInfo = GetPrintRec();

   if (prInfo != NULL && prInfo->merge == 0 && HasMergeFile())
     return  prInfo;
   return NULL;
}
#endif

#if defined TABLES && !defined NETWP
static IDType gIdBtns[] = { I_('C', 't', 'n', 'u'),
                            I_('S', 'k', 'i', 'p'),
                            I_('A', 'b', 'd', 'n'), 0 };
#define gIdmerg I_('m', 'e', 'r', 'g')
#endif

// ------------------------------------------------------------------------
// 07/12/93 [21133] New for spooled printing
void _TExpressionDocument::SavePrint()
{
   TSaveInfo info;
   wr_wimp_msgstr msg;
   char leafname[32];
#if defined TABLES && !defined NETWP
   // expand and prompt (if necessary) for next merge iteration
   int mergeRes = 0;
   THPrint prInfo = CanDoMerge();

   if (prInfo != NULL)      // it is merge
   {
      if (prInfo->preview == 0)
          mergeRes = 1;     // send unexpanded merge
      else
         do
         {
            int start = fMergeIndex == 0;

            if (start)
               LoadMergeDocument();
            if (fMergeIndex >= MergeRows())
               mergeRes = 2;    // finish
            else
            {
               Str255 buffer;
               TDialogView aDialogView = TDialogView(NewTemplateWindow1(26));

               DoMerge(start);
               GetFieldValue(0, buffer);
               aDialogView->WriteTruncText(gIdmerg, buffer, dotRight);  // 30/08/95 ...
               mergeRes = LookupID(aDialogView->PoseModally(0), gIdBtns);
               aDialogView->Close();
            }
            if (mergeRes == 2)
            {
               DoMerge(-1);
               return;
            }
         }
         while (mergeRes == 1);    // while skip pressed
   }
#else
#define mergeRes 0
#endif
   memset(&msg, 0, 40);          // send as a broadcast & zeroise other fields (inc flags)
   msg.hdr.action = Message_PrintSave;
   GetLeafName(leafname);
   info.msg = &msg;
   info.filename = leafname;
   // info.filename = fTitle;

   // save in normal format if background off or unexpanded merge file
   if ((info.filetype = fDocPrintHandler->GetPrintFileType()) == 0 || mergeRes == 1)
      info.filetype = kExpressionFile;
   DoSaveSend(&info, cPrint, 0);
}

// ------------------------------------------------------------------------
void _TExpressionDocument::Save(CmdNumber itsCmdNumber)
{
   fSaveCmd = itsCmdNumber;
   fSaveSelection = FALSE;

#ifdef NEVER
   int fileType;
   char *suff;

   switch (itsCmdNumber)
   {
     case cSaveWord:
       fileType = kMSWord;
       suff = "DOC";
       break;
     case cSaveText:
       fileType = kTextFile;
       suff = "TXT";
       break;
     case cSave:
       fileType = kExpressionFile;
       suff = "NCW";
       break;
     default:
       fileType = 0;
       suff = NULL;
   }
   if (fSaveExists && fileType)
   {
      // for saving files without going through saveas
      TSaveInfo fileInfo;
      char *lastDot;
      char buffer[512];

      fileInfo.filename = buffer;
      lastDot = strrchr(strcpy(buffer, fTitle), '.');
      strcpy(lastDot + 1, GetNickName());
      strcat(strcat(lastDot, "/"), suff);
      fileInfo.msg = NULL;
      fileInfo.filetype = fileType;
      fileInfo.fileIsSafe = TRUE;
      if (DoSaveSend(&fileInfo, itsCmdNumber, 0) != 2)
        return;
      Save(cSave);      // try again with our filetype - should not fail this time
      return;
   }
#endif

   if (itsCmdNumber == cPrint)           // 07/12/93 [21133] New for spooled printing
      SavePrint();
#ifdef NETWP
   else if (fSaveExists && itsCmdNumber <= cSaveWord)  // short-circuit save dialogue
      SetUpSave(itsCmdNumber, NULL, 0, NULL, 0);
#endif
   else
      DoDialogue(this, itsCmdNumber, itsCmdNumber >= cSaveStationery
#ifdef TeX
/* TeX */
                           && itsCmdNumber != cSaveTeX
#endif
                              ? (
#if defined CONT && !defined NETWP
                   itsCmdNumber == cSaveContents ? kSaveContents :
#endif
                   kSaveAsNS) : kSaveAs, -1);    // 26/11/93 use new global routine
}

#ifdef TABLES
// ------------------------------------------------------------------------
// 04/12/93 new virtual method which can be overridden by mailmerge loop
bool _TExpressionDocument::Print(char *filename)
{
   if (fMergeIndex == 0 && CanDoMerge() != NULL)   // it is unexpanded merge
   {
      int another = 0;

      LoadMergeDocument();
      // do a loop printing the merge files
      do
      {
         another = DoMerge(1 - another);
      } while (_TDocument::Print(NULL) && another);

      DoMerge(-1); // finished
      return TRUE;
   }
   return _TDocument::Print(filename);  // had proceed parameter
}
#endif

// ------------------------------------------------------------------------
#ifdef DRAGDROP
int _TExpressionApplication::SetSendingTypes(int *types, int selFlags)
{
   int i = 0;

   if (selFlags == kSpriteSelected)
   {
      types[i++] = kSpriteFile;
      types[i++] = kDrawFile;
   }
   else if (selFlags == kJPEGSelected)
   {
      types[i++] = kJPEGFile;
      types[i++] = kDrawFile;
   }
   else if (selFlags == kDrawSelected)
   {
      types[i++] = kDrawFile;
   }
#ifdef FILMS
   else if (selFlags == kFilmSelected)
   {
      types[i++] = kFilm;
      types[i++] = kDrawFile;
   }
   else if (selFlags == kACESelected)
   {
      types[i++] = kACE;
      types[i++] = kDrawFile;
   }
#endif
   else
   {
#ifdef MATHS
      if ((selFlags & kMathsSelected) != 0)
         types[i++] = kExpressionFile;
#endif
#ifdef TABLES
      if ((selFlags & (kFootnoteSelected | kTableSelected | kMathsSelected)) != 0)
         types[i++] = kExpressionFile;
#endif
      types[i++] = kExpressionFile;
#ifdef DRAWSAVE
      if ((selFlags & (kMathsSelected | kSpriteSelected | kDrawSelected)) != 0)
                                            // 25/10/93 save pix in Draw format
         types[i++] = kDrawFile;
#endif
      if ((selFlags & kTextSelected) != 0)
         types[i++] = kTextFile;
   }
   return i;
}

// ------------------------------------------------------------------------
int _TExpressionApplication::GetDragKeys(int *filetypes)
{
   int flags = 0;

   for ( ; ; filetypes++)
   {
      int i;

      switch (*filetypes)
      {
         case kExpressionFile:
            for (i = 0; *(filetypes + i + 1) == kExpressionFile; i++)  {}
            filetypes += i;
            if (i == 2)
              flags |= kTextSelected | kMathsSelected | kTableSelected;
            else if (i == 1)
              flags |= kTextSelected | kTableSelected;
            else
              flags |= kTextSelected;
            break;

         case -1:
            return flags;

         case kTextFile:
            flags |= kTextSelected;
            break;

         case kSpriteFile:
            flags |= kSpriteSelected;
            break;

         case kJPEGFile:
            flags |= kJPEGSelected;
            break;

         case kDrawFile:
            flags |= kDrawSelected;
            break;
#ifdef FILMS
         case kFilm:
            flags |= kFilmSelected;
            break;

         case kACE:
            flags |= kACESelected;
            break;
#endif
      }
   }
}

// ------------------------------------------------------------------------
CmdNumber _TExpressionDocument::TestFileTypes(TSaveInfo *info, CmdNumber saveCmdNum)
{
   int *filetypes;
   int selFlags;
#ifdef DRAWSAVE
   bool saveAsDraw = FALSE;
#endif

   selFlags = GetSelectionFlags();

   for (filetypes = info->msg->data.words + 9; ; filetypes++)
   {
      int i;

      info->filetype = *filetypes;
      switch (*filetypes)
      {
         case kExpressionFile:
            if (info->msg->hdr.action == Message_Dragging)
               break;  // if not claimed, kExpressionFile is probably little use
            // that will do nicely unless only pic selected
            if (selFlags == kSpriteSelected || selFlags == kDrawSelected
#ifdef FILMS
                  || selFlags == kFilmSelected || selFlags == kACESelected
#endif
                  )
               break;
            for (i = 0; *(filetypes + i + 1) == kExpressionFile; i++)  {}
            filetypes += i;
            if (i == 2 &&      // or StartWrite with tables etc.
                 (selFlags & (kTableSelected | kFootnoteSelected | kMathsSelected)) != 0)
               break;
            if (i == 1 &&      // or EasiWriter with maths
                 (selFlags & (kMathsSelected)) != 0)
               break;
            return saveCmdNum;

         case -1:
#ifdef DRAWSAVE
            if (saveAsDraw && saveCmdNum == cSaveSelection)
            {
               saveCmdNum = cSaveDraw;
               info->filetype = kDrawFile;
            }
            else
#endif
#ifdef NETWP
            if (filetypes == info->msg->data.words + 9 && saveCmdNum == cSaveClip)
            {
               info->filetype = kTextFile;
               saveCmdNum = cSaveText;
            }
            else
#endif
               info->filetype = kExpressionFile;
            return saveCmdNum;

         case kTextFile:
#ifdef DRAWSAVE
            if (saveAsDraw && saveCmdNum == cSaveSelection &&
                      (selFlags & (kMathsSelected | kSpriteSelected | kDrawSelected)) != 0)
                                        // 25/10/93 save text pix in Draw format too
               break;    // better to save as Draw if possible
#endif
            if ((selFlags & kTextSelected) == 0)  // nothing to save as text
               break;
            return (saveCmdNum == cSave ? cSaveText : 
                         (saveCmdNum == cNoCommand ? saveCmdNum : cSaveTextSelection));
         case kSpriteFile:
            if (selFlags != kSpriteSelected)
               break;
            return cSaveSelection;

         case kJPEGFile:
            if (selFlags != kJPEGSelected)
               break;
            return cSaveSelection;

#ifdef FILMS
         case kFilm:
            if (selFlags != kFilmSelected)
               break;
            return cSaveSelection;

         case kACE:
            if (selFlags != kACESelected)
               break;
            return cSaveSelection;
#endif
         case kDrawFile:
#ifdef DRAWSAVE
            saveAsDraw = TRUE;
#endif
            if (selFlags != kDrawSelected && selFlags != kSpriteSelected &&
#ifdef FILMS
                         selFlags != kFilmSelected && selFlags != kACESelected &&
#endif
                                                        selFlags != kJPEGSelected)
               break;
            return cSaveSelection;
      }
   }
}

// ------------------------------------------------------------------------
void _TExpressionDocument::SaveData(wr_wimp_msgstr *msg, CmdNumber saveCmdNum)
{
   // handles message requests (in info->msg) which contain a list of required types
   // saveCmdNum == cSaveClip means saving the clip document
   // cSaveSelection, send the documents current selection
   // cNoCommand, as cSaveClip, but document is freed after being sent (04/01/95)
   TSaveInfo info;
   CmdNumber newCmdNum;

   info.msg = msg;
   info.filename = NULL;
   info.fileIsSafe = FALSE;

   // 04/01/95 test below switched from saveCmdNum == cSaveClip to catch cNoCommand call too
   if (saveCmdNum != cSaveSelection) /* ie save clipboard */
   {
      FreeIfObject(fSelection);                   // 09/11/93 left handles on 2nd paste
      InitialSelection(ActiveMainView(), 0, -1);  // need a selection in doc
   }
   newCmdNum = TestFileTypes(&info, saveCmdNum);   // NB this fills in info.filetype
   DoSaveSend(&info, newCmdNum, 0);
}
#endif

// ------------------------------------------------------------------------
void _TExpressionDocument::PipePicture()
{
   if (GetSelectionFileType() != kExpressionFile)
           // 16/03/94 [21500] in case 2nd click on pict which was not selected by the first
   {
      TSaveInfo info;
      char leafname[32];
      wr_wimp_msgstr msg;

      memset(&msg, 0, 40);        // send as a broadcast & zeroise other fields (inc flags)
      msg.hdr.action = wr_wimp_MDATAOPEN;
      GetLeafName(leafname);
      info.msg = &msg;
      info.filename = leafname;  // fTitle;

      // save in normal format if background off or unexpanded merge file
      DoSaveSend(&info, cSaveSelection, 0);
   }
}

#if defined PRO && !defined NETWP
// ------------------------------------------------------------------------
static void LoadPostscript()
{
  Str255 buffer;
  char *template;
  char *modName;

  if (JSRead("Printers$Path", buffer) != NULL || buffer[0] == 0)
     FailGeneral(43);
  template = GetRsrcMisc(8);
  modName = GetRsrcMisc(9);
  sprintf(buffer, template, modName, modName);
  if (wr_os_cli(buffer) != NULL)
     FailGeneral(44);   // 28/01/94 [21366]
  modName = GetRsrcMisc(10);
  sprintf(buffer, template, modName, modName);  // 20/04/94 also load MakePSFont
  wr_os_cli(buffer);
}
#endif

// ------------------------------------------------------------------------
void _TExpressionDocument::CreateClipDocument(TExpressionDocument clipDocument)
{
  TSelection selection = GetSelection(TRUE);
  TCursorNode anchor, activeEnd;
  TCurrency currency;
  TStructure structure;
  TMainView clipView;

  clipDocument->DoInitialState();     // 28/06/90
  anchor = selection->GetAnchorRoot();
  activeEnd = selection->GetActiveRoot();
  currency = anchor->fCurrency;
  structure = GetStructureReadWrite(currency);
#ifdef DRAGDROP
  structure->CopyToClipboard(currency, anchor, activeEnd, NULL, clipDocument,
         gNullCurrency, -1);
#else
  structure->CopyToClipboard(currency, anchor, activeEnd, clipDocument, gNullCurrency, -1);
#endif
  clipDocument->BuildFontRefTable();

  clipView = clipDocument->ActiveMainView();
  clipView->AttachPrintHandler(clipView->fPrintHandler);
  ClearObject(clipDocument->fSelection);
  clipDocument->InitialSelection(clipView, 0, -1);  // 06/09/92
  clipDocument->GetNewSelection()->fReformatType = kReformatAll;
  clipDocument->Reformat();
}

// ------------------------------------------------------------------------
TCurrency _TExpressionDocument::EstimateSpaceNeeded(TSaveInfo *info, long *neededSpace)
{
  TStructure structure;
  TCursorNode anchor, activeEnd;
  TCurrency currency;

  if (TSelection(info->selection)->fAnchor == NULL)      // 11/09/92
  {
    anchor = NULL;
    activeEnd = NULL;
    currency = fBody;
  }
  else
  {
    anchor = TSelection(info->selection)->GetAnchorOwner();
    activeEnd = TSelection(info->selection)->GetActiveOwner();
    currency = anchor->fCurrency;
  }
#ifdef WORD7
  if (info->filetype == kMSWord)
  {
    char buffer[kStdSenderBuffer];

    // --- Pass 1 ---
    BeginProgress();
    CommitLastDocCommand();  // for safety - maybe can remove for pass 1 if sender can manage?
    fSender = new _TWordSender(buffer, TExpressionView(ActiveMainView()));
    TWordSender(fSender)->SendFIB();
    SendWordFile(this, currency, anchor, activeEnd, fSender);
    TWordSender(fSender)->SendWordData();
    TWordSender(fSender)->Flush();
    *neededSpace = fSender->GetSpaceUsed();
  }
  else
#endif
  {
    long numOfItems;
    int estSize = 0;

    structure = GetStructureReadOnly(currency); // 18/06/91 from RW?

    numOfItems = structure->CountSelectedItems(currency, anchor, activeEnd, FALSE);
    // 29/04/91 show hourglass during count
    ShowProgress(numOfItems);

    structure->DoNeedAlienSpace(currency, anchor, activeEnd,
              info->filetype, &estSize);
    *neededSpace = estSize;
  }
  HideProgress();
  return currency;
}


// ------------------------------------------------------------------------
int _TExpressionDocument::DoSaveSelection(TSaveInfo *info, wr_wimp_w closeWind)
{
   TExpressionDocument clipDoc;
   FailInfo fi;

   CommitLastDocCommand();               // 18/02/91
   // when saving a selection, create a clip document and save it
   // instead of our current document.  Thus pass this clip doc
   // down to the inherited method

   clipDoc = TExpressionDocument(gApplication->DoMakeDocument(kTWScrapType, FALSE));

   CatchFailures(&fi);
   CreateClipDocument(clipDoc);
   Success(&fi);

   info->fileIsSafe = FALSE;
   info->selection = this;
   clipDoc->DoSaveSend(info, cNoCommand, closeWind);
   if (info->msg == NULL)
      FreeIfObject(clipDoc);
   return TRUE;

Rescue:
   FreeIfObject(clipDoc);
   ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
int _TExpressionDocument::DoSaveSend(TSaveInfo *info, CmdNumber saveCmdNum,
                                                               wr_wimp_w closeWind)
{
  // called after a file or selection has been dropped (or paste in another app).
  // saveCmdNum indicates what is to be saved (cSaveSelection may mean send a sprite
  // or draw file if that is all that is selected)
  // 25/11/93 cPrint for send a file to print queue
  long estsize = 0;
  int res = FALSE;
  bool bounceRam = TRUE;
  TExpressionDocument document;
  wr_wimp_msgstr *msg = info->msg;
  TCurrency currency;
  FailInfo fi;

  fi.error = 0;
  info->print = FALSE;
  currency = 0;
  if (saveCmdNum == cSaveSelection &&
                       (info->filetype = GetSelectionFileType()) == kExpressionFile)
    return DoSaveSelection(info, closeWind);

  fSaveCmd = saveCmdNum;      // 07/09/95 [26068] not cleared after SaveContents, etc.
  document = (saveCmdNum == cNoCommand ? TExpressionDocument(info->selection) : this);
  info->selection = NULL;

  CatchFailures(&fi);

  // set up estimated size and selection for particular save
  if (info->filetype == kExpressionFile || info->filetype == kStationeryPad)
  {
     // this covers Save, Save Stationery and Save Selection (not with pic selected)
     if (saveCmdNum != cSave)
       info->fileIsSafe = FALSE;

     DoNeedDiskSpace(estsize);
  }
#ifdef DRAWSAVE
  else if (saveCmdNum == cSaveDraw)  // && filetype == drawfile??
  {
         // 12/10/92 for intercepting draws
     InitMasterList();            // create an empty master fonts list
     estsize = DoNeedDrawSpace(TExpressionView(ActiveMainView())->fZoomBox);
     bounceRam = FALSE;
  }
#endif
#if defined PRO && !defined NETWP
  else if (saveCmdNum == cSavePostscript)
  {
     LoadPostscript();
     estsize = 1024;
     info->print = 2;  // 19/04/94 [21626]
  }
#endif
  else if (saveCmdNum == cPrint            // spool to file case
#ifdef TRACE
         && info->filetype != kTextFile   // Draft Print
#endif
       )
  {
     estsize = 1024;
#ifdef TRACE
     info->print = 1;      // Draft Print
#endif
  }
  else
  {
     bounceRam = FALSE;

     // we are going to (try to) send via RAM, so need the estimated size of data
     switch (saveCmdNum)
     {
#ifdef TeX
/* TeX */
       case cSaveTeXSelection:               // 23/02/95 need a better way!!
         estsize = 4096;                // frig size!!!
#endif
       case cSaveSelection:   // cSaveSelection here is when a picture is selected
         if (info->filetype == kJPEGFile)
           bounceRam = TRUE;              // 21/08/95 Fudge because !Paint fails RAM
                                          // (even though it sends a RAMFetch for JPEG)
       case cSaveTextSelection:
              // make a copy of the current selection
         info->selection = GetNewSelection()->Clone();
         break;

#if (defined CONT || defined INDEX) && !defined NETWP
       case cSaveIndex:
       case cSaveContents:
         estsize = GetContentsSize();
         // info->selection = new _TSelection(this);
         break;
#endif

#ifdef TRACE
       case cPrint:   // Draft Print (filetype == kTextFile, not dealt with above)
         info->print = 3;      // Draft Print
#endif
#ifdef TeX
       case cSaveTeX:         // 23/02/95 /* TeX */
#endif
       case cSaveText:        // save whole document as text
       case cNoCommand:       // Drag & drop from dialogue field clip doc
         if (fVersion >= 5)
         {
           // 18/06/91 fast method for getting text size which avoids reading the disc
           TStatistics stats;

           GetStatistics(&stats, FALSE);
           estsize = stats.fCharacters + 1; // 12/10/94 + 1 because final CR sent for !Draw
         }
#ifdef WORD7
       case cSaveWord:
#endif
         // create a selection selecting the whole document
         // 11/09/92 need a selection, but only to hold doc ref, and indicate
         // whole document needs saving (by leaving cursors NULL)
         // Avoid InitialSelection(..., 0, -1) - it needs Commit to have been done!
         // info->selection = new _TSelection(this);
         break;
#ifdef TRACE
       default:
         Assert(0, 497);
#endif
     }
     if (info->selection == NULL)
       info->selection = new _TSelection(this);
     // FailNIL(info->selection);
     // get the alien disc space required
     // force down old else path if stats corrupt or if only part of doc selected
     if (estsize <= 0)
     {
       CatchFailures(&fi);

       currency = EstimateSpaceNeeded(info, &estsize);
       HideProgress();

       Success(&fi);
     }
  }

  if (msg != NULL)
  {
     // need to get a filename via DataSaveAck, which then calls the Saver
     int flags = msg->data.words[4];
     int toTask = FALSE;
     TSaveHandle *hdl;
     char *leaf;

#ifdef DRAGDROP
     if (msg->hdr.action == Message_DragClaim) // 25/11/93 action was overwritten before test
       toTask = TRUE;
#endif
     leaf = (info->filename == NULL ? ".Selection" : strrchr(info->filename, '.'));
     leaf = (leaf == NULL ? info->filename : leaf + 1);
     if (msg->hdr.action == wr_wimp_MDATAOPEN)
     {
       sprintf(msg->data.dataopen.name, "Pipe:$.%.10s.%s.%3X%u", gProgName,
                                             leaf, info->filetype, Curr_fRecnum(currency));
       info->filename = msg->data.dataopen.name;
       msg->hdr.size = sizeof(wr_wimp_msghdr) + sizeof(wr_wimp_msgdatasave) - 8 +
              (strlen(info->filename) >> 2) << 2;
       Saver(info, estsize);         // pipe to info->filename directly
       toTask = TRUE;
       if (gWimpVersion >= 300)
         gApplication->SetIdleFreq(50);     // gOLE;
     }
     else
     {
       int leafXtra = strlen(leaf) & 0xfffffffc; // 04/10/94 [23001] avoid limit of 11 chars

       msg->hdr.size = (leafXtra >= 8 ?
                  leafXtra + sizeof(wr_wimp_msghdr) + sizeof(wr_wimp_msgdatasave) - 8 :
                  sizeof(wr_wimp_msghdr) + sizeof(wr_wimp_msgdatasave));
       if (saveCmdNum == cPrint)  // 25/11/93 [21133] for Q-ed printing (action already set)
#ifndef TRACE
         info->print =
#endif
           toTask = TRUE;
       else
         msg->hdr.action = wr_wimp_MDATASAVE;
       strcpy(msg->data.datasave.leaf, leaf);    // 04/10/94 [23001]: [11] = 0;
     }

     msg->data.datasave.estsize = estsize;
     msg->data.datasave.type = info->filetype;

     msg->hdr.your_ref = msg->hdr.my_ref;  // 14/07/95 [ ??? ]
     if (toTask)                // 25/11/93 moved up as action was overwritten before test
        wr_wimpt_noerr(wr_wimp_sendmessage(wr_wimp_ESENDWANTACK, msg, msg->hdr.task));
     else
        wr_wimpt_noerr(wr_wimp_sendwmessage(
              wr_wimp_ESENDWANTACK, msg, msg->data.datasave.w, msg->data.datasave.i));

     /* set up handle needed in the event processor */
     hdl = (TSaveHandle *)NewCheckedHandle(sizeof(TSaveHandle));
     hdl->msgId = msg->hdr.my_ref;    /* filled in by wimp. */
     hdl->bounceRam = bounceRam;
     hdl->doc = this;
     hdl->saveCmdNum = saveCmdNum;
     hdl->filetype = info->filetype;
     hdl->selection = TSelection(info->selection);
     hdl->closeWind = closeWind;
     hdl->estsize = estsize;
     hdl->clearDoc = (flags & 8) != 0 ? document : NULL;
     hdl->print = info->print;     // 04/12/93 new field
     wr_win_add_unknown_event_processor(wr_xfersend__pipe_unknowns, hdl);
     return TRUE;
  }
  res = Saver(info, estsize);         // write to info->filename directly

Rescue:
  FreeIfObject(info->selection);
  ClearObject(fSender);
  if (fi.error == 0)
    return res;
  HideProgress();
#ifdef NETWP
  if (saveCmdNum == cSaveWord)
    return 2;   // failed in computing estimated space - try again in native format
#endif
  ContinueFailure(&fi);
}


// -------------------------------------------------------------------------
void _TExpressionApplication::Free()
{
// 15/06/91 no need:   gDictionaries->Free();

   BASEAPPLICATION::Free();
}

// -------------------------------------------------------------------------
static wr_os_error *ReadPipeName(wr_os_regset &r, char *buff, char *reply)
{
   r.r[0] = 9;
   r.r[1] = (int)buff;
   r.r[2] = (int)reply;
   r.r[3] = 1;
   r.r[4] = 0;
   r.r[5] = 20;
   r.r[6] = 0;
   return wr_os_swix(12 /* wr_os_gbpb */, &r);
}

// -------------------------------------------------------------------------
bool _TExpressionApplication::DoIdle(IdlePhase phase)
{
  if (phase != idleEnd)
  {
    wr_os_regset r;
    char buff1[48];
    char reply[20];
    char leafname[32];
    char *buff = buff1 + 8;

    sprintf(buff1, "%%remove Pipe:$.%.10s", gProgName);
    ReadPipeName(r, buff, reply);
    if (r.r[3] > 0)
    {
      TExpressionDocument doc = NULL;
      TFileInfo fileInfo;
      AppFile anAppFile;
      TCurrency picCurr;
      TStructure picStruct;
      int readFiletype;

      for (int i = 1; i <= gDocList->fSize; i++)
      {
        TExpressionDocument thisDoc = TExpressionDocument(gDocList->At(i));

        thisDoc->GetLeafName(leafname);
        if (strcmp(reply, leafname) == 0)
        {
          doc = thisDoc;
          break;
        }
      }
      strcat(buff, ".");
      strcat(buff, reply);
      ReadPipeName(r, buff, reply);
      strcat(buff, ".");
      strcat(buff, reply);
      sscanf(reply, "%3x%d", &anAppFile.fType, &picCurr);
                                 // get pic currency recnum (NNN) from "tttNNN"
      picCurr = Curr_Set(picCurr, kPictStruct);
      if (doc != NULL)
      {
        doc->CommitLastDocCommand();
        picStruct = TTextDocument(doc)->GetStructure(picCurr, kReadWrite + 2);
        if (picStruct == NULL)
        {
          doc = NULL;
//          wr_os_cli(buff1);
//          FailGeneral(45);
        }
        else
        {
          TMainView mv = doc->ActiveMainView();
          TSelection oldSelection = doc->GetSelection(TRUE);

          mv->ClearHighlighting(TRUE);
          doc->DoneTyping();
          doc->InitialCursor(mv, picCurr, 0);
          FreeIfObject(oldSelection);
          // 17/02/94 hopefully InitialCursor replaces this lot
          // theSelection = doc->StartNewSelection();
          // theSelection->fAnchor = new _TCursor(theSelection);
          // theSelection->fAnchor->InitialCursor(mv, picCurr, 0);
          // theSelection->fCursor = TRUE;
          // theSelection->SetTarget();
          // theSelection->fChanged = TRUE;
          // theSelection->DoSetupLevels();
          doc->SetTextHandler();             // to get selection viewId set
          // doc->SetCurrentStyle();
        }
      }
      if (doc == NULL)
      {
        // the file is ours, but nowhere to put it
        OpenNew();
        doc = TExpressionDocument(gDocList->Last());
      }
      GetFileInfo(buff, fileInfo);
      fileInfo.CheckType();           // fail if not file

      // Some apps do not supply the file type on save (DrawPlus & Paint for example)
      readFiletype = (fileInfo.fInfo.loadaddr & 0x000fff00) >> 8;
      if (readFiletype != 0)
        anAppFile.fType = readFiletype;      // use the file filetype if possible
      anAppFile.fName = buff;
      anAppFile.fEstSize = -1;        // 18/02/91 indicates file is safe
      anAppFile.fFileIsSafe = TRUE;
      PerformCommand(doc->DoPaste(&anAppFile, fileInfo.GetFileSize(), kF2Insert, NULL));
    }
  }
  return BASEAPPLICATION::DoIdle(phase);
}

#ifdef NETWP
// ------------------------------------------------------------------------
static void ReleaseClipAndClose(int called_at, void *handle)
{
   if (gDocList->fSize == 0)     // no new docs opened since alarm set (open+close cancels alarm)
      gApplication->Close(NULL); // Quit the App
}
#endif

// ------------------------------------------------------------------------
void _TExpressionApplication::DeleteDocument(TDocument docToDelete)
{
   int oldSize = gDocList->fSize;

   BASEAPPLICATION::DeleteDocument(docToDelete);
#ifdef NETWP
#ifdef TRACE
#define CLOSE_DELAY 100000
#else
#define CLOSE_DELAY 12032
#endif
  if (gDocList->fSize == 0 && oldSize != 0)
  {
    // that was the last document; Set up a wait (120 secs) after which, if no document reopened,
    // dump the scrap doc and quit the application
   wr_alarm_removeall((void *)1);    // a unique handle for this alarm (idles use gApplication)
   wr_alarm_set(wr_alarm_timenow() + CLOSE_DELAY, ReleaseClipAndClose, (void *)1);
  }
#endif
}

#if defined PRO && !defined NETWP
// ------------------------------------------------------------------------
void _TExpressionApplication::DoChoice(TView origView, int itsChoice)
{
   if (origView->fIdentifier == I_('D', 'f', 'l', 't') ||
                                origView->fIdentifier == I_('l', 'i', 'n', 'l'))
      DoChoicesChoice(this, origView, itsChoice);
   else
      BASEAPPLICATION::DoChoice(origView, itsChoice);
}

// ------------------------------------------------------------------------
void _TExpressionApplication::WriteToDialog(TView aDialogView, CmdNumber cmdNumber)
{
   if (cmdNumber == cChoices)
      WriteToChoicesDialog(this, aDialogView);
   else
      BASEAPPLICATION::WriteToDialog(aDialogView, cmdNumber);
}

// ------------------------------------------------------------------------
TCommand _TExpressionApplication::ReadFromDialog(TView aDialogView, CmdNumber aCmd, IDType icnId)
{
   if (aCmd == cChoices)
      return ReadFromChoicesDialog(this, aDialogView, aCmd, icnId);
   return BASEAPPLICATION::ReadFromDialog(aDialogView, aCmd, icnId);
}
#endif

#ifndef NETWP
// -------------------------------------------------------------------------
// used by the AboutApp dialogue
#define kLargeDelay     500
#define kSmallDelay     200
#define kAboutBox       42
#define gIdauth I_('a', 'u', 't', 'h')
#define gIdruse I_('r', 'u', 's', 'e')

static TDialogView gAboutBox;
static int  gMsgNum;

static void AboutApp_ChangeMsg()
{
   char *theMsg;

#if SIDEBAR == 1
   if (gSplashOver == 0 && gMsgNum > 0)
     FailNoFail();
#endif
   while (theMsg = GetRsrc(gMsgNum++, 'i'), theMsg == NULL)
      gMsgNum = 0;
   gAboutBox->WriteText(gIdauth, theMsg);

#if DEMO == 0 && ACORNSP != 2
#ifdef TRACE
   gAboutBox->WriteText(gIdruse, "This is an illegal copy");
#else
#if ACORNSP == 1
#if SIDEBAR == 1
   // 05/06/95 Flash the about dialogue, showing license & number
   gAboutBox->WriteText(I_('l', 'i', 'c', 'e'), gMsgNum == 1 ? LicenceType : Reg_Number);
   gAboutBox->WriteText(gIdruse, LicenceHolder);
#else
   // 01/03/93 [20801] Start with name, then "licence : number"
   char buff[40];

   strcpy(buff, LicenceType);
   strcat(buff, " : ");
   strcat(buff, Reg_Number);
   gAboutBox->WriteText(gIdruse, gMsgNum == 1 ? LicenceHolder : buff);
#endif
#else
   gAboutBox->WriteText(gIdruse, gMsgNum != 1 ? gRegUserName : gRegUserNumber);
#endif
#endif
#endif

   wr_alarm_set(wr_alarm_timenow() + (gMsgNum != 1 ? kSmallDelay : kLargeDelay
#if SIDEBAR == 1
                   * (2 - gSplashOver)
#endif
                            ), (wr_alarm_handler)AboutApp_ChangeMsg, NULL);
}


// -------------------------------------------------------------------------
void _TExpressionApplication::DoShowAboutApp()
{
#if defined PRO
   TControl fontIcon;
#endif
#if SIDEBAR == 1
   FailInfo fi;

   CatchFailures(&fi);
#endif
   gAboutBox = TDialogView(NewTemplateWindow1(kAboutBox));
   gMsgNum = 0;

   // 31/10/95 no need:   wr_alarm_init();

   AboutApp_ChangeMsg();
   gAboutBox->WriteText(gIdvers, GetRsrcMisc(1));
#if defined PRO
   fontIcon = TControl(gAboutBox->FindSubView(I_(0,0,0,'A')));
   if (fontIcon)
      fontIcon->SetFont("Trinity.Bold", 12 * 16, 12 * 16);
   fontIcon = TControl(gAboutBox->FindSubView(I_(0,0,0,'P')));
   if (fontIcon)
      fontIcon->SetFont("Trinity.Bold.Italic", 12 * 16, 12 * 16);
#endif
   gAboutBox->PoseModally(cAboutApp);
   gAboutBox->Close();

#if SIDEBAR == 1
   Success(&fi);

Rescue:
   gSplashOver = TRUE;
#endif
   wr_alarm_removeall(NULL);
}
#endif

// -------------------------------------------------------------------------
TDocument _TExpressionApplication::DoMakeDocument(CmdNumber itsCmdNumber,
                                                        bool installHandler)
  // 05/07/90 always build an expression document. The filetype gets saved
  // as fFileType, rather than generating a separate document object type.
  // Current set of expected types are:
  //     kExpressionFile - build a doc for editing
  //     kStationeryPad - ditto from a stationery pad
  //     kDrawFile - build a doc containing a Draw file/Sprite for pasting
  //     kTextFile - build a doc containing text for pasting
  //     kFirstWordFile - build a doc containing 1stWord+ for pasting
  //     kCSV - build a doc containing a table
  //     kTWScrapType - for managing the save selection command
{
  TDocument aDocument;
  FailInfo fi;

  aDocument = new _TExpressionDocument(itsCmdNumber);

#ifdef SHAREPRINT
  aDocument->fSharePrintInfo = FALSE;
#endif

  if (installHandler)
  {
    // only set up the text handler if we are going to allow editing
    TTextEvent textEvent;

    CatchFailures(&fi);
    // set up TTextEvent handlers etc. here
#ifdef MATHS
    textEvent = new _TMathEvent(TExpressionDocument(aDocument));
#else
    textEvent = new _TTextEvent(TExpressionDocument(aDocument));
#endif
    Success(&fi);
    TExpressionDocument(aDocument)->fTextHandler = textEvent;
  }
  return(aDocument);

Rescue:
  FreeIfObject(aDocument);
  ContinueFailure(&fi);
}

// -------------------------------------------------------------------------
static TView CreateArrayScroller(int ignore, TDocument itsDoc,
                              TView itsSuper, char * &itsParams)
{
   TScrollingList aView = new _TScrollingList(itsDoc, itsSuper, itsParams);

   aView->HaveArray(NewTextArray(kUnitsArrayID), 0);
   return aView;
}

// -------------------------------------------------------------------------
static TView CreateControlView(int controlType, TDocument itsDoc,
                              TView itsSuper, char * &itsParams)
{
   TControl aView = new _TControl(itsDoc, itsSuper, itsParams);

   aView->fDefChoice = controlType;
   return aView;
}

// -------------------------------------------------------------------------
static TView CreateView(int objType, TDocument itsDoc,
                              TView itsSuper, char * &itsParams)
{
   switch (objType)
   {
   case 'A' : return CreateArrayScroller(0, itsDoc, itsSuper, itsParams);
#ifdef TABLES
   case 'a' : return new _TTextAttrsDlg(itsDoc, itsSuper, itsParams);
#endif
   case 'B' : return CreateControlView(mCheckBoxHit, itsDoc, itsSuper, itsParams);
   case 'b' : return new _TRulePicture(itsDoc, itsSuper, itsParams);
   case 'C' : return new _TControl(itsDoc, itsSuper, itsParams);
#ifdef SPELL
   case 'c' : return new _TSpellCheckDlg(itsDoc, itsSuper, itsParams);
#endif
   case 'D' : return new _TDialogView(itsDoc, itsSuper, itsParams);
#if WORDBANK == 1
   case 'd' : return new _TWordListDlg(itsDoc, itsSuper, itsParams);
#endif
   // case 'd' : return new _TPrintStatusWindow(itsDoc, itsSuper, itsParams);
   case 'E' : return new _TSpacingDlg(itsDoc, itsSuper, itsParams);
#ifdef SPELL
   case 'e' : return new _TExceptionsDlg(itsDoc, itsSuper, itsParams);
#endif
   case 'F' : return new _TFixedPtText(itsDoc, itsSuper, itsParams);
#ifdef TABLES
   case 'f' : return new _TTypeSpecDlg(itsDoc, itsSuper, itsParams);
#endif
#ifdef MATHS
   case 'G' : return new _TPalette(itsDoc, itsSuper, itsParams);
#endif
   case 'g' : return new _TScroller(itsDoc, itsSuper, itsParams);
#ifdef TABLES
   case 'H' : return new _TSaveStyleDlg(itsDoc, itsSuper, itsParams);
   case 'h' : return new _TMergeDialog(itsDoc, itsSuper, itsParams);  // 10/05/92
#endif
   case 'I' : return new _TSmallIcon(itsDoc, itsSuper, itsParams);
   case 'i' : return new _TFileIcon(itsDoc, itsSuper, itsParams);
#ifdef TABLES
   case 'J' : return new _TSprite(itsDoc, itsSuper, itsParams);
#endif
   case 'j' : return new _TSlider(itsDoc, itsSuper, itsParams);
   case 'K' : return new _TCluster(itsDoc, itsSuper, itsParams);
   case 'k' : return new _TAdornCluster(itsDoc, itsSuper, itsParams);
   case 'L' : return new _TScrollingList(itsDoc, itsSuper, itsParams);
#ifdef NETWP
   case 'l' : return new _TTwitteredText(itsDoc, itsSuper, itsParams);
                                  // 06/09/96 [27061] new control object class
#endif
   case 'M' : return new _TExpressionView(itsDoc, itsSuper, itsParams);
   case 'm' : return new _TMarginDialog(itsDoc, itsSuper, itsParams);
   case 'N' : return new _TNumberText(itsDoc, itsSuper, itsParams);
   case 'n' : return new _TColourPatch(itsDoc, itsSuper, itsParams);
   case 'O' : return CreateControlView(mRadioHit, itsDoc, itsSuper, itsParams);
   // case 'o' : return new _TWordList(itsDoc, itsSuper, itsParams);  // 27/09/93
#ifdef TABLES
   case 'P' : return new _TPopup(itsDoc, itsSuper, itsParams);
#endif
   case 'Q' : return new _TTabPosition(itsDoc, itsSuper, itsParams);
   case 'R' : return new _TRulerScale(itsDoc, itsSuper, itsParams);
   case 'S' : return new _TScaleScroller(itsDoc, itsSuper, itsParams);
   case 'T' : return new _TTabView(itsDoc, itsSuper, itsParams);
   case 'U' : return new _TUpDown(itsDoc, itsSuper, itsParams);
   case 'V' : return new _TView(itsDoc, itsSuper, itsParams);
   case 'W' : return new _TWindow(itsSuper == NULL ? itsDoc : NULL, itsSuper, itsParams);
   case 'X' : return new _TScaledWindow(itsDoc, itsSuper, itsParams);
#ifdef SPELL
   case 'Y' : return new _TScrollBarList(itsDoc, itsSuper, itsParams);  // 01/09/93
#endif
#ifdef TABLES
   case 'Z' : return new _TTabDialog(itsDoc, itsSuper, itsParams);
#endif
   default  : return NULL;
   }
}


// -------------------------------------------------------------------------
TView _TExpressionApplication::CreateAView(TDocument itsDoc,
                              TView itsSuper, char * &itsParams)
// itsParams on entry points to a string:
// byte 0 is alphabetic (A-Z, a-z) denoting the view type to be created
// bytes 1 onwards are passed to the created object
{
   TView aView;
   char  objType;
   // int strOffset;

   // sscanf(itsParams, " %c %n", &objType, &strOffset);
   // OffsetPtr(itsParams, strOffset);
   objType = *(itsParams++);

   aView = CreateView(objType, itsDoc, itsSuper, itsParams);

#ifdef TRACE
   if (aView == NULL)
     wr_werr(0, "TExpressionAppl: object type '%c' not in case structure",
              objType);
#endif
   if (itsSuper != NULL)
     itsSuper->AddSubView(aView);
   return(aView);
}


// ------------------------------------------------------------------------
bool _TExpressionApplication::CanOpenDocument(CmdNumber itsCmdNumber,
                                                         AppFile &anAppFile)
// return true if it is any type we understand (for when file double clicked),
// or (when itsCmdNumber == cPrint) when file dropped on printer icon
{
   register OSType fileType = anAppFile.fType;

   return ((fileType == kDictionaryFile && itsCmdNumber == cOpen) ||
#ifdef WORD7
        fileType == kMSWord ||
#endif
        fileType == kStationeryPad || fileType == kExpressionFile);
}

// ------------------------------------------------------------------------
bool _TExpressionApplication::CanReadDocument(AppFile &anAppFile, int failcode)
// return true for any type we can read (when file dropped on icon bar )
{
   register OSType fileType = anAppFile.fType;

#ifdef SPELL
   if (fileType == kDictionaryFile && anAppFile.fFileIsSafe)
     return gDictionaries->NoteFile(anAppFile);
#endif

   // maybe if file is not safe (ram file dropped on icon), treat as stationery??

   if (fileType == kStationeryPad || fileType == kExpressionFile || fileType == kTextFile ||
#ifdef WORD7
           fileType == kMSWord ||
#ifndef NETWP
           (fileType == kDOS && (anAppFile.fType = kMSWord, TRUE)) ||
#endif
#endif
#ifndef NETWP
           fileType == kFirstWordFile ||
#endif
            fileType == kCSV)
                   // ... and all the other file types acceptable
      return TRUE;
   if (failcode == 0)
      return FALSE;
   FailGeneral(failcode);   // does not return
}

// ------------------------------------------------------------------------
void GetPath(char *path)
{
   sprintf(path, "%s$Path", gProgName);
}

#ifndef NETWP
// ------------------------------------------------------------------------
static void SetAppMenuTicks(int menuId, char *defName)
{
   MenuHandle thePadMenu = *GetResMenu(menuId);
   char buffer[32];

   if (thePadMenu != NULL)
   {
      // set ticks on the menu in any case
      for (int item = CountMItems(thePadMenu); item > 0; item--)
         EnableCheck(CmdFromMenuItem(menuId, item - 1), TRUE,
            (item == 1 && defName == NULL) ||
               (defName != NULL &&
                  (GetItem(thePadMenu, item, buffer), strcmp(buffer, defName) == 0)));
   }
}
#endif

// ------------------------------------------------------------------------
// new 26/08/94
bool _TExpressionApplication::SetupDynamicMenu(CmdNumber aCmdNumber, int menuNum, bool create)
{
#if defined TABLES && !defined NETWP
  MenuHandle* thePadMenu;

  if (menuNum == cmStationery && (thePadMenu = GetResMenu(cmStationery), *thePadMenu != NULL))
  {
    wr_os_regset f_regs;              // regset for getting terminal names
    int termName[10];
    char path[20];
    char buffer[260];
    char *p;
    char *stop;

    DelMenuItems(thePadMenu, 2);   // new menu entries are added starting from number 2
    if (create)
    {
       // get list of path directories into buffer, using <app$Dir>. if no app$Path found
       GetPath(path);
       if (JSRead(path, buffer) != NULL)
          strcpy(buffer, gDirName);

       p = strcat(buffer, ",") - 1;   // make it easier to parse

       f_regs.r[0] = 10;              // get name & load address
       f_regs.r[2] = int(termName);   // buffer to receive name & address, etc.
       f_regs.r[5] = 40;              // buffer length
       f_regs.r[6] = 0;               // find all names in directory

       for ( ; *(p + 1) != 0; )       // p points to comma, so see if one we strcat-ed above
       {
          // scan through each of the components in the path
          stop = NULL;
          for (; *(++p) == ' ';) {}   // find a non-space
          f_regs.r[1] = int(p);       // pointer to name start
          f_regs.r[4] = 0;            // initialise for directory
          for (; *p != ','; p++)      // scan to comma at end
             if (*p == '.')
                stop = p;             // remember last '.'
          if (stop == NULL)
             stop = p;
          *stop = 0;                  // replace final '.' (or ',') by terminator

          for (;;)
          {
             f_regs.r[3] = 1;         // single directory entry
             if (wr_os_swix(OS_GBPB, &f_regs) != NULL ||          // get a name from dirctory
                                        f_regs.r[4] == -1)     // -1 means all names found
                break;
             if ((termName[0] & 0x0ffffff00) == 0x0fffd0000)   // its a pad (type 0xd00)
             {
                AppendMenuItem(thePadMenu, (char *)(termName + 5));
             }
          }
       }
       SetAppMenuTicks(cmStationery, gPadNamePtr);
    }
    return TRUE;
  }
#endif
#if WORDBANK == 1
  if (menuNum == cmWordBank)
    return SetupWordListMenu(create);
#endif
  return BASEAPPLICATION::SetupDynamicMenu(aCmdNumber, menuNum, create);
}

// ------------------------------------------------------------------------
void _TExpressionApplication::DoSetupMenus()
{
  BASEAPPLICATION::DoSetupMenus();

#ifdef NETWP
//  EnableCmd(cNewDocument);
#else
#ifdef TABLES
  EnableCmd(cStationeryMenu);    // 26/08/94 need to enable this when dynamic menu
#endif
  SetAppMenuTicks(cmStationery, gPadNamePtr);

  EnableCmd(cUserDictionary);
#ifdef TABLES
  EnableCmd(cHyphExceptions);
#endif
#ifdef PRO
  EnableCmd(cChoices);
  EnableCmd(cSaveChoices);
#endif
#endif
#if WORDBANK == 1
  EnableCmd(cWordBankMenu);
  if (gBankNamePtr)
  {
    SetAppMenuTicks(cmWordBank, gBankNamePtr);
  }
  // cWordBankShow needs to be disabled expicitly because not in main menu tree
  Enable(cWordBankShow, bool(gBankNamePtr));
  EnableCmd(cActivateHelp);
#endif
}

// *************************************************************************
void GetCanonicalName(char *root, char *buff)
{
   _kernel_swi_regs r;
   char path[20];

   r.r[0] = 37;
   r.r[1] = (int)root;
   r.r[2] = (int)buff;
   r.r[3] = (int)path;
   r.r[4] = int(gDirName);
   r.r[5] = 511;
     
   GetPath(path);
   if (gWimpVersion < 300 || _kernel_swi(OS_FSControl, &r, &r) != NULL)
      sprintf(buff, "%s%s", (char *)r.r[4], (char *)r.r[1]);
}

#if defined TRACE || ! defined NETWP
// *************************************************************************
TCommand SelectFromPadMenu()
{
   if (gPadNamePtr != NULL)
   {
      char buff[512];
      int fd;

      GetCanonicalName(gPadNamePtr, buff);

      if (MAOpenFile(buff, fd, kAccessRdIfExists) == NULL && fd != 0)
      {
         wr_wimpt_noerr(CloseFile(fd));
         gApplication->HandleFinderRequest(buff, FALSE);

         return gNoChanges;
      }
   }
   gApplication->OpenNew();  // 03/02/93 cOpen);
   return gNoChanges;
}
#endif

#ifdef SPELL
// ------------------------------------------------------------------------
static void ReformatDoc(TObject null, TDocument theDoc, int refType)
{
  TExpressionDocument(theDoc)->DoReformat(refType, 1);
}
#endif

#if WORDBANK == 1
// ------------------------------------------------------------------------
static TCommand ActivateHelp()
{
  char buffer[512];

  if (JSRead("Help$Dir", buffer) != NULL || buffer[0] == 0)
  {
    // Help$Dir not found, so load help application
    buffer[0] = '/';
    if (JSRead("Help$Start", buffer + 1) == NULL && buffer[1] != 0)
      wr_os_swi1(wr_os_X | StartTask, (int)buffer);
    else
      wr_os_swi1(wr_os_X | StartTask, (int)GetRsrcMisc(31));
  }
  else
  {
    // simulate a click on the Help icon
    wr_os_regset r;

    r.r[0] = 0;
    r.r[1] = (int)buffer;
    r.r[2] = 512;
    if (wr_os_swix(0x42681 /* TaskManager_EnumerateTasks */, &r) == NULL)
    {
      for (char *p = buffer; p < (char *)r.r[1]; p += 16)
      {
        if (strcmp("Help", (char *)*((int *)(p + 4))) == 0)
        {
          wr_wimp_eventdata data;

          data.but.m.x = 0;
          data.but.m.y = 0;
          data.but.m.bbits = 4;
          data.but.m.w = -2;
          data.but.m.i = -1;
          wr_wimp_sendmessage(6, (wr_wimp_msgstr *)&data, *((int *)p));
          return gNoChanges;
        }
      }
    }
  }
  return gNoChanges;
}
#endif

// ------------------------------------------------------------------------
TCommand _TExpressionApplication::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
   bool isHyph = FALSE;

   if (aCmdNumber < 0)        // 26/08/94 new for stationery menu
   {
      int aMenu;
      int anItem;

      aMenu = CmdToMenuItem(aCmdNumber, anItem);
#ifndef NETWP
      if (aMenu == cmStationery)
      {
         if (anItem == 1)
            gPadNamePtr = NULL;
         else
         {
            gPadNamePtr = gPadName;
            CmdToName(aCmdNumber, gPadName);
         }
         return SelectFromPadMenu();
      }
#endif
#if WORDBANK == 1
      if (aMenu == cmWordBank)
      {
         gBankNamePtr = gBankName;
         CmdToName(aCmdNumber, gBankName);
         return SelectFromBankMenu();
      }
#endif
   }
#ifdef SPELL
   else if (aCmdNumber == cUserDictionary || (isHyph = TRUE, aCmdNumber == cHyphExceptions))
   {
      if (gDictionaries->DoExceptions(isHyph))
         gDocList->Each(NULL, (DoToObject)ReformatDoc, kReformatAll);

      return gNoChanges;
   }
#endif
#if defined PRO && !defined NETWP
   else if (aCmdNumber == cChoices)
     return DoDialogue(this, cChoices, 48, -1);
   else if (aCmdNumber == cSaveChoices)
     return SaveChoicesToFile();          // 10/02/96 menu command as well as button
#endif
#if WORDBANK == 1
   if (aCmdNumber == cWordBankShow)
      return SelectFromBankMenu();
   if (aCmdNumber == cActivateHelp)
      return ActivateHelp();
#endif
   //#ifdef NETWP
   //   if (aCmdNumber == cNewDocument)
   //     return SelectFromPadMenu();
   //#endif
   return BASEAPPLICATION::DoMenuCommand(info, aCmdNumber);
}


// ======================== TExpressionDocument ===========================
_TExpressionDocument::_TExpressionDocument(OSType fileType) : (fileType)
   // 03/02/93, bool keepsDataOpen, bool stationery) : (fileType, keepsDataOpen, stationery)
{
  TBodyStyleStruct bodyProtoType;
#ifndef ZERO_OBJ
  fSpellChecker = NULL;
  fMergeData = 0; // MMerge 13/5/92
  fUnsafeMergeFile = FALSE;
  fNormalCharStyleDone = FALSE;
#endif
  NewStructureHandler(new _TTextStructure(this), kTextStruct,
// #ifdef AUTONUM
                                    2);    // 12/10/94
// #else
//                                     1);
// #endif
  NewStructureHandler(new _TPictStructure(this, kPict), kPictStruct, 1);
  NewStructureHandler(new _TBodyStructure(this, kDocument), kBodyStruct, 2); // fn1
#ifdef TABLES
  NewStructureHandler(new _TTableStructure(this), kTableStruct, 1);
#else
  NewStructureHandler(new _TStructure(this, sizeof(TCellItem)), kTableStruct, 1);
#endif
#ifdef MATHS
  NewStructureHandler(new _TMathStructure(this), kMathStruct, 1);          // 13/01/92
#else
  NewStructureHandler(NULL, kMathStruct, 1);       // 04/08/92 to repair converted V5 docs
#endif
  NewStructureHandler(new _TStyleStructure(this, kText), kTextStyleStruct, 1);
  NewStructureHandler(new _TPictStyleStruct(this), kPictStyleStruct, 1);
  bodyProtoType = new _TBodyStyleStruct(this, kDocument);   // 12/02/91
  bodyProtoType->IBodyStyleStruct(kDocument, "", gNullCurrency);  
  NewStructureHandler(bodyProtoType, kBodyStyleStruct, 1);
  NewStructureHandler(new _TColumnStyleStructure(this), kColumnsStyleStruct, 1);
#ifdef MATHS
  NewStructureHandler(new _TMathStyleStruct(this), kMathStyleStruct, 1);  // 13/01/92
#else
  NewStructureHandler(new _TStyleStructure(this, kMaths), kMathStyleStruct, 1);  // 26/08/92
#endif
  NewStructureHandler(new _TPictObject(), TStructTypes(-1),
#if SIDEBAR == 1
                       2);       // TalkWrite saves extra data for pix
#else
                       1); // see below
#endif
#ifdef INDEX
  NewStructureHandler(TDiscObject(new _TIndexStructure(this, kIndexEntry)),
                            kIndexRefStruct, 1);
#else
  NewStructureHandler(NULL, kIndexRefStruct, 1);  // 03/05/95 so we can fail in non-pro products
#endif
#ifdef MATHS
  fAlignList = new _TAlignList(this);  // 26/03/92
#else
  fAlignList = new _TAssocList();  // 09/05/92
#endif
//  draw_unknown_object_handler X = draw_set_unknown_object_handler(XHANDLER, NULL);
}


// ------------------------------------------------------------------------
void _TExpressionDocument::NewStructureHandler(TDiscObject protoType,
                              TStructTypes structType, int version)
{
  FailInfo fi;
  TRecordHandler recHandler;

  CatchFailures(&fi);
#ifdef SPELL
  if (fSpellChecker == NULL)
    fSpellChecker = new _TSpellChecker(this);  // 15/10/90
#endif
  recHandler = new _TRecordHandler(this, NULL, protoType, version);
  Success(&fi);

  // 04/07/90: passed -ve value to save having CatchFailures in ctor
  if (structType < 0)
  {
      fPictureHandler = recHandler;
  }
  else
    fStructureHandlers[structType] = recHandler;
  return;

Rescue:
  FreeIfObject(protoType);
  _TExpressionDocument::Free();    // 15/10/90
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TExpressionDocument::Free()
{
  ClosePicker(this);                // 08/07/94 [22005]
  StartClearing();
#ifdef SPELL
  FreeIfObject(fSpellChecker);
#endif
  _TTextDocument::Free();
  EndClearing();
  MemSpaceIsLow();   // 11/08/92 allow mem mgr to grab its contingency before reallocating
  ReAllocHandle(&gLastFile);        // 29/07/93 [21000]
  gEnabledControls->ReAllocate();
  gDocList->ReAllocate();
  gFreeWindowList->ReAllocate();
#ifdef SPELL
  gDictionaries->ReAllocate();
#endif
#ifdef FN
  ReallocBreakStack();    // 27/04/92
#endif
#ifndef NETWP
  ReallocControlBlocks();    // 05/04/94
#endif
}

// ------------------------------------------------------------------------
static void MaxSpaceRequired(TObject null, TRecordIndex aRecord, TRecordHandler handler,
                                                   int *maxSize)
// 13/07/92 to get largest picture size while printing
{
  *maxSize = Max(*maxSize, handler->GetRecordLength(aRecord));
}


// ------------------------------------------------------------------------
void _TExpressionDocument::StartPrinting()   // bool loadMergeDoc)
// 13/07/92 to get largest picture size while printing
{
  int maxSize = 0;

  Purge();  // 20/07/92 use minimum store while printing
  PruneHeap();   // 20/07/92
  fPictureHandler->ForAllRecordsDo(NULL, (DoToRecord)MaxSpaceRequired, &maxSize);
  SetPrintContingency(maxSize);
//#ifdef TABLES
//  if (loadMergeDoc)
//    LoadMergeDocument();
//#endif
}

#ifdef TABLES
// ------------------------------------------------------------------------
// MMerge methods 13/5/92
TTextDocument _TExpressionDocument::DoLoadMergeDocument(AppFile &anAppFile,
                               TCurrency *tableCurrency, int numHeadings)
{
  TCurrency tabCurr;
  FailInfo fi;
  TTextDocument aDocument;

  if (anAppFile.fName != NULL)
  {
    TFileInfo fileInfo;
    char stamp[6];

    // if we are being asked to open the current merge file and it has not
    // changed, then we can avoid rereading it
    GetFileInfo(anAppFile.fName, fileInfo);
    if (fMergeDoc != NULL && strcmp(fMergeDoc->fStationery ? fMergeDoc->fStationeryName :
                                 fMergeDoc->fTitle, anAppFile.fName) == 0 &&
        (fileInfo.FileModDate(stamp),
        memcmp(stamp, fMergeDoc->fModDate, 5) == 0))
      return fMergeDoc;         // the merge file is unchanged

    // set up AppFile structure from file name - it may have gone or even
    // though the name is the same it is possible it may be a different type
    // anAppFile.fName is correct, but cannot use fType
    fileInfo.CheckType();            // fail if not file
    anAppFile.fType = (fileInfo.fInfo.loadaddr & 0x000fff00) >> 8;
  }

  aDocument = TTextDocument(gApplication->DoMakeDocument(anAppFile.fType, FALSE));
                               // 03/02/93 gApplication->KindOfDocument(0, &anAppFile)));

  CatchFailures(&fi);

  if (anAppFile.fName == NULL)
    aDocument->ReadFromRamFile(anAppFile, kForMerge);
  else
    aDocument->ReadFromFile(anAppFile, kForMerge);

  tabCurr = TBodyStructure(aDocument->GetStructureReadOnly(aDocument->fBody))->
                                      GetBodyItem(1);
  if (Curr_fType(tabCurr) != kTableStruct)
    FailGeneral(kNotTable);
  if (TColumnStructure(aDocument->GetStructureReadOnly(tabCurr))->fNumberOfRows <= numHeadings)
    FailGeneral(kMergeFileEmpty);

  Success(&fi);

  *tableCurrency = tabCurr;
  return aDocument;

Rescue:
  FreeIfObject(aDocument);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
// load the merge document (if necessary) at the start of printing with merge
// if it is temporary, use the last one dropped on the dialogue
void _TExpressionDocument::LoadMergeDocument()
// 14/07/92 param added
{
  if (fMergeDoc == NULL || // fMergeDoc->fTitle != NULL)
                       !TExpressionDocument(fMergeDoc)->fUnsafeMergeFile)   // 07/07/92
        // Load the merge document now as it is not a temp file
  {
    AppFile anAppFile;
    TCurrency tabCurr;
    TTextDocument mergeDoc;
    FailInfo fi;

    CatchFailures(&fi);
    anAppFile.fName = fMergeFileName;
    anAppFile.fEstSize = -1;         // indicates file is safe
    anAppFile.fFileIsSafe = TRUE;
    mergeDoc = DoLoadMergeDocument(anAppFile, &tabCurr, fHeadings);
    Success(&fi);

    // only overwrite fields when we have passed fail-possible code
    if (mergeDoc != fMergeDoc)
    {
      fMergeData = tabCurr;
      ReplaceObject(fMergeDoc, mergeDoc);
      // FreeIfObject(fMergeDoc);
      // fMergeDoc = mergeDoc;
    }
    return;
Rescue:
    if (fMergeDoc == NULL)   // ignore the failure if we already have a merge
                             // file loaded (file must have been deleted)
    {
      gErrorParm3 = fMergeFileName;
      FailNewMessage(&fi, msgOpenFailed);
    }
  }
}

// ------------------------------------------------------------------------
bool _TExpressionDocument::DoMerge(int action)
// action = 1 to initialise, 0 to get next, -1 to finish, -2 to rfmt after changing
{
  FailInfo fi;
  bool DoMerge_r = TRUE;
  // int numRows = 1;

  fMergeActive = action >= -1;
  if (action < 0)
    fMergeIndex = 0;
  else
  {
    if (action > 0)
    {
      if (fMergeDoc == NULL)
        // Load the merge document now
        LoadMergeDocument();
      fMergeIndex = fHeadings + 1;
    }
    else
      fMergeIndex++;
    if (fMergeIndex >= MergeRows())
                 // TColumnStructure(fMergeDoc->GetStructureReadOnly(fMergeData))->fNumberOfRows)
      DoMerge_r = FALSE;
  }
  if (fMainViewList != NULL)   // 20/05/92 avoid reformat if main view is/soon to be freed
  {
    GetSelection(TRUE)->fReformatType = kReformatAll;
    CatchFailures(&fi);
    Reformat();
    Success(&fi);
  }
  fMergeActive = FALSE;
  return DoMerge_r;
  // return fMergeIndex < numRows;

Rescue:
  fMergeActive = FALSE;
  fMergeIndex = 0;
  ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
void _TExpressionDocument::GetField(int recNumber, int fieldNumber, char *value)
{
  TColumnStructure mergeData;

  value[0] = 0;

  if (fMergeData != 0 &&
          (mergeData = TColumnStructure(fMergeDoc->GetStructureReadOnly(fMergeData)),
           fieldNumber <= mergeData->fNumberOfColumns))
  {
    TCurrency cell = mergeData->AtRowCol(recNumber, fieldNumber)->cell;
    
    if (cell != 0 && Curr_fType(cell) == kTextStruct)
      TTextStructure(fMergeDoc->GetStructureReadOnly(cell))->
                                   GetSelectedText(cell, NULL, NULL, value);
  }
}


// ------------------------------------------------------------------------
bool _TExpressionDocument::AddFieldName(char *str, int fldLen)
{
  int zeroByte = GetHandleSize(fMergeTitles) - 1;

  // knock off any trailing white space
  for (; fldLen >= 0; fldLen--)
    if (!isspace(str[fldLen - 1]))
      break;

  // knock off any leading white space
  for (; fldLen >= 0; fldLen--)
  {
    if (!isspace(str[0]))
      break;
    str++;
  }

  // check uniqueness, if there was a match, set as if empty
  if (GetFieldNumber(str) != 0)
    fldLen = 0;

  InsertIntoHandle(&fMergeTitles, zeroByte, str - 1, fldLen + 1);
//  Munger(&fMergeTitles, zeroByte, NULL, 0, str - 1, fldLen + 1);
  fMergeTitles[zeroByte] = fldLen + 1;
  return TRUE;
}


// ------------------------------------------------------------------------
void _TExpressionDocument::ProcessFieldNames()
// the user has just clicked on the field name list menu entry
{
  Str255 userBuffer;
  char *userString = userBuffer;

  CmdToName(cMergeList, userBuffer);
  if (fMergeTitles == NULL)
    fMergeTitles = StringHandle(FailNIL(NewHandle(1)));
  else
  {
    if (strcmp(fMergeTitles, userString) != 0)
      UpdateChangeCount(1);                      // 29/04/94 [21714] add * if changes
    SetHandleSize(&fMergeTitles, 1);
  }
  fMergeTitles[0] = 0;

  // scan through the comma separated list passing each item to AddFieldName
  for (char *p = userString; *p; userString = p + 1)
  {
    p = strchr(userString, ',');
    if (p == NULL)
      p = strchr(userString, 0);
    AddFieldName(userString, p - userString);
  }
  CommitLastDocCommand();    // 08/10/92
  DoMerge(-2);
}


// ------------------------------------------------------------------------
void _TExpressionDocument::GenerateFieldNames()
// Called when a new file is loaded to check if the user has specified any field names
{
  if (fMergeTitles == NULL)
  {
    fMergeTitles = StringHandle(FailNIL(NewHandle(1)));
    fMergeTitles[0] = 0;
  }

  if (fHeadings || fMergeTitles[0] == 0)     // 21/05/92 reset if headings as well as no names
  {
    char str[255];
    int numCols =
          TColumnStructure(fMergeDoc->GetStructureReadOnly(fMergeData))->fNumberOfColumns;

    SetHandleSize(&fMergeTitles, 1);      // 21/05/92 reset if headings
    fMergeTitles[0] = 0;                  // 21/05/92
    for (int n = 1; n <= numCols; n++)
    {
      int fldLen = 0;

      if (fHeadings)
      {
        GetField(1, n, str);
        if ((fldLen = strlen(str)) > kLongestFieldName)
        {
          // truncate the string to the last space before the limit
          char *lastSpace;

          str[kLongestFieldName] = 0;
          if ((lastSpace = strrchr(str, ' ')) != NULL)
            *lastSpace = 0;
          fldLen = strlen(str);
        }
      }

      // knock off any trailing non alphanumerics except the final char
      for (; fldLen > 0; fldLen--)
        if (isalnum(str[fldLen - 1]))
          break;

      AddFieldName(str, fldLen);
    }
    DoMerge(-2);   // reflect the changes in the doc
  }
}


// ------------------------------------------------------------------------
void _TExpressionDocument::GetFieldValue(int fieldNumber, char *value)
{
  value[0] = 0;
  if (fieldNumber == 0)
  {
    if (fMergeIndex != 0)
    {
      char str[255];
      int numCols =
        TColumnStructure(fMergeDoc->GetStructureReadOnly(fMergeData))->fNumberOfColumns;
      int totalLen = -2;

      for (int n = 1; n <= numCols; n++)
      {
        GetField(fMergeIndex, n, str);
        if ((totalLen += strlen(str) + 2) > 255)
          break;
        if (n != 1)
          strcat(value, ", ");
        strcat(value, str);
      }
    }
  }
  else if (fMergeIndex == 0)
  {
    GetFieldName(fieldNumber, value + 1);
    value[0] = '«';
    strcat(value, "»");
  }
  else
    GetField(fMergeIndex, fieldNumber, value);
}


// ------------------------------------------------------------------------
void _TExpressionDocument::GetFieldName(int fieldNumber, char *value)
{
  int i = 1;
  char *p = fMergeTitles;
  int copyLen;

  if (p == NULL)
    copyLen = 0;
  else
  {
    for (; i != fieldNumber && *p; i++, p += *p) {}

    copyLen = *p - 1;
  }
  if (copyLen > 0 && i == fieldNumber)    // found useful field name
    ((char *)memcpy(value, p + 1, copyLen))[copyLen] = 0;
  else
    sprintf(value, gMergePrefix, fieldNumber);
}


// ------------------------------------------------------------------------
int _TExpressionDocument::GetFieldNumber(char *name)
{
  int nameLen = strlen(name);
  int prefixLen = strlen(gMergePrefix) - 2;

  if (name[0] == '«')
  {
    name++;
    nameLen -= 2;
  }

  if (nameLen > prefixLen &&                           // -2 for %d
          memcmp(name, gMergePrefix, prefixLen) == 0)
  {

    if (isdigit(name[prefixLen]))
    {
      int theNum;
      int i;
      char *p;

      StringToNum(name + prefixLen, theNum);
      for (i = 1, p = fMergeTitles; *p; i++, p += *p)
      {
        if (i == theNum && *p != 1)
          return 0;          // the field corresponding to Field n is not empty,
                             // so Fieldn would not be returned
      }
      return theNum;         // the field name is (still) Fieldn
    }
  }

  if (fMergeTitles != NULL)
  {
    char *ptr;
    int i = 1;

    for (ptr = fMergeTitles; *ptr; i++, ptr += *ptr)
    {
      int fieldLen = *ptr - 1;

      if (fieldLen == nameLen && memcmp(name, ptr + 1, fieldLen) == 0)
        return i;
    }
  }
  return 0;
}

// ------------------------------------------------------------------------
bool _TExpressionDocument::HasMergeFile()
{
  return (fMergeDoc != NULL || fMergeFileName != NULL);
}

#define thisItemLen 255
// ------------------------------------------------------------------------
void _TExpressionDocument::BuildMergeMenu()
{
  MenuHandle *mergeMenu;
  int aMenu;
  int anItem;
  char *ptr;
  Str255 buffer;

  // delete all the entries following cMergeSide & rebuild
  aMenu = CmdToMenuItem(cMergeSide, anItem);
  mergeMenu = GetResMenu(aMenu);
  DelMenuItems(mergeMenu, anItem + 1);

  if (fMergeTitles == NULL || fMergeTitles[0] == 0)
  {
    anItem = AppendMenuItem(mergeMenu, GetString(kNoFields));
    DisableItem(*mergeMenu, anItem);
    SetCmdName(cMergeList, "");
  }
  else
  {
    for (anItem = 1, ptr = fMergeTitles; *ptr; anItem++, ptr += *ptr)
    {
      int fieldLen = *ptr - 1;

      if (fieldLen > 0)               // found useful field name
        ((char *)memcpy(buffer, ptr + 1, fieldLen))[fieldLen] = 0;
      else
        sprintf(buffer, gMergePrefix, anItem);
      AppendMenuItem(mergeMenu, buffer);
    }

    memcpy(buffer, fMergeTitles, Min(GetHandleSize(fMergeTitles), thisItemLen));
    buffer[thisItemLen] = 0;
    for (ptr = buffer; *ptr && ptr < buffer + thisItemLen; ptr += anItem)
    {
      anItem = *ptr;
      *ptr = ',';
    }
    SetCmdName(cMergeList, buffer + 1);
  }
}
// End of MMerge methods
#endif

// ------------------------------------------------------------------------
void _TExpressionDocument::DoReformat(int reformatType, int change)
{
  TSelection selection = GetSelection(TRUE); // 18/05/93 [20880] GetNewSelection();

  if (reformatType >= 0)
    selection->fReformatType = reformatType;

  HighlightSelection(HLOff, FALSE);
  Reformat();
  HighlightSelection(HLOn, FALSE);   // 24/05/91 reset caret after spell chk
  UpdateChangeCount(change);
}

// ------------------------------------------------------------------------
TMainView _TExpressionDocument::DoCreateMainView(int viewType)
// new 25/06/90 to allow different varieties of main view to be created
// when reading from disc. The actual view type created is determined
// by the message 'vn', where n is passed as the viewType parameter.
{
  return TMainView(CreateRsrcViews(viewType, 'v', this, NULL));
}


#ifdef TABLES
// -------------------------------------------------------------------------
THandler _TExpressionDocument::CreateAHandler(TDialogView theDialog,
    TStyleFormat theStyle, TStyleFormat theChanges, TStyleTypes theType)
{
  switch (theStyle->GetChangeDlg(theType))
  {
    case kChapterDlgID:
      return new _TChapterDlgHpr(theDialog, theStyle, theChanges, theType);
    case kColStyleDlg:
      return new _TColStyleDlgHpr(theDialog, theStyle, theChanges, theType);
    case kFigureDlg:
      return new _TFigureDlgHpr(theDialog, theStyle, theChanges, theType);
    case kPicStyleDlg:
      return new _TPictStyleHpr(theDialog, theStyle, theChanges, theType);
#ifdef MATHS
    case kMathStyleDlg:
      return new _TMathDlgHpr(theDialog, theStyle, theChanges, theType);
#endif
    default:
      // by default return a TStyleDlgHelper
      return _TTextDocument::CreateAHandler(theDialog, theStyle, theChanges, theType);
  }
}
#endif

// ------------------------------------------------------------------------
TCurrency _TExpressionDocument::InitStyle(int rsrcId, char * &resource,
          TStructTypes structType, TStyleTypes styleType, TDiscObject &rec,
          char *name)
{
  TCurrency style;
  char *resName;

#ifdef WORD7
  if (fFileType == kMSWord)
    resource = RealGetResource(rsrcId + 32);
  else
    resource = NULL;
  if (resource == NULL)
#endif
    resource = RealGetResource(rsrcId);
  style = NewCurrency(structType, rec);
  // 22/04/94 [21700] GetResInfo(resource, theId, theType, name);
#ifdef WORD7
  if (rsrcId == kParaId && fFileType == kMSWord)
    resName = (char *)GetRsrc(0, 'u');      // Change 'Paragraph Style' to 'Normal'
  else
    resName = NULL;
  if (resName == NULL)
#endif
    resName = (char *)GetResourceName(rsrcId);
  if (resName == NULL)
    name[0] = 0;
  else
  {
    // int defined;
    int isEmphasis;

    strcpy(name, resName);
    isEmphasis = strtoul(resource, NULL, 16);    // sscanf(resource, "%x", &defined);
    isEmphasis = (isEmphasis & kEmphasis) / kEmphasis;
    fStyleSheet->AddStyle(name, styleType, isEmphasis, style,
#ifdef MATHS
                                                rsrcId == kBoldId ? 9 :
#endif
                                                          isEmphasis);
                     // 27/01/92 pass TRUE for (built-in) emphasis styles
                     // 28/01/92 and suppress allocating a command number
  }
  return style;
}


// ------------------------------------------------------------------------
TCurrency _TExpressionDocument::InitBodyStyle(int rsrcId, char * &resource,
     TStructTypes structType, TStyleTypes styleType, TCurrency p2)
{
  char name[30];
  TDiscObject rec;
  TCurrency style;

  style = InitStyle(rsrcId, resource, structType, styleType, rec, name);
  TBodyStyleStruct(rec)->IBodyStyleStruct(styleType, name, p2);
  return style;
}


// ------------------------------------------------------------------------
TCurrency _TExpressionDocument::InitStyleStruct(int rsrcId, char * &resource,
     TStructTypes structType, TStyleTypes styleType)
{
  char name[30];
  TDiscObject rec;
  TCurrency style;

  style = InitStyle(rsrcId, resource, structType, styleType, rec, name);
  TStyleStructure(rec)->IStyleStructure(styleType, name);
  return style;
}


// ------------------------------------------------------------------------
TCurrency _TExpressionDocument::DoInitialStyles(TExpressionView pagesView,
                           TCurrency *hfStyle)
{
  TCurrency bodyCurrency;
  TCurrency textCurrency;
  TCurrency chapterStyle;
  TCurrency sectionStyle;
  TCurrency listStyle;
  TCurrency pictCurrency;
  TCurrency targetCurrency;
  char *chapterRes;
  char *sectionRes;
  char *listRes;
  TBodyStructure doc;
  TBodyItem bodyItem;
  TCurrency docHeadStyle;
  TCurrency chapHeadStyle;
  TCurrency secHeadStyle;
  TCurrency figStyle;
  char *emphRes;
  char *docHeadRes;
  char *chapHeadRes;
  char *secHeadRes;
  char *pictRes;
  char *figRes;
  char *paraRes;
  TCurrency pictStyle;
  TCurrency bodyStyle;
  TCurrency paraStyle;
  char *bodyRes;
  char *hfRes;
  TDiscObject rec;
  char* tableRes;
  TCurrency columnStyle;

  // 03/02/91 default emphasis style
  fEmphasisStyle = InitStyleStruct(kEmphasisId, emphRes, kTextStyleStruct, kText);

  // 22/11/90 default paragraph style
  paraStyle = InitStyleStruct(kParaId, paraRes, kTextStyleStruct, kText);

  fBodyStyles[kCurrTextStyle] = paraStyle;          // 22/11/90

  docHeadStyle = InitStyleStruct(kDocHeadingId, docHeadRes, kTextStyleStruct, kText);

  bodyStyle = InitBodyStyle(kBodyId, bodyRes, kBodyStyleStruct, kDocument, docHeadStyle);

  // 11/04/91 for header footer styles
  if (hfStyle != NULL)
    *hfStyle = InitBodyStyle(kHFId, hfRes, kBodyStyleStruct, kDocument, nc);

  chapHeadStyle = InitStyleStruct(kChapHeadingId, chapHeadRes, kTextStyleStruct, kText);

  chapterStyle = InitBodyStyle(kChapterId, chapterRes, kBodyStyleStruct, kChapter, chapHeadStyle);

  secHeadStyle = InitStyleStruct(kSecHeadingId, secHeadRes, kTextStyleStruct, kText);

  sectionStyle = InitBodyStyle(kSectionId, sectionRes, kBodyStyleStruct, kSection, secHeadStyle);

  listStyle = InitBodyStyle(kListId, listRes, kBodyStyleStruct, kList, nc);

  pictStyle = InitStyleStruct(kPictId, pictRes, kPictStyleStruct, kPict);

  // 24/07/90 - tables
  columnStyle = InitStyleStruct(kTableId, tableRes, kColumnsStyleStruct, kColumns);

  // 06/11/90 new init for Figures
  figStyle = InitBodyStyle(kFigureId, figRes, kBodyStyleStruct, kFigure, nc);

  bodyCurrency = NewCurrency(kBodyStruct, rec);
  doc = TBodyStructure(rec);
  doc->IBodyStructure(nc, bodyStyle, kDocument);

  targetCurrency = nc;
  switch (fFileType)
  {
    case kExpressionFile:
    case kStationeryPad:
    case kTWScrapType:
      textCurrency = NewCurrency(kTextStruct, rec);
      TTextStructure(rec)->InitNewStructure(bodyCurrency, textCurrency, nc,
                                          kText, TRUE, NULL); // 26/03/92
      targetCurrency = textCurrency;
      break;

    case kDrawFile:
    case kSpriteFile:
    case kJPEGFile:
#ifdef FILMS
    case kFilm:
    case kACE:
#endif
      pictCurrency = NewCurrency(kPictStruct, rec);
      TPictStructure(rec)->IPictStructure(bodyCurrency, pictStyle, kPict);
      targetCurrency = pictCurrency;
      break;

#ifdef TRACE
    case kTextFile:
#ifdef WORD7
    case kMSWord:
#endif
#ifndef NETWP
    case kFirstWordFile:  // 08/10/90 kFirstWordFile too
#endif
    case kCSV:
      // structure done in DoReadTextFile()
      break;

    default:
      Assert(0, 41);
#endif
  }

  // 12/07/90 - if... clause new, as the bodyItem is plugged in later on
  if (targetCurrency != nc)
  {
    bodyItem.fCurrency = targetCurrency;
    bodyItem.fState = kShown;
    bodyItem.fNew = TRUE;
    bodyItem.fAffected = FALSE;
    bodyItem.fGone = FALSE;
    bodyItem.fNoteNumber = 0;            // 06/04/96 was uninitialised
    bodyItem.spare = 0;
    doc->InsertFirst(&bodyItem);
  }

  fBody = bodyCurrency;       //  SetBody(bodyCurrency);
  fNumLevels = 2 + kBaseBodyStyle; // 10/02/92 add 2 for notes; 6;  // 30/05/90
  fBodyStyles[0 + kBaseBodyStyle /* 10/02/92; 6 */] = chapterStyle;
  fBodyStyles[1 + kBaseBodyStyle /* 10/02/92; 6 */] = sectionStyle;
  fBodyStyles[kCurrPictStyle] = pictStyle;
  fBodyStyles[kCurrListStyle] = listStyle;
  fBodyStyles[kCurrColumnsStyle] = columnStyle;
  fBodyStyles[kCurrFigureStyle] = figStyle;         // 11/09/90
  pagesView->NewStyle(docHeadStyle, docHeadRes);    // 11/09/90
  pagesView->NewStyle(chapHeadStyle, chapHeadRes);
  pagesView->NewStyle(secHeadStyle, secHeadRes);
  pagesView->NewStyle(bodyStyle, bodyRes);          // 11/04/91
  if (hfStyle != NULL)
    pagesView->NewStyle(*hfStyle, hfRes);
  pagesView->NewStyle(chapterStyle, chapterRes);
  pagesView->NewStyle(sectionStyle, sectionRes);
  pagesView->NewStyle(listStyle, listRes);
  pagesView->NewStyle(pictStyle, pictRes);
  pagesView->NewStyle(columnStyle, tableRes); // 24/07/90
  pagesView->NewStyle(figStyle, figRes);     // 11/09/90
  pagesView->NewStyle(paraStyle, paraRes);   // 22/11/90
  pagesView->NewStyle(fEmphasisStyle, emphRes);   // 03/02/91

  return targetCurrency;
}

// ------------------------------------------------------------------------
void _TExpressionDocument::DoInitialState()
{
  TCurrency textCurrency;
  TExpressionView pagesView;
  TCurrency hfStyle;

  pagesView = TExpressionView(DoCreateMainView(1));
#ifdef MATHS
  // 22/09/92 ensure 3 maths styles are recreated (fields will non-empty after Revert)
  fItalicStyle = 0;
  fGreekStyle = 0;
  fSymbolsStyle = 0;
#endif
  textCurrency = DoInitialStyles(pagesView, &hfStyle);
  // MakeNoteCollector done in connectview
  ActivateMainView(pagesView);
  BuildFontRefTable();  // build up our font table list

  MakeHeaderFooter(hfStyle);      // 11/09/90
  InitialCursor(pagesView, textCurrency, /* FALSE, 06/09/92 */ 0);
  SetCurrentStyle();
  ConnectView(pagesView); // Connect print handler into the view
  Reformat();
}

#ifdef MATHS
// ------------------------------------------------------------------------
void _TExpressionDocument::AddInStyle(TMainView theMainView, TCurrency &curr, int rsrcId)
{
  if (curr == gNullCurrency)
  {
    char *resource;
#ifdef WORD7
    TStyleFormat theStyle = new _TStyleFormat();
    bool found;

    theStyle->IRes(RealGetResource(rsrcId));
    // theStyle->fDefined &= (~kEmphasis);
    found = theMainView->FindStyle(theStyle, kTextStyleStruct, curr);
    FreeIfObject(theStyle);
    if (!found)
#endif
    {
      curr = InitStyleStruct(rsrcId, resource, kTextStyleStruct, kText);
      theMainView->NewStyle(curr, resource);
    }
  }
}
#endif

// ------------------------------------------------------------------------
void _TExpressionDocument::ConnectView(TView theMainView)
{
#ifdef MATHS
  TStyleInfo info;
#endif

  theMainView->AttachPrintHandler(theMainView->fPrintHandler);
                          // on Mac, done inside IPagesPrintHandler
#ifdef MATHS
  // 08/04/92 add in the 3 built in styles
  AddInStyle(TMainView(theMainView), fItalicStyle, kItalicId);
//  if (fItalicStyle == 0)
//  {
//    char *itRes;

//    fItalicStyle = InitStyleStruct(kItalicId, itRes, kTextStyleStruct, kText);
//    TMainView(theMainView)->NewStyle(fItalicStyle, itRes);
//  }
  AddInStyle(TMainView(theMainView), fGreekStyle, kGreekId);
//  if (fGreekStyle == 0)
//  {
//    char *grkRes;

//    fGreekStyle = InitStyleStruct(kGreekId, grkRes, kTextStyleStruct, kText);
//    TMainView(theMainView)->NewStyle(fGreekStyle, grkRes);
//  }
  AddInStyle(TMainView(theMainView), fSymbolsStyle, kSymbolsId);
//  if (fSymbolsStyle == 0)
//  {
//    char *symbRes;

//    fSymbolsStyle = InitStyleStruct(kSymbolsId, symbRes, kTextStyleStruct, kText);
//    TMainView(theMainView)->NewStyle(fSymbolsStyle, symbRes);
//  }

  // 27/05/92 & 09/06/92 built in bold style
  // 22/04/94 [21700] GetResourceName instead of GetResInfo
//#ifndef WORD7
  if (fStyleSheet->FindStyleInfo(GetResourceName(kBoldId), info) == 0)
//#endif
  {
    // Bold style not found, so create one
    TCurrency boldMathStyle = gNullCurrency;

    AddInStyle(TMainView(theMainView), boldMathStyle, kBoldId);
    // char *boldRes;

    // TCurrency boldMathStyle = 
    //  InitStyleStruct(kBoldId, boldRes, kTextStyleStruct, kText);

    // TMainView(theMainView)->NewStyle(boldMathStyle, boldRes);
  }

  // 20/01/92
  if (fBodyStyles[kCurrMathsStyle] == 0)
  {
    char *mathRes;

    fBodyStyles[kCurrMathsStyle] = 
      InitStyleStruct(kMathId, mathRes, kMathStyleStruct, kMaths);
    TMainView(theMainView)->NewStyle(fBodyStyles[kCurrMathsStyle], mathRes);
  }
  // 17/06/92 Matrix and Matrix body Style
  if (fBodyStyles[kMaxLevels] == 0)
  {
    char *matrixRes;
    char *cellRes;
    TPartStyles partStyles;

    fBodyStyles[kMaxLevels] = 
      InitStyleStruct(21, matrixRes, kColumnsStyleStruct, kMatrix);
    TMainView(theMainView)->NewStyle(fBodyStyles[kMaxLevels], matrixRes);
    partStyles.fStyle =
      InitStyleStruct(22, cellRes, kTextStyleStruct, kText);
    TMainView(theMainView)->NewStyle(partStyles.fStyle, cellRes);
    TStyleStructure(GetStyleReadWrite(fBodyStyles[kMaxLevels]))->
                      PutPartStyles(kAllColsBody, gZeroRect, partStyles);
  }
  // 29/06/92 style for cells and in-line maths
  if (fBodyStyles[kMaxLevels - 1] == 0)
  {
    char *cellRes;

    fBodyStyles[kMaxLevels - 1] = 
      InitStyleStruct(23, cellRes, kMathStyleStruct, kMaths);
    TMainView(theMainView)->NewStyle(fBodyStyles[kMaxLevels - 1], cellRes);
  }
#endif
#ifdef FN
  // 31/03/92 set up footnote styles for old documents
  if (fBodyStyles[kCurrNoteSetStyle] == 0)
  {
    char *noteSetRes;

    fBodyStyles[kCurrNoteSetStyle] = 
       InitBodyStyle(kNoteSetId, noteSetRes, kBodyStyleStruct, kNoteSet, nc);
    TMainView(theMainView)->NewStyle(fBodyStyles[kCurrNoteSetStyle], noteSetRes);
  }
  if (fBodyStyles[kCurrNoteStyle] == 0)
  {
    char *noteRes;

    fBodyStyles[kCurrNoteStyle] = 
      InitBodyStyle(kFootnoteId, noteRes, kBodyStyleStruct, kFootnote, nc); 
    TMainView(theMainView)->NewStyle(fBodyStyles[kCurrNoteStyle], noteRes);
  }
  {
    // 31/03/92 moved from BodyStructure::DoRead & doinitialstate
    TBodyStructure body = TBodyStructure(GetStructureReadOnly(fBody));

#ifdef TRACE
    Assert(body->fKind == kDocument, 619);  // check test below redundant
#endif
    // if (body->fKind == kDocument)
    {
      if (body->fFootnotes == 0)
        TBodyStructure(GetStructureReadWrite(fBody))->MakeNoteCollector(fBody);
      else if (fFootnotes == 0)
      {
        fFootnotes = body->fFootnotes;  // 02/05/95 keep noteSet curr (fn collector) in doc
      }
#ifdef TRACE
      else
        Assert(fFootnotes == body->fFootnotes, 620);
#endif
    }
  }
#endif
}


// ------------------------------------------------------------------------
void _TExpressionDocument::AddAWindow(TView theMainView)
{
  TExpressionView(theMainView)->ConnectToWindow(this, NULL);
}


// ------------------------------------------------------------------------
void _TExpressionDocument::DoMakeWindows()
{
  TScaledWindow aWindow;

  fMainViewList->Each(this, (DoToObject)_TExpressionDocument::AddAWindow);

  // a document must have at least 1 window, so find last and make it active
  aWindow = TScaledWindow(TView(fMainViewList->Last())->GetWindow());

  // 30/07/90 put the caret in at last written position
  aWindow->fWindowRecord.SetCaret();
}


// ------------------------------------------------------------------------
void _TExpressionDocument::DoRead(int aRefNum, TWhyMaking forPrinting)
{
  fReformatDates = fFileType == kStationeryPad;
                                     // 05/02/93 [20615] update date/time on stat pads

  if (fReformatDates || fFileType == kExpressionFile || fFileType == kTWScrapType)
  {
    bool needsReformat;

    _TTextDocument::DoRead(aRefNum, forPrinting);

    if (forPrinting != kForMerge)
      // 22/05/92 make loading merge docs faster and avoid inappropriate reformat messages
    {
#ifndef FN
      TCurrency footnoteRec;

      // 19/05/92 force a failure if any footnotes
      if ((footnoteRec = TBodyStructure(GetStructureReadOnly(fBody))->fFootnotes) != 0 &&
              GetStructureReadOnly(footnoteRec)->fSize > 0)
        FailGeneral(34);
#endif
      needsReformat = BuildFontRefTable();  // build up our font table list
      fMainViewList->Each(this, (DoToObject)_TExpressionDocument::ConnectView); //29/06/90
      if (fReformatDates || fNeedsReformat)
                                      // 29/11/91 font substitution done - 05/02/93 [20615]
      {
        DoReformat(kReformatAll, fNeedsReformat & 1);  // 16/07/93 [20988] no change if pad
                                                       // 02/05/95 or because version change
        fNeedsReformat = needsReformat;            // set for next time doc loaded
      }
    }
  }
  else
    DoReadAlienFile(aRefNum, forPrinting);  // fFileType == kTextFile, kFirstWordFile or kCSV
  fReformatDates = FALSE;     // 05/02/93 [20615] now no longer update date/time on reformat
}

// ------------------------------------------------------------------------
void _TExpressionDocument::GetStatistics(PStatistics stats, bool countMaths)
// countMaths parameter added
{
  CommitLastDocCommand();    // 27/11/91 moved above following line
  *stats = fStatistics;
  fStructureHandlers[kTextStruct]->UpdateStatistics(stats);
#ifdef MATHS
  if (countMaths)            // 22/04/92
    fStructureHandlers[kMathStruct]->UpdateStatistics(stats);
#endif
  if (fFileType != kTWScrapType)   // 15/03/93 [20707] get count right for Save Clipboard
    stats->fCharacters -= (3 + fLeftRightHdr + fLeftRightFtr);
}

// ------------------------------------------------------------------------
bool _TExpressionDocument::GetSaveInfo(CmdNumber itsCmdNumber, char* filename, AppFile &file)
// 24/02/95 returns filetype
{
   file.fName = filename;
   file.fEstSize = -1;                // 18/02/91
   file.fFileIsSafe = TRUE;

   switch (itsCmdNumber)
      {
      case cSave:
         if (fSaveSelection)
           return GetSelectionFileType();
         return kExpressionFile;

      case cSaveStationery:
         return kStationeryPad;

#ifdef TABLES
      case cSaveDraw:               // 12/10/92
         return kDrawFile;
#endif

#ifdef WORD7
      case cSaveWord:
         return kMSWord;
#endif

#if defined PRO && !defined NETWP
      case cSavePostscript:               // 12/10/92
         return 0xff5;
#endif

#ifdef TeX
      case cSaveTeX:               // 23/02/95  /* TeX */
         return gTeXfile;
#endif

      default:
         return kTextFile;
      }
}

// ------------------------------------------------------------------------
void _TExpressionDocument::DoChoice(TView origView, int itsChoice)
{
   if (origView->fIdentifier == gIdsel)
   {
      fSaveSelection = TControl(origView)->IsOn();
      WriteToDialog(origView->GetDialogView(), fSaveCmd);
   }
   _TTextDocument::DoChoice(origView, itsChoice);
}

// ------------------------------------------------------------------------
void _TExpressionDocument::WriteToDialog(TView aDialogView, CmdNumber cmdNumber)
{
   if (cmdNumber == cDocFileInfo)
   {
      long      docSize;
      TControl  theControl;
      Str255    tempBuf;
      wr_os_regset regs;
      int thisFileType = kExpressionFile;       // 17/03/91   fFileType;

      // file icon sprite
      theControl = TControl(aDialogView->FindSubView(I_('d', 'I', 'c', 'n')));
      // fileicon(theControl->fWMgrWindow, theControl->fIconNum, thisFileType);
      theControl->DrawFileIcon(thisFileType);

      if (fVersion >= 5)
      {
        TStatistics stats;

        GetStatistics(&stats, TRUE);

        // word count
        if (stats.fWords >= 0)
        {
          sprintf(tempBuf, GetString(stats.fWords == 1 ? 10 : 11), stats.fWords);
          aDialogView->WriteText(I_('d', 'W', 'd', 'c'), tempBuf);
        }

        // text count
        if (stats.fCharacters >= 0)
        {
          sprintf(tempBuf, GetString(stats.fCharacters == 1 ? 12 : 13), stats.fCharacters);
          aDialogView->WriteText(I_('d', 'C', 'h', 'c'), tempBuf);
        }
      }

      // file size
      docSize = 0;
      DoNeedDiskSpace(docSize);
      regs.r[0] = int(docSize);
      regs.r[1] = int(tempBuf);
      regs.r[2] = 30;   // buffer length
      wr_wimpt_noerr(wr_os_swix(/* XOS_Bit | */ OS_ConvertFileSize, &regs));
      aDialogView->WriteText(I_('d', 'S', 'i', 'z'), tempBuf);

      aDialogView->WriteTruncText(I_('d', 'N', 'a', 'm'), fTitle, dotLeft);

      aDialogView->WriteText(I_('d', 'M', 'o', 'd'), GetIndString(2, (fChangeCount != 0)));

      // file date
      regs.r[0] = int(fModDate);
      regs.r[1] = int(tempBuf);
      regs.r[2] = 30;   // buffer length
      wr_wimpt_noerr(wr_os_swix(/* XOS_Bit | */ OS_ConvertStandardDateAndTime, &regs));
      aDialogView->WriteText(I_('d', 'D', 'a', 't'), tempBuf);

      // file type
      regs.r[0] = 18;
      regs.r[2] = thisFileType;
      wr_wimpt_noerr(wr_os_swix(/* XOS_Bit | */ OS_FSControl, &regs));
      sprintf(tempBuf, "%.8s(%x)", (char *)&regs.r[2], thisFileType);
      aDialogView->WriteText(I_('d', 'T', 'y', 'p'), tempBuf);
   }
   else if (IsFileCommand(cmdNumber))
   {
      char* msgname;
      AppFile cInfo;
      TFileIcon fileIcon;
      TControl selBox;

      // Construct a name to put in the save dialogue
      if (cmdNumber == cSave && fSaveExists && !fSaveSelection)
         msgname = fTitle;    // use real document name
#ifdef TABLES
      else if (cmdNumber == cSaveStationery && fStationery)
            // 19/06/92 extra tests for perm file && not a text/CSV/etc file
         msgname = fStationeryName;    // 28/04/92 put in stationery name if from pad
#endif
      else
         msgname = GetRsrc(cmdNumber - (fSaveSelection ? cSave - 10 : cSave), 'f');
                                                    // 31/05/96 name dependant on cmd

      aDialogView->WriteText(gIdfnam, msgname);
      cInfo.fType = GetSaveInfo(cmdNumber, msgname, cInfo);
      if ((fileIcon = TFileIcon(aDialogView->FindSubView(gIdicon))) != NULL)
         fileIcon->SetUp(this, cInfo.fType, fSaveSelection ?
                           (cmdNumber + (cSaveSelection >> 2) - cSave) * 4 : cmdNumber);

      selBox = aDialogView->WriteCheckBox(gIdsel, fSaveSelection);
      if (selBox != NULL)
      {
         selBox->DimState(fSaveCmd == cSave ? ActiveMainView()->fCursor :  // allow Pix
                                              GetNewSelection()->fCursor, kRedraw);
                               // !CmdEnabled(fSaveCmd + 1), kRedraw);
      }
#ifdef CONT
      if (cmdNumber == cSaveContents)
      {
         aDialogView->WriteCheckBox(I_(0, 0, 'b', '0') + fSaveContentsSet, TRUE); // 21/04/95
         aDialogView->WriteCheckBox(I_('t', 'l', 'e', 'v'), fTabContents);
      }
#endif
   }
   else
      _TTextDocument::WriteToDialog(aDialogView, cmdNumber);  // 17/07/90
}

// ------------------------------------------------------------------------
TCommand _TExpressionDocument::ReadFromDialog(TView aDialogView, CmdNumber cmdNumber,
                                                            IDType icnId)
{
   if (IsFileCommand(cmdNumber))
   {
     // pressed the OK button (and not dragged the icon somewhere)
     TFileIcon fileIcon;

     if ((fileIcon = TFileIcon(aDialogView->FindSubView(gIdicon))) != NULL)
         fileIcon->DoAction(NULL, 0);
     return gNoChanges;
   }
   return _TTextDocument::ReadFromDialog(aDialogView, cmdNumber, icnId);
}

#ifdef SPELL
// --------------------------------------------------------------------
_TSpellCommand::_TSpellCommand(CmdNumber itsCmdNumber, TDocument itsDocument)
                                    : (itsCmdNumber, itsDocument, NULL, NULL)
{
   fCanUndo = FALSE;
}

// --------------------------------------------------------------------
void _TSpellCommand::DoIt(void)
{
   TExpressionDocument doc = TExpressionDocument(fChangedDocument);
   FailInfo fi;

#ifdef TABLES
   if (fCmdNumber != cCorrect)
#endif
   {
      // doc->CommitLastDocCommand();       // 03/09/91 gApplication->CommitLastCommand();
                                     // 26/03/91 moved from in DoSpellCheck
      doc->Purge();    // get as much store as possible
      EnableEscape();       // 04/06/91 escape handling
      CatchFailures(&fi);
      doc->DoSpellCheck(fCmdNumber == cCheckAll);
      Success(&fi);
      DisableEscape();
   }
   doc->fSaveCmd = fCmdNumber;
      // 11/11/94 [23014] so text does not set (and leave set) fTempFlag on cCheckSelection
   if (doc->fSpellChecker->CorrectErrors())
   {
      doc->DoReformat(fCmdNumber == cCheckSelection ? -1 : kReformatChgs, 1);
   }
   else
     fCausesChange = FALSE;  // do not do in ctor as this stops last command being committed
   return;

Rescue:
   {
      // 18/12/90 recover store if DoSpellCheck runs out of it
      bool saveInteractive = doc->fInteractive;

      DisableEscape();
      doc->fInteractive = TRUE;
      doc->EndInteractive();
      doc->fInteractive = saveInteractive;
      FailNewMessage(&fi, (msgCmdErr << 16) | fCmdNumber);
// 07/06/91 done in FNM      ContinueFailure(&fi);
   }
}
#endif

// --------------------------------------------------------------------
TCommand _TExpressionDocument::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
   TDialogView aDialogView;
#if defined INDEX && !defined NETWP
   int menuIdx;
#endif

   if (aCmdNumber == cDocFileInfo
#ifdef TABLES
        || aCmdNumber == cMergeDialog || aCmdNumber == cMergeMenu
#endif
         )  // 10/05/92 & 21/05/92
   {
      THandler rwHandler;

#ifdef TABLES
      if (aCmdNumber == cDocFileInfo)
#endif
      {
         aDialogView = TDialogView(NewTemplateWindow1(kDocInfoDlog));
         rwHandler = this;
      }
#ifdef TABLES
      else
      {
         aDialogView = TDialogView(NewTemplateWindow(kMergeDlg, this));  // 10/05/92
         rwHandler = aDialogView;
      }
#endif
      if (aDialogView != NULL)
      {
         aDialogView->SetReadWriteHandler(rwHandler);
         aDialogView->PoseModally(aCmdNumber);
         aDialogView->Close();
      }
   }
#if defined TABLES && defined SPELL
   else if (aCmdNumber == cInteractive)
     fSpellChecker->Interactive();
#endif
#if TALK == 2
   else if (aCmdNumber == cInteractiveSpeech)  // 15/02/93 [20700]
     fInteractive = !fInteractive;
#endif
#ifdef SPELL
   else if (aCmdNumber == cCheckAll || aCmdNumber == cCheckSelection
#ifdef TABLES
                              || aCmdNumber == cCorrect
#endif
                              )
   {
#ifdef TABLES
      if (aCmdNumber != cCorrect)
         EndInteractive();             // 26/11/90
#endif
     return new _TSpellCommand(aCmdNumber, this);
   }
#endif
#ifdef TABLES
   else if (aCmdNumber == cMergeList)
     ProcessFieldNames();
#endif
#if defined INDEX && !defined NETWP
   else if (aCmdNumber < 0 &&
                 CmdToMenuItem(cRemoveBookmark, menuIdx) == MenuForNegCmd(aCmdNumber))
   {
      TIndexStructure indexStructure;
      int anItem;
      TCurrency homeCurrency = 0;

      CmdToMenuItem(aCmdNumber, anItem);
      indexStructure = GetBookmarkReadOnly();
                // TIndexStructure(fStructureHandlers[kIndexRefStruct]->
                //                            GetRecordObject(fBookmarkRec, kReadOnly));
      for (int i = 1; i <= indexStructure->fSize; i++)
      {
        PIndexRef iref = PIndexRef(indexStructure->At(i));

        if (indexStructure->IsShown(iref))
        {
          homeCurrency = iref->fHomeCurrency;
          anItem--;
          if (anItem <= menuIdx)
            break;
        }
      }
      
      GotoPhrase(this, homeCurrency);
   }
   else if (aCmdNumber == cAddToIndexI ||                      // add to index (no dlog)
            aCmdNumber == cAddBookMenu ||                  // add book parent menu
            aCmdNumber == cRemoveBookmark || aCmdNumber == cAddBookmark)     // delete or add
   {
      TSelection selection = GetNewSelection();
      TCursorNode activeEnd = selection->GetActiveOwner();
      TCursorNode anchor = selection->GetAnchorOwner();
      TCurrency startCurrency = anchor->fCurrency;
      TCurrency homeCurrency = gNullCurrency;
      TStructure structure;
      int updateIdx = 0;
      char userBuffer[256];
      char *key;
      char *qual;

      structure = GetStructureReadOnly(startCurrency);
      key = userBuffer;
      if (aCmdNumber == cAddToIndexI)
      {
        *key = 0;
        structure->GetSelectedText(startCurrency, anchor, activeEnd, key);
        aCmdNumber = cAddToIndex;
        qual = "";
      }
      else
      {
        qual = key;
        if (aCmdNumber == cAddBookMenu)
          aCmdNumber = cAddBookmark;
        CmdToName(aCmdNumber, qual);
        if (aCmdNumber == cAddBookmark)
        {
          aCmdNumber = cAddBookMenu;
          key = "\x01";
        }
        else
        {
          updateIdx = 1;
          homeCurrency = TTextStructure(structure)->GetIndexPhraseAt(startCurrency,
                                          TTextCursor(anchor)->GetCharPos(), updateIdx);
          key = "";
        }
      }
      return new _TIndexCommand(aCmdNumber, this, key, qual, startCurrency,
              updateIdx, homeCurrency, "");
   }
#endif
   else
     return(_TTextDocument::DoMenuCommand(info, aCmdNumber));

   return gNoChanges;
}


// ------------------------------------------------------------------------
void _TExpressionDocument::DoSetupMenus()
{
  fCurrentMenuLanguage = -1;  // 09/11/92 avoid ticks on the 2 dynamic menus
  fCurrentMenuFont = -1;      // ... unless they go through SetTextMenus
#if TALK != 0
  DisableCmd(cSpeakWord);  // 05/04/94 moved from else of Speaking branch so can be
                           // controlled (enabled) from within Application DoSetUpMenus
#endif

#ifdef INDEX
  DisableCmd(cAddToIndexI);
#endif

  _TTextDocument::DoSetupMenus();

#ifdef TeX
  if (!gTeXInstalled)
    DisableCmd(cSaveTeX);
#endif
  EnableCmd(cDocFileInfo);
#ifdef MATHS
  DisableCmd(cMatrix);               // 03/07/93 do not leave enabled when ruler selected
#endif
#if defined TABLES && !defined NETWP
  DisableCmd(cUnderline);    // 17/06/93 this is in Buzzwords so not automatically disabled
  EnableCmd(cMergeDialog);   // 10/05/92
  EnableCmd(cMergeList);     // 12/05/92
  BuildMergeMenu();
#ifdef SPELL
  // menus for spell checking
  Enable(cCorrect, fInteractive && fSpellChecker->fErrors->GetSize() > 0);
  EnableCheck(cInteractive, TRUE, fInteractive);
#endif
#endif
#if TALK == 2
  if (Speaking() >= 0)
  {
    EnableCheck(cInteractiveSpeech, TRUE, fInteractive);  // 15/02/93 [20700]
    EnableCmd(cSpeakWord);
  }
#endif
#if defined PRO && !defined NETWP
  if (gWimpVersion < 300 || wr_os_swi1(PDriver_SelectDriver | wr_os_X, -2) != NULL)
                           // 28/02/94 [21429] ensure printer swi available too
    DisableCmd(cSavePostscript);
#endif
#if defined TABLES || DEMO == 0
  EnableCmd(cCheckAll);
  if (!GetNewSelection()->fCursor)     // !isCursor)
    EnableCmd(cCheckSelection);                            // 14/05/92
#endif
}

#ifdef INDEX
// ------------------------------------------------------------------------
bool _TExpressionDocument::SetupDynamicMenu(CmdNumber aCmdNumber, int menuNum, bool create)
{
  return _TTextDocument::SetupDynamicMenu(aCmdNumber, menuNum, create);
}
#endif

// ------------------------------------------------------------------------
bool _TExpressionDocument::CanPaste(int fileType)
{
// 08/05/90 To decide whether or not we can handle files dropped on window

  return ((fileType == kDrawFile ||
           fileType == kTextFile ||      // 11/07/90 - added text import
#ifdef WORD7
           fileType == kMSWord ||
#endif
#ifndef NETWP
           fileType == kFirstWordFile || //08/10/90 - first word plus import
#endif
           fileType == kCSV ||           // 13/06/91
           fileType == kSpriteFile ||    // 24/05/90 - added sprite import
           fileType == kJPEGFile ||    // 24/05/90 - added sprite import
#ifdef FILMS
           fileType == kFilm ||
           fileType == kACE ||
#endif
           fileType == kExpressionFile ||
           fileType == kStationeryPad) ?
                      !GetNewSelection()->fEndStructure :  // 05/02/92 was TRUE
                                          _TDocument::CanPaste(fileType));
}

#ifdef SPELL
// ------------------------------------------------------------------------
void _TExpressionDocument::BeginSpell(int language)
{
  fSpellChecker->BeginSpell(language);
}


// ------------------------------------------------------------------------
void _TExpressionDocument::Spell(TCurrency currency, TCharPos charPos,
                                           Ptr token, int tokenLen)
{
  fSpellChecker->Spell(currency, charPos, token, tokenLen);
}

// ------------------------------------------------------------------------
void _TExpressionDocument::Hyphenate(int language, char *first, char *last)
{
  fSpellChecker->Hyphenate(language, first, last);
}

// ------------------------------------------------------------------------
bool _TExpressionDocument::InsertChar(int ch, TCursorNode cursor)
{
  return fSpellChecker->InsertChar(ch, cursor);
}

// ------------------------------------------------------------------------
void _TExpressionDocument::EndInteractive()
{
  fSpellChecker->Commit();
}
#endif

// ------------------------------------------------------------------------
_TExpressionView::_TExpressionView(TDocument itsDocument, TView itsSuperView,
             char * &params) : (itsDocument, itsSuperView, params)
{
  TTextFormat protoText;
  TBodyFormat protoBody;
  TBodyStyle protoBodyStyle;
//  TFigureFormat protoFigure;
  TStyleFormat protoTextStyle;
  TPictStyle protoPictStyle;
  TPictFormat protoPict;
#ifdef MATHS
  TMathFormat protoMaths;
#endif
  TMathStyle protoMathStyle;
  int strOffset;
#ifdef TABLES
  TTableFormat protoTable;
#else
  TFormat protoTable;
#endif
  TColumnStyleFormat protoColumnStyle;

  protoText = new _TTextFormat(this);
  NewFormatHandler(protoText, kTextStruct, itsDocument, 1);       // fn1

  protoPict = new _TPictFormat(this);                             // 03/05/90
  NewFormatHandler(protoPict, kPictStruct, itsDocument, 1);       // 03/05/90

  protoBody = new _TBodyFormat(this);
  NewFormatHandler(protoBody, kBodyStruct, itsDocument, 2);       // fn1

#ifdef TABLES
  protoTable = new _TTableFormat(this);
  NewFormatHandler(protoTable, kTableStruct, itsDocument, 2);
                       // fn1
                       // 25/03/91 v2 corrects problem with array part
#else
  protoTable = new _TFormat(this, sizeof(TTableFormatData));
  NewFormatHandler(protoTable, kTableStruct, itsDocument, 1);
#endif
#ifdef MATHS
  protoMaths = new _TMathFormat(this);                             // 13/01/91
  NewFormatHandler(protoMaths, kMathStruct, itsDocument, 2);  // v2 27/03/92
//#else
//  NewFormatHandler(NULL, kMathStruct, itsDocument, 2); // 04/08/92 repair converted V5 docs
#endif

  protoTextStyle = new _TStyleFormat();
  NewFormatHandler(protoTextStyle, kTextStyleStruct, itsDocument, 1);

  protoPictStyle = new _TPictStyle();                             // 03/05/90
  NewFormatHandler(protoPictStyle, kPictStyleStruct, itsDocument, 1);

  protoBodyStyle = new _TBodyStyle();
  NewFormatHandler(protoBodyStyle, kBodyStyleStruct, itsDocument, 1);
                                                        // v2 31/01/92; v1 again 26/03/92
  protoColumnStyle = new _TColumnStyleFormat();
  NewFormatHandler(protoColumnStyle, kColumnsStyleStruct, itsDocument, 2);
                       // 25/03/91 v2 corrects problem with array part

  // 26/08/92 install a handler so math styles always copied in EW and SW
  protoMathStyle = new _TMathStyle();                             // 13/01/91
  NewFormatHandler(protoMathStyle, kMathStyleStruct, itsDocument, 1);

  TTextDocument(itsDocument)->AddMainView(this);

  // copy default params to fWindowPars: they will be replaced by disc read
  sscanf(params, " %d %d %d %d %d %d %d %d %n ", &fWindowPars.zoomNum,
    &fWindowPars.zoomDenom, &fWindowPars.zoomFit,
    &fWindowPars.hTranslation, &fWindowPars.vTranslation,
    &fWindowPars.rulerShown, &fWindowPars.scalesShown,
    &fWindowPars.greekPalShown, &strOffset);
  fWindowPars.hScale = fWindowPars.vScale = gUnits;
  fWindowPars.hCustomPoints = fWindowPars.vCustomPoints = gCustomPoints;
  fWindowPars.hOrigin = fWindowPars.vOrigin = 0;
  OffsetPtr(params, strOffset);
  fRuleType = gDefaultPen;
  // fRuleType.fPen = kOnePtPen;            // 31/01/91
  // fRuleType.fRule = k1Thn;
  // fRuleType.fShort = FALSE; // 21/07/92 adding this gives better code!
}

// ------------------------------------------------------------------------
void _TExpressionView::NewFormatHandler(TDiscObject protoType,
               TStructTypes structType, TDocument itsDocument, int version)
{
  TRecordHandler recHandler = NULL;
  TRecordHandler master;
  FailInfo fi;

  CatchFailures(&fi);
  master = TTextDocument(itsDocument)->fStructureHandlers[structType];
  recHandler = new _TRecordHandler(itsDocument, master, protoType, version);
  recHandler->InitIndex();
  Success(&fi);
  AddFormatHandler(structType, recHandler);
  return;

Rescue:
  FreeIfObject(protoType);
  FreeIfObject(recHandler);
  ContinueFailure(&fi);
}


/* ------------------------------------------------------------------------
 * Since the window has not (normally) been created at the point where
 * the document is read (and in the case of desktop printing will never be
 * created), the expression view reads the saved info on behalf of the
 * window, and passes it on when the window is connected. The following
 * three methods support reading, writing and sizing of these parameters.
 */

// ------------------------------------------------------------------------
void _TExpressionView::DoReadData(int aRefNum, long &position)
{
  long count = sizeof(TScaledWindowTemplate);

  SetFPos(aRefNum, position);
  FRead(aRefNum, count, &fWindowPars); 
  position += sizeof(TScaledWindowTemplate);
  _TPagesView::DoReadData(aRefNum, position);
//  AttachPrintHandler(fPrintHandler);
                          // on Mac, done inside IPagesPrintHandler
}


// ------------------------------------------------------------------------
void _TExpressionView::DoWriteIndex(int aRefNum, long &position)
{
  long count = 4;
  int myType = 1;   // the value saved on disc to recreate a TExpressionView
  TWindow myWindow;

  myWindow = GetWindow();
  if (myWindow != NULL)
    TScaledWindow(myWindow)->WriteRes(&fWindowPars);  // get current values

  SetFPos(aRefNum, position);          // needed?

  FWrite(aRefNum, count, &myType);

  count = sizeof(TScaledWindowTemplate);
  FWrite(aRefNum, count, &fWindowPars);
  position += sizeof(TScaledWindowTemplate) + 4;
  _TPagesView::DoWriteIndex(aRefNum, position);
}


// ------------------------------------------------------------------------
void _TExpressionView::DoNeedDiskSpace(long &dataForkBytes)
{
  dataForkBytes += sizeof(TScaledWindowTemplate) + 4;
  _TPagesView::DoNeedDiskSpace(dataForkBytes);
}

// ------------------------------------------------------------------------
void _TExpressionView::ConnectToWindow(TDocument doc, TScaledWindow aWindow)
{
  if (aWindow == NULL)
  {
    // there is no current window for the view, so make one.
    aWindow = TScaledWindow(NewTemplateWindow(kMainWindow, doc));
    aWindow->fTargetID = fIdentifier;           // see note below
  }

  aWindow->ConnectMainView(this, &fWindowPars); // pass initialisation params
  gApplication->SetWindowForMenus(aWindow);     // 21/05/91 for DoSetUpMenus
  gApplication->SetupTheMenus();                // 21/05/91
}


/* ------------------------------------------------------------------------
 * Note: Reverting is different to and more advanced than Mac, and provides
 * a basis for supporting multiple views in a single document. Instead of
 * using fPagesWindow (which won't work with multiple views/windows), when
 * a window is created for a view, the window's fTargetID field is set to
 * the identifier of the view. If the window is closed, then a revert done,
 * a view will be recreated from the saved file. [This must have the same
 * unique identifier each time it is created by document::DoRead]. The view
 * can then scan through all the windows in ShowReverted to find the one it
 * should be connected to. If none is found, the window has been deleted
 * since the original load, so a fresh window needs to be created.
 * Of course, extra windows may have been created since the original load.
 * These should be deleted (this is not yet done) after the Revert.
 */

// ------------------------------------------------------------------------
static void CheckID(TDocument null, TWindow aWindow, IDType id, TWindow *aMatch)
{
   if (aWindow->fTargetID == id)
     *aMatch = aWindow;
}

// ------------------------------------------------------------------------
void _TExpressionView::ShowReverted()
{
// this is called after a Revert. For multi-view documents, it is possible
// for the user to have closed the window for this view since the document
// was saved. In that case, the view will have no superviews.

  if (fSuperView == NULL)  // if it has a superview it is already connected
  {
    TScaledWindow aMatch = NULL;

    fDocument->fWindowList->Each(NULL, (DoToObject)CheckID, fIdentifier, &aMatch);
    ConnectToWindow(fDocument, TScaledWindow(aMatch));
  }

  _TPagesView::ShowReverted();
}

// ------------------------------------------------------------------------
_TScrollCommand::_TScrollCommand(TView theView) : (cNoCommand, NULL, theView, NULL)
{
  // 30/07/96 [27037] mouse controlled scrolling command
  fTrackNonMovement = FALSE;
}

// ------------------------------------------------------------------------
TCommand _TScrollCommand::TrackMouse(TrackPhase aTrackPhase,
                                    VPoint &anchorPoint,
                                    VPoint &previousPoint,
                                    VPoint &nextPoint, bool mouseDidMove,
                                    EventInfo &info)
{
  // 30/07/96 [27037] mouse controlled scrolling command
  if (aTrackPhase == trackPress)
  {
    fPrevPoint = anchorPoint;
    return gNoChanges;
  }
  else if (aTrackPhase == trackRelease)
  {
    InitCursor();
    return gNoChanges;
  }
  if (mouseDidMove)
  {
    TScroller trackScroller = fView->GetScroller(TRUE);
    Point translations;
    Point delta;

    SetCursor(GetCursor(kHandCursor));
    if (fView->Focus())
    {
      VPoint mouseInScroller = nextPoint;

      fView->LocalToWindow(mouseInScroller);
      trackScroller->WindowToLocal(mouseInScroller);
      trackScroller->AutoScroll(mouseInScroller, delta);
    }
    else
      delta.h = delta.v = 0;
    
    trackScroller->GetTranslations(translations);
    trackScroller->ScrollBy(fPrevPoint.h - nextPoint.h - delta.h,
                                  fPrevPoint.v - nextPoint.v - delta.v);
    trackScroller->Translate(translations);
    fPrevPoint.h = nextPoint.h + translations.h;
    fPrevPoint.v = nextPoint.v + translations.v;
  }
  return this;
}

// ------------------------------------------------------------------------
void _TScrollCommand::TrackFeedback(VPoint &anchorPoint, VPoint &nextPoint,
                 bool turnItOn, bool mouseDidMove)
{
}

// ------------------------------------------------------------------------
TCommand _TExpressionView::DoMouseCommand(Point &theMouse, EventInfo &info)
{
  // 30/07/96 [27037] mouse controlled scrolling command
  if (info.theClickCount)              // 03/10/96 not if drag and drop
    return new _TScrollCommand(this);
  return _TPagesView::DoMouseCommand(theMouse, info);
}

// ------------------------------------------------------------------------
bool _TExpressionView::HandleMouseDown(VPoint &theMouse, EventInfo &info,
                                              TCommand &theCommand)
{
#ifdef DRAGDROP
  if (info.theClickCount > 0)  // 23/03/93 ignore dragdrop tracking
  {
#endif
#if defined TABLES || defined DRAWSAVE
    Point qdPoint;

    if (fDoBoxZoom && Focus() &&
                       (ViewToQDPt(theMouse, qdPoint), InPage(qdPoint)))
    {
#ifdef DRAWSAVE
      if (fDoBoxZoom == drawCursor)
        theCommand =  new _TSaveDrawTracker(this);
      else
#endif
      {
#ifdef TABLES
        theCommand = new _TZoomTracker(this);
#endif
      }
      return TRUE;
    }
#endif
#ifdef DRAGDROP
  }
#endif
  return _TPagesView::HandleMouseDown(theMouse, info, theCommand);
}

#ifdef TABLES
static IDType gMrgIds[2] = {I_('f', 'i', 'l', 'n'), I_('h', 'e', 'a', 'd')};
// ------------------------------------------------------------------------
// 10/05/92 new object
_TMergeDialog::_TMergeDialog(TDocument itsDoc, TView itsSuperV, char* &itsParams) :
         (NULL, itsSuperV, itsParams)
{
  fDoc = TExpressionDocument(itsDoc);
#ifndef ZERO_OBJ
  fCheckBox = NULL;
  fTextBox = NULL;
  fMergeDoc = NULL;
  fTableCurr = 0;
#endif
}


// ------------------------------------------------------------------------
void _TMergeDialog::Free()
{
  FreeIfObject(fMergeDoc);  // file created, but OK not pressed
  _TDialogView::Free();
}


// ------------------------------------------------------------------------
void _TMergeDialog::WriteToDialog(TView aDialogView, CmdNumber aCmd)
{
  fTextBox = WriteText(gMrgIds[0], fDoc->fMergeFileName ? fDoc->fMergeFileName : "");
  fCheckBox = WriteCheckBox(gMrgIds[1], fDoc->fHeadings);
}

// ------------------------------------------------------------------------
void _TMergeDialog::ReadTheFile()
{
  TCurrency tabCurr;
  TTextDocument aDocument;

  if (fAppFile.fName != NULL && fAppFile.fName[0] == 0)  // 07/07/92 NULL test
  {
    tabCurr = 0;
    aDocument = NULL;          // remove doc
  }
  else
    aDocument = fDoc->DoLoadMergeDocument(fAppFile, &tabCurr, fCheckBox->IsOn());

  if (aDocument != fMergeDoc)
  {
    fTableCurr = tabCurr;
    ReplaceObject(fMergeDoc, aDocument);
    // FreeIfObject(fMergeDoc);
    // fMergeDoc = aDocument;
  }
}

// ------------------------------------------------------------------------
TCommand _TMergeDialog::ReadFromDialog(TView aDialogView, CmdNumber aCmd, IDType choice)
{
  Str255 newTitle;
  char *titlePtr = NULL;

  if (fTextBox)
  {
    fTextBox->GetText(newTitle);
    if (strcmp(newTitle, GetString(kUntitledFile)) != 0)  // it is not temporary
    {
      if (newTitle[0] != 0)
        titlePtr = newTitle;
      if (strcmp(newTitle, fDoc->fMergeFileName == NULL ? "" : fDoc->fMergeFileName) != 0)
      {
        // the value of the field is permanent and different
        fAppFile.fName = newTitle;
        ReadTheFile();
      }
    }
  }

  // successfully got here and OK pressed, so can now update document fields
  if (fCheckBox)
    fDoc->fHeadings = fCheckBox->IsOn();
  if (fDoc->fMergeDoc != fMergeDoc)
  {
    fDoc->fMergeData = fTableCurr;
    ReplaceObject(fDoc->fMergeDoc, fMergeDoc);
  }
  DisposIfHandle(fDoc->fMergeFileName);
  fDoc->fMergeFileName = NewString(titlePtr);
  fMergeDoc = NULL;
  if (fDoc->fMergeDoc)
    fDoc->GenerateFieldNames();
  fDoc->UpdateChangeCount(1);
  return gNoChanges;
}


// ------------------------------------------------------------------------
TCommand _TMergeDialog::DoLoadFile(AppFile &appFile, TObject pasteSel, bool shift)
{
  char *filename = appFile.fName;
  // 09/07/95 [26034] done by caller: fileIsSafe = filename != NULL && xferrecv_file_is_safe();

#ifdef TRACE
  Assert(pasteSel == NULL, 528);
#endif
  // 09/07/95 [26034] done by caller:  appFile.fFileIsSafe = fileIsSafe;
  gApplication->CanReadDocument(appFile, kNotOurFileType);
  // if (!gApplication->CanReadDocument(appFile)) //, fileIsSafe))
  //    FailGeneral(kNotOurFileType);

  fAppFile = appFile;
  if (!appFile.fFileIsSafe)       // file may not stay around, so read now
  {
    filename = GetString(kUntitledFile);
    ReadTheFile();
    TExpressionDocument(fMergeDoc)->fUnsafeMergeFile = TRUE;   // 07/07/92
  }
  // 09/07/95 [26034] done by caller:
  //  if (appFile.fName != NULL)
  //    xferrecv_insertfileok();              // an insert should be acknowleged
  fTextBox->SetText(filename, kRedraw);

  return gNoChanges;
}
#endif

// -----------------------------------------------------------------------
int _TStructure::SendAlienData(TCurrency currency, PAlienSaveItems saveInfo, void *state)
{
#ifdef TeX
  if (saveInfo->sender->GetFileType() == gTeXfile)
    return SendStructTeXData(currency, PTexSaveItems(saveInfo), state);
#endif
#ifdef WORD7
  if (saveInfo->sender->GetFileType() == kMSWord)
    return SendStructWordData(currency, PWordSaveItems(saveInfo), state);
#endif
  return 0;
}

// -----------------------------------------------------------------------
int _TTextStructure::SendAlienData(TCurrency currency, PAlienSaveItems saveInfo, void *state)
{
#ifdef TeX
  if (saveInfo->sender->GetFileType() == gTeXfile)
    return SendTextTeXData(currency, PTexSaveItems(saveInfo), state);
#endif
#ifdef WORD7
  if (saveInfo->sender->GetFileType() == kMSWord)
    return SendTextWordData(currency, PWordSaveItems(saveInfo), state);
#endif
  return _TStructure::SendAlienData(currency, saveInfo, state);
}

#ifdef MATHS
// -----------------------------------------------------------------------
int _TMathStructure::SendAlienData(TCurrency currency, PAlienSaveItems saveInfo, void *state)
{
#ifdef TeX
  if (saveInfo->sender->GetFileType() == gTeXfile)
    return SendMathTeXData(currency, PTexSaveItems(saveInfo), state);
#endif
#ifdef WORD7
  if (saveInfo->sender->GetFileType() == kMSWord)
    return SendMathWordData(currency, PWordSaveItems(saveInfo), state);
#endif
  return _TStructure::SendAlienData(currency, saveInfo, state);
}
#endif

// -----------------------------------------------------------------------
int _TBodyStructure::SendAlienData(TCurrency currency, PAlienSaveItems saveInfo, void *state)
{
#ifdef TeX
  if (saveInfo->sender->GetFileType() == gTeXfile)
    return SendBodyTeXData(currency, PTexSaveItems(saveInfo), state);
#endif
#ifdef WORD7
  if (saveInfo->sender->GetFileType() == kMSWord)
    return SendBodyWordData(currency, PWordSaveItems(saveInfo), state);
#endif
  return _TStructure::SendAlienData(currency, saveInfo, state);
}

// -----------------------------------------------------------------------
int _TColumnStructure::SendAlienData(TCurrency currency, PAlienSaveItems saveInfo, void *state)
{
#ifdef TeX
  if (saveInfo->sender->GetFileType() == gTeXfile)
    return SendColTeXData(currency, PTexSaveItems(saveInfo), state);
#endif
#ifdef WORD7
  if (saveInfo->sender->GetFileType() == kMSWord)
    return SendColWordData(currency, PWordSaveItems(saveInfo), state);
#endif
  return _TStructure::SendAlienData(currency, saveInfo, state);
}

// -----------------------------------------------------------------------
int _TPictStructure::SendAlienData(TCurrency currency, PAlienSaveItems saveInfo, void *state)
{
#ifdef TeX
  if (saveInfo->sender->GetFileType() == gTeXfile)
    return SendPictTeXData(currency, PTexSaveItems(saveInfo), state);
#endif
#ifdef WORD7
  if (saveInfo->sender->GetFileType() == kMSWord)
    return SendPictWordData(currency, PWordSaveItems(saveInfo), state);
#endif
  return _TStructure::SendAlienData(currency, saveInfo, state);
}

