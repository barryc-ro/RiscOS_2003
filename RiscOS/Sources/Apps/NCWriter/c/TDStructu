/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdlib.h>
#include <stdarg.h>

#include "os.h"
#include "font.h"
#include "xfersend.h"
#include "event.h"

#include "UTextDoc.h"

int gFormatting = 0;  // 24/07/90 moved from BodyEdit 16/06/91
static TCurrency gPasteEndCurr;
static long gPasteEndPosn;
#ifdef DRAGDROP
static TCurrency gPastedObj;
#endif
#ifdef TABLES
bool gSelNewStructs = FALSE;
#endif

void SetPastePosition(TCurrency curr, long posn)
// 10/09/92 new to avoid more parameters on IteratePart (IterateForPaste)
{
  gPasteEndCurr = curr;
  gPasteEndPosn = posn;
#ifdef DRAGDROP
  if (gPastedObj == 0)
    gPastedObj = curr;
#endif
}

#ifdef FN
// 11/05/93 [20864] new procs to save paste position corrupted by pasting footnotes
void SavePastePosition(TPasteSaveArea *saveArea)
{
  saveArea->pasteEndCurr = gPasteEndCurr;
  saveArea->pasteEndPosn = gPasteEndPosn;
#ifdef DRAGDROP
  saveArea->pastedObj = gPastedObj;
#endif
}

void RestorePastePosition(TPasteSaveArea *saveArea)
{
  gPasteEndCurr = saveArea->pasteEndCurr;
  gPasteEndPosn = saveArea->pasteEndPosn;
#ifdef DRAGDROP
  gPastedObj = saveArea->pastedObj;
#endif
}
#endif

// 2/4/92 methods for new class TStyleSet
// ------------------------------------------------------------------------
_TStyleSet::_TStyleSet(TStyleFormat style): (sizeof(TCurrency))
{
  fStyle = style;       // 09/02/93 [20620] new field and initialiser
}


// ------------------------------------------------------------------------
int _TStyleSet::Compare(Ptr item1, Ptr item2)
{
  return *PCurrency(item1) - *PCurrency(item2);
/*
  if (*((long *)item1) < *((long *)item2))
    return kALessThanB;
  if (*((long *)item1) > *((long *)item2))
    return kAGreaterThanB;
  return kAEqualB;
*/
}

// ------------------------------------------------------------------------
bool _TStyleSet::ContainsStyle(TCurrency aStyle)
{
  if (Search(&aStyle) == 0)
  {
    Insert(&aStyle);
    return FALSE;
  }
  return TRUE;
}


// ------------------------------------------------------------------------
void _TCommonStructure::IStructure(TCurrency itsParent, TCurrency itsStyle)
{
  fParent = itsParent;
  fStyle = itsStyle;
}


// ------------------------------------------------------------------------
_TCommonStructure::_TCommonStructure(TDocument itsDocument, int itsItemSize)
                                                         : (itsItemSize)
{
  fDocument = TTextDocument(itsDocument);
#ifndef ZERO_OBJ
  fParent = gNullCurrency;
  fStyle = gNullCurrency;
  fUndoStyle = gNullCurrency;
  fChanges = gNullCurrency;
  fUndoChanges = gNullCurrency;
#endif
}


// ------------------------------------------------------------------------
TStructure _TStructure::GetStructureReadWrite(TCurrency currency)
{
  return fDocument->GetStructureReadWrite(currency);
}


// ------------------------------------------------------------------------
TStructure _TStructure::GetStructureReadOnly(TCurrency currency)
{
  return fDocument->GetStructureReadOnly(currency);
}


#define kStructSpaceReq 9
// ------------------------------------------------------------------------
long _TCommonStructure::DoNeedDiskSpace(long dataForkBytes)
{
  return _TArray::DoNeedDiskSpace(dataForkBytes + kStructSpaceReq -
                              int(sizeof(_TStructure)) + int(sizeof(_TArray)));
}

// ------------------------------------------------------------------------
void _TCommonStructure::DoRead(int aRefNum, long remainder, int version)
{
  char buffer[kStructSpaceReq];

#ifdef VERS0
  if (version == 0)
  {
    TTextDocument myDoc = fDocument;

    _TArray::DoRead(aRefNum, remainder, version);  // the inherited read

    fDocument = myDoc;
  }
  else
#endif
  {
    _TArray::DoRead(aRefNum, sizeof(_TArray), version);  // the inherited read

    FRead(aRefNum, kStructSpaceReq, buffer);
    UnpackRecord(0x555, "\x01\x01\x02\x04\x01\x01\x02\x04\x01\x01\x02",
                                                 buffer, NULL, &fStyle);
    FRead(aRefNum, remainder - sizeof(_TStructure), this + 1);
  }
}

// ------------------------------------------------------------------------
void _TCommonStructure::DoWrite(int aRefNum, long remainder)
{
  char buffer[kStructSpaceReq];

  fDocument->SetUsedStyles(fStyle);
  fDocument->SetUsedStyles(fChanges);

  _TArray::DoWrite(aRefNum, sizeof(_TArray));              // write count

  PackRecord(0x555, "\x01\x01\x02\x04\x01\x01\x02\x04\x01\x01\x02",
                                                     &fStyle, buffer);
  FWrite(aRefNum, kStructSpaceReq, buffer);                // write own data
  FWrite(aRefNum, remainder - sizeof(_TStructure), this + 1);
                                                 // write any following data
}

// ------------------------------------------------------------------------
void _TCommonStructure::AboutToRewrite(void *buffer, int buffLen)
{
  struct {
  TCurrency fStyle;
  TCurrency fUndoStyle;
  TCurrency fChanges;
  TCurrency fUndoChanges;
  TCurrency fParent;
  } mySavedData;

  mySavedData.fStyle = 0;
  mySavedData.fChanges = 0;
  UnpackRecord(0x555, "\x01\x01\x02\x04\x01\x01\x02\x04\x01\x01\x02",
             (char *)buffer + _TArray::DoNeedDiskSpace(sizeof(_TArray) -
             fSize * fItemSize), NULL, &mySavedData);

  fDocument->SetUsedStyles(mySavedData.fStyle);
  fDocument->SetUsedStyles(mySavedData.fChanges);
}


// ------------------------------------------------------------------------
void _TStructure::InsertLevelInfo(TSelection selection, TLevelInfo &levelInfo, int part,
                        Rect &custom, int level, int currTarget)
// 11/01/92 new, overridden in Maths
{
  int i;
  int pos;
  int resId = kSelectStrings + levelInfo.fKind;

  pos = selection->GetSize() + 1; // 01/05/90 - new from mac vsn
  for (i = 2; GetIndString(resId, i) != NULL; i++)
  {
    int kind = GetKind(); // 22/6/92
    if (part == 0 || i == 2 || i == abs(part) + 1
#ifdef TABLES
          || ((kind == kColumns || kind == kMatrix) && i <= abs(part))
#endif
                                                    ) // 22/6/92, 29/06/92
    {
      levelInfo.fPart = i - 1;
      levelInfo.fMsgNum = levelInfo.fPart;   // 24/03/92
      levelInfo.fCustom = custom;
      selection->InsertBefore(pos, &levelInfo); // 01/05/90 - prev. InsertFirst
    }
  }
  // 08/02/91 new clause
  if (part >= 0 && (level == selection->fTarget || level == currTarget))
  {
    levelInfo.fPart = Min(-1, -part);        // 23/05/91 Min
    levelInfo.fMsgNum = levelInfo.fPart;   // 24/03/92
    selection->InsertBefore(pos, &levelInfo);
  // 28/01/92 fPopup set up after BuildLevel:    selection->fPopup++;
  }
}

#if defined MATHS || defined INDEX
// ------------------------------------------------------------------------
// 11/01/92 new
void _TStructure::DoSetupMenus(TCurrency currency, TCursorNode anchor, TCursorNode activeEnd)
{
  TStructure parentStruct;
  TCursorNode previous;

  previous = anchor->GetPrevious();
  if (previous != NULL && fParent != 0)      // 08/12/92 && click in endnotes
  {
    parentStruct = GetStructureReadOnly(fParent);
    parentStruct->DoSetupMenus(fParent, previous, activeEnd->GetPrevious());
  }
}
#endif


// ------------------------------------------------------------------------
bool _TStructure::IsInLine(void)
{
  // 16/11/93 [21123] need to test fParent as documents now call this in PreFormat
  return fParent != 0 && Curr_fType(fParent) < kBodyStruct;
}

// ------------------------------------------------------------------------
// 05/03/91 new method
TCurrency _TStructure::GetEnd(TCurrency currency, bool start)
{
  return currency;
}

// ------------------------------------------------------------------------
int _TStructure::TextFont(PFontStyle fontStyle)
{
  return fDocument->SetCurrentFont(fontStyle);
}


// ------------------------------------------------------------------------
void _TStructure::DoSearchIteration(TCurrency currency, long pos,
               TCursorNode anchor, TCursorNode activeEnd, char* findText,
               TSelection hitSelection, bool wholeWord, bool caseSensitive,
               bool searchBackwards, bool changeAll)
{
  TStructure structToSearch;
  TCursorNode newStart;

  structToSearch = GetStructureReadOnly(currency);
  // newStart = NULL;
  newStart = (searchBackwards ? activeEnd : anchor);

  if (structToSearch->DoSearch(currency, newStart, hitSelection, findText,
                      wholeWord, caseSensitive, searchBackwards, changeAll))
    FailNoFail();
}


// ------------------------------------------------------------------------
bool _TStructure::DoSearch(TCurrency currency, TCursorNode startPoint,
                    TSelection hitSelection, char* findText,
                    bool wholeWord, bool caseSensitive,
                    bool searchBackwards, bool changeAll)
{
  volatile TSelection selection = NULL;
  bool found = FALSE;
  TCursorNode first = NULL;
  TCursorNode last = NULL;
  TCurrency docCurr = fDocument->fBody;
  FailInfo fi;

  if (MemSpaceIsLow())
    fDocument->Purge();            // 04/04/91
  CatchFailures(&fi);

  // 04/01/95 [23023] following to cycle at end/start of document
  if (searchBackwards)
    last = startPoint;
  else
    first = startPoint;

  for (;;)
  {
    TCursorNode temp;

    Iterate(currency, first, last, searchBackwards ^ TRUE, this,
            DoStep(_TStructure::DoSearchIteration), findText, hitSelection,
            wholeWord, caseSensitive, searchBackwards, changeAll);

    // 02/05/95 [25012] do not do an alert if replace all
    if (currency != docCurr || changeAll || Alert(phFindFromStart + searchBackwards,
          wr_wimp_EOK | wr_wimp_ECANCEL | 16, gErrorParm3 /* findText [26009] 01/06/95 */) != kYesButton)
      break;
    docCurr = gNullCurrency;
    // swap first and last for start from begining
    temp = last;
    last = first;
    first = temp;
  }
  // if we get here, no match found
#ifdef FN
  if (GetKind() == kFootnote && startPoint != NULL)
                          // 26/09/94 [22029] cursor started in note, reset to reference
  {
    TMainView mainView = fDocument->ActiveMainView();
    TStructure structure;
    TCurrency noteRef = GetNoteReference();
    bool saveCur = mainView->fCursor;

    selection = new _TSelection(fDocument);
    selection->InitialCursor(mainView, noteRef, searchBackwards ? -currency : currency);

    mainView->SetTheCursor(saveCur);   // reset after set to TRUE by InitCur
    mainView->ClearViewSlave();  // ??

    structure = GetStructureReadOnly(fDocument->fBody);
    found = structure->DoSearch(fDocument->fBody, selection->GetAnchorRoot(), hitSelection,
         findText, wholeWord, caseSensitive, searchBackwards, changeAll);
    FreeIfObject(selection);
  }
#endif
  Success(&fi);
  return found;
// +++++++++++++++++
Rescue:
  FreeIfObject(selection);
//  if (fi.error != 0 || fi.message != 0)
//    ContinueFailure(&fi);
  ContinueIfFail(&fi);
  return TRUE;
}


// ------------------------------------------------------------------------
void _TStructure::CountItems(TCurrency currency, long pos,
     TCursorNode anchor, TCursorNode activeEnd, long *numItems, bool format)
{
  (*numItems)++;
  if (Curr_fType(currency) > kMathStruct)         // 08/07/92
//  if (currency.cgf_31.fType != kTextStruct &&
//                                    currency.cgf_31.fType != kPictStruct)
    (*numItems) += GetStructureReadOnly(currency)->
                    CountSelectedItems(currency, anchor, activeEnd, format);
}


// ------------------------------------------------------------------------
long _TStructure::CountSelectedItems(TCurrency currency,
                     TCursorNode anchor, TCursorNode activeEnd, bool format)
// 07/09/90 new (with CountItems)
{
  long numItems = 0;

  gFormatting += format;       // 20/04/91 keep count in sync with Reformat
  Iterate(currency, anchor, activeEnd, TRUE, this,
                  (DoStep)_TStructure::CountItems, &numItems, format);
  gFormatting -= format;              // 20/04/91
  return numItems;
}


#ifdef DRAGDROP
// ------------------------------------------------------------------------
bool _TStructure::WithinSelection(TCursorNode anchor, TCursorNode activeEnd, TCursorNode node)
{
#ifdef EXPERIMENT
  TCursorNode anchorNext = anchor->GetNext();
  TCursorNode activeNext = activeEnd->GetNext();
  TCursorNode nodeNext = node->GetNext();

  if (anchorNext != NULL || activeNext != NULL)
  {
    if (nodeNext != NULL)
    {
      TStructure nextStruct = GetStructureReadOnly(nodeNext->fCurrency);

      if (anchorNext == NULL || nodeNext->fCurrency == activeNext->fCurrency)
        return nextStruct->WithinSelection(nodeNext, activeNext, nodeNext);

      if (activeNext == NULL || nodeNext->fCurrency == anchorNext->fCurrency)
        return nextStruct->WithinSelection(anchorNext, nodeNext, nodeNext);
    }
  }
#endif
  // 27/07/93 See if node is (inclusively) between anchor and active ends
  return !SwapNodes(anchor, node) && !SwapNodes(node, activeEnd);
}

// ------------------------------------------------------------------------
void _TStructure::CheckWhatsSelected (TCurrency currency, long pos,
                                  TCursorNode anchor, TCursorNode activeEnd, int *flags)
{
  *flags |= GetStructureReadOnly(currency)->FindWhatsSelected(currency, anchor, activeEnd);
}

// ------------------------------------------------------------------------
int _TStructure::FindWhatsSelected(TCurrency currency,
                                     TCursorNode anchor, TCursorNode activeEnd)
{
  int flags = // 12/10/94 currency IS my currency!??: GetStructureReadOnly(currency)->
                           WhatsSelected(currency, anchor, activeEnd);
#ifdef TRACE
  Assert(GetStructureReadOnly(currency) == this, 309);
#endif

  if (!MemSpaceIsLow())    // 24/10/94 better than failing?
    Iterate(currency, anchor, activeEnd, TRUE, this,
                                   DoStep(_TStructure::CheckWhatsSelected), &flags);
  return flags;
}
#endif

// ------------------------------------------------------------------------
int _TStructure::GetAlienTerm(long pos, TCursorNode anchor,
                                TCursorNode activeEnd)
{
  return 1;    // 21/02/95 chLineFeed;
}


// ------------------------------------------------------------------------
void _TStructure::DoWriteAlienData(TCurrency currency,
                      long pos, TCursorNode anchor, TCursorNode activeEnd,
                      TSender sender, TCursorNode parentAnchor,
                      TCursorNode parentActiveEnd)
{
  TStructure structure;

  structure = GetStructureReadOnly(currency);        // 31/07/92 from RW
  structure->WriteAlienData(currency, anchor, activeEnd,
                            sender, this, parentAnchor, parentActiveEnd, pos);
}


// ------------------------------------------------------------------------
void _TStructure::WriteAlienData(TCurrency currency, TCursorNode anchor,
          TCursorNode activeEnd, TSender sender, TStructure parent,
          TCursorNode parentAnchor, TCursorNode parentActiveEnd, long pos)
{
  Iterate(currency, anchor, activeEnd, TRUE, this,
          DoStep(_TStructure::DoWriteAlienData), sender, anchor, activeEnd);   // 25/09/91 3 new params
}


// ------------------------------------------------------------------------
static void DoIterateNeedAlienSpace(TStructure theStructure,
                      TCurrency currency,
                      long pos, TCursorNode anchor, TCursorNode activeEnd,
                      int fileType, int *bytesNeeded)
{
  TStructure structure;

  UpdateProgress();
  structure = theStructure->GetStructureReadOnly(currency);    // 12/20/94 from RW??
  structure->DoNeedAlienSpace(currency, anchor, activeEnd,
                                                   fileType, bytesNeeded);
}


// ------------------------------------------------------------------------
void _TStructure::DoNeedAlienSpace(TCurrency currency, TCursorNode anchor,
          TCursorNode activeEnd, int fileType, int *bytesNeeded)
{
  Iterate(currency, anchor, activeEnd, TRUE, this,
                  DoStep(DoIterateNeedAlienSpace), fileType, bytesNeeded);
}


// ------------------------------------------------------------------------
int _TStructure::GetLevel()
{
  TStructure parent;

  if (fParent == 0)
    return 1;

  parent = GetStructureReadOnly(fParent);
  return (parent->fParent == 0 && GetKind() == kSection ?
                                       2 : 1 ) + parent->GetLevel();
}


// ------------------------------------------------------------------------
bool _TStructure::HasCompositeStyle()
{
  return TRUE;
}


#ifdef DRAGDROP
// ------------------------------------------------------------------------
void _TStructure::DoMarkToTop(TCurrency currency, TCurrency child)
{
  if (fParent != 0)
    GetStructureReadWrite(fParent)->DoMarkToTop(fParent, currency);
}

// ------------------------------------------------------------------------
void _TStructure::MarkToTop(TCurrency currency)
{
  DoMarkToTop(currency, gNullCurrency);
}
#endif

// ------------------------------------------------------------------------
int _TStructure::Split(TCursorNode cursorNode, TCurrency &newStart,
                        TCurrency &newEnd, bool keepEmptyStart)
{
  newStart = cursorNode->fCurrency;
  newEnd = 0;
  return 0;
}

// ------------------------------------------------------------------------
int _TStructure::AtEnds(TCursorNode cursorNode)
{
  return 1;
}

#if TALK == 1
// ------------------------------------------------------------------------
void _TStructure::UpdateCaretByWord(TCursorNode anchor, wr_wimp_msgstr *msg)
{
  if (msg->data.words[1] >= 0 && (msg->data.words[1] & 0xff) <= 1)
  {
    EventInfo info;
    TMainView mainView = fDocument->ActiveMainView();

    app_GetEventInfo(&info, (wr_wimp_eventstr *)((char *)msg - 4));
    anchor->fCursor->fSelection->MoveCursor(chSpeak, info, mainView);
    if (msg->data.words[0] == 0)
      msg->data.words[0] = 1;  // so if at end of doc, next call will recognise end
  }
}
#endif

#ifdef TRACE
// ------------------------------------------------------------------------
void _TStructure::GetSelectedText(TCurrency currency, TCursorNode anchor,
                     TCursorNode activeEnd, char* selectedText)
{
}


// ------------------------------------------------------------------------
void _TStructure::DoReplace(TCurrency currency, TCursorNode anchor,
        TCursorNode activeEnd, char* replaceText, bool replaceAll)
{
}


#if TALK == 2
// 15/02/93 [20700] new method for speech
// ------------------------------------------------------------------------
void _TStructure::DoSpeak(TCursorNode cursor)
{
}
#endif


#if TALK == 1
// 30/03/94 new method for speech
// ------------------------------------------------------------------------
int _TStructure::GetWordAtCaret(TCursorNode anchor, TCursorNode activeEnd,
                                                                 wr_wimp_msgstr *msg)
{
  return 0;
}
#endif

#if SIDEBAR == 1
// ------------------------------------------------------------------------
int _TStructure::AddTextToSpeak(TCurrency currency, char *buffer)
{
  return 0;
}
#endif

#ifdef DRAGDROP
// ------------------------------------------------------------------------
int _TStructure::WhatsSelected(TCurrency currency, TCursorNode anchor, TCursorNode activeEnd)
{
  return kNullSelected;
}
#endif

// ------------------------------------------------------------------------
void _TStructure::Iterate(TCurrency currency, TCursorNode anchor,
       TCursorNode activeEnd, bool fromAnchor, TObject obj, DoStep x, ...)
{
}


// ------------------------------------------------------------------------
void _TStructure::IteratePart(TCurrency currency, int part, Rect& custom,
      TStructure pasteStruct, TCurrency pasteCurr, TTextDocument clipDoc,
                                        TObject obj, DoPartStep x, ...)
{
}

// ------------------------------------------------------------------------
void _TStructure::InsertSubStructure(int isPaste, TTextDocument sourceDoc, TCurrency parent, TCurrency &currency, long& before)
{
  NotYetImplemented("TStructure.InsertSubStructure");
}

// ------------------------------------------------------------------------
bool _TStructure::CanIndent(TCurrency currency)
{
  // 28/05/90 - new mac method
  return FALSE;
}

// ------------------------------------------------------------------------
bool _TStructure::CanTypeFast(TCurrency childCurr)
{
  // 25/07/90 - new method
  return FALSE;    // 18/06/95 [26018] TRUE;
}

// ------------------------------------------------------------------------
void _TStructure::InitNewStructure(TCurrency parent, TCurrency currency,
       TCurrency newStyle, TStyleTypes styleTypes, bool initialise, TStructureCmd command)
// 24/03/92 command & initialise
{
  NotYetImplemented("TStructure.InitNewStructure");
}


// ------------------------------------------------------------------------
void _TStructure::NewStructure(TCurrency currency, TCursorNode anchor,
          TCursorNode activeEnd, TCurrency subStruct, TCurrency subStyle,
          TStyleTypes styleTypes, TNewStructureCmd command)
// 24/03/92 replaced by command: CmdNumber command, TCurrency &newStart, TCurrency &newEnd)
{
  NotYetImplemented("TStructure.NewStructure");
}


// ------------------------------------------------------------------------
void _TStructure::EndStructure(TCurrency currency, TCursorNode anchor,
                               int part, Rect& custom)
{
  // 10/09/90 - now just a dummy proc (pictures can go here)
}


// ------------------------------------------------------------------------
TStyleTypes _TStructure::GetKind()
{
  NotYetImplemented("TStructure.GetKind");
  return 0;
}

// ------------------------------------------------------------------------
bool _TStructure::HandleKeypress(int ch, TCursorNode cursorNode)
{
  NotYetImplemented("TStructure.HandleKeypress");
  return FALSE;  // 28/05/90 - MADE INTO A BOOL FN
}


// ------------------------------------------------------------------------
// 21/8/92
bool _TStructure::DoJoin(TCurrency myCurrency, TCurrency currencyToJoin)
{
  return FALSE;
}


// ------------------------------------------------------------------------
bool _TStructure::CanJoin(TCurrency item)
{
  return FALSE;
}

// ------------------------------------------------------------------------
bool _TStructure::AllSelected(TCurrency currency, TCursorNode anchor, TCursorNode activeEnd)
{
  return FALSE;
}


// ------------------------------------------------------------------------
bool _TStructure::SwapNodes(TCursorNode anchor, TCursorNode activeEnd)
{
  return FALSE;      // 15/10/93 TRUE; // 2/5/93 FALSE 
}


// ------------------------------------------------------------------------
void _TStructure::ExtendCursor(TCursorNode cursorNode, TCurrency currency,
                     bool fromRight, bool toBottom, bool keep)
{
  NotYetImplemented("TStructure.ExtendCursor");
}


// ------------------------------------------------------------------------
void _TStructure::ResetCursor(TCursorNode cursor, long insertionPos,
                                            bool fromRight, bool keep)
{
}

// ------------------------------------------------------------------------
void _TStructure::SelectPart(TCursorNode anchor, TCursorNode activeEnd,
                                          int part, Rect &custom)
// 12/01/92 custom param added
{
  NotYetImplemented("TStructure.SelectPart");
}

// ------------------------------------------------------------------------
bool _TStructure::LinkStructure(TCursorNode anchor, TCursorNode activeEnd, bool cmdDone)
// 09/02/93 return as func result: , bool &link)
{
  return FALSE;
}


// ------------------------------------------------------------------------
void _TStructure::Show(TCurrency currency, bool state)
{
  // 25/01/91 - new mac method
}


#ifdef MATHS
// ------------------------------------------------------------------------
bool _TStructure::CanPasteInLine()
{
  // 12/01/92 - new method
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
bool _TStructure::CanLink(TCurrency currency)
{
  // 25/01/91 - new mac method
  return FALSE;
}


// ------------------------------------------------------------------------
TCurrency _TStructure::GetLink()
{
  // 25/01/91 - new mac method
  return gNullCurrency;
}


// ------------------------------------------------------------------------
bool _TStructure::Clear(TCursorNode anchor, TCursorNode activeEnd,
                                  TClearTypes clearType, /* bool &gone, */ int &ch)
{
  NotYetImplemented("TStructure::Clear");
  return FALSE;
}


// ------------------------------------------------------------------------
void _TStructure::GivePastePosition(TCursorNode cursor,
                                    long &startPos, long &endPos)
{
  NotYetImplemented("TStructure.GivePastePosition");
}


// ------------------------------------------------------------------------
void _TStructure::ToggleState(TCurrency currency, TCursorNode anchor,
                             TCursorNode activeEnd, TCommand command)
{
  NotYetImplemented("TStructure.ToggleState");
}


// ------------------------------------------------------------------------
void _TStructure::Commit(TCurrency currency, TCursorNode anchor,
                  TCursorNode activeEnd, TCommand command, bool freeParts)
{
  NotYetImplemented("TStructure.Commit");
}


// ------------------------------------------------------------------------
void _TStructure::GetSelectionKind(TCursorNode anchor, TCursorNode activeEnd,
                             TStyleTypes &kind, int &part, Rect &custom)
{
  NotYetImplemented("TStructure::GetSelectionKind");
}

#ifdef SPELL
// ------------------------------------------------------------------------
void _TStructure::CorrectSpelling(TCurrency currency, TCharPos cp, int len, char *correction)
{
}
#endif

#ifdef FN
// ------------------------------------------------------------------------
TCurrency _TStructure::GetNoteReference()
{
  NotYetImplemented("TStructure::GetNoteReference");
  return gNullCurrency;
}

// ------------------------------------------------------------------------
int _TStructure::GetOrder(TCurrency c1, TCurrency c2) // 22/4/92
{
  return 0;        // 25/03/92 stop warning
}

// ------------------------------------------------------------------------
void _TStructure::ProtoInit(TCurrency currency)
{
}

#else
// ------------------------------------------------------------------------
void _TStructure::ClearNoteCollector()
// 10/05/95 [25012] clear fFootnotes in clip doc
{
}
#endif

#ifdef SPELL
// ------------------------------------------------------------------------
void _TStructure::GetContext(TCharPos cp, char *txt)
{
  strcpy(txt, "---");
}
#endif

// ------------------------------------------------------------------------
#ifdef THESAURUS
void _TStructure::FindSynonym(TCursorNode anchor, TCursorNode activeEnd)
{
}
#endif

#endif

// ------------------------------------------------------------------------
bool _TStructure::IsEmpty()
{
  return FALSE;
}

// ------------------------------------------------------------------------
TCursorNode _TStructure::NewCursorNode()
{
  return new _TCursorNode(gNullCurrency, 0, gZeroVPt);
}



// ------------------------------------------------------------------------
bool _TStructure::InSecondHalf(TCursorNode cursor)
{
  return TRUE;
}


// ------------------------------------------------------------------------
bool _TStructure::IsShown(TCurrency currency, TCurrency child)
{
  if (fParent == 0
#ifdef FN
      || GetKind() == kNoteSet
#endif
     )
    return TRUE;
  return GetStructureReadOnly(fParent)->IsShown(fParent, currency);
// 25/04/91 from: return FALSE;
}

// ------------------------------------------------------------------------

void _TStructure::LinkSelection(TCursorNode anchor, TCursorNode activeEnd,
                                                               bool cmdDone)
{
  TCurrency parent1 = anchor->fCurrency;
  TCurrency parent2 = activeEnd->fCurrency;
  TCursorNode nextAnchor = anchor->GetNext();
  TCursorNode nextActive = activeEnd->GetNext();

  while (nextAnchor != NULL && nextActive != NULL)
  {
    TCurrency currency1 = nextAnchor->fCurrency;
    TCurrency currency2 = nextActive->fCurrency;
    TStructure linkStruct1 = GetStructureReadOnly(parent1);
    TStructure linkStruct2 = GetStructureReadOnly(parent2);
    TStructure linkStruct3 = GetStructureReadWrite(currency1);

    if (currency1 != currency2)
    {
      if ((cmdDone && linkStruct3->GetLink() != 0) ||
                      (!cmdDone && linkStruct1->CanLink(currency1) &&
                                 linkStruct2->CanLink(currency2)) 
                             && linkStruct1->IsShown(parent1, currency1))
                               // 11/01/94 [21226] && do not link from a hidden item
      {
        bool linked;

        linked = linkStruct3->LinkStructure(nextAnchor, nextActive, cmdDone);
        if (!linked && !cmdDone)      // 23/09/91 new test for delete last body
          break;       // 05/02/93 [20609] loop after clear from strt section to next list
        linkStruct2->Show(currency2, !linked);
      }
      else
        break;
    }
    parent1 = currency1;
    parent2 = currency2;
    nextAnchor = nextAnchor->GetNext();
    nextActive = nextActive->GetNext();
  }
}

// ------------------------------------------------------------------------
void _TStructure::DoClipCopy(TCurrency currency, long pos,
                        TCursorNode anchor, TCursorNode activeEnd,
#ifdef DRAGDROP
                        TCursorNode dropNode,
#endif
                        TTextDocument clipDocument, TCurrency clipCurrency)
{
  TStructure structure;

  if (MemSpaceIsLow())
    fDocument->Purge();
  structure = GetStructureReadOnly(currency); // 19/03/91 RW
#ifdef DRAGDROP
  structure->CopyToClipboard(currency, anchor, activeEnd, dropNode, 
                                clipDocument, clipCurrency, -1);
#else
  structure->CopyToClipboard(currency, anchor, activeEnd, clipDocument, clipCurrency, -1);
#endif
}


// ------------------------------------------------------------------------
#ifdef DRAGDROP
void _TStructure::CopyToClipboard(TCurrency currency, TCursorNode anchor,
    TCursorNode activeEnd, TCursorNode dropNode, TTextDocument clipDocument,
    TCurrency clipParent, long pos)
#else
void _TStructure::CopyToClipboard(TCurrency currency, TCursorNode anchor,
    TCursorNode activeEnd, TTextDocument clipDocument, TCurrency clipParent, long pos)
#endif
{
  volatile TStructure structure;
  TCurrency clipCurrency;
  TStyleTypes kind;
  int part;
  Rect custom;
  FailInfo fi;

  GetSelectionKind(anchor, activeEnd, kind, part, custom);
  if ((anchor == NULL || (!anchor->IsCursor(activeEnd) && abs(part) == 1) || clipParent == 0)
#ifdef FN
          && !(kind == kNoteSet || (kind == kFootnote && pos != -22))   // 17/05/93 [20876]
              // 17/05/93 [20876] -22 means ignore fn body for selection within footnote
#endif
           )
  {
    structure = _TStructure::CloneForPaste(currency, fDocument);

    CatchFailures(&fi);
    clipCurrency = currency;
    if (pos == -22)
      pos = -1;    // 17/05/93 [20876]
    clipDocument->AddStructure(0, structure, pos, clipParent, fDocument, clipCurrency);
    Success(&fi);
  }
  else
    clipCurrency = clipParent;

  Iterate(currency, anchor, activeEnd, TRUE, this, DoStep(_TStructure::DoClipCopy), 
#ifdef DRAGDROP
            dropNode, 
#endif
            clipDocument, clipCurrency);
  return;

// ++++++++++++++++++++++++++++++++++
Rescue:
  FreeIfObject(structure);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TStructure::TestTypeOfPaste(TCurrency currency, long pos,
            TTextDocument clipDocument, bool* canHandleIt, int* numOfItems,
            bool *giveToParent, TCurrency anchorCurr)
{
  TStructure pasteData = clipDocument->GetStructureReadOnly(currency);
  int result = (_TStructure::IsShown(anchorCurr, gNullCurrency) ? 
                CanDoPaste(currency, pasteData, *numOfItems) : 0);
                      // 12/01/92 CanPaste renamed
                      // 05/10/93 test IsShown here rather than in every CanDoPaste method

  *canHandleIt = *canHandleIt && (result != 0);
  *giveToParent = result < 0;
  (*numOfItems)++;
}


// ------------------------------------------------------------------------
TStructure DoThePaste(TSelection pasteSelection, TTextDocument clipDocument,
                          TCurrency &currency, bool replace, TStructureCmd cmd)
{
  TCursorNode anchor, activeEnd;
  TStructure structure;

  anchor = pasteSelection->GetAnchorTarget();
  activeEnd = pasteSelection->GetActiveTarget();
  currency = anchor->fCurrency;
  structure = pasteSelection->fDocument->GetStructureReadWrite(currency);
  structure = structure->FindStructureForPaste(anchor, activeEnd, clipDocument, cmd);
  structure->DoPasteFromClipboard(anchor->fCurrency, anchor, activeEnd,
                                                       clipDocument, replace, cmd);
  return structure;
}

// ------------------------------------------------------------------------
TStructure _TStructure::FindStructureForPaste(TCursorNode &anchor,
                     TCursorNode &activeEnd, TTextDocument clipDocument, TStructureCmd cmd)
{
  TCurrency body;
  TStructure pasteBody;
  TStructure parent;
  bool canHandleIt;
  bool giveToParent;
  int numOfItems;
  TStructure findStrForPaste_r = this;   // moved up to stop warning

  body = clipDocument->fBody;
  pasteBody = clipDocument->GetStructureReadOnly(body);
  canHandleIt = TRUE;
  numOfItems = 1;
  pasteBody->IteratePart(body, 1, gZeroRect, NULL, gNullCurrency,
                NULL, this, (DoPartStep)_TStructure::TestTypeOfPaste,
                clipDocument, &canHandleIt, &numOfItems, &giveToParent,
                anchor->fCurrency);   // 18/04/91 anchor curr param added
  if (canHandleIt)
  {
    int index;
    TCursor cursor;
    int limit;

    if (giveToParent && (cmd->fCmdNumber != cMove || AtEnds(anchor)))  // 05/03/91 new condition
    {
      findStrForPaste_r = GetStructureReadWrite(fParent);
      if (activeEnd->GetIndex() >= anchor->GetIndex())  // 15/09/92 balance up cursors
        activeEnd = activeEnd->GetPrevious();
      anchor = anchor->GetPrevious();
    }
    index = 1;
    cursor = anchor->fCursor;
    limit = cursor->GetSize();
    while (index <= limit)
    {
      if (cursor->At(index) == anchor)
        break;
      index++;
    }
    cursor = activeEnd->fCursor;
    activeEnd = TCursorNode(cursor->At(Min(index, cursor->GetSize())));
  }
  else if ((int)(0x800c0180 << GetKind()) >= 0)    // 19/05/94 [21811] not doc, h/f, fn
  {
    parent = GetStructureReadWrite(fParent);
    if (activeEnd->GetIndex() >= anchor->GetIndex())  // 15/09/92 balance up cursors
      activeEnd = activeEnd->GetPrevious();
    anchor = anchor->GetPrevious();
    findStrForPaste_r = parent->FindStructureForPaste(anchor, activeEnd, clipDocument, cmd);
  }
  else
    FailGeneral(kPasteAlert);    // 19/05/94 [21811]
  return findStrForPaste_r;
}


// ------------------------------------------------------------------------
TStructure _TStructure::CloneForPaste(TCurrency currency, TTextDocument targetDoc)
{
  TStructure obj;
  Ptr ptrToArray;

  obj = TStructure(targetDoc->GetPrototype(Curr_fType(currency)));
  obj->ReduceSize(0);                     // the prototype may not be empty!
  ptrToArray = obj->fPtrToArray;

#ifdef TRACE
  Assert(memcmp(obj, this, 4) == 0, 196); // check same object type (CFront specific!)
#endif

  obj = TStructure(memcpy(obj, this, GetHandleSize(Handle(obj)))); // copy the non-array flds
  obj->fSize = 0;                         // restore those that should be
  obj->fPtrToArray = ptrToArray;
  return obj;
}


// ------------------------------------------------------------------------
void _TStructure::DoPasteBody(TCurrency currency, long pos,
          TTextDocument clipDocument, long *insertionPos,
          TCurrency parentCurr, TCurrency *pasteCurrency, 
          int* pasteLevel
#ifdef DRAGDROP
        , int cmdNumber
#endif
        )  
{
  TStructure pasteData;
  long savePos;
  TCurrency pasteCurr1;
  volatile TStructure newStruct;
  volatile TCurrency pasteCurr;
  FailInfo fi;

  newStruct = NULL;
  pasteData = clipDocument->GetStructureReadOnly(currency);
  newStruct = pasteData->CloneForPaste(currency, fDocument);
  pasteCurr = Curr_Set(0, Curr_fType(currency));

  CatchFailures(&fi);
  fDocument->AddStructure(
#ifdef DRAGDROP
        cmdNumber,
#else
        1, 
#endif
        newStruct, *insertionPos, parentCurr, clipDocument, pasteCurr);
  Success(&fi);

  *pasteLevel = *pasteLevel + 1;
  savePos = *insertionPos;
  *insertionPos = -1;
  if (pasteCurr != 0)    // fn1
    parentCurr = pasteCurr; // fn1
  else
  {
    newStruct = GetStructureReadWrite(parentCurr);
    pasteCurr = parentCurr;
  }
  pasteData->IteratePart(currency, 1, gZeroRect, newStruct, pasteCurr,
          clipDocument, this, DoPartStep(_TStructure::DoPasteBody),
          clipDocument, insertionPos, parentCurr, &pasteCurr1, pasteLevel
#ifdef DRAGDROP
          , cmdNumber
#endif
          );

  *insertionPos = savePos;
  *pasteLevel = *pasteLevel - 1;
  *pasteCurrency = pasteCurr;

  return;

// ++++++++++++++++++++
Rescue:
  if (Curr_fRecnum(pasteCurr) == 0)
    FreeIfObject(newStruct);
  ContinueFailure(&fi);
}

// ------------------------------------------------------------------------
// 21/8/92
void _TStructure::DoPasteErrorRecovery(TCurrency currency, long endPos, TStructureCmd cmd)
{
#ifdef DRAGDROP
  if (cmd->fCmdNumber != cMove)  // 30/09/93 [21064] avoid double Toggle with cMove recovery
#endif
    ToggleState(currency, NULL, NULL, cmd);
#ifndef DRAGDROP
  Commit(currency, NULL, NULL, cmd, FALSE);
#endif
}

// 09/09/92 PasteFromClipboard split into PasteFromClipboard and DoPasteFromClipboard
// ------------------------------------------------------------------------
long _TStructure::PasteFromClipboard(TCurrency currency, TCursorNode anchor,
       TCursorNode activeEnd, TTextDocument clipDocument, long *insertionPos,
       TStructureCmd cmd)
{
  TCurrency body;
  TStructure pasteBody;
  TCurrency parentCurr;
  long startPos;
  TCurrency pasteCurrency;       // fn1
  int pasteLevel;
  FailInfo fi; // 21/8/92

  body = clipDocument->fBody;
  pasteBody = clipDocument->GetStructureReadOnly(body);

  // Beware: nodes not necessarily 'mine'
  GivePastePosition( // 10/02/92 for paste over paras: activeEnd,
     activeEnd->fCurrency == anchor->fCurrency ? activeEnd : anchor,
           startPos, *insertionPos); // 25/07/90
  parentCurr = currency;
  pasteLevel = 0;
  SetPastePosition(gNullCurrency, 0);    // 10/09/92
  CatchFailures(&fi);
#ifdef DRAGDROP
  gPastedObj = 0;
#endif

  pasteBody->IteratePart(body, 1, gZeroRect, NULL, gNullCurrency, NULL,
               this, DoPartStep(_TStructure::DoPasteBody),
               clipDocument, insertionPos, parentCurr, &pasteCurrency, &pasteLevel
#ifdef DRAGDROP
               , cmd->fCmdNumber
#endif
             ); // fn1

  Success(&fi);

  // setting the final cursor after the paste is now a seperate action
  // 09/09/92 leave caret in the last maths, text or picture pasted (hopefully there is one)
#ifdef DRAGDROP
  cmd->SetPastedObj(gPastedObj);
#endif
  cmd->SetStart(gPasteEndCurr);
  cmd->SetPositionData(gPasteEndPosn);

  return startPos;

// ++++++++++++++++++++
Rescue: // 21/8/92 added error handler
  DoPasteErrorRecovery(currency, *insertionPos, cmd);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TStructure::DoPasteFromClipboard(TCurrency currency, TCursorNode anchor,
       TCursorNode activeEnd, TTextDocument clipDocument, bool replace, TStructureCmd cmd)
// 09/09/92 this is what is done for maths and text; body and column override
{
  long insertionPos, startPos;
//  TStructure anchorStruct;

#ifdef TRACE
  Assert(GetStructureReadOnly(anchor->fCurrency) == this, 297);
#endif

  // this now is (only) to reset the selection used for reformatting the changes
  startPos = PasteFromClipboard(currency, anchor, activeEnd, clipDocument, &insertionPos, cmd);
// only bodies:  if (startPos >= 0)                       // 25/01/91 test added
  ResetCursor(anchor, startPos, FALSE, FALSE);

// 23/05/94 [21818] insertionPos may not relate to anchorStruct (unless it too is me)
//  anchorStruct = GetStructureReadOnly(activeEnd->fCurrency);  // may be the same as self
//  anchorStruct->ResetCursor(activeEnd, insertionPos, TRUE, FALSE);
  if (activeEnd->fCurrency == currency)
    ResetCursor(activeEnd, insertionPos, TRUE, FALSE);
}


// ------------------------------------------------------------------------
int _TStructure::CanDoPaste(TCurrency currency,
                                    TStructure dataToPaste, int numOfItems)
               // 18/04/91 first param added; 12/01/91 renamed from CanPaste
               // 29/07/93 Maths and Text are common so do here
{
#ifdef MATHS
  return (              // 05/10/93 IsShown(myCurrency, gNullCurrency) &&
             numOfItems == 1 && dataToPaste->CanPasteInLine() ? 1 : 0);
#else
  return 0;
#endif
}


// ------------------------------------------------------------------------
bool _TStructure::CanType()
{
  return TRUE;
}


// ------------------------------------------------------------------------
void _TStructure::GetControlChars(TStructure caller, TCursorNode cursor, ControlCharSet &controls)
{
  if (fParent != 0)
  {
    TStructure structure = GetStructureReadOnly(fParent);

    structure->GetControlChars(caller, cursor->GetPrevious(), controls);
  }
}


// ------------------------------------------------------------------------
void _TStructure::SetStyle(TCurrency currency, TCurrency style, int part, Rect &custom,
                                                                          CmdNumber cmd)
{
  if (part == 1)
  {
    fUndoStyle = fStyle;
    fStyle = style;
    fUndoChanges = fChanges;
    fChanges = 0;
  }
  else
  {
    TStyleFormat styleFormat = fDocument->ActiveMainView()->GetStyle(style, kReadOnly);

    styleFormat = TStyleFormat(styleFormat->Clone());
    InstallStyleChange(currency, styleFormat, part, custom, cmd);
  }
}


// ------------------------------------------------------------------------
void _TStructure::ToggleStyle(int part, Rect &custom, CmdNumber cmd)
{
  if (part == 1)
  {
    TCurrency tempStyle;

    tempStyle = fStyle;
    fStyle = fUndoStyle;
    fUndoStyle = tempStyle;
    tempStyle = fChanges;
    fChanges = fUndoChanges;
    fUndoChanges = tempStyle;
  }
  else
    ToggleChanges(abs(part), custom, cmd); // 22/4/92               // 16/06/91 abs
}


// ------------------------------------------------------------------------
void _TStructure::ToggleChanges(int part, Rect& custom, CmdNumber cmd)
{
  TCurrency tempStyle;

  tempStyle = fChanges;
  fChanges = fUndoChanges;
  fUndoChanges = tempStyle;
}


// ------------------------------------------------------------------------
static void TestForChanges(TObject self, int part, Rect &custom,
         TCurrency partStyle, TStyleStructure styleStructure,
         TMainView view, int *next)
{
  *next = *next | partStyle;  // in fact this is only called if partStyle != 0
}

// ------------------------------------------------------------------------
void _TStructure::InstallStyleChange(TCurrency currency, TStyleFormat theChanges,
                                               int part, Rect &custom, CmdNumber cmd)
{
  TStyleStructure styleStructure = NULL;
  TStyleFormat styleFormat = NULL;
  TCurrency newStyle;
  TPartStyles partStyles;
  TPartStyles partStyles1;
  TDiscObject newObj;
  TStructTypes styleType;
  TMainView view = fDocument->ActiveMainView();
  int partChanges;
  bool iterating = FALSE;

  if (part < 0)    // 24/02/92 to stop creating dozens of styles
  {
    iterating = TRUE;
    part = -part;
  }
  theChanges->fDefined &= ~kEmphasis;              // 03/10/91 moved from UTextEdit
  if (fChanges == 0)
  {
  }
  else if (part == 1)
    styleFormat = view->GetStyleReadWrite(fChanges);
  else
  {
    styleStructure = fDocument->GetStyleReadWrite(fChanges);
    styleStructure->GetPartStyles(part, custom, partStyles);
    if (partStyles.fStyle != 0)
      styleFormat = view->GetStyleReadWrite(partStyles.fStyle);
  }
#ifdef TRACE
//  Assert(fUndoChanges == 0, 591);    // should have been committed
#endif
#ifdef WORD7
  if (cmd != cNoCommand)      // 26/04/96 do not set up undo state when cNoCommand
#endif
    fUndoChanges = fChanges;
  newStyle = 0;

  if (cmd != cPlain) // 6/5/92
  {
    TStyleFormat newChanges;

    styleType = (fStyle == 0 || part != 1 ? kTextStyleStruct : Curr_fType(fStyle));

    if (styleType != kTextStyleStruct)
    {
      newChanges = TStyleFormat(view->GetPrototype(styleType));
      theChanges->Copy(newChanges);
    }
    else
       newChanges = TStyleFormat(theChanges->Clone());

    if (styleFormat == NULL || styleFormat->fTimeStamp == theChanges->fTimeStamp)
    {
      if (newChanges->NumOfAttrs(0) != 0 &&
                view->FindAnonStyle(newChanges, styleType, newStyle) == 0)  // 28/01/94 [21369]
      {
        if (styleFormat == NULL || part != 1)        // 11&15/02/91 new test
        {
          newStyle = fDocument->NewCurrency(styleType, newObj);
          if (part == 1)
            TStyleStructure(newObj)->fType = GetKind();            // 25/01/91
        }
        else
        {
          newStyle = fChanges;
          fDocument->CloneStyle(fDocument, view, FALSE, TRUE, newStyle); // 8/4/92
        }
        newChanges->fTimeStamp = UniqueNumber();            // 15/02/91
        view->SetStyle(newStyle, newChanges);
        newChanges = NULL;     // 26/04/96 do not free it below
      }
      // 26/04/96 else
      // 26/04/96   newChanges->Free();
    }
    else if (newChanges->NumOfAttrs(kRuler) == 0 && newChanges->fTimeStamp != 0)
    {
      if (part == 1)               // 22/05/92 missed from Mac
        newStyle = fChanges;       // 26/04/96 must be the same as: fUndoChanges;
      else
        newStyle = 0;
      // 26/04/96 newChanges->Free();
    }
    else
    {
      styleFormat = TStyleFormat(styleFormat->Clone());
      styleFormat->ApplyOverride(newChanges, gNullCurrency, TRUE);
      if (styleFormat->NumOfAttrs(0) != 0)
      {
        if (view->FindAnonStyle(styleFormat, styleType, newStyle) == 0)  // 28/01/94 [21369]
        {
          if (styleType == Curr_fType(fChanges)) // 01/10/91 do not get non-para part styles
          {
            newStyle = fChanges;              // 11/02/91 replace 3 lines below
            fDocument->CloneStyle(fDocument, view, FALSE, TRUE, newStyle); // 8/4/92
          }
          else   // 01/10/91 new else clause
          {
            newStyle = fDocument->NewCurrency(styleType, newObj);
            if (part == 1)
              TStyleStructure(newObj)->fType = GetKind();
          }
          view->SetStyle(newStyle, styleFormat);
          styleFormat = NULL;  // 26/04/96 do not free it below
        }
        // 26/04/96 else
        // 26/04/96   styleFormat->Free();
      }
      // 26/04/96 else
      // 26/04/96   styleFormat->Free();
      FreeIfObject(styleFormat);
      // 26/04/96 newChanges->Free();               // 18/09/90
    }
    FreeIfObject(newChanges);
  }
  if (part == 1)
    fChanges = newStyle;
  else
  {
    partStyles1 = partStyles;          // 18/02/92
    partStyles.fStyle = newStyle;      // 18/02/92
#ifdef TRACE
    Assert(newStyle == 0 || Curr_fType(newStyle) == kTextStyleStruct, 197);
    // 11/05/94 Assertion never hit, so assume test below unnecessary
#endif
    //  if (newStyle == 0 || Curr_fType(newStyle) == kTextStyleStruct)
    // 18/02/92 was not allowing Delete changes on a part style
    {
      // 18/02/92 - new block to take off * on style if all changes removed
      if (newStyle == 0 && styleStructure != NULL &&
                                    view->GetStyleReadOnly(fChanges)->NumOfAttrs(0) == 0)
      {
        partChanges = 0;
        styleStructure->PutPartStyles(part, custom, partStyles);
        styleStructure->ForAllPartsDo(this,
                (DoToStyles)TestForChanges, NULL, NULL, &partChanges);
        styleStructure->PutPartStyles(part, custom, partStyles1);
      }
      else if (cmd == cPlain) // 6/5/92
      {
        partChanges = 0;
        // fChanges = gNullCurrency;
      }
      else
        partChanges = 1;

      if (partChanges)        // 18/02/92
      {
        if (styleStructure == NULL)
        {
          newStyle = fDocument->NewCurrency(Curr_fType(fStyle), newObj);
          styleStructure = TStyleStructure(newObj);
          styleStructure->fType = GetKind();
        }
        else
        {
          newStyle = fChanges;              // 11/02/91 new else
          if (!iterating)                   // 24/02/92 new clause
          {
            fDocument->CloneStyle(fDocument, view, FALSE, TRUE, newStyle); // 8/4/92
            styleStructure = fDocument->GetStyleReadWrite(newStyle);
          }
        }
        fChanges = newStyle;
        styleStructure->PutPartStyles(part, custom, partStyles);
      }
      else                    // 18/02/92
        fChanges = 0;
    }
  }
}


// ------------------------------------------------------------------------
void _TStructure::CommitStyle(TCurrency currency, TCommand command, int part, Rect &custom)
{
  fUndoStyle = 0;
  fUndoChanges = 0;
}


// ------------------------------------------------------------------------
void _TStructure::GetPartInfo(TCurrency partCurrency, int &part, Rect &custom)
{
  part = 0;
  ClearRect(custom);
}


// ------------------------------------------------------------------------
// 17/7/92 new
TStructTypes _TStructure::GetPartStyleType(int part, Rect& custom)
{
  return (part == 1 && fStyle != 0 ? Curr_fType(fStyle): kTextStyleStruct);
    // 02/02/93 && fStyle != 0 for corrupt documents
}

// ------------------------------------------------------------------------
TCurrency _TStructure::GetPartStyle(int part, Rect& custom, TCurrency &itsChanges)
{
  TPartStyles partStyles;
  TStyleStructure style;
  TCurrency itsStyle;

  if (part == 1)
  {
    itsStyle = fStyle;
    itsChanges = fChanges;
  }
  else
  {
    style = fDocument->GetStyleReadOnly(fStyle);
    style->GetPartStyles(part, custom, partStyles);
    itsStyle = partStyles.fStyle;

    // 25/01/91 following changed
    if (fChanges == 0)
      itsChanges = 0;
    else
    {
      style = fDocument->GetStyleReadOnly(fChanges);
      style->GetPartStyles(part, custom, partStyles);
      itsChanges = partStyles.fStyle;
    }
  }
  return itsStyle;
}

// ------------------------------------------------------------------------
void _TStructure::SetChanged(TCurrency currency, TCurrency child,
                                                          bool state)
{
  GetStructureReadWrite(fParent)->SetChanged(fParent, currency, state);
}

#ifdef SPELL
// ------------------------------------------------------------------------
void _TStructure::DoSpellIteration(TCurrency currency, long pos,
                             TCursorNode anchor, TCursorNode activeEnd)
{
  UpdateProgress();
  GetStructureReadOnly(currency)->DoSpellCheck(currency, anchor, activeEnd);
}

// ------------------------------------------------------------------------
void _TStructure::DoSpellCheck(TCurrency currency, TCursorNode anchor,
                                                   TCursorNode activeEnd)
{
  Iterate(currency, anchor, activeEnd, TRUE, this,
                                  (DoStep)_TStructure::DoSpellIteration);
}
#endif

// ------------------------------------------------------------------------
// 03/08/92 used by UTextComm not in footnotes!
// 24/01/94 rewritten to use use set of TStyleTypes: from == kind
// Compares the kind of the parent structures of this with the set of TStyleTypes
TCurrency _TStructure::IsPartOf(TStyleTypes kind)
{
  TCurrency item;
  TStructure structure = this;
  
  while (item = structure->fParent, item != 0)
  {
    structure = GetStructureReadOnly(item);

    if (((1 << structure->GetKind()) & kind) != 0)
      break;   // match found, return the currency
  }
  return item;  // if dropped out of the bottom of the loop, item is a null currency
}


#ifdef FN
// ------------------------------------------------------------------------
void _TStructure::AddNote(TCurrency owner, TCurrency note)
{
  GetStructureReadWrite(fParent)->AddNote(owner, note);
}

// ------------------------------------------------------------------------
TNumberStyle _TStructure::GetNoteNumber(TCurrency currency, TCurrency note, char *number)
{
  TStructure parent = GetStructureReadOnly(fParent);

  if (parent->GetKind() == kNoteSet)
    currency = fParent;
  return parent->GetNoteNumber(currency, note, number);
}

// ------------------------------------------------------------------------
void _TStructure::ShowNote(TCurrency currency, bool state)
{
  GetStructureReadOnly(fParent)->ShowNote(currency, state);
}

// ------------------------------------------------------------------------
void _TStructure::DeleteNote(TCurrency currency, TCurrency note, TCommand command)
{
  GetStructureReadOnly(fParent)->DeleteNote(fParent, note, command);
}

// ------------------------------------------------------------------------
TCurrency _TStructure::GetNoteCollector(void)
{
  if (fParent == 0)
    return gNullCurrency;
  return GetStructureReadOnly(fParent)->GetNoteCollector();
}

// ------------------------------------------------------------------------
TCurrency _TStructure::GetLastNote(void)
{
  return (fParent == 0 ? fParent : GetStructureReadOnly(fParent)->GetLastNote());
                       // 19/05/92 avoid running off the top
}

// ------------------------------------------------------------------------
//void _TStructure::FindNoteReference(TCurrency currency, TCursorNode &node)
//{
//  GetStructureReadOnly(fParent)->FindNoteReference(fParent, node);
//}

// ------------------------------------------------------------------------
//bool _TStructure::IsNoteCollector(void)
//{
//  return FALSE;
//}

// ------------------------------------------------------------------------
TCurrency _TStructure::GetNoteContainer(TCurrency)
{
  return DoGetNoteContainer(fParent);
     // GetStructureReadOnly(fParent)->GetNoteContainer(fParent);
}

// ------------------------------------------------------------------------
TCurrency _TStructure::DoGetNoteContainer(TCurrency curr)
{
  return GetStructureReadOnly(curr)->GetNoteContainer(curr);
}
#endif

// ------------------------------------------------------------------------
#ifdef MATHS
bool _TStructure::CommandToStruct(CmdNumber cmd, TStyleTypes &styleType,
                            TStructTypes &structType)
{
  return CmdToStruct(cmd, styleType, structType);
}
#endif

// ------------------------------------------------------------------------
TStyleFormat _TStructure::GetStyleFormat(TStyleFormat *toBeFreed)
{
  TMainView mv = fDocument->ActiveMainView();
  TStyleFormat style = (fStyle == 0 ? NULL : mv->GetStyleReadOnly(fStyle));

#ifdef TRACE
  Assert(style, 557);   // most places assume fStyle always set (is so, this can be simplified)
#endif

  *toBeFreed = NULL;
  if (fChanges != 0)
  {
    TStyleFormat changes = mv->GetStyleReadOnly(fChanges);

    if (style != NULL)
    {
      style = TStyleFormat(style->Clone());
      *toBeFreed = style;
      style->ApplyOverride(changes, gNullCurrency, TRUE);
    }
    else
      style = changes;
  }
  return style;
}

// ------------------------------------------------------------------------
_TFormat::_TFormat(TMainView itsView, int itsItemSize) : (itsItemSize)
{
  fMainView = itsView;
#ifndef ZERO_OBJ
  fSpBefore = 0;
  fSpAfter = 0;
  fAscent = 0;
  fDescent = 0;
  fLeftMargin = 0;
  fRightMargin = 0;
  fIndentation = 0; // 28/05/90 - new
  fAlign = kAlignLeft;
  fFiller1 = 0;
  fFiller2 = 0;
  fFlags = 0;
  fAdorn = 0;
#endif
//  fRules.fRule = kHairLine;
//  fRules.fPen = 1;
//  fRules.fRule = k1Thn;
//  fRules.fPen = kOnePtPen;
//  fRules.fShort = FALSE;  // 21/07/92
  fRules = gDefaultPen;
}

static struct {
  int fSpBefore;
  int fSpAfter;
  Size fAscent;
  Size fDescent;
  Fixed fLeftMargin;
  Fixed fRightMargin;
  Fixed fIndentation;
  char /* TAlignment */ fAlign;
  char fFiller1;
  char fFiller2;
  char fFlags;
  CntlAdornment fAdorn;
  TRuleType fRules;
  bool fHasChanged;
  } gFmtMaster = {20,20,0,27,0,0,0,0,0,0,0,0,{kOnePtPen, k1Thn, FALSE},0};
                            // 21/07/92 FALSE added

static char gFmtMap[] =
  "\x01\x01\x02\x01\x01\x02\x01\x01\x02\x01\x01\x02\x02\x01\x01\x02\x01\x01\x02\x01\x01\x01\x03\x01\x03\x04\x04\x00\x00\x00\x00";
 // the extra zeroes ensure SumRecord adds nothing if the top bit of flags set

// ------------------------------------------------------------------------
unsigned int _TFormat::GetFmtMask()
{
  return FindMask((char *)&fSpBefore, (char *)&gFmtMaster.fSpBefore, gFmtMap,
              0x2bfffdb); // 08/12/94 0x2bff7db);
}

// ------------------------------------------------------------------------
long _TFormat::DoNeedDiskSpace(long dataForkBytes)
{
  unsigned int mask = GetFmtMask();
  int fmtTotal = SumRecord(mask, gFmtMap) + 4;

  return _TArray::DoNeedDiskSpace(dataForkBytes + fmtTotal -
                              int(sizeof(_TFormat)) + int(sizeof(_TArray)));
}

// ------------------------------------------------------------------------
void _TFormat::DoRead(int aRefNum, long remainder, int version)
{
#ifdef VERS0
  if (version == 0)
  {
    TMainView myView = fMainView;

    _TArray::DoRead(aRefNum, remainder, version);  // the inherited read
    fMainView = myView;
  }
  else
#endif
  {
    unsigned int flags;
    char buffer[48];
    int reqSize;

    _TArray::DoRead(aRefNum, sizeof(_TArray), version);

    FRead(aRefNum, sizeof(unsigned int), &flags);
    reqSize = SumRecord(flags, gFmtMap);

    FRead(aRefNum, reqSize, buffer);
    UnpackRecord(flags, gFmtMap, buffer, &gFmtMaster, &fSpBefore);
    fFlags = (flags >> 24) & kBackwards;   // 28/06/94 top flag bit is backward text flag
    FRead(aRefNum, remainder - sizeof(_TFormat), this + 1);
  }
}

// ------------------------------------------------------------------------
void _TFormat::DoWrite(int aRefNum, long remainder)
{
  struct{
    unsigned int flags;
    char buffer[48];
  } discData;
  int reqSize;

  _TArray::DoWrite(aRefNum, sizeof(_TArray));   // inherited inherited call

  discData.flags = GetFmtMask();
  reqSize = PackRecord(discData.flags, gFmtMap, (char *)&fSpBefore, discData.buffer);
  discData.flags |= (fFlags << 24);  // 28/06/94 set backward text flag

  FWrite(aRefNum, reqSize + 4, &discData);
  FWrite(aRefNum, remainder - sizeof(_TFormat), this + 1);
}


// ------------------------------------------------------------------------
int _TFormat::TextFont(PFontStyle fontStyle)
{
  return TTextDocument(fMainView->fDocument)->SetCurrentFont(fontStyle);
}


// 03/07/91 four envelopes for calling MainView zoom methods
// ------------------------------------------------------------------------
void _TFormat::ZoomPt(Point &itsPoint)
{
  fMainView->ZoomPt(itsPoint);
}


// ------------------------------------------------------------------------
void _TFormat::ZoomRect(Rect &itsRect)
{
  fMainView->ZoomRect(itsRect);
}


// ------------------------------------------------------------------------
int _TFormat::ZoomInt(int itsNum)
{
  return fMainView->ZoomInt(itsNum);
}


// ------------------------------------------------------------------------
Fixed _TFormat::ZoomFixed(Fixed itsNum)
{
  return fMainView->ZoomFixed(itsNum);
}

// ------------------------------------------------------------------------
TCursorNode _TFormat::InitialCursor(TCurrency currency, TCurrency child, long posn)
{
  return new _TCursorNode(currency, kNewCursor, gZeroVPt);
}

// ------------------------------------------------------------------------
TStyleFormat _TFormat::GetNewStyle(TCurrency currency, int part, Rect& custom)
{
  // 07/02/94 rewritten to shorten code (does the same as before), i.e.
  // part number < 1 or no changes - return an empty prototype
  // else return a copy of the changes for the part
  TStructure struct1 = GetStructureReadOnly(currency);
  TCurrency changesCurrency = struct1->fChanges;
  TStyleFormat theStyle;

  if (part >= 1)
  {
    if (part > 1)
      struct1->GetPartStyle(part, custom, changesCurrency);
    if (changesCurrency != 0)
      return TStyleFormat(GetStyleReadOnly(changesCurrency)->Clone());
  }

  theStyle = TStyleFormat(fMainView->GetPrototype(
                           struct1->GetPartStyleType(part, custom) & 0x7f)); // 10/03/94 &.
  if (part >= 1)
    theStyle->fTimeStamp = UniqueNumber();

  return theStyle;
}


// ------------------------------------------------------------------------
void _TFormat::GetMarginLimits(TStructure structure, int part, Rect& custom,
                               Fixed &leftLimit, Fixed &rightLimit)
{
  TStyleFormat styleToBeFreed;
  // TCurrency styleCurrency;
  TStyleFormat theStyle;
  // TStyleFormat theChanges;
  // bool cloned;
  int structKind = structure->GetKind();

  if (structKind == kText
#ifdef MATHS
         || structKind == kMaths  // 12/01/92 for rulers in maths emphasis
#endif
       )
    return;

  theStyle = structure->GetStyleFormat(&styleToBeFreed);
  // cloned = FALSE;
  // styleCurrency = structure->fStyle;
  // if (styleCurrency != 0)
  //   theStyle = GetStyleReadOnly(styleCurrency);
  // else
  //   theStyle = NULL;

  // styleCurrency = structure->fChanges;
  // if (styleCurrency != 0)
  // {
  //   if (theStyle != NULL)
  //   {
  //     theStyle = TStyleFormat(theStyle->Clone());
  //     cloned = TRUE;
  //     theChanges = TStyleFormat(GetStyleReadOnly(styleCurrency));
  //     theStyle->ApplyOverride(theChanges, gNullCurrency, TRUE);
  //   }
  //   else
  //     theStyle = GetStyleReadOnly(styleCurrency);
  // }

  if (theStyle != NULL)
  {
    leftLimit += Max(0, theStyle->GetLeftMargin());
    rightLimit += Max(0, theStyle->GetRightMargin());   // 08/02/91 Max
  }

  // if (cloned)
  //   theStyle->Free();
  FreeIfObject(styleToBeFreed);
}


// ------------------------------------------------------------------------
TCursorNode _TFormat::GetTheCursor(TView view, VPoint& mousePoint, TCurrency child)
{
  return(TSubView(view)->ClickOnce(mousePoint));
// 20/02/94 moved from UTextEdit
//  NotYetImplemented("TFormat.GetTheCursor");
//  return NULL;
}

#ifdef TRACE
// ------------------------------------------------------------------------
Fixed _TFormat::GetIndentation()
{
  return fIndentation;
}


// ------------------------------------------------------------------------
Fixed _TFormat::GetLeftMargin()
{
  return fLeftMargin;
}


// ------------------------------------------------------------------------
void _TFormat::SetLeftMargin(Fixed margin)
{
  fLeftMargin = margin;
}


// ------------------------------------------------------------------------
Fixed _TFormat::GetRightMargin()
{
  return fRightMargin;
}


// ------------------------------------------------------------------------
void _TFormat::SetRightMargin(Fixed margin)
{
  fRightMargin = margin;
}


// ------------------------------------------------------------------------
void _TFormat::SetHasChanged(bool changed)
{
  fHasChanged = changed;
}

// ------------------------------------------------------------------------
bool _TFormat::ContainsCursor(TCurrency currency, TObject startBreak,
                              TObject endBreak, TCursorNode cursor)
{
  NotYetImplemented("TFormat.ContainsCursor");
  return FALSE;
}


// ------------------------------------------------------------------------
void _TFormat::ClearChangedFlags(TCurrency currency, int hf)
{
  NotYetImplemented("TFormat.ClearChangedFlags");
}

// ------------------------------------------------------------------------
TChangeTypes _TFormat::Reformat(TCurrency currency, TCursorNode anchor,
        TCursorNode activeEnd, int fitToWidth, Fixed gapHalf, PStdNoteVars v)
{
  // 06/08/90 - interface changed
  NotYetImplemented("TFormat.Reformat");
  return 0;
}


// ------------------------------------------------------------------------
// fn1 changed params
bool _TFormat::Fit(int pageNumber, TCurrency currency, int &spaceAvailable, int &noteSpaceUsed,
    int maxAvailable, TObject &breakObject, int &gapCount, bool &splitLeaf,
    PStdFitNoteVars headingProc,
    PStdFitNoteVars v)
{
  // 06/08/90 - interface changed
  NotYetImplemented("TFormat.Fit");
  return FALSE;
}


// ------------------------------------------------------------------------
THFVisibility _TFormat::GetHFVisibility(TCurrency currency)
{
  NotYetImplemented("TFormat.GetHFVisibility");
  return 0;
}


// ------------------------------------------------------------------------
void _TFormat::MoveCursor(TCursorNode cursor, int arrowKey, EventInfo &)
// 02/11/90 new
{
  NotYetImplemented("TFormat.MoveCursor");
}


// ------------------------------------------------------------------------
int _TFormat::GetMinWidth()
{
  NotYetImplemented("TFormat.GetMinWidth");
  return 0;
}


// ------------------------------------------------------------------------
void _TFormat::SetWidth(TCurrency currency, int newWidth)
{
  NotYetImplemented("TFormat.Setwidth");
}


// ------------------------------------------------------------------------
int _TFormat::GetWidth()
{
  NotYetImplemented("TFormat.Getwidth");
  return 0;
}


// ------------------------------------------------------------------------
TSubView _TFormat::MakeView(TCurrency currency, TViewId viewId, // Fixed itsSlop, VPoint &
                  Fixed itsVSlop, TView itsSuperView, TView itsNextView,
                  VPoint &itsLocation, TObject startBreak, TObject endBreak)
{
  NotYetImplemented("TFormat.Makeview");
  return NULL;
}


// ------------------------------------------------------------------------
bool _TFormat::UpdateView(
                TCurrency currency, TSubView itsView, VPoint &itsLocation, // VPoint &
                Fixed itsVSlop, TObject startBreak,
                TObject endBreak, bool invalidate, bool updateAll)
{
  NotYetImplemented("TFormat.UpdateView");
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
// 18/11/94 common up 4 calls
static void ApplyStyleChange(TFormat self, TCurrency styleCurr, TCurrency currency,
      TStyleSet styleSet, TStyleTypes kind, Attributes allowed, bool useRuler)
{
  Attributes defined;
  TStyleFormat theStyle = self->GetStyleReadOnly(styleCurr);

  if (styleSet->ContainsStyle(styleCurr))
    allowed &= ~kFace; // 29/4/92

  if (kind == kMaths || kind == kText)
    allowed &= emphasisAttrs;

  // inline: styleSet->ApplyOverride(theStyle, styleCurr, useRuler, allowed);
  defined = theStyle->fDefined;
  theStyle->fDefined &= allowed;
  styleSet->fStyle->ApplyOverride(theStyle, currency, useRuler);
  theStyle->fDefined = defined;
}

// ------------------------------------------------------------------------
void _TFormat::DoGetCompositeStyle(TCurrency currency, TCurrency partCurrency, 
                                   Attributes permittedAttrs, TStyleSet styleSet)
{
  TStructure structure = GetStructureReadOnly(currency);
  bool ruler;
  TCurrency parent = structure->fParent;
  TStyleTypes kind = partCurrency ? structure->GetKind() : kDocument;
                         // kDocument is a value which stops kind tests succeeding below

  ruler = structure->HasCompositeStyle();
  if (parent != 0)
    GetFormatReadOnly(parent)->DoGetCompositeStyle(parent, currency,
          (kind >= kFigure && kind <= kText) || kind == kMatrix ?
                     permittedAttrs & ~kAdornment: permittedAttrs, styleSet);
    // 09/02/93 [20620] avoid putting borders on in-line maths when applied to section body

  if (structure->fStyle != 0)
    ApplyStyleChange(this, structure->fStyle, structure->fStyle, styleSet, kind, -1, ruler);

  if (structure->fChanges != 0)
    ApplyStyleChange(this, structure->fChanges, gNullCurrency, styleSet, kind, -1, ruler);

  if (partCurrency != 0)
    DoApplyPartStyles(structure, partCurrency, permittedAttrs, styleSet);
}


// ------------------------------------------------------------------------
void _TFormat::DoApplyPartStyles(TStructure structure,
                               TCurrency partCurrency,
                               Attributes permittedAttrs,
                               TStyleSet styleSet)
// 09/02/93 new method - the difference between table & other DoGetCompositeStyle
{ 
  int part;
  Rect custom;

  structure->GetPartInfo(partCurrency, part, custom);
  if (part > 0)
    ApplyPartStyles(structure, permittedAttrs, styleSet, part, custom);
}

// ------------------------------------------------------------------------
void _TFormat::ApplyPartStyles(TStructure structure,
                               Attributes permittedAttrs,
                               TStyleSet styleSet,
                               int part,
                               Rect &custom)
// 09/02/93 new method - the difference between table & other DoGetCompositeStyle
{ 
  TCurrency styleCurr;
  TCurrency changesCurr;
  TStyleTypes kind = structure->GetKind();    // 18/11/94

  styleCurr = structure->GetPartStyle(part, custom, changesCurr);
  if (styleCurr != 0)
    ApplyStyleChange(this, styleCurr, styleCurr, styleSet, kind, permittedAttrs, TRUE);

  if (changesCurr != 0)
    ApplyStyleChange(this, changesCurr, gNullCurrency, styleSet, kind, permittedAttrs, TRUE);
}

// ------------------------------------------------------------------------
TStyleFormat _TFormat::GetCompositeStyle(TCurrency currency)
{
  TStructure structure = GetStructureReadOnly(currency);
  TStyleFormat style;
  volatile TStyleSet styleSet = NULL;
  FailInfo fi;

  if (structure->HasCompositeStyle())
  {
    /* changed param for math stuff */
    style = TStyleFormat(fMainView->GetPrototype(Curr_fType(structure->fStyle)));

    CatchFailures(&fi);
    styleSet = new _TStyleSet(style); // 2/4/92 09/02/93 [20620] different param
    DoGetCompositeStyle(currency, gNullCurrency, -1, styleSet);
    Success(&fi);

    FreeIfObject(styleSet);
  }
  else
  {
    // TStyleFormat changes;
    // TCurrency styleCurr;
    TStyleFormat clonedStyle;

    style = structure->GetStyleFormat(&clonedStyle);
    if (clonedStyle == NULL)  // not already cloned
      style = TStyleFormat(style->Clone());

    // styleCurr = structure->fChanges;
    // changes = (styleCurr != 0 ? GetStyleReadOnly(styleCurr) : NULL);
    // style = GetStyleReadOnly(structure->fStyle);
    // style = TStyleFormat(style->Clone());
    // if (changes != NULL)
    //   style->ApplyOverride(changes, gNullCurrency, TRUE);
  }
  style->ClearDeletes(); // 9/7/92 dont keep anti-tabs
  
  return(style);

Rescue:
  FreeIfObject(style);
  FreeIfObject(styleSet);
  ContinueFailure(&fi);
}

#ifdef TABLES
// ------------------------------------------------------------------------
static bool TestStyles(TFormat self, TEditedStyles *edits,
                           TStructure theStruct, TSelection selection)
{
  // 17/05/94 now returns true if theStruct has been updated
  // quite what it was supposed to return is a mystery as there is only 1 element
  // in fEditedStyles at the moment

  if ((unsigned int)edits->fAction <= 1 ||     // action == 0 or 1
        (edits->fAction < 0 && edits->fBaseChanges != 0 &&
          (theStruct->fChanges == edits->fBaseChanges ||
             theStruct->fUndoChanges == edits->fBaseChanges)))
  {
    if (edits->fBaseStyle == theStruct->fStyle)
    {
      theStruct->fUndoStyle = theStruct->fStyle;
      theStruct->fStyle = edits->fNewStyle;
      if (edits->fAction != 1 && theStruct->fChanges == edits->fBaseChanges)
      {
        theStruct->fUndoChanges = theStruct->fChanges;
        theStruct->fChanges = 0;
      }
      return TRUE;
    }
    if (edits->fBaseStyle == theStruct->fUndoStyle)
    {
      theStruct->fStyle = theStruct->fUndoStyle;
      if (edits->fAction == 1)
        theStruct->fUndoStyle = 0;
      else
        theStruct->fChanges = theStruct->fUndoChanges;
      return TRUE;
    }
  }
  return FALSE;
// action == 1 included in above test (NB. action is currently always -1 anyway)
//  else if (edits->fAction == 1)
//  {
//    if (edits->fBaseStyle == theStruct->fStyle)
//    {
//      theStruct->fUndoStyle = theStruct->fStyle;
//      theStruct->fStyle = edits->fNewStyle;      
//    }
//    else if (edits->fBaseStyle == theStruct->fUndoStyle)
//    {
//      theStruct->fStyle = theStruct->fUndoStyle;
//      theStruct->fUndoStyle = 0;
//    }
//    else
//      TestStyles_r = FALSE;
//  }
//  return TestStyles_r;
}
#endif

#ifdef TRACE
// ------------------------------------------------------------------------
int _TFormat::BorderCompatibility()
{
  return 0;
}
#endif

// ------------------------------------------------------------------------
CntlAdornment _TFormat::MergeAdornment(TCurrency currency, CntlAdornment adornment,
                                                  TRuleType ruleType)
{
  return adornment;
}

// ------------------------------------------------------------------------
bool _TFormat::DoReformat(TStyleFormat theStyle,
            TChangeTypes &result, Attributes &defined, TCurrency currency, Fixed gapHalf)
{
  Fixed indent;
  Fixed lb, rb, tb, bb;
  Fixed lm, rm;
  Fixed temp;
  TStructure theStruct;
  CntlAdornment adornment;
  TRuleType ruleType;
  TReformatTypes reformatType = fMainView->fSelection->fReformatType;  // 23/09/92
  bool DoReformat_r = FALSE;
  TAlignment *alignPtr;
  TAlignment autoAlign;
  int structKind;

  theStruct = GetStructureReadOnly(currency);        // 20/07/94 from RW
  structKind = theStruct->GetKind();

  defined = theStyle->fDefined;

  if (structKind == kDocument) // 08/12/94 (more) [21620] ignore any spacing set on document
  {
    fSpBefore = fSpAfter = 0;
  }
  else
  {
    if (defined & kHasSpaceBefore)
    {
      defined &= ~kOwnSpaceBefore;  // 25/07/90
      if (/* 8/4/92 (theStyle->fDefined & kOwnSpaceBefore) && */
                                   (fSpBefore != theStyle->fOwnSpaceBefore))
      {
        result = kHeightChg;
        fSpBefore = theStyle->fOwnSpaceBefore;
        SetHasChanged(TRUE);
      }
    }
    else if (/* 8/4/92 (theStyle->fDefined & kSpaceBefore) && */
                                      (fSpBefore != theStyle->fSpaceBefore))
    {
      defined &= ~kSpaceBefore;
      result = kHeightChg;
      fSpBefore = theStyle->fSpaceBefore;
      SetHasChanged(TRUE);
    }

    if (defined & kHasSpaceAfter)
    {
      defined &= ~kOwnSpaceAfter;
      if (/* 8/4/92 (theStyle->fDefined & kOwnSpaceAfter) && */
                                     (fSpAfter != theStyle->fOwnSpaceAfter))
      {
        result = kHeightChg;
        fSpAfter = theStyle->fOwnSpaceAfter;
        SetHasChanged(TRUE);
      }
    }
    else if (/* 8/4/92 (theStyle->fDefined & kSpaceAfter) && */
                                        (fSpAfter != theStyle->fSpaceAfter))
    {
      defined &= ~kSpaceAfter;
      result = kHeightChg;
      fSpAfter = theStyle->fSpaceAfter;
      SetHasChanged(TRUE);
    }
  }

  // theStruct = GetStructureReadOnly(currency);        // 20/07/94 from RW
  // structKind = theStruct->GetKind();
  // 20/07/94 Find text direction - moved from Text & bodies
  {
    TStyleFormat itsStyle = theStyle;

    if ((structKind == kText
#ifdef FN
       || (structKind == kFootnote && (itsStyle =
        GetFormatReadOnly(theStruct->fParent)->GetCompositeStyle(theStruct->fParent), TRUE))
#endif
      ) && (itsStyle->fDefined & kFont) != 0)
    {
      // for footnotes, the style used for text direction is that of the note area
      fFlags = TextFont(PFontStyle(&itsStyle->fTextFont));
    }
    else
      fFlags = 0;
#ifdef FN
    if (itsStyle != theStyle) // 01/09/94 didnt notice GetCompositeStyle returns a new style
      FreeIfObject(itsStyle);
#endif
  }

  if (defined & kHasAlignment)  // 07/06/90 - moved from after adornment checks
  {
    defined &= ~kOwnAlignment;
    alignPtr = &theStyle->fOwnAlignment;
  }
  else
    alignPtr = &theStyle->fAlignment;

  if (*alignPtr == kAlignAuto)
  {
    // set fAlign depending on current styles font
    alignPtr = &autoAlign;
    *alignPtr = (structKind == kText ? fFlags >> 6 : kAlignCentre);
  }
#ifdef TABLES
  else if (*alignPtr == kAlignForce && structKind != kText)  // [26067]
  {
    // set fAlign to kFill
    alignPtr = &autoAlign;
    *alignPtr = kFill;
  }
#endif
  if (*alignPtr != fAlign)
  {
    if ((theStyle->fDefined & kHasAlignment) == 0)
      defined &= ~kAlignment;
    if (result == kNoChg)
      result = kWidthChg;
    DoReformat_r = TRUE;
    SetHasChanged(TRUE);
    fAlign = *alignPtr;
  }

  if (defined & kHasAdornment)
  {
    defined &= ~kOwnAdornment;
    adornment = theStyle->fOwnAdornment;
    ruleType = theStyle->fOwnRuleType;
  }
  else
  {
    defined &= ~kAdornment;
    adornment = theStyle->fAdornment;
    ruleType = theStyle->fRuleType;
  }
  if (theStruct->fParent && (adornment & adnWordStyle) != 0)
    adornment = GetFormatReadOnly(theStruct->fParent)->
                                        MergeAdornment(currency, adornment, ruleType);

  lb = GetBorderWidth(adnLineLeft, adornment, ruleType);
  rb = GetBorderWidth(adnLineRight, adornment, ruleType);
  tb = GetBorderWidth(adnLineTop, adornment, ruleType);
  bb = GetBorderWidth(adnLineBottom, adornment, ruleType);

  // 13/10/96 tests for adorn changes moved before exit in case of reformIndent
  if (tb != GetBorderWidth(adnLineTop, fAdorn, fRules) ||
                                 bb != GetBorderWidth(adnLineBottom, fAdorn, fRules))
  {
    result = kHeightChg;
    DoReformat_r = TRUE;
  }
  if (fAdorn != adornment || *((int *)&fRules) != *((int *)&ruleType))
  {
    SetHasChanged(TRUE);    // 06/06/96 [27032] not marking save style changes with a border
    fAdorn = adornment;
    fRules = ruleType;
  }

  // 13/05/96 [27027] extend to half the gutter width for fixed column width tables
  //lb = Max(gapHalf, lb);
  //rb = Max(gapHalf, rb);

  // 16/07/93 [20977] proper fix which works with in-line objects with borders
  if (theStruct->IsInLine() && gapHalf < 0) // 13/05/96 [27027] indents/margins in manual columns
    indent = lm = rm = 0;
  else
  {
    indent = theStyle->GetIndentation();
    lm = theStyle->GetLeftMargin();
    rm = theStyle->GetRightMargin();
  }

  // [20981] Need to check effects of this!
#ifdef NEVER
  if (fAlign == kAlignCentre || fAlign == kAlignRight || indent == -1)
              // 09/04/92 for indent on para containing maths with borders
    indent = lm;
#endif

  if (gapHalf < 0)     // 15/10/96 [27107]
  {
#ifdef TRUE
    if (indent >= 0)   // 10/12/93 [21145] do not corrupt -1 value for later tests
    {
      // if (lm >= -1)
        indent = Max(indent, fFlags ? rb : lb); // 05/07/94 Experiment!!!
    }
    if (lm >= -1)     // 15/10/96 [27107]
      lm = Max(lb, lm);
#else
    if (indent >= 0)   // 10/12/93 [21145] do not corrupt -1 value for later tests
      indent += (fFlags ? rb : lb);   // 30/06/94 for backwards text
    lm += lb;
#endif
    rm += rb;
  }

  temp = (fFlags ? rm : lm);   // 30/06/94 for backwards text
  if (indent > temp && (theStyle->fDefined & (theStyle->fAutoIndent * kAutoIndent)))
  {
    if (!theStruct->CanIndent(currency))
      indent = temp;
  }
  else if (reformatType == kReformatIndent)    // 24/09/92 new ref type
    return DoReformat_r;   // 13/010/96 FALSE;

  if (lm != fLeftMargin || rm != fRightMargin || indent != fIndentation)
  {
    fLeftMargin = lm;
    fRightMargin = rm;
    fIndentation = indent;
    if (result == kNoChg)
      result = kWidthChg;
    DoReformat_r = TRUE;
  }
  // 13/010/96 following not needed
  // 13/010/96 else if (reformatType == kReformatIndent)    // 24/09/92 new ref type
  // 13/010/96 return FALSE;

  return DoReformat_r;
}


// ------------------------------------------------------------------------
bool _TFormat::PreFormat(TCurrency currency, int &part, Rect &custom,
                         VRect &ruleWidths, TStyleFormat &theStyle,
                         TChangeTypes &result, Fixed gapHalf)
{
  bool  PreFormat_r = TRUE;
  TSelection selection;
  TReformatTypes reformatType;
  int index;
  TLevelInfo levelInfo;
  Attributes defined;

  result = kNoChg;
  selection = fMainView->fSelection;
  reformatType = selection->fReformatType;
  ClearRect(custom);
  if (reformatType == kSelNormal || reformatType == kReformatLine ||
                          reformatType == kReformatBorders || reformatType == kReformatIndent)
  {
    // 13/10/96 not used! hit = selection->FindLevelInfo(currency, index, levelInfo);
    theStyle = GetCompositeStyle(currency);
    if (reformatType == kReformatIndent || reformatType == kReformatBorders ||
                                                  (theStyle->fAdornment & adnWordStyle) != 0)
    {
      if (DoReformat(theStyle, result, defined, currency, gapHalf))
        SetHasChanged(TRUE);
      else if (reformatType == kReformatIndent || reformatType == kReformatBorders)
        PreFormat_r = FALSE;
    }
    part = 0;
  }
// 13/10/96 merged in with case above (for merged adornment)
//  else if (reformatType == kReformatIndent)    // 24/09/92 new ref type
//  {
//    theStyle = GetCompositeStyle(currency);
//    if (DoReformat(theStyle, result, defined, currency, gapHalf))
//    {
//      SetHasChanged(TRUE);
//      part = 0;
//    }
//    else
//      PreFormat_r = FALSE;
//  }
  else if (reformatType == kSelSlow || reformatType == kReformatPaste ||
           reformatType == kReformatAll)
  {
    theStyle = GetCompositeStyle(currency);
    DoReformat(theStyle, result, defined, currency, gapHalf);
    SetHasChanged(TRUE);
    part = 0;
  }
  else if (reformatType == kReformatChgs || reformatType == kReformatMacros)
  {
    theStyle = GetCompositeStyle(currency);
    part = 1;
  }
#ifdef TABLES
  else if (reformatType == kSelSaveAll)
  {
    TCurrency structStyle;
    TStructure theStruct = GetStructureReadOnly(currency);        // 16/05/94 from RW

    structStyle = theStruct->fStyle;
    if (structStyle == selection->fStyleToUpdate
#ifdef MATHS
      && (Curr_fType(structStyle) != kTextStyleStruct ||  // 16/05/94 if !text before symbol
          !theStruct->fDocument->IsMathSymbol(Curr_fRecnum(structStyle)))
#endif
       ) // 22/6/92 - 03/08/92 compiled conditional on MATHS
    {
      if (theStruct->fChanges == selection->fAppliedChgs)
      {
        theStruct = GetStructureReadWrite(currency);        // 16/05/94 RW only if changed
        theStruct->fChanges = 0;
        theStruct->fUndoChanges = selection->fAppliedChgs;
      }
      else if (theStruct->fUndoChanges == selection->fAppliedChgs)
      {
        theStruct = GetStructureReadWrite(currency);        // 16/05/94 RW only if changed
        theStruct->fUndoChanges = 0;
        theStruct->fChanges = selection->fAppliedChgs;
      }
    }
    theStyle = GetCompositeStyle(currency);
    DoReformat(theStyle, result, defined, currency, gapHalf);
    part = 1;
  }
  else if (reformatType == kReformatEdits)        // 25/01/91 new clause
  {
    // 13/05/91    if (MemSpaceIsLow())
    //      selection->fDocument->Purge();
    TStructure theStruct = GetStructureReadOnly(currency);     // 17/05/94 from RW

    if (selection->fEditedStyles->FirstThat(this,
                                   (TestItem)TestStyles, theStruct, selection))
      GetStructureReadWrite(currency);   // 17/05/94 retrospectively mark as RW if updated
    theStyle = GetCompositeStyle(currency);
    DoReformat(theStyle, result, defined, currency, gapHalf);
    part = 1;
  }
#endif
  else
  {
    int hit = selection->FindLevelInfo(currency, index, levelInfo);

    theStyle = GetCompositeStyle(currency);
    PreFormat_r = DoReformat(theStyle, result, defined, currency, gapHalf);
    switch (hit)
    {
    case -1:
      part = 0;
      PreFormat_r = TRUE; // 16/06/91 as may be corrupted above
      if (levelInfo.fKind == kText)
      {
        if (reformatType == kSelStyleChgd)
        {
          SetHasChanged(TRUE);
          part = 1;
        }
      }
      break;

    case 0:
      part = abs(levelInfo.fPart);
      custom = levelInfo.fCustom;
      if (reformatType == kSelStyleChgd)
      {
        SetHasChanged(TRUE);
        PreFormat_r = TRUE;
      }
      else if ((defined & ~(kHasSpaceBefore | kHasSpaceAfter | kHasAdornment |
                                  kHasAlignment | kHasMargins)) == 0)
        part = -1;
      else
        PreFormat_r = TRUE;
      break;

    case 1:
      part = 1;
      PreFormat_r = TRUE; // 16/06/91 as may be corrupted above
      break;
    }
  }
  {
    // 04/03/92 save some space
    CntlAdornment ruleBorders;
    TRuleType ruleType;

    GetBorderInfo(ruleWidths, ruleBorders, ruleType);
  }
//  ruleWidths.top = GetBorderWidth(adnLineTop, fAdorn, fRules);
//  ruleWidths.bottom = GetBorderWidth(adnLineBottom, fAdorn, fRules);
//  ruleWidths.right = GetBorderWidth(adnLineRight, fAdorn, fRules);
//  ruleWidths.left = GetBorderWidth(adnLineLeft, fAdorn, fRules);

  return(PreFormat_r);
}


// ------------------------------------------------------------------------
void _TFormat::SetDepth(long ascent, long descent)
{
  fAscent = ascent;
  fDescent = descent;
}

// ------------------------------------------------------------------------
void _TFormat::GetDepth(long &ascent, long &descent)
{
  ascent = fAscent;
  descent = fDescent;
}

// ------------------------------------------------------------------------
Fixed _TFormat::GetLeftLimit(void)
{
  // if fIndentation is -1 the unsigned test will ensure fLeftMargin returned
  // new for backwards paragraphs where indentation is on the right
  return ((unsigned int)fIndentation > (unsigned int)fLeftMargin || fFlags ?
                         fLeftMargin : fIndentation);
}

// ------------------------------------------------------------------------
Fixed _TFormat::GetRightLimit(void)
{
  // new for backwards paragraphs where indentation is on the right
  return ((unsigned int)fIndentation > (unsigned int)fRightMargin || !fFlags ?
                         fRightMargin : fIndentation);
}

// ------------------------------------------------------------------------
void _TFormat::GetSpacing(int &spBefore, int &spAfter)
{
  spBefore = fSpBefore;
  spAfter = fSpAfter;
}


/* ------------------------------------------------------------------------
void _TFormat::SetSpacing(int spBefore, int spAfter)
{
  fSpBefore = spBefore;
  fSpAfter = spAfter;
}
*/

// ------------------------------------------------------------------------
void _TFormat::GetBorderInfo(VRect &ruleWidths, CntlAdornment &ruleBorders,
                             TRuleType &ruleType)
{
  ruleBorders = fAdorn;
  if (fAdorn != 0)
  { 
    ruleType = fRules;
    ruleWidths.top = GetBorderWidth(adnLineTop, ruleBorders, ruleType);
    ruleWidths.bottom = GetBorderWidth(adnLineBottom, ruleBorders, ruleType);
    ruleWidths.right = GetBorderWidth(adnLineRight, ruleBorders, ruleType);
    ruleWidths.left = GetBorderWidth(adnLineLeft, ruleBorders, ruleType);
  }
  else
    ClearRect(ruleWidths);
}


/* ------------------------------------------------------------------------
void _TFormat::GetBorders(CntlAdornment &borders, TRuleType &ruleType)
{
  borders = fAdorn;
  ruleType = fRules;
}
*/

/* ------------------------------------------------------------------------
void _TFormat::SetBorders(CntlAdornment borders, TRuleType ruleType)
{
  fAdorn = borders;
  fRules = ruleType;
}
*/

// ------------------------------------------------------------------------
void _TFormat::GetViewBorders(TObject startBreak, TObject endBreak,
                              Rect &ruleRect, int &spBefore, int &spAfter)
{
  GetSpacing(spBefore, spAfter);
  if (startBreak != 0) spBefore = 0;
  if (endBreak != 0) spAfter = 0;

  ruleRect.top = FixRound(/* fn1 spBefore + */ GetBorderWidth(adnLineTop, fAdorn, fRules));
  ruleRect.bottom = FixRound(/* fn1 spAfter + */ GetBorderWidth(adnLineBottom, fAdorn, fRules));
  ruleRect.right = FixRound(fRightMargin - GetBorderWidth(adnLineRight, fAdorn, fRules));
  ruleRect.left = FixRound(fLeftMargin - GetBorderWidth(adnLineLeft, fAdorn, fRules));
}


// ------------------------------------------------------------------------
// 21/11/91 added arrowKey
void _TFormat::SendToParent(TCursorNode cursor, int arrowKey, EventInfo &info,
                                                 TStructure structure)
{
  if (structure->fParent == 0
#ifdef FN
      || (structure->GetKind() == kNoteSet &&
            (arrowKey & 0x7e) != 0x2e)  // [20985] allow Ctrl up and down
#endif
     )
  {
#if TALK != 0
// two values which cannot be obtained from keyboard, but used in speech
#define mvShftDown  0x1e
#define mvShftUp    0x1f
    arrowKey &= 0x7f;
    if (arrowKey != (chSpeak & 0x7f) && arrowKey != mvShftUp
#if TALK == 1
         && arrowKey != (0x185 & 0x7f)
#endif
          )
         // 11/03/93 [20700] do not beep at all if speaking with F6
         // 18/04/94 ... or move back by sentance
#endif
#if TALK == 2
    {
      while (Speaking() > 0) {}  // 15/02/93 [20700] stop beep killing last word
#endif
      SysBeep(0);
#if TALK == 2
    }
#endif
  }
  else
  {
    TFormat parent = GetFormatReadOnly(structure->fParent);

    if (arrowKey == chCaseSwap)
      arrowKey = 0x18d;                  // 23/06/92 convert to right
    parent->MoveCursor(cursor->GetPrevious(), arrowKey, info);
  }
}


// ------------------------------------------------------------------------
TStyleFormat _TFormat::GetStyle(TCurrency currency)
{
  TStructure structure = GetStructureReadOnly(currency);

  return TStyleFormat(GetStyleReadOnly(structure->fStyle));
}


// ------------------------------------------------------------------------
int _TFormat::ReAlign(TCurrency currency, int pageNumber, TObject breakObj)
{
  return (fHasChanged ? -1 : 0);          // 03/04/91
}


// ------------------------------------------------------------------------
void _TFormat::ResetCursor(TCursorNode cursor)
{
  TSubView view = fMainView->FindCursorView(cursor);

  if (view == NULL)    // 25/02/92
    return;
  cursor->fIdentifier = view->fIdentifier;
}


// ------------------------------------------------------------------------
TStructure _TFormat::GetStructureReadOnly(TCurrency currency)
{
  return TTextDocument(fMainView->fDocument)->GetStructureReadOnly(currency);
}


// ------------------------------------------------------------------------
TStructure _TFormat::GetStructureReadWrite(TCurrency currency)
{
  return TTextDocument(fMainView->fDocument)->GetStructureReadWrite(currency);
}


// 27/07/92 more envelopes
// ------------------------------------------------------------------------
TFormat _TFormat::GetFormatReadOnly(TCurrency currency)
{
  return fMainView->GetFormat(currency, kReadOnly);
}


// ------------------------------------------------------------------------
TFormat _TFormat::GetFormatReadWrite(TCurrency currency)
{
  return fMainView->GetFormat(currency, kReadWrite);
}

// 04/08/92 another one
// ------------------------------------------------------------------------
TStyleFormat _TFormat::GetStyleReadOnly(TCurrency currency)
{
  return fMainView->GetStyleReadOnly(currency);
}


// ------------------------------------------------------------------------
void _TFormat::DeleteFormatData(int index)
{
  if (index <= fSize)        // 25/01/91
    Delete(index);
}


// ------------------------------------------------------------------------
// 18/07/94 new method commoning up Text & Maths
void _TFormat::LocateCaret(TCursorNode cursor, TSubView view)
{
  if (!gPrinting && fMainView->fCursor && cursor->IsAnchorLast())
                 // 01/05/92 do not do the focus when printing!
                 // 09/04/92 test last in anchor & focus below
  {
    TWindow theWindow = view->GetWindow();

    if (theWindow != NULL && theWindow->Focus()) // 02/09/91 test window in case printing
    {
      // 09/04/92 focus on the window so caret always located even if out of sight
      Point pos;
      int cDepth;

      cDepth = view->GetCaretSize(pos, cursor);
      view->LocalToWindow(pos);      // 09/04/92 compensate for window focus
      theWindow->fWindowRecord.LocateCaret(pos, cDepth);
    }
  }
}

// ------------------------------------------------------------------------
_TNewStructureCmd::_TNewStructureCmd(TTextDocument itsDocument,
                CmdNumber cmd, TCurrency itsStructure) : (cmd, itsDocument)
{
  fStructure = itsStructure;
#ifndef ZERO_OBJ
//  fInsertion = 0;
//  fNewStart = 0;
//  fNewEnd = 0;
  fStyleCurrency = 0;
#endif
// 10/09/90  fMainView = itsView;
//  fViewConstrain = FALSE;   // 17/06/92 stop pointer jumping

#ifdef TABLES
  // 20/06/93 [20949] for structure commands created with style
  if (cmd < 0)
  {
    int aMenu, anItem;

    aMenu = CmdToMenuItem(cmd, anItem);

    if (aMenu == cmStructureStyle)
    {
      bool emph; // unused return value

      fCmdNumber = itsDocument->fLastStructCmdNum;
                           // the actual command set up when side menu built
      fStyleCurrency = itsDocument->GetStyleFromMenu(cmd, emph);
    }
  }
#endif
}


// ------------------------------------------------------------------------
void _TNewStructureCmd::DoCommand(TSelection selection)
{
  // 26/07/90 - rewritten
  TCursorNode anchor, activeEnd;
  TStructure structure;
  TStructTypes structType;
  TStyleTypes styleType;
  TDiscObject obj;
  volatile TCurrency subStructCurr;
  TCurrency subStructStyle;
  FailInfo fi;

  FailSpaceIsLow();  // !!! not the best place !!!
  structure = TTextDocument(fDocument)->GetStructureReadWrite(fStructure);
  // 10/09/90 rest of proc hacked around a lot
// 16/09/92 done generically  selection = TSelection(selection->Clone());
  selection->UpdateScope(NULL);
  selection->GetNodes(fStructure, anchor, activeEnd);
  subStructStyle = fStyleCurrency;    // [20949]
#ifdef MATHS
  if (structure->CommandToStruct(fCmdNumber, styleType, structType))
#else
  if (CmdToStruct(fCmdNumber, styleType, structType))
#endif
  {
    int level;

    subStructCurr = fDocument->NewCurrency(structType, obj);
    level = structure->GetLevel();
    if (level == 1 && styleType == kSection)
      level = 2;
    else if (fCmdNumber == cSection && level > 2)     // 25/04/91
      level--;
#ifdef MATHS
    else if (fCmdNumber == cEquation)     // 18/06/92
      level = 1;
#endif
    if (subStructStyle == 0)      // [20949] use supplied style if available
      subStructStyle = fDocument->GetStyleAtLevel(styleType, level);
  }
  else  // 10/09/90 macros for H/F do not need a structure
  {
    subStructCurr = 0;
    // 18/08/92 pass correct style used for figures created as a result of Remove structure
    if (fCmdNumber == cRemoveStruct && structure->GetKind() == kFigure)
      subStructStyle = fDocument->GetStyleAtLevel0(kFigure);
// [20949]    else
// [20949]      subStructStyle = 0;
  }

  CatchFailures(&fi);  // 10/09/90 error trap added
  structure->NewStructure(fStructure, anchor, activeEnd, subStructCurr,
                            subStructStyle, styleType, this);
// 24/03/92               fCmdNumber, fNewStart, fNewEnd);      // 05/03/91 3 new
#ifdef DRAGDROP
  {
    // 27/07/93 [20997] try to mark up from the thing just created
    TCurrency newAnc = selection->GetAnchorTarget()->fCurrency;

    fDocument->GetStructureReadWrite(newAnc)->MarkToTop(newAnc);
  }
  // structure->MarkToTop(fStructure);
#endif
  Success(&fi);
  selection->fReformatType = kSelSlow;
  fDocument->ResetSelection(selection);
  return;

Rescue:
  fDocument->DeleteCurrency(subStructCurr);
// 16/09/92 done generically:  FreeIfObject(selection);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TNewStructureCmd::DoPostCommand()
{
  TSelection selection;
  TSubView view;
  TTextDocument document = fDocument;
  TMainView mainView = document->ActiveMainView();

  if (fNewEnd /* <= 06/09/92 */ == 0)           // fn1 05/03/91 new test
  {
    if (fNewStart == 0)           // 05/03/91 new test
    {
      selection = document->GetNewSelection();
      selection = TSelection(selection->Clone());
      selection->SetTheCursor(FALSE);
      view = mainView->FindCursorView(selection->GetAnchorOwner());
      if (view != NULL)                 // 24/03/92
        view->SetupMacros();   // 22/02/91
      selection->fEndStructure = FALSE;
      document->ResetSelection(selection);
    }
    else
      document->InitialCursor(mainView, fNewStart, fPosn); // 06/09/92 fNewEnd < 0
  }
  else if (gSelNewStructs)           // 14/07/93 [20982] Select new structures
  {
    document->InitialCursor(mainView, fNewStart, 0);
    document->GetNewSelection()->SelectCurrency(fNewEnd);
  }
  else
    document->InitialSelection(mainView, fNewStart, fNewEnd);  // 24/03/92
  document->GetNewSelection()->fReformatType = kSelNormal; // fn1
  document->ScrollSelectionIntoView();   // 20/03/91
}


// ------------------------------------------------------------------------
// 06/09/90 --- Utilities for calling 'local procs' passed as parameters ---
#ifdef FN
// ------------------------------------------------------------------------
// 11/5/93 added ref
TChangeTypes CallNoteFunc(PStdNoteVars v, TCurrency note, TCurrency ref)
{
  return v->procToDo(v->obj, note, ref, v);
}

// ------------------------------------------------------------------------
bool CallFitNoteProc(PStdFitNoteVars v, TCurrency note, bool &allFits,
                                                    int &noteSpaceAvailable)
{
  return v->procToDo(v->obj, note, allFits, noteSpaceAvailable, v);
}
#endif

// ------------------------------------------------------------------------
void CallNotifyHeading(PStdFitNoteVars v, TCurrency itsHeading,
      TStyleTypes itsTypes, int startPage, bool useRomanNumbers)
{
  v->procForHeading(v->obj, itsHeading, itsTypes, startPage, useRomanNumbers, v);
}

