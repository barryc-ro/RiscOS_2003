/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdlib.h>
#include <stdio.h>

#include "drawfdiag.h"
#include "drawferror.h"
#include "drawfobj.h"
#include "drawftypes.h"
#include "akbd.h"

#include "UClipBrd.h"
#include "UPictEdit.h"
#include "DrawIFace.h"

#if SIDEBAR == 1
#include "alarm.h"
#endif

#define kJPEGFile       (0x0c85)
#define kSpriteFile     (0x0ff9)
#define kFilm           (0x0c2a)
#define kACE            (0x0d6a)
#define IotaSound_LoadTable    0x81ec3
#define IotaSound_ReleaseTable 0x81ec4
#define IotaSound_Play         0x81ec5
#define Euclid_Expand          0x80654
#define ColourTrans_SetGCOL    0x40743
#define ColourTrans_ColourNumberToGCOL 0x4074d
#define OS_ReadModeVariable    0x35
#define OS_Byte                0x06

typedef struct
{ wr_draw_tagtyp    tag;       /* 1 word  */  
  wr_draw_sizetyp   size;      /* 1 word  */   
  wr_draw_bboxtyp   bbox;      /* 4 words */ 
  int            imagex;
  int            imagey;
  int            pixdensityx;
  int            pixdensityy;
  int            matrix[6];
  int            imagelen;
  /* followed by image and padding to word */
} wr_draw_JPEGstrhdr;

#define kLeftArrowCursor  7
#define kRightArrowCursor 8
#define kUpArrowCursor    9
#define kDownArrowCursor  10
#define kMagicCursor 11
#define kSystemCursor 0
#define kOwnWhichAlign 0x80000000

//#define kNoCustomUnitsArray 36
#define kPictStyleStrs 51
#define kSlop 60  /* 12/09/90 - CHANGED FROM 80 TO 60 */
#ifdef TABLES
#define kMouseSlopH (6 * GetVLineThickness())
#define kMouseSlopV (6 * GetHLineThickness())
#else
#define kMouseSlopH (15 * GetVLineThickness())
#define kMouseSlopV (15 * GetHLineThickness())
#endif

#define DOSCALE(x) ((((x) + 50) / 10) / 10)

#ifdef TABLES
static TScale gChosenUnits = 0;
#endif

// extern double dr_scalefactor_x;
// extern double dr_scalefactor_y; /* RSP */
extern TCommand DoCursorCommand(TTextDocument fDocument, int ch, EventInfo &info);

#define FILMSTART (sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr) + sizeof(sprite_header))

// ------------------------------------------------------------------------
static void QueryBox(wr_draw_fileheader *hdrptr, wr_draw_box *box)
/*
 Function    : queryBox
 Purpose     : find the bounding box of the diagram in screen units
 Parameters  : diagram object
               pointer to box structure
 Returns     : void
 Description : Find the bounding box of the file.
*/
{
  box->x0 = wr_draw_drawToScreen(hdrptr->bbox.x0);
  box->y0 = wr_draw_drawToScreen(hdrptr->bbox.y0);
  box->x1 = wr_draw_drawToScreen(hdrptr->bbox.x1);
  box->y1 = wr_draw_drawToScreen(hdrptr->bbox.y1);
}

// ------------------------------------------------------------------------
// ------------ TPictObject methods
// ------------------------------------------------------------------------
_TPictObject::_TPictObject()
{
#ifndef ZERO_OBJ
  fSprite = FALSE;    // 25/05/90 - piccy is a draw file by default
  fDrawDiagStr.length = 0;
#if SIDEBAR == 1
  fContinuous = 0;
  fRateType = 0;
  fRate = 0;
  fVSyncs = 0;
  fText[0] = 0;
#endif
#endif
  // fDrawDiagStr.data = ptr to the draw diagram data
  if ((fDrawDiagStr.data = (char *)NewEmptyHandle()) == NULL)
  {
    _TObject::Free();
    FailOutOfMem();
  }
}


// ------------------------------------------------------------------------
void _TPictObject::Free()
{
  DisposIfHandle(Handle(fDrawDiagStr.data)); // dump draw data block
  _TObject::Free();
}


// ------------------------------------------------------------------------
TObject _TPictObject::ShallowClone()
{
  TPictObject copy = TPictObject(_TDiscObject::ShallowClone());
  int  myArraySize = GetHandleSize(Handle(fDrawDiagStr.data));

  if (copy != NULL)
  {
    register Ptr picPtr = NewHandle(myArraySize);
    if ((copy->fDrawDiagStr.data = (char *)picPtr) == NULL)
    {
      copy->_TPictObject::Free();
      copy = NULL;
    }
    else
      memcpy(picPtr, fDrawDiagStr.data, myArraySize);
  }

  return copy;
}


// ------------------------------------------------------------------------
void _TPictObject::DoRead(int aRefNum, long remainder, int version)
{
  long count;

  //  remainder -= (sizeof(_TDiscObject) + sizeof(char *));
  FRead(aRefNum, /* remainder */ 8, &fDrawDiagStr.length);
  if ((count = fDrawDiagStr.length) != 0)
  {
    SetPermHandleSize(&fDrawDiagStr.data, count);
    FRead(aRefNum, count, fDrawDiagStr.data); // read the diag
  }
#if SIDEBAR == 1
  if (version == 2)
    FRead(aRefNum, kTalkTextLength + 4, &fContinuous); // read the TalkWrite data
#endif
}

// ------------------------------------------------------------------------
void _TPictObject::DoWrite(int aRefNum, long remainder)
{
  long count;

  remainder -= (sizeof(_TDiscObject) + sizeof(char *)
#if SIDEBAR == 1
                                                      + kTalkTextLength + 4
#endif
               );
  FWrite(aRefNum, remainder, &fDrawDiagStr.length);
  if ((count = fDrawDiagStr.length) != 0)
    FWrite(aRefNum, count, fDrawDiagStr.data); // write the diag
#if SIDEBAR == 1
  FWrite(aRefNum, kTalkTextLength + 4, &fContinuous); // write the TalkWrite data
#endif
}

// ------------------------------------------------------------------------
long _TPictObject::DoNeedDiskSpace(long dataForkBytes)
{
  return _TDiscObject::DoNeedDiskSpace(fDrawDiagStr.length - sizeof(char *) +
                               dataForkBytes);
}

#ifdef FILMS
// ------------------------------------------------------------------------
char *_TPictObject::FindFilmChunk(int chunkType)
{
  char *start = fDrawDiagStr.data;
  char *end = start + fDrawDiagStr.length;

  start += FILMSTART;
  do
  {
    if (*(int *)start == chunkType)
      return start + 8;
    start += *((int *)(start + 4));
  }
  while (start < end);
  return NULL;
}
#endif

// ------------------------------------------------------------------------
static int ComputeScaleFactor(Rect &picFrame, Rect &dstRect, VHSelect vhs)
{
  int orig = Max(LengthRect(picFrame, vhs), 10);    // 10/01/94 avoid zero divide
  int dest = LengthRect(dstRect, vhs);
  int num = dest / orig;
  int rem = dest % orig;

  return (num << 16) + (rem << 16) / orig;
}

#if SIDEBAR == 1
extern bool RenderDrawFile(wr_draw_diag *diag, int *matr, wr_draw_box *clipBox, int avoidSWI);
#define NUMPATHELS 15
#define CLEARPATHSIZE ((4 * NUMPATHELS) * 2 + 4 + sizeof(wr_draw_pathstrhdr))

void FillARect(int *path, wr_draw_box *bbox)
{
  path[0] = 2;
  path[3] = 8;
  path[6] = 8;
  path[9] = 8;
  path[12] = 8;
  path[1] = bbox->x0;
  path[4] = bbox->x0;
  path[13] = bbox->x0;
  path[2] = bbox->y0;
  path[11] = bbox->y0;
  path[14] = bbox->y0;
  path[7] = bbox->x1;
  path[10] = bbox->x1;
  path[5] = bbox->y1;
  path[8] = bbox->y1;
}
#else
extern bool RenderDrawFile(wr_draw_diag *diag, int *matr, wr_draw_box *clipBox);
#endif

// ------------------------------------------------------------------------
#if SIDEBAR == 1
static void DrawPicture(wr_draw_diag *diag, Rect &dstRect, Rect &clipToRect, int frame)
#else
static void DrawPicture(wr_draw_diag *diag, Rect &dstRect, Rect &clipToRect)
#endif
{
  // If an error occurs, we cannot spit out a msg
  // as that will cause a redraw which causes a draw etc...
  if (VisibleRect(clipToRect))
  {
    int orgx;
    int orgy;
    Rect clipRect;
    Rect picFrame;
    wr_draw_box aBox;
    Point edge;
    int matr[6];
#if SIDEBAR == 1
    wr_draw_diag frameDiag;
    int avoidModule = FALSE;

    frameDiag.data = NULL;
#endif

    thePort->SetVDUClip(clipToRect);     // 15/05/90 - set graphics window
    QueryBox((wr_draw_fileheader *)diag->data, &aBox);  // get frame in scrn units
    BoxToQDRect(*((wr_wimp_box *)&aBox), picFrame, 0); // get in QD units

    SetPt(edge, dstRect.left, dstRect.bottom);
    thePort->LocalToGlobal(edge);
    QDPttoOS(edge, orgx, orgy, ScreenHeight());

    // first calculate the scale factor. The dstRect passed in is the size we want
    // the picture to end up, so scale picFrame up/down so that it fits into dstRect
    matr[0] = ComputeScaleFactor(picFrame, dstRect, h);
    matr[3] = ComputeScaleFactor(picFrame, dstRect, v);
    // fiddle the origin, compensating for draw attempt to
    // move bottom left to position in draw file
    matr[4] = orgx * 256 - ((aBox.x0 * (matr[0] >> 2)) >> 6);
    matr[5] = orgy * 256 - ((aBox.y0 * (matr[3] >> 2)) >> 6);
    matr[1] = matr[2] = 0;

    GetClip(clipRect);
    thePort->LocalToBox(clipRect, *((wr_wimp_box *)&aBox));

#define OS_SpriteOp 0x2e
#if SIDEBAR == 1
    if (frame >= 0)
    {
      sprite_header *currentSprite = (sprite_header *)
                 ((char *)diag->data + sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr));
      int currentSpriteSize;

      for(; frame > 0; frame--)
        currentSprite = (sprite_header *)((char *)currentSprite + currentSprite->next);
                                              // get position of current sprite in buffer
      currentSpriteSize = currentSprite->next;
      frameDiag.length = currentSpriteSize +
                                    sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr);

      frameDiag.data = (char *)NewHandle(frameDiag.length + CLEARPATHSIZE);
      if (frameDiag.data != NULL)
      {
        // build up a temporary draw file containing just sprite number 'fCurrentFrame'
        wr_os_regset r, r1;
        Point spriteSize;
        wr_draw_spristrhdr *sprihdr;
        int *path;
        wr_draw_box aBoxCopy = aBox;
        wr_draw_box clearBox;
        int newSize;

        r1.r[1] = 0xff;  // ?? not using sprite area
        r1.r[2] = (int)currentSprite;
        ReadSpriteSize(&r1, spriteSize);

        memcpy(frameDiag.data, diag->data, sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr));
        sprihdr = (wr_draw_spristrhdr *)(frameDiag.data + sizeof(wr_draw_fileheader));
        sprihdr->size = sizeof(wr_draw_spristrhdr) + currentSpriteSize;
        clearBox = sprihdr->bbox;
        newSize = wr_draw_screenToDraw(spriteSize.h);
        sprihdr->bbox.x0 = (sprihdr->bbox.x1 - newSize) / 2;
        sprihdr->bbox.x1 = sprihdr->bbox.x0 + newSize;
                                       // multiply sprite by its defined mode eig
        newSize = wr_draw_screenToDraw(spriteSize.v);
        sprihdr->bbox.y0 = (sprihdr->bbox.y1 - newSize) / 2;
        sprihdr->bbox.y1 = sprihdr->bbox.y0 + newSize;

        diag = &frameDiag;
        if (r1.r[5] == 1)     // sprite has a mask
        {
          // clear the background area where mask will prevent redrawing
          sprite_header *tempSprite = (sprite_header *)(sprihdr + 1);

          r.r[0] = 0x23d;                   // switch output to sprite
          r.r[1] = 0xff;                    // ?? not using sprite area
          r.r[2] = (int)tempSprite;         // where sprite copy is
          r.r[3] = 0;
          // build sprite with palette removed
          memcpy(tempSprite, currentSprite, 44); // copy the sprite start
          tempSprite->mask -= (tempSprite->image - 44);
          tempSprite->image = 44;
          memset((char *)tempSprite + 44, 255, currentSpriteSize - 44);
                                               // set whole sprite to white and all mask on
          FailOSErr(wr_os_swix(OS_SpriteOp, &r)); // switch output for following write to mask

          // clear pixels corresponding to image
          //bbc_vdu(18);bbc_vdu(8);bbc_vdu(128);// use mask and set b/g colour
          r1.r[0] = 512 + 48;                   // put mask to ...
          FailOSErr(wr_os_swix(OS_SpriteOp, &r1)); // clear pixels corresponding to image
          FailOSErr(wr_os_swix(OS_SpriteOp, &r));  // switch back to screen!
          avoidModule = TRUE;                // so same rounding applied to mask and image
          RenderDrawFile(diag, matr, &aBoxCopy, TRUE); // plot b/g white avoiding draw mod
        }
        if (memcmp(&clearBox, &sprihdr->bbox, sizeof(wr_draw_box)) != 0 && !gPrinting)
        {
          // build up filled draw path to clear any area between sprite and largest sprite
          wr_draw_pathstrhdr *clearHdr = (wr_draw_pathstrhdr *)sprihdr;

          sprihdr = (wr_draw_spristrhdr *)
             memmove((char *)sprihdr + CLEARPATHSIZE, sprihdr, sizeof(wr_draw_spristrhdr));
          clearHdr->bbox = clearBox;
          clearHdr->tag = wr_draw_OBJPATH;        /* 1 word  */
          clearHdr->size = CLEARPATHSIZE;       /* 1 word  */
          clearHdr->fillcolour = 0xffffff00; /* white fill */
          clearHdr->pathcolour = 0xffffff00; /* and outline  */
          clearHdr->pathwidth = 2;
          *((int *)&clearHdr->pathstyle) = 0x40;  /* even-odd */
          path = (int *)(clearHdr + 1);
          FillARect(path, &clearHdr->bbox);
          FillARect(path + NUMPATHELS, &sprihdr->bbox);
          path[NUMPATHELS * 2] = 0;
          frameDiag.length += CLEARPATHSIZE;
        }
        memcpy(sprihdr + 1, currentSprite, currentSpriteSize); // copy sprite to 'diag'
      }
    }
    if (!RenderDrawFile(diag, matr, &aBox, avoidModule))
#else
    if (!RenderDrawFile(diag, matr, &aBox))
#endif
    {
      // Do not put up alert, it may cause redraw failure. Anyway should not
      // happen if the validate diag has been done on loading?
#ifdef TRACE
      SysBeep(0);
#endif
    }
#if SIDEBAR == 1
    DisposIfHandle(frameDiag.data);
#endif
    thePort->RestoreVDUClip(); // 15/05/90 - restore graphics window
    ClearCurrentColour();      // 14/04/92
  }
}


// ------------------------------------------------------------------------
static int CountFrames(TPictObject pict)
{
  if (pict->fSprite == 1)
  {
    char *p;
    char *q;
    int  frames = 0;

    p = pict->fDrawDiagStr.data;
    q = p + pict->fDrawDiagStr.length;
    p += sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr);

    for (; p < q; p += ((sprite_header *)p)->next)
      frames++;
    return frames;
  }
#if defined WORD7 && defined FILMS
  if (pict->fSprite >= 9)
    return 0;
#endif
#ifdef FILMS
  if (pict->fSprite >= 7)
    return 100;
#endif
  return 0;
}

// ------------------------------------------------------------------------
void _TPictStructure::IPictStructure(TCurrency itsParent, TCurrency itsStyle, TStyleTypes picKind)
{
  fPicKind = picKind;   // 12/09/90
  IStructure(itsParent, itsStyle);
//  fPicKind = picKind;   // 12/09/90
}


// ------------------------------------------------------------------------
_TPictStructure::_TPictStructure(TDocument itsDocument, TStyleTypes picKind)
                              : (itsDocument, 0)
{
#ifndef ZERO_OBJ
  fPicture = 0;
  fUndoPicture = 0;
  fBaseLine = 0;
  fUndoInsert = gNullCurrency;   // 12/09/90
  fLinkByDel = FALSE;            // 23/01/91
#endif
  fPicKind = picKind;   // 12/09/90
}

// ------------------------------------------------------------------------
long _TPictStructure::DoNeedDiskSpace(long dataForkBytes)
{
  return _TStructure::DoNeedDiskSpace(dataForkBytes);
}

// ------------------------------------------------------------------------
void _TPictStructure::DoRead(int aRefNum, long remainder, int version)
{
  _TStructure::DoRead(aRefNum, remainder, version);    // the inherited read
  fUndoPicture = fPicture;   // 21/02/92
}

// ------------------------------------------------------------------------
void _TPictStructure::DoWrite(int aRefNum, long remainder)
{
  _TStructure::DoWrite(aRefNum, remainder);
}

// ------------------------------------------------------------------------
#ifdef NEVER
void _TPictStructure::DoSetupMenus(TCurrency currency, TCursorNode anchor, TCursorNode activeEnd)
// new 13/01/92
{
  _TStructure::DoSetupMenus(currency, anchor, activeEnd);
}
#endif

// ------------------------------------------------------------------------
TStyleTypes _TPictStructure::GetKind()
{
  return fPicKind;    // 12/09/90
}


// ------------------------------------------------------------------------
//bool _TPictStructure::IsInLine()
//{
//#ifdef MATHS
//  return (fParent.cgf_31.fType <= kMathStruct);  // 22/04/93 missed this one!
//#else
//  return (fParent.cgf_31.fType == kTextStruct);
//#endif
//}


// ------------------------------------------------------------------------
TPictObject _TPictStructure::GetPicture()
{
  return (fPicture == 0 ? NULL : TPictObject(fDocument->GetPicture(fPicture)));
}

#ifdef TRACE
// ------------------------------------------------------------------------
bool _TPictStructure::CanType()
{
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
bool _TPictStructure::IsEmpty()
{
  return fPicture == 0; // 05/03/91 from F
}


// ------------------------------------------------------------------------
bool _TPictStructure::LinkStructure(TCursorNode anchor, TCursorNode activeEnd, bool cmdDone)
{
  fLinkedByDel = TRUE;
  return FALSE;
}


// ------------------------------------------------------------------------
bool _TPictStructure::HandleKeypress(int ch, TCursorNode cursorNode)
{
  if (ch == chBackspace || ch == chFwdDelete)     // 23/05/91 || added
  {
    TStructure myParent = GetStructureReadWrite(fParent);

// 21/02/92    fUndoPicture = fPicture;
// 21/02/92    fPicture = 0;
    return myParent->HandleKeypress(ch == chBackspace ? chLeft : chRight,
               cursorNode->GetPrevious());       // 23/05/91 fm chClear
  }
  SysBeep(0);
  return FALSE;   // from TRUE ???
}


// ------------------------------------------------------------------------
void _TPictStructure::InsertSubStructure(int isPaste,
                                TTextDocument sourceDoc, TCurrency parent,
                                TCurrency &currency, long &before)
{
  if (Curr_fType(currency) == kPictStruct)  // 12/09/90 new test
  {
    TPictStructure struc;

    struc = TPictStructure(GetStructureReadWrite(currency));
    fUndoPicture = fPicture;
    fPicture = struc->fPicture;
    fDocument->DeleteCurrency(currency);
    currency = 0;
    SetPastePosition(parent, 0);             // 10/09/92
  }
  else
    fUndoInsert = currency;                  // 12/09/90 new else clause
}


// ------------------------------------------------------------------------
void _TPictStructure::InitNewStructure(TCurrency parent, TCurrency currency,
        TCurrency newStyle, TStyleTypes styleType, bool initialise, TStructureCmd command)
{
  if (newStyle == 0)        // 12/09/90 new test
    newStyle = fDocument->GetStyleAtLevel0(kPict);

  IPictStructure(parent, newStyle, styleType);// 12/09/90 new par
}


// ------------------------------------------------------------------------
void _TPictStructure::ExtendCursor(TCursorNode cursorNode,
            TCurrency currency, bool fromRight, bool toBottom, bool keep)
{
  TCursorNode newNode;
  TCursor cursor;

  newNode = new _TCursorNode(currency, kNewCursor, gZeroVPt);
  cursor = cursorNode->fCursor;
  cursor->AddTarget(newNode);
}


// ------------------------------------------------------------------------
#ifdef DRAGDROP
void _TPictStructure::CopyToClipboard(TCurrency currency, TCursorNode anchor, 
        TCursorNode activeEnd, TCursorNode dropNode, TTextDocument clipDocument, 
        TCurrency clipParent, long pos)
#else
void _TPictStructure::CopyToClipboard(TCurrency currency, TCursorNode anchor, TCursorNode activeEnd, TTextDocument clipDocument, TCurrency clipParent, long pos)
#endif
{
  // volatile
  TPictStructure structure;
  //  volatile
  TPictObject pict;
  TCurrency clipCurrency;
  FailInfo fi;

  structure = TPictStructure(Clone());

  CatchFailures(&fi);

  structure->fPicture = (fPicture == 0 ? 0 : clipDocument->AddNewPictureObject(pict));
  structure->fUndoPicture = structure->fPicture;    // 21/02/92

  if (fPicture != 0)
  {
    pict = TPictObject(GetPicture()->Clone()); // clones pic too
    clipDocument->ReplacePicture(structure->fPicture, pict); // hopefully does not fail
  }

  clipCurrency = currency;
  clipDocument->AddStructure(0, structure, pos, clipParent, fDocument, clipCurrency);
  Success(&fi);
  return;

// +++++++++++++++++++
Rescue:
  FreeIfObject(structure);
// 28/05/92 What is this for??? Record handler frees it:  FreeIfObject(pict);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
TStructure _TPictStructure::CloneForPaste(TCurrency currency, TTextDocument targetDoc)
{
  TPictStructure structure;
//  volatile TPictObject pict;
  TPictObject targetPict;
  FailInfo fi;

  structure = TPictStructure(Clone());

  CatchFailures(&fi);

  structure->fPicture = (fPicture == 0 ? 0 : targetDoc->AddNewPictureObject(targetPict));
  structure->fUndoPicture = structure->fPicture;  // 21/02/92

  if (fPicture != 0)
  {
    TPictObject myPict = GetPicture();
                     // 12/10/94 TPictObject(fDocument->GetPicture(fPicture));

    // 27/10/92 avoid cloning if just dropped a draw file/sprite into doc
    if (gClipView == NULL || gClipView->fDocument != fDocument)
    {
      // selfs document is not the Cut/Copy clip document, so no need to clone
      // The picture will be in store so GetPicture should not fail & can safely alter it
      wr_draw_diag tempDiag = myPict->fDrawDiagStr;
      
      myPict->fDrawDiagStr = targetPict->fDrawDiagStr;  // will contain an empty handle
      targetPict->fDrawDiagStr = tempDiag;
#if SIDEBAR == 1
      memcpy(&targetPict->fSprite, &myPict->fSprite, kTalkTextLength + 8); // TalkWrite data
#else
      targetPict->fSprite = myPict->fSprite;
#endif
    }
    else
    {
      TPictObject pict;

      pict = TPictObject(myPict->Clone());
      targetDoc->ReplacePicture(structure->fPicture, pict);
    }
  }
  Success(&fi);
  return(structure);

// +++++++++++++++++++
Rescue:
  FreeIfObject(structure);
  // 27/10/92 looks unnecessary:  FreeIfObject(pict);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TPictStructure::GivePastePosition(TCursorNode cursor,
                                        long &startPos, long &endPos)
{
  startPos = 0;
  endPos = -1;
}


// ------------------------------------------------------------------------
bool _TPictStructure::InSecondHalf(TCursorNode cursor)
{
  return TRUE;
}


// ------------------------------------------------------------------------
int _TPictStructure::CanDoPaste(TCurrency currency,
                     TStructure dataToPaste, int numOfItems)
{
  return (Curr_fType(currency) == kPictStruct &&
             fPicKind == kPict                             // 15/04/91
             /* 05/10/93 && IsShown(myCurrency, gNullCurrency) */);             // 10/05/91
}


// ------------------------------------------------------------------------
#ifdef MATHS
bool _TPictStructure::CanPasteInLine()
// new 11/01/92
{
  return TRUE;
}
#endif


// ------------------------------------------------------------------------
void _TPictStructure::GetSelectionKind(TCursorNode anchor, TCursorNode activeEnd, TStyleTypes &kind, int &part, Rect &custom)
{
  part = -1;
  kind = fPicKind;        // fGetKind();
  ClearRect(custom);
}

#ifdef TRACE
// -----------------------------------------------------------------------
bool _TPictStructure::HasCompositeStyle()
{
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
bool _TPictStructure::AllSelected(TCurrency currency, TCursorNode anchor, TCursorNode activeEnd)
{
  return (/* fPicKind == kPict &&  08/02/91  */
          !fLinkedByDel &&     // 23/01/91 fLinkedByDel
          (anchor == NULL || activeEnd == NULL));     // 28/11/90 null tests
}


// ------------------------------------------------------------------------
bool _TPictStructure::Clear(TCursorNode anchor, TCursorNode activeEnd,
                            TClearTypes clearType, /* return bool &gone,*/ int &ch)
{
  fUndoPicture = fPicture;
  fPicture = 0;
  // gone = (clearType != kClearedByPaste) || IsInLine();
  if (clearType != kClearedByPaste)  // 02/03/94 [21428]
    return TRUE;
  return IsInLine();
}


// ------------------------------------------------------------------------
void _TPictStructure::ToggleState(TCurrency currency, TCursorNode anchor, TCursorNode activeEnd, TCommand command)
{
  int temp = fPicture;

  fPicture = fUndoPicture;
  fUndoPicture = temp;

  // 14/08/92 stop body edit disposing of undoinsert on commit after Redo
  if (fUndoInsert && !command->fCmdDone)
    GetStructureReadWrite(fUndoInsert)->fParent = currency;
}


// ------------------------------------------------------------------------
void _TPictStructure::Commit(TCurrency currency, TCursorNode anchor,
                  TCursorNode activeEnd, TCommand command, bool freeParts)
{
  if (fUndoPicture != 0 && fUndoPicture != fPicture)  // 21/02/92
    fDocument->DeletePicture(fUndoPicture);
  if (freeParts)      // 05/03/91 test added
  {
    if (fPicture != 0)
      fDocument->DeletePicture(fPicture);
    fPicture = 0;                     // 21/02/92
// 21/02/92    if (fUndoPicture != 0) 
// 21/02/92      fDocument->DeletePicture(fUndoPicture);
  }
// 21/02/92  else if (fUndoPicture != 0 && fUndoPicture != fPicture)  // 21/02/92
// 21/02/92    fDocument->DeletePicture(fUndoPicture);

  // 19/02/92 delete fUndoInsert if necessary
  if (fUndoInsert != 0 && command->fCmdDone)
  {
    TStructure aStruct = TStructure(GetStructureReadWrite(fUndoInsert));
    aStruct->Commit(fUndoInsert, NULL, NULL, command, TRUE);
    fDocument->DeleteCurrency(fUndoInsert);
  }
  fUndoInsert = 0;

  fUndoPicture = fPicture;                               // 21/02/92
  fLinkedByDel = FALSE;                                  // 23/01/91
}

#if defined TRACE && defined SPELL
// ------------------------------------------------------------------------
void _TPictStructure::DoSpellCheck(TCurrency currency, TCursorNode anchor,
                               TCursorNode activeEnd)
{
}
#endif

// ------------------------------------------------------------------------
void _TPictStructure::WriteAlienData(TCurrency currency, TCursorNode anchor,
          TCursorNode activeEnd, TSender sender, TStructure parent,
          TCursorNode parentAnchor, TCursorNode parentActiveEnd, long pos)
{
  if (anchor != NULL && activeEnd != NULL)
  // if not, the selection cannot be the picture alone, so ignore call
  {
    TPictObject pict = GetPicture();

#ifdef TRACE
      Assert(anchor, 191);
#endif
    if (pict != NULL)    // should do: && sender->GetFileType() == ???
    {
      int picFileType = sender->GetFileType();

      if (picFileType == kSpriteFile)    // 27/10/92 Sprite File saving
      {
        int control[3];

        control[0] = CountFrames(pict);  // number of sprites, 17/01/95 now computed
        control[1] = 16; // we have lost any extension area
        control[2] = 16 + pict->fDrawDiagStr.length -
            sizeof(wr_draw_fileheader) - sizeof(wr_draw_spristrhdr); // pointer after sprite

        sender->SendString((char *)control, 12);
        sender->SendString(pict->fDrawDiagStr.data + sizeof(wr_draw_fileheader) +
                        sizeof(wr_draw_spristrhdr), control[2] - 16);
      }
      else if (picFileType == kJPEGFile)
      {
        sender->SendString(pict->fDrawDiagStr.data + sizeof(wr_draw_fileheader) +
                                                               sizeof(wr_draw_JPEGstrhdr),
          ((wr_draw_JPEGstrhdr *)(pict->fDrawDiagStr.data + sizeof(wr_draw_fileheader)))->imagelen);
      }
#ifdef FILMS
      else if (picFileType == kFilm)
      {
        sender->SendString(pict->fDrawDiagStr.data + sizeof(wr_draw_fileheader) +
                      sizeof(wr_draw_spristrhdr) + sizeof(sprite_header),
          pict->fDrawDiagStr.length - (sizeof(wr_draw_fileheader) +
                      sizeof(wr_draw_spristrhdr) + sizeof(sprite_header)));
      }
      else if (picFileType == kACE)
      {
        char *acef = (char *)pict->FindFilmChunk('FECA');  // ACEF

        if (acef)
          sender->SendString(acef, *((int *)(acef - 4)) - 8);
      }
#endif
      else
        sender->SendString(pict->fDrawDiagStr.data, pict->fDrawDiagStr.length);
    }
  }
}


// ------------------------------------------------------------------------
void _TPictStructure::DoNeedAlienSpace(TCurrency currency,
  TCursorNode anchor, TCursorNode activeEnd, int fileType, int *bytesNeeded)
{
  if (anchor != NULL && activeEnd != NULL)
  // if not, the selection cannot be the picture alone, so ignore call
  {
    TPictObject pict = GetPicture();

    anchor->fMousePt.h = 0;
    if (pict != NULL)
    {
      *bytesNeeded += pict->fDrawDiagStr.length;
      if (fileType == kSpriteFile)    // 27/10/92 Sprite File saving
        *bytesNeeded += 12 - sizeof(wr_draw_fileheader) - sizeof(wr_draw_spristrhdr);
      else if (fileType == kJPEGFile)
        *bytesNeeded -= (sizeof(wr_draw_fileheader) + sizeof(wr_draw_JPEGstrhdr));
                         // may be 1 to 3 bytes too big for JPEGs because of round-up bytes
                         // but avoids having to load the image to get the exact size;
#ifdef FILMS
      else if (fileType == kFilm)
        *bytesNeeded -=
               (sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr) + sizeof(sprite_header));
      else if (fileType == kACE)
        *bytesNeeded -=
            (sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr) + sizeof(sprite_header) + 8);
        // *bytesNeeded +=
        //     *((int *)(pict->FindFilmChunk('FECA') - 4)) - 8 - pict->fDrawDiagStr.length;
#endif
    }
  }
}


#ifdef DRAGDROP
// ------------------------------------------------------------------------
int _TPictStructure::WhatsSelected(TCurrency currency,
                                     TCursorNode anchor, TCursorNode activeEnd)
{
  TPictObject pict = GetPicture();

  if (pict != NULL)
     return kDrawSelected << pict->fSprite;  // Draw, Sprite, JPEG for fSprite == 0, 1 and 2
     // (pict->fSprite ? (pict->fSprite == 1 ? kSpriteSelected : kJPEGSelected) : kDrawSelected);
  return kNullSelected;
}
#endif

#if SIDEBAR == 1
// ------------------------------------------------------------------------
static int GetTextToSpeak(TPictStructure self, char *buffer)
{
  TPictObject pict = self->GetPicture();

  return strlen(strcpy(buffer, pict->fText));
}

// ------------------------------------------------------------------------
int _TPictStructure::AddTextToSpeak(TCurrency currency, char *buffer)
{
  if (!gPrinting)
    if (fDocument->ActiveMainView()->AnimateView(currency) == NULL)
      return 0;
  return GetTextToSpeak(this, buffer);
}
#endif

#if TALK == 1 && SIDEBAR == 1
// ------------------------------------------------------------------------
int _TPictStructure::GetWordAtCaret(TCursorNode anchor, TCursorNode activeEnd,
                                                                 wr_wimp_msgstr *msg)
{
  int txtLen = GetTextToSpeak(this, (char *)&msg->data.words[3]);

  if (msg->data.words[0] > 0)
    UpdateCaretByWord(anchor, msg);
  msg->data.words[1] |= 0x200;     // 09/01/96 avoid moving caret
  return txtLen;
}
#endif

// ------------------------------------------------------------------------
_TPictFormat::_TPictFormat(TMainView itsView) : (itsView, 0)
{
#ifndef ZERO_OBJ
  fPicture = 0;
  ClearRect(fPicRect);
  fAlignedByUser = FALSE;
//  fOffset = 0;
  fWidth = 0;
  fSetWidth = 0;
//  fResult = kNoChg;
  fScaleFactor = gZeroPt;
  ClearRect(fCropRect);
  fUserAlign = gZeroPt;
#endif
  fInline = TRUE;
  fPicKind = kPict;
  fPicRect.bottom = 128;  // 24/10/94 [23011] from 0, initial depth for white space
}


/* ------------------------------------------------------------------------
// 20/02/94 will not now be called as picts will always be leaf nodes
TCursorNode _TPictFormat::GetTheCursor(TView view, VPoint &mousePoint, TCurrency child)
{
  return(TPictView(view)->ClickOnce(mousePoint));
}
*/

// ------------------------------------------------------------------------
void _TPictFormat::ResetCursor(TCursorNode cursor)
{
  // added 20/11/90
  cursor->fIdentifier = fMainView->FindCursorView(cursor)->fIdentifier;
}


// ------------------------------------------------------------------------
void _TPictFormat::AlignPicture(Rect &changedRect1, Rect &changedRect2,
                    Rect &picRect, Rect &newPicFrame, Rect &oldPicFrame)
{
  if ((LengthRect(changedRect1, h) != LengthRect(changedRect2, h)))
  {
    OffsetRect(picRect, oldPicFrame.left - newPicFrame.left, 0);
  }
  if (LengthRect(changedRect1, v) != LengthRect(changedRect2, v))
  {
    OffsetRect(picRect, 0, oldPicFrame.top - newPicFrame.top);
  }
}


// ------------------------------------------------------------------------
bool _TPictFormat::ContainsCursor(TCurrency currency,
                       TObject startBreak, TObject endBreak, TCursorNode Cursor)
{
  return TRUE;
}


// ------------------------------------------------------------------------
void _TPictFormat::MoveCursor(TCursorNode cursor, int arrowKey, EventInfo &info)
{
//  TTextDocument document = TTextDocument(fMainView->fDocument);
  TStructure structure = GetStructureReadOnly(cursor->fCurrency);

  SendToParent(cursor, arrowKey, info, structure); // 21/11/91
  info.affectsMenus = TRUE;
}

// ------------------------------------------------------------------------
static int DoScale(int side, int fact)
{
  return FromFixed(side * fact * 10 + 500);
}

// ------------------------------------------------------------------------
int _TPictFormat::GetNewSide(VHSelect vhs)
{
  int newSide = DoScale(LengthRect(fPicRect, vhs), fScaleFactor.vh[vhs]);

  return newSide - (((int *)&fCropRect)[vhs + 2] + ((int *)&fCropRect)[vhs]);
}

// ------------------------------------------------------------------------
int _TPictFormat::BorderCompatibility()
{
  return kPictStruct;
}

// ------------------------------------------------------------------------
TChangeTypes _TPictFormat::Reformat(TCurrency currency, TCursorNode anchor,
       TCursorNode activeEnd, int fitToWidth, Fixed gapHalf, PStdNoteVars origProc)
{
  int part;
  Rect custom;
  TStyleFormat itsPictStyle = NULL;
  VRect oldRuleWidths;
  VRect ruleWidths;
  CntlAdornment ruleBorders;
  TRuleType ruleType;
  TChangeTypes result;
  TPictStructure pictStructure;
  TPictObject picture;
  long asc, desc;
  int lm, rm;
  TAlignment alignment;
  int newWidth;
  int newDepth;
  Point oldAlign;

  pictStructure = TPictStructure(GetStructureReadWrite(currency));

  fPicKind = pictStructure->fPicKind;       // 02/01/91 moved out
  // 12/09/90 new clause for non pictures
  if (fPicKind != kPict && fPicKind != kWhiteSpace)
  {
    SetHasChanged(TRUE);
    if (fDescent == 0)
    {
      fAscent = -1;
      result = kHeightChg;
    }
    else if (fSetWidth != fitToWidth)
      result = kWidthChg;
    else
    {
      SetHasChanged(FALSE);
      result = kNoChg;
    }
    fSetWidth = fitToWidth;
    fWidth = fitToWidth;
    return result;
  }

  alignment = fAlign;
  GetBorderInfo(oldRuleWidths, ruleBorders, ruleType);
  if (PreFormat(currency, part, custom, ruleWidths, itsPictStyle, result, gapHalf))
  {
    if (fPicKind == kWhiteSpace)     // 07/12/92 stop wh space changing with borders/spacing
    {
      ClearRect(ruleWidths);
      fSpBefore = fSpAfter = 0;      // SetSpacing(0, 0);
      fAdorn = 0;                    // .. and stop it drawing any rules
    }
    lm = FixRound(GetLeftMargin() - ruleWidths.left);  // 28/05/90
    rm = FixRound(GetRightMargin() - ruleWidths.right);  // 28/05/90
    oldAlign = fUserAlign; //   02/01/91
    fScaleFactor = TPictStyle(itsPictStyle)->fScaleFactor; //   02/01/91
    MoveRect(fCropRect, TPictStyle(itsPictStyle)->fCropRect); //   02/01/91
    fAlignedByUser = (TPictStyle(itsPictStyle)->fDefinedInPict &
                 (kUserAlign | kOwnWhichAlign)) == kUserAlign;  // 26/11/92
    fUserAlign = TPictStyle(itsPictStyle)->fUserAlign; //   02/01/91
    if (pictStructure->fPicture != fPicture)
      fWidth = 0;
    fInline = pictStructure->IsInLine();
    if (fWidth == 0 || EmptyRect(fPicRect))
    {
      picture = pictStructure->GetPicture();
      fPicture = pictStructure->fPicture;
      if (picture == NULL && fWidth == 0)
      {
        if (fitToWidth == 0)
          fWidth = 720;         // 16/05/90 1 inch wide
        else
        {
          fWidth = fitToWidth - lm - rm;
          if (fPicKind == kPict)
            fWidth /= 2;
        }
        
        if (fPicKind == kPict)
        {
          asc = (long) fWidth / 3;
        }
        else
        {
          asc = 80;
        }
        desc = asc;
        SetDepth(asc, desc);
        result = kHeightChg;
      }
      else if (picture != NULL)
      { 
        // this is pulling out the size of the picture from the handle
        Rect picFrame;
        wr_wimp_box aBox;
        
        QueryBox((wr_draw_fileheader *)picture->fDrawDiagStr.data, (wr_draw_box *)&aBox);

        // 15/05/90 - new - set the origin of the box so that the bottom left
        // is (0,0) but keeping the same relative box size
        aBox.x1 -= aBox.x0;
        aBox.y1 -= aBox.y0;
        aBox.x0 = 0;
        aBox.y0 = 0;

        BoxToQDRect(aBox, picFrame, ScreenHeight()); // get in QD units

        fWidth = picFrame.right - picFrame.left + 32; // 16/05/90 - 32 (decipoints)
        desc = picFrame.bottom - picFrame.top + 32; // 16/05/90 - 32 (decipoints)
        if (pictStructure->fBaseLine == 0)    // 06/06/96 was always zero: test changed from <= 0
          asc = desc / 2;
        else
          asc = desc;              // 06/06/96 put on baseline for Word: asc = baseLine + 16;
        desc -= asc;
        SetDepth(asc, desc);
        MoveRect(fPicRect, picFrame);
        OffsetRect(fPicRect, -fPicRect.left, -fPicRect.top);
        result = kHeightChg;
      }
    }
    if (fPicture != 0 || fPicKind == kWhiteSpace)
    {
      if (fPicKind == kPict)
      {
        newWidth = GetNewSide(h) + FixRound(oldRuleWidths.left +
              oldRuleWidths.right) + 32;   // 2 pixels
        if (newWidth != fWidth)
        {
          fWidth = newWidth;
          if (result < kHeightChg)      // 09/05/93 [20855] from !=
            result = kWidthChg;
        }
      }
      else
        fSetWidth = fWidth = fitToWidth; // 11/04/91 set width of white space

      newDepth = Max(0, GetNewSide(v)) + FixRound(oldRuleWidths.top +
              oldRuleWidths.bottom) + 32;       // should be 2 pixels, 30/11/92 Max
      // 24/10/94 [23011] if (fPicKind == kWhiteSpace)
      // 24/10/94 [23011]   newDepth += 128;  // should be 16pts - 2 pixels
      _TPictFormat::GetDepth(asc, desc);
      if (newDepth != asc + desc)
      {
        if (pictStructure->fBaseLine == 0)    // 06/06/96 was always zero, so use for Word7
          asc = newDepth / 2;
        else
          asc = newDepth;                     // Word pix sit on baseline
        desc = newDepth - asc;
        asc -= oldAlign.v;
        desc += oldAlign.v;
        SetDepth(asc, desc);
        result = kHeightChg;
      }
      if (fInline && oldAlign.v != fUserAlign.v)
      {
        asc += oldAlign.v - fUserAlign.v;
        desc += fUserAlign.v - oldAlign.v;
        SetDepth(asc, desc);
        result = kHeightChg;
      }
    }
    
    if (!EqualVRect(oldRuleWidths, ruleWidths))
    {
      int brw, trw;

      _TPictFormat::GetDepth(asc, desc);
      brw = FixRound(ruleWidths.bottom - oldRuleWidths.bottom);
      trw = FixRound(ruleWidths.top - oldRuleWidths.top);
      asc += trw;
      if (pictStructure->fBaseLine == 0)    // 06/06/96 use for Word7
        desc += brw;
      else
        asc += brw;
      fWidth += FixRound(ruleWidths.left + ruleWidths.right -
                                       oldRuleWidths.left - oldRuleWidths.right);
      SetDepth(asc, desc);
      if (oldRuleWidths.top + oldRuleWidths.bottom != ruleWidths.top + ruleWidths.bottom)
        result = kHeightChg;
    }

    if (fitToWidth == 0)
    {
      fSetWidth = fWidth;
//      if (result < kHeightChg)      // 09/05/93 [20855] from !=
//        result = kWidthChg;
    }
    else if (fitToWidth != fSetWidth || result == kWidthChg)
    {
      fSetWidth = fitToWidth;
//      if (result < kHeightChg)      // 09/05/93 [20855] from !=
//        result = kWidthChg;
    }
    if (result < kHeightChg)      // 09/05/93 [20855] from !=
      result = kWidthChg;
  }
  FreeIfObject(itsPictStyle);       // 10/12/90
  return(result);
}


// ------------------------------------------------------------------------
void _TPictFormat::ClearChangedFlags(TCurrency currency, int hf)
{
  SetHasChanged(FALSE);
}


// ------------------------------------------------------------------------
// fn1 params changed
bool _TPictFormat::Fit(int pageNumber,TCurrency currency,int &spaceAvailable,
           int &noteSpaceUsed, int maxAvailable, TObject &breakObject, int &gapCount,
           bool &splitLeaf, PStdFitNoteVars hdgProc, PStdFitNoteVars origProc)
{
  long asc, desc;
  int height;

  gapCount = 1;             // 17/06/91
  breakObject = NULL;
  _TPictFormat::GetDepth(asc, desc);
  height = asc + desc;
  if (fPicKind == kPageBreak || fPicKind == kColBreak ||
                         fPicKind == kPageFiller) // 05/03/91 pfill
  {
    fDescent = spaceAvailable;
    spaceAvailable = (fPicKind == kPageBreak ? MAXLONGINT : 0); // 26/05/93 LONG
    return TRUE;
  }
  if (height <= spaceAvailable)
  {
    spaceAvailable = spaceAvailable - height;
    return TRUE;
  }
  if (height >= maxAvailable && spaceAvailable >= maxAvailable)  // 08/02/91 && 30/11/92
  {
    spaceAvailable = 0;  // ideally return a value to indicate size too small for a big pic
                         // in a multi-col layout, which currently gets a too small view
    return TRUE;
  }
  return FALSE;
}


// ------------------------------------------------------------------------
int _TPictFormat::GetWidth()
{
  return fWidth;
}


/* ------------------------------------------------------------------------
void _TPictFormat::SetOffset(int lm, int rm)
{ // 12/09/90 new
  int t;

  fOffset = lm + (fAlign == kAlignLeft ? 0 :
    (t = fSetWidth - lm - rm - fWidth, (fAlign == kAlignRight ? t : t / 2)));
}
*/

// ------------------------------------------------------------------------
void _TPictFormat::SetWidth(TCurrency currency, int newWidth)
{
//  int lm, rm;

  fSetWidth = newWidth;

/*   02/01/91
  if (!fAlignedByUser)
  {
    lm = FixRound(GetLeftMargin() -
                          GetBorderWidth(adnLineLeft, fAdorn, fRules));
    rm = FixRound(GetRightMargin() -
                          GetBorderWidth(adnLineRight, fAdorn, fRules));
    SetOffset(lm, rm);
  }
*/
}


// ------------------------------------------------------------------------
int _TPictFormat::GetMinWidth()
{ // 12/09/90 new
  return fWidth;
}

/* ------------------------------------------------------------------------
void _TPictFormat::CreatePicFrame(Rect &picFrame,
                                  int spBefore, long ascent, long descent)
{
  picFrame.top = spBefore;
  picFrame.left = fOffset;
  picFrame.bottom = picFrame.top + ascent + descent; // 28/05/90 - new
  picFrame.right = picFrame.left + fWidth;
}
*/


// ------------------------------------------------------------------------
TSubView _TPictFormat::MakeOrUpdateView(TCurrency currency, TViewId viewId,
                                  TView itsSuperView, TView itsNextView,
                                  VPoint &itsLocation, TObject startBreak,
                                  TObject endBreak, TSubView itsView,
                                  bool invalidate) // 27/07/90
{
  // 11/07/90 - changed makeview and updateview so that they are now
  //            merged together in this local procedure

  VPoint pictViewSize;
  long ascent;
  long descent;
  int spBefore;
  int spAfter;
  Rect ruleRect;
  Rect picRect;
  Rect picFrame;
  int pict;

  _TPictFormat::GetDepth(ascent, descent);
  if (fPicKind != kPict && fPicKind != kWhiteSpace)  // 02/01/91 xtra clause
  {
    spBefore = 0;
    spAfter = 0;
    pictViewSize.v = fDescent;
  }
  else
  {
    GetViewBorders(startBreak, endBreak, ruleRect, spBefore, spAfter);
    if (fInline || fPicKind == kWhiteSpace)  // 02/01/91 xtra clause
    {
      spBefore = 0;
      spAfter = 0;
    }
    pictViewSize.v = ascent + descent + spBefore + spAfter;
  }
  pictViewSize.h = fSetWidth;
  ZoomVPt(pictViewSize);

  if (itsView == NULL)
  {
    itsView = new _TPictView(itsSuperView, fMainView,
            TSubView(itsNextView), itsLocation, pictViewSize,
            currency, spBefore, spAfter);
    itsSuperView->AddSubView(itsView);
    itsView->SetColNum(viewId.tag.fColNum);
  }
  else
  {
    itsView->Resize(pictViewSize.h, pictViewSize.v, invalidate);
    if (fPicKind == kPict)
      itsView->SetSpacing(spBefore, spAfter);
  }
  GetPictInfo(currency, spBefore, pict, picRect, picFrame);
  
  if (fPicKind == kPict)
    ZoomRect(picRect);
  ZoomRect(picFrame);
  TPictView(itsView)->SetPicture(pict, picRect, picFrame, fPicKind);

  return itsView;
}


// ------------------------------------------------------------------------
TSubView _TPictFormat::MakeView(
                 TCurrency currency, TViewId viewId, // Fixed itsSlop, VPoint &
                 Fixed itsVSlop, TView itsSuperView,
                 TView itsNextView, VPoint &itsLocation,
                 TObject startBreak, TObject endBreak)
{
  // itsVSlop.v = 0;
  // itsVSlop.h = 0;         // 17/06/91
  return MakeOrUpdateView(currency, viewId, itsSuperView, itsNextView, itsLocation,
                                startBreak, endBreak, NULL, TRUE);
}


// ------------------------------------------------------------------------
bool _TPictFormat::UpdateView(
     TCurrency currency, TSubView itsView, VPoint &itsLocation, // VPoint &
     Fixed itsVSlop, TObject startBreak, TObject endBreak, bool invalidate, bool updateAll)
{
  TViewId viewId;

  // itsVSlop.v = 0;
  // itsVSlop.h = 0;         // 17/06/91
  itsView->Locate(itsLocation.h, itsLocation.v, TRUE);  // 12/09/90
  viewId.fNumId = 0;
  MakeOrUpdateView(currency, viewId, NULL, NULL, itsLocation,
                                startBreak, endBreak, itsView, invalidate);
  return FALSE;
}


// ------------------------------------------------------------------------
void _TPictFormat::GetPictInfo(TCurrency currency, int spBefore,
             /* TPictObject*/ int &pict, Rect &picRect, Rect &picFrame)
{
  long ascent;
  long descent;
  CntlAdornment borders;
  TRuleType ruleType;
  VRect ruleWidths;
  int lm;
  int rm;
  int tb;
  int lb;

  _TPictFormat::GetDepth(ascent, descent);
  pict = fPicture;      // 18/03/91

  // 02/01/91 all following added
  GetBorderInfo(ruleWidths, borders, ruleType);
  tb = FixRound(ruleWidths.top);
  lb = FixRound(ruleWidths.left);
  lm = FixRound(GetLeftMargin() - ruleWidths.left);
  rm = FixRound(GetRightMargin() - ruleWidths.right);
  picFrame.top = spBefore;
  MoveRect(picRect, fPicRect);
  if (fInline)
    picFrame.left = 0;
  else if (fAlignedByUser)
  {
    picFrame.left = fUserAlign.h;
  }
  else if (fAlign == kAlignLeft)
    picFrame.left = lm;
  else
  {
    int left = fSetWidth - lm - rm -fWidth;
    if (fAlign == kAlignCentre)
      left /= 2;
    picFrame.left = left + lm;
  }
  picFrame.right = picFrame.left + fWidth;
  picRect.right = DoScale(picRect.right, fScaleFactor.h);
  //if (fScaleFactor.h != 100)
  //  picRect.right = DOSCALE(picRect.right * fScaleFactor.h);
  picFrame.bottom = picFrame.top + ascent + descent;
  picRect.bottom =  DoScale(picRect.bottom, fScaleFactor.v);
  //if (fScaleFactor.v != 100)
  //  picRect.bottom = DOSCALE(picRect.bottom * fScaleFactor.v);
  if (fPicKind == kPict)
    OffsetRect(picRect, picFrame.left + lb - fCropRect.left + 16,
                                  picFrame.top + tb - fCropRect.top + 16);
                                                // 12/04/91: 16 for 10s
}


/* ------------------------------------------------------------------------
bool _TPictFormat::ContainsChanges(TCurrency currency, TObject startBreak, TObject endBreak)
{
  return(fHasChanged);
}
*/

// ------------------------------------------------------------------------
_TPictView::_TPictView(TView itsSuperView, TMainView itsMainView,
            TSubView itsNextView, VPoint &itsLocation, VPoint &itsSize,
            TCurrency itsStructure, int itsSpBefore, int itsSpAfter) :
  (itsMainView->fDocument, itsSuperView, itsMainView, itsNextView, itsLocation, itsSize,
         itsStructure, itsSpBefore, itsSpAfter)
{
#ifndef ZERO_OBJ
  SetPicture(0, gZeroRect, gZeroRect, kPict);
  fOffset = 0;
  fAllSelected = FALSE;
  fInTracker = FALSE;
#ifdef FILMS
  fFilmDiag.data = NULL;
  fFilmBase = NULL;
  fCompress = 0;
#endif
#if SIDEBAR == 1
  fCurrentFrame = 0;
  fFrameCount = 0;
  fAnimationSpeed = 0;
  fAnimationType = 0;
  fUserAnimationType = 0;
  fBackward = FALSE;        // 05/12/95 for animated films
#ifdef FILMS
  fDelta = 0;
  fSoundPtr = 0;
#endif
#endif
#else
  fPicKind = kPict;  
#endif
}

// ------------------------------------------------------------------------
void _TPictView::Delete()
{
//  TPictStructure structure = TPictStructure(
//            TTextDocument(fDocument)->GetStructure(fStructure, kReadOnly));

//  if (structure->fPicture != 0)
//    TTextDocument(fDocument)->PurgePicture(structure->fPicture);

  if (fPictureRecnum != 0)
    TTextDocument(fDocument)->PurgePicture(fPictureRecnum, FALSE);
                  // 15/07/91 extra param - use docs current fPurging value

  TTextDocument(fDocument)->PurgeCurrency(fStructure);

  _TSubView::Delete();
}


#if SIDEBAR == 1 || defined FILMS
// ------------------------------------------------------------------------
void _TPictView::Free()
{
  wr_alarm_removeall(this);

#ifdef FILMS
  DisposIfHandle(fFilmDiag.data);
#endif

  _TSubView::Free();
}
#endif

// ------------------------------------------------------------------------
void _TPictView::SetPicture(/*TPictObject picture,*/ int picture, Rect &picRect,
           Rect &picFrame, TStyleTypes picKind)
{
  VRect limits;
  VRect frame;
  int offset;

  // 27/11/90 new block
  TSubView(fSuperView)->GetTrackLimits(this, limits, 0);   // FALSE, FALSE);
  MoveRect(frame, picFrame);
  LocalToMainRect(frame);
//  LocalToMainView(*frame.topLeft);
//  LocalToMainView(*frame.botRight);

  fPictureRecnum = picture;
  MoveRect(fPicRect, picRect);
#if SIDEBAR == 1
  fCurrentFrame = 0;
  fBackward = FALSE;        // 05/12/95 for animated films
#endif
#ifdef FILMS
  fSoundPtr = 0;
  ClearHandle(&fFilmDiag.data);
#endif

  // 27/11/90 new block to fit frame within page
  offset = limits.left - frame.left;
  if (offset > 0)
    picFrame.left += offset;
  offset = frame.right - limits.right;
  if (offset > 0)
    picFrame.right -= offset;
  // 08/02/91 new block - corrected 25/04/91 to not set fPicFrame
  offset = limits.top - frame.top;
  if (offset > 0)
    picFrame.top += offset;
  offset = frame.bottom - limits.bottom;
  if (offset > 0)
    picFrame.bottom -= offset;

  MoveRect(fPicFrame, picFrame);
  fPicKind = picKind;
}


// ------------------------------------------------------------------------
bool _TPictView::ContainsCursor(TCursorNode cursor, TCursorNode target, TSubView &subView)
{
  if (fStructure == cursor->fCurrency)
  {
    cursor->fIdentifier = fIdentifier;
    subView = this;
    return TRUE;
  }
  return FALSE;
}

// ------------------------------------------------------------------------
void _TPictView::ScrollCursorIntoView(TCursorNode cursor)
{
  VRect picFrame;
  VRect cursRect;
  TScroller scroller;

  GetAdornRect(picFrame);
  MoveRect(cursRect, picFrame);  // visibleRect corrupts picFrame
  scroller = GetScroller(FALSE);

  if ((scroller != NULL && cursRect.right - cursRect.left < scroller->fSize.h &&
       cursRect.bottom - cursRect.top < scroller->fSize.v) ||
        (/* InsetRect(cursRect, -180, -180),*/ !Focus()) || !VisibleRect(picFrame))
        // only do anything if NOT any part visible ... 14/07/95 or fits in window
  {
    // InsetRect(cursRect, inset, inset);// 1/4 inch round outside if not visible
    cursor->fCursor->Connect(fMainView);
    RevealRect(cursRect, gZeroVRect);
  }
}

#ifdef NEVER
// ------------------------------------------------------------------------
void _TPictView::GetCursorExtent(TCursorNode cursor, VRect &cursExtent, VRect &extent)
{
  GetExtent(cursExtent);
  LocalToMainRect(cursExtent);
  // 11/05/93 [20868] get pictures/white space to scroll into view if not all visible
  MoveRect(extent, cursExtent);
  VisibleRect(extent);
  if (EmptyRect(extent))
  {
    MoveRect(extent, cursExtent);  // only scroll if non part of extent visible
    extent.bottom =
          Min(extent.bottom, extent.top + LengthRect(*thePort->GetClipRect(), v) - 360);
    InsetRect(cursExtent, -180, -180);   // 1/4 inch round outside
  }
  else
    ClearRect(extent);
}
#endif

// ------------------------------------------------------------------------
void _TPictView::GetAdornRect(Rect &adornRect)
{
#ifdef TRACE
  Rect QDExtent;

  GetQDExtent(QDExtent);
  Assert(QDExtent.left == 0 && QDExtent.top == 0, 632);
#endif
  MoveRect(adornRect, fPicFrame);
}

// ------------------------------------------------------------------------
static void SetFrameCentre(Rect &picFrame, int kind)
{
  // 22/05/90 - added Mins for the case of a very small picture
  // 26/04/93 - use Min(length / 4, ...) instead of / 2 so there is room in centre to drag
  // 24/10/94 - use common routine which allows more room to grab edge of white space
  int hInset = (picFrame.right - picFrame.left) / 4;
  int vInset = picFrame.bottom - picFrame.top;

  vInset = (kind == kWhiteSpace ? vInset / 2 : vInset / 4);
  InsetRect(picFrame, Min(hInset, kMouseSlopH), Min(vInset, kMouseSlopV));
}

// ------------------------------------------------------------------------
int _TPictView::GetCursorID(Point &localPoint)
{
  Rect picFrame;
  int cursorId = kSystemCursor; // 10/08/90 - return this if no cursor

  GetAdornRect(picFrame);
  if (PtInRect(localPoint, picFrame))
  {
    if (GetWindow()->fTarget == this)
    {
      if (fAllSelected || (fPicKind != kWhiteSpace && fPictureRecnum == 0))           // || 24/04/91
        cursorId = (fPicKind == kPict ? kHandCursor : kSystemCursor);
      else
      {
        SetFrameCentre(picFrame, fPicKind);
        // InsetRect(picFrame, Min(LengthRect(picFrame, h) / 4, kMouseSlopH),
        //                   Min(LengthRect(picFrame, v) / 4, kMouseSlopV));
        if (PtInRect(localPoint, picFrame))
        {
          cursorId = (fPictureRecnum == 0 ? kSystemCursor : kHandCursor);
        }
        else if (localPoint.h < picFrame.left || localPoint.h >= picFrame.right)
        {
          if (fPicKind != kPict)
            cursorId = kSystemCursor;             // 12/09/90
          else if (localPoint.v < picFrame.top || localPoint.v >= picFrame.bottom)
            cursorId = kFourArrowCursor;
          else if (localPoint.h < picFrame.left)   // 23/05/90 - changed from lr / ud cursors to separate ones for each bit
            cursorId = kRightArrowCursor;
          else
            cursorId = kLeftArrowCursor;
        }
        else if (localPoint.v < picFrame.top)  // 23/05/90 - changed from lr / ud cursors to separate ones for each bit
          cursorId = kDownArrowCursor;
        else
          cursorId = kUpArrowCursor;
      }
    }
    else if (fPicKind == kWhiteSpace)
      cursorId = kMagicCursor;
    else
      cursorId = kSystemCursor;
  }

  return cursorId;
}

#define gIDSt07 I_('S', 't', '0', '7')
#define gIDPic0 I_('P', 'i', 'c', '0')
// ------------------------------------------------------------------------
bool _TPictView::DoHelp(IDType msgID, EventInfo &info, VPoint &theMouse)
  // 09/08/90 - improved help msg depending on the cursor shape
{
  int cursorId = GetCursorID(theMouse);
  int msg = -1;

  if (cursorId >= kLeftArrowCursor && cursorId <= kDownArrowCursor)
  {
    msg = 0;  // crop picture frame
  }
  else if (cursorId == kFourArrowCursor)
  {
    msg = 1;  // crop or resize picture
  }
  else if (cursorId == kHandCursor)
  {
    if (Selected())
    {
      // pic3 - baseline msg, pic4 - drag frame left/right
      msg = (TPictFormat(GetMyFormatReadOnly())->fInline ? 3 : 4);
    }
    else
      msg = 2; // drag picture inside its frame
  }
  else if (cursorId == kMagicCursor)
    msg = 5;
//  else show default picture msg

  msgID = (msg < 0 ? gIDSt07 : gIDPic0 + msg);
  return _TView::DoHelp(msgID, info, theMouse); // do not call subview help
}


// ------------------------------------------------------------------------
int _TPictView::GetPointerShape(Point &localPoint)
{
  // int cursorId =
  return GetCursorID(localPoint);

//  return SetCursor(cursorId == kSystemCursor ? NULL : GetCursor(cursorId));
  // return SetCursor(GetCursor(cursorId));  // 28/03/93 GetCursor(kSystemCursor) returns NULL
}


/* ------------------------------------------------------------------------
bool _TPictView::CanFlashCaret()
{
  return FALSE;
}
*/

// ------------------------------------------------------------------------
static void InvertTheFrame(TView theView, Rect *extent, int colour)
{
  PenMode(patXor);
  PenPat(colour);         // 08/04/93 set to caret/ghost colour
  FrameRect(*extent);
  PenNormal();
}

#ifdef DRAGDROP
// ------------------------------------------------------------------------
void _TPictView::DrawGhostCaret(TCursorNode cursorNode)
{ 
  bool temp = fAllSelected;
  
  fAllSelected = 2;
  DrawHighlight(FALSE);
  fAllSelected = temp;
}
#endif

#if SIDEBAR == 1
// ------------------------------------------------------------------------
static void RedrawDiag(TPictView self)
{
  VRect viewRect;

//  self->GetExtent(viewRect);
//  InsetVRect(viewRect, GetVLineThickness(), GetHLineThickness());
//  self->UpdateVRect(viewRect);

  MoveRect(viewRect, self->fPicRect);
  // self->GetAdornRect(viewRect);
  //  InsetRect(viewRect, GetVLineThickness(), GetHLineThickness());
  OffsetRect(viewRect, self->fLocation.h, self->fLocation.v);
  self->fSuperView->UpdateVRect(viewRect);
//  self->UpdateVRect(self->fPicRect);
}

// ------------------------------------------------------------------------
static bool ShowDiag(int called_at, TPictView self)
{
  int reshow = TRUE;
  bool ShowDiag_r = TRUE;

#ifdef FILMS
  if (self->fFilmDiag.data != NULL)
  {
    // build up sprite for next frame
    TPictObject thePict =
           TPictObject(TTextDocument(self->fDocument)->GetPicture(self->fPictureRecnum));
    char *acef = thePict->FindFilmChunk('FECA');  // ACEF
    char *filmPtr;
    char *soundPtr = NULL;
    char *nextFrame;

    if (self->fCurrentFrame == 0)
      self->fCurrentFrame = ((int *)acef)[4];
    filmPtr = acef + self->fCurrentFrame;

    reshow = self->fAnimationType != 0 && self->fBackward != 2;
#ifdef TRACE
    if (*(int *)filmPtr != *((int *)(filmPtr + *(int *)filmPtr - 4)))
        FailGeneral(97);
#endif
    nextFrame = self->ExpandFilm(acef);

    // play required sound for frame
    if (self->fWaveTable == 0)
    {
      if (wr_os_swi2r(IotaSound_LoadTable | wr_os_X, int(thePict->fDrawDiagStr.data) + FILMSTART,
             thePict->fDrawDiagStr.length - FILMSTART, &self->fWaveTable, NULL) != NULL)
        self->fWaveTable = 0;
    }
    if (self->fWaveTable != 0)
    {
      char *dir1 = thePict->FindFilmChunk('1RID');  // DIR1

      if (dir1 != NULL)
      {
        int ready = -1;
        wr_os_regset r;

        soundPtr = dir1 + self->fSoundPtr;
#ifdef TRACE
        if (*(int *)soundPtr != *((int *)(soundPtr + *(int *)soundPtr - 4)))
          FailGeneral(98);
#endif
        r.r[0] = self->fWaveTable;
        r.r[1] = (int)soundPtr;

        if (wr_os_swi1r(0x4ad80 | wr_os_X, 0, &ready) != NULL || ready != 0)
        {
          wr_wimpt_noerr(wr_os_swix(IotaSound_Play, &r));
          // else Speak is still talking - do not use IotaSound!
          ShowDiag_r = FALSE;      // suppress sending commentry string
        }
      }
    }
    if (self->fBackward == 0)
    {
      if (*(int *)nextFrame == 0)          // reached the end
      {
        if (self->fAnimationType < 2)
          self->fBackward = 2;
        if (self->fAnimationType == 3)
          self->fBackward = TRUE;   // yo yo
        else
        {
          self->fCurrentFrame = ((int *)acef)[4];   // reset to start
          self->fSoundPtr = 0;
        }
      }
      else
      {
        self->fCurrentFrame = nextFrame - acef;
        if (soundPtr)
          self->fSoundPtr += ((int *)soundPtr)[0];
      }
    }
    if (self->fBackward == 1)
    {
      self->fCurrentFrame -= ((int *)filmPtr)[-1];   // wind back to preceeding frame
      if (soundPtr && self->fSoundPtr != 0)
        self->fSoundPtr -= ((int *)soundPtr)[-1];
      if (self->fCurrentFrame == ((int *)acef)[4])   // back to start (must be yo yo)
        self->fBackward = FALSE;
    }
  }
  else
#endif
  {
    self->fCurrentFrame++;
    if (self->fCurrentFrame >= self->fFrameCount +
                       (self->fAnimationType == 3 ? self->fFrameCount - 2 : 0))
    {
      self->fCurrentFrame = 0;
      if (self->fAnimationType < 2)
        reshow = FALSE;
    }
    else if (self->fAnimationType == 0)     // self->fFrameCount == 2)
      reshow = FALSE;
  }
  if (reshow)
    wr_alarm_set(wr_alarm_timenow() + self->fAnimationSpeed, (wr_alarm_handler)ShowDiag, self);
  else
  {
    if (self->fWaveTable != 0)
      wr_wimpt_noerr(wr_os_swi1(IotaSound_ReleaseTable | wr_os_X, self->fWaveTable));
    self->fWaveTable = 0;
  }
  RedrawDiag(self);
  return ShowDiag_r;
}

// ------------------------------------------------------------------------
static void ResetDiag(int called_at, TPictView self)
{
#ifdef FILMS
  if (self->fFilmDiag.data != NULL)
  {
    self->fCurrentFrame = 0;
    self->fSoundPtr = 0;
  }
  else
#endif
    self->fCurrentFrame = self->fFrameCount;
  ShowDiag(called_at, self);
}

// ------------------------------------------------------------------------
static bool StartAnimation(TPictView self, int animType)
{
  self->fAnimationType = animType;
  self->fBackward = FALSE;
  wr_alarm_removeall(self);
  return ShowDiag(0, self);
}

// ------------------------------------------------------------------------
void _TPictView::DoEndClick()
{
  if (fFrameCount > 0 && fSelected)      // tests fSelected to ignore adjust clicks
    StartAnimation(this, fUserAnimationType);
}

// ------------------------------------------------------------------------
bool _TPictView::AnimateView(TCurrency currency)
{
  if (currency == fStructure)
  {
    if (fFrameCount > 0)
    {
      if (!StartAnimation(this, 1))      // 1 cycle
      {
        // Problem: a Free the document in event_process can cause devastation
        int oldMask = wr_event_getmask();

        wr_event_setmask(wr_wimp_emask((wr_wimp_EMCLOSE) | (wr_wimp_EMMENU)));
        while (wr_alarm_anypending(this))   // finish soundtrack before Speak can get in again
          wr_event_process();
        wr_event_setmask(oldMask); 
        return FALSE;                    // and avoid speak commentary?
      }
    }
    return TRUE;
  }
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
void _TPictView::DrawHighlight(bool drag)
{
  Rect picFrame;
  Rect updateRect;
  int hLine = GetHLineThickness();

  GetAdornRect(picFrame);
  MoveRect(updateRect, picFrame);
  updateRect.top -= hLine;   // 05/10/90 see Toolbox
  updateRect.right += GetVLineThickness(); // 18/07/93 V for H ??
#ifdef DRAGDROP
  if (drag)
  {
    LocalToMainRect(updateRect);
    UnionRect(fMainView->fZoomBox, updateRect, fMainView->fZoomBox);    
  }
  else
#endif
    NoNH_DoInUpdate(updateRect,
               fAllSelected == 1 ? (DrawProc)InvertTheExtent : (DrawProc)InvertTheFrame,
               &picFrame, fAllSelected + 11); // 08/04/93 pass colour
}


// ------------------------------------------------------------------------
void _TPictView::SetHighlight(TCursorNode anchor, TCursorNode activeEnd, bool redraw,
                              bool noteSelection) // fn1
{
#ifdef DRAGDROP
  if (redraw == 2)
    DrawHighlight(TRUE);
  else
#endif
  // 11/08/95 if (!fInTracker)             // 24/04/91 stop rehighlighting in autoscroll
  {
    HLState desiredState;
    bool cleared = (anchor == TCursorNode(-1) || activeEnd == TCursorNode(-1));

    if (cleared)
      desiredState = HLOff;
    else
    {
      bool invertIt = (anchor == NULL || activeEnd == NULL);

      if ((fAllSelected || Selected()) && invertIt != fAllSelected && Focus())
      {
        DrawHighlight(FALSE);          // remove current h/l - its wrong
        fHLDesired = HLOff;            // get it put back the other way
      }
      Select(!invertIt);
      fAllSelected = invertIt;
      desiredState = HLOn;
    }
    if (desiredState != fHLDesired)     // 11/08/95 [26054] && redraw)
    {
      if (Focus())
        DrawHighlight(FALSE);
    }
    fHLDesired = desiredState;
    if (cleared)
      fAllSelected = FALSE;
#if SIDEBAR == 1
    if (cleared)
    {
      if (fAnimationType == 0)    // fFrameCount == 2)
      {
        if (fCurrentFrame != 0)
          wr_alarm_set(wr_alarm_timenow(), (wr_alarm_handler)ResetDiag, this);
                         // reset to frame 0 asap (unless cancelled by click on same view)
      }
      else
      {
        if (fCurrentFrame != 0)
        {
          ResetDiag(0, this);
          // ??? fCurrentFrame = 0;     // reset to base frame
          // ??? RedrawDiag(this);
        }
        wr_alarm_removeall(this);
      }
      if (fWaveTable != 0)
        wr_wimpt_noerr(wr_os_swi1(IotaSound_ReleaseTable | wr_os_X, fWaveTable));
      fWaveTable = 0;
    }
#endif
    Select(!cleared);
  }
}

#if SIDEBAR == 1
// ------------------------------------------------------------------------
static int GetFilmRate(TPictObject pictObj)
{
  switch (pictObj->fRateType)
  {
    case 0:   /* Centiseconds per frame */
      return pictObj->fRate;
    case 2:   /* Vsyncs per second */
      return (100 * pictObj->fRate) /
               (pictObj->fVSyncs == 0 ? 50 : pictObj->fVSyncs);
    case 1:   /* Frames per second */
      if (pictObj->fRate != 0)
        return 100 / pictObj->fRate;
  }
  return 10;  /* use a sensible default? */
}

// ------------------------------------------------------------------------
void *_TPictView::FindFilmSprite()
{
  return (wr_draw_spristrhdr *)(fFilmDiag.data + sizeof(wr_draw_fileheader)) + 1;
}

// ------------------------------------------------------------------------
char *_TPictView::ExpandFilm(char *acef)
{
  wr_os_regset r, r1;

  r.r[0] = 0x23d;                       // switch output to the sprite at end of area
  r.r[1] = 0xff;                        // not using sprite area
  r.r[2] = (int)FindFilmSprite();
  r.r[3] = 0;
  FailOSErr(wr_os_swix(OS_SpriteOp, &r));  // switch output for following write to sprite
  r1.r[0] = fCompress;
  r1.r[1] = (int)(acef + fCurrentFrame);
  r1.r[2] = (fDelta ? (int)fFilmBase : 0);
  wr_wimpt_noerr(wr_os_swix(Euclid_Expand, &r1));
  fFilmBase = (void *)r1.r[2];
  FailOSErr(wr_os_swix(OS_SpriteOp, &r));  // switch back to screen!
  return (char *)r1.r[1];
}
#endif

// ------------------------------------------------------------------------
void _TPictView::Draw(Rect &area)
{
  Rect picRect;
  Rect picFrame;
  int hLine = GetHLineThickness();
  int vLine = GetVLineThickness();
  TPictObject thePict = NULL;
  FailInfo fi;

  CatchFailures(&fi);
   // 22/02/93 [20710] && ...; reads pictures off disc even though not needed for display
  if (fPictureRecnum != 0 && ((fMainView->fShowPictures & 1) != 0 || gPrinting))
  {
    thePict = TPictObject(TTextDocument(fDocument)->GetPicture(fPictureRecnum));
#if SIDEBAR == 1
    fFrameCount = CountFrames(thePict);
    fAnimationSpeed = GetFilmRate(thePict);
//    switch (thePict->fSpeed)
//    {
//      case 0:
//        fAnimationSpeed = 5; break;
//      case 1:
//        fAnimationSpeed = 20; break;
//      default:
//        fAnimationSpeed = 50;
//    }
    fUserAnimationType = thePict->fContinuous;
#endif
  }
  Success(&fi);
  // 19/03/91 if cannot load picture, carry on by drawing a crossed square
Rescue:

  GetAdornRect(picFrame);
  InsetRect(picFrame, vLine, hLine);          // 11/09/90 moved from below

  MoveRect(picRect, fPicRect);
  if (thePict == NULL
#ifdef WORD7
              || thePict->fSprite >= 9
#endif
          )      // 22/02/93 [20710] || !(fMainView->fShowPictures || gPrinting))
  {
    if ((!gPrinting) && fPicKind == kPict)   // 11/09/90
    {
      int topPlusLine;

      // draw the crossed box
      PenNormal();
#ifdef WORD7
      if (thePict->fSprite >= 9)
      {
        PenPat(ltGrey);
        PaintRect(picRect);   // picFrame);
      }
      else
#endif
      {
        PenPat(gray);
        FrameRect(picFrame);
        InsetRect(picFrame, vLine, hLine);
        topPlusLine = picFrame.top + 1;
        MoveTo(picFrame.left, topPlusLine);
        LineTo(picFrame.right, picFrame.bottom);
        MoveTo(picFrame.right, topPlusLine);
        LineTo(picFrame.left, picFrame.bottom);
      }
    }
  }
  else
  {
    wr_draw_diag *diag = &thePict->fDrawDiagStr;

    // draw the picture properly
    if (fRuleType.fRule >= k2Thn)
    {
      InvalBorders(area, picFrame);  // 20/05/93 [20882] clip inside the borders if > 1 line
      picFrame.top -= fSpBefore;     // 20/05/93 [20882]
      picFrame.bottom += fSpAfter;   // 20/05/93 [20882]
    }
    MAFont_ReleaseCurrentFont();     // 08/04/94 [21613] so not slaved over Drawfile text?

#ifdef FILMS
    if (thePict->fSprite >= 7)
    {
      if (fFilmDiag.data == NULL)
      {
        sprite_header *tempSprite;
        wr_draw_spristrhdr *sprihdr;
        char *acef = thePict->FindFilmChunk('FECA');  // ACEF

        tempSprite = (sprite_header *)
                 ((char *)diag->data + sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr));
        fFilmDiag.length =
                     tempSprite->next + sizeof(wr_draw_fileheader) + sizeof(wr_draw_spristrhdr);
        fFilmDiag.data = (char *)NewCheckedHandle(fFilmDiag.length);
        sprihdr = (wr_draw_spristrhdr *)((char *)memcpy(fFilmDiag.data, diag->data, FILMSTART) +
                                                                sizeof(wr_draw_fileheader));
        sprihdr->tag = wr_draw_OBJSPRITE;
        sprihdr->size = sizeof(wr_draw_spristrhdr) + tempSprite->next;

        if (tempSprite->image > sizeof(sprite_header))
        {
          // copy over a palette from PALE chunk into the sprite palette
          int *pale = (int *)thePict->FindFilmChunk('ELAP');  // PALE
          int *paletteLimit = pale + ((tempSprite->image - sizeof(sprite_header)) / 8) + 7;
          int *spritePal = (int *)(((sprite_header *)(sprihdr + 1)) + 1);

          for (int *i = pale + 7; i < paletteLimit; )
          {
            int entry = *(i++) & 0xffffff00;

            *(spritePal++) = entry;
            *(spritePal++) = entry;
          }
        }
        fFilmBase = NULL;
        fCompress = ((int *)acef)[8];
        fCurrentFrame = ((int *)acef)[4];
        ExpandFilm(acef);
        fDelta = ((int *)acef)[9] & 1;
        fSoundPtr = 0;
      }
      diag = &fFilmDiag;
      // picFrame.bottom += //TruncateToPixel(picFrame.bottom, v - 4) +
      //      GetHLineThickness() * 6;  // move up clear of frame
      //OffsetRect(picRect, 0, -GetHLineThickness());
      //picRect.bottom -= GetHLineThickness(); // TruncateToPixel(picRect.bottom, v - 4);
    }
#endif
#if SIDEBAR == 1
    DrawPicture(diag, picRect, picFrame,
#ifdef FILMS
         (thePict->fSprite < 7
#ifdef WORD7
           || thePict->fSprite >= 9
#endif
            ) &&
#endif
            fFrameCount && !gPrinting ? (fCurrentFrame >= fFrameCount ?
                     (fFrameCount - 1) * 2 - fCurrentFrame: fCurrentFrame) : -1);
#else
    DrawPicture(diag, picRect, picFrame);
#endif
  }

  // 12/06/91 if printing chuck away the record if no longer needed
  if (fPictureRecnum != 0 && gPrinting && PtInRect(*picFrame.botRight, area))
                                    // 19/04/93 [20836] ensure not a page break etc.
    TTextDocument(fDocument)->PurgePicture(fPictureRecnum, TRUE);
               // 15/07/91 extra param - ignore docs current fPurging value

  _TSubView::Draw(area);
}


// ------------------------------------------------------------------------
void _TPictView::DrawChanges(bool invalidate, bool installChanges)
{
  TPictFormat pictFormat;
  Rect viewExtent;

  pictFormat = TPictFormat(GetMyFormatReadOnly());
  if (installChanges)
  {
    VRect limits;
    VRect frame;
    int offset;

    pictFormat->GetPictInfo(GetStructure(), 0, fPictureRecnum, fPicRect, fPicFrame);
    ZoomRect(fPicFrame);
    ZoomRect(fPicRect);
    OffsetRect(fPicFrame, 0, fSpBefore);                  //   02/01/91
    OffsetRect(fPicRect, 0, fSpBefore);

    // 27/11/90 new block to fit frame within page
    TSubView(fSuperView)->GetTrackLimits(this, limits, 0);     // FALSE, FALSE);
    MoveRect(frame, fPicFrame);
    LocalToMainRect(frame);
    offset = limits.left - frame.left;
    if (offset > 0)
      fPicFrame.left += offset;
    offset = frame.right - limits.right;
    if (offset > 0)
      fPicFrame.right -= offset;
    // 08/02/91
    offset = limits.top - frame.top;
    if (offset > 0)
      fPicFrame.top += offset;
    offset = frame.bottom - limits.bottom;
    if (offset > 0)
      fPicFrame.bottom -= offset;
  }

  if (pictFormat->fHasChanged && Focus())
  {
    GetQDExtent(viewExtent);
    AddChangedExtent(viewExtent);
    _TSubView::DrawChanges(invalidate, installChanges);
  }
}


// ------------------------------------------------------------------------
void _TPictView::DoHighlightSelection(HLState fromHL, HLState toHL)
{
  if (Selected() && fromHL != toHL)  // && !fInTracker) // 03/03/94 [21433] && fIT 
  {
    // ?? WindowPeek(thePort)->LocateCaret(gZeroPt, 0);// 05/10/90 - hide the caret
    DrawHighlight(FALSE);
    // unnecessary: fHLDesired = toHL;
  }
}


// ------------------------------------------------------------------------
TCursorNode _TPictView::ClickOnce(VPoint &mousePoint)
{
//  removed 02/01/91
//  fAllSelected = FALSE;
//  Select(TRUE);
  return new _TCursorNode(fStructure, fIdentifier, mousePoint);
}


/* ------------------------------------------------------------------------
void _TPictView::ClickAgain(TCursorNode cursor, bool rightEdge)
{
  fAllSelected = TRUE;         // 11/09/90 from Select(TRUE)
}
*/                                //   02/01/91


// ------------------------------------------------------------------------
void _TPictView::DoSetupMenus()
{
  TRulerDef theStyle;  // 28/05/90 - new
  // Fixed leftLimit;
  // Fixed rightLimit;
  TSelection selection;
  TPictFormat pictFormat;
  bool hasAlign;
  bool hasPict;
  int i;

  _TSubView::DoSetupMenus();

  pictFormat = TPictFormat(GetMyFormatReadOnly());
  hasPict = (fPicKind == kPict) && !MemSpaceIsLow();

  theStyle = fMainView->GetCurrentStyle(NULL);
  EnableCmd(cParagraph);      // 11/09/90
  selection = TTextDocument(fDocument)->GetNewSelection();
  selection->DoSetupMenus(TRUE);
  Enable(cCut, hasPict);         // 11/09/90
  Enable(cCopy, hasPict);        // 11/09/90
  EnablePasteCmd();              // 27/06/96
  EnableCmd(cClear);
  // 24/02/95 tested inside the Save dialogue setup: EnableCmd(cSaveSelection);
                          // 05/09/90 Enabled because fCursor is TRUE
#ifdef TABLES
  Enable(cChangeStyle, hasPict && fPictureRecnum != 0);         //   02/01/91
  EnableCmd(cSelStyleName);    // 03/05/95 [25013] pic styles submenu

  // 11/09/90 ??? all disabled anyway ???
// 23/11/91 not a command!  DisableCmd(cmInsert);
  DisableCmd(cPicture);
  DisableCmd(cDocTitle);
  DisableCmd(cChapTitle);
  DisableCmd(cPageNum);
  DisableCmd(cPageCount);
  DisableCmd(cContText);
#endif
#ifndef TABLES
  EnableCheck(cBorderOne, TRUE, 
    (theStyle->fDefined & (kOwnAdornment | kHasAdornment)) == (kOwnAdornment | kHasAdornment)
       && (TStyleFormat(theStyle)->fOwnAdornment & adnShadow));
#endif
  DisableCmd(cCurrTime);
  DisableCmd(cCurrDate);
#ifdef TABLES
  Enable(cSpacing, hasPict);
#endif
  Enable(cBorders, fPicKind == kPict);
             // 14/07/95 [26038] fPicKind != kPageBreak && fPicKind != kColBreak);

  hasAlign = hasPict && !(pictFormat->fAlignedByUser || pictFormat->fInline);
  for (i = kAlignLeft; i <= kAlignRight; i++)
    EnableCheck(i + cAlignLeft, hasPict && !pictFormat->fInline,
                                  hasAlign && (TStyleFormat(theStyle)->fAlignment == i));
#if SIDEBAR == 1
  Enable(600, hasPict);
#endif
}

// ------------------------------------------------------------------------
TCommand _TPictView::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
  // 04/04/93 Common UPicture & TextComm commands done in TDDoc
#ifdef TABLES
  if (aCmdNumber < 0)
  {
    int menu;
    int item;

    menu = CmdToMenuItem(aCmdNumber, item);
    // a picture style chosen from menu
    if (menu == cmSelStyle)
        return TTextDocument(fDocument)->DoStyleChange(aCmdNumber); // menu, item);
  }
#endif
#if SIDEBAR == 1
  if (aCmdNumber == 600)
    return DoDialogue(this, 600, 50, -1);     
#endif
  if (aCmdNumber != cUndo && aCmdNumber != cUndoDescription)
    TTextDocument(fDocument)->CommitStyle(TCommand(-1));
  return _TSubView::DoMenuCommand(info, aCmdNumber);
}

// ------------------------------------------------------------------------
TCommand _TPictView::DoMouseCommand(Point &theMouse, EventInfo &info)
{
  int pict;
  Rect picFrame;
  Rect picRect;
  register TPictPart pictPart;
  TPictFormat pictFormat;
#ifdef DRAGDROP
  bool dragDrop = info.theClickCount == 0;
#endif

  pictFormat = TPictFormat(GetMyFormatReadOnly());
  if (info.rightButton && GetWindow()->fTarget != this)
    return new _TSelector(fMainView, this);

  // 16/01/91 Order changed so adjust tested before double click
  if (info.theClickCount > 1 && fPicKind == kPict && fPictureRecnum != 0)
  {
    if (gWimpVersion >= 300 && wr_akbd_pollctl())       // 08/02/94 test ctrl for ole
    {
      fDocument->PipePicture();
      return gNoChanges;
    }
#if defined TABLES && !defined NETWP
    gApplication->SetWindowForMenus(GetWindow());        // 10/08/95 [26053] make sure ...
    gApplication->SetupTheMenus();                       // menus are correctly set ...
    if (CmdEnabled(cChangeStyle))                        // and command is allowed
      return DoMenuCommand(info, cChangeStyle);
#endif
  }

  if (fPicKind == kPageBreak || fPicKind == kColBreak || fPicKind == kPageFiller)
  {
    pictPart = kOverFrame;                            // 05/03/91
#ifdef DRAGDROP
    dragDrop = TRUE;     // 19/12/94 [23022]
#endif
  }
  else
  {
    GetAdornRect(picFrame);
    SetFrameCentre(picFrame, fPicKind);
    //InsetRect(picFrame, Min(LengthRect(picFrame, h) / 4, kMouseSlopH),
    //                      Min(LengthRect(picFrame, v) / 4, kMouseSlopV));
    if (PtInRect(theMouse, picFrame))
    {
#ifdef DRAGDROP
      dragDrop = !wr_akbd_pollctl();
#endif
      pictPart = kOverFrame;
    }
    else
    {
      // 11/09/90 various extra tests for fPicKind == kPict, etc.
      GetAdornRect(picRect);
      InsetRect(picRect, -kSlop, -kSlop);
      if (PtInRect(theMouse, picRect))
      {
        if (fPictureRecnum != 0 || fPicKind != kPict)     // 02/01/91 new clause
        {
          if (theMouse.h < picFrame.left && fPicKind == kPict)
          {
            if (theMouse.v < picFrame.top)
              pictPart = kTopLeftCnr;
            else if (theMouse.v > picFrame.bottom)
              pictPart = kBtmLeftCnr;
            else
              pictPart = kLeftEdge;
          }
          else if (theMouse.v < picFrame.top)
          {
            if (theMouse.h > picFrame.right)
              pictPart = (fPicKind == kPict ? kTopRightCnr : kNoPart);
            else
              pictPart = kTopEdge;
          }
          else if (theMouse.h > picFrame.right && fPicKind == kPict)
          {
            if (theMouse.v > picFrame.bottom)
              pictPart = kBtmRightCnr;
            else
              pictPart = kRightEdge;
          }
          else if (theMouse.v > picFrame.bottom)
            pictPart = kBtmEdge;          
          else
            pictPart = kNoPart;
        }
        else
            pictPart = kOverFrame;
      }
      else
        pictPart = kNoPart;
    }
  }
  pictFormat->GetPictInfo(GetStructure(), 0, pict, picRect, picFrame);

#ifdef DRAGDROP
  if (dragDrop && !info.rightButton)
  {
    TSelector selector = new _TSelector(fMainView, this);

    selector->fDragDrop = (info.theClickCount == 0 ? info.trackingKey : 
#if SIDEBAR == 1
            (GetRsrcOption('s') == NULL ? kDrawSelected : 0));  // suppress D&D with s option
#else
            kDrawSelected);
#endif
#if SIDEBAR == 1
    info.theClickCount = 1; // a selected pic cursor with click count > 1 confuses selector
#endif
    return selector;
  }
#endif

  // 14/05/90 - changed option key to RHS button (for scaling the picture)
  return new _TPictTracker(this, pictFormat, info.rightButton,
                        pictFormat->fInline, pictPart, picFrame, picRect);
}

// ------------------------------------------------------------------------
TCommand _TPictView::DoKeyCommand(int ch, EventInfo &info)
{
  if (ch == chBackspace)
    return DoMenuCommand(info, cClear);

  if (ch == chReturn)         // maybe unnecessary, next bodyview on cmd chain will do this
    return DoMenuCommand(info, cParagraph);  // 11/09/90

  return _TSubView::DoKeyCommand(ch, info);
}

#if SIDEBAR == 1
static IDType gSpeedIDs[] = { I_(0, 0, 0, 'F'), I_(0, 0, 0, 'M'), I_(0, 0, 0, 'S'), 0 };
static IDType gAnimIDs[] = { I_(0, 0, 'S', 'i'), I_(0, 0, 'C', 'y'), I_(0, 0, 'R', 'p'),
                             I_(0, 0, 'Y', 'o'), 0 };

// ------------------------------------------------------------------------
void _TPictView::WriteToDialog(TView aDialog, CmdNumber aCmd)
{
  TPictStructure picStruct = TPictStructure(GetStructureReadOnly(fStructure));
  TPictObject pict = picStruct->GetPicture();

  if (pict)
  {
    int rate = GetFilmRate(pict);

    aDialog->WriteText(I_('t', 'e', 'x', 't'), pict->fText);
    aDialog->WriteCheckBox(gSpeedIDs[rate <= 10 ? 0 : (rate < 50 ? 1 : 2)], TRUE);
    aDialog->WriteCheckBox(gAnimIDs[pict->fContinuous], TRUE);
    if (fFrameCount <= 1)
    {
      for (int i = 0; i < 4; i++)
      {
        aDialog->SetDimState(gSpeedIDs[i], TRUE);   // index 3 will not be found hopefully
        aDialog->SetDimState(gAnimIDs[i], TRUE);
      }
    }
  }
}

// ------------------------------------------------------------------------
TCommand _TPictView::ReadFromDialog(TView aDialog, CmdNumber aCmd, IDType itsId)
{
  TPictStructure picStruct = TPictStructure(GetStructureReadOnly(fStructure));

  if (picStruct->fPicture != 0)
  {
    TPictObject pict = TPictObject(TTextDocument(fDocument)->fPictureHandler->
                                          GetRecordObject(picStruct->fPicture, kReadWrite));

    TControl(aDialog->FindSubView(I_('t', 'e', 'x', 't')))->GetText(pict->fText);

    pict->fRateType = 0;
    switch (LookupID(TCluster(aDialog->FindSubView(I_('S', 'C', 'l', 's')))->
                                                            ReportCurrent(), gSpeedIDs))
    {
      case 0:
        fAnimationSpeed = 5; break;
      case 1:
        fAnimationSpeed = 20; break;
      default:
        fAnimationSpeed = 50;
    }
    pict->fRate = fAnimationSpeed;
    fUserAnimationType = pict->fContinuous =
           LookupID(TCluster(aDialog->FindSubView(I_('E', 'C', 'l', 's')))->
                                                            ReportCurrent(), gAnimIDs);
  }
  return gNoChanges;
}
#endif


// ------------------------------------------------------------------------
_TPictStyle::_TPictStyle() : ()
{
  fDefined |= (kHasAdornment | kHasSpaceBefore | kHasSpaceAfter |
               kHasMargins | kHasAlignment);  // 25/07/90
#ifndef ZERO_OBJ
  fDefinedInPict = 0;
  fScaleFactor = gZeroPt;
  ClearRect(fCropRect);
  fUserAlign = gZeroPt;
#endif
}


// ------------------------------------------------------------------------
void _TPictStyle::IRes(char* &itsResource)
{
  _TStyleFormat::IRes(itsResource);

  SetPt(fScaleFactor, 100, 100);
  fDefinedInPict =
       (kVScale | kHScale | kTopCrop | kLeftCrop | kBtmCrop | kRightCrop);
}

#ifdef TRACE
// ------------------------------------------------------------------------
//bool _TPictStyle::AllTextAttrs()
//{
//  return(FALSE);
//}

// ------------------------------------------------------------------------
bool _TPictStyle::CanAddTabs()
{
  return(FALSE);
}
#endif


// -------------------------------------------------------------------------
bool _TPictStyle::IsStyleMember(int matchType)
{
  return (matchType & (TStyleFormatType | TRulerDefType | TPictStyleType)) != 0;
}


// -------------------------------------------------------------------------
void _TPictStyle::DeleteAttribute(TStyleFormat changes, int attrNum)
// 04/01/91 at the moment delete all the attributes
{
  TPictStyle(changes)->fDefinedInPict = 0;
  _TStyleFormat::DeleteAttribute(changes, attrNum);
}


// -------------------------------------------------------------------------
int _TPictStyle::NumOfAttrs(int ignore)
{
  // return _TStyleFormat::NumOfAttrs(ignore) + ((fDefinedInPict & ~kOwnWhichAlign) != 0);
  if ((fDefinedInPict & ~kOwnWhichAlign) != 0)
    return 1;
  return _TStyleFormat::NumOfAttrs(ignore);
}


// -------------------------------------------------------------------------
void _TPictStyle::Copy(TRulerDef newStyle)
{ // new 02/01/91

  _TStyleFormat::Copy(newStyle);

  if (newStyle->IsStyleMember(TPictStyleType))           // 01/04/92
    memcpy(((char *)newStyle) + sizeof(_TStyleFormat),   // to newStyle
         ((char *)this) + sizeof(_TStyleFormat),         // from self
         sizeof(_TPictStyle) - sizeof(_TStyleFormat));
}


// ------------------------------------------------------------------------
void _TPictStyle::ZoomCropRect(int vhs, TPictStyle derivative, int divisor)
{
  for (int k = vhs; k < 4; k += 2)
    ((int *)&fCropRect)[k] = (((int *)&fCropRect)[k] *
                  TPictStyle(derivative)->fScaleFactor.vh[vhs]) / divisor;
}


// ------------------------------------------------------------------------
void _TPictStyle::ApplyOverride(TRulerDef derivative, TCurrency currency,
                           bool applyRuler)
{
  if (derivative->IsStyleMember(TPictStyleType))
  {
    for (VHSelect vhs = v; vhs <= h; vhs++)
      if (TPictStyle(derivative)->fDefinedInPict & (kVScale << vhs))
      {
        // 02/11/92 different approach to scaling crop values
        if ((fDefinedInPict & (kVScale << vhs)) != 0 &&
                      (TPictStyle(derivative)->fDefinedInPict & (kVScale << vhs)) != 0)
          ZoomCropRect(vhs, TPictStyle(derivative), fScaleFactor.vh[vhs]);

        fDefinedInPict |= (kVScale << vhs);
        fScaleFactor.vh[vhs] =
                         TPictStyle(derivative)->fScaleFactor.vh[vhs];
      }
    for (int i = 0; i < 4; i++)
      if (TPictStyle(derivative)->fDefinedInPict & (kTopCrop << i))
      {
        fDefinedInPict |= (kTopCrop << i);
        ((int *)&fCropRect)[i] =
                         ((int *)&TPictStyle(derivative)->fCropRect)[i];
      }

    // 26/11/92 new flag to indicate which of user align or standard align to use
    if ((TPictStyle(derivative)->fDefinedInPict & kUserAlign) != 0 ||
                             (TPictStyle(derivative)->fDefined & kAlignment) != 0)
    {
      fDefinedInPict = (fDefinedInPict & ~kOwnWhichAlign) |
                    (TPictStyle(derivative)->fDefinedInPict & kOwnWhichAlign);
    }

    if (TPictStyle(derivative)->fDefinedInPict & kUserAlign)
    {
      fDefinedInPict |= kUserAlign;
      fUserAlign = TPictStyle(derivative)->fUserAlign;
    }
  }
  _TStyleFormat::ApplyOverride(derivative, currency, applyRuler);
}


// ------------------------------------------------------------------------
void _TPictStyle::GetDescription(char* description)
{
#ifdef TABLES
  char buffer[60];
  int definedSet = fDefinedInPict;
  int attr;
  int strNum;

  _TStyleFormat::GetDescription(description);

  // 29/10/92 start strNum 0, to include vert scaling value
  for (attr = kVScale, strNum = 0; attr <= kUserAlign; attr <<= 1, strNum++)
  {
    if ((attr & definedSet) != 0)
    {
      char *key = GetIndString(kPictStyleStrs, strNum);

      if (key && strNum < 2)
      {
        sprintf(buffer, key, fScaleFactor.vh[strNum]);
        key = buffer;
      }

      AppendAttr(key, "", description);
      // if (key[0] != 0 && strlen(description) + strlen(key) < 253)
      // {
      //   if (description[0] != 0)
      //     strcat(description, " + ");
      //   strcat(description, key);
      // }
    }
  }
#else
  _TStyleFormat::GetDescription(description);
#endif
}


// ------------------------------------------------------------------------
bool _TPictStyle::Match(TStyleFormat theStyle)
{
  bool  Match_r;

  if (!_TStyleFormat::Match(theStyle) ||
                fDefinedInPict != TPictStyle(theStyle)->fDefinedInPict)
    Match_r = FALSE;
  else
  {
    bool result = TRUE;
    int i = 0;           // log base 2 of attr

    for (int attr = kVScale; attr <= kUserAlign; attr <<= 1, i++)
    {
      if ((fDefinedInPict & attr) != 0)
      {
        if (attr & (kVScale | kHScale))
          result = (fScaleFactor.vh[i] ==
                              TPictStyle(theStyle)->fScaleFactor.vh[i]);
        else if (attr & (kTopCrop | kLeftCrop | kBtmCrop | kRightCrop))
          result = ((int *)&fCropRect)[i - 2] ==
                          ((int *)&TPictStyle(theStyle)->fCropRect)[i - 2];
        else if (attr == kUserAlign)
          result = EqualPt(fUserAlign, TPictStyle(theStyle)->fUserAlign);
      }
      if (!result)
        break;         // return FALSE
    }
    Match_r = result;  // return TRUE if dropped completed loop
  }
  return(Match_r);
}


// ------------------------------------------------------------------------
int _TPictStyle::GetChangeDlg(TStyleTypes type)
// 18/06/92
{
  return (type == kPageFiller ? 0 : kPicStyleDlg);
}

// ------------------------------------------------------------------------
// 04/04/93 set extra bits for picture styles
CmdNumber _TPictStyle::ChangeAlign(TAlignment newAlign)
{
  fDefinedInPict |= kOwnWhichAlign;
  fDefined &= ~kHasAlignment;     // 15/06/93 [20930] bit should never have been be set
                                  // .. unfortunately wrongly set in ctor and hence on disc?
#ifdef TRACE
//  Assert((fDefined & kHasAlignment) == 0, 737);
         // otherwise the inherited method will not do the right thing
#endif
  return _TStyleFormat::ChangeAlign(newAlign);
}

#ifdef TABLES

static IDType gPicLookTab[] = { I_('v', 's', 'c', 'l'),
                                I_('h', 's', 'c', 'l'),
                                I_('f', 'c', 'l', 'i'),
                                I_('s', 'c', 'l', 'i'),
                                I_('b', 'c', 'l', 'i'),
                                I_('r', 'c', 'l', 'i'),
                                I_('p', 'c', 'l', 'i'), 0};

// ------------------------------------------------------------------------
_TPictStyleHpr::_TPictStyleHpr(TDialogView theDialog, TStyleFormat theStyle,
                   TStyleFormat theChanges, TStyleTypes theType) :
                      (theDialog, theStyle, theChanges, theType)
{
  TScrollingList thePopUp;
  TWindow theWindow =
    TTextDocument(theDialog->fDocument)->ActiveMainView()->GetWindow();
  TScale units;

  theWindow->GetScaleUnits(h, units);
  gChosenUnits = (units == eInches || units >= eCustom ? 1 : units);
  thePopUp = TScrollingList(theDialog->FindSubView(I_('p', 'c', 'l', 'i')));
  if (thePopUp != NULL)
  {
    TArray unitArray = thePopUp->fArrayOfItems;

    if (unitArray != NULL)
    {
      unitArray->ReduceSize(eCustom - 1);
      thePopUp->HaveArray(unitArray, gChosenUnits);
    }
  }
}


// ------------------------------------------------------------------------
void _TPictStyleHpr::WriteToDialog(TView aDialog, CmdNumber aCmd)
{
  TPictStyle pictStyle = TPictStyle(fStyleFormat);
  int i;

  pictStyle->fDefined &= ~(kFont | kSize | kFace | kCaps |
    kAlignment | kLeading | kSpaceBefore | kSpaceAfter | kRuler | kLeftMgn |
    kRightMgn | kIndent | kTabs | kCols | kColSep | kAdornment | kHyphenate |
    kLanguage | kColour | kAutoIndent | kBullet);

  _TStyleDlgHelper::WriteToDialog(aDialog, aCmd);

  pictStyle = TPictStyle(TTextAttrsDlg(fNextHandler)->fStyleFormat);

  for (i = 0; i < 2; i++)
  {
    // TNumberText number;

    // if ((number = TNumberText(TView(fNextHandler)->FindSubView(gPicLookTab[i]))) != NULL)
    //  number->SetValue(((int *)&pictStyle->fScaleFactor)[i], kRedraw);
    TView(fNextHandler)->WriteValueRedraw(gPicLookTab[i], ((int *)&pictStyle->fScaleFactor)[i]);
  }
  for (; i < 6; i++)
  {
    TFixedPtText side;

    if ((side = TFixedPtText(TView(fNextHandler)->FindSubView(gPicLookTab[i]))) != NULL)
    {
      side->SetScale(gChosenUnits, 12, kDontRedraw);
      side->SetPoints(ToFixed(((int *)&pictStyle->fCropRect)[i - 2]), kRedraw);
    }
  }
}


/* ------------------------------------------------------------------------
TCommand _TPictStyleHpr::ReadFromDialog(TView aDialog, CmdNumber aCmd, IDType itsId)
{
  return _TStyleDlgHelper::ReadFromDialog(aDialog, aCmd, itsId);
}
*/

// ------------------------------------------------------------------------
void _TPictStyleHpr::DoChoice(TView origView, int itsChoice)
{
  int vIdx;

  if ((vIdx = LookupID(origView->fIdentifier, gPicLookTab)) >= 0)
  {
    TPictStyle pictStyle = TPictStyle(fChanges);

    if (vIdx < 2)
    {
      int currValue = TNumberText(origView)->GetValue();
      TPictStyle diviStyle = (pictStyle->fDefinedInPict & (kVScale << vIdx)) == 0 ?
           TPictStyle(TTextAttrsDlg(fNextHandler)->fStyleFormat) : pictStyle; // 29/10/92
      int divisor = ((int *)&diviStyle->fScaleFactor)[vIdx];                  // 29/10/92

      // As currently draw allows only one scale factor, set both to same
      pictStyle->fDefinedInPict |= (kVScale << vIdx);      // 29/10/92 (kVScale | kHScale);
      ((int *)&pictStyle->fScaleFactor)[vIdx] = currValue;
      // 29/10/92 SetPt(pictStyle->fScaleFactor, currValue, currValue);

      // 29/10/92 - stop large crop values dissappearing the picture on zoom down
      pictStyle->ZoomCropRect(vIdx, pictStyle, divisor);
    }
    else if (vIdx < 6)
    {
      pictStyle->fDefinedInPict |= (kVScale << vIdx);
      ((int *)&pictStyle->fCropRect)[vIdx - 2] =
                 FixRound(TFixedPtText(origView)->GetPoints()); // 29/10/92 from FromFixed
    }
    
    if (vIdx < 6)
      ResetStyle();
  }
  else
    _TStyleDlgHelper::DoChoice(origView, itsChoice);

  if (vIdx == 6)
     gChosenUnits = TControl(origView)->GetValue();
}
#endif

// ------------------------------------------------------------------------
_TPictTracker::_TPictTracker(TPictView theView, TPictFormat theFormat,
     bool scaleKey, bool inText,
     TPictPart pictPart, Rect &picFrame, Rect &picRect)
         : (cPictChange, theView->fDocument, theView->fMainView,
            theView->GetScroller(FALSE)) // 28/05/90 - added fDoc field
{
  VRect vTemp;
  VRect picLimits;
  // bool movePict;
  TwoBools movePictInText;

//  fViewConstrain = FALSE; // 15/05/90 - for autoscrolling
  fConstrainsMouse = TRUE;
// 18/03/91  fPicture = picture;
  MoveRect(fPicFrame, picFrame);      
  MoveRect(fPicRect, picRect);
  MoveRect(fXPicFrame, picFrame);       // 05/10/90 from fPicFrame
  MoveRect(fXPicRect, fPicRect);
  fInline = inText;
  fPictFormat = theFormat;
  fConstrainKey = scaleKey || wr_akbd_pollsh();  // shift key  11/05/91
                                              // 14/05/91 force constrain
  fScaleKey = scaleKey;          // ADJUST button
  fPictPart = pictPart;
  fPicView = theView;
  MoveRect(fCropRect, theFormat->fCropRect);
  fScaleFactor = theFormat->fScaleFactor;
//  fDoubleClick = doubleClick;
//  fFirstClick = TRUE;  // 11/09/90 - new
  fClickOffset.h = MAXINT;             // 05/10/90
#ifndef ZERO_OBJ
  fHasMoved = FALSE;
#endif

  TSubView(theView->fSuperView)->GetTrackLimits(theView, fFrameLimits, 0);
                                           // FALSE, FALSE);   // 04/07/91
  RectToVView(picFrame, vTemp);        // 05/10/90 from fPicFrame
  MoveRect(picLimits, vTemp);
  movePictInText = inText;
  // movePict = (pictPart == kOverFrame);
  if (pictPart == kOverFrame)
    movePictInText |= 2;
  TSubView(theView->fSuperView)->GetTrackLimits(theView, picLimits, movePictInText);

  switch (pictPart)
  {
    case kTopLeftCnr:
        vTemp.top = picLimits.top;
        vTemp.bottom -= kMouseSlopV;  // drop through
    case kLeftEdge:
    case kBtmLeftCnr:
        vTemp.left = picLimits.left;
        vTemp.right -= kMouseSlopH;
        if (pictPart != kBtmLeftCnr)
          break;
    case kBtmEdge:
    case kBtmRightCnr:
        vTemp.top += (3 * GetHLineThickness());    // 24/10/94 [23011] kMouseSlopV;
        vTemp.bottom = picLimits.bottom;
        if (pictPart != kBtmRightCnr)
          break;
    case kRightEdge:
    case kTopRightCnr:
        vTemp.right = picLimits.right;
        vTemp.left += kMouseSlopH;
        if (pictPart != kTopRightCnr)
          break;
    case kTopEdge:
        vTemp.top = picLimits.top;
        vTemp.bottom -= kMouseSlopV; // drop through
        break;

    case kOverFrame: 
        MoveRect(vTemp, picLimits);
        break;
  }
  MoveRect(fTrackerRect, vTemp);
}


// ------------------------------------------------------------------------
void _TPictTracker::RectToVView(Rect &aRect, VRect &newRect)
{
  RectToVRect(aRect, newRect);
  TMainView(fView)->ZoomVRect(newRect);
  OffsetVRect(newRect, 0, fPicView->fSpBefore);   // 24/04/91 missing
  fPicView->LocalToMainRect(newRect);
//  fPicView->LocalToMainView(*newRect.topLeft);
//  fPicView->LocalToMainView(*newRect.botRight);
/*
  newRect->left = Max(newRect->left, fFrameLimits.left);
  newRect->right = Min(newRect->right, fFrameLimits.right);
  newRect->top = Max(newRect->top, fFrameLimits.top);
  newRect->bottom = Min(newRect->bottom, fFrameLimits.bottom);
*/
  SectRect(newRect, fFrameLimits, newRect);  // 04/07/91
}


// ------------------------------------------------------------------------
void _TPictTracker::RectToView(Rect &aRect, Rect &newRect)
{
  VRect aVRect;

  RectToVView(aRect, aVRect);
  TMainView(fView)->ViewToQDRect(aVRect, newRect);
}


// ------------------------------------------------------------------------
void _TPictTracker::UnZoomVPt(VPoint &itsVPoint)
{
  Fixed zoomFactor;

  zoomFactor = TMainView(fView)->GetZoomFactor();
  if (zoomFactor != kFix1)
  {
    itsVPoint.h = FixDiv(itsVPoint.h, zoomFactor);
    itsVPoint.v = FixDiv(itsVPoint.v, zoomFactor);
   }
}

static char gEdgeFlags[] = {1, 2, 4, 8, 3, 9, 6, 12, 0, 0, 0};
// ------------------------------------------------------------------------
void _TPictTracker::AdjustRect(Rect &theRect, VPoint &delta)
{
  int flags = gEdgeFlags[fPictPart];

  if ((flags & 1) != 0)
    theRect.top += delta.v;
  if ((flags & 2) != 0)
    theRect.left += delta.h;
  if ((flags & 4) != 0)
    theRect.bottom += delta.v;
  if ((flags & 8) != 0)
    theRect.right += delta.h;
#ifdef NEVER
  switch (fPictPart)
  {
  case kTopLeftCnr:
    theRect.left += delta.h;  // drop through
  case kTopEdge:
    theRect.top += delta.v;
    break;

  case kTopRightCnr:
    theRect.top += delta.v;  // drop through
  case kRightEdge:
    theRect.right += delta.h;
    break;

  case kBtmLeftCnr:
    theRect.bottom += delta.v;  // drop through
  case kLeftEdge:
    theRect.left += delta.h;
    break;

  case kBtmRightCnr:
    theRect.right += delta.h;  // drop through
  case kBtmEdge:
    theRect.bottom += delta.v;
    break;
  }
#endif
}


// ------------------------------------------------------------------------
TCommand _TPictTracker::TrackMouse(TrackPhase aTrackPhase,
           VPoint &anchorPoint, VPoint &previousPoint, VPoint &nextPoint,
           bool mouseDidMove, EventInfo &info)
{
  VPoint delta;
  TSelection theSelection;
  TTextDocument theDocument = TTextDocument(fView->fDocument);

  if (aTrackPhase == trackPress)
  {
    // 03/03/94 [21433] wait(see TrackFeedback)!   TMainView(fView)->ClearHighlighting(TRUE);
    theDocument->DoneTyping();
    theSelection = theDocument->StartNewSelection();
    theSelection->SingleClick(fPicView, nextPoint);
    theSelection->fChanged = TRUE;
    theSelection->DoSetupLevels();
    theDocument->SetTextHandler();
    theDocument->SetCurrentStyle();
    fPicView->fInTracker = TRUE; // 24/04/91 inhibit highlight in autoscroll
    fView->Focus();
  }
// 14/01/91 else if (aTrackPhase == trackMove && fPictPart != kNoPart)
  else if (fPictPart != kNoPart)
  {
    // 14/01/91 hysteresis test added for 2pt movement on click
    delta = nextPoint;
    SubVPt(anchorPoint, delta);
//    fHasMoved = fHasMoved || abs(delta.h) >= 20 || abs(delta.v) >= 20;

// 29/05/91 use anchor rather than previous to avoid accumulating rounding errors
//    delta = nextPoint;
//    SubVPt(previousPoint, delta);
    UnZoomVPt(delta);
    MoveRect(fPicFrame, fXPicFrame);  // 29/05/91 add delta to orig. rects
    MoveRect(fPicRect, fXPicRect);    // 29/05/91
    if (fPictPart == kOverFrame)
    {
      OffsetRect(fPicFrame, delta.h, delta.v);
      if (!EmptyRect(fPicRect) && !fInline)
        OffsetRect(fPicRect, delta.h, delta.v);
    }
    else
    {
      AdjustRect(fPicFrame, delta);
      if (!EmptyRect(fPicRect))
      {
        if (fScaleKey)
          AdjustRect(fPicRect, delta);
      }
    }
    // 24/04/91 get scales to feedback the drag
    SubPt(fClickOffset, nextPoint);
    if (fPictPart == kTopEdge || fPictPart == kTopLeftCnr || fPictPart == kTopRightCnr)
      nextPoint.h -= GetVLineThickness();
  }
  if (aTrackPhase == trackRelease)
  {
    bool noChange = // 03/03/94 (!fHasMoved) || 
         (EqualRect(fPicFrame, fXPicFrame) && EqualRect(fPicRect, fXPicRect));

    fPicView->fInTracker = FALSE;        // 24/04/91 allow highlight again
    // 11/08/95  TMainView(fView)->ClearHighlighting(!fHasMoved); // 03/03/94 moved from start & was TRUE
    if (noChange)
    {
      // 11/08/95 [26054] Restore highlight here if we are not going to do it in the command
      theDocument->GetNewSelection()->Highlight(TMainView(fView), kRedraw); // 11/08/95 noChange);
#if SIDEBAR == 1
      fPicView->DoEndClick();
#endif
      return gNoChanges;
    }
  }
  return this;
}


// ------------------------------------------------------------------------
void _TPictTracker::TrackFeedback(VPoint &anchorPoint, VPoint &nextPoint, bool turnItOn, bool mouseDidMove)
{
  if (mouseDidMove && fView->Focus())
                   // 02/11/95 when another window on top, pic view was focussed
  {
    Rect aRect;

    Synchronize();
    RectToView(fPicFrame, aRect);
    InvertTheFrame(NULL, &aRect, 11);
    if (fPicView->fSelected && !fHasMoved)   // 03/03/94 [21433] turn off highlight
    {
      // 11/08/95      RectToView(fXPicFrame, aRect);
      // 11/08/95      InvertTheFrame(NULL, &aRect, 11);
      // 11/08/95 wait until the real arc dragging begins, otherwise the highlighting just
      // gets removed for a second until drag kicks in. Also avoid 'backdoor' frame inverting
      TMainView(fView)->ClearHighlighting(TRUE);    // 11/08/95 [26054]
    }
    fHasMoved = TRUE;    // !InsideHysteresis(anchorPoint, nextPoint);
    return;
  }
  PenNormal();
}


// ------------------------------------------------------------------------
static void MapCorner(bool tlORbr, VPoint &nextPoint, VRect &picFrame,
                 VPoint &delta, VRect &limits, VPoint &previousPoint)
{
  VPoint p1, p2;
  VPoint corner;
  bool computeV;
  double gradient, val1, val2;

  corner = nextPoint;
  { 
    p1.h = picFrame.left;
    p1.v = picFrame.top;
    p2.h = picFrame.right;
    p2.v = picFrame.bottom;
    computeV = (delta.h > delta.v);
    val1 = (p2.h - p1.h);
    val2 = (p2.v - p1.v);
    gradient = val1 / val2;  // 30/05/90

    if (!tlORbr)
    {
      p1.v = picFrame.bottom;
      p1.h = picFrame.left;
      computeV = (abs(delta.h) <= abs(delta.v));
      gradient = -gradient;
    }
  }

  if (computeV)
  {
    val1 = (nextPoint.h - p1.h);
    corner.v = int(val1 / gradient) + p1.v;  // 30/05/90
  }
  else
  {
    val1 = (nextPoint.v - p1.v);
    corner.h = int(val1 * gradient) + p1.h;  // 30/05/90
  }

  if (PtInVRect(corner, limits))
    nextPoint = corner;
  else
    nextPoint = previousPoint;
}


// ------------------------------------------------------------------------
void _TPictTracker::TrackConstrain(VPoint &anchorPoint,
                                 VPoint &previousPoint, VPoint &nextPoint)
{
  VRect limits;
  VRect picFrame;
  VPoint delta;
  int delta1, delta2;

  // 05/10/90 moved, and now sets up fClickOffset with distance from hotspot
  // to the point where the dragging is taking place
  {
    if (fClickOffset.h == MAXINT)
    {
        // 28/05/90 - new AnchorMouse() local proc
        VRect theRect;
        int flags;

        fClickOffset = anchorPoint;
        RectToVView(fPicFrame, theRect);
        flags = gEdgeFlags[fPictPart];
        if ((flags & 1) != 0)
          anchorPoint.v = theRect.top;
        if ((flags & 2) != 0)
          anchorPoint.h = theRect.left;
        if ((flags & 4) != 0)
          anchorPoint.v = theRect.bottom;
        if ((flags & 8) != 0)
          anchorPoint.h = theRect.right;
#ifdef NEVER
        switch (fPictPart)
        {
          case kTopRightCnr:
              anchorPoint.h = theRect.right;  // fall through...
          case kTopEdge:
              anchorPoint.v = theRect.top; break;

          case kTopLeftCnr:
              anchorPoint.v = theRect.top;  // fall through...
          case kLeftEdge:
              anchorPoint.h = theRect.left; break;

          case kBtmLeftCnr:
              anchorPoint.h = theRect.left;  // fall through...
          case kBtmEdge:
              anchorPoint.v = theRect.bottom; break;

          case kBtmRightCnr:
              anchorPoint.v = theRect.bottom;  // fall through...
          case kRightEdge:
              anchorPoint.h = theRect.right; break;
        }
#endif
        previousPoint.v = anchorPoint.v;
        previousPoint.h = anchorPoint.h;
        SubVPt(anchorPoint, fClickOffset);
      }
      SubVPt(fClickOffset, nextPoint);
      // end if inline AnchorMouse() local proc
  }

  MoveRect(limits, fTrackerRect);
  PinVRect(limits, nextPoint);
  delta = nextPoint;
  SubVPt(previousPoint, delta);
  RectToVView(fXPicFrame, picFrame);
  AddVPt(fClickOffset, nextPoint);    // 12/04/91 30/05/91 moved up
  if ((delta.v != 0) || (delta.h != 0))
  {
    bool tlOrBr = FALSE;

    switch (fPictPart)
    {
    case kOverFrame:
      if (fInline)
      {
        delta1 = anchorPoint.v - picFrame.top;
        delta2 = picFrame.bottom - anchorPoint.v;
        if (nextPoint.v - delta1 < limits.top)
          nextPoint.v = limits.top + delta1;
        else if (nextPoint.v + delta2 > limits.bottom)
          nextPoint.v = limits.bottom - delta2;
        nextPoint.h = anchorPoint.h;
      }
      else
      {
        delta1 = anchorPoint.h - picFrame.left;
        delta2 = picFrame.right - anchorPoint.h;
        if (nextPoint.h - delta1 < limits.left)
          nextPoint.h = limits.left + delta1;
        else if (nextPoint.h + delta2 > limits.right)
          nextPoint.h = limits.right - delta2;
        nextPoint.v = anchorPoint.v;
      }
      break;
    case kTopLeftCnr:
    case kBtmRightCnr:   // 18/05/90 - was missing...
      tlOrBr = TRUE;     // 14/05/91 run on ....
//      if (fConstrainKey)
//        MapCorner(TRUE, nextPoint, picFrame, delta, limits, previousPoint);
//      break;

    case kTopRightCnr:
    case kBtmLeftCnr:   // 18/05/90 - was missing...
      if (fConstrainKey)
        MapCorner(tlOrBr, nextPoint, picFrame, delta, limits, previousPoint);
      break;
    }
  }
}


// ------------------------------------------------------------------------
void _TPictTracker::DoIt()
{
  // 02/01/91 rewritten
  TSelection selection;
  TPictStyle changes;
  bool scaled;
  TTextDocument doc = TTextDocument(fChangedDocument);

  doc->CommitLastDocCommand();          // 16/04/93 from CommitLastCommand
  selection = doc->GetSelection(TRUE);
  changes = TPictStyle(doc->GetCurrentChanges(FALSE));
        // 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted
  if (fPictPart == kOverFrame)
  {
    changes->fDefinedInPict |= kUserAlign;
    changes->fDefinedInPict &= ~kOwnWhichAlign;   // 26/11/92
    if (fInline)
      changes->fUserAlign.v += (fPicFrame.top - fXPicFrame.top);
    else
      changes->fUserAlign.h = fPicFrame.left;
  }
  else
  {
    int attr = kVScale;
    VHSelect vhs;

    scaled = FALSE;
    for (vhs = v; vhs <= h; vhs++)
    {
      // inline TestIfScaled(v, kVScale); TestIfScaled(h, kHScale);
      int n1 = LengthRect(fPicRect, vhs);
      int n2 = LengthRect(fXPicRect, vhs);

      if (n1 != n2)
      {
        scaled = TRUE;
        changes->fDefinedInPict |= attr;
        n1 = ((n1 * 100) + 50) / n2;       // new percentage
        n2 = fScaleFactor.vh[vhs];
        changes->fScaleFactor.vh[vhs] = DoScale(n1, n2);   // scale by previous factor

        //changes->fScaleFactor.vh[vhs] = ((n1 * 100) + 50) / n2;
        //n1 = fScaleFactor.vh[vhs];
        //if (n1 != 100)
        //  changes->fScaleFactor.vh[vhs] = DOSCALE(n1 * changes->fScaleFactor.vh[vhs]);

        // 29/10/92 - stop large crop values dissappearing the picture on zoom down
        changes->ZoomCropRect(vhs, changes, n2);
      }
      attr = kHScale;  // ready for h iteration of the loop
    }
    if (!scaled)
    {
      for (int i = 0; i < 4; i++)
        if (((int *)&fPicFrame)[i] != ((int *)&fXPicFrame)[i])
        {
          int diff = ((int *)&fPicFrame)[i] - ((int *)&fXPicFrame)[i];

          ((int *)&changes->fCropRect)[i] = ((int *)&fCropRect)[i] + (i <= 1 ? diff : -diff);
          changes->fDefinedInPict |= kTopCrop << i;
        }
#ifdef NEVER
      attr = kTopCrop;
      // inline TestIfTLCropped(v, kTopCrop); TestIfTLCropped(h, kLeftCrop);
      for (vhs = v; vhs <= h; vhs++)
      {
        if (fPicFrame.topLeft->vh[vhs] != fXPicFrame.topLeft->vh[vhs])
        {
          changes->fDefinedInPict |= attr;
          changes->fCropRect.topLeft->vh[vhs] =
               fCropRect.topLeft->vh[vhs] + fPicFrame.topLeft->vh[vhs] -
                                            fXPicFrame.topLeft->vh[vhs];
        }
        attr = kLeftCrop;  // ready for h iteration of the loop
      }

      attr = kBtmCrop;
      // inline TestIfBRCropped(v, kBtmCrop); TestIfBRCropped(h, kRightCrop);
      for (vhs = v; vhs <= h; vhs++)
      {
        if (fPicFrame.botRight->vh[vhs] != fXPicFrame.botRight->vh[vhs])
        {
          changes->fDefinedInPict |= attr;
          changes->fCropRect.botRight->vh[vhs] =
               fCropRect.botRight->vh[vhs] + fXPicFrame.botRight->vh[vhs] -
                                            fPicFrame.botRight->vh[vhs];
        }
        attr = kRightCrop;  // ready for h iteration of the loop
      }
#endif
    }
  }
  doc->InstallStyleChange(changes, fCmdNumber); // 6/5/92

}


// ------------------------------------------------------------------------
void _TPictTracker::UndoIt()
{
  TTextDocument(fChangedDocument)->ToggleChanges(fCmdNumber); // 6/5/92, 02/01/91
}


// ------------------------------------------------------------------------
void _TPictTracker::RedoIt()
{
  UndoIt();
}

