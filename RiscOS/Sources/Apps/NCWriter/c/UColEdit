/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include "UColEdit.h"

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>

#ifdef TABLES

#define kSpanDlgID   27
#define kColStyleStrs 52
#define cSpanMatrix 128
     // 30/04/92 2 cSpan command numbers needed for 2 menu entries

#define gIDKeep I_('K', 'e', 'e', 'p')
#define gIDspns I_('s', 'p', 'n', 's')

typedef struct TSelectedItemList
   {
      unsigned a;
      unsigned b;
      unsigned c;
      unsigned d;
      unsigned e;
      unsigned f;
      unsigned g;
      unsigned h;
   } TSelectedItemList;

// ------------------------------------------------------------------------
void IUColumns(void)
{
}


// ------------------------------------------------------------------------
_TColStyleDlgHpr::_TColStyleDlgHpr(TDialogView theDialog,
  TStyleFormat theStyle, TStyleFormat theChanges, TStyleTypes theType) :
           (theDialog, theStyle, theChanges, theType)
{}


// ------------------------------------------------------------------------
void _TColStyleDlgHpr::WriteToDialog(TView aDialog, CmdNumber aCmd)
{
  _TStyleDlgHelper::WriteToDialog(aDialog, aCmd);

  aDialog->WriteCheckBox(gIDKeep,
    TColumnStyleFormat(TTextAttrsDlg(aDialog)->fStyleFormat)->fKeepTogether);
}


// ------------------------------------------------------------------------
void _TColStyleDlgHpr::DoChoice(TView origView, int itsChoice)
{
  TColumnStyleFormat changes = TColumnStyleFormat(fChanges);

  if (origView->fIdentifier == gIDKeep)
  { 
    changes->fDefinedInStyle |= kKeepTogether;
    changes->fKeepTogether = TCheckBox(origView)->IsOn();
    ResetStyle();
  }
  else
    _TStyleDlgHelper::DoChoice(origView, itsChoice);
}


// ------------------------------------------------------------------------
_TAddRowColCommand::_TAddRowColCommand(TTextDocument itsDocument,
                    TMainView itsMainView, TCurrency itsCurrency,
                    CmdNumber itsCmdNumber, bool pos)
                  : (itsCmdNumber, itsDocument)
{
  fCurrency = itsCurrency;
  fMainView = itsMainView;
  fPos = pos;
  fStructure =
       TColumnStructure(itsDocument->GetStructureReadWrite(itsCurrency));
}


// ------------------------------------------------------------------------
void _TAddRowColCommand::ToggleState(void)
{
  TCellRect cellCoords;
  TSelShape scope;

  if (fCmdNumber == cAddRow)
    scope = kRowWise;
  else if (fCmdNumber == cAddColumn)
    scope = kColumnWise;
  else
    scope = kWithinCell;

  cellCoords = fCellCoords;
  fStructure->ToggleCells(fCurrency, cellCoords, scope, this, NULL, NULL);
               // 13/08/92 added currency 28/08/92 added command 02/09/92 added null nodes
}


// ------------------------------------------------------------------------
void _TAddRowColCommand::CommitState(void)
{
  TCellRect cellCoords;
  if (fCmdNumber == cAddRow)
    fStructure->CommitRow(fCurrency, fCellCoords.startRow, NULL, NULL, this);
                                                            // 03/09/92 extra params
  else if (fCmdNumber == cAddColumn)
    fStructure->CommitColumn(fCurrency, fCellCoords.startCol, NULL, NULL, this);
  else
  {
    cellCoords = fCellCoords;
    fStructure->CommitCells(fCurrency, cellCoords, this);
  }
}


// ------------------------------------------------------------------------
void _TAddRowColCommand::DoCommand(TSelection selection)
{
  TCursorNode aCursorNode;
  TCursorNode anchorNode; // 21/11/91 was activeNode
  TCurrency firstNewCell;
  TCurrency lastNewCell;
  int row, column;
  TCellRect cellCoords;
  PCellItem cellStruct;

  selection->GetNodes(fCurrency, anchorNode, aCursorNode); // 21/11/91 changed params

  fStructure->GetAllCells(cellCoords);
  TColCursorNode(aCursorNode)->GetRowCol(fStructure, row, column);
  if (fCmdNumber == cAddRow)          // 19/03/91 put back
  {
    cellCoords.startRow = row + int(fPos);
    cellCoords.endRow = cellCoords.startRow;
    fStructure->AddNewRow(row - int(!fPos), fCurrency);  // 23/05/91 moved up
    firstNewCell = fStructure->AtRowCol(row, 1)->cell;         // 25/04/91
    fNewTarget = fStructure->AtRowCol(cellCoords.startRow, 1)->cell;
  }
  else
  {
    cellStruct = fStructure->AtRowCol(row, column);
    cellCoords.startCol = column + int(fPos);
    cellCoords.endCol = cellCoords.startCol;
    fStructure->AddNewColumn(column - int(!fPos), fCurrency);  // 23/05/91 moved up
    firstNewCell = fStructure->AtRowCol(1, fStructure->FindMasterCell(1, column))->cell;
    fNewTarget = (fStructure->AtRowCol(1,  // 01/10/92 row, put in row 1 for tables over page
       fStructure->FindMasterCell(1, cellCoords.startCol)))->cell;  // 08/07/91 FMC
  }
  lastNewCell = fStructure->AtRowCol(fStructure->fNumberOfRows,
     fStructure->FindMasterCell(fStructure->fNumberOfRows, fStructure->fNumberOfColumns))->cell;
#ifdef DRAGDROP
  fStructure->MarkToTop(fCurrency);
#endif
  fDocument->InitialSelection(fMainView, firstNewCell, lastNewCell);// 24/03/92
  // 2/12/91 fixes bug adding row/col to table in H/F
  fDocument->GetNewSelection()->fViewId.fId = selection->fViewId.fId;
  // 17/06/91  fDocument->GetNewSelection()->fReformatType = kSelNormal;  // 01/05/91 slow
  fCellCoords = cellCoords;
}


// ------------------------------------------------------------------------
void _TAddRowColCommand::DoPostCommand(void)
{
  fDocument->InitialCursor(fMainView, fNewTarget, 0);
    // fn1 was TRUE, 24/03/92 zeroRect - may be better to set cursor like TNewStructureCmd!!!
  fDocument->GetNewSelection()->fReformatType = kSelNormal; // 01/05/91 added
}


// ------------------------------------------------------------------------
_TSpanColumnCommand::_TSpanColumnCommand(TTextDocument itsDocument,
         TCurrency itsCurrency, TMainView itsMainView, int newNumberOfSpans)
       : (itsDocument, itsMainView, itsCurrency, cSpan, TRUE)
{
  fNewSpans = newNumberOfSpans;
#ifndef ZERO_OBJ
  fSelectionCopy = NULL;
#endif
}


// ------------------------------------------------------------------------
void _TSpanColumnCommand::ToggleState(void)
{
  int oldSpans;
  TCellRect cellCoords;
  PCellItem cellItem;

  cellCoords = fCellCoords;
  cellItem = fStructure->AtRowCol(cellCoords.startRow, cellCoords.startCol);

  oldSpans = cellItem->spanCount;
  cellItem->spanCount = fNewSpans;
  fNewSpans = oldSpans;

  _TAddRowColCommand::ToggleState();

  cellItem = fStructure->AtRowCol(cellCoords.startRow, cellCoords.startCol);
  cellItem->colChange = TRUE;
}


// ------------------------------------------------------------------------
void _TSpanColumnCommand::DoCommand(TSelection selection)
{
  TCursorNode aCursorNode;
  TCursorNode activeNode;
  TCurrency firstCell;
  TCurrency lastCell;
  int row, column;
  TCellItem newCell;
  int limit;
  int i;
  int oldSpans;
  PCellItem cellItem;
  int szVal;

  selection->GetNodes(fCurrency, aCursorNode, activeNode);
  TColCursorNode(aCursorNode)->GetRowCol(fStructure, row, column);
  cellItem = fStructure->AtRowCol(row, column);
  firstCell = cellItem->cell;
  oldSpans = cellItem->spanCount;
  if (column + fNewSpans > fStructure->fNumberOfColumns)
    fNewSpans = fStructure->fNumberOfColumns - column;
  cellItem->spanCount = fNewSpans;
  cellItem->colChange = TRUE;

  szVal = Min(oldSpans, fNewSpans);
  for (i = 0; i <= szVal; i++)
  {
    cellItem = fStructure->AtRowCol(row, column + i);
    cellItem->undoState = cellItem->hidden;
  }

  lastCell = firstCell;
  limit = oldSpans;

  for (i = oldSpans + 1; i <= fNewSpans; i++)
  {
    cellItem = fStructure->AtRowCol(row, column + i);
    limit = cellItem->spanCount + i;
    cellItem->undoState = cellItem->hidden;
    cellItem->hidden = TRUE;
    if (cellItem->cell != 0)
      lastCell = cellItem->cell;
  }

  for (i = fNewSpans + 1; i <= limit; i++)
  {
    fStructure->MakeNewCell(newCell, kWithinCell, fCurrency);
    *(fStructure->AtRowCol(row, column + i)) = newCell;
    lastCell = newCell.cell;
  }

#ifdef DRAGDROP
  fStructure->MarkToTop(fCurrency);  // 23/12/93 [21209] whoops - forgotten
#endif
  // FailNIL(fSelectionCopy = TSelection(selection->Clone()));
  selection->MakeClone(&fSelectionCopy);
  fDocument->InitialSelection(fMainView, firstCell, lastCell); // 24/03/92

  fCellCoords.startRow = row;
  fCellCoords.startCol = column;
  fCellCoords.endRow = row;
  fCellCoords.endCol = column + limit;

  fNewSpans = oldSpans;
}


// ------------------------------------------------------------------------
void _TSpanColumnCommand::DoPostCommand(void)
{
  fSelectionCopy->SetTheCursor(TRUE);
  fDocument->ResetSelection(fSelectionCopy);
}


// ------------------------------------------------------------------------
_TColFormat::_TColFormat(TMainView itsView, int itsItemSize)
                      : (itsView, itsItemSize)
{
#ifndef ZERO_OBJ
  fNumberOfColumns = 0;
  fPrivateDataSize = 0;
  ClearRect(fRCBorderEnds);
#endif
}


// ------------------------------------------------------------------------
void _TColFormat::DoRead(int aRefNum, long remainder, int version)
{
  if (version < 2)
  {
    int oldSize;

    _TFormat::DoRead(aRefNum, remainder, version);        // read the main part
    oldSize = fSize * fItemSize;
    SetPermHandleSize(&fPtrToArray, oldSize + fPrivateDataSize);
    FRead(aRefNum, fPrivateDataSize, ((char *)fPtrToArray) + oldSize);
  }
  else
    _TFormat::DoRead(aRefNum, remainder, 1);    // read the main part
}


// ------------------------------------------------------------------------
void _TColFormat::DoWrite(int aRefNum, long remainder)
{
  // 08/08/90 - new method to set up private data size
  fPrivateDataSize = GetHandleSize(fPtrToArray) - fSize * fItemSize;

  _TFormat::DoWrite(aRefNum, remainder);
}


// ------------------------------------------------------------------------
long _TColFormat::DoNeedDiskSpace(long dataForkBytes)
{
  // 08/08/90 - new method to add private data size
  return _TFormat::DoNeedDiskSpace(GetHandleSize(fPtrToArray) -
                                    (fSize * fItemSize) + dataForkBytes);
}


// ------------------------------------------------------------------------
void _TColFormat::DoReadArrayPart(int aRefNum, int version)
{
  int oldSize = fSize * fItemSize;

  if (version >= 2)
  {
    //  as array but also copy the private data onto the end of the array
    oldSize += fPrivateDataSize;

    SetPermHandleSize(&fPtrToArray, oldSize);
  }
  FRead(aRefNum, oldSize, fPtrToArray);
}


// ------------------------------------------------------------------------
void _TColFormat::DoWriteArrayPart(int aRefNum)
{
  FWrite(aRefNum, fPrivateDataSize + fSize * fItemSize, fPtrToArray);
}


// ------------------------------------------------------------------------
PColFormatData _TColFormat::InfoAt(int column)
{
  return PColFormatData(int(fPtrToArray) + GetHandleSize(fPtrToArray) -
               ((fNumberOfColumns - column + 1) * sizeof(TColFormatData)));
}


// ------------------------------------------------------------------------
void _TColFormat::DeleteColumn(int column)
{
/* the following is better:
  Ptr thisCol, nextCol;

  thisCol = Ptr(InfoAt(column));
  nextCol = Ptr(InfoAt(column + 1));
  memmove(thisCol, nextCol,
                   (fNumberOfColumns - column) * sizeof(TColFormatData));
  fNumberOfColumns --;
  ChangeHandleSize(&fPtrToArray, -sizeof(TColFormatData));  // 22/01/91
*/
  if (column <= fNumberOfColumns)  // 16/05/96 for delete column before Reformat (in Word input)
  {
    DeleteSlice((char *)InfoAt(column) - (char *)fPtrToArray, sizeof(TColFormatData));
    fNumberOfColumns--;
  }
}


// ------------------------------------------------------------------------
void _TColFormat::SetNumberOfCols(int numOfCols, TColumnStyleFormat itsStyle)
{
  int i;
  int oldCols;
  Fixed posn;
  PColFormatData data;

  oldCols = fNumberOfColumns;
  if (numOfCols != oldCols)
    ChangeHandleSize(&fPtrToArray,
                     (numOfCols - oldCols) * sizeof(TColFormatData));
  fNumberOfColumns = numOfCols;
  for (i = oldCols + 1; i <= numOfCols; i++)
  {
    posn = itsStyle->ColPosition(i);
    data = InfoAt(i);
    data->columnRtEdge = posn;
    data->columnLimit = 0;
    data->ruleType.fRule = kNoRule;         // 22/01/91
    data->ruleType.fPen = kOnePtPen;         // 22/01/91
    data->ruleType.fShort = FALSE; // 21/07/92 adding this gives better code!
    data->adornment = 0;
    for (int al = kAlignLeft; al <= kFill; al++)
      data->columnSubWidths[al] = 0;
  }
}


// ------------------------------------------------------------------------
void _TColFormat::SetColumnLimit(int column, Fixed limit)
{
  (InfoAt(column))->columnLimit = limit;
}


// ------------------------------------------------------------------------
Fixed _TColFormat::GetColumnLimit(int column)
{
  return (InfoAt(column))->columnLimit;
}


// ------------------------------------------------------------------------
bool _TColFormat::HiddenCol(int c, TColumnStructure colStruct)
{
  for (int r = 1; r <= colStruct->fNumberOfRows; r++)
  {
    PCellItem itm = colStruct->AtRowCol(r, c);

    if (!itm->hidden || !itm->colChange)
      return FALSE;
  }
  return TRUE;
}


// ------------------------------------------------------------------------
void _TColFormat::Distribute(TColumnStructure colStruct, int firstCol,
                             int lastCol, Fixed spare)
{
  int c;
  Fixed prevRtEdge;
  Fixed currLimit = 0;
  int numberOfColumns;
  Fixed slop;

  numberOfColumns = lastCol - firstCol + 1;
  for (c = firstCol; c <= lastCol; c++)
  {
    if (HiddenCol(c, colStruct))
      numberOfColumns --;
  }
  slop = FixDiv(spare, ToFixed(numberOfColumns));    // 02/07/91 was up the pole
  if (firstCol == 1)
  {
    prevRtEdge = 0;
    currLimit = 0;
  }
  else
  {
    prevRtEdge = (InfoAt(firstCol - 1))->columnRtEdge;
    currLimit = GetColumnLimit(firstCol - 1);
  }

  for (c = firstCol; c <= lastCol; c++)
  { 
    PColFormatData data = InfoAt(c);

    if (HiddenCol(c, colStruct))
      data->columnRtEdge = prevRtEdge;
    else
    {
      data->columnRtEdge = prevRtEdge + 
                                     (data->columnLimit - currLimit) + slop;
      if (data->adornment != 0)
        data->columnRtEdge +=
           GetBorderWidth(adnLineLeft, data->adornment, data->ruleType) +
           GetBorderWidth(adnLineRight, data->adornment, data->ruleType);

      prevRtEdge = data->columnRtEdge;
    }
    currLimit = data->columnLimit;
  }
}


// ------------------------------------------------------------------------
Fixed _TColFormat::GetColLtEdge(int column)
{
  PColFormatData data = InfoAt(column);
  Fixed leftBorder = (column <= fNumberOfColumns ?
        GetBorderWidth(adnLineLeft, data->adornment, data->ruleType) : 0);

  return leftBorder + (column == 1 || fNumberOfColumns == 0 ? 0 :
          InfoAt(Min(column - 1, fNumberOfColumns))->columnRtEdge);
}


// ------------------------------------------------------------------------
Fixed _TColFormat::GetColRtEdge(int column)
{
  return (column == 0 || fNumberOfColumns == 0 ? 0 :
          InfoAt(column)->columnRtEdge);
}


// ------------------------------------------------------------------------
Fixed _TColFormat::GetColWidth(int column)
{
  return (fNumberOfColumns == 0 ? FixPointVal(720) :
              (GetColRtEdge(column) - GetColLtEdge(column)));
}


// ------------------------------------------------------------------------
Fixed _TColFormat::GetColMinWidth(int column)
{
  Fixed GetColMinWidth_r;

  if (fNumberOfColumns == 0)
    GetColMinWidth_r = FixPointVal(720);
  else
    GetColMinWidth_r = GetColumnLimit(column) - (column == 1 ? 0 : GetColumnLimit(column - 1));

  return GetColMinWidth_r;
}


/* ------------------------------------------------------------------------
int _TColFormat::GetWidthForReformat(int fitWidth, PCellItem cellStruct,
      int row, int column, TColumnStyleFormat style)
{
  return 0;
}
*/

// 09/02/93 [20620] common up code in tables & TFormat
// ------------------------------------------------------------------------
void _TColFormat::DoApplyPartStyles(TStructure structure, 
                               TCurrency partCurrency, 
                               Attributes permittedAttrs,
                               TStyleSet styleSet)
 // 09/02/93 new method - the difference between table & TFormat DoGetCompositeStyle
{
  Rect custom;

  PCellRect rect = PCellRect(&custom);

  ClearRect(custom); // 2/4/92
  ApplyPartStyles(structure, permittedAttrs, styleSet, kAllColsBody, custom);
//  ApplyRowColStyles(kAllColsBody, style, structure, custom, styleSet); // 2/4/92
  TColumnStructure(structure)->FindCell(partCurrency,
                                       rect->startRow, rect->startCol);
// 21/11/91 2 new stmts added
  // 10/03/94 [21450] As a consequence of GetPartStyle doing things 'properly', 
  // ie compensating for hidden rows, the following over-compensated, so is no longer needed
  // rect->startRow = TColumnStructure(structure)->GetRowColNumber(rect->startRow, TRUE);
  // rect->startCol = TColumnStructure(structure)->GetRowColNumber(rect->startCol, FALSE);
  rect->endRow = rect->startRow;
  rect->endCol = rect->startCol;
  ApplyPartStyles(structure, permittedAttrs, styleSet, kColPart, custom);
  ApplyPartStyles(structure, permittedAttrs, styleSet, kRowPart, custom);
//  ApplyRowColStyles(kColPart, styleSet->fStyle, structure, custom, styleSet); // 2/4/92
//  ApplyRowColStyles(kRowPart, styleSet->fStyle, structure, custom, styleSet); // 2/4/92
//  style->fDefined &= ~kBullet;     // 22/01/91 can? have bullets in tables
}

// ------------------------------------------------------------------------
TStyleFormat _TColFormat::GetNewStyle(TCurrency currency, int part, Rect& custom)
{
  TStyleFormat theStyle = _TFormat::GetNewStyle(currency, part, custom);

  // Part styles are not supposed to have kHasAdornment set, as applyoverrides then
  // ignores the borders when calling GetCurrentChanges to put values in Borders
  // dialogue (when looking at Save Style-d table styles) 27/01/94 [21364]
  // 10/03/94 However that causes GetCompositeStyle to get totally confused,
  // so for time being the part styles have kHasAdornment and the borders dialogue
  // goes wrong! [21450]
  if (part == kRowPart || part == kColPart)
    theStyle->fDefined |= kHasAdornment;
  return theStyle;
}

// ------------------------------------------------------------------------
void _TColFormat::SetColumnSubWidth(TCurrency cellCurrency, int column, TAlignment alignment,
                                          Fixed width)
{
  PColFormatData data = InfoAt(column);

#ifdef MATHS
  if (Curr_fType(cellCurrency) == kMathStruct)
    alignment = kAlignLeft;    // 29/06/92
#endif
  if (width > data->columnSubWidths[alignment])
    data->columnSubWidths[alignment] = width;
  else if (width < 0)
    data->columnSubWidths[alignment] = 0;
}

// ------------------------------------------------------------------------
Fixed _TColFormat::GetColumnSubWidth(TCurrency cellCurrency, int column, TAlignment alignment)
{
#ifdef MATHS
  if (Curr_fType(cellCurrency) == kMathStruct)
    return GetColMinWidth(column);   // 29/06/92
#endif
  return (fNumberOfColumns == 0 ? FixPointVal(720) :
                               InfoAt(column)->columnSubWidths[alignment]);
}

// ------------------------------------------------------------------------
void _TColFormat::SetColBorders(int column, TRuleType itsRuleType,
                                 CntlAdornment itsAdornment)
{
  PColFormatData data = InfoAt(column);

  data->ruleType = itsRuleType;
  data->adornment = itsAdornment;
}

// ------------------------------------------------------------------------
void _TColFormat::GetColBorders(int column, TRuleType &itsRuleType,
                                 CntlAdornment &itsAdornment)
{
  PColFormatData data = InfoAt(column);

  itsRuleType = data->ruleType;
  itsAdornment = data->adornment;
}


// ------------------------------------------------------------------------
_TColumnStructure::_TColumnStructure(TDocument itsDocument,
          /* TCurrency itsParent, TCurrency itsStyle,*/
          TStructTypes theCellType, TStyleTypes theCellKind)
        : (itsDocument, /* itsParent, itsStyle,*/ sizeof(TCellItem))
{

  fNumberOfRows = 1;
#ifndef ZERO_OBJ
  fNumberOfColumns = 0;
  fUndoStructure = NULL;
  fUndoCoords = *PCellRect(&gZeroRect);
#endif
  fCellType = theCellType;
  fCellKind = theCellKind;       // 19/09/90 new field initialised
}

// ------------------------------------------------------------------------
long _TColumnStructure::DoNeedDiskSpace(long dataForkBytes)
{
  return _TStructure::DoNeedDiskSpace(dataForkBytes);
}

// ------------------------------------------------------------------------
void _TColumnStructure::DoRead(int aRefNum, long remainder, int version)
{
  _TStructure::DoRead(aRefNum, remainder, version);        // the inherited read
  ClearRect(*((Rect *)&fUndoCoords));              // 22/05/91 for paste
  fUndoStructure = NULL;                           // 08/11/91 repair
}

// ------------------------------------------------------------------------
void _TColumnStructure::DoWrite(int aRefNum, long remainder)
{
  _TStructure::DoWrite(aRefNum, remainder);
}


// ------------------------------------------------------------------------
TCurrency _TColumnStructure::GetEnd(TCurrency currency, bool start)
{
  TCurrency item = (start ? AtRowCol(1, 1) :
                            AtRowCol(fNumberOfRows, fNumberOfColumns))->cell;

  return (item == 0 ? item : GetStructureReadOnly(item)->GetEnd(item, start));
      // 14/01/94 [21223] better returning a null currency than crashing
}


// ------------------------------------------------------------------------
int _TColumnStructure::GetAlienTerm(long pos, TCursorNode anchor,
                                TCursorNode activeEnd)
// 27/09/91 new for saving tables as text
{
  TCellRect cellCoords;
  int r = GetHi(pos);
  int c = GetLo(pos);
  int spanCount = AtRowCol(r,c)->spanCount + 1;

  GetSelectedCells(cellCoords, anchor, activeEnd);
  // return (c + AtRowCol(r,c)->spanCount >= cellCoords.endCol ? chLineFeed : chTab);

  // 21/02/95 change interface:
  // -ve means not last cell
  // value = number of cells plus spanners
  return (spanCount > cellCoords.endCol - c ? cellCoords.endCol - c + 1 : -spanCount);
}

#ifdef DRAGDROP
// ------------------------------------------------------------------------
bool _TColumnStructure::WithinSelection(TCursorNode anchor, TCursorNode activeEnd,
                                                                  TCursorNode node)
  // 27/07/93 See if node is (inclusively) between anchor and active ends
{
  TCellRect cellCoords;
  int row, column;

  TColCursorNode(node)->GetRowCol(this, row, column);

  // 05/01/94 [21214] Avoid GetSelectedCells which extends the selection for Undo/Commit,etc
  GetCellsInSelection(cellCoords, anchor, activeEnd, FALSE);

  if (row < cellCoords.startRow || row > cellCoords.endRow ||
          column < cellCoords.startCol || column > cellCoords.endCol)
    return FALSE;
  return TRUE;
}

// ------------------------------------------------------------------------
int _TColumnStructure::WhatsSelected(TCurrency currency,
                                  TCursorNode anchor, TCursorNode activeEnd)
{
  return kTableSelected;
}
#endif

// ------------------------------------------------------------------------
void _TColumnStructure::FindNextVisible(int &row, int &column, int direction)
{
  while(row > 0 && row <= fNumberOfRows &&
                               column > 0 && column <= fNumberOfColumns)
  {
    PCellItem cellItem = PCellItem(AtRowCol(row, column));
    if (!cellItem->hidden)
      break;
    if (cellItem->rowChange)
    {
      // 27/07/92 do the same as cols
      // if (row + direction < 1 || row + direction > fNumberOfRows)
      //   break;
      // 05/08/92 cannot do this, cursor move wants values out of range!
      row += direction;
    }
    else if (cellItem->colChange)
    {
      if (FindMasterCell(row, column) != column)  // 09/07/91 selecting 2 cells
        break;
      // 27/07/92 increments past fNumberOfColumns on deleting columns
      // if (column + direction < 1 || column + direction > fNumberOfColumns)
      //   break;
      // 05/08/92 cannot do this, cursor move wants values out of range!
      column += direction;
    }
    else
      break;
  }
}


// ------------------------------------------------------------------------
TCursorNode _TColumnStructure::NewCursorNode(void)
{
  return new _TColCursorNode(gNullCurrency, kNewCursor, gZeroVPt);
}


// ------------------------------------------------------------------------
void _TColumnStructure::DoCellStep(PCellItem cellStruct, int row, int column,
                                 TCursorNode anchorN, TCursorNode activeEndN,
                                 TObject obj, DoStep procToDo,
                                 TCellRect *cellCoords,
                                 TColumnIterateList *args)
{
  if (!cellStruct->hidden)       // 26/11/90
  {
    // 18/03/94 [21502] Do not pass node to bottom right cell, the cellCoords may have been
    //                  extended past the original activeEnd cell position

    procToDo(obj, cellStruct->cell, PackTwoShorts(row, column),
             anchorN != NULL && cellStruct->cell == anchorN->fCurrency ? anchorN : NULL,
             activeEndN != NULL && cellStruct->cell == activeEndN->fCurrency ?
                                                         activeEndN : NULL, *args);
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::Iterate(TCurrency currency, TCursorNode anchor,
                                TCursorNode activeEnd, bool fromAnchor,
                                TObject obj, DoStep procToDo, ...)
{
  TCellRect cellCoords;
  TSelShape selShape;
  TCursorNode anchorN, activeEndN, temp;
  int t;
  TColumnIterateList *args = (TColumnIterateList *)((char *)&procToDo + sizeof(procToDo));

  anchorN = (anchor == NULL ? NULL : anchor->GetNext());
  activeEndN = (activeEnd == NULL ? NULL : activeEnd->GetNext());
  selShape = GetSelectedCells(cellCoords, anchor, activeEnd);

  if (!fromAnchor)
  {
    temp = anchorN;
    anchorN = activeEndN;
    activeEndN = temp;
    t = cellCoords.startRow;
    cellCoords.startRow = cellCoords.endRow;
    cellCoords.endRow = t;
    t = cellCoords.startCol;
    cellCoords.startCol = cellCoords.endCol;
    cellCoords.endCol = t;
  }

  ForSelectedCellsDo(this, cellCoords, (Action)_TColumnStructure::DoCellStep,
                 anchorN, activeEndN, obj, procToDo, &cellCoords, /* & */args);
}


// ------------------------------------------------------------------------
void _TColumnStructure::DoCellStep2(PCellItem cellStruct, int row, int column,
 TStructure pasteStruct, TCurrency pasteCurrency, TTextDocument clipDocument,
         TObject obj, DoPartStep procToDo, TColumnIteratePartList* args)
{
  if (pasteStruct != NULL)             // 23/05/91 new block for paste span
  {
    int r = TColumnStructure(pasteStruct)->fUndoCoords.startRow;
    int c = TColumnStructure(pasteStruct)->fUndoCoords.startCol;

    // 05/08/93 fUndoCoords is not now updated by InsertSubStructure when fUndoStructure == NULL
    // 05/08/93    if (fUndoStructure != NULL)        // 24/05/91
    {
      r += row - 1;
      c += column - 1;
    }
    if (cellStruct->hidden)
    {
      // 27/06/91 new block
      bool isSpanned;
      bool extended;
      TCellItem newCell;
      int mc;

      extended = (c == TColumnStructure(pasteStruct)->fNumberOfColumns + 1);  // 16/09/91
      mc = TColumnStructure(pasteStruct)->
              FindMasterCell(r, Min(c, TColumnStructure(pasteStruct)->fNumberOfColumns));
      isSpanned = (mc != c) ||
          (extended && (TColumnStructure(pasteStruct)->AtRowCol(r, c - 1)->spanCount > 0));
                                                            // || 16/09/91
      if (isSpanned)
        newCell.cell = 0;
      else
        TColumnStructure(pasteStruct)->
                 MakeNewCell(newCell, kColumnWise, pasteCurrency);
      pasteStruct->InsertSubStructure(1, clipDocument, pasteCurrency,
                       newCell.cell, *(long *)(args->b));   // 05/08/93 frig on frig
      TColumnStructure(pasteStruct)->AtRowCol(r, c)->hidden = isSpanned;
      if (isSpanned && extended)
        TColumnStructure(pasteStruct)->AtRowCol(r, mc)->spanCount--;  // || 16/09/91
    }
    else
    {
      int loopLim;

      procToDo(obj, cellStruct->cell, PackTwoShorts(r, c), *args);
      TColumnStructure(pasteStruct)->AtRowCol(r, c)->spanCount =
                                                  cellStruct->spanCount;

      // 16/09/91 new loop
      loopLim = Min(TColumnStructure(pasteStruct)->fNumberOfColumns, c + cellStruct->spanCount);
      for (int i = c + 1; i <= loopLim; i++)
        TColumnStructure(pasteStruct)->AtRowCol(r, i)->hidden = TRUE;
    }
  }
  else if (!cellStruct->hidden)             // 26/11/90
    procToDo(obj, cellStruct->cell, PackTwoShorts(row, column), *args);
}


// ------------------------------------------------------------------------
void _TColumnStructure::IteratePart(TCurrency currency, int part, Rect &custom,
          TStructure pasteStruct, TCurrency pasteCurr, TTextDocument clipDoc,
          TObject obj, DoPartStep procToDo, ...)
{
  TCellRect cellCoords;
  TColumnIteratePartList *args =
      (TColumnIteratePartList *)((char *)&procToDo + sizeof(procToDo)); // 24/04/91

  if (part == kAllCols)
    GetAllCells(cellCoords);
  else
    cellCoords = *(PCellRect(&custom));

  if (pasteStruct != NULL && TColumnStructure(pasteStruct)->fUndoCoords.startRow == 0)
    TColumnStructure(pasteStruct)->fUndoCoords = cellCoords;     // 23/05/91

  ForSelectedCellsDo(this, cellCoords, (Action)_TColumnStructure::DoCellStep2,
                     pasteStruct, pasteCurr, clipDoc,
                     obj, procToDo, args);
}


// ------------------------------------------------------------------------
void _TColumnStructure::ResetCursors(TCursorNode anchor, TCursorNode activeEnd,
    TCellRect &cellCoords)
{
  ResetCursor(anchor, PackTwoShorts(cellCoords.startRow, cellCoords.startCol), FALSE, FALSE);
  ResetCursor(activeEnd, PackTwoShorts(cellCoords.endRow, cellCoords.endCol), TRUE, FALSE);
}


// ------------------------------------------------------------------------
void _TColumnStructure::DoPasteFromClipboard(TCurrency currency, TCursorNode anchor,
    TCursorNode activeEnd, TTextDocument clipDocument, bool replace, TStructureCmd cmd)
// 08/09/92 new override to get selection sorted out for reformat
{
#ifdef DRAGDROP
  if (fUndoStructure != NULL)
#endif
    _TStructure::DoPasteFromClipboard(currency, anchor, activeEnd, clipDocument,
                               replace, cmd);
#ifdef DRAGDROP
  else
  {
    long ignore;

    PasteFromClipboard(currency, anchor, activeEnd, clipDocument, &ignore, cmd);
    ResetCursors(anchor, activeEnd, fUndoCoords);
  }
#endif
}


// ------------------------------------------------------------------------
bool _TColumnStructure::IsEmpty(void)
{
  return (fSize == 0 || (fNumberOfColumns + fNumberOfRows == 2 &&
                  GetStructureReadOnly(AtRowCol(1,1)->cell)->IsEmpty()));
                   // 26/09/91 for paste tables to replace empty tables
}


// ------------------------------------------------------------------------
bool _TColumnStructure::IsShown(TCurrency currency, TCurrency child)
{
  // 12/05/93 [20863] rewritten to test for child == gNullCurrency
  if (_TStructure::IsShown(currency, child))
  {
    int row;
    int column;
    PCellItem item;

    if (child == 0 ||
      (  FindCell(child, row, column),    // 25/04/91 extra param & call inherited
         item = AtRowCol(row, column),
         !item->hidden && item->cell))  // 21/11/91
      return TRUE;
  }
  return FALSE;
}


// ------------------------------------------------------------------------
bool _TColumnStructure::SearchCell(PCellItem cellStruct, int row, int column,
                        TCursorNode newStart, TSelection hitSelection,
                        char* findText, bool wholeWord, bool caseSensitive,
                        bool searchBackwards, bool changeAll)
{
  bool  SearchCell_r;
  TStructure structure;

  if (cellStruct->hidden)
    SearchCell_r = FALSE;
  else
  {
    structure = GetStructureReadOnly(cellStruct->cell); // 19/03/91 RW
    SearchCell_r = structure->DoSearch(cellStruct->cell, newStart,
                   hitSelection, findText, wholeWord, caseSensitive,
                   searchBackwards, changeAll);
  }
  return SearchCell_r;
}


// ------------------------------------------------------------------------
bool _TColumnStructure::DoSearch(TCurrency currency, TCursorNode startPoint,
                                 TSelection hitSelection, char* findText,
                                 bool wholeWord, bool caseSensitive,
                                 bool searchBackwards, bool changeAll)
{
  TCellRect cellCoords;
  TCursorNode newStart;
  bool found, done;

  GetAllCells(cellCoords);

  if (startPoint != 0)
  {
    if (searchBackwards)
      TColCursorNode(startPoint)->GetRowCol(this,
                                      cellCoords.endRow, cellCoords.endCol);
    else
      TColCursorNode(startPoint)->GetRowCol(this,
                                  cellCoords.startRow, cellCoords.startCol);
    newStart = startPoint->GetNext();
  }
  else
    newStart = NULL;

  done = FALSE;
  do {
    if (searchBackwards)
    {
      found = SearchCell(AtRowCol(cellCoords.endRow, cellCoords.endCol),
              cellCoords.endRow, cellCoords.endCol, newStart, hitSelection,
              findText, wholeWord, caseSensitive, searchBackwards,changeAll);
      if (found)
        done = TRUE;
      else
      {
        cellCoords.endCol --;
        if (cellCoords.endCol == 0)
        {
          cellCoords.endCol = fNumberOfColumns;
          cellCoords.endRow --;
        }
        done = (cellCoords.startRow > cellCoords.endRow);
      }
    }
    else
    {
      found = SearchCell(AtRowCol(cellCoords.startRow, cellCoords.startCol),
              cellCoords.startRow,cellCoords.startCol,newStart,hitSelection,
              findText, wholeWord, caseSensitive, searchBackwards,changeAll);
      if (found)
        done = TRUE;
      else
      {
        cellCoords.startCol ++;
        if (cellCoords.startCol > fNumberOfColumns)
        {
          cellCoords.startCol = 1;
          cellCoords.startRow ++;
        }
        done = (cellCoords.startRow > cellCoords.endRow);
      }
    }
    newStart = 0;
  } while (!done);

  return found;
}


// ------------------------------------------------------------------------
void _TColumnStructure::InsertSubStructure(int isPaste,
                                  TTextDocument sourceDoc, TCurrency parent,
                                  TCurrency &currency, long &before)
{
  int row, column;
  TColumnStructure structure;
  TCellRect cellCoords;
  bool addTheCell = FALSE;

  if (Curr_fType(currency) == kBodyStruct)
    FailGeneral(41);      // 08/06/93 [20927] do not allow tables to contain body structures

  if (before < 0)        // 23/07/93 == -1)
  {
    row = fNumberOfRows + 1;
    column = 1;
  }
  else
  {
    row = GetHi(before);
    column = GetLo(before);
  }

  if (isPaste)
  {
    if (before < 0)        // 23/07/93 == -1)
    {
      if (fUndoStructure == NULL)
      {
        if (fUndoCoords.startRow == 0)
          GetAllCells(fUndoCoords);

        if (fSize == 0)
        {
          fNumberOfRows = 0;
          fNumberOfColumns = 1;
          row = 1;
          if (fUndoCoords.endCol < fUndoCoords.startCol)
            fUndoCoords.endCol = fUndoCoords.startCol;
                                      // 22/09/93 [21047] stop zero div below, 30/09/93 Max
        }
        else
        {
          int disp = -(before + 1);
          int hdisp, vdisp;

          vdisp = disp / (fUndoCoords.endCol - fUndoCoords.startCol + 1);
          hdisp = disp % (fUndoCoords.endCol - fUndoCoords.startCol + 1);
          row = fUndoCoords.startRow + vdisp;
          column = fUndoCoords.startCol + hdisp;
        }
        before--;
        addTheCell = TRUE;
        SetPastePosition(currency, -1);             // 10/09/92
      }
      else
      {
        register TCellRect *cgf_56 = &fUndoStructure->fUndoCoords;

        row = cgf_56->startRow;
        column = cgf_56->startCol;
        cgf_56->startCol ++;
        if (cgf_56->startCol > cgf_56->endCol)
        {
          cgf_56->startCol = 1;
          cgf_56->startRow ++;
        }

        row += fUndoCoords.startRow - 1;
        column += fUndoCoords.startCol - 1;
        if ((row <= fUndoCoords.endRow) && (column <= fUndoCoords.endCol))
        {
          (AtRowCol(row, column))->cell = currency;
          SetPastePosition(currency, -1);             // 10/09/92
        }
      }
    }
    else
    {
      if (Curr_fType(currency) == kTableStruct)
      {
        structure =
             TColumnStructure(GetStructureReadOnly(currency));
        structure->GetAllCells(cellCoords);
      }
      else  // 19/09/90 new clause
      {
        structure = NULL;
        ClearRect(*((Rect *)&cellCoords));
        // memset(&cellCoords, 0, sizeof(TCellRect));
      }

#ifdef DRAGDROP
      if (isPaste == cMove)
      {
        int i;

        if (cellCoords.endCol == fNumberOfColumns && fUndoStructure == NULL) // 14/03/94 &&
        {
          if (column > fNumberOfColumns / 2)
            row++;
          for (i = 0; i < cellCoords.endRow; i++)
            AddNewRow(row - 1, gNullCurrency);
          column = 1;
          fUndoCoords.startRow = row;
          fUndoCoords.endRow = row + cellCoords.endRow - 1;
          fUndoCoords.startCol = 1;
          fUndoCoords.endCol = fNumberOfColumns;
        }
        else if (cellCoords.endRow == fNumberOfRows && fUndoStructure == NULL) // 14/03/94 &&
        {
          if (row > fNumberOfRows / 2)
            column++;
          for (i = 0; i < cellCoords.endCol; i++)
            AddNewColumn(column - 1, gNullCurrency);
          row = 1;
          fUndoCoords.startRow = 1;
          fUndoCoords.endRow = fNumberOfRows;
          fUndoCoords.startCol = column;
          fUndoCoords.endCol = column + cellCoords.endCol - 1;
        }
        else
          FailGeneral(kMoveAlert);

        before = PackTwoShorts(row, column);
        fDocument->DeleteCurrency(currency);
        currency = 0;
      }
      else
#endif
      if (fUndoStructure != NULL &&
            fUndoCoords.startRow == fUndoCoords.endRow &&
            fUndoCoords.startCol == fUndoCoords.endCol)
      {
        if (structure != NULL)
            structure->fUndoCoords = cellCoords;
        AtRowCol(fUndoCoords.startRow, fUndoCoords.startCol)->cell = currency;
        SetPastePosition(currency, -1);             // 10/09/92
      }
      else
      {
        if (fUndoStructure == NULL ||
              cellCoords.endRow != fUndoCoords.endRow - fUndoCoords.startRow + 1 ||
              cellCoords.endCol != fUndoCoords.endCol - fUndoCoords.startCol + 1)
                                 // 14/08/90 fUndoStructure test added
          FailGeneral(kPasteAlert);
        fUndoStructure->fUndoCoords = cellCoords;
        before = PackTwoShorts(fUndoCoords.endRow, fUndoCoords.endCol);
        fDocument->DeleteCurrency(currency);
        currency = 0;
      }
    }
  }
  else
  {
    if (fSize == 0)
    {
      fNumberOfRows = 0;
      fNumberOfColumns = 1;
      AddNewRow(0, gNullCurrency);
      row = 1;
      column = 1;
    }
    addTheCell = TRUE;
  }
  if (addTheCell)
  {
    PCellItem theCellItem;

    if (row > fNumberOfRows)
      AddNewRow(fNumberOfRows, gNullCurrency);
    if (column > fNumberOfColumns)
      AddNewColumn(fNumberOfColumns, gNullCurrency);

    theCellItem = AtRowCol(row, column);
    if (currency == 0)       // 07/01/94 [21219] avoid corrupt nested tables
      MakeNewCell(*theCellItem, kWithinCell, parent);
    else
      theCellItem->cell = currency;
    theCellItem->rowChange = FALSE;   // 01/10/91 clear flags to stop redrawing
    theCellItem->colChange = FALSE;   // when typing into the cell
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::EndStructure(TCurrency currency, TCursorNode anchor,
                                     int part, Rect &custom)
{
  TCurrency cellItem;
  TStructure subStruct;
  int row, col;

  row = fNumberOfRows;
  col = FindMasterCell(row, fNumberOfColumns);          // 02/05/91 i/f
  cellItem = (AtRowCol(row, col))->cell;
  TColCursorNode(anchor)->SetCell(cellItem);            // 03/04/91
#ifdef MATHS
  if (fParent == 0 || (Curr_fType(fParent) != kMathStruct
                && Curr_fType(fParent) != kTextStruct))  // 07/04/92 && for enter in matrix
#endif
  {
    subStruct = GetStructureReadOnly(cellItem);
    subStruct->ExtendCursor(anchor, cellItem, TRUE, TRUE, FALSE);
  }
}


// ------------------------------------------------------------------------
TStyleTypes _TColumnStructure::GetKind(void)
{
  return (fCellKind == kMaths ? kMatrix : kColumns); // 14/04/92
}

// ------------------------------------------------------------------------
static bool FirstThatHasCurrency(TColumnStructure structure,
                                 TCurrency currency, int &row, int &column)
// 24/11/91 try to speed up FindCell
{
  PCellItem cellItem = PCellItem(structure->At(1));

  for (int index = 0; index < structure->fSize; index++, cellItem++)
  {
    if (cellItem->cell == currency)
    {
      row = (index / structure->fNumberOfColumns) + 1;
      column = (index % structure->fNumberOfColumns) + 1;
      return TRUE;
    }
  }
  return FALSE;
}

// ------------------------------------------------------------------------
void _TColumnStructure::FindCell(TCurrency currency, int &row, int &column)
{
  if (!FirstThatHasCurrency(this, currency, row, column))
  {
    bool cellFound;
#ifdef TRACE
    Assert(fUndoStructure, 173);
#endif
    cellFound = FirstThatHasCurrency(fUndoStructure, currency, row, column);
#ifdef TRACE
    Assert(cellFound, 173);
#endif
    row += fUndoCoords.startRow - 1;
    column += fUndoCoords.startCol - 1;
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::FindCellInCol(TCurrency currency,int &row,int column)
{
  int index = column;

  row = 1;
  while (PCellItem(At(index))->cell != currency)  // from !HasCurrency2
  {
    index += fNumberOfColumns;
    row ++;
  }
}


// ------------------------------------------------------------------------
int _TColumnStructure::FindMasterCell(int row, int column)
{
  int cellIndex;
  int spanIndex;
  bool checkHidden = column > 0;

  column = abs(column);
  cellIndex = fNumberOfColumns * (row - 1) + column;
  if (cellIndex <= fSize && 
       (!checkHidden || PCellItem(At(cellIndex))->hidden)) // 09/07/91 test
  {
    for (spanIndex = 1; spanIndex <= column - 1; spanIndex++)
    {
      PCellItem cellItem = PCellItem(At(cellIndex - spanIndex));

      if (!cellItem->hidden && cellItem->spanCount >= spanIndex)  // 23/12/93 check hidden
      {
        column -= spanIndex;
        break;
      }
    }
  }
  return column;
}


// ------------------------------------------------------------------------
void _TColumnStructure::SelectPart(TCursorNode anchor,
                                   TCursorNode activeEnd, int part, Rect &custom)
{
  TStructure subStruct;
  TCurrency subStructCur;
  int row, column;
  int c;

  if (anchor != NULL)
  {
    if (part == kAllCols || part == kAllColsBody) // 2/4/92
    {
      row = 1;
      column = 1;
    }
    else
    {
      TColCursorNode(anchor)->GetRowCol(this, row, column);
      if (part == kColPart)
        row = 1;
      else
        column = 1;
    }
    FindNextVisible(row, column, 1);         // 17/06/91 loop to proc
    c = FindMasterCell(row, column);
    subStructCur = (AtRowCol(row, c))->cell;
    TColCursorNode(anchor)->SetCell(subStructCur);
    TColCursorNode(anchor)->SetSpanOffset(column - c);  // 27/06/91
    subStruct = GetStructureReadOnly(subStructCur);
    subStruct->ExtendCursor(anchor, subStructCur, FALSE, TRUE, FALSE);
  }

  if (activeEnd != NULL)
  {
    bool spanned; // 27/11/91 fix prob in 2x2 table: del col2 then select row1
    if (part == kAllCols || part == kAllColsBody) // 2/4/92
    {
      row = fNumberOfRows;
      column = fNumberOfColumns;
    }
    else
    {
      TColCursorNode(activeEnd)->GetRowCol(this, row, column);
      if (part == kColPart)
        row = fNumberOfRows;
      else
        column = fNumberOfColumns;
    }
    // 14/05/91 rest new; 23/05/91 allow multi-hidden
    c = FindMasterCell(row, column);     // 25/09/91 for select after undo delete row
    spanned = c != column;               // 27/11/91 fix prob in 2x2 table
    FindNextVisible(row, c, -1);         // 17/06/91 loop to proc
    if (!spanned)                        // 27/11/91 fix prob in 2x2 table
      column = c;
    c = FindMasterCell(row, column);
    subStructCur = (AtRowCol(row, c))->cell;
    TColCursorNode(activeEnd)->SetCell(subStructCur);
    TColCursorNode(activeEnd)->SetSpanOffset(column - c);  // 27/06/91
    subStruct = GetStructureReadOnly(subStructCur);
    subStruct->ExtendCursor(activeEnd, subStructCur, TRUE, TRUE, FALSE);
  }
}


// ------------------------------------------------------------------------
bool _TColumnStructure::InSecondHalf(TCursorNode cursor)
{
  return (TColCursorNode(cursor)->GetRow(this) >= fNumberOfRows / 2);
}


// ------------------------------------------------------------------------
void _TColumnStructure::ExtendCursor(TCursorNode cursorNode,
          TCurrency currency, bool fromRight, bool toBottom, bool keep)
{
  TColCursorNode newNode;
  TCursor cursor;
  TCurrency cellItem;
  TStructure structure;
  int r, c;
  int c1;

  newNode = new _TColCursorNode(currency, kNewCursor, gZeroVPt);

  if (fromRight)
  {
    r = fNumberOfRows;
    c = fNumberOfColumns;
    FindNextVisible(r, c, -1);      // 17/06/91
    c1 = FindMasterCell(r, c);       // 02/05/91 i/f
  }
  else
  {
    r = 1;
    c = 1;
    FindNextVisible(r, c, 1);      // 17/06/91
    c1 = c;
  }

  cellItem = (AtRowCol(r, c1))->cell;
  TColCursorNode(newNode)->SetCell(cellItem);
  TColCursorNode(newNode)->SetSpanOffset(c - c1);    // 27/06/91
  cursor = cursorNode->fCursor;
  cursor->AddTarget(newNode);

  if (toBottom)
  {
    structure = GetStructureReadOnly(cellItem);
    structure->ExtendCursor(newNode, cellItem, fromRight, TRUE, keep);
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::ResetCursor(TCursorNode cursor, long insertionPos,
                                    bool fromRight, bool keep)
{
  if (cursor != NULL) // 03/10/91 Clear gets passed a NULL value to 2nd Half
  {
    TCurrency currency;
    TStructure item;
    int row = GetHi(insertionPos);
    int col = GetLo(insertionPos);
    int c1;

    cursor->Collapse();
    currency = (AtRowCol(row, c1 = FindMasterCell(row, col)))->cell;
                                               // 24/05/91 FindMasterCell
    TColCursorNode(cursor)->SetCell(currency);
    TColCursorNode(cursor)->SetSpanOffset(col - c1);         // 27/06/91
    item = GetStructureReadOnly(currency);
    item->ExtendCursor(cursor, currency, fromRight, TRUE, keep);
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::DoCopy(PCellItem cellStruct, int row, int column,
  TCellRect *cellCoords, TTextDocument clipDocument, TCurrency clipCurrency,
  TCursorNode n1, TCursorNode n2, 
#ifdef DRAGDROP
  TCursorNode dropNode,
#endif
  TSelShape selShape, TColumnStructure structure)
{
  TStructure subStruct;
  TCurrency currency;
  long pos;
  int r;
  int c;

  if (MemSpaceIsLow())
    fDocument->Purge();
  currency = cellStruct->cell;

  r = row - cellCoords->startRow + 1;
  c = column - cellCoords->startCol + 1;
  pos = (selShape == kWithinCell ? -1 :       // 12/02/91
       PackTwoShorts(r, c));
  if (cellStruct->spanCount > 0 && structure != NULL)    // 24/05/91 && test
    structure->AtRowCol(r, c)->spanCount =
              Min(cellStruct->spanCount, structure->fNumberOfColumns - c);
  if (cellStruct->hidden)
    structure->AtRowCol(r, c)->hidden = TRUE;
  else
  {
    subStruct = GetStructureReadOnly(currency); // 19/03/91 RW
    subStruct->CopyToClipboard(currency, n1, n2,
#ifdef DRAGDROP
                             dropNode,
#endif
                             clipDocument, clipCurrency, pos);
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::CopyToClipboard(TCurrency currency,
                        TCursorNode anchor, TCursorNode activeEnd,
#ifdef DRAGDROP
                        TCursorNode dropNode,
#endif
                        TTextDocument clipDocument, TCurrency clipParent,
                        long pos)
{
  TColumnStructure structure;
  volatile TObject obj;
  TCurrency clipCurrency;
  TSelShape selShape;
  TCellRect cellCoords;
  int row;
  FailInfo fi;
  TCursorNode n1;
  TCursorNode n2;

  ClearRect(*((Rect *)(&fUndoCoords)));
  selShape = GetSelectedCells(cellCoords, anchor, activeEnd);

  if (selShape != kWithinCell)
  {
    // Handle arrayPtr;

    obj = CloneForPaste(currency, fDocument);   // same as following:
    // obj = fDocument->GetPrototype(Curr_fType(currency));
    // arrayPtr = TColumnStructure(obj)->fPtrToArray;
    // structure = TColumnStructure(memcpy(obj, this, GetHandleSize(obj)));
    // structure->fPtrToArray = arrayPtr;
    // structure->fSize = 0;
    structure = TColumnStructure(obj);
    structure->fNumberOfRows = 0;
    structure->fNumberOfColumns = cellCoords.endCol - cellCoords.startCol + 1;

    CatchFailures(&fi);

    for (row = cellCoords.startRow; row <= cellCoords.endRow; row++)
      structure->AddNewRow(structure->fNumberOfRows, gNullCurrency);
  
    clipCurrency = currency;
    clipDocument->AddStructure(0, structure, pos, clipParent, fDocument, clipCurrency);
    Success(&fi);

    n1 = NULL;
    n2 = NULL;
  }
  else
  {
    n1 = anchor->GetNext();
    n2 = activeEnd->GetNext();
    clipCurrency = clipParent;
    structure = NULL;
  }
  ForSelectedCellsDo(this, cellCoords, (Action)_TColumnStructure::DoCopy,
       &cellCoords, clipDocument, clipCurrency, n1, n2, 
#ifdef DRAGDROP
       dropNode,
#endif
       selShape, structure);
  return;

// +++++++++++++++++++
Rescue:
  FreeIfObject(obj);
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TColumnStructure::GivePastePosition(TCursorNode cursor,
                                          long &startPos, long &endPos)
{
#ifdef DRAGDROP
  if (fUndoStructure == NULL)
  {
    int row, col;

    TColCursorNode(cursor)->GetRowCol(this, row, col);
    startPos = endPos = PackTwoShorts(row, col);
    return;
  }
#endif
  startPos = PackTwoShorts(fUndoCoords.startRow, fUndoCoords.startCol);
  endPos = PackTwoShorts(fUndoCoords.endRow, fUndoCoords.endCol);
}


// ------------------------------------------------------------------------
int _TColumnStructure::CanDoPaste(TCurrency currency,
                                 TStructure dataToPaste, int numOfItems)
{
  TStyleTypes kind = dataToPaste->GetKind();

  return ((kind == GetKind() && fNumberOfColumns + fNumberOfRows > 2) // 26/09/91 pass up (1,1)
              || kind == kMaths || kind == kPict || kind == kText);  // 25/04/91
}


// ------------------------------------------------------------------------
bool _TColumnStructure::IsHeadingRow(int row)
{
  return AtRowCol(row, 1)->heading;
}


#ifdef MATHS
// ------------------------------------------------------------------------
bool _TColumnStructure::CanPasteInLine()
{
  return fCellType == kMathStruct;
}
#endif

// ------------------------------------------------------------------------
bool _TColumnStructure::AllSelected(TCurrency currency, TCursorNode anchor,
                                    TCursorNode activeEnd)
{
  bool  AllSelected_r = FALSE;
  TSelShape selShape;
  TCellRect cellCoords;
  TCellRect allCells;

  selShape = GetSelectedCells(cellCoords, anchor, activeEnd);
// 27/06/91  cellCoords.startCol = FindMasterCell(1, cellCoords.startCol);
// 27/06/91  cellCoords.endCol = FindMasterCell(fNumberOfRows, cellCoords.endCol);

  if (selShape == kColumnWise)
  {
    GetAllCells(allCells);
    if (EqualRect(*((Rect*) &allCells), *((Rect*) &cellCoords)))
      AllSelected_r = TRUE;
  }

  return AllSelected_r;
}

#ifdef TRACE
// ------------------------------------------------------------------------
void _TColumnStructure::GetPartInfo(TCurrency partCurrency, int &part,
                                    Rect &custom)
{
  NotYetImplemented("TColumnStructure::GetPartInfo");
}


// ------------------------------------------------------------------------
bool _TColumnStructure::HasCompositeStyle(void)
{
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
void _TColumnStructure::GetSelectionKind(TCursorNode anchor,
                        TCursorNode activeEnd, TStyleTypes &kind, int &part,
                        Rect &custom)
{
  TSelShape selShape;
  TCellRect cellCoords;
  TCellRect allCells;

  kind = GetKind();             // 19/09/90 from kColumns
  selShape = GetCellsInSelection(cellCoords, anchor, activeEnd, FALSE); // 06/01/94 [21216]

  custom = *((Rect*) &cellCoords);
  switch (selShape)
  {
    case kWithinCell:
    case kBlockOfCells:
         part = 0;
         break;
    case kRowWise:
         part = -kRowPart;
         break;
    case kColumnWise:
         GetAllCells(allCells);
         if (EqualRect(*((Rect*) &allCells), *((Rect*) &cellCoords)))
         { // 2/4/92 new block
           TCursorNode anchorNext = (anchor == NULL ? NULL: anchor->GetNext()),
                       activeNext = (activeEnd == NULL ? NULL: activeEnd->GetNext());
           TCurrency currency1, currency2;
           TStructure cell1, cell2;

           currency1 = AtRowCol(1, 1)->cell;
           currency2 = (activeEnd == NULL ?
                AtRowCol(fNumberOfRows,
                         FindMasterCell(fNumberOfRows, fNumberOfColumns))->cell :
                TColCursorNode(activeEnd)->GetCell());
           cell1 = GetStructureReadOnly(currency1);
           cell2 = GetStructureReadOnly(currency2);         
           part = -kAllColsBody;
           if (currency1 == currency2)
           {
             if (cell1->AllSelected(currency1, anchorNext, NULL))
               part = -kAllCols;
           }
           else if (cell1->AllSelected(currency1, anchorNext, NULL) &&
                    cell2->AllSelected(currency2, NULL, activeNext))
             part = -(kAllCols);
         }
         else
           part = -(kColPart);
         break;
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::MakeNewCell(TCellItem &newCell, TSelShape scope,
                                    TCurrency myCurrency)
{
  newCell.hidden = FALSE;
  newCell.heading = FALSE;
  newCell.ruleRight = FALSE;
  newCell.spanCount = 0;
  newCell.undoState = TRUE; // 19/11/91 why changed in first place?? FALSE;// 04/10/91 ??? TRUE;
  newCell.colChange = (scope == kColumnWise);
  newCell.rowChange = (scope == kRowWise);
  newCell.cell = 0;

  if (myCurrency != 0)
  {
    TDiscObject cellObject;

    newCell.cell = fDocument->NewCurrency(fCellType, cellObject);
    TStructure(cellObject)->InitNewStructure(myCurrency, newCell.cell,
                                  gNullCurrency, fCellKind, TRUE, NULL); // 24/03/92
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::AddNewRow(int afterRow, TCurrency myCurrency)
{
  int i;
  volatile int inserts = 0; // 07/08/90 - for safety
  volatile int afterIdx;
  volatile TCellItem newCell;
  FailInfo fi;

  afterIdx = afterRow * fNumberOfColumns;
  CatchFailures(&fi);
  for (i = 1; i <= fNumberOfColumns; i++)
  {
    inserts = i;
    // 25/07/92 done in MNC:    newCell.cell.cgf_31.fRecnum = 0;
    MakeNewCell(newCell, kRowWise, myCurrency);
    if (afterRow == fNumberOfRows)
      InsertLast(&newCell);
    else
      InsertBefore(afterIdx + i, &newCell);
  }
  newCell.cell = 0;     // 25/07/92 better to use fValue than fRecnum
  inserts++;
  FailSpaceIsLow();
  Success(&fi);
  fNumberOfRows++;
  return;

// +++++++++++++++++++++++++++++
Rescue:
  // 25/07/92 checks in DeleteCurrency:    if (newCell.cell.cgf_31.fRecnum != 0)
  fDocument->DeleteCurrency(newCell.cell);
  for (int j = 1; j < inserts; j++)
  {
    fDocument->DeleteCurrency(PCellItem(At(afterIdx + 1))->cell);
              // 25/07/92 was deleting gNullCurrency but now test in DeleteCurrency
    Delete(afterIdx + 1);
  }
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TColumnStructure::AddNewColumn(int afterColumn, TCurrency myCurrency)
{
  int i;
  volatile TCellItem newCell;
  volatile int inserts = 0; // 07/08/90 - for safety
  FailInfo fi;

  CatchFailures(&fi);
  for (i = 0; i < fNumberOfRows; i++)
  {
    inserts = i;
    // 25/07/92 done in MNC:    newCell.cell.cgf_31.fRecnum = 0;
    MakeNewCell(newCell, kColumnWise, myCurrency);
    if ((afterColumn == fNumberOfColumns) && (i == fNumberOfRows - 1))
      InsertLast(&newCell);
    else
      InsertBefore((i * (fNumberOfColumns + 1)) + afterColumn + 1, &newCell);
  }
  // 25/07/92 better to use fValue: newCell.cell.cgf_31.fRecnum = 0;
  newCell.cell = 0;
  inserts++;
  FailSpaceIsLow();
  Success(&fi);
  fNumberOfColumns++;
  if (afterColumn > 0)
  {
    afterColumn++;
    for (i = 1; i <= fNumberOfRows; i++)
    {
      int mc = FindMasterCell(i, -afterColumn);    // 08/07/91

      if (mc < afterColumn)     // 08/07/91
      {
        PCellItem item = AtRowCol(i, afterColumn);

        item->hidden = TRUE;
        // 25/07/92 checks in DeleteCurrency:  if (item->cell != 0)         // 16/09/91
        fDocument->DeleteCurrency(item->cell);
        item->cell = 0;
        AtRowCol(i, mc)->spanCount++;
      }
    }
  }
  return;

// +++++++++++++++++++++++++++++++
Rescue:
  {
    int j;

    // 25/07/92 checks in DeleteCurrency:    if (newCell.cell.cgf_31.fRecnum != 0)
    fDocument->DeleteCurrency(newCell.cell);
    for (j = inserts - 1; j >= 0; j--)
    {
      int idx = (fNumberOfColumns + 1) * j + afterColumn + 1;

      fDocument->DeleteCurrency(PCellItem(At(idx))->cell);
      Delete(idx);
    }
  }
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TColumnStructure::CommitRow(TCurrency currency, int row,
                          TCursorNode anchor, TCursorNode activeEnd, TCommand command)
// 03/09/92 extra params
{
  int i;
  int cellIndex;
  bool rowDeleted;

  cellIndex = (row - 1) * fNumberOfColumns + 1;
  rowDeleted = PCellItem(At(cellIndex))->hidden;
  for (i = 1; i <= fNumberOfColumns; i++)
  {
    register TCellItem *cgf_69 = PCellItem(At(cellIndex));
    // 10/01/94 [21222] TCurrency cellParent =

    CellCommit(currency, cgf_69->cell, command, anchor, activeEnd, rowDeleted);

    if (rowDeleted)
    {
      // 10/01/94 [21222] if (cellParent == currency)
      // 10/01/94 [21222]  fDocument->DeleteCurrency(cgf_69->cell);
      Delete(cellIndex);
    }
    else
    {
      cgf_69->undoState = cgf_69->hidden;  // 23/12/93 [21211] from FALSE,
                                           // messes next toggle spanned cell
      cgf_69->rowChange = FALSE;
      cellIndex ++;
    }
  }

  if (rowDeleted)
  {
    fDocument->DeleteFormatData(currency, -row);
    fNumberOfRows --;
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::CommitColumn(TCurrency currency, int column,
                          TCursorNode anchor, TCursorNode activeEnd, TCommand command)
// 03/09/92 extra params
{
  int i;
  int cellIndex;
  bool colDeleted;
  int spanIndex;

  colDeleted = TRUE;
  for (i = 1; i <= fNumberOfRows; i++)
  { 
    PCellItem itm = AtRowCol(i, column);

    itm->undoState = itm->hidden;
    itm->colChange = FALSE;
    if (!itm->hidden)
    {
      colDeleted = FALSE;
      if (itm->spanCount > 0) // 2/7/92 code was missing
      {
        for (int ci = column + 1; ci <= column + itm->spanCount; ci++)
        {
          PCellItem itm1 = AtRowCol(i, ci);
          
          fDocument->DeleteCurrency(itm1->cell);// 25/07/92 checks nullCurr in DeleteCurrency
          itm1->cell = 0;
          itm1->spanCount = 0;    // 23/12/93 [21208] not zeroised by toggle state any more
        }
      }
    }
  }

  cellIndex = fNumberOfColumns * (fNumberOfRows - 1) + column; // 22/6/92 moved
// 22/6/92 code below reorganised  
  for (i = 1; i <= fNumberOfRows; i++)
  {
    TCurrency cellCurrency = PCellItem(At(cellIndex))->cell;
    // 10/01/94 [21222] TCurrency cellParent = 
    CellCommit(currency, cellCurrency, command, anchor, activeEnd, colDeleted);

    if (colDeleted)
    {
      for (spanIndex = 1; spanIndex <= column - 1; spanIndex++)
      { 
        register TCellItem *cgf_71 = PCellItem(At(cellIndex - spanIndex));
        if (cgf_71->spanCount >= spanIndex)
        {
          cgf_71->spanCount --;
          break;
        }
      }
      // 10/01/94 [21222] if (cellParent == currency)   // 22/01/91
      // 10/01/94 [21222]  fDocument->DeleteCurrency(cellCurrency);
      Delete(cellIndex);
      // 02/07/92 should be done if col not deleted:       cellIndex -= fNumberOfColumns;
      // 02/07/92 should be outside loop:      fNumberOfColumns --;
    }
    cellIndex -= fNumberOfColumns;
  }
  if (colDeleted)
  {
    fDocument->DeleteFormatData(currency, column);
    fNumberOfColumns--;   // 02/07/92
  }
}

// ------------------------------------------------------------------------
void _TColumnStructure::CommitCells(TCurrency currency, TCellRect &cellCoords,
                                                            TCommand command)
{
  ForSelectedCellsDo(this, cellCoords, (Action)_TColumnStructure::CommitCellBlock,
                                 currency, command);  // 03/09/92 extra param

}

// ------------------------------------------------------------------------
void _TColumnStructure::CommitCellBlock(PCellItem cellStruct, int row, int column,
                                        TCurrency currency, TCommand command)
// 03/09/92 extra param
{
  TCurrency deletedCell;

  deletedCell = 0;
  if (cellStruct->hidden && !cellStruct->undoState)
    deletedCell = cellStruct->cell;
  cellStruct->undoState = cellStruct->hidden;
  cellStruct->colChange = FALSE;

  if (deletedCell != 0)
  {
    CellCommit(currency, deletedCell, command, NULL, NULL, TRUE);
    // 10/01/94 [21222] fDocument->DeleteCurrency(deletedCell);
    cellStruct->cell = 0;
  }
}


// ------------------------------------------------------------------------
bool _TColumnStructure::SwapNodes(TCursorNode anchor, TCursorNode activeEnd)
{
  int startRow;
  int startCol;
  int endRow;
  int endCol;

  TColCursorNode(anchor)->GetRowCol(this, startRow, startCol);
  TColCursorNode(activeEnd)->GetRowCol(this, endRow, endCol);
  return ((startRow > endRow) || ((startRow == endRow) && (startCol > endCol)));
}


// ------------------------------------------------------------------------
void _TColumnStructure::GetAllCells(TCellRect &cellCoords)
{  
  cellCoords.startRow = 1;
  cellCoords.endRow = fNumberOfRows;
  cellCoords.startCol = 1;
  cellCoords.endCol = fNumberOfColumns;
}


// ------------------------------------------------------------------------
// 29/5/92 rewritten to call GetCellsInSelection which was GetSelectedCells!
TSelShape _TColumnStructure::GetSelectedCells(TCellRect &cellCoords,
                            TCursorNode startCursor, TCursorNode endCursor)
{
  TSelShape shape = GetCellsInSelection(cellCoords, startCursor, endCursor, TRUE);
  
  if (shape == kWithinCell)
  { // 23/6/92 fix in case selection inside cell
    TCurrency cell = AtRowCol(cellCoords.startRow, cellCoords.endCol)->cell;
    if (cell != 0) //15/7/92
    {
      TStructure structure = GetStructureReadOnly(cell);
      
      if (structure->AllSelected(cell, startCursor->GetNext(), endCursor->GetNext()))
      {
        if (fNumberOfRows == 1)
          return kColumnWise;
        if (fNumberOfColumns == 1)
          return kRowWise;
      }
    }
  }
  return shape;
}

// ------------------------------------------------------------------------
// 29/5/92 was GetSelectedCells
TSelShape _TColumnStructure::GetCellsInSelection(TCellRect &cellCoords,
                TCursorNode startCursor, TCursorNode endCursor, bool extend)
{
  int temp;
  TSelShape shape;

  shape = kColumnWise;
  GetAllCells(cellCoords);

  if (startCursor != NULL)
    TColCursorNode(startCursor)->GetRowCol(this,
                                cellCoords.startRow, cellCoords.startCol);
  if (endCursor != NULL)
  {
    TColCursorNode(endCursor)->GetRowCol(this,
                                cellCoords.endRow, cellCoords.endCol);
  }
  if ((cellCoords.startCol == cellCoords.endCol) &&
      (cellCoords.startRow == cellCoords.endRow))
  {
    if (startCursor != NULL && endCursor != NULL)
      shape = kWithinCell;
  }
  else
  {
    temp = Max(cellCoords.startRow, cellCoords.endRow);
    cellCoords.startRow = Min(cellCoords.startRow, cellCoords.endRow);
    cellCoords.endRow = temp;
    temp = Max(cellCoords.startCol, cellCoords.endCol);
    cellCoords.startCol = Min(cellCoords.startCol, cellCoords.endCol);
    cellCoords.endCol = temp;
    // 22/6/92 new loop (to extend selection for backspacing through cells)
    if (extend)       // 06/01/94 [21216] only extend block if toggle/commit
    {
      for (temp = cellCoords.startRow; temp <= cellCoords.endRow; temp++)
        if (AtRowCol(temp, 1)->rowChange)
        {
          cellCoords.startCol = 1;
          cellCoords.endCol = fNumberOfColumns;
          shape = kRowWise;
          break;
        }
    }
  }

  if (shape != kWithinCell)
  {
    if (cellCoords.endRow - cellCoords.startRow == fNumberOfRows - 1)
    {
    }
    else if (cellCoords.endCol- cellCoords.startCol == fNumberOfColumns -1)
      shape = kRowWise;
    else
      shape = kBlockOfCells;
  }
  return shape;
}


// ------------------------------------------------------------------------
void _TColumnStructure::ForSelectedCellsDo(TObject obj, TCellRect &toSelectedCells, Action procToDo, ...)
{
  int i, j;
  int itsIndex;
  TSelectedItemList *args = (TSelectedItemList *)((char *)&procToDo + sizeof(procToDo));

  if (toSelectedCells.startRow <= toSelectedCells.endRow)
  {
    for (i = toSelectedCells.startRow; i <= toSelectedCells.endRow; i++)
    {
      itsIndex = (i - 1) * fNumberOfColumns;
      for (j = toSelectedCells.startCol; j <= toSelectedCells.endCol; j++)
        procToDo(obj, PCellItem(At(itsIndex + j)), i, j, *args);
    }
  }
  else
  {
    for (i = toSelectedCells.endRow; i >= toSelectedCells.startRow; i--)
    {
      itsIndex = (i - 1) * fNumberOfColumns;
      for (j = toSelectedCells.endCol; j >= toSelectedCells.startCol; j--)
        procToDo(obj, PCellItem(At(itsIndex + j)), i, j, *args);
    }
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::CopyCellForUndo(PCellItem cellStruct, int row,
         int column, TCellRect* cellsToClear, TColumnStructure undoStruct,
         TCurrency currency, bool pasting)
{
  PCellItem undoCell;

  undoCell = undoStruct->AtRowCol(row - cellsToClear->startRow + 1,
                                  column - cellsToClear->startCol + 1);

  *undoCell = *cellStruct;

  cellStruct->cell = 0;
  cellStruct->colChange = TRUE;
  cellStruct->rowChange = FALSE;
  if (pasting)
  {
    if (column + cellStruct->spanCount > cellsToClear->endCol)
    {
      TDiscObject cellObject;
      PCellItem item;
      TCurrency newCell = fDocument->NewCurrency(fCellType, cellObject);

      TStructure(cellObject)->InitNewStructure(currency, newCell,
                            gNullCurrency, kText, TRUE, NULL);  // 24/03/92
      item = AtRowCol(row, cellsToClear->endCol + 1);
      item->cell = newCell;
      item->hidden = FALSE;
      item->spanCount =
               cellStruct->spanCount - (cellsToClear->endCol - column + 1);
    }
    cellStruct->hidden = FALSE;
    cellStruct->undoState = FALSE;
    cellStruct->spanCount = 0;
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::SaveCellsForUndo(TCurrency currency,
                                 TCellRect &cellsToClear, bool pasting)
{
  volatile TColumnStructure undoStruct;
  int n;
  FailInfo fi;

  undoStruct = new _TColumnStructure(fDocument, /* gNullCurrency,
                                     gNullCurrency,*/ fCellType, fCellKind);
  CatchFailures(&fi);

  undoStruct->fNumberOfColumns = cellsToClear.endCol - cellsToClear.startCol + 1;
  undoStruct->fNumberOfRows = 0;

  for (n = 1; n <= cellsToClear.endRow - cellsToClear.startRow + 1; n++)
    undoStruct->AddNewRow(0, gNullCurrency);

  ForSelectedCellsDo(this, cellsToClear,
    (Action)_TColumnStructure::CopyCellForUndo, &cellsToClear, undoStruct,
                                                currency, pasting);
  Success(&fi);
  fUndoStructure = undoStruct;
  fUndoCoords = cellsToClear;
  return;

// ++++++++++++++++
Rescue:
  undoStruct->Free();
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TColumnStructure::ClearCell(PCellItem cellStruct, int row, int column,
                 TSelShape scope, bool createCell, TCurrency myCurrency)
// 27/06/91 redone
{
  if (scope != kRowWise)    // 25/09/91 for undo delete row with spanners
  {
    if (cellStruct->spanCount > 0 && !createCell)
    {
      PCellItem cellStruct1 = AtRowCol(row, column + 1);

      CreateEmptyCell(cellStruct1, row, column + 1, myCurrency);
      cellStruct1->hidden = FALSE;

      // 05/01/94 [21211] Initialise undoState to a special value, so it can be recognised
      // below if it, too, is cleared because the following column is subsequently deleted
      cellStruct1->undoState = 2;
      cellStruct1->spanCount = cellStruct->spanCount - 1;  // Max(0, ); ??
    }
    else if (createCell && !cellStruct->hidden)
      CreateEmptyCell(cellStruct, row, column, myCurrency);
  }

  if (scope != kWithinCell && scope != kBlockOfCells)
  {
    int delCh = chBackspace; // 9/7/92
    // bool gone;  // 9/7/92

    // 05/01/94 [21211] ensure new span headers are toggled to hidden by undo
    cellStruct->undoState = (cellStruct->undoState == 2 ? TRUE : cellStruct->hidden);
    // 05/01/94 [21211] cellStruct->undoState = cellStruct->hidden;
    cellStruct->hidden = TRUE;
    cellStruct->colChange = (scope == kColumnWise);
    cellStruct->rowChange = (scope == kRowWise);
    // 9/7/92 clear all cells
    if (cellStruct->cell != 0)       // 05/08/92 crashes HogTable
      GetStructureReadWrite(cellStruct->cell)->Clear(NULL, NULL, kNormalClear, delCh);
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::CreateEmptyCell(PCellItem cellStruct,
                              int row, int column, TCurrency myCurrency)
{
  TCurrency cell;
  TDiscObject cellObject;

  cell = fDocument->NewCurrency(fCellType, cellObject);
#ifdef TRACE
  Assert(myCurrency != 0, 587);   // 10/07/92 as we can now pass NULLs for cursors
#endif
  TStructure(cellObject)->InitNewStructure(myCurrency,
                          cell, gNullCurrency, kText, TRUE, NULL); // 24/03/92
  cellStruct->cell = cell;
}


// ------------------------------------------------------------------------
bool _TColumnStructure::Clear(TCursorNode anchor, TCursorNode activeEnd,
                              TClearTypes clearType, /* returns bool &gone,*/ int &ch)
{
  bool gone = FALSE;
  TCellRect cellCoords;
  TStructure theCell;
  TSelShape scope;
  TCurrency myCurrency, cell;

  scope = GetSelectedCells(cellCoords, anchor, activeEnd);
  FailSpaceIsLow();
  
  if (clearType == kClearedByPaste && anchor != NULL && activeEnd != NULL) // kClearWord??
  {
    if (scope == kWithinCell)
    {
      cell = (AtRowCol(cellCoords.startRow, cellCoords.startCol))->cell;
      theCell = GetStructureReadWrite(cell);
      if (theCell->AllSelected(cell, anchor->GetNext(), activeEnd->GetNext()) ||
                  theCell->IsEmpty() ||    // 19/11/91 added empty condition
                  ch == chClear)           // 24/02/92 for 2x2 undo in cell 3
        SaveCellsForUndo(anchor->fCurrency, cellCoords, TRUE);
      else
        theCell->Clear(anchor->GetNext(), activeEnd->GetNext(), clearType, /*hasGone,*/ ch);
    }
    else
    {
      SaveCellsForUndo(anchor->fCurrency, cellCoords, TRUE);
      // 24/02/92 new conditional
      if (ch == chClear)
        ForSelectedCellsDo(this, cellCoords,
            (Action)_TColumnStructure::ClearCell, kBlockOfCells, TRUE, anchor->fCurrency);
    }
  }
  else if (anchor == NULL && activeEnd == NULL) // 14/7/92
  {
    gone = TRUE;
    fUndoStructure = TColumnStructure(-1);
  }
  else
  {
    long cellParams = 0;
    bool fromRight = FALSE;  // 15/12/93 [21147] put cursor at correct end of cell
    bool hasGone = FALSE; // 21/11/91, 07/04/94 [21609] moved up

    myCurrency = (anchor != NULL ? anchor->fCurrency :
                    (activeEnd != NULL ? activeEnd->fCurrency : 0));
    switch (scope)
    {
      case kColumnWise:
          if (cellCoords.endCol - cellCoords.startCol + 1 == fNumberOfColumns &&
                  IsPartOf((1 << kFigure)
#ifdef FN
                       | (1 << kNoteSet) | (1 << kFootnote)
#endif
                        ))
              // 24/05/94 [21819] GetStructureReadOnly(fParent)->GetKind() == kFigure)
              // 24/05/94 [21819] use IsPartOf -  not ideal, but should stop crashes
              // 03/10/91 for deleting table in figure - drop through and treat as...
            scope = kBlockOfCells;
          else
          {
            ForSelectedCellsDo(this, cellCoords,
              (Action)_TColumnStructure::ClearCell, scope, FALSE, myCurrency);
            gone = ((cellCoords.endCol- cellCoords.startCol + 1) == fNumberOfColumns);
            cellParams = PackTwoShorts(cellCoords.startRow,
                cellCoords.startCol == 1 ?
                  cellCoords.endCol + 1 : (fromRight = TRUE, cellCoords.startCol - 1));
            break;
          }
      case kWithinCell:
      case kBlockOfCells:
          cell = (AtRowCol(cellCoords.startRow, cellCoords.startCol))->cell;
          theCell = GetStructureReadWrite(cell);
          // 07/04/94 [21609] moved up: hasGone = FALSE; // 21/11/91
          if (scope == kWithinCell)
          {
            hasGone = (theCell->AllSelected(cell, anchor->GetNext(),
               activeEnd->GetNext()) || theCell->GetKind() == kPict);
            gone = hasGone && fNumberOfRows == 1 && fNumberOfColumns == 1;
            if (!hasGone) // 21/11/91
              hasGone = theCell->Clear(anchor->GetNext(), activeEnd->GetNext(), 
                                                        kNormalClear, ch);
          }
          if (scope == kBlockOfCells || hasGone) // 21/11/91
          {
            SaveCellsForUndo(myCurrency, cellCoords, FALSE);
            ForSelectedCellsDo(this, cellCoords,
                (Action)_TColumnStructure::ClearCell, scope, TRUE, myCurrency);
            cellParams = PackTwoShorts(cellCoords.startRow,
                  cellCoords.startCol);
            break;
          }
          return gone;   // 24/11/91 crashed on deleting text in resetCursor

      case kRowWise:
          ForSelectedCellsDo(this, cellCoords,
            (Action)_TColumnStructure::ClearCell, scope, FALSE, myCurrency);
          gone = ((cellCoords.endRow - cellCoords.startRow + 1) == fNumberOfRows);
          if (cellCoords.startRow == 1)
             cellParams = PackTwoShorts(cellCoords.endRow + 1, cellCoords.startCol);
          else
          {
             fromRight = TRUE; // 15/12/93 [21147] put in correct cell
             cellParams = PackTwoShorts(cellCoords.startRow - 1, cellCoords.endCol);
          }
          break;
    }
    // 03/10/91 common up ResetCursor from end of switch cases; return above to avoid reset
    // 07/04/94 [21609] Caller may ignore gone, causing ScrollSelectionIntoView to fail
    if (!gone || hasGone)     // 07/04/94 [21609] || hasGone = the cell is reset
    {
       ResetCursor(anchor, cellParams, fromRight, FALSE);
       // 07/01/94 [21218] force cursor into 1st row span header after delete column
       if (TColCursorNode(anchor))  // 13/04/94 [21621]
         TColCursorNode(anchor)->SetSpanOffset(0);
    }
  }
  return gone;  // 26/05/94
}


// ------------------------------------------------------------------------
void _TColumnStructure::ToggleCellBlock(PCellItem cellStruct, int row,
                int column, TSelShape scope, TCurrency currency, TCommand command,
                TCursorNode anchor, TCursorNode activeEnd)
// 13/08/92 needs currency 02/09/92 needs currency
{
  bool temp;
  temp = cellStruct->undoState;
  cellStruct->undoState = cellStruct->hidden;
  cellStruct->hidden = temp;
  // 23/12/93 [21207] moving arrow down after redo delete row fails test in FindNextVisible
  // the following corrupts rowChange in a Redo delete row (because command is cTyping)
  cellStruct->colChange = (scope == kColumnWise);
  cellStruct->rowChange = (scope == kRowWise);
  
  // 22/6/92 toggle the cell
  if (cellStruct->cell != 0) // 14/7/92
  {
    TCurrency cellCurrency = cellStruct->cell;
    TCursorNode anchorNext = (anchor == NULL ? NULL : anchor->GetNext());
    TCursorNode activeNext = (activeEnd == NULL ? NULL : activeEnd->GetNext());
    TStructure cellStructure = GetStructureReadWrite(cellStruct->cell);

    cellStructure->ToggleState(cellStruct->cell,
         anchorNext == NULL || anchorNext->fCurrency != cellCurrency ?
                                             NULL : anchorNext,
         activeNext == NULL || activeNext->fCurrency != cellCurrency ? 
                                             NULL : activeNext , command);
                                         // 02/09/92 pass next nodes
                                         // 28/08/92 pass command, not NULL! 
    cellStructure->fParent = currency;   // 13/08/92 was wrong after Redo paragraph -> cell
  }
  // 23/12/93 [21208] Redo delete span master goes wrong because the spanned cells get
  // toggled again (the selection is 'extended' to whole table by ToggleState if cTyping)
  // 26/09/91 rest new for Redo delete row with spanners
  if (cellStruct->spanCount > 0 && command->fCmdNumber != cSpan &&
                             command->fCmdNumber != cAddRow &&
                             command->fCmdNumber != cAddColumn &&  // 17/09/92 redo span
                             command->fCmdNumber != cTyping) // 23/12/93 [21208]
  {
    if (temp)
    {
      PCellItem cellStruct1 = AtRowCol(row, column + 1);

      if (cellStruct1->cell != 0)
      {
        cellStruct1->spanCount = cellStruct->spanCount - 1;
        cellStruct1->hidden = FALSE;
      }
    }
    else
      for (int c = column + 1; c <= column + cellStruct->spanCount; c++)
      {
        PCellItem cellStruct2 = AtRowCol(row, c);

        cellStruct2->spanCount = 0;
        cellStruct2->hidden = TRUE;
        cellStruct2->undoState = TRUE; // 28/11/91 del col with span head cell & undo failed
      }
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::ToggleCells(TCurrency currency, TCellRect &cellCoords,
           TSelShape scope, TCommand command, TCursorNode anchor, TCursorNode activeEnd)
// 13/08/92 need to pass currency 28/08/92 needs command 02/09/92 needs nodes
{
  ForSelectedCellsDo(this, cellCoords, (Action)_TColumnStructure::ToggleCellBlock,
                                   scope, currency, command, anchor, activeEnd);
}


// ------------------------------------------------------------------------
void _TColumnStructure::ToggleUndoCell(PCellItem cellStruct,
            int row, int column, TCellRect* cellCoords, bool isStructureCmd)
{
  PCellItem undoCell;
  TCellItem temp;
  TCurrency tc;
  TStructure cellStruct1, cellStruct2;

  undoCell = fUndoStructure->AtRowCol(row - cellCoords->startRow + 1,
                                      column - cellCoords->startCol + 1);

  if (undoCell->spanCount != cellStruct->spanCount)      // 27/06/91
  {
    PCellItem cellStruct3 = AtRowCol(row, cellCoords->endCol + 1);

    if (column + undoCell->spanCount > cellCoords->endCol)
    {
      cellStruct3->hidden = TRUE;
      cellStruct3->spanCount = 0;
    }
    else if (column + cellStruct->spanCount > cellCoords->endCol)
    {
      cellStruct3->hidden = FALSE;
      cellStruct3->spanCount = cellStruct->spanCount -
                                    (cellCoords->endCol - column + 1);
    }
  }

  temp = *cellStruct;
  *cellStruct = *undoCell;
  *undoCell = temp;
  cellStruct->colChange = TRUE;
  if (isStructureCmd && cellStruct->cell != 0 && undoCell->cell != 0)
                                // 07/01/94 [21220] check hidden cells
  {
    cellStruct1 = GetStructureReadWrite(cellStruct->cell);
    cellStruct2 = GetStructureReadWrite(undoCell->cell);
    tc = cellStruct1->fParent;
    cellStruct1->fParent = cellStruct2->fParent;
    cellStruct2->fParent = tc;
  }
}


// ------------------------------------------------------------------------
void _TColumnStructure::ToggleState(TCurrency currency, TCursorNode anchor,
                                    TCursorNode activeEnd, TCommand command)
{
  TCellRect cellCoords;
  TStructure theCell;
  TCurrency cellCurrency;
  bool isStructureCmd;
  TStyleTypes styleType;
  TStructTypes structType;

  isStructureCmd = CmdToStruct(command->fCmdNumber, styleType, structType);
  if (fUndoStructure != NULL && fUndoStructure != TObject(-1)) // 14/7/92
  {
    cellCoords = fUndoCoords;
    ForSelectedCellsDo(this, cellCoords,
     (Action)_TColumnStructure::ToggleUndoCell, &cellCoords, isStructureCmd);

    ResetCursors(anchor, activeEnd, cellCoords);  // 08/09/92 new call
//    ResetCursor(anchor, PackTwoShorts(cellCoords.startRow, cellCoords.startCol), FALSE, FALSE);
//    ResetCursor(activeEnd, PackTwoShorts(cellCoords.endRow, cellCoords.endCol), TRUE, FALSE);
  }
  else
  {
    switch (command->fCmdNumber)
    {
      case cSpan:
      case cAddRow:
      case cAddColumn:
          TSpanColumnCommand(command)->ToggleState();
          break;
      default:
      if (anchor != NULL || activeEnd != NULL || fUndoStructure == NULL) // 14/7/92
      {
        int wise = kRowWise;

        // 07/02/94 GetSelectedCells can be fooled by the fChanges cursor nodes set up
        // by the typing command and calls AllSelected on the cell with these nodes
        // which can give the wrong answer, so call GetCellsInSelection directly
        // switch (GetSelectedCells(cellCoords, anchor, activeEnd))
        switch (GetCellsInSelection(cellCoords, anchor, activeEnd, TRUE))
        {
          case kWithinCell:
             cellCurrency = (AtRowCol(cellCoords.startRow,
                                      cellCoords.startCol))->cell;
             theCell = GetStructureReadWrite(cellCurrency);
             theCell->ToggleState(cellCurrency, anchor->GetNext(),
                                      activeEnd->GetNext(), command);
             break;

          case kColumnWise:
          case kBlockOfCells: // 22/6/92
             wise = kColumnWise;
          case kRowWise:
             if (command->fCmdNumber == cTyping)
                            // 03/09/92 not necessarily correct block after deleting
             {
               GetAllCells(cellCoords);
               // 11/03/94 [21451] whats this for??? stops rows being commited: wise = kColumnWise;
             }
             ToggleCells(currency, cellCoords, wise, command, anchor, activeEnd);
                                     // 13/08/92 added currency 28/08/92 added command
                                     // 02/09/92 added cursor nodes
             break;
        }
      }
    }
  }
}

// ------------------------------------------------------------------------
void _TColumnStructure::CellCommit(TCurrency currency, TCurrency cellCurrency,
         TCommand command, TCursorNode anchor, TCursorNode activeEnd, bool freeParts)
// 03/09/92 new, 10/01/94 currency added
{
  if (cellCurrency != 0)
  {
    TStructure theCell = GetStructureReadWrite(cellCurrency);
 
    if (theCell->fParent != currency)  // 10/01/94 [21222]
      freeParts = FALSE;

    theCell->Commit(cellCurrency,
       anchor == NULL || TColCursorNode(anchor)->fCell != cellCurrency ?
                          NULL : anchor->GetNext(),      // 03/09/92
       activeEnd == NULL || TColCursorNode(activeEnd)->fCell != cellCurrency ?
                          NULL : activeEnd->GetNext(),      // 03/09/92
       command, freeParts);
    if (freeParts)
      fDocument->DeleteCurrency(cellCurrency); // 10/01/94 [21222] rather than return parent
//    return theCell->fParent;
  }
//  return gNullCurrency;
}


// ------------------------------------------------------------------------
void _TColumnStructure::CommitCell(PCellItem cellStruct, int row,
                         int column, TCommand command, TCurrency currency,
                         TCursorNode anchor, TCursorNode activeEnd)
// 03/09/92 extra params
{
  TCurrency cellCurrency = cellStruct->cell;
  // 10/01/94 [21222] TCurrency cellParent = 
  CellCommit(currency, cellCurrency, command, anchor, activeEnd, TRUE);

  // 10/01/94 [21222] if (cellParent == currency)    // 22/01/91
  // 10/01/94 [21222]     fDocument->DeleteCurrency(cellCurrency);
}


// ------------------------------------------------------------------------
void _TColumnStructure::Commit(TCurrency currency, TCursorNode anchor,
                    TCursorNode activeEnd, TCommand command, bool freeParts)
{
  TCellRect cellCoords;
//  TStructure theCell;
  bool canDelete;
  TStyleTypes styleType;
  TStructTypes structType;

  if (fUndoStructure != NULL && fUndoStructure != TObject(-1)) // 14/7/92
  {
    canDelete = (command == NULL) || // 21/8/92
                        !(CmdToStruct(command->fCmdNumber, styleType, structType) &&
                           command->fCmdDone);
    fUndoStructure->GetAllCells(cellCoords);
    if (canDelete)
      fUndoStructure->ForSelectedCellsDo(this, cellCoords,
        (Action)_TColumnStructure::CommitCell, command, currency, anchor, activeEnd);
                                                           // 03/09/92 extra params
    fUndoStructure->Free();
    fUndoStructure = NULL;
    ClearRect(*((Rect *)&fUndoCoords));
    Commit(currency, NULL, NULL, command, freeParts);    // 10/09/92 commit the rest???
  }
  else
  {
    switch (command->fCmdNumber)
    {
      case cSpan:
      case cAddRow:
      case cAddColumn:
          TAddRowColCommand(command)->CommitState();
          break;
      default:
      {
        register TCellRect *cgf_96 = &cellCoords;

        // 27/11/91 didnt always throw tables away on commit, so added if freeParts clause
        TSelShape scope = GetSelectedCells(cellCoords, anchor, activeEnd); 

        if (freeParts)
          ForSelectedCellsDo(this, cellCoords, 
            (Action)_TColumnStructure::CommitCell, command, currency, anchor, activeEnd);
                                                           // 03/09/92 extra params
        else
          if (anchor != NULL || activeEnd != NULL || fUndoStructure == NULL) // 14/7/92
            switch (scope) //27/11/91
            {
              case kWithinCell:
                 PCellItem cellItem = AtRowCol(cgf_96->startRow, cgf_96->startCol);

                 cellItem->colChange = FALSE;  // 23/01/91 clear 2 flags
                 cellItem->rowChange = FALSE;
                 CellCommit(currency, cellItem->cell,
                                   command, anchor, activeEnd, freeParts);
                  break;
              case kRowWise:
                   // prev. CommitRows(cellCoords) local proc

                 if (command->fCmdNumber == cTyping)
                     GetAllCells(cellCoords);
                                // 03/09/92 not necessarily correct block after deleting
                   // 19/09/90 reversed loop direction
                 for (int rn = cellCoords.endRow; rn >= cellCoords.startRow; rn--)
                     CommitRow(currency, rn, anchor, activeEnd, command);
                 break;
              case kColumnWise:
              case kBlockOfCells: // 22/6/92
                   // prev. CommitColumns(cellCoords) local proc

                 if (command->fCmdNumber == cTyping)
                    GetAllCells(cellCoords);
                                // 03/09/92 not necessarily correct block after deleting
                 // 19/09/90 reversed loop direction
                 for (int cn = cellCoords.endCol; cn >= cellCoords.startCol; cn--)
                     CommitColumn(currency, cn, anchor, activeEnd, command);
                 break;
            }
        fUndoStructure = NULL; // 14/7/92
      }
    }
  }
}


// ------------------------------------------------------------------------
PCellItem _TColumnStructure::AtRowCol(int row, int column)
{
#ifdef TRACE
  Assert(row <= fNumberOfRows && column <= fNumberOfColumns, 86);
#endif
  return PCellItem(At((row - 1) * fNumberOfColumns + column));
}

// ------------------------------------------------------------------------
bool _TColumnStructure::RowColHidden(int rowCol, bool testRow)
{
  if (testRow)
  {
    for (int n = 1; n <= fNumberOfColumns; n++)
      if (!AtRowCol(rowCol, n)->hidden) 
        return FALSE;
  }
  else
  {
    for (int n = 1; n <= fNumberOfRows; n++)
      if (!AtRowCol(n, rowCol)->hidden) 
        return FALSE;
  }
  return TRUE;
}

// ------------------------------------------------------------------------
int _TColumnStructure::GetRowColNumber(int rowCol, bool testRow)
{
  int rc = 0;
  for (int n = 1; n <= rowCol; n++)
    if (!RowColHidden(n, testRow))
      rc++;
  return rc;
}

// ------------------------------------------------------------------------
void _TColumnStructure::InstallStyleChange(TCurrency currency,
                    TStyleFormat theChanges, int part, Rect &custom, CmdNumber cmd)
{
  Rect cellRect;
  TCurrency oldChanges = (
#ifdef WORD7
                   cmd == cNoCommand ? 0 :    // 26/04/96 do not set up undo for cNoCommand
#endif
                                       fChanges);

  MoveRect(cellRect, custom);
  if (part == kRowPart && custom.top/*startRow*/ != custom.left/*endRow*/)
  {
    for (int n = custom.top /*startRow*/; n <= custom.left /*endRow*/; n++)
    {
      cellRect.top /*startRow*/ = n;
      cellRect.left /*endRow*/ = n;
      _TStructure::InstallStyleChange(currency, theChanges, part, cellRect, cmd);
      fUndoChanges = 0;   // for assertion check in TStructure::InstallStyleChange next iteration
      if (part >= 0)      // 24/02/92 new clause to stop creating dozens of styles
        part = -part;
    }
    fUndoChanges = oldChanges;
  }
  else if (part == kColPart && custom.bottom/*startCol*/ != custom.right/*endCol*/)
  {
    for (int m = custom.bottom/*startCol*/; m <= custom.right/*endCol*/; m++)
    {
      cellRect.bottom/*startCol*/ = m;
      cellRect.right/*endCol*/ = m;
      _TStructure::InstallStyleChange(currency, theChanges, part, cellRect, cmd);
      fUndoChanges = 0;   // for assertion check in TStructure::InstallStyleChange next iteration
      if (part >= 0)      // 24/02/92 new clause to stop creating dozens of styles
        part = -part;
    }
    fUndoChanges = oldChanges;
  }
  else
    _TStructure::InstallStyleChange(currency, theChanges, part, custom, cmd);
}


#ifdef FN
// ------------------------------------------------------------------------
int _TColumnStructure::GetOrder(TCurrency c1, TCurrency c2)
// 22/4/92 replaced GetNoteIndex
{
  int n1 = 0, n2 = 0;

  for (int c = 0; c <= 1; c++)
  {
    for (int n = 1; n <= fSize; n++)
    {
      PCellItem p = PCellItem(At(n));

      if (p->cell == (c == 0? c1 : c2))
      {
        if (c == 0)
          n1 = n;
        else
          n2 = n;
        break;
      }
    }
  }
  return n1 - n2;}
#endif

// end of objects not required for StartWrite
#endif

// ------------------------------------------------------------------------
_TColumnStyleStructure::_TColumnStyleStructure(TTextDocument itsDocument
           /*, TCurrency itsParent, TCurrency itsOwnStyle, char* itsName */)
        : (itsDocument, /* itsParent, itsOwnStyle,*/ kColumns /*, itsName */)
{
#ifndef ZERO_OBJ
  fNumRowStyles = 0;
  fNumColStyles = 0;
#endif
}


// NB: The TColumnStyleStructure array part looks like:
// <array elements ...> <    sparse array data    >
//                      <row styles><column styles>


// ------------------------------------------------------------------------
void _TColumnStyleStructure::ForAllPartsDo(TObject obj, DoToStyles procToDo,
         TStyleStructure styleStruct, TMainView theView, int *idx)
{
  PStyleIndex styleIndex;
  Rect cellRect;
  int n;
  TPartStyles partStyles;

  ClearRect(cellRect);
  GetPartStyles(kAllColsBody, cellRect, partStyles);

  if (partStyles.fStyle != 0)
    procToDo(obj, kAllColsBody, cellRect, partStyles.fStyle, styleStruct, theView, idx);

  styleIndex = // PStyleIndex(int(At(fSize)) + fItemSize);
               PStyleIndex(int(fPtrToArray) + fSize * sizeof(TPartStyles));
  //if (fNumRowStyles > 0)      
  {
    for (n = 0; n < fNumRowStyles; n++, styleIndex++)
    {
      PCellRect(&cellRect)->endRow = PCellRect(&cellRect)->startRow = styleIndex->rowCol;
      GetPartStyles(kRowPart, cellRect, partStyles);
      if (partStyles.fStyle != 0)
        procToDo(obj, kRowPart, cellRect, partStyles.fStyle, styleStruct, theView, idx);
    }
  }
  // if (fNumColStyles > 0)
  {
    ClearRect(cellRect);
    // styleIndex = PStyleIndex(int(At(fSize)) + fItemSize +
    //                             (fNumRowStyles * sizeof(TStyleIndexEntry)));

    for (n = 0; n < fNumColStyles; n++, styleIndex++)
    {
      PCellRect(&cellRect)->endCol = PCellRect(&cellRect)->startCol = styleIndex->rowCol;
      GetPartStyles(kColPart, cellRect, partStyles);
      if (partStyles.fStyle != 0)       // 09/04/92 for protection; any ideas why???
        procToDo(obj, kColPart, cellRect, partStyles.fStyle, styleStruct, theView, idx);
    }
  }
}


// ------------------------------------------------------------------------
int _TColumnStyleStructure::ComputeIndex(int part, Rect &custom)
{
  int  ComputeIndex_r;
  PStyleIndex styleIndex;
  int i, theRowCol, limit;
  PCellRect rect = PCellRect(&custom);

  ComputeIndex_r = fSize + 1;
  if (part == kAllColsBody)
  {
    if (fSize > fNumRowStyles + fNumColStyles)
      ComputeIndex_r--;   // = fSize;
  } 
  else
  {
    if (fSize > (fSize > fNumRowStyles + fNumColStyles? 1 : 0))
    {
      styleIndex = PStyleIndex(int(fPtrToArray) + fSize * sizeof(TPartStyles));
      if (part == kRowPart)
      {
        theRowCol = rect->startRow;
        limit = fNumRowStyles;
        // styleIndex = PStyleIndex(int(At(fSize)) + fItemSize);
      }
      else
      {
        theRowCol = rect->startCol;
        limit = fNumColStyles;
        //styleIndex = PStyleIndex(int(At(fSize)) + fItemSize +
        //                         (fNumRowStyles * sizeof(TStyleIndexEntry)));
        styleIndex += fNumRowStyles;
      }

      for (i = 0; i < limit; i++, styleIndex++)
      {
        if (styleIndex->rowCol == theRowCol)
          return styleIndex->index;
      }
    }
  }
  return ComputeIndex_r;
}

#ifdef TABLES
// ------------------------------------------------------------------------
void _TColumnStyleStructure::PutPartStyles(int part, Rect &custom, TPartStyles &partStyles)
{
  int index;
  TStyleIndexEntry indexEntry;

  index = ComputeIndex(part, custom);
  if (index <= fSize)
    AtPut(index, &partStyles);
  else if (part == kAllColsBody)
    InsertLast(&partStyles); 
  else
  {
    TCellRect rect;
    int numStyles;

    MoveRect(*((Rect *)&rect), custom);
    FailSpaceIsLow();
    numStyles = (part == kColPart ? rect.endCol - rect.startCol :
                                    rect.endRow - rect.startRow) + 1;
    while (numStyles > 0)
    {
      // 05/01/94 replace ChangeHandleSize by InsertSlice
      int styleOffset;
      int *numXStyles;

      numStyles--;
      indexEntry.index = fSize; // 22/4/92
      if (fSize > fNumRowStyles + fNumColStyles)
        InsertBefore(fSize, &partStyles);
      else
      {
        InsertLast(&partStyles);
        indexEntry.index++;
      }
      styleOffset = fSize * sizeof(TPartStyles);
      if (part == kRowPart)
      {
        indexEntry.rowCol = rect.startRow;
        rect.startRow++;
        numXStyles = &fNumRowStyles;
      }
      else
      {
        styleOffset += fNumRowStyles * sizeof(TStyleIndexEntry);
        indexEntry.rowCol = rect.startCol;
        rect.startCol++;
        numXStyles = &fNumColStyles;
      }
      InsertSlice(styleOffset, &indexEntry, sizeof(TStyleIndexEntry));
      (*numXStyles)++;
    }
  }
}
#endif


// ------------------------------------------------------------------------
void _TColumnStyleStructure::DoRead(int aRefNum, long remainder, int version)
{
  // 08/08/90 - new method to read in data at the end of an array

  _TStyleStructure::DoRead(aRefNum, remainder, version); // read the main part
}


// ------------------------------------------------------------------------
void _TColumnStyleStructure::DoWrite(int aRefNum, long remainder)
{
  // 08/08/90 - new method to save current private data size

  fPrivateDataSize = GetHandleSize(fPtrToArray) - fSize * fItemSize;
  _TStyleStructure::DoWrite(aRefNum, remainder);
}


// ------------------------------------------------------------------------
long _TColumnStyleStructure::DoNeedDiskSpace(long dataForkBytes)
{
  // 08/08/90 - new method to add private data size
  return _TStyleStructure::DoNeedDiskSpace(GetHandleSize(fPtrToArray) -
                                     (fSize * fItemSize) + dataForkBytes);
}


// ------------------------------------------------------------------------
void _TColumnStyleStructure::DoReadArrayPart(int aRefNum, int version)
{
  //  as array but also copy the private data onto the end of the array
  int oldSize = fPrivateDataSize + fSize * fItemSize;

  SetPermHandleSize(&fPtrToArray, oldSize);
  FRead(aRefNum, oldSize, fPtrToArray);
}


// ------------------------------------------------------------------------
void _TColumnStyleStructure::DoWriteArrayPart(int aRefNum)
{
  // write the private data from the array onto disc
  FWrite(aRefNum, fPrivateDataSize + fSize * fItemSize, fPtrToArray);
}


// ------------------------------------------------------------------------
_TColumnStyleFormat::_TColumnStyleFormat(void) : ()
{
  fAutomatic = TRUE;
//  fCaption = kBtmCaption;
#ifndef ZERO_OBJ
  fDefinedInStyle = 0;       // 19/09/90 from keep together and auto
  fKeepTogether = FALSE;
#endif
  fDefined |= (kHasAdornment | kHasSpaceBefore |
               kHasSpaceAfter | kHasMargins | kHasAlignment);
}


// ------------------------------------------------------------------------
void _TColumnStyleFormat::IRes(char* &itsResource)
{
  int strOffset;

  _TStyleFormat::IRes(itsResource);

  sscanf(itsResource, " %x %d %d %n ", &fDefinedInStyle, &fAutomatic,
         &fKeepTogether, &strOffset);
  OffsetPtr(itsResource, strOffset);
}


// -------------------------------------------------------------------------
bool _TColumnStyleFormat::IsStyleMember(int matchType)
{
// 04/01/91 needed for Member replacement in ApplyOverride

  return (matchType & (TStyleFormatType | TRulerDefType | TColumnStyleType)) != 0;
}

#ifdef TABLES
// ------------------------------------------------------------------------
int _TColumnStyleFormat::GetChangeDlg(TStyleTypes type)
{
  return (type == kColumns ? kColStyleDlg : kTextAttrsDlgID);
}


// ------------------------------------------------------------------------
Fixed _TColumnStyleFormat::ColPosition(int column)
{
  Fixed  ColPosition_r;

  if (column > fSize)
  {
    ColPosition_r = (fSize == 0 ? 0 : PFTabInfo(At(fSize))->fStop) +
                                         FixPointVal(720) * (column - fSize);
  }
  else
    ColPosition_r = (PFTabInfo(At(column)))->fStop;

  return ColPosition_r - GetLeftMargin();
}


// ------------------------------------------------------------------------
bool _TColumnStyleFormat::CanAddTabs(void)
{
  return FALSE;
}


// ------------------------------------------------------------------------
void _TColumnStyleFormat::SetAuto(bool automatic)
{
  fAutomatic = automatic;
}


// ------------------------------------------------------------------------
bool _TColumnStyleFormat::GetAuto()
{
  return fAutomatic;
}


// -------------------------------------------------------------------------
int _TColumnStyleFormat::NumOfAttrs(int ignore)
{
  if (fDefinedInStyle != 0)
    return 1;
  return _TStyleFormat::NumOfAttrs(ignore);
}


// -------------------------------------------------------------------------
void _TColumnStyleFormat::DeleteAttribute(TStyleFormat changes, int attrNum)
// 04/01/91 at the moment delete all the attributes
{
  TColumnStyleFormat(changes)->fDefinedInStyle = 0;
  _TStyleFormat::DeleteAttribute(changes, attrNum);
}


// ------------------------------------------------------------------------
void _TColumnStyleFormat::Copy(TRulerDef newStyle)
{
  _TStyleFormat::Copy(newStyle);

  if (newStyle->IsStyleMember(TColumnStyleType))           // 01/04/92
    memcpy(((char *)newStyle) + sizeof(_TStyleFormat),   // to newStyle
         ((char *)this) + sizeof(_TStyleFormat),         // from self
         sizeof(_TColumnStyleFormat) - sizeof(_TStyleFormat));
}


// ------------------------------------------------------------------------
void _TColumnStyleFormat::ApplyOverride(TRulerDef derivative,
                                        TCurrency currency, bool applyRuler)
{
  if (derivative->IsStyleMember(TColumnStyleType))  // 22/01/91
  {
    if (TColumnStyleFormat(derivative)->fDefinedInStyle & kAutomatic)
    {
      fDefinedInStyle |= kAutomatic;
      fAutomatic = TColumnStyleFormat(derivative)->fAutomatic;
    }

    if (TColumnStyleFormat(derivative)->fDefinedInStyle & kKeepTogether)
    {
      fDefinedInStyle |= kKeepTogether;
      fKeepTogether = TColumnStyleFormat(derivative)->fKeepTogether;
    }
  }
  _TStyleFormat::ApplyOverride(derivative, currency, applyRuler);
}


// ------------------------------------------------------------------------
void _TColumnStyleFormat::GetDescription(char* description)
{
  int strNum = 1;

  _TStyleFormat::GetDescription(description);
  for (int attr = kAutomatic; attr <= kKeepTogether; attr <<= 1, strNum++)
  {
    if ((fDefinedInStyle & attr) != 0)
    {
      AppendAttr(GetIndString(kColStyleStrs, strNum), "", description);
      // key = GetIndString(kColStyleStrs, strNum);
      // if (key != NULL && strlen(description) + strlen(key) < 253)
      // {
      //   if (description[0] != 0)
      //     strcat(description, " + ");
      //   strcat(description, key);
      // }
    }
  }
}


// ------------------------------------------------------------------------
bool _TColumnStyleFormat::Match(TStyleFormat theStyle)
{
  if (_TStyleFormat::Match(theStyle) &&
      fDefinedInStyle == TColumnStyleFormat(theStyle)->fDefinedInStyle &&
    ((fDefinedInStyle & kAutomatic) == 0 ||
        fAutomatic == TColumnStyleFormat(theStyle)->fAutomatic) &&
    ((fDefinedInStyle & kKeepTogether) == 0 ||
        fKeepTogether == TColumnStyleFormat(theStyle)->fKeepTogether))
    return TRUE;
  return FALSE;
}


// ------------------------------------------------------------------------
_TColumnsView::_TColumnsView(TView itsSuperView, TMainView itsMainView,
               TSubView itsNextView, VPoint &itsLocation, VPoint &itsSize,
               TCurrency itsCurrency, int itsSpBefore, int itsSpAfter)
             : (itsMainView->fDocument, itsSuperView, itsMainView,
                itsNextView, itsLocation, itsSize,
                // sizeVariable, sizeVariable,
                itsCurrency, itsSpBefore, itsSpAfter)
{
#ifndef ZERO_OBJ
  fHeadingSuppressed /* fCellSelecting 31/01/94 */ = FALSE;
  fHeadingState = FALSE;
#endif
  fFirstRow = 1;
  fLastRow = 1;
}


// ------------------------------------------------------------------------
void _TColumnsView::DrawAdornment(Rect &area)
{
  TRuleType saveRuleType;
  CntlAdornment saveAdornment;
  Rect extent;
  TColFormat format;
  TRuleType  ruleType;
  CntlAdornment ruleBorders;
  VRect ruleWidths;

  _TSubView::DrawAdornment(area);

  format = TColFormat(GetMyFormatReadOnly());
  GetQDExtent(extent);
  format->GetBorderInfo(ruleWidths, ruleBorders, ruleType);
  extent.left += FixRound(ZoomFixed(ruleWidths.left));
  // 16/07/91 use line thicknesses rather than line + inset for drawing
  GetBorderThicknessRect(ruleWidths, ruleBorders, ruleType);
  ZoomVRect(ruleWidths);

  extent.top += FixRound(ruleWidths.top) + fSpBefore;        // 20/06/91
  extent.bottom -= (FixRound(ruleWidths.bottom) + fSpAfter); // spB & spA
  saveRuleType = fRuleType;
  saveAdornment = fAdornment;
  for (int cn = 1; cn <= format->fNumberOfColumns; cn++)
  {
    Rect colExtent;
    TRuleType ruleType;
    CntlAdornment adornment;
    Fixed offset;

    format->GetColBorders(cn, ruleType, adornment);
    if (adornment != 0)
    {
      MoveRect(colExtent, extent);
      offset = ZoomFixed(format->GetColRtEdge(cn - 1));
      colExtent.left += FixRound(offset);
      offset = ZoomFixed(format->GetColRtEdge(cn));
      colExtent.right = extent.left + FixRound(offset);
      fRuleType = ruleType;
      fAdornment = adornment;
      if (!EmptyRect(colExtent)) // 21/11/91
        DrawBorders(area, colExtent);
    }
  }
  fRuleType = saveRuleType;
  fAdornment = saveAdornment;
}


// ------------------------------------------------------------------------
void _TColumnsView::Draw(Rect &area)
{
  _TSubView::Draw(area);
}


// ------------------------------------------------------------------------
static void DrawColumnChanges(TObject null, TSubView view, bool invalidate,
                              bool installChanges)
{
  view->DrawChanges(invalidate, installChanges);
}


// ------------------------------------------------------------------------
void _TColumnsView::DrawChanges(bool invalidate, bool installChanges)
{
  if (GetMyFormatReadOnly()->fHasChanged)
    EachSubview(NULL, (DoToSubView)DrawColumnChanges, invalidate, installChanges);
  _TSubView::DrawChanges(invalidate, installChanges);
}


// ------------------------------------------------------------------------
void _TColumnsView::DoSetupMenus(void)
{
  bool haveMemory;
  TSelection theSelection;
  TCursorNode activeNode;
  TCursorNode anchorNode;
  TCursor anchorCursor;
  TColumnStructure columnStruct;
  int row1, col1;
  int row2, col2;
  TCellRect cellCoords;
  int idx;

  _TSubView::DoSetupMenus();
  haveMemory = !MemSpaceIsLow();
  theSelection = TTextDocument(fDocument)->GetNewSelection();
  theSelection->GetNodes(fStructure, anchorNode, activeNode);
  columnStruct = TColumnStructure(GetStructureReadOnly(fStructure));
  columnStruct->GetSelectedCells(cellCoords, anchorNode, activeNode);
  anchorCursor = theSelection->GetAnchor();
  idx = anchorCursor->GetSameItemNo(anchorNode);
  TColCursorNode(anchorNode)->GetRowCol(columnStruct, row1, col1);
  TColCursorNode(activeNode)->GetRowCol(columnStruct, row2, col2);
  if (row1 == row2)
  {
    if (col1 == col2 && col1 < columnStruct->fNumberOfColumns)    // 03/02/94
    {
      EnableCmd(cSpan);
#ifdef MATHS
      EnableCmd(cSpanMatrix);
#endif
    }
    if (haveMemory)
    {
      EnableCmd(cAddRowBelow);
      EnableCmd(cAddRowAbove);
    }
  }
  if (col1 == col2 && haveMemory)
  {
    EnableCmd(cAddColumnRight);
    EnableCmd(cAddColumnLeft);
  }
  DisableCmd(cPaste);
  fHeadingState = TRUE;
  for (idx = cellCoords.startRow; idx <= cellCoords.endRow; idx++)
  {
    if (!columnStruct->IsHeadingRow(idx))
      fHeadingState = FALSE;
  }
}


// ------------------------------------------------------------------------
TCommand _TColumnsView::GetRowColCmd(CmdNumber cmd, bool pos)
{
  // 01/09/92 do not create a command if disabled in the menu
  if ((cmd == cAddRow && CmdEnabled(cAddRowBelow)) ||
                             (cmd == cAddColumn && CmdEnabled(cAddColumnRight)))
    return new _TAddRowColCommand(TTextDocument(fDocument),
                                          fMainView, fStructure, cmd, pos);
  return gNoChanges;
}


// ------------------------------------------------------------------------
TCommand _TColumnsView::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
  TSelection selection;
  TCursorNode aCursorNode;
  TCursorNode anchorNode; // 21/11/91 was activeNode
  TColumnStructure structure;
// not used  TCurrency cell;
  int row, column;
  int inCol;
  int oldSpanCount;
  TDialogView aDialogView;
  bool direction = FALSE;
//  bool stdDirection = TRUE;

  selection = TTextDocument(fDocument)->GetNewSelection();
  selection->GetNodes(fStructure, anchorNode, aCursorNode); // 21/11/91 changed params
  structure = TColumnStructure(GetStructureReadOnly(fStructure));

  switch (aCmdNumber)
  {
#ifdef MATHS
    case cSpanMatrix:
#endif
    case cSpan:
      // 15/06/91 do in-line to avoid a special class for TSpanDialog
      // and to allow Adjust click on dialogue to have some effect
      TColCursorNode(aCursorNode)->GetRowCol(structure, oldSpanCount, inCol);
      // inCol = TColCursorNode(aCursorNode)->GetColumn(structure);
      if (inCol == structure->fNumberOfColumns)
        break;             // 03/02/94 if cSpan is enabled, it must have been by a parent
      oldSpanCount = structure->AtRowCol(TColCursorNode(aCursorNode)->
                                 GetRow(structure), inCol)->spanCount + 1;

      aDialogView = TDialogView(NewTemplateWindow1(kSpanDlgID));
      aDialogView->SetReadWriteHandler(this);
      {
        TNumberText spansView = TNumberText(aDialogView->FindSubView(gIDspns));

        if (spansView != NULL)
        {
          spansView->fMaximum = structure->fNumberOfColumns - inCol + 1;
          spansView->SetValue(oldSpanCount, kDontRedraw);
        }
      }
      aDialogView->PoseModally(cSpan);
      aDialogView->Close();
      return gNoChanges;

    case cKeyAddRow:
      // 11/12/92 redone to avoid having to use committed table data
      TColCursorNode(aCursorNode)->GetRowCol(structure, row, column);
      // 11/12/92 redone to avoid having to use committed table data
      row++;
      structure->FindNextVisible(row, column, 1);
      if (row <= structure->fNumberOfRows)
      {
        selection->MoveCursor(0x18e /* down */, info, fMainView);
        return gNoChanges;
      }
      // else run on
    case cAddRowBelow:
    case cAddRow:
      direction = TRUE;
    case cAddRowAbove:
      return GetRowColCmd(cAddRow, direction);

    case cKeyAddColumn:
      TColCursorNode(aCursorNode)->GetRowCol(structure, row, column);
      do
      {
        column++;
      } while (column != structure->FindMasterCell(row, column));
      structure->FindNextVisible(row, column, 1);
      if (column <= structure->FindMasterCell(row, structure->fNumberOfColumns))
      {
        structure->ResetCursor(aCursorNode, PackTwoShorts(row, column), TRUE, FALSE);
        TTextDocument(fDocument)->ScrollSelectionIntoView();
        selection->DoMenus(TRUE);
        return gNoChanges;
      }
//      if (fMainView->GetFormatReadOnly(fStructure)->fFlags)
//        stdDirection = FALSE;     // for backwards tables
      // else run on
    case cAddColumnRight:
    case cAddColumn:
      direction = TRUE;  // stdDirection;
    case cAddColumnLeft:
      return GetRowColCmd(cAddColumn, direction);

    case cNewTableMenu:
      aCmdNumber = cTable; // 08/08/90 - get the cmd into a cTable
    case cTable:
#ifdef MATHS
    case cMatrix:  // 30/01/92
    case cNewMatrix:  // 14/04/92
    case cEquation:   // 07/01/94 why not allowed?
#endif
    case cPicture:         // 19/09/90 - 10/05/91 moved to right place
      if (structure->AllSelected(fStructure, anchorNode, aCursorNode))
        break;  // 03/02/94
      return new _TNewStructureCmd(TTextDocument(
                  /* fMainView-> */ fDocument), aCmdNumber, fStructure);
  }
  return _TSubView::DoMenuCommand(info, aCmdNumber);
}


// -------------------------------------------------------------------------
TCommand _TColumnsView::ReadFromDialog(TView aDialogView, CmdNumber aCmd,
                                                              IDType itsID)
{
  if (aCmd == cSpan)
  {
    TNumberText spansView = TNumberText(aDialogView->FindSubView(gIDspns));

    if (spansView != NULL)
      return new _TSpanColumnCommand(TTextDocument(fDocument), fStructure,
                                  fMainView, spansView->GetValue() - 1);
    else
      return gNoChanges;
  }
  return _TSubView::ReadFromDialog(aDialogView, aCmd, itsID);
}


// ------------------------------------------------------------------------
int _TColumnsView::GetPointerShape(Point &localPoint)
{
  return iBeamCursor; // SetCursor(GetCursor(iBeamCursor));
}


// ------------------------------------------------------------------------
TCursorNode _TColumnsView::ClickOnce(VPoint &mousePoint)
{
  TSubView nearestView;
  long deltaMin;
  TColCursorNode myNode;
  TCursorNode subNode;
  VPoint newMouse;

  nearestView = 0;
  deltaMin = MAXLONGINT;
  EachSubview(this, (DoToSubView)_TColumnsView::TestNearestToMouse,
              &mousePoint, &newMouse, &deltaMin, &nearestView);

  myNode = new _TColCursorNode(fStructure, fIdentifier, newMouse);
  subNode = nearestView->ClickOnce(newMouse);
  myNode->SetCell(subNode->fCurrency);
  myNode->fSavedNode = subNode;

  return myNode;
}


// ------------------------------------------------------------------------
_TColCursorNode::_TColCursorNode(TCurrency itsCurrency, IDType itsIdent,
           VPoint &mousePt) : (itsCurrency, itsIdent, mousePt)
{
#ifndef ZERO_OBJ
  fCell = 0;
  fSpanOffset = 0;
#endif
  fLastRow = 1;
}


// ------------------------------------------------------------------------
void _TColCursorNode::SetCell(TCurrency cell)
{
  fCell = cell;
}


// ------------------------------------------------------------------------
TCurrency _TColCursorNode::GetCell(void)
{
  return fCell;
}


// ------------------------------------------------------------------------
bool _TColCursorNode::Equal(TCursorNode node)
{
  return (_TCursorNode::Equal(node) && fCell == TColCursorNode(node)->fCell);
}


// ------------------------------------------------------------------------
void _TColCursorNode::SetSpanOffset(int spanOffset)
{
  fSpanOffset = spanOffset;
}


// ------------------------------------------------------------------------
void _TColCursorNode::GetRowCol(TColumnStructure structure, int &row,
                                int &col)
{
  structure->FindCell(fCell, row, col);
  col = Min(structure->fNumberOfColumns, col + fSpanOffset);
      // 14/04/94 [21624] not perfect, but should stop crashes, etc after delete spanned col
}


// ------------------------------------------------------------------------
int _TColCursorNode::GetRow(TColumnStructure structure)
{
  int r, c;

  GetRowCol(structure, r, c);
  return r;
}


// ------------------------------------------------------------------------
int _TColCursorNode::GetSpanOffset(void)
{
  return fSpanOffset;
}


// ------------------------------------------------------------------------
void _TColCursorNode::Copy(TCursorNode cursorNode)
{
  fCell = TColCursorNode(cursorNode)->fCell;
  fSpanOffset = TColCursorNode(cursorNode)->fSpanOffset;
  fLastRow = TColCursorNode(cursorNode)->fLastRow;
  _TCursorNode::Copy(cursorNode);
}
// end of objects not needed for StartWrite
#endif
