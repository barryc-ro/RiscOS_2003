/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

#include "akbd.h"
#include "dbox.h"

#include "UDialog.h"
#include "PackTempl.h"
#ifdef TABLES
#include "UPopup.h"
#endif

TScalePars gScalePars[] = {
   {03, 01, 01, 01, 01, 03},        /* Inches      */
   {01, 04, 01, 01, 01, 03},        /* DecInches   */
   {01, 04, 01, 01, 05, 10},        /* Centimetres */
   {01, 04, 10, 02, 05, 10},        /* Millimetres */
   {05, 01, 72, 01, 02, 05},        /* Points      */
   {05, 01, 06, 01, 02, 05},        /* Picas       */
   {05, 01, 72, 01, 02, 05},        /* Didots      */
   {05, 01, 06, 01, 02, 05},        /* Ciceros     */
   {01, 04, 10, 01, 02, 05},        /* Custom      */
   {05, 01, 72, 01, 02, 05},        /* Point16     */
   {05, 01, 72, 01, 02, 05},        /* Point10     */
};

#define ePoint10 10

#define kInvalidValueReasons 9
  // 19/03/93 was 10, but kNoFilenameDot inserted as e10

typedef enum
{
   atStart,
   inMiddle,
   atEnd
} TConvState;


// -------------------------------------------------------------------------
static bool DialogView_RawHandler(dbox d, void* event, void* handle)
{
#ifdef TRACE
   Assert(d == dbox(TDialogView(handle)->fDbox), 37);
#endif

   if (((wr_wimp_eventstr *)event)->e == wr_wimp_ECLOSE)
     return FALSE;      // 10/05/92 avoid deleting window behind scenes

   return(wind_HandleEvent((wr_wimp_eventstr *)event, handle));
}


// -------------------------------------------------------------------------
// called whenever a buttonclick has been artificially generated by the dbox
// as a result of fn key presses etc..

static void DialogView_EventHandler(dbox d, void* handle)
{
   TCommand tempCmd = gNoChanges;
   EventInfo info;
   wr_wimp_eventstr e;
   bool found;

#ifdef TRACE
   Assert(d == dbox(TDialogView(handle)->fDbox), 37);
#endif

   // create a dummy structure for the keypress occurance
   e.e = wr_wimp_EKEY;
   e.data.but.m.w = wr_dbox_syshandle(dbox(d));
   e.data.but.m.i = wr_dbox_read(d);
   e.data.but.m.x = 0;
   e.data.but.m.y = 0;
   e.data.but.m.bbits = wr_wimp_BLEFT;
   if (e.data.but.m.i == wr_dbox_CLOSE)      // 04/09/94 for non pose-modally dbox
   {
     if (TDialogView(handle)->fIdentifier == I_('w', 'l', 'i', 's')) // need better frig!!!
       TDialogView(handle)->Close();     // or CloseByUser?
   }
   else
   {
     app_GetEventInfo(&info, &e);
     info.theClickCount = 1;

     found = TDialogView(handle)->HandleControlClick(info, tempCmd);
#ifdef TRACE
     Assert(!found || tempCmd == gNoChanges, 398);
#endif
   }
}


// ------------------------------------------------------------------------
// 26/11/93 [21127] Moved from UTextComm
TCommand DoDialogue(THandler target, CmdNumber cmd, int dlgId, int ignoreFlags)
{
  TDialogView aDialogView;

  aDialogView = TDialogView(NewTemplateWindow1(dlgId));
  aDialogView->fKeyFlags = ignoreFlags;
  aDialogView->SetIdleFreq(0);         // 13/11/90 re-applied
  aDialogView->SetReadWriteHandler(target);
  aDialogView->PoseModally(cmd);
  aDialogView->Close();

  return gNoChanges;
}


// =========================================================================
_TDialogView::_TDialogView(TDocument itsDoc, TView itsSupV, char* &itsParams)
                        : (itsDoc, itsSupV, itsParams)
{
//   int  strOffset;
//   char cancelItem[5];
   wr_wimp_eventstr *e;

   // dbox will not convert an f10 press to an icon, but leave it in the
   // mask in case this changes in the future

   fKeyFlags = -1;           // no check
   fClosingIcon = wr_dbox_CLOSE;  // 21/07/93
#ifndef ZERO_OBJ
   fCurrentEditText = NULL;
//   fDismissed = FALSE;
//   fDismisser = kNoIdentifier;
   fCallingObject = NULL;
#endif

   // sscanf(itsParams," %s %n", cancelItem, &strOffset);
   // OffsetPtr(itsParams, strOffset);
//   ReadString(itsParams, cancelItem);

   // initialise the dialogview identifier
   fCancelItem = ReadID(itsParams);
  // fCancelItem  = StrToID(cancelItem);
//   fOpenInitially = TRUE;
   // could set fOpenInitially in all the resources messages, but dialogues
   // should always be opened by NewTemplateWindow. EXCEPT dboxQuery one!

  if (itsDoc != NULL)
  {
    itsDoc->DeleteWindow(this);   // do not keep me in your window list
    gApplication->AddFreeWindow(this);   // 19/11/90 but make sure of Idles
  }

  // 12/05/91 stop dflt menu handling for adjust
  e = wr_wimpt_last_event();
  if (e->e == wr_wimp_EMENU)
    e->e = wr_wimp_ENULL;
}


// -------------------------------------------------------------------------
void _TDialogView::Open()
{
   FailInfo fi;
   int w;

   CatchFailures(&fi);
   // set up the dbox window here as it cannot be set up in TWindow
   if (fDbox == NULL)
     fDbox = wr_dbox_find_template(fTemplateName);  // 08/03/93 [20806] for re-open 3d bar
   // Get Controls reset to 3d here before create_wind
   PreOpen();                                    // 08/03/93 [20806]
   if (wr_dbox_create_wind(dbox(fDbox)) == NULL)
   {
     fDbox = NULL;     // 03/07/91 tidy up
     FailNoFail();       // error already reported
   }
   w = wr_dbox_syshandle(dbox(fDbox));
   fWindowRecord.SetHandle(w);
   // 30/05/91 experiment
   fMenuTreeExists = SetDlogSubMenu(w); // wr_dbox_syshandle(dbox(fDbox)));   // 31/05/91
   wr_dbox_raw_eventhandler(dbox(fDbox), DialogView_RawHandler, this);

   wr_dbox_eventhandler(dbox(fDbox), DialogView_EventHandler, this);
#ifdef TABLES
   if (fShowStatic)
     fMenuData = new _TMenu(0, this, NULL, w); // 19/02/93 [20708], 16/01/94
     // fMenuData = new _TPopupMenu(0, this, NULL, w); // 19/02/93 [20708]
#endif
   Success(&fi);
   _TWindow::Open();
   return;

// ++++++++++++++++++++ Exception handler +++++++++++++++++++++++++
Rescue:
   CloseWindow();
   ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TDialogView::CloseWindow()
{
   wr_wimp_caretstr caret;
   
#if defined TABLES || SIDEBAR == 1
   ClearObject(fMenuData);    // 19/02/93 [20708]
#endif
   if (fDbox != NULL)
   {
//      wr_wimp_mousestr mousestr;
//      wr_wimp_w w = fWindowRecord.GetHandle();

      wr_dbox_raw_eventhandler(dbox(fDbox), NULL, NULL);
      wr_dbox_eventhandler(dbox(fDbox), NULL, NULL);
      if (fClosingIcon != wr_dbox_CLOSE)
      {
//      wr_wimp_icon result;
//      while(wr_wimp_get_icon_info(fWindowRecord.GetHandle(), fClosingIcon, &result) == NULL &&
//                                         (result.flags & wr_wimp_ISELECTED) != 0)
//       event_process();
//        wr_wimp_get_point_info(&mousestr);
//        if (mousestr.w == w && mousestr.bbits != 0)
          WaitForMouseRelease();
      }
      wr_dbox_dispose((dbox *)&fDbox);
      fDbox = NULL;
   }

   // we have just deleted the dbox window so make sure nobody else
   // tries to delete it
   fWindowRecord.SetHandle(kNoWindow);
   _TWindow::CloseWindow();

   // 21/05/91 restore caret in window; the target if not done by wimp
   wr_wimpt_noerr(wr_wimp_get_caret_pos(&caret));
   if (caret.w < 0 && gSetUpWindow != NULL)
     gSetUpWindow->fWindowRecord.SetCaret();
}


// -------------------------------------------------------------------------
bool _TDialogView::DoIdle(IdlePhase phase)
{
  if (phase != idleEnd)
  {
    wr_wimp_caretstr caret;
    
    wr_wimpt_noerr(wr_wimp_get_caret_pos(&caret)) ;
    if (caret.w == fWindowRecord.GetHandle())
      SelectEditText(IDFromWimpIcon(caret.i));
  }
  return _TWindow::DoIdle(phase);
}

// -------------------------------------------------------------------------
TCommand _TDialogView::DoKeyCommand(int chcode, EventInfo &info)
{
   // find out if the last field was valid
   if (chcode == 13)
   {
      if (!DeselectCurrentEditText())
      {
         // abort from this operation as the current field is invalid
         info.eventHandled = TRUE;  // do not let dbox at the event
//         return(gNoChanges);
      }
   }
   return gNoChanges;
// we should call the inherited method, but there is a problem that we
// do not want the key (and pass it to wr_wimp_processkey), but dbox will pick
// it up after the raw handler, so we should not pass it on. The best thing
// to do seems to be to avoid calling the last _THandler::DoKeyCommand.
//   return(_TWindow::DoKeyCommand(chcode, info));
}


// -------------------------------------------------------------------------
TCommand _TDialogView::DoCommandKey(int chcode, EventInfo &info)
{
   int tempCode;
   // find out if the last field was valid
   if ((chcode == wr_akbd_UpK) || (chcode == wr_akbd_DownK))
   {
      if (!DeselectCurrentEditText())
      {
         // abort from this operation as the current field is invalid
         info.eventHandled = TRUE;  // do not let dbox at the event
//         return(gNoChanges);
      }
   }

   // 22/05/91 reinstated check for func keys
   if ((chcode > wr_akbd_Fn && chcode < wr_akbd_TabK) ||
        (chcode >= wr_akbd_Fn10 && chcode <= wr_akbd_Fn12))
   {
     tempCode = chcode;
     if (chcode >= wr_akbd_Fn10)
        tempCode = chcode - 64;  // get the fn keys in a f0-f12 order

     if (!Odd(fKeyFlags >> (tempCode - wr_akbd_Fn)))  // keyflag not set
        info.eventHandled = TRUE;  // do not let dbox at the event
   }

   return gNoChanges;

/*
   // 15/06/90 - this block gone as same problems as with DoKeyCommand
   // find out whether we deal with the fn key press or pass it on...
   tempCode = chcode;
   if ((chcode >= wr_akbd_Fn10) && (chcode <= wr_akbd_Fn12))
      tempCode = chcode - 64;  // get the fn keys in a f0-f12 order

   if (Odd(fKeyFlags >> (tempCode - wr_akbd_Fn)))
      return(gNoChanges);  // keyflag set so give the keypress to the dbox

   return(_TWindow::DoCommandKey(chcode, info));
*/
}


// -------------------------------------------------------------------------
TCommand _TDialogView::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
   // 17/01/94 new for [21344]
   TWindow mainWindow = GetWindow();

   if (mainWindow == this)
     return _TWindow::DoMenuCommand(info, aCmdNumber);
   return mainWindow->fTarget->DoMenuCommand(info, aCmdNumber);
}


// -------------------------------------------------------------------------
IDType _TDialogView::PoseModally(CmdNumber dialogCmdCreator)
{
   // 12/07/90 now failures cause dialogue view to close down itself
   bool      dboxOpen;
   bool      firstTime = TRUE;
   wr_wimp_i hitIcon;
   IDType    hitId;
   TControl  theControl = NULL;
   bool      dboxDismissed;
   TCommand  aCommand;
   FailInfo  fi;

   CatchFailures(&fi);
   // these 3 statements do the equivalent of a TWindow::Show
   if (fShowStatic)
      wr_dbox_showstatic(dbox(fDbox));
   else
      wr_dbox_show(dbox(fDbox));
   fWindowRecord.GetWindowState(); // get window in correct state
   fShown = TRUE;

   OpenWindow();  // 27/08/93 So that any panes are correctly positioned above this
   // this is moved to here so that the wimp can find the proper window for
   // inserting the caret

   do
   {
      if (fCallingObject != NULL)
         fCallingObject->WriteToDialog(this, dialogCmdCreator);

      // 30/05/91 experiment
      if (!firstTime && fMenuTreeExists)
         ResetMenu();               // reset menu for Adjust click on dialog

      // keep looping round the dbox
      do
      {
         hitIcon = (firstTime && !fReserved ? wr_dbox_fillin(dbox(fDbox)) : //17/10/94 use fRsv
                           wr_dbox_fillin_fixedcaret(dbox(fDbox))); // 14/08/90
         firstTime = FALSE;

         // find out immediately if ADJ pressed as wr_dbox_persist() looks
         // at the CURRENT mouse state.. if we leave it too late the user
         // could have let go of the button...

         dboxOpen = (wr_dbox_persist() && hitIcon != wr_dbox_CLOSE);

         // a wr_dbox_CLOSE is returned if you press ESC or click on the X icon
         // ??? do we want to do a CANCEL operation if you click on an X ???
         // what is returned if you click outside a window ???

         hitId = (hitIcon == wr_dbox_CLOSE ? fCancelItem :
                                               IDFromWimpIcon(hitIcon));

         dboxDismissed = (hitId == gNoIdentifier ? FALSE :
                    TControl(FindSubView(hitId))->fDismissesDialog);

         if (hitId != fCancelItem && dboxDismissed)
            dboxDismissed = CanDismiss(hitId);  // 25/04/90 new CanDismiss
      } 
      while (hitIcon != wr_dbox_CLOSE && !dboxDismissed);

      fClosingIcon = hitIcon;                   // 21/07/93

      if (fCallingObject != NULL && hitId != fCancelItem)
      {
         aCommand = 
            fCallingObject->ReadFromDialog(this, dialogCmdCreator, hitId);
         gApplication->PerformCommand(aCommand);
      }
   }
   while (dboxOpen);

   Success(&fi);

   return hitId;     // return the identifier of the button hit

// ++++++++++++++++
Rescue:
   Close();
   ContinueFailure(&fi);
}


bool _TDialogView::CanDismiss(IDType hitId)
{                                       // validate fields
   wr_wimp_i wi[20];
   wr_wimp_which_block wb;
   int i;
   bool dboxDismissed = TRUE;

   wb.window = fWindowRecord.GetHandle();          /* handle */
   wb.bit_mask = 0x0040F000;    /* bit set => consider this bit */
                                /* mask should be writable & !dimmed */
   wb.bit_set = 0x0000F000;     /* desired bit setting (writable) */
   FailOSErr(wr_wimp_which_icon(&wb, wi));
   for (i = 0; wi[i] != wr_wimp_i(-1); i++)
   {
//      TControl contr = TControl(FindSubView(IDFromWimpIcon(wi[i])));
      TControl contr = TControl(ViewFromWimpIcon(wi[i]));
      TValidationResults res;

#ifdef TRACE
      Assert(contr, 39);
#endif
      res = contr->Validate(TRUE);
      CantDeselect(contr, res);
      if (res != kValidValue)
         dboxDismissed = FALSE;
   }
   return dboxDismissed;
}


// -------------------------------------------------------------------------
void _TDialogView::SetReadWriteHandler(THandler obj)
{
   fCallingObject = obj;
}


// -------------------------------------------------------------------------
bool _TDialogView::SetupDynamicMenu(CmdNumber aCmdNumber, int menuNum, bool create)
{
  if (fCallingObject != NULL && fCallingObject != this)
    return fCallingObject->SetupDynamicMenu(aCmdNumber, menuNum, create);
  return _TWindow::SetupDynamicMenu(aCmdNumber, menuNum, create);
}


// -------------------------------------------------------------------------
bool _TDialogView::DeselectCurrentEditText()
{
   TValidationResults validateResult;

   if (fCurrentEditText != NULL)
   {
//      if ((gLastCommand != NULL) && (gLastCommand->fView == fTEView))
//         gApplication->CommitLastCommand();
      validateResult = fCurrentEditText->Validate(TRUE);
      if (validateResult == kValidValue)
         fCurrentEditText = NULL;
      else
      {
         CantDeselect(fCurrentEditText, validateResult);
         return(FALSE);
      }
   }
   return(TRUE);
}


// -------------------------------------------------------------------------
void _TDialogView::CantDeselect(TControl currText, TValidationResults reason)
{
  if (reason != kValidValue)
  {
    ErrorAlert(reason <= kFractionTooBig ? reason + kInvalidValueReasons :
                      kInvalidValue + kInvalidValueReasons,
                      reason == kNoFilenameDot ? msgPlainMsg : msgFieldFailed);
                      // 22/03/93 suppress prefix for missing dot on SaveAs

    currText->ProdIcon(); // 13/06/90 - get the edittext field redrawn
                          // eg for when inserting closest value
    currText->StartEdit();
  }
}

#ifdef TRACE
// -------------------------------------------------------------------------
TWindow _TDialogView::GetDialogView()
{
   return this;
}
#endif

// -------------------------------------------------------------------------
void _TDialogView::SelectEditText(IDType itsIdentifier /* ,bool selchars */)
{
   TControl aSubView = TControl(FindSubView(itsIdentifier));

   if (aSubView != NULL && aSubView->IsWriteable())
      DoSelectEditText(aSubView);
}


// -------------------------------------------------------------------------
void _TDialogView::DoSelectEditText(TControl theEditText)
{
   if (theEditText != fCurrentEditText)
   {
      // the texts are different so validate the old one
      if (DeselectCurrentEditText())
      {
         // all is ok, make this the new current text
         fCurrentEditText = theEditText;
         if (theEditText != NULL && theEditText->fViewEnabled)
            theEditText->StartEdit();
         else
           SetTarget(this);
         // 27/04/90 'else' added (as Mac); StartEdit sets target to editText
      }
   }
}


// -------------------------------------------------------------------------
void _TDialogView::DoChoice(TView origView, int message)
{
  // 02/09/93 see DoChoice:  if (message == mPopupHit)
  if (message == mScrollingListAdjust || message == mScrollingListHit)
  {
    TScale scale = TScale(TScrollingList(origView)->GetCurrentItem());
    int temp = origView->fIdentifier;
    TFixedPtText theFixedPtTxt;
    char *lookup = "fsbr";

    // 13/09/90 test for s and f fixed pt subviews on menu select
    for (int i = 0; i < 4; i++)
    {
      temp = ((temp & 0x00ffffff) | (lookup[i] << 24));
      if ((theFixedPtTxt = TFixedPtText(FindSubView(temp))) != NULL)
      {
        TValidationResults valResult = theFixedPtTxt->Validate(TRUE);

        if (valResult != kValidValue && valResult != kEmptyValue)
          CantDeselect(theFixedPtTxt, valResult);

        theFixedPtTxt->SetScale(scale,theFixedPtTxt->fCustomPoints, kRedraw);
      }
    }
  }

  if (fCallingObject != NULL && fCallingObject != this)
    fCallingObject->DoChoice(origView, message);  // 26/01/91 Experiment

  _TWindow::DoChoice(origView, message);
}


// -------------------------------------------------------------------------
TValidationResults CvtStrToPoints(Str255 string, TScale units, int custPt,
                                 VCoordinate origin, Fixed& pts)
{
   int        i = 0;
   bool       succeeded = TRUE;
   int        total = 0;
   int        divider = 0;
   int        savedTotal = 0;
   int        theSignIdx = -1;
   int        fixedVal;
   bool       hasPorC = FALSE;
   TConvState state = atStart;
   int        pcMark;
   int        points = 0; // 26/04/90 for safety
   double     floatnum;

   switch (units)
   {
   case ePicas   : pcMark = 'P'; break;
   case eCiceros : pcMark = 'C'; break;
   default       : pcMark = 0;
   }

   while (i < strlen(string) && succeeded)
   {
      int theChar = string[i];

      if (theChar == '+' || theChar == '-')
      {
         if (state != atStart || theSignIdx >= 0)
            succeeded = FALSE;
         theSignIdx = i;
      }
      else if (theChar == ' ')
      {
        if (state != atStart)
            state = atEnd;
      }
      else if (theChar >= '0' && theChar <= '9')
      {
         if (state == atEnd)
            succeeded = FALSE;
         else
         {
            state = inMiddle;
            /******************* check for overflow here ******/
            if (total > (214748363 / kFix1) || divider >= 1000)
            {
               succeeded = (divider != 0);
               i = 0x80000000;
            }
            else
            {
               total = total * 10 + (string[i] - '0');
               divider *= 10;
            }
         }
      }
      else
      {
         if (state == atEnd)
            succeeded = FALSE;
         else if (*gDecPoint == string[i])
         {
            if (divider == 0)
               divider = 1;
            else
               succeeded = FALSE;
            state = inMiddle;
         }
         else if (*gThousSep == string[i])
         {
            if (state == atStart)
               succeeded = FALSE;
         }
         else if (!(hasPorC || (divider != 0)) &&
                  ((string[i] & 223) == pcMark))
         {
            savedTotal = total;
            total = 0;
            hasPorC = TRUE;
            state = inMiddle;
         }
         else
            succeeded = FALSE;
      }
      i++;
   } 

   fixedVal = total * (kFix1 / (divider == 0 ? 1 : divider));
                                   // 21/01/91 was ToFixed(total);

   if (hasPorC)
   {
// 21/01/91      fixedVal = fixedVal / (divider == 0 ? 1 : divider);
      if (fixedVal >= kFixedTwelve)
         return(kFractionTooBig);
      else
         fixedVal = fixedVal / 12 + ToFixed(savedTotal);
/* 21/01/91
      {
         fixedVal = (fixedVal * 12) / 10;  // because the divider now 12
         fixedVal += ToFixed(savedTotal * 12);
         divider = 12;
      }
*/
   }

   if (succeeded)
   {
      if ((theSignIdx >= 0) && (string[theSignIdx] == '-'))
         fixedVal = -fixedVal;

      points = MAXLONGINT;  // 22/09/93 [21048] avoid overflow on fixing large values
      floatnum = 0;  // 0.0?

//      if (fixedVal > maxPtSize)
//      {
      /* do some of the units in floating pt arithmetic */
      // 2.53993 cms/in is what Ordinance Survey gives
      switch (units)
      {
         case eInches:
         case eDecInches:
            points = fixedVal * 720;
            break;
         case eCentimetres:
            floatnum = fixedVal;
            floatnum = ((floatnum * 72000) / 254);
            break;
         case eMillimetres:
            floatnum = fixedVal;
            floatnum = ((floatnum * 7200) / 254);
            break;
         case ePoints:
         case ePoint16:
         case ePoint10:
            points = fixedVal * 10;
            break;
         case ePicas:
            points = fixedVal * 120;
            break;
         case eDidots:
            floatnum = fixedVal;
            floatnum = ((((floatnum * 1238) / 1157) * 72000) / 7227);
            break;
         case eCiceros:
            floatnum = fixedVal;
            floatnum = ((((floatnum * 14856) / 1157) * 72000) / 7227);
            break;
         case eCustom:
            points = fixedVal * custPt * 10;
            break;
      }
      // 22/09/93 [21048] avoid overflow on fixing large values
      if (points == MAXLONGINT && floatnum < MAXLONGINT)
         points = floatnum;
/*    }
      else
      {
         // shouldn't overflow so do as per normal
         switch (units)
         {
            case eCentimetres: points = ((fixedVal * 7200) / 254) * 10;
                               break;
            case eMillimetres: points = (fixedVal * 7200) / 254;
                               break; 
            case eDidots     : points = ((((fixedVal*1238)/1157)*7200)/7227);
                               break;
            case eCiceros    : points =((((fixedVal*14856)/1157)*7200)/7227);
                               break;
         }
      }

      // normal cases where floating point isn't a problem
      switch (units)
      {
         case ePoints       : points = fixedVal * 10;
                              break;
         case eInches       :
         case eDecInches    : points = fixedVal * 720;
                              break;
         case ePicas        : points = fixedVal * 120;
                              break;
         case eCustom       : points = fixedVal * custPt * 10;
                              break;
      }
*/
      /* now divide the points back down to size & store away */
// 21/01/91      pts = (divider != 0 ? points / divider : points) + ToFixed(origin);
      pts = points + ToFixed(origin);
   }
   return(((succeeded == TRUE) ? kValidValue : kNonNumericCharacters));
}


// -------------------------------------------------------------------------
void CvtUnitsToStr(Fixed points, TScale units, int customPoints,
                   TConstraints constrain, VCoordinate origin,
                   char *aStr)
{
   int conValue = 0;
   int fraction = 1;
   int fracPart;
   Str255 tempStr;

   aStr[0] = 0;
   points -= ToFixed(origin);
   if (points > maxPtSize)
   {
      /* do some of the units in floating pt arithmetic */
      double floatnum = points;
      switch (units)
      {
      case eCentimetres:
           conValue = (int) ((floatnum * 847) / 24000);
           fraction = 100;   // 08/04/94 2 digits after dec pt
           break;
      case eMillimetres:
           conValue = (int) ((floatnum * 8470) / 24000);
           fraction = 10;
           break;
      case eDidots:
           conValue = (int) ((((floatnum * 1157) / 1238) * 7227) / 7200);
           break;
      case eCiceros:
           conValue = (int) ((((floatnum * 1157) / 14856) * 7227) / 7200);
           fraction = 12;
           break;
      }
   }
   else
   {
      /* shouldn't overflow so do as per normal */
      switch (units)
      {
      case eCentimetres:
         conValue = IntDivide(points * 847, 24000);
         fraction = 100;   // 08/04/94 2 digits after dec pt
         break;
      case eMillimetres:
         conValue = IntDivide(points * 847, 2400);
         fraction = 10;
         break;
      case eDidots:
         conValue = IntDivide(IntDivide(points * 1157, 1238) * 7227, 7200);
         break;
      case eCiceros:
         conValue = IntDivide(IntDivide(points * 14856, 1157) * 7200, 7227);
         fraction = 12;
         break;
      }
   }


   /* for the following cases large numbers can be done ok */
   switch (units)
   {
   case ePoints:
        conValue = points;
        fraction = 1;
        break;

   case ePoint16:
        conValue = points;
        fraction = 16;
        break;
           
   case ePoint10:
        conValue = points;
        fraction = 10;
        break;

   case eInches:
   case eDecInches:
        conValue = IntDivide(points, 72);
        fraction = 100;
        break;

   case ePicas:
        conValue = IntDivide(points, 12);
        fraction = 12;
        break;

   case eCustom:
        conValue = IntDivide(points, customPoints);
        fraction = 10;
        break;
   }


   if (constrain != eNoConstraint)
   {
      /* do the constraints stuff */
      Fixed constrainTo;
      Fixed rounder;
      TScalePars *scaleInfo = &gScalePars[units];

      fraction = (scaleInfo->minorDivs + 1) * (scaleInfo->midiDivs + 1);
      constrainTo = FixDiv(scaleInfo->factor, fraction) * 10 /* 21/01/91 */;

      switch (constrain)
      {
      case eConstrainToNearest:  rounder = kFix1 / 2; break;
      case eConstrainToNext:     rounder = kFix1 - 1; break;
      default:         // 26/04/90 was case eConstrainToPrevious:
                                 rounder = 0;
      }

      conValue = FixMul(constrainTo,
           ToFixed(FromFixed(FixDiv(conValue, constrainTo) + rounder)));
//      tempFixed = FixDiv(conValue, constrainTo) + rounder;
//      tempFixed -= (tempFixed % 100);
//      conValue = FixMul(constrainTo, tempFixed);
   }


/*
   if (units == eInteger)
   {
      // the number doesn't change at all
      wholenum = points;
      fract = 0;
   }
   else
*/

   conValue = IntDivide(conValue + 5, 10);
   if (FractPart(conValue) == 0)
      NumToString(FromFixed(conValue), aStr);   // the easy case
   else     
   {
      if (conValue < 0)
      {
        strcpy(aStr, "-");
        conValue = -conValue;
      }
      conValue = FixMul(conValue, ToFixed(fraction));  // 25/05/90 - temp: to see if rounding sorted out: prev. + 50;
      NumToString(FromFixed(conValue) / fraction, tempStr);
      strcat(aStr, tempStr);
      fracPart = FromFixed(conValue) % fraction;
      if (fracPart != 0)
      {
        if ((units == ePicas) || (units == eCiceros))
        {
          strcat(aStr, (units == eCiceros ? "c" : "p"));
          NumToString((fracPart * 12) / fraction, tempStr);
          strcat(aStr, tempStr);
        }
        else
        {
          int i;

          strcat(aStr, gDecPoint);
          strcat(aStr, "000");
          NumToString((fracPart * 1000) / fraction, tempStr);
          strcpy(aStr + strlen(aStr) - strlen(tempStr), tempStr);
          while ((i = strlen(aStr) - 1, aStr[i] == '0'))
            aStr[i] = 0;
        }
      }
   }
}


// -------------------------------------------------------------------------
_TCluster::_TCluster(TDocument itsDoc,TView itsSuperView, char* &itsParams)
                  : (itsDoc, itsSuperView, itsParams)
{
   // int  strOffset;
   int  labelIcon;
// 01/06/92 not used   char labelID[5];

   // sscanf(itsParams," %d %d %n", &fEsgNum, &labelIcon, &strOffset);
   // OffsetPtr(itsParams, strOffset);
   fEsgNum = ReadInt(itsParams);
   labelIcon = ReadInt(itsParams);

// 01/06/92 fLabelIdentifier not used - so use it to hold sprite number of label
//   fLabelIdentifier = StrToID(labelID);
#ifndef ZERO_OBJ
   fIndex = 0;
#endif
// 12/07/93 new guidelines no border on cluster label
// 12/07/93  if (labelIcon)
// 12/07/93    SetControlBorder(1, labelIcon);    // 01/06/92
}


// -------------------------------------------------------------------------
IDType _TCluster::ReportCurrent()
{
   wr_wimp_which_block blk;
   wr_wimp_i           ic[2];   // ic[0] = value,  ic[1] = terminator

   blk.window = fWMgrWindow;
   blk.bit_mask = 0x03f0000;
   blk.bit_set  = (fEsgNum + 0x020) << 16; // == our esg num to search for
   FailOSErr(wr_wimp_which_icon(&blk, ic));  // WARNING - you are not allowed
                                          // to have 2 items in a cluster
                                          // selected !!!
   fIndex = IDFromWimpIcon(ic[0]);

   return(fIndex);
}


/* -------------------------------------------------------------------------
void _TCluster::ResetRadios(TView aView, TView origView)
{
  if (aView != origView)
    TControl(aView)->HiliteState(FALSE, kRedraw);
}
*/

// -------------------------------------------------------------------------
bool _TCluster::HandleControlClick(EventInfo &info, TCommand &aCmd)
{
   // cluster may have to be enabled to stop subviews being dimmed,
   // but still want to pass on mouse click to subviews
   if (info.event->data.but.m.i == fIconNum)
     return FALSE;                         // stop it being recognised

   return _TView::HandleControlClick(info, aCmd);
}


// -------------------------------------------------------------------------
void _TCluster::DoChoice(TView origView, int itsChoice)
{
//  if ((itsChoice == mRadioHit) && (origView->fSuperView == this))
//    EachSubview(this, (DoToSubView)_TCluster::ResetRadios, origView);

  _TControl::DoChoice(origView, itsChoice);
}


// =========================================================================
_TNumberText::_TNumberText(TDocument itsDoc, TView itsSuperView,
                           char* &itsParams)
                         : (itsDoc, itsSuperView, itsParams)
{
   fMaximum = ReadInt(itsParams);
   fMinimum = ReadInt(itsParams);
}


// -------------------------------------------------------------------------
void _TNumberText::SetValue(int newNumber, bool redraw)
{
   Str255 temp;
   int oldNumber = fCurrentValue;

   _TControl::SetValue(newNumber, kDontRedraw);  // 31/03/93 from redraw: only redraw once!
   NumToString(fCurrentValue, temp);
   SetText(temp, redraw && fCurrentValue != oldNumber);
                           // 31/03/93 stop flicker at end of range when dragging
}


// -------------------------------------------------------------------------
int _TNumberText::GetValue()
{
   Str255 temp;
   int theValue;

   GetText(temp);
   StringToNum(temp, theValue);
   return(theValue);
}


// -------------------------------------------------------------------------
TValidationResults _TNumberText::Validate(bool resetLimits)
{
   // this needs to check the whole string. The wimps validation is used to
   // force the typed characters into DoKeyCommand, so cannot be used to
   // stop non-digit characters being supplied. As a bonus(?) this means
   // that signed values can be allowed. - 22/08/90

   Str255 temp;
   int typedInNumber = fCurrentValue;
   int dump;
   int fldCount;
   TValidationResults Validate_r = kValidValue;

   GetText(temp);
   fldCount = sscanf(temp, "%d%n", &typedInNumber, &dump);

   if (fldCount < 1)
   {
      dump = 0;
      if (temp[dump] == '-')
        dump = 1;
      else
        Validate_r = kEmptyValue;
   }

   for (; temp[dump] != 0; dump++)
      if (temp[dump] > 32)
         Validate_r = kNonNumericCharacters;

   if (Validate_r != kValidValue)
      return Validate_r;

   if (typedInNumber < fMinimum)
   {
      if (resetLimits)
         SetValue(fMinimum, kDontRedraw);
      Validate_r = kValueTooSmall;
   }
   else if (typedInNumber > fMaximum)
   {
      if (resetLimits)
         SetValue(fMaximum, kDontRedraw);
      Validate_r = kValueTooLarge;
   }
   else
     resetLimits = FALSE;

   // 18/11/92 do not DoChoice with out of range values
   if ((typedInNumber != fCurrentValue && Validate_r == kValidValue) || resetLimits)
     DoChoice(this, fDefChoice);
   fCurrentValue = typedInNumber;   // 25/06/91 ??? for #cols set back to 1
   return Validate_r;
}


// =========================================================================
_TUpDown::_TUpDown(TDocument itsDoc, TView itsSuperView, char* &itsParams)
                : (itsDoc, itsSuperView, itsParams)
{
   fUpArrow = ReadInt(itsParams);
   fDownArrow = ReadInt(itsParams);
   SetControlBorder(10, fUpArrow);    // 01/06/92
   SetControlBorder(10, fDownArrow);    // 01/06/92
}


// -------------------------------------------------------------------------
void _TUpDown::ViewShown(bool state) // 04/06/90 - new method to show/hide updown icons
{
  ShowIcon(fUpArrow, state);
  ShowIcon(fDownArrow, state);

  _TView::ViewShown(state);  // do not call TControl.Show
}


// -------------------------------------------------------------------------
bool _TUpDown::HandleControlClick(EventInfo &info, TCommand &aCmd)
{
   if (info.event->data.but.m.i == fUpArrow ||
                         info.event->data.but.m.i == fDownArrow)
   {
      // clicked on an arrow so see if adjust was pressed & invert direction
      // if it was (eg ADJ on down == up etc...)

      // 31/03/93 All calling DoChoice on self seems to do is cause main icon to flicker
      // 31/03/93 so now call SuperView DoChoice with the appropriate arrow click message
      // 21/04/93 ... except when this is a scrollbar: fSuperView->
      DoChoice(this, (info.event->data.but.m.i == fUpArrow) ==
                       info.rightButton ? mDownArrowHit : mUpArrowHit);
      // aCmd = gNoChanges;
      return TRUE;
   }
   return _TControl::HandleControlClick(info, aCmd);
}


// -------------------------------------------------------------------------
bool _TUpDown::DoHelp(IDType msgID, EventInfo &info, VPoint &theMouse)
{
  if (info.event->data.msg.data.helprequest.m.i == fDownArrow)
    msgID = (msgID & 0xffffff00) | 'D';

  return _TControl::DoHelp(msgID, info, theMouse);
}


// -------------------------------------------------------------------------
void _TUpDown::SetIconFlags(wr_wimp_iconflags value, wr_wimp_iconflags mask)
{
  wr_wimpt_noerr(wr_wimp_set_icon_state(fWMgrWindow, fUpArrow, value, mask));
  wr_wimpt_noerr(wr_wimp_set_icon_state(fWMgrWindow, fDownArrow, value, mask));
  _TControl::SetIconFlags(value, mask);
}

// =========================================================================
// NB. For TScrollingList, the icon nums must be in SEQUENTIAL order
// eg 5,6,7,8,9 (firsticon = 5, lasticon = 9)

_TScrollingList::_TScrollingList(TDocument itsDocument,
                                 TView itsSuperView,
                                 char* &itsParams)
                               : (itsDocument, itsSuperView, itsParams)
{
   int  strOffset;

#ifndef ZERO_OBJ
   fMaximum = 0;  // by default, make the limits of the control be 0-list size.
   fArrayOfItems = NULL;
   fItemInTopIcon = 0;   // so that the initial scrolllistto will happen
#endif
   if (sscanf(itsParams," %d %d %n", &fFirstIcon, &fLastIcon, &strOffset) == 2)
   {
     // fFirstIcon, fLastIcon are only used for the colour block
     fMaximum = fLastIcon - fFirstIcon;
     OffsetPtr(itsParams, strOffset);
   }
   else
   {
     fLastIcon = fIconNum;     // 02/09/93 the de facto state for remaining cases
     fFirstIcon = fIconNum;    // 02/09/93
   }
   fVisibleSize = fMaximum + 1;
   // 30/03/93 [20815] leave 0 until has array: fMinimum = 1;
}


// -------------------------------------------------------------------------
void _TScrollingList::Free()
{
  FreeIfObject(fArrayOfItems);
  _TControl::Free();
}


// -------------------------------------------------------------------------
void _TScrollingList::ViewShown(bool state) // 04/06/90 - to show/hide lists
{
#ifdef NEVER
  // 02/09/93 only ever 1 entry now (except colour block)
  int n = fFirstIcon;
  int newNumber;

  if (n == fIconNum)  // for a 1 item list, we normally have ficonnum,
                      // ffirsticon,flasticon all the same, so do nothing
    n++;              // here (the loop will exit immediately) - 05/06/90

  for (; n <= fLastIcon; n++)
  {
    newNumber = n;
    ShowIcon(newNumber, state);
  }
#endif
  _TControl::ViewShown(state);
}


// -------------------------------------------------------------------------
//static void InformScrollBar(TObject null, TView theSubview)
//{
//  theSubview->DoChoice(theSubview, mScrollingListChanged);
//}


// -------------------------------------------------------------------------
void _TScrollingList::HaveArray(TArray array, int selectedItem)
{
   int currentTop = (fItemInTopIcon == 0 ? selectedItem : fItemInTopIcon);
                                       // 13/01/91 was = fItemInTopIcon

  
   ReplaceObject(fArrayOfItems, array);
   // if (fArrayOfItems != array)
   //   FreeIfObject(fArrayOfItems);
   // fArrayOfItems = array;
   fMaximum = GetSize();
   fMinimum = 1;        // 09/04/93 [20815]
   fItemInTopIcon = 0;  // seems to be the way of getting the list redrawn!
   SetValue(selectedItem, kDontRedraw);
   ScrollListTo(currentTop, kRedraw);
//   if (CountSubViews() != 0)
//     EachSubview(NULL, (DoToSubView)InformScrollBar);
}

// -------------------------------------------------------------------------
void _TScrollingList::SetValue(int newValue, bool redraw)
{
  int newMax = GetSize();   // in case its size has changed

  if (newMax != 0)      // 30/03/93 [20815]
  {
    fMaximum = newMax;
    // there is only 1 visible item so scroll it around the list ends
    if (newValue > fMaximum)
      newValue = fMinimum;
    else if (newValue < fMinimum)
      newValue = fMaximum;
  }

  _TControl::SetValue(newValue, redraw);
}

// -------------------------------------------------------------------------
void _TScrollingList::SelectItem(int anItem, bool extendSelection, bool highlight, bool select)
{
   SetValue(anItem, kRedraw);
}

// -------------------------------------------------------------------------
int _TScrollingList::GetCurrentItem()
{
   return GetValue();
}

// -------------------------------------------------------------------------
int _TScrollingList::GetSize()
{
   return (fArrayOfItems == NULL ? 0 : fArrayOfItems->GetSize());
}

// -------------------------------------------------------------------------
void _TScrollingList::GetItemText(int arrayIndex, char *buffer)
{
   if ((fArrayOfItems != NULL) && (arrayIndex <= fArrayOfItems->GetSize()))
      fArrayOfItems->Get(arrayIndex, buffer);
   else
     buffer[0] = 0;
}

// -------------------------------------------------------------------------
bool _TScrollingList::HandleControlClick(EventInfo &info, TCommand &aCmd)
{
   if (info.event->data.but.m.i >= fFirstIcon && info.event->data.but.m.i <= fLastIcon)
   {
      SelectItem(fItemInTopIcon + (info.event->data.but.m.i - fFirstIcon),
                                                               FALSE, TRUE, TRUE);
      DoChoice(this, info.rightButton ? mScrollingListAdjust : mScrollingListHit);
      // aCmd = gNoChanges;
      return TRUE;
   }
   return _TControl::HandleControlClick(info, aCmd);
}

// -------------------------------------------------------------------------
void _TScrollingList::DoChoice(TView origView, int message)
{
   int incr = 1;
   int newSize = GetSize();

   if (newSize != 0)   
      fMaximum = newSize;   // in case its size has changed

//?? 02/09/93  _TControl::DoChoice(origView, message);

   switch (message)
   {
   case mScrollingListAdjust:
      incr = -1;
   case mScrollingListHit:
      if (fVisibleSize == 1)
      {
        SetValue(GetValue() + incr, kDontRedraw);
        // a 1-entry scrolling list simulates a pop up on the Mac
        // 02/09/93 mPopupHit must be a TPopup ??? _TControl::DoChoice(this, mPopupHit);
        fItemInTopIcon = 0; // forces a redraw of the list
        ScrollListTo(GetValue(), kRedraw);
      }
      break;
   case mUpArrowHit   :
   case mDownArrowHit :
#ifdef NEVER
   case mScrollerDrag :
   case mScrollPgUp   :
   case mScrollPgDown :
   case mScrollBarChanged:
#endif
      ScrollListTo(TControl(origView)->GetValue(), kRedraw);
      break;
//?? 02/09/93   default: _TControl::DoChoice(origView, message);
   }
   _TControl::DoChoice(origView, message);   //?? 02/09/93
}

// -------------------------------------------------------------------------
void _TScrollingList::ScrollListTo(int newTopPosition, bool redraw)
{
   // the newTopPosition value should be already validated as it will have
   // been through the SetValue() routine in TScroller::DoChoice()

   wr_wimp_icon ic;
   wr_wimp_icon iconInfo;
   // int theIcon;

   if (newTopPosition != fItemInTopIcon)
   {
      // the list has scrolled so rebuild it (deselecting the current
      // hilited item if necessary

      if (newTopPosition > GetSize() - fVisibleSize)
        newTopPosition = GetSize() - fVisibleSize + 1;
      if (newTopPosition < 1)
        newTopPosition = 1;

      fItemInTopIcon = newTopPosition;  // inform scroll bar?

      // 02/09/93 for (int i = fFirstIcon; i <= fLastIcon; i++)
      {
         // set the text for each of the icons in turn
         char ptrToText[255];
         // 02/09/93 int iconSave = fIconNum;

         // deselect the icon in case it was hilited
         wr_wimpt_noerr(wr_wimp_set_icon_state(fWMgrWindow, fIconNum /* i */, 0, wr_wimp_ISELECTED));

         if (fArrayOfItems != NULL)
         {
            GetItemText(fItemInTopIcon /* 02/09/93 + i - fFirstIcon */, ptrToText);

            // 02/09/93 fIconNum = i;
            wr_wimpt_noerr(wr_wimp_get_icon_info(fWMgrWindow, fIconNum /* i */, &iconInfo));
            
            wr_wimpt_noerr(wr_wimp_set_icon_state(fWMgrWindow, fIconNum /* i */,
              (ptrToText[0] == 0 && (iconInfo.flags & 0x0000f000 /* button type */) != 0) * wr_wimp_INOSELECT, wr_wimp_INOSELECT));
//            DimState((ptrToText[0] == 0), kDontRedraw);
            SetText(ptrToText, redraw);
            // 02/09/93 fIconNum = iconSave;
         }
      }

      // make sure the fCurrentValue field does not point to a dimmed out
      // icon. If it does, point it to the 1st icon
// 02/09/93 probably all unnecessary now
//    theIcon = Max(fFirstIcon, Min(fCurrentValue - fItemInTopIcon + fFirstIcon, fLastIcon));
      wr_wimpt_noerr(wr_wimp_get_icon_info(fWMgrWindow, fIconNum /* theIcon */, &ic));
      if (ic.flags & wr_wimp_INOSELECT)
        fCurrentValue = 1;

      // make sure the scrolling list itself is not dimmed
      DimState(FALSE, kDontRedraw);
   }
}


// =========================================================================
_TFixedPtText::_TFixedPtText(TDocument itsDoc,TView itsSuperV,char* &params)
                            : (itsDoc, itsSuperV, params)
{
   fScale = ePoints;
   fCustomPoints = 12000;
#ifndef ZERO_OBJ
   fCheckLimits = FALSE;
   fPointsSet = FALSE;
   fOrigin = 0;
#endif
   fDefChoice = mFixedPtTextHit;
}


// -------------------------------------------------------------------------
int _TFixedPtText::IncrementValue(int message)
{
  int theValue;
  TValidationResults valValue;

  valValue = Validate(TRUE);
  if (valValue == kValidValue)
  {
#ifdef TRACE
    int change = (fScale == ePoint16 ? 625 : kFix1 * 10);
#else
    int change = kFix1 * 10;
#endif

    if (message == mFixedPtTextHitDown)
      change = -change;

    theValue = Max(fMinimum, Min(GetPoints() + change, fMaximum));
    SetPoints(theValue, kRedraw);
    return message;
  }
  TDialogView(GetDialogView())->CantDeselect(this, valValue);
  return 0;
}


// -------------------------------------------------------------------------
void _TFixedPtText::DoChoice(TView origView, int message)
{
  if (message == mUpArrowHit || message == mDownArrowHit)
  {  
        //message == mFixedPtTextHitDown ?
        //                                           mDownArrowHit : mFixedPtTextHitUp);
    message =
        IncrementValue(message == mDownArrowHit ? mFixedPtTextHitDown : mFixedPtTextHitUp);
    if (message == 0)
      return;
    origView = this;    // 19/01/94 change view for mFixedPtTextHitDown/Up
  }
  _TControl::DoChoice(origView, message);
}


// -------------------------------------------------------------------------
void _TFixedPtText::GetString(char *itsString)
{
   if (fPointsSet)
      CvtUnitsToStr(fCurrentValue, fScale, fCustomPoints, eNoConstraint,
                                                    fOrigin, itsString);
   else
      strcpy(itsString,"");
}


// -------------------------------------------------------------------------
void _TFixedPtText::SetOrigin(VCoordinate newOrigin)
{
   fOrigin = newOrigin;
}


// -------------------------------------------------------------------------
TValidationResults _TFixedPtText::Validate(bool resetLimits)
{
   Fixed             fixedVal;
   Str255            aStr;
   Str255            testStr;
   TValidationResults result = kValidValue;
   // 21/08/90 these 2 variables added so DoChoice done on reset to Max/Min
   Fixed             resetValue;
   bool              doResetValue = FALSE;

   GetString(testStr);
   GetText(aStr);
   if (strcmp(aStr, testStr) != 0)
   {
      if (aStr[0] == 0)
         result = kEmptyValue;
      else
      {
         result = CvtStrToPoints(aStr, fScale, fCustomPoints, fOrigin, fixedVal);
         if (result == kValidValue)
         {
            resetValue = fMaximum;
            if (fCheckLimits && fixedVal > fMaximum)
            {
               doResetValue = resetLimits;
               result = kValueTooLarge;
            }
            else if (fCheckLimits && fixedVal < fMinimum)
            {
               doResetValue = resetLimits;
               resetValue = fMinimum;
               result = kValueTooSmall;
            }
            else
            {
               fCurrentValue = fixedVal;
               fPointsSet = TRUE;
               result = ValValue();
            }
            // 07/01/91 block moved inside condition so DoChoice only done if change
            if (doResetValue)
            {
               fCurrentValue = -1;
               SetPoints(resetValue, kRedraw);
            }
         }
      }
      if (result == kValidValue || doResetValue)
         DoChoice(this, fDefChoice);
   }
   else if (aStr[0] == 0)
   {
      fPointsSet = FALSE;
      result = kEmptyValue;
   }
   return(result);
}


// -------------------------------------------------------------------------
void _TFixedPtText::ForceRevalidation()
{
   fPointsSet = FALSE;
}


// -------------------------------------------------------------------------
TValidationResults _TFixedPtText::ValValue()
{
   return kValidValue;
}


// -------------------------------------------------------------------------
void _TFixedPtText::SetScale(TScale scale, int customPoints, int redraw)
{
   Str255 aStr;

   if ((scale != fScale) || (customPoints != fCustomPoints))
   {
      GetText(aStr);
      if (aStr[0] == 0)
         fPointsSet = FALSE;
      fScale = scale;
      fCustomPoints = customPoints;
      GetString(aStr);
      SetText(aStr, redraw);
   }
}


// -------------------------------------------------------------------------
void _TFixedPtText::SetLimits(Fixed maximum, Fixed minimum, bool doValidate)
{
   fCheckLimits = doValidate;
   fMaximum = maximum;
   fMinimum = minimum;
}


void _TFixedPtText::SetPoints(Fixed theValue, bool redraw)
{
  Str255 aStr;

  if ((theValue != fCurrentValue) || !fPointsSet)  // 25/05/90 - added || clause so SetPoints(0) will draw a 0
  {
    fPointsSet = TRUE;   // 25/05/90 - prev. before if... block
    fCurrentValue = theValue;
    GetString(aStr);
    SetText(aStr, redraw);
  }
  fPointsSet = TRUE;  // 25/05/90 - just to make sure the points set field is set
}

Fixed _TFixedPtText::GetPoints()
{
  return GetValue();
}


// =========================================================================
_TSmallIcon::_TSmallIcon(TDocument itsDoc, TView itsSuperV, char* &itsParams)
                      : (itsDoc, itsSuperV, itsParams)
{
   int termCh;

   fMenuCmd = ReadInt(itsParams);
   if ((termCh = *(itsParams++)) == ',')
                                 // 26/11/93 [21132] allow select,adjust commands in resources
   {
     fAdjustMenuCmd = ReadInt(itsParams);
#ifdef TABLES
     if ((termCh = *(itsParams++)) == ',')
                                 // 16/01/94 [21344] allow select,adjust,menu in resources
     {
       // Read in the menu number - if not supplied it is looked for in the menu tree
       // using the fMenuCmd command number
       fPopupMenu = ReadInt(itsParams);
#ifdef NETWP
       termCh = *(itsParams++);
#endif
     }
#endif
   }
   else
     fAdjustMenuCmd = fMenuCmd;
#ifdef NETWP
   if (termCh == '$')  // 24/06/96 pick up dimmed sprite name
   {
     char buff[16];

     *buff = 's';
     ReadString(itsParams, buff + 1);
     buff[4] = (IsTV() ? 'n' : 'v');
     fValidation = NewString(buff);
   }
#ifndef ZERO_OBJ
   else
     fValidation = NULL;
#endif
   fCurrentVal = fValidation;
#endif

   if (/*fMenuCmd != 0 && */ gEnabledControls != NULL)
   {
#ifndef NETWP
      bool enabled;
      bool menuThere = GetMenuState(fMenuCmd, enabled, enabled);

      if (menuThere)
#endif
        gEnabledControls->InsertLast(this); // only install in list if there
                                            // is a corresponding menu item
   }
}


// -------------------------------------------------------------------------
void _TSmallIcon::Free()
{
#ifdef NETWP
   DisposIfHandle(fValidation);
#endif
   if (/* fMenuCmd != 0 && */ gEnabledControls != NULL)
      gEnabledControls->Delete(this);

   _TControl::Free();
}


// ------------------------------------------------------------------------
void _TSmallIcon::Draw(Rect &area)
{
#ifndef NETWP
  // 09/02/96 [27019] Draw in button as background
  wr_wimp_icon ic;

  GetIconInfo(&ic);
  if ((ic.flags & wr_wimp_IBORDER) == 0)
  {
    char *spriteName = fDimmed ? "button_dim" : (fHilite ? "button_on" : "button_off");

    ic.flags = (ic.flags & (wr_wimp_IHALVESPRITE | wr_wimp_INOSELECT)) |
                                   (wr_wimp_ISPRITE | wr_wimp_IHCENTRE | wr_wimp_IVCENTRE);
    if (gWimpVersion >= 316)
      strcpy(ic.data.sprite_name, spriteName);
    else
    {
      ic.flags |= wr_wimp_INDIRECT;
      ic.data.indirectsprite.name = spriteName;
      ic.data.indirectsprite.spritearea = wr_resspr_area();
      ic.data.indirectsprite.nameisname = strlen(spriteName);
    }
    wr_wimp_ploticon(&ic);
  }
#endif
  _TControl::Draw(area);
}

#ifdef NETWP
// -------------------------------------------------------------------------
static void DimToggleIcon(wr_wimp_icreate *ic, char *newVal)
{
  ic->i.data.indirecttext.validstring = newVal;
}
#endif

// -------------------------------------------------------------------------
void _TSmallIcon::MakeDim(bool state)
{
#ifdef NETWP
  if (fValidation)
  {
    wr_wimp_icon ic;
    StringHandle oldVal = fCurrentVal;

    GetIconInfo(&ic);
    fCurrentVal = ic.data.indirecttext.validstring;
    ChangeDeletedIcon(fIconNum, (int)oldVal, (DoToIcon)DimToggleIcon);
  }
#else
  _TControl::MakeDim(state);
#endif
}


// -------------------------------------------------------------------------
void _TSmallIcon::RealHiliteState(bool state)
{
#ifdef NETWP
   _TControl::RealHiliteState(state);
#else
   // if (g3Dicons)
   {
     if (fHilite != state)
     {
       fHilite = state;
       SetControlBorder(state + 1, fIconNum);

       // 09/02/96 [27019] does not force call of Draw:   ProdIcon();
       ProdIt(TRUE);
     }
   }
   // else
   //   _TControl::RealHiliteState(state);
#endif
}


// -------------------------------------------------------------------------
void _TSmallIcon::ReflectMenuState(int menuChange)
{
   if (fWMgrWindow != kNoWindow)       // 28/06/93 for menu icons in closed windows
   {
      bool enabled;    // test result of GetMenuState: = FALSE;
      bool ticked;     // = FALSE;
      int oldDimmed = fDimmed;

#ifdef NETWP
      if (fIdentifier == I_('m', 'e', 'n', 'u'))
      {
        if (menuChange)
        {
          wr_wimp_mousestr result;

          wr_wimpt_noerr(wr_wimp_get_point_info(&result));

          // Leave Hilite unchanged (ie. On) if we are going to get a mouse press soon
          if (result.bbits == 0 || fWMgrWindow != result.w || fIconNum != result.i)
            HiliteState(FALSE, kRedraw);
        }
        return;
      }
#endif
      if (GetMenuState(fMenuCmd, enabled, ticked))  // there is a menu entry
      {
        DimState(!enabled, kDontRedraw);

        if (fMenuCmd == cUndoDescription)
        {
          TDocument doc = fSuperView->fDocument;

#ifdef NETWP
          if (enabled)
            ChangeDeletedIcon(fIconNum, (int)GetString(doc->fLastCommand != NULL &&
                          doc->fLastCommand->fCanUndo && !doc->fLastCommand->fCmdDone ? 92 : 93),
                          (DoToIcon)DimToggleIcon);
#else
          SetIconFlags(doc->fLastCommand != NULL && doc->fLastCommand->fCanUndo &&
                      !doc->fLastCommand->fCmdDone ? wr_wimp_ISELECTED : 0, wr_wimp_ISELECTED);
#endif
        }
        // 05/02/96 [27019] ?really could do with making RealDimState virtual?
        // force call of Draw if changed
        if (oldDimmed == enabled)
          ProdIt(TRUE);
      }
#ifdef NETWP
      else
        ticked = FALSE;
#endif
      HiliteState(ticked, kRedraw);
   }
}

// -------------------------------------------------------------------------
bool _TSmallIcon::DoHelp(IDType msgID, EventInfo &info, VPoint &theMouse)
{
  // 21/04/94 recoded: 15% shorter than using sprintf
  // Generate an id for Cnnn or Dnnn where nnn is the command number for the button
  // using the method of repeated subtraction: hundreds, tens then units
  int cmdno = fMenuCmd;
  int htu;                // current digit, first iteration it is 100, then 10, then 1

  // 11/03/93 [20809] give dimmed help for dimmed icons on icon bar ("Dnnn")
  msgID = fDimmed + 'C';
  for (char *i = "\x64\x0a\x01"; (htu = *(i++)) != 0; )
  {
    if (fMenuCmd >= htu)
      for (msgID = (msgID << 8) + '0'; cmdno >= htu; cmdno -= htu)
        msgID++;
  }
  if (fMenuCmd == cUndoDescription)
  {
    TDocument doc = fSuperView->fDocument;

    if (doc->fLastCommand != NULL && doc->fLastCommand->fCanUndo && !doc->fLastCommand->fCmdDone)
      msgID += I_(0, 'R' - 'C', 0, 0);
  }
  return _TControl::DoHelp(msgID, info, theMouse);

//  char buff[8];
//  sprintf(buff, fDimmed ? "D%d" : "C%d", fMenuCmd);
//  msgID += (fDimmed << (fMenuCmd >= 100 ? 24 : 16));  // change Cnn to Dnn
//  return _TControl::DoHelp(StrToID(buff), info, theMouse);
}

// -------------------------------------------------------------------------
TCommand _TSmallIcon::DoClick(EventInfo &info)
{
  // 26/11/93 [21132] allow adjust commands
  CmdNumber aCmdNumber = info.rightButton ? fAdjustMenuCmd : fMenuCmd;

  return /* GetWindow()->fTarget-> 17/01/94 DoMenuCommand now does this */
         DoMenuCommand(info, aCmdNumber);
}

#ifdef TABLES
// ------------------------------------------------------------------------
int _TSmallIcon::PopupAction(wr_wimp_eventstr *e)
{
  int popupMenu = fPopupMenu;

  if (e == NULL)   // initial call to return menu number
  {
    if (popupMenu == 0)
       popupMenu = GetSubmenu(fMenuCmd);
    if (popupMenu > 0)         // may be dynamic (maybe should check!)
       SetupDynamicMenu(fMenuCmd, popupMenu, TRUE);
       // strictly, wrong if fPopupMenu & fMenuCmd both supplied and the menu
       // is dynamic (as they are not then related in the menu tree),
       // but currently this is only true for the Font button but in this case
       // SetupDynamicMenu ignores the command number
  }
#ifdef NETWP
  else if (Focus())
  {
    // modify menu coordinates - avoids popping up above safe area
    wr_wimp_box box;
    Rect extent;

    GetExtent(extent);
    thePort->LocalToBox(extent, box);
    e->data.but.m.x = box.x0;
    // e->data.but.m.y = box.y0 - 4;   // open just below the button
    e->data.but.m.y = thePort->GetPortBox()->y0 - QDtoOS(GetHLineThickness());
                        // 05/09/96 [] move down a pixel to avoid overlaying status message
    if (fIdentifier == I_('m', 'e', 'n', 'u'))
      HiliteState(TRUE, kRedraw);
  }
#endif
  return popupMenu;
}
#endif

#ifdef NETWP
// -------------------------------------------------------------------------
bool _TSmallIcon::HandleControlClick(EventInfo &info, TCommand &aCmd)
{
  if (fDimmed)
    return FALSE;
  return _TControl::HandleControlClick(info, aCmd);
}
#endif

// ------------------------------------------------------------------------
_TSlider::_TSlider(TDocument itsDoc, TView itsSuperView, char* &itsParams) :
                             (itsDoc, itsSuperView, itsParams)
{
  fMaximum = 255;
}

// ------------------------------------------------------------------------
void _TSlider::SetValue(int newNumber, bool redraw)
{
   wr_wimp_icreate ic;
   wr_wimp_icon ic1;
   int icNum = fIconNum + 2;
   int oldEdge;

   _TControl::SetValue(newNumber, kDontRedraw);
   ic.w = fWMgrWindow;
   wr_wimpt_noerr(wr_wimp_get_icon_info(ic.w, fIconNum + 1, &ic1));
   wr_wimpt_noerr(wr_wimp_get_icon_info(ic.w, icNum, &ic.i));

   oldEdge = ic.i.box.x1;
   ic.i.box.x1 = ic.i.box.x0 + ((ic1.box.x1 - ic1.box.x0) * fCurrentValue) / fMaximum;
   if (oldEdge != ic.i.box.x1)
   {
      FailOSErr(wr_wimp_delete_icon(ic.w, icNum));
      if (fCurrentValue == 0)
         ic.i.flags &= ~wr_wimp_IFILLED;
      else
         ic.i.flags |= wr_wimp_IFILLED;
      FailOSErr(wr_wimp_create_icon(&ic, &icNum));

      if (redraw)
      {
         VRect extent;

         GetExtent(extent);
         InsetRect(extent, OStoQD(10), OStoQD(12));  // allow for border
         extent.left += OStoQD(Min(oldEdge, ic.i.box.x1) - ic.i.box.x0);
         extent.right = extent.left + OStoQD(abs(oldEdge - ic.i.box.x1));

         InvalidVRect(extent);
      }
   }
}

// ------------------------------------------------------------------------
TCommand _TSlider::TrackMouse(TrackPhase thePhase, VPoint &anchorPoint,
     VPoint &previous, VPoint &next, bool mouseDidMove, EventInfo &info)
{
   VRect extent;
   int currVal;

   GetExtent(extent);
   currVal = ((next.h - extent.left - OStoQD(10)) * fMaximum) /
                    (extent.right - extent.left - OStoQD(20)); // allow for border
   SetValue(currVal, mouseDidMove);

   if (mouseDidMove)
      DoChoice(this, mSliderHit);
   return gNoChanges;
}

// ------------------------------------------------------------------------
_TColourPatch::_TColourPatch(TDocument itsDoc,TView itsSuperView, char* &itsParams) :
                      (itsDoc, itsSuperView, itsParams)
{
}

// ------------------------------------------------------------------------
void _TColourPatch::SetColour(int colour, bool redraw)
{
   if (fColour != colour)
   {
     fColour = colour;
     if (redraw && Focus())
     {
       VRect myExtent;

       GetExtent(myExtent);
       InsetRect(myExtent, OStoQD(4), OStoQD(4)); // reduce over borders
       UpdateVRect(myExtent);
     }
   }
}

// ------------------------------------------------------------------------
void _TColourPatch::Draw(Rect &area)
{
   VRect myExtent;

   GetExtent(myExtent);
   InsetRect(myExtent, OStoQD(4), OStoQD(4)); // reduce over borders
   DrawFilledRect(myExtent, fColour, 0 /* GCol action */);
}

// =========================================================================
void _TSprite::ISprite(char* spriteName)
{
   wr_os_regset r;

   InitPlot(&r, spriteName, fSpriteSize);
   fSpriteID.s.addr = (char *)r.r[2];
   fInvertColour = r.r[6];
   Resize(fSpriteSize.h, fSpriteSize.v, FALSE);
}


// -------------------------------------------------------------------------
_TSprite::_TSprite(TDocument doc, TView supV, char* &pars)
                  : (doc, supV, pars)
{
   int    hPos;
   int    vPos;
   char   spriteName[14];

   ReadString(pars, spriteName);

   ISprite(spriteName);

   hPos = ReadInt(pars);
   vPos = ReadInt(pars);
   fIcon = ReadInt(pars);       // may not be there, so should be set to 1
   Locate(hPos, vPos, kDontRedraw);
}


// -------------------------------------------------------------------------
_TSprite::_TSprite(TView supV, VPoint &itsLoc, char* sprName)
                : (supV, itsLoc, gZeroVPt, sizeFixed)
             // : (NULL, supV, itsLoc, gZeroVPt, sizeFixed, sizeFixed)
{
   ISprite(sprName);
}


// -------------------------------------------------------------------------
void _TSprite::Plot(Point &destPt, int mode)
{
   sprite_factors sFactors;
   int change;
   sprite_pixtrans pixTrans[16];
   wr_os_regset r;

   // set up scale factors & pixel translation for current mode
   r.r[5] = mode;
   r.r[1] = (int)wr_resspr_area();
   r.r[2] = (int)fSpriteID.s.addr;
   r.r[6] = fInvertColour;

   if (!IsViewEnabled())
     change = 0x99999900;   // grey
   else if (fSelect)
     change = 0x0000dd00;  // red
   else
     change = 0;           // black

   SetPlot(&r, (int *)&sFactors, pixTrans, change);

   // the sizes of the sprite v. the rectangle may have changed so work out
   // what to do to the transformation matrix
   sFactors.xmag *= fSize.h;
   sFactors.xdiv *= fSpriteSize.h;
   sFactors.ymag *= fSize.v;
   sFactors.ydiv *= fSpriteSize.v;

   PlotIt(&r, destPt.h, destPt.v + fSize.v);
}


// -------------------------------------------------------------------------
void _TSprite::Draw(Rect &area)
{
#ifdef TABLES
   if (fIcon && gWimpVersion >= 316)
   {
     char *p;
     wr_wimp_icon ic;
     Rect extent;
     char buff[20];

     GetExtent(extent);
     thePort->LocalToWABox(extent, ic.box);
#ifdef NETWP
     ic.box.x0 = ic.box.x1 - QDtoOS(fSpriteSize.h) - 16;
     extent.right -= OStoQD(ic.box.x1 - ic.box.x0);
     PenPat(1);
     PaintRect(extent);
#endif
     ic.flags = wr_wimp_IBORDER | wr_wimp_ITEXT | wr_wimp_INDIRECT |
                wr_wimp_ISPRITE | wr_wimp_IHCENTRE | wr_wimp_IVCENTRE |
                (wr_wimp_IBACKCOL * 1) | wr_wimp_IFILLED;
     ic.data.indirecttext.buffer = p = (char *)memcpy(buff, "\x00R8;S", 6);
     ic.data.indirecttext.validstring = p + 1;
     p[2] = char(fIcon + '0');
     strcpy(p + 5, (char *)fSpriteID.s.addr + 4);   // concat sprite name
     ic.data.indirecttext.bufflen = 1;
     wr_wimp_ploticon(&ic);
   }
   else
#endif
     Plot(gZeroPt, plotOr);    // gcol 8 as standard ???
}


// -------------------------------------------------------------------------
void _TSprite::HiliteState(bool state)
{
   fSelect = state;
}

#ifdef NETWP
// 06/09/96 [27061] New control object to support anti-twittered text in dialogues
// -------------------------------------------------------------------------
_TTwitteredText::_TTwitteredText(TDocument itsDoc, TView itsSuperView, char* &itsParams) :
                                     (itsDoc, itsSuperView, itsParams)
{
#ifndef ZERO_OBJ
   fText = NULL;
#endif
}

// -------------------------------------------------------------------------
void _TTwitteredText::Free()
{
   DisposIfHandle(fText);
   _TControl::Free();
}

#define wimp_ReadSysInfo 0x400F2
#define wimp_TextOp      0x400f9
#define Font_ReadInfo    0x40084
// -------------------------------------------------------------------------
void _TTwitteredText::Draw(Rect &area)
{
   if (fText)
   {
      VRect extentRect;
      wr_wimp_box ic_box;
      wr_os_regset reg_set;
      int ic_gap;

      GetExtent(extentRect);
      thePort->LocalToBox(extentRect, ic_box);        // screen box of the icon
      ic_gap = ic_box.y1 - ic_box.y0;                 // vertical height available for centering

      reg_set.r[0] = 8;                               // get desktop font handle
      if (wr_os_swix(wimp_ReadSysInfo, &reg_set) == NULL && reg_set.r[0] != 0 &&
                                          wr_os_swix(Font_ReadInfo, &reg_set) == NULL)
        ic_gap -= (reg_set.r[4] + reg_set.r[2]);      // adjust for font ascent and descent
      else
        ic_gap -= 24;                                 // use fixed value when using System font

      wr_os_swi3(wimp_TextOp, 0, 0xffffff00, 0x8c520f00); // white text on blue-ish background
      wr_os_swi6(wimp_TextOp, 2, (int)fText, -1, -1, ic_box.x0, ic_box.y0 + ic_gap / 2);
   }
}

// -------------------------------------------------------------------------
void _TTwitteredText::SetText(char *theText, bool redraw)
{
   if (fText && strcmp(fText, theText) == 0)
      return;

   DisposIfHandle(fText);
   fText = NewString(theText);
   if (redraw)
   {
      if (redraw < 0)
         ProdIt(FALSE);   // it needs to be forced - cannot wait for event
      else
         ProdIcon();
   }
}

// -------------------------------------------------------------------------
void _TTwitteredText::GetText(char *theText)
{
  if (fText)
     strcpy(theText, fText);
  else
     *theText = 0;
}
#endif
