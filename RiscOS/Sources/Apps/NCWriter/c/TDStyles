/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <string.h>
#include <stdio.h>

#include "os.h"
#include "font.h"

#include "UTextDoc.h"

// numbers in resource file
#define kSpacingDlgID   16
#define kBordersDlgID   17
#define kTypeSpecDlgID  22 /* Font Selector Dialogue */
#define kPicSpacingDlgID 23

#define kBitFont           0
#define kBitSize           1
#define kBitFace           2
#define kBitEmphasis       3
#define kBitCaps           4
#define kBitAlignment      5
#define kBitLeading        6
#define kBitSpaceBefore    7
#define kBitSpaceAfter     8
#define kBitRuler          9
#define kBitLeftMgn        10
#define kBitRightMgn       11
#define kBitIndent         12
#define kBitTabs           13
#define kBitCols           14
#define kBitColSep         15
#define kBitAdornment      16
#define kBitHyphenate      17
#define kBitLanguage       18
#define kBitColour         19
#define kBitOwnSpaceBefore 20
#define kBitOwnSpaceAfter  21
#define kBitOwnAdornment   22
#define kBitOwnAlignment   23
#define kBitHasSpaceBefore 24
#define kBitHasSpaceAfter  25
#define kBitHasAdornment   26
#define kBitHasAlignment   27
#define kBitAutoIndent     28
#define kBitBullet         29
#define kBitOwnMargins     30
#define kBitHasMargins     31

// ------------------------------------------------------------------------
int MergeFaces(int origFace, int newFace)
{
/* The face is made up of 2 bits (underline && strikeout)
        kNormal      0 (or 3 when forced to normal by the FontSelect dialogue)
        kUnderline   1
        kStrikeOut   2
   then 1 bit for bold
        kBold        4
   then 1 bit for italic
        kItalic      8
   then 2 bit for subscript and superscript which are mutually exclusive
        kSuperscript 16
        kSubscript   32
   then proposed 2 bits for kerning (but only one needed?)
        kKerning     64
        kKerningDefined 128 (in the style - NEVER returned from MergeFaces)
*/
  int oldstate = origFace & 3;
  int newstate = newFace & 3;
  int oldsuper;
  int newsuper;

  if (oldstate == newstate || newstate == 3)
    newstate = 0;
  else if (newstate == 0)
    newstate = oldstate;

  oldsuper = origFace & (kSuperscript | kSubscript);
  newsuper = newFace & (kSuperscript | kSubscript);
  if (oldsuper == newsuper)
    newsuper = 0;
  else if (newsuper == 0)
    newsuper = oldsuper;

  return ((origFace ^ newFace) & (kBold | kItalic | kKerning)) | newsuper | newstate;
}

#if defined TABLES || defined WORD7
// ------------------------------------------------------------------------
CmdNumber DoCaseChange(TStyleFormat theStyle, int newCase)
{
  theStyle->fDefined |= (kCaps | kEmphasis);  // 04/07/91 | KEmph
  theStyle->fTextCaps = newCase;
  return cCaseChange;
}
#endif

// ------------------------------------------------------------------------
CmdNumber DoSizeChange(TStyleFormat theStyle, int newSize)
{
  theStyle->fDefined |= (kSize | kEmphasis);  // 04/07/91 | KEmph
  theStyle->fTextSizeX = newSize;
  theStyle->fTextSizeY = newSize;
  return cSizeChange;
}

#if defined TABLES || defined WORD7
// ------------------------------------------------------------------------
CmdNumber DoLanguageChange(TStyleFormat theStyle, int language)
{
  theStyle->fDefined |= (kLanguage | kEmphasis);  // 04/07/91 | KEmph
  theStyle->fLanguage = language;
  return cLanguageChange;
}
#endif

// ------------------------------------------------------------------------
CmdNumber DoFontChange(TStyleFormat theStyle, int fontNum)
{
  theStyle->fDefined |= (kFont | kEmphasis);
  theStyle->fTextFont = fontNum;
  return cFontChange;
}

// ------------------------------------------------------------------------
CmdNumber RemoveEmphasis(TStyleFormat theStyle, int ignored)
{
  theStyle->fDefined = (kFace | kEmphasis);
                        // 22/02/93 [20709] from |=; New emphasis un-Plains paragraph
  theStyle->fTextFace = 0;
  return cPlain;
}

// 17/06/93 [20947] do underline in EW and TW
// ------------------------------------------------------------------------
CmdNumber DoUnderline(TStyleFormat theStyle, int newUFace)
{
  theStyle->fDefined |= (kFace | kEmphasis);
  theStyle->fTextFace ^= newUFace;

  // clear strikeOut whatever state underline is in (or vice versa)
  theStyle->fTextFace &= (newUFace - 4);   // gives ...1101 for newUFace == kUnderline (1)
                                           // and   ...1110 for newUFace == kStrikeOut (2)
                        // 04/04/93 [20824] avoid clearing bold/italic, etc
  return cUnderline;
}

// ------------------------------------------------------------------------
CmdNumber DoLineSpacing(TStyleFormat theStyle, int leading)
{
  theStyle->fDefined |= kLeading;
  theStyle->fLeading = leading;
  return cSpacing;
}

#if defined TABLES || defined WORD7
// ------------------------------------------------------------------------
CmdNumber DoKernChange(TStyleFormat theStyle, int cmdNo)
{
  theStyle->fDefined |= (kFace | kEmphasis);
  theStyle->fTextFace ^= kKerning;
  return cmdNo;
}
#endif

#if defined TABLES || defined WORD7
// ------------------------------------------------------------------------
CmdNumber DoHyphenate(TStyleFormat theStyle, int ignored)
{
  theStyle->fDefined |= kHyphenate;
  theStyle->fHyphenate = !theStyle->fHyphenate;
  return cHyphenation;
}
#endif

// ------------------------------------------------------------------------
CmdNumber DoColourChange(TStyleFormat theStyle, int colour)
{
  theStyle->fDefined |= (kColour | kEmphasis);  // 04/07/91 | KEmph
  theStyle->fColour = colour;
  return cColourChange;
}

// ------------------------------------------------------------------------
CmdNumber DoFaceChange(TStyleFormat theStyle, int faceIdx)
{
  theStyle->fDefined |= (kFace | kEmphasis);
#if defined TABLES || defined WORD7
  // prevent subscript and superscript
  if (faceIdx >= 2)
    theStyle->fTextFace &= ~(1 << (7 - faceIdx)); // clear sub if super & vice versa
#endif
  theStyle->fTextFace ^= (kBold << faceIdx);
  return faceIdx < 2 ? (faceIdx * 4) + cBold : faceIdx - 2 + cSuperscript;
}

// ------------------------------------------------------------------------
void DoBordersChange(TStyleFormat self, // not needed!: TStyleFormat fStyleFormat,
                         TRuleType ruleType, CntlAdornment adornment)
{
  CntlAdornment *myAdornment;

  if ((self->fDefined & kHasAdornment) != 0)
        // || (fStyleFormat != NULL && (fStyleFormat->fDefined & kHasAdornment) != 0))
  {
#ifdef TRACE
//  if (fStyleFormat)
//    Assert((fStyleFormat->fDefined & kHasAdornment) != 0, 629); // test above can be simplified
#endif
    self->fDefined |= (kOwnAdornment /* | kHasAdornment */);
    self->fOwnRuleType = ruleType;
    myAdornment = &self->fOwnAdornment;
  }
  else
  {
    self->fDefined |= kAdornment;
    self->fRuleType = ruleType;
    myAdornment = &self->fAdornment;
  }
  if ((adnShadow & adornment) != 0)
    adornment |= (adnLineTop | adnLineLeft | adnLineBottom | adnLineRight);
  *myAdornment = adornment;
}

// ------------------------------------------------------------------------
void DoColumnsChange(TStyleFormat self, Fixed firstColumn, Fixed firstGap)
{
  TFTabInfo tab;

  self->fDefined |= kRuler;
  ITabInfo(tab);
  tab.fMark = ' ';
  tab.fStop = firstColumn * 250;  // half twips to fixed deciPts
  tab.fKind = kRightCol;
  self->InsertFirst(&tab);
  tab.fStop += firstGap * 250;
  tab.fKind = kLeftCol;
  self->InsertLast(&tab);
}

// ------------------------------------------------------------------------
_TStyleStructure::_TStyleStructure(TTextDocument itsDocument,
                  TStyleTypes itsType) : (itsDocument, sizeof(TPartStyles))
{
#ifndef ZERO_OBJ
  fStylename[0] = 0;
  fUsed = FALSE;
#endif
  fType = itsType;
}


// ------------------------------------------------------------------------
void _TStyleStructure::IStyleStructure(TStyleTypes itsType, char *itsName)
{
  fType = itsType;
  fParent = fStyle = gNullCurrency;     // arent these initialised to null currencies??
  _TStyleStructure::SetName(itsName);
}


// ------------------------------------------------------------------------
void _TStyleStructure::SetName(char *name)
{
  strcpyn(fStylename, name, defNameLen);
}


// ------------------------------------------------------------------------
int _TStyleStructure::ComputeIndex(int part, Rect &custom)
{
  return(part - 1);
}


// ------------------------------------------------------------------------
void _TStyleStructure::ForAllPartsDo(TObject obj, DoToStyles procToDo,
         TStyleStructure styleStruct, TMainView theView, int *idx)
{
  for (int index = 1; index <= fSize; index++)
  {
    TCurrency styleCurr = PPartStyles(At(index))->fStyle;

    if (styleCurr != 0)
      procToDo(obj, index + 1, gZeroRect, styleCurr, styleStruct, theView, idx);
  }
}

// ------------------------------------------------------------------------
void _TStyleStructure::GetPartStyles(int part, Rect& custom, TPartStyles &partStyles)
{
  int index = ComputeIndex(part, custom);

  if (index > GetSize())
  { 
    partStyles.fStyle = 0;
  }
  else
    Get(index, &partStyles);
}


// ------------------------------------------------------------------------
long _TStyleStructure::DoNeedDiskSpace(long dataForkBytes)
{
  return _TCommonStructure::DoNeedDiskSpace(dataForkBytes + 2 + int(strlen(fStylename)) -
              int(sizeof(_TStyleStructure)) + int(sizeof(_TCommonStructure)));
}

typedef struct TOldStyleStruct {
  DefName fStylename;
  TStyleTypes fType;
} TOldStyleStruct;

// ------------------------------------------------------------------------
void _TStyleStructure::DoRead(int aRefNum, long remainder, int version)
{
  char buffer[2 + sizeof(DefName)];

  _TCommonStructure::DoRead(aRefNum, sizeof(_TCommonStructure), version);  // the inherited read
#ifdef VERS0
  if (version == 0)
    FRead(aRefNum, sizeof(TOldStyleStruct), fStylename);            // old fmt
  else
#endif
  {
    int nameLen;

    FRead(aRefNum, 2, buffer);           // new fmt; name length & type
    nameLen = buffer[0];
    fType = buffer[1];
    FRead(aRefNum, nameLen, fStylename);
    fStylename[nameLen] = 0;
  }
  FRead(aRefNum, remainder - sizeof(_TStyleStructure), this + 1);
                                                     // any following stuff
#ifdef TRACE
  if (fChanges)
    SysBeep(0);    // 01/06/95 should always be zero???
#endif
}

// ------------------------------------------------------------------------
void _TStyleStructure::DoWrite(int aRefNum, long remainder)
{
  char buffer[2 + sizeof(DefName)];
  int nameLen;

  fStyle = 0;      // 11/03/91 sort out old docs
#ifdef TRACE
  if (fChanges)
    SysBeep(0);    // 01/06/95 should always be zero???
#endif
  fChanges = 0;    // 01/06/95 sort out corrupt docs
#ifdef TRACE
#endif
  _TCommonStructure::DoWrite(aRefNum, sizeof(_TCommonStructure)); // write stuff below

  buffer[0] = nameLen = strlen(fStylename);
  buffer[1] = fType;
  strcpy(buffer + 2, fStylename);
  FWrite(aRefNum, 2 + nameLen, buffer);              // write own stuff
  FWrite(aRefNum, remainder - sizeof(_TStyleStructure), this + 1);
                                          // write following stuff (if any)
}

// ------------------------------------------------------------------------
void _TStyleStructure::PutPartStyles(int part, Rect &custom, TPartStyles &partStyles)
{
  int index = ComputeIndex(part, custom);
  if (index > GetSize())
    InsertLast(&partStyles);
  else
    AtPut(index, &partStyles);
}


// ------------------------------------------------------------------------
_TStyleFormat::_TStyleFormat() : (Fixed(-1), Fixed(-1), Fixed(-1))
{
  fTimeStamp = UniqueNumber();
#ifndef ZERO_OBJ
  fSpaceBefore = 0;
  fSpaceAfter = 0;
  fLeading = 0;
  fAlignment = kAlignLeft;
  fTextFont = 0;
  fTextSizeX = 0;  // ??? prev fTextSize
  fTextSizeY = 0;  // ??? prev fTextSize
  fColour = 0;     // black foreground colour by default
  fFontName[0] = 0;
  fTextFace = 0;
  fOldFace = 0;
  fTextCaps = kMixedCase;
  fAdornment = 0;
  fFixedHeight = FALSE;
  fHyphenate = FALSE;
  fAutoIndent = FALSE; // 28/05/90
  fBullet = 0;         // 28/05/90
  fAutoBullet = 0;     // [20981]
  fOwnSpaceBefore = 0;
  fOwnSpaceAfter = 0;
  fOwnAlignment = kAlignLeft;
  fOwnAdornment = 0;
  fBulletFont = 0;
  fBulletFontName[0] = 0;
#endif
  fLanguage = GetDefaultCountry() & 0x7f;  // read the current country number

  fOwnRuleType = gDefaultPen;
  fRuleType = fOwnRuleType;
  fSpaceAfter = 20;     // 17/06/92 set default for non-math styles
  SetGutterWidth(-1);
}


// ------------------------------------------------------------------------
void _TStyleFormat::IRes(char* &params)
{
  int strOffset;

  fTimeStamp = 0;
  fAdornment = 0;
  fOwnAdornment = 0;
  fOwnRuleType = gDefaultPen;
  fRuleType = fOwnRuleType;
  fFixedHeight = 0;
  fOldFace = 0;
  fHyphenate = 0;

  fDefined = ReadHex(params);
  // 22/04/94 read 7 fixeds fLeftMargin to fGutterWidth
  for (Fixed *i = &fLeftMargin; i <= &fGutterWidth; i++)
    *i = ReadFixed(params);

  sscanf(params, " %d %d %d %d %d %x %d %c %d %d %d %d %n",
     &fTotalColumns, &fSpaceBefore, &fSpaceAfter, &fTextFont, &fTextSizeX, &fTextFace,
     &fAlignment, &fBullet, &fBulletFont, &fOwnSpaceBefore, &fOwnSpaceAfter, &fOwnAlignment,
     &strOffset);

  OffsetPtr(params, strOffset);

#ifdef MATHS
  // 03/02/94
  if ((fDefined & (kLanguage | kEmphasis)) == (kLanguage | kEmphasis))
    fLanguage = 0;  // frig to recognise Greek and Symbol emphases as having no language
#endif
  //16/06/92 all resources have these values & common up font names
  fTextSizeY = fTextSizeX;
  fColour = 0;
  // 06/05/94 read in as resource again:  fTextFace = 0;
  fTextCaps = 0;
  fLeading = 0;
  fAutoIndent = 0;
  if (fBulletFont != 0)
  {
    fAutoBullet = 1;       // [20981] set auto tab on bullets for new styles
    strcpy(fBulletFontName, GetRsrc(fBulletFont, 'n'));
  }
  if (fTextFont != 0)
      strcpy(fFontName, GetRsrc(fTextFont, 'n'));
}

static char gStyleMap1[] =
 "\x04\x04\x04\x04\x04\x04\x04\x04\x01\x03\x04\x02\x02\x02\x26\x01\x03\x02\x02\x02\x02\x01\x03\x01\x03\x02\x02\x01\x03\x01\x03";

static char gStyleMap2[] =
 "\x04\x01\x07\x01\x03\x01\x03\x01\x03\x01\x03\x01\x27\x02\x02\x02\x02\x01\x03\x01\x03\x04\x04\x0c";

// ------------------------------------------------------------------------
static unsigned int ComputeRulerMask(TStyleFormat style)
{
  unsigned int defaultMask = 0;

  if (style->fLeftMargin >= 0)
    defaultMask |= 0x01;
  if (style->fRightMargin >= 0)
    defaultMask |= 0x02;
  if (style->fIndentation >= 0)
    defaultMask |= 0x04;
  if (style->fOwnLeftMargin >= 0)
    defaultMask |= 0x08;
  if (style->fOwnRightMargin >= 0)
    defaultMask |= 0x10;
  if (style->fOwnIndentation >= 0)
    defaultMask |= 0x20;
  if (style->fGutterWidth >= 0)
    defaultMask |= 0x040;
  if (style->fTotalColumns != 0)
    defaultMask |= 0x080;

  return defaultMask;
}

// ------------------------------------------------------------------------
static void ComputeStyleMasks(int defined,
                unsigned int *mask1, unsigned int *mask2)
{
  unsigned int defaultMask1 = 0x401; // fDefined and timeStamp
  unsigned int defaultMask2 = 0;

  if (defined & kFont)
    defaultMask1 |= 0x08000;
  if (defined & kSize)
    defaultMask1 |= 0x0a0000;
  if (defined & kFace)
    defaultMask1 |= 0x0200000;
  if (defined & kCaps)  
    defaultMask1 |= 0x0800000;
  if (defined & kAlignment)
    defaultMask1 |= 0x08000000;
  if (defined & kLeading)
  {
    defaultMask1 |= 0x02000000;
    defaultMask2 |= 0x02;
  }
  if (defined & kSpaceBefore)
    defaultMask1 |= 0x0800;
  if (defined & kSpaceAfter)
    defaultMask1 |= 0x02000;
  if (defined & kAdornment)
  {
    defaultMask1 |= 0x20000000;
    defaultMask2 |= 0x01;
  }
  if (defined & kHyphenate)
    defaultMask2 |= 0x08;
  if (defined & kLanguage)
    defaultMask2 |= 0x020;
  if (defined & kColour)
    defaultMask2 |= 0x0400000;
  if (defined & kOwnSpaceBefore)
    defaultMask2 |= 0x02000;
  if (defined & kOwnSpaceAfter)
    defaultMask2 |= 0x08000;
  if (defined & kOwnAdornment)
    defaultMask2 |= 0x0280000;
  if (defined & kOwnAlignment)
    defaultMask2 |= 0x020000;
  if (defined & kAutoIndent)
    defaultMask2 |= 0x080;
  if (defined & kBullet)
    defaultMask2 |= 0x0a00;

  *mask1 = defaultMask1;
  *mask2 = defaultMask2;
}


// ------------------------------------------------------------------------
long _TStyleFormat::DoNeedDiskSpace(long dataForkBytes)
{
  unsigned int flags1, flags2;
  unsigned int rulerMask = ComputeRulerMask(this);

  ComputeStyleMasks(fDefined, &flags1, &flags2);

  return _TRulerDef::DoNeedDiskSpace(dataForkBytes +
    SumRecord(flags1 | (rulerMask << 1), gStyleMap1) + SumRecord(flags2, gStyleMap2) +
    int(strlen(fFontName)) + int(strlen(fBulletFontName)) + 3 + fAutoBullet - // [20981]
         int(sizeof(_TStyleFormat)) + int(sizeof(_TArray)));
}

// ------------------------------------------------------------------------
void _TStyleFormat::DoRead(int aRefNum, long remainder, int version)
{
  char buffer[sizeof(_TStyleFormat)];
//  int defined;
  int partLen1;
  int partLen2;
  int fontNameLen;
  int bulletFontNameLen;
  unsigned int mask1;
  unsigned int mask2;
  unsigned int rulerMask;

#ifdef VERS0
  if (version == 0)
  {
    _TRulerDef::DoRead(aRefNum, remainder, version);   // the inherited read
    if (fTotalColumns < 0)
      fTotalColumns = 0;
    if (fGutterWidth == 0)
      fGutterWidth = -1;
  }
  else
#endif
  {
    _TArray::DoRead(aRefNum, sizeof(_TArray), version);
                                           // inherited - inherited read

    FRead(aRefNum, 7, buffer);      // flags and counts and defined
    memcpy(&fDefined, buffer + 3, 4);
    fontNameLen = buffer[1];
    bulletFontNameLen = buffer[2];
    rulerMask = buffer[0];
    ComputeStyleMasks(fDefined, &mask1, &mask2);
    mask1 = (mask1 | (rulerMask << 1)) & ~1;     // remove fdefined bit
    partLen1 = SumRecord(mask1, gStyleMap1);
    partLen2 = SumRecord(mask2, gStyleMap2);
    FRead(aRefNum, partLen1 + partLen2 + fontNameLen + bulletFontNameLen,
                                                       buffer);
    UnpackRecord(mask1, gStyleMap1, buffer, NULL,
                                               (char *)&fDefined);
    UnpackRecord(mask2, gStyleMap2, buffer + partLen1,
                                               NULL, (char *)&fRuleType);
    if (fontNameLen != 0)
      memcpy(fFontName, buffer + partLen1 + partLen2, fontNameLen);
    fFontName[fontNameLen] = 0;

    if (bulletFontNameLen != 0)
    {
      memcpy(fBulletFontName, buffer + partLen1 + partLen2 + fontNameLen,
                                                       bulletFontNameLen);
      // 15/07/93 [20981] identify styles saved with fAutoBullet
      if (fBulletFontName[bulletFontNameLen - 1] == ' ')
      {
        bulletFontNameLen--;
        fAutoBullet = TRUE;
      }
    }
    fBulletFontName[bulletFontNameLen] = 0;

    FRead(aRefNum, remainder - sizeof(_TStyleFormat), this + 1);
  }  
}


// ------------------------------------------------------------------------
void _TStyleFormat::DoWrite(int aRefNum, long remainder)
{
  unsigned int flags1;
  unsigned int flags2;
  char buffer[sizeof(_TStyleFormat)];
  int currPtr;
  int fontNameLen;
  int bulletFontNameLen;
  unsigned int rulerMask = ComputeRulerMask(this);

  _TArray::DoWrite(aRefNum, sizeof(_TArray));  // inherited - inherited write

  // temp for repairing styles
  if (fBulletFontName[0] == 0 && (fDefined & kBullet) != 0)
  {
    strcpy(fBulletFontName, TTextDocument(gSavingDoc)->GetFName(fBulletFont));
  }

  ComputeStyleMasks(fDefined, &flags1, &flags2);
  flags1 |= (rulerMask << 1);
  currPtr = PackRecord(flags1, gStyleMap1,
                    (char *)&fDefined, buffer + 3) + 3;
  currPtr += PackRecord(flags2, gStyleMap2,
                    (char *)&fRuleType, buffer + currPtr);
  buffer[0] = rulerMask;
  fontNameLen = buffer[1] = strlen(fFontName);
  if (fontNameLen != 0)
    memcpy(buffer + currPtr, fFontName, fontNameLen);
  currPtr += fontNameLen;
  bulletFontNameLen = strlen(fBulletFontName);
  if (bulletFontNameLen != 0)
  {
    memcpy(buffer + currPtr, fBulletFontName, bulletFontNameLen);
    // 15/07/93 [20981] identify styles saved with fAutoBullet by adding a space to font name
    if (fAutoBullet)
    {
      buffer[currPtr + bulletFontNameLen] = ' ';
      bulletFontNameLen++;
    }
  }
  buffer[2] = bulletFontNameLen;
  FWrite(aRefNum, currPtr + bulletFontNameLen, buffer);
  FWrite(aRefNum, remainder - sizeof(_TStyleFormat), this + 1);
}

// -------------------------------------------------------------------------
bool _TStyleFormat::IsStyleMember(int matchType)
{
  return (matchType & (TStyleFormatType | TRulerDefType)) != 0;
}


// -------------------------------------------------------------------------
int _TStyleFormat::NumOfAttrs(int ignore)
// 23/09/93 parameter to ignore ruler
{
  return (fDefined & ~(ignore | kHasSpaceBefore | kHasSpaceAfter | kHasAdornment |
                                      kHasAlignment | kHasMargins)) != 0;
}


// -------------------------------------------------------------------------
void _TStyleFormat::DeleteAttribute(TStyleFormat changes, int attrNum)
// 04/01/91 at the moment delete all the attributes
{
  changes->fDefined &= (kHasSpaceBefore | kHasSpaceAfter | kHasAdornment |
                                kHasAlignment | kHasMargins | kEmphasis);
  // 14/01/91 only knock out real defined bits 13/11/92 including kEmphasis
}


// ------------------------------------------------------------------------
void MeasureFont(Fixed &ascent, Fixed &descent, Fixed &leading)
{
  wr_font_info info;

                // 25/10/90 allow room for accents...
  FailOSErr(wr_font_stringbbox("EÊjç×¤y", &info));  // 08/10/92 y added for Primary font
  ascent = info.maxy * 10;
  descent = Max(0, -info.miny) * 10;
  leading = 0;
}


// ------------------------------------------------------------------------
void _TStyleFormat::SetLineSpacing(int itsLineSpace)
{
  fLeading = itsLineSpace;
}


// ------------------------------------------------------------------------
Fixed _TStyleFormat::GetWidth(int containerWidth)
{
  return(ToFixed(containerWidth) - GetLeftMargin() - GetRightMargin());
}


// ------------------------------------------------------------------------
void _TStyleFormat::SetItsCurrency(PFTabInfo tab, TCurrency itsCurrency, bool changeAll)
{
   if (changeAll || tab->fOwner == 0)
     tab->fOwner = itsCurrency;
}


// ------------------------------------------------------------------------
void _TStyleFormat::SetTabCurrency(TCurrency itsCurrency, bool changeAll)
{  
  Each(this, (DoToItem)_TStyleFormat::SetItsCurrency, itsCurrency, changeAll);
}


// ------------------------------------------------------------------------
void _TStyleFormat::Copy(TRulerDef newStyle)
{ // new 18/09/90

  _TRulerDef::Copy(newStyle);

  if (newStyle->IsStyleMember(TStyleFormatType))      // 01/04/92
    memcpy(((char *)newStyle) + sizeof(_TRulerDef),   // to newStyle
         ((char *)this) + sizeof(_TRulerDef),         // from self
         sizeof(_TStyleFormat) - sizeof(_TRulerDef));
}


// ------------------------------------------------------------------------
void _TStyleFormat::ApplyOverride(TRulerDef derivative, TCurrency currency, bool applyRuler)
{
  register int derivDef = derivative->fDefined;

  if (derivative->IsStyleMember(TStyleFormatType))
  {
    if (TStyleFormat(derivative)->fFontName[0] != 0)
      strcpy(fFontName, TStyleFormat(derivative)->fFontName);
    // 12/06/90 - get this applied by default, so that there is always a font name there

    if (derivDef & (kFont | kSize | kAutoIndent | kBullet))
    {
      if (derivDef & kFont)
      {
        fTextFont = TStyleFormat(derivative)->fTextFont;
        //    strcpy(fFontName, TStyleFormat(derivative)->fFontName);
      }
      if (derivDef & kSize)
      {
        fTextSizeX = TStyleFormat(derivative)->fTextSizeX;
        fTextSizeY = TStyleFormat(derivative)->fTextSizeY;
      }
      if (derivDef & kAutoIndent)
        fAutoIndent = TStyleFormat(derivative)->fAutoIndent;
      if (derivDef & kBullet)
      {
        fBullet = TStyleFormat(derivative)->fBullet;
        fAutoBullet = TStyleFormat(derivative)->fAutoBullet; // [20981]
        fBulletFont = TStyleFormat(derivative)->fBulletFont;
        strcpy(fBulletFontName, TStyleFormat(derivative)->fBulletFontName);  // 01/03/91
      }
    }

    if (derivDef & (kFace | kCaps | kAlignment | kLeading | kSpaceBefore | kSpaceAfter))
    {
      if (derivDef & kFace)
      {
        Style deriv = TStyleFormat(derivative)->fTextFace;

        fOldFace = fTextFace;
//      fTextFace = ((fDefined & kFace) != 0 && deriv == fTextFace ? 0 : deriv);  // 21/03/91
        fTextFace = ((fDefined & kFace) == 0 ? deriv :
                                 MergeFaces(fTextFace, deriv));      // 07/07/93
                         // (deriv == fTextFace ? 0 : deriv ^ fTextFace));
                         // 15/04/93 [20824] Needs to be done properly
      }
      if (derivDef & kCaps)
        fTextCaps = TStyleFormat(derivative)->fTextCaps;
      if (derivDef & kAlignment)
        fAlignment = TStyleFormat(derivative)->fAlignment;
      if (derivDef & kLeading)
      {
        fLeading = TStyleFormat(derivative)->fLeading;
        fFixedHeight = TStyleFormat(derivative)->fFixedHeight;
      }
      if (derivDef & kSpaceBefore)
        fSpaceBefore = TStyleFormat(derivative)->fSpaceBefore;
      if (derivDef & kSpaceAfter)
        fSpaceAfter = TStyleFormat(derivative)->fSpaceAfter;
    }

    if (derivDef & (kAdornment | kHyphenate | kLanguage | kColour))
    {
      if (derivDef & kAdornment)
      {
        fAdornment = TStyleFormat(derivative)->fAdornment;
        fRuleType = TStyleFormat(derivative)->fRuleType;
      }
      if (derivDef & kHyphenate)
        fHyphenate = TStyleFormat(derivative)->fHyphenate;
      if (derivDef & kLanguage)
        fLanguage = TStyleFormat(derivative)->fLanguage;
      if (derivDef & kColour)
        fColour = TStyleFormat(derivative)->fColour;
    }

    if (derivDef & (kOwnSpaceBefore | kOwnSpaceAfter | kOwnAlignment | kOwnAdornment))
    {
      if ((fDefined & kHasSpaceBefore) && (derivDef & kOwnSpaceBefore))
        fOwnSpaceBefore = TStyleFormat(derivative)->fOwnSpaceBefore;
      if ((fDefined & kHasSpaceAfter) && (derivDef & kOwnSpaceAfter))
        fOwnSpaceAfter = TStyleFormat(derivative)->fOwnSpaceAfter;
      if ((fDefined & kHasAlignment) && (derivDef & kOwnAlignment))
        fOwnAlignment = TStyleFormat(derivative)->fOwnAlignment;
      if ((fDefined & kHasAdornment) && (derivDef & kOwnAdornment))
      {
        fOwnAdornment = TStyleFormat(derivative)->fOwnAdornment;
        fOwnRuleType = TStyleFormat(derivative)->fOwnRuleType;
      }
    }

  }
  _TRulerDef::ApplyOverride(derivative, currency, applyRuler);
  fDefined |= (derivDef & (~(kHasSpaceBefore | kHasSpaceAfter
               | kHasAdornment | kHasAlignment | kHasMargins | kEmphasis))); 
  if (derivDef & kRuler)
  {
    int numCols;
    Fixed colSep = derivative->GetGutterWidth();

    if (colSep > 0)
      SetGutterWidth(colSep);
    numCols = derivative->GetTotalColumns();
    if (numCols > 0)
      SetTotalColumns(numCols);
    
    if ((fDefined & (kLeftMgn | kRightMgn | kIndent)) != (kLeftMgn | kRightMgn | kIndent))
    {
      // no point in testing if target bits already set
      if (GetLeftMargin() >= 0)      // 03/03/92 now does! Use GetLeftMargin, etc!!!
        fDefined |= kLeftMgn;
      if (GetRightMargin() >= 0)
        fDefined |= kRightMgn;
      if (GetIndentation() >= 0)
        fDefined |= kIndent;
    }
    if (fTotalColumns > 0)
    {
      fDefined |= kCols;
      if (fTotalColumns > 1 && fGutterWidth >= 0)
        fDefined |= kColSep;
    }
    // 21/02/92 remove * from style when last tab removed
    if (fSize == 0 && (fDefined & (kLeftMgn | kRightMgn | kIndent |
                              kCols | kColSep)) == 0)
      fDefined &= ~kRuler;
  }
}


// ------------------------------------------------------------------------
bool _TStyleFormat::MergeEmphasisAttrs(TStyleFormat changes, bool toggle)
{
  Attributes defined;

  if (changes->fDefined & kFont)
  {
    if (!(fDefined & kFont) || (fTextFont != changes->fTextFont))
    {
      fTextFont = changes->fTextFont;
      strcpy(fFontName, changes->fFontName);
      // 12/06 & 16/08/90 - get the font name merged with the emphasis attrs
      fDefined |= kFont;
    }
    else
    {
      if (toggle)
        fDefined &= ~kFont;
    }
  }
  else if (changes->fFontName[0] != 0 && fFontName[0] == 0)
    strcpy(fFontName, changes->fFontName);
           // 29/08/90 name may be saved in style for kSize, etc.

  if (changes->fDefined & kSize)
  {
    if (!(fDefined & kSize) ||
               fTextSizeX != changes->fTextSizeX || fTextSizeY != changes->fTextSizeY)
    {
      fTextSizeX = changes->fTextSizeX;
      fTextSizeY = changes->fTextSizeY;
      fDefined |= kSize;
    }
    else if (toggle)
      fDefined &= ~kSize;
  }

  if (changes->fDefined & kColour)
  {
    if (!(fDefined & kColour) || fColour != changes->fColour)
    {
      fColour = changes->fColour;
      fDefined |= kColour;
    }
    else if (toggle)
      fDefined &= ~kColour;
  }

  if (changes->fDefined & kFace)    // 21/03/91 simplified
  {
    if (!(fDefined & kFace) || fTextFace != changes->fTextFace)
    {
      fTextFace = MergeFaces(fTextFace, changes->fTextFace);  // 07/07/93
      // fTextFace ^= changes->fTextFace;   // 15/04/93 [20824] Needs to be done properly
      fDefined |= kFace;
    }
    else if (toggle)
      fDefined &= ~kFace;
  }

  if (changes->fDefined & kCaps)
  {
    if (toggle && (fDefined & kCaps) &&
                (changes->fTextCaps == fTextCaps || changes->fTextCaps == kMixedCase))
      fDefined &= ~kCaps;
    else
    {
      fTextCaps = changes->fTextCaps;
      fDefined |= kCaps;
    }
  }

  if (changes->fDefined & kLanguage)
  {
    if (!(fDefined & kLanguage) || fLanguage != changes->fLanguage)
    {
      fLanguage = changes->fLanguage;
      fDefined |= kLanguage;
    }
    else if (toggle)
      fDefined &= ~kLanguage;
  }
  if (changes->fDefined & kEmphasis)
    fDefined |= kEmphasis;                // 28/01/91

  defined = changes->fDefined;
  changes->fDefined &= ~emphasisAttrs;
  // 12/01/92 better test!; if (changes->fDefined != 0)
  if (changes->NumOfAttrs(0) != 0)                  // 23/09/93 new param: (wrong??? )
    ApplyOverride(changes, gNullCurrency, TRUE);
  changes->fDefined = defined;

  return (fDefined & (emphasisAttrs & ~kEmphasis));
}


// ------------------------------------------------------------------------
CmdNumber _TStyleFormat::ChangeAlign(TAlignment newAlign)
// 11/09/90 new for common bits of TPictView & TTextEvent
{
  if ((fDefined & kHasAlignment) != 0)
  {
    if ((fDefined & kOwnAlignment) != 0 && fOwnAlignment == newAlign)
      fDefined &= (~kOwnAlignment);
    else
    {
      fDefined |= kOwnAlignment;
      fOwnAlignment = newAlign;
    }
  }
  else
  {
    fDefined |= kAlignment;
    fAlignment = newAlign;
  }
  return cJustifyChange;
}


// ------------------------------------------------------------------------
int _TStyleFormat::SelectStyle(TTextDocument document, TStyle &theStyle,
                                                        TEmphasisType emphasis)
{
  bool set1;
  bool scripted;
  int theSizeX, theSizeY;
  int backwards = 0;   // will be reset to correct value if kFont set in style

  if (emphasis == kNoEmphasis)
  {
    theStyle.fcTextFace = 0;
    theStyle.fcSpaceBefore = fSpaceBefore;
    theStyle.fcSpaceAfter = fSpaceAfter;
    theStyle.fcSpaceExtra = 0;  // 06/09/95 theStyle.fcAlignment = fAlignment;
    theStyle.fcAdornment = 0;
    theStyle.fcTextCaps = kMixedCase;
    theStyle.fcRuler = this;
    theStyle.fcFixedHeight = Odd(fFixedHeight);
    theStyle.fcAutoIndent = fAutoIndent;  // 28/05/90 - bullets below added...
    if (fDefined & kBullet)
    {
      theStyle.fcBullet = fBullet;
      theStyle.fcAutoBullet = fAutoBullet;   // [20981]
      theStyle.fcBulletFont = fBulletFont;
    }
    else
      theStyle.fcBullet = 0;
  }

  scripted = set1 = FALSE;

  if ((fDefined & kSize) != 0)
  {
    theSizeX = fTextSizeX;
    theSizeY = fTextSizeY;
    set1 = TRUE;
  }
  else
  {
    theSizeX = theStyle.fcTextSizeX;
    theSizeY = theStyle.fcTextSizeY;
  }

  if ((fDefined & kFace) != 0)
  {
    // ??? may need to toggle if theStyle.fcTextFace is already set ???
    // 18/08/93 [21027] use new MergeFaces: theStyle.fcTextFace |= fTextFace;
    theStyle.fcTextFace = MergeFaces(theStyle.fcTextFace, fTextFace);
    if (          // 18/06/93 what is this for???      !(fDefined & kSize) &&
             ((kSuperscript | kSubscript) & fTextFace))
      scripted = TRUE;
    set1 = TRUE;
  }

  if (scripted || emphasis == kFootnoteEmphasis)
  {
    theSizeX = (theSizeX * 2) / 3;
    theSizeY = (theSizeY * 2) / 3;
    set1 = TRUE;
  }

  if ((fDefined & kFont) || set1)
  {
    // 28/04/92 code from SetStyles: was corrupting styles by losing the font with 2 emphs
    if ((fDefined & kFont) && emphasis != kSymbolEmphasis)
      theStyle.fcTextFont = fTextFont;

    theStyle.fcTextSizeX = theSizeX;
    theStyle.fcTextSizeY = theSizeY;

    backwards = document->SetCurrentFont(PFontStyle(&theStyle.fcTextFont));

    set1 = TRUE;
  }

  if ((fDefined & kColour) != 0)
  {
    theStyle.fcColour = fColour;
    TextColour(theStyle.fcColour, FALSE);
  }

  if (set1)
  {
    Fixed ascent, descent, leading;

    MeasureFont(ascent, descent, leading);  // 25/10/90 combine fudges together

    if (emphasis != kNoEmphasis)
    {
      if (scripted || emphasis == kFootnoteEmphasis)
      {
        // [20834] move the base line up by 1/3rd the ascent
        theStyle.fcAscent = FixRound(ascent + kFixHalf);
        theStyle.fcDescent = FixRound(descent + kFixHalf);
      }
      else if (!theStyle.fcFixedHeight)
      {
        theStyle.fcAscent = Max(theStyle.fcAscent, FixRound(ascent + kFixHalf));
        theStyle.fcDescent = Max(theStyle.fcDescent, FixRound(descent + kFixHalf));
      }
    }
    else
    {
      theStyle.fcAscent = FixRound(ascent + kFixHalf);

#if !defined TABLES
 // || defined NETWP
      { // 26/8/92 StartWrite line spacing
        Fixed lh = ascent + descent + leading;

        if (fLeading != 0)
        {
          if (fLeading & 1)
            lh *= 2;
          else
            lh = lh * 3 / 2;
        }
        theStyle.fcDescent = FixRound(lh - ascent + kFixHalf);
      }
#else
      theStyle.fcDescent = FixRound(descent + leading + kFixHalf);
      if (fLeading != 0)
      {
        // fFixedHeight == 0: old style TechWriter: Custom set, fixedHeight unset
        // fFixedHeight == 1: fixed height line of size fLeading
        // fFixedHeight == 2: at least size given by fLeading
        // fFixedHeight == 4: multiple line spacing: (line depth * fLeading) / 120
        int theLeading = fLeading;

        if ((fFixedHeight & 4) != 0)
          theLeading = (theLeading * (theStyle.fcAscent + theStyle.fcDescent)) / 120;
                          // 21/10/96 Multi-line spacing like MS Word

        if (fFixedHeight < 2 || theStyle.fcAscent + theStyle.fcDescent < theLeading)
        {
          // 01/05/91 ensure the descent never goes negative
          theStyle.fcDescent = Max(0, theLeading - theStyle.fcAscent);
          theStyle.fcAscent = theLeading - theStyle.fcDescent;
        }
      }
#endif
    }
  }

  if ((fDefined & kCaps) != 0)
    theStyle.fcTextCaps = fTextCaps;

  if ((fDefined & kAdornment) != 0)
  {
    theStyle.fcAdornment = fAdornment;
    theStyle.fcRuleType = fRuleType;
  }

  if ((fDefined & kHyphenate) != 0)
    theStyle.fcHyphenate = fHyphenate;

  if ((fDefined & kLanguage) != 0)
    theStyle.fcLanguage = fLanguage;

  return backwards;
}


// ------------------------------------------------------------------------
bool _TStyleFormat::Match(TStyleFormat theStyle)
{
  unsigned int rulerMask = ComputeRulerMask(this);
  unsigned int rulerMask1 = ComputeRulerMask(theStyle);

  if (fDefined == theStyle->fDefined && rulerMask == rulerMask1 && fSize == theStyle->fSize)
  {
    unsigned int mask1, mask2;
    int currPtr;
    char buffer[sizeof(_TStyleFormat)];
    char buffer1[sizeof(_TStyleFormat)];

    ComputeStyleMasks(fDefined, &mask1, &mask2);
    mask1 |= (rulerMask << 1);
    mask1 &= ~(0x8401); // ignore fTimestamp and fDefined and font
    mask2 &= ~(0x0800); // ignore bullet font - match font names not numbers
    currPtr = PackRecord(mask1, gStyleMap1, (char *)&fDefined, buffer);
    currPtr += PackRecord(mask2, gStyleMap2, (char *)&fRuleType, buffer + currPtr);
    currPtr = PackRecord(mask1, gStyleMap1, (char *)&theStyle->fDefined, buffer1);
    currPtr += PackRecord(mask2, gStyleMap2, (char *)&theStyle->fRuleType, buffer1 + currPtr);
    // need to match font names, not the font numbers which are document specific, and
    // we may be matching styles from 2 different documents
    if (memcmp(buffer, buffer1, currPtr) == 0 &&
      ((fDefined & kFont) == 0 ||
        strcmp(fFontName, theStyle->fFontName) == 0) &&
      ((fDefined & kBullet) == 0 ||
        (fAutoBullet == theStyle->fAutoBullet &&    // [20981] - auto bullet is not packed
         strcmp(fBulletFontName, theStyle->fBulletFontName) == 0)))
    {
      // match so far so check the tabs
      for (int tn = 1; tn <= fSize; tn++)
      {
        PFTabInfo ts1 = PFTabInfo(At(tn));
        PFTabInfo ts2 = PFTabInfo(theStyle->At(tn));

        if (ts1->fStop != ts2->fStop ||
            ts1->fDeleted != ts2->fDeleted ||
            ts1->fKind != ts2->fKind ||
            ts1->fMark != ts2->fMark ||
            strncmp(ts1->fFiller, ts2->fFiller, kFillerLen) != 0)
           return FALSE;
      }
      // 12/06/90 - copy the font name if these styles are meant to be the same
      // but are not quite.
      if (strcmp(fFontName, theStyle->fFontName) != 0 && theStyle->fFontName[0] != 0)
        strcpy(fFontName, theStyle->fFontName);

      return TRUE;
    }
  }
  return FALSE;
}

#ifdef TABLES
// ------------------------------------------------------------------------
void AppendAttr(char *key, char *val, char *description)
{
  if (key != NULL)      // 09/07/90 from key[0] != 0
  {
    if (description[0] != 0)
      strcat255(description, " + ");

    strcat255(description, key);

    if (val[0] != 0)
    {
      strcat255(description, ":");
      strcat255(description, val);
    }
  }
}
#endif

#ifdef TABLES
// ------------------------------------------------------------------------
void _TStyleFormat::GetEmphasisDescription(char *description)
// [20834] new for icon bar & style attrs description
{
  Style theFace = fTextFace;

#ifdef TRACE
  if ((theFace & 3) == 3)
    theFace &= ~3;             // [20983] both on means normal
#endif

  description[0] = 0;
  for (int i = 0; i < 7; i++)  // 19/07/94 6->7 for kern
  {
    if ((theFace & (1 << i)) != 0)
    {
      int descLen = strlen(description);

      if (descLen != 0)
      {
        description[descLen] = '/';
        descLen++;
      }
      strcpy(description + descLen, GetIndString(kTextFaceStrs, i + 1));
    }
  }
}
#endif

// ------------------------------------------------------------------------
void _TStyleFormat::GetDescription(char *description)
{
#ifdef TABLES
  int attr;
  int keyId;
  Str255 val;
//  bool onOff;
  int onOffValue;
  Attributes defined = fDefined;
  int numVal;
  char *appnd;
  int bitnum;  // 06/11/92 faster/smaller code for case

  for (attr = kFont, bitnum = 0; attr <= kBullet; attr = (attr << 1), bitnum++)
    if ((defined & attr) != 0)
    {
      val[0] = 0; // 09/07/90
      keyId = 0;
      onOffValue = -1;
      numVal = -1;
      appnd = NULL;
      switch (bitnum)  // 06/11/92 attr)
      {
      case kBitSize:
        keyId = kSizeDesc + 1;
        if (fTextSizeX != fTextSizeY)  // the x,y sizes are different
        {
          strcpy(val, " X:");
          NumToString(fTextSizeX / 16, val + strlen(val));     
          strcat(val, GetIndString(kSmallUnitsRsrc, 4));
          strcat(val, " Y:");
        }
        NumToString(fTextSizeY / 16, val + strlen(val));     
        appnd = GetIndString(kSmallUnitsRsrc, 4);
//        else the x,y sizes are the same so just do the one value
        break;

      case kBitColour:
        keyId = kColourStr;
        break;

      case kBitFace:
        keyId = kFaceDesc + 1;
// [20834] use list of face attrs:   appnd = GetIndString(kTextFaceStrs, fTextFace);
        GetEmphasisDescription(val);
        break;

      case kBitCaps: 
        if (fTextCaps != kMixedCase)
        {
          keyId = kCapsDesc + 1;
          appnd = GetIndString(kStyleDescStrs, kUpperStr + int(fTextCaps) - 1);
        }
        break;

      case kBitOwnAlignment:          // 04/10/93 for table alignment
        keyId = kAlignmentDesc + 1;
        appnd = GetIndString(kStyleDescStrs, kLeftStr + int(fOwnAlignment));
        break;

      case kBitAlignment:
        keyId = kAlignmentDesc + 1;
        appnd = GetIndString(kStyleDescStrs, kLeftStr + int(fAlignment));
        break;

      case kBitLeading:
        if (fLeading == 0)
          strcpy255(val, GetIndString(kStyleDescStrs, kAutoStr));
        else
          NumToString(fLeading / 10, val); // 10/07/90

        if (Odd(fFixedHeight))
        {
           strcat255(val, "/");
           appnd = GetIndString(kStyleDescStrs, kFixedStr);
        }
        keyId = kLeadingDesc + 1;
        break;

      case kBitSpaceBefore:
        keyId = kSpaceBeforeDesc + 1;
        numVal = fSpaceBefore;
        break;

      case kBitSpaceAfter:
        keyId = kSpaceAfterDesc + 1;
        numVal = fSpaceAfter;
        break;

      case kBitOwnSpaceBefore:                 // 12/05/91
        keyId = kSpaceBeforeDesc + 1;
        numVal = fOwnSpaceBefore;
        break;

      case kBitOwnSpaceAfter:                 // 12/05/91
        keyId = kSpaceAfterDesc + 1;
        numVal = fOwnSpaceAfter;
        break;

#ifndef EDITSTYLES
      case kBitRuler:
        // 19/02/91 use Get... for f... to pick up fOwn values
        if (GetLeftMargin() >= 0) defined |= kLeftMgn;
        if (GetRightMargin() >= 0) defined |= kRightMgn;
        if (GetIndentation() >= 0) defined |= kIndent;
        if (GetSize() > 0) defined |= kTabs;
        if (fTotalColumns >= 1)                      // 19/02/91
           defined |= kCols;
        if (fTotalColumns != 1 && fGutterWidth >= 0)
           defined |= kColSep;
        break;
#endif

      case kBitLeftMgn:
        keyId = kLeftMgnStr;
        break;

      case kBitRightMgn:
        keyId = kRightMgnStr;
        break;

      case kBitIndent:
        keyId = kIndentStr;
        break;

      case kBitTabs:
        keyId = kTabsStr;
        break;

      case kBitCols:
        keyId = kColsStr;
        numVal = fTotalColumns * 10;
        break;

      case kBitColSep:
        keyId = kSepStr;
        CvtUnitsToStr(fGutterWidth, gUnits, gCustomPoints,
                                     eNoConstraint, 0, val);
        appnd = GetIndString(32, MinMax(1, gUnits, 7));
        break;

      case kBitOwnAdornment:
// 01/08/91        if (fOwnAdornment != 0)
// 04/10/93          keyId = kAdornStr;
// 04/10/93        break;
      case kBitAdornment:
// 01/08/91        if (fAdornment != 0)
          keyId = kAdornStr;
        break;

      case kBitHyphenate:
        keyId = kHyphenateStr;
        // onOff = TRUE;
        onOffValue = fHyphenate;
        break;

      case kBitLanguage:
        keyId = kLanguageStr;
#if defined TABLES && ! defined NETWP
        if (fLanguage == 0)
          CmdToName(cNoLanguage, val);     // 17/02/94 [21403] say None, not Default
        else
#endif
          GetCountryName(fLanguage, val);
        break;

      case kBitAutoIndent:
        keyId = kAutoIndentStr;
        // onOff = TRUE;
        onOffValue = fAutoIndent;
        break;

      case kBitBullet:
        keyId = kBulletStr;
#ifdef AUTONUM
        if ((unsigned int)(fBullet - 1) < 2)
          keyId = 33 + fBullet;
        else
#endif
          onOffValue = (fBullet != 0);
        break;
      }
      if (numVal >= 0)
        NumToString(numVal / 10, val);
      if (appnd != NULL)
        strcat255(val, appnd);

      // 18/05/90: do not print the word 'Font:'
      AppendAttr(
        attr == kFont ? fFontName : GetIndString(kStyleDescStrs, keyId),
        onOffValue >= 0 ? GetIndString(kOnOffStrs, int(onOffValue) + 1) : val, description);
    }
#endif
}


// ------------------------------------------------------------------------
bool PoseDialog(TDialogView theDialog, int dialogCmd, TTextDocument theDocument)
{
  IDType choice;

  theDialog->SetIdleFreq(0);   // all except border dialog did this
  choice = theDialog->PoseModally(dialogCmd);
  theDialog->Close();
  return (choice  == gIDOKbn);
}

#ifdef TABLES
// ------------------------------------------------------------------------
bool _TStyleFormat::ChangeTypeSpec(TTextDocument theDocument, TStyleFormat theChanges)
{
  TTypeSpecDlg typeDialogView;
  
  ApplyOverride(theChanges, gNullCurrency, FALSE);
  typeDialogView = TTypeSpecDlg(NewTemplateWindow(kTypeSpecDlgID, theDocument));

  typeDialogView->InitialiseTypeSpecDlg(); // set up the font lists
  typeDialogView->SetAttrs(this, theChanges, TRUE);
  return PoseDialog(typeDialogView, cTypeSpec, theDocument);
}
#endif

// ------------------------------------------------------------------------
bool _TStyleFormat::ChangeBorders(TTextDocument theDocument, TStyleFormat theChanges,
                                  TStyleTypes theType)
{
  bool  ChangeBorders_r;
  TSpacingDlg bordersDialogView;

  ApplyOverride(theChanges, gNullCurrency, FALSE);
#if SIDEBAR == 1
  if (theType == -1)
    bordersDialogView = TSpacingDlg(NewTemplateWindow(44, theDocument));
  else
#endif
    bordersDialogView = TSpacingDlg(NewTemplateWindow(kBordersDlgID, theDocument));
  bordersDialogView->SetReadWriteHandler(bordersDialogView);
  bordersDialogView->fStyleFormat = this;
  bordersDialogView->fChanges = theChanges;

#ifdef FN
  ChangeBorders_r = PoseDialog(bordersDialogView, 
           (theType == kNoteSet ? cNoteBorders: cBorders), theDocument);
#else
#if SIDEBAR == 1
  if (theType == -1)
    ChangeBorders_r = PoseDialog(bordersDialogView, cSizeDialog, theDocument);
  else
#endif
    ChangeBorders_r = PoseDialog(bordersDialogView, cBorders, theDocument);
#endif
  return(ChangeBorders_r);
}


#if defined TABLES || defined WORD7
// ------------------------------------------------------------------------
void _TStyleFormat::SetSpaceBefore(int newVal)
{
  if ((fDefined & kHasSpaceBefore) != 0)
  {
    fDefined |= kOwnSpaceBefore;
    fOwnSpaceBefore = newVal;
  }
  else
  {
    fDefined |= kSpaceBefore;
    fSpaceBefore = newVal;
  }
}

// ------------------------------------------------------------------------
void _TStyleFormat::SetSpaceAfter(int newVal)
{
  if ((fDefined & kHasSpaceAfter) != 0)
  {
    fDefined |= kOwnSpaceAfter;
    fOwnSpaceAfter = newVal;
  }
  else
  {
    fDefined |= kSpaceAfter;
    fSpaceAfter = newVal;
  }
}
#endif

#ifdef TABLES
// ------------------------------------------------------------------------
bool _TStyleFormat::ChangeSpacing(TTextDocument theDocument, TStyleFormat theChanges, bool canType)
{
  TSpacingDlg spacingDialogView;

  spacingDialogView = TSpacingDlg(NewTemplateWindow(
             canType ? kSpacingDlgID : kPicSpacingDlgID, theDocument));
  spacingDialogView->SetAttrs(this, theChanges, TRUE); 
  spacingDialogView->SetReadWriteHandler(spacingDialogView);
  return PoseDialog(spacingDialogView, cSpacing, theDocument);
}
#endif


// -------------------------------------------------------------------------
int _TStyleFormat::GetChangeDlg(TStyleTypes theType)
  // 18/06/92
{
  return (theType >= kDocTitle && theType <= kChapCount ? 0 : kTextAttrsDlgID);
}


// ------------------------------------------------------------------------
bool _TStyleFormat::ChangeStyleAttrs(TTextDocument theDocument,
                              TStyleFormat theChanges, TStyleTypes theType)
{
#ifdef TABLES
  TTextAttrsDlg attrsDialogView;
  int dlgId = GetChangeDlg(theType);
  THandler helper;
  bool ChangeStyleAttrs_r;
  FailInfo fi;

  if (dlgId == 0 || (dlgId == kTextAttrsDlgID && theChanges->NumOfAttrs(0) == 0))
                 // 05/07/93 suppress useless dialogue, 23/09/93 include ruler in num attrs
    return FALSE;

  attrsDialogView = TTextAttrsDlg(NewTemplateWindow(dlgId, theDocument));

  CatchFailures(&fi);
  helper = theDocument->CreateAHandler(attrsDialogView, this, theChanges, theType);
  Success(&fi);

  attrsDialogView->SetReadWriteHandler(helper);

  ChangeStyleAttrs_r = PoseDialog(attrsDialogView, cChangeStyle, theDocument);
  helper->Free();
  return ChangeStyleAttrs_r;

Rescue:
  FreeIfObject(attrsDialogView);
  ContinueFailure(&fi);
#else
  return FALSE;
#endif
}

#ifdef TRACE
#ifdef AUTONUM
// ------------------------------------------------------------------------
char *_TStyleFormat::GetAutoCustom()
{
  return NULL;
}

// ------------------------------------------------------------------------
void _TStyleFormat::SetAutoCustom(char *str)
{
}
#endif
#endif

#ifdef TABLES
// ------------------------------------------------------------------------
// 03/01/91 - EventHandler object for communication between Dialog and Style
_TStyleDlgHelper::_TStyleDlgHelper(TDialogView theDialog, TStyleFormat theStyle,
         TStyleFormat theChanges, TStyleTypes theType) : (theDialog)
{
  fStyleFormat = theStyle;
  fChanges = theChanges;
  fType = theType;
}


// ------------------------------------------------------------------------
TCommand _TStyleDlgHelper::ReadFromDialog(TView aDialog, CmdNumber aCmd, IDType itsId)
{
  TTextDocument(TheDlg()->fDocument)->fSelection->fStyleChanges = NULL;
             // 11/01/91 ensure not freed by commit
  fChanges = NULL;
  return fNextHandler->ReadFromDialog(aDialog, aCmd, itsId);
}


// ------------------------------------------------------------------------
void _TStyleDlgHelper::WriteToDialog(TView aDialog, CmdNumber aCmd)
{
  TTextDocument theDoc = TTextDocument(TheDlg()->fDocument);
                  // 04/01/91 Experiment to see if we can get changes back

  if (fChanges == NULL)
  {
    theDoc->fSelection->CommitStyle(TCommand(-1));
    fChanges = TStyleFormat(theDoc->GetCurrentChanges(TRUE));
         // 14/10/93 Change i/f to indicate whether dialogue style "Changes" wanted
  }
  FreeIfObject(TheDlg()->fStyleFormat);
  TheDlg()->SetAttrs(fStyleFormat, fChanges,
         fType == kText && theDoc->GetNewSelection()->fCursor);
                              // 23/07/96 [27030] dim Delete button if insertion pt (in emphasis)
  ResetStyle();
}

// ------------------------------------------------------------------------
void _TStyleDlgHelper::DoChoice(TView origView, int itsChoice)
{
  if (origView->fIdentifier == I_('D', 'e', 'l', '0'))
  {
    fChanges->DeleteAttribute(fChanges, -1);
                                   // 04/01/91 remove changes generically
    WriteToDialog(TheDlg(), cStyleChange);
  }
  else if (origView->fIdentifier == gIDCncl)
    fChanges = NULL;
}

// ------------------------------------------------------------------------
void _TStyleDlgHelper::ResetStyle()
{
  TheDlg()->ResetStyle();
}
#endif
