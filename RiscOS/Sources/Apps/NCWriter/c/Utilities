/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "kernel.h"

#include "drawfdiag.h"
#include "drawferror.h"
#include "drawfobj.h"
#include "drawftypes.h"
#include "win.h"
#include "event.h"
#include "bbc.h"

#include "os.h"
#include "swis.h"
#include "font.h"

#include "UFailure.h"
#include "DrawIFace.h"
#include "Utilities.h"
#include "USaveDraw.h"

extern wr_os_error *FontPaint(char *string, int flags, int xpos, int ypos);
extern wr_os_error *FontPaintJust(char *string, int flags, int xpos, int ypos, int *);
extern wr_os_error *FontFind(int *handle, char *name, int xsize, int ysize);
extern void FontLose(int handle);

#define kDefaultFontMsg 200

// globals
char *gDecPoint;
char *gThousSep;
bool gPrinting = FALSE;
char *gRegUserName;
char *gRegUserNumber;
char gUnderlinePos[4] = {64, 248, 16, 16};
// ptr to the font tree
FontTree gFontHead = {{0,0,0,0,0,0,0}};
bool gInUpdate;      // 14/04/92 to avoid erase while text drawing

// static globals for the last font in the system
char  gLastFontName[40];
int   gLastFontSizeX;
int   gLastFontSizeY;
font  gLastFontHandle;
Style gLastFontStyle;  // 23/07/90 - the last style used
char *gFontPath;
int   gLastFontColour; // 14/04/92
int   gLastFontColourOpt; // 29/04/92
FontTree *gLastFontTreePtr;  // 14/04/93
TSender gSender = NULL;   // 13/10/92
bool  gNewFontMgr;
static int gBackwardsFont;
static int gBackwardsFontSet = 0;
static char *gWordWrapTable = NULL;
static char gWordWrapTableLat1[32] = {
  '\200', '\000', '\000', '\000', '\175', '\312', '\377', '\361',
  '\377', '\377', '\377', '\375', '\377', '\377', '\377', '\366',
  '\377', '\377', '\376', '\077', '\377', '\377', '\277', '\377',
  '\377', '\377', '\376', '\377', '\377', '\377', '\376', '\377' };
// 28/10/90 made like Mac by excluding only maths type operators
// sp & * + - / < = > ^ | del ± × ÷
// 09/07/92 and 3 '-' like symbols
// 25/08/93 Bit 0 ??? (footnotes or widgets)

static char gWordWrapTableSymb[32] = {
  '\200', '\000', '\000', '\000', '\175', '\312', '\377', '\361',
  '\377', '\377', '\377', '\375', '\377', '\377', '\377', '\366',
  '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377',
  '\377', '\377', '\377', '\377', '\377', '\377', '\377', '\377' };

TDeclaredFontList gMasterList = NULL; // 29/10/92

StringHandle gFontBoldNames;    // [20824]
StringHandle gFontItalicNames;

struct {
   char *contents;
   int   fileHandle;
   long  filePos;
   long  eof;
} gRAMFile = {0, 0, 0, 0};
 
/*----------------------- Global draw data --------------------------------*/

/* Unknown object handler, and its handle */
wr_draw_unknown_object_handler wr_dr_unknown_handler = 0;
void *wr_dr_unknown_handle;
extern wr_os_error *wr_displ_setVDU5charsize(int xsize, int ysize, int xspace, int yspace);

typedef struct      /* cached values read by wr_bbc_vduvars, so ordering */ 
                    /* is important, see cache_currentmodevars        */      
{
  int gcharaltered; /* flag set if Draw changes the system font size */

  int gcharsizex;   /* if so, restore from here */  /* first cached value */
  int gcharsizey;
  int gcharspacex;
  int gcharspacey;
 
  int ncolour;
  int xeigfactor;
  int yeigfactor;                                   /* last cached value  */

  int pixsizex;     /* in dBase coords, ie 0x100 << xeigfactor */
  int pixsizey;     /* in dBase coords, ie 0x100 << yeigfactor */
} currentmodestr;

/* Current mode state */
currentmodestr wr_currentmode;

/* List of the mode variables we want */
static int modevarlist[] =
{ wr_bbc_GCharSizeX, wr_bbc_GCharSizeY, wr_bbc_GCharSpaceX,wr_bbc_GCharSpaceY,
  wr_bbc_NColour,
  wr_bbc_XEigFactor, wr_bbc_YEigFactor,
  -1
};

/* Flag needed for text areas */
BOOL Draw_memoryError;

/* Hooks for handling font numbers */
wr_draw_fontListDeclare wr_fontListHandler = NULL;
wr_draw_fontListAccess wr_fontGetName = NULL;
void *wr_fontProcHandle;

/* Memory allocation/freeing functions */
wr_draw_allocate wr_Draw_allocator = NULL;
wr_draw_extend   wr_Draw_extender  = NULL;
wr_draw_free     wr_Draw_freer     = NULL;

#ifdef NETWP
// -------------------------------------------------------------------------
wr_os_error *wr_displ_setVDU5charsize(int xsize, int ysize, int xspace, int yspace)
{
  wr_os_error *e;

  wr_currentmode.gcharaltered = 1;  /* so we restore before next pollwimp */
  e = wr_bbc_vduq(23, 17, 7, 2, xsize, xsize >> 8, ysize, ysize >> 8, 0, 0);
  if (!e)
    wr_bbc_vduq(23, 17, 7, 4, xspace, xspace >> 8, yspace, yspace >> 8, 0, 0);
  return(e);
}

#endif

/* -------------------------- wr_dr_setScreenState -------------------------------
 Function    : wr_dr_setScreenState
 Purpose     : cache mode variables and set up for output
 Parameters  : void
 Returns     : VDU status byte (as an int)
 Description : records the mode variables needed for rendering; records the VDU
               state and sets to VDU5 style output
*/

int wr_dr_setScreenState(void)
{
  int VDUstatus;           /* VDU status: only the VDU5 setting matters */
  int dx = wr_wimpt_dx(), dy = wr_wimpt_dy();
  int xeig = 0, yeig = 0;

  while (dx > 1) { dx = dx>>1; xeig++; }
  while (dy > 1) { dy = dy>>1; yeig++; }

  /* Get mode variables */
  wr_bbc_vduvars(modevarlist, &wr_currentmode.gcharsizex);

  wr_currentmode.gcharaltered = 0;

  if (dx == 0 && dy == 0)
  {
  wr_currentmode.pixsizex = 0x100 << wr_currentmode.xeigfactor;
  wr_currentmode.pixsizey = 0x100 << wr_currentmode.yeigfactor;
  }
  else
  {
    wr_currentmode.pixsizex = 0x100 << xeig;
    wr_currentmode.pixsizey = 0x100 << yeig;
  }

  /* probably the whole of the following is redundant - but definitely need to stop  */
  /* vdu(4) while printing to stop crash while using CC's register corrupting driver */
  if (gPrinting)    /* 24/11/93 [20606] Avoid vdu(5) and vdu(4) */
    return 0x20;

  /* Get VDU status */
  wr_os_byte(117, &VDUstatus, &yeig); /* 23/04/93 need address of something for last param */

  /* Set to VDU5 mode */
  wr_bbc_vdu(5);

  return (VDUstatus);
}

/* --------------------------- wr_dr_recoverScreenState ------------------------
 Function    : wr_dr_recoverScreenState
 Purpose     : restore (some) changed mode variables and reset the VDU5 state
 Parameters  : old vdu status
 Returns     : void
*/

// static gCCFrig;  // 04/02/93 [20606]
void wr_dr_recoverScreenState(int status)
{
  if (wr_currentmode.gcharaltered)
  {
    wr_displ_setVDU5charsize(wr_currentmode.gcharsizex,  wr_currentmode.gcharsizey,
                          wr_currentmode.gcharspacex, wr_currentmode.gcharspacey);
    wr_currentmode.gcharaltered = 0;
  }

  if ((status & 0x20) == 0)
    wr_bbc_vdu(4);
//  gCCFrig = 0;  // 04/02/93 [20606] frig to get registers reloaded after CC driver bug
}

// -------------------------------------------------------------------------
wr_os_error *ReadExpression(char *buffer, char *expression, int *count)
{
  return wr_os_swi3r(OS_GSTrans | wr_os_X, (int)expression,
                            (int)buffer, *count, NULL, NULL, count);
}

// -------------------------------------------------------------------------
#define MAXELEM 1024
#define boldweight 1
#define italicweight 1
static FontTree *gOriginalName;
static FontTree *gNewName;
static int gBestmatch;
// -------------------------------------------------------------------------
// See whether the given string appears in the space-separated list.
static int bi__findstring(char *list, char *item)
{
  char *ptr1, *ptr2;
  int itemlen = strlen(item);
  int i;
  int itemno = MAXELEM;

  for ( ptr1 = list; ; ptr1 = ptr2+1 )
  {
    itemno--;

    for ( ptr2 = ptr1; *ptr2; ptr2++ ) if ( *ptr2==' ' ) break;

    if ( itemlen == ptr2-ptr1 )
    {
      for ( i = 0; i<itemlen; i++ )
      {
        if ( tolower(ptr1[i]) != tolower(item[i]) ) break;
      }
      if ( i == itemlen ) return itemno;
    }

    if ( *ptr2 == 0 ) break;
  }

  return 0;             /* not found */
}

// -------------------------------------------------------------------------
FontTree *AllocFontTreeNode(int namePartLen, char *name)
{
   FontTree *newNode = (FontTree *)FailNIL(malloc(sizeof(FontTreeHdr) + namePartLen + 1));

   /* and initialise its fields */
   strcpyn(newNode->fonttext, name, namePartLen);                   /* copy part name */
   return (FontTree *)memset(newNode, 0, sizeof(FontTreeHdr));      /* zeroise rest */
}

// -------------------------------------------------------------------------
static void AddFontToTree(FontTree *parentPtr, char *name, int level)
{
   /* search a level for the name, if not found add a node. */
   /* Recurse down if not the terminal part of the name.    */
   FontTree *node;
   FontTree *newNode = NULL;
   FontTree *lastBrotherNode = NULL;
   int namePartLen;
   char *backwardsFonts = (level == 1 ? GetRsrcOption('b') : NULL);

   namePartLen = strcspn(name, level == 3 ? "" : ".");
   node = (FontTree *)parentPtr->info.childPtr;

   while (node != NULL)
   {
      lastBrotherNode = node;
      if (strncmp(name, node->fonttext, namePartLen) == 0 &&
                                            node->fonttext[namePartLen] == '\0')
      {
        newNode = node;
        break;
      }
      /* names do not match, so try next brother */
      node = (FontTree *)node->info.brotherPtr;
   }
   if (newNode == NULL)
   {
     /* not found, so add a node on end of brother chain */
     newNode = AllocFontTreeNode(namePartLen, name);
     if (level > 1)
     {
#ifdef TeX
       // mark font with bold/italic flags
       int newBIbits = parentPtr->info.texFontIdx; /* TeX */

       if (bi__findstring(gFontBoldNames, newNode->fonttext) != 0)
         newBIbits |= 1;
       if (bi__findstring(gFontItalicNames, newNode->fonttext) != 0)
         newBIbits |= 2;
       newNode->info.texFontIdx = newBIbits;
#endif
       newNode->info.parentPtr = Ptr(parentPtr);           /* back to parent unless top */
     }
     else
     {
       // 28/06/94 See if a Backwards font
       while (backwardsFonts != NULL)
       {
         if (*backwardsFonts == ',')
           backwardsFonts++;
         if (strncmp(name, backwardsFonts, namePartLen) == 0)
         {
           newNode->info.backwards = kBackwards;
           break;
         }
         backwardsFonts = strchr(backwardsFonts, ',');
       }
     }
     if (lastBrotherNode != NULL)
       lastBrotherNode->info.brotherPtr = Ptr(newNode);    /* point last brother to this */
     else
       parentPtr->info.childPtr = Ptr(newNode);            /* point parent to it */
   }
   if (name[namePartLen] == '\0')
     newNode->info.terminal = TRUE;                        /* we have reached the end */
   else
     AddFontToTree(newNode, name + namePartLen + 1, level + 1); /* else match next level */
}

// -------------------------------------------------------------------------
void CheckInstalledFonts()
{
  char fntBuffer[514];
  int countFont;

  // check & reset setting of Font Manager paths
  countFont = 512;
  if (ReadExpression(fntBuffer, "<Font$Prefix> + <Font$Path>", &countFont) == 0)
  {
    fntBuffer[512] = 0;
    fntBuffer[countFont] = 0;
    if (gFontPath == NULL || strcmp(gFontPath, fntBuffer) != 0)
    {
      free(gFontPath);
      FailNIL(gFontPath = (char *)malloc(countFont + 1));
      strcpy(gFontPath, fntBuffer);
      countFont = 0;
      while (FailOSErr(wr_font_list(fntBuffer, &countFont)),
              countFont != -1)
      {
        AddFontToTree((FontTree *)&gFontHead, fntBuffer, 1);
      }
    }
  }
}


// -------------------------------------------------------------------------
int LookupID(IDType id, int *lookupTab)
{
  register int i;

  for (i = 0; lookupTab[i] != 0; i++)
    if (id == lookupTab[i])
      return i;
  return -1;
}

/*
// -------------------------------------------------------------------------
VHSelect LongerSide(Rect &r)
{
   return ((r.bottom - r.top) >= (r.left - r.right) ? v : h);
}
*/

// -------------------------------------------------------------------------
void RectSizeToPt(Rect &r, Point &aPt)
{
  SetPt(aPt, r.right - r.left, r.bottom - r.top);
}


/* -------------------------------------------------------------------------
void PinOnRect(const Rect &theRect, Point &thePt)
{
   if (thePt.h < theRect.left) thePt.h = theRect.left;
   if (thePt.h > theRect.right) thePt.h = theRect.right;
   if (thePt.v < theRect.top) thePt.v = theRect.top;
   if (thePt.v > theRect.bottom) thePt.v = theRect.bottom;
}
*/

// -------------------------------------------------------------------------
bool RectsNest(const Rect &outer, const Rect &inner)
{
  return(((inner.left >= outer.left) && (inner.right <= outer.right) &&
        (inner.top >= outer.top) && (inner.bottom <= outer.bottom)));
}


// -------------------------------------------------------------------------
void CenterRectOnScreen(Rect &aRect, bool horiz, bool vert, bool forDialog)
{
   Point rectSize;
   Point screenSize;

   SetPt(screenSize, ScreenWidth(), ScreenHeight() - GetIconBarHeight());
   RectSizeToPt(aRect, rectSize);

   if (horiz)
      aRect.left = (screenSize.h - rectSize.h) / 2;

   if (vert)
//    if (forDialog) case ignored
      aRect.top = (screenSize.v - rectSize.v) / 2;

   aRect.right = aRect.left + rectSize.h;
   aRect.bottom = aRect.top + rectSize.v;
}

/*
// -------------------------------------------------------------------------
wr_wimp_w FindWindowBefore(wr_wimp_w theWindow)
{
   wr_wimp_wstate wstate;

   wr_wimpt_noerr(wr_wimp_get_wind_state(theWindow, &wstate));
   return((wstate.o.behind == -1 ? NULL : wstate.o.behind));
}


// -------------------------------------------------------------------------
bool EqualBlocks(Ptr first, Ptr second, int theSize)
{
   return(memcmp(first, second, theSize) == 0);
}


// -------------------------------------------------------------------------
char UprChar(char ch)
{
   return(ch && 223);
}


// -------------------------------------------------------------------------
char LowerChar(char ch)
{
   return(ch || 32);
}


// -------------------------------------------------------------------------
void UprStr255(char *s)
{
   for (register int i = 0; i < strlen(s); i++)
      s[i] = UprChar(s[i]);
}


// -------------------------------------------------------------------------
void LowerStr255(char *s)
{
   for (register int i = 0; i < strlen(s); i++)
      s[i] = LowerChar(s[i]);
}
*/

/* -------------------------------------------------------------------------
IDType StrToID(char *idString)
{
//  return (((((idString[0] << 8) | idString[1]) << 8) | idString[2]) << 8) | idString[3];
  // 11/03/93 [20809] allow view ids with less than 4 characters
  int id = idString[0];

  for (int i = 1; idString[i] != 0; i++)
    id = (id << 8) | idString[i];
  return id;
}
*/

// -------------------------------------------------------------------------
char *TruncateText(char *newStr, char *oldStr, int newLen, TruncType truncMode)
// 16/12/94 new version for [23021] strips out text comments & returns ptr to last found
{
   int diff = -newLen;
   int ch;
   char *p;
   char *fe = NULL;
   char *endCh;

   for (p = oldStr; (ch = *(p++)) != 0; )
   {
      if (ch == 21)
      {
         fe = p;                          // return comment terminator
         for ( ; *(p++) >= 32; ) {}       // skip a comment
      }
      else 
         diff++;
   }
   endCh = newStr + newLen;
   if (diff < 0)
     endCh += diff;                // reduce to required length
   *endCh = 0;                     // mark terminator
   if (diff > 0)                   // will not fit
   {
      if (truncMode == dotLeft)
      {
         diff += 3;                // need to start 3 further in
         *(newStr++) = '.';
         *(newStr++) = '.';
         *(newStr++) = '.';
      }
      else if (truncMode == dotRight)
      {
         *(--endCh) = '.';
         *(--endCh) = '.';
         *(--endCh) = '.';         // add dots and move end back 3
      }
      if (truncMode > cutLeft)     // for dotRight or cutRight
         diff = 0;                 // start at beginning of source string
   }
   // ignoring start characters (and comments), copy newLen characters to output
   while (TRUE)
   {
      ch = *(oldStr++);
      if (ch == 21)
         for ( ; *(oldStr++) >= 32; ) {}     // skip to end of comment
      else
      {
         if (newStr >= endCh)
           return fe;
         diff--;
         if (diff < 0)
            *(newStr++) = ch;               // copy if past initial skipping
         
      }
   }
}

// *************************************************************************
// FILE MANAGEMENT ROUTINES
// *************************************************************************

wr_os_error *FSWrite(int file_handle, long nChars, void *buffer_ptr)
{
   if (file_handle != gRAMFile.fileHandle)
   {
      wr_os_gbpbstr GBPBblock;

#ifdef TRACE
      long file_position;

      GetFPos(file_handle, file_position);
#endif
      GBPBblock.action      = 2;         // specified ptr in block for writing
      GBPBblock.file_handle = file_handle;
      GBPBblock.data_addr   = buffer_ptr;
      GBPBblock.number      = nChars;

#ifdef OBS_CURS
      DeObscureCursor();   // 08/07/91 in case swap floppy alert comes up
#endif
      return wr_os_gbpb(&GBPBblock);    // write block from file into memory
   }
   if (gRAMFile.filePos + nChars > gRAMFile.eof)
   {
      gRAMFile.eof = gRAMFile.filePos + nChars;
      if (GetHandleSize(gRAMFile.contents) < gRAMFile.eof)
      {
         SetPermHandleSize(&gRAMFile.contents, gRAMFile.eof);
      }
   }
   memcpy(gRAMFile.contents + gRAMFile.filePos, buffer_ptr, nChars);
   gRAMFile.filePos += nChars;
   return NULL;
}


/**************************************************************************/
void SetFPos(int file_handle, int file_position)
{
   if (file_handle != gRAMFile.fileHandle)
   {
      wr_os_regset r;

      r.r[0] = 1;             // write open file seq file ptr
      r.r[1] = file_handle;
      r.r[2] = file_position;
      FailOSErr(wr_os_args(&r));
   }
   else
      gRAMFile.filePos = file_position;
}


/**************************************************************************/
void GetFPos(int file_handle, long &file_position)
{
   if (file_handle != gRAMFile.fileHandle)
   {
      wr_os_regset r;

      r.r[0] = 0;              // read open file seq file ptr
      r.r[1] = file_handle;
      FailOSErr(wr_os_args(&r));
      file_position = r.r[2];  // the sequential file position
   }
   else
      file_position = gRAMFile.filePos;
}


/**************************************************************************/
void SetEOF(int file_handle, long file_size)
{
   if (file_handle != gRAMFile.fileHandle)
   {
      wr_os_regset regs;

      regs.r[0] = 3;
      regs.r[1] = file_handle;
      regs.r[2] = file_size;
      FailOSErr(wr_os_args(&regs));
   }
   else
      gRAMFile.eof = file_size;
}


/**************************************************************************/
void GetEOF(int file_handle, long &file_size)
{
   if (file_handle != gRAMFile.fileHandle)
   {
      wr_os_regset regs;

      regs.r[0] = 2;
      regs.r[1] = file_handle;
      regs.r[2] = 0;
      FailOSErr(wr_os_args(&regs));
      file_size = regs.r[2];
   }
   else
      file_size = gRAMFile.eof;
}


/**************************************************************************/
wr_os_error *Create(char *name, int fileType, int fileSize)
{
   wr_os_filestr file;

   file.action = fileType == 0x1000 ? 8 : 11;   // 18/02/96 pass in x1000 for CDir
   file.name = name;
   file.loadaddr = fileType;  // this is NOT the load addr but the FILETYPE
   file.start = 0;
   file.end = fileSize;
   return(wr_os_file(&file));
}


// *************************************************************************
wr_os_error* Rename(char* prevName, char* newName)
{
   return(wr_os_swi3(wr_os_X | OS_FSControl, 25, (int) prevName, (int) newName));
}


// -------------------------------------------------------------------------
wr_os_error* MAOpenFile(char* name, int &dataRefNum, int access)
{
   wr_os_error  *err;
   wr_os_regset r;

   r.r[0] = access == kAccessReadWriteX ? kAccessReadWrite : access; // 18/02/93 [20704]
   r.r[1] = (int) name;
   err = wr_os_find(&r);
   dataRefNum = r.r[0];

   // 18/02/93 [20704] new access kAccessReadWriteX means RW if possible, RO if protected
   if (access == kAccessReadWriteX && err == NULL)
   {
     // read and write first 4 bytes of file, then force a failure if a protected disc
     char buffer[4];

     FRead(dataRefNum, 4, buffer);
     SetFPos(dataRefNum, 0);
     err = FSWrite(dataRefNum, 4, buffer);
     r.r[0] = 255;             // purge write buffer
     r.r[1] = dataRefNum;
     if (err == NULL)
       err = wr_os_args(&r);
     if (err != NULL)
     {
       CloseFile(dataRefNum);
       return MAOpenFile(name, dataRefNum, kAccessRead);  // try again with read access
     }
     SetFPos(dataRefNum, 0);
   }
   // 18/02/93 [20704] end
   return(err);
}


// ------------------------------------------------------------------------
void OpenAFile(char *name, int &dataRefnum)
{
// 18/02/93  FailOSErr(MAOpenFile(name, dataRefnum, kAccessReadWrite));
   OpenFile(name, dataRefnum, kAccessReadWrite);
}


// ------------------------------------------------------------------------
void OpenFile(char *name, int &dataRefnum, int access)
{
   FailOSErr(MAOpenFile(name, dataRefnum, access));
}


// -------------------------------------------------------------------------
wr_os_error *CloseFile(int dataRefNum)
{
   if (dataRefNum == kNoFileRefnum)
      return NULL;
   else
   {
      wr_os_regset r;

#ifdef TRACE
      Assert(dataRefNum, 24);
#endif

      r.r[0] = 0;
      r.r[1] = dataRefNum;
      return(wr_os_find(&r));
   }
}

// -------------------------------------------------------------------------
void FRead(int file_handle, long nChars, void *buffer_ptr)
{
  if (nChars != 0)
  {
     if (gRAMFile.fileHandle == file_handle)
     {
        memcpy(buffer_ptr, gRAMFile.contents + gRAMFile.filePos, nChars);
        gRAMFile.filePos += nChars;
     }
     else
     {
        wr_os_gbpbstr GBPBblock;

#ifdef TRACE
        if (nChars < 0)
        {
           wr_werr(FALSE, "%d characters to FSRead", nChars);
           return;
        }
#endif

        GBPBblock.action      = 4;         // specified ptr in block for reading
        GBPBblock.file_handle = file_handle;
        GBPBblock.data_addr   = buffer_ptr;
        GBPBblock.number      = nChars;

#ifdef OBS_CURS
        DeObscureCursor();   // 08/07/91 in case swap floppy alert comes up
#endif
        FailOSErr(wr_os_gbpb(&GBPBblock));      // read block from file into memory
     }
  }
}

// -------------------------------------------------------------------------
void FWrite(int file_handle, long nChars, void *buffer_ptr)
{
  if (nChars != 0)
    FailOSErr(FSWrite(file_handle, nChars, buffer_ptr));
}

// -------------------------------- TFileInfo --------------------------

void GetFileInfo(char* filename, TFileInfo &blk)
{
   blk.fInfo.action = 17;
   blk.fInfo.name   = filename;
   FailOSErr(wr_os_file(&blk.fInfo));
#ifdef TRACE
   if ((blk.fInfo.loadaddr & 0x000fff00) == 0x000fca00)
   {
     int refNum;
     wr_os_error *err = MAOpenFile(filename, refNum, kAccessRead);
     int tfile[4];

     FRead(refNum, 16, (char *)tfile);
     wr_wimpt_noerr(CloseFile(refNum));
     if (tfile[0] == 'HSQS')
     {
       blk.fInfo.loadaddr = tfile[2];
       blk.fInfo.execaddr = tfile[3];
       blk.fInfo.start = tfile[1];
     }
   }
#endif
}

void TFileInfo::CheckType()
{
   if (fInfo.action == 0)
      FailGeneral(18);           // == twErr18 == file not found
   else if (fInfo.action == 2)
      FailGeneral(19);           // == twErr19 == cant load a directory
}

int TFileInfo::GetFileSize()
{
   CheckType();
   return(fInfo.start);
}

void TFileInfo::FileModDate(char *t)
  // must be passed a string of 5 chars
{
   CheckType();
   if ((fInfo.loadaddr & 0x0fff00000) != 0x0fff00000)
      memset(t, 0, 5);
   else {
      memcpy(t, &fInfo.execaddr, 4);
      t[4] = (fInfo.loadaddr & 0x0ff);
   }
}

void SetFileStamp(char *name, char *stamp, int attr)
{
   TFileInfo blk;

   GetFileInfo(name, blk);
   memcpy(&blk.fInfo.execaddr, stamp, 4);
   blk.fInfo.loadaddr = (blk.fInfo.loadaddr & 0xffffff00) | stamp[4];
   blk.fInfo.action = 1;
// 06/09/91 disc may be locked:   FailOSErr(wr_os_file(&blk.fInfo));
   wr_os_file(&blk.fInfo);
}

// -------------------------------------------------------------------------
wr_os_error* DeleteFile(char* name)
{
   wr_os_filestr f;

   f.action = 6;
   f.name = name;
   return(wr_os_file(&f));
}

// *************************************************************************
// 10/11/92 rather faster and does a proper match at above leaf levels
static FontTree *DoLeafLevel(char* name, FontTree *ptr, int level)
{
  while (ptr != NULL)
  {
    char *dot;        // if matched, pointer to next '.' or 0; NULL if no match
    char *t;

    for (dot = name, t = ptr->fonttext; tolower(*dot) == tolower(*t); dot++, t++)
      if (*dot == '\0')
        return ptr;        // last part of name, but may not be a leaf node!!!

    // if level = 1 or 2, and matches up to a dot, go to next level
    if (level < 3 && *dot == '.' && *t == '\0')
      return DoLeafLevel(dot + 1, (FontTree *)ptr->info.childPtr, level + 1); // do next lev

    // we have not found the node yet so move on to its brother
    ptr = (FontTree *)ptr->info.brotherPtr;
  }
  return ptr;  // i.e. NULL
}

// -------------------------------------------------------------------------
// given a name, this routine finds the addr of its leaf node in the system font tree
FontTree *GetAddrOfLeafNode(char* name)
{
  return DoLeafLevel(name, (FontTree *)gFontHead.info.childPtr, 1);
}

// ------------------------------------------------------------------------
// 22/06/92 common up and speed up code for getting a font name
char *GenerateFontName(FontTree *ptr, char *buffer)
{
  FontTree *parentPtr;

  if ((parentPtr = (FontTree *)ptr->info.parentPtr) != NULL)
  {
    buffer = GenerateFontName(parentPtr, buffer);
    buffer[0] = '.';
    buffer++;
  }
  else
    gBackwardsFont = ptr->info.backwards & kBackwards;
  strcpy(buffer, ptr->fonttext);
  return buffer + strlen(ptr->fonttext);
}

// -------------------------------------------------------------------------
static void FindBestMatch(FontTree *ptr, int score, bool bold, bool italic)
{
  while (ptr != NULL)
  {
    int score1;

    if (bold || italic)
    {
      score1 = (bold ? bi__findstring(gFontBoldNames, ptr->fonttext) : 0);
      score1 += (italic ? bi__findstring(gFontItalicNames, ptr->fonttext) : 0);
      // no match against italic or bold, but give a good score if similar to chosen font
      for (FontTree *ptr1 = gOriginalName; score1 == 0 && ptr1->info.parentPtr;
                                              ptr1 = (FontTree *)ptr1->info.parentPtr)
        score1 = bi__findstring(ptr1->fonttext, ptr->fonttext);
    }
    else
    {
     // 17/06/96 credit a font with no bold or italic in it (when looking for non-bold/italic)
      score1 = bi__findstring(gFontBoldNames, ptr->fonttext) +
                 bi__findstring(gFontItalicNames, ptr->fonttext);
      score1 = (score1 > 0 ? 0 : 1);
    }


    if (ptr->info.terminal && score + score1 > gBestmatch)
    {
      gNewName = ptr;
      gBestmatch = score + score1;
    }
    FindBestMatch((FontTree *)ptr->info.childPtr, score + score1 - 20, bold, italic);
                                   // 22/11/93 [21128] - 20 to bias against nested names
    ptr = (FontTree *)ptr->info.brotherPtr;
  }
}

// -------------------------------------------------------------------------
int MAFont_SetCurrentFont(FontTree *ptr, PFontStyle fontStyle)
// char* fontName, int fontNum, int fontXSize, int fontYSize)
// 13/10/92 fontNum passed too for saving draw files
// 28/06/94 return backwards text flag
// NB: font sizes are actually in 1/16 ths of a point
{
  int fontXSize = fontStyle->fTextSizeX;
  int fontYSize = fontStyle->fTextSizeY;
  bool fontNameChanged = (ptr != gLastFontTreePtr ||
       (gLastFontStyle & (kBold | kItalic)) != (fontStyle->fTextFace & (kBold | kItalic)));

  if (fontNameChanged || gLastFontSizeX != fontXSize || gLastFontSizeY != fontYSize)
  {
    // the current font is changing so get rid of the previous one
    MAFont_ReleaseCurrentFont();

    gLastFontSizeX = fontXSize;
    gLastFontSizeY = fontYSize;
    // gLastFontStyle = fontStyle->fTextFace;
    if (fontNameChanged)
    {
      bool bold, italic;

      gLastFontTreePtr = ptr;        // 02/11/93 [21100] had stopped going down fast path
      bold = (fontStyle->fTextFace & kBold);
      italic = (fontStyle->fTextFace & kItalic);

#ifdef TRACE
      Assert(ptr != (FontTree *) -1 && ptr != NULL, 793);  // clause below unnecessary?
#endif
      if (ptr == (FontTree *) -1)
        ptr = GetAddrOfLeafNode(GetString(kDefaultFontMsg));  // use default font

      if (ptr->info.terminal == 2) // 19/04/96 it is a missing font (pointing up to default font)
        ptr = (FontTree *)ptr->info.parentPtr;
      gOriginalName = ptr;
      gNewName = ptr;
      gWordWrapTable = ((ptr->info.backwards & 1) == 0 ? gWordWrapTableLat1 : gWordWrapTableSymb);
      gBestmatch = 0;
      if (bold | italic | !ptr->info.terminal)   // 17/06/96 try to find 'Regular' if !terminal
      {
        // climb up to the font family name
        while (ptr->info.parentPtr)
          ptr = (FontTree *)ptr->info.parentPtr;
        // and find the best score amongst its children (if any)
        FindBestMatch((FontTree *)ptr->info.childPtr, 0, bold, italic);
      }
      gBackwardsFont = 0;
      GenerateFontName(gNewName, gLastFontName);    // 22/06/92 for next clause
      gBackwardsFontSet = gBackwardsFont;
    }

    if (FontFind(&gLastFontHandle, gLastFontName, fontXSize, fontYSize) != NULL)
    {
      strcpy(gLastFontName, GetString(kDefaultFontMsg));
      FailOSErr(FontFind(&gLastFontHandle, gLastFontName, fontXSize, fontYSize));
                                             // 29/05/91 recover if possible
      gBackwardsFontSet = 0;
    }
  }
  else // if (!gNewFontMgr)   // 31/07/95 for RISC_OS3, pass handle on wr_font_paint calls
  {
    FailOSErr(wr_font_setfont(gLastFontHandle));
  }
#ifdef TeX
  if (gSender)
    gSender->SetFont(gNewName, gLastFontHandle);  /* TeX */
         // gNewName points to actual terminal node (after applying bold & italic)
#endif
  gLastFontStyle = (fontStyle->fTextFace & ~kBackwards) | gBackwardsFontSet;
  return gBackwardsFontSet;
}


// -------------------------------------------------------------------------
void MAFont_ReleaseCurrentFont()
{
  int handle;

  // inline: ClearCurrentColour();  // 14/04/92
  gLastFontColour = -1;
  gLastFontColourOpt = -1;

  handle = gLastFontHandle;
  if (gLastFontHandle != -1)
  {
    gLastFontHandle = -1;
    gLastFontSizeX = -1;
    gLastFontSizeY = -1;
    FontLose(handle);      // FailOSErr(wr_font_lose(gLastFontHandle));
  }
}

// -------------------------------------------------------------------------
int GetTextDirection()
{
  // 28/06/94 return the direction of the last font selected
  return gBackwardsFontSet;
}

// -------------------------------------------------------------------------
//void TextFace(Style theStyle)
//{
//  gLastFontStyle = theStyle;  // 23/07/90 - set up the font style

//  if (gLastFontHandle != -1)
//    FailOSErr(wr_font_lose(gLastFontHandle));
//  DoSetCurrentFont(gLastFontName, gLastFontSizeX, gLastFontSizeY);
//}


// -------------------------------------------------------------------------
void ClearCurrentColour()
// 14/04/92 new
{
  gLastFontColour = -1;
  gLastFontColourOpt = -1;
}

// -------------------------------------------------------------------------
void TextColour(int theColour, bool drawing)
{
  if (theColour != gLastFontColour || drawing != gLastFontColourOpt) // 14/04/92 & 29/04/92
  {
    wr_os_regset r;
    wr_wimp_palettestr palette;

    gLastFontColour = theColour;
    gLastFontColourOpt = drawing;     // 30/06/92 'Opt' missing
    if (drawing)
    {
      wr_wimpt_noerr(wr_wimp_readpalette(&palette));

#ifdef TRACE
      Assert(thePort != NULL, 194);
#endif
      r.r[1] = palette.c[drawing >= 3 ? drawing : thePort->BackgroundCol()].word;

      // 21/05/91 frig to stop black on black when Invert-ed palette
      if (!gPrinting && theColour == 0)
        theColour = (palette.c + 7)->word;
    }
    else
      r.r[1] = 0xffffff00;                 // use white b/g if just measuring

    // need this be called at all if we are just measuring characters??

    r.r[0] = 0;                            // the current font
    r.r[2] = theColour;
    r.r[3] = (drawing == 2 ? 0 : 14);      // aliasRange

#define ColourTrans_SetFontColours 0x0004074f
    FailOSErr(wr_os_swix(ColourTrans_SetFontColours, &r)); // 02/11/93 do not need return values
  }
}

/*---------------------------------------------------------------------------*/

typedef struct
{ int wr_menu_size;        /* Number found on start up                        */
  int list_size;        /* Same or includes extra found from file fontlist */
  char *name[256];      /* Space for names                                 */
} fontcatstr;

extern void wr_note_fontcat(char *hdrptr);
extern bool wr_do_objects(char *hdrptr, char *limit, int orgx, int orgy,
                 wr_draw_box *clipBox, wr_draw_error *err);
extern fontcatstr *wr_fontcat;

#ifndef NETWP
// 14/10/92-05/11/92 the draw bottleneck for drawing Draw files
static bool render_diag(wr_draw_diag *diag, int orgx, int orgy, wr_draw_box *clipBox)
{
  bool       err;
  wr_draw_error error;
  int        vdu_status;
  fontcatstr stackCat;

  wr_fontcat = &stackCat; // 02/03/94 avoid malloc-ing 1K
  /* Render the objects via the level 1 interface */
  wr_note_fontcat(NULL);
  /* Draw the objects */
  vdu_status = wr_dr_setScreenState();
  Draw_memoryError = FALSE; /* Only relevant for text areas */
  /* Locate the objects */
  err = wr_do_objects(diag->data + sizeof(wr_draw_fileheader), diag->data + diag->length,
                                orgx, orgy, clipBox, &error);
  wr_dr_recoverScreenState(vdu_status);

  // 02/03/94 free(wr_fontcat);
  wr_fontcat = NULL;
  if (Draw_memoryError)
    return (FALSE);
  return (err);
}
#endif

#ifdef NETWP
// used in USaveDraw (though ideally should be removed)
double wr_dr_scalefactor_x;
double wr_dr_scalefactor_y;
#else
extern double wr_dr_scalefactor_x;
extern double wr_dr_scalefactor_y;
#endif
#define scaledown_x(A) ((int)((double)(A) / wr_dr_scalefactor_x))
#define scaledown_y(A) ((int)((double)(A) / wr_dr_scalefactor_y))
#define XDrawFile_Render 0x65540

/*---------------------------------------------------------------------------*/
// 29/05/95 Use DrawFile module if available
bool RenderDrawFile(wr_draw_diag *diag, int *matr, wr_draw_box *clipBox
#if SIDEBAR == 1
            , int avoidSWI
#endif
                          )
{
  if (gSender != NULL)
    return RenderDrawFile_bn(diag, matr, clipBox);

  if (
#if SIDEBAR == 1
       avoidSWI || 
#endif
        wr_os_swi6(XDrawFile_Render, 0, (int)diag->data,
         diag->length, (int)matr, (int)clipBox, 0) != NULL)
  {
#ifndef NETWP
    wr_dr_scalefactor_x = ((double)matr[0]) / ((double)0x10000);
    wr_dr_scalefactor_y = ((double)matr[3]) / ((double)0x10000);

    clipBox->x0 = scaledown_x((clipBox->x0 << 8) - matr[4]);
    clipBox->y0 = scaledown_y((clipBox->y0 << 8) - matr[5]);
    clipBox->x1 = scaledown_x((clipBox->x1 << 8) - matr[4]);
    clipBox->y1 = scaledown_y((clipBox->y1 << 8) - matr[5]);

    return render_diag(diag, matr[4], matr[5], clipBox);
#endif
  }
  return TRUE;
}

/*---------------------------------------------------------------------------
// 14/10/92 the draw bottleneck for drawing Draw files
bool RenderDiag(wr_draw_diag *diag, int orgx, int orgy, wr_draw_box *clipBox)
{
  if (gSender != NULL)
    return RenderDiag_bn(diag, orgx, orgy, clipBox);

  return render_diag(diag, orgx, orgy, clipBox);
}
*/

#ifdef MATHS
/*---------------------------------------------------------------------------*/
// 13/10/92 the draw bottleneck
wr_os_error *DrawFill(wr_drawmod_pathelemptr path_seq,
                       wr_drawmod_filltype fill_style,
                       wr_drawmod_transmat *matrix,
                       int colour)
{
  wr_os_regset r;
  // int newGcol;
  // wr_wimp_paletteword colwd;

  if (gSender != NULL)
#ifdef DRAWSAVE
    return DrawFill_bn(path_seq, fill_style, matrix, colour);
#else
    return NULL;   // 02/03/94 [21436] no fonts to declare
#endif
  // colwd.word = colour;
  r.r[0] = colour;        /* BBGGRRxx    */
  r.r[3] = 0;
  r.r[4] = 0;             /* GCol action (0) */
  wr_wimpt_noerr(wr_os_swix(0x40743 /*ColourTrans_SetGCOL*/, &r)) ;
  // wr_wimpt_noerr(colourtran_setGCOL(colwd, 0, 0, &newGcol));
  return wr_drawmod_fill(path_seq, fill_style, matrix, 0); // flatness);
}
#endif

/*---------------------------------------------------------------------------*/
wr_os_error *DrawStroke(wr_drawmod_pathelemptr path_seq, 
                         wr_drawmod_filltype fill_style,
                         wr_drawmod_transmat *matrix,
                         wr_drawmod_line *line_style)
{
  if (gSender != NULL)
#ifdef DRAWSAVE
    return DrawStroke_bn(path_seq, fill_style, matrix, line_style);
#else
    return NULL;   // 02/03/94 [21436] no fonts to declare
#endif
  return wr_drawmod_stroke(path_seq, fill_style, matrix, line_style);
}

#ifdef MATHS
/*---------------------------------------------------------------------------*/
int StartGroup(int groupSize)
{
#ifdef DRAWSAVE
  return (gSender == NULL ? 0 : StartGroup_bn(groupSize));
#else
  return 0;
#endif
}


/*---------------------------------------------------------------------------*/
int FinishGroup()
{
#ifdef DRAWSAVE
  return (gSender == NULL ? 0 : gSender->GetSpaceUsed());
#else
  return 0;
#endif
}
#endif


#define LARGEOFFSET 0x10000
// -------------------------------------------------------------------
int Pixel2Char(char* textBuf, int textLen, Fixed slop, int pixelWidth, int numOfSpaces, bool &leftSide, int &pixelPos)
{
  wr_os_regset r;
  int justBlock[9];
  char ch = textBuf[textLen];
  int *justP;
  int *coordP;
  wr_os_error *err;
  int SWInum;
  int retIdx;

  textBuf[textLen] = 0; // terminator byte
  leftSide = FALSE;     // 27/04/92 ??? eventually put in proper value ???
  r.r[1] = (int)textBuf;
  coordP = r.r + 2;
  if (gWimpVersion >= 316)
  {
    int flags = (pixelWidth == LARGEOFFSET ? 0 : (1 << 20) + (1 << 17));

    r.r[0] = 0;                         // the current font
    r.r[5] = (int)&justBlock;
    r.r[7] = textLen;
    *(coordP++) = (1 << 7) + (1 << 5) +
                   ((gLastFontStyle & (kKerning + kBackwards)) << 3) + flags;
    justP = (int *)memset(justBlock, 0, 36);
    justBlock[4] = -1;    // split char
    SWInum = 0xA1 /* Font_ScanString - 0x040000 */;
    retIdx = 7;
  }
  else
  {
    // textBuf[textLen] = 0; // terminator byte
    justP = r.r + 4;
    SWInum = 0x96; /*Font_FindCaretJ - 0x040000 */
    retIdx = 5;
  }
  *(justP++) = (numOfSpaces > 0 ? slop / (numOfSpaces * 10) : 0);
  *(justP++) = 0;
  *coordP = pixelWidth * 100;     // Deci to MilliPts
  *(coordP + 1) = 0;
  err = wr_os_swix(SWInum + 0x040000, &r);
  textBuf[textLen] = ch;          // restore buffer
  FailOSErr(err);
  pixelPos = FromFixed(*coordP * 10); // 27/07/92 MilliPts to Fixed to DeciPts
  return r.r[retIdx];
}


// -------------------------------------------------------------------
int Char2Pixel(char* textBuf, int textLen, Fixed slop, int offset,
                                    SignedByte direction, int numOfSpaces)
{
  bool leftSide;
  int pixelPos;

  Pixel2Char(textBuf, offset, slop, LARGEOFFSET, numOfSpaces, leftSide, pixelPos);
  return pixelPos;
}

// --------------------------------------------------------------------------
int FitText(char *charPtr, int itsNumChars, Fixed &itsWidth)
{
  wr_os_regset r;
  int SWInum;
  int rIdx;

  r.r[1] = (int)charPtr;
  if (gWimpVersion >= 316)
  {
    r.r[2] = (1 << 7) + /* (1 << 5) + */ ((gLastFontStyle & (kKerning + kBackwards)) << 3);
    r.r[7] = itsNumChars;
    rIdx = 3;
    SWInum = 0xA1 /* Font_ScanString - 0x040000 */;
  }
  else
  {
    // get the size of the font bounding box
    r.r[4] = -1;
    r.r[5] = itsNumChars;
    rIdx = 2;
    SWInum = 0x85;    // wr_font_StringWidth - 0x040000;
  }
  r.r[rIdx] = itsWidth / 10;              // DeciPts to MilliPts
  if (gBackwardsFontSet)
    r.r[rIdx] = -r.r[rIdx];
  r.r[rIdx + 1] = MAXLONGINT;
  if (r.r[rIdx] != 0)      // with backwards, a width of zero allows character to fit!
    FailOSErr(wr_os_swix(SWInum + 0x040000, &r));
  if (gBackwardsFontSet)
    r.r[rIdx] = -r.r[rIdx];
  itsWidth = r.r[rIdx] * 10;             // back to fixed deciPts
  return (char *)r.r[1] - charPtr;
}

#ifdef NEVER
// --------------------------------------------------------------------------
int FitText(char *charPtr, int itsNumChars, Fixed &itsWidth)
{
  if (gWimpVersion >= 316)
  {
    wr_os_regset r;
    //int justBlock[9];

    //memset(justBlock, 0, 36);
    //justBlock[4] = -1;
    //r.r[0] = 0;                         // the current font
    r.r[1] = (int)charPtr;
    r.r[2] = (1 << 7) + /* (1 << 5) + */ ((gLastFontStyle & (kKerning + kBackwards)) << 3);
    r.r[3] = itsWidth / 10;              // DeciPts to MilliPts
    if (gBackwardsFontSet)
      r.r[3] = -r.r[3];
    r.r[4] = MAXLONGINT;
    //r.r[5] = (int)justBlock;
    //r.r[6] = 0;
    r.r[7] = itsNumChars;
    if (itsWidth != 0)      // with backwards, a width of zero allows character to fit!
      FailOSErr(wr_os_swix(0x0400A1 /*Font_ScanString*/, &r));
    if (gBackwardsFontSet)
      r.r[3] = -r.r[3];
    itsWidth = r.r[3] * 10;             // back to fixed deciPts
    itsNumChars = (char *)r.r[1] - charPtr;
  }
  else
  {
    // get the size of the font bounding box
    wr_font_string fontString;

    fontString.s = charPtr;
    fontString.y = MAXLONGINT;
    fontString.split = -1;
    fontString.term = itsNumChars;
    fontString.x = itsWidth / 10;          // 27/07/92: Cvt Fixed DeciPoint -> MilliPoint...
    FailOSErr(wr_font_strwidth(&fontString));
    itsWidth = fontString.x * 10;          // 27/07/92: faster convert back
    itsNumChars = fontString.term;         // chars before the break
  }
  return itsNumChars;
}
#endif

/*---------------------------------------------------------------------------*/
// 13/10/92 the draw bottleneck for font painting
// 14/11/92 changed to pass QD coords
wr_os_error *PaintText(char *s, int options, int h, int v)
{
  Point topLt;
  int x, y;

  SetPt(topLt, h, v);
  thePort->LocalToGlobal(topLt);
  QDPttoOS(topLt, x, y, ScreenHeight());

  if (gSender != NULL)
  {
#ifdef DRAWSAVE
    return PaintText_bn(s, options, x, y);
#else
    gMasterList->AddToMasterList(gLastFontName);  // 02/03/94 [21436]
    return NULL;
#endif
  }
  if (gWimpVersion >= 316)
    options |= (gBackwardsFontSet << 3);    // set backwards
  return FontPaint(s, options | (gNewFontMgr << 8), x, y);
}

// -------------------------------------------------------------------
void DrawText(char* textBuf, int numChars, Rect &extent, Rect &rubOut,
     int ascent, int justify)  // justify now space extra when fully justified
{
  if (gBackwardsFontSet != 0)
  {
    int temp = extent.left;

    extent.left = extent.right;
    extent.right = temp;
  }
  if (gSender != NULL)
  {
#ifdef DRAWSAVE
    gSender->DrawText(numChars, extent, textBuf, ascent, justify);
    // DrawText_bn(textBuf, numChars, extent, rubOut, ascent, justify);
#else
    gMasterList->AddToMasterList(gLastFontName);  // 02/03/94 [21436]
#endif
  }
  else
  {
    wr_os_error *err;
    int options;
    char* bufferToUse;
    Point topLt;
    char ch;

    // 23/07/90 - if we have to create an underline or strikeout situation,
    // we need to embed 3 control chars into the start of the text. Therefore
    // create a new buffer if we have to and use it
    if (gLastFontStyle & (kUnderline | kStrikeOut) &&
      (bufferToUse = (char *)NewHandle(numChars + 4)) != NULL)
         // 27/07/92 rather than FailNIL, might as well carry on without underline
    {
      int under = gLastFontStyle & kUnderline;    // 1 for u/l, 0 for strikeout

      bufferToUse[0] = 25;
      bufferToUse[1] = gUnderlinePos[under];       // [23018] [23019] position
      bufferToUse[2] = gUnderlinePos[under + 2];   // [23018] [23019] line size
      memcpy(bufferToUse + 3, textBuf, numChars); // + 1);
      numChars += 3;
    }
    else
      bufferToUse = textBuf;

    options = 0;
    // 14/04/92 do not rub out if background already clear
    if (gInUpdate && SectRect(rubOut, *thePort->GetClipRect(), rubOut))  // 14/07/92
      options = wr_font_RUBOUT | (1 << 5);
    SetPt(topLt, extent.left, extent.top + ascent);
    thePort->LocalToGlobal(topLt);

    // make the string smaller so that less of it is painted if necessary
    ch = bufferToUse[numChars];
    bufferToUse[numChars] = 0;

    if (gNewFontMgr)
    {
      //wr_os_regset r;
      int justBlock[8];

      if (justify != 0)
        options |= (1 << 5);

      // r.r[0] = 0;                         // the current font
      // r.r[1] = (int)bufferToUse;
      // r.r[2] = options + // ??? (1 << 7) + (1 << 8) + 
      //              ((gLastFontStyle & (kKerning + kBackwards)) << 3);
      // r.r[3] = topLt.h * 100;
      // r.r[4] = (ScreenHeight() - topLt.v) * 100;
      // r.r[7] = numChars;
      if (options != 0)
      {
        Point tempPt;

        //r.r[5] = (int)&justBlock;
        justBlock[0] = justify; 
        justBlock[1] = justBlock[2] = justBlock[3] = 0;
        SetPt(tempPt, rubOut.left - GetVLineThickness(),
                    rubOut.bottom + GetHLineThickness());
                                        // 23/06/94 + GHLT leaving btm pixel trail
        thePort->LocalToGlobal(tempPt);
        justBlock[4] = tempPt.h * 100;
        justBlock[5] = (ScreenHeight() - tempPt.v) * 100;

        SetPt(tempPt, rubOut.right, rubOut.top);
        thePort->LocalToGlobal(tempPt);
        justBlock[6] = tempPt.h * 100;
        justBlock[7] = (ScreenHeight() - tempPt.v) * 100;
      }
      //err = wr_os_swix(0x040086 /* Font_Paint */, &r);
      err = FontPaintJust(bufferToUse,
            (options + ((gLastFontStyle & (kKerning + kBackwards)) << 3)) | (1 << 8),
            topLt.h * 100,
            (ScreenHeight() - topLt.v) * 100,
            justBlock);
    }
    else
    {
      int x, y;

      if (options != 0)         // do the rubout box positioning first
      {
        // 25/06/92 hopefully simpler
        MoveTo(rubOut.left, rubOut.bottom);
        MoveTo(rubOut.right, rubOut.top + GetHLineThickness());  // 20/07/92 + hline
        // allow adjacent views to avoid erasing each other!
        options = wr_font_RUBOUT;
      }

      if (justify)
      {
        // now do the justification extent
        MoveTo(extent.right, extent.top + ascent);
        options |= wr_font_JUSTIFY;
      }

      if (gWimpVersion >= 316)
        options |= ((gLastFontStyle & (kKerning + kBackwards)) << 3);

      QDPttoOS(topLt, x, y, ScreenHeight());

      err = FontPaint(bufferToUse, wr_font_OSCOORDS | options, x, y);
    }
    // restore ch back to normal afterwards
    bufferToUse[numChars] = ch;

    // 23/07/90 free the temporary buffer used on underline/strikeout
    if (bufferToUse != textBuf)
      DisposIfHandle(bufferToUse);

    FailOSErr(err);
  }
}

// -------------------------------------------------------------------
void FreeMasterList()
{
  ClearObject(gMasterList);
}


#define chEnd 1
// -------------------------------------------------------------------
static char gWordTable[32] = {
  '\000', '\000', '\000', '\000', '\001', '\004', '\377', '\300',
  '\177', '\377', '\377', '\343', '\377', '\377', '\377', '\342',
  '\146', '\000', '\100', '\063', '\200', '\302', '\010', '\000',
  '\377', '\377', '\377', '\377', '\377', '\377', '\376', '\377' };

/* 22/06/91 added © and ® - b21 from \200 */
/* 19/07/91 oe and fi, fl */
/* 23/09/91 added smart apostrophe */
/* 15/08/95 [26055] add Welsh Y and W */

// -------------------------------------------------------------------
// 22/05/90 - added wordwrap table stuff

bool InWordSyms(int c, BreakTable breaks)
{
#ifdef TRACE
  Assert(breaks == 0 || gWordWrapTable != NULL, 820);
#endif
  return ((breaks == 0 ? gWordTable : gWordWrapTable)[c >> 3] >> (7 - (c & 7))) & 1;
/*
                     (inWordTable[c >> 3] >> (7 - (c & 7))) & 1 :
                     (inWordWrapTable[c >> 3] >> (7 - (c & 7))) & 1);

  if (((c >= '0') && (c <= '9')) || ((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')) || 
     ((c >= 0x0c0) && (c <= 0x0ff) && (c != 0x0f7) && (c != 0x0d7)))
    {
    return TRUE;
    }
  else switch (c)
  {
  case 0x027: // '
  case 0x0b4: // ´
  case '^':
  case 0x060: // `
  case 0x0a8: // ¨
  case '~':
  case 0x0a0: // Non-breaking space
  case '_':
    return TRUE;
  }

  // breaks = 0 if clicked on, -1 if wordwrap. Therefore only include some
  // cases if wordwrap is off (eg include '-' in word if double-click on)
  if (breaks != 0)
  {
    switch (c)
    {
    case '!':
    case '"':
    case '(':
    case ')':
    case '-':
    case '/':
    case ':':
    case ';':
    case '?':
    case '[':
    case '\\':
    case ']':
    case '{':
    case '}':
    case '¡':
    case '¿':
          return TRUE;
    }
  }
  return FALSE;
  return returnVal;
*/
}

//static bool InStartSyms(int c)
//{
//  switch (c)
//  {
//  case '#':
//  case '$':
//  case '¥':
//  case '£': return TRUE;
//  }
//  return FALSE;
//}

//static bool InEndSyms(int c)
//{
//  switch (c)
//  {
//  // can do mac codes $A0 $A2 $AA
//  case 0x0ae: // reg ®
//  case 0x0a9: // copyright ©
//  case '%'  : return TRUE;
//  }
//  return FALSE;
//}

static int GetNextChar(char* textPtr, int charPos)
{
  return (charPos < 0 ? chEnd : textPtr[charPos]);   // 25/08/93 return 1, not 0 if off start
}

static bool Digit(char* textPtr, int charPos)
{
  return (isdigit(GetNextChar(textPtr, charPos)) != 0);  // 27/14/92 return 0 or 1
}


void FindWord(char* textPtr, int textLen, int offset, bool leftTable, BreakTable breaks, OffsetTable *offsets)
{
  int  c;
  bool done      = FALSE;
  bool number    = TRUE;
  bool isDecimal = FALSE;
  int  wordBegin;
  int  wordEnd;

  if (offset > 0 && textPtr[offset - 1] != ' ')
                       // 27/09/90 implement leftTable for macros
  // subtract 1 if leftTable == FALSE and the char before is not a space
  {
    offset += leftTable - 1;
  }

  wordBegin = offset;
  wordEnd   = offset - 1;
  do {
    wordEnd ++;
    c = (wordEnd < textLen ? GetNextChar(textPtr, wordEnd) : chEnd);   // 25/08/93 1 for 0
    if (InWordSyms(c, breaks))
    {
      number &= (isdigit(c) != 0);  // 14/07/92 can access off end: Digit(textPtr, wordEnd);
      if (!number && isDecimal)
      {
        done = TRUE;
        number = TRUE;
      }
    }
    else if (c == '%' || c == 0x0ae /* reg ® */ || c == 0x0a9 /* copyright © */) // InEndSyms(c))
    {
      done = TRUE;
    }
    else if (number && (c == gDecPoint[0] || c == gThousSep[0] || c == '/')) // 30/08/95 [26026]
    {
      // 27/04/92 have another go
      if (wordEnd + 1 >= textLen || !Digit(textPtr, wordEnd + 1))
                 // 14/07/92 instead of accessing off the end, treat as end of number
      {
        done = TRUE;
        wordEnd++;
      }
      isDecimal = TRUE;
/*   27/04/92 pick up single full stops as words
      {
        done = TRUE;
        number = FALSE;
      }
      else
        isDecimal = TRUE;
*/
    }
    else
    {
      done = TRUE;
      if (offset == wordEnd && (c == ' ' || breaks == NULL))
      {
        /* wordEnd ++; */
// 25/05/90        offsets[0] = wordBegin;
// 25/05/90        offsets[1] = wordEnd;
// 25/05/90        return;
        goto ExitFindWord; 
      }
    }
  } while (!done);

  done = FALSE;

  do {
    wordBegin --;
    c = GetNextChar(textPtr, wordBegin);
    if (InWordSyms(c, breaks))
    {
      number &= Digit(textPtr, wordBegin);
      if (!number && isDecimal)
      {
        done = TRUE;
        wordBegin ++;
      }
    }
    else if (c == '#' || c == '$' || c == '¥' || c == '£')    // InStartSyms(c))
      done = TRUE;
    else if (number && (c == gDecPoint[0] || c == gThousSep[0] || c == '/')) // 30/08/95 [26026]
    {
      if (!Digit(textPtr, wordBegin - 1) && c == gThousSep[0])
      {
        done = TRUE;
        wordBegin ++;
      }
      else
        isDecimal = TRUE;
    }
    else
    {
      done = TRUE;
      wordBegin ++;
    }
  } while (!done);

ExitFindWord:
  if (wordBegin == wordEnd)
    wordEnd ++;
  else if (breaks == NULL)   // 27/04/92 wrap needs to take over a leading quote
  // 21/02/92 knock off leading and trailing single quotes (normal & smart)
  {
    while (wordEnd - 1 > offset &&
            (c = GetNextChar(textPtr, wordEnd - 1), c == 39 || c == 145))
      wordEnd--;
    while (wordBegin < offset &&
           (c = GetNextChar(textPtr, wordBegin), c == 39 || c == 144)) // 27/04/92 145 wrong?
      wordBegin++;
  }
  
  offsets->offFirst = wordBegin;
  offsets->offSecond = wordEnd;
}


// ------------------------------------------------------------------------
char *GetLangName(int country)
{
  return GetRsrc(country, 'y');
}


// ------------------------------------------------------------------------
bool GetCountryName(int country, char *name)
// name must be kMaxLangNameLen + 1 chars long
{
  wr_os_regset r;
  char *strPtr;

  r.r[0] = 0;
  r.r[1] = 0x43;
  r.r[2] = 2;                      // convert number to name
  r.r[3] = country;
  r.r[4] = (int)name;
  r.r[5] = kMaxLangNameLen;
  wr_wimpt_noerr(wr_os_swix(OS_ServiceCall, &r));
  name[r.r[5]] = 0;

  // 19/11/91 test for override anyway, rather than in found path
  // do not find Default, Master or Compact, Esperanto or Canadas
  strPtr = GetLangName(country);
  if (strPtr != NULL)               // there is an overriding value
  {
    if (strPtr[0] == 0)               // if empty, do not find it
      return FALSE;
    if (r.r[1] == 0x43)             // else override if no driver name found
      strcpy(name, strPtr);
    return TRUE;                    // name is set up
  }
  return (r.r[1] != 0x43);
}

// ------------------------------------------------------------------------
int GetCountryNumber(char *countryName)
{
  wr_os_regset r;

  r.r[0] = 0;
  r.r[1] = 0x43;
  r.r[2] = 0;                      // convert name to number
  r.r[3] = (int)countryName;
  r.r[4] = 0;
  wr_wimpt_noerr(wr_os_swix(OS_ServiceCall, &r));
  if (r.r[4] == 0)
    for (int i = 1; i < 100; i++)
    {
      char *resName = GetLangName(i);
      if (resName != NULL && strcmp(resName, countryName) == 0)
        return i;
    }
  return r.r[4];
}

// ------------------------------------------------------------------------
int GetDefaultCountry()
{
  return _kernel_osbyte(70, 127, 0);
}

// -------------------------------------------------------------------------
void Synchronize()
{
   int x = 0, y = 255;
   int ticks;

   wr_os_byte(176, &x, &y);
   ticks = x;
   do
   {
      wr_os_byte(176, &x, &y);
   }
   while (ticks == x);
//   long ticks = TickCount();

//   do {} while (TickCount() == ticks);
}

// -------------------------------------------------------------------------
int PackRecord(unsigned int flags, char *map, void *inRec, char *outRec)
{
  // outRec to be put in packed format
  char *start = outRec;
  int fieldLen;

//  for (int i = 0 ; (fieldLen = map[i]) != 0; i++)
  for ( ; flags != 0; flags >>= 1)
  {
    fieldLen = *(map++);
//    if ((flags >> i) & 1)
    if (flags & 1)
      for (char *p = (char *)inRec; p < (char *)inRec + fieldLen; )
        *(outRec++) = *(p++);
//    outRec = ((char *)memcpy(outRec, inRec, fieldLen)) + fieldLen;

    inRec = ((char *)inRec) + fieldLen;
  }
  return (outRec - start);
}

// -------------------------------------------------------------------------
void UnpackRecord(unsigned int flags, char *map, char *inRec,
                                              void *matchRec, void *outRec)
{
  // inRec is in packed format
  // if matchRec non NULL, it is merged into empty fields
  int fieldLen;

  for (int i = 0 ; (fieldLen = map[i]) != 0; i++)
  {
    if ((flags >> i) & 1)
    {
      outRec = memcpy(outRec, inRec, fieldLen);
      inRec += fieldLen;
    }
    else if (matchRec != NULL)
      outRec = memcpy(outRec, matchRec, fieldLen);

    outRec = (char *)outRec + fieldLen;

    if (matchRec)
      matchRec = (char *)matchRec + fieldLen;
  }
}

// -------------------------------------------------------------------------
int SumRecord(unsigned int flags, char *map)
{
  int total = 0;

//  for (int i = 0 ; flags != 0; flags >>= 1, i++)
  for ( ; flags != 0; flags >>= 1)
  {
    int fieldLen = *(map++);

    if ((flags & 1) != 0)
//      total += map[i];
      total += fieldLen;
  }

  return total;
}

// -------------------------------------------------------------------------
unsigned int FindMask(char *record1, char *record2, char *map, unsigned int mask)
{
  // clear the bits if fields match
  int segLen;
  unsigned int f = 1;

  for (int i = 0; (segLen = map[i]) != 0; i++, f <<= 1)
  {
    if ((mask & f) != 0 && memcmp(record1, record2, segLen) == 0)
      mask &= ~f;
    record1 += segLen;
    record2 += segLen;
  }
  return mask;
}

// ------------------------------------------------------------------------
// 12/01/95 Senders split into Sender (which builds up the buffer) and
// Dispatcher (which sends the buffer to File, RAM or nowhere). As we do
// not have multiple inheritance this allows the sender part and output
// part to be separately overridden (eg. TeX to RAM, Text to file), in
// any combination.

// ------------------------------------------------------------------------
void _TDispatcher::WriteBuffer(int bufferUsed, char *buffer)
{
   // null dispatcher does nothing
}

// ------------------------------------------------------------------------
void _TDispatcher::Flush()
{
}

#if DEMO == 0
// -------------------------------------------------------------------------
static bool wr_sendbuf__unknowns(wr_wimp_eventstr *e, TRamDispatcher self)
{
   if ((e->e == wr_wimp_ESENDWANTACK || e->e == wr_wimp_ESEND) &&
       e->data.msg.hdr.your_ref == self->fMsgMyRef &&
       e->data.msg.hdr.action == wr_wimp_MRAMFETCH)
   {
      /* Prepare fields as the next RAMTRANSMIT. Most of the fields are already set up. */
      self->fState = 1;
      self->fMsgYourRef = e->data.msg.hdr.my_ref;
      self->fMsgSendAddr = e->data.msg.data.ramfetch.addr;
      self->fMsgNumBytes = 0;

      self->fReceiverBuffSize = e->data.msg.data.ramfetch.nbytes;
      return TRUE;      /* We've had another RAMFETCH: off we go again */
   }

   if (e->e == wr_wimp_EACK && e->data.msg.hdr.my_ref == self->fMsgMyRef)
   {
      self->fState = 2;
      return TRUE;      /* our message bounced back; give up */
   }
   return FALSE;    /* we don't want it here */
}

// ------------------------------------------------------------------------
_TRamDispatcher::_TRamDispatcher(wr_wimp_eventstr *e) : ()
{
#ifndef ZERO_OBJ
  fMsgTask = 0;   // filled in by wimp
#endif
  fReceiver = e->data.msg.hdr.task;   // task to send message back to and transfer data to

  /* Prepare the reply record. */
  fMsgMyRef = e->data.msg.hdr.your_ref;
  fMsgSize = 28;
  fMsgAction = wr_wimp_MRAMTRANSMIT;
  wr_sendbuf__unknowns(e, this);
}

// ------------------------------------------------------------------------
void _TRamDispatcher::Flush()
{
   /* See sendbuf for all the real work for this case... */
   /* We may have transferred some data but not yet told the
   other end about it. xfersend__msg contains a final RAMTRANSMIT,
   which does not quite fill his buffer (or we'd have sent it already)
   thus signalling to him that the transfer is over. */

   SendTransmit(wr_wimp_ESEND);
}

static int gDynamicBuffer[7];    // move out of dynamic area because of bug in RISC_OS
// -------------------------------------------------------------------------
void _TRamDispatcher::SendTransmit(wr_wimp_etype type)
{
   wr_wimpt_noerr(wr_wimp_sendmessage(
     type,
     (wr_wimp_msgstr *)memcpy(gDynamicBuffer, &fMsgSize, 28),
     fReceiver));
   fMsgMyRef = gDynamicBuffer[2];  // reset updated my_ref of message
}

// ------------------------------------------------------------------------
void _TRamDispatcher::WriteBuffer(int bufferUsed, char *buffer)
{
  int pos = 0; // position in our buffer

  do
  {
    int amtToSend = Min(fReceiverBuffSize - fMsgNumBytes, bufferUsed - pos);

    /* Make the data transfer */
    wr_wimpt_noerr(wr_wimp_transferblock(
        wr_wimpt_task(),
        buffer + pos,
        fReceiver,
        fMsgSendAddr + fMsgNumBytes,
        amtToSend));
    
    /* update bytes to be sent to the other end */
    fMsgNumBytes += amtToSend;

    if (fReceiverBuffSize <= fMsgNumBytes)    // min above ensures never < than
    {
      /* we have filled the other end's buffer, so tell him that you've done it */
      SendTransmit(wr_wimp_ESENDWANTACK);

      /* Get his reply. Poll and despatch events until get nack or message */
      fState = 0;

      wr_win_add_unknown_event_processor(wr_sendbuf__unknowns, this);

      do { wr_event_process(); }
        while (fState == 0);

      wr_win_remove_unknown_event_processor(wr_sendbuf__unknowns, this);

      if (fState == 2)
        FailNoFail();  // finished - transfer broken
      // N.B. fReceiverBuffSize may be changed above and fMsgNumBytes is now zero
    }
    pos += amtToSend;
  }
  while (pos < bufferUsed);  // keep going until whole of our buffer transferred
}

// ------------------------------------------------------------------------
_TDiscDispatcher::_TDiscDispatcher(int refNum) : ()
{
   fRefNum = refNum;
}

// ------------------------------------------------------------------------
void _TDiscDispatcher::WriteBuffer(int bufferUsed, char *buffer)
{
   FWrite(fRefNum, bufferUsed, buffer);
}
#endif

// ------------------------------------------------------------------------
// 31/07/92 new objects for sending alien data to the ouside world
_TSender::_TSender(char *buffer, TDispatcher dispatcher, int fileType) : ()
{
  char *thisOpt;

// 28/02/94 using our heap used to fail on RISCOS2, using a large lump in malloc
// is liable to cause an extension into the heap, so try allocating an on-stack
// buffer which is passed as parameter
#ifndef ZERO_OBJ
  fBufferUsed = 0;
  fSpaceRequired = 0;
#endif
  fBuffer = buffer;            // 28/02/94
  fFileType = fileType;
  fDispatcher = dispatcher;
#ifdef PRO
  thisOpt = GetRsrcOption('e');
  fParaBreak = (thisOpt ? *thisOpt : '0');
  thisOpt = GetRsrcOption('k');
  fLineBreak = (thisOpt ? *thisOpt : '1');
#endif
}

// ------------------------------------------------------------------------
void _TSender::Free()
{
  if (this == gSender)
    gSender = NULL;      // 13/10/92
  FreeIfObject(fDispatcher);
  _TObject::Free();
}

// ------------------------------------------------------------------------
void _TSender::Flush()
{
  if (fBufferUsed > 0)
    WriteBuffer();       // flush out the buffer
  if (fDispatcher)
    fDispatcher->Flush(); // complete RAM protocol if necessary
}

// ------------------------------------------------------------------------
void _TSender::WriteBuffer()
{
  int bufferUsed = fBufferUsed;

  fSpaceRequired += bufferUsed;
  fBufferUsed = 0;
  if (fDispatcher)
    fDispatcher->WriteBuffer(bufferUsed, fBuffer);
}

// ------------------------------------------------------------------------
void _TSender::SendData(int amount)
{
  // on entry we can assume at least 1 byte free
  fBufferUsed += amount;
  if (fBufferUsed >= kStdSenderBuffer)
    WriteBuffer();
}

#ifdef PRO
// ------------------------------------------------------------------------
void _TSender::SendABreak(int opt)
{
  switch (opt)
  {
    case '2':
      _TSender::SendChar(chLineFeed);
    case '1':
      SendChar(chReturn);
      return;
    case '3':
      _TSender::SendChar(chReturn);
  }
  SendChar(chLineFeed);
}
#endif

// ------------------------------------------------------------------------
void _TSender::SendParaBreak()
{
#ifdef PRO
  int opt = fParaBreak;

  if (opt >= '4')
  {
    opt -= 4;
    SendABreak(opt);
  }
  SendABreak(opt);
#else
  SendChar(chLineFeed);
#endif
}

// ------------------------------------------------------------------------
void _TSender::SendLineBreak()
{
#ifdef PRO
  SendABreak(fLineBreak);
#else
  SendChar(chReturn);
#endif
}

// ------------------------------------------------------------------------
void _TSender::SendChar(int ch)
{
  // on entry we can assume at least 1 byte free
  fBuffer[fBufferUsed] = ch;
  SendData(1);
}

// ------------------------------------------------------------------------
void _TSender::SendString(char *data, int dataLen)
{
  // on entry we can assume at least 1 byte free
  while (dataLen > 0)
  {
    int dataToMove = Min(dataLen, kStdSenderBuffer - fBufferUsed);

    memcpy(fBuffer + fBufferUsed, data, dataToMove);
    data += dataToMove;
    dataLen -= dataToMove;
    SendData(dataToMove);
  }
}

// ------------------------------------------------------------------------
void _TSender::SendCString(char *data)
{
  for (char *p = data; *(p++); );
  SendString(data, p - data - 1);
}

// ------------------------------------------------------------------------
void _TSender::SendTex(char *data)
{
#ifdef TeX
  SendTexPlus(data, 0x80000000);
#endif
}

// ------------------------------------------------------------------------
int _TSender::GetSpaceUsed()
{
  return fSpaceRequired + fBufferUsed;
}

#ifdef TRACE
// ------------------------------------------------------------------------
int _TSender::StyleChange(int currency)
{
  return 0;
}

#ifdef TeX
// ------------------------------------------------------------------------
void _TSender::SendTexPlus(char *data, int plus)
{
  // overridden by the Tex sender - otherwise nothing output
}

// ------------------------------------------------------------------------
void _TSender::SetFont(FontTree *ptr, int fontHandle)
{
  /* TeX */ // overridden by TeX sender
}
#endif
#endif
