/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>

#include "swis.h"
#include "akbd.h"
#include "wimpt.h"
#include "win.h"
#include "event.h"
#include "font.h"
#include "dboxfile.h"
#include "dbox.h"

#include "PackTempl.h"
#include "Support.h"

extern bool app_HandleEvent(wr_wimp_eventstr *e, void *handle);

#define kLoadFileMsg    8
#define kToBeOpened 8
#define cShowHideButtons 816

const kMaxTitleLength = 80;
const stdHScreen = 1280;
const stdVScreen = 1024;

static int gLastClickTime = 0;
static int gLastClickPosX;
static int gLastClickPosY;
static int gClickCount;
static int gUnprocessedKey;
static bool gStuffedChar;
static bool gCommandKey;
static int gStdStaggerCount = 0;

#ifdef TABLES
static int gLastSmartCh = 0;
static int gLastSavedCh = 0;
#endif

// *************************************************************************
void CancelDoubleClick()
{
   gLastClickTime = 0;
}

// *************************************************************************
// 05/06/91 routine for converting between Acorn and text handler codes
// returns TRUE if command key
static int ConvertKeys(int chcode)
{
   // bool commandKey;

   gCommandKey = FALSE;

   // deal with common keys first
   if (chcode >= 32 && chcode <= 255)
   {
#ifdef TABLES
      // 03/07/95 [26023] new block to set up smart quote handling
      if (gSmartQuote)
      {
         char *p = strchr(gSmartChars, chcode);

         if (p != NULL)    // it is a smart quote char
         {
            char *subs = gSmartSubs[p - gSmartChars];

            if (chcode != gLastSmartCh ||
                       (gKeyTick != 0 && abs(TickCount() - gKeyTick) > gSmartQuoteDelay))
                               // gKeyTick will be set if been through an idle since last key
                gLastSavedCh = 0;       // the first one!
            else
            {
               gLastSavedCh++;
               if (subs[gLastSavedCh] == 0)
                  gLastSavedCh = 0;      // cycle index to start
               chcode += 0x200;        // do a replace in textedit
            }
            chcode += (subs[gLastSavedCh] << 16);
            gKeyTick = 0;              // reset to start 'timing'
         }
      }
      gLastSmartCh = chcode & 0xff;
#endif
      if (chcode == 0x07f)
#ifdef NETWP
         chcode = chFwdDelete;
#else
         chcode = chBackspace;
#endif
      return chcode;
   }
#ifdef TABLES
   gLastSmartCh = chcode;
#endif

   if (chcode == chBackspace)
      return chcode;

   if (chcode == chReturn)  // 16/12/92 when picture is target, handle Shift Return properly
   {
      if (wr_akbd_pollsh())
         chcode = chLineFeed;
      return chcode;
   }
#ifdef NETWP
   if (chcode == 30)      // HOME key
      return 0x1af;       // Move cursor to start
#endif

   // commandKey = TRUE;

   if (chcode >= 0x0180)
   {
     if (chcode <= 0x01bf)
     {
        int lastDigit = (chcode & 0x0f);

        if (lastDigit == 0x0a)          // tab key
        {
           return chTab;
           // commandKey = FALSE;
        }
        else if (lastDigit == 0x0b)     // 18/05/91 Copy key
        {
#ifdef NETWP
           return 0x1ae;
#else
           return chFwdDelete;
#endif
           // commandKey = FALSE;
        }
        else if (chcode == chCaseSwap && WindowBorder())
          return chcode;              // 22/06/92 f7 for case
          // commandKey = FALSE;
#if TALK != 0
        else if (chcode == chSpeak
#if TALK == 2
            && Speaking() >= 0
#endif
                               )
          return chcode;              // 12/02/93 [20700] f6 for speech
          // commandKey = FALSE;
#endif
        else if (lastDigit >= 0x0c && chcode < 0x1b0 && chcode != 0x19e && chcode != 0x19f)
          return chcode;              // various arrow keys
          // commandKey = FALSE;
     }
     else if (chcode <= 0x1c9)
     {
       // 16/09/96 [27086] 1c0, 1c1, 1c6 used by IR handset
       if (chcode == 0x1c6)  // toolbar button -> F12
         chcode = 0x1cc;
       else
       {
         if (chcode == 0x1c8)
           chcode = 0x10;   // map IR Print button to ^P
         else
           chcode = chcode - 0x1c0 + 0x181; // 1c0 -> F1 (Help); 1c1 -> F2 (Menu)
       }
     }
#ifdef NEVER
     // 16/01/94 [21342] Style Guide has this as same as Paste
     else if ((chcode & 0xffffffcf) == 0x1cd)     // 18/05/91 Insert key
     {
        chcode = chInsert;
        commandKey = FALSE;
     }
#endif
   }
   gCommandKey = TRUE;  // commandKey;
   return chcode;
}


// *************************************************************************
// 05/06/91 routines for managing buffered characters
static int GetUnprocessedKey()
{
  return (gStuffedChar ? gUnprocessedKey : -1);
}


// *************************************************************************
static int GetNextKey(int convert)
{
  int keyVal;

  if (!gStuffedChar && wr_akbd_pollkey(&gUnprocessedKey) != 1)
  {
    gStuffedChar = FALSE;
    return -1;
  }
  gStuffedChar = TRUE;

  // convert key values to ones text handler expects
  keyVal = gUnprocessedKey;

  // if convert is FALSE, this call only tests to see if key present, so do not convert
  if (convert)
    keyVal = ConvertKeys(keyVal);
  return keyVal;
}


// *************************************************************************
void UndoGetNextKey()
{
  gStuffedChar = TRUE;      // caller of TestNextKey, etc did not want key
}


// *************************************************************************
bool TestNextKey(int theKey)
{
  int theNext = GetNextKey(TRUE);

  if (theKey != theNext)
    return FALSE;
  gStuffedChar = FALSE;
  return TRUE;
}


// *************************************************************************
bool TestNextKeyNonCntrl(int *theChar)
{
  *theChar = GetNextKey(TRUE);

  if (*theChar < 0x020 || (*theChar > 0x0ff && *theChar < 0x200)) // 0x7f will have been converted
    return FALSE;

  gStuffedChar = FALSE;
  return TRUE;
}


// *************************************************************************
// the inner core to handle the event

bool wind_HandleEvent(wr_wimp_eventstr *e, void *handle)
{
  EventInfo info;
  TCommand  commandToPerform;
  FailInfo fi;
  TWindow window;
  int nextChar;

  TWindow(handle)->fHasScrolled = FALSE;
  TWindow(handle)->Focus();     // 04/06/91 move out of loop

  gStuffedChar = FALSE;
  info.fDeleteWindow = FALSE;    // 22/02/94 [21414]

  do
  {
    CatchFailures(&fi);

    gApplication->PreHandleEvent(e);

    app_GetEventInfo(&info, e);
    if (TWindow(handle)->fNoMenuSetup == 0)
      info.affectsMenus = FALSE;         // 12/05/91 value switched

    // call the main case structure
    commandToPerform = TWindow(handle)->HandleEvent(info);  

    gApplication->PerformCommand(commandToPerform);

    window = TWindow(info.fDeleteWindow ? NULL : handle);
    gApplication->PostHandleEvent(window, info);
    Success(&fi);

    // 24/04/91 do not allow redraw events while keys outstanding
    // 12/05/91 unless scroll draw required
    if (window != NULL && e->e == wr_wimp_EKEY)
    {
      if (window->fHasScrolled)
        nextChar = GetUnprocessedKey();  // do not get any more from kb buff
      else
        nextChar = GetNextKey(FALSE);
    }
    else
    {
#ifdef TABLES
      if (e->e > wr_wimp_EREDRAW)
        gLastSmartCh = 0;  // suppress smart quote test if non-key, non-idle, non-redraw event 
#endif
      nextChar = -1;
    }
  }
  while (nextChar >= 0 &&
        (gStuffedChar = FALSE, e->data.key.chcode = gUnprocessedKey, TRUE));

  if (window != NULL)
    window->InvalSavedArea();        // 05/05/92 experiment to avoid having to wait for idle
#if TALK == 1
  else
    FailNoFail();
#endif
  return info.eventHandled;

Rescue:
  if (!info.fDeleteWindow)
    MarkDamagedDoc(&fi, TWindow(handle)->fDocument);  // 22/02/94 [21414]
  // undo nasties before returning to wimp

  // 24/04/95 return 
       DoRescue(fi); // 11/05/92 confuses dbox stack in raw handler: ContinueFailure(&fi);
  return TRUE;    // 24/04/95 if it failed once, better be done with it than repeat?
}


// *************************************************************************
_TWindow::_TWindow(TDocument itsDocument, TView itsSuperView, char * &params)
                          : (itsDocument, itsSuperView, params)
{
  int flags;
  wr_wimp_wind *window;
  bool forcePosition;
#if SIDEBAR == 1 || defined NETWP
  char nameBuffer[16];
#endif
#if SIDEBAR == 1
  char *vOption;
  char *iOption;
#endif
  FailInfo fi;

  // get pointer to the data from its handle, and write the fields
  // read window specific initialisation parameters
#if SIDEBAR == 1
  vOption = GetRsrcOption('v');
  vOption = (vOption && *vOption != '-' ? "V" : "");
  iOption = GetRsrcOption('i');
#endif
#if SIDEBAR == 1 || defined NETWP
  ReadString(params, nameBuffer);
  sprintf(fTemplateName, nameBuffer,
#ifdef NETWP
            (IsTV() ? "TV" : ""));
#else
            iOption && *iOption != '-' ? iOption : "", vOption);
  if (*vOption && strcmp(fTemplateName, nameBuffer) != 0)
    fSizeDeterminer = ((0x0b & 0x0c) << 2) + (0x0b & 0x03) + kToBeOpened;
#endif
#else
  ReadString(params, fTemplateName);
#endif
  fTargetID = ReadID(params);
  flags = ReadHex(params);

#ifndef ZERO_OBJ
  fTitle = NULL;
  fDbox = NULL;      // set up and managed only if this is a dialogue
  fMenuData = NULL;
  fScroller = NULL;
  ClearRect(fAreaToInvalidate);
  fLocation.v = 0;
  fLocation.h = 0;
  fSize.v = 0;
  fSize.h = 0;
#endif
  fWindowRecord.SetHandle(kNoWindow);   // in case of failure
  fShown = FALSE;

  CatchFailures(&fi);

  FailNIL(fDbox = wr_dbox_find_template(fTemplateName));
  window = wr_dbox_wind((dbox)fDbox);

#ifdef NETWP
  if (!WindowBorder() && fTemplateName[0] != '!')
  {
    window->flags &= 0x80ffffff;
  }
#endif
  forcePosition = FALSE;  // if we do not set it, dbox will place near mouse
  fWindowRecord.SetUp(window, (int) this);
  //  if (flags.transBgrnd)
  //    window->colours[wr_wimp_WCWKAREABACK] = 255;   // 20/06/90 make transparent
  if (gWimpVersion < 316)
    window->spritearea = (int *)1;          // 01/10/93 [21057] retain for RISC_OS2
                                            // 11/02/94 [21395] and RISC_OS3.00
  // 31/05/92 [20806] do not overwrite for 3D
  // if (/* 15/06/92 flags.sysSprites && */ !g3Dicons)
  //   window->spritearea = (int *)1;                     // 30/11/90 for Acorn
#ifdef NETWP
  if (strchr(nameBuffer, '%') != NULL)
    window->spritearea = (int *)HasPointer();  // Set pointer to Tile_1 for current monitor type
#endif

  fTarget = this;
  // fTargetID = StrToID(targetID);

  // frig to copy over flags; relies on order of fields being fixed
  memcpy(&fScroller + 1, &flags, sizeof(WindowTemplate));
  // fToBeOpened = fBeOpened;
  SetToBeOpened(fBeOpened);

  InstallDocument(itsDocument);

  // 09/09/91 moved here so done for dialogues too
  if ((window->titleflags & wr_wimp_INDIRECT) != 0)
  {
    fTitle = (char *)NewCheckedHandle(kMaxTitleLength + 1);
    fTitle = strcpyn(fTitle, window->title.indirecttext.buffer, kMaxTitleLength);
    window->title.indirecttext.buffer = fTitle;
  }

  Success(&fi);

#ifdef NETWP
  if (fFrameless)
  {
    if (!WindowBorder())
      window->colours[0] = 255;
  }
#endif

  DoResize();
  ComputeSize(fSize);
  Resize(fSize.h, fSize.v, kDontRedraw);  // waste of time???

  if (fAdapted)
  {
    forcePosition = TRUE;
    AdaptToScreen();
  }
  if (fHorzCentered || fVertCentered)
  {
    forcePosition = TRUE;
    Center(fHorzCentered, fVertCentered, fIsModal);
  }
  if (fVertStagger != 0 || fHorzStagger != 0)
  {
    forcePosition = TRUE;
    SimpleStagger(OStoQD(fHorzStagger), OStoQD(fVertStagger), gStdStaggerCount);
  }

  if (fTemplateName[0] != '!')
  {
#ifdef NETWP
    // force window to be opened in safe area
    wr_wimp_eventstr *e = wr_wimpt_last_event();

    if (e->e == wr_wimp_ESEND && e->data.msg.hdr.action == wr_wimp_MMENUWARN) 
    {
       e->data.msg.data.words[1] = Min(e->data.msg.data.words[1],
                 (gSafeArea.right >> 2) - window->box.x1 + window->box.x0);
       e->data.msg.data.words[2] = Max(e->data.msg.data.words[2],
               QDtoOS(ScreenHeight() - gSafeArea.bottom) + window->box.y1 - window->box.y0);
    }
    else
#endif
    if (forcePosition)
    {
      // it is a dialog, so change the template to say where we want it
      window->box = ((wr_wimp_wstate *)&fWindowRecord)->o.box;
      window->flags &= ~wr_wimp_WTRESPASS;  // stop dbox resetting it
    }
  }
  return;

// ****************** Exception handler **********************
Rescue:
  /* Call my Free method, not the general one for the object, as */
  /* inherited object's fields will not yet be initialised!      */
  _TWindow::Free();
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TWindow::Free()
{
  if (WindowCreated())
     Close();

  if (fDocument != NULL)
    fDocument->DeleteWindow(this);
  gApplication->DeleteFreeWindow(this);

  if (gSetUpWindow == this)
    gSetUpWindow = NULL; 
  if (gWindowWithPointer == this)
  {
    gWindowWithPointer = NULL;
    InitCursor();  // 23/09/91 lose I-beam on close window
  }
  if (fDbox != NULL)
    wr_dbox_free((dbox)fDbox);

//  if (!fClosesDocument)
//    WaitForMouseRelease();     // 10/02/93

  _TView::Free();
}


// ------------------------------------------------------------------------
void _TWindow::Open()
{
  FailInfo fi;
  wr_wimp_wind *window;
  wr_wimp_w w;
  Rect workSize;

  CatchFailures(&fi);

  window = wr_dbox_wind((dbox)fDbox);

  // do not create a window (yet) if this is a dialogue
  if (fTemplateName[0] == '!')
  {
    TWindow mainWindow;

    // 11/06/90 get current work area size, and reset when the window created
    MoveRect(workSize, *fWindowRecord.GetWorkArea());  // get copy of size
    fWindowRecord.ResetWorkArea(gZeroRect); // so next call wont be ignored
    if (fDocument != NULL)
      fDocument->DoInstallTitle(this);  // 15/04/93 [20833] zoom percentge in title
//    {
//      char *aString = fDocument->fTitle;

//      if (aString != NULL)
//        SetTitleForDoc(aString);
//    }

    FailOSErr(wr_wimp_create_wind(window, &w));

    fWindowRecord.SetHandle(w);   // save window info

    // in case there has been a resize since it was created (eg. rulers)
    fWindowRecord.ResetWorkArea(workSize);

    // register menu and event handler for the newly created window
    wr_win_register_event_handler(w, (wr_win_event_handler)wind_HandleEvent, this);
    mainWindow = GetWindow();             /* panes may have a superview! */
    if (mainWindow->fNoMenuSetup)        // 31/08/93 maybe no menu for panes in dlogs
      fMenuData = new _TMenu(1, mainWindow, NULL, w);
//  31/10/90 attach now done by _TMenu ctor
//  event_attachmenumaker(w, (event_menu_maker)MenuMaker,
//                        (event_menu_proc)MenuProc, menuData);
  }

  Success(&fi);

  BeInPort(GetGrafPort());
  if (fTemplateName[0] == '!' || fBeOpened)  // 27/06/91 else dbox will do it
    Show(TRUE, kRedraw);
  _TView::Open();
  return;

// ****************** Exception handler **********************
Rescue:
  // remove event and menu handlers
  CloseWindow();
  ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TWindow::CloseWindow()
{
  // remove event and menu handlers
  wr_wimp_w w = fWindowRecord.GetHandle();

  if (w != kNoWindow)
  {
    // 07/07/91 seems to close win:  wr_win_register_event_handler(w, NULL, NULL);
    // 31/10/90 detach now done by _TMenu Free
    ClearObject(fMenuData);

    // delete the window
    wr_wimpt_noerr(wr_wimp_delete_wind(w));
    wr_win_register_event_handler(w, NULL, NULL);
    fWindowRecord.SetHandle(kNoWindow);
  } 
  ClearHandle(&fTitle);  // 07/07/91 moved out of condition
  CancelDoubleClick();   // 10/08/95 [26052] no not treat click on underlying window as double
}


// ------------------------------------------------------------------------
void _TWindow::Close()
{
  _TView::Close();

  // Do not do a show for a dialog - it seems to clash with dbox
  if (fTemplateName[0] == '!')
    Show(FALSE, kRedraw);
  gApplication->InvalidateFocus();
  CloseWindow();   // get rid of wimp resource
  if (fFreeOnClosing)
    Free();
}


// ------------------------------------------------------------------------
void _TWindow::BeInPort(GrafPtr itsPort)
{
  _TView::BeInPort(&fWindowRecord);
}


// ------------------------------------------------------------------------
TCommand _TWindow::DoDataLoad(wr_wimp_msgstr *msg, AppFile &appFile)
// 09/07/95 [26034] called only on DataLoad, so can ack with DataSaveOK.
// NB. DoLoadFile is virtual & calls merge dialogue or standard window
// make a copy of msg???
{
   TCommand commandToPerform;
   FailInfo fi;

   CatchFailures(&fi);

   appFile.fName = msg->data.dataload.name;
   if (msg->hdr.your_ref == 0)
     appFile.fFileIsSafe = TRUE;

   commandToPerform = DoLoadFile(appFile, NULL, FALSE);

   // 09/07/95 [26034] include a PerformCommand within CatchFailures so
   // that we can remove the other xferrecv_insertfileok calls in the commands
   gApplication->PerformCommand(commandToPerform);

   Success(&fi);  // fall into Rescue...

Rescue:
   app_InsertFileOK(msg);
   ContinueIfFail(&fi);
   return gNoChanges;
}

// *************************************************************************
TCommand _TWindow::HandleEvent(EventInfo &info)
{
  switch (info.event->e)
     {
     case wr_wimp_EREDRAW:
        InvalSavedArea();
        Redraw(info);                 // redraw original area + areaToInval
//        info.affectsMenus = FALSE;                        // 03/12/90
        break;

     case wr_wimp_EOPEN:
        fWindowRecord.SetOpenStr(&info.event->data.o);
        OpenWindow();
        info.eventHandled = TRUE;   // 27/08/93 stop dbox doing it again
//        info.affectsMenus = FALSE;
        break;

     case wr_wimp_ECLOSE:
        CloseByUser(info);
        break;

     case wr_wimp_EPTRENTER:
        gWindowWithPointer = this;   // force into TrackCursor
     case wr_wimp_EPTRLEAVE:
        // 22/03/96 force a NULL event so that the pointer shape reset for new window
        // ... would be better to do a TrackCursor, but may need to reset the idle freq.
        info.event->e = wr_wimp_ENULL;
        app_HandleEvent(info.event, NULL);
        break;

     case wr_wimp_EBUT:
        return HandleMousePress(info);

     case wr_wimp_EKEY:
        return HandleKeyDownEvent(info);

     case wr_wimp_ESCROLL:
        if (fScroller != NULL)
          // wr_wimp_eventdata *data = &info.event->data;
          fScroller->ScrollStep(info.event->data.scroll.x, info.event->data.scroll.y);
        break;

     case wr_wimp_ELOSECARET:
        fWindowRecord.LoseCaret(info.event->data.c);
        break;

     case wr_wimp_EGAINCARET:
        fWindowRecord.GainCaret(info.event->data.c);
                        // 09/05/91 menus get reset when mouse moved into
                        // a writable icon & back to the menu which is up
                        // over a window which does not have the caret
        break;

     case wr_wimp_ESEND:
     case wr_wimp_ESENDWANTACK:
        {
           wr_wimp_msgstr *msg = &info.event->data.msg;
           TObject pasteSelection = NULL;
           AppFile appFile;

           appFile.fFileIsSafe = FALSE;
           switch (msg->hdr.action)
           {
           case wr_wimp_MDATASAVE:
#ifdef DRAGDROP
              pasteSelection = gApplication->CheckDragDrop(info);  // 23/03/93
#endif
              appFile.fName = NULL;
           case wr_wimp_MDATALOAD:
              FinishIdle();
              // the following fields are coincident in dataload and datasave
              appFile.fType = msg->data.datasave.type;
              appFile.fEstSize = msg->data.datasave.estsize;
              if (msg->hdr.action == wr_wimp_MDATALOAD)
                 return DoDataLoad(msg, appFile);
              return DoLoadFile(appFile, pasteSelection, info.theShiftKey);

           case wr_wimp_MHELPREQUEST:
              {
                 Point  theMouse;
                 VPoint theVMouse;
                 wr_wimp_mousestr *m = &msg->data.helprequest.m;

                 if (Focus())
                 {
                   OStoQDPt(m->x, m->y, theMouse, ScreenHeight());
                   msg->data.helpreply.text[0] = 0;
                   fWindowRecord.GlobalToLocal(theMouse);
                   QDToViewPt(theMouse, theVMouse);
                   HandleHelp(theVMouse, info);
                 }
                 info.affectsMenus = FALSE;
              }
              break;

#ifdef THESAURUS
           case Message_ThesaurusSend:  // 26/02/93 [20802]
              appFile.fName = msg->data.chars;
              appFile.fType = 0xfff;     // a kTextFile
              appFile.fEstSize = 0;
              info.eventHandled = TRUE;  // ?
              // UApplication has already checked caret in our window, so ack message
              // msg->hdr.your_ref = msg->hdr.my_ref;
              // wr_wimpt_noerr(wr_wimp_sendmessage(wr_wimp_EACK, msg, msg->hdr.task));
              wr_wimpt_noerr(AckMessage(msg));
              return fDocument->DoPaste(&appFile, strlen(appFile.fName),
                          kSynonymReturned, NULL);
#endif
           }
        }
     }
  return gNoChanges;
}


// *************************************************************************
// a file dropped into a window or a Save file icon dropped on window
TCommand _TWindow::DoLoadFile(AppFile &appFile, TObject pasteSelection, bool shiftKey)
{
  TCommand theCmd = gNoChanges;

  // the test for copying a file to itself will only match if a file icon
  // for the file we are editing in the window is dropped onto the window

  if (fDocument != NULL &&
        (appFile.fName == NULL || strcmp(appFile.fName, fDocument->fTitle) != 0) &&
                                        fDocument->CanPaste(appFile.fType))
  {
    TFileInfo  fileInfo;

    BeginProgress();
     
    if (appFile.fName != NULL)
    {
      GetFileInfo(appFile.fName, fileInfo);    // can cause a Failure
      appFile.fEstSize = fileInfo.GetFileSize();
    }
     
    theCmd = fDocument->DoPaste(&appFile, appFile.fEstSize,
               pasteSelection == NULL ? kInsertFile : (shiftKey ? kMoveCommand : kCopyCommand),
               pasteSelection);

    HideProgress();
  }
  return theCmd;
}

// ------------------------------------------------------------------------
TCommand _TWindow::HandleMousePress(EventInfo &theEventInfo)
{
  TCommand aCommand;
  Point theMouse;
  Point where;
  bool track;
  int tCount = TickCount();
  int mouseX;
  int mouseY;
  wr_wimp_mousestr *mouseInfo = &theEventInfo.event->data.but.m;
  bool focused = FALSE;
  int bbits = mouseInfo->bbits;

#ifdef NETWP
  // 16/09/96 [27087] menu button toggles button bar
  if ((bbits & wr_wimp_BMID) != 0)
    return DoMenuCommand(theEventInfo, cShowHideButtons);
#endif

  mouseX = mouseInfo->x;
  mouseY = mouseInfo->y;
  if (Focus())
  {
    OStoQDPt(mouseX, mouseY, where, ScreenHeight());
    focused = TRUE;
  }
  // 16/08/93 [21025] test for dragging event
  if ((bbits & ((wr_wimp_BRIGHT | wr_wimp_BLEFT) * 16)) != 0)
  {
    theEventInfo.eventHandled = TRUE;
           // 07/07/95 Avoid second spurious DoChoice from DialogView_EventHandler
    if (focused)
    {
      thePort->GlobalToLocal(where);
      theEventInfo.delayDrag = FALSE;
      app_DragStarting(where, theEventInfo);
    }
  }
  // 01/09/93: treat double/click/drag clicks as normal clicks
  //           NB. The double clicks themselves should be handled by dbox
  if (bbits >= 256)
    bbits = bbits >> 8;

  if ((bbits & (wr_wimp_BRIGHT | wr_wimp_BLEFT)) != 0)
  {
    app_NewClick(theEventInfo);
    if (tCount - gLastClickTime >
         100 
#ifdef TRACE
         * 2
#endif
        || abs(gLastClickPosX - mouseX) > 16 ||
           abs(gLastClickPosY - mouseY) > 16)
      gClickCount = 0;
    gLastClickTime = tCount;
    gLastClickPosX = mouseX;
    gLastClickPosY = mouseY;
    theEventInfo.theClickCount = ++gClickCount;
    // 11/05/91 set new field
    theEventInfo.rightButton = (bbits & wr_wimp_BRIGHT) != 0;
#ifdef MATHS
    theEventInfo.theShiftKey = wr_akbd_pollsh();  // 30/04/92 use flag for sh-click
#endif

    if (focused)
    {
      int buttonType = (fDbox == NULL ? 0 : wr_dbox_wind((dbox)fDbox)->workflags);
                                            // 17/08/93 [21025] set button type for window
      bool handled = FALSE;
      TWindow realWindow = GetWindow();     // 19/10/92 do before window may be freed
                                            // 12/08/92 get the caret window
      int mousei;

      theMouse = where;
      Focus();  // 21/11/95 Possibly reset above
      fWindowRecord.GlobalToLocal(theMouse);
      theEventInfo.theTrackPhase = trackPress;

      // the following may free self!
      aCommand = gNoChanges;
      mousei = mouseInfo->i;      // make copy - allows event to be overwritten
      if (mousei != -1)
      {
        wr_wimp_icon result;
        int mousew = mouseInfo->w;

        theEventInfo.eventHandled = TRUE;  // dismissing buttons reset to FALSE
        // if mouse in a control call HandleControlClick
        handled = HandleControlClick(theEventInfo, aCommand);

        // 17/08/93 [21025] find from icon whether drag is possible
        wr_wimpt_noerr(wr_wimp_get_icon_info(mousew, mousei, &result));
        buttonType = result.flags;
      }
#ifdef DRAGDROP
      theEventInfo.trackingKey = 0;  // HandleControlClick not part of drag scheme (yet?)
#endif
      track = TRUE;
      if (!handled)
         track = HandleMouseDown(theMouse, theEventInfo, aCommand);

      //    include the following if we want to gain caret when clicking on icon bar/ruler
      //    if (realWindow not freed)
      //    realWindow->fWindowRecord.SetCaret();    // 12/08/92 gain caret whereever clicked
      if (theEventInfo.affectsMenus)                 // 14/09/92 lost gain cursor if dbox
        gApplication->SetWindowForMenus(realWindow); // 12/08/92 and set up menus

      theEventInfo.delayDrag = DragButton(buttonType);  // 17/08/93 [21025]
      if (track && aCommand != gNoChanges)
        return gApplication->TrackMouse(where, aCommand, theEventInfo);
    }
  }
  return gNoChanges;
}


// *************************************************************************
void _TWindow::AboutToScroll(VCoordinate deltaH, VCoordinate deltaV)
{
  fHasScrolled = TRUE;           // 12/05/91
}


// *************************************************************************
void _TWindow::OpenWindow()
// Called as a result of a wimp window drag or resize event
{
  fWindowRecord.OpenWindow();
  DoResize();  // ensure fSize correctly set
}


// *************************************************************************
void _TWindow::Redraw(EventInfo &info)
{
  wr_wimp_redrawstr r;
  int more;
  FailInfo fi;
#ifdef TRACE
  THandler oldTarget = fTarget;
#endif

  fWindowRecord.SaveCaret();
  r.w = fWindowRecord.GetHandle();
  wr_wimpt_noerr(wr_wimp_redraw_wind(&r, &more));

  gInRedraw = TRUE;

  while (more != 0)
  {
    // set up the clip rect, etc. for drawing
    fWindowRecord.SetRedrawStr(&r);

    // do the main window redrawing
    CatchFailures(&fi);
    DrawContents();
#ifdef NETWP
    if (IsTV())
      wr_os_swi4(NH_AntiTwitter + XOS_Bit, r.g.x0, r.g.y0, r.g.x1 - r.g.x0, r.g.y1 - r.g.y0);
    DrawView(TRUE);
#endif
    Success(&fi);
#ifdef TRACE
        goto noRescue;
#endif

Rescue: // If anything goes wrong while drawing (which should not happen too
        // often) we are in a mess. Rather than stick up a dialog, which will
        // cause a redraw, and probably fail again, it seems better to just
        // carry on, in the hope that the user can save the document.
#ifdef TRACE
        SysBeep(1);     // to warn us that something is amiss
noRescue:
#endif
    MarkDamagedDoc(&fi, fDocument);  // 09/07/96 like UView, to pick up Assertions
    if (wr_wimp_get_rectangle(&r, &more) != NULL)
    {
#ifdef TRACE
      Assert(0, 26);
#endif
      more = 0;
    }
  }
  fWindowRecord.RestoreCaret(TRUE);

  gInRedraw = FALSE;
#ifdef TRACE
  Assert(oldTarget == fTarget, 888);
//  info.affectsMenus = (oldTarget == fTarget);  // this is original
#endif
  info.affectsMenus = FALSE; // (oldTarget != fTarget);    // 12/05/91 what was meant?
}

// *************************************************************************
TCommand _TWindow::HandleKeyDownEvent(EventInfo &info)
{
   int chcode = info.event->data.key.chcode;

#ifdef DRAGDROP
   if (app_DoingDrag(chcode))
      return gNoChanges;   // ignore all except escape while dragging
#endif
   // 09/05/91 finish any tracking that may be in progress
   if (gTracker != NULL)              // 22/03/93 && gTracker != gNoChanges)
   {
      gUnprocessedKey = chcode;
      gStuffedChar = TRUE;
      info.theTrackPhase = trackRelease;
      return gApplication->DoTrackMouse(info);
   }
   chcode = ConvertKeys(chcode);
   if (gCommandKey)
      return(fTarget->DoCommandKey(chcode, info));

   return(fTarget->DoKeyCommand(chcode, info));
}


#define MAXBUFFSIZE 50
// *************************************************************************
TCommand _TWindow::DoCommandKey(int chcode, EventInfo &info)
{
  CmdNumber aCmd;
  FailInfo fi;

  if (info.affectsMenus)                 // 31/01/94 lost gain cursor if dbox
    gApplication->SetWindowForMenus(GetWindow());        // 03/12/90 make sure ...
  gApplication->SetupTheMenus();                         // menus are correctly set
  //  aCmd = (chcode == wr_akbd_PrintK && CmdEnabled(cPrint) ?
  //              cPrint : CmdFromKeyPress(chcode));  // 16/01/92 [21342] & [21343]
  aCmd = (chcode == wr_akbd_InsertK ? cPaste : CmdFromKeyPress(chcode)); // 16/01/92

  if (aCmd == 0)
  {
#ifdef NETWP
#ifdef TRACE
    if (chcode == wr_akbd_Fn+9)
      aCmd = 816;   // toggle bar while RiscOS has f12
    else
#endif
#else
    bool shiftF2 = (chcode == wr_akbd_Sh+wr_akbd_Fn+2); /* Sh-F2 */

    // not in menu: - test for non-menu function keys
    if (chcode == wr_akbd_Fn+2 || shiftF2)
    {
      AppFile anAppFile;
      char buff[MAXBUFFSIZE];
      TFileInfo fileInfo;
      TCommand pasteCmd = gNoChanges;

      buff[0] = 0;
      wr_dboxfile(GetString(kLoadFileMsg + shiftF2), gMainFileType, buff, MAXBUFFSIZE);
      if(buff[0] != 0)
      {
        CatchFailures(&fi);
        GetFileInfo(buff, fileInfo);
        fileInfo.CheckType();           // fail if not file
        anAppFile.fType = (fileInfo.fInfo.loadaddr & 0x000fff00) >> 8;
        anAppFile.fName = buff;
        anAppFile.fEstSize = -1;        // 18/02/91 indicates file is safe
        anAppFile.fFileIsSafe = TRUE;
        if (shiftF2)
        {
          if (fDocument == NULL || !fDocument->CanPaste(anAppFile.fType))
            FailGeneral(kNotOurFileType);
          pasteCmd = fDocument->DoPaste(&anAppFile,
                                        fileInfo.GetFileSize(), kF2Insert, NULL);
        }
        else
        {
          gApplication->CanReadDocument(anAppFile, kNotOurFileType);
          // if (!gApplication->CanReadDocument(anAppFile))
          //   FailGeneral(kNotOurFileType);
          gApplication->OpenOld(/* 03/02/93 cOpen, */ anAppFile);
        }
        Success(&fi);
      }
      return pasteCmd;
    }
    else
#endif
    // not in menu: - test for non-menu function keys (Ctrl-F2)
    if (chcode == wr_akbd_Ctl+wr_akbd_Fn+2 && WindowBorder())
    {
      CloseByUser(info);
      return gNoChanges;
    }
#if defined TABLES && !defined NETWP
    // 20/02/92 Ctrl-Sh-F11 for old cEndStruct action
    else if (chcode == wr_akbd_Ctl+wr_akbd_Sh+wr_akbd_Fn11)
      aCmd = 211;  // cEndStruct
#endif
    else
      // it is not in the menu, pass to inherited DoCommandKey 
      return _TView::DoCommandKey(chcode, info);
  }
  return fTarget->DoMenuCommand(info, aCmd);

Rescue:
   // really gErrorParm3 needs to be set to the filename for message
   FailNewMessage(&fi, msgOpenFailed);
   goto Rescue; // stop compiler warning
   // 07/06/91 done by FNM   ContinueFailure(&fi);
}


// ------------------------------------------------------------------------
void _TWindow::AdaptToScreen()
{
  Point diff;
  Rect windRect;
  Point newSize;

  SetPt(diff, ScreenWidth() - OStoQD(stdHScreen),
              ScreenHeight() - OStoQD(stdVScreen));
  if (diff.h != 0 || diff.v != 0)
  {
    int newHSize;
    int newVSize;

    GetGlobalBounds(windRect);
    RectSizeToPt(windRect, newSize);
    AddPt(diff, newSize);
    newHSize = newSize.h - fWindowRecord.GetScrollBarWidth();
    newVSize = newSize.v - fWindowRecord.GetTitleBarDepth() -
                                       fWindowRecord.GetScrollBarDepth();
    if (IsShown())
      Resize(newHSize, newVSize, FALSE);
    else
      SizeWindow(&fWindowRecord, newHSize, newVSize, FALSE);
  }
}

// ------------------------------------------------------------------------
void _TWindow::PositionWindow(int left, int top)
{
  if (IsShown())       // try this when a method: WindowCreated() && fShown)  
    Locate(left, top, FALSE);
  else
    MoveWindow(&fWindowRecord, left, top, FALSE);
}

// ------------------------------------------------------------------------
void _TWindow::Center(bool horizontally, bool vertically, bool forDialog)
{
  Rect globalbounds;

  GetGlobalBounds(globalbounds);
  CenterRectOnScreen(globalbounds, horizontally, vertically, forDialog);
  PositionWindow(globalbounds.left, globalbounds.top);
  // if (IsShown())
  //   Locate(globalbounds.left, globalbounds.top, FALSE);
  // else
  //   MoveWindow(&fWindowRecord, globalbounds.left, globalbounds.top, FALSE);
}


// ------------------------------------------------------------------------
void _TWindow::SimpleStagger(int dh, int dv, int &counter)
{
  Rect posRect;
  int nSlots;
  int slot;
  int spareRight;
  int spareBottom;

  GetGlobalBounds(posRect);

  spareRight = (dh == 0 ? 0 : (ScreenWidth() - posRect.right) / dh);
  spareBottom = (dv == 0 ? 0 : (ScreenHeight() - GetIconBarHeight() -
                              posRect.bottom - GetHLineThickness()) / dv);

  nSlots = (spareRight == 0 ? spareBottom :
            (spareBottom == 0 ? spareRight : Min(spareBottom, spareRight)));

  slot = (nSlots <= 0 ? 0 : counter % (nSlots + 1));
  if (slot != 0)
  {
    int hPos = posRect.left + (spareRight == 0 ? 0 : slot * dh);
    int vPos = posRect.top + (spareBottom == 0 ? 0 : slot * dv);

    PositionWindow(hPos, vPos);
    // if (IsShown())
    //   Locate(hPos, vPos, FALSE);
    // else
    //   MoveWindow(&fWindowRecord, hPos, vPos, FALSE);
  }
  counter++;
}

// ------------------------------------------------------------------------
void _TWindow::CountOpenWindows(TWindow aWindow, int &openDocWindows)
{
  if (aWindow->IsShown())
    openDocWindows += openDocWindows;
}


// ------------------------------------------------------------------------
void _TWindow::CloseByUser(EventInfo &info)
{
// test the button & shift; Fail if the user cancels

  int openDocWindows;
  wr_wimp_mousestr theMouse;
  bool theShiftKey = wr_akbd_pollsh();     // 11/05/91 local instead of info.

  // check for adjust being pressed, & shift held down for filer opening
  GetMouseInfo(&theMouse);
  if (theMouse.bbits == wr_wimp_BRIGHT)
  {
     // clicked on the ADJUST button
     if (fDocument != NULL)
     {
        // the window has a document relating to it. If the doc has changed,
        // DO NOT close the window (ie assume SHIFT pressed)
        if (fDocument->fChangeCount != 0)
           theShiftKey = TRUE;

        app_OpenDir(fDocument->fTitle);
     }
     
     // if SHIFT-ADJUST, abort as we do not want to close the window
     if (theShiftKey)
        FailNoFail();
  }

  if (fDocument == NULL)
    Close();
  else
  {
    openDocWindows = 0;
    fDocument->fWindowList->Each(this,
                  (DoToObject)_TWindow::CountOpenWindows, &openDocWindows);
    if (fClosesDocument || (openDocWindows == 1))
      fDocument->Close(TRUE);
    else
      Close();
  }
  info.fDeleteWindow = TRUE;
}


// ------------------------------------------------------------------------
void _TWindow::DoSetupMenus()
{  
  if (!fIsModal)
    _TView::DoSetupMenus();
}


// ------------------------------------------------------------------------
bool _TWindow::Focus()
{
  if (!IsFocused() && WindowCreated())
  {
    SetPort(GetGrafPort());
    SetOrigin(0, 0);
    thePort->SetHugeClip();
    gFocusedView = this;
  }
  return(IsShown());
}

#ifdef TRACE
// ------------------------------------------------------------------------
void _TWindow::Draw(Rect &area)
{
}


// ------------------------------------------------------------------------
bool _TWindow::FocusOnSuperView()
{
  return FALSE;
}
#endif

// ------------------------------------------------------------------------
void _TWindow::GetGlobalBounds(Rect &globalbounds)
{
  Point workAreaSize;

  globalbounds = *fWindowRecord.GetPortRect();

  RectSizeToPt(*fWindowRecord.GetWorkArea(), workAreaSize);
  // if window global bounds are larger than the work area use its size
  if (LengthRect(globalbounds, v) > workAreaSize.v)
    globalbounds.bottom = globalbounds.top + workAreaSize.v;
  if (LengthRect(globalbounds, h) > workAreaSize.h)
    globalbounds.right = globalbounds.left + workAreaSize.h;

  fWindowRecord.LocalToGlobal(*globalbounds.topLeft);
  fWindowRecord.LocalToGlobal(*globalbounds.botRight);

  globalbounds.right += fWindowRecord.GetScrollBarWidth();
  globalbounds.top -= fWindowRecord.GetTitleBarDepth();
  globalbounds.bottom += fWindowRecord.GetScrollBarDepth();
}


// ------------------------------------------------------------------------
GrafPtr _TWindow::GetGrafPort()
{
  return (WindowCreated() ? &fWindowRecord : NULL);
}


// ------------------------------------------------------------------------
TWindow _TWindow::GetWindow()
{
  // if fSuperView is not NULL, this is a pane so return its window
  return (fSuperView == NULL ? this : _TView::GetWindow());
}


// ------------------------------------------------------------------------
bool _TWindow::HandleMouseDown(VPoint &theMouse, EventInfo &info,
                                  TCommand &theCommand)
{
   // 20/06/96 check window to ensure not sent to the 'wrong' pane when hidden
   if (info.event->e != wr_wimp_EBUT || info.event->data.but.m.w == fWindowRecord.GetHandle())
     return _TView::HandleMouseDown(theMouse, info, theCommand);
   return FALSE;
}


// ------------------------------------------------------------------------
void _TWindow::InstallDocument(TDocument itsDocument)
{
  fDocument = itsDocument;
  if (itsDocument != NULL)
  {
    gApplication->DeleteFreeWindow(this);
    itsDocument->AddWindow(this);
    fNextHandler = itsDocument;
  }
  else
  {
    gApplication->AddFreeWindow(this);

    // 01/02/94 do not overwrite fNextHandler for panes, this loses the command chain if
    // a pane (which is just a window) is made target of a dialogue. Bounced keys from
    // the raw dialogue handler are then passed to wr_wimp_processkey, instead of being
    // handed up to the be ignored by the dialogue
    if (fNextHandler == NULL)
       fNextHandler = gApplication;
  }
}


// ------------------------------------------------------------------------
void _TWindow::SetTitleForDoc(char *newDocTitle, int zoomPercent, int changeCount)
{
  if (newDocTitle != NULL)
  {
    char *changed = " *";
    int changeOffset = (changeCount == 0 ? 2 : 0);
    char buffer[kMaxTitleLength + 1];

#ifndef TABLES
    char temp[267];

    sprintf(temp, GetRsrcMisc(7), newDocTitle, zoomPercent);
    newDocTitle = temp;
#endif
    TruncateText(buffer, newDocTitle, kMaxTitleLength - changeOffset, dotLeft);
    strcat(buffer, changed + changeOffset);
    SetTitle(buffer);
  }
}


// ------------------------------------------------------------------------
void _TWindow::GetTitle(char * &theTitle)
{
  theTitle = fTitle;
}


// ------------------------------------------------------------------------
void _TWindow::SetTitle(char *title)
{
  if (fWindowRecord.GetTitleBarDepth() != 0)
  {
    wr_wimp_redrawstr r;

// 07/07/91 avoid the horrors of wr_win_settitle
    if (fTitle != NULL)
    {
      strcpyn(fTitle, title, kMaxTitleLength);

      r.w = (wr_wimp_w) -1;    /* absolute screen coords */
      r.box = *fWindowRecord.GetPortBox();
      r.box.y0 = r.box.y1;
      r.box.y1 += 40;            /* yuk - tweaky */
      if (WindowCreated())
        wr_wimpt_noerr(wr_wimp_force_redraw(&r));
    }
  }
}


// ------------------------------------------------------------------------
bool _TWindow::IsShown()
{
#ifdef TRACE
  if (WindowCreated() && (fWindowRecord.IsShown() != fShown))
  {
    wr_werr(0, "fShown inconsistent with RISCOS");
    fShown = !fShown;
  }
#endif
  return (WindowCreated() ? fShown : FALSE);
}


// ------------------------------------------------------------------------
void _TWindow::Locate(VCoordinate h, VCoordinate v, bool invalidate)
{
  MoveWindow(&fWindowRecord, h, v, FALSE);
  if (IsShown())
    fWindowRecord.OpenWindow();
}


// ------------------------------------------------------------------------
void _TWindow::Select()
{
  fWindowRecord.SetBehind(-1);
  OpenWindow();
}


// ------------------------------------------------------------------------
void _TWindow::DoResize()
{
  Rect bounds;

  GetGlobalBounds(bounds);
  Resize(bounds.right - bounds.left - fWindowRecord.GetScrollBarWidth(),
             bounds.bottom - bounds.top - fWindowRecord.GetTitleBarDepth() -
             fWindowRecord.GetScrollBarDepth(), TRUE);
}


// ------------------------------------------------------------------------
void _TWindow::Resize(VCoordinate width, VCoordinate height, bool invalidate)
{
  if (width != fSize.h || height != fSize.v)
  {
    _TView::Resize(width, height, invalidate);

    SizeWindow(&fWindowRecord, fSize.h, fSize.v, invalidate);
    gApplication->InvalidateFocus();
  }
}


// ------------------------------------------------------------------------
void _TWindow::SetTarget(THandler newTarget)
{
  fTarget = newTarget;
}


// ------------------------------------------------------------------------
void _TWindow::Show(bool state, bool redraw)
{
  if (WindowCreated())      // the window may never have been opened
  {
    fShown = state;
    if (state)
      OpenWindow();
    else
    {
      HideWindow(&fWindowRecord);
      gApplication->InvalidateFocus();
    }
  }
}


// ------------------------------------------------------------------------
bool _TWindow::DoIdle(IdlePhase phase)
{
  // 21/03/96 moved out of application DoWindowIdle
  if (phase != idleEnd)    // 10/09/91
    return InvalSavedArea();
  return _TView::DoIdle(phase);
}


// ------------------------------------------------------------------------
bool _TWindow::InvalSavedArea()
{
  if (!EmptyRect(fAreaToInvalidate) && Focus())
  {
    // 06/07/90 offset by scroll, because already in work area coords
    SetIdleFreq(kMaxIdleTime);        // 21/03/96 ??? !!!!
    thePort->WorkAreaToQDRect(fAreaToInvalidate);
    InvalRect(fAreaToInvalidate);
    ClearRect(fAreaToInvalidate);
  }
  return FALSE;
}


// ------------------------------------------------------------------------
void _TWindow::InvalidateArea(VRect &aRect)
{
  SetIdleFreq(0);        // 21/03/96 Ensure dealt with asap
  if (fAreaToInvalidate.right <= fAreaToInvalidate.left ||
                                      fAreaToInvalidate.bottom <= fAreaToInvalidate.top)
    MoveRect(fAreaToInvalidate, aRect);
  else
    UnionRect(fAreaToInvalidate, aRect, fAreaToInvalidate);
}


// ------------------------------------------------------------------------
int _TWindow::GetScaleUnits(VHSelect direction, TScale &units)
{
  units = gUnits;
  return 12;
}

