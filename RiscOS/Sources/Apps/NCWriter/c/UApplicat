/************************************************************************/
/* Copyright © Icon Technology, Ltd, 1996.  All rights reserved.        */
/*                                                                      */
/* This file forms part of the source of NCWriter.                      */
/*                                                                      */
/* It may be used solely to create executable images of the Network     */
/* Computer (NC) Word processor. It cannot be used for any other        */
/* purpose without the prior written consent of Icon Technology Ltd.    */
/*                                                                      */
/* This file (even if modified) must retain this copyright notice.      */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

#include "os.h"
#include "dbox.h"
#include "wimpt.h"
#include "win.h"
#include "event.h"
#include "alarm.h"
#include "visdelay.h"
#include "pointer.h"
#include "kernel.h"
#include "swis.h"
#include "akbd.h"

#include "Support.h"
#include "PApplicat.h"

#define Message_Service (0x0004D300)
#define TaskModule_DeRegisterService (0x0004D303)
#define Service_RegistryStatus 0xba

#if DEMO == 0 && ! defined TRACE && ACORNSP == 1
#include "SP.h"
int SP_win_handle;
int SP_icon_handle;
#endif

#if SIDEBAR == 1
char *gStickyOption = NULL;
#endif

#define trackDrop 3
#define kShortFreq 50
#define kLongFreq 200

static int gIdleFreq = 0;
static int gLastIdle = 0;
static IdlePhase gIdlePhase = idleEnd;
static int gEventLevel = 0;
static int gNextSpaceMsg = 0;
static THandler gHeadCohandler = NULL;
#ifdef DRAGDROP
extern int SetSendingTypes(int *types, int selFlags);
                                       // in UExpressn: - needs to be a method!
static int      gLastClaim = 0;
static int      gLastClaimYref = 0;
       TCommand gStartDragger = NULL;
static wr_wimp_t   gDragClaimant;
static int      gDragClaimantRef;
static bool     gDragFinished = FALSE;
static TWindow  gStartWindow;
static int      gDragShift;
static int      gDragQuit;
static int      gDragTypes;  // flag set for things in the selection
static wr_wimp_box gDragBox;
static VPoint   gClaimMouse;
static int      gClaimWords[9];
       bool     gPointerAltered = FALSE;   // pointer changed by me
static char    *gDragPointerShape;
static int      gDragPointer;          // pointer reset by receiver
static TWindow  gCurrWindow;
#endif
static int      gPreDrag = FALSE;      // 17/08/93 [21025]
static int      gDragButton = 0;
static int      gExternalClip = FALSE;

typedef struct {
   wr_wimp_caretstr caret;
   int chcode;
} keystruct;

StringHandle gLastFile = NULL;  // 29/07/93 [21000] for adj click on icon bar
TCommand gAppnCommands[3];  // 10/05/91

       TList   gWindMenuList;
static bool    gMenusAreSetup = FALSE;
static bool    gIconBarIsSetup = FALSE;
static VPoint  gAnchorPoint;
static VPoint  gPreviousPoint;
static bool    gClipClaimed;
static TCommand gClipClaimer = NULL;

// ------------------------------

// used by the document gWindMenuList menu inserter
#define kMaxDocMenuLength 60
// ------------------------------

static void FeedbackOnce(bool turnItOn, bool mouseDidMove);
void app_SetWindowExtent(TObject null, TWindow aWindow, bool changed3D);
static void GetWindowForWimpW(TObject null, TWindow aWindow, 
                              TWindow* theWindow, wr_wimp_w theWimpWindow);
void FinishDrag(wr_wimp_msgstr *msg, bool quitDragging);
TCommand SelectFromPadMenu();

static long gVisUsed;
static long gVisTotal;
static long gInc;
static long gVisDepth = 0;

// -------------------------------------------------------------------------
void MarkDamagedDoc(FailInfo *fi, TDocument doc)
{
  if (doc != NULL && fi->error > 100)
    doc->fDamaged = TRUE;
}

// -------------------------------------------------------------------------
bool InsideHysteresis(Point &clickPoint, Point &newPoint)
{
  if ((unsigned int)(newPoint.h - clickPoint.h + 16) > 32 ||
      (unsigned int)(newPoint.v - clickPoint.v + 16) > 32)
    return FALSE;
  return TRUE;
}

// *************************************************************************
void BroadcastPasteRequest(wr_wimp_msgstr &msg)
{
  int i;

  // caller passes in  msg...w set up already
  msg.data.datasave.i = -1;
  msg.data.datasave.x = 0;
  msg.data.datasave.y = 0;
  msg.data.words[4] = 4;
  i = 0;
  do
     msg.data.words[i + 5] = gFileType[i];
  while (gFileType[i++] != -1);

  //wr_wimpt_noerr()
  BroadcastWantAck(Message_DataRequest, &msg, sizeof(wr_wimp_msghdr) + 4 * 5 + 4 * i);
}

// -------------------------------------------------------------------------
void EnablePasteCmd()
{
#ifdef DRAGDROP
  Enable(cPaste, gExternalClip || gClipView != NULL);
#else
  Enable(cPaste, gClipView != NULL);        // 16/04/91
#endif
}

// *************************************************************************
static void CloseADocument(TObject null, TDocument doc, bool prompt)
{
   doc->Close(prompt);         // close document
}

// *************************************************************************
static void FreeIt(TObject null, THandler aHandler)
{
   aHandler->Free();
}

// -------------------------------------------------------------------------
void TidyFiles()
// 07/06/91 called on exit - see if we have crashed leaving any files open
{
#ifdef NETWP
   // 22/10/96 [27116]
   wr_os_swi3(TaskModule_DeRegisterService | wr_os_X, 0, Service_RegistryStatus, wr_wimpt_task());
#endif

#if SIDEBAR == 1
   // 05/06/95 [25010] turn off sticky keys (ignore result os SWI)
   if (gStickyOption != NULL)
      wr_os_swi2(0x0004a0c0 | wr_os_X, 0, wr_wimpt_task());
#endif

#ifdef FILMS
#define IotaSound_InitSystem (0x81EC0)
#define IotaSound_DeregisterApp (0x81EC2)
   wr_os_swi1(IotaSound_InitSystem | wr_os_X, 0);
   wr_os_swi0(IotaSound_DeregisterApp | wr_os_X);
#endif

#if TALK == 2
   if (gPep == 2)
     wr_os_swi1(0x0004ad82 | wr_os_X, 2);
#endif

   if (gDumping)
    system("Spool");

   // 30/08/96 [27055] close any remaining files (left by PreQuit)
   gDocList->Each(NULL, (DoToObject)CloseADocument, FALSE);
   gApplication->EachHandler(NULL, gHeadCohandler, (DoToHandler)FreeIt);
   for (int i = 1; i <= gDocList->fSize; i++)
     wr_wimpt_noerr(CloseFile(TDocument(gDocList->At(i))->fDataRefnum));
   FinaliseMemory();
}


// -------------------------------------------------------------------------
static void ShutdownDoc(TObject null, TDocument doc, EventInfo &info)
// 05/05/94 [21721] handle shutdown messages
{
   doc->DoMenuCommand(info, cSaveFileShutdown);
}

// -------------------------------------------------------------------------
void ResetMenuFlag()
{
  gMenusAreSetup = FALSE;
}

// 10/09/90 three new functions for showing reformat progress
// -------------------------------------------------------------------------
void ShowProgress(long limit)
{
  if (gVisDepth <= 0)
  {
    gVisUsed = 0;
    gVisTotal = 0;
    gVisDepth = 0;
    wr_visdelay_begin();
  }
  gVisDepth++;
  gVisTotal += limit;
  if (gVisTotal > 10)
    gInc = (100 << 12) / gVisTotal;
}

// -------------------------------------------------------------------------
void BeginProgress()
{
  // 07/05/91 new for replacing wr_visdelay_begin in case already on
  ShowProgress(0);
}

// -------------------------------------------------------------------------
void RestartProgress()
{
  // 07/05/91 new for re-showing hourglass after a dialogue
  if (gVisDepth > 0)
    wr_visdelay_begin();
}

// -------------------------------------------------------------------------
void UpdateProgress()
{
  gVisUsed += gInc;
  if (gVisTotal > 10)
    wr_visdelay_percent(gVisUsed >> 12);
}

// -------------------------------------------------------------------------
void HideProgress()
{
  gVisDepth--;
  if (gVisDepth == 0)
    wr_visdelay_end();
}

// -------------------------------------------------------------------------
int HoldProgress(int newVal)
{
  int oldVal = gInc;

  gInc = newVal;
  return oldVal;
}

// -------------------------------------------------------------------------
static void KillProgress()
{
  if (gVisDepth > 0)
  {
    gVisDepth = 0;
    wr_os_swi0(0x406C2 + wr_os_X);   // 08/12/93 Hourglass_Smash for wr_visdelay_end();
  }
}

// -------------------------------------------------------------------------
static void GetControlToReflectMenuState(TObject null, TObject theControl, int disable)
{
   if (TControl(theControl)->GetWindow() == gSetUpWindow)
      TControl(theControl)->ReflectMenuState(disable);
}


// *************************************************************************
// 22/04/94 canClose is always TRUE for Close(NULL) & why not set gAppDone after it worked?
void _TQuitCommand::DoIt()
{
   gApplication->Close(NULL);
   // 22/02/94 done by Close itself gAppDone = TRUE;
}

#ifdef TRACE
// *************************************************************************
void _TQuitCommand::Free()
{
}
#endif

// *************************************************************************
void _TUndoRedoCommand::DoIt()
{
   int deltaCount;
   TCommand lastCommand;
   DECLARE(this);

#ifdef DRAGDROP
#ifdef TRACE
   Assert(fChangedDocument, 741);
#endif
   lastCommand = fChangedDocument->fLastCommand;
#else
   lastCommand = gLastCommand;
#endif
   if (lastCommand == NULL) return;  // 20/04/93 [20838]
           // 24/08/90 an unfortunate effect of committing in menu selection

   // Need to commit any other documents Cut/Copy commands on DoIt!!!
   if (lastCommand->fChangesClipboard
#ifdef DRAGDROP
        && gClipClaimer == lastCommand
#endif
     )   // 11/07/90 new for Undo Cut/Copy
   {
      TView tempClipView;

      tempClipView = gClipUndoView;
      gClipUndoView = gClipView;
      gClipView = tempClipView;
   }    

   if (lastCommand->fCmdDone)
   {
      lastCommand->UndoIt();
      lastCommand->fCmdDone = FALSE;
      deltaCount = -1;
   }
   else
   {
      lastCommand->RedoIt();
      lastCommand->fCmdDone = TRUE;
      deltaCount = 1;
   }

   if (lastCommand->fCausesChange)
   {
#ifdef DRAGDROP
      fChangedDocument->UpdateChangeCount(deltaCount);
#else
      if (lastCommand->fChangedDocument != NULL)
        lastCommand->fChangedDocument->UpdateChangeCount(deltaCount);
#endif
   }
}

#ifdef TRACE
// *************************************************************************
void _TUndoRedoCommand::Free()
{
   DECLARE(this);
}
#endif

// *************************************************************************
void _TAboutAppCommand::DoIt()
{
   DECLARE(this);
   gApplication->DoShowAboutApp();
}

#ifdef TRACE
// *************************************************************************
void _TAboutAppCommand::Free()
{
   DECLARE(this);
}
#endif

// *************************************************************************
static void app_AbandonClipboard(TView clipView)
{
  if (clipView != NULL && clipView->fDocument != NULL)
    FreeIfObject(clipView->fDocument);
  else
    FreeIfObject(clipView);
}

// -------------------------------------------------------------------------
static TWindow WimpToWindow(wr_wimp_w w)
{
   TWindow theWindow = NULL;

   if (w != -1)       // 05/09/94 avoid matching with any unopened windows
      gApplication->ForAllWindowsDo(NULL, (DoToObject)GetWindowForWimpW, &theWindow, w);
   return theWindow;
}

// -------------------------------------------------------------------------
static void InstallTracker(TCommand newTracker)
{
   ReplaceObject(gTracker, newTracker);
}

// *************************************************************************
static void RemoveTracker(TCommand newTracker)
// set gTracker to NULL && free it (if different to newTracker)
// also set gStartDragger to NULL if it is freed as a result of freeing gTracker
{
   register TCommand oldTracker = gTracker;

   gTracker = NULL;
#ifdef DRAGDROP
   // if we free gTracker, then we need to set gStartDragger to NULL if equal gTracker
   if (oldTracker != newTracker && oldTracker == gStartDragger)
      gStartDragger = NULL;
#endif
   FreeIfObject(oldTracker != newTracker ? oldTracker : NULL);
}

// -------------------------------------------------------------------------
void app_NewClick(EventInfo &info)
{
   if (gTracker != NULL && gPreDrag)
   {
      Point theMouse;
      wr_wimp_mousestr *mouseInfo = &info.event->data.but.m;

      info.theTrackPhase = trackRelease;
      OStoQDPt(mouseInfo->x, mouseInfo->y, theMouse, ScreenHeight());
      gApplication->PerformCommand(gApplication->TrackMouse(theMouse, gTracker, info));
   }
}

// -------------------------------------------------------------------------
#ifdef DRAGDROP
bool app_DoingDrag(int chcode)
{
   if (gStartDragger != NULL)  // ignore all except escape while dragging
   {
      if (chcode == chEscape)
         gDragQuit = 16;
      return TRUE;
   }
   return FALSE;
}
#endif

// -------------------------------------------------------------------------
bool DoRescue(FailInfo &fi)
{
   // 03/08/92 new tidy up proc
   KillProgress();     // in case failed with hourglass on
   ErrorAlert(fi.error, fi.message);
#ifdef DRAGDROP
   // 26/07/93 free and clear dragger after failure
   FinishDrag(NULL, TRUE);
#else
   RemoveTracker(NULL);
#endif
   return FALSE;
}

// -------------------------------------------------------------------------
void WaitForMouseRelease()
// 18/11/92
{
   if (gWimpVersion >= 300 && gWimpVersion <= 316)  // 12/05/94 [21805]
   {
      /* 01/10/92 Fix for Wimp problem when quitting with a 3-d icon */
      _kernel_swi_regs r;

      gApplication->SetIdleFreq(0);   // 28/08/96 turn on idle routine
      // wr_event_setmask(0); /*-- set event mask to 0                 --*/
      do /*-- read mouse state until buttons are released --*/
      {
         /* 29/10/92 do an event anyway - original fix can fail on A4 portable */
         _kernel_swi(OS_Mouse, &r, &r);
         wr_event_process();  /*-- give wimp chance to sort itself out --*/
         wr_event_process();  /*-- give wimp chance to sort itself out --*/
         wr_event_process();  /*-- give wimp chance to sort itself out --*/
         wr_event_process();  /*-- give wimp chance to sort itself out --*/
         wr_event_process();  /*-- give wimp chance to sort itself out --*/
         wr_event_process();  /*-- give wimp chance to sort itself out --*/
      } while(r.r[2] != 0);
   }
}


// *************************************************************************
void _TApplication::Free()
{
   WaitForMouseRelease();  // 18/11/92
   // ??? deinstall unknown event processors & load event handlers ???

   _THandler::Free();
}


typedef struct TEachList
   {
      unsigned a;
      unsigned b;
      unsigned c;
      unsigned d;
      unsigned e;
      unsigned f;
      unsigned g;
      unsigned h;
   } TEachList;

// *************************************************************************
void _TApplication::EachHandler(TObject object, THandler aFirstHandler,
                                DoToHandler procToDo, ...)
{
   THandler currHandler;
   THandler nextHandler;
   char *args = (char *)&procToDo + sizeof(procToDo);
   DECLARE(this);

   currHandler = aFirstHandler;
   while (currHandler != NULL)
   {
      nextHandler = currHandler->fNextHandler;
      procToDo(object, currHandler, *(TEachList *)args);
      currHandler = nextHandler;
   }
}


// *************************************************************************
void app_OpenDir(char *theFilename)
{
   if (theFilename != NULL)
   {
      char *lastDot = strrchr(theFilename, '.');

      if (lastDot != NULL)
      {
         //  open the dir
         Str255 tempBuf;
         int filenameSize = lastDot - theFilename;

         if (filenameSize <= 239)
         {
            // oscli can only handle 255 chars so only open the dir if
            // its pathname is not too long
            strcpy(tempBuf, "%Filer_OpenDir ");
            strncat(tempBuf, theFilename, filenameSize);
            tempBuf[filenameSize + 15] = '\0';
            wr_os_cli(tempBuf);
         }
      }
   }
}

#if defined TRACE || ! defined NETWP
// *************************************************************************
void wr_baricon__win_event_handler(wr_wimp_eventstr *e, void *handle)
{
   handle = handle;
   if (e->e == wr_wimp_EBUT) 
   {
#if DEMO == 0 && ! defined TRACE && ACORNSP == 1
      if (e->data.but.m.i == SP_icon_handle)
      {
         // 24/02/93 [20801] bring illegal use window to front
         wr_wimp_wstate state;

         wr_wimpt_noerr(wr_wimp_get_wind_state(SP_win_handle, &state));
         state.o.behind = -1;
         wr_wimpt_noerr(wr_wimp_open_wind(&state.o));
         return;
      }
#endif
      if ((e->data.but.m.bbits & wr_wimp_BLEFT) != 0)
         // 08/08/92 left click : read blank paper if present
         SelectFromPadMenu();
      else
         app_OpenDir(gLastFile);
   }
}
#endif


// *************************************************************************
void _TApplication::OpenNew()
{
   FailInfo  fi;
   volatile TDocument aDocument = NULL;

   BeginProgress();
   CatchFailures(&fi);

   FailSpaceIsLow();
   aDocument = DoMakeDocument(gMainFileType, TRUE);
                                 // 03/02/93 KindOfDocument(itsCmdNumber, NULL));
   aDocument->DoInitialState();
   // AddDocument(aDocument);    // 20/06/96 moved before DoMakeWindows in case of failure
   aDocument->UntitledName(); // 04/09/96 [27068] moved before DoMakeWindows for Documents menu
   aDocument->DoMakeWindows();
   FailSpaceIsLow();
   // 04/09/96 aDocument->UntitledName();
   AddDocument(aDocument);    // 04/09/96 [27068] should be last thing before Success

   Success(&fi);

   HideProgress();
   return;

// +++++++++++++++++ Exception handler ++++++++++++++++++++++++++++
Rescue:
   HideProgress();
   FreeIfObject(aDocument);
   FailNewMessage(&fi, msgNewFailed);
// 07/06/91 done by FNM   ContinueFailure(&fi);
}


// *************************************************************************
void _TApplication::OpenOld(AppFile &anAppFile)
{
   FailInfo  fi;
   volatile TDocument aDocument = NULL;
   TDocument otherDoc;
   char *errorParm3 = anAppFile.fName;   // 17/11/91 reset to doc before fail

   if (anAppFile.fType != 0)  // ignore if dictionary file
   {
      BeginProgress();
      CatchFailures(&fi);
      // if already open, bring window to front & jump to rescue
      otherDoc = AlreadyOpen(anAppFile.fName);
      if (otherDoc != NULL)
         otherDoc->OpenAgain();  // 03/02/93 itsOpenCmd, aDocument);

      FailSpaceIsLow();
      aDocument = DoMakeDocument(anAppFile.fType, TRUE);
                                // 03/02/93 KindOfDocument(itsOpenCmd, &anAppFile));
      if (anAppFile.fName == NULL)
      {
         aDocument->ReadFromRamFile(anAppFile, kForDisplay);// 11/05/92 extra param for merge
         aDocument->UntitledName();
      }
      else
      {
         if (strrchr(anAppFile.fName, '.') != NULL)   // 06/01/94 [21213] ignore scrap files
         {
            DisposIfHandle(gLastFile);                // 29/07/93 for Adj click on icon bar
            gLastFile = NewString(anAppFile.fName);
         }
         aDocument->ReadFromFile(anAppFile, kForDisplay);
      }
      // 14/11/92      aDocument->DoMakeViews(kForDisplay);
      // AddDocument(aDocument);    // 20/06/96 moved before DoMakeWindows in case of failure
      aDocument->DoMakeWindows();
      FailSpaceIsLow();
      AddDocument(aDocument);    // 04/09/96 [27068] should be last thing before Success

      Success(&fi);
      HideProgress();
   }
   return;

// ++++++++++++ exception handler +++++++++++++++++++++++++
Rescue:
   HideProgress();
   FreeIfObject(aDocument);

   if (fi.error != 0)
   {
      if (fi.message == 0)
         gErrorParm3 = errorParm3;
      FailNewMessage(&fi, msgOpenFailed);
// 07/06/91 done by FNM      ContinueFailure(&fi);
   }
   // resume if no error
}


// *************************************************************************
void _TApplication::PerformCommand(TCommand command)
{
   if (command != gNoChanges)
   {
      FailInfo fi;
      bool     saveCmd;
      unsigned int eMsg;

#ifdef TRACE
      Assert(command, 64);
      Assert(command != gNoChanges, 64);
#endif
#ifdef DRAGDROP
      if (command->fChangedDocument == NULL ||
                             command != command->fChangedDocument->fLastCommand)
#else
      if (command != gLastCommand)
#endif
      {
         if ((saveCmd = (command->fCausesChange || command->fCanUndo)) == TRUE)
#ifdef DRAGDROP
         {
#ifdef TRACE
            Assert(command->fChangedDocument, 740);
#endif
            command->fChangedDocument->CommitLastDocCommand();  // 20/04/93 [20838]
         }
#else
            CommitLastCommand();
#endif

         CatchFailures(&fi);

         gClipClaimed = FALSE;
         command->DoIt();
         Success(&fi);

         if (saveCmd)
         {
#ifdef DRAGDROP
            command->fChangedDocument->fLastCommand = command;  // 20/04/93 [20838]
#else
            gLastCommand = command;
#endif
            command->fCmdDone = TRUE;
         }

         if ((command->fCausesChange) && (command->fChangedDocument != NULL))
            command->fChangedDocument->UpdateChangeCount(1);

         if (!saveCmd)
            command->Free();
      }
#ifdef TRACE
      else
         Assert(0, 742);
#endif
      return;
// ----------------------- exception handler ------------------------------
Rescue:
      if (gClipClaimed)
      {
         gClipView = gClipUndoView;
         gClipUndoView = NULL;
         gClipClaimer = NULL;
      }
      MarkDamagedDoc(&fi, command->fChangedDocument);  // 22/02/94 [21414]
      eMsg = command->fCmdNumber | (msgCmdErr << 16);
      command->Free();
      FailNewMessage(&fi, eMsg);
   }
}


// *************************************************************************
void _TApplication::CommitLastCommand()
{
   app_AbandonClipboard(gClipUndoView);  // 12/03/93 pass clipview
   gClipUndoView = NULL;
#ifndef DRAGDROP
   if (gLastCommand != NULL)
   {
      if (gLastCommand->fCmdDone)
         gLastCommand->Commit();
      gLastCommand->Free();
      gLastCommand = NULL;
   }
#endif
}

// *************************************************************************
void FinishIdle()
{
   if (gIdlePhase != idleBegin)
   {
      gIdlePhase = idleBegin;       // 10/12/90 if done after can recurse
      gApplication->Idle(idleEnd);
   }
}

// *************************************************************************
static void DesktopSave(int file_handle)
{
   char *runMsg = GetRsrcMisc(6);
   char buf[512];
   int strLen;

   if (runMsg != NULL)
   {
     char *p;
     char *q = buf;     // used at end if no options

     // 26/04/94 [21709] new bit to Set App$Options ...
     sprintf(q, "Set %s$Options ", gProgName);
     p = q + strlen(q);                              // pointer to end
     for (int i = 'a'; i <= 'z'; i++)
     {
        char *rsrc = GetRsrcOption(i);               // get option string

        if (rsrc != NULL)
        {
           *(p - 1) = ' ';                           // insert space over previous end
           *(p++) = i;                               // save code letter
           p = strcpy(p, rsrc);
           p += strlen(p);                           // copy rsrc string
           *(p++) = 10;                              // add return
           q = p;         // 01/03/95 [23030] avoid options line if no opts set
        }
     }

     sprintf(q, runMsg, gDirName);  // append Run Appn line
     strLen = strlen(buf);
     buf[strLen] = 10;              // add return
     FSWrite(file_handle, strLen + 1, buf);
   }
}

#ifdef DRAGDROP
// *************************************************************************
static void ResetDragCursor(int theirFlags)
{
   int oldPointer = gDragPointer;

   gDragPointer = theirFlags;         // 17/08/95 & 1;
   if ((oldPointer & 1) != 0 && (theirFlags & 1) == 0)
      ForceCursor(gDragPointerShape);     // reset cursor back to original shape

   // need to see if b1 set to remove drag box
   if (gStartDragger && (oldPointer & 2) != (theirFlags & 2))  // it has changed
   {
      gStartDragger->fFeedbackBox = ((theirFlags & 2) ? wr_wimp_USER_HIDDEN : wr_wimp_USER_FIXED);
      gStartDragger->StartDrag(gAnchorPoint, gAnchorPoint);  // both points ignored
   }
}

void ClearDragSelection(TDocument);

// *************************************************************************
static void DoSendDraggingMsg(wr_wimp_msgstr *msg)
{
   if (gDragClaimant != 0)
   {
      msg->hdr.your_ref = gDragClaimantRef;  // should be set if gDragClaimant set
      wr_wimpt_noerr(wr_wimp_sendmessage(wr_wimp_ESENDWANTACK, msg, gDragClaimant));
   }
   else
   {
      msg->hdr.your_ref = 0;
      wr_wimpt_noerr(wr_wimp_sendwmessage(gDragFinished ? wr_wimp_ESENDWANTACK : wr_wimp_ESEND,
                                   msg, msg->data.words[0], msg->data.words[1]));
   }
}


// *************************************************************************
static void SendDraggingMsg(wr_wimp_mousestr *m)
{
   wr_wimp_msgstr msg;
   int i;

   msg.hdr.action = Message_Dragging;
   msg.data.words[0] = m->w;
   msg.data.words[1] = m->i;
   msg.data.words[2] = m->x;
   msg.data.words[3] = m->y;
   memcpy(gClaimWords, msg.data.words, 36);
   msg.data.words[4] = 2 | gDragShift | gDragQuit;
   memcpy(msg.data.words + 5, &gDragBox, 16);
   i = gApplication->SetSendingTypes(msg.data.words + 9, gDragTypes);
   msg.data.words[9 + i] = -1;
   msg.hdr.size = sizeof(wr_wimp_msghdr) + 4 * (10 + i);
   DoSendDraggingMsg(&msg);
}

// *************************************************************************
TCommand _TApplication::DoMakeMoveCommand(TObject pasteSelection, TDocument doc,
                                                        TPasteCommandType defltCmd)
{
   return MakeMoveCommand(pasteSelection, doc,
               gDragShift ? defltCmd ^ (kCopyCommand ^ kMoveCommand) : defltCmd);
}

// *************************************************************************
void FinishDrag(wr_wimp_msgstr *msg, bool quitDragging)
{
   if (!quitDragging)   // if not aborted!!
   {
      TObject pasteSel = (gTracker ? gTracker->fPasteSelection : NULL);
      TDocument startDocument = gStartWindow->fDocument;
      CmdNumber cmdToDo = cSaveSelection;

      if (startDocument == NULL)
      {
#ifdef TRACE
         Assert(gStartDragger, 902);
#endif
         startDocument = gStartDragger->CreateTextDocument(gDragShift);
         msg->data.words[4] &= ~8;  // do not try to clear selection if shift pressed
         gDragShift = 0;
         cmdToDo = cNoCommand;      // forces temp doc to be freed after save complete
      }
      if (pasteSel != NULL && msg->hdr.my_ref != 0 && msg->hdr.task == wr_wimpt_task())
      {
         // there is a claimer && it is another of our windows
         TCommand moveCmd = gApplication->DoMakeMoveCommand(pasteSel, startDocument,
           gCurrWindow && gCurrWindow->GetWindow() == gStartWindow ? kMoveCommand : kCopyCommand);
         TDocument moveCmdDoc = moveCmd->fChangedDocument;

         gTracker->fPasteSelection = NULL;  // avoid freeing now it has been given away
         gApplication->PerformCommand(moveCmd);

         //if (gStartWindow->fDocument == NULL)        // temp doc created above
         //   FreeIfObject(startDocument);
         //else
         if (startDocument != moveCmdDoc && gDragShift)
            ClearDragSelection(startDocument);
      }
      else
         startDocument->SaveData(msg, cmdToDo);
   }
   else if (gDragClaimant != 0)
   {
      // 10/11/93 [21112] we are quitting with someone else still tracking
      wr_wimp_mousestr m;

      gDragQuit = 16;
      wr_wimpt_noerr(wr_wimp_get_point_info(&m));
      SendDraggingMsg(&m);
      return;
   }
   gDragClaimant = 0;      // 10/11/93 [21112] so we know above did not fail
   RemoveTracker(gStartDragger);
   gDragQuit = 0;          // 11/10/93 [21073] not being cleared after <Escape>
   ClearObject(gStartDragger);
   // FreeIfObject(gStartDragger);
   // gStartDragger = NULL;
}

// *************************************************************************
TObject _TApplication::CheckDragDrop(EventInfo &info)
{
   TObject res = NULL;

   // test if this is a save as a result of a dragdrop action
   if (gTracker != NULL && gLastClaim != 0 &&
        (gLastClaim == info.event->data.msg.hdr.your_ref ||
           gLastClaimYref == info.event->data.msg.hdr.your_ref || // 17/08/95 Iota gets it wrong
           info.event->data.msg.hdr.your_ref == 0))    // [24009] StrongEd gets it wrong
   {
      TCommand TrackMouse_res;

      // force a stop to the dragging
      info.theTrackPhase = trackRelease;
      res = gTracker->fPasteSelection;
      gTracker->fPasteSelection = NULL;
      TrackMouse_res = TrackMouse(gClaimMouse, gTracker, info);  // result ?
#ifdef TRACE
      Assert(TrackMouse_res == gNoChanges, 525);
#endif
      info.theShiftKey = gDragShift;
   }
   return res;
}

#ifdef TRACE
// *************************************************************************
int _TApplication::GetDragKeys(int *filetypes)
{
   return 0;  // overridden
}
#endif

// *************************************************************************
static void SetClaimReply(wr_wimp_msgstr *msg)
{
   int our_i = 1, their_i;
   int *our_type;

   msg->hdr.your_ref = msg->hdr.my_ref;
   msg->hdr.action = Message_DragClaim;
   // too early: msg->data.words[0] = gPointerAltered; // 17/08/95 indicates remove dragbox too
               // copy delete source flag & indicate if cursor altered

   // need to be careful that we do not overwrite the input list
   // which is possible if gFileType contains more than 8 entries
   
   for (our_type = gFileType; *our_type != -1; our_type++)
   {
      their_i = 9;
      do
      {
         if (msg->data.words[their_i] == *our_type)
         {
            int orig_i = their_i;

            if (our_type == gFileType)      // D01 file type
            {
               while (msg->data.words[their_i + 1] == *our_type)
                 their_i++;
            }
#ifndef MATHS
#ifdef TABLES
            if (their_i - orig_i < 2)  // cannot handle maths in EW or SW
#else
            if (their_i == orig_i)     // cannot handle tables in SW
#endif
#endif
            {
              msg->data.words[our_i++] = *our_type;
              break;
            }
         }
      }
      while (msg->hdr.size > their_i * 4 + sizeof(wr_wimp_msghdr) + 4 &&
                                                       msg->data.words[their_i++] != -1);
   }
   // 17/08/95 avoid leaving off -1 term if sender did too: do ... while (*(our_type++) != -1);
   msg->data.words[our_i] = -1;
   msg->hdr.size = sizeof(wr_wimp_msghdr) + 4 + (our_i * 4);
}
#endif


// *************************************************************************
bool DoPrinterChangeMsg()
// 02/06/94 see if it has really changed
{
   TPrint newData;
   char *printDrName;
   int features;
   THPrint prInfo = &newData;

   memcpy(prInfo, gPrinterDetails, sizeof(TPrint)); // 05/07/95 memset(prInfo, 0, sizeof(TPrint));
   printDrName = GetPrinterDetails(prInfo, &features);

   if (memcmp(prInfo, gPrinterDetails, sizeof(TPrint)) != 0 || (printDrName != NULL &&
                     strcmp(printDrName, ((char *)gPrinterDetails) + sizeof(TPrint)) != 0))
   {
      SetLastPrintChange();
      memcpy(gPrinterDetails, prInfo, sizeof(TPrint));
      if (printDrName != NULL)
        strncpy(((char *)gPrinterDetails) + sizeof(TPrint), printDrName, 20);
   }
   return TRUE;
}

// *************************************************************************
void app_InsertFileOK(wr_wimp_msgstr *msg)
{
/* An insert has been completed successfully. This sends an acknowledge back
   to the original application. The msg should be original DATALOAD */

#ifdef TRACE
   Assert(msg->hdr.action == wr_wimp_MDATALOAD || msg->hdr.action == wr_wimp_MDATAOPEN, 609);
#endif
   if (msg->hdr.your_ref)      // !appFile->fFileIsSafe)
   {
      /* Must delete scrap file */
      wr_os_cli("%remove <Wimp$Scrap>");
   }
   // msg->hdr.action = wr_wimp_MDATALOADOK;
   // what xferrecv did is wrong according to PRM: msg->hdr.size = sizeof(wr_wimp_msghdr);
   // msg->hdr.your_ref = msg->hdr.my_ref;
   // wr_wimp_sendmessage(wr_wimp_ESEND, msg, msg->hdr.task);
   Sendmessage(wr_wimp_MDATALOADOK, msg, msg->hdr.size);
}

// *************************************************************************
int _TApplication::DoDataLoad(wr_wimp_msgstr *msg, AppFile &anAppFile)
{
   // 09/07/95 [26034] LoadFile redone to get rid of xferrecv
   FailInfo fi;

   FinishIdle();
   CatchFailures(&fi);
   OpenOld(anAppFile);
   Success(&fi);

Rescue:
   if (msg->hdr.action != wr_wimp_MDATASAVE)
      app_InsertFileOK(msg);     // indicate load completed

   ContinueIfFail(&fi);
   return TRUE;
}

#ifdef NETWP
// *************************************************************************
void DisplayHelpText(TObject obj, TWindow aWindow, char *text)
{
   TControl status = TControl(aWindow->FindSubView(I_('d', 'r', 'a', 'g')));

   if (status != NULL)
   {
     char buff[128];

     if (obj)
     {
       // add the text to what's showing
       status->GetText(buff);
       if (*buff)
         strcat(buff, " ");
     }
     else
     {
       buff[0] = 0;
     }
     strcat(buff, text);
     status->SetText(buff, obj ? -1 : kRedraw);
   }
}
#endif

// *************************************************************************
static void ReleaseClaimedEntity(wr_wimp_msgstr *msg)
{
   if ((msg->data.words[0] & 4) != 0)
   {
     // Someone else has claimed the clipboard
     app_AbandonClipboard(gClipUndoView);
     gClipUndoView = NULL;
     app_AbandonClipboard(gClipView);
     gClipView = NULL;
     gClipClaimer = NULL;
     gExternalClip = -1;             // someone has got clipboard, so enable Paste menu
                                     // ... not ideal, we do not know what type of data
                                     // they hold, they might change it without telling
                                     // us, and they might quit without telling anybody
   }
   else if ((msg->data.words[0] & 3) != 0)
   {
     // for each document, Collapse Selection
   }
}

// *************************************************************************
_TApplication::HandleMsgEvent(EventInfo &info)
{
   wr_wimp_msgstr *msg = &info.event->data.msg;
   AppFile anAppFile;
#ifndef NETWP
   bool old3D;
#endif
   TWindow theWindow;

   anAppFile.fFileIsSafe = FALSE;
   anAppFile.fName = NULL;     // for DATASAVE
   switch (msg->hdr.action)
   {
      case wr_wimp_MDATALOAD:
         // file dragged onto iconbar
      case wr_wimp_MDATAOPEN:
         // double click on a file icon
         // anAppFile.fType = xferrecv_checkinsert(&anAppFile.fName);
         if (info.event->data.msg.hdr.your_ref == 0)
            anAppFile.fFileIsSafe = TRUE;
         anAppFile.fName = msg->data.dataload.name;

      case wr_wimp_MDATASAVE:
         // file icon saved to icon bar icon (NB dataload & datastruct fields coincide)
         // or (if w and i are both -1) it is acknowledgement that another app has clipboard
         if ((msg->data.dataload.w & msg->data.dataload.i) == -1)
            gExternalClip = msg->data.dataload.type;   // note type, and quietly forget the data
         else
         {
            anAppFile.fType = msg->data.dataload.type;
            anAppFile.fEstSize = msg->data.dataload.size;
            if ((msg->hdr.action != wr_wimp_MDATAOPEN || CanOpenDocument(cOpen, anAppFile)) &&
                                                              CanReadDocument(anAppFile, 0))
               return DoDataLoad(msg, anAppFile);
         }
         break;

      case wr_wimp_MPREQUIT:
         FinishIdle();
         // 22/04/94 done by close itself gAppDone =
         Close(msg);
         return(!gAppDone);

      case Message_Shutdown:
         // 05/05/94 [21721] handle shutdown messages
         gDocList->Each(NULL, (DoToObject)ShutdownDoc, &info);
         return TRUE;

      case wr_wimp_MMODECHANGE:
         // change work area extent so it fits on-screen
         FinishIdle();
         ResetModeVariables();
         wr_wimpt_checkmode();     // 28/06/91
#ifdef NETWP
         ForAllWindowsDo(NULL, (DoToObject)app_SetWindowExtent, 0);
#else
          // 08/03/93 [20806] see if 3D state changed & pass to windows
         old3D = g3Dicons;
         if (gWimpVersion >= 316 && g3Dicons < 2)
           g3Dicons = ReadCMOS3D();
         old3D ^= g3Dicons;
         ForAllWindowsDo(NULL, (DoToObject)app_SetWindowExtent, old3D); // 08/03/93 [20806]
         if (old3D)
           return FALSE;
#endif
         break;

      case wr_wimp_MSETSLOT:
         // set the slot for the task manager
         if (msg->data.words[1] == wr_wimpt_task())
         {
            FinishIdle();
            return(HandleSetSlotEvent(msg));
         }
         break;

      case wr_wimp_MHELPREQUEST:
         info.affectsMenus = FALSE;
         if (GetMenuHelp(msg))
         {
           // 26/07/96 do anyway: info.affectsMenus = FALSE;
           return SendHelpReply(msg);
         }
#ifdef NETWP
         else
         {
           *msg->data.helpreply.text = 0;
           return SendHelpReply(msg);
         }
#endif
         break;

#ifdef NETWP
      case wr_wimp_MHELPREPLY:
         ForAllWindowsDo(NULL, (DoToObject)DisplayHelpText, msg->data.helpreply.text);
         break;
#endif

      case wr_wimp_SAVEDESK:  // 21/10/91 desktop save
         DesktopSave(msg->data.savedesk.filehandle);
         break;

      case Message_PrintError:        // 25/11/93 [21133]
         if (msg->hdr.size > 20)                     // RISC_OS3 format
           FailOSErr((wr_os_error *)msg->data.words);
         FailGeneral(42);

      case wr_wimp_MPrintTypeOdd:
         // broadcast when strange files dropped onto printer icon
         if (msg->hdr.your_ref == 0)  // 26/01/93 [20601] ignore RiscOS3 spurious msg before save
         {
            // in-line: anAppFile.fType = xferrecv_checkprint(&anAppFile.fName);
            // anAppFile.fFileIsSafe = FALSE;   // that was what checkprint did - sounds dubious??
            anAppFile.fFileIsSafe = TRUE;       // 10/07/95 [26035] stop whole file being loaded
                                                // should be OK assuming no poll before complete
            anAppFile.fType = msg->data.print.type;
            anAppFile.fName = msg->data.print.name;
            anAppFile.fEstSize = 0; 
            if (CanOpenDocument(cPrint, anAppFile))
            {
               FinishIdle();
               // in-line: xferrecv_printfileok(0 /* gMainFileType */);
               msg->data.print.type = 0;      // unnecesary?? (that is what param above does)
               // msg->hdr.size = sizeof(wr_wimp_msghdr) + sizeof(wr_wimp_msgprint);  // bit big??
               // msg->hdr.action = wr_wimp_MPrintTypeKnown;
               // msg->hdr.your_ref = msg->hdr.my_ref;
               // wr_wimp_sendmessage(wr_wimp_ESEND, msg, msg->hdr.task);
               Sendmessage(wr_wimp_MPrintTypeKnown, msg,
                                           sizeof(wr_wimp_msghdr) + sizeof(wr_wimp_msgprint));

               PrintDocument(anAppFile);   // must not poll events
               return TRUE;
            }
         }
#ifdef TRACE
         else
           Assert(0, 348);  // PrintTypeOdd with your_ref != 0 should be picked up elsewhere
#endif
         break;

      case wr_wimp_MPrinterChange:
        FinishIdle(); // 07/06/95 [26010] to get the button reset
        // new printer application installed
        return DoPrinterChangeMsg();

      case Message_MenusDeleted: // 27/10/93 [21103] menu closed
        if (CurrentSyshandle() == wr_wimp_menuptr(msg->data.words[0]))
        {
#ifdef NETWP
           // Get control (if any) which reflects menu state to change
           if (gEnabledControls != NULL)
              gEnabledControls->Each(NULL, (DoToObject)GetControlToReflectMenuState,
                                     wr_wimp_menuptr(msg->data.words[0]));
#endif
           CloseCurrentMenu();
        }
        break;

      case Message_WindowInf: // 08/10/92 redone properly
        if (msg->data.words[0] != 0)
        {
          theWindow = WimpToWindow(msg->data.words[0]);            // find window closed
          if (theWindow != NULL && theWindow->fDocument != NULL)   // 06/09/94 && not dlog
          {
             char *p = (char *)memset((char *)(msg->data.words + 1), 0, 32);

             p = strncpy(p + 4, gProgName, 7);  // ic_nnnnnnn
             // 06/09/94 moved up (ignore msg if dlog): if (theWindow->fDocument != NULL)
             theWindow->fDocument->GetLeafName(p + 8);
             //else if (theWindow->fTitle != NULL)
             // strncpy(p + 8, theWindow->fTitle, 19); // 06/09/94 needed for wordlists, etc.
             p[27] = 0;          // safety - terminate name at 19 chars
             info.affectsMenus = FALSE;
             // msg->hdr.size = 56;
             // msg->hdr.your_ref = msg->hdr.my_ref;
             // wr_wimpt_noerr(wr_wimp_sendmessage(wr_wimp_ESEND, msg, msg->hdr.task));
             wr_wimpt_noerr(Sendmessage(Message_WindowInf, msg, 56));
             // 03/09/93 [21042] lose the caret if in the window being iconized
             if (theWindow->fWindowRecord.HasInputFocus())
             {
                wr_wimp_caretstr caret;

                caret.w = -1;                                  // turn it off
                wr_wimpt_noerr(wr_wimp_set_caret_pos(&caret));
             }
             return TRUE;
          }
        }
        break;

#if defined DRAGDROP || defined NETWP
      case Message_ClaimEntity:   // 12/03/93 [20707]
        if (msg->hdr.task != wr_wimpt_task())      // ignore messages from me
        {
          ReleaseClaimedEntity(msg);
          FinishIdle();   // 16/04/93 may be able to release memory
          return TRUE;  // does affect menus, and it has been dealt with
        }
        break;

      case Message_DataRequest:   // [20707]
        if ((msg->data.words[4] & 4) != 0)
        {
          TDocument clipDoc;

          if (gClipView != NULL && (clipDoc = gClipView->fDocument) != NULL)
          {
             // convert to Message_Dragging format
             msg->data.words[4] &= ~8;       // cannot easily delete clipboard
             // 14/07/95 done in correct place: DoSaveSend: msg->hdr.your_ref = msg->hdr.my_ref;
               // 09/11/93 [21110] DataPower needs this set when pasting from our clipboard
             memmove(msg->data.words + 9, msg->data.words + 5, Min(msg->hdr.size - 40, 200));
             memset(msg->data.words + 5, 0, 16);
             clipDoc->SaveData(msg, cSaveClip);  // send whole clipdoc
          }
        }
        else
        {
          // cannot send anything until/if we support a global selection
          // If we did: docWithSelection->SaveData(msg, cSaveSelection)
        }
        break;
#endif

#ifdef NETWP
      case Message_Service:
        if ((msg->data.words[2] & 1) == 0)
          gDocList->Each(NULL, (DoToObject)CloseADocument, FALSE);
        break;
#endif

#ifdef DRAGDROP
      case Message_Dragging:      // [20707]
        OStoQDPt(msg->data.words[2], msg->data.words[3], gClaimMouse, ScreenHeight());
        theWindow = NULL;
        if (gTracker != NULL)     // already claiming drag
        {
           // see if window (msg->data.words[0] == -2) for over icon bar!!!
           theWindow = WimpToWindow(msg->data.words[0]);  // find window under mouse

           if ((msg->data.words[4] & 16) != 0 ||   // user has hit <Esc>, etc
              gTracker->fView == NULL || theWindow == NULL || // or we are not in our window
              gTracker->fView->GetWindow() != theWindow->GetWindow())
           {
              TCommand TrackMouse_res;

              info.theTrackPhase = trackRelease;    // to undraw the ghost cursor
              TrackMouse_res = TrackMouse(gClaimMouse, gTracker, info);
#ifdef TRACE
              Assert(TrackMouse_res == gNoChanges || TrackMouse_res == gStartDragger, 527);
#endif
              break;
           }
           SetClaimReply(msg);  // this overwrites msg, so call after accessing drag fields
           info.theTrackPhase = trackMove;
        }
        else if ((msg->data.words[4] & 16) == 0) // if not to be ignored
        {
           // Set up gTracker if in the main window (ignore icon bar, etc.)
           theWindow = WimpToWindow(msg->data.words[0]);  // find window under mouse

           if (theWindow != NULL && theWindow->Focus())
           {
              VPoint where, theVMouse, theMouse;
              TCommand aCommand = gNoChanges;
              int enterRef = msg->hdr.your_ref;

              OStoQDPt(msg->data.words[2], msg->data.words[3], where, ScreenHeight());
              theMouse = where;
              theWindow->fWindowRecord.GlobalToLocal(theMouse);
              theWindow->QDToViewPt(theMouse, theVMouse);
              info.theTrackPhase = trackPress;
              info.trackingKey = GetDragKeys(msg->data.words + 9);

              gPointerAltered = 1;  // 17/08/95 set/keep pointer changed
              SetClaimReply(msg);   // this overwrites msg, so call after accessing drag fields
              if (msg->data.words[1] != -1)    // we liked at least one file type
              {
                 // using fileIsSafe is bit of a frig - but a handy flag set to zero at start
#define replyToDragging anAppFile.fFileIsSafe
                 if (enterRef == 0)     // just entering window if sender is obeying rules
                    ForceCursor(GetCursor(13));  // force in case gone out & re-entered window
                 replyToDragging = TRUE;         // 17/08/95 reply to dragging msg
                 if (theWindow->HandleMouseDown(theVMouse, info, aCommand) &&
                                                       aCommand != gNoChanges)
                 {
                    InstallTracker(aCommand);
                    aCommand->fFeedbackBox = -1;  // controlled externally
                 }
              }
           }
        }
        if (gTracker != NULL || replyToDragging)  // 17/08/95 reply too if cursor reset
        {
          // TCommand TrackMouse_res = 
          if (gTracker != NULL)
             TrackMouse(gClaimMouse, gTracker, info);     // set and draw ghost cursor

          msg->data.words[0] = gPointerAltered & (msg->hdr.task == wr_wimpt_task() ? 1 : 3);
                      // 17/08/95 indicates remove dragbox too if not one of our windows
          wr_wimpt_noerr(wr_wimp_sendmessage(
                  wr_wimp_ESEND,
                  msg,
                  msg->hdr.task));

          gLastClaim = msg->hdr.my_ref; // 17/08/95 use spec not do what DataPower does: your_ref;
          gLastClaimYref = msg->hdr.your_ref; // 17/08/95 what DataPower returns
          gCurrWindow = theWindow;
          info.affectsMenus = FALSE;
          return TRUE;
        }
        break;

      case Message_DragClaim:   // [20707]
         {
            // need to see if b1 set to remove drag box
            int theirFlags = msg->data.words[0] | gDragShift; // DataPower clears delete!

            if (gDragFinished)
            {
               if ((theirFlags & 1) != 0)
                  ForceCursor(gDragPointerShape);   // reset pointer shape

               // move file list up to be same format as Dragging
               memmove(msg->data.words + 9, msg->data.words + 1,
                                                      Min(msg->hdr.size - 24, 200));
               memcpy(msg->data.words, gClaimWords, 36);
               msg->data.words[4] = theirFlags;
               FinishDrag(msg, gDragQuit);
            }
            else
            {
               ResetDragCursor(theirFlags);
               gDragClaimant = msg->hdr.task;
               gDragClaimantRef = msg->hdr.my_ref;  // 17/08/95 do as spec: your_ref;
            }
         }
         break;
#endif

#ifdef THESAURUS
      case Message_ThesaurusStarting:  // 26/02/93 [20802]
        gThesaurus = TRUE;
        return FALSE;  // pass on, but does affect menus

      case Message_ThesaurusDying:  // 26/02/93 [20802] - see if another left
        wr_wimpt_noerr(BroadcastWantAck(Message_ThesaurusQuery, msg, 20));  // send recorded msg
        break;

      case Message_ThesaurusSend:  // 26/02/93 [20802]
        {
          TWindow theWindow = GetActiveWindow();

          if (theWindow != NULL)
            return wind_HandleEvent(info.event, (void *)theWindow);
        }
        break;
#endif
   }
   info.affectsMenus = FALSE;      // 11/05/90
   return FALSE;
}


// *************************************************************************
bool app_HandleEvent(wr_wimp_eventstr *e, void *handle)
{
   EventInfo   info;
   TCommand    commandToPerform = gNoChanges;
   FailInfo fi;

#ifdef TRACE
   Assert(handle == NULL, 666);
#endif

   gFull = FALSE;                                       // 18/12/90

   // 03/12/90 win sends these events to application rather than window
   if (e->e == wr_wimp_ELOSECARET || e->e == wr_wimp_EGAINCARET)
   {
      TWindow theWindow;

#if SIDEBAR == 1
      // 01/05/95 [25010] sticky keys (ignore result os SWI)
      if (gStickyOption != NULL)
         wr_os_swi2(0x0004a0c0 | wr_os_X, e->e - wr_wimp_ELOSECARET, wr_wimpt_task());
#endif
      theWindow = WimpToWindow(e->data.c.w);
      if (theWindow != NULL)
         return wind_HandleEvent(e, (void *)theWindow);
      return FALSE;
   }

   CatchFailures(&fi);

   gApplication->PreHandleEvent(e);

   app_GetEventInfo(&info, e);

   commandToPerform = gApplication->HandleEvent(info);

   gApplication->PerformCommand(commandToPerform);

   gApplication->PostHandleEvent(TWindow(handle), info);

   Success(&fi);
   return info.eventHandled;

Rescue:
   return DoRescue(fi);
}

#ifdef DRAGDROP
#ifdef TRACE
// ------------------------------------------------------------------------
int _TApplication::SetSendingTypes(int *types, int selFlags)
{
  return 0;
}
#endif
#endif

// *************************************************************************
TCommand _TApplication::DoTrackMouse(EventInfo &info)
{
   Point theMouse;
   wr_wimp_mousestr m;
#ifdef DRAGDROP
   TWindow lastWindow = gWindowWithPointer;
#endif

   GetMouseInfo(&m);

   gWindowWithPointer = WimpToWindow(m.w);
   if (gWindowWithPointer == NULL && info.theTrackPhase == trackRelease)
      InitCursor();
          // [20848] 27/04/93 seem to lose Pointer_leaving_window events while dragging
#ifdef DRAGDROP
   // we must not call this as a result of a track in another window
   if (gStartDragger != NULL && !gPreDrag)  // 17/08/93 [21025] ignore if before drag starts
   {
      if (gDragQuit)
      {
         wr_wimp_drag_box(NULL);
         gDragFinished = TRUE;
         info.theTrackPhase = trackRelease;
      }
      if (gDragClaimant != 0)
      {
         // send message to claimant (even though mouse could be back in original window)
         SendDraggingMsg(&m);
         return gNoChanges;
      }
      else
      {
         bool restoreGC = FALSE;

         if (gWindowWithPointer == NULL || gWindowWithPointer->GetWindow() != gStartWindow)
         {
            // see if any window out there wants it
            // RemoveTracker(gStartDragger);  // do after track release
            if (gTracker == NULL)  // force through trackRelease on 'first time'
            {
              SendDraggingMsg(&m);
              return gNoChanges;
            }
            info.theTrackPhase = trackRelease;
         }
         else if (lastWindow == NULL || lastWindow->GetWindow() != gStartWindow)
                                                        // just re-entered start window
            restoreGC = TRUE;

         // mouse is back/still in the original window
         InstallTracker(gStartDragger);  // ?
         if (restoreGC)
            FeedbackOnce(TRUE, TRUE);                   // restore ghost cursor
      }
   }
#endif
   // 16/08/93 [21025] force a release when buttons released before tracking starts
   if (gPreDrag && info.event->e == wr_wimp_ENULL && m.bbits == 0)
      info.theTrackPhase = trackRelease;

   OStoQDPt(m.x, m.y, theMouse, ScreenHeight());
   return(TrackMouse(theMouse, gTracker, info));
}

// *************************************************************************
TCommand _TApplication::HandleEvent(EventInfo &info)
{
   int theEvent = info.event->e;

   switch(theEvent)
   {
      case wr_wimp_EUSERDRAG :
#ifdef DRAGDROP
         gDragFinished = TRUE;
#endif
      case wr_wimp_ENULL :
         //         info.affectsMenus = FALSE;
         // null or drag events shouldnt change the menus. If they do, leave
         // it to the routine which changes them to set the affectsMenu flag
         if (gTracker != NULL
#ifdef DRAGDROP
                        || gStartDragger != NULL
#endif
                         )
         {
            info.theTrackPhase = 
                   (theEvent == wr_wimp_ENULL
#ifdef DRAGDROP
                          && !gDragQuit
#endif
                           ? trackMove : trackRelease);
            return DoTrackMouse(info);
         }
         else if (theEvent == wr_wimp_ENULL)
         {
            // do the idle calling stuff for begin/continue
            Idle(gIdlePhase);
#ifdef TABLES
//          if (gKeyTick == 0)
//             gKeyTick = TickCount(); // 03/07/95 [26023] start timing for repeat quote from idle
#endif
            gIdlePhase = idleContinue;
         }
         break;

      case wr_wimp_ESEND :
      case wr_wimp_ESENDWANTACK :
         info.eventHandled = gApplication->HandleMsgEvent(info);
         break;

      case wr_wimp_EACK:
         {
            wr_wimp_msgstr *msg = &info.event->data.msg;

            if (msg->hdr.action == Message_PrintSave)   // 25/11/93 [21133]
            {
               // should never happen if command only allowed when print driver selected
            }
#ifdef THESAURUS
            else if (msg->hdr.action == Message_ThesaurusQuery)
            {
               // 26/02/93 [20802] No reply from Thesaurus
               gThesaurus = FALSE;
               info.affectsMenus = TRUE;
            }
#endif
#ifdef DRAGDROP
            else if (msg->hdr.action == Message_Dragging) // [20707]
            {

               // No reply to our message to the tracking window
               ResetDragCursor(0);     // 17/08/95 msg->data.words[4]);

               if (gDragClaimant)
               {
                  // we were tracking in someone elses window
                  gDragClaimant = 0;
                  // unnecessary gDragClaimantRef = 0;
                  DoSendDraggingMsg(&info.event->data.msg);  // resend message to window
               }
               else if (gDragFinished)
               {
                  msg->hdr.my_ref = 0;                  // set to indicate no receiver
                  FinishDrag(msg, gDragQuit);
               }
            }
#endif
            else if (msg->hdr.action == Message_DataRequest)
               gExternalClip = FALSE;           // no-one has the global clipboard
            else if (msg->hdr.action == Message_ReleaseEntity) // no clipboard task present
               ReleaseClaimedEntity(msg);       // have to throw it away allowing App to quit
            }
         break;
   }

   return(gNoChanges);
}

// *************************************************************************
void _TApplication::PreHandleEvent(wr_wimp_eventstr *e)
{
   int idleMask = 0x73e00000;

   if (gEventLevel == 0)
     gVisTotal = 0;   // 28/10/90 initialise at base event level
   gEventLevel ++;  // just entered a new event so inc our event level count
   gErrorParm3 = NULL;  // ensure this has not been left as junk

   if ((idleMask << e->e) < 0)
     FinishIdle();
      // 15/08/90 dont end idle on Help request, etc.
}


// *************************************************************************
static void DoIdleAction(TObject null, THandler aHandler,
                                         IdlePhase phase, long currTick)
{
   if (aHandler->fIdleFreq != kMaxIdleTime)
   {
      if (phase != idleContinue || currTick - aHandler->fLastIdle >= aHandler->fIdleFreq)
      {
         if (aHandler->DoIdle(phase))
           return;      // it freed itself!
         aHandler->fLastIdle = currTick;
      }
      if (gIdleFreq > aHandler->fIdleFreq)
         gIdleFreq = aHandler->fIdleFreq;
   }
}


// *************************************************************************
static void DoWindowIdle(TObject null, TWindow aWindow, IdlePhase phase, long currTick)
{
  // 17/05/90 see if any areas currently out of date
  // 21/03/96 moved to window DoIdle
  // if (phase != idleEnd)    // 10/09/91
  //   aWindow->InvalSavedArea();
  gApplication->EachHandler(NULL, aWindow->fTarget,
                           (DoToHandler)DoIdleAction, phase, currTick);
}

// *************************************************************************
static void DummyIdle(int called_at, TApplication self)
{
   wr_event_setmask(0);   // force idle to be passed to us
}


// *************************************************************************
bool _TApplication::TrackCursor(bool reset)
{
  // returns TRUE if in a window where the pointer shape changes according to
  // position. While over such a window, the application will regularly call
  // this function. A nice enhancement would be to return a value indicating
  // whether the mouse was moving towards a 'change' boundary, so that the idle
  // frequency could be increased while possibly moving over the boundary.
  // Alternatively for RISC_OS3 use sprite 'tiles' with P... validation strings!

  wr_wimp_mousestr mouseInfo;

  GetMouseInfo(&mouseInfo);
  if (mouseInfo.w != kNoWindow && mouseInfo.i >= -1)  // in somebodies window
  {
    TWindow cursorWindow;
    Point qdMouse;

    OStoQDPt(mouseInfo.x, mouseInfo.y, qdMouse, ScreenHeight());
    cursorWindow = gWindowWithPointer = WimpToWindow(mouseInfo.w);
    if (cursorWindow != NULL)       // in one of ours
    {
      if (cursorWindow->Focus())
      {
        thePort->GlobalToLocal(qdMouse);
        // cursorWindow->QDToViewPt(qdMouse, theMouse);
        if (cursorWindow->HandleCursor(qdMouse) != NULL)
          return TRUE;     // we have set up a pointer, so ensure fast idles
      }
    }
    // else not in our window, so must be as a result of EPTRLEAVE, init cursor
    // and do not come back in here until we get an EPTRLEAVE, or drag end
  }
  InitCursor();
  return FALSE;
}

#ifdef TRACE
// *************************************************************************
bool _TApplication::DoIdle(IdlePhase phase)
{
   return FALSE;
}
#endif

#ifdef NETWP
// *************************************************************************
static void SendForHelp()
{
   wr_wimp_msgstr msg;

   msg.hdr.my_ref = 0;
   msg.hdr.task = wr_wimpt_task();
   if (CurrentSyshandle() != NULL)
   {
     // menu is shown, give help on that
     msg.data.helprequest.m.w = 0;
     msg.data.helprequest.m.i = 0;
   }
   else
     wr_wimp_get_point_info((wr_wimp_mousestr *)&msg.data);
   Sendmessage(wr_wimp_MHELPREQUEST, &msg, sizeof(wr_wimp_msghdr) + sizeof(wr_wimp_mousestr));
}
#endif

#if TALK == 2
static bool gNoSpeech = TRUE;
#endif

// *************************************************************************
void _TApplication::Idle(IdlePhase phase)
{
   long currTick = TickCount();

   if (phase == idleBegin)
   {
      // 22/03/96 allow for time wrapping round
      if (currTick - gNextSpaceMsg >= 0) // currTick >= gNextSpaceMsg)
      {
         if (MemSpaceIsLow())
         {
           SpaceIsLow();
           gNextSpaceMsg = currTick + 12 * 1024 /* wait at least a couple of minutes */;
         }
         else
           gNextSpaceMsg = currTick;
      }
      SetupTheMenus();
      // gLastIdle = 0;
      // gIdleFreq = 0;
      PruneHeap();                                          // 10/12/90
   }

   if (phase != idleContinue || currTick - gLastIdle >= gIdleFreq)
   {
      gIdleFreq = kMaxIdleTime;
      gLastIdle = currTick;
      EachHandler(NULL, gHeadCohandler, (DoToHandler)DoIdleAction, phase, currTick);
      ForAllWindowsDo(NULL, (DoToObject)DoWindowIdle, phase, currTick);
      DoIdleAction(NULL, this, phase, currTick);  // 14/12/93 do self in case no windows
      // gLastIdle = currTick;
   }

   if (phase != idleEnd)
   {
#ifdef NETWP
      SendForHelp();
#endif
#if TALK == 2
      if (gNoSpeech && Speaking() >= 0)
      {
        gNoSpeech = FALSE;
        gMenusAreSetup = FALSE;
      }
#endif
#ifdef TABLES
      if (gKeyTick == 0)
         gKeyTick = currTick; // TickCount();
             // 03/07/95 [26023] start timing for repeat quote from idle after keystroke
#endif
      if (gWindowWithPointer != NULL && TrackCursor(TRUE) && gIdleFreq > kShortFreq)
         gIdleFreq = kShortFreq;   // 21/03/96 specify period before next cursor check
   }

   // 21/03/96 prepare for next idle
   wr_alarm_removeall(this);
   if (gIdleFreq == 0 || phase == idleEnd)
      wr_event_setmask(0);                       // idle asap please
   else
   {
      wr_event_setmask(wr_wimp_EMNULL);             // finish fast idling
      if (gIdleFreq != kMaxIdleTime)
         wr_alarm_set(currTick + gIdleFreq, (wr_alarm_handler)DummyIdle, this);
         // NB for example: if one handler has freq of 100 and one a freq of
         // 101, the second is liable to only get called every 200 centisecs!
   }
}

#if SIDEBAR != 1
// *************************************************************************
static void InsertIntoDocMenu(TWindow theActiveWindow, TWindow windToInsert,
                                                         MenuHandle* theDocMenu)
{
   // to ensure we do not get dialogue window titles, etc. only add
   // the names of windows with indirected titles (ie. fTitle != NULL)
   if (windToInsert->fDocument != NULL && windToInsert->fTitle != NULL)
   {
      // the window is document based & in displayed on-screen
      int currItemNum;    // 07/09/94 made local
      char title[kMaxDocMenuLength];

      // (*currItemNum)++;
      TruncateText(title, windToInsert->fDocument->fTitle,
                                        kMaxDocMenuLength - 1, dotLeft);
      currItemNum = AppendMenuItem(theDocMenu, title);

      // insert this window into the gWindMenuList
      gWindMenuList->InsertLast(windToInsert);

      // and tick this entry it if it is the active window
      if (theActiveWindow == windToInsert)
         CheckItem(*theDocMenu, currItemNum, TRUE);
   }
}
#endif

// *************************************************************************
void _TApplication::DoSetupMenus()
{
#if SIDEBAR != 1
   MenuHandle* theDocMenu = GetResMenu(cmDocuments);
   TWindow    theActiveWindow = GetActiveWindow();
   //int        currItemNum     = 0;
#endif

   _THandler::DoSetupMenus();

#ifdef NETWP
   if (TRUE)
#else
   if (!gIconBarIsSetup)
#endif
   {
      // enable and set names of application commands like Documents etc.
      // but only if it needs setting up

#if SIDEBAR != 1
      // Set up the documents menu using gWindMenuList
      // first delete whatever items are in the list
      DelMenuItems(theDocMenu, 1);
      gWindMenuList->DeleteAll();

      // now insert the items into it again
      //ForAllWindowsDo(this, (DoToObject)_TApplication::InsertWindIntoDocMenu,
      //                theDocMenu, theActiveWindow, &currItemNum);
      ForAllWindowsDo(theActiveWindow, (DoToObject)InsertIntoDocMenu, theDocMenu);
#endif

      // 07/09/94 unnecessary!?: Enable(cDocumentList, currItemNum != 0);
      EnableCmd(cAboutApp);
      EnableCmd(cQuit);
#ifdef TABLES
      EnableCheck(cSmartQuotes, TRUE, bool(gSmartQuote));
#endif
      gIconBarIsSetup = TRUE;
   }
#if SIDEBAR != 1
   else
   {
      // remove all the ticks from the menu, except the active one
      TWindow listWindow;
      for (int n = 1; n <= gWindMenuList->fSize; n++)
      {
        listWindow = TWindow(gWindMenuList->At(n));
        CheckItem(*theDocMenu, n, (listWindow == theActiveWindow));
      }
   }
#endif
}

#ifdef TABLES
// *************************************************************************
static TCommand ToggleSmartQuotes()
{
   gSmartQuote = (gSmartQuote == NULL ? gSmartQuoteStr : NULL);
   gIconBarIsSetup = FALSE;
   return gNoChanges;
}
#endif

// *************************************************************************
TCommand _TApplication::DoMenuCommand(EventInfo &info, CmdNumber aCmdNumber)
{
#if SIDEBAR != 1
   int aMenu;
   int anItem;

   if (aCmdNumber < 0)
   {
      aMenu = CmdToMenuItem(aCmdNumber, anItem);
      if (aMenu == cmDocuments)
      {
         // clicked on a document window entry on the iconbar list
         TWindow theWindow = TWindow(gWindMenuList->At(anItem));

         theWindow->Select();
         return gNoChanges;
      }
   }
   else
#endif
   {
      switch (aCmdNumber)
      {
      case cQuit:
         return gAppnCommands[kQuitCommand];
#ifndef DRAGDROP
      case cUndoDescription:
      case cUndo:
         return gAppnCommands[kUndoRedoCommand];
#endif
      case cAboutApp:
         return gAppnCommands[kAboutCommand];
#ifdef TABLES
      case cSmartQuotes:
         return ToggleSmartQuotes();
#endif
      }
   }
   return(_THandler::DoMenuCommand(info, aCmdNumber));
// 10/05/91  return(aCmd);
}

#ifdef TRACE
// *************************************************************************
TCommand _TApplication::UnrecognisedCommand(EventInfo &info, CmdNumber aCmdNumber)
{
   return gNoChanges;
}
#endif

// *************************************************************************
void _TApplication::ForAllWindowsDo(TObject object, DoToObject procToDo, ...)
{
   char *args = (char *)&procToDo + sizeof(procToDo);

   for (int i = 1; i <= gDocList->fSize; i++)
     TDocument(gDocList->At(i))->fWindowList->Each(object, procToDo,
                                                   *(TEachList *)args);
   gFreeWindowList->Each(object, procToDo, *(TEachList *)args);
}


// [20612] 05/02/93 ********************************************************
void RenameDocument()
{
   gIconBarIsSetup = FALSE;
}

// *************************************************************************
void _TApplication::AddDocument(TDocument aNewDocument)
{
   gIconBarIsSetup = FALSE;       // ADD WIND TO DOC INSTEAD?
   gDocList->InsertLast(aNewDocument);
}


// *************************************************************************
void _TApplication::AddFreeWindow(TWindow aWindow)
{
   gFreeWindowList->InsertLast(aWindow);
}


// *************************************************************************
static void TestDoc(TObject null, TDocument doc, TDocument* result,
                    char* fileName)
{
   if (doc->fSaveExists && strcmp(fileName, doc->fTitle) == 0)
      *result = doc;
}


TDocument _TApplication::AlreadyOpen(char* fileName)
{
   TDocument result = NULL;

   if (fileName != NULL)            // 17/07/90 ignore check if 'ram' file
      gDocList->Each(NULL, (DoToObject)TestDoc, &result, fileName);
   return result;
}


// *************************************************************************
void _TApplication::DeleteDocument(TDocument docToDelete)
{
   gIconBarIsSetup = FALSE; //  ADD WIND TO DOC INSTEAD?
   gDocList->Delete(docToDelete);
}


// *************************************************************************
void _TApplication::DeleteFreeWindow(TWindow windowToDelete)
{
   gFreeWindowList->Delete(windowToDelete);
}


// *************************************************************************
TDocument _TApplication::DoMakeDocument(CmdNumber itsCmdNumber, bool installHandler)
{
   NotYetImplemented("TApplication::DoMakeDocument");
   return TDocument(this);   // never executed - (for benefit of compiler)
}


// *************************************************************************
void _TApplication::PostHandleEvent(TWindow theWindow, 
                                    EventInfo &theEventInfo)
{
   if (theEventInfo.affectsMenus)
   {
      gMenusAreSetup = FALSE;           // ??? needed - put in an else ???
      if (theWindow != NULL)
      {
         TWindow realWindow = theWindow->GetWindow();           // 03/12/90

         if (realWindow->fWindowRecord.HasInputFocus())         // 03/12/90
            SetWindowForMenus(realWindow);
      }
   }

   gEventLevel --;  // decrement the event loop as we are leaving it now
   MAFont_ReleaseCurrentFont(); // get rid of any font handles lying around
}


// *************************************************************************
void _TApplication::Run()
{
   FailSpaceIsLow();
   gInitialized = TRUE;
   HandleFinderRequest(gFinderFilename, gFinderPrinting);
   SetupTheMenus();
   MainEventLoop();
   // 22/04/94 moved to MainEventLoop: Close(NULL);
   CloseCurrentMenu();
}


// ------------------------------------------------------------------------
void _TApplication::MainEventLoop(void)
{
   FailInfo fi;

   gIdlePhase = idleBegin;

bottomFailurePosition:
   
   InitFailures();            // 14/08/90 failsafe in case stack not unwound
   CatchFailures(&fi);
   while (!gAppDone)
      wr_event_process();
   gAppDone = FALSE;          // 22/04/94 reset so Cancel close will resume from rescue
   Close(NULL);               // 22/04/94 moved inside failure trap - success will exit
   Success(&fi);              // 22/04/94 was not tidying failure stack, but maybe not
                              // needed now that Close moved, as nothing else should fail
   return;

// ++++++++ bottom level exception handler +++++++++++++++++++++++++++++++++
Rescue:
   DoRescue(fi);
   goto bottomFailurePosition;
}

// ------------------------------------------------------------------------
void _TApplication::HandleFinderRequest(char *fname, bool fp)
{
   AppFile anAppFile;
   FailInfo fi;
   TFileInfo fileInfo;

   if (fname != NULL)
   {
      CatchFailures(&fi);          // 12/05/91 move before CheckType

      GetFileInfo(fname, fileInfo);
      fileInfo.CheckType();           // fail if not file
      anAppFile.fType = (fileInfo.fInfo.loadaddr & 0x000fff00) >> 8;
      anAppFile.fName = fname;
      anAppFile.fEstSize = -1;        // 18/02/91 indicates file is safe
      anAppFile.fFileIsSafe = TRUE;
      CanReadDocument(anAppFile, kNotOurFileType);
      // if (!CanReadDocument(anAppFile))
      //   FailGeneral(kNotOurFileType);

      if (fp)
         PrintDocument(anAppFile);
      else
         OpenOld(anAppFile);

      Success(&fi);
   }
   return;

// -------------- rescue ---------
Rescue:
   if (fi.error != noErr)
   {
      if (fi.message == 0)
      {
         gErrorParm3 = anAppFile.fName;
         fi.message = (fp ? msgPrintFailed : msgOpenFailed);
      }
      ErrorAlert(fi.error, fi.message);
   }
   // return to caller without propagating failure
}

// *************************************************************************
static void CheckChanged(TObject null, TDocument doc, int *openCount)
{
   if (doc->fChangeCount != 0)
      (*openCount)++;
}

#ifdef NETWP
#define Standby_Standby (0x4C7C1)
static int gUserPrompted = FALSE;

#else
// *************************************************************************
static void ClearChanged(TObject null, TDocument doc)
{
   doc->UpdateChangeCount(-doc->fChangeCount);
}
#endif

// *************************************************************************
bool _TApplication::Close(wr_wimp_msgstr *msg)
{
   int       openCount = 0;
   wr_wimp_t taskmsg   = 0;
   bool      killApp   = (msg == NULL);
   keystruct gKeyMsg;     // no need for static

   gDocList->Each(NULL, (DoToObject)CheckChanged, &openCount);
   if (openCount != 0 || gClipView != NULL)    // 30/08/96 or I have the clipboard
   {
      if (msg != NULL)     // acknowledge the message
      {
         taskmsg = msg->hdr.task;

#ifdef NETWP
         if (gUserPrompted)       // this is the follow-up as a result of the re-sent Stand-by
         {
            gUserPrompted = FALSE;
            return TRUE;
         }
#endif
         wr_wimpt_noerr(AckMessage(msg));    // object to closedown (for time being anyway)

         if (openCount != 0)
         {
            wr_wimpt_noerr(wr_wimp_get_caret_pos(&gKeyMsg.caret));
            if (Alert(openCount == 1 ? phUnsavedFile : phUnsavedFiles, -1, openCount) !=
                                                                                  kYesButton)
              return FALSE;        // abort shutdown - the user has cancelled it
         }
      }

      if (gClipView
#ifdef NETWP
              && msg == NULL     // 02/09/96 [27055] only send if internally generated Quit
                                 // !! hopefully Prequits must be Standby generated on NC? !!
#endif
                   )  // I have the clipboard - save it if possible
      {
         wr_wimp_eventstr e;

         e.data.msg.data.words[0] = 4;                                  // bit 2 for clipboard
         wr_wimpt_noerr(BroadcastWantAck(Message_ReleaseEntity, &e.data.msg,
                                         sizeof(wr_wimp_msghdr) + 4));  // send recorded msg

         // either Clipboard app should catch this and reply with Release entity
         // or message will be returned, and we free up the clipboard anyway
         while (gClipView)
            wr_event_process();
      }

      if (msg != NULL)
      {
         WaitForMouseRelease();  // 18/11/92
         if (msg->hdr.size < 24 || (msg->data.words[0] & 1) == 0)
         {
            /* 16/05/92: Risc_OS3 message indicates whether to restart desk close */
            /* send a keypress (Ctrl-Sh-f12) event to the task manager */
            gKeyMsg.chcode = 0x01fc;   // code f12
            wr_wimpt_noerr(wr_wimp_sendmessage(8, (wr_wimp_msgstr *) &gKeyMsg, taskmsg));
#ifdef NETWP
            // 01/09/96 [27055] Restart standby sequence - and ignore follow-up PreQuit
            wr_os_swi1(Standby_Standby | wr_os_X, 0);
            gUserPrompted = TRUE;
#else
            gDocList->Each(NULL, (DoToObject)ClearChanged);  // so next PreQuit will be ignored
#endif
         }
         else
            killApp = TRUE;  // we are not going to get a Quit now, so quit app 'manually'
      } 
   }
   if (killApp)   // 30/08/96 [27055] now called only if we really shut down (not on PreQuit)
   {
      gDocList->Each(NULL, (DoToObject)CloseADocument, msg == NULL);
      EachHandler(NULL, gHeadCohandler, (DoToHandler)FreeIt);
   }
   gAppDone = killApp;  // 22/02/94 gAppDone set here rather than by each caller
                        // 30/08/96 [27055] wait for Message_Quit rather than quit on PreQuit
   return TRUE;
}

#ifdef NEVER
// *************************************************************************
bool _TApplication::Close(wr_wimp_msgstr *msg)
{
   wr_wimp_t taskmsg = 0;
   int    openCount = 0;
   bool   canClose  = TRUE;

   gDocList->Each(NULL, (DoToObject)CheckChanged, &openCount);
   if (openCount != 0)
   {
      if (msg != NULL)     // acknowledge the message
      {
         keystruct gKeyMsg;     // no need for static

         taskmsg = msg->hdr.task;
         wr_wimpt_noerr(AckMessage(msg));
         wr_wimpt_noerr(wr_wimp_get_caret_pos(&gKeyMsg.caret));

         if (Alert(openCount == 1 ? phUnsavedFile : phUnsavedFiles, -1, openCount) ==
                                                                                   kYesButton)
         {
            WaitForMouseRelease();  // 18/11/92
            if (msg->hdr.size < 24 || (msg->data.words[0] & 1) == 0)
            {
               /* 16/05/92: Risc_OS3 message indicates whether to restart desk close */
               /* send a keypress (Ctrl-Sh-f12) event to the task manager */
               // do before caret loss in dlog: wr_wimpt_noerr(wr_wimp_get_caret_pos(&gKeyMsg.caret));
               gKeyMsg.chcode = 0x01fc;   // code f12
               wr_wimpt_noerr(wr_wimp_sendmessage(8, (wr_wimp_msgstr *) &gKeyMsg, taskmsg));
            }
         } 
         else
            canClose = FALSE;
      }
   }
   
   if (canClose)
   {
      // we can close down the application, so do just that!
      gDocList->Each(NULL, (DoToObject)CloseADocument, msg == NULL);
      EachHandler(NULL, gHeadCohandler, (DoToHandler)FreeIt);
#ifdef NETWP
      if (gClipView)  // I have the clipboard
      {
         wr_wimp_eventstr e;

         e.data.msg.data.words[0] = 4;                                  // bit 2 for clipboard
         wr_wimpt_noerr(BroadcastWantAck(Message_ReleaseEntity, &e.data.msg,
                                         sizeof(wr_wimp_msghdr) + 4));  // send recorded msg

         // either Clipboard app should catch this and reply with Release entity
         // or message will be returned, and we free up the clipboard anyway
         while (gClipView)
            wr_event_process();
      }
#endif
      gAppDone = TRUE;  // 22/02/94 gAppDone set here rather than by each caller
   }
   return (canClose);
}
#endif

#ifdef MATHS
// *************************************************************************
void _TApplication::InstallCohandler(THandler aCohandler, bool addIt)
{
   if (addIt)
   {
      aCohandler->fNextHandler = gHeadCohandler;
      gHeadCohandler = aCohandler;
      // does not achieve much!
      // gLastIdle = 0;
      // gIdleFreq = 0;
   }
   else
   {
      THandler prevCohandler = NULL;
      THandler currCohandler = gHeadCohandler;

      while (currCohandler != NULL)
      {
         THandler nextCohandler = currCohandler->fNextHandler;

         if (aCohandler == currCohandler)
         {
            if (prevCohandler == NULL)
               gHeadCohandler = nextCohandler;
            else
               prevCohandler->fNextHandler = nextCohandler;
            return;
         }
         prevCohandler = currCohandler;
         currCohandler = nextCohandler;
      }
   }
}
#endif


#ifndef DRAGDROP
// *************************************************************************
void _TApplication::SetUndoText(bool cmdDone, CmdNumber aCmdNumber)
{
   int newMenuState;
   Str255 undoText;

   if ((gUndoState != cmdDone) || (gUndoCmd != aCmdNumber))
   {
      if (aCmdNumber == cCantUndo)
         newMenuState = bzCantUndo;
      else
      {
         newMenuState = (cmdDone ? bzUndo : bzRedo);
         CmdToName(aCmdNumber, undoText);
         SetCmdName(cUndoDescription, undoText); // undo/redo description
      }

      SetIndCmdName(cUndo, newMenuState);     // undo/redo/cant undo
      gUndoState = cmdDone;
      gUndoCmd   = aCmdNumber;
   }
}
#endif

// *************************************************************************
/* called whenever a mode change etc has happened and all of a document's  */
/* windows have to get their extents changed                               */

void app_SetWindowExtent(TObject null, TWindow aWindow, bool changed3D)
{
#ifdef TRACE
   Assert(aWindow, 679);
   if (aWindow != NULL)
#endif
   {
#ifndef NETWP
      if (changed3D) // 08/03/93 [20806]
      {
        TView subv = aWindow->FindSubView(I_('i', 'c', 'b', 'r'));

        if (subv)
        {
          subv->Close();
          subv->Open();
        }
      }
#endif
      aWindow->AdjustSize();       // set up the extent for the document
                                   // so that the window always = screensize
   }
}


// *************************************************************************
void app_GetEventInfo(EventInfo *info, wr_wimp_eventstr *e)
{
   int menuMask = 0x00061340; // mouse, key, menu, esend(wantack)
                              // 26/04/93 add gain caret for inter window drag and drop

   // 11/05/91 key flags replaced by button settings
   info->event = e;
//   info->theShiftKey = wr_akbd_pollsh();
//   info->theOptionKey = FALSE;
//   info->theControlKey = FALSE;
//   info->theAlphaLock = FALSE;
   info->theClickCount = 0;
   info->affectsMenus = (menuMask >> e->e) & 1;
   info->menuClickedOn = FALSE;       // 12/05/91 TRUE; set in UMenu
   info->fDeleteWindow = FALSE;
   info->eventHandled = FALSE;
   info->rightButton = FALSE;
   info->theShiftKey = FALSE;
   info->document = NULL;      // 23/03/94 for unrecognised commands
   info->windowID = 0;         // 19/04/95
}


// *************************************************************************
bool _TApplication::CanReadDocument(AppFile &anAppFile, int failcode)
{
   return (anAppFile.fType == gMainFileType);
}


// -------------------------------------------------------------------------
static void ConstrainTracker(VPoint &theMouse)
{
   if (gTracker->fConstrainsMouse)
      gTracker->TrackConstrain(gAnchorPoint, gPreviousPoint, theMouse);
}


// -------------------------------------------------------------------------
void app_DrawFeedback(TObject null, bool turnItOn, bool mouseDidMove)
{
   if (!gPreDrag)    // 11/08/95 test gPreDrag again (for call from UView)
   {
      PenNormal();
      PenMode(patXor);
      gTracker->TrackFeedback(gAnchorPoint, 
                           gPreviousPoint, turnItOn, mouseDidMove);
   }
}


// -------------------------------------------------------------------------
static void FeedbackOnce(bool turnItOn, bool mouseDidMove)
{
   // 20/05/90 now uses DoInUpdate
  TView theView = gTracker->fView;
  Rect viewRect;

  if (theView != NULL && gTracker->fTrackNonMovement && !gPreDrag)   // 16/08/93 [21025]
                     // 15/06/91 do TrackNonMovement to stop s/bar flicker
                     // by redefining meaning to not call DoInUpdate
  {
    theView->GetExtent(viewRect);

    // 28/08/90 fudge to stop DoInUpdate being called here when dragging the
    // selection, before the flag is set saying the dragging is complete. The
    // DoInUpdate is called in the guts of highlighting in this case, so
    // there is no problem with drawing outside the window.
    if (gTracker->fCmdNumber == cMouseCommand)
      app_DrawFeedback(NULL, turnItOn, mouseDidMove);
    else
      theView->NoNH_DoInUpdate(viewRect, (DrawProc)app_DrawFeedback, turnItOn, mouseDidMove);
  }
}


// -------------------------------------------------------------------------
#ifdef DRAGDROP
#ifdef TRACE
TCommand _TApplication::MakeMoveCommand(TObject pasteSelection,
                                             TDocument sourcedoc, TPasteCommandType type)
{
   return NULL;  // always overridden
}
#endif
#endif

// -------------------------------------------------------------------------
static TCommand NestTrackRelease(VPoint &theMouse, EventInfo &info)
// 18/06/93 need to save globals in case tracking started in TrackMouse
// 29/06/95 made into function and added failure handling
{
   TCommand saveTracker = gTracker;
   TCommand newTracker;
   FailInfo fi;

   CatchFailures(&fi);
   gTracker = NULL;
   newTracker = saveTracker->TrackMouse(trackRelease,
      gAnchorPoint, gPreviousPoint, theMouse, TRUE, info);
   Success(&fi);

   gTracker = saveTracker;
   return newTracker;

Rescue:
   gTracker = saveTracker;
   ErrorAlert(fi.error, fi.message);
   return gTracker;
}

// -------------------------------------------------------------------------
TCommand _TApplication::TrackMouse(Point &globalMousePt, TCommand theCommand,
                                                            EventInfo &info)
{
   VPoint       theMouse;
   Point        globalMouse = globalMousePt;
   TCommand     newTracker;
   VPoint       delta;
   bool         didScroll;
   bool         didMove;
   TView        trackView;
   TScroller    trackScroller;
   int          dragFlags;

   // convert globalMouse coords to the local view area
   if (theCommand->fView != NULL && theCommand->fView->Focus())
   {
      // put ptr relative to local view area
      thePort->GlobalToLocal(globalMouse);
      theCommand->fView->QDToViewPt(globalMouse, theMouse);
   }
   else
   {
      // local view area is the screen
      PtToVPt(globalMouse, theMouse);
   }

   switch (info.theTrackPhase)
   {
      case trackPress :
         gDragButton = (info.event->e == wr_wimp_EBUT ?
            info.rightButton = (info.event->data.but.m.bbits & wr_wimp_BRIGHT) / wr_wimp_BRIGHT :
            0);    // 28/04/94 [21132] take 2: remember pressed button for release

         if (info.event->e == wr_wimp_EBUT)
           InstallTracker(theCommand);
         gAnchorPoint = theMouse;
         gPreviousPoint = theMouse;

         ConstrainTracker(theMouse);
         gAnchorPoint = theMouse;
         gPreviousPoint = theMouse;
#ifdef DRAGDROP
         dragFlags = info.trackingKey;
#endif
         newTracker = gTracker->TrackMouse(trackPress,
            gAnchorPoint, gPreviousPoint, theMouse, TRUE, info);

#ifdef DRAGDROP
         gDragClaimant = 0;
         // unnecessary gDragClaimantRef = 0;
         if (dragFlags == 0 && (gDragTypes = info.trackingKey) != 0)
                                             // 24/03/93 a dragger has just started
         {
           VRect globalView;

           gStartDragger = theCommand;
           gDragFinished = FALSE;
           // gDragAborted = FALSE;
           // gDragPointer = 0;
           gStartWindow = theCommand->fView->GetWindow();
           gDragQuit = 0;
           gDragShift = wr_akbd_pollsh() * 8;  // test if Shift down
           gDragPointer = 0;
           gDragPointerShape = GetLastCursor();

           MoveRect(globalView, theCommand->fInitialRect);
           if (theCommand->fScroller == NULL)           // ?
              VisibleRect(globalView);
           OffsetRect(globalView, -theMouse.h, -theMouse.v);
           thePort->LocalToGlobal(*globalView.topLeft);
           thePort->LocalToGlobal(*globalView.botRight);
           QDRectToBox(globalView, gDragBox, ScreenHeight());
         }
#endif
         app_DragStarting(theMouse, info);
         break;

      case trackMove :
         // called while the nulls are being generated
         trackView = gTracker->fView;
         trackScroller = gTracker->fScroller;

         // 22/03/93 always call AutoScroll, so unnecessary: SetupFocus(autoscrollLimit);
         delta.h = delta.v = 0;     // delta = gZeroVPt;
         didScroll = FALSE;

         if (trackView != NULL && trackView->Focus() && trackScroller != NULL)
         {
            // the view can scroll about
            VPoint mouseInScroller = theMouse;

            trackView->LocalToWindow(mouseInScroller);
            trackScroller->WindowToLocal(mouseInScroller);

            trackScroller->AutoScroll(mouseInScroller, delta);
            // 11/07/96 ensure we actually scroll first: AddVPt(delta, theMouse);
            if (delta.h | delta.v)
            {
#ifdef DRAGDROP
               int tick = TickCount();

               if (gTracker->fAutoScrollStart == 0)
               {
                  gTracker->fAutoScrollStart = tick + 50;  // wait half a sec.
                  didScroll = FALSE;
               }
               else if (gTracker->fAutoScrollStart > tick)
                  didScroll = FALSE;
               else
#endif
               {
                 didScroll = TRUE;
                 AddVPt(delta, theMouse);    // 11/07/96 wait to ensure scroll implemented
               }
            }
#ifdef DRAGDROP
            else
              gTracker->fAutoScrollStart = 0;
#endif
         }

         ConstrainTracker(theMouse);

         didMove = !(EqualVPt(gPreviousPoint, theMouse));  // hysteresis!!
         FeedbackOnce(FALSE, (didMove | didScroll));
         if (didScroll)
         {
            gTracker->AutoScroll(delta.h, delta.v);

#ifdef DRAGDROP
            if (theCommand->fFeedbackBox == wr_wimp_USER_RUBBER)
                                   // 22/03/93 was != 5 which it always was
#endif
            {
               wr_wimp_drag_box(NULL);

               theCommand->StartDrag(gAnchorPoint, globalMousePt);
            }
         }

         // 02/05/91 symantics changed; nextPoint is returned as the active
         // point, and changed values are not passed back on next track call
         delta = theMouse;                              // temporary save
         newTracker = gTracker->TrackMouse(trackMove,
            gAnchorPoint, gPreviousPoint, theMouse, didMove, info);

         gPreviousPoint = delta;
         if (trackView != NULL)
         {
            thePort->LocalToGlobal(theMouse);   // assumes no focus change
            trackView->DrawFeedback(theMouse);
         }
         FeedbackOnce(TRUE, (didMove | didScroll));
         break;

      case trackRelease :
         // for when the drag ends
         info.rightButton = gDragButton; // 28/04/94 [21132] Take 2: set rtBut to click state
         ConstrainTracker(theMouse);

         FeedbackOnce(FALSE, TRUE);

         theCommand->StopDrag();      // 19/03/93 for solid drag stop
         newTracker = NestTrackRelease(theMouse, info);   // 29/06/95 new func to handle fails
#ifdef DRAGDROP
         if (gTracker == gStartDragger && !gPreDrag)    // 17/08/93 [21025] only if started
         {
            if (gDragQuit)
            {
               FinishDrag(NULL, TRUE);  // param not used if quit
            }
            else if (info.event->e == wr_wimp_ENULL)
            {
               // we have wandered outside the original window but not released
               // set gTracker to NULL, but do not free gStartDragger
               // return gNoChanges so gStartDragger is not performed
               gTracker = NULL;
            }
            else
            {
               info.theShiftKey = gDragShift;
               newTracker = gTracker->TrackMouse(trackDrop,
                  gAnchorPoint, gPreviousPoint, theMouse, TRUE, info);
#ifdef NEVER
               TObject pasteSelection = gTracker->fPasteSelection;

               // redundant (set by RemoveTracker): gStartDragger = NULL;
               if (pasteSelection != NULL)
               {
                  gTracker->fPasteSelection = NULL;  // ensure not freed, since handed over
                  // newTracker should be gNoChanges so following RemoveTracker frees
                  // gTracker & gStartDragger, and sets them to NULL; moving after
                  // call of DoMakeMoveCommand should have same effect
                  // RemoveTracker(newTracker);
                  // return MakeMoveCommand(pasteSelection, gStartWindow->fDocument,
                  //               gDragShift ? kCopyCommand : kMoveCommand);
                  // return DoMakeMoveCommand(..)
                  newTracker = DoMakeMoveCommand(pasteSelection, gStartWindow->fDocument,
                                                               kMoveCommand);
               }
#endif
            }
         }
#endif
         gPreDrag = FALSE;                 // 17/08/93 [21025]
         RemoveTracker(newTracker);
         return newTracker;
   }
   return gNoChanges;
}

// ------------------------------------------------------------------------
// 17/08/93 [21025] new procedure to kick off delayed dragging when event arrives
void app_DragStarting(Point &theMouse, EventInfo &info)
{
   Point globalMouse;
   TCommand theCommand = gTracker;

   if (theCommand != NULL)
   {
#ifdef DRAGDROP
      if (theCommand->fFeedbackBox >= 0) // 22/03/93 someone else is controlling the drag
#endif
      {
         gPreDrag = info.delayDrag;
         if (!gPreDrag)      // 17/08/93 [21025] wait for drag event before dragging
         {
            VPtToPt(theMouse, globalMouse);
            thePort->LocalToGlobal(globalMouse);
            theCommand->StartDrag(gAnchorPoint, globalMouse);
         }
      }
      gPreviousPoint = theMouse;                     
      FeedbackOnce(TRUE, TRUE);
   }
}


// ------------------------------------------------------------------------
bool _TApplication::CanOpenDocument(CmdNumber itsCmdNumber,
                                                  AppFile &anAppFile)
{
   // override if more filetypes supported
   return (gMainFileType == anAppFile.fType);
}


// ------------------------------------------------------------------------
void _TApplication::PrintDocument(AppFile &anAppFile)
{
   TDocument aDocument;
   FailInfo fi;

   aDocument = DoMakeDocument(anAppFile.fType, FALSE);

   CatchFailures(&fi);

   aDocument->ReadFromFile(anAppFile, kForPrinting);
   aDocument->Print("<Printer$Temp>");  // 04/12/93 new virtual method
   Success(&fi);

Rescue:
   FreeIfObject(aDocument);
   ContinueIfFail(&fi);
}

#ifdef TRACE
// -------------------------------------------------------------------------
void _TApplication::DoShowAboutApp()
{
}
#endif

// -------------------------------------------------------------------------
TCommand _TApplication::DoCommandKey(int ch, EventInfo &info)
{
   // include Help fn key presses etc here (items not in the menus)
   return _THandler::DoCommandKey(ch, info);
}


// -------------------------------------------------------------------------
void _TApplication::SpaceIsLow()
{
   Alert(phSpaceIsLow, wr_wimp_EOK | 16 | 0x300);       // 16 => suppress 'Error from'
                                                    // 22/02/94 [21415] info message
}

#ifdef TRACE
// -------------------------------------------------------------------------
void _TApplication::InvalidateFocus()
{
   gFocusedView = NULL;
}
#endif

// -------------------------------------------------------------------------
static void GetWindowForWimpW(TObject null, TWindow aWindow, 
                              TWindow* theWindow, wr_wimp_w theWimpWindow)
{
   if (aWindow != NULL)
   {
      if (aWindow->fWindowRecord.GetHandle() == theWimpWindow)
         *theWindow = aWindow;
   }
}

// -------------------------------------------------------------------------
TWindow _TApplication::GetActiveWindow()
{
   wr_wimp_caretstr c;

   FailOSErr(wr_wimp_get_caret_pos(&c));
   return WimpToWindow(c.w);
}


// -------------------------------------------------------------------------
void _TApplication::SetupTheMenus()
{
   // grey out the iconbar menu only if it needs set up
   // gIconBarIsSetup is a global used by TApplication.DoSetupMenus
   // and is set by things like document creation/deletion
#ifndef NETWP
   if (!gIconBarIsSetup)
      DisableMenu(gIconbarMenu->fRootMenu);
#endif

   if (!gMenusAreSetup)
   {
      bool undoState    = TRUE;
      CmdNumber undoCmd = cCantUndo;

      // grey out all the window menu (if there is one) and there
      // is menudata for it!!!
      if (gSetUpWindow != NULL && gSetUpWindow->fMenuData != NULL)
      {
         // there is a window on-screen so grey out its menu items
         // a value of 0 disables the whole tree recursively
#ifdef NETWP
         DisableMenu(0);   // ensure things which are suppressed are dimmed
#else
         DisableMenu(gSetUpWindow->fMenuData->fRootMenu);
#endif

         // now activate along the window target chain
         gSetUpWindow->fTarget->DoSetupMenus();

         // the following are window-menu related but either are not on
         // the target chain or are to do with icons on the iconbar pane

         // set up the undo/redo bit which is not on the target chain
#ifndef DRAGDROP
         if (gLastCommand != NULL && gLastCommand->fCanUndo)
         {
            undoState = gLastCommand->fCmdDone;     // 10/05/91
            undoCmd = gLastCommand->fCmdNumber;
            Enable(cUndoDescription,
             ((gLastCommand->fChangedDocument == NULL) ||
             ((gSetUpWindow != NULL) &&
             (gLastCommand->fChangedDocument == gSetUpWindow->fDocument))));
            EnableCmd(cUndo);
         }
         else
         {
            // we cannot undo the item so grey out the leaf name
            DisableCmd(cUndo);
         }
         SetUndoText(undoState, undoCmd);
#endif
         // set up the icons on the icon bar pane
         if (gEnabledControls != NULL)
            gEnabledControls->Each(NULL, (DoToObject)GetControlToReflectMenuState, FALSE);
      }
      else
         gApplication->DoSetupMenus();  // application is the target

      gMenusAreSetup = TRUE;
   }

   // in case the icon bar menu has not yet been set ...
   if (!gIconBarIsSetup)
      gApplication->DoSetupMenus();
}


// ------------------------------------------------------------------------
void _TApplication::SetWindowForMenus(TWindow windowToSet)
{
   if (windowToSet != gSetUpWindow) // 12/05/91 && windowToSet->fDbox == NULL)
   {
      gSetUpWindow = windowToSet;  // 03/12/90 moved from below
      gMenusAreSetup = FALSE;
   }
}

#ifdef TRACE
// ------------------------------------------------------------------------
TView _TApplication::CreateAView(TDocument itsDocument, TView itsSuperView,
          char * &itsParams)
{
  return NULL;
}
#endif

// -------------------------------------------------------------------------
void _TApplication::ClaimClipboard(TView clipView, TCommand claimer)
{
#ifdef DRAGDROP
// 12/03/93 [20707] Tell everyone that we have the clipboard
  if (gClipView == NULL)
  {
    wr_wimp_msgstr msg;

    msg.data.words[0] = 4;
    
    wr_wimpt_noerr(Broadcast(Message_ClaimEntity, &msg, sizeof(wr_wimp_msghdr) + 4));
  }
#endif

  app_AbandonClipboard(gClipUndoView);      // 12/03/93 pass the clipview
  gClipUndoView = gClipView;                // preserve current clip for Undo
  gClipView = clipView;
  gClipClaimed = TRUE;
  gClipClaimer = claimer;
}
