/*************************************************
*    Spelling Checker PassWord                   *
*    Copyright 1986,87,88,89                     *
*    Circle Noetic Services                      *
*    All Rights Reserved                         *
*************************************************/
#include "Password.h"

#ifdef  DEBUG
extern short debugFlag;
#endif

PWDDictHandle PWD;
struct PWDResultType PWDStat;
short PWDpostLen,PWDonLen,PWDallLen,PWDcliLen,PWDcompound;
short PWDLastLvl1Cnt;
u_char PWDfirst,PWDsecond;

static u_short onStat,postStat,wordStat;
static u_short CastMode;
static u_short status;
static u_short accentFlag;

u_char *Advance();

SpellCheck(dict,startT,endT,mixed)
PWDDictHandle dict;
u_char *startT,*endT;
short mixed;
{
  register u_char *s,*e,*map;
  register short result;

  if(endT - startT >= MAX_WORD_LEN)
    return(0);
  PWD = dict;
  PWDStat.stat = 0;
  if((result = CheckToken(startT,endT,mixed)) == 0) {
    s = startT;
    e = endT;
    map = (*PWD)->chType;
    /* find first alphabetic */
    for(; s <= e && DELIM(map[*s]); s++)
      ;
    /* find last alphabetic */
    for(; s <= e && DELIM(map[*e]); e--)
      ;
    PWDStat.start = s - startT;
    PWDStat.end = e - startT;
  }
  PWD = NIL;
  return(result);
}

static CheckToken(startT,endT,mixed)
register u_char *startT,*endT;
register short mixed;
{
  register u_char *m,*start;
  register short onSave,postSave;

  if(startT > endT)
    return(1);
  if(MatchOne(startT,endT,mixed))
    return(1);
  onSave = PWDonLen;
  postSave = PWDpostLen;
  if(!ALPHA(status)) {  /* if NOT only alphabetics present */
    start = startT;
    do {
      m = startT;
      while(m <= endT) {
        m = Advance(m,endT);
        if((m != endT || startT != start) && MatchOne(startT,m,mixed) &&
            (m >= endT || DELIM((*PWD)->chType[m[1]]) && CheckToken(m + 2,endT,mixed)))
          return(1);
        m++;
      }
      startT++;
    } while(startT <= endT && DELIM((*PWD)->chType[startT[-1]]));
  }
  PWDpostLen = postSave;
  PWDonLen = onSave;
  return(0);
}

static u_char *Advance(m,endT)
register u_char *m;
u_char *endT;
{
  register u_char *map,*e;

  e = endT;
  map = (*PWD)->chType;
  while(m <= e && DELIM(map[*m]))  /* 22/10/90 "while" changed to "if"; 20/07/93 and back */
    m++;
  while(m <= e && !DELIM(map[*m]))
    m++;
  return(m-1);
}

static MatchOne(startT,endT,mixed)
u_char *startT,*endT;
short mixed;
{
  register u_short stat;
  u_char token[256];  /* NUL terminated version of [startT .. endT] */
  u_char *IsAccented();

  if(startT > endT)
    return(1);
  PWDcompound = wordStat = onStat = postStat = PWDcliLen = PWDpostLen = PWDonLen = 0;
  PWDallLen = endT - startT + 1;
  status = stat = GetStat(startT,endT,token,0);
  if((stat & (UPPER|LOWER|FSTCAP)) == 0)
    return(1);
  if(CheckCompound(token,stat,mixed))
    return(1);    /* success */
  if(!MIXED(stat) && (stat & (FSTCAP|UPPER)) && ((*PWD)->flags & TryAccent)) {
    register PWDDictPtr dp;
    register u_char *s,*accMap,**temp;

    dp = *PWD;
    temp = PWDCheckHandle(dp->etc,dp->file,dp->ETCStart,1);
    dp = *PWD;
    if((dp->etc = temp) != NIL) {
      s = *temp;          /* onShtutz */
      s += *s;          /* postShtutz */
      s += *s;          /* lower case unmap map */
      s += dp->maxCode;
      s += dp->maxCode;
      s += dp->maxCode + 3;    /* Upper case accents map */
      accMap = s;
      for(s = token; *s != '\0'; s++)
        if((dp->chType[*s] & UPPER) && IsAccented(dp->chMap[*s],accMap) != NIL) {
          CNSUnlock(dp->etc);
          return(0);
        }
      stat = AccentMatch(token,stat,mixed,accMap);
      CNSUnlock((*PWD)->etc);
      return(stat);
    }
  }
  return(0);
}

static u_char *IsAccented(ch,s)
register u_char ch,*s;
{
  register u_char *save;

  for(; *s != '\0'; s++) {
    save = s;
    while(*++s != '\0')
      if(*s == ch)
        return(save);
  }
  return(NIL);
}

static u_char *GetAccents(ch,s)
register u_char ch,*s;
{
  if((*PWD)->chType[ch] & ACCENT) {  /* if the letter takes accents */
    ch = (*PWD)->chMap[ch];
    for(; *s != '\0'; s++) {
      if(*s == ch)
        return(s);  /* go it */
      while(*++s != '\0')
        ;
    }
  }
  return(NIL);
}

static u_char ***accents;

static LoadAccents(token,accMap)
u_char *token,*accMap;
{
  register len,i;

  len = PWDallLen - PWDonLen;
  if((accents = (u_char ***)CNSHandle((long)len * sizeof(char *))) == NIL) {
    PWDStat.stat |= MEMERROR;
    return(0);
  }
  for(i = 0; i < len; i++)
    (*accents)[i] = GetAccents(token[i],accMap);
  return(1);
}

static AccentMatch(tt,stat,mixed,accMap)
u_char *tt;
u_short stat,mixed;
u_char *accMap;
{
  register u_char *token,*s1,*s2,ch1,ch2;

  token = tt + PWDonLen;  /* skip onShtutz */
  ch1 = token[0];
  ch2 = token[1];
  if(!(stat & UPPER)) {  /* if only FSTCAP then vary the first letter */
    if((s1 = GetAccents(ch1,accMap)) != NIL)
      while(*++s1 != '\0') {
        token[0] = UnMapChar(*s1,1);
        if(CheckCompound(tt,stat,mixed))
          goto Found;
      }
  } else {        /* all capitals */
    accentFlag = 1;
    if(LoadAccents(token,accMap) == 0)
      goto NotFound;
    if((*accents)[0] == NIL) {
      if((*accents)[1] == NIL) {
        if(CheckCompound(tt,stat,0))
          goto Found;
        goto NotFound;
      }
      for(s2 = (*accents)[1]; *s2 != '\0'; s2++) {
        token[1] = UnMapChar(*s2,1);
        if(CheckCompound(tt,stat,0))
          goto Found;
      }
    } else if((*accents)[1] == NIL) {
      for(s1 = (*accents)[0]; *s1 != '\0'; s1++) {
        token[0] = UnMapChar(*s1,1);
        if(CheckCompound(tt,stat,0))
          goto Found;
      }
    } else {
      /* try all accented variations for the first letter */
      for(s1 = (*accents)[0]; *s1 != '\0'; s1++) {
        token[0] = UnMapChar(*s1,1);
        /* try all accented variations for the second letter */
        for(s2 = (*accents)[1]; *s2 != '\0'; s2++) {
          token[1] = UnMapChar(*s2,1);
          if(CheckCompound(tt,stat,0))
            goto Found;
        }
      }
    }
  }
NotFound:
  accentFlag = 0;
  CNSDisposHandle(accents);
  accents = NIL;
  token[0] = ch1;
  token[1] = ch2;
  return(0);
Found:
  accentFlag = 0;
  CNSDisposHandle(accents);
  accents = NIL;
  token[0] = ch1;
  token[1] = ch2;
  return(1);
}

static GetStat(startT,endT,token,flag)
u_char *startT,*endT;
u_char *token;
short flag;
{
  register u_char *t,*map,*s,*e;
  register u_short result;

  map = (*PWD)->chType;
  s = startT;
  e = endT;
  t = token;
  result = map[*t = *s];
  if(result & UPPER) {
    result &= ~UPPER;
    result |= FSTCAP;
  }
  while(s < e) {
    t++;
    s++;
#ifdef  MPW
    {
    short temp;
    temp = map[*t = *s];
    result |= temp;
    }
#else
    result |= (u_short)map[*t = *s];
#endif
  }
  t[1] = '\0';
  if(flag == 0) {
    wordStat = result;
    if(result & ONPOST)
      GetOnPost(startT,endT);
    if(postStat & FSTCAP) {  /* postShtutz should never set FSTCAP */
      postStat &= ~FSTCAP;
      postStat |= UPPER;
    }
    result = wordStat | postStat;
    if(onStat & UPPER) {  /* if upper case onShtutz */
      onStat &= ~FSTCAP;    /* onShtutz should not set FSTCAP */
      result |= onStat;
    }
  }
  result &= ~VOWEL;
  result &= ~ACCENT;
  return(result);
}

static GetOnPost(startT,endT)
u_char *startT,*endT;
{
  register u_char *s,*p;
  register PWDDictPtr dp;
  register u_char *e,*start,*end;
  char result;
  u_char token[256];    /* just a place holder */

  start = startT;
  end = endT;
  CNSLock(PWD);
  dp = *PWD;
  dp->etc = PWDCheckHandle(dp->etc,dp->file,dp->ETCStart,0);
  CNSUnlock(PWD);
  if(dp->etc == NIL)
    goto Skip;
  s = *dp->etc;
  s += *s + 1;
  e = s + s[-1];
  for(; s < e; s++) {
    /* match the postShtutz */
    for(p = end;; p--, s++) {
      if(p < start)
        goto NextPost;
      if(*s == '\0')  /* if postShtutz ended */
        break;
      if(dp->version == VERSION1) {  /* if version 1 dictionary */
        if(*p != *s)
          goto NextPost;
      } else {
        if((result = dp->chMap[*p] - *s) > 0)
          goto NextPost;
        if(result < 0)
          goto CheckOn;
      }
    }
    if(dp->chType[*p] & ONPOST) {
      p--;  /* backup over 'Õ' */
      PWDpostLen = end - p;
      end = p;
      break;
    }
NextPost:
    while(*s != '\0')
      s++;
  }
  if(PWDpostLen != 0)
    goto Skip;
CheckOn:
  s = *dp->etc + 1;
  e = s + s[-1];
  for(; s < e; s++) {
    /* match the onShtutz */
    for(p = start; p <= end; p++, s++) {
      if(p > end)
        goto NextOn;
      if(*s == '\0')  /* if onShtutz ended */
        break;
      if(dp->version == VERSION1) {  /* if version 1 dictionary */
        if(*p != *s)
          goto NextOn;
      } else {
        if((result = dp->chMap[*p] - *s) > 0)
          goto NextOn;
        if(result < 0)
          goto Skip;
      }
    }
    if(dp->chType[*p] & ONPOST) {
      p++;
      if(dp->chType[*p] & VOWEL) {  /* a vowel must follow on-shtutz */
        PWDonLen = p - start;
        start = p;
      }
      break;
    }
NextOn:
    while(*s != '\0')
      s++;
  }
Skip:
  if(PWDpostLen != 0 || PWDonLen != 0) {
    wordStat = GetStat(start,end,token,1);
    if(PWDpostLen != 0)
      postStat = GetStat(end+2,endT,token,2);
    if(PWDonLen != 0)
      onStat = GetStat(startT,start-2,token,2);
  }
}

#define  SAVE_LEN()    { save1 = PWDallLen; save2 = PWDonLen; save3 = PWDpostLen; }
#define  RESTORE_LEN()  { PWDallLen = save1; PWDonLen = save2; PWDpostLen = save3; }

static CheckCompound(token,stat,mixed)
u_char *token;
short stat,mixed;
{
  short x,save1,save2,save3,save4;
  struct HyphDataType hdata;

  if((x = CheckOne(token,stat,mixed)) != 0 || (PWDStat.stat & CAPERROR)
        || (PWDStat.stat & MEMERROR) || !ALPHA(stat))
    return(x);
  SAVE_LEN();
  token += PWDonLen;
  PWDallLen -= PWDonLen;
  PWDallLen -= PWDpostLen;
  PWDonLen = 0;
  PWDpostLen = 0;
  save4 = token[PWDallLen];  /* save postShtutz character */
  token[PWDallLen] = '\0';
  if((*PWD)->flags & TryClitics)
    x = CheckClitics(token,stat,mixed);
  else if(((*PWD)->flags & TryCompound) && UserGetHyphens(PWD,token,&hdata) != 0) {
    PWDcompound = 1;  /* tell everyone we START compounding */
    hdata.hyphens[hdata.hyph_index].offset = PWDallLen - 1;
    stat |= FSTCAP;  /* don't check capitalization for compounds */
    x = BreakCompound(token,stat,mixed,0,hdata.hyphens,hdata.hyphens + hdata.hyph_index);
    PWDcompound = 0;  /* tell everyone we STOPED compounding */
  }
  RESTORE_LEN();
  token[PWDallLen - PWDpostLen] = save4;  /* restore postShtutz character */
  return(x);
}

static BreakCompound(token,stat,mixed,offset,p,q)
register u_char *token;
register short stat,mixed,offset;
register HyphenType *p,*q;
{
  if(offset != 0) {
    PWDallLen = q->offset - offset + 1;
    if(CheckOne(token + offset,stat,mixed))
      return(1);
  }
  for(; p < q; p++) {
    if(p->offset < offset + 1)
      continue;
    if(p->offset > q->offset - 3)
      continue;
    if((p->value & 0x3f) >= 3)    /* hierarchies 3 and 4 can't compound */
      continue;

    /* if(p->value & 0x80) {????}  /* hyphen is in question */
    /* if(p->value & 0x40) {????}  /* rewrite is indicated */

    if(CheckBinding(p->value,token[p->offset]))
      if(TryIt(token,stat,mixed,offset,p->offset,p->offset + 1,p + 1,q))
        return(1);
    if(TryIt(token,stat,mixed,offset,p->offset + 1,p->offset + 1,p + 1,q))
      return(1);
  }
  return(0);
}

static CheckBinding(val,ch)
u_char val,ch;
{
  ch = (*PWD)->chMap[ch];
  val &= 0x3f;
  return(val == 0 && ch == 19);
}

static TryIt(token,stat,mixed,offset,offset1,offset2,p,q)
register u_char *token;
register short stat,mixed,offset,offset1;
register HyphenType *p,*q;
{
  register u_char save;

  save = token[offset1];
  token[offset1] = '\0';
  PWDallLen = offset1 - offset;
  if(CheckOne(token + offset,stat,mixed)) {  /* if CheckOne() matched then */
    token[offset1] = save;
    if(p > q || BreakCompound(token,stat,mixed,offset2,p,q))
      return(1);
  }
  token[offset1] = save;
  return(0);
}

static CheckClitics(token,stat,mixed)
u_char *token;
short stat,mixed;
{
  register PWDDictPtr dp;
  register u_char *s,**temp;
  u_char clitics[256];

  dp = *PWD;
  temp = PWDCheckHandle(dp->etc,dp->file,dp->ETCStart,0);
  dp = *PWD;
  if((dp->etc = temp) == NIL)
    return(0);
  /* fill in "clitics" */
  s = *dp->etc + CNSGetHandleSize(dp->etc) - 1;
  BlockMove(s - *s,clitics,(long)*s);
  return(SearchClitics(token,stat,mixed,NULL,token + PWDallLen - 1,clitics));
}

static SearchClitics(token,stat,mixed,prev,token_end,clitics)
u_char *token;
short stat,mixed;
u_char *prev,*token_end,*clitics;
{
  register u_char *s,*te,*clit,save1,save2,*map;
  register short x;

  map = (*PWD)->chMap;
  for(s = clit = clitics;; clit = ++s) {
    if(*s == '\0')
      goto Done;  /* no more clitics */
    /* match clitic here */
    if(prev != NULL) {
      if(!(*s & IndirObject))
        goto NextClitic;
    }
    for(te = token_end; *s != '\0'; te--, s++) {
      if(te <= token)
        goto Done;
      save1 = map[*te];
      save2 = *s & 0x3f;
      if(save1 > save2)
        goto NextClitic;
      if(save1 < save2)
        goto Done;
    }
    te++;
    save1 = *te;
    *te = '\0';
    x = TryClitic(token,te - 1,stat,mixed);
    *te = save1;
    if(x != 0)
      return(1);
    if(prev == NULL && (*clit & DirObject))
      if(SearchClitics(token,stat,mixed,clit,te - 1,clitics) != 0)
        return(1);
NextClitic:
    while(*s != '\0')
      s++;
  }
Done:
  return(0);
}

static TryClitic(token,token_end,stat,mixed)
u_char *token;
u_char *token_end;
short stat,mixed;
{
  register short x;
  register PWDDictPtr dp;
  register u_char *map,*te,save,**temp;

  if(CheckOne(token,stat,mixed) != 0)
    return(1);
  /* find second vowel from the end */
  te = token_end;
  dp = *PWD;
  map = dp->chType;
  save = dp->chMap[*te];
  x = 2;
  if(save == 4 || save == 12 || save == 18)  /* if save == d/l/r */
    x = 1;
  for(;; te--) {
    if(te < token)
      return(0);
    if(map[*te] & VOWEL)
      x--;
    if(x == 0)
      break;
  }
  temp = PWDCheckHandle(dp->etc,dp->file,dp->ETCStart,0);
  dp = *PWD;
  if((dp->etc = temp) == NIL)
    return(0);
  map = *temp;          /* onShtutz */
  map += *map;          /* postShtutz */
  map += *map;          /* lower case unmap map */
  map += dp->maxCode;        /* upper case unmap map */
  map += dp->maxCode;
  map += 2;
  if(dp->flags & TryAccent)
    map += dp->maxCode + 1;
  if((map = IsAccented(dp->chMap[*te],map)) == NIL)
    return(0);
  save = *te;
  *te = UnMapChar(*map,(dp->chType[*te] & UPPER) ? 1 : 0);
  x = CheckOne(token,stat,mixed);
  *te = save;
  return(x);
}

static CheckOne(token,stat,mixed)
register u_char *token;
register short stat;
short mixed;
{
  char word[256];
  register u_char *nulPlace;
  register short suff,length;
  register short caseErr,inDict;
  register u_char save;

/* eprintf("CheckOne(): token (%s), accentFlag %d\r",token,accentFlag); */
  length = PWDallLen;
  length -= PWDpostLen;
  nulPlace = &token[length];  /* pointer to postShtutz delimeter */
  length -= PWDonLen;
  caseErr = 0;
  if(!mixed && MIXED(stat) && ALPHA(stat))
    caseErr = CASEERROR;
  /* only alphabetics and words longer than 2 chars  */
  /* are present in the common and main dictionaries */
  inDict = 0;
  save = *nulPlace;  /* remember postShtutz delimeter */
  *nulPlace = '\0';  /* overwrite postShtutz delimeter for PWDMapWord() */
  if(length >= 2 && ALPHA(stat)) {
    inDict = 1;
    if(!caseErr) {
      if(!accentFlag)
        suff = PWDMapWord(token + PWDonLen,word) + 2;
      else {
        MapGuess(token + PWDonLen,word);
        PWDfirst = word[0];
        PWDsecond = word[1];
      }
/* eprintf("CheckOne(): calling CheckCommon(): token (%s)\r",token + PWDonLen); */
      if(CheckCommon(word,stat,suff,length))
        return(1);    /* success */
    }
  }
/* eprintf("CheckOne(): calling CheckExact(): token (%s)\r",token + PWDonLen); */
  if(!PWDcompound && CheckExact(token + PWDonLen,stat))
    return(1);  /* success */
  *nulPlace = save;  /* restore postShtutz delimeter for CheckUser() */
  switch(CheckUser(PWD,token,stat)) {
    case 0:    /* token was NOT found, check main dictionary */
      if(inDict && !caseErr) {
        *nulPlace = '\0';  /* overwrite postShtutz delimeter for CheckDict() */
        if(CheckBig(word,token + PWDonLen,stat,suff,length))
          return(1);    /* success */
      }
    case 2:    /* token was found and rejected */
      PWDStat.stat |= caseErr;
      return(0);
  }
  /* token was found by CheckUser() */
  return(1);
}

static CheckCommon(word,stat,suff,length)
u_char *word;
short stat,suff,length;
{
  register PWDDictPtr p;
  register u_char *start,*end;
  register u_short index;
  u_short ss,ee;

  p = *PWD;
  if(length > p->maxCommon || length < p->minCommon)
    return(0);
  if(PWDfirst > p->maxComFirst || PWDsecond > p->maxComSecond)
    return(0);
  index = (PWDfirst - 1) * p->maxComSecond + PWDsecond - 1;
  CNSLock(PWD);
  if((p->commIndex = (u_short **)PWDCheckHandle(p->commIndex,p->file,p->CIStart,0)) == NIL) {
    CNSUnlock(PWD);
    return(0);
  }
  ss = (*p->commIndex)[index];
  ee = (*p->commIndex)[index + 1];
#ifdef  FLIP
  FlipShort(&ss);
  FlipShort(&ee);
#endif

  p->commList = PWDCheckHandle(p->commList,p->file,p->CLStart,0);
  CNSUnlock(PWD);
  if(p->commList == NIL)
    return(0);
  start = end = *p->commList;
  start += ss;
  end += ee;
  end--;

#ifdef DEBUG
  CNSLock(PWD);  
  CNSLock(p->commList);
  if(debugFlag)
    eprintf("\rCheckCommon(): index %d, commIndex[index] %x, commIndex[index + 1] %x\r",
          index,(*p->commIndex)[index],(*p->commIndex)[index + 1]);
  if(accentFlag)
    index = AccMatchDict(word,start,end);
  else
    index = PWDMatchDict(word,start,end,stat & FSTCAP,suff);
  CNSUnlock(p->commList);
  CNSUnlock(PWD);
  return(index);
#else
  if(accentFlag)
    return(AccMatchDict(word,start,end));
  return(PWDMatchDict(word,start,end,stat & FSTCAP,suff));
#endif
}

static AccMatchDict(word,start,end)
u_char *word,*start,*end;
{
/*{
char str[40];
UnMap(word,str,0);
eprintf("AccMatchDict(): word (%s)\n",str);
}*/
  word += 2;    /* skip first two letters. they are already matched */
  while(start <= end) {
    if(AccMatchEntry(word,start,end))
      return(1);
    do
      start++;
    while((*(char *)start) > 0);
  }
  return(0);
}

static AccMatchChars(ch,list)
register u_char ch,*list;
{
  while(*++list != 0)
    if(ch == *list)
      return(0);
  return(1);
}

static AccMatchSuff(t,se,ss,i)
register u_char *t,*se,*ss;
register short i;
{
  for(;; i++, t++, se--) {
    if(*t == '\0') {
      if(ss <= se)
        return(1);  /* no match */
      break;
    }
    if(ss > se)
      return(1);  /* no match */
    if(*se == *t)
      continue;
    if((*accents)[i] == NIL)
      return(1);  /* no match */
    if(AccMatchChars(*se,(*accents)[i]))
      return(1);  /* no match */
  }
  return(0);
}

static AccMatchEntry(token,elem,end)
register u_char *token;
u_char *elem,*end;
{
  register u_char *w,*suffList,*suffEnd;
  register short i,len,suff;
  register PWDDictPtr p;
  u_char word[256];
  u_char *decode();

  suffList = elem + PWDCountCtls(elem);  /* suffList is a temporary variable here */
  decode(suffList,end,word);
/*{
char str[40];
UnMap(word,str,0);
eprintf("AccMatchEntry(): stem (%c%c%s)\n",UnMapChar(PWDfirst,0),UnMapChar(PWDsecond,0),str);
}*/
  /* match stem here */
  for(i = 2, w = word; *w != '\0'; w++, token++, i++) {
    if(*w == *token)
      continue;
    if (*token == '\0')
      return(0);  /* 16/02/93 stop crash by indexing off end of accents */
    if((*accents)[i] == NIL)
      return(0);  /* no match */
    if(AccMatchChars(*w,(*accents)[i]))
      return(0);  /* no match */
  }

  /* if can stand alone */
  if(PWDGetBit(elem,NOSUFF) != 0)
    return(token[0] == '\0');

  p = *PWD;
  if((p->suffList = PWDCheckHandle(p->suffList,p->file,p->SLStart,0)) == NIL)
    return(0);
  p = *PWD;
  suffEnd = suffList = *p->suffList;
  suffEnd += CNSGetHandleSize(p->suffList);
  for(suff = FIRST_SUFF; suffList < suffEnd; suffList += len + 1, suff++) {
    len = strlen(suffList);
    if(PWDGetBit(elem,suff) != 0)    /* if suffix present */
      if(AccMatchSuff(token,suffList + len - 1,suffList,i) == 0)
        return(1);
  }
  return(0);
}

static ExactCmp(s1,s2)
register u_char *s1;  /* input word */
register u_char *s2;  /* dictionary entry */
{
  register u_char *map1;
  register char result;

  map1 = (*PWD)->chMap;
  for(; *s1 != '\0'; s1++, s2++) {
    if(*s2 == '\0')
      return(1);
    if((result = map1[*s1] - map1[*s2]) == 0)
      if(map1[*s1] == '\0')
        result = *s1 - *s2;
    if(result)
      return(result);
  }
  if(*s2 == '\0')
    return(0);
  return(-1);
}

static CheckExact(token,stat)
register u_char *token;
register u_short stat;
{
  register PWDDictPtr p;
  int found;

  found = 0;
  if(token[1] == '\0' || token[2] == '\0' && (stat & FSTCAP) || (stat & ~(LOWER | FSTCAP)))
  {
    /* RSP 27/10/94 start of block to sort out finding (etc.) in exact dict by deleting */
    /* trailing characters which are not in the dictionary */
    u_char *map;
    u_char *pp;
    int save;

    CNSLock(PWD);
    p = *PWD;

    /* RSP start */
    map = p->chType;
    for (pp = token; (save = *pp) != 0; pp++)
      if (map[save] & NOTDICT)
        break;
    while (pp != token && !found)
    {
      *pp = 0;
      /* end of RSP block */
      if(!MIXED(stat)) {
        if((p->exact1Dict = PWDCheckHandle(p->exact1Dict,p->file,p->E1DStart,1)) != NIL) {
          register long pos;

          pos = CNSLookUp(*p->exact1Dict,token,0L,
                  CNSGetHandleSize(p->exact1Dict),ExactCmp,0,0,&found);
          if(found) {  /* check if the first letters match */
            register u_char temp;

            temp = (*p->exact1Dict)[pos];
            if(p->chType[temp] & UPPER)
              if(temp != token[0])
                found = 0;
          }
          CNSUnlock(p->exact1Dict);
        }
      }
      if(!found) {
        if((p->exact2Dict = PWDCheckHandle(p->exact2Dict,p->file,p->E2DStart,1)) != NIL) {
          CNSLookUp(*p->exact2Dict,token,0L,
                    CNSGetHandleSize(p->exact2Dict),CNSstrcmp,0,0,&found);
          CNSUnlock(p->exact2Dict);
        }
      }
      /* RSP start */
      *(pp--) = save;
      save = *pp;
      if ((p->chType[save] & OTHER) == 0)
        break;
    }
    /* end of RSP block */
    CNSUnlock(PWD);
  }
  return(found);
}

static CheckBig(word,token,stat,suff,length)
u_char *word,*token;
short stat,suff,length;
{
  register PWDDictPtr p;
  register short num;
  register struct PortionType *port;
  register u_char *start,*end;
  register u_short index;
  u_short ss,ee;
  union {
    char c[4];
    short s[2];
    long l;
  } trix;
  long temp;

  p = *PWD;
  if(length > p->maxBig || length < p->minBig)
    return(0);
  if(PWDfirst > p->maxBigFirst || PWDsecond > p->maxBigSecond)
    return(0);

  /* determine the portion(s) to look through   */
  /* then check to see if it is present. if not */
  /* read portion(s).                           */

  port = &p->portions[0];
#ifdef  FLIP
  trix.c[3] = PWDfirst;
  trix.c[2] = PWDsecond;
  if(accentFlag)
    trix.s[0] = 0;
  else {
    trix.c[1] = word[0];
    trix.c[0] = word[1];
  }
#else
  trix.c[0] = PWDfirst;
  trix.c[1] = PWDsecond;
  if(accentFlag)
    trix.s[1] = 0;
  else {
    trix.c[2] = word[0];
    trix.c[3] = word[1];
  }
#endif
  for(num = 0;; num++, port++) {
    /* return 0 if the word is greater than */
    /* the last word of the last section.   */
    if(num >= p->numPortions)
      return(0);
    /* start with the section which last word */
    /* is greater or equal to the input word. */
    if(*(long *)port->last >= trix.l)
      break;
  }
  CNSLock(PWD);
  if((p->bigIndex = (u_short **)PWDCheckHandle(p->bigIndex,p->file,p->BIStart,0)) == NIL)
    goto Failed;
  index = (PWDfirst - 1) * p->maxBigSecond + PWDsecond - 1;
  ss = (*p->bigIndex)[index];
  ee = (*p->bigIndex)[index + 1];
#ifdef  FLIP
  FlipShort(&ss);
  FlipShort(&ee);
#endif

  for(; num < p->numPortions && *(long *)port->first <= trix.l; port++, num++) {
    if(port->list == NIL || *port->list == NIL) {
      /* look through cache only if the portion is not present */
      if(p->goodCache != NIL)
        if(CNSSearch(p->goodCache,token) >= 0)
          goto Found1;  /* success */
      /* read portion(s) here */
      CNSDisposHandle(port->list);
      if((port->list = CNSHandle(p->portionSize)) == NIL) {
        PWDStat.stat |= MEMERROR;
        break;
      }
      CNSPurge(port->list);
      CNSLock(port->list);
      temp = p->portionSize;
      if(num == p->numPortions - 1)
        temp -= port->numUnused;
      if(IOCheck(CNSSetFPos(p->file,fsFromStart,p->BDStart + num * p->portionSize))
                || IOCheck(CNSRead(p->file,&temp,*port->list))) {
        PWDStat.stat |= IOERROR;
        CNSUnlock(port->list);
        break;
      }
      CNSUnlock(port->list);
    }
    /* look through the portion(s) here */
    end = start = *port->list;
#ifdef  FLIP
    if(*(short *)&port->first[2] != trix.s[1])
      start += ss;
    if(*(short *)&port->last[2] == trix.s[1])
      end += p->portionSize - port->numUnused;
    else
      end += ee;
#else
    if(*(short *)port->first != trix.s[0])
      start += ss;
    if(*(short *)port->last == trix.s[0])
      end += p->portionSize - port->numUnused;
    else
      end += ee;
#endif
    end--;
#ifdef  DEBUG
  {
  int res;

  CNSLock(port->list);
  if(debugFlag) {
    eprintf("\rCheckBig(): index %d, bigIndex[index] %x, bigIndex[index + 1] %x, *port->list %lx, portion %d\r",
        index,(*p->bigIndex)[index],(*p->bigIndex)[index + 1],*port->list,num);
    eprintf("\t\tport->first %c%c%c%c, port->last %c%c%c%c, trix %c%c%c%c\r",
            UnMapChar(port->first[0],0),UnMapChar(port->first[1],0),
            UnMapChar(port->first[2],0),UnMapChar(port->first[3],0),
            UnMapChar(port->last[0],0),UnMapChar(port->last[1],0),
            UnMapChar(port->last[2],0),UnMapChar(port->last[3],0),
            UnMapChar(trix.c[0],0),UnMapChar(trix.c[1],0),
            UnMapChar(trix.c[2],0),UnMapChar(trix.c[3],0));
  }
  if(accentFlag)
    res = AccMatchDict(word,start,end);
  else
    res = PWDMatchDict(word,start,end,stat & FSTCAP,suff);
  CNSUnlock(port->list);
  if(res)
    goto Found;
  }
#else
  if(accentFlag) {
    if(AccMatchDict(word,start,end))
      goto Found;
  } else {
    if(PWDMatchDict(word,start,end,stat & FSTCAP,suff))
      goto Found;
  }
#endif
  }
Failed:
  CNSUnlock(PWD);
  return(0);
Found:
  /* put token in cache only if it was found */
  if(p->goodCache != NIL)
    CNSInsert(p->goodCache,token);
Found1:
  CNSUnlock(PWD);
  return(1);
}

#ifdef DEBUG
Debug(word,mid,end)
u_char *word,*mid,*end;
{
  register u_char *s,*t;
  u_char xxx[64],yyy[64];
  u_char *decode();

  if(!debugFlag)
    return;
  decode(word,word + strlen(word) - 1,yyy);
  UnMap(yyy,xxx,0);
  eprintf("%s -- %lx ",xxx,mid);
  s = mid + PWDCountCtls(mid);
  for(; mid < s; mid++)        /* print controls */
    eprintf("%x ",*mid);
  eprintf("-- ( ");
  t = xxx;
  while(((char)*s) > 0) {        /* print codes */
    eprintf("%d ",*s);
    *t = *s;
    t++;
    s++;
  }
  *t = 0x80;
  decode(xxx,t,yyy);
  UnMap(yyy,xxx,0);
  eprintf(") %s\r",xxx);
}
#endif

PWDencode(from,to)
register u_char *from,*to;
{
  register u_char *map,sym1,sym2;
  register u_short *level1;
#ifdef  FLIP
  register u_char c;
#endif
  union {
    u_short s;
    u_char c[2];
  } temp;

  /* functions calling encode must check for encodeTable presence */
  map = *(*PWD)->encodeTable;
  level1 = (u_short *)map;
  for(; (sym1 = from[0]) != '\0'; to++) {
    if((sym2 = from[1]) == '\0'
        || sym1 > map[0] || sym2 > map[1]
        || (temp.s = level1[sym1]) == 0)
      goto NextChar;
#ifdef  FLIP
    c = temp.c[0];
    temp.c[0] = temp.c[1];
    temp.c[1] = c;
#endif
    if((sym2 = map[temp.s + sym2 - 1]) == '\0')
      goto NextChar;
    *to = sym2;
    from += 2;
    continue;
NextChar:
    *to = sym1;
    from++;
  }
  *to = '\0';
}

static u_char *decode(from,end,to)
register u_char *from,*to;
u_char *end;
{
  union {
    u_short sym;
    u_char ch[2];
  } trix;
  register u_char *e;

  e = end;
  while(from <= e && *((char *)from) > 0) {
    trix.sym = (*PWD)->decodeTable[*from];
    if(trix.sym != 0) {
      to[0] = trix.ch[0];
      to[1] = trix.ch[1];
      to += 2;
    } else {
      to[0] = from[0];
      to++;
    }
    from++;
  }
  *to = '\0';
  return(to);
}

static struct CNSDictType **guesses;
static u_char **Rearrange();

static short com1(s1,s2)
register char *s1,*s2;
{
  register char rank;
  register short result;

  /* skip the ranking byte */
  if((result = strcmp(s1 + 1,s2 + 1)) == 0) {
    rank = *s1;
    if(rank > *s2)  /* choose the smallest rank */
      rank = *s2;
    *s1 = rank;
    *s2 = rank;
  }
  return(result);
}

static short com2(s1,s2)
register char *s1,*s2;
{
  register char x;

  /* compare ranking bytes */
  if((x = *s1 - *s2) != 0)
    return(x);
  /* skip ranking bytes */
  return(Intl_strcmp(s1 + 1,s2 + 1));
}

u_char **Guess(dict,startT,endT,cast)
PWDDictHandle dict;
u_char *startT,*endT;
short cast;
{
  register short stat,save;
  u_char word[256],**h;

  if((guesses = CNSNewDict('\0',GrowSize,512L,0x7fffffffL,512L,com1)) == NULL) {
    PWDStat.stat = MEMERROR;
    return(NULL);
  } else {
    PWDStat.stat = 0;
    CastMode = cast;
    PWD = dict;
    PWDcompound = wordStat = onStat = postStat = PWDpostLen = PWDonLen = 0;
    PWDallLen = endT - startT + 1;
    save = (*PWD)->flags;
    (*PWD)->flags &= ~TryCompound;  /* turn compounding off for guesses */
    stat = GetStat(startT,endT,word,0) & ~NOTDICT;
    DoGuess(word,stat);
    (*PWD)->flags = save;
    h = Rearrange(Dict2Handle(guesses));
    PWD = NIL;
    return(h);
  }
}

static u_char **Rearrange(h)
register u_char **h;
{
  register u_char *s,*e;

  if(h == NULL)
    return(NULL);
  if((guesses = CNSNewDict('\0',GrowSize,512L,0x7fffffffL,512L,com2)) == NULL) {
    CNSDisposHandle(h);
    PWDStat.stat |= MEMERROR;
    return(NULL);
  }
  s = *h;
  e = s + CNSGetHandleSize(h);
  for(; s < e; s += strlen(s) + 1)
    if(CNSInsert(guesses,s) == 1) {
      PWDStat.stat |= MEMERROR;
      break;
    }
  CNSDisposHandle(h);
  return(Dict2Handle(guesses));
}

static DoGuess(word,stat)
u_char *word;
u_short stat;
{
  u_char token[256];
  short len;

  if(GuessUser(PWD,word,stat))
    if(Exact1Guess(word,stat))
      if(PWDonLen == 0 || Exact1Guess(word + PWDonLen,stat)) { /* skip onShtutz */
        len = MapGuess(word + PWDonLen,token);
        if(GuessDict(token,stat,len))
          if(PhoneGuess(token,stat,len))
            return(1);
      }
  return(0);
}

static Exact1Guess(tt,stat)
u_char *tt;
short stat;
{
  register PWDDictPtr p;
  register result;

  CNSLock(PWD);
  p = *PWD;
  result = 0;
  if((p->exact1Dict = PWDCheckHandle(p->exact1Dict,p->file,p->E1DStart,0)) != NIL) {
    if(ExactGuess(tt,stat,p->exact1Dict,CNSGetHandleSize(p->exact1Dict),1))
      if((p->exact2Dict = PWDCheckHandle(p->exact2Dict,p->file,p->E2DStart,0)) != NIL)
        result = ExactGuess(tt,0,p->exact2Dict,CNSGetHandleSize(p->exact2Dict),0);
  }
  CNSUnlock(PWD);
  return(result);
}

GuessExact(tt,h,size)
u_char *tt;
u_char **h;
long size;
{
  return(ExactGuess(tt,0,h,size,0));
}

static ExactGuess(tt,stat,h,size,cast)
u_char *tt;
short stat;
register u_char **h;
long size;
short cast;
{
  register u_char *s,*e;
  u_char token[257],guess[257];

  convert(tt,token);
  CNSLock(h);
  s = *h;
  e = s + size;
  for(; s < e; s += strlen(s) + 1) {
    convert(s,guess);
    if(guess[0] = alike(token+1,guess+1,0,token[0],guess[0])) {
      strcpy(guess+1,s);
      if(InsertGuess(guess,stat,cast) == 0)
        goto Error;
    }
  }
  CNSUnlock(h);
  return(1);
Error:
  CNSUnlock(h);
  return(0);    /* no memory */
}

InsertGuess(guess,stat,cast)
u_char *guess;
short stat,cast;
{
  register short result;

/* eprintf("InsertGuess(): guess (%s), PWDonLen %d\n",guess,PWDonLen); */
  if(cast) {
    if(PlaceGuess(guess,stat) == 0)
      goto Error;
  } else if(PWDonLen == 0 || ((*PWD)->chType[guess[1]] & VOWEL)) {
    if((result = UserTakeGuess(guess)) == 2)
      goto Error;      /* stop guessing */
    else if(result != 1)  /* UserTakeGuess() doesn't want to handle this guess */
      if(CNSInsert(guesses,guess) == 1) {
        PWDStat.stat |= MEMERROR;
        goto Error;
      }
  }
  return(1);
Error:
  return(0);
}

/* convert "C" string to C/Pascal string and map */
static convert(src,dst)
u_char *src,*dst;
{
  register u_char *s1,*s2,*map;

  map = (*PWD)->chMap;
  /* convert input token to pascal string */
  for(s1 = dst + 1, s2 = src; *s2 != '\0'; s2++)
    if((*s1 = map[*s2]) != 0)  /* ignore nonalphabetics */
      s1++;
  *s1 = '\0';
  dst[0] = s1 - &dst[1];
}

static GuessDict(word,stat,len)
register u_char *word;
register short stat,len;
{
  if(word[1] != '\0') {  /* smallest word is 2 chars long */
    PWDfirst = word[0];
    PWDsecond = word[1];
    if(GuessCommon(word,stat,len) == 0 || GuessBig(word,stat,len) == 0)
      return(0);
  }
  return(1);
}

static MapGuess(token,word)
u_char *token,*word;
{
  register u_char *t,*w,*map;

  map = (*PWD)->chMap;
  t = token;
  w = word;
  for(; *t != '\0'; t++, w++)
    if((*w = map[*t]) == '\0')
      *w = 0x7f;  /* map unrecognized chars to 0x7f */
  w -= PWDpostLen;  /* remove postShtutz */
  *w = '\0';
  return(w - word);
}

static GuessCommon(word,stat,wordLen)
u_char *word;
short stat,wordLen;
{
  register PWDDictPtr p;
  register u_char *start,*end;
  register u_short index;
  u_short ss,ee;

  p = *PWD;
  if(PWDfirst > p->maxComFirst || PWDsecond > p->maxComSecond)
    return(1);
  index = (PWDfirst - 1) * p->maxComSecond + PWDsecond - 1;
  CNSLock(PWD);
  if((p->commIndex = (u_short **)PWDCheckHandle(p->commIndex,p->file,p->CIStart,0)) == NIL) {
    CNSUnlock(PWD);
    return(0);
  }
  ss = (*p->commIndex)[index];
  ee = (*p->commIndex)[index + 1];
#ifdef  FLIP
  FlipShort(&ss);
  FlipShort(&ee);
#endif

  p->commList = PWDCheckHandle(p->commList,p->file,p->CLStart,1);
  CNSUnlock(PWD);
  if(p->commList == NIL)
    return(0);
  start = end = *p->commList;
  start += ss;
  end += ee;
  end--;
  while(start <= end) {
    if(GuessEntry(word,wordLen,start,end,stat,0) == 0) {
      CNSUnlock((*PWD)->commList);
      return(0);
    }
    do
      start++;
    while((*(char *)start) > 0);
  }
  CNSUnlock((*PWD)->commList);
  return(1);
}

static GuessBig(word,stat,wordLen)
u_char *word;
short stat,wordLen;
{
  register PWDDictPtr p;
  register short num;
  register struct PortionType *port;
  register u_char *start,*end;
  register u_short index;
  u_short ss,ee;
  union {
    char c[4];
    short s[2];
    long l;
  } trix;
  long temp;
  long GetTrix();

  p = *PWD;
  if(PWDfirst > p->maxBigFirst || PWDsecond > p->maxBigSecond)
    return(1);
  index = (PWDfirst - 1) * p->maxBigSecond + PWDsecond - 1;

  port = &p->portions[0];
  CNSLock(PWD);
  if((p->bigIndex = (u_short **)PWDCheckHandle(p->bigIndex,p->file,p->BIStart,0)) == NIL)
    goto Fail1;
  ss = (*p->bigIndex)[index];
  ee = (*p->bigIndex)[index + 1];
#ifdef  FLIP
  FlipShort(&ss);
  FlipShort(&ee);
#endif
  if((trix.l = GetTrix(word,ss,ee)) == 0)
    goto Good;
  for(num = 0;; num++, port++) {
    if(num >= p->numPortions)
      goto Good;
    if (*(long *)port->last >= trix.l)
      break;
  }
  for(; num < p->numPortions && *(long *)port->first <= trix.l; port++, num++) {
    if(port->list == NIL || *port->list == NIL) {
      /* read portion(s) here */
      CNSDisposHandle(port->list);
      if((port->list = CNSHandle(p->portionSize)) == NIL) {
        PWDStat.stat |= MEMERROR;
        goto Fail1;
      }
      CNSPurge(port->list);
      temp = p->portionSize;
      if(num == p->numPortions - 1)
        temp -= port->numUnused;
      if(IOCheck(CNSSetFPos(p->file,fsFromStart,p->BDStart + num * p->portionSize))
                || IOCheck(CNSRead(p->file,&temp,*port->list))) {
        PWDStat.stat |= IOERROR;
        goto Fail1;
      }
    }
    /* look through the portion(s) here */
    end = start = *port->list;
#ifdef  FLIP
    if(*(short *)&port->first[2] != trix.s[1])
      start += ss;
    if(*(short *)&port->last[2] == trix.s[1])
      end += p->portionSize - port->numUnused;
    else
      end += ee;
#else
    if(*(short *)port->first != trix.s[0])
      start += ss;
    if(*(short *)port->last == trix.s[0])
      end += p->portionSize - port->numUnused;
    else
      end += ee;
#endif
    end--;
    CNSLock(port->list);
    while(start <= end) {
#ifdef  FLIP
      if(GuessEntry(word,wordLen,start,end,stat,trix.c[1]) == 0)
        goto Fail;
#else
      if(GuessEntry(word,wordLen,start,end,stat,trix.c[2]) == 0)
        goto Fail;
#endif
      do
        start++;
      while((*(char *)start) > 0);
    }
    CNSUnlock(port->list);
  }
Good:
  CNSUnlock(PWD);
  return(1);
Fail:
  CNSUnlock(port->list);
Fail1:
  CNSUnlock(PWD);
  return(0);
}

static long GetTrix(word,ss,ee)
u_char *word;
u_short ss,ee;
{
  register PWDDictPtr p;
  register struct PortionType *port;
  register short num;
  register long size;
  union {
    char c[4];
    short s[2];
    long l;
  } trix;
  u_char temp[4];

#ifdef  FLIP
  trix.c[3] = PWDfirst;
  trix.c[2] = PWDsecond;
  trix.s[0] = 0;
#else
  trix.c[0] = PWDfirst;
  trix.c[1] = PWDsecond;
  trix.s[1] = 0;
#endif
  p = *PWD;
  port = &p->portions[0];
  for(num = 0;; num++, port++) {
    if(num >= p->numPortions)
      return(0L);
    if(*(long *)port->last >= trix.l)
      break;
  }
  for(size = 0; num < p->numPortions && *(long *)port->first <= trix.l; port++, num++) {
#ifdef  FLIP
    if(*(short *)&port->last[2] == trix.s[1])
      size += p->portionSize - port->numUnused;
    else
      size += ee;
    if(*(short *)&port->first[2] != trix.s[1])
      size -= ss;
#else
    if(*(short *)port->last == trix.s[0])
      size += p->portionSize - port->numUnused;
    else
      size += ee;
    if(*(short *)port->first != trix.s[0])
      size -= ss;
#endif
  }
  if(size >= 5120L) {
    temp[0] = word[2];
    temp[1] = word[3];
    temp[2] = '\0';
    if(p->encodeTable == NIL || *p->encodeTable == NIL)
      p->encodeTable = PWDCheckHandle(p->encodeTable,p->file,p->ETStart,0);
    if(p->encodeTable != NIL)
      PWDencode(temp,temp);
#ifdef  FLIP
    trix.c[1] = temp[0];
#else
    trix.c[2] = temp[0];
#endif
  }
  return(trix.l);
}

static GuessEntry(word,wordLen,elem,end,stat,ch)
u_char *word;
register short wordLen;
u_char *elem,*end;
short stat;
char ch;
{
  register u_char *suffList,*suffEnd,*rootEnd;
  register short suff,len,cap,diff,slack,rootLen;
  register PWDDictPtr p;
  short matched;
  u_char guess[256];

  if(UserCancel())
    return(0);
  guess[0] = PWDfirst;
  guess[1] = PWDsecond;
  suffList = elem + PWDCountCtls(elem);  /* suffList is a temporary variable here */
  if(ch == '\0' || ch == *suffList) {      /* check if we are in range */
    rootEnd = decode(suffList,end,guess+2);
/*{
char str[40];
UnMap(guess,str,0);
eprintf("%15s %08lx\r",str,*(long *)suffList);
}*/
    rootLen = rootEnd - guess;
    diff = wordLen - rootLen;
    slack = wordLen / 4 + 1;
    if(slack > 3)
      slack = 3;
    if(Filter(word,wordLen,guess,rootLen,slack,&matched)) {
      cap = (stat & FSTCAP) || PWDGetBit(elem,CAPBIT);
      if(PWDGetBit(elem,NOSUFF) != 0)    /* if can stand alone */
        if(CheckGuess(word,guess,cap,stat,wordLen,rootLen,matched) == 0)
          return(0);    /* no memory */
      CNSLock(PWD);
      p = *PWD;
      if((p->suffList = PWDCheckHandle(p->suffList,p->file,p->SLStart,1)) == NIL)
        goto Fail;
      suffEnd = suffList = *p->suffList;
      suffEnd += CNSGetHandleSize(p->suffList);
      for(suff = FIRST_SUFF; suffList < suffEnd; suffList += len + 1, suff++) {
        len = strlen(suffList);
        if(diff - len >= -slack && diff - len <= slack) {
          if(PWDGetBit(elem,suff) != 0) {    /* if suffix present */
            /* tack the suffix on here */
            copy(rootEnd,suffList + len - 1,suffList);
            if(CheckGuess(word,guess,cap,stat,wordLen,rootLen + len,matched) == 0)
              goto Fail;    /* no memory */
          }
        }
      }
      CNSUnlock(p->suffList);
      CNSUnlock(PWD);
    }
  }
  return(1);
Fail:
  CNSUnlock(p->suffList);
  CNSUnlock(PWD);
  return(0);
}

static copy(d,end,start)
register u_char *d,*end,*start;
{
  for(; start <= end; end--, d++)
    *d = *end;
  *d = '\0';
}

static CheckGuess(word,guess,cap,stat,wordLen,guessLen,pos)
u_char *word,*guess;
short cap,stat,wordLen,guessLen,pos;
{
  u_char str[257];

  if(str[0] = alike(word,guess,pos,wordLen,guessLen)) {
    UnMap(guess,str + 1,cap);
    if(PlaceGuess(str,stat) == 0)
      return(0);    /* no memory */
    if(cap != 0 && ((*PWD)->flags & TryAccent)) {
      str[1] = UnMapChar(*guess,3);
      if(PlaceGuess(str,stat) == 0)
        return(0);    /* no memory */
    }
  }
  return(1);
}

static UnMapChar(ch,cap)
register u_short ch;
register u_short cap;
{
  register u_char *map;
  register PWDDictPtr dp;

  CNSLock(PWD);
  dp = *PWD;
  dp->etc = PWDCheckHandle(dp->etc,dp->file,dp->ETCStart,0);
  CNSUnlock(PWD);
  if(dp->etc == NIL)
    return(0);
  map = *dp->etc;  /* map -> onShtutz */
  map += map[0];    /* map -> postShtutz */
  map += map[0];    /* map -> unmap map */
  if(cap)
    if((cap & 2) && (dp->flags & TryAccent))  /* map to un-accented upper case */
      map += dp->maxCode + dp->maxCode + 2;
    else                    /* map to accented upper case */
      map += dp->maxCode + 1;
  return(map[ch]);
}

static UnMap(src,dst,cap)
register u_char *src,*dst;
u_short cap;
{
  register u_char *map;
  register PWDDictPtr dp;

  if(*src == '\0')
    *dst = '\0';
  else {
    CNSLock(PWD);
    dp = *PWD;
    dp->etc = PWDCheckHandle(dp->etc,dp->file,dp->ETCStart,0);
    CNSUnlock(PWD);
    if(dp->etc == NIL)
      *dst = '\0';
    else {
      map = *dp->etc;    /* map -> onShtutz */
      map += map[0];    /* map -> postShtutz */
      map += map[0];    /* map -> unmap map */
      if(!cap)            /* map to lower case */
        *dst = map[*src];
      else if((cap & 2) && (dp->flags & TryAccent))  /* map to un-accented upper case */
        *dst = map[*src + dp->maxCode + dp->maxCode + 2];
      else              /* map to accented upper case */
        *dst = map[*src + dp->maxCode + 1];
      while(src[1] != '\0') {
        src++;
        dst++;
        *dst = map[*src];
      }
      dst[1] = '\0';
    }
  }
}

static PhoneGuess(word,stat,len)
register u_char *word;
short stat;
register short len;
{
  register PWDDictPtr dp;
  register u_char c1,c2,c3;

  c1 = word[0];
  c2 = word[1];
  c3 = word[2];
  if(c2 != '\0') {
    word[0] = c2;
    word[1] = c1;
    if(CheckIt(word,len,stat,1) == 0)
      return(0);
    if(c3 != '\0') {
      word[0] = c1;
      word[1] = c3;
      word[2] = c2;
      if(CheckIt(word,len,stat,1) == 0)
        return(0);
      word[0] = c3;
      word[1] = c2;
      word[2] = c1;
      if(CheckIt(word,len,stat,1) == 0)
        return(0);
    }
  }
  word[0] = c1;
  word[1] = c2;
  word[2] = c3;
  if(CheckIt(word,len,stat,1) != 0) {  /* if no errors occurred */
    register u_char **temp;

    dp = *PWD;
    if((temp = PWDCheckHandle(dp->phonemes,dp->file,dp->PHStart,1)) != NIL) {
      (*PWD)->phonemes = temp;
      len = DoPhones(word,word,1,stat);
      CNSUnlock(temp);
      return(len);
    }
  }
  return(0);
}

static DoPhones(word,start,level,stat)
u_char *word,*start;
short level,stat;
{
  register u_char *p,*e;

  if(level > 0) {
/* eprintf("DoPhones(): word (%s), start (%s), level %d\r",word,start,level); */
    p = *(*PWD)->phonemes;
    e = p + CNSGetHandleSize((*PWD)->phonemes);
    for(; p < e; p += *p)
      if(MatchRing(word,start,p,level,stat) == 0)
        return(0);  /* an error occurred */
  }
  return(1);
}

static MatchRing(word,start,ring,level,stat)
u_char *word,*start,*ring;
short level,stat;
{
  register u_char *w,*r,*e,*w1,*r1,wild;

  for(w1 = start; *w1 != '\0'; w1++) {
    for(r = ring, e = r + *r, r++; r < e; r++) {
/* eprintf("w1 (%s), r1 (%s)\r",w1,r); */
      wild = '\0';
      r1 = r;
      if(*r == FIRSTLTR)
        r++;
      for(w = w1; *r != '\0'; r++) {
        if(*r == WILDCARD) {
          if((wild = *w) == '\0')
            goto NextPattern;
        } else if(*w != *r)
          goto NextPattern;
        w++;
      }
      /* if we are here the pattern matched  */
      /* replace the matched word section by */
      /* other ring elements.                */
/* eprintf("(%s) matched (%s), level %d\r",r1,w1,level); */
      if(Replace(word,w1,w,ring,r1,wild,level,stat) == 0)
        return(0);
NextPattern:
      while(*r != '\0')
        r++;
    }
    /* if this was FIRSTLTR ring then stop */
    if(ring[1] == FIRSTLTR)
      break;
  }
  return(1);
}

static Replace(word,w1,w,ring,r1,wild,level,stat)
u_char *word,*w1,*w,*ring,*r1,wild;
short level,stat;
{
  register u_char *s,*p,*q,*e,*start;
  register short rank;
  u_char guess[256];

  for(s = guess, p = word, e = w1; p < e; s++, p++)
    *s = *p;
  start = s;
  for(p = ring, e = p + *p, p++; p < e; p++) {
/* eprintf("Replacing with (%s)\r",p); */
    if(p == r1) {
      while(*p != '\0')
        p++;
    } else {
      /* place the replacement pattern into the "guess" */
      for(s = start; *p != '\0'; p++) {
        if(*p == WILDCARD) {
          if(wild == '\0')
            continue;
          *s = wild;
          s++;
        } else if(*p != FIRSTLTR) {
          *s = *p;
          s++;
        }
      }
      /* place the rest of the word */
      for(q = w;; q++, s++)
        if((*s = *q) == '\0')
          break;
      /* At this point we have our guess. */
/* eprintf("Replace(): guess is (%s)\r",guess); */
      if((rank = (q - word) - (s - guess)) < 0)
        rank = -rank;
      if(rank == 0)
        rank++;
      if(CheckIt(guess,(short)(s - guess),stat,rank) == 0)
        return(0);  /* an error occurred */
      /* try one more level of phonetics */
      if(DoPhones(guess,&guess[w - word],level - 1,stat) == 0)
        return(0);  /* an error occurred */
    }
  }
  return(1);
}

static CheckIt(guess,len,stat,rank)
register u_char *guess;
short len,stat,rank;
{
  register unsigned short errstat,r;
  register short onSave,postSave;
  u_char str[257];

  if(UserCancel())
    return(0);
  str[0] = rank;
  UnMap(guess,str+1,0);
/* eprintf("CheckIt(): guess is (%d %s)\r",str[0],str+1); */
  errstat = PWDStat.stat;
  PWDStat.stat = 0;
  onSave = PWDonLen;
  postSave = PWDpostLen;
  r = MatchOne(str + 1,str + len,0);
  PWDpostLen = postSave;
  PWDonLen = onSave;
  if(r || PWDStat.stat == CAPERROR) {
    if(PWDStat.stat == CAPERROR) {
      PWDStat.stat &= ~CAPERROR;
      if((*PWD)->flags & TryAccent) {
        str[1] = UnMapChar(guess[0],3);  /* convert to un-accented upper case */
        PlaceGuess(str,stat);
      }
      str[1] = UnMapChar(guess[0],1);  /* convert to accented upper case */
    }
    PlaceGuess(str,stat);
  }
  if(PWDStat.stat) {
    PWDStat.stat |= errstat;
    return(0);
  }
  PWDStat.stat |= errstat;
  return(1);
}

static PlaceGuess(gg,stat)
u_char *gg;
short stat;
{
  register u_char *p,*map,ch,cap,r;
  u_char guess[256];

/* eprintf("PlaceGuess(): %s %04x\n",gg,stat); */
  /* if no onShtutz or a guess starts w/ a vowel or 'h' */
  if(PWDonLen == 0 || ((*PWD)->chType[guess[1]] & VOWEL)) {
    cap = 1;  /* convert to accented upper case */
Again:
    p = (u_char *)strcpy(guess,gg) + 1;
    if(CastMode) {  /* match first capital or all upper */
      /* if input word is mixed or lower case do nothing */
      if(!MIXED(stat) && (stat & (FSTCAP|UPPER))) {
        map = (*PWD)->chMap;
        if(stat & UPPER) {  /* if all caps */
          for(; *p != '\0'; p++) {
            if((ch = map[*p]) != '\0')
              *p = UnMapChar(ch,cap);  /* convert to upper case */
          }
        } else {      /* if first cap */
          if((ch = map[*p]) != '\0')
            *p = UnMapChar(ch,cap);  /* convert to upper case */
        }
      }
    }
    if((r = UserTakeGuess(guess)) == 2)
      return(0);  /* stop guessing */
    else if(r != 1)  /* UserTakeGuess() doesn't want to handle this guess */
      if(CNSInsert(guesses,guess) == 1) {
        PWDStat.stat |= MEMERROR;
        return(0);    /* no memory */
      }
    if(CastMode && ((*PWD)->flags & TryAccent) && cap != 3) {
      cap = 3;  /* convert to un-accented upper case */
      goto Again;
    }
  }
  return(1);
}

static Filter(textStart,textLen,dictStart,dictLen,slack,matches)
register u_char *textStart,*dictStart;
register short textLen;
short slack,dictLen,*matches;
{
  register short pos,bads,end;

  if(textLen + slack < dictLen)
    return(0);
  /*
  if(dictLen + slack + maxSuffLen < textLen)
    return(0);
  */
  if(textLen > dictLen)
    textLen = dictLen;
  bads = textLen / 7;
  end = textLen - 1 - slack;
  for(pos = 0; pos < end; pos++) {
    bads -= matchChar(textStart[pos],dictStart,pos - slack,pos + slack,textLen);
    bads -= matchChar(dictStart[pos],textStart,pos - slack,pos + slack,textLen);
    if(bads < 0)
      return(0);
  }
  for(pos = 0; pos < textLen; pos++)
    if(textStart[pos] != dictStart[pos])
      break;
  *matches = pos;
  return(1);
}

/*alike------------------------------------------------------------*/
/* alike() is called by GuessBig() and GuessCom() to see whether a */
/* word in the dictionary (w2) is similar enough to the input     */
/* word (w1) to warrant inclusion in the list of guesses.         */
/* If the words are of equal length, call eqnear. If the words    */
/* are of different length, call lessnear.                        */

alike(w1,w2,pos,len1,len2)
u_char *w1,*w2;
short pos;
register short len1,len2;
{
  if(len1 == len2)
    return(eqnear(w1,w2,pos,len1));
  if(len1 < len2)
    return(lessnear(w1,w2,pos,len1,len2));
  return(lessnear(w2,w1,pos,len2,len1));
}
/*------------------------------------------------------------alike*/

/*eqnear----------------------------------------------------------*/
/* March through w1 character by character.  Make sure that the   */
/* nth character of w1 matches either the (n-1)th, the nth, or    */
/* the (n+1)th character of w2.  We are allowed to fail x times   */
/* at most, where x is the length of w1 (and w2) divided by 7.    */

static eqnear(w1,w2,pos,len)
register u_char *w1,*w2;
register short pos,len;
{
  register short bads,badstart,flags;

  bads = len / 8 + 1;
  if(bads < 2)
    bads = 2;
  if(len < 5)
    bads = 0;
  badstart = bads;
  for(; pos < len; pos++) {
    bads -= matchChar(w1[pos],w2,pos - 1,pos + 1,len);
    bads -= matchChar(w2[pos],w1,pos - 1,pos + 1,len);
    if(bads < 0)
      return(0);
  }
  len--;
  flags = (*PWD)->flags;
  if((flags & MatchLast) && w1[len] != w2[len])
    bads--;
  len--;
  if((flags & MatchN2Last) && w1[len] != w2[len])
    bads--;
  if(bads < 0)
    return(0);
  bads = badstart - bads + 1;
  if(w1[len+1] != w2[len+1])
    bads++;
  return(bads);
}
/*----------------------------------------------------------eqnear*/

/*lessnear--------------------------------------------------------*/
static lessnear(w1,w2,pos,len1,len2)
register u_char *w1,*w2;
register short pos,len1,len2;
{
  register short bads,slack,diff,badstart,flags;

  diff = len2 - len1;
  if(diff > 3 || diff > len1 / 3)
    return(0);
  bads = len1 / 7 + 1;
  badstart = bads;
  slack = 0;
  if(len1 > 5)
    slack = 1;
  for(; pos < len1; pos++) {
    bads -= matchChar(w1[pos],w2,pos - slack,pos + slack + diff,len2);
    bads -= matchChar(w2[pos],w1,pos - slack - diff,pos + slack,len1);
    if(bads < 0)
      return(0);
  }
  for(; pos < len2; pos++) {
    bads -= matchChar(w2[pos],w1,pos - slack - diff,pos + slack,len1);
    if(bads < 0)
      return(0);
  }
  if(badstart - bads < diff)
    bads = badstart - diff;
  flags = (*PWD)->flags;
  len1--;
  len2--;
  if((flags & MatchLast) && w1[len1] != w2[len2])
    bads--;
  len1--;
  len2--;
  if((flags & MatchN2Last) && w1[len1] != w2[len2])
    bads--;
  if(bads < 0)
    return(0);
  bads = badstart - bads + 1;
  len1++;
  len2++;
  if(w1[len1] != w2[len2])
    bads++;
  return(bads);
}
/*--------------------------------------------------------lessnear*/
