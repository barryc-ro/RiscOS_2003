/************************************************************************/
/* 	        Copyright 1996 Acorn Network Computers		        */
/*									*/
/*  This material is the confidential trade secret and proprietary	*/
/*  information of Acorn Network Computers. It may not be reproduced,   */
/*  used sold, or transferred to any third party without the prior      */
/*  written consent of Acorn Network Computers. All rights reserved.	*/
/* 									*/
/************************************************************************/

/*
 *
 * Modification History
 *---------------------
 *
 * 02-Sep-1996 Added error messages in textual form
 * 02-Sep-1996 Added chv enable/disable
 * 08-Nov-1996 Added wrong instruction class error message
 * 10-Jan-1997 Added interactive mode
 * 13-Jan-1997 Display file size during dump
 * 19-Feb-1997 Added unblock command, changed chv enable|disable format
 * 	       commented out the file create commands.
 * 25-Feb-1997 Fixed caseness bug found using the unblock command.
 * 07 Apr 1997 Added CLI.
 * 09 May 1997 Added change chv command
 * 12 May 1997 allow blank lines
 * 19 May 1997 Added atr breakdown, rawatr, serial, stat, support for
 *             lineeditor.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"
#include "error.h"
#include "constants.h"
#include "scinter.h"

#define APPNAME "SCProgram"
#define VERSION "2.07"

char *file_status[] = {"Invalidated","Validated"};
char *ac[] = {"ALW","CHV1","CHV2","PRO","AUT","","CHV & PRO","","CHV & AUT",
              "","ADM1","ADM2","ADM3","ADM4","ADM5","NVR"};

char *atr_manuf[] = {"Reserved","Reserved","Reserved","I2C","Microwire",
     		     "InCard","Orga","Schlumberger","Gemplus"};
char *atr_licencee[] = {"Reserved","Acorn","NCI","Net products"};
/*
 * script processing table
 */
static cmd_ret_t _write     (int, char**);
static cmd_ret_t _read      (int, char**);
static cmd_ret_t _code      (int, char**);
static cmd_ret_t _display   (int, char**);
static cmd_ret_t _wait      (int, char**);
static cmd_ret_t _createdir (int, char**);
static cmd_ret_t _createfile(int, char**);
static cmd_ret_t _chv       (int, char**);
static cmd_ret_t _unblock   (int, char**);
static cmd_ret_t _dump      (int, char**);
static cmd_ret_t _help	    (int, char**);
static cmd_ret_t _quit      (int, char**);
static cmd_ret_t _changechv (int, char**);
static cmd_ret_t _atr       (int, char**);
static cmd_ret_t _atr_raw   (int, char**);
static cmd_ret_t _serial    (int, char**);
static cmd_ret_t _stat      (int, char**);

static const cmd_t cmd_tbl[] = {
 _code,      "code",      "code <code number>",
 	     		  "submit the given code for chv1 verification",
 _dump,	     "dump",      "dump <scfilename>",
                          "dump card file to screen",
 _write,     "write",     "write <filename> <scfilename>",
 	     		  "write disk file to smartcard",
 _read,      "read",      "read <filename> <scfilename>",
 	     		  "read scartcard file to disk file",
 _display,   "display",   "display <text to be displayed>",
 	     		  "display the supplied text on screen",
 _wait,	     "wait",      "wait",
 	     		  "wait for a key to be pressed",
 _atr,	     "atr",	  "atr",
 	     		  "display atr breakdown",
 _atr_raw,   "rawatr",	  "atr",
 	     		  "display atr in raw form",
 _serial,    "serial",	  "serial <filename>",
 	     		  "display card serial number",
 _stat,	     "stat",      "stat <filename>",
 	     		  "display DF/EF stats",
/*
 _createdir, "createdir", "createdir <scfilename> <size> <access>",
                          "create directory on smartcard",
 _createfile,"createfile","createfile <scfilename> <size> <access>",
                          "create file on smartcard",
*/
 _chv,       "chv",       "chv <enable|disable>",
                          "change chv1 state",
 _changechv, "change",	  "change <new chv1 code>",
 	     		  "change chv value",
 _unblock,   "unblock",	  "unblock <unblock code> <new chv1 code>",
 	     		  "unblock a blocked card",
 _help,	     "help",      "help [command]",
                          "display help on selected keyword",
 _quit,	     "quit",      "quit","quit application",
 0,0,0,0
};

char sc_code[9] = "";

/*
 * display an error message given an SCInterface error number
 */
char *
get_error_msg(int errnum)
{
  switch (errnum)
  {
    case 0x01 :
      return "smart card not inserted";
    case 0x02 :
      return "file path format error";
    case 0x03 :
      return "too many nexted subdirectories";
    case 0x04 :
      return "do not understand inserted card";
    case 0x05 :
      return "still processing previous command";
    case 0x06 :
      return "smart card reserved filename specified";
    case 0x07 :
      return "command not implemented on this card";
    case 0x10 :
      return "requested file not found";
    case 0x11 :
      return "error returned from SCTransport";
    case 0x12 :
      return "not enough space to fit requested data";
    case 0x13 :
      return "file already exists";
    case 0x14 :
      return "storage problem";
    case 0x15 :
      return "no file selected";
    case 0x16 :
      return "outside valid area";
    case 0x17 :
      return "file type is inconsistant with command";
    case 0x18 :
      return "unknown response code returned";
    case 0x19 :
      return "incorrect parameter values p1,p2";
    case 0x1a :
      return "incorrect parameter value p3";
    case 0x1b :
      return "technical problem with no diagnostics given";
    case 0x1c :
      return "wrong instruction class byte";
    case 0x20 :
      return "no access code defined";
    case 0x21 :
      return "failed access code verification";
    case 0x22 :
      return "change CHV not possible";
    case 0x23 :
      return "CHV failure counter has blocked";
    case 0x24 :
      return "file has NVR access defined";
  }
  return (NULL);
}

/*
 * wait until the SCInterface module is not busy or an error has occurred
 * do an hourglass whilst waiting for completion
 */
static int
_check_interface_status(void)
{
  _kernel_swi_regs reg;
  int status;
  int error;

  _swix(Hourglass_On,0);
  do
  {
    _kernel_swi(SCInterface_Status, &reg, &reg);
    status = reg.r[0];
    error = reg.r[1];

    if (status==StatusError)
      break;

  } while (status==StatusBusy);
  _swix(Hourglass_Off,0);

  return (status==StatusError)?error:0;
}

/*
 * implement the quit command
 */
static cmd_ret_t
_quit (int argc, char **argv)
{
  return _QUIT;
}
/*
 * convert a BCD byte to an int
 */
static int
bcd_to_int(unsigned char byte)
{
  return (((byte&0xf0)>>4)*10)+(byte&0xf);
}

/* BCD_END is any character with a binary value > 9 */
/* bear this in mind for non ASCII character values */
/* this marks the current end of the shift register */
#define BCD_END '#'

/* this reverses The working register and converts BCD to ASCII */
static void
conv_bcd(unsigned char *string, unsigned int out_len)
{
        unsigned int i;
        unsigned int n = 0;
        unsigned char c_tmp;

        /* get length of register and convert to ASCII */
        /* we add '0' - so beware on non ASCII systems */
        while (string[n] != BCD_END)
                string[n++] += '0';

        /* reverse bytes */
        for (i = 0; i < n / 2; i++)
        {
                c_tmp = string[i];
                string[i] = string[n - i - 1];
                string[n - i - 1] = c_tmp;
        }

        for (i = 0; i < n; i++)
                string[out_len - i - 1] = string[n - i - 1];

        while (i < out_len)
                string[out_len - i++ - 1] = '0';

        /* NULL terminate at end */
        string[out_len] = '\0';
}

/* BCD multiply the shift register by 2 */
static void mult_2(unsigned char *bcd)
{
        unsigned char carry = 0;

        while (*bcd != BCD_END)
        {
                /* multiply first BCD digit by 2 and add any previous carry */
                if ((*bcd = *bcd * 2 + carry) > 9)
                {
                        /* overflow - so set carry */
                        *bcd -= 10;
                        carry = 1;
                }
                else
                        carry = 0;

                /* advance to next digit */
                bcd++;
        }

        /* any residual carry increases register length */
        if (carry)
        {
                *bcd++ = 1;
                *bcd = BCD_END;
        }
}

/* Increment BCD shift register by 1 */
static void
add_1(unsigned char *bcd)
{
        while (1)
        {
                /* if we get to the end it must be a carry */
                /* or the first time we've needed to add 1 */
                if (*bcd == BCD_END)
                {
                        *bcd++ = 1;
                        *bcd = BCD_END;
                        break;
                }
                else if ((*bcd += 1) < 10)
                        break; /* finished */
                else
                        *bcd++ -= 10; /* carry one to next digit */
        }
}

/*
 * convert a serial number buffer into an serial number string
 */
static void
btos(unsigned char *bits, unsigned int bytes, char *string,
                                        unsigned int out_len)
{
  unsigned int i, j;
  unsigned int found_1 = 0;
  unsigned char curr_byte;
  unsigned char mask;

  /* place END sentinel at start of string */
  string[0] = BCD_END;

  for (i = 0; i < bytes; i++)
  {
    /* take bytes, highest first */
    curr_byte = bits[i];

    for (j = 0, mask = 0x80; j < 8; j++, mask /= 2)
    {
      /* after the first binary 1, we BCD *2 each time */
      if (found_1)
        mult_2((unsigned char *)string);

      /* take bits, highest first and check */
      /* if the current bit is 1, add 1 to register */
      if (curr_byte & mask)
      {
        add_1((unsigned char *)string);
        found_1 = 1;
      }
    }
  }

  /* post-process string */
  conv_bcd((unsigned char *)string, out_len);
}
/*
 * implement the atr command
 */
static cmd_ret_t
_atr (int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  t_card_atr  *ATR;
  int i;
  int licensee_code;
  int num_manuf;
  int num_licencee;

  if (argc!=1)
    return _SYNTAX;

  reg.r[0] = 0;  /* flags */
  ERR_GOTO(err,_kernel_swi(SCInterface_GetATR,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }
  ATR = (t_card_atr*)reg.r[1];

  num_manuf = sizeof(atr_manuf)/sizeof(char*);
  num_licencee = sizeof(atr_licencee)/sizeof(char*);

  /*
   * display ATR
   */
  printf("ATR version          : %d\n",ATR->hist[3]);
  switch (ATR->hist[3])
  {
    case 1 :
      printf("Manufacturer code    : %d (%s)\n",ATR->hist[0],
      	(ATR->hist[0]<num_manuf)?atr_manuf[ATR->hist[0]]:"Unknown");
      printf("OS code              : %d\n",ATR->hist[1]);
      printf("Hardware code        : %d\n",ATR->hist[2]);
      printf("Date of issue        : %02d/%02d/%02d\n",
        bcd_to_int(ATR->hist[6]),bcd_to_int(ATR->hist[5]),
      	bcd_to_int(ATR->hist[4]));
      licensee_code = ATR->hist[7]<<16|ATR->hist[8]<<8|ATR->hist[9];
      printf("Licensee code        : %d (%s)\n",licensee_code,
        (licensee_code<num_licencee)?atr_licencee[licensee_code]:"Unknown");
      printf("Reserved bytes       : 0x%02x,0x%02x,0x%02x,0x%02x,0x%02x\n",
      	ATR->hist[10],ATR->hist[11],ATR->hist[12],ATR->hist[13],ATR->hist[14]);
      printf("Defaulted class byte : 0x%02x\n",0xA0);
      break;
    case 2 :
      printf("Manufacturer code    : %d (%s)\n",ATR->hist[0],
      	(ATR->hist[0]<num_manuf)?atr_manuf[ATR->hist[0]]:"Unknown");
      printf("OS code              : %d\n",ATR->hist[1]);
      printf("Hardware code        : %d\n",ATR->hist[2]);
      printf("Date of issue        : %02d/%02d/%02d\n",
      	       bcd_to_int(ATR->hist[6]),bcd_to_int(ATR->hist[5]),
      	       bcd_to_int(ATR->hist[4]));
      licensee_code = ATR->hist[7]<<16|ATR->hist[8]<<8|ATR->hist[9];
      printf("Licensee code        : %d (%s)\n",licensee_code,
        (licensee_code<num_licencee)?atr_licencee[licensee_code]:"Unknown");
      printf("Class byte           : %02x\n",ATR->hist[10]);
      printf("Reserved bytes       : 0x%02x,0x%02x,0x%02x,0x%02x\n",
  	       ATR->hist[11],ATR->hist[12],ATR->hist[13],ATR->hist[14]);
      printf("Class byte           : 0x%02x\n",ATR->hist[10]);
      break;
    case 3 :
      printf("Manufacturer code    : %d (%s)\n",ATR->hist[0],
      	(ATR->hist[0]<num_manuf)?atr_manuf[ATR->hist[0]]:"Unknown");
      printf("OS code              : %d\n",ATR->hist[1]);
      printf("Hardware code        : %d\n",ATR->hist[2]);
      printf("Date of issue        : %02d/%02d/%02d%02d\n",
      	       bcd_to_int(ATR->hist[7]),bcd_to_int(ATR->hist[6]),
      	       bcd_to_int(ATR->hist[4]),bcd_to_int(ATR->hist[5]));
      licensee_code = ATR->hist[8]<<16|ATR->hist[9]<<8|ATR->hist[10];
      printf("Licensee code        : %d (%s)\n",licensee_code,
        (licensee_code<num_licencee)?atr_licencee[licensee_code]:"Unknown");
      printf("Class byte           : %02x\n",ATR->hist[11]);
      printf("Reserved bytes       : 0x%02x,0x%02x,0x%02x\n",
  	       ATR->hist[12],ATR->hist[13],ATR->hist[14]);

      break;

    default:
      printf("Unknown format ATR\n");
      for (i=0; i<ATR->len; i++)
        printf("ATR byte %d : %02x\n",i,ATR->hist[i]);
  }

exit_gracefully:
  if (err)
    error_generate(err);

  return _CONT;
}

/*
 * implement the atr_raw command
 */
static cmd_ret_t
_atr_raw(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  t_card_atr  *ATR;
  int i;

  if (argc!=1)
    return _SYNTAX;

  reg.r[0] = 0;  /* flags */
  ERR_GOTO(err,_kernel_swi(SCInterface_GetATR,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }
  ATR = (t_card_atr*)reg.r[1];

  for (i=0; i<ATR->len; i++)
    printf("ATR byte %d : %02x\n",i,ATR->hist[i]);

exit_gracefully:
  if (err)
    error_generate(err);

  return _CONT;
}

/*
 * change chv1
 */
static cmd_ret_t
_changechv(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;

  if (argc!=2)
    return (_SYNTAX);

  printf("%s: change chv to %s\n",argv[0],argv[1]);

  /*
   * change chv
   */
  reg.r[0] = 0;
  reg.r[1] = (int)"/";			   /* filename */
  reg.r[2] = 1;				   /* access condition */
  reg.r[3] = (int)sc_code;
  reg.r[4] = strlen(sc_code);
  reg.r[5] = (int)argv[1];
  reg.r[6] = strlen(argv[1]);
  ERR_GOTO(err,_kernel_swi(SCInterface_ChangeCHV,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: chv changed\n",argv[0]);

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}
/*
 * enable/disable chv verification
 */
static cmd_ret_t
_chv(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;
  int enable;

  if (argc!=2)
    return (_SYNTAX);

  if (strcmp(argv[1],"enable")==0)
    enable = 1;
  else if (strcmp(argv[1],"disable")==0)
    enable = 0;
  else
    return (_SYNTAX);

  printf("%s: %s chv code verification\n",argv[0],argv[1]);

  /*
   * enable/disable chv
   */
  reg.r[0] = (enable?1<<1:0);              /* flags */
  reg.r[1] = (int)"/";			   /* filename */
  reg.r[2] = 1;				   /* access condition */
  reg.r[3] = (int)sc_code;
  reg.r[4] = strlen(sc_code);
  ERR_GOTO(err,_kernel_swi(SCInterface_EnableCHV,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: chv changed\n",argv[0]);

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * enable/disable chv verification
 */
static cmd_ret_t
_unblock(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;

  if (argc!=3)
    return (_SYNTAX);

  printf("%s: card using code %s and set chv1 to %s\n",argv[0],argv[1],argv[2]);

  /*
   * unblock chv
   */
  reg.r[0] = 0;                            /* flags */
  reg.r[1] = (int)"/";			   /* filename */
  reg.r[2] = 1;				   /* access condition */
  reg.r[3] = (int)argv[1];
  reg.r[4] = strlen(argv[1]);
  reg.r[5] = (int)argv[2];
  reg.r[6] = strlen(argv[2]);

  ERR_GOTO(err,_kernel_swi(SCInterface_UnBlockCHV,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: card unblocked\n",argv[0]);

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * create a directory on the smart card
 */
static cmd_ret_t
_createdir(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;

  if (argc!=4)
    return (_SYNTAX);

  printf("%s: creating directory %s size 0x%x access 0x%x ",argv[0],
          argv[1],atoi(argv[2]),atoi(argv[3]));

  /*
   * do a create dir
   */
  reg.r[0] = 1<<1;              /* flags */
  reg.r[1] = (int)argv[1];	/* filename */
  reg.r[2] = atoi(argv[2]);	/* size */
  reg.r[3] = atoi(argv[3]);	/* access condition */
  ERR_GOTO(err,_kernel_swi(SCInterface_Create,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: directory created\n",argv[0]);

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * create a file on the smart card
 */
static cmd_ret_t
_createfile(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;

  if (argc!=4)
    return (_SYNTAX);

  printf("%s: creating file %s size 0x%x access 0x%x ",argv[0],
          argv[1],atoi(argv[2]),atoi(argv[3]));

  /*
   * do a create dir
   */
  reg.r[0] = 0;                 /* flags */
  reg.r[1] = (int)argv[1];	/* filename */
  reg.r[2] = atoi(argv[2]);	/* size */
  reg.r[3] = atoi(argv[3]);	/* access condition */
  ERR_GOTO(err,_kernel_swi(SCInterface_Create,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: file created\n",argv[0]);

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * wait for a key to be pressed
 */
static cmd_ret_t
_wait(int argc, char **argv)
{
  _kernel_swi_regs reg;
  int iCarry;

  printf("press a key...\n");
  reg.r[0] = 145;
  reg.r[1] = 0;
  do
  {
    _kernel_swi_c(OS_Byte, &reg, &reg, &iCarry);
  } while (iCarry!=0);

  return (_CONT);
}

/*
 * display given text on the screen
 */
static cmd_ret_t
_display(int argc, char **argv)
{
  int i;

  if (argc<=1)
    return (_SYNTAX);

  for (i=1; i<argc; i++)
    printf("%s%s",i==1?"":" ",argv[i]);

  printf(".\n");

  return (_CONT);
}

/*
 * function to record the supplied password
 *
 *   argv[1] = code
 */
static cmd_ret_t
_code(int argc, char **argv)
{
  if (argc!=2)
    return (_SYNTAX);

  strncpy(sc_code,argv[1],sizeof(sc_code));

  return (_CONT);
}

/*
 * function to perform a write of a file to the smart card
 *
 *   argv[1] = riscos filename
 *   argv[2] = smartcard filename
 */
static cmd_ret_t
_write(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int handle;
  int len;
  char *buffer = 0;
  int status;

  if (argc!=3)
    return (_SYNTAX);

  printf("%s: file %s to smart card file %s ",argv[0],argv[1],argv[2]);

  /*
   * open file
   */
  reg.r[0] = 0x4f;
  reg.r[1] = (int)argv[1];
  reg.r[2] = 0;
  ERR_GOTO(err,_kernel_swi(OS_Find,&reg,&reg));
  handle = reg.r[0];

  if (!handle)
    ERR_GOTO(err,error_construct(ERROR_NOFILE,0));

  /*
   * find size of file
   */
  reg.r[0] = 2;
  reg.r[1] = handle;
  ERR_GOTO(err,_kernel_swi(OS_Args, &reg, &reg));
  len = reg.r[2];

  if (!len)
    ERR_GOTO(err,error_construct(ERROR_ZEROSIZE,argv[1]));

  if ((buffer = malloc(len))==NULL)
    ERR_GOTO(err,error_construct(ERROR_MEMORY,0));

  /*
   * read file with given handle
   */
  reg.r[0] = 3;
  reg.r[1] = handle;
  reg.r[2] = (int)buffer;
  reg.r[3] = len;
  reg.r[4] = 0;
  ERR_GOTO(err,_kernel_swi(OS_GBPB,&reg,&reg));

  /*
   * do the write to the smart card
   */
  reg.r[0] = 0;
  reg.r[1] = (int)argv[2];
  reg.r[2] = 0;
  reg.r[3] = (int)buffer;
  reg.r[4] = len;
  reg.r[5] = (int)sc_code;
  reg.r[6] = strlen(sc_code);
  ERR_GOTO(err,_kernel_swi(SCInterface_Write,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: complete %d bytes written\n",argv[0],len);

exit_gracefully:
  if (handle)
  {
    reg.r[0] = 0;
    reg.r[1] = handle;
    _kernel_swi(OS_Find,&reg,&reg);
  }
  if (buffer)
    free(buffer);

  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * function to read a smart card file into a file
 *
 *   argv[1] = riscos filename
 *   argv[2] = smartcard filename
 */
static cmd_ret_t
_read(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  char data[8];
  int  status;
  char *buffer = 0;
  int  len;
  int  handle;

  if (argc!=3)
    return (_SYNTAX);

  printf("%s: smart card file %s to file %s ",argv[0],argv[2],argv[1]);

  /*
   * find out the size of the file to read
   */
  reg.r[0] = 0;
  reg.r[1] = (int)argv[2];
  reg.r[2] = (int)data;
  reg.r[3] = sizeof(data);
  ERR_GOTO(err,_kernel_swi(SCInterface_FileInfo,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }

  len = (data[2]<<8)|data[3]; /* calculate size from fileinfo */

  if ((buffer = malloc(len))==NULL)
    ERR_GOTO(err,error_construct(ERROR_MEMORY,0));

  /*
   * do the read from the smart card
   */
  reg.r[0] = 0;
  reg.r[1] = (int)argv[2];
  reg.r[2] = 0;
  reg.r[3] = (int)buffer;
  reg.r[4] = len;
  reg.r[5] = (int)sc_code;
  reg.r[6] = strlen(sc_code);
  ERR_GOTO(err,_kernel_swi(SCInterface_Read,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }
  else
    printf("\n");


  /*
   * open file
   */
  reg.r[0] = 0x8f;
  reg.r[1] = (int)argv[1];
  reg.r[2] = 0;
  ERR_GOTO(err,_kernel_swi(OS_Find,&reg,&reg));
  handle = reg.r[0];

  /*
   * write to file with given handle
   */
  reg.r[0] = 1;
  reg.r[1] = handle;
  reg.r[2] = (int)buffer;
  reg.r[3] = len;
  reg.r[4] = 0;
  ERR_GOTO(err,_kernel_swi(OS_GBPB,&reg,&reg));
    printf("%s: complete %d bytes read\n",argv[0],len);

exit_gracefully:
  if (handle)
  {
    reg.r[0] = 0;
    reg.r[1] = handle;
    _kernel_swi(OS_Find,&reg,&reg);
  }

  if (buffer)
    free(buffer);

  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * function to read a smart card file and display it on screen
 *
 *   argv[1] = smartcard filename
 */
static cmd_ret_t
_dump(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  char data[8];
  int  status;
  char *buffer = 0;
  int  len;
  char line[81];
  int  i, j, dp, hp;
  char *bp=0;

  if (argc!=2)
    return (_SYNTAX);

  printf("%s: smart card file %s",argv[0],argv[1]);

  /*
   * find out the size of the file to read
   */
  reg.r[0] = 0;
  reg.r[1] = (int)argv[1];
  reg.r[2] = (int)data;
  reg.r[3] = sizeof(data);
  ERR_GOTO(err,_kernel_swi(SCInterface_FileInfo,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }

  len = (data[2]<<8)|data[3]; /* calculate size from fileinfo */

  printf("\nFile size %d bytes\n",len);

  if ((buffer = malloc(len))==NULL)
    ERR_GOTO(err,error_construct(ERROR_MEMORY,0));

  /*
   * do the read from the smart card
   */
  reg.r[0] = 0;
  reg.r[1] = (int)argv[1];
  reg.r[2] = 0;
  reg.r[3] = (int)buffer;
  reg.r[4] = len;
  reg.r[5] = (int)sc_code;
  reg.r[6] = strlen(sc_code);
  ERR_GOTO(err,_kernel_swi(SCInterface_Read,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }
  else
    printf("\n");


  /*
   * display on screen
   */
  bp = buffer;  /* point to start of buffer */
  while (len > 0)
  {
    hp = 0;
    memset(line, ' ', 80);
    for (hp = j = 0, dp = 52; j < 16 && len > 0; j++, len--)
    {
      i = *bp / 16;
      line[hp++] = (i < 10) ? '0' + i : 'A' + i - 10;
      i = *bp % 16;
      line[hp++] = (i < 10) ? '0' + i : 'A' + i - 10;
      line[hp++] = ' ';
      line[dp++] = (*bp >= ' ' && *bp <= '~') ? *bp : '.';
      bp++;
    }
    line[dp++] = '\n';
    line[dp] = '\0';
    printf(line);
  }

exit_gracefully:
  if (buffer)
    free(buffer);

  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * obtain file info
 *
 *   argv[1] = filename
 */
static cmd_ret_t
_stat(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  char data[22];
  int  status;
  int i;

  if (argc!=2)
    return (_SYNTAX);

  /*
   * stat the file
   */
  reg.r[0] = 0;
  reg.r[1] = (int)argv[1];
  reg.r[2] = (int)data;
  reg.r[3] = sizeof(data);
  ERR_GOTO(err,_kernel_swi(SCInterface_FileInfo,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }

  printf("  File ID             : %02x%02x\n",data[4],data[5]);
  switch (data[6])
  {
    case 0x38 :
      printf("  Type of file        : %02x (DF)\n",data[6]);
      printf("  Left free space     : %d bytes\n",data[2]<<8|data[3]);
      printf("  Access conditions\n");
      printf("    Dir               : %s\n",ac[(data[8]>>4)&0xf]);
      printf("    Delete file       : %s\n",ac[(data[9]>>4)&0xf]);
      printf("    Create file       : %s\n",ac[(data[9]>>0)&0xf]);
      printf("    Rehabilitate      : %s\n",ac[(data[10]>>4)&0xf]);
      printf("    Invalidate        : %s\n",ac[(data[10]>>0)&0xf]);
      break;
    default :
      printf("  Type of file        : %02x (EF)\n",data[6]);
      printf("  File size           : %d bytes\n",data[2]<<8|data[3]);
      printf("  Access conditions\n");
      printf("    Read & Seek       : %s\n",ac[(data[8]>>4)&0xf]);
      printf("    Update / Decrease : %s\n",ac[(data[8]>>0)&0xf]);
      printf("    Increase          : %s\n",ac[(data[9]>>4)&0xf]);
      printf("    Create record     : %s\n",ac[(data[9]>>0)&0xf]);
      printf("    Rehabilitate      : %s\n",ac[(data[10]>>4)&0xf]);
      printf("    Invalidate        : %s\n",ac[(data[10]>>0)&0xf]);
      break;
  }
  printf("  File status         : %s\n",file_status[data[11]]);
  switch (data[12])
  {
    case 7 : case 9 :
      printf("  CHV status          : %02x\n",data[18]);
      printf("  CHV unblock status  : %02x\n",data[19]);
      /* drop through to */
    case 5 :
      printf("  Number of DFs       : %02x\n",data[14]);
      printf("  Number of EFs       : %02x\n",data[15]);
      break;
    case 1 :
      /* ignore */
      break;
    default :
      printf("  Following data %d\n",data[12]);
      for (i=13; i<13+data[12]; i++)
        printf("    Further data      : %02x\n",data[i]);
  }
  printf("\n");

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}
/*
 * function to read a smart card serial number file and display it on screen
 *
 *   argv[1] = serial number filename
 */
static cmd_ret_t
_serial(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  char data[8];
  int  status;
  unsigned char buffer[8];
  char out_buff[8];
  int  len;

  if (argc!=2)
    return (_SYNTAX);

  /*
   * find out the size of the file to read
   */
  reg.r[0] = 0;
  reg.r[1] = (int)argv[1];
  reg.r[2] = (int)data;
  reg.r[3] = sizeof(data);
  ERR_GOTO(err,_kernel_swi(SCInterface_FileInfo,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }

  len = (data[2]<<8)|data[3]; /* calculate size from fileinfo */
  if (len>sizeof(buffer))
    len=sizeof(buffer);

  /*
   * do the read from the smart card
   */
  reg.r[0] = 0;
  reg.r[1] = (int)argv[1];
  reg.r[2] = 0;
  reg.r[3] = (int)buffer;
  reg.r[4] = len;
  reg.r[5] = NULL;
  reg.r[6] = 0;
  ERR_GOTO(err,_kernel_swi(SCInterface_Read,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }
  else
    printf("\n");

  btos(buffer, sizeof(buffer), out_buff, sizeof(out_buff));

  printf("%s: serial number : %s\n",argv[0],out_buff);


exit_gracefully:

  if (err)
    error_generate(err);

  return (_CONT);
}
/*
 * implement the help command
 */
static cmd_ret_t
_help (int argc, char **argv)
{
  const cmd_t *cmd;

  if (argc==1)
    printf("   %s (Version %s)\n\n",APPNAME,VERSION);

  for (cmd = &cmd_tbl[0]; cmd->call; cmd++)
  {
    if (argc == 1 || strcmp(argv[1], cmd->name) == 0)
    {
      printf("   %s: %s\n", cmd->name, cmd->help);
      if (argc != 1) printf("   syntax : %s\n", cmd->syntax);
    }
  }
  return _CONT;
}

/*
 * parse the command line to extract arguments in form argc and argv
 */
static int
_getargs(char *line, char **argv)
{
  int  argc = 0;
  char *cp;

  cp = line;
  while (*cp != '\0')
  {
    while (*cp == ' ')
      cp++;
    if (*cp == '\0')
      break;

    argv[argc++] = cp;
    while (*cp != '\0' && *cp != ' ')
      cp++;
    if (*cp == 0)
      break;
    *cp++ = '\0';
  }
  *cp++ = '\0';

  return (argc);
}

/*
 * display the command prompt and read a command line from console
 */
static void
_getline(char *line, int size)
{
  _kernel_swi_regs reg;
  printf("sc>");
  reg.r[0] = (int)line | 1U<<31;
  reg.r[1] = size;
  reg.r[2] = 0;
  reg.r[3] = 255;
  reg.r[4] = 0;
  _kernel_swi(OS_ReadLine,&reg,&reg);
  line[reg.r[1]] = 0; /* terminate */
}
/*
 * read a line of text in from the specified file and remove any newlines
 */
cmd_ret_t
read_line(FILE *fptr, char *buffer, int size)
{
  int i;

  if (fgets(buffer, size, fptr)==NULL)
    return (_QUIT);

  i=strlen(buffer);
  while (i>0 && buffer[i]!='\n') i--;

  if (i>0)
    buffer[i] = 0;

  return (_CONT);
}
/*
 * compare two strings caselessly
 */
int
caseless_strcmp(char *a, char *b)
{
  int d;

  while (*a || *b)
  {
    d = tolower( *(a++) ) - tolower( *(b++) );
    if (d) return d;
  }
  return 0;
}

/*
 */
int main(int argc, char *argv[])
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;
  char	command_line[80];
  cmd_ret_t ret = _CONT;
  FILE *fptr;
  char cmd_line[256];
  int	margc;
  char	*margv[10];
  const cmd_t	*cmd;

  if (argc==2) /* do we have a script to run */
  {
    if ((fptr = fopen(argv[1], "r")) == NULL)
    {
      ERR_GOTO(err,error_construct(ERROR_NOFILE,argv[1]));
    }
    /*
     * read file and parse commands
     */
    while (ret != _QUIT)
    {
      do
      {
        if (read_line(fptr,cmd_line, sizeof(cmd_line))==_QUIT)
          goto exit_gracefully;
      } while (cmd_line[0] == '|' || strlen(cmd_line)==1);

      margc = _getargs(cmd_line, margv);

      for (cmd = &cmd_tbl[0]; cmd->call; cmd++)
      {
        if (caseless_strcmp(margv[0], cmd->name) != 0)
    	  continue;
        else if ((ret=(*(cmd->call))(margc, margv)) == _QUIT)
  	  break;
        else if (ret == _SYNTAX)
        {
  	  error_generate(error_construct(ERROR_SYNTAX,cmd->syntax));
  	  break;
        }
        else if (ret == _CONT)
          break;
      }
      if (cmd->call == 0)
        error_generate(error_construct(ERROR_UNKNOWN,margv[0]));
    }
    fclose (fptr);
  }
  else /* or go interactive */
  {
    printf("Entering SCProgram interactive mode, try typing help\n");
    while (ret != _QUIT)
    {
      _getline(command_line, sizeof(command_line));
      if (*command_line)
      {
        argc = _getargs(command_line, argv);

        for (cmd = &cmd_tbl[0]; cmd->call; cmd++)
        {
          if (caseless_strcmp(argv[0], cmd->name) != 0)
    	  continue;
          else if ((ret=(*(cmd->call))(argc, argv)) == _QUIT)
    	  break;
          else if (ret == _SYNTAX)
          {
    	  printf("   syntax: %s\n", cmd->syntax);
    	  break;
          }
          else if (ret == _CONT)
            break;
        }
        if (cmd->call == 0)
        {
          if (*argv[0]=='*')
          {
            reg.r[0] = (int)command_line;
            _kernel_swi(OS_CLI,&reg,&reg);
          }
          else
            printf("   unknown command - try 'help'\n");
        }
      }
    }
  }

exit_gracefully:
  /* _wait(0,NULL); */
  if (err)
    error_generate(err);
  return (0);
}
