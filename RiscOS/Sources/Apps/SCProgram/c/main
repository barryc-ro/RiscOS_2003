/************************************************************************/
/* 	        Copyright 1996 Acorn Network Computers		        */
/*									*/
/*  This material is the confidential trade secret and proprietary	*/
/*  information of Acorn Network Computers. It may not be reproduced,   */
/*  used sold, or transferred to any third party without the prior      */
/*  written consent of Acorn Network Computers. All rights reserved.	*/
/* 									*/
/************************************************************************/

/*
 *
 * Modification History
 *---------------------
 *
 * 02-Sep-1996 Added error messages in textual form
 * 02-Sep-1996 Added chv enable/disable
 * 08-Nov-1996 Added wrong instruction class error message
 * 10-Jan-1997 Added interactive mode
 * 13-Jan-1997 Display file size during dump
 * 19-Feb-1997 Added unblock command, changed chv enable|disable format
 * 	       commented out the file create commands.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"
#include "error.h"
#include "constants.h"
#include "console.h"
#include "scinter.h"

#define APPNAME "SCProgram"
#define VERSION "2.02"

/*
 * script processing table
 */
static cmd_ret_t _write     (int, char**);
static cmd_ret_t _read      (int, char**);
static cmd_ret_t _code      (int, char**);
static cmd_ret_t _display   (int, char**);
static cmd_ret_t _wait      (int, char**);
static cmd_ret_t _createdir (int, char**);
static cmd_ret_t _createfile(int, char**);
static cmd_ret_t _chv       (int, char**);
static cmd_ret_t _unblock   (int, char**);
static cmd_ret_t _dump      (int, char**);
static cmd_ret_t _help	    (int, char**);
static cmd_ret_t _quit      (int, char**);

static const cmd_t cmd_tbl[] = {
 _code,      "code",      "code <code number>",
 	     		  "submit the given code for chv1 verification",
 _dump,	     "dump",      "dump <scfilename>",
                          "dump card file to screen",
 _write,     "write",     "write <filename> <scfilename>",
 	     		  "write disk file to smartcard",
 _read,      "read",      "read <filename> <scfilename>",
 	     		  "read scartcard file to disk file",
 _display,   "display",   "display <text to be displayed>",
 	     		  "display the supplied text on screen",
 _wait,	     "wait",      "wait",
 	     		  "wait for a key to be pressed",
/*
 _createdir, "createdir", "createdir <scfilename> <size> <access>",
                          "create directory on smartcard",
 _createfile,"createfile","createfile <scfilename> <size> <access>",
                          "create file on smartcard",
*/
 _chv,       "chv",       "chv <enable|disable>",
                          "change chv1 state",
 _unblock,   "unblock",	  "unblock <unblock code> <new chv1 code>",
 	     		  "unblock a blocked card",
 _help,	     "help",      "help [command]",
                          "display help on selected keyword",
 _quit,	     "quit",      "quit","quit application",
 0,0,0,0
};

char sc_code[9] = "";

/*
 * display an error message given an SCInterface error number
 */
char *
get_error_msg(int errnum)
{
  switch (errnum)
  {
    case 0x01 :
      return "smart card not inserted";
    case 0x02 :
      return "file path format error";
    case 0x03 :
      return "too many nexted subdirectories";
    case 0x04 :
      return "do not understand inserted card";
    case 0x05 :
      return "still processing previous command";
    case 0x06 :
      return "smart card reserved filename specified";
    case 0x07 :
      return "command not implemented on this card";
    case 0x10 :
      return "requested file not found";
    case 0x11 :
      return "error returned from SCTransport";
    case 0x12 :
      return "not enough space to fit requested data";
    case 0x13 :
      return "file already exists";
    case 0x14 :
      return "storage problem";
    case 0x15 :
      return "no file selected";
    case 0x16 :
      return "outside valid area";
    case 0x17 :
      return "file type is inconsistant with command";
    case 0x18 :
      return "unknown response code returned";
    case 0x19 :
      return "incorrect parameter values p1,p2";
    case 0x1a :
      return "incorrect parameter value p3";
    case 0x1b :
      return "technical problem with no diagnostics given";
    case 0x1c :
      return "wrong instruction class byte";
    case 0x20 :
      return "no access code defined";
    case 0x21 :
      return "failed access code verification";
    case 0x22 :
      return "change CHV not possible";
    case 0x23 :
      return "CHV failure counter has blocked";
    case 0x24 :
      return "file has NVR access defined";
  }
  return (NULL);
}

/*
 * wait until the SCInterface module is not busy or an error has occurred
 * do a twiddler whilst waiting for completion
 */
static int
_check_interface_status(void)
{
  _kernel_swi_regs reg;
  char twiddle[4]={124,47,45,92};
  int i=0;
  int status;
  int error;

  _kernel_swi(OS_RemoveCursors,&reg,&reg);
  do
  {
    reg.r[0] = (int)twiddle[i++];
    if (i>=sizeof(twiddle)) i=0;
    _kernel_swi(OS_WriteC,&reg,&reg);

    _kernel_swi(SCInterface_Status, &reg, &reg);
    status = reg.r[0];
    error = reg.r[1];

    reg.r[0] = (int)'\b';
    _kernel_swi(OS_WriteC,&reg,&reg);

    if (status==StatusError)
      break;

  } while (status==StatusBusy);

  reg.r[0] = (int)' ';
  _kernel_swi(OS_WriteC,&reg,&reg);
  reg.r[0] = (int)'\b';
  _kernel_swi(OS_WriteC,&reg,&reg);
  _kernel_swi(OS_RestoreCursors,&reg,&reg);

  return (status==StatusError)?error:0;
}

/*
 * implement the quit command
 */
static cmd_ret_t
_quit (int argc, char **argv)
{
  return _QUIT;
}

/*
 * enable/disable chv verification
 */
static cmd_ret_t
_chv(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;
  int enable;

  if (argc!=2)
    return (_SYNTAX);

  if (strcmp(argv[1],"enable")==0)
    enable = 1;
  else if (strcmp(argv[1],"disable")==0)
    enable = 0;
  else
    return (_SYNTAX);

  printf("%s: %s chv code verification\n",argv[0],argv[1]);

  /*
   * enable/disable chv
   */
  reg.r[0] = 1<<0 | (enable?1<<1:0);       /* flags */
  reg.r[1] = (int)"/";			   /* filename */
  reg.r[2] = 1;				   /* access condition */
  reg.r[3] = (int)sc_code;
  reg.r[4] = strlen(sc_code);
  ERR_GOTO(err,_kernel_swi(SCInterface_EnableCHV,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: chv changed\n",argv[0]);

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * enable/disable chv verification
 */
static cmd_ret_t
_unblock(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;

  if (argc!=3)
    return (_SYNTAX);

  printf("%s: card using code %s and set chv1 to %s\n",argv[0],argv[1],argv[2]);

  /*
   * unblock chv
   */
  reg.r[0] = 0;                            /* flags */
  reg.r[1] = (int)"/";			   /* filename */
  reg.r[2] = 1;				   /* access condition */
  reg.r[3] = (int)argv[1];
  reg.r[4] = strlen(argv[1]);
  reg.r[5] = (int)argv[2];
  reg.r[6] = strlen(argv[2]);

  ERR_GOTO(err,_kernel_swi(SCInterface_UnBlockCHV,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: card unblocked\n",argv[0]);

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * create a directory on the smart card
 */
static cmd_ret_t
_createdir(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;

  if (argc!=4)
    return (_SYNTAX);

  printf("%s: creating directory %s size 0x%x access 0x%x ",argv[0],
          argv[1],atoi(argv[2]),atoi(argv[3]));

  /*
   * do a create dir
   */
  reg.r[0] = 1<<0 | 1<<1;       /* flags */
  reg.r[1] = (int)argv[1];	/* filename */
  reg.r[2] = atoi(argv[2]);	/* size */
  reg.r[3] = atoi(argv[3]);	/* access condition */
  ERR_GOTO(err,_kernel_swi(SCInterface_Create,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: directory created\n",argv[0]);

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * create a file on the smart card
 */
static cmd_ret_t
_createfile(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;

  if (argc!=4)
    return (_SYNTAX);

  printf("%s: creating file %s size 0x%x access 0x%x ",argv[0],
          argv[1],atoi(argv[2]),atoi(argv[3]));

  /*
   * do a create dir
   */
  reg.r[0] = 1<<0;              /* flags */
  reg.r[1] = (int)argv[1];	/* filename */
  reg.r[2] = atoi(argv[2]);	/* size */
  reg.r[3] = atoi(argv[3]);	/* access condition */
  ERR_GOTO(err,_kernel_swi(SCInterface_Create,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: file created\n",argv[0]);

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * wait for a key to be pressed
 */
static cmd_ret_t
_wait(int argc, char **argv)
{
  _kernel_swi_regs reg;
  int iCarry;

  printf("press a key...\n");
  reg.r[0] = 145;
  reg.r[1] = 0;
  do
  {
    _kernel_swi_c(OS_Byte, &reg, &reg, &iCarry);
  } while (iCarry!=0);

  return (_CONT);
}

/*
 * display given text on the screen
 */
static cmd_ret_t
_display(int argc, char **argv)
{
  int i;

  if (argc<=1)
    return (_SYNTAX);

  for (i=1; i<argc; i++)
    printf("%s%s",i==1?"":" ",argv[i]);

  printf(".\n");

  return (_CONT);
}

/*
 * function to record the supplied password
 *
 *   argv[1] = code
 */
static cmd_ret_t
_code(int argc, char **argv)
{
  if (argc!=2)
    return (_SYNTAX);

  strncpy(sc_code,argv[1],sizeof(sc_code));

  return (_CONT);
}

/*
 * function to perform a write of a file to the smart card
 *
 *   argv[1] = riscos filename
 *   argv[2] = smartcard filename
 */
static cmd_ret_t
_write(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int handle;
  int len;
  char *buffer = 0;
  int status;

  if (argc!=3)
    return (_SYNTAX);

  printf("%s: file %s to smart card file %s ",argv[0],argv[1],argv[2]);

  /*
   * open file
   */
  reg.r[0] = 0x4f;
  reg.r[1] = (int)argv[1];
  reg.r[2] = 0;
  ERR_GOTO(err,_kernel_swi(OS_Find,&reg,&reg));
  handle = reg.r[0];

  if (!handle)
    ERR_GOTO(err,error_construct(ERROR_NOFILE,0));

  /*
   * find size of file
   */
  reg.r[0] = 2;
  reg.r[1] = handle;
  ERR_GOTO(err,_kernel_swi(OS_Args, &reg, &reg));
  len = reg.r[2];

  if (!len)
    ERR_GOTO(err,error_construct(ERROR_ZEROSIZE,argv[1]));

  if ((buffer = malloc(len))==NULL)
    ERR_GOTO(err,error_construct(ERROR_MEMORY,0));

  /*
   * read file with given handle
   */
  reg.r[0] = 3;
  reg.r[1] = handle;
  reg.r[2] = (int)buffer;
  reg.r[3] = len;
  reg.r[4] = 0;
  ERR_GOTO(err,_kernel_swi(OS_GBPB,&reg,&reg));

  /*
   * do the write to the smart card
   */
  reg.r[0] = 1<<0;
  reg.r[1] = (int)argv[2];
  reg.r[2] = 0;
  reg.r[3] = (int)buffer;
  reg.r[4] = len;
  reg.r[5] = (int)sc_code;
  reg.r[6] = strlen(sc_code);
  ERR_GOTO(err,_kernel_swi(SCInterface_Write,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
  else
    printf("\n%s: complete %d bytes written\n",argv[0],len);

exit_gracefully:
  if (handle)
  {
    reg.r[0] = 0;
    reg.r[1] = handle;
    _kernel_swi(OS_Find,&reg,&reg);
  }
  if (buffer)
    free(buffer);

  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * function to read a smart card file into a file
 *
 *   argv[1] = riscos filename
 *   argv[2] = smartcard filename
 */
static cmd_ret_t
_read(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  char data[8];
  int  status;
  char *buffer = 0;
  int  len;
  int  handle;

  if (argc!=3)
    return (_SYNTAX);

  printf("%s: smart card file %s to file %s ",argv[0],argv[2],argv[1]);

  /*
   * find out the size of the file to read
   */
  reg.r[0] = 1<<0;
  reg.r[1] = (int)argv[2];
  reg.r[2] = (int)data;
  reg.r[3] = sizeof(data);
  ERR_GOTO(err,_kernel_swi(SCInterface_FileInfo,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }

  len = (data[2]<<8)|data[3]; /* calculate size from fileinfo */

  if ((buffer = malloc(len))==NULL)
    ERR_GOTO(err,error_construct(ERROR_MEMORY,0));

  /*
   * do the read from the smart card
   */
  reg.r[0] = 1<<0;
  reg.r[1] = (int)argv[2];
  reg.r[2] = 0;
  reg.r[3] = (int)buffer;
  reg.r[4] = len;
  reg.r[5] = (int)sc_code;
  reg.r[6] = strlen(sc_code);
  ERR_GOTO(err,_kernel_swi(SCInterface_Read,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }
  else
    printf("\n");


  /*
   * open file
   */
  reg.r[0] = 0x8f;
  reg.r[1] = (int)argv[1];
  reg.r[2] = 0;
  ERR_GOTO(err,_kernel_swi(OS_Find,&reg,&reg));
  handle = reg.r[0];

  /*
   * write to file with given handle
   */
  reg.r[0] = 1;
  reg.r[1] = handle;
  reg.r[2] = (int)buffer;
  reg.r[3] = len;
  reg.r[4] = 0;
  ERR_GOTO(err,_kernel_swi(OS_GBPB,&reg,&reg));
    printf("%s: complete %d bytes read\n",argv[0],len);

exit_gracefully:
  if (handle)
  {
    reg.r[0] = 0;
    reg.r[1] = handle;
    _kernel_swi(OS_Find,&reg,&reg);
  }

  if (buffer)
    free(buffer);

  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * function to read a smart card file and display it on screen
 *
 *   argv[1] = smartcard filename
 */
static cmd_ret_t
_dump(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  char data[8];
  int  status;
  char *buffer = 0;
  int  len;
  int  handle;
  char line[81];
  int  i, j, dp, hp;
  char *bp=0;

  if (argc!=2)
    return (_SYNTAX);

  printf("%s: smart card file %s",argv[0],argv[1]);

  /*
   * find out the size of the file to read
   */
  reg.r[0] = 1<<0;
  reg.r[1] = (int)argv[1];
  reg.r[2] = (int)data;
  reg.r[3] = sizeof(data);
  ERR_GOTO(err,_kernel_swi(SCInterface_FileInfo,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }

  len = (data[2]<<8)|data[3]; /* calculate size from fileinfo */

  printf("\nFile size %d bytes\n",len);

  if ((buffer = malloc(len))==NULL)
    ERR_GOTO(err,error_construct(ERROR_MEMORY,0));

  /*
   * do the read from the smart card
   */
  reg.r[0] = 1<<0;
  reg.r[1] = (int)argv[1];
  reg.r[2] = 0;
  reg.r[3] = (int)buffer;
  reg.r[4] = len;
  reg.r[5] = (int)sc_code;
  reg.r[6] = strlen(sc_code);
  ERR_GOTO(err,_kernel_swi(SCInterface_Read,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(reg.r[0]));
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\n%s: error %s\n",argv[0],get_error_msg(status));
    goto exit_gracefully;
  }
  else
    printf("\n");


  /*
   * display on screen
   */
  bp = buffer;  /* point to start of buffer */
  while (len > 0)
  {
    hp = 0;
    memset(line, ' ', 80);
    for (hp = j = 0, dp = 52; j < 16 && len > 0; j++, len--)
    {
      i = *bp / 16;
      line[hp++] = (i < 10) ? '0' + i : 'A' + i - 10;
      i = *bp % 16;
      line[hp++] = (i < 10) ? '0' + i : 'A' + i - 10;
      line[hp++] = ' ';
      line[dp++] = (*bp >= ' ' && *bp <= '~') ? *bp : '.';
      bp++;
    }
    line[dp++] = '\n';
    line[dp] = '\0';
    printf(line);
  }

exit_gracefully:
  if (handle)
  {
    reg.r[0] = 0;
    reg.r[1] = handle;
    _kernel_swi(OS_Find,&reg,&reg);
  }

  if (buffer)
    free(buffer);

  if (err)
    error_generate(err);

  return (_CONT);
}
/*
 * implement the help command
 */
static cmd_ret_t
_help (int argc, char **argv)
{
  const cmd_t *cmd;

  if (argc==1)
    printf("   %s (Version %s)\n\n",APPNAME,VERSION);

  for (cmd = &cmd_tbl[0]; cmd->call; cmd++)
  {
    if (argc == 1 || strcmp(argv[1], cmd->name) == 0)
    {
      printf("   %s: %s\n", cmd->name, cmd->help);
      if (argc != 1) printf("   syntax : %s\n", cmd->syntax);
    }
  }
  return _CONT;
}

/*
 * parse the command line to extract arguments in form argc and argv
 */
static int
_getargs(char *line, char **argv)
{
  int  argc = 0;
  char *cp;
  char ch;

  cp = line;
  while (*cp!=0)
  {
    ch = *cp;
    *cp++ = tolower(ch);
  }

  cp = line;
  while (*cp != '\0')
  {
    while (*cp == ' ')
      cp++;
    if (*cp == '\0')
      break;

    argv[argc++] = cp;
    while (*cp != '\0' && *cp != ' ')
      cp++;
    if (*cp == 0)
      break;
    *cp++ = '\0';
  }
  *cp++ = '\0';

  return (argc);
}

/*
 * display the command prompt and read a command line from console
 */
static void
_getline(char *line, int size)
{
  char ch = 0;
  int  i  = 0;

  printf("sc>");
  while (ch != '\r' && i < size)
  {
    ch = (char)console_get_key(0);
    if (ch == '\b' && i > 0)
    {
      console_put_char('\b');
      console_put_char(' ');
      console_put_char('\b');
      i--;
    }
    else
    {
      if (ch != '\r' && ch !='\b' && ch)
      {
        console_put_char(ch);
        line[i++] = ch;
      }
    }
  }
  line[i] = 0;
  printf("\n");
}
/*
 * read a line of text in from the specified file and remove any newlines
 */
cmd_ret_t
read_line(FILE *fptr, char *buffer, int size)
{
  int i;

  if (fgets(buffer, size, fptr)==NULL)
    return (_QUIT);

  i=strlen(buffer);
  while (i>0 && buffer[i]!='\n') i--;

  if (i>0)
    buffer[i] = 0;

  return (_CONT);
}

/*
 */
int main(int argc, char *argv[])
{
  _kernel_oserror *err = NULL;
  char	command_line[80];
  cmd_ret_t ret = _CONT;
  FILE *fptr;
  char cmd_line[256];
  int	margc;
  char	*margv[10];
  const cmd_t	*cmd;

  if (argc==2) /* do we have a script to run */
  {
    if ((fptr = fopen(argv[1], "r")) == NULL)
    {
      ERR_GOTO(err,error_construct(ERROR_NOFILE,argv[1]));
    }
    /*
     * read file and parse commands
     */
    while (ret != _QUIT)
    {
      do
      {
        if (read_line(fptr,cmd_line, sizeof(cmd_line))==_QUIT)
          goto exit_gracefully;
      } while (cmd_line[0] == '|' || strlen(cmd_line)==1);

      margc = _getargs(cmd_line, margv);

      for (cmd = &cmd_tbl[0]; cmd->call; cmd++)
      {
        if (strcmp(margv[0], cmd->name) != 0)
  	continue;
        else if ((ret=(*(cmd->call))(margc, margv)) == _QUIT)
  	break;
        else if (ret == _SYNTAX)
        {
  	error_generate(error_construct(ERROR_SYNTAX,cmd->syntax));
  	break;
        }
        else if (ret == _CONT)
          break;
      }
      if (cmd->call == 0)
        error_generate(error_construct(ERROR_UNKNOWN,margv[0]));
    }
    fclose (fptr);
  }
  else /* or go interactive */
  {
    printf("Entering SCProgram interactive mode, try typing help\n");
    while (ret != _QUIT)
    {
      _getline(command_line, sizeof(command_line));
      argc = _getargs(command_line, argv);

      for (cmd = &cmd_tbl[0]; cmd->call; cmd++)
      {
        if (strcmp(argv[0], cmd->name) != 0)
  	continue;
        else if ((ret=(*(cmd->call))(argc, argv)) == _QUIT)
  	break;
        else if (ret == _SYNTAX)
        {
  	printf("   syntax: %s\n", cmd->syntax);
  	break;
        }
        else if (ret == _CONT)
          break;
      }
      if (cmd->call == 0)
        printf("   unknown command - try 'h' for help\n");
    }
  }

exit_gracefully:
  /* _wait(0,NULL); */
  if (err)
    error_generate(err);
  return (0);
}
