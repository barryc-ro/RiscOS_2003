/************************************************************************/
/* 	        Copyright 1996 Acorn Network Computers		        */
/*									*/
/*  This material is the confidential trade secret and proprietary	*/
/*  information of Acorn Network Computers. It may not be reproduced,   */
/*  used sold, or transferred to any third party without the prior      */
/*  written consent of Acorn Network Computers. All rights reserved.	*/
/* 									*/
/************************************************************************/

/*
 *
 * Modification History
 *---------------------
 *
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"
#include "error.h"
#include "constants.h"
#include "scinter.h"

/*
 * script processing table
 */
static cmd_ret_t _write     (int, char**);
static cmd_ret_t _read      (int, char**);
static cmd_ret_t _code      (int, char**);
static cmd_ret_t _display   (int, char**);
static cmd_ret_t _wait      (int, char**);
static cmd_ret_t _createdir (int, char**);
static cmd_ret_t _createfile(int, char**);

static const cmd_t cmd_tbl[] = {
        _write,     "write",     "write <filename> <scfilename>",
        _read,      "read",      "read <filename> <scfilename>",
        _code,      "code",      "code <code number>",
        _display,   "display",   "display <text to be displayed>",
        _wait,	    "wait",      "wait",
        _createdir, "createdir", "createdir <scfilename> <size> <access>",
        _createfile,"createfile","createfile <scfilename> <size> <access>",
	0,0,0
};

char sc_code[9] = "";

/*
 * wait until the SCInterface module is not busy or an error has occurred
 * do a twiddler whilst waiting for completion
 */
static int
_check_interface_status(void)
{
  _kernel_swi_regs reg;
  char twiddle[4]={124,47,45,92};
  int i=0;
  int status;
  int error;

  _kernel_swi(OS_RemoveCursors,&reg,&reg);
  do
  {
    reg.r[0] = (int)twiddle[i++];
    if (i>=sizeof(twiddle)) i=0;
    _kernel_swi(OS_WriteC,&reg,&reg);

    _kernel_swi(SCInterface_Status, &reg, &reg);
    status = reg.r[0];
    error = reg.r[1];

    reg.r[0] = (int)'\b';
    _kernel_swi(OS_WriteC,&reg,&reg);

    if (status==StatusError)
      break;

  } while (status==StatusBusy);

  reg.r[0] = (int)' ';
  _kernel_swi(OS_WriteC,&reg,&reg);
  reg.r[0] = (int)'\b';
  _kernel_swi(OS_WriteC,&reg,&reg);
  _kernel_swi(OS_RestoreCursors,&reg,&reg);

  return (status==StatusError)?error:0;
}

/*
 * create a directory on the smart card
 */
static cmd_ret_t
_createdir(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;

  if (argc!=4)
    return (_SYNTAX);

  printf("createdir: creating directory %s size 0x%x access 0x%x ",
          argv[1],atoi(argv[2]),atoi(argv[3]));

  /*
   * do a create dir
   */
  reg.r[0] = 1<<0 | 1<<1;       /* flags */
  reg.r[1] = (int)argv[1];	/* filename */
  reg.r[2] = atoi(argv[2]);	/* size */
  reg.r[3] = atoi(argv[3]);	/* access condition */
  ERR_GOTO(err,_kernel_swi(SCInterface_Create,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\ncreatedir: error 0x%x returned from SCInterface\n",reg.r[0]);
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\ncreatedir: error 0x%x returned async from SCInterface\n",status);
  else
    printf("\ncreatedir: directory created\n");

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * create a file on the smart card
 */
static cmd_ret_t
_createfile(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int status;

  if (argc!=4)
    return (_SYNTAX);

  printf("createdir: creating file %s size 0x%x access 0x%x ",
          argv[1],atoi(argv[2]),atoi(argv[3]));

  /*
   * do a create dir
   */
  reg.r[0] = 1<<0;              /* flags */
  reg.r[1] = (int)argv[1];	/* filename */
  reg.r[2] = atoi(argv[2]);	/* size */
  reg.r[3] = atoi(argv[3]);	/* access condition */
  ERR_GOTO(err,_kernel_swi(SCInterface_Create,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\ncreatedir: error 0x%x returned from SCInterface\n",reg.r[0]);
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\ncreatedir: error 0x%x returned async from SCInterface\n",status);
  else
    printf("\ncreatedir: file created\n");

exit_gracefully:
  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * wait for a key to be pressed
 */
static cmd_ret_t
_wait(int argc, char **argv)
{
  _kernel_swi_regs reg;
  int iCarry;

  printf("press a key...\n");
  reg.r[0] = 145;
  reg.r[1] = 0;
  do
  {
    _kernel_swi_c(OS_Byte, &reg, &reg, &iCarry);
  } while (iCarry!=0);

  return (_CONT);
}

/*
 * display given text on the screen
 */
static cmd_ret_t
_display(int argc, char **argv)
{
  int i;

  if (argc<=1)
    return (_SYNTAX);

  for (i=1; i<argc; i++)
    printf("%s%s",i==1?"":" ",argv[i]);

  printf(".\n");

  return (_CONT);
}

/*
 * function to record the supplied password
 *
 *   argv[1] = code
 */
static cmd_ret_t
_code(int argc, char **argv)
{
  if (argc!=2)
    return (_SYNTAX);

  strncpy(sc_code,argv[1],sizeof(sc_code));

  return (_CONT);
}

/*
 * function to perform a write of a file to the smart card
 *
 *   argv[1] = riscos filename
 *   argv[2] = smartcard filename
 */
static cmd_ret_t
_write(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  int handle;
  int len;
  char *buffer = 0;
  int status;

  if (argc!=3)
    return (_SYNTAX);

  printf("write: file %s to smart card file %s ",argv[1],argv[2]);

  /*
   * open file
   */
  reg.r[0] = 0x4f;
  reg.r[1] = (int)argv[1];
  reg.r[2] = 0;
  ERR_GOTO(err,_kernel_swi(OS_Find,&reg,&reg));
  handle = reg.r[0];

  if (!handle)
    ERR_GOTO(err,error_construct(ERROR_NOFILE,0));

  /*
   * find size of file
   */
  reg.r[0] = 2;
  reg.r[1] = handle;
  ERR_GOTO(err,_kernel_swi(OS_Args, &reg, &reg));
  len = reg.r[2];

  if (!len)
    ERR_GOTO(err,error_construct(ERROR_ZEROSIZE,argv[1]));

  if ((buffer = malloc(len))==NULL)
    ERR_GOTO(err,error_construct(ERROR_MEMORY,0));

  /*
   * read file with given handle
   */
  reg.r[0] = 3;
  reg.r[1] = handle;
  reg.r[2] = (int)buffer;
  reg.r[3] = len;
  reg.r[4] = 0;
  ERR_GOTO(err,_kernel_swi(OS_GBPB,&reg,&reg));

  /*
   * do the write to the smart card
   */
  reg.r[0] = 1<<0;
  reg.r[1] = (int)argv[2];
  reg.r[2] = 0;
  reg.r[3] = (int)buffer;
  reg.r[4] = len;
  reg.r[5] = (int)sc_code;
  reg.r[6] = strlen(sc_code);
  ERR_GOTO(err,_kernel_swi(SCInterface_Write,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\nwrite: error 0x%x returned from SCInterface\n",reg.r[0]);
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
    printf("\nwrite: error 0x%x returned async from SCInterface\n",status);
  else
    printf("\nwrite: complete %d bytes written\n",len);

exit_gracefully:
  if (handle)
  {
    reg.r[0] = 0;
    reg.r[1] = handle;
    _kernel_swi(OS_Find,&reg,&reg);
  }
  if (buffer)
    free(buffer);

  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * function to read a smart card file into a file
 *
 *   argv[1] = riscos filename
 *   argv[2] = smartcard filename
 */
static cmd_ret_t
_read(int argc, char **argv)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  char data[8];
  int  status;
  char *buffer = 0;
  int  len;
  int  handle;

  if (argc!=3)
    return (_SYNTAX);

  printf("read: smart card file %s to file %s ",argv[2],argv[1]);

  /*
   * find out the size of the file to read
   */
  reg.r[0] = 1<<0;
  reg.r[1] = (int)argv[2];
  reg.r[2] = (int)data;
  reg.r[3] = sizeof(data);
  ERR_GOTO(err,_kernel_swi(SCInterface_FileInfo,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\nread: error 0x%x returned from SCInterface\n",reg.r[0]);
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\nread: error 0x%x returned async from SCInterface\n",status);
    goto exit_gracefully;
  }

  len = (data[2]<<8)|data[3]; /* calculate size from fileinfo */

  if ((buffer = malloc(len))==NULL)
    ERR_GOTO(err,error_construct(ERROR_MEMORY,0));

  /*
   * do the read from the smart card
   */
  reg.r[0] = 1<<0;
  reg.r[1] = (int)argv[2];
  reg.r[2] = 0;
  reg.r[3] = (int)buffer;
  reg.r[4] = len;
  reg.r[5] = (int)sc_code;
  reg.r[6] = strlen(sc_code);
  ERR_GOTO(err,_kernel_swi(SCInterface_Read,&reg,&reg));
  if (reg.r[0] != SC_SUCCESS)
  {
    printf("\nread: error 0x%x returned from SCInterface\n",reg.r[0]);
    goto exit_gracefully;
  }

  /*
   * now wait for completion
   */
  if ((status=_check_interface_status())!=0)
  {
    printf("\nread: error 0x%x returned async from SCInterface\n",status);
    goto exit_gracefully;
  }
  else
    printf("\n");


  /*
   * open file
   */
  reg.r[0] = 0x8f;
  reg.r[1] = (int)argv[1];
  reg.r[2] = 0;
  ERR_GOTO(err,_kernel_swi(OS_Find,&reg,&reg));
  handle = reg.r[0];

  /*
   * write to file with given handle
   */
  reg.r[0] = 1;
  reg.r[1] = handle;
  reg.r[2] = (int)buffer;
  reg.r[3] = len;
  reg.r[4] = 0;
  ERR_GOTO(err,_kernel_swi(OS_GBPB,&reg,&reg));
    printf("read: complete %d bytes read\n",len);

exit_gracefully:
  if (handle)
  {
    reg.r[0] = 0;
    reg.r[1] = handle;
    _kernel_swi(OS_Find,&reg,&reg);
  }

  if (buffer)
    free(buffer);

  if (err)
    error_generate(err);

  return (_CONT);
}

/*
 * parse the command line to extract arguments in form argc and argv
 */
static int
_getargs(char *line, char **argv)
{
  int  argc = 0;
  char *cp;
  char ch;

  cp = line;
  while (*cp!=0)
  {
    ch = *cp;
    *cp++ = tolower(ch);
  }

  cp = line;
  while (*cp != '\0')
  {
    while (*cp == ' ')
      cp++;
    if (*cp == '\0')
      break;

    argv[argc++] = cp;
    while (*cp != '\0' && *cp != ' ')
      cp++;
    if (*cp == 0)
      break;
    *cp++ = '\0';
  }
  *cp++ = '\0';

  return (argc);
}

/*
 * read a line of text in from the specified file and remove any newlines
 */
cmd_ret_t
read_line(FILE *fptr, char *buffer, int size)
{
  int i;

  if (fgets(buffer, size, fptr)==NULL)
    return (_QUIT);

  i=strlen(buffer);
  while (i>0 && buffer[i]!='\n') i--;

  if (i>0)
    buffer[i] = 0;

  return (_CONT);
}

/*
 */
int main(int argc, char *argv[])
{
  _kernel_oserror *err = NULL;
  cmd_ret_t ret = _CONT;
  FILE *fptr;
  char cmd_line[256];
  int	margc;
  char	*margv[10];
  const cmd_t	*cmd;

  if (argc!=2)
  {
    ERR_GOTO(err,error_construct(ERROR_USAGE,0));
  }

  if ((fptr = fopen(argv[1], "r")) == NULL)
  {
    ERR_GOTO(err,error_construct(ERROR_NOFILE,argv[1]));
  }
  /*
   * read file and parse commands
   */
  while (ret != _QUIT)
  {
    do
    {
      if (read_line(fptr,cmd_line, sizeof(cmd_line))==_QUIT)
        goto exit_gracefully;
    } while (cmd_line[0] == '|' || strlen(cmd_line)==1);

    margc = _getargs(cmd_line, margv);

    for (cmd = &cmd_tbl[0]; cmd->call; cmd++)
    {
      if (strcmp(margv[0], cmd->name) != 0)
	continue;
      else if ((ret=(*(cmd->call))(margc, margv)) == _QUIT)
	break;
      else if (ret == _SYNTAX)
      {
	error_generate(error_construct(ERROR_SYNTAX,cmd->syntax));
	break;
      }
      else if (ret == _CONT)
        break;
    }
    if (cmd->call == 0)
      error_generate(error_construct(ERROR_UNKNOWN,margv[0]));
  }
  fclose (fptr);

exit_gracefully:
  if (err)
    error_generate(err);

  return (0);
}
