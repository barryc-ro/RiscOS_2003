/*
 Scan.c
 Scan postboxes for new mail and commands for mercury server
 (c)1994 STNC Enterprises
 */

#define ANTTYPE

/*
****************************************************************
             Standard includes
****************************************************************
*/
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <ctype.h>
#include <stdlib.h>

/*
******************************************************************
             RISC OS Includes
******************************************************************
*/
#include "kernel.h"
#include "swis.h"



/*
******************************************************************
            Local Includes
******************************************************************
*/
#include "file.h"
#include "message.h"
#include "error.h"
#include "database.h"
#include "users.h"
#include "token.h"
#include "smtp.h"
#include "nntp.h"
#include "log.h"
#include "debug.h"
#include "wimp.h"
#include "config.h"
#include "scan.h"
#include "version.h"
#include "mail.h"

/*
******************************************************************
Local defines
******************************************************************
*/
#define FALSE 0
#define TRUE 1

#define FAIL_ANY      0
#define FAIL_CENSORED 1

#define MAIL_FLAG_READ 1

/*
******************************************************************
 Externals
******************************************************************
*/

extern char mail_domain[];
extern char smtp_server[];
extern char pop_server[];

extern char news_org[];
extern char pb_path[];
extern char po_path[];
extern char mail_domain[];
extern char news_key[];
static error_reported=0;
extern int connection_handle;

extern char mime_type[];
extern char mime_subtype[];

extern int admin_handle;

extern int total_mail_size;
extern int total_news_size;

extern int do_nntp;
extern int nntp_state;
extern int smtp_state;
extern int mail_in_state;
extern int script_active;

/*
******************************************************************
 Exported variables
******************************************************************
*/
int pending_messages=0;
int pass_pos=0;

extern int total_mail_size;
extern int total_news_size;

/*
******************************************************************
 Static variables
******************************************************************
*/
static char old_boundary[256];
static char old_mime_type[256];
char current_pass[256];

/*
******************************************************************
 Static functions
******************************************************************
*/

/*
 deliver_waring(char *reason)
 Deliver a warning message to the administrator, checking first
 that the administrator is interested in warnings

 Args:
      reason - A short string to be included in the message.

 Returns

      void.
*/


void deliver_warning(char *reason)
{
 char buf[256],path[256];
 char admin_name[256];
 time_t timer;
 int f;

 if (!selected(admin_handle,3)) return;                /* Not interested in warnings */

 sprintf(buf,"%s.PostBoxes",pb_path);                  /* Get a postbox to create message in */
 new_server_file_name(buf,path);

 f=file_open_create(path,ACCESS_DIR);                  /* Crate and open file */
 if (f==0) return;

 get_icon_text(admin_handle,1,admin_name);             /* Get administartor's name */
 sprintf(buf,"To: %s",admin_name);                     /* And create To: hdr line */
 file_write_line(f,buf,TRUE);

 sprintf(buf,"From: MailServer@localhost");       /* From MailServer ! */
 file_write_line(f,buf,TRUE);

 file_write_line(f,"Subject: Server warning\n",FALSE); /* Subject */

 strftime(buf,256,"Date: %d %b %Y %H:%M:%S GMT\n",gmtime(&timer)); /* Date line */
 file_write_line(f,buf,FALSE);

 sprintf(buf,"\n\n%s",reason);                         /* Gap between hdr & body + body*/
 file_write_line(f,buf,FALSE);

 file_close(&f);                                       /* Close file, delivered by next scan */
}

/*
 local_deliver_fail(t,reason,why)
 Deliver a failed delivery notification.

 Args:
     t      - User to notify.
     reason - Textual reason for failiure.
     why    - Failiure type.

 Returns
     void.

*/
void local_deliver_fail(char *t,char *reason,int why)
{
 char path[256];
 char buf[256];
 int f,f1;
 char to[2048];
 time_t timer;

 smtp_get_user(t,to);                    /* Get user part of address */
 if (strcmpci(to,"MailServer")) return;  /* Don't reply to self      */

 log_report(LOG_INFO,reason);            /* Note it in the log */

 sprintf(buf,"%s.PostBoxes",pb_path);    /* Get a postbox and open it */
 new_server_file_name(buf,path);
 f=file_open_create(path,ACCESS_DIR);
 if (f==0) return;

 get_icon_text(admin_handle,1,path);     /* Is the adinistrator interested ?*/

 if (  /* bounced, but not to admin! */
      (selected(admin_handle,5) && (!strcmpci(t,path)) && (why!=FAIL_CENSORED)) ||
      (selected(admin_handle,4) && (why==FAIL_CENSORED))      /* Or censored */
    )
 sprintf(buf,"To: %s,%s@localhost",t,path);
  else sprintf(buf,"To: %s",t);

 file_write_line(f,buf,TRUE);

 sprintf(buf,"From: MailServer@%s",mail_domain);
 file_write_line(f,buf,TRUE);

 file_write_line(f,"Subject: Failed delivery notification\n",FALSE);

 timer=time(NULL);
 strftime(buf,256,"Date: %d %b %Y %H:%M:%S GMT\n",gmtime(&timer));
 file_write_line(f,buf,FALSE);

 sprintf(buf,"\n\nThe following message could not be delivered for the following reason:\n\n%s\n---message follows--\n\n",reason);
 file_write_line(f,buf,FALSE);

 f1=file_open("<MailServ$Dir>.Message",ACCESS_RW);          /* copy original message */
 if (f1)
 {
  while (file_get_line(f1,buf,FALSE)) file_write_line(f,buf,TRUE);
  file_close(&f1);
 }

 file_close(&f);
}

static char base64[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static int b64tbl[256];

static void b64_init(void)
{
 int i;
 for (i=0;i<256;i++) b64tbl[i]=0;
 for (i=0;i<strlen(base64);i++) b64tbl[base64[i]]=i;
}
#if 0
static int b64(char c)
{
 int i;
 for (i=0;i<strlen(base64);i++)
  if (c==base64[i]) return i;
 return 0;
}
#else
static int b64(char c)
{
 return b64tbl[c];
}
#endif

static int message_end(char *b)
{
 int l=strlen(b);
//DEBUG((dbg,"Message end? %s",b));
 if ( (l>3) && (b[l-1]=='-') && (b[l-2]=='-')) return TRUE;
 return FALSE;
}

static int mime_base64_decode(int in,int out,char *boundary)
{
 char buf[256];
 int p=0,outcount=3;
 int val=0;
 char outbuf[1024*6+10];
 int  outbufptr=0;
 char inbuf[10*1024];
 char *inbufptr=inbuf;
 char *c=buf;
 int i,copy_end=FALSE,pos;

 _kernel_swi_regs r;

 b64_init();

/* Read file in, use 5K chunks */
 r.r[4]=file_get_pos(in);
 do
 {
  int max;
  r.r[0]=3;
  r.r[1]=in;
  r.r[2]=(int)inbuf;
  r.r[3]=10*1024;
  pos=r.r[4];
  _kernel_swi(OS_GBPB,&r,&r);
  max=10*1024-r.r[3];      /* Number of bytes in buffer */
  if (r.r[3]!=0) copy_end=TRUE;
  inbufptr=inbuf;
  do
  {
   while ((inbufptr<inbuf+max) && (*inbufptr != '\n')) *c++=*inbufptr++;
   if (*inbufptr=='\n')
   {
    *c=0;
    c=buf;
    inbufptr++;

    if (strcmpcin(buf,boundary,strlen(boundary)))
    {
     file_set_ptr(in,pos+(inbufptr-inbuf));
     if (outbufptr>0)
     {
      _kernel_swi_regs r;
      r.r[0]=2;
      r.r[1]=out;
      r.r[2]=(int)outbuf;
      r.r[3]=outbufptr;
      _kernel_swi(OS_GBPB,&r,&r);
     }
     return message_end(buf); /* at end */
    }

    for (i=0;i<strlen(buf);i++)
    {
     if (buf[i]=='=')
     {
      while (buf[i]=='=')
      {
       outcount--;
       i++;
      }
     } else
     {
      val+=b64(buf[i])<<(18-6*p);
     }
     p++;
     if ((p==4) || (outcount<3))
     {
#if 0
      char bytes[3];
      bytes[0]=(val>>16) & 0xff;
      bytes[1]=(val>>8)  & 0xff;
      bytes[2]=val &0xff;
      file_put_bytes(out,bytes,outcount);
#else
      if (outcount >=1) outbuf[outbufptr++]=(val>>16) & 0xff;
      if (outcount >=2) outbuf[outbufptr++]=(val>>8)  & 0xff;
      if (outcount >=3) outbuf[outbufptr++]=val &0xff;
      if (outbufptr>1024*6)
      {
       _kernel_swi_regs r;
       r.r[0]=2;
       r.r[1]=out;
       r.r[2]=(int)outbuf;
       r.r[3]=outbufptr;
       _kernel_swi(OS_GBPB,&r,&r);
       outbufptr=0;
//error_display("write");
      }
#endif
      p=0;
      val=0;
     }
    if (outcount<3) break;
    }
   }
   hourglass_off();
   wimp_do_poll(FALSE);
   hourglass_on();
  } while (inbufptr<inbuf+max);
 } while (r.r[3]==0);

 file_set_ptr(in,r.r[4]);

 if (outbufptr>0)
 {
  _kernel_swi_regs r;
  r.r[0]=2;
  r.r[1]=out;
  r.r[2]=(int)outbuf;
  r.r[3]=outbufptr;
  _kernel_swi(OS_GBPB,&r,&r);
 }

 while (file_get_line(in,buf,FALSE))
 {
//DEBUG((dbg,"%s %s",buf,boundary));
  if (strcmpcin(buf,boundary,strlen(boundary))) return message_end(buf); /* at end */
 }
//error_display("EOF");
 return TRUE;
}


static int mime_decode(int in,char *d,char *init_boundary,int file,int *att_num,int top,int skip)
{
 char boundary[256];
 char buf[256],buf1[256];
 char command[256];
 char encoding[256],*e;
 char path[256];
 char type_name[256];
 int pos;
 int name_num=0,out;
 int type;
 char dir[256],new_dir[256];

 strcpy(dir,d);
 strcpy(new_dir,d);
 if (init_boundary) strcpy(boundary,init_boundary);
 process_mime("text/plain ;name=\"Data\" ;type=\"ffd,Data\"",FALSE,FALSE);
//error_display("mime_decode");
//error_display(dir);

 while (1)
 {
      /* set default type */

       strcpy(mime_type,"text");
       strcpy(mime_subtype,"plain");

      /* process hdr */
       if (!file_get_line(in,buf,FALSE))
       {
        file_close(&in);
        return 0;
       }

      while (hdr_get_command(buf,command,&pos))
      {
       if (strcmpci(command,"Content-Type"))
       {
        process_mime(buf+pos,FALSE,TRUE);
        if (strcmpci(mime_type,"text")) process_mime("text/plain; type=\"fff,Text\"",FALSE,TRUE);
        if (strcmpci(mime_type,"text")) process_mime("text/plain; name=\"Text\"",FALSE,FALSE);
       }
       if (strcmpci(command,"Content-Transfer-Encoding")) strcpy(encoding,buf+pos);
       if (!file_get_line(in,buf,FALSE))
       {
        file_close(&in);
        error_report_string(token_get("ER30"));
//error_display("1");
        local_deliver_fail(message_get_from(),token_get("FD01"),FAIL_ANY);
        return 1;
       }
      }

       /* Done hdr */
       if (strcmpci(mime_type,"multipart"))
       {
        char lboundary[256];
        sprintf(lboundary,"--%s",mime_get_arg("boundary"));
//error_display("Boundary");
//error_display(mime_get_arg("boundary"));
//error_display(lboundary);
        /* Skip to next boundary */
        while (1)
        {
         if (!file_get_line(in,buf,FALSE))
         {
          file_close(&in);
          error_report_string(token_get("ER30"));
//error_display("2");
          local_deliver_fail(message_get_from(),token_get("FD01"),FAIL_ANY);
          return 1;
         }
         if (strcmpcin(lboundary,buf,strlen(boundary))) break;
        }

        if (skip)  /* and again */
        {
         while (1)
         {
          if (!file_get_line(in,buf,FALSE))
          {
           file_close(&in);
           error_report_string(token_get("ER30"));
//error_display("3");
           local_deliver_fail(message_get_from(),token_get("FD01"),FAIL_ANY);
           return 1;
          }
          if (strcmpcin(lboundary,buf,strlen(boundary))) break;
         }


        }
//error_display(lboundary);

        if (                  /* Do next level */
             mime_decode(in,new_dir,lboundary,(top>0)?file:0,(top>0)?att_num:0,0,0)
           ) return 1;

//error_display("Got dir");
        while (file_get_line(in,buf,FALSE))
        {
//error_display(buf);
//DEBUG((dbg,"%s %s",buf,boundary));
         if (strcmpcin(buf,boundary,strlen(boundary))) break;
        }
        if (message_end(buf)) return 0; /* at end */
       } else /* Decode data */
       {
        /* Create output file */
        char *name=mime_get_arg("name");
        sprintf(buf1,"F%02i",name_num);
        if (name==NULL)
        {
         name=buf1;
         name_num++;
        }
#ifdef ANTTYPE
        if (strcmpci(mime_type,"application") && strcmpci(mime_subtype,"riscos"))
        {
         char *t;
         int load=0,exec=0;
         type=0xffd;
         t=mime_get_arg("type");
         if (t) strcpy(type_name,t); else strcpy(type_name,"Data");
         t=mime_get_arg("load");
         if (t) sscanf(t,"&%x",&load);
         t=mime_get_arg("exec");
         if (t) sscanf(t,"&%x",&exec);
         if (load & 0xfff00000 == 0xfff00000)
         {
          type=(load & 0x000fff00) >> 8;
         }
         t=name+strlen(name);
         while ((t>=name) && (*t!=',')) t--;
         if (t>name) sscanf(t+1,"%x",&type);
        } else /* "not application/riscos" */
#endif
        if (strcmpci(mime_type,"application") && strcmpci(mime_subtype,"x-riscos"))
        {
         char *t;
         t=mime_get_arg("type");
//error_display(t);
         if (strcmpci(t,"1000,directory"))
         {
          char buf[256];
          sprintf(path,"%s.%s",dir,name);
          if (file)
          {
           char buf[256];
           if (name[0]=='!') sprintf(buf,"%i %s Application\n",0x2000,name);
           else sprintf(buf,"%i %s Directory\n",0x1000,name);
//error_display(buf);
           file_write_line(file,buf,FALSE);
           sprintf(buf,"%s\n",path+11+strlen(po_path));
           file_write_line(file,buf,FALSE);
           (*att_num)++;
          }

          file_create_dir(path);
          while (1)
          {
           if (strcmpcin(boundary,buf,strlen(boundary))) break;
           if (!file_get_line(in,buf,FALSE))
           {
            file_close(&in);
            error_report_string(token_get("ER30"));
//error_display("5");
            local_deliver_fail(message_get_from(),token_get("FD01"),FAIL_ANY);
            return 1;
           }
          }
          if (message_end(buf)) return 0;
          strcpy(new_dir,path);
//error_display(dir);
          continue;
         } else
         {
          if (t==NULL) t="ffd,Data";
         }
     DEBUG((dbg,"type is %s",t));
         if (sscanf(t,"%x,%s",&type,type_name)!=2)
         {
          type=0xffd;
          strcpy(type_name,t);
         }
     DEBUG((dbg,"Numeric type is %i %s",type,type_name));
        } else /* Not app or not riscos */
        {
         type=0xffd;  /* Data file */
         strcpy(type_name,"Data");
        }
     DEBUG((dbg,"Numeric type is %i",type));

        /* Make name into a RISC OS one */
        {
         char *c;
         for (c=name;*c;c++) if (*c=='.') *c='/';
         if (strlen(name)>10) name[10]=0;
        }


        sprintf(path,"%s.%s",dir,name);
        if (file)
        {
           char buf[256];
           sprintf(buf,"%i %s %s\n",type,name,type_name);
           file_write_line(file,buf,FALSE);
           sprintf(buf,"%s\n",path+11+strlen(po_path));
           file_write_line(file,buf,FALSE);
           (*att_num)++;
        }
        out=file_open_create(path,ACCESS_DIR);
//error_display(path);
        if (out==0)
        {
//         file_close(&in);
         error_report_string(token_get("ER30"));
         local_deliver_fail(message_get_from(),token_get("FD02"),FAIL_ANY);
         return 1;
        }
        e=encoding;
        while (isspace(*e)) e++;
        if (strcmpci(e,"Base64"))
        {
//error_display(boundary);
         if (mime_base64_decode(in,out,boundary))
         {
          file_close(&out);
          file_set_type(path,type);
          return 0;
         }
//DEBUG((dbg,"Not eof"));
        } else
        {
         while (1)
         {
          if (!file_get_line(in,buf,FALSE))
          {
           file_close(&in);
           error_report_string(token_get("ER30"));
//error_display("6");
           local_deliver_fail(message_get_from(),token_get("FD01"),FAIL_ANY);
           return 1;
          }
          if (strcmpcin(buf,boundary,strlen(boundary))) break;
          file_write_line(out,buf,TRUE);
         }
        }
        file_close(&out);
        file_set_type(path,type);
        if (message_end(buf)) return 0;
       }
 } /* While 1 */
}

static void deliver_mime(char *file,char *boundary,char *key)
{
 char dir[256],saved_dir[256];
 char path[256];
 int in,out,start,end;
 char to_buff[4096];
 char cc_buff[4096];
 char buf[256];
 int to_lines,cc_lines;
 int ti,indexstart,mime_attachments;

 hourglass_on();

 in=file_open("<MailServ$Dir>.Message",TRUE);
 if (in==0)
 {
  error_report_string(token_get("ER30"));
  local_deliver_fail(message_get_from(),token_get("FD03"),FAIL_ANY);
  return;
 }

 sprintf(buf,"%s.Mail.Data.%s",po_path,file);
 ti=time(NULL);
 while (difftime(time(NULL),ti)<5) /* Try for 5 seconds */
 {
  out=file_open_append(buf,FALSE);
  if (out) break;
  wimp_do_poll(FALSE);
 }
 if (out==0)
 {
  local_deliver_fail(message_get_from(),token_get("FD04"),FAIL_ANY);
  file_close(&in);
  return;
 }
 start=file_get_pos(out);

 /* skip to first boundary */
 while (file_get_line(in,buf,TRUE))
 {
  if (strcmp(boundary,buf)==0) break;
//  DEBUG((dbg,"Skip *%s* != *%s*",boundary,buf));
 }

 /* And write out first part */
 pass_pos=0;
 strcpy(current_pass,key);
 while (file_get_line(in,buf,TRUE))
 {
//  DEBUG((dbg,"Write %s",buf));
  if (strcmpci(boundary,buf)) break;
  encode_line(buf,FALSE,TRUE);
  file_write_line(out,buf,FALSE);
 }
 end=file_get_pos(out);
 file_close(&out);
 file_close(&in);   /* Copied data to data file */
 total_mail_size+=end-start;

 /* Now write temp. index file data */
 sprintf(buf,"%s.Mail.Index.%s",po_path,file);
 ti=time(NULL);
 while (difftime(time(NULL),ti)<5) /* Try for 5 seconds */
 {
  out=file_open_append(buf,FALSE);
  if (out) break;
  wimp_do_poll(FALSE);
 }
 if (out==0)
 {
  local_deliver_fail(message_get_from(),token_get("FD05"),FAIL_ANY);
  return;
 }
 strcpy(buf,message_get_subject());
 pass_pos=0;
 strcpy(current_pass,key);
 encode_line(buf,TRUE,TRUE);
 file_write_line(out,buf,FALSE);
 strcpy(buf,message_get_from());
 file_write_line(out,buf,TRUE);
 message_get_all_to(to_buff,&to_lines);
 message_get_all_cc(cc_buff,&cc_lines);
 sprintf(buf,"%i %i %i %i %i %i %4i",
         time(NULL),start,end,(message_get_flags()&MESSAGE_FLAG_ACK)?2:0,to_lines,cc_lines,0);
 indexstart=file_get_pos(out);
 file_write_line(out,buf,TRUE);
 file_write_line(out,to_buff,FALSE);
 file_write_line(out,cc_buff,FALSE);


 sprintf(path,"%s.Mail.Data",po_path);
 new_user_file_name(path,dir);
 file_create_dir(dir);
 strcpy(saved_dir,dir);

 in=file_open("<MailServ$Dir>.Message",TRUE);
 if (in==0)
 {
  error_report_string(token_get("ER30"));
  local_deliver_fail(message_get_from(),token_get("FD03"),FAIL_ANY);
  return;
 }
 mime_attachments=0;
 if (mime_decode(in,dir,0,out,&mime_attachments,1,1)==0)
 {
  file_set_ptr(out,indexstart);
  sprintf(buf,"%i %i %i %i %i %i %4i",time(NULL),start,end,
             (message_get_flags()&MESSAGE_FLAG_ACK)?2:0,to_lines,cc_lines,mime_attachments);
  file_write_line(out,buf,TRUE);
 } else
 {
  file_set_ptr(out,indexstart);
  sprintf(buf,"%i %i %i %i %i %i %4i",time(NULL),start,end,
             (message_get_flags()&MESSAGE_FLAG_ACK)?2:0,to_lines,cc_lines,mime_attachments);
  file_write_line(out,buf,TRUE);
 }
 hourglass_off();
 file_close(&in);
 file_close(&out);

 total_mail_size+=file_get_total_size(saved_dir);
}



static void local_deliver(char *to,int mime)
{
 char name[2048],buf[256],file[256],group[256],password[30],www[256],key[256];
 char boundary[256];

// strcpy(boundary,old_boundary);

 smtp_get_user(to,name);
 if (strcmpci(name,"postmaster")) get_icon_text(admin_handle,1,name);
 if (!user_find(name,password,group,buf,file,www,key))
 {
  sprintf(buf,token_get("FD06"),to);
  local_deliver_fail(message_get_from(),buf,FAIL_ANY);
  return;
 }

 DEBUG((dbg,"From: is %s",message_get_from()));
 if (!check_allowed_address(FALSE,message_get_from(),group))
 {
  sprintf(buf,token_get("FD07"),message_get_from(),to);
  local_deliver_fail(message_get_from(),buf,FAIL_CENSORED);
  return;
 }

 if (file_get_length("<MailServ$Dir>.Message")+total_mail_size>mail_limit*1024*1024)
 {
  local_deliver_fail(message_get_from(),token_get("FD10") ,FAIL_ANY);
  return;
 }

 if (mime)
 {
  strcpy(mime_type,old_mime_type);
  strcpy(boundary,old_boundary);
 }

 if ((message_get_flags() & MESSAGE_FLAG_MIME) || mime)
 {
  strcpy(old_mime_type,mime_type);

  if (strcmpci(mime_type,"multipart"))
  {
   DEBUG((dbg,"MULTIPART"));
   if (!mime) sprintf(boundary,"--%s",mime_get_arg("boundary"));
   strcpy(old_boundary,boundary);
   DEBUG((dbg,"MULTIPART boundary = %s",boundary));
   deliver_mime(file,boundary,key);
   return;
  }
 }

 {
  int in,out,start,end;
  char to_buff[4096];
  char cc_buff[4096];
  int to_lines,cc_lines;
  int ti;

  in=file_open("<MailServ$Dir>.Message",TRUE);
  if (in==0)
  {
   error_report_string(token_get("ER30"));
   local_deliver_fail(message_get_from(),token_get("FD03"),FAIL_ANY);
   return;
  }
  sprintf(buf,"%s.Mail.Data.%s",po_path,file);
  ti=time(NULL);
  /* this timeout is presumably here because mail can be accessing
     the index at the same time.
     I've increased it from 5 secs to 10 secs because large index files
     might take a long time to read.
     might help to stop the index going astray??  ne */
  while (difftime(time(NULL),ti)<10) /* Try for 10 seconds (cos mail could be accesing it) */
  {
   out=file_open_append(buf,FALSE);
   if (out) break;
   wimp_do_poll(FALSE);
  }
  if (out==0)
  {
   local_deliver_fail(message_get_from(),token_get("FD04"),FAIL_ANY);
   file_close(&in);
   return;
  }
  start=file_get_pos(out);
  pass_pos=0;
  strcpy(current_pass,key);
  while (file_get_line(in,buf,TRUE))
  {
   encode_line(buf,FALSE,TRUE);
   file_write_line(out,buf,FALSE);
  }
  end=file_get_pos(out);
  total_mail_size+=end-start;
  file_close(&out);
  file_close(&in);
  /* Now write index file */
  sprintf(buf,"%s.Mail.Index.%s",po_path,file);
  ti=time(NULL);
  while (difftime(time(NULL),ti)<10) /* Try for 10 seconds */
  {
   out=file_open_append(buf,FALSE);
   if (out) break;
   wimp_do_poll(FALSE);
  }
  if (out==0)
  {
   local_deliver_fail(message_get_from(),token_get("FD05"),FAIL_ANY);
   return;
  }
  strcpy(buf,message_get_subject());
  pass_pos=0;
  strcpy(current_pass,key);
  encode_line(buf,TRUE,TRUE);
  file_write_line(out,buf,FALSE);
  strcpy(buf,message_get_from());
  file_write_line(out,buf,TRUE);
  message_get_all_to(to_buff,&to_lines);
  message_get_all_cc(cc_buff,&cc_lines);
  sprintf(buf,"%i %i %i %i %i %i %4i",time(NULL),start,end,(message_get_flags()&MESSAGE_FLAG_ACK)?2:0,to_lines,cc_lines,0);
  file_write_line(out,buf,TRUE);
  file_write_line(out,to_buff,FALSE);
  file_write_line(out,cc_buff,FALSE);
  file_close(&out);
  sprintf(buf,"%s.Mail.Index.%s",po_path,file);
  file_stamp_now(buf);
  sprintf(buf,"%s.Mail.Data.%s",po_path,file);
  file_stamp_back(buf,2);
 }
}

static void do_post_news(int fz,char *pb)
{
 int to_type;
 int hdr;
 char *to;
 char buf1[256];
DEBUG((dbg,"Posting"));

 file_close(&fz);
 message_init_file(pb);
 /* For every message (should only ever be one) */
 while (message_load_next())
 {
  /* For every newsgroup */
  message_reset_to();
  while(message_get_to(&to,&to_type) && to[0])
  {
   int local=FALSE;
   int active_f=file_open("<MailServ$Dir>.Active",FALSE);
   int active_f_out=file_open_create("<MailServ$Dir>.ActiveZ",ACCESS_RW);

   if (file_get_length("<MailServ$Dir>.Message")+total_news_size>news_limit*1024*1024)
   {
    local_deliver_fail(message_get_from(),token_get("FD11") ,FAIL_ANY);
   }

   DEBUG((dbg,"Posting to %s",to));
   DEBUG((dbg,"Posting From:%s",message_get_from()));
   if (active_f!=0)
   {
    char buf[256];
    while(1)
    {
     char ng[256],fn[256];
     int first,last,date;
     DEBUG((dbg,"loop"));
     if (!file_get_line(active_f,buf,FALSE)) break;
     DEBUG((dbg,"Read %s",buf));

     sscanf(buf,"%i %i %i %s %s",&date,&first,&last,ng,fn);
     DEBUG((dbg,"%s %s",ng,to));
     if (strcmpci(ng,to))
     {
      int index,data,message;
      int start,end;
      DEBUG((dbg,"Found newsgroup"));
      first--;
      local=TRUE;
//      file_close(&active_f);
      sprintf(buf,"%s.News.Data.%s",po_path,fn);
      data=file_open_append(buf,TRUE);
      if (data!=0)
      {
       start=file_get_pos(data);
       pass_pos=0;
       strcpy(current_pass,news_key);
       message=file_open("<MailServ$Dir>.Message",FALSE);
       if (message!=0)
       {
        file_get_line(message,buf,TRUE);
        hdr=TRUE;
        while (file_get_line(message,buf,TRUE))
        {
         if (hdr && (buf[0]==0))  /* Add or line at end */
         {
          char buf1[256];
          sprintf(buf1,"Organization: %s",news_org);
          encode_line(buf1,FALSE,TRUE);
          file_write_line(data,buf1,FALSE);
          hdr=FALSE;
         }
         if (strncmp(buf,"From:",5) == 0)
         {
           char buf2[240];
           DEBUG((dbg,"Found a from: line"));
           smtp_get_user(buf,buf2);
           sprintf(buf,"From: %s@%s",buf2,mail_domain);
         }
         DEBUG((dbg,"Writing %s",buf));
         encode_line(buf,FALSE,TRUE);
         file_write_line(data,buf,FALSE);
        }
        end=file_get_pos(data);
        file_close(&message);
       }
       file_close(&data);
       total_news_size+=end-start;
       /* Now update index */
       sprintf(buf,"%s.News.Index.%s",po_path,fn);
       index=file_open(buf,TRUE);
       if (index !=0)
       {
        int done=FALSE;
        int out;
        strcpy(buf1,buf);
        strcat(buf1,"z");
        out = file_open_create(buf1,ACCESS_DIR);
        if (out!=0)
        {
         while (file_get_line(index,buf,FALSE))  /* For every thread in the file */
         {
          if (file_write_line(out,buf,TRUE)==0)
          {
           file_close(&index);
           file_close(&out);
           error_report_string1(token_get("E22"),to);
           break;
          }
          buf[strlen(buf)-1]=0;
          if (buf[0]=='+') continue; /* An article, not a thread */
          if (buf[0]=='=') continue; /* An article, not a thread */
          if (nntp_equal_subject(buf,message_get_subject())) /* Same thread */
          {
           char dt[256];
           strcpy(buf1,message_get_from());
           smtp_get_user(buf1,dt);
           sprintf(buf,"+%i %i %i %i %s@%s",first,nntp_get_time(),start,end,dt,mail_domain);
           sprintf(dt,"=%s",message_get_date());
           if (
               (file_write_line(out,buf,TRUE)==0) ||
               (file_write_line(out,dt,TRUE)==0)
              )
           {
            file_close(&index);
            file_close(&out);
            error_report_string1(token_get("E22"),to);
            break;
           }
           done=TRUE;
          }
         }
         if (!done)  /* add at end */
         {
          char dt[256];
          sprintf(buf,"%s\n",nntp_strip_subject(message_get_subject()));
          strcpy(buf1,message_get_from());
          smtp_get_user(buf1,dt);
          sprintf(buf1,"+%i %i %i %i %s@%s\n",first-1,nntp_get_time(),start,end,dt,mail_domain);
          sprintf(dt,"=%s\n",message_get_date());
          if (
              (file_write_line(out,buf,FALSE)==0)  ||
              (file_write_line(out,buf1,FALSE)==0) ||
              (file_write_line(out,dt,FALSE)==0)
             )
          {
           file_close(&index);
           file_close(&out);
           error_report_string1(token_get("E22"),to);
           continue;
          }
         }
         /* Now close and copy new index file into place */
         file_close(&out);
         file_close(&index);
         sprintf(buf,"%s.News.Index.%s",po_path,fn);
         file_delete(buf);
         sprintf(buf1,"%s.News.Index.%sz",po_path,fn);
         file_rename(buf1,buf);
        }
       }
      }
//      break; /* active file search */
     }
     {
      char buf[256];
      sprintf(buf,"%i %i %i %s %s",date,first,last,ng,fn);
      file_write_line(active_f_out,buf,TRUE);
DEBUG((dbg,"Write %s",buf));
     }
     sprintf(buf,"%s.News",po_path);
     if (
         (total_news_size<(news_limit*1024*1024)) &&
         (total_news_size>(news_limit*1024*1024)-(news_limit*1024*1024)/10)
        )
        deliver_warning(token_get("SW02"));

    }
    file_close(&active_f);
    file_close(&active_f_out);
    file_delete("<MailServ$Dir>.Active");
    file_rename("<MailServ$Dir>.ActiveZ","<MailServ$Dir>.Active");
   }
  }
 }
 message_close_file();
 file_delete(pb);
}

static int dl_file=0;
static void build_dl(Object *o)
{
 char buf[256];
 strcpy(buf,o->name);
 file_write_line(dl_file,buf,TRUE);
}

static void do_deliver(int f,char *pb,int do_out)
{
 char buf[256],group[256],www[256],key[256];
 char *to;
 char domain[256];
 int to_type;
 int remote=FALSE;
 int local_from;
 extern int mail_protocol;
 extern char pop3_user[];
 //extern char pop_server[];

 file_close(&f);
 message_init_file(pb);
 /* For every message (should only ever be one) */
 while (message_load_next())
 {
  int mime=(message_get_flags() & MESSAGE_FLAG_MIME);
  int first=1;

  smtp_get_domain(message_get_from(),domain);
  local_from=strcmpci(domain,"localhost");
  if (local_from)
  {
   smtp_get_user(message_get_from(),domain);
   /*DEBUG((dbg,domain));*/
   if (!user_find(domain,buf,group,buf,buf,www,key))
   {
    local_from=0;
    if (!strcmpci(domain,"MailServer"))
    {
     char buf[256];
     sprintf(buf,token_get("FD09"),message_get_from());
     log_report(LOG_INFO,buf);
     local_deliver_fail(message_get_from(),buf,FAIL_ANY);
     continue;
    }
   }
  }
  /* Look at every recepient */
  message_reset_to();
  while(message_get_to(&to,&to_type))
  {
   int is_dl=FALSE,dl_f;
   char dl_buf[256];
   char fn[256];
   if (find_dl(to,fn))
   {
    dl_f=file_open(fn,TRUE);
    if (dl_f) is_dl=TRUE;
   }
   else if (find_group(to))
   {
    dl_file=file_open_create("<MailServ$Dir>.DL",ACCESS_RW);
    if (dl_file)
    {
     database_find_all_by_attribute("user","group",to,subgroup,build_dl);
     file_close(&dl_file);
    }
    dl_f=file_open("<MailServ$Dir>.DL",TRUE);
    if (dl_f) is_dl=TRUE;
   }

   do
   {
    if (is_dl)
    {
     dl_buf[0]='#';
     to=dl_buf;
     while ((dl_buf[0]=='#') && (is_dl)) is_dl=file_get_line(dl_f,dl_buf,FALSE);
     if (!is_dl)
     {
      file_close(&dl_f);
      break;
     }
    }
    if (local_from)
    {
     char full_to[2048];
     char user[256],domain[256];
     smtp_get_domain(to,domain);
     smtp_get_user(to,user);
     sprintf(full_to,"%s@%s",user,domain);
     DEBUG((dbg,"Full To: is %s",full_to));
     if (!check_allowed_address(FALSE,full_to,group))
     {
      sprintf(buf,token_get("FD08"),to,message_get_from());
      local_deliver_fail(message_get_from(),buf,FAIL_CENSORED);
      continue;
     }
    }
    DEBUG((dbg,"Check allowed %s %i %i",to,check_allowed_address(FALSE,to,group),local_from));
    /* Is it a local one ? */
    smtp_get_domain(to,domain);
 //DEBUG((dbg,"%s %s %i",domain,mail_domain,strcmpci(domain,mail_domain)));
    if (strcmpci(domain,"localhost") || (!do_out))     /* local to server */
    {
     char buf[256];
     local_deliver(to,mime && !first);
     first=0;
     sprintf(buf,"%s.Mail",po_path);
     if (
         (total_mail_size<(mail_limit*1024*1024)) &&
         (total_mail_size>(mail_limit*1024*1024)-(mail_limit*1024*1024)/10)
        )
        deliver_warning(token_get("SW01"));
    }
    else remote=TRUE;
   } while (is_dl);
  }
  if (remote && do_out) /* Append message to outgoing file */
  {
    int out=file_open_append("<MailServ$Dir>.Outgoing",TRUE);
    int in=file_open("<MailServ$Dir>.Message",TRUE);
    if ((in==0) || (out==0))
    {
     file_close(&in);
     file_close(&out);
     error_report_string(token_get("ER31"));
     return;
    }

  /* Look at every recepient */
  message_reset_to();
  while(message_get_to(&to,&to_type))
  {
   int is_dl=FALSE,dl_f;
   char dl_buf[256];
   char fn[256];
   if (find_dl(to,fn))
   {
    dl_f=file_open(fn,TRUE);
    if (dl_f) is_dl=TRUE;
   }
   else if (find_group(to)) continue;

   do
   {
    if (is_dl)
    {
     dl_buf[0]='#';
     to=dl_buf;
     while ((dl_buf[0]=='#') && (is_dl)) is_dl=file_get_line(dl_f,dl_buf,FALSE);
     if (!is_dl)
     {
      file_close(&dl_f);
      break;
     }
    }
    /* Is it a local one ? */
    smtp_get_domain(to,domain);
    if (strcmpci(domain,"localhost")) continue;
    else /* A remote address */
    {
     char buf[1024];
     sprintf(buf,"RCPT TO: %s \n",to);
     file_write_line(out,buf,FALSE);
    }
   } while (is_dl);
  }
  buf[0]='.';
  while (file_get_line(in,buf+1,TRUE)) /* Believe that I can do any mail header processing here RCE 971202 */
  {
     char *l=(buf[1]=='.')?buf:buf+1;
     /* insert POP3 stuff here */
     if (!strncmp(l,"From: ",6))
     {
       char *ptr;

       ptr = strstr(l,"<");
       if (ptr == NULL)
       {
         ptr = l + 6*sizeof(char);
       }

       if (mail_protocol==MAIL_PROTOCOL_POP3) /* get rid of @localhost & add Reply-To: field */
       {
         sprintf(ptr,"<%s@%s>",pop3_user,mail_domain);
         file_write_line(out,l,TRUE);
         sprintf(l,"Sender: \"InterTalk MailServer\" <%s@%s>",pop3_user,mail_domain);
         file_write_line(out,l,TRUE);
         sprintf(l,"Reply-To: <%s@%s>",pop3_user,mail_domain);
       }
       else
       {
         char tmp[256];

         smtp_get_user(message_get_from(),tmp);
         /* SMTP so change localhost to mail_domain */
         sprintf(ptr,"<%s@%s>",tmp,mail_domain);
       }
     }
     else if (!strncmp(l,"Return-Receipt-To: ",19))
     {
       char tmp[256];

       smtp_get_user(message_get_from(),tmp);
       if (mail_protocol==MAIL_PROTOCOL_POP3)
       {
         /* add POP3 user details and a comment of real target */
         sprintf(l,"Return-Receipt-To: <%s@%s>",pop3_user,mail_domain);
       }
       else
       {
         /* SMTP so change localhost to mail_domain */
         sprintf(l,"Return-Receipt-To: <%s@%s>",tmp,mail_domain);
       }
     }
     if (file_write_line(out,l,TRUE)==0)
     {
       file_close(&in);
       file_close(&out);
       error_report_string(token_get("ER31"));
       return;
     }
  }
  file_write_line(out,".\n",FALSE);
  file_close(&in);
  file_close(&out);
  pending_messages++;
  if (pending_messages==1) wimp_create_baricon_fat();
  } /* endif (remote && do_out) - Append message to outgoing file */
  remote=0;
 }
 message_close_file();
 file_delete(pb);
}

static void do_mail_loaded(int f,char *pb)
{
#if 0
 char user[256];
 char pass[256];
 char group[256];
 char name[256];
 char file[256];
 char www[256];
 char key[256];

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (user_find(user,pass,group,name,file,www,key)==0)
    )
 {
  file_close(&f);
  file_delete(pb);
  return;
 }
#endif
 file_close(&f);
 file_delete(pb);
#if 0
 /* Copy index file stamp to data file  */
 sprintf(pass,"%s.Mail.Index.%s",po_path,file);
 sprintf(group,"%s.Mail.Data.%s",po_path,file);
 file_stamp(pass,file_get_stamp(pass));
#endif
}

static void do_mail_delete(int f,char *pb)
{
 char user[256];
 char which[256];
 char pass[256];
 char group[256];
 char name[256];
 char file[256];
 char www[256];
 char key[256];
 int i,in,out,pos;
 int end,flags,cc,to,att;
 int old_data_stamp;
 int old_index_stamp;

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (file_get_line(f,which,FALSE)==0) ||
     (user_find(user,pass,group,name,file,www,key)==0)
    )
 {
  file_close(&f);
  file_delete(pb);
  return;
 }
 sscanf(which,"%i",&pos);
//DEBUG((dbg,"%i",pos));
 /* Open index file and mark as deleted */
 sprintf(pass,"%s.Mail.Data.%s",po_path,file);
 old_data_stamp=file_get_stamp(pass);
 sprintf(pass,"%s.Mail.Index.%s",po_path,file);
 old_index_stamp=file_get_stamp(pass);
 sprintf(group,"%s.Mail.Index.%sz",po_path,file);
 in=file_open(pass,TRUE);
 if (in==0)
 {
  file_close(&f);
  file_delete(pb);
  return;
 }
 out=file_open_create(group,ACCESS_DIR);
 if (out==0)
 {
  file_close(&f);
  file_close(&in);
  file_delete(pb);
  return;
 }
 while (1)
 {
  char l1[256],l2[256],l3[256];
  int p,t;
  if ((file_get_line(in,l1,FALSE)==0) ||
      (file_get_line(in,l2,FALSE)==0) ||
      (file_get_line(in,l3,FALSE)==0)
     )
  {
   file_close(&f);
   file_close(&in);
   file_close(&out);
   file_delete(pb);
   file_delete(pass);
   file_stamp(group,old_index_stamp);
   file_rename(group,pass);
   sprintf(group,"%s.Mail.Data.%s",po_path,file);
   file_stamp(pass,old_index_stamp);
   file_stamp(group,old_data_stamp);
   return;
  }
  sscanf(l3,"%i %i %i %i %i %i %i",&t,&p,&end,&flags,&cc,&to,&att);
  if (p!=pos)
  {
   file_write_line(out,l1,TRUE);
   file_write_line(out,l2,TRUE);
   file_write_line(out,l3,TRUE);
  }
   for (i=0;i<cc+to;i++)
   {
    char buf[256];
    if (file_get_line(in,buf,FALSE))
    {
     if (p!=pos) file_write_line(out,buf,TRUE);
    }
   }
   for (i=0;i<att*2;i++)
   {
    char buf[256];
    if (file_get_line(in,buf,FALSE))
    {
#if 1
    if ((i==1) && (p==pos))
    {
     char buf1[256],*d;
     _kernel_swi_regs r;
     r.r[0]=(int)buf1;
     sprintf(buf1,"Wipe %s.Mail.Data.%s ",po_path,buf);
     d=buf1+strlen(buf1);
     while (*d!='.') d--;
     *d=0;
     strcat(buf1," ~CFR~V");
//error_display(buf1);
     _kernel_swi(OS_CLI,&r,&r);
    }
#endif
     if (p!=pos) file_write_line(out,buf,TRUE);
    }
   }
 }
}


static void do_mail_quit(int f,char *pb)
{
 char user[256];
 char pass[256];
 char group[256];
 char name[256];
 char file[256];
 char www[256];
 char key[256];
 char datafile[256],olddatafile[256];
 int in,out,datastamp,indexstamp,dataout,datain,oldstart;
 int time,start,end,flags,cc,to,att;
 int size,i;

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (user_find(user,pass,group,name,file,www,key)==0)
    )
 {
  file_close(&f);
  file_delete(pb);
  return;
 }

 /* Open index file and mark as deleted */
 sprintf(pass,"%s.Mail.Index.%s",po_path,file);
 indexstamp=file_get_stamp(pass);
 sprintf(group,"%s.Mail.Index.%sz",po_path,file);
 sprintf(olddatafile,"%s.Mail.Data.%s",po_path,file);
 datastamp=file_get_stamp(datafile);
 sprintf(datafile,"%s.Mail.Data.%sz",po_path,file);
 in=file_open(pass,TRUE);
 if (in==0)
 {
  file_close(&f);
  file_delete(pb);
  return;
 }
 out=file_open_create(group,ACCESS_DIR);
 if (out==0)
 {
  file_close(&f);
  file_close(&in);
  file_delete(pb);
  return;
 }
 dataout=file_open_create(datafile,ACCESS_DIR);
 if (dataout==0)
 {
  file_close(&f);
  file_close(&in);
  file_close(&out);
  file_delete(pb);
  return;
 }
 datain=file_open(olddatafile,TRUE);
 if (dataout==0)
 {
  file_close(&f);
  file_close(&in);
  file_close(&out);
  file_delete(pb);
  return;
 }
 while (1)
 {
  char l1[256],l2[256],l3[256];
  if ((file_get_line(in,l1,FALSE)==0) ||
      (file_get_line(in,l2,FALSE)==0) ||
      (file_get_line(in,l3,FALSE)==0)
     )
  {
   file_close(&f);
   file_close(&in);
   file_close(&out);
   file_close(&dataout);
   file_close(&datain);
   file_delete(pb);
   file_delete(pass);
   file_rename(group,pass);
   file_stamp(pass,indexstamp);
   file_delete(olddatafile);
   file_rename(datafile,olddatafile);
   file_stamp(datafile,datastamp);
   return;
  }
//DEBUG((dbg,"l1=%s",l1));
//DEBUG((dbg,"l2=%s",l2));
//DEBUG((dbg,"l3=%s",l3));
  sscanf(l3,"%i %i %i %i %i %i %i",&time,&start,&end,&flags,&cc,&to,&att);
  oldstart=start;
  end=end-start+file_get_pos(dataout);
  start=file_get_pos(dataout);
  /* Copy data from in to out */
  size=end-start;
//DEBUG((dbg,"Size = %i",size));
  while (size>0)
  {
   char buf[256];
   int bytes=size>256?256:size;
   file_get_bytes(datain,buf,oldstart,bytes);
   file_put_bytes(dataout,buf,bytes);
   size-=bytes;
   oldstart+=bytes;
  }
  file_write_line(out,l1,TRUE);
  file_write_line(out,l2,TRUE);
  sprintf(l3,"%i %i %i %i %i %i %4i",time,start,end,flags,cc,to,att);
  file_write_line(out,l3,TRUE);
//DEBUG((dbg,"CC+TO=%i",cc+to));
  for (i=0;i<cc+to+att*2;i++)
  {
   char buf[256];
   if (file_get_line(in,buf,FALSE))
   {
//DEBUG((dbg,"%i buf=%s",i,buf));
    file_write_line(out,buf,TRUE);
   }
  }
 }
}

static void do_read_mail(int f,char *pb)
{
 char user[256];
 char which[256];
 char pass[256];
 char group[256];
 char name[256];
 char file[256];
 char www[256];
 char key[256];
 char datafile[256];
 int i,in,out,pos;
 int end,flags,cc,to,att;
 int p,t;
 int indexstamp,datastamp;

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (file_get_line(f,which,FALSE)==0) ||
     (user_find(user,pass,group,name,file,www,key)==0)
    )
 {
  file_close(&f);
  file_delete(pb);
  return;
 }
 sscanf(which,"%i",&pos);
//DEBUG((dbg,"%i",pos));
 /* Open index file and mark as deleted */

 sprintf(datafile,"%s.Mail.Data.%s",po_path,file);
 datastamp=file_get_stamp(datafile);


 sprintf(pass,"%s.Mail.Index.%s",po_path,file);
 indexstamp=file_get_stamp(pass);
 sprintf(group,"%s.Mail.Index.%sz",po_path,file);
 in=file_open(pass,TRUE);
 if (in==0)
 {
  file_close(&f);
  file_delete(pb);
  return;
 }
 out=file_open_create(group,ACCESS_DIR);
 if (out==0)
 {
  file_close(&f);
  file_close(&in);
  file_delete(pb);
  return;
 }
 while (1)
 {
  char l1[256],l2[256],l3[256];
  if ((file_get_line(in,l1,FALSE)==0) ||
      (file_get_line(in,l2,FALSE)==0) ||
      (file_get_line(in,l3,FALSE)==0)
     )
  {
   file_close(&f);
   file_close(&in);
   file_close(&out);
   file_delete(pb);
   file_delete(pass);
   file_stamp(group,indexstamp);
   file_rename(group,pass);
   file_stamp(pass,indexstamp);
   sprintf(group,"%s.Mail.Data.%s",po_path,file);
   file_stamp(group,datastamp);
   return;
  }
  sscanf(l3,"%i %i %i %i %i %i %i",&t,&p,&end,&flags,&cc,&to,&att);
//DEBUG((dbg,"p,pos= %i %i",p,pos));
  if (p!=pos)
  {
   file_write_line(out,l1,TRUE);
   file_write_line(out,l2,TRUE);
   file_write_line(out,l3,TRUE);
  } else
  {
   flags |= MAIL_FLAG_READ;
   sprintf(l3,"%i %i %i %i %i %i %4i",t,p,end,flags,cc,to,att);
   file_write_line(out,l1,TRUE);
   file_write_line(out,l2,TRUE);
   file_write_line(out,l3,TRUE);
  }
  for (i=0;i<cc+to+att*2;i++)
  {
   char buf[256];
   if (file_get_line(in,buf,FALSE))
   {
//DEBUG((dbg,"%i buf=%s",i,buf));
    file_write_line(out,buf,TRUE);
   }
  }
 }
}

static void add_read(read_entry **r,int first,int last)
{
 read_entry *e=*r;
 while (e)
 {
  if (last==e->first-1)
  {
   e->first=first;
   return;
  }
  if (first==e->last+1)
  {
   e->last=last;
   return;
  }
  e=e->next;
 }
 e=malloc(sizeof(read_entry));
 if (e==0) return;
 e->next=*r;
 e->first=first;
 e->last=last;
 *r=e;
}

static void free_read(read_entry *e)
{
 if (e==NULL) return;
 free_read(e->next);
 free(e);
}

static void do_read_news(int f,char *pb)
{
 char user[256];
 char which[256];
 char pass[256];
 char group[256];
 char newsgroup[256];
 char name[256];
 char file[256];
 char buf[256];
 char www[256];
 char key[256];
 int  in,out,eof;
 read_entry *read=NULL,*e;

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (file_get_line(f,newsgroup,FALSE)==0) ||

     (user_find(user,pass,group,name,file,www,key)==0)
    )
 {
  file_close(&f);
  file_delete(pb);
  return;
 }


  /* Open index file and mark as read */
  sprintf(pass,"%s.News.Users.%s",po_path,file);
  sprintf(group,"%s.News.Users.%sz",po_path,file);
  in=file_open(pass,TRUE);
  if (in==0)
  {
   file_close(&f);
   file_delete(pb);
   return;
  }
  out=file_open_create(group,ACCESS_DIR);
  if (out==0)
  {
   file_close(&f);
   file_close(&in);
   file_delete(pb);
   return;
  }
  while (1)
  {
   char ng[256];
   if (file_get_line(in,buf,FALSE)==0)
   {
    file_close(&f);
    file_close(&in);
    file_delete(pb);
    return;
   }
   if (file_write_line(out,buf,TRUE)==0)
   {
    file_close(&f);
    file_close(&in);
    file_delete(pb);
    return;
   }
   if (buf[0]=='+') continue;
   sscanf(buf,"%s",ng);
   if (strcmpci(newsgroup,ng)) break;
  }

  while (file_get_line(f,which,FALSE))
  {
   int first,last;
   if (sscanf(which,"%i %i",&first,&last)!=2) continue;
   add_read(&read,first,last);
  }

  eof=FALSE;
  while(1)
  {
   int first,last;
   if (!file_get_line(in,buf,FALSE))
   {
    eof=TRUE;
    break;
   }
   if (buf[0]!='+') break;
   if (sscanf(buf,"+%i %i",&first,&last)!=2) continue;
   add_read(&read,first,last);
   buf[0]='0';
  }

  /* Now write all entries to the file */

  for (e=read;e;e=e->next)
  {
   char buf[256];
   sprintf(buf,"+%i %i",e->first,e->last);
   file_write_line(out,buf,TRUE);
  }

  /* and now write rest of file */
  if (!eof)
  {
   do
   {
    file_write_line(out,buf,TRUE);
   } while (file_get_line(in,buf,FALSE));
  }
  file_close(&in);
  file_close(&out);
  file_close(&f);
  file_delete(pb);
  file_delete(pass);
  file_rename(group,pass);
  free_read(read);
}


static void do_login_command(int f,char *pb)
{
 char user[256];
 char password[256];
 char pass[256];
 char group[256];
 char name[256];
 char file[256];
 char www[256];
 char key[256];
 char fbuf[8096];
 int allowed=TRUE;

//error_display("login");

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (file_get_line(f,password,FALSE)==0) ||
     (user_find(user,pass,group,name,file,www,key)==0)
#ifdef SU
#else
     ||
     (strcmpci(pass,password)==0)
#endif
    )
 {
  file_close(&f);
  file_delete(pb);
  return;
 }
 file_close(&f);

//error_display("login ok");

/* Remove unwanted newsgroups */

 sprintf(fbuf,"%s.News.Users.%s",po_path,file);
 f=file_open(fbuf,TRUE);
//DEBUG((dbg,"%s %i",fbuf,f));
 if (f)
 {
  char buf[256],ng[256];
  int i,f1;

  sprintf(buf,"%s.News.Users.%sz",po_path,file);
  f1=file_open_create(buf,ACCESS_DIR);
//DEBUG((dbg,"%s %i",buf,f1));
  if (f1)
  {
   while (file_get_line(f,buf,FALSE))
   {
    if (buf[0]!='+')
    {
     sscanf(buf,"%s %i",ng,&i);
     if (!check_allowed(ng,group)) allowed=FALSE; else allowed=TRUE;
    }
    if (allowed) file_write_line(f1,buf,TRUE);
   }
   file_close(&f1);
   file_close(&f);
   sprintf(fbuf,"%s.News.Users.%s",po_path,file);
//DEBUG((dbg,"%s",fbuf));
   file_delete(fbuf);
   sprintf(buf,"%s.News.Users.%sz",po_path,file);
   file_rename(buf,fbuf);
//DEBUG((dbg,"%s %s",buf,fbuf));
  }
  else file_close(&f);
 }
 sprintf(fbuf,"%s\n%s\n%s\n\n",name,file,mail_domain);
 if (file_save(pb,fbuf,strlen(fbuf),0xffd)==0)
 {
  error_report_string(token_get("ER32"));
  file_close(&f);
  file_delete(pb);
 }
//error_display("file saved");
}

extern int mail_message_limit;

/* now sends domain as 'localhost' so that local mail can be identified */
static void do_login200_command(int f,char *pb)
{
 char user[256],u1[256];
 char password[256];
 char password1[256];
 char pass[256];
 char group[256];
 char name[256];
 char file[256];
 char www[256];
 char key[256];
 char local_news_key[256];
 char message_limit[256];
 char fbuf[8096];
 char attrbuf[8096];
 char *c;
 char local_host[]="localhost";
 int allowed=TRUE;
 Object *u;

 strcpy(local_news_key,news_key);
 sprintf(message_limit,"%i",mail_message_limit);

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (file_get_line(f,password,FALSE)==0) ||
     (file_get_line(f,password1,FALSE)==0) ||
     (strcpy(u1,user),user_find(u1,pass,group,name,file,www,key)==0)     )
 {
  file_close(&f);
  file_delete(pb);
  return;
 }

#ifdef SU
 if (strcmpci(user,"<SingleUser>")) strcpy(pass,"nopassword");
 strcpy(user,u1);
#endif
 for (c=pass;*c;c++) *c=tolower(*c);
 pass_pos=0;
 decode_data(password,strlen(password),pass,TRUE,FALSE);
 pass_pos=0;
 decode_data(password1,strlen(password1),password,TRUE,TRUE);
 strcpy(current_pass,password1);
 pass_pos=0;
 encode_line(key,TRUE,TRUE);
 strcpy(current_pass,password1);
 pass_pos=0;
 encode_line(local_news_key,TRUE,TRUE);

 attrbuf[0]=0;
 u=database_find("user",user);
 while (file_get_line(f,fbuf,FALSE))
 {
  AttributeValue *v;
  v=database_get_attribute(u,fbuf,FALSE);
  if (v) strcat(attrbuf,v->value);
  strcat(attrbuf,"\n");
 }
 file_close(&f);

//error_display("login ok");

/* Remove unwanted newsgroups */

 sprintf(fbuf,"%s.News.Users.%s",po_path,file);
 f=file_open(fbuf,TRUE);
 if (f)
 {
  char buf[256],ng[256];
  int i,f1;

  sprintf(buf,"%s.News.Users.%sz",po_path,file);
  f1=file_open_create(buf,ACCESS_DIR);
  if (f1)
  {
   while (file_get_line(f,buf,FALSE))
   {
    if (buf[0]!='+')
    {
     sscanf(buf,"%s %i",ng,&i);
     if (!check_allowed(ng,group)) allowed=FALSE; else allowed=TRUE;
    }
    if (allowed) file_write_line(f1,buf,TRUE);
   }
   file_close(&f1);
   file_close(&f);
   sprintf(fbuf,"%s.News.Users.%s",po_path,file);
   file_delete(fbuf);
   sprintf(buf,"%s.News.Users.%sz",po_path,file);
   file_rename(buf,fbuf);
  }
  else file_close(&f);
 }
  sprintf(fbuf,"%s\n%s\n%s\n%s\n%s\n%s%s%s\n%s\n",user,
             name,file,local_host,password,key,local_news_key,message_limit,attrbuf);
 if (file_save(pb,fbuf,strlen(fbuf),0xffd)==0)
 {
  error_report_string(token_get("ER32"));
  file_close(&f);
  file_delete(pb);
 }
//error_display("file saved");
}

static void do_password_command(int f,char *pb)
{
 char user[256];
 char password[256];
 char password1[256];
 char num[256];
 char pass[256];
 char group[256];
 char name[256];
 char file[256];
 char www[256];
 char key[256];
 Object *u;
 AttributeValue *v;

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (file_get_line(f,num,FALSE)==0) ||
     (file_get_line(f,password,FALSE)==0) ||
     (file_get_line(f,password1,FALSE)==0) ||
     (user_find(user,pass,group,name,file,www,key)==0)     )
 {
  file_close(&f);
  file_delete(pb);
  return;
 }

 decode_data(num,strlen(num),key,TRUE,TRUE);   /* Get num */
 decode_data(password,strlen(password),num,TRUE,TRUE);
 decode_data(password1,strlen(password1),num,TRUE,TRUE);

 if (!strcmpci(password,pass))
 {
  file_close(&f);
  file_delete(pb);
  return;
 }

 u=database_find("user",user);
 v=database_get_attribute(u,"Password",FALSE);
 if (v) database_remove_attribute_value(u,"Password",v->value);
 database_add_attribute(u,"Password",password1,TRUE,FALSE);
 file_close(&f);
 database_save("<MailServ$Dir>.Database");    //ne
}

static void do_add_attr(int f,char *pb)
{
 char user[256];
 char password[256];
 char pass[256];
 char group[256];
 char name[256];
 char file[256];
 char www[256];
 char key[256];
 char fbuf[8096];
 Object *u;

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (file_get_line(f,password,FALSE)==0) ||
     (user_find(user,pass,group,name,file,www,key)==0)
#ifdef SU
#else
     ||
     (strcmpci(pass,password)==0)
#endif
    )
 {
  file_close(&f);
  return;
 }

 u=database_find("user",user);
 while (file_get_line(f,fbuf,FALSE))
 {
  char *c=strchr(fbuf,' ');
  if (!c) continue; else *c++=0;
  database_add_attribute(u,fbuf,c,TRUE,FALSE);
 }
 file_close(&f);
 file_delete(pb);
}


static void do_set_attr(int f,char *pb)
{
 char user[256];
 char password[256];
 char pass[256];
 char group[256];
 char name[256];
 char file[256];
 char fbuf[8096];
 char www[256];
 char key[256];
 Object *u;

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (file_get_line(f,password,FALSE)==0) ||
     (user_find(user,pass,group,name,file,www,key)==0)
#ifdef SU
#else
     ||
     (decode_data(password,strlen(password),key,TRUE,TRUE) , (strcmpci(pass,password)==0))
#endif
    )
 {
  file_close(&f);
  return;
 }

 u=database_find("user",user);
 while (file_get_line(f,fbuf,FALSE))
 {
  AttributeValue *v,*v1;
  char *c=strchr(fbuf,' ');
  if (!c) continue; else *c++=0;

  v=database_get_attribute(u,fbuf,FALSE);  /* Delete any existing attributes */
  while (v)
  {
   v1=v->next;
   database_remove_attribute_value(u,fbuf,v->value);
   v=v1;
  }
  database_add_attribute(u,fbuf,c,TRUE,FALSE);
 }
 file_close(&f);
 file_delete(pb);
}


/* re-organised to save alot of space  */


void do_save_hotlist_or_history( int f, char *pb, char *hot_his, int filetype)
{
 char user[256];
 char pass[256];
 char group[256];
 char name[256];
 char file[256];
 char buf[1024];
 char www[256];
 char key[256];
 int f1;

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (user_find(user,pass,group,name,file,www,key)==0)
    )
 {
  file_close(&f);
  file_delete(pb);
  return;
 }

 sprintf(buf,"%s.Web.%s.%s",po_path,file,hot_his );
 f1=file_open_create(buf,ACCESS_DIR);
 if (f1)
 {
  while (file_get_line(f,buf,FALSE)) file_write_line(f1,buf,TRUE);
 }
 else /* DNW - added this bit so that if the directory does not exist it is created !  */
 	{
 	file_close(&f1);
 	sprintf(buf,"Web.%s",file);
 	if ( (file_create_multi_dirs( po_path, buf)) == 1 )   /* makes the directorys !  */
 		{
 		sprintf(buf,"%s.Web.%s.%s",po_path,file,hot_his);
		f1=file_open_create(buf,ACCESS_DIR);
		if (f1)
			{
			while (file_get_line(f,buf,FALSE)) file_write_line(f1,buf,TRUE);
			}
		}
	}

 sprintf(buf,"%s.Web.%s.%s",po_path,file, hot_his);

 file_close(&f);
 file_close(&f1);
 file_delete(pb);

 {
  _kernel_swi_regs r;
  r.r[0]=18;
  r.r[1]=(int)buf;
  r.r[2]=filetype;
  _kernel_swi(OS_File,&r,&r);
 }
// _swix(OS_File, _INR(0,2), 18, buf, filetype);


}

static void do_save_hotlist(int f,char *pb)
{
do_save_hotlist_or_history( f, pb, "Hotlist", 0xfaf);
return;
}

static void do_save_history(int f,char *pb)
{
do_save_hotlist_or_history( f, pb, "History", 0xFFD);
return;
}


static void do_del_attr(int f,char *pb)
{
 char user[256];
 char pass[256];
 char password[256];
 char group[256];
 char name[256];
 char file[256];
 char fbuf[8096];
 char www[256];
 char key[256];
 Object *u;

 if (
     (file_get_line(f,user,FALSE)==0) ||
     (file_get_line(f,password,FALSE)==0) ||
     (user_find(user,pass,group,name,file,www,key)==0)
#ifdef SU
#else
     ||
     (decode_data(password,strlen(password),key,TRUE,TRUE) , (strcmpci(pass,password)==0))
#endif
    )
 {
  file_close(&f);
  return;
 }

 u=database_find("user",user);
 while (file_get_line(f,fbuf,FALSE))
 {
  AttributeValue *v,*v1;

  v=database_get_attribute(u,fbuf,FALSE);  /* Delete any existing attributes */
  while (v)
  {
   v1=v->next;
   database_remove_attribute_value(u,fbuf,v->value);
   v=v1;
  }
 }
 file_close(&f);
 file_delete(pb);
}

static void do_mercury_command(int f,char *command,char *pb)
{
 if (strcmpci("Login250",command)) do_login200_command(f,pb);
 else if (strcmpci("Login",command)) do_login_command(f,pb);
 else if (strcmpci("Password",command)) do_password_command(f,pb);
 else if (strcmpci("MailDelete",command)) do_mail_delete(f,pb);
 else if (strcmpci("MailLoaded",command)) do_mail_loaded(f,pb);
 else if (strcmpci("ReadMail",command)) do_read_mail(f,pb);
 else if (strcmpci("ReadNews",command)) do_read_news(f,pb);
 else if (strcmpci("SetAttr",command)) do_set_attr(f,pb);
 else if (strcmpci("AddAttr",command)) do_add_attr(f,pb);
 else if (strcmpci("DelAttr",command)) do_del_attr(f,pb);
 else if (strcmpci("Post",command)) do_post_news(f,pb);
 else if (strcmpci("Quit",command)) do_mail_quit(f,pb);
 else if (strcmpci("SaveHotlist",command)) do_save_hotlist(f,pb);
 else if (strcmpci("SaveHistory",command)) do_save_history(f,pb);
 else
 {
  file_close(&f);
  file_delete(pb);
 }
}

/*
******************************************************************
 Exported functions
******************************************************************
*/


void encode_line(char *buf,int keepnl,int magic)
{
 int i,len;
 char p;
 char *password=current_pass;

 len=strlen(buf);
 buf[len]='\n';
 buf[len+1]=0;

#if 0
#else
 for (i=0;i<=len;i++)
 {
  p=password[pass_pos];
  if ( (!keepnl) || ((buf[i]!='\n') && ((buf[i]^p)!='\n')))
  {
   if ((buf[i]!=p) && (buf[i] !=0))
      buf[i]^=p;
  }
  pass_pos++;
  if (password[pass_pos]<32)
  {
   unsigned int r1,r2,tmp;
   if (magic)
   {
    sscanf(password,"%8x%8x",&r1,&r2);
    tmp = r2 &  1;
    r2  = r2 >> 1;
    if (r1 & 1) r2 |= (1U<<31);
    r1  = r1 >> 1;
    if (tmp) r1 |= (1U<<31);
    sprintf(password,"%08x%08x",r1,r2);
   }
   pass_pos=0;
  }
 }
#endif
}


void scan(char *path,int do_out)
{
 _kernel_swi_regs r;
 _kernel_oserror *e;
 int filebuf[100];
 int f;


  r.r[4]=0;

 while (1)
 {
  if (r.r[4]==-1) return;
  r.r[0]=10;
  r.r[1]=(int)path;
  r.r[2]=(int)filebuf;
  r.r[3]=1;
  r.r[5]=100*sizeof(int);
  r.r[6]=(int)"*";
  e=_kernel_swi(OS_GBPB,&r,&r);
  if (e)
  {
   if (!error_reported) error_display(e->errmess);
   error_reported=TRUE;
   return;
  }
  error_reported=FALSE;
  if (r.r[3]==0)
  {
   if (do_out)
   {
//    char buf[256];
    int n=1;
    get_icon(connection_handle,33,&n);
//    sprintf(buf,"Pending %i config %i",pending_messages,n);
//    error_display(buf);
    if ((pending_messages>=n) && (!script_active) && (!smtp_state)
#if 0
        && (!mail_in_state)
        && (!nntp_state)
#endif
       )
     {
      if (!check_connected())
      {
       do_connect( -2 );  /* DNW - explained in do_connect  */
      }
      else
      if (!smtp_state)
      {
       smtp_deliver(smtp_server,po_path,mail_domain);
       smtp_state=smtp_process_out();
      }
     }
     else
     if ((pending_messages) && check_connected() && (!script_active) )
     {
       smtp_deliver(smtp_server,po_path,mail_domain);
       smtp_state=smtp_process_out();
     }
   }
   return;  /* Nothing to load */
  }
  if (filebuf[4]==0) return; /* Ah??? notfound */

  if (filebuf[4]==1) /* a file */
  {
   char file[256];
   char buf[256];
   char command[256];
   int pos;
   sprintf(file,"%s.%s",path,(char *)(filebuf+5));
//DEBUG((dbg,"File is %s",file));
   f=file_open(file,FALSE);
   if (f==0)
   {
    continue;   /* try next file */
   }
//DEBUG((dbg,"File opened"));
   file_get_line(f,buf,FALSE);
   if (!hdr_get_command(buf,command,&pos)) /* Not a header line ??? */
   {
    file_close(&f);
//    file_delete(file);
    continue;  /* try next one */
   } else
   {
    if (strcmpci("X-Mercury-Command",command))
    {
     do_mercury_command(f,buf+pos,file);
//     return;
    }
    else do_deliver(f,file,do_out);
   }
  }
 }
}
