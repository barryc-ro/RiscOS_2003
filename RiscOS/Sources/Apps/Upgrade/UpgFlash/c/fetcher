/* This code ensures that the compressed OS image is held in RAM before
programming commences.

There are two cases to consider.

1) The image is to be loaded from Zip drive
2) The image is already in memory, and has been passed as a memory pointer.

in case 1) the function fetch_image_from_zip below fetches a compressed image
from a zip disk into a RAM buffer, and returns a pointer to it back to the
main program.

in case 2) the function get_memory_pointer simply returns the pointer to the
memory location of the already loaded image.

*/



#include <stdio.h>
#include <stdlib.h>

#include "kernel.h"
#include "swis.h"

#include "fetcher.h"



extern int image_length;  // size of input file in bytes.
extern int filing_system; // filing system type



/* This function decides which type of fetch is going on (RAM/ZIP) and
executes the correct function depending
*/
volatile unsigned int *fetch_image(char *filename)
{
  volatile unsigned int *start_of_buffer;


  if (filing_system == MEMORY)  start_of_buffer = get_memory_ptr(filename);

  if (filing_system == ZIPFS)  start_of_buffer  = fetch_image_from_zip(filename);


  return(start_of_buffer);

}



/* If we are doing a ZIP fetch, this function reads in the image file into a RAM buffer ready to be programmed.   It returns a pointer to the start of the
buffer.
*/
volatile unsigned int *fetch_image_from_zip(char *filename)
{
  _kernel_swi_regs regs;
  _kernel_oserror *err;

  volatile unsigned int *start_of_buffer;

  // read in the size of the file from the OS
  regs.r[0] = 5;
  regs.r[1] = (int)filename;


  _kernel_swi(OS_File, &regs, &regs);

  // if file not found
  if (regs.r[0] == 0)
  {
    printf("File not found\n");
    exit(0);
  }

  // get the size of file
  image_length = regs.r[4];


  // allocate memory for image file in RAM
  start_of_buffer = malloc(image_length);


  // load file into RAM
  printf("Loading image file....\n");

  regs.r[0] = 16;
  regs.r[1] = (int)filename;
  regs.r[2] = (int)start_of_buffer;
  regs.r[3] = 0;

  if ((err = _kernel_swi(OS_File, &regs, &regs)))
  {
    printf("Couldn't open input file\n");
    exit(0);
  }

  return(start_of_buffer);


}



/* If the image is already in memory (e.g. FTP fetch) we just need to grab
the pointer, passed as filename.  This is returned as start_of_buffer.
*/
volatile unsigned int *get_memory_ptr(char *filename)
{

  volatile unsigned int *start_of_buffer;



  if (image_length == 0)
  {
    printf("No image length supplied\n");
    return(0);
  }

  // get the address of the image from the command line
   start_of_buffer = (volatile unsigned int*)atoi(filename);

  return(start_of_buffer);
}

