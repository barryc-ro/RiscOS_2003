/*  The purpose of this Application is to provide a means to reprogram an
Operating system without the need for a Maintainance OS or secondary OS.
This effectively equates to a system which overwrites the currently running
OS.

These requirements force certain constraints on the Application as listed below.

1)  The program must make no OS calls after programming begins.
2)  The program must not make use of hardware/software interrupts as these
must be disabled
3)  The program cannot run as a module, as the SWI protocol will die when
interrupts die.
4)  The program will be very hard to write !!!!


Extra constraints imposed upon this application were....
5) Low memory footprint (run on an 8MB machine)


constraint 5) forced the use of compressed images, since an average OS image
will typically occupy 8MB of space itself.  This prompted the integration of
ZLIB into the programming algorithm to facilitate the handling of compressed
images.


This file is responsible for controlling the whole programming sequence which
goes a bit like this

1) Make sure compressed file is in RAM
2) Erase/Unlock flash devices
3) Decompress and Program image block at a time
4) Display Success/Failure message at the end


*/

/*
 * Version 1.0  17-Aug-2000  Mark Robertshaw - Created
 *
 * Version 1.1  29-Aug-2000  Mark Robertshaw - Modified (Added functionality  *                                             to enable write access to any  *                                             part of the physical ROM
 *
 * Version 1.2  05-Sep-2000  Mark Robertshaw - Modified (Added functionality
 *                                             to allow compressed images)
 *
 * Version 1.3  12-Sep-2000  Mark Robertshaw - Fixed Bugs with compression
 *
 */



#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "kernel.h"
#include "swis.h"
#include "zlib/h/zlib"

#include "globals.h"
#include "ProgOS.h"
#include "flashprog.h"
#include "endscreen.h"
#include "fetcher.h"
#include "messages.h"



// global variables

int image_type = NO_IMAGE;
int image_length = 0;
int filing_system = ZIPFS;

volatile unsigned int *rom_base = ROM_BASE;
int number_of_devices = NO_DEVICES;
int verbose = NO;




/* This function basically executes the programming procedure step at a time
*/

int main(int argc, char *argv[])
{
  volatile unsigned int *start_of_buffer;
  char *filename = malloc(255); // allocate memory for filename
  volatile unsigned int *end_of_buffer;  // pointer to end of block.
  volatile char *zlib_output_buffer;   // output buffer for zlib

  char buffer[255];


  // load the messages file and prepare to read from it
  if (!init_messages()) exit(0);


  // set up the endscreen for later use
  setup_endscreen();



  // deal with the command line arguments
  if (!command_line_arguments(argc, argv, filename) ) return(FAILURE);



  // allocate memory for zlib output buffer
  zlib_output_buffer = malloc(OUTPUT_BUFFER_SIZE);

  // check allocation success
  if ( zlib_output_buffer == NULL )
  {
     printf("Not enough memory\n");
     return(FAILURE);
  }


  /* STARTUP DISPLAY STUFF */

  if (verbose)
  {
    printf("\nAtmel Series Flash Rom Device Programmer v1.3\n");
    printf("(C) 2000  Pace Micro Technology PLC\n\n");

    // report which bank writing to
    if (image_type == OS_IMAGE) printf("Write OS Image to %p\n",  rom_base);
    if (image_type == FONT_IMAGE) printf("Write Font Image to %p\n", rom_base);

    // give chance to quit
    printf("You will lose all the data in this bank.  Do you wish to continue yes/no  ");

    scanf("%s", buffer);

    // check that person says yes !!
    if (strcmp(buffer, "yes") && strcmp(buffer, "y")) return(FAILURE);

  }

  start_of_buffer = fetch_image(filename);


  // check for success
  if (start_of_buffer == NULL)
  {
    printf("Fetch failed\n");
    exit(0);
  }


  // set up the end of buffer pointer
  end_of_buffer = start_of_buffer + (image_length/4);


  // tell the user what to do.
  if (verbose)
  {
    printf("Please switch off power when screen colour changes\n");
    printf("Green Screen = success      Red Screen = failure\n");

  }



  // allow us to write to the ROM
  if ( !flash_init() ) return(0);



  // erase phase
  if (!erase_and_unlock_devices() )
  {
    if (verbose) printf("Erase sequence failed\n");
    else display_endscreen(FAILURE);
    return(0);
  }


  // program phase
  if (!program_rom(start_of_buffer, zlib_output_buffer,  image_length) )
  {
    if (verbose) printf("Program sequence failed\n");
    else display_endscreen(FAILURE);

  }


  // verify phase
  if (!verify_rom(start_of_buffer, zlib_output_buffer,  image_length) )
  {
    if (verbose) printf("Verify sequence failed\n");
    else display_endscreen(FAILURE);
    return(0);
  }


  if (verbose)
  printf("Verification complete\n");

  if (verbose)
  printf("\nChip Programming complete\n");


  display_endscreen(SUCCESS);


  return(SUCCESS);

}







/* This function Erases and unlocks all of the devices.  It is really an API
to the erase functions provided in flashprog.c */


int erase_and_unlock_devices(void)
{
  int current_device;


  if (verbose)
  printf("Erasing and unlocking devices....\n");

  // Erase and then unlock All devices
  for (current_device = 0; current_device < number_of_devices;
                                             current_device++)
  {
    // erase device
    if ( !flash_erase_device(current_device) ) return(FAILURE);

    // bypass unlock device
    if ( !flash_bypass_unlock_device(current_device) ) return(FAILURE);
  }


  return(SUCCESS);

}


/* This function handles the writing of the image.  Again it just passes
information to the write/verify routines in flashprog.h
*/
int program_rom(volatile unsigned int *start_of_buffer,
           volatile char *zlib_output_buffer, int image_length)
{

  if (verbose)
  {
    printf("Programming Flash....\n");
  }


  // main write function
  if (!flash_decompress_block_operation(PROGRAM_FLASH, start_of_buffer,
    zlib_output_buffer,  image_length,  rom_base ) ) return(FAILURE);


  return(SUCCESS);
}







/* This function verifies the image.  Again it just passes
information to the write/verify routines in flashprog.h
*/
int verify_rom(volatile unsigned int *start_of_buffer,
           volatile char *zlib_output_buffer, int image_length)

{

  if (verbose)
  {
    printf("Verifying Flash....\n");
  }


  // main verify operation
  if (!flash_decompress_block_operation(VERIFY_FLASH, start_of_buffer,
    zlib_output_buffer,  image_length,  rom_base ) ) return(FAILURE);


  return(SUCCESS);


}




/*  This function deals with the command line arguments passed
to the application these are as follows

filename - path of image / memory pointer to image
-zipfs   - image is held on zip drive
-memory  - image is in memory (maybe put there by ftp fetcher)
-size    - reads next argument to find size of image
-OS      - Image is an OS image
-font    - Image is a font image
-v       - turns on verbose mode (loads of text output)
-help    - prints help stuff

*/

int command_line_arguments(int argc, char *argv[], char *filename)
{
  int argument_counter;
  int get_base_position = NO;
  int base_index;


  // assume the first argument is the filename
  strcpy(filename, argv[1]);



  // count through the command line arguments
  for (argument_counter = 1; argument_counter <= argc; argument_counter++)
  {


    // help mode
    if ( (!strcmp(argv[argument_counter], "-h") ) ||
         (!strcmp(argv[argument_counter], "-help") ) )
    {
      printf("\n");
      printf("Atmel Series Flash Rom Device Programmer v1.3 \n");
      printf("(C) 2000  Pace Micro Technology PLC\n\n");
      printf("Description: Erases and reprograms the flash ROM in Funai 8 devices\n");
      printf("\n");
      printf("Options: \n");
      printf("-zipfs         Selects source FS as zipfs\n");
      printf("-cachefs       Selects source FS as cachefs\n");
      printf("-os            Selects an OS image\n");
      printf("-font          Selects a Font image\n");
      printf("-v             Switch on verbose output\n");
      printf("-h, -help      Help mode\n");
      printf("\nReturns: \n");
      printf("Green screen if reprogramming successful\n");
      printf("Red   screen if failure\n");
      printf("\nSyntax: *flashprog image_filename <Options>\n");
      exit(0);


    }


    // if -zipfs passed set up for ZIP load
    if ( !strcmp(argv[argument_counter], "-zipfs") )
    {
      filing_system = ZIPFS;
    }

    // if -cachefs passed set up for CACHEFS
    if ( !strcmp(argv[argument_counter], "-memory") )
    {
      filing_system = MEMORY;
    }



    // if -size passed get the image length from command line
    if ( !strcmp(argv[argument_counter], "-size") )
    {
      image_length = atoi(argv[argument_counter + 1]);
    }



    // if -os set up for os bank
    if ( (!strcmp(argv[argument_counter], "-os") ) ||
         (!strcmp(argv[argument_counter], "-OS") )  )
    {
      // set  the type of image
      image_type = OS_IMAGE;

      // select the number of devices
      number_of_devices = OS_DEVICES;

      // get base position
      get_base_position = 1;


    }

    // if -font set up for font data
    if( (!strcmp(argv[argument_counter], "-font") ) ||
        (!strcmp(argv[argument_counter],"-FONT") )  )
    {


       // set the type of image
       image_type = FONT_IMAGE;

       // select the number of devices
       number_of_devices = FONT_DEVICES;

       // get base position
       get_base_position = YES;

    }



    // if get_base_position set get the base position
    if (get_base_position == YES)
    {
      // read in the base index argument
      base_index = atoi(argv[argument_counter + 1]);

      // check that a valid offset was given
      if ( base_index > 7 )
      {
        printf("Invalid ROM offset given\n");
        return(0);
      }



      rom_base = ROM_BASE + (base_index * BANK_SIZE);

      get_base_position = NO;

    }


    // check whether verbose output is required
    if (!strcmp(argv[argument_counter], "-v") )
    {
      verbose = YES;
    }


  }


  if (image_type == NO_IMAGE)
  {
    printf("No image type selected\n");
    return(0);
  }


return(1);
}



