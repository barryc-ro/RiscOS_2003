/*  This file performs all of the user interface functions for the download
application.

This involves

1) Setting up the status screen
2) Updating the status screen
3) Printing the current status
4) Creating an error box and handling any errors that may occur
5) polling the wimp as required

*/



#include <stdio.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"

#include "wimplib.h"
#include "toolbox.h"
#include "window.h"
#include "event.h"
#include "TextArea.h"

#include "ui.h"
#include "messages.h"
#include "globals.h"

#include "DBUG.h"
#include "Debuglib/Debuglib.h"

ObjectId     window_id;
ObjectId     errorbox_id;

extern MessagesFD messages;
int old_percentage = 0;



/* This function initialises the main status screen.  It creates the main
window via the toolbox and shows it on the screen */
void initialise_status_screen(void)
{

  // create the main window, get the id
  toolbox_create_object(0, "Window", &window_id);

  // show the main window
  toolbox_show_object(0, window_id, 0, 0, 0, 0 );

  poll_wimp();
}




/* This function updates the status screen to show the latest status.
This involves calculating the percentage completed and calling the functions
to update the gadgets accordingly */
void update_status_screen(int total_bytes_read, int total_bytes_to_read)
{
  int percentage;

  // prevent division by zero
  if (total_bytes_to_read != 0)
  percentage = ( (BAR_MAX * total_bytes_read) / total_bytes_to_read );

  else percentage = 0;

  // decide whether to update the percentage or not
  if (percentage == old_percentage + BAR_STEP)
  {
    set_percentage(percentage);
    old_percentage = percentage;
  }

}



/* change value of status field */
void status_print(char *message)
{
  displayfield_set_value(0, window_id, STATUS_TEXT, message);
  poll_wimp();
}



// set the percentage field and change slider to reflect the percentage
void set_percentage(int value)
{
  char string[10];

  sprintf(string, "%i%%", value);

  /* set the percentage field */
  displayfield_set_value(0, window_id, PERCENTAGE_COUNTER, string);

  /* set the slider */
  slider_set_value(0, window_id, STATUS_BAR, value);
}




/* This function is called if an error occurs.  It opens up an error window
displaying the error message which it gets from the message routines, and
it provides a reset button for the user to reset the box */
void error_occurred(char *token)
{
  char *error_message1;
  char *error_message2;

  char token1[40];
  char token2[40];

  // set up event variables
  int event_code;
  WimpPollBlock wimp_poll_block;
  IdBlock id_block;

  //create two tokens
  strcpy(token1,token);
  strcat(token1,"1");
  strcpy(token2,token);
  strcat(token2,"2");

  // create error window
  toolbox_create_object(0, "Error", &errorbox_id);

  error_message1 = lookup_message_token(token1);
  error_message2 = lookup_message_token(token2);

  // report error back
  draggable_set_text(0, errorbox_id,0, lookup_message_token(token1));
  draggable_set_text(0, errorbox_id,2, lookup_message_token(token2));


  // show error window
  toolbox_show_object(0, errorbox_id, 0, 0, 0, 0);

  // initialise the event veneers
  event_initialise(&id_block);
  event_set_mask(1+256);

  // register button press
  event_register_toolbox_handler(-1, 1, reset_machine, 0);

  while (TRUE)
  {
    event_poll (&event_code, &wimp_poll_block, 0);
  }

}


// poll the wimp
void poll_wimp(void)
{
  // wimp poll entries
  int mask = 0;
  WimpPollBlock wimp_poll_block;
  int pollword;
  int event_code;

  wimp_poll(mask, &wimp_poll_block, &pollword, &event_code);
}



/* Nasty, nasty... Ideally we would pass in a mode-style descriptor. At the
very least we should make it mre generic by allowing the user to pass in a
mode number. */
void set_wimp_mode(void)
{
  _kernel_swi_regs reg;
  _kernel_oserror *err = NULL;

  reg.r[0]=28;  //mode 28 640 X 480, 8bbp

  err=_kernel_swi(Wimp_SetMode, &reg, &reg);

  if(err) DBUG_PRINTF(DBUG_LVL_DIAG,err->errmess);

}



