
/*
This Application performs the first part of a two part upgrade procedure for
upgrading the operating system on an NC without the need for a seperate
operating system or maintainance OS.

This Application Fetches a compressed OS image from a supplied URL via FTP
and stores it in a dynamic area.  It then triggers a seperate application
to reprogram the flash memory with the new image.


This program provides a Wimp interface for the download process showing a
bar chart of the progress of the download and status information as to the
progress.  The program launches the programming task as soon as the download
is complete.

 Created 26th September 2000    Mark Robertshaw
*/




#include <stdio.h>
#include <stdlib.h>
#include "string.h"

#include "swis.h"
#include "kernel.h"

#include "interface/URL.h"
#include "math.h"
#include "wimplib.h"
#include "toolbox.h"


#include "FetchImage.h"
#include "kill.h"

#include "ui.h"
#include "messages.h"
#include "globals.h"

/* Other libraries */
#include "DBUG.h"
#include "Debuglib/Debuglib.h"



#define WimpVersion    310

static  WimpPollBlock  poll_block;
        MessagesFD     messages;
static  IdBlock        id_block;

int     server_timeout;


/* This flag below states how much data we wish to read from the URL at any time. */
#define URL_CHUNK_SIZE 32768



/*  Main takes a URL as it's only command line argument.  It controls the
downloading of a compressed image into a dynamic area.  Here are the main
steps it takes

1) Read URL from Command line
2) Create a dynamic area to store the compressed image
3) Connect to the FTP Server
4) Get the image 32k at the time.
5) Launch the child task

*/


int main(int argc, char *argv[])
{
  _kernel_swi_regs regs;                        // kernel swi regs
  _kernel_oserror *err, *error;                 // kernel errors

  int session_identifier = 0;                   // used to pass to URL module

  char *url = malloc(255);                      // url string

  int dynamic_area_number;                      // dynamic area identifier
  char *dynamic_area_base_address = NULL;       // base address of area
  char *dynamic_area_current_ptr;               // pointer to current bit

  char buffer[URL_CHUNK_SIZE];        // buffer for latest chunk

  char command_line_arguments[255];             // used to pass args to
                                                // child process
  int memory_bank;                              // memory bank to write to

  char child_task[256];                        // child task to run

  int bytes_read;                              // bytes read in a single pass
  int total_bytes_read = 0;                    // total bytes read
  int total_bytes_to_read = 0;                 // total bytes to read
  int bytes_left_to_read = -1;                 // bytes left to read

  int image_size = 0;                          // size of image

  int checked_free_memory  = FALSE;            // flag
  int started_getting_data = FALSE;            // flag

  /* Set vars to store the amount of memory currently alloated for te DA, and the amount used. */
  unsigned int mem_da_size = 0;
  unsigned int mem_da_used = 0;

  /* Initialise the DebugLib library. */
  debug_initialise ("UpgradeFetcher", "izipfs:$.FetchOut", "");
  debug_output_device (FILE_OUTPUT);
  debug_atexit ();

  DBUG_PRINTF(DBUG_LVL_DIAG, "main()\n");

  /* read the command line arguments. There should be two arguments we read
      the second one, the url */
  if (argc < 2)
  {
    printf("Not enough arguments supplied\n");
    exit(EXIT_FAILURE);
  }

  /* set up the url */
  strcpy(url, argv[2]);

  /* initialise message file */
  init_messages();

  /* Initialise the WIMP */
  initialise_wimp();

  /* create ourselves a dynamic area */
  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Creating a dynamic area.\n");
  regs.r[0] = 0;
  regs.r[1] = -1;
  regs.r[2] = 1;
  regs.r[3] = -1;
  regs.r[4] = 0;
  regs.r[5] = -1;
  regs.r[6] = 0;
  regs.r[7] = 0;
  regs.r[8] = (int)"Upgrade Image Area";

  err = _kernel_swi(OS_DynamicArea, &regs, &regs);

  if (err)
  {
    error_occurred("CantClaimDynamicArea");
  }

  /* set up the dynamic area variables */
  dynamic_area_number = regs.r[1];
  dynamic_area_base_address = (char*)regs.r[3];

  // free up some memory by killing running applications
  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Attempting to kill some running applications.\n");
  if (!kill_apps())
  {
    error_occurred("CantKillApplications");
  }

  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Initialising the status screen.\n");
  initialise_status_screen();

  // register the session
  regs.r[0] = 0;
  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Resgistering the session.\n");
  err = _kernel_swi(URL_Register, &regs, &regs);
  status_print("Connecting to the FTP server\n");
  if (err)
  {
    error_occurred("CantConnectToFTPServer");
  }

  session_identifier = regs.r[1];

  // get url
  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Getting the URL.\n");
  regs.r[0] = 0;  // we do want the length of the data
  regs.r[1] = session_identifier;
  regs.r[2] = 1;
  regs.r[3] = (int)url;  //location
  regs.r[4] = NULL;
  regs.r[5] = 0;
  regs.r[6] = NULL;

  error = _kernel_swi(URL_GetURL, &regs, &regs);

  if (error)
  {
     error_occurred("CantFetchURL");
  }

  dynamic_area_current_ptr = dynamic_area_base_address;

  // get the server timeout value from message file
  server_timeout = atoi( lookup_message_token("ServerTimeout") );

  /*  This is the main Data fetch routine */

  /* Here we get 32k chunks of data at a time.  If we can we try and read
  the number of bytes remaining to be read as soon as possible so as to
  ensure we don't run out of memory in the dynamic area.  If this isn't
  possible we allocate the memory on the fly and hope for the best !!
  */

  while (!error)
  {
    regs.r[0] = 0;
    regs.r[1] = session_identifier;
    regs.r[2] = (int)buffer;
    regs.r[3] = URL_CHUNK_SIZE;

    /* Read next 32k chunk */
    error = _kernel_swi(URL_ReadData, &regs, &regs);

    // check to see that we have finished
    if (error)
    {
      break;
    }

    bytes_read = regs.r[4];
    if (bytes_read > 0)
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "main(): We actually only read %d bytes from the URL.\n", bytes_read);
    }

    // update the total bytes read variable
    total_bytes_read += bytes_read;

    if (bytes_read > 0)
    {
       // if we haven't already done so update the display
       if (started_getting_data == FALSE)
       {
         status_print("Downloading new image\n");
         started_getting_data = TRUE;
       }

       // if we haven't already done so, check we have the required free ram.
       if (checked_free_memory == FALSE)
       {
        bytes_left_to_read = regs.r[5];

        // if we receive notification of how much left
        if (bytes_left_to_read != -1)
        {
         // make a record of how many bytes to read in total
         total_bytes_to_read = bytes_left_to_read + total_bytes_read;

         // allocate memory for the whole image
         DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Attempting to increase size of DA holding image to %d bytes (free memory in system is %d bytes).\n", bytes_read, return_free_memory());

         regs.r[0] = dynamic_area_number;
         regs.r[1] = bytes_left_to_read + bytes_read;
         err = _kernel_swi(OS_ChangeDynamicArea, &regs, &regs);
         if (err)
         {
           DBUG_PRINTF(DBUG_LVL_DIAG, "main(): DA area increase failed 1 - allocated %d bytes instead of the required %d bytes (message %s).\n", regs.r[1], bytes_read, err->errmess);
           error_occurred("NotEnoughMemory");
         }
         else
         {
           mem_da_size+=bytes_read;
           mem_da_used+=bytes_read;
         }

         checked_free_memory = TRUE;
       }
     }

     /* If we still don't know how large the image is allocate enough
         for the currently read block (dynamically) */
     if (checked_free_memory == FALSE)
     {
       double d_mem_requested = (double) bytes_read;
       int i_mem_requested;
       d_mem_requested = ceil(d_mem_requested/4096)*4096; /* Page-align it */
       i_mem_requested = (int)d_mem_requested;
       DBUG_PRINTF(DBUG_LVL_DIAG, "main(): We want %d more bytes (free memory in system is %d bytes).\n", i_mem_requested, return_free_memory());
       DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Current DA size is %d bytes, used is %d bytes\n", mem_da_size, mem_da_used);

       /* If we have not got enough space in the da, increase the size. */
       if ((i_mem_requested+mem_da_used) >= mem_da_size)
       {
         DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Increasing size of th DA by %d bytes.\n", i_mem_requested);

         regs.r[0] = dynamic_area_number;
         regs.r[1] = i_mem_requested;
         err = _kernel_swi(OS_ChangeDynamicArea, &regs, &regs);
         if (err)
         {
           DBUG_PRINTF(DBUG_LVL_DIAG, "main(): DA area increase failed 3 - allocated %d bytes instead of the required %d bytes (message %s).\n", regs.r[1], bytes_read, err->errmess);
           error_occurred("NotEnoughMemory");
         }
         else
         {
           mem_da_size+=i_mem_requested;
           mem_da_used+=bytes_read;
         }
       }
       else
       {
         mem_da_used+=bytes_read;
       }
     }

     /* If the memory allocation has worked, copy the memory over and update the status screen. */
     if (!err)
     {
       /* copy the memory block into the dynamic area */
       DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Copying %d bytes of memory from %0x to %0x over.\n", bytes_read, dynamic_area_current_ptr, buffer);
       memcpy(dynamic_area_current_ptr, buffer, bytes_read);
       update_status_screen(total_bytes_read, total_bytes_to_read);
       dynamic_area_current_ptr += bytes_read; // increment the memory pointer
     }
     else
     {
       DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Error allocating dynamic area (%s)\n", err->errmess);
     }

     /* reset the null reads counter */
     number_of_null_reads = 0;
     last_timer_value = 0;
    }
    else
    {
      /* if no bytes have been read from the URL */
      check_for_timeout();
    }

    // poll the wimp to update any toolbox changes
    poll_wimp();

  }

  // finish up

  regs.r[0] = 0;
  regs.r[1] = session_identifier;
  _kernel_swi(URL_Deregister, &regs, &regs);

  // calculate the image size.
  image_size = dynamic_area_current_ptr - dynamic_area_base_address;

  status_print("Programming new image\n");
  poll_wimp();


  // pass the dynamic area address and image size to atmelprog
  strcpy(child_task, lookup_message_token("ChildTask") );
  memory_bank = atoi( lookup_message_token("MemoryBank") );

  sprintf(command_line_arguments, "%s %i -memory -size %i -os %i",
                  child_task, (int)dynamic_area_base_address, image_size,
                  memory_bank);

  if (!close_messages_file())
  {
    exit(EXIT_FAILURE);
  }


  _kernel_oscli(command_line_arguments);

}





/* This function checks that we are still receiving data from the server
essentially if we don't receive any data in the time specified in the
messages file as ServerTimeout it returns an error.
*/

void check_for_timeout(void)
{
  float current_timer_value;

  // increment the number of null reads
  number_of_null_reads ++;


  // set up the timer for the first time
  if (last_timer_value == 0)
  {
    last_timer_value = read_time_in_seconds();
    return;
  }



  // if number of null reads > NULL_COUNTOUT check for data stream
  if (number_of_null_reads > NULL_COUNTOUT)
  {

    current_timer_value = read_time_in_seconds();

    // check for activity for NULL_TIMEOUT seconds
    if ( (current_timer_value - last_timer_value) > server_timeout )
    {
      error_occurred("ServerError");
    }

    else number_of_null_reads = 0;

  }



}




/* This function is just an interface to the ReadMonotonicTime SWI
*/

float read_time_in_seconds(void)
{
  _kernel_swi_regs regs;
  float time_in_seconds;

  _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);

  time_in_seconds = (float)regs.r[0] / 100;

  return time_in_seconds;
}





/* Since we are running as a Wimp Toolbox task we need to initialise the
Toolbox and load our resource file e.t.c. This routine does this for us.
It also makes a call to initialise our messages.

*/


void initialise_wimp()
{
  int wimp_messages = 0,
      toolbox_events = 0;

  toolbox_initialise(0, WimpVersion, &wimp_messages, &toolbox_events,
                     "<Fetch$Dir>", &messages, &id_block, 0, 0, 0);
}



/* This function is just an interface to OS_Reset called to
reset the machine.  Called when the user clicks the dialogue box to reset
*/

int reset_machine(int event_code, ToolboxEvent *event,
                             IdBlock *id_block,void *handle)
{
  _kernel_swi_regs regs;

  _kernel_swi(OS_Reset, &regs, &regs);

  return(SUCCESS);
}



/* This routine returns the amount of freememory available. */
unsigned int return_free_memory(void)
{
  _kernel_swi_regs regs;
  regs.r[0] = -1;
  regs.r[1] = -1;
  _kernel_swi(Wimp_SlotSize, &regs, &regs);

  return (regs.r[2]);
}

