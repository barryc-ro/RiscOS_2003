/**************************************************************/
/* File:    main.h                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: To run.                                           */
/*                                                            */
/* Author:  Mark Robertshaw; Nick Evans; Andrew Hodgkinson.   */
/*                                                            */
/* History: 26-Sep-2000 (MR):  Created.                       */
/*          10-Oct-2000 (NE):  Added CRC check.               */
/*          11-Oct-2000 (NE):  Added build check.             */
/*          12-Oct-2000 (NE):  Added Flash Bank.              */
/*          01-May-2001 (ADH): Lots of reorganisation, fixes, */
/*                             restructuring, rewriting...    */
/**************************************************************/

/*
 * This application performs the first part of a two part upgrade procedure
 * for upgrading the operating system on an NC without the need for a
 * separate operating system ("maintenance OS").
 *
 * The application fetches a compressed OS image from a supplied URL via FTP
 * and stores it in a dynamic area.  It then triggers a separate application
 * to reprogram the flash memory with the new image.
 *
 * The program provides a Wimp interface for the download process showing a
 * bar chart of the progress of the download along with status information.
 * The program launches the programming task as soon as the download is
 * complete.
 *
 * Versions post-dating 30-Apr-2001 may also take a textual configuration
 * file and pass it on for setting NVRAM details (e.g. to reconfigure the
 * ISP details), or take a packed archive containing an application to run,
 * put it in CacheFS, execute it, and tidy up afterwards.
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <setjmp.h>
#include <signal.h>
#include <math.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimplib.h>
#include <tboxlibs/toolbox.h>

#include <DebugLib/DebugLib.h>

#ifdef USE_CHECKURL
  #include <CheckURL.h>
#endif

#include "crc32.h"
#include "Errors.h"
#include "FetchImage.h"
#include "globals.h"
#include "Kill.h"
#include "UI.h"
#include "Utils.h"
#include "URLVeneer.h"

#include "main.h"

/* The flag below states how much data we wish to read from the */
/* URL at any time.                                             */

#define URL_CHUNK_SIZE 8192

/* Temporary CheckURL area name */

#define UpgFetch_CheckURLArea "UpgFetch_TemporaryValidationArea"

/* Tag types and a structure to hold a list of known tags */

typedef enum
{
  TLV_TAG_TYPE_FILE_SIZE,
  TLV_TAG_TYPE_DISPLAY_STRING,
  TLV_TAG_TYPE_BUILD_LIST,
  TLV_TAG_TYPE_LOCALE_LIST,
  TLV_TAG_TYPE_IMAGE_TYPE,
  TLV_TAG_TYPE_IMAGE_LENGTH,
  TLV_TAG_TYPE_IMAGE_DATA,
  TLV_TAG_TYPE_FILE_CRC,
  TLV_TAG_TYPE_RANDOM_DATA,
  TLV_TAG_TYPE_BANK,
  TLV_TAG_TYPE_UNRECOGNISED

} TLV_TAG_TYPES;

typedef struct tlv_list_node
{
  int      tag_type;      /* The type of the tag (one word) */
  int      tag_length;    /* The length of the tag (one word) */
  char   * value_pointer; /* A pointer to the start of the area containing the value */
  struct   tlv_list_node * next_tag;

} tlv_list_node_type;

static tlv_list_node_type * tlv_list_head = NULL; /* Head and tail pointers */
static tlv_list_node_type * tlv_list_tail = NULL;

/* Other locals */

static char * dynamic_area_base_address = NULL;
static bool   crc_validated             = false; /* This variable gets set if the CRC of the image has been validated */
static int    memory_bank               = 0;     /* Memory bank to write to */
static int    total_bytes_to_read       = 0;     /* Total bytes to read - this can be obtained from either the FTP server or the filelength tag */

/* Local functions */

static void                 exit_handler                   (void);

static void                 check_for_timeout              (const int server_timeout);
static float                read_time_in_seconds           (void);

static _kernel_oserror    * initialise_wimp                (void);
static unsigned int         return_free_memory             (void);

static bool                 fetch_data                     (const int session_identifier, const int dynamic_area_number, char ** dynamic_area_current_ptr, const int server_timeout, const char * const dynamic_area_base);
static int                  return_tag_type                (const char * const base_pointer, const char * end_pointer);
static unsigned int         read_little_word               (const char * const buff);
static int                  return_tag_length              (const char * const base_pointer, const char * end_pointer);
static char               * is_tag_complete                (const char * const base_pointer, const char * const end_pointer);

#ifdef ENABLE_DEBUGGING
  static void               decode_file                    (const char * const memory_base, const char * const memory_end);
#endif

static void                 display_linked_list            (void);
static void                 free_list                      (void);
static void                 decode_tlv_tags_after_download (void);
static tlv_list_node_type * return_tlv_of_type             (const unsigned int type);
static void                 add_node                       (const int type, const int length, const char * const location);

static bool                 validate_crc                   (unsigned int expected_crc, const char * const end_location);
static void                 checkBuild                     (char * builds);
static bool                 setup_proxy                    (const unsigned int session);

#if defined(USE_TRUSTED_DOMAINS) || defined(TEST_TRUSTED_DOMAINS_CODE)
  static bool               rightmatches                   (const char * p1, const char * p2, const char * s1, const char * s2);
  static bool               validate_domain                (const char * const url, const char * const allowed_domains);
#endif

static void                 start_iconhigh                 (void);
static void                 catch_errors                   (int signum);

/**************************************************************/
/* exit_handler()                                             */
/*                                                            */
/* General cleanup function registered through atexit().      */
/**************************************************************/

static void exit_handler(void)
{
  _kernel_oserror * e;

  /* Hang up the line - this fixes MPT fault 142. They have  */
  /* asked for the line to be hungup when the program fails. */

  e = _swix(NCDial_Hangup, 0);

  if (e != NULL)
  {
    dprintf(("Fail", "exit_handler (main.c): Hangup SWI failed ('%s')\n", e->errmess));
  }

  return;
}

#ifdef TEST_TRUSTED_DOMAINS_CODE

  #define test_url(url, allowed, pass) printf("Testing url '%s' against allowed list '%s': ", url, allowed); \
                                       if (validate_domain(url, allowed)==pass) printf("OK\n");              \
                                       else printf("*** FAIL ***\n");

  /**************************************************************/
  /* main_self_test()                                           */
  /*                                                            */
  /* Run the self-test. Manual inspection of output required.   */
  /**************************************************************/

  int main_self_test(void)
  {
    printf("Testing cases which should be allowed:\n\n");

    test_url("http://www.pace.co.uk",               ".pace.co.uk",               true);
    test_url("http://support.pace.co.uk",           ".funai.co.jp, .pace.co.uk", true);
    test_url("http://w.pace.co.uk",                 ".pace.co.uk",               true);
    test_url("http://www.pace.co.uk/test.html",     ".pace.co.uk",               true);
    test_url("http://www.pace.co.uk/test.html",     ".pace.co.uk",               true);
    test_url("http://support.pace.co.uk/test.html", ".funai.co.jp, .pace.co.uk", true);
    test_url("http://w.pace.co.uk/test.html",       ".pace.co.uk",               true);
    test_url("http://WWW.PACE.CO.UK",               ".pace.co.uk",               true);
    test_url("http://www.pace.co.uk",               ".PACE.CO.UK",               true);

    printf("\nTesting cases which should be rejected:\n\n");

    test_url("http://pace.co.uk",                   ".pace.co.uk, mptech.co.jp", false);
    test_url("http://pace.co.uk/test.html",         ".pace.co.uk, mptech.co.jp", false);
    test_url("http://pace.co.uk",                   ".pace.co.uk",               false);
    test_url("http://pace.co.uk.ha.co.uk",          ".pace.co.uk",               false);
    test_url("http://pace.co.ukc",                  ".pace.co.uk",               false);
    test_url("http://ace.co.uk",                    ".pace.co.uk",               false);
    test_url("http://space.co.uk",                  ".pace.co.uk",               false);
    test_url("http://space.co.uk",                  ".pace.co.uk",               false);
    test_url("http://pace.co.uk",                   ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk.ha.co.uk",          ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.ukc",                  ".funai.co.jp, .pace.co.uk", false);
    test_url("http://ace.co.uk",                    ".funai.co.jp, .pace.co.uk", false);
    test_url("http://space.co.uk",                  ".funai.co.jp, .pace.co.uk", false);
    test_url("http://space.co.uk",                  ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk/test/",             ".pace.co.uk, .funai.co.jp", false);
    test_url("http://pace.co.uk.ha.co.uk/test/",    ".pace.co.uk, .funai.co.jp", false);
    test_url("http://pace.co.ukc/test/",            ".pace.co.uk, .funai.co.jp", false);
    test_url("http://ace.co.uk/test/",              ".pace.co.uk, .funai.co.jp", false);
    test_url("http://space.co.uk/test",             ".pace.co.uk, .funai.co.jp", false);
    test_url("http://space.co.uk/test",             ".pace.co.uk, .funai.co.jp", false);
    test_url("http://pace.co.uk/test",              ".pace.co.uk",               false);
    test_url("http://pace.co.uk",                   ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk.ha.co.uk",          ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk?q=www.fool.com",    ".pace.co.uk",               false);
    test_url("http://fooled.co.uk/pace.co.uk",      ".pace.co.uk",               false);

    return EXIT_SUCCESS;
  }

#endif

/**************************************************************/
/* main()                                                     */
/*                                                            */
/* Entry point for non-TEST_TRUSTED_DOMAINS_CODE builds.      */
/*                                                            */
/* This requires a URL as its only command line argument. It  */
/* controls the downloading of a compressed image into a      */
/* dynamic area:                                              */
/*                                                            */
/* 1) Read URL from command line                              */
/* 2) Create a dynamic area to store the compressed image     */
/* 3) Connect to the FTP Server                               */
/* 4) Get the image URL_CHUNK_SIZE at the time                */
/* 5) Launch the child task                                   */
/**************************************************************/

int main(int argc, char *argv[])
{
  _kernel_swi_regs regs;
  _kernel_oserror *err, *error;

  int session_identifier = 0;                   /* This stores the session identifier we have registered with the URL module. */

  char url[256];                                /* url string */

  int dynamic_area_number;                      /* dynamic area identifier */
  char *dynamic_area_current_ptr = NULL;        /* pointer to current bit */

  char command_line_arguments[255];             /* used to pass args to child process */
  char child_task[256];                         /* child task to run */

  int image_size = 0;                           /* size of image */

  int server_timeout;

  char* image_pointer = NULL; /* This points to the start if the image to be put into Flash in the DA. */
  tlv_list_node_type* image_pointer_tlv = NULL;

  #ifdef TEST_TRUSTED_DOMAINS_CODE
    return main_self_test();
  #endif

  /* Initialise the DebugLib library. */

  debug_initialise("UpgFetch", "izipfs:$.FetchOut", "");
  debug_output_device(TML_OUTPUT);
  debug_atexit();

  dprintf(("", "\n"));
  dprintf(("Diag", "main (main.c): Running\n"));

  /* NB, don't forget to echo any changes here with the duplicate code */
  /* just below the setjmp call later.                                 */

  signal(SIGOSERROR, catch_errors); /* OS error            */
  signal(SIGILL,     catch_errors); /* Illegal instruction */
  signal(SIGSEGV,    catch_errors); /* Segment violation   */
  signal(SIGSTAK,    catch_errors); /* Stack overflow      */
  signal(SIGFPE,     catch_errors); /* FPE error           */

  /* Set up an atexit() handler */

  atexit(exit_handler);

  /* Read the command line arguments. There should be two arguments we read; */
  /* the second one should be the URL.                                       */

  if (argc < 2)
  {
    dprintf(("Fail", "main (main.c): Not enough arguments supplied, exitting\n"));
    exit(EXIT_FAILURE);
  }

  /* Take a local copy of the URL */

  StrNCpy0(url, argv[1]);

  /* Start as a Wimp task */

  initialise_wimp();

  /* Initialise IconHigh */

  start_iconhigh();

  /* 01-May-2001 (ADH): Presently a proliferation of Wimp_Poll call points (yikes!) */
  /* means there's no sensible central point to put a longjmp handler for critical  */
  /* error recovery. So put it here, and force a bail-out on error.                 */

  if (setjmp(env) == Main_FromCatchErrors)
  {
    /* Long jump handler - most nasty or generally unexpected */
    /* errors will come back to here. The OS error abort      */
    /* handler jumps back here to deal with the error as we   */
    /* then have a clear stack; this is to avoid 'no stack    */
    /* for trap handler' errors caused by a SWI corrupting    */
    /* the value of R10.                                      */

    char         * tok        = NULL;
    unsigned int * regdump    = NULL;
    unsigned int * os_regdump = NULL;
    char           pc[16];

    /* Sort out the register dump */

    _swix(OS_ChangeEnvironment,
          _INR(0,3) | _OUT(3),

          7, /* Call back */
          0,
          0,
          0,

          &regdump); /* Where the C library put the registers */

    _swix(OS_ChangeEnvironment,
          _INR(0,3) | _OUT(1),

          13, /* Exception registers */
          0,
          0,
          0,

          &os_regdump); /* Where *ShowRegs gets them from */

    /* Copy the C register dump into the OS space */

    if (regdump && os_regdump) memcpy(os_regdump, regdump, 4 * 16);

    /* Store a more sensible error in the error block 'erb' where possible. */

    switch (erb.errnum & 0x00ffffff)
    {
      case 0x000000: tok = "EZeros0"; break;
      case 0x000001: tok = "EZeros1"; break;
      case 0x000002: tok = "EZeros2"; break;
      case 0x000003: tok = "EZeros3"; break;
      case 0x000005: tok = "EZeros5"; break;
    }

    if (tok)
    {
      char * error;

      /* If we know the PC, put this in the message */

      if (!regdump) sprintf(pc, "&deaddead");
      else          sprintf(pc, "&%08X", os_regdump[15] &~ 0xfc000003);

      error = lookup_token(tok, 1, pc);

      /* If the message token wasn't found, use the OS error, */
      /* otherwise copy the new one into the error block.     */

      if (strcmp(error, "!")) StrNCpy0(erb.errmess, error);
    }

    /* Need to reinstall the signal handlers since the run-time */
    /* system will have removed them 'For Your Safety And       */
    /* Convenience'. Don't forget to keep this list up to date  */
    /* with the code near the top of the function.              */

    signal(SIGOSERROR, catch_errors); /* OS error            */
    signal(SIGILL,     catch_errors); /* Illegal instruction */
    signal(SIGSEGV,    catch_errors); /* Segment violation   */
    signal(SIGSTAK,    catch_errors); /* Stack overflow      */
    signal(SIGFPE,     catch_errors); /* FPE error           */

    erb.errnum = Errors_Custom_Fatal; /* Force 'Quit' */
    errors_ret(&erb);

    exit(EXIT_FAILURE);
  }

  /* Ensure that the URL is from a trusted source */

  #ifdef USE_TRUSTED_DOMAINS

    if (!validate_domain(url,  USE_TRUSTED_DOMAINS))
    {
      dprintf(("Fail", "main (main.c): %s is not a trusted domain. Exitting...\n", url));
      quit("InvalidServer");
    }

  #endif /* USE_TRUSTED_DOMAINS */

  /* set wimp mode to 640 X 480 so it works on any box */
  set_wimp_mode();

  /* Create ourselves a dynamic area */

  dprintf(("Diag", "main (main.c): Creating a dynamic area\n"));

  regs.r[0] = 0;
  regs.r[1] = -1;
  regs.r[2] = 1;
  regs.r[3] = -1;
  regs.r[4] = 0;
  regs.r[5] = -1;
  regs.r[6] = 0;
  regs.r[7] = 0;
  regs.r[8] = (int)"Upgrade Image Area";

  err = _kernel_swi(OS_DynamicArea, &regs, &regs);
  if (err)
  {
    error_occurred("CantClaimDynamicArea");
  }

  /* set up the dynamic area variables */
  dynamic_area_number = regs.r[1];
  dynamic_area_base_address = (char*)regs.r[3];
  dynamic_area_current_ptr = dynamic_area_base_address;

  /* free up some memory by killing running applications */

  dprintf(("Diag", "main (main.c): Attempting to kill various applications...\n"));

  if (!kill_apps())
  {
    error_occurred("CantKillApplications");
  }

  dprintf(("Diag", "main (main.c): Initialising the status screen\n"));

  initialise_status_screen();

  /* Register the session and set the session_identifier flag */
  regs.r[0] = 0;

  dprintf(("Diag", "main (main.c): Registering with URL_Fetcher\n"));

  err = _kernel_swi(URL_Register, &regs, &regs);
  status_print(lookup_token("ConnectFTP",0,0));
  if (err)
  {
    error_occurred("CantConnectToFTPServer");
  }
  session_identifier = regs.r[1];

  /* Set up the proxy (if any) */
  if (!setup_proxy(session_identifier))
  {
    dprintf(("Diag,Fail", "main (main.c): Could not connect via. a proxyr\n"));
  }

  /* Commence the fetch of the data from the url */

  dprintf(("Diag", "main (main.c): Starting URL fetch\n"));

  regs.r[0] = 0;         /* We do want the length of the data */
  regs.r[1] = session_identifier;
  regs.r[2] = 1;
  regs.r[3] = (int)url;  /* The location of the URL */
  regs.r[4] = NULL;
  regs.r[5] = 2;  /* magic number! makes all responses have HTTP headers! We need to do this or the responces for HTTP and FTP servers are inconsistant */
  regs.r[6] = NULL;
  error = _kernel_swi(URL_GetURL, &regs, &regs);

  if (error)
  {
    dprintf(("Fail", "main (main.c): Error '%s' from URL_GetURL", error->errmess));
    error_occurred("CantFetchURL");
  }

  /* Get the server timeout value from message file */
  server_timeout = atoi( lookup_token("ServerTimeout",0,0) );

  /* Initialise the linked list of TLV values. */
  tlv_list_head = NULL;
  tlv_list_tail = NULL;

  /*  This is the main Data fetch routine */
  fetch_data(session_identifier, dynamic_area_number, &dynamic_area_current_ptr, server_timeout, dynamic_area_base_address);

  /* Deregister with the URL module */
  regs.r[0] = 0;
  regs.r[1] = session_identifier;
  _kernel_swi(URL_Deregister, &regs, &regs);

  /* Decode the TLV tags. */
  decode_tlv_tags_after_download();

  /* Calculate the final image size. */

  image_size = dynamic_area_current_ptr - dynamic_area_base_address;
  dprintf(("Diag", "main (main.c): Final image size is %d bytes\n", image_size));

  if (image_size <= 0)
  {
    dprintf(("Fail", "main (main.c): Image too small\n"));
    exit(EXIT_FAILURE);
  }

  /* Display the linked list */
  display_linked_list();

  /* Obtain a pointer to the image to be programmed from the linked list. */
  image_pointer_tlv = return_tlv_of_type(TLV_TAG_TYPE_IMAGE_DATA);
  image_pointer = image_pointer_tlv->value_pointer;

  dprintf(("Diag", "main (main.c): Image start is at &%08X\n", (int) image_pointer));

  /* Free the list. */
  free_list();

  /* Only attempt to flash the image if it's CRC has been validated. */
  if (crc_validated)
  {
    //removed this message so that the user doesn't see a change
    //when programming begins
    //    status_print(lookup_token("Programming",0,0));
    poll_wimp();

    /* Create the string to pass the dynamic area address and image size to the atmel flash programmer */
    strcpy(child_task, lookup_token("ChildTask",0,0) );
    //  memory_bank = atoi( lookup_token("MemoryBank",0,0) );
    sprintf(command_line_arguments, "%s %i -memory -size %i -os %i",
            child_task, (int)image_pointer, image_pointer_tlv->tag_length,
            memory_bank);

    /* Finally execute the string including the child task string */

    dprintf(("Diag", "main (main.c): UpgFlash command line args: '%s'\n", command_line_arguments));
    _kernel_oscli(command_line_arguments);
  }

  return (SUCCESS);
}

/* This function checks that we are still receiving data from the server
essentially if we don't receive any data in the time specified in the
messages file as ServerTimeout it returns an error.
*/
static void check_for_timeout(const int server_timeout)
{
  float current_timer_value;

  /* increment the number of null reads */
  number_of_null_reads ++;

  /* set up the timer for the first time */
  if (last_timer_value == 0)
  {
    last_timer_value = read_time_in_seconds();
    return;
  }

  /* if number of null reads > NULL_COUNTOUT check for data stream */
  if (number_of_null_reads > NULL_COUNTOUT)
  {
    current_timer_value = read_time_in_seconds();

    /* check for activity for NULL_TIMEOUT seconds */
    if ( (current_timer_value - last_timer_value) > server_timeout )
    {
      error_occurred("ServerError");
    }
    else
    {
      number_of_null_reads = 0;
    }
  }
}

/**************************************************************/
/* read_time_in_seconds()                                     */
/*                                                            */
/* Read the monotonic time divided by 100, as a float.        */
/*                                                            */
/* Returns:    Monotonic time / 100.                          */
/**************************************************************/

static float read_time_in_seconds(void)
{
  unsigned int t;

  _swix(OS_ReadMonotonicTime,
        _OUT(0),

        &t);

  return ((float) t) / 100;
}

/**************************************************************/
/* initialise_wimp()                                          */
/*                                                            */
/* Start up as a Toolbox task.                                */
/**************************************************************/

static _kernel_oserror * initialise_wimp(void)
{
  int            wimp_messages  = 0;
  int            toolbox_events = 0;
  static IdBlock id_block;

  /* As well as starting us as a Wimp task, the Toolbox opens the */
  /* Messages file too.                                           */

  return toolbox_initialise(0,                        /* Flags                                */
                            310,                      /* Minimum Wimp version                 */
                            &wimp_messages,           /* List of required messages            */
                            &toolbox_events,          /* List of required events              */
                            "<Fetch$Dir>",            /* Application directory                */
                            &meb,                     /* Messages file control block          */
                            &id_block,                /* Our application's local ID block     */
                            0,                        /* (Current wimp version returned here) */
                            0,                        /* (Task handle returned here)          */
                            (void *) &sprite_block);  /* Local sprite area returned here      */
}

/**************************************************************/
/* reset_machine()                                            */
/*                                                            */
/* Handler to reset the machine. Parameters are as standard   */
/* for a Toolbox event handler.                               */
/**************************************************************/

int reset_machine(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  _swix(OS_Reset, 0);

  return 0;
}

/**************************************************************/
/* quit_app()                                                 */
/*                                                            */
/* Handler to quit the application. Parameters are as         */
/* standard for a Toolbox event handler.                      */
/**************************************************************/

int quit_app(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  exit(EXIT_SUCCESS);

  return 0;
}

/**************************************************************/
/* return_free_memory()                                       */
/*                                                            */
/* Return the size of the Wimp free pool.                     */
/**************************************************************/

static unsigned int return_free_memory(void)
{
  unsigned int free;

  _swix(Wimp_SlotSize,
        _INR(0,1) | _OUT(2),

        -1, /* Read Current slot */
        -1, /* Read Next slot    */

        &free);

  return free;
}



/* This routine performs the fetching of the data from the URL.
   Here we get 32k chunks of data at a time.  If we can we try and read
  the number of bytes remaining to be read as soon as possible so as to
  ensure we don't run out of memory in the dynamic area.  If this isn't
  possible we allocate the memory on the fly and hope for the best !!

  The first part of the image shall be an header in the format as specified
   by the specification 2503/047/FS. This header consists of a series of
   Tag-Length-Value triplets that contain imformation about theimage embedded
   within the file.
  */
static bool fetch_data(const int session_identifier, const int dynamic_area_number, char** dynamic_area_current_ptr, const int server_timeout, const char* const dynamic_area_base)
{
  _kernel_oserror  * error                = NULL;
  _kernel_swi_regs   regs;
  char               buff_in [URL_CHUNK_SIZE];     /* Buffer for the latest chunk of data from the URL */
  int                raw_bytes_read;               /* Bytes read in a single pass */
  int                valid_bytes_read;             /* Bytes read minus any header bytes stripped */
  int                total_bytes_read     = 0;     /* Total bytes read */
  int                bytes_left_to_read   = -1;    /* Bytes left to read */

  bool               checked_free_memory  = false; /* If this flag is set then the program has recived the size
                                                    * of the file from the server, and has allocated the correct
                                                    * DA size. If it is unset, then as it reads some data from
                                                    * the URL it also allocates the memory for it to be put in.
                                                    */

  bool               started_getting_data = false; /* Flag */
  bool               success              = true;
  char             * end_of_last_tag      = (char *) dynamic_area_base;

  unsigned int       mem_da_size          = 0;
  unsigned int       mem_da_used          = 0;

  char             * start                = NULL;
  char             * data_out;                     /* Pointer to start of data */
  bool               finished_parsing     = false;
  int                l;
  char               state                = '?';
  int                got_http_header      = 0;

  while (!error)
  {
    dprintf(("Diag", "fetch_data (main.c): Bytes to read %d, total bytes read %d\n",
                     total_bytes_to_read,
                     total_bytes_read));

    /* Exit if we've got all the data */

    if (total_bytes_to_read > 0 && total_bytes_read == total_bytes_to_read) break;

    regs.r[0] = 0;
    regs.r[1] = session_identifier;
    regs.r[2] = (int) buff_in;
    regs.r[3] = URL_CHUNK_SIZE;

    /* Read next URL_CHUNK_SIZE sized chunk */

    error = _kernel_swi(URL_ReadData, &regs, &regs);

    /* Check to see that we have finished */

    if (error != NULL)
    {
      dprintf(("Fail", "fetch_data (main.c): Fetch error '%s'\n", error->errmess));

      regs.r[0] = 0;
      regs.r[1] = session_identifier;

      error = _kernel_swi(URL_Status, &regs, &regs);

      /* Transfer aborted, or all data not received? */

      if (error != NULL || !(regs.r[0] & 0x30)) /* Bit 5 set -> all data received */
      {
        error_occurred("ServerError");
      }

      /* Otherwise, should have all the data */

      break;
    }

    raw_bytes_read = regs.r[4];

    valid_bytes_read = raw_bytes_read;
    data_out         = buff_in;

    if (!got_http_header)
    {
      /* Search for the CR/LF/CR/LF at the end of the HTTP header */

      for (l = 0; l < raw_bytes_read; l++)
      {
        switch (state)
        {
          case '\r':
          {
            dprintf(("Diag", "fetch_data (main.c): State is '\\r'\n"));

            if (*data_out == '\n') state = '\n';
            else                   state = '?';
          }
          break;

          case '\n':
          {
            dprintf(("Diag", "fetch_data (main.c): State is '\\n'\n"));

            if (*data_out == '\r') state='R';
            else                   state='?';
          }
          break;

          case 'R':
          {
            dprintf(("Diag", "fetch_data (main.c): State is 'R'\n"));

            if (*data_out == '\n')
            {
              dprintf(("Diag", "fetch_data (main.c): Read final '\\n'\n"));

              state           = '\r';
              got_http_header = 1;
              l               = raw_bytes_read; /* Force end of for() loop */
            }
            else state = '?';
          }
          break;

          case '?':
          {
            if (*data_out == '\r') state = '\r'; /* Possible start of a CR/LF/CR/LF sequence */
          }
          break;
        }

        data_out++;
        valid_bytes_read--;
      }
    }


    if (valid_bytes_read > 0)
    {
      dprintf(("Diag", "fetch_data (main.c): have read %d bytes from the URL.\n", valid_bytes_read));

      /* update the variable holding the total bytes read */
      total_bytes_read += valid_bytes_read;

       // if we haven't already done so update the display
       if (started_getting_data == false)
       {
         status_print(lookup_token("Downloading",0,0));
         started_getting_data = true;
       }

       /* if we haven't already done so, check we have the required free ram. */
       if (checked_free_memory == false)
       {
        bytes_left_to_read = regs.r[5];

        /* if we receive notification of how much left */
        if (bytes_left_to_read != -1 || total_bytes_to_read > 0)
        {
          int amount_to_allocate;
          /* We now know (either from the server or the upgrade file itself) how much memory we need. Allocate it.*/
          if (bytes_left_to_read != -1)
          {
            total_bytes_to_read = bytes_left_to_read + total_bytes_read;
            amount_to_allocate = bytes_left_to_read + valid_bytes_read;
          }
          else
          {
            amount_to_allocate = total_bytes_to_read-mem_da_size;
          }

         /* allocate memory for the whole image */

         dprintf(("Diag", "fetch_data (main.c): Attempting to increase size of DA holding image by %d bytes (free memory in system is %d bytes).\n", amount_to_allocate, return_free_memory()));

         regs.r[0] = dynamic_area_number;
         regs.r[1] = amount_to_allocate;
         error = _kernel_swi(OS_ChangeDynamicArea, &regs, &regs);
         if (error)
         {
           dprintf(("Fail", "fetch_data (main.c): DA area increase failed - allocated %d bytes instead of the required %d bytes (message '%s').\n", regs.r[1], amount_to_allocate, error->errmess));
           error_occurred("NotEnoughMemory");
         }
         else
         {
           mem_da_size+=amount_to_allocate;
           mem_da_used+=valid_bytes_read;
         }

         checked_free_memory = true;
       }
     }

     /* If we still don't know how large the image is allocate enough
         for the currently read block (dynamically). This needs to be done to the nearest page size. */
     if (checked_free_memory == false)
     {
       double d_mem_requested = (double) valid_bytes_read;
       int i_mem_requested;
       d_mem_requested = ceil(d_mem_requested/4096)*4096; /* Page-align it */
       i_mem_requested = (int)d_mem_requested;
       dprintf(("Diag", "fetch_data (main.c): We want %d more bytes (free memory in system is %d bytes).\n", i_mem_requested, return_free_memory()));
       dprintf(("Diag", "fetch_data (main.c): Current DA size is %d bytes, used is %d bytes\n", mem_da_size, mem_da_used));

       /* If we have not got enough space in the da, increase the size. */
       if ((i_mem_requested+mem_da_used) >= mem_da_size)
       {
         dprintf(("Diag", "fetch_data (main.c): Increasing size of the DA by %d bytes.\n", i_mem_requested));

         regs.r[0] = dynamic_area_number;
         regs.r[1] = i_mem_requested;
         error = _kernel_swi(OS_ChangeDynamicArea, &regs, &regs);
         if (error)
         {
           dprintf(("Fail", "fetch_data (main.c): Incremental DA area increase failed - allocated %d bytes instead of the required %d bytes (message %s).\n", regs.r[1], valid_bytes_read, error->errmess));
           error_occurred("NotEnoughMemory");
         }
         else
         {
           mem_da_size+=i_mem_requested;
           mem_da_used+=valid_bytes_read;
         }
       }
       else
       {
         mem_da_used+=valid_bytes_read;
       }
     }
     else
     {
       mem_da_used+=valid_bytes_read;
       dprintf(("Diag", "fetch_data (main.c): Current DA size is %d bytes, used is %d bytes\n", mem_da_size, mem_da_used));
     }

     /* If the memory allocation has worked, copy the memory over and update the status screen. */
     if (!error)
     {
       /* copy the memory block into the dynamic area */
       dprintf(("Diag", "fetch_data (main.c): Copying %d bytes of memory\n", valid_bytes_read));
       memcpy(*dynamic_area_current_ptr, data_out, valid_bytes_read);
       update_status_screen(total_bytes_read, total_bytes_to_read);
       *dynamic_area_current_ptr += valid_bytes_read; // increment the memory pointer
     }
     else
     {
       dprintf(("Fail", "fetch_data (main.c): Error allocating dynamic area (%s)\n", error->errmess));
     }

     start = end_of_last_tag;
     finished_parsing = false;

     while (!finished_parsing && end_of_last_tag != *dynamic_area_current_ptr) /* We wish to get all the complete tags out of this block. */
     {
       char *complete_tag = is_tag_complete(end_of_last_tag, *dynamic_area_current_ptr);
       dprintf(("Diag", "fetch_data (main.c): end_of_last_tag = &%08X, *dynamic_area_current_ptr = &%08X\n", (int) end_of_last_tag, (int) *dynamic_area_current_ptr));
       if (complete_tag) /* Tag is complete, add it to the list. */
       {
         /* Now act on the tags that we need to act on during download. */
         if (return_tag_type(start, *dynamic_area_current_ptr) == TLV_TAG_TYPE_FILE_SIZE) /* File size */
         {
           int file_size = read_little_word(start+8);
           dprintf(("Diag", "fetch_data (main.c): This is a file size tag. Size of downloadable file is %d\n", file_size));
           /* We wish to set the size of the downloaded file now that we know it. */
           total_bytes_to_read = file_size;
         }
         if (return_tag_type(start, *dynamic_area_current_ptr) == TLV_TAG_TYPE_DISPLAY_STRING) /* String to display */
         {
           dprintf(("Diag", "fetch_data (main.c): This is a string tag. String is '%s'\n", start+8));
           status_print(start+8);
         }
         if (return_tag_type(start, *dynamic_area_current_ptr) == TLV_TAG_TYPE_BUILD_LIST) /* A list of builds to which this image can be applied. */
         {
           /* do it later! */
         }
         end_of_last_tag = complete_tag;
         add_node(return_tag_type(start, *dynamic_area_current_ptr), return_tag_length(start, *dynamic_area_current_ptr), start+8);
         start = end_of_last_tag; /* Reset the start to point back to the end of te newly completed tag. */
       }
       else
       {
         /* Make it point back to the start of this tag again. */
         dprintf(("Diag", "fetch_data (main.c): Incomplete tag. Setting end_of_last_tag back to &%08X and waiting for more data to be downloaded.\n", (int) end_of_last_tag));
         end_of_last_tag = (char*)start;
         finished_parsing = true;
       }
     }

     /* reset the null reads counter */
     number_of_null_reads = 0;
     last_timer_value = 0;
    }
    else
    {
      /* if no bytes have been read from the URL */
      check_for_timeout(server_timeout);
    }

    /* poll the wimp to update any toolbox changes */
    poll_wimp();
  }

  return (success);
}





/* This routine returns the type of the tag held at the memory location
base_pointer. It returns -1 if the tag type is incomplete (i.e. only three of
the four bytes needed have been downloaded). Typically base_poiner would be
the known start point of a tag (or the beginning of the memory area if no
complete tag has yet been found), and end_pointer the end of the currently
downloaded memory. */

static int return_tag_type(const char* const base_pointer, const char* end_pointer)
{
  int tag_type = -1;

  /* Ensure that at least four bytes have been downloaded */
  if (end_pointer-base_pointer < 4)
  {
    dprintf(("Fail", "return_tag_type (main.c): Tag type data is incomplete\n"));
    tag_type = -1;
  }
  else
  {
    /* Convert the word to an integer */
    tag_type = (int) *base_pointer;
    if (tag_type < 0)
    {
      /* The tag_type should be positive (according to the spec) */
      dprintf(("Fail", "return_tag_type (main.c): Error: the tag_type should be positive according to the spec.\n"));
    }
  }

  dprintf(("Diag", "return_tag_type (main.c): The tag is of type %d\n", tag_type));

  return (tag_type);
}





unsigned int read_little_word(const char* const buff)
{
    unsigned int i = 0;

    i = (*(buff)) | ((*(buff+1))<<8) | ((*(buff+2))<<16) | ((*(buff+3))<<24);

    return(i);
}



/* This routine returns the langth of the tag held at the memory location
base_pointer. It returns -1 if the tag type is incomplete (i.e. only three of
the four bytes needed have been downloaded). Typically base_poiner would be
the known start point of a tag (or the beginning of the memory area if no
complete tag has yet been found), and end_pointer the end of the currently
downloaded memory. */

static int return_tag_length(const char* const base_pointer, const char* end_pointer)
{
  int tag_length = -1;

  /* Ensure that at least eight bytes have been downloaded (this must be the case if the length has been completely doenloaded */
  if (end_pointer-base_pointer < 8)
  {
    dprintf(("Fail", "return_tag_length (main.c): Tag length data is incomplete\n"));
    tag_length = -1;
  }
  else
  {
    char *length_pointer = (char*)(base_pointer+4); /* Ignore the first word */
    /* Convert the word to an integer */
    tag_length = (int)read_little_word(length_pointer);
    if (tag_length < 0)
    {
      /* The tag_type should be positive (according to the spec) */
      dprintf(("Fail", "return_tag_length (main.c): Error: the tag length should be positive according to the spec.\n"));
    }
  }

  dprintf(("Fail", "return_tag_length (main.c): The tag is of length %d\n", tag_length));

  return (tag_length);
}




/* This routine can be used to detect whether the tag which starts at
base_pointer is complete. It retrieves the type of the tag and the length,
and checks that the entire contents of the tag (type, length and value) have
been downloaded. It assumes that base_pointer points at the start of a tag.
   It returns NULL if it is incomplete, or the end of tag if it is complete. */

static char* is_tag_complete(const char* const base_pointer, const char* const end_pointer)
{
  /* Note: This routine relies on some nasty pointer arithmetic, and assumes
that the memory block is contiguous. */
  char* end_of_tag  = NULL;
  int tag_type, tag_length;

  dprintf(("Diag", "is_tag_complete (main.c): Called\n"));

  tag_type = return_tag_type(base_pointer, end_pointer);
  tag_length = return_tag_length(base_pointer, end_pointer);

  /* Ensure that the tag has been fully downloaded, i.e. that end_pointer -
base_pointer is greater than 8+the tag length. (the 8 comes from the combined
size of the tag and length values in bytes). */
  dprintf(("Diag", "is_tag_complete (main.c): base_pointer is &%08X end_pointer is &%08X\n", (int) base_pointer, (int) end_pointer));
  dprintf(("Diag", "is_tag_complete (main.c): end_pointer-base_pointer is %d\n", (int)(end_pointer-base_pointer)));
  if ((int)(end_pointer-base_pointer) <= 0)
  {
    dprintf(("Fail", "is_tag_complete (main.c): Error, end_pointer-base_pointer should be positive.\n"));
    exit (EXIT_FAILURE);
  }
  if (end_pointer-base_pointer < (8+tag_length))
  {
    dprintf(("Fail", "is_tag_complete (main.c): The tag is not yet complete. Current tag size is %d, known tag length is %d\n", (int)(end_pointer-base_pointer), 8+tag_length));
    return (end_of_tag);
  }

  end_of_tag = (char*)base_pointer+8+tag_length; /* +8 to skip over Tag+Length */
  return (end_of_tag);
}


#ifdef ENABLE_DEBUGGING

/* This routine decodes the file once it has been downloaded into a series of
 TLV values in a linked list.
*/
static void decode_file(const char* const memory_base, const char* const memory_end)
{
  // This points to the end of the last tag found, i.e. the start of the next tag. Whenever a tag is found this gets moved up as appropriate.
  char* end_of_last_tag = (char*)memory_base;

  dprintf(("Diag", "decode_file (main.c): Called\n"));
  end_of_last_tag = is_tag_complete(end_of_last_tag, memory_end);
  while (end_of_last_tag && end_of_last_tag < memory_end)
  {
    const char* const start = end_of_last_tag;
    dprintf(("Diag", "decode_file (main.c): end_of_last_tag = &%08X, memory_end = &%08X\n", (int) end_of_last_tag, (int) memory_end));
    end_of_last_tag = is_tag_complete(end_of_last_tag, memory_end);
    if (end_of_last_tag) // Tag is complete, add it to the list.
    {
      add_node(return_tag_type(start, memory_end), return_tag_length(start, memory_end), start+8);
    }
  }
}

#endif

/* Parse and display the list of TLV nodes */
static void display_linked_list(void)
{
  dprintf(("Diag", "display_linked_list (main.c): Called\n"));

  if (tlv_list_head == NULL)
  {
    dprintf(("Fail", "display_linked_list (main.c): No list generated.\n"));
  }
  else
  {
    tlv_list_node_type *tlv_node_current = tlv_list_head;
    do
    {
      /* Display the node details... */
      dprintf(("Diag", "display_linked_list (main.c): Tag is of type %d length %d\n", tlv_node_current->tag_type, tlv_node_current->tag_length));

      /* Move onto the next node... */
      tlv_node_current = tlv_node_current->next_tag;
    }
    while (tlv_node_current != NULL);
  }
}


/* This goes through the list and frees all memory allocated. */
static void free_list(void)
{
  dprintf(("Diag", "free_list (main.c): Called\n"));

  if (tlv_list_head == NULL)
  {
    dprintf(("Diag", "free_list (main.c): Null list.\n"));
  }
  else
  {
    tlv_list_node_type *tlv_node_current = tlv_list_head;
    do
    {
      tlv_list_node_type* node_to_delete = tlv_node_current;

      dprintf(("Diag", "free_list (main.c): Freeing node..\n"));

      /* Move onto the next node... */
      tlv_node_current = tlv_node_current->next_tag;

      /* And free the node to be deleted. */
      if (node_to_delete)
      {
        free (node_to_delete);
        node_to_delete = NULL;
      }
    }
    while (tlv_node_current != NULL);
  }

  /* Finally set the head pointer to NULL. */
  tlv_list_head = NULL;
}


/* This routine is called after the download has completed so that we can act
on the TLV tags. For instance in this routine the CRC check is called. */

static void decode_tlv_tags_after_download(void)
{
  dprintf(("Diag", "decode_tlv_tags_after_download (main.c): Called\n"));

  /* Scan through the list of tags, acting on each of them in turn. */
  if (tlv_list_head == NULL)
  {
    dprintf(("Fail", "decode_tlv_tags_after_download (main.c): No list generated.\n"));
  }
  else
  {
    tlv_list_node_type *tlv_node_current = tlv_list_head;
    do
    {
      /* Now act on this TLV type. */
      switch (tlv_node_current->tag_type)
      {
        case TLV_TAG_TYPE_FILE_SIZE:
          break;
        case TLV_TAG_TYPE_DISPLAY_STRING:
          break;
        case TLV_TAG_TYPE_BUILD_LIST:
          checkBuild(tlv_node_current->value_pointer);
          break;
        case TLV_TAG_TYPE_LOCALE_LIST:
          break;
        case TLV_TAG_TYPE_IMAGE_TYPE:
          break;
        case TLV_TAG_TYPE_IMAGE_LENGTH:
          break;
        case TLV_TAG_TYPE_IMAGE_DATA:
          break;
        case TLV_TAG_TYPE_FILE_CRC:
          {
          unsigned int crc_value = read_little_word(tlv_node_current->value_pointer);
          dprintf(("Diag", "decode_tlv_tags_after_download (main.c): This is a CRC of value %d.\n", crc_value));
          crc_validated = validate_crc(crc_value, tlv_node_current->value_pointer-8);
          }
          break;
        case TLV_TAG_TYPE_RANDOM_DATA:
          break;
        case TLV_TAG_TYPE_UNRECOGNISED:
          break;
        case TLV_TAG_TYPE_BANK:
          memory_bank=read_little_word(tlv_node_current->value_pointer);
          break;
        default:
          break;
      }

      /* Move onto the next node... */
      tlv_node_current = tlv_node_current->next_tag;
    }
    while (tlv_node_current != NULL);
  }
}


// /* This routine scans through the list of TLV's and does what is necessary after the whole file has been downloaded. Currently we do not need to do anything after the file has been downloaded. */
// void decode_tags_after_download(void)
// {
//   dprintf(("Diag", "decode_tags_after_download (main.c): Called\n"));
//
//   if (tlv_list_head == NULL)
//   {
//     dprintf(("Diag", "decode_tags_after_download (main.c): Null list.\n"));
//   }
//   else
//   {
//     tlv_list_node_type *tlv_node_current = tlv_list_head;
//     do
//     {
//       // decode this tag...
//
//       // Move onto the next node...
//       tlv_node_current = tlv_node_current->next_tag;
//     }
//     while (tlv_node_current != NULL);
//   }
// }

// helo


/* This routine can be used to scan through a list of TLV's and return the
    first one that it comes across of a certain type. */
static tlv_list_node_type * return_tlv_of_type(const unsigned int type)
{
  dprintf(("Diag", "return_tlv_of_type (main.c): Called\n"));

  if (tlv_list_head == NULL)
  {
    dprintf(("Fail", "return_tlv_of_type (main.c): No list generated.\n"));
  }
  else
  {
    tlv_list_node_type *tlv_node_current = tlv_list_head;
    do
    {
      /* Is this node of the type that we want... */
      if (tlv_node_current->tag_type == type)
      {
        return (tlv_node_current);
      }

      /* Move onto the next node... */
      tlv_node_current = tlv_node_current->next_tag;
    }
    while (tlv_node_current != NULL);
  }

  return (NULL);
}







/* This routine adds a node to the list of TLV values. */
static void add_node(const int type, const int length, const char* const location)
{
  tlv_list_node_type* temp_node;

  dprintf(("Diag", "add_node (main.c): Creating node with data: tag %d length %d location &%08X\n", type, length, (int) location));

  /* Creatte the new node */
  temp_node = malloc(sizeof(tlv_list_node_type));
  if (!temp_node)
  {
    dprintf(("Fail", "add_node (main.c): Failed to add node (memory allcation error)\n"));
    exit(EXIT_FAILURE);
  }

  /* Copy over the data */
  temp_node->tag_type = type;
  temp_node->tag_length = length;
  temp_node->value_pointer = (char*)location;
  temp_node->next_tag = NULL;

  /* If no node has been allocated, allocate one */
  if (tlv_list_head == NULL)
  {
    dprintf(("Diag", "add_node (main.c): Creating the first (head) node.\n"));
    tlv_list_head = temp_node;
    tlv_list_tail = tlv_list_head;
  }
  else
  {
    dprintf(("Diag", "add_node (main.c): Adding another node.\n"));
    tlv_list_tail->next_tag = temp_node;
    /* And move the tail onto the newly allocated node */
    tlv_list_tail = tlv_list_tail->next_tag;
  }
}



/* This routine checks that the image is correct up to the passed location.
It returns true if the crc matches, false oterwise. */

static bool validate_crc(unsigned int expected_crc, const char* const end_location)
{
  unsigned int crc;
  unsigned int size = 0;
  char* ch;

  dprintf(("Diag", "validate_crc (main.c): We are expecting an end value of %d\n", expected_crc));

  make_crc_tables();

  dprintf(("Diag", "validate_crc (main.c): CRC tables constructed\n"));

  /* Ensure that we are not attmepting to read from NULL */
  if (dynamic_area_base_address == NULL)
  {
    dprintf(("Diag", "validate_crc (main.c): Urgh, dynamic_area_base_address is NULL. Bailing.\n"));
    return (false);
  }

  /* crc precondition */
  crc=0xffffffff;

  dprintf(("Diag", "validate_crc (main.c): CRCed image follows:\n"));

  ch = dynamic_area_base_address;
  do
  {
    update_crc((U8*)ch,(U32*)&crc);
    size++;
    ch++;
  }
  while(ch < end_location);

  /* crc postcondition */
  crc ^= 0xffffffff;

  dprintf(("Diag", "validate_crc (main.c): CRC generated is %ud\n", crc));

  /* Ensure that the crc matches the expected value. */
  if (crc == expected_crc)
  {
    return (true);
  }
  else
  {
    dprintf(("Diag", "validate_crc (main.c): The CRC's mismatch (size of CRC'd image was %d).\n", size));
    error_occurred("CRCMismatch");
  }

  return (false);
}

static void checkBuild(char *builds)
{
  _kernel_swi_regs regs;
  _kernel_oserror *error = NULL;

  //the OSversion string should contain the build
  char *OSver,*token;
  char build_list[80];

  //get the OS version string
  regs.r[0] = 0;
  regs.r[1] = 0;
  error = _kernel_swi(OS_Byte, &regs, &regs);
  OSver=error->errmess;

  dprintf(("Diag", "fetch_data (main.c): OS version is %s\n", OSver));

  //point to the build list
  strcpy(build_list,builds);

  dprintf(("Diag", "fetch_data (main.c): build list : %s\n", build_list));

  //get the first token in the build list
  token=strtok(build_list,", ");

  do
  {
    dprintf(("Diag", "fetch_data (main.c): token : %s\n", token));
    //if we find the token break out of the loop
    if (strstr(OSver,token) != NULL) break;
    token=strtok(NULL,", ");
   }
   while (token !=NULL);

   if (token==NULL)
     {
       dprintf(("Diag", "fetch_data (main.c): Invalid Build"));
       error_occurred("WrongBuild");
     }
     else
     {
       dprintf(("Diag", "fetch_data (main.c): Correct Build"));
     }
}



/* This routine sets up a proxy with the URL module */
static bool setup_proxy(const unsigned int session)
{
  char* ftp_proxy = NULL;
  char full_proxy[100];
  int tag_size = -1;
  _kernel_swi_regs regs;
  _kernel_oserror *err;

  /* Read the FTP proxy from NCMAlite */
  regs.r[0] = (int)"FTP_PROXY";
  regs.r[1] = NULL;
  regs.r[2] = 0;

  err = _kernel_swi(NCMATwin_Enquiry, &regs, &regs);
  if (err!=NULL)
  {
    dprintf(("Fail", "setup_proxy (main.c): Error whilst trying to get FTP proxy from NCMA.\n"));
    return (false);
  }

  tag_size = regs.r[0];
  if (tag_size <= 0)
  {
    dprintf(("Fail", "setup_proxy (main.c): FTP proxy tag does not exist..\n"));
    return (false);
  }
  else
  {
    if ((ftp_proxy = malloc(tag_size+2)) == NULL)
    {
      dprintf(("Fail", "setup_proxy (main.c): Error allocating %d bytes of memory for tag.\n", tag_size));
      return (false);
    }
    else
    {
      regs.r[0]=(int)"FTP_PROXY";
      regs.r[1]=(int)ftp_proxy;
      regs.r[2]=tag_size;

      err = _kernel_swi(NCMATwin_Enquiry, &regs, &regs);
      if (err!=NULL)
      {
        dprintf(("Fail", "setup_proxy (main.c): Error whilst trying to get FTP proxy from NCMA.\n"));
        return (false);
      }
    }
  }

  dprintf(("Diag", "setup_proxy (main.c): Proxy is %s\n", ftp_proxy));

  /* Create full proxy URL. We really should ensure that it does not already have the http:// or the / at the end before adding them. */
  strcpy(full_proxy,"http://");
  strcat(full_proxy,ftp_proxy);
  strcat(full_proxy,"/");

  dprintf(("Diag", "setup_proxy (main.c): full Proxy is %s\n", full_proxy));

  /* Register the proxy */
  regs.r[0] = 0;
  regs.r[1] = session;
  regs.r[2] = (int)full_proxy;
  regs.r[3] = (int)"ftp:";
  regs.r[4] = 0;
  err = _kernel_swi(URL_SetProxy, &regs, &regs);
  if (err!=NULL)
  {
    dprintf(("Fail", "setup_proxy (main.c): Error whilst trying to set FTP proxy\n"));
    return (false);
  }

  return (true);
}



#if defined(USE_TRUSTED_DOMAINS) || defined(TEST_TRUSTED_DOMAINS_CODE)

// /*       Search for Substring s1 in String p1
//          ------------------------------------
//
// Returns true if string at s1 to s2 occurs anywhere in string at p1 to p2.
// Note that strings are NOT null terminated, as the end pointers point to the terminating character
// (ie the next character after the end of the string).
//
// Using this approach avoids using fixed sized buffers which might overflow.
// */
//
// static bool instring(const char* p1, const char *p2, const char *s1, const char *s2)
// {
//   const char *s, *p;
//
//   while (p1<p2)
//   {
//     s=s1;       /* Rewind to start of sub-string. We are about to check if this occurs at th current p1 */
//     p=p1;       /* p is pointer into string we are searching in. We advance p as we do the char match */
//
//     while (*s==*p && s<s2 && p<p2)  /* keep searching while chars in both strings match and we are not at end of either one */
//     {
//       s++; p++;                /* Matches so far, and not at end of either so move on to next char */
//       if (s==s2) return true;  /* Substring s1 matches substring p1, and reached end of substring s1
//                                   ie substring s1 occurs in its entirety in p1. */
//     }
//     p1++; /* Try next position within p1 string */
//   }
//   return false;
// }

/*       Check Whether Substring s1 is the Rightmost String in p1
         --------------------------------------------------------

Returns true if string at s1 to s2 appears as the rightmost string in the string at p1 to p2.
Note that strings are NOT null terminated, as the end pointers point to the terminating character
(ie the next character after the end of the string).

For example:
   s1="pace.co.uk" and p1="download.pace.co.uk" would return true
   s1="pace.co.uk" and p2="ace.co.uk" would return false
   s1="pace.co.uk" and p2="pace.co.uk.fooledyou.co.uk" would return false

Using this approach avoids using fixed sized buffers which might overflow.
*/

static bool rightmatches(const char* p1, const char *p2, const char *s1, const char *s2)
{
  const char *s, *p;

  s=s2-1;  /* Point to last char in s string */
  p=p2-1;  /* Point to last char in p string */

  while (s>=s1 && p>=p1 && tolower(*s)==tolower(*p))  /* Test that characters match, stepping backwards through both strings */
  {
    s--, p--;
  }

  return s<s1;     /* Success if we found whole of s string at end of p, otherwise fail */
}



/* This routine checks that the url passed in is an allowed domain. The rules for detecting a valid domain are as follows:
   * Anything before (and including) a :// is stripped (e.g. http:// or ftp://)
   * Anything after (and including) the next / is stripped (e.g. /upgrades/ftp)
   * The remainder is now checked against each of the allowed domains in turn. The matching is done in a substring manner, with pace.co.uk matching both support.pace.co.uk, upgrades.pace.co.uk and pace.co.uk?upgrades, but not http://hackers_r_us@hacknet.net/pace.co.uk
   This routine returns true if the domain matches, false otherwise.
*/

static bool validate_domain(const char * const url, const char * const allowed_domains)
{
  #ifdef USE_CHECKURL

    _kernel_oserror * e;
    char            * domains_copy;
    const char      * p;
    char            * c;
    unsigned int      commas;
    unsigned int      area_id;
    unsigned int      flags;

    if (
         url              == NULL ||
         allowed_domains  == NULL ||
         *url             == '\0' ||
         *allowed_domains == '\0'
       )
    {
      dprintf(("Fail", "validate_domain (main.c): Invalid parameters, returning 'false'\n"));
      return false;
    }

    /* This is a bit awkward. The domain list passed in is comma separated and */
    /* has no fragments, so count the number of items in the list by counting  */
    /* commas, allocate space including an extra two characters for each comma */
    /* so we can put " -" in there to give a parameter for each domain to keep */
    /* CheckURL happy, copy the domains with that extra specifier, and finally */
    /* pass the whole thing to CheckURL. Then the URL can be checked.          */

    p      = allowed_domains;
    commas = 1;

    while (*p != '\0') if (*(p++) == ',') commas++;

    /* Allocate space for fragment / parameter pairs. A comma is replaced by */
    /* a space, hyphen and '\n'; there's an extra space and hyphen at the    */
    /* end too, along with the NUL. Hence '+3' below. Since any white space  */
    /* in allowed_domains is stripped out, the maximum possible amount is    */
    /* being calculated - so, safe.                                          */

    domains_copy = malloc(strlen(allowed_domains) + (commas * 2) + 3);

    if (domains_copy == NULL)
    {
      dprintf(("Fail", "validate_domain (main.c): Can't allocate space for copy of domains\n"));
      quit("NotEnoughMemory");
    }

    /* Copy the domains list in a format for Check URL */

    p = allowed_domains;
    c = domains_copy;

    while (*p != '\0')
    {
      if (*p == ',')
      {
        *(c++) = ' ';
        *(c++) = '-';
        *(c++) = '\n';
      }
      else if (*p > ' ')
      {
        *(c++) = *p;
      }

      p++;
    }

    *(c++) = ' ';
    *(c++) = '-';
    *c     = '\0';

    /* Add the domains in a temporary area */

    e = _swix(CheckURL_AddArea,
              _INR(0,2) | _OUT(1),

              0,
              UpgFetch_CheckURLArea,
              domains_copy,

              &area_id);

    free(domains_copy);

    if (e != NULL)
    {
      dprintf(("Fail", "validate_domain (main.c): Error '%s' from CheckURL_AddArea, returning 'false'\n", e->errmess));
      return false;
    }

    /* Check the given URL; delete the temporary area regardless of outcome */

    e = _swix(CheckURL_Check,
              _INR(0,2) | _OUT(0),

              CU_Check_OnEntry_GivenAreaID,
              area_id,
              url,

              &flags);

    _swix(CheckURL_DeleteArea,
          _INR(0,1),

          CU_DeleteArea_OnEntry_GivenAreaID,
          area_id);

    if (e != NULL)
    {
      dprintf(("Fail", "validate_domain (main.c): Error '%s' from CheckURL_Check, returning 'false'\n", e->errmess));
      return false;
    }

    if ((flags & CU_Check_OnExit_MatchFound) != 0) return true;
    else                                           return false;

  #else

    const char *host_start, *host_end;
    const char *domain_start, *domain_end;

    dprintf(("Diag", "validate_domain (main.c): url is %s domains are %s\n", url, allowed_domains));

    if ((host_start = strstr(url, "://")) == NULL)
    {
      dprintf(("Fail", "validate_domain (main.c): Cannot locate :// in url.\n"));
      return (false);
    }
    host_start+=3; /* Move to beyond the :// */

    host_end = strchr(host_start, '/');  /* Find end of the host name in the URL, ie the trailing / */
    if (host_end == NULL)               /* No trailing / so use end of string */
      host_end=host_start+strlen(host_start);

    dprintf(("Diag", "validate_domain (main.c): Stripped line is %s\n", host_start));

    /* Now scan through the allowed domains, checking if there is a substring match. */
    domain_start=allowed_domains;
    while (*domain_start!=NULL)
    {
      while (*domain_start==' ')
        domain_start++;         /* Skip leading spaces before the domain (ie it might be "pace.co.uk, funai.co.uk") */
      domain_end=domain_start;
      while (*domain_end && *domain_end !=',' && *domain_end !=' ')
        domain_end++;    /* Look for end of the domain string, either a null, a comma or a space*/
      if (rightmatches(host_start, host_end, domain_start, domain_end))
      {
        dprintf(("Diag", "validate_domain (main.c): domains %s and %s match\n", host_start, domain_start));
        return (true);
      }
      domain_start=domain_end;  /* Skip over this domain */
      if (*domain_start)
        domain_start++;         /* Try next domain, if there is one */
    }
    return (false);  /* No match */

  #endif
}

#endif /* USE_TRUSTED_DOMAINS */



static void start_iconhigh(void)
{
  if (
       _swix(IconHigh_Start,
             _IN(0),

             0) /* Highlight (not pointer) emulation */

       != NULL
     )
  {
    dprintf(("Fail", "start_IconHigh (main.c): SWI call failed\n"));
///    exit(EXIT_FAILURE);
  }
}

/**************************************************************/
/* catch_errors()                                             */
/*                                                            */
/* Catch OS errors and report them with the opportunity to    */
/* continue or quit (done inside main itself).                */
/*                                                            */
/* This is the last function in the file since it plays       */
/* around with stack checking, and you can't read the         */
/* previous state. If this was in the middle of the source    */
/* and someone wrote a #pragma above it, endless confusion    */
/* could otherwise arise as to why the instruction had no     */
/* effect on some of the functions here...                    */
/*                                                            */
/* Parameters: The signal number (ignored).                   */
/**************************************************************/

#pragma no_check_stack

static void catch_errors(int signum)
{
  /* Store the error locally */

  StrLastE;

  /* Go back to main to report the error */

  longjmp(env, Main_FromCatchErrors);

  /* Just in case... */

  exit(EXIT_FAILURE);
}
