/**************************************************************/
/* File:    main.h                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: To run.                                           */
/*                                                            */
/* Author:  Mark Robertshaw; Nick Evans; Andrew Hodgkinson.   */
/*                                                            */
/* History: 26-Sep-2000 (MR):  Created.                       */
/*          10-Oct-2000 (NE):  Added CRC check.               */
/*          11-Oct-2000 (NE):  Added build check.             */
/*          12-Oct-2000 (NE):  Added Flash Bank.              */
/*          01-May-2001 (ADH): Lots of reorganisation, fixes, */
/*                             restructuring, rewriting...    */
/**************************************************************/

/*
 * This application performs the first part of a two part upgrade procedure
 * for upgrading the operating system on an NC without the need for a
 * separate operating system ("maintenance OS").
 *
 * The application fetches a compressed OS image from a supplied URL via FTP
 * and stores it in a dynamic area.  It then triggers a separate application
 * to reprogram the flash memory with the new image.
 *
 * The program provides a Wimp interface for the download process showing a
 * bar chart of the progress of the download along with status information.
 * The program launches the programming task as soon as the download is
 * complete.
 *
 * Versions post-dating 30-Apr-2001 may also take a textual configuration
 * file and pass it on for setting NVRAM details (e.g. to reconfigure the
 * ISP details), or take a packed archive containing an application to run,
 * put it in CacheFS, execute it, and tidy up afterwards.
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <setjmp.h>
#include <signal.h>
#include <math.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimplib.h>
#include <tboxlibs/toolbox.h>
#include <tcpiplibs/dirent.h>

#define __BORLANDC__ 0
#include <zlib/zlib.h>

#include <DebugLib/DebugLib.h>

#ifdef USE_CHECKURL
  #include <CheckURL.h>
#endif

#include "VersionNum"

#include "crc32.h"
#include "Dirs.h"
#include "Errors.h"
#include "Kill.h"
#include "Structures.h"
#include "UI.h"
#include "Utils.h"
#include "URLUtils.h"
#include "URLVeneer.h"

#include "main.h"

/* The flag below states how much data we wish to read from the */
/* URL at any time.                                             */

#define Main_ChunkSize      32768

/* Extract buffer size for zlib decompression of archives */

#define Main_Extract        32768

/* Leaf name for UID file and subdirectory for extracted archive data; */
/* the length of the directory string MUST be equal to or greater than */
/* that of the UID leaf. The length of the wrapper name is arbitrary.  */

#define Main_Archive_Subdir  ".Data"
#define Main_Archive_UID     ".UID"
#define Main_Archive_Wrapper ".!Run"

/* Kick-off command etc. */

#define Main_Archive_Kickoff "Obey -c"
#define Main_Archive_Append  ""
#define Main_UpgLaunch_Run   "<" Module_ComponentName "$Dir>.UpgLaunch"
#define Main_UpgLaunch_Slot  "WimpSlot -Min 20K -Max 20K"

/* Filetypes */

#define Main_FileType_Text  0xFFF
#define Main_FileType_Obey  0xFEB
#define Main_FileType_EPROM 0xFE5

/* Temporary CheckURL area name */

#define Main_CheckURLArea   "UpgFetch_TemporaryValidationArea"

/* Tidy up some #ifdefs */

#if defined(USE_TRUSTED_DOMAINS) || defined(TEST_TRUSTED_DOMAINS_CODE)
  #define CHECK_DOMAINS
#else
  #undef CHECK_DOMAINS
#endif

/* Should we allow OS_Reset to be called ever? */

#define ALLOW_RESETTING

/* Decoding images */

typedef struct decoder_state
{
  unsigned int   crc;
  bool           crc_lock;

  /* State variables for reading a tag number */

  bool           expecting_tag;
  unsigned int   reading_tag;
  unsigned int   tag;

  /* State variables for reading the data size after the tag number */

  bool           expecting_size;
  unsigned int   reading_size;
  unsigned int   size;

  /* State variables for reading the data itself */

  bool           expecting_data;
  unsigned int   reading_data;

  /* State variables for reading specific words */

  unsigned int   reading_word;
  unsigned int   word;

  /* General operation state variables */

  bool           lock_first;
  FILE         * fout;
  int            ptr;
  char           extract_to [512];
  char           uid_name   [512]; /* Must be same as extract_to */

  /* Storage for information about this file */

  image_type     type_of_image;
  unsigned int   decomp_size;
  unsigned int   file_crc;
  unsigned int   archive_uid;
  bool           have_uid;
  bool           matched_uid;

  char         * build;
  char         * locale;
  char         * display;

  /* Successful fetch (set at CRC match)? */

  bool           success;

  /* Specific image type decoding */

  struct
  {
    bool           expecting_stubname;
    int            reading_stubname;
    char         * stubname;
    char         * fullname;
    char         * first_fullname;
    int            subtype;

    unsigned int   stage;

    unsigned int   reading_word;
    unsigned int   word;

    /* Check for a multitasking application? */

    char         * task_name;
    action_type    action;

    /* Decompression variables */

    bool           restart_zlib;
    z_stream       stream;

    /* Storage for information about a file inside the archive */

    unsigned int   itemsize;
    unsigned int   loadaddr;
    unsigned int   execaddr;
    unsigned int   itemattr;

    /* Cumulative file information for the UID file */

    unsigned int   total_items; /* Includes all directories  */
    unsigned int   total_size;  /* Files and image dirs only */

    /* Flag to say a complete file / directory entry has been dealt with */
    /* (tidy up and reset local state machine for the next one)          */

    bool           completed;

  } archive;

  struct
  {
    unsigned int   not_tag;
    unsigned int   total;

  } image;

} decoder_state;

/* Local variables */

#ifdef DEBUGLIB

  static char       * type_names []       = {
                                              "OS image",
                                              "Font upgrade",
                                              "Exec special",
                                              "Transient executable",
                                              "Resident executable",
                                              "Permanent executable"
                                            };

  static char       * action_names[]      = {
                                              "no action",
                                              "abort",
                                              "replace"
                                            };

#endif

static char         * extract_path        = NULL;  /* Set up if extracting an archive, allowing tidy-up if the download is aborted */
static FILE         * extract_fout        = NULL;  /* We might be holding a file open when we want to wipe the partial download... */

static char         * dynamic_area_base   = NULL;
static unsigned int   dynamic_area_number = 0;
static unsigned int   dynamic_area_size   = 0;
static unsigned int   total_bytes_to_read = 0;     /* Total bytes to read - this can be obtained from either the FTP server or the filelength tag */
static unsigned int   last_timer_value    = 0;     /* Used for timeouts */

static bool           session_registered  = false; /* Record whether or not we should deregister with the URL module in the atexit handler */
static unsigned int   session_identifier  = 0;

/* Local functions */

static void                 exit_handler                   (void);

static void                 check_for_timeout              (const unsigned int server_timeout);

static _kernel_oserror    * main_initialise_toolbox        (void);
static _kernel_oserror    * main_initialise_eventlib       (void);

static int                  reset_machine                  (int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle);
static int                  quit_app                       (int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle);
static int                  main_null                      (int event_code, WimpPollBlock * block, IdBlock * id_block, void * handle);
static int                  main_quit_message              (WimpMessage * message, void * handle);

static bool                 setup_proxy                    (const unsigned int session, const char * url);
static bool                 fetch_data                     (const unsigned int server_timeout);

static void                 main_check_build               (const char * builds);

#ifdef CHECK_DOMAINS
  #ifndef USE_CHECKURL
    static bool             rightmatches                   (const char * p1, const char * p2, const char * s1, const char * s2);
  #endif
  static bool               validate_domain                (const char * const url, const char * const allowed_domains);
#endif

static _kernel_oserror    * main_create_directory          (const char * name);
static void                 main_init_decoder              (decoder_state * ds);
static void                 main_add_word_to_crc           (decoder_state * ds, unsigned int word, bool check);

static int                  main_decode_chunk              (const char * buf, unsigned int amount, bool first, decoder_state * ds, unsigned int incoming_size);
static int                  main_decode_data_chunk         (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_data_word_chunk    (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_data_string_chunk  (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_data_image_chunk   (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_ofec               (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_trp                (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_trp_stubname       (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_trp_subtype        (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_trp_subtype_isdir  (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_trp_subtype_isfile (const char * buf, unsigned int amount, bool first, decoder_state * ds);

static bool                 main_find_archive              (char * buffer, int buffer_size, decoder_state * ds);

static int                  main_build_wrapper             (decoder_state * ds, const char * name, const char * subdir);
static _kernel_oserror    * main_run_from_wrapper          (decoder_state * ds);

static void                 start_iconhigh                 (void);
static void                 stop_iconhigh                  (void);

static void                 catch_errors                   (int signum);

/**************************************************************/
/* exit_handler()                                             */
/*                                                            */
/* General cleanup function registered through atexit().      */
/**************************************************************/

static void exit_handler(void)
{
  _kernel_oserror * e;

  #ifdef BUILD_MPT

    /* Hang up the line - this fixes MPT fault 142. They have  */
    /* asked for the line to be hungup when the program fails. */

    e = _swix(NCDial_Hangup, 0);

    if (e != NULL)
    {
      dprintf(("Fail", "exit_handler (main.c): Error from NCDial_Hangup ('%s')\n", e->errmess));
    }

  #endif

  /* Stop IconHigh so Return etc. doesn't keep getting trapped */

  stop_iconhigh();

  /* Registered with the URL module? */

  if (session_registered == true)
  {
    e = _swix(URL_Deregister,
              _INR(0,1),

              0,
              session_identifier);

    if (e != NULL)
    {
      dprintf(("Fail", "exit_handler (main.c): Error from URL_Deregister ('%s')\n", e->errmess));
    }
  }

  /* Attempt to tidy up any archive files we might have downloaded */

  if (extract_path != NULL && *extract_path != '\0')
  {
    _swix(Hourglass_On, 0);

    if (extract_fout != NULL) fclose(extract_fout), extract_fout = NULL;

    if (utils_unlock_files(extract_path, NULL, false) == EXIT_SUCCESS)
    {
      _swix(OS_FSControl,
            _INR(0,1) | _IN(3),

            27,    /* 27 = Wipe objects */
            extract_path,
            3);    /* Flags; bits 0 and 1 set -> Recurse, Force */
    }

    _swix(Hourglass_Off, 0);
  }

  /* Kill the dynamic area */

  if (dynamic_area_base != 0)
  {
    e = _swix(OS_DynamicArea,
              _INR(0,1),

              1,
              dynamic_area_number);

    if (e != NULL)
    {
      dprintf(("Fail", "exit_handler (main.c): Error from OS_DynamicArea ('%s')\n", e->errmess));
    }
  }

  return;
}

#ifdef TEST_TRUSTED_DOMAINS_CODE

  #define test_url(url, allowed, pass) printf("Testing url '%s' against allowed list '%s': ", url, allowed); \
                                       if (validate_domain(url, allowed)==pass) printf("OK\n");              \
                                       else printf("*** FAIL ***\n");

  /**************************************************************/
  /* main_self_test()                                           */
  /*                                                            */
  /* Run the self-test. Manual inspection of output required.   */
  /**************************************************************/

  int main_self_test(void)
  {
    printf("Testing cases which should be allowed:\n\n");

    test_url("http://www.pace.co.uk",               ".pace.co.uk",               true);
    test_url("http://support.pace.co.uk",           ".funai.co.jp, .pace.co.uk", true);
    test_url("http://w.pace.co.uk",                 ".pace.co.uk",               true);
    test_url("http://www.pace.co.uk/test.html",     ".pace.co.uk",               true);
    test_url("http://www.pace.co.uk/test.html",     ".pace.co.uk",               true);
    test_url("http://support.pace.co.uk/test.html", ".funai.co.jp, .pace.co.uk", true);
    test_url("http://w.pace.co.uk/test.html",       ".pace.co.uk",               true);
    test_url("http://WWW.PACE.CO.UK",               ".pace.co.uk",               true);
    test_url("http://www.pace.co.uk",               ".PACE.CO.UK",               true);

    printf("\nTesting cases which should be rejected:\n\n");

    test_url("http://pace.co.uk",                   ".pace.co.uk, mptech.co.jp", false);
    test_url("http://pace.co.uk/test.html",         ".pace.co.uk, mptech.co.jp", false);
    test_url("http://pace.co.uk",                   ".pace.co.uk",               false);
    test_url("http://pace.co.uk.ha.co.uk",          ".pace.co.uk",               false);
    test_url("http://pace.co.ukc",                  ".pace.co.uk",               false);
    test_url("http://ace.co.uk",                    ".pace.co.uk",               false);
    test_url("http://space.co.uk",                  ".pace.co.uk",               false);
    test_url("http://space.co.uk",                  ".pace.co.uk",               false);
    test_url("http://pace.co.uk",                   ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk.ha.co.uk",          ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.ukc",                  ".funai.co.jp, .pace.co.uk", false);
    test_url("http://ace.co.uk",                    ".funai.co.jp, .pace.co.uk", false);
    test_url("http://space.co.uk",                  ".funai.co.jp, .pace.co.uk", false);
    test_url("http://space.co.uk",                  ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk/test/",             ".pace.co.uk, .funai.co.jp", false);
    test_url("http://pace.co.uk.ha.co.uk/test/",    ".pace.co.uk, .funai.co.jp", false);
    test_url("http://pace.co.ukc/test/",            ".pace.co.uk, .funai.co.jp", false);
    test_url("http://ace.co.uk/test/",              ".pace.co.uk, .funai.co.jp", false);
    test_url("http://space.co.uk/test",             ".pace.co.uk, .funai.co.jp", false);
    test_url("http://space.co.uk/test",             ".pace.co.uk, .funai.co.jp", false);
    test_url("http://pace.co.uk/test",              ".pace.co.uk",               false);
    test_url("http://pace.co.uk",                   ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk.ha.co.uk",          ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk?q=www.fool.com",    ".pace.co.uk",               false);
    test_url("http://fooled.co.uk/pace.co.uk",      ".pace.co.uk",               false);

    return EXIT_SUCCESS;
  }

#endif /* TEST_TRUSTED_DOMAINS_CODE */

/**************************************************************/
/* main()                                                     */
/*                                                            */
/* Entry point for non-TEST_TRUSTED_DOMAINS_CODE builds.      */
/*                                                            */
/* This requires a URL as its only command line argument. It  */
/* controls the downloading of a compressed image into a      */
/* dynamic area:                                              */
/*                                                            */
/* 1) Read URL from command line                              */
/* 2) Create a dynamic area to store the compressed image     */
/* 3) Connect to the FTP Server                               */
/* 4) Get the image Main_ChunkSize at the time                */
/* 5) Launch the child task                                   */
/**************************************************************/

int main(int argc, char *argv[])
{
  _kernel_oserror * e;
  char              url [256]; /* Copy of URL string from argv[1] */
  char            * url_p;
  unsigned int      server_timeout;

  /* Self test build? */

  #ifdef TEST_TRUSTED_DOMAINS_CODE
    return main_self_test();
  #endif

  /* Initialise the DebugLib library. */

  debug_initialise("UpgFetch", "izipfs:$.FetchOut", "");
  debug_output_device(TML_OUTPUT);
  debug_atexit();

  dprintf(("", "\n"));
  dprintf(("Diag", "main (main.c): Running\n"));

  /* NB, don't forget to echo any changes here with the duplicate code */
  /* just below the setjmp call later.                                 */

  signal(SIGOSERROR, catch_errors); /* OS error            */
  signal(SIGILL,     catch_errors); /* Illegal instruction */
  signal(SIGSEGV,    catch_errors); /* Segment violation   */
  signal(SIGSTAK,    catch_errors); /* Stack overflow      */
  signal(SIGFPE,     catch_errors); /* FPE error           */

  /* Set up an atexit() handler */

  atexit(exit_handler);

  /* Read the command line arguments. There should be two arguments we read; */
  /* the second one should be the URL.                                       */

  if (argc < 2)
  {
    dprintf(("Fail", "main (main.c): Not enough arguments supplied, exitting\n"));
    exit(EXIT_FAILURE);
  }

  /* Take a local copy of the URL, stripping of "upgrade:" prefix if present  */

  url_p = argv[1];
  if (!utils_strncasecmp(url_p, "upgrade:", sizeof("upgrade:") - 1)) url_p += sizeof("upgrade:") - 1;
  StrNCpy0(url, url_p);

  /* Start as a Wimp task */

  errors_show(main_initialise_toolbox());
  errors_show(main_initialise_eventlib());

  /* Initialise IconHigh */

  start_iconhigh();

  /* 01-May-2001 (ADH): Presently a proliferation of Wimp_Poll call points (yikes!) */
  /* means there's no sensible central point to put a longjmp handler for critical  */
  /* error recovery. So put it here, and force a bail-out on error.                 */

  if (setjmp(env) == Main_FromCatchErrors)
  {
    /* Long jump handler - most nasty or generally unexpected */
    /* errors will come back to here. The OS error abort      */
    /* handler jumps back here to deal with the error as we   */
    /* then have a clear stack; this is to avoid 'no stack    */
    /* for trap handler' errors caused by a SWI corrupting    */
    /* the value of R10.                                      */

    char         * tok        = NULL;
    unsigned int * regdump    = NULL;
    unsigned int * os_regdump = NULL;
    char           pc[16];

    /* Sort out the register dump */

    _swix(OS_ChangeEnvironment,
          _INR(0,3) | _OUT(3),

          7, /* Call back */
          0,
          0,
          0,

          &regdump); /* Where the C library put the registers */

    _swix(OS_ChangeEnvironment,
          _INR(0,3) | _OUT(1),

          13, /* Exception registers */
          0,
          0,
          0,

          &os_regdump); /* Where *ShowRegs gets them from */

    /* Copy the C register dump into the OS space */

    if (regdump && os_regdump) memcpy(os_regdump, regdump, 4 * 16);

    /* Store a more sensible error in the error block 'erb' where possible. */

    switch (erb.errnum & 0x00ffffff)
    {
      case 0x000000: tok = "EZeros0"; break;
      case 0x000001: tok = "EZeros1"; break;
      case 0x000002: tok = "EZeros2"; break;
      case 0x000003: tok = "EZeros3"; break;
      case 0x000005: tok = "EZeros5"; break;
    }

    if (tok)
    {
      char * error;

      /* If we know the PC, put this in the message */

      if (!regdump) sprintf(pc, "&deaddead");
      else          sprintf(pc, "&%08X", os_regdump[15] &~ 0xfc000003);

      error = lookup_token(tok, 1, pc);

      /* If the message token wasn't found, use the OS error, */
      /* otherwise copy the new one into the error block.     */

      if (strcmp(error, "!")) StrNCpy0(erb.errmess, error);
    }

    /* Need to reinstall the signal handlers since the run-time */
    /* system will have removed them 'For Your Safety And       */
    /* Convenience'. Don't forget to keep this list up to date  */
    /* with the code near the top of the function.              */

    signal(SIGOSERROR, catch_errors); /* OS error            */
    signal(SIGILL,     catch_errors); /* Illegal instruction */
    signal(SIGSEGV,    catch_errors); /* Segment violation   */
    signal(SIGSTAK,    catch_errors); /* Stack overflow      */
    signal(SIGFPE,     catch_errors); /* FPE error           */

    erb.errnum = Errors_Custom_Fatal; /* Force 'Quit' */
    errors_ret(&erb);

    exit(EXIT_FAILURE);
  }

  /* Ensure that the URL is from a trusted source */

  #ifdef USE_TRUSTED_DOMAINS

    if (!validate_domain(url,  USE_TRUSTED_DOMAINS))
    {
      dprintf(("Fail", "main (main.c): %s is not a trusted domain. Exitting...\n", url));
      quit("InvalidServer");
    }

  #endif /* USE_TRUSTED_DOMAINS */

  /* Enable null events for fetching */

  dprintf(("Diag", "main (main.c): Claiming null events\n"));

  register_null_claimant(Wimp_ENull, main_null, NULL);

  /* Status window setup */

  dprintf(("Diag", "main (main.c): Opening the status window\n"));

  initialise_status_screen();

  /* Register the session and set the session_identifier flag */

  dprintf(("Diag", "main (main.c): Registering with URL_Fetcher\n"));

  if (
       _swix(URL_Register,
             _IN(0) | _OUT(1),

             0,

             &session_identifier)

       != NULL
     )
  {
    quit("CantConnectToFTPServer");
  }
  else
  {
    session_registered = true;
    status_print(lookup_token("ConnectFTP",0,0));
  }

  /* Set up the proxy (if any) */

  if (!setup_proxy(session_identifier, url))
  {
    dprintf(("Diag,Fail", "main (main.c): Did not connect via. a proxy\n"));
  }

  /* Initiate the data fetch */

  dprintf(("Diag", "main (main.c): Starting URL fetch\n"));

  e = _swix(URL_GetURL,
            _INR(0,6),

            0,                   /* Flags - all clear this time                          */
            session_identifier,
            URL_Method_http_GET, /* GET the item                                         */
            url,
            NULL,                /* No extra data to send                                */
            2,                   /* Historical API oddity. R5 must be 2 as R0:1 is clear */
            NULL);               /* No user agent string supplied                        */

  if (e != NULL)
  {
    dprintf(("Fail", "main (main.c): Error '%s' from URL_GetURL", e->errmess));
    quit("CantFetchURL");
  }

  /* Get the server timeout value from message file */

  server_timeout = (unsigned int) strtoul(lookup_token("ServerTimeout",0,0), NULL, 10);

  /* Call the main data fetch routine. This does its own local poll loop and */
  /* returns only upon fetch completion.                                     */

  if (fetch_data(server_timeout) == false) quit("BrokenImage");

  /* Deregister with the URL module */

  _swix(URL_Deregister,
        _INR(0,1),

        0,
        session_identifier);

  session_registered = false;
  session_identifier = 0;

  return EXIT_SUCCESS;
}

/**************************************************************/
/* check_for_timeout()                                        */
/*                                                            */
/* See if we are still receiving data from the server.        */
/*                                                            */
/* Paramters: Server timeout value, in seconds.               */
/**************************************************************/

static void check_for_timeout(const unsigned int server_timeout)
{
  unsigned int current_timer_value;

  /* Set up the timer for the first time... */

  if (last_timer_value == 0)
  {
    _swix(OS_ReadMonotonicTime,
          _OUT(0),

          &last_timer_value);

    return;
  }

  /* ...or check for timeout */

  else
  {
    _swix(OS_ReadMonotonicTime,
          _OUT(0),

          &current_timer_value);

    if ((current_timer_value - last_timer_value) > (100 * server_timeout))
    {
      quit("ServerError");
    }
  }
}

/**************************************************************/
/* main_initialise_toolbox()                                  */
/*                                                            */
/* Start up as a Toolbox task.                                */
/**************************************************************/

static _kernel_oserror * main_initialise_toolbox(void)
{
  /* As well as starting us as a Wimp task, the Toolbox opens the */
  /* Messages file.                                               */

  return toolbox_initialise(0,                                /* Flags                                */
                            310,                              /* Minimum Wimp version                 */
                            messages_list,                    /* List of required messages            */
                            event_code_list,                  /* List of required events              */
                            "<" Module_ComponentName "$Dir>", /* Application directory                */
                            &meb,                             /* Messages file control block          */
                            &idb,                             /* Our application's local ID block     */
                            0,                                /* (Current wimp version returned here) */
                            0,                                /* (Task handle returned here)          */
                            (void *) &sprite_block);          /* Local sprite area returned here      */
}

/**************************************************************/
/* main_initialise_eventlib()                                 */
/*                                                            */
/* Set up EventLib for all operations.                        */
/**************************************************************/

static _kernel_oserror * main_initialise_eventlib(void)
{
  RetError(event_initialise(&idb));

  RetError(event_register_toolbox_handler(-1, UI_EVENT_QUIT,  quit_app,      NULL));
  RetError(event_register_toolbox_handler(-1, UI_EVENT_RESET, reset_machine, NULL));

  RetError(event_register_message_handler(Wimp_MQuit, main_quit_message, NULL));

  return NULL;
}

/**************************************************************/
/* main_poll()                                                */
/*                                                            */
/* Poll EventLib until null reason is seen.                   */
/**************************************************************/

void main_poll(void)
{
  int reason;

  do
  {
    errors_show(event_poll(&reason, &b, NULL));
  }
  while (reason != 0);
}

/**************************************************************/
/* reset_machine()                                            */
/*                                                            */
/* Handler to reset the machine. Parameters are as standard   */
/* for a Toolbox event handler.                               */
/**************************************************************/

static int reset_machine(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  #ifdef ALLOW_RESETTING
    _swix(OS_Reset, 0);
  #else
    exit(EXIT_SUCCESS);
  #endif

  return 1;
}

/**************************************************************/
/* quit_app()                                                 */
/*                                                            */
/* Handler to quit the application. Parameters are as         */
/* standard for a Toolbox event handler.                      */
/**************************************************************/

static int quit_app(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  exit(EXIT_SUCCESS);

  return 1;
}

/**************************************************************/
/* main_null()                                                */
/*                                                            */
/* Handler for null reason codes.  Parameters are as          */
/* standard for a Toolbox event handler.                      */
/**************************************************************/

static int main_null(int event_code, WimpPollBlock * block, IdBlock * id_block, void * handle)
{
  return 0;
}

/**************************************************************/
/* main_quit_message()                                        */
/*                                                            */
/* Wimp message handler for Wimp_MQuit messages.              */
/*                                                            */
/* Parameters are as standard for a Toolbox message handler.  */
/**************************************************************/

static int main_quit_message(WimpMessage * message, void * handle)
{
  (void) message;
  (void) handle;

  quit_app(UI_EVENT_QUIT, NULL, NULL, NULL);

  return 0;
}

/**************************************************************/
/* setup_proxy()                                              */
/*                                                            */
/* Attempt to set up a proxy server if required.              */
/*                                                            */
/* Parameters: URL module session handle;                     */
/*                                                            */
/*             URL to be fetched.                             */
/*                                                            */
/* Returns:    true if a proxy was successfully set up, else  */
/*             false (e.g. no proxy, or internal error).      */
/**************************************************************/

static bool setup_proxy(const unsigned int session, const char * url)
{
  url_description * d = NULL;

  dprintf(("Diag", "setup_proxy: Called for '%s' (&%08X)\n", url, session));

  if (urlutils_return_description(url, &d) != NULL) return false;

  if (d && d->host && d->protocol)
  {
    _kernel_oserror * err;
    char            * proxy_tag = malloc(strlen(d->protocol) + sizeof("_PROXY"));
    char            * proxy_url;
    char            * p;
    int               tag_size;

    if (proxy_tag == NULL)
    {
      dprintf(("Fail", "setup_proxy: Not enough memory for proxy tag\n"));
      return false;
    }

    sprintf(proxy_tag, "%s_PROXY", d->protocol);
    for (p = proxy_tag; *p != '\0'; p++) *p = toupper(*p);

    dprintf(("Diag", "setup_proxy: Proxy tag is '%s'\n", proxy_tag));

    err = _swix(NCMATwin_Enquiry,
                _INR(0,2) | _OUT(0),

                proxy_tag,
                0,
                0,

                &tag_size);

    if (err != NULL)
    {
      dprintf(("Fail", "setup_proxy: NCMATwin_Enquiry reported '%s' (1)\n", err->errmess));
      return false;
    }
    else if (tag_size <= 0)
    {
      dprintf(("Diag", "setup_proxy: There is no proxy tag defined\n"));
      return false;
    }

    /* For the proxy URL, over-allocate to allow us to insert 'http://' at the */
    /* start and a trailing '/' if missing at the end.                         */

    proxy_url = malloc(tag_size + sizeof("http:///"));

    if (proxy_url == NULL)
    {
      dprintf(("Fail", "setup_proxy: Not enough memory for proxy URL\n"));
      return false;
    }

    err = _swix(NCMATwin_Enquiry,
                _INR(0,2),

                proxy_tag,
                proxy_url,
                tag_size);

    if (err != NULL)
    {
      dprintf(("Fail", "setup_proxy: NCMATwin_Enquiry reported '%s' (2)\n", err->errmess));
      return false;
    }

    dprintf(("Diag", "setup_proxy: Proxy URL is '%s'\n", proxy_url));

    /* Modify if required */

    if (utils_strncasecmp(proxy_url, "http://", 7))
    {
      memmove(proxy_url + 7, proxy_url, strlen(proxy_url) + 1);
      strncpy(proxy_url, "http://", 7);
    }

    if (proxy_url[strlen(proxy_url) - 1] != '/') strcat(proxy_url, "/");

    dprintf(("Diag", "setup_proxy: Post-modification proxy URL is '%s'\n", proxy_url));

    /* Set the proxy */

    err = _swix(URL_SetProxy,
                _INR(0,4),

                0,
                session,
                proxy_url,
                "",
                0);

    if (err != NULL)
    {
      dprintf(("Fail", "setup_proxy: URL_SetProxy reported '%s'\n", err->errmess));
      return false;
    }

    dprintf(("Diag", "setup_proxy: Successful\n"));

    return true;
  }

  dprintf(("Diag", "setup_proxy: Couldn't get %s URL description\n", d == NULL ? "any" : "sensible"));

  return false;
}

/**************************************************************/
/* fetch_data()                                               */
/*                                                            */
/* This routine performs the fetching and processing of data. */
/* Here we get Main_ChunkSize chunks of data at a time. If we */
/* can we try and read the number of bytes remaining to be    */
/* read as soon as possible.                                  */
/*                                                            */
/* Paramters: Required server timeout value, in seconds.      */
/**************************************************************/

static bool fetch_data(const unsigned int server_timeout)
{
  _kernel_oserror  * error                = NULL;
  _kernel_swi_regs   regs;
  char               buff_in [Main_ChunkSize];     /* Buffer for the latest chunk of data from the URL */
  int                raw_bytes_read;               /* Bytes read in a single pass */
  int                valid_bytes_read;             /* Bytes read minus any header bytes stripped */
  int                total_bytes_read     = 0;     /* Total bytes read */

  bool               started_getting_data = false; /* Flag */

  char             * data_out;                     /* Pointer to start of data */
  int                l;
  char               state                = '?';
  int                got_http_header      = 0;

  bool               first                = true;
  decoder_state      ds;

  while (!error)
  {
    if (total_bytes_read > 0) dprintf(("Diag",
                                       "fetch_data (main.c): Bytes to read %d, total bytes read %d\n",
                                       total_bytes_to_read,
                                       total_bytes_read));

    /* Poll the Wimp to update any Toolbox changes */

    main_poll();

    /* Exit if we've got all the data */

    if (total_bytes_to_read > 0 && total_bytes_read == total_bytes_to_read) break;

    regs.r[0] = 0;
    regs.r[1] = session_identifier;
    regs.r[2] = (int) buff_in;
    regs.r[3] = Main_ChunkSize;

    /* Read next Main_ChunkSize sized chunk */

    error = _kernel_swi(URL_ReadData, &regs, &regs);

    /* Check to see that we have finished */

    if (error != NULL)
    {
      dprintf(("Diag", "fetch_data (main.c): Fetch error '%s'\n", error->errmess));

      regs.r[0] = 0;
      regs.r[1] = session_identifier;

      error = _kernel_swi(URL_Status, &regs, &regs);

      /* Transfer aborted, or all data not received? */

      if (error != NULL || !(regs.r[0] & 0x30)) /* Bit 5 set -> all data received */
      {
        dprintf(("Fail", "fetch_data (main.c): Status error '%s'\n", error->errmess));
        quit("ServerError");
      }

      /* Otherwise, should have all the data */

      break;
    }

    raw_bytes_read = regs.r[4];

    if (total_bytes_read == 0) dprintf(("Diag", "fetch_data (main.c): Raw read of %d bytes\n", raw_bytes_read));

    valid_bytes_read = raw_bytes_read;
    data_out         = buff_in;

    if (!got_http_header)
    {
      /* Search for the CR/LF/CR/LF at the end of the HTTP header */

      for (l = 0; l < raw_bytes_read; l++)
      {
        switch (state)
        {
          case '\r':
          {
            dprintf(("Diag", "fetch_data (main.c): State is '\\r'\n"));

            if (*data_out == '\n') state = '\n';
            else                   state = '?';
          }
          break;

          case '\n':
          {
            dprintf(("Diag", "fetch_data (main.c): State is '\\n'\n"));

            if (*data_out == '\r') state='R';
            else                   state='?';
          }
          break;

          case 'R':
          {
            dprintf(("Diag", "fetch_data (main.c): State is 'R'\n"));

            if (*data_out == '\n')
            {
              dprintf(("Diag", "fetch_data (main.c): Read final '\\n'\n"));

              state           = '\r';
              got_http_header = 1;
              l               = raw_bytes_read; /* Force end of for() loop */
            }
            else state = '?';
          }
          break;

          case '?':
          {
            if (*data_out == '\r') state = '\r'; /* Possible start of a CR/LF/CR/LF sequence */
          }
          break;
        }

        data_out++;
        valid_bytes_read--;
      }
    }


    if (valid_bytes_read > 0)
    {
      dprintf(("Diag", "fetch_data (main.c): have read %d bytes from the URL.\n", valid_bytes_read));

      total_bytes_read += valid_bytes_read;

      /* If we haven't already done so, update the display */

      if (started_getting_data == false)
      {
        status_print(lookup_token("Downloading",0,0));
        started_getting_data = true;
      }

      if (regs.r[5] != -1 || total_bytes_to_read > 0)
      {
        if (regs.r[5] != -1) total_bytes_to_read = regs.r[5] + total_bytes_read;
      }

      if (!error)
      {
        dprintf(("Diag", "fetch_data (main.c): Copying %d bytes of memory\n", valid_bytes_read));

        update_status_screen(total_bytes_read, total_bytes_to_read);

        if (
             main_decode_chunk(data_out,
                               valid_bytes_read,
                               first,
                               &ds,
                               total_bytes_to_read)
             == EXIT_FAILURE
           )
           return false;

        first = false;
      }
      else
      {
        dprintf(("Fail", "fetch_data (main.c): Error allocating dynamic area (%s)\n", error->errmess));
      }

      last_timer_value = 0;
    }
    else
    {
      /* If no bytes have been read from the URL... */

      check_for_timeout(server_timeout);
    }
  }

  /* Fetching is finished. Do we need to run anything? */

  if (ds.success == false) quit("BrokenImage"); /* Usually, the file was truncated if this happens */

  if (
       ds.type_of_image == image_type_transient ||
       ds.type_of_image == image_type_resident  ||
       ds.type_of_image == image_type_permanent
     )
  {
    unsigned int check_items, check_size;

    /* If the expected count doesn't match the current count, as a last */
    /* sanity check, then something 'orrible happened (e.g. CacheFS     */
    /* expired files despite locking or writes failed but were not      */
    /* faulted at the time). We take this to mean free memory is low.   */

    if (
         utils_count_contents(ds.extract_to, NULL, &check_items, &check_size) == EXIT_FAILURE ||
         check_items != ds.archive.total_items                                                ||
         check_size  != ds.archive.total_size
       )
       quit("NotEnoughMemory");

    /* If that last test passes, run the item */

    errors_show(main_run_from_wrapper(&ds));
  }

  return true;
}

/**************************************************************/
/* main_check_build()                                         */
/*                                                            */
/* Check whether or not the given list of builds matches the  */
/* current OS build.                                          */
/*                                                            */
/* Parameters: Comma-separated list of builds, in the form    */
/*             "ITEM, ITEM, ..." (i.e. one comma, one space). */
/*                                                            */
/* Returns:    Nothing... The function raises an appropriate  */
/*             UI message and causes an exit directly, should */
/*             the build not match.                           */
/**************************************************************/

static void main_check_build(const char * builds)
{
  _kernel_oserror  * error;
  _kernel_swi_regs   regs;

  char             * osver;
  char             * token;
  char             * blist;

  if (builds == NULL || *builds == '\0') return;

  blist = utils_strdup(builds);
  if (blist == NULL) quit("NotEnoughMemory");

  dprintf(("Diag", "main_check_build: Build list is '%s'\n", blist));

  /* Get the OS version string, which should have a substring */
  /* matching one of the build list items exactly.            */

  regs.r[0] = 0;
  regs.r[1] = 0;

  error = _kernel_swi(OS_Byte, &regs, &regs);
  osver = error->errmess;

  dprintf(("Diag", "main_check_build: OS version is %s\n", osver));

  /* Get the first token in the build list */

  token = strtok(blist, ", ");

  do
  {
    dprintf(("Diag", "main_check_build: token: %s\n", token));

    /* If we find the token, break out of the loop */

    if (strstr(osver, token) != NULL) break;
    token = strtok(NULL, ", ");
  }
  while (token != NULL);

  if (token == NULL)
  {
    dprintf(("Diag", "main_check_build: Invalid build\n"));
    quit("WrongBuild");
  }

  dprintf(("Diag", "main_check_build: Correct build\n"));

  free(blist);
  return;
}

/**************************************************************/
/* main_check_locale()                                        */
/*                                                            */
/* Check whether or not the given list of locales matches the */
/* current locale.                                            */
/*                                                            */
/* Parameters: Comma-separated list of locales, in the form   */
/*             "ITEM, ITEM, ..." (i.e. one comma, one space). */
/*                                                            */
/* Returns:    Nothing... The function raises an appropriate  */
/*             UI message and causes an exit directly, should */
/*             the locale not match.                          */
/**************************************************************/

static void main_check_locale(const char * locales)
{
  _kernel_oserror  * error;

  unsigned int       tnum;
  char               locale[100];
  char             * token;
  char             * llist;

  if (locales == NULL || *locales == '\0') return;

  llist = utils_strdup(locales);
  if (llist == NULL) quit("NotEnoughMemory");

  dprintf(("Diag", "main_check_locale: Build list is '%s'\n", llist));

  /* Get the locale */

  error = _swix(Territory_Number,
                _OUT(0),

                &tnum);

  if (error != NULL)
  {
    dprintf(("Diag", "main_check_locale: Territory_Number reported '%s'\n", error->errmess));
    quit("WrongBuild");
  }

  error = _swix(Territory_NumberToName,
                _INR(0,2),

                tnum,
                locale,
                sizeof(locale));

  if (error != NULL)
  {
    dprintf(("Diag", "main_check_locale: Territory_NumberToName reported '%s'\n", error->errmess));
    quit("WrongBuild");
  }

  dprintf(("Diag", "main_check_locale: OS Locale is %s\n", locale));

  /* Get the first token in the locale list */

  token = strtok(llist, ", ");

  do
  {
    dprintf(("Diag", "main_check_locale: token: %s\n", token));

    /* If we find the token, break out of the loop */

    if (strstr(locale, token) != NULL) break;
    token = strtok(NULL, ", ");
  }
  while (token != NULL);

  if (token == NULL)
  {
    dprintf(("Diag", "main_check_locale: Invalid locale\n"));
    quit("WrongBuild");
  }

  dprintf(("Diag", "main_check_locale: Correct locale\n"));

  free(llist);
  return;
}

#ifdef CHECK_DOMAINS

  #ifndef USE_CHECKURL

    /**************************************************************/
    /* rightmatches()                                             */
    /*                                                            */
    /* See if a substring appears as the rightmost part of a      */
    /* main string. Does not require string termination. The      */
    /* comparison is case insensitive.                            */
    /*                                                            */
    /* Parameters: Pointer to first char in the larger string;    */
    /*                                                            */
    /*             Pointer to first char after the end of the     */
    /*             larger string;                                 */
    /*                                                            */
    /*             Pointer to first char in the substring;        */
    /*                                                            */
    /*             Pointer to first char after the end of the     */
    /*             substring.                                     */
    /*                                                            */
    /* Returns:    true if there's a match, else false.           */
    /**************************************************************/

    static bool rightmatches(const char * p1, const char * p2, const char * s1, const char * s2)
    {
      const char * s;
      const char * p;

      s =s2 - 1; /* Point to last char in s string */
      p =p2 - 1; /* Point to last char in p string */

      /* Test character by character, stepping backwards */

      while (s >= s1 && p >= p1 && tolower(*s) == tolower(*p))
      {
        s--, p--;
      }

      /* Success if we found whole of s string at end of p, otherwise fail */

      return s < s1;
    }

  #endif /* USE_CHECKURL */

  /**************************************************************/
  /* validate_domain()                                          */
  /*                                                            */
  /* Check whether the URL given is allowed, on the basis of a  */
  /* comma-separated list of domains.                           */
  /*                                                            */
  /* If USE_CHECKURL is defined, the Check URL module is called */
  /* to do the check. All the rules that the Check URL module   */
  /* gives become available. Otherwise, simpler code checks the */
  /* domain. It assumes "://" is in the URL and strips all data */
  /* before this; strips everything after the next "/" (so no   */
  /* path validation). What left is checked.                    */
  /*                                                            */
  /* Parameters: Pointer to the URL to check;                   */
  /*                                                            */
  /*             Pointer to a NUL terminated, comma-separated   */
  /*             list of allowed domains.                       */
  /*                                                            */
  /* Returns:    true if the URL is allowed, else false. A      */
  /*             result of 'false' is returned for some kinds   */
  /*             of internal error; others are reported via.    */
  /*             the front-end directly.                        */
  /**************************************************************/

  static bool validate_domain(const char * const url, const char * const allowed_domains)
  {
    #ifdef USE_CHECKURL

      _kernel_oserror * e;
      char            * domains_copy;
      const char      * p;
      char            * c;
      unsigned int      commas;
      unsigned int      area_id;
      unsigned int      flags;

      if (
           url              == NULL ||
           allowed_domains  == NULL ||
           *url             == '\0'
         )
      {
        dprintf(("Fail", "validate_domain (main.c): Invalid parameters, returning 'false'\n"));
        return false;
      }

      if (*allowed_domains == '\0')
      {
        dprintf(("Diag", "validate_domain (main.c): Empty allowed list; letting anything through.\n"));
        return true;
      }

      /* This is a bit awkward. The domain list passed in is comma separated and */
      /* has no fragments, so count the number of items in the list by counting  */
      /* commas, allocate space including an extra two characters for each comma */
      /* so we can put " -" in there to give a parameter for each domain to keep */
      /* CheckURL happy, copy the domains with that extra specifier, and finally */
      /* pass the whole thing to CheckURL. Then the URL can be checked.          */

      p      = allowed_domains;
      commas = 1;

      while (*p != '\0') if (*(p++) == ',') commas++;

      /* Allocate space for fragment / parameter pairs. A comma is replaced by */
      /* a space, hyphen and '\n'; there's an extra space and hyphen at the    */
      /* end too, along with the NUL. Hence '+3' below. Since any white space  */
      /* in allowed_domains is stripped out, the maximum possible amount is    */
      /* being calculated - so, safe.                                          */

      domains_copy = malloc(strlen(allowed_domains) + (commas * 2) + 3);

      if (domains_copy == NULL)
      {
        dprintf(("Fail", "validate_domain (main.c): Can't allocate space for copy of domains\n"));
        quit("NotEnoughMemory");
      }

      /* Copy the domains list in a format for Check URL */

      p = allowed_domains;
      c = domains_copy;

      while (*p != '\0')
      {
        if (*p == ',')
        {
          *(c++) = ' ';
          *(c++) = '-';
          *(c++) = '\n';
        }
        else if (*p > ' ')
        {
          *(c++) = *p;
        }

        p++;
      }

      *(c++) = ' ';
      *(c++) = '-';
      *c     = '\0';

      /* Add the domains in a temporary area */

      e = _swix(CheckURL_AddArea,
                _INR(0,2) | _OUT(1),

                0,
                Main_CheckURLArea,
                domains_copy,

                &area_id);

      free(domains_copy);

      if (e != NULL)
      {
        dprintf(("Fail", "validate_domain (main.c): Error '%s' from CheckURL_AddArea, returning 'false'\n", e->errmess));
        return false;
      }

      /* Check the given URL; delete the temporary area regardless of outcome */

      e = _swix(CheckURL_Check,
                _INR(0,2) | _OUT(0),

                CU_Check_OnEntry_GivenAreaID,
                area_id,
                url,

                &flags);

      _swix(CheckURL_DeleteArea,
            _INR(0,1),

            CU_DeleteArea_OnEntry_GivenAreaID,
            area_id);

      if (e != NULL)
      {
        dprintf(("Fail", "validate_domain (main.c): Error '%s' from CheckURL_Check, returning 'false'\n", e->errmess));
        return false;
      }

      if ((flags & CU_Check_OnExit_MatchFound) != 0) return true;
      else                                           return false;

    #else /* USE_CHECKURL */

      const char *host_start, *host_end;
      const char *domain_start, *domain_end;

      dprintf(("Diag", "validate_domain (main.c): url is %s domains are %s\n", url, allowed_domains));

      if ((host_start = strstr(url, "://")) == NULL)
      {
        dprintf(("Fail", "validate_domain (main.c): Cannot locate :// in url.\n"));
        return (false);
      }
      host_start+=3; /* Move to beyond the :// */

      host_end = strchr(host_start, '/');  /* Find end of the host name in the URL, ie the trailing / */
      if (host_end == NULL)               /* No trailing / so use end of string */
        host_end=host_start+strlen(host_start);

      dprintf(("Diag", "validate_domain (main.c): Stripped line is %s\n", host_start));

      /* Now scan through the allowed domains, checking if there is a substring match. */
      domain_start=allowed_domains;
      while (*domain_start!=NULL)
      {
        while (*domain_start==' ')
          domain_start++;         /* Skip leading spaces before the domain (ie it might be "pace.co.uk, funai.co.uk") */
        domain_end=domain_start;
        while (*domain_end && *domain_end !=',' && *domain_end !=' ')
          domain_end++;    /* Look for end of the domain string, either a null, a comma or a space*/
        if (rightmatches(host_start, host_end, domain_start, domain_end))
        {
          dprintf(("Diag", "validate_domain (main.c): domains %s and %s match\n", host_start, domain_start));
          return (true);
        }
        domain_start=domain_end;  /* Skip over this domain */
        if (*domain_start)
          domain_start++;         /* Try next domain, if there is one */
      }
      return (false);  /* No match */

    #endif /* USE_CHECKURL */
  }

#endif /* CHECK_DOMAINS */

/**************************************************************/
/* main_create_directory()                                    */
/*                                                            */
/* Create a locked directory under the given name.            */
/*                                                            */
/* Parameters: Full pathname of the directory.                */
/**************************************************************/

static _kernel_oserror * main_create_directory(const char * name)
{
  _kernel_oserror * e = _swix(OS_File,
                              _INR(0,1) | _IN(4),

                              8,        /* Create directory */
                              name,
                              0);       /* Initial number of entries; 0 = use default */

  if (e != NULL) return e;

  else return _swix(OS_File,
                    _INR(0,1) | _IN(5),

                    4,    /* Set attributes */
                    name,
                    11);  /* Bit pattern -> "LWR/" */
}

/**************************************************************/
/* main_init_decoder()                                        */
/*                                                            */
/* Prepare a decoder_state structure for starting to decode a */
/* new image.                                                 */
/*                                                            */
/* Parameters: Pointer to the decoder_state structure to      */
/*             initialise.                                    */
/**************************************************************/

static void main_init_decoder(decoder_state * ds)
{
  if (ds == NULL) return;

  ds->crc = 0xFFFFFFFF, ds->crc_lock = false;
  make_crc_tables();

  ds->expecting_tag              = true;
  ds->reading_tag                = 0;
  ds->tag                        = 0;

  ds->expecting_size             = true;
  ds->reading_size               = 0;
  ds->size                       = 0;

  ds->expecting_data             = false;
  ds->reading_data               = 0;

  ds->reading_word               = 0;
  ds->word                       = 0;

  ds->lock_first                 = true;
  ds->fout                       = NULL;
  extract_fout                   = NULL;
  ds->ptr                        = 0;
  *ds->extract_to                = '\0';
  extract_path                   = NULL;

  ds->type_of_image              = image_type_unknown;
  ds->decomp_size                = 0;
  ds->file_crc                   = 0;
  ds->archive_uid                = 0;
  ds->have_uid                   = false;
  ds->matched_uid                = false;

  ds->build                      = NULL;
  ds->locale                     = NULL;
  ds->display                    = NULL;

  ds->success                    = false;

  ds->archive.expecting_stubname = true;
  ds->archive.reading_stubname   = NULL;
  ds->archive.stubname           = NULL;
  ds->archive.fullname           = NULL;
  ds->archive.first_fullname     = NULL;
  ds->archive.subtype            = 0;

  ds->archive.task_name          = NULL;
  ds->archive.action             = action_type_none;

  ds->archive.stage              = 0;

  ds->archive.reading_word       = 0;
  ds->archive.word               = 0;

  ds->archive.restart_zlib       = true;

  ds->archive.itemsize           = 0;
  ds->archive.loadaddr           = 0;
  ds->archive.execaddr           = 0;
  ds->archive.itemattr           = 0;

  ds->archive.total_items        = 0;
  ds->archive.total_size         = 0;

  ds->archive.completed          = false;

  ds->image.total                = 0;
  ds->image.not_tag              = 0;

  return;
}

/**************************************************************/
/* main_add_word_to_crc()                                     */
/*                                                            */
/* Add the given word to the running CRC if crc_lock in the   */
/* given decoder is false.                                    */
/*                                                            */
/* Parameters: Pointer to the decoder_state structure holding */
/*             the running CRC value and lock flag;           */
/*                                                            */
/*             Word to add;                                   */
/*                                                            */
/*             true if this is a tag value and should be      */
/*             checked against TLV_TAG_TYPE_FILE_CRC to end   */
/*             CRC addition, else false.                      */
/**************************************************************/

static void main_add_word_to_crc(decoder_state * ds, unsigned int word, bool check)
{
  if (!ds->crc_lock)
  {
    if (check && word == TLV_TAG_TYPE_FILE_CRC)
    {
      ds->crc_lock  = true;
      ds->crc      ^= 0xFFFFFFFF;

      dprintf(("Diag", "main_add_word_to_crc: Have CRC tag; locked running value of &%08X\n", ds->crc));
    }
    else
    {
      char c;

      c = (word & 0xff);             update_crc((U8 *)(&c), (U32 *)(&ds->crc));
      c = (word & 0xff00) >> 8;      update_crc((U8 *)(&c), (U32 *)(&ds->crc));
      c = (word & 0xff0000) >> 16;   update_crc((U8 *)(&c), (U32 *)(&ds->crc));
      c = (word & 0xff000000) >> 24; update_crc((U8 *)(&c), (U32 *)(&ds->crc));
    }
  }

  return;
}

/**************************************************************/
/* main_decode_chunk()                                        */
/*                                                            */
/* Decode a chunk of a compressed upgrade image. The function */
/* is rather monolithic, but pretty straightforward.          */
/*                                                            */
/* Parameters: Pointer to a buffer holding a chunk of data to */
/*             process;                                       */
/*                                                            */
/*             Amount of data in the buffer;                  */
/*                                                            */
/*             true if this is a first call, else false;      */
/*                                                            */
/*             Pointer to a decoder_state structure for this  */
/*             session, which need not be initialsed;         */
/*                                                            */
/*             Total incoming data size from the server (only */
/*             required if the data isn't a tag file, but is  */
/*             instead a configuration update file).          */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_decode_chunk(const char * buf, unsigned int amount, bool first, decoder_state * ds, unsigned int incoming_size)
{
  dprintf(("Diag", "main_decode_chunk: Called (&%08X, %d, %d, &%08X)\n", (int) buf, amount, first, (int) ds));

  /* On first call, initialise the decoder */

  if (first == true)
  {
    main_init_decoder(ds);
    ds->lock_first = true;
  }

  ds->ptr = 0;

  /* Anything to read? */

  if (amount == 0) return EXIT_SUCCESS;

  /* Now go around reading data */

  do
  {
    /* Read the tag value */

    while (ds->expecting_tag == true && ds->reading_tag < 32 && ds->ptr < amount)
    {
      ds->tag = ds->tag | (buf[ds->ptr++] << ds->reading_tag);
      ds->reading_tag += 8;
    }

    /* Finished reading a tag? */

    if (ds->reading_tag == 32)
    {
      ds->expecting_tag  = false;
      ds->reading_tag    = 0;
      ds->expecting_size = true;
      ds->reading_size   = 0;
      ds->size           = 0;

      dprintf(("Diag", "main_decode_chunk: Tag %d acquired\n", ds->tag));

      /* Now, if this is a plain text file, the tag won't make sense; */
      /* kick the state machine into reading data, setting up a few   */
      /* of the other fields we'll need.                              */

      if ((ds->tag & 0xff000000) != 0)
      {
        dprintf(("Diag", "main_decode_chunk: Nonsensical tag implies configuration update\n"));

        if (incoming_size < 4)
        {
          dprintf(("Fail", "main_decode_chunk: Server did not supply data size for us...\n"));
          quit("InvalidServer");
        }

        ds->expecting_size = false;
        ds->reading_size   = 0;
        ds->expecting_data = true;
        ds->reading_data   = 0;

        ds->image.not_tag  = ds->tag;
        ds->tag            = TLV_TAG_TYPE_IMAGE_DATA;
        ds->type_of_image  = image_type_configuration;
        ds->size           = incoming_size - 4; /* We've already read 4 bytes thinking it was a tag... */
        ds->decomp_size    = incoming_size;
        ds->lock_first     = false;
        ds->image.total    = 0;
      }

      /* Otherwise, include it in the CRC value */

      else main_add_word_to_crc(ds, ds->tag, true);
    }

    if (ds->ptr == amount)
    {
      dprintf(("Diag", "main_decode_chunk: ds->ptr = amount (%d), successful\n", ds->ptr));
      return EXIT_SUCCESS;
    }

    /* Read data size */

    while (ds->expecting_size == true && ds->reading_size < 32 && ds->ptr < amount)
    {
      ds->size = ds->size | (buf[ds->ptr++] << ds->reading_size);
      ds->reading_size += 8;
    }

    /* Finished reading size? */

    if (ds->reading_size == 32)
    {
      ds->expecting_size = false;
      ds->reading_size   = 0;
      ds->expecting_data = true;
      ds->reading_data   = 0;

      dprintf(("Diag", "main_decode_chunk: Data size %d\n", ds->size));

      main_add_word_to_crc(ds, ds->size, false);
    }

    if (ds->ptr == amount)
    {
      dprintf(("Diag", "main_decode_chunk: ds->ptr = amount (%d), successful\n", ds->ptr));
      return EXIT_SUCCESS;
    }

    /* If expecting data, read it */

    if (ds->expecting_data)
    {
      if (ds->size > 0)
      {
        unsigned int ptr = ds->ptr;

        if (main_decode_data_chunk(buf, amount, first, ds) == EXIT_FAILURE) return EXIT_FAILURE;

        /* Incorporate whatever data that consumed in the CRC value */

        if (!ds->crc_lock)
        {
          while (ptr < ds->ptr) update_crc((U8 *)(buf + (ptr++)), (U32 *)(&ds->crc));
        }
      }

      if (ds->reading_data == ds->size)
      {
        dprintf(("Diag", "main_decode_chunk: All data received\n"));

        ds->tag = ds->size = 0;
        ds->expecting_data = false;
        ds->reading_size   = 0;
        ds->expecting_tag  = true;
      }
    }
  }
  while (ds->ptr < amount);

  dprintf(("Diag", "main_decode_chunk: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_data_chunk()                                   */
/*                                                            */
/* Service function for main_decode_chunk. Once a tag and     */
/* data size have been found, decode the data part of the     */
/* tag. Should not be called if data size is zero. Detection  */
/* that the amount of data read equals the data size must be  */
/* done externally, with appropriate state machine resetting  */
/* for the next tag.                                          */
/*                                                            */
/* Parameters are as for main_decode_chunk.                   */
/**************************************************************/

static int main_decode_data_chunk(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_data_chunk: Called\n"));

  switch (ds->tag)
  {
    case TLV_TAG_TYPE_FILE_SIZE:
    case TLV_TAG_TYPE_IMAGE_TYPE:
    case TLV_TAG_TYPE_IMAGE_LENGTH:
    case TLV_TAG_TYPE_FILE_CRC:
    case TLV_TAG_TYPE_RANDOM_DATA:
    case TLV_TAG_TYPE_UID:
    case TLV_TAG_TYPE_TASK_ACTION:
    {
      return main_decode_data_word_chunk(buf, amount, first, ds);
    }
    break; /* Safety net in case above code gets, say, changed to not call return() */

    case TLV_TAG_TYPE_DISPLAY_STRING:
    case TLV_TAG_TYPE_BUILD_LIST:
    case TLV_TAG_TYPE_LOCALE_LIST:
    case TLV_TAG_TYPE_TASK_NAME:
    {
      return main_decode_data_string_chunk(buf, amount, first, ds);
    }
    break;

    case TLV_TAG_TYPE_IMAGE_DATA:
    {
      return main_decode_data_image_chunk(buf, amount, first, ds);
    }
    break;

    default:
    {
      /* Just discard the data */

      while (ds->reading_data < ds->size && ds->ptr < amount)
      {
        ds->ptr++, ds->reading_data++;
      }
    }
    break;
  }

  dprintf(("Diag", "main_decode_data_chunk: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_data_word_chunk()                              */
/*                                                            */
/* Service function for main_decode_data_chunk. Called on tag */
/* types FILE_SIZE, IMAGE_TYPE, IMAGE_LENGTH, FILE_CRC, UID,  */
/* RANDOM_DATA and TASK_ACTION. Must not be called for other  */
/* types.                                                     */
/*                                                            */
/* Parameters are as for main_decode_data_chunk.              */
/**************************************************************/

static int main_decode_data_word_chunk(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_data_word_chunk: Called\n"));

  if (
       ds->tag != TLV_TAG_TYPE_FILE_SIZE    &&
       ds->tag != TLV_TAG_TYPE_IMAGE_LENGTH &&
       ds->tag != TLV_TAG_TYPE_FILE_CRC     &&
       ds->tag != TLV_TAG_TYPE_RANDOM_DATA  &&
       ds->tag != TLV_TAG_TYPE_UID          &&
       ds->tag != TLV_TAG_TYPE_IMAGE_TYPE   &&
       ds->tag != TLV_TAG_TYPE_TASK_ACTION
     )
  {
    dprintf(("Fail", "main_decode_data_word_chunk: Called for invalid tag type %d\n", ds->tag));
    return EXIT_FAILURE;
  }

  if (ds->size != 4)
  {
    dprintf(("Fail", "main_decode_data_word_chunk: Error: Expecting to read one word of data for this tag, but data size is %d\n", ds->size));
    return EXIT_FAILURE;
  }

  /* Read data word */

  while (ds->reading_word < 32 && ds->ptr < amount)
  {
    ds->word = ds->word | (buf[ds->ptr++] << ds->reading_word);
    ds->reading_data ++;
    ds->reading_word += 8;
  }

  /* Finished? */

  if (ds->reading_word == 32)
  {
    switch (ds->tag)
    {
      case TLV_TAG_TYPE_FILE_SIZE:    dprintf(("Diag", "main_decode_data_word_chunk: File size is %d\n",                   ds->word)); break;
      case TLV_TAG_TYPE_IMAGE_LENGTH: dprintf(("Diag", "main_decode_data_word_chunk: Decompressed data length is %d MB\n", ds->word)); ds->decomp_size = ds->word; break;
      case TLV_TAG_TYPE_RANDOM_DATA:  dprintf(("Diag", "main_decode_data_word_chunk: Random data is &%08X\n",              ds->word)); break;
      case TLV_TAG_TYPE_UID:          dprintf(("Diag", "main_decode_data_word_chunk: UID is &%08X\n",                      ds->word)); ds->archive_uid = ds->word, ds->have_uid = true; break;
      case TLV_TAG_TYPE_FILE_CRC:
      {
        dprintf(("Diag", "main_decode_data_word_chunk: File CRC is &%08X (running CRC is &%08X)\n", ds->word, ds->crc));

        ds->file_crc = ds->word;
        if (ds->file_crc != ds->crc) quit("CRCMismatch");
        else ds->success = true;
      }
      break;
      case TLV_TAG_TYPE_IMAGE_TYPE:
      {
        dprintf(("Diag",
                 "main_decode_data_word_chunk: Image type: %s\n",
                 ds->word < (sizeof(type_names) / sizeof(*type_names)) ?
                 type_names[ds->word]                                  :
                 "<Unknown!>"));

        ds->type_of_image = (image_type) ds->word;
      }
      break;
      case TLV_TAG_TYPE_TASK_ACTION:
      {
        dprintf(("Diag",
                 "main_decode_data_word_chunk: Task action: %s\n",
                 ds->word < (sizeof(action_names) / sizeof(*action_names)) ?
                 action_names[ds->word]                                    :
                 "<Unknown!>"));

        ds->archive.action = (action_type) ds->word;
      }
      break;

      default:
      {
        dprintf(("Fail", "main_decode_data_word_chunk: Fatal internal error (1)\n"));
        exit(EXIT_FAILURE);
      }
    }

    /* Don't forget to reset the values... */

    ds->reading_word = 0;
    ds->word         = 0;
  }

  dprintf(("Diag", "main_decode_data_word_chunk: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_data_string_chunk()                            */
/*                                                            */
/* Service function for main_decode_data_chunk. Called on tag */
/* types DISPLAY_STRING, BUILD_LIST, LOCALE_LIST and          */
/* TASK_NAME. Must not be called for other types.             */
/*                                                            */
/* Parameters are as for main_decode_data_chunk.              */
/**************************************************************/

static int main_decode_data_string_chunk(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_data_string_chunk: Called\n"));

  if (
       ds->tag != TLV_TAG_TYPE_DISPLAY_STRING &&
       ds->tag != TLV_TAG_TYPE_BUILD_LIST     &&
       ds->tag != TLV_TAG_TYPE_LOCALE_LIST    &&
       ds->tag != TLV_TAG_TYPE_TASK_NAME
     )
  {
    dprintf(("Fail", "main_decode_data_string_chunk: Called for invalid tag type %d\n", ds->tag));
    return EXIT_FAILURE;
  }

  while (ds->reading_data < ds->size && ds->ptr < amount)
  {
    char    c = buf[ds->ptr++];
    char  * r;
    char ** write;

    switch (ds->tag)
    {
      case TLV_TAG_TYPE_DISPLAY_STRING: write = &ds->display;           break;
      case TLV_TAG_TYPE_BUILD_LIST:     write = &ds->build;             break;
      case TLV_TAG_TYPE_LOCALE_LIST:    write = &ds->locale;            break;
      case TLV_TAG_TYPE_TASK_NAME:      write = &ds->archive.task_name; break;
    }


    if (ds->reading_data == 0) r = malloc(1);
    else                       r = realloc(*write, ds->reading_data + 1);

    if (r == 0)
    {
      dprintf(("Fail", "main_decode_data_string_chunk: Out of memory\n"));
      quit("NotEnoughMemory");
    }
    else *write = r;

    r[ds->reading_data++] = c;
    if (ds->reading_data == 1) dprintf(("Diag", "main_decode_data_string_chunk: String value is \""));

    if (c != '\0') dprintf(("Diag", "%c", c));
    else
    {
      /* Finished reading this string */

      dprintf(("Diag", "\"\n"));

      if (ds->reading_data != ds->size)
      {
        dprintf(("Fail", "main_decode_data_string_chunk: Error: Reached NUL in string but haven't read all expected data yet (%d bytes left hanging)\n", ds->size - ds->reading_data));
        return EXIT_FAILURE;
      }

      switch(ds->tag)
      {
        case TLV_TAG_TYPE_DISPLAY_STRING:
        {
          if (ds->display != NULL && *ds->display != '\0')
          {
            /* Update the front-end to display the string */

            status_print(ds->display);
          }
        }
        break;

        case TLV_TAG_TYPE_BUILD_LIST:
        {
          if (ds->build != NULL && *ds->build != '\0')
          {
            /* Check the build is correct for this OS */

            main_check_build(ds->build);
          }
        }
        break;

        case TLV_TAG_TYPE_LOCALE_LIST:
        {
          if (ds->locale != NULL && *ds->locale != '\0')
          {
            /* Check the locale is correct for this territory */

            main_check_locale(ds->locale);
          }
        }
        break;
      }
    }
  }

  dprintf(("Diag", "main_decode_data_string_chunk: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_data_image_chunk()                             */
/*                                                            */
/* Service function for main_decode_data_chunk. Called on tag */
/* type IMAGE_DATA only. Must not be called for other types.  */
/*                                                            */
/* Parameters are as for main_decode_data_chunk.              */
/**************************************************************/

static int main_decode_data_image_chunk(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_data_image_chunk: Called\n"));

  if (ds->tag != TLV_TAG_TYPE_IMAGE_DATA)
  {
    dprintf(("Fail", "main_decode_data_image_chunk: Called for invalid tag type %d\n", ds->tag));
    return EXIT_FAILURE;
  }

  switch (ds->type_of_image)
  {
    default:
    case image_type_unknown:
    {
      dprintf(("Fail", "main_decode_data_image_chunk: Error: Reached image data before finding out the image type\n"));
      return EXIT_FAILURE;
    }
    break;

    case image_type_transient:
    case image_type_resident:
    case image_type_permanent:
    {
      return main_decode_trp(buf, amount, first, ds);
    }
    break;

    case image_type_os:
    case image_type_font:
    case image_type_exec:
    case image_type_configuration:
    {
      return main_decode_ofec(buf, amount, first, ds);
    }
    break;
  }

  /* Should never drop through to here */

  dprintf(("Fail", "main_decode_data_image_chunk: Fatal internal error (4)\n"));
  return EXIT_FAILURE;
}

/**************************************************************/
/* main_decode_ofec()                                         */
/*                                                            */
/* Service function for main_decode_data_image_chunk. Called  */
/* for image types os, font, exec and configuration only.     */
/*                                                            */
/* Parameters are as for main_decode_data_image_chunk.        */
/**************************************************************/

static int main_decode_ofec(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  unsigned int write;

  dprintf(("Diag", "main_decode_ofec: Called\n"));

  if (
       ds->type_of_image != image_type_os   &&
       ds->type_of_image != image_type_font &&
       ds->type_of_image != image_type_exec &&
       ds->type_of_image != image_type_configuration
     )
  {
    dprintf(("Fail", "main_decode_ofec: Called for invalid image type %d\n", ds->type_of_image));
    return EXIT_FAILURE;
  }

  /* If we don't have a dynamic area, now's the time to get one */

  if (dynamic_area_base == 0)
  {
    dynamic_area_size = ds->size;

    /* If this is a configuration update file, 4 bytes will have been 'eaten' */
    /* and the remaining size indicator in ds->size adjusted. Take account    */
    /* of this.                                                               */

    if (ds->type_of_image == image_type_configuration) dynamic_area_size += 4;

    /* Claim the area */

    errors_show(_swix(OS_DynamicArea,
                      _INR(0,8) | _OUT(1) | _OUT(3),

                      0,                            /* Reason code; 0 = claim new area     */
                      -1,                           /* Must be -1                          */
                      dynamic_area_size,            /* Initial size                        */
                      -1,                           /* Must be -1                          */
                      1<<7,                         /* Flags; bit 7 -> not user resizeable */
                      16 * 1024 * 1024,             /* Maximum size                        */
                      0,                            /* No handler routine                  */
                      -1,                           /* ...so this is irrelevant really     */
                      Module_ComponentName " data", /* Name of area, for Task Manager      */

                      &dynamic_area_number,
                      &dynamic_area_base));

    dprintf(("Diag", "main_decode_ofec: Dynamic area %d created (%d bytes)\n", dynamic_area_number, dynamic_area_size));
  }

  if (ds->type_of_image == image_type_configuration && ds->image.total < 4)
  {
    /* We swallowed the first 4 bytes thinking they were a tag... */

    if (dynamic_area_size < 4)
    {
      dprintf(("Fail", "main_decode_ofec: DA size for configuration type should be at least 4 bytes\n"));
      return EXIT_FAILURE;
    }

    dynamic_area_base[0] = (ds->image.not_tag & 0xff);
    dynamic_area_base[1] = (ds->image.not_tag & 0xff00) >> 8;
    dynamic_area_base[2] = (ds->image.not_tag & 0xff0000) >> 16;
    dynamic_area_base[3] = (ds->image.not_tag & 0xff000000) >> 24;

    ds->image.total = 4;
  }

  /* Work out how much data we can write this time around and write it */

  write = ds->size - ds->reading_data;
  if (amount - ds->ptr < write) write = amount - ds->ptr;

  if (write + ds->image.total > dynamic_area_size)
  {
    /* Since we took care to claim an area of correct size to start with, this should */
    /* never be necessary - but it does work (e.g. set dynamic_area_size to 4 above   */
    /* to test it) and is useful "just in case".                                      */

    unsigned int changed_by;

    dprintf(("Diag", "main_decode_ofec: Resize area by %d bytes\n", ds->image.total + write - dynamic_area_size));

    errors_show(_swix(OS_ChangeDynamicArea,
                      _INR(0,1) | _OUT(1),

                      dynamic_area_number,
                      ds->image.total + write - dynamic_area_size,

                      &changed_by));

    dynamic_area_size += changed_by;

    dprintf(("Diag", "main_decode_ofec: Dynamic area %d resized to %d bytes\n", dynamic_area_number, dynamic_area_size));
  }

  memcpy(dynamic_area_base + ds->image.total,
         buf + ds->ptr,
         write);

  ds->image.total  += write;
  ds->ptr          += write;
  ds->reading_data += write;

  dprintf(("Diag",
           "main_decode_ofec: Wrote %d bytes at offset %d\nmain_decode_ofec: to arrive at image.total %d, ptr %d and reading_data %d\n",
           write,
           ds->image.total - write,
           ds->image.total,
           ds->ptr,
           ds->reading_data));

  /* Finished? */

  if (ds->reading_data == ds->size)
  {
    dprintf(("Diag", "main_decode_ofec: Finished\n"));

    switch (ds->type_of_image)
    {
      case image_type_font:
      case image_type_exec:
      {
        dprintf(("Diag", "main_decode_ofec: This image type is not fully supported; taking no further action\n"));
      }
      break;

      case image_type_os:
      {
        dprintf(("Diag", "main_decode_ofec: Commencing FLASH ROM programming from compressed OS image...\n"));

        /* Free up some memory by killing running applications */

        dprintf(("Diag", "main_deocde_ofec: Attempting to kill various applications...\n"));

        if (!kill_apps())
        {
          error_occurred("CantKillApplications");
        }

        //////////////// Rest of this TBD
      }
      break;

      case image_type_configuration:
      {
        _kernel_oserror * e;

        dprintf(("Diag", "main_decode_ofec: Sending configuration update file off...\n"));

        e = _swix(ConfigurationUpdate_AcceptFile,
                  _INR(0,1),

                  dynamic_area_base,
                  ds->image.total);

        if (e != NULL)
        {
          if (e->errnum == 0x1E6) /* SWI not known */ quit("WrongBuild");
          else errors_show(e);
        }
      }
      break;

      default:
      {
        dprintf(("Diag", "main_decode_ofec: Fatal internal error (6)\n"));
        return EXIT_FAILURE;
      }
      break;
    }
  }

  dprintf(("Diag", "main_decode_ofec: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_trp()                                          */
/*                                                            */
/* Service function for main_decode_data_image_chunk. Called  */
/* for image types transient, resident and permanent only.    */
/*                                                            */
/* Parameters are as for main_decode_data_image_chunk.        */
/**************************************************************/

static int main_decode_trp(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_trp: Called\n"));

  if (
       ds->type_of_image != image_type_transient &&
       ds->type_of_image != image_type_resident  &&
       ds->type_of_image != image_type_permanent
     )
  {
    dprintf(("Fail", "main_decode_trp: Called for invalid image type %d\n", ds->type_of_image));
    return EXIT_FAILURE;
  }

  /* For archives, we first expect the 'stub' name of the file */

  if (main_decode_trp_stubname(buf, amount, first, ds) == EXIT_FAILURE) return EXIT_FAILURE;

  /* Once the stubname is done, need the subtype byte; may have to do some */
  /* setup though, if this is the first file we've encountered.            */

  if (main_decode_trp_subtype(buf, amount, first, ds) == EXIT_FAILURE) return EXIT_FAILURE;

  /* If subtype is 2 (i.e. byte in file was 2-1 = 1) -> directory; create it now. */
  /* If subtype is 1 (i.e. byte in file was 1-1 = 0) -> file...                   */

  if (ds->archive.subtype == 2)
  {
    if (main_decode_trp_subtype_isdir(buf, amount, first, ds) == EXIT_FAILURE) return EXIT_FAILURE;
  }
  else if (ds->archive.subtype == 1)
  {
    if (main_decode_trp_subtype_isfile(buf, amount, first, ds) == EXIT_FAILURE) return EXIT_FAILURE;
  }

  /* Did we finish that item? If so, reset this section of the state machine */
  /* ready for the next thing in the archive, or run the existant copy if a  */
  /* UID match was made.                                                     */

  if (ds->archive.completed)
  {
    /* Is this the first full name? */

    if (ds->archive.first_fullname == NULL)
    {
      ds->archive.first_fullname = utils_strdup(ds->archive.fullname);

      if (ds->archive.first_fullname == NULL)
      {
        dprintf(("Fail", "main_decode_trp: Error: Out of memory copying first full name\n"));
        quit("NotEnoughMemory");
      }
    }

    /* Reset other stuff */

    free(ds->archive.stubname), ds->archive.stubname = NULL;
    free(ds->archive.fullname), ds->archive.fullname = NULL;

    ds->archive.expecting_stubname = true;
    ds->archive.reading_stubname   = 0;
    ds->archive.subtype            = 0;
    ds->archive.stage              = 0;
    ds->archive.completed          = false;
  }

  dprintf(("Diag", "main_decode_trp: Successful; completed = %d\n", ds->archive.completed));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_trp_stubname()                                 */
/*                                                            */
/* Service function for main_decode_trp. Called to extract    */
/* the stubname from a transient, resident or permanent       */
/* image's main data area.                                    */
/*                                                            */
/* Parameters are as for main_decode_trp.                     */
/**************************************************************/

static int main_decode_trp_stubname(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_trp_stubname: Called\n"));

  while (ds->archive.expecting_stubname && ds->ptr < amount && ds->reading_data < ds->size)
  {
    if (ds->archive.reading_stubname == 0)
    {
      /* These are just-in-case items; the bit handling the */
      /* 'completed' flag way down below *should* ensure    */
      /* that they are always reset appropriately.          */

      free(ds->archive.fullname), ds->archive.fullname = NULL;
      free(ds->archive.stubname), ds->archive.stubname = NULL;

      /* OK, allocate space for the first byte of the stubname */

      ds->archive.stubname = malloc(1);

      if (ds->archive.stubname == NULL)
      {
        dprintf(("Fail", "main_decode_trp_stubname: Error: Out of memory reading file stub name\n"));
        quit("NotEnoughMemory");
      }
    }
    else
    {
      /* Reallocate for the next byte */

      char * temp = realloc(ds->archive.stubname, ds->archive.reading_stubname + 1);

      if (temp == NULL)
      {
        dprintf(("Fail", "main_decode_trp_stubname: Error: Out of memory reading file stub name\n"));
        quit("NotEnoughMemory");
      }
      else ds->archive.stubname = temp;
    }

    ds->archive.stubname[ds->archive.reading_stubname] = buf[ds->ptr++];

    /* The name terminates on NUL; after that we expect the subtype byte */

    if (ds->archive.stubname[ds->archive.reading_stubname] == '\0') ds->archive.expecting_stubname = false;

    ds->archive.reading_stubname ++;
    ds->reading_data             ++;
  }

  if (ds->reading_data >= ds->size)
  {
    free(ds->archive.stubname);
    dprintf(("Fail", "main_decode_trp_stubname: Error: Ran out of data for this record during archive processing\n"));
    return EXIT_FAILURE;
  }

  dprintf(("Diag", "main_decode_trp_stubname: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_trp_subtype()                                  */
/*                                                            */
/* Service function for main_decode_trp. Called to extract    */
/* the subtype byte from a transient, resident or permanent   */
/* image's main data area. Once obtained, the full name using */
/* the decoder_state structure's extract_to path is built;    */
/* the extract_to path itself is set up here.                 */
/*                                                            */
/* Parameters are as for main_decode_trp.                     */
/**************************************************************/

static int main_decode_trp_subtype(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_trp_subtype: Called\n"));

  if (!ds->archive.expecting_stubname && ds->archive.subtype == 0 && ds->ptr < amount && ds->reading_data < ds->size)
  {
    dprintf(("Diag", "main_decode_trp_subtype: Item stub name is '%s'\n", ds->archive.stubname));

    /* Was this the first item? */

    if (ds->lock_first)
    {
      _kernel_oserror * e;
      unsigned int      pos;
      char              temp[sizeof(ds->extract_to)];

      ds->lock_first = false;

      /* Need to create a directory to extract to, assuming one isn't already present! */

      if (
           ds->have_uid == false
           ||
           main_find_archive(temp,
                             sizeof(temp),
                             ds)
           == false
         )
      {
        utils_get_unique_name(ds->extract_to, sizeof(ds->extract_to));

        if (*ds->extract_to == '\0')
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: Could not get a unique directory name!\n"));
          return EXIT_FAILURE;
        }

        /* Take a copy for aborted download tidy-up */

        extract_path = utils_strdup(ds->extract_to);

        if (extract_path == NULL)
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: Not enough memory to copy unique directory name\n"));
          quit("NotEnoughMemory");
        }

        /* Build the full path - unique directory and 'Data' directory to */
        /* put the actual image contents in                               */

        pos = strlen(ds->extract_to);

        if (pos + sizeof(Main_Archive_Subdir) > sizeof(ds->extract_to))
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: extract_to buffer isn't big enough to append '.Data'\n"));
          return EXIT_FAILURE;
        }

        /* Note the assumption that the UID will fit if the subdirectory */
        /* name did, here.                                               */

        sprintf(ds->uid_name, "%s%s", ds->extract_to, Main_Archive_UID);
        ds->matched_uid = false;

        /* Put in the subdirectory name */

        strcpy(ds->extract_to + pos, Main_Archive_Subdir);

        if ((e = utils_build_tree(ds->extract_to, true)) != NULL)
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: Error '%s' from utils_build_path\n", e->errmess));
          return EXIT_FAILURE;
        }
      }
      else
      {
        /* There's already an archive! */

        dprintf(("Diag", "main_decode_trp_subtype: There is already an archive with UID &%08X\n", ds->archive_uid));

        ds->matched_uid = true;
        ds->success     = true;

        /* Make sure extract_to holds a valid path */

        strcpy(ds->extract_to, temp);
        pos = strlen(ds->extract_to);

        if (pos + sizeof(Main_Archive_Subdir) > sizeof(ds->extract_to))
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: extract_to buffer isn't big enough to append '" Main_Archive_Subdir "'\n"));
          return EXIT_FAILURE;
        }
        else strcpy(ds->extract_to + pos, Main_Archive_Subdir);

        /* OK - run it */

        dprintf(("Diag", "main_decode_trp_subtype: extract_to for existant copy is '%s'\n", ds->extract_to));

        errors_show(main_run_from_wrapper(ds));
        exit(EXIT_SUCCESS);
      }
    }

    /* Get the subtype */

    ds->archive.subtype = buf[ds->ptr++] + 1;
    ds->reading_data++;

    if (ds->archive.subtype != 1 && ds->archive.subtype != 2)
    {
      dprintf(("Fail", "main_decode_trp_subtype: Error: Subtype byte value %d not recognised\n", ds->archive.subtype));
    }
    else
    {
      dprintf(("Diag", "main_decode_trp_subtype: This is a %s\n", ds->archive.subtype == 1 ? "file" : "directory"));
    }
  }

  /* For files, we expect more data */

  if (ds->reading_data >= ds->size && ds->archive.subtype == 1)
  {
    free(ds->archive.stubname);
    dprintf(("Fail", "main_decode_trp_subtype: Error: Ran out of data for this record during archive processing\n"));
    return EXIT_FAILURE;
  }

  if (ds->archive.subtype != 0 && ds->archive.fullname == NULL)
  {
    /* Construct the full name */

    ds->archive.fullname = malloc(strlen(ds->extract_to) + strlen(ds->archive.stubname) + 2); /* 1 for separating ".", 1 for NUL */

    if (ds->archive.fullname == NULL)
    {
      dprintf(("Fail", "main_decode_trp_subtype: Error: Out of memory creating full filename\n"));
      quit("NotEnoughMemory");
    }
    else sprintf(ds->archive.fullname, "%s.%s", ds->extract_to, ds->archive.stubname);

    dprintf(("Diag", "main_decode_trp_subtype: Full name is '%s'\n", ds->archive.fullname));
  }

  dprintf(("Diag", "main_decode_trp_subtype: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_trp_subtype_isdir()                            */
/*                                                            */
/* Service function for main_decode_trp. Called to handle     */
/* directory items (subtype byte value 1; since the value is  */
/* incremented by 1 in the decoder_state structure to allow 0 */
/* for 'not obtained yet', the ds->subtype value should be 2  */
/* if this function is to be called).                         */
/*                                                            */
/* Parameters are as for main_decode_trp.                     */
/**************************************************************/

static int main_decode_trp_subtype_isdir(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  _kernel_oserror * e;

  dprintf(("Diag", "main_decode_trp_subtype_isdir: Called\n"));

  if (ds->archive.subtype != 2)
  {
    dprintf(("Fail", "main_decode_trp_subtype_isdir: Called for invalid subtype '%d'\n", ds->archive.subtype));
    return EXIT_FAILURE;
  }

  e = main_create_directory(ds->archive.fullname);

  if (e != NULL)
  {
    dprintf(("Fail", "main_decode_trp_subtype_isdir: Error: %s", e->errmess));
    return EXIT_FAILURE;
  }

  /* Report and flag completion for this item */

  dprintf(("Diag", "main_decode_trp_subtype_isdir: Directory created\n"));

  ds->archive.completed = true;
  ds->archive.total_items++;

  dprintf(("Diag", "main_decode_trp_subtype_isdir: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_trp_subtype_isfile()                           */
/*                                                            */
/* Service function for main_decode_trp. Called to handle     */
/* file items (subtype byte value 0; since the value is       */
/* incremented by 1 in the decoder_state structure to allow 0 */
/* for 'not obtained yet', the ds->subtype value should be 1  */
/* if this function is to be called).                         */
/*                                                            */
/* Parameters are as for main_decode_trp.                     */
/**************************************************************/

static int main_decode_trp_subtype_isfile(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_trp_subtype_isfile: Called\n"));

  if (ds->archive.subtype != 1)
  {
    dprintf(("Fail", "main_decode_trp_subtype_isfile: Called for invalid subtype '%d'\n", ds->archive.subtype));
    return EXIT_FAILURE;
  }

  while (ds->ptr < amount && ds->reading_data < ds->size && !ds->archive.completed)
  {
    switch (ds->archive.stage)
    {
      /* Need to read words for item size, load address, exec address and attributes */

      case 0:
      case 1:
      case 2:
      case 3:
      {
        /* Read the word */

        while (ds->reading_word < 32 && ds->ptr < amount && ds->reading_data < ds->size)
        {
          ds->word = ds->word | (buf[ds->ptr++] << ds->reading_word);
          ds->reading_data ++;
          ds->reading_word += 8;
        }

        /* Finished? Record it in the relevant variable */

        if (ds->reading_word == 32)
        {
          switch (ds->archive.stage)
          {
            case 0: ds->archive.itemsize = ds->word; break;
            case 1: ds->archive.loadaddr = ds->word; break;
            case 2: ds->archive.execaddr = ds->word; break;
            case 3: ds->archive.itemattr = ds->word; break;
            default:
            {
              dprintf(("Fail", "main_decode_trp_subtype_isfile: Fatal internal error (2)\n"));
              exit(EXIT_FAILURE);
            }
          }

          ds->reading_word = 0;
          ds->word         = 0;

          ds->archive.stage++;
        }

        /* Out of data unexpectedly? */

        if (ds->reading_data >= ds->size)
        {
          free(ds->archive.stubname);
          free(ds->archive.fullname);
          dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: Ran out of data for this record during archive processing\n"));
          return EXIT_FAILURE;
        }
      }
      break;

      /* When we get to stage 4, all words have been read; this is file data now */

      case 4:
      {
        Byte   outbuf[Main_Extract];
        int    error;
        size_t write, written;

        /* If not presently open, open the output file and wake up zlib */

        if (ds->fout == NULL)
        {
          extract_fout = ds->fout = fopen(ds->archive.fullname, "wb");

          if (ds->fout == NULL)
          {
            /* perror(ds->archive.fullname); */
            return EXIT_FAILURE;
          }
          else if (ds->archive.restart_zlib == true)
          {
            ds->archive.restart_zlib = false;

            /* Set up basic stream info */

            memset(&ds->archive.stream, 0, sizeof(ds->archive.stream));

            ds->archive.stream.zalloc = Z_NULL;
            ds->archive.stream.zfree  = Z_NULL;
            ds->archive.stream.opaque = Z_NULL;

            /* Initialise the inflate engine */

            error = inflateInit(&ds->archive.stream);

            if (error)
            {
              free(ds->archive.stubname);
              free(ds->archive.fullname);
              fclose(ds->fout), ds->fout = extract_fout = NULL;
              dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: ZLib error %d at initialisation (%s)\n", error, ds->archive.stream.msg != NULL && *ds->archive.stream.msg != '\0' ? ds->archive.stream.msg : "no further details"));
              return EXIT_FAILURE;
            }
          }
        }

        /* Work out how much data we can write this time around and write it */

        if (ds->ptr < amount)
        {
          do
          {
            /* Read a chunk */

            ds->archive.stream.next_in  = (Byte *) (buf + ds->ptr);
            ds->archive.stream.avail_in = ((amount - ds->ptr) * sizeof(char)) / sizeof(Byte);

            /* Decompressor loop */

            do
            {
              ds->archive.stream.next_out  = outbuf;
              ds->archive.stream.avail_out = (uInt) sizeof(outbuf);

              error = inflate(&ds->archive.stream, Z_SYNC_FLUSH);

              if (error && error != Z_STREAM_END)
              {
                free(ds->archive.stubname);
                free(ds->archive.fullname);
                fclose(ds->fout), ds->fout = extract_fout = NULL;
                dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: ZLib error %d at decompression (%s)\n", error, ds->archive.stream.msg != NULL && *ds->archive.stream.msg != '\0' ? ds->archive.stream.msg : "no further details"));
                return EXIT_FAILURE;
              }

              /* Write out the decompressed data */

              write   = (sizeof(outbuf) / sizeof(Byte)) - ds->archive.stream.avail_out;
              written = fwrite(outbuf,
                               sizeof(Byte),
                               write,
                               ds->fout);

              if (written < write)
              {
                free(ds->archive.stubname);
                free(ds->archive.fullname);
                fclose(ds->fout), ds->fout = extract_fout = NULL;
                quit("NotEnoughMemory");
              }

              /* Keep going until all input data is consumed */
            }
            while (ds->archive.stream.avail_in > 0 && !error);

            /* Increment our local data counters */

            ds->reading_data += (amount - ds->ptr - ds->archive.stream.avail_in);
            ds->ptr          += (amount - ds->ptr - ds->archive.stream.avail_in);

            /* Keep going until stream end, or we run out of data */
          }
          while (error != Z_STREAM_END && ds->ptr < amount && ds->reading_data < ds->size);

          /* Finished? */

          if (error == Z_STREAM_END)
          {
            _kernel_oserror * e;

            fclose(ds->fout), ds->fout = extract_fout = NULL;

            error = inflateEnd(&ds->archive.stream);

            if (error && error != Z_STREAM_END)
            {
              free(ds->archive.stubname);
              free(ds->archive.fullname);
              dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: ZLib error %d at inflate end (%s)\n", error, ds->archive.stream.msg != NULL && *ds->archive.stream.msg != '\0' ? ds->archive.stream.msg : "no further details"));
              return EXIT_FAILURE;
            }

            /* Reset the byte counter for the state machine */

            ds->archive.restart_zlib = true;

            /* Set the item's attributes etc. */

            ds->archive.itemattr |= (1u<<3); /* Lock all files */

            e = _swix(OS_File,
                      _INR(0,3) | _IN(5),

                      1,
                      ds->archive.fullname,
                      ds->archive.loadaddr,
                      ds->archive.execaddr,
                      ds->archive.itemattr);

            if (e != NULL)
            {
              dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: %s", e->errmess));
              return EXIT_FAILURE;
            }

            /* Report and flag completion of this item */

            dprintf(("Diag", "main_decode_trp_subtype_isfile: File created\n"));

            ds->archive.completed   = true;
            ds->archive.total_items ++;
            ds->archive.total_size  += ds->archive.itemsize;
          }
          else
          {
            /* If not at stream end, expect more data */

            if (ds->reading_data >= ds->size)
            {
              free(ds->archive.stubname);
              free(ds->archive.fullname);
              fclose(ds->fout), ds->fout = extract_fout = NULL;
              dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: Ran out of input data before decompression ds->archive.completed\n"));
              return EXIT_FAILURE;
            }
          }
        }
      }
      break;

      default:
      {
        dprintf(("Fail", "main_decode_trp_subtype_isfile: Fatal internal error (3)\n"));
        exit(EXIT_FAILURE);
      }
      break;

    } /* 'switch (ds->archive.stage)' */

  } /* 'while (ds->ptr < amount && ds->reading_data < ds->size) && !ds->archive.completed' */

  dprintf(("Diag", "main_decode_trp_subtype_isfile: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_find_archive()                                        */
/*                                                            */
/* Assuming the naming strategy of utils_get_unique_name,     */
/* run through directories looking for UID files matching     */
/* the given UID. UID files are written with utils_write_uid. */
/*                                                            */
/* Needs a buffer for pathname construction, just as in       */
/* utils_get_unique_name. On exit, if an archive has been     */
/* found, the buffer will hold the path of the archive.       */
/*                                                            */
/* Parameters: Pointer to the buffer;                         */
/*                                                            */
/*             Size of the buffer;                            */
/*                                                            */
/*             Pointer to decoder_state structure for the     */
/*             archive to compare against.                    */
/*                                                            */
/* Returns:    true if found, else false for not found or any */
/*             internal error. If true, the buffer is updated */
/*             to hold the pathname of the archive,           */
/**************************************************************/

static bool main_find_archive(char * buffer, int buffer_size, decoder_state * ds)
{
  unsigned int    len, ulen;
  char          * leaf;
  char          * uleaf;
  DIR           * dir;
  struct dirent * entry;

  dprintf(("Diag", "main_find_archive: Called\n"));

  if (!buffer || buffer_size < 2) return false;

  /* Clear the buffer first */

  memset(buffer, 0, buffer_size);

  if (strlen(Utils_ScrapPath) + 9 <= buffer_size) strcpy(buffer, Utils_ScrapPath);
  else return false;

  dprintf(("Diag", "main_find_archive: Working from directory '%s'\n", buffer));

  /* Work out places for unique 8 character leaf and so-on */

  ulen  = sizeof(Main_Archive_UID) - 1;
  len   = strlen(buffer);
  leaf  = buffer + len;
  uleaf = buffer + len + 8;

  if (len + 8 + ulen >= buffer_size) return false;

  /* Do we have a directory? */

  buffer[len - 1] = '\0'; /* Ensure trailing '.' is suppressed for the moment */

  if (!dirs_is_dir(buffer))
  {
    dprintf(("Fail", "main_find_archive: '%s' is not a directory!\n", buffer));
    return false;
  }

  dir = dirs_open_dir(buffer);
  if (dir == NULL) return false;

  buffer[len - 1] = '.'; /* Restore trailing '.' */

  /* Go through the entries looking for subdirectories */

  while ((entry = dirs_read_dir(dir)) != NULL)
  {
    if (!strncmp(entry->d_name, Utils_UDPrefix, sizeof(Utils_UDPrefix) - 1))
    {
      unsigned int h, local_uid, local_items, local_size;
      bool         fault = false;

      dprintf(("Diag", "main_find_archive: Found item '%s'\n", entry->d_name));

      /* Build the UID filename */

      strcpy(leaf, entry->d_name);     /* First get the directory name */
      if (!dirs_is_dir(buffer))
      {
        dprintf(("Diag", "main_find_archive: ...but it is not a directory\n"));
        continue;
      }
      strcpy(uleaf, Main_Archive_UID); /* Then append the leaf */

      dprintf(("Diag", "main_find_archive: UID filename is '%s'\n", buffer));

      /* Open it and check the contents */

      if (
           _swix(OS_Find,
                 _INR(0,2) | _OUT(0),

                 0x47, /* Open existing file with read only access; use no path, error if there's a directory */
                 buffer,
                 0,

                 &h)

           != NULL
         )
         continue;

      if (
           utils_read_word(h, &local_uid)   != NULL ||
           utils_read_word(h, &local_items) != NULL ||
           utils_read_word(h, &local_size)  != NULL
         )
         fault = true;

      _swix(OS_Find,
            _INR(0,1),

            0,  /* Close file */
            h);

      if (fault) continue;

      /* Is there a UID match? */

      if (ds->archive_uid == local_uid)
      {
        /* Yes, so check the contents */

        unsigned int count_items, count_size;

        strcpy(uleaf, Main_Archive_Subdir);

        if (
             utils_count_contents(buffer, NULL, &count_items, &count_size) == EXIT_FAILURE ||
             local_items != count_items                                                    ||
             local_size  != count_size
           )
        {
          dprintf(("Diag", "main_find_archive: UID matched but count failed\n"));

          /* Permanent images are locked; so if the counts don't match, we're confused. */
          /* There could be a UID clash or deliberate deletion, yet either way the item */
          /* could still be running so we can't just force delete the lot and download. */
          /* So, bail, and bail to reset... (Same applies if the count function returns */
          /* a failure code).                                                           */

          if (ds->type_of_image == image_type_permanent)
          {
            dprintf(("Fail", "main_find_archive: Count failure or mismatch for permanent image...\n"));
            error_occurred("Internal");
          }

          /* Otherwise, just forget it; carry on to the next item */

          continue;
        }

        dprintf(("Diag", "main_find_archive: UID and counts both match\n"));

        if (ds->type_of_image != image_type_permanent)
        {
          /* Need to re-lock files for a Resident item */

          _swix(Hourglass_On, 0);

          *uleaf = '\0';
          utils_unlock_files(buffer, NULL, true); /* ...which *locks* the files */

          /* Since counting files could claim memory (it's recursive) and so could */
          /* locking them, during either operation pesky CacheFS might expire some */
          /* files. To be ultra-paranoid we thus recount the items and if there is */
          /* now a mismatch, unlock the locked files and raise a low memory error  */
          /* (if there wasn't enough RAM to even count/lock things there is no way */
          /* there would be enough to download the archive a second time, given    */
          /* transient decompression requirements and temporary string claims!).   */

          strcpy(uleaf, Main_Archive_Subdir);

          if (
               utils_count_contents(buffer, NULL, &count_items, &count_size) == EXIT_FAILURE ||
               local_items != count_items                                                    ||
               local_size  != count_size
             )
          {
            /* Zoiks, it really did expire */

            utils_unlock_files(buffer, NULL, false); /* Unlock them again */
            _swix(Hourglass_Off, 0);
            quit("NotEnoughMemory");
          }

          _swix(Hourglass_Off, 0);
        }

        *uleaf = '\0';
        return true;
      }
    }
  }

  /* Finished */

  dprintf(("Diag", "main_find_archive: Nothing found, normal exit\n"));

  return false;
}

/**************************************************************/
/* main_build_wrapper()                                       */
/*                                                            */
/* Build a wrapper Obey file to run the contents of a given   */
/* archive.                                                   */
/*                                                            */
/* Parameters: Pointer to decoder_state structure for the     */
/*             archive;                                       */
/*                                                            */
/*             Filename of the wrapper file to write;         */
/*                                                            */
/*             Name of top-level directory to reference with  */
/*             wipe and file access commands (normally this   */
/*             will be the unique directory name that the     */
/*             wrapper file, UID and extracted archive data   */
/*             all lies in).                                  */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_build_wrapper(decoder_state * ds, const char * name, const char * subdir)
{
  int    ret  = EXIT_SUCCESS;
  FILE * fout = fopen(name, "wb");

  dprintf(("Diag", "main_build_wrapper: Called\n"));

  if (fout == NULL) quit("NotEnoughMemory");

  if (fprintf(fout, Main_UpgLaunch_Slot "\n") < 0)
  {
    ret = EXIT_FAILURE;
  }
  else if (ds->have_uid == false)
  {
    dprintf(("Diag", "main_build_wrapper: Setting -wipe\n"));

    /* Must wipe the data afterwards */

    if (
         fprintf(fout, "Run %s -run %s -wipe", Main_UpgLaunch_Run, ds->archive.first_fullname) < 0
       )
       ret = EXIT_FAILURE;
  }
  else if (ds->type_of_image == image_type_permanent)
  {
    dprintf(("Diag", "main_build_wrapper: Leaving locked\n"));

    /* Leave locked */

    if (
         fprintf(fout, "Run %s -run %s", Main_UpgLaunch_Run, ds->archive.first_fullname) < 0
       )
       ret = EXIT_FAILURE;
  }
  else
  {
    dprintf(("Diag", "main_build_wrapper: Setting -unlock\n"));

    /* Unlock but don't wipe */

    if (
         fprintf(fout, "Run %s -run %s -unlock", Main_UpgLaunch_Run, ds->archive.first_fullname) < 0
       )
       ret = EXIT_FAILURE;
  }

  /* Deal with -task */

  if (ret != EXIT_FAILURE)
  {
    if (
         ds->archive.task_name  != NULL &&
         *ds->archive.task_name != '\0' &&
         (
           ds->archive.action == action_type_replace ||
           ds->archive.action == action_type_abort
         )
       )
    {
      unsigned int   i     = 0;
      unsigned int   count = 0;
      char         * copy  = NULL;

      /* The task name has to be enclosed in double quotes, but that means */
      /* we must escape any double quotes already in it                    */

      while (ds->archive.task_name[i] != '\0')
      {
        if (ds->archive.task_name[i++] == '\"') count++;
      }

      if (count == 0) copy = ds->archive.task_name;
      else
      {
        copy = malloc(strlen(ds->archive.task_name) + count + 1);

        if (copy == NULL)
        {
          dprintf(("Fail", "main_build_wrapper: Out of memory\n"));
          ret = EXIT_FAILURE;
        }
        else
        {
          count = 0;
          i     = 0;

          while (ds->archive.task_name[i] != '\0')
          {
            if (ds->archive.task_name[i] == '\"')
            {
              copy[count++] = '\\';
              copy[count++] = '\"';
            }
            else
            {
              copy[count++] = ds->archive.task_name[i];
            }

            i++;
          }

          copy[count] = '\0';
        }
      }

      if (
           ret != EXIT_FAILURE &&
           fprintf(fout, " -task \"%s\" %s\n", copy, ds->archive.action == action_type_replace ? "replace" : "abort") < 0
         )
         ret = EXIT_FAILURE;

      if (copy != NULL && copy != ds->archive.task_name) free(copy);
    }
    else if (fprintf(fout, "\n") < 0) ret = EXIT_FAILURE;
  }

  fclose(fout);

  if (ret != EXIT_FAILURE)
  {
    if (
         _swix(OS_File,
               _INR(0,1) | _IN(5),

               4,  /* Set attributes */
               name,
               11) /* Permissions LWR/ */

         != NULL
       )
    {
      ret = EXIT_FAILURE;
    }
    else if (
              _swix(OS_File,
                    _INR(0,2),

                    18,
                    name,
                    Main_FileType_Obey)

               != NULL
            )
            ret = EXIT_FAILURE;
  }

  if (ret == EXIT_FAILURE) remove(name);

  dprintf(("Diag", "main_build_wrapper: Finished, returning %s\n", ret == EXIT_SUCCESS ? "EXIT_SUCCESS" : "EXIT_FAILURE"));

  return ret;
}

/**************************************************************/
/* main_run_from_wrapper()                                    */
/*                                                            */
/* Run an archive from its wrapper file, by building that     */
/* wrapper file and issuing SWI Wimp_StartTask for it.        */
/*                                                            */
/* Parameters: Pointer to a decoder_state structure with an   */
/*             appropriate extract_to path, filled in         */
/*             type_of_image field, and filled in             */
/*             first_fullname field.                          */
/**************************************************************/

static _kernel_oserror * main_run_from_wrapper(decoder_state * ds)
{
  _kernel_oserror * e;
  int               ret;
  char            * subdir;
  char            * wrapper;
  char            * combuf;
  char            * dot;

  dprintf(("Diag", "main_run_from_wrapper: Called\n"));

  /* Sanity checks */

  if (*ds->extract_to == '\0' || (ds->archive.first_fullname == NULL && ds->matched_uid == false))
  {
    dprintf(("Fail", "main_run_from_wrapper: Invalid parameters\n"));
    return errors_frontend_error(fee_invalid_parameters, "1");
  }

  /* Write the UID file for this item if need be */

  if (ds->matched_uid == false)
  {
    e = utils_write_uid(ds->uid_name,
                        ds->have_uid ? 1 : 0,
                        ds->archive_uid,
                        ds->archive.total_items,
                        ds->archive.total_size);

    if (e != NULL)
    {
      dprintf(("Fail", "main_run_from_wrapper: Couldn't write UID file ('%s')\n", e->errmess));
      return e;
    }
  }

  /* Construct the subdirectory by stripping off the leaf directory name */
  /* that must be present in the extract_to path.                        */

  subdir = malloc(strlen(ds->extract_to) + 1);

  if (subdir == NULL) return errors_frontend_error(fee_out_of_memory, "2");
  else strcpy(subdir, ds->extract_to);

  dot = strrchr(subdir, '.');

  if (dot == NULL)
  {
    dprintf(("Fail", "main_run_from_wrapper: Fatal internal error (5)\n"));
    exit(EXIT_FAILURE);
  }
  else *dot = '\0';

  /* Construct the wrapper filename */

  combuf = malloc(strlen(subdir) + sizeof(Main_Archive_Wrapper) + sizeof(Main_Archive_Kickoff) + sizeof(Main_Archive_Append));

  if (combuf == NULL) return errors_frontend_error(fee_out_of_memory, "3");

  wrapper = combuf + sizeof(Main_Archive_Kickoff) + sizeof(Main_Archive_Append) - 1;

  /* Polite not to leave a trailing space on the command ;-) */

  if (sizeof(Main_Archive_Append) == 1) sprintf(combuf, "%s %s%s",    Main_Archive_Kickoff, subdir, Main_Archive_Wrapper);
  else                                  sprintf(combuf, "%s %s%s %s", Main_Archive_Kickoff, subdir, Main_Archive_Wrapper, Main_Archive_Append);

  /* Build the wrapper */

  if (ds->matched_uid == false)
  {
    dprintf(("Diag", "main_run_from_wrapper: Building with '%s', '%s', '%s'\n", wrapper, subdir, ds->archive.first_fullname));

    ret = main_build_wrapper(ds,
                             wrapper,
                             subdir);

    free(subdir);

    if (ret == EXIT_FAILURE)
    {
      dprintf(("Fail", "main_run_from_wrapper: Building failed, bailing\n"));

      free(combuf);
      return errors_frontend_error(fee_cannot_build_wrapper);
    }
  }

  dprintf(("Diag", "main_run_from_wrapper: Calling Wimp_StartTask with '%s'\n", combuf));

  stop_iconhigh();
  status_print(lookup_token("Running:Running item...",0,0));
  update_status_screen(1, 1);
  status_grey();

  e = _swix(Wimp_StartTask,
            _IN(0),

            combuf);

  if (e == NULL)
  {
    /* Ensure exit_handler doesn't delete files under a multitasking application's feet...! */

    free(extract_path);
    extract_path = NULL;
  }

  start_iconhigh();
  free(combuf);

  dprintf(("Diag", "main_run_from_wrapper: Finished, returning &%08X\n", (int) e));

  return e;
}

/**************************************************************/
/* start_iconhigh()                                           */
/*                                                            */
/* Bring up the IconHigh module so buttons in any dialogue    */
/* boxes we open can be activated via. a highlight.           */
/**************************************************************/

static void start_iconhigh(void)
{
  if (
       _swix(IconHigh_Start,
             _IN(0),

             0) /* Highlight (not pointer) emulation */

       != NULL
     )
  {
    dprintf(("Fail", "start_iconhigh (main.c): SWI call failed\n"));
    return;
  }
}

/**************************************************************/
/* stop_iconhigh()                                            */
/*                                                            */
/* Stop the IconHigh module.                                  */
/* boxes we open can be activated via. a highlight.           */
/**************************************************************/

static void stop_iconhigh(void)
{
  if (
       _swix(IconHigh_Stop,
             _IN(0),

             0)

       != NULL
     )
  {
    dprintf(("Fail", "stop_iconhigh (main.c): SWI call failed\n"));
    return;
  }
}

/**************************************************************/
/* catch_errors()                                             */
/*                                                            */
/* Catch OS errors and report them with the opportunity to    */
/* continue or quit (done inside main itself).                */
/*                                                            */
/* This is the last function in the file since it plays       */
/* around with stack checking, and you can't read the         */
/* previous state. If this was in the middle of the source    */
/* and someone wrote a #pragma above it, endless confusion    */
/* could otherwise arise as to why the instruction had no     */
/* effect on some of the functions here...                    */
/*                                                            */
/* Parameters: The signal number (ignored).                   */
/**************************************************************/

#pragma no_check_stack

static void catch_errors(int signum)
{
  /* Store the error locally */

  StrLastE;

  /* Go back to main to report the error */

  longjmp(env, Main_FromCatchErrors);

  /* Just in case... */

  exit(EXIT_FAILURE);
}
