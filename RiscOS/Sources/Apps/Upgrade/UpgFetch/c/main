/**************************************************************/
/* File:    main.h                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: To run.                                           */
/*                                                            */
/* Author:  Mark Robertshaw; Nick Evans; Andrew Hodgkinson.   */
/*                                                            */
/* History: 26-Sep-2000 (MR):  Created.                       */
/*          10-Oct-2000 (NE):  Added CRC check.               */
/*          11-Oct-2000 (NE):  Added build check.             */
/*          12-Oct-2000 (NE):  Added Flash Bank.              */
/*          01-May-2001 (ADH): Lots of reorganisation, fixes, */
/*                             restructuring, rewriting...    */
/**************************************************************/

/*
 * This application performs the first part of a two part upgrade procedure
 * for upgrading the operating system on an NC without the need for a
 * separate operating system ("maintenance OS").
 *
 * The application fetches a compressed OS image from a supplied URL via FTP
 * and stores it in a dynamic area.  It then triggers a separate application
 * to reprogram the flash memory with the new image.
 *
 * The program provides a Wimp interface for the download process showing a
 * bar chart of the progress of the download along with status information.
 * The program launches the programming task as soon as the download is
 * complete.
 *
 * Versions post-dating 30-Apr-2001 may also take a textual configuration
 * file and pass it on for setting NVRAM details (e.g. to reconfigure the
 * ISP details), or take a packed archive containing an application to run,
 * put it in CacheFS, execute it, and tidy up afterwards.
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <setjmp.h>
#include <signal.h>
#include <math.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimplib.h>
#include <tboxlibs/toolbox.h>
#include <tcpiplibs/dirent.h>

#define __BORLANDC__ 0
#include <zlib/zlib.h>

#include <DebugLib/DebugLib.h>

#ifdef USE_CHECKURL
  #include <CheckURL.h>
#endif

#include "VersionNum"

#include "crc32.h"
#include "Dirs.h"
#include "Errors.h"
#include "FetchImage.h"
#include "globals.h"
#include "Kill.h"
#include "Structures.h"
#include "UI.h"
#include "Utils.h"
#include "URLVeneer.h"

#include "main.h"

/* The flag below states how much data we wish to read from the */
/* URL at any time.                                             */

#define Main_ChunkSize      32768

/* Extract buffer size for zlib decompression of archives */

#define Main_Extract        32768

/* Leaf name for UID file and subdirectory for extracted archive data; */
/* the length of the directory string MUST be equal to or greater than */
/* that of the UID leaf. The length of the wrapper name is arbitrary.  */

#define Main_Archive_Subdir  ".Data"
#define Main_Archive_UID     ".UID"
#define Main_Archive_Wrapper ".!Run"

/* Kick-off command etc. */

#define Main_Archive_Kickoff "Obey -c"
#define Main_Archive_Append  ""
#define Main_UpgLaunch_Run   "<" Module_ComponentName "$Dir>.UpgLaunch"
#define Main_UpgLaunch_Slot  "WimpSlot -Min 20K -Max 20K"

/* Filetypes */

#define Main_FileType_Text  0xFFF
#define Main_FileType_Obey  0xFEB
#define Main_FileType_EPROM 0xFE5

/* Temporary CheckURL area name */

#define Main_CheckURLArea   "UpgFetch_TemporaryValidationArea"

/* Tidy up some #ifdefs */

#if defined(USE_TRUSTED_DOMAINS) || defined(TEST_TRUSTED_DOMAINS_CODE)
  #define CHECK_DOMAINS
#else
  #undef CHECK_DOMAINS
#endif

// /* Structure to hold a list of known tags */
//
// typedef struct tlv_list_node
// {
//   int      tag_type;      /* The type of the tag (one word) */
//   int      tag_length;    /* The length of the tag (one word) */
//   char   * value_pointer; /* A pointer to the start of the area containing the value */
//   struct   tlv_list_node * next_tag;
//
// } tlv_list_node_type;
//
// static tlv_list_node_type * tlv_list_head = NULL; /* Head and tail pointers */
// static tlv_list_node_type * tlv_list_tail = NULL;

/* Decoding images */

typedef struct decoder_state
{
  unsigned int   crc;
  bool           crc_lock;

  /* State variables for reading a tag number */

  bool           expecting_tag;
  unsigned int   reading_tag;
  unsigned int   tag;

  /* State variables for reading the data size after the tag number */

  bool           expecting_size;
  unsigned int   reading_size;
  unsigned int   size;

  /* State variables for reading the data itself */

  bool           expecting_data;
  unsigned int   reading_data;

  /* State variables for reading specific words */

  unsigned int   reading_word;
  unsigned int   word;

  /* General operation state variables */

  bool           lock_first;
  FILE         * fout;
  int            ptr;
  char           extract_to [512];

  /* Storage for information about this file */

  image_type     type_of_image;
  unsigned int   decomp_size;
  unsigned int   file_crc;
  unsigned int   archive_uid;
  bool           have_uid;
  bool           matched_uid;

  char         * build;
  char         * locale;
  char         * display;

  /* Specific image type decoding */

  struct
  {
    bool           expecting_stubname;
    int            reading_stubname;
    char         * stubname;
    char         * fullname;
    char         * first_fullname;
    int            subtype;

    unsigned int   stage;

    unsigned int   reading_word;
    unsigned int   word;

    /* Check for a multitasking application? */

    char         * task_name;
    action_type    action;

    /* Decompression variables */

    bool           restart_zlib;
    z_stream       stream;

    /* Storage for information about a file inside the archive */

    unsigned int   itemsize;
    unsigned int   loadaddr;
    unsigned int   execaddr;
    unsigned int   itemattr;

    /* Flag to say a complete file / directory entry has been dealt with */
    /* (tidy up and reset local state machine for the next one)          */

    bool           completed;

  } archive;

  struct
  {
    unsigned int   not_tag;
    unsigned int   total;

  } image;

} decoder_state;

/* Local variables */

#ifdef DEBUGLIB

  static char       * type_names []       = {
                                              "OS image",
                                              "Font upgrade",
                                              "Exec special",
                                              "Transient executable",
                                              "Resident executable",
                                              "Permanent executable"
                                            };

  static char       * action_names[]      = {
                                              "no action",
                                              "abort",
                                              "replace"
                                            };

#endif

static char         * extract_path        = NULL;  /* Set up if extracting an archive, allowing tidy-up if the download is aborted */
static FILE         * extract_fout        = NULL;  /* We might be holding a file open when we want to wipe the partial download... */

static char         * dynamic_area_base   = NULL;
static unsigned int   dynamic_area_number = 0;
static unsigned int   dynamic_area_size   = 0;
// static bool           crc_validated       = false; /* This variable gets set if the CRC of the image has been validated */
// static int            memory_bank         = 0;     /* Memory bank to write to */
static unsigned int   total_bytes_to_read = 0;     /* Total bytes to read - this can be obtained from either the FTP server or the filelength tag */

static bool           session_registered  = false; /* Record whether or not we should deregister with the URL module in the atexit handler */
static unsigned int   session_identifier  = 0;

/* Local functions */

static void                 exit_handler                   (void);

static void                 check_for_timeout              (const int server_timeout);
static float                read_time_in_seconds           (void);

static _kernel_oserror    * main_initialise_toolbox        (void);
static _kernel_oserror    * main_initialise_eventlib       (void);

static int                  reset_machine                  (int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle);
static int                  quit_app                       (int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle);
static int                  main_null                      (int event_code, WimpPollBlock * block, IdBlock * id_block, void * handle);
static int                  main_quit_message              (WimpMessage * message, void * handle);

static bool                 fetch_data                     (char ** dynamic_area_current_ptr, const int server_timeout);
// static unsigned int         read_little_word               (const char * const buff);

#ifdef ENABLE_DEBUGGING
  static unsigned int       return_free_memory             (void);
#endif

// static void                 display_linked_list            (void);
// static void                 free_list                      (void);
// static void                 decode_tlv_tags_after_download (void);
// static tlv_list_node_type * return_tlv_of_type             (const unsigned int type);
//
// static bool                 validate_crc                   (unsigned int expected_crc, const char * const end_location);
// static void                 checkBuild                     (char * builds);
static bool                 setup_proxy                    (const unsigned int session);

#ifdef CHECK_DOMAINS
  #ifndef USE_CHECKURL
    static bool             rightmatches                   (const char * p1, const char * p2, const char * s1, const char * s2);
  #endif
  static bool               validate_domain                (const char * const url, const char * const allowed_domains);
#endif

static _kernel_oserror    * main_create_directory          (const char * name);
static void                 main_init_decoder              (decoder_state * ds);
static void                 main_add_word_to_crc           (decoder_state * ds, unsigned int word, bool check);

static int                  main_decode_chunk              (const char * buf, unsigned int amount, bool first, decoder_state * ds, unsigned int incoming_size);
static int                  main_decode_data_chunk         (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_data_word_chunk    (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_data_string_chunk  (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_data_image_chunk   (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_ofec               (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_trp                (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_trp_stubname       (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_trp_subtype        (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_trp_subtype_isdir  (const char * buf, unsigned int amount, bool first, decoder_state * ds);
static int                  main_decode_trp_subtype_isfile (const char * buf, unsigned int amount, bool first, decoder_state * ds);

static _kernel_oserror    * main_run_from_wrapper          (decoder_state * ds);
static int                  main_build_wrapper             (decoder_state * ds, const char * name, const char * subdir);
static int                  main_unlock_files              (const char * top_path, const char * current);

static void                 start_iconhigh                 (void);
static void                 stop_iconhigh                  (void);

static void                 catch_errors                   (int signum);


/**************************************************************/
/* exit_handler()                                             */
/*                                                            */
/* General cleanup function registered through atexit().      */
/**************************************************************/

static void exit_handler(void)
{
  _kernel_oserror * e;

  /* Hang up the line - this fixes MPT fault 142. They have  */
  /* asked for the line to be hungup when the program fails. */

  e = _swix(NCDial_Hangup, 0);

  if (e != NULL)
  {
    dprintf(("Fail", "exit_handler (main.c): Error from NCDial_Hangup ('%s')\n", e->errmess));
  }

  /* Stop IconHigh so Return etc. doesn't keep getting trapped */

  stop_iconhigh();

  /* Registered with the URL module? */

  if (session_registered == true)
  {
    e = _swix(URL_Deregister,
              _INR(0,1),

              0,
              session_identifier);

    if (e != NULL)
    {
      dprintf(("Fail", "exit_handler (main.c): Error from URL_Deregister ('%s')\n", e->errmess));
    }
  }

  /* Attempt to tidy up any archive files we might have downloaded */

  if (extract_path != NULL && *extract_path != '\0')
  {
    _swix(Hourglass_On, 0);

    if (extract_fout != NULL) fclose(extract_fout), extract_fout = NULL;

    if (main_unlock_files(extract_path, NULL) == EXIT_SUCCESS)
    {
      _swix(OS_FSControl,
            _INR(0,1) | _IN(3),

            27,    /* 27 = Wipe objects */
            extract_path,
            3);    /* Flags; bits 0 and 1 set -> Recurse, Force */
    }

    _swix(Hourglass_Off, 0);
  }

  /* Kill the dynamic area */

  if (dynamic_area_base != 0)
  {
    e = _swix(OS_DynamicArea,
              _INR(0,1),

              1,
              dynamic_area_number);

    if (e != NULL)
    {
      dprintf(("Fail", "exit_handler (main.c): Error from OS_DynamicArea ('%s')\n", e->errmess));
    }
  }

  return;
}

#ifdef TEST_TRUSTED_DOMAINS_CODE

  #define test_url(url, allowed, pass) printf("Testing url '%s' against allowed list '%s': ", url, allowed); \
                                       if (validate_domain(url, allowed)==pass) printf("OK\n");              \
                                       else printf("*** FAIL ***\n");

  /**************************************************************/
  /* main_self_test()                                           */
  /*                                                            */
  /* Run the self-test. Manual inspection of output required.   */
  /**************************************************************/

  int main_self_test(void)
  {
    printf("Testing cases which should be allowed:\n\n");

    test_url("http://www.pace.co.uk",               ".pace.co.uk",               true);
    test_url("http://support.pace.co.uk",           ".funai.co.jp, .pace.co.uk", true);
    test_url("http://w.pace.co.uk",                 ".pace.co.uk",               true);
    test_url("http://www.pace.co.uk/test.html",     ".pace.co.uk",               true);
    test_url("http://www.pace.co.uk/test.html",     ".pace.co.uk",               true);
    test_url("http://support.pace.co.uk/test.html", ".funai.co.jp, .pace.co.uk", true);
    test_url("http://w.pace.co.uk/test.html",       ".pace.co.uk",               true);
    test_url("http://WWW.PACE.CO.UK",               ".pace.co.uk",               true);
    test_url("http://www.pace.co.uk",               ".PACE.CO.UK",               true);

    printf("\nTesting cases which should be rejected:\n\n");

    test_url("http://pace.co.uk",                   ".pace.co.uk, mptech.co.jp", false);
    test_url("http://pace.co.uk/test.html",         ".pace.co.uk, mptech.co.jp", false);
    test_url("http://pace.co.uk",                   ".pace.co.uk",               false);
    test_url("http://pace.co.uk.ha.co.uk",          ".pace.co.uk",               false);
    test_url("http://pace.co.ukc",                  ".pace.co.uk",               false);
    test_url("http://ace.co.uk",                    ".pace.co.uk",               false);
    test_url("http://space.co.uk",                  ".pace.co.uk",               false);
    test_url("http://space.co.uk",                  ".pace.co.uk",               false);
    test_url("http://pace.co.uk",                   ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk.ha.co.uk",          ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.ukc",                  ".funai.co.jp, .pace.co.uk", false);
    test_url("http://ace.co.uk",                    ".funai.co.jp, .pace.co.uk", false);
    test_url("http://space.co.uk",                  ".funai.co.jp, .pace.co.uk", false);
    test_url("http://space.co.uk",                  ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk/test/",             ".pace.co.uk, .funai.co.jp", false);
    test_url("http://pace.co.uk.ha.co.uk/test/",    ".pace.co.uk, .funai.co.jp", false);
    test_url("http://pace.co.ukc/test/",            ".pace.co.uk, .funai.co.jp", false);
    test_url("http://ace.co.uk/test/",              ".pace.co.uk, .funai.co.jp", false);
    test_url("http://space.co.uk/test",             ".pace.co.uk, .funai.co.jp", false);
    test_url("http://space.co.uk/test",             ".pace.co.uk, .funai.co.jp", false);
    test_url("http://pace.co.uk/test",              ".pace.co.uk",               false);
    test_url("http://pace.co.uk",                   ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk.ha.co.uk",          ".funai.co.jp, .pace.co.uk", false);
    test_url("http://pace.co.uk?q=www.fool.com",    ".pace.co.uk",               false);
    test_url("http://fooled.co.uk/pace.co.uk",      ".pace.co.uk",               false);

    return EXIT_SUCCESS;
  }

#endif /* TEST_TRUSTED_DOMAINS_CODE */

/**************************************************************/
/* main()                                                     */
/*                                                            */
/* Entry point for non-TEST_TRUSTED_DOMAINS_CODE builds.      */
/*                                                            */
/* This requires a URL as its only command line argument. It  */
/* controls the downloading of a compressed image into a      */
/* dynamic area:                                              */
/*                                                            */
/* 1) Read URL from command line                              */
/* 2) Create a dynamic area to store the compressed image     */
/* 3) Connect to the FTP Server                               */
/* 4) Get the image Main_ChunkSize at the time                */
/* 5) Launch the child task                                   */
/**************************************************************/

int main(int argc, char *argv[])
{
  _kernel_oserror    * e;

//  char               * dynamic_area_current_ptr = NULL;  /* Pointer to current bit */
//  char               * image_pointer            = NULL;  /* This points to the start if the image to be put into Flash in the DA. */
//  tlv_list_node_type * image_pointer_tlv        = NULL;
//  int                  image_size               = 0;     /* Size of image */

  char                 url                        [256]; /* Copy of URL string from argv[1] */
  char               * url_p;
  int                  server_timeout;

  /* Self test build? */

  #ifdef TEST_TRUSTED_DOMAINS_CODE
    return main_self_test();
  #endif

  /* Initialise the DebugLib library. */

  debug_initialise("UpgFetch", "izipfs:$.FetchOut", "");
  debug_output_device(TML_OUTPUT);
  debug_atexit();

  dprintf(("", "\n"));
  dprintf(("Diag", "main (main.c): Running\n"));

  /* NB, don't forget to echo any changes here with the duplicate code */
  /* just below the setjmp call later.                                 */

  signal(SIGOSERROR, catch_errors); /* OS error            */
  signal(SIGILL,     catch_errors); /* Illegal instruction */
  signal(SIGSEGV,    catch_errors); /* Segment violation   */
  signal(SIGSTAK,    catch_errors); /* Stack overflow      */
  signal(SIGFPE,     catch_errors); /* FPE error           */

  /* Set up an atexit() handler */

  atexit(exit_handler);

  /* Read the command line arguments. There should be two arguments we read; */
  /* the second one should be the URL.                                       */

  if (argc < 2)
  {
    dprintf(("Fail", "main (main.c): Not enough arguments supplied, exitting\n"));
    exit(EXIT_FAILURE);
  }

  /* Take a local copy of the URL, stripping of "upgrade:" prefix if present  */

  url_p = argv[1];
  if (!utils_strncasecmp(url_p, "upgrade:", sizeof("upgrade:") - 1)) url_p += sizeof("upgrade:") - 1;
  StrNCpy0(url, url_p);

  /* Start as a Wimp task */

  errors_show(main_initialise_toolbox());
  errors_show(main_initialise_eventlib());

  /* Initialise IconHigh */

  start_iconhigh();

  /* 01-May-2001 (ADH): Presently a proliferation of Wimp_Poll call points (yikes!) */
  /* means there's no sensible central point to put a longjmp handler for critical  */
  /* error recovery. So put it here, and force a bail-out on error.                 */

  if (setjmp(env) == Main_FromCatchErrors)
  {
    /* Long jump handler - most nasty or generally unexpected */
    /* errors will come back to here. The OS error abort      */
    /* handler jumps back here to deal with the error as we   */
    /* then have a clear stack; this is to avoid 'no stack    */
    /* for trap handler' errors caused by a SWI corrupting    */
    /* the value of R10.                                      */

    char         * tok        = NULL;
    unsigned int * regdump    = NULL;
    unsigned int * os_regdump = NULL;
    char           pc[16];

    /* Sort out the register dump */

    _swix(OS_ChangeEnvironment,
          _INR(0,3) | _OUT(3),

          7, /* Call back */
          0,
          0,
          0,

          &regdump); /* Where the C library put the registers */

    _swix(OS_ChangeEnvironment,
          _INR(0,3) | _OUT(1),

          13, /* Exception registers */
          0,
          0,
          0,

          &os_regdump); /* Where *ShowRegs gets them from */

    /* Copy the C register dump into the OS space */

    if (regdump && os_regdump) memcpy(os_regdump, regdump, 4 * 16);

    /* Store a more sensible error in the error block 'erb' where possible. */

    switch (erb.errnum & 0x00ffffff)
    {
      case 0x000000: tok = "EZeros0"; break;
      case 0x000001: tok = "EZeros1"; break;
      case 0x000002: tok = "EZeros2"; break;
      case 0x000003: tok = "EZeros3"; break;
      case 0x000005: tok = "EZeros5"; break;
    }

    if (tok)
    {
      char * error;

      /* If we know the PC, put this in the message */

      if (!regdump) sprintf(pc, "&deaddead");
      else          sprintf(pc, "&%08X", os_regdump[15] &~ 0xfc000003);

      error = lookup_token(tok, 1, pc);

      /* If the message token wasn't found, use the OS error, */
      /* otherwise copy the new one into the error block.     */

      if (strcmp(error, "!")) StrNCpy0(erb.errmess, error);
    }

    /* Need to reinstall the signal handlers since the run-time */
    /* system will have removed them 'For Your Safety And       */
    /* Convenience'. Don't forget to keep this list up to date  */
    /* with the code near the top of the function.              */

    signal(SIGOSERROR, catch_errors); /* OS error            */
    signal(SIGILL,     catch_errors); /* Illegal instruction */
    signal(SIGSEGV,    catch_errors); /* Segment violation   */
    signal(SIGSTAK,    catch_errors); /* Stack overflow      */
    signal(SIGFPE,     catch_errors); /* FPE error           */

    erb.errnum = Errors_Custom_Fatal; /* Force 'Quit' */
    errors_ret(&erb);

    exit(EXIT_FAILURE);
  }

  /* Ensure that the URL is from a trusted source */

///  #ifdef USE_TRUSTED_DOMAINS
///
///    if (!validate_domain(url,  USE_TRUSTED_DOMAINS))
///    {
///      dprintf(("Fail", "main (main.c): %s is not a trusted domain. Exitting...\n", url));
///      quit("InvalidServer");
///    }
///
///  #endif /* USE_TRUSTED_DOMAINS */

  /* Create ourselves a dynamic area */

  dprintf(("Diag", "main (main.c): Creating a dynamic area\n"));

//   if (
//        _swix(OS_DynamicArea,
//              _INR(0,8) | _OUT(1) | _OUT(3),
//
//              0,                /* Reason code 0 = claim area */
//              -1,               /* Must be -1                 */
//              1,                /* Initial area size in bytes */
//              -1,               /* Must be -1                 */
//              0,                /* Flags - all zero here      */
//              10 * 1024 * 1024, /* 10MB max size              */
//              0,                /* No handler routine...      */
//              0,                /* ...so no workspace needed  */
//              "UpgFetch data",  /* Area's name                */
//
//              &dynamic_area_number,
//              &dynamic_area_base)
//
//        != NULL
//      )
//   {
//     error_occurred("CantClaimDynamicArea");
//   }
//   else
//   {
//     dynamic_area_current_ptr = dynamic_area_base;
//   }

  /* Free up some memory by killing running applications */

  dprintf(("Diag", "main (main.c): Attempting to kill various applications...\n"));

  if (!kill_apps())
  {
    error_occurred("CantKillApplications");
  }

  /* Enable null events for fetching */

  dprintf(("Diag", "main (main.c): Claiming null events\n"));

  register_null_claimant(Wimp_ENull, main_null, NULL);

  /* Status window setup */

  dprintf(("Diag", "main (main.c): Opening the status window\n"));

  initialise_status_screen();

  /* Register the session and set the session_identifier flag */

  dprintf(("Diag", "main (main.c): Registering with URL_Fetcher\n"));

  if (
       _swix(URL_Register,
             _IN(0) | _OUT(1),

             0,

             &session_identifier)

       != NULL
     )
  {
    error_occurred("CantConnectToFTPServer");
  }
  else
  {
    session_registered = true;
    status_print(lookup_token("ConnectFTP",0,0));
  }

  /* Set up the proxy (if any) */

  if (!setup_proxy(session_identifier))
  {
    dprintf(("Diag,Fail", "main (main.c): Could not connect via. a proxyr\n"));
  }

  /* Initiate the data fetch */

  dprintf(("Diag", "main (main.c): Starting URL fetch\n"));

  e = _swix(URL_GetURL,
            _INR(0,6),

            0,                   /* Flags - all clear this time                          */
            session_identifier,
            URL_Method_http_GET, /* GET the item                                         */
            url,
            NULL,                /* No extra data to send                                */
            2,                   /* Historical API oddity. R5 must be 2 as R0:1 is clear */
            NULL);               /* No user agent string supplied                        */

  if (e != NULL)
  {
    dprintf(("Fail", "main (main.c): Error '%s' from URL_GetURL", e->errmess));
    error_occurred("CantFetchURL");
  }

  /* Get the server timeout value from message file */

  server_timeout = atoi(lookup_token("ServerTimeout",0,0));

//  /* Initialise the linked list of TLV values. */
//
//  tlv_list_head = NULL;
//  tlv_list_tail = NULL;

  /* Call the main data fetch routine. This does its own local poll loop and */
  /* returns only upon fetch completion.                                     */

  if (fetch_data(NULL, server_timeout) == false) quit("BrokenImage");

  /* Deregister with the URL module */

  _swix(URL_Deregister,
        _INR(0,1),

        0,
        session_identifier);

  session_registered = false;
  session_identifier = 0;

//  /* Decode the TLV tags. */
//
//  decode_tlv_tags_after_download();
//
//  /* Calculate the final image size. */
//
//  image_size = dynamic_area_current_ptr - dynamic_area_base;
//  dprintf(("Diag", "main (main.c): Final image size is %d bytes\n", image_size));
//
//  if (image_size <= 0)
//  {
//    dprintf(("Fail", "main (main.c): Image too small\n"));
//    exit(EXIT_FAILURE);
//  }
//
//  /* Display the linked list */
//  display_linked_list();
//
//  /* Obtain a pointer to the image to be programmed from the linked list. */
//  image_pointer_tlv = return_tlv_of_type(TLV_TAG_TYPE_IMAGE_DATA);
//  image_pointer = image_pointer_tlv->value_pointer;
//
//  dprintf(("Diag", "main (main.c): Image start is at &%08X\n", (int) image_pointer));
//
//  /* Free the list. */
//  free_list();
//
//  /* Only attempt to flash the image if it's CRC has been validated. */
//  if (crc_validated)
//  {
//    char command_line_arguments [256];
//    char child_task             [256];
//
//    //removed this message so that the user doesn't see a change
//    //when programming begins
//    //    status_print(lookup_token("Programming",0,0));
//    poll_wimp();
//
//    /* Create the string to pass the dynamic area address and image size to the atmel flash programmer */
//    strcpy(child_task, lookup_token("ChildTask",0,0) );
//    //  memory_bank = atoi( lookup_token("MemoryBank",0,0) );
//    sprintf(command_line_arguments, "%s %i -memory -size %i -os %i",
//            child_task, (int)image_pointer, image_pointer_tlv->tag_length,
//            memory_bank);
//
//    /* Finally execute the string including the child task string */
//
//    dprintf(("Diag", "main (main.c): UpgFlash command line args: '%s'\n", command_line_arguments));
/////    _kernel_oscli(command_line_arguments);
//exit(EXIT_SUCCESS);
//  }

  return EXIT_SUCCESS;
}

/* This function checks that we are still receiving data from the server
essentially if we don't receive any data in the time specified in the
messages file as ServerTimeout it returns an error.
*/
static void check_for_timeout(const int server_timeout)
{
  float current_timer_value;

  /* increment the number of null reads */
  number_of_null_reads ++;

  /* set up the timer for the first time */
  if (last_timer_value == 0)
  {
    last_timer_value = read_time_in_seconds();
    return;
  }

  /* if number of null reads > NULL_COUNTOUT check for data stream */
  if (number_of_null_reads > NULL_COUNTOUT)
  {
    current_timer_value = read_time_in_seconds();

    /* check for activity for NULL_TIMEOUT seconds */
    if ( (current_timer_value - last_timer_value) > server_timeout )
    {
      error_occurred("ServerError");
    }
    else
    {
      number_of_null_reads = 0;
    }
  }
}

/**************************************************************/
/* read_time_in_seconds()                                     */
/*                                                            */
/* Read the monotonic time divided by 100, as a float.        */
/*                                                            */
/* Returns:    Monotonic time / 100.                          */
/**************************************************************/

static float read_time_in_seconds(void)
{
  unsigned int t;

  _swix(OS_ReadMonotonicTime,
        _OUT(0),

        &t);

  return ((float) t) / 100;
}

/**************************************************************/
/* main_initialise_toolbox()                                  */
/*                                                            */
/* Start up as a Toolbox task.                                */
/**************************************************************/

static _kernel_oserror * main_initialise_toolbox(void)
{
  /* As well as starting us as a Wimp task, the Toolbox opens the */
  /* Messages file.                                               */

  return toolbox_initialise(0,                                /* Flags                                */
                            310,                              /* Minimum Wimp version                 */
                            messages_list,                    /* List of required messages            */
                            event_code_list,                  /* List of required events              */
                            "<" Module_ComponentName "$Dir>", /* Application directory                */
                            &meb,                             /* Messages file control block          */
                            &idb,                             /* Our application's local ID block     */
                            0,                                /* (Current wimp version returned here) */
                            0,                                /* (Task handle returned here)          */
                            (void *) &sprite_block);          /* Local sprite area returned here      */
}

/**************************************************************/
/* main_initialise_eventlib()                                 */
/*                                                            */
/* Set up EventLib for all operations.                        */
/**************************************************************/

static _kernel_oserror * main_initialise_eventlib(void)
{
  RetError(event_initialise(&idb));

  RetError(event_register_toolbox_handler(-1, UI_EVENT_QUIT,  quit_app,      NULL));
  RetError(event_register_toolbox_handler(-1, UI_EVENT_RESET, reset_machine, NULL));

  RetError(event_register_message_handler(Wimp_MQuit, main_quit_message, NULL));

  return NULL;
}

/**************************************************************/
/* main_poll()                                                */
/*                                                            */
/* Poll EventLib until null reason is seen.                   */
/**************************************************************/

void main_poll(void)
{
  int reason;

  do
  {
    errors_show(event_poll(&reason, &b, NULL));
  }
  while (reason != 0);
}

/**************************************************************/
/* reset_machine()                                            */
/*                                                            */
/* Handler to reset the machine. Parameters are as standard   */
/* for a Toolbox event handler.                               */
/**************************************************************/

static int reset_machine(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{

exit(EXIT_SUCCESS);
///  _swix(OS_Reset, 0);

  return 1;
}

/**************************************************************/
/* quit_app()                                                 */
/*                                                            */
/* Handler to quit the application. Parameters are as         */
/* standard for a Toolbox event handler.                      */
/**************************************************************/

static int quit_app(int event_code, ToolboxEvent * event, IdBlock * id_block, void * handle)
{
  exit(EXIT_SUCCESS);

  return 1;
}

/**************************************************************/
/* main_null()                                                */
/*                                                            */
/* Handler for null reason codes.  Parameters are as          */
/* standard for a Toolbox event handler.                      */
/**************************************************************/

static int main_null(int event_code, WimpPollBlock * block, IdBlock * id_block, void * handle)
{
  return 0;
}

/**************************************************************/
/* main_quit_message()                                        */
/*                                                            */
/* Wimp message handler for Wimp_MQuit messages.              */
/*                                                            */
/* Parameters are as standard for a Toolbox message handler.  */
/**************************************************************/

static int main_quit_message(WimpMessage * message, void * handle)
{
  (void) message;
  (void) handle;

  quit_app(UI_EVENT_QUIT, NULL, NULL, NULL);

  return 0;
}




/* This routine performs the fetching of the data from the URL.
   Here we get 32k chunks of data at a time.  If we can we try and read
  the number of bytes remaining to be read as soon as possible so as to
  ensure we don't run out of memory in the dynamic area.  If this isn't
  possible we allocate the memory on the fly and hope for the best !!

  The first part of the image shall be an header in the format as specified
   by the specification 2503/047/FS. This header consists of a series of
   Tag-Length-Value triplets that contain imformation about theimage embedded
   within the file.
  */
static bool fetch_data(char ** dynamic_area_current_ptr, const int server_timeout)
{
  _kernel_oserror  * error                = NULL;
  _kernel_swi_regs   regs;
  char               buff_in [Main_ChunkSize];     /* Buffer for the latest chunk of data from the URL */
  int                raw_bytes_read;               /* Bytes read in a single pass */
  int                valid_bytes_read;             /* Bytes read minus any header bytes stripped */
  int                total_bytes_read     = 0;     /* Total bytes read */
//  int                bytes_left_to_read   = -1;    /* Bytes left to read */
//
//  bool               checked_free_memory  = false; /* If this flag is set then the program has recived the size
//                                                    * of the file from the server, and has allocated the correct
//                                                    * DA size. If it is unset, then as it reads some data from
//                                                    * the URL it also allocates the memory for it to be put in.
//                                                    */

  bool               started_getting_data = false; /* Flag */
//  bool               success              = true;

//  unsigned int       mem_da_size          = 0;
//  unsigned int       mem_da_used          = 0;

  char             * data_out;                     /* Pointer to start of data */
  int                l;
  char               state                = '?';
  int                got_http_header      = 0;

  bool               first                = true;
  decoder_state      ds;

  while (!error)
  {
    dprintf(("Diag", "fetch_data (main.c): Bytes to read %d, total bytes read %d\n",
                     total_bytes_to_read,
                     total_bytes_read));

    /* Poll the Wimp to update any Toolbox changes */

    main_poll();

    /* Exit if we've got all the data */

    if (total_bytes_to_read > 0 && total_bytes_read == total_bytes_to_read) break;

    regs.r[0] = 0;
    regs.r[1] = session_identifier;
    regs.r[2] = (int) buff_in;
    regs.r[3] = Main_ChunkSize;

    /* Read next Main_ChunkSize sized chunk */

    error = _kernel_swi(URL_ReadData, &regs, &regs);

    /* Check to see that we have finished */

    if (error != NULL)
    {
      dprintf(("Fail", "fetch_data (main.c): Fetch error '%s'\n", error->errmess));

      regs.r[0] = 0;
      regs.r[1] = session_identifier;

      error = _kernel_swi(URL_Status, &regs, &regs);

      /* Transfer aborted, or all data not received? */

      if (error != NULL || !(regs.r[0] & 0x30)) /* Bit 5 set -> all data received */
      {
        error_occurred("ServerError");
      }

      /* Otherwise, should have all the data */

      break;
    }

    raw_bytes_read = regs.r[4];

    valid_bytes_read = raw_bytes_read;
    data_out         = buff_in;

    if (!got_http_header)
    {
      /* Search for the CR/LF/CR/LF at the end of the HTTP header */

      for (l = 0; l < raw_bytes_read; l++)
      {
        switch (state)
        {
          case '\r':
          {
            dprintf(("Diag", "fetch_data (main.c): State is '\\r'\n"));

            if (*data_out == '\n') state = '\n';
            else                   state = '?';
          }
          break;

          case '\n':
          {
            dprintf(("Diag", "fetch_data (main.c): State is '\\n'\n"));

            if (*data_out == '\r') state='R';
            else                   state='?';
          }
          break;

          case 'R':
          {
            dprintf(("Diag", "fetch_data (main.c): State is 'R'\n"));

            if (*data_out == '\n')
            {
              dprintf(("Diag", "fetch_data (main.c): Read final '\\n'\n"));

              state           = '\r';
              got_http_header = 1;
              l               = raw_bytes_read; /* Force end of for() loop */
            }
            else state = '?';
          }
          break;

          case '?':
          {
            if (*data_out == '\r') state = '\r'; /* Possible start of a CR/LF/CR/LF sequence */
          }
          break;
        }

        data_out++;
        valid_bytes_read--;
      }
    }


    if (valid_bytes_read > 0)
    {
      dprintf(("Diag", "fetch_data (main.c): have read %d bytes from the URL.\n", valid_bytes_read));

      /* update the variable holding the total bytes read */
      total_bytes_read += valid_bytes_read;

       // if we haven't already done so update the display
       if (started_getting_data == false)
       {
         status_print(lookup_token("Downloading",0,0));
         started_getting_data = true;
       }

       if (regs.r[5] != -1 || total_bytes_to_read > 0)
       {
         if (regs.r[5] != -1) total_bytes_to_read = regs.r[5] + total_bytes_read;
       }

//       /* if we haven't already done so, check we have the required free ram. */
//       if (checked_free_memory == false)
//       {
//        bytes_left_to_read = regs.r[5];
//
//        /* if we receive notification of how much left */
//        if (bytes_left_to_read != -1 || total_bytes_to_read > 0)
//        {
//          int amount_to_allocate;
//          /* We now know (either from the server or the upgrade file itself) how much memory we need. Allocate it.*/
//          if (bytes_left_to_read != -1)
//          {
//            total_bytes_to_read = bytes_left_to_read + total_bytes_read;
//            amount_to_allocate = bytes_left_to_read + valid_bytes_read;
//          }
//          else
//          {
//            amount_to_allocate = total_bytes_to_read-mem_da_size;
//          }
//
//         /* allocate memory for the whole image */
//
//         dprintf(("Diag", "fetch_data (main.c): Attempting to increase size of DA holding image by %d bytes (free memory in system is %d bytes).\n", amount_to_allocate, return_free_memory()));
//
//         regs.r[0] = dynamic_area_number;
//         regs.r[1] = amount_to_allocate;
//         error = _kernel_swi(OS_ChangeDynamicArea, &regs, &regs);
//         if (error)
//         {
//           dprintf(("Fail", "fetch_data (main.c): DA area increase failed - allocated %d bytes instead of the required %d bytes (message '%s').\n", regs.r[1], amount_to_allocate, error->errmess));
//           error_occurred("NotEnoughMemory");
//         }
//         else
//         {
//           mem_da_size+=amount_to_allocate;
//           mem_da_used+=valid_bytes_read;
//         }
//
//         checked_free_memory = true;
//       }
//     }
//
//     /* If we still don't know how large the image is allocate enough
//         for the currently read block (dynamically). This needs to be done to the nearest page size. */
//     if (checked_free_memory == false)
//     {
//       double d_mem_requested = (double) valid_bytes_read;
//       int i_mem_requested;
//       d_mem_requested = ceil(d_mem_requested/4096)*4096; /* Page-align it */
//       i_mem_requested = (int)d_mem_requested;
//       dprintf(("Diag", "fetch_data (main.c): We want %d more bytes (free memory in system is %d bytes).\n", i_mem_requested, return_free_memory()));
//       dprintf(("Diag", "fetch_data (main.c): Current DA size is %d bytes, used is %d bytes\n", mem_da_size, mem_da_used));
//
//       /* If we have not got enough space in the da, increase the size. */
//       if ((i_mem_requested+mem_da_used) >= mem_da_size)
//       {
//         dprintf(("Diag", "fetch_data (main.c): Increasing size of the DA by %d bytes.\n", i_mem_requested));
//
//         regs.r[0] = dynamic_area_number;
//         regs.r[1] = i_mem_requested;
//         error = _kernel_swi(OS_ChangeDynamicArea, &regs, &regs);
//         if (error)
//         {
//           dprintf(("Fail", "fetch_data (main.c): Incremental DA area increase failed - allocated %d bytes instead of the required %d bytes (message %s).\n", regs.r[1], valid_bytes_read, error->errmess));
//           error_occurred("NotEnoughMemory");
//         }
//         else
//         {
//           mem_da_size+=i_mem_requested;
//           mem_da_used+=valid_bytes_read;
//         }
//       }
//       else
//       {
//         mem_da_used+=valid_bytes_read;
//       }
//     }
//     else
//     {
//       mem_da_used+=valid_bytes_read;
//       dprintf(("Diag", "fetch_data (main.c): Current DA size is %d bytes, used is %d bytes\n", mem_da_size, mem_da_used));
//     }

     /* If the memory allocation has worked, copy the memory over and update the status screen. */
     if (!error)
     {
       /* copy the memory block into the dynamic area */
       dprintf(("Diag", "fetch_data (main.c): Copying %d bytes of memory\n", valid_bytes_read));
//       memcpy(*dynamic_area_current_ptr, data_out, valid_bytes_read);
       update_status_screen(total_bytes_read, total_bytes_to_read);

       if (
            main_decode_chunk(data_out,
                              valid_bytes_read,
                              first,
                              &ds,
                              total_bytes_to_read)
            == EXIT_FAILURE
          )
          return false;

       first = false;
//       *dynamic_area_current_ptr += valid_bytes_read; // increment the memory pointer
     }
     else
     {
       dprintf(("Fail", "fetch_data (main.c): Error allocating dynamic area (%s)\n", error->errmess));
     }

     /* reset the null reads counter */
     number_of_null_reads = 0;
     last_timer_value = 0;
    }
    else
    {
      /* if no bytes have been read from the URL */
      check_for_timeout(server_timeout);
    }
  }

  /* Fetching is finished. Do we need to run anything? */

  if (
       ds.type_of_image == image_type_transient ||
       ds.type_of_image == image_type_resident  ||
       ds.type_of_image == image_type_permanent
     )
     errors_show(main_run_from_wrapper(&ds));

  return true;
}









// unsigned int read_little_word(const char* const buff)
// {
//     unsigned int i = 0;
//
//     i = (*(buff)) | ((*(buff+1))<<8) | ((*(buff+2))<<16) | ((*(buff+3))<<24);
//
//     return(i);
// }
//





#ifdef ENABLE_DEBUGGING

  /**************************************************************/
  /* return_free_memory()                                       */
  /*                                                            */
  /* Return the size of the Wimp free pool.                     */
  /**************************************************************/

  static unsigned int return_free_memory(void)
  {
    unsigned int free;

    _swix(Wimp_SlotSize,
          _INR(0,1) | _OUT(2),

          -1, /* Read Current slot */
          -1, /* Read Next slot    */

          &free);

    return free;
  }

//  /* This routine decodes the file once it has been downloaded into a series of
//   TLV values in a linked list.
//  */
//  static void decode_file(const char* const memory_base, const char* const memory_end)
//  {
//    // This points to the end of the last tag found, i.e. the start of the next tag. Whenever a tag is found this gets moved up as appropriate.
//    char* end_of_last_tag = (char*)memory_base;
//
//    dprintf(("Diag", "decode_file (main.c): Called\n"));
//    end_of_last_tag = is_tag_complete(end_of_last_tag, memory_end);
//    while (end_of_last_tag && end_of_last_tag < memory_end)
//    {
//      const char* const start = end_of_last_tag;
//      dprintf(("Diag", "decode_file (main.c): end_of_last_tag = &%08X, memory_end = &%08X\n", (int) end_of_last_tag, (int) memory_end));
//      end_of_last_tag = is_tag_complete(end_of_last_tag, memory_end);
//      if (end_of_last_tag) // Tag is complete, add it to the list.
//      {
//        add_node(return_tag_type(start, memory_end), return_tag_length(start, memory_end), start+8);
//      }
//    }
//  }

#endif

// /* Parse and display the list of TLV nodes */
// static void display_linked_list(void)
// {
//   dprintf(("Diag", "display_linked_list (main.c): Called\n"));
//
//   if (tlv_list_head == NULL)
//   {
//     dprintf(("Fail", "display_linked_list (main.c): No list generated.\n"));
//   }
//   else
//   {
//     tlv_list_node_type *tlv_node_current = tlv_list_head;
//     do
//     {
//       /* Display the node details... */
//       dprintf(("Diag", "display_linked_list (main.c): Tag is of type %d length %d\n", tlv_node_current->tag_type, tlv_node_current->tag_length));
//
//       /* Move onto the next node... */
//       tlv_node_current = tlv_node_current->next_tag;
//     }
//     while (tlv_node_current != NULL);
//   }
// }
//
//
// /* This goes through the list and frees all memory allocated. */
// static void free_list(void)
// {
//   dprintf(("Diag", "free_list (main.c): Called\n"));
//
//   if (tlv_list_head == NULL)
//   {
//     dprintf(("Diag", "free_list (main.c): Null list.\n"));
//   }
//   else
//   {
//     tlv_list_node_type *tlv_node_current = tlv_list_head;
//     do
//     {
//       tlv_list_node_type* node_to_delete = tlv_node_current;
//
//       dprintf(("Diag", "free_list (main.c): Freeing node..\n"));
//
//       /* Move onto the next node... */
//       tlv_node_current = tlv_node_current->next_tag;
//
//       /* And free the node to be deleted. */
//       if (node_to_delete)
//       {
//         free (node_to_delete);
//         node_to_delete = NULL;
//       }
//     }
//     while (tlv_node_current != NULL);
//   }
//
//   /* Finally set the head pointer to NULL. */
//   tlv_list_head = NULL;
// }
//
//
// /* This routine is called after the download has completed so that we can act
// on the TLV tags. For instance in this routine the CRC check is called. */
//
// static void decode_tlv_tags_after_download(void)
// {
//   dprintf(("Diag", "decode_tlv_tags_after_download (main.c): Called\n"));
//
//   /* Scan through the list of tags, acting on each of them in turn. */
//   if (tlv_list_head == NULL)
//   {
//     dprintf(("Fail", "decode_tlv_tags_after_download (main.c): No list generated.\n"));
//   }
//   else
//   {
//     tlv_list_node_type *tlv_node_current = tlv_list_head;
//     do
//     {
//       /* Now act on this TLV type. */
//       switch (tlv_node_current->tag_type)
//       {
//         case TLV_TAG_TYPE_FILE_SIZE:
//           break;
//         case TLV_TAG_TYPE_DISPLAY_STRING:
//           break;
//         case TLV_TAG_TYPE_BUILD_LIST:
//           checkBuild(tlv_node_current->value_pointer);
//           break;
//         case TLV_TAG_TYPE_LOCALE_LIST:
//           break;
//         case TLV_TAG_TYPE_IMAGE_TYPE:
//           break;
//         case TLV_TAG_TYPE_IMAGE_LENGTH:
//           break;
//         case TLV_TAG_TYPE_IMAGE_DATA:
//           break;
//         case TLV_TAG_TYPE_FILE_CRC:
//           {
//           unsigned int crc_value = read_little_word(tlv_node_current->value_pointer);
//           dprintf(("Diag", "decode_tlv_tags_after_download (main.c): This is a CRC of value %d.\n", crc_value));
//           crc_validated = validate_crc(crc_value, tlv_node_current->value_pointer-8);
//           }
//           break;
//         case TLV_TAG_TYPE_RANDOM_DATA:
//           break;
//         case TLV_TAG_TYPE_UNRECOGNISED:
//           break;
//         case TLV_TAG_TYPE_BANK:
//           memory_bank=read_little_word(tlv_node_current->value_pointer);
//           break;
//         default:
//           break;
//       }
//
//       /* Move onto the next node... */
//       tlv_node_current = tlv_node_current->next_tag;
//     }
//     while (tlv_node_current != NULL);
//   }
// }
//
//
// /* This routine scans through the list of TLV's and does what is necessary after the whole file has been downloaded. Currently we do not need to do anything after the file has been downloaded. */
// void decode_tags_after_download(void)
// {
//   dprintf(("Diag", "decode_tags_after_download (main.c): Called\n"));
//
//   if (tlv_list_head == NULL)
//   {
//     dprintf(("Diag", "decode_tags_after_download (main.c): Null list.\n"));
//   }
//   else
//   {
//     tlv_list_node_type *tlv_node_current = tlv_list_head;
//     do
//     {
//       // decode this tag...
//
//       // Move onto the next node...
//       tlv_node_current = tlv_node_current->next_tag;
//     }
//     while (tlv_node_current != NULL);
//   }
// }
//
//
//
// /* This routine can be used to scan through a list of TLV's and return the
//     first one that it comes across of a certain type. */
// static tlv_list_node_type * return_tlv_of_type(const unsigned int type)
// {
//   dprintf(("Diag", "return_tlv_of_type (main.c): Called\n"));
//
//   if (tlv_list_head == NULL)
//   {
//     dprintf(("Fail", "return_tlv_of_type (main.c): No list generated.\n"));
//   }
//   else
//   {
//     tlv_list_node_type *tlv_node_current = tlv_list_head;
//     do
//     {
//       /* Is this node of the type that we want... */
//       if (tlv_node_current->tag_type == type)
//       {
//         return (tlv_node_current);
//       }
//
//       /* Move onto the next node... */
//       tlv_node_current = tlv_node_current->next_tag;
//     }
//     while (tlv_node_current != NULL);
//   }
//
//   return (NULL);
// }
//
//
//
// /* This routine checks that the image is correct up to the passed location.
// It returns true if the crc matches, false oterwise. */
//
// static bool validate_crc(unsigned int expected_crc, const char* const end_location)
// {
//   unsigned int crc;
//   unsigned int size = 0;
//   char* ch;
//
//   dprintf(("Diag", "validate_crc (main.c): We are expecting an end value of %d\n", expected_crc));
//
//   make_crc_tables();
//
//   dprintf(("Diag", "validate_crc (main.c): CRC tables constructed\n"));
//
//   /* Ensure that we are not attmepting to read from NULL */
//   if (dynamic_area_base == NULL)
//   {
//     dprintf(("Diag", "validate_crc (main.c): Urgh, dynamic_area_base is NULL. Bailing.\n"));
//     return (false);
//   }
//
//   /* crc precondition */
//   crc=0xffffffff;
//
//   dprintf(("Diag", "validate_crc (main.c): CRCed image follows:\n"));
//
//   ch = dynamic_area_base;
//   do
//   {
//     update_crc((U8*)ch,(U32*)&crc);
//     size++;
//     ch++;
//   }
//   while(ch < end_location);
//
//   /* crc postcondition */
//   crc ^= 0xffffffff;
//
//   dprintf(("Diag", "validate_crc (main.c): CRC generated is %ud\n", crc));
//
//   /* Ensure that the crc matches the expected value. */
//   if (crc == expected_crc)
//   {
//     return (true);
//   }
//   else
//   {
//     dprintf(("Diag", "validate_crc (main.c): The CRC's mismatch (size of CRC'd image was %d).\n", size));
//     error_occurred("CRCMismatch");
//   }
//
//   return (false);
// }
//
// static void checkBuild(char *builds)
// {
//   _kernel_swi_regs regs;
//   _kernel_oserror *error = NULL;
//
//   //the OSversion string should contain the build
//   char *OSver,*token;
//   char build_list[80];
//
//   //get the OS version string
//   regs.r[0] = 0;
//   regs.r[1] = 0;
//   error = _kernel_swi(OS_Byte, &regs, &regs);
//   OSver=error->errmess;
//
//   dprintf(("Diag", "fetch_data (main.c): OS version is %s\n", OSver));
//
//   //point to the build list
//   strcpy(build_list,builds);
//
//   dprintf(("Diag", "fetch_data (main.c): build list : %s\n", build_list));
//
//   //get the first token in the build list
//   token=strtok(build_list,", ");
//
//   do
//   {
//     dprintf(("Diag", "fetch_data (main.c): token : %s\n", token));
//     //if we find the token break out of the loop
//     if (strstr(OSver,token) != NULL) break;
//     token=strtok(NULL,", ");
//   }
//   while (token !=NULL);
//
//   if (token==NULL)
//   {
//     dprintf(("Diag", "fetch_data (main.c): Invalid Build\n"));
//     error_occurred("WrongBuild");
//   }
//   else
//   {
//     dprintf(("Diag", "fetch_data (main.c): Correct Build\n"));
//   }
// }



/* This routine sets up a proxy with the URL module */
static bool setup_proxy(const unsigned int session)
{
  char* ftp_proxy = NULL;
  char full_proxy[100];
  int tag_size = -1;
  _kernel_swi_regs regs;
  _kernel_oserror *err;

  /* Read the FTP proxy from NCMAlite */
  regs.r[0] = (int)"FTP_PROXY";
  regs.r[1] = NULL;
  regs.r[2] = 0;

  err = _kernel_swi(NCMATwin_Enquiry, &regs, &regs);
  if (err!=NULL)
  {
    dprintf(("Fail", "setup_proxy (main.c): Error whilst trying to get FTP proxy from NCMA.\n"));
    return (false);
  }

  tag_size = regs.r[0];
  if (tag_size <= 0)
  {
    dprintf(("Fail", "setup_proxy (main.c): FTP proxy tag does not exist..\n"));
    return (false);
  }
  else
  {
    if ((ftp_proxy = malloc(tag_size+2)) == NULL)
    {
      dprintf(("Fail", "setup_proxy (main.c): Error allocating %d bytes of memory for tag.\n", tag_size));
      return (false);
    }
    else
    {
      regs.r[0]=(int)"FTP_PROXY";
      regs.r[1]=(int)ftp_proxy;
      regs.r[2]=tag_size;

      err = _kernel_swi(NCMATwin_Enquiry, &regs, &regs);
      if (err!=NULL)
      {
        dprintf(("Fail", "setup_proxy (main.c): Error whilst trying to get FTP proxy from NCMA.\n"));
        return (false);
      }
    }
  }

  dprintf(("Diag", "setup_proxy (main.c): Proxy is %s\n", ftp_proxy));

  /* Create full proxy URL. We really should ensure that it does not already have the http:// or the / at the end before adding them. */
  strcpy(full_proxy,"http://");
  strcat(full_proxy,ftp_proxy);
  strcat(full_proxy,"/");

  dprintf(("Diag", "setup_proxy (main.c): full Proxy is %s\n", full_proxy));

  /* Register the proxy */
  regs.r[0] = 0;
  regs.r[1] = session;
  regs.r[2] = (int)full_proxy;
  regs.r[3] = (int)"ftp:";
  regs.r[4] = 0;
  err = _kernel_swi(URL_SetProxy, &regs, &regs);
  if (err!=NULL)
  {
    dprintf(("Fail", "setup_proxy (main.c): Error whilst trying to set FTP proxy\n"));
    return (false);
  }

  return (true);
}



#ifdef CHECK_DOMAINS

  // /*       Search for Substring s1 in String p1
  //          ------------------------------------
  //
  // Returns true if string at s1 to s2 occurs anywhere in string at p1 to p2.
  // Note that strings are NOT null terminated, as the end pointers point to the terminating character
  // (ie the next character after the end of the string).
  //
  // Using this approach avoids using fixed sized buffers which might overflow.
  // */
  //
  // static bool instring(const char* p1, const char *p2, const char *s1, const char *s2)
  // {
  //   const char *s, *p;
  //
  //   while (p1<p2)
  //   {
  //     s=s1;       /* Rewind to start of sub-string. We are about to check if this occurs at th current p1 */
  //     p=p1;       /* p is pointer into string we are searching in. We advance p as we do the char match */
  //
  //     while (*s==*p && s<s2 && p<p2)  /* keep searching while chars in both strings match and we are not at end of either one */
  //     {
  //       s++; p++;                /* Matches so far, and not at end of either so move on to next char */
  //       if (s==s2) return true;  /* Substring s1 matches substring p1, and reached end of substring s1
  //                                   ie substring s1 occurs in its entirety in p1. */
  //     }
  //     p1++; /* Try next position within p1 string */
  //   }
  //   return false;
  // }

  #ifndef USE_CHECKURL

    /**************************************************************/
    /* rightmatches()                                             */
    /*                                                            */
    /* See if a substring appears as the rightmost part of a      */
    /* main string. Does not require string termination. The      */
    /* comparison is case insensitive.                            */
    /*                                                            */
    /* Parameters: Pointer to first char in the larger string;    */
    /*                                                            */
    /*             Pointer to first char after the end of the     */
    /*             larger string;                                 */
    /*                                                            */
    /*             Pointer to first char in the substring;        */
    /*                                                            */
    /*             Pointer to first char after the end of the     */
    /*             substring.                                     */
    /*                                                            */
    /* Returns:    true if there's a match, else false.           */
    /**************************************************************/

    static bool rightmatches(const char * p1, const char * p2, const char * s1, const char * s2)
    {
      const char * s;
      const char * p;

      s =s2 - 1; /* Point to last char in s string */
      p =p2 - 1; /* Point to last char in p string */

      /* Test character by character, stepping backwards */

      while (s >= s1 && p >= p1 && tolower(*s) == tolower(*p))
      {
        s--, p--;
      }

      /* Success if we found whole of s string at end of p, otherwise fail */

      return s < s1;
    }

  #endif /* USE_CHECKURL */

  /**************************************************************/
  /* validate_domain()                                          */
  /*                                                            */
  /* Check whether the URL given is allowed, on the basis of a  */
  /* comma-separated list of domains.                           */
  /*                                                            */
  /* If USE_CHECKURL is defined, the Check URL module is called */
  /* to do the check. All the rules that the Check URL module   */
  /* gives become available. Otherwise, simpler code checks the */
  /* domain. It assumes "://" is in the URL and strips all data */
  /* before this; strips everything after the next "/" (so no   */
  /* path validation). What left is checked.                    */
  /*                                                            */
  /* Parameters: Pointer to the URL to check;                   */
  /*                                                            */
  /*             Pointer to a NUL terminated, comma-separated   */
  /*             list of allowed domains.                       */
  /*                                                            */
  /* Returns:    true if the URL is allowed, else false. A      */
  /*             result of 'false' is returned for some kinds   */
  /*             of internal error; others are reported via.    */
  /*             the front-end directly.                        */
  /**************************************************************/

  static bool validate_domain(const char * const url, const char * const allowed_domains)
  {
    #ifdef USE_CHECKURL

      _kernel_oserror * e;
      char            * domains_copy;
      const char      * p;
      char            * c;
      unsigned int      commas;
      unsigned int      area_id;
      unsigned int      flags;

      if (
           url              == NULL ||
           allowed_domains  == NULL ||
           *url             == '\0' ||
           *allowed_domains == '\0'
         )
      {
        dprintf(("Fail", "validate_domain (main.c): Invalid parameters, returning 'false'\n"));
        return false;
      }

      /* This is a bit awkward. The domain list passed in is comma separated and */
      /* has no fragments, so count the number of items in the list by counting  */
      /* commas, allocate space including an extra two characters for each comma */
      /* so we can put " -" in there to give a parameter for each domain to keep */
      /* CheckURL happy, copy the domains with that extra specifier, and finally */
      /* pass the whole thing to CheckURL. Then the URL can be checked.          */

      p      = allowed_domains;
      commas = 1;

      while (*p != '\0') if (*(p++) == ',') commas++;

      /* Allocate space for fragment / parameter pairs. A comma is replaced by */
      /* a space, hyphen and '\n'; there's an extra space and hyphen at the    */
      /* end too, along with the NUL. Hence '+3' below. Since any white space  */
      /* in allowed_domains is stripped out, the maximum possible amount is    */
      /* being calculated - so, safe.                                          */

      domains_copy = malloc(strlen(allowed_domains) + (commas * 2) + 3);

      if (domains_copy == NULL)
      {
        dprintf(("Fail", "validate_domain (main.c): Can't allocate space for copy of domains\n"));
        quit("NotEnoughMemory");
      }

      /* Copy the domains list in a format for Check URL */

      p = allowed_domains;
      c = domains_copy;

      while (*p != '\0')
      {
        if (*p == ',')
        {
          *(c++) = ' ';
          *(c++) = '-';
          *(c++) = '\n';
        }
        else if (*p > ' ')
        {
          *(c++) = *p;
        }

        p++;
      }

      *(c++) = ' ';
      *(c++) = '-';
      *c     = '\0';

      /* Add the domains in a temporary area */

      e = _swix(CheckURL_AddArea,
                _INR(0,2) | _OUT(1),

                0,
                Main_CheckURLArea,
                domains_copy,

                &area_id);

      free(domains_copy);

      if (e != NULL)
      {
        dprintf(("Fail", "validate_domain (main.c): Error '%s' from CheckURL_AddArea, returning 'false'\n", e->errmess));
        return false;
      }

      /* Check the given URL; delete the temporary area regardless of outcome */

      e = _swix(CheckURL_Check,
                _INR(0,2) | _OUT(0),

                CU_Check_OnEntry_GivenAreaID,
                area_id,
                url,

                &flags);

      _swix(CheckURL_DeleteArea,
            _INR(0,1),

            CU_DeleteArea_OnEntry_GivenAreaID,
            area_id);

      if (e != NULL)
      {
        dprintf(("Fail", "validate_domain (main.c): Error '%s' from CheckURL_Check, returning 'false'\n", e->errmess));
        return false;
      }

      if ((flags & CU_Check_OnExit_MatchFound) != 0) return true;
      else                                           return false;

    #else /* USE_CHECKURL */

      const char *host_start, *host_end;
      const char *domain_start, *domain_end;

      dprintf(("Diag", "validate_domain (main.c): url is %s domains are %s\n", url, allowed_domains));

      if ((host_start = strstr(url, "://")) == NULL)
      {
        dprintf(("Fail", "validate_domain (main.c): Cannot locate :// in url.\n"));
        return (false);
      }
      host_start+=3; /* Move to beyond the :// */

      host_end = strchr(host_start, '/');  /* Find end of the host name in the URL, ie the trailing / */
      if (host_end == NULL)               /* No trailing / so use end of string */
        host_end=host_start+strlen(host_start);

      dprintf(("Diag", "validate_domain (main.c): Stripped line is %s\n", host_start));

      /* Now scan through the allowed domains, checking if there is a substring match. */
      domain_start=allowed_domains;
      while (*domain_start!=NULL)
      {
        while (*domain_start==' ')
          domain_start++;         /* Skip leading spaces before the domain (ie it might be "pace.co.uk, funai.co.uk") */
        domain_end=domain_start;
        while (*domain_end && *domain_end !=',' && *domain_end !=' ')
          domain_end++;    /* Look for end of the domain string, either a null, a comma or a space*/
        if (rightmatches(host_start, host_end, domain_start, domain_end))
        {
          dprintf(("Diag", "validate_domain (main.c): domains %s and %s match\n", host_start, domain_start));
          return (true);
        }
        domain_start=domain_end;  /* Skip over this domain */
        if (*domain_start)
          domain_start++;         /* Try next domain, if there is one */
      }
      return (false);  /* No match */

    #endif /* USE_CHECKURL */
  }

#endif /* CHECK_DOMAINS */

/**************************************************************/
/* main_create_directory()                                    */
/*                                                            */
/* Create a locked directory under the given name.            */
/*                                                            */
/* Parameters: Full pathname of the directory.                */
/**************************************************************/

static _kernel_oserror * main_create_directory(const char * name)
{
  _kernel_oserror * e = _swix(OS_File,
                              _INR(0,1) | _IN(4),

                              8,        /* Create directory */
                              name,
                              0);       /* Initial number of entries; 0 = use default */

  if (e != NULL) return e;

  else return _swix(OS_File,
                    _INR(0,1) | _IN(5),

                    4,    /* Set attributes */
                    name,
                    11);  /* Bit pattern -> "LWR/" */
}

/**************************************************************/
/* main_init_decoder()                                        */
/*                                                            */
/* Prepare a decoder_state structure for starting to decode a */
/* new image.                                                 */
/*                                                            */
/* Parameters: Pointer to the decoder_state structure to      */
/*             initialise.                                    */
/**************************************************************/

static void main_init_decoder(decoder_state * ds)
{
  if (ds == NULL) return;

  ds->crc = 0xFFFFFFFF, ds->crc_lock = false;
  make_crc_tables();

  ds->expecting_tag              = true;
  ds->reading_tag                = 0;
  ds->tag                        = 0;

  ds->expecting_size             = true;
  ds->reading_size               = 0;
  ds->size                       = 0;

  ds->expecting_data             = false;
  ds->reading_data               = 0;

  ds->reading_word               = 0;
  ds->word                       = 0;

  ds->lock_first                 = true;
  ds->fout                       = NULL;
  extract_fout                   = NULL;
  ds->ptr                        = 0;
  *ds->extract_to                = '\0';
  extract_path                   = NULL;

  ds->type_of_image              = image_type_unknown;
  ds->decomp_size                = 0;
  ds->file_crc                   = 0;
  ds->archive_uid                = 0;
  ds->have_uid                   = false;
  ds->matched_uid                = false;

  ds->build                      = NULL;
  ds->locale                     = NULL;
  ds->display                    = NULL;

  ds->archive.expecting_stubname = true;
  ds->archive.reading_stubname   = NULL;
  ds->archive.stubname           = NULL;
  ds->archive.fullname           = NULL;
  ds->archive.first_fullname     = NULL;
  ds->archive.subtype            = 0;

  ds->archive.task_name          = NULL;
  ds->archive.action             = action_type_none;

  ds->archive.stage              = 0;

  ds->archive.reading_word       = 0;
  ds->archive.word               = 0;

  ds->archive.restart_zlib       = true;

  ds->archive.itemsize           = 0;
  ds->archive.loadaddr           = 0;
  ds->archive.execaddr           = 0;
  ds->archive.itemattr           = 0;

  ds->archive.completed          = false;

  ds->image.total                = 0;
  ds->image.not_tag              = 0;

  return;
}

/**************************************************************/
/* main_add_word_to_crc()                                     */
/*                                                            */
/* Add the given word to the running CRC if crc_lock in the   */
/* given decoder is false.                                    */
/*                                                            */
/* Parameters: Pointer to the decoder_state structure holding */
/*             the running CRC value and lock flag;           */
/*                                                            */
/*             Word to add;                                   */
/*                                                            */
/*             true if this is a tag value and should be      */
/*             checked against TLV_TAG_TYPE_FILE_CRC to end   */
/*             CRC addition, else false.                      */
/**************************************************************/

static void main_add_word_to_crc(decoder_state * ds, unsigned int word, bool check)
{
  if (!ds->crc_lock)
  {
    if (check && word == TLV_TAG_TYPE_FILE_CRC)
    {
      ds->crc_lock  = true;
      ds->crc      ^= 0xFFFFFFFF;

      dprintf(("Diag", "main_add_word_to_crc: Have CRC tag; locked running value of &%08X\n", ds->crc));
    }
    else
    {
      char c;

      c = (word & 0xff);             update_crc((U8 *)(&c), (U32 *)(&ds->crc));
      c = (word & 0xff00) >> 8;      update_crc((U8 *)(&c), (U32 *)(&ds->crc));
      c = (word & 0xff0000) >> 16;   update_crc((U8 *)(&c), (U32 *)(&ds->crc));
      c = (word & 0xff000000) >> 24; update_crc((U8 *)(&c), (U32 *)(&ds->crc));
    }
  }

  return;
}

/**************************************************************/
/* main_decode_chunk()                                        */
/*                                                            */
/* Decode a chunk of a compressed upgrade image. The function */
/* is rather monolithic, but pretty straightforward.          */
/*                                                            */
/* Parameters: Pointer to a buffer holding a chunk of data to */
/*             process;                                       */
/*                                                            */
/*             Amount of data in the buffer;                  */
/*                                                            */
/*             true if this is a first call, else false;      */
/*                                                            */
/*             Pointer to a decoder_state structure for this  */
/*             session, which need not be initialsed;         */
/*                                                            */
/*             Total incoming data size from the server (only */
/*             required if the data isn't a tag file, but is  */
/*             instead a configuration update file).          */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_decode_chunk(const char * buf, unsigned int amount, bool first, decoder_state * ds, unsigned int incoming_size)
{
  dprintf(("Diag", "main_decode_chunk: Called (&%08X, %d, %d, &%08X)\n", (int) buf, amount, first, (int) ds));

  /* On first call, initialise the decoder */

  if (first == true)
  {
    main_init_decoder(ds);
    ds->lock_first = true;
  }

  ds->ptr = 0;

  /* Anything to read? */

  if (amount == 0) return EXIT_SUCCESS;

  /* Now go around reading data */

  do
  {
    /* Read the tag value */

    while (ds->expecting_tag == true && ds->reading_tag < 32 && ds->ptr < amount)
    {
      ds->tag = ds->tag | (buf[ds->ptr++] << ds->reading_tag);
      ds->reading_tag += 8;
    }

    /* Finished reading a tag? */

    if (ds->reading_tag == 32)
    {
      ds->expecting_tag  = false;
      ds->reading_tag    = 0;
      ds->expecting_size = true;
      ds->reading_size   = 0;
      ds->size           = 0;

      dprintf(("Diag", "main_decode_chunk: Tag %d acquired\n", ds->tag));

      /* Now, if this is a plain text file, the tag won't make sense; */
      /* kick the state machine into reading data, setting up a few   */
      /* of the other fields we'll need.                              */

      if ((ds->tag & 0xff000000) != 0)
      {
        dprintf(("Diag", "main_decode_chunk: Nonsensical tag implies configuration update\n"));

        if (incoming_size < 4)
        {
          dprintf(("Fail", "main_code_chunk: Server did not supply data size for us...\n"));
          quit("InvalidServer");
        }

        ds->expecting_size = false;
        ds->reading_size   = 0;
        ds->expecting_data = true;
        ds->reading_data   = 0;

        ds->image.not_tag  = ds->tag;
        ds->tag            = TLV_TAG_TYPE_IMAGE_DATA;
        ds->type_of_image  = image_type_configuration;
        ds->size           = incoming_size - 4; /* We've already read 4 bytes thinking it was a tag... */
        ds->decomp_size    = incoming_size;
        ds->lock_first     = false;
        ds->image.total    = 0;
      }

      /* Otherwise, include it in the CRC value */

      else main_add_word_to_crc(ds, ds->tag, true);
    }

    if (ds->ptr == amount)
    {
      dprintf(("Diag", "main_decode_chunk: ds->ptr = amount (%d), successful\n", ds->ptr));
      return EXIT_SUCCESS;
    }

    /* Read data size */

    while (ds->expecting_size == true && ds->reading_size < 32 && ds->ptr < amount)
    {
      ds->size = ds->size | (buf[ds->ptr++] << ds->reading_size);
      ds->reading_size += 8;
    }

    /* Finished reading size? */

    if (ds->reading_size == 32)
    {
      ds->expecting_size = false;
      ds->reading_size   = 0;
      ds->expecting_data = true;
      ds->reading_data   = 0;

      dprintf(("Diag", "main_decode_chunk: Data size %d\n", ds->size));

      main_add_word_to_crc(ds, ds->size, false);
    }

    if (ds->ptr == amount)
    {
      dprintf(("Diag", "main_decode_chunk: ds->ptr = amount (%d), successful\n", ds->ptr));
      return EXIT_SUCCESS;
    }

    /* If expecting data, read it */

    if (ds->expecting_data)
    {
      if (ds->size > 0)
      {
        unsigned int ptr = ds->ptr;

        if (main_decode_data_chunk(buf, amount, first, ds) == EXIT_FAILURE) return EXIT_FAILURE;

        /* Incorporate whatever data that consumed in the CRC value */

        if (!ds->crc_lock)
        {
          while (ptr < ds->ptr) update_crc((U8 *)(buf + (ptr++)), (U32 *)(&ds->crc));
        }
      }

      if (ds->reading_data == ds->size)
      {
        dprintf(("Diag", "main_decode_chunk: All data received\n"));

        ds->tag = ds->size = 0;
        ds->expecting_data = false;
        ds->reading_size   = 0;
        ds->expecting_tag  = true;
      }
    }
  }
  while (ds->ptr < amount);

  dprintf(("Diag", "main_decode_chunk: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_data_chunk()                                   */
/*                                                            */
/* Service function for main_decode_chunk. Once a tag and     */
/* data size have been found, decode the data part of the     */
/* tag. Should not be called if data size is zero. Detection  */
/* that the amount of data read equals the data size must be  */
/* done externally, with appropriate state machine resetting  */
/* for the next tag.                                          */
/*                                                            */
/* Parameters are as for main_decode_chunk.                   */
/**************************************************************/

static int main_decode_data_chunk(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_data_chunk: Called\n"));

  switch (ds->tag)
  {
    case TLV_TAG_TYPE_FILE_SIZE:
    case TLV_TAG_TYPE_IMAGE_TYPE:
    case TLV_TAG_TYPE_IMAGE_LENGTH:
    case TLV_TAG_TYPE_FILE_CRC:
    case TLV_TAG_TYPE_RANDOM_DATA:
    case TLV_TAG_TYPE_UID:
    case TLV_TAG_TYPE_TASK_ACTION:
    {
      return main_decode_data_word_chunk(buf, amount, first, ds);
    }
    break; /* Safety net in case above code gets, say, changed to not call return() */

    case TLV_TAG_TYPE_DISPLAY_STRING:
    case TLV_TAG_TYPE_BUILD_LIST:
    case TLV_TAG_TYPE_LOCALE_LIST:
    case TLV_TAG_TYPE_TASK_NAME:
    {
      return main_decode_data_string_chunk(buf, amount, first, ds);
    }
    break;

    case TLV_TAG_TYPE_IMAGE_DATA:
    {
      return main_decode_data_image_chunk(buf, amount, first, ds);
    }
    break;

    default:
    {
      /* Just discard the data */

      while (ds->reading_data < ds->size && ds->ptr < amount)
      {
        ds->ptr++, ds->reading_data++;
      }
    }
    break;
  }

  dprintf(("Diag", "main_decode_data_chunk: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_data_word_chunk()                              */
/*                                                            */
/* Service function for main_decode_data_chunk. Called on tag */
/* types FILE_SIZE, IMAGE_TYPE, IMAGE_LENGTH, FILE_CRC, UID,  */
/* RANDOM_DATA and TASK_ACTION. Must not be called for other  */
/* types.                                                     */
/*                                                            */
/* Parameters are as for main_decode_data_chunk.              */
/**************************************************************/

static int main_decode_data_word_chunk(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_data_word_chunk: Called\n"));

  if (
       ds->tag != TLV_TAG_TYPE_FILE_SIZE    &&
       ds->tag != TLV_TAG_TYPE_IMAGE_LENGTH &&
       ds->tag != TLV_TAG_TYPE_FILE_CRC     &&
       ds->tag != TLV_TAG_TYPE_RANDOM_DATA  &&
       ds->tag != TLV_TAG_TYPE_UID          &&
       ds->tag != TLV_TAG_TYPE_IMAGE_TYPE   &&
       ds->tag != TLV_TAG_TYPE_TASK_ACTION
     )
  {
    dprintf(("Fail", "main_decode_data_word_chunk: Called for invalid tag type %d\n", ds->tag));
    return EXIT_FAILURE;
  }

  if (ds->size != 4)
  {
    dprintf(("Fail", "main_decode_data_word_chunk: Error: Expecting to read one word of data for this tag, but data size is %d\n", ds->size));
    return EXIT_FAILURE;
  }

  /* Read data word */

  while (ds->reading_word < 32 && ds->ptr < amount)
  {
    ds->word = ds->word | (buf[ds->ptr++] << ds->reading_word);
    ds->reading_data ++;
    ds->reading_word += 8;
  }

  /* Finished? */

  if (ds->reading_word == 32)
  {
    switch (ds->tag)
    {
      case TLV_TAG_TYPE_FILE_SIZE:    dprintf(("Diag", "main_decode_data_word_chunk: File size is %d\n",                   ds->word)); break;
      case TLV_TAG_TYPE_IMAGE_LENGTH: dprintf(("Diag", "main_decode_data_word_chunk: Decompressed data length is %d MB\n", ds->word)); ds->decomp_size = ds->word; break;
      case TLV_TAG_TYPE_RANDOM_DATA:  dprintf(("Diag", "main_decode_data_word_chunk: Random data is &%08X\n",              ds->word)); break;
      case TLV_TAG_TYPE_UID:          dprintf(("Diag", "main_decode_data_word_chunk: UID is &%08X\n",                      ds->word)); ds->archive_uid = ds->word, ds->have_uid = true; break;
      case TLV_TAG_TYPE_FILE_CRC:
      {
        dprintf(("Diag", "main_decode_data_word_chunk: File CRC is &%08X (running CRC is &%08X)\n", ds->word, ds->crc));

        ds->file_crc = ds->word;
        if (ds->file_crc != ds->crc) quit("CRCMismatch");
      }
      break;
      case TLV_TAG_TYPE_IMAGE_TYPE:
      {
        dprintf(("Diag",
                 "main_decode_data_word_chunk: Image type: %s\n",
                 ds->word < (sizeof(type_names) / sizeof(*type_names)) ?
                 type_names[ds->word]                                  :
                 "<Unknown!>"));

        ds->type_of_image = (image_type) ds->word;
      }
      break;
      case TLV_TAG_TYPE_TASK_ACTION:
      {
        dprintf(("Diag",
                 "main_decode_data_word_chunk: Task action: %s\n",
                 ds->word < (sizeof(action_names) / sizeof(*action_names)) ?
                 action_names[ds->word]                                    :
                 "<Unknown!>"));

        ds->archive.action = (action_type) ds->word;
      }
      break;

      default:
      {
        dprintf(("Fail", "main_decode_data_word_chunk: Fatal internal error (1)\n"));
        exit(EXIT_FAILURE);
      }
    }

    /* Don't forget to reset the values... */

    ds->reading_word = 0;
    ds->word         = 0;
  }

  dprintf(("Diag", "main_decode_data_word_chunk: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_data_string_chunk()                            */
/*                                                            */
/* Service function for main_decode_data_chunk. Called on tag */
/* types DISPLAY_STRING, BUILD_LIST, LOCALE_LIST and          */
/* TASK_NAME. Must not be called for other types.             */
/*                                                            */
/* Parameters are as for main_decode_data_chunk.              */
/**************************************************************/

static int main_decode_data_string_chunk(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_data_string_chunk: Called\n"));

  if (
       ds->tag != TLV_TAG_TYPE_DISPLAY_STRING &&
       ds->tag != TLV_TAG_TYPE_BUILD_LIST     &&
       ds->tag != TLV_TAG_TYPE_LOCALE_LIST    &&
       ds->tag != TLV_TAG_TYPE_TASK_NAME
     )
  {
    dprintf(("Fail", "main_decode_data_string_chunk: Called for invalid tag type %d\n", ds->tag));
    return EXIT_FAILURE;
  }

  while (ds->reading_data < ds->size && ds->ptr < amount)
  {
    char    c = buf[ds->ptr++];
    char  * r;
    char ** write;

    switch (ds->tag)
    {
      case TLV_TAG_TYPE_DISPLAY_STRING: write = &ds->display;           break;
      case TLV_TAG_TYPE_BUILD_LIST:     write = &ds->build;             break;
      case TLV_TAG_TYPE_LOCALE_LIST:    write = &ds->locale;            break;
      case TLV_TAG_TYPE_TASK_NAME:      write = &ds->archive.task_name; break;
    }


    if (ds->reading_data == 0) r = malloc(1);
    else                       r = realloc(*write, ds->reading_data + 1);

    if (r == 0)
    {
      dprintf(("Fail", "main_decode_data_string_chunk: Out of memory\n"));
      return EXIT_FAILURE;
    }
    else *write = r;

    r[ds->reading_data++] = c;
    if (ds->reading_data == 1) dprintf(("Diag", "main_decode_data_string_chunk: String value is \""));

    if (c != '\0') dprintf(("Diag", "%c", c));
    else
    {
      /* Finished reading this string */

      dprintf(("Diag", "\"\n"));

      if (ds->reading_data != ds->size)
      {
        dprintf(("Fail", "main_decode_data_string_chunk: Error: Reached NUL in string but haven't read all expected data yet (%d bytes left hanging)\n", ds->size - ds->reading_data));
        return EXIT_FAILURE;
      }

      if (ds->tag == TLV_TAG_TYPE_DISPLAY_STRING && ds->display != NULL & *ds->display != '\0')
      {
        /* Update the front-end to display the string */

        status_print(ds->display);
      }
    }
  }

  dprintf(("Diag", "main_decode_data_string_chunk: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_data_image_chunk()                             */
/*                                                            */
/* Service function for main_decode_data_chunk. Called on tag */
/* type IMAGE_DATA only. Must not be called for other types.  */
/*                                                            */
/* Parameters are as for main_decode_data_chunk.              */
/**************************************************************/

static int main_decode_data_image_chunk(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_data_image_chunk: Called\n"));

  if (ds->tag != TLV_TAG_TYPE_IMAGE_DATA)
  {
    dprintf(("Fail", "main_decode_data_image_chunk: Called for invalid tag type %d\n", ds->tag));
    return EXIT_FAILURE;
  }

  switch (ds->type_of_image)
  {
    default:
    case image_type_unknown:
    {
      dprintf(("Fail", "main_decode_data_image_chunk: Error: Reached image data before finding out the image type\n"));
      return EXIT_FAILURE;
    }
    break;

    case image_type_transient:
    case image_type_resident:
    case image_type_permanent:
    {
      return main_decode_trp(buf, amount, first, ds);
    }
    break;

    case image_type_os:
    case image_type_font:
    case image_type_exec:
    case image_type_configuration:
    {
      return main_decode_ofec(buf, amount, first, ds);
    }
    break;
  }

  /* Should never drop through to here */

  dprintf(("Fail", "main_decode_data_image_chunk: Fatal internal error (4)\n"));
  return EXIT_FAILURE;
}

/**************************************************************/
/* main_decode_ofec()                                         */
/*                                                            */
/* Service function for main_decode_data_image_chunk. Called  */
/* for image types os, font, exec and configuration only.     */
/*                                                            */
/* Parameters are as for main_decode_data_image_chunk.        */
/**************************************************************/

static int main_decode_ofec(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  unsigned int write;

  dprintf(("Diag", "main_decode_ofec: Called\n"));

  if (
       ds->type_of_image != image_type_os   &&
       ds->type_of_image != image_type_font &&
       ds->type_of_image != image_type_exec &&
       ds->type_of_image != image_type_configuration
     )
  {
    dprintf(("Fail", "main_decode_ofec: Called for invalid image type %d\n", ds->type_of_image));
    return EXIT_FAILURE;
  }

  /* If we don't have a dynamic area, now's the time to get one */

  if (dynamic_area_base == 0)
  {
    dynamic_area_size = ds->size;

    /* If this is a configuration update file, 4 bytes will have been 'eaten' */
    /* and the remaining size indicator in ds->size adjusted. Take account    */
    /* of this.                                                               */

    if (ds->type_of_image == image_type_configuration) dynamic_area_size += 4;

    /* Claim the area */

    errors_show(_swix(OS_DynamicArea,
                      _INR(0,8) | _OUT(1) | _OUT(3),

                      0,                            /* Reason code; 0 = claim new area     */
                      -1,                           /* Must be -1                          */
                      dynamic_area_size,            /* Initial size                        */
                      -1,                           /* Must be -1                          */
                      1<<7,                         /* Flags; bit 7 -> not user resizeable */
                      16 * 1024 * 1024,             /* Maximum size                        */
                      0,                            /* No handler routine                  */
                      -1,                           /* ...so this is irrelevant really     */
                      Module_ComponentName " data", /* Name of area, for Task Manager      */

                      &dynamic_area_number,
                      &dynamic_area_base));

    dprintf(("Diag", "main_decode_ofec: Dynamic area %d created (%d bytes)\n", dynamic_area_number, dynamic_area_size));
  }

  if (ds->type_of_image == image_type_configuration)
  {
    /* We swallowed the first 4 bytes thinking they were a tag... */

    if (dynamic_area_size < 4)
    {
      dprintf(("Fail", "main_decode_ofec: DA size for configuration type should be at least 4 bytes\n"));
      return EXIT_FAILURE;
    }

    dynamic_area_base[0] = (ds->image.not_tag & 0xff);
    dynamic_area_base[1] = (ds->image.not_tag & 0xff00) >> 8;
    dynamic_area_base[2] = (ds->image.not_tag & 0xff0000) >> 16;
    dynamic_area_base[3] = (ds->image.not_tag & 0xff000000) >> 24;

    ds->image.total = 4;
  }

  /* Work out how much data we can write this time around and write it */

  write = ds->size - ds->reading_data;
  if (amount - ds->ptr < write) write = amount - ds->ptr;

  if (write + ds->image.total > dynamic_area_size)
  {
    /* Since we took care to claim an area of correct size to start with, this should */
    /* never be necessary - but it does work (e.g. set dynamic_area_size to 4 above   */
    /* to test it) and is useful "just in case".                                      */

    unsigned int changed_by;

    dprintf(("Diag", "main_decode_ofec: Resize area by %d bytes\n", ds->image.total + write - dynamic_area_size));

    errors_show(_swix(OS_ChangeDynamicArea,
                      _INR(0,1) | _OUT(1),

                      dynamic_area_number,
                      ds->image.total + write - dynamic_area_size,

                      &changed_by));

    dynamic_area_size += changed_by;

    dprintf(("Diag", "main_decode_ofec: Dynamic area %d resized to %d bytes\n", dynamic_area_number, dynamic_area_size));
  }

  memcpy(dynamic_area_base + ds->image.total,
         buf + ds->ptr,
         write);

  ds->image.total  += write;
  ds->ptr          += write;
  ds->reading_data += write;

  dprintf(("Diag",
           "main_code_ofec: Wrote %d bytes at offset %d\nmain_code_ofec: to arrive at image.total %d, ptr %d and reading_data %d\n",
           write,
           ds->image.total - write,
           ds->image.total,
           ds->ptr,
           ds->reading_data));

  /* Finished? */

  if (ds->reading_data == ds->size)
  {
    dprintf(("Diag", "main_decode_ofec: Finished\n"));

    switch (ds->type_of_image)
    {
      case image_type_font:
      case image_type_exec:
      {
        dprintf(("Diag", "main_decode_ofec: This image type is not fully supported; taking no further action\n"));
      }
      break;

      case image_type_os:
      {
        dprintf(("Diag", "main_decode_ofec: Commencing FLASH ROM programming from compressed OS image...\n"));
        //////////////// TBD
      }
      break;

      case image_type_configuration:
      {
        _kernel_oserror * e;

        dprintf(("Diag", "main_decode_ofec: Sending configuration update file off...\n"));

        e = _swix(ConfigurationUpdate_AcceptFile,
                  _INR(0,1),

                  dynamic_area_base,
                  ds->image.total);

        if (e != NULL)
        {
          if (e->errnum == 0x1E6) /* SWI not known */ quit("WrongBuild");
          else errors_show(e);
        }
      }
      break;

      default:
      {
        dprintf(("Diag", "main_decode_ofec: Fatal internal error (6)\n"));
        return EXIT_FAILURE;
      }
      break;
    }
  }

  dprintf(("Diag", "main_decode_ofec: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_trp()                                          */
/*                                                            */
/* Service function for main_decode_data_image_chunk. Called  */
/* for image types transient, resident and permanent only.    */
/*                                                            */
/* Parameters are as for main_decode_data_image_chunk.        */
/**************************************************************/

static int main_decode_trp(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_trp: Called\n"));

  if (
       ds->type_of_image != image_type_transient &&
       ds->type_of_image != image_type_resident  &&
       ds->type_of_image != image_type_permanent
     )
  {
    dprintf(("Fail", "main_decode_trp: Called for invalid image type %d\n", ds->type_of_image));
    return EXIT_FAILURE;
  }

  /* For archives, we first expect the 'stub' name of the file */

  if (main_decode_trp_stubname(buf, amount, first, ds) == EXIT_FAILURE) return EXIT_FAILURE;

  /* Once the stubname is done, need the subtype byte; may have to do some */
  /* setup though, if this is the first file we've encountered.            */

  if (main_decode_trp_subtype(buf, amount, first, ds) == EXIT_FAILURE) return EXIT_FAILURE;

  /* If subtype is 2 (i.e. byte in file was 2-1 = 1) -> directory; create it now. */
  /* If subtype is 1 (i.e. byte in file was 1-1 = 0) -> file...                   */

  if (ds->archive.subtype == 2)
  {
    if (main_decode_trp_subtype_isdir(buf, amount, first, ds) == EXIT_FAILURE) return EXIT_FAILURE;
  }
  else if (ds->archive.subtype == 1)
  {
    if (main_decode_trp_subtype_isfile(buf, amount, first, ds) == EXIT_FAILURE) return EXIT_FAILURE;
  }

  /* Did we finish that item? If so, reset this section of the state machine */
  /* ready for the next thing in the archive.                                */

  if (ds->archive.completed)
  {
    /* Is this the first full name? */

    if (ds->archive.first_fullname == NULL)
    {
      ds->archive.first_fullname = utils_strdup(ds->archive.fullname);

      if (ds->archive.first_fullname == NULL)
      {
        dprintf(("Fail", "main_decode_trp: Error: Out of memory copying first full name\n"));
        return EXIT_FAILURE;
      }
    }

    /* Reset other stuff */

    free(ds->archive.stubname), ds->archive.stubname = NULL;
    free(ds->archive.fullname), ds->archive.fullname = NULL;

    ds->archive.expecting_stubname = true;
    ds->archive.reading_stubname   = 0;
    ds->archive.subtype            = 0;
    ds->archive.stage              = 0;
    ds->archive_uid                = 0;
    ds->have_uid                   = false;
    ds->matched_uid                = false;
    ds->archive.completed          = false;
  }

  dprintf(("Diag", "main_decode_trp: Successful; completed = %d\n", ds->archive.completed));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_trp_stubname()                                 */
/*                                                            */
/* Service function for main_decode_trp. Called to extract    */
/* the stubname from a transient, resident or permanent       */
/* image's main data area.                                    */
/*                                                            */
/* Parameters are as for main_decode_trp.                     */
/**************************************************************/

static int main_decode_trp_stubname(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_trp_stubname: Called\n"));

  while (ds->archive.expecting_stubname && ds->ptr < amount && ds->reading_data < ds->size)
  {
    if (ds->archive.reading_stubname == 0)
    {
      /* These are just-in-case items; the bit handling the */
      /* 'completed' flag way down below *should* ensure    */
      /* that they are always reset appropriately.          */

      free(ds->archive.fullname), ds->archive.fullname = NULL;
      free(ds->archive.stubname), ds->archive.stubname = NULL;

      /* OK, allocate space for the first byte of the stubname */

      ds->archive.stubname = malloc(1);

      if (ds->archive.stubname == NULL)
      {
        dprintf(("Fail", "main_decode_trp_stubname: Error: Out of memory reading file stub name\n"));
        return EXIT_FAILURE;
      }
    }
    else
    {
      /* Reallocate for the next byte */

      char * temp = realloc(ds->archive.stubname, ds->archive.reading_stubname + 1);

      if (temp == NULL)
      {
        dprintf(("Fail", "main_decode_trp_stubname: Error: Out of memory reading file stub name\n"));
        return EXIT_FAILURE;
      }
      else ds->archive.stubname = temp;
    }

    ds->archive.stubname[ds->archive.reading_stubname] = buf[ds->ptr++];

    /* The name terminates on NUL; after that we expect the subtype byte */

    if (ds->archive.stubname[ds->archive.reading_stubname] == '\0') ds->archive.expecting_stubname = false;

    ds->archive.reading_stubname ++;
    ds->reading_data             ++;
  }

  if (ds->reading_data >= ds->size)
  {
    free(ds->archive.stubname);
    dprintf(("Fail", "main_decode_trp_stubname: Error: Ran out of data for this record during archive processing\n"));
    return EXIT_FAILURE;
  }

  dprintf(("Diag", "main_decode_trp_stubname: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_trp_subtype()                                  */
/*                                                            */
/* Service function for main_decode_trp. Called to extract    */
/* the subtype byte from a transient, resident or permanent   */
/* image's main data area. Once obtained, the full name using */
/* the decoder_state structure's extract_to path is built;    */
/* the extract_to path itself is set up here.                 */
/*                                                            */
/* Parameters are as for main_decode_trp.                     */
/**************************************************************/

static int main_decode_trp_subtype(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_trp_subtype: Called\n"));

  if (!ds->archive.expecting_stubname && ds->archive.subtype == 0 && ds->ptr < amount && ds->reading_data < ds->size)
  {
    dprintf(("Diag", "main_decode_trp_subtype: Item stub name is '%s'\n", ds->archive.stubname));

    /* Was this the first item? */

    if (ds->lock_first)
    {
      _kernel_oserror * e;
      unsigned int      pos;
      char              temp[sizeof(ds->extract_to)];

      ds->lock_first = false;

      /* Need to create a directory to extract to, assuming one isn't already present! */

      if (
           ds->have_uid == false
           ||
           utils_find_archive(temp,
                              sizeof(temp),
                              Main_Archive_UID,
                              ds->archive_uid)
           == false
         )
      {
        utils_get_unique_name(ds->extract_to, sizeof(ds->extract_to));

        if (*ds->extract_to == '\0')
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: Could not get a unique directory name!\n"));
          return EXIT_FAILURE;
        }

        /* Take a copy for aborted download tidy-up */

        extract_path = utils_strdup(ds->extract_to);

        if (extract_path == NULL)
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: Not enough memory to copy unique directory name\n"));
          return EXIT_FAILURE;
        }

        /* Build the full path - unique directory and 'Data' directory to */
        /* put the actual image contents in                               */

        pos = strlen(ds->extract_to);

        if (pos + sizeof(Main_Archive_Subdir) > sizeof(ds->extract_to))
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: extract_to buffer isn't big enough to append '.Data'\n"));
          return EXIT_FAILURE;
        }

        strcpy(ds->extract_to + pos, Main_Archive_Subdir);

        if ((e = utils_build_tree(ds->extract_to, true)) != NULL)
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: Error '%s' from utils_build_path\n", e->errmess));
          return EXIT_FAILURE;
        }

        /* Borrow the ds->extract_to leaf to write the UID file :-)          */
        /*                                                               */
        /* Note the assumption that the UID will fit if the subdirectory */
        /* name did.                                                     */

        strcpy(ds->extract_to + pos, Main_Archive_UID);

        e = utils_write_uid(ds->extract_to,
                            ds->have_uid ? 1 : 0,
                            ds->archive_uid);

        if (e != NULL)
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: Couldn't write UID file ('%s')\n", e->errmess));
          return EXIT_FAILURE;
        }

        /* OK, put Main_Archive_Subdir back... (There are better ways to organise this, yes) */

        strcpy(ds->extract_to + pos, Main_Archive_Subdir);
        ds->matched_uid = false;
      }
      else
      {
        /* There's already an archive! */

        dprintf(("Diag", "main_decode_trp_subtype: There is already an archive with UID &%08X\n", ds->archive_uid));
        ds->matched_uid = true;

        /* Make sure extract_to holds a valid path */

        strcpy(ds->extract_to, temp);
        pos = strlen(ds->extract_to);

        if (pos + sizeof(Main_Archive_Subdir) > sizeof(ds->extract_to))
        {
          free(ds->archive.stubname);
          dprintf(("Fail", "main_decode_trp_subtype: extract_to buffer isn't big enough to append '.Data'\n"));
          return EXIT_FAILURE;
        }
        else strcpy(ds->extract_to + pos, Main_Archive_Subdir);

        dprintf(("Diag", "main_decode_trp_subtype: extract_to for existant copy is '%s'\n", ds->extract_to));
      }
    }

    /* Get the subtype */

    ds->archive.subtype = buf[ds->ptr++] + 1;
    ds->reading_data++;

    if (ds->archive.subtype != 1 && ds->archive.subtype != 2)
    {
      dprintf(("Fail", "main_decode_trp_subtype: Error: Subtype byte value %d not recognised\n", ds->archive.subtype));
    }
    else
    {
      dprintf(("Diag", "main_decode_trp_subtype: This is a %s\n", ds->archive.subtype == 1 ? "file" : "directory"));
    }
  }

  /* For files, we expect more data */

  if (ds->reading_data >= ds->size && ds->archive.subtype == 1)
  {
    free(ds->archive.stubname);
    dprintf(("Fail", "main_decode_trp_subtype: Error: Ran out of data for this record during archive processing\n"));
    return EXIT_FAILURE;
  }

  if (ds->archive.subtype != 0 && ds->archive.fullname == NULL)
  {
    /* Construct the full name */

    ds->archive.fullname = malloc(strlen(ds->extract_to) + strlen(ds->archive.stubname) + 2); /* 1 for separating ".", 1 for NUL */

    if (ds->archive.fullname == NULL)
    {
      dprintf(("Fail", "main_decode_trp_subtype: Error: Out of memory creating full filename\n"));
      return EXIT_FAILURE;
    }
    else sprintf(ds->archive.fullname, "%s.%s", ds->extract_to, ds->archive.stubname);

    dprintf(("Diag", "main_decode_trp_subtype: Full name is '%s'\n", ds->archive.fullname));

    /* Do we have to take action immediately? */

    if (ds->matched_uid)
    {
      errors_show(main_run_from_wrapper(ds));
      exit(EXIT_SUCCESS);
    }
  }

  dprintf(("Diag", "main_decode_trp_subtype: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_trp_subtype_isdir()                            */
/*                                                            */
/* Service function for main_decode_trp. Called to handle     */
/* directory items (subtype byte value 1; since the value is  */
/* incremented by 1 in the decoder_state structure to allow 0 */
/* for 'not obtained yet', the ds->subtype value should be 2  */
/* if this function is to be called).                         */
/*                                                            */
/* Parameters are as for main_decode_trp.                     */
/**************************************************************/

static int main_decode_trp_subtype_isdir(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  _kernel_oserror * e;

  dprintf(("Diag", "main_decode_trp_subtype_isdir: Called\n"));

  if (ds->archive.subtype != 2)
  {
    dprintf(("Fail", "main_decode_trp_subtype_isdir: Called for invalid subtype '%d'\n", ds->archive.subtype));
    return EXIT_FAILURE;
  }

  e = main_create_directory(ds->archive.fullname);

  if (e != NULL)
  {
    dprintf(("Fail", "main_decode_trp_subtype_isdir: Error: %s", e->errmess));
    return EXIT_FAILURE;
  }

  /* Report and flag completion for this item */

  dprintf(("Diag", "main_decode_trp_subtype_isdir: Directory created\n"));
  ds->archive.completed = true;

  dprintf(("Diag", "main_decode_trp_subtype_isdir: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_trp_subtype_isfile()                           */
/*                                                            */
/* Service function for main_decode_trp. Called to handle     */
/* file items (subtype byte value 0; since the value is       */
/* incremented by 1 in the decoder_state structure to allow 0 */
/* for 'not obtained yet', the ds->subtype value should be 1  */
/* if this function is to be called).                         */
/*                                                            */
/* Parameters are as for main_decode_trp.                     */
/**************************************************************/

static int main_decode_trp_subtype_isfile(const char * buf, unsigned int amount, bool first, decoder_state * ds)
{
  dprintf(("Diag", "main_decode_trp_subtype_isfile: Called\n"));

  if (ds->archive.subtype != 1)
  {
    dprintf(("Fail", "main_decode_trp_subtype_isfile: Called for invalid subtype '%d'\n", ds->archive.subtype));
    return EXIT_FAILURE;
  }

  while (ds->ptr < amount && ds->reading_data < ds->size && !ds->archive.completed)
  {
    switch (ds->archive.stage)
    {
      /* Need to read words for item size, load address, exec address and attributes */

      case 0:
      case 1:
      case 2:
      case 3:
      {
        /* Read the word */

        while (ds->reading_word < 32 && ds->ptr < amount && ds->reading_data < ds->size)
        {
          ds->word = ds->word | (buf[ds->ptr++] << ds->reading_word);
          ds->reading_data ++;
          ds->reading_word += 8;
        }

        /* Finished? Record it in the relevant variable */

        if (ds->reading_word == 32)
        {
          switch (ds->archive.stage)
          {
            case 0: ds->archive.itemsize = ds->word; break;
            case 1: ds->archive.loadaddr = ds->word; break;
            case 2: ds->archive.execaddr = ds->word; break;
            case 3: ds->archive.itemattr = ds->word; break;
            default:
            {
              dprintf(("Fail", "main_decode_trp_subtype_isfile: Fatal internal error (2)\n"));
              exit(EXIT_FAILURE);
            }
          }

          ds->reading_word = 0;
          ds->word         = 0;

          ds->archive.stage++;
        }

        /* Out of data unexpectedly? */

        if (ds->reading_data >= ds->size)
        {
          free(ds->archive.stubname);
          free(ds->archive.fullname);
          dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: Ran out of data for this record during archive processing\n"));
          return EXIT_FAILURE;
        }
      }
      break;

      /* When we get to stage 4, all words have been read; this is file data now */

      case 4:
      {
        Byte   outbuf[Main_Extract];
        int    error;
        size_t write, written;

        /* If not presently open, open the output file and wake up zlib */

        if (ds->fout == NULL)
        {
          extract_fout = ds->fout = fopen(ds->archive.fullname, "wb");

          if (ds->fout == NULL)
          {
            ///perror(ds->archive.fullname);
            return EXIT_FAILURE;
          }
          else if (ds->archive.restart_zlib == true)
          {
            ds->archive.restart_zlib = false;

            /* Set up basic stream info */

            memset(&ds->archive.stream, 0, sizeof(ds->archive.stream));

            ds->archive.stream.zalloc = Z_NULL;
            ds->archive.stream.zfree  = Z_NULL;
            ds->archive.stream.opaque = Z_NULL;

            /* Initialise the inflate engine */

            error = inflateInit(&ds->archive.stream);

            if (error)
            {
              free(ds->archive.stubname);
              free(ds->archive.fullname);
              fclose(ds->fout), ds->fout = extract_fout = NULL;
              dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: ZLib error %d at initialisation (%s)\n", error, ds->archive.stream.msg != NULL && *ds->archive.stream.msg != '\0' ? ds->archive.stream.msg : "no further details"));
              return EXIT_FAILURE;
            }
          }
        }

        /* Work out how much data we can write this time around and write it */

        if (ds->ptr < amount)
        {
          do
          {
            /* Read a chunk */

            ds->archive.stream.next_in  = (Byte *) (buf + ds->ptr);
            ds->archive.stream.avail_in = ((amount - ds->ptr) * sizeof(char)) / sizeof(Byte);

            /* Decompressor loop */

            do
            {
              ds->archive.stream.next_out  = outbuf;
              ds->archive.stream.avail_out = (uInt) sizeof(outbuf);

              error = inflate(&ds->archive.stream, Z_SYNC_FLUSH);

              if (error && error != Z_STREAM_END)
              {
                free(ds->archive.stubname);
                free(ds->archive.fullname);
                fclose(ds->fout), ds->fout = extract_fout = NULL;
                dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: ZLib error %d at decompression (%s)\n", error, ds->archive.stream.msg != NULL && *ds->archive.stream.msg != '\0' ? ds->archive.stream.msg : "no further details"));
                return EXIT_FAILURE;
              }

              /* Write out the decompressed data */

              write   = (sizeof(outbuf) / sizeof(Byte)) - ds->archive.stream.avail_out;
              written = fwrite(outbuf,
                               sizeof(Byte),
                               write,
                               ds->fout);

              if (written < write)
              {
                free(ds->archive.stubname);
                free(ds->archive.fullname);
                fclose(ds->fout), ds->fout = extract_fout = NULL;
                ///perror(ds->archive.fullname);
                return EXIT_FAILURE;
              }

              /* Keep going until all input data is consumed */
            }
            while (ds->archive.stream.avail_in > 0 && !error);

            /* Increment our local data counters */

            ds->reading_data += (amount - ds->ptr - ds->archive.stream.avail_in);
            ds->ptr          += (amount - ds->ptr - ds->archive.stream.avail_in);

            /* Keep going until stream end, or we run out of data */
          }
          while (error != Z_STREAM_END && ds->ptr < amount && ds->reading_data < ds->size);

          /* Finished? */

          if (error == Z_STREAM_END)
          {
            _kernel_oserror * e;

            fclose(ds->fout), ds->fout = extract_fout = NULL;

            error = inflateEnd(&ds->archive.stream);

            if (error && error != Z_STREAM_END)
            {
              free(ds->archive.stubname);
              free(ds->archive.fullname);
              dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: ZLib error %d at inflate end (%s)\n", error, ds->archive.stream.msg != NULL && *ds->archive.stream.msg != '\0' ? ds->archive.stream.msg : "no further details"));
              return EXIT_FAILURE;
            }

            /* Reset the byte counter for the state machine */

            ds->archive.restart_zlib = true;

            /* Set the item's attributes etc. */

            ds->archive.itemattr |= (1u<<3); /* Lock all files */

            e = _swix(OS_File,
                      _INR(0,3) | _IN(5),

                      1,
                      ds->archive.fullname,
                      ds->archive.loadaddr,
                      ds->archive.execaddr,
                      ds->archive.itemattr);

            if (e != NULL)
            {
              dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: %s", e->errmess));
              return EXIT_FAILURE;
            }

            /* Report and flag completion of this item */

            dprintf(("Diag", "main_decode_trp_subtype_isfile: File created\n"));
            ds->archive.completed = true;
          }
          else
          {
            /* If not at stream end, expect more data */

            if (ds->reading_data >= ds->size)
            {
              free(ds->archive.stubname);
              free(ds->archive.fullname);
              fclose(ds->fout), ds->fout = extract_fout = NULL;
              dprintf(("Fail", "main_decode_trp_subtype_isfile: Error: Ran out of input data before decompression ds->archive.completed\n"));
              return EXIT_FAILURE;
            }
          }
        }
      }
      break;

      default:
      {
        dprintf(("Fail", "main_decode_trp_subtype_isfile: Fatal internal error (3)\n"));
        exit(EXIT_FAILURE);
      }
      break;

    } /* 'switch (ds->archive.stage)' */

  } /* 'while (ds->ptr < amount && ds->reading_data < ds->size) && !ds->archive.completed' */

  dprintf(("Diag", "main_decode_trp_subtype_isfile: Successful\n"));

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_run_from_wrapper()                                    */
/*                                                            */
/* Run an archive from its wrapper file, by building that     */
/* wrapper file and issuing SWI Wimp_StartTask for it.        */
/*                                                            */
/* Parameters: Pointer to a decoder_state structure with an   */
/*             appropriate extract_to path, filled in         */
/*             type_of_image field, and filled in             */
/*             first_fullname field.                          */
/**************************************************************/

static _kernel_oserror * main_run_from_wrapper(decoder_state * ds)
{
  _kernel_oserror * e;
  int               ret;
  char            * subdir;
  char            * wrapper;
  char            * combuf;
  char            * dot;

  dprintf(("Diag", "main_run_from_wrapper: Called\n"));

  /* Sanity checks */

  if (*ds->extract_to == '\0' || ds->archive.first_fullname == NULL)
  {
    dprintf(("Fail", "main_run_from_wrapper: Invalid parameters\n"));
    return errors_frontend_error(fee_invalid_parameters, "1");
  }

  /* Construct the subdirectory by stripping off the leaf directory name */
  /* that must be present in the extract_to path.                        */

  subdir = malloc(strlen(ds->extract_to) + 1);

  if (subdir == NULL) return errors_frontend_error(fee_out_of_memory, "2");
  else strcpy(subdir, ds->extract_to);

  dot = strrchr(subdir, '.');

  if (dot == NULL)
  {
    dprintf(("Fail", "main_run_from_wrapper: Fatal internal error (5)\n"));
    exit(EXIT_FAILURE);
  }
  else *dot = '\0';

  /* Construct the wrapper filename */

  combuf = malloc(strlen(subdir) + sizeof(Main_Archive_Wrapper) + sizeof(Main_Archive_Kickoff) + sizeof(Main_Archive_Append));

  if (combuf == NULL) return errors_frontend_error(fee_out_of_memory, "3");

  wrapper = combuf + sizeof(Main_Archive_Kickoff) + sizeof(Main_Archive_Append) - 1;

  /* Polite not to leave a trailing space on the command ;-) */

  if (sizeof(Main_Archive_Append) == 1) sprintf(combuf, "%s %s%s",    Main_Archive_Kickoff, subdir, Main_Archive_Wrapper);
  else                                  sprintf(combuf, "%s %s%s %s", Main_Archive_Kickoff, subdir, Main_Archive_Wrapper, Main_Archive_Append);

  /* Build the wrapper */

  dprintf(("Diag", "main_run_from_wrapper: Building with '%s', '%s', '%s'\n", wrapper, subdir, ds->archive.first_fullname));

  ret = main_build_wrapper(ds,
                           wrapper,
                           subdir);

  free(subdir);

  if (ret == EXIT_FAILURE)
  {
    dprintf(("Fail", "main_run_from_wrapper: Building failed, bailing\n"));

    free(combuf);
    return errors_frontend_error(fee_cannot_build_wrapper);
  }
  else
  {
    dprintf(("Diag", "main_run_from_wrapper: Calling Wimp_StartTask with '%s'\n", combuf));

    status_print(lookup_token("Running:Running item...",0,0));
    stop_iconhigh();
    status_grey();

    e = _swix(Wimp_StartTask,
              _IN(0),

              combuf);

    if (e == NULL)
    {
      /* Ensure exit_handler doesn't delete files under a multitasking application's feet...! */

      free(extract_path);
      extract_path = NULL;
    }

    start_iconhigh();

    free(combuf);
  }

  dprintf(("Diag", "main_run_from_wrapper: Finished, returning &%08X\n", (int) e));

  return e;
}

/**************************************************************/
/* main_build_wrapper()                                       */
/*                                                            */
/* Build a wrapper Obey file to run the contents of a given   */
/* archive.                                                   */
/*                                                            */
/* Parameters: Pointer to decoder_state structure for the     */
/*             archive;                                       */
/*                                                            */
/*             Filename of the wrapper file to write;         */
/*                                                            */
/*             Name of top-level directory to reference with  */
/*             wipe and file access commands (normally this   */
/*             will be the unique directory name that the     */
/*             wrapper file, UID and extracted archive data   */
/*             all lies in).                                  */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_build_wrapper(decoder_state * ds, const char * name, const char * subdir)
{
  int    ret  = EXIT_SUCCESS;
  FILE * fout = fopen(name, "wb");

  dprintf(("Diag", "main_build_wrapper: Called\n"));

  if (fout == NULL) return EXIT_FAILURE;

  if (fprintf(fout, Main_UpgLaunch_Slot "\n") < 0)
  {
    ret = EXIT_FAILURE;
  }
  else if (ds->have_uid == false)
  {
    /* Must wipe the data afterwards */

    if (
         fprintf(fout, "Run %s -run %s -wipe", Main_UpgLaunch_Run, ds->archive.first_fullname) < 0
       )
       ret = EXIT_FAILURE;
  }
  else if (ds->type_of_image == image_type_permanent)
  {
    /* Leave locked */

    if (
         fprintf(fout, "Run %s -run %s", Main_UpgLaunch_Run, ds->archive.first_fullname) < 0
       )
       ret = EXIT_FAILURE;
  }
  else
  {
    /* Unlock but don't wipe */

    if (
         fprintf(fout, "Run %s -run %s -unlock", Main_UpgLaunch_Run, ds->archive.first_fullname) < 0
       )
       ret = EXIT_FAILURE;
  }

  /* Deal with -task */

  if (ret != EXIT_FAILURE)
  {
    if (
         ds->archive.task_name  != NULL &&
         *ds->archive.task_name != '\0' &&
         (
           ds->archive.action == action_type_replace ||
           ds->archive.action == action_type_abort
         )
       )
    {
      unsigned int   i     = 0;
      unsigned int   count = 0;
      char         * copy  = NULL;

      /* The task name has to be enclosed in double quotes, but that means */
      /* we must escape any double quotes already in it                    */

      while (ds->archive.task_name[i] != '\0')
      {
        if (ds->archive.task_name[i++] == '\"') count++;
      }

      if (count == 0) copy = ds->archive.task_name;
      else
      {
        copy = malloc(strlen(ds->archive.task_name) + count + 1);

        if (copy == NULL)
        {
          dprintf(("Fail", "main_build_wrapper: Out of memory\n"));
          ret = EXIT_FAILURE;
        }
        else
        {
          count = 0;
          i     = 0;

          while (ds->archive.task_name[i] != '\0')
          {
            if (ds->archive.task_name[i] == '\"')
            {
              copy[count++] = '\\';
              copy[count++] = '\"';
            }
            else
            {
              copy[count++] = ds->archive.task_name[i];
            }

            i++;
          }

          copy[count] = '\0';
        }
      }

      if (
           ret != EXIT_FAILURE &&
           fprintf(fout, " -task \"%s\" %s\n", copy, ds->archive.action == action_type_replace ? "replace" : "abort") < 0
         )
         ret = EXIT_FAILURE;

      if (copy != NULL && copy != ds->archive.task_name) free(copy);
    }
    else if (fprintf(fout, "\n") < 0) ret = EXIT_FAILURE;
  }

  fclose(fout);

  if (ret != EXIT_FAILURE)
  {
    if (
         _swix(OS_File,
               _INR(0,1) | _IN(5),

               4,  /* Set attributes */
               name,
               11) /* Permissions LWR/ */

         != NULL
       )
    {
      ret = EXIT_FAILURE;
    }
    else if (
              _swix(OS_File,
                    _INR(0,2),

                    18,
                    name,
                    Main_FileType_Obey)

               != NULL
            )
            ret = EXIT_FAILURE;
  }

  if (ret == EXIT_FAILURE) remove(name);

  dprintf(("Diag", "main_build_wrapper: Finished, returning %s\n", ret == EXIT_SUCCESS ? "EXIT_SUCCESS" : "EXIT_FAILURE"));

  return ret;
}

/**************************************************************/
/* main_unlock_files()                                        */
/*                                                            */
/* Go down the given path, setting permissions to "WR/".      */
/*                                                            */
/* Parameters: Pathname of the top level directory to look    */
/*             inside;                                        */
/*                                                            */
/*             NULL for outer level call, else a pathname for */
/*             inner recursion during directory scanning.     */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_unlock_files(const char * top_path, const char * current)
{
  /* Note the restrictions that using this static buffer places on the */
  /* order we rely on calling ourselves recursively with respect to    */
  /* directory contents.                                               */

  _kernel_oserror * e;
  static char       path[MAXNAMLEN * 2 + 1];

  if (current == NULL) current = top_path;

  /* Set permissions */

  e = _swix(OS_File,
            _INR(0,1) | _IN(5),

            4,       /* Set attributes */
            current,
            3);      /* Bits 0 and 1 set -> "WR/" */

  if (e != NULL) return EXIT_FAILURE;

  if (dirs_is_dir(current))
  {
    DIR           * dir;
    struct dirent * entry;
    unsigned int    len;

    /* This is a directory; open it and dive in */

    dir = dirs_open_dir(current);

    if (dir == NULL)
    {
      return EXIT_FAILURE;
    }

    /* Write the basic path to the static buffer and remember */
    /* the length of it.                                      */

    StrNCpy0(path, current);
    len = strlen(path);

    /* Go round all entries */

    while ((entry = dirs_read_dir(dir)) != NULL)
    {
      /* Will the full pathname of this item fit in the buffer? */

      if (len + 2 + strlen(entry->d_name) > sizeof(path))
      {
        /* No - bail out */

        return EXIT_FAILURE;
      }
      else
      {
        /* Yes - write the leaf in */

        path[len] = '.';
        strcpy(path + len + 1, entry->d_name);

        if (main_unlock_files(top_path, path) == EXIT_FAILURE) return EXIT_FAILURE;
      }
    }

    dirs_close_dir(dir);
  }

  return EXIT_SUCCESS;
}

/**************************************************************/
/* start_iconhigh()                                           */
/*                                                            */
/* Bring up the IconHigh module so buttons in any dialogue    */
/* boxes we open can be activated via. a highlight.           */
/**************************************************************/

static void start_iconhigh(void)
{
  if (
       _swix(IconHigh_Start,
             _IN(0),

             0) /* Highlight (not pointer) emulation */

       != NULL
     )
  {
    dprintf(("Fail", "start_iconhigh (main.c): SWI call failed\n"));
    return;
  }
}

/**************************************************************/
/* stop_iconhigh()                                            */
/*                                                            */
/* Stop the IconHigh module.                                  */
/* boxes we open can be activated via. a highlight.           */
/**************************************************************/

static void stop_iconhigh(void)
{
  if (
       _swix(IconHigh_Stop,
             _IN(0),

             0)

       != NULL
     )
  {
    dprintf(("Fail", "stop_iconhigh (main.c): SWI call failed\n"));
    return;
  }
}

/**************************************************************/
/* catch_errors()                                             */
/*                                                            */
/* Catch OS errors and report them with the opportunity to    */
/* continue or quit (done inside main itself).                */
/*                                                            */
/* This is the last function in the file since it plays       */
/* around with stack checking, and you can't read the         */
/* previous state. If this was in the middle of the source    */
/* and someone wrote a #pragma above it, endless confusion    */
/* could otherwise arise as to why the instruction had no     */
/* effect on some of the functions here...                    */
/*                                                            */
/* Parameters: The signal number (ignored).                   */
/**************************************************************/

#pragma no_check_stack

static void catch_errors(int signum)
{
  /* Store the error locally */

  StrLastE;

  /* Go back to main to report the error */

  longjmp(env, Main_FromCatchErrors);

  /* Just in case... */

  exit(EXIT_FAILURE);
}
