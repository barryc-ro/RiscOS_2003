
/*
This Application performs the first part of a two part upgrade procedure for
upgrading the operating system on an NC without the need for a seperate
operating system or maintainance OS.

This Application Fetches a compressed OS image from a supplied URL via FTP
and stores it in a dynamic area.  It then triggers a seperate application
to reprogram the flash memory with the new image.


This program provides a Wimp interface for the download process showing a
bar chart of the progress of the download and status information as to the
progress.  The program launches the programming task as soon as the download
is complete.

 Created               26/9/00    Mark Robertshaw
 added CRC check       10/10/00   Nick Evans
 added build check     11/10/00   Nick Evans
 added Flash Bank      12/10/00   Nick Evans
*/




#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "string.h"

#include "swis.h"
#include "kernel.h"

#include "interface/URL.h"
#include "math.h"
#include "wimplib.h"
#include "toolbox.h"


#include "FetchImage.h"
#include "kill.h"

#include "ui.h"
#include "messages.h"
#include "globals.h"
#include "main.h"

/* Other libraries */
#include "DBUG.h"
#include "Debuglib/Debuglib.h"
#include "crc32.h"


#define WimpVersion    310

static  WimpPollBlock  poll_block;
        MessagesFD     messages;
static  IdBlock        id_block;

/* Define the SWI number for NCMA that we need. */
#define NCMATwin_Enquiry                0x04f000

/* This flag below states how much data we wish to read from the URL at any time. */
#define URL_CHUNK_SIZE 32768


/* A structure to hold the list of known tags. */
typedef struct tlv_list_node
{
  int tag_type;          /* The type of the tag (one word) */
  int tag_length;        /* The length of the tag (one word) */
  char* value_pointer;   /* A pointer to the start of the area containing the value */
  struct tlv_list_node* next_tag;
} tlv_list_node_type;

/* And store the head and tail pointers. */
tlv_list_node_type *tlv_list_head, *tlv_list_tail = NULL;

/* total bytes to read. This can be obtained from either the FTP server or the filelength tag. */
int total_bytes_to_read = 0;

/* Forward prototypes */
unsigned int return_free_memory(void);
void initialise_wimp(void);

#ifdef ENABLE_DEBUGGING
static void decode_file(const char* const memory_base, const char* const memory_end);
#endif

bool fetch_data(const int session_identifier, const int dynamic_area_number, char** dynamic_area_current_ptr, const int server_timeout, const char* const dynamic_area_base);
static void add_node(const int type, const int length, const char* const location);
static void display_linked_list(void);
unsigned int read_little_word(const char* const buff);
static void free_list(void);
static char* is_tag_complete(const char* const base_pointer, const char* const end_pointer);
static int return_tag_length(const char* const base_pointer, const char* end_pointer);
static int return_tag_type(const char* const base_pointer, const char* end_pointer);
tlv_list_node_type* return_tlv_of_type(const unsigned int type);
static bool setup_proxy(const unsigned int session);
#ifdef USE_TRUSTED_DOMAINS
static bool validate_domain(const char* const url, const char* const allowed_domains);
#endif /* USE_TRUSTED_DOMAINS */

/* The base address for the dynamic area. */
char *dynamic_area_base_address = NULL;

/* This variable gets set if the CRC of the image has been validated. */
bool crc_validated = false;

static int memory_bank=0;     /* memory bank to write to */

typedef enum {
  TLV_TAG_TYPE_FILE_SIZE,
  TLV_TAG_TYPE_DISPLAY_STRING,
  TLV_TAG_TYPE_BUILD_LIST,
  TLV_TAG_TYPE_LOCALE_LIST,
  TLV_TAG_TYPE_IMAGE_TYPE,
  TLV_TAG_TYPE_IMAGE_LENGTH,
  TLV_TAG_TYPE_IMAGE_DATA,
  TLV_TAG_TYPE_FILE_CRC,
  TLV_TAG_TYPE_RANDOM_DATA,
  TLV_TAG_TYPE_BANK,
  TLV_TAG_TYPE_UNRECOGNISED
} TLV_TAG_TYPES;


/*  Main takes a URL as it's only command line argument.  It controls the
downloading of a compressed image into a dynamic area.  Here are the main
steps it takes

1) Read URL from Command line
2) Create a dynamic area to store the compressed image
3) Connect to the FTP Server
4) Get the image 32k at the time.
5) Launch the child task
*/

int main(int argc, char *argv[])
{
  _kernel_swi_regs regs;
  _kernel_oserror *err, *error;

  int session_identifier = 0;                   /* This stores the session identifier we have registered with the URL module. */

  char *url = malloc(255);                      /* url string */

  int dynamic_area_number;                      /* dynamic area identifier */
  char *dynamic_area_current_ptr = NULL;        /* pointer to current bit */

  char command_line_arguments[255];             /* used to pass args to child process */
  char child_task[256];                         /* child task to run */

  int image_size = 0;                           /* size of image */

  int server_timeout;

  char* image_pointer = NULL; /* This points to the start if the image to be put into Flash in the DA. */
  tlv_list_node_type* image_pointer_tlv = NULL;

  /* Initialise the DebugLib library. */
  debug_initialise ("UpgradeFetcher", "izipfs:$.FetchOut", "");
  debug_output_device (PRINTF_OUTPUT);
  debug_atexit ();

  DBUG_PRINTF(DBUG_LVL_DIAG, "main()\n");

  /* Read the command line arguments. There should be two arguments we read
      the second one should be the url */
  if (argc < 2)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "main(): Not enough arguments supplied\n");
    exit(EXIT_FAILURE);
  }

  /* set up the url */
  strcpy(url, argv[2]);

  /* initialise message file */
  init_messages();

  /* set wimp mode to 640 X 480 so it works on any box */
  set_wimp_mode();

  /* Initialise the WIMP */
  initialise_wimp();

  /* Ensure that the URL is from a trusted source */
  #ifdef USE_TRUSTED_DOMAINS
  if (!validate_domain(url,  USE_TRUSTED_DOMAINS))
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "main(): %s is not a trusted domain. Exiting.\n", url);
    error_occurred("InvalidServer");
  }
  #endif /* USE_TRUSTED_DOMAINS */

  /* Create ourselves a dynamic area */
  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Creating a dynamic area.\n");
  regs.r[0] = 0;
  regs.r[1] = -1;
  regs.r[2] = 1;
  regs.r[3] = -1;
  regs.r[4] = 0;
  regs.r[5] = -1;
  regs.r[6] = 0;
  regs.r[7] = 0;
  regs.r[8] = (int)"Upgrade Image Area";

  err = _kernel_swi(OS_DynamicArea, &regs, &regs);
  if (err)
  {
    error_occurred("CantClaimDynamicArea");
  }

  /* set up the dynamic area variables */
  dynamic_area_number = regs.r[1];
  dynamic_area_base_address = (char*)regs.r[3];
  dynamic_area_current_ptr = dynamic_area_base_address;

  /* free up some memory by killing running applications */
  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Attempting to kill some running applications.\n");
  if (!kill_apps())
  {
    error_occurred("CantKillApplications");
  }

  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Initialising the status screen.\n");
  initialise_status_screen();

  /* Register the session and set the session_identifier flag */
  regs.r[0] = 0;
  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Resgistering the session.\n");
  err = _kernel_swi(URL_Register, &regs, &regs);
  status_print("Connecting to the FTP server\n");
  if (err)
  {
    error_occurred("CantConnectToFTPServer");
  }
  session_identifier = regs.r[1];

  /* Set up the proxy (if any) */
  if (!setup_proxy(session_identifier))
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "main(): Could not connect via a proxy.\n");
  }

  /* Commence the fetch of the data from the url */
  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Commencing fetch of the URL.\n");
  regs.r[0] = 0;         /* We do want the length of the data */
  regs.r[1] = session_identifier;
  regs.r[2] = 1;
  regs.r[3] = (int)url;  /* The location of the URL */
  regs.r[4] = NULL;
  regs.r[5] = 0;
  regs.r[6] = NULL;
  error = _kernel_swi(URL_GetURL, &regs, &regs);

  if (error)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "main(): Error commencing fetch of the URL.\n");
    error_occurred("CantFetchURL");
  }

  /* Get the server timeout value from message file */
  server_timeout = atoi( lookup_message_token("ServerTimeout") );

  /* Initialise the linked list of TLV values. */
  tlv_list_head = NULL;
  tlv_list_tail = NULL;

  /*  This is the main Data fetch routine */
  fetch_data(session_identifier, dynamic_area_number, &dynamic_area_current_ptr, server_timeout, dynamic_area_base_address);

  /* Deregister with the URL module */
  regs.r[0] = 0;
  regs.r[1] = session_identifier;
  _kernel_swi(URL_Deregister, &regs, &regs);

  /* Decode the TLV tags. */
  decode_tlv_tags_after_download();

  /* Calculate the final image size. */
  image_size = dynamic_area_current_ptr - dynamic_area_base_address;
  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Final image size is %d bytes\n", image_size);
  if (image_size <= 0)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "main(): Error: Image size should be greater than zero.\n");
    exit(EXIT_FAILURE);
  }

  /* Display the linked list */
  display_linked_list();

  /* Obtain a pointer to the image to be programmed from the linked list. */
  image_pointer_tlv = return_tlv_of_type(TLV_TAG_TYPE_IMAGE_DATA);
  image_pointer = image_pointer_tlv->value_pointer;
  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): Pointer to the beginning of the image is %0x\n", image_pointer);

  /* Free the list. */
  free_list();

  /* Only attempt to flash the image if it's CRC has been validated. */
  if (crc_validated)
  {
    status_print("Programming new image\n");
    poll_wimp();

    /* Create the string to pass the dynamic area address and image size to the atmel flash programmer */
    strcpy(child_task, lookup_message_token("ChildTask") );
//  memory_bank = atoi( lookup_message_token("MemoryBank") );
    sprintf(command_line_arguments, "%s %i -memory -size %i -os %i",
            child_task, (int)image_pointer, image_pointer_tlv->tag_length,
            memory_bank);

    /* Ensure that the messages file has been closed. */
    if (!close_messages_file())
    {
      exit(EXIT_FAILURE);
    }

    /* Finally execute the string including the child task string */
    DBUG_PRINTF(DBUG_LVL_DIAG, "main(): UpgFlash command line args %s\n", command_line_arguments);
    _kernel_oscli(command_line_arguments);
  }
  else
  {
    if (!close_messages_file())
    {
     exit(EXIT_FAILURE);
    }
  }

  return (SUCCESS);
}





/* This function checks that we are still receiving data from the server
essentially if we don't receive any data in the time specified in the
messages file as ServerTimeout it returns an error.
*/
void check_for_timeout(const int server_timeout)
{
  float current_timer_value;

  /* increment the number of null reads */
  number_of_null_reads ++;

  /* set up the timer for the first time */
  if (last_timer_value == 0)
  {
    last_timer_value = read_time_in_seconds();
    return;
  }

  /* if number of null reads > NULL_COUNTOUT check for data stream */
  if (number_of_null_reads > NULL_COUNTOUT)
  {
    current_timer_value = read_time_in_seconds();

    /* check for activity for NULL_TIMEOUT seconds */
    if ( (current_timer_value - last_timer_value) > server_timeout )
    {
      error_occurred("ServerError");
    }
    else
    {
      number_of_null_reads = 0;
    }
  }
}




/* This function is just an interface to the ReadMonotonicTime SWI
*/
float read_time_in_seconds(void)
{
  _kernel_swi_regs regs;
  float time_in_seconds;

  _kernel_swi(OS_ReadMonotonicTime, &regs, &regs);

  time_in_seconds = (float)regs.r[0] / 100;

  return (time_in_seconds);
}





/* Since we are running as a Wimp Toolbox task we need to initialise the
Toolbox and load our resource file e.t.c. This routine does this for us.
It also makes a call to initialise our messages.
*/
void initialise_wimp()
{
  int wimp_messages = 0,
      toolbox_events = 0;

  toolbox_initialise(0, WimpVersion, &wimp_messages, &toolbox_events,
                     "<Fetch$Dir>", &messages, &id_block, 0, 0, 0);
}



/* This function is just an interface to OS_Reset called to
reset the machine.  Called when the user clicks the dialogue box to reset
*/

int reset_machine(int event_code, ToolboxEvent *event,
                             IdBlock *id_block,void *handle)
{
  _kernel_swi_regs regs;

  _kernel_swi(OS_Reset, &regs, &regs);

  return(SUCCESS);
}



/* This routine returns the amount of free memory available in the system. */
unsigned int return_free_memory(void)
{
  _kernel_swi_regs regs;
  regs.r[0] = -1;
  regs.r[1] = -1;
  _kernel_swi(Wimp_SlotSize, &regs, &regs);

  return (regs.r[2]);
}





/* This routine performs the fetching of the data from the URL.
   Here we get 32k chunks of data at a time.  If we can we try and read
  the number of bytes remaining to be read as soon as possible so as to
  ensure we don't run out of memory in the dynamic area.  If this isn't
  possible we allocate the memory on the fly and hope for the best !!

  The first part of the image shall be an header in the format as specified
   by the specification 2503/047/FS. This header consists of a series of
   Tag-Length-Value triplets that contain imformation about theimage embedded
   within the file.
  */
bool fetch_data(const int session_identifier, const int dynamic_area_number, char** dynamic_area_current_ptr, const int server_timeout, const char* const dynamic_area_base)
{
  _kernel_swi_regs regs;
  _kernel_oserror *error = NULL;
  char buffer[URL_CHUNK_SIZE];                  /* buffer for the latest chunk of data from the URL. */

  int bytes_read;                               /* bytes read in a single pass */
  int total_bytes_read = 0;                     /* total bytes read */
  int bytes_left_to_read = -1;                  /* bytes left to read */

  bool checked_free_memory  = false;            /* If this flag is set then the program has recived the size of the file from the server, and has allocated the correct DA size. If it is unset, then as it reads some data from the URL it also allocates the memory for it to be put in. */
  bool started_getting_data = false;            /* flag */
  bool success = true;

  /* Add two vars we need for the TLV decode.... */
  char* end_of_last_tag = (char*)dynamic_area_base;

  /* Set vars to store the amount of memory currently alloated for the DA, and the amount used. */
  unsigned int mem_da_size = 0;
  unsigned int mem_da_used = 0;

  char* start = NULL;
  bool finished_parsing = false;

  while (!error)
  {
    regs.r[0] = 0;
    regs.r[1] = session_identifier;
    regs.r[2] = (int)buffer;
    regs.r[3] = URL_CHUNK_SIZE;

    /* Read next 32k chunk */
    error = _kernel_swi(URL_ReadData, &regs, &regs);

    /* check to see that we have finished */
    if (error)
    {
        DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Fetch error :%s",error->errmess);

       regs.r[0] = 0;
       regs.r[1] = session_identifier;

      _kernel_swi(URL_Status, &regs, &regs);

      //if tranfer aborted or all data not recieved
      if((regs.r[0] & 0x40)         //bit 6 set transfer aborted
          || !(regs.r[0] & 0x30))    //bit 5 all data recieved
      error_occurred("ServerError");

      //we should have the data now!

      break;
    }

    bytes_read = regs.r[4];
    if (bytes_read > 0)
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): We have read %d bytes from the URL.\n", bytes_read);
    }

    /* update the variable holding the total bytes read */
    total_bytes_read += bytes_read;

    if (bytes_read > 0)
    {
       // if we haven't already done so update the display
       if (started_getting_data == false)
       {
         status_print("Downloading new image\n");
         started_getting_data = true;
       }

       /* if we haven't already done so, check we have the required free ram. */
       if (checked_free_memory == false)
       {
        bytes_left_to_read = regs.r[5];

        /* if we receive notification of how much left */
        if (bytes_left_to_read != -1 || total_bytes_to_read > 0)
        {
          int amount_to_allocate;
          /* We now know (either from the server or the upgrade file itself) how much memory we need. Allocate it.*/
          if (bytes_left_to_read != -1)
          {
            total_bytes_to_read = bytes_left_to_read + total_bytes_read;
            amount_to_allocate = bytes_left_to_read + bytes_read;
          }
          else
          {
            amount_to_allocate = total_bytes_to_read-mem_da_size;
          }

         /* allocate memory for the whole image */
         DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Attempting to increase size of DA holding image by %d bytes (free memory in system is %d bytes).\n", amount_to_allocate, return_free_memory());

         regs.r[0] = dynamic_area_number;
         regs.r[1] = amount_to_allocate;
         error = _kernel_swi(OS_ChangeDynamicArea, &regs, &regs);
         if (error)
         {
           DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): DA area increase failed - allocated %d bytes instead of the required %d bytes (message %s).\n", regs.r[1], amount_to_allocate, error->errmess);
           error_occurred("NotEnoughMemory");
         }
         else
         {
           mem_da_size+=amount_to_allocate;
           mem_da_used+=bytes_read;
         }

         checked_free_memory = true;
       }
     }

     /* If we still don't know how large the image is allocate enough
         for the currently read block (dynamically). This needs to be done to the nearest page size. */
     if (checked_free_memory == false)
     {
       double d_mem_requested = (double) bytes_read;
       int i_mem_requested;
       d_mem_requested = ceil(d_mem_requested/4096)*4096; /* Page-align it */
       i_mem_requested = (int)d_mem_requested;
       DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): We want %d more bytes (free memory in system is %d bytes).\n", i_mem_requested, return_free_memory());
       DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Current DA size is %d bytes, used is %d bytes\n", mem_da_size, mem_da_used);

       /* If we have not got enough space in the da, increase the size. */
       if ((i_mem_requested+mem_da_used) >= mem_da_size)
       {
         DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Increasing size of the DA by %d bytes.\n", i_mem_requested);

         regs.r[0] = dynamic_area_number;
         regs.r[1] = i_mem_requested;
         error = _kernel_swi(OS_ChangeDynamicArea, &regs, &regs);
         if (error)
         {
           DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Incremental DA area increase failed - allocated %d bytes instead of the required %d bytes (message %s).\n", regs.r[1], bytes_read, error->errmess);
           error_occurred("NotEnoughMemory");
         }
         else
         {
           mem_da_size+=i_mem_requested;
           mem_da_used+=bytes_read;
         }
       }
       else
       {
         mem_da_used+=bytes_read;
       }
     }
     else
     {
       mem_da_used+=bytes_read;
       DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Current DA size is %d bytes, used is %d bytes\n", mem_da_size, mem_da_used);
     }

     /* If the memory allocation has worked, copy the memory over and update the status screen. */
     if (!error)
     {
       /* copy the memory block into the dynamic area */
       DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Copying %d bytes of memory\n", bytes_read);
       memcpy(*dynamic_area_current_ptr, buffer, bytes_read);
       update_status_screen(total_bytes_read, total_bytes_to_read);
       *dynamic_area_current_ptr += bytes_read; // increment the memory pointer
     }
     else
     {
       DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Error allocating dynamic area (%s)\n", error->errmess);
     }

     start = end_of_last_tag;
     finished_parsing = false;

     while (!finished_parsing && end_of_last_tag != *dynamic_area_current_ptr) /* We wish to get all the complete tags out of this block. */
     {
       char *complete_tag = is_tag_complete(end_of_last_tag, *dynamic_area_current_ptr);
       DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): end_of_last_tag = %0x, *dynamic_area_current_ptr = %0x\n", end_of_last_tag, *dynamic_area_current_ptr);
       if (complete_tag) /* Tag is complete, add it to the list. */
       {
         /* Now act on the tags that we need to act on during download. */
         if (return_tag_type(start, *dynamic_area_current_ptr) == TLV_TAG_TYPE_FILE_SIZE) /* File size */
         {
           int file_size = read_little_word(start+8);
           DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): This is a file size tag. Size of downloadable file is %d\n", file_size);
           /* We wish to set the size of the downloaded file now that we know it. */
           total_bytes_to_read = file_size;
         }
         if (return_tag_type(start, *dynamic_area_current_ptr) == TLV_TAG_TYPE_DISPLAY_STRING) /* String to display */
         {
           DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): This is a string tag. String is %s\n", start+8);
           status_print(start+8);
         }
         if (return_tag_type(start, *dynamic_area_current_ptr) == TLV_TAG_TYPE_BUILD_LIST) /* A list of builds to which this image can be applied. */
         {
           //do it later!
         }
         end_of_last_tag = complete_tag;
         add_node(return_tag_type(start, *dynamic_area_current_ptr), return_tag_length(start, *dynamic_area_current_ptr), start+8);
         start = end_of_last_tag; /* Reset the start to point back to the end of te newly completed tag. */

       }
       else
       {
         /* Make it point back to the start of this tag again. */
         DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Incomplete tag. Setting end_of_last_tag back to %0x and waiting for more data to be downloaded.\n", end_of_last_tag);
         end_of_last_tag = (char*)start;
         finished_parsing = true;
       }
     }

     /* reset the null reads counter */
     number_of_null_reads = 0;
     last_timer_value = 0;
    }
    else
    {
      /* if no bytes have been read from the URL */
      check_for_timeout(server_timeout);
    }

    /* poll the wimp to update any toolbox changes */
    poll_wimp();
  }

  return (success);
}





/* This routine returns the type of the tag held at the memory location
base_pointer. It returns -1 if the tag type is incomplete (i.e. only three of
the four bytes needed have been downloaded). Typically base_poiner would be
the known start point of a tag (or the beginning of the memory area if no
complete tag has yet been found), and end_pointer the end of the currently
downloaded memory. */

static int return_tag_type(const char* const base_pointer, const char* end_pointer)
{
  int tag_type = -1;

  /* Ensure that at least four bytes have been downloaded */
  if (end_pointer-base_pointer < 4)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "return_tag_type(): Tag type data is incomplete\n");
    tag_type = -1;
  }
  else
  {
    /* Convert the word to an integer */
    tag_type = (int) *base_pointer;
    if (tag_type < 0)
    {
      /* The tag_type should be positive (according to the spec) */
      DBUG_PRINTF(DBUG_LVL_ERROR, "return_tag_type(): Error: the tag_type should be positive according to the spec.\n");
    }
  }

  DBUG_PRINTF(DBUG_LVL_DIAG, "return_tag_type(): The tag is of type %d\n", tag_type);

  return (tag_type);
}





unsigned int read_little_word(const char* const buff)
{
    unsigned int i = 0;

    i = (*(buff)) | ((*(buff+1))<<8) | ((*(buff+2))<<16) | ((*(buff+3))<<24);

    return(i);
}



/* This routine returns the langth of the tag held at the memory location
base_pointer. It returns -1 if the tag type is incomplete (i.e. only three of
the four bytes needed have been downloaded). Typically base_poiner would be
the known start point of a tag (or the beginning of the memory area if no
complete tag has yet been found), and end_pointer the end of the currently
downloaded memory. */

static int return_tag_length(const char* const base_pointer, const char* end_pointer)
{
  int tag_length = -1;

  /* Ensure that at least eight bytes have been downloaded (this must be the case if the length has been completely doenloaded */
  if (end_pointer-base_pointer < 8)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "return_tag_length(): Tag length data is incomplete\n");
    tag_length = -1;
  }
  else
  {
    char *length_pointer = (char*)(base_pointer+4); /* Ignore the first word */
    /* Convert the word to an integer */
    tag_length = (int)read_little_word(length_pointer);
    if (tag_length < 0)
    {
      /* The tag_type should be positive (according to the spec) */
      DBUG_PRINTF(DBUG_LVL_ERROR, "return_tag_length(): Error: the tag length should be positive according to the spec.\n");
    }
  }

  DBUG_PRINTF(DBUG_LVL_DIAG, "return_tag_length(): The tag is of length %d\n", tag_length);

  return (tag_length);
}




/* This routine can be used to detect whether the tag which starts at
base_pointer is complete. It retrieves the type of the tag and the length,
and checks that the entire contents of the tag (type, length and value) have
been downloaded. It assumes that base_pointer points at the start of a tag.
   It returns NULL if it is incomplete, or the end of tag if it is complete. */

static char* is_tag_complete(const char* const base_pointer, const char* const end_pointer)
{
  /* Note: This routine relies on some nasty pointer arithmetic, and assumes
that the memory block is contiguous. */
  char* end_of_tag  = NULL;
  int tag_type, tag_length;

  DBUG_PRINTF(DBUG_LVL_DIAG, "is_tag_complete()\n");

  tag_type = return_tag_type(base_pointer, end_pointer);
  tag_length = return_tag_length(base_pointer, end_pointer);

  /* Ensure that the tag has been fully downloaded, i.e. that end_pointer -
base_pointer is greater than 8+the tag length. (the 8 comes from the combined
size of the tag and length values in bytes). */
  DBUG_PRINTF(DBUG_LVL_DIAG, "is_tag_complete(): base_pointer is %0x end_pointer is %0x\n", base_pointer, end_pointer);
  DBUG_PRINTF(DBUG_LVL_DIAG, "is_tag_complete(): end_pointer-base_pointer is %d\n", (int)(end_pointer-base_pointer));
  if ((int)(end_pointer-base_pointer) <= 0)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "is_tag_complete(): Error, end_pointer-base_pointer should be positive.\n");
    exit (EXIT_FAILURE);
  }
  if (end_pointer-base_pointer < (8+tag_length))
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "is_tag_complete(): The tag is not yet complete. Current tag size is %d, known tag length is %d\n", (int)(end_pointer-base_pointer), 8+tag_length);
    return (end_of_tag);
  }

  end_of_tag = (char*)base_pointer+8+tag_length; /* +8 to skip over Tag+Length */
  return (end_of_tag);
}


#ifdef ENABLE_DEBUGGING

// This routine decodes the file once it has been downloaded into a series of
// TLV values in a linked list.

static void decode_file(const char* const memory_base, const char* const memory_end)
{
  // This points to the end of the last tag found, i.e. the start of the next tag. Whenever a tag is found this gets moved up as appropriate.
  char* end_of_last_tag = (char*)memory_base;

  DBUG_PRINTF(DBUG_LVL_DIAG, "decode_file()\n");
  end_of_last_tag = is_tag_complete(end_of_last_tag, memory_end);
  while (end_of_last_tag && end_of_last_tag < memory_end)
  {
    const char* const start = end_of_last_tag;
    DBUG_PRINTF(DBUG_LVL_DIAG, "decode_file(): end_of_last_tag = %0x, memory_end = %0x\n", end_of_last_tag, memory_end);
    end_of_last_tag = is_tag_complete(end_of_last_tag, memory_end);
    if (end_of_last_tag) // Tag is complete, add it to the list.
    {
      add_node(return_tag_type(start, memory_end), return_tag_length(start, memory_end), start+8);
    }
  }
}

#endif

/* Parse and display the list of TLV nodes */
static void display_linked_list(void)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "display_linked_list()\n");

  if (tlv_list_head == NULL)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "display_linked_list(): No list generated.\n");
  }
  else
  {
    tlv_list_node_type *tlv_node_current = tlv_list_head;
    do
    {
      /* Display the node details... */
      DBUG_PRINTF(DBUG_LVL_DIAG, "display_linked_list(): Tag is of type %d length %d\n", tlv_node_current->tag_type, tlv_node_current->tag_length);

      /* Move onto the next node... */
      tlv_node_current = tlv_node_current->next_tag;
    }
    while (tlv_node_current != NULL);
  }
}


/* This goes through the list and frees all memory allocated. */
static void free_list(void)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "free_list()\n");

  if (tlv_list_head == NULL)
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "free_list(): Null list.\n");
  }
  else
  {
    tlv_list_node_type *tlv_node_current = tlv_list_head;
    do
    {
      tlv_list_node_type* node_to_delete = tlv_node_current;

      DBUG_PRINTF(DBUG_LVL_DIAG, "free_list(): Freeing node..\n");

      /* Move onto the next node... */
      tlv_node_current = tlv_node_current->next_tag;

      /* And free the node to be deleted. */
      if (node_to_delete)
      {
        free (node_to_delete);
        node_to_delete = NULL;
      }
    }
    while (tlv_node_current != NULL);
  }

  /* Finally set the head pointer to NULL. */
  tlv_list_head = NULL;
}


/* This routine is called after the download has completed so that we can act
on the TLV tags. For instance in this routine the CRC check is called. */

void decode_tlv_tags_after_download(void)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "decode_tlv_tags_after_download()\n");

  /* Scan through the list of tags, acting on each of them in turn. */
  if (tlv_list_head == NULL)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "decode_tlv_tags_after_download(): No list generated.\n");
  }
  else
  {
    tlv_list_node_type *tlv_node_current = tlv_list_head;
    do
    {
      /* Now act on this TLV type. */
      switch (tlv_node_current->tag_type)
      {
        case TLV_TAG_TYPE_FILE_SIZE:
          break;
        case TLV_TAG_TYPE_DISPLAY_STRING:
          break;
        case TLV_TAG_TYPE_BUILD_LIST:
          checkBuild(tlv_node_current->value_pointer);
          break;
        case TLV_TAG_TYPE_LOCALE_LIST:
          break;
        case TLV_TAG_TYPE_IMAGE_TYPE:
          break;
        case TLV_TAG_TYPE_IMAGE_LENGTH:
          break;
        case TLV_TAG_TYPE_IMAGE_DATA:
          break;
        case TLV_TAG_TYPE_FILE_CRC:
          {
          unsigned int crc_value = read_little_word(tlv_node_current->value_pointer);
          DBUG_PRINTF(DBUG_LVL_DIAG, "decode_tlv_tags_after_download(): This is a CRC of value %d.\n", crc_value);
          crc_validated = validate_crc(crc_value, tlv_node_current->value_pointer-8);
          }
          break;
        case TLV_TAG_TYPE_RANDOM_DATA:
          break;
        case TLV_TAG_TYPE_UNRECOGNISED:
          break;
        case TLV_TAG_TYPE_BANK:
          memory_bank=read_little_word(tlv_node_current->value_pointer);
          break;
        default:
          break;
      }

      /* Move onto the next node... */
      tlv_node_current = tlv_node_current->next_tag;
    }
    while (tlv_node_current != NULL);
  }
}


#if 0
/* This routine scans through the list of TLV's and does what is necessary after the whole file has been downloaded. Currently we do not need to do anything after the file has been downloaded. */
void decode_tags_after_download(void)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "decode_tags_after_download()\n");

  if (tlv_list_head == NULL)
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "decode_tags_after_download(): Null list.\n");
  }
  else
  {
    tlv_list_node_type *tlv_node_current = tlv_list_head;
    do
    {
      // decode this tag...

      // Move onto the next node...
      tlv_node_current = tlv_node_current->next_tag;
    }
    while (tlv_node_current != NULL);
  }
}
#endif




/* This routine can be used to scan through a list of TLV's and return the
    first one that it comes across of a certain type. */
tlv_list_node_type* return_tlv_of_type(const unsigned int type)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "return_tlv_of_type()\n");

  if (tlv_list_head == NULL)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "return_tlv_of_type(): No list generated.\n");
  }
  else
  {
    tlv_list_node_type *tlv_node_current = tlv_list_head;
    do
    {
      /* Is this node of the type that we want... */
      if (tlv_node_current->tag_type == type)
      {
        return (tlv_node_current);
      }

      /* Move onto the next node... */
      tlv_node_current = tlv_node_current->next_tag;
    }
    while (tlv_node_current != NULL);
  }

  return (NULL);
}







/* This routine adds a node to the list of TLV values. */
static void add_node(const int type, const int length, const char* const location)
{
  tlv_list_node_type* temp_node;

  DBUG_PRINTF(DBUG_LVL_DIAG, "add_node(): Creating node with data: tag %d length %d location %0x\n", type, length, location);

  /* Creatte the new node */
  temp_node = malloc(sizeof(tlv_list_node_type));
  if (!temp_node)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "add_node(): Failed to add node (memory allcation error)\n");
    exit(EXIT_FAILURE);
  }

  /* Copy over the data */
  temp_node->tag_type = type;
  temp_node->tag_length = length;
  temp_node->value_pointer = (char*)location;
  temp_node->next_tag = NULL;

  /* If no node has been allocated, allocate one */
  if (tlv_list_head == NULL)
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "add_node(): Creating the first (head) node.\n");
    tlv_list_head = temp_node;
    tlv_list_tail = tlv_list_head;
  }
  else
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "add_node(): Adding another node.\n");
    tlv_list_tail->next_tag = temp_node;
    /* And move the tail onto the newly allocated node */
    tlv_list_tail = tlv_list_tail->next_tag;
  }
}



/* This routine checks that the image is correct up to the passed location.
It returns true if the crc matches, false oterwise. */

bool validate_crc(unsigned int expected_crc, const char* const end_location)
{
  unsigned int crc;
  unsigned int size = 0;
  char* ch;

  DBUG_PRINTF(DBUG_LVL_DIAG, "validate_crc(): We are expecting an end value of %d\n", expected_crc);

  make_crc_tables();

  DBUG_PRINTF(DBUG_LVL_DIAG, "validate_crc(): CRC tables constructed. %d\n");

  /* Ensure that we are not attmepting to read from NULL */
  if (dynamic_area_base_address == NULL)
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "validate_crc(): Urgh, dynamic_area_base_address is NULL. Bailing.\n");
    return (false);
  }

  /* crc precondition */
  crc=0xffffffff;

  DBUG_PRINTF(DBUG_LVL_DIAG, "validate_crc(): CRCed image follows:\n");

  ch = dynamic_area_base_address;
  do
  {
    update_crc((U8*)ch,(U32*)&crc);
    size++;
    ch++;
  }
  while(ch < end_location);

  /* crc postcondition */
  crc ^= 0xffffffff;

  DBUG_PRINTF(DBUG_LVL_DIAG, "validate_crc(): CRC generated is %ud\n", crc);

  /* Ensure that the crc matches the expected value. */
  if (crc == expected_crc)
  {
    return (true);
  }
  else
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "validate_crc(): The CRC's mismatch (size of CRC'd image was %d).\n", size);
    error_occurred("CRCMismatch");
  }

  return (false);
}

void checkBuild(char *builds)
{
  _kernel_swi_regs regs;
  _kernel_oserror *error = NULL;

  //the OSversion string should contain the build
  char *OSver,*token;
  char build_list[80];

  //get the OS version string
  regs.r[0] = 0;
  regs.r[1] = 0;
  error = _kernel_swi(OS_Byte, &regs, &regs);
  OSver=error->errmess;

  DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): OS version is %s\n", OSver);

  //point to the build list
  strcpy(build_list,builds);

  DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): build list : %s\n", build_list);

  //get the first token in the build list
  token=strtok(build_list,", ");

  do
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): token : %s\n", token);
    //if we find the token break out of the loop
    if (strstr(OSver,token) != NULL) break;
    token=strtok(NULL,", ");
   }
   while (token !=NULL);

   if (token==NULL)
     {
       DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Invalid Build");
       error_occurred("WrongBuild");
     }
     else
     {
       DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_data(): Correct Build");
     }
}



/* This routine sets up a proxy with the URL module */
static bool setup_proxy(const unsigned int session)
{
  char* ftp_proxy = NULL;
  int tag_size = -1;
  _kernel_swi_regs regs;
  _kernel_oserror *err;

  /* Read the FTP proxy from NCMAlite */
  regs.r[0] = (int)"FTP_PROXY";
  regs.r[1] = NULL;
  regs.r[2] = 0;

  err = _kernel_swi(NCMATwin_Enquiry, &regs, &regs);
  if (err!=NULL)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "setup_proxy(): Error whilst trying to get FTP proxy from NCMA.\n");
    return (false);
  }

  tag_size = regs.r[0];
  if (tag_size < 0)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "setup_proxy(): FTP proxy tag does not exist..\n");
    return (false);
  }
  else
  {
    if ((ftp_proxy = malloc(tag_size+2)) == NULL)
    {
      DBUG_PRINTF(DBUG_LVL_ERROR, "setup_proxy(): Error allocating %d bytes of memory for tag.\n", tag_size);
      return (false);
    }
    else
    {
      regs.r[0]=(int)"FTP_PROXY";
      regs.r[1]=(int)ftp_proxy;
      regs.r[2]=tag_size;

      err = _kernel_swi(NCMATwin_Enquiry, &regs, &regs);
      if (err!=NULL)
      {
        DBUG_PRINTF(DBUG_LVL_ERROR, "setup_proxy(): Error whilst trying to get FTP proxy from NCMA.\n");
        return (false);
      }
    }
  }

  DBUG_PRINTF(DBUG_LVL_DIAG, "setup_proxy(): Proxy is %s\n", ftp_proxy);

#if 0 /* We may well need to make a call to the SWI below to convert the format of the Proxy URL. */
  /* Parse the URL (converts it into a suitable format */
  {
    char buffer[10];
    regs.r[0] = 0;
    regs.r[1] = 3;         /* Quick parse */
    regs.r[2] = ftp_proxy;
    regs.r[3] = NULL;
    regs.r[4] = buffer;    /* Only availble if r0 bit 0 is 0 and r3 is 1. */
    err = _kernel_swi(URL_Parse, &regs, &regs);
  }
#endif /* 0 */

  /* Register the proxy */
  regs.r[0] = 0;
  regs.r[1] = session;
  regs.r[2] = (int)ftp_proxy;
  regs.r[3] = (int)"ftp";
  regs.r[4] = 0;
  err = _kernel_swi(URL_SetProxy, &regs, &regs);
  if (err!=NULL)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "setup_proxy(): Error whilst trying to set FTP proxy\n");
    return (false);
  }

  return (true);
}


#ifdef USE_TRUSTED_DOMAINS
/* This routine checks that the url passed in is an allowed domain. The rules for detecting a valida domain are as follows:
   * Anything before (and including) a :// is stripped (e.g. http:// or ftp://)
   * Anything after (and including) the next / is stripped (e.g. /upgrades/ftp)
   * The remainder is now checked against each of the allowed domains in turn. The matching is done in a substring manner, with pace.co.uk matching both support.pace.co.uk, upgrades.pace.co.uk and pace.co.uk?upgrades, but not http://hackers_r_us@hacknet.net/pace.co.uk
   This routine returns true if the domain mataches, false otherwise.
*/

static bool validate_domain(const char* const url, const char* const allowed_domains)
{
  /* Strip the URL */
  char url_copy[255]; /* We do not wish to alter the main copy, so store the altered version seperately */
  char* start=NULL;
  char* end = NULL;
  char* current_domain = NULL;

  if (strlen(url) >= 255)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "validate_domain(): Error: buffer for url_copy is shorter than the url legnth.\n");
    return (false);
  }
  strcpy (url_copy, url);

  DBUG_PRINTF(DBUG_LVL_DIAG, "validate_domain(): url is %s domains are %s\n", url_copy, allowed_domains);

  if ((start = strstr(url_copy, "://")) == NULL)
  {
    DBUG_PRINTF(DBUG_LVL_ERROR, "validate_domain(): Cannot locate :// in url.\n");
    return (false);
  }
  start+=3; /* Move to beyond the :// */

  end = strchr(start, '/');
  if (end != NULL)
  {
    /* There does not have to be a trailing slash, eg. http://www.pace.co.uk is valid. */
    *end = '\0'; /* Convert the slash to an endline. */
  }

  DBUG_PRINTF(DBUG_LVL_DIAG, "validate_domain(): Stripped line is %s\n", start);

  /* Now scan through the allowed domaind, checking if there is a substring match. */
  current_domain=(char*)allowed_domains;
  while (current_domain!=NULL)
  {
    char* new_current_domain = strchr(current_domain, ',');
    if (new_current_domain)
    {
      *new_current_domain='\0';
      new_current_domain++;
    }
    DBUG_PRINTF(DBUG_LVL_DIAG, "validate_domain(): current_domain is %s\n", current_domain);

    /* Now attempt to match the domain.. */
    if (strstr(start,current_domain))
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "validate_domain(): domains %s and %s match\n", start, current_domain);
      return (true);
    }

    /* Move onto the next allowed domain. */
    current_domain = new_current_domain;
  }

  return (false);
}

#endif /* USE_TRUSTED_DOMAINS */
