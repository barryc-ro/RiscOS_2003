/**************************************************************/
/* File:    Utils.c                                           */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Infrequently altered utilities.                   */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 07-Apr-2000 (ADH): Adapted from Browse source.    */
/*          16-Oct-2000 (ADH): Imported from PlugPlay.        */
/*          18-Oct-2000 (ADH): Error reporting functions and  */
/*                             related definitions moved to   */
/*                             Error.c / Error.h.             */
/*          30-Apr-2001 (ADH): Imported from DDT2.            */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <setjmp.h>
#include <string.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimplib.h>
#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>
#include <tboxlibs/gadgets.h>

#include "Dirs.h"
#include "Errors.h"
#include "FromROSLib.h"
#include "Global.h"

#include "Utils.h"

/* Local definitions. MaxiumUniqueNames is an inclusive number for   */
/* the highest numbered directory used by the unique name functions. */

#define MillipointsPerOSUnit 400
#define MaximumUniqueNames   128

/* Locals */

static int  millipoints_per_os_unit_x = 400; /* See read_os_to_points */
static int  millipoints_per_os_unit_y = 400;
static int  half_mppou_x              = 200;
static int  half_mppou_y              = 200;
static int  overflow_limit_x          = 0x28f5c1; /* = (0x3fffffff / 400) rounded down for caution*/
static int  overflow_limit_y          = 0x28f5c1;

/* Local functions */

static char * lookup_in_given (MessagesFD * control, const char * s, unsigned int num_args, va_list ap);

/**************************************************************/
/* lookup_token()                                             */
/*                                                            */
/* Returns a pointer to an expanded message token, or '!' if  */
/* there was an error.                                        */
/*                                                            */
/* Lookup is done into a global fixed-size buffer. So if you  */
/* pass multiple calls to this function in as parameters to   */
/* something else, *it will fail* as each call points to the  */
/* same buffer (which will only contain data from the last    */
/* call).                                                     */
/*                                                            */
/* On the upside this means you can modify the returned       */
/* string directly without having to worry about taking a     */
/* copy. If you do this, though, you *must* invalidate the    */
/* record of the last looked up token; "*lasttokn = '\0'" is  */
/* sufficient. This is all clearly hideous and best avoided,  */
/* but hey, it's handy from time to time...!                  */
/*                                                            */
/* Parameters: Pointer to a message token;                    */
/*                                                            */
/*             Number of arguments that follow (0 to 4);      */
/*                                                            */
/*             Between zero and four pointers to NUL          */
/*             terminated strings used for substitution into  */
/*             the string being looked up ('%0' to '%3').     */
/*                                                            */
/* Returns:    Pointer to the full message text or '!' to     */
/*             signal an error; never a null pointer.         */
/*                                                            */
/* Assumes:    That the pointer to the message token is never */
/*             NULL.                                          */
/**************************************************************/

char * lookup_token(const char * s, unsigned int num_args, ...)
{
  char    * ret;
  va_list   ap;

  dprintf(("MsgT", "lookup_token: Called, exitting through lookup_in_given\n"));

  va_start(ap, num_args);
  ret = lookup_in_given(&meb, s, num_args, ap);
  va_end(ap);

  return ret;
}

/**************************************************************/
/* lookup_in_given()                                          */
/*                                                            */
/* Workhorse back-end to lookup_token, lookup_choice and      */
/* so-on. See lookup_token for more information.              */
/*                                                            */
/* Parameters: A MessagesFD pointer, giving the control block */
/*             of the file to look in;                        */
/*                                                            */
/*             Pointer to a message token;                    */
/*                                                            */
/*             Number of arguments that follow (0 to 4);      */
/*                                                            */
/*             A va_list built by va_start before calling,    */
/*             from a variable argument list.                 */
/*                                                            */
/* Returns:    Pointer to the full message text or '!' to     */
/*             signal an error; never a null pointer.         */
/*                                                            */
/* Assumes:    That the pointer to the message token is never */
/*             NULL.                                          */
/**************************************************************/

static char * lookup_in_given(MessagesFD * control, const char * s, unsigned int num_args, va_list ap)
{
  _kernel_oserror * e;
  char            * args[4];

  dprintf(("MsgT", "lookup_in_given: Lookup token '%s'\n",s));

  if (strcmp(lasttokn, (char *) s))
  {
    dprintf(("MsgT", "lookup_in_given: Proceeding\n"));

    StrNCpy0(lasttokn, (char *) s);

    args[0] = num_args > 0 ? va_arg(ap, char *) : 0;
    args[1] = num_args > 1 ? va_arg(ap, char *) : 0;
    args[2] = num_args > 2 ? va_arg(ap, char *) : 0;
    args[3] = num_args > 3 ? va_arg(ap, char *) : 0;

    e = _swix(MessageTrans_Lookup,
              _INR(0,7),

              control,            /* Pointer to control block               */
              s,                  /* String to look up                      */
              tokens,             /* Global buffer to take looked up string */
              sizeof(tokens) - 1, /* Size of the buffer                     */
              args[0],            /* Parameter 0                            */
              args[1],            /* Parameter 1                            */
              args[2],            /* Parameter 2                            */
              args[3]);           /* Parameter 3                            */

    tokens[Limits_Message - 1] = 0;

    if (e)
    {
      /* If the lookup fails, put '!' into the lookup buffer and report */
      /* the error directly.                                            */

      dprintf(("MsgT", "lookup_in_given: Failed\n"));

      *lasttokn = 0;
      strcpy(tokens, "!");

      errors_cont(e);
    }
  }

  dprintf(("MsgT", "lookup_in_given: Returning '%s'\n",tokens));

  return (char *) &tokens;
}

/**************************************************************/
/* report_toolbox_error()                                     */
/*                                                            */
/* If the toolbox generates an error this function will be    */
/* called to report it. Parameters are as standard for a      */
/* Toolbox event handler.                                     */
/**************************************************************/

int report_toolbox_error(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  ChkError((_kernel_oserror *) &event->data);

  return 1;
}

/**************************************************************/
/* register_null_claimant()                                   */
/*                                                            */
/* Call if you want to claim null polls.                      */
/*                                                            */
/* Parameters: As for a Wimp event handler, but without the   */
/*             object ID.                                     */
/**************************************************************/

void register_null_claimant(int eventcode, WimpEventHandler * handler, void * handle)
{
  null_counter++;
  ChkError(event_register_wimp_handler(-1,eventcode,handler,handle));

  #ifdef TRACE

    {
      int   shut_up_compiler = (int)   handler;
      int * function_name    = (int *) shut_up_compiler;

      dprintf(("Null", "register_null_claimant:   Registered a claimant for handle %p\n", handle));

      /* If the word before the function address has ff in the high */
      /* byte, the function name starts as many bytes before the    */
      /* function address as specified in the low 3 bytes.          */

      function_name -= 1;

      if (((*function_name) & 0xff000000) == 0xff000000)
      {
        dprintf(("Null", "                          Handler is '\0213%s\0217'\n", (char *) (((char *) function_name) - ((*function_name) & 0x00ffffff))));
      }
      else
      {
        dprintf(("Null", "                          Cannot find handler's name; address is \02130x%08x\0217\n", (int) handler));
      }
    }

  #endif

  if (null_counter == 1)
  {
    unsigned int mask;

    ChkError(event_get_mask(&mask));
    mask = (mask & (~Wimp_Poll_NullMask));
    ChkError(event_set_mask(mask));

    dprintf(("Null", "register_null_claimant:   \0211Nulls claimed\0217\n"));
  }
}

/**************************************************************/
/* deregister_null_claimant()                                 */
/*                                                            */
/* Call if you want to release null polls.                    */
/*                                                            */
/* Parameters: As for a Wimp event handler, but without the   */
/*             object ID.                                     */
/**************************************************************/

void deregister_null_claimant(int eventcode, WimpEventHandler * handler, void * handle)
{
  null_counter--;
  ChkError(event_deregister_wimp_handler(-1,eventcode,handler,handle));

  #ifdef TRACE

    {
      int   shut_up_compiler = (int)   handler;
      int * function_name    = (int *) shut_up_compiler;

      dprintf(("Null", "deregister_null_claimant: Deregistered a claimant for handle %p\n", handle));

      /* If the word before the function address has ff in the high */
      /* byte, the function name starts as many bytes before the    */
      /* function address as specified in the low 3 bytes.          */

      function_name -= 1;

      if (((*function_name) & 0xff000000) == 0xff000000)
      {
        dprintf(("Null", "                          Handler is '\0216%s\0217'\n", (char *) (((char *) function_name) - ((*function_name) & 0x00ffffff))));
      }
      else
      {
        dprintf(("Null", "                          Cannot find handler's name; address is \2160x%08x\0217\n", (int) handler));
      }
    }

  #endif

  if (null_counter < 0) null_counter = 0;

  if (!null_counter)
  {
    unsigned int mask;

    ChkError(event_get_mask(&mask));
    mask = (mask | Wimp_Poll_NullMask);
    ChkError(event_set_mask(mask));

    dprintf(("Null", "deregister_null_claimant: \0212Nulls released\0217\n"));
  }
}

/**************************************************************/
/* intersection()                                             */
/*                                                            */
/* Takes two BBoxes and returns a pointer to a third which is */
/* the the intersection between the first two, or NULL, if    */
/* they don't intersect.                                      */
/*                                                            */
/* Parameters: Pointer to a BBox;                             */
/*                                                            */
/*             Pointer to another BBox.                       */
/*                                                            */
/* Returns:    Pointer to a BBox which is the intersection of */
/*             the given two, or NULL, if they don't          */
/*             intersect.                                     */
/**************************************************************/

BBox * intersection(BBox * a, BBox * b)
{
  static BBox intersect;

  #define max(a,b) ((a) > (b) ? (a) : (b))
  #define min(a,b) ((a) < (b) ? (a) : (b))

  if (!a || !b) return NULL;

  if ((a->xmin >= b->xmax) || (a->xmax <= b->xmin) || (a->ymin >= b->ymax) || (a->ymax <= b->ymin)) return NULL;

  intersect.xmin = max(a->xmin,b->xmin);
  intersect.xmax = min(a->xmax,b->xmax);
  intersect.ymin = max(a->ymin,b->ymin);
  intersect.ymax = min(a->ymax,b->ymax);

  return &intersect;
}

/**************************************************************/
/* set_graphics_intersection()                                */
/*                                                            */
/* Intended for redraw loop routines, this sets up a given    */
/* graphics rectangle, but takes account of the intersection  */
/* between this and the current (given) graphics rectangle    */
/* for the redraw. The rectangle *must* be restored with      */
/* restore_graphics_intersection() as soon as the rectangle   */
/* set here is finished with; the caller must thus remember   */
/* this rectangle for later.                                  */
/*                                                            */
/* Parameters: Pointer to a BBox describing the rectangle to  */
/*             set, where xmax and ymax are inclusive;        */
/*                                                            */
/*             Pointer to a BBox describing the current       */
/*             graphics rectangle, where xmax and ymax are    */
/*             exclusive (e.g. as in a                        */
/*             WimpRedrawWindowBlock's redraw_area BBox).     */
/*                                                            */
/* Returns:    Pointer to a BBox describing the actual        */
/*             rectangle that was set. If this is NULL, the   */
/*             two do not intersect at all and the redraw     */
/*             subsequent graphics window restoration can and */
/*             should be skipped.                             */
/**************************************************************/

BBox * set_graphics_intersection(BBox * rbox, BBox * cbox)
{
  BBox * ibox;
  BBox   ogrect = *cbox;

  ogrect.xmax -= 1;
  ogrect.ymax -= 1;

  ibox = intersection(rbox, &ogrect);

  if (!ibox) return NULL;

  bbc_gwindow(ibox->xmin, ibox->ymin, ibox->xmax, ibox->ymax);

  return ibox;
}

/**************************************************************/
/* restore_graphics_intersection()                            */
/*                                                            */
/* Restores the Wimp's redraw graphics rectangle which was    */
/* changed by a call to set_graphics_intersection (which      */
/* *must* have been called before this restoring function).   */
/*                                                            */
/* Parameters: Pointer to a BBox holding the graphics         */
/*             rectangle as it was before                     */
/*             set_graphics_intersection was called, where    */
/*             xmax and ymax are exclusive (e.g. as in a      */
/*             WimpRedrawWindowBlock's redraw_area BBox).     */
/**************************************************************/

void restore_graphics_intersection(BBox * cbox)
{
  BBox ogrect = *cbox;

  ogrect.xmax -= 1;
  ogrect.ymax -= 1;

  bbc_gwindow(ogrect.xmin, ogrect.ymin, ogrect.xmax, ogrect.ymax);
}

/**************************************************************/
/* read_os_to_points()                                        */
/*                                                            */
/* To avoid having to use a SWI every time a conversion is    */
/* made between OS units and points or vice versa, this       */
/* initialises some internal variables which are used         */
/* subsequently. It may be called on a mode change, for       */
/* example, to ensure things are up to date.                  */
/*                                                            */
/* If printing, values of MillipointsPerOSUnit as defined at  */
/* the top of this file are used, since you can't read it; it */
/* seems that during a print job, this call may *not* be      */
/* used, contrary to the information on PRM 3-573. This bug   */
/* caused *severe* grief during the development of the print  */
/* routines...                                                */
/**************************************************************/

void read_os_to_points(void)
{
  int x = 1, y = 1;

  if (!printing)
  {
    if (
          _swix(Font_Converttopoints,
                _INR(1,2) | _OUTR(1,2),

                x,
                y,

                &x,
                &y)
       )
    {
      millipoints_per_os_unit_x = MillipointsPerOSUnit;
      millipoints_per_os_unit_y = MillipointsPerOSUnit;
    }
    else
    {
      millipoints_per_os_unit_x = x;
      millipoints_per_os_unit_y = y;
    }
  }
  else
  {
    millipoints_per_os_unit_x = MillipointsPerOSUnit;
    millipoints_per_os_unit_y = MillipointsPerOSUnit;
  }

  overflow_limit_x = (0x3fffffff / millipoints_per_os_unit_x) - 1;
  overflow_limit_y = (0x3fffffff / millipoints_per_os_unit_y) - 1;

  half_mppou_x = millipoints_per_os_unit_x / 2;
  half_mppou_y = millipoints_per_os_unit_y / 2;
}

/**************************************************************/
/* convert_pair_to_os()                                       */
/*                                                            */
/* Converts from millipoints to OS units. The scale factor is */
/* determined by a previous call to read_os_to_points.        */
/*                                                            */
/* Parameters: A coordinate in millipoints;                   */
/*                                                            */
/*             Another coord in millipoints;                  */
/*                                                            */
/*             Pointer to an int into which the first         */
/*             coordinate, converted to OS units, is placed;  */
/*                                                            */
/*             Similarly a pointer to an int for the second   */
/*             coordinate.                                    */
/*                                                            */
/* Assumes:    The pointers may NOT be NULL. The input and    */
/*             output variables may be the same (so passing   */
/*             in x, y, &x, &y would work correctly).         */
/**************************************************************/

void convert_pair_to_os(int x, int y, int * osx, int * osy)
{
  *osx = ((x + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
  *osy = ((y + half_mppou_y) / millipoints_per_os_unit_y) & ~(wimpt_dy() - 1);
}

/**************************************************************/
/* convert_pair_to_points()                                   */
/*                                                            */
/* Converts from OS units to millipoints. The scale factor is */
/* determined by a previous call to read_os_to_points.        */
/*                                                            */
/* Parameters: A coordinate in OS units;                      */
/*                                                            */
/*             Another coordinate in OS units;                */
/*                                                            */
/*             Pointer to an int into which the first         */
/*             coordinate, converted to millipoints, is       */
/*             placed;                                        */
/*                                                            */
/*             Similarly a pointer to an int for the second   */
/*             coordinate.                                    */
/*                                                            */
/* Assumes:    The pointers may not be NULL. The input and    */
/*             output variables may be the same (so passing   */
/*             in x, y, &x, &y would work correctly).         */
/**************************************************************/

void convert_pair_to_points(int x, int y, int * mpx, int * mpy)
{
  #ifdef TRACE

    if (abs(x) > overflow_limit_x || abs(y) > overflow_limit_y)
    {
      erb.errnum = Errors_Custom_Normal;
      sprintf(erb.errmess,
              "convert_pair_to_points: Can't convert (%d, %d) to millipoints without overflow.",
              x,y);

      errors_ret(&erb);

      *mpx = *mpy = 0;

      return;
    }

  #endif

  *mpx = x * millipoints_per_os_unit_x;
  *mpy = y * millipoints_per_os_unit_y;
}

/**************************************************************/
/* convert_to_os()                                            */
/*                                                            */
/* As convert_pair_to_os, but only converts one coordinate at */
/* a time.                                                    */
/*                                                            */
/* Parameters: An x coordinate in millipoints;                */
/*                                                            */
/*             Pointer to an int into which the coordinate,   */
/*             converted to OS units, is placed.              */
/*                                                            */
/* Assumes:    That the pointer is not NULL. The input and    */
/*             output variable may be the same (so passing in */
/*             x, &x would work correctly);                   */
/*                                                            */
/*             If x and y scalings differ, this will only     */
/*             ever use the x scaling.                        */
/**************************************************************/

void convert_to_os(int x, int * osx)
{
  *osx = ((x + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
}

/**************************************************************/
/* convert_to_points()                                        */
/*                                                            */
/* As convert_pair_to_points, but only converts one           */
/* coordinate at a time.                                      */
/*                                                            */
/* Parameters: An x coordinate in OS units;                   */
/*                                                            */
/*             Pointer to an int into which the coordinate,   */
/*             converted to milli- points, is placed.         */
/*                                                            */
/* Assumes:    That the pointer is not NULL. The input and    */
/*             output variable may be the same (so passing in */
/*             x, &x would work correctly);                   */
/*                                                            */
/*             If x and y scalings differ, this will only     */
/*             ever use the x scaling.                        */
/**************************************************************/

void convert_to_points(int x, int * mpx)
{
  #ifdef TRACE

    if (abs(x) > overflow_limit_x)
    {
      erb.errnum = Errors_Custom_Normal;
      sprintf(erb.errmess,
              "convert_to_points: Can't convert '%d' to millipoints without overflow.",
              x);

      errors_ret(&erb);

      *mpx = 0;

      return;
    }

  #endif

  *mpx = x * millipoints_per_os_unit_x;
}

/**************************************************************/
/* convert_box_to_os()                                        */
/*                                                            */
/* As convert_pair_to_os, but converts the four coordinates   */
/* inside a BBox in one go.                                   */
/*                                                            */
/* Parameters: Pointer to a BBox containing coords in         */
/*             millipoints;                                   */
/*                                                            */
/*             Pointer to a BBox into which the first box's   */
/*             coords, converted to OS units, are placed.     */
/*                                                            */
/* Assumes:    That neither pointer is NULL. The two pointers */
/*             may be the same (so passing in &box, &box      */
/*             would work correctly).                         */
/**************************************************************/

void convert_box_to_os(const BBox * mp, BBox * os)
{
  os->xmin = ((mp->xmin + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
  os->ymin = ((mp->ymin + half_mppou_y) / millipoints_per_os_unit_y) & ~(wimpt_dy() - 1);
  os->xmax = ((mp->xmax + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
  os->ymax = ((mp->ymax + half_mppou_y) / millipoints_per_os_unit_y) & ~(wimpt_dy() - 1);
}

/**************************************************************/
/* convert_box_to_points()                                    */
/*                                                            */
/* As convert_pair_to_points, but converts the four           */
/* coordinates inside a BBox in one go.                       */
/*                                                            */
/* Parameters: Pointer to a BBox containing coords in OS      */
/*             units;                                         */
/*                                                            */
/*             Pointer to a BBox into which the first box's   */
/*             coords, converted to millipoints, are placed.  */
/*                                                            */
/* Assumes:    That neither pointer is NULL. The two pointers */
/*             may be the same (so passing in &box, &box      */
/*             would work correctly).                         */
/**************************************************************/

void convert_box_to_points(const BBox * os, BBox * mp)
{
  #ifdef TRACE

    if (
         abs(os->xmin) > overflow_limit_x ||
         abs(os->ymin) > overflow_limit_y ||
         abs(os->xmax) > overflow_limit_x ||
         abs(os->ymax) > overflow_limit_y
       )
    {
      erb.errnum = Errors_Custom_Normal;
      sprintf(erb.errmess,
              "convert_box_to_points: Can't convert (%d, %d, %d, %d) to millipoints without overflow.",
              os->xmin,
              os->ymin,
              os->xmax,
              os->ymax);

      errors_ret(&erb);

      mp->xmin = mp->ymin = 0;
      mp->xmax = mp->ymax = 0;

      return;
    }

  #endif

  mp->xmin = os->xmin * millipoints_per_os_unit_x;
  mp->ymin = os->ymin * millipoints_per_os_unit_y;
  mp->xmax = os->xmax * millipoints_per_os_unit_x;
  mp->ymax = os->ymax * millipoints_per_os_unit_y;
}

/**************************************************************/
/* read_sprite_size()                                         */
/*                                                            */
/* Finds out the size of a given sprite in the application's  */
/* sprite pool in OS units.                                   */
/*                                                            */
/* Parameters: Pointer to the sprite name;                    */
/*                                                            */
/*             Pointer to int into which the sprite's width   */
/*             is returned;                                   */
/*                                                            */
/*             Pointer to int into which the sprite's height  */
/*             is returned.                                   */
/*                                                            */
/* Assumes:    The name pointer is not NULL, but either of    */
/*             the two int pointers may be.                   */
/**************************************************************/

_kernel_oserror * read_sprite_size(char * name, int * width, int * height)
{
  unsigned int      w, h, m;
  _kernel_oserror * e;

  e = _swix(OS_SpriteOp,
            _INR(0,2) | _OUTR(3,4) | _OUT(6),

            0x128,
            sprite_block,
            name,

            &w,
            &h,
            &m);

  if (e) return e;

  w = w << bbc_modevar(m, BBC_XEigFactor);
  h = h << bbc_modevar(m, BBC_YEigFactor);

  if (width)  *width  = (int) w;
  if (height) *height = (int) h;

  return NULL;
}

/**************************************************************/
/* utils_text_width()                                         */
/*                                                            */
/* Returns the width of a given piece of text, in OS units,   */
/* if it were to be plotted in the Desktop. Wimp_TextOp is    */
/* used if available, else the width and spacing of the       */
/* bitmap font is read and the width is calculated from this  */
/* instead.                                                   */
/*                                                            */
/* Parameters: Pointer to the text;                           */
/*                                                            */
/*             Pointer to an int, into which the width is     */
/*             written;                                       */
/*                                                            */
/*             0 to work out the whole string width, or the   */
/*             number of chars to read.                       */
/*                                                            */
/* Assumes:    Either pointer may be NULL;                    */
/*                                                            */
/*             If the number of chars to read is greater than */
/*             the string length, the value given is ignored  */
/*             and the string length used instead.            */
/**************************************************************/

_kernel_oserror * utils_text_width(char * text, int * width, int scan)
{
  int cwidth, cspacing;
  int len;

  /* Return if there's no text or 'width' is NULL */

  if (!width) return NULL;

  if (!text || !*text)
  {
    *width = 0;
    return NULL;
  }

  /* Otherwise, set 'len' either to the string length, */
  /* if 'scan' is zero, or to the value of 'scan'.     */

  len = strlen(text);
  if (scan && scan < len) len = scan;

  /* Rather than try mucking about guessing what version number of */
  /* Wimp supports Wimp_TextOp, simply use the alternative method  */
  /* if the SWI raises an error.                                   */

  if (
       _swix(Wimp_TextOp,
             _INR(0,2) | _OUT(0),

             1,
             text,
             len,

             width)
     )
  {
    /* Find out the spacing (start of one char to start of next) */
    /* and width of the text the Wimp is using, assuming that if */
    /* there is no nested wimp, Wimp_TextOp is unavailable.      */

    int vars[3] = {
                    BBC_GCharSizeX,
                    BBC_GCharSpaceX,
                    -1
                  };

    RetError(bbc_vduvars(vars, vars));

    cwidth   = vars[0];
    cspacing = vars[1];

    /* cspacing gives how much to increment x by after plotting a   */
    /* character, and therefore includes cwidth; so to find the     */
    /* width, we'd use (len * cspacing) - (cspacing - cwidth),      */
    /* which simplifies to the below (plus conversion to OS units). */

    *width = ((len - 1) * cspacing + cwidth) * wimpt_dx();
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* set_gadget_state()                                         */
/*                                                            */
/* Greys or ungreys a gadget, only changing its state to      */
/* avoid flicker.                                             */
/*                                                            */
/* Parameters: Object ID the gadget resides in;               */
/*                                                            */
/*             Component ID of the gadget;                    */
/*                                                            */
/*             1 to grey, 0 to ungrey.                        */
/**************************************************************/

_kernel_oserror * set_gadget_state(ObjectId o, ComponentId c, int grey_state)
{
  _kernel_oserror * e;
  unsigned int      flags;

  e = gadget_get_flags(0, o, c, &flags);
  if (e) return e;

  /* Only change state, to avoid flicker. */

  if (!!grey_state != !!(flags & Gadget_Faded))
  {
    if (grey_state) flags |=  Gadget_Faded;
    else            flags &= ~Gadget_Faded;

    return gadget_set_flags(0, o, c, flags);
  }

  return NULL;
}

/**************************************************************/
/* utils_set_display_field()                                  */
/*                                                            */
/* Update a display field with the given text, if the text    */
/* isn't the same as whatever is already being displayed.     */
/*                                                            */
/* Parameters: Object ID the gadget lies in;                  */
/*                                                            */
/*             Component ID of the gadget;                    */
/*                                                            */
/*             Text to set;                                   */
/*                                                            */
/*             Maximum length of text the item can take,      */
/*             including terminator (used for the buffer to   */
/*             take the current text; if too short or the     */
/*             new text is longer than the gadget can take,   */
/*             an error will be returned).                    */
/**************************************************************/

_kernel_oserror * utils_set_display_field(ObjectId o, ComponentId c, const char * text, size_t maxlen)
{
  char * current = malloc(maxlen);
  int    match;

  if (current == NULL) return errors_frontend_error(fee_out_of_memory,
                                                    "4");

  /* Read the existant text */

  RetError(displayfield_get_value(0,
                                  o,
                                  c,
                                  current,
                                  maxlen,
                                  NULL));

  current[maxlen - 1] = '\0';

  /* Check if it matches and free the temporary buffer */

  match = strcmp(text, current);

  free(current);

  /* Exit by setting the new text if there was a difference */

  if (match != NULL)
  {
    return displayfield_set_value(0,
                                  o,
                                  c,
                                  (char *) text);
  }
  else
  {
    return NULL;
  }
}

/**************************************************************/
/* utils_set_writeable_field()                                */
/*                                                            */
/* Update a writeable field with the given text, if the text  */
/* isn't the same as whatever is already being writeableed.   */
/*                                                            */
/* Parameters: Object ID the gadget lies in;                  */
/*                                                            */
/*             Component ID of the gadget;                    */
/*                                                            */
/*             Text to set;                                   */
/*                                                            */
/*             Maximum length of text the item can take,      */
/*             including terminator (used for the buffer to   */
/*             take the current text; if too short or the     */
/*             new text is longer than the gadget can take,   */
/*             an error will be returned).                    */
/**************************************************************/

_kernel_oserror * utils_set_writeable_field(ObjectId o, ComponentId c, const char * text, size_t maxlen)
{
  char * current = malloc(maxlen);
  int    match;

  if (current == NULL) return errors_frontend_error(fee_out_of_memory,
                                                    "5");

  /* Read the existant text */

  RetError(writablefield_get_value(0,
                                   o,
                                   c,
                                   current,
                                   maxlen,
                                   NULL));

  current[maxlen - 1] = '\0';

  /* Check if it matches and free the temporary buffer */

  match = strcmp(text, current);

  free(current);

  /* Exit by setting the new text if there was a difference */

  if (match != NULL)
  {
    return writablefield_set_value(0,
                                   o,
                                   c,
                                   (char *) text);
  }
  else
  {
    return NULL;
  }
}

/**************************************************************/
/* utils_increment_usage()                                    */
/*                                                            */
/* Given an object name, find out if it is shared. If so,     */
/* call toolbox_create_object on it, discarding the returned  */
/* object ID, just to ensure that the usage count is          */
/* permanently at least 1 - thus the object will never be     */
/* automatically deleted.                                     */
/*                                                            */
/* Code should really try to avoid relying on the item never  */
/* being deleted just in case; this should only really be     */
/* done because of an efficiency improvement (e.g. building a */
/* complex menu on the fly from a template object in the Res  */
/* file as infrequently as possible).                         */
/*                                                            */
/* Parameters: Pointer to the object name to work with.       */
/**************************************************************/

_kernel_oserror * utils_increment_usage(const char * object_name)
{
  ObjectTemplateHeader * tmplt;

  RetError(toolbox_template_lookup(0,
                                   (char *) object_name, /* Sigh. Wonderfully well typed, these interfaces. */
                                   (void **) &tmplt));

  if ((tmplt->flags & Object_Shared) != 0)
  {
    RetError(toolbox_create_object(0,
                                   (char *) object_name,
                                   NULL)); /* Don't care about the ID, just want the usage count up */
  }

  return NULL;
}

/**************************************************************/
/* adjust()                                                   */
/*                                                            */
/* Returns 1 if Wimp_GetPointerInfo says that Adjust is being */
/* pressed, else 0.                                           */
/**************************************************************/

int adjust(void)
{
  WimpGetPointerInfoBlock info;

  wimp_get_pointer_info(&info);

  return !!(info.button_state & Wimp_MouseButtonAdjust);
}

/**************************************************************/
/* debounce_keypress()                                        */
/*                                                            */
/* For some key presses (e.g. function keys), it is not       */
/* desirable to let the key autorepeat. This function sits in */
/* a tight loop waiting for all keys to be released before    */
/* exitting.                                                  */
/*                                                            */
/* Returns: 1 if a key was being pressed and the function     */
/* waited for its release, else 0.                            */
/**************************************************************/

int debounce_keypress(void)
{
  int               key, waited = 0;
  _kernel_oserror * e;

  do
  {
    e = _swix(OS_Byte,
              _INR(0,1) | _OUT(1),

              121, /* Keyboard scan */
              0,   /* Scan all keys */

              &key);

    if (key != 255) waited = 1;
  }
  while (!e && key != 255);

  if (waited) _swix(OS_Byte, _INR(0,1), 21, 0); /* Flush keyboard buffer */

  return waited;
}

/**************************************************************/
/* utils_check_caret_restoration()                            */
/*                                                            */
/* Checks to see if the given dialogue has the caret, and if  */
/* it has a parent. If so, it'll return the Object ID of that */
/* parent, else NULL_ObjectId is written.                     */
/*                                                            */
/* Parameters: The Object ID of the dialogue to check.        */
/**************************************************************/

ObjectId utils_check_caret_restoration(ObjectId window_id)
{
  WimpGetCaretPositionBlock   caret_b;
  int                         caret_w;
  ObjectId                    parent = NULL_ObjectId;
  _kernel_oserror           * e      = NULL;

  /* Do we have the input focus? */

  e = wimp_get_caret_position(&caret_b);

  if (!e)
  {
    e = window_get_wimp_handle(0,
                               window_id,
                               &caret_w);

    if (!e)
    {
      if (caret_w == caret_b.window_handle)
      {
        /* Yes, we have the caret. So move it back to the Print */
        /* dialogue - well, this object's parent, anyway.       */

        e = toolbox_get_parent(0,
                               window_id,
                               &parent,
                               NULL);

        if (e) parent = NULL_ObjectId;

        else if (parent == NULL_ObjectId)
        {
          /* Maybe there's an ancestor? (E.g. PrintDBox using an  */
          /* alternate window -> doesn't pass Parent info through */
          /* so we need the ancestor instead... sigh).            */

          e = toolbox_get_ancestor(0,
                                   window_id,
                                   &parent,
                                   NULL);

          if (e) parent = NULL_ObjectId;
        }
      }
    }
  }

  /* Finished */

  return parent;
}

/**************************************************************/
/* utils_restore_focus()                                      */
/*                                                            */
/* If the given dialogue has the caret, put the caret into    */
/* the parent of this object, in the default input focus      */
/* position.                                                  */
/*                                                            */
/* Parameters: The Object ID of the dialogue whos parent is   */
/*             to gain the caret.                             */
/*                                                            */
/* Assumes:    The parent has a default caret position set    */
/*             up; the parent exists (the function is fairly  */
/*             pedantic about returning any errors it gets    */
/*             from external calls it makes).                 */
/**************************************************************/

_kernel_oserror * utils_restore_focus(ObjectId window_id)
{
  _kernel_oserror           * e = NULL;
  ObjectId                    parent;
  ComponentId                 focus_c;

  /* Do we have the input focus and a parent? */

  parent = utils_check_caret_restoration(window_id);

  if (parent != NULL_ObjectId)
  {
    /* Find the default caret position of the parent */

    e = window_get_default_focus(0,
                                 parent,
                                 &focus_c); /* Nasty interface; it's not really a component ID. It's -1 for no focus, -2 for "in window", else a component ID */

    /* Set the focus there */

    if (!e)
    {
      if (focus_c != -1 && focus_c != -2)
      {
        e = gadget_set_focus(0,
                             parent,
                             focus_c);
      }
      else if (focus_c == -2)
      {
        int handle;

        e = window_get_wimp_handle(0, parent, &handle);
        if (!e) e = wimp_set_caret_position(handle, -1, 0, 0, 0, 0);
      }
    }
  }

  /* Finished */

  return e;
}

/**************************************************************/
/* utils_place_focus()                                        */
/*                                                            */
/* If a given object has input focus, place the caret in the  */
/* specified writeable item.                                  */
/*                                                            */
/* Parameters: Object ID of the relevant window;              */
/*                                                            */
/*             Component ID to move the caret to, if the      */
/*             window has focus already, or NULL_ComponentId  */
/*             to give general focus.                         */
/**************************************************************/

_kernel_oserror * utils_place_focus(ObjectId window_id, ComponentId c)
{
  WimpGetCaretPositionBlock caret_b;
  int                       handle;

  RetError(window_get_wimp_handle(0, window_id, &handle));
  RetError(wimp_get_caret_position(&caret_b));

  if (caret_b.window_handle == handle)
  {
    if (c != NULL_ComponentId) return gadget_set_focus(0, window_id, c);
    else                       return wimp_set_caret_position(handle, -1, 0, 0, -1, -1);
  }
  else return NULL;
}

/**************************************************************/
/* task_from_window()                                         */
/*                                                            */
/* Returns the task handle of the owner of a given window.    */
/*                                                            */
/* Parameters: A window handle.                               */
/*                                                            */
/* Returns:    Task handle of the window owner.               */
/**************************************************************/

int task_from_window (int window_handle)
{
  WimpMessage  m;
  int          handle;

  m.hdr.size        = 20;
  m.hdr.your_ref    = 0;
  m.hdr.action_code = 0;

  if (
       wimp_send_message(Wimp_EUserMessageAcknowledge,
                         &m,
                         window_handle,
                         0,
                         &handle)
     )
     return 0;

  return handle;
}

/**************************************************************/
/* utils_strcasecmp()                                         */
/*                                                            */
/* Function to compare two strings case insensitively.        */
/*                                                            */
/* Originally by S.Brodie.                                    */
/*                                                            */
/* The conversions to unsigned int stop the compiler messing  */
/* around with shifts all over the place whilst trying to     */
/* promote the chars to int whilst retaining the sign.        */
/*                                                            */
/* Problems: Choice of return value when strings do not match */
/* is based upon character number rather than any alphabetic  */
/* sorting.                                                   */
/*                                                            */
/* Parameters: As strcmp.                                     */
/*                                                            */
/* Returns:    As strcmp.                                     */
/**************************************************************/

int utils_strcasecmp(const char *a, const char *b)
{
  for (;;)
  {
    unsigned int f1 = *a++;
    unsigned int s1 = *b++;

    if (f1 == 0) return -s1;

    if (f1 != s1)
    {
      unsigned int f2     = (unsigned int) tolower(f1);
      unsigned int s2     = (unsigned int) tolower(s1);
      signed int   result = f2 - s2;

      if (result != 0) return result;
    }
  }
}

/**************************************************************/
/* utils_strncasecmp()                                        */
/*                                                            */
/* Function to compare two strings case insensitively up to a */
/* maximum char count.                                        */
/*                                                            */
/* Originally by S.Brodie.                                    */
/*                                                            */
/* The conversions to unsigned int stop the compiler messing  */
/* around with shifts all over the place whilst trying to     */
/* promote the chars to int whilst retaining the sign.        */
/*                                                            */
/* Problems: Choice of return value when strings do not match */
/* is based upon character number rather than any alphabetic  */
/* sorting.                                                   */
/*                                                            */
/* Parameters: As strncmp.                                    */
/*                                                            */
/* Returns:    As strncmp.                                    */
/**************************************************************/

int utils_strncasecmp(const char * a, const char * b, unsigned int n)
{
  for (; n; --n)
  {
    unsigned int f1 = *a++;
    unsigned int s1 = *b++;

    if (f1 == 0) return -s1;

    if (f1 != s1)
    {
      unsigned int f2     = (unsigned int) tolower(f1);
      unsigned int s2     = (unsigned int) tolower(s1);
      signed int   result = f2 - s2;

      if (result != 0) return result;
    }
  }

  return 0;
}

/**************************************************************/
/* utils_strcasestr()                                         */
/*                                                            */
/* Same as standard C library 'strstr', but works case        */
/* insensitively.                                             */
/*                                                            */
/* Parameters: As strstr.                                     */
/*                                                            */
/* Returns:    As strstr.                                     */
/**************************************************************/

char * utils_strcasestr(const char * a, const char * b)
{
  int i;

  for (;;)
  {
    for (i=0;; i++)
    {
      char ch = tolower(b[i]);

      if (ch == 0) return (char *) a;
      if (tolower(a[i]) != ch) break;
    }

    if (*a++ == 0) return 0;
  }
}

/**************************************************************/
/* utils_strdup()                                             */
/*                                                            */
/* Returns a pointer to a malloc'd copy of the given string.  */
/*                                                            */
/* Parameters: Pointer to the string to copy.                 */
/*                                                            */
/* Returns:    Pointer to a malloc'd copy of the given        */
/*             string.                                        */
/*                                                            */
/* Assumes:    Returns NULL if it gets NULL or if memory      */
/*             allocation fails.                              */
/**************************************************************/

char * utils_strdup(const char * s1)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = (char *) malloc(strlen(s1) + 1);

  if (s2 == NULL) return NULL;

  return strcpy(s2, s1);
}

/**************************************************************/
/* utils_strndup()                                            */
/*                                                            */
/* Returns a pointer to a malloc'd copy of the given string,  */
/* copying only as many characters as asked for. The result   */
/* is zero terminated.                                        */
/*                                                            */
/* Parameters: Pointer to the string to copy;                 */
/*                                                            */
/*             Maximum number of characters to copy.          */
/*                                                            */
/* Returns:    Pointer to a malloc'd copy of the given        */
/*             string (always zero terminated).               */
/*                                                            */
/* Assumes:    Returns NULL if it gets NULL or if memory      */
/*             allocation fails. The length of the source     */
/*             string must be greater than or equal to the    */
/*             number of characters to copy.                  */
/**************************************************************/

char * utils_strndup(const char * s1, size_t size)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = malloc(size + 1); /* +1 so we can force a zero terminator */
  if (s2 == NULL) return NULL;

  s2[size] = '\0';
  return memcpy(s2,s1,size);
}

/**************************************************************/
/* utils_get_task_handle()                                    */
/*                                                            */
/* Returns the task handle of the given task (name comparison */
/* is case insensitive).                                      */
/*                                                            */
/* Parameters: Pointer to a null-terminated task name;        */
/*                                                            */
/*             Pointer to an unsigned int, in which the task  */
/*             handle is written, or 0 if the task is not     */
/*             found.                                         */
/*                                                            */
/* Assumes:    Neither pointer may be NULL.                   */
/**************************************************************/

_kernel_oserror * utils_get_task_handle(const char * task_to_get, unsigned int * found_handle)
{
  _kernel_oserror * e;
  char            * c;
  int             * p;
  int               buffer  [32];
  char              taskname[Limits_TaskName];
  int             * notused;
  int               t;
  int               len    = strlen(task_to_get);
  int               next   = 0;
  unsigned int      handle = 0;

  do
  {
    e = _swix(TaskManager_EnumerateTasks,
              _INR(0,2) | _OUTR(0,1),

              next,
              buffer,
              sizeof(buffer),

              &next,
              &notused);

    if (e) return e;

    /* Go through as much of the buffer as the call said it used */

    for (p = buffer; p < notused && handle == 0; p += 4)
    {
      c = (char *) p[1];
      t = 0;

      memset(taskname, 0, sizeof(taskname));
      while (*c > 31 && t < sizeof(taskname) - 1) taskname[t++] = *c++;

      if (!utils_strncasecmp(taskname, task_to_get, len)) handle = p[0];
    }
  }
  while (next >= 0 && handle == 0);

  /* Return the handle */

  *found_handle = handle;

  return NULL;
}

/**************************************************************/
/* utils_canonicalise_path()                                  */
/*                                                            */
/* Take some pathname (which may include a path or other      */
/* general system variable) and expand (or canonicalise) it.  */
/*                                                            */
/* Caller is responsible for calling free() on the returned   */
/* block.                                                     */
/*                                                            */
/* Parameters: Pointer to the path to canonicalise;           */
/*                                                            */
/*             Pointer to a char *, which will be filled in   */
/*             with the address of a malloced block - the     */
/*             caller is responsible for freeing it.          */
/*                                                            */
/* Returns:    If there is an error, it returns it, but it    */
/*             may return NULL and also return NULL as the    */
/*             pointer to the malloced block if some other    */
/*             internal failure occurred.                     */
/**************************************************************/

_kernel_oserror * utils_canonicalise_path(const char * in, char ** out)
{
  int required;

  if (!in || !*in || !out) return NULL;

  RetError(_swix(OS_FSControl,
                 _INR(0, 5) | _OUT(5),

                 37,   in,
                 NULL, NULL,
                 NULL, 0,

                 &required)); /* Path length not including terminator returned as MINUS r5 */

  *out = malloc(1 - required); /* (Yes, '1 - required' - see above!) */

  if (!*out) return errors_frontend_error(fee_out_of_memory,
                                          "6");

  RetError(_swix(OS_FSControl,
                 _INR(0, 5) | _OUT(5),

                 37,   in,
                 *out, NULL,
                 NULL, 1 - required,

                 &required));

  /* Er, 'something' went wrong... PRMs say to check, but not what to */
  /* do if you don't get 1 back here and haven't had an error from    */
  /* the SWI call!                                                    */

  if (required != 1)
  {
    free (*out);
    *out = NULL;
  }

  return NULL;
}

/**************************************************************/
/* utils_build_tree()                                         */
/*                                                            */
/* Takes a fully canonicalised pathname and ensures that all  */
/* the directories in the path exist. This is useful if you   */
/* are going to save something to a temporary directory in    */
/* Scrap or somewhere in <Choices$Write>, say, and need to    */
/* ensure that the directory structure you're addressing is   */
/* present.                                                   */
/*                                                            */
/* All items are given attributes "LWR/" on creation.         */
/*                                                            */
/* Parameters: Pointer to the path to ensure is present;      */
/*                                                            */
/*             true to include all items, i.e. the leafname   */
/*             item is a directory too.                       */
/**************************************************************/

_kernel_oserror * utils_build_tree(const char * path, bool include_all)
{
  char * temp;
  char * p;
  int    level, len;

  /* Sanity check, and take a local copy of the path */

  if (!path || !*path) return NULL;

  len  = strlen(path);
  temp = malloc(len + 1);

  if (!temp) return errors_frontend_error(fee_out_of_memory,
                                          "7");

retry:

  level = 0;
  strcpy(temp, path);

  /* Create the directories */

  do
  {
    p = strrchr(temp, '.');

    if (p)
    {
      *p = '\0';

      if (
           !_swix(OS_File,
                  _INR(0,1) | _IN(4),

                  8,  /* Create directory */
                  temp,
                  0)
           &&

           !_swix(OS_File,
                  _INR(0,1) | _IN(5),

                  4,  /* Set attributes */
                  temp,
                  11) /* Bit pattern -> "LWR/" */
         )
      {



        if (level) goto retry;
        else       break;
      }
    }

    level++;
  }
  while (p);

  /* Top level item */

  if (include_all)
  {
    _swix(OS_File,
          _INR(0,1) | _IN(4),

          8,
          path,
          0);

    _swix(OS_File,
          _INR(0,1) | _IN(5),

          4,
          path,
          11);
  }

  /* Finished */

  free(temp);

  return NULL;
}

/**************************************************************/
/* utils_get_unique_name()                                    */
/*                                                            */
/* Generates a unique pathname in the given buffer, based on  */
/* Wimp$ScrapDir. This is hopefully system-unique as the      */
/* function keeps going until it can't find a file under the  */
/* name it has constructed.                                   */
/*                                                            */
/* In the extremely unlikely event there are directories      */
/* named "UTF00000" to "UTFFFFFF" inclusive in Scrap, the     */
/* function bails, writing a single NUL byte into the start   */
/* of the buffer to indicate the problem (well - the last     */
/* directory is actually defined by MaximumUniqueNames at the */
/* top of the file).                                          */
/*                                                            */
/* If the way the names returned are generated is altered,    */
/* utils_find_archive must be updated too.                    */
/*                                                            */
/* Parameters: Pointer to the buffer;                         */
/*                                                            */
/*             Size of the buffer.                            */
/*                                                            */
/* Assumes:    Well it won't crash if you give it a NULL      */
/*             buffer pointer or a buffer size of less than 2 */
/*             bytes, but there's not exactly a huge amount   */
/*             of worth in calling the function under those   */
/*             conditions!                                    */
/**************************************************************/

void utils_get_unique_name(char * buffer, int buffer_size)
{
  int    filecount = 0;
  int    type;
  char * leaf;

  if (!buffer || buffer_size < 2) return;

  /* Clear the buffer first */

  memset(buffer, 0, buffer_size);

  /* Write '<Wimp$ScrapDir>.' (or whatever is defined above) to */
  /* the buffer - +9 is 8 letters for the leafname (see code    */
  /* below) plus 1 for a terminator.                            */

  if (strlen(Utils_ScrapPath) + 9 <= buffer_size) strcpy(buffer, Utils_ScrapPath);
  else return;

  /* Append with a unique 8 letter leafname */

  leaf = buffer + strlen(buffer);

  do
  {
    sprintf(leaf, Utils_UDPrefix "%05x", filecount++);

    /* Can we find the file? */

    type = 1;

    _swix(OS_File,
          _INR(0,1) | _OUT(0),

          17, /* Read catalogue info for object */
          buffer,

          &type);

    /* Keep going until we run out of files (!) or find an unused name */
  }
  while (type != 0 && filecount <= MaximumUniqueNames);

  /* Woo - did we run out? */

  if (filecount > MaximumUniqueNames)
  {
    *buffer = 0;
    return;
  }

  /* Finished */

  return;
}

/**************************************************************/
/* utils_unlock_files()                                       */
/*                                                            */
/* Go down the given path, setting permissions to "WR/" or,   */
/* if 'lock' is true, "LR/".                                  */
/*                                                            */
/* Parameters: Pathname of the top level directory to look    */
/*             inside;                                        */
/*                                                            */
/*             NULL for outer level call, else a pathname for */
/*             inner recursion during directory scanning;     */
/*                                                            */
/*             true to, in fact, lock, rather than unlock.    */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

int utils_unlock_files(const char * top_path, const char * current, bool lock)
{
  /* Note the restrictions that using this static buffer places on the */
  /* order we rely on calling ourselves recursively with respect to    */
  /* directory contents.                                               */

  _kernel_oserror * e;
  static char       path[MAXNAMLEN * 2 + 1];

  if (current == NULL) current = top_path;

  /* Set permissions */

  e = _swix(OS_File,
            _INR(0,1) | _IN(5),

            4,              /* Set attributes */
            current,
            lock ? 11 : 3); /* Bits 0 and 1 set -> "WR/"; bit 3 set -> "LR/" */

  if (e != NULL) return EXIT_FAILURE;

  if (dirs_is_dir(current))
  {
    DIR           * dir;
    struct dirent * entry;
    unsigned int    len;

    /* This is a directory; open it and dive in */

    dir = dirs_open_dir(current);

    if (dir == NULL)
    {
      return EXIT_FAILURE;
    }

    /* Write the basic path to the static buffer and remember */
    /* the length of it.                                      */

    StrNCpy0(path, current);
    len = strlen(path);

    /* Go round all entries */

    while ((entry = dirs_read_dir(dir)) != NULL)
    {
      /* Will the full pathname of this item fit in the buffer? */

      if (len + 2 + strlen(entry->d_name) > sizeof(path))
      {
        /* No - bail out */

        return EXIT_FAILURE;
      }
      else
      {
        /* Yes - write the leaf in */

        path[len] = '.';
        strcpy(path + len + 1, entry->d_name);

        if (utils_unlock_files(top_path, path, lock) == EXIT_FAILURE) return EXIT_FAILURE;
      }
    }

    dirs_close_dir(dir);
  }

  return EXIT_SUCCESS;
}

/**************************************************************/
/* utils_count_contents()                                     */
/*                                                            */
/* Count the number of items in the given path excluding the  */
/* named top-level item (be it file or directory), and return */
/* the total object size in bytes (directories are considered */
/* to be zero bytes long).                                    */
/*                                                            */
/* Parameters: Pathname of the top level directory to look    */
/*             inside;                                        */
/*                                                            */
/*             NULL for outer level call, else a pathname for */
/*             inner recursion during directory scanning;     */
/*                                                            */
/*             Pointer to an unsigned int to take the number  */
/*             of items;                                      */
/*                                                            */
/*             Pointer to an unsigned int to take the total   */
/*             size of the file items.                        */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/*                                                            */
/* Assumes:    Either of the integer pointers may be NULL if  */
/*             you aren't interested in that quantity.        */
/**************************************************************/

int utils_count_contents(const char * top_path, const char * current, unsigned int * items, unsigned int * size)
{
  /* Note the restrictions that using this static buffer places on the */
  /* order we rely on calling ourselves recursively with respect to    */
  /* directory contents.                                               */

  _kernel_oserror * e;
  static char       path[MAXNAMLEN * 2 + 1];
  unsigned int      local_items;
  unsigned int      local_size;
  unsigned int      item_size, item_type;

  if (current == NULL) current = top_path;
  if (items   == NULL) items   = &local_items;
  if (size    == NULL) size    = &local_size;

  if (current == top_path)
  {
    dprintf(("Diag", "utils_count_contents: Called with '%s'\n", top_path));
    *items = *size = 0;
  }
  else
  {
    (*items)++;

    e = _swix(OS_File,
              _INR(0,1) | _OUT(0) | _OUT(4),

              17,          /* Read catalogue info */
              current,

              &item_type,  /* 0: Not found, 1: File, 2: Dir, 3: Image dir */
              &item_size);

    if (e != NULL || item_type == 0) return EXIT_FAILURE;
    else if (item_type != 2) (*size) += item_size;
  }

  if (dirs_is_dir(current))
  {
    DIR           * dir;
    struct dirent * entry;
    unsigned int    len;

    /* This is a directory; open it and dive in */

    dir = dirs_open_dir(current);

    if (dir == NULL)
    {
      return EXIT_FAILURE;
    }

    /* Write the basic path to the static buffer and remember */
    /* the length of it.                                      */

    StrNCpy0(path, current);
    len = strlen(path);

    /* Go round all entries */

    while ((entry = dirs_read_dir(dir)) != NULL)
    {
      /* Will the full pathname of this item fit in the buffer? */

      if (len + 2 + strlen(entry->d_name) > sizeof(path))
      {
        /* No - bail out */

        return EXIT_FAILURE;
      }
      else
      {
        /* Yes - write the leafname in */

        path[len] = '.';
        strcpy(path + len + 1, entry->d_name);

        if (
             utils_count_contents(top_path,
                                  path,
                                  items,
                                  size)

             == EXIT_FAILURE
           )
           return EXIT_FAILURE;
      }
    }

    dirs_close_dir(dir);
  }

  return EXIT_SUCCESS;
}

/**************************************************************/
/* utils_read_word()                                          */
/*                                                            */
/* Read a 32-bit word from a file, ordered LSB to MSB.        */
/*                                                            */
/* Parameters: RISC OS file handle;                           */
/*                                                            */
/*             Pointer to unsigned int updated with the value */
/*             read from the file if there is no returned     */
/*             error (else untouched).                        */
/**************************************************************/

_kernel_oserror * utils_read_word(unsigned int h, unsigned int * word)
{
  unsigned int      v, b;
  _kernel_oserror * e = _swix(OS_BGet,
                              _IN(1) | _OUT(0),

                              h,

                              &v);

  if (e == NULL)
  {
    e = _swix(OS_BGet,
              _IN(1) | _OUT(0),

              h,

              &b);
  }

  if (e == NULL)
  {
    v |= (b << 8);
    e = _swix(OS_BGet,
              _IN(1) | _OUT(0),

              h,

              &b);
  }

  if (e == NULL)
  {
    v |= (b << 16);
    e = _swix(OS_BGet,
              _IN(1) | _OUT(0),

              h,

              &b);
  }

  if (e == NULL)
  {
    v |= (b << 24);
    if (word != NULL) *word = v;
  }

  return e;
}

/**************************************************************/
/* utils_write_word()                                         */
/*                                                            */
/* Write a 32-bit word to a file, LSB to MSB.                 */
/*                                                            */
/* Parameters: RISC OS file handle;                           */
/*                                                            */
/*             Word to write.                                 */
/**************************************************************/

_kernel_oserror * utils_write_word(unsigned int h, unsigned int word)
{
  _kernel_oserror * e = _swix(OS_BPut,
                              _INR(0,1),

                              (word & 0xff),
                              h);

  if (e == NULL) e = _swix(OS_BPut,
                           _INR(0,1),

                           (word & 0xff00) >> 8,
                           h);

  if (e == NULL) e = _swix(OS_BPut,
                           _INR(0,1),

                           (word & 0xff0000) >> 16,
                           h);

  if (e == NULL) e = _swix(OS_BPut,
                           _INR(0,1),

                           (word & 0xff000000) >> 24,
                           h);

  return e;
}

/**************************************************************/
/* utils_write_uid()                                          */
/*                                                            */
/* Write a file holding a given UID with attributes "LWR/".   */
/*                                                            */
/* Parameters: Full pathname of UID file to write;            */
/*                                                            */
/*             true to write a 'real' file, false to write a  */
/*             dummy file;                                    */
/*                                                            */
/*             UID, used if the above is true;                */
/*                                                            */
/*             Number of items including directories in the   */
/*             data the UID relates to;                       */
/*                                                            */
/*             Total data size excluding directories.         */
/**************************************************************/

_kernel_oserror * utils_write_uid(const char * name, bool real, unsigned int uid, unsigned int items, unsigned int size)
{
  unsigned int      h;
  _kernel_oserror * e = _swix(OS_Find,
                              _INR(0,2) | _OUT(0),

                              0x87, /* Create empty file with read/write access; use no path, error if there's a directory */
                              name,
                              0,

                              &h);

  if (e != NULL) return e;

  /* If writing a dummy file, put a single zero byte in it; */
  /* else write the full UID.                               */

  if (real)
  {
    e                = utils_write_word(h, uid);
    if (e == NULL) e = utils_write_word(h, items);
    if (e == NULL) e = utils_write_word(h, size);
  }
  else
  {
    e = _swix(OS_BPut,
              _INR(0,1),

              0,
              h);
  }

  /* Close the file */

  _swix(OS_Find,
        _INR(0,1),

        0, /* 0 -> Close file */
        h);

  /* Return any error from the above */

  if (e) return e;

  /* Exit via. setting file attributes */

  return _swix(OS_File,
               _INR(0,1) | _IN(5),

               4, /* Write attributes */
               name,
               11); /* Bit pattern -> "LWR/" */
}
