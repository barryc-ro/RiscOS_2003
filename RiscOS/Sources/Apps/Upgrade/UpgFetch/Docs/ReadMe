UpgFetch

Background
----------
	UpgFetch is a utility that allows an upgrade file (with a format as
specified in 2503/047/FS) and, if various checks are validated successfully,
call a utility to upgrade a Funai 8 box with the resultant image.

Fetching
--------
	The upgrade image is fetched via FTP using the URL module. The
routine fetch_data() is the main data fetch routine.
	UpgFetch allows the use of proxies for the fetching, to allow (for
instance) fetching through firewalls. Since the URL module is used to perform
the fetching, then the AcornHTTP module is needed to perform the proxying
services.
	Details of the proxy to use are obtained from the ftp_proxy details
held within the bootblock. If this tag is not present then no proxy will be
used.

Image validation
----------------
	The upgrade file contains a CRC of all the file except for the
CRC itself. Once the whole file as been downloaded, the CRC is validated and,
if the CRC is incorrect, the upgrade will fail. This is a vital step to
ensure that we do not try to upgrade the NC with invalid data.
	A check is also made to ensure that we are downloading the correct
sort of image for the box that we are in. The upgrade file has a list of
builds for which the image is applicable, and this is validated against the
build that the NC is current running. For instance a Funai NC running
Fun8JP0713 could be upgraded with an image containing a Fun, Fun8 or Fun8JP
builds, but not Fun7 or Laz1.


Security
--------
	There are many potential security issues with allowing an NC to be
upgraded over the internet. One of the most important of these is trying to
prevent the box being upgraded from unauthorised servers.
	This version of UpgFetch has a system whereby you can pass in at
build-time a series of domains from which upgrades will be allowed. These
domains are then compared with the URL that the data is being fetched from
and the fetch will only occur if it is from one of the allowable domains.
This code is contained within the validate_domain() routine, and is only used
if the USE_TRUSTED_DOMAINS preprocessor flag is set. If it is unset then
upgrades are allowed from any server.
	The rules for detecting a valid domain are as follows:
	* Anything before (and including) a :// is stripped (e.g. http:// or
ftp://). so http://www.acorn.com becomes www.acorn.com
	* Anything after (and including) the next / is stripped (e.g.
/upgrades/ftp), so www.acorn.com/this/is/a/url becomes www.acorn.com
	* The remainder is now checked against each of the allowed domains in
turn. The matching is done in a substring manner, with pace.co.uk matching
both support.pace.co.uk, upgrades.pace.co.uk and pace.co.uk?upgrades, but not
http://hackers_r_us@hacknet.net/pace.co.uk.
	The allowable domains are passed in at build-time on the
command-line. Because of the quirkiness of the interactions between AMU and
C, they are passed in in the following manner:
	* "OPTS=\"-DUSE_TRUSTED_DOMAINS=\\\"pace.co.uk,mpt.co.jp\\\"\""
	In the case above, the allowable domains are pace.co.uk and
mpt.co.jp.


Debugging
---------
	UpgFetch has been written with full DebugLib support built in. To
enable it, the build flags "OPTS=-DDEBUGLIB -DENABLE_DEBUGGING" need to be
passed in, as happens with the MkDebug script.This allows you to output
information via file, printf or any other of the DebugLib-supported output
mechanisms.


Future Ehancements
------------------
	UpgFetch has been written to be as flexible as possible, and it is
envisaged that it may be used in the future to allow things other than OS
images to be upgraded. For instance, the same system could be used to update
the font data held in Funai boxes, or even to download apps or games into
Flash. This section of the document outliens possible ways in which this
could be managed within the existing application framework.
	The module CheckURL allows validations of URL's of the form needed
for the trusted domains. It would be nice if the code were to be altered to
use this module instead of doing the parsing itself (oh, the joys of finding
out that such things exist *after* you have written the code...).
	Other security models may be needed by customers. The present system
is fairly secure as long as the details of the file format do not become
public. If yhey do, then it would be possibe for bogus upgrade files to be
created. The ability to download only from certain servers with certain
domain names helps with this, but is felt to be constraining by some
customers.
	Another possible security system would be to use certificates, and
have the NC validate a certificate passed from the server with the upgrade
image. Whilst this model could be very secure, it does pose additional
problems with the overheads related to certificate management which ould need
to be incurred by our customers and their ISP's.
