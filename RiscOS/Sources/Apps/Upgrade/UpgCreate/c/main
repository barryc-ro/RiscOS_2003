/**************************************************************/
/* File:    main.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: To run.                                           */
/*                                                            */
/* Author:  Nick Evans, Andrew Hodgkinson.                    */
/*                                                            */
/* History: 26-Sep-2000 (NE):  Created.                       */
/*          10-May-2001 (ADH): Bits of restructuring, various */
/*                             fixes.                         */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <time.h>

#include <kernel.h>
#include <swis.h>

#include <tcpiplibs/dirent.h>

#include <zlib/zlib.h>

#include "VersionNum"

#include "compress.h"
#include "config.h"
#include "crc32.h"
#include "Dirs.h"
#include "Utils.h"

#include "main.h"

/* 4 byte word */

#define WORD 4

/* Buffers for test extraction */

#define BSInput_Extract  16384
#define BSOutput_Extract 16384

/* Locals */

static char * type_names[] = {
                               "OS image",
                               "Font upgrade",
                               "Exec special",
                               "Transient executable",
                               "Resident executable",
                               "Permanent executable"
                             };

static char * bank_names[] = {
                               "(on-board)",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "(ROM card)"
                             };

static char * action_names[] = {
                                 "no action",
                                 "abort",
                                 "replace"
                               };

/* Local functions */

static void write_record_header       (int record, int size, FILE * fp);
static int  write_string_record       (int record, char * string, FILE * fp);
static int  write_word_record         (int record, int data, FILE * fp);

static int  main_write_word           (unsigned int word, FILE * fp);
static int  main_output_crc           (int comp_size, FILE * fp);

static int  main_build_upgrade_file   (config * setup);
static int  main_build_single_file    (config * setup);
static int  main_build_archive_file   (config * setup);

static int  main_add_files_to_archive (config * setup, unsigned int slen, FILE * fout, char * current);

static int  main_extract_files        (config * setup);
static int  main_decode_chunk         (config * setup, const char * buf, unsigned int amount);

/**************************************************************/
/* main()                                                     */
/*                                                            */
/* That which runs before all others.                         */
/**************************************************************/

int main(int argc, char * argv[])
{
  config setup; /* Contains data extracted from command line arguments */

  srand((int) time(NULL));
  printf("UpgCreate %s\n\n", Module_HelpVersion);

  /* Ensure strings are empty to start with, and numerical quantites */
  /* are zeroed where required (e.g. bank number) or set where zero  */
  /* isn't appropriate (e.g. image type).                            */

  memset(&setup, 0, sizeof(setup));

  setup.type    = image_type_unknown;
  setup.action  = action_type_none;
  setup.verbose = 1; /* 0 = quiet, 1 = normal, 2 = verbose */

  if (config_read_args(&setup, argc, argv) != 0)
  {
    printf("Syntax: " Module_ComponentName " [options] <-s source> <-o output>\n"
           "\n"
           "   -s (source)          Full pathname of file/directory to read.\n"
           "   -o (output)          Full pathname of output image.\n"
           "   -t (type)            osimage | transient | resident | permanent |\n"
           "                        font | exec (\"font\" and \"exec\" are presently\n"
           "                        not implemented).\n"
           "   -u (hex string)      Include UID in image; the value should be an 8\n"
           "                        digit hex number with no special prefix (may be\n"
           "                        omitted; if absent, no UID is included).\n"
           "   -r (boolean)         1 | 0 (if \"1\", randomise UID by EORing with\n"
           "                        rand() and time; ignored if -u is absent; may\n"
           "                        be omitted; default is \"0\").\n"
           "   -n (task name)       Optional task name for transient, resident or\n"
           "                        permanent images only, if the item being\n"
           "                        archived is multitasking.\n"
           "   -a (action)          abort | replace (if \"abort\", and '-t' is used,\n"
           "                        and the named task is present, running of this\n"
           "                        item will be aborted; if \"replace\" the running\n"
           "                        copy will be replaced by the new one).\n"
           "   -c (card/bank)       0 for on-board FLASH ROM, 6 for card ROM (may\n"
           "                        be omitted; default is \"0\").\n"
           "   -d (display)         \"display string\".\n"
           "   -l (locale)          \"one or more locales\".\n"
           "   -b (build)           \"build to match\" (OS, font and exec only).\n"
           "   -e (extract)         Full pathname to extract to; leads to a test\n"
           "                        of output file's integrity after creation by\n"
           "                        extracting to the given location (may be\n"
           "                        omitted; if absent, no test is performed; see\n"
           "                        below for more information).\n"
           "   -v (level)           0 | 1 | 2 (\"0\" = quiet, \"2\" = verbose).\n"
           "\n"
           "If -s and -o must always be present; -e and -v is always optional\n"
           "(default value of -v is 0); other parameters depend on the value given\n"
           "to -t:\n"
           "\n"
           " * \"osimage\": -d, -b and -l must be present; -c is optional (default\n"
           "    value is 0). If -e is present the image is extracted to the given\n"
           "    filename, remaining in compressed form.\n"
           " * \"font\" or \"exec\": A single file will be compressed. Use of -e is as\n"
           "    for \"osimage\".\n"
           "\n"
           "For other values of -t, -d and -l is always optional. If the item\n"
           "being archived is a multitasking application, -n and -a may be used to\n"
           "define actions if the task is already running when the archive image is\n"
           "unpacked and run (specifying only one of -a or -n is ignored). The\n"
           "remaining parameters should be set as follows according to -t:\n"
           "\n"
           " * \"transient\": If -e is present it should be the directory in which\n"
           "    extraction will take place. All extracted files are decompressed.\n"
           " * \"resident\": -u (and therefore -r) are optional. Use of -e is as for\n"
           "    \"transient\".\n"
           " * \"permanent\": -u is mandatory, -r optional. Use of -e is as for\n"
           "    \"transient\".\n");

    return 0;
  }

  printf("** Creating upgrade image...\n");

  if (setup.verbose != 0)
  {
    printf("\nType:    %s"
           "\nDisplay: \"%s\""
           "\nBuild:   %s"
           "\nLocale:  %s"
           "\nBank:    %d %s"
           "\nInput:   %s"
           "\nOutput:  %s"
           "\nTask:    %s (%s)"
           "\n",

           setup.type >= 0 && setup.type < (sizeof(type_names) / sizeof(*type_names)) ? type_names[setup.type] : "<Unknown!>",
           setup.display_string,
           (*setup.build  != '\0') ? setup.build  : "<None>",
           (*setup.locale != '\0') ? setup.locale : "<None>",
           setup.bank,
           setup.bank < (sizeof(bank_names) / sizeof(*bank_names) && *bank_names[setup.bank] != '\0') ? bank_names[setup.bank] : "<Unknown!>",
           setup.image_path,
           setup.out_path,
           (*setup.task_name != '\0') ? setup.task_name : "<None>",
           setup.action >=0 && setup.action < (sizeof(action_names) / sizeof(*action_names)) ? action_names[setup.action] : "<Unknown!>");
  }

  return main_build_upgrade_file(&setup);
}


/* write a record header */
static void write_record_header(int record,int size,FILE *fp)
{
  main_write_word(record, fp);
  main_write_word(size, fp);
}


/* write a variable length string record and return total size */
static int write_string_record(int record,char *string,FILE *fp)
{
  if(string[0]!=NULL)
  {
    write_record_header(record,strlen(string)+1,fp);
    fputs(string,fp);
    fputc(NULL,fp);   /* terminate it! */
    return (strlen(string) + 2*WORD+1);
  }
  else
    return 0;  /* no record to write */
}


/* write a single word record */
static int write_word_record(int record,int data,FILE *fp)
{
  write_record_header(record,WORD,fp);
  main_write_word(data, fp);
  return (3*WORD);
}

/**************************************************************/
/* main_write_word()                                          */
/*                                                            */
/* Write a word, assumed 32-bit, to the given output file,    */
/* least significant byte first.                              */
/*                                                            */
/* Parameters: 32-bit word to write;                          */
/*                                                            */
/*             Pointer to FILE describing output file.        */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_write_word(unsigned int word, FILE * fp)
{
  if      (fputc((word & 0xFF),             fp) == EOF) return EXIT_FAILURE;
  else if (fputc((word & 0xFF00)     >> 8,  fp) == EOF) return EXIT_FAILURE;
  else if (fputc((word & 0xFF0000)   >> 16, fp) == EOF) return EXIT_FAILURE;
  else if (fputc((word & 0xFF000000) >> 24, fp) == EOF) return EXIT_FAILURE;

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_output_crc()                                          */
/*                                                            */
/* Given a file open for read and write, rewind, calculate a  */
/* CRC based on all data in the file, and output it plus tag  */
/* 8 (pseudo-random value) at the end of the file.            */
/*                                                            */
/* Parameters: Value to EOR with CRC for pseudo-random data;  */
/*                                                            */
/*             Pointer to FILE describing output file.        */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_output_crc(int comp_size, FILE * fp)
{
  unsigned int crc;
  int          ch;

  printf("Calculating overall CRC\n");

  rewind(fp);
  make_crc_tables();

  /* CRC precondition */

  crc = 0xffffffff;

  while (feof(fp) == 0)
  {
    ch = fgetc(fp);

    if (ch == EOF) break;
    else update_crc((U8 *) &ch, (U32 *) &crc);
  }

  /* CRC postcondition */

  crc ^= 0xffffffff;

  printf("CRC = &%08X\n", crc);

  /* Add the CRC */

  write_word_record(TLV_TAG_TYPE_FILE_CRC, crc, fp);

  /* Now write the random data record to disguise the CRC */

  write_word_record(TLV_TAG_TYPE_RANDOM_DATA, comp_size ^ crc, fp);

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_build_upgrade_file()                                  */
/*                                                            */
/* Build an upgrade archive based on the given configuration  */
/* structure.                                                 */
/*                                                            */
/* Parameters: Pointer to the config structure relevant to    */
/*             the upgrade archive to be built.               */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_build_upgrade_file(config * setup)
{
  /* What type of object is this? */

  switch (setup->type)
  {
    case image_type_os:
    case image_type_font:
    case image_type_exec: return main_build_single_file(setup);

    case image_type_transient:
    case image_type_resident:
    case image_type_permanent: return main_build_archive_file(setup);

    default:
    {
      printf("Do not know how to make type %d images\n", setup->type);
      return EXIT_FAILURE;
    }
  }

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_build_single_file()                                   */
/*                                                            */
/* Build an upgrade archive based around a single file - for  */
/* image types OS, font and exec only.                        */
/*                                                            */
/* Parameters: Pointer to the config structure relevant to    */
/*             the upgrade archive to be built.               */
/*                                                            */
/* Returns:    0 for success, non-zero for failure.           */
/**************************************************************/

static int main_build_single_file(config * setup)
{
  FILE         * fin;
  FILE         * fout;
  int            comp_size;      /* Compressed image size                  */
  long int       pos0;           /* Used to store record 0 file position   */
  long int       pos100;         /* Used to store record 100 file position */
  unsigned int   inputsize;      /* Input file size                        */
  long int       size;           /* Output file size                       */

  /* We need catalogue information on the input file */

  fin = fopen(setup->image_path, "rb");

  if (fin == NULL)
  {
    printf("Cannot open input file\n");
    return EXIT_FAILURE;
  }

  fseek(fin, 0, SEEK_END);
  inputsize = (unsigned int) ftell(fin);
  fclose(fin);
  fin = NULL;

  /* Open the output file */

  fout = fopen(setup->out_path, "wb");

  if (fout==NULL)
  {
    printf("Cannot open output file\n");
    return EXIT_FAILURE;
  }

  /* Write record 0 header (file size) */

  write_record_header(TLV_TAG_TYPE_FILE_SIZE, WORD, fout);

  /* Store the current file position */

  pos0 = ftell(fout);

  /* Write some random rubbish into the file size record for now; */
  /* we will rewind later and put something sensible in.          */

  main_write_word(0, fout);

  /* Write record 1 (display message) */

  write_string_record(TLV_TAG_TYPE_DISPLAY_STRING, setup->display_string, fout);

  /* Write record 2 (build) */

  write_string_record(TLV_TAG_TYPE_BUILD_LIST, setup->build, fout);

  /* Write record 3 (locale) */

  write_string_record(TLV_TAG_TYPE_LOCALE_LIST, setup->locale, fout);

  /* Write record 4 (image type) */

  write_word_record(TLV_TAG_TYPE_IMAGE_TYPE, setup->type, fout);

  /* Write record 5 (decompressed ROM size); this is meant to be in */
  /* MBytes, so we must round up to a whole MByte anything that's   */
  /* as little as 1 byte over the previous MByte boundary.          */

  inputsize = (inputsize + (1024 * 1024 - 1)) / (1024 * 1024);

  write_word_record(TLV_TAG_TYPE_IMAGE_LENGTH, inputsize, fout);

  /* Write record 9 (ROM bank) */

  write_word_record(TLV_TAG_TYPE_BANK, setup->bank, fout);

  /* Write record 6 (compressed image) header */

  main_write_word(TLV_TAG_TYPE_IMAGE_DATA, fout);

  /* Store the record 100 size field file pointer */

  pos100 = ftell(fout);

  /* Write some random stuff into to record 100 size field for now */

  main_write_word(0, fout);

  /* Open the input file */

  fin = fopen(setup->image_path,"r");
  if (fin == NULL)
  {
    printf("Cannot open input file\n");
    return EXIT_FAILURE;
  }

  /* Compress the image file */

  comp_size = crunch(fin, fout, setup->verbose);
  fclose(fin);

  /* Go back and write the real file size, accounting for adding tags 7 and 8 afterwards */

  size = ftell(fout) + (6 * sizeof(int));
  if (setup->verbose > 0) printf("Going back to record final output file size of %d bytes\n", (int) size);
  fseek(fout, pos0, SEEK_SET);
  main_write_word((int) size, fout);

  /* Write record 100 (compressed image size) */

  if (setup->verbose > 0) printf("Recording compressed data size of %d bytes\n", comp_size);
  fseek(fout, pos100, SEEK_SET);
  main_write_word(comp_size, fout);

  /* Calculate the CRC */

  if (main_output_crc(comp_size, fout) == EXIT_FAILURE)
  {
    printf("\nCouldn't write CRC information\n");
    fclose(fout);
    return EXIT_FAILURE;
  }

  /* Finished writing */

  fclose(fout);
  printf("\nSuccessful.");

  /* Optional expansion test to check it all worked:
   *
   * expand(setup->out_path,setup->image_path);
   */

return EXIT_SUCCESS;
}

/**************************************************************/
/* main_build_archive_file()                                  */
/*                                                            */
/* Build an upgrade archive based around multiple files for   */
/* execution - relevant for transient, resident and permanent */
/* types only.                                                */
/*                                                            */
/* Parameters: Pointer to the config structure relevant to    */
/*             the upgrade archive to be built.               */
/*                                                            */
/* Returns:    0 for success, non-zero for failure.           */
/**************************************************************/

static int main_build_archive_file(config * setup)
{
  FILE     * fout;
  long int   pos0, pos6s, pos6e;
  long int   size;
  int        slen;

  printf("\n");

  /* Open the output file */

  fout = fopen(setup->out_path,"wb");
  if (fout==NULL)
  {
    printf("Cannot open output file\n");
    return EXIT_FAILURE;
  }

  /* Write record 0 header (file size) */

  write_record_header (0, WORD, fout);

  /* Store the current file position */

  pos0 = ftell(fout);

  if (pos0 < 0)
  {
    fclose(fout);
    printf("Error reading file position in output file\n");
    return EXIT_FAILURE;
  }

  main_write_word(TLV_TAG_TYPE_FILE_SIZE, fout);

  /* UID if required */

  if (setup->have_uid != 0)
  {
    int ti;

    if (
         _swix(OS_ReadMonotonicTime,
               _OUT(0),

               &ti)
         != 0
       )
       ti = (int) time(NULL);

    write_word_record(TLV_TAG_TYPE_UID,
                     setup->randomise == 0 ? setup->uid : (setup->uid ^ ti) ^ rand(),
                     fout);
  }

  /* Other misc stuff */

  write_string_record (TLV_TAG_TYPE_DISPLAY_STRING, setup->display_string, fout);
  write_string_record (TLV_TAG_TYPE_BUILD_LIST,     setup->build,          fout);
  write_string_record (TLV_TAG_TYPE_LOCALE_LIST,    setup->locale,         fout);
  write_word_record   (TLV_TAG_TYPE_IMAGE_TYPE,     setup->type,           fout);

  if (*setup->task_name != '\0' && (setup->action == action_type_abort || setup->action == action_type_replace))
  {
    write_string_record (TLV_TAG_TYPE_TASK_NAME,   setup->task_name, fout);
    write_word_record   (TLV_TAG_TYPE_TASK_ACTION, setup->action,    fout);
  }

  /* Put in the header for the archived files */

  write_record_header(TLV_TAG_TYPE_IMAGE_DATA, WORD, fout);
  pos6s = ftell(fout);

  /* Get the length of setup->image_path up to and including the last '.' */

  slen = strlen(setup->image_path);

  while (slen > 0 && (setup->image_path)[slen - 1] != '.') slen--;

  if (slen == 0)
  {
    fclose(fout);
    printf("Could not form sensible path from output filename\n");
    return EXIT_FAILURE;
  }

  /* Now add all the files in */

  if (
       main_add_files_to_archive(setup,
                                 slen,
                                 fout,
                                 NULL)
       == EXIT_FAILURE
     )
  {
    fclose(fout);
    printf("Could not write all files to output file; aborting\n");
    return EXIT_FAILURE;
  }

  if (setup->verbose > 0) printf("All files added\n\n");

  pos6e = ftell(fout) - pos6s;
  size  = ftell(fout) + (6 * sizeof(int));

  /* Rewind to write the record 6 size */

  if (setup->verbose > 0) printf("Going back to record tag 6 data size of %d bytes\n", (int) pos6e);
  fseek(fout, pos6s - 4, SEEK_SET);
  main_write_word((int) pos6e, fout);

  /* Go back and write the real file size, accounting for adding tags 7 and 8 afterwards */

  if (setup->verbose > 0) printf("Going back to record final output file size of %d bytes\n", (int) size);
  fseek(fout, pos0, SEEK_SET);
  main_write_word((int) size, fout);

  /* Calculate the CRC */

  if (main_output_crc(rand(), fout) == EXIT_FAILURE)
  {
    printf("\nCouldn't write CRC information\n");
    fclose(fout);
    return EXIT_FAILURE;
  }

  /* Finished writing */

  printf("\nSuccessful.");
  fclose(fout);

  /* Optional expansion test to check it all worked */

  if (*setup->extract_to != '\0')
  {
    printf("\n\n** Expanding archive to check integrity...\n\n");

    return main_extract_files(setup);
  }
  else return EXIT_SUCCESS;
}

/**************************************************************/
/* main_add_files_to_archive()                                */
/*                                                            */
/* Once main_build_archive_file() has done the preamble, this */
/* adds all files to the archive. Its operation is recursive, */
/* going into directories as need be.                         */
/*                                                            */
/* Parameters: Pointer to the config structure relevant to    */
/*             the upgrade archive being built;               */
/*                                                            */
/*             Length of config's "image_path" *path* (i.e.   */
/*             take "image_path" and wind back to the '.',    */
/*             and include this in the count) - avoids having */
/*             to recalculate this internally at each         */
/*             recursion level;                               */
/*                                                            */
/*             Pointer to FILE struct describing output file. */
/*                                                            */
/*             NULL for outer level call, else a pathname for */
/*             inner recursion during directory scanning.     */
/*                                                            */
/* Returns:    0 for success, non-zero for failure.           */
/**************************************************************/

static int main_add_files_to_archive(config * setup, unsigned int slen, FILE * fout, char * current)
{
  /* Note the restrictions that using this static buffer places on the */
  /* order we rely on calling ourselves recursively with respect to    */
  /* directory contents.                                               */

  static char    path[MAXNAMLEN * 2 + 1];
  char         * leaf;
  unsigned int   leaflen, written;

  if (current == NULL) current = setup->image_path;

  /* Output this item's filename */

  leaf    = current + slen;
  leaflen = strlen(leaf);

  if (leaflen == 0)
  {
    printf("Can't get a sensible leafname from current path\n");
    return EXIT_FAILURE;
  }

  written = fwrite(current + slen,
                   sizeof(char),
                   leaflen + 1,
                   fout);

  if (written <= leaflen)
  {
    printf("Couldn't write item's filename to output file\n");
    return EXIT_FAILURE;
  }

  /* Handle directories or files differently */

  if (dirs_is_dir(current))
  {
    DIR           * dir;
    struct dirent * entry;
    unsigned int    len;

    /* This is a directory */

    if (setup->verbose > 0) printf("Dir : '%s'\n", current + slen);

    /* Output subtype byte */

    if (fputc(Main_SubType_Directory, fout) == EOF)
    {
      printf("Couldn't write subtype byte to output file\n");
      return EXIT_FAILURE;
    }

    /* Open it and dive in */

    dir = dirs_open_dir(current);

    if (dir == NULL)
    {
      printf("Out of memory!\n");
      return EXIT_FAILURE;
    }

    /* Write the basic path to the static buffer and remember */
    /* the length of it.                                      */

    StrNCpy0(path, current);
    len = strlen(path);

    /* Go round all entries */

    while ((entry = dirs_read_dir(dir)) != NULL)
    {
      /* Will the full pathname of this item fit in the buffer? */

      if (len + 2 + strlen(entry->d_name) > sizeof(path))
      {
        /* No - bail out */

        printf("Pathname buffer overflow\n");
        return EXIT_FAILURE;
      }
      else
      {
        /* Yes - write the leaf in */

        path[len] = '.';
        strcpy(path + len + 1, entry->d_name);

        if (main_add_files_to_archive(setup, slen, fout, path) == EXIT_FAILURE) return EXIT_FAILURE;
      }
    }

    dirs_close_dir(dir);
  }
  else
  {
    unsigned int      itemtype, loadaddr, execaddr, itemsize, itemattr;
    _kernel_oserror * e;
    FILE            * fin;

    /* We've got a file */

    if (setup->verbose > 0) printf("File: '%s'\n", current + slen);

    /* Output subtype byte */

    if (fputc(Main_SubType_File, fout) == EOF)
    {
      printf("Couldn't write subtype byte to output file\n");
      return EXIT_FAILURE;
    }

    /* Write the load and execution addresses */

    e = _swix(OS_File,
              _INR(0,1) | _OUT(0) | _OUTR(2,5),

              17, /* Read file information with no special path prefix on R1 */
              current,

              &itemtype,
              &loadaddr,
              &execaddr,
              &itemsize,
              &itemattr);

    if (e != NULL)
    {
      printf("OS_File error '%s'\n", e->errmess);
      return EXIT_FAILURE;
    }
    else if (itemtype == 0)
    {
      printf("Cannot find current file '%s'\n", current);
      return EXIT_FAILURE;
    }

    if (
         main_write_word(itemsize, fout) == EXIT_FAILURE ||
         main_write_word(loadaddr, fout) == EXIT_FAILURE ||
         main_write_word(execaddr, fout) == EXIT_FAILURE ||
         main_write_word(itemattr, fout) == EXIT_FAILURE
       )
    {
      printf("Cannot write item's details to output file\n");
      return EXIT_FAILURE;
    }

    /* OK, compress it */

    fin = fopen(current, "rb");

    if (fin == NULL)
    {
      printf("Cannot open item for compression to output file\n");
      return EXIT_FAILURE;
    }
    else
    {
      crunch(fin, fout, setup->verbose);
      fclose(fin);
    }
  }

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_extract_file()                                        */
/*                                                            */
/* Unpack the file to the specified location.                 */
/*                                                            */
/* Parameters: Pointer to a config structure describing the   */
/*             file to unpack and location to send it.        */
/*                                                            */
/* Returns;    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_extract_files(config * setup)
{
  FILE         * fin;
  char           buf[BSInput_Extract];
  unsigned int   read;
  char         * filename = setup->out_path;

  fin = fopen(filename, "rb");

  if (fin == 0)
  {
    perror(filename);
    return EXIT_FAILURE;
  }

  do
  {
    read = fread(buf, sizeof(char), sizeof(buf), fin);

    if (read < sizeof(buf) && !feof(fin))
    {
      perror(filename);
      fclose(fin);
      return EXIT_FAILURE;
    }
    else
    {
      if (main_decode_chunk(setup, buf, read) == EXIT_FAILURE)
      {
        fclose(fin);
        return EXIT_FAILURE;
      }
    }
  }
  while (!feof(fin));

  fclose(fin);

  if (setup->verbose > 0) printf("\n");
  printf("Extraction successful.\n");

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_decode_chunk()                                        */
/*                                                            */
/* Decode a chunk of a compressed upgrade image. The function */
/* is rather monolithic, but very straightforward.            */
/*                                                            */
/* Parameters: Pointer to a config structure describing where */
/*             any output data should be sent to;             */
/*                                                            */
/*             Pointer to a buffer holding a chunk of data to */
/*             process;                                       */
/*                                                            */
/*             Amount of data in the buffer.                  */
/*                                                            */
/* Returns;    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_decode_chunk(config * setup, const char * buf, unsigned int amount)
{
  static bool           expecting_tag  = true;
  static unsigned int   reading_tag    = 0;
  static unsigned int   tag            = 0;

  static bool           expecting_size = true;
  static unsigned int   reading_size   = 0;
  static unsigned int   size           = 0;

  static bool           expecting_data = false;
  static unsigned int   reading_data   = 0;

  static image_type     type_of_image  = image_type_unknown;
  static action_type    action         = action_type_none;

  static FILE         * fout           = NULL;

  int                   ptr            = 0;

  if (amount == 0) return EXIT_SUCCESS;

  do
  {
    /* Read the tag value */

    while (expecting_tag == true && reading_tag < 32 && ptr < amount)
    {
      tag = tag | (buf[ptr++] << reading_tag);
      reading_tag += 8;
    }

    /* Finished reading a tag? */

    if (reading_tag == 32)
    {
      expecting_tag  = false;
      reading_tag    = 0;
      expecting_size = true;
      reading_size   = 0;
      size           = 0;

      if (setup->verbose > 0) printf("Tag %d acquired\n", tag);
    }

    if (ptr == amount) return EXIT_SUCCESS;

    /* Read data size */

    while (expecting_size == true && reading_size < 32 && ptr < amount)
    {
      size = size | (buf[ptr++] << reading_size);
      reading_size += 8;
    }

    /* Finished reading size? */

    if (reading_size == 32)
    {
      expecting_size = false;
      reading_size   = 0;
      expecting_data = true;
      reading_data   = 0;

      if (setup->verbose == 2) printf("Data size %d\n", size);
    }

    if (ptr == amount) return EXIT_SUCCESS;

    /* If expecting data, read it */

    if (expecting_data)
    {
      if (size > 0)
      {
        switch (tag)
        {
          case TLV_TAG_TYPE_FILE_SIZE:
          case TLV_TAG_TYPE_IMAGE_LENGTH:
          case TLV_TAG_TYPE_FILE_CRC:
          case TLV_TAG_TYPE_RANDOM_DATA:
          case TLV_TAG_TYPE_UID:
          case TLV_TAG_TYPE_IMAGE_TYPE:
          case TLV_TAG_TYPE_TASK_ACTION:
          {
            static unsigned int reading_word = 0;
            static unsigned int word         = 0;

            if (size != 4)
            {
              printf("Error: Expecting to read one word of data for this tag, but data size is %d\n", size);
              return EXIT_FAILURE;
            }

            /* Read data word */

            while (reading_word < 32 && ptr < amount)
            {
              word = word | (buf[ptr++] << reading_word);
              reading_data ++;
              reading_word += 8;
            }

            /* Finished? */

            if (reading_word == 32)
            {
              switch (tag)
              {
                case TLV_TAG_TYPE_FILE_SIZE:    if (setup->verbose > 0) printf("File size is %d\n",              word); break;
                case TLV_TAG_TYPE_IMAGE_LENGTH: if (setup->verbose > 0) printf("Compressed data length is %d\n", word); break;
                case TLV_TAG_TYPE_FILE_CRC:     if (setup->verbose > 0) printf("File CRC is &%08X\n",            word); break;
                case TLV_TAG_TYPE_RANDOM_DATA:  if (setup->verbose > 0) printf("Random data is &%08X\n",         word); break;
                case TLV_TAG_TYPE_UID:          if (setup->verbose > 0) printf("UID is &%08X\n",                 word); break;
                case TLV_TAG_TYPE_IMAGE_TYPE:
                {
                  if (setup->verbose > 0)
                  {
                    printf("Image type: %s\n",
                           word < (sizeof(type_names) / sizeof(*type_names)) ?
                           type_names[word]                                  :
                           "<Unknown!>");
                  }

                  type_of_image = (image_type) word;
                }
                break;
                case TLV_TAG_TYPE_TASK_ACTION:
                {
                  if (setup->verbose > 0)
                  {
                    printf("Task action: %s\n",
                           word < (sizeof(action_names) / sizeof(*action_names)) ?
                           action_names[word]                                    :
                           "<Unknown!>");
                  }

                  action = (action_type) word;
                }
                break;
                default:
                {
                  printf("Fatal internal error (1)\n");
                  exit(EXIT_FAILURE);
                }
              }

              /* Don't forget to reset the values... */

              reading_word = 0;
              word         = 0;
            }
          }
          break;

          case TLV_TAG_TYPE_DISPLAY_STRING:
          case TLV_TAG_TYPE_BUILD_LIST:
          case TLV_TAG_TYPE_LOCALE_LIST:
          case TLV_TAG_TYPE_TASK_NAME:
          {
            while (reading_data < size && ptr < amount)
            {
              char c = buf[ptr++];

              reading_data++;

              if (reading_data == 1 && setup->verbose > 0) printf("String value is \"");

              if (c != '\0')
              {
                if (setup->verbose > 0) printf("%c", c);
              }
              else
              {
                if (setup->verbose > 0) printf("\"\n");

                if (reading_data != size)
                {
                  printf("Error: Reached NUL in string but haven't read all expected data yet (%d bytes left hanging)\n", size - reading_data);
                  return EXIT_FAILURE;
                }
              }
            }
          }
          break;

          case TLV_TAG_TYPE_IMAGE_DATA:
          {
            switch (type_of_image)
            {
              default:
              case image_type_unknown:
              {
                printf("Error: Reached image data before finding out the image type\n");
                return EXIT_FAILURE;
              }
              break;

              case image_type_transient:
              case image_type_resident:
              case image_type_permanent:
              {
                static bool           expecting_stubname = true;
                static int            reading_stubname   = NULL;
                static char         * stubname           = NULL;
                static char         * fullname           = NULL;
                static int            subtype            = 0;

                static unsigned int   stage              = 0;

                static unsigned int   itemsize;
                static unsigned int   loadaddr;
                static unsigned int   execaddr;
                static unsigned int   itemattr;

                static unsigned int   reading_word       = 0;
                static unsigned int   word               = 0;

                static bool           completed          = false;

                /* For archives, we first expect the 'stub' name of the file */

                while (expecting_stubname && ptr < amount && reading_data < size)
                {
                  if (reading_stubname == 0)
                  {
                    /* These are just-in-case items; the bit handling the */
                    /* 'completed' flag way down below *should* ensure    */
                    /* that they are always reset appropriately.          */

                    free(fullname), fullname = NULL;
                    free(stubname), stubname = NULL;

                    /* OK, allocate space for the first byte of the stubname */

                    stubname = malloc(1);

                    if (stubname == NULL)
                    {
                      printf("Error: Out of memory reading file stub name\n");
                      return EXIT_FAILURE;
                    }
                  }
                  else
                  {
                    /* Reallocate for the next byte */

                    char * temp = realloc(stubname, reading_stubname + 1);

                    if (temp == NULL)
                    {
                      printf("Error: Out of memory reading file stub name\n");
                      return EXIT_FAILURE;
                    }
                    else stubname = temp;
                  }

                  stubname[reading_stubname] = buf[ptr++];

                  /* The name terminates on NUL; after that we expect the subtype byte */

                  if (stubname[reading_stubname] == '\0') expecting_stubname = false;

                  reading_stubname ++;
                  reading_data     ++;
                }

                if (reading_data >= size)
                {
                  free(stubname);
                  printf("Error: Ran out of data for this record during archive processing\n");
                  return EXIT_FAILURE;
                }

                /* Once the stubname is done, need the subtype byte */

                if (!expecting_stubname && subtype == 0 && ptr < amount && reading_data < size)
                {
                  if (setup->verbose > 0) printf("Item stub name is '%s'\n", stubname);

                  subtype = buf[ptr++] + 1;
                  reading_data++;

                  if (subtype != 1 && subtype != 2)
                  {
                    printf("Error: Subtype byte value %d not recognised\n", subtype);
                  }
                  else
                  {
                    if (setup->verbose == 2) printf("This is a %s\n", subtype == 1 ? "file" : "directory");
                  }
                }

                /* If this is a file, we expect more data */

                if (reading_data >= size && subtype == 1)
                {
                  free(stubname);
                  printf("Error: Ran out of data for this record during archive processing\n");
                  return EXIT_FAILURE;
                }

                if (subtype != 0 && fullname == NULL)
                {
                  /* Construct the full name */

                  fullname = malloc(strlen(setup->extract_to) + strlen(stubname) + 2); /* 1 for separating ".", 1 for NUL */

                  if (fullname == NULL)
                  {
                    printf("Error: Out of memory creating full filename\n");
                    return EXIT_FAILURE;
                  }
                  else sprintf(fullname, "%s.%s", setup->extract_to, stubname);

                  if (setup->verbose == 2) printf("Full name is '%s'\n", fullname);
                }

                /* If subtype is 2 (i.e. byte in file was 2-1 = 1) -> directory; create it now */

                if (subtype == 2)
                {
                  _kernel_oserror * e = _swix(OS_File,
                                              _INR(0,1) | _IN(4),

                                              8,        /* Create directory */
                                              fullname,
                                              0);       /* Initial number of entries; 0 = use default */

                  if (e != NULL)
                  {
                    printf("Error: %s", e->errmess);
                    return EXIT_FAILURE;
                  }

                  /* Report and flag completion for this item */

                  if (setup->verbose > 0) printf("Directory created\n");
                  completed = true;
                }

                /* If subtype is 1 (i.e. byte in file was 1-1 = 0) -> file */

                else if (subtype == 1)
                {
                  while (ptr < amount && reading_data < size && !completed)
                  {
                    switch (stage)
                    {
                      /* Need to read words for item size, load address, exec address and attributes */

                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      {
                        /* Read the word */

                        while (reading_word < 32 && ptr < amount && reading_data < size)
                        {
                          word = word | (buf[ptr++] << reading_word);
                          reading_data ++;
                          reading_word += 8;
                        }

                        /* Finished? Record it in the relevant variable */

                        if (reading_word == 32)
                        {
                          switch (stage)
                          {
                            case 0: itemsize = word; break;
                            case 1: loadaddr = word; break;
                            case 2: execaddr = word; break;
                            case 3: itemattr = word; break;
                            default:
                            {
                              printf("Fatal internal error (2)\n");
                              exit(EXIT_FAILURE);
                            }
                          }

                          reading_word = 0;
                          word         = 0;

                          stage++;
                        }

                        /* Out of data unexpectedly? */

                        if (reading_data >= size)
                        {
                          free(stubname);
                          free(fullname);
                          printf("Error: Ran out of data for this record during archive processing\n");
                          return EXIT_FAILURE;
                        }
                      }
                      break;

                      /* When we get to stage 4, all words have been read; this is file data now */

                      case 4:
                      {
                        static bool      restart_zlib = true;
                        static z_stream  stream;
                        Byte             outbuf[BSOutput_Extract];
                        int              error;
                        size_t           write, written;

                        /* If not presently open, open the output file and wake up zlib */

                        if (fout == NULL)
                        {
                          fout = fopen(fullname, "wb");

                          if (fout == NULL)
                          {
                            perror(fullname);
                            return EXIT_FAILURE;
                          }
                          else if (restart_zlib == true)
                          {
                            restart_zlib = true;

                            /* Set up basic stream info */

                            memset(&stream, 0, sizeof(stream));

                            stream.zalloc = Z_NULL;
                            stream.zfree  = Z_NULL;
                            stream.opaque = Z_NULL;

                            /* Initialise the inflate engine */

                            error = inflateInit(&stream);

                            if (error)
                            {
                              free(stubname);
                              free(fullname);
                              fclose(fout);
                              printf("Error: ZLib error %d at initialisation (%s)\n", error, stream.msg != NULL && *stream.msg != '\0' ? stream.msg : "no further details");
                              return EXIT_FAILURE;
                            }
                          }
                        }

                        /* Work out how much data we can write this time around and write it */

                        if (ptr < amount)
                        {
                          do
                          {
                            /* Read a chunk */

                            stream.next_in  = (Byte *) (buf + ptr);
                            stream.avail_in = ((amount - ptr) * sizeof(char)) / sizeof(Byte);

                            /* Decompressor loop */

                            do
                            {
                              stream.next_out  = outbuf;
                              stream.avail_out = (uInt) sizeof(outbuf);

                              error = inflate(&stream, Z_SYNC_FLUSH);

                              if (error && error != Z_STREAM_END)
                              {
                                free(stubname);
                                free(fullname);
                                fclose(fout);
                                printf("Error: ZLib error %d at decompression (%s)\n", error, stream.msg != NULL && *stream.msg != '\0' ? stream.msg : "no further details");
                                return EXIT_FAILURE;
                              }

                              /* Write out the decompressed data */

                              write   = (sizeof(outbuf) / sizeof(Byte)) - stream.avail_out;
                              written = fwrite(outbuf,
                                               sizeof(Byte),
                                               write,
                                               fout);

                              if (written < write)
                              {
                                free(stubname);
                                free(fullname);
                                fclose(fout);
                                perror(fullname);
                                return EXIT_FAILURE;
                              }

                              /* Keep going until all input data is consumed */
                            }
                            while (stream.avail_in > 0 && !error);

                            /* Increment our local data counters */

                            reading_data += (amount - ptr - stream.avail_in);
                            ptr          += (amount - ptr - stream.avail_in);

                            /* Keep going until stream end, or we run out of data */
                          }
                          while (error != Z_STREAM_END && ptr < amount && reading_data < size);

                          /* Finished? */

                          if (error == Z_STREAM_END)
                          {
                            _kernel_oserror * e;

                            fclose(fout), fout = NULL;

                            error = inflateEnd(&stream);

                            if (error && error != Z_STREAM_END)
                            {
                              free(stubname);
                              free(fullname);
                              printf("Error: ZLib error %d at inflate end (%s)\n", error, stream.msg != NULL && *stream.msg != '\0' ? stream.msg : "no further details");
                              return EXIT_FAILURE;
                            }

                            /* Flag that zlib needs restarting next time around */

                            restart_zlib = true;

                            /* Set the item's attributes etc. */

                            e = _swix(OS_File,
                                      _INR(0,3) | _IN(5),

                                      1,
                                      fullname,
                                      loadaddr,
                                      execaddr,
                                      itemattr);

                            if (e != NULL)
                            {
                              printf("Error: %s", e->errmess);
                              return EXIT_FAILURE;
                            }

                            /* Report and flag completion of this item */

                            if (setup->verbose > 0) printf("File created\n");
                            completed = true;
                          }
                          else /* Not finished, so shouldn't have reached end of data */
                          {
                            if (reading_data >= size)
                            {
                              free(stubname);
                              free(fullname);
                              fclose(fout);
                              printf("Error: Ran out of input data before decompression completed\n");
                              return EXIT_FAILURE;
                            }
                          }
                        }
                      }
                      break;

                      default:
                      {
                        printf("Fatal internal error (3)\n");
                        exit(EXIT_FAILURE);
                      }
                      break;

                    } /* 'switch (stage)' */

                  } /* 'while (ptr < amount && reading_data < size) && !completed' */

                } /* 'if (subtype == 1 && ptr < amount)' */

                /* Did we finish that item? If so, reset this section of the state machine */
                /* ready for the next thing in the archive.                                */

                if (completed)
                {
                  free(stubname), stubname = NULL;
                  free(fullname), fullname = NULL;

                  expecting_stubname = true;
                  reading_stubname   = 0;
                  subtype            = 0;
                  stage              = 0;
                  completed          = false;
                }

              } /* 'case image_type_[permanent|resident|transient]:' */
              break;

              case image_type_os:
              case image_type_font:
              case image_type_exec:
              {
                unsigned int written, write;

                /* If not presently open, open the output file */

                if (fout == NULL)
                {
                  fout = fopen(setup->extract_to, "wb");
                  if (fout == NULL)
                  {
                    perror(setup->extract_to);
                    return EXIT_FAILURE;
                  }
                }

                /* Work out how much data we can write this time around and write it */

                write = size - reading_data;
                if (amount - ptr < write) write = amount - ptr;

                written = fwrite(buf + ptr, sizeof(char), write, fout);

                if (written != write)
                {
                  perror(setup->extract_to);
                  fclose(fout), fout = NULL;
                  return EXIT_FAILURE;
                }
                else ptr += written, reading_data += written;

                /* Finished? */

                if (reading_data == size)
                {
                  fclose(fout), fout = NULL;

                  /* Set filetype to &FE5, "EPROM" - assuming OS upgrade here since we */
                  /* don't really suport font or exec upgrade images yet.              */
                  /*                                                                   */
                  /* Don't really care if this SWI returns an error.                   */

                  _swix(OS_File,
                        _INR(0,2),

                        18,                /* 18 -> filetype is in R2 */
                        setup->extract_to,
                        Main_FileType_EPROM);
                }
              }
              break;
            }
          }
          break;

          default:
          {
            /* Just discard the data */

            while (reading_data < size && ptr < amount)
            {
              ptr++, reading_data++;
            }
          }
          break;
        }
      }

      if (reading_data == size)
      {
        if (setup->verbose > 0) printf("All data received\n");

        tag = size = 0;
        expecting_data = false;
        reading_size   = 0;
        expecting_tag  = true;
      }
    }
  }
  while (ptr < amount);

  return EXIT_SUCCESS;
}
