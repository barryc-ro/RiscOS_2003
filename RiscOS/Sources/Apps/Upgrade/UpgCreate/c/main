/**************************************************************/
/* File:    main.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: To run.                                           */
/*                                                            */
/* Author:  Nick Evans, Andrew Hodgkinson.                    */
/*                                                            */
/* History: 26-Sep-2000 (NE):  Created.                       */
/*          10-May-2001 (ADH): Bits of restructuring, various */
/*                             fixes.                         */
/**************************************************************/

#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <tcpiplibs/dirent.h>

#include <zlib/zlib.h>

#include "VersionNum"

#include "compress.h"
#include "config.h"
#include "crc32.h"
#include "Dirs.h"
#include "Utils.h"

#include "main.h"

/* 4 byte word */

#define WORD 4

/* Locals */

static char * type_names[] = {
                               "OS image",
                               "Font upgrade",
                               "Exec special",
                               "Transient executable",
                               "Resident executable",
                               "Permanent executable"
                             };

static char * bank_names[] = {
                               "(on-board)",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "(ROM card)"
                             };

/* Local functions */

static void write_record_header      (int record, int size, FILE * fp);
static int  write_string_record      (int record, char * string, FILE * fp);
static int  write_word_record        (int record, int data, FILE * fp);

static int  main_write_word          (unsigned int word, FILE * fp);
static int  main_output_crc          (int comp_size, FILE * fp);

static int  main_build_upgrade_file  (config * setup);
static int  main_build_single_file   (config * setup);
static int  main_build_archive_file  (config * setup);

static int main_add_files_to_archive (config * setup, unsigned int slen, FILE * fout, char * current);

/**************************************************************/
/* main()                                                     */
/*                                                            */
/* That which runs before all others.                         */
/**************************************************************/

int main(int argc, char * argv[])
{
  config setup; /* Contains data extracted from command line arguments */

  printf("UpgCreate %s\n\n", Module_HelpVersion);

  /* Ensure strings are empty to start with, and numerical quantites */
  /* are zeroed where required (e.g. bank number) or set where zero  */
  /* isn't appropriate (e.g. image type).                            */

  memset(&setup, 0, sizeof(setup));
  setup.type = image_type_unknown;

  if (config_read_args(&setup, argc, argv) != 0)
  {
    printf("Syntax: UpgCreate [options] <-s source> <-o output>\n\n"
           "-t (type)            OSImage | Transient | Resident | Permanent\n"
           "                     | Font | Exec (\"Font\" and \"Exec\" are presently\n"
           "                     not implemented)\n"
           "-c (card/bank)       If present, program given ROM bank rather\n"
           "                     than assuming FLASH ROM (bank 0). Presently\n"
           "                     only banks 0 (on-board) or 6 (card ROM) are\n"
           "                     understood (OS images only).\n"
           "-d (display)         \"display string\"\n"
           "-b (build)           \"build to match\" (OS images only)\n"
           "-l (locale)          \"one or more locales\" (OS images only)\n\n"
           "If -t is set to OSImage, then all of the above parameters MUST be\n"
           "supplied on the command line, except -c, which if omitted leads to the\n"
           "assumption that on-board FLASH ROM should be programmed, as opposed to\n"
           "card ROM (i.e. bank 0 rather than bank 6).\n\n"
           "If -t is set to any other value, then -d, -s and -o MUST be supplied\n"
           "on the command line. Other parameters, if present, will be ignored.");

    return 0;
  }

  printf("** Creating upgrade image...\n");

  printf("\nType:    %s"
         "\nDisplay: \"%s\""
         "\nBuild:   %s"
         "\nLocale:  %s"
         "\nBank:    %d %s"
         "\nInput:   %s"
         "\nOutput:  %s\n",

         (setup.type >= 0 && setup.type < (sizeof(type_names) / sizeof(*type_names))) ? type_names[setup.type] : "<Unknown!>",
         setup.display_string,
         (*setup.build  != '\0') ? setup.build  : "<None>",
         (*setup.locale != '\0') ? setup.locale : "<None>",
         setup.bank,
         (setup.bank >= 0 && setup.bank < (sizeof(bank_names) / sizeof(*bank_names)) && *bank_names[setup.bank] != '\0') ? bank_names[setup.bank] : "<Unknown!>",
         setup.image_path,
         setup.out_path);

  return main_build_upgrade_file(&setup);
}


/* write a record header */
static void write_record_header(int record,int size,FILE *fp)
{
  main_write_word(record, fp);
  main_write_word(size, fp);
}


/* write a variable length string record and return total size */
static int write_string_record(int record,char *string,FILE *fp)
{
  if(string[0]!=NULL)
  {
    write_record_header(record,strlen(string)+1,fp);
    fputs(string,fp);
    fputc(NULL,fp);   /* terminate it! */
    return (strlen(string) + 2*WORD+1);
  }
  else
    return 0;  /* no record to write */
}


/* write a single word record */
static int write_word_record(int record,int data,FILE *fp)
{
  write_record_header(record,WORD,fp);
  main_write_word(data, fp);
  return (3*WORD);
}

/**************************************************************/
/* main_write_word()                                          */
/*                                                            */
/* Write a word, assumed 32-bit, to the given output file,    */
/* least significant byte first.                              */
/*                                                            */
/* Parameters: 32-bit word to write;                          */
/*                                                            */
/*             Pointer to FILE describing output file.        */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_write_word(unsigned int word, FILE * fp)
{
  if      (fputc((word & 0xFF),             fp) == EOF) return EXIT_FAILURE;
  else if (fputc((word & 0xFF00)     >> 8,  fp) == EOF) return EXIT_FAILURE;
  else if (fputc((word & 0xFF0000)   >> 16, fp) == EOF) return EXIT_FAILURE;
  else if (fputc((word & 0xFF000000) >> 24, fp) == EOF) return EXIT_FAILURE;

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_output_crc()                                          */
/*                                                            */
/* Given a file open for read and write, rewind, calculate a  */
/* CRC based on all data in the file, and output it plus tag  */
/* 8 (pseudo-random value) at the end of the file.            */
/*                                                            */
/* Parameters: Value to EOR with CRC for pseudo-random data;  */
/*                                                            */
/*             Pointer to FILE describing output file.        */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_output_crc(int comp_size, FILE * fp)
{
  unsigned int crc;
  int          ch;

  printf("Calculating overall CRC\n");

  rewind(fp);
  make_crc_tables();

  /* CRC precondition */

  crc = 0xffffffff;

  while (feof(fp) == 0)
  {
    ch = fgetc(fp);

    if (ch == EOF) break;
    else update_crc((U8 *) &ch, (U32 *) &crc);
  }

  /* Note if we add any records beyond this point */
  /* we must update the size...                   */

  /* CRC postcondition */

  crc ^= 0xffffffff;

  printf("CRC = &%08X\n", crc);

  /* Now add the CRC */

  write_word_record(7, crc, fp);

  /* Now write the random data record to disguise the CRC */

  write_word_record(8, comp_size ^ crc, fp);

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_build_upgrade_file()                                  */
/*                                                            */
/* Build an upgrade archive based on the given configuration  */
/* structure.                                                 */
/*                                                            */
/* Parameters: Pointer to the config structure relevant to    */
/*             the upgrade archive to be built.               */
/*                                                            */
/* Returns:    EXIT_SUCCESS or EXIT_FAILURE as appropriate.   */
/**************************************************************/

static int main_build_upgrade_file(config * setup)
{
  /* What type of object is this? */

  switch (setup->type)
  {
    case image_type_os:
    case image_type_font:
    case image_type_exec: return main_build_single_file(setup);

    case image_type_transient:
    case image_type_resident:
    case image_type_permanent: return main_build_archive_file(setup);

    default:
    {
      printf("Do not know how to make type %d images\n", setup->type);
      return EXIT_FAILURE;
    }
  }

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_build_single_file()                                   */
/*                                                            */
/* Build an upgrade archive based around a single file - for  */
/* image types OS, font and exec only.                        */
/*                                                            */
/* Parameters: Pointer to the config structure relevant to    */
/*             the upgrade archive to be built.               */
/*                                                            */
/* Returns:    0 for success, non-zero for failure.           */
/**************************************************************/

static int main_build_single_file(config * setup)
{
  FILE         * fin;
  FILE         * fout;
  int            comp_size;      /* Compressed image size                  */
  long int       pos0;           /* Used to store record 0 file position   */
  long int       pos100;         /* Used to store record 100 file position */
  unsigned int   inputsize;      /* Input file size                        */
  long int       size;           /* Output file size                       */

  /* We need catalogue information on the input file */

  fin = fopen(setup->image_path, "rb");

  if (fin == NULL)
  {
    printf("Cannot open input file\n");
    return EXIT_FAILURE;
  }

  fseek(fin, 0, SEEK_END);
  inputsize = (unsigned int) ftell(fin);
  fclose(fin);
  fin = NULL;

  /* Open the output file */

  fout = fopen(setup->out_path, "wb+");

  if (fout==NULL)
  {
    printf("Cannot open output file\n");
    return EXIT_FAILURE;
  }

  /* Write record 0 header (file size) */

  write_record_header(0, WORD, fout);

  /* Store the current file position */

  pos0 = ftell(fout);

  /* Write some random rubbish into the file size record for now; */
  /* we will rewind later and put something sensible in.          */

  main_write_word(0, fout);

  /* Write record 1 (display message) */

  write_string_record(1, setup->display_string, fout);

  /* Write record 2 (build) */

  write_string_record(2, setup->build, fout);

  /* Write record 3 (locale) */

  write_string_record(3, setup->locale, fout);

  /* Write record 4 (image type) */

  write_word_record(4, setup->type, fout);

  /* Write record 5 (decompressed ROM size); this is meant to be in */
  /* MBytes, so we must round up to a whole MByte anything that's   */
  /* as little as 1 byte over the previous MByte boundary.          */

  inputsize = (inputsize + (1024 * 1024 - 1)) / (1024 * 1024);

  write_word_record(5, inputsize, fout);

  /* Write record 9 (ROM bank) */

  write_word_record(9, setup->bank, fout);

  /* Write record 6 (compressed image) header */

  main_write_word(6, fout);

  /* Store the record 100 size field file pointer */

  pos100 = ftell(fout);

  /* Write some random stuff into to record 100 size field for now */

  main_write_word(0, fout);

  /* Open the input file */

  fin = fopen(setup->image_path,"r");
  if (fin == NULL)
  {
    printf("Cannot open input file\n");
    return EXIT_FAILURE;
  }

  /* Compress the image file */

  comp_size = crunch(fin, fout);
  fclose(fin);

  /* Go back and write the real file size, accounting for adding tags 7 and 8 afterwards */

  size = ftell(fout) + 6 * sizeof(int);
  printf("Going back to record final output file size of %d bytes\n", (int) size);
  fseek(fout, pos0, SEEK_SET);
  main_write_word((int) size, fout);

  /* Write record 100 (compressed image size) */

  printf("Recording compressed data size of %d bytes\n", comp_size);
  fseek(fout, pos100, SEEK_SET);
  main_write_word(comp_size, fout);

  /* Calculate the CRC */

  if (main_output_crc(comp_size, fout) == EXIT_FAILURE)
  {
    printf("\nCouldn't write CRC information\n");
    fclose(fout);
    return EXIT_FAILURE;
  }

  /* Finished writing */

  fclose(fout);
  printf("\nSuccessful.");

  /* Optional expansion test to check it all worked:
   *
   * expand(setup->out_path,setup->image_path);
   */

return EXIT_SUCCESS;
}

/**************************************************************/
/* main_build_archive_file()                                  */
/*                                                            */
/* Build an upgrade archive based around multiple files for   */
/* execution - relevant for transient, resident and permanent */
/* types only.                                                */
/*                                                            */
/* Parameters: Pointer to the config structure relevant to    */
/*             the upgrade archive to be built.               */
/*                                                            */
/* Returns:    0 for success, non-zero for failure.           */
/**************************************************************/

static int main_build_archive_file(config * setup)
{
  FILE         * fout;
  long int       pos0;
  long int       size;
  unsigned int   slen;

  printf("\n");

  /* Open the output file */

  fout = fopen(setup->out_path,"w+");
  if (fout==NULL)
  {
    printf("Cannot open output file\n");
    return EXIT_FAILURE;
  }

  /* Write record 0 header (file size) */

  write_record_header (0, WORD, fout);

  /* Store the current file position */

  pos0 = ftell(fout);

  if (pos0 < 0)
  {
    fclose(fout);
    printf("Error reading file position in output file\n");
    return EXIT_FAILURE;
  }

  main_write_word(0, fout);

  write_string_record (1, setup->display_string, fout);
  write_string_record (2, setup->build,          fout);
  write_string_record (3, setup->locale,         fout);
  write_word_record   (4, setup->type,           fout);

  /* Put in the header for the archived files */

  write_record_header(6, WORD, fout);

  /* Get the length of setup->image_path up to and including the last '.' */

  slen = strlen(setup->image_path);

  while (slen > 0 && (setup->image_path)[slen - 1] != '.') slen--;

  if (slen == 0)
  {
    fclose(fout);
    printf("Could not form sensible path from output filename\n");
    return EXIT_FAILURE;
  }

  /* Now add all the files in */

  if (
       main_add_files_to_archive(setup,
                                 slen,
                                 fout,
                                 NULL)
       == EXIT_FAILURE
     )
  {
    fclose(fout);
    printf("Could not write all files to output file; aborting\n");
    return EXIT_FAILURE;
  }

  printf("All files added\n\n");

  /* Go back and write the file size */

  size = ftell(fout);
  printf("Going back to record final output file size of %d bytes\n", (int) size);
  fseek(fout, pos0, SEEK_SET);
  main_write_word((int) size, fout);

  /* Calculate the CRC */

  if (main_output_crc(rand(), fout) == EXIT_FAILURE)
  {
    printf("\nCouldn't write CRC information\n");
    fclose(fout);
    return EXIT_FAILURE;
  }

  /* Finished writing */

  printf("\nSuccessful.");
  fclose(fout);

  /* Optional expansion test to check it all worked:
   *
   * expand(setup->out_path,setup->image_path);
   */

  return EXIT_SUCCESS;
}

/**************************************************************/
/* main_add_files_to_archive()                                */
/*                                                            */
/* Once main_build_archive_file() has done the preamble, this */
/* adds all files to the archive. Its operation is recursive, */
/* going into directories as need be.                         */
/*                                                            */
/* Parameters: Pointer to the config structure relevant to    */
/*             the upgrade archive being built;               */
/*                                                            */
/*             Length of config's "image_path" *path* (i.e.   */
/*             take "image_path" and wind back to the '.',    */
/*             and include this in the count) - avoids having */
/*             to recalculate this internally at each         */
/*             recursion level;                               */
/*                                                            */
/*             Pointer to FILE struct describing output file. */
/*                                                            */
/*             NULL for outer level call, else a pathname for */
/*             inner recursion during directory scanning.     */
/*                                                            */
/* Returns:    0 for success, non-zero for failure.           */
/**************************************************************/

static int main_add_files_to_archive(config * setup, unsigned int slen, FILE * fout, char * current)
{
  /* Note the restrictions that using this static buffer places on the */
  /* order we rely on calling ourselves recursively with respect to    */
  /* directory contents.                                               */

  static char    path[MAXNAMLEN * 2 + 1];
  char         * leaf;
  unsigned int   leaflen, written;

  if (current == NULL) current = setup->image_path;

  /* Output this item's filename */

  leaf    = current + slen;
  leaflen = strlen(leaf);

  if (leaflen == 0)
  {
    printf("Can't get a sensible leafname from current path\n");
    return EXIT_FAILURE;
  }

  written = fwrite(current + slen,
                   sizeof(char),
                   leaflen + 1,
                   fout);

  if (written <= leaflen)
  {
    printf("Couldn't write item's filename to output file\n");
    return EXIT_FAILURE;
  }

  /* Handle directories or files differently */

  if (dirs_is_dir(current))
  {
    DIR           * dir;
    struct dirent * entry;
    unsigned int    len;

    /* This is a directory */

    printf("Dir : '%s'\n", current + slen);

    /* Output subtype byte */

    if (fputc(Main_SubType_Directory, fout) == EOF)
    {
      printf("Couldn't write subtype byte to output file\n");
      return EXIT_FAILURE;
    }

    /* Open it and dive in */

    dir = dirs_open_dir(current);

    if (dir == NULL)
    {
      printf("Out of memory!\n");
      return EXIT_FAILURE;
    }

    /* Write the basic path to the static buffer and remember */
    /* the length of it.                                      */

    StrNCpy0(path, current);
    len = strlen(path);

    /* Go round all entries */

    while ((entry = dirs_read_dir(dir)) != NULL)
    {
      /* Will the full pathname of this item fit in the buffer? */

      if (len + 2 + strlen(entry->d_name) > sizeof(path))
      {
        /* No - bail out */

        printf("Pathname buffer overflow\n");
        return EXIT_FAILURE;
      }
      else
      {
        /* Yes - write the leaf in */

        path[len] = '.';
        strcpy(path + len + 1, entry->d_name);

        if (main_add_files_to_archive(setup, slen, fout, path) == EXIT_FAILURE) return EXIT_FAILURE;
      }
    }

    dirs_close_dir(dir);
  }
  else
  {
    unsigned int      itemtype, loadaddr, execaddr, itemsize, itemattr;
    _kernel_oserror * e;
    FILE            * fin;

    /* We've got a file */

    printf("File: '%s'\n", current + slen);

    /* Output subtype byte */

    if (fputc(Main_SubType_File, fout) == EOF)
    {
      printf("Couldn't write subtype byte to output file\n");
      return EXIT_FAILURE;
    }

    /* Write the load and execution addresses */

    e = _swix(OS_File,
              _INR(0,1) | _OUT(0) | _OUTR(2,5),

              17, /* Read file information with no special path prefix on R1 */
              current,

              &itemtype,
              &loadaddr,
              &execaddr,
              &itemsize,
              &itemattr);

    if (e != NULL)
    {
      printf("OS_File error '%s'\n", e->errmess);
      return EXIT_FAILURE;
    }
    else if (itemtype == 0)
    {
      printf("Cannot find current file '%s'\n", current);
      return EXIT_FAILURE;
    }

    if (
         main_write_word(itemsize, fout) == EXIT_FAILURE ||
         main_write_word(loadaddr, fout) == EXIT_FAILURE ||
         main_write_word(execaddr, fout) == EXIT_FAILURE ||
         main_write_word(itemattr, fout) == EXIT_FAILURE
       )
    {
      printf("Cannot write item's details to output file\n");
      return EXIT_FAILURE;
    }

    /* OK, compress it */

    fin = fopen(current, "rb");

    if (fin == NULL)
    {
      printf("Cannot open item for compression to output file\n");
      return EXIT_FAILURE;
    }
    else
    {
      crunch(fin, fout);
      fclose(fin);
    }
  }

  return EXIT_SUCCESS;
}
