
#include <stdio.h>
#include <string.h>
#include <zlib/zlib.h>

//a number of codes used by the error handler to identify which
//function has generated an eror

#define INIT 1
#define DEFLATE 2
#define DEFLATE_END 3
#define INFLATE 4

#define SIZEOF_INPUTBUFFER 32768
#define SIZEOF_OUTPUTBUFFER SIZEOF_INPUTBUFFER

void err_handle(int err,int function);
int fill_nextin(z_streamp stream,FILE *fp);
int write_file(z_streamp stream,FILE *fp);


int crunch(FILE *fin,FILE *fp_out)
{
   int err,size=0;

   char input_buffer [SIZEOF_INPUTBUFFER];
   char output_buffer[SIZEOF_OUTPUTBUFFER];

   z_stream stream;
   stream.zalloc = Z_NULL;
   stream.zfree  = Z_NULL;
   stream.opaque = Z_NULL;
   stream.next_in =  (Bytef *)input_buffer;
   stream.next_out = (Bytef *)output_buffer;
   stream.avail_out = SIZEOF_OUTPUTBUFFER;
   stream.avail_in = 0;

   err = deflateInit(&stream,Z_BEST_COMPRESSION);
   err_handle(err,INIT);

   //now deflate the file
   do
   {

     if(stream.avail_in==0)
     {
       stream.next_in =  (Bytef *)input_buffer;  //need to do this because
                                                 //zlib update next_in as it
                                                 //move through the buffer
       //fill_nextin returns zero if OK
       //break out loop if it return anything else (hopefully an EOF!)
       if (fill_nextin(&stream,fin))
         {
           break;  //if we have no more input we can jump to the flush routine
         }
     }
     err=deflate(&stream,Z_NO_FLUSH);
     err_handle(err,DEFLATE);
     //point next_out back to the start of the output buffer
     //we use this to output the contents, also this is used by deflate
     //to write new data after the buffer has been emptyed.
     stream.next_out =  (Bytef *)output_buffer;
     size+=write_file(&stream,fp_out);
   }
   while (!err);


   //now flush any stuff remaining in buffers

   while (!err)
   {
     err=deflate(&stream,Z_FINISH);
     err_handle(err,DEFLATE);
     stream.next_out =  (Bytef *)output_buffer;
     size+=write_file(&stream,fp_out);
   }

   err=deflateEnd(&stream);
   err_handle(err,DEFLATE_END);

   printf("Finished Compression\n");

   return size;
}

int expand(char *deflated,char *inflated)
{
   FILE *fp,*fp_out;

   char input_buffer [SIZEOF_INPUTBUFFER];
   char output_buffer[SIZEOF_OUTPUTBUFFER];
   int err,tag,length,l;

   z_stream stream;
   stream.zalloc = Z_NULL;
   stream.zfree  = Z_NULL;
   stream.opaque = Z_NULL;
   stream.next_in =  (Bytef *)input_buffer;
   stream.next_out = (Bytef *)output_buffer;
   stream.avail_out = SIZEOF_OUTPUTBUFFER;
   stream.avail_in = 0;

   //Now do the Decompression test!

   printf("\nDoing test decompression\n");

   strcat(inflated,"T");
   fp_out = fopen(inflated,"w");

   if (fp_out==NULL)
     printf("Cannot open inflate file");

   fp = fopen(deflated,"r");
   if (fp==NULL)
     printf("Cannot open deflated file");

   err = inflateInit(&stream);
   err_handle(err,INIT);

   //ignore the tags were not interested in
   do
   {
     fread(&tag,sizeof(int),1,fp);
     fread(&length,sizeof(int),1,fp);
     printf("tag %d, length %d\n",tag,length);
     //move to the end of the data
     if (tag != 6) for(l=0;l<length;l++) fgetc(fp);
   }
   while (tag != 6);


    //inflate the file
   do
   {
     if(stream.avail_in==0)
     {
       stream.next_in =  (Bytef *)input_buffer;
       if (fill_nextin(&stream,fp))
         {
           fclose(fp);
           break;  //if we have no more input we can jump to the flush routine
         }
     }
     err=inflate(&stream,Z_SYNC_FLUSH);
     err_handle(err,INFLATE);
     stream.next_out =  (Bytef *)output_buffer;
     write_file(&stream,fp_out);
   }
   while (!err);

   while (!err)
   {
     err=inflate(&stream,Z_SYNC_FLUSH);
     err_handle(err,INFLATE);
     stream.next_out =  (Bytef *)output_buffer;
     write_file(&stream,fp_out);
   }


   fclose(fp_out);
   fclose(fp);

   return err;
}

void err_handle(int err,int function)
{
  if (err != 0)
  {
    switch(function)
    {
      case INIT:
       printf("Init error -%d\n",err);
      break;

      case DEFLATE:
       printf("Deflate error - %d\n",err);
      break;

      case DEFLATE_END:
       printf("Deflate end - %d\n",err);
      break;

      case INFLATE:
       printf("Inflate error -%d\n",err);
      break;
    }
  }
}

int fill_nextin(z_streamp stream,FILE *fp)
{
  unsigned int i=0;
  char *buffer=(char *)stream->next_in;
  char c;

 while(stream->avail_in<SIZEOF_INPUTBUFFER)
  {
   c=fgetc(fp);
   if(feof(fp)) return 1;
   buffer[i++]=c;
   stream->avail_in++;
  }

  return 0;
}

int write_file(z_streamp stream,FILE *fp)
{
  char *buffer=(char *)stream->next_out;
  int i=0;

  while((stream->avail_out)<SIZEOF_OUTPUTBUFFER)
  {
    putc(buffer[i++],fp);
    stream->avail_out++;
  }

  //return bytes written
  return i;
}



