/* > standby.c * *      Standby code. */

#include <stdlib.h>
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "flashprog.h"
#include "error.h"

/* Errors */
ERROR_STRUCT(BADTYPES, "Unknown type of flash");
ERROR_STRUCT(BADPARAMS, "Bad parameters");
ERROR_STRUCT(LOCKED, "Device is busy");
ERROR_STRUCT(BADHARD, "Bad hardware");

/* Addressing stuff */
#define DEFUALT_PODULE	1
#define EASI_SPACE	0x88000000U

#define PODULE_OFFSET	0
#define POWER_OFFSET	0x400000
#define FLASH_OFFSET	0x800000
#define SLEDGE_OFFSET	0xC00000

#define MEG		(1024*1024)

/* Return values */
#define RET_DONE	0		/* Completed OK */
#define RET_PENDING	1		/* Request has been queued */
#define RET_BUSY	2		/* Device is too busy at the moment */

/* IDs */
#define MAN_INTEL	0x0089
#define	DEV_28F016Sx	0x66A0

/* 28F008SA-compatible commands (16bit-wide, replicated to 32bits) */
#define WRITE_WORD	0x40404040
#define READ_ID		0x00900090
#define READ_ARRAY	0x00FF00FF

/* 28F016SA/SV commands (16bit-wide, replicated to 32bits) */
#define CLEAR_SR	0x00500050
#define READ_ESR	0x00710071
#define ERASE_ALL	0x00A700A7
#define ERASE_CONFIRM	0x00D000D0
#define LOAD_PB		0x00E000E0
#define WRITE_PB	0x000C000C

/* IDs (accessible after READ_ID but not during WSM operation) */
#define MAN_ADDR	0
#define DEV_ADDR	1

/* BSR (accessible after READ_ESR or during WSM operation) */
#define BSR_ADDR	1
#define BSR_READY	0x00800080
#define BSR_BOS_ERROR	0x00200020
#define BSR_QUEUE_FULL	0x00080008

/* GSR (accessible after READ_ESR or during WSM operation) */
#define GSR_ADDR	2
#define GSR_WSMS_READY	0x00800080
#define GSR_DOS_ERROR	0x00200020
#define GSR_QUEUE_FULL	0x00080008
#define GSR_PB_AVAIL	0x00040004


/*
 * Types
 */
typedef struct
{
  volatile unsigned int power	:1;
  volatile unsigned int 	:0;
  union
  {
    struct bits
    {
      volatile unsigned int control	:1;
      volatile unsigned int databus	:1;
      volatile unsigned int addrbus	:1;
      volatile unsigned int 		:0;
    };
    volatile unsigned int all_signals;
  } signals;
  volatile unsigned int program;
} power_control_t;


/*
 * Variables
 */
static volatile power_control_t *power_control;
static int man=0, dev=0, size=0, blocksize=0, writesize=0, pending=0;
static unsigned int easi_base;
static volatile unsigned int *flash;


/*
 * Functions
 */
void power_up(void)
{
  power_control->power = 1;
  power_control->signals.all_signals = 7;
}

void power_down(void)
{
  power_control->program = 0;
  power_control->signals.all_signals = 0;
  power_control->power = 0;
}


_kernel_oserror *flash_initialise( void *pw, int podule_base )
{
  if (podule_base < 0x3000000)
    easi_base = (DEFUALT_PODULE<<24) + EASI_SPACE;
  else
  {
    /* Get EASI address using podule_base */
    _swix(Podule_ReadInfo, _IN(0)|_IN(1)|_IN(2)|_IN(3),
          1<<9, &easi_base, sizeof(easi_base), podule_base);
  }
  power_control = (void *) (easi_base + POWER_OFFSET);
  flash = (void *) (easi_base + FLASH_OFFSET);
  
  return NULL;
}

extern void flash_finalise( void *pw )
{
  power_down();
}


/*
 * SWI Flash_Info
 *
 * Power up the flash card and get info about it.
 * Card should not be ejected until Flash_Release is called.
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 *
 *   IN
 *
 *   OUT
 *     r0:  Address of flash
 *     r1:  Manufacturer code (0 if garbage recognised)
 *     r2:  Device code       (0 if garbage recognised)
 *     r3:  Amount of flash fitted  [bytes] (0 if device unrecognised)
 *     r4:  Erase block granularity [bytes] (0 if device unrecognised)
 *     r5:  Maximum size of a write [bytes] (0 if device unrecognised)
 */
_kernel_oserror *flash_info( _kernel_swi_regs *r )
{
  /* Can't do anything if WSM is in operation */
  if (pending)
    return ERROR(LOCKED);

  r->r[0] = (int) flash;

  power_up();
  *flash = READ_ID;			/* Get ID stuff */
  man = flash[MAN_ADDR];
  dev = flash[DEV_ADDR];

  /* Check same in both 16-bit halves, otherwise its garbage */
  if (((man & 0xffff) != (man >> 16)) || ((dev & 0xffff) != (dev >> 16)))
  {
    *flash = READ_ARRAY;		/* Restore normality */
    r->r[1] = r->r[2] = r->r[3] = r->r[4] = 0;
    man = dev = 0;
    return NULL;
  }
  
  r->r[1] = (man &= 0xffff);
  r->r[2] = (dev &= 0xffff);

  if ((man == MAN_INTEL) && (dev == DEV_28F016Sx))
  {
    r->r[4] = blocksize = 128*1024;	/* Each device in pair = 64Kbytes */
    r->r[5] = writesize = 512;		/* pagebuffer=256 bytes * 2 devices */

    /* If IDs also appear at 4M, then its a ghost and only 4M is fitted */
    if ((flash[MEG+MAN_ADDR] == ((MAN_INTEL<<16) | MAN_INTEL)) &&
        (flash[MEG+DEV_ADDR] == ((DEV_28F016Sx<<16) | DEV_28F016Sx)))
    {
      *flash = READ_ARRAY;		/* Restore normality */
      r->r[3] = size = 4*MEG;
    }
    else
    {
      int man2, dev2;
      *flash = READ_ARRAY;		/* Restore normality on 1st bank */
      
      /* Look again for IDs at 4Meg to see two pairs of chips are fitted */
      flash[MEG] = READ_ID;		/* Get ID stuff */
      man2 = flash[MEG+MAN_ADDR];
      dev2 = flash[MEG+DEV_ADDR];
      flash[MEG] = READ_ARRAY;		/* Restore normality on 2nd bank */
    
      if (((man2 & 0xffff) == (man2 >> 16)) &&
          ((dev2 & 0xffff) == (dev2 >> 16)) &&
          ((man2 & 0xffff) == MAN_INTEL) &&
          ((dev2 & 0xffff) == DEV_28F016Sx))
        r->r[3] = size = 8*MEG;
      else
        r->r[3] = size = 4*MEG;
    }
  }
  else
  {
    r->r[3] = r->r[4] = r->r[5] = size = 0;	/* Dunno about this device */
  }

  return NULL;
}


/*
 * SWI Flash_Read
 *
 * Read bytes from flash
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 *
 *   IN
 *     r0-> Buffer
 *     r1:  Offset from start of flash (is rounded down to multiple of 4)
 *     r2:  Number of bytes to read (is rounded up to multiple of 4)
 *
 *   OUT
 *     r0:  RET_DONE
 */
_kernel_oserror *flash_read( _kernel_swi_regs *r )
{
  volatile unsigned int *src = flash + (r->r[1] / 4);
  unsigned int *dst = (unsigned int *) r->r[0];
  unsigned int len = (3 + r->r[2]) / 4;
  
  /* Only know about this kind of flash */
  if ((man != MAN_INTEL) || (dev != DEV_28F016Sx))
    return ERROR(BADTYPES);

  /* Can't do anything if WSM is in operation */
  if (pending)
    return ERROR(LOCKED);

  while (len--)
    *(dst++) = *(src++);

  r->r[0] = RET_DONE;
  return NULL;
}


/*
 * SWI Flash_Erase
 *
 * Erases entire flash
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 *
 *   IN
 *
 *   OUT
 *     r0:  RET_PENDING
 */
_kernel_oserror *flash_erase( _kernel_swi_regs *r )
{
  /* Only know about this kind of flash */
  if ((man != MAN_INTEL) || (dev != DEV_28F016Sx))
    return ERROR(BADTYPES);
    
  /* Can't do anything if WSM is in operation */
  /* Actually, we probably could but it makes things simpler if we don't */
  if (pending)
    return ERROR(LOCKED);

  *flash = READ_ESR;
  if (flash[BSR_ADDR] & BSR_QUEUE_FULL)
  {
    /* This should never happen if !pending */
    *flash = READ_ARRAY;		/* Try to Restore normality */
    return ERROR(LOCKED);
  }
  
  if (size > (4*MEG))
  {
    flash[MEG] = READ_ESR;
    if (flash[MEG+BSR_ADDR] & BSR_QUEUE_FULL)
    {
      /* This should never happen if !pending */
      *flash = READ_ARRAY;		/* Try to restore normality */
      flash[MEG] = READ_ARRAY;
      return ERROR(LOCKED);
    }
  }
  
  power_control->program = 1;
  *flash = ERASE_ALL;
  *flash = ERASE_CONFIRM;
  if (size > (4*MEG))
  {
    flash[MEG] = ERASE_ALL;
    flash[MEG] = ERASE_CONFIRM;
  }
  
  pending = 1;
  r->r[0] = RET_PENDING;
  return NULL;
}


/*
 * SWI Flash_Write
 *
 * Write to flash
 * Number of bytes (r2) must not be greater than the value returned in r5
 * from Flash_info.
 * Results are undefined if r2 is less than the value returned in r5 from
 * Flash_info.
 *
 *   IN
 *     r0-> Buffer
 *     r1:  Offset from start of flash (is rounded down to multiple of 4)
 *     r2:  Number of bytes to write (is rounded down to multiple of 4)
 *
 *   OUT
 *     r0:  RET_PENDING or RET_BUSY
 */
_kernel_oserror *flash_write( _kernel_swi_regs *r )
{
  volatile unsigned int *block = flash + ((r->r[1] & ~(blocksize-1)) / 4);
  volatile unsigned int *chip = flash + (((r->r[1] / 4) < MEG) ? 0 : MEG);
  volatile unsigned int *dst = flash + (r->r[1] / 4);
  unsigned int *src = (unsigned int *) r->r[0];
  unsigned int len = r->r[2] / 4;
  unsigned int pb_offset = ((r->r[1] & (writesize-1)) / 4);

  /* Length to write in half-words, replicated in both 16-bits of 32bit word */
  unsigned int i, lenpattern = (len - 1) + ((len - 1)<<16);

  if (len>writesize/4)
    return ERROR(BADPARAMS);
  
  if (pending)
  {
    /* Check if still busy (erasing) */
    if (flash[BSR_ADDR] & BSR_QUEUE_FULL)
    {
      r->r[0] = RET_BUSY;
      return NULL;
    }

    if (size > (4*MEG))
      if (flash[MEG+BSR_ADDR] & BSR_QUEUE_FULL)
      {
        r->r[0] = RET_BUSY;
        return NULL;
      }
      
    pending = 0;
    
    /* Check last operation completed successfully */
    if ((flash[GSR_ADDR] & GSR_DOS_ERROR) ||
        ((size > (4*MEG)) && (flash[MEG+GSR_ADDR] & GSR_DOS_ERROR)))
    {
      power_control->program = 0;
      return ERROR(BADHARD);
    }

    /* Clear prior status bits */
    *flash = CLEAR_SR;
    flash[MEG] = CLEAR_SR;
  }

  /* OK, start the write */
  *chip = READ_ESR;

  /* Check for WSM queue and page buffer availability */
  if ((block[BSR_ADDR] & BSR_QUEUE_FULL) ||
      ((block[GSR_ADDR] & GSR_PB_AVAIL) != GSR_PB_AVAIL))
  {
    DEBUGFN(printf("Busy! BSR=%x, GSR=%x\n", block[BSR_ADDR], block[GSR_ADDR]));
    r->r[0] = RET_BUSY;
    return NULL;
  }    

#ifdef DEBUG
  printf("chip=%p\n", chip);
  printf("BSR=%x, GSR=%x\n", block[BSR_ADDR], block[GSR_ADDR]);
  printf("block offset=%x\n", ((int) block) - ((int) flash));
  printf("write offset=%x\n", ((int) dst) - ((int) flash));
  printf("Length pattern=%x\n", lenpattern);
  printf("pb offset=%x\n", pb_offset);
#endif

  power_control->program = 1;

  /* Write length followed by data to page buffer */
  *block = LOAD_PB;
  block[pb_offset] = lenpattern;	/* LSB of word count */
  block[pb_offset] = 0;			/* MSB of word count & buffer offset */
  for (i=0; i<len; i++)
    block[pb_offset+i] = src[i];

  DEBUGFN(printf("BSR=%x, GSR=%x\n", block[BSR_ADDR], block[GSR_ADDR]));

  /* Write page buffer to flash */
  *dst = WRITE_PB;
  *dst = lenpattern;			/* LSB of word count */
  *dst = 0;				/* MSB of word count & address */

  do
  {
    /* XXX We could drop into user mode here to let callbacks happen !!! */
    DEBUGFN(printf("Wait: BSR=%x, GSR=%x\n", chip[BSR_ADDR], chip[GSR_ADDR]));
  } while ((chip[GSR_ADDR] & GSR_WSMS_READY) != GSR_WSMS_READY);

  power_control->program = 0;

  /* Check for failure */
  if (chip[GSR_ADDR] & GSR_DOS_ERROR)
  {
    return ERROR(BADHARD);
  }
  
  *chip = CLEAR_SR;			/* Restore normality */

  r->r[0] = RET_DONE;
  return NULL;
}


/*
 * SWI Flash_Status
 *
 * Poll for status of flash device after previous SWI returned PENDING / BUSY
 *
 *   IN
 *
 *   OUT
 *     r0:  RET_DONE, RET_PENDING or RET_BUSY
 */
_kernel_oserror *flash_status( _kernel_swi_regs *r )
{
  /* Only know about this kind of flash */
  if ((man != MAN_INTEL) || (dev != DEV_28F016Sx))
    return ERROR(BADTYPES);
  
  if (!pending)
  {
    r->r[0] = RET_DONE;
    return NULL;
  }

  /*
   * Despite what figure 11-15 of the manual advises, doing the following causes
   * the WSM to suspend (the OSS bit in the GSR gets set). So we don't do it.
   */
#if 0
  *flash = READ_ESR;
#endif

  if (flash[BSR_ADDR] & BSR_QUEUE_FULL)
  {
    r->r[0] = RET_BUSY;
    return NULL;
  }

  if (size > (4*MEG))
  {
#if 0	/* See above */
    flash[MEG] = READ_ESR;
#endif
    if (flash[MEG+BSR_ADDR] & BSR_QUEUE_FULL)
    {
      r->r[0] = RET_BUSY;
      return NULL;
    }
  }

  if ((flash[GSR_ADDR] & GSR_WSMS_READY) != GSR_WSMS_READY)
  {
    r->r[0] = RET_PENDING;
    return NULL;
  }

  if (size > (4*MEG))
  {
#if 0	/* See above */
    flash[MEG] = READ_ESR;
#endif
    if ((flash[MEG+GSR_ADDR] & GSR_WSMS_READY) != GSR_WSMS_READY)
    {
      r->r[0] = RET_PENDING;
      return NULL;
    }
  }
  
  if ((flash[GSR_ADDR] & GSR_DOS_ERROR) ||
      ((size > (4*MEG)) && (flash[MEG+GSR_ADDR] & GSR_DOS_ERROR)))
  {
#if 0
    *flash = CLEAR_SR;
    *flash = READ_ARRAY;
    flash[MEG] = CLEAR_SR;
    flash[MEG] = READ_ARRAY;
#endif
    pending = 0;		/* So Flash_Release doesn't fail */
    power_control->program = 0;
    return ERROR(BADHARD);
  }

  DEBUGFN(printf("BSR=%x, GSR=%x\n", flash[BSR_ADDR], flash[GSR_ADDR]));
  
  power_control->program = 0;
  *flash = CLEAR_SR;
  flash[MEG] = CLEAR_SR;

  pending = 0;
  r->r[0] = RET_DONE;
  return NULL;  
}

/*
 * SWI Flash_Release
 *
 * Allow ejection of flash card
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 *
 *   IN
 *
 *   OUT
 */
_kernel_oserror *flash_release( _kernel_swi_regs *r )
{
  /* Shouldn't power-down if WSM is in operation */
  if (pending)
    return ERROR(LOCKED);

  man = dev = size = blocksize = writesize = pending = 0;
  power_down();

  return NULL;
}

