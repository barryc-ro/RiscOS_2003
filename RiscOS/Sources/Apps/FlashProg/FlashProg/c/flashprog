/* Changes
   0.12  TC Correct bugs in 8Meg recognition
         TC Return Power status in R1 from Flash_Status
         TC Add support for 12Meg and 16Meg cards

*/

//#ifdef DEBUG
#include <stdio.h>
//#endif
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"
#include "time.h"

#include "module.h"
#include "flashprog.h"
#include "error.h"

/* Errors */
ERROR_STRUCT(BADTYPES, "Unknown type of flash");
ERROR_STRUCT(BADPARAMS, "Bad parameters");
ERROR_STRUCT(LOCKED, "Device is busy");
ERROR_STRUCT(BADHARD, "Bad hardware");

/* Addressing stuff */
#define DEFUALT_PODULE	0		/* Hack for testing when softloaded */
#define EASI_SPACE	0x88000000U

#define ROM_OFFSET	0
#define POWER_OFFSET	0x400000
#define ENABLE_OFFSET	0x400004 /* also defined as power_control->program */
#define PROGCTRL_OFFSET	0x400008
#define VOLTINFO_OFFSET	0x40000C
#define FLASH_OFFSET	0x800000
#define SLEDGE_OFFSET	0xC00000

#define TWELVE_VOLTS	1
#define FIVE_VOLTS	2
#define PAGE1	4
#define PAGE0	0
#define SETPAGE1	power_control->program = (programcopy & 3) | PAGE1
#define SETPAGE0	power_control->program = (programcopy & 3) | PAGE0

#define MEG		(1024*1024)
#define MEG2MASK		(2*MEG-1)
#define MEG8MASK		(8*MEG-1)

/* Return values */
#define RET_DONE	0		/* Completed OK */
#define RET_PENDING	1		/* Request has been queued */
#define RET_BUSY	2		/* Device is too busy at the moment */

/* IDs */
#define MAN_INTEL	0x0089
#define MAN_SHARP	0x00B0
#define	DEV_28F016Su	0x6688
#define	DEV_28F016Sx	0x66A0

#define	PROG_VOLTAGE	((dev) == DEV_28F016Su ? FIVE_VOLTS : TWELVE_VOLTS)

/* 28F008SA-compatible commands (16bit-wide, replicated to 32bits) */
#define WRITE_WORD	0x40404040
#define READ_ID		0x00900090
#define READ_ARRAY	0x00FF00FF

/* 28F016SA/SV commands (16bit-wide, replicated to 32bits) */
#define CLEAR_SR	0x00500050
#define READ_ESR	0x00710071
#define ERASE_ALL	0x00A700A7
#define ERASE_CONFIRM	0x00D000D0
#define LOAD_PB		0x00E000E0
#define WRITE_PB	0x000C000C
#define ABORT	0x00800080
#define ERASE_SUSPEND	0x00B000B0
#define ERASE_RESUME	0x00D000D0

/* IDs (accessible after READ_ID but not during WSM operation) */
#define MAN_ADDR	0
#define DEV_ADDR	1

/* BSR (accessible after READ_ESR or during WSM operation) */
#define BSR_ADDR	1
#define BSR_READY	0x00800080
#define BSR_BOS_ERROR	0x00200020
#define BSR_QUEUE_FULL	0x00080008

/* GSR (accessible after READ_ESR or during WSM operation) */
#define GSR_ADDR	2
#define GSR_WSMS_READY	0x00800080
#define GSR_DOS_ERROR	0x00200020
#define GSR_QUEUE_FULL	0x00080008
#define GSR_PB_AVAIL	0x00040004

/* Do we recognise this flash? */
#define RECOGNISE(man,dev)					\
	((((man) == MAN_INTEL) || ((man) == MAN_SHARP)) &&	\
	 (((dev) == DEV_28F016Sx) || ((dev) == DEV_28F016Su)))
#define CHECKMANDEV(man,dev) \
	(((man & 0xffff) == (man >> 16)) && \
	((dev & 0xffff) == (dev >> 16)) && \
	(man != READ_ID) || (dev != READ_ID))

/*
 * Types
 */
typedef struct
{
  volatile unsigned int power	:1;
  volatile unsigned int 	:0;
  union
  {
    struct bits
    {
      volatile unsigned int control	:1;
      volatile unsigned int databus	:1;
      volatile unsigned int addrbus	:1;
      volatile unsigned int 		:0;
    };
    volatile unsigned int all_signals;
  } signals;
  volatile unsigned int program;
  volatile unsigned int powerstatus;
} power_control_t;


/*
 * Variables
 */
static volatile power_control_t *power_control;
static int man=0, dev=0, size=0, blocksize=0, writesize=0, width, widthmask;
static int pending=0,pending1=0,pcopy=0,pcopy1=0;
static unsigned int easi_base;
static volatile unsigned int *flash;
static int programcopy=0;


/*
 * Functions
 */
void power_up(void)
{
  clock_t done;
  power_control->power = 1;
  power_control->signals.all_signals = 7;

  /* Delay for >50ms to give Vcc time to settle */
  done = clock() + 1 + (int) (CLOCKS_PER_SEC * 50e-3);
  while (clock() < done);
}

void power_down(void)
{
  power_control->program = programcopy = 0;
  power_control->signals.all_signals = 0;
  power_control->power = 0;
}

_kernel_oserror *flash_initialise( void *pw, int podule_base )
{
  if (podule_base < 0x3000000)
    easi_base = (DEFUALT_PODULE<<24) + EASI_SPACE;
  else
  {
    /* Get EASI address using podule_base */
    _swix(Podule_ReadInfo, _IN(0)|_IN(1)|_IN(2)|_IN(3),
          1<<9, &easi_base, sizeof(easi_base), podule_base);
  }
  power_control = (void *) (easi_base + POWER_OFFSET);

  return NULL;
}

extern void flash_finalise( void *pw )
{
  power_down();
}

/*
 * SWI Flash_Info
 *
 * Power up the flash card and get info about it.
 * Card should not be ejected until Flash_Release is called.
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 *
 *   IN
 *
 *   OUT
 *     r0:  Address of flash
 *     r1:  Manufacturer code (0 if garbage recognised)
 *     r2:  Device code       (0 if garbage recognised)
 *     r3:  Amount of flash fitted  [bytes] (0 if device unrecognised)
 *     r4:  Erase block granularity [bytes] (0 if device unrecognised)
 *     r5:  Maximum size of a write [bytes] (0 if device unrecognised)
 *     r6:  Device width [bytes] (4, 2 or 1)
 */
_kernel_oserror *flash_info( _kernel_swi_regs *r )
{
  /* Can't do anything if WSM is in operation */
  if (pending | pending1)
    return ERROR(LOCKED);

  power_up();

  flash = (void *) (easi_base + FLASH_OFFSET);
  r->r[0] = (int) flash;

  *flash = READ_ID;man = flash[MAN_ADDR];dev = flash[DEV_ADDR];

  DEBUGFN(printf("Checking first half man=%x dev=%x\n",man,dev));
  /* See if same in both 16-bit halves, ie 32-bit wide pair of 16-bit devices */
  /* and ensure we're not just reading back the latched value we just wrote */
  if (CHECKMANDEV(man,dev))
  {
    r->r[6] = width = 4;widthmask = 0xffffffff;r->r[1] = (man &= 0xffff);r->r[2] = (dev &= 0xffff);

    if (RECOGNISE(man,dev))
    {
      r->r[4] = blocksize = 128*1024;	/* Each device in pair = 64Kbytes */
      r->r[5] = writesize = 512;	/* pagebuffer=256 bytes * 2 devices */

      /* If IDs also appear at 4M, then its a ghost and only 4M is fitted */
      if (((flash[MEG+MAN_ADDR] & 0xffff) == man) && ((flash[MEG+DEV_ADDR] & 0xffff) == dev))
      {
        DEBUGFN(printf("Ghost found\n"));

        *flash = READ_ARRAY;		/* Restore normality */
        r->r[3] = size = 4*MEG;
      }
      else /*not Ghost*/
      {
        int man2, dev2;
        *flash = READ_ARRAY;		/* Restore normality on 1st bank */

        /* Look again for IDs at 4Meg to see two pairs of chips are fitted */
        flash[MEG] = READ_ID;man2 = flash[MEG+MAN_ADDR];dev2 = flash[MEG+DEV_ADDR];flash[MEG] = READ_ARRAY;

        DEBUGFN(printf("Checking other half man=%x dev=%x\n",man2,dev2));

        if (CHECKMANDEV(man2,dev2))
        {
          man2 &= 0xffff;dev2 &= 0xffff;
          if (RECOGNISE(man2,dev2))
          {
           /* Go through ringmarole again for the other page... */
           SETPAGE1;*flash = READ_ID;man2 = flash[MAN_ADDR];dev2 = flash[DEV_ADDR];

           DEBUGFN(printf("Checking upper first half man=%x dev=%x\n",man2,dev2));

           if (CHECKMANDEV(man2,dev2))
           {
            man2 &= 0xffff;dev2 &= 0xffff;
            if (RECOGNISE(man2,dev2))
            {
             if (((flash[MEG+MAN_ADDR] & 0xffff) == man2) && ((flash[MEG+DEV_ADDR] & 0xffff) == dev2))
             {
              DEBUGFN(printf("Upper Ghost found\n"));

              *flash = READ_ARRAY;SETPAGE0;
              r->r[3] = size = 8*MEG;
             }
             else /*not Upper Ghost*/
             {
              *flash = READ_ARRAY;
              flash[MEG] = READ_ID;man2 = flash[MEG+MAN_ADDR];dev2 = flash[MEG+DEV_ADDR];flash[MEG] = READ_ARRAY;SETPAGE0;

              DEBUGFN(printf("Checking upper other half man=%x dev=%x\n",man2,dev2));

              if (CHECKMANDEV(man2,dev2))
              {
               if RECOGNISE(man2,dev2)
                r->r[3] = size = 16*MEG;
               else
                r->r[3] = size = 12*MEG;
              }
              else
               r->r[3] = size = 12*MEG;
             }
            }
            else /*Failed to recognise lower other half*/
            {
             SETPAGE0;
             r->r[3] = size = 8*MEG;
            }
           }
           else /*Failed to check lower other half*/
           {
            SETPAGE0;
            r->r[3] = size = 8*MEG;
           }
          } /*Hopefully page 0 restored by here...*/
          else /*Failed to recognise upper half*/
           r->r[3] = size = 4*MEG;
        }
        else /*Failed to check upper half*/
         r->r[3] = size = 4*MEG;
      } /*End not Ghost*/
    }
    else	/* Dunno about this device */
    {
      r->r[3] = r->r[4] = r->r[5] = size = 0;
    }
  }
  else		/* Maybe its a 16bit device */
  {
    *flash = READ_ARRAY;		/* Try to restore normality */
    flash = (void *) (easi_base + SLEDGE_OFFSET);
    *flash = READ_ID;			/* Get ID stuff */
    man = flash[MAN_ADDR] & 0xffff;
    dev = flash[DEV_ADDR] & 0xffff;
    *flash = READ_ARRAY;		/* Restore normality */

    if (RECOGNISE(man,dev))
    {
      r->r[1] = man;
      r->r[2] = dev;
      r->r[3] = size = 2*MEG;
      r->r[4] = blocksize = 64*1024;
      r->r[5] = writesize = 256;	/* pagebuffer=256 bytes */
      r->r[6] = width = 2;
      widthmask = 0xffff;
    }
    else	/* Dunno whether any device is present */
    {
      flash_release(r);
      r->r[1] = r->r[2] = r->r[3] = r->r[4] = r->r[5] = 0;
    }
  }

  return NULL;
}


/*
 * SWI Flash_Read
 *
 * Read bytes from flash
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 * If the device being read is 16 or 8 bits wide, the data is returned in
 * the least significant half-word or byte in each word (so the buffer
 * pointed to by r0 should be at least r2*4/width bytes long)
 *
 *   IN
 *     r0-> Buffer
 *     r1:  Offset from start of flash (is rounded down to multiple of width)
 *     r2:  Number of bytes to read (is rounded up to multiple of device width)
 *
 *   OUT
 *     r0:  RET_DONE
 */
_kernel_oserror *flash_read( _kernel_swi_regs *r )
{
  int offset = r->r[1] / width;
  volatile unsigned int *src;
  unsigned int *dst = (unsigned int *) r->r[0];
  unsigned int len = (width - 1 + r->r[2]) / width;


  src = flash + (offset & MEG2MASK);

  /* Only know about this kind of flash */
  if (!RECOGNISE(man,dev))
    return ERROR(BADTYPES);

  /* Can't do anything if WSM is in operation */
  if (pending | pending1)
    return ERROR(LOCKED);

  if (offset >= (2*MEG))
  {
   DEBUGFN(printf("setting page 1\n"));
   SETPAGE1;
  }

  while (len--)
    *(dst++) = *(src++);

  if (offset >= (2*MEG)) SETPAGE0;

  r->r[0] = RET_DONE;
  return NULL;
}


/*
 * SWI Flash_Erase
 *
 * Erases entire flash
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 *
 *   IN
 *
 *   OUT
 *     r0:  RET_PENDING
 */
_kernel_oserror *erase(int page)
{

 if (size > page)
 {
  if (page>0) SETPAGE1;

  *flash = READ_ESR;
  if (flash[BSR_ADDR] & BSR_QUEUE_FULL)
  {
    /* This should never happen if !pending */
    *flash = READ_ARRAY;		/* Try to Restore normality */
    if (page>0) SETPAGE0;
    return ERROR(LOCKED);
  }

  if (size > (page+(4*MEG)))
  {
    flash[MEG] = READ_ESR;
    if (flash[MEG+BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
    {
      /* This should never happen if !pending */
      *flash = READ_ARRAY;		/* Try to restore normality */
      flash[MEG] = READ_ARRAY;
      if (page>0) SETPAGE0;
      return ERROR(LOCKED);
    }
  }
  if (page>0)
   power_control->program = programcopy = PROG_VOLTAGE | PAGE1;
  else
   power_control->program = programcopy = PROG_VOLTAGE | PAGE0;

  *flash = ERASE_ALL;
  *flash = ERASE_CONFIRM;
  if (size > (4*MEG))
  {
    flash[MEG] = ERASE_ALL;
    flash[MEG] = ERASE_CONFIRM;
  }
 }
 if (page>0) SETPAGE0;
 return NULL;
}

_kernel_oserror *flash_erase( _kernel_swi_regs *r )
{
  _kernel_oserror *oserror;
  /* Only know about this kind of flash */
  if (!RECOGNISE(man,dev))
    return ERROR(BADTYPES);

  /* Can't do anything if WSM is in operation */
  /* Actually, we probably could but it makes things simpler if we don't */
  if (pending | pending1)
    return ERROR(LOCKED);

  oserror = erase(0);
  if (oserror != NULL) return oserror;
  oserror = erase(8*MEG);
  if (oserror != NULL) return oserror;

  pending = 1;
  if (size>8*MEG) pending1 = 1;
  r->r[0] = RET_PENDING;
  return NULL;
}

/*
 * SWI Flash_Write
 *
 * Write to flash
 * Number of bytes (r2) must not be greater than the value returned in r5
 * from Flash_info.
 * Results are undefined if r2 is less than the value returned in r5 from
 * Flash_info.
 * If the device being read is 16 or 8 bits wide, the data is written from
 * the least significant half-word or byte in each word (so the buffer
 * pointed to by r0 should be at least r2*4/width bytes long)
 *
 *   IN
 *     r0-> Buffer
 *     r1:  Offset from start of flash (is rounded down to multiple of width)
 *     r2:  Number of bytes to write (is rounded down to multiple of dev. width)
 *
 *   OUT
 *     r0:  RET_PENDING or RET_BUSY
 */
_kernel_oserror *flash_write( _kernel_swi_regs *r )
{
  int offset = r->r[1] / width;
  int chipoffset = r->r[1] & MEG8MASK;
  volatile unsigned int *block;
  volatile unsigned int *chip;
  volatile unsigned int *dst;
  unsigned int *src = (unsigned int *) r->r[0];
  unsigned int len = r->r[2] / width;		/* Number of words to write */
  unsigned int pb_offset = r->r[1] & (writesize-1);

  /* Length to write in half-words, replicated in both 16-bits of 32bit word */
  unsigned int i, lenpattern = (len - 1) + ((len - 1)<<16);

  block = flash + ((chipoffset & ~(blocksize-1)) / width);
  chip = flash + (((chipoffset / 4) < MEG) ? 0 : MEG);
  dst = flash + (offset & MEG2MASK);

  /* Only know about this kind of flash */
  if (!RECOGNISE(man,dev))
    return ERROR(BADTYPES);

  if (len>writesize/width)
    return ERROR(BADPARAMS);

  if (offset >= (2*MEG))
  {
   SETPAGE1;

   if (pending1)
   {
     /* Check if still busy (erasing) */
     if (flash[BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
     {
       SETPAGE0;
       r->r[0] = RET_BUSY;
       return NULL;
     }

     if (size > (12*MEG))
       if (flash[MEG+BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
       {
         SETPAGE0;
         r->r[0] = RET_BUSY;
         return NULL;
       }

     pending1 = 0;

     /* Check last operation completed successfully */
     if ((flash[GSR_ADDR] & GSR_DOS_ERROR & widthmask) ||
         ((size > (12*MEG)) && (flash[MEG+GSR_ADDR] & GSR_DOS_ERROR & widthmask)))
     {
       power_control->program = programcopy = 0;
       return ERROR(BADHARD);
     }

     /* Clear prior status bits */
     *flash = CLEAR_SR;
     if (size > (12*MEG)) flash[MEG] = CLEAR_SR;
   }
  }
  else
  {
   if (pending)
   {
     /* Check if still busy (erasing) */
     if (flash[BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
     {
       r->r[0] = RET_BUSY;
       return NULL;
     }

     if (size > (4*MEG))
       if (flash[MEG+BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
       {
         r->r[0] = RET_BUSY;
         return NULL;
       }

      pending = 0;

     /* Check last operation completed successfully */
     if ((flash[GSR_ADDR] & GSR_DOS_ERROR & widthmask) ||
         ((size > (4*MEG)) && (flash[MEG+GSR_ADDR] & GSR_DOS_ERROR & widthmask)))
     {
       power_control->program = programcopy = 0;
       return ERROR(BADHARD);
     }

     /* Clear prior status bits */
     *flash = CLEAR_SR;
     if (size > (4*MEG)) flash[MEG] = CLEAR_SR;
   }
  }
  /* OK, start the write */
  *chip = READ_ESR;

  /* Check for WSM queue and page buffer availability */
  if ((block[BSR_ADDR] & BSR_QUEUE_FULL & widthmask) ||
      ((block[GSR_ADDR] & GSR_PB_AVAIL & widthmask) !=
       (GSR_PB_AVAIL & widthmask)))
  {
    DEBUGFN(printf("Busy! BSR=%x, GSR=%x\n",
                   block[BSR_ADDR] & widthmask, block[GSR_ADDR] & widthmask));
    if (offset >= (2*MEG)) SETPAGE0;
    r->r[0] = RET_BUSY;
    return NULL;
  }

#ifdef DEBUG
  printf("\nWrite: offset=%x, len=%x\n", r->r[1], r->r[2]);
  printf("chip=%p\n", chip);
  printf("BSR=%x, GSR=%x\n",
         block[BSR_ADDR] & widthmask, block[GSR_ADDR] & widthmask);
  printf("block offset=%x\n", ((int) block) - ((int) flash));
  printf("write offset=%x\n", ((int) dst) - ((int) flash));
  printf("Length pattern=%x\n", lenpattern);
  printf("pb offset=%x\n", pb_offset);
#endif

  if (offset >= (2*MEG))
   power_control->program = programcopy = PROG_VOLTAGE | PAGE1;
  else
   power_control->program = programcopy = PROG_VOLTAGE | PAGE0;

  /* Write length followed by data to page buffer */
  *block = LOAD_PB;
  block[pb_offset] = lenpattern;	/* LSB of word count */
  block[pb_offset] = 0;			/* MSB of word count & buffer offset */
  for (i=0; i<len; i++)
    block[pb_offset+i] = src[i];

  DEBUGFN(printf("BSR=%x, GSR=%x\n",
                 block[BSR_ADDR] & widthmask, block[GSR_ADDR] & widthmask));

  /* Write page buffer to flash */
  *dst = WRITE_PB;
  *dst = lenpattern;			/* LSB of word count */
  *dst = 0;				/* MSB of word count & address */

  DEBUGFN(printf("BSR=%x, GSR=%x\n",
                 block[BSR_ADDR] & widthmask, block[GSR_ADDR] & widthmask));

  while ((chip[GSR_ADDR] & GSR_WSMS_READY & widthmask) !=
           (GSR_WSMS_READY & widthmask));
  {
    /* XXX We could drop into user mode here to let callbacks happen !!! */
    DEBUGFN(printf("Wait: BSR=%x, GSR=%x\n",
                   chip[BSR_ADDR] & widthmask, chip[GSR_ADDR] & widthmask));
  }

  if (offset >= (2*MEG))
   power_control->program = programcopy = PAGE1;
  else
   power_control->program = programcopy = PAGE0;

  /* Check for failure */
  if (chip[GSR_ADDR] & GSR_DOS_ERROR)
  {
    if (offset >= (2*MEG)) SETPAGE0;
    return ERROR(BADHARD);
  }

  *chip = CLEAR_SR;			/* Restore normality */

  if (offset >= (2*MEG)) SETPAGE0;
  r->r[0] = RET_DONE;
  return NULL;
}


/*
 * SWI Flash_Status
 *
 * Poll for status of flash device after previous SWI returned PENDING / BUSY
 *
 *   IN
 *
 *   OUT
 *     r0:  RET_DONE, RET_PENDING or RET_BUSY
 */

/* This version does one part with the latch in a single state */

_kernel_oserror *status ( _kernel_swi_regs *r, int size,int *pending)
{

  /* Only know about this kind of flash */
  if (!RECOGNISE(man,dev))
    return ERROR(BADTYPES);

  if (!*pending)
  {
    r->r[0] = RET_DONE;
    return NULL;
  }

  /*
   * Despite what figure 11-15 of the manual advises, doing the following causes
   * the WSM to suspend (the OSS bit in the GSR gets set). So we don't do it.
   */
#if 0
  *flash = READ_ESR;
#endif

  if (flash[BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
  {
    r->r[0] = RET_BUSY;
    return NULL;
  }

  if (size > (4*MEG))
  {
#if 0	/* See above */
    flash[MEG] = READ_ESR;
#endif
    if (flash[MEG+BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
    {
      r->r[0] = RET_BUSY;
      return NULL;
    }
  }

  if ((flash[GSR_ADDR] & GSR_WSMS_READY & widthmask) !=
      (GSR_WSMS_READY & widthmask))
  {
    r->r[0] = RET_PENDING;
    return NULL;
  }

  if (size > (4*MEG))
  {
#if 0	/* See above */
    flash[MEG] = READ_ESR;
#endif
    if ((flash[MEG+GSR_ADDR] & GSR_WSMS_READY & widthmask) !=
        (GSR_WSMS_READY & widthmask))
    {
      r->r[0] = RET_PENDING;
      return NULL;
    }
  }

  if ((flash[GSR_ADDR] & GSR_DOS_ERROR & widthmask) ||
      ((size > (4*MEG)) && (flash[MEG+GSR_ADDR] & GSR_DOS_ERROR & widthmask)))
  {
#if 0
    *flash = CLEAR_SR;
    *flash = READ_ARRAY;
    flash[MEG] = CLEAR_SR;
    flash[MEG] = READ_ARRAY;
#endif
    *pending = 0;		/* So Flash_Release doesn't fail */
    return ERROR(BADHARD);
  }

  DEBUGFN(printf("BSR=%x, GSR=%x\n",
                 flash[BSR_ADDR] & widthmask, flash[GSR_ADDR] & widthmask));

  *flash = CLEAR_SR;
  if (size>4*MEG) flash[MEG] = CLEAR_SR;  /*TC - didn't like the unconditional version of this before*/

  *pending = 0;
  r->r[0] = RET_DONE;
  return NULL;
}

_kernel_oserror *flash_status( _kernel_swi_regs *r )
{
  _kernel_oserror *oserror;
  int r0copy;

  /* Now return Power status in R1 */

  r->r[1] = power_control->powerstatus;

  if (size > (8*MEG))
  {
    SETPAGE1;
    oserror = status(r,size - 8*MEG,&pending1);
    SETPAGE0;
    if (oserror != NULL)
    {
     status(r,8*MEG,&pending); /*Just to clear stuff if possible*/
     pending = 0; /*Forced by the upper half*/
     power_control->program = programcopy = 0;
     return oserror;
    }
    else
    {
     r0copy = r->r[0];
     oserror = status(r,8*MEG,&pending);
     if ((r->r[0] == RET_DONE) && (r0copy |=RET_DONE)) r->r[0] = r0copy;
     if (oserror != NULL) pending1 = 0; /*Forced by the lower half*/
     if (!(pending | pending1)) power_control->program = programcopy = 0;
     return oserror;
    }
  }
  else
  {
    oserror = status(r,size,&pending);
    if (!pending) power_control->program = programcopy = 0;
    return oserror;
  }
}

/*
 * SWI Flash_Release
 *
 * Allow ejection of flash card
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 *
 *   IN
 *
 *   OUT
 */
_kernel_oserror *flash_release( _kernel_swi_regs *r )
{
  /* Shouldn't power-down if WSM is in operation */
  if (pending | pending1)
    return ERROR(LOCKED);

  man = dev = size = blocksize = 0;
  power_down();

  return NULL;
}

/*
 * SWI Flash_EraseSuspend
 *
 * Suspend Erase operation
 * Only call this if the last operation was an Erase or EraseResume
 *
 *   IN
 *
 *   OUT
 */

void erasesuspend(int page)
{
 if (size > page)
 {
  if (page>0) SETPAGE1;
  *flash = ERASE_SUSPEND;

  if (size > (page+(4*MEG)))
  {
   flash[MEG] = ERASE_SUSPEND;
  }
  if (page>0) SETPAGE0;
 }
}

_kernel_oserror *flash_erasesuspend( _kernel_swi_regs *r )
{
 /* Should find that status is pending */
 /* I'm not too bothered if it isn't... */

 if (!RECOGNISE(man,dev)) return ERROR(BADTYPES);
 if (pending) erasesuspend(0);
 if (pending1) erasesuspend(8*MEG);

 pcopy = pending;pcopy1 = pending1;
 pending1 = pending = 0;
 return NULL;
}

/*
 * SWI Flash_EraseResume
 *
 * Resume Erase operation
 * Only call this if the last operation was an EraseSuspend
 *
 *   IN
 *
 *   OUT
 */

void eraseresume(int page)
{
 if (size > page)
 {
  if (page>0) SETPAGE1;
  *flash = ERASE_RESUME;

  if (size > (page+(4*MEG)))
  {
   flash[MEG] = ERASE_RESUME;
  }
  if (page>0) SETPAGE0;
 }
}

_kernel_oserror *flash_eraseresume( _kernel_swi_regs *r )
{
 /* Assumes Flash_EraseSuspend called before */

 if (!RECOGNISE(man,dev)) return ERROR(BADTYPES);
 if (pcopy) eraseresume(0);
 if (pcopy1) eraseresume(8*MEG);

 pending = pcopy;pending1 = pcopy1;
 pcopy1 = pcopy = 0;
 return NULL;
}

/*
 * SWI Flash_Abort
 *
 * Abort the current operation
 * Internal flags indicating WSM in operation are cleared
 *
 *   IN
 *
 *   OUT
 */

void flashabort(int page)
{
 if (size > page)
 {
  if (page>0) SETPAGE1;
  *flash = ABORT;

  if (size > (page+(4*MEG)))
  {
   flash[MEG] = ABORT;
  }
  if (page>0) SETPAGE0;
 }
}

_kernel_oserror *flash_abort( _kernel_swi_regs *r )
{

 if (!RECOGNISE(man,dev)) return ERROR(BADTYPES);
 flashabort(0);
 flashabort(8*MEG);

 pending1 = pending = 0;
 return NULL;
}

/*
 * SWI Flash_PowerControl
 *
 * Control the programming control register
 * Be careful about using this, especially if WSM in operation
 *
 *   IN
 *    r0: 1=>Power on Vpp,0=>Power off Vpp
 *
 *   OUT
 *    results from Flash_Status call
 */

_kernel_oserror *flash_powercontrol( _kernel_swi_regs *r )
{
 clock_t done;
 if (!RECOGNISE(man,dev)) return ERROR(BADTYPES);
 if (r->r[0] & 1) 
 {
  power_control->program = programcopy = (programcopy & 0xFFFFFFFC) | PROG_VOLTAGE;
 }
 else
 {
  power_control->program = programcopy = (programcopy & 0xFFFFFFFC);
 }
  /* Delay for >5ms to give Vpp time to settle */
  done = clock() + 1 + (int) (CLOCKS_PER_SEC * 5e-3);
  while (clock() < done);
 r->r[1] = power_control->powerstatus;
 r->r[0] = (pending | pending1) ? RET_PENDING : RET_DONE;
 return NULL;
}
