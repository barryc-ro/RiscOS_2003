#include <stdlib.h>
#include "kernel.h"
#include "swis.h"
#include "time.h"

#include "module.h"
#include "flashprog.h"
#include "error.h"

/* Errors */
ERROR_STRUCT(BADTYPES, "Unknown type of flash");
ERROR_STRUCT(BADPARAMS, "Bad parameters");
ERROR_STRUCT(LOCKED, "Device is busy");
ERROR_STRUCT(BADHARD, "Bad hardware");

/* Addressing stuff */
#define DEFUALT_PODULE	0		/* Hack for testing when softloaded */
#define EASI_SPACE	0x88000000U

#define ROM_OFFSET	0
#define POWER_OFFSET	0x400000
#define FLASH_OFFSET	0x800000
#define SLEDGE_OFFSET	0xC00000

#define MEG		(1024*1024)

/* Return values */
#define RET_DONE	0		/* Completed OK */
#define RET_PENDING	1		/* Request has been queued */
#define RET_BUSY	2		/* Device is too busy at the moment */

/* IDs */
#define MAN_INTEL	0x0089
#define MAN_SHARP	0x00B0
#define	DEV_28F016Su	0x6688
#define	DEV_28F016Sx	0x66A0

/* 28F008SA-compatible commands (16bit-wide, replicated to 32bits) */
#define WRITE_WORD	0x40404040
#define READ_ID		0x00900090
#define READ_ARRAY	0x00FF00FF

/* 28F016SA/SV commands (16bit-wide, replicated to 32bits) */
#define CLEAR_SR	0x00500050
#define READ_ESR	0x00710071
#define ERASE_ALL	0x00A700A7
#define ERASE_CONFIRM	0x00D000D0
#define LOAD_PB		0x00E000E0
#define WRITE_PB	0x000C000C

/* IDs (accessible after READ_ID but not during WSM operation) */
#define MAN_ADDR	0
#define DEV_ADDR	1

/* BSR (accessible after READ_ESR or during WSM operation) */
#define BSR_ADDR	1
#define BSR_READY	0x00800080
#define BSR_BOS_ERROR	0x00200020
#define BSR_QUEUE_FULL	0x00080008

/* GSR (accessible after READ_ESR or during WSM operation) */
#define GSR_ADDR	2
#define GSR_WSMS_READY	0x00800080
#define GSR_DOS_ERROR	0x00200020
#define GSR_QUEUE_FULL	0x00080008
#define GSR_PB_AVAIL	0x00040004

/* Do we recognise this flash? */
#define RECOGNISE(man,dev)					\
	((((man) == MAN_INTEL) || ((man) == MAN_SHARP)) &&	\
	 (((dev) == DEV_28F016Sx) || ((dev) == DEV_28F016Su)))


/*
 * Types
 */
typedef struct
{
  volatile unsigned int power	:1;
  volatile unsigned int 	:0;
  union
  {
    struct bits
    {
      volatile unsigned int control	:1;
      volatile unsigned int databus	:1;
      volatile unsigned int addrbus	:1;
      volatile unsigned int 		:0;
    };
    volatile unsigned int all_signals;
  } signals;
  volatile unsigned int program;
} power_control_t;


/*
 * Variables
 */
static volatile power_control_t *power_control;
static int man=0, dev=0, size=0, blocksize=0, writesize=0, width, widthmask;
static int pending=0;
static unsigned int easi_base;
static volatile unsigned int *flash;


/*
 * Functions
 */
void power_up(void)
{
  clock_t done;
  power_control->power = 1;
  power_control->signals.all_signals = 7;

  /* Delay for >50ms to give Vcc time to settle */
  done = clock() + 1 + (int) (CLOCKS_PER_SEC * 50e-3);
  while (clock() < done);
}

void power_down(void)
{
  power_control->program = 0;
  power_control->signals.all_signals = 0;
  power_control->power = 0;
}

_kernel_oserror *flash_initialise( void *pw, int podule_base )
{
  if (podule_base < 0x3000000)
    easi_base = (DEFUALT_PODULE<<24) + EASI_SPACE;
  else
  {
    /* Get EASI address using podule_base */
    _swix(Podule_ReadInfo, _IN(0)|_IN(1)|_IN(2)|_IN(3),
          1<<9, &easi_base, sizeof(easi_base), podule_base);
  }
  power_control = (void *) (easi_base + POWER_OFFSET);

  return NULL;
}

extern void flash_finalise( void *pw )
{
  power_down();
}


/*
 * SWI Flash_Info
 *
 * Power up the flash card and get info about it.
 * Card should not be ejected until Flash_Release is called.
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 *
 *   IN
 *
 *   OUT
 *     r0:  Address of flash
 *     r1:  Manufacturer code (0 if garbage recognised)
 *     r2:  Device code       (0 if garbage recognised)
 *     r3:  Amount of flash fitted  [bytes] (0 if device unrecognised)
 *     r4:  Erase block granularity [bytes] (0 if device unrecognised)
 *     r5:  Maximum size of a write [bytes] (0 if device unrecognised)
 *     r6:  Device width [bytes] (4, 2 or 1)
 */
_kernel_oserror *flash_info( _kernel_swi_regs *r )
{
  /* Can't do anything if WSM is in operation */
  if (pending)
    return ERROR(LOCKED);

  power_up();

  flash = (void *) (easi_base + FLASH_OFFSET);
  r->r[0] = (int) flash;

  *flash = READ_ID;			/* Get ID stuff */
  man = flash[MAN_ADDR];
  dev = flash[DEV_ADDR];

  /* See if same in both 16-bit halves, ie 32-bit wide pair of 16-bit devices */
  /* and ensure we're not just reading back the latched value we just wrote */
  if (((man & 0xffff) == (man >> 16)) && ((dev & 0xffff) == (dev >> 16)) &&
      (man != READ_ID) || (dev != READ_ID))
  {
    r->r[6] = width = 4;
    widthmask = 0xffffffff;
    r->r[1] = (man &= 0xffff);
    r->r[2] = (dev &= 0xffff);

    if (RECOGNISE(man,dev))
    {
      r->r[4] = blocksize = 128*1024;	/* Each device in pair = 64Kbytes */
      r->r[5] = writesize = 512;	/* pagebuffer=256 bytes * 2 devices */

      /* If IDs also appear at 4M, then its a ghost and only 4M is fitted */
      if ((flash[MEG+MAN_ADDR] == man) && (flash[MEG+DEV_ADDR] == dev))
      {
        *flash = READ_ARRAY;		/* Restore normality */
        r->r[3] = size = 4*MEG;
      }
      else
      {
        int man2, dev2;
        *flash = READ_ARRAY;		/* Restore normality on 1st bank */

        /* Look again for IDs at 4Meg to see two pairs of chips are fitted */
        flash[MEG] = READ_ID;		/* Get ID stuff */
        man2 = flash[MEG+MAN_ADDR];
        dev2 = flash[MEG+DEV_ADDR];
        flash[MEG] = READ_ARRAY;	/* Restore normality on 2nd bank */

        if (((man2 & 0xffff) == (man2 >> 16)) &&
            ((dev2 & 0xffff) == (dev2 >> 16)) &&
            RECOGNISE(man2,dev2))
          r->r[3] = size = 8*MEG;
        else
          r->r[3] = size = 4*MEG;
      }
    }
    else	/* Dunno about this device */
    {
      r->r[3] = r->r[4] = r->r[5] = size = 0;
    }
  }
  else		/* Maybe its a 16bit device */
  {
    *flash = READ_ARRAY;		/* Try to restore normality */
    flash = (void *) (easi_base + SLEDGE_OFFSET);
    *flash = READ_ID;			/* Get ID stuff */
    man = flash[MAN_ADDR] & 0xffff;
    dev = flash[DEV_ADDR] & 0xffff;
    *flash = READ_ARRAY;		/* Restore normality */

    if (RECOGNISE(man,dev))
    {
      r->r[1] = man;
      r->r[2] = dev;
      r->r[3] = size = 2*MEG;
      r->r[4] = blocksize = 64*1024;
      r->r[5] = writesize = 256;	/* pagebuffer=256 bytes */
      r->r[6] = width = 2;
      widthmask = 0xffff;
    }
    else	/* Dunno whether any device is present */
    {
      flash_release(r);
      r->r[1] = r->r[2] = r->r[3] = r->r[4] = r->r[5] = 0;
    }
  }

  return NULL;
}


/*
 * SWI Flash_Read
 *
 * Read bytes from flash
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 * If the device being read is 16 or 8 bits wide, the data is returned in
 * the least significant half-word or byte in each word (so the buffer
 * pointed to by r0 should be at least r2*4/width bytes long)
 *
 *   IN
 *     r0-> Buffer
 *     r1:  Offset from start of flash (is rounded down to multiple of width)
 *     r2:  Number of bytes to read (is rounded up to multiple of device width)
 *
 *   OUT
 *     r0:  RET_DONE
 */
_kernel_oserror *flash_read( _kernel_swi_regs *r )
{
  volatile unsigned int *src = flash + (r->r[1] / width);
  unsigned int *dst = (unsigned int *) r->r[0];
  unsigned int len = (width - 1 + r->r[2]) / width;

  /* Only know about this kind of flash */
  if (!RECOGNISE(man,dev))
    return ERROR(BADTYPES);

  /* Can't do anything if WSM is in operation */
  if (pending)
    return ERROR(LOCKED);

  while (len--)
    *(dst++) = *(src++);

  r->r[0] = RET_DONE;
  return NULL;
}


/*
 * SWI Flash_Erase
 *
 * Erases entire flash
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 *
 *   IN
 *
 *   OUT
 *     r0:  RET_PENDING
 */
_kernel_oserror *flash_erase( _kernel_swi_regs *r )
{
  /* Only know about this kind of flash */
  if (!RECOGNISE(man,dev))
    return ERROR(BADTYPES);

  /* Can't do anything if WSM is in operation */
  /* Actually, we probably could but it makes things simpler if we don't */
  if (pending)
    return ERROR(LOCKED);

  *flash = READ_ESR;
  if (flash[BSR_ADDR] & BSR_QUEUE_FULL)
  {
    /* This should never happen if !pending */
    *flash = READ_ARRAY;		/* Try to Restore normality */
    return ERROR(LOCKED);
  }

  if (size > (4*MEG))
  {
    flash[MEG] = READ_ESR;
    if (flash[MEG+BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
    {
      /* This should never happen if !pending */
      *flash = READ_ARRAY;		/* Try to restore normality */
      flash[MEG] = READ_ARRAY;
      return ERROR(LOCKED);
    }
  }

  power_control->program = 1;
  *flash = ERASE_ALL;
  *flash = ERASE_CONFIRM;
  if (size > (4*MEG))
  {
    flash[MEG] = ERASE_ALL;
    flash[MEG] = ERASE_CONFIRM;
  }

  pending = 1;
  r->r[0] = RET_PENDING;
  return NULL;
}


/*
 * SWI Flash_Write
 *
 * Write to flash
 * Number of bytes (r2) must not be greater than the value returned in r5
 * from Flash_info.
 * Results are undefined if r2 is less than the value returned in r5 from
 * Flash_info.
 * If the device being read is 16 or 8 bits wide, the data is written from
 * the least significant half-word or byte in each word (so the buffer
 * pointed to by r0 should be at least r2*4/width bytes long)
 *
 *   IN
 *     r0-> Buffer
 *     r1:  Offset from start of flash (is rounded down to multiple of width)
 *     r2:  Number of bytes to write (is rounded down to multiple of dev. width)
 *
 *   OUT
 *     r0:  RET_PENDING or RET_BUSY
 */
_kernel_oserror *flash_write( _kernel_swi_regs *r )
{
  volatile unsigned int *block = flash + ((r->r[1] & ~(blocksize-1)) / width);
  volatile unsigned int *chip = flash + (((r->r[1] / 4) < MEG) ? 0 : MEG);
  volatile unsigned int *dst = flash + (r->r[1] / width);
  unsigned int *src = (unsigned int *) r->r[0];
  unsigned int len = r->r[2] / width;		/* Number of words to write */
  unsigned int pb_offset = r->r[1] & (writesize-1);

  /* Length to write in half-words, replicated in both 16-bits of 32bit word */
  unsigned int i, lenpattern = (len - 1) + ((len - 1)<<16);

  /* Only know about this kind of flash */
  if (!RECOGNISE(man,dev))
    return ERROR(BADTYPES);

  if (len>writesize/width)
    return ERROR(BADPARAMS);

  if (pending)
  {
    /* Check if still busy (erasing) */
    if (flash[BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
    {
      r->r[0] = RET_BUSY;
      return NULL;
    }

    if (size > (4*MEG))
      if (flash[MEG+BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
      {
        r->r[0] = RET_BUSY;
        return NULL;
      }

    pending = 0;

    /* Check last operation completed successfully */
    if ((flash[GSR_ADDR] & GSR_DOS_ERROR & widthmask) ||
        ((size > (4*MEG)) && (flash[MEG+GSR_ADDR] & GSR_DOS_ERROR & widthmask)))
    {
      power_control->program = 0;
      return ERROR(BADHARD);
    }

    /* Clear prior status bits */
    *flash = CLEAR_SR;
    flash[MEG] = CLEAR_SR;
  }

  /* OK, start the write */
  *chip = READ_ESR;

  /* Check for WSM queue and page buffer availability */
  if ((block[BSR_ADDR] & BSR_QUEUE_FULL & widthmask) ||
      ((block[GSR_ADDR] & GSR_PB_AVAIL & widthmask) !=
       (GSR_PB_AVAIL & widthmask)))
  {
    DEBUGFN(printf("Busy! BSR=%x, GSR=%x\n",
                   block[BSR_ADDR] & widthmask, block[GSR_ADDR] & widthmask));
    r->r[0] = RET_BUSY;
    return NULL;
  }

#ifdef DEBUG
  printf("\nWrite: offset=%x, len=%x\n", r->r[1], r->r[2]);
  printf("chip=%p\n", chip);
  printf("BSR=%x, GSR=%x\n",
         block[BSR_ADDR] & widthmask, block[GSR_ADDR] & widthmask);
  printf("block offset=%x\n", ((int) block) - ((int) flash));
  printf("write offset=%x\n", ((int) dst) - ((int) flash));
  printf("Length pattern=%x\n", lenpattern);
  printf("pb offset=%x\n", pb_offset);
#endif

  power_control->program = 1;

  /* Write length followed by data to page buffer */
  *block = LOAD_PB;
  block[pb_offset] = lenpattern;	/* LSB of word count */
  block[pb_offset] = 0;			/* MSB of word count & buffer offset */
  for (i=0; i<len; i++)
    block[pb_offset+i] = src[i];

  DEBUGFN(printf("BSR=%x, GSR=%x\n",
                 block[BSR_ADDR] & widthmask, block[GSR_ADDR] & widthmask));

  /* Write page buffer to flash */
  *dst = WRITE_PB;
  *dst = lenpattern;			/* LSB of word count */
  *dst = 0;				/* MSB of word count & address */

  DEBUGFN(printf("BSR=%x, GSR=%x\n",
                 block[BSR_ADDR] & widthmask, block[GSR_ADDR] & widthmask));

  while ((chip[GSR_ADDR] & GSR_WSMS_READY & widthmask) !=
           (GSR_WSMS_READY & widthmask));
  {
    /* XXX We could drop into user mode here to let callbacks happen !!! */
    DEBUGFN(printf("Wait: BSR=%x, GSR=%x\n",
                   chip[BSR_ADDR] & widthmask, chip[GSR_ADDR] & widthmask));
  }

  power_control->program = 0;

  /* Check for failure */
  if (chip[GSR_ADDR] & GSR_DOS_ERROR)
  {
    return ERROR(BADHARD);
  }

  *chip = CLEAR_SR;			/* Restore normality */

  r->r[0] = RET_DONE;
  return NULL;
}


/*
 * SWI Flash_Status
 *
 * Poll for status of flash device after previous SWI returned PENDING / BUSY
 *
 *   IN
 *
 *   OUT
 *     r0:  RET_DONE, RET_PENDING or RET_BUSY
 */
_kernel_oserror *flash_status( _kernel_swi_regs *r )
{
  /* Only know about this kind of flash */
  if (!RECOGNISE(man,dev))
    return ERROR(BADTYPES);

  if (!pending)
  {
    r->r[0] = RET_DONE;
    return NULL;
  }

  /*
   * Despite what figure 11-15 of the manual advises, doing the following causes
   * the WSM to suspend (the OSS bit in the GSR gets set). So we don't do it.
   */
#if 0
  *flash = READ_ESR;
#endif

  if (flash[BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
  {
    r->r[0] = RET_BUSY;
    return NULL;
  }

  if (size > (4*MEG))
  {
#if 0	/* See above */
    flash[MEG] = READ_ESR;
#endif
    if (flash[MEG+BSR_ADDR] & BSR_QUEUE_FULL & widthmask)
    {
      r->r[0] = RET_BUSY;
      return NULL;
    }
  }

  if ((flash[GSR_ADDR] & GSR_WSMS_READY & widthmask) !=
      (GSR_WSMS_READY & widthmask))
  {
    r->r[0] = RET_PENDING;
    return NULL;
  }

  if (size > (4*MEG))
  {
#if 0	/* See above */
    flash[MEG] = READ_ESR;
#endif
    if ((flash[MEG+GSR_ADDR] & GSR_WSMS_READY & widthmask) !=
        (GSR_WSMS_READY & widthmask))
    {
      r->r[0] = RET_PENDING;
      return NULL;
    }
  }

  if ((flash[GSR_ADDR] & GSR_DOS_ERROR & widthmask) ||
      ((size > (4*MEG)) && (flash[MEG+GSR_ADDR] & GSR_DOS_ERROR & widthmask)))
  {
#if 0
    *flash = CLEAR_SR;
    *flash = READ_ARRAY;
    flash[MEG] = CLEAR_SR;
    flash[MEG] = READ_ARRAY;
#endif
    pending = 0;		/* So Flash_Release doesn't fail */
    power_control->program = 0;
    return ERROR(BADHARD);
  }

  DEBUGFN(printf("BSR=%x, GSR=%x\n",
                 flash[BSR_ADDR] & widthmask, flash[GSR_ADDR] & widthmask));

  power_control->program = 0;
  *flash = CLEAR_SR;
  flash[MEG] = CLEAR_SR;

  pending = 0;
  r->r[0] = RET_DONE;
  return NULL;
}

/*
 * SWI Flash_Release
 *
 * Allow ejection of flash card
 * Don't call this if WSM is in operation (previous SWI returned PENDING / BUSY)
 *
 *   IN
 *
 *   OUT
 */
_kernel_oserror *flash_release( _kernel_swi_regs *r )
{
  /* Shouldn't power-down if WSM is in operation */
  if (pending)
    return ERROR(LOCKED);

  man = dev = size = blocksize = pending = 0;
  power_down();

  return NULL;
}

