/*-*-C-*-
 * document handling for the ResEd shell
 */

#include "resed.h"
#include "main.h"

#include "swicall.h"
#include "wimp.h"
#include "resformat.h"
#include "newmsgs.h"
#include "dbox.h"
#include "dragdrop.h"
#include "filetypes.h"
#include "focus.h"
#include "interactor.h"
#include "menu.h"
#include "registry.h"
#include "saveas.h"
#include "toolbox.h"

#include "class.h"
#include "document.h"
#include "copy.h"
#include "fileinfo.h"
#include "genmsgs.h"
#include "help.h"
#include "icondefs.h"
#include "objflags.h"
#include "protocol.h"
#include "rename.h"


#define DOCUMENT_LEFT_MARGIN 16
#define DOCUMENT_RIGHT_MARGIN 16
#define DOCUMENT_TOP_MARGIN 16
#define DOCUMENT_BOTTOM_MARGIN 16
#define DOCUMENT_VERTICAL_SPACING 32
#define DOCUMENT_HORIZONTAL_SPACING 32

static WindowPtr docprotowin = NULL;
static WindowPtr palprotowin = NULL;
static WindowPtr docwarnwin = NULL;

static DocumentPtr paldoc;      /* Palette document */

static IconRec docspriteproto, docnameproto, docrenameproto;
static int iconwidth, iconheight;     /* size of whole icon */
static int maxgridwidth, maxgridheight;
static MenuPtr docmenu = NULL, filemenu = NULL, editmenu = NULL;

static int key_delete, key_save, key_objflags, key_selectall, key_clearsel;

static error * _document_close_window (DocumentPtr doc);
#ifndef NOBBLE
static error * issue_close_warning (DocumentPtr doc);
#endif

#define DOCMENU_FILE 0
#define DOCMENU_EDIT 1
#define DOCMENU_PALETTE 2

#define FILEMENU_INFO 0
#define FILEMENU_SAVE 1
#define FILEMENU_MESSAGES 2

#define EDITMENU_COPY 0
#define EDITMENU_RENAME 1
#define EDITMENU_DELETE 2
#define EDITMENU_PROPS 3
#define EDITMENU_SELALL 4
#define EDITMENU_CLEAR 5


/*
 * This static is shared by document_create(..) and document_add_resource(..)
 * It determines where the next new document window will be placed.
 */

static int lasty = -1;


/*
 * This structure is used to hold information about any drag currently in
 *  progress.
 */

typedef struct
{
    DocumentPtr doc;        /* the source document */
    Bool closeafter;        /* TRUE iff the document window is to be closed
                                when the drag is successfully completed */
} DragSelectionClosureRec, *DragSelectionClosurePtr;



/*
 * Check whether the given name is unique in the document (or rather,
 * is non-existent in the document).
 */

static Bool checkunique (DocumentPtr doc, char *name)
{
    ResourcePtr res;
    for (res = doc->resources; res; res = res->next)
        if (strcmp (res->object->hdr.name, name) == 0)
            return FALSE;
    return TRUE;
}


/*
 * Check to see if a named resource is already present in the document.  If so,
 * disambiguate until it is unique.  Returns name in the same buffer that
 * was passed in; note the buffer is expected to be MAX_OBJECT_NAME bytes long,
 * ie enough for the longest valid name and a null terminator.
 * Returns TRUE is the name was changed, FALSE otherwise.
 */

Bool document_disambiguate_name (DocumentPtr doc, char *name)
{
    int number = 0, oldlen;
    char oldname[MAX_OBJECT_NAME];

    if (checkunique (doc, name))
        return FALSE;

    strcpy (oldname, name);
    oldlen = strlen (oldname);

    /* If there is a "dot-number" suffix, increment it, else append one */
    {
        char *dot = strrchr (oldname, '_');
        if (dot)
        {
            char *s;
            for (s = dot + 1; *s && isdigit (*s); s++)
                ;
            if (*s == 0)
            {
                number = atoi (dot + 1);
                oldlen = dot - oldname;
            }
        }
    }

    for (;;)
    {
        int pos = oldlen;
        number++;
        sprintf(name, "_%d", number);
        if (pos + strlen (name) >= MAX_OBJECT_NAME)
            pos = MAX_OBJECT_NAME - strlen(name) - 1;
        strcpy (name, oldname);
        sprintf (name + pos, "_%d", number);
        if (checkunique (doc, name))
            break;
    }
    return TRUE;
}


/*
 * What grid width is possible with the current window size?  Must be
 * at least one.
 */

static int find_grid_width (WindowPtr win)
{
    int width = win->visarea.maxx - win->visarea.minx;

    /* this copes with "toggle-size" behaviour: when toggled to full size,
       the window is opened as if its entire work-area were visible; but
       in fact it is not possible for a user to resize a window in such a
       way that its "visible area" is larger than the screen (regardless of
       all those configuration bits!) so this test will only be effective
       after a "toggle-size" operation */

    if (width > screenx)
        width = screenx;

    width -= DOCUMENT_LEFT_MARGIN + DOCUMENT_RIGHT_MARGIN;
    width += DOCUMENT_HORIZONTAL_SPACING;
    width /= iconwidth + DOCUMENT_HORIZONTAL_SPACING;
    return width > 1 ? width : 1;
}


/*
 * What grid height is possible with the current window size?  Must be
 * at least one.
 */

static int find_grid_height (WindowPtr win)
{
    int height = win->visarea.maxy - win->visarea.miny;
    height -= DOCUMENT_TOP_MARGIN + DOCUMENT_BOTTOM_MARGIN;
    height += DOCUMENT_VERTICAL_SPACING;
    height /= iconheight + DOCUMENT_VERTICAL_SPACING;
    return height > 1 ? height : 1;
}


/*
 * What window extent is needed to accomodate the grid width of this document?
 * Always returns enough width for one row, even if no icons there.
 */

static int find_extent_width (int gridwidth)
{
    int cols = gridwidth ? gridwidth : 1;
    return DOCUMENT_LEFT_MARGIN
        + cols * iconwidth
            + (cols - 1) * DOCUMENT_HORIZONTAL_SPACING
                + DOCUMENT_RIGHT_MARGIN;
    /* XXX round up to whole pixels? */
}
    

/*
 * What window extent is needed to accomodate the grid height of this document?
 * Always returns enough height for one row, even if no icons there.
 */

static int find_extent_height (int gridheight)
{
    int rows = gridheight ? gridheight : 1;
    return DOCUMENT_TOP_MARGIN
        + rows * iconheight
            + (rows - 1) * DOCUMENT_VERTICAL_SPACING
                + DOCUMENT_BOTTOM_MARGIN;
    /* XXX round up to whole pixels? */
}
    

/*
 * Determine width of window required for the given title string.
 * Allow 2 char cells for the " *" modified flag, and 2 each for the
 * window decorations.  Assumes system-font.
 */

static int find_title_width (DocumentPtr doc)
{
    int num = strlen(doc->title) + (2 * 3);
    if (!doc->modified) num += 2;
    return num * 16;
}


/*
 * Determine bounding box, on the work area, of the n'th icon
 * on the document window's grid.  Numbering starts at 0.
 * NB: it is expected to fit on the window's extent - no checking.
 */

static void get_icon_bbox (DocumentPtr doc, int nth, ResourcePtr res)
{
    int row = nth / doc->gridwidth;
    int col = nth % doc->gridwidth;
    int topleftx = DOCUMENT_LEFT_MARGIN + col * (iconwidth + DOCUMENT_HORIZONTAL_SPACING);
    int toplefty = -(DOCUMENT_TOP_MARGIN + row * (iconheight + DOCUMENT_VERTICAL_SPACING));
    res->spritebbox = docspriteproto.bbox;
    res->spritebbox.minx += topleftx;
    res->spritebbox.maxx += topleftx;
    res->spritebbox.miny += toplefty;
    res->spritebbox.maxy += toplefty;
    res->namebbox = docnameproto.bbox;
    res->namebbox.minx += topleftx;
    res->namebbox.maxx += topleftx;
    res->namebbox.miny += toplefty;
    res->namebbox.maxy += toplefty;
}


/*
 * Determine which icon the given point is inside.
 * The point is in work-area coordinates.  If it does not correspond
 * to any icon, return NULL
 */

static ResourcePtr which_sprite_icon (DocumentPtr doc, PointPtr position)
{
    ResourcePtr res;
    for (res = doc->resources; res; res = res->next)
        if (wimp_point_inside (&res->spritebbox, position))
            return res;
    return NULL;
}


/*
 * Determine which name icon the given point is inside.
 * The point is in work-area coordinates.  If it does not correspond
 * to any icon, return NULL
 */

static ResourcePtr which_name_icon (DocumentPtr doc, PointPtr position)
{
    ResourcePtr res;
    for (res = doc->resources; res; res = res->next)
        if (wimp_point_inside (&res->namebbox, position))
            return res;
    return NULL;
}


/*
 * Try to grow the visible area of the window with Filer-like
 * behaviour. If it returns TRUE, the visible area has changed
 * and doc->gridwidth has been updated.
 */

static Bool increase_visarea (DocumentPtr doc, int newnum)
{
    int viswidth = find_grid_width(&doc->window);/*doc->gridwidth;*/
    int visheight = find_grid_height(&doc->window);
    int ovisheight = visheight;

    if (viswidth * visheight >= newnum)
        return FALSE;           /* no need */

    if (doc->window.visarea.maxy - doc->window.visarea.miny <
        doc->window.workarea.maxy - doc->window.workarea.miny)
        return FALSE;           /* scrolled, so don't */

    if (visheight == 1)
    {
        /* Try adding columns */
        while (viswidth < maxgridwidth)
        {
            viswidth++;
            if (viswidth * visheight >= newnum)
                goto changeit;
        }
    }

 retry:
    /* Try adding rows */
    while (visheight < maxgridheight)
    {
        visheight++;
        if (viswidth * visheight >= newnum)
            goto changeit;
    }

 changeit:
    doc->window.visarea.maxx = MAX(doc->window.visarea.minx + find_extent_width(viswidth),
                                   doc->window.visarea.maxx);
    doc->window.visarea.miny = doc->window.visarea.maxy - find_extent_height(visheight);

    /* Ensure that the work area is at least that big too! */
    doc->window.workarea.maxx = MAX(doc->window.workarea.maxx,
                                    doc->window.workarea.minx + find_extent_width(viswidth));
    doc->window.workarea.miny = MIN(doc->window.workarea.miny,
                                    doc->window.workarea.maxy - find_extent_height(visheight));


    /* Attempt to open the window at the new size */
    {
        /* To get 'behind' handle afresh */
        WindowRec state;

        state.handle = doc->window.handle;
        swi (Wimp_GetWindowState,  R1, &state,  END);
        doc->window.behind = state.behind;

        swi (Wimp_SetExtent, R0, doc->window.handle,  R1, &doc->window.workarea,  END);
        swi (Wimp_OpenWindow,  R1, &doc->window,  END);
    }

    /* And now get the window's real new size, in case it didn't grow as much
     * as we wanted. 
     */

    swi (Wimp_GetWindowState,  R1, &doc->window,  END);
    if ((doc->gridwidth = find_grid_width (&doc->window)) != viswidth)
    {
        viswidth = doc->gridwidth;
        visheight = ovisheight;
        goto retry;             /* assert: won't happen more than once */
    }
    return TRUE;
}


/*
 * Document is getting more/less icons. Sort out value of gridheight.
 * Fix extent up.  If getting smaller, change visible area
 * too (and fix scroll bar position).  Does not alter doc->numresources.
 * Note that if this returns *redraw == TRUE, the caller must call
 * Wimp_OpenWindow pretty soon to actually effect the changes on-screen.
 * If 'newwin' is set, then a minimum size of the titlebar's width
 * will be enforced.  If 'newwin' is not set then this minimum will only
 * be enforced when altering the window's width as a result of
 * adding/removing icons.
 */

static error * changing_size (DocumentPtr doc, int newnum, Bool *reopen, Bool newwin)
{
    int newgridheight;

/* dprintf("*** CHANGING_SIZE IN *** width is %d, height is %d\n" _ doc->gridwidth _ doc->gridheight); */

    *reopen = FALSE;
    
    if (newnum > doc->numresources)
        *reopen = increase_visarea(doc, newnum);

    newgridheight = (newnum + doc->gridwidth - 1) / doc->gridwidth;
    if (newgridheight < 1)
        newgridheight = 1;

/* dprintf("New gridheight is %d\n" _ newgridheight); */

    if (newgridheight > doc->gridheight)
    {
        /* Make vertical extent bigger */
/* dprintf("Making bigger\n"); */
        doc->gridheight = newgridheight;
        doc->window.workarea.miny = -find_extent_height(doc->gridheight);
        ER ( swi(Wimp_SetExtent,  R0, doc->window.handle,  R1, &doc->window.workarea,  END) );
    }

    else if (newgridheight < doc->gridheight)
    {
        /* Make vertical extent smaller, fix up win size and scroll offset */
        int newextent, visheight;

/* dprintf("Making smaller\n"); */
        doc->gridheight = newgridheight;
        newextent = find_extent_height(doc->gridheight);
        
        visheight = doc->window.visarea.maxy - doc->window.visarea.miny;

        if (visheight > newextent)
        {
            doc->window.visarea.miny = doc->window.visarea.maxy - newextent;
            doc->window.scrolloffset.y = 0;
            *reopen = TRUE;
        }
        else if (newextent + doc->window.scrolloffset.y < visheight)
        {
            doc->window.scrolloffset.y = visheight - newextent;
            *reopen = TRUE;
        }

        doc->window.workarea.miny = -newextent;
        ER ( swi(Wimp_SetExtent,  R0, doc->window.handle,  R1, &doc->window.workarea,  END) );
    }

    if (newgridheight <= 1)
    {
        /* Sort out horizontal work area, restricting the width.
         * If this change is due to the number of icons changing, ensure
         * that the window size is at least the titlebar width.
         */
        int width, twidth = find_title_width(doc);
/* dprintf("ONE\n"); */
        doc->gridwidth = newnum ? newnum : 1;
        width = find_extent_width (doc->gridwidth);
        if (newwin || newnum != doc->numresources)
        {
/* dprintf("TWO\n"); */
            if (twidth > width)
                width = twidth;
            if (doc->window.visarea.maxx > doc->window.visarea.minx + width)
            {
/* dprintf("THREE\n"); */
                doc->window.visarea.maxx = doc->window.visarea.minx + width;
                *reopen = TRUE;
            }
            doc->gridwidth = find_grid_width(&doc->window);
        }
        else if (!newwin && newnum == doc->numresources)
        {
/* dprintf("FOUR\n"); */
            if (twidth > width)
                width = twidth;
        }
        doc->window.workarea.maxx = doc->window.workarea.minx + width;
        ER ( swi(Wimp_SetExtent,  R0, doc->window.handle,  R1, &doc->window.workarea,  END) );
    }
    else
    {
        /* Unrestrict the width */
/* dprintf("FIVE\n"); */
        doc->window.workarea.maxx = doc->window.workarea.minx + 
            (docprotowin->workarea.maxx - docprotowin->workarea.minx);
        ER ( swi(Wimp_SetExtent,  R0, doc->window.handle,  R1, &doc->window.workarea,  END) );
    }

/* dprintf("***OUT *** width is %d, height is %d\n" _ doc->gridwidth _ doc->gridheight); */

    return NULL;
}


/*
 * Redo the layout of a document window after deleting a resource or
 * altering the number of rows.  Forces a redraw.  The document
 * should already be sorted.
 */

static error * relayout (DocumentPtr doc)
{
    int i;
    for (i = 0; i < doc->numresources; i++)
        get_icon_bbox(doc, i, doc->mapping[i]);
    return wimp_invalidate (&doc->window, &doc->window.workarea);
}


/*
 * Select or deselect an icon according to the
 * value passed in.  Redraws screen and keeps
 * numselected up to date.
 */

static error * select_icon (DocumentPtr doc, ResourcePtr res, Bool newstate)
{
    if (res->selected == newstate)
        return NULL;
    doc->numselected += newstate ? 1 : -1;
    res->selected = newstate;

    ER   ( wimp_invalidate (&doc->window, &res->spritebbox) );
    return wimp_invalidate (&doc->window, &res->namebbox);
}


/*
 * Select any icons in the window that intersect the given
 * bounding box.  If the 'toggle' parameter is TRUE, then
 * toggle state rather than setting.  If 'toggle' FALSE, then
 * icons not in the bbox are cleared.  Forces redraw of the
 * appropriate parts of the screen.
 *
 * If 'entirely' is TRUE, only those icons entirely within the bounding box
 *  are selected.
 */

static error * select_bounded_icons (
    DocumentPtr doc,
    RectPtr inside,
    Bool toggle,
    Bool entirely
)
{
    ResourcePtr res = doc->resources;
    Bool anyinvalid = FALSE;
    RectRec invalid;
    invalid.minx = invalid.miny = 1000000;
    invalid.maxx = invalid.maxy = -1000000;

    for (; res; res = res->next)
    {
        Bool changed = FALSE;
        if ( entirely && wimp_rect_contained  (&res->spritebbox, inside)
                      && wimp_rect_contained  (&res->namebbox, inside)   ||
            !entirely && (wimp_rects_intersect (&res->spritebbox, inside)
                          ||  wimp_rects_intersect (&res->namebbox, inside)))
        {
            if (res->selected)
            {
                if (toggle)
                {
                    /* Toggle off */
                    res->selected = FALSE;
                    doc->numselected--;
                    changed = TRUE;
                }
            }
            else
            {
                /* Switch on */
                res->selected = TRUE;
                doc->numselected++;
                changed = TRUE;
            }
        }
        else
        {
            if (res->selected && !toggle)
            {
                /* clear selection */
                res->selected = FALSE;
                doc->numselected--;
                changed = TRUE;
            }
        }

        if (changed)
        {
            wimp_merge_bboxes (&invalid, &invalid, &res->spritebbox);
            wimp_merge_bboxes (&invalid, &invalid, &res->namebbox);
            anyinvalid = TRUE;
        }
    }

    if (anyinvalid)
        ER ( wimp_invalidate (&doc->window, &invalid) );
    return NULL;
}


/*
 * Select all icons in the window.
 */

static error * document_select_all (DocumentPtr doc)
{
    return select_bounded_icons (doc, &doc->window.workarea, FALSE, FALSE);
}


/*
 * Deselect all icons in the window.
 */

error * document_clear_selection (DocumentPtr doc)
{
    if (doc->numselected != 0)
    {
        RectRec outside;
        outside.minx = outside.miny = -2;
        outside.maxx = outside.maxy = -2;
        ER ( select_bounded_icons (doc, &outside, FALSE, TRUE) );
    }
    return NULL;
}


/*
 * Determine how big a document will be when saved to memory/file.
 * All modified objects must have been recovered when
 * this is called.
 */

int document_file_size (DocumentPtr doc, Bool selection)
{
    int size = 0;
    ResourcePtr res;

    for (res = doc->resources; res; res = res->next)
        if (selection == FALSE || res->selected)
            size += (toolbox_object_size (res->object) + 3) & ~3;
    
    if (size == 0)
        return sizeof(ResourceFileHeaderRec);    /* empty files are always this long */
    else if (doc->objectoffset > 0)
        return size + doc->objectoffset;
    else
        return size + sizeof(ResourceFileHeaderRec);
}


/*
 * Sets doc->timestamp.  If doc->fullpath, set the timestamp
 * to that of the file.  Otherwise, set it to the current
 * time.
 */

static error * read_timestamp (DocumentPtr doc)
{
    if (doc->fullpath)
    {
        char name[FILENAMELEN];
        unsigned int low4, high1;
        sprintf (name, "%.*s", doc->namelength, doc->title);
        ER ( swi (OS_File,  R0, 23,  R1, name,  OUT,  R2, &high1,  R3, &low4,  END) );
        memcpy ((void *) doc->timestamp, (void *) &low4,  4);
        memcpy ((void *) (doc->timestamp + 4), (void *) &high1, 1);
    }
    else
    {
        doc->timestamp[0] = 3;
        ER ( swi (OS_Word,  R0, 14,  R1, doc->timestamp,  END) );
    }
    return NULL;
}


/*
 * Save the specified document (or just its selected resources)
 * into the block of memory given.  This must be big enough, as determined
 * by document_file_size().
 */

static error * document_save_to_memory (DocumentPtr doc, char *buffer, Bool selection)
{
    ResourceFileHeaderPtr hdr = (ResourceFileHeaderPtr) buffer;
    int off, num = 0;
    ResourcePtr res;

    hdr->fileid = 'F' << 24 | 'S' << 16 | 'E' << 8 | 'R';   /* 'FSER' */
    hdr->versionnumber = RESF_VERSION;
    hdr->objectoffset = sizeof(ResourceFileHeaderRec);

    off = hdr->objectoffset;

    for (res = doc->resources; res; res = res->next)
        if (selection == FALSE || res->selected)
        {
            int size = toolbox_object_size (res->object);
            memcpy ((void *) (buffer + off), (void *) res->object, size);
            off += (size + 3) & ~3;
            num++;
        }
    
    if (num == 0)
        hdr->objectoffset = -1;        /* special indication of empty file */

#ifdef NOBBLE      /* scramble resource file for nobbled version */

    {
        int i;
        int max = off >> 2;
        unsigned x = hdr->fileid;
        int *buf = (int *) buffer;

        for (i = 1; i < max; i++)
            buf[i] ^= x;
    }

#endif

    return NULL;
}


/*
 * Save a document, or just the selected resources, into a given file.
 * The caller is responsible for updating the stored filename,
 * resetting the modified flag when appropriate, etc.
 */


error * document_save_file (DocumentPtr doc, char *filename, Bool selection)
{
    int size = document_file_size (doc, selection);
    char *buf = NULL;
    error *err = NULL;
    FILE *f = fopen(filename, "w");

    if (!f)
        err = error_lookup ("CantWrite", filename);
    else
    {
        buf = malloc(size);
        if (!buf)
            err = error_lookup("NoMem");
        else
        {
            err = document_save_to_memory (doc, buf, selection);
            if (!err)
                if (fwrite ((void *) buf, 1, size, f) < size)
                    err = error_lookup ("CantWrite", filename);
        }
    }

    if (f) fclose(f);
    free(buf);
    if (!err)
        settype(filename, FILETYPE_RESOURCE);
    return err;
}


/*
 * Called from saveas module, for saving a whole Document or just the selection
 */

static error * save_document_cb (SaveAsReason reason, Bool selection, char **buf, int *size, void *closure)
{
    DocumentPtr doc = (DocumentPtr) closure;
/* dprintf("In save_document_cb %d\n" _ reason); */
    switch (reason)
    {
    case SaveAsGetSize:
        /* Recover latest versions of the doc's objects from CSEs */
        ER ( document_recover_document (doc) );
        *size = document_file_size (doc, selection);
        break;
    case SaveAsGetBlock:
        *buf = malloc (*size);
        if (*buf == NULL)
            return error_lookup("NoMem");
        return document_save_to_memory (doc, *buf, selection);
    case SaveAsFreeBlock:
        free (*buf);
        break;
    case SaveAsSuccess:
        /* Only called if file is "safe".  *buf points to filename */
        document_change_filename (doc, *buf, TRUE);
        document_modified (doc, FALSE);
        (void) read_timestamp (doc);
        break;
    case SaveAsDelete:
        /* Only called if file is "safe" and the caller wants the document closed */
        return _document_close_window (doc);
    }
    return NULL;
}


/*
 * Called when the user clicks on File->Save menu entry
 */

static error * save_document_directly (DocumentPtr doc)
{
    char name[FILENAMELEN];
    if (doc->fullpath)
    {
        /* Recover latest versions of the doc's objects from CSEs */
        ER ( document_recover_document (doc) );
        sprintf (name, "%.*s", doc->namelength, doc->title);
        ER ( document_save_file (doc, name, FALSE) );
        (void) read_timestamp (doc);
        document_modified (doc, FALSE);
    }
    else
    {
        PointerInfoRec pointer;
        sprintf (name, "%.*s", doc->namelength, doc->title);
        ER ( swi (Wimp_GetPointerInfo,  R1, &pointer,  END) );
        return saveas_open (TRUE, FALSE, FALSE, &pointer.position, name,
                            FILETYPE_RESOURCE, save_document_cb, (void *) doc);
    }
    return NULL;
}
 

/*
 * Called from the menu warning for File->Info
 */

static error * show_infowin (MenuPtr menu, MessageMenuWarningPtr warn, void *closure)
{
    DocumentPtr doc = (DocumentPtr) closure;
    return fileinfo_open (doc, &warn->position);
}


/*
 * Called from the menu warning for Edit->Copy
 */

static error * show_copywin (MenuPtr menu, MessageMenuWarningPtr warn, void *closure)
{
    return copy_open ((DocumentPtr) closure, &warn->position);
}


/*
 * Called from the menu warning for Edit->Rename
 */

static error * show_renamewin (MenuPtr menu, MessageMenuWarningPtr warn, void *closure)
{
    return rename_open ((DocumentPtr) closure, &warn->position);
}


/*
 * Called from the menu warning for Edit->Props
 */

static error * show_propswin (MenuPtr menu, MessageMenuWarningPtr warn, void *closure)
{
    return objflags_open ((DocumentPtr) closure, &warn->position);
}


/*
 * Called from the menu warning for File->Save
 */

static error * save_document (MenuPtr menu, MessageMenuWarningPtr warn, void *closure)
{
    DocumentPtr doc = (DocumentPtr) closure;
    char name[FILENAMELEN];
    sprintf (name, "%.*s", doc->namelength, doc->title);
    return saveas_open (FALSE, doc->numselected != 0, FALSE, &warn->position, name,
                        FILETYPE_RESOURCE, save_document_cb, closure);
}
 

/*
 * Called from the menu warning for Export Messages
 */

static error * save_messages (MenuPtr menu, MessageMenuWarningPtr warn, void *closure)
{
    DocumentPtr doc = (DocumentPtr) closure;
    return saveas_open (FALSE, doc->numselected != 0, FALSE, &warn->position, message_lookup (&msgs, "Messages"),
                        FILETYPE_TEXT, genmsgs_saveas_cb, closure);
}
 

/*
 * Called while the Templates file is open
 */

error * document_load_prototypes ()
{
    ER ( wimp_load_template("DocProto", &docprotowin) );
    ER ( wimp_load_template("PalProto", &palprotowin) );
    ER ( wimp_load_template("DocWarn", &docwarnwin) );

    /* Document window: first two icons are prototypes for others */
    if (docprotowin->numicons != 3)
        return error_lookup("DocProtos");

    {
        IconPtr icons = docprotowin->icons;

        docspriteproto = *icons;
        docnameproto = *(icons + 1);
        docrenameproto = *(icons + 2);
    }

    /* Determine size of whole icon, and offsets of the parts */
    {
        RectRec bbox;
        wimp_merge_bboxes (&bbox, &docspriteproto.bbox, &docnameproto.bbox);
        iconwidth = bbox.maxx - bbox.minx;
        iconheight = bbox.maxy - bbox.miny;

        /* Now make the two bboxes relative to the whole bbox */
        docspriteproto.bbox.minx -= bbox.minx;
        docspriteproto.bbox.maxx -= bbox.minx;
        docspriteproto.bbox.miny -= bbox.maxy;
        docspriteproto.bbox.maxy -= bbox.maxy;
        docnameproto.bbox.minx -= bbox.minx;
        docnameproto.bbox.maxx -= bbox.minx;
        docnameproto.bbox.miny -= bbox.maxy;
        docnameproto.bbox.maxy -= bbox.maxy;
    }

    /* Now zap the icons in the window record, we don't want them created */
    docprotowin->numicons = 0;

    /* Use initial visarea of window to determine how much
     * it can auto-grow
     */
    maxgridwidth = find_grid_width (docprotowin);
    maxgridheight = find_grid_height (docprotowin);

    /* Sort out the minimum size for all Document windows now:- */

    docprotowin->minsize.width = (short) find_extent_width(1);
    docprotowin->minsize.height = (short) find_extent_height(1);

    /* We fix the initial size in document_create */

    /* Open at top of window stack */
    docprotowin->behind = -1;

    /* Use this opportunity to create menus.  Replace all this mess with
     * something better, eventually.
     */

    ER ( menu_create (3, message_lookup (&msgs, "FM_Name"), &filemenu) );

    ER ( menu_entry (filemenu, FILEMENU_INFO, message_lookup (&msgs, "FM_Info"),
                     0, MF_MESSAGE, -1, -1, (void *) (int) show_infowin) );

    ER ( menu_entry (filemenu, FILEMENU_SAVE, message_lookup (&msgs, "FM_Save"),
                     0, MF_MESSAGE, -1, -1, (void *) (int) save_document) );

    ER ( menu_entry (filemenu, FILEMENU_MESSAGES, message_lookup (&msgs, "FM_Msgs"),
                     0, MF_MESSAGE, -1, -1, (void *) (int) save_messages) );


    ER ( menu_create (6, message_lookup (&msgs, "EM_Name"), &editmenu) );

    ER ( menu_entry (editmenu, EDITMENU_COPY, message_lookup (&msgs, "EM_Copy"),
                     0, MF_MESSAGE, -1, -1, (void *) (int) show_copywin) );

    ER ( menu_entry (editmenu, EDITMENU_RENAME, message_lookup (&msgs, "EM_Renm"),
                     0, MF_MESSAGE, -1, -1, (void *) (int) show_renamewin) );

    ER ( menu_entry (editmenu, EDITMENU_DELETE, message_lookup (&msgs, "EM_Delt"),
                     0, 0, -1, -1, NULL) );

    ER ( menu_entry (editmenu, EDITMENU_PROPS, message_lookup (&msgs, "EM_Prop"),
                     0, MF_MESSAGE|MF_DOTTED, -1, -1, (void *) (int) show_propswin) );

    ER ( menu_entry (editmenu, EDITMENU_SELALL, message_lookup (&msgs, "EM_SAll"),
                     0, 0, -1, -1, NULL) );

    ER ( menu_entry (editmenu, EDITMENU_CLEAR, message_lookup (&msgs, "EM_CSel"),
                     0, 0, -1, -1, NULL) );

        
    ER ( menu_create (3, message_lookup (&msgs, "DM_Name"), &docmenu) );

    ER ( menu_entry (docmenu, DOCMENU_FILE, message_lookup (&msgs, "DM_File"),
                     0, 0, -1, -1, (void *) filemenu) );

    ER ( menu_entry (docmenu, DOCMENU_EDIT, message_lookup (&msgs, "DM_Edit"),
                     0, 0, -1, -1, (void *) editmenu) );

    ER ( menu_entry (docmenu, DOCMENU_PALETTE, message_lookup (&msgs, "DM_Palt"),
                     0, 0, -1, -1, NULL) );
    ER ( menu_register (docmenu, MAIN_MENU) );

#ifndef NOBBLE    /* do not define "save" keycut for nobbled version */
    key_save = atoi (message_lookup (&msgs, "KFM_Save"));
#endif
    key_delete = atoi (message_lookup (&msgs, "KEM_Dele"));
    key_objflags = atoi (message_lookup (&msgs, "KEM_Prop"));
    key_selectall = atoi (message_lookup (&msgs, "KEM_SAll"));
    key_clearsel = atoi (message_lookup (&msgs, "KEM_CSel"));

    return NULL;
}


/*
 * Redo titlebar, putting modified flag in if wanted.  Only
 * force a redraw if caller wants it, as the window may not
 * be open yet.
 */

static error * fix_titlebar (DocumentPtr doc, Bool redraw)
{
    if (doc->modified)
        strcpy (doc->title + doc->namelength, " *");
    else
        doc->title[doc->namelength] = 0;
    if (redraw)
    {
        WindowRedrawRec win, vis;
        win.handle = vis.handle = doc->window.handle;
        ER ( swi(Wimp_GetWindowOutline,  R1, &win,  END) );
        ER ( swi(Wimp_GetWindowState,  R1, &vis,  END) );
        ER ( swi(Wimp_ForceRedraw,  R0, -1,
                 R1, win.visarea.minx, R2, vis.visarea.maxy,
                 R3, win.visarea.maxx, R4, win.visarea.maxy,  END) );
    }
    return NULL;
}


/*
 * Update current notion of whether the document is modified or
 * not.  Update titlebar on screen.
 */

error * document_modified (DocumentPtr doc, Bool modified)
{
    if (!doc->internal)
    {
        if (doc->modified != modified)
        {
            doc->modified = modified;
            ER ( fix_titlebar (doc, TRUE) );
        }
    }
    return NULL;
}


/*
 * Set the document's filename.  If the filename supplied is
 * NULL or "" or <Wimp$Scrap>, then sets it to Untitled.
 */

error * document_change_filename (DocumentPtr doc, char *filename, Bool redraw)
{
    char fname[256];
    if (filename == NULL || *filename == 0 || strcmp(filename, "<Wimp$Scrap>") == 0)
    {
        static int numuntitled = 0;
        sprintf(fname, message_lookup(&msgs, "Untitled"), ++numuntitled);
        filename = fname;
        doc->fullpath = FALSE;
    }
    else
        doc->fullpath = TRUE;
    strcpy (doc->title, filename);
    doc->namelength = strlen(filename);
    return fix_titlebar (doc, redraw);
}


/*
 * Create a new empty document record from the prototype.
 * Create its window, register it and open it.  Modify the
 * position each time around, so that we don't get bored
 * with the window position.
 *
 * If filename is "", this is an "untitled" document.
 */

error * document_create (DocumentPtr *ret, char *filename)
{
    Bool dummy;
    DocumentPtr doc = (DocumentPtr) calloc (1, sizeof(DocumentRec));

    if (doc == NULL)
        return error_lookup("NoMem");
    
    doc->window = *docprotowin;
    doc->window.titledata[0] = (int) doc->title;
    doc->window.titledata[2] = FILENAMELEN;
    ER ( document_change_filename(doc, filename, FALSE) );
    (void) read_timestamp (doc);

    /* 
     * Create windows in slightly different positions each time.
     */

    if (lasty == -1)
        lasty = doc->window.visarea.maxy;
    else
    {
        int height = doc->window.visarea.maxy - doc->window.visarea.miny;

        lasty -= 40;
        doc->window.visarea.maxy = lasty;
        doc->window.visarea.miny = doc->window.visarea.maxy - height;
    }

    ER ( swi (Wimp_CreateWindow,  R1, &doc->window.visarea,
              OUT,  R0, &doc->window.handle,  END) );
    
    doc->gridwidth = 1;
    doc->gridheight = 10;
    changing_size(doc, 0, &dummy, TRUE);
        
    ER ( registry_register_window(doc->window.handle, Document, (void *) doc) );

    /*
     * If the base of this window now overlaps the icon bar, then reset to
     *  the original position.
     */

    {
        int base = doc->window.visarea.miny;
        WindowStateRec iconbar;

        iconbar.handle = -2;
        ER ( swi (Wimp_GetWindowOutline, R1, &iconbar, END) );

        if (base  < iconbar.visarea.maxy)
        {
            lasty = docprotowin->visarea.maxy;
            doc->window.visarea.miny += (lasty - doc->window.visarea.maxy);
            doc->window.visarea.maxy = lasty;
        }
    }

    ER ( swi (Wimp_OpenWindow, R1, &doc->window, END) );

    *ret = doc;
    return NULL;
}


/*
 * Create the empty palette document and open its window.  This gets
 * called when the user first accesses the palette; the palette is
 * then immediately filled in by class_prime_palette() before the window
 * has a chance to be displayed - well, that's the theory!
 */

static error * _document_create_palette (DocumentPtr *ret)
{
    Bool dummy;
    DocumentPtr doc = (DocumentPtr) calloc (1, sizeof(DocumentRec));
    if (doc == NULL)
        return error_lookup("NoMem");
    
    doc->internal = TRUE;
    doc->window = *palprotowin;             /* so that the palette can have a different position */
    doc->window.titledata[0] = (int) doc->title;
    doc->window.titledata[2] = FILENAMELEN;
    strcpy(doc->title, message_lookup(&msgs, "PalTitle"));
    doc->namelength = strlen(doc->title);
    doc->window.behind = -1;
    ER ( swi (Wimp_CreateWindow,  R1, &doc->window.visarea,
              OUT,  R0, &doc->window.handle,  END) );

    doc->gridwidth = 1;
    doc->gridheight = 10;
    changing_size(doc, 0, &dummy, TRUE);

    ER ( swi (Wimp_OpenWindow, R1, &doc->window, END) );
    ER ( registry_register_window(doc->window.handle, Document, (void *) doc) );
    ER ( swi (Wimp_GetWindowState,  R1, &doc->window,  END) );

    *ret = doc;
    return NULL;
}


/*
 * SORTING
 */

static int sort_by_name (const void *one, const void *two)
{
    char *s1 = (*((ResourcePtr *)one))->object->hdr.name;
    char *s2 = (*((ResourcePtr *)two))->object->hdr.name;
    int len1 = strlen (s1);
    int len2 = strlen (s2);
    int len = (len1 < len2) ? len1 : len2;
    int i = 0;

    while (i < len)
    {
        int x = toupper(s1[i]) - toupper(s2[i]);

        if (x != 0)
            return x;

        i++;
    }

    return (len1 - len2);
}


static error * sort_document (DocumentPtr doc)
{
    int i;
    ResourcePtr res;

    if (doc->numresources == 0)
        return NULL;

    /* Make sure that the mapping array is big enough for
     * the number of resources we have.
     */

    if (doc->mappingmax < doc->numresources)
    {
        doc->mappingmax = doc->numresources + 20; /* avoid reallocating too often */
        free((char *) doc->mapping);
        doc->mapping = (ResourcePtr *) malloc (doc->mappingmax * sizeof(ResourcePtr));
        if (doc->mapping == NULL)
            return error_lookup("NoMem");
    }

    for (res = doc->resources, i = 0; res; res = res->next, i++)
        doc->mapping[i] = res;

    qsort ((void *)doc->mapping, (size_t) doc->numresources, sizeof(ResourcePtr), sort_by_name);
    return NULL;
}


/*
 * Add a resource to the list for the given document.  The record
 * for it is added to the end of the document's resource list.
 * NOTE: when this function has been called, the caller MUST
 * do a sort_document() and a relayout().  When adding multiple resources
 * this step can be delayed until they have all been added, this
 * must be before any redrawing happens.
 *
 * The object and class fields are left as NULL; these must be filled
 * in by the caller.
 *
 * Parameter 'isnew' is set to indicate whether the window into which the
 *  resource is being loaded is a new one or not; if it is a new one, then
 *  its base should not obscure the icon bar as it fills up.
 */

error * document_add_resource (DocumentPtr doc, ResourcePtr *ret, Bool isnew)
{
    ResourcePtr new = (ResourcePtr) calloc(1, sizeof(ResourceRec));
    ResourcePtr last = doc->resources;
    Bool reopen = FALSE;
    error *err;

    if (ret)
        *ret = new;

    if (new == NULL)
        return error_lookup("NoMem");

    new->owner = doc;

    /* Fix up window size */
    EG ( fail, changing_size (doc, doc->numresources + 1, &reopen, FALSE) );
    if (reopen)
    {
        /* To get 'behind' handle afresh */
        WindowRec state;
        state.handle = doc->window.handle;
        EG ( fail, swi (Wimp_GetWindowState,  R1, &state,  END) );
        doc->window.behind = state.behind;

        /*
         * If this is a new document window whose base now overlaps the icon
         *  bar, then restart the document staggering.
         * See document_create(..) for more details.
         */

        if (isnew)
        {
            int base = doc->window.visarea.miny;
            WindowStateRec iconbar;

            iconbar.handle = -2;
            ER ( swi (Wimp_GetWindowOutline, R1, &iconbar, END) );

            if (base  < iconbar.visarea.maxy)
            {
                lasty = docprotowin->visarea.maxy;
                doc->window.visarea.miny +=
                                    (lasty - doc->window.visarea.maxy);
                doc->window.visarea.maxy = lasty;
            }
        }

        EG ( fail, swi (Wimp_OpenWindow,  R1, &doc->window,  END) );
    }

    /* Link this resource into the document */
    while (last && last->next)
        last = last->next;
    if (last) last->next = new; else doc->resources = new;
    doc->numresources++;

    document_modified (doc, TRUE);
    return NULL;                /* success */

 fail:
    if (new) free((char *)new);
    return err;
}


/*
 * Free res (and all data attached to it).  If this resources is
 * currently being edited by a CSE, inform it that the object
 * has disappeared.
 */

static error * document_free_resource(ResourcePtr res)
{
    if (res->editing)
    {
        MessageResEdObjectDeletedRec del;
        del.header.size = sizeof(MessageResEdObjectDeletedRec);
        del.header.yourref = 0;
        del.header.messageid = MESSAGE_RESED_OBJECT_DELETED;
        del.flags = 0;
        del.documentID = (Opaque) res->owner;
        del.objectID = (Opaque) res;
        (void) swi (Wimp_SendMessage,
                    R0, EV_USER_MESSAGE,
                    R1, &del,
                    R2, res->class->cse->taskid,  END);
    }
    free((char *) res->object);
    free((char *) res);
    return NULL;
}


/*
 * Delete any selected items in this document, redraw window, etc.
 */

error * document_delete_selection (DocumentPtr doc)
{
    ResourcePtr this = doc->resources, prev = NULL;
    Bool reopen;

    while (this)
    {
        ResourcePtr next = this->next;
        if (this->selected)
        {
            if (prev)
                prev->next = next;
            else
                doc->resources = next;
            document_free_resource (this);    /* this also informs the CSE */
        }
        else
            prev = this;
        this = next;
    }

    /* Fix up window size */
    ER ( changing_size (doc, doc->numresources - doc->numselected, &reopen, FALSE) );
    doc->numresources -= doc->numselected;
    doc->numselected = 0;

    if (reopen)
    {
        /* To get 'behind' handle afresh */
        WindowRec state;
        state.handle = doc->window.handle;
        ER ( swi (Wimp_GetWindowState,  R1, &state,  END) );
        doc->window.behind = state.behind;

        ER ( swi (Wimp_OpenWindow,  R1, &doc->window,  END) );
    }

    ER ( sort_document(doc) );
    ER ( relayout(doc) );       /* does ForceRedraw for us */

    document_modified (doc, TRUE);
    return NULL;
}


/*
 * Delete the specified resource from the document.
 */

error * document_delete_resource (ResourcePtr res)
{
    DocumentPtr doc = res->owner;
    ER ( document_clear_selection (doc) );
    ER ( select_icon (doc, res, TRUE) );
    return document_delete_selection (doc);
}


/* 
 * Respond to open_window_request on a document window.
 * Note: the 'win' parameter is only a partial window structure
 * (just the fields returned with Open_Window_Request).
 * This works for the palette too.
 */

error * document_open_window (WindowPtr win, DocumentPtr doc)
{
    int newcols;

    doc->window.visarea = win->visarea;
    doc->window.scrolloffset = win->scrolloffset;
    doc->window.behind = win->behind;

    /* Does our new size require more or less columns? */
    newcols = find_grid_width(&doc->window);
    if (newcols != doc->gridwidth)
    {
        Bool reopen;            /* ignored, we always reopen */
        doc->gridwidth = newcols;
        ER ( changing_size (doc, doc->numresources, &reopen, FALSE) );
        /* Sort order should already be correct */
        ER ( relayout(doc) );   /* does ForceRedraw for us */
    }

    return swi (Wimp_OpenWindow, R1, &doc->window, END);
}


/* 
 * Respond to close_window_request on a document window.
 * Note: the 'win' parameter is only a partial window structure
 * (just the fields returned with Close_Window_Request).
 * Close and free up all associated templates too.
 */

static error * _document_close_window (DocumentPtr doc)
{
    ResourcePtr res = doc->resources;
        
    focus_giveup (doc->window.handle);
    registry_deregister_window (doc->window.handle);
    swi (Wimp_DeleteWindow, R1, &doc->window, END);

    while (res)
    {
        ResourcePtr next = res->next;
        document_free_resource (res); /* this informs the CSE too */
        res = next;
    }

    free ((char *) doc->mapping);
    free ((char *) doc);
    return NULL;
}


#ifndef NOBBLE

/*
 * Interactor for the warning window.
 */

static error * close_interactor (unsigned int event, int *buf, void *closure, Bool *consumed)
{
    DocumentPtr doc = (DocumentPtr) closure;
    MouseClickPtr mouse = (MouseClickPtr) buf;
    WindowPtr win = (WindowPtr) buf;         /* only half there */
    MessagePtr mess = (MessagePtr) buf;
    char name[FILENAMELEN];

    if (buf == NULL)                     /* we are being asked to cancel */
    {
        swi (Wimp_CreateMenu,  R1, -1,  END);
        return NULL;
    }

/* dprintf("in close_interactor %d\n" _ event); */

    switch (event)
    {
    case EV_OPEN_WINDOW_REQUEST:
        if (win->handle == docwarnwin->handle)
        {
            *consumed = TRUE;
            return swi (Wimp_OpenWindow, R1, win, END);
        }
        break;

    case EV_MOUSE_CLICK:
        if (mouse->windowhandle == docwarnwin->handle)
        {
            *consumed = TRUE;
            switch (mouse->iconhandle)
            {
            case I_DOCWARN_DISCARD:
                _document_close_window (doc);
                /* FALLTHRU */
            case I_DOCWARN_CANCEL:
                interactor_cancel ();
                return NULL;
            case I_DOCWARN_SAVE:
                interactor_cancel ();
                sprintf (name, "%.*s", doc->namelength, doc->title);
                return saveas_open (TRUE, FALSE, TRUE, &mouse->position, name,
                                    FILETYPE_RESOURCE, save_document_cb, (void *) doc);
            }
        }
        break;

    case EV_USER_MESSAGE:
    case EV_USER_MESSAGE_RECORDED:
        if (mess->code == MESSAGE_MENUS_DELETED)
        {
            interactor_cancel();
            *consumed = TRUE;
        }
        break;
    }

    return NULL;
}


/*
 * Issues a warning box for a modified document for which a close request
 *  has been received.
 */

static error * issue_close_warning (DocumentPtr doc)
{
    char *s = dbox_getstring (docwarnwin, I_DOCWARN_MESSAGE);
    char name[FILENAMELEN];
    if (docwarnwin->handle <= 0)
    {
        ER ( swi (Wimp_CreateWindow,  R1, &docwarnwin->visarea,
                  OUT,  R0, &docwarnwin->handle,  END) );

        /* register window - for interactive help */
        ER ( registry_register_window(docwarnwin->handle, DocWarnDbox, (void *) docwarnwin) );
    }
    sprintf (name, "%.*s", doc->namelength, doc->title);
    sprintf (s, message_lookup (&msgs, "DocWarn"), name);
    dbox_setstring (docwarnwin, I_DOCWARN_MESSAGE, s);
    ER ( swi (Wimp_CreateMenu,  R1, docwarnwin->handle,
              R2, docwarnwin->visarea.minx,  R3, docwarnwin->visarea.maxy,  END) );
    interactor_install (close_interactor, (void *) doc);
    return NULL;
}

#endif


/*
 * Respond to Close_Window_Request on a document window.  If the ADJUST
 * button was used, open the parent directory.  If the document is modified,
 * give the user a chance to save it.
 */

error * document_close_window (DocumentPtr doc)
{
    PointerInfoRec info;
    Bool adjust = FALSE;
    Bool shift = (wimp_read_modifiers () & MODIFIER_SHIFT) != 0;

    if (swi (Wimp_GetPointerInfo,  R1, &info,  END) == NULL)
        adjust = info.buttons & MB_ADJUST;

    if (doc == paldoc)
        return document_close_palette();

    /* See if the user used ADJUST, and open parent directory if so */
    if (doc->fullpath && adjust)
    {
        char cmd[FILENAMELEN + 100], *dot;
/*        sprintf (cmd, "%%Filer_OpenDir %.*s", doc->namelength, doc->title); */
        sprintf (cmd, "%.*s", doc->namelength, doc->title);
        dot = strrchr (cmd, '.');
        if (dot)
        {
            int fsn;
            MessageFilerOpenDirRec mess;

            *dot = 0;
/*            dprintf ("Doing *%s*\n", cmd); */
/*            system (cmd);                  */

            /* determine filing system number */
            swi (OS_FSControl, R0, 13,
                               R1, (int) cmd,
                               R2, 0,
                          OUT, R1, &fsn, END);

            /* send FilerOpenDir message */
            mess.header.size = (offsetof (MessageFilerOpenDirRec, filename) +
                                    strlen(cmd) + 1) + 3 & ~3;
            mess.header.yourref = 0;
            mess.header.messageid = MESSAGE_FILER_OPEN_DIR;
            mess.fsnumber = fsn;
            mess.flags = 0;
            strcpy(mess.filename, cmd);

            swi (Wimp_SendMessage, R0, EV_USER_MESSAGE,
                                   R1, &mess,
                                   R2, 0, END);   /* broadcast */
        }
    }

    /* nothing more to do if SHFT/ADJ click */
    if (shift && adjust)
        return NULL;

#ifdef NOBBLE    /* close regardless in nobbled version */

    return _document_close_window (doc);

#else

    if (doc->modified)
        return issue_close_warning (doc);
    else
        return _document_close_window (doc);

#endif
}



/*
 * Redraw loop for the document window.
 */

error * document_redraw_window (WindowRedrawPtr redraw, DocumentPtr doc)
{
    int more;
    int havefocus = focus_current() == doc->window.handle;
    
    ER ( swi(Wimp_RedrawWindow,  R1, redraw,  OUT,  R0, &more,  END) );
    while (more)
    {
        RectRec work;
        ResourcePtr res;

        /* Determine work-area relative bbox of invalid area */
        wimp_convert_rect(ScreenToWork, (WindowPtr) redraw, &redraw->graphwin, &work);

        for (res = doc->resources; res; res = res->next)
        {
            if (wimp_rects_intersect(&res->spritebbox, &work))
            {
                IconRec icon = docspriteproto;
                icon.bbox = res->spritebbox;
                /* the prototype icon should already contain the name of the
                 * sprite for "unknown class" (from the Templates file).
                 * If this resource is *not* of an unknown class, fill in
                 * the correct sprite name, which class_initialise() will
                 * have filled in.
                 */
                if (res->class)
                    icon.data[0] = (unsigned int) res->class->spritename;
                if (res->selected)
                {
                    icon.flags |= IF_SELECTED;
                }
                ER (swi (Wimp_PlotIcon,  R1, &icon,  END) );
            }
            if (wimp_rects_intersect(&res->namebbox, &work))
            {
                IconRec icon = docnameproto;
                icon.bbox = res->namebbox;
                if (res->selected)
                {
                    if (havefocus)
                        icon.flags |= IF_SELECTED;
                }
                icon.data[0] = (unsigned int) res->object->hdr.name;
                icon.data[2] = (unsigned int) MAX_OBJECT_NAME;
                ER (swi (Wimp_PlotIcon,  R1, &icon,  END) );
            }
        }

        ER ( swi (Wimp_GetRectangle,  R1,  redraw,  OUT,  R0, &more,  END) );
    }
    return NULL;
}


/*
 * Get work area coords of the selection's bounding box
 */

static void get_selection_bbox (DocumentPtr doc, RectPtr bbox)
{
    ResourcePtr res;
    bbox->minx = bbox->miny = 1000000;
    bbox->maxx = bbox->maxy = -1000000;
    for (res = doc->resources; res; res = res->next)
        if (res->selected)
        {
            wimp_merge_bboxes (bbox, bbox, &res->spritebbox);
            wimp_merge_bboxes (bbox, bbox, &res->namebbox);
        }
}



/*
 * Called when the focus changes - either gained or lost.  Simply
 * force the redraw of the selected icons.  The redraw code decides
 * whether to draw the selection highlighted or not by looking
 * at focus_current(), which will either be the same as 'window'
 * if 'window' is the focus window, or -1 if it is not.
 */

static error * focus_cb (FocusReason why, int window, void *cls)
{
    void *closure;
    if (why == FocusGained || why == FocusLost)
    {
        if (registry_lookup_window(window, &closure) == Document &&
            closure == cls)
        {
            DocumentPtr doc = (DocumentPtr) cls;
            RectRec bbox;
            get_selection_bbox (doc, &bbox);
            ER ( wimp_invalidate (&doc->window, &bbox) );
        }
    }
    return NULL;
}


/*
 * Claim the (invisible) caret and input focus into a document window
 */

error * document_claim_focus (DocumentPtr doc)
{
    ER ( swi (Wimp_SetCaretPosition,  R0, doc->window.handle,  R1, -1,
              R2, 0,  R3, 0,  R4, BIT(25),  R5, 0,  END) );
    return focus_claim (doc->window.handle, focus_cb, (void *) doc);
}


/*
 * Move the selected icons from 'doc' to 'dst'.  They remain selected
 * in the destination.
 */

static error * move_internal (DocumentPtr doc, DocumentPtr dst)
{
    ResourcePtr this = doc->resources, prev = NULL, last;
    Bool reopen;
    int numdis = 0;

    if (doc == dst)
        return NULL;
    if (doc->numselected == 0 || dst->internal || doc->internal)
        return NULL;

    ER ( document_recover_document (doc) );

    /* Destination gains focus & has its existing selection cleared */
    (void) document_claim_focus (dst);
    (void) document_clear_selection (dst);

    for (last = dst->resources; last && last->next; last = last->next)
        ;
    
    while (this)
    {
        ResourcePtr next = this->next;
        if (this->selected)
        {
            /* If editing, tell the CSE that it has been deleted (sic) */
            if (this->editing)
            {
                MessageResEdObjectDeletedRec del;
                del.header.size = sizeof(MessageResEdObjectDeletedRec);
                del.header.yourref = 0;
                del.header.messageid = MESSAGE_RESED_OBJECT_DELETED;
                del.flags = 0;
                del.documentID = (Opaque) doc;
                del.objectID = (Opaque) this;
                (void) swi (Wimp_SendMessage,
                            R0, EV_USER_MESSAGE,
                            R1, &del,
                            R2, this->class->cse->taskid,  END);
                this->editing = FALSE;
            }

            /* Unlink this from doc */
            if (prev)
                prev->next = next;
            else
                doc->resources = next;

            /* Make sure it has a unique name in dst */
            if (document_disambiguate_name (dst, this->object->hdr.name))
            {
                numdis++;
/*                dprintf (" DISAMBIGUATED TO %s\n" _ this->object->hdr.name); */
            }

            /* And append it to dst */
            if (last)
                last->next = this;
            else
                dst->resources = this;

            this->owner = dst;
            last = this;
            last->next = NULL;
        }
        else
            prev = this;
        this = next;
    }

    /* Resize/redraw both */

    ER ( changing_size (doc, doc->numresources - doc->numselected, &reopen, FALSE) );
    if (reopen)
        ER ( swi (Wimp_OpenWindow,  R1, &doc->window,  END) );

    ER ( changing_size (dst, dst->numresources + doc->numselected, &reopen, FALSE) );
    if (reopen)
        ER ( swi (Wimp_OpenWindow,  R1, &dst->window,  END) );

    dst->numresources += doc->numselected;
    doc->numresources -= doc->numselected;
    dst->numselected += doc->numselected;
    doc->numselected = 0;

    /* Warn user if any resource names were disambiguated */

    if (numdis != 0)
        error_box (error_lookup (numdis == 1 ? "DisOne" : "DisSome", numdis));

    ER ( sort_document(doc) );
    ER ( sort_document(dst) );
    ER ( relayout(doc) );       /* does ForceRedraw for us */
    ER ( relayout(dst) );       /* does ForceRedraw for us */
    document_modified (doc, TRUE);
    document_modified (dst, TRUE);

    return NULL;
}


/*
 * Copy the selected icons from 'doc' to 'dst'.  They remain selected
 * in the destination.  Note that doc and dst must not be the same.
 */

static error * copy_internal (DocumentPtr doc, DocumentPtr dst)
{
    ResourcePtr this = doc->resources, last;
    Bool reopen;
    int numdis = 0;
    int numcopied = 0;

    if (doc == dst)
        return NULL;
    if (doc->numselected == 0 || dst->internal)
        return NULL;

    ER ( document_recover_document (doc) );

    /* Destination gains focus & has its existing selection cleared */
    (void) document_claim_focus (dst);
    (void) document_clear_selection (dst);

    for (last = dst->resources; last && last->next; last = last->next)
        ;
    
    while (this)
    {
        ResourcePtr next = this->next;
        if (this->selected)
        {
            int objsize = toolbox_object_size (this->object);
            ResourcePtr copy = (ResourcePtr) calloc(1, sizeof(ResourceRec));
            if (copy == NULL)
            {
                error_box (error_lookup ("NoMem"));
                break;
            }
            copy->object = (ResourceFileObjectTemplateHeaderPtr) malloc (objsize);
            if (copy->object == NULL)
            {
                free ((char *) copy);
                error_box (error_lookup ("NoMem"));
                break;
            }

            copy->selected = TRUE;
            copy->owner = dst;
            memcpy (copy->object, this->object, objsize);
            copy->class = this->class;
            copy->editing = copy->modified = FALSE;

            /* Make sure it has a unique name in dst */
            if (document_disambiguate_name (dst, copy->object->hdr.name))
            {
                numdis++;
/*                dprintf (" DISAMBIGUATED TO %s\n" _ copy->object->hdr.name); */
            }

            /* And append it to dst */
            if (last)
                last->next = copy;
            else
                dst->resources = copy;

            last = copy;
            last->next = NULL;

            numcopied++;
        }
        this = next;
    }

    /* Resize dst */

    ER ( changing_size (dst, dst->numresources + numcopied, &reopen, FALSE) );
    if (reopen)
        ER ( swi (Wimp_OpenWindow,  R1, &dst->window,  END) );

    dst->numresources += numcopied;
    dst->numselected += numcopied;

    /* Warn user if any resource names were disambiguated */

    if (numdis != 0)
        error_box (error_lookup (numdis == 1 ? "DisOne" : "DisSome", numdis));

    ER ( sort_document(dst) );
    ER ( relayout(dst) );       /* does ForceRedraw for us */
    document_modified (dst, TRUE);

    return NULL;
}



/*
 * Closure for the drag and lassoo interactors
 */

typedef struct
{
    DocumentPtr doc;
    RectRec workbox;
    unsigned int buttons, modifiers;
} DragClosureRec, *DragClosurePtr;


/*
 * Interactor for the lassoo operation
 */

static error * lassoo_interactor (unsigned int event, int *buf, void *closure, Bool *consumed)
{
    DragClosurePtr drag = (DragClosurePtr) closure;
    static Bool donepointer = FALSE;
    Bool removeptr;

    if (buf == NULL)            /* we are being asked to cancel */
    {
        if (donepointer)
        {
            dragdrop_normal_pointer ();
            donepointer = FALSE;
        }
        wimp_update_eor_box (&drag->doc->window, &drag->workbox);
        (void) dragdrop_scroll (NULL, NULL, NULL);
        return swi(Wimp_DragBox,  R1, 0,  END);
    }
    
    switch (event)
    {
    case EV_NULL_REASON_CODE:
        {
            PointerInfoRec pointer;
            PointRec work;
            PointRec oldscroll, newscroll;
            Bool abouttoscroll;

            (void) swi (Wimp_GetPointerInfo,  R1, &pointer,  END);
            
            /*
             * Look to see if scrolling is about to happen.
             * If so, then we wish only to remove the lassoo: it will be
             *  redrawn by the REDRAW_WINDOW_REQUEST code.
             * The auto-scrolling routines actually update the scroll offset,
             *  so we must preserve the original and reinstate afterwards.
             */

            oldscroll = drag->doc->window.scrolloffset;
            abouttoscroll = dragdrop_scroll (&drag->doc->window,
                                             &pointer.position, &removeptr);
            if (abouttoscroll)
            {
                /* take note of new scroll offset before restoring */
                newscroll = drag->doc->window.scrolloffset;
                drag->doc->window.scrolloffset = oldscroll;
            }
            
            wimp_convert_point (ScreenToWork, &drag->doc->window,
                                              &pointer.position, &work);

            if (work.x != drag->workbox.maxx ||
                work.y != drag->workbox.miny || abouttoscroll)
            {
                wimp_update_eor_box (&drag->doc->window, &drag->workbox);

                drag->workbox.maxx = work.x;
                drag->workbox.miny = work.y;

                /* don't plot new lassoo if about to scroll */
                if (!abouttoscroll)
                    wimp_update_eor_box (&drag->doc->window, &drag->workbox);
            }
            else
            {
                wimp_start_rotate_box ();
                wimp_update_eor_box (&drag->doc->window, &drag->workbox);
                wimp_end_rotate_box ();
            }

            if (abouttoscroll)
            {
                /* restore new scroll offset ready for redraw code */
                drag->doc->window.scrolloffset = newscroll;

                if (donepointer == FALSE)
                {
                    dragdrop_scroll_pointer ();
                    donepointer = TRUE;
                }
            }
            if (donepointer && removeptr)
            {
                dragdrop_normal_pointer ();
                donepointer = FALSE;
            }
        }
        break;

    case EV_REDRAW_WINDOW_REQUEST:
        {
            WindowRedrawPtr redraw = (WindowRedrawPtr) buf;
            
            if (redraw->handle == drag->doc->window.handle)
            {
                PointerInfoRec pointer;
                PointRec work;

                *consumed = TRUE;

                /* redraw exposed part of window */
                document_redraw_window (redraw, drag->doc);

                /* determine revised position of lassoo and draw it */
                (void) swi (Wimp_GetPointerInfo,  R1, &pointer,  END);
                wimp_convert_point (ScreenToWork, &drag->doc->window,
                                                  &pointer.position, &work);
                drag->workbox.maxx = work.x;
                drag->workbox.miny = work.y;
                wimp_update_eor_box (&drag->doc->window, &drag->workbox);
            }
        }
        break;

    case EV_KEY_PRESSED:
        {
            KeyPressPtr key = (KeyPressPtr) buf;

            dragdrop_nudge (key->code, 4);

            /* drag has priority over keyboard shortcuts */
            *consumed = (key->code != 0x1b);
        }
        break;

    case EV_USER_DRAG_BOX:
        {
            interactor_cancel();
            *consumed = TRUE;
            wimp_regularise_rect (&drag->workbox);
            return select_bounded_icons (
                       drag->doc,
                       &drag->workbox,
                       drag->buttons == MB_DRAG(MB_ADJUST),
                       (drag->modifiers & MODIFIER_SHIFT) != 0);
        }
        break;
    }
    return NULL;
}


/*
 * Determine best filetype for transfer.  If we can't agree on one, send
 * my favorite.  Actually I can only do one, so this code is a little
 * over the top, but I might add other formats later...
 */

int document_negotiate_filetype (int *mypref, int *yourpref)
{
    int *mp;
    for (; *yourpref != -1; yourpref++)
        for (mp = mypref; *mp != -1; mp++)
            if (*mp == *yourpref)
                return *mp;
    return *mypref;
}
        


/*
 * Closure record for the Data_Save interactor.
 */

typedef struct
{
    DocumentPtr doc;   /* src doc */
    Bool move;         /* TRUE => delete src */
    Bool closeafter;   /* TRUE => close src doc after */
} DataSaveClosureRec, *DataSaveClosurePtr;


/*
 * Interactor for datasaving a selection from a document.  Copes with the
 * recipient using either scrap transfer or RAM transfer.  Also responds to
 * getting MESSAGE_RESED_OBJECT_NAME_REQUEST in reply.
 */

static error * datasave_interactor (unsigned int event, int *buf, void *closure, Bool *consumed)
{
    MessageHeaderPtr message = (MessageHeaderPtr) buf;
    DataSaveClosurePtr cls = (DataSaveClosurePtr) closure;

    /* State for RAM transfer */
    static char *rambuf = NULL;
    static int ramnum = 0, rampos = 0;
    error *err = NULL;
    
    if (buf == NULL)
    {
        if (rambuf) free (rambuf);
        rambuf = NULL;
        return NULL;                     /* cancel */
    }

    switch (event)
    {
    case EV_USER_MESSAGE:
    case EV_USER_MESSAGE_RECORDED:
        switch (message->messageid)
        {
        case MESSAGE_DATA_SAVE_ACK:
            block
            {
                MessageDataSavePtr save = (MessageDataSavePtr) buf;
                MessageDataLoadPtr load = (MessageDataLoadPtr) buf;
/*                dprintf("Data Save Ack\n"); */
                *consumed = TRUE;
                ER ( document_save_file (cls->doc, save->leafname, TRUE) );
                load->header.yourref = save->header.myref;
                load->header.messageid = MESSAGE_DATA_LOAD;
                return swi (Wimp_SendMessage,
                            R0, EV_USER_MESSAGE_RECORDED,
                            R1, load,
                            R2, save->header.taskhandle,  END);
            }
            break;

        case MESSAGE_DATA_LOAD_ACK:
/*            dprintf("Data Load Ack\n"); */
            *consumed = TRUE;
            interactor_cancel();

            if (cls->move)
            {
                ER ( document_delete_selection (cls->doc) );
            }

            if (cls->closeafter)
            {
                if (cls->doc == paldoc)
                    return document_close_palette ();
                else

#ifdef NOBBLE    /* close regardless in nobbled version */

                    return _document_close_window (cls->doc);

#else

                if (cls->doc->modified)
                    return issue_close_warning (cls->doc);
                else
                    return _document_close_window (cls->doc);

#endif
            }
            break;

        case MESSAGE_RAM_FETCH:
            block
            {
                MessageRamFetchPtr fetch = (MessageRamFetchPtr) buf;
                MessageRamTransmitPtr transmit = (MessageRamTransmitPtr) buf;
                int num;
                Bool full = FALSE;
/*                dprintf("RamFetch received\n"); */
                *consumed = TRUE;
                if (rambuf == NULL)
                {
                    /* First time round, set up rambuf, and set up pointers and counters.
                     * If we have any problems, then bounce the RamFetch message.
                     */
                    rambuf = malloc (ramnum = document_file_size (cls->doc, TRUE));
                    if (rambuf == NULL)
                        return NULL; /* sender will try DataSaveAck */
/*                    dprintf("Allocated scratch buffer for RAM xfer\n"); */
                    EG ( fail, document_save_to_memory (cls->doc, rambuf, TRUE) );
/*                    dprintf("Saved selection to sratch space\n"); */
                    rampos = 0;
                }
                /* Send the next batch of data along */
                num = ramnum - rampos;
                if (num >= fetch->buflen)
                {
                    num = fetch->buflen;
                    full = TRUE;
                }
                EG ( fail, swi (Wimp_TransferBlock,
                                R0, taskhandle,
                                R1, rambuf + rampos,
                                R2, fetch->header.taskhandle,
                                R3, fetch->buffer,
                                R4, num,  END) );

/*                dprintf ("Wimp_TransferBlock of %d bytes to receiver starting at position %d\n" _ num _ rampos); */

                transmit->header.yourref = fetch->header.myref;
                transmit->header.messageid = MESSAGE_RAM_TRANSMIT;
                transmit->numsent = num;
            
                rampos += num;
            
                EG ( fail, swi (Wimp_SendMessage, R0, full ? EV_USER_MESSAGE_RECORDED : EV_USER_MESSAGE,
                                R1, transmit,
                                R2, fetch->header.taskhandle,  END) );
                if (!full)
                {
/*                    dprintf("Ram Transfer ended normally\n"); */
                    free (rambuf);
                    rambuf = NULL;
                    interactor_cancel();

                    if (cls->move)
                        ER ( document_delete_selection (cls->doc) );

                    if (cls->closeafter)
                    {
                        if (cls->doc == paldoc)
                            return document_close_palette ();
                        else

#ifdef NOBBLE    /* close regardless in nobbled version */

                            return _document_close_window (cls->doc);

#else

                        if (cls->doc->modified)
                            return issue_close_warning (cls->doc);
                        else
                            return _document_close_window (cls->doc);

#endif
                    }
                }
            }
            break;

        case MESSAGE_RESED_OBJECT_NAME_REQUEST:
            /*
             * If the receiver replies with this message instead of
             * DataSaveAck/RamFetch, then oblige by cancelling the transfer
             * and replying with the name of the dragged object.  If it's a
             * different document, or there is more than one object being
             * dragged, then return an error indication.
             */
            block
            {
                MessageResEdObjectNameRequestPtr namereq = (MessageResEdObjectNameRequestPtr) buf;
                MessageResEdObjectNamePtr name = (MessageResEdObjectNamePtr) buf;

                *consumed = TRUE;

                /* Complain if the other party is talking about some other document
                 * or if they dragged more than one object
                 */

                if (class_lookup_cse (namereq->header.taskhandle) == NULL ||
                    (DocumentPtr) namereq->documentID != cls->doc)
                {
                    err = error_lookup ("LinkSame");
                    name->flags = BIT(0); /* error indication */
                }
                else if (cls->doc->numselected != 1)
                {
                    err = error_lookup ("LinkOne");
                    name->flags = BIT(0); /* error indication */
                }
                else
                {
                    ResourcePtr res;
                    name->flags = 0;
                    for (res = cls->doc->resources; res; res = res->next)
                        if (res->selected)
                            break;
                    name->class = res->class->class;
                    sprintf (name->name, "%.*s", MAX_OBJECT_NAME - 1, res->object->hdr.name);
                }
                
                name->header.yourref = namereq->header.myref;
                name->header.messageid = MESSAGE_RESED_OBJECT_NAME;
                name->header.size = sizeof (MessageResEdObjectNameRec);
                ER ( swi (Wimp_SendMessage, R0, EV_USER_MESSAGE,
                          R1, name,
                          R2, namereq->header.taskhandle,  END) );
                interactor_cancel ();
                return err;
            }
            break;
        }
        break;

    case EV_USER_MESSAGE_ACKNOWLEDGE:
        switch (message->messageid)
        {
        case MESSAGE_DATA_SAVE:
        case MESSAGE_DATA_LOAD:
/*            dprintf("Message bounced: %d; datasave cancelled\n" _ message->messageid); */
            *consumed = TRUE;                            /* error message here? */
            interactor_cancel();
            break;
        case MESSAGE_RAM_TRANSMIT:
/*            dprintf("Message bounced: %d; ram xfer cancelled\n" _ message->messageid); */
            *consumed = TRUE;
            interactor_cancel();
            if (rambuf) free (rambuf);
            rambuf = NULL;
            break;
        }
        break;
    }

fail:
    if (err)
    {
/*        dprintf("Error: Ram Transfer had a problem\n"); */
        if (rambuf) free (rambuf);
        rambuf = NULL;
    }
    return err;
}


/*
 * Finalise a drag operation from the Document window.  Internal drags are
 * done with special code, external ones via the DataSave protocol.
 */

static error * drag_callback (void *cls, DragDropCallbackPtr dd)
{
    DragSelectionClosurePtr clos = (DragSelectionClosurePtr) cls;
    DocumentPtr doc = clos->doc;   /* src doc */
    Bool closeafter = clos->closeafter;
    void *closure;
    RegistryType type = registry_lookup_window (dd->mouse.windowhandle, &closure);
    static DataSaveClosureRec dsclosure;

    /* Test to see whether this is a drag to one of our documents.  If
     * so, use the copy_internal routine for speed (but not if src
     * and dest documents are the same, because the copy_internal
     * routine can't handle that).
     */

    if (type == Document && doc != (DocumentPtr) closure)
    {
        /* It's a drag to one of our other Document windows */
        dragdrop_cancel ();
        if (dd->dragflags & BIT(3))
        {
            ER ( move_internal (doc, (DocumentPtr) closure) );
        }
        else if (dd->claimant != -1 && (dd->claimantsflags & BIT(3)))
        {
            ER ( move_internal (doc, (DocumentPtr) closure) );
        }
        else
        {
            ER ( copy_internal (doc, (DocumentPtr) closure) );
        }

        if (closeafter)
        {
            if (doc == paldoc)
                return document_close_palette ();
            else

#ifdef NOBBLE    /* close regardless in nobbled version */

                return _document_close_window (doc);

#else

            if (doc->modified)
                return issue_close_warning (doc);
            else
                return _document_close_window (doc);

#endif
        }
        else
            return NULL;
    }
    else if (type == Document && doc == (DocumentPtr) closure)
    {
        /* It's a drag to the same window; ignore unless SHIFT, in which case copy
         * using the DataSave method
         */

#ifdef NOBBLE  /* even SHIFT-drags in same window must be disallowed in
                  the nobbled version */

        dragdrop_cancel ();
        return NULL;

#else

        if (dd->dragflags & BIT(3))
        {
            closeafter = FALSE;   /* never close if it's the same window! */
            dsclosure.move = FALSE;
        }
        else
        {
            dragdrop_cancel ();
            return NULL;
        }

#endif

    }
    else
    {
        /* It's a drag to an alien window; DataSave it */

#ifdef NOBBLE   /* the only acceptable destinations for the nobbled version
                   are:
                      - the !ResTest application icon on the icon bar
                      - a window belonging to one of the CSEs */
        {
            int w = dd->mouse.windowhandle;
            int i = dd->mouse.iconhandle;
            int t;
            char *name = NULL;
            MessageHeaderRec dummy;
            error *err = NULL;

            /* determine handle of task associated with drop location */
            dummy.size = sizeof (MessageHeaderRec);
            dummy.yourref = 0;
            dummy.messageid = 0;
            ER ( swi (Wimp_SendMessage,
                      R0, EV_USER_MESSAGE_ACKNOWLEDGE,
                      R1, &dummy,
                      R2, w,
                      R3, i,
                    OUT,
                      R2, &t,  END) );

            /* we accept drops onto CSE windows (which will respond only by
               asking for the object's name) */
            if (class_lookup_cse (t) == NULL)
            {
                /* otherwise we only accept drops onto the icon bar */
                if (w != -2)
                {
                    dragdrop_cancel ();
                    return NULL;
                }

                /* locate task's taskname */
                err = swi (TaskManager_TaskNameFromHandle,
                                R0, t,
                              OUT,
                                R0, &name,  END);

                /* ensure terminator is 0 */
                {
                    char *c = name;

                    while (*c >= 32) c++;
                    *c = 0;
                }

                /* only accept ResTest */
                if (err != NULL || strcmp (name, "ResTest") != 0 )
                {
                    dragdrop_cancel ();
                    return NULL;
                }
            }
        }
#endif

        if (dd->dragflags & BIT(3))
        {
            closeafter = FALSE;    /* never close after move */
            dsclosure.move = TRUE;
        }
        else if (dd->claimant != -1 && (dd->claimantsflags & BIT(3)))
        {
            closeafter = FALSE;    /* never close after move */
            dsclosure.move = TRUE;
        }
        else
            dsclosure.move = FALSE;
    }

    /* Recover latest versions of the doc's objects from CSEs */
    ER ( document_recover_document (doc) );

    /* DataSave the selection in "doc" to the drop window */

    block
    {
        MessageDataSaveRec msg;

        if (dd->claimant != -1)                          /* find an agreeable filetype */
            msg.filetype = document_negotiate_filetype (dd->filetypes, dd->claimantstypes);
        else
            msg.filetype = dd->filetypes[0];

        msg.header.size = sizeof(MessageDataSaveRec);
        msg.header.yourref = (dd->claimant != -1 ? dd->claimantsref : 0);
        msg.header.messageid = MESSAGE_DATA_SAVE;
        msg.windowhandle = dd->mouse.windowhandle;
        msg.iconhandle = dd->mouse.iconhandle;
        msg.position = dd->mouse.position;
        msg.estsize = document_file_size (doc, TRUE);
        strcpy(msg.leafname, message_lookup(&msgs, "Selection"));

        ER ( swi (Wimp_SendMessage,
                  R0, EV_USER_MESSAGE_RECORDED,
                  R1, &msg,
                  R2, dd->mouse.windowhandle,
                  R3, dd->mouse.iconhandle,  END) );

        dsclosure.doc = doc;
        dsclosure.closeafter = closeafter;

        interactor_install (datasave_interactor, (void *) &dsclosure);
    }
    return NULL;
}


/*
 * Commence a drag operation on the document window.  The coords in
 * 'mouse' are screen-relative.
 */

static int filetypes [] = {FILETYPE_RESOURCE, -1};

static error * start_drag (DocumentPtr doc, ResourcePtr res, MouseClickPtr mouse, unsigned int modifiers)
{
    if (res)
    {
        /* Drag selection */
        RectRec bbox;
        static DragSelectionClosureRec closure;
        get_selection_bbox (doc, &bbox);
        wimp_convert_rect (WorkToScreen, &doc->window, &bbox, &bbox);

        closure.doc = doc;
        closure.closeafter = (mouse->buttons == MB_DRAG(MB_ADJUST));

        ER ( dragdrop_start (&bbox, FALSE,               /* bbox is not data's real size */
                             BIT(1) | ((modifiers & MODIFIER_SHIFT) ? BIT(3) : 0),
                             filetypes,
                             drag_callback,
                             (void *) &closure,
                             res->class->spritename,
                             doc->numselected) );
    }
    else
    {
        /* Lassoo icons */
        DragBoxRec drag;
        static DragClosureRec closure;
        PointRec work;

        interactor_cancel();
        wimp_convert_point (ScreenToWork, &doc->window, &mouse->position, &work);
        closure.doc = doc;
        closure.buttons = mouse->buttons;
        closure.modifiers = modifiers;
        closure.workbox.minx = work.x;
        closure.workbox.miny = work.y;
        closure.workbox.maxx = work.x + scalex;
        closure.workbox.maxy = work.y + scaley;

        wimp_update_eor_box (&doc->window, &closure.workbox);

        drag.windowhandle = doc->window.handle;
        drag.type = 7;
        drag.constrain = doc->window.visarea;

        ER ( swi (Wimp_DragBox,  R1, &drag,  END) );

        interactor_install (lassoo_interactor, (void *) &closure);
        interactor_enable_events (BIT(EV_NULL_REASON_CODE));
        interactor_set_timeout (5);
    }
    return NULL;
}


/*
 * Type-in renaming.
 */

typedef struct
{
    DocumentPtr doc;
    ResourcePtr res;
    int icon;
    char newname[MAX_OBJECT_NAME];
    CaretPositionRec caret;
    Bool resetcaret;
} RenameClosureRec, *RenameClosurePtr;


/*
 * Finalise a rename operation.  Called from the type-in renaming stuff
 * below as well as the rename dialogue code.
 */

error * document_rename_resource (DocumentPtr doc, ResourcePtr res, char *newname)
{
    if (strlen (newname) == 0)
        return NULL;    /* quietly refuse */
    if (strcmp (newname, res->object->hdr.name) == 0)
        return NULL;    /* same name */
    if ((!privateflag && newname[0] == '_') || isdigit (newname[0]))
        return error_lookup ("BadName");
    if (checkunique (doc, newname) == FALSE)
        return error_lookup ("NotUnique", newname);
    
    sprintf (res->object->hdr.name, "%.*s", MAX_OBJECT_NAME - 1, newname);
    
    protocol_send_resed_object_renamed (doc, res);

    document_modified (doc, TRUE);
    ER ( sort_document(doc) );
    return relayout(doc);
}


/*
 * RETURN finishes a rename operation.  Many other events cause cancellation.  The
 * losing caret stuff is surprisingly difficult to get right.
 */

static error * rename_interactor (unsigned int event, int *buf, void *closure, Bool *consumed)
{
    RenameClosurePtr rename = (RenameClosurePtr) closure;
    CaretPositionPtr caret = (CaretPositionPtr) buf;
    MouseClickPtr mouse = (MouseClickPtr) buf;
    KeyPressPtr key = (KeyPressPtr) buf;
    PointRec p;
    
    if (buf == NULL)            /* we are being asked to cancel */
    {
        int iblock[2];
        iblock[0] = rename->doc->window.handle;
        iblock[1] = rename->icon;
        ER ( swi (Wimp_DeleteIcon,  R1, &iblock,  END) );
        ER ( wimp_invalidate (&rename->doc->window, &rename->res->namebbox) );

        if (rename->resetcaret)
            return swi (Wimp_SetCaretPosition,
                        R0, rename->caret.windowhandle,  R1, rename->caret.iconhandle,
                        R2, rename->caret.position.x,  R3, rename->caret.position.y,
                        R4, rename->caret.height,  R5, rename->caret.index,  END);
    }

    switch (event)
    {
    case EV_NULL_REASON_CODE:           case EV_REDRAW_WINDOW_REQUEST:
    case EV_POINTER_ENTERING_WINDOW:    case EV_POINTER_LEAVING_WINDOW:
    case EV_GAIN_CARET:                 case EV_USER_MESSAGE:
    case EV_USER_MESSAGE_RECORDED:      case EV_USER_MESSAGE_ACKNOWLEDGE:
        break;

    case EV_LOSE_CARET:
        if (caret->windowhandle == rename->doc->window.handle &&
            wimp_point_inside(&rename->res->namebbox, &caret->position))
        {
            rename->resetcaret = FALSE;
            interactor_cancel();
        }
        break;

    case EV_MOUSE_CLICK:
        p.x = mouse->position.x - (rename->doc->window.visarea.minx - rename->doc->window.scrolloffset.x);
        p.y = mouse->position.y - (rename->doc->window.visarea.maxy - rename->doc->window.scrolloffset.y);
        if (mouse->windowhandle == rename->doc->window.handle &&
            wimp_point_inside(&rename->res->namebbox, &p))
            *consumed = TRUE;
        else
            interactor_cancel();
        break;

    case EV_KEY_PRESSED:
        if (key->caret.windowhandle == rename->doc->window.handle &&
            key->code == 13)
        {
            error *err = NULL;

            *consumed = TRUE;

            /* Name changed.  Check to see if it is unique */
            err = document_rename_resource (rename->doc, rename->res, rename->newname);
            if (err)
                error_box (err);
            else
                interactor_cancel ();
        }
        break;

    default:
        interactor_cancel();
        break;
    }
    return NULL;
}


static error * start_rename (DocumentPtr doc, ResourcePtr res, PointPtr position)
{
    static RenameClosureRec closure;
    CreateIconRec create;

    interactor_cancel();

    sprintf (closure.newname, "%.*s", MAX_OBJECT_NAME - 1, res->object->hdr.name);

    create.windowhandle = doc->window.handle;
    create.icon = docrenameproto;
    create.icon.bbox = res->namebbox;
    create.icon.data[0] = (int) closure.newname;

    ER ( swi (Wimp_CreateIcon,  R1, &create,  OUT,  R0, &closure.icon,  END) );
    closure.doc = doc;
    closure.res = res;
    closure.resetcaret = TRUE;

    ER ( wimp_invalidate (&doc->window, &res->namebbox) );

    interactor_install (rename_interactor, (void *) &closure);
    
    ER ( swi (Wimp_GetCaretPosition,  R1, &closure.caret,  END) );
    ER ( swi (Wimp_SetCaretPosition,
              R0, doc->window.handle,  R1, closure.icon,
              R2, position->x,  R3, position->y,  R4, -1,  R5, -1,  END ) );

    return  NULL;
}


/* Do any shading etc necessary before posting the menu */

static void prepare_menu (DocumentPtr doc, Bool selection)
{
    if (selection)
    {
        /* We have a selection */
        menu_shade_menu (editmenu, FALSE);
        if (doc->numselected != 1)
        {
            /* XXX need to make these submenus untraversable, as well
             * as shaded (because they have dboxes at the end).  How?
             */
            menu_shade (editmenu, EDITMENU_COPY, TRUE);
            menu_shade (editmenu, EDITMENU_RENAME, TRUE);
        }
    }
    else
    {
        /* No selection in this doc */
        menu_shade_menu (editmenu, TRUE);
        menu_shade (editmenu, EDITMENU_SELALL, FALSE);
    }

#ifdef NOBBLE         /* shade out "save" entry if nobbled version */
    menu_shade (filemenu, FILEMENU_SAVE, TRUE);
#endif

}

/*
 * Callback for the document menu.
 */

static error * docmenu_cb (MenuPtr menu, int *buf, void *closure, Bool adjust)
{
    DocumentPtr doc = (DocumentPtr) closure;
    if (buf)
    {
        if (buf[0] == DOCMENU_FILE)
        {
            if (buf[1] == FILEMENU_SAVE)
            {
                ER ( save_document_directly (doc) );
            }
        }
        else if (buf[0] == DOCMENU_EDIT)
        {
            if (buf[1] == EDITMENU_COPY)
            {
                /* XXX Insert code for copy selection here */
            }
            else if (buf[1] == EDITMENU_DELETE)
            {
                ER ( document_delete_selection (doc) );
            }
            else if (buf[1] == EDITMENU_SELALL)
            {
                doc->weakselection = FALSE;
                ER ( document_select_all (doc) );
            }
            else if (buf[1] == EDITMENU_CLEAR)
            {
                ER ( document_clear_selection (doc) );
            }
        }
        else if (buf[0] == DOCMENU_PALETTE)
        {
            ER ( document_create_palette () );
        }


        if (adjust)
            prepare_menu (doc, doc->numselected != 0);
    }
    else
        if (!adjust && doc->weakselection)
            document_clear_selection (doc);

    return NULL;
}


/*
 * Post the document menu.  The window should already have
 * the focus.
 */

static error * post_docmenu (PointPtr workposition, PointPtr screenposition, DocumentPtr doc)
{
    ResourcePtr res;
    if (doc->numselected != 0)
    {
        /* We have a selection */
        doc->weakselection = FALSE;
        prepare_menu (doc, TRUE);
    }
    else if ((res = which_sprite_icon (doc, workposition)) != NULL ||
             (res = which_name_icon (doc, workposition)) != NULL)
    {
        select_icon (doc, res, TRUE);
        doc->weakselection = TRUE;
        prepare_menu (doc, TRUE);
    }
    else
    {
        doc->weakselection = FALSE;
        prepare_menu (doc, FALSE);
    }

    return menu_post (docmenu, screenposition, FALSE, docmenu_cb, (void *) doc);
}


/*
 * Handle clicks on Document window.
 */

error * document_mouse_click (MouseClickPtr mouse, unsigned int modifiers, DocumentPtr doc)
{
    PointRec position;
    ResourcePtr res;

    position.x = mouse->position.x - (doc->window.visarea.minx - doc->window.scrolloffset.x);
    position.y = mouse->position.y - (doc->window.visarea.maxy - doc->window.scrolloffset.y);

    /* All clicks gain the caret and focus */
    document_claim_focus (doc);

    switch (mouse->buttons)
    {
    case MB_DOUBLE(MB_SELECT):
        if (doc->internal)
            return NULL;
        res = which_name_icon (doc, &position);
        if (!res) res = which_sprite_icon (doc, &position);
        if (!res) break;

        /* Call CSE to open/raise the object 'res'.  CSE is also
         * responsible for putting caret and focus in its window.
         */
        ER ( class_launch_cse (res->class) );
        ER ( protocol_send_resed_object_load (doc, res, FALSE) );
        break;
        
    case MB_SINGLECLICK(MB_SELECT):
        res = which_name_icon (doc, &position);
        if (res && (modifiers & MODIFIER_ALT))
        {
            if (doc->internal)
                return NULL;
            ER ( start_rename (doc, res, &position) );
        }
        else
        {
            if (res == NULL)
                res = which_sprite_icon (doc, &position);
            if (res == NULL)
            {
                ER ( document_clear_selection(doc) );
            }
            else if (!res->selected)
            {
                document_clear_selection(doc);
                ER ( select_icon(doc, res, TRUE) );
            }
        }
        break;

    case MB_SINGLECLICK(MB_ADJUST):
        res = which_name_icon (doc, &position);
        if (res == NULL)
            res = which_sprite_icon (doc, &position);
        if (res)
            ER ( select_icon(doc, res, !res->selected) );
        break;

    case MB_MENU:
        if (doc->internal)
            return NULL;
        post_docmenu (&position, &mouse->position, doc);
        break;

    case MB_DRAG(MB_SELECT):
    case MB_DRAG(MB_ADJUST):
        res = which_name_icon (doc, &position);
        if (res == NULL)
            res = which_sprite_icon (doc, &position);
        if (mouse->buttons == MB_DRAG(MB_ADJUST))
            ER ( select_icon (doc, res, TRUE) );
        ER ( start_drag(doc, res, mouse, modifiers) );
        break;
    }
    return NULL;
}


/*
 * Message_Dragging handler for Document windows.  This does not have to
 * do much since the document window does not have any concept
 * of insertion point.  A more complex one would do ghost
 * caret feedback, etc, and would store data for the DataSave handler
 * to use later.
 */

error * document_claim_drag (DocumentPtr doc,            /* the document in this window */
                             int windowhandle,           /* window handle of receiver/claimant */
                             MessageDraggingPtr msg,     /* may contain different widow handle */
                             int *claimref)              /* update with new myref, else 0 */
{
    int reply[64];
    MessageDragClaimPtr claim = (MessageDragClaimPtr) reply;
    static Bool donepointer = FALSE;
    Bool removeptr;

    *claimref = 0;

    if (msg == NULL)                                     /* Drag-n-drop aborted */
    {
        donepointer = FALSE;
        (void) dragdrop_scroll (NULL, NULL, NULL);
        return NULL;                                     /* no feedback to undo */
    }

/* dprintf ("        MESSAGE_DRAGGING Offered to win %d (for %d)\n" _ windowhandle _ msg->windowhandle); */

    if (windowhandle != msg->windowhandle)               /* Left claim window, so bounce message */
    {
        donepointer = FALSE;
        (void) dragdrop_scroll (NULL, NULL, NULL);
        return NULL;
    }

    if (dragdrop_scroll (&doc->window, &msg->position, &removeptr))
    {
        if (donepointer == FALSE)
        {
            dragdrop_scroll_pointer ();
            donepointer = TRUE;
        }
    }
    if (donepointer && removeptr)
        donepointer = FALSE;

    claim->header.yourref = msg->header.myref;           /* Reply */
    claim->header.messageid = MESSAGE_DRAG_CLAIM;
/*    claim->flags = 0;                               */
/*    claim->flags = 2 + (donepointer ? BIT(0) : 0);  */
    claim->flags = donepointer ? BIT(0) : 0;

    {
        int *filetypes = claim->filetypes;

        *filetypes = FILETYPE_RESOURCE;
        *(filetypes + 1) = -1;
    }

    claim->header.size = sizeof (MessageDragClaimRec) + sizeof(int);
                                                         /* needs increasing if length of filetypes list grows*/

    ER ( swi (Wimp_SendMessage,  R0, EV_USER_MESSAGE,  R1, claim,  R2, msg->header.taskhandle,  END) );
    *claimref = claim->header.myref;
/* dprintf("         Replying with MESSAGE_DRAG_CLAIM ref == %d\n" _ *claimref); */
    return NULL;
}


/*
 * Clear up on exit.
 */

void document_free_all ()
{
    int i = 0;
    RegistryType type;
    void *closure;
    while ((i = registry_enumerate_windows (i, &type, NULL, &closure)) != 0)
    {
        if (type == Document)
        {
            DocumentPtr doc = (DocumentPtr) closure;

            if (doc == paldoc)
                document_close_palette ();
            else
                _document_close_window (doc);
        }
    }
}


/*
 * Look for a document with the given filename.
 */

DocumentPtr document_lookup_by_filename (char *name)
{
    int i = 0;
    RegistryType type;
    void *closure;
    while ((i = registry_enumerate_windows (i, &type, NULL, &closure)) != 0)
    {
        if (type == Document)
        {
            DocumentPtr doc = (DocumentPtr) closure;
            if (doc->fullpath &&
                doc->namelength == strlen(name) &&
                strncmp (name, doc->title, doc->namelength) == 0)
            {
                return doc;
            }
        }
    }
    return NULL;
}


/*
 * Raise the specified document to the top of the
 * window stack.  Also claim caret and focus.
 */

error * document_raise_window (DocumentPtr doc)
{
    if (doc->window.handle != -1)
    {
        doc->window.behind = -1;
        ER ( swi (Wimp_OpenWindow,  R1, &doc->window,  END) );
        ER ( document_claim_focus (doc) );
    }
    return NULL;
}


/*
 * Keyboard shortcuts.
 */

error * document_key_pressed (DocumentPtr doc, KeyPressPtr key, Bool *consumed)
{
    error *err = NULL;

    *consumed = FALSE;

    if (key->code == key_selectall)
        err = document_select_all (doc);
    else if (key->code == key_clearsel)
        err = document_clear_selection (doc);

    /* only ^A and ^Z are allowed on the palette window */
    else if (!doc->internal)
    {
        if (key->code == key_save)
        {
            PointerInfoRec pointer;
            char name[FILENAMELEN];

            *consumed = TRUE;
            interactor_cancel ();  /* remove any menu */
            sprintf (name, "%.*s", doc->namelength, doc->title);
            ER ( swi (Wimp_GetPointerInfo,  R1, &pointer,  END) );
            return saveas_open (TRUE, TRUE, FALSE, &pointer.position, name,
                                FILETYPE_RESOURCE,
                                save_document_cb, (void *) doc);
        }
        else if (key->code == key_delete)
        {
            if (doc->numselected > 0)
                err = document_delete_selection (doc);
        }
        else if (key->code == key_objflags)
        {
            if (doc->numselected > 0)
            {
                *consumed = TRUE;
                interactor_cancel ();  /* remove any menu */
                return objflags_open (doc, NULL);
            }
        }
        else
            return NULL;
    }
    else
        return NULL;

    /* keypress has been processed */
    *consumed = TRUE;

    /* cancel any foreground interaction in progress (eg menu) */
    interactor_cancel ();

    return err;
}




/*
 * DOCUMENT LOADING
 */

/*
 * Append the resources in the given block of memory to the
 * document "doc".  Name clashes are handled by name disambiguation
 * which is reported to the user if 'silent' is FALSE.
 *
 * If an error occurs, give up processing the file.  Leave any
 * fully-loaded templates in "doc", but delete partial ones, ensuring
 * the data structures are still consistent.
 *
 * 'isnew' is set TRUE if 'doc' is a new document.
 */

error * document_load (char *buf, int size, DocumentPtr doc, Bool silent, Bool select, Bool isnew)
{
    ResourceFileHeaderPtr hdr = (ResourceFileHeaderPtr) buf;
    ResourcePtr new = NULL;
    error *err = NULL;
    int numdis = 0;
    int off = hdr->objectoffset;
    
    /* All loads gain the caret and focus unless to the palette */
    if (doc->internal == FALSE)
    {
        (void) document_claim_focus (doc);
        if (select)
            (void) document_clear_selection (doc);
    }

    if (hdr->fileid != ('F' << 24 | 'S' << 16 | 'E' << 8 | 'R')) /* 'FSER' */
    {
        return error_lookup("BadMagic");
    }

    switch (hdr->versionnumber)
    {
    case 100:
    case RESF_VERSION:
        break;

    /* only the versions above can be processed by this version of !ResEd */
    default:
        {
            char ver[20];
            sprintf(ver, "%d.%02d", hdr->versionnumber / 100, hdr->versionnumber % 100);
            return error_lookup("BadVersion", ver);
        }
    }

    /* Version number and objectoffset will be set when the document
     *  is saved, so do not need to be copied from hdr to doc.
     */

    if (off == -1)
        return NULL;                    /* Empty file */

    /* Loop over all the objects in the file */

    while (off < size)
    {
        ResourceFileObjectTemplateHeaderPtr objhdr = (ResourceFileObjectTemplateHeaderPtr) (buf + off);
        int total = toolbox_object_size (objhdr);
        ResourceFileObjectTemplateHeaderPtr copy = (ResourceFileObjectTemplateHeaderPtr) malloc(total);

/*        dprintf("off is now %d\n" _ off); */
/*        dprintf("total size %d\n" _ total); */

        if (copy == NULL)
            return error_lookup("NoMem");

        memcpy ((void *) copy, (void *) objhdr, total);
        
/*        dprintf("  RESNAME %s\n" _ copy->hdr.name); */
        if (document_disambiguate_name (doc, copy->hdr.name))
        {
            numdis++;
/*            dprintf (" DISAMBIGUATED TO %s\n" _ copy->hdr.name); */
        }

        /* Below increments doc->numresources & links it in, also fixes */
        /* up the dirviewer */

        if ((err = document_add_resource (doc, &new, isnew)) != NULL)
        {
            free((char *) copy);
            break;
        }

        new->object = copy;
        new->class = class_lookup (copy->hdr.class); /* NULL for unknown classes */

        if (select)
        {
            new->selected = TRUE;
            doc->numselected++;
        }

        /* Step along to the next one */
        off += total;
    }

    /* Warn user if any resource names were disambiguated */

    if (!silent && numdis != 0)
        error_box (error_lookup (numdis == 1 ? "DisOne" : "DisSome", numdis));

    ER ( sort_document(doc) );
    ER ( relayout(doc) );               /* does ForceRedraw for us */

    return err;
}


/*
 * Append the resources in "filename" to the document "doc".  Get the
 * window up to date, etc.
 *
 * 'isnew' is set TRUE if 'doc' is a new document.
 */

error * document_load_file (char *filename, DocumentPtr doc, Bool silent, Bool select, Bool isnew)
{
    FILE *file = fopen(filename, "r");
    char *buf = NULL;
    int size;
    error *err = NULL;

    if (!file) return error_lookup("CantRead", filename);
    fseek(file, 0, SEEK_END);
    size = (int) ftell(file);
    
    buf = calloc(size, sizeof(char));
    if (!buf)
    {
        err = error_lookup("NoMem");
        goto fail;
    }

    fseek(file, 0, SEEK_SET);
    fread (buf, sizeof(*buf), size, file);

    err = document_load (buf, size, doc, silent, select, isnew);

 fail:
    if (buf) free(buf);
    if (file) fclose(file);
    return err;
}


/*
 * PALETTE HANDLING
 *
 * The palette is a normal document, mostly.  When the user first attempts
 * to look at the palette, document_create_palette() creates the palette document
 * with _document_create_palette and then fills it in using class_prime_palette().
 * The variable paletteopen is then used to keep track of whether the palette
 * is on view - unlike other documents, the Close icon of the palette just
 * closes the window, it doesn't delete it.
 */

static Bool paletteopen = FALSE;


/*
 * Construct the palette, if necessary, and then open it.  If it is already
 * open then just raise it.
 */

error * document_create_palette ()
{
    static Bool madepalette = FALSE;
    if (!madepalette)
    {
        _document_create_palette (&paldoc);
        class_prime_palette ();
        madepalette = TRUE;
    }
    else
        document_raise_window (paldoc);
    paletteopen = TRUE;
    return NULL;
}


/*
 * Close the palette's window, but don't delete it.
 */

error * document_close_palette ()
{
    if (paletteopen)
        ER ( swi (Wimp_CloseWindow,  R1, &paldoc->window,  END) );
    paletteopen = FALSE;
    return NULL;
}


/*
 * Merge the specified file into paldoc.
 */

error * document_merge_palette (char *filename)
{
    return document_load_file (filename, paldoc, TRUE, FALSE, FALSE);
}



Bool document_exists (DocumentPtr doc)
{
    int i = 0;
    RegistryType type;
    void *closure;

    while ((i = registry_enumerate_windows (i, &type, NULL, &closure)) != 0)
        if (type == Document && (DocumentPtr) closure == doc)
            return TRUE;
    return FALSE;
}


/*
 * Finalise a copy operation.  Called from the copy dialogue code.
 */

error * document_copy_resource (DocumentPtr doc, ResourcePtr res, char *newname)
{
    error *err = NULL;
    if (strlen (newname) == 0)
        return NULL;    /* quietly refuse */
    if ((!privateflag && newname[0] == '_') || isdigit (newname[0]))
        return error_lookup ("BadName");
    if (checkunique (doc, newname) == FALSE)
        return error_lookup ("NotUnique", newname); 
    
    ER ( document_recover_resource (doc, res) );

    block
    {
        int total = toolbox_object_size (res->object);
        ResourceFileObjectTemplateHeaderPtr copy = (ResourceFileObjectTemplateHeaderPtr) malloc(total);
        ResourcePtr new = NULL;

        if (copy == NULL)
            return error_lookup("NoMem");

        memcpy ((void *) copy, (void *) res->object, total);
        sprintf (copy->hdr.name, "%.*s", MAX_OBJECT_NAME - 1, newname);
        
        /* Below increments doc->numresources & links it in, also fixes */
        /* up the dirviewer */

        if ((err = document_add_resource (doc, &new, FALSE)) != NULL)
        {
            free((char *) copy);
            return err;
        }

        new->object = copy;
        new->class = class_lookup (copy->hdr.class); /* NULL for unknown classes */

        document_modified (doc, TRUE);
        ER ( sort_document(doc) );
        ER ( relayout(doc) );
    }
    return NULL;
}


/*
 * Recover the specified block of data from the CSE and
 * assign it to the given resource, replacing the previous
 * data associated with it.
 */

error * document_recover_object_data (DocumentPtr doc, ResourcePtr res, int address, int size)
{
    error *err;
    ResourceFileObjectTemplateHeaderPtr new;
    if (!document_exists(doc) || res->owner != doc)
        return NULL;
    new = (ResourceFileObjectTemplateHeaderPtr) malloc(size);
    if (new == NULL)
        return error_lookup("NoMem");
    
    err = swi (Wimp_TransferBlock,
               R0, res->class->cse->taskid,
               R1, address,
               R2, taskhandle,
               R3, (int) new,
               R4, size,  END);
    if (err)
    {
        free((char *) new);
        return err;
    }
    
    /* Make sure the name is up to date */
    memcpy((void *)new->hdr.name, (void *)res->object->hdr.name, sizeof(new->hdr.name));
    /* Use the shell's copy of flags word, not the CSE's */
    new->hdr.flags = res->object->hdr.flags;

    free ((char *) res->object);
    res->object = new;
    res->modified = FALSE;

    return NULL;
}


/*
 * Recover the latest version of an object from its CSE.
 *
 * This uses a mini Wimp_Poll loop to greatly simplify the business
 * of exchanging messages with the CSEs while looping over all the
 * resources in the doc.
 */

error * document_recover_resource (DocumentPtr doc, ResourcePtr res)
{
    if (res->editing && res->modified && res->class->cse->taskid)
    {
        MessageResEdObjectSendRec send;
        send.header.size = sizeof(send);
        send.header.yourref = 0;
        send.header.messageid = MESSAGE_RESED_OBJECT_SEND;
        send.flags = 0;
        send.documentID = (Opaque) doc;
        send.objectID = (Opaque) res;
        ED (swi (Wimp_SendMessage,
                 R0, EV_USER_MESSAGE_RECORDED,
                 R1, &send,
                 R2, res->class->cse->taskid,  END));

        /* Now poll the Wimp awaiting a reply or a bounce */

        for (; ;)
        {
            int event, buf[64];
            MessageResEdObjectSendingPtr sending = (MessageResEdObjectSendingPtr) buf;
            MessageResEdObjectSendPtr bounce = (MessageResEdObjectSendPtr) buf;

            EE ( main_next_event (&event, buf) );

            if ((event == EV_USER_MESSAGE || event == EV_USER_MESSAGE_RECORDED)
                && sending->header.messageid == MESSAGE_RESED_OBJECT_SENDING
                && sending->header.yourref == send.header.myref)
            {
                /* Ask the protocol code to recover the data & reply */
                ER ( protocol_incoming_message (event, buf, NULL) );
                break;
            }
            else if (event == EV_USER_MESSAGE_ACKNOWLEDGE
                     && bounce->header.messageid == MESSAGE_RESED_OBJECT_SEND
                     && bounce->header.myref == send.header.myref)
            {
                /* CSE did not respond; give up waiting.  The object will
                 * be marked unmodified by the code below.  The assumption is
                 * that the CSE has died and we'll do the tidying up after
                 * we get Message Wimp_TaskCloseDown
                 */
                break;
            }
            else                /* process other events as normal */
            {
                ED (main_dispatch_event (event, buf));
            }
        }
    }
    res->modified = FALSE;
    return NULL;
}


error * document_recover_document (DocumentPtr doc)
{
    ResourcePtr res = doc->resources;
    for (; res; res = res->next)
    {
        ER ( document_recover_resource (doc, res) );
    }
    return NULL;
}


/*
 * Generate a suitable interactive help message for the document window.
 * The pointer is at position 'mouse', and the text should be stored at
 *  'reply'.
 * Called from help_message(..).
 * Returns TRUE iff help text has been located.
 */

Bool document_help_text (
    DocumentPtr doc,
    PointPtr mouse,
    char *reply
)
{
    ResourcePtr res;
    char *token;
    char buf[MAX_HELP_TEXT];

    /* convert mouse position to work area coordinates */
    wimp_convert_point (ScreenToWork, &doc->window, mouse, mouse);

    /* before asking where the pointer is */
    res = which_sprite_icon (doc, mouse);
    if (res == NULL)
        res = which_name_icon (doc, mouse);

    if (doc->internal)        /* palette window */
    {
        if (res == NULL)   /* pointer on background */
            return help_lookup_token ("Hlp.P", reply, MAX_HELP_TEXT);

        /* pointer over object template icon */
        if (!help_lookup_token ("Hlp.PI", buf, MAX_HELP_TEXT))
            return FALSE;

        sprintf (reply, buf, res->class->classname);

        token = (res->selected) ? "Hlp.PIS" : "Hlp.PIN";
        return help_lookup_token (token, reply + strlen (reply),
                                 MAX_HELP_TEXT - strlen (reply));
    }

    else                      /* resource file display window */
    {
        if (res == NULL)   /* pointer on background */
            return help_lookup_token ("Hlp.E", reply, MAX_HELP_TEXT);

        /* pointer over object template icon */
        if (!help_lookup_token ("Hlp.EI", buf, MAX_HELP_TEXT))
            return FALSE;

        sprintf (reply, buf, res->class->classname);

        token = (res->selected) ? "Hlp.EIS" : "Hlp.EIN";
        return help_lookup_token (token, reply + strlen (reply),
                                 MAX_HELP_TEXT - strlen (reply));
    }
}
