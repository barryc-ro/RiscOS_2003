/*-*-C-*-
 * windowedit
 *
 * Note: the window handling and redraw code relies on the top-left corner of
 * the extent being at 0,0.
 *
 *
 * Some notes on layout.
 *
 * The work area extent of the window is set up in the conventional
 * way with 0,0 at the top left, and Y becoming more negative as you go
 * down the page.
 */

#include "resed.h"
#include "main.h"

#include "swicall.h"
#include "wimp.h"
#include "resformat.h"
#include "newmsgs.h"
#include "focus.h"
#include "interactor.h"
#include "menu.h"
#include "registry.h"

#include "format.h"
#include "relocate.h"
#include "windowedit.h"
#include "align.h"
#include "colours.h"
#include "coords.h"
#include "drag.h"
#include "extent.h"
#include "gadget.h"
#include "grid.h"
#include "gui.h"
#include "help.h"
#include "keycuts.h"
#include "lassoo.h"
#include "move.h"
#include "props.h"
#include "protocol.h"
#include "resize.h"
#include "toolbars.h"
#include "winddrag.h"
#include "windinfo.h"


static WindowPtr windowwinproto;
static int windowwinsize;
static WindowObjPtr palette = NULL;

static MenuPtr windowmenu = NULL, editmenu = NULL,
               alignmenu = NULL, selectmenu = NULL;
static int key_mainprops, key_extent, key_keys, key_toolbars, key_grid,
           key_gadgets, key_close, key_delete, key_gadgetprops, key_snap,
           key_radiogroup, key_linkwritables, key_coordinates, key_selectall,
           key_clearsel, key_selectradiogroup;

#define WINDOWMENU_INFO        0
#define WINDOWMENU_EDIT        1
#define WINDOWMENU_MPROPS      2
#define WINDOWMENU_OPROPS      3
#define WINDOWMENU_COLOURS     4
#define WINDOWMENU_EXTENT      5
#define WINDOWMENU_KEYS        6
#define WINDOWMENU_TOOLBARS    7
#define WINDOWMENU_GRID        8
#define WINDOWMENU_PALETTE     9
#define WINDOWMENU_CLOSE      10

#define EDITMENU_DELETE        0
#define EDITMENU_PROPS         1
#define EDITMENU_SNAP          2
#define EDITMENU_RADIOGROUP    3
#define EDITMENU_LINKWRITE     4
#define EDITMENU_COORDS        5
#define EDITMENU_ALIGN         6
#define EDITMENU_SELALL        7
#define EDITMENU_SELECT        8
#define EDITMENU_CLEAR         9

#define SELECTMENU_RADIOGROUP        0
#define SELECTMENU_NEXTWRITABLE      1
#define SELECTMENU_PREVIOUSWRITABLE  2
#define SELECTMENU_DEFAULTWRITABLE   3
#define SELECTMENU_DEFAULTACTION     4
#define SELECTMENU_CANCELACTION      5


typedef struct
{
    WindowObjPtr window;
    GadgetPtr gadget;
} MenuClosRec, *MenuClosPtr;

static MenuClosRec menuclosure;


/* description of each resize ear */
#define  EAR_SIZE   16   /* resize ears are square - must be multiple of 4 */
#define  EAR_COLOUR 11   /* red */


/* "About to redraw window containing gadgets" service call */
#define SERVICE_REDRAW  0x44ec6


/* Forward references */
static error * windowedit_open_palette (void);
static error * create_menu (void);


/*
 * Make a malloced copy of a string.  If the src string is NULL, return NULL.
 */

char *copystring (char *src)
{
    if (src != NULL)
    {
        char *dst = malloc (strlen (src) + 1);
        if (dst) strcpy (dst, src);
        return dst;
    }
    else
        return NULL;
}


/*
 * If the location addressed by s contains NULL, do nothing. Otherwise, make
 *  a copy of the string addressed by *s, and store its address at *s.
 *
 * Result is NULL unless memory runs out, in which case a suitable error
 *  message is returned.
 */

error * clonestring (char **s)
{
    char *clone;

    if (*s == NULL)
        return NULL;

    clone = (char *) malloc (strlen(*s) + 1);
    if (clone == NULL)
        return error_lookup ("NoMem");

    strcpy (clone, *s);
    *s = clone;
    return NULL;
}


/*
 * Compare two values which may be NULL or may be strings
 */

Bool equalstrings (char *s, char *t)
{
    return (s == NULL && t == NULL ||
            s != NULL && t != NULL && strcmp (s, t) == 0);
}


/*
 * Load Templates pertaining to this module
 */

error * windowedit_load_prototypes ()
{
    ER ( create_menu () );
    return wimp_load_template_returning_size ("windowwin", &windowwinproto, &windowwinsize);
}


/*
 * Plot the special "internal" resize ear that allows the user to alter the
 *  size of a display or writable field inside a number range gadget.
 */

static error * plot_numberrange_special_ear (GadgetPtr gadget)
{
    /* must have numeric field and slider in order to change its size */
    if ((gadget->hdr.flags & NUMBERRANGE_NONUMERICALDISPLAY) == 0 &&
        (gadget->hdr.flags & NUMBERRANGE_SLIDERTYPE) != NUMBERRANGE_NOSLIDER)
    {
        IconRec ear;
        int colour = EAR_COLOUR;
        int bgcolour = gadget->owner->window->colours.workBG;
        int x, y;

        /* ensure highlight colour is different from window background */
        if (colour == bgcolour)
            colour = uncolour[bgcolour];

        /* set icon flags for ear */
        ear.flags = IF_BORDER |
                    (6 << IF_TYPE_SHFT) |      /* button type = click/drag */
                    (colour << IF_FG_SHFT);

        /* determine position to plot ear */
        if ((gadget->hdr.flags & NUMBERRANGE_SLIDERTYPE) ==
                                           NUMBERRANGE_SLIDERLEFT)
            x = gadget->hdr.bbox.maxx -
                    (gadget->body.numberrange.displaylength + EAR_SIZE/2);
        else
            x = gadget->hdr.bbox.minx +
                    (gadget->body.numberrange.displaylength - EAR_SIZE/2);
        y = gadget->hdr.bbox.miny +
                (gadget->hdr.bbox.maxy - gadget->hdr.bbox.miny - EAR_SIZE)/2;

        /* and plot it */
        ear.bbox.minx = x;
        ear.bbox.maxx = x + EAR_SIZE;
        ear.bbox.miny = y;
        ear.bbox.maxy = y + EAR_SIZE;
        ER ( swi (Wimp_PlotIcon, R1, &ear, END) );
    }

    return NULL;
}


/*
 * Given a gadget's bounding box, return the coordinates of its resize ears
 * in the arrays given.  All in work coords.
 */

static void find_resize_ears (RectPtr bbox, int *x, int *y)
{
    x[0] = bbox->minx+scalex - EAR_SIZE;
    x[1] = bbox->minx + (bbox->maxx - bbox->minx - EAR_SIZE) / 2;
    x[2] = bbox->maxx-scalex;
    y[0] = bbox->miny+scaley - EAR_SIZE;
    y[1] = bbox->miny + (bbox->maxy - bbox->miny - EAR_SIZE) / 2;
    y[2] = bbox->maxy-scaley;
}


/*
 * Given the bbox of a gadget, plot the "highlight" rectangle around it,
 *  together with the six resize ears (if 'withears' is TRUE).
 * The bbox is in work-area coordinates; note that it is half-open.
 */

static error * plot_highlight (
    WindowObjPtr window,
    RectPtr work,
    Bool withears
)
{
    IconRec ear;
    RectRec bbox;
    int colour = EAR_COLOUR;
    int bgcolour = window->window->colours.workBG;
    int x[3], y[3], xx, yy;

    /* ensure highlight colour is different from window background */
    if (colour == bgcolour)
        colour = uncolour[bgcolour];


    /* draw a rectangle around - but inside - the gadget's bounding box */
    wimp_convert_rect (WorkToScreen, window->window, work, &bbox);
    bbox.maxx -= scalex;
    bbox.maxy -= scaley;

    swi (Wimp_SetColour,  R0, colour,  END);
    swi (OS_Plot, R0,  4, R1, bbox.minx, R2, bbox.miny,  END);
    swi (OS_Plot, R0,  5, R1, bbox.maxx, R2, bbox.miny,  END);
    swi (OS_Plot, R0,  5, R1, bbox.maxx, R2, bbox.maxy,  END);
    swi (OS_Plot, R0,  5, R1, bbox.minx, R2, bbox.maxy,  END);
    swi (OS_Plot, R0,  5, R1, bbox.minx, R2, bbox.miny,  END);

    /* plot ears if required */
    if (withears)
    {
        /* set icon flags for ears */
        ear.flags = IF_BORDER |
                    (6 << IF_TYPE_SHFT) |      /* button type = click/drag */
                    (colour << IF_FG_SHFT);

        /* determine coordinates of resize ears */
        find_resize_ears (work, x, y);

        /* and plot them */
        for (yy = 0; yy < 3; yy++)
            for (xx = 0; xx < 3; xx++)
                if (!(xx == 1 && yy == 1))
                {
                    ear.bbox.minx = x[xx];
                    ear.bbox.maxx = x[xx] + EAR_SIZE;
                    ear.bbox.miny = y[yy];
                    ear.bbox.maxy = y[yy] + EAR_SIZE;
                    ER ( swi (Wimp_PlotIcon, R1, &ear, END) );
                }
    }

    return NULL;
}


/*
 * The bounding box 'dst' is set equal to the bounding box 'src' plus an
 *  allowance for any resize ears
 */

void windowedit_add_ears_to_bbox (RectPtr src, RectPtr dst)
{
    dst->minx = src->minx+scalex - EAR_SIZE;
    dst->miny = src->miny+scaley - EAR_SIZE;
    dst->maxx = src->maxx-scalex + EAR_SIZE;
    dst->maxy = src->maxy-scaley + EAR_SIZE;
}


/*
 * Redraw loop for the editing window.
 * Must be called as a result of a redraw event.
 */

error * windowedit_redraw_window (
    WindowRedrawPtr redraw,
    WindowObjPtr window
)
{
    int more;
    int havefocus = focus_current() == window->window->handle;
    error *err;       /* errors are reported after completing redraw ... */
    error *firsterr = NULL;                /* ... but only the first one */

    /*
     * Issue Service Call &44ec6 with R0 = handle of window about to be
     *  drawn. This is intercepted by the window module so that PlotGadget
     *  code can find out about the window to which they're writing if they
     *  need to.
     */
    ER ( swi(OS_ServiceCall,  R0, redraw->handle, R1, SERVICE_REDRAW, END) );

    ER ( swi(Wimp_RedrawWindow,  R1, redraw,  OUT,  R0, &more,  END) );
    while (more)
    {
        RectRec work;
        GadgetPtr gadget = window->gadgets;

        /* Determine work-area relative bbox of invalid area */
        wimp_convert_rect (ScreenToWork, (WindowPtr) redraw,
                           &redraw->graphwin, &work);

        /* Now plot any gadgets that are in the area */

        /* plot those at the back first */
        while (gadget)
        {
            /* use Toolbox Window module to plot the gadget itself if
               necessary */
            if ((gadget->hdr.flags & GADGET_ATBACK) != 0 &&
                     wimp_rects_intersect (&work, &gadget->hdr.bbox))
            {
                err = swi (Window_PlotGadget, R0, 0,
                                              R1, (int)&gadget->hdr, END);
                if (firsterr == NULL)
                    firsterr = err;
            }
            gadget = gadget->next;
        }

        /* and now plot the rest on top of them */
        gadget = window->gadgets;
        while (gadget)
        {
            /* use Toolbox Window module to plot the gadget itself if
               necessary */
            if ((gadget->hdr.flags & GADGET_ATBACK) == 0 &&
                     wimp_rects_intersect (&work, &gadget->hdr.bbox))
            {
                err = swi (Window_PlotGadget, R0, 0,
                                              R1, (int)&gadget->hdr, END);
                if (firsterr == NULL)
                    firsterr = err;
            }
            gadget = gadget->next;
        }

        /* highlight any selected gadgets */
        gadget = window->gadgets;
        while (gadget)
        {
            if (gadget->selected)
            {
                RectRec bbox;

                if (havefocus)
                    windowedit_add_ears_to_bbox (&gadget->hdr.bbox, &bbox);
                else
                    bbox = gadget->hdr.bbox;
                if (wimp_rects_intersect (&work, &bbox))
                {
                    err = plot_highlight (window,
                                         &gadget->hdr.bbox, havefocus);
                    if (firsterr == NULL)
                        firsterr = err;

                    /* plot special internal resize ear for numberrange */
                    if (havefocus && gadget->hdr.type == GADGET_NUMBER_RANGE)
                    {
                        err = plot_numberrange_special_ear (gadget);
                        if (firsterr == NULL)
                            firsterr = err;
                    }
                }
            }

            gadget = gadget->next;
        }

        /* display the grid if enabled */
        if (window->grid.show)
            grid_show (window, &work);

        ER ( swi (Wimp_GetRectangle,  R1,  redraw,  OUT,  R0, &more,  END) );
    }

#if DEBUGREDRAW
    return firsterr;
#else
    return NULL;
#endif
}


/*
 * Select or deselect a gadget.  Redraw window.
 */

static error * select_gadget (WindowObjPtr window, GadgetPtr gadget,
    Bool newstate)
{
    RectRec bbox;
    if (gadget->selected == newstate)
        return NULL;
    window->numselected += newstate ? 1 : -1;
    gadget->selected = newstate;

    windowedit_add_ears_to_bbox (&gadget->hdr.bbox, &bbox);
    return wimp_invalidate (window->window, &bbox);
}


/*
 * Select all or clear the current selection, depending on the value of
 *  'newstate'.
 * Redraw the window.
 */

static error * set_or_clear_selection (WindowObjPtr window, Bool newstate)
{
    GadgetPtr gadget = window->gadgets;
    RectRec bbox;
    if (newstate == TRUE && window->numselected == window->numgadgets ||
        newstate == FALSE && window->numselected == 0)
        return NULL;

    window->numselected = newstate ? window->numgadgets : 0;

    bbox.minx = bbox.miny = BIG;
    bbox.maxx = bbox.maxy = -BIG;
    while (gadget != NULL)
    {
        if (gadget->selected != newstate)
        {
            gadget->selected = newstate;
            wimp_merge_bboxes (&bbox, &bbox, &gadget->hdr.bbox);
        }
        gadget = gadget->next;
    }

    windowedit_add_ears_to_bbox (&bbox, &bbox);
    return wimp_invalidate (window->window, &bbox);
}


/*
 * Delete selected gadgets
 */

static error * delete_selection (WindowObjPtr window)
{
    GadgetPtr gadget = window->gadgets;
    GadgetPtr *prev = &window->gadgets;
    RectRec bbox;

    /* invalidate selection - including resize ears */
    windowedit_get_selection_bbox (window, &bbox);
    windowedit_add_ears_to_bbox (&bbox, &bbox);
    wimp_invalidate (window->window, &bbox);

    while (gadget != NULL)
    {
        GadgetPtr next = gadget->next;

        if (gadget->selected)
        {
            gadget_free (gadget);
            window->numgadgets--;
            *prev = next;
        }
        else
            prev = &gadget->next;

        gadget = next;
    }

    /* none selected now */
    window->numselected = 0;

    ER ( protocol_send_resed_object_modified (window) );

    return NULL;
}


/*
 * Called in response to Edit=>Select=>Next/Previous Writable; 'next' is TRUE
 *  iff the entry selected was "Next writable".
 *
 * It is known that just one writable (or stringset or numberrange) is
 *  selected at the time of call.
 */

static error * select_linked_writable (WindowObjPtr window, Bool next)
{
    GadgetPtr gadget = window->gadgets;
    GadgetPtr linkgadget = window->gadgets;
    ComponentID id = -1;

    /* the selected gadget should remain on view if an error occurs */
    window->weakselection = FALSE;

    /* find the selected gadget */
    while (!gadget->selected)
        gadget = gadget->next;

    /* pick up linked gadget field value */
    switch (gadget->hdr.type)
    {
    case GADGET_WRITABLE_FIELD:
        if (next)
            id = gadget->body.writablefield.after;
        else
            id = gadget->body.writablefield.before;
        break;
    case GADGET_STRING_SET:
        if (next)
            id = gadget->body.stringset.after;
        else
            id = gadget->body.stringset.before;
        break;
    case GADGET_NUMBER_RANGE:
        if (next)
            id = gadget->body.numberrange.after;
        else
            id = gadget->body.numberrange.before;
        break;
    }

    /* return error message if no linked gadget */
    if (id == -1)
        return error_lookup ("NoLinkGadg", next ? "after" : "before");

    /* locate linked gadget, if possible */
    while (linkgadget != NULL && linkgadget->hdr.componentID != id)
        linkgadget = linkgadget->next;

    /* display error message if specified gadget does not exist */
    if (linkgadget == NULL)
        return error_lookup ("BadLinkGadg", next ? "after" : "before");

    /* deselect gadget and select linkgadget */
    select_gadget (window, gadget, FALSE);
    select_gadget (window, linkgadget, TRUE);

    return NULL;
}


/*
 * If the window has a gadget nominated as the "default input focus" gadget,
 *  then the current selection is replaced by that gadget.
 *
 * Otherwise a suitable error message is displayed, and the current selection
 *  is left unaltered.
 *
 * Called from windowmenu_cb(..) when the user chooses "Default writable".
 */

static error * select_default_focus (WindowObjPtr window)
{
    ComponentID dfltid = window->p.defaultfocus;
    GadgetPtr gadget = window->gadgets;

    if (dfltid == DEFAULTFOCUS_NONE)
        return (error_lookup ("NoDfltFcs") );

    if (dfltid == DEFAULTFOCUS_INVISIBLE)
        return (error_lookup ("InvisDfltFcs") );

    /* locate default gadget, if possible */
    while (gadget != NULL && gadget->hdr.componentID != dfltid)
        gadget = gadget->next;

    if (gadget == NULL)
        return (error_lookup ("BadDfltFcs") );

    /* clear current selection */
    window->weakselection = FALSE;
    set_or_clear_selection (window, FALSE);

    /* select default focus gadget */
    select_gadget (window, gadget, TRUE);

    return NULL;
}


/*
 * If the window has a "default" or "cancel" action button, then the current
 *  selection is replaced by that gadget.
 *
 * Otherwise a suitable error message is displayed, and the current selection
 *  remains unchanged.
 *
 * Called from windowmenu_cb(..) when the user chooses "Default/Cancel
 *  action": 'dflt' is TRUE iff the "Default action" entry is chosen.
 */

static error * select_special_action (WindowObjPtr window, Bool dflt)
{
    GadgetPtr gadget = window->gadgets;
    unsigned mask = dflt ? ACTIONBUTTON_ISDEFAULT : ACTIONBUTTON_ISCANCEL;

    /* search for special action button */
    while (gadget != NULL)
    {
        if (gadget->hdr.type == GADGET_ACTION_BUTTON &&
            (gadget->hdr.flags & mask) != 0)
        {
            /* clear current selection */
            window->weakselection = FALSE;
            set_or_clear_selection (window, FALSE);

            /* select special action button */
            select_gadget (window, gadget, TRUE);

            return NULL;
        }

        gadget = gadget->next;
    }

    /* special button not found */
    return error_lookup ("NoSpcAb", dflt ? "default" : "cancel");
}


/*
 * Called to show Coords dbox as Edit => Coordinates => is traversed
 */

static error * show_coords (MenuPtr menu, MessageMenuWarningPtr warn, void *closure)
{
    MenuClosPtr clos = (MenuClosPtr) closure;

    return coords_open (clos->window, &warn->position);
}


/*
 * Called to show WindInfo dbox as Info => is traversed
 */

static error * show_windinfo (MenuPtr menu, MessageMenuWarningPtr warn, void *closure)
{
    MenuClosPtr clos = (MenuClosPtr) closure;

    return windinfo_open (clos->window, &warn->position);
}


/*
 * Called to show Grid dbox as Grid => is traversed
 */

static error * show_grid (MenuPtr menu, MessageMenuWarningPtr warn, void *closure)
{
    MenuClosPtr clos = (MenuClosPtr) closure;

    return grid_open (clos->window, &warn->position);
}


/*
 * Menu handling.  Replace this with something more compact one day!
 */

static error * create_menu (void)
{
    ER ( menu_create (6, message_lookup (&msgs, "SM_Name"), &selectmenu) );
    ER ( menu_entry (selectmenu, SELECTMENU_RADIOGROUP,
                                 message_lookup (&msgs, "SM_Rgrp"),
                                 0, MF_DOTTED, -1, -1, NULL) );
    ER ( menu_entry (selectmenu, SELECTMENU_NEXTWRITABLE,
                                 message_lookup (&msgs, "SM_Nxtw"),
                                 0, 0, -1, -1, NULL) );
    ER ( menu_entry (selectmenu, SELECTMENU_PREVIOUSWRITABLE,
                                 message_lookup (&msgs, "SM_Prvw"),
                                 0, 0, -1, -1, NULL) );
    ER ( menu_entry (selectmenu, SELECTMENU_DEFAULTWRITABLE,
                                 message_lookup (&msgs, "SM_Dflw"),
                                 0, MF_DOTTED, -1, -1, NULL) );
    ER ( menu_entry (selectmenu, SELECTMENU_DEFAULTACTION,
                                 message_lookup (&msgs, "SM_Dfla"),
                                 0, 0, -1, -1, NULL) );
    ER ( menu_entry (selectmenu, SELECTMENU_CANCELACTION,
                                 message_lookup (&msgs, "SM_Cana"),
                                 0, 0, -1, -1, NULL) );

    ER ( menu_create (6, message_lookup (&msgs, "AM_Name"), &alignmenu) );
    ER ( menu_entry (alignmenu, ALIGNMENU_TOP,
                                message_lookup (&msgs, "AM_HTop"),
                                0, 0, -1, -1, NULL) );
    ER ( menu_entry (alignmenu, ALIGNMENU_HCENTRE,
                                message_lookup (&msgs, "AM_HCen"),
                                0, 0, -1, -1, NULL) );
    ER ( menu_entry (alignmenu, ALIGNMENU_BOTTOM,
                                message_lookup (&msgs, "AM_HBot"),
                                0, MF_DOTTED, -1, -1, NULL) );
    ER ( menu_entry (alignmenu, ALIGNMENU_LEFT,
                                message_lookup (&msgs, "AM_VLft"),
                                0, 0, -1, -1, NULL) );
    ER ( menu_entry (alignmenu, ALIGNMENU_VCENTRE,
                                message_lookup (&msgs, "AM_VCen"),
                                0, 0, -1, -1, NULL) );
    ER ( menu_entry (alignmenu, ALIGNMENU_RIGHT,
                                message_lookup (&msgs, "AM_VRgt"),
                                0, 0, -1, -1, NULL) );

    ER ( menu_create (10, message_lookup (&msgs, "EM_Name"), &editmenu) );
    ER ( menu_entry (editmenu, EDITMENU_DELETE,
                               message_lookup (&msgs, "EM_Delt"),
                               0, 0, -1, -1, NULL) );
    ER ( menu_entry (editmenu, EDITMENU_PROPS,
                               message_lookup (&msgs, "EM_Prop"),
                               0, 0, -1, -1, NULL) );
    ER ( menu_entry (editmenu, EDITMENU_SNAP,
                               message_lookup (&msgs, "EM_Snap"),
                               0, 0, -1, -1, NULL) );
    ER ( menu_entry (editmenu, EDITMENU_RADIOGROUP,
                               message_lookup (&msgs, "EM_Mkrg"),
                               0, 0, -1, -1, NULL) );
    ER ( menu_entry (editmenu, EDITMENU_LINKWRITE,
                               message_lookup (&msgs, "EM_Lkwr"),
                               0, 0, -1, -1, NULL) );
    ER ( menu_entry (editmenu, EDITMENU_COORDS,
                               message_lookup (&msgs, "EM_Coor"),
                               0, MF_MESSAGE, -1, -1,
                               (void *) (int) show_coords) );
    ER ( menu_entry (editmenu, EDITMENU_ALIGN,
                               message_lookup (&msgs, "EM_Algn"),
                               0, MF_DOTTED, -1, -1,
                               (void *) alignmenu) );
    ER ( menu_entry (editmenu, EDITMENU_SELALL,
                               message_lookup (&msgs, "EM_SAll"),
                               0, 0, -1, -1, NULL) );
    ER ( menu_entry (editmenu, EDITMENU_SELECT,
                               message_lookup (&msgs, "EM_Slct"),
                               0, 0, -1, -1,
                               (void *) selectmenu) );
    ER ( menu_entry (editmenu, EDITMENU_CLEAR,
                               message_lookup (&msgs, "EM_CSel"),
                               0, 0, -1, -1, NULL) );

    ER ( menu_create (11, message_lookup (&msgs, "WM_Name"), &windowmenu) );
    ER ( menu_entry (windowmenu, WINDOWMENU_INFO,
                                 message_lookup (&msgs, "WM_Info"),
                                 0, MF_MESSAGE, -1, -1,
                                 (void *) (int) show_windinfo) );
    ER ( menu_entry (windowmenu, WINDOWMENU_EDIT,
                                 message_lookup (&msgs, "WM_Edit"),
                                 0, 0, -1, -1, (void *) editmenu) );
    ER ( menu_entry (windowmenu, WINDOWMENU_MPROPS,
                                 message_lookup (&msgs, "WM_Mprp"),
                                 0, 0, -1, -1, NULL) );
    ER ( menu_entry (windowmenu, WINDOWMENU_OPROPS,
                                 message_lookup (&msgs, "WM_Oprp"),
                                 0, 0, -1, -1, NULL) );
    ER ( menu_entry (windowmenu, WINDOWMENU_COLOURS,
                                 message_lookup (&msgs, "WM_Clrs"),
                                 0, 0, -1, -1, NULL) );
    ER ( menu_entry (windowmenu, WINDOWMENU_EXTENT,
                                 message_lookup (&msgs, "WM_Extn"),
                                 0, 0, -1, -1, NULL) );
    ER ( menu_entry (windowmenu, WINDOWMENU_KEYS,
                                 message_lookup (&msgs, "WM_Keys"),
                                 0, 0, -1, -1, NULL) );
    ER ( menu_entry (windowmenu, WINDOWMENU_TOOLBARS,
                                 message_lookup (&msgs, "WM_Tbar"),
                                 0, 0, -1, -1, NULL) );
    ER ( menu_entry (windowmenu, WINDOWMENU_GRID,
                                 message_lookup (&msgs, "WM_Grid"),
                                 0, MF_MESSAGE | MF_DOTTED, -1, -1,
                                 (void *) (int) show_grid) );
    ER ( menu_entry (windowmenu, WINDOWMENU_PALETTE,
                                 message_lookup (&msgs, "WM_Palt"),
                                 0, MF_DOTTED, -1, -1, NULL) );
    ER ( menu_entry (windowmenu, WINDOWMENU_CLOSE,
                                 message_lookup (&msgs, "WM_Clse"),
                                 0, 0, -1, -1, NULL) );
    ER ( menu_register (windowmenu, MAIN_MENU) );

    key_mainprops = atoi (message_lookup (&msgs, "KWM_Mprp"));
    key_extent = atoi (message_lookup (&msgs, "KWM_Extn"));
    key_keys = atoi (message_lookup (&msgs, "KWM_Keys"));
    key_toolbars = atoi (message_lookup (&msgs, "KWM_Tool"));
    key_grid = atoi (message_lookup (&msgs, "KWM_Grid"));
    key_gadgets = atoi (message_lookup (&msgs, "KWM_Gadg"));
    key_close = atoi (message_lookup (&msgs, "KWM_Clse"));

    key_delete = atoi (message_lookup (&msgs, "KEM_Delt"));
    key_gadgetprops = atoi (message_lookup (&msgs, "KEM_Prop"));
    key_snap = atoi (message_lookup (&msgs, "KEM_Snap"));
    key_radiogroup = atoi (message_lookup (&msgs, "KEM_Mkrg"));
    key_linkwritables = atoi (message_lookup (&msgs, "KEM_Lkwr"));
    key_coordinates = atoi (message_lookup (&msgs, "KEM_Cord"));
    key_selectall = atoi (message_lookup (&msgs, "KEM_SAll"));
    key_clearsel = atoi (message_lookup (&msgs, "KEM_CSel"));

    key_selectradiogroup = atoi (message_lookup (&msgs, "KSM_Serg"));

    return NULL;
}


/*
 * Do any shading etc necessary before posting the menu.
 *
 * 'menugadget' identifies the gadget - if any - over which the mouse pointer
 *  was when the menu button was depressed. If appropriate, this gadget
 *  will already have been 'weakly' selected.
 */

static void prepare_menu (WindowObjPtr window, GadgetPtr menugadget)
{
    menu_shade (windowmenu, WINDOWMENU_TOOLBARS,
                            (window->p.flags & WINDOW_ISTOOLBAR) != 0);

    if (window->numselected != 0)
    {
        /* We have a selection */
        menu_shade_menu (editmenu, FALSE);
        menu_shade (editmenu, EDITMENU_PROPS, window->numselected > 1);
        menu_shade (editmenu, EDITMENU_SELALL,
                              !window->weakselection &&
                                  window->numselected == window->numgadgets);

        /*
         * "Make radio group" is greyed out unless all selected gadgets
         *   are radio buttons.
         * "Select radio group" is greyed out unless exactly one radio
         *  button is selected.
         */

        {
            GadgetPtr gadget = window->gadgets;
            Bool shademake = FALSE;
            Bool shadesel = (window->numselected != 1);
            Bool shadelinkwr = TRUE;

            while (gadget != NULL)
            {
                if (gadget->selected)
                {
                    int type = gadget->hdr.type;

                    if (type != GADGET_RADIO_BUTTON)
                    {
                        shademake = TRUE;
                        shadesel = TRUE;
                        if ( type == GADGET_WRITABLE_FIELD ||
                             type == GADGET_STRING_SET ||
                             type == GADGET_NUMBER_RANGE )
                        {
                            shadelinkwr = FALSE;
                            break;
                        }
                    }
                }

                gadget = gadget->next;
            }

            menu_shade (editmenu, EDITMENU_RADIOGROUP, shademake);
            menu_shade (selectmenu, SELECTMENU_RADIOGROUP, shadesel);
            menu_shade (editmenu, EDITMENU_LINKWRITE, shadelinkwr);
            menu_shade (selectmenu, SELECTMENU_NEXTWRITABLE,
                                    window->numselected > 1 || shadelinkwr);
            menu_shade (selectmenu, SELECTMENU_PREVIOUSWRITABLE,
                                    window->numselected > 1 || shadelinkwr);
        }

        /*
         * "Align" entry should be available only if the menu button was
         *  clicked over a gadget, and at least one other gadget is selected.
         */

        {
            Bool alignok = menugadget != NULL &&
                        (window->numselected > 1 || !menugadget->selected);

            menu_shade (editmenu, EDITMENU_ALIGN, !alignok);
        }
    }
    else
    {
        /* No selection in this doc */
        menu_shade_menu (editmenu, TRUE);
        menu_shade (editmenu, EDITMENU_SELALL, FALSE);
        menu_shade (editmenu, EDITMENU_SELECT, FALSE);
        menu_shade (selectmenu, SELECTMENU_RADIOGROUP, TRUE);
        menu_shade (selectmenu, SELECTMENU_NEXTWRITABLE, TRUE);
        menu_shade (selectmenu, SELECTMENU_PREVIOUSWRITABLE, TRUE);
    }
}


/*
 * Callback for the windowedit window's menu.
 *
 * Called with buf = NULL and adjust = FALSE when the menu tree is deleted.
 *
 * Called with buf indicating the chosen item and adjust TRUE if it was
 *  chosen with ADJUST when a menu entry is chosen by the user.
 */

static error * windowmenu_cb (MenuPtr wimpmenu, int *buf, void *closure, Bool adjust)
{
    MenuClosPtr clos = (MenuClosPtr) closure;
    WindowObjPtr window = clos->window;
    GadgetPtr gadget = clos->gadget;

    if (buf)
    {
        switch (buf[0])
        {
        case WINDOWMENU_EDIT:
            switch (buf[1])
            {
            case EDITMENU_DELETE:
                ER ( delete_selection (window) );
                break;
            case EDITMENU_PROPS:
                {
                    GadgetPtr gadget = window->gadgets;

                    /* must be just one gadget selected - find it */
                    while (gadget != NULL)
                    {
                        if (gadget->selected)
                            ER ( gadget_open_dbox (gadget) );
                        gadget = gadget->next;
                    }
                }
                break;
            case EDITMENU_SNAP:
                grid_snap (window);
                break;
            case EDITMENU_RADIOGROUP:
                window->weakselection = FALSE; /* selection should persist */
                ER ( gadget_rb_make_radio_group (window) );
                break;
            case EDITMENU_LINKWRITE:
                ER ( gadget_link_writables (window) );
                break;
            case EDITMENU_ALIGN:
                if (buf[2] >= 0)
                    ER ( align_selection_to (gadget, buf[2]) );
                break;
            case EDITMENU_SELALL:
                window->weakselection = FALSE; /* selection must persist! */
                ER ( set_or_clear_selection (window, TRUE) );
                break;
            case EDITMENU_SELECT:
                switch (buf[2])
                {
                case SELECTMENU_RADIOGROUP:
                    /* selection must persist */
                    window->weakselection = FALSE;
                    ER ( gadget_rb_select_radio_group (window) );
                    break;
                case SELECTMENU_NEXTWRITABLE:
                    ER ( select_linked_writable (window, TRUE) );
                    break;
                case SELECTMENU_PREVIOUSWRITABLE:
                    ER ( select_linked_writable (window, FALSE) );
                    break;
                case SELECTMENU_DEFAULTWRITABLE:
                    ER ( select_default_focus (window) );
                    break;
                case SELECTMENU_DEFAULTACTION:
                    ER ( select_special_action (window, TRUE) );
                    break;
                case SELECTMENU_CANCELACTION:
                    ER ( select_special_action (window, FALSE) );
                    break;
                }
                break;
            case EDITMENU_CLEAR:
                ER ( set_or_clear_selection (window, FALSE) );
                break;
            }
            break;
        case WINDOWMENU_MPROPS:
            ER ( props_open_main_dbox (window) );
            break;
        case WINDOWMENU_OPROPS:
            ER ( props_open_other_dbox (window) );
            break;
        case WINDOWMENU_COLOURS:
            ER ( colours_open_dbox (window) );
            break;
        case WINDOWMENU_EXTENT:
            ER ( extent_open_dbox (window) );
            break;
        case WINDOWMENU_KEYS:
            ER ( keycuts_open_dbox (window) );
            break;
        case WINDOWMENU_TOOLBARS:
            ER ( toolbars_open_dbox (window) );
            break;
        case WINDOWMENU_PALETTE:
            ER ( windowedit_open_palette () );
            break;
        case WINDOWMENU_CLOSE:
            ER ( windowedit_close_wind (window) );
            break;
        }

        /* if the item was chosen by clicking ADJUST, must prepare the menu
           ready to show again */
        if (adjust)
            prepare_menu (window, gadget);
    }
    else
        /* clear any weak selection when the menu tree is deleted because
           the user clicks elsewhere, or some other application creates a
           menu, or whatever */
        if (window->weakselection)
            ER ( set_or_clear_selection (window, FALSE) );

    return NULL;
}


/*
 * Post the windowedit window's menu.  The window should already have
 * the focus.
 */

static error * post_windowmenu (PointPtr workposition, PointPtr screenposition, WindowObjPtr window, GadgetPtr gadget)
{
    if (window->numselected != 0)
    {
        /* We have a selection */
        window->weakselection = FALSE;
        prepare_menu (window, gadget);
    }
    else if (gadget)
    {
        select_gadget (window, gadget, TRUE);
        window->weakselection = TRUE;
        prepare_menu (window, gadget);
    }
    else
    {
        window->weakselection = FALSE;
        prepare_menu (window, gadget);
    }

    menuclosure.window = window;
    menuclosure.gadget = gadget;

    return menu_post (windowmenu, screenposition, FALSE, windowmenu_cb,
                      (void *) &menuclosure);
}


/*
 * Return the gadget which intersects the specified work-area
 *  mouse click position, or NULL if none.
 *
 * If the window currently has the input focus, a check is also made to see
 *  if the click was on a resize ear of a selected gadget; if so, the ear is
 *  indicated as follows:
 *
 *           6      7      8
 *             -----------
 *            |           |
 *          3 |     4     | 5
 *            |           |
 *             -----------
 *           0      1      2
 *
 * (Note that 4 is possible only for numberrange gadgets.)
 */

static GadgetPtr click_in_gadget (
    WindowObjPtr window, /* window */
    PointPtr click,      /* mouse position */
    Bool *inear,         /* set TRUE iff click was in gadget's resize ear */
    int *which           /* identifies which resize ear (if inear = TRUE) */
)
{
    GadgetPtr gadget = window->gadgets;
    Bool hasfocus = (focus_current () == window->window->handle);

    /* if the window has input focus, look for a resize ear click first */
    if (hasfocus)
    {
        int posx = click->x;
        int posy = click->y;
        int x[3], y[3], xx, yy;

        while (gadget != NULL)
        {
            if (gadget->selected)
            {
                find_resize_ears (&gadget->hdr.bbox, x, y);

                for (yy = 0; yy < 3; yy++)
                    if (posy >= y[yy] && posy < y[yy] + EAR_SIZE)
                        break;

                if (yy != 3)
                {
                    for (xx = 0; xx < 3; xx++)
                        if (posx >= x[xx] && posx < x[xx] + EAR_SIZE)
                            break;
                    if (xx != 3 && !(yy == 1 && xx == 1))
                    {
                        *inear = TRUE;
                        *which = 3 * yy + xx;
                        return gadget;
                    }
                }

                /* finally, check for "display" resize ear in numberrange */
                if (gadget->hdr.type == GADGET_NUMBER_RANGE &&
                   (gadget->hdr.flags & NUMBERRANGE_NONUMERICALDISPLAY) ==
                                                          0 &&
                   (gadget->hdr.flags & NUMBERRANGE_SLIDERTYPE) !=
                                                       NUMBERRANGE_NOSLIDER)
                {
                    if ((gadget->hdr.flags & NUMBERRANGE_SLIDERTYPE) ==
                                                      NUMBERRANGE_SLIDERLEFT)
                        xx = gadget->hdr.bbox.maxx -
                                (gadget->body.numberrange.displaylength +
                                 EAR_SIZE/2);
                    else
                        xx = gadget->hdr.bbox.minx +
                                (gadget->body.numberrange.displaylength -
                                 EAR_SIZE/2);

                    if (posx >= xx && posx < xx + EAR_SIZE)
                    {
                        yy = gadget->hdr.bbox.miny +
                            (gadget->hdr.bbox.maxy - gadget->hdr.bbox.miny -
                                 EAR_SIZE)/2;
                        if (posy >= yy && posy < yy + EAR_SIZE)
                        {
                            *inear = TRUE;
                            *which = 4;
                            return gadget;
                        }
                    }
                }
            }

            gadget = gadget->next;
        }
    }

    /* otherwise see if it's a click inside a gadget */
    *inear = FALSE;

    /* examine gadgets on top first of all */
    gadget = window->gadgets;
    while (gadget != NULL)
    {
        if ((gadget->hdr.flags & GADGET_ATBACK) == 0 &&
                 wimp_point_inside (&gadget->hdr.bbox, click))
            return gadget;

        gadget = gadget->next;
    }

    /* and then check the others */
    gadget = window->gadgets;
    while (gadget != NULL)
    {
        if ((gadget->hdr.flags & GADGET_ATBACK) != 0 &&
                 wimp_point_inside (&gadget->hdr.bbox, click))
            return gadget;

        gadget = gadget->next;
    }

    return NULL;
}


/*
 * Detect clicks on the editing window and dispatch as appropriate.
 */

error * windowedit_mouse_click (MouseClickPtr mouse, unsigned int modifiers, WindowObjPtr window)
{
    PointRec position;
    static GadgetPtr gadget = NULL;  /* used to retain information between */
    static Bool resizing;            /* click and drag, for example        */
    static int ear;
    static Bool pendingctrlshftdrag;

    /* CTRL/SHFT modification treated specially */
    if (pendingctrlshftdrag || modifiers == (MODIFIER_SHIFT | MODIFIER_CTRL))
    {
        switch (mouse->buttons)
        {
        case MB_SINGLECLICK(MB_SELECT):
        case MB_SINGLECLICK(MB_ADJUST):
            pendingctrlshftdrag = TRUE;
            return NULL;

        case MB_DRAG(MB_SELECT):
            if (pendingctrlshftdrag)
            {
                pendingctrlshftdrag = FALSE;
                winddrag_move_start (window, &mouse->position);
            }
            return NULL;

        case MB_DRAG(MB_ADJUST):
            if (pendingctrlshftdrag)
            {
                pendingctrlshftdrag = FALSE;
                winddrag_resize_start (window, &mouse->position);
            }
            return NULL;

        default:
            pendingctrlshftdrag = FALSE;
        }
    }

    /* for these cases there must have been a previous MB_SINGLECLICK */
    switch (mouse->buttons)
    {
    case MB_DOUBLE(MB_SELECT):
        if (window->internal)      /* ignore if palette window */
            return NULL;
        /* double-click on editing window background opens properties dbox */
        if (gadget == NULL)
            return props_open_main_dbox (window);
        /* double-click on gadget opens appropriate gadget dialogue */
        return gadget_open_dbox (gadget);

    case MB_DRAG(MB_SELECT):
    case MB_DRAG(MB_ADJUST):
        if (resizing)
        {
            if (window->internal)  /* ignore if palette window */
                return NULL;
            if (mouse->buttons == MB_DRAG(MB_SELECT))
                resize_start (window, gadget, ear, &mouse->position);
            else
                if (ear != 4)
                    move_start (window, ear, &mouse->position);
            return NULL;
        }

        if (gadget == NULL)             /* background */
            return lassoo_start (window, mouse, modifiers);
        else if (gadget->selected &&    /* gadget */
                 mouse->buttons == MB_DRAG(MB_SELECT))
            return drag_start (window, gadget, mouse, modifiers);
        return NULL;
    }

    /* determine which gadget the mouse is over, and whether it is a resize
        request or not */
    wimp_convert_point (ScreenToWork,
                        window->window, &mouse->position, &position);
    gadget = click_in_gadget (window, &position, &resizing, &ear);

    /* All clicks gain caret and focus */
    ER ( windowedit_focus_claim (window) );

    switch (mouse->buttons)
    {
    case MB_SINGLECLICK(MB_SELECT):
        if (!resizing)
        {
            if (gadget == NULL)
                return set_or_clear_selection (window, FALSE);
            else if (!gadget->selected)
            {
                ER ( set_or_clear_selection (window, FALSE) );
                return select_gadget (window, gadget, TRUE);
            }
        }
        break;

    case MB_SINGLECLICK(MB_ADJUST):
        if (!resizing && gadget)
            return select_gadget (window, gadget, !gadget->selected);
        break;

    case MB_MENU:
        if (window->internal)
            return NULL;
        return post_windowmenu (&position, &mouse->position, window, gadget);
        break;
    }

    return NULL;
}



#if KEYNUDGE
static error * windowedit_nudge_selection
(
    WindowObjPtr window,
    int key,       /* cursor key-code */
    Bool resize    /* TRUE if selection is to be resized rather than moved */
)
{
    int dx = 0;
    int dy = 0;
    RectRec bbox;
    GadgetPtr gadget;

    /* each "nudge" moves 4 OS units */
    switch (key)
    {
    case 0x18c:   /* left cursor */
        dx = -4;
        break;
    case 0x18d:   /* right cursor */
        dx = 4;
        break;
    case 0x18e:   /* down cursor */
        dy = -4;
        break;
    case 0x18f:   /* up cursor */
        dy = 4;
        break;
    }

    /* invalidate current selection */
    windowedit_get_selection_bbox (window, &bbox);
    windowedit_add_ears_to_bbox (&bbox, &bbox);
    wimp_invalidate (window->window, &bbox);

    /* move or resize each selected gadget */
    gadget = window->gadgets;
    while (gadget != NULL)
    {
        if (gadget->selected)
        {
            gadget->hdr.bbox.maxx += dx;
            gadget->hdr.bbox.maxy += dy;
            if (!resize)
            {
                gadget->hdr.bbox.minx += dx;
                gadget->hdr.bbox.miny += dy;
            }
            else
            {
                int width = gadget->hdr.bbox.maxx - gadget->hdr.bbox.minx;
                int height = gadget->hdr.bbox.maxy - gadget->hdr.bbox.miny;

                if (width < gadget->def->minsize.x)
                    gadget->hdr.bbox.maxx -= dx;
                if (height < gadget->def->minsize.y)
                    gadget->hdr.bbox.maxy -= dy;
            }
        }
        gadget = gadget->next;
    }

    /* invalidate newly-positioned current selection */
    windowedit_get_selection_bbox (window, &bbox);
    windowedit_add_ears_to_bbox (&bbox, &bbox);
    wimp_invalidate (window->window, &bbox);

    /* note window modified */
    return protocol_send_resed_object_modified (window);
}
#endif



/*
 * Keyboard shortcuts
 */

error * windowedit_key_pressed (WindowObjPtr window, KeyPressPtr key,
                                Bool *consumed)
{
    unsigned modifiers = wimp_read_modifiers ();
    error *err = NULL;

    if (key->code == key_selectall)
        err = set_or_clear_selection (window, TRUE);

    else
    if (key->code == key_clearsel)
        err = set_or_clear_selection (window, FALSE);

    else     /* only the shortcuts above are allowed on the palette window */
    if (window->internal)
    {
        *consumed = FALSE;
        return NULL;
    }

    else
#if KEYNUDGE
    if (key->code >= 0x18c && key->code <= 0x18f)
    {
        if (window->numselected != 0)
            err = windowedit_nudge_selection (window, key->code, FALSE);
    }
    else
    if (key->code >= 0x19c && key->code <= 0x19f)
    {
        if (window->numselected != 0)
            err = windowedit_nudge_selection (window, key->code - 16, TRUE);
    }
#endif
    if (key->code == key_mainprops)
        err = props_open_main_dbox (window);

    else
    if (key->code == key_extent)
        err = extent_open_dbox (window);

    else
    if (key->code == key_keys)
        err = keycuts_open_dbox (window);

    else
    if (key->code == key_toolbars && (window->p.flags & WINDOW_ISTOOLBAR) == 0)
        err = toolbars_open_dbox (window);

    else
    if (key->code == key_grid && modifiers == MODIFIER_SHIFT)
    {
        *consumed = TRUE;
        interactor_cancel ();  /* remove any other menu first */
        return grid_open (window, NULL);
    }

    else
    if (key->code == key_gadgets)
        err = windowedit_open_palette ();

    else
    if (key->code == key_close)
        err = windowedit_close_wind (window);

    else
    if (key->code == key_delete)
    {
        if (window->numselected > 0)
            err = delete_selection (window);
    }

    else
    if (key->code == key_gadgetprops)
    {
        if (window->numselected == 1)
        {
            GadgetPtr gadget;
            for (gadget = window->gadgets; gadget; gadget = gadget->next)
                if (gadget->selected)
                {
                    err = gadget_open_dbox (gadget);
                    break;
                }
        }
    }

    else
    if (key->code == key_snap)
    {
        if (window->numselected > 0)
            err = grid_snap (window);
    }

    else
    if (key->code == key_radiogroup)
    {
        GadgetPtr gadget = window->gadgets;
        Bool ok = (window->numselected > 0);

        /* all selected gadgets must be radio buttons */
        if (ok)
            while (gadget != NULL)
            {
                if (gadget->selected)
                {
                    int type = gadget->hdr.type;

                    if (type != GADGET_RADIO_BUTTON)
                    {
                        ok = FALSE;
                        break;
                    }
                }
                gadget = gadget->next;
            }

        if (ok)
            err = gadget_rb_make_radio_group (window);
        else
            err = error_lookup ("Rbsonly");
    }

    else
    if (key->code == key_linkwritables)
        err = gadget_link_writables (window);

    else
    if (key->code == key_coordinates && modifiers == MODIFIER_SHIFT)
    {
        if (window->numselected > 0)
        {
            *consumed = TRUE;
            interactor_cancel ();  /* remove any other menu first */
            return coords_open (window, NULL);
        }
    }

    else
    if (key->code == key_selectradiogroup && modifiers == MODIFIER_SHIFT)
    {
        GadgetPtr gadget = window->gadgets;
        Bool ok = (window->numselected == 1);

        if (ok)
            while (gadget != NULL)
            {
                if (gadget->selected)
                {
                    ok = (gadget->hdr.type == GADGET_RADIO_BUTTON);
                    break;
                }
                gadget = gadget->next;
            }

        if (ok)
            err = gadget_rb_select_radio_group (window);
        else
            err = error_lookup ("Onerb");
    }

    else   /* don't recognise this key */
    {
        *consumed = FALSE;
        return NULL;
    }

    /* key was processed */
    *consumed = TRUE;

    /* cancel any foreground interaction in progress */
    interactor_cancel ();

    return err;
}


/*
 * Load a window from the the shell according to the RESED_OBJECT_LOAD
 * message 'load'.
 * If 'window' is NULL, then create a new editing window and load the
 * data into that.
 * If 'window' is non-NULL, then close it first; this option is used when the
 * Shell forces us to re-load a modified object after messages are imported.
 *
 * Creation of the palette window is treated specially:
 *    'load' = NULL - to indicate this special case
 *    'window' addresses an empty WindowObjRec, except that the 'internal'
 *             field is set TRUE.
 */

error * windowedit_load (WindowObjPtr window,
                         ResourceFileObjectTemplateHeaderPtr object,
                         MessageResEdObjectLoadPtr load)
{
    WindowTemplatePtr body = (WindowTemplatePtr) relocate_object (object);
    int i;
    error *err = NULL;
    Bool nodisplay;

    if (body == NULL)
        return error_lookup ("CorruptWindow");

    /*
     * If this request to load is a result of a force-load of a window which
     *  we do not already know about, then don't display it - it's a result
     *  of message import, and will be grabbed back and deleted forthwith.
     */

    nodisplay = window == NULL && (load->flags & BIT(0)) != 0;

    /*
     * Make sure a window structure is ready:
     *  - create a new one if this is a new window
     *  - delete old one and create new one if this is a reload
     *  - no need to do anything if this is the palette
     */

    if (window == NULL || window->internal == FALSE)
    {
        GridRec gridsettings;
        Bool reload = FALSE;

        /*
         * If the window already exists, we must close it first; note that
         * this means that any window or gadget property dialogue boxes open
         * at the time will disappear when new messages are imported into
         * the shell.
         *
         * We remember grid settings, to restore when the new window has been
         * created.
         */

        if (window)
        {
            reload = TRUE;
            gridsettings = window->grid;
            windowedit_close_window (window, FALSE); /* FALSE => don't notify
                                                        the shell */
        }

        /* Allocate and clear a new window object structure */
        window = (WindowObjPtr) calloc (1, sizeof (WindowObjRec));
        if (window == NULL)
            return error_lookup ("NoMem");
        window->window = (WindowPtr) calloc (1, offsetof (WindowRec, icons));
        if (window->window == NULL)
        {
            free (window);
            return error_lookup ("NoMem");
        }

        /* set grid values to default or previous settings */
        if (reload)
            window->grid = gridsettings;
        else
            grid_set_defaults (&window->grid);
    }

    /* copy fields from (relocated) template to window object */
    for (i=0; i < MAX_OBJECT_NAME; i++)
        window->name[i] = object->hdr.name[i];
    window->p.flags = body->flags;
    window->p.helpmessage = copystring ((char *) body->helpmessage);
    window->p.maxhelp = gui_load_len_field (window->p.helpmessage,
                                          &body->maxhelp);
    window->p.pointershape = copystring ((char *) body->pointershape);
    window->p.maxpointershape = gui_load_len_field (window->p.pointershape,
                                                  &body->maxpointershape);
    window->p.pointerxhot = body->pointerxhot;
    window->p.pointeryhot = body->pointeryhot;
    window->p.menu = copystring ((char *) body->menu);
    window->p.defaultfocus = body->defaultfocus;
    window->p.showevent = body->showevent;
    window->p.hideevent = body->hideevent;
    window->toolbaribl = copystring ((char *) body->toolbaribl);
    window->toolbaritl = copystring ((char *) body->toolbaritl);
    window->toolbarebl = copystring ((char *) body->toolbarebl);
    window->toolbaretl = copystring ((char *) body->toolbaretl);

    /* copy wimp window (sorry!) */
    *( (WindowWimpTemplatePtr)
          ( (char *) (window->window) + offsetof (WindowRec, visarea) )
     ) = body->window;

    /* force visarea, scrolloffset, workarea to be multiples of 4 */
    wimp_align_rect (&window->window->visarea);
    wimp_align_point (&window->window->scrolloffset);
    wimp_align_rect (&window->window->workarea);

    /* force window to be on top of stack */
    window->window->behind = -1;

    /* clean up windowflags copy, just in case */
    window->p.windowflags =
                    (window->window->flags & ~WF_FORCE0) | WF_FORCE1;

    /* clean up titleflags, just in case */
    window->window->titleflags =
                    (window->window->titleflags & ~TF_FORCE0) | TF_FORCE1;

    /* make copy of button type, and set standard type for editing window */
    window->p.buttontype = IF_GET_FIELD(TYPE, window->window->workareaflags);
    window->window->workareaflags = BUTTONTYPE_FOR_RESED << IF_TYPE_SHFT;

    /* make copy of work area background colour, and substitute 'white' for
        'transparent' in the editing window if necessary */
    window->p.workBG = window->window->colours.workBG;
    if (window->p.workBG == 0xff)                 /* transparent */
        window->window->colours.workBG = 0;     /* white       */

    /* take copy of sprite area, and force editing window to use Wimp area */
    window->p.spritearea = (void *) window->window->spritearea;
    window->window->spritearea = (void *) (+1);

    /* force title validation string to be -1 (ie none) */
    window->window->titledata[1] = -1;

    /* take copy of title text and buffer length */
    window->p.title = copystring ((char *) window->window->titledata[0]);
    window->p.maxtitle = gui_load_len_field (window->p.title,
                                           &window->window->titledata[2]);
    /* record window object's unique identity */
    if (window->internal == FALSE)
    {
        window->documentID = load->documentID;
        window->objectID = load->objectID;
    }

    /* create list of keyboard shortcuts */
    {
        KeyBoardShortcutTemplatePtr key =
            (KeyBoardShortcutTemplatePtr) body->keyboardshortcuts;
        KeyBoardShortcutPtr *keylist = &window->keyboardshortcuts;

        for (i = 0; i < body->numkeyboardshortcuts; i++)
        {
            KeyBoardShortcutPtr new =
             (KeyBoardShortcutPtr) calloc (1, sizeof (KeyBoardShortcutRec));

            if (new == NULL)
            {
                err = error_lookup ("NoMem");
                goto fail;
            }

            /* add to end of list */
            *keylist = new;
            keylist = &new->next;

            new->flags = key->flags;
            new->wimpkeycode = key->wimpkeycode;
            new->keyevent = key->keyevent;
            new->keyshow = copystring ((char *) key->keyshow);

            key++;
        }

        window->numkeyboardshortcuts = body->numkeyboardshortcuts;
    }

    /* create list of gadgets */
    {
        GadgetTemplatePtr gadget = (GadgetTemplatePtr) body->gadgets;
        GadgetPtr *gadgetlist = &window->gadgets;

        for (i = 0; i < body->numgadgets; i++)
        {
            GadgetPtr new = gadget_load (
                     gadget,
                     (char *) gadget - (char *) body,
                     (RelocationTablePtr)
                         ((char *) object + object->relocationtableoffset) );

            if (new == NULL)
            {
                err = error_lookup ("NoMem");
                goto fail;
            }

            /* add to end of list */
            *gadgetlist = new;
            gadgetlist = &new->next;

            new->owner = window;

            /* move on to next gadget template */
            gadget = (GadgetTemplatePtr)
                       ( (char *) (gadget) +
                         gadget->hdr.size );
        }

        window->numgadgets = body->numgadgets;
    }

    /* copy appropriate flag values etc. from window fields into the
       wimp window */
    window->window->flags = (window->p.windowflags & ~WF_FORCE0_FOR_RESED) |
                                                         WF_FORCE1_FOR_RESED;
    if (window->p.title != NULL)
    {
        window->window->titledata[0] = (int) window->p.title;
        window->window->titledata[2] = window->p.maxtitle;
    }
    else
    {
        window->window->titledata[0] = (int) "";
        window->window->titledata[2] = 1;
    }

    /* create a wimp window, register it, open it, claim focus */
    {
        RectRec pos = window->window->visarea;

        EG ( fail, swi (Wimp_CreateWindow,  R1, &window->window->visarea,
                               OUT,  R0, &window->window->handle,  END) );
        EG ( fail, registry_register_window (window->window->handle,
                                           WindowEdit, (void *) window) );

        if (!nodisplay)
        {
            EG ( fail, swi (Wimp_OpenWindow,  R1, window->window,  END) );

            if (window->internal == FALSE)
            {
                /* if Wimp has forced window to new position, we must note
                    that the window has been modified */
                if ( pos.minx != window->window->visarea.minx ||
                     pos.miny != window->window->visarea.miny ||
                     pos.maxx != window->window->visarea.maxx ||
                     pos.maxy != window->window->visarea.maxy )
                    protocol_send_resed_object_modified (window);

                EG ( fail, windowedit_focus_claim (window) );
            }
        }
    }

    return NULL;


fail:
    if (err)
    {
        /* We failed (probably out of memory). Try to clean up the mess we
         * have made and pass the error back to the caller.
         * Caller will pass an error indication back to the shell.
         * Note: we have been careful to ensure that the partial window
         * edifice that we now have is consistent and will be freed correctly
         * by the code in windowedit_close_window().
         */
        if (window)
            windowedit_close_window (window, FALSE);
    }

    return err;
}


/*
 * The shell has informed us that this window's name has changed.
 *
 * Record the new name, and update the titlebars of any dialogue boxes open.
 */

error * windowedit_rename_window (WindowObjPtr window, char *name)
{
    GadgetPtr gadget;

    /* record new name for window object */
    sprintf (window->name, "%.*s", sizeof (window->name) - 1, name);

    /* Update titles of any dboxes on display */
    if (window->mainpropsdbox)
        ER ( props_update_main_dbox (window, FALSE, TRUE) );
    if (window->otherpropsdbox)
        ER ( props_update_other_dbox (window, FALSE, TRUE) );
    if (window->coloursdbox)
        ER ( colours_update_dbox (window, FALSE, TRUE) );
    if (window->extentdbox)
        ER ( extent_update_dbox (window, FALSE, TRUE) );
    if (window->keycutsdbox)
        ER ( keycuts_update_dbox (window, FALSE, TRUE) );
    if (window->toolbarsdbox)
        ER ( toolbars_update_dbox (window, FALSE, TRUE) );

    /* update window name field in any gadget properties dboxes open */
    for (gadget = window->gadgets; gadget; gadget = gadget->next)
    {
        if (gadget->dbox)
        {
            ER ( gadget_dbox_update_window_name (gadget, name) );
        }
    }

    return NULL;
}


/*
 * Get work area coords of the selection's bounding box
 */

void windowedit_get_selection_bbox (WindowObjPtr window, RectPtr bbox)
{
    GadgetPtr gadget = window->gadgets;

    bbox->minx = bbox->miny = BIG;
    bbox->maxx = bbox->maxy = -BIG;

    while (gadget != NULL)
    {
        if (gadget->selected)
            wimp_merge_bboxes (bbox, bbox, &gadget->hdr.bbox);
        gadget = gadget->next;
    }
}



/*
 * Called when the focus changes - either gained or lost.  Simply
 * force the redraw of the selected entries.  The redraw code decides
 * whether to draw the selection highlighted or not by looking
 * at focus_current(), which will either be the same as 'window'
 * if 'window' is the focus window, or different (perhaps -1) if it is not.
 */

static error * focus_cb (FocusReason why, int window, void *cls)
{
    void *closure;

    if (why == FocusGained || why == FocusLost)
    {
        if (registry_lookup_window (window, &closure) == WindowEdit &&
            closure == cls)
        {
            WindowObjPtr window = (WindowObjPtr) cls;
            RectRec bbox;
            windowedit_get_selection_bbox (window, &bbox);
            windowedit_add_ears_to_bbox (&bbox, &bbox);
            ER ( wimp_invalidate (window->window, &bbox) );
        }
    }

    return NULL;
}


/*
 * Gain the caret and focus into a WindowEdit window
 */

error * windowedit_focus_claim (WindowObjPtr window)
{
    ER ( swi (Wimp_SetCaretPosition,  R0, window->window->handle,  R1, -1,
              R2, 0,  R3, 0,  R4, BIT(25),  R5, 0,  END) );
    return focus_claim (window->window->handle, focus_cb, (void *) window);
}


/*
 * Raise the specified window's window to the top of the window stack.
 * Also ensure that it has the caret and focus.
 */

error * windowedit_raise_window (WindowObjPtr window)
{
    WindowPtr win = window->window;
    RectRec vis = win->visarea;

    win->behind = -1;
    ER ( swi (Wimp_OpenWindow,  R1, win,  END) );

    /* if the Wimp has forced the window to new position, we must note that
        it has been modified */
    if ( vis.minx != win->visarea.minx ||
         vis.miny != win->visarea.miny ||
         vis.maxx != win->visarea.maxx ||
         vis.maxy != win->visarea.maxy )
        protocol_send_resed_object_modified (window);

    return windowedit_focus_claim (window);
}


/*
 * Called to delete and recreate the window on-screen after changes to the
 *  window object have been made (eg after extent changes, or addition/
 *  removal of window furniture).
 *
 * The caller is responsible for calling
 *  protocol_send_resed_object_modified(..) if necessary.
 */

error * windowedit_redisplay_window (WindowObjPtr window)
{
    WindowPtr win = window->window;
    WindowStateRec state;

    /* find out handle of window in front of this one before deletion */
    state.handle = win->handle;
    swi (Wimp_GetWindowState, R1, &state, END);

    ER ( registry_deregister_window (win->handle) );
    ER ( swi (Wimp_DeleteWindow,  R1, win,  END) );

    win->behind = state.behind;
    ER ( swi (Wimp_CreateWindow,  R1, &win->visarea,
                            OUT,  R0, &win->handle,  END) );

    ER ( registry_register_window (win->handle,
                                   WindowEdit, (void *) window) );
    return swi (Wimp_OpenWindow,  R1, win,  END);
}


/*
 * Respond to an Open_Window_Request on a window window
 */

error * windowedit_reopen_window (WindowPtr win, WindowObjPtr window)
{
    RectRec vis = window->window->visarea;
    PointRec scroll = window->window->scrolloffset;

    /* force new coordinates to be multiples of 4 */
    wimp_align_rect (&win->visarea);
    wimp_align_point (&win->scrolloffset);

    window->window->visarea = win->visarea;
    window->window->scrolloffset = win->scrolloffset;
    window->window->behind = win->behind;

    ER ( swi (Wimp_OpenWindow, R1, window->window, END) );

    /* note modification only if new position is different to old */
    if ( vis.minx != win->visarea.minx ||
         vis.miny != win->visarea.miny ||
         vis.maxx != win->visarea.maxx ||
         vis.maxy != win->visarea.maxy ||
         scroll.x != win->scrolloffset.x ||
         scroll.y != win->scrolloffset.y )
        protocol_send_resed_object_modified (window);

    return NULL;
}


/*
 * Close the specified window, removing all traces of it from our workspace,
 * closing associated dialogue boxes, etc.
 *
 * If the Bool 'notifyshell' is TRUE, then notify the shell (the data must
 * already have been transferred back).
 *
 * This is not called for the palette.
 */

error * windowedit_close_window (WindowObjPtr window, Bool notifyshell)
{
    if (notifyshell)
    {
/*        dprintf ("WINDOW: notifying shell\n"); */
        ER ( protocol_send_resed_object_closed (window) );
    }

    /* free any keyboard shortcut records attached to the window */
    {
        KeyBoardShortcutPtr key = window->keyboardshortcuts;

        while (key)
        {
            KeyBoardShortcutPtr next = key->next;
            free (key->keyshow);
            free (key);
            key = next;
        }
    }

    /* free all gadgets in the window */
    {
        GadgetPtr gadget = window->gadgets;

        while (gadget)
        {
            GadgetPtr next = gadget->next;
            gadget_free (gadget);
            gadget = next;
        }
    }

    /* free any space occupied by malloc'd fields in the window itself */
    free (window->p.helpmessage);
    free (window->p.pointershape);
    free (window->p.menu);
    free (window->toolbaribl);
    free (window->toolbaritl);
    free (window->toolbarebl);
    free (window->toolbaretl);

    /* deregister and delete if the window has been created */
    if (window->window->handle != 0)
    {
        (void) registry_deregister_window (window->window->handle);
        (void) swi (Wimp_DeleteWindow,  R1, window->window,  END);
        focus_giveup (window->window->handle);
    }

    /* deregister, delete and free any dbox associated with the window */
    if (window->mainpropsdbox)
        (void) props_close_main_dbox (window);
    if (window->otherpropsdbox)
        (void) props_close_other_dbox (window);
    if (window->extentdbox)
        (void) extent_close_dbox (window);
    if (window->coloursdbox)
        (void) colours_close_dbox (window);
    if (window->keycutsdbox)
        (void) keycuts_close_dbox (window);
    if (window->toolbarsdbox)
        (void) toolbars_close_dbox (window);

    /* free remaining malloc'd storage */
    free ((char *) window->window);
    free (window->p.title);
    free ((char *) window);

    return NULL;
}


/*
 * Respond to close_window_request on an editing window, or to the user
 *  choosing the "Close" menu entry, or to the corresponding keyboard
 *  shortcut.
 * If the window seems to be modified, then send its data back to
 * the shell, marking the window as "pending close".
 * If it is unmodified then just close it.  In any case, tell the
 * shell that it has been closed.
 *
 * If this is the palette, just close the window (don't delete it).
 */

error * windowedit_close_wind (WindowObjPtr window)
{
    if (window->internal)
        return swi (Wimp_CloseWindow,  R1, window->window,  END);

    if (window->modified)
    {
        /* Closing the window is handled for us when the object is safely
           back with the shell */
        window->pendingclose = TRUE;
        return protocol_send_resed_object_sending (window);
    }
    else
    {
        return windowedit_close_window (window, TRUE);
    }
}


/*
 * Return the size in bytes that the specified window will occupy when
 * saved as a ResourceFileObjectTemplateHeaderPtr for transfer to
 * the shell.
 */

int windowedit_object_size (
    WindowObjPtr window,
    int *bodysize, int *stringsize, int *msgsize, int *numrelocs
)
{
    /* size up fields in the window template proper */
    *bodysize = sizeof (WindowTemplateRec);
    *stringsize = 0;
    *msgsize = 0;

    *numrelocs = 12; /* helpmessage, pointershape, menu, keyboardshortcuts,
                        gadgets, spritearea, titletext, titlevalidation,
                        titlebaribl, titlebaritl, titlebarebl, titlebaretl */

    if (window->p.helpmessage)
        *msgsize += strlen (window->p.helpmessage) + 1;
    if (window->p.pointershape)
        *stringsize += strlen (window->p.pointershape) + 1;
    if (window->p.menu)
        *stringsize += strlen (window->p.menu) + 1;
    if (window->p.title)
        *msgsize += strlen (window->p.title) + 1;
    if (window->toolbaribl)
        *stringsize += strlen (window->toolbaribl) + 1;
    if (window->toolbaritl)
        *stringsize += strlen (window->toolbaritl) + 1;
    if (window->toolbarebl)
        *stringsize += strlen (window->toolbarebl) + 1;
    if (window->toolbaretl)
        *stringsize += strlen (window->toolbaretl) + 1;

    /* size up space required for any keyboard shortcuts */
    {
        KeyBoardShortcutPtr key = window->keyboardshortcuts;

        while (key)
        {
            *bodysize += sizeof (KeyBoardShortcutTemplateRec);
            *numrelocs += 1;
            if (key->keyshow)
                *stringsize += strlen (key->keyshow) + 1;
            key = key->next;
        }
    }

    /* size up space required for any gadgets in the window */
    {
        GadgetPtr gadget = window->gadgets;

        while (gadget)
        {
            gadget_size (gadget, bodysize, stringsize, msgsize, numrelocs);
            gadget = gadget->next;
        }
    }

    /* round up to word boundaries */
    *bodysize = (*bodysize + 3) & ~ 3;
    *stringsize = (*stringsize + 3) & ~ 3;
    *msgsize = (*msgsize + 3) & ~ 3;

    return sizeof (ResourceFileObjectTemplateHeaderRec) +
           *bodysize + *stringsize + *msgsize +
           sizeof (int) + *numrelocs * sizeof (RelocationRec);
}

/*
 * Re-order the gadgets into component ID order.  This gives you a
 * more sane redraw when the object is actually used.  This function
 * only modifies the linked list of gadgets, nothing else.
 *
 * Returns the new first item
 */
static void windowedit_insert_gadget(GadgetPtr *headptr, GadgetPtr item)
{
	while (*headptr) {
	        if (item->hdr.componentID < (*headptr)->hdr.componentID) break;
                headptr = &(*headptr)->next;
	}

        item->next = *headptr;
	*headptr = item;
}

static GadgetPtr windowedit_sort_gadgets(GadgetPtr *head, int num_gadgets)
{
        GadgetPtr newlist = NULL;
        GadgetPtr srclist, nextsrc;

	for (srclist = *head; srclist && num_gadgets--; srclist = nextsrc) {
	        nextsrc = srclist->next;
	        windowedit_insert_gadget(&newlist, srclist);
	}

	*head = newlist;
	return newlist;
}


/*
 * Save the specified window to a pre-allocated block of memory as a
 * ResourceFileObjectTemplateHeaderRec ready for transfer to the
 * shell.  The block is expected to be big enough as measured
 * with windowedit_object_size().
 *
 * A note on relocations.  In order to make the "export/import messages"
 * facility as robust as possible, we always output a relocation record
 * for every potential message in the object, even those that are NULL.
 * NULL strings are represented by a relocation record that points to a
 * -1 word (the toolbox loader turns this into a NULL when it is relocated).
 * This ensures that the numbering won't be changed between message export
 * and import if changes have been made to the object's messages since the
 * messages were exported.
 */

error * windowedit_save_object_to_memory (WindowObjPtr window, char *buffer,
                    int bodysize, int stringsize, int msgsize, int numrelocs)
{
    ResourceFileObjectTemplateHeaderPtr object =
                                (ResourceFileObjectTemplateHeaderPtr) buffer;
    WindowTemplatePtr body = (WindowTemplatePtr)
                     (buffer + sizeof (ResourceFileObjectTemplateHeaderRec));
    int offset = sizeof (ResourceFileObjectTemplateHeaderRec) + bodysize;
    TemplateInfoRec tip;
    RelocationTablePtr reloctable;
    char *next;

    /* fill in table offsets, and construct Template Information Record
       for calls to relocate_make_ref(..) */
    tip.body = (char *) body;
    object->stringtableoffset = stringsize ? offset : -1;
    tip.string = tip.stringbase = buffer + offset;
    offset += stringsize;
    object->messagetableoffset = msgsize ? offset : -1;
    tip.msg = tip.msgbase = buffer + offset;
    offset += msgsize;
    object->relocationtableoffset = offset;
    reloctable = (RelocationTablePtr) (buffer + offset);
    reloctable->numrelocations = numrelocs;
    tip.reloc = reloctable->relocations;
    tip.numrelocs = 0;

    /* construct ObjectTemplateHeaderRec */
    object->hdr.class = WINDOW_OBJECT_CLASS;
    /* object->hdr.flags filled in by shell */
    object->hdr.version = WINDOW_OBJECT_VERSION;
    /* object->hdr.name filled in by shell */
    object->hdr.totalsize = sizeof (ObjectTemplateHeaderRec) +
                                   bodysize + stringsize + msgsize;
    object->hdr.bodyoffset = (Offset) sizeof (ObjectTemplateHeaderRec);
    object->hdr.bodysize = bodysize;

    /* fill in the top level window data */
    body->flags = window->p.flags;
    relocate_make_ref (&tip,
        RELOCATE_MSGREFERENCE,
        (int *) &body->helpmessage, window->p.helpmessage);
    body->maxhelp = gui_save_len_field (window->p.helpmessage,
                                        window->p.maxhelp);
    relocate_make_ref (&tip,
        RELOCATE_STRINGREFERENCE,
        (int *) &body->pointershape, window->p.pointershape);
    body->maxpointershape = gui_save_len_field (window->p.pointershape,
                                                window->p.maxpointershape);
    body->pointerxhot = window->p.pointerxhot;
    body->pointeryhot = window->p.pointeryhot;
    relocate_make_ref (&tip,
        RELOCATE_STRINGREFERENCE,
        (int *) &body->menu, window->p.menu);
    body->defaultfocus = window->p.defaultfocus;
    body->showevent = window->p.showevent;
    body->hideevent = window->p.hideevent;
    relocate_make_ref (&tip,
        RELOCATE_STRINGREFERENCE,
        (int *) &body->toolbaribl, window->toolbaribl);
    relocate_make_ref (&tip,
        RELOCATE_STRINGREFERENCE,
        (int *) &body->toolbaritl, window->toolbaritl);
    relocate_make_ref (&tip,
        RELOCATE_STRINGREFERENCE,
        (int *) &body->toolbarebl, window->toolbarebl);
    relocate_make_ref (&tip,
        RELOCATE_STRINGREFERENCE,
        (int *) &body->toolbaretl, window->toolbaretl);

    /* copy over all those window fields ... */
    body->window = *( (WindowWimpTemplatePtr) &window->window->visarea );

    /* force title validation string to be NULL */
    relocate_make_ref (&tip,
        RELOCATE_STRINGREFERENCE,
        (int *) &body->window.titlevalidation, 0);

    /* force window to be on top of stack unless it's at the bottom */
    if ((window->p.windowflags & WF_BACKDROP) != 0)
        body->window.behind = -2;
    else
        body->window.behind = -1;

    /* copy across the "duplicate" values */
    body->window.windowflags = window->p.windowflags;
    IF_SET_FIELD(TYPE, body->window.buttontype, window->p.buttontype);
    body->window.workback = window->p.workBG;
    relocate_make_ref (&tip,
        RELOCATE_SPRITEAREAREFERENCE,
        (int *) &body->window.spritearea,
        (char *) window->p.spritearea);
    relocate_make_ref (&tip,
        RELOCATE_MSGREFERENCE,
        (int *) &body->window.titletext,
        (char *) window->p.title);
    body->window.titlebuflen = gui_save_len_field (window->p.title,
                                                   window->p.maxtitle);

    /* create any keyboard shortcut records */
    next = (char *) (body + 1);
    relocate_make_ref (&tip,
        RELOCATE_OBJECTOFFSET,
        (int *) &body->keyboardshortcuts,
        (window->numkeyboardshortcuts == 0) ? NULL : next);
    {
        KeyBoardShortcutTemplatePtr template =
                               (KeyBoardShortcutTemplatePtr) next;
        KeyBoardShortcutPtr key = window->keyboardshortcuts;

        while (key)
        {
            template->flags = key->flags;
            template->wimpkeycode = key->wimpkeycode;
            template->keyevent = key->keyevent;
            relocate_make_ref (&tip,
                RELOCATE_STRINGREFERENCE,
                (int *) &template->keyshow, key->keyshow);

            key = key->next;
            template++;
        }

        body->numkeyboardshortcuts = window->numkeyboardshortcuts;
        next = (char *) template;
    }

    /* create any gadget records */
    relocate_make_ref (&tip,
        RELOCATE_OBJECTOFFSET,
        (int *) &body->gadgets,
        (window->numgadgets == 0) ? NULL : next);
    {
        GadgetTemplatePtr template = (GadgetTemplatePtr) next;
        GadgetPtr gadget = windowedit_sort_gadgets(&window->gadgets, window->numgadgets);

        while (gadget)
        {
            int bodysize = gadget->def->body.size;

            gadget_save (&tip, gadget, template);

            gadget = gadget->next;
            template = (GadgetTemplatePtr)
                       ( (char *) (template) +
                         sizeof (GadgetTemplateHeaderRec) +
                         bodysize );
        }

        body->numgadgets = window->numgadgets;
        next = (char *) template;
    }

    /* pad out strings and message tables with zeros */
    while ((int) tip.string & 3)
    {
        *tip.string = 0;
        tip.string++;
    }
    while ((int) tip.msg & 3)
    {
        *tip.msg = 0;
        tip.msg++;
    }

    /* consistency checks! */
    if (next != tip.stringbase)
        error_exit (error_lookup ("SaveChk1",
                                  (int) next, (int) tip.stringbase));
    if (tip.string != tip.msgbase)
        error_exit (error_lookup ("SaveChk2",
                                  (int) tip.string, (int) tip.msgbase));
    if (tip.msg != (char *) reloctable)
        error_exit (error_lookup ("SaveChk3",
                                  (int) tip.msg, (int) reloctable));
    if (tip.numrelocs != tip.numrelocs)
        error_exit (error_lookup ("SaveChk4", tip.numrelocs, numrelocs));

    return NULL;
}


/*
 * Create (if necessary) and open the palette.
 */

static error * windowedit_open_palette (void)
{
    if (palette)
    {
        /* Palette already created.  Just open the window */
        palette->window->behind = -1;
        return swi (Wimp_OpenWindow,  R1, palette->window,  END);
    }
    else
    {
        /* Read in palette data and create and open the window */
        char filename[FILENAMELEN], *buf;
        FILE *file;
        int size, off;
        ResourceFileHeaderPtr hdr;
        error *err = NULL;

        sprintf (filename, "%s.%s", appdir, "Palette");
        file = fopen (filename, "r");
        if (file == NULL)
            return error_lookup ("CantRead", filename);

        fseek(file, 0, SEEK_END);
        size = (int) ftell(file);

        buf = calloc(size, sizeof(char));
        if (!buf)
        {
            fclose (file);
            return error_lookup("NoMem");
        }

        fseek (file, 0, SEEK_SET);
        fread (buf, sizeof(*buf), size, file);
        fclose (file);

        hdr = (ResourceFileHeaderPtr) buf;
        off = hdr->objectoffset;

        if (hdr->fileid != ('F' << 24 | 'S' << 16 | 'E' << 8 | 'R')
            || off == -1)  /* off = -1 => no objects */
        {
            free (buf);
            return error_lookup("CantRead", filename);
        }

        palette = (WindowObjPtr) calloc (1, sizeof (WindowObjRec));
        if (palette == NULL)
            return error_lookup ("NoMem");
        palette->window = (WindowPtr) calloc (1, offsetof(WindowRec, icons));
        if (palette->window == NULL)
            return error_lookup ("NoMem");
        palette->internal = TRUE;

        /* The following leaves the window open */

        err = windowedit_load (palette,
                    (ResourceFileObjectTemplateHeaderPtr) (buf + off), NULL);
        if (err)
        {
            free (palette);
            palette = NULL;
        }

        /* Fix all the component IDs in the palette at -1.  This would
         * normally be invalid but we allow the window to be like this to
         * ensure that component IDs in a new window get created
         * incrementally
         */

        {
            GadgetPtr gadget = palette->gadgets;
            while (gadget)
            {
                gadget->hdr.componentID = -1;
                gadget = gadget->next;
            }
        }

        free (buf);
        return err;
    }
}


/*
 * Generate a suitable interactive help message for the editing window.
 * The pointer is at position 'mouse', and the text should be stored at
 *  'reply'.
 * Called from help_message(..).
 * Returns TRUE iff help text has been located.
 */

Bool windowedit_help_text (
    WindowObjPtr window,
    PointPtr mouse,
    char *reply
)
{
    Bool inear;
    int earnum;
    GadgetPtr gadget;
    char *token;
    char buf[MAX_HELP_TEXT];
    char tokbuf[30], namebuf[30];

    /* convert mouse position to work area coordinates */
    wimp_convert_point (ScreenToWork, window->window, mouse, mouse);

    /* before asking where the pointer is */
    gadget = click_in_gadget (window, mouse, &inear, &earnum);

    if (window->internal)     /* palette window */
    {
        if (gadget == NULL || inear)   /* pointer on background */
            return help_lookup_token ("Hlp.P", reply, MAX_HELP_TEXT);

        /* pointer over gadget */
        if (!help_lookup_token ("Hlp.PG", buf, MAX_HELP_TEXT))
            return FALSE;

        sprintf (tokbuf, "Hlp.T.%s", gadget->def->templatename);
        if (!help_lookup_token (tokbuf, namebuf, 30))
            return FALSE;
        sprintf (reply, buf, namebuf);

        token = (gadget->selected) ? "Hlp.PGS" : "Hlp.PGN";
        return help_lookup_token (token, reply + strlen (reply),
                                 MAX_HELP_TEXT - strlen (reply));
    }

    else                      /* editing window */
    {
        if (gadget == NULL)   /* pointer on background */
            return help_lookup_token ("Hlp.E", reply, MAX_HELP_TEXT);

        /* pointer over gadget */
        if (!help_lookup_token ("Hlp.EG", buf, MAX_HELP_TEXT))
            return FALSE;

        sprintf (tokbuf, "Hlp.T.%s", gadget->def->templatename);
        if (!help_lookup_token (tokbuf, namebuf, 30))
            return FALSE;
        sprintf (reply, buf, namebuf,
                             gadget->hdr.componentID,
                             gadget->hdr.bbox.minx,
                             gadget->hdr.bbox.maxy,
                             gadget->hdr.bbox.maxx - gadget->hdr.bbox.minx,
                             gadget->hdr.bbox.maxy - gadget->hdr.bbox.miny );

        if (gadget->selected)
        {
            if (inear)
                switch (earnum)
                {
                    case 0: case 2: case 6: case 8:   /* corner */
                        token = "Hlp.EGC";
                        break;
                    case 3: case 5:                   /* side */
                        token = "Hlp.EGH";
                        break;
                    case 1: case 7:                   /* top or bottom */
                        token = "Hlp.EGV";
                        break;
                    case 4:                           /* internal ear */
                        token = "Hlp.EGI";
                        break;
                    default:
                        return FALSE;
                }
            else
                token = "Hlp.EGS";
        }
        else
            token = "Hlp.EGN";

        return help_lookup_token (token, reply + strlen (reply),
                                 MAX_HELP_TEXT - strlen (reply));
    }
}
