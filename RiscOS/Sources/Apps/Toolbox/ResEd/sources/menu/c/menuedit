/*-*-C-*-
 * menuedit
 *
 * Note: the window handling and redraw code relies on the top-left corner of
 * the extent being at 0,0.
 *
 *
 * Some notes on layout.
 *
 * The work area extent of the window is set up in the conventional
 * way with 0,0 at the top left, and Y becoming more negative as you go
 * down the page.  The top-left of the menu's titlebar is at (menu->margin,-MENU_MARGIN)
 * - note this is a half-open coordinate.
 */

#include "resed.h"
#include "main.h"

#include "swicall.h"
#include "wimp.h"
#include "resformat.h"
#include "newmsgs.h"
#include "dbox.h"
#include "focus.h"
#include "interactor.h"
#include "menu.h"
#include "registry.h"

#include "format.h"
#include "relocate.h"
#include "menuedit.h"
#include "drag.h"
#include "gui.h"
#include "help.h"
#include "lassoo.h"
#include "props.h"
#include "protocol.h"

static error * create_menu (void);   /* allows forward reference */

static WindowPtr menuwinproto, palwin;
static int menuwinsize;
static MenuObjPtr palette = NULL;
static MenuPtr menumenu = NULL, editmenu = NULL;
static int key_delete, key_menuprops, key_entryprops, key_selectall, key_clearsel;

#define MENUMENU_EDIT 0
#define MENUMENU_PROPS 1
#define MENUMENU_PALETTE 2

#define EDITMENU_DELETE 0
#define EDITMENU_PROPS 1
#define EDITMENU_SELALL 2
#define EDITMENU_CLEAR 3


/*
 * Set up basic icon flags - FG, BG, FILLED, SELECTED, SHADED.
 *
 * These are chosen so that text menu entries and the ticks and
 *  submenu arrows look "right" when plotted normally or shaded,
 *  selected or not, in a window with input focus or not. Note that
 *  menu entries that are sprites are treated like the ticks or
 *  submenu arrows.
 */

static unsigned int textflags[] =              /* focus? shaded? selected? */
{
    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   N       N        N     */
    IF_FIELD (BG, ENTRY_NORMAL_BG) |
    IF_FILLED,

    IF_FIELD (FG, ENTRY_SELECTED_NOFOCUS_BG) | /*   N       N        Y     */
    IF_FIELD (BG, ENTRY_NORMAL_FG) |
    IF_FILLED | IF_SELECTED,

    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   N       Y        N     */
    IF_FIELD (BG, ENTRY_NORMAL_BG) |
    IF_FILLED | IF_SHADED,

    IF_FIELD (FG, ENTRY_SELECTED_NOFOCUS_BG) | /*   N       Y        Y     */
    IF_FIELD (BG, ENTRY_NORMAL_BG) |
    IF_FILLED | IF_SELECTED,

    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   Y       N        N     */
    IF_FIELD (BG, ENTRY_NORMAL_BG) |
    IF_FILLED,

    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   Y       N        Y     */
    IF_FIELD (BG, ENTRY_NORMAL_BG) |
    IF_FILLED | IF_SELECTED,

    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   Y       Y        N     */
    IF_FIELD (BG, ENTRY_NORMAL_BG) |
    IF_FILLED | IF_SHADED,

    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   Y       Y        Y     */
    IF_FIELD (BG, ENTRY_SELECTED_NOFOCUS_BG) |
    IF_FILLED | IF_SELECTED
};

static unsigned int spriteflags[] =            /* focus? shaded? selected? */
{
    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   N       N        N     */
    IF_FIELD (BG, ENTRY_NORMAL_BG) |
    IF_FILLED,

    IF_FIELD (FG, ENTRY_SELECTED_NOFOCUS_BG) | /*   N       N        Y     */
    IF_FIELD (BG, ENTRY_SELECTED_NOFOCUS_BG) |
    IF_FILLED | IF_SELECTED | IF_SHADED,

    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   N       Y        N     */
    IF_FIELD (BG, ENTRY_NORMAL_BG) |
    IF_FILLED | IF_SHADED,

    IF_FIELD (FG, ENTRY_SELECTED_NOFOCUS_BG) | /*   N       Y        Y     */
    IF_FIELD (BG, ENTRY_SELECTED_NOFOCUS_BG) |
    IF_FILLED | IF_SELECTED | IF_SHADED,

    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   Y       N        N     */
    IF_FIELD (BG, ENTRY_NORMAL_BG) |
    IF_FILLED,

    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   Y       N        Y     */
    IF_FIELD (BG, ENTRY_NORMAL_FG) |
    IF_FILLED | IF_SELECTED,

    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   Y       Y        N     */
    IF_FIELD (BG, ENTRY_NORMAL_BG) |
    IF_FILLED | IF_SHADED,

    IF_FIELD (FG, ENTRY_NORMAL_FG) |           /*   Y       Y        Y     */
    IF_FIELD (BG, ENTRY_NORMAL_FG) |
    IF_FILLED | IF_SELECTED
};



/*
 * Make a malloced copy of a string.  If the src string is NULL, return NULL.
 */

char *copystring (char *src)
{
    if (src != NULL)
    {
        char *dst = malloc (strlen (src) + 1);
        if (dst) strcpy (dst, src);
        return dst;
    }
    else
        return NULL;
}


/*
 * If the location addressed by s contains NULL, do nothing. Otherwise, make
 *  a copy of the string addressed by *s, and store its address at *s.
 *
 * Result is NULL unless memory runs out, in which case a suitable error
 *  message is returned.
 */

error * clonestring (char **s)
{
    char *clone;

    if (*s == NULL)
        return NULL;

    clone = (char *) malloc (strlen(*s) + 1);
    if (clone == NULL)
        return error_lookup ("NoMem");

    strcpy (clone, *s);
    *s = clone;
    return NULL;
}


/*
 * Compare two values which may be NULL or may be strings
 */

Bool equalstrings (char *s, char *t)
{
    return (s == NULL && t == NULL ||
            s != NULL && t != NULL && strcmp (s, t) == 0);
}


/*
 * Load Templates pertaining to this module
 */

error * menuedit_load_prototypes ()
{
    ER ( create_menu () );
    ER ( wimp_load_template ("palwin", &palwin) );
    return wimp_load_template_returning_size ("menuwin", &menuwinproto, &menuwinsize);
}


/*
 * Determine whether the given string has a "keyboard shortcut" in it.
 * This is spotted by looking for two consecutive spaces at the
 * right-hand end of the string followed by some other characters.
 * Also the keyname cannot itself contain any spaces at all.
 * These conventions are enforced by the shortcut entry dbox.
 *
 * Return address of the first character in the keyname, or NULL if none
 * was found.  The number of spaces before this point is at least 2.
 * If padding is non-NULL, use it to return the position of the
 * first space in the padding.
 */

char * menuedit_find_keyname (char *string, char **padding)
{
    char *lastspace;
    if (string == NULL)
        return NULL;
    lastspace = strrchr (string, ' ');
    if (lastspace == NULL || lastspace == string)
        return NULL;
    if (*(lastspace + 1) == 0)
        return NULL;
    if (*(lastspace - 1) != ' ')
        return NULL;

    /* Determine end of non-keycut portion */
    if (padding)
    {
        char *where = lastspace;
        while (where > string && *(where - 1) == ' ')
            where--;
        *padding = where;
    }

    return lastspace + 1;
}


/*
 * Determine width of window required for the given title string.
 * Allow 32 OS Units for each for the window decorations.
 */

static int find_title_width (MenuObjPtr menu)
{
    char buf[100];
    sprintf (buf, dbox_gettitle (menuwinproto), menu->name);

    return wimp_string_width (buf) + (3 * 32);
}


/*
 * Calculate the width of a menu entry.  If there is an error, return 0.
 * This does not need to do anything special about strings containing keyboard
 * shortcuts.
 *
 * Separator entries are said to have zero width so that they will expand
 * to fit.
 */

static int entry_width (MenuEntryPtr entry)
{
    if (entry->separator)
        return 0;
    else if (entry->p.flags & MENU_ENTRY_ISSPRITE)
    {
        int width, mode, xeig, carry;
        if (swi (Wimp_SpriteOp,  R0, 40,  R2,  entry->p.text,
                 OUT,  R3,  &width,  R6, &mode,  END))
            return 0;
        if (swi (OS_ReadModeVariable,  R0, mode,  R1, 4,
                 OUT,  R2, &xeig,  CARRY, &carry,  END) || carry)
            return 0;
        return width << xeig;   /* OS Units */
    }
    else
    {
        if (entry->p.text)
            return wimp_string_width (entry->p.text) + 16;
        else
            return 16;
    }
}


/*
 * Recalculate menu size & save some useful information about the
 * position of all the menu items.
 *
 * The menu's top-left corner is at MENU_MARGIN, -MENU_MARGIN in work area coords.
 * This is the position of the top-left corner of the title icon.
 * The border is not included in the numbers.
 *
 * The menu entries dangle below this.
 *
 * Also calculates the work area extent required on the window, returning
 * it in workwidth, workheight.  Fixes up menu->numentries and menu->numselected
 * too just in case.
 *
 * The palette window has slightly different layout, this is handled here.
 */

void menuedit_calculate_menu_size (MenuObjPtr menu, int *workwidth, int *workheight)
{
    MenuEntryPtr entry;
    int width, titlewidth, ypos;
    /* Smaller margins on the palette */
    int margin = menu->internal ? MENU_MARGIN / 2 : MENU_MARGIN;
    
    /* No title strip in the palette window */
    if (menu->internal)
        ypos = -margin;
    else
        ypos = - (margin + MENU_TITLE_HEIGHT);

    menu->numselected = menu->numentries = 0;

    {
        int titlewidth = 
            (menu->p.title) ? wimp_string_width (menu->p.title) : 0;

        menu->entrywidth = titlewidth + 16;
    }

    for (entry = menu->entries; entry; entry = entry->next)
    {
        menu->numentries++;
        if (entry->selected)
            menu->numselected++;

        width = entry_width (entry);
        if (width > menu->entrywidth)
            menu->entrywidth = width;

        /* If this is the palette leave extra space between entries to make it look different */
        if (menu->internal && entry != menu->entries)
            ypos -= WIMP_ALIGN_COORD (ENTRY_HEIGHT_NORMAL / 2);

        entry->maxy = ypos;     /* Half open */
        ypos -= entry->separator ? ENTRY_HEIGHT_SEPARATOR : ENTRY_HEIGHT_NORMAL;
        entry->miny = ypos;

    }

    menu->width = menu->entrywidth + MENU_TICK_WIDTH + MENU_ARROW_WIDTH;
    menu->height = - (ypos + margin);

    /* Determine the size of the work area and the horizontal
     * margins required for centering
     */

    titlewidth = find_title_width (menu);
    width = 2 * margin + menu->width;
    if (titlewidth > width)
        width = titlewidth;
    menu->margin = (width - menu->width) / 2;
    if (workwidth) *workwidth = width;
    if (workheight) *workheight = 2 * margin + menu->height;
}


/*
 * Return the work-area bounding box of the menu's titlebar, not including
 * the border.
 */

static void get_titlebar_bbox (MenuObjPtr menu, RectPtr box)
{
    box->minx = menu->margin;
    box->maxx = box->minx + menu->width;
    box->maxy = -MENU_MARGIN;
    box->miny = box->maxy - MENU_TITLE_HEIGHT;
}


/*
 * Return work-area bounding box of a menu entry, not including
 * the border.
 */

void menuedit_get_entry_bbox (MenuObjPtr menu, MenuEntryPtr entry, RectPtr box)
{
    box->minx = menu->margin;
    box->maxx = box->minx + menu->width;
    box->miny = entry->miny;
    box->maxy = entry->maxy;
}
 

/*
 * Get work area coords of the selection's bounding box
 */

void menuedit_get_selection_bbox (MenuObjPtr menu, RectPtr bbox)
{
    MenuEntryPtr entry;
    RectRec entrybox;
    bbox->minx = bbox->miny = BIG;
    bbox->maxx = bbox->maxy = -BIG;
    for (entry = menu->entries; entry; entry = entry->next)
        if (entry->selected)
        {
            menuedit_get_entry_bbox (menu, entry, &entrybox);
            wimp_merge_bboxes (bbox, bbox, &entrybox);
        }
}


/*
 * Get the bounding box (half open) of the menu's border
 */

static void get_border_bbox (MenuObjPtr menu, RectPtr box)
{
    int margin = menu->internal ? MENU_MARGIN / 2 : MENU_MARGIN;
    box->minx = menu->margin - scalex;
    box->maxx = menu->margin + menu->width + scalex;
    box->maxy = -margin + scaley;
    box->miny = -margin - menu->height - scaley;
}


/*
 * Return TRUE or FALSE according to whether the work-area bounding box
 * intersects the titlebar of the menu.
 */

static Bool titlebar_intersects (MenuObjPtr menu, RectPtr workbox)
{
    RectRec box;
    if (menu->internal)
        return FALSE;           /* No title in the palette window */
    get_titlebar_bbox (menu, &box);
    return wimp_rects_intersect (workbox, &box);
}


/*
 * Test to see whether a particular menu entry intersects
 * the given work-area bounding box.  Useful for deciding whether
 * to redraw the entry, and also for click detection.
 */

static Bool entry_intersects (MenuObjPtr menu, MenuEntryPtr entry, RectPtr workbox)
{
    RectRec box;
    menuedit_get_entry_bbox (menu, entry, &box);
    return wimp_rects_intersect (workbox, &box);
}


/*
 * Return TRUE or FALSE according to whether the specified work-area
 * mouse click position is in the titlebar or not
 */

static Bool click_in_titlebar (MenuObjPtr menu, PointPtr click)
{
    RectRec box;
    box.minx = click->x;
    box.miny = click->y;
    box.maxx = box.minx + scalex;
    box.maxy = box.miny + scaley;
    return titlebar_intersects (menu, &box);
}


/*
 * Return the menu entry which intersects the specified work-area
 * mouse click position, or NULL if none.
 */

static MenuEntryPtr click_in_entry (MenuObjPtr menu, PointPtr click)
{
    MenuEntryPtr entry;
    RectRec box;
    box.minx = click->x;
    box.miny = click->y;
    box.maxx = box.minx + scalex;
    box.maxy = box.miny + scaley;

    for (entry = menu->entries; entry; entry = entry->next)
        if (entry_intersects (menu, entry, &box))
            return entry;
    return NULL;
}


/*
 * Plot the specified menu entry at its stored position.  This must
 * only be called in a screen redraw loop.
 *
 * Entry: the background has been cleared to the window background
 * colour.
 * Exit: the menu entry has been plotted, complete with selection
 * highlighting and dotted line if appropriate.  The menu's border
 * is not drawn.
 */

static error * plot_entry (MenuObjPtr menu, MenuEntryPtr entry, Bool havefocus)
{
    IconRec icon;
    char *entrytext = (entry->p.text) ? entry->p.text : "";
    Bool shaded = entry->p.flags & MENU_ENTRY_FADED;
    Bool selected = entry->selected;
    int state = (havefocus ? 4 : 0) + (shaded ? 2 : 0) + (selected ? 1 : 0);

    icon.bbox.minx = menu->margin;
    icon.bbox.maxx = icon.bbox.minx + menu->width;
    icon.bbox.maxy = entry->maxy;
    icon.bbox.miny = entry->miny;

    /* plot appropriate background colour */
    if (selected)
        icon.flags = IF_FILLED |
                     IF_FIELD (BG, 
                               havefocus ? ENTRY_SELECTED_FOCUS_BG :
                                           ENTRY_SELECTED_NOFOCUS_BG);
    else
        icon.flags = IF_FILLED | IF_FIELD (BG, ENTRY_NORMAL_BG);
    ER ( swi (Wimp_PlotIcon,  R1, &icon,  END) );

    /* If this entry is a separator, just draw a dotted line.  Otherwise
     *  plot the entry text/sprite and the decorations
     */

    if (entry->separator)
    {
        icon.bbox.minx = menu->margin;
        icon.bbox.maxx = icon.bbox.minx + menu->width;
        icon.bbox.miny = entry->miny + ENTRY_HEIGHT_SEPARATOR / 2;
        icon.bbox.maxy = icon.bbox.miny;
        wimp_convert_rect (WorkToScreen, menu->window, &icon.bbox, &icon.bbox);
        ER ( wimp_set_dotdash (NULL) );
        {
            int fgcolour = (entry->selected && havefocus) ? ENTRY_NORMAL_BG :
                                                            ENTRY_NORMAL_FG;
            ER ( swi (Wimp_SetColour,  R0, fgcolour,  END) );
        }
        ER ( swi (OS_Plot, R0, 4, R1, icon.bbox.minx, R2, icon.bbox.miny,  END) );
        ER ( swi (OS_Plot, R0, 5 | 24, R1, icon.bbox.maxx, R2, icon.bbox.maxy,  END) );
    }
    else
    {
        /* Plot the tick, if present */
        if (entry->p.flags & MENU_ENTRY_TICKED)
        {
            icon.bbox.maxx = icon.bbox.minx + MENU_TICK_WIDTH;
            icon.flags = IF_HCENT | IF_VCENT | IF_SPRITE |
                             spriteflags[state];
            strcpy ((char *) icon.data, "\200");
            ER ( swi (Wimp_PlotIcon,  R1, &icon,  END) );
        }

        /* Plot the entry itself */
        icon.bbox.minx = menu->margin + MENU_TICK_WIDTH;
        icon.bbox.maxx = icon.bbox.minx + menu->entrywidth;
        icon.flags = IF_VCENT | IF_INDIR;

        if (entry->p.flags & MENU_ENTRY_ISSPRITE)
        {
            icon.flags |= IF_SPRITE | spriteflags[state];

            icon.data[0] = (unsigned int) entrytext;
            icon.data[1] = 1;   /* Wimp sprite area */
            icon.data[2] = strlen(entrytext) + 1;
            ER ( swi (Wimp_PlotIcon,  R1, &icon,  END) );
        }
        else
        {
            error *err;
            char *padding, *keyname = menuedit_find_keyname (entrytext, &padding);

            /*
             * If the menu item's text is in two parts - entry text and key
             *  name - then we must plot two adjoining icons. The first one
             *  must be big enough to contain the entry text, and we call
             *  wimp_string_width(..) to find how wide this is. But this is
             *  not guaranteed to be completely accurate (and does not allow
             *  for the icon's border in any case), so we add a fudge factor
             *  of 16 OS units. This should be safe, because there should
             *  always be at least two spaces between the entry text and its
             *  keyboard shortcut.
             */

            if (keyname)
            {
                *padding = 0;
                icon.bbox.maxx = icon.bbox.minx + 16 +
                                     wimp_string_width (entrytext);
            }

            icon.flags |= IF_TEXT | textflags[state];

            icon.data[0] = (unsigned int) entrytext;
            icon.data[1] = (unsigned int) "";
            icon.data[2] = strlen (entrytext) + 1;
            err = swi (Wimp_PlotIcon,  R1, &icon,  END);
        
            if (keyname)
            {
                *padding = ' ';
                if (err)
                    return err;
                {
                    int lhs = icon.bbox.minx;
                    icon.bbox.minx = icon.bbox.maxx;
                    icon.bbox.maxx = lhs + menu->entrywidth;
                }
                icon.flags |= IF_RJUST;
                icon.data[0] = (unsigned int) keyname;
                icon.data[1] = (unsigned int) "";
                icon.data[2] = strlen (keyname) + 1;
                ER ( swi (Wimp_PlotIcon,  R1, &icon,  END) );
            }
        }

        /* Plot the submenu arrow, if present */
        if (entry->p.flags & MENU_ENTRY_SUBMENU)
        {
            icon.bbox.minx = icon.bbox.maxx;
            icon.bbox.maxx = icon.bbox.minx + MENU_ARROW_WIDTH;
            icon.flags = IF_HCENT | IF_VCENT | IF_SPRITE |
                             spriteflags[state];
            strcpy ((char *) icon.data, "\211");
            ER ( swi (Wimp_PlotIcon,  R1, &icon,  END) );
        }

    }

    /* add border for items in the palette */
    if (menu->internal)
    {
        icon.bbox.minx = menu->margin;
        icon.bbox.maxx = icon.bbox.minx + menu->width;
        icon.bbox.maxy = entry->maxy;
        icon.bbox.miny = entry->miny;

        icon.flags = IF_BORDER | IF_FIELD (FG, ENTRY_NORMAL_FG);
        ER ( swi (Wimp_PlotIcon,  R1, &icon,  END) );
    }

    return NULL;
}


/*
 * Redraw the menu's titlebar.  Must only be called in a redraw loop.
 */

static error * plot_titlebar (MenuObjPtr menu)
{
    IconRec icon;

    if (menu->internal)
        return NULL;

    icon.bbox.minx = menu->margin;
    icon.bbox.maxx = icon.bbox.minx + menu->width;
    icon.bbox.maxy = -MENU_MARGIN;
    icon.bbox.miny = icon.bbox.maxy - MENU_TITLE_HEIGHT;

    icon.flags = IF_INDIR | IF_TEXT | IF_FILLED | IF_VCENT | IF_HCENT |
        IF_FIELD (BG, TITLE_NORMAL_BG) | IF_FIELD (FG, ENTRY_NORMAL_FG);

    icon.data[0] = (unsigned int) ((menu->p.title) ? menu->p.title : "");
    icon.data[1] = (unsigned int) "";
    icon.data[2] = strlen ((char *)(icon.data[0])) + 1;

    return swi (Wimp_PlotIcon,  R1, &icon,  END);
}


/*
 * Redraw the menu's border.  Must only be called in a redraw loop.
 * This is not done for the palette.
 */

static void plot_border (MenuObjPtr menu)
{
    RectRec box;

    if (menu->internal)
        return;

    get_border_bbox (menu, &box);
    box.maxx -= scalex;    /* convert from half-open */
    box.maxy -= scaley;

    wimp_convert_rect (WorkToScreen, menu->window, &box, &box);
    swi (Wimp_SetColour,  R0, MENU_BORDER_FG,  END);
    swi (OS_Plot, R0, 4, R1, box.minx, R2, box.miny,  END);
    swi (OS_Plot, R0, 5, R1, box.maxx, R2, box.miny,  END);
    swi (OS_Plot, R0, 5, R1, box.maxx, R2, box.maxy,  END);
    swi (OS_Plot, R0, 5, R1, box.minx, R2, box.maxy,  END);
    swi (OS_Plot, R0, 5, R1, box.minx, R2, box.miny,  END);
}
    

/*
 * Redraw loop for a menu window, updating the lassoo too if one is specified.
 * Must be called as a result of a redraw event.
 */

error * menuedit_redraw_window (WindowRedrawPtr redraw, MenuObjPtr menu)
{
    int more;
    int havefocus = focus_current() == menu->window->handle;

    ER ( swi(Wimp_RedrawWindow,  R1, redraw,  OUT,  R0, &more,  END) );
    while (more)
    {
        RectRec work, box;
        MenuEntryPtr entry;

        /* Determine work-area relative bbox of invalid area */
        wimp_convert_rect(ScreenToWork, (WindowPtr) redraw, &redraw->graphwin, &work);

        /* Plot titlebar, if necessary */

        if (titlebar_intersects (menu, &work))
            ER ( plot_titlebar (menu) );

        /* Now plot any menu entries that are in the area */

        for (entry = menu->entries; entry; entry = entry->next)
            if (entry_intersects (menu, entry, &work))
                ER ( plot_entry (menu, entry, havefocus) );

        /* Plot border, if necessary */

        get_border_bbox (menu, &box);
        if (wimp_rects_intersect (&work, &box))
            plot_border (menu);

        ER ( swi (Wimp_GetRectangle,  R1,  redraw,  OUT,  R0, &more,  END) );
    }
    return NULL;
}


/*
 * Select or deselect a menu entry.  Redraw window.
 */

static error * select_entry (MenuObjPtr menu, MenuEntryPtr entry, Bool newstate)
{
    RectRec bbox;

    if (entry->selected == newstate)
        return NULL;
    menu->numselected += newstate ? 1 : -1;
    entry->selected = newstate;

    menuedit_get_entry_bbox (menu, entry, &bbox);
    return wimp_invalidate (menu->window, &bbox);
}


/*
 * Select all or clear the current selection, depending on the value of 'newstate'.
 * Redraw the window.
 */

static error * set_or_clear_selection (MenuObjPtr menu, Bool newstate)
{
    MenuEntryPtr entry;
    RectRec bbox;
    if (newstate == TRUE && menu->numselected == menu->numentries ||
        newstate == FALSE && menu->numselected == 0)
        return NULL;

    menu->numselected = newstate ? menu->numentries : 0;
    for (entry = menu->entries; entry; entry = entry->next)
        entry->selected = newstate;
    get_border_bbox (menu, &bbox);
    return wimp_invalidate (menu->window, &bbox);
}


/*
 * Check to see if the window needs resizing.  This is based on whether the
 * required work area has altered.  Always forces a redraw of the window.
 */

error * menuedit_fix_extent (MenuObjPtr menu)
{
    int workwidth, workheight, excess;
    menuedit_calculate_menu_size (menu, &workwidth, &workheight);

    /* if work area is different, need to re-size window etc */

    if (menu->window->workarea.maxx - menu->window->workarea.minx != workwidth ||
        menu->window->workarea.maxy - menu->window->workarea.miny != workheight)
    {
        Bool reopen = FALSE;
        ER ( swi (Wimp_GetWindowState,  R1, menu->window,  END) );
    
        /* Trim visible width and height if too big */
        
        excess = (menu->window->visarea.maxx - menu->window->visarea.minx) - workwidth;
        if (excess > 0)
        {
            menu->window->visarea.maxx -= excess;
            reopen = TRUE;
        }
        excess = (menu->window->visarea.maxy - menu->window->visarea.miny) - workheight;
        if (excess > 0)
        {
            menu->window->visarea.miny += excess;
            reopen = TRUE;
        }

        /* Validate X scrollbar  */

        if (menu->window->scrolloffset.x < 0)
        {
            menu->window->scrolloffset.x = 0;
            reopen = TRUE;
        }
        excess = workwidth - (menu->window->visarea.maxx - menu->window->visarea.minx);
        if (menu->window->scrolloffset.x > excess)
        {
            menu->window->scrolloffset.x = excess;
            reopen = TRUE;
        }

        /* Validate Y scrollbar */

        if (menu->window->scrolloffset.y > 0)
        {
            menu->window->scrolloffset.y = 0;
            reopen = TRUE;
        }
        excess = (menu->window->visarea.maxy - menu->window->visarea.miny) - workheight;
        if (menu->window->scrolloffset.y < excess)
        {
            menu->window->scrolloffset.y = excess;
            reopen = TRUE;
        }

        /* If the window was at "full size" then keep it at full size.  The palette
         * window is forever at full size because it has no scrollbars or resize icon.
         */

        if (menu->internal || menu->window->flags & WF_INFO_FULL_SIZE)
        {
            menu->window->visarea.maxx = menu->window->visarea.minx + workwidth;
            menu->window->visarea.miny = menu->window->visarea.maxy - workheight;
            reopen = TRUE;
        }

        menu->window->workarea.maxx = menu->window->workarea.minx + workwidth;
        menu->window->workarea.miny = menu->window->workarea.maxy - workheight;
        ER ( swi (Wimp_SetExtent, R0, menu->window->handle,  R1, &menu->window->workarea,  END) );
        if (reopen)
        {
            ER ( swi (Wimp_OpenWindow,  R1, menu->window,  END) );
        }
    }

    return wimp_invalidate (menu->window, &menu->window->workarea);
}


/*
 * Called when the focus changes - either gained or lost.  Simply
 * force the redraw of the selected entries.  The redraw code decides
 * whether to draw the selection highlighted or not by looking
 * at focus_current(), which will either be the same as 'window'
 * if 'window' is the focus window, or different (perhaps -1) if it is not.
 */

static error * focus_cb (FocusReason why, int window, void *cls)
{
    void *closure;
    if (why == FocusGained || why == FocusLost)
    {
        if (registry_lookup_window (window, &closure) == MenuEdit &&
            closure == cls)
        {
            MenuObjPtr menu = (MenuObjPtr) cls;
            RectRec bbox;
            menuedit_get_selection_bbox (menu, &bbox);
            ER ( wimp_invalidate (menu->window, &bbox) );
        }
    }
    return NULL;
}


/*
 * Gain the caret and focus into a MenuEdit window
 */

error * menuedit_focus_claim (MenuObjPtr menu)
{
    ER ( swi (Wimp_SetCaretPosition,  R0, menu->window->handle,  R1, -1,
              R2, 0,  R3, 0,  R4, BIT(25),  R5, 0,  END) );
    return focus_claim (menu->window->handle, focus_cb, (void *) menu);
}


/*
 * Free a menu entry and all associated data, and delete its dbox if
 * it is extant.
 */

static void free_entry (MenuEntryPtr entry)
{
    if (entry->separator == FALSE)
    {
        free (entry->p.text);
        free (entry->p.clickshow);
        free (entry->p.submenushow);
        free (entry->p.helpmessage);
        if (entry->dbox)
        {
            (void) registry_deregister_window (entry->dbox->handle);
            (void) swi (Wimp_DeleteWindow,  R1, entry->dbox,  END);
            free ((char *) entry->dbox);
        }
    }
    free ((char *) entry);
}


/*
 * Delete all the selected menu entries in the indicated menu.  Fix up
 * the window size and redraw.
 */

static error * delete_selection (MenuObjPtr menu)
{
    MenuEntryPtr entry, next, last = NULL;

    for (entry = menu->entries; entry; entry = next)
    {
        next = entry->next;
        if (entry->selected)
        {
            free_entry (entry); /* also closes dbox, etc */
            menu->numentries--;
            if (last)
                last->next = next;
            else
                menu->entries = next;
        }
        else
            last = entry;
    }
    menu->numselected = 0;
    menuedit_canonicalise (menu);
    ER ( protocol_send_resed_object_modified (menu) );
    ER ( menuedit_justify_keycuts (menu) );
    return menuedit_fix_extent (menu);
}


/*
 * Menu handling.  Replace this with something more compact one day!
 */

static error * create_menu (void)
{
    ER ( menu_create (4, message_lookup (&msgs, "EM_Name"), &editmenu) );
    ER ( menu_entry (editmenu, EDITMENU_DELETE, message_lookup (&msgs, "EM_Delt"),
                     0, 0, -1, -1, NULL) );
    ER ( menu_entry (editmenu, EDITMENU_PROPS, message_lookup (&msgs, "EM_Prop"),
                     0, MF_DOTTED, -1, -1, NULL) );
    ER ( menu_entry (editmenu, EDITMENU_SELALL, message_lookup (&msgs, "EM_SAll"),
                     0, 0, -1, -1, NULL) );
    ER ( menu_entry (editmenu, EDITMENU_CLEAR, message_lookup (&msgs, "EM_CSel"),
                     0, 0, -1, -1, NULL) );

    ER ( menu_create (3, message_lookup (&msgs, "MM_Name"), &menumenu) );
    ER ( menu_entry (menumenu, MENUMENU_EDIT, message_lookup (&msgs, "MM_Edit"),
                     0, 0, -1, -1, (void *) editmenu) );
    ER ( menu_entry (menumenu, MENUMENU_PROPS, message_lookup (&msgs, "MM_Prop"),
                     0, 0, -1, -1, NULL) );
    ER ( menu_entry (menumenu, MENUMENU_PALETTE, message_lookup (&msgs, "MM_Palt"),
                     0, 0, -1, -1, NULL) );
    ER ( menu_register (menumenu, MAIN_MENU) );

    key_menuprops = atoi (message_lookup (&msgs, "KMM_Prop"));
    key_entryprops = atoi (message_lookup (&msgs, "KEM_Prop"));
    key_delete = atoi (message_lookup (&msgs, "KEM_Delt"));
    key_selectall = atoi (message_lookup (&msgs, "KEM_SAll"));
    key_clearsel = atoi (message_lookup (&msgs, "KEM_CSel"));

    return NULL;
}


/*
 * Do any shading etc necessary before posting the menu
 */

static void prepare_menu (MenuObjPtr menu)
{
    if (menu->numselected != 0)
    {
        /* We have a selection */
        menu_shade_menu (editmenu, FALSE);
        menu_shade (editmenu, EDITMENU_PROPS, menu->numselected > 1);
    }
    else
    {
        /* No selection in this doc */
        menu_shade_menu (editmenu, TRUE);
        menu_shade (editmenu, EDITMENU_SELALL, FALSE);
    }
}


/*
 * Callback for the menuedit window's menu.
 */

static error * menumenu_cb (MenuPtr wimpmenu, int *buf, void *closure, Bool adjust)
{
    MenuObjPtr menu = (MenuObjPtr) closure;
    if (buf)
    {
        if (buf[0] == MENUMENU_EDIT)
        {
            if (buf[1] == EDITMENU_DELETE)
            {
                ER ( delete_selection (menu) );
            }
            else if (buf[1] == EDITMENU_PROPS)
            {
                MenuEntryPtr entry;
                for (entry = menu->entries; entry; entry = entry->next)
                {
                    if (entry->selected)
                    {
                        ER ( props_open_entry_dbox (menu, entry) );
                    }
                }
            }
            else if (buf[1] == EDITMENU_SELALL)
            {
                menu->weakselection = FALSE;
                ER ( set_or_clear_selection (menu, TRUE) );
            }
            else if (buf[1] == EDITMENU_CLEAR)
            {
                ER ( set_or_clear_selection (menu, FALSE) );
            }
        }
        else if (buf[0] == MENUMENU_PROPS)
        {
            ER ( props_open_menu_dbox (menu) );
        }
        else if (buf[0] == MENUMENU_PALETTE)
        {
            ER ( menuedit_open_palette () );
        }

        if (adjust)
            prepare_menu (menu);
    }
    else
        if (!adjust && menu->weakselection)
        {
            ER ( set_or_clear_selection (menu, FALSE) );
        }

    return NULL;
}


/*
 * Post the menuedit window's menu.  The window should already have
 * the focus.
 */

static error * post_menumenu (PointPtr workposition, PointPtr screenposition, MenuObjPtr menu, MenuEntryPtr entry)
{
    if (menu->numselected != 0)
    {
        /* We have a selection */
        menu->weakselection = FALSE;
        prepare_menu (menu);
    }
    else if (entry)
    {
        select_entry (menu, entry, TRUE);
        menu->weakselection = TRUE;
        prepare_menu (menu);
    }
    else
    {
        menu->weakselection = FALSE;
        prepare_menu (menu);
    }

    return menu_post (menumenu, screenposition, FALSE, menumenu_cb, (void *) menu);
}


/*
 * Detect clicks on the Window menu and dispatch as appropriate.
 */

error * menuedit_mouse_click (MouseClickPtr mouse, unsigned int modifiers, MenuObjPtr menu)
{
    PointRec position;
    MenuEntryPtr entry;

    wimp_convert_point (ScreenToWork, menu->window, &mouse->position, &position);
    entry = click_in_entry (menu, &position);

    /* All clicks gain caret and focus */
    ER ( menuedit_focus_claim (menu) );

    switch (mouse->buttons)
    {
    case MB_DOUBLE(MB_SELECT):
        if (menu->internal)
            return NULL;
        if (click_in_titlebar (menu, &position))
            return props_open_menu_dbox (menu);
        if (entry && entry->separator == FALSE)
            return props_open_entry_dbox (menu, entry);
        break;
        
    case MB_SINGLECLICK(MB_SELECT):
        if (entry == NULL)
            return set_or_clear_selection (menu, FALSE);
        else if (!entry->selected)
        {
            ER ( set_or_clear_selection (menu, FALSE) );
            return select_entry (menu, entry, TRUE);
        }
        break;

    case MB_SINGLECLICK(MB_ADJUST):
        if (entry)
            return select_entry (menu, entry, !entry->selected);
        break;

    case MB_MENU:
        if (menu->internal)
            return NULL;
        return post_menumenu (&position, &mouse->position, menu, entry);
        break;

    case MB_DRAG(MB_SELECT):
    case MB_DRAG(MB_ADJUST):
        if (click_in_titlebar (menu, &position))
            return NULL;        /* can't drag titlebar */
        else if (entry == NULL) /* background */
            return lassoo_start (menu, mouse, modifiers);
        else if (entry->selected &&    /* menu entry */
                 mouse->buttons == MB_DRAG(MB_SELECT))
            return drag_start (menu, entry, mouse, modifiers);
        break;
    }
    return NULL;
}


/*
 * Raise the specified menu's window to the top of the window stack.
 * Also ensure that it has the caret and focus.
 */

error * menuedit_raise_window (MenuObjPtr menu)
{
    menu->window->behind = -1;
    ER ( swi (Wimp_OpenWindow,  R1, menu->window,  END) );
    return menuedit_focus_claim (menu);
}


/*
 * Load a menu from the the shell according to the RESED_OBJECT_LOAD message 'load'.
 * If 'menu' is NULL, then create a new MenuEdit window and load the
 * data into that.  If 'menu' is non-NULL, then overwrite it with the
 * new data - this is used when the Shell forces us to re-load a modified object
 * after messages are imported, etc.
 *
 * If an entry has the MENU_ENTRY_DOTTEDLINE set, then create a separator
 * entry after it.
 *
 * When creating the palette, we pass in a non-NULL menu structure with
 * the internal flag set, and "load" is passed in as NULL.
 */

error * menuedit_load (MenuObjPtr menu,
                       ResourceFileObjectTemplateHeaderPtr object,
                       MessageResEdObjectLoadPtr load)
{
    MenuTemplatePtr body = (MenuTemplatePtr) relocate_object (object);
    MenuEntryPtr entry, next, last;
    int i;
    error *err = NULL;
    char buf[100];
    Bool nodisplay;

    if (body == NULL)
        return error_lookup("CorruptMenu");

    /*
     * If this request to load is a result of a force-load of a menu which
     *  we do not already know about, then don't display it - it's a result
     *  of message import, and will be grabbed back and deleted forthwith.
     */

    nodisplay = menu == NULL && (load->flags & BIT(0)) != 0;

    if (menu)
    {
        /* Clear up the old information.  This entails deleting
         * any menu entries and their dboxes, if extant.  However the
         * old menu dbox can be left alive, and left open if it already is.
         * We will get it filled in again below.
         */

        for (entry = menu->entries; entry; entry = next)
        {
            next = entry->next;
            free_entry (entry);
        }
        free (menu->p.title); menu->p.title = NULL;
        free (menu->p.helpmessage);  menu->p.helpmessage = NULL;
    }
    else
    {
        /* Allocate a new menu structure */
        menu = (MenuObjPtr) calloc (1, sizeof(MenuObjRec));
        if (menu == NULL)
            return error_lookup ("NoMem");
    }

    if (menu->internal == FALSE)
        sprintf (menu->name, "%.*s", sizeof (menu->name) - 1, load->name);
    menu->p.flags = body->flags;
    menu->p.title = copystring ((char *) body->title);
    menu->p.maxtitle = body->maxtitle;
    gui_load_len_field (menu->p.title, &menu->p.maxtitle);
    menu->p.helpmessage = copystring ((char *) body->helpmessage);
    menu->p.maxhelp = body->maxhelp;
    menu->p.showevent = body->showevent;
    menu->p.hideevent = body->hideevent;
    gui_load_len_field (menu->p.helpmessage, &menu->p.maxhelp);

    if (menu->internal == FALSE)
    {
        menu->documentID = load->documentID;
        menu->objectID = load->objectID;
    }

    /* Now make all the entries */

    menu->numentries = menu->numselected = 0;
    menu->entries = last = NULL;

    for (i = 0; i < body->numentries; i++)
    {
        entry = (MenuEntryPtr) calloc (1, sizeof (MenuEntryRec));
        if (entry == NULL)
        {
            err = error_lookup ("NoMem");
            goto fail;
        }
        entry->p.flags = body->entries[i].flags;
        entry->p.componentID = body->entries[i].componentID;
        entry->p.text = copystring ((char *) body->entries[i].text);
        entry->p.maxtext = body->entries[i].maxtext;
        gui_load_len_field (entry->p.text, &entry->p.maxtext);
        entry->p.clickshow =
            copystring ((char *) (body->entries[i].clickshow));
        entry->p.submenushow =
            copystring ((char *) (body->entries[i].submenushow));
        entry->p.submenuevent = body->entries[i].submenuevent;
        entry->p.clickevent = body->entries[i].clickevent;
        entry->p.helpmessage = copystring ((char *) body->entries[i].helpmessage);
        entry->p.maxentryhelp = body->entries[i].maxentryhelp;
        gui_load_len_field (entry->p.helpmessage, &entry->p.maxentryhelp);
        entry->owner = menu;
        
        if (last)
            last->next = entry;
        else
            menu->entries = entry;
        last = entry;
        menu->numentries++;

        /* Append a separator entry if this has the dotted flag */

        if (last->p.flags & MENU_ENTRY_DOTTEDLINE)
        {
            entry = (MenuEntryPtr) calloc (1, sizeof (MenuEntryRec));
            if (entry == NULL)
            {
                err = error_lookup ("NoMem");
                goto fail;
            }
            entry->separator = TRUE;
            entry->owner = menu;
            last->next = entry;
            last = entry;
            menu->numentries++;
        }
    }

     /* If menu does not have a window yet, create it one of the right size and open it.
      * If it already has a window just do a forceredraw on it.  Also claim the
      * caret and focus.
      */

    if (menu->window == NULL)
    {
        static int lasty = -1;
        int workwidth, workheight;

        /* We now have all the information required to calculate the menu layout & size */
        menuedit_calculate_menu_size (menu, &workwidth, &workheight);

        if (menu->internal)
        {
            menu->window = palwin;
        }
        else
        {
            EG ( fail, wimp_copy_template (menuwinproto, &menu->window, menuwinsize) );
            
            /* 
             * Create windows in slightly different positions each time.
             */

            if (lasty == -1)
                lasty = menu->window->visarea.maxy;
            else
            {
                lasty -= 40;
                menu->window->visarea.maxy = lasty;
            }
        }

        menu->window->visarea.maxx = menu->window->visarea.minx + workwidth;
        menu->window->visarea.miny = menu->window->visarea.maxy - workheight;
        menu->window->workarea.maxx = menu->window->workarea.minx + workwidth;
        menu->window->workarea.miny = menu->window->workarea.maxy - workheight;
        menu->window->behind = -1;
        EG ( fail, swi (Wimp_CreateWindow,  R1, &menu->window->visarea,
                        OUT,  R0, &menu->window->handle,  END) );
        EG ( fail, registry_register_window (menu->window->handle, MenuEdit, (void *) menu) );

        if (!nodisplay)
        {
            EG ( fail, swi (Wimp_OpenWindow,  R1, menu->window,  END) );

            /*
             * If the final position of the window is different from the
             * one we tried for, then reset the 'marching windows' to the
             * initial position.
             */
            
            if (menu->internal == FALSE)
            {
                ER ( swi (Wimp_GetWindowState,  R1, menu->window,  END) );
                if (menu->window->visarea.maxy != lasty)
                    lasty = -1;
            }

            menuedit_focus_claim (menu);
        }
    }
    else
    {
        /* The window was already open.  Make sure that the extent is still
         * correct.
         */
        EG ( fail, menuedit_fix_extent (menu) );
    }

    /* Fix window titles.  The proto windows should have titles
     * like "Menu: %.12s".  The title max should be big enough
     * for the pattern and the longest possible resource name.
     */

    if (menu->internal == FALSE)
    {
        sprintf (buf, dbox_gettitle (menuwinproto), menu->name);
        (void) dbox_settitle (menu->window, buf, TRUE);
    }

    /* If there is a menu editing dbox already created, then update it */

    if (menu->dbox)
    {
        EG ( fail, props_update_menu_dbox (menu, TRUE, TRUE) );
    }

fail:
    if (err)
    {
        /* Piss in a pot.  We failed (probably out of memory).  Try to clean up
         * the mess we have made and pass the error back to the caller.
         * Caller will pass an error indication back to the shell.  Note: we have been
         * careful to ensure that the partial menu edifice that we now have
         * is consistent and will be freed correctly by the code in menuedit_close_menu().
         */

        if (menu)
        {
            (void) menuedit_close_menu (menu, FALSE);
        }
    }

    return err;
}


/*
 * Close the specified menu, removing all traces of it from our workspace, closing
 * associated dialogue boxes, etc.  If the Bool 'notifyshell' is TRUE, then notify
 * the shell (the data must already have been transferred back).
 *
 * This is not called for the palette.
 */

error * menuedit_close_menu (MenuObjPtr menu, Bool notifyshell)
{
    MenuEntryPtr entry = menu->entries;

    if (notifyshell)
    {
/*        dprintf ("MENU: notifying shell\n"); */
        ER ( protocol_send_resed_object_closed (menu) );
    }

    while (entry)
    {
        MenuEntryPtr next = entry->next;
        free_entry (entry);
        entry = next;
    }

    free (menu->p.title);
    free (menu->p.helpmessage);

    if (menu->window)
    {
        (void) registry_deregister_window (menu->window->handle);
        (void) swi (Wimp_DeleteWindow,  R1, menu->window,  END);
        free ((char *) menu->window);
    }
    if (menu->dbox)
    {
        (void) registry_deregister_window (menu->dbox->handle);
        (void) swi (Wimp_DeleteWindow,  R1, menu->dbox,  END);
        free ((char *) menu->dbox);
    }
    
    focus_giveup (menu->window->handle);
    free ((char *) menu);
    return NULL;
}


/*
 * The shell has informed us that this menu's name has changed.  Update the window's
 * titlebar and those of any dialogue boxes.
 */

error * menuedit_rename_menu (MenuObjPtr menu, char *name)
{
    char buf[100];
    MenuEntryPtr entry;
    sprintf (menu->name, "%.*s", sizeof (menu->name) - 1, name);

    sprintf (buf, dbox_gettitle (menuwinproto), menu->name);
    (void) dbox_settitle (menu->window, buf, TRUE);

    if (menu->dbox)
        ER ( props_update_menu_dbox (menu, FALSE, TRUE) );

    for (entry = menu->entries; entry; entry = entry->next)
    {
        if (entry->dbox)
        {
            ER ( props_update_entry_dbox (entry, FALSE, TRUE) );
        }
    }

    return menuedit_fix_extent (menu);
}


/*
 * Respond to an Open_Window_Request on a menu window
 */

error * menuedit_reopen_window (WindowPtr win, MenuObjPtr menu)
{
    menu->window->visarea = win->visarea;
    menu->window->scrolloffset = win->scrolloffset;
    menu->window->behind = win->behind;
    return swi (Wimp_OpenWindow, R1, menu->window, END);
}


/* 
 * Respond to close_window_request on a document window.
 * Note: the 'win' parameter is only a partial window structure
 * If the menu seems to be modified, then send its data back to
 * the shell, marking the menu as "pending close".
 * If it is unmodified then just close it.  In any case, tell the
 * shell that it has been closed.
 *
 * If this is the palette, just close the window (don't delete it).
 */

error * menuedit_close_window (MenuObjPtr menu)
{
    if (menu->internal)
        return swi (Wimp_CloseWindow,  R1, menu->window,  END);

    if (menu->modified)
    {
        /* Closing the menu is handled for us when the object is safely back with the shell */
        menu->pendingclose = TRUE;
        return protocol_send_resed_object_sending (menu);
    }
    else
    {
        return menuedit_close_menu (menu, TRUE);
    }
}


/*
 * Return the size in bytes that the specified menu will occupy when
 * saved as a ResourceFileObjectTemplateHeaderPtr for transfer to
 * the shell.
 */

int menuedit_object_size (MenuObjPtr menu, int *bodysize, int *stringsize,
                          int *msgsize, int *numrelocs)
{
    MenuEntryPtr entry;
    *bodysize = offsetof(MenuTemplateRec, entries);
    *stringsize = 0;
    *msgsize = 0;
    *numrelocs = 2;             /* Title and Help */

    if (menu->p.title)
        *msgsize += strlen (menu->p.title) + 1;
    if (menu->p.helpmessage)
        *msgsize += strlen (menu->p.helpmessage) + 1;

    for (entry = menu->entries; entry; entry = entry->next)
    {
        if (entry->separator)
            continue;           /* These occupy no extra space in the output */

        *bodysize += sizeof (MenuTemplateEntryRec);
        *numrelocs += 4;        /* Title, Clickshow, Submenushow and Help */
        if (entry->p.flags & MENU_ENTRY_ISSPRITE)
            *stringsize += entry->p.text ? strlen(entry->p.text) + 1 : 0;
        else
            *msgsize += entry->p.text ? strlen(entry->p.text) + 1 : 0;
        if (entry->p.clickshow)
            *stringsize += strlen (entry->p.clickshow) + 1;
        if (entry->p.submenushow)
            *stringsize += strlen (entry->p.submenushow) + 1;
        if (entry->p.helpmessage)
            *msgsize += strlen (entry->p.helpmessage) + 1;
    }

    *bodysize = (*bodysize + 3) & ~ 3;
    *stringsize = (*stringsize + 3) & ~ 3;
    *msgsize = (*msgsize + 3) & ~ 3;

    return sizeof (ResourceFileObjectTemplateHeaderRec) + *bodysize + *stringsize + *msgsize +
        sizeof(int) + *numrelocs * sizeof(RelocationRec);
}


/*
 * Save the specified menu to a pre-allocated block of memory as
 * ResourceFileObjectTemplateHeaderPtr ready for transfer to the
 * shell.  The block is expected to be big enough as measured
 * with menuedit_object_size().
 *
 * A note on relocations.  In order to make the "export/import messages"
 * facility as robust as possible, we always output a relocation record
 * for every potential message in the object, even those that are NULL.
 * NULL strings are represented by a relocation record that points to a
 * -1 word (the toolbox loader turns this into a NULL when it is relocated).
 * This ensures that the numbering won't be changed between message export
 * and import if changes have been made to the object's messages since the
 * messages were exported.
 */

error * menuedit_save_object_to_memory (MenuObjPtr menu, char *buffer,
                                        int bodysize, int stringsize, int msgsize, int numrelocs)
{
    ResourceFileObjectTemplateHeaderPtr object = (ResourceFileObjectTemplateHeaderPtr) buffer;
    MenuTemplatePtr body = (MenuTemplatePtr)
        (buffer + sizeof (ResourceFileObjectTemplateHeaderRec));
    int offset = sizeof (ResourceFileObjectTemplateHeaderRec) + bodysize;
    char *strings, *msgs, *stringbase, *msgbase;
    RelocationTablePtr reloctable;
    RelocationPtr relocs;
    MenuTemplateEntryPtr bodyentry, lastbodyentry = NULL;
    MenuEntryPtr entry;
    int numentries = 0;         /* can't use menu->numentries because it includes separators */

    object->stringtableoffset = stringsize ? offset : -1;
    offset += stringsize;
    object->messagetableoffset = msgsize ? offset : -1;
    offset += msgsize;
    object->relocationtableoffset = offset;

    strings = stringbase = buffer + object->stringtableoffset;
    msgs = msgbase = buffer + object->messagetableoffset;
    reloctable = (RelocationTablePtr) (buffer + object->relocationtableoffset);
    reloctable->numrelocations = numrelocs;
    relocs = reloctable->relocations;
    
    /* Enter the header data */

    object->hdr.class = MENU_OBJECT_CLASS;
    /* object->hdr.flags filled in by shell */
    object->hdr.version = MENU_OBJECT_VERSION;
    /* object->hdr.name filled in by shell */
    object->hdr.totalsize = sizeof (object->hdr) + bodysize + stringsize + msgsize;
    object->hdr.bodyoffset = (Offset) sizeof (object->hdr);  /* No gap before body*/
    object->hdr.bodysize = bodysize;

    /* Enter the top level menu data */
    body->flags = menu->p.flags;

    body->title = (Offset) (menu->p.title ? msgs - msgbase : -1);
    relocs->wordtorelocate = ((char *) &body->title  - (char *) body);
    relocs->directive = RELOCATE_MSGREFERENCE;
    relocs++;
    if (menu->p.title)
    {
        strcpy (msgs, menu->p.title);
        msgs += strlen (msgs) + 1;
    }
    body->maxtitle = menu->p.maxtitle;
    gui_save_len_field (menu->p.title, &body->maxtitle);

    body->helpmessage = (Offset) (menu->p.helpmessage ? msgs - msgbase : -1);
    relocs->wordtorelocate = ((char *) &body->helpmessage  - (char *) body);
    relocs->directive = RELOCATE_MSGREFERENCE;
    relocs++;
    if (menu->p.helpmessage)
    {
        strcpy (msgs, menu->p.helpmessage);
        msgs += strlen (msgs) + 1;
    }
    body->maxhelp = menu->p.maxhelp;
    gui_save_len_field (menu->p.helpmessage, &body->maxhelp);
    body->showevent = menu->p.showevent;
    body->hideevent = menu->p.hideevent;

    for (bodyentry = body->entries, entry = menu->entries; entry; entry = entry->next)
    {
        /* If this is a separator just set the appropriate flag on the previous output entry */
        if (entry->separator)
        {
            if (lastbodyentry)
                lastbodyentry->flags |= MENU_ENTRY_DOTTEDLINE;
            continue;
        }

        numentries++;

        bodyentry->flags = entry->p.flags & ~MENU_ENTRY_DOTTEDLINE;
        bodyentry->componentID = entry->p.componentID;

        if (entry->p.text)
        {
            if (entry->p.flags & MENU_ENTRY_ISSPRITE)
            {
                bodyentry->text = (Offset) (strings - stringbase);
                strcpy (strings, entry->p.text);
                strings += strlen (strings) + 1;
            }
            else
            {
                bodyentry->text = (Offset) (msgs - msgbase);
                strcpy (msgs, entry->p.text);
                msgs += strlen (msgs) + 1;
            }
        }
        else
            bodyentry->text = (Offset) -1;
        
        relocs->wordtorelocate = ((char *) &bodyentry->text  - (char *) body);
        relocs->directive = entry->p.flags & MENU_ENTRY_ISSPRITE ?
            RELOCATE_STRINGREFERENCE : RELOCATE_MSGREFERENCE;
        relocs++;

        bodyentry->maxtext = entry->p.maxtext;
        gui_save_len_field (entry->p.text, &bodyentry->maxtext);

        if (entry->p.clickshow)
        {
            bodyentry->clickshow = (Offset) (strings - stringbase);
            strcpy (strings, entry->p.clickshow);
            strings += strlen (strings) + 1;
        }
        else
            bodyentry->clickshow = (Offset) -1;
        relocs->wordtorelocate = ((char *) &bodyentry->clickshow  - (char *) body);
        relocs->directive = RELOCATE_STRINGREFERENCE;
        relocs++;

        if (entry->p.submenushow)
        {
            bodyentry->submenushow = (Offset) (strings - stringbase);
            strcpy (strings, entry->p.submenushow);
            strings += strlen (strings) + 1;
        }
        else
            bodyentry->submenushow = (Offset) -1;
        relocs->wordtorelocate = ((char *) &bodyentry->submenushow  - (char *) body);
        relocs->directive = RELOCATE_STRINGREFERENCE;
        relocs++;

        bodyentry->submenuevent = entry->p.submenuevent;
        bodyentry->clickevent = entry->p.clickevent;
        
        if (entry->p.helpmessage)
        {
            bodyentry->helpmessage = (Offset) (msgs - msgbase);
            strcpy (msgs, entry->p.helpmessage);
            msgs += strlen (msgs) + 1;
        }
        else
            bodyentry->helpmessage = (Offset) -1;
        relocs->wordtorelocate = ((char *) &bodyentry->helpmessage  - (char *) body);
        relocs->directive = RELOCATE_MSGREFERENCE;
        relocs++;

        bodyentry->maxentryhelp = entry->p.maxentryhelp;
        gui_save_len_field (entry->p.helpmessage, &bodyentry->maxentryhelp);

        lastbodyentry = bodyentry++;            /* Move on to the next output entry */
    }

    body->numentries = numentries;
    return NULL;
}


/*
 * Keyboard shortcuts
 */

error * menuedit_key_pressed (MenuObjPtr menu, KeyPressPtr key, Bool *consumed)
{
    error *err = NULL;

    *consumed = FALSE;

    if (key->code == key_selectall)
        err = set_or_clear_selection (menu, TRUE);
    else if (key->code == key_clearsel)
        err = set_or_clear_selection (menu, FALSE);

    /* only ^A and ^Z are allowed in the palette window */
    else if (menu->internal)
        return NULL;

    else if (key->code == key_delete)
    {
        if (menu->numselected > 0)
            err = delete_selection (menu);
    }
    else if (key->code == key_menuprops)
        err = props_open_menu_dbox (menu);
    else if (key->code == key_entryprops)
    {
        if (menu->numselected == 1)
        {
            MenuEntryPtr entry;
            for (entry = menu->entries; entry; entry = entry->next)
                if (entry->selected)
                {
                    err = props_open_entry_dbox (menu, entry);
                    break;
                }
        }
    }
    else
        return NULL;

    /* key press has been processed */
    *consumed = TRUE;

    /* cancel any foreground interaction in progress (eg menu) */
    interactor_cancel ();

    return err;
}


/*
 * The Wimp's system font has changed.  Recalculate sizes and
 * window extents accordingly.
 */

error * menuedit_font_changed ()
{
    int i = 0;
    RegistryType type;
    void *closure;
    while ((i = registry_enumerate_windows (i, &type, NULL, &closure)) != 0)
    {
        if (type == MenuEdit)
        {
            ER ( menuedit_fix_extent ((MenuObjPtr) closure) );
        }
    }
    return NULL;
}


/*
 * Check the specified menu to see whether it has any invalid separator entries,
 * perhaps after some entries have been added or deleted.  A separator is invalid if
 * it occurs at the beginning of the menu, or if it immediately follows another separator.
 * Remove any such invalid separators.  The caller is responsible for calling
 * menuedit_fix_extent() to recalculate layout.
 */

void menuedit_canonicalise (MenuObjPtr menu)
{
    MenuEntryPtr entry, next, last = NULL;

    for (entry = menu->entries; entry; entry = next)
    {
        next = entry->next;

        if (entry->separator)
        {
            /* Is this the first entry? */
            if (last == NULL)
            {
                menu->entries = next;
                if (entry->selected)
                    menu->numselected--;
                free_entry (entry);
                menu->numentries--;
            }
            /* Was the last entry a separator? */
            else if (last->separator)
            {
                last->next = next;
                if (entry->selected && !last->selected)
                    last->selected = TRUE;
                else if (entry->selected)
                    menu->numselected--;
                free_entry (entry);
                menu->numentries--;
            }
            else
                last = entry;
        }
        else
            last = entry;
    }
}
            

/*
 * The string for an entry has changed, or entries have been added or deleted.
 *
 * Look at the menu and determine whether the spacing
 * of keyboard shortcuts must be altered to make everything line
 * up again.  If so, jiggle them and fix up any entry dialogues that need changing
 * (only the maximum length will have changed).  It is assumed that the caller
 * will get the menu window size recalculated and the window redisplayed.
 */

error * menuedit_justify_keycuts (MenuObjPtr menu)
{
    MenuEntryPtr entry;
    int width = -1;
    char *key, *padding;

    /* Determine width in chars.  Entries without keycuts are simply
     * counted with strlen.  Entries with keycuts are counted as having
     * just two spaces between the label and the keycut, regardless of
     * how many are actually there.
     */

    for (entry = menu->entries; entry; entry = entry->next)
    {
        int length;
        char *entrytext = (entry->p.text) ? entry->p.text : "";

        if (entry->separator)
            continue;
        if (entry->p.flags & MENU_ENTRY_ISSPRITE)
            continue;
        key = menuedit_find_keyname (entrytext, &padding);
        if (key == NULL)
            length = strlen (entrytext);
        else
            length = (padding - entrytext) + 2 + strlen (key);
        if (length > width)
            width = length;
    }

    /* Now pad out all textual entries that have a keycut so that they are
     * all width characters long.  Leave other entries alone.
     */
            
    for (entry = menu->entries; entry; entry = entry->next)
    {
        char *entrytext = (entry->p.text) ? entry->p.text : "";

        if (entry->separator)
            continue;
        if (entry->p.flags & MENU_ENTRY_ISSPRITE)
            continue;
        key = menuedit_find_keyname (entrytext, &padding);
        if (key)
        {
            char *newval, *p;
            int i, numspcs = width - ((padding - entrytext) + strlen (key));
            if (entry->p.maxtext < width + 1)
                entry->p.maxtext = width + 1;
            p = newval = malloc (width + 1);
            if (newval == NULL)
                return error_lookup ("NoMem");
            strncpy (p, entrytext, padding - entrytext);
            p += padding - entrytext;
            for (i = 0; i < numspcs; i++)
                *p++ = ' ';
            strcpy (p, key);
            free (entry->p.text);
            entry->p.text = newval;

            if (entry->dbox)
            {           
                ER ( props_update_entry_dbox (entry, TRUE, FALSE) );
            }
        }
    }
    return NULL;
}


/*
 * Create (if necessary) and open the palette.
 */

error * menuedit_open_palette ()
{
    if (palette)
    {
        /* Palette already created.  Just open the window */
        palette->window->behind = -1;
        return swi (Wimp_OpenWindow,  R1, palette->window,  END);
    }
    else
    {
        /* Read in palette data and create and open the window */
        char filename[FILENAMELEN], *buf;
        FILE *file;
        int size, off;
        ResourceFileHeaderPtr hdr;
        MenuEntryPtr entry;
        error *err = NULL;

        sprintf (filename, "%s.%s", appdir, "Palette");
        file = fopen (filename, "r");
        if (file == NULL)
            return error_lookup ("CantRead", filename);

        fseek(file, 0, SEEK_END);
        size = (int) ftell(file);
    
        buf = calloc(size, sizeof(char));
        if (!buf)
        {
            fclose (file);
            return error_lookup("NoMem");
        }

        fseek (file, 0, SEEK_SET);
        fread (buf, sizeof(*buf), size, file);
        fclose (file);

        hdr = (ResourceFileHeaderPtr) buf;
        off = hdr->objectoffset;
    
        if (hdr->fileid != ('F' << 24 | 'S' << 16 | 'E' << 8 | 'R')
           || off == -1)
        {
            free (buf);
            return error_lookup("CantRead", filename);
        }

        palette = (MenuObjPtr) calloc (1, sizeof (MenuObjRec));
        palette->internal = TRUE;

        /* The following leaves the windoow open */

        err = menuedit_load (palette, (ResourceFileObjectTemplateHeaderPtr) (buf + off), NULL);
        if (err)
        {
            free (palette);
            palette = NULL;
        }
                
        /* Fix all the component IDs in the palette at -1.  This would
         * normally be invalid but we allow the menu to be like this
         * to ensure that component IDs in a new menu get created incrementally
         */

        for (entry = palette->entries; entry; entry = entry->next)
            entry->p.componentID = -1;

        free (buf);
        return err;
    }
}


/*
 * Generate a suitable interactive help message for the editing window.
 * The pointer is at position 'mouse', and the text should be stored at
 *  'reply'.
 * Called from help_message(..).
 * Returns TRUE iff help text has been located.
 */

Bool menuedit_help_text (
    MenuObjPtr menu,
    PointPtr mouse,
    char *reply
)
{
    MenuEntryPtr entry;
    Bool titlebar = FALSE;
    char *token;
    char buf[MAX_HELP_TEXT];

    /* convert mouse position to work area coordinates */
    wimp_convert_point (ScreenToWork, menu->window, mouse, mouse);

    /* before asking where the pointer is */
    entry = click_in_entry (menu, mouse);
    if (entry == NULL)
        titlebar = click_in_titlebar (menu, mouse);

    if (menu->internal)      /* palette window */
    {
        if (entry == NULL)   /* pointer on background */
            return help_lookup_token ("Hlp.P", reply, MAX_HELP_TEXT);

        /* pointer over menu entry or separator */
        token = (entry->separator) ? "Hlp.PS" : "Hlp.PE";
        if (!help_lookup_token (token, reply, MAX_HELP_TEXT))
            return FALSE;

        token = (entry->selected) ? "Hlp.PIS" : "Hlp.PIN";
        return help_lookup_token (token, reply + strlen (reply),
                                 MAX_HELP_TEXT - strlen (reply));
    }

    else                      /* editing window */
    {
        if (titlebar)         /* pointer over menu's title */
            return help_lookup_token ("Hlp.MT", reply, MAX_HELP_TEXT);

        if (entry == NULL)    /* pointer on background */
            return help_lookup_token ("Hlp.E", reply, MAX_HELP_TEXT);

        /* pointer over menu entry or separator */
        token = (entry->separator) ? "Hlp.ES" : "Hlp.EE";
        if (!help_lookup_token (token,
                                (entry->separator) ? reply : buf,
                                MAX_HELP_TEXT))
            return FALSE;
        if (!entry->separator)
            sprintf (reply, buf, entry->p.componentID);

        token = (entry->selected) 
                   ? ( (entry->separator) ? "Hlp.ESS" : "Hlp.EES" )
                   : ( (entry->separator) ? "Hlp.ESN" : "Hlp.EEN" );
        return help_lookup_token (token, reply + strlen (reply),
                                 MAX_HELP_TEXT - strlen (reply));
    }
}
