
-----------------------------------------------------------------------------

From nicko@ant.co.uk
Date: Thu, 04 Jul 1996 19:18:07 +0100 (BST)
From: "Dr. Nicko van Someren" <nicko@ant.co.uk>
To: David Fell <borris@ant.co.uk>
Subject: Table formatting

Borris,
	OK, I think I now belive that we can correctly format tables in only
2 passes with only a medium amount of state kept between the passes (small
enough to be put in the table item).  This method seems to work on all the
examples that Peter and I could come up with.

	In the following discussion it is assumed that we are at the deapest
nesting level. If we are not then we need to have done this process on every
sub-table already and when calculating the minimum width of a stream the
table must be assumed to be the mimimum width and when doing the maximum it
is assumed to be the maximum.  It will also be neccessary to set the width of
sub-tables to some 'correct' value before the table is layed out.  OK, here
goes:

	1) Work out the maximum and minimum widths it is worth making each
stream in the table when wholly unconstrained.  As I mentioned above this
uses the widest setting for subtables when doing the max and the narrowest
setting when doing the min.

	2) For cells with absolute widths set both the min and max widths to
be the higher of the specified witdh and the min calculated width.  

	3) Within each row, for each boundary between columns work out the
lowest and highest percentage across the table that this boundary could occur
at. This can be done by working left to right for the minimums and right to
left for the maximums, assuming every cell that is not given a percentage
width has zero percent and then summing up the percentages as you move across
the row.  Care should be taken to deal with the case where a leftmost or
rightmost cell of a row has a percentage given as this constrain both the
hightest and lowest values that the adjacent boundary could end up at.

	4) Resolve confilicts in the row information given above boundaries.
This means if the sums of the percentages come ot over 100 in any given row
then all the numbers need to be scaled down, if the total if very close to
100% then some evasive action is needed to stop the table looking stupid and
if the lowest and highest percentages that any give boundary should have are
the wrong way around then both values should be given some half way value.

	5) For each column boundary, examin the results from the previous
stage and work out high and low percentage values for where the boundary can
lie.  Again, conflicts may need to be resolved in badly specified tables.

	6) For each cell that has a relative width, divide the min stream
widths by the relative size and calculate the maximum value for the minimum
widths of a '1*' width. Do the same for the max widths of the streams.  Go
through the cells with relative widths again rewriting the min and max widths
as the specified relative width times these new values.

	7) For each cell with a relative width examin the high and low
percentage values for the boundaries at each end to determin the highest and
lowest pecgentage widths the cell could have.  Divide these values by the
relative with for the given cell and over the set of cells determine the
highest and lowest percentages a unit of '1*' could take.  Given the highest
and lowest posable values choose a value to give to a unit of '1*' (say, half
way between the bounds) and rewrite the widths for each relative width cell
as a percentage.

	8) For each cell with a percentage width check that the width lies
within the constraint percentages arrived at in (4) and resolve the conflicts
by forcing the column boundary percentage to lie half way between the high
and low and then forcing the percentage for the cell to be the difference
between the values for the boundaries at each end.

	9) For each cell with a percentage width take its min width and
divide it by the percentage width and take the maximum of these over the set
of cells with percentage widths.  Do the same for the maximum widths.  This
gives candidate values for the min and max widths of 1%.

	10) For each row sum the precentages given in cells with specified
percentages (this now includes the relative width cells too).  Then sum the
min widths of the cells that do not have given percentage widths.  Divide sum
of min widths by 100-(sum of percentages); if this value is bigger than the
cadidate min for 1% then take this value as the new candidate.  Do the same
for the max widths in each non-percentage cell.

At this stage we have a minimum and maximum values for the width taken up by
1% of a table and we have a set of mimimum and maximum percentage positions
at which each column boundary can lie.  We can now return the mimimum and
maximum width values for this table, they are just 100 times the min and max
widths for 1%.  Before we dispose of all this wonderful state I suggest that
we do one more thing, resolve the relative positions for the column
boundaries.  I am still thinking about exactly how to do this but I need to
go home now.  We do however have some good constraints now as to where these
boundaries can be so we should be able to simple make a guess (e.g. half way
between where the contraints will allow) and as long as we propagate any
effects that any of our choices force we should be OK.  If we can resolve
at this stage the percentage positions of the column boundaries then
the final formatting of the table will be very easy indeed.

	Nicko

-- 
Dr. Nicko van Someren.      Vox:(44)(1223) 567808     Fax:(44)(1223) 567801
mailto:nicko@ant.co.uk                          http://www.ant.co.uk/~nicko

-----------------------------------------------------------------------------

A column group may be empty and have no associated columns. 

The implied column group in the absence of both <COLGROUP>
and <COL> needs to cover all columns, whereas normally it
would cover none (if just automatic insertion was used).

Forms of column specification we can see, after the parser has done
whatever element insertion it chooses.


<TABLE><COLGROUPSECTION><COLGROUP>...
<TABLE><COLGROUPSECTION><COLGROUP><COL><COL>...
<TABLE COLS=N><COLGROUPSECTION><COLGROUP>...
<TABLE COLS=N><COLGROUPSECTION><COLGROUP><COL><COL>...


<TABLE RULES=ROWS><COLGROUP SPAN=4>
<TD>Cell one
<TD>Cell two
<TD>Cell three
<TD>Cell four
<TD>Extra cell one
<TD>Extra cell two
</table>



=============================================================================
SPARE CODE


/*****************************************************************************

  5) For each column boundary, examin the results from the previous
  stage and work out high and low percentage values for where the
  boundary can lie.  Again, conflicts may need to be resolved in badly
  specified tables.

  */

#if 0
static void assign_column_percent_boundaries(rid_table_item *table)
{
    int x, y;
    rid_table_cell *cell;

    TABDBG(("assign_column_percent_boundaries()\n"));

    for (x = -1, y = 0; (cell = rid_next_root_cell(table, &x, &y)) != NULL; )
    {
	rid_table_colhdr *colhdr = &table->colhdrs[x];

	if ( (cell->flags & rid_cf_PERCENT) != 0 )
	{
	    if (colhdr->minpct == NO_PCT || cell->minpct > colhdr->minpct)
	    {
		TABDBG(("rid_size_table(): raising minpct for column %d from %d to %d\n",
			x, colhdr->minpct, cell->minpct));
		colhdr->minpct = cell->minpct;
	    }
	    
	    if (colhdr->maxpct == NO_PCT || cell->maxpct < colhdr->maxpct)
	    {
		TABDBG(("rid_size_table(): lowering maxpct for column %d from %d to %d\n",
			x, colhdr->maxpct, cell->maxpct));
		colhdr->maxpct = cell->maxpct;
	    }
	}
    }
}
#endif

#if 0
static int find_cells_rhs_min_percentage(rid_table_item *table, rid_table_cell *cell)
{
    TABDBG(("find_cells_rhs_min_percentage(): cell (%d, %d)\n", cell->cell.x, cell->cell.y));
    return 0;
}

static int find_cells_rhs_max_percentage(rid_table_item *table, rid_table_cell *cell)
{
    TABDBG(("find_cells_rhs_max_percentage(): cell (%d, %d)\n", cell->cell.x, cell->cell.y));
    return 100;
}
	    
#endif

/*****************************************************************************

  7) For each cell with a relative width examin the high and low
  percentage values for the boundaries at each end to determin the
  highest and lowest pecgentage widths the cell could have.  Divide
  these values by the relative with for the given cell and over the
  set of cells determine the highest and lowest percentages a unit of
  '1*' could take.  Given the highest and lowest posable values choose
  a value to give to a unit of '1*' (say, half way between the bounds)
  and rewrite the widths for each relative width cell as a percentage.

  */

#if 0
static void assign_rel_width_boundaries(rid_table_item *table)
{
    int x, y;
    rid_table_cell *cell;
    int mink = INT_MAX, maxk = 0, avg;

    for (x = -1, y = 0; (cell = rid_next_root_cell(table, &x, &y)) != NULL;  )
    {
	if ( (cell->flags & rid_cf_RELATIVE) != 0 )
	{
	    rid_table_colhdr *colhdr = &table->colhdrs[x];
	    int min = colhdr->minpct, max = colhdr->maxpct;
	    int z;
	    VALUE width;

	    rid_getprop(table, x, y, rid_PROP_WIDTH, &width);

	    ASSERT(min != NO_PCT);
	    ASSERT(max != NO_PCT);

	    max = find_cells_rhs_min_percentage(table, cell) - max;
	    min = find_cells_rhs_max_percentage(table, cell) - min;
	    
	    ASSERT(min >= 0 && min <= 100);
	    ASSERT(max >= 0 && max <= 100);

	    z = min / width.u.f;
	    if ( z < mink )
		mink = z;
	    z = max / width.u.f;
	    if ( x > maxk )
		maxk = z;
	}
    }

    TABDBG(("assign_rel_width_boundaries(): mink %d, maxk %d\n", mink, maxk));

    avg = (mink + maxk) / 2;

    for (x = -1, y = 0; (cell = rid_next_root_cell(table, &x, &y)) != NULL;  )
    {
	if ( (cell->flags & rid_cf_RELATIVE) != 0 )
	{
	    cell->minpct = (cell->stream.width_info.minwidth * 100) / avg;
	    cell->maxpct = (cell->stream.width_info.maxwidth * 100) / avg;
	}
    }
}
#endif

/*****************************************************************************

  9) For each cell with a percentage width take its min width and
  divide it by the percentage width and take the maximum of these over
  the set of cells with percentage widths.  Do the same for the
  maximum widths.  This gives candidate values for the min and max
  widths of 1%.

  */

#if 0
static void calc_1_percent_candidates(rid_table_item *table)
{
    int min1 = 0, max1 = INT_MAX, x, y;
    rid_table_cell *cell;

    for (x = -1, y = 0; (cell = rid_next_root_cell(table, &x, &y)) != NULL;  )
    {
	if ( (cell->flags & rid_cf_PERCENT) != 0 )
	{
	    VALUE width;
	    double d;

	    rid_getprop(table, x, y, rid_PROP_WIDTH, &width);
	    d = (int) ceil(cell->minabs / width.u.f);
	    if (d > min1)
		min1 = d;
	    d = (int) ceil(cell->maxabs / width.u.f);
	    if (d < max1)
		max1 = d;
	}
    }

    TABDBG(("calc_1_percent_candidates(): min_cand %d, max_cand %d\n", min1, max1));
    table->min_cand = min1;
    table->max_cand = max1;
}
#endif

/*****************************************************************************

  8) For each cell with a percentage width check that the width lies
  within the constraint percentages arrived at in (4) and resolve the
  conflicts by forcing the column boundary percentage to lie half way
  between the high and low and then forcing the percentage for the
  cell to be the difference between the values for the boundaries at
  each end.

  I might have done some of this to the wrong things - I can't be
  certain.  

  */

#if 0
static void check_percent_boundaries(rid_table_item *table)
{
    int x, y;
    rid_table_cell *cell;

    TABDBG(("check_percent_boundaries()\n"));

    for (x = -1, y = 0; (cell = rid_next_root_cell(table, &x, &y)) != NULL; )
    {
	rid_table_colhdr *colhdr = &table->colhdrs[x];

	if (cell->minpct == NO_PCT)
	{
	    ASSERT(cell->maxpct == NO_PCT);
	    continue;
	}

	ASSERT(cell->maxpct != NO_PCT);

	if (cell->minpct < colhdr->minpct || cell->maxpct > colhdr->maxpct)
	{
	    TABDBG(("check_percent_boundaries(): (%d,%d) strays from column: [%d,%d] v [%d,%d]\n",
		    x, y, cell->minpct, cell->maxpct, colhdr->minpct, colhdr->maxpct));

	    if (cell->minpct < colhdr->minpct)
		cell->minpct = colhdr->minpct;

	    if (cell->maxpct > colhdr->maxpct)
		cell->maxpct = colhdr->maxpct;

	    /* FIXME: WRITE SOMETHING HERE! */
	}
    }
}
#endif

/*****************************************************************************

  10) For each row sum the precentages given in cells with specified
  percentages (this now includes the relative width cells too).  Then
  sum the min widths of the cells that do not have given percentage
  widths.  Divide sum of min widths by 100-(sum of percentages); if
  this value is bigger than the cadidate min for 1% then take this
  value as the new candidate.  Do the same for the max widths in each
  non-percentage cell.

  */

#if 0
static void get_1_percent_values(rid_table_item *table)
{
#if 0
    for (y = 0; y < table->cells.y; y++)
    {
	for (x = 0; x < table->cells.x; x++)
	{
	    rid_table_cell *cell = *CELLFOR(table, x, y);
	    if (cell == NULL || x != cell->cell.x || y != cell->cell.y)
		continue;
	    
    }
#endif
}
#endif

#if 0
static void get_final_min_max(rid_table_item *table)
{

}
#endif


/*****************************************************************************

  4) Resolve confilicts in the row information given above boundaries.
  This means if the sums of the percentages come ot over 100 in any
  given row then all the numbers need to be scaled down, if the total
  if very close to 100% then some evasive action is needed to stop the
  table looking stupid and if the lowest and highest percentages that
  any give boundary should have are the wrong way around then both
  values should be given some half way value.

  */

#if 0
static void resolve_cell_percent_conflicts(rid_table_item *table)
{
    int y;

    TABDBG(("resolve_cell_percent_conflicts():\n"));

    for (y = 0; y < table->cells.y; y++)
    {
	int x, smin = 0, smax = 0;

	for (x = 0; x < table->cells.x; x++)
	{
	    rid_table_cell *cell = *CELLFOR(table, x, y);

	    if ( cell != NULL && 
		 (cell->flags & rid_cf_PERCENT) != 0)
	    {

		smin += cell->minpct;
		smax += cell->maxpct;

		if (cell->minpct > cell->maxpct )
		{
		    const unsigned char z = (cell->minpct + cell->maxpct) / 2;
		    TABDBG(("resolve_cell_percent_conflicts(): averaging min/max %% for (%d,%d)\n", x,y));
		    ASSERT(cell->minpct != NO_PCT);
		    ASSERT(cell->maxpct != NO_PCT);
		    cell->minpct = z;
		    cell->maxpct = z;
		}
	    }
	}

#if 0
	if (smin == 99)
	{
	    TABDBG(("resolve_cell_percent_conflicts(): used 99%% - rounding to 100%%\n"));
	    /* FIXME: not quite certain how to allocate this */
	}
	else if (smin > 100)
	{
	    const double k = 100.0 / smin;
	    TABDBG(("resolve_cell_percent_conflicts(): used %d%% - scaling to 100%%\n", smin));

	    /* FIXME: This should then check that we've got precisely 100% used */
	    for (x = 0; x < table->cells.x; x++)
	    {
		rid_table_cell *cell = *CELLFOR(table, x, y);
		
		if ( cell != NULL && 
		     (cell->flags & rid_cf_PERCENT) != 0)
		{
		    cell->minpct *= k;
		    cell->maxpct *= k;
		}
	    }
	}
#endif
    }
}
#endif

/*****************************************************************************

  This deviates from Nicko's original algorithm.

  All columns are now assigned some min/max percentage values. Any
  conflicts need resolving.

  

  From this complete column header percentages information, we can
  work out a min/max value for any cell - this is the sum of min/max
  for all the columns the cell covers.

  */

#if 0
static void ensure_column_percent_boundaries(rid_table_item *table)
{
    int x, y, last;
    rid_table_colhdr *colhdr;
    rid_table_cell *cell;

    TABDBG(("ensure_column_percent_boundaries()\n"));

    for (x = table->cells.x - 1, last = 100, colhdr = &table->colhdrs[x];
	 x >= 0;
	 x--, colhdr--)
    {
	if (colhdr->maxpct == NO_PCT || colhdr->maxpct > last)
	{
	    colhdr->maxpct = last;
	}
	else
	{
	    last = colhdr->maxpct;
	}
    }

    for (x = 0, last = 0, colhdr = &table->colhdrs[0];
	 x < table->cells.x;
	 x++, colhdr++)
    {
	if (colhdr->minpct == NO_PCT || colhdr->minpct < last)
	{
	    colhdr->minpct = last;
	}
	else
	{
	    last = colhdr->minpct;
	}
	
	if (colhdr->minpct > colhdr->maxpct)
	{
	    const unsigned char z = colhdr->minpct;
	    TABDBG(("ensure_column_percent_boundaries(): swap min/max pct, column %d\n", x));
	    colhdr->minpct = colhdr->maxpct;
	    colhdr->maxpct = z;
	}
    }

    /* Process in vertical strips working rightwards */

    for (x = 0; x < table->cells.x; x++)
    {
	for (y = 0; y < table->cells.y; y++)
	{
	    VALUE width;
	    int w, d, q, z, c;
	    rid_table_cell *cell = *CELLFOR(table, x, y);

	    if (cell == NULL || (cell->flags & rid_cf_PERCENT) == 0 ||
		cell->cell.x != x || cell->cell.y != y  )
		continue;

	    rid_getprop(table, x, y, rid_PROP_WIDTH, &width);

	    w = (int) ceil(width.u.f);
	    c = x + cell->span.x;

	    TABDBG(("ensure_column_percent_boundaries(): (%d,%d) width %d to col %d\n",
		    x, y, w, c));

	    for (q = x + 1, z = table->colhdrs[x].sumpct; q < c && q < table->cells.x; q++)
	    {
		if ( table->colhdrs[q].sumpct < z )
		{
		    TABDBG(("ensure_column_percent_boundaries(): bump col %d to sum %d\n", q, z));
		    table->colhdrs[q].sumpct = z;
		}
	    }

	    w += z;

	    if (c < table->cells.x && table->colhdrs[c].sumpct < w)
	    {
		TABDBG(("ensure_column_percent_boundaries(): col after span %d to %d\n", c, w));
		table->colhdrs[c].sumpct = w;
	    }

	    for (q = c + 1; q < table->cells.x; q++)
	    {
		if (table->colhdrs[q].sumpct >= w)
		    break;
		table->colhdrs[q].sumpct = w;
	    }
	}
	
    }

}

static void resolve_column_percent_boundaries(rid_table_item *table)
{
    int x, last;
    rid_table_colhdr *colhdr;

    TABDBG(("resolve_column_percent_boundaries()\n"));

    for (x = 0, last = 0, colhdr = &table->colhdrs[0];
	 x < table->cells.x;
	 x++, colhdr++)
    {	
	if (colhdr->minpct != NO_PCT &&
	    colhdr->maxpct != NO_PCT &&
	    colhdr->minpct > colhdr->maxpct)
	{
	    const unsigned char z = colhdr->minpct;
	    TABDBG(("resolve_column_percent_boundaries(): swap min/max pct, column %d\n", x));
	    colhdr->minpct = colhdr->maxpct;
	    colhdr->maxpct = z;
	}
    }


}
#endif

/*****************************************************************************

  6) For each cell that has a relative width, divide the min stream
  widths by the relative size and calculate the maximum value for the
  minimum widths of a '1*' width. Do the same for the max widths of
  the streams.  Go through the cells with relative widths again
  rewriting the min and max widths as the specified relative width
  times these new values.

  */

#if 0
static void spread_min_max_rel_width(rid_table_item *table)
{
    int x = -1, y = 0;
    rid_table_cell *cell = rid_next_root_cell(table, &x, &y);
    double mink = 0.0, maxk = 0.0;

    while ( (cell = rid_next_root_cell(table, &x, &y)) != NULL )
    {
	if ( (cell->flags & rid_cf_RELATIVE) != 0 )
	{
	    VALUE width;
	    float f;
	    rid_getprop(table, x, y, rid_PROP_WIDTH, &width);
	    f = cell->stream.width_info.minwidth / width.u.f;
	    if (f > mink)
		mink = f;
	    f = cell->stream.width_info.maxwidth / width.u.f;
	    if (f > maxk)
		maxk = f;
	}
    }

    for (x = -1, y = 0; (cell = rid_next_root_cell(table, &x, &y)) != NULL; )
    {
	if ( (cell->flags & rid_cf_RELATIVE) != 0 )
	{
	    VALUE width;
	    rid_getprop(table, x, y, rid_PROP_WIDTH, &width);
	    cell->stream.width_info.minwidth = (int) ( mink / width.u.f );
	    cell->stream.width_info.maxwidth = (int) ( maxk / width.u.f );
	}
	
    }

}
#endif

#if 0
static void spread_min_rel_width(rid_table_item *table)
{

}
#endif

/*****************************************************************************
  
  3) Within each row, for each boundary between columns work out the
  lowest and highest percentage across the table that this boundary
  could occur at. This can be done by working left to right for the
  minimums and right to left for the maximums, assuming every cell
  that is not given a percentage width has zero percent and then
  summing up the percentages as you move across the row.  Care should
  be taken to deal with the case where a leftmost or rightmost cell of
  a row has a percentage given as this constrain both the hightest and
  lowest values that the adjacent boundary could end up at.

  */

#if 0
static void sum_max_percents(rid_table_item *table)
{
    int y;

    for (y = 0; y < table->cells.y; y++)
    {
	int smax = 100, x;

	TABDBG(("sum_max_percents(): Summing minimum percentages for row %d\n", y));

	for (x = table->cells.x - 1; x >= 0; x--)
	{
	    rid_table_cell *cell = *CELLFOR(table, x, y);

	    if (cell == NULL)
	    {
		TABDBG(("sum_max_percents(): cell (%d,%d) is empty\n", x, y));
		continue;
	    }
	    if ( cell->cell.x != x || cell->cell.y != y )
	    {
		TABDBG(("sum_max_percents(): cell (%d,%d) isn't a root cell\n", x, y));
		continue;
	    }
	    if ( (cell->flags & rid_cf_PERCENT) == 0 )
	    {
		TABDBGN(("sum_max_percents(): cell (%d,%d) isn't percentage based\n", x, y));
		continue;
	    }

	    smax -= cell->maxpct;
	    cell->maxpct = smax;

	    TABDBG(("sum_max_percents(): cell (%d,%d) given maxpct %d\n", x, y, cell->maxpct));
	}

	if (smax != 0)
	{
	    TABDBG(("sum_max_percents(): row %d needs attention: sum %d\n", y, smax));
	}
    }

}

static void sum_min_percents(rid_table_item *table)
{
    int y;
    int *list = mm_calloc(table->cells.x, sizeof(int));

    for (y = 0; y < table->cells.y; y++)
    {
	int smin = 0, x;

	TABDBG(("sum_min_percents(): Summing minimum percentages for row %d\n", y));

	for (x = 0; x < table->cells.x; x++)
	{
	    rid_table_cell *cell = *CELLFOR(table, x, y);
	    int z;

	    if (cell == NULL)
	    {
		TABDBG(("sum_min_percents(): cell (%d,%d) is empty\n", x, y));
		continue;
	    }
	    if ( cell->cell.x != x || cell->cell.y != y )
	    {
		TABDBG(("sum_min_percents(): cell (%d,%d) isn't a root cell\n", x, y));
		continue;
	    }
	    if ( (cell->flags & rid_cf_PERCENT) == 0 )
	    {
		TABDBGN(("sum_min_percents(): cell (%d,%d) isn't percentage based\n", x, y));
		continue;
	    }

	    /* IE 1st cell gets zero here */
	    z = cell->minpct;
	    /*if (smin > 0)*/ cell->minpct = smin;
	    smin += z;

	    TABDBG(("sum_min_percents(): cell (%d,%d) given minpct %d\n", x, y, cell->minpct));
	}

	if (smin != 100)
	{
	    TABDBG(("sum_min_percents(): sum %d: row %d needs attention\n", smin, y));
	}
    }
}
#endif


#if 0

    rid_text_stream *stream;
    rid_table_colgroup *colgroup;
    rid_table_colhdr *colhdr;
    rid_text_item *ti;
    rid_table_cell *cell;
    rid_fmt_info fmt;
    int x, y, i, j;
    int *min_widths, *max_widths;
    int nwidths;
    rid_width_info *wi;

    fmt = *parfmt;


    /* Before trying to merge these two loops, be certain rid_scanf() */
    /* is going to use the same order you want to below. */

    TABDBG(("rid_size_table(): All cells now have sizes\n"));

    /*

	3) Within each row, for each boundary between columns work out
	the lowest and highest percentage across the table that this
	boundary could occur at. This can be done by working left to
	right for the minimums and right to left for the maximums,
	assuming every cell that is not given a percentage width has
	zero percent and then summing up the percentages as you move
	across the row.  Care should be taken to deal with the case
	where a leftmost or rightmost cell of a row has a percentage
	given as this constrain both the hightest and lowest values
	that the adjacent boundary could end up at.

	+) Each cell contributes precisely once. 

	*/

    TABDBG(("rid_size_table(): Summing percentages\n"));

    for (y = 0; y < table->cells.y; y++)
    {
	int smin = 0, smax = 100;

	ASSERT(smin == smax);

#if 0
	if (smin == 99)
	{
	    TABDBG(("rid_size_table(): row %d is 99 units - bump 1st percentage cell\n", y));
	    for (x = 0; x < table->cell.x; x++)
	    {
		cell = *CELLFOR(table, x, y);
		if (cell->minpct != 0)
		{
		    TABDBG(("rid_size_table(): bumping percentage by 1 for (%d, %d)\n", x, y));
		    cell->minpct++;		    
		    cell->maxpct++;
		    break;
		}
	    }
	}
	else if ( smin == 101)
	{
	    TABDBG(("rid_size_table(): row %d is 101 units - bump 1st percentage cell\n", y));
	    for (x = 0; x < table->cell.x; x++)
	    {
		cell = *CELLFOR(table, x, y);
		if (cell->minpct != 0)
		{
		    TABDBG(("rid_size_table(): bumping percentage by -1 for (%d, %d)\n", x, y));
		    cell->minpct--;		    
		    cell->maxpct--;
		    break;
		}
	    }
	}
#endif

	TABDBG(("rid_size_table(): checking whether need to swap percentage for row %d\n", y));

	for (x = 0, colhdr = &table->colhdrs[x]; x < table->cell.x; x++, colhdr++)
	{
	    cell = *CELLFOR(table, x, y);

	    PERCENT_CONTINUE_CONDITIONS;

	    if (cell->minpct > cell->maxpct)
	    {
		TABDBG(("rid_size_table(): swapping percentages for (%d, %d)\n", x, y));
		z = cell->minpct;
		cell->minpct = cell->maxpct;
		cell->maxpct = z;
	    }

	    /* 

	       5) For each column boundary, examin the results from
	       the previous stage and work out high and low percentage
	       values for where the boundary can lie.  Again,
	       conflicts may need to be resolved in badly specified
	       tables.
	
	       */
	    
	    if (colhdr->minpct != NO_PCT && cell->minpct < colhdr->minpct)
	    {
		TABDBG(("rid_size_table(): lowering minpct for column %d from %d to %d\n",
			x, colhdr->minpct, cell->minpct));
		colhdr->minpct = cell->minpct;
	    }

	    if (colhdr->maxpct != NO_PCT && cell->maxpct > colhdr->maxpct)
	    {
		TABDBG(("rid_size_table(): raising maxpct for column %d from %d to %d\n",
			x, colhdr->maxpct, cell->maxpct));
		colhdr->maxpct = cell->maxpct;
	    }

	}

    }

    /*

      Having update colhdr information from all cells, we now need to
      resolve any conflicts that may have been created for the
      position of the column headers. First ensure min/max relations
      are the right way around, then ensure each column is sensibly
      positioned, relative to its neighbours. Some columns may not
      have been given any percentage information - either through
      omission on the user's part or because of COLPSPAN=N attributes.

| : | :
|.:.|#:-
|#:-|.:.
| : | :

min  0  - 50 100
max  0  - 50 100

min  0  0 50 50
max 50 50 50  0

      */

    for (x = 0, colhdr = &table->colhdrs[0]; x < table->cells.x; x++, colhdr++)
    {
	if (colhdr->minpct != NO_PCT && 
	    colhdr->maxpct != NO_PCT && 
	    colhdr->minpct > colhdr->maxpct)
	{
	    TABDBG(("rid_size_table(): swapping min/max (%d,%d) for column %d\n",
		    colhdr->minpct, colhdr->maxpct, x));
	    z = colhdr->minpct;
	    colhdr->minpct = colhdr->maxpct;
	    colhdr->maxpct = z;
	}
    }

    for (x = 0, colhdr = &table->colhdrs[0]; x < table->cells.x; x++, colhdr++)
    {
	if (colhdr->minpct == 0)
	{
	    z = x == 0 ? 0 : colhdr[-1].maxpct;
	    TABDBG(("rid_size_table(): choosing minpct %d for column %d\n", z, x));
	    colhdr->minpct = z;
	}
    }

    for (x = 0, colhdr = &table->colhdrs[0]; x < table->cells.x; x++, colhdr++)
    {
	if (colhdr->minpct == 0)
	{
	    z = x == 0 ? 0 : colhdr[-1].maxpct;
	    TABDBG(("rid_size_table(): choosing minpct %d for column %d\n", z, x));
	    colhdr->minpct = z;
	}
    }

#endif    
    
}


#if 0
static void old_rid_size_table( rid_table_item *table, rid_fmt_info *parfmt )
{
    rid_text_stream *stream;
    rid_table_colgroup *colgroup;
    rid_table_colhdr *colhdr;
    rid_text_item *ti;
    rid_table_cell *cell;
    rid_fmt_info fmt;
    rid_halign_tag halign;
    rid_stdunits width_units, choff_units;
    int x, y, i, j;
    int *min_widths, *max_widths;
    int nwidths;
    
    fmt = *parfmt;
    
    TABDBGN(("rid_size_table(%p, %p)\n", table, parfmt));
    
    if (table->caption)
    {       /* Size the caption. No borders on captions. */
	stream = &table->caption->stream;
	TABDBG(("rid_size_table() sizing caption\n"));
	rid_size_stream(stream, &fmt, 0);
    }
    
    for (x = -1, y = 0; (cell = rid_next_root_cell(table, &x, &y)) != NULL; )
    {       /* Size cell. Include any border type spacing */
	/* Might be prevented from wrapping by cell */
	/* Might be forced to minimum width by col or colgroup */
	int flags = 0;
	stream = &cell->stream;

	TABDBG(("rid_size_table() sizing cell (%d,%d)\n", x, y));

	memset( &stream->width_info, 0, sizeof(stream->width_info));
	
	rid_getprop(table, x, y, rid_PROP_HALIGN, &halign);
	rid_getprop(table, x, y, rid_PROP_WIDTH, &width_units);
	
	if (halign == STYLE_ALIGN_CHAR)
	{
	    rid_getprop(table, x, y, rid_PROP_CH, &fmt.align_char);
	    rid_getprop(table, x, y, rid_PROP_CHOFF, &choff_units);
	    if (choff_units.type == rid_stdunit_PX)
	    {
		stream->width_info.minleft = stream->width_info.maxleft = (int) ceil(choff_units.u.f);
	    }
	    flags |= rid_fmt_CHAR_ALIGN;
	    TABDBG(("rid_size_table(): character alignment\n"));
	}
	
	if ( (cell->flags & rid_cf_NOWRAP) != 0 )
	{
	    flags |= rid_fmt_MAX_WIDTH;
	    TABDBG(("rid_size_table(): NOWRAP\n"));
	}
	else if ( (width_units.type == rid_stdunit_MULT ||
		   width_units.type == rid_stdunit_PCENT) &&
		  width_units.u.f == 0.0 )
	{
	    flags |= rid_fmt_MIN_WIDTH;
	    TABDBG(("rid_size_table(): MINWIDTH\n"));
	}

	TABDBG(("Sizing the stream now\n"));

	rid_size_stream(&cell->stream, &fmt, flags);
	
	colhdr = &table->colhdrs[x];

	if (width_units.type != value_none)
	{
	    int width_px = 0;
	    int set = 0;

	    switch(width_units.type)
	    {
	    case value_absunit:
		width_px = (int) ceil(width_units.u.f);
		set = 1;
		TABDBG(("rid_size_table(): absolute width %d\n", width_px));
		break;
	    case value_relunit:
		break;
	    case value_pcunit:
		break;
	    }

	    if (set)
	    {
		if (cell->stream.width_info.minwidth < width_px)
		    cell->stream.width_info.minwidth = width_px;

		if (cell->stream.width_info.maxwidth > width_px)
		    cell->stream.width_info.maxwidth = cell->stream.width_info.minwidth;
	    }
	}
	
	cell->stream.width_info.minwidth +=
	    colhdr->lborder + table->colhdrs[x + cell->span.x - 1].rborder;
	
	cell->stream.width_info.maxwidth +=
	    colhdr->lborder + table->colhdrs[x + cell->span.x - 1].rborder;
	
	if (cell->stream.width_info.minleft > colhdr->width_info.minleft)
	    colhdr->width_info.minleft = cell->stream.width_info.minleft;
	if (cell->stream.width_info.maxleft > colhdr->width_info.maxleft)
	    colhdr->width_info.maxleft = cell->stream.width_info.maxleft;
	
	if (cell->stream.width_info.minright > colhdr->width_info.minright)
	    colhdr->width_info.minright = cell->stream.width_info.minright;
	if (cell->stream.width_info.maxright > colhdr->width_info.maxright)
	    colhdr->width_info.maxright = cell->stream.width_info.maxright;

	TABDBG(("rid_size_table(): width info for cell is:\n"));
	dump_width_info(cell->stream.width_info);
    }
    
    memset(&table->width_info, 0, sizeof(table->width_info));
    
    if (table->caption)
    {
	table->width_info.minwidth = table->caption->stream.width_info.minwidth;
	table->width_info.maxwidth = table->caption->stream.width_info.maxwidth;
	TABDBG(("rid_size_table(): caption initialises width:\n"));
	dump_width_info(table->width_info);
    }
    
    nwidths = table->cells.x;
    
    if (nwidths != 0)
    {       /* Have cells to do as well */
	TABDBG(("rid_size_table(): %d width entries to work on\n", nwidths));

	min_widths = mm_calloc(sizeof(int), nwidths);
	max_widths = mm_calloc(sizeof(int), nwidths);
	
	/* If the user gave an absolute width for a column, start with this */
	/* If any column groups have absolute widths, apply these */
	/* Negate any widths got - these are notched out of the sharing, */
	/* unless only notched out values are present, when we force sharing */
	
	for (x = 0; x < nwidths; x++)
	{
	    colhdr = &table->colhdrs[x];
	    colgroup = colhdr->colgroup;
	    
	    if ( (colhdr->flags & rid_chf_ABSOLUTE) != 0 )
	    {
		TABDBG(("\nSharing widths for absolute sized column %d, %d pixels\n\n",
			x, (int) ceil(colhdr->userwidth.u.f)));
		ensure_span_evenly(min_widths, x, 1, (int) ceil(colhdr->userwidth.u.f));
		ensure_span_evenly(max_widths, x, 1, (int) ceil(colhdr->userwidth.u.f));
		min_widths[x] = -min_widths[x];
		max_widths[x] = -max_widths[x];
	    }
	}
	
	/* Now ensure each cells width across its columns */
	
	for (x = -1, y = 0; (cell = rid_next_root_cell(table, &x, &y)) != NULL; )
	{
	    int worst_span = nwidths - cell->cell.x;
#if 1
	    if (worst_span > cell->span.x)
		worst_span = cell->span.x;
#else
	    worst_span = cell->span.x;
#endif
	    TABDBGN(("\nSharing for cell %d,%d, span %d,%d\n", cell->cell.x, cell->cell.y, cell->span.x, cell->span.y));
	    ensure_span_evenly(min_widths, cell->cell.x, worst_span,
			       cell->stream.width_info.minwidth);
	    ensure_span_evenly(max_widths, cell->cell.x, worst_span,
			       cell->stream.width_info.maxwidth);
	}
	
	/* Cancel negation for notching */
	
	for (x = 0; x < nwidths; x++)
	{
	    if (min_widths[x] < 0)
		min_widths[x] = -min_widths[x];
	    if (max_widths[x] < 0)
		max_widths[x] = -max_widths[x];
	}
	
	/* Write back revised minimum widths */
	/* Calculate table min|max widths */
	/* i is table minwidth, j is table maxwidth */
	for (x = 0, i = 0, j = 0; x < nwidths; x++)
	{
	    if (max_widths[x] > table->colhdrs[x].width_info.maxwidth)
		table->colhdrs[x].width_info.maxwidth = max_widths[x];
	    table->colhdrs[x].width_info.minwidth = min_widths[x];
	    i += min_widths[x];
	    j += table->colhdrs[x].width_info.maxwidth;
	}
	
	i += table->lborder;
	i += table->rborder;
	j += table->lborder;
	j += table->rborder;
	
	if(i > j)
	    j = i;
	
	if (i > table->width_info.minwidth)
	    table->width_info.minwidth = i;
	if (j > table->width_info.maxwidth)
	    table->width_info.maxwidth = j;
	
	if ( table->userwidth.type == rid_stdunit_PX )
	{
	    int x = (int) ceil(table->userwidth.u.f);
	    if (x < table->width_info.minwidth)
	    {
		TABDBGN(("Table width %d smaller than min width %d - using minwidth\n", x, table->width_info.minwidth));
		table->width_info.maxwidth = table->width_info.minwidth;
	    }
	    else
	    {
		TABDBGN(("Table width %d chosen over %d|%d\n", x, table->width_info.minwidth, table->width_info.maxwidth));
		table->width_info.maxwidth = table->width_info.minwidth = x;
	    }
	}
	
	if (table->width_info.minwidth > table->width_info.maxwidth)
	    table->width_info.maxwidth = table->width_info.minwidth;
	
	nullfree((void**)&min_widths);
	nullfree((void**)&max_widths);
    }
    
    /* Until we are actually formatted, we have a width anywhere */
    /* between the minimum and maximum width, except probably in */
    /* big jumps at word breaks. */
    
    ti = (rid_text_item *)table->parent;
    ti->width = table->width_info.minwidth;
}
#endif /* 0 */

=============================================================================

23rd August 1996. Borris

Between <TABLE> and <TD|TH> we have a default caption text stream active.
Problems arise with

	<TABLE>Wibble
and
	<TABLE><H1>Wibble</H1>

because they end up in the wrong place - ie the caption rather than an
assumed first cell.  The first example is sorted out in deliver.c in
the unexpected character delivery. The second example has more code
associated with it. We want to generate

	<TABLE><TD><H1>wibble</H1>

we might have actually had 

	<TABLE><H1>Wibble</H1><TD>

and generate a "spurious" empty cell at the start of the
table. Without a retracing parsing (what we programmers call a
telepathic parser), this sort of additional markup problem can always
occur.

The simple solution if for <TABLE> to install a delivery handler of
its own and check everything going past. This has overheads for
anything contained in a table, which is not acceptable.

On closer examination, it is obvious that this extra behaviour is not
needed when within a table cell - indeed, it must not get in the way
for cases such as:

	<TABLE><P><TABLE><P>

The rules are quite simple:

1) Whenever we enter a table or leave a table cell (<TABLE>, </TD>,
</TH>), table_deliver() is installed.

2) Whenever we leave a table or enter a table cell (</TABLE>, <TD>,
<TH>), table_deliver() is removed.

3) table_deliver()

nop is ignored and does not get passed on.

word and space should not occur and are just freed.

unexpected is passed on and should trigger <TD>.

sgml is passed on.

eol is ignored.

eos unwinds the deliver stack and passes the call on.

pre open of anything that isn't a table content item causes <TD>.



#define DELIVER_NOP             	0
#define DELIVER_WORD            	1       /* A textual word */
#define DELIVER_SPACE           	2       /* Non end-of-line whitespace */
#define DELIVER_PRE_OPEN_MARKUP		3       /* Some markup parsed - before *fn */
#define DELIVER_POST_OPEN_MARKUP     	4       /* Some markup parsed - after  *fn */
#define DELIVER_PRE_CLOSE_MARKUP	5       /* Some markup parsed - before *fn */
#define DELIVER_POST_CLOSE_MARKUP	6       /* Some markup parsed - after  *fn */
#define DELIVER_UNEXPECTED      	7       /* Unexpected characters */
#define DELIVER_SGML            	8       /* General <SGML> */
#define DELIVER_EOL             	9       /* End of line */
#define DELIVER_EOS             	10       /* End of stream */


TABLE TD

 /   \   /      \   /       \   /   \   /\   /\
 TABLE   COLGROUP   /COLGROUP   TBODY   TR   TD
|     |=|        |=|         |=|     |=|  |=|  |
       ^          ^           ^       ^    ^

/	pre open/close
\	post open/close
|	change
=	table_deliver installed
^	possible bogus markup/text insertion point

All table elements except <TD> and <TR> do

	sgml_install_deliver(context, &table_deliver)

just before returning. The handler removes itself





=============================================================================

1st September 1996. Borris - started
11th September 1996. Borris - revised spacing/padding model for captions


Table borders, etc.


border		.
spacing		*
padding		-
contents	#

...............................
...............................
...............................
...*************************...
...*-----------------------*...
...*-----------------------*...
...*--######CAPTION######--*...
...*-----------------------*...
...*-----------------------*...
...*************************...
...*************************...
...*-------*-------*-------*...
...*-------*-------*-------*...
...*--###--*--###--*--###--*...
...*--###--*--###--*--###--*...
...*-------*-------*-------*...
...*-------*-------*-------*...
...*************************...
...*---------------*-------*...
...*---------------*-------*...
...*--###########--*--###--*...
...*--###########--*--###--*...
...*---------------*-------*...
...*---------------*-------*...
...*************************...
...............................
...............................
...............................
   |<-\--->|
   |<-cells width->|
   |<---- table width ---->|


This gets fractured as follows, from the viewpoint of each cell:

...............................
...............................
...............................
...*************************...
...*-----------------------*...
...*-----------------------*...

...*-- ######CAPTION###### --*...

...*-----------------------*...
...*-----------------------*...
...*************************...

...******** ******** ******** *...
...*------- *------- *------- *...
...*------- *------- *------- *...
...*--###-- *--###-- *--###-- *...
...*--###-- *--###-- *--###-- *...
...*------- *------- *------- *...
...*------- *------- *------- *...

...**************** ******** *...
...*--------------- *------- *...
...*--------------- *------- *...
...*--###########-- *--###-- *...
...*--###########-- *--###-- *...
...*--------------- *------- *...
...*--------------- *------- *...

...*************************...
...............................
...............................
...............................

We can't bring both sides of the spacing into the normal width of a
cell or we mess up some of the single/multiple colspan relationships.

This view only breaks down for the right and bottom cell spacing
lines. This only affects the redrawing of the cell spacing lines -
table frame, caption and cell contents are not affected by this. Thus,
there is a cludge in otable_redraw() for just these lines.



Various size values are involved

table overall size:
===================

The size the enclosing stream sees the word object as. stream->fwidth.

table internal size:
====================

The same as table overall size - 2 * border. This is the value the
user specifies in a <TABLE WIDTH=N%> element. Thus the table is always
wider than this unless BORDER=0 has been specified.

cell internal size:
===================

This is the size the user specifies with a <TD WIDTH=N%> element. It
does not include any cellpadding or cellspacing values. Care is
required when assigning widths to COLSPAN=N, N>1 table cells. The
following rows are the same width.

<table border=1 cellpadding=2 cellspacing=3>

<tr>
<td colspan=2 width=205>
The two cells below give:<br>
1 + 2 + 3 + 100 + 3 + 2 + 3 + 100 + 2 + 1<br>
= 217<br>
This cell gives:<br>
1 + 2 + 3 + X + 3 + 2 + 1<BR>
 = X + 12<BR>
 = 217<br>
X = 205
<tr>
<td width=100>100
<td width=100>another 100

</table>



For a table with two cells with widths W1 and W2, the overall table
size is calculated as:

	border
+	cellspacing
+	cellpadding
+	W1
+	cellpadding
+	cellspacing
+	cellpadding
+	W2
+	cellpadding
+	cellspacing
+	border

=	table overall size

This differs from our previous implementation!

To simplify matters somewhat, each cell is treated as having width:

	cellspacing + cellpadding + cell internal size + cellpadding

with

	border

pixels to the left of the first cell and

	cellspacing + border

pixels to the right.

This means the relative width calculations might be giving slightly
incorrect answers as the user might expect the percentages to relate
to any the width values given, wheras they relate to any given width
values plus cellspacing and cellpadding adjustments. This might be
fixed in a future version of the code.

These distances are always allocated. It is the filling in of these
distances that <TABLE FRAME=?> affects. The width of the table is not
affected by FRAME=? attributes. This differs from the previous
implementation.

BTW, this is how Netvirus works, I think.

We check to see if any text items have been put into the caption and
remove it if none have.  The caption is given a cellspacing plus
cellpadding border. Thus, a caption of X by Y occupies a screen space
of:

	2 * (border + cellspacing + cellpadding) + X
	2 * (border + cellspacing + cellpadding) + Y

This is done to satisfy:

a) The more spacing the user chooses to seperate table cells probably
indicates more space seperating the caption would be better layout.

b) Some additional space will help to clarify the caption.

Netvirus appears to go for an odd scheme:

			above		below

border			0		1
padding			1		1
spacing			0		2

I judge the 2*spacing case to be a bug.

Table captions placed to the left or the right are not supported. 


=============================================================================

17/9/96 borris 
19/9/96 borris

<TFOOT>

There are two phases. Before the end of the table, the TFOOT section
must take no vertical space. It can contribute to the horizontal
width, although for now it only contributes the minimal possible
width. At the end of the table, editting of the row group, row header
and cell array are performed to put the TFOOT where it belongs. The
cell origins are updated to be correct. Once this has been done, the
table can be treated as normal. We have a flag set
(rid_tf_TFOOT_INVISIBLE) to indicate that TFOOT cells are not to be
displayed.

Ideally, no sizing and formatting would be performed on the invisible
(TFOOT) items during the table.  For this to work, every relevant
place needs extra code. Getting anything wrong (eg future change) will
break it. For example, saving as text or searching during a table with
a TFOOT could easily have odd effects if we're not careful. The size
of a TFOOT is expected to be "reasonable".


=============================================================================

20/9/96 borris

Handling the case where the user requests the table to be larger than
the sum of the columns maxwidths.

Can occur either through WIDTH=N% or WIDTH=Npx. 

The table may be composed of a mixture of items with constrained and
unconstrained sizes (former = absolute and percentage items, latter
the normal min/max width (ie slight corruption of meaning of
unconstrained)).

If all items are constrained, then the user has really asked for
something impossible directly.  No way can all their requested
constraints be satisfied. So we break as many constraints as we
want. Given this freedom, we try to minimise any individual constraint
relaxation.

If some items are constrained and some are not, then we alter only
those unconstrained items - this is out attempt to "best honour" the
users contraints.

Whichever case, the placing of spare space is ultimately driven by
visual goals. Maintaining proportions is the best way to achieve
this. Over the range of numbers typically involved, we can probably
deviate (eg add fixed amount and ignore ratios) and have something
"close" to this.



=============================================================================