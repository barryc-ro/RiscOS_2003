/* htmlprocs.c - old procedures for opening and closing each element */
/* (C) Copyright ANT Limited 1996. All rights reserved. */

/*****************************************************************************/

extern void starthtml (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

/*****************************************************************************/

extern void startbyline (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startcaption (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startcenter (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startchanged (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startcmd (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startcol (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startcolgroup (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startcomment (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startfig (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startfont (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startfootnote (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void starthead (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void starthtmlplus (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startimage (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startimg (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startl (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startlisting (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startlit (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startmap (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startmargin (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startmath (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startnextid (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startnoframe (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startnoframes (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startnote (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startover (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startp (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startperson (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startplaintext (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startq (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startquote (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startremoved (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startrender (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void starts (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void starttab (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void starttable (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void starttbody (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void starttd (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void starttextarea (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void starttfoot (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startth (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startthead (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void starttr (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}

extern void startu (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{    generic_start (context, element, attributes);	}


extern void startcolgroupsection (SGMLCTX * context, ELEMENT * element, VALUES * attributes)
{ /*   generic_start (context, element, attributes); */	}

/*****************************************************************************/


extern void finishbyline (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishcaption (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishcenter (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishchanged (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishcite (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishcmd (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishcode (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishcol (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishcolgroup (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishcomment (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishdd (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishdfn (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishdir (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishdl (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishdt (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishem (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishfig (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishfont (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishfootnote (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}


extern void finishhead (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishhr (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishhtml (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishhtmlplus (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishi (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishimage (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishimg (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishinput (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishisindex (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishkbd (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishl (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishli (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishlink (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishlisting (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishlit (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishmap (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishmargin (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishmath (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishmenu (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishmeta (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishnextid (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishnoframe (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishnoframes (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishnote (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishol (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishover (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishp (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishperson (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishplaintext (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}


extern void finishq (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishquote (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishremoved (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishrender (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishs (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishsamp (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishscript (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishselect (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishstrong (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishsub (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishsup (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishtab (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishtable (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishtbody (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishtd (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishth (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishtfoot (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishthead (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishtextarea (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}


extern void finishtr (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishtt (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishu (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishul (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishvar (SGMLCTX * context, ELEMENT * element)
{    generic_finish (context, element);	}

extern void finishcolgroupsection (SGMLCTX * context, ELEMENT * element)
{ /*   generic_finish (context, element);	*/ }

/*****************************************************************************/


/*	Start Element
**	-------------
**
**     	No attributes are put to the output		Henrik 07/03-94
**	Does no assumptions of WHAT element is started...
*/
static void HTRISCOS_start_element (
				    HTStructured * 	me,
				    int		element_number,
				    const BOOL*	present,
				    const char **	value)
{
  ROStyle	new_style;
  int		new_list;
  int		new_state;
  
#if PARSE_DEBUG
  fprintf(stderr, "<%s element %d '%s'>\n",
	  me->dtd->tags[element_number].contents != SGML_EMPTY ? "Start" : "Empty",
	  element_number,
	  me->dtd->tags[element_number].name);
#endif
  
  /* @@@@ This almost certainly wants to be a bit more careful about forcing line breaks */
  
  
  /* N.B. Items that produce temporary style changes should update new_style from me->sp[0].def_style */
  new_style = me->sp[0].style;
  
  new_state = me->sp[0].state;
  new_list  = me->sp[0].list_no;
  
  if (!me->noframe) switch (element_number)
    {
    case HTML_A:
      text_item_push_word(me, 0);
      /* Make a new aref and fill in its fields */
      new_aref_item(me,
		    present[HTML_A_HREF] ? value[HTML_A_HREF] : 0,		/* Addresss */
		    present[HTML_A_NAME] ? value[HTML_A_NAME] : 0,	/* Tag */
		    present[HTML_A_REL]  ? value[HTML_A_REL] : 0,
		    present[HTML_A_TARGET]  ? value[HTML_A_TARGET] : 0);
      break;
      
    case HTML_FORM:
      text_item_push_word(me, 0);
      /* Make a new form and fill in its fields */
      new_form_item(me,
		    present[HTML_FORM_ACTION] ? value[HTML_FORM_ACTION] : 0,
		    present[HTML_FORM_METHOD] ? value[HTML_FORM_METHOD] : 0,
		    present[HTML_FORM_TARGET] ? value[HTML_FORM_TARGET] : 0 );
      break;
      
    case HTML_FRAME:
      new_frame_item(me,
		     present[HTML_FRAME_MARGINWIDTH] ? atoi(value[HTML_FRAME_MARGINWIDTH]) : 0,
		     present[HTML_FRAME_MARGINHEIGHT] ? atoi(value[HTML_FRAME_MARGINHEIGHT]) : 0,
		     present[HTML_FRAME_NAME] ? value[HTML_FRAME_NAME] : 0,
		     present[HTML_FRAME_NORESIZE] ? 1 : 0,
		     present[HTML_FRAME_SCROLLING] ? value[HTML_FRAME_SCROLLING] : 0,
		     present[HTML_FRAME_SRC] ? value[HTML_FRAME_SRC] : 0);
      break;
      
    case HTML_FRAMESET:
      new_frameset_item(me,
			present[HTML_FRAMESET_COLS] ? value[HTML_FRAMESET_COLS] : 0,
			present[HTML_FRAMESET_ROWS] ? value[HTML_FRAMESET_ROWS] : 0);
      break;
      
    case HTML_NOFRAMES: /* netscape 'spec' says this */
			     case HTML_NOFRAME:  /* netscape site uses this... */
						      if (include_frames)
							me->noframe++;
			     break;
			     
    case HTML_TITLE:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      if (me->rh->title)
	{
	  mm_free(me->rh->title);
	  me->rh->title = NULL;
	}
      new_state |= STK_STATE_LINES;
      break;
      
    case HTML_META:
      if (present[HTML_META_CONTENT] && present[HTML_META_HTTPEQUIV])
	{
	  if (strcasecomp(value[HTML_META_HTTPEQUIV], "REFRESH") == 0)
	    {
	      char *ss, *s = strdup(value[HTML_META_CONTENT]);
	      
	      ss = strtok(s, " ;\n\r");
	      if (ss)
                {
		  int i = atoi(ss);
		  if (i > 0)
		    me->rh->refreshtime = i;
		  do
                    {
		      if (strncasecomp(ss, "url=", 4) == 0)
                        {
			  me->rh->refreshurl = strdup(ss+4);
                        }
                    }
		  while ((ss = strtok(NULL, " ;\n\r")) != NULL);
                }
	      
	      mm_free(s);
	    }
	  else if (strcasecomp(value[HTML_META_HTTPEQUIV], "Window-target") == 0)
	    {
	      me->rh->windowname = strdup(value[HTML_META_CONTENT]);
	    }
	}
      break;
      
    case HTML_BODY:
      text_item_push_word(me, 0);
      if (present[HTML_BODY_BACKGROUND])
	{
	  me->rh->bgt |= rid_bgt_IMAGE;
	  if (me->rh->tile.src)
	    mm_free(me->rh->tile.src);
	  me->rh->tile.src = strdup(value[HTML_BODY_BACKGROUND]);
	}
      if (present[HTML_BODY_BGCOLOR])
	{
	  me->rh->bgt |= rid_bgt_COLOURS;
	  htmlriscos_colour((char*) value[HTML_BODY_BGCOLOR], &me->rh->colours.back);
	}
      if (present[HTML_BODY_TEXT])
	{
	  me->rh->bgt |= rid_bgt_FCOL;
	  htmlriscos_colour((char*) value[HTML_BODY_TEXT], &me->rh->colours.fore);
	}
      if (present[HTML_BODY_LINK])
	{
	  me->rh->bgt |= rid_bgt_LCOL;
	  htmlriscos_colour((char*) value[HTML_BODY_LINK], &me->rh->colours.link);
	}
      if (present[HTML_BODY_VLINK])
	{
	  me->rh->bgt |= rid_bgt_VCOL;
	  htmlriscos_colour((char*) value[HTML_BODY_VLINK], &me->rh->colours.vlink);
	}
      if (present[HTML_BODY_ALINK])
	{
	  me->rh->bgt |= rid_bgt_ACOL;
	  htmlriscos_colour((char*) value[HTML_BODY_ALINK], &me->rh->colours.alink);
	}
      break;
      
    case HTML_FONT:
      if (present[HTML_FONT_SIZE])
	{
	  int size;
	  size = (me->rh->bgt & rid_bgt_BASEFONT) ? me->rh->basefont : 3; /* Default font size is 3 */
	  
	  /* some documents use <FONT SIZE> to mean (apparently) restore default, yuk! */
	       if (value[HTML_FONT_SIZE])
		 {
		   if (value[HTML_FONT_SIZE][0] == '+')
		     size += atoi(value[HTML_FONT_SIZE]+1);
		   else if (value[HTML_FONT_SIZE][0] == '-')
		     size -= atoi(value[HTML_FONT_SIZE]+1);
		   else
		     size = atoi(value[HTML_FONT_SIZE]);
		   
		   if (size < 1)
		     size = 1;
		   if (size > 7)
		     size = 7;
		 }
	  
	  text_item_push_word(me, 0);
	  new_style.wf_index &= ~WEBFONT_SIZE_MASK;
	  new_style.wf_index |= (size - 1) << WEBFONT_SIZE_SHIFT;
	  
#if PARSE_DEBUG
	  fprintf(stderr, "FONT size %p '%s' %d\n", value[HTML_FONT_SIZE], value[HTML_FONT_SIZE], size);
#endif
	}
      break;
      
    case HTML_BASE:
      if (present[HTML_BASE_HREF])
	{
	  me->rh->base = strdup(value[HTML_BASE_HREF]);
	}
      if (present[HTML_BASE_TARGET])
	{
	  me->rh->basetarget = strdup(value[HTML_BASE_TARGET]);
	}
      break;
      
    case HTML_BASEFONT:
      break;
      
    case HTML_LISTING:				/* Litteral text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
    case HTML_PRE:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      new_style.wf_index = WEBFONT_PRE;
      new_state |= (STK_STATE_PRE | STK_STATE_LINES);
      break;
      
    case HTML_H1:
    case HTML_H2:
    case HTML_H3:
    case HTML_H4:
    case HTML_H5:
    case HTML_H6:
    case HTML_H7:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      {
	int wf = new_style.wf_index;
	
	if (element_number == HTML_H1) wf = WEBFONT_H1;
	else if (element_number == HTML_H2) wf = WEBFONT_H2;
	else if (element_number == HTML_H3) wf = WEBFONT_H3;
	else if (element_number == HTML_H4) wf = WEBFONT_H4;
	else if (element_number == HTML_H5) wf = WEBFONT_H5;
	else if (element_number == HTML_H6) wf = WEBFONT_H6;
	else if (element_number == HTML_H7) wf = WEBFONT_H7;
	
	new_style.wf_index = wf;
	new_state &= ~(STK_STATE_PRE | STK_STATE_LINES);
      }
      break;
      
    case HTML_DL:
      /* The style pushed here gets modified by the <DD> and <DL> tags */
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      if (new_style.indent < (256-INDENT_WIDTH) )
	new_style.indent += INDENT_WIDTH;
      break;
      
    case HTML_DT:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      if (me->sp[0].tag_number == HTML_DL)
	{
	  me->sp[0].style.indent = me->sp[1].style.indent + 2;
	  me->sp[0].style.wf_index = WEBFONT_DT;
	}
      break;
      
    case HTML_DD:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      if (me->sp[0].tag_number == HTML_DL)
	{
	  me->sp[0].style.indent = me->sp[1].style.indent + INDENT_WIDTH;
	  me->sp[0].style.wf_index = WEBFONT_DD;
	}
      break;
      
    case HTML_CENTER:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      new_style.flags |= rid_sf_CENTERED;
      break;
      
    case HTML_CODE:
    case HTML_KBD:
    case HTML_SAMP:
    case HTML_TT:
      text_item_push_word(me, 0);
      new_style.wf_index |= WEBFONT_FLAG_FIXED;
      break;
      
    case HTML_STRONG:
    case HTML_B:
      text_item_push_word(me, 0);
      new_style.wf_index |= WEBFONT_FLAG_BOLD;
      break;
      
    case HTML_EM:
    case HTML_VAR:
    case HTML_I:
      text_item_push_word(me, 0);
      new_style.wf_index |= WEBFONT_FLAG_ITALIC;
      break;
      
    case HTML_CITE:
      text_item_push_word(me, 0);
      new_style.wf_index = WEBFONT_CITE;
      break;
      
    case HTML_BLOCKQUOTE:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      new_style.wf_index = WEBFONT_BLOCK;
      if (new_style.indent < (256-INDENT_WIDTH) )
	new_style.indent += INDENT_WIDTH;
      break;
      
    case HTML_UL:
    case HTML_OL:
    case HTML_MENU:
    case HTML_DIR:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      if (new_style.indent < (256-INDENT_WIDTH) )
	new_style.indent += INDENT_WIDTH;
      new_list = 0;
      break;
      
    case HTML_LI:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      switch (me->sp[0].tag_number)
	{
	case HTML_OL:
	  me->sp[0].list_no++;
	  break;
	case HTML_UL:
	case HTML_MENU:
	case HTML_DIR:
	default:
	  break;
	}
      
      {
	int oldindent = me->sp[0].style.indent;
	
	if (oldindent >= INDENT_WIDTH)
	  me->sp[0].style.indent -= INDENT_WIDTH;
	text_item_push_bullet(me);
	me->sp[0].style.indent = oldindent;
      }
      break;
      
    case HTML_IMG:
      text_item_push_word(me, 0);
      text_item_push_image(me, 0,
			   present[HTML_IMG_SRC]   ? value[HTML_IMG_SRC]    : 0,
			   present[HTML_IMG_ALT]   ? value[HTML_IMG_ALT]    : 0,
			   present[HTML_IMG_ALIGN] ? value[HTML_IMG_ALIGN]  : 0,
			   present[HTML_IMG_BORDER]? value[HTML_IMG_BORDER] : 0,
			   present[HTML_IMG_WIDTH] ? value[HTML_IMG_WIDTH]  : 0,
			   present[HTML_IMG_HEIGHT]? value[HTML_IMG_HEIGHT] : 0,
			   present[HTML_IMG_USEMAP] ? value[HTML_IMG_USEMAP] : 0,
			   present[HTML_IMG_ISMAP] ? 1 : 0);
      break;
      
    case HTML_INPUT:
      text_item_push_word(me, 0);
      text_item_push_input(me, 0, present, value);
      break;
      
    case HTML_P:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      text_item_push_break(me, 0);
      break;
      
    case HTML_HR:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      text_item_push_break(me, 1);
      break;
      
    case HTML_BR:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      break;
      
    case HTML_U:
      text_item_push_word(me, 0);
      new_style.flags |= rid_sf_UNDERLINE;
      break;
      
    case HTML_ISINDEX:
      me->rh->flags |= rid_hf_ISINDEX;
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      text_item_push_break(me, 1);
      
      push_fake_search_form(me, (char *) (present[HTML_INDEX_PROMPT] ? value[HTML_INDEX_PROMPT] : 0));
      
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      text_item_push_break(me, 1);
      break;
      
    case HTML_SELECT:
      text_item_push_word(me, STRIP_SPACE);
      text_item_push_select(me,
			    (char *) (present[HTML_SELECT_NAME] ? value[HTML_SELECT_NAME] : 0),
			    (char *) (present[HTML_SELECT_SIZE] ? value[HTML_SELECT_SIZE] : 0),
			    present[HTML_SELECT_MULTIPLE] );
      new_state |= (STK_STATE_LINES);
      break;
      
    case HTML_OPTION:
      text_item_push_word(me, STRIP_SPACE);
      new_option_item(me,
		      (char *) (present[HTML_OPTION_VALUE] ? value[HTML_OPTION_VALUE] : 0),
		      (present[HTML_OPTION_DISABLED] ? rid_if_DISABLED : 0) + (present[HTML_OPTION_SELECTED] ? rid_if_CHECKED : 0) );
      break;
      
    case HTML_TEXTAREA:
      text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      text_item_push_textarea(me,
			      (char *) (present[HTML_TEXTAREA_NAME] ? value[HTML_TEXTAREA_NAME] : 0),
			      (char *) (present[HTML_TEXTAREA_ROWS] ? value[HTML_TEXTAREA_ROWS] : 0),
			      (char *) (present[HTML_TEXTAREA_COLS] ? value[HTML_TEXTAREA_COLS] : 0) );
      new_state |= (STK_STATE_PRE | STK_STATE_LINES);
      break;
      
    case HTML_MAP:
      text_item_push_word(me, 0);
      new_map_item(me, present[HTML_MAP_NAME] ? value[HTML_MAP_NAME] : 0);
      break;
    case HTML_AREA:
      text_item_push_word(me, 0);
      new_area_item(me,
		    (present[HTML_AREA_SHAPE] ? value[HTML_AREA_SHAPE] : 0),
		    (present[HTML_AREA_COORDS] ? value[HTML_AREA_COORDS] : 0),
		    (present[HTML_AREA_HREF] ? value[HTML_AREA_HREF] : 0),
		    (present[HTML_AREA_TARGET] ? value[HTML_AREA_TARGET] : 0),
		    (present[HTML_AREA_ALT] ? value[HTML_AREA_ALT] : 0));
      break;
      
    case HTML_SCRIPT:
      text_item_push_word(me, 0);
      me->noframe++;
      break;
      
    case HTML_CAPTION:
      text_item_push_word(me, STRIP_SPACE);
      if ( present[HTML_CAPTION_ID] && 
	   value[HTML_CAPTION_ID] != NULL && 
	   value[HTML_CAPTION_ID][0] != 0 )
	new_aref_item(me, NULL, value[HTML_CAPTION_ID], NULL, NULL);                               
      new_style.flags |=
        table_start_caption(me,
			    V_OR_NULL(HTML_CAPTION_ALIGN),
			    V_OR_NULL(HTML_CAPTION_CLASS),
			    V_OR_NULL(HTML_CAPTION_DIR),
			    V_OR_NULL(HTML_CAPTION_ID),
			    V_OR_NULL(HTML_CAPTION_LANG),
			    V_OR_NULL(HTML_CAPTION_STYLE)
			    );
      break;
    case HTML_TABLE:
      {
        /* The start of a table or start of a row pushes a line break */
        char *border = NULL;
        if ( present[HTML_TABLE_BORDER] )
	  {
	    border = (char*)value[HTML_TABLE_BORDER];
	    if (border == NULL)
	      border = "1";
	  }
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE/*?*/);
        must_have_a_text_item(me);
        if ( present[HTML_TABLE_ID] && 
             value[HTML_TABLE_ID] != NULL && 
             value[HTML_TABLE_ID][0] != 0 )
	  new_aref_item(me, NULL, value[HTML_TABLE_ID], NULL, NULL);                               
        new_style.flags |=
	  table_start_table(me,
			    (char *) (present[HTML_TABLE_ALIGN] ? value[HTML_TABLE_ALIGN] : NULL ),
			    border,
			    (char *) (present[HTML_TABLE_CELLPADDING] ? value[HTML_TABLE_CELLPADDING] : NULL ),
			    (char *) (present[HTML_TABLE_CELLSPACING] ? value[HTML_TABLE_CELLSPACING] : NULL ),
			    (char *) (present[HTML_TABLE_CLASS] ? value[HTML_TABLE_CLASS] : NULL ),
			    (char *) (present[HTML_TABLE_COLS]  ? value[HTML_TABLE_COLS]  : NULL ),
			    (char *) (present[HTML_TABLE_DIR]   ? value[HTML_TABLE_DIR]   : NULL ),
			    (char *) (present[HTML_TABLE_FRAME] ? value[HTML_TABLE_FRAME] : NULL ),
			    (char *) (present[HTML_TABLE_ID]    ? value[HTML_TABLE_ID]    : NULL ),
			    (char *) (present[HTML_TABLE_LANG]  ? value[HTML_TABLE_LANG]  : NULL ),
			    (char *) (present[HTML_TABLE_RULES] ? value[HTML_TABLE_RULES] : NULL ),
			    (char *) (present[HTML_TABLE_STYLE] ? value[HTML_TABLE_STYLE] : NULL ),
			    (char *) (present[HTML_TABLE_WIDTH] ? value[HTML_TABLE_WIDTH] : NULL )
			    );
        new_style.indent = 0;
        break;
      }
    case HTML_THEAD:
    case HTML_TFOOT:
    case HTML_TBODY:
      text_item_push_word(me, STRIP_SPACE);
      ASSERT( HTML_THEAD_ATTRIBUTES == HTML_TFOOT_ATTRIBUTES);
      ASSERT( HTML_THEAD_ATTRIBUTES == HTML_TBODY_ATTRIBUTES);
      if ( present[HTML_THEAD_ID] && 
	   value[HTML_THEAD_ID] != NULL && 
	   value[HTML_THEAD_ID][0] != 0 )
	new_aref_item(me, NULL, value[HTML_THEAD_ID], NULL, NULL);                               
      table_start_rowgroup(me, element_number,
			   V_OR_NULL(HTML_THEAD_ALIGN),
			   V_OR_NULL(HTML_THEAD_CHAR),
			   V_OR_NULL(HTML_THEAD_CHAROFF),
			   V_OR_NULL(HTML_THEAD_CLASS),
			   V_OR_NULL(HTML_THEAD_DIR),
			   V_OR_NULL(HTML_THEAD_ID),
			   V_OR_NULL(HTML_THEAD_LANG),
			   V_OR_NULL(HTML_THEAD_STYLE),
			   V_OR_NULL(HTML_THEAD_VALIGN)
			   );
      break;
    case HTML_COLGROUP:
      text_item_push_word(me, STRIP_SPACE);
      if ( present[HTML_COLGROUP_ID] && 
	   value[HTML_COLGROUP_ID] != NULL && 
	   value[HTML_COLGROUP_ID][0] != 0 )
	new_aref_item(me, NULL, value[HTML_COLGROUP_ID], NULL, NULL);                               
      table_start_colgroup(me,
                           V_OR_NULL(HTML_COLGROUP_ALIGN),
                           V_OR_NULL(HTML_COLGROUP_CHAR),
                           V_OR_NULL(HTML_COLGROUP_CHAROFF),
                           V_OR_NULL(HTML_COLGROUP_CLASS),
                           V_OR_NULL(HTML_COLGROUP_DIR),
                           V_OR_NULL(HTML_COLGROUP_ID),
                           V_OR_NULL(HTML_COLGROUP_LANG),
                           V_OR_NULL(HTML_COLGROUP_SPAN),
                           V_OR_NULL(HTML_COLGROUP_STYLE),
                           V_OR_NULL(HTML_COLGROUP_VALIGN),
                           V_OR_NULL(HTML_COLGROUP_WIDTH)
			   );
      break;
    case HTML_COL:
      text_item_push_word(me, STRIP_SPACE);
      if ( present[HTML_COL_ID] && 
	   value[HTML_COL_ID] != NULL && 
	   value[HTML_COL_ID][0] != 0 )
	new_aref_item(me, NULL, value[HTML_COL_ID], NULL, NULL);                               
      table_start_col(me,
		      V_OR_NULL(HTML_COL_ALIGN),
		      V_OR_NULL(HTML_COL_CHAR),
		      V_OR_NULL(HTML_COL_CHAROFF),
		      V_OR_NULL(HTML_COL_CLASS),
		      V_OR_NULL(HTML_COL_DIR),
		      V_OR_NULL(HTML_COL_ID),
		      V_OR_NULL(HTML_COL_LANG),
		      V_OR_NULL(HTML_COL_SPAN),
		      V_OR_NULL(HTML_COL_STYLE),
		      V_OR_NULL(HTML_COL_VALIGN),
		      V_OR_NULL(HTML_COL_WIDTH)
		      );
      break;
    case HTML_TR:
      text_item_push_word(me, STRIP_SPACE);
      if ( present[HTML_TR_ID] && 
	   value[HTML_TR_ID] != NULL && 
	   value[HTML_TR_ID][0] != 0 )
	new_aref_item(me, NULL, value[HTML_TR_ID], NULL, NULL);                               
      table_start_tr(me,
		     V_OR_NULL(HTML_TR_ALIGN),
		     V_OR_NULL(HTML_TR_CHAR),
		     V_OR_NULL(HTML_TR_CHAROFF),
		     V_OR_NULL(HTML_TR_CLASS),
		     V_OR_NULL(HTML_TR_DIR),
		     V_OR_NULL(HTML_TR_ID),
		     V_OR_NULL(HTML_TR_LANG),
		     V_OR_NULL(HTML_TR_STYLE),
		     V_OR_NULL(HTML_TR_VALIGN)
		     );
      break;
    case HTML_TH:
    case HTML_TD:
      text_item_push_word(me, STRIP_SPACE);
      assert(HTML_TH_ATTRIBUTES == HTML_TD_ATTRIBUTES);
      if ( present[HTML_TD_ID] && 
	   value[HTML_TD_ID] != NULL && 
	   value[HTML_TD_ID][0] != 0 )
	new_aref_item(me, NULL, value[HTML_TD_ID], NULL, NULL);                               
      new_style = me->sp[0].def_style;
      if (element_number == HTML_TH)
        {
	  fprintf(stderr, "Choosing bold for TH\n");
	  new_style.wf_index |= WEBFONT_FLAG_BOLD;
        }
      new_style.flags |=	/* @@@@ This does no good as nothing is stacked for 'empty' elements */
        table_start_th_td(me, element_number,
			  V_OR_NULL(HTML_TD_ALIGN),
			  V_OR_NULL(HTML_TD_AXES),
			  V_OR_NULL(HTML_TD_AXIS),
			  V_OR_NULL(HTML_TD_CHAR),
			  V_OR_NULL(HTML_TD_CHAROFF),
			  V_OR_NULL(HTML_TD_CLASS),
			  V_OR_NULL(HTML_TD_COLSPAN),
			  V_OR_NULL(HTML_TD_DIR),
			  V_OR_NULL(HTML_TD_ID),
			  V_OR_NULL(HTML_TD_LANG),
			  present[HTML_TD_NOWRAP],
			  V_OR_NULL(HTML_TD_ROWSPAN),
			  V_OR_NULL(HTML_TD_STYLE),
			  V_OR_NULL(HTML_TD_VALIGN)
			  );
      break;
      
    default:
      text_item_push_word(me, 0);
      break;
    }
  
  if (me->dtd->tags[element_number].contents != SGML_EMPTY)
    {
      if (me->sp == me->stack)
	{
	  fprintf(stderr, "HTML: ****** Maximum nesting of %d exceded!\n", MAX_NESTING);
	  me->rh->flags |= rid_hf_HTML_ERRS;
	  return;
	}
      --(me->sp);
      me->sp[0].style = me->sp[0].def_style = new_style;	/* Stack new style */
      me->sp[0].state = new_state;	/* Stack new state */
      me->sp[0].list_no = new_list;	/* Stack new list position */
      me->sp[0].tag_number = element_number;
    }
  else
    {
      /* Update the current style without stacking */
      me->sp[0].style = new_style;
    }
  
}


/*		End Element
**		-----------
**
**	Ends an markup element			Henrik 07/03-94
**	Does no assumptions of WHAT element is ended...
*/
static void HTRISCOS_end_element (HTStructured * me, int element_number)
{
#if PARSE_DEBUG
  fprintf(stderr, "<End element %d '%s'>\n", element_number, me->dtd->tags[element_number].name);
#endif
  
  switch (element_number)
    {
    case HTML_PRE:
    case HTML_DT:
    case HTML_DD:
    case HTML_DL:
    case HTML_H1:
    case HTML_H2:
    case HTML_H3:
    case HTML_H4:
    case HTML_H5:
    case HTML_H6:
    case HTML_H7:
    case HTML_TITLE:
    case HTML_BLOCKQUOTE:
    case HTML_UL:
    case HTML_OL:
    case HTML_MENU:
    case HTML_DIR:
    case HTML_FORM:
    case HTML_CENTER:
      if (!me->noframe)
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
      break;
      
    case HTML_FRAMESET:
      /* unstack frameset, check level as we may be skipping framesets */
	   if (me->frameset > 0)
	     {
	       if (--me->frameset == 0)
		 me->noframe++;
	     }
      break;
      
    case HTML_NOFRAME:
    case HTML_NOFRAMES:
      me->noframe--;
      break;
      
    case HTML_MAP:
      me->map = NULL;
      break;
      
    case HTML_TABLE:
      if (!me->noframe)
        {
	  text_item_push_word(me, STRIP_SPACE);
	  table_end_table(me);
	  must_have_a_text_item(me);
	  text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
        }
      break;
      
      
    case HTML_COLGROUP:
      if (!me->noframe)
        {
	  text_item_push_word(me, STRIP_SPACE);
	  table_end_colgroup(me);
        }
      break;
      
    case HTML_COL:
    case HTML_THEAD:
    case HTML_TFOOT:
    case HTML_TBODY:
    case HTML_TR:
    case HTML_TH:
    case HTML_TD:
      if (!me->noframe)
	text_item_push_word(me, STRIP_SPACE);
      break;
      
    case HTML_SCRIPT:
      if (--me->noframe)
	text_item_push_word(me, 0);
      break;
      
    default:
      if (!me->noframe)
	text_item_push_word(me, 0);
      break;
    }
  
#ifdef CAREFUL			/* parser assumed to produce good nesting */
  if (element_number != me->sp[0].tag_number) {
    fprintf(stderr, "***** HTMLText: end of element %s when expecting end of %s\n",
	    me->dtd->tags[element_number].name,
	    me->dtd->tags[me->sp->tag_number].name);
    /* panic */
    me->rh->flags |= rid_hf_HTML_ERRS;
  }
#endif
  
  /* This test should not be needed but some people can't read the spec and give us bad HTML */
  if (me->dtd->tags[element_number].contents != SGML_EMPTY)
    {
      if (me->sp != me->stack + MAX_NESTING - 1)
	me->sp++;				/* Pop state off stack */
      else
	{
	  fprintf(stderr, "***** Stack underrun\n");
	  me->rh->flags |= rid_hf_HTML_ERRS;
	}
    }
  
  switch (element_number)
    {
    case HTML_A:
      /* Clear the current anchor.  They are not supposed to be nested */
      if (me->aref && me->aref->first == NULL)
	me->aref->first = me->rh->curstream->text_last;
      me->aref = 0;
      break;
    case HTML_FORM:
      /* Leaving the current form.  Again, it sould not be nested */
#if 0
      me->form = 0;
#endif
      break;
    }
}

/*****************************************************************************/

#include "htmldefs.c"

/* eof htmlprocs.c */
