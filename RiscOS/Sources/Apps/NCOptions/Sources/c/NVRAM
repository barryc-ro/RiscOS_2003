#include <string.h>

#include "swis.h"

#include "Desk/Error2.h"
#include "Desk/DeskMem.h"

#include "NVRAM.h"


#define	NVRAM_Read	0x4ee00
#define	NVRAM_Write	0x4ee01


#define	NOTSUCHTAG	"Unable to %s NVRAM tag '%s' - no such tag"
#define	NOTAWORD	"Unable to %s NVRAM tag '%s' - not a word"
#define	UNRECOGERROR	"Unable to %s NVRAM tag '%s' - unrecognised error number %i"

/*
These error strings are duplicated in read and write fns so that cc can
use the same literal in both functions.
 */


static void	NVRAM_WriteInt( const char* tag, int value)
{
	int	e;
	Desk_Error2_CheckOS( _swix( NVRAM_Write, _INR(0,2)|_OUT(0), tag, &value, 0, &e));
	if ( e>=0)	;
	else if (e==-1)	Desk_Error2_MsgTransHandlef( "NVTag", "read", tag);
	else if (e==-4)	Desk_Error2_MsgTransHandlef( "NVWord", "read", tag);
	else		Desk_Error2_MsgTransHandlef( "NVReg", "read", tag);
}

int	NVRAM_ReadInt( const char* tag)
{
	int	value;
	int	e;
	Desk_Error2_CheckOS( _swix( NVRAM_Read, _INR(0,2)|_OUT(0), tag, &value, 0, &e));
	if ( e>=0)	return value;
	else if (e==-1)	Desk_Error2_MsgTransHandlef( "NVTag", "write", tag);
	else if (e==-4)	Desk_Error2_MsgTransHandlef( "NVWord", "write", tag);
	else		Desk_Error2_MsgTransHandlef( "NVReg", "write", tag);
	return 0;
}


typedef struct
{
	Desk_linklist_header	header;
	int			value;
	char			tag[4];	// Actually a complete string.
}
	nvram_oldvalue;
/*
A linked list of these is kept for all changed NVRAM values. If an error
occurs, the NVRAM is restored using this list.
 */




void	NVRAM_InitChangeList( nvram_changelist* changelist)
{
	Desk_LinkList_Init( changelist);
}


void	NVRAM_WriteAndStoreOld( const char* tag, int value, nvram_changelist* changelist)
{
	nvram_oldvalue*	oldvalue = (nvram_oldvalue*) Desk_DeskMem_Malloc( sizeof( nvram_oldvalue) + strlen( tag) + 1 - 4);
	oldvalue->value	= NVRAM_ReadInt( tag);
	strcpy( oldvalue->tag, tag);
	Desk_LinkList_AddToTail( changelist, &oldvalue->header);
	NVRAM_WriteInt( tag, value);
}

void	NVRAM_RestoreOld( nvram_changelist* changelist)
{
	nvram_oldvalue*	oldvalue;
	// It's important that we restore things in reverse order, in case a location is changed twice.
	for ( oldvalue=Desk_LinkList_LastItem( changelist); oldvalue; oldvalue=Desk_LinkList_PreviousItem( &oldvalue->header))
	{
		NVRAM_WriteInt( oldvalue->tag, oldvalue->value);
	}
}

void	NVRAM_FreeChangeList( nvram_changelist* changelist)
{
	nvram_oldvalue*	oldvalue;
	for ( oldvalue=Desk_LinkList_FirstItem( changelist); oldvalue;)
	{
		nvram_oldvalue*	next = Desk_LinkList_NextItem( &oldvalue->header);
		// Don't need to call, Desk_LinkList_Unlink() as we are freeing the entire list.
		Desk_DeskMem_Free( oldvalue);
		oldvalue = next;
	}
	NVRAM_InitChangeList( changelist);
}

