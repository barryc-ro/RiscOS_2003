/************************************************************************************/
/*                                                                                  */
/*  File: ftp.c                                                                     */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  17-Jul-1998  SR        Created                                                  */
/*                                                                                  */
/************************************************************************************/

/* ANSI Includes */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <ctype.h>

/* System includes */
#include "kernel.h"
#include "swis.h"
#include "zlib/zlib.h"

/* Local includes */
#include "ui.h"
#include "main.h"
#include "errors.h"
#include "ftp.h"
#include "progrmng.h"
#include "ppp.h"

enum ftp_state {IDLE,
                OPENING_SESSION,
                READING_DATA,
                READING_IDLE,
                CLOSING_SESSION};

char ftp_buf[FTP_BUFFER_SIZE];
static enum ftp_state ftp_state = IDLE;
static char *p = NULL;
static int no_more_data_to_fetch = FALSE;
static int bytes_read = 0;  /* (0<=bytes_read<=FTP_BUFFER_SIZE) */
static int ftp_fetcher_initialised = FALSE;

static int initialise_ftp_fetcher(int *session_id);
static int ftp_stop(int *session_id);
static int ftp_status(int session_id);
static int ftp_read_data(int session_id);
static int e_check(int rc,int line);

enum status {STATUS_IDLE,FETCHING_DATA,DATA_FETCHED};
static enum status status = STATUS_IDLE;

#ifdef FTP_SIMULATION
static FILE *ftp = NULL;
static void delay_simulation(int *timer_started,time_t *save_time,int *rc);
#else
static void dns_init(void);
static int build_url(char **url);
static int parse_header(int session);
static _kernel_oserror *readhdr(int session,char *buff,int amt,int *fetched);
static int bytes_transferred_to_buffer = 0;  /* Not the same as bytes available in the buffer.  Bytes transferred is
                                                the number of bytes transferred on the current call to URL_ReadData,
                                                which may not be the full number of bytes we've asked for.  We may
                                                need to call URL_ReadData several times before getting the amt requested.
                                                bytes_transferred_to_buffer is not a cumulative sum and does not tell us
                                                the number of bytes currently available in the buffer. */
#endif

/************************************************************************************/
/* Function:  ftp_stateMachine()                                                    */
/* Behaviour: Code contained within the FTP state machine maps directly onto the    */
/*            state machine spreadsheet for FTP, drawing no. 2205,034/DS.           */
/* Requires:  'reason', which is START, ABORT, CLOSE, or POLL, as defined on the    */
/*            spreadsheet.                                                          */
/* Returns:   DONE, IN_PROGRESS, or ERROR, as defined on the spreadsheet.           */
/************************************************************************************/

extern int ftp_stateMachine(int reason)
{
  int rc;
  int flags = 0;
  static int session_id = -1;
  _kernel_oserror *er;

    switch (ftp_state)
    {
       case IDLE:            switch (reason)
                             {
                               case START: rc = initialise_ftp_fetcher(&session_id);
                                           if ((e_check(rc,__LINE__)) == ERROR)
                                           {
                                                ftp_stop(&session_id);
                                                ftp_state = IDLE;
                                                return ERROR;
                                           }
                                           else if (rc == IN_PROGRESS)
                                           {
                                                ftp_state = OPENING_SESSION;
                                                if ((er = ui_set_progress_message(flags,FTP_Connect_Stage)) != NULL)
                                                {
                                                     error_handler(__FILE__,__LINE__,"ftp_stateMachine()",er->errnum,er->errmess,WARNING);
                                                }
                                                return IN_PROGRESS;
                                           }
                                           else if (rc == DONE)
                                           {
                                                rc = ftp_read_data(session_id);
                                                if ((e_check(rc,__LINE__)) == ERROR)
                                                {
                                                     ftp_stop(&session_id);
                                                     ftp_state = IDLE;
                                                     return ERROR;
                                                }
                                                else if (rc == IN_PROGRESS)
                                                {
                                                     if ((er = ui_set_progress_message(flags,FTP_Fetch_Stage)) != NULL)
                                                     {
                                                          error_handler(__FILE__,__LINE__,"ftp_stateMachine()",er->errnum,er->errmess,
                                                            WARNING);
                                                     }
                                                     ftp_state = READING_DATA;
                                                     return IN_PROGRESS;
                                                }
                                                else if (rc == DONE)
                                                {
                                                     /* UI translates FTP_Fetch_Stage to "Fetching image & writing flash..." */
                                                     if ((er = ui_set_progress_message(flags,FTP_Fetch_Stage)) != NULL)
                                                     {
                                                          error_handler(__FILE__,__LINE__,"ftp_stateMachine()",er->errnum,er->errmess,
                                                            WARNING);
                                                     }
                                                     ftp_state = READING_DATA;
                                                     return IN_PROGRESS;
                                                     /* It'll realise we're done on the next poll. */
                                                }
                                           }
                                           break;
                               case ABORT: /* Drop through */
                               case CLOSE: ftp_stop(&session_id);
                                           return DONE;
                                           break;
                               case POLL:  error_handler(__FILE__,__LINE__,"ftp_stateMachine()",0,
                                             "Invalid event (POLL) in state (IDLE).",WARNING);
                                           return ERROR;
                                           break;
                               default:    error_handler(__FILE__,__LINE__,"ftp_stateMachine()",0,
                                             "Unrecognised reason code in state (IDLE).",FATAL);
                             }
                             break;

       case OPENING_SESSION: switch (reason)
                             {
                               case START: error_handler(__FILE__,__LINE__,"ftp_stateMachine()",0,
                                             "Invalid event (START) in state (OPENING_SESSION).",FATAL);
                                           ftp_state = OPENING_SESSION;
                                           return ERROR;
                                           break;
                               case ABORT: /* Drop through */
                               case CLOSE: rc = ftp_stop(&session_id);
                                           if ((e_check(rc,__LINE__)) == ERROR)
                                           {
                                                ftp_state = IDLE;
                                                return ERROR;
                                           }
                                           else if (rc == IN_PROGRESS)
                                           {
                                                ftp_state = CLOSING_SESSION;
                                                return IN_PROGRESS;
                                           }
                                           else if (rc == DONE)
                                           {
                                                ftp_state = IDLE;
                                                return DONE;
                                           }
                                           break;
                               case POLL:  rc = ftp_status(session_id);
                                           if ((e_check(rc,__LINE__)) == ERROR)
                                           {
                                                ftp_stop(&session_id);
                                                ftp_state = IDLE;
                                                return ERROR;
                                           }
                                           else if (rc == IN_PROGRESS)
                                           {
                                                ftp_state = OPENING_SESSION;
                                                return IN_PROGRESS;
                                           }
                                           else if (rc == DONE)
                                           {
                                                rc = ftp_read_data(session_id);
                                                if ((e_check(rc,__LINE__)) == ERROR)
                                                {
                                                     ftp_stop(&session_id);
                                                     ftp_state = IDLE;
                                                     return ERROR;
                                                }
                                                else if (rc == IN_PROGRESS)
                                                {
                                                     if ((er = ui_set_progress_message(flags,FTP_Fetch_Stage)) != NULL)
                                                     {
                                                          error_handler(__FILE__,__LINE__,"ftp_stateMachine()",er->errnum,er->errmess,
                                                            WARNING);
                                                     }
                                                     ftp_state = READING_DATA;
                                                     return IN_PROGRESS;
                                                }
                                                else if (rc == DONE)
                                                {
                                                     /* UI translates FTP_Fetch_Stage to "Fetching image & writing flash..." */
                                                     if ((er = ui_set_progress_message(flags,FTP_Fetch_Stage)) != NULL)
                                                     {
                                                          error_handler(__FILE__,__LINE__,"ftp_stateMachine()",er->errnum,er->errmess,
                                                            WARNING);
                                                     }
                                                     ftp_state = READING_DATA;
                                                     return IN_PROGRESS;
                                                     /* It'll realise we're done on the next poll. */
                                                }
                                           }
                                           break;
                               default:    error_handler(__FILE__,__LINE__,"ftp_stateMachine()",0,
                                             "Unrecognised reason code in state (OPENING_SESSION).",FATAL);
                             }
                             break;
       case READING_DATA:    switch (reason)
                             {
                               case START: error_handler(__FILE__,__LINE__,"ftp_stateMachine()",0,
                                             "Invalid event (START) in state (READING_DATA).",FATAL);
                                           ftp_state = READING_DATA;
                                           return ERROR;
                                           break;
                               case ABORT: /* Drop through */
                               case CLOSE: rc = ftp_stop(&session_id);
                                           if ((e_check(rc,__LINE__)) == ERROR)
                                           {
                                                ftp_state = IDLE;
                                                return ERROR;
                                           }
                                           else if (rc == IN_PROGRESS)
                                           {
                                                ftp_state = CLOSING_SESSION;
                                                return IN_PROGRESS;
                                           }
                                           else if (rc == DONE)
                                           {
                                                ftp_state = IDLE;
                                                return DONE;
                                           }
                                           break;
                               case POLL:  rc = ftp_status(session_id);
                                           if ((e_check(rc,__LINE__)) == ERROR)
                                           {
                                                ftp_stop(&session_id);
                                                ftp_state = IDLE;
                                                return ERROR;
                                           }
                                           else if (rc == IN_PROGRESS)
                                           {
                                                ftp_state = READING_DATA;
                                                return IN_PROGRESS;
                                           }
                                           else if (rc == DONE)
                                           {
                                                ftp_state = READING_IDLE;
                                                return DONE;
                                           }
                                           break;
                               default:    error_handler(__FILE__,__LINE__,"ftp_stateMachine()",0,
                                             "Unrecognised reason code in state (READING_DATA).",FATAL);
                             }
                             break;
       case READING_IDLE:    switch (reason)
                             {
                               case START: rc = ftp_read_data(session_id);
                                           if ((rc != IN_PROGRESS) && (rc != DONE))
                                           {
                                                if ((er = ui_show_error(flags,translate(rc))) != NULL)
                                                {
                                                     error_handler(__FILE__,__LINE__,"ftp_stateMachine()",er->errnum,er->errmess,WARNING);
                                                }
                                                pause(0);
                                                err_abort = TRUE;
                                                ftp_stop(&session_id);
                                                ftp_state = CLOSING_SESSION;
                                                return ERROR;
                                           }
                                           else if (rc == IN_PROGRESS)
                                           {
                                                ftp_state = READING_DATA;
                                                return IN_PROGRESS;
                                           }
                                           else if (rc == DONE)
                                           {
                                                ftp_state = READING_IDLE;
                                                return DONE;
                                           }
                                           break;
                               case ABORT: /* Drop through */
                               case CLOSE: rc = ftp_stop(&session_id);
                                           if ((e_check(rc,__LINE__)) == ERROR)
                                           {
                                                ftp_state = IDLE;
                                                return ERROR;
                                           }
                                           else if (rc == IN_PROGRESS)
                                           {
                                                ftp_state = CLOSING_SESSION;
                                                return IN_PROGRESS;
                                           }
                                           else if (rc == DONE)
                                           {
                                                ftp_state = IDLE;
                                                return DONE;
                                           }
                                           break;
                               case POLL:  ftp_state = READING_IDLE;
                                           return DONE;
                                           break;
                               default:    error_handler(__FILE__,__LINE__,"ftp_stateMachine()",0,
                                             "Unrecognised reason code in state (READING_IDLE).",FATAL);
                             }
                             break;

       case CLOSING_SESSION: switch (reason)
                             {
                               case START: error_handler(__FILE__,__LINE__,"ftp_stateMachine()",0,
                                             "Invalid event (START) in state (CLOSING_SESSION).",FATAL);
                                           ftp_state = CLOSING_SESSION;
                                           return ERROR;
                                           break;
                               case POLL:  /* Drop through */
                               case ABORT: /* Drop through */
                               case CLOSE: rc = ftp_status(session_id);
                                           if ((e_check(rc,__LINE__)) == ERROR)
                                           {
                                                ftp_stop(&session_id);
                                                ftp_state = IDLE;
                                                return ERROR;
                                           }
                                           else if (rc == IN_PROGRESS)
                                           {
                                                ftp_state = CLOSING_SESSION;
                                                return IN_PROGRESS;
                                           }
                                           else if (rc == DONE)
                                           {
                                                ftp_stop(&session_id);
                                                ftp_state = IDLE;
                                                return DONE;
                                           }
                                           break;
                               default:    error_handler(__FILE__,__LINE__,"ftp_stateMachine()",0,
                                             "Unrecognised reason code in state (CLOSING_SESSION).",FATAL);
                             }
                             break;

       default:              error_handler(__FILE__,__LINE__,"ftp_stateMachine()",0,
                               "Unrecognised ftp state.",FATAL);
    }

    return ERROR;
}

/************************************************************************************/
/* Function:  e_check()                                                             */
/* Behaviour: Checks return codes for error.  Internal error codes are translated   */
/*            to those recognised by the UI Library before it is called to display  */
/*            the error.                                                            */
/* Requires:  - 'rc', which is the return code to check.                            */
/*            - 'line', which is the line at which the error occurred.              */
/* Returns:   Return code unchanged if not an error, otherwise ERROR is returned in */
/*            accordance with the state machine spreadsheet.                        */
/* Outputs:   On error, an error pop-up via the UI Library, error diagnostics to a  */
/*            log file (providing logging is turned on), and error diagnostics to a */
/*            system variable "err".                                                */
/************************************************************************************/
static int e_check(int rc,int line)
{
  int flags = 1;
  error_t report_err;
  _kernel_oserror *er;

    if ((rc != IN_PROGRESS) && (rc != DONE))
    {
         report_err = translate(rc);
         if ((er = ui_show_error(flags,report_err)) != NULL)
         {
              error_handler(__FILE__,line,"ftp_stateMachine()",er->errnum,
                er->errmess,WARNING);
         }
         else
         {
              pause(0);
         }
         rc = ERROR;
    }

    return rc;
}

/************************************************************************************/
/* Function:  total_bytes_fetched()                                                 */
/* Behaviour: Keeps a record of total bytes fetched so far (excluding header which  */
/*            is not part of the downloaded image).  Useful for estimating time     */
/*            remaining and for debugging.                                          */
/* Requires:  - 'request':                                                          */
/*               0 -> Increment total bytes fetched with 'amt',                     */
/*               1 -> Query total number of bytes fetched,                          */
/*               2 -> Reset total bytes fetched to zero.                            */
/*            - 'amt', which is the number of bytes fetched so far (unused when     */
/*               request is 1 or 2)                                                 */
/* Returns:   Current record of the number of bytes fetched so far.                 */
/************************************************************************************/
extern int total_bytes_fetched(int request,int amt)
{
  static int running_total = 0;

    switch (request)
    {
      case 0 : running_total += amt;
               break;
      case 1 : /* Do nothing */
               break;
      case 2 : running_total = 0;
               break;
      default: error_handler(__FILE__,__LINE__,"total_bytes_fetched()",0,"Unrecognised request",WARNING);
               break;
    }

    return running_total;
}

/************************************************************************************/
/* Function:  ftp_query_stream_end()                                                */
/* Behaviour: Provides a mechanism for distinguishing between decompression error   */
/*            caused by data not decompressing to give the required image size, and */
/*            decompression error due to some other cause.  Effectively gives us a  */
/*            way of knowing when the most likely cause of programming error is     */
/*            that the compressed image held on the server appears to have been     */
/*            truncated or has lost some of its end data.                           */
/* Returns:   TRUE if end of stream has been reached and there is no more data to   */
/*            fetch, FALSE otherwise.                                               */
/************************************************************************************/
extern int ftp_query_stream_end(void)
{
  if (no_more_data_to_fetch == TRUE)
      return TRUE;
  else
      return FALSE;
}

#ifndef FTP_SIMULATION

/************************************************************************************/
/* Function:  initialise_ftp_fetcher()                                              */
/* Behaviour: Initialise with the URL module and obtain a session identifier.  The  */
/*            URL module is a front end to the FTP fetcher.  The session identifier */
/*            is used in later interactions with the URL module.  Call URL_GetURL   */
/*            to instigate data transfer, then parse the header for server response */
/*            code.                                                                 */
/* Requires:  Address of a session identifier to set.                               */
/* Returns:   Call be reference returns the session identifier.                     */
/* Notes:     You need version 0.55 (Acorn version 0.55 as opposed to ANT version   */
/*            0.55) of the Resolver module for DNS to work.  Acorn versions are     */
/*            kept on the trunk.  ANT versions are kept on a branch.  If you're     */
/*            stuck with version 0.46 you need to insert an artifical delay after   */
/*            the call to dns_init() (10 seconds is plenty).                        */
/************************************************************************************/
static int initialise_ftp_fetcher(int *session_id)
{
  char *url = NULL;
  int flags = 0;
  int server_response_code;
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;

    if (ftp_fetcher_initialised == TRUE)
    {
        return DONE;
    }

    dns_init();

    if ((build_url(&url)) == ERROR)
    {
         return BUILD_URL_ERR;
    }

    regs.r[0] = flags;
    if ((er = _kernel_swi(URL_Register,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"initialise_ftp_fetcher()",er->errnum,er->errmess,WARNING);
         if (url != NULL)
         {
             free(NULL);
         }
         return URL_REGISTER_ERR;
    }
    *session_id = regs.r[1];

    #ifdef LOGFILE
    fprintf(logfile,"URL_GetURL -> %s\n",url);
    #endif

    regs.r[0] = flags;
    regs.r[1] = *session_id;
    regs.r[2] = GET_OBJECT_OPERATION;
    regs.r[3] = (int)url;
    regs.r[4] = NO_ADDITIONAL_DATA_TO_SEND;
    regs.r[5] = 2; /* If R0:0 is clear, R5 must be 2. */
    if ((er = _kernel_swi(URL_GetURL,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"initialise_ftp_fetcher()",er->errnum,er->errmess,WARNING);
         if (url != NULL)
         {
             free(url);
         }
         return URL_GETURL_ERR;
    }

    if (url != NULL)
    {
        free(url);
    }

    /* At this stage we still don't know if the remote file really exists.*/

    server_response_code = parse_header(*session_id);

    switch (server_response_code)
    {
      case FTP_AUTHENTICATION_FAILURE: return FTP_AUTHENTICATION_FAILURE;
                                       break;
      case REMOTE_FILE_DOES_NOT_EXIST: return REMOTE_FILE_DOES_NOT_EXIST;
                                       break;
      case SERVER_RESPONSE_OK:         break;
      case ERROR:                      return FTP_CONNECTION_FAILURE;
                                       break;
      default:                         error_handler(__FILE__,__LINE__,"initialise_ftp_fetcher()",server_response_code,
                                         "Unexpected server response code",WARNING);
                                       return FTP_CONNECTION_FAILURE;
    }

    ftp_fetcher_initialised = TRUE;
    return DONE;

}

/************************************************************************************/
/* Function:  dns_init()                                                            */
/* Behaviour: Configures the resolver using DNS address(es) given by the user.      */
/************************************************************************************/
static void dns_init(void)
{
  _kernel_oserror *er = NULL;
  _kernel_swi_regs regs;
  char *command = NULL;

    if (usr_details == NULL)
    {
        error_handler(__FILE__,__LINE__,"dns_init()",0,"Setup details are missing",WARNING);
        return;
    }

    if (usr_details->isp.dns == NULL)
    {
     /* The UI Library does not allow the upgrade screen to be reached until one or
        two DNS addresses have been entered, so this section of code should never be
        reached.  If it is, error_handler() notes the error for the attention of
        developers during development and the user will be informed of the problem
        when FTP fails to connect. */
        error_handler(__FILE__,__LINE__,"dns_init()",0,"DNS addresses have not been specified",WARNING);
        return;
    }

    if ((command = calloc(strlen("Set Inet$Resolvers ") + strlen(usr_details->isp.dns) + 2,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"dns_init()",0,"Not enough memory to configure the resolver.",WARNING);
         return;
    }

    sprintf(command,"Set Inet$Resolvers %s",usr_details->isp.dns);

    regs.r[0] = (int)command;
    if ((er = _kernel_swi(OS_CLI,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"dns_init()",er->errnum,er->errmess,WARNING);
         if (command != NULL)
         {
             free(command);
         }
         return;
    }

    if (command != NULL)
    {
        free(command);
    }

    /* Now set Inet$LocalDomain.  This must be set correctly for DNS to work. */
    if (usr_details->isp.domain == NULL)
    {
     /* The UI Library does not allow the upgrade screen to be reached unless */
     /* a local domain has been entered, so this section of code should never */
     /* be reached.  If it is, error_handler() notes the error for the        */
     /* attention of engineers during development and the user will be        */
     /* informed of the problem when FTP fails to connect.                    */
        error_handler(__FILE__,__LINE__,"dns_init()",0,"A local domain has not been specified.",WARNING);
        return;
    }

    if ((command = calloc(strlen("Set Inet$LocalDomain ") + strlen(usr_details->isp.domain) + 2,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"dns_init()",0,"Insufficient memory for local domain",WARNING);
         return;
    }

    sprintf(command,"Set Inet$LocalDomain %s",usr_details->isp.domain);

    regs.r[0] = (int)command;
    if ((er = _kernel_swi(OS_CLI,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"dns_init()",er->errnum,er->errmess,WARNING);
         if (command != NULL)
         {
             free(command);
         }
         return;
    }

    if (command != NULL)
    {
        free(command);
    }

    /* Now tell the resolver to read the new DNS settings. */
    regs.r[0] = (int)"ResolverConfig";
    if ((er = _kernel_swi(OS_CLI,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"dns_init()",er->errnum,er->errmess,WARNING);
    }

    return;
}

/************************************************************************************/
/* Function:  build_url()                                                           */
/* Behaviour: Merges FTP username and password into the FTP URL in the (standard)   */
/*            format required by the FTP fetcher.  Example: username "srose", pass- */
/*            word "xxxxx", URL "ftp://ftp.acorn.co.uk" becomes "ftp://srose:xxxxx  */
/*            @ftp.acorn.co.uk".                                                    */
/* Requires:  Null initialised URL string pointer.                                  */
/* Returns:   'DONE' if the url was built successfully, otherwise returns 'ERROR'.  */
/*            Call by reference returns the modified URL.  The caller should free   */
/*            the URL when finished.                                                */
/************************************************************************************/
static int build_url(char **url)
{
  int url_len = 0;
  int uname_len = 0;
  int passwd_len = 0;
  extern setup_details_t *usr_details;

    if (usr_details == NULL)
    {
        error_handler(__FILE__,__LINE__,"build_url()",0,"No user details from which to extract a URL",WARNING);
        return ERROR;
    }
    if (usr_details->ftp.url == NULL)
    {
        error_handler(__FILE__,__LINE__,"build_url()",0,"FTP URL is missing",WARNING);
        return ERROR;
    }
    url_len = strlen(usr_details->ftp.url);
    if (usr_details->ftp.username != NULL)
    {
        uname_len = strlen(usr_details->ftp.username);
    }
    if (usr_details->ftp.password != NULL)
    {
        passwd_len = strlen(usr_details->ftp.password);
    }
    if ((*url = calloc(url_len + uname_len + passwd_len + strlen(":@") + 1, sizeof(char))) == NULL)
    {
        error_handler(__FILE__,__LINE__,"build_url()",0,"Insufficient memory",WARNING);
        return ERROR;
    }
    if ((strncmp(usr_details->ftp.url,"ftp://",strlen("ftp://"))) != 0)
    {
        error_handler(__FILE__,__LINE__,"build_url()",0,"URL does not start as ftp://",WARNING);
        free (*url);
        *url = NULL;
        return ERROR;
    }
    sprintf(*url,"ftp://");
    if (uname_len > 0)
    {
        strncat(*url,usr_details->ftp.username,strlen(usr_details->ftp.username));
    }
    strncat(*url,":",sizeof(char));
    if (passwd_len > 0)
    {
        strncat(*url,usr_details->ftp.password,strlen(usr_details->ftp.password));
    }
    strncat(*url,"@",sizeof(char));
    strncat(*url,usr_details->ftp.url+strlen("ftp://"),strlen(usr_details->ftp.url));

    return DONE;
}

/************************************************************************************/
/* Function:  parse_header()                                                        */
/* Behaviour: Downloaded image data is preceded by a section of header data.  We    */
/*            parse the header to determine where it ends and where Main OS image   */
/*            data begins.  Header data is discarded to ensure that it is not saved */
/*            as Main OS image data.  Before discarding we look for the server      */
/*            response code, which will always appear in the first line of the      */
/*            header, following the first white space(s), e.g. HTTP/1.0 401 ....    */
/*            gives a response code of 401 (failed authentication).  If the remote  */
/*            file does not exist, URL_ReadData fails and we are unable to parse    */
/*            the header for a 404 (file not found) return code, so we search for   */
/*            "No such file or directory" in the error message returned from URL_   */
/*            ReadData.                                                             */
/* Requires:  FTP session identifier.                                               */
/* Returns:   Server response code.                                                 */
/************************************************************************************/
static int parse_header(int session)
{
  char c;
  int fetched = FALSE;
  char server_response_str[] = "000\0";
  int server_response_code = -1;
  _kernel_oserror *er = NULL;

    do
    {  if ((er = readhdr(session,&c,1,&fetched)) != NULL)
       {
            if ((strstr(er->errmess,"No such file or directory")) != NULL)
            {
                 error_handler(__FILE__,__LINE__,"parse_header()",er->errnum,er->errmess,WARNING);
                 return REMOTE_FILE_DOES_NOT_EXIST;
            }
            else
            {
                 error_handler(__FILE__,__LINE__,"parse_header()",er->errnum,er->errmess,WARNING);
                 return ERROR;
            }
       }
    }  while (c != ' ');

    do
    {
       if ((er = readhdr(session,&c,1,&fetched)) != NULL)
       {
            error_handler(__FILE__,__LINE__,"parse_header()",er->errnum,er->errmess,WARNING);
            return ERROR;
       }
    }  while (c == ' ');

    if (isdigit(c))
    {
        server_response_str[0] = c;
    }
    else
    {
        error_handler(__FILE__,__LINE__,"parse_header()",0,"Unexpected FTP header format",WARNING);
        return ERROR;
    }

    do
    {
       if ((er = readhdr(session,server_response_str + 1,1,&fetched)) != NULL)
       {
            error_handler(__FILE__,__LINE__,"parse_header()",er->errnum,er->errmess,WARNING);
            return ERROR;
       }
    }  while (fetched == FALSE);

    do
    {
       if ((er = readhdr(session,server_response_str + 2,1,&fetched)) != NULL)
       {
            error_handler(__FILE__,__LINE__,"parse_header()",er->errnum,er->errmess,WARNING);
            return ERROR;
       }
    }  while (fetched == FALSE);

    if ((server_response_code = atoi(server_response_str)) != SERVER_RESPONSE_OK)
    {
        return server_response_code;
    }

    /* Now look for end of header sequence */

    start_again:  do
                  {
                     readhdr(session,&c,1,&fetched);
                  }  while (c != 0x0D);

                  readhdr(session,&c,1,&fetched);
                  if (c != 0x0A)
                      goto start_again;

                  readhdr(session,&c,1,&fetched);
                  if (c != 0x0D)
                      goto start_again;

                  readhdr(session,&c,1,&fetched);
                  if (c != 0x0A)
                      goto start_again;

                  /* Subsequent fetches will now download Main OS image data */

    return server_response_code;

}

/************************************************************************************/
/* Function:  readhdr()                                                             */
/* Behaviour: Streams in header data as required by parse_header() above.           */
/* Requires:  Session identifier, buffer to store fetched data, amt of data to      */
/*            fetch in bytes, and the address of a fetched variable to indicate     */
/*            whether or not all the data has been fetched.                         */
/************************************************************************************/
static _kernel_oserror *readhdr(int session,char *buff,int amt,int *fetched)
{
  _kernel_oserror *er = NULL;
  _kernel_swi_regs regs;

    regs.r[0] = 0;
    regs.r[1] = session;
    regs.r[2] = (int)buff;
    regs.r[3] = amt;
    if ((er = _kernel_swi(URL_ReadData,&regs,&regs)) != NULL)
    {
         return er;
    }

    if (regs.r[4] == amt)
    {
        *fetched = TRUE;
    }
    else
    {
        *fetched = FALSE;  /* No data transferred to buffer */
    }

    return NULL;
}

/************************************************************************************/
/* Function:  ftp_stop()                                                            */
/* Behaviour: Deregisters the session from the URL module.  The session identifier  */
/*            ceases to be valid and becomes available for re-issue on a subsequent */
/*            call to SWI URL_Register.                                             */
/* Requires:  Session identifier for the session that is to be closed.              */
/* Returns:   'DONE'.                                                               */
/************************************************************************************/
static int ftp_stop(int *session_id)
{
  int flags = 0;
  _kernel_oserror *er = NULL;
  _kernel_swi_regs regs;

    if (*session_id == -1)
    {
        return DONE;
    }

    regs.r[0] = flags;
    regs.r[1] = *session_id;
    if ((er = _kernel_swi(URL_Deregister,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"ftp_stop()",er->errnum,er->errmess,WARNING);
      /* error_handler() notes the error for the attention of engineers during development,
         but this isn't something the user needs to be concerned about so carry on as normal. */
    }
    *session_id = -1;

    /* Reset local state variables */
    p = NULL;
    bytes_read = 0;
    status = STATUS_IDLE;
    bytes_transferred_to_buffer = 0;
    total_bytes_fetched(2,0);
    read_amt = FTP_BUFFER_SIZE;
    ftp_fetcher_initialised = FALSE;
    no_more_data_to_fetch = FALSE;

    return DONE;
}

/************************************************************************************/
/* Function:       ftp_status()                                                     */
/* Behaviour:*/
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static int ftp_status(int session_id)
{
  extern z_stream stream;
  int flags = 0;
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;
  unsigned int stat;

    if (no_more_data_to_fetch == TRUE)
    {
        return DONE;
    }

    if (status == FETCHING_DATA)
    {
        if (no_more_data_to_fetch == TRUE)
        {
            return DONE;
        }

       /* Although at this point ftp_read_data() has been called, it's possible that no
          data has been received yet, and therefore avail_in may well still be zero */

        if (((int)p + read_amt) > ((int)(ftp_buf) + FTP_BUFFER_SIZE))
        {
            error_handler(__FILE__,__LINE__,"ftp_status()",0,"Bad memory access about to occur",WARNING);
            return FTP_FETCH_ERR;
        }

        regs.r[0] = flags;
        regs.r[1] = session_id;
        regs.r[2] = (int)p;
        regs.r[3] = read_amt;
        if ((er = _kernel_swi(URL_ReadData,&regs,&regs)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"ftp_status()",er->errnum,er->errmess,WARNING);
             return FTP_FETCH_ERR;
        }
        stat = (unsigned int)regs.r[0];
        bytes_transferred_to_buffer = regs.r[4];

        if (bytes_transferred_to_buffer > 0)
        {
            bytes_read += bytes_transferred_to_buffer;
            stream.avail_in = bytes_read; /* Tell zlib more data is available in its input buffer */
            read_amt -= bytes_transferred_to_buffer;
            total_bytes_fetched(0,bytes_transferred_to_buffer);

            #ifdef DEVELOPMENT
            _kernel_swi(OS_WriteI+4,&regs,&regs);
            _kernel_swi(OS_WriteI+30,&regs,&regs);
            _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
            printf("%d, total = %d\n",regs.r[0],total_bytes_fetched(1,0));
            _kernel_swi(OS_WriteI+5,&regs,&regs);
            #endif
        }
        else
        {
         /* No data was received.  Check that we still have a connection. */

            #ifdef DEVELOPMENT
            _kernel_swi(OS_WriteI+4,&regs,&regs);
            _kernel_swi(OS_WriteI+30,&regs,&regs);
            _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
            printf("%d, total = %d\n",regs.r[0],total_bytes_fetched(1,0));
            _kernel_swi(OS_WriteI+5,&regs,&regs);
            #endif

            #ifndef PPP_SIMULATION
            regs.r[0] = 1;
            regs.r[1] = 0;  /* Ben says this should be zero */
            if ((er = _kernel_swi(PPP_Status,&regs,&regs)) != NULL)
            {
                 error_handler(__FILE__,__LINE__,"ftp_status()",er->errnum,er->errmess,WARNING);
                 return FTP_FETCH_ERR;
            }
            if (regs.r[2] == 0)
            {
                error_handler(__FILE__,__LINE__,"ftp_status()",0,"Connection lost",WARNING);
                return CONNECTION_LOSS;
            }
            #endif
        }

        if (stat & ALL_DATA_RECEIVED)
        {
               /* End of stream, no more data to fetch */
                  status = DATA_FETCHED;
                  no_more_data_to_fetch = TRUE;
        }

        if ((bytes_read == FTP_BUFFER_SIZE) || (no_more_data_to_fetch == TRUE))
        {
            status = DATA_FETCHED;  /* Reset ourselves for next time round, but as far as zlib is concerned,    */
            bytes_read = 0;         /* it still has a full buffer of data to consume.  zlib resets stream.      */
            p = ftp_buf;            /* avail_in to zero when inflate() has consumed all data in the FTP buffer. */
            return DONE;
        }
        else
        {
            status = FETCHING_DATA;
            p += bytes_transferred_to_buffer;
            return IN_PROGRESS;
        }
    }
    error_handler(__FILE__,__LINE__,"ftp_status()",0,"Unexpected path of execution.",WARNING);
    return FTP_FETCH_ERR;
}

/************************************************************************************/
/* Function: ftp_read_data()                                                        */
/* Behaviour: Receives compressed data into the FTP buffer.  The FTP buffer is the  */
/*            input buffer to the zlib decompression library.  zlibs output buffer  */
/*            may become full whilst there is still data in the input FTP buffer.   */
/*            If this happens postpone the FTP fetch until zlib is ready to receive */
/*            a full buffer of data.                                                */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static int ftp_read_data(int session_id)
{
  extern z_stream stream;
  int flags = 0;
  unsigned int stat;
  _kernel_oserror *er = NULL;
  _kernel_swi_regs regs;

    if (no_more_data_to_fetch == TRUE)
    {
        return DONE;
    }
    if (p == NULL)
    {
        p = ftp_buf;
        stream.avail_in = 0;
    }

    /* Other than in initialisation, only refill the FTP buffer when inflate() has
       returned avail_in to zero, i.e. when zlib has consumed all data in the FTP
       buffer. */

    if (stream.avail_in != 0)
    {
        return DONE;
    }
    if (((int)p + read_amt) > ((int)(ftp_buf) + FTP_BUFFER_SIZE))
    {
        error_handler(__FILE__,__LINE__,"ftp_read_data()",0,"Bad memory access about to occur",WARNING);
        return FTP_FETCH_ERR;
    }

    regs.r[0] = flags;
    regs.r[1] = session_id;
    regs.r[2] = (int)p;
    regs.r[3] = read_amt;
    if ((er = _kernel_swi(URL_ReadData,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"ftp_read_data()",er->errnum,er->errmess,WARNING);
         return FTP_FETCH_ERR;
    }
    stat = (unsigned int)regs.r[0];
    bytes_transferred_to_buffer = regs.r[4];

    if (bytes_transferred_to_buffer > 0)
    {
        bytes_read += bytes_transferred_to_buffer;
        stream.avail_in = bytes_read; /* Tell zlib more data is available in its input buffer. */
        read_amt -= bytes_transferred_to_buffer;
        total_bytes_fetched(0,bytes_transferred_to_buffer);
    }

    if (stat & ALL_DATA_RECEIVED)
    {
     /* End of stream, no more data to fetch. */
        status = DATA_FETCHED;
        no_more_data_to_fetch = TRUE;
    }

    if ((bytes_read == FTP_BUFFER_SIZE) || (no_more_data_to_fetch == TRUE))
    {
        status = DATA_FETCHED;  /* Reset ourselves for next time round, but as far as zlib is concerned     */
        bytes_read = 0;         /* it still has a full buffer of data to consume.  zlib resets stream.      */
        p = ftp_buf;            /* avail_in to zero when inflate() has consumed all data in the FTP buffer. */
        return DONE;
    }
    else
    {
        status = FETCHING_DATA;
        p += bytes_transferred_to_buffer;
        return IN_PROGRESS;
    }
    error_handler(__FILE__,__LINE__,"ftp_read_data()",0,"Unexpected path of execution.",WARNING);
    return FTP_FETCH_ERR;

}

#else

/************************************************************************************/
/* Function: initialise_ftp_fetcher()                                               */
/* Behaviour: Simulates ftp fetcher initialisation.                                 */
/* Prerequisites: */
/* Requires: */
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static int initialise_ftp_fetcher(int *session_id)
{
  if (ftp != NULL)
  {
      return DONE;  /* We're already initialised. */
  }

  if ((ftp = fopen("MainOS","rb")) == NULL)
  {
       error_handler(__FILE__,__LINE__,"initialise_ftp_fetcher()",0,"Could not open MainOS (filename hardcoded)",WARNING);
       return REMOTE_FILE_DOES_NOT_EXIST;
  }
  else
  {
       return DONE;
  }
}

/************************************************************************************/
/* Function: ftp_read_data()                                                        */
/* Behaviour: Receives compressed data into the FTP buffer.  The FTP buffer is the  */
/*            input buffer to the zlib decompression library.  zlibs output buffer  */
/*            may become full whilst there is still data in the input FTP buffer.   */
/*            If this happens postpone the FTP fetch until zlib is ready to receive */
/*            a full buffer of data.                                                */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static int ftp_read_data(int session_id)
{
  int simulate_amt_fetched = FTP_BUFFER_SIZE/4;
  extern z_stream stream;


    if (no_more_data_to_fetch == TRUE)
    {
        return DONE;
    }

    if (p == NULL)
    {
        p = ftp_buf;
        stream.avail_in = 0;
    }

    /* Other than in initialisation, only refill the FTP buffer when inflate() has returned
       avail_in to zero, i.e. when zlib has consumed all data in the FTP buffer. */

    if (stream.avail_in != 0)
    {
        return DONE;
    }

    if ((FTP_BUFFER_SIZE % simulate_amt_fetched) != 0)
    {
         error_handler(__FILE__,__LINE__,"ftp_read_data()",0,"FTP Simulation error",WARNING);
         return FTP_FETCH_ERR;
    }

    if (ftp == NULL)
    {
        error_handler(__FILE__,__LINE__,"ftp_read_data()",0,"Attempted read on null file handle",WARNING);
        return FTP_FETCH_ERR;
    }

    if (((int)p + simulate_amt_fetched) > ((int)(ftp_buf) + FTP_BUFFER_SIZE))
    {
         error_handler(__FILE__,__LINE__,"ftp_read_data()",0,"Bad memory access about to happen",FATAL);
         return FTP_FETCH_ERR;  /* Not reached when error level is 'FATAL' */
    }

    if ((fread(p,sizeof(char),simulate_amt_fetched,ftp)) != simulate_amt_fetched)
    {
         if (feof(ftp))
         {
             no_more_data_to_fetch = TRUE;
         }
         else
         {
             error_handler(__FILE__,__LINE__,"ftp_read_data()",simulate_amt_fetched,
               "Unexpected simulate_amt_fetched value",WARNING);
             return FTP_FETCH_ERR;
         }
    }

    bytes_read += simulate_amt_fetched;
    stream.avail_in = bytes_read;  /* Tell zlib more data is available in its input buffer. */

    if (bytes_read == FTP_BUFFER_SIZE)
    {
        status = DATA_FETCHED;
        bytes_read = 0;    /* Reset ourselves for next time round, but as far as zlib is concerned     */
        p = ftp_buf;       /* it still has a full buffer of data to consume.  zlib resets stream.      */
        return DONE;       /* avail_in to zero when inflate() has consumed all data in the FTP buffer. */
    }
    else
    {
        status = FETCHING_DATA;
        p += simulate_amt_fetched;
        return IN_PROGRESS;
    }
}

/************************************************************************************/
/* Function:       ftp_status()                                                     */
/* Behaviour:*/
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static int ftp_status(int session_id)
{
  int simulate_amt_fetched = FTP_BUFFER_SIZE/4; /* Must be same as ftp_read_data() */
  static int timer_started = 0;
  static time_t save_time;
  int rc;
  extern z_stream stream;

    if (status == FETCHING_DATA)
    {
     /* We've kicked off the fetch with an initial call to ftp_read_data().  We want
        to check how much data has arrived, so we simulate the arrival of more data.*/


        if (no_more_data_to_fetch == TRUE)
        {
            return DONE;
        }

        if (p == NULL)
        {
            p = ftp_buf + simulate_amt_fetched;  /* Don't think this is right. (Doesn't get run under current simulation tho).*/
        }

        if (stream.avail_in == 0)
        {
            error_handler(__FILE__,__LINE__,"ftp_status()",0,
              "Expected to be in ftp_read_data() if it's the first fill",WARNING);
            return FTP_FETCH_ERR;
        }

        if (ftp == NULL)
        {
            error_handler(__FILE__,__LINE__,"ftp_status()",0,"Attempted read on null file handle",WARNING);
            return FTP_FETCH_ERR;
        }

        if (((int)p + simulate_amt_fetched) > ((int)(ftp_buf) + FTP_BUFFER_SIZE))
        {
             error_handler(__FILE__,__LINE__,"ftp_read_data()",0,"Bad memory access about to happen",FATAL);
             return FTP_FETCH_ERR;  /* Not reached when error level is 'FATAL'. */
        }

        if ((fread(p,sizeof(char),simulate_amt_fetched,ftp)) != simulate_amt_fetched)
        {
             if (feof(ftp))
             {
                 no_more_data_to_fetch = TRUE;
             }
             else
             {
                 error_handler(__FILE__,__LINE__,"ftp_read_data()",simulate_amt_fetched,
                   "Unexpected simulate_amt_fetched value",WARNING);
                 return FTP_FETCH_ERR;
             }
        }

        bytes_read += simulate_amt_fetched;
        stream.avail_in = bytes_read;  /* Tell zlib more data is available in its input buffer. */

        if (bytes_read == FTP_BUFFER_SIZE)
        {
            status = DATA_FETCHED;
            bytes_read = 0;    /* Reset ourselves for next time round, but as far as zlib is concerned     */
            p = ftp_buf;       /* it still has a full buffer of data to consume.  zlib resets stream.      */
            return DONE;       /* avail_in to zero when inflate() has consumed all data in the FTP buffer. */
        }
        else
        {
            status = FETCHING_DATA;
            p += simulate_amt_fetched;
            return IN_PROGRESS;
        }
    }
    else
    {
      delay_simulation(&timer_started,&save_time,&rc);
      return rc;
    }

    error_handler(__FILE__,__LINE__,"ftp_status()",0,"Unexpected path of execution.",WARNING);

    return FTP_FETCH_ERR;
}

/************************************************************************************/
/* Function:       ftp_stop()                                                       */
/* Behaviour:*/
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static int ftp_stop(int session_id)
{
  if (ftp != NULL)
  {
      fclose(ftp);
      ftp = NULL;
  }
  return DONE;
}

/************************************************************************************/
/* Function: delay_simulation()                                                     */
/* Behaviour: Allows us to simulate how long various tasks are expected to take,    */
/*            and to exercise IN_PROGRESS return codes.  Allows the UI simulator to */
/*            be slowed to a decent speed for observation and testing during devel- */
/*            opment.                                                               */
/* Prerequisites: None.                                                             */
/* Requires: - 'timer_started', which must be 0 on the first call.                  */
/*           - 'save_time', which is used to evauluate elapsed time for a specific  */
/*              activity.                                                           */
/*           - 'rc', which is used to return DONE or IN_PROGRESS, depending upon    */
/*              elapsed time.                                                       */
/* Example usage: static int ftp_read_data(void)                                    */
/*                {                                                                 */
/*                  #ifdef FTP_SIMULATION                                           */
/*                  static int timer_started = 0;                                   */
/*                  static time_t save_time;                                        */
/*                  int rc;                                                         */
/*                     delay_simulation(&timer_started,&save_time,&rc);             */
/*                     return rc;                                                   */
/*                  #endif                                                          */
/*                }                                                                 */
/************************************************************************************/
static void delay_simulation(int *timer_started,time_t *save_time,int *rc)
{
  int lapsed_time;  /* in secs */

    if (*timer_started == 0)
    {
        *save_time = time(NULL);
        *timer_started = 1;
        *rc = IN_PROGRESS;
    }
    else
    {
        lapsed_time = (int)(difftime(time(NULL),*save_time));
        if (lapsed_time > TIME_DELAY)
        {
            *rc = DONE;
            *timer_started = 0;
        }
        else
        {
            *rc = IN_PROGRESS;
        }
    }
}

#endif

