/************************************************************************************/
/*                                                                                  */
/*  File: dial.c                                                                    */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  xx-Jul-1998  SR        Created                                                  */
/*                                                                                  */
/************************************************************************************/

#include "kernel.h"
#include "ui.h"
#include "errors.h"
#include "main.h"
#include <stdlib.h>
#include <time.h>
#include "dial.h"

enum dial_state {IDLE,
                 CONNECTING,
                 CONNECTED,
                 HANGING_UP};

static int dial_state = IDLE;

static int initialise_with_dialler_and_dial_ISP(void);
static int tell_dialler_to_hang_up(void);
static int check_dialler_status_word(void);
static void reset_modem(void);
static int e_check(int rc,int line);

#ifdef DIALLER_SIMULATION
static void delay_simulation(int *timer_started,time_t *save_time,int *rc);
#endif

/************************************************************************************/
/* Function:  dialler_stateMachine()                                                */
/* Behaviour: .... */
/*            Error reporting to the user is done via e_check().  e_check()         */
/*            translates internal error codes to those recognised by the UI Library.*/
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/

extern int dialler_stateMachine(int reason)
{
  int rc;
  unsigned int flags = 0;
  _kernel_oserror *er;

    switch (dial_state)
    {
       case IDLE:        switch (reason)
                         {
                           case START: rc = initialise_with_dialler_and_dial_ISP();
                                       if ((e_check(rc,__LINE__)) == ERROR)
                                       {
                                            return ERROR;
                                       }
                                       else if (rc == IN_PROGRESS)
                                       {
                                            dial_state = CONNECTING;
                                            if ((er = ui_set_progress_message(flags,ISP_Dial_Stage)) != NULL)
                                            {
                                                 error_handler(__FILE__,__LINE__,"dialler_stateMachine()",er->errnum,
                                                   er->errmess,WARNING);
                                            }
                                            return IN_PROGRESS;
                                       }
                                       else if (rc == DONE)
                                       {
                                            dial_state = CONNECTED;
                                            return DONE;
                                       }
                                       break;
                           case ABORT: /* Drop through */
                           case CLOSE: return DONE;
                                       break;
                           case POLL:  error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                             "Invalid event (POLL) in state (IDLE).",FATAL);
                                       return ERROR;
                                       break;
                           case HANGUP:return DONE;
                                       break;
                           default:    error_handler(__FILE__,__LINE__,"dialler_stateMachine()",reason,
                                         "Unrecognised reason code passed in state (IDLE).",FATAL);
                         }
                         break;

       case CONNECTING:  switch (reason)
                         {
                           case START: error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Invalid event (START) in state (CONNECTING).",FATAL);
                                       return ERROR;
                                       break;
                           case ABORT: /* Drop through */
                           case HANGUP:rc = tell_dialler_to_hang_up();
                                       if ((e_check(rc,__LINE__)) == ERROR)
                                       {
                                            return ERROR;
                                       }
                                       else if (rc == IN_PROGRESS)
                                       {
                                            dial_state = HANGING_UP;
                                            return IN_PROGRESS;
                                       }
                                       else if (rc == DONE)
                                       {
                                            dial_state = IDLE;
                                            return DONE;
                                       }
                                       break;
                           case POLL:  rc = check_dialler_status_word();
                                       if ((e_check(rc,__LINE__)) == ERROR)
                                       {
                                            reset_modem();
                                            return ERROR;
                                       }
                                       else if (rc == IN_PROGRESS)
                                       {
                                            return IN_PROGRESS;
                                       }
                                       else if (rc == DONE)
                                       {
                                            dial_state = CONNECTED;
                                            return DONE;
                                       }
                                       break;
                           default:    error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Unrecognised reason code passed in state (CONNECTING).",FATAL);
                         }
                         break;

       case CONNECTED:   switch (reason)
                         {
                           case START: error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Invalid event (START) in state (CONNECTED).",FATAL);
                                       return ERROR;
                                       break;
                           case ABORT: /* Drop through */
                           case HANGUP:rc = tell_dialler_to_hang_up();
                                       if ((e_check(rc,__LINE__)) == ERROR)
                                       {
                                            return ERROR;
                                       }
                                       else if (rc == IN_PROGRESS)
                                       {
                                            dial_state = HANGING_UP;
                                            return IN_PROGRESS;
                                       }
                                       else if (rc == DONE)
                                       {
                                            dial_state = IDLE;
                                            return DONE;
                                       }
                                       break;
                           case POLL:  error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Invalid event (POLL) in state (CONNECTED).",FATAL);
                                       return ERROR;
                                       break;
                           default:    error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Unrecognised reason code in state (CONNECTED).",FATAL);
                         }
                         break;

       case HANGING_UP:  switch (reason)
                         {
                           case START: error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Invalid event (START) in state (HANGING_UP).",FATAL);
                                       return ERROR;
                                       break;
                           case ABORT: /* Drop through */
                           case HANGUP:/* Drop through */
                           case POLL:  rc = check_dialler_status_word();
                                       if ((e_check(rc,__LINE__)) == ERROR)
                                       {
                                            return ERROR;
                                       }
                                       else if (rc ==IN_PROGRESS)
                                       {
                                            return IN_PROGRESS;
                                       }
                                       else if (rc == DONE)
                                       {
                                            dial_state = IDLE;
                                            return DONE;
                                       }
                                       break;
                           default:    error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Unrecognised reason code in state (HANGING_UP).",FATAL);
                         }
                         break;

       default:          error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Unrecognised dial state.",FATAL);
    }

    return ERROR;
}

/************************************************************************************/
/* Function:  initialise_with_dialler_and_dial_ISP()                                */
/* Behaviour: */
/*            The correct context for calling ui_show_error() is from within the    */
/*            calling function.  Therefore, error codes should be returned to the   */
/*            caller.  The caller ensures that internal error codes are translated  */
/*            to those recognised by the UI Library before ui_show_error() is       */
/*            called.                                                               */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
static int initialise_with_dialler_and_dial_ISP(void)
{
  #ifdef DIALLER_SIMULATION
  static int timer_started = 0;
  static time_t save_time;
  int rc;

    delay_simulation(&timer_started,&save_time,&rc);
    return rc;
  #endif
}

/************************************************************************************/
/* Function:  tell_dialler_to_hang_up()                                             */
/* Behaviour: */
/*            Error reporting to the user is as described in initialise_dialler_and */
/*            dial_ISP().                                                           */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
static int tell_dialler_to_hang_up(void)
{
  #ifdef DIALLER_SIMULATION
  static int timer_started = 0;
  static time_t save_time;
  int rc;

    delay_simulation(&timer_started,&save_time,&rc);
    return rc;
  #endif
}

/************************************************************************************/
/* Function:       check_dialler_status_word()                                      */
/* Behaviour: */
/*            Error reporting to the user is as described in initialise_dialler_and */
/*            dial_ISP().                                                           */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
static int check_dialler_status_word(void)
{
  #ifdef DIALLER_SIMULATION
  static int timer_started = 0;
  static time_t save_time;
  int rc;

    delay_simulation(&timer_started,&save_time,&rc);
    return rc;
  #endif
}

/************************************************************************************/
/* Function:       reset_modem()                                                    */
/* Behaviour: */
/*            Error reporting to the user is as described in initialise_dialler_and */
/*            dial_ISP().                                                           */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
static void reset_modem(void)
{
    return;
}

/************************************************************************************/
/* Function:  e_check()                                                             */
/* Behaviour: Checks return codes for error.  Internal error codes are translated   */
/*            to those recognised by the UI Library before it is called to display  */
/*            the error.                                                            */
/* Requires:  - 'rc', which is the return code to check.                            */
/*            - 'line', which is the line at which the error occurred.              */
/* Returns:   Return code unchanged if not an error, otherwise ERROR is returned in */
/*            accordance with the state machine spreadsheet.                        */
/* Outputs:   On error, an error pop-up via the UI Library, error diagnostics to a  */
/*            log file (providing logging is turned on), and error diagnostics to a */
/*            system variable "err".                                                */
/************************************************************************************/
static int e_check(int rc,int line)
{
  int flags = 0;
  error_t report_err;
  _kernel_oserror *er;
  static int n = 1;

    //if (n < 3)
    //    rc = -1;
    if ((rc != IN_PROGRESS) && (rc != DONE))
    {
         report_err = translate(rc);
         //if (n < 3)
         //    report_err = Connection_Failure;
         if ((er = ui_show_error(flags,report_err)) != NULL)
         {
              error_handler(__FILE__,line,"dialler_stateMachine()",er->errnum,
                er->errmess,WARNING);
         }
         dial_state = IDLE;
         rc = ERROR;
    }

    n++;
    return rc;
}

/************************************************************************************/
/* Function: delay_simulation()                                                     */
/* Behaviour: Allows us to simulate how long various tasks are expected to take,    */
/*            and to exercise IN_PROGRESS return codes.  Allows the UI simulator to */
/*            be slowed to a decent speed for observation and testing during devel- */
/*            opment.                                                               */
/* Prerequisites: None.                                                             */
/* Requires: - 'timer_started', which must be 0 on the first call.                  */
/*           - 'save_time', which is used to evauluate elapsed time for a specific  */
/*              activity.                                                           */
/*           - 'rc', which is used to return DONE or IN_PROGRESS, depending upon    */
/*              elapsed time.                                                       */
/* Returns: */
/* Outputs: */
/* Example usage: static int ftp_read_data(void)                                    */
/*                {                                                                 */
/*                  #ifdef FTP_SIMULATION                                           */
/*                  static int timer_started = 0;                                   */
/*                  static time_t save_time;                                        */
/*                  int rc;                                                         */
/*                     delay_simulation(&timer_started,&save_time,&rc);             */
/*                     return rc;                                                   */
/*                  #endif                                                          */
/*                }                                                                 */
/************************************************************************************/
#ifdef DIALLER_SIMULATION
static void delay_simulation(int *timer_started,time_t *save_time,int *rc)
{
  int lapsed_time; /* secs */

    if (*timer_started == 0)
    {
        *save_time = time(NULL);
        *timer_started = 1;
        *rc = IN_PROGRESS;
    }
    else
    {
        lapsed_time = (int)(difftime(time(NULL),*save_time));
        if (lapsed_time > TIME_DELAY)
        {
            *rc = DONE;
            *timer_started = 0;
        }
        else
        {
            *rc = IN_PROGRESS;
        }
    }
}
#endif

