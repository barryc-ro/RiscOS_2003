/************************************************************************************/
/*                                                                                  */
/*  File: dial.c                                                                    */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*  Documents: dialler state machine spreadsheet, drawing no.: 2205,033/DS.         */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  17-Jul-1998  SR        Created                                                  */
/*  14-Aug-1998  RML       Added actual dialler code.                               */
/*  26-Aug-1998  SR        Added more diagnostics.                                  */
/*                                                                                  */
/************************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "kernel.h"
#include "swis.h"
#include "ui.h"
#include "errors.h"
#include "main.h"
#include "dial.h"
#include "dialler.h"

enum dial_state {IDLE,
                 CONNECTING,
                 CONNECTED,
                 HANGING_UP};

static int dial_state = IDLE;

/************************************************************************************/
/*                             Function Prototypes                                  */
/************************************************************************************/

static int initialise_with_dialler_and_dial_ISP(void);
static int tell_dialler_to_hang_up(void);
static int check_dialler_status_word(void);
static void reset_modem(void);
static int e_check(int rc,int line);

#ifdef DIALLER_SIMULATION
static void delay_simulation(int *timer_started,time_t *save_time,int *rc);
#else
static char *get_script_string(char *ptr, char *script, char *end);
static int get_country_code(int dial_code);
#endif

/************************************************************************************/
/* Function:  dialler_stateMachine()                                                */
/* Behaviour: Code contained within the Dialler state machine maps directly onto    */
/*            the Dialler state machine spreadsheet, drawing no.xxx,xxx/DS.         */
/*            Error reporting to the user is done via e_check().  e_check()         */
/*            translates internal error codes to those recognised by the UI Library.*/
/* Requires:  'reason', which is START, ABORT, CLOSE, POLL, or HANGUP, as defined   */
/*            on the spreadsheet.                                                   */
/* Returns:   DONE, IN_PROGRESS, or ERROR, as defined on the spreadsheet.           */
/************************************************************************************/

extern int dialler_stateMachine(int reason)
{
  int rc;
  unsigned int flags = 0;
  _kernel_oserror *er;

    switch (dial_state)
    {
       case IDLE:        switch (reason)
                         {
                           case START: rc = initialise_with_dialler_and_dial_ISP();
                                       if ((e_check(rc,__LINE__)) == ERROR)
                                       {
                                            return ERROR;
                                       }
                                       else if (rc == IN_PROGRESS)
                                       {
                                            dial_state = CONNECTING;
                                            if ((er = ui_set_progress_message(flags,ISP_Dial_Stage)) != NULL)
                                            {
                                                 error_handler(__FILE__,__LINE__,"dialler_stateMachine()",er->errnum,
                                                   er->errmess,WARNING);
                                            }
                                            return IN_PROGRESS;
                                       }
                                       else if (rc == DONE)
                                       {
                                            dial_state = CONNECTED;
                                            return DONE;
                                       }
                                       break;
                           case ABORT: /* Drop through */
                           case CLOSE: return DONE;
                                       break;
                           case POLL:  error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                             "Invalid event (POLL) in state (IDLE).",FATAL);
                                       return ERROR;
                                       break;
                           case HANGUP:return DONE;
                                       break;
                           default:    error_handler(__FILE__,__LINE__,"dialler_stateMachine()",reason,
                                         "Unrecognised reason code passed in state (IDLE).",FATAL);
                         }
                         break;

       case CONNECTING:  switch (reason)
                         {
                           case START: error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Invalid event (START) in state (CONNECTING).",FATAL);
                                       return ERROR;
                                       break;
                           case ABORT: /* Drop through */
                           case HANGUP:rc = tell_dialler_to_hang_up();
                                       if ((e_check(rc,__LINE__)) == ERROR)
                                       {
                                            return ERROR;
                                       }
                                       else if (rc == IN_PROGRESS)
                                       {
                                            dial_state = HANGING_UP;
                                            return IN_PROGRESS;
                                       }
                                       else if (rc == DONE)
                                       {
                                            dial_state = IDLE;
                                            return DONE;
                                       }
                                       break;
                           case POLL:  rc = check_dialler_status_word();
                                       if ((e_check(rc,__LINE__)) == ERROR)
                                       {
                                            reset_modem();
                                            return ERROR;
                                       }
                                       else if (rc == IN_PROGRESS)
                                       {
                                            return IN_PROGRESS;
                                       }
                                       else if (rc == DONE)
                                       {
                                            dial_state = CONNECTED;
                                            return DONE;
                                       }
                                       break;
                           default:    error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Unrecognised reason code passed in state (CONNECTING).",FATAL);
                         }
                         break;

       case CONNECTED:   switch (reason)
                         {
                           case START: error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Invalid event (START) in state (CONNECTED).",FATAL);
                                       return ERROR;
                                       break;
                           case ABORT: /* Drop through */
                           case HANGUP:rc = tell_dialler_to_hang_up();
                                       if ((e_check(rc,__LINE__)) == ERROR)
                                       {
                                            return ERROR;
                                       }
                                       else if (rc == IN_PROGRESS)
                                       {
                                            dial_state = HANGING_UP;
                                            return IN_PROGRESS;
                                       }
                                       else if (rc == DONE)
                                       {
                                            dial_state = IDLE;
                                            return DONE;
                                       }
                                       break;
                           case POLL:  error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Invalid event (POLL) in state (CONNECTED).",FATAL);
                                       return ERROR;
                                       break;
                           default:    error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Unrecognised reason code in state (CONNECTED).",FATAL);
                         }
                         break;

       case HANGING_UP:  switch (reason)
                         {
                           case START: error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Invalid event (START) in state (HANGING_UP).",FATAL);
                                       return ERROR;
                                       break;
                           case ABORT: /* Drop through */
                           case HANGUP:/* Drop through */
                           case POLL:  rc = check_dialler_status_word();
                                       if ((e_check(rc,__LINE__)) == ERROR)
                                       {
                                            return ERROR;
                                       }
                                       else if (rc ==IN_PROGRESS)
                                       {
                                            return IN_PROGRESS;
                                       }
                                       else if (rc == DONE)
                                       {
                                            dial_state = IDLE;
                                            return DONE;
                                       }
                                       break;
                           default:    error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Unrecognised reason code in state (HANGING_UP).",FATAL);
                         }
                         break;

       default:          error_handler(__FILE__,__LINE__,"dialler_stateMachine()",0,
                                         "Unrecognised dial state.",FATAL);
    }

    return ERROR;
}

/************************************************************************************/
/* Function:  initialise_with_dialler_and_dial_ISP()                                */
/* Behaviour: Initiate dialling of ISP.                                             */
/*            The correct context for calling ui_show_error() is from within the    */
/*            calling function.  Therefore, error codes should be returned to the   */
/*            caller.  The caller ensures that internal error codes are translated  */
/*            to those recognised by the UI Library before ui_show_error() is       */
/*            called.                                                               */
/* Returns:   Typically IN_PROGRESS, else an error.  Errors are defined in h.dial.  */
/************************************************************************************/
static int initialise_with_dialler_and_dial_ISP(void)
{
#ifndef DIALLER_SIMULATION
    _kernel_oserror *e;
    static char      new_dial_script[MAXIMUM_SCRIPT_SIZE];
    static char      hang_script[] = "\"\" ATZ\n";
    char            *script = usr_details->isp.modem_script;
    char            *current = new_dial_script;
    char            *new_dial_end = new_dial_script + sizeof(new_dial_script);

    /* We build our final dial script (in new_dial_script) by substituting the
       user details into the dial script which is specified through the UI
       (usr_details->isp.modem_script). */
    while (*script)
    {
        if (script[0])
        {
            /* Get the next line from the login script (lines are seperated by \n)
               and copy into new_dial_string (at position pointed to by current) */
            script = get_script_string(current, script, new_dial_end);

            /* If null pointer returned from get_script_string, then there was
               not enough room to copy the next line into new_dial_script */
            if (!script)
            {
                error_handler(__FILE__,__LINE__,"initialise_with_dialler_and_dial_ISP()",0,"Dial script too long",WARNING);
                return DIAL_ERROR_SCRIPT_TOO_LONG;
            }

            /* Check for login string (usually 'ogin: ') */
            if (strcmp(current, LOGIN_STRING) == 0)
            {
                strcat(current, usr_details->isp.username);
            }

            /* Check for password string (usually 'assword: ') */
            else if (strcmp(current, PASSWORD_STRING) == 0)
            {
                strcat(current, usr_details->isp.password);
            }

            /* Check for country code string (usually 'OK AT*NC') */
            else if (strcmp(current, COUNTRY_STRING) == 0)
            {
                sprintf(current, "%s%d", COUNTRY_STRING, get_country_code(usr_details->phone.country_code));
            }

            /* Check for dial command (begins 'OK ATD') */
            else if (strncmp(current, DIAL_STRING, strlen(DIAL_STRING)) == 0)
            {
                strcat(current, usr_details->phone.outside_line_prefix);
                strcat(current, usr_details->phone.call_waiting_prefix);
                strcat(current, usr_details->isp.phone_number);
            }

            /* Move current on to point to next line */
            current += strlen(current);
            *current++ = LINE_FEED;
        }
    }

    /* Terminate string */
    *current++ = LINE_FEED;
    *current++ = 0;

    /* Now call DiallerB */
    e = _swix(DiallerB_Dial, _INR(0,4),
                             Dialler_Flags_DialScriptInMemory +
                             Dialler_Flags_HangupScriptInMemory,
                             SERIAL,
                             new_dial_script,
                             hang_script,
                             SPEED);

     #ifdef DEVELOPMENT
     dialling_started = 1;
     #endif

    /* Any error from DiallerB_Dial will typically be because serial1: is
       already claimed, or else if DiallerB module not present. */
    if (e)
    {
        error_handler(__FILE__,__LINE__,"initialise_with_dialler_and_dial_ISP()",e->errnum,e->errmess,WARNING);
        return DIAL_ERROR_NO_RESPONSE;
    }

    return IN_PROGRESS;

#else
  static int timer_started = 0;
  static time_t save_time;
  int rc;

    delay_simulation(&timer_started,&save_time,&rc);
    return rc;
#endif
}

/************************************************************************************/
/* Function:  tell_dialler_to_hang_up()                                             */
/* Behaviour: Tell modem to hang up.  Error reporting to the user is as described   */
/*            in initialise_dialler_and dial_ISP().                                 */
/* Returns:   Typically DONE, else and error. */
/************************************************************************************/
static int tell_dialler_to_hang_up(void)
{
#ifndef DIALLER_SIMULATION
    if (_swix(DiallerB_HangUp, _IN(0), 0)) return DIAL_ERROR_BAD_HANGUP;
    return DONE;
#else
  static int timer_started = 0;
  static time_t save_time;
  int rc;

    delay_simulation(&timer_started,&save_time,&rc);
    return rc;
#endif
}

/************************************************************************************/
/* Function:  check_dialler_status_word()                                           */
/* Behaviour: Check the status of the dialling to see if it has finished.           */
/*            Error reporting to the user is as described in initialise_dialler_and */
/*            dial_ISP().                                                           */
/* Returns:   Either IN_PROGRESS, DONE or ERROR.                                    */
/************************************************************************************/
static int check_dialler_status_word(void)
{
#ifndef DIALLER_SIMULATION
    int status_word;
    int state;
    int ginfo;
    _kernel_oserror *e = NULL;

    if ((e = _swix(DiallerB_Status, _IN(0)|_OUT(0), 0, &status_word)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"check_dialler_status_word()",e->errnum,e->errmess,WARNING);
         return ERROR;
    }

    state = status_word & Dialler_ConnectedFlagsMask;
    ginfo = status_word & Dialler_GeneralInfoMask;

    if (state == Dialler_Connected)
        return DONE;

    if ((state == Dialler_Disconnected) && (ginfo != Dialler_ExecutingScript_Dial))
    {
        switch (ginfo)
        {
          case Dialler_ExecutingScript_Hangup: error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,
                                               "Dialler_ExecutingScript_Hangup",WARNING);
                                               break;
          case Dialler_ExecutingScript_Answer: error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,
                                               "Dialler_ExecutingScript_Answer",WARNING);
                                               break;
          case Dialler_AbortedScript_Syntax:   error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,
                                               "Dialler_AbortedScript_Syntax",WARNING);
                                               break;
          case Dialler_AbortedScript_Timeout:  error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,
                                               "Dialler_AbortedScript_Timeout",WARNING);
                                               break;
          case Dialler_AbortedScript_NoCarrier:error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,
                                               "Dialler_AbortedScript_NoCarrier",WARNING);
                                               break;
          case Dialler_AbortedScript_Error:    error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,
                                               "Dialler_AbortedScript_Error",WARNING);
                                               break;
          case Dialler_AbortedScript_NoDialtone:error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,
                                               "Dialler_AbortedScript_NoDialtone",WARNING);
                                               break;
          case Dialler_AbortedScript_Busy:     error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,
                                               "Dialler_AbortedScript_Busy",WARNING);
                                               break;
          case Dialler_AbortedScript_NoAnswer: error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,
                                               "Dialler_AbortedScript_NoAnswer",WARNING);
                                               break;
          case Dialler_AbortedScript_UserAbortString:error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,
                                               "Dialler_AbortedScript_UserAbortString",WARNING);
                                               break;
          default: error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,"Dialler disconnected and not executing dial script",
                   WARNING);
        }

        return ERROR;
    }

    /* XXX: don't think this is needed anymore. */
    if (ginfo > Dialler_AbortedScript_Syntax)
    {
        error_handler(__FILE__,__LINE__,"check_dialler_status_word()",0,"ooops",WARNING);
        return ERROR;
    }

    return IN_PROGRESS;

#else
  static int timer_started = 0;
  static time_t save_time;
  int rc;

    delay_simulation(&timer_started,&save_time,&rc);
    return rc;
#endif
}

/************************************************************************************/
/* Function:  reset_modem()                                                         */
/* Behaviour: Unused.  If it ever does get used, error reporting to the user should */
/*            be as described in initialise_dialler_and dial_ISP().                 */
/************************************************************************************/
static void reset_modem(void)
{
    return;
}

/************************************************************************************/
/* Function:  get_script_string                                                     */
/* Behaviour: Copy the next line from a script string into a new string. ,          */
/* Requires: ptr -> string to copy into (destination)                               */
/*           script -> source script string                                         */
/*           end -> end of buffer for destination string                            */
/* Returns:  pointer to next line in source string                                  */
/************************************************************************************/
#ifndef DIALLER_SIMULATION
static char *get_script_string(char *ptr, char *script, char *end)
{
    /* Copy characters up to '\n' string */
    while ( !(*script==BACKSLASH && *(script+1)=='n') )
    {
        /* Check for over-running buffer */
        if (ptr >= end) return 0;

        /* Check for premature end of string */
        if (*script == 0)
        {
            *ptr = 0;
            return script;
        }

        /* Okay, copy character */
        *ptr++ = *script++;
    }

    /* Increment script to take account of '\n' */
    script+=2;

    /* Terminate string */
    *ptr = 0;

    return script;
}
#endif

/************************************************************************************/
/* Function:      get_country_code                                                  */
/* Behaviour:     Given the dialling code for a country, return the modem country   */
/*                code. If the dialling code is not understood, then the default    */
/*                dialling code is returned (defined in h.dial).                    */
/* Prerequesites:                                                                   */
/* Requires:      dial_code = international dialling code.                          */
/* Outputs:       modem country code.                                               */
/************************************************************************************/
#ifndef DIALLER_SIMULATION
static int get_country_code(int dial_code)
{
    int dialcodes[NumDialcodes][2] = { DialCode_USA, CountryCode_USA,
                                       DialCode_Norway, CountryCode_Norway,
                                       DialCode_UK, CountryCode_UK,
                                       DialCode_Germany, CountryCode_Germany,
                                       DialCode_Sweden, CountryCode_Sweden,
                                       DialCode_Denmark, CountryCode_Denmark,
                                       DialCode_Finland, CountryCode_Finland };
    int country_code = DefaultCountryCode;
    int n;

    /* Search through our list to see if we can find a country code to match the given dial code */
    for (n=0; n<NumDialcodes; n++)
    {
        if (dialcodes[n][0] == dial_code)
        {
            country_code = dialcodes[n][1];
            break;
        }
    }

    return country_code;
}
#endif

/************************************************************************************/
/* Function:  e_check()                                                             */
/* Behaviour: Checks return codes for error.  Internal error codes are translated   */
/*            to those recognised by the UI Library before it is called to display  */
/*            the error.                                                            */
/* Requires:  - 'rc', which is the return code to check.                            */
/*            - 'line', which is the line at which the error occurred.              */
/* Returns:   Return code unchanged if not an error, otherwise ERROR is returned in */
/*            accordance with the state machine spreadsheet.                        */
/* Outputs:   On error, an error pop-up via the UI Library, error diagnostics to a  */
/*            log file (providing logging is turned on), and error diagnostics to a */
/*            system variable "err".                                                */
/************************************************************************************/
static int e_check(int rc,int line)
{
  int flags = 0;
  error_t report_err;
  _kernel_oserror *er;
  static int n = 1;

    if ((rc != IN_PROGRESS) && (rc != DONE))
    {
         report_err = translate(rc);
         if ((er = ui_show_error(flags,report_err)) != NULL)
         {
              error_handler(__FILE__,line,"dialler_stateMachine()",er->errnum,
                er->errmess,WARNING);
         }
         dial_state = IDLE;
         rc = ERROR;
    }

    n++;
    return rc;
}

/************************************************************************************/
/* Function: delay_simulation()                                                     */
/* Behaviour: Allows us to simulate how long various tasks are expected to take,    */
/*            and to exercise IN_PROGRESS return codes.  Allows the UI simulator to */
/*            be slowed to a decent speed for observation and testing during devel- */
/*            opment.                                                               */
/* Prerequisites: None.                                                             */
/* Requires: - 'timer_started', which must be 0 on the first call.                  */
/*           - 'save_time', which is used to evauluate elapsed time for a specific  */
/*              activity.                                                           */
/*           - 'rc', which is used to return DONE or IN_PROGRESS, depending upon    */
/*              elapsed time.                                                       */
/* Returns: */
/* Outputs: */
/* Example usage: static int ftp_read_data(void)                                    */
/*                {                                                                 */
/*                  #ifdef FTP_SIMULATION                                           */
/*                  static int timer_started = 0;                                   */
/*                  static time_t save_time;                                        */
/*                  int rc;                                                         */
/*                     delay_simulation(&timer_started,&save_time,&rc);             */
/*                     return rc;                                                   */
/*                  #endif                                                          */
/*                }                                                                 */
/************************************************************************************/
#ifdef DIALLER_SIMULATION
static void delay_simulation(int *timer_started,time_t *save_time,int *rc)
{
  int lapsed_time; /* secs */

    if (*timer_started == 0)
    {
        *save_time = time(NULL);
        *timer_started = 1;
        *rc = IN_PROGRESS;
    }
    else
    {
        lapsed_time = (int)(difftime(time(NULL),*save_time));
        if (lapsed_time > TIME_DELAY)
        {
            *rc = DONE;
            *timer_started = 0;
        }
        else
        {
            *rc = IN_PROGRESS;
        }
    }
}
#endif

