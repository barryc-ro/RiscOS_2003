/************************************************************************************/
/*                                                                                  */
/*  File: main.c                                                                    */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*  Documents: State machine spreadsheets, drawing no.s xxxx,xxx/DS, .....          */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  xx-Jul-1998  SR        Created                                                  */
/*                                                                                  */
/************************************************************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "swis.h"
#include "kernel.h"
#include "event.h"
#include "ui.h"
#include "errors.h"
#include "main.h"
#include "nvram.h"
#include "dial.h"
#include "ppp.h"
#include "ftp.h"
#include "progrmng.h"

enum engine_state {WELCOME,
                   WAITNG_SRVR_ACCESS_INFO,
                   DIALLING,
                   PPP,
                   HANGING_UP,
                   FTP,
                   PPP_DISCONNECTING,
                   FTP_CLOSING,
                   PROGRAMMING_FLASH};

enum start_close_at {FLASH_PROGRAMMING,
                     FTP_CLOSE,
                     PPP_DISCONNECT,
                     DIALLER_HANGUP};

static engine_state = -1;
//static int start_upgrade_flag = FALSE; /* True if start upgrade needs to be called by the engine. */
static int usr_abort = FALSE;
int err_abort = FALSE;
static int callback_start_upgrade_flag = FALSE;
static int callback_user_abort_flag = FALSE;

int suspended = FALSE;
int quit = 0;
FILE *logfile = NULL;
setup_details_t *usr_details = NULL;

static int engine_initialise(void);
static int main_loop(int event_code,WimpPollBlock *event,IdBlock *id_block,void *handle);
static int start_dialler_sm(void);
static void dialling_state(void);
static void ppp_state(void);
static void ftp_state(void);
static void programming_state(void);
static void close(enum start_close_at start_close_at);
static void engine_state_machine(void);
static void start_upgrade(void);
static void user_abort(void);

/************************************************************************************/
/* Function:  main()                                                                */
/* Behaviour: Initialises the engine and UI Library.  The UI Library sets up event  */
/*            handlers for button presses.  The engine sets up a handler for        */
/*            processing on null events.                                            */
/************************************************************************************/

int main(int argc, char *argv[])
{
  WimpPollBlock block;
  int code;
  _kernel_oserror *er;
  int rc;

     #ifdef LOGFILE
     if ((logfile = fopen("logfile","w")) == NULL)
          error_handler(__FILE__,__LINE__,"main()",0,"Could not create logfile",WARNING);
     #endif

     if ((rc = engine_initialise()) != SUCCESS)
     {
          error_handler(__FILE__,__LINE__,"main()",0,
            "Engine failed to initialise.",FATAL);
     }

     while (quit == 0)
     {
         if ((er = event_poll(&code, &block, 0)) != NULL)
         {
              error_handler(__FILE__,__LINE__,"main()",er->errnum,
                er->errmess,FATAL);
         }
     }
}

/************************************************************************************/
/* Function:  engine_initialise()                                                   */
/* Behaviour: Provides the UI Library with addresses of the callback functions it   */
/*            requires, registers the engine's null event handler, reads any        */
/*            default set-up info from nvram and passes it to the UI Library,       */
/*            giving the user a chance to change default settings if required.      */
/* Returns:   'FAILURE' if the engine has not been initialised, 'SUCCESS' if it has.*/
/************************************************************************************/

static int engine_initialise(void)
{
  int flags = 0;
  engine_callbacks_t callbacks;
  unsigned int mask = 0xc3872;
  _kernel_oserror *er;

    callbacks.start_upgrade = callback_start_upgrade;
    callbacks.user_abort = callback_user_abort;
    callbacks.return_to_main_os = engine_reboot;
    callbacks.encountered_error = encountered_error;
    callbacks.pause = pause;
    callbacks.setup_started = setup_started;
    callbacks.resume = resume;
    callbacks.error_action = callback_error_action;

    event_set_mask(mask);

    if ((er = ui_initialise(flags,&callbacks)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"engine_initialise()",er->errnum,er->errmess,FATAL);
         return FAILURE;
    }

    if ((er = event_register_wimp_handler(-1,Wimp_ENull,main_loop,(void *)0)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"engine_initialise()",er->errnum,er->errmess,FATAL);
    }

    get_nvram_defaults();
    engine_state = WELCOME;
    return SUCCESS;
}

/************************************************************************************/
/* Function:       main_loop()                                            */
/* Behaviour:*/
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/

static int main_loop(int event_code,WimpPollBlock *event,IdBlock *id_block,void *handle)
{

    if (callback_user_abort_flag == TRUE)    /* Respond to any outstanding callback */
        user_abort();                        /* requests.                           */
    else                                     /* If there were no callback requests  */
        engine_state_machine();              /* carry on with what we were doing.   */

    return 0;
}

/************************************************************************************/
/* Function: engine_state_machine()                                                 */
/************************************************************************************/
static void engine_state_machine(void)
{
      switch (engine_state)
      {
        case WELCOME: /*
                      if (start_upgrade_flag == TRUE)
                      {
                           Tell the UI Library we've started upgrading.
                           Needs to come before the actual call to start_upgrade()

                          if ((er = ui_upgrade_started(flags)) != NULL)
                          {
                               error_handler(__FILE__,__LINE__,"main_loop()",er->errnum,
                                 er->errmess,WARNING);
                          }
                          else
                          {
                           start_upgrade(flags,NULL);
                           start_upgrade_flag = FALSE;
                          }
                      }
                      */

                      if (callback_start_upgrade_flag == TRUE)
                      {
                          start_upgrade();
                      }
                      break;

        case WAITNG_SRVR_ACCESS_INFO:
                      if (callback_start_upgrade_flag == TRUE)
                      {
                          start_upgrade();
                      }
                      break;

        case DIALLING: dialling_state();
                       break;

        case PPP:      ppp_state();
                       break;

        case FTP:      ftp_state();
                       break;

        case PROGRAMMING_FLASH: programming_state();
                                break;

        case FTP_CLOSING: close(FTP_CLOSE);
                          break;

        case PPP_DISCONNECTING: close(PPP_DISCONNECT);
                                break;

        case HANGING_UP: close(DIALLER_HANGUP);
                         break;

        default: error_handler(__FILE__,__LINE__,"main_loop()",0,
                   "Unrecognised engine state.",FATAL);
      }
}

/************************************************************************************/
/* Function:  start_dialler_sm()                                                    */
/* Behaviour: .... */
/*            Calls to ui_show_error() at this level run the risk of overwriting    */
/*            more specific error reporting that will already have taken place      */
/*            within the appropriate sub-routines used by this function.            */
/* Prerequisites:*/
/* Requires:*/
/* Returns: IN_PROGRESS, DONE, or ERROR.  The caller only needs to know whether or  */
/*          not an error occurred.  The caller does not need to distinguish between */
/*          done and in progress.                                                   */
/* Outputs:*/
/************************************************************************************/
static int start_dialler_sm(void)
{
  int flags = 0;
  int rc;
  _kernel_oserror *er;

    rc = dialler_stateMachine(START);
    switch (rc)
    {
      case IN_PROGRESS: if ((er = ui_set_progress_message(flags,ISP_Dial_Stage)) != NULL)
                        {
                             error_handler(__FILE__,__LINE__,"start_dialler_sm()",er->errnum,
                               er->errmess,WARNING);
                        }
                        engine_state = DIALLING;
                        return IN_PROGRESS;
                        break;
      case ERROR:       /* ui_show_error() has already been called */
                        engine_state = WAITNG_SRVR_ACCESS_INFO;
                        return ERROR;
                        break;
      case DONE:        rc = ppp_stateMachine(START);
                        switch (rc)
                        {
                          case IN_PROGRESS: engine_state = PPP;
                                            return IN_PROGRESS;
                                            break;
                          case ERROR:       /* ui_show_error() has already been called */
                                            engine_state = WELCOME;
                                            return ERROR;
                                            break;
                          case DONE:        rc = ftp_stateMachine(START);
                                            switch (rc)
                                            {
                                              case IN_PROGRESS: engine_state = FTP;
                                                                return IN_PROGRESS;
                                                                break;
                                              case ERROR:       close(FTP_CLOSE);
                                                                return ERROR;
                                                                break;
                                              case DONE:        /* This is an appropriate point to stop if we haven't yet encountered an */
                                                                /* IN_PROGRESS return code.                                              */
                                                                engine_state = FTP;
                                                                /* It'll realise we're done on the next poll.  Don't want to set engine  */
                                                                /* state to PROGRAMMING until we've actually started programming.        */
                                                                return DONE;
                                                                break;
                                              default:          error_handler(__FILE__,__LINE__,"start_dialler_sm()",0,
                                                                  "Unrecognised reason code.",FATAL);
                                                                return ERROR;
                                            }
                                            break;
                        }
                        break;
      default:          error_handler(__FILE__,__LINE__,"start_dialler_sm()",0,
                          "Unrecognised return code from starting dialler state machine.",FATAL);
                        return ERROR;
    }
    error_handler(__FILE__,__LINE__,"start_dialler_sm()",0,"Unexpected path of execution.",WARNING);
    return ERROR;
}

/************************************************************************************/
/* Function:      dialling_state()                                                  */
/* Behaviour:                                                                       */
/*            Calls to ui_show_error() at this level run the risk of overwriting    */
/*            more specific error reporting that will already have taken place      */
/*            within the appropriate sub-routines used by this function.            */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/

static void dialling_state(void)
{
  int rc;

    rc = dialler_stateMachine(POLL);
    switch (rc)
    {
      case IN_PROGRESS: engine_state = DIALLING;
                        break;
      case ERROR:       engine_state = WAITNG_SRVR_ACCESS_INFO;
                        break;
      case DONE:        rc = ppp_stateMachine(START);
                        switch (rc)
                        {
                          case IN_PROGRESS: engine_state = PPP;
                                            break;
                          case ERROR:       close(DIALLER_HANGUP);
                                            break;

                          case DONE:        /* This is an appropriate point to stop if we */
                                            /* haven't yet encountered an IN_PROGRESS     */
                                            /* return code.                               */
                                            engine_state = PPP;
                                            /* It'll realise we're done on the next poll. */
                                            /* Don't want to set engine state to FTP      */
                                            /* until we've started opening the FTP session*/
                                            break;
                          default:          error_handler(__FILE__,__LINE__,"dialling_state()",
                                              0,"Unrecognised return code.",FATAL);
                        }
                        break;
      default:          error_handler(__FILE__,__LINE__,"dialling_state()",0,
                          "Unrecognised return code after polling dialler state machine.",FATAL);
    }
}

/************************************************************************************/
/* Function:      ppp_state()                                                       */
/* Behaviour:                                                                       */
/*            Calls to ui_show_error() at this level run the risk of overwriting    */
/*            more specific error reporting that will already have taken place      */
/*            within the appropriate sub-routines used by this function.            */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static void ppp_state(void)
{
  int rc;

    rc = ppp_stateMachine(POLL);
    switch (rc)
    {
      case IN_PROGRESS: engine_state = PPP;
                        break;
      case ERROR:       close(DIALLER_HANGUP);
                        break;
      case DONE:        rc = ftp_stateMachine(START);
                        switch (rc)
                        {
                          case IN_PROGRESS: engine_state = FTP;
                                            break;
                          case ERROR:       close(PPP_DISCONNECT);
                                            break;
                          case DONE:        /* This is an appropriate point to stop if we */
                                            /* haven't yet encountered an IN_PROGRESS     */
                                            /* return code.                               */
                                            engine_state = FTP;
                                            /* It'll realise we're done on the next poll. */
                                            /* Don't want to set engine state to          */
                                            /* programming flash until we've started      */
                                            /* programming flash.                         */
                                            break;
                          default:          error_handler(__FILE__,__LINE__,"ppp_state()",0,
                                              "Unrecognised return code.",WARNING);
                        }
                        break;
      default:          error_handler(__FILE__,__LINE__,"ppp_state()",0,
                          "Unrecognised return code from polling ppp state machine.",FATAL);
    }
}

/************************************************************************************/
/* Function:      ftp_state()                                                       */
/* Behaviour:                                                                       */
/*            Calls to ui_show_error() at this level run the risk of overwriting    */
/*            more specific error reporting that will already have taken place      */
/*            within the appropriate sub-routines used by this function.            */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static void ftp_state(void)
{
  int rc;

    rc = ftp_stateMachine(POLL);
    switch (rc)
    {
      case IN_PROGRESS: engine_state = FTP;
                        break;
      case ERROR:       close(PPP_DISCONNECT);
                        break;
      case DONE:        rc = programming_stateMachine(START);
                        switch (rc)
                        {
                          case IN_PROGRESS: engine_state = PROGRAMMING_FLASH;
                                            break;
                          case ERROR:       close(FTP_CLOSE);
                                            break;
                          case DONE:        /* This is an appropriate point to stop if we */
                                            /* haven't yet encountered an IN_PROGRESS     */
                                            /* return code.                               */
                                            engine_state = PROGRAMMING_FLASH;
                                            /* It'll realise we're done on the next poll. */
                                            /* Don't want to set engine state to          */
                                            /* ftp closing until we've started to ftp     */
                                            /* close.                                     */
                                            break;
                          default:     error_handler(__FILE__,__LINE__,"ftp_state()",0,"Unrecognised return code.",FATAL);
                        }
                        break;
      default:          error_handler(__FILE__,__LINE__,"ftp_state()",0,"Unrecognised return code.",FATAL);
    }
}

/************************************************************************************/
/* Function:      programming_state()                                               */
/* Behaviour:                                                                       */
/*            Calls to ui_show_error() at this level run the risk of overwriting    */
/*            more specific error reporting that will already have taken place      */
/*            within the appropriate sub-routines used by this function.            */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static void programming_state(void)
{
  int rc;
  int flags = 0;
  _kernel_oserror *er;

    rc = programming_stateMachine(POLL);
    switch (rc)
    {
      case IN_PROGRESS: engine_state = PROGRAMMING_FLASH;
                        break;
      case ERROR:       if ((er = ui_set_progress_message(flags,FTP_Disconnect_Stage)) != NULL)
                        {
                             error_handler(__FILE__,__LINE__,"programming_state()",er->errnum,er->errmess,WARNING);
                        }
                        close(FTP_CLOSE);
                        break;
      case DONE:        if ((er = ui_set_progress_message(flags,FTP_Disconnect_Stage)) != NULL)
                        {
                             error_handler(__FILE__,__LINE__,"programming_state()",er->errnum,er->errmess,WARNING);
                        }
                        close(FTP_CLOSE);
                        break;
      default:          error_handler(__FILE__,__LINE__,"programming_state()",0,"Unrecognised return code.",FATAL);
    }
}

/************************************************************************************/
/* Function:      close()                                                           */
/* Behaviour:     This function saves code duplication.  Enter the switch state-    */
/*                ment at the appropriate point and then drop through to the end,   */
/*                unless we hit IN_PROGRESS along the way in which case we return   */
/*                to poll the wimp.  Calls to ui_show_error() happen at the lower   */
/*                levels.  If used at the current level you risk overwriting more   */
/*                specific error reporting by the UI Library from lower down.       */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static void close(enum start_close_at start_close_at)
{
  int rc;
  unsigned int flags = 0;
  _kernel_oserror *er = NULL;

  decomp_close();

  switch (start_close_at)
  {
     case FLASH_PROGRAMMING: /* Entering the switch at this point means that a user abort */
                             /* has occurred.  Other values of start_close_at are not     */
                             /* necessarily a result of user aborts.                      */

                           rc = programming_stateMachine(CLOSE);
                           switch (rc)
                           {
                             case IN_PROGRESS: engine_state = FTP_CLOSING;
                                               break;
                             case DONE:        engine_state = FTP_CLOSING;
                                               break;
                             case ERROR:       break;
                             default:          error_handler(__FILE__,__LINE__,"close()",rc,
                                                 "Unrecognised return code from closing programming state machine.",WARNING);
                           }

     case FTP_CLOSE:       rc = ftp_stateMachine(CLOSE);
                           switch (rc)
                           {
                             case IN_PROGRESS: engine_state = FTP_CLOSING;
                                               break;
                             case ERROR:       /* Don't break.  Drop through */
                             case DONE:        break;
                             default:          error_handler(__FILE__,__LINE__,"close()",0,
                                                 "Unrecognised return code from closing ftp state machine.",WARNING);
                           }
                           if ((er = ui_set_progress_message(flags,ISP_Disconnect_Stage)) != NULL)
                           {
                                error_handler(__FILE__,__LINE__,"programming_state()",er->errnum,er->errmess,WARNING);
                           }
                           /* Don't break out yet.  FTP session closed (or not     */
                           /* closed due to error).  Move on to ppp disconnect.    */
     case PPP_DISCONNECT:  rc = ppp_stateMachine(CLOSE);
                           switch (rc)
                           {
                             case IN_PROGRESS: engine_state = PPP_DISCONNECTING;
                                               return;
                                               break;
                             case ERROR:       /* Don't break.  Drop through */
                             case DONE:        break;
                             default:          error_handler(__FILE__,__LINE__,"close()",rc,
                                                 "Unrecognised return code from cloing ppp state machine.",WARNING);
                           }
                           /* Don't break out yet.  PPP disconnected (or not due   */
                           /* to error).  Move on to dialler hangup.               */
     case DIALLER_HANGUP:  rc = dialler_stateMachine(HANGUP);
                           switch (rc)
                           {
                             case IN_PROGRESS: engine_state = HANGING_UP;
                                               break;
                             case ERROR:       /* Don't break.  Drop through */
                             case DONE:        if (suspended == TRUE)
                                               {
                                                /* We mustn't display the welcome screen until the user has clicked OK on */
                                                /* the error pop-up.  'suspended' only gets set when we're waiting for    */
                                                /* the user to acknowledge that an error has occurred.                    */
                                                   engine_state = HANGING_UP;
                                                   return;
                                               }
                                               /* Don't want to display the "finished upgrade" screen if we're hanging up */
                                               /* as a result of user abort or abort as a result of error.                */
                                               if ((usr_abort == FALSE) && (err_abort == FALSE))
                                               {
                                                   if ((er = ui_finished_upgrade(flags)) != NULL)
                                                   {
                                                        error_handler(__FILE__,__LINE__,"close()",er->errnum,er->errmess,WARNING);
                                                   }
                                               }
                                               else if ((usr_abort == TRUE) || (err_abort == TRUE))
                                               {
                                                 // It's ok for the ui to unfade the stop button now.
                                                    if ((er = ui_reset_stop_button(flags)) != NULL)
                                                    {
                                                         error_handler(__FILE__,__LINE__,"close()",er->errnum,er->errmess,WARNING);
                                                    }
                                                    if ((er = ui_show_welcome(flags)) != NULL)
                                                    {
                                                         error_handler(__FILE__,__LINE__,"close()",er->errnum,er->errmess,WARNING);
                                                    }
                                               }
                                               engine_state = WELCOME;
                                               if (usr_abort == TRUE)
                                               {
                                                /* Reset the user abort flag. */
                                                   usr_abort = FALSE;
                                               }
                                               if (err_abort == TRUE)
                                               {
                                                /* Reset the abort due to error flag. */
                                                   err_abort = FALSE;
                                               }
                                               break;
                             default:          error_handler(__FILE__,__LINE__,"close()",0,
                                                 "Unrecognised return code from hanging up dialler state machine.",FATAL);
                           }
                           break;
     default:              error_handler(__FILE__,__LINE__,"close()",0,"Unrecognised start code.",FATAL);
  }

  return;
}

/************************************************************************************/
/*                             UI Library Callbacks                                 */
/************************************************************************************/

/* Note: it is safe to call ui_show_error() from within the callbacks, providing    */
/* that the callback has been called by the engine on that particular wimp poll.  A */
/* wimp poll must have occurred between the time that the ui library calls the      */
/* callback, and the engine actually executing the callback.  Otherwise, the UI     */
/* library cannot guarantee that the pop-up will be visible.                        */

/* As a result of the above, the callback functions simply set a flag and then      */
/* return for a wimp poll before actually carrying out the work associated with the */
/* callback.                                                                        */

/************************************************************************************/
/* Function:      callback_start_upgrade()                                          */
/************************************************************************************/
extern _kernel_oserror *callback_start_upgrade(unsigned int flags,setup_details_t *defaults)
{
    usr_details = defaults;
    callback_start_upgrade_flag = TRUE;
    return NULL;
}

/************************************************************************************/
/* Function:      start_upgrade()                                                   */
/* Behaviour:     Read setup details returned from the UI library, save as defaults */
/*                and start the dialler state machine.  If the engine is not ready  */
/*                to start upgrading, set a flag which reminds us that the UI       */
/*                Library has made a start upgrade request.                         */
/* Prerequisites:*/
/* Requires:*/
/* Returns:      */
/* Outputs:*/
/************************************************************************************/
static void start_upgrade(void)
{
  int rc;
  extern int program_flash_reset_flag;

    if (usr_details != NULL)
        write_nvram_defaults(usr_details);

    if (engine_state == WAITNG_SRVR_ACCESS_INFO)
    {
        if ((rc = decomp_init()) == ERROR)
        {
             callback_start_upgrade_flag = FALSE;
             return;
        }
        program_flash_reset_flag = TRUE;
        if ((rc = start_dialler_sm()) == ERROR)
        {
             callback_start_upgrade_flag = FALSE;
             return;
        }
    }
    else
    {
     /* We're not yet ready to start the upgrade */
        callback_start_upgrade_flag = TRUE;
        return;
    }

    callback_start_upgrade_flag = FALSE;
    return;
}

/************************************************************************************/
/* Function:      callback_user_abort()                                             */
/************************************************************************************/
extern _kernel_oserror *callback_user_abort(unsigned int flags)
{
    callback_user_abort_flag = TRUE;
    return NULL;
}

/************************************************************************************/
/* Function:      user_abort()                                                     */
/* Behaviour:                                                  */
/* Prerequisites:*/
/* Requires:*/
/* Returns:      */
/* Outputs:*/
/************************************************************************************/
static void user_abort(void)
{

    usr_abort = TRUE;  /* This flag lets us know whether it's appropriate to display */
                       /* the "finished upgrade" screen when hanging up.  It is not  */
                       /* appropriate to display "finished upgrade" if we're hanging */
                       /* up as a result of user abort.                              */

    switch (engine_state)
    {
      case WELCOME:  break;

      case WAITNG_SRVR_ACCESS_INFO:
                     engine_state = WELCOME;
                     break;

      case DIALLING: close(DIALLER_HANGUP);
                     break;

      case PPP:      close(PPP_DISCONNECT);
                     break;

      case HANGING_UP: close(DIALLER_HANGUP);
                     break;

      case FTP:      close(FTP_CLOSE);
                     break;

      case PPP_DISCONNECTING: close(PPP_DISCONNECT);
                     break;

      case FTP_CLOSING: close(FTP_CLOSE);
                     break;

      case PROGRAMMING_FLASH: close(FLASH_PROGRAMMING);
                     break;

      default:       error_handler(__FILE__,__LINE__,"user_abort()",engine_state,
                       "Unrecognised engine state.",FATAL);
    }

    callback_user_abort_flag = FALSE;
}

/************************************************************************************/
/* Function:      engine_reboot()                                                   */
/* Behaviour:     Reboot the box.                                                   */
/* Prerequisites:*/
/* Requires:*/
/* Returns:       Does not exit (PRM p.5a-162).*/
/* Outputs:*/
/************************************************************************************/

extern _kernel_oserror *engine_reboot(unsigned int flags)
{
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;

    #ifdef LOGFILE
    if (logfile != NULL)
        fclose(logfile);
    #endif

    if ((er = _kernel_swi(OS_Reset,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"engine_reboot()",er->errnum,er->errmess,FATAL);
    }
    return NULL;
}

/************************************************************************************/
/* Function: encountered_error()                                                    */
/* Behaviour: The UI Library has encountered a severe error.  Attempt to display    */
/*            the error message on screen.                                          */
/* Prerequisites:*/
/* Requires:*/
/* Returns:      */
/* Outputs:*/
/************************************************************************************/
extern _kernel_oserror *encountered_error(unsigned int flags,_kernel_oserror *error)
{
    puts("The NC has experienced a technical fault.");
    puts("Please contact your supplier with the following error report:");
    puts("  Severe UI error.");
    printf("  Report: %d\n",error->errnum);
    printf("  Report: %s\n",error->errmess);
    error_handler(__FILE__,__LINE__,"encountered_error()",error->errnum,error->errmess,FATAL);
    return NULL;
}

/************************************************************************************/
/* Function:      pause()                                                     */
/* Behaviour:     Originally intended as a callback.  In future it may well be used */
/*                as a callback but for now it is used to prevent the engine        */
/*                displaying the welcome screen before the user has had a chance to */
/*                click OK on the error pop up.                                     */
/* Prerequisites:*/
/* Requires:*/
/* Returns:      */
/* Outputs:*/
/************************************************************************************/
extern _kernel_oserror *pause(unsigned int flags)
{
    suspended = TRUE;
    return NULL;
}

/************************************************************************************/
/* Function:      resume()                                                     */
/* Behaviour:                                                  */
/* Prerequisites:*/
/* Requires:*/
/* Returns:      */
/* Outputs:*/
/************************************************************************************/
extern _kernel_oserror *resume(unsigned int flags)
{
  _kernel_oserror *er = NULL;

    suspended = FALSE;
    return NULL;
}

/************************************************************************************/
/* Function:      setup_started()                                                   */
/* Behaviour:                                                  */
/* Prerequisites:*/
/* Requires:*/
/* Returns:      */
/* Outputs:*/
/************************************************************************************/
extern _kernel_oserror *setup_started(unsigned int flags)
{
  static _kernel_oserror er;

    if (engine_state == WELCOME)
        engine_state = WAITNG_SRVR_ACCESS_INFO;
    else
    {
        error_handler(__FILE__,__LINE__,"setup_started()",0,
          "Invalid context for calling setup_started(), try again later.",WARNING);
        er.errnum = 1;
        strcpy(er.errmess,"Invalid context for calling setup_started().  Try again later.");
        return &er;
    }

    return NULL;
}

/************************************************************************************/
/* Function:      setup_started()                                                   */
/************************************************************************************/
extern _kernel_oserror *callback_error_action(unsigned int flags,error_action_t error_action)
{
  _kernel_oserror *er = NULL;

    if (error_action == Action_TryAgain)
    {
        callback_start_upgrade_flag = TRUE;
    }
    else if (error_action == Action_Options)
    {
         if ((er = ui_reset_stop_button(0)) != NULL)
         {
              error_handler(__FILE__,__LINE__,"callback_error_action()",er->errnum,er->errmess,WARNING);
         }
         ui_show_setup(0);
    }
    return NULL;
}
