/************************************************************************************/
/*                                                                                  */
/*  File: main.c                                                                    */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*  Documents: State machine spreadsheets, drawing no.s 2205,032/DS, 2205,033/DS,   */
/*             2205,034/DS, 2205,035/DS,2205,036/DS.                                */
/*             Funai NC2 OS Upgrade Software Functional Specification, 2205,011/FS  */
/*             Funai NC2 OS Upgrade Top Level Software Design Spec'n, 2205,011/DS   */
/*             Funai NC2 OS Upgrade Data Decompression Detailed Design 2205,019/DS  */
/*             Funai NC2 OS Upgrade Flash Programming Detailed Design 2205,018/DS   */
/*             Funai NC2 OS Upgrade User Interface Detailed Design, 2205,016/DS     */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  17-Jul-1998  SR        Created                                                  */
/*                                                                                  */
/************************************************************************************/

/* ANSI Includes */
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

/* System includes */
#include "swis.h"
#include "kernel.h"
#include "event.h"
#include "debuglib/DebugLib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck/MemCheck.h"
#endif

/* Local includes */
#include "ui.h"
#include "errors.h"
#include "main.h"
#include "nvram.h"
#include "dial.h"
#include "ppp.h"
#include "ftp.h"
#include "progrmng.h"
#include "leds.h"

enum engine_state {ENGINE_NOT_YET_STARTED,WELCOME,WAITNG_SRVR_ACCESS_INFO,DIALLING,PPP,
                   HANGING_UP,FTP,PPP_DISCONNECTING,FTP_CLOSING,PROGRAMMING_FLASH};
enum start_close_at {FLASH_PROGRAMMING,FTP_CLOSE,PPP_DISCONNECT,DIALLER_HANGUP};

#ifdef LOGFILE
FILE *logfile = NULL;
#endif

#ifdef DEVELOPMENT
int dialling_started = 0;
#endif
int quit = 0;
int err_abort = FALSE;
setup_details_t *usr_details = NULL;

static int usr_abort = FALSE;
static int callback_start_upgrade_flag = FALSE;
static int callback_user_abort_flag = FALSE;
static int suspended = FALSE;
static int return_to_options = FALSE;
static int try_again = FALSE;
static enum engine_state engine_state = ENGINE_NOT_YET_STARTED;


/************************************************************************************/
/*                            Function Prototypes                                   */
/************************************************************************************/

static int engine_initialise(void);
static int main_loop(int event_code,WimpPollBlock *event,IdBlock *id_block,void *handle);
static void engine_state_machine(void);
static void dialling_state(void);
static void ppp_state(void);
static void ftp_state(void);
static void programming_state(void);
static void close_down(enum start_close_at start_close_at);
static void start_upgrade(void);
static void user_abort(void);

/************************************************************************************/
/* Function:  main()                                                                */
/* Behaviour: Initialises the engine and UI Library.  The UI Library sets up event  */
/*            handlers for button presses.  The engine sets up a handler for        */
/*            processing on null events.                                            */
/************************************************************************************/
int main(int argc, char *argv[])
{
  WimpPollBlock block;
  int code;
  _kernel_oserror *er;
  int rc;

     errInit();

     IGNORE(argv);
     IGNORE(argc);

     #ifdef MemCheck_MEMCHECK
     MemCheck_Init();
     MemCheck_InterceptSCLStringFunctions();
     MemCheck_SetStoreMallocFunctions(1);
     MemCheck_RedirectToFilename ("$.memcheck");
     atexit (MemCheck_OutputBlocksInfo);
     MemCheck_SetReadChecking (0);
     #endif

     /* Initialise Debug Library */
     debug_initialise ("NCUpgrade", "","");
     debug_output_device (DEBUGIT_OUTPUT);
     /* debug_output_device (PDEBUG_OUTPUT); */
     debug_atexit ();

     #ifdef LOGFILE
     if ((logfile = fopen("$.logfile","w")) == NULL)
          error_handler(__FILE__,__LINE__,"main()",0,"Could not create logfile",WARNING);
     #endif

     set_led(LEFT_LED,LED_ON);

     if ((rc = engine_initialise()) != SUCCESS)
     {
          error_handler(__FILE__,__LINE__,"main()",0,
            "Engine failed to initialise.",FATAL);
     }

     while (quit == 0)
     {
         #ifdef DEVELOPMENT
         static int last_time = 0;
         _kernel_swi_regs regs;
         _kernel_swi(OS_WriteI+4,&regs,&regs);
         _kernel_swi(OS_WriteI+30,&regs,&regs);
         _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
         printf("%d\n",regs.r[0]);
         if ((regs.r[0] > last_time + 50) && (dialling_started == 1))
         {
             last_time = regs.r[0];
             regs.r[0] = (int)"modemstats";
             _kernel_swi(OS_CLI,&regs,&regs);
         }
         _kernel_swi(OS_WriteI+5,&regs,&regs);
         #endif

         if ((er = event_poll(&code, &block, 0)) != NULL)
         {
              error_handler(__FILE__,__LINE__,"main()",er->errnum,
                er->errmess,FATAL);
         }
     }

     return 0;
}

/************************************************************************************/
/* Function:  engine_initialise()                                                   */
/* Behaviour: Provides the UI Library with addresses of the callback functions it   */
/*            requires, registers the engine's null event handler, reads any        */
/*            default set-up info from nvram and passes it to the UI Library,       */
/*            giving the user a chance to change default settings if required.      */
/* Returns:   'FAILURE' if the engine has not been initialised, 'SUCCESS' if it has.*/
/************************************************************************************/
static int engine_initialise(void)
{
  engine_callbacks_t callbacks;
  _kernel_oserror *er = NULL;
  int magic_word = 0;
  _kernel_swi_regs regs;
  unsigned int mask = 0xc3872; /* PRM p.3-117
                                  Return Null reason code,
                                  Do not return Redraw_Window_Request; queue for later handling,
                                  Do not return Pointer_Leaving_Window,
                                  Do not return Pointer_Entering_Window,
                                  Do not return Mouse_Click; queue for later handling,
                                  Return Key_Pressed,
                                  Do not return Lose_Caret,
                                  Do not return Gain_Caret,
                                  Do not return Pollword_NonZero,
                                  Return User_Message,
                                  Do not return User_Message_Recorded,
                                  Do not return User_Message_Acknowledge. */

    callbacks.start_upgrade = callback_start_upgrade;
    callbacks.user_abort = callback_user_abort;
    callbacks.return_to_main_os = engine_reboot;
    callbacks.encountered_error = encountered_error;
    callbacks.pause = pause;
    callbacks.setup_started = setup_started;
    callbacks.resume = resume;
    callbacks.error_action = callback_error_action;

    event_set_mask(mask);

    /* Before calling ui_initialise(), determine whether we started up as a result of an */
    /* invalid Main OS, or as a result of the user explicitly requesting an upgrade.     */
    regs.r[0] = IMAGESIZE - 16;
    if ((er = _kernel_swi(FlashWrite_ReadWord,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"engine_initialise()",er->errnum,er->errmess,WARNING);
         return FAILURE;
    }
    magic_word = regs.r[1];

    if (magic_word == NCOS_MAGIC_WORD)
    {
     /* A valid Main OS is present, so the user must have asked to upgrade.  Therefore, */
     /* we ask for the welcome screen which reads "You have decided to upgrade ...".    */
        if ((er = ui_initialise(0,&callbacks)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"engine_initialise()",er->errnum,er->errmess,FATAL);
             return FAILURE;  /* Not reached when error level above is FATAL */
        }
    }
    else
    {
     /* Ask for a welcome screen that indicates no valid Main OS present, and which recognises */
     /* that the upgrade may not have been user initiated.                                     */
        if ((er = ui_initialise(1,&callbacks)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"engine_initialise()",er->errnum,er->errmess,FATAL);
             return FAILURE;  /* Not reached when error level above is FATAL */
        }
    }

    if ((er = event_register_wimp_handler(-1,Wimp_ENull,main_loop,0)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"engine_initialise()",er->errnum,er->errmess,FATAL);
         return FAILURE;  /* Not reached when error level above is FATAL */
    }

    get_nvram_defaults();
    engine_state = WELCOME;
    return SUCCESS;
}

/************************************************************************************/
/* Function:       main_loop()                                                      */
/* Behaviour:      Main polling loop.                                               */
/* Prerequisites:  engine_initialise()                                              */
/* Returns:        This is an eventlib callback.                                    */
/************************************************************************************/
static int main_loop(int event_code,WimpPollBlock *event,IdBlock *id_block,void *handle)
{
    IGNORE(handle);
    IGNORE(id_block);
    IGNORE(event_code);
    IGNORE(event);

    if (callback_user_abort_flag == TRUE)    /* Respond to any outstanding callback */
        user_abort();                        /* requests.                           */
    else                                     /* If there were no callback requests  */
        engine_state_machine();              /* carry on with what we were doing.   */

    return 0;                              /* This is the only null event handler. */
}

/************************************************************************************/
/* Function:   engine_state_machine()                                               */
/* Behaviour:  This function and its sub-routines make up the main state machine as */
/*             described in spreadsheet 2205,032/DS.  (Callbacks described towards  */
/*             end of main.c).                                                      */
/************************************************************************************/
static void engine_state_machine(void)
{

      switch (engine_state)
      {
        case WELCOME: if (callback_start_upgrade_flag == TRUE)
                      {
                          start_upgrade();
                      }
                      break;

        case WAITNG_SRVR_ACCESS_INFO:
                      if (callback_start_upgrade_flag == TRUE)
                      {
                          start_upgrade();
                      }
                      break;

        case DIALLING: dialling_state();
                       break;

        case PPP:      ppp_state();
                       break;

        case FTP:      ftp_state();
                       break;

        case PROGRAMMING_FLASH: programming_state();
                                break;

        case FTP_CLOSING: close_down(FTP_CLOSE);
                          break;

        case PPP_DISCONNECTING: close_down(PPP_DISCONNECT);
                                break;

        case HANGING_UP: close_down(DIALLER_HANGUP);
                         break;

        default: error_handler(__FILE__,__LINE__,"main_loop()",0,
                   "Unrecognised engine state.",FATAL);
      }
}

/************************************************************************************/
/* Function:  start_dialler_sm()                                                    */
/* Behaviour: Starts the dialler state machine.  Ref: 2205,032/DS.                  */
/*            Calls to ui_show_error() happen at the lower levels.  If used here    */
/*            you risk overwriting more specific ui_show_error()'s lower down.      */
/* Returns:   IN_PROGRESS, DONE, or ERROR.                                          */
/************************************************************************************/
static int start_dialler_sm(void)
{
  int flags = 0;
  int rc;
  _kernel_oserror *er;

    rc = dialler_stateMachine(START);
    switch (rc)
    {
      case IN_PROGRESS: if ((er = ui_set_progress_message(flags,ISP_Dial_Stage)) != NULL)
                        {
                             error_handler(__FILE__,__LINE__,"start_dialler_sm()",er->errnum,
                               er->errmess,WARNING);
                        }
                        engine_state = DIALLING;
                        return IN_PROGRESS;
                        break;  /* In terms of code maintenance and possible future changes I prefer to leave */
                                /* break statements intact.  For example, someone may in future decide to     */
                                /* replace "return IN_PROGRESS" with "return_code = IN_PROGRESS", the killer  */
                                /* being forgetting to insert a break.  Easily done, I'd rather not risk it.  */
      case ERROR:       close_down(DIALLER_HANGUP);
                        engine_state = WAITNG_SRVR_ACCESS_INFO;
                        return ERROR;
                        break;
      case DONE:        rc = ppp_stateMachine(START);
                        switch (rc)
                        {
                          case IN_PROGRESS: engine_state = PPP;
                                            return IN_PROGRESS;
                                            break;
                          case ERROR:       close_down(PPP_DISCONNECT);
                                            engine_state = WELCOME;
                                            return ERROR;
                                            break;
                          case DONE:        rc = ftp_stateMachine(START);
                                            switch (rc)
                                            {
                                              case IN_PROGRESS: engine_state = FTP;
                                                                return IN_PROGRESS;
                                                                break;
                                              case ERROR:       close_down(FTP_CLOSE);
                                                                return ERROR;
                                                                break;
                                              case DONE:        /* This is an appropriate point to stop if we haven't yet encountered an */
                                                                /* IN_PROGRESS return code.                                              */
                                                                engine_state = FTP;
                                                                /* It'll realise we're done on the next poll.  Don't want to set engine  */
                                                                /* state to PROGRAMMING until we've actually started programming.        */
                                                                return DONE;
                                                                break;
                                              default:          error_handler(__FILE__,__LINE__,"start_dialler_sm()",0,
                                                                  "Unrecognised reason code.",FATAL);
                                                                return ERROR;
                                            }
                                            break;
                        }
                        break;
      default:          error_handler(__FILE__,__LINE__,"start_dialler_sm()",0,
                          "Unrecognised return code from starting dialler state machine.",FATAL);
                        return ERROR;
    }
    error_handler(__FILE__,__LINE__,"start_dialler_sm()",0,"Unexpected path of execution.",WARNING);
    return ERROR;
}

/************************************************************************************/
/* Function:  dialling_state()                                                      */
/* Behaviour: As defined in the main state machine spreadsheet (2205,032/DS).       */
/*            Calls to ui_show_error() happen at the lower levels.  If used here    */
/*            you risk overwriting more specific ui_show_error()'s lower down.      */
/************************************************************************************/
static void dialling_state(void)
{
  int rc;

    rc = dialler_stateMachine(POLL);
    switch (rc)
    {
      case IN_PROGRESS: engine_state = DIALLING;
                        break;
      case ERROR:       close_down(DIALLER_HANGUP);
                        break;
      case DONE:        rc = ppp_stateMachine(START);
                        switch (rc)
                        {
                          case IN_PROGRESS: engine_state = PPP;
                                            break;
                          case ERROR:       close_down(DIALLER_HANGUP);
                                            break;

                          case DONE:        /* This is an appropriate point to stop if we */
                                            /* haven't yet encountered an IN_PROGRESS     */
                                            /* return code.                               */
                                            engine_state = PPP;
                                            /* It'll realise we're done on the next poll. */
                                            /* Don't want to set engine state to FTP      */
                                            /* until we've started opening the FTP session*/
                                            break;
                          default:          error_handler(__FILE__,__LINE__,"dialling_state()",
                                              0,"Unrecognised return code.",FATAL);
                        }
                        break;
      default:          error_handler(__FILE__,__LINE__,"dialling_state()",0,
                          "Unrecognised return code after polling dialler state machine.",FATAL);
    }
}

/************************************************************************************/
/* Function:  ppp_state()                                                           */
/* Behaviour: As defined in the main state machine spreadsheet (2205,032/DS).       */
/*            Calls to ui_show_error() happen at the lower levels.  If used here    */
/*            you risk overwriting more specific ui_show_error()'s lower down.      */
/************************************************************************************/
static void ppp_state(void)
{
  int rc;

    rc = ppp_stateMachine(POLL);
    switch (rc)
    {
      case IN_PROGRESS: engine_state = PPP;
                        break;
      case ERROR:       close_down(DIALLER_HANGUP);
                        break;
      case DONE:        rc = ftp_stateMachine(START);
                        switch (rc)
                        {
                          case IN_PROGRESS: engine_state = FTP;
                                            break;
                          case ERROR:       close_down(PPP_DISCONNECT);
                                            break;
                          case DONE:        /* This is an appropriate point to stop if we */
                                            /* haven't yet encountered an IN_PROGRESS     */
                                            /* return code.                               */
                                            engine_state = FTP;
                                            /* It'll realise we're done on the next poll. */
                                            /* Don't want to set engine state to          */
                                            /* programming flash until we've started      */
                                            /* programming flash.                         */
                                            break;
                          default:          error_handler(__FILE__,__LINE__,"ppp_state()",0,
                                              "Unrecognised return code.",WARNING);
                        }
                        break;
      default:          error_handler(__FILE__,__LINE__,"ppp_state()",0,
                          "Unrecognised return code from polling ppp state machine.",FATAL);
    }
}

/************************************************************************************/
/* Function:  ftp_state()                                                           */
/* Behaviour: As defined in the main state machine spreadsheet (2205,032/DS).       */
/*            Calls to ui_show_error() happen at the lower levels.  If used here    */
/*            you risk overwriting more specific ui_show_error()'s lower down.      */
/************************************************************************************/
static void ftp_state(void)
{
  int rc;

    rc = ftp_stateMachine(POLL);
    switch (rc)
    {
      case IN_PROGRESS: engine_state = FTP;
                        break;
      case ERROR:       close_down(PPP_DISCONNECT);
                        break;
      case DONE:        rc = programming_stateMachine(START);
                        switch (rc)
                        {
                          case IN_PROGRESS: engine_state = PROGRAMMING_FLASH;
                                            break;
                          case ERROR:       close_down(FTP_CLOSE);
                                            break;
                          case DONE:        /* This is an appropriate point to stop if we */
                                            /* haven't yet encountered an IN_PROGRESS     */
                                            /* return code.                               */
                                            engine_state = PROGRAMMING_FLASH;
                                            /* It'll realise we're done on the next poll. */
                                            /* Don't want to set engine state to          */
                                            /* ftp closing until we've started to ftp     */
                                            /* close.                                     */
                                            break;
                          default:     error_handler(__FILE__,__LINE__,"ftp_state()",0,"Unrecognised return code.",FATAL);
                        }
                        break;
      default:          error_handler(__FILE__,__LINE__,"ftp_state()",0,"Unrecognised return code.",FATAL);
    }
}

/************************************************************************************/
/* Function:  programming_state()                                                   */
/* Behaviour: As defined in the main state machine spreadsheet (2205,032/DS).       */
/*            Calls to ui_show_error() happen at the lower levels.  If used here    */
/*            you risk overwriting more specific ui_show_error()'s lower down.      */
/************************************************************************************/
static void programming_state(void)
{
  int rc;
  int flags = 0;
  _kernel_oserror *er;

    rc = programming_stateMachine(POLL);
    switch (rc)
    {
      case IN_PROGRESS: engine_state = PROGRAMMING_FLASH;
                        break;
      case ERROR:       if ((er = ui_set_progress_message(flags,FTP_Disconnect_Stage)) != NULL)
                        {
                             error_handler(__FILE__,__LINE__,"programming_state()",er->errnum,er->errmess,WARNING);
                        }
                        close_down(FTP_CLOSE);
                        break;
      case DONE:        if ((er = ui_set_progress_message(flags,FTP_Disconnect_Stage)) != NULL)
                        {
                             error_handler(__FILE__,__LINE__,"programming_state()",er->errnum,er->errmess,WARNING);
                        }
                        close_down(FTP_CLOSE);
                        break;
      default:          error_handler(__FILE__,__LINE__,"programming_state()",0,"Unrecognised return code.",FATAL);
    }
}

/************************************************************************************/
/* Function:  close_down()                                                          */
/* Behaviour: Ref: main state machine spreadsheet 2205,032/DS.                      */
/*            This function saves code duplication.  Enter the switch statement at  */
/*            the appropriate point and then drop through to the end, unless we hit */
/*            IN_PROGRESS along the way in which case we return to poll the wimp.   */
/*            Calls to ui_show_error() happen at the lower levels.  If used here    */
/*            you risk overwriting more specific error reporting by the UI Library  */
/*            from lower down.                                                      */
/* Requires:  'start_close_at', which is the point at which to start closing.       */
/************************************************************************************/
static void close_down(enum start_close_at start_close_at)
{
  int rc;
  unsigned int flags = 0;
  _kernel_oserror *er = NULL;


  switch (start_close_at)
  {
     case FLASH_PROGRAMMING: /* Entering the switch at this point means that a user abort */
                             /* has occurred.  Other values of start_close_at are not     */
                             /* necessarily a result of user aborts.                      */

                           rc = programming_stateMachine(CLOSE);
                           switch (rc)
                           {
                             case IN_PROGRESS: engine_state = FTP_CLOSING;
                                               break;
                             case DONE:        engine_state = FTP_CLOSING;
                                               break;
                             case ERROR:       engine_state = FTP_CLOSING;
                                               break;
                             default:          error_handler(__FILE__,__LINE__,"close_down()",rc,
                                                 "Unrecognised return code from closing programming state machine.",WARNING);
                           }
                           break;  /* Return for a wimp poll. */
     case FTP_CLOSE:       rc = ftp_stateMachine(CLOSE);
                           switch (rc)
                           {
                             case IN_PROGRESS: engine_state = FTP_CLOSING;
                                               return;
                             case ERROR:       engine_state = PPP_DISCONNECTING;
                                               break;
                             case DONE:        engine_state = PPP_DISCONNECTING;
                                               break;
                             default:          error_handler(__FILE__,__LINE__,"close_down()",0,
                                                 "Unrecognised return code from closing ftp state machine.",WARNING);
                           }
                           if ((er = ui_set_progress_message(flags,ISP_Disconnect_Stage)) != NULL)
                           {
                                error_handler(__FILE__,__LINE__,"programming_state()",er->errnum,er->errmess,WARNING);
                           }
                           break;  /* Return for a wimp poll (necessary for UI updates to appear on screen). */
     case PPP_DISCONNECT:  rc = ppp_stateMachine(CLOSE);
                           switch (rc)
                           {
                             case IN_PROGRESS: engine_state = PPP_DISCONNECTING;
                                               break;
                             case ERROR:       engine_state = HANGING_UP;
                                               break;
                             case DONE:        engine_state = HANGING_UP;
                                               break;
                             default:          error_handler(__FILE__,__LINE__,"close_down()",rc,
                                                 "Unrecognised return code from closing ppp state machine.",WARNING);
                           }
                           break;
     case DIALLER_HANGUP:  rc = dialler_stateMachine(HANGUP);
                           switch (rc)
                           {
                             case IN_PROGRESS: engine_state = HANGING_UP;
                                               break;
                             case ERROR:       /* Don't break.  Drop through */
                             case DONE:        if (suspended == TRUE)
                                               {
                                                /* We mustn't display the welcome screen until the user has clicked OK on */
                                                /* the error pop-up.  'suspended' only gets set when we're waiting for    */
                                                /* the user to acknowledge that an error has occurred.                    */
                                                   engine_state = HANGING_UP;
                                                   return;
                                               }
                                               /* Don't want to display the "finished upgrade" screen if we're hanging up */
                                               /* as a result of user abort or abort as a result of error.                */
                                               if ((usr_abort == FALSE) && (err_abort == FALSE))
                                               {
                                                   if ((er = ui_finished_upgrade(flags)) != NULL)
                                                   {
                                                        error_handler(__FILE__,__LINE__,"close_down()",er->errnum,er->errmess,WARNING);
                                                   }
                                               }
                                               else
                                               {
                                                 /* It's ok for the ui to unfade the stop button now. */
                                                    if ((er = ui_reset_stop_button(flags)) != NULL)
                                                    {
                                                         error_handler(__FILE__,__LINE__,"close_down()",er->errnum,er->errmess,WARNING);
                                                    }

                                                    if (return_to_options == TRUE)
                                                    {
                                                     /* We're here as a result of the user clicking on "Options" in an error pop-up. */
                                                        ui_show_setup(0);
                                                        return_to_options = FALSE;
                                                        engine_state = WAITNG_SRVR_ACCESS_INFO;
                                                    }
                                                    else if (try_again == TRUE)
                                                    {
                                                      /* We're here as a result of the user clicking on "TryAgain" in an error pop-up. */
                                                      /* We don't want to go back to the welcome screen, nor do we want to go back to  */
                                                      /* the setup (options) screens.                                                  */
                                                         try_again = FALSE; /* Reset the flag now that we're dealing with the request. */
                                                         callback_start_upgrade_flag = TRUE;
                                                         engine_state = WAITNG_SRVR_ACCESS_INFO;
                                                    }
                                                    else
                                                    {
                                                      /* Return to the welcome screen. */
                                                         if ((er = ui_show_welcome(flags)) != NULL)
                                                         {
                                                              error_handler(__FILE__,__LINE__,"close_down()",er->errnum,er->errmess,WARNING);
                                                         }
                                                         engine_state = WELCOME;
                                                    }
                                               }

                                               if (usr_abort == TRUE)
                                               {
                                                /* Reset the user abort flag. */
                                                   usr_abort = FALSE;
                                               }
                                               if (err_abort == TRUE)
                                               {
                                                /* Reset the abort due to error flag. */
                                                   err_abort = FALSE;
                                               }
                                               break;
                             default:          error_handler(__FILE__,__LINE__,"close_down()",0,
                                                 "Unrecognised return code from hanging up dialler state machine.",WARNING);
                           }
                           break;
     default:              error_handler(__FILE__,__LINE__,"close_down()",0,"Unrecognised start_close_at code.",WARNING);
  }

  return;
}

/************************************************************************************/
/*                             UI Library Callbacks                                 */
/************************************************************************************/

/* Note: it is safe to call ui_show_error() from within the callbacks, providing    */
/* that the callback has been called by the engine on that particular wimp poll.  A */
/* wimp poll must have occurred between the time that the ui library calls the      */
/* callback, and the engine actually executing the callback.  Otherwise, the UI     */
/* library cannot guarantee that the pop-up will be visible.                        */

/* As a result of the above, some callback functions simply set a flag and then     */
/* return for a wimp poll before actually carrying out the work associated with the */
/* callback.                                                                        */

/************************************************************************************/
/* Function:  callback_start_upgrade()                                              */
/* Behaviour: Called as a result of the user clicking on the upgrade button once    */
/*            all setup values have been entered.  The user may have changed default*/
/*            setup info that was previously read from nvram and passed to the UI,  */
/*            so we need to read back the setup info and resave any new default     */
/*            settings.  For reasons described above, we set a start upgrade        */
/*            callback flag and return for a wimp poll before carrying out any work */
/*            associated with the callback.                                         */
/* Requires:  - 'flags', unused.                                                    */
/*            - 'defaults', latest setup info as supplied by the user.              */
/* Returns:   NULL.  (If an error occurs when the work associated with the callback */
/*            is carried out it is properly dealt with in that context).            */
/************************************************************************************/
extern _kernel_oserror *callback_start_upgrade(unsigned int flags,setup_details_t *defaults)
{
    IGNORE(flags);
    usr_details = defaults;
    callback_start_upgrade_flag = TRUE;
    return NULL;
}

/************************************************************************************/
/* Function:      start_upgrade()                                                   */
/* Behaviour:     Read setup details returned from the UI library, save as defaults */
/*                and start the dialler state machine.  If the engine is not ready  */
/*                to start upgrading, set a flag which reminds us that the UI       */
/*                Library has made a start upgrade request.                         */
/************************************************************************************/
static void start_upgrade(void)
{
  int rc;

    if (usr_details != NULL)
    {
        write_nvram_defaults(usr_details);
    }
    else
    {
        error_handler(__FILE__,__LINE__,"start_upgrade()",0,"UI Library didn't return any setup info",WARNING);
    }

    if (engine_state == WAITNG_SRVR_ACCESS_INFO)
    {
        if ((rc = start_dialler_sm()) == ERROR)
        {
             callback_start_upgrade_flag = FALSE;
             return;
        }
    }
    else
    {
     /* We're not yet ready to start the upgrade */
        callback_start_upgrade_flag = TRUE;
        return;
    }

    callback_start_upgrade_flag = FALSE;
    return;
}

/************************************************************************************/
/* Function:   callback_user_abort()                                                */
/* Behaviour:  Called as a result of the user clicking on the abort button.  For    */
/*             reasons described above we set a flag and return for a wimp poll     */
/*             before actually carrying out work associated with the callback.      */
/* Returns:    NULL.  (If an error occurs when the work is carried out it is        */
/*             properly dealt with in that context).                                */
/************************************************************************************/
extern _kernel_oserror *callback_user_abort(unsigned int flags)
{
    IGNORE(flags);
    callback_user_abort_flag = TRUE;
    return NULL;
}

/************************************************************************************/
/* Function:   user_abort()                                                         */
/* Behaviour:  Initiates closure as a result of user abort.  On exit from this      */
/*             routine we unset the callback flag to say that we've responded to    */
/*             the callback and therefore do not need to return to this routine.    */
/************************************************************************************/
static void user_abort(void)
{

    usr_abort = TRUE;  /* This flag lets us know whether it's appropriate to display */
                       /* the "finished upgrade" screen when hanging up.  It is not  */
                       /* appropriate to display "finished upgrade" if we're hanging */
                       /* up as a result of user abort.                              */

    switch (engine_state)
    {
      case WELCOME:  close_down(DIALLER_HANGUP);
                     break;

      case WAITNG_SRVR_ACCESS_INFO:
                     /* As shown by defining TEST_3_OPTION_ERROR_POPUP (dial.h), it */
                     /* is possible that the welcome screen may still need re-      */
                     /* displaying in this particular engine state, so we still     */
                     /* make a call to close_down.                                  */
                     close_down(DIALLER_HANGUP);
                     engine_state = WELCOME;
                     break;

      case DIALLING: close_down(DIALLER_HANGUP);
                     break;

      case PPP:      close_down(PPP_DISCONNECT);
                     break;

      case HANGING_UP: close_down(DIALLER_HANGUP);
                     break;

      case FTP:      close_down(FTP_CLOSE);
                     break;

      case PPP_DISCONNECTING: close_down(PPP_DISCONNECT);
                     break;

      case FTP_CLOSING: close_down(FTP_CLOSE);
                     break;

      case PROGRAMMING_FLASH: close_down(FLASH_PROGRAMMING);
                     break;

      default:       error_handler(__FILE__,__LINE__,"user_abort()",engine_state,
                       "Unrecognised engine state.",FATAL);
    }

    callback_user_abort_flag = FALSE;
}

/************************************************************************************/
/* Function:   engine_reboot()                                                      */
/* Behaviour:  Reboot the box.                                                      */
/* Requires:   - 'flags', currently unused.                                         */
/* Returns:    Does not exit (PRM p.5a-162).                                        */
/************************************************************************************/
extern _kernel_oserror *engine_reboot(unsigned int flags)
{
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;

    IGNORE(flags);

    #ifdef LOGFILE
    if (logfile != NULL)
    {
        fclose(logfile);
        logfile = NULL;
    }
    #endif

    /* Indicate that the app'n is no longer running. */
    set_led(LEFT_LED,LED_OFF);

    if ((er = _kernel_swi(OS_Reset,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"engine_reboot()",er->errnum,er->errmess,FATAL);
         /* Not reached */
    }
    return NULL;
}

/************************************************************************************/
/* Function: encountered_error()                                                    */
/* Behaviour: The UI Library has encountered a severe error.  Attempt to display    */
/*            the error message on screen (not guaranteed).  Also attempts to save  */
/*            what has happened to a system variable via our error handler.         */
/* Requires:  - 'flags', currently unused.                                          */
/*            - 'error', which points to the error number and error message.        */
/* Returns:   Does not return.                                                      */
/************************************************************************************/
extern _kernel_oserror *encountered_error(unsigned int flags,_kernel_oserror *error)
{
  _kernel_swi_regs regs;

    IGNORE(flags);

    puts("The NC has experienced a technical fault.");
    puts("Please contact your supplier with the following error report:");
    puts("  Severe UI error.");
    printf("  Report: %d\n",error->errnum);
    printf("  Report: %s\n",error->errmess);

    /* And just in case the above failed to appear on screen ... */
    _kernel_swi(OS_WriteI+4,&regs,&regs);
    _kernel_swi(OS_WriteI+30,&regs,&regs);
    _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
    printf("The NC has experienced a technical fault.\n");
    printf("Please contact your supplier with the following error report:\n");
    printf("Severe UI error.");
    printf("  Report: %d\n",error->errnum);
    printf("  Report: %s\n",error->errmess);
    _kernel_swi(OS_WriteI+5,&regs,&regs);

    error_handler(__FILE__,__LINE__,"encountered_error()",error->errnum,error->errmess,FATAL);
    return NULL;
}

/************************************************************************************/
/* Function:   pause()                                                              */
/* Behaviour:  Originally intended as a callback.  In future it may well be used as */
/*             a callback but for now it is used to prevent the engine displaying   */
/*             the welcome screen before the user has had a chance to  click OK on  */
/*             the error pop up.                                                    */
/* Requires:  'flags', currently unused.                                            */
/* Returns:    NULL                                                                 */
/************************************************************************************/
extern _kernel_oserror *pause(unsigned int flags)
{
    IGNORE(flags);
    suspended = TRUE;
    return NULL;
}

/************************************************************************************/
/* Function:   resume()                                                             */
/* Behaviour:  Unsets pause as described above.  Called by the UI library when the  */
/*             user acknowledges that an error has occurred.  This callback is only */
/*             applicable to acknowledgement of serious errors.  A serious error is */
/*             one which only allows the user to click OK in acknowledgement, with  */
/*             no choice of Try Again, go to the Options screen, or Cancel.         */
/* Requires:  'flags', currently unused.                                            */
/* Returns:    NULL                                                                 */
/************************************************************************************/
extern _kernel_oserror *resume(unsigned int flags)
{
    IGNORE(flags);
    suspended = FALSE;
    return NULL;
}

/************************************************************************************/
/* Function:   setup_started()                                                      */
/* Behaviour:  The UI calls this function to let us know that we've left the        */
/*             welcome screen and the user has started entering setup info.         */
/*             Ref: main state machine spreadsheet 2205,032/DS.                     */
/* Requires:  'flags', unused.                                                      */
/* Returns:    NULL if the engine is ready to acknowledge change of state. Otherwise*/
/*             tells the UI Library to try again later.  This prevents the UI lib   */
/*             from forcing the engine into a state which it is not yet ready to    */
/*             enter.                                                               */
/************************************************************************************/
extern _kernel_oserror *setup_started(unsigned int flags)
{
  static _kernel_oserror er;

    IGNORE(flags);

    if (engine_state == WELCOME)
    {
        engine_state = WAITNG_SRVR_ACCESS_INFO;
    }
    else
    {
        error_handler(__FILE__,__LINE__,"setup_started()",0,
          "Invalid context for calling setup_started(), try again later.",WARNING);
        er.errnum = 1;
        sprintf(er.errmess,"Invalid context for calling setup_started().  Try again later.");
        return &er;
    }

    return NULL;
}

/************************************************************************************/
/* Function:  callback_error_action()                                               */
/* Behaviour: Called by the UI Library as a result of the user clicking on an error */
/*            pop up.                                                               */
/* Requires:  - 'flags', unused.                                                    */
/*            - 'error_action', which tells us which course of action the user      */
/*               chose.                                                             */
/*               Action_TryAgain -> usr wishes to reattempt upgrade.                */
/*               Action_Options -> user wishes to return t the options (setup) scrn */
/*               Action_Cancel -> user wants to cancel the upgrade.                 */
/*               Action_OK -> usr has acknowledged the error.                       */
/* Returns:   NULL                                                                  */
/************************************************************************************/
extern _kernel_oserror *callback_error_action(unsigned int flags,error_action_t error_action)
{
  _kernel_oserror *er = NULL;

    IGNORE(flags);

 /* The UI Library doesn't call resume() for acknowledgement of non-serious errors,
    so we must do so ourselves, otherwise close_down() will still think that the
    user hasn't acknowledged the error and therefore the welcome screen will never
    reappear. */

    resume(0);

    switch (error_action)
    {
      case Action_TryAgain: if ((er = ui_reset_stop_button(0)) != NULL)
                            {
                                 error_handler(__FILE__,__LINE__,"callback_error_action()",er->errnum,er->errmess,WARNING);
                            }
                            callback_start_upgrade_flag = TRUE;
                            try_again = TRUE;
                            break;
      case Action_Options:  if ((er = ui_reset_stop_button(0)) != NULL)
                            {
                                 error_handler(__FILE__,__LINE__,"callback_error_action()",er->errnum,er->errmess,WARNING);
                            }
                            return_to_options = TRUE;
                            break;
      case Action_Cancel:   if ((er = ui_reset_stop_button(0)) != NULL)
                            {
                                 error_handler(__FILE__,__LINE__,"callback_error_action()",er->errnum,er->errmess,WARNING);
                            }
                            user_abort();
                            break;
      case Action_OK:       break; /* No need to do anything. */
      default:              error_handler(__FILE__,__LINE__,"callback_error_action()",0,"Unrecognised error action.",WARNING);
                            break;
    }

    return NULL;
}

