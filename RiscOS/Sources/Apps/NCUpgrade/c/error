/************************************************************************************/
/*                                                                                  */
/*  File: error.c                                                                   */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  17-Jul-1998  SR        Created                                                  */
/*                                                                                  */
/************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "swis.h"
#include "signal.h"
#include "kernel.h"
#include "ui.h"
#include "errors.h"
#include "main.h"
#include "zlib.h"
#include "ftp.h"
#include "progrmng.h"
#include "ppp.h"
#include "dial.h"
#ifdef SIMULATE_FLASH
#include "flashstubs.h"
#else
#include "flash.h"
#endif

static void catchErr(int code);
static void set_error_system_var(char *mess,char *file,int ln);

/************************************************************************************/
/* Function:       errInit()                                                        */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
extern void errInit(void)
{
  int i;
  int errs[] = { SIGABRT, SIGFPE,
                 SIGILL,  SIGINT,
                 SIGSEGV, SIGTERM,
                 SIGSTAK, SIGUSR1,
                 SIGUSR2, SIGOSERROR};

    for (i = 0; i < 10; signal(errs[i],catchErr),i++);
}

/************************************************************************************/
/* Function:       catchErr()                                                       */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
static void catchErr(int code)
{
  char mess[50];

    switch (code)
    {
     case SIGABRT : sprintf(mess,"Interrupt -> abort.\n");
                    break;
     case SIGFPE  : sprintf(mess,"Interrupt -> arithmetic exception.\n");
                    break;
     case SIGILL  : sprintf(mess,"Interrupt -> illegal instruction.\n");
                    break;
     case SIGINT  : sprintf(mess,"Interrupt -> attention request from user.\n");
                    break;
     case SIGSEGV : sprintf(mess,"Interrupt -> bad memory access.\n");
                    break;
     case SIGTERM : sprintf(mess,"Interrupt -> termination request.\n");
                    break;
     case SIGSTAK : sprintf(mess,"Interrupt -> stack overflow.\n");
                    break;
     case SIGUSR1 : sprintf(mess,"Interrupt -> user definable interrupt.\n");
                    break;
     case SIGUSR2 : sprintf(mess,"Interrupt -> user definable interrupt.\n");
                    break;
     case SIGOSERROR : sprintf(mess,"Interrupt -> operating system error.\n");
                    break;
     default      : sprintf(mess,"Interrupt -> unrecognised interrupt code.\n");
                    break;
    }

    error_handler(__FILE__,__LINE__,"catchErr()",code,mess,FATAL);
}

/************************************************************************************/
/* Function:       error_handler()                                                  */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
extern void error_handler(char *file,int ln,char *fn,int errnum,char *mess,int level)
{
  time_t t;

   #if !defined(LOGFILE) && !defined(DEVELOPMENT)
   IGNORE(fn);
   IGNORE(errnum);
   #endif

   #ifdef LOGFILE
   if (logfile != NULL)
   {
       if (level == FATAL) fputs("FATAL ERROR:\n",logfile);
       else if (level == WARNING) fputs("WARNING:\n",logfile);
       else fputs("WARNING: Unknown error level in error handler\n",logfile);

       fprintf(logfile,"  File: %s\n",file);
       fprintf(logfile,"  Function: %s\n",fn);
       fprintf(logfile,"  Line: %d\n",ln);
       fprintf(logfile,"  Error number: %d\n",errnum);
       fprintf(logfile,"  %s\n",mess);
       fflush(logfile);

       if (level == FATAL)
           fclose(logfile);
   }
   #endif

   #ifdef DEVELOPMENT

         if (level == FATAL) puts("FATAL ERROR:");
          else if (level == WARNING) puts("WARNING:");
                   else puts("WARNING: Unknown error level in error handler.");

      printf("  File: %s\n",file);
      printf("  Function: %s\n",fn);
      printf("  Line: %d\n",ln);
      printf("  Error number: %d\n",errnum);
      printf("  %s\n",mess);

   #endif

   set_error_system_var(mess,file,ln);
   if (level == FATAL)
   {
    /* Pause, allowing time to view any on-screen error messages. */
       t = time(NULL);
       while(difftime(time(NULL),t) < 5)
             continue;
       exit(0);
   }
}

/************************************************************************************/
/* Function:       set_error_system_var()                                           */
/* Behaviour:      Creates and sets a system variable called "err" with appropriate */
/*                 error diagnostics.  Error$Message and Error$Number may also have */
/*                 been set.  (Error$Message and Error$Number are nothing to do     */
/*                 with !upgrade).                                                  */
/* Prerequisites: */
/* Requires:       - 'mess', which is the error message.                            */
/*                 - 'file', which is the file in which the error occurred.         */
/*                 - 'ln', which is the line number in the file in which the error  */
/*                    occurred. */
/* Returns: */
/* Outputs: */
/* Assumptions:    - 'ln' is never greater than 999999.                             */
/************************************************************************************/
static void set_error_system_var(char *mess,char *file,int ln)
{
 char *str = NULL;
 _kernel_swi_regs regs;

   if ((str = calloc(strlen("Set err ")+
              strlen("File:,Line:,Error message:")+
              strlen(file)+strlen("999999")+strlen(mess)+1,sizeof(char))) != NULL)
   {
        sprintf(str,"Set err File:%s,Line:%d,Error message:%s",file,ln,mess);
        regs.r[0] = (int)str;
        _kernel_swi(OS_CLI,&regs,&regs);
        free(str);
   }
}

/************************************************************************************/
/* Function:       translate()                                                      */
/* Behaviour:      Translates internal error codes to those recognised by the UI    */
/*                 Library. */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
extern error_t translate(int internal_error_code)
{
  error_t ui_code = Programming_Failure;

#ifdef SIMULATE_FLASH
    if ((internal_error_code == FLASH_DEVICE_UNKNOWN) || (internal_error_code == FLASH_INIT_ERR))
    {
         ui_code = Programming_Failure;
    }
    else
#endif
    if (internal_error_code == PREMATURE_END_OF_INPUT_DATA)
    {
      /* Compressed image held on the server appears to have been truncated. */
         ui_code = ImageFault_Failure;
    }
    else if (internal_error_code == Z_DATA_ERROR)
    {
      /* Input data was found to be corrupt or not of the format expected by zlib. */
         ui_code = ImageFault_Failure;
    }
    else if (internal_error_code == FTP_AUTHENTICATION_FAILURE)
    {
         ui_code = FTP_Authentication_Failure;
    }
    else if (internal_error_code == REMOTE_FILE_DOES_NOT_EXIST)
    {
      /* The user needs to check that the file and pathname they specified was correct.  Another possiblity
         could be that the file held on the server is not publicly readable. */
         ui_code = NotFound_Failure;
    }
    else if ( (internal_error_code == DIAL_ERROR_NO_RESPONSE)
           || (internal_error_code == DIAL_ERROR_SCRIPT_TOO_LONG))
    {
        ui_code = Connection_Failure;
    }
    else if (internal_error_code == DIAL_ERROR_BAD_HANGUP)
    {
        ui_code = Programming_Failure;
    }
    else if ( (internal_error_code == PPP_ERROR_TIMEOUT)
           || (internal_error_code == PPP_ERROR_CANT_WRITE_SECRETS)
           || (internal_error_code == PPP_ERROR_FAILED_CONNECT) )
    {
        ui_code = Connection_Failure;
    }
    else if (internal_error_code == PPP_ERROR_FAILED_DISCONNECT)
    {
        ui_code = Programming_Failure;
    }
    else if (internal_error_code == ERROR)
    {
         ui_code = Programming_Failure;
    }
    else
    {
         error_handler(__FILE__,__LINE__,"translate()",0,"Unrecognised internal error code.",WARNING);
    }

    err_abort = TRUE;
    return ui_code;
}
