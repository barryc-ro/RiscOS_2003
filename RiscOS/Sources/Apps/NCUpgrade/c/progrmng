/************************************************************************************/
/*                                                                                  */
/*  File: progrmng.c                                                                */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  xx-Jul-1998  SR        Created                                                  */
/*                                                                                  */
/************************************************************************************/

#include <stdlib.h>
#include <time.h>
#include "main.h"
#include "ftp.h"
#include "flashstubs.h"
#include "kernel.h"
#include "errors.h"
#include "progrmng.h"
#include <zlib.h>

enum programming_state {IDLE,
                        FETCHING,
                        DECOMPRESSING,
                        PROGRAMMING};

char ftp_buf[FTP_BUFFER_SIZE];
char *flash_buf = NULL;
z_stream stream;
int program_flash_reset_flag = TRUE;

static enum programming_state programming_state = IDLE;
static flashdeviceinfo flash;
static int timer_on = FALSE;
static int bytes_programmed = 0;
static flashdeviceinfo dev;
static int sizeof_flash_buffer = 0;
static int decomp_stream_end = FALSE;
static int decomp_initialised = TRUE;

static int idle_handler(int reason);
static void progress_tracker(void);
static int timer(enum reason_code);
static int e_check(int rc,int line);
static int decomp(void);
static int program_flash(void);

#ifndef FTP_SIMULATION
int read_amt = FTP_BUFFER_SIZE;
#endif

#ifdef PROGRAMMING_SIMULATION
//static void delay_simulation(int *timer_started,time_t *save_time,int *rc);
#endif

/************************************************************************************/
/* Function:  programming_stateMachine()                                            */
/* Behaviour: */
/*            ui_show_error() should only be called for errors returned from sub    */
/*            routines that are not state machines.  ui_show_error() is called via  */
/*            e_check().                                                            */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
extern int programming_stateMachine(enum reason_code reason)
{
  int rc;

    switch (programming_state)
    {
       case IDLE:          switch (reason)
                           {
                              case START:  rc = idle_handler(START);
                                           if ((e_check(rc,__LINE__)) == ERROR)
                                           {
                                                return ERROR;
                                           }
                                           else if (rc == IN_PROGRESS)
                                           {
                                                programming_state = FETCHING;
                                                return IN_PROGRESS;
                                           }
                                           else if (rc == DONE)
                                           {
                                                rc = decomp();
                                                if ((e_check(rc,__LINE__)) == ERROR)
                                                {
                                                     return ERROR;
                                                }
                                                else if (rc == DONE)
                                                {
                                                     programming_state = PROGRAMMING;
                                                     return IN_PROGRESS;
                                                }
                                                else if (rc == IN_PROGRESS)
                                                {
                                                     programming_state = DECOMPRESSING;
                                                     return IN_PROGRESS;
                                                }
                                           }
                                           break;
                              case CLOSE:  /* Drop through */
                              case ABORT:  return DONE;
                                           break;
                              case POLL:   error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Poll not valid whilst in idle state.",FATAL);
                                           break;
                              default:     error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Unexpected reason code passed into programming state machine.",FATAL);
                           }
                           break;

       case FETCHING:      switch (reason)
                           {
                              case START: error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Start not valid whilst in fetching state.",FATAL);
                                          break;
                              case ABORT: /* drop through to close */
                              case CLOSE: if ((rc = ftp_stateMachine(CLOSE)) == ERROR)
                                          {
                                               return ERROR;
                                          }
                                          else if ((rc == IN_PROGRESS) || (rc == DONE))
                                          {
                                               programming_state = IDLE;
                                               return DONE;
                                          }
                                          break;
                              case POLL:  if ((rc = ftp_stateMachine(POLL)) == ERROR)
                                          {
                                               return ERROR;
                                          }
                                          else if (rc == IN_PROGRESS)
                                          {
                                               programming_state = FETCHING;
                                               return IN_PROGRESS;
                                          }
                                          else if (rc == DONE)
                                          {
                                               rc = decomp();
                                               if ((e_check(rc,__LINE__)) == ERROR)
                                               {
                                                    return ERROR;
                                               }
                                               else if (rc == DONE)
                                               {
                                                    programming_state = PROGRAMMING;
                                                    return IN_PROGRESS;
                                               }
                                               else if (rc == IN_PROGRESS)
                                               {
                                                    programming_state = DECOMPRESSING;
                                                    return IN_PROGRESS;
                                               }
                                          }
                                          break;
                              default:    error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Unexpected reason code passed into programming state machine.",FATAL);
                           }
                           break;

       case DECOMPRESSING: switch (reason)
                           {
                              case START: error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Start not valid whilst in decompressing state.",FATAL);
                                          break;
                              case ABORT: /* Drop through */
                              case CLOSE: if ((rc = ftp_stateMachine(CLOSE)) == ERROR)
                                          {
                                               return ERROR;
                                          }
                                          else if ((rc == IN_PROGRESS) || (rc == DONE))
                                          {
                                               programming_state = IDLE;
                                               return DONE;
                                          }
                                          break;
                              case POLL:  rc = decomp();
                                          if ((e_check(rc,__LINE__)) == ERROR)
                                          {
                                               return DONE;
                                          }
                                          else if (rc == IN_PROGRESS)
                                          {
                                               programming_state = DECOMPRESSING;
                                               return IN_PROGRESS;
                                          }
                                          else if (rc == DONE)
                                          {
                                               rc = program_flash();
                                               if ((e_check(rc,__LINE__)) == ERROR)
                                               {
                                                    return ERROR;
                                               }
                                               else if (rc == IN_PROGRESS)
                                               {
                                                    programming_state = PROGRAMMING;
                                                    return IN_PROGRESS;
                                               }
                                               else if (rc == DONE)
                                               {
                                                    programming_state = PROGRAMMING;
                                                    /* It'll realise it's done on the next poll in the new state. */
                                                    return IN_PROGRESS;
                                               }
                                          }
                                          break;
                              default:    error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Unexpected reason code passed into programming state machine.",FATAL);
                           }
                           break;
       case PROGRAMMING:   switch (reason)
                           {
                              case START: error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Start not valid whilst in programming state.",FATAL);
                                          break;
                              case ABORT: /* Drop through */
                              case CLOSE: ftp_stateMachine(CLOSE);
                                          /* No need to check return value on this one. */
                                          return DONE;
                                          break;
                              case POLL:  rc = program_flash();
                                          if ((e_check(rc,__LINE__)) == ERROR)
                                          {
                                               return ERROR;
                                          }
                                          else if (rc == IN_PROGRESS)
                                          {
                                               programming_state = PROGRAMMING;
                                               return IN_PROGRESS;
                                          }
                                          else if (rc == DONE)
                                          {
                                               progress_tracker();
                                               if ((rc = ftp_stateMachine(START)) == ERROR)
                                               {
                                                    return ERROR;
                                               }
                                               else if (rc == IN_PROGRESS)
                                               {
                                                    programming_state = FETCHING;
                                                    return IN_PROGRESS;
                                               }
                                               else if (rc == DONE)
                                               {
                                                    if (bytes_programmed == IMAGESIZE)
                                                    {
                                                        programming_state = IDLE;
                                                        return DONE;
                                                    }
                                                    else
                                                    {
                                                        programming_state = FETCHING;
                                                        /* It'll realise it's done on */
                                                        /* the next poll in the new   */
                                                        /* state.                     */
                                                        return IN_PROGRESS;
                                                    }
                                               }
                                          }
                                          break;
                              default:    error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Unexpected reason code passed into programming state machine.",FATAL);
                           }
                           break;
       default:            error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                              "Unrecognised programming state.",FATAL);
    }

    return ERROR;
}

/************************************************************************************/
/* Function:       idle_handler()                                                   */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
static int idle_handler(int reason)
{
  int rc;

    switch (reason)
    {
      case START: if ((rc = flash_initialise(&flash)) != FLASH_SUCCESS)
                  {
                       switch (rc)
                       {
                         case FLASH_DEVICE_UNKNOWN: return FLASH_DEVICE_UNKNOWN;
                                                    break;
                         case FLASH_DEVICE_TIMEOUT: return FLASH_DEVICE_TIMEOUT;
                                                    break;
                         case FLASH_PROG_ERR:       return FLASH_PROG_ERR;
                                                    break;
                         default:                   error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                                    "Unexpected return code from flash_initialise()",FATAL);
                       }
                  }
                  if ((rc = flash_allowlockwrite()) != FLASH_SUCCESS)
                  {
                       switch (rc)
                       {
                         case FLASH_INIT_ERR:       error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                                    "Flash library should be initialised, or we should not be here.",FATAL);
                                                    break;
                         case FLASH_DEVICE_TIMEOUT: return FLASH_DEVICE_TIMEOUT;
                                                    break;
                         case FLASH_PROG_ERR:       return FLASH_PROG_ERR;
                                                    break;
                         default:                   error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                                    "Unexpected return code from flash_allowlockwrite()",FATAL);
                       }
                  }
                  if ((rc = flash_chiperase()) != FLASH_SUCCESS)
                  {
                       switch (rc)
                       {
                         case FLASH_INIT_ERR:       error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                                    "Flash library should be initialised, or we should not be here.",FATAL);
                                                    break;
                         case FLASH_DEVICE_TIMEOUT: return FLASH_DEVICE_TIMEOUT;
                                                    break;
                         case FLASH_BLOCK_LOCKED:   error_handler(__FILE__,__LINE__,"idle_handler()",0,"We've already called flash_allowlockwrite() so we should be able to write to locked blocks.",FATAL);
                                                    break;
                         case FLASH_PROG_ERR:       return FLASH_PROG_ERR;
                                                    break;
                         default:                   error_handler(__FILE__,__LINE__,"idle_handler()",0,"Unexpected return code from flash_chiperase()",FATAL);
                       }
                  }
                  rc = ftp_stateMachine(START);
                  switch (rc)
                  {
                    case IN_PROGRESS: return IN_PROGRESS;
                                      break;
                    case ERROR:       return ERROR;
                                      break;
                    case DONE:        return DONE;
                                      break;
                    default:          error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                      "Unexpected return code from ftp_stateMachine()",FATAL);
                  }
                  break;
      default:    error_handler(__FILE__,__LINE__,"idle_handler()",0,
                  "Unexpected reason code passed into idle_handler()",FATAL);
    }

    return ERROR;
}

/************************************************************************************/
/* Function:       progress_tracker()                                               */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/* Notes:          Be careful where progress_tracker is called from, otw estimates  */
/*                 for time remaining will be inaccurate.  Make a single call on    */
/*                 each cycle, from the same point in the cycle.                    */
/************************************************************************************/
static void progress_tracker(void)
{
  static int mins,secs;
  int seconds_used;
  int seconds_remaining;
  int bytes_remaining;
  double percent_complete;
  int flags = 0;
  _kernel_oserror *er;

    if (timer_on == FALSE)
    {
        timer(START);
        timer_on = TRUE;
    }

    seconds_used = timer(POLL);
    bytes_remaining = IMAGESIZE - bytes_programmed;
    if (bytes_programmed != 0)
        seconds_remaining = (seconds_used * bytes_remaining) / bytes_programmed;
    mins = seconds_remaining / 60;
    secs = seconds_remaining % 60;

    if ((er = ui_set_estimated_download_time (flags,mins,secs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"programming_stateMachine()",
           er->errnum,er->errmess,WARNING);
    }

    percent_complete = ((double)bytes_programmed / IMAGESIZE) * 100;

    if ((er = ui_set_progress_percent(flags,(int)percent_complete)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"progress_tracker()",er->errnum,er->errmess,
           WARNING);
    }
}

/************************************************************************************/
/* Function:       timer()                                                          */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: seconds used, or 0 on start or error. */
/* Outputs: */
/************************************************************************************/
static int timer (enum reason_code reason)
{
  static time_t save_time;

    switch (reason)
    {
      case START: save_time = time(NULL);
                  break;
      case POLL:  return (int)(difftime(time(NULL),save_time));
                  break;
      default:    error_handler(__FILE__,__LINE__,"timer()",0,
                  "Unexpected reason code.",FATAL);
    }

    return 0;
}

/************************************************************************************/
/* Function:  e_check()                                                             */
/* Behaviour: Checks return codes for error.  Internal error codes are translated   */
/*            to those recognised by the UI Library before it is called to display  */
/*            the error.                                                            */
/* Requires:  - 'rc', which is the return code to check.                            */
/*            - 'line', which is the line at which the error occurred.              */
/* Returns:   Return code unchanged if not an error, otherwise ERROR is returned in */
/*            accordance with the state machine spreadsheet.                        */
/* Outputs:   On error, an error pop-up via the UI Library, error diagnostics to a  */
/*            log file (providing logging is turned on), and error diagnostics to a */
/*            system variable "err".                                                */
/************************************************************************************/
static int e_check(int rc,int line)
{
  int err_flags = 1;
  int pause_flags = 0;
  error_t report_err;
  _kernel_oserror *er;

    if ((rc != IN_PROGRESS) && (rc != DONE))
    {
         report_err = translate(rc);
         if ((er = ui_show_error(err_flags,report_err)) != NULL)
         {
              error_handler(__FILE__,line,"programming_stateMachine()",er->errnum,
                er->errmess,WARNING);
         }
         pause(pause_flags);
         programming_state = IDLE;
         rc = ERROR;
    }

    return rc;
}

/************************************************************************************/
/* Function:  decomp_init()                                                         */
/************************************************************************************/
extern int decomp_init(void)
{
  int rc;

    decomp_stream_end = FALSE;

    if ((rc = flash_initialise(&dev)) != FLASH_SUCCESS)
    {
         error_handler(__FILE__,__LINE__,"decomp()",rc,"Flash initialisation failure",WARNING);
         return ERROR;
    }

    sizeof_flash_buffer = dev.blocksize;

    if ((flash_buf = malloc(sizeof_flash_buffer)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"program_flash()",sizeof_flash_buffer,
           "Unable to malloc Flash buffer",WARNING);
         return ERROR;
    }

    stream.zalloc = Z_NULL; stream.zfree = NULL; stream.opaque = Z_NULL;
    stream.next_in = (Bytef *)ftp_buf; stream.next_out = (Bytef *)flash_buf;

    /* stream.avail_in will have been set in the preceeding FTP fetch state */
    //if (stream.avail_in != FTP_BUFFER_SIZE)
    //{
    //    error_handler(__FILE__,__LINE__,"decomp()",stream.avail_in,
    //      "FTP input buffer to zlib should be full on initialisation",WARNING);
    //    return ERROR;
    //}

    /* We start with an empty output buffer */
    stream.avail_out = sizeof_flash_buffer;

    /* inflateInit() does not perform any decompression apart from reading the zlib header if present,
       so next_in and avail_in may be modified, but next_out and avail_out remain unchanged.  (The
       current image being tested does not contain a zlib header; next_in and next_out remain unchanged
       by inflateInit(). */

    if ((inflateInit(&stream)) != Z_OK)
    {
         error_handler(__FILE__,__LINE__,"decomp()",0,"zlib initialisation error",WARNING);
         return ERROR;
    }

    decomp_initialised = TRUE;
    return DONE;
}

/************************************************************************************/
/* Function: decomp()                                                               */
/* Behaviour: The zlib decompression library is used to consume compressed data     */
/*            from the FTP buffer. It inflates the data into an output buffer which */
/*            is of a size that when full allows the Flash library to take it as a  */
/*            single block of data.  Calls to ui_show_error() occur from within the */
/*            programming state machine (which translates internal error codes to   */
/*            those recognised by the UI Library).                                  */
/* Prerequisites: decomp_init()                                                     */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
static int decomp(void)
{
  int rc;

    if (decomp_stream_end == TRUE)
    {
        return DONE;  // There is no more data to decompress
    }

    /* inflate() decompresses as much data as possible, stopping when the input FTP buffer becomes
       empty or the output Flash buffer becomes full.  next_in, next_out, avail_in, and avail_out
       also get updated. */

    if ((rc = inflate(&stream,Z_SYNC_FLUSH)) != Z_OK)
    {
        if (rc == Z_STREAM_END)
        {
         /* End of compressed data ha been reached and all uncompressed data has been produced */
            decomp_stream_end = TRUE;
        }
        else if (rc == Z_DATA_ERROR)
        {
          /* Input data does not conform to the zlib format of the data is corrupt */
             error_handler(__FILE__,__LINE__,"decomp()",0,"Bad input data",WARNING);
             decomp_stream_end = TRUE;
             return Z_DATA_ERROR;
        }
        else if (rc == Z_MEM_ERROR)
        {
             error_handler(__FILE__,__LINE__,"decomp()",0,"zlib needs more memory",WARNING);
             decomp_stream_end = TRUE;
             return ERROR;
        }
        else if (ftp_query_stream_end() == TRUE)
        {
             error_handler(__FILE__,__LINE__,"decomp()",0,"Image held on server appears to have been truncated",WARNING);
             decomp_stream_end = TRUE;
             return PREMATURE_END_OF_INPUT_DATA;
        }
        else
        {
             error_handler(__FILE__,__LINE__,"decomp()",rc,"zlib inflation error",WARNING);
             decomp_stream_end = TRUE;
             return ERROR;
        }
    }

    /* avail_out is the amt of free space in the output buffer.  avail_out gets incremented as data in the
       output Flash buffer is written to Flash.  avail_out gets decremented by inflate() as zlib fills the
       buffer with decompressed data.  When inflate() drops avail_in to 0 there is no space left in the Flash
       buffer; it is full and ready to be programmed into Flash. */

       if (stream.avail_out == 0)
       {
           stream.next_out = (Bytef *)flash_buf;
       }

    /* avail_in is the number of bytes in the input FTP buffer that have not been consumed by zlib.  avail_in
       gets incremented when the FTP buffer is being filled.  avail_in gets decremented by zlib as inflate()
       consumes data.  When avail_in drops to zero, zlib has consumed all data in the input FTP buffer. */

       if (stream.avail_in == 0)
       {
           stream.next_in = (Bytef *)ftp_buf;
           #ifndef FTP_SIMULATION
           read_amt = FTP_BUFFER_SIZE;  // Tell the ftp fetcher it can start refilling it's buffer.
           #endif
       }

       return DONE;  /* We've decompressed as much data as possible.  Nothing further can be done until
                        work has been done in another state; the output buffer gets emptied in the programming
                        state or the input buffer gets filled in the fetching state. */
}

/************************************************************************************/
/* Function:  decomp_close()                                                        */
/* Behaviour: Resets decompression for a possible restart following user abort or   */
/*            error.  decomp_init() still needs to be called before decomp() can be */
/*            used.                                                                 */
/************************************************************************************/
extern int decomp_close(void)
{
    if (decomp_initialised == TRUE)
    {
        if (flash_buf != NULL)
        {
            free(flash_buf);
            flash_buf = NULL;
        }

        decomp_stream_end = FALSE;

        if (inflateEnd(&stream) != Z_OK)
        {
             error_handler(__FILE__,__LINE__,"decomp_close()",0,
               "Decompression library failed to close, therefore memory leaks expected.",
               WARNING);
             return ERROR;
        }
        decomp_initialised = FALSE;
    }

    return DONE;
}

/************************************************************************************/
/* Function:       program_flash()                                */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
static int program_flash(void)
{
  #ifdef PROGRAMMING_SIMULATION

  /*
    int rc;
    int buffsize = 1024 * 1024;
    static int bytes_taken_out_of_buffer = 0;


      bytes_taken_out_of_buffer = bytes_taken_out_of_buffer + ((1024 * 1024) / 2);
      bytes_programmed = bytes_programmed + ((1024* 1024)/2);

      if (bytes_taken_out_of_buffer == buffsize)
      {
          bytes_taken_out_of_buffer = 0;
          return DONE;
      }
      else
      {
          return IN_PROGRESS;
      }

      return rc;
    */

  static int initialised = FALSE;
  static FILE *flashfile = NULL;
  static int stream_end = FALSE;
  size_t n = 0;

  if (program_flash_reset_flag == TRUE)
  {
   /* We're restarting as a result of user abort or some previous error. */
      stream_end = FALSE;
      fclose(flashfile);
      n = 0;
      bytes_programmed = 0;
      initialised = FALSE;
      program_flash_reset_flag = FALSE;
  }

  if (stream_end == TRUE)
  {
      return DONE;  // Nothing left to program.  We've finished.
  }

  /* Do our equivalent of Flash initialisation.  In this case we 'program' data into a file rather than into Flash. */

  if (initialised == FALSE)
  {
      if ((flashfile = fopen("Flash","wb")) == NULL)
      {
           error_handler(__FILE__,__LINE__,"program_flash()",0,"Could not create Flash file",WARNING);
           return ERROR;
      }
      initialised = TRUE;
  }

  if (stream.avail_out == 0)
  {
   /* The Flash buffer is full and ready to be programmed into Flash as a single block of data. */
      if ((n = fwrite(flash_buf,sizeof(char),sizeof_flash_buffer,flashfile)) != sizeof_flash_buffer)
      {
           error_handler(__FILE__,__LINE__,"program_flash()",n,"Flash block write failure",WARNING);
           fclose(flashfile);
           return ERROR;
      }
      fflush(flashfile);

      bytes_programmed += n;

      if (bytes_programmed == IMAGESIZE)
      {
          fclose(flashfile);
          stream_end = TRUE;
      }

   /* Tell zlib we've freed up space in its output buffer, so it's free to decompress another block of data. */
      stream.avail_out = sizeof_flash_buffer;
  }

  return DONE;

  #endif
}

/************************************************************************************/
/* Function:  program_flash_reset()                                                 */
/************************************************************************************/
extern void program_flash_reset(void)
{
    program_flash_reset_flag = TRUE;
    return;
}

/************************************************************************************/
/* Function:       delay_simulation()                                               */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
#ifdef PROGRAMMING_SIMULATION
/*
static void delay_simulation(int *timer_started,time_t *save_time,int *rc)
{
  int lapsed_time;  in seconds

    if (*timer_started == 0)
    {
        *save_time = time(NULL);
        *timer_started = 1;
        *rc = IN_PROGRESS;
    }
    else
    {
        lapsed_time = (int)(difftime(time(NULL),*save_time));
        if (lapsed_time > TIME_DELAY)
        {
            *rc = DONE;
            *timer_started = 0;
        }
        else
        {
            *rc = IN_PROGRESS;
        }
    }
}
*/
#endif

