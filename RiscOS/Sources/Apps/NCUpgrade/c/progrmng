/************************************************************************************/
/*                                                                                  */
/*  File: progrmng.c                                                                */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*  Documents: programming state machine spreadsheet, drawing no.: 2205,036/DS.     */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  17-Jul-1998  SR        Created                                                  */
/*                                                                                  */
/************************************************************************************/

/* ANSI Includes */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/* System includes */
#include "kernel.h"
#include "swis.h"
#include "zlib/zlib.h"

/* Local includes */
#include "main.h"
#include "ftp.h"
#include "errors.h"
#include "progrmng.h"

#ifdef SIMULATE_FLASH
#include "flashstubs.h"
#else
#include "flash.h"
#endif

enum programming_state {IDLE,
                        FETCHING,
                        DECOMPRESSING,
                        PROGRAMMING};

z_stream stream;
int program_flash_reset_flag = TRUE;

static enum programming_state programming_state = IDLE;
static char *flash_buf = NULL;
static flashdeviceinfo flash;
static int timer_on = FALSE;
static int bytes_programmed = 0;
static int sizeof_flash_buffer = 0;
static int decomp_stream_end = FALSE;
static int decomp_initialised = TRUE;

static int idle_handler(int reason);
static void progress_tracker(void);
static int timer(enum reason_code,int units);
static int e_check(int rc,int line);
static int decomp(void);
static int program_flash(void);
static int check_write(unsigned int byte_offset);
static void vandalize_main_os(void);

#ifndef FTP_SIMULATION
int read_amt = FTP_BUFFER_SIZE;
#endif

/************************************************************************************/
/* Function:  programming_stateMachine()                                            */
/* Behaviour: As defined in the programming state machine spreadsheet 2205,036/DS.  */
/*            ui_show_error() should only be called for errors returned from sub    */
/*            routines that are not state machines.  ui_show_error() is called via  */
/*            e_check().                                                            */
/* Requires:  'reason', which is START, ABORT, CLOSE, or POLL, as defined on the    */
/*            spreadsheet.                                                          */
/* Returns:   DONE, IN_PROGRESS, or ERROR, as defined on the spreadsheet.           */
/************************************************************************************/
extern int programming_stateMachine(enum reason_code reason)
{
  int rc;

    switch (programming_state)
    {
       case IDLE:          switch (reason)
                           {
                              case START:  rc = idle_handler(START);
                                           if ((e_check(rc,__LINE__)) == ERROR)
                                           {
                                                programming_state = IDLE;
                                                return ERROR;
                                           }
                                           else if (rc == IN_PROGRESS)
                                           {
                                                programming_state = FETCHING;
                                                return IN_PROGRESS;
                                           }
                                           else if (rc == DONE)
                                           {
                                                rc = decomp();
                                                if ((e_check(rc,__LINE__)) == ERROR)
                                                {
                                                     programming_state = IDLE;
                                                     return ERROR;
                                                }
                                                else if (rc == DONE)
                                                {
                                                     programming_state = PROGRAMMING;
                                                     return IN_PROGRESS;
                                                }
                                                else if (rc == IN_PROGRESS)
                                                {
                                                     programming_state = DECOMPRESSING;
                                                     return IN_PROGRESS;
                                                }
                                           }
                                           break;
                              case CLOSE:  /* Drop through */
                              case ABORT:  return DONE;
                                           break;
                              case POLL:   error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Poll not valid whilst in idle state.",WARNING);
                                           break;
                              default:     error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Unexpected reason code passed into programming state machine.",WARNING);
                           }
                           break;

       case FETCHING:      switch (reason)
                           {
                              case START: error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Start not valid whilst in fetching state.",WARNING);
                                          break;
                              case ABORT: /* drop through to close */
                              case CLOSE: if ((rc = ftp_stateMachine(CLOSE)) == ERROR)
                                          {
                                               return ERROR;
                                          }
                                          else if ((rc == IN_PROGRESS) || (rc == DONE))
                                          {
                                               programming_state = IDLE;
                                               return DONE;
                                          }
                                          break;
                              case POLL:  if ((rc = ftp_stateMachine(POLL)) == ERROR)
                                          {
                                               return ERROR;
                                          }
                                          else if (rc == IN_PROGRESS)
                                          {
                                               programming_state = FETCHING;
                                               return IN_PROGRESS;
                                          }
                                          else if (rc == DONE)
                                          {
                                               rc = decomp();
                                               if ((e_check(rc,__LINE__)) == ERROR)
                                               {
                                                    programming_state = IDLE;
                                                    return ERROR;
                                               }
                                               else if (rc == DONE)
                                               {
                                                    programming_state = PROGRAMMING;
                                                    return IN_PROGRESS;
                                               }
                                               else if (rc == IN_PROGRESS)
                                               {
                                                    programming_state = DECOMPRESSING;
                                                    return IN_PROGRESS;
                                               }
                                          }
                                          break;
                              default:    error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Unexpected reason code passed into programming state machine.",WARNING);
                           }
                           break;

       case DECOMPRESSING: switch (reason)
                           {
                              case START: error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Start not valid whilst in decompressing state.",WARNING);
                                          break;
                              case ABORT: /* Drop through */
                              case CLOSE: if ((rc = ftp_stateMachine(CLOSE)) == ERROR)
                                          {
                                               return ERROR;
                                          }
                                          else if ((rc == IN_PROGRESS) || (rc == DONE))
                                          {
                                               programming_state = IDLE;
                                               return DONE;
                                          }
                                          break;
                              case POLL:  rc = decomp();
                                          if ((e_check(rc,__LINE__)) == ERROR)
                                          {
                                               programming_state = IDLE;
                                               return DONE;
                                          }
                                          else if (rc == IN_PROGRESS)
                                          {
                                               programming_state = DECOMPRESSING;
                                               return IN_PROGRESS;
                                          }
                                          else if (rc == DONE)
                                          {
                                               rc = program_flash();
                                               if ((e_check(rc,__LINE__)) == ERROR)
                                               {
                                                    programming_state = IDLE;
                                                    return ERROR;
                                               }
                                               else if (rc == IN_PROGRESS)
                                               {
                                                    programming_state = PROGRAMMING;
                                                    return IN_PROGRESS;
                                               }
                                               else if (rc == DONE)
                                               {
                                                    programming_state = PROGRAMMING;
                                                    /* It'll realise it's done on the next poll in the new state. */
                                                    return IN_PROGRESS;
                                               }
                                          }
                                          break;
                              default:    error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Unexpected reason code passed into programming state machine.",WARNING);
                           }
                           break;
       case PROGRAMMING:   switch (reason)
                           {
                              case START: error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Start not valid whilst in programming state.",WARNING);
                                          break;
                              case ABORT: /* Drop through */
                              case CLOSE: ftp_stateMachine(CLOSE);
                                          programming_state = IDLE;
                                          /* No need to check return value on this one. */
                                          return DONE;
                                          break;
                              case POLL:  rc = program_flash();
                                          if ((e_check(rc,__LINE__)) == ERROR)
                                          {
                                               programming_state = IDLE;
                                               return ERROR;
                                          }
                                          else if (rc == IN_PROGRESS)
                                          {
                                               programming_state = PROGRAMMING;
                                               return IN_PROGRESS;
                                          }
                                          else if (rc == DONE)
                                          {
                                               progress_tracker();
                                               if ((rc = ftp_stateMachine(START)) == ERROR)
                                               {
                                                    programming_state = IDLE;
                                                    return ERROR;
                                               }
                                               else if (rc == IN_PROGRESS)
                                               {
                                                    programming_state = FETCHING;
                                                    return IN_PROGRESS;
                                               }
                                               else if (rc == DONE)
                                               {
                                                    if (bytes_programmed == IMAGESIZE)
                                                    {
                                                        programming_state = IDLE;
                                                        return DONE;
                                                    }
                                                    else
                                                    {
                                                        programming_state = FETCHING;
                                                        /* It'll realise it's done on */
                                                        /* the next poll in the new   */
                                                        /* state.                     */
                                                        return IN_PROGRESS;
                                                    }
                                               }
                                          }
                                          break;
                              default:    error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                                             "Unexpected reason code passed into programming state machine.",WARNING);
                           }
                           break;
       default:            error_handler(__FILE__,__LINE__,"programming_stateMachine()",0,
                              "Unrecognised programming state.",WARNING);
    }

    return ERROR;
}

#ifdef SIMULATE_FLASH
/************************************************************************************/
/* Function:  idle_handler()                                                        */
/* Behaviour: Separated out from the programming state machine (for clarity).       */
/*            Carries out work associated with starting the programming state       */
/*            machine, namely, uses flash stubs from the original flash API spec to */
/*            simulate writing to Flash, and starts the FTP state machine.          */
/* Requires:  'reason', which in this context should be 'START' (see programming_   */
/*            stateMachine()).                                                      */
/* Returns:   IN_PROGRESS, ERROR, or DONE (see calling context for definitions).    */
/************************************************************************************/
static int idle_handler(int reason)
{
  int rc;

    switch (reason)
    {
      case START: if ((rc = flash_initialise(&flash)) != FLASH_SUCCESS)
                  {
                       switch (rc)
                       {
                         case FLASH_DEVICE_UNKNOWN: return FLASH_DEVICE_UNKNOWN;
                                                    break;
                         case FLASH_DEVICE_TIMEOUT: return FLASH_DEVICE_TIMEOUT;
                                                    break;
                         case FLASH_PROGRAMMING_ERR:return FLASH_PROGRAMMING_ERR;
                                                    break;
                         default:                   error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                                    "Unexpected return code from flash_initialise()",FATAL);
                       }
                  }
                  if ((rc = flash_allowlockwrite()) != FLASH_SUCCESS)
                  {
                       switch (rc)
                       {
                         case FLASH_INIT_ERR:       error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                                    "Flash library should be initialised, or we should not be here.",FATAL);
                                                    break;
                         case FLASH_DEVICE_TIMEOUT: return FLASH_DEVICE_TIMEOUT;
                                                    break;
                         case FLASH_PROGRAMMING_ERR:return FLASH_PROGRAMMING_ERR;
                                                    break;
                         default:                   error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                                    "Unexpected return code from flash_allowlockwrite()",FATAL);
                       }
                  }
                  if ((rc = flash_chiperase()) != FLASH_SUCCESS)
                  {
                       switch (rc)
                       {
                         case FLASH_INIT_ERR:       error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                                    "Flash library should be initialised, or we should not be here.",FATAL);
                                                    break;
                         case FLASH_DEVICE_TIMEOUT: return FLASH_DEVICE_TIMEOUT;
                                                    break;
                         case FLASH_BLOCK_LOCKED:   error_handler(__FILE__,__LINE__,"idle_handler()",0,"We've already called flash_allowlockwrite() so we should be able to write to locked blocks.",FATAL);
                                                    break;
                         case FLASH_PROGRAMMING_ERR:return FLASH_PROGRAMMING_ERR;
                                                    break;
                         default:                   error_handler(__FILE__,__LINE__,"idle_handler()",0,"Unexpected return code from flash_chiperase()",FATAL);
                       }
                  }
                  rc = ftp_stateMachine(START);
                  switch (rc)
                  {
                    case IN_PROGRESS: return IN_PROGRESS;
                                      break;
                    case ERROR:       return ERROR;
                                      break;
                    case DONE:        return DONE;
                                      break;
                    default:          error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                      "Unexpected return code from ftp_stateMachine()",FATAL);
                  }
                  break;
      default:    error_handler(__FILE__,__LINE__,"idle_handler()",0,
                  "Unexpected reason code passed into idle_handler()",FATAL);
    }

    return ERROR;
}
#else
/************************************************************************************/
/* Function:  idle_handler()                                                        */
/* Behaviour: Separated out from the programming state machine (for clarity).       */
/*            Carries out work associated with starting the programming state       */
/*            machine, namely, checks that Flash is large enough, erases in         */
/*            preparation for Flash write, starts the FTP state machine.            */
/* Requires:  'reason', which in this context should be 'START' (see programming_   */
/*            stateMachine()).                                                      */
/* Returns:   IN_PROGRESS, ERROR, or DONE (see calling context for definitions).    */
/************************************************************************************/
static int idle_handler(int reason)
{
   int rc;
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;

    switch (reason)
    {
      case START: if ((er = _kernel_swi(FlashWrite_DeviceInfo,&regs,&regs)) != NULL)
                  {
                       error_handler(__FILE__,__LINE__,"idle_handler()",er->errnum,er->errmess,WARNING);
                       return FLASH_DEVICE_INFO_ERR;
                  }
                  if (regs.r[0] < IMAGESIZE)
                  {
                      error_handler(__FILE__,__LINE__,"idle_handler()",regs.r[0],"Flash is not large enough",WARNING);
                      return FLASH_PROGRAMMING_ERR;
                  }
                  flash.sizeof_flash = regs.r[0];  /* byte size */
                  flash.blocksize = regs.r[2];     /* byte size */

                  if ((er = _kernel_swi(FlashWrite_EraseFlash,&regs,&regs)) != NULL)
                  {
                       error_handler(__FILE__,__LINE__,"idle_handler()",er->errnum,er->errmess,WARNING);
                       return FLASH_PROGRAMMING_ERR;
                  }

                  rc = ftp_stateMachine(START);
                  switch (rc)
                  {
                    case IN_PROGRESS: return IN_PROGRESS;
                                      break;
                    case ERROR:       return ERROR;
                                      break;
                    case DONE:        return DONE;
                                      break;
                    default:          error_handler(__FILE__,__LINE__,"idle_handler()",0,
                                      "Unexpected return code from ftp_stateMachine()",WARNING);
                  }
                  break;
      default:    error_handler(__FILE__,__LINE__,"idle_handler()",0,
                  "Unexpected reason code passed into idle_handler()",WARNING);
    }

    return ERROR;
}

#endif

/************************************************************************************/
/* Function:      progress_tracker()                                                */
/* Behaviour:     Calculates estimated time remaining and percentage complete.      */
/* Prerequisites: Must be called once from the same place on each cycle (otherwise  */
/*                calculated estimates will be inaccurate).  A cycle is defined as  */
/*                a single progression through each of the three working states of  */
/*                the programming state machine.                                    */
/* Outputs:       Percentage complete and estimated time remaining to the UI Lib.   */
/* Notes:         The image held on the server is compressed.  Therefore it cannot  */
/*                be used to estimate progress.  As an example the current image    */
/*                being used is fully downloaded at the 68% mark.  After that it    */
/*                is all decompressing and programming to flash with no further     */
/*                fetching required. This note is germane to anyone wanting to      */
/*                alter the way in which progress tracking works.                   */
/*                                                                                  */
/*                We only work in seconds at the start of the upgrade.              */
/*                Calculations done in seconds during later stages result in        */
/*                overflow.                                                         */
/************************************************************************************/
static void progress_tracker(void)
{
  int mins_used;
  int secs_used;
  static int mins_remaining;
  static int secs_remaining;
  int bytes_remaining;
  double percent_complete;
  _kernel_oserror *er;
  int bytes_fetched = 0;

    if (timer_on == FALSE)
    {
        timer(START,1);
        timer_on = TRUE;
    }

    percent_complete = ((double)bytes_programmed / IMAGESIZE) * 100;

    if ((er = ui_set_progress_percent(0,(int)percent_complete)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"progress_tracker()",er->errnum,er->errmess,
           WARNING);
    }

    if (bytes_programmed == 0)
    {
     /* Base our estimated time remaining on the amount of data fetched so far. */
     /* If no data has been fetched, clear the ui time display.                 */

        bytes_fetched = total_bytes_fetched(1,0);

        if (bytes_fetched > 0)
        {
            secs_used = timer(POLL,0);
            bytes_remaining = IMAGESIZE - bytes_fetched;

            /* XXX: huh? check.  This looks wrong.  Look instead at bytes decompressed perhaps. */

            secs_remaining = (secs_used * bytes_remaining) / bytes_fetched;

            if (secs_remaining > 0)
            {
                if ((er = ui_set_estimated_download_time(0u,secs_remaining / 60,0)) != NULL)
                {
                     error_handler(__FILE__,__LINE__,"progress_tracker()",er->errnum,er->errmess,WARNING);
                }
                return;
            }
        }

        if ((er = ui_set_estimated_download_time(0u,-1,0)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"progress_tracker()",er->errnum,er->errmess,WARNING);
             return;
        }
    }
    else
    {
     /* Estimated time remaining can now include time taken to program Flash. */

        mins_used = timer(POLL,1);
        bytes_remaining = IMAGESIZE - bytes_programmed;
        mins_remaining = (mins_used * bytes_remaining) / bytes_programmed;

        if (mins_remaining == 0)
        {
             return;
        }
        else if ((er = ui_set_estimated_download_time(0u,mins_remaining,0)) != NULL)
        {
                  error_handler(__FILE__,__LINE__,"progress_tracker()",er->errnum,er->errmess,WARNING);
        }
    }

    return;
}

/************************************************************************************/
/* Function:       timer()                                                          */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: minutes used, or 0 on start or error. */
/* Outputs: */
/************************************************************************************/
static int timer (enum reason_code reason,int units)
{
  static time_t save_time;
  int seconds = 0;
  int minutes = 1;

    switch (reason)
    {
      case START: save_time = time(NULL);
                  break;
      case POLL:  if (units == minutes)
                  {
                      return (int) ((difftime(time(NULL),save_time))/60);
                  }
                  else if (units == seconds)
                  {
                      return (int) (difftime(time(NULL),save_time));
                  }
                  else
                  {
                      error_handler(__FILE__,__LINE__,"timer()",0,"Unrecognised units request",WARNING);
                  }
                  break;
      default:    error_handler(__FILE__,__LINE__,"timer()",0,
                  "Unexpected reason code.",FATAL);
    }

    return 0;
}

/************************************************************************************/
/* Function:  e_check()                                                             */
/* Behaviour: Checks return codes for error.  Internal error codes are translated   */
/*            to those recognised by the UI Library before it is called to display  */
/*            the error.                                                            */
/* Requires:  - 'rc', which is the return code to check.                            */
/*            - 'line', which is the line at which the error occurred.              */
/* Returns:   Return code unchanged if not an error, otherwise ERROR is returned in */
/*            accordance with the state machine spreadsheet.                        */
/* Outputs:   On error, an error pop-up via the UI Library, error diagnostics to a  */
/*            log file (providing logging is turned on), and error diagnostics to a */
/*            system variable "err".                                                */
/************************************************************************************/
static int e_check(int rc,int line)
{
  int err_flags = 1;
  int pause_flags = 0;
  error_t report_err;
  _kernel_oserror *er;

    if ((rc != IN_PROGRESS) && (rc != DONE))
    {
         report_err = translate(rc);
         if ((er = ui_show_error(err_flags,report_err)) != NULL)
         {
              error_handler(__FILE__,line,"programming_stateMachine()",er->errnum,
                er->errmess,WARNING);
         }
         else
         {
              pause(pause_flags);
         }
         rc = ERROR;
    }

    return rc;
}

/************************************************************************************/
/* Function:  decomp_init()                                                         */
/************************************************************************************/
extern int decomp_init(void)
{
  #ifndef SIMULATE_FLASH
  _kernel_oserror *er = NULL;
  _kernel_swi_regs regs;
  #else
  int rc;
  #endif

    decomp_stream_end = FALSE;

    #ifdef SIMULATE_FLASH
    if ((rc = flash_initialise(&flash)) != FLASH_SUCCESS)
    {
         error_handler(__FILE__,__LINE__,"decomp()",rc,"Flash initialisation failure",WARNING);
         return ERROR;
    }
    #else

    if ((er = _kernel_swi(FlashWrite_DeviceInfo,&regs,&regs)) != NULL)
    {
         /* XXX: need to insert a ui_show_err() here and then get back to the welcome screen */
         /*      or wherever.                                                                */
         error_handler(__FILE__,__LINE__,"idle_handler()",er->errnum,er->errmess,WARNING);
         return FLASH_PROGRAMMING_ERR;
    }
    if (regs.r[0] < IMAGESIZE)
    {
        error_handler(__FILE__,__LINE__,"idle_handler()",regs.r[0],"Flash is not large enough",WARNING);
        return FLASH_PROGRAMMING_ERR;
    }
    flash.sizeof_flash = regs.r[0];  /* byte size */
    flash.blocksize = regs.r[2];     /* byte size */

    /*

    if ((er = _kernel_swi(FlashWrite_EraseFlash,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"idle_handler()",er->errnum,er->errmess,WARNING);
         return FLASH_PROGRAMMING_ERR;
    }

    */

    #endif

    sizeof_flash_buffer = flash.blocksize;

    if ((flash_buf = malloc(sizeof_flash_buffer)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"program_flash()",sizeof_flash_buffer,
           "Unable to malloc Flash buffer",WARNING);
         return FLASH_PROGRAMMING_ERR;
    }

    stream.zalloc = Z_NULL; stream.zfree = NULL; stream.opaque = Z_NULL;
    stream.next_in = (Bytef *)ftp_buf; stream.next_out = (Bytef *)flash_buf;

    /* We start with an empty output buffer */
    stream.avail_out = sizeof_flash_buffer;

    /* inflateInit() does not perform any decompression apart from reading the zlib header if present,
       so next_in and avail_in may be modified, but next_out and avail_out remain unchanged.  (The
       current image being tested does not contain a zlib header; next_in and next_out remain unchanged
       by inflateInit(). */

    if ((inflateInit(&stream)) != Z_OK)
    {
         error_handler(__FILE__,__LINE__,"decomp()",0,"zlib initialisation error",WARNING);
         return FLASH_PROGRAMMING_ERR;
    }

    decomp_initialised = TRUE;
    return DONE;
}

/************************************************************************************/
/* Function:  decomp()                                                              */
/* Behaviour: The zlib decompression library is used to consume compressed data     */
/*            from the FTP buffer. It inflates the data into an output buffer which */
/*            is of a size that when full allows the Flash library to take it as a  */
/*            single block of data.  Calls to ui_show_error() occur from within the */
/*            programming state machine (which translates internal error codes to   */
/*            those recognised by the UI Library).                                  */
/* Prerequisites: decomp_init()                                                     */
/* Returns:   DONE, or an error code recognised by translate() in error.c.          */
/************************************************************************************/
static int decomp(void)
{
  int rc;

    if (decomp_stream_end == TRUE)
    {
     /* There is no more data to decompress */
        return DONE;
    }

    /* inflate() decompresses as much data as possible, stopping when the input FTP buffer becomes
       empty or the output Flash buffer becomes full.  next_in, next_out, avail_in, and avail_out
       also get updated. */

    if ((rc = inflate(&stream,Z_SYNC_FLUSH)) != Z_OK)
    {
        if (rc == Z_STREAM_END)
        {
         /* End of compressed data has been reached and all uncompressed data has been produced */
            decomp_stream_end = TRUE;
        }
        else if (rc == Z_DATA_ERROR)
        {
          /* Input data does not conform to the zlib format of the data is corrupt */
             error_handler(__FILE__,__LINE__,"decomp()",0,"Bad input data",WARNING);
             decomp_stream_end = TRUE;
             return Z_DATA_ERROR;
        }
        else if (rc == Z_MEM_ERROR)
        {
             error_handler(__FILE__,__LINE__,"decomp()",0,"zlib needs more memory",WARNING);
             decomp_stream_end = TRUE;
             return FLASH_PROGRAMMING_ERR;
        }
        else if (ftp_query_stream_end() == TRUE)
        {
             error_handler(__FILE__,__LINE__,"decomp()",0,"Image held on server appears to have been truncated",WARNING);
             decomp_stream_end = TRUE;
             return PREMATURE_END_OF_INPUT_DATA;
        }
        else
        {
             error_handler(__FILE__,__LINE__,"decomp()",rc,"zlib inflation error",WARNING);
             decomp_stream_end = TRUE;
             return FLASH_PROGRAMMING_ERR;
        }
    }

    /* avail_out is the amt of free space in the output buffer.  avail_out gets incremented as data in the
       output Flash buffer is written to Flash.  avail_out gets decremented by inflate() as zlib fills the
       buffer with decompressed data.  When inflate() drops avail_in to 0 there is no space left in the Flash
       buffer; it is full and ready to be programmed into Flash. */

       if (stream.avail_out == 0)
       {
           stream.next_out = (Bytef *)flash_buf;
       }

    /* avail_in is the number of bytes in the input FTP buffer that have not been consumed by zlib.  avail_in
       gets incremented when the FTP buffer is being filled.  avail_in gets decremented by zlib as inflate()
       consumes data.  When avail_in drops to zero, zlib has consumed all data in the input FTP buffer. */

       if (stream.avail_in == 0)
       {
           stream.next_in = (Bytef *)ftp_buf;
           #ifndef FTP_SIMULATION
           read_amt = FTP_BUFFER_SIZE;  /* Tell the ftp fetcher it can start refilling it's buffer. */
           #endif
       }

       return DONE;  /* We've decompressed as much data as possible.  Nothing further can be done until
                        work has been done in another state; the output buffer gets emptied in the programming
                        state or the input buffer gets filled in the fetching state. */
}

/************************************************************************************/
/* Function:  decomp_close()                                                        */
/* Behaviour: Resets decompression for a possible restart following user abort or   */
/*            error.  decomp_init() still needs to be called before decomp() can be */
/*            used.                                                                 */
/************************************************************************************/
extern int decomp_close(void)
{
    if (decomp_initialised == TRUE)
    {
        if (flash_buf != NULL)
        {
            free(flash_buf);
            flash_buf = NULL;
        }

        decomp_stream_end = FALSE;

        if (inflateEnd(&stream) != Z_OK)
        {
             error_handler(__FILE__,__LINE__,"decomp_close()",0,
               "Decompression library failed to close, therefore memory leaks expected.",
               WARNING);
             return ERROR;
        }
        decomp_initialised = FALSE;
    }

    return DONE;
}

#ifdef SIMULATE_FLASH
/************************************************************************************/
/* Function:       program_flash()                                */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
static int program_flash(void)
{

  static int initialised = FALSE;
  static FILE *flashfile = NULL;
  static int stream_end = FALSE;
  size_t n = 0;

  if (program_flash_reset_flag == TRUE)
  {
   /* We're restarting as a result of user abort or some previous error. */
      stream_end = FALSE;
      fclose(flashfile);
      n = 0;
      bytes_programmed = 0;
      initialised = FALSE;
      program_flash_reset_flag = FALSE;
  }

  if (stream_end == TRUE)
  {
      return DONE;  /* Nothing left to program.  We've finished. */
  }

  /* Do our equivalent of Flash initialisation.  In this case we 'program' data into a file rather than into Flash. */

  if (initialised == FALSE)
  {
      if ((flashfile = fopen("Flash","wb")) == NULL)
      {
           error_handler(__FILE__,__LINE__,"program_flash()",0,"Could not create Flash file",WARNING);
           return FLASH_PROGRAMMING_ERR;
      }
      initialised = TRUE;
  }

  if (stream.avail_out == 0)
  {
   /* The Flash buffer is full and ready to be programmed into Flash as a single block of data. */
      if ((n = fwrite(flash_buf,sizeof(char),sizeof_flash_buffer,flashfile)) != sizeof_flash_buffer)
      {
           error_handler(__FILE__,__LINE__,"program_flash()",n,"Flash block write failure",WARNING);
           fclose(flashfile);
           return FLASH_PROGRAMMING_ERR;
      }
      fflush(flashfile);

      bytes_programmed += n;

      if (bytes_programmed == IMAGESIZE)
      {
          fclose(flashfile);
          stream_end = TRUE;
      }

   /* Tell zlib we've freed up space in its output buffer, so it's free to decompress another block of data. */
      stream.avail_out = sizeof_flash_buffer;
  }

  return DONE;

}
#else
/************************************************************************************/
/* Function:       program_flash()                                */
/* Behaviour: */
/* Prerequisites: */
/* Requires: */
/* Returns: */
/* Outputs: */
/************************************************************************************/
static int program_flash(void)
{
  static int stream_end = FALSE;
  static unsigned int byte_offset = 0;
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;

    if (program_flash_reset_flag == TRUE)
    {
     /* We're restarting as a result of usr abort or some previous error. */
        stream_end = FALSE;
        bytes_programmed = 0;
        byte_offset = 0;
        program_flash_reset_flag = FALSE;
    }
    if (stream_end == TRUE)
    {
        return DONE;  /* Nothing left to program.  We've finished. */
    }

    if (stream.avail_out == 0)
    {

     /* The Flash buffer is full and ready to be programmed into Flash as a single block of data. */
        regs.r[0] = byte_offset;       /* Offset from base of Flash */
        regs.r[1] = (int)flash_buf;    /* Block of data             */

        #ifdef CHECK_VERIFY
        if ((er = _kernel_swi(FlashWrite_WriteWord,&regs,&regs)) != NULL)
        #else
        if ((er = _kernel_swi(FlashWrite_WriteBlock,&regs,&regs)) != NULL)
        #endif
        {
             error_handler(__FILE__,__LINE__,"program_flash()",er->errnum,er->errmess,WARNING);
             if (er->errnum == FLASH_WRITEBUFF_BUFFERBUSY)
             {
                 /*XXX: I'm assuming the FlashWrite request has not been queued by the module and */
                 /*     I do in fact need to call it again.                                       */
                 return IN_PROGRESS;
             }
             else
             {
                 return FLASH_PROGRAMMING_ERR;
             }
        }

        if ((check_write(byte_offset)) != SUCCESS)
        {
             return FLASH_PROGRAMMING_ERR;
        }

        bytes_programmed += sizeof_flash_buffer;

        byte_offset += (unsigned int)sizeof_flash_buffer;

        if (bytes_programmed == IMAGESIZE)
        {
            stream_end = TRUE;
        }

     /* Tell zlib we've freed up space in its output buffer, so it's free to decompress another block of data. */
        stream.avail_out = sizeof_flash_buffer;
    }

    return DONE;
}

/************************************************************************************/
/* Function:  check_write()                                                         */
/* Behaviour: Checks that what we think we've written to Flash really has been      */
/*            written to Flash.                                                     */
/* Requires: */
/* Returns:   SUCCESS, or FAILURE.                                                  */
/************************************************************************************/
static int check_write(unsigned int byte_offset)
{
  char *verification_buffer = NULL;
  int i;
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;

    if ((verification_buffer = calloc(flash.blocksize,1)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"check_write()",flash.blocksize,
           "Insufficient memory for validating what's been programmed to Flash",WARNING);
         return FAILURE;
    }

    regs.r[0] = byte_offset;
    regs.r[1] = (int)verification_buffer;
    if ((er = _kernel_swi(FlashWrite_ReadBlock,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"check_write()",er->errnum,er->errmess,WARNING);
         if (verification_buffer != NULL)
         {
             free(verification_buffer);
         }
         return FAILURE;
    }

    /* Now compare what we've read back from Flash with our original Flash write buffer. */
    for (i = 0; i < flash.blocksize; i++)
    {
         if ((*flash_buf) != (*verification_buffer))
         {
              error_handler(__FILE__,__LINE__,"check_write()",i,"Flash verification failed.",WARNING);
              if (verification_buffer != NULL)
              {
                  free(verification_buffer);
              }
              vandalize_main_os();
              return FAILURE;
         }
    }

    if (verification_buffer != NULL)
    {
        free(verification_buffer);
    }

    return SUCCESS;
}

/************************************************************************************/
/* Function:  vandalize_main_os()                                                   */
/* Behaviour: If one of our Flash write verification checks fail, we want to be     */
/*            certain that the kernel will not think there is a valid Main OS       */
/*            present on start up.  (This has already happened once when the Flash  */
/*            module was only programming the start of each block - the kernel      */
/*            still thought there was a valid Main OS present).  Regardless of the  */
/*            amt of padding in an image, the magic string "NCOS" will always appear*/
/*            16 bytes from the end of the image.  Remove this and the kernel will  */
/*            know for certain that there is no valid Main OS present.              */
/************************************************************************************/
static void vandalize_main_os(void)
{
  int garbage = 0;
  int verification = -1;
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;

    regs.r[0] = IMAGESIZE - 16;  /* Byte offset from Flash base. */
    regs.r[1] = garbage;
    if ((er = _kernel_swi(FlashWrite_WriteWord,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"vandalize_main_os()",er->errnum,er->errmess,WARNING);
      /* error_handler() notes the error for the attention of engineers during development,
         but this isn't something the user needs to be concerned about since we've already
         reported a Flash programming error.  */
         return;
    }

    /* Check that we really have written over the magic string "NCOS" */
    regs.r[0] = IMAGESIZE - 16;
    if ((er = _kernel_swi(FlashWrite_ReadWord,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"vandalize_main_os()",er->errnum,er->errmess,WARNING);
      /* error_handler() notes the error for the attention of engineers during development,
         but this isn't something the user needs to be concerned about since we've already
         reported a Flash programming error.  */
         return;
    }
    verification = regs.r[1];

    if (verification != garbage)
    {
        error_handler(__FILE__,__LINE__,"vandalize_main_os()",0,"Garbage data overwrite of magic word NCOS has failed.",
          WARNING);
    }

    return;
}

#endif

/************************************************************************************/
/* Function:  program_flash_reset()                                                 */
/************************************************************************************/
extern void program_flash_reset(void)
{
    program_flash_reset_flag = TRUE;
    return;
}

