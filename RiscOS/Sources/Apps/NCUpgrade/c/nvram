/************************************************************************************/
/*                                                                                  */
/*  File: nvram.c                                                                   */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  17-Jul-1998  SR        Created                                                  */
/*                                                                                  */
/************************************************************************************/

/* ANSI Includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

/* System includes */
#include "kernel.h"
#include "inetlib.h"

/* Local includes */
#include "ui.h"
#include "errors.h"
#include "main.h"
#include "nvram.h"

#if defined(NVRAM_SINGLE_TAG)
static int getsize(setup_details_t *defaults);
static void buff_write(char *p, setup_details_t *defaults);
#elif defined (REAL_NVRAM) && defined(NVRAM_MULTIPLE_TAGS)
static char * read_field(const char *tagname);
static void write_field(const char *tagname,char *buff,int size);
#endif

#if defined(REAL_NVRAM) && defined(NVRAM_MULTIPLE_TAGS)
/************************************************************************************/
/* Function:      get_nvram_defaults()                                              */
/* Behaviour:     Read defaults from nvram and hand them over to the UI Library.    */
/************************************************************************************/
extern void get_nvram_defaults(void)
{
  int size = 0;
  int flags = 0;
  int i = 0;
  static setup_details_t defaults;
  char *p = NULL;
  struct in_addr dns1;
  struct in_addr dns2;
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;
  const char country_code_tagname[] = COUNTRY_CODE_TAGNAME;
  const char outside_line_prefix_tagname[] = OUTSIDE_LINE_PREFIX_TAGNAME;
  const char call_waiting_prefix_tagname[] = CALL_WAITING_PREFIX_TAGNAME;
  const char wait_for_dialtone_flag_tagname[] = WAIT_FOR_DIALTONE_FLAG_TAGNAME;
  const char isp_phonenum_tagname[] = ISP_PHONENUM_TAGNAME;
  const char isp_username_tagname[] = ISP_USERNAME_TAGNAME;
  const char isp_password_tagname[] = ISP_PASSWORD_TAGNAME;
  const char dns1_tagname[] = DNS1_TAGNAME;
  const char dns2_tagname[] = DNS2_TAGNAME;
  const char local_domain_tagname[] = LOCAL_DOMAIN_TAGNAME;
  const char modem_script_tagname[] = MODEM_SCRIPT_TAGNAME;
  const char ftp_url_tagname[] = FTP_URL_TAGNAME;
  const char ftp_username_tagname[] = FTP_USERNAME_TAGNAME;
  const char ftp_password_tagname[] = FTP_PASSWORD_TAGNAME;

    /* Initialise members */
    defaults.phone.country_code = -1;
    defaults.phone.outside_line_prefix = defaults.phone.call_waiting_prefix = NULL;
    defaults.phone.wait_for_dialtone_flag = 0;

    defaults.isp.phone_number = defaults.isp.username = defaults.isp.password =
    defaults.isp.dns = defaults.isp.modem_script = NULL;

    defaults.ftp.url = defaults.ftp.username = defaults.ftp.password = NULL;

    /* Fetch country code */
    regs.r[0] = (int)country_code_tagname;
    regs.r[1] = (int)&defaults.phone.country_code;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
    }

    /* Fetch dial tone flag */
    regs.r[0] = (int)wait_for_dialtone_flag_tagname;
    regs.r[1] = 0;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
    }
    else
    {
         size = regs.r[0];
         if (size != 1)
         {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",size,"Unexpected WaitForDialToneFlag size",WARNING);
         }
         else
         {
             regs.r[0] = (int)wait_for_dialtone_flag_tagname;
             regs.r[1] = (int)&defaults.phone.wait_for_dialtone_flag;
             regs.r[2] = NVRAM_WAIT_FOR_DIALTONE_FLAG_BYTE_LEN;
             if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
             {
                  error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
             }
         }
    }

    /* Fetch codes of type string */
    defaults.phone.outside_line_prefix = read_field(outside_line_prefix_tagname);
    defaults.phone.call_waiting_prefix = read_field(call_waiting_prefix_tagname);
    defaults.isp.phone_number = read_field(isp_phonenum_tagname);
    defaults.isp.username = read_field(isp_username_tagname);
    defaults.isp.password = read_field(isp_password_tagname);
    defaults.isp.modem_script = read_field(modem_script_tagname);
    defaults.ftp.url = read_field(ftp_url_tagname);
    defaults.ftp.username = read_field(ftp_username_tagname);
    defaults.ftp.password = read_field(ftp_password_tagname);
    defaults.isp.domain = read_field(local_domain_tagname);

    /* DNS1 */
    regs.r[0] = (int)dns1_tagname;
    regs.r[1] = (int)&dns1.s_addr;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
    }

    /* DNS2 */
    regs.r[0] = (int)dns2_tagname;
    regs.r[1] = (int)&dns2.s_addr;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
    }

    /* Merge DNS1 and DNS2 */
    if ((defaults.isp.dns = calloc(strlen("xxx.xxx.xxx.xxx xxx.xxx.xxx.xxx") + 2,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",(strlen("xxx.xxx.xxx.xxx xxx.xxx.xxx.xxx") + 2) * sizeof(char),
         "Insufficient memory",WARNING);
    }
    else
    {
         strcpy(defaults.isp.dns,inet_ntoa(dns1));
         strcat(defaults.isp.dns," ");
         strcat(defaults.isp.dns,inet_ntoa(dns2));
    }

    /* On NVRAM reset, by default DNS1 and DNS2 get set to 0 (as is true of any tag).
       This gives us an end result of "0.0.0.0 0.0.0.0". */
    if (defaults.isp.dns != NULL)
    {
        if ((strncmp(defaults.isp.dns,"0.0.0.0 0.0.0.0",strlen("0.0.0.0 0.0.0.0"))) == 0)
        {
             free(defaults.isp.dns);
             defaults.isp.dns = NULL;
        }
        else if ((p = strstr(defaults.isp.dns,"0.0.0.0")) != NULL)
        {
             /* We also need to allow for the user only specifying one DNS address, in which
                case we don't want it to appear as e.g. "136.170.131.2 0.0.0.0" */

                for (i = 0; i < strlen("0.0.0.0"); i++)
                {
                     *p++ = '\0';
                }
        }
    }

    /* On NVRAM reset we would like the modem script to default to the script shown below.
       Since the tags file does not support string values as NVRAM reset defaults, the
       default string is inferred from a stored NVRAM value of 0 (NULL). */

    if (defaults.isp.modem_script != NULL)
    {
        #ifdef LOGFILE
        fprintf(logfile,"NVRAM reset -> defaults.isp.modem_script != NULL\n");
        if (((*(defaults.isp.modem_script)) == 0) && (strlen(defaults.isp.modem_script) == 0))
        {
             fprintf(logfile,"NVRAM reset default detected (0) for modem script\n");
        }
        fflush(logfile);
        #endif

        if (((*(defaults.isp.modem_script)) == 0) && (strlen(defaults.isp.modem_script) == 0))
        {
             free(defaults.isp.modem_script);
             if ((defaults.isp.modem_script = calloc(strlen(DEFAULT_MODEM_DIAL_SCRIPT) + 3,
                  sizeof(char))) == NULL)
             {
                 error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Insufficient memory",WARNING);
                 /* error_handler() notifies the engineer of the problem during development, but this isn't
                    something that the user needs to be concerned about so carry on as normal. */
             }
             else
             {
                 strncpy(defaults.isp.modem_script,DEFAULT_MODEM_DIAL_SCRIPT,
                   strlen(DEFAULT_MODEM_DIAL_SCRIPT));
             }

             #ifdef LOGFILE
             fprintf(logfile,"strlen -> expected value 69, actual value %d\n",
               strlen(DEFAULT_MODEM_DIAL_SCRIPT));
             fprintf(logfile,"script -> %s\n",defaults.isp.modem_script);
             fflush(logfile);
             #endif
        }
    }

    #ifdef LOGFILE
    else
    {
       fprintf(logfile,"defaults.isp.modem_script == NULL\n");
       fflush(logfile);
    }
    #endif

    if ((er = ui_set_defaults(flags,&defaults)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
    }

    if (defaults.phone.outside_line_prefix != NULL)
        free(defaults.phone.outside_line_prefix);

    if (defaults.phone.call_waiting_prefix != NULL)
        free(defaults.phone.call_waiting_prefix);

    if (defaults.isp.phone_number != NULL)
         free(defaults.isp.phone_number);

    if (defaults.isp.username != NULL)
        free(defaults.isp.username);

    if (defaults.isp.password != NULL)
        free(defaults.isp.password);

    if (defaults.isp.modem_script != NULL)
        free(defaults.isp.modem_script);

    if (defaults.isp.dns != NULL)
        free(defaults.isp.dns);

    if (defaults.ftp.url != NULL)
        free(defaults.ftp.url);

    if (defaults.ftp.username != NULL)
        free(defaults.ftp.username);

    if (defaults.ftp.password != NULL)
        free(defaults.ftp.password);

    return;
}

/************************************************************************************/
/* Function read_field()                                                            */
/************************************************************************************/
static char * read_field(const char *tagname)
{
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;
  int size = 0;
  char *buff;

    regs.r[0] = (int)tagname;
    regs.r[1] = 0;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"read_field()",er->errnum,er->errmess,WARNING);
         return NULL;
    }
    size = regs.r[0];  /* Size in bytes */

    if (size <= 0)
    {
        error_handler(__FILE__,__LINE__,"read_field()",size,"Unexpected buffer length",WARNING);
        return NULL;
    }

    /* I'm assuming the returned size does not include a null termination character, */
    /* just to be safe.                                                              */
    if ((buff = calloc(size + 2,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"read_field()",0,"Insufficient memory",WARNING);
         return NULL;
    }

    /* calloc() ensures presence of terminating nulls */
    regs.r[0] = (int)tagname;
    regs.r[1] = (int)buff;
    regs.r[2] = size;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"read_field()",er->errnum,er->errmess,WARNING);
         return NULL;
    }

    return buff;
}

#elif !defined(REAL_NVRAM) && defined(NVRAM_MULTIPLE_TAGS)
/************************************************************************************/
/* Function:      get_nvram_defaults()                                              */
/* Behaviour:     Read defaults from simulated nvram and hand them over to the UI   */
/*                Library.                                                          */
/* Prerequisites: String allocation lengths must match up with intended lengths     */
/*                to be specified in the nvram tags file.                           */
/************************************************************************************/
extern void get_nvram_defaults(void)
{
  #define MAXLEN 256

  char line[MAXLEN];
  FILE *f = NULL;
  int flags = 0;
  char filename[] = "$.nvsim";
  static setup_details_t defaults;
  _kernel_oserror *er = NULL;
  struct in_addr dns1;
  struct in_addr dns2;

    defaults.phone.country_code = 0;
    defaults.phone.outside_line_prefix = defaults.phone.call_waiting_prefix = NULL;
    defaults.phone.wait_for_dialtone_flag = 0;

    defaults.isp.phone_number = defaults.isp.username = defaults.isp.password =
    defaults.isp.dns = defaults.isp.modem_script = NULL;

    defaults.ftp.url = defaults.ftp.username = defaults.ftp.password = NULL;

    if ((f = fopen(filename,"r")) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Cannot open nvram file: nvsim",WARNING);
         goto bypass_nvram;
    }

    /* Country Code */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if (isdigit(line[0]))
    {
         defaults.phone.country_code = atoi(line);
    }

    /* Outside Line Prefix */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.phone.outside_line_prefix = calloc(NVRAM_OUTSIDE_LINE_PREFIX_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_OUTSIDE_LINE_PREFIX_BYTE_LEN *
         sizeof(char),"Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
      /* Earlier use of calloc and the length specified below ensures null termination */
         strncpy(defaults.phone.outside_line_prefix,line,NVRAM_OUTSIDE_LINE_PREFIX_BYTE_LEN - 1);
    }

    /* Call Waiting Prefix */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.phone.call_waiting_prefix = calloc(NVRAM_CALL_WAITING_PREFIX_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_CALL_WAITING_PREFIX_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.phone.call_waiting_prefix,line,NVRAM_CALL_WAITING_PREFIX_BYTE_LEN - 1);
    }

    /* Wait For Dial Tone Flag */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if (line[0] == '1')
    {
         defaults.phone.wait_for_dialtone_flag = 1;
    }
    else
    {
        defaults.phone.wait_for_dialtone_flag = 0;
    }

    /* ISP Phone Number */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.isp.phone_number = calloc(NVRAM_ISP_PHONENUM_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_ISP_PHONENUM_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.isp.phone_number,line,NVRAM_ISP_PHONENUM_BYTE_LEN - 1);
    }

    /* ISP Username */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.isp.username = calloc(NVRAM_ISP_USERNAME_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_ISP_USERNAME_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.isp.username,line,NVRAM_ISP_USERNAME_BYTE_LEN - 1);
    }

    /* ISP Password */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.isp.password = calloc(NVRAM_ISP_PASSWORD_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_ISP_PASSWORD_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.isp.password,line,NVRAM_ISP_PASSWORD_BYTE_LEN - 1);
    }

    /* DNS1 */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.isp.dns = calloc(strlen("xxx.xxx.xxx.xxx xxx.xxx.xxx.xxx") + 2,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",(strlen("xxx.xxx.xxx.xxx xxx.xxx.xxx.xxx") + 2) * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         dns1.s_addr = atoi(line);
         strcpy(defaults.isp.dns,inet_ntoa(dns1));
    }

    /* DNS2 */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else
    {
         dns2.s_addr = atoi(line);
         strcat(defaults.isp.dns," ");
         strcat(defaults.isp.dns,inet_ntoa(dns2));
    }

    /* Modem Script */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.isp.modem_script = calloc(NVRAM_MODEM_SCRIPT_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_MODEM_SCRIPT_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.isp.modem_script,line,NVRAM_MODEM_SCRIPT_BYTE_LEN - 1);
    }

    /* FTP URL */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.ftp.url = calloc(NVRAM_FTP_URL_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_FTP_URL_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.ftp.url,line,NVRAM_FTP_URL_BYTE_LEN - 1);
    }

    /* FTP Username */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.ftp.username = calloc(NVRAM_FTP_USERNAME_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_FTP_USERNAME_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.ftp.username,line,NVRAM_FTP_USERNAME_BYTE_LEN - 1);
    }

    /* FTP Password */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.ftp.password = calloc(NVRAM_FTP_PASSWORD_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_FTP_PASSWORD_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.ftp.password,line,NVRAM_FTP_PASSWORD_BYTE_LEN - 1);
    }

    ui_handover:  if ((er = ui_set_defaults(flags,&defaults)) != NULL)
                  {
                       error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
                  }

    bypass_nvram: if (defaults.phone.outside_line_prefix != NULL)
                      free(defaults.phone.outside_line_prefix);

                  if (defaults.phone.call_waiting_prefix != NULL)
                      free(defaults.phone.call_waiting_prefix);

                  if (defaults.isp.phone_number != NULL)
                      free(defaults.isp.phone_number);

                  if (defaults.isp.username != NULL)
                      free(defaults.isp.username);

                  if (defaults.isp.password != NULL)
                      free(defaults.isp.password);

                  if (defaults.isp.modem_script != NULL)
                      free(defaults.isp.modem_script);

                  if (defaults.isp.dns != NULL)
                      free(defaults.isp.dns);

                  if (defaults.ftp.url != NULL)
                      free(defaults.ftp.url);

                  if (defaults.ftp.username != NULL)
                      free(defaults.ftp.username);

                  if (defaults.ftp.password != NULL)
                      free(defaults.ftp.password);

                  if (f != NULL)
                      fclose(f);

#undef MAXLEN

}

#elif defined(REAL_NVRAM) && defined(NVRAM_SINGLE_TAG)
/************************************************************************************/
/* Function:      get_nvram_defaults()                                              */
/* Behaviour:     Read defaults from nvram and hand them over to the UI Library.    */
/* Prerequisites: Appropriate tag in NV-RAM Tags file.                              */
/* Notes:         Format of nvram SetupInfoBuffer: D=NVRAM_DELIMITER                */
/*                <isp_phoneno>D<isp_username>D<isp_password>D<dns>D                */
/*                <isp_modemstring>D<ftp_url>D<ftp_username>D<ftp_password>D        */
/*                This allows maximum length of each field to vary without changes  */
/*                in this code.  The only restriction is the maximum length of the  */
/*                buffer in which all these details gets stored.  If the UI Library */
/*                wants to place restrictions on the length of individual fields it */
/*                is free to do with no code modification necessary here.           */
/************************************************************************************/
extern void get_nvram_defaults(void)
{
  int i,j;
  int size;
  int flags = 0;
  char *nvram_buffer_ptr = NULL;
  static setup_details_t defaults;
  int delimiters = 0;
  int field_lengths[EXPECTED_NUMBER_OF_DELIMITERS];
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;

    defaults.phone.country_code = 0;
    defaults.phone.outside_line_prefix = defaults.phone.call_waiting_prefix = NULL;
    defaults.phone.wait_for_dialtone_flag = 0;

    defaults.isp.phone_number = defaults.isp.username = defaults.isp.password =
    defaults.isp.dns = defaults.isp.modem_script = NULL;

    defaults.ftp.url = defaults.ftp.username = defaults.ftp.password = NULL;

    regs.r[0] = "SetupInfoBuffer";
    regs.r[1] = 0;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
         goto bypass_nvram;
    }
    size = regs.r[0];

    if ((nvram_buffer_ptr = malloc(size)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",size,
           "Insufficient memory available for nvram buffer.",WARNING);
         goto bypass_nvram;
    }

    regs.r[0] = "SetupInfoBuffer";
    regs.r[1] = nvram_buffer_ptr;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
         goto bypass_nvram;
    }

    i = 0;
    while (i < size)
    {
           if (*(nvram_buffer_ptr+i) == NVRAM_DELIMITER)
           {
               delimiters++;
           }
           i++;
    }

    if (delimiters != EXPECTED_NUMBER_OF_DELIMITERS)
    {
        /* NV-RAM was corrupted and the SetupInfoBuffer has been re-initialised
           to 0, or there are no defaults in store.
         */

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }
    }
    else
    {
        j = 0;
        for (i = 0; i < EXPECTED_NUMBER_OF_DELIMITERS; i++)
        {
             field_lengths[i] = 0;
             while (nvram_buffer_ptr[j] != NVRAM_DELIMITER)
             {
                    field_lengths[i]++;
                    j++;
             }
             j++;
        }

        if (((defaults.phone.outside_line_prefix = malloc(field_lengths[1] + 1) == NULL) ||
            ((defaults.phone.call_waiting_prefix = malloc(field_lengths[2] + 1) == NULL) ||
            ((defaults.isp.phone_number = malloc(field_lengths[4] + 1) == NULL) ||
            ((defaults.isp.username = malloc(field_lengths[5] + 1) == NULL) ||
            ((defaults.isp.password = malloc(field_lengths[6] + 1) == NULL) ||
            ((defaults.isp.dns = malloc(field_lengths[7] + 1) == NULL) ||
            ((defaults.isp.modem_script = malloc(field_lengths[8] + 1) == NULL) ||
            ((defaults.ftp.url = malloc(field_lengths[9] + 1) == NULL) ||
            ((defaults.ftp.username = malloc(field_lengths[10] + 1) == NULL) ||
            ((defaults.ftp.password = malloc(field_lengths[11] + 1) == NULL))
        {
               error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,
                 "Insufficient memory available for reading setup defaults.",WARNING);

               goto bypass_nvram;
        }

        defaults.phone.country_code = atoi(p);
        p += ((int)(log10((double)defaults.phone.country_code))+1) + 1;

        sscanf(p,"%[^'\033']",defaults.phone.outside_line_prefix);
        defaults.phone.outside_line_prefix[field_lengths[1]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.phone.call_waiting_prefix);
        defaults.phone.call_waiting_prefix[field_lengths[2]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        if (*p == '1')
            defaults.phone.wait_for_dialtone_flag = 1;
        else
            defaults.phone.wait_for_dialtone_flag = 0;
        p += 2;

        sscanf(p,"%[^'\033']",defaults.isp.phone_number);
        defaults.isp.phone_number[field_lengths[4]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.username);
        defaults.isp.username[field_lengths[5]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.password);
        defaults.isp.password[field_lengths[6]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.dns);
        defaults.isp.dns[field_lengths[7]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.modem_script);
        defaults.isp.modem_script[field_lengths[8]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.url);
        defaults.ftp.url[field_lengths[9]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.username);
        defaults.ftp.username[field_lengths[10]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.password);
        defaults.ftp.password[field_lengths[11]] = '\0';

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }
    }

    bypass_nvram: if (nvram_buffer_ptr != NULL)
                      free(nvram_buffer_ptr);

                  if (defaults.phone.outside_line_prefix != NULL)
                      free(defaults.phone.outside_line_prefix);

                  if (defaults.phone.call_waiting_prefix != NULL)
                      free(defaults.phone.call_waiting_prefix);

                  if (defaults.isp.phone_number != NULL)
                      free(defaults.isp.phone_number);

                 if (defaults.isp.username != NULL)
                      free(defaults.isp.username);

                  if (defaults.isp.password != NULL)
                      free(defaults.isp.password);

                  if (defaults.isp.modem_script != NULL)
                      free(defaults.isp.modem_script);

                  if (defaults.isp.dns != NULL)
                      free(defaults.isp.dns);

                  if (defaults.ftp.url != NULL)
                      free(defaults.ftp.url);

                  if (defaults.ftp.username != NULL)
                      free(defaults.ftp.username);

                  if (defaults.ftp.password != NULL)
                      free(defaults.ftp.password);

                  return NULL;
}

#elif !defined(REAL_NVRAM) && defined(NVRAM_SINGLE_TAG)
/************************************************************************************/
/* Function:      get_nvram_defaults()                                              */
/* Behaviour:     Read defaults from simulated nvram and hand them over to the UI   */
/*                Library.                                                          */
/* Notes:         Format of nvram SetupInfoBuffer: D=NVRAM_DELIMITER                */
/*                <isp_phoneno>D<isp_username>D<isp_password>D<dns>D                */
/*                <isp_modemstring>D<ftp_url>D<ftp_username>D<ftp_password>D        */
/*                This allows maximum length of each field to vary without changes  */
/*                in this code.  The only restriction is the maximum length of the  */
/*                buffer in which all these details gets stored.  If the UI Library */
/*                wants to place restrictions on the length of individual fields it */
/*                is free to do with no code modification necessary here.           */
/************************************************************************************/
extern void get_nvram_defaults(void)
{
  FILE *f = NULL;
  int size;
  int i,j;
  int flags = 0;
  int delimiters = 0;
  int end,start;
  void *nvram_buffer_ptr = NULL;
  char *p = NULL;
  char filename[] = "$.nvsim";
  int field_lengths[EXPECTED_NUMBER_OF_DELIMITERS];
  static setup_details_t defaults;
  _kernel_oserror *er = NULL;

    defaults.phone.country_code = 0;
    defaults.phone.outside_line_prefix = defaults.phone.call_waiting_prefix = NULL;
    defaults.phone.wait_for_dialtone_flag = 0;

    defaults.isp.phone_number = defaults.isp.username = defaults.isp.password =
    defaults.isp.dns = defaults.isp.modem_script = NULL;

    defaults.ftp.url = defaults.ftp.username = defaults.ftp.password = NULL;

    if ((f = fopen(filename,"rb")) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Cannot open nvram file: nvsim",WARNING);
         goto bypass_nvram;
    }
    rewind(f);
    start = (int)ftell(f);

    if ((fseek(f,0L,SEEK_END)) != 0)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Cannot seek to end of nvram file",WARNING);
         goto bypass_nvram;
    }
    end = (int)ftell(f);

    size = end - start;

    if ((nvram_buffer_ptr = malloc(size)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",size,"Insufficient memory for nvram buffer.",WARNING);
         goto bypass_nvram;
    }
    p = (char *)nvram_buffer_ptr;
    rewind(f);

    if ((fread((char *)nvram_buffer_ptr,sizeof(char),size,f)) != size)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Read failure.",WARNING);
         goto bypass_nvram;
    }

    i = 0;
    while (i < size)
    {
           if (*(p+i) == NVRAM_DELIMITER)
           {
               delimiters++;
           }
           i++;
    }

    if (delimiters != EXPECTED_NUMBER_OF_DELIMITERS)
    {
        /* NV-RAM was corrupted and the SetupInfoBuffer has been re-initialised
           to 0, or there are no defaults in store.
         */

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }
    }
    else
    {
        j = 0;
        for (i = 0; i < EXPECTED_NUMBER_OF_DELIMITERS; i++)
        {
             field_lengths[i] = 0;
             while (p[j] != NVRAM_DELIMITER)
             {
                    field_lengths[i]++;
                    j++;
             }
             j++;
        }

        if (((defaults.phone.outside_line_prefix = malloc(field_lengths[1]+1)) == NULL) ||
            ((defaults.phone.call_waiting_prefix = malloc(field_lengths[2]+1)) == NULL) ||
            ((defaults.isp.phone_number = malloc(field_lengths[4]+1)) == NULL) ||
            ((defaults.isp.username = malloc(field_lengths[5]+1)) == NULL) ||
            ((defaults.isp.password = malloc(field_lengths[6]+1)) == NULL) ||
            ((defaults.isp.dns = malloc(field_lengths[7]+1)) == NULL) ||
            ((defaults.isp.modem_script = malloc(field_lengths[8]+1)) == NULL) ||
            ((defaults.ftp.url = malloc(field_lengths[9]+1)) == NULL) ||
            ((defaults.ftp.username = malloc(field_lengths[10]+1)) == NULL) ||
            ((defaults.ftp.password = malloc(field_lengths[11]+1)) == NULL))
        {
              error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,
                "Insufficient memory available for reading setup defaults.",WARNING);

               goto bypass_nvram;
        }

        defaults.phone.country_code = atoi(p);
        p += ((int)(log10((double)defaults.phone.country_code))+1) + 1;

        sscanf(p,"%[^'\033']",defaults.phone.outside_line_prefix);
        defaults.phone.outside_line_prefix[field_lengths[1]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.phone.call_waiting_prefix);
        defaults.phone.call_waiting_prefix[field_lengths[2]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        if (*p == '1')
            defaults.phone.wait_for_dialtone_flag = 1;
        else
            defaults.phone.wait_for_dialtone_flag = 0;
        p += 2;

        sscanf(p,"%[^'\033']",defaults.isp.phone_number);
        defaults.isp.phone_number[field_lengths[4]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.username);
        defaults.isp.username[field_lengths[5]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.password);
        defaults.isp.password[field_lengths[6]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.dns);
        defaults.isp.dns[field_lengths[7]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.modem_script);
        defaults.isp.modem_script[field_lengths[8]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.url);
        defaults.ftp.url[field_lengths[9]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.username);
        defaults.ftp.username[field_lengths[10]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.password);
        defaults.ftp.password[field_lengths[11]] = '\0';

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }

    }

    bypass_nvram: if (nvram_buffer_ptr != NULL)
                      free(nvram_buffer_ptr);

                  if (defaults.phone.outside_line_prefix != NULL)
                      free(defaults.phone.outside_line_prefix);

                  if (defaults.phone.call_waiting_prefix != NULL)
                      free(defaults.phone.call_waiting_prefix);

                  if (defaults.isp.phone_number != NULL)
                      free(defaults.isp.phone_number);

                 if (defaults.isp.username != NULL)
                      free(defaults.isp.username);

                  if (defaults.isp.password != NULL)
                      free(defaults.isp.password);

                  if (defaults.isp.modem_script != NULL)
                      free(defaults.isp.modem_script);

                  if (defaults.isp.dns != NULL)
                      free(defaults.isp.dns);

                  if (defaults.ftp.url != NULL)
                      free(defaults.ftp.url);

                  if (defaults.ftp.username != NULL)
                      free(defaults.ftp.username);

                  if (defaults.ftp.password != NULL)
                      free(defaults.ftp.password);

                  if (f != NULL)
                      fclose(f);
}
#endif

#if defined(REAL_NVRAM) && defined(NVRAM_MULTIPLE_TAGS)
/************************************************************************************/
/* Function:      write_nvram_defaults()                                            */
/* Behaviour:     Reads setup info entered by the user and saves it to nvram.       */
/* Requires:      Defaults to save to nvram.                                        */
/************************************************************************************/
extern void write_nvram_defaults(setup_details_t *defaults)
{
  char dns1_str[] = "xxx.xxx.xxx.xxx0";
  char dns2_str[] = "xxx.xxx.xxx.xxx0";
  unsigned long dns1_num = 0;
  unsigned long dns2_num = 0;
  _kernel_oserror *er = NULL;
  _kernel_swi_regs regs;
  char *p = NULL;
  const char country_code_tagname[] = COUNTRY_CODE_TAGNAME;
  const char outside_line_prefix_tagname[] = OUTSIDE_LINE_PREFIX_TAGNAME;
  const char call_waiting_prefix_tagname[] = CALL_WAITING_PREFIX_TAGNAME;
  const char wait_for_dialtone_flag_tagname[] = WAIT_FOR_DIALTONE_FLAG_TAGNAME;
  const char isp_phonenum_tagname[] = ISP_PHONENUM_TAGNAME;
  const char isp_username_tagname[] = ISP_USERNAME_TAGNAME;
  const char isp_password_tagname[] = ISP_PASSWORD_TAGNAME;
  const char dns1_tagname[] = DNS1_TAGNAME;
  const char dns2_tagname[] = DNS2_TAGNAME;
  const char local_domain_tagname[] = LOCAL_DOMAIN_TAGNAME;
  const char modem_script_tagname[] = MODEM_SCRIPT_TAGNAME;
  const char ftp_url_tagname[] = FTP_URL_TAGNAME;
  const char ftp_username_tagname[] = FTP_USERNAME_TAGNAME;
  const char ftp_password_tagname[] = FTP_PASSWORD_TAGNAME;

    /* DNS info */
    sscanf(defaults->isp.dns,"%[1234567890.]",dns1_str);
    dns1_num = inet_addr(dns1_str);

    /* strrchr searches from the right */
    p = strrchr(defaults->isp.dns,' ');

    if (p != NULL)
    {
        p++;
    }

    if (p != NULL)
    {
        if (isdigit(p[0]))
        {
            sscanf(p,"%[1234567890.]",dns2_str);
            dns2_num = inet_addr(dns2_str);

        }
    }
    else
    {
        dns2_str[0] = '\0';
    }

    /* Country code */
    regs.r[0] = (int)country_code_tagname;
    regs.r[1] = (int)&defaults->phone.country_code;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Write,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",er->errnum,er->errmess,WARNING);
    }
    if (regs.r[0] != 0)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",regs.r[0],"No such tag or tag not updateable",WARNING);
    }

    write_field(outside_line_prefix_tagname,defaults->phone.outside_line_prefix,NVRAM_OUTSIDE_LINE_PREFIX_BYTE_LEN);
    write_field(call_waiting_prefix_tagname,defaults->phone.call_waiting_prefix,NVRAM_CALL_WAITING_PREFIX_BYTE_LEN);

    /* Wait for dial tone flag */
    regs.r[0] = (int)wait_for_dialtone_flag_tagname;
    regs.r[1] = (int)&defaults->phone.wait_for_dialtone_flag;
    regs.r[2] = NVRAM_WAIT_FOR_DIALTONE_FLAG_BYTE_LEN;
    if ((er = _kernel_swi(NVRAM_Write,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",er->errnum,er->errmess,WARNING);
    }
    if (regs.r[0] != 0)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",regs.r[0],"No such tag or tag not updateable",WARNING);
    }

    write_field(isp_phonenum_tagname,defaults->isp.phone_number,NVRAM_ISP_PHONENUM_BYTE_LEN);
    write_field(isp_username_tagname,defaults->isp.username,NVRAM_ISP_USERNAME_BYTE_LEN);
    write_field(isp_password_tagname,defaults->isp.password,NVRAM_ISP_PASSWORD_BYTE_LEN);

    /* DNS1 */
    regs.r[0] = (int)dns1_tagname;
    regs.r[1] = (int)&dns1_num;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Write,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",er->errnum,er->errmess,WARNING);
    }
    if (regs.r[0] != 0)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",regs.r[0],"No such tag or tag not updateable",WARNING);
    }

    /* DNS2 */
    regs.r[0] = (int)dns2_tagname;
    regs.r[1] = (int)&dns2_num;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Write,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",er->errnum,er->errmess,WARNING);
    }
    if (regs.r[0] != 0)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",regs.r[0],"No such tag or tag not updateable",WARNING);
    }

    write_field(local_domain_tagname,defaults->isp.domain,NVRAM_LOCAL_DOMAIN_BYTE_LEN);
    write_field(modem_script_tagname,defaults->isp.modem_script,NVRAM_MODEM_SCRIPT_BYTE_LEN);
    write_field(ftp_url_tagname,defaults->ftp.url,NVRAM_FTP_URL_BYTE_LEN);
    write_field(ftp_username_tagname,defaults->ftp.username,NVRAM_FTP_USERNAME_BYTE_LEN);
    write_field(ftp_password_tagname,defaults->ftp.password,NVRAM_FTP_PASSWORD_BYTE_LEN);

    #ifdef LOGFILE
    fprintf(logfile,"SETUP DETAILS:\n");
    fprintf(logfile,"Country code: %d\n",defaults->phone.country_code);
    fprintf(logfile,"Outside line prefix: %s\n",defaults->phone.outside_line_prefix);
    fprintf(logfile,"Call waiting prefix: %s\n",defaults->phone.call_waiting_prefix);
    fprintf(logfile,"Wait for dialtone flag: %c\n",defaults->phone.wait_for_dialtone_flag);
    fprintf(logfile,"ISP phone no.: %s\n",defaults->isp.phone_number);
    fprintf(logfile,"ISP username: %s\n",defaults->isp.username);
    fprintf(logfile,"ISP password: %s\n",defaults->isp.password);
    fprintf(logfile,"Domain: %s\n",defaults->isp.domain);
    fprintf(logfile,"Modem script: %s\n",defaults->isp.modem_script);
    fprintf(logfile,"FTP URL: %s\n",defaults->ftp.url);
    fprintf(logfile,"FTP username: %s\n",defaults->ftp.username);
    fprintf(logfile,"FTP password: %s\n\n",defaults->ftp.password);
    #endif

    return;
}

/************************************************************************************/
/* Function: write_field()                                                          */
/************************************************************************************/
static void write_field(const char *tagname,char *buff,int size)
{
  _kernel_oserror *er = NULL;
  _kernel_swi_regs regs;

    if ((buff == NULL) || (tagname == NULL) || (size < 1))
    {
         error_handler(__FILE__,__LINE__,"write_field()",0,"Buffer / tagname not specified, or size < 1",WARNING);
         return;
    }

    regs.r[0] = (int)tagname;
    regs.r[1] = (int)buff;
    regs.r[2] = size;
    if ((er = _kernel_swi(NVRAM_Write,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"write_field()",er->errnum,er->errmess,WARNING);
    }
    if (regs.r[0] != 0)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",regs.r[0],"No such tag or tag not updateable",WARNING);
    }

    return;
}

#elif !defined(REAL_NVRAM) && defined(NVRAM_MULTIPLE_TAGS)
/************************************************************************************/
/* Function:      write_nvram_defaults()                                            */
/* Behaviour:     Reads setup info entered by the user and saves it to simulated    */
/*                nvram.                                                            */
/* Requires:      Defaults to save to nvram.                                        */
/************************************************************************************/
extern void write_nvram_defaults(setup_details_t *defaults)
{
  char filename[] = "$.nvsim";
  FILE *f = NULL;
  char dns1_str[] = "xxx.xxx.xxx.xxx0";
  char dns2_str[] = "xxx.xxx.xxx.xxx0";
  unsigned long dns1_num = 0;
  unsigned long dns2_num = 0;
  char *p = NULL;


    if ((f = fopen(filename,"w")) == NULL)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Could not save defaults",WARNING);
         return;
    }

    sscanf(defaults->isp.dns,"%[1234567890.]",dns1_str);
    dns1_num = inet_addr(dns1_str);

    /* strrchr searches from the right */
    p = strrchr(defaults->isp.dns,' ');

    if (p != NULL)
    {
        p++;
    }

    if (p != NULL)
    {
        if (isdigit(p[0]))
        {
            sscanf(p,"%[1234567890.]",dns2_str);
            dns2_num = inet_addr(dns2_str);

        }
    }
    else
    {
        dns2_str[0] = '\0';
    }

    fprintf(f,"%d\n",defaults->phone.country_code);
    fprintf(f,"%.*s\n",NVRAM_OUTSIDE_LINE_PREFIX_BYTE_LEN,defaults->phone.outside_line_prefix);
    fprintf(f,"%.*s\n",NVRAM_CALL_WAITING_PREFIX_BYTE_LEN,defaults->phone.call_waiting_prefix);
    fprintf(f,"%d\n",defaults->phone.wait_for_dialtone_flag);
    fprintf(f,"%.*s\n",NVRAM_ISP_PHONENUM_BYTE_LEN,defaults->isp.phone_number);
    fprintf(f,"%.*s\n",NVRAM_ISP_USERNAME_BYTE_LEN,defaults->isp.username);
    fprintf(f,"%.*s\n",NVRAM_ISP_PASSWORD_BYTE_LEN,defaults->isp.password);
    fprintf(f,"%lu\n",dns1_num);
    if (dns2_str != NULL)
    {
        fprintf(f,"%lu\n",dns2_num);
    }
    else
    {
        fprintf(f,"\0\n");
    }
    fprintf(f,"%.*s\n",NVRAM_MODEM_SCRIPT_BYTE_LEN,defaults->isp.modem_script);
    fprintf(f,"%.*s\n",NVRAM_FTP_URL_BYTE_LEN,defaults->ftp.url);
    fprintf(f,"%.*s\n",NVRAM_FTP_USERNAME_BYTE_LEN,defaults->ftp.username);
    fprintf(f,"%.*s\n",NVRAM_FTP_PASSWORD_BYTE_LEN,defaults->ftp.password);

    if ((fclose(f)) != 0)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Could not close nvram file",WARNING);
    }
}

#elif defined(REAL_NVRAM) && defined(NVRAM_SINGLE_TAG)
/************************************************************************************/
/* Function:      write_nvram_defaults()                                            */
/* Behaviour:     Reads setup info entered by the user and saves it to nvram.       */
/* Requires:      Defaults to save to nvram.                                        */
/************************************************************************************/
extern void write_nvram_defaults(setup_details_t *defaults)
{
  char *buff, *p;
  int buffersize;
  _kernel_swi_regs regs;
  _kernel_oserror *er;

    if (defaults == NULL)
        return;

    buffersize = getsize(defaults);

    if (buffersize > NVRAM_MAXSIZE)
    {
        error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Defaults too big to fit in nvram",WARNING);
        return;
    }

    if ((buff = malloc(buffersize)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Insufficient memory to save setup defaults.",WARNING);
         return;
    }

    memset(buff,'\0',(size_t)buffersize);
    buff_write(buff,defaults);

    regs.r[0] = (int)"SetupInfoBuffer";
    regs.r[1] = (int)buff;
    regs.r[2] = buffersize;
    if ((er = _kernel_swi(NVRAM_Write,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,"er->errmess",WARNING);
    }

    if (buff != NULL)
        free(buff);

    return;
}

#elif !defined(REAL_NVRAM) && defined(NVRAM_SINGLE_TAG)
/************************************************************************************/
/* Function:      write_nvram_defaults()                                            */
/* Behaviour:     Reads setup info entered by the user and saves it to simulated    */
/*                nvram.                                                            */
/* Requires:      Defaults to save to nvram.                                        */
/************************************************************************************/

extern void write_nvram_defaults(setup_details_t *defaults)
{
  char filename[] = "$.nvsim";
  FILE *f = NULL;
  int n;
  char *buff = NULL;
  int buffersize = 0;

    if (defaults == NULL)
        return;

    buffersize = getsize(defaults);

    if (buffersize > NVRAM_MAXSIZE)
    {
        error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Defaults too big to fit in nvram",WARNING);
        return;
    }

    if ((buff = malloc(buffersize)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Insufficient memory for nvram buffer",WARNING);
         return;
    }
    memset(buff,'\0',(size_t)buffersize);
    buff_write(buff,defaults);

    if ((f = fopen(filename,"wb")) == NULL)
    {
        error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Could not create nvram simulator file",WARNING);

        if (buff != NULL)
            free(buff);

        return;
    }
    n = fwrite(buff,sizeof(char),buffersize,f);

    if ((fclose(f)) != 0)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Could not close nvram file\n",WARNING);
    }

    if (buff != NULL)
        free(buff);

    return;
}
#endif


#if defined(NVRAM_SINGLE_TAG)
/************************************************************************************/
/* Function:   getsize()                                                            */
/* Behaviour:  Calculates the size of the buffer required to hold setup defaults    */
/*             before writing them to nvram in the required format.                 */
/* Requires:   Setup defaults.                                                      */
/* Returns:    Size of buffer required.                                             */
/************************************************************************************/
static int getsize(setup_details_t *defaults)
{
  int size;

    size = ((int)(log10((double)defaults->phone.country_code))+1) + 1;

    if ((defaults->phone.outside_line_prefix) != NULL)
         size += strlen(defaults->phone.outside_line_prefix) + 2;
    else
         size += 2;  /* ... for null terminator and nvram delimiter. */

    if ((defaults->phone.call_waiting_prefix) != NULL)
         size += strlen(defaults->phone.call_waiting_prefix) + 2;
    else
         size += 2;

    size += sizeof(char) + 1;

    if ((defaults->isp.phone_number) != NULL)
         size += strlen(defaults->isp.phone_number) + 2;
    else
         size += 2;

    if ((defaults->isp.username) != NULL)
         size += strlen(defaults->isp.username) + 2;
    else
         size += 2;

    if ((defaults->isp.password) != NULL)
         size += strlen(defaults->isp.password) + 2;
    else
         size += 2;

    if ((defaults->isp.dns) != NULL)
         size += strlen(defaults->isp.dns) + 2;
    else
         size += 2;

    if ((defaults->isp.modem_script) != NULL)
         size += strlen(defaults->isp.modem_script) + 2;
    else
         size += 2;

    if ((defaults->ftp.url) != NULL)
         size += strlen(defaults->ftp.url) + 2;
    else
         size += 2;

    if ((defaults->ftp.username) != NULL)
         size += strlen(defaults->ftp.username) + 2;
    else
         size += 2;

    if ((defaults->ftp.password) != NULL)
         size += strlen(defaults->ftp.password) + 2;
    else
         size += 2;

    return size;
}
#endif

#if defined(NVRAM_SINGLE_TAG)
/************************************************************************************/
/* Function:      buff_write()                                            */
/* Behaviour:        */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static void buff_write(char *p,setup_details_t *defaults)
{
    sprintf(p,"%d%c",defaults->phone.country_code,NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->phone.outside_line_prefix) != NULL)
         sprintf(p,"%s%c",defaults->phone.outside_line_prefix,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->phone.call_waiting_prefix) != NULL)
         sprintf(p,"%s%c",defaults->phone.call_waiting_prefix,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    sprintf(p,"%d%c",defaults->phone.wait_for_dialtone_flag,NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.phone_number) != NULL)
         sprintf(p,"%s%c",defaults->isp.phone_number,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.username) != NULL)
         sprintf(p,"%s%c",defaults->isp.username,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.password) != NULL)
         sprintf(p,"%s%c",defaults->isp.password,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.dns) != NULL)
         sprintf(p,"%s%c",defaults->isp.dns,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.modem_script) != NULL)
         sprintf(p,"%s%c",defaults->isp.modem_script,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->ftp.url) != NULL)
         sprintf(p,"%s%c",defaults->ftp.url,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->ftp.username) != NULL)
         sprintf(p,"%s%c",defaults->ftp.username,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->ftp.password) != NULL)
         sprintf(p,"%s%c",defaults->ftp.password,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);
}
#endif

