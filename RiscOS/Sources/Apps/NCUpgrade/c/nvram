/************************************************************************************/
/*                                                                                  */
/*  File: nvram.c                                                                   */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  17-Jul-1998  SR        Created                                                  */
/*                                                                                  */
/************************************************************************************/

/* ANSI Includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

/* System includes */
#include "kernel.h"
#include "swis.h"
#include "toolbox.h"
#include "inetlib.h"
#include "DebugLib/DebugLib.h"
#include "MsgLib/MsgLib.h"

/* Local includes */
#include "ui.h"
#include "errors.h"
#include "main.h"
#include "strings.h"
#include "nvram.h"


#if defined(NVRAM_SINGLE_TAG)
  static int getsize (setup_details_t *);
  static void buff_write (char *, setup_details_t *);
#endif


#if defined(REAL_NVRAM) && defined(NVRAM_MULTIPLE_TAGS)


/*******************/
/* Local functions */


static void nvram_default_field (const char *tagname, char **field_ptr)
{
  if (*field_ptr != NULL)
    free (*field_ptr);

  *field_ptr = strdup (msglib_lookup_token (0u, &ui_message_block, (char *)tagname));
  if (*field_ptr == NULL)
    error_handler(__FILE__,__LINE__,"nvram_default_field()",0,"Insufficient memory",WARNING);
}


static _kernel_oserror *nvram_read_number (const char *tagname, int *num_ptr)
{
  _kernel_oserror *er;
  int ret;

  er = _swix (NVRAM_Read, _INR(0,2) | _OUT(0), tagname, num_ptr, 0, &ret);
  if (er != NULL)
    error_handler(__FILE__,__LINE__,"nvram_read_number()",er->errnum,er->errmess,WARNING);
  if (ret < 0)
  {
    error_handler(__FILE__,__LINE__,"nvram_read_number()",ret,"Error reading NVRAM tag",WARNING);
    dprintf (("Error", "tag = \"%s\"\n", tagname));
  }

  return er;
}


/************************************************************************************/
/* Function:  nvram_read_string                                                     */
/* Behaviour: Reads a single item from NVRAM, whose tag is specified by 'tagname'.  */
/* Requires:  'tagname', which is the tag specified in the NVRAM tags file.         */
/* Returns:   'buff', which is the value stored in NVRAM.                           */
/************************************************************************************/
static char *nvram_read_string (const char *tagname)
{
  _kernel_oserror *er = NULL;
  int size = 0;
  char *buff = NULL;

  /* First find the size of the value in NVRAM */
  er = _swix (NVRAM_Read, _INR(0,2) | _OUT(0), tagname, 0, 0, &size);

  if (er != NULL)
    error_handler (__FILE__,__LINE__,"nvram_read_string()",er->errnum,er->errmess,WARNING);
  else
  {
    if (size <= 0)
      error_handler (__FILE__,__LINE__,"nvram_read_string()",size,"Unexpected buffer length",WARNING);
    else
    {
      buff = malloc (size+1);
      if (buff == NULL)
        error_handler (__FILE__,__LINE__,"nvram_read_string()",0,"Insufficient memory",WARNING);
      else
      {
        er = _swix (NVRAM_Read, _INR(0,2), tagname, buff, size);
        if (er != NULL)
          error_handler (__FILE__,__LINE__,"nvram_read_string()",er->errnum,er->errmess,WARNING);
      }
    }
  }

  /* This memory is safely freed on exit from the calling routine. */
  return buff;
}


/************************************************************************************/
/* Function:    nvram_write_string                                                  */
/* Behaviour:   Saves a value to NVRAM.                                             */
/* Requires:    - 'tagname', which is the tag of the value to save, as specified in */
/*                 the NVRAM tags file.                                             */
/*              - 'buff', which is the value to save under that tagname.            */
/************************************************************************************/
static void nvram_write_string (const char *tagname, char *buff, int max_len)
{
  _kernel_oserror *er = NULL;
  int ret;

  if ((buff == NULL) || (tagname == NULL) || (max_len < 1))
    error_handler(__FILE__,__LINE__,"nvram_write_string()",0,"Buffer / tagname not specified, or max_len < 1",WARNING);
  else
  {
    /* If the buffer is too long, truncate it */
    if (strlen (buff) >= max_len)
      buff[max_len-1] = '\0';

    er = _swix (NVRAM_Write, _INR(0,2) | _OUT(0), tagname, buff, strlen (buff) + 1/* Write the '\0' too */, &ret);
    if (er != NULL)
      error_handler(__FILE__,__LINE__,"nvram_write_string()",er->errnum,er->errmess,WARNING);
    if (ret != 0)
      error_handler(__FILE__,__LINE__,"nvram_write_string()",ret,"Error calling NVRAM_Write",WARNING);
  }
}


static _kernel_oserror *nvram_write_number (const char *tagname, int number)
{
  _kernel_oserror *er;
  int ret;

  er = _swix (NVRAM_Write, _INR(0,2) | _OUT(0), tagname, &number, 0, &ret);
  if (er != NULL)
    error_handler(__FILE__,__LINE__,"nvram_write_number()",er->errnum,er->errmess,WARNING);
  if (ret != 0)
    error_handler(__FILE__,__LINE__,"nvram_write_number()",ret,"Error calling NVRAM_Write",WARNING);

  return er;
}


/************************************************************************************/
/* Function:      get_nvram_defaults                                                */
/* Behaviour:     Read defaults from nvram and hand them over to the UI Library.    */
/************************************************************************************/
extern void get_nvram_defaults (void)
{
  int num;
  setup_details_t defaults;
  struct in_addr dns1;
  struct in_addr dns2;
  _kernel_oserror *er = NULL;

  /* Initialise members (in case we find that there are no defaults in NVRAM). */
  defaults.phone.country_code = -1;  /* -1 tells the UI Library to display a blank. */
  defaults.phone.outside_line_prefix = defaults.phone.call_waiting_prefix = NULL;
  defaults.phone.wait_for_dialtone_flag = 0;
  defaults.phone.dial_mode = DialMode_Tone;

  defaults.isp.phone_number = defaults.isp.username = defaults.isp.password =
  defaults.isp.dns = defaults.isp.modem_script = defaults.ftp.url = defaults.ftp.username =
  defaults.ftp.password = NULL;

  /* Fetch country code */
  nvram_read_number (COUNTRY_CODE_TAGNAME, &defaults.phone.country_code);

  /* Fetch dial tone flag */
  nvram_read_number (WAIT_FOR_DIALTONE_FLAG_TAGNAME, (int*) &defaults.phone.wait_for_dialtone_flag);

  /* Fetch Dial mode */
  nvram_read_number (DIAL_MODE_TAGNAME, (int*) &defaults.phone.dial_mode);

  /* Fetch fields of type string */
  defaults.phone.outside_line_prefix = nvram_read_string (OUTSIDE_LINE_PREFIX_TAGNAME);
  defaults.phone.call_waiting_prefix = nvram_read_string (CALL_WAITING_PREFIX_TAGNAME);
  defaults.isp.phone_number = nvram_read_string (ISP_PHONENUM_TAGNAME);
  defaults.isp.username = nvram_read_string (ISP_USERNAME_TAGNAME);
  defaults.isp.password = nvram_read_string (ISP_PASSWORD_TAGNAME);
  defaults.isp.modem_script = nvram_read_string (MODEM_SCRIPT_TAGNAME);
  defaults.isp.domain = nvram_read_string (LOCAL_DOMAIN_TAGNAME);
  defaults.ftp.url = nvram_read_string (FTP_URL_TAGNAME);
  defaults.ftp.username = nvram_read_string (FTP_USERNAME_TAGNAME);
  defaults.ftp.password = nvram_read_string (FTP_PASSWORD_TAGNAME);

  /* Fetch DNS1 */
  nvram_read_number (DNS1_TAGNAME, (int*) &dns1.s_addr);

  /* Fetch DNS2 */
  nvram_read_number (DNS2_TAGNAME, (int*) &dns2.s_addr);

  /* Build DNS string from the IP addresses fetched from NVRAM */
  {
    BOOL dns1_empty, dns2_empty;
    int len;

    dns1_empty = (strcmp (inet_ntoa (dns1), "0.0.0.0")) ? FALSE : TRUE;
    dns2_empty = (strcmp (inet_ntoa (dns2), "0.0.0.0")) ? FALSE : TRUE;

    if (!(dns1_empty == TRUE && dns2_empty == TRUE))
    {
      len = strlen("xxx.xxx.xxx.xxx") + 1;

      if (dns2_empty == FALSE)
        len += strlen (" xxx.xxx.xxx.xxx");

      defaults.isp.dns = malloc (len);
      if (defaults.isp.dns == NULL)
      {
        error_handler (__FILE__,__LINE__,"get_nvram_defaults()", len, "Insufficient memory",WARNING);
      }
      else
      {
        strcpy (defaults.isp.dns, inet_ntoa (dns1));

        if (dns2_empty == FALSE)
        {
          strcat (defaults.isp.dns, " ");
          strcat (defaults.isp.dns, inet_ntoa (dns2));
        }
      }
    }
    else
      defaults.isp.dns = NULL;
  }

  /* Check if we should default the setup values */
  er = nvram_read_number (USE_DEFAULT_VALUES_TAGNAME, &num);
  if (er == NULL)
  {
    if (num == 1)
    {
      /* We should, so overwrite whatever we read from NVRAM with values from
         the messages file */
      nvram_default_field ("NVRAMDefault_ISP_PhoneNumber", &defaults.isp.phone_number);
      nvram_default_field ("NVRAMDefault_ISP_Username", &defaults.isp.username);
      nvram_default_field ("NVRAMDefault_ISP_Password", &defaults.isp.password);
      nvram_default_field ("NVRAMDefault_ISP_DNS", &defaults.isp.dns);
      nvram_default_field ("NVRAMDefault_ISP_Domain", &defaults.isp.domain);
      nvram_default_field ("NVRAMDefault_ISP_ModemScript", &defaults.isp.modem_script);
      nvram_default_field ("NVRAMDefault_FTP_URL", &defaults.ftp.url);
      nvram_default_field ("NVRAMDefault_FTP_Username", &defaults.ftp.username);
      nvram_default_field ("NVRAMDefault_FTP_Password", &defaults.ftp.password);

      /* And reset the NVRAM tag so we don't do it on the next run */
      nvram_write_number (USE_DEFAULT_VALUES_TAGNAME, 0);
    }
  }

  /* Hand over to the UI Library. */
  if ((er = ui_set_defaults (0u, &defaults)) != NULL)
  {
    error_handler (__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
  }

  /* The UI Library will have made it's own copy of the defaults, so now we can safely free. */
  if (defaults.phone.outside_line_prefix != NULL)
    free(defaults.phone.outside_line_prefix);

  if (defaults.phone.call_waiting_prefix != NULL)
    free(defaults.phone.call_waiting_prefix);

  if (defaults.isp.phone_number != NULL)
    free(defaults.isp.phone_number);

  if (defaults.isp.username != NULL)
    free(defaults.isp.username);

  if (defaults.isp.password != NULL)
    free(defaults.isp.password);

  if (defaults.isp.modem_script != NULL)
    free(defaults.isp.modem_script);

  if (defaults.isp.dns != NULL)
    free(defaults.isp.dns);

  if (defaults.ftp.url != NULL)
    free(defaults.ftp.url);

  if (defaults.ftp.username != NULL)
    free(defaults.ftp.username);

  if (defaults.ftp.password != NULL)
    free(defaults.ftp.password);

  if (defaults.isp.domain != NULL)
    free(defaults.isp.domain);

  return;
}


/************************************************************************************/
/* Function:      write_nvram_defaults                                              */
/* Behaviour:     Reads setup info entered by the user and saves it to nvram.       */
/* Requires:      Defaults to save to nvram.                                        */
/************************************************************************************/
extern void write_nvram_defaults (setup_details_t *defaults)
{
  char dns1_str[] = "xxx.xxx.xxx.xxx0";
  char dns2_str[] = "xxx.xxx.xxx.xxx0";
  unsigned long dns1_num = 0;
  unsigned long dns2_num = 0;
  char *p = NULL;

  /* Convert DNS string into ip numbers */
  sscanf(defaults->isp.dns,"%[1234567890.]",dns1_str);
  dns1_num = inet_addr(dns1_str);

  /* strrchr searches from the right */
  p = strrchr(defaults->isp.dns,' ');

  if (p != NULL)
    p++;

  if (p != NULL)
  {
    if (isdigit(p[0]))
    {
        sscanf(p,"%[1234567890.]",dns2_str);
        dns2_num = inet_addr(dns2_str);
    }
  }
  else
    dns2_str[0] = '\0';

  /* Write Country code */
  nvram_write_number (COUNTRY_CODE_TAGNAME, defaults->phone.country_code);

  /* Write Wait for dial tone flag */
  nvram_write_number (WAIT_FOR_DIALTONE_FLAG_TAGNAME, defaults->phone.wait_for_dialtone_flag);

  /* Write Dial mode field */
  nvram_write_number (DIAL_MODE_TAGNAME, defaults->phone.dial_mode);

  /* Write DNS1 */
  nvram_write_number (DNS1_TAGNAME, (int) dns1_num);

  /* Write DNS2 */
  nvram_write_number (DNS2_TAGNAME, (int) dns2_num);

  /* Write all string-type fields */
  nvram_write_string (OUTSIDE_LINE_PREFIX_TAGNAME, defaults->phone.outside_line_prefix, NVRAM_OUTSIDE_LINE_PREFIX_BYTE_LEN);
  nvram_write_string (CALL_WAITING_PREFIX_TAGNAME, defaults->phone.call_waiting_prefix, NVRAM_CALL_WAITING_PREFIX_BYTE_LEN);
  nvram_write_string (ISP_PHONENUM_TAGNAME, defaults->isp.phone_number, NVRAM_ISP_PHONENUM_BYTE_LEN);
  nvram_write_string (ISP_USERNAME_TAGNAME, defaults->isp.username, NVRAM_ISP_USERNAME_BYTE_LEN);
  nvram_write_string (ISP_PASSWORD_TAGNAME, defaults->isp.password, NVRAM_ISP_PASSWORD_BYTE_LEN);
  nvram_write_string (LOCAL_DOMAIN_TAGNAME, defaults->isp.domain, NVRAM_LOCAL_DOMAIN_BYTE_LEN);
  nvram_write_string (MODEM_SCRIPT_TAGNAME, defaults->isp.modem_script, NVRAM_MODEM_SCRIPT_BYTE_LEN);
  nvram_write_string (FTP_URL_TAGNAME, defaults->ftp.url, NVRAM_FTP_URL_BYTE_LEN);
  nvram_write_string (FTP_USERNAME_TAGNAME, defaults->ftp.username, NVRAM_FTP_USERNAME_BYTE_LEN);
  nvram_write_string (FTP_PASSWORD_TAGNAME, defaults->ftp.password, NVRAM_FTP_PASSWORD_BYTE_LEN);

  dprintf (("Engine", "\nSETUP DETAILS:\n"));
  dprintf (("Engine", "Country code:         %d\n",defaults->phone.country_code));
  dprintf (("Engine", "Outside line prefix:  %s\n",
           (*defaults->phone.outside_line_prefix == '\0') ? "Off" : defaults->phone.outside_line_prefix));
  dprintf (("Engine", "Call waiting prefix:  %s\n",
           (*defaults->phone.call_waiting_prefix == '\0') ? "Off" : defaults->phone.call_waiting_prefix));
  dprintf (("Engine", "Wait for dialtone:    %s\n", (defaults->phone.wait_for_dialtone_flag == 0) ? "No" : "Yes"));
  #ifdef DEBUGLIB
    {
      char *str;
      switch (defaults->phone.dial_mode)
      {
        case 0:
          str = "Tone";
          break;
        case 1:
          str = "Pulse10";
          break;
        case 2:
          str = "Pulse20";
          break;
        default:
          str = "Unexpected value";
      }
      dprintf (("Engine", "Dial mode:            %s\n", str));
    }
  #endif
  dprintf (("Engine", "ISP phone no.:        \"%s\"\n", defaults->isp.phone_number));
  dprintf (("Engine", "ISP username:         \"%s\"\n", defaults->isp.username));
  dprintf (("Engine", "ISP password:         \"%s\"\n", defaults->isp.password));
  dprintf (("Engine", "Local Domain:         \"%s\"\n", defaults->isp.domain));
  dprintf (("Engine", "Modem script:         \"%s\"\n", defaults->isp.modem_script));
  dprintf (("Engine", "FTP URL:              \"%s\"\n", defaults->ftp.url));
  dprintf (("Engine", "FTP username:         \"%s\"\n", defaults->ftp.username));
  dprintf (("Engine", "FTP password:         \"%s\"\n\n", defaults->ftp.password));
  /* DNS gets printed at the point where it's actually used. */
}





/***************************************/
/* Unused and simulation NVRAM systems */
/* from here onwards                   */
/***************************************/


#elif !defined(REAL_NVRAM) && defined(NVRAM_MULTIPLE_TAGS)
/************************************************************************************/
/* Function:      get_nvram_defaults                                                */
/* Behaviour:     Read defaults from simulated nvram and hand them over to the UI   */
/*                Library.                                                          */
/* Prerequisites: String allocation lengths must match up with intended lengths     */
/*                to be specified in the nvram tags file.                           */
/************************************************************************************/
extern void get_nvram_defaults (void)
{
  #define MAXLEN 256

  char line[MAXLEN];
  FILE *f = NULL;
  int flags = 0;
  char filename[] = "$.nvsim";
  static setup_details_t defaults;
  _kernel_oserror *er = NULL;
  struct in_addr dns1;
  struct in_addr dns2;

    defaults.phone.country_code = 0;
    defaults.phone.outside_line_prefix = defaults.phone.call_waiting_prefix = NULL;
    defaults.phone.wait_for_dialtone_flag = 0;

    defaults.isp.phone_number = defaults.isp.username = defaults.isp.password =
    defaults.isp.dns = defaults.isp.modem_script = NULL;

    defaults.ftp.url = defaults.ftp.username = defaults.ftp.password = NULL;

    if ((f = fopen(filename,"r")) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Cannot open nvram file: nvsim",WARNING);
         goto bypass_nvram;
    }

    /* Country Code */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if (isdigit(line[0]))
    {
         defaults.phone.country_code = atoi(line);
    }

    /* Outside Line Prefix */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.phone.outside_line_prefix = calloc(NVRAM_OUTSIDE_LINE_PREFIX_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_OUTSIDE_LINE_PREFIX_BYTE_LEN *
         sizeof(char),"Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
      /* Earlier use of calloc and the length specified below ensures null termination */
         strncpy(defaults.phone.outside_line_prefix,line,NVRAM_OUTSIDE_LINE_PREFIX_BYTE_LEN - 1);
    }

    /* Call Waiting Prefix */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.phone.call_waiting_prefix = calloc(NVRAM_CALL_WAITING_PREFIX_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_CALL_WAITING_PREFIX_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.phone.call_waiting_prefix,line,NVRAM_CALL_WAITING_PREFIX_BYTE_LEN - 1);
    }

    /* Wait For Dial Tone Flag */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if (line[0] == '1')
    {
         defaults.phone.wait_for_dialtone_flag = 1;
    }
    else
    {
        defaults.phone.wait_for_dialtone_flag = 0;
    }

    /* ISP Phone Number */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.isp.phone_number = calloc(NVRAM_ISP_PHONENUM_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_ISP_PHONENUM_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.isp.phone_number,line,NVRAM_ISP_PHONENUM_BYTE_LEN - 1);
    }

    /* ISP Username */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.isp.username = calloc(NVRAM_ISP_USERNAME_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_ISP_USERNAME_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.isp.username,line,NVRAM_ISP_USERNAME_BYTE_LEN - 1);
    }

    /* ISP Password */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.isp.password = calloc(NVRAM_ISP_PASSWORD_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_ISP_PASSWORD_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.isp.password,line,NVRAM_ISP_PASSWORD_BYTE_LEN - 1);
    }

    /* DNS1 */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.isp.dns = calloc(strlen("xxx.xxx.xxx.xxx xxx.xxx.xxx.xxx") + 2,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",(strlen("xxx.xxx.xxx.xxx xxx.xxx.xxx.xxx") + 2) * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         dns1.s_addr = atoi(line);
         strcpy(defaults.isp.dns,inet_ntoa(dns1));
    }

    /* DNS2 */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else
    {
         dns2.s_addr = atoi(line);
         strcat(defaults.isp.dns," ");
         strcat(defaults.isp.dns,inet_ntoa(dns2));
    }

    /* Modem Script */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.isp.modem_script = calloc(NVRAM_MODEM_SCRIPT_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_MODEM_SCRIPT_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.isp.modem_script,line,NVRAM_MODEM_SCRIPT_BYTE_LEN - 1);
    }

    /* FTP URL */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.ftp.url = calloc(NVRAM_FTP_URL_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_FTP_URL_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.ftp.url,line,NVRAM_FTP_URL_BYTE_LEN - 1);
    }

    /* FTP Username */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.ftp.username = calloc(NVRAM_FTP_USERNAME_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_FTP_USERNAME_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.ftp.username,line,NVRAM_FTP_USERNAME_BYTE_LEN - 1);
    }

    /* FTP Password */
    fgets(line,MAXLEN - 1,f);
    if (feof(f))
    {
         goto ui_handover;
    }
    else if ((defaults.ftp.password = calloc(NVRAM_FTP_PASSWORD_BYTE_LEN,sizeof(char))) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",NVRAM_FTP_PASSWORD_BYTE_LEN * sizeof(char),
         "Insufficient memory",WARNING);
         goto ui_handover;
    }
    else
    {
         strncpy(defaults.ftp.password,line,NVRAM_FTP_PASSWORD_BYTE_LEN - 1);
    }

    ui_handover:  if ((er = ui_set_defaults(flags,&defaults)) != NULL)
                  {
                       error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
                  }

    bypass_nvram: if (defaults.phone.outside_line_prefix != NULL)
                      free(defaults.phone.outside_line_prefix);

                  if (defaults.phone.call_waiting_prefix != NULL)
                      free(defaults.phone.call_waiting_prefix);

                  if (defaults.isp.phone_number != NULL)
                      free(defaults.isp.phone_number);

                  if (defaults.isp.username != NULL)
                      free(defaults.isp.username);

                  if (defaults.isp.password != NULL)
                      free(defaults.isp.password);

                  if (defaults.isp.modem_script != NULL)
                      free(defaults.isp.modem_script);

                  if (defaults.isp.dns != NULL)
                      free(defaults.isp.dns);

                  if (defaults.ftp.url != NULL)
                      free(defaults.ftp.url);

                  if (defaults.ftp.username != NULL)
                      free(defaults.ftp.username);

                  if (defaults.ftp.password != NULL)
                      free(defaults.ftp.password);

                  if (f != NULL)
                      fclose(f);

#undef MAXLEN
}

/************************************************************************************/
/* Function:      write_nvram_defaults                                              */
/* Behaviour:     Reads setup info entered by the user and saves it to simulated    */
/*                nvram.                                                            */
/* Requires:      Defaults to save to nvram.                                        */
/************************************************************************************/
extern void write_nvram_defaults (setup_details_t *defaults)
{
  char filename[] = "$.nvsim";
  FILE *f = NULL;
  char dns1_str[] = "xxx.xxx.xxx.xxx0";
  char dns2_str[] = "xxx.xxx.xxx.xxx0";
  unsigned long dns1_num = 0;
  unsigned long dns2_num = 0;
  char *p = NULL;


    if ((f = fopen(filename,"w")) == NULL)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Could not save defaults",WARNING);
         return;
    }

    sscanf(defaults->isp.dns,"%[1234567890.]",dns1_str);
    dns1_num = inet_addr(dns1_str);

    /* strrchr searches from the right */
    p = strrchr(defaults->isp.dns,' ');

    if (p != NULL)
    {
        p++;
    }

    if (p != NULL)
    {
        if (isdigit(p[0]))
        {
            sscanf(p,"%[1234567890.]",dns2_str);
            dns2_num = inet_addr(dns2_str);

        }
    }
    else
    {
        dns2_str[0] = '\0';
    }

    fprintf(f,"%d\n",defaults->phone.country_code);
    fprintf(f,"%.*s\n",NVRAM_OUTSIDE_LINE_PREFIX_BYTE_LEN,defaults->phone.outside_line_prefix);
    fprintf(f,"%.*s\n",NVRAM_CALL_WAITING_PREFIX_BYTE_LEN,defaults->phone.call_waiting_prefix);
    fprintf(f,"%d\n",defaults->phone.wait_for_dialtone_flag);
    fprintf(f,"%.*s\n",NVRAM_ISP_PHONENUM_BYTE_LEN,defaults->isp.phone_number);
    fprintf(f,"%.*s\n",NVRAM_ISP_USERNAME_BYTE_LEN,defaults->isp.username);
    fprintf(f,"%.*s\n",NVRAM_ISP_PASSWORD_BYTE_LEN,defaults->isp.password);
    fprintf(f,"%lu\n",dns1_num);
    if (dns2_str != NULL)
    {
        fprintf(f,"%lu\n",dns2_num);
    }
    else
    {
        fprintf(f,"\0\n");
    }
    fprintf(f,"%.*s\n",NVRAM_MODEM_SCRIPT_BYTE_LEN,defaults->isp.modem_script);
    fprintf(f,"%.*s\n",NVRAM_FTP_URL_BYTE_LEN,defaults->ftp.url);
    fprintf(f,"%.*s\n",NVRAM_FTP_USERNAME_BYTE_LEN,defaults->ftp.username);
    fprintf(f,"%.*s\n",NVRAM_FTP_PASSWORD_BYTE_LEN,defaults->ftp.password);

    if ((fclose(f)) != 0)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Could not close nvram file",WARNING);
    }
}


#elif defined(REAL_NVRAM) && defined(NVRAM_SINGLE_TAG)


/************************************************************************************/
/* Function:      get_nvram_defaults                                                */
/* Behaviour:     Read defaults from nvram and hand them over to the UI Library.    */
/* Prerequisites: Appropriate tag in NV-RAM Tags file.                              */
/* Notes:         Format of nvram SetupInfoBuffer: D=NVRAM_DELIMITER                */
/*                <isp_phoneno>D<isp_username>D<isp_password>D<dns>D                */
/*                <isp_modemstring>D<ftp_url>D<ftp_username>D<ftp_password>D        */
/*                This allows maximum length of each field to vary without changes  */
/*                in this code.  The only restriction is the maximum length of the  */
/*                buffer in which all these details gets stored.  If the UI Library */
/*                wants to place restrictions on the length of individual fields it */
/*                is free to do with no code modification necessary here.           */
/************************************************************************************/
extern void get_nvram_defaults (void)
{
  int i,j;
  int size;
  int flags = 0;
  char *nvram_buffer_ptr = NULL;
  static setup_details_t defaults;
  int delimiters = 0;
  int field_lengths[EXPECTED_NUMBER_OF_DELIMITERS];
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;

    defaults.phone.country_code = 0;
    defaults.phone.outside_line_prefix = defaults.phone.call_waiting_prefix = NULL;
    defaults.phone.wait_for_dialtone_flag = 0;

    defaults.isp.phone_number = defaults.isp.username = defaults.isp.password =
    defaults.isp.dns = defaults.isp.modem_script = NULL;

    defaults.ftp.url = defaults.ftp.username = defaults.ftp.password = NULL;

    regs.r[0] = "SetupInfoBuffer";
    regs.r[1] = 0;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
         goto bypass_nvram;
    }
    size = regs.r[0];

    if ((nvram_buffer_ptr = malloc(size)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",size,
           "Insufficient memory available for nvram buffer.",WARNING);
         goto bypass_nvram;
    }

    regs.r[0] = "SetupInfoBuffer";
    regs.r[1] = nvram_buffer_ptr;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
         goto bypass_nvram;
    }

    i = 0;
    while (i < size)
    {
           if (*(nvram_buffer_ptr+i) == NVRAM_DELIMITER)
           {
               delimiters++;
           }
           i++;
    }

    if (delimiters != EXPECTED_NUMBER_OF_DELIMITERS)
    {
        /* NV-RAM was corrupted and the SetupInfoBuffer has been re-initialised
           to 0, or there are no defaults in store.
         */

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }
    }
    else
    {
        j = 0;
        for (i = 0; i < EXPECTED_NUMBER_OF_DELIMITERS; i++)
        {
             field_lengths[i] = 0;
             while (nvram_buffer_ptr[j] != NVRAM_DELIMITER)
             {
                    field_lengths[i]++;
                    j++;
             }
             j++;
        }

        if (((defaults.phone.outside_line_prefix = malloc(field_lengths[1] + 1) == NULL) ||
            ((defaults.phone.call_waiting_prefix = malloc(field_lengths[2] + 1) == NULL) ||
            ((defaults.isp.phone_number = malloc(field_lengths[4] + 1) == NULL) ||
            ((defaults.isp.username = malloc(field_lengths[5] + 1) == NULL) ||
            ((defaults.isp.password = malloc(field_lengths[6] + 1) == NULL) ||
            ((defaults.isp.dns = malloc(field_lengths[7] + 1) == NULL) ||
            ((defaults.isp.modem_script = malloc(field_lengths[8] + 1) == NULL) ||
            ((defaults.ftp.url = malloc(field_lengths[9] + 1) == NULL) ||
            ((defaults.ftp.username = malloc(field_lengths[10] + 1) == NULL) ||
            ((defaults.ftp.password = malloc(field_lengths[11] + 1) == NULL))
        {
               error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,
                 "Insufficient memory available for reading setup defaults.",WARNING);

               goto bypass_nvram;
        }

        defaults.phone.country_code = atoi(p);
        p += ((int)(log10((double)defaults.phone.country_code))+1) + 1;

        sscanf(p,"%[^'\033']",defaults.phone.outside_line_prefix);
        defaults.phone.outside_line_prefix[field_lengths[1]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.phone.call_waiting_prefix);
        defaults.phone.call_waiting_prefix[field_lengths[2]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        if (*p == '1')
            defaults.phone.wait_for_dialtone_flag = 1;
        else
            defaults.phone.wait_for_dialtone_flag = 0;
        p += 2;

        sscanf(p,"%[^'\033']",defaults.isp.phone_number);
        defaults.isp.phone_number[field_lengths[4]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.username);
        defaults.isp.username[field_lengths[5]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.password);
        defaults.isp.password[field_lengths[6]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.dns);
        defaults.isp.dns[field_lengths[7]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.modem_script);
        defaults.isp.modem_script[field_lengths[8]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.url);
        defaults.ftp.url[field_lengths[9]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.username);
        defaults.ftp.username[field_lengths[10]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.password);
        defaults.ftp.password[field_lengths[11]] = '\0';

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }
    }

    bypass_nvram: if (nvram_buffer_ptr != NULL)
                      free(nvram_buffer_ptr);

                  if (defaults.phone.outside_line_prefix != NULL)
                      free(defaults.phone.outside_line_prefix);

                  if (defaults.phone.call_waiting_prefix != NULL)
                      free(defaults.phone.call_waiting_prefix);

                  if (defaults.isp.phone_number != NULL)
                      free(defaults.isp.phone_number);

                 if (defaults.isp.username != NULL)
                      free(defaults.isp.username);

                  if (defaults.isp.password != NULL)
                      free(defaults.isp.password);

                  if (defaults.isp.modem_script != NULL)
                      free(defaults.isp.modem_script);

                  if (defaults.isp.dns != NULL)
                      free(defaults.isp.dns);

                  if (defaults.ftp.url != NULL)
                      free(defaults.ftp.url);

                  if (defaults.ftp.username != NULL)
                      free(defaults.ftp.username);

                  if (defaults.ftp.password != NULL)
                      free(defaults.ftp.password);

                  return NULL;
}


/************************************************************************************/
/* Function:      write_nvram_defaults                                              */
/* Behaviour:     Reads setup info entered by the user and saves it to nvram.       */
/* Requires:      Defaults to save to nvram.                                        */
/************************************************************************************/
extern void write_nvram_defaults (setup_details_t *defaults)
{
  char *buff, *p;
  int buffersize;
  _kernel_swi_regs regs;
  _kernel_oserror *er;

    if (defaults == NULL)
        return;

    buffersize = getsize(defaults);

    if (buffersize > NVRAM_MAXSIZE)
    {
        error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Defaults too big to fit in nvram",WARNING);
        return;
    }

    if ((buff = malloc(buffersize)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Insufficient memory to save setup defaults.",WARNING);
         return;
    }

    memset(buff,'\0',(size_t)buffersize);
    buff_write(buff,defaults);

    regs.r[0] = (int)"SetupInfoBuffer";
    regs.r[1] = (int)buff;
    regs.r[2] = buffersize;
    if ((er = _kernel_swi(NVRAM_Write,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,"er->errmess",WARNING);
    }

    if (buff != NULL)
        free(buff);

    return;
}


#elif !defined(REAL_NVRAM) && defined(NVRAM_SINGLE_TAG)


/************************************************************************************/
/* Function:      get_nvram_defaults                                                */
/* Behaviour:     Read defaults from simulated nvram and hand them over to the UI   */
/*                Library.                                                          */
/* Notes:         Format of nvram SetupInfoBuffer: D=NVRAM_DELIMITER                */
/*                <isp_phoneno>D<isp_username>D<isp_password>D<dns>D                */
/*                <isp_modemstring>D<ftp_url>D<ftp_username>D<ftp_password>D        */
/*                This allows maximum length of each field to vary without changes  */
/*                in this code.  The only restriction is the maximum length of the  */
/*                buffer in which all these details gets stored.  If the UI Library */
/*                wants to place restrictions on the length of individual fields it */
/*                is free to do with no code modification necessary here.           */
/************************************************************************************/
extern void get_nvram_defaults (void)
{
  FILE *f = NULL;
  int size;
  int i,j;
  int flags = 0;
  int delimiters = 0;
  int end,start;
  void *nvram_buffer_ptr = NULL;
  char *p = NULL;
  char filename[] = "$.nvsim";
  int field_lengths[EXPECTED_NUMBER_OF_DELIMITERS];
  static setup_details_t defaults;
  _kernel_oserror *er = NULL;

    defaults.phone.country_code = 0;
    defaults.phone.outside_line_prefix = defaults.phone.call_waiting_prefix = NULL;
    defaults.phone.wait_for_dialtone_flag = 0;

    defaults.isp.phone_number = defaults.isp.username = defaults.isp.password =
    defaults.isp.dns = defaults.isp.modem_script = NULL;

    defaults.ftp.url = defaults.ftp.username = defaults.ftp.password = NULL;

    if ((f = fopen(filename,"rb")) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Cannot open nvram file: nvsim",WARNING);
         goto bypass_nvram;
    }
    rewind(f);
    start = (int)ftell(f);

    if ((fseek(f,0L,SEEK_END)) != 0)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Cannot seek to end of nvram file",WARNING);
         goto bypass_nvram;
    }
    end = (int)ftell(f);

    size = end - start;

    if ((nvram_buffer_ptr = malloc(size)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",size,"Insufficient memory for nvram buffer.",WARNING);
         goto bypass_nvram;
    }
    p = (char *)nvram_buffer_ptr;
    rewind(f);

    if ((fread((char *)nvram_buffer_ptr,sizeof(char),size,f)) != size)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Read failure.",WARNING);
         goto bypass_nvram;
    }

    i = 0;
    while (i < size)
    {
           if (*(p+i) == NVRAM_DELIMITER)
           {
               delimiters++;
           }
           i++;
    }

    if (delimiters != EXPECTED_NUMBER_OF_DELIMITERS)
    {
        /* NV-RAM was corrupted and the SetupInfoBuffer has been re-initialised
           to 0, or there are no defaults in store.
         */

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }
    }
    else
    {
        j = 0;
        for (i = 0; i < EXPECTED_NUMBER_OF_DELIMITERS; i++)
        {
             field_lengths[i] = 0;
             while (p[j] != NVRAM_DELIMITER)
             {
                    field_lengths[i]++;
                    j++;
             }
             j++;
        }

        if (((defaults.phone.outside_line_prefix = malloc(field_lengths[1]+1)) == NULL) ||
            ((defaults.phone.call_waiting_prefix = malloc(field_lengths[2]+1)) == NULL) ||
            ((defaults.isp.phone_number = malloc(field_lengths[4]+1)) == NULL) ||
            ((defaults.isp.username = malloc(field_lengths[5]+1)) == NULL) ||
            ((defaults.isp.password = malloc(field_lengths[6]+1)) == NULL) ||
            ((defaults.isp.dns = malloc(field_lengths[7]+1)) == NULL) ||
            ((defaults.isp.modem_script = malloc(field_lengths[8]+1)) == NULL) ||
            ((defaults.ftp.url = malloc(field_lengths[9]+1)) == NULL) ||
            ((defaults.ftp.username = malloc(field_lengths[10]+1)) == NULL) ||
            ((defaults.ftp.password = malloc(field_lengths[11]+1)) == NULL))
        {
              error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,
                "Insufficient memory available for reading setup defaults.",WARNING);

               goto bypass_nvram;
        }

        defaults.phone.country_code = atoi(p);
        p += ((int)(log10((double)defaults.phone.country_code))+1) + 1;

        sscanf(p,"%[^'\033']",defaults.phone.outside_line_prefix);
        defaults.phone.outside_line_prefix[field_lengths[1]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.phone.call_waiting_prefix);
        defaults.phone.call_waiting_prefix[field_lengths[2]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        if (*p == '1')
            defaults.phone.wait_for_dialtone_flag = 1;
        else
            defaults.phone.wait_for_dialtone_flag = 0;
        p += 2;

        sscanf(p,"%[^'\033']",defaults.isp.phone_number);
        defaults.isp.phone_number[field_lengths[4]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.username);
        defaults.isp.username[field_lengths[5]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.password);
        defaults.isp.password[field_lengths[6]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.dns);
        defaults.isp.dns[field_lengths[7]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.modem_script);
        defaults.isp.modem_script[field_lengths[8]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.url);
        defaults.ftp.url[field_lengths[9]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.username);
        defaults.ftp.username[field_lengths[10]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.password);
        defaults.ftp.password[field_lengths[11]] = '\0';

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }

    }

    bypass_nvram: if (nvram_buffer_ptr != NULL)
                      free(nvram_buffer_ptr);

                  if (defaults.phone.outside_line_prefix != NULL)
                      free(defaults.phone.outside_line_prefix);

                  if (defaults.phone.call_waiting_prefix != NULL)
                      free(defaults.phone.call_waiting_prefix);

                  if (defaults.isp.phone_number != NULL)
                      free(defaults.isp.phone_number);

                 if (defaults.isp.username != NULL)
                      free(defaults.isp.username);

                  if (defaults.isp.password != NULL)
                      free(defaults.isp.password);

                  if (defaults.isp.modem_script != NULL)
                      free(defaults.isp.modem_script);

                  if (defaults.isp.dns != NULL)
                      free(defaults.isp.dns);

                  if (defaults.ftp.url != NULL)
                      free(defaults.ftp.url);

                  if (defaults.ftp.username != NULL)
                      free(defaults.ftp.username);

                  if (defaults.ftp.password != NULL)
                      free(defaults.ftp.password);

                  if (f != NULL)
                      fclose(f);
}


/************************************************************************************/
/* Function:      write_nvram_defaults                                              */
/* Behaviour:     Reads setup info entered by the user and saves it to simulated    */
/*                nvram.                                                            */
/* Requires:      Defaults to save to nvram.                                        */
/************************************************************************************/

extern void write_nvram_defaults (setup_details_t *defaults)
{
  char filename[] = "$.nvsim";
  FILE *f = NULL;
  int n;
  char *buff = NULL;
  int buffersize = 0;

    if (defaults == NULL)
        return;

    buffersize = getsize(defaults);

    if (buffersize > NVRAM_MAXSIZE)
    {
        error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Defaults too big to fit in nvram",WARNING);
        return;
    }

    if ((buff = malloc(buffersize)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Insufficient memory for nvram buffer",WARNING);
         return;
    }
    memset(buff,'\0',(size_t)buffersize);
    buff_write(buff,defaults);

    if ((f = fopen(filename,"wb")) == NULL)
    {
        error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Could not create nvram simulator file",WARNING);

        if (buff != NULL)
            free(buff);

        return;
    }
    n = fwrite(buff,sizeof(char),buffersize,f);

    if ((fclose(f)) != 0)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Could not close nvram file\n",WARNING);
    }

    if (buff != NULL)
        free(buff);

    return;
}


#endif


#if defined(NVRAM_SINGLE_TAG)


/************************************************************************************/
/* Function:   getsize                                                              */
/* Behaviour:  Calculates the size of the buffer required to hold setup defaults    */
/*             before writing them to nvram in the required format.                 */
/* Requires:   Setup defaults.                                                      */
/* Returns:    Size of buffer required.                                             */
/************************************************************************************/
static int getsize (setup_details_t *defaults)
{
  int size;

    size = ((int)(log10((double)defaults->phone.country_code))+1) + 1;

    if ((defaults->phone.outside_line_prefix) != NULL)
         size += strlen(defaults->phone.outside_line_prefix) + 2;
    else
         size += 2;  /* ... for null terminator and nvram delimiter. */

    if ((defaults->phone.call_waiting_prefix) != NULL)
         size += strlen(defaults->phone.call_waiting_prefix) + 2;
    else
         size += 2;

    size += sizeof(char) + 1;

    if ((defaults->isp.phone_number) != NULL)
         size += strlen(defaults->isp.phone_number) + 2;
    else
         size += 2;

    if ((defaults->isp.username) != NULL)
         size += strlen(defaults->isp.username) + 2;
    else
         size += 2;

    if ((defaults->isp.password) != NULL)
         size += strlen(defaults->isp.password) + 2;
    else
         size += 2;

    if ((defaults->isp.dns) != NULL)
         size += strlen(defaults->isp.dns) + 2;
    else
         size += 2;

    if ((defaults->isp.modem_script) != NULL)
         size += strlen(defaults->isp.modem_script) + 2;
    else
         size += 2;

    if ((defaults->ftp.url) != NULL)
         size += strlen(defaults->ftp.url) + 2;
    else
         size += 2;

    if ((defaults->ftp.username) != NULL)
         size += strlen(defaults->ftp.username) + 2;
    else
         size += 2;

    if ((defaults->ftp.password) != NULL)
         size += strlen(defaults->ftp.password) + 2;
    else
         size += 2;

    return size;
}


/************************************************************************************/
/* Function:  buff_write                                                            */
/************************************************************************************/
static void buff_write (char *p,setup_details_t *defaults)
{
    sprintf(p,"%d%c",defaults->phone.country_code,NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->phone.outside_line_prefix) != NULL)
         sprintf(p,"%s%c",defaults->phone.outside_line_prefix,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->phone.call_waiting_prefix) != NULL)
         sprintf(p,"%s%c",defaults->phone.call_waiting_prefix,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    sprintf(p,"%d%c",defaults->phone.wait_for_dialtone_flag,NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.phone_number) != NULL)
         sprintf(p,"%s%c",defaults->isp.phone_number,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.username) != NULL)
         sprintf(p,"%s%c",defaults->isp.username,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.password) != NULL)
         sprintf(p,"%s%c",defaults->isp.password,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.dns) != NULL)
         sprintf(p,"%s%c",defaults->isp.dns,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.modem_script) != NULL)
         sprintf(p,"%s%c",defaults->isp.modem_script,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->ftp.url) != NULL)
         sprintf(p,"%s%c",defaults->ftp.url,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->ftp.username) != NULL)
         sprintf(p,"%s%c",defaults->ftp.username,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->ftp.password) != NULL)
         sprintf(p,"%s%c",defaults->ftp.password,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);
}
#endif
