/************************************************************************************/
/*                                                                                  */
/*  File: nvram.c                                                                   */
/*                                                                                  */
/*  Copyright © 1998 Acorn Computers Ltd., Cambridge, England                       */
/*                                                                                  */
/*  Modification History:                                                           */
/*  Date         Engineer  Change                                                   */
/*  ----         --------  ------                                                   */
/*  xx-Jul-1998  SR        Created                                                  */
/*                                                                                  */
/************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "kernel.h"
#include "ui.h"
#include "errors.h"
#include "main.h"

#define LOGFILE

#include "nvram.h"

static int getsize(setup_details_t *defaults);
static void buff_write(char *p, setup_details_t *defaults);

/************************************************************************************/
/* Function:      get_nvram_defaults()                                              */
/* Behaviour:     Read defaults from nvram and hand them over to the UI Library.    */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/* Notes:         Format of nvram ServerInfoBuffer: D=NVRAM_DELIMITER               */
/*                <isp_phoneno>D<isp_username>D<isp_password>D<dns>D                */
/*                <isp_modemstring>D<ftp_url>D<ftp_username>D<ftp_password>D        */
/************************************************************************************/

#ifdef REAL_NVRAM
extern _kernel_oserror *get_nvram_defaults(void)
{
  int i,j;
  int size;
  int flags = 0;
  char *nvram_buffer_ptr = NULL;
  static setup_details_t defaults;
  int delimiters = 0;
  int field_lengths[EXPECTED_NUMBER_OF_DELIMITERS];
  _kernel_swi_regs regs;
  _kernel_oserror *er = NULL;

    defaults.phone.country_code = 0;
    defaults.phone.outside_line_prefix = defaults.phone.call_waiting_prefix = NULL;
    defaults.phone.wait_for_dialtone_flag = 0;

    defaults.isp.phone_number = defaults.isp.username = defaults.isp.password =
    defaults.isp.dns = defaults.isp.modem_script = NULL;

    defaults.ftp.url = defaults.ftp.username = defaults.ftp.password = NULL;

    regs.r[0] = "ServerInfoBuffer";
    regs.r[1] = 0;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
         goto bypass_nvram;
    }
    size = regs.r[0];

    if ((nvram_buffer_ptr = malloc(size)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",size,
           "Insufficient memory available for nvram buffer.",WARNING);
         goto bypass_nvram;
    }

    regs.r[0] = "ServerInfoBuffer";
    regs.r[1] = nvram_buffer_ptr;
    regs.r[2] = 0;
    if ((er = _kernel_swi(NVRAM_Read,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,WARNING);
         goto bypass_nvram;
    }

    i = 0;
    while (i < size)
    {
           if (*(nvram_buffer_ptr+i) == NVRAM_DELIMITER)
           {
               delimiters++;
           }
           i++;
    }

    if (delimiters != EXPECTED_NUMBER_OF_DELIMITERS)
    {
        /* NV-RAM was corrupted and the ServerInfoBuffer has been re-initialised
           to 0, or there are no defaults in store.
         */

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }
    }
    else
    {
        j = 0;
        for (i = 0; i < EXPECTED_NUMBER_OF_DELIMITERS; i++)
        {
             field_lengths[i] = 0;
             while (nvram_buffer_ptr[j] != NVRAM_DELIMITER)
             {
                    field_lengths[i]++;
                    j++;
             }
             j++;
        }

        if (((defaults.phone.outside_line_prefix = malloc(field_lengths[1]) == NULL) ||
            ((defaults.phone.call_waiting_prefix = malloc(field_lengths[2]) == NULL) ||
            ((defaults.isp.phone_number = malloc(field_lengths[4]) == NULL) ||
            ((defaults.isp.username = malloc(field_lengths[5]) == NULL) ||
            ((defaults.isp.password = malloc(field_lengths[6]) == NULL) ||
            ((defaults.isp.modem_script = malloc(field_lengths[7]) == NULL) ||
            ((defaults.isp.dns = malloc(field_lengths[8]) == NULL) ||
            ((defaults.ftp.url = malloc(field_lengths[9]) == NULL) ||
            ((defaults.ftp.username = malloc(field_lengths[10]) == NULL) ||
            ((defaults.ftp.password = malloc(field_lengths[11]) == NULL))
        {
               error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,
                 "Insufficient memory available for reading setup defaults.",WARNING);

               goto bypass_nvram;
        }

        sscanf(nvram_buffer_ptr,"%d",defaults.phone.country_code);
        nvram_buffer_ptr += strlen(defaults.phone.country_code) + 2;

        sscanf(nvram_buffer_ptr,"%[^'\033']",defaults.phone.outside_line_prefix);
        nvram_buffer_ptr += strlen(defaults.phone.outside_line_prefix) + 2;

        sscanf(nvram_buffer_ptr,"%c",defaults.phone.wait_for_dialtone_flag);
        nvram_buffer_ptr += strlen(defaults.phone.wait_for_dialtone_flag) + 2;

        sscanf(nvram_buffer_ptr,"%[^'\033']",defaults.isp.phone_number);
        nvram_buffer_ptr += strlen(defaults.isp.phone_number) + 2;

        sscanf(nvram_buffer_ptr,"%[^'\033']",defaults.isp.username);
        nvram_buffer_ptr += strlen(defaults.isp.username) + 2;

        sscanf(nvram_buffer_ptr,"%[^'\033']",defaults.isp.password);
        nvram_buffer_ptr += strlen(defaults.isp.password) + 2;

        sscanf(nvram_buffer_ptr,"%[^'\033']",defaults.isp.modem_script);
        nvram_buffer_ptr += strlen(defaults.isp.modem_script) + 2;

        sscanf(nvram_buffer_ptr,"%[^'\033']",defaults.isp.dns);
        nvram_buffer_ptr += strlen(defaults.isp.dns) + 2;

        sscanf(nvram_buffer_ptr,"%[^'\033']",defaults.ftp.url);
        nvram_buffer_ptr += strlen(defaults.ftp.url) + 2;

        sscanf(nvram_buffer_ptr,"%[^'\033']",defaults.ftp.username);
        nvram_buffer_ptr += strlen(defaults.ftp.username) + 2;

        sscanf(nvram_buffer_ptr,"%[^'\033']",defaults.ftp.password);


        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }
    }

    //engine_state = WAITNG_SRVR_ACCESS_INFO;

    if (nvram_buffer_ptr != NULL)
        free(nvram_buffer_ptr);

    return NULL;

    bypass_nvram: if (nvram_buffer_ptr != NULL)
                      free(nvram_buffer_ptr);

                  if (defaults.phone.outside_line_prefix != NULL)
                      free(defaults.phone.outside_line_prefix);

                  if (defaults.phone.call_waiting_prefix != NULL)
                      free(defaults.phone.call_waiting_prefix);

                  if (defaults.isp.phone_number != NULL)
                      free(defaults.isp.phone_number);

                 if (defaults.isp.username != NULL)
                      free(defaults.isp.username);

                  if (defaults.isp.password != NULL)
                      free(defaults.isp.password);

                  if (defaults.isp.modem_script != NULL)
                      free(defaults.isp.modem_script);

                  if (defaults.isp.dns != NULL)
                      free(defaults.isp.dns);

                  if (defaults.ftp.url != NULL)
                      free(defaults.ftp.url);

                  if (defaults.ftp.username != NULL)
                      free(defaults.ftp.username);

                  if (defaults.ftp.password != NULL)
                      free(defaults.ftp.password);

                  //engine_state = WAITNG_SRVR_ACCESS_INFO;

                  return NULL;
}

#else
/* Simulate nvram */

extern _kernel_oserror *get_nvram_defaults(void)
{
  FILE *f = NULL;
  int size;
  int i,j;
  int flags = 0;
  int delimiters = 0;
  int end,start;
  void *nvram_buffer_ptr = NULL;
  char *p = NULL;
  char filename[] = "nvsim";
  int field_lengths[EXPECTED_NUMBER_OF_DELIMITERS];
  static setup_details_t defaults;
  _kernel_oserror *er = NULL;

    defaults.phone.country_code = 0;
    defaults.phone.outside_line_prefix = defaults.phone.call_waiting_prefix = NULL;
    defaults.phone.wait_for_dialtone_flag = 0;

    defaults.isp.phone_number = defaults.isp.username = defaults.isp.password =
    defaults.isp.dns = defaults.isp.modem_script = NULL;

    defaults.ftp.url = defaults.ftp.username = defaults.ftp.password = NULL;

    if ((f = fopen(filename,"rb")) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Cannot open nvram file: nvsim",WARNING);
         goto bypass_nvram;
    }
    rewind(f);
    start = (int)ftell(f);

    if ((fseek(f,0L,SEEK_END)) != 0)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Cannot seek to end of nvram file",WARNING);
         goto bypass_nvram;
    }
    end = (int)ftell(f);

    size = end - start;

    if ((nvram_buffer_ptr = malloc(size)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",size,"Insufficient memory for nvram buffer.",WARNING);
         goto bypass_nvram;
    }
    p = (char *)nvram_buffer_ptr;
    rewind(f);

    if ((fread((char *)nvram_buffer_ptr,sizeof(char),size,f)) != size)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Read failure.",WARNING);
         goto bypass_nvram;
    }

    i = 0;
    while (i < size)
    {
           if (*(p+i) == NVRAM_DELIMITER)
           {
               delimiters++;
           }
           i++;
    }

    if (delimiters != EXPECTED_NUMBER_OF_DELIMITERS)
    {
        /* NV-RAM was corrupted and the ServerInfoBuffer has been re-initialised
           to 0, or there are no defaults in store.
         */

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }
    }
    else
    {
        j = 0;
        for (i = 0; i < EXPECTED_NUMBER_OF_DELIMITERS; i++)
        {
             field_lengths[i] = 0;
             while (p[j] != NVRAM_DELIMITER)
             {
                    field_lengths[i]++;
                    j++;
             }
             j++;
        }

        if (((defaults.phone.outside_line_prefix = malloc(field_lengths[1]+1)) == NULL) ||
            ((defaults.phone.call_waiting_prefix = malloc(field_lengths[2]+1)) == NULL) ||
            ((defaults.isp.phone_number = malloc(field_lengths[4]+1)) == NULL) ||
            ((defaults.isp.username = malloc(field_lengths[5]+1)) == NULL) ||
            ((defaults.isp.password = malloc(field_lengths[6]+1)) == NULL) ||
            ((defaults.isp.dns = malloc(field_lengths[7]+1)) == NULL) ||
            ((defaults.isp.modem_script = malloc(field_lengths[8]+1)) == NULL) ||
            ((defaults.ftp.url = malloc(field_lengths[9]+1)) == NULL) ||
            ((defaults.ftp.username = malloc(field_lengths[10]+1)) == NULL) ||
            ((defaults.ftp.password = malloc(field_lengths[11]+1)) == NULL))
        {
              error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,
                "Insufficient memory available for reading setup defaults.",WARNING);

               goto bypass_nvram;
        }

        defaults.phone.country_code = atoi(p);
        p += ((int)(log10((double)defaults.phone.country_code))+1) + 1;

        sscanf(p,"%[^'\033']",defaults.phone.outside_line_prefix);
        defaults.phone.outside_line_prefix[field_lengths[1]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.phone.call_waiting_prefix);
        defaults.phone.call_waiting_prefix[field_lengths[2]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        if (*p == '1')
            defaults.phone.wait_for_dialtone_flag = 1;
        else
            defaults.phone.wait_for_dialtone_flag = 0;
        p += 2;

        sscanf(p,"%[^'\033']",defaults.isp.phone_number);
        defaults.isp.phone_number[field_lengths[4]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.username);
        defaults.isp.username[field_lengths[5]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.password);
        defaults.isp.password[field_lengths[6]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.dns);
        defaults.isp.dns[field_lengths[7]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.isp.modem_script);
        defaults.isp.modem_script[field_lengths[8]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.url);
        defaults.ftp.url[field_lengths[9]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.username);
        defaults.ftp.username[field_lengths[10]] = '\0';
        while (*p++ != NVRAM_DELIMITER);

        sscanf(p,"%[^'\033']",defaults.ftp.password);
        defaults.ftp.password[field_lengths[11]] = '\0';

        if ((er = ui_set_defaults(flags,&defaults)) != NULL)
        {
             error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,er->errmess,FATAL);
        }

    }

    bypass_nvram: if (nvram_buffer_ptr != NULL)
                      free(nvram_buffer_ptr);

                  if (defaults.phone.outside_line_prefix != NULL)
                      free(defaults.phone.outside_line_prefix);

                  if (defaults.phone.call_waiting_prefix != NULL)
                      free(defaults.phone.call_waiting_prefix);

                  if (defaults.isp.phone_number != NULL)
                      free(defaults.isp.phone_number);

                 if (defaults.isp.username != NULL)
                      free(defaults.isp.username);

                  if (defaults.isp.password != NULL)
                      free(defaults.isp.password);

                  if (defaults.isp.modem_script != NULL)
                      free(defaults.isp.modem_script);

                  if (defaults.isp.dns != NULL)
                      free(defaults.isp.dns);

                  if (defaults.ftp.url != NULL)
                      free(defaults.ftp.url);

                  if (defaults.ftp.username != NULL)
                      free(defaults.ftp.username);

                  if (defaults.ftp.password != NULL)
                      free(defaults.ftp.password);

                  if (f != NULL)
                      fclose(f);

                  return NULL;

}
#endif

/************************************************************************************/
/* Function:      write_nvram_defaults()                                            */
/* Behaviour:     Reads setup info entered by the user and saves it to nvram.       */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
#ifdef REAL_NVRAM
extern void write_nvram_defaults(setup_details_t *defaults)
{
  char *buff, *p;
  int buffersize;
  _kernel_swi_regs regs;
  _kernel_oserror *er;

    if (defaults == NULL)
        return;

    buffersize = getsize(defaults);

    if (buffersize > NVRAM_MAXSIZE)
    {
        error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Defaults too big to fit in nvram",WARNING);
    }

    if ((buff = malloc(buffersize)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",0,"Insufficient memory to save setup defaults.",WARNING);
         return;
    }

    buff_write(buff,defaults);

    regs.r[0] = (int)"ServerInfoBuffer";
    regs.r[1] = (int)buff;
    regs.r[2] = buffersize;
    if ((er = _kernel_swi(NVRAM_Write,&regs,&regs)) != NULL)
    {
         error_handler(__FILE__,__LINE__,"get_nvram_defaults()",er->errnum,"er->errmess",WARNING);
    }

    if (buff != NULL)
        free(buff);

    return;
}

#else

extern void write_nvram_defaults(setup_details_t *defaults)
{
  char filename[] = "nvsim";
  FILE *f = NULL;
  int n;
  char *buff = NULL;
  int buffersize = 0;

    if (defaults == NULL)
        return;

    buffersize = getsize(defaults);

    if (buffersize > NVRAM_MAXSIZE)
    {
        error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Defaults too big to fit in nvram",WARNING);
        return;
    }

    if ((buff = malloc(buffersize)) == NULL)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Insufficient memory for nvram buffer",WARNING);
         return;
    }
    memset(buff,'\0',(size_t)buffersize);
    buff_write(buff,defaults);

    if ((f = fopen(filename,"wb")) == NULL)
    {
        error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Could not create nvram simulator file",WARNING);

        if (buff != NULL)
            free(buff);

        return;
    }
    n = fwrite(buff,sizeof(char),buffersize,f);

    if ((fclose(f)) != 0)
    {
         error_handler(__FILE__,__LINE__,"write_nvram_defaults()",0,"Could not close nvram file\n",WARNING);
    }

    if (buff != NULL)
        free(buff);

    return;
}
#endif

/************************************************************************************/
/* Function:      getsize()                                            */
/* Behaviour:        */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static int getsize(setup_details_t *defaults)
{
  int size;

    size = ((int)(log10((double)defaults->phone.country_code))+1) + 1;

    if ((defaults->phone.outside_line_prefix) != NULL)
         size += strlen(defaults->phone.outside_line_prefix) + 2;
    else
         size += 2;  /* ... for null terminator and nvram delimiter. */

    if ((defaults->phone.call_waiting_prefix) != NULL)
         size += strlen(defaults->phone.call_waiting_prefix) + 2;
    else
         size += 2;

    size += sizeof(char) + 1;

    if ((defaults->isp.phone_number) != NULL)
         size += strlen(defaults->isp.phone_number) + 2;
    else
         size += 2;

    if ((defaults->isp.username) != NULL)
         size += strlen(defaults->isp.username) + 2;
    else
         size += 2;

    if ((defaults->isp.password) != NULL)
         size += strlen(defaults->isp.password) + 2;
    else
         size += 2;

    if ((defaults->isp.dns) != NULL)
         size += strlen(defaults->isp.dns) + 2;
    else
         size += 2;

    if ((defaults->isp.modem_script) != NULL)
         size += strlen(defaults->isp.modem_script) + 2;
    else
         size += 2;

    if ((defaults->ftp.url) != NULL)
         size += strlen(defaults->ftp.url) + 2;
    else
         size += 2;

    if ((defaults->ftp.username) != NULL)
         size += strlen(defaults->ftp.username) + 2;
    else
         size += 2;

    if ((defaults->ftp.password) != NULL)
         size += strlen(defaults->ftp.password) + 2;
    else
         size += 2;

    return size;
}

/************************************************************************************/
/* Function:      buff_write()                                            */
/* Behaviour:        */
/* Prerequisites:*/
/* Requires:*/
/* Returns:*/
/* Outputs:*/
/************************************************************************************/
static void buff_write(char *p,setup_details_t *defaults)
{
    sprintf(p,"%d%c",defaults->phone.country_code,NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->phone.outside_line_prefix) != NULL)
         sprintf(p,"%s%c",defaults->phone.outside_line_prefix,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->phone.call_waiting_prefix) != NULL)
         sprintf(p,"%s%c",defaults->phone.call_waiting_prefix,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    sprintf(p,"%d%c",defaults->phone.wait_for_dialtone_flag,NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.phone_number) != NULL)
         sprintf(p,"%s%c",defaults->isp.phone_number,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.username) != NULL)
         sprintf(p,"%s%c",defaults->isp.username,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.password) != NULL)
         sprintf(p,"%s%c",defaults->isp.password,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.dns) != NULL)
         sprintf(p,"%s%c",defaults->isp.dns,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->isp.modem_script) != NULL)
         sprintf(p,"%s%c",defaults->isp.modem_script,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->ftp.url) != NULL)
         sprintf(p,"%s%c",defaults->ftp.url,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->ftp.username) != NULL)
         sprintf(p,"%s%c",defaults->ftp.username,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);

    if ((defaults->ftp.password) != NULL)
         sprintf(p,"%s%c",defaults->ftp.password,NVRAM_DELIMITER);
    else
         sprintf(p,"%c%c",'\0',NVRAM_DELIMITER);
    while (*p++ != NVRAM_DELIMITER);
}
