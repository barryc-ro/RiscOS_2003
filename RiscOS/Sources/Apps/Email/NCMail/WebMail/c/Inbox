/************************************************************************/
/* File:    Inbox.c                                                     */
/* Purpose: Normal inbox code.                                          */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Wed 16th September 1998                               */
/*                Created.                                              */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "WebMail.h"
#include "Inbox.h"

#include "Time.h"
#include "Locale.h"
#include "escapehtml.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

#define DateString_Length	30



/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* inbox_message_received                                               */
/*                                                                      */
/* Function is called when the library receives an ncmail: message from */
/* the Inbox screen.                                                    */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
bool inbox_message_received(int num_args, url_param *  arg)
{
  int		 counter;

  dprintf(("UI", "inbox_message_received entered\n"));

  for (counter = 0; counter < num_args; counter++)
  {
    /* Exit Button */
    if (nb_case_insensitive_strcmp(arg[counter].value, Inbox_Button_Exit) == 0)
    {
      inbox_exit_selected();
    }
    /* Netlink Button */
    else if (nb_case_insensitive_strcmp(arg[counter].value, Inbox_Button_Netlink) == 0)
    {
      inbox_netlink_selected();
    }
    /* Compose Button */
    else if (nb_case_insensitive_strcmp(arg[counter].value, Inbox_Button_Compose) == 0)
    {
      inbox_compose_selected();
    }
    /* "Read" Button */
    else if (nb_case_insensitive_strcmp(arg[counter].value, Inbox_Button_Read) == 0)
    {
      inbox_read_selected(num_args, arg);
    }
  }
  return(true);
}


/************************************************************************/
/* inbox_exit_selected                                                  */
/*                                                                      */
/* Function is called when the user clicks on the Exit button in the    */
/* Inbox screen.                                                        */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void inbox_exit_selected(void)
{
  dprintf(("UI", "EXIT SELECTED\n"));
  eng_email_active(false);

  browserif_sendurl(status.exit_url, false);
  free(status.exit_url);
}


/************************************************************************/
/* inbox_netlink_selected                                               */
/*                                                                      */
/* Function is called when the user clicks on the Netlink button in the */
/* Inbox screen.  The UI's internal states will be updated by the engine*/
/* when it receives the eng_(dis)connect() and calls me back.           */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void inbox_netlink_selected(void)
{
  if (status.netlink == NetLink_Online)
  {
    dprintf(("UI", "DISCONNECT SELECTED\n"));
    eng_disconnect();
  }
  else
  {
    dprintf(("UI", "CONNECT SELECTED\n"));
    eng_connect();
  }
}


/************************************************************************/
/* inbox_compose_selected                                               */
/*                                                                      */
/* Function is called when the user clicks on the Compose button in the */
/* Inbox screen.                                                        */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void inbox_compose_selected(void)
{
  dprintf(("UI", "COMPOSE SELECTED\n"));
}


/************************************************************************/
/* inbox_read_selected                                                  */
/*                                                                      */
/* Function is called when the user clicks on a link for a message      */
/* entry in the Inbox screen.                                           */
/*                                                                      */
/* Parameters: num_args - number of items in args.                      */
/*             args     - Arguments structure.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void inbox_read_selected(uint32 num_args, url_param *  arg)
{
  int		 counter;

  dprintf(("UI", "READ SELECTED "));

  for (counter = 0; counter < num_args; counter++)
  {
    if (nb_case_insensitive_strcmp(arg[counter].name, "id") == 0)
    {
      dprintf(("UI", "on message: %s\n", arg[counter].value));
    }
  }
}


/************************************************************************/
/* ncmui_inbox_render_cbf                                               */
/*                                                                      */
/* Function is used by the engine to inform the UI when the inbox should*/
/* be updated.                                                          */
/*                                                                      */
/* Parameters: eng_cbf_prompt params.                                   */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void ncmui_inbox_render_cbf(eng_rcode rc, MessageDescriptor *msg, bool online, void *handle)
{
  dprintf(("UI", "#############################\n"));
  dprintf(("UI", "ncmui_inbox_render_cbf called\n"));
  dprintf(("UI", "Status: %d\n", status.state));
  dprintf(("UI", "#############################\n"));

  if (rc == ENG_COMPLETED)
  {
    /* If the state is Inbox unprocessed then do a render */
    if (status.state == State_Inbox_Unprocessed)
    {
      inbox_build_screen();
    }
    else if (status.state == State_Inbox)
    {
      inbox_build_screen();
    }
  }
}


/* ============================================================================================== */
/* ===================================== PAGE BUILDING CODE ===================================== */
/* ============================================================================================== */

/************************************************************************/
/* inbox_build_screen                                                   */
/*                                                                      */
/* Function is called when the Inbox has to be displayed.  Any old      */
/* pages must be deleted, the root page copied from ResourceFS and the  */
/* header & listing pages generated.                                    */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void inbox_build_screen(void)
{
  dprintf(("UI", "*******************************************************\n"));
  /* Delete any Inbox files present */
  if (nb_file_exists(1, Generated_Inbox_Parent, NULL, NULL) == NULL)
  {
    dprintf(("UI", "'Inbox' existed - deleting\n"));
    nb_file_delete(1, Generated_Inbox_Parent, NULL);
  }
  if (nb_file_exists(1, Generated_Inbox_Header, NULL, NULL) == NULL)
  {
    dprintf(("UI", "'Inbox_H' existed - deleting\n"));
    nb_file_delete(1, Generated_Inbox_Header, NULL);
  }
  if (nb_file_exists(1, Generated_Inbox_Listing, NULL, NULL) == NULL)
  {
    dprintf(("UI", "'Inbox_L' existed - deleting\n"));
    nb_file_delete(1, Generated_Inbox_Listing, NULL);
  }

  /* Copy Inbox Parent into place */
  if (nb_file_copy(0, Template_Inbox_Parent, Generated_Inbox_Parent) != NULL)
    dprintf(("UI", "Parent Copy Error\n"));

  /* Decide whether we are online or not? */
  if (status.netlink == NetLink_Online)
  {
    dprintf(("UI", "Copying Online header file\n"));
    if (nb_file_copy(0, Template_Inbox_Header_Online, Generated_Inbox_Header) != NULL)
      dprintf(("UI", "'Inbox_H' online *NOT* copied\n"));
  }
  else
  {
    dprintf(("UI", "Copying Offline header file\n"));
    if (nb_file_copy(0, Template_Inbox_Header_Offline, Generated_Inbox_Header) != NULL)
      dprintf(("UI", "'Inbox_H' offline *NOT* copied\n"));
  }

  /* Parse Inbox Listing file and build proper screen */
  parser_parse_file(PageType_Inbox, Template_Inbox_Listing, Generated_Inbox_Listing);

  dprintf(("UI", "FINISHED BUILDING INBOX PAGE\n"));
  dprintf(("UI", "*******************************************************\n"));

  browserif_sendurl(Open_Inbox, false);
}


/************************************************************************/
/* inbox_active_comment_found                                           */
/*                                                                      */
/* Function is called when the UI page type is Inbox & an active comment*/
/* is found in the web page being parsed.                               */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void inbox_active_comment_found(char *comment, FILE *out)
{
  if (nb_case_insensitive_strcmp(comment, Inbox_AC_Table_Row) == 0)
  {
    inbox_output_messages_listing(out);
  }
  /* Not a known tag */
  else
  {
    fprintf(out, "<H1>Unknown tag '%s' received</H1><BR>\n", comment);
  }
}



/************************************************************************/
/* inbox_output_messages_listing                                        */
/*                                                                      */
/* Function outputs the Inbox Intray at the current file position.  If  */
/* the inbox is processed then we can display it.  If not then a status */
/* must be displayed in the intray table.                               */
/*                                                                      */
/* Parameters: out - FILE pointer to output file.                       */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void inbox_output_messages_listing(FILE *out)
{
  eng_rcode		 er;
  MessageDescriptor	*ptr = NULL;
  char			*output_line;
  char			*token;
  int			 len = 0;

  er = eng_get_mailbox_list(&ptr);

  if (er == ENG_EUNPROCESSED)
  {
    /* Set internal state */
    status.state = State_Inbox_Unprocessed;

    /* We have an unprocessed Mailbox.  We now have to determine whether we are online or offline,
     * and display the appropriate message
     */
    if (status.netlink == NetLink_Online)
    {
      fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "INBOX_Unprocessed_On"));
    }
    else
    {
      fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "INBOX_Unprocessed_Off"));
    }
  }
  else
  {
    /* Set internal state */
    status.state = State_Inbox;

    dprintf(("UI", "#####################################\n"));

    /* Get length of Messagetrans token */
    len = nb_messagetrans_token_length(message_block, "INBOX_Intray_Row");

    if ( ((output_line= malloc(len + 300)) == NULL)	||
         ((token= malloc(len + 5)) == NULL)
       )
    {
      dprintf(("UI", "ERROR: Not enough memory to create inbox listing.\n"));
    }
    else
    {
      /* Get token from messages file */
      strcpy(token, nb_messagetrans_lookup(message_block, "INBOX_Intray_Row"));

      while (ptr)
      {
        dprintf(("", "From:    %s\n", ptr->from));
        dprintf(("", "Subject: %s\n", ptr->subject));
        dprintf(("", "Date:    %s\n", asctime(ptr->datestruct)));
        dprintf(("", "Flags:   %d\n", ptr->flags));

        inbox_output_message_html(out, ptr, token, len);

        ptr = ptr->next;
      }
      free(token);
      free(output_line);
    }

    dprintf(("UI", "#####################################\n"));
  }
}


/************************************************************************/
/* inbox_output_message_html                                            */
/*                                                                      */
/* Function takes the required details to build a line of the Inbox     */
/* table, escapes the output to remove reserved HTML characters and     */
/* outputs the data as an HTML Table Row.                               */
/*                                                                      */
/* Parameters: out     - file pointer                                   */
/*             flags   - flags word for message                         */
/*             id      - message id                                     */
/*             from    - from text                                      */
/*             date    - date struct for turning into date string.      */
/*             subject - subject text.                                  */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void inbox_output_message_html(FILE *out, MessageDescriptor *msg, char *html, uint32 len)
{
  char			*output_line;
  char			*from;
  char			*subject;
  char			*image_filename;
  char			*date;
  char			*date_initial;
  int			 sub_len = 0;
  int			 date_len = 0;
  int			 from_len = 0;
  int			 rc = 0;
  esc_html_context	 context;

  /* First check to see if the subject text is empty */
  if ( (msg->subject == NULL) || (strcmp(msg->subject, "") == 0) )
  {
    /* Empty, so we need the INBOX_No_Subject token text to be output instead */
    sub_len = (nb_messagetrans_token_length(message_block, "INBOX_No_Subject") * 6) + 5;
  }
  else
  {
    sub_len = (strlen(msg->subject) * 6) + 5;
  }

  /* For escaping characters the rule is that you must malloc the size of the original string
   * times 6 to ensure that all characters in the string can be escaped.
   */
  from_len = (strlen(msg->from) * 6) + 5;
  date_len = (DateString_Length * 6) + 5;

  if ( ((output_line= malloc(len + 300)) == NULL)			||
       ((date_initial = malloc(DateString_Length)) == NULL)		||
       ((date = malloc(date_len)) == NULL)  				||
       ((from = malloc(from_len)) == NULL)  				||
       ((subject = malloc(sub_len)) == NULL)				||
       ((image_filename = malloc(Inbox_Filename_Max_Length)) == NULL)
     )
  {
    dprintf(("UI", "ERROR: Not enough memory to create inbox listing.\n"));
  }
  else
  {
    /* Setup the initial date string based on the tm structure passed.  Then send this to
     * strftime to get internationalised date.  Later pass it through the html escaper with the
     * rest of the text
     */
    strftime(date_initial, DateString_Length, "%d %b", msg->datestruct);

    /* Check the flags for the message to ensure the correct graphic is displayed */
    if ( (msg->flags & (NEW | DOWNLOADED)) == (NEW | DOWNLOADED) )
    {
      strcpy(image_filename, Inbox_Local_New_Message);
    }
    else if ( (msg->flags & (READ | DOWNLOADED)) == (READ | DOWNLOADED) )
    {
      strcpy(image_filename, Inbox_Local_Read_Message);
    }
    else if ( (!(msg->flags & DOWNLOADED)) && ((msg->flags & READ) == READ) )
    {
      strcpy(image_filename, Inbox_Server_Read_Message);
    }
    else if ( (!(msg->flags & DOWNLOADED)) && ((msg->flags & NEW) == NEW) )
    {
      strcpy(image_filename, Inbox_Server_New_Message);
    }
    else
    {
      strcpy(image_filename, Inbox_Local_Read_Message);
    }

    /* Setup The Subject Text.
     * Check the subject field to ensure there is some text to build the link around
     */
    if ( (msg->subject == NULL) || (strcmp(msg->subject, "") == 0) )
    {
      /* No subject, so escape the Message token */
      context = NULL;
      while (rc = escape_html_mem_to_mem (nb_messagetrans_lookup(message_block, "INBOX_No_Subject"),
                                          subject, sub_len, 1, &context), rc == 0);
    }
    else
    {
      /* Has subject, so escape the Message token */
      context = NULL;
      while (rc = escape_html_mem_to_mem (msg->subject, subject, sub_len, 1, &context), rc == 0);
    }
    /* Check for error code in either situation */
    if (rc == 0)
    {
      strcpy(subject, "Escaping Error");
    }

    /* Setup The From Text.
     * Escape the text and output if no error
     */
    context = NULL;
    while (rc = escape_html_mem_to_mem (msg->from, from, from_len, 1, &context), rc == 0);

    /* Check for error code in either situation */
    if (rc == 0)
    {
      strcpy(subject, "Escaping Error");
    }

    /* Setup The Date Text.
     * Escape the text and output if no error
     */
    context = NULL;
    while (rc = escape_html_mem_to_mem (date_initial, date, date_len, 1, &context), rc == 0);

    /* Check for error code in either situation */
    if (rc == 0)
    {
      strcpy(subject, "Escaping Error");
    }


    /* Output the escaped data plus the message ID in the correct order based on the html
     * fragment from the Messages file
     */
    sprintf(output_line, html, image_filename,
                               from,
                               date,
                               msg->ID,
                               subject);
    fprintf(out, "%s\n", output_line);

    /* Tidy up */
    free(date);
    free(date_initial);
    free(from);
    free(subject);
    free(image_filename);
    free(output_line);
  }
}



