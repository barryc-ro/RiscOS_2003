/************************************************************************/
/* File:    ReadMsg.c                                                   */
/* Purpose: Code relating to displaying an email message, including     */
/*          attachments on the screen using HTML.                       */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Mon 28th September 1998                               */
/*                Created.                                              */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "WebMail.h"
#include "ReadMsg.h"
#include "Inbox.h"
#include "EscapeHTML.h"
#include "PopUp.h"
#include "Reply.h"
/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */


/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

/* This is used to pass around MessageIds in the case of Delete messages. */
char *readmsg_id_ptr = NULL;

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* readmsg_message_received                                             */
/*                                                                      */
/* Function is called when the library receives an ncmail: message from */
/* the Read Message screen.                                             */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
bool readmsg_message_received(int num_args, url_param *  arg)
{
  int32		 counter = -1;
  bool		 found = false;

  dprintf(("UI", "readmsg_message_received entered\n"));

  /* Check to see if the UI is locked */
  if (status.ui_locked == false)
  {
    /* Now lock the UI to prevent clicks until whatever item is selected is unlocked */
    status.ui_locked = true;

    do
    {
      counter++;
      dprintf(("UI", "Name:  %s\n", arg[counter].name));
      dprintf(("UI", "Value: %s\n", arg[counter].value));
       /* Inbox Button */
      if (nb_case_insensitive_strcmp(arg[counter].value, ReadMsg_Button_Inbox) == 0)
      {
        readmsg_inbox_selected();
        found = true;
      }
      /* Reply Button */
      else if (nb_case_insensitive_strcmp(arg[counter].value, ReadMsg_Button_Reply) == 0)
      {
        readmsg_reply_selected(num_args, arg);
        found = true;
      }
      /* Delete Button */
      else if (nb_case_insensitive_strcmp(arg[counter].value, ReadMsg_Button_Delete) == 0)
      {
        readmsg_delete_selected(num_args, arg);
        found = true;
      }
    }
    while ( (found == false) && (counter < num_args) );

    if (found == false)
    {
      ncmui_error_display(5);
      status.ui_locked = false;
    }
  }
  return(true);
}


/************************************************************************/
/* readmsg_inbox_selected                                               */
/*                                                                      */
/* Function is called when the user clicks on the Inbox button in the   */
/* Read Message screen.                                                 */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_inbox_selected(void)
{
  dprintf(("UI", "INBOX SELECTED\n"));

  /* Unlocking of the UI occurs within inbox_build_screen() */
  inbox_build_screen();
}


/************************************************************************/
/* readmsg_reply_selected                                               */
/*                                                                      */
/* Function is called when the user clicks on the Reply button in the   */
/* Read Message screen.                                                 */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_reply_selected(int num_args, url_param *  arg)
{
  int		 counter;
  uint32	 msg;

  dprintf(("UI", "REPLY SELECTED "));

  for (counter = 0; counter < num_args; counter++)
  {
    if (nb_case_insensitive_strcmp(arg[counter].name, Template_Tag_ID) == 0)
    {
      dprintf(("UI", "on message: %s\n", arg[counter].value));
      msg = atoi(arg[counter].value);
      reply_selected_from_readmsg(msg);
    }
  }

  /* ## This should be removed when reply is completed */
  status.ui_locked = false;
}


/************************************************************************/
/* readmsg_delete_selected                                              */
/*                                                                      */
/* Function is called when the user clicks on the Delete button in the  */
/* Read Message screen.                                                 */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_delete_selected(int num_args, url_param *  arg)
{
  int		 counter;
  int		 found = 0;

  for (counter = 0; counter < num_args; counter++)
  {
    if (nb_case_insensitive_strcmp(arg[counter].name, Template_Tag_ID) == 0)
    {
      found = counter;
    }
  }

  /* This malloc is free'd in the readmsg_delete_cbf function */
  if ((readmsg_id_ptr = malloc(strlen(arg[found].value) + 2)) == NULL)
  {
    ncmui_error_display(1);
  }
  else
  {
    strcpy(readmsg_id_ptr, arg[found].value);

    dprintf(("UI", "malloc'd into msg_id_ptr as:       %s\n", readmsg_id_ptr));

    popup_2_open_dialogue( nb_messagetrans_lookup(message_block, "READMSG_Delete"),
                           nb_messagetrans_lookup(message_block, "BUTTON_Delete"),
                           nb_messagetrans_lookup(message_block, "BUTTON_Cancel"),
                           readmsg_delete_cbf,
                           (void *) readmsg_id_ptr );
  }
}


/************************************************************************/
/* readmsg_delete_cbf                                                   */
/*                                                                      */
/* Function is called when the user clicks on either of the buttons on  */
/* the Popup dialogue.                                                  */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void readmsg_delete_cbf(bool default_sel, void *handle)
{
  uint32 id;
  uint32	*item;
  eng_rcode	 rc;

  dprintf(("UI", "readmsg_delete_cbf entered with handle of: %d\n", (uint32) handle));

  /* For now keep this in until really sending is implemented. */
  status.ui_locked = false;

  /* User selected Delete */
  if (default_sel == true)
  {
    id = atoi( (char *)handle );

    dprintf(("UI", "DELETE SELECTED on message: %d\n", id));
    dprintf(("UI", "Mode is %d:\n", status.state));

    /* Delete Message */
    /* DO NOT FREE THIS MALLOC.  It is free'd by the engine. */
    if ((item = (uint32 *) malloc(sizeof(uint32))) == NULL)
    {
      ncmui_error_display(1);
    }
    else
    {
      status.state = State_ReadMsg_Delete;
      item[0] = id;
      dprintf(("UI", "DELETE SELECTED on item: %d\n", item[0]));

      /* No need to mark for deletion here because eng_mark_for_deletion() calls the UI upate
       * cbf.
       */
      rc = eng_mark_for_deletion(1, item);
      if ( (rc != ENG_COMPLETED) && (rc != ENG_RUNNING) )
      {
        ncmui_error_display(6);
      }
      popup_close_dialogue();
    }
  }
  else
  {
    /* User wants to continue.  So just close the PopUp. */
    popup_close_dialogue();
  }

  /* Free the message id global pointer */
  free(readmsg_id_ptr);
  readmsg_id_ptr = NULL;
}


/************************************************************************/
/* readmsg_inbox_message_selected                                       */
/*                                                                      */
/* Function is called by the Inbox code when the user clicks on a       */
/* message link.                                                        */
/*                                                                      */
/* Parameters: num_args - number of items in arg.                       */
/*             arg      - data embedded in the HTML.                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_inbox_message_selected(uint32 num_args, url_param *arg)
{
  int		 counter;
  uint32	 id = 0;

  dprintf(("UI", "readmsg_message_selected entered\n"));

  dprintf(("UI", "READ SELECTED "));

  for (counter = 0; counter < num_args; counter++)
  {
    if (nb_case_insensitive_strcmp(arg[counter].name, Template_Tag_ID) == 0)
    {
      dprintf(("UI", "on message: %s\n", arg[counter].value));

      id = atoi(arg[counter].value);

      readmsg_build_screen(id);
    }
    else
    {
      ncmui_error_display(7);
    }
  }
}



/* ============================================================================================== */
/* ===================================== PAGE BUILDING CODE ===================================== */
/* ============================================================================================== */


/************************************************************************/
/* readmsg_build_screen                                                 */
/*                                                                      */
/* Function is called when the ReadMsg screen has to be displayed.  Any */
/* old pages must be deleted, the root page copied from ResourceFS & the*/
/* header & listing pages generated.                                    */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_build_screen(uint32 msg_id)
{
  eng_rcode		 rc;

  dprintf(("UI", "*******************************************************\n"));
  dprintf(("UI", "Read message %d request come in.\n", msg_id));

  ncmui_tidy_output_dir();
  rc = eng_get_message(msg_id, NULL, ncmui_get_message_cbf);
  if (rc != ENG_RUNNING)
  {
    popup_1_open_dialogue( nb_messagetrans_lookup(message_block, "READMSG_GetMsgFail"),
                           nb_messagetrans_lookup(message_block, "BUTTON_OK"),
                           readmsg_getmsgfail_cbf,
                           NULL );
    ncmui_error_display(8);
  }

  dprintf(("UI", "*******************************************************\n"));
}


/************************************************************************/
/* ncmui_get_message_cbf                                                */
/*                                                                      */
/* Function is called by the Engine once it has retrieved the requested */
/* message.  Must then build the HTML pages.                            */
/*                                                                      */
/* Parameters: eng_cbf_getmsg params.                                   */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void ncmui_get_message_cbf(eng_rcode rc, MessageDescriptor *msg, void *handle)
{
  eng_rcode	er;
  bool		rc1 = true, rc2 = true, rc3 = true;

  NB_UNUSED(handle);

  dprintf(("UI", "Eng rc: %d\n", rc));

  if (rc == ENG_GETMSGFAILED)
  {
    popup_1_open_dialogue( nb_messagetrans_lookup(message_block, "READMSG_GetMsgFail"),
                           nb_messagetrans_lookup(message_block, "BUTTON_OK"),
                           readmsg_getmsgfail_cbf,
                           NULL );
  }
  else if (rc == ENG_CONNECTCANCELLED)
  {
    inbox_build_screen();
  }
  else
  {
    dprintf(("UI", "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n"));
    dprintf(("UI", "Got message %d back from engine\n", msg->ID));
    dprintf(("UI", "From:    %s\n", msg->fromreal));
    dprintf(("UI", "Address: %s\n", msg->fromaddr));
    dprintf(("UI", "Subject: %s\n", msg->subject));

    /* Copy parent file across */
    if (nb_file_copy(0, Template_ReadMsg_Parent, Generated_ReadMsg_Parent) != NULL)
    {
      rc1 = false;
      ncmui_error_display(16);
    }
    /* Parse Inbox Listing file and build proper screen */
    rc2 = parser_parse_file(PageType_ReadMsg,Template_ReadMsg_Header,Generated_ReadMsg_Header,
                          (void *) msg);
    rc3 = parser_parse_file(PageType_ReadMsg, Template_ReadMsg_Body, Generated_ReadMsg_Body,
                            (void *) msg);

    if ( (rc1 == false) || (rc2 == false) || (rc3 == false) )
    {
      /* *** FATAL ERROR *** */
      error_parser_failed();
      ncmui_error_display(17);
    }
    else
    {
      browserif_sendurl(Open_ReadMsg, false);
      status.state = State_ReadMsg;

      /* Update the state of the message to read */
      er = eng_mark_as_read(msg->ID);
      if ( (er != ENG_COMPLETED) && (er != ENG_RUNNING) )
        ncmui_error_display(9);
    }

    /* Unlock the UI */
    status.ui_locked = false;

    dprintf(("UI", "FINISHED BUILDING READMSG PAGE\n"));
    dprintf(("UI", "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n"));
  }
}


/************************************************************************/
/* readmsg_getmsgfail_cbf                                               */
/*                                                                      */
/* Function is called when the engine returns ENG_GETMSGFAILED in the   */
/* callback for eng_get_message().  Must redisplay the inbox.           */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void readmsg_getmsgfail_cbf(bool sel, void *handle)
{
  popup_close_dialogue();
  inbox_build_screen();
}


/************************************************************************/
/* readmsg_active_comment_found                                         */
/*                                                                      */
/* Function is called when the UI page type is Read & an active comment */
/* is found in the web page being parsed.                               */
/*                                                                      */
/* Parameters: comment - The comment found by parser_parse_file().      */
/*             out     - FILE pointer to output file.                   */
/*             msg     - MessageDescriptor for message being output.    */
/*                       This is passed to parser_parse_file when read  */
/*                       is clicked on and passed back when an AC is    */
/*                       found.                                         */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_active_comment_found(char *comment, FILE *out, MessageDescriptor *msg)
{
  if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_MsgID) == 0)
  {
    fprintf(out, "%d", msg->ID);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_Charset) == 0)
  {
    fprintf(out, msg->charset);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_Date) == 0)
  {
    readmsg_output_item(out, msg->datestr);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_From) == 0)
  {
    if ( (msg->fromreal == NULL) || (strcmp(msg->fromreal, "") == 0) )
    {
      readmsg_output_item(out, msg->fromaddr);
    }
    else
    {
      /* Output <real name> <space> <angel_bracket><email address><angel_bracket> */
      readmsg_output_item(out, msg->fromreal);
      fprintf(out, " %s", HTML_AngleBracket_Left);
      readmsg_output_item(out, msg->fromaddr);
      fprintf(out, "%s", HTML_AngleBracket_Right);
    }
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_To) == 0)
  {
    readmsg_output_item(out, msg->to);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_CC) == 0)
  {
    readmsg_output_item(out, msg->cc);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_Subject) == 0)
  {
    readmsg_output_item(out, msg->subject);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_Body) == 0)
  {
    readmsg_output_attachments(out, msg);
  }
  /* Not a known tag */
  else
  {
    ncmui_error_display(11);
#ifdef DEBUGLIB
    fprintf(out, "<H1>Unknown tag '%s' received</H1><BR>\n", comment);
#endif
  }
}


/************************************************************************/
/* readmsg_output_item                                                  */
/*                                                                      */
/* Function is called by readmsg_active_comment_found() to output a     */
/* string, escaping it first.  A check is made to ensure that there is  */
/* valid data in the string first.                                      */
/*                                                                      */
/* Parameters: out  - pointer to output file.                           */
/*             item - string to be escaped and output, or possibly NULL.*/
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_output_item(FILE *out, char *item)
{
  esc_html_context	 context;

  if ( (item == NULL) || (strcmp(item, "") == 0) )
  {
    /* Do nothing.  There is no text to output */
  }
  else
  {
    context = NULL;
    while (escape_html_mem_to_file (item, out, 1, &context) == 0);
  }
}


/************************************************************************/
/* readmsg_output_attachments                                           */
/*                                                                      */
/* Function is called once the read screen has been built to such as    */
/* stage as it is time to output the body text and/or attachments.      */
/*                                                                      */
/* Parameters: out - pointer to output file.                            */
/*             msg - MessageDescriptor containing pointer to attachments*/
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_output_attachments(FILE *out, MessageDescriptor *msg)
{
  uint32			 num_entities = 0;
  uint32			 counter = 0;
  EntityDescriptor	*ptr;

  num_entities = readmsg_count_entities(msg->entity_list);

  dprintf(("UI", "readmsg_output_attachments entered for message %d with %d attachments\n",
           msg->ID, num_entities));

  if (msg->entity_list == NULL)
  {
    dprintf(("UI", "ERROR: No attachments in message %d\n", msg->ID));
  }
  else
  {
    ptr = msg->entity_list;

    while (ptr)
    {
      counter++;

      if (readmsg_validate_attachment(out, counter, ptr->typestr, ptr->flags) == true)
      {
        /* Readable Attachment, so output the Format start tag, the attachment and then the
         * Format Stop tag.
         */
        if (readmsg_output_attachment(out, ptr->fname) == false)
        {
          /* An unexpected error occured such as not enough space in CacheFS or missing file etc */
          fprintf(out, "%s%s\n", nb_messagetrans_lookup(message_block, "READMSG_No_Att"),
                  HTML_LineFeed);
        }
      }
      ptr = ptr->next;
    }

  }
}


/************************************************************************/
/* readmsg_validate_attachment                                          */
/*                                                                      */
/* Function checks to see what attachment type we have and returns TRUE */
/* if it is a displayable attachment.  It also outputs the appropriate  */
/* attachment headings.                                                 */
/*                                                                      */
/* Parameters: out     - file pointer.                                  */
/*             att_num - attachment number.                             */
/*             mime    - the MIME type of the attachment.               */
/*             type    - flags word of EntityDescriptor.                */
/*                                                                      */
/* Returns: true (readable attachment), false (non-readable attachment).*/
/*                                                                      */
/************************************************************************/
uint32 readmsg_validate_attachment(FILE *out, uint32 att_num, char *mime, uint32 type)
{
  char		*output_line;
  char		*token;
  int		 len;
  bool		 rc = false;

  /* Output attachment splitter, then attachment title, and finally attachment */
  fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_Att_Split"));

  len = nb_messagetrans_token_length(message_block, "READMSG_Att_Title");

  if ( ((output_line= malloc(len + strlen(mime) +
         nb_messagetrans_token_length(message_block, "READMSG_Unknown") + 10)) == NULL)		||
       ((token= malloc(len + 5)) == NULL)
     )
  {
    ncmui_error_display(1);
  }
  else
  {
    strcpy(token, nb_messagetrans_lookup(message_block, "READMSG_Att_Title"));

    if ( (mime == NULL) || (strcmp(mime, "") == 0) )
    {
      /* There is no mime type text to output */
      sprintf(output_line, token, att_num, nb_messagetrans_lookup(message_block,"READMSG_Unknown"));
    }
    else
    {
      sprintf(output_line, token, att_num, mime);
    }

    fprintf(out, "%s\n", output_line);
    free(output_line);
  }

  /* Now check to see whether we can display the attachment */
  switch(type)
  {
    case(ENTITY_OK):
    {
      rc = true;
      break;
    }
    case(ENTITY_NOT_OK):
    {
      /* Not a readable attachment */
      fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_No_Read"));
      rc = false;
      break;
    }
    case(ENTITY_BEST):
    {
      /* Display using best guess view */
      fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_Guess_Read"));
      rc = true;
      break;
    }
    default:
    {
      ncmui_error_display(10);
      rc = false;
      break;
    }
  }
  return(rc);
}


/************************************************************************/
/* readmsg_count_entities                                               */
/*                                                                      */
/* When passed an EntityDescriptor this function increments through     */
/* the linked list and counts up the number of entities.                */
/*                                                                      */
/* Parameters: ptr  - pointer to EntityDescriptor linked list.          */
/*                                                                      */
/* Returns:    0 (no entities) or num of entities.                      */
/*                                                                      */
/************************************************************************/
uint32 readmsg_count_entities(EntityDescriptor *ptr)
{
  uint32	 num_entities = 0;

  if (ptr == NULL)
  {
    return(0);
  }
  else
  {
    while (ptr)
    {
      num_entities++;
      ptr = ptr->next;
    }
    return(num_entities);
  }
}


/************************************************************************/
/* readmsg_output_attachment                                            */
/*                                                                      */
/* Function outputs the specified attachment after firstly escaping the */
/* text, and then scanning the text for LineFeed_Email characters, and  */
/* replacing them with LineFeed_HTMLs.                                  */
/*                                                                      */
/* Parameters: out      - pointer to file to output text to.            */
/*             filename - filename of attachment to output.             */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
uint32 readmsg_output_attachment(FILE *out, char *filename)
{
  FILE			*att_fp = NULL;		// File pointer to source attachment file.
  FILE			*escaped_fp = NULL;	// File pointer to file to store escaped HTML in.
  esc_html_context	 context;
  char			 current, previous;

  /* Check for the existance of the Temp file and remove */
  if (nb_file_exists(1, ReadMsg_Temp_File, NULL, NULL) == NULL)
  {
    nb_file_delete(1, ReadMsg_Temp_File, NULL);
  }

/*   if (nb_file_exists(1, filename, NULL, NULL) == NULL) */
/*   { */
/*     dprintf(("UI", "File doesn't exist\n")); */
/*     return(false); */
/*   } */

  /* Open up the source & destination files */
  att_fp = fopen(filename, "r");
  escaped_fp = fopen(ReadMsg_Temp_File, "w+");

  if ( (att_fp == NULL) || (escaped_fp == NULL) )
  {
    dprintf(("UI", "One file didn't open.\n"));

#ifdef DEBUGLIB
    if (att_fp == NULL)
      ncmui_error_display(12);
    if (escaped_fp == NULL)
      ncmui_error_display(13);
      dprintf(("UI", "Escaped file didn't open\n"));
#endif

    return(false);
  }
  else
  {
    dprintf(("UI", "About to escape the HTML\n"));

    /* Escape from att_fp to escaped_fp and close the att_fp file */
    context = NULL;
    while (escape_html_file_to_file (att_fp, escaped_fp, 1, &context) == 0);
    fclose(att_fp);

    /* Go back to the beginning of the Escaped file and begin the parse & output rountine.
     * This is ugly.  To avoid having to wrap everything we are using the <TT> Teletype HTML
     * tag.  Unfortunately this behaves like normal HTML in that all but one space in a sequence
     * is ignored.  Therefore if we detect more than one space in a row it must be replaced with
     * &nbsp; which is defined as HTML_HardSpace.  We must also search for LineFeed characters and
     * replace with <BR> tags.
     */
    rewind(escaped_fp);
    current =  0;
    previous = 0;

    /* Add in the wrapper for the attachment section */
    fprintf(out, "%s", nb_messagetrans_lookup(message_block, "READMSG_Format_Start"));

    do
    {
      current =  getc(escaped_fp);

      /* Check to see if we have retrieved the EOF marker */
      if (!feof(escaped_fp))
      {
        switch(current)
        {
          case(Character_LineFeed):
          {
            fprintf(out, "%s\n", HTML_LineFeed);
            break;
          }
          case(Character_Tab):
          {
            fprintf(out, "%s", HTML_Tab);
            break;
          }
          case(Character_Space):
          {
            if ( (current == Character_Space) && (previous == Character_Space) )
            {
              fprintf(out, "%s", HTML_HardSpace);
              /* We don't want previous to say it is a space in the next iteration of the loop */
              current = 0;
            }
            else
            {
              putc(current, out);
            }
            break;
          }
          default:
          {
            putc(current, out);
            break;
          }
        }
        previous = current;
      }
    }
    while (!feof(escaped_fp));

    /* Add the formatter terminator */
    fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_Format_Stop"));

    /* Close escaped file, Tidy up other files in use */
    fclose(escaped_fp);
    nb_file_delete(1, ReadMsg_Temp_File, NULL);

    /* Delete the entity file */
    nb_file_unlock(1, filename, NULL);
    nb_file_delete(1, filename, NULL);

    return(true);
  }
}

