/************************************************************************/
/* File:    ReadMsg.c                                                   */
/* Purpose: Code relating to displaying an email message, including     */
/*          attachments on the screen using HTML.                       */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Mon 28th September 1998                               */
/*                Created.                                              */
/************************************************************************/


#include "../Build/Env.h"		/* Include Build Environment file.  This MUST be 1st before
					   any other preprocessor command */

/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "WebMail.h"
#include "ReadMsg.h"
#include "Inbox.h"
#include "EscapeHTML.h"
#include "PopUp.h"
#include "Reply.h"
#include "ForwardMsg.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

#define READMSG_ENTITY_RFC822	ENTITY_OK + ENTITY_RFC822

#ifdef READMSG_IMAGES
  #define READMSG_ENTITY_IMAGE	2
  #define READMSG_ENTITY_AUDIO	3
  #define READMSG_MIME_IMAGE	"image/"
  #define READMSG_IMAGE_HTML	"<CENTER><IMG src=\"file:/%s\"></CENTER>"
  #define READMSG_MIME_AUDIO	"audio/"
  #define READMSG_AUDIO_HTML	"<CENTER><FORM METHOD=\"GET\" ACTION=\"file:/%s\"><INPUT TYPE=SUBMIT VALUE=\" \" BORDERIMAGE=\"icontype:play\" SELIMAGE=\"icontype:play?\" WIDTH=86 HEIGHT=50></FORM> </CENTER>\n"
#endif



static bool readmsg_rfc822_fix_null(char **);

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

/* This is used to pass around MessageIds in the case of Delete messages. */
char	*readmsg_id_ptr = NULL;

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* readmsg_message_received                                             */
/*                                                                      */
/* Function is called when the library receives an ncmail: message from */
/* the Read Message screen.                                             */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
bool readmsg_message_received(int num_args, url_param *  arg)
{
  int32		 counter = -1;
  bool		 found = false;

  dprintf(("UI_0", "readmsg_message_received entered\n"));

  /* Check to see if the UI is locked */
  if (status.ui_locked == false)
  {
    /* Now lock the UI to prevent clicks until whatever item is selected is unlocked */
    status.ui_locked = true;

    do
    {
      counter++;
      dprintf(("UI_0", "Name:  %s\n", arg[counter].name));
      dprintf(("UI_0", "Value: %s\n", arg[counter].value));
       /* Inbox Button */
      if (nb_case_insensitive_strcmp(arg[counter].value, ReadMsg_Button_Inbox) == 0)
      {
        readmsg_inbox_selected();
        found = true;
      }
      /* Reply Button */
      else if (nb_case_insensitive_strcmp(arg[counter].value, ReadMsg_Button_Reply) == 0)
      {
        readmsg_reply_selected(num_args, arg);
        found = true;
      }
      /* Forward Button */
      else if (nb_case_insensitive_strcmp(arg[counter].value, ReadMsg_Button_Forward) == 0)
      {
        readmsg_forward_selected(num_args, arg);
        found = true;
      }
      /* Delete Button */
      else if (nb_case_insensitive_strcmp(arg[counter].value, ReadMsg_Button_Delete) == 0)
      {
        readmsg_delete_selected(num_args, arg);
        found = true;
      }
    }
    while ( (found == false) && (counter < num_args) );

    if (found == false)
    {
      error_report(ERROR_UnknownButton,
                   nb_messagetrans_lookup(config_block, "ERROR_UnknownButton"));
      status.ui_locked = false;
    }
  }
  return(true);
}


/************************************************************************/
/* readmsg_inbox_selected                                               */
/*                                                                      */
/* Function is called when the user clicks on the Inbox button in the   */
/* Read Message screen.                                                 */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_inbox_selected(void)
{
  dprintf(("UI_0", "INBOX SELECTED\n"));

  /* Unlocking of the UI occurs within inbox_build_screen() */
  inbox_build_screen();
}


/************************************************************************/
/* readmsg_reply_selected                                               */
/*                                                                      */
/* Function is called when the user clicks on the Reply button in the   */
/* Read Message screen.                                                 */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_reply_selected(int num_args, url_param *  arg)
{
  int		 counter;
  uint32	 msg;

  dprintf(("UI_0", "REPLY SELECTED "));

  for (counter = 0; counter < num_args; counter++)
  {
    if (nb_case_insensitive_strcmp(arg[counter].name, Template_Tag_ID) == 0)
    {
      dprintf(("UI_0", "on message: %s\n", arg[counter].value));
      msg = atoi(arg[counter].value);
      reply_selected_from_readmsg(msg);
    }
  }

  /* ## This should be removed when reply is completed */
  status.ui_locked = false;
}


/************************************************************************/
/* readmsg_delete_selected                                              */
/*                                                                      */
/* Function is called when the user clicks on the Delete button in the  */
/* Read Message screen.                                                 */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_delete_selected(int num_args, url_param *  arg)
{
  int		 counter;
  int		 found = 0;

  for (counter = 0; counter < num_args; counter++)
  {
    if (nb_case_insensitive_strcmp(arg[counter].name, Template_Tag_ID) == 0)
    {
      found = counter;
    }
  }

  /* This malloc is free'd in the readmsg_delete_cbf function */
  if ((readmsg_id_ptr = malloc(strlen(arg[found].value) + 2)) == NULL)
  {
    error_report(ERROR_NoMem,
                 nb_messagetrans_lookup(config_block, "ERROR_NoMem"));
  }
  else
  {
    strcpy(readmsg_id_ptr, arg[found].value);

    dprintf(("UI_0", "malloc'd into msg_id_ptr as:       %s\n", readmsg_id_ptr));

    popup_2_open_dialogue( nb_messagetrans_lookup(message_block, "READMSG_Delete"),
                           nb_messagetrans_lookup(message_block, "BUTTON_Yes"),
                           nb_messagetrans_lookup(message_block, "BUTTON_No"),
                           readmsg_delete_cbf,
                           (void *) readmsg_id_ptr );
  }
}


/************************************************************************/
/* readmsg_delete_cbf                                                   */
/*                                                                      */
/* Function is called when the user clicks on either of the buttons on  */
/* the Popup dialogue.                                                  */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void readmsg_delete_cbf(bool default_sel, void *handle)
{
  uint32 id;
  uint32	*item;
  eng_rcode	 rc;

//  dprintf(("UI_0", "readmsg_delete_cbf entered with handle of: %d\n", (uint32) handle));

  /* For now keep this in until really sending is implemented. */
  status.ui_locked = false;

  /* User selected Delete */
  if (default_sel == true)
  {
    id = atoi( (char *)handle );

    dprintf(("UI_0", "DELETE SELECTED on message: %d\n", id));
    dprintf(("UI_0", "Mode is %d:\n", status.state));

    /* Delete Message */
    /* DO NOT FREE THIS MALLOC.  It is free'd by the engine. */
    if ((item = (uint32 *) malloc(sizeof(uint32))) == NULL)
    {
      error_report(ERROR_NoMem,
                   nb_messagetrans_lookup(config_block, "ERROR_NoMem"));
    }
    else
    {
      status.state = State_ReadMsg_Delete;
      item[0] = id;
      dprintf(("UI_0", "DELETE SELECTED on item: %d\n", item[0]));

      /* No need to mark for deletion here because eng_mark_for_deletion() calls the UI upate
       * cbf.
       */
      rc = eng_mark_for_deletion(1, item);
      if ( (rc != ENG_COMPLETED) && (rc != ENG_RUNNING) )
      {
        error_report(ERROR_MarkDelFail,
                     nb_messagetrans_lookup(config_block, "ERROR_MarkDelFail"));
      }
      popup_close_dialogue();
    }
  }
  else
  {
    /* User wants to continue.  So just close the PopUp. */
    popup_close_dialogue();
  }

  /* Free the message id global pointer */
  free(readmsg_id_ptr);
  readmsg_id_ptr = NULL;
}


/************************************************************************/
/* readmsg_forward_selected                                             */
/*                                                                      */
/* Function is called when the user clicks on the Forward button in the */
/* Read Message screen.                                                 */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_forward_selected(int num_args, url_param *  arg)
{
  uint32	 id = 0;
  uint32	*item = NULL;
  int		 counter = 0;
  int		 found = 0;

  for (counter = 0; counter < num_args; counter++)
  {
    if (nb_case_insensitive_strcmp(arg[counter].name, Template_Tag_ID) == 0)
    {
      found = counter;
    }
  }

  if (found == true)
  {
    id = atoi(arg[found].value);
    /* Forward Message */
    /* DO NOT FREE THIS MALLOC.  It is free'd by the engine. */
    if ((item = (uint32 *) malloc(sizeof(uint32))) == NULL)
    {
      error_report(ERROR_NoMem,
                   nb_messagetrans_lookup(config_block, "ERROR_NoMem"));
    }
    else
    {
      item[0] = id;
      dprintf(("UI_0", "FORWARD SELECTED on item: %d\n", item[0]));

      forwardmsg_forward_request(item, 1, readmsg_forward_cbf, (void *) id);
    }
  }
}


/************************************************************************/
/* readmsg_forward_cbf                                                  */
/*                                                                      */
/* Function is called by the Forward code when the forward operation    */
/* has completed.  We can then call readmsg_build_screen with the       */
/* contents of handle as the messageid.                                 */
/*                                                                      */
/* Parameters: handle - should contain a valid message id.              */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_forward_cbf(void *handle)
{
  readmsg_build_screen( (uint32) handle);
}


/************************************************************************/
/* readmsg_inbox_message_selected                                       */
/*                                                                      */
/* Function is called by the Inbox code when the user clicks on a       */
/* message link.                                                        */
/*                                                                      */
/* Parameters: num_args - number of items in arg.                       */
/*             arg      - data embedded in the HTML.                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_inbox_message_selected(uint32 num_args, url_param *arg)
{
  int		 counter;
  uint32	 id = 0;

  dprintf(("UI_0", "readmsg_message_selected entered\n"));

  dprintf(("UI_0", "READ SELECTED "));

  for (counter = 0; counter < num_args; counter++)
  {
    if (nb_case_insensitive_strcmp(arg[counter].name, Template_Tag_ID) == 0)
    {
      dprintf(("UI_0", "on message: %s\n", arg[counter].value));

      id = atoi(arg[counter].value);

      readmsg_build_screen(id);
    }
/*     else */
/*     { */
/*       error_report(ERROR_InboxReadFail, */
/*                    nb_messagetrans_lookup(config_block, "ERROR_InboxReadFail")); */
/*     } */
  }
}



/* ============================================================================================== */
/* ===================================== PAGE BUILDING CODE ===================================== */
/* ============================================================================================== */


/************************************************************************/
/* readmsg_build_screen                                                 */
/*                                                                      */
/* Function is called when the ReadMsg screen has to be displayed.  Any */
/* old pages must be deleted, the root page copied from ResourceFS & the*/
/* header & listing pages generated.                                    */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_build_screen(uint32 msg_id)
{
  eng_rcode		 rc;

  dprintf(("UI_0", "*******************************************************\n"));
  dprintf(("UI_0", "Read message %d request come in.\n", msg_id));

  ncmui_tidy_output_dir();
  rc = eng_get_message(msg_id, NULL, ncmui_get_message_cbf);

  switch(rc)
  {
    case(ENG_UNKNOWNID):
    case(ENG_UNPROCESSED):
    {
      popup_1_open_dialogue( nb_messagetrans_lookup(message_block, "READMSG_GetMsgFail"),
                             nb_messagetrans_lookup(message_block, "BUTTON_OK"),
                             readmsg_getmsgfail_cbf,
                             NULL );
      error_report(ERROR_EngGetMsgFail,
                   nb_messagetrans_lookup(config_block, "ERROR_EngGetMsgFail"));
      break;
    }
    case(ENG_PROCESSING):
    case(ENG_FETCHINGMESSAGE):
    {
      popup_1_open_dialogue( nb_messagetrans_lookup(message_block,
                           (rc == ENG_FETCHINGMESSAGE) ? "READMSG_GetMsgFetch" : "READMSG_Process"),
                             nb_messagetrans_lookup(message_block, "BUTTON_OK"),
                             readmsg_getmsgfail_cbf,
                             NULL );
      error_report(ERROR_EngGetMsgFail,
                   nb_messagetrans_lookup(config_block, "ERROR_EngGetMsgFail"));
      break;
    }
    case(ENG_RUNNING):
    {
      /* Put up the hourglass until the callback comes back */
      feedback_on();
      break;
    }
    default:
    {
      error_report(ERROR_EngineUnexpectedError,
                   nb_messagetrans_lookup(config_block, "ERROR_EngineUnexpectedError"));
    }
  }
  dprintf(("UI_0", "*******************************************************\n"));
}


/************************************************************************/
/* ncmui_get_message_cbf                                                */
/*                                                                      */
/* Function is called by the Engine once it has retrieved the requested */
/* message.  Must then build the HTML pages.                            */
/*                                                                      */
/* Parameters: eng_cbf_getmsg params.                                   */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void ncmui_get_message_cbf(eng_return *codes, MessageDescriptor *msg, void *handle)
{
  NB_UNUSED(handle);

  dprintf(("UI_0", "Eng rc: %d\n", codes->code));

  /* Turn off the feedback (hourglass) */
  feedback_off();

  switch(codes->code)
  {
    case(ENG_GETMSGFAILED):
    case(ENG_NOMEMORY):
    {
      popup_1_open_dialogue( nb_messagetrans_lookup(message_block, "READMSG_GetMsgFail"),
                             nb_messagetrans_lookup(message_block, "BUTTON_OK"),
                             readmsg_getmsgfail_cbf,
                             NULL );
      break;
    }
    case(ENG_CONNECTCANCELLED):
    {
      inbox_build_screen();
      break;
    }
    default:
    {
      ncmui_get_message_cbf_success(codes, msg);
    }
  }
}

/************************************************************************/
/* ncmui_get_message_cbf_success                                        */
/*                                                                      */
/* Function is called when ncmui_get_message_cbf() returns a message.   */
/*                                                                      */
/* Parameters: engine return code.                                      */
/*             messagedescritpor.                                       */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void ncmui_get_message_cbf_success(eng_return *codes, MessageDescriptor *msg)
{
  eng_rcode	er;
  bool		rc1 = true, rc2 = true;

  NB_UNUSED(codes);

  dprintf(("UI_0", "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n"));
  dprintf(("UI_0", "Got message %d back from engine\n", msg->ID));
  dprintf(("UI_0", "From:    %s\n", msg->fromreal));
  dprintf(("UI_0", "Address: %s\n", msg->fromaddr));
  dprintf(("UI_0", "Subject: %s\n", msg->subject));

  /* Parse Inbox Listing file and build proper screen */
  feedback_on();
  rc1 = parser_parse_file(PageType_ReadMsg,Template_ReadMsg_Header,Generated_ReadMsg_Header,
                        (void *) msg);
  rc2 = parser_parse_file(PageType_ReadMsg, Template_ReadMsg_Body, Generated_ReadMsg_Body,
                          (void *) msg);
  feedback_off();

  if ( (rc1 == false) || (rc2 == false) )
  {
    /* *** FATAL ERROR *** */
    error_parser_failed();
    error_report(ERROR_ReadMsgParserFail,
                 nb_messagetrans_lookup(config_block, "ERROR_ReadMsgParserFail"));
  }
  else
  {
    browserif_sendurl(Open_ReadMsg, false);
    status.state = State_ReadMsg;

    /* Update the state of the message to read */
    er = eng_mark_as_read(msg->ID);
    if ( (er != ENG_COMPLETED) && (er != ENG_RUNNING) )
      error_report(ERROR_EngMarkReadFail,
                   nb_messagetrans_lookup(config_block, "ERROR_EngMarkReadFail"));
  }

  /* Unlock the UI */
  status.ui_locked = false;

  dprintf(("UI_0", "FINISHED BUILDING READMSG PAGE\n"));
  dprintf(("UI_0", "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n"));
}


/************************************************************************/
/* readmsg_getmsgfail_cbf                                               */
/*                                                                      */
/* Function is called when the engine returns ENG_GETMSGFAILED in the   */
/* callback for eng_get_message().  Must redisplay the inbox.           */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void readmsg_getmsgfail_cbf(bool sel, void *handle)
{
  NB_UNUSED(sel);
  NB_UNUSED(handle);

  popup_close_dialogue();
  inbox_build_screen();
}


/************************************************************************/
/* readmsg_active_comment_found                                         */
/*                                                                      */
/* Function is called when the UI page type is Read & an active comment */
/* is found in the web page being parsed.                               */
/*                                                                      */
/* Parameters: comment - The comment found by parser_parse_file().      */
/*             out     - FILE pointer to output file.                   */
/*             msg     - MessageDescriptor for message being output.    */
/*                       This is passed to parser_parse_file when read  */
/*                       is clicked on and passed back when an AC is    */
/*                       found.                                         */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_active_comment_found(char *comment, FILE *out, MessageDescriptor *msg)
{
  if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_MsgID) == 0)
  {
    fprintf(out, "%d", msg->ID);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_Charset) == 0)
  {
    fprintf(out, msg->charset);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_Date) == 0)
  {
    readmsg_output_item(out, msg->datestr);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_From) == 0)
  {
    if (nb_string_empty(msg->fromreal) == TRUE)
    {
      readmsg_output_item(out, msg->fromaddr);
    }
    else
    {
      /* Output <real name> <space> <angel_bracket><email address><angel_bracket> */
      readmsg_output_item(out, msg->fromreal);
      fprintf(out, " %s", HTML_AngleBracket_Left);
      readmsg_output_item(out, msg->fromaddr);
      fprintf(out, "%s", HTML_AngleBracket_Right);
    }
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_To) == 0)
  {
    readmsg_output_item(out, msg->to);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_CC) == 0)
  {
    readmsg_output_item(out, msg->cc);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_Subject) == 0)
  {
    readmsg_output_item(out, msg->subject);
  }
  else if (nb_case_insensitive_strcmp(comment, ReadMsg_AC_Body) == 0)
  {
    readmsg_output_attachments(out, msg);
  }
  /* Not a known tag */
  else
  {
    error_report(ERROR_ReadMsgUnknownAC,
                 nb_messagetrans_lookup(config_block, "ERROR_ReadMsgUnknownAC"));
#ifdef DEBUGLIB
    fprintf(out, "<H1>Unknown tag '%s' received</H1><BR>\n", comment);
#endif
  }
}


/************************************************************************/
/* readmsg_output_item                                                  */
/*                                                                      */
/* Function is called by readmsg_active_comment_found() to output a     */
/* string, escaping it first.  A check is made to ensure that there is  */
/* valid data in the string first.                                      */
/*                                                                      */
/* Parameters: out  - pointer to output file.                           */
/*             item - string to be escaped and output, or possibly NULL.*/
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_output_item(FILE *out, char *item)
{
  esc_html_context	 context;

  if (nb_string_empty(item) == FALSE)
  {
    context = NULL;
    while (escape_html_mem_to_file (item, out, 1, &context) == 0);
  }
}


/************************************************************************/
/* readmsg_output_attachments                                           */
/*                                                                      */
/* Function is called once the read screen has been built to such as    */
/* stage as it is time to output the body text and/or attachments.      */
/*                                                                      */
/* Parameters: out - pointer to output file.                            */
/*             msg - MessageDescriptor containing pointer to attachments*/
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void readmsg_output_attachments(FILE *out, MessageDescriptor *msg)
{
  uint32			 num_entities = 0;
  uint32			 counter = 0;
  EntityDescriptor		*ptr;
  bool				 rc = false;
  uint32			 valid = false;

  num_entities = readmsg_count_entities(msg->entity_list);

  dprintf(("UI_0", "readmsg_output_attachments entered for message %d with %d attachments\n",
           msg->ID, num_entities));

  if (msg->entity_list == NULL)
  {
    dprintf(("UI_0", "ERROR: No attachments in message %d\n", msg->ID));
    num_entities = 0;
  }
  else
  {
    ptr = msg->entity_list;

    while (ptr)
    {
      counter++;

      valid = readmsg_validate_attachment(out, counter, num_entities, ptr->typestr, ptr->flags);

      if (valid == true)
      {
        /* Readable Attachment */
        if (ptr->flags == READMSG_ENTITY_RFC822)
        {
          rc = readmsg_output_rfc822(out, ptr);
        }
        else
        {
          /* Normal message, so output the Format start tag, the attachment and then the
           * Format Stop tag.
           */
          rc = readmsg_output_attachment(out, ptr->data.fname);
        }
        /* Check to see that the attachment was output correctly */
        if (rc == false)
        {
          fprintf(out, "%s%s\n", nb_messagetrans_lookup(message_block, "READMSG_No_Att"),
                  HTML_LineFeed);
        }
      }
#ifdef READMSG_IMAGES
      else if (valid == READMSG_ENTITY_IMAGE)
      {
        readmsg_output_image(out, ptr->data.fname);
      }
      else if (valid == READMSG_ENTITY_AUDIO)
      {
        readmsg_output_audio(out, ptr->data.fname);
      }
#endif
      ptr = ptr->next;
    }

  }
}


/************************************************************************/
/* readmsg_validate_attachment                                          */
/*                                                                      */
/* Function checks to see what attachment type we have and returns TRUE */
/* if it is a displayable attachment.  It also outputs the appropriate  */
/* attachment headings.                                                 */
/*                                                                      */
/* Parameters: out     - file pointer.                                  */
/*             att_num - attachment number.                             */
/*             atts    - number of attachments.                         */
/*             mime    - the MIME type of the attachment.               */
/*             type    - flags word of EntityDescriptor.                */
/*                                                                      */
/* Returns: true (readable attachment), false (non-readable attachment).*/
/*                                                                      */
/************************************************************************/
uint32 readmsg_validate_attachment(FILE *out, uint32 att_num, uint32 atts, char *mime, uint32 type)
{
  char		*output_line = NULL;
  char		*token = NULL;
  int		 len;
  uint32	 rc = false;
#ifdef READMSG_ANCHORS
  int		 anchor_len;
  char		*anchor = NULL;
  char		*anchor_token = NULL;
#endif

  /* Output attachment splitter, then attachment title, and finally attachment */
  fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_Att_Split"));

  len = nb_messagetrans_token_length(message_block, "READMSG_Att_Title");

#ifdef READMSG_ANCHORS
  anchor_len = nb_messagetrans_token_length(message_block, "READMSG_Anchor");
#endif

  if ( ((output_line= malloc(len + strlen(mime) +
         nb_messagetrans_token_length(message_block, "READMSG_Unknown") + 20)) == NULL)		||
       ((token= malloc(len + 5)) == NULL)
#ifdef READMSG_ANCHORS
       || ((anchor = malloc(anchor_len + 25)) == NULL)
#endif
     )
  {
    error_report(ERROR_NoMem,
                 nb_messagetrans_lookup(config_block, "ERROR_NoMem"));
  }
  else
  {
    strcpy(token, nb_messagetrans_lookup(message_block, "READMSG_Att_Title"));
#ifdef READMSG_ANCHORS
    nb_strcpy_malloc(&anchor_token, nb_messagetrans_lookup(message_block, "READMSG_Anchor"));
    sprintf(anchor, anchor_token, att_num);
    fprintf(out, anchor);
#endif

    if (nb_string_empty(mime) == TRUE)
    {
      /* There is no mime type text to output */
      sprintf(output_line, token, att_num, atts,
              nb_messagetrans_lookup(message_block,"READMSG_Unknown"));
    }
    else
    {
      sprintf(output_line, token, att_num, atts, mime);
    }

    fprintf(out, "%s\n", output_line);
    free(output_line);
    output_line = 0;
    free(token);
    token = 0;
#ifdef READMSG_ANCHORS
    readmsg_output_anchor_link(out, att_num, atts);
    free(anchor);
    free(anchor_token);
#endif
  }

  /* Now check to see whether we can display the attachment */
  dprintf(("UI_0", "Entity Flags: %d\n", type));
  switch(type)
  {
    case(ENTITY_OK):
    case(READMSG_ENTITY_RFC822):
    {
      rc = true;
      break;
    }
    case(ENTITY_NOT_OK):
    {
#ifdef READMSG_IMAGES
      if (nb_case_insensitive_strncmp(mime, READMSG_MIME_IMAGE, 6) == 0)
      {
        rc = READMSG_ENTITY_IMAGE;
      }
      else if (nb_case_insensitive_strncmp(mime, READMSG_MIME_AUDIO, 6) == 0)
      {
        rc = READMSG_ENTITY_AUDIO;
      }
      else
      {
        fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_No_Read"));
        rc = false;
      }
#else
      /* Not a readable attachment */
      fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_No_Read"));
      rc = false;
#endif
      break;
    }
    case(ENTITY_BEST):
    {
      /* Display using best guess view */
      fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_Guess_Read"));
      rc = true;
      break;
    }
    case(ENTITY_INCOMPLETE):
    {
      fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_Incomplete"));
      rc = true;
      break;
    }
    default:
    {
      error_report(ERROR_UnknownEntityFlags,
                   nb_messagetrans_lookup(config_block, "ERROR_UnknownEntityFlags"));
      rc = false;
      break;
    }
  }
  return(rc);
}


/************************************************************************/
/* readmsg_count_entities                                               */
/*                                                                      */
/* When passed an EntityDescriptor this function increments through     */
/* the linked list and counts up the number of entities.                */
/*                                                                      */
/* Parameters: ptr  - pointer to EntityDescriptor linked list.          */
/*                                                                      */
/* Returns:    0 (no entities) or num of entities.                      */
/*                                                                      */
/************************************************************************/
uint32 readmsg_count_entities(EntityDescriptor *ptr)
{
  uint32	 num_entities = 0;

  if (ptr == NULL)
  {
    return(0);
  }
  else
  {
    while (ptr)
    {
      num_entities++;
      ptr = ptr->next;
    }
    return(num_entities);
  }
}


/************************************************************************/
/* readmsg_output_attachment                                            */
/*                                                                      */
/* Function outputs the specified attachment after firstly escaping the */
/* text, and then scanning the text for LineFeed_Email characters, and  */
/* replacing them with LineFeed_HTMLs.                                  */
/*                                                                      */
/* Parameters: out      - pointer to file to output text to.            */
/*             filename - filename of attachment to output.             */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
bool readmsg_output_attachment(FILE *out, char *filename)
{
  FILE			*att_fp = NULL;		// File pointer to source attachment file.
  FILE			*escaped_fp = NULL;	// File pointer to file to store escaped HTML in.
  esc_html_context	 context;
  char			 current, previous;

  /* Check for the existance of the Temp file and remove */
  if (nb_file_exists(1, ReadMsg_Temp_File, NULL, NULL) == NULL)
  {
    nb_file_delete(1, ReadMsg_Temp_File, NULL);
  }

/*   if (nb_file_exists(1, filename, NULL, NULL) == NULL) */
/*   { */
/*     dprintf(("UI_0", "File doesn't exist\n")); */
/*     return(false); */
/*   } */

  /* Open up the source & destination files */
  att_fp = fopen(filename, "r");
  escaped_fp = fopen(ReadMsg_Temp_File, "w+");

  if ( (att_fp == NULL) || (escaped_fp == NULL) )
  {
    dprintf(("UI_0", "One file didn't open.\n"));

#ifdef DEBUGLIB
    if (att_fp == NULL)
      error_report(ERROR_AttachmentNoOpen,
                   nb_messagetrans_lookup(config_block, "ERROR_AttachmentNoOpen"));
    if (escaped_fp == NULL)
      error_report(ERROR_EscapedFileNoOpen,
                   nb_messagetrans_lookup(config_block, "ERROR_EscapedFileNoOpen"));
      dprintf(("UI_0", "Escaped file didn't open\n"));
#endif

    return(false);
  }
  else
  {
    dprintf(("UI_0", "About to escape the HTML\n"));

    /* Escape from att_fp to escaped_fp and close the att_fp file */
    context = NULL;
    while (escape_html_file_to_file (att_fp, escaped_fp, 1, &context) == 0);
    fclose(att_fp);

    /* Go back to the beginning of the Escaped file and begin the parse & output rountine.
     * This is ugly.  To avoid having to wrap everything we are using the <TT> Teletype HTML
     * tag.  Unfortunately this behaves like normal HTML in that all but one space in a sequence
     * is ignored.  Therefore if we detect more than one space in a row it must be replaced with
     * &nbsp; which is defined as HTML_HardSpace.  We must also search for LineFeed characters and
     * replace with <BR> tags.
     */
    rewind(escaped_fp);
    current =  0;
    previous = 0;

    /* Add in the wrapper for the attachment section */
    fprintf(out, "%s", nb_messagetrans_lookup(message_block, "READMSG_Format_Start"));

    do
    {
      current =  fgetc(escaped_fp);

      /* Check to see if we have retrieved the EOF marker */
      if (!feof(escaped_fp))
      {
        switch(current)
        {
          case(Character_LineFeed):
          {
            fprintf(out, "%s\n", HTML_LineFeed);
            break;
          }
          case(Character_Tab):
          {
            fprintf(out, "%s", HTML_Tab);
            break;
          }
          case(Character_Space):
          {
            if ( ((current == Character_Space) && (previous == Character_Space))	||
                 ((current == Character_Space) && (previous == Character_LineFeed)) )
            {
              fprintf(out, "%s", HTML_HardSpace);
              /* We don't want previous to say it is a space in the next iteration of the loop */
              current = 0;
            }
            else
            {
              fputc(current, out);
            }
            break;
          }
          default:
          {
            fputc(current, out);
            break;
          }
        }
        previous = current;
      }
    }
    while (!feof(escaped_fp));

    /* Add the formatter terminator */
    fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_Format_Stop"));

    /* Close escaped file, Tidy up other files in use */
    fclose(escaped_fp);
    nb_file_delete(1, ReadMsg_Temp_File, NULL);

    /* Delete the entity file */
    nb_file_unlock(1, filename, NULL);
    nb_file_delete(1, filename, NULL);

    return(true);
  }
}


/************************************************************************/
/* readmsg_rfc822_build_from                                            */
/*                                                                      */
/* Function builds the from text in the format:                         */
/*   <real name> <space> <angle_bracket> <email address> <angle_bracket>*/
/*                                                                      */
/* Parameters: msg   - message descriptor to get data from.             */
/*             from  - pointer for where to store string.               */
/*                                                                      */
/* Returns:    from text as pointer.                                    */
/*                                                                      */
/************************************************************************/
bool readmsg_rfc822_build_from(MessageDescriptor *msg, char **from)
{
  char			*temp = NULL;
  char			*ptr = NULL;		/* DO NOT FREE */
  int32			 temp_len = 0, ptr_len = 0;
  int			 rc = 0;
  esc_html_context	 context;

  temp_len = strlen(msg->fromreal) + strlen(msg->fromaddr) + 10;
  ptr_len = (temp_len * 6) + 5;

  if ( ((temp = malloc(temp_len)) == NULL) ||
       ((ptr =  malloc(ptr_len)) == NULL) )
  {
    error_report(ERROR_NoMem,
                 nb_messagetrans_lookup(config_block, "ERROR_NoMem"));
    return(false);
  }
  else
  {
    if (nb_string_empty(msg->fromreal) == TRUE)
    {
      /* Real name missing */
      sprintf(temp, "%s", msg->fromaddr);
    }
    else
    {
      /* Both filled in */
      sprintf(temp, "%s <%s>", msg->fromreal, msg->fromaddr);
    }
    /* OK, now escape the text */
    context = NULL;
    while (rc = escape_html_mem_to_mem (temp, ptr, ptr_len, 1, &context), rc == 0);

    *from = ptr;
    free(temp);
    return(true);
  }
}


/************************************************************************/
/* readmsg_rfc822_fix_null                                              */
/*                                                                      */
/* Function is called if any of the parameters to be ouput as part of   */
/* the sprintfs in this code are NULL pointers as this outputs crap.    */
/* This function simply mallocs a few bytes and stores a \0 character   */
/*                                                                      */
/* Parameters: str  - string to be modified.                            */
/*                                                                      */
/* Returns:    true or false.                                           */
/*                                                                      */
/************************************************************************/
bool readmsg_rfc822_fix_null(char **str)
{
  char	*ptr = NULL;

  if ((ptr = malloc(2)) == NULL)
  {
    error_report(ERROR_NoMem,
                 nb_messagetrans_lookup(config_block, "ERROR_NoMem"));
    dprintf(("UI_0", "ERROR: Not enough memory to create inbox listing.\n"));
    return(false);
  }
  else
  {
    ptr[0] = '\0';
    *str = ptr;
    return(true);
  }
}


/************************************************************************/
/* readmsg_rfc822_output_headers                                        */
/*                                                                      */
/* Function outputs the To, From, CC and Subject details from the       */
/* supplied RFC822 message.                                             */
/*                                                                      */
/* Parameters: out  - file pointer                                      */
/*             msg  - MessageDescriptor to display.                     */
/*             html - HTML template to use.                             */
/*                                                                      */
/* Returns:    bool                                                     */
/*                                                                      */
/************************************************************************/
bool readmsg_rfc822_output_headers(FILE *out, MessageDescriptor *msg, char *html)
{
  char			*output_line = NULL;
  char			*from = NULL;
  char			*subject = NULL;
  char			*to = NULL;
  char			*cc = NULL;
  char			*date = NULL;
  bool			 er = true;

  dprintf(("UI_0", "readmsg_rfc822_output_headers entered\n"));

  if (msg == NULL)
  {
    dprintf(("UI_0", "NULL MESSAGE POINTER!!!\n"));
    return(false);
  }

  /* SUBJECT TEXT
   * First check to see if the subject text is empty.  If so output INBOX_No_Subject token.
   */
  if (nb_string_empty(msg->subject) == TRUE)
    nb_strcpy_malloc(&subject, nb_messagetrans_lookup(message_block, "INBOX_No_Subject"));
  else
    er = inbox_build_intray_element(msg->subject, &subject, 0);

  /* FROM TEXT
   * First check to see if the fromreal text is empty.  If it is display the email address.
   */
  readmsg_rfc822_build_from(msg, &from);

  /* TO TEXT */
  if (nb_string_empty(msg->to) == TRUE)
    readmsg_rfc822_fix_null(&to);
  else
    er = inbox_build_intray_element(msg->to, &to, 0);

  /* CC TEXT */
  if (nb_string_empty(msg->cc) == TRUE)
    readmsg_rfc822_fix_null(&cc);
  else
    er = inbox_build_intray_element(msg->cc, &cc, 0);

  /* DATE TEXT
   * First check to see if the fromreal text is empty.  If it is display the email address.
   */
  er = inbox_build_intray_element(msg->datestr, &date, 0);

  /*
   * Build HTML
   */
  if ((output_line= malloc(strlen(html) + strlen(from) + strlen(subject) + strlen(date) +
                           strlen(to) + strlen(cc) + 10)) == NULL)
  {
    error_report(ERROR_NoMem,
                 nb_messagetrans_lookup(config_block, "ERROR_NoMem"));
    dprintf(("UI_0", "ERROR: Not enough memory to create inbox listing.\n"));
  }
  else
  {
    /* Output the escaped data plus the message ID in the correct order based on the html
     * fragment from the Messages file
     */
    dprintf(("UI_0", "Done malloc of length: %d\n", (strlen(html) + strlen(from) + strlen(subject) +
             strlen(date) + strlen(to) + strlen(cc) + 10) ));

    sprintf(output_line, html, date,
                               from,
                               subject,
                               to,
                               cc);
    fprintf(out, "%s\n", output_line);

    /* Tidy up */
    if (date != NULL)
      free(date);
    if (from != NULL)
      free(from);
    if (subject != NULL)
      free(subject);
    if (to != NULL)
      free(to);
    if (cc != NULL)
      free(cc);
    free(output_line);
  }
  return(true);
}


/************************************************************************/
/* readmsg_output_rfc822                                                */
/*                                                                      */
/* Function for outputting RFC822 messages.                             */
/*                                                                      */
/* Parameters: out                                                      */
/*             desc - EntityDescriptor for top level message.           */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
bool readmsg_output_rfc822(FILE *out, EntityDescriptor *desc)
{
  bool		rc = false;

  dprintf(("UI_0", "readmsg_output_rfc822() entered\n"));

#ifdef DEBUGLIB
  debug_output_messagedescriptor(desc->data.msg);
#endif

  /* Output RFC822 start marker */
  fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_RFC822Start"));

  /* Output To, From, Subject, Date, CC details. */
  rc = readmsg_rfc822_output_headers(out, desc->data.msg,
                                     nb_messagetrans_lookup(message_block, "READMSG_RFC822Header"));

  if (rc == true)
  {
    /* Indent The Display */
    fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_RFC822Indent"));


    /* *** OUTPUT THE MESSAGE ATTACHMENTS HERE *** */
    readmsg_output_attachments(out, desc->data.msg);
  }
  else
  {
    /* Output a warning that we failed */
    dprintf(("UI_0", "rc was false\n"));
    fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_No_Att"));
  }

  /* Outdent The Display after the last attachment */
  fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_RFC822Outdent"));

  /* Output RFC822 stop marker */
  fprintf(out, "%s\n", nb_messagetrans_lookup(message_block, "READMSG_RFC822Stop"));

  return(true);
}


#ifdef READMSG_IMAGES
  /************************************************************************/
  /* readmsg_output_image                                                 */
  /*                                                                      */
  /* Function outputs the Image tags to display the attached pictures.    */
  /*                                                                      */
  /* Parameters: out  - file pointer.                                     */
  /*             fname- filename of attachment.                           */
  /*                                                                      */
  /* Returns:    void.                                                    */
  /*                                                                      */
  /************************************************************************/
  void readmsg_output_image(FILE *out, char *filename)
  {
    char	*command = NULL;

    dprintf(("UI_0", "Output Image with filename: %s\n", filename));

    if ((command = malloc(strlen(READMSG_IMAGE_HTML) + strlen(filename) + 5)) == NULL)
    {
      error_report(ERROR_NoMem,
                   nb_messagetrans_lookup(config_block, "ERROR_NoMem"));
    }
    else
    {
      sprintf(command, READMSG_IMAGE_HTML, filename);
      fprintf(out, "%s\n\n", command);
      free(command);
    }
  }


  /************************************************************************/
  /* readmsg_output_audio                                                 */
  /*                                                                      */
  /* Function creates a form button in the HTML to play the audio clip.   */
  /*                                                                      */
  /* Parameters: out  - file pointer.                                     */
  /*             fname- filename of attachment.                           */
  /*                                                                      */
  /* Returns:    void.                                                    */
  /*                                                                      */
  /************************************************************************/
  void readmsg_output_audio(FILE *out, char *filename)
  {
    char	*command = NULL;

    dprintf(("UI_0", "Output Audio with filename: %s\n", filename));

    if ((command = malloc(strlen(READMSG_AUDIO_HTML) + strlen(filename) + 5)) == NULL)
    {
      error_report(ERROR_NoMem,
                   nb_messagetrans_lookup(config_block, "ERROR_NoMem"));
    }
    else
    {
      nb_file_set_filetype(1, filename, NULL, 0xfb1);

      sprintf(command, READMSG_AUDIO_HTML, filename);
      fprintf(out, "%s\n\n", command);
      free(command);
    }
  }

#endif


#ifdef READMSG_ANCHORS

  /************************************************************************/
  /* readmsg_output_anchor_link                                           */
  /*                                                                      */
  /* Function outputs the link text beside the MIME type to link to the   */
  /* next or previous attachment.                                         */
  /*                                                                      */
  /* Parameters: out     - file pointer.                                  */
  /*             att_num - attachment number.                             */
  /*             atts    - number of attachments.                         */
  /*                                                                      */
  /* Returns:    void.                                                    */
  /*                                                                      */
  /************************************************************************/
  void readmsg_output_anchor_link(FILE *out, uint32 att_num, uint32 atts)
  {
    char	*token = NULL;
    char	*output = NULL;

    if ((output = malloc(nb_messagetrans_token_length(message_block, "READMSG_PreviousNext")
                         + 20)) == NULL)
    {
      error_report(ERROR_NoMem,
                   nb_messagetrans_lookup(config_block, "ERROR_NoMem"));
    }
    else
    {
      /* OK, now output Next/Previous stuff */
      if ( (att_num == 1) && (atts > 1) )
      {
        /* Output just Next */
        nb_strcpy_malloc(&token, nb_messagetrans_lookup(message_block, "READMSG_Next"));
        sprintf(output, token, (att_num+1));
        fprintf(out, output);
      }
      else if ( (att_num == atts) && (atts == 1) )
      {
        /* Only one attachment - do nothing */
      }
      else if (att_num == atts)
      {
        /* Last attachment */
        nb_strcpy_malloc(&token, nb_messagetrans_lookup(message_block, "READMSG_Previous"));
        sprintf(output, token, (att_num-1));
        fprintf(out, output);
      }
      else
      {
        /* Somewhere in the middle - output Next/Previous */
        nb_strcpy_malloc(&token, nb_messagetrans_lookup(message_block, "READMSG_PreviousNext"));
        sprintf(output, token, (att_num-1), (att_num+1));
        fprintf(out, output);
      }
    }
    if (token != NULL)
      free(token);
    if (output != NULL)
      free(output);
  }

#endif

#ifdef DEBUGLIB

  /************************************************************************/
  /* debug_output_messagedescriptor                                       */
  /*                                                                      */
  /* Function outputs the readable parts of the messagedescriptor.        */
  /*                                                                      */
  /* Parameters: pointer to md.                                           */
  /*                                                                      */
  /* Returns:    void.                                                    */
  /*                                                                      */
  /************************************************************************/
  void debug_output_messagedescriptor(MessageDescriptor *msg)
  {
    dprintf(("UI_0", "---------------------------------------------------------------\n"));
    dprintf(("UI_0", "Message: %d with flags %d\n", msg->ID, msg->flags));
    dprintf(("UI_0", "Number of forwards: %d, number of attachments %d\n", msg->forward_num,
             msg->entity_num));

//  if (msg != NULL)
  {
//    if (msg->to != NULL)
      dprintf(("UI_0", "To:      %s\n", msg->to));
    if (nb_string_empty(msg->cc) == FALSE)
      dprintf(("UI_0", "CC:      %s\n", msg->cc));
    if (nb_string_empty(msg->fromreal) == FALSE)
      dprintf(("UI_0", "From:    %s\n", msg->fromreal));
    if (nb_string_empty(msg->fromaddr) == FALSE)
      dprintf(("UI_0", "         %s\n", msg->fromaddr));
    if (nb_string_empty(msg->subject) == FALSE)
      dprintf(("UI_0", "Subject: %s\n", msg->subject));
    if (nb_string_empty(msg->charset) == FALSE)
      dprintf(("UI_0", "Charset: %s\n", msg->charset));
    if (nb_string_empty(msg->datestr) == FALSE)
      dprintf(("UI_0", "Date:    %s\n", msg->datestr));
  }
//  else
  {
    dprintf(("UI_0", "NULL MESSAGE pointer in debug_output_messagedescriptor()\n"));
  }
    dprintf(("UI_0", "---------------------------------------------------------------\n"));
  }

#endif
