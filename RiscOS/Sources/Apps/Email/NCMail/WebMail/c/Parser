/************************************************************************/
/* File:    Parser.c                                                    */
/* Purpose: Central HTML file parser for WebMail.                       */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Wed 16th September 1998                               */
/*                Created.                                              */
/************************************************************************/


#include "../Build/Env.h"		/* Include Build Environment file.  This MUST be 1st before
					   any other preprocessor command */

/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "WebMail.h"
#include "Parser.h"
#include "Inbox.h"
#include "States.h"
#include "PopUp.h"
#include "SendMsg.h"
#include "UserSel.h"
#include "Advanced.h"
#include "Info.h"
#include "ReadMsg.h"
#include "Exit.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

static void file_get_string(FILE *file, char *string, int32 max_len, int32 extra_terminator);

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* parser_parse_file                                                    */
/*                                                                      */
/* Function parses the specified template file and outputs all tags &   */
/* text to the specified output file.  When an Active Comment is        */
/* detected a mode-dependant function is called to determine what the   */
/* comment is, and what to do with it.  The output_file is created here */
/* with the file pointer being passed to the subsequent functions.      */
/*                                                                      */
/* Parameters: page_type     - type of page to be rendered              */
/*             template_file - filename in ResourceFS for template.     */
/*             output_file   - location in CacheFS to create file.      */
/*             handle        - used to pass data through to the mode    */
/*                             specific output functions.               */
/*                                                                      */
/* Returns:    TRUE for success.                                        */
/************************************************************************/
bool parser_parse_file(char *template_file, char *output_file, ncmui_cbf_parser func, void *handle)
{
  FILE		*in = NULL;
  FILE		*out = NULL;
  int32		 c = 'a';
  bool		 rc = true;

  if (func == NULL)
  {
    /* No callback passed */
    rc = false;
  }
  else
  {
    /* Open the template file */
    in = fopen(template_file, "r");
    if (in == NULL)
    {
      error_report(ERROR_ParserOpenTemplateFail,
                   nb_messagetrans_lookup(config_block, "ERROR_ParserOpenTemplateFail"));
      rc = false;
    }
    else
    {
      /* Open the Output file */
      out = fopen(output_file, "w");
      if (out == NULL)
      {
        error_report(ERROR_ParserWriteOpenFileFail,
                     nb_messagetrans_lookup(config_block, "ERROR_ParserWriteOpenFileFail"));
        rc = false;
      }
      else
      {
        /* Lock the file to stop CacheFS deleting it */
        nb_file_lock(1, output_file, NULL);
        /* OK, now that we have successfully opened both files, loop around until we find an
         * Active Comment
         */
        do
        {
          c = fgetc(in);
          /* Check to see if we have retrieved the EOF marker */
          if (!feof(in))
          {
            /* OK, so now check for Active Comment and act accordingly */
            if (c != Active_Comment_Open)
            {
              fprintf(out, "%c", c);
            }
            else
            {
              parser_active_comment_found(in, out, func, handle);
            }
          }
        }
        while (!feof(in));

        /* Close the generated file, and set the filetype */
        fclose(out);
        nb_file_set_filetype(1, output_file, NULL, NB_FileType_HTML);
      }
      fclose(in);
    }
  }
  return(rc);
}


/************************************************************************/
/* parser_active_comment_found                                          */
/*                                                                      */
/* Function is called when an Active Comment delimeter is detected when */
/* a template file is being parsed.                                     */
/*                                                                      */
/* Parameters: in  - File pointer to template file.                     */
/*             out - File pointer to HTML file being created.           */
/*             handle        - used to pass data through to the mode    */
/*                             specific output functions.               */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void parser_active_comment_found(FILE *in, FILE *out, ncmui_cbf_parser func, void *handle)
{
  char string[Active_Comment_Max_Length];

  /* Retrieve AC */
  file_get_string(in, string, (Active_Comment_Max_Length - 1), Active_Comment_Close);
  dprintf(("UI_0", "*** Comment found: %s\n", string));

  /* Call the callback function */
  func(string, out, handle);
}


/************************************************************************/
/* file_get_string                                                      */
/*                                                                      */
/* Function reads in text from the specified file pointer until the EOL */
/* is hit, or a special extra terminator character is reached.          */
/*                                                                      */
/* Parameters: file                - pointer to file to read from.      */
/*             string              - pointer to string to put text in.  */
/*             max_len             - length of string.                  */
/*             extra_terminator    - Extra terminator to stop on.  If   */
/*                                   NULL EOL or EOF is used.           */
/*                                                                      */
/* Returns:    text in pointer, plus void.                              */
/*                                                                      */
/************************************************************************/
static void file_get_string(FILE *file, char *string, int32 max_len, int32 extra_terminator)
{
  int32		 counter;
  int32		 c;

  counter = 0;
  strcpy(string, "");
  c = 'a';	// Must be reset to something other than the terminators below in the while.

  while ( (counter < max_len) &&
          (c >= ' ') &&
          (c != extra_terminator) &&
          (c != EOF) ||
          (c == '\t')
        )
  {
    /* Get the character */
    c = fgetc(file);

    /* Make sure we don't run over the end of the buffer */
    if (counter < max_len)
    {
      string[counter++] = c;
    }
    else
    {
      /* The buffer is too full, so put character back */
      ungetc(c, file);
    }
  }

  if (counter >= max_len)
  {
    counter = max_len -1;
    ungetc(c, file);
  }
  string[counter-1] = 0;
}


