/************************************************************************/
/* File:    FrescoComs.c                                                */
/* Purpose: File contains code to do with communicating with NCFresco.  */
/*          This takes the form of receiving display request messages   */
/*          and opening/closing web pages.                              */
/*                                                                      */
/* Author:  Ben Laughton <mailto:blaughton@acorn.com>                   */
/* History: 0.01  Mon 21st September 1998                               */
/*                Created.                                              */
/*          0.02  Thu 24th September 1998                               */
/*                SNB: Added some NCMail specific bits to original code.*/
/*          0.03  Mon 28th September 1998                               */
/*                BAL: Fixed bug stopping ncmail: commands with just one*/
/*                parameter causing a postmortem.                       */
/************************************************************************/

/* Copyright 1998 Acorn Computers Ltd

   This material is the confidential trade secret and proprietary information
   of Acorn Computers. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Acorn Computers.
   All rights reserved.
 */

/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
/* CLib */
#include <ctype.h>

#include "WebMail.h"

/* Miscellaneous */
#include "URI.h"

/* Local */
#include "BrowserIF.h"
#include "URLOpen.h"		/* From NCFresco's source */
#include "WebMail.h"
#include "Inbox.h"
#include "Entry.h"
#include "ReadMsg.h"
#include "SendMsg.h"
#include "PopUp.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

#define URL_OFFSET       236
#define URL_PTR          (char *) 0x01800000

#define DBOX             "remove=\"__dbox\""

#define ARG_GRANULARITY  5

#define OS_Module_Claim  6
#define OS_Module_Free   7

/* Macro definitions */
#define M_unused(a) (void) (a)

/* -------------------------------------- TYPE DEFINITIONS -------------------------------------- */
typedef struct
{
    char *  name;
    bool (*handler) (char *, const char *);
} scheme_handler_t;

typedef struct
{
    char *  page;
    bool (*fn) (int, url_param *);
} url_handler_t;


/* ------------------------------------ FUNCTION PROTOTYPES ------------------------------------- */

static const char *  extract_indirect_string (
                         const urlopen_data *const  openurl,
                         const string_value         indirect_string);

static bool  process_url (char *const        url,
                          const char *const  body_filename);

static bool  process_ncmail (char *             url,
                             const char *const  body_filename);

static url_param *  process_ncmail_args_mem (char *      url,
                                             int *const  count);

static url_param *  process_ncmail_args_file (const char *const  filename,
                                              int *const         count);

static bool  process_mailto (char *             url,
                             const char *const  body_filename);


static bool  read_arg_name_file (FILE *const       fp,
                                 url_param *const  arg);

static bool  read_arg_value_file (FILE *const       fp,
                                  url_param *const  arg);

static bool  write_body_argument (FILE *const        in_file,
                                  const char *const  filename);

static bool  unescape_url_string (char *  string);

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

static scheme_handler_t  scheme[] =
{
    { "NCMail", process_ncmail },
    { "mailto", process_mailto }
};

extern bool test (int num_args, url_param *  arg);
static url_handler_t  url_handler[] =
{
  /* Structure should be 'Page Type', 'Function to call ' */
    { "Enter", entry_message_received } ,
    { "Inbox", inbox_message_received } ,
    { "ReadMsg", readmsg_message_received } ,
    { "Debug", debug_message_received } ,
    { "SendMsg", sendmsg_message_received } ,
    { "PopUp", popup_message_received }
};


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* browserif_sendurl                                                    */
/*                                                                      */
/* Function sends the URL to the browser to open using the URI protocol.*/
/*                                                                      */
/* Parameters: url   - url to display.                                  */
/*             dbox  - Set to true if the page is a popup dialogue.     */
/*                                                                      */
/* Returns:    TRUE (sent URL), FALSE (error).                          */
/*                                                                      */
/************************************************************************/
extern bool  browserif_sendurl (const char *const  url,
                                const bool         dbox)
{
    const char *  _url = url;
    char *        s    = NULL;
    bool          rc   = false;


    if (dbox)
    {
        /* Append information to the URL to indicate that it is being used to
         * control a dialogue box.
         */
        size_t  url_len = strlen (url);

        if (url[url_len - 1] != '?')
        {
            /* Need to add '&' to separate variables */
            ++url_len;
        }

        s = malloc (url_len + sizeof (DBOX));
        if (s)
        {
            memcpy (s,
                    url,
                    url_len + 1);

            if (url[url_len - 1] != '?')
            {
                strcat (s,
                        "&");
            }

            strcat (s,
                    DBOX);

            _url = s;
        }
        else
        {
            _url = NULL;
        }
    }

    dprintf(("UI", "URL to be sent is: %s\n", _url));

    if (_url)
#if 1
    {
        WimpMessage     message;
        urlopen_data *  open = (urlopen_data *) &message.data;
        size_t          url_size = strlen (_url) + 1;

        /* TEMPORARILY USE THE ANT URL PROTOCOL UNTIL FRESCO'S HANDLING OF THE
         * ACORN URI PROTOCOL IS FIXED.  THIS WILL *NOT* ACCEPT URLS LONGER
         * THAN 236 BYTES.
         */

       if (url_size <= 236)
       {
           message.hdr.size = sizeof (WimpMessage);
           message.hdr.your_ref = 0;
           message.hdr.action_code = wimp_MOPENURL;
           memcpy (open->url,
                   _url,
                   url_size);

           if (wimp_send_message (Wimp_EUserMessageRecorded,
                                  &message,
                                  0,
                                  0,
                                  NULL) == NULL)
           {
               rc = true;
           }
       }

    }
#else
    {
        if (uri_dispatch (0,
                          (char *) _url,
                          0,

                          NULL,
                          NULL,
                          NULL) == NULL)
        {
            rc = true;
        }
    }
#endif

    if (s)
    {
        free (s);
    }

    return rc;
}


/************************************************************************/
/* browserif_openurl_msg_handler                                        */
/*                                                                      */
/* Handle OpenURL Wimp messages from the web browser.  If we handle     */
/* the URL type then ack the message.                                   */
/*                                                                      */
/* Parameters: Wimp message params.                                     */
/*                                                                      */
/* Returns:    TRUE (handled message), FALSE (didn't handle message).   */
/*                                                                      */
/************************************************************************/
extern int  browserif_openurl_msg_handler (WimpMessage *  message,
                                           void *         handle)
{
    urlopen_data *  openurl = (urlopen_data *) &message->data;
    const char *    url = NULL;
    const char *    body_filename = NULL;
    int             rc = 0;

    dprintf(("UI", "browserif_openurl_msg_handler entered\n"));

    M_unused (handle);

    if (openurl->indirect.tag == 0)
    {
        /* Indirect URL */
        url = extract_indirect_string (openurl,
                                       openurl->indirect.url);

        /* For other fields need to check the message size to ensure that
         * the field is valid.  If this test passes then also need to check
         * actual value of field to see if it's filled in - yuck.
         */
        if (offsetof (WimpMessage, data) +
            offsetof (urlopen_data, indirect.body_file) < message->hdr.size)
        {
            /* Field might possibly contain valid data */
            body_filename = extract_indirect_string (openurl,
                                                     openurl->indirect.body_file);
        }
    }
    else
    {
        /* Wimp message just contains URL */
        url = openurl->url;
    }

    if (url)
    {
        /* Not clear whether it is acceptable to overwrite the URL, so take a
         * copy for manipulation.
         */
        char *  working_copy_url;
        size_t  url_size = strlen (url) + 1;

        working_copy_url = malloc (url_size);
        if (working_copy_url)
        {
            memcpy (working_copy_url,
                    url,
                    url_size);

            rc = (int) process_url (working_copy_url,
                                    body_filename);

            free (working_copy_url);

            if (rc)
            {
                /* We handled the URL so we must acknowledge the Wimp message */
                dprintf(("UI", "sending URL message back\n"));
                message->hdr.your_ref = message->hdr.my_ref;

                (void) wimp_send_message (Wimp_EUserMessageAcknowledge,
                                          message,
                                          message->hdr.sender,
                                          0,
                                          NULL);
            }
        }
    }

    return rc;
}


/************************************************************************/
/* extract_indirect_string                                              */
/*                                                                      */
/* Return a pointer to a character string given an indirected string    */
/* field from the (revolting) ANT URL protocol.                         */
/*                                                                      */
/* Parameters: openurl - pointer to OpenURL data area in Wimp message   */
/*             indirect_string - indirect string from OpenURL message   */
/*                                                                      */
/* Returns:    NULL (no string in field), otherwise pointer to string.  */
/*                                                                      */
/************************************************************************/
static const char *  extract_indirect_string (
                         const urlopen_data *const  openurl,
                         const string_value         indirect_string)
{
    char *  string = NULL;

    if (indirect_string.offset < URL_OFFSET)
    {
        string = ((char *) openurl) + indirect_string.offset;
    }
    else if (indirect_string.ptr >= URL_PTR)
    {
        string = indirect_string.ptr;
    }

    return string;
}



/************************************************************************/
/* process_url                                                          */
/*                                                                      */
/* Process a zero terminated URL, deciding whether or not we should     */
/* handle it.                                                           */
/*                                                                      */
/* Parameters: url  - pointer to URL.                                   */
/*             body_file - pointer to body filename (NULL if N/A)       */
/*                                                                      */
/* Returns:    true (handled URL), false (didn't handle URL).           */
/*                                                                      */
/************************************************************************/
static bool  process_url (char *const        url,
                          const char *const  body_filename)
{
    bool  rc = false;
    char *  s;

    if (url)
    {
        /* Search for scheme delimiter ':' */
        s = strchr (url, ':');
        if (s)
        {
            int  i = 0;

            *s++ = 0;

            while (i < sizeof (scheme) / sizeof (scheme[0]))
            {
                if (nb_case_insensitive_strcmp (url, scheme[i].name) == 0)
                {
                    rc = (*scheme[i].handler) (s,
                                               body_filename);
                    break;
                }
                i++;
            }
        }
    }

    return rc;
}


/************************************************************************/
/* process_ncmail                                                       */
/*                                                                      */
/* Extract the variables from an NCMail URL in memory or a file and     */
/* forward them to the appropriate handling function.  Variables are of */
/* the form variable=value and are separated by '&'.                    */
/*                                                                      */
/* Parameters: url  - pointer to zero terminated url in memory.         */
/*             body_filename - name of file containing URL (NULL if N/A)*/
/*                                                                      */
/* Returns:    true (handled), false (not handled).                     */
/*                                                                      */
/************************************************************************/
static bool  process_ncmail (char *             url,
                             const char *const  body_filename)
{
    bool    rc = false;

    /* Skip over '/' */
    if (*url++ == '/')
    {
        int          count;
        url_param *  arg;

        if (body_filename)
        {
            arg = process_ncmail_args_file (body_filename,
                                            &count);
        }
        else
        {
            arg = process_ncmail_args_mem (url,
                                           &count);
        }

        if (arg)
        {
            int  i = 0;

            /* First argument should be page */
            if (strcmp (arg[0].name, "page") == 0)
            {
                while (i < sizeof (url_handler) / sizeof (url_handler[0]))
                {
                    if (strcmp (arg[0].value, url_handler[i].page) == 0)
                    {
                        /* No need to give handler the page parameter */
                        (*url_handler[i].fn) (count - 1,
                                              &arg[1]);
                        rc = true;
                        break;
                    }

                    i++;
                }
            }

            if (body_filename)
            {
                for (i = 0; i < count; ++i)
                {
                    if (arg[i].name)
                    {
                        free (arg[i].name);
                    }
                    if (arg[i].value)
                    {
                        free (arg[i].value);
                    }
                }
            }

            free (arg);
        }
    }

    return rc;
}




/************************************************************************/
/* process_ncmail_args_mem                                              */
/*                                                                      */
/* Process NCMail URLs where the scheme specific data is stored in      */
/* memory.                                                              */
/*                                                                      */
/* Parameters: s - pointer to tail of 0 terminated URL.                 */
/*             count - (output) number of parameters extracted from URL */
/*                                                                      */
/* Returns:    NULL (error), otherwise pointer to array of parameters   */
/*                                                                      */
/************************************************************************/
static url_param *  process_ncmail_args_mem (char *      s,
                                             int *const  count)
{
    url_param *  arg = NULL;

    *count = 0;

    /* Skip over '?' */
    if (*s++ == '?')
    {
        char *  name = s;

        while (s = strchr (s, '='), s != NULL)
        {
            /* Allocate space for arguments in blocks */
            if (*count % ARG_GRANULARITY == 0)
            {
                url_param *  temp =
                    realloc (
                        arg,
                        sizeof (url_param) * (*count + ARG_GRANULARITY));

                if (!temp)
                {
                    goto cleanup;
                }

                arg = temp;
            }

            /* Store pointer to parameter name */
            if (!unescape_url_string (name))
            {
                goto cleanup;
            }

            arg[*count].name = name;

            /* Replace '=' with 0 to separate parameter name from value */
            *s++ = 0;

            /* Store pointer to parameter value */
            if (!unescape_url_string (s))
            {
                goto cleanup;
            }

            arg[*count].value = s;
            ++*count;

            /* Find parameter separator */
            s = strchr (s, '&');
            if (s)
            {
                /* Replace '&' with 0 to separate parameters */
                *s++ = 0;
                name = s;
            }
        };

        /* May need to allocate an extra element in the argument array
         * to hold the array terminator.
         */
        if (*count % ARG_GRANULARITY == 0)
        {
            url_param *  temp =
                    realloc (
                        arg,
                        sizeof (url_param) * (*count + 1));

            if (!temp)
            {
                goto cleanup;
            }

            arg = temp;
        }

        /* Ensure arg list is properly terminated */
        arg[*count].name  = NULL;
        arg[*count].value = NULL;
    }
    return arg;

cleanup:
    if (arg)
    {
        free (arg);
    }

    return NULL;
}




/************************************************************************/
/* process_ncmail_args_file                                             */
/*                                                                      */
/* Process NCMail URLs where the scheme specific data is stored in      */
/* a file.                                                              */
/*                                                                      */
/* Parameters: filename - name of file containing scheme specific data  */
/*             count - (output) number of parameters extracted from URL */
/*                                                                      */
/* Returns:    NULL (error), otherwise pointer to array of parameters   */
/*                                                                      */
/************************************************************************/
static url_param *  process_ncmail_args_file (const char *const  filename,
                                              int *const         count)
{
    FILE *       fp;
    url_param *  arg = NULL;

    *count = 0;

    fp = fopen (filename, "r");
    if (fp)
    {
        /* Disclaimer: I wrote a version of this loop without the gotos,
         * but it was more difficult to follow, produced larger code and
         * would have been slower (though these last two would not have
         * been significant).
         */

        while (!feof (fp))
        {
            /* Allocate space for arguments in blocks */
            if (*count % ARG_GRANULARITY == 0)
            {
                url_param *  temp =
                    realloc (
                        arg,
                        sizeof (url_param) * (*count + ARG_GRANULARITY));

                if (!temp)
                {
                    goto cleanup;
                }

                arg = temp;
            }

            if (!read_arg_name_file (fp,
                                     &arg[*count]))
            {
                goto cleanup;
            }

            /* Check for special case: 'body' argument's contents need
             * to be copied to another file, not memory.
             */
            if (strcmp (arg[*count].name, "body") == 0)
            {
                /* Body argument's value is the name of a file
                 * containing the real value.
                 */
                arg[*count].value = malloc (L_tmpnam + 1);
                if (arg[*count].value == NULL)
                {
                    free (arg[*count].name);
                    goto cleanup;
                }

                tmpnam (arg[*count].value);
                if (!write_body_argument (fp,
                                          arg[*count].value))
                {
                    free (arg[*count].name);
                    goto cleanup;
                }
            }
            else
            {
                if (!read_arg_value_file (fp,
                                          &arg[*count]))
                {
                    goto cleanup;
                }
            }

            ++*count;
        };

        /* May need to allocate an extra element in the argument array
         * to hold the array terminator.
         */
        if (*count % ARG_GRANULARITY == 0)
        {
            url_param *  temp =
                    realloc (
                        arg,
                        sizeof (url_param) * (*count + 1));

            if (!temp)
            {
                goto cleanup;
            }
            arg = temp;
        }

        /* Ensure arg list is properly terminated */
        arg[*count].name  = NULL;
        arg[*count].value = NULL;

        fclose (fp);
    }
    return arg;

cleanup:
    fclose (fp);

    if (arg)
    {
        int i;

        for (i = 0; i < *count; ++i)
        {
            if (arg[i].name)
            {
                free (arg[i].name);
            }
            if (arg[i].value)
            {
                free (arg[i].value);
            }
        }
        free (arg);
    }

    return NULL;
}




/************************************************************************/
/* process_mailto                                                       */
/*                                                                      */
/* Process mailto: URL messages.                                        */
/*                                                                      */
/* Parameters: s  - contents of mailto: URL.                            */
/*             body_filename -                                          */
/*                                                                      */
/* Returns:    true (handled), false (not handled).                     */
/*                                                                      */
/************************************************************************/
static bool  process_mailto (char *const        s,
                             const char *const  body_filename)
{
    /* Not implemented yet, so pass on URL */
  NB_UNUSED(s);
  NB_UNUSED(body_filename);

  return false;
}




/************************************************************************/
/* read_arg_name_file                                                   */
/*                                                                      */
/* Read a parameter name from a file containing NCEmail scheme          */
/* specific data.                                                       */
/*                                                                      */
/* Parameters: fp - file handle                                         */
/*             arg - place to store parameter name                      */
/*                                                                      */
/* Returns:    true (success), false (error)                            */
/*                                                                      */
/************************************************************************/
static bool  read_arg_name_file (FILE *const       fp,
                                 url_param *const  arg)
{
    bool       rc = false;
    long int   offset;

    arg->name  = NULL;

    /* Record current position in file */
    offset = ftell (fp);
    if (offset != -1)
    {
        int        name_len;

        /* Find length of parameter name */
        if (fscanf (fp,
                    "%*[^=]%n",
                    &name_len) != EOF)
        {
            if (name_len > 0)
            {
                /* Allocate memory to store parameter name */
                arg->name = malloc (name_len + 1);
                if (arg->name)
                {
                    /* Go back to initial position in file to do actual read */
                    if (fseek (fp,
                               offset,
                               SEEK_SET) == 0)
                    {
                        if (fscanf (fp,
                                    "%[^=]=",
                                    arg->name) == 1)
                        {
                            rc = true;
                        }
                    }
                }
            }
        }
    }

    if (rc == false)
    {
        if (arg->name)
        {
            free (arg->name);
        }
    }

    return rc;
}




/************************************************************************/
/* read_arg_value_file                                                  */
/*                                                                      */
/* Read a parameter value from a file containing NCEmail scheme         */
/* specific data.                                                       */
/*                                                                      */
/* Parameters: fp - file handle                                         */
/*             arg - place to store parameter value                     */
/*                                                                      */
/* Returns:    true (success), false (error)                            */
/*                                                                      */
/************************************************************************/
static bool  read_arg_value_file (FILE *const       fp,
                                  url_param *const  arg)
{
    bool       rc = false;
    long int   offset;

    arg->value = NULL;

    /* Record current position in file */
    offset = ftell (fp);
    if (offset != -1)
    {
        int        value_len;

        /* Find length of parameter value */
        if (fscanf (fp,
                    "%*[^&]%n",
                    &value_len) != EOF)
        {
            /* Allocate memory to store parameter value */
            arg->value = malloc (value_len + 1);
            if (arg->value)
            {
                /* Go back to initial position in file to do actual read */
                if (fseek (fp,
                           offset,
                           SEEK_SET) == 0)
                {
                    if (fscanf (fp,
                                "%[^&]&",
                                arg->value) == 1)
                    {
                        if (unescape_url_string (arg->value))
                        {
                            rc = true;
                        }
                    }
                }
            }
        }
    }

    if (rc == false)
    {
        if (arg->value)
        {
            free (arg->value);
        }
    }

    return rc;
}




/************************************************************************/
/* write_body_argument                                                  */
/*                                                                      */
/* Write the value of an NCEmail 'body' argument to a file, peforming   */
/* any necessary character unescaping.                                  */
/*                                                                      */
/* Parameters: in_file - input file handle                              */
/*             filename - name of output file                           */
/*                                                                      */
/* Returns:    true (success), false (error)                            */
/*                                                                      */
/************************************************************************/
static bool  write_body_argument (FILE *const        in_file,
                                  const char *const  filename)
{
    bool    rc = true;
    FILE *  out_file;

    out_file = fopen (filename, "w");
    if (out_file == NULL)
    {
        rc = false;
    }
    else
    {
        int  c;

        while (rc && (c = getc (in_file)) != EOF)
        {
            switch (c)
            {
                case '%':    /* escape sequence */
                {
                    /* Expect two hex characters - this code nicked from
                     * c-client's quoted-printable decoding.
                     */
                    char  e;

                    c = getc (in_file);
                    if (! (isxdigit (c) &&
                           (e = getc (in_file)) != EOF &&
                           isxdigit (e)))
                    {
                        rc = false;
                        break;
                    }

                    if (isdigit (c))
                    {
                        c -= '0';
                    }
                    else
                    {
                        if (isupper (c))
                        {
                            c -= 'A' - 10;
                        }
                        else
                        {
                            c -= 'a' - 10;
                        }
                    }

                    if (isdigit (e))
                    {
                        e -= '0';
                    }
                    else
                    {
                        if (isupper (e))
                        {
                            e -= 'A' - 10;
                        }
                        else
                        {
                            e -= 'a' - 10;
                        }
                    }

                    if (putc (e + (c << 4),
                              out_file) == EOF)
                    {
                        rc = false;
                    }
                    break;
                }

                case '+':
                    c = ' ';
                    /* drop through */

                default:
                    if (putc (c, out_file) == EOF)
                    {
                        rc = false;
                    }
                    break;
            }
        }

        fclose (out_file);
        nb_file_lock(1, (char *) filename, NULL);
    }

    return rc;
}




/************************************************************************/
/* unescape_url_string                                                  */
/*                                                                      */
/* Perform any necessary character unescaping on a URL string passed    */
/* from NCFresco.  Unescaped data is never longer than escaped data,    */
/* so the processing is performed 'in place' without making a new copy  */
/* of the string.                                                       */
/*                                                                      */
/* Parameters: string - 0 terminated string to unescape                 */
/*                                                                      */
/* Returns:    true (successful), false (invalid data)                  */
/*                                                                      */
/************************************************************************/
static bool  unescape_url_string (char *  string)
{
    int     c;
    bool    rc = true;
    char *  s = string;
    char *  d = string;

    while (rc && (c = *s++) != 0)
    {
        switch (c)
        {
            case '%':    /* escape sequence */
            {
                /* Expect two hex characters - this code nicked from
                 * c-client's quoted-printable decoding.
                 */
                char  e;

                c = *s++;
                if (! (isxdigit (c) &&
                       (e = *s++) &&
                       isxdigit (e)))
                {
                    rc = false;
                    break;
                }

                if (isdigit (c))
                {
                    c -= '0';
                }
                else
                {
                    if (isupper (c))
                    {
                        c -= 'A' - 10;
                    }
                    else
                    {
                        c -= 'a' - 10;
                    }
                }

                if (isdigit (e))
                {
                    e -= '0';
                }
                else
                {
                    if (isupper (e))
                    {
                        e -= 'A' - 10;
                    }
                    else
                    {
                        e -= 'a' - 10;
                    }
                }

                *d++ = e + (c << 4);
                break;
            }

            case '+':
                c = ' ';
                /* fall through */

            default:
                *d++ = c;
                break;
        }
    }

    if (rc)
    {
        /* Ensure unescaped string is 0 terminated */
        *d = 0;
    }

    return rc;
}
