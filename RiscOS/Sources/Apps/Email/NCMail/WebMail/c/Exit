/************************************************************************/
/* File:    Entry.c                                                     */
/* Purpose: Code relating to entering the email client.                 */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Wed 23rd September 1998                               */
/*                Created.                                              */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "Exit.h"
#include "Entry.h"
#include "PopUp.h"
#include "Parser.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */


/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* exit_active_comment_found                                            */
/*                                                                      */
/* Function is called when the UI page type is Exit & an active comment */
/* is found in the web page being parsed.                               */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void exit_active_comment_found(char *comment, FILE *out, void *handle)
{
  char		*url = NULL;

  url = (char *) handle;

  if (nb_case_insensitive_strcmp(comment, Exit_URL) == 0)
  {
    fprintf(out, url);
  }
}


/************************************************************************/
/* exit_build_screen                                                    */
/*                                                                      */
/* Function is called to build the exit build screen.                   */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void exit_build_screen(char *url)
{
  bool rc = false;

  rc = parser_parse_file(PageType_Exit, Template_Exit, Generated_Exit, (void *) url);

  if (rc == true)
  {
    if (browserif_sendurl(Open_Exit, false) == false)
    {
      ncmui_error_display(22);
      /* We are screwed.  Set status.state to Inbox before calling parser failed so that it doesn't
       * go into an infinite loop.
       */
      status.state = State_Inbox;
      error_parser_failed();
    }
    /* Unlock the UI */
    status.ui_locked = false;
  }
  else
  {
    ncmui_error_display(21);
    dprintf(("", "State: %d\n", status.state));
    error_parser_failed();
    /* Unlock the UI */
    status.ui_locked = false;
  }
}





/************************************************************************/
/* exit_die_gracefully                                                  */
/*                                                                      */
/* Function is called when we die.  This allows us to tidy up after a   */
/* crash.                                                               */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void exit_die_gracefully(void)
{
  dprintf(("UI", "atexit() called exit_die_gracefully()\n"));
  entry_reset_url_strings();
}


/************************************************************************/
/* exit_to_browser                                                      */
/*                                                                      */
/* Function is called when we are exiting the email client for whatever */
/* reason.  A check will be made to see if we are still online and if   */
/* so status.exit_urlon will be displayed, else status.exit_urloff will */
/* be displayed.  If both of these are null then ncint:current will be  */
/* passed to the browser.                                               */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
bool exit_to_browser(void)
{
  bool		rc = false;

  if (status.netlink == NetLink_Online)
  {
    if (nb_string_empty(status.exit_urlon) == TRUE)
    {
//    rc = browserif_sendurl(Online_Default, false);
      exit_build_screen(Online_Default);
    }
    else
    {
#ifdef WORK_AROUND_NCMA_BUG
      /* NCMA does not accept the ANT URL broadcast at present so we must send any NCMA: urls to
       * it via the command line - yuck!
       */
      if (nb_case_insensitive_strncmp(status.exit_urlon, "ncma:", 5) == 0)
      {
        exit_work_around_ncma_bug(status.exit_urlon);
      }
      else
#endif
      {
//      rc = browserif_sendurl(status.exit_urlon, false);
        exit_build_screen(status.exit_urlon);
      }
    }
  }
  else
  {
    /* We are offline */
    if (nb_string_empty(status.exit_urloff) == TRUE)
    {
//    rc = browserif_sendurl(Offline_Default, false);
      exit_build_screen(Offline_Default);
    }
    else
    {
#ifdef WORK_AROUND_NCMA_BUG
      /* NCMA does not accept the ANT URL broadcast at present so we must send any NCMA: urls to
       * it via the command line - yuck!
       */
      if (nb_case_insensitive_strncmp(status.exit_urloff, "ncma:", 5) == 0)
      {
        exit_work_around_ncma_bug(status.exit_urloff);
      }
      else
#endif
      {
//      rc = browserif_sendurl(status.exit_urloff, false);
        exit_build_screen(status.exit_urloff);
      }
    }
  }
  entry_reset_url_strings();
  return(rc);
}


#ifdef WORK_AROUND_NCMA_BUG

  /************************************************************************/
  /* exit_work_around_ncma_bug                                            */
  /*                                                                      */
  /* Function converts the NCMA url into an NCMA command.                 */
  /*                                                                      */
  /* Parameters: url to send.                                             */
  /*                                                                      */
  /* Returns:                                                             */
  /*                                                                      */
  /************************************************************************/
  void exit_work_around_ncma_bug(char *url)
  {
    char		*command = NULL;

    if ((command = malloc(strlen(url) + strlen(NCMA_COMMAND_PREFIX) + 5)) == NULL)
    {
      ncmui_error_display(1);
    }
    else
    {
      sprintf(command, "%s %s", NCMA_COMMAND_PREFIX, url);

      _kernel_oscli(command);

      free(command);
    }
  }

#endif

