/************************************************************************/
/* File:    Compose.c                                                   */
/* Purpose: Code relating to the Compose screen.                        */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Mon 05th October 1998                                 */
/*                Created.                                              */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "Compose.h"
#include "SendMsg.h"
#include "States.h"
#include "Inbox.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */


/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */


/************************************************************************/
/* compose_message_received                                             */
/*                                                                      */
/* Function is called when the library receives an ncmail: message from */
/* the Compose Screen.                                                  */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
bool compose_message_received(int num_args, url_param *  arg)
{
  int32		 counter = -1;
  int32		 counter2 = -1;
  bool		 found = false;

  dprintf(("UI", "compose_message_received entered\n"));

  /* Check to see if the UI is locked */
  if (status.ui_locked == false)
  {
    /* Now lock the UI to prevent clicks until whatever item is selected is unlocked */
    status.ui_locked = true;

    do
    {
      counter++;
      dprintf(("UI", "Name:  %s\n", arg[counter].name));
      dprintf(("UI", "Value: %s\n", arg[counter].value));

      /* Cancel Button */
      if (nb_case_insensitive_strcmp(arg[counter].value, Compose_Button_Cancel) == 0)
      {
        for (counter2 = 0; counter2 < num_args; counter2++)
        {
          if (nb_case_insensitive_strcmp(arg[counter2].name, Compose_ID) == 0)
          {
            compose_cancel_selected(arg[counter2].value);
          }
        }
        found = true;
      }
      /* Send Button */
      else if (nb_case_insensitive_strcmp(arg[counter].value, Compose_Button_Send) == 0)
      {
        compose_send_selected(num_args, arg);
        found = true;
      }
    }
    while ( (found == false) && (counter < num_args) );

    if (found == false)
    {
      ncmui_error_display(27);
      status.ui_locked = false;
    }
  }

  return(true);
}


/************************************************************************/
/* compose_cancel_selected                                              */
/*                                                                      */
/* Function is called when the user clicks on the Cancel button in the  */
/* Compose screen.                                                      */
/*                                                                      */
/* Parameters: id  - internal ID of the message to be cancelled.        */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void compose_cancel_selected(char *id)
{
  uint32	 msg_id;

  dprintf(("UI", "CANCEL SELECTED on message: %s\n", id));
  status.ui_locked = true;

  /* For now keep this in until really sending is implemented. */
  status.ui_locked = false;

  msg_id = atoi(id);
  if (eng_cancel_message(msg_id) != ENG_COMPLETED)
  {
    ncmui_error_display(33);
  }
  inbox_build_screen();
}


/************************************************************************/
/* compose_send_selected                                                */
/*                                                                      */
/* Function called when the user clicks on Send in the Compose screen.  */
/*                                                                      */
/* Parameters: num_args  - number of items in arg array.                */
/*             arg       - array of var names and values.               */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void compose_send_selected(int num_args, url_param *  arg)
{
  MessageDescriptor	*ptr;
  char			*body_file = NULL;
  eng_rcode		 rc, er;
  uint32		 msg_id = 0;
  int32			 counter;
  bool			 found = false;

  /* Locate the MessageId from the url_param struct */
  counter = -1;
  do
  {
    counter++;
    if (nb_case_insensitive_strcmp(arg[counter].name, Template_Tag_ID) == 0)
    {
      msg_id = atoi(arg[counter].value);
      found = true;
    }
  }
  while ( (found == false) && (counter < num_args) );

  if (found == true)
  {
    dprintf(("UI", "SEND SELECTED\n"));
    status.ui_locked = true;

    er = eng_get_send_message(msg_id, &ptr);

    if (er == ENG_COMPLETED)
    {
      /* Loop around the url_param struct and extract the data */
      for (counter = 0; counter < num_args; counter++)
      {
        /* To field */
        if (nb_case_insensitive_strcmp(arg[counter].name, SendMsg_Tag_To) == 0)
          sendmsg_setup_messagedescriptor_field(arg[counter].value, &ptr->to);
        /* CC field */
        else if (nb_case_insensitive_strcmp(arg[counter].name, SendMsg_Tag_CC) == 0)
          sendmsg_setup_messagedescriptor_field(arg[counter].value, &ptr->cc);
        /* Subject field */
        else if (nb_case_insensitive_strcmp(arg[counter].name, SendMsg_Tag_Subject) == 0)
          sendmsg_setup_messagedescriptor_field(arg[counter].value, &ptr->subject);
        /* Body field */
        else if (nb_case_insensitive_strcmp(arg[counter].name, SendMsg_Tag_Body) == 0)
          sendmsg_setup_messagedescriptor_field(arg[counter].value, &body_file);
      }
      dprintf(("UI", "MessageDescriptor:\n"));
      dprintf(("UI", "  ID:      %d\n", ptr->ID));
      dprintf(("UI", "  To:      %s\n", ptr->to));
      dprintf(("UI", "  Subject: %s\n", ptr->subject));
      dprintf(("UI", "  CC:      %s\n", ptr->cc));
      dprintf(("UI", "  Body:    %s\n", body_file));

      /* Send the message to the engine */
      rc = eng_send_message(msg_id, body_file, NULL, compose_send_cbf);
      free(body_file);

      switch(rc)
      {
        case(ENG_BUSY):
        case(ENG_RUNNING):
        {
          if (status.netlink == NetLink_Online)
            popup_open_dialogue(nb_messagetrans_lookup(message_block, "SENDMSG_Sending"));
          else
            popup_open_dialogue(nb_messagetrans_lookup(message_block, "SENDMSG_Queuing"));

          break;
        }
        case(ENG_NOMEMORY):
        {
          ncmui_error_display(34);
          break;
        }
        default:
        {
          ncmui_error_display(35);
        }
      }
    }
    else
    {
      ncmui_error_display(37);

    }
  }
  /* For now keep this in until really sending is implemented. */
  status.ui_locked = false;
}


/************************************************************************/
/* compose_send_cbf                                                     */
/*                                                                      */
/* Function is called by the engine when eng_send_message() returns.    */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void compose_send_cbf(eng_rcode rc, void *handle)
{
  NB_UNUSED(handle);

  dprintf(("UI", "eng_send_message callback entered\n"));

  /* Close the dialogue box and take appropriate action */
  popup_close_dialogue();

  switch(rc)
  {
    case(ENG_COMPLETED):
    {
      status.ui_locked = true;
      inbox_build_screen();
      break;
    }
    case(ENG_SENDFAILED):
    {
      status.state = State_Compose_Failed;
      popup_1_open_dialogue( nb_messagetrans_lookup(message_block, "COMPOSE_SendFailed"),
                             nb_messagetrans_lookup(message_block, "BUTTON_Cancel") );
      ncmui_error_display(36);
      break;
    }
    default:
    {
      ncmui_error_display(35);
    }
  }
}


/************************************************************************/
/* compose_selected_from_inbox                                          */
/*                                                                      */
/* Function is called when the user clicks on Compose in the Inbox      */
/* screen.  We must now setup the compose dialogue.                     */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void compose_selected_from_inbox(void)
{
  eng_rcode		 rc;

  status.state = State_Compose;

  rc = eng_create_message(0, NULL, compose_msg_cbf);

  /* Check the return code */
  switch(rc)
  {
    case(ENG_BUSY):	dprintf(("UI", "Engine is BUSY when creating message\n"));	break;
    case(ENG_RUNNING):	dprintf(("UI", "Engine create message RUNNING\n"));		break;
    case(ENG_NOMEMORY):
    {
      ncmui_error_display(30);
      status.ui_locked = false;
      error_parser_failed();
    }
    default:		ncmui_error_display(29);					break;
  }
}


/************************************************************************/
/* compose_msg_cbf                                                      */
/*                                                                      */
/* Function is called by the email engine when it has created a new     */
/* MessageDescriptor for me to use for the compose.                     */
/*                                                                      */
/* Parameters: rc      - error code.                                    */
/*             msg     - MessageDescriptor allocated.                   */
/*             handle  - not used.                                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void compose_msg_cbf(eng_rcode rc, MessageDescriptor *msg, void *handle)
{
  NB_UNUSED(handle);

  dprintf(("UI", "compose_msg_cbf entered with msg id: %d\n", msg->ID));

  if (rc == ENG_COMPLETED)
  {
    if (sendmsg_build_screen(msg) == false)
    {
      ncmui_error_display(32);
      status.ui_locked = false;
      error_parser_failed();
    }
  }
  else
  {
    ncmui_error_display(31);
    status.ui_locked = false;
    error_parser_failed();
  }
}

