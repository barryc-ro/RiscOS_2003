/************************************************************************/
/* File:    SendMsg.c                                                   */
/* Purpose: Page parsing code for Compose, Reply, MailTo: screens.      */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Tue 06th October 1998                                 */
/*                Created.                                              */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "SendMsg.h"
#include "EscapeHTML.h"
#include "MailTo.h"
#include "Compose.h"
#include "PopUp.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */


/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

/* This is used to pass around MessageIds in the case of Cancel messages. */
char *msg_id_ptr = NULL;

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */


/************************************************************************/
/* sendmsg_message_received                                             */
/*                                                                      */
/* Function is called when the library receives an ncmail: message from */
/* the SendMsg Screen.  This can be for any of the send types.          */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
bool sendmsg_message_received(int num_args, url_param *  arg)
{
  int32		 counter = -1;
  int32		 counter2 = -1;
  bool		 found = false;

  dprintf(("UI", "SendMsg_message_received entered\n"));

  /* Check to see if the UI is locked */
  if (status.ui_locked == false)
  {
    /* Now lock the UI to prevent clicks until whatever item is selected is unlocked */
    status.ui_locked = true;

    do
    {
      counter++;
      dprintf(("UI", "Name:  %s\n", arg[counter].name));
      dprintf(("UI", "Value: %s\n", arg[counter].value));

      /* Cancel Button */
      if (nb_case_insensitive_strcmp(arg[counter].value, SendMsg_Button_Cancel) == 0)
      {
        for (counter2 = 0; counter2 < num_args; counter2++)
        {
          if (nb_case_insensitive_strcmp(arg[counter2].name, Template_Tag_ID) == 0)
          {
            sendmsg_cancel_selected(arg[counter2].value);
          }
        }
        found = true;
      }
      /* Send Button */
      else if (nb_case_insensitive_strcmp(arg[counter].value, SendMsg_Button_Send) == 0)
      {
        sendmsg_send_selected(num_args, arg);
        found = true;
      }
    }
    while ( (found == false) && (counter < num_args) );

    if (found == false)
    {
      ncmui_error_display(27);
      status.ui_locked = false;
    }
  }

  return(true);
}


/************************************************************************/
/* sendmsg_send_selected                                                */
/*                                                                      */
/* Function is called if the email on screen has the necessary data     */
/* filled in, and we can proceed with the Send operation.               */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void sendmsg_send_selected(int num_args, url_param *arg)
{
  int32		 counter;
  bool		 to_empty = false;
  bool		 cc_empty = false;

  /* Loop through the args and check for To and CC.  If both are empty then report an error */
  for (counter = 0; counter < num_args; counter++)
  {
    if (nb_case_insensitive_strcmp(arg[counter].name, SendMsg_Tag_To) == 0)
    {
      if ( (arg[counter].name == NULL) || (strcmp(arg[counter].name, "") == 0) )
        to_empty = true;
    }
    if (nb_case_insensitive_strcmp(arg[counter].name, SendMsg_Tag_CC) == 0)
    {
      if ( (arg[counter].name == NULL) || (strcmp(arg[counter].name, "") == 0) )
        cc_empty = true;
    }
  }

  if ( (cc_empty == true) && (to_empty == true) )
  {
    /* no email address specified */
    /* popup */
  }
  else
  {
    switch(status.state)
    {
      case(State_Compose):	compose_send_message(num_args, arg);		break;
      default:
      {
        dprintf(("UI", "Unknown send state (%d)\n", status.state));
        break;
      }
    }
  }
}


/************************************************************************/
/* sendmsg_cancel_selected                                              */
/*                                                                      */
/* Function is called when the user clicks on the Cancel button in the  */
/* SendMsg screen.  As all states have the same outcome it is handled   */
/* here without calling anything in Compose, Reply etc.                 */
/*                                                                      */
/* Parameters: id  - internal ID of the message to be cancelled.        */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_cancel_selected(char *id)
{
  /* This malloc is free'd in the sendmsg_cancel_cbf function */
  if ((msg_id_ptr = malloc(strlen(id) + 1)) == NULL)
  {
    ncmui_error_display(1);
  }
  else
  {
    strcpy(msg_id_ptr, id);
    dprintf(("UI", "sendmsg_cancel_selected() with id: %s\n", id));
    dprintf(("UI", "malloc'd into msg_id_ptr as:       %s\n", msg_id_ptr));

    popup_2_open_dialogue( nb_messagetrans_lookup(message_block, "SENDMSG_Cancel"),
                           nb_messagetrans_lookup(message_block, "BUTTON_Continue"),
                           nb_messagetrans_lookup(message_block, "BUTTON_Cancel"),
                           sendmsg_cancel_cbf,
                           (void *) msg_id_ptr );
  }
}


/************************************************************************/
/* sendmsg_cancel_cbf                                                   */
/*                                                                      */
/* Function is called when the user makes a decision in the Popup window*/
/* opened when they selected Cancel in the Send window.                 */
/*                                                                      */
/* Parameters: ncmui_cbf_popup parameters.                              */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_cancel_cbf(bool default_sel, void *handle)
{
  uint32 id;

  dprintf(("UI", "sendmsg_cancel_cbf entered with handle of: %d\n", (uint32) handle));

  /* User selected cancel */
  if (default_sel == false)
  {
    /* Cancel the message */
    id = atoi( (char *)handle );

    dprintf(("UI", "CANCEL SELECTED on message: %d\n", id));
    dprintf(("UI", "Mode is %d:\n", status.state));
    status.ui_locked = true;

    /* For now keep this in until really sending is implemented. */
    status.ui_locked = false;

    if (eng_cancel_message(id) != ENG_COMPLETED)
    {
      ncmui_error_display(33);
    }

    /* All modes execpt for MailTo: will be returning to the Inbox */
    if (status.state == State_MailTo)
    {
      mailto_exit();
    }
    else
    {
      inbox_build_screen();
    }
  }
  else
  {
      browserif_close_dbox ();
      status.ui_locked = false;
  }

  /* Free the message id global pointer */
  free(msg_id_ptr);
  msg_id_ptr = NULL;
}



/************************************************************************/
/* sendmsg_send_cbf                                                     */
/*                                                                      */
/* Function is called by the engine when eng_send_message() returns.    */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void sendmsg_send_cbf(eng_rcode rc, void *handle)
{
  NB_UNUSED(handle);

  dprintf(("UI", "eng_send_message callback entered\n"));

  switch(rc)
  {
    case(ENG_COMPLETED):
    {
      status.ui_locked = true;

      /* Check to see what state we are in - if it is MailTo then exit, otherwise render inbox */
      if (status.state == State_MailTo)
        mailto_exit();
      else
        inbox_build_screen();

      break;
    }
    case(ENG_SENDFAILED):
    {
      status.state = State_Compose_Failed;
//      popup_1_open_dialogue( nb_messagetrans_lookup(message_block, "COMPOSE_SendFailed"),
//                             nb_messagetrans_lookup(message_block, "BUTTON_Cancel") );
      ncmui_error_display(36);
      break;
    }
    default:
    {
      ncmui_error_display(35);
    }
  }
}


/************************************************************************/
/* sendmsg_display_status                                               */
/*                                                                      */
/* Function is called by any of the send sub-types with the return code */
/* supplied by eng_send_message().  The feedback to the user is common. */
/*                                                                      */
/* Parameters: rc - the return code from the engine.                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_display_status(eng_rcode rc)
{
  switch(rc)
  {
    case(ENG_BUSY):
    case(ENG_RUNNING):
    {
      if (status.netlink == NetLink_Online)
        popup_open_dialogue(nb_messagetrans_lookup(message_block, "SENDMSG_Sending"));
      else
        popup_open_dialogue(nb_messagetrans_lookup(message_block, "SENDMSG_Queuing"));

      break;
    }
    case(ENG_NOMEMORY):
    {
      ncmui_error_display(34);
      break;
    }
    default:
    {
      ncmui_error_display(35);
    }
  }

}


/************************************************************************/
/* sendmsg_create_message_cbf                                           */
/*                                                                      */
/* Function is called by the email engine when it has created a new     */
/* MessageDescriptor for me to use for the Send.                        */
/*                                                                      */
/* Parameters: rc      - error code.                                    */
/*             msg     - MessageDescriptor allocated.                   */
/*             handle  - not used.                                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void sendmsg_create_message_cbf(eng_rcode rc, MessageDescriptor *msg, void *handle)
{
  NB_UNUSED(handle);

  dprintf(("UI", "compose_msg_cbf entered with msg id: %d\n", msg->ID));

  if (rc == ENG_COMPLETED)
  {
    if (sendmsg_build_screen(msg) == false)
    {
      ncmui_error_display(32);
      status.ui_locked = false;
      error_parser_failed();
    }
  }
  else
  {
    ncmui_error_display(31);
    status.ui_locked = false;
    error_parser_failed();
  }
}


/* ============================================================================================== */
/* ===================================== PAGE BUILDING CODE ===================================== */
/* ============================================================================================== */


/************************************************************************/
/* sendmsg_build_screen                                                 */
/*                                                                      */
/* Function is called when the SendMsg screen has to be displayed by    */
/* either Compose, Reply, MailTo: or potentially Forward.               */
/*                                                                      */
/* Parameters: msg   - MessageDescriptor with the relevant details.     */
/*                                                                      */
/* Returns:    true or false.                                           */
/*                                                                      */
/************************************************************************/
bool sendmsg_build_screen(MessageDescriptor *msg)
{
  bool			 rc = false;

  dprintf(("UI", "*******************************************************\n"));
  dprintf(("UI", "Send message %d request come in.\n", msg->ID));

  /* Tidy up the temp dir */
  ncmui_tidy_output_dir();

  rc = parser_parse_file(PageType_SendMsg, Template_SendMsg, Generated_SendMsg,
                          (void *) msg);

  if (rc == false)
  {
    /* *** FATAL ERROR *** */
    error_parser_failed();
    ncmui_error_display(28);
    /* Unlock the UI */
    status.ui_locked = false;
    return(false);
  }
  else
  {
    browserif_sendurl(Open_SendMsg, false);
    /* Unlock the UI */
    status.ui_locked = false;
    return(true);
  }

  dprintf(("UI", "FINISHED BUILDING SENDMSG PAGE\n"));
  dprintf(("UI", "*******************************************************\n"));
}


/************************************************************************/
/* sendmsg_active_comment_found                                         */
/*                                                                      */
/* Function is called when the UI page type is Send & an active comment */
/* is found in the web page being parsed.                               */
/*                                                                      */
/* Parameters: comment - The comment found by parser_parse_file().      */
/*             out     - FILE pointer to output file.                   */
/*             msg     - MessageDescriptor for message being output.    */
/*                       This is passed to parser_parse_file when read  */
/*                       is clicked on and passed back when an AC is    */
/*                       found.                                         */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_active_comment_found(char *comment, FILE *out, MessageDescriptor *msg)
{
  /* MessageId field */
  if (nb_case_insensitive_strcmp(comment, SendMsg_AC_ID) == 0)
  {
    dprintf(("UI", "Outputting sendmsg id\n"));
    fprintf(out, "%d", msg->ID);
  }
  /* Graphic Field */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_Graphic) == 0)
  {
    switch(status.state)
    {
      case(State_MailTo):
      case(State_Compose):	fprintf(out, SendMsg_Graphic_Compose);		break;
      case(State_Reply):	fprintf(out, SendMsg_Graphic_Compose);		break;
    }
  }
  /* Page Type */
//  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_Mode) == 0)
//  {
//    switch(status.state)
//    {
//      case(State_MailTo):	fprintf(out, SendMsg_Mode_MailTo);		break;
//      case(State_Compose):	fprintf(out, SendMsg_Mode_Compose);		break;
//      case(State_Reply):	fprintf(out, SendMsg_Mode_Compose);		break;
//    }
//  }
  /* Form Element Sizes */
  else if ( (nb_case_insensitive_strcmp(comment, SendMsg_AC_Field_X) == 0)	||
            (nb_case_insensitive_strcmp(comment, SendMsg_AC_Text_X) == 0)	||
            (nb_case_insensitive_strcmp(comment, SendMsg_AC_Text_Y) == 0)
          )
  {
    sendmsg_output_form_size(out, comment);
  }

  /* To field */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_To) == 0)
  {
    sendmsg_output_item(out, msg->to);
  }
  /* Subject field */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_Subject) == 0)
  {
    sendmsg_output_item(out, msg->subject);
  }
  /* CC field */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_CC) == 0)
  {
    sendmsg_output_item(out, msg->cc);
  }
  /* Body field */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_Body) == 0)
  {
    sendmsg_output_body(out, msg->entity_list);
  }
  else
  {
    dprintf(("UI", "UNKNOWN SENDMSG TAG\n"));
#ifdef DEBUGLIB
    fprintf(out, "<H1>Unknown tag '%s' received</H1><BR>\n", comment);
#endif
  }
}


/************************************************************************/
/* sendmsg_output_item                                                  */
/*                                                                      */
/* Function is called by sendmsg_active_comment_found() to output a     */
/* string, escaping it first.  A check is made to ensure that there is  */
/* valid data in the string first.                                      */
/*                                                                      */
/* Parameters: out  - pointer to output file.                           */
/*             item - string to be escaped and output, or possibly NULL.*/
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_output_item(FILE *out, char *item)
{
  esc_html_context	 context;

  if ( (item == NULL) || (strcmp(item, "") == 0) )
  {
    /* Do nothing.  There is no text to output */
  }
  else
  {
    context = NULL;
    while (escape_html_mem_to_file (item, out, 1, &context) == 0);
  }
}


/************************************************************************/
/* sendmsg_output_form_size                                             */
/*                                                                      */
/* Function is called when we have to output a form dimension.  This    */
/* is dependant on the screen mode.                                     */
/*                                                                      */
/* Parameters: out  - file pointer.                                     */
/*             item - Active comment to check size for.                 */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_output_form_size(FILE *out, char *item)
{
  int32		 x,y;

  nb_get_screenmode(0, &x, &y);

  switch(x)
  {
    case(ScreenMode_TV_X):
    {
      dprintf(("UI", "Outputting tv widths\n"));
      if (nb_case_insensitive_strcmp(item, SendMsg_AC_Field_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Field_X_TV"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_X_TV"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_Y) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_Y_TV"));
      break;
    }
    case(ScreenMode_VDU_X):
    {
      dprintf(("UI", "Outputting VDU widths\n"));
      if (nb_case_insensitive_strcmp(item, SendMsg_AC_Field_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Field_X_VDU"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_X_VDU"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_Y) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_Y_VDU"));
      break;
    }
    default:
    {
      dprintf(("UI", "Unknown Screen mode - assuming RiscPC! and using 640x480\n"));
      if (nb_case_insensitive_strcmp(item, SendMsg_AC_Field_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Field_X_VDU"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_X_VDU"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_Y) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_Y_VDU"));
      break;
    }
  }
}


/************************************************************************/
/* sendmsg_output_body                                                  */
/*                                                                      */
/* Function checks to see what mode we are in and then acts accordingly.*/
/* If the mode is Compose, then body will be empty, if Reply then it    */
/* will contain the first item in the Entity descriptor list, if MailTo */
/* then it will also be empty.                                          */
/*                                                                      */
/* Parameters: out  - file pointer.                                     */
/*             ptr  - Pointer to the entity descriptor in the message.  */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_output_body(FILE *out, EntityDescriptor *ptr)
{
  switch(status.state)
  {
    case(State_Compose):
    case(State_MailTo):
    {
      dprintf(("UI", "Nothing to output\n"));
      break;
    }
  }
}


/************************************************************************/
/* sendmsg_setup_messagedescriptor_field                                */
/*                                                                      */
/* Function is called by one of the Send message types to allocate      */
/* data retrieved from the HTML into the message descriptor.  The       */
/* location pointer must be malloc'd with enough space to store data.   */
/*                                                                      */
/* Parameters: data     - data retrieved from the HTML.                 */
/*             location - position to malloc and store the data at.     */
/*                                                                      */
/* Returns:    bool                                                     */
/*                                                                      */
/************************************************************************/
bool sendmsg_setup_messagedescriptor_field(char *data, char **location)
{
  char *ptr;

  if (!data)
  {
    dprintf(("", "if (!data) failed\n"));
    return(false);
  }
  else if (*data != NULL)
  {
    if ((ptr= malloc(strlen(data) + 5)) == NULL)
    {
      ncmui_error_display(1);
      return(false);
    }
    else
    {
      /* Do not FREE this malloc - that will be done by the engine in DestroyDescriptor() */
      strcpy(ptr, data);
      *location = ptr;
      return(true);
    }
  }
  else
  {
    dprintf(("", "Location null\n"));
    return(false);
  }
}


