/************************************************************************/
/* File:    SendMsg.c                                                   */
/* Purpose: Page parsing code for Compose, Reply, MailTo: screens.      */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Tue 06th October 1998                                 */
/*                Created.                                              */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "SendMsg.h"
#include "EscapeHTML.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */


/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* sendmsg_build_screen                                                 */
/*                                                                      */
/* Function is called when the SendMsg screen has to be displayed by    */
/* either Compose, Reply, MailTo: or potentially Forward.               */
/*                                                                      */
/* Parameters: msg   - MessageDescriptor with the relevant details.     */
/*                                                                      */
/* Returns:    true or false.                                           */
/*                                                                      */
/************************************************************************/
bool sendmsg_build_screen(MessageDescriptor *msg)
{
  bool			 rc = false;

  dprintf(("UI", "*******************************************************\n"));
  dprintf(("UI", "Send message %d request come in.\n", msg->ID));

  /* Tidy up the temp dir */
  ncmui_tidy_output_dir();

  rc = parser_parse_file(PageType_SendMsg, Template_SendMsg, Generated_SendMsg,
                          (void *) msg);

  if (rc == false)
  {
    /* *** FATAL ERROR *** */
    error_parser_failed();
    ncmui_error_display(28);
    /* Unlock the UI */
    status.ui_locked = false;
    return(false);
  }
  else
  {
    browserif_sendurl(Open_SendMsg, false);
    /* Unlock the UI */
    status.ui_locked = false;
    return(true);
  }

  dprintf(("UI", "FINISHED BUILDING SENDMSG PAGE\n"));
  dprintf(("UI", "*******************************************************\n"));
}


/************************************************************************/
/* sendmsg_setup_messagedescriptor_field                                */
/*                                                                      */
/* Function is called by one of the Send message types to allocate      */
/* data retrieved from the HTML into the message descriptor.  The       */
/* location pointer must be malloc'd with enough space to store data.   */
/*                                                                      */
/* Parameters: data     - data retrieved from the HTML.                 */
/*             location - position to malloc and store the data at.     */
/*                                                                      */
/* Returns:    bool                                                     */
/*                                                                      */
/************************************************************************/
bool sendmsg_setup_messagedescriptor_field(char *data, char **location)
{
  char *ptr;

  if (!data)
  {
    dprintf(("", "if (!data) failed\n"));
    return(false);
  }
  else if (*data != NULL)
  {
    if ((ptr= malloc(strlen(data) + 5)) == NULL)
    {
      ncmui_error_display(1);
      return(false);
    }
    else
    {
      /* Do not FREE this malloc - that will be done by the engine in DestroyDescriptor() */
      strcpy(ptr, data);
      *location = ptr;
      return(true);
    }
  }
  else
  {
    dprintf(("", "Location null\n"));
    return(false);
  }
}


/************************************************************************/
/* sendmsg_active_comment_found                                         */
/*                                                                      */
/* Function is called when the UI page type is Send & an active comment */
/* is found in the web page being parsed.                               */
/*                                                                      */
/* Parameters: comment - The comment found by parser_parse_file().      */
/*             out     - FILE pointer to output file.                   */
/*             msg     - MessageDescriptor for message being output.    */
/*                       This is passed to parser_parse_file when read  */
/*                       is clicked on and passed back when an AC is    */
/*                       found.                                         */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_active_comment_found(char *comment, FILE *out, MessageDescriptor *msg)
{
  /* MessageId field */
  if (nb_case_insensitive_strcmp(comment, SendMsg_AC_ID) == 0)
  {
    dprintf(("UI", "Outputting sendmsg id\n"));
    fprintf(out, "%d", msg->ID);
  }
  /* Graphic Field */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_Graphic) == 0)
  {
    switch(status.state)
    {
      case(State_MailTo):
      case(State_Compose):	fprintf(out, SendMsg_Graphic_Compose);		break;
      case(State_Reply):	fprintf(out, SendMsg_Graphic_Compose);		break;
    }
  }
  /* Page Type */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_Mode) == 0)
  {
    switch(status.state)
    {
      case(State_MailTo):	fprintf(out, SendMsg_Mode_MailTo);		break;
      case(State_Compose):	fprintf(out, SendMsg_Mode_Compose);		break;
      case(State_Reply):	fprintf(out, SendMsg_Mode_Compose);		break;
    }
  }
  /* Form Element Sizes */
  else if ( (nb_case_insensitive_strcmp(comment, SendMsg_AC_Field_X) == 0)	||
            (nb_case_insensitive_strcmp(comment, SendMsg_AC_Text_X) == 0)	||
            (nb_case_insensitive_strcmp(comment, SendMsg_AC_Text_Y) == 0)
          )
  {
    sendmsg_output_form_size(out, comment);
  }

  /* To field */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_To) == 0)
  {
    sendmsg_output_item(out, msg->to);
  }
  /* Subject field */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_Subject) == 0)
  {
    sendmsg_output_item(out, msg->subject);
  }
  /* CC field */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_CC) == 0)
  {
    sendmsg_output_item(out, msg->cc);
  }
  /* Body field */
  else if (nb_case_insensitive_strcmp(comment, SendMsg_AC_Body) == 0)
  {
    sendmsg_output_body(out, msg->entity_list);
  }
  else
  {
    dprintf(("UI", "UNKNOWN SENDMSG TAG\n"));
#ifdef DEBUGLIB
    fprintf(out, "<H1>Unknown tag '%s' received</H1><BR>\n", comment);
#endif
  }
}


/************************************************************************/
/* sendmsg_output_item                                                  */
/*                                                                      */
/* Function is called by sendmsg_active_comment_found() to output a     */
/* string, escaping it first.  A check is made to ensure that there is  */
/* valid data in the string first.                                      */
/*                                                                      */
/* Parameters: out  - pointer to output file.                           */
/*             item - string to be escaped and output, or possibly NULL.*/
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_output_item(FILE *out, char *item)
{
  esc_html_context	 context;

  if ( (item == NULL) || (strcmp(item, "") == 0) )
  {
    /* Do nothing.  There is no text to output */
  }
  else
  {
    context = NULL;
    while (escape_html_mem_to_file (item, out, 1, &context) == 0);
  }
}


/************************************************************************/
/* sendmsg_output_form_size                                             */
/*                                                                      */
/* Function is called when we have to output a form dimension.  This    */
/* is dependant on the screen mode.                                     */
/*                                                                      */
/* Parameters: out  - file pointer.                                     */
/*             item - Active comment to check size for.                 */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_output_form_size(FILE *out, char *item)
{
  int32		 x,y;

  nb_get_screenmode(0, &x, &y);

  switch(x)
  {
    case(ScreenMode_TV_X):
    {
      dprintf(("UI", "Outputting tv widths\n"));
      if (nb_case_insensitive_strcmp(item, SendMsg_AC_Field_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Field_X_TV"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_X_TV"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_Y) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_Y_TV"));
      break;
    }
    case(ScreenMode_VDU_X):
    {
      dprintf(("UI", "Outputting VDU widths\n"));
      if (nb_case_insensitive_strcmp(item, SendMsg_AC_Field_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Field_X_VDU"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_X_VDU"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_Y) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_Y_VDU"));
      break;
    }
    default:
    {
      dprintf(("UI", "Unknown Screen mode - assuming RiscPC! and using 640x480\n"));
      if (nb_case_insensitive_strcmp(item, SendMsg_AC_Field_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Field_X_VDU"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_X) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_X_VDU"));
      else if (nb_case_insensitive_strcmp(item, SendMsg_AC_Text_Y) == 0)
        fprintf(out, "%s", nb_messagetrans_lookup(message_block, "SENDMSG_Text_Y_VDU"));
      break;
    }
  }
}


/************************************************************************/
/* sendmsg_output_body                                                  */
/*                                                                      */
/* Function checks to see what mode we are in and then acts accordingly.*/
/* If the mode is Compose, then body will be empty, if Reply then it    */
/* will contain the first item in the Entity descriptor list, if MailTo */
/* then it will also be empty.                                          */
/*                                                                      */
/* Parameters: out  - file pointer.                                     */
/*             ptr  - Pointer to the entity descriptor in the message.  */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sendmsg_output_body(FILE *out, EntityDescriptor *ptr)
{
  switch(status.state)
  {
    case(State_Compose):
    case(State_MailTo):
    {
      dprintf(("UI", "Nothing to output\n"));
      break;
    }
  }
}

