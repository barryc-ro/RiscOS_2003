/************************************************************************/
/* File:    MailTo.c                                                    */
/* Purpose: Code relating to MailTo email sends.                        */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Thu 08th October 1998                                 */
/*                Created.                                              */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "Reply.h"
#include "BrowserIF.h"
#include "States.h"
#include "SendMsg.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */


/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */


/************************************************************************/
/* reply_selected_from_readmsg                                          */
/*                                                                      */
/* Function is called when the user clicks on Reply in the Read screen. */
/*                                                                      */
/* Parameters: msgid  - the messageid of the selected message.          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void reply_selected_from_readmsg(uint32 msgid)
{
  eng_rcode		 rc;

  dprintf(("UI", "reply_selected_from_readmsg with id: %d\n", msgid));

  status.state = State_Reply;

//  rc = eng_create_message(msgid, NULL, reply_create_message_cbf);

  /* Check the return code */
  switch(rc)
  {
    case(ENG_BUSY):	dprintf(("UI", "Engine is BUSY when creating message\n"));	break;
    case(ENG_RUNNING):	dprintf(("UI", "Engine create message RUNNING\n"));		break;
    case(ENG_NOMEMORY):
    {
      ncmui_error_display(30);
      status.ui_locked = false;
      error_parser_failed();
    }
    default:		ncmui_error_display(29);					break;
  }
}


/************************************************************************/
/* mailto_send_message_request                                          */
/*                                                                      */
/* Function is called when the user clicks on a MailTo: HTML link on    */
/* the web.                                                             */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void reply_send_message_request(int num_args, url_param *arg)
{
//  eng_rcode		 rc;
//  uint32 counter;
//
//  /* Set the state to MailTo */
//  status.state = State_MailTo;
//
//  /* Setup the global MessageDescriptor */
//  if ((global_msg = malloc(sizeof(MessageDescriptor))) == NULL)
//  {
//    ncmui_error_display(1);
//  }
//  else
//  {
//    global_msg->ID = 0;
//    global_msg->flags = 0;
//    global_msg->entity_num = 0;
//    global_msg->to = NULL;
//    global_msg->cc = NULL;
//    global_msg->fromreal = NULL;
//    global_msg->fromaddr = NULL;
//    global_msg->subject = NULL;
//    global_msg->charset = NULL;
//    global_msg->datestr = NULL;
//
//    /* OK, now loop through the arguments and fill in the MessageDescriptor */
//    for (counter = 0; counter < num_args; counter++)
//    {
//      dprintf(("UI", "Item '%s': '%s'\n", arg[counter].name, arg[counter].value));
//
//      if (nb_case_insensitive_strcmp(arg[counter].name, MailTo_Tag_To) == 0)
//        sendmsg_setup_messagedescriptor_field(arg[counter].value, &global_msg->to);
//    }
//
//    dprintf(("UI", "MessageDescritor:\n"));
//    dprintf(("UI", "   id:      %d\n", global_msg->ID));
//    dprintf(("UI", "   to:      %s\n", global_msg->to));
//    dprintf(("UI", "   subject: %s\n", global_msg->subject));
//
//    rc = eng_create_message(0, (void *) global_msg, mailto_create_message_cbf);
//
//    /* Check the return code */
//    switch(rc)
//    {
//      case(ENG_BUSY):		dprintf(("UI", "Engine is BUSY when creating message\n")); break;
//      case(ENG_RUNNING):	dprintf(("UI", "Engine create message RUNNING\n"));	break;
//      case(ENG_NOMEMORY):
//      {
//        ncmui_error_display(30);
//        status.ui_locked = false;
//        error_parser_failed();
//      }
//      default:		ncmui_error_display(29);					break;
//    }
//  }
}


/************************************************************************/
/* reply_create_message_cbf                                             */
/*                                                                      */
/* Function is called by the email engine when it has created a new     */
/* MessageDescriptor for me to use for the Reply.                       */
/*                                                                      */
/* Parameters: rc      - error code.                                    */
/*             msg     - MessageDescriptor allocated.                   */
/*             handle  - not used.                                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void reply_create_message_cbf(eng_rcode rc, MessageDescriptor *msg, void *handle)
{
  MessageDescriptor *ptr;

  ptr = (MessageDescriptor *) handle;

  dprintf(("UI", "reply_msg_cbf entered with msg id: %d\n", msg->ID));
  dprintf(("UI", "to is: %s\n", ptr->to));

  if (rc == ENG_COMPLETED)
  {
    /* We must setup the MessageDescriptor
     *
     * To field */
    sendmsg_setup_messagedescriptor_field(ptr->to, &msg->to);
    /* Subject */
    sendmsg_setup_messagedescriptor_field(ptr->subject, &msg->subject);
    /* CC*/
    sendmsg_setup_messagedescriptor_field(ptr->cc, &msg->cc);
    /* Body */

    if (sendmsg_build_screen(msg) == false)
    {
      ncmui_error_display(32);
      status.ui_locked = false;
      error_parser_failed();
    }
  }
  else
  {
    ncmui_error_display(31);
    status.ui_locked = false;
    error_parser_failed();
  }
}


/************************************************************************/
/* reply_output_body                                                    */
/*                                                                      */
/* Function outputs the body text when the Active Comment is found.     */
/*                                                                      */
/* Parameters: out  - location in HTML file to place text.              */
/*             ptr  - pointer to entity descriptor                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void reply_output_body(FILE *out, EntityDescriptor *ptr)
{
  FILE			*in = NULL;
  char			 c = 'a';

  in = fopen(ptr->fname, "r");

  if (in != NULL)
  {
    do
    {
      c = getc(in);
      /* Check to see if we have retrieved the EOF marker */
      if (!feof(in))
      {
        /* OK, so now check for Active Comment and act accordingly */
        fprintf(out, "%c", c);
      }
    }
    while (!feof(in));

    fclose(in);
  }
}
