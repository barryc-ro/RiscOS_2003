/************************************************************************/
/* File:    UserSel.c                                                   */
/* Purpose: User Selection code.                                        */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Fri 16th October 1998                                 */
/*                Created.                                              */
/************************************************************************/


#include "../Build/Env.h"		/* Include Build Environment file.  This MUST be 1st before
					   any other preprocessor command */

/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "UserSel.h"
#include "Parser.h"
#include "States.h"
#include "SendMsg.h"
#include "PopUp.h"
#include "WebMail.h"
#include "Inbox.h"
#include "Exit.h"

#define STB_Exit_Hack		"NCMail:?page=Enter&button=Enter&exiton=file:/<ncfresco$home>=file:/<ncfresco$home>"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */


/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

UserSelStatus	user_details;


static ncma_user_t  ncma_tags[] =
{
  { "", "", "" } ,
  { "POP3_EMAIL_ADDRESS1", "POP3_EMAIL_USERNAME1", "POP3_EMAIL_PASSWORD1" } ,
  { "POP3_EMAIL_ADDRESS2", "POP3_EMAIL_USERNAME2", "POP3_EMAIL_PASSWORD2" } ,
  { "POP3_EMAIL_ADDRESS3", "POP3_EMAIL_USERNAME3", "POP3_EMAIL_PASSWORD3" } ,
  { "POP3_EMAIL_ADDRESS4", "POP3_EMAIL_USERNAME4", "POP3_EMAIL_PASSWORD4" } ,
  { "POP3_EMAIL_ADDRESS5", "POP3_EMAIL_USERNAME5", "POP3_EMAIL_PASSWORD5" }
};

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* usersel_message_received                                             */
/*                                                                      */
/* Function is called when the library receives an ncmail: message from */
/* the User Selection screen.                                           */
/*                                                                      */
/* Parameters: num_args - number of arguments passed in arg.            */
/*             arg      - list of the name= & value= bits from the HTML */
/*                                                                      */
/* Returns:    TRUE.                                                    */
/*                                                                      */
/************************************************************************/
bool usersel_message_received(int num_args, url_param *  arg)
{
  int32		 counter = -1;
  bool		 found = false;

  dprintf(("UI", "usersel_message_received entered (args: %d)\n", num_args));

  /* Now lock the UI to prevent clicks until whatever item is selected is unlocked */
  status.ui_locked = true;

  do
  {
    counter++;
    dprintf(("UI", "Name (%d) %s\n", counter, arg[counter].name));
    dprintf(("UI", "Value:   %s\n", arg[counter].value));

    /* Start User Selection */
    if (nb_case_insensitive_strcmp(arg[counter].value, UserSel_Start) == 0)
    {
      usersel_start_selected(num_args, arg);
      found = true;
    }
    /* OK Button */
    else if (nb_case_insensitive_strcmp(arg[counter].name, UserSel_OK) == 0)
    {
      usersel_ok_selected(num_args, arg);
      found = true;
    }
    /* Cancel Button */
    else if (nb_case_insensitive_strcmp(arg[counter].name, UserSel_Cancel) == 0)
    {
      usersel_cancel_selected(num_args, arg);
      found = true;
    }
  }
  while ( (found == false) && (counter < num_args) );

  if (found == false)
  {
    ncmui_error_display(5);
    status.ui_locked = false;
  }
  return(true);
}


/************************************************************************/
/* usersel_start_selected                                               */
/*                                                                      */
/* Function is called when the user selection screen is required by     */
/* NCMA.                                                                */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void usersel_start_selected(int num_args, url_param *  arg)
{
  bool		 rc = false;
  int32		 num_users = 0;

  dprintf(("UI", "usersel_start_selected\n"));

  ncmui_create_output_directories();

  /* Reset the struct */
  usersel_reset_struct();

  dprintf(("UI", "Reset struct complete\n"));

  user_details.email_mode = usersel_email_selected(num_args, arg);

  dprintf(("UI", "Number of users: %d\n", num_users));
  dprintf(("UI", "Email Mode:      %d\n", user_details.email_mode));


#ifdef CHECK_FOR_NCMALITE
  /* Check to see what architecture we are running on.  If the NCMA module is not present, setup
   * some fake data
   */
  if (nb_ensure_module(0, "NCMALite") == FALSE)
  {
    dprintf(("UI", "Getting NCMA Details (NCMA **NOT** present)\n"));
    /* We are probably running on a RiscPC, so setup Fake data */
    rc = usersel_get_fake_user_details(&num_users);
  }
  else
  {
    dprintf(("UI", "Getting NCMA Details (NCMA present)\n"));
    rc = usersel_get_user_details(&num_users);
  }
#else
  dprintf(("UI", "Getting NCMA Details (#else clause)\n"));
  rc = usersel_get_user_details(&num_users);
#endif

  if (rc == false)
  {
    dprintf(("UI", "usersel_get_user_details returned false\n"));

    /* Invalid data.  If in email mode then we throw an error.  If not we proceed. */
    if (user_details.email_mode == true)
    {
      dprintf(("UI", "we are in email mode\n"));
      /* There was badly formatted data included */
      popup_1_open_dialogue(nb_messagetrans_lookup(message_block, "USERSEL_BadData"),
                            nb_messagetrans_lookup(message_block, "BUTTON_OK_Default"),
                            usersel_popup_cbf,
                            NULL);
    }
    else
    {
      dprintf(("UI", "we are not in email mode\n"));
      /* Not in email mode.  So we don't have to worry about no users */
      usersel_call_ncma(NCMA_Success);
    }
  }
  else
  {
    dprintf(("UI", "rc was not false\n"));
    if (num_users == 0)
    {
      dprintf(("UI", "No users\n"));
      if (user_details.email_mode == true)
      {
        /* Cannont go any further */
        popup_1_open_dialogue(nb_messagetrans_lookup(message_block, "USERSEL_EmailNoUser"),
                              nb_messagetrans_lookup(message_block, "BUTTON_OK_Default"),
                              usersel_popup_cbf,
                              NULL);
        usersel_reset_struct();
      }
      else
      {
        /* Call NCMA */
        usersel_call_ncma(NCMA_Success);
      }
    }
    else if (num_users == 1)
    {
      dprintf(("UI", "One user\n"));
      if (usersel_setup_one_valid_user() == true)
      {
        /* Call NCMA */
        usersel_call_ncma(NCMA_Success);
      }
      else
      {
        popup_1_open_dialogue(nb_messagetrans_lookup(message_block, "USERSEL_BadData"),
                              nb_messagetrans_lookup(message_block, "BUTTON_OK_Default"),
                              usersel_popup_cbf,
                              NULL);
        usersel_reset_struct();
      }
    }
    else
    {
      /* More than 1 user */
      dprintf(("UI", "Multiple users\n"));
      usersel_build_screen();
    }
  }
}



/************************************************************************/
/* usersel_ok_selected                                                  */
/*                                                                      */
/* Function is called if the user has clicked on the Continue button in */
/* the screen.                                                          */
/*                                                                      */
/* Parameters: url params.                                              */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void usersel_ok_selected(int num_args, url_param *arg)
{
  int32		 counter;
  int32		 user = 0;

  dprintf(("UI", "OK button pressed\n"));

  for (counter = 0; counter < num_args; counter++)
  {
    if (nb_case_insensitive_strcmp(arg[counter].name, UserSel_User) == 0)
    {
      dprintf(("UI", "Value: %s\n", arg[counter].value));
      user = atoi(arg[counter].value);
      dprintf(("UI", "Setup user: %d\n", user));
    }
  }

  /* Setup the system variables */
  usersel_setup_sysvars(user);

  /* Call NCMA */
  usersel_call_ncma(NCMA_Success);
}


/************************************************************************/
/* usersel_cancel_selected                                              */
/*                                                                      */
/* Function is called if the user has clicked on the Cancel button in   */
/* the screen.                                                          */
/*                                                                      */
/* Parameters: url params.                                              */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void usersel_cancel_selected(int num_args, url_param *arg)
{
  NB_UNUSED(num_args);
  NB_UNUSED(arg);

  dprintf(("UI", "Cancel button pressed\n"));

  usersel_reset_struct();

  /* Call NCMA */
  usersel_call_ncma(NCMA_Failure);
}


/************************************************************************/
/* usersel_email_selected                                               */
/*                                                                      */
/* Function is called to check to see which button the user clicked on. */
/* This is required because if there are no users and connect was       */
/* pressed we don't want to throw up an error.                          */
/*                                                                      */
/* Parameters: url params.                                              */
/*                                                                      */
/* Returns:    true (email pressed), false (connect pressed).           */
/*                                                                      */
/************************************************************************/
bool usersel_email_selected(int num_args, url_param *arg)
{
  int32		 counter = -1;
  bool		 found = false;

  do
  {
    counter++;
    dprintf(("UI", "Name[%d]: '%s', Value: '%s'\n", counter,arg[counter].name, arg[counter].value));

    if (nb_case_insensitive_strcmp(arg[counter].name, UserSel_Mode) == 0)
    {
      if (nb_case_insensitive_strcmp(arg[counter].value, UserSel_Mode_Email) == 0)
      {
        dprintf(("UI", "*** WE ARE IN EMAIL MODE\n"));
        return(true);
      }
      else
      {
        dprintf(("UI", "*** WE ARE IN CONNECT MODE\n"));
        return(false);
      }
    }
  }
  while ( (found == false) && (counter < num_args) );

  dprintf(("UI", "Didn't match\n"));

  return(false);
}


/************************************************************************/
/* usersel_build_screen                                                 */
/*                                                                      */
/* Function is called to build the HTML page listing all the users.     */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
bool usersel_build_screen(void)
{
  bool		rc;

  /* Parse Inbox Listing file and build proper screen */
  ncmui_tidy_output_dir();

  rc = parser_parse_file(PageType_UserSel, Template_UserSel, Generated_UserSel, NULL);
  dprintf(("UI", "Finished building file\n"));

  if (rc == true)
  {
    if (browserif_sendurl(Open_UserSel, false) == false)
    {
      ncmui_error_display(22);
      /* We are screwed.  Set status.state to Inbox before calling parser failed so that it doesn't
       * go into an infinite loop.
       */
      status.state = State_Inbox;
      error_parser_failed();
    }
    /* Unlock the UI */
    status.state = State_UserSel;
    status.ui_locked = false;
    return(true);
  }
  else
  {
    ncmui_error_display(21);
    dprintf(("", "State: %d\n", status.state));
    error_parser_failed();
    /* Unlock the UI */
    status.ui_locked = false;
    return(false);
  }

}


/************************************************************************/
/* usersel_active_comment_found                                         */
/*                                                                      */
/* Function is called when the UI page type is User & an active comment */
/* is found in the web page being parsed.                               */
/*                                                                      */
/* Parameters: comment - The comment found by parser_parse_file().      */
/*             out     - FILE pointer to output file.                   */
/*             handle  - Data to be passed through.                     */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void usersel_active_comment_found(char *comment, FILE *out, void *handle)
{
  NB_UNUSED(handle);

  if (nb_case_insensitive_strcmp(comment, UserSel_AC_Users) == 0)
  {
    usersel_output_users(out);
  }
  /* Not a known tag */
  else
  {
    ncmui_error_display(11);
#ifdef DEBUGLIB
    fprintf(out, "<H1>Unknown tag '%s' received</H1><BR>\n", comment);
#endif
  }
}


/************************************************************************/
/* usersel_output_users                                                 */
/*                                                                      */
/* Function outputs the HTML containing the list of users.              */
/*                                                                      */
/* Parameters: file pointer.                                            */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void usersel_output_users(FILE *out)
{
  uint32		 counter;
  char			*token = NULL;
  int			 len = 0;

  dprintf(("UI", "usersel_output_users\n"));

  /* Get length of Messagetrans token */
  len = nb_messagetrans_token_length(message_block, "USERSEL_UserRow");
  dprintf(("UI", "Len: %d\n", len));

  if ((token = malloc(len+10)) == NULL)
  {
    ncmui_error_display(1);
  }
  else
  {
    /* Get token from messages file */
    strcpy(token, nb_messagetrans_lookup(message_block, "USERSEL_UserRow"));
    dprintf(("UI", "Token:  %s\n",token));

    for (counter = 0; counter < UserSel_NumUsers; counter++)
    {
      dprintf(("UI", "Looping (%d)\n", counter));
      dprintf(("UI", "Token:  %s\n",token));
      usersel_output_user_line(out, counter, token, len);
    }
    free(token);
  }
}


/************************************************************************/
/* usersel_output_user_line                                             */
/*                                                                      */
/* Function takes data from the output_users function and creates the   */
/* necessary HTML.                                                      */
/*                                                                      */
/* Parameters: out  - file pointer.                                     */
/*             item - item number to output.                            */
/*             html - MessageTrans token stored in the string.          */
/*             len  - length of the HTML token.                         */
/*                                                                      */
/* Returns:    bool.                                                    */
/*                                                                      */
/************************************************************************/
bool usersel_output_user_line(FILE *out, uint32 item, char *html, uint32 len)
{
  bool			 rc1 = false, rc2 = false;
  char			*output_line = NULL;
  char			*esc_name = NULL, *esc_addr = NULL;

  /* Check to see if either the name or address are empty.  If so don't output. */
  if ( (nb_string_empty(user_details.user[item].name) == TRUE) ||
       (nb_string_empty(user_details.user[item].address) == TRUE) ||
       (nb_string_empty(user_details.user[item].password) == TRUE)
     )
  {
    dprintf(("UI", "Empty (%d)\n", item));
    return(false);
  }
  else
  {
    dprintf(("UI", "Name:    %s\n", user_details.user[item].name));
    dprintf(("UI", "Address: %s\n", user_details.user[item].address));

    rc1 = inbox_build_intray_element(user_details.user[item].name, &esc_name, 0);
    rc2 = inbox_build_intray_element(user_details.user[item].address, &esc_addr, 0);

    if ( (rc1 == false) || (rc2 == false) )
    {
      return(false);
    }
    else
    {
      if ((output_line= malloc(len + strlen(UserSel_Selected) + strlen(esc_name) +
                               strlen(esc_addr) + 2)) == NULL)
      {
        ncmui_error_display(1);
      }
      else
      {
        /* Output the escaped data */
        if (item == 0)
        {
          /* First item, must have UserSel_Selected added */
          sprintf(output_line, html, UserSel_Selected,
                                     item,
                                     user_details.user[item].name,
                                     user_details.user[item].address);
        }
        else
        {
          sprintf(output_line, html, " ",
                                     item,
                                     user_details.user[item].name,
                                     user_details.user[item].address);
        }
        dprintf(("UI", "Outputting line: %s\n", output_line));
        fprintf(out, "%s\n", output_line);

        /* Tidy up */
        if (output_line != NULL)
          free(output_line);
      }
      if (esc_name != NULL)
        free(esc_name);
      if (esc_addr != NULL)
        free(esc_addr);
    }
    return(true);
  }
}


/************************************************************************/
/* usersel_setup_one_valid_user                                         */
/*                                                                      */
/* Function is called to setup the user details if there is only one    */
/* user in the box.  We need to find out which number it is and then    */
/* call usersel_setup_sysvars().                                        */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    true (success), false (incomplete data)                  */
/*                                                                      */
/************************************************************************/
bool usersel_setup_one_valid_user(void)
{
  int32		counter;
  bool		name = true;
  bool		address = true;
  bool		password = true;
  bool		found = false;

  /* Pop3 server */
  if (nb_string_empty(user_details.pop3_server) == TRUE)
  {
    return(false);
  }
  /* SMTP server */
  if (nb_string_empty(user_details.smtp_server) == TRUE)
  {
    return(false);
  }

  for (counter = 0; counter < UserSel_NumUsers; counter++)
  {
    name = true;
    address = true;
    password = true;

    /* User Name */
    if (nb_string_empty(user_details.user[counter].name) == TRUE)
    {
      name = false;
    }
    /* Password */
    if (nb_string_empty(user_details.user[counter].password) == TRUE)
    {
      password = false;
    }
    /* Address */
    if (nb_string_empty(user_details.user[counter].address) == TRUE)
    {
      address = false;
    }

    if ((name == true) && (address == true) && (password == true))
    {
      found = true;
      usersel_setup_sysvars(counter);
    }
  }
  return(found);
}


/************************************************************************/
/* usersel_boot_ncma                                                    */
/*                                                                      */
/* Function kicks NCMA (hopefully) to build it's cache.                 */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void usersel_boot_ncma(void)
{
  _kernel_swi_regs	 regs;

  dprintf(("UI", "Calling NCMA MiscOP\n"));

  regs.r[0] = NCMA_MISCOP_PRECONNECT;
  _kernel_swi(NCMA_MiscOp, &regs, &regs);

  return;
}

/************************************************************************/
/* usersel_get_user_details                                             */
/*                                                                      */
/* Function extracts the data from the smartcard, storing it in the     */
/* global struct and then returns the number of users on the box.       */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    true (success), false (badly formatted data)             */
/*                                                                      */
/************************************************************************/
bool usersel_get_user_details(int32 *num_users)
{
  int32			 counter, num;
  bool			 rc;
  char			*poll_delay_tmp = NULL;

  dprintf(("UI", "Getting user details\n"));

  /* Tell NCMA to build its Cache */
  usersel_boot_ncma();

  /* Get POP3 Server */
  rc = usersel_get_tag_details(NCMA_Tag_POP3_SERVER, &user_details.pop3_server);
  if (rc == false)
    return(false);

  /* Get SMTP Server */
  rc = usersel_get_tag_details(NCMA_Tag_SMTP_SERVER, &user_details.smtp_server);
  if (rc == false)
    return(false);

  /* Get Poll For Mail - Not setup yet, so set to on for default. */
  user_details.poll_for_mail = true;

  /* Get Poll Delay */
  rc = usersel_get_tag_details(NCMA_Tag_POLL_DELAY, &poll_delay_tmp);
  if (rc == false)
  {
    /* As timeout isn't configurable in ISPCapture or NCOptions set to default. */
    user_details.poll_delay = UserSel_Timeout_Default;
  }
  else
  {
    user_details.poll_delay = atoi(poll_delay_tmp);
    free(poll_delay_tmp);
  }

  /* Do Users */
  for (counter = 0; counter < UserSel_NumUsers; counter++)
  {
    dprintf(("UI", "User     [%d]: %s\n", counter, ncma_tags[counter+1].user));
    dprintf(("UI", "Password [%d]: %s\n", counter, ncma_tags[counter+1].password));
    dprintf(("UI", "Address  [%d]: %s\n", counter, ncma_tags[counter+1].address));

    /* User Name */
    rc = usersel_get_tag_details(ncma_tags[counter+1].user, &user_details.user[counter].name);
    if (rc == false)
      return(false);
    /* Password */
    rc=usersel_get_tag_details(ncma_tags[counter+1].password, &user_details.user[counter].password);
    if (rc == false)
      return(false);
    /* Email Address */
    rc = usersel_get_tag_details(ncma_tags[counter+1].address, &user_details.user[counter].address);
    if (rc == false)
      return(false);
  }

  num = 0;
  rc = usersel_validate_data(&num);
  *num_users = num;

  dprintf(("UI", "Number of users: %d\n", num));
  return(rc);
}

/************************************************************************/
/* usersel_get_tag_details                                              */
/*                                                                      */
/* Function calls NCMA, retrieves the length of the tag, allocates space*/
/* and then fetches the data.                                           */
/*                                                                      */
/* Parameters: tag name.                                                */
/*             pointer to store data at.                                */
/*                                                                      */
/* Returns:    true (success), false (problem).                         */
/*                                                                      */
/************************************************************************/
bool usersel_get_tag_details(char *tag, char **location)
{
  _kernel_swi_regs	 regs;
  _kernel_oserror	*er;
  char			*ptr = NULL;
  int32			 len;

  dprintf(("UI", "Get Tag: %s\n", tag));

  regs.r[0] = (int) tag;
  regs.r[1] = NULL;
  regs.r[2] = 0;

  er = _kernel_swi(NCMA_CacheEnquiry, &regs, &regs);
  if (er != NULL)
  {
    dprintf(("UI", "Cache Enquiry get length failed with number %d and text:\n", er->errnum));
    dprintf(("UI", "  %s\n", er->errmess));
    return(false);
  }
  else
  {
    dprintf(("UI", "Length of tag: %d\n", regs.r[0]));
    len = regs.r[0];

    if (len < 0)
    {
      dprintf(("UI", "Tag length of -1 returned\n"));
      return(false);
    }
    else if (len == 0)
    {
      dprintf(("UI", "Tag length of 0 returned\n"));
      *location = NULL;
      return(true);
    }
    else
    {
      if ((ptr= malloc(len + 2)) == NULL)
      {
        dprintf(("UI", "Memory allocation failed\n"));
        return(false);
      }
      else
      {
        regs.r[0] = (int) tag;
        regs.r[1] = (int) ptr;
        regs.r[2] = len;

        er = _kernel_swi(NCMA_CacheEnquiry, &regs, &regs);

        if (er != NULL)
        {
          dprintf(("UI", "Cache Enquiry failed with number %d and text:\n", er->errnum));
          dprintf(("UI", "  %s\n", er->errmess));
          free(ptr);
          return(false);
        }
        else
        {
          dprintf(("UI", "Tag '%s' returned data: '%s'\n", tag, ptr));
          /* Do not free 'ptr' here */
          *location = ptr;
          return(true);
        }
      }
    }
  }
}

#ifdef CHECK_FOR_NCMALITE

  /************************************************************************/
  /* usersel_get_fake_user_details                                        */
  /*                                                                      */
  /* Function sets up fake user details for testing purposes.             */
  /*                                                                      */
  /* Parameters: void.                                                    */
  /*                                                                      */
  /* Returns:    true (success), false (badly formatted data)             */
  /*                                                                      */
  /************************************************************************/
  bool usersel_get_fake_user_details(int32 *num_users)
  {
    FILE	*in = NULL;
    int32	 num;
    bool	 rc;
    bool	 endoffile = false;
    char	 tokenname[50];
    char	 temp[50];

    dprintf(("UI", "Getting FAKE user details\n"));

    in = fopen(UserSel_Fake_Choices, "r");

    if (in == NULL)
    {
      return(false);
    }
    else
    {
      dprintf(("UI", "File opened\n"));
      num = 0;

      do
      {
        fscanf(in, "%s ", tokenname);

        if (feof(in))
        {
          endoffile = true;
        }
        else
        {
          dprintf(("UI", "Read token: '%s'\n", tokenname));
          /* POP3 Server */
          if (nb_case_insensitive_strcmp(UserSel_Choices_POP3, tokenname) == 0)
          {
            fscanf(in, "%s\n", temp);
            nb_strcpy_malloc(&user_details.pop3_server, temp);
          }
          /* SMTP Server */
          else if (nb_case_insensitive_strcmp(UserSel_Choices_SMTP, tokenname) == 0)
          {
            fscanf(in, "%s\n", temp);
            nb_strcpy_malloc(&user_details.smtp_server, temp);
          }
          /* Poll For Mail */
          else if (nb_case_insensitive_strcmp(UserSel_Choices_Poll, tokenname) == 0)
          {
            dprintf(("UI", "Found poll for mail\n"));
            fscanf(in, "%d\n", &user_details.poll_delay);
            user_details.poll_for_mail = true;
          }

          /* User Details
           * The email address *must* be the last item on the list, to terminate the user
           */
          else if (nb_case_insensitive_strcmp(UserSel_Choices_Address, tokenname) == 0)
          {
            dprintf(("UI", "found email address\n"));
            fscanf(in, "%s\n", temp);
            nb_strcpy_malloc(&user_details.user[num].address, temp);
            num++;
          }
          /* User Name */
          else if (nb_case_insensitive_strcmp(UserSel_Choices_User, tokenname) == 0)
          {
            fscanf(in, "%s\n", temp);
            nb_strcpy_malloc(&user_details.user[num].name, temp);
          }
          /* Password */
          else if (nb_case_insensitive_strcmp(UserSel_Choices_Password, tokenname) == 0)
          {
            fscanf(in, "%s\n", temp);
            nb_strcpy_malloc(&user_details.user[num].password, temp);
          }
        }
      }
      while ( (!feof(in)) && (endoffile == FALSE) && (num < UserSel_NumUsers) );

      fclose(in);
    }

    dprintf(("UI", "Email Details (number of users %d)\n", num));
    dprintf(("UI", "   POP3:    %s\n", user_details.pop3_server));
    dprintf(("UI", "   SMTP:    %s\n", user_details.smtp_server));
    dprintf(("UI", "   Poll:    %d\n", user_details.poll_delay));

    rc = usersel_validate_data(&num);

    *num_users = num;
    return(rc);
  }

#endif


/************************************************************************/
/* usersel_validate_data                                                */
/*                                                                      */
/* Function is called when all the data has been read off the smartcard */
/* and we need to check if it is intact.                                */
/*                                                                      */
/* Parameters: num_users - return number of valid users found.          */
/*                                                                      */
/* Returns:    true (intact), false (incomplete).                       */
/*                                                                      */
/************************************************************************/
bool usersel_validate_data(int32 *num_users)
{
  int32		counter;
  int32		users;
  bool		name = true;
  bool		address = true;
  bool		password = true;

  users = 0;

  /* Pop3 server */
  if (nb_string_empty(user_details.pop3_server) == TRUE)
  {
    return(false);
  }
  /* SMTP server */
  if (nb_string_empty(user_details.smtp_server) == TRUE)
  {
    dprintf(("", "SMTP server invalid\n"));
    return(false);
  }

  for (counter = 0; counter < UserSel_NumUsers; counter++)
  {
    name = true;
    address = true;
    password = true;

    /* User Name */
    if (nb_string_empty(user_details.user[counter].name) == TRUE)
    {
      name = false;
    }
    /* Password */
    if (nb_string_empty(user_details.user[counter].password) == TRUE)
    {
      password = false;
    }
    /* Address */
    if (nb_string_empty(user_details.user[counter].address) == TRUE)
    {
      address = false;
    }
    else
    {
      if (eng_validate_email_address(user_details.user[counter].address) == false)
        address = false;
    }

    if ( ((name == false) && (address == false) && (password == false)) ||
         ((name == true) && (address == true) && (password == true)) )
    {
      /* Valid data must be all filled in, or all empty.  If all filled in, increment users */
      if ((name == true) && (address == true) && (password == true))
        users++;
    }
    else
    {
      dprintf(("UI", "Failed on user %d\n", counter));
      *num_users = users;
      return(false);
    }
  }
  /* If we got here it is good */
  dprintf(("UI", "All valid\n"));
  *num_users = users;
  return(true);
}

/************************************************************************/
/* usersel_initialise                                                   */
/*                                                                      */
/* Function is called on startup to make sure all the pointers are NULL */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void usersel_initialise(void)
{
  int32		 counter;

  user_details.email_mode = false;
  user_details.poll_for_mail = false;
  user_details.poll_delay = 0;

  /* POP3 Server */
  user_details.pop3_server = NULL;
  /* SMTP server */
  user_details.smtp_server = NULL;

  for (counter = 0; counter < UserSel_NumUsers; counter++)
  {
    /* User Name */
    user_details.user[counter].name = NULL;
    /* Password */
    user_details.user[counter].password = NULL;
    /* Address */
    user_details.user[counter].address = NULL;
  }
}


/************************************************************************/
/* usersel_reset_struct                                                 */
/*                                                                      */
/* Function will reset the UserSelDetails struct.                       */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void usersel_reset_struct(void)
{
  int32			 counter;

  user_details.email_mode = false;
  user_details.poll_for_mail = false;
  user_details.poll_delay = 0;

  dprintf(("UI", "Resetting data struct\n"));

  /* Pop3 server */
  if (user_details.pop3_server)
  {
    free(user_details.pop3_server);
    user_details.pop3_server = NULL;
  }
  /* SMTP server */
  if (user_details.smtp_server)
  {
    free(user_details.smtp_server);
    user_details.smtp_server = NULL;
  }

  for (counter = 0; counter < UserSel_NumUsers; counter++)
  {
    /* User Name */
    if (user_details.user[counter].name)
    {
      free(user_details.user[counter].name);
      user_details.user[counter].name = NULL;
    }
    /* Password */
    if (user_details.user[counter].password)
    {
      free(user_details.user[counter].password);
      user_details.user[counter].password = NULL;
    }
    /* Address */
    if (user_details.user[counter].address)
    {
      free(user_details.user[counter].address);
      user_details.user[counter].address = NULL;
    }
  }
}


/************************************************************************/
/* usersel_setup_sysvars                                                */
/*                                                                      */
/* Function sets up the system variables based on the user selection.   */
/*                                                                      */
/* Parameters: num -  user number to setup.                             */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void usersel_setup_sysvars(int32 num)
{
  char		poll[10];

  /* POP3 Server */
  _kernel_setenv(UserSel_SysVar_POP3, user_details.pop3_server);
  /* SMTP Server */
  _kernel_setenv(UserSel_SysVar_SMTP, user_details.smtp_server);
  /* Poll Delay */
  if (user_details.poll_for_mail == true)
  {
    sprintf(poll, "%d", user_details.poll_delay);
    _kernel_setenv(UserSel_SysVar_Poll, poll);
  }
  else
  {
    _kernel_setenv(UserSel_SysVar_Poll, "0");
  }

  /* User Name */
  _kernel_setenv(UserSel_SysVar_User, user_details.user[num].name);
  /* Password */
  _kernel_setenv(UserSel_SysVar_Password, user_details.user[num].password);
  /* Email Address */
  _kernel_setenv(UserSel_SysVar_Address, user_details.user[num].address);

  /* Inform the engine here: */
  eng_change_user();
}


/************************************************************************/
/* usersel_popup_cbf                                                    */
/*                                                                      */
/* Function is called when something is wrong such as the user has      */
/* entered bad data in the setup screens, or no users are configured and*/
/* we must return to NCMA immediately.                                  */
/*                                                                      */
/* Parameters: popup cbf params.                                        */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void usersel_popup_cbf(bool default_sel, void *handle)
{
  NB_UNUSED(default_sel);
  NB_UNUSED(handle);

  dprintf(("UI", "usersel_popup_cbf entered\n"));

  /* Call NCMA */
  popup_close_dialogue();
  usersel_call_ncma(NCMA_Failure);
}




/************************************************************************/
/* usersel_call_ncma                                                    */
/*                                                                      */
/* Function is called when we need to pass something to NCMA.           */
/*                                                                      */
/* Parameters: command - command to execute in NCMA.                    */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void usersel_call_ncma(char *command)
{
#ifdef DEBUGLIB
  if (strcmp(command, NCMA_Success) == 0)
  {
    dprintf(("UI", "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"));
    dprintf(("UI", "SUCCESS\n"));
    dprintf(("UI", "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"));
  }
  else
  {
    dprintf(("UI", "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"));
    dprintf(("UI", "FAILURE\n"));
    dprintf(("UI", "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n"));
  }
#endif

#ifdef CHECK_FOR_NCMALITE
  if (nb_ensure_module(0, "NCMALite") == TRUE)
  {
    dprintf(("UI", "NCMALite present, sending URL\n"));
//    browserif_sendurl(command, false);
    _kernel_oscli(command);
  }
  else
  {
    if (command == NCMA_Success)
    {
      if (strcmp(BUILDENV_NAME, "STB") == 0)
      {
        /* This is a temporary hack to get NCMail to re-enter itself on the STB until we decide
         * how to do it properly */
        if (exit_build_screen(STB_Exit_Hack) == true)
        {
          browserif_sendurl(Open_Exit, false);
        }
        else
        {
          /* Just in case something went wrong, have an escape. */
          browserif_sendurl("ncint:current", false);
        }
      }
      else
      {
        /* Running on a RiscPC */
        browserif_sendurl("file:/ncfresco:welcome", false);
      }
    }
    else
    {
      browserif_sendurl("ncint:current", false);
    }
  }
#else

  dprintf(("UI", "Sending URL: '%s'\n", command));
//  browserif_sendurl(command, false);
  _kernel_oscli(command);

#endif

  /* Now that we have sent the data to NCMA, we can clear the structs and unlock our UI dirs */
  dprintf(("UI", "usersel_call_ncma() completed - cleaning up.\n"));
  usersel_reset_struct();
  ncmui_release_output_directories();
}
