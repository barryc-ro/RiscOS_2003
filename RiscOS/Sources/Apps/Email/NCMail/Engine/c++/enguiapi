/*
** Email Engine
** Interface to UI
*/

#include "kernel.h"
#include "string.h"

#include "Email/Mailbox/Message.h"

#include "DebugLib/DebugLib.h"

#include "enguiapi.h"
#include "engtypes.h"
#include "engmanager.h"
#include "engprocess.h"
#include "engfile.h"
#include "engdownld.h"
#include "engparse.h"
#include "enginit.h"

CallBackList callbacklist;

/*
** eng_connect() is called by the UI when the user clicks Connect.
*/

extern "C" eng_rcode eng_connect(void)
{

  if (state.connected)
    return ENG_ALREADYCONNECTED;

  else if (state.state & CONNECT)
    return ENG_ALREADYCONNECTING;

  else if (!(state.state & DISCONNECT))
  {
    ConnectToISP();
    return ENG_RUNNING;
  }

  else
    return ENG_BUSY;

}


/*
** eng_disconnect() is called by the UI when the user clicks Disconnect.
*/

extern "C" eng_rcode eng_disconnect(void)
{

  if (!state.connected)
    return ENG_ALREADYDISCONNECTED;

  else if (state.state & DISCONNECT)
    return ENG_ALREADYDISCONNECTING;

  else if ((state.state == IDLE) || (state.state & (PROCESSPOP | PROCESSSMTP)))
  {
    PreDisconnect();
    return ENG_RUNNING;
  }

  else
  {
    /*
    ** Set disconnectpending so that if any other process
    ** is active we will know to disconnect when finished.
    */
    state.disconnectpending = true;
    if (state.state & SEND)
      return ENG_SENDINGMAIL;
    else if (state.state & RETRIEVEMSG)
      return ENG_FETCHINGMESSAGE;
    else if (state.state & (DOWNLOADHDR | DOWNLOADMSG))
      return ENG_DOWNLOADINGMAIL;
    else  
      return ENG_WILLDISCONNECTASAP;
  }
}


/*
** eng_get_number_of_messages() is called by the UI to get
** the total number of messages in the list, as well as the
** number read and the number answered, and returns with
** these values in total, read and answered.
** If any of the pointers are null, they are ignored.
*/

extern "C" eng_rcode eng_get_number_of_messages(uint32 *total, uint32 *read, uint32 *answered)
{
  
  if (ourmboxin->flags & MBOXPROCESSED)
  {
    if (total)
      *total = ourmboxin->total;
    if (read)
      *read = ourmboxin->read;
    if (answered)
      *answered = ourmboxin->answered;
    return ENG_COMPLETED;
  }
  else
    return ENG_UNPROCESSED;

}


/*
** eng_get_mailbox_list() is called by the UI to get
** the contents of the current mailbox list.
** It returns a pointer to the first Message Descriptor
** in a linked list.
*/

extern "C" eng_rcode eng_get_mailbox_list(MessageDescriptor **msg)
{

  if (ourmboxin->flags & MBOXPROCESSED)
  {
    *msg = ourmboxin->list;
    return (ourmboxin->flags & MBOXINCOMPLETE) ? ENG_MBOXINCOMPLETE : ENG_COMPLETED;
  }
  else
    return ENG_UNPROCESSED;

}


/*
** eng_get_message() is called by the UI when the user requests
** to read a message.
** It activates the RETRIEVEMSG state.
** When finished it calls func with a Message Descriptor.
** The UI should then request the list of attachments.
*/

extern "C" eng_rcode eng_get_message(uint32 msg_id, void *handle, eng_cbf_getmsg func)
{

  if (!(ourmboxin->flags & MBOXPROCESSED))
    return ENG_UNPROCESSED;

  if (state.state & (PROCESSPOP | RETRIEVEMSG))
    return ENG_BUSY;

  if ((state.retrieve.msg = FindDescriptor(msg_id, ourmboxin)) == 0)
    return ENG_UNKNOWNID;

  dprintf(("Eng", "Message no. %d requested\n",msg_id));
  state.state |= RETRIEVEMSG;
  callbacklist.getmsgfunc = func;
  callbacklist.getmsghandle = handle;

  /*
  ** If message is already downloaded, it will be parsed.
  ** If not, and connection is up, it will be fetched.
  ** Otherwise user will be asked to confirm connection.
  */

  if ((state.retrieve.msg->flags & DOWNLOADED) && (FileExists(msg_id)))
  {
    dprintf(("Eng", "File is already downloaded\n"));
    state.retrieve.substate = readytoparse;
  }

  else if (state.retrieve.msg->flags & DOWNLOADING)
  {
    /* message is in process of being downloaded */
    dprintf(("Eng", "Message is already being downloaded\n"));
    state.retrieve.substate = downloadpending;
  }

  else
  {
    dprintf(("Eng", "Fetching file from server\n"));
    state.retrieve.msg->flags &= ~DOWNLOADED;
    if (state.connected)
      state.retrieve.substate = readytoretrieve;
    else
      state.retrieve.substate = reqconnect;
  }

  return ENG_RUNNING;

}


/*
** eng_create_message() is called by the UI
** when the user wishes to compose an email.
** If msg_id > 0, the new message is a reply to msg_id.
** It activates the CREATE or REPLY state and calls cbfunc with a
** Message Descriptor when finished.
*/

extern "C" eng_rcode eng_create_message(uint32 msg_id, void *handle, eng_cbf_getmsg func)
{

  if (state.state & (CREATE | REPLY))
    return ENG_BUSY;

  else if ((state.create.msg = NewDescriptor(0, ourmboxout)) == 0)
  {
    /* not enough memory for new message */
    return ENG_NOMEMORY;
  }

  if ((state.create.msg->fromreal = malloc(strlen(realname) + 1)) == 0)
  {
    /* not enough memory for new message */
    return ENG_NOMEMORY;
  }

  if ((state.create.msg->fromaddr = malloc(strlen(emailaddr) + 1)) == 0)
  {
    /* not enough memory for new message */
    return ENG_NOMEMORY;
  }

  strcpy(state.create.msg->fromreal, realname);
  strcpy(state.create.msg->fromaddr, emailaddr);
  state.state |= (msg_id > 0) ? REPLY : CREATE;
  callbacklist.createfunc = func;
  callbacklist.createhandle = handle;
  if (msg_id)
    state.create.reply = FindDescriptor(msg_id, ourmboxin);
  state.create.substate = readytocreate;
  return ENG_RUNNING;

}


/*
** eng_send_message() is called by the UI when the user
** sends an email. The body of the mesage is in bodyfile.
** It activates the SEND state.
*/

extern "C" eng_rcode eng_send_message(uint32 msg_id, char *bodyfile)
{

  if (state.state & (CREATE | REPLY))
    return ENG_BUSY;

  else
  {
    state.state |= SEND;
    state.send.msg = FindDescriptor(msg_id, ourmboxout);
    if ((state.send.fname = malloc(strlen(bodyfile) + 1)) == 0)
      return ENG_NOMEMORY;

    strcpy(state.send.fname, bodyfile);
    state.send.substate = readytoparse;
    dprintf(("Eng", "Sending message %d, body in file %s\n",msg_id,state.send.fname));
    return ENG_RUNNING;
  }

}


/*
** eng_cancel_message() is called by the UI when the user
** wishes to cancel a message or reply previously created.
*/

extern "C" eng_rcode eng_cancel_message(uint32 msg_id)
{

  DestroyDescriptor(FindDescriptor(msg_id, ourmboxout), ourmboxout);

  /* Do we need to do anything else here? */

  return ENG_COMPLETED;

}


/*
** eng_mark_as_read() is called by the UI to mark a message as read.
*/

extern "C" eng_rcode eng_mark_as_read(uint32 msg_id)
{

  if (state.state & (MARKREAD | MARKDELETE))
    return ENG_BUSY;

  state.mark.msg = FindDescriptor(msg_id, ourmboxin);
  if (!state.mark.msg)
    return ENG_UNKNOWNID;

  dprintf(("Eng", "About to mark message %d as read\n",msg_id));
  state.mark.msg->flags |= READ;
  state.state |= MARKREAD;
  state.mark.rc = ENG_COMPLETED;
  state.mark.substate = readytomark;
  return ENG_RUNNING;

}


/*
** eng_mark_for_deletion() is called by the UI when the user
** wishes to mark a selection of messages for deletion.
** When finished, the Engine calls the UI's prompt function
** to indicate that the Inbox should be updated.
*/

extern "C" eng_rcode eng_mark_for_deletion(uint32 number, uint32 *message_list)
{

  if (state.state & (MARKREAD | MARKDELETE))
    return ENG_BUSY;

  state.mark.list = message_list;
  state.mark.total = number;
  state.mark.current = 0;
  state.mark.substate = readytomark;
  state.mark.rc = ENG_COMPLETED;
  state.state |= MARKDELETE;
  dprintf(("Eng", "About to mark %d messages for deletion\n",number));

  return ENG_RUNNING;

}
  

/*
** eng_register_prompt() is called by the UI to register a callback
** function that will be called whenever the inbox list should
** be redisplayed, e.g. after processing the mailbox.
*/

extern "C" eng_rcode eng_register_prompt(void *handle, eng_cbf_prompt func)
{

  callbacklist.promptfunc = func;
  callbacklist.prompthandle = handle;

  return ENG_COMPLETED;
}


/*
** eng_email_active() is called by the UI to notify the Engine
** that user has entered or left the Email client.
*/

extern "C" eng_rcode eng_email_active(bool status)
{

  MessageDescriptor *msgptr = ourmboxin->list;

  if (status == state.emailactive)
    dprintf(("Eng", "Already in that state\n"));
  state.emailactive = status;    
  dprintf(("Eng", "Email Client is now %sactive\n",(status) ? "" : "in"));

  /*
  ** Check which messages in list are on file.
  ** If active, lock them, otherwise unlock them.
  */
  while (msgptr)
  {
    if (FileExists(msgptr->ID))
    {
      msgptr->flags |= DOWNLOADED;
      if (state.emailactive)
      {
        dprintf(("Eng", "Locking file %d\n",msgptr->ID));
        LockFile(SetFilename(msgptr->ID, false));
      }
      else
      {
        UnlockFile(SetFilename(msgptr->ID, false));
        dprintf(("Eng", "Unlocking file %d\n",msgptr->ID));
      }
    }
    else
    {
      dprintf(("Eng", "File %d not loaded\n",msgptr->ID));
      msgptr->flags &= ~DOWNLOADED;
    }
    msgptr = msgptr->next;
  }

  return ENG_COMPLETED;

}


/*
** eng_register_status() is called by the UI to register a
** callback function that should be called whenever a status
** report needs to be given to the user (e.g. a process failed).
**
** The callback function allows for the Engine to return a callback
** function of its own to receive an indication of feedback from
** the user, e.g. if a confirmation is required.
*/

extern "C" eng_rcode eng_register_status(void *handle, eng_cbf_status func)
{

  /* register a function for status reports to UI */

  callbacklist.statusfunc = func;
  callbacklist.statushandle = handle;

  return ENG_COMPLETED;
}


/*
** eng_confirm() is called by the UI as a callback function when
** the Engine requires confirmation of connection, e.g. when a
** message is requested that is on the server and the link is down.
*/

extern "C" void eng_confirm(bool conf)
{

  if (conf)
  {
    /* user has confirmed connection */
    ConnectToISP();
  }

  else
  {
    /* Cancel RETRIEVEMSG state and clean up. */
    state.state &= ~(RETRIEVEMSG + DOWNLOADMSG);
    (*callbacklist.getmsgfunc)(ENG_CONNECTCANCELLED, 0, callbacklist.getmsghandle);
  }

}
