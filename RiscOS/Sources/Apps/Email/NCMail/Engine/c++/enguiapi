/*
** Email Engine
** Interface to UI
*/

#include "kernel.h"
#include "string.h"

#include "Email/Mailbox/Message.h"

#include "DebugLib/DebugLib.h"

#include "enguiapi.h"
#include "engtypes.h"
#include "engmanager.h"
#include "engprocess.h"
#include "engfile.h"
#include "engdownld.h"
#include "engparse.h"

CallBackList callbacklist;

/*
** eng_connect() is called by the UI when the user clicks Connect.
*/

extern "C" eng_rcode eng_connect(void)
{

  if (state.connected)
    return ENG_EALREADYCONNECTED;

  else if (state.state & CONNECT)
    return ENG_EALREADYCONNECTING;

  else if (!(state.state & DISCONNECT))
  {
    ConnectToISP();
    return ENG_RUNNING;
  }

  else
    return ENG_EBUSY;

}


/*
** eng_disconnect() is called by the UI when the user clicks Disconnect.
*/

extern "C" eng_rcode eng_disconnect(void)
{

  if (!state.connected)
    return ENG_EALREADYDISCONNECTED;

  else if (state.state & DISCONNECT)
    return ENG_EALREADYDISCONNECTING;

  else if (!(state.state & CONNECT))
  {
    DisconnectFromISP();
    return ENG_RUNNING;
  }

  else
  {
    /*
    ** Set disconnectpending so that if any other process
    ** is active we will know to disconnect when finished.
    */
    state.disconnectpending = true;
    if (state.state & SEND)
      return ENG_ESENDINGMAIL;
    else if (state.state & RETRIEVEMSG)
      return ENG_EFETCHINGMAIL;
    else  
      return ENG_EBUSY;
  }
}


/*
** eng_get_number_of_messages() is called by the UI to get
** the total number of messages in the list, as well as the
** number read and the number answered, and returns with
** these values in total, read and answered.
** If any of the pointers are null, they are ignored.
*/

extern "C" eng_rcode eng_get_number_of_messages(uint32 *total, uint32 *read, uint32 *answered)
{
  
  if (ourinbox->flags & MBOXPROCESSED)
  {
    if (total)
      *total = ourinbox->total;
    if (read)
      *read = ourinbox->read;
    if (answered)
      *answered = ourinbox->answered;
    return ENG_COMPLETED;
  }
  else
    return ENG_EUNPROCESSED;

}


/*
** eng_get_mailbox_list() is called by the UI to get
** the contents of the current mailbox list.
** It returns a pointer to the first Message Descriptor
** in a linked list.
*/

extern "C" eng_rcode eng_get_mailbox_list(MessageDescriptor **msg)
{

  if (ourinbox->flags & MBOXPROCESSED)
  {
    *msg = ourinbox->list;
    return (ourinbox->flags & MBOXINCOMPLETE) ? ENG_EMBOXINCOMPLETE : ENG_COMPLETED;
  }
  else
    return ENG_EUNPROCESSED;

}


/*
** eng_get_message() is called by the UI when the user requests
** to read a message.
** It activates the RETRIEVEMSG state.
** When finished it calls func with a Message Descriptor.
** The UI should then request the list of attachments.
*/

extern "C" eng_rcode eng_get_message(uint32 msg_id, void *handle, eng_cbf_getmsg func)
{

  if (!(ourinbox->flags & MBOXPROCESSED))
    return ENG_EUNPROCESSED;

/*   if (state.state != IDLE) */
/*     return ENG_EBUSY; */

  if ((state.download.msg = FindDescriptor(msg_id, ourinbox)) == 0)
    return ENG_EUNKNOWNID;

  state.state |= (RETRIEVEMSG + DOWNLOADMSG);
  callbacklist.getmsgfunc = func;
  callbacklist.getmsghandle = handle;

  /*
  ** If message is already downloaded, it will be parsed.
  ** If not, and connection is up, it will be fetched.
  ** Otherwise user will be asked to confirm connection.
  */

  if ((state.download.msg->flags & DOWNLOADED) && (FileExists(msg_id)))
  {
    dprintf(("Eng", "File is already downloaded\n"));
    state.download.substate = readytoparse;
  }

  else
  {
    dprintf(("Eng", "Fetching file from server\n"));
    state.download.msg->flags &= ~DOWNLOADED;
    if (state.connected)
      state.download.substate = readytodownload;
    else
      state.download.substate = reqconnect;
  }

  return ENG_RUNNING;

}


/*
** eng_get_attachment() is called by the UI when it needs to
** display an attachment.
** It activates the RETRIEVEENT state.
** When finished it puts the body of the attachment into the
** temp file specified and calls func with a Message Descriptor.
*/

extern "C" eng_rcode eng_get_attachment(uint32 msg_id, uint32 ent_id, char *file, void *handle, eng_cbf_getentity func)
{

  if (state.state == IDLE)
  {
    callbacklist.getentfunc = func;
    callbacklist.getenthandle = handle;
    callbacklist.getentfile = file;
    if ((state.retrieve.msg = FindDescriptor(msg_id, ourinbox)) == 0)
    {
      dprintf(("Eng", "Unknown attachment\n"));
      return ENG_EUNKNOWNENT;
    }
    
    state.retrieve.ent = FindEntity(state.retrieve.msg, ent_id);
    StartRetrieve();

    return ENG_RUNNING;
  }
  else
    return ENG_EBUSY;

}


/*
** eng_create_message() is called by the UI
** when the user wishes to compose an email.
** If msg_id > 0, the new message is a reply to msg_id.
** It activates the CREATE state and calls cbfunc with a
** Message Descriptor when finished.
*/

extern "C" eng_rcode eng_create_message(uint32 msg_id, void *handle, eng_cbf_getmsg func)
{

  if (state.state & (CREATE | REPLY))
    return ENG_EBUSY;

  else if ((state.create.msg = NewDescriptor(0, ouroutbox)) == 0)
  {
    /* not enough memory for new message */
    return ENG_ENOMEMORY;
  }

  state.state |= (msg_id > 0) ? REPLY : CREATE;
  callbacklist.createfunc = func;
  callbacklist.createhandle = handle;
  state.create.reply = FindDescriptor(msg_id, ourinbox);
  state.create.substate = readytocreate;
  return ENG_RUNNING;

}


/*
** eng_send_message() is called by the UI when the user
** sends an email. The body of the mesage is in bodyfile.
** It activates the SEND state.
*/

extern "C" eng_rcode eng_send_message(uint32 msg_id, char *bodyfile)
{

  if (state.state & (CREATE | REPLY))
    return ENG_EBUSY;

  else
  {
    state.state |= SEND;
    state.send.msg = FindDescriptor(msg_id, ouroutbox);
    state.send.fname = malloc(strlen(bodyfile) + 1);
    strcpy(state.send.fname, bodyfile);
    state.send.substate = readytoparse;
    dprintf(("Eng", "Sending message %d\n",msg_id));
    return ENG_RUNNING;
  }

}


/*
** eng_cancel_message() is called by the UI when the user
** wishes to cancel a message or reply previously created.
*/

extern "C" eng_rcode eng_cancel_message(uint32 msg_id)
{

  DestroyDescriptor(FindDescriptor(msg_id, ouroutbox), ouroutbox);
  
  /* Do we need to do anything else here? */
  
  return ENG_COMPLETED;

}


/*
** eng_mark_as_read() is called by the UI to mark a message as read.
*/

extern "C" eng_rcode eng_mark_as_read(uint32 msg_id)
{

  MessageDescriptor *msg = FindDescriptor(msg_id, ourinbox);
  msg->flags |= READ;
  /* msg->mboxobj->SetFlags(Read);  probably wrong params */
  
  /* need to catch and return errors from Mailbox */

  return ENG_COMPLETED;

}


/*
** eng_mark_for_deletion() is called by the UI when the user
** wishes to mark a selection of messages for deletion.
** When finished, the Engine calls the UI's prompt function
** to indicate that the Inbox should be updated.
*/

extern "C" eng_rcode eng_mark_for_deletion(uint32 number, uint32 *message_list)
{

  state.mark.list = message_list;
  state.mark.total = number;
  state.mark.current = 0;
  state.mark.substate = readytomark;
  state.mark.rc = ENG_COMPLETED;
  state.state |= DELETE;
  dprintf(("Eng", "About to mark %d messages for deletion\n",number));

  return ENG_RUNNING;
}
  

/*
** eng_register_prompt() is called by the UI to register a callback
** function that will be called whenever the inbox list should
** be redisplayed, e.g. after processing the mailbox.
*/

extern "C" eng_rcode eng_register_prompt(void *handle, eng_cbf_prompt func)
{

  callbacklist.promptfunc = func;
  callbacklist.prompthandle = handle;

  return ENG_COMPLETED;
}


/*
** eng_email_active() is called by the UI to notify the Engine
** that user has entered or left the Email client.
*/

extern "C" eng_rcode eng_email_active(bool status)
{

  MessageDescriptor *msgptr = ourinbox->list;

  if (status == state.emailactive)
    dprintf(("Eng", "Already in that state\n"));
  state.emailactive = status;    
  dprintf(("Eng", "Email Client is now %sactive\n",(status) ? "" : "in"));

  /*
  ** Check which messages in list are on file.
  ** If active, lock them, otherwise unlock them.
  */
  while (msgptr)
  {
    if (FileExists(msgptr->ID))
    {
      msgptr->flags |= DOWNLOADED;
      if (state.emailactive)
      {
        dprintf(("Eng", "Locking file %d\n",msgptr->ID));
        LockFile(msgptr->ID, false);
      }
      else
      {
        UnlockFile(msgptr->ID, false);
        dprintf(("Eng", "Unlocking file %d\n",msgptr->ID));
      }
    }
    else
    {
      dprintf(("Eng", "File %d not loaded\n",msgptr->ID));
      msgptr->flags &= ~DOWNLOADED;
    }
    msgptr = msgptr->next;
  }

  return ENG_COMPLETED;

}


/*
** eng_register_status() is called by the UI to register a
** callback function that should be called whenever a status
** report needs to be given to the user (e.g. a process failed).
**
** The callback function allows for the Engine to return a callback
** function of its own to receive an indication of feedback from
** the user, e.g. if a confirmation is required.
*/

extern "C" eng_rcode eng_register_status(void *handle, eng_cbf_status func)
{

  /* register a function for status reports to UI */

  callbacklist.statusfunc = func;
  callbacklist.statushandle = handle;

  return ENG_COMPLETED;
}


/*
** eng_confirm() is called by the UI as a callback function when
** the Engine requires confirmation of connection, e.g. when a
** message is requested that is on the server and the link is down.
*/

extern "C" void eng_confirm(bool conf)
{

  if (conf)
  {
    /* user has confirmed connection */
    ConnectToISP();
  }

  else
  {
    /* Cancel RETRIEVEMSG state and clean up. */
    state.state &= ~(RETRIEVEMSG + DOWNLOADMSG);
    (*callbacklist.getmsgfunc)(ENG_ECONNECTCANCELLED, 0, callbacklist.getmsghandle);
  }

}
