/*
** Email Engine
** Interface to UI
*/

#include "kernel.h"
#include "string.h"
#include "swis.h"

#include "Email/Mailbox/Message.h"

#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "DebugLib/DebugLib.h"
#include "NBLib/NBLib.h"

#include "enguiapi.h"
#include "engtypes.h"
#include "engmanager.h"
#include "engprocess.h"
#include "engdownld.h"
#include "engparse.h"
#include "enginit.h"
#include "enguser.h"
#include "engcbf.h"
#include "engsend.h"
#include "engtimers.h"
#include "engconnect.h"

CallBackList callbacklist;

#ifdef ALAN
static int filecount = 1;
#endif

/*
** eng_connect() is called by the UI when the user clicks Connect.
*/

extern "C" eng_rcode eng_connect(void)
{

  dprintf(("Eng", "Engine receiving connect request from UI\n"));
  if (online)
    return ENG_ALREADYCONNECTED;

  else if (state & CONNECT)
    return ENG_ALREADYCONNECTING;

  else if (state & DISCONNECT)
    return ENG_ALREADYDISCONNECTING;

  ConnectToISP();
  return ENG_RUNNING;

}


/*
** eng_disconnect() is called by the UI when the user clicks Disconnect.
*/

extern "C" eng_rcode eng_disconnect(void)
{

  dprintf(("Eng", "Engine receiving disconnect request from UI\n"));
  if (!online)
    return ENG_ALREADYDISCONNECTED;

  else if (state & DISCONNECT)
    return ENG_ALREADYDISCONNECTING;

  else if (state == IDLE)
  {
    DisconnectLine();
    return ENG_RUNNING;
  }

  else
  {
    /*
    ** Set disconnectpending so that if any other process
    ** is active we will know to disconnect when finished.
    */
    disconnectpending = true;
    if ((state & (PROCESSPOP | PROCESSSMTP)) && (!(state & TIMEOUT)))
      return ENG_PROCESSING;
    else if (state & SEND)
      return ENG_SENDINGMAIL;
    else if (state & RETRIEVEMSG)
      return ENG_FETCHINGMESSAGE;
    else if (state & (DOWNLOADHDR | DOWNLOADMSG))
      return ENG_DOWNLOADINGMAIL;
    else
      return ENG_WILLDISCONNECTASAP;
  }
}


/*
** eng_get_number_of_messages() is called by the UI to get
** the total number of messages in the list, as well as the
** number read and the number answered, and returns with
** these values in total, read and answered.
** If any of the pointers are null, they are ignored.
*/

extern "C" eng_rcode eng_get_number_of_messages(uint32 *total, uint32 *read, uint32 *answered)
{

  if (ourmboxin->flags & MBOXPROCESSED)
  {
    if (total)
      *total = ourmboxin->total;
    if (read)
      *read = ourmboxin->read;
    if (answered)
      *answered = ourmboxin->answered;
    return ENG_COMPLETED;
  }
  else
    return ENG_UNPROCESSED;

}


#ifdef ALAN
/***************Temporary debugging code***************/

void TempDebugOutput(void)
{

  FILE *f;
  char fname[32];
  MessageDescriptor *msgptr;

  sprintf(fname, "NFS::NCB.$.Debug.Inbox%d\0",filecount++);
  f = fopen(fname, "w");
  msgptr = ourmboxin->list;
  while (msgptr)
  {
    fprintf(f, "%d:\t%s\t%s\t%s\tdescriptor at 0x%x\tmboxobj at 0x%x\n",msgptr->ID,msgptr->fromaddr,asctime(msgptr->datestruct),msgptr->subject,msgptr,msgptr->mboxobj);
    msgptr = msgptr->next;
  }
  fclose(f);
  MakeFilePublic(fname);
  _kernel_swi(OS_FSControl,&regs,&regs);
  dprintf(("Eng", "Finished outputting inbox to file\n"));

}
/***************End of debugging code***************/
#endif


/*
** eng_get_mailbox_list() is called by the UI to get
** the contents of the current mailbox list.
** It returns a pointer to the first Message Descriptor
** in a linked list.
*/

extern "C" eng_rcode eng_get_mailbox_list(MessageDescriptor **msg)
{

  if (ourmboxin->flags & MBOXPROCESSED)
  {
    *msg = ourmboxin->list;

#ifdef ALAN
    /* temp debug output to save Inbox to file */
    TempDebugOutput();
#endif

    dprintf(("Eng", "Returning mailbox list, %scomplete\n",(ourmboxin->flags & MBOXINCOMPLETE) ? "in" : ""));
    if (ourmboxin->total)
    {
      /* if Inbox is being displayed after reading message,
         remove entities and destroy rfc object */
      RemoveMessage();

      return (ourmboxin->flags & MBOXINCOMPLETE) ? ENG_MBOXINCOMPLETE : ENG_COMPLETED;
    }
    else
      return ENG_NOMBOX;
  }

  else
    return ENG_UNPROCESSED;

}


/*
** eng_get_message() is called by the UI when the user requests
** to read a message.
** It activates the RETRIEVEMSG state.
** When finished it calls func with a Message Descriptor.
** The body and any attachments are listed the entity_list field.
*/

extern "C" eng_rcode eng_get_message(uint32 msg_id, void *handle, eng_cbf_getmsg func)
{

  dprintf(("Eng", "Receiving get_message request from UI. State=0x%x\n",state));
  if (!(ourmboxin->flags & MBOXPROCESSED))
    return ENG_UNPROCESSED;

  if (state & PROCESSPOP)
    return ENG_PROCESSING;

  if (state & RETRIEVEMSG)
    return ENG_FETCHINGMESSAGE;

  /* if message is being returned to after reply, remove entities
     and destroy rfc object before creating them again */
  RemoveMessage();

  if ((retrievestate.msg = FindDescriptor(msg_id, ourmboxin)) == 0)
    return ENG_UNKNOWNID;

  dprintf(("Eng", "Message no. %d requested for reading\n",msg_id));
  state |= RETRIEVEMSG;
  callbacklist.getmsgfunc = func;
  callbacklist.getmsghandle = handle;
  retrievestate.ret.code = ENG_COMPLETED;
  retrievestate.ret.rc = ELIB_RUNNING;
  retrievestate.retrievelist = 0;
  ResetEntID();

  /*
  ** If message is already downloaded, it will be parsed.
  ** If not, and connection is up, it will be fetched.
  ** Otherwise user will be asked to confirm connection.
  */

  SetFilename(msg_id, false);
  if ((retrievestate.msg->flags & DOWNLOADED) && (!nb_file_exists(1, msgfilename,0 ,0)))
  {
    dprintf(("Eng", "File is already downloaded\n"));
    retrievestate.context = readytoparse;
  }

  else if (retrievestate.msg->flags & DOWNLOADING)
  {
    /* message is in process of being downloaded */
    dprintf(("Eng", "Message is already being downloaded\n"));
    retrievestate.context = downloadpending;
  }

  else
  {
    dprintf(("Eng", "Fetching file from server\n"));
    retrievestate.msg->flags &= ~DOWNLOADED;
    if (online)
    {
      ActivatePOP();
      if (popstatus == acctconnected)
        retrievestate.context = readytoretrieve;
      else
        retrievestate.context = readytoconnect;
    }
    else
      retrievestate.context = reqconnect;
  }

  return ENG_RUNNING;

}


/*
** eng_create_message() is called by the UI
** when the user wishes to compose an email.
** If msg_id > 0, the new message is a reply to msg_id.
** It activates the CREATE or REPLY state and calls cbfunc with a
** Message Descriptor when finished.
*/

extern "C" eng_rcode eng_create_message(uint32 msg_id, uint32 number, uint32 *forward_list, void *handle, eng_cbf_getmsg func)
{

  if (state & (CREATE | REPLY))
    return ENG_CREATING;

  if ((createstate.msg = NewDescriptor(0, ourmboxout, true)) == 0)
  {
    /* not enough memory for new message */
    return ENG_NOMEMORY;
  }

  if ((createstate.msg->fromreal = malloc(strlen(realname) + 1)) == 0)
  {
    /* not enough memory for new message */
    return ENG_NOMEMORY;
  }

  if ((createstate.msg->fromaddr = malloc(strlen(emailaddr) + 1)) == 0)
  {
    /* not enough memory for new message */
    return ENG_NOMEMORY;
  }

  strcpy(createstate.msg->fromreal, realname);
  strcpy(createstate.msg->fromaddr, emailaddr);
  state |= (msg_id > 0) ? REPLY : CREATE;
  callbacklist.createfunc = func;
  callbacklist.createhandle = handle;
  if (msg_id)
  {
    createstate.orig = FindDescriptor(msg_id, ourmboxin);
    dprintf(("Eng", "Getting descriptor at 0x%x for original massage\n",createstate.orig));
  }

  if (number)
  {
    dprintf(("Eng", "Compiling list of messages to forward\n"));
    createstate.msg->forward_num = number;
    createstate.msg->forward_list = forward_list;
  }

  createstate.context = readytocreate;
  return ENG_RUNNING;

}


eng_rcode eng_get_reply_id(uint32 msg_id, uint32 *orig_id)
{

  if ((!createstate.msg) || (createstate.msg->ID != msg_id))
    return ENG_UNKNOWNID;

  *orig_id = createstate.orig->ID;

  return ENG_COMPLETED;

}


/*
** eng_send_message() is called by the UI when the user
** sends an email. The body of the mesage is in bodyfile.
** It activates the SEND state.
** If there are any entries in the descriptor's forward_list,
** these are assumed to be message IDs to be forwarded with the
** message to be sent, and the FORWARD state is set.
** When finished it calls the callback function with a return code
** to indicate the success of otherwise of the send.
*/

extern "C" eng_rcode eng_send_message(uint32 msg_id, char *bodyfile, void *handle, eng_cbf_sendstatus func)
{

  dprintf(("Eng", "Receiving Send Message request from UI\n"));
  if (state & (CREATE | REPLY))
    return ENG_CREATING;

  if ((state & RETRIEVEMSG) && (sendstate.msg->forward_list))
    return ENG_FETCHINGMESSAGE;

  dprintf(("Eng", "Sending message %d, body in file %s\n",msg_id,bodyfile));
  callbacklist.sendfunc = func;
  callbacklist.sendhandle = handle;
  state |= SEND;
  
  sendstate.msg = FindDescriptor(msg_id, ourmboxout);
  sendstate.bodyname = bodyfile;
  sendstate.ret.code = ENG_COMPLETED;
  if (sendstate.msg->forward_num)
  {
    dprintf(("Eng", "There are messages in the forward list\n"));
    sendstate.listindex = 0;
    state |= FORWARD;
    sendstate.context = readytoretrieve;
  }
  else
    sendstate.context = readytoparse;

  return ENG_RUNNING;

}


/*
** eng_cancel_message() is called by the UI when the user
** wishes to cancel a message or reply previously created.
*/

extern "C" eng_rcode eng_cancel_message(uint32 msg_id)
{

  DestroyDescriptor(FindDescriptor(msg_id, ourmboxout), ourmboxout);

  /* Do we need to do anything else here? */

  return ENG_COMPLETED;

}


/*
** eng_mark_as_read() is called by the UI to mark a message as read.
*/

extern "C" eng_rcode eng_mark_as_read(uint32 msg_id)
{

  if (state & (MARKREAD | MARKDELETE))
    return ENG_ALREADYMARKING;

  markstate.msg = FindDescriptor(msg_id, ourmboxin);
  if (!markstate.msg)
    return ENG_UNKNOWNID;

  dprintf(("Eng", "About to mark message %d as read\n",msg_id));
  markstate.msg->flags |= READ;
  state |= MARKREAD;
  markstate.ret.code = ENG_COMPLETED;
  markstate.context = readytomark;
  return ENG_RUNNING;

}


/*
** eng_mark_for_deletion() is called by the UI when the user
** wishes to mark a selection of messages for deletion.
** When finished, the Engine calls the UI's prompt function
** to indicate that the Inbox should be updated.
*/

extern "C" eng_rcode eng_mark_for_deletion(uint32 number, uint32 *message_list)
{

  if (state & (MARKREAD | MARKDELETE))
    return ENG_ALREADYMARKING;

  /* if message is being deleted from Read screen,
     remove entities and destroy rfc object */
  RemoveMessage();

  markstate.list = message_list;
  markstate.total = number;
  markstate.current = 0;
  markstate.context = readytomark;
  markstate.ret.code = ENG_COMPLETED;
  expungepending = false;
  state |= MARKDELETE;
  dprintf(("Eng", "About to mark %d messages for deletion\n",number));

  return ENG_RUNNING;

}


/*
** eng_register_prompt() is called by the UI to register a callback
** function that will be called whenever the inbox list should
** be redisplayed, e.g. after processing the mailbox.
*/

extern "C" eng_rcode eng_register_prompt(void *handle, eng_cbf_prompt func)
{

  callbacklist.promptfunc = func;
  callbacklist.prompthandle = handle;

  return ENG_COMPLETED;
}


/*
** eng_email_active() is called by the UI to notify the Engine
** that user has entered or left the Email client.
*/

extern "C" eng_rcode eng_email_active(bool status)
{

  if (emailactive == status)
  {
    /* no change so just return */
    return ENG_COMPLETED;
  }

  emailactive = status;
  dprintf(("Eng", "Email Client is now %sactive\n",(status) ? "" : "in"));
#ifdef CHECK_FOR_NCMALITE
  if (emailactive)
    ChangeUser();
#endif

  if ((emailactive) && (popstatus == acctnonexistent))
  {
    dprintf(("Eng", "No account details - returning error\n"));
    return ENG_NOPOPACCOUNT;
  }

  if (emailactive)
  {
    MessageDescriptor *msgptr = ourmboxin->list;

    /*
    ** Check which messages in list are on file.
    ** Set the DOWNLOADED flag if they are there.
    */
    while (msgptr)
    {
      SetFilename(msgptr->ID, false);
      if (!nb_file_exists(1, msgfilename, 0, 0))
      {
        msgptr->flags |= DOWNLOADED;
/*         dprintf(("Eng", "Message %d is downloaded\n",msgptr->ID)); */
      }
      msgptr = msgptr->next;
    }
    nb_file_lock(1, "<NCMailStore$Dir>.<NCMail$User>", 0);
    nb_file_lock(0, "<NCMailStore$Dir>.<NCMail$User>", "*");
  }
  else
  {
    nb_file_unlock(1, "<NCMailStore$Dir>.<NCMail$User>", 0);
    nb_file_unlock(0, "<NCMailStore$Dir>.<NCMail$User>", "*");
  }

  if (online)
  {
    if ((emailactive) && (!popactive))
      StartProcess();
  }

  else if (sendpending)
  {
    /* if offline and mail waiting to be sent, cancel retry countdown */
    StopRetryCount();
  }

  return ENG_COMPLETED;

}


/*
** eng_register_status() is called by the UI to register a
** callback function that should be called whenever a status
** report needs to be given to the user (e.g. a process failed).
**
** The callback function allows for the Engine to return a callback
** function of its own to receive an indication of feedback from
** the user, e.g. if a confirmation is required.
*/

extern "C" eng_rcode eng_register_status(void *handle, eng_cbf_status func)
{

  /* register a function for status reports to UI */

  callbacklist.statusfunc = func;
  callbacklist.statushandle = handle;

  return ENG_COMPLETED;
}


extern "C" eng_rcode eng_get_send_message(uint32 msg_id, MessageDescriptor **msg)
{

  MessageDescriptor *msgptr = FindDescriptor(msg_id, ourmboxout);

  if (!msgptr)
    return ENG_UNKNOWNID;

  *msg = msgptr;
  return ENG_COMPLETED;

}


extern "C" eng_rcode eng_change_user(void)
{

  ChangeUser();
  return ENG_COMPLETED;

}


extern "C" void eng_null_events(bool yes)
{

  if (yes)
  {
    state |= UINULLS;
  }
  else
    state &= ~UINULLS;

}


extern "C" eng_rcode eng_mem_available(int32 *free)
{

  *free = FreeMem();
  return (cachefs) ? ENG_COMPLETED : ENG_NOCACHEFS;

}


extern "C" eng_rcode eng_clear_memory(uint32 bestguess)
{

  return ClearMemory(bestguess, false);

}


void eng_fatal_error(void)
{

  /*
  ** UI is reporting a fatal error.
  ** Stop any downloads, disconnect from servers,
  ** then blow up in a puff of smoke and await reincarnation.
  */
  
  state = BROWNTROUSERS;
  if (popactive)
    DisconnectServer();
  else
    appquit = true;

}
