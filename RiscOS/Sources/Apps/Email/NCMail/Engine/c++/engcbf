/*
** Email Engine
** Callback functions
*/

#include "Email/Mailbox/MBoxCB.h"

#include "DebugLib/DebugLib.h"

#include "engprocess.h"
#include "enginit.h"
#include "engtypes.h"
#include "engparse.h"
#include "enguiapi.h"
#include "engcbf.h"
#include "engdownld.h"
/* #include "engdebug.h" */

extern "C"
{
  #include "../Build/NCMailUI.h"
}

/* temp definitions until NetLink Cntrl is linked */

#define DOWN 0
#define COMINGUP 1
#define UPSUCCESSFULLY 2
#define UPFAILED 3
#define COMINGDOWN 4

/*
** eng_line_change() is a callback function for NetLink Cntrl.
** It is called whenever a change in the status of the link is reported.
*/

void eng_line_change(uint32 status)
{

  switch (status)
  {
    case DOWN :

      state.connected = false;
      state.state &= ~(CONNECT + DISCONNECT);
      ncmui_line_state(LINKDOWN);
      if (state.state & PREQUIT)
      {
        /* reinstate the shutdown process */
        appquit = true;
      }
      break;

    case COMINGUP :

      break;

    case UPSUCCESSFULLY :

      state.connected = true;
      ncmui_line_state(LINKUP);
      POPaccount->SetConnectionState(true);
      SMTPaccount->SetConnectionState(true);
      state.state &= ~(CONNECT + DISCONNECT);
      if (state.state & RETRIEVEMSG)
        state.download.substate = readytodownload;
      else
        StartProcess();
      break;

    case UPFAILED :

      state.state &= ~(CONNECT + DISCONNECT);
      if (state.state & RETRIEVEMSG)
      {
        state.state &= ~(RETRIEVEMSG + DOWNLOADMSG);
        /* presumably abandon fetch a this point?*/
      }

      (*callbacklist.statusfunc)(ENG_CONNECTIONFAILED, callbacklist.statushandle, 0);
      break;

    case COMINGDOWN :

      break;
  }

}


void eng_mbox_cbfunc(MBoxOpCB *cb, void *h)
{
  /*
  ** Generic function for receiving callbacks from Mailbox.
  ** Uses GetType method to determine what kind of callback
  ** and route it accordingly.
  */

  uint32 handle = (uint32) h;

  switch (cb->GetType())
  {
    case MBoxOpCB::Connect :
    {
      MBoxOpCB_connect *obj = (MBoxOpCB_connect *) cb;
      eng_rcode code = (eng_rcode) obj->rc;
      dprintf(("Eng", "Receiving Connect callback for %s, rc = %d\n",((handle == pop) ? "POP" : "SMTP"),code));
      if (code < 0)
      {
        /* error has occurred during connection to mail server */
        if (handle == pop)
          state.popprocess.substate = connectfailure;
        else
          state.smtpprocess.substate = connectfailure;
      }

      else if (code == ENG_COMPLETED)
      {
        if (handle == pop)
          state.popprocess.substate = connected;
        else
          state.smtpprocess.substate = connected;
      }

      else
      {
        /* process must be still running */
      }

      break;
    }
    case MBoxOpCB::Disconnect :
    {
      MBoxOpCB_disconnect *obj = (MBoxOpCB_disconnect *) cb;
      eng_rcode code = (eng_rcode) obj->rc;

      dprintf(("Eng", "Receiving Disconnect callback for %s, rc = %d\n",((handle == pop) ? "POP" : "SMTP"),code));
      if (code < 0)
      {
        /* error has occurred during disconnection from mail server */
        if (handle == pop)
          state.popprocess.substate = disconnectfailure;
        else
          state.smtpprocess.substate = disconnectfailure;
      }

      else if (code == ENG_COMPLETED)
      {
        /* disconnection has happened (presumably) */
        if (handle == pop)
          state.popprocess.substate = disconnected;
        else
          state.smtpprocess.substate = disconnected;
      }

      else
      {
        /* process must be still running */
      }

      break;
    }
    case MBoxOpCB::Expunge :
    {
      MBoxOpCB_expunge *obj = (MBoxOpCB_expunge *) cb;
      eng_rcode code = (eng_rcode) obj->rc;

      dprintf(("Eng", "Receiving Expunge callback for %s, rc = %d\n",((handle == pop) ? "POP" : "SMTP"),code));
      if ((code < 0) && (handle == pop))
      {
        /* error has occurred during expunge */
        ourmboxin->flags |= MBOXINCOMPLETE;
      }

      else
      {
        /* expunge has happened (presumably) */
        if (handle == pop)
          state.popprocess.substate = readytoprocess;
        else
          state.smtpprocess.substate = smtpdone;
      }

      if (state.state & MARKDELETE)
      {
        state.state &= ~PROCESSPOP;
        state.mark.substate = readytodisplay;
      }

      break;
    }
    case MBoxOpCB::Process :
    {
      MBoxOpCB_process *obj = (MBoxOpCB_process *) cb;
      eng_rcode code = (eng_rcode) obj->rc;

      dprintf(("Eng", "Receiving Process callback for %s, rc = %d\n",((handle == pop) ? "POP" : "SMTP"),code));
      if (code < 0)
      {
        /* error has occurred during processing mailbox */
        if (handle == pop)
        {
          state.popprocess.substate = processfailure;
          state.popprocess.rc = (eng_rcode) obj->rc;
        }
        else
        {
          state.smtpprocess.substate = processfailure;
          state.smtpprocess.rc = (eng_rcode) obj->rc;
        }
      }

      else if (code == ENG_COMPLETED)
      {
        if (handle == pop)
          state.popprocess.substate = popdone;
        else
          state.smtpprocess.substate = smtpdone;
      }
      
      else
      {
        /* process must be still running */
      }

      break;
    }

    case MBoxOpCB::GetNumMsgs :
    {
      MBoxOpCB_getnummsgs *obj = (MBoxOpCB_getnummsgs *) cb;
      eng_rcode code = (eng_rcode) obj->rc;
      dprintf(("Eng", "Receiving GetNumMsgs callback, rc = %d\n",code));
      if (code < 0)
      {
        /* error has occurred during getnum */
        state.popprocess.substate = getnumfailure;
        state.popprocess.rc = (eng_rcode) obj->rc;
      }
      else if (code == ENG_COMPLETED)
        state.popprocess.substate = gotnumber;

      else
      {
        /* process must be still running */
      }

      break;
    }
    case MBoxOpCB::GetHdrsFile :
    {
      MBoxOpCB_gethdrs_file *obj = (MBoxOpCB_gethdrs_file *) cb;
      eng_rcode code = (eng_rcode) obj->rc;
      dprintf(("Eng", "Receiving GetHdrsFile callback, rc = %d\n",code));
      if (code < 0)
      {
        /* error has occurred while fetching headers */
        state.download.substate = downloadfailure;
        state.download.rc = code;
      }
      else if (code == ENG_COMPLETED)
      {
        LockFile(SetFilename(state.download.msg->ID, true));
        state.download.substate = readytoparse;
      }

      else
      {
        /* process must be still running */
      }

      break;
    }
    case MBoxOpCB::GetMsgFile :
    {
      MBoxOpCB_getmsg_file *obj = (MBoxOpCB_getmsg_file *) cb;
      eng_rcode code = (eng_rcode) obj->rc;
      MessageDescriptor *msg = (handle == DOWNLOADMSG) ? state.download.msg : state.retrieve.msg;
      dprintf(("Eng", "Receiving GetMsgFile callback for %s, message %d, rc = %d\n",(handle == DOWNLOADMSG) ? "DOWNLOAD" : "RETRIEVE",msg->ID,code));
      if (code < 0)
      {
        /* error has occurred while fetching headers */
        if (handle == DOWNLOADMSG)
        {
          state.download.substate = downloadfailure;
          state.download.rc = code;
        }
        else
        {
          state.retrieve.substate = retrievefailure;
          state.retrieve.rc = code;
        }
      }

      else if (code == ENG_COMPLETED)
      {
        msg->flags &= ~DOWNLOADING;
        msg->flags |= DOWNLOADED;
        LockFile(SetFilename(msg->ID, false));
        if (handle == RETRIEVEMSG)
          state.retrieve.substate = readytoparse;
        else
        {
          state.download.msg = msg->next;
          state.download.substate = readytodownload;
        }

      }

      else
      {
        /* process must be still running */
      }

      break;
    }
    case MBoxOpCB::SetFlags :
    {
      MBoxOpCB_setflags *obj = (MBoxOpCB_setflags *) cb;
      eng_rcode code = (eng_rcode) obj->rc;
      dprintf(("Eng", "Receiving SetFlags callback, rc = %d\n",code));
      if (code < 0)
      {
        /* error has occurred while fetching headers */
        state.mark.substate = markfailure;
      }
      else if (code == ENG_COMPLETED)
        state.mark.substate = (state.state & MARKDELETE) ? deletedone : readdone;

      break;
    }
  }

}
