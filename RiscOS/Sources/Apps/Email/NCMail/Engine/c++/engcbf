/*
** Email Engine
** Callback functions
*/

#include "Email/Mailbox/MBoxCB.h"

#include "DebugLib/DebugLib.h"
#include "NBLib/NBDefs.h"

#include "Email/NetLink/NetLink.h"
#include "Email/NetLink/Permanent.h"

#include "engprocess.h"
#include "enginit.h"
#include "engtypes.h"
#include "engparse.h"
#include "enguiapi.h"
#include "engcbf.h"
#include "engdownld.h"

extern "C"
{
  #include "../Build/NCMailUI.h"
}

PermanentNetLink *netlink;

/*
** LineChange() is a callback function for NetLink Cntrl.
** It is called whenever a change in the status of the link is reported.
*/

void LineChange(NetLink::Status status, void *h)
{

  NB_UNUSED(h);

  switch (status)
  {
    case NetLink::Disconnected :

      dprintf(("Eng", "Receiving NetLink callback - disconnected\n"));
      online = false;
      disconnectpending = false;
      state &= ~(CONNECT + DISCONNECT);
      POPaccount->SetConnectionState(false);
      SMTPaccount->SetConnectionState(false);
      ncmui_line_state(false);
      StopTimeoutCount();
      StopReconnectCount();
      if (state & PREQUIT)
      {
        /* reinstate the shutdown process */
        appquit = true;
      }
      break;

    case NetLink::Connecting :

      dprintf(("Eng", "Receiving NetLink callback - connecting\n"));
      break;

    case NetLink::Connected :

      dprintf(("Eng", "Receiving NetLink callback - connected\n"));
      online = true;
      ncmui_line_state(true);
      POPaccount->SetConnectionState(true);
      SMTPaccount->SetConnectionState(true);
      state &= ~(CONNECT + DISCONNECT);
      if (state & RETRIEVEMSG)
        retrievestate.context = readytoconnect;
      else
        StartProcess();
      break;

    case NetLink::Error :

      dprintf(("Eng", "Receiving NetLink callback - error\n"));
      state &= ~(CONNECT + DISCONNECT);
      if (state & RETRIEVEMSG)
      {
        state &= ~(RETRIEVEMSG + DOWNLOADMSG);
        /* presumably abandon fetch a this point?*/
      }

      statusret.code = ENG_CONNECTIONFAILED;
      (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, 0);
      break;

    case NetLink::Disconnecting :

      dprintf(("Eng", "Receiving NetLink callback - disconnecting\n"));
      break;
  }

}


void ProcessCallback(ELib_rcode rc, uint32 handle, uint32 fail, uint32 ok)
{

  if (handle == pop)
  {
    popprocessstate.ret.rc = rc;
    if (rc < 0)
      popprocessstate.context = fail;
    else if (rc == ELIB_COMPLETED)
      popprocessstate.context = ok;
  }

  else
  {
    smtpprocessstate.ret.rc = rc;
    if (rc < 0)
      smtpprocessstate.context = fail;
    else
      smtpprocessstate.context = ok;
  }
}


void MBoxCallback(MBoxOpCB *cb, void *h)
{
  /*
  ** Generic function for receiving callbacks from Mailbox.
  ** Uses GetType method to determine what kind of callback
  ** and route it accordingly.
  */

  uint32 handle = (uint32) h;

  switch (cb->GetType())
  {
    case MBoxOpCB::Connect :

      dprintf(("Eng", "Receiving Connect callback for %s, rc = %d\n",((handle == pop) ? "POP" : "SMTP"),cb->rc));
      ProcessCallback(cb->rc, handle, connectfailure, connected);

      break;

    case MBoxOpCB::Disconnect :

      dprintf(("Eng", "Receiving Disconnect callback for %s, rc = %d\n",((handle == pop) ? "POP" : "SMTP"),cb->rc));
      ProcessCallback(cb->rc, handle, disconnectfailure, disconnected);

      break;

    case MBoxOpCB::Expunge :

      dprintf(("Eng", "Receiving Expunge callback for %s, rc = %d\n",((handle == pop) ? "POP" : "SMTP"),cb->rc));
      if (handle == smtp)
      {
        smtpprocessstate.ret.rc = cb->rc;
        smtpprocessstate.context = expunged;
      }

      else
      {
        popprocessstate.ret.rc =cb->rc;
        if (cb->rc < 0)
        {
          /* error has occurred during expunge */
          ourmboxin->flags |= MBOXINCOMPLETE;
          popprocessstate.context = readytoprocess;
        }
        else
        {
          /* expunge has happened (presumably) */
          popprocessstate.context = readytoprocess;
        }
      }

      if (state & MARKDELETE)
      {
        state &= ~PROCESSPOP;
        markstate.context = readytodisplay;
      }

      break;

    case MBoxOpCB::Process :

      dprintf(("Eng", "Receiving Process callback for %s, rc = %d\n",((handle == pop) ? "POP" : "SMTP"),cb->rc));
      ProcessCallback(cb->rc, handle, processfailure, done);

      break;

    case MBoxOpCB::GetNumMsgs :

      dprintf(("Eng", "Receiving GetNumMsgs callback for %s, rc = %d\n",((handle == pop) ? "POP" : "SMTP"),cb->rc));
      ProcessCallback(cb->rc, handle, getnumfailure, gotnumber);

      break;

    case MBoxOpCB::GetHdrsFile :

      dprintf(("Eng", "Receiving GetHdrsFile callback, rc = %d\n",cb->rc));
      downloadstate.ret.rc = cb->rc;
      if (cb->rc < 0)
      {
        /* error has occurred while fetching headers */
        downloadstate.context = downloadfailure;
      }
      else if (cb->rc == ENG_COMPLETED)
      {
        LockFile(SetFilename(downloadstate.msg->ID, true));
        downloadstate.context = downloaddone;
      }

      else
      {
        /* process must be still running */
      }

      break;

    case MBoxOpCB::GetMsgFile :

      dprintf(("Eng", "Receiving GetMsgFile callback for %s, message %d, rc = %d\n",(handle == DOWNLOADMSG) ? "DOWNLOAD" : "RETRIEVE",(handle == DOWNLOADMSG) ? downloadstate.msg->ID : retrievestate.msg->ID,cb->rc));
      if (cb->rc < 0)
      {
        /* error has occurred while fetching headers */
        if (handle == DOWNLOADMSG)
        {
          downloadstate.context = downloadfailure;
          downloadstate.ret.rc = cb->rc;
        }
        else
        {
          retrievestate.context = retrievefailure;
          retrievestate.ret.rc = cb->rc;
        }
      }

      else if (cb->rc == ENG_COMPLETED)
      {
        MessageDescriptor *msg = (handle == DOWNLOADMSG) ? downloadstate.msg : retrievestate.msg;
        msg->flags &= ~DOWNLOADING;
        msg->flags |= DOWNLOADED;
        LockFile(SetFilename(msg->ID, false));
        if (handle == RETRIEVEMSG)
          retrievestate.context = readytoparse;
        else
        {
          downloadstate.msg = msg->next;
          downloadstate.context = readytodownload;
        }

      }

      else
      {
        /* process must be still running */
      }

      break;

    case MBoxOpCB::SetFlags :

      dprintf(("Eng", "Receiving SetFlags callback, rc = %d\n",cb->rc));
      if (cb->rc < 0)
      {
        /* error has occurred while fetching headers */
        markstate.context = markfailure;
      }
      else if (cb->rc == ENG_COMPLETED)
        markstate.context = (state & MARKDELETE) ? deletedone : readdone;

      break;
  }

}
