/*
** Email Client
** Send message routines
*/

#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "DebugLib/DebugLib.h"

#include "Email/Mailbox/SendQ/SendQAccount.h"
#include "Email/Mailbox/SendQ/SendQMailbox.h"
#include "Email/Mailbox/Mailbox.h"
#include "Email/EmailLib/rfc822msg.h"
#include "Email/EmailLib/MIMEtext.h"
#include "Email/EmailLib/ELib.h"
#include "Email/EmailLib/entity.h"
#include "Email/EmailLib/to.h"
#include "Email/EmailLib/cc.h"
#include "Email/EmailLib/subject.h"
#include "Email/EmailLib/body.h"
#include "Email/EmailLib/from.h"

#include "engtypes.h"
#include "engmanager.h"
#include "engfile.h"
#include "engcbf.h"
#include "engprocess.h"
#include "engparse.h"

bool sendpending = false;
static char scrapf[] = "<Wimp$ScrapDir>.TempMime";

void CleanupSend(void)
{

  UnlockFile(sendstate.bodyname);
  remove(sendstate.bodyname);
  dprintf(("Eng", "Removing file %s\n",sendstate.bodyname));
  free(sendstate.bodyname);
  delete sendstate.rfc;
  destroy_context(&sendstate.elibcontext);

}


void SendMessage(void)
{

  ELib_rcode code;
  MessageDescriptor *msg = sendstate.msg;
  char *file = SetFilename(msg->ID, true);
  char *reciplist, *sendlist;
  SendQMailbox *outbox;

  sendstate.ret.code = ENG_RUNNING;
  dprintf(("Eng", "About to get recipient list\n"));
  code = sendstate.rfc->GetRecipients(reciplist);
  if (code < 0)
  {
    /* error getting recipient list - default to To header */
    dprintf(("Eng", "Error getting recipients, rc=%d\n",code));
    sendlist = msg->to;
  }
  else
  {
    dprintf(("Eng", "Got recipient list: %s\n",reciplist));
    sendlist = reciplist;
  }
  sendstate.context = idle;
  outbox = (SendQMailbox *) SMTPaccount->GetInbox();
  code = outbox->AddMessage(file, sendlist, msg->fromaddr);
  dprintf(("Eng", "Added message to %s, from %s, cc'd to %s, rc=%d\n",msg->to,msg->fromaddr,msg->cc,code));
  if (code < 0)
  {
    /* error adding message to send queue */
    sendstate.ret.code = ENG_SENDFAILED;
  }

  LockFile(file);
  sendpending = true;
  CleanupSend();
  delete[] reciplist;
  if (sendstate.ret.code == ENG_SENDFAILED)
  {
    state &= ~SEND;
    sendpending = false;
    sendstate.ret.code = ENG_SENDFAILED;
    (*callbacklist.sendfunc)(&sendstate.ret, callbacklist.sendhandle);
  }
    
  else if ((smtpstatus != acctnonexistent) && (online))
  {
    smtpprocessstate.context = readytosend;
    state |= PROCESSSMTP;
  }

  else
  {
    state &= ~SEND;
    sendstate.ret.code = ENG_ADDEDMSG;
    (*callbacklist.sendfunc)(&sendstate.ret, callbacklist.sendhandle);
  }

}


bool AddHeader(headers *hdrs, header *hdr, char *s)
{

  ELib_rcode code = ELIB_COMPLETED;

  if (s)
    code = hdr->SetBody(s);
  if (code >= 0)
  {
    code = hdr->ParseData(sendstate.elibcontext, 0);
    if (code >= 0)
    {
      code = hdrs->AddHdr(*hdr);
    }
  }

  if (code < 0)
  {
    delete hdr;
    sendstate.context = parsefailure;
    sendstate.ret.code = (eng_rcode) code;
    return false;
  }

  return true;

}


void AssembleMessage(MessageDescriptor *msg)
{

  ELib_rcode code;

  MIMEtext *ent = new MIMEtext(true, scrapf, 0, 0, ELIB_CT_TEXT_PLAIN, true);
  if (!ent)
  {
    sendstate.context = parsefailure;
    sendstate.ret.code = ENG_NOMEMORY;
    return;
  }

  sendstate.ret.code = ENG_COMPLETED;
  code = ent->ReplaceBody(sendstate.msgbody);
  if (code < 0)
  {
    sendstate.context = parsefailure;
    sendstate.ret.code = (eng_rcode) code;
    return;
  }

  to *tohdr = new to(false, 0, 0, 0, true);
  cc *cchdr = new cc(false, 0, 0, 0, true);
  subject *subhdr = new subject(false, 0, 0, 0, true);
  from *fromhdr = new from(false, 0, 0, 0, true);

  fromhdr->SetRealName(realname);
  fromhdr->SetAddress(emailaddr);
  rfc822msg *rfc = new rfc822msg(true, 0, 0, 0, true);
  if (!rfc)
  {
    sendstate.context = parsefailure;
    sendstate.ret.code = ENG_NOMEMORY;
    return;
  }

  headers *hdrs = rfc->GetHdrs();

  if (!AddHeader(hdrs, (header *) tohdr, msg->to))
    return;

  if (!AddHeader(hdrs, (header *) fromhdr, 0))
    return;

  if (!AddHeader(hdrs, (header *) cchdr, msg->cc))
    return;

  if (!AddHeader(hdrs, (header *) subhdr, msg->subject))
    return;

  sendstate.file = fopen(SetFilename(msg->ID, true), "w");
  dprintf(("Eng", "File handle for writing out is %d\n",sendstate.file));
  rfc->MergeMIMEentity(ent);
  sendstate.rfc = rfc;
  sendstate.context = readytowrite;

}


void DoCreateMessage(void)
{

  ELib_rcode rc;
  eng_rcode code;

  switch (createstate.context)
  {
    case readytocreate :

      dprintf(("Eng", "Create context is readytocreate\n"));
      if (state & CREATE)
      {
        state &= ~CREATE;
        dprintf(("Eng", "Calling back UI with new message %d\n",createstate.msg->ID));
        createstate.ret.code = ENG_COMPLETED;
        (*callbacklist.createfunc)(&createstate.ret, createstate.msg, callbacklist.createhandle);
      }

      else
      {
        /* get EmailLib to return a reply correctly formatted */

        dprintf(("Eng", "Asking EmailLib to prepare reply\n"));
        createstate.replyobj = 0;
        EntityDescriptor *replyent = NewEntity(createstate.msg, reply);
        if (!replyent)
        {
          createstate.context = createfailure;
          createstate.ret.code = ENG_NOMEMORY;
          return;
        }

        dprintf(("Eng", "About to create reply from object at 0x%x into file %s\n",createstate.reply->elibobj,replyent->fname));
        createstate.msg->entity_list = replyent;
        dprintf(("Eng", "Msg is at 0x%x, entitynum=%d, entity list is at 0x%x\n",createstate.msg,createstate.msg->entity_num,createstate.msg->entity_list));
        rc = createstate.reply->elibobj->CreateReply(createstate.replyobj, replyent->fname, true);
        dprintf(("Eng", "Creating reply in %s, rc=%d\n",replyent->fname,rc));
        
        createstate.context = readytoparse;
      }

      break;

    case readytoparse :
    {
      headers *hdrs = createstate.replyobj->GetHdrs();
      dprintf(("Eng", "Create context is readytoparse\n"));

      if ((code = GetHeader(&createstate.msg->to, hdrs, ELIB_HDR_TO)) == ENG_NOMEMORY)
        createstate.ret.code = code;
      else if (code >= 0)
        dprintf(("Eng", "To = %s\n",createstate.msg->to));

      if ((code = GetHeader(&createstate.msg->subject, hdrs, ELIB_HDR_SUBJECT)) < 0)
      {
        createstate.context = createfailure;
        createstate.ret.code = code;
      }
      else
        dprintf(("Eng", "Subject = %s\n",(createstate.msg->subject) ? createstate.msg->subject : "none"));
        dprintf(("Eng", "Calling back UI with new message %d\n",createstate.msg->ID));
        createstate.ret.code = ENG_COMPLETED;
        (*callbacklist.createfunc)(&createstate.ret, createstate.msg, callbacklist.createhandle);
      state &= ~REPLY;

      break;
    }
  }

}


void DoSend(void)
{

  MessageDescriptor *msg = sendstate.msg;
  ELib_rcode code;

  switch (sendstate.context)
  {
    case readytoparse :

      dprintf(("Eng", "Send context is readytoparse\n"));
      if ((code = new_context(&sendstate.elibcontext)) < 0)
      {
        /* error setting up context */
        dprintf(("Eng", "***ERROR*** Error setting up context, code=%d\n",code));
        sendstate.context = parsefailure;
        sendstate.ret.code = (eng_rcode) code;
      }
      else
      {
        uint32 len = GetFileLength(sendstate.bodyname);
        sendstate.msgbody = new body(true, sendstate.bodyname, 0, len, ELIB_TE_NONE, true);
        sendstate.context = readytoencode;
      }

      break;

    case parsefailure :

      /* creation of new message has failed */
      dprintf(("Eng", "Send context is parsefailure, rc=%d\n",sendstate.ret.code));
      if (sendstate.ret.code != ENG_NOMEMORY)
        sendstate.ret.code = ENG_SENDFAILED;
      (*callbacklist.sendfunc)(&sendstate.ret, callbacklist.sendhandle);
      state &= ~SEND;
      CleanupSend();
      break;

    case readytoencode :

      dprintf(("Eng", "Send context is readytoencode\n"));
//      code = sendstate.msgbody->ApplyEncoding(sendstate.elibcontext, clock() + 25, ELIB_TE_QUOTED_PRINTABLE, scrapf1, 0x1000);
      code = sendstate.msgbody->ParseData(sendstate.elibcontext, clock() + 25);
      if (code < 0)
      {
        dprintf(("Eng", "***ERROR*** Parsefailure rc=%d\n",code));
        sendstate.context = parsefailure;
        sendstate.ret.code = (eng_rcode) code;
      }
      else if (code != ELIB_RUNNING)
        sendstate.context = encoded;

      break;

    case encoded :

      dprintf(("Eng", "Send context is encoded\n"));
      AssembleMessage(msg);
      break;

    case readytowrite :

      dprintf(("Eng", "Send context is readytowrite\n"));
//      code = sendstate.rfc->WriteOut(sendstate.elibcontext, clock() + 25, sendstate.file);
      code = sendstate.rfc->WriteOut(sendstate.elibcontext, clock() + 25, sendstate.file, ELIB_TE_7BIT);
      dprintf(("Eng", "Writing out file\n"));
      if (code < 0)
      {
        sendstate.context = parsefailure;
        sendstate.ret.code = (eng_rcode) code;
      }
      else if (code != ELIB_RUNNING)
        sendstate.context = writedone;

    case writedone :

      dprintf(("Eng", "Send context is writedone\n"));
      fclose(sendstate.file);
      LockFile(SetFilename(msg->ID, true));
      remove(scrapf);

      SendMessage();

      break;
  }

}
