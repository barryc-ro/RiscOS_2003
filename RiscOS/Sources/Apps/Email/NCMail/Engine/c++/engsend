/*
** Email Client
** Send message routines
*/

#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "DebugLib/DebugLib.h"
#include "NBLib/NBDefs.h"

#include "Email/Mailbox/SendQ/SendQAccount.h"
#include "Email/Mailbox/SendQ/SendQMailbox.h"
#include "Email/Mailbox/Mailbox.h"
#include "Email/EmailLib/rfc822msg.h"
#include "Email/EmailLib/MIMEtext.h"
#include "Email/EmailLib/ELib.h"
#include "Email/EmailLib/entity.h"
#include "Email/EmailLib/to.h"
#include "Email/EmailLib/cc.h"
#include "Email/EmailLib/subject.h"
#include "Email/EmailLib/body.h"
#include "Email/EmailLib/from.h"

#include "engtypes.h"
#include "engmanager.h"
#include "engfile.h"
#include "engcbf.h"
#include "engprocess.h"
#include "engparse.h"

bool sendpending = false;
static char scrapf[] = "<Wimp$ScrapDir>.TempMime";

void CleanupSend(void)
{

  UnlockFile(sendstate.bodyname);
  remove(sendstate.bodyname);
  dprintf(("Eng", "Removing file %s\n",sendstate.bodyname));
  free(sendstate.bodyname);
  if (sendstate.rfc)
    delete sendstate.rfc;
  destroy_context(&sendstate.elibcontext);

}


void SendMessage(void)
{

  ELib_rcode rc;
  MessageDescriptor *msg = sendstate.msg;
  char *file = SetFilename(msg->ID, true);
  char *reciplist, *sendlist;
  SendQMailbox *outbox;

  sendstate.ret.code = ENG_RUNNING;
  dprintf(("Eng", "About to get recipient list\n"));
  rc = sendstate.rfc->GetRecipients(reciplist);
  if (rc < 0)
  {
    /* error getting recipient list - default to To header */
    dprintf(("Eng", "Error getting recipients, rc=%d\n",rc));
    sendlist = msg->to;
  }
  else
  {
    dprintf(("Eng", "Got recipient list: %s\n",reciplist));
    sendlist = reciplist;
  }
  sendstate.context = idle;
  outbox = (SendQMailbox *) SMTPaccount->GetInbox();
  rc = outbox->AddMessage(file, sendlist, msg->fromaddr);
  dprintf(("Eng", "Added message to %s, from %s, cc'd to %s, rc=%d\n",msg->to,msg->fromaddr,msg->cc,rc));
  if (rc < 0)
  {
    /* error adding message to send queue */
    sendstate.ret.rc = rc;
  }

  CleanupSend();
  if (reciplist)
    delete[] reciplist;
  if (sendstate.ret.rc < 0)
  {
    state &= ~SEND;
    sendpending = false;
    sendstate.ret.code = ENG_SENDFAILED;
    (*callbacklist.sendfunc)(&sendstate.ret, callbacklist.sendhandle);
  }
    
  else
  {
    LockFile(file);
    sendpending = true;
    createstate.msg = 0;
    if ((smtpstatus != acctnonexistent) && (online))
    {
      smtpprocessstate.context = readytosend;
      state |= PROCESSSMTP;
    }

    else
    {
      state &= ~SEND;
      sendstate.ret.code = ENG_ADDEDMSG;
      (*callbacklist.sendfunc)(&sendstate.ret, callbacklist.sendhandle);
    }
  }
}


ELib_rcode AddHeader(headers *hdrs, header *hdr, char *s)
{

  ELib_rcode rc = ELIB_COMPLETED;

  if (s)
    rc = hdr->SetBody(s);
  if (rc >= 0)
  {
    rc = hdr->ParseData(sendstate.elibcontext, 0);
    if (rc >= 0)
    {
      rc = hdrs->AddHdr(*hdr);
    }
  }

  if (rc < 0)
  {
    if (hdr)
      delete hdr;
  }

  return rc;

}


ELib_rcode AssembleMessage(MessageDescriptor *msg)
{

  ELib_rcode rc;

  MIMEtext *ent = new MIMEtext(true, scrapf, 0, 0, ELIB_CT_TEXT_PLAIN, true);
  if (!ent)
    return ELIB_EMALLOCFAILED;

  rc = ent->ReplaceBody(sendstate.msgbody);
  if (rc < 0)
    return rc;

  to *tohdr = new to(false, 0, 0, 0, true);
  cc *cchdr = new cc(false, 0, 0, 0, true);
  subject *subhdr = new subject(false, 0, 0, 0, true);
  from *fromhdr = new from(false, 0, 0, 0, true);
  if ((!tohdr) || (!cchdr) || (!subhdr) | (!fromhdr))
    return ELIB_EMALLOCFAILED;

  fromhdr->SetRealName(realname);
  fromhdr->SetAddress(emailaddr);
  rfc822msg *rfc = new rfc822msg(true, 0, 0, 0, true);
  if (!rfc)
    return ELIB_EMALLOCFAILED;

  headers *hdrs = rfc->GetHdrs();

  if ((rc = AddHeader(hdrs, (header *) tohdr, msg->to)) < 0)
    return rc;

  if ((rc = AddHeader(hdrs, (header *) fromhdr, 0)) < 0)
    return rc;

  if (msg->cc)
  {
    if ((rc = AddHeader(hdrs, (header *) cchdr, msg->cc)) < 0)
      return rc;
  }

  if ((rc = AddHeader(hdrs, (header *) subhdr, msg->subject)) < 0)
    return rc;

  sendstate.file = fopen(SetFilename(msg->ID, true), "w");
  dprintf(("Eng", "File handle for writing out is %d\n",sendstate.file));
  rfc->MergeMIMEentity(ent);
  sendstate.rfc = rfc;
  
  return rc;

}


void DoCreateMessage(void)
{

  ELib_rcode rc;

  switch (createstate.context)
  {
    case readytocreate :

      dprintf(("Eng", "Create context is readytocreate\n"));
      if (state & CREATE)
      {
        state &= ~CREATE;
        dprintf(("Eng", "Calling back UI with new message %d\n",createstate.msg->ID));
        createstate.ret.code = ENG_COMPLETED;
        (*callbacklist.createfunc)(&createstate.ret, createstate.msg, callbacklist.createhandle);
      }

      else
      {
        /* get EmailLib to return a reply correctly formatted */

        dprintf(("Eng", "Asking EmailLib to prepare reply\n"));
        createstate.replyobj = 0;
        EntityDescriptor *replyent = NewEntity(createstate.msg, reply);
        if (!replyent)
        {
          createstate.context = createfailure;
          createstate.ret.rc = ELIB_EMALLOCFAILED;
        }

        else
        {
          dprintf(("Eng", "About to create reply from object at 0x%x into file %s\n",createstate.orig->elibobj,replyent->fname));
          createstate.msg->entity_list = replyent;
          dprintf(("Eng", "Msg is at 0x%x, entitynum=%d, entity list is at 0x%x\n",createstate.msg,createstate.msg->entity_num,createstate.msg->entity_list));
          rc = createstate.orig->elibobj->CreateReply(createstate.replyobj, replyent->fname, true);
          dprintf(("Eng", "Creating reply in %s, rc=%d\n",replyent->fname,rc));
          if (rc < 0)
          {
            createstate.context = createfailure;
            createstate.ret.rc = rc;
          }
          else
            createstate.context = readytoparse;
        }
      }

      break;

    case readytoparse :
    {
      headers *hdrs = createstate.replyobj->GetHdrs();
      dprintf(("Eng", "Create context is readytoparse\n"));

      if ((rc = GetHeader(&createstate.msg->to, hdrs, ELIB_HDR_TO)) < 0)
        createstate.ret.rc = rc;
      else
      {
        dprintf(("Eng", "To = %s\n",createstate.msg->to));
        if ((rc = GetHeader(&createstate.msg->subject, hdrs, ELIB_HDR_SUBJECT)) < 0)
          createstate.ret.rc = rc;
        else
          dprintf(("Eng", "Subject = %s\n",(createstate.msg->subject) ? createstate.msg->subject : "none"));
      }

      if (createstate.ret.rc < 0)
        createstate.context = createfailure;
      else
      {
        dprintf(("Eng", "Calling back UI with new message %d\n",createstate.msg->ID));
        createstate.ret.code = ENG_COMPLETED;
        (*callbacklist.createfunc)(&createstate.ret, createstate.msg, callbacklist.createhandle);
        state &= ~REPLY;
      }

      break;
    }
    case createfailure :

      createstate.ret.code = (createstate.ret.rc == ELIB_EMALLOCFAILED) ? ENG_NOMEMORY : ENG_CREATEFAILED;
        (*callbacklist.createfunc)(&createstate.ret, createstate.msg, callbacklist.createhandle);
        state &= ~(CREATE + REPLY);
      break;
  }

}


void DoSend(void)
{

  MessageDescriptor *msg = sendstate.msg;
  ELib_rcode rc;

  switch (sendstate.context)
  {
    case readytoparse :

      dprintf(("Eng", "Send context is readytoparse\n"));
      if ((rc = new_context(&sendstate.elibcontext)) < 0)
      {
        /* error setting up context */
        dprintf(("Eng", "***ERROR*** Error setting up context, code=%d\n",rc));
        sendstate.context = parsefailure;
        sendstate.ret.rc = rc;
      }
      else
      {
        uint32 len = GetFileLength(sendstate.bodyname);
        sendstate.msgbody = new body(true, sendstate.bodyname, 0, len, ELIB_TE_NONE, true);
        if (!sendstate.msgbody)
        {
          sendstate.context = parsefailure;
          sendstate.ret.rc = ELIB_EMALLOCFAILED;
        }
        else
          sendstate.context = readytoencode;
      }

      break;

    case parsefailure :

      /* creation of new message has failed */
      dprintf(("Eng", "Send context is parsefailure, rc=%d\n",sendstate.ret.code));
      if (sendstate.ret.code != ENG_NOMEMORY)
        sendstate.ret.code = ENG_SENDFAILED;
      (*callbacklist.sendfunc)(&sendstate.ret, callbacklist.sendhandle);
      state &= ~SEND;
      CleanupSend();
      break;

    case readytoencode :

      dprintf(("Eng", "Send context is readytoencode\n"));
//      code = sendstate.msgbody->ApplyEncoding(sendstate.elibcontext, clock() + 25, ELIB_TE_QUOTED_PRINTABLE, scrapf1, 0x1000);
      rc = sendstate.msgbody->ParseData(sendstate.elibcontext, clock() + 25);
      if (rc < 0)
      {
        dprintf(("Eng", "***ERROR*** Parsefailure rc=%d\n",rc));
        sendstate.context = parsefailure;
        sendstate.ret.rc = rc;
      }
      else if (rc != ELIB_RUNNING)
        sendstate.context = encoded;

      break;

    case encoded :

      dprintf(("Eng", "Send context is encoded\n"));
      rc = AssembleMessage(msg);
      if (rc >= 0)
        sendstate.context = readytowrite;
      else
      {
        sendstate.ret.rc = rc;
        sendstate.context = parsefailure;
      }

      break;

    case readytowrite :

      dprintf(("Eng", "Send context is readytowrite\n"));
//      code = sendstate.rfc->WriteOut(sendstate.elibcontext, clock() + 25, sendstate.file);
      rc = sendstate.rfc->WriteOut(sendstate.elibcontext, clock() + 25, sendstate.file, ELIB_TE_7BIT);
      dprintf(("Eng", "Writing out file\n"));
      if (rc < 0)
      {
        sendstate.context = parsefailure;
        sendstate.ret.rc = rc;
      }
      else if (rc != ELIB_RUNNING)
        sendstate.context = writedone;

    case writedone :

      dprintf(("Eng", "Send context is writedone\n"));
      fclose(sendstate.file);
      LockFile(SetFilename(msg->ID, true));
      remove(scrapf);

      SendMessage();

      break;
  }

}


void ConfirmSend(bool conf, void *h)
{

  NB_UNUSED(h);
  if (conf)
  {
    /************************************
    *** ATTENTION
    ************************************/
    /* User has confirmed he wants to send mail */
  }

  else
  {
    /************************************
    *** ATTENTION
    ************************************/
    /* user has rejected mail - restart PreQuit sequence */
  }

}


void ConfirmResend(bool conf, void *h)
{

  NB_UNUSED(h);
  smtpprocessstate.attempts = 0;
  if (conf)
    StartOffSMTP();

}
