/*
** Email Engine
** Event handlers
*/

#include "stdlib.h"
#include "time.h"
#include "string.h"
#include "swis.h"

#include "tboxlibs/wimplib.h"
#include "tboxlibs/event.h"
#include "tboxlibs/quit.h"
#include "tboxlibs/wimp.h"

#include "DebugLib/DebugLib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

#include "Email/Mailbox/WimpRegistry.h"

#include "enginit.h"
#include "engstr.h"
#include "engevent.h"
#include "engprocess.h"
#include "engtypes.h"
#include "engparse.h"
#include "engdownld.h"
#include "enguiapi.h"

int *pollword;

enum pwtime {disconnecttime = 1, reprocesstime};

int tbevents[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, Toolbox_ObjectAutoCreated, Quit_Quit, 0};

int Messages(WimpMessage *msg, void *h)
{

  switch (msg->hdr.action_code)
  {

    case Wimp_MPreQuit :

      PreShutDown(msg);
      break;

    case Wimp_MQuit :

      ShutDown();
      break;

  }

  return 1;

}


int NullEvent(int code, WimpPollBlock *blk, IdBlock *idblock, void *h)
{
  
  clock_t t = clock();

  /*
  ** Check engine state and farm out processes to each active bit.
  ** Each process needs to save its context on each pass,
  ** ready for the next pass.
  **
  ** Stop at any point if more than 0.5 seconds has passed.
  */
  
  if (state & INIT)
  {
    if (((clock() - t) < 50) && (initstate.context != idle))
      DoCreateAccount();
  }

  if (state & PROCESSPOP)
  {
    if (((clock() - t) < 50) && (popprocessstate.context != idle))
      DoPOPProcess();
  }

  if (state & PROCESSSMTP)
  {
    if (((clock() - t) < 50) && (smtpprocessstate.context != idle))
      DoSMTPProcess();
  }

  if (state & DOWNLOADHDR)
  {
    if (((clock() - t) < 50) && (downloadstate.context != idle))
      DownloadHeader();
    if (((clock() - t) < 50) && (parsehdrstate.context != idle))
      DoParseHeader();
  }

  else if (state & DOWNLOADMSG)
  {
    if (((clock() - t) < 50) && (downloadstate.context != idle))
      DownloadMessage();
  }
  
  if (state & RETRIEVEMSG)
  {
    if (((clock() - t) < 50) && (retrievestate.context != idle))
      DoRetrieve();
  }

  if (state & (CREATE | REPLY))
  {
    if (((clock() - t) < 50) && (createstate.context != idle))
      DoCreateMessage();
  }

  else if (state & SEND)
  {
    if (((clock() - t) < 50) && (sendstate.context != idle))
      DoSend();
  }

  if (state & (MARKDELETE | MARKREAD))
  {
    if (((clock() - t) < 50) && (markstate.context != idle))
      DoMark();
  }

  return 1;

}


int PollWord(int code, WimpPollBlock *blk, IdBlock *idblock, void *h)
{
  
  int pw = *pollword;
  
  *pollword = 0;

  dprintf(("Eng", "Receiving pollword = %d\n",pw));
  switch (pw)
  {
    case disconnecttime :

      /* connection has timed out */
      PreDisconnect(false);
      break;
      
    case reprocesstime :
      
      /* time to reprocess mailbox if still online */
      if (online)
      {
        dprintf(("Eng", "Reprocessing mailbox\n"));
        StartProcess();
      }
      
      break;
  }
  
  return 1;
}

        
int TBEvents(int code, ToolboxEvent *event, IdBlock *idblock, void *h)
{

  switch (code)
  {
    case Quit_Quit :

      appquit = true;
      break;
  }

  return 1;
}


int *GetWorkspace(void)
{
  
  static char modname[] = "NCMailSupport";
  
  regs.r[0] = 18;
  regs.r[1] = (int) modname;
  _kernel_swi(OS_Module,&regs,&regs);
  return (int *) regs.r[4];

}


int main(int argc, char *argv[])
{

#ifdef MemCheck_MEMCHECK
  MemCheck_InitNoDebug();
  MemCheck_RedirectToFilename("<NCMail$Dir>.MemCheck");
  MemCheck_SetStoreMallocFunctions(1);
  MemCheck_InterceptSCLStringFunctions();
  MemCheck_RegisterMiscBlock(WimpRegistry::Instance(), sizeof(WimpRegistry));
#endif

  if (!AppInit())
    exit(1);

  do
  {
    if (appquit)
      ShutDown();
    else
    {
      pollword = GetWorkspace();
      /* if engine is idle, suppress null codes */
      event_set_mask((state == IDLE) ? 0x401831 : 0x401830);
      event_poll(0, 0, pollword);
    }
  }
  while (true);

}
