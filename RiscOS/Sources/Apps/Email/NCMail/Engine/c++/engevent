/*
** Email Engine
** Event handlers
*/

#include "stdlib.h"
#include "time.h"
#include "string.h"

#include "tboxlibs/wimplib.h"
#include "tboxlibs/event.h"
#include "tboxlibs/quit.h"
#include "tboxlibs/wimp.h"

#include "DebugLib/DebugLib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

#include "Email/Mailbox/WimpRegistry.h"

#include "enginit.h"
#include "engstr.h"
#include "engevent.h"
#include "engprocess.h"
#include "engtypes.h"
#include "engparse.h"
#include "engdownld.h"
#include "enguiapi.h"


int tbevents[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, Toolbox_ObjectAutoCreated, Quit_Quit, 0};

int Messages(WimpMessage *msg, void *h)
{

  switch (msg->hdr.action_code)
  {

    case Wimp_MPreQuit :

      PreShutDown();
      break;

    case Wimp_MQuit :

      ShutDown();
      break;

  }

  return 1;

}


int NullEvent(int code, WimpPollBlock *blk, IdBlock *idblock, void *h)
{
  
  clock_t t = clock();

  /*
  ** Check engine state and farm out processes to each active bit.
  ** Each process needs to save its context on each pass,
  ** ready for the next pass.
  **
  ** Stop at any point if more than 0.5 seconds has passed.
  */

  /*
  ** INIT and PROCESS are mutually exclusive since we can't
  ** process until we've created the accounts, hence the 'else if'.
  ** Similarly, DOWNLOADHDR and DOWNLOADMSG will not occur together
  ** since there are few if any circumstances where this would
  ** be necessary.
  **
  ** However, other engine states may operate concurrently
  ** and can therefore be preemptively threaded until time runs out.
  */
  
  if (state.state & INIT)
  {
    if (((clock() - t) < 50) && (state.init.substate != idle))
      DoCreateAccount();
  }

  if (state.state & PROCESSPOP)
  {
    if (((clock() - t) < 50) && (state.popprocess.substate != idle))
      DoPOPProcess();
  }

  if (state.state & PROCESSSMTP)
  {
    if (((clock() - t) < 50) && (state.smtpprocess.substate != idle))
      DoSMTPProcess();
  }

  if (state.state & DOWNLOADHDR)
  {
    if (((clock() - t) < 50) && (state.download.substate != idle))
      DownloadHeader();
  }

  else if (state.state & DOWNLOADMSG)
  {
    if (((clock() - t) < 50) && (state.download.substate != idle))
      DownloadMessage();
  }
  
  if (state.state & RETRIEVEENT)
  {
    if ((clock() - t) < 50)
      WriteOutSlice();
  }

  if (state.state & (CREATE | REPLY))
  {
    if (((clock() - t) < 50) && (state.create.substate != idle))
      DoCreateMessage();
  }

  else if (state.state & SEND)
  {
    if (((clock() - t) < 50) && (state.send.substate != idle))
      DoSend();
  }

  if (state.state & DELETE)
  {
    if (((clock() - t) < 50) && (state.mark.substate != idle))
      DoMark();
  }

  return 1;

}


int TBEvents(int code, ToolboxEvent *event, IdBlock *idblock, void *h)
{

  switch (code)
  {
    case Quit_Quit :

      appquit = true;
      break;
  }

  return 1;
}


int main(int argc, char *argv[])
{

/*   TraceInit(); */
  
#ifdef MemCheck_MEMCHECK
  MemCheck_InitNoDebug();
  MemCheck_RedirectToFilename("<NCMail$Dir>.MemCheck");
  MemCheck_SetStoreMallocFunctions(1);
  MemCheck_InterceptSCLStringFunctions();
  MemCheck_RegisterMiscBlock(WimpRegistry::Instance(), sizeof(WimpRegistry));
#endif

  if (!AppInit())
    exit(1);

  while (!appquit)
  {
    /* if engine is idle, suppress null codes */
    event_set_mask((state.state == IDLE) ? 0x401831 : 0x401830);
    event_poll(0, 0, 0);
  }

#ifdef MemCheck_MEMCHECK
  MemCheck_UnRegisterMiscBlock(WimpRegistry::Instance());
  MemCheck_OutputBlocksInfo();
#endif
  
  exit(0);

}
