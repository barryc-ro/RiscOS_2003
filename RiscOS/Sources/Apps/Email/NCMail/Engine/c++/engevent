/*
** Email Engine
** Event handlers
*/

#include "stdlib.h"
#include "time.h"
#include "string.h"
#include "swis.h"

#include "tboxlibs/wimplib.h"
#include "tboxlibs/event.h"
#include "tboxlibs/quit.h"
#include "tboxlibs/wimp.h"

#include "DebugLib/DebugLib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif
#ifdef HierProf_PROFILE
  #include "HierProf:HierProf.h"
#endif

#include "Email/Mailbox/WimpRegistry.h"

#include "enginit.h"
#include "engstr.h"
#include "engevent.h"
#include "engprocess.h"
#include "engtypes.h"
#include "engparse.h"
#include "engdownld.h"
#include "enguiapi.h"
#include "enguser.h"
#include "engsend.h"
#include "engmanager.h"

#include "Version.h"
#include "../Build/UIVersion.h"
#include "Email/Common/Version.h"
#include "Email/EmailLib/Version.h"
#include "Email/Mailbox/Version.h"
#include "Email/NetLink/Version.h"

#include "NBLib/NBDefs.h"

int nexttimeout = 0, nextreconnect = 0, nextretry = 0;;
bool timeoutactive = false, reconactive = false, retryactive = false;

#ifdef ENGINE
  int tbevents[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, Toolbox_ObjectAutoCreated, Quit_Quit, 0};
#else
  int tbevents[] = {Quit_Quit, 0};
#endif

/*
** Messages() handles Wimp messages destined for the Engine
** (i.e. not those registered with WimpRegistry by Mailbox and UI).
** Currently only PreQuit and Quit are handled.
*/

int Messages(WimpMessage *msg, void *h)
{

  (void)(h);
  switch (msg->hdr.action_code)
  {

    case Wimp_MPreQuit :

      PreShutDown(msg);
      break;

    case Wimp_MQuit :

      ShutDown();
      break;

  }

  return 1;

}


/*
** NullEvent() is called on null events from Wimp_Poll.
** Null events are only enabled if either the engine state is not idle,
** or a timer is active.
**
** More than one state may be active, so more than one process may
** be activated consecutively within this function,
** until 50 centiseconds have elapsed, when it returns.
*/

int NullEvent(int code, WimpPollBlock *blk, IdBlock *idblk, void *h)
{

  int tt;
  clock_t t = clock();

  (void)(code);
  (void)(blk);
  (void)(idblk);
  (void)(h);
  _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
  tt = regs.r[0];

  if (timeoutactive)
  {
    if (tt >= nexttimeout)
    {
      dprintf(("Eng", "Timeout due\n"));
      StopTimeoutCount();
      if (!(state & DISCONNECT))
        DisconnectServer();
      return 0;
    }
  }

  if (reconactive)
  {
    if ((tt >= nextreconnect) && (!(state & TIMEOUT)))
    {
      dprintf(("Eng", "Reconnect due\n"));
      StopReconnectCount();
      if (online)
        StartProcess();
      return 0;
    }
  }

  if (retryactive)
  {
    if (tt >= nextretry)
    {
      dprintf(("Eng", "Retry due\n"));
      retryactive  = false;
      nextretry = 0;
      StartOffSMTP();
      return 0;
    }
  }

  /*
  ** Check engine state and farm out processes to each active bit.
  ** Each process needs to save its context on each pass,
  ** ready for the next pass.
  **
  ** Stop at any point if more than 0.5 seconds has passed.
  */

  if (state & PROCESSPOP)
  {
    if (((clock() - t) < 50) && (popprocessstate.context != idle))
      DoPOPProcess();
  }

  if (state & PROCESSSMTP)
  {
    if (((clock() - t) < 50) && (smtpprocessstate.context != idle))
      DoSMTPProcess();
  }

  if (state & RETRIEVEMSG)
  {
    if (((clock() - t) < 50) && (retrievestate.context != idle))
      DoRetrieve();
  }

  if (state & DOWNLOADHDR)
  {
    if (((clock() - t) < 50) && (downloadstate.context != idle))
      DoDownloadHeader();
    if (((clock() - t) < 50) && (parsehdrstate.context != idle))
      DoParseHeader();
  }

  else if (state & DOWNLOADMSG)
  {
    if (((clock() - t) < 50) && (downloadstate.context != idle))
      DoDownloadMessage();
  }

  if (state & (CREATE | REPLY))
  {
    if (((clock() - t) < 50) && (createstate.context != idle))
      DoCreate();
  }

  else if (state & SEND)
  {
    if (((clock() - t) < 50) && (sendstate.context != idle))
      DoSend();
  }

  if (state & (MARKDELETE | MARKREAD))
  {
    if (((clock() - t) < 50) && (markstate.context != idle))
      DoMark();
  }

  return 0;

}


/*
** TBEvents() handles Toolbox events. This is primarily for the use
** of the test UI running on the desktop.
*/

int TBEvents(int code, ToolboxEvent *event, IdBlock *idblk, void *h)
{

  (void)(event);
  (void)(idblk);
  (void)(h);
  switch (code)
  {
    case Quit_Quit :

      appquit = true;
      break;
  }

  return 1;
}


/*
** Next() calculates when the next timer will time out. There are
** potentially three timers running at the same time - POP3 timeout,
** POP3 reconnect, and SMTP retry.
*/

int Next(int a, int b, int c)
{

  int temp;

  if (a == 0)
    temp = b;
  else if (b == 0)
    temp = a;
  else
    temp = (a < b) ? a : b;

  if (temp == 0)
    return c;
  else if (c == 0)
    return temp;
  else
    return (temp < c) ? temp : c;

}


#ifdef DEBUGLIB
void DoOutputVersionToDebugLib(Version* instance)
{
  dprintf(("Eng", "\n"));
  dprintf(("Eng", "Name         : %s\n", instance->Name()));
  dprintf(("Eng", "VersionNumber: %d\n", instance->VersionNumber()));
  dprintf(("Eng", "MajorVersion : %s\n", instance->MajorVersion()));
  dprintf(("Eng", "MinorVersion : %s\n", instance->MinorVersion()));
  dprintf(("Eng", "Date         : %s\n", instance->Date()));
}


void OutputVersionsToDebugLib(void)
{
  DoOutputVersionToDebugLib(NCMailEngineVersion::Instance());
  DoOutputVersionToDebugLib(NCMailUIVersion::Instance());
  DoOutputVersionToDebugLib(NetLinkVersion::Instance());
  DoOutputVersionToDebugLib(MailboxVersion::Instance());
  DoOutputVersionToDebugLib(EmailLibVersion::Instance());
  DoOutputVersionToDebugLib(CommonVersion::Instance());
}
#endif


int main(int argc, char *argv[])
{

#ifdef MemCheck_MEMCHECK
  MemCheck_InitNoDebug();
  MemCheck_RedirectToFilename("<NCMail$Dir>.MemCheck");
  MemCheck_SetStoreMallocFunctions(1);
  MemCheck_InterceptSCLStringFunctions();
  MemCheck_RegisterMiscBlock(WimpRegistry::Instance(), sizeof(WimpRegistry));
  atexit(MemCheck_OutputBlocksInfo);
#endif

#ifdef HierProf_PROFILE
  HierProf_ProfileAllFunctions();
#endif

  NB_UNUSED(argc);
  NB_UNUSED(argv);
  if (!AppInit())
    exit(1);

#ifdef DEBUGLIB
  OutputVersionsToDebugLib();
#endif

  do
  {
    if (appquit)
      ShutDown();
    else
    {
      /* if engine is idle and countdown is in progress, call Poll_Idle */
      if ((state == IDLE) && (timeoutactive | reconactive | retryactive))
      {
        event_set_mask(0x1830);
        event_poll_idle(0, 0, Next(nexttimeout, nextreconnect, nextretry), 0);
      }
      else
      {
        /* if engine is idle, disable null events */
        event_set_mask((state == IDLE) ? 0x1831 : 0x1830);
        event_poll(0, 0, 0);
      }
    }
  }
  while (true);

}
