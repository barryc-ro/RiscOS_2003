/*
** Email Engine
** Event handlers
*/

#include "stdlib.h"
#include "time.h"
#include "string.h"
#include "swis.h"

#include "tboxlibs/wimplib.h"
#include "tboxlibs/event.h"
#include "tboxlibs/quit.h"
#include "tboxlibs/wimp.h"

#include "DebugLib/DebugLib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

#include "Email/Mailbox/WimpRegistry.h"

#include "NBLib/NBDefs.h"

#include "enginit.h"
#include "engstr.h"
#include "engevent.h"
#include "engprocess.h"
#include "engtypes.h"
#include "engparse.h"
#include "engdownld.h"
#include "enguiapi.h"
#include "enguser.h"
#include "engsend.h"
#include "engmanager.h"

int nexttimeout = 0, nextreconnect = 0;
bool timeoutactive = false, reconactive = false;

#ifdef ENGINE
  int tbevents[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, Toolbox_ObjectAutoCreated, Quit_Quit, 0};
#else
  int tbevents[] = {Quit_Quit, 0};
#endif

int Messages(WimpMessage *msg, void *h)
{

  NB_UNUSED(h);
  switch (msg->hdr.action_code)
  {

    case Wimp_MPreQuit :

      PreShutDown(msg);
      break;

    case Wimp_MQuit :

      ShutDown();
      break;

  }

  return 1;

}


int NullEvent(int code, WimpPollBlock *blk, IdBlock *idblk, void *h)
{

  int tt;
  clock_t t = clock();

  NB_UNUSED(code);
  NB_UNUSED(blk);
  NB_UNUSED(idblk);
  NB_UNUSED(h);
  _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
  tt = regs.r[0];

  if (timeoutactive)
  {
    if (tt >= nexttimeout)
    {
      dprintf(("Eng", "Timeout due\n"));
      StopTimeoutCount();
      PreDisconnect(false);
      return 1;
    }
  }
  
  if (reconactive)
  {
    if (tt >= nextreconnect)
    {
      dprintf(("Eng", "Reconnect due\n"));
      StopReconnectCount();
      if (online)
        StartProcess();
      return 1;
    }
  }
  
  /*
  ** Check engine state and farm out processes to each active bit.
  ** Each process needs to save its context on each pass,
  ** ready for the next pass.
  **
  ** Stop at any point if more than 0.5 seconds has passed.
  */
  
  if (state & PROCESSPOP)
  {
    if (((clock() - t) < 50) && (popprocessstate.context != idle))
      DoPOPProcess();
  }

  if (state & PROCESSSMTP)
  {
    if (((clock() - t) < 50) && (smtpprocessstate.context != idle))
      DoSMTPProcess();
  }

  if (state & DOWNLOADHDR)
  {
    if (((clock() - t) < 50) && (downloadstate.context != idle))
      DownloadHeader();
    if (((clock() - t) < 50) && (parsehdrstate.context != idle))
      DoParseHeader();
  }

  else if (state & DOWNLOADMSG)
  {
    if (((clock() - t) < 50) && (downloadstate.context != idle))
      DownloadMessage();
  }
  
  if (state & RETRIEVEMSG)
  {
    if (((clock() - t) < 50) && (retrievestate.context != idle))
      DoRetrieve();
  }

  if (state & (CREATE | REPLY))
  {
    if (((clock() - t) < 50) && (createstate.context != idle))
      DoCreateMessage();
  }

  else if (state & SEND)
  {
    if (((clock() - t) < 50) && (sendstate.context != idle))
      DoSend();
  }

  if (state & (MARKDELETE | MARKREAD))
  {
    if (((clock() - t) < 50) && (markstate.context != idle))
      DoMark();
  }

  if (state & CHANGEUSER)
  {
    if (((clock() - t) < 50) && (changestate.context != idle))
      DoUserChange();
  }

  return 0;

}


int TBEvents(int code, ToolboxEvent *event, IdBlock *idblk, void *h)
{

  NB_UNUSED(event);
  NB_UNUSED(idblk);
  NB_UNUSED(h);
  switch (code)
  {
    case Quit_Quit :

      appquit = true;
      break;
  }

  return 1;
}


int main(int argc, char *argv[])
{

#ifdef MemCheck_MEMCHECK
  MemCheck_InitNoDebug();
  MemCheck_RedirectToFilename("<NCMail$Dir>.MemCheck");
  MemCheck_SetStoreMallocFunctions(1);
  MemCheck_InterceptSCLStringFunctions();
  MemCheck_RegisterMiscBlock(WimpRegistry::Instance(), sizeof(WimpRegistry));
#endif

  NB_UNUSED(argc);
  NB_UNUSED(argv);
  if (!AppInit())
    exit(1);

  do
  {
    if (appquit)
      ShutDown();
    else
    {
      /* if engine is idle and countdown is in progress, call Poll_Idle */
      if ((state == IDLE) && (timeoutactive | reconactive))
      {
        event_set_mask(0x1830);
        event_poll_idle(0, 0, ((nexttimeout) ? nexttimeout : nextreconnect), 0);
      }
      else
      {
        /* if engine is idle, disable null events */
        event_set_mask((state == IDLE) ? 0x1831 : 0x1830);
        event_poll(0, 0, 0);
      }
    }
  }
  while (true);

}
