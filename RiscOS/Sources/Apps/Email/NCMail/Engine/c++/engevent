/*
** Email Engine
** Event handlers
*/

#include "stdlib.h"
#include "time.h"
#include "setjmp.h"
#include "signal.h"

#include "tboxlibs/wimplib.h"
#include "tboxlibs/event.h"
#include "tboxlibs/quit.h"
#include "tboxlibs/wimp.h"

#include "DebugLib/DebugLib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif
#ifdef HierProf_PROFILE
  #include "HierProf:HierProf.h"
#endif

#include "Email/Mailbox/WimpRegistry.h"

#include "enginit.h"
#include "engevent.h"
#include "engprocess.h"
#include "engtypes.h"
#include "engparse.h"
#include "engdownld.h"
#include "enguiapi.h"
#include "enguser.h"
#include "engsend.h"
#include "engmanager.h"
#include "engtimers.h"

#include "Version.h"
#include "../Build/UIVersion.h"
#include "Email/Common/Version.h"
#include "Email/EmailLib/Version.h"
#include "Email/Mailbox/Version.h"
#include "Email/NetLink/Version.h"

#ifndef CHECK_FOR_NCMALITE
#define oursignal 1

static jmp_buf env;

void SignalError(int num);
#endif

/*
** Messages() handles Wimp messages destined for the Engine
** (i.e. not those registered with WimpRegistry by Mailbox and UI).
*/

int Messages(WimpMessage *msg, void *h)
{
  (void)(h);
  switch (msg->hdr.action_code)
  {

    case Wimp_MPreLogOff:
    {
      PreShutDown(msg, PRELOGOFF);
      break;
    }
    case Wimp_MLogOff:
    {
      LogOff();
      break;
    }
    case Wimp_MPreQuit :

      PreShutDown(msg, PREQUIT);
      break;

    case Wimp_MQuit :

      ShutDown();
      break;

  }

  return 1;

}


/*
** NullEvent() is called on null events from Wimp_Poll.
** Null events are only enabled if either the engine state is not idle,
** or a timer is active.
**
** More than one state may be active, so more than one process may
** be activated consecutively within this function,
** until 50 centiseconds have elapsed, when it returns.
*/

int NullEvent(int code, WimpPollBlock *blk, IdBlock *idblk, void *h)
{

  clock_t t = clock();

  (void)(code);
  (void)(blk);
  (void)(idblk);
  (void)(h);

  if (CheckTimers())
    return 0;

  /*
  ** Check engine state and farm out processes to each active bit.
  ** Each process needs to save its context on each pass,
  ** ready for the next pass.
  **
  ** Stop at any point if more than 0.5 seconds has passed.
  */

  if (state & PROCESSPOP)
  {
    if (((clock() - t) < 50) && (popprocessstate.context != idle))
      DoPOPProcess();
  }

  if (state & PROCESSSMTP)
  {
    if (((clock() - t) < 50) && (smtpprocessstate.context != idle))
      DoSMTPProcess();
  }

  if (state & RETRIEVEMSG)
  {
    if (((clock() - t) < 50) && (retrievestate.context != idle))
      DoRetrieve();
  }

  if (state & DOWNLOADHDR)
  {
    if (((clock() - t) < 50) && (downloadstate.context != idle))
      DoDownloadHeader();
    if (((clock() - t) < 50) && (parsehdrstate.context != idle))
      DoParseHeader();
  }

  else if (state & DOWNLOADMSG)
  {
    if (((clock() - t) < 50) && (downloadstate.context != idle))
      DoDownloadMessage();
  }

  if (state & (CREATE | REPLY))
  {
    if (((clock() - t) < 50) && (createstate.context != idle))
      DoCreate();
  }

  else if (state & SEND)
  {
    if (((clock() - t) < 50) && (sendstate.context != idle))
      DoSend();
  }

  if (state & (MARKDELETE | MARKREAD))
  {
    if (((clock() - t) < 50) && (markstate.context != idle))
      DoMark();
  }

  return 0;

}


/*
** TBEvents() handles Toolbox events. This is primarily for the use
** of the test UI running on the desktop.
*/

int TBEvents(int code, ToolboxEvent *event, IdBlock *idblk, void *h)
{

  (void)(event);
  (void)(idblk);
  (void)(h);
  switch (code)
  {
    case Quit_Quit :

      appquit = true;
      break;
  }

  return 1;
}


#ifdef DEBUGLIB
void DoOutputVersionToDebugLib(Version* instance)
{
  dprintf(("Eng", "\n"));
  dprintf(("Eng", "Name         : %s\n", instance->Name()));
  dprintf(("Eng", "VersionNumber: %d\n", instance->VersionNumber()));
  dprintf(("Eng", "MajorVersion : %s\n", instance->MajorVersion()));
  dprintf(("Eng", "MinorVersion : %s\n", instance->MinorVersion()));
  dprintf(("Eng", "Date         : %s\n", instance->Date()));
}


void OutputVersionsToDebugLib(void)
{
  DoOutputVersionToDebugLib(NCMailEngineVersion::Instance());
  DoOutputVersionToDebugLib(NCMailUIVersion::Instance());
  DoOutputVersionToDebugLib(NetLinkVersion::Instance());
  DoOutputVersionToDebugLib(MailboxVersion::Instance());
  DoOutputVersionToDebugLib(EmailLibVersion::Instance());
  DoOutputVersionToDebugLib(CommonVersion::Instance());
}
#endif


int main(int argc, char *argv[])
{

#ifdef MemCheck_MEMCHECK
#ifdef DEBUG
  MemCheck_Init();
#else
  MemCheck_InitNoDebug();
#endif
  MemCheck_RedirectToFilename("<NCMail$Dir>.MemCheck");
  MemCheck_SetStoreMallocFunctions(1);
  MemCheck_InterceptSCLStringFunctions();
  MemCheck_RegisterMiscBlock(WimpRegistry::Instance(), sizeof(WimpRegistry));
  atexit(MemCheck_OutputBlocksInfo);
  MemCheck_SetQuitting(1, 1);
  MemCheck_SetAccessQuitting(1, 1);
#endif

#ifdef HierProf_PROFILE
  HierProf_ProfileAllFunctions();
  HierProf_OutputToFilenamef("<NCMail$Dir>.HierProf");
#endif

  (void)(argc);
  (void)(argv);

#ifndef CHECK_FOR_NCMALITE
  signal(SIGOSERROR, SignalError);
  signal(SIGILL, SignalError);
  signal(SIGSEGV, SignalError);
  signal(SIGSTAK, SignalError);
  signal(SIGFPE, SignalError);
#endif

  if (!AppInit())
    exit(1);

#ifdef DEBUGLIB
  OutputVersionsToDebugLib();
#endif

#ifndef CHECK_FOR_NCMALITE
  if (setjmp(env) == oursignal)
    appquit = true;
#endif

  do
  {
    if (appquit)
      ShutDown();
    else
    {
      /* if engine is idle and countdown is in progress, call PollIdle */
      if ((state == IDLE) && (TimerActive()))
      {
        event_set_mask(0x1830);
        event_poll_idle(0, 0, NextTime(), 0);
      }
      else
      {
        /* if engine is idle, disable null events */
        event_set_mask((state == IDLE) ? 0x1831 : 0x1830);
        event_poll(0, 0, 0);
      }
    }
  }
  while (true);

}

#ifndef CHECK_FOR_NCMALITE
#pragma no_check_stack

void SignalError(int num)
{

  (void)(num);
  dprintf(("Eng", "Getting signal error\n"));
  longjmp(env, oursignal);

  exit(EXIT_FAILURE);

}
#endif
