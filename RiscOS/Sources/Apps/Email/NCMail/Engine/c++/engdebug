/*
** Tracing routines
*/

#include "kernel.h"
#include "swis.h"
#include "string.h"
#include "stdarg.h"
#include "stdio.h"

#include "engdebug.h"
#include "enginit.h"

static int  tracetype, areanumber;
static char *tracebuffer;
static char *tracetop;
static char filename[] = "<NCMail$Dir>.TraceFile";
static char areaname[] = "EngTrace";
static char varname[] = "NCMail$TraceType";

#define PAGESIZE 0x1000

void Vigil46102(int r0, int r1, int r2, int r3, int r4, int r5, int r6, int r7, int r8, int r9);

void TraceInit(void)
{
  int  done;
  char bk[4];
  
  /*
  ** Examine NCMail$TraceType variable.
  ** If variable doesn't exist, tracetype = 0 (i.e. no tracing).
  ** Otherwise variable contains number of trace type.
  ** Type 1 = file tracing.
  ** Type 2 = dynamic area tracing.
  ** Type 3  = Vigil tracing.
  */
  
  regs.r[0] = (int) varname;
  regs.r[1] = (int) bk;
  regs.r[2] = 4;
  regs.r[3] = 0;
  regs.r[4] = 3;
  _kernel_swi(OS_ReadVarVal,&regs,&regs);
  tracetype = (regs.r[2] == 0) ? 0 : *(bk) - 48;
  
  switch (tracetype)
  {
    case 0 : break;
    
    case 1 : /* file tracing */

             regs.r[0] = 11;
             regs.r[1] = (int) filename;
             regs.r[2] = 0xfff;
             regs.r[4] = regs.r[5] = 0;
             _kernel_swi(OS_File,&regs,&regs);
             break;
      
    case 2 : regs.r[1] = -1;
             done = 0;
             while (!done)
             {
               regs.r[0] = 3;
               _kernel_swi(OS_DynamicArea,&regs,&regs);
               if (regs.r[1] != -1)
               {
                 regs.r[0] = 2;
                 _kernel_swi(OS_DynamicArea,&regs,&regs);
                 if (!strcmp((char *)regs.r[8], areaname))
                 {
                   regs.r[0] = 1;
                   _kernel_swi(OS_DynamicArea,&regs,&regs);
                   done = 1;
                 }
               }
               else
                 break;
             }
  
             regs.r[0]=0;
             regs.r[1]=-1;
             regs.r[2]=PAGESIZE;
             regs.r[3]=-1;
             regs.r[4]=0;
             regs.r[5]=-1;
             regs.r[6]=0;
             regs.r[7]=0;
             regs.r[8]=(int) areaname;
             _kernel_swi(OS_DynamicArea,&regs,&regs);
  
             areanumber = regs.r[1];
             tracebuffer = (char *) regs.r[3];
             * (int *) tracebuffer = (int)(tracebuffer + 4);
             tracetop = tracebuffer + PAGESIZE;
             break;
    
    case 3 : /* Vigil tracing */
             break;
  }
  
  if (tracetype)
    EngTrace("Initiating trace\n");

}

void EngTrace(char *s, ...)
{
  va_list          va;
  char             buffer[1024];
  int              len;
  int              *ptrstore = (int *) tracebuffer;
  char             *traceptr = (char *) *ptrstore;
  _kernel_swi_regs r;

  if (tracetype)
  {
    /* Create message */
    va_start(va, s);
    vsprintf(buffer, s, va);
    va_end(va);
  
    switch (tracetype)
    {
    
      case 0 :
        break;
    
      case 1 :

        r.r[0] = 0xc3;
        r.r[1] = (int) filename;
        _kernel_swi(OS_Find,&r,&r);
        r.r[1] = r.r[0];
        r.r[0] = 2;
        _kernel_swi(OS_Args,&r,&r);
        r.r[0] = 1;
        _kernel_swi(OS_Args,&r,&r);

        r.r[0] = 2;
        r.r[2] = (int) buffer;
        r.r[3] = strlen(buffer);
        _kernel_swi(OS_GBPB,&r,&r);
        r.r[0] = 0;
        _kernel_swi(OS_Find,&r,&r);
        break;

      case 2 :

        len = strlen(buffer);
        if (traceptr + len >= tracetop)
        {
          r.r[0] = areanumber;
          r.r[1] = PAGESIZE;
          _kernel_swi(OS_ChangeDynamicArea,&r,&r);
          tracetop += PAGESIZE;
        }
        strcpy(traceptr, buffer);
        traceptr += len;
        *ptrstore = (int) traceptr;
        break;
    
      case 3 :

        r.r[0] = (int) buffer;
        _kernel_swi(Vigil_Trace,&r,&r);
        break;
    }         
  }
}

void VigilRegister(int task)
{
  
  _kernel_swi_regs r;

  r.r[0] = task;

  _kernel_swi(Vigil_Register,&r,&r);
  
}


void VigilShow(int r)

{
  
  Vigil46102(r,0,0,0,0,0,0,0,0,0);
  
}


void VigilDisplayRegisters(int r0, int r1, int r2, int r3, int r4, int r5, int r6, int r7, int r8, int r9)

{

  _kernel_swi_regs regs;

  regs.r[0]=r0;
  regs.r[1]=r1;
  regs.r[2]=r2;
  regs.r[3]=r3;
  regs.r[4]=r4;
  regs.r[5]=r5;
  regs.r[6]=r6;
  regs.r[7]=r7;
  regs.r[8]=r8;
  regs.r[9]=r9;

  _kernel_swi(Vigil_DisplayRegisters,&regs,&regs);

}

void VigilCompareRegisters(int r0, int r1, int r2, int r3, int r4, int r5, int r6, int r7, int r8, int r9)

{

  _kernel_swi_regs r;

  r.r[0]=r0;
  r.r[1]=r1;
  r.r[2]=r2;
  r.r[3]=r3;
  r.r[4]=r4;
  r.r[5]=r5;
  r.r[6]=r6;
  r.r[7]=r7;
  r.r[8]=r8;
  r.r[9]=r9;

  _kernel_swi(Vigil_CompareRegisters,&r,&r);

}

void VigilDisplayMemory(char *start)

{

  _kernel_swi_regs r;

  r.r[0]=(int) start;

  _kernel_swi(Vigil_DisplayMemory,&r,&r);

}

void Vigil46102(int r0, int r1, int r2, int r3, int r4, int r5, int r6, int r7, int r8, int r9)

{

  _kernel_swi_regs r;

  r.r[0]=r0;
  r.r[1]=r1;
  r.r[2]=r2;
  r.r[3]=r3;
  r.r[4]=r4;
  r.r[5]=r5;
  r.r[6]=r6;
  r.r[7]=r7;
  r.r[8]=r8;
  r.r[9]=r9;

  _kernel_swi(Vigil_DisplayRegisters,&r,&r);

}

void Vigil46103(int r0, int r1, int r2, int r3, int r4, int r5, int r6, int r7, int r8, int r9)

{

  _kernel_swi_regs r;

  r.r[0]=r0;
  r.r[1]=r1;
  r.r[2]=r2;
  r.r[3]=r3;
  r.r[4]=r4;
  r.r[5]=r5;
  r.r[6]=r6;
  r.r[7]=r7;
  r.r[8]=r8;
  r.r[9]=r9;

  _kernel_swi(Vigil_CompareRegisters,&r,&r);

}

void Vigil46104(char *start)

{

  _kernel_swi_regs r;

  r.r[0]=(int) start;

  _kernel_swi(Vigil_DisplayMemory,&r,&r);

}
