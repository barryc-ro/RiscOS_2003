/*
** Email Client
** Download Mail
**
** This file contains routines to download headers for parsing,
** download messages when doing a mailbox process,
** and retrieve single messages when requested by the user to read.
*/

#include "Email/Common/list.h"
#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "DebugLib/DebugLib.h"
#include "NBLib/NBLib.h"

#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

#include "Email/Mailbox/Account.h"
#include "Email/Mailbox/POP3/POP3Account.h"
#include "Email/Mailbox/Mailbox.h"
#include "Email/Mailbox/MBoxCB.h"
#include "Email/Mailbox/Message.h"
#include "Email/Mailbox/MBoxOpCB/getsize.h"
#include "Email/Mailbox/MBoxOpCB/getmsg.h"
#include "Email/Mailbox/MBoxOpCB/gethdrs.h"

#include "engtypes.h"
#include "engmanager.h"
#include "enguiapi.h"
#include "engprocess.h"
#include "engcbf.h"
#include "engparse.h"
#include "enginit.h"
#include "enguser.h"
#include "engtimers.h"
#include "engconnect.h"

extern "C"
{
  #include "../Build/NCMailUI.h"
}

static bool secondtimeround, newmsgs;
static uint32 skipped;

void StartMessageDownload(void)
{

  downloadstate.msg = popmbox->list;
  downloadstate.context = readytodownload;
  downloadstate.ret.code = ENG_COMPLETED;

  state |= DOWNLOADMSG;

}


/*
** FinishHeaders() is called when all the headers have been
** downloaded and parsed. The UI is given the go-ahead to
** display the Inbox.
** If the Email client is active and a disconnect is not pending,
** downloading of messages is kicked off.
*/

void FinishHeaders(void)
{

  state &= ~DOWNLOADHDR;
  popmbox->flags |= MBOXPROCESSED;

  if (firstprocess)
  {
    popstat->flags = 0;
    popstat->tag = processcomplete;
    ncmui_connection_status(popstat);
    firstprocess = false;
  }

  /*
  ** If the Inbox has changed in any way,
  ** tell the UI it can now display the Inbox,
  ** but message list may be incomplete.
  */
  if ((newmsgs) || (popmbox->flags & CHANGED))
  {
    popprocessstate.ret.code = (popmbox->flags & MBOXINCOMPLETE) ? ENG_MBOXINCOMPLETE : ENG_COMPLETED;
    dprintf(("Eng", "Notifying UI that it can display Inbox\n"));
    (*callbacklist.promptfunc)(&popprocessstate.ret, popmbox->list, online, callbacklist.prompthandle);
  }

  if (disconnectpending)
    DisconnectPending();

  else if (emailactive)
  {
    /*
    ** If email client is active, we can now get on with
    ** downloading messages in the background, but only if
    ** newmsgs flag is set (indicating new mail),
    ** or a previous download was interrupted.
    **
    ** Otherwise provided we're not also retrieving a message
    ** at the same time, we can mark POP as inactive.
    */

    if ((newmsgs) || (popmbox->flags & DOWNLOADINCOMPLETE))
    {
      skipped = 0;
      secondtimeround = false;
      StartMessageDownload();
    }
    else if (!(state & RETRIEVEMSG))
    {
      DeactivatePOP();
      StartReconnectCount();
    }
  }

  else
  {
    /*
    ** If email not active, disconnect from mail server
    ** in case user drops line while outside email client.
    */
    DeactivatePOP();
    StartReconnectCount();
    DisconnectServer();
    NotifyBrowser(newmail);
  }

}


/*
** DownloadFailure() is called by either DoDownloadHeader or
** DoDownloadMessage if a download has failed. First time round,
** the message's ERROR flag is set. Second time round this is
** detected and the download is abandoned for this message.
*/

void DownloadFailure(bool headers)
{

  MessageDescriptor *msg = downloadstate.msg;

  SetFilename(msg->ID, headers);
  UnlockFile(msgfilename);
  remove(msgfilename);
  if (msg->flags & ERROR)
  {
    /*
    ** Must be second time around so we've obviously
    ** already failed once.
    ** In that case ignore this message and move on to next.
    */
    if (headers)
    {
      popmbox->flags |= MBOXINCOMPLETE;
      /* move start of temp message list to next message */
      transmbox->list = msg->next;
    }

    downloadstate.msg = msg->next;
    dprintf(("Eng", "Second attempt at message %d failed\n",msg->ID));
  }
  else
  {
    /* set ERROR flag so that another attempt will be made */
    msg->flags |= ERROR;
  }

  downloadstate.context = readytodownload;
}


/*
** DoDownloadHeader downloads message headers ready for parsing
** under control of the DOWNLOADHDR state. The function is entered
** during null events under one of the following contexts:
**   startdownload
**   readytodownload
**   downloadfailure
**   downloaddone
**
** The process cycles through the message list until all messages
** have been done.
*/

void DoDownloadHeader(void)
{

  ELib_rcode code;
  MessageDescriptor *msg = downloadstate.msg;

  switch (downloadstate.context)
  {

    case startdownload :

      newmsgs = false;
      downloadstate.context = readytodownload;
      break;

    case readytodownload :

      /*
      ** Ready to download the next header.
      ** If the message pointer is zero it's the end of the list.
      ** If disconnectpending is set, download is interrupted.
      */

      dprintf(("Eng", "download context = readytodownload hdr %d\n",(msg) ? msg->ID : 0));
      if ((!msg) || (disconnectpending))
      {
        /* all headers now downloaded */

        if (disconnectpending)
        {
          dprintf(("Eng", "Picking up disconnectpending while downloading headers\n"));
          popmbox->flags |= MBOXINCOMPLETE;
        }
        if (parsehdrstate.context != idle)
          hdrsdownloaded = true;
        else
          FinishHeaders();

      }

      else
      {
        if (msg->flags & NEWLYCREATED)
        {
          /* it's a new message so get the header */
          newmsgs = true;
          SetFilename(msg->ID, true);
          downloadstate.hdrsobj = new MBoxOpCB_gethdrs_file((MBoxCBHandlerFn) MBoxCallback, msgfilename, code, 0);
          downloadstate.context = idle;

          code = msg->mboxobj->GetHeaders(downloadstate.hdrsobj);
          if (code < 0)
          {
            /* an error has occurred so we'll skip this message */
            dprintf(("Eng", "***ERROR*** Error getting headers, rc=%d\n",code));
            downloadstate.context = downloadfailure;
            downloadstate.ret.code = (code == ELIB_EMALLOCFAILED) ? ENG_NOMEMORY : ENG_GETHDRFAILED;
          }
        }
        else
        {
          /* we already have a descriptor so no need to parse */
          dprintf(("Eng", "We already have a descriptor for this message\n"));
          downloadstate.msg = msg->next;
          transmbox->list = msg->next;
          downloadstate.context = readytodownload;
        }
      }

      break;

    case downloadfailure :

      /*
      ** Header download or parse has failed.
      ** If this is the second failure, DownloadFailure() will
      ** cause it to be skipped, otherwise we try to get it again.
      */

      dprintf(("Eng", "download context = downloadfailure msg %d\n",msg->ID));
      RemoveObj((MBoxOpCB**) &downloadstate.hdrsobj);
      DownloadFailure(true);

      break;

    case downloaddone :

      /*
      ** Download successfully completed for this header.
      ** Delete the callback object and send the header for parsing.
      ** Meanwhile start fetching the next header.
      */

      dprintf(("Eng", "download context = downloaddone hdr %d\n",msg->ID));
      RemoveObj((MBoxOpCB**) &downloadstate.hdrsobj);
      if (parsehdrstate.context == idle)
      {
        /* DoParseHeader() will now pick up this message */
        parsehdrstate.msg = downloadstate.msg;
        parsehdrstate.context = readytoparse;
        downloadstate.msg = msg->next;
        transmbox->list = msg->next;
        downloadstate.context = readytodownload;
      }
      else
      {
        /*
        ** Not yet ready to parse - still parsing previous message.
        ** All we need do here is wait in downloaddone context.
        ** Eventually parsehdrstate.context will become idle.
        */
      }

      break;
  }
}


void DownloadCleanup(void)
{

  state &= ~DOWNLOADMSG;
  if (!(state & RETRIEVEMSG))
  {
    /* only reset countdown timers if a retrieve is not
       happening at the same time */
    DeactivatePOP();
    StartReconnectCount();
  }

  downloadstate.ret.code = ENG_COMPLETED;
  (*callbacklist.promptfunc)(&downloadstate.ret, popmbox->list, online, callbacklist.prompthandle);

}


/*
** DoDownloadMessage() downloads messages into CacheFS under the
** control of the DOWNLOADMSG state.
** It checks the available free memory (which is adjusted so that
** there is always at least 2Mb of unused space) and only downloads
** messages that will fit into that space, unless this is not the
** first processing of the mailbox (see below).
** 
** The download makes two passes. On the first pass it only
** downloads messages up to the configured threshhold size,
** and if there is still memory remaining it makes a second pass
** to see if any larger messages can be downloaded.
**
** If this is the second or subsequent processing of the mailbox,
** any new messages are given precedence over old ones, so if
** necessary old messages are cleared out of memory to make way
** for the new ones.
**
** The function is entered during null events under one of the
** following contexts:
**   readytodownload
**   downloadfailure
*/


void DoDownloadMessage(void)
{

  ELib_rcode code;
  MessageDescriptor *msg = downloadstate.msg;
  int32 freemem = FreeMem();

  switch (downloadstate.context)
  {

    case readytodownload :

      dprintf(("Eng", "context = readytodownload\n"));
      if ((!msg) || ((freemem <= 0) && (firstdownload)))
      {
        /*
        ** Either we're at the end of the list, or it's the
        ** first download and we've run out of memory.
        ** Either way, it's time to stop.
        */

        if ((skipped) && (!secondtimeround))
        {
          /*
          ** We've only made one pass so far, and the skipped
          ** flag is set, meaning there are larger messages
          ** waiting to be downloaded.
          ** So let's go and see if we can get the bastards.
          */

          dprintf(("Eng", "Starting to get messages skipped first time round, total remaining %dK\n",skipped/1024));
          /* set the flag so we know this is the second pass */
          secondtimeround = true;

          if (skipped > popmbox->redispsize)
          {
            dprintf(("Eng", "skipped greater than configured size, notify UI\n"));
            /* tell the UI it can display the Inbox again */
            (*callbacklist.promptfunc)(&downloadstate.ret, popmbox->list, online, callbacklist.prompthandle);
          }

          StartMessageDownload();
          return;
        }

        /* All messages now downloaded */
        dprintf(("Eng", "All messages downloaded\n"));
        firstdownload = false;

        /* unset NEW and REMOVED flags for all messages in list */
        msg = popmbox->list;
        popmbox->flags &= ~DOWNLOADINCOMPLETE;
        while (msg)
        {
          msg->flags &= ~(NEW + REMOVED);
          msg = msg->next;
        }

        DownloadCleanup();

      }

      else if (disconnectpending)
      {
        /* A disconnect request has been received while downloading */
        dprintf(("Eng", "Picking up disconnectpending while downloading\n"));

        DownloadCleanup();
        DisconnectPending();
      }

      else if (!emailactive)
      {
        /* User has left email client while downloading */
        dprintf(("Eng", "Stopping downloading on exit from NCMail\n"));

        DownloadCleanup();
      }

      else if (msg->flags & (DOWNLOADED | DOWNLOADING | REMOVED))
      {
        /*
        ** This message is either downloaded or downloading,
        ** or it has already been removed during this process
        ** to make way for another, so we don't want to get it again.
        */
        dprintf(("Eng", "Message %d %s\n",msg->ID,(msg->flags & REMOVED) ? "has previously been removed" : "is downloading or already downloaded"));
        downloadstate.msg = msg->next;
        downloadstate.context = readytodownload;
      }

      else
      {
        /* Phew! we can actually try to download this message */
        code = msg->mboxobj->GetLength(downloadstate.size);
        if (code < 0)
        {
          /* some kind of error in getting size */
          dprintf(("Eng", "***ERROR*** Error returned from GetSize method\n"));
          downloadstate.context = downloadfailure;
        }

        else if (!(msg->flags & NEW))
        {
          /* Not a new message, so ignore it */
          dprintf(("Eng", "Message %d is not new\n",msg->ID));
          downloadstate.msg = msg->next;
          downloadstate.context = readytodownload;
        }

        else
        {
          bool ok = true;

          dprintf(("Eng", "Free memory is %dK\n",freemem/1024));
          dprintf(("Eng", "Message size=%d\n",downloadstate.size));
          if ((downloadstate.size > popmbox->maxsize) && (!secondtimeround))
          {
            /*
            ** It's the first pass and this message is larger
            ** than the threshold size. So, tough.
            */
            dprintf(("Eng", "Skipping message %d - too bleedin' big\n",msg->ID));
            /* set flag so we know some have been skipped */
            skipped += downloadstate.size;
            ok = false;
          }

          else if (freemem < (int32) downloadstate.size)
          {
            /*
            ** Free memory is less than message size,
            ** so try to clear memory if possible
            */
            ok = false;
            if ((msg->flags & NEW) && (!firstdownload))
            {
              if (ClearMemory(downloadstate.size, true) != ENG_NOMEMORY)
                ok = true;
            }
          }

          if (ok)
          {
            /* NOW we can download it! */
            msg->flags |= DOWNLOADING;
            SetFilename(msg->ID, false);
            downloadstate.context = idle;

            downloadstate.msgobj = new MBoxOpCB_getmsg_file((MBoxCBHandlerFn) MBoxCallback, msgfilename, code, (void *) DOWNLOADMSG);
            code = msg->mboxobj->GetMessage(downloadstate.msgobj);
            if (code < 0)
            {
              /* an error of some sort - skip this message */
              downloadstate.context = downloadfailure;
              downloadstate.ret.code = (eng_rcode) code;
            }
          }

          else
          {
            if (secondtimeround)
            {
              dprintf(("Eng", "Not enough space for message %d\n",msg->ID));
              msg->flags &= ~NEW;
            }
            downloadstate.msg = msg->next;
            downloadstate.context = readytodownload;
          }
        }
      }

      break;

    case downloadfailure :

      dprintf(("Eng", "context = downloadfailure for msg %d\n",msg->ID));
      /* message download or parse has failed */
      msg->flags &= ~(DOWNLOADED + DOWNLOADING);
      DownloadFailure(false);

      break;

  }
}


/*
** DoRetrieve() retrieves a single message when the user requests
** to read a message that is on the server, under the control of the
** RETRIEVEMSG state.
** The function is entered during null events under one of the
** following contexts:
**   reqconnect
**   readytoconnect
**   connectfailure
**   readytoretrieve
**   retrievefailure
**   downloadpending
**   readytoparse
**   parsing
**   parsedone
**   readytowrite
**   writing
**   writedone
**   writefailure
**   finished
*/

void DoRetrieve(void)
{

  ELib_rcode rc;
  MessageDescriptor *msg = retrievestate.msg;

  switch (retrievestate.context)
  {

    case reqconnect :

      dprintf(("Eng", "Retrieve context = reqconnect\n"));
      /* confirmation of connection required to get message */
      retrievestate.context = idle;
      retrievestate.ret.code = (state & FORWARD) ? ENG_CONFIRMFORWARD : ENG_CONFIRMCONNECT;
      (*callbacklist.statusfunc)(&retrievestate.ret, callbacklist.statushandle, ConfirmConnect);
      break;

    case readytoconnect :

      state |= PROCESSPOP;
      popprocessstate.context = readytoconnect;
      retrievestate.context = idle;

      break;

    case connectfailure :

      /* POP has already been deactivated in DoPOPProcess() */
      state &= ~RETRIEVEMSG;
      (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, 0);
      break;

    case readytoretrieve :
    {
      uint32 size;

      dprintf(("Eng", "Retrieve context = readytoretrieve\n"));
      rc = msg->mboxobj->GetLength(size);
      dprintf(("Eng", "Message size=%d\n",size));
      if (rc < 0)
      {
        /* some kind of error in gettingsize */
        dprintf(("Eng", "***ERROR*** Error returned from GetSize method\n"));
        retrievestate.context = retrievefailure;
        retrievestate.ret.rc = rc;
      }

      else
      {
        int32 freemem = FreeMem();
        if (freemem < (int32) size)
        {
          if (ClearMemory(size, false) == ENG_NOMEMORY)
          {
            dprintf(("Eng", "Can't retrieve message - no space left\n"));
            retrievestate.context = retrievefailure;
            retrievestate.ret.rc = ELIB_EMALLOCFAILED;
            return;
          }
        }
        msg->flags |= DOWNLOADING;
        SetFilename(msg->ID, false);
        retrievestate.context = idle;

        retrievestate.msgobj = new MBoxOpCB_getmsg_file((MBoxCBHandlerFn) MBoxCallback, msgfilename, rc, (void *) RETRIEVEMSG);
        rc = msg->mboxobj->GetMessage(retrievestate.msgobj);
        if (rc < 0)
        {
          /* an error of some sort - skip this message */
          retrievestate.context = retrievefailure;
          retrievestate.ret.rc = rc;
        }
      }

      break;
    }
    case retrievefailure :

      dprintf(("Eng", "Retrieve context = retrievefailure\n"));
      state &= ~RETRIEVEMSG;
      msg->flags &= ~(DOWNLOADED + DOWNLOADING);
      if (!(state & DOWNLOADMSG))
        DeactivatePOP();
      switch (retrievestate.ret.rc)
      {
        case ELIB_EMALLOCFAILED :
          retrievestate.ret.code = ENG_NOMEMORY;
          break;

        case ELIB_ECONREFUSED :
        case ELIB_ECONFAILED :

          retrievestate.ret.code = ENG_POPCONNECTFAIL;
          break;

        case ELIB_EINVALIDUSERNAME :
        case ELIB_EINVALIDPASSWORD :

          retrievestate.ret.code = ENG_AUTHORISATIONFAILED;
          break;

        default :
          retrievestate.ret.code = ENG_GETMSGFAILED;
      }

      (*callbacklist.getmsgfunc)(&retrievestate.ret, msg, callbacklist.getmsghandle);
      break;

    case downloadpending :

      if (msg->flags & DOWNLOADED)
        retrievestate.context = readytoparse;

      break;

    case readytoparse :

      dprintf(("Eng", "Retrieve context = readytoparse\n"));
      StartParseMessage();

      break;

    case parsing :

      dprintf(("Eng", "Retrieve context = parsing\n"));
      ParseMessageSlice();
      break;

    case parsedone :

      dprintf(("Eng", "Retrieve context = parsedone\n"));
      if (state & FORWARD)
      {
        destroy_context(&retrievestate.elibcontext);
        msg->elibobj = retrievestate.rfc;
        dprintf(("Eng", "Setting message elibobj in DoRetrieve to 0x%x\n",retrievestate.rfc));
        retrievestate.context = finished;
      }

      else
      {
        retrievestate.retrievelist = new RetrieveList();
        DecodeMessage(retrievestate.msg, retrievestate.rfc);
        destroy_context(&retrievestate.elibcontext);

        if (retrievestate.ret.rc < 0)
          retrievestate.context = retrievefailure;

        else
        {
          /* get first message descriptor in list */
          retrievestate.retrievelist->Start();
          retrievestate.current = (MessageDescriptor *) retrievestate.retrievelist->Current();
          /* get first entity in this message */
          retrievestate.ent = retrievestate.current->entity_list;
          retrievestate.context = readytowrite;
        }
      }

      break;

    case readytowrite :

      dprintf(("Eng", "Retrieve context = readytowrite\n"));
      if (retrievestate.ent->flags & ENTITY_RFC822)
      {
        dprintf(("Eng", "Not writing this entity - it's a message\n"));
        retrievestate.context = writedone;
      }
      else
      {
        dprintf(("Eng", "Writing out entity %d, msg %d\n",retrievestate.ent->ID,retrievestate.current->ID));
        StartWrite();
      }

      break;

    case writing :

      dprintf(("Eng", "Retrieve context = writing\n"));
      WriteOutSlice();

      break;

    case writedone :

      dprintf(("Eng", "Retrieve context = writedone\n"));
      if (!(retrievestate.ent->flags & ENTITY_RFC822))
      {
        fclose(retrievestate.file);
        LockFile(retrievestate.ent->data.fname);
      }

      if (retrievestate.ent->next)
      {
        retrievestate.ent = retrievestate.ent->next;
        retrievestate.context = readytowrite;
      }

      else
      {
        /* get next message on list */
        retrievestate.retrievelist->Next();
        if (retrievestate.retrievelist->Nul())
          retrievestate.context = finished;
        else
        {
          retrievestate.current = (MessageDescriptor *) retrievestate.retrievelist->Current();
          /* get first entity in this message */
          retrievestate.ent = retrievestate.current->entity_list;
          retrievestate.context = readytowrite;
        }
      }

      break;

    case writefailure :

      dprintf(("Eng", "Retrieve context = writefailure\n"));
      UnlockFile(retrievestate.ent->data.fname);
      free(retrievestate.ent->data.fname);
      retrievestate.ent->data.fname = 0;
      msg->flags |= ERROR;
      retrievestate.context = writedone;

      break;

    case finished :

      dprintf(("Eng", "Retrieve context = finished\n"));
      /* finished downloading message,
         so we can now return it to the UI */
      if (retrievestate.retrievelist)
      {
        delete retrievestate.retrievelist;
        retrievestate.retrievelist = 0;
      }
      state &= ~RETRIEVEMSG;
      if (!(state & (DOWNLOADMSG | PROCESSPOP)))
        DeactivatePOP();
      msg->flags &= ~DOWNLOADING;
      msg->flags |= DOWNLOADED;
      retrievestate.ret.code = ENG_COMPLETED;
      (*callbacklist.getmsgfunc)(&retrievestate.ret, msg, callbacklist.getmsghandle);

      if (disconnectpending)
      {
        dprintf(("Eng", "Picking up disconnectpending during retrieve\n"));
        DisconnectPending();
      }

      break;
  }

}
