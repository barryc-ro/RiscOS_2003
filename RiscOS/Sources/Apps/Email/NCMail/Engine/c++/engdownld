/*
** Email Client
** Download Mail
*/

#include "Email/Common/list.h"
#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "DebugLib/DebugLib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

#include "Email/Mailbox/Account.h"
#include "Email/Mailbox/POP3/POP3Accoun.h"
#include "Email/Mailbox/Mailbox.h"
#include "Email/Mailbox/MBoxCB.h"
#include "Email/Mailbox/Message.h"
#include "Email/Mailbox/MBoxOpCB/getsize.h"
#include "Email/Mailbox/MBoxOpCB/getmsg.h"
#include "Email/Mailbox/MBoxOpCB/gethdrs.h"

#include "engtypes.h"
#include "engmanager.h"
#include "enguiapi.h"
#include "engprocess.h"
#include "engcbf.h"
#include "engfile.h"
#include "engparse.h"

void FinishHeaders(void)
{
  
  MessageDescriptor *msg;

  state &= ~DOWNLOADHDR;
  SortMailbox();
  ourmboxin->flags |= MBOXPROCESSED;
  msg = ourmboxin->list;

  /*
  ** Tell the UI it can now display the Inbox,
  ** but if rc is not ENG_COMPLETED, UI will know that
  ** message list may be incomplete.
  */
  (*callbacklist.promptfunc)((ourmboxin->flags & MBOXINCOMPLETE) ? ENG_MBOXINCOMPLETE : ENG_COMPLETED, ourmboxin->list, online, callbacklist.prompthandle);

  dprintf(("Eng", "Notifying UI that it can display Inbox\n"));

#ifdef MemCheck_MEMCHECK
  MemCheck_OutputBlocksInfo();
#endif

  if (disconnectpending)
  {
    PreDisconnect();
    disconnectpending = false;
  }

  else if (emailactive)
  {
    /* we can now get on with downloading messages in the background */
    downloadstate.msg = ourmboxin->list;
    downloadstate.context = readytodownload;
    downloadstate.rc = ENG_COMPLETED;
    state |= DOWNLOADMSG;
  }
  
  /* If email is not active, should we disconnect from POP? */

}


void DownloadFailure(MessageDescriptor *msg, uint32 size, bool headers)
{

  char *file = SetFilename(msg->ID, headers);
  UnlockFile(file);
  remove(file);
  if (msg->flags & ERROR)
  {
    /*
    ** Must be second time around so we've obviously
    ** already failed once.
    ** In that case ignore this message and move on to next.
    */
    if (headers)
      ourmboxin->flags |= MBOXINCOMPLETE;
    downloadstate.msg = msg->next;
  }
  else
  {
    if (downloadstate.rc == ENG_NOSPACEFORMSG)
    {
      /*
      ** There has been a malloc failure so try to free memory
      ** by removing old message files.
      */

      if (!ClearMemory(size))
      {
        /* attempt to clear memory has failed -
           what do we do now? */
      }
    }

    /* try to download once more*/
    msg->flags |= ERROR;
    downloadstate.context = readytodownload;
  }
}


void DLReady(bool b)
{
  downloadstate.context = readytodownload;
}


void DownloadHeader(void)
{

  ELib_rcode code;
  char *file;
  MessageDescriptor *msg = downloadstate.msg;

  switch (downloadstate.context)
  {

    case readytodownload :

      dprintf(("Eng", "download context = readytodownload msg %d\n",msg->ID));
      if(!msg)
      {
        /* all headers now downloaded */
        hdrsdownloaded = true;
      }

      else if (disconnectpending)
      {
        /* a disconnect is pending */
        dprintf(("Eng", "Picking up disconnectpending while getting headers\n"));
        ourmboxin->flags |= MBOXINCOMPLETE;
        FinishHeaders();
      }

      else
      {
        if (msg->flags & NEWLYCREATED)
        {
          file = SetFilename(msg->ID, true);
          dprintf(("Eng", "About to get headers for message %d\n",msg->ID));
          downloadstate.hdrsobj = new MBoxOpCB_gethdrs_file((MBoxCBHandlerFn) eng_mbox_cbfunc, file, code, 0);
          downloadstate.context = idle;
          code = msg->mboxobj->GetHeaders(downloadstate.hdrsobj);
          if (code < 0)
          {
            /* an error of some sort - skip this message */
            dprintf(("Eng", "Error getting headers, rc=%d\n",code));
            downloadstate.context = downloadfailure;
            downloadstate.rc = (eng_rcode) code;
          }
        }
        else
        {
          /* we already have a descriptor so no need to parse */
          dprintf(("Eng", "We already have a descriptor for this message\n"));
          downloadstate.msg = msg->next;
          downloadstate.context = readytodownload;
        }
      }

      break;

    case downloadfailure :

      dprintf(("Eng", "download context = downloadfailure msg %d\n",msg->ID));
      /*
      ** Header download or parse has failed.
      ** If this is the second failure, skip this message.
      ** Otherwise try to get it again.
      ** The amount of memory to clear in the event of a
      ** memory failure has been set at 8K. This is a guess.
      */
      RemoveObj((MBoxOpCB**) &downloadstate.hdrsobj);
      DownloadFailure(msg, 0x2000, true);

      break;

    case downloaddone :

      dprintf(("Eng", "download context = downloaddone msg %d\n",msg->ID));
      RemoveObj((MBoxOpCB**) &downloadstate.hdrsobj);
      if (parsehdrstate.context == idle)
      {
        parsehdrstate.msg = downloadstate.msg;
        parsehdrstate.context = readytoparse;
        downloadstate.msg = msg->next;
        downloadstate.context = readytodownload;
      }
      else
      {
        /* not yet ready to parse - what do we do now? */
      }

      break;
  }
}


void DownloadMessage(void)
{

  ELib_rcode code;
  char *file;
  MessageDescriptor *msg = downloadstate.msg;

  switch (downloadstate.context)
  {

    case readytodownload :

      dprintf(("Eng", "context = readytodownload\n"));
      if(!msg)
      {
        /*
        ** Need to check the flag to see if any have been
        ** skipped because of size.
        ** If so, see if we still have memory and go back to
        ** download them.
        */
        
        /* all messages now downloaded */
        dprintf(("Eng", "All messages downloaded\n"));
        state &= ~DOWNLOADMSG;
        (*callbacklist.promptfunc)(ENG_COMPLETED, ourmboxin->list, online, callbacklist.prompthandle);

      }

      else if (disconnectpending)
      {
        /* a disconnect is pending */
        dprintf(("Eng", "Picking up disconnectpending while downloading\n"));
        state &= ~DOWNLOADMSG;
        (*callbacklist.promptfunc)(ENG_COMPLETED, ourmboxin->list, online, callbacklist.prompthandle);
        PreDisconnect();
      }

      else if (msg->flags & (DOWNLOADED | DOWNLOADING))
      {
        dprintf(("Eng", "Message is %s\n",(msg->flags & DOWNLOADED) ? "already downloaded" : "downloading"));
        downloadstate.msg = msg->next;
        downloadstate.context = readytodownload;
      }

      else
      {
        code = msg->mboxobj->GetLength(downloadstate.size);
        dprintf(("Eng", "Message size=%d\n",downloadstate.size));
        if (code < 0)
        {
          /* some kind of error in gettingsize */
          dprintf(("Eng", "Error returned from GetSize method\n"));
          downloadstate.context = downloadfailure;
        }
        else
        {
          if (ourmboxin->maxsize >= downloadstate.size)
          {
            msg->flags |= DOWNLOADING;
            file = SetFilename(msg->ID, false);
            downloadstate.context = idle;

            downloadstate.msgobj = new MBoxOpCB_getmsg_file((MBoxCBHandlerFn) eng_mbox_cbfunc, file, code, (void *) DOWNLOADMSG);
            code = msg->mboxobj->GetMessage(downloadstate.msgobj);
            if (code < 0)
            {
              /* an error of some sort - skip this message */
              downloadstate.context = downloadfailure;
              downloadstate.rc = (eng_rcode) code;
            }
          }
          else
          {
            dprintf(("Eng", "Skipping this message - too big\n"));
            /* set a flag so we know some have been skipped */
            
            downloadstate.msg = msg->next;
            downloadstate.context = readytodownload;
          }
        }
      }

      break;

    case downloadfailure :

      dprintf(("Eng", "context = downloadfailure, rc = %d\n",downloadstate.rc));
      /* message download or parse has failed */
      RemoveObj((MBoxOpCB**) &downloadstate.msgobj);
      msg->flags &= ~(DOWNLOADED + DOWNLOADING);
      DownloadFailure(msg, downloadstate.size, false);

      break;

  }
}


void DoRetrieve(void)
{

  ELib_rcode code;
  char *file;
  MessageDescriptor *msg = retrievestate.msg;

  switch (retrievestate.context)
  {

    case reqconnect :

      dprintf(("Eng", "context = reqconnect\n"));
      /* confirmation of connection required to get message */
      retrievestate.context = idle;
      (*callbacklist.statusfunc)(ENG_CONFIRMCONNECT, callbacklist.statushandle, eng_confirm);
      break;

    case readytoretrieve :
    {
      uint32 size;

      dprintf(("Eng", "context = readytoretrieve\n"));
      code = msg->mboxobj->GetLength(size);
      dprintf(("Eng", "Message size=%d\n",size));
      if (code < 0)
      {
        /* some kind of error in gettingsize */
        dprintf(("Eng", "Error returned from GetSize method\n"));
        retrievestate.context = downloadfailure;
      }

      else
      {
        msg->flags |= DOWNLOADING;
        file = SetFilename(msg->ID, false);
        retrievestate.context = idle;

        retrievestate.msgobj = new MBoxOpCB_getmsg_file((MBoxCBHandlerFn) eng_mbox_cbfunc, file, code, (void *) RETRIEVEMSG);
        code = msg->mboxobj->GetMessage(retrievestate.msgobj);
        if (code < 0)
        {
          /* an error of some sort - skip this message */
          retrievestate.context = downloadfailure;
          retrievestate.rc = (eng_rcode) code;
        }
      }

      break;
    }
    case retrievefailure :

      dprintf(("Eng", "context = retrievefailure\n"));
      /* return failure code to UI's callback */
      state &= ~RETRIEVEMSG;
      (*callbacklist.getmsgfunc)(retrievestate.rc, retrievestate.msg, callbacklist.getmsghandle);
      break;

    case downloadpending :

      if (msg->flags & DOWNLOADED)
        retrievestate.context = readytoparse;

      break;        

    case readytoparse :

      dprintf(("Eng", "context = readytoparse\n"));
      RemoveObj((MBoxOpCB**) &retrievestate.msgobj);
      StartParseMessage();

      break;

    case parsing :

      dprintf(("Eng", "context = parsing\n"));
      ParseMessageSlice();
      break;

    case parsedone :

      dprintf(("Eng", "context = parsedone\n"));
      FinishParseMessage();
      break;

    case readytowrite :

      dprintf(("Eng", "context = readytowrite\n"));
      if (retrievestate.ent)
        StartRetrieve();
      else
      {
        /* all entities written out to file */
        dprintf(("Eng", "Finished writing entities to file\n"));
        retrievestate.context = finished;
      }

      break;        

    case writing :

      dprintf(("Eng", "context = writing\n"));
      WriteOutSlice();

      break;

    case writedone :

      dprintf(("Eng", "context = writedone\n"));
      fclose(retrievestate.file);
      LockFile(retrievestate.ent->fname);
      retrievestate.ent = retrievestate.ent->next;
      retrievestate.context = readytowrite;

      break;

    case writefailure :

      dprintf(("Eng", "context = writefailure\n"));
      free(retrievestate.ent->fname);
      retrievestate.ent->fname = 0;
      retrievestate.context = writedone;

      break;

    case finished :

      dprintf(("Eng", "context = finished\n"));
      /* finished downloading message,
         so we can now return it to the UI */
      state &= ~RETRIEVEMSG;
      (*callbacklist.getmsgfunc)(ENG_COMPLETED, retrievestate.msg, callbacklist.getmsghandle);
      if (disconnectpending)
        PreDisconnect();

      break;
  }

}
