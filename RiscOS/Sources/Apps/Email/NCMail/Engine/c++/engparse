#define RDW_SPEEDUP_HACK 1
/*
** Email Client
** EmailLib interface
*/

#include "stdlib.h"
#include "time.h"
#include "string.h"
#include "ctype.h"
#include "swis.h"

#include "DebugLib/DebugLib.h"

#include "Email/EmailLib/rfc822msg.h"
#include "Email/EmailLib/MIMEentity.h"
#include "Email/EmailLib/MIMEtext.h"
#include "Email/EmailLib/MIMEmultip.h"
#include "Email/EmailLib/date.h"
#include "Email/EmailLib/entity.h"
#include "Email/EmailLib/to.h"
#include "Email/EmailLib/cc.h"
#include "Email/EmailLib/subject.h"
#include "Email/EmailLib/body.h"
#include "Email/EmailLib/ELib.h"
#include "Email/EmailLib/from.h"

#include "Email/Mailbox/SendQ/SendQMailbox.h"

#include "engtypes.h"
#include "engmanager.h"
#include "engfile.h"
#include "engdownld.h"
#include "engstr.h"
#include "enguiapi.h"
#include "enginit.h"
#include "engprocess.h"

#ifdef RDW_SPEEDUP_HACK
static char *rdw_tmp = 0;
#endif
static char scrapf1[] = "<Wimp$ScrapDir>.TempBody";
static char scrapf2[] = "<Wimp$ScrapDir>.TempMime";

eng_rcode FinishParseMessage(MessageDescriptor *msgptr);

eng_rcode GetHeader(char **dest, headers *hdrs, ELIB_HDR_TYPE type)
{

  ELib_rcode code;
  uint32 len;
  char *ptr;

  *dest = 0;
  header *h = hdrs->FindHdr(type);
  if (h)
  {
    code = h->GetBodyLen(len);
    if (code < 0)
      return (eng_rcode) code;
    else if (!len)
      return ENG_COMPLETED;

    ++len;
    if ((ptr = malloc(len + 1)) == 0)
    {
      dprintf(("Eng", "***ERROR*** Malloc failure\n"));
      return ENG_NOSPACEFORMSG;
    }

    code = h->GetUnfoldedNoCommentsBody(ptr, len);
    if (code < 0)
      return (eng_rcode) code;

    *dest = ptr;
  }

  return ENG_COMPLETED;

}


/*
** GetDate() gets a date header from a message
** and puts it into a tm structure.
*/

eng_rcode GetDate(struct tm **dest, headers *hdrs, ELIB_HDR_TYPE type)
{

  ELib_rcode code;
  struct tm *tim;
  date *d;

  *dest = 0;
  if ((tim = (struct tm *) malloc(sizeof(struct tm))) == 0)
  {
    dprintf(("Eng", "***ERROR*** Malloc failure\n"));
    return ENG_NOSPACEFORMSG;
  }

  d = (date *) hdrs->FindHdr(type);
  if (d)
  {
    code = d->GetDate(*tim);
    if (code < 0)
    {
      dprintf(("Eng", "***ERROR*** Error getting date, code=%d\n",code));
      return (eng_rcode) code;
    }

    *dest = tim;
  }

  return ENG_COMPLETED;

}


eng_rcode GetCharSet(char **dest, entity *ent)
{

  uint32 size = 0;
  ELib_rcode code;
  char *ptr = *dest;

  code = ent->GetCharSet(0, size);
  if (size)
  {
    if ((ptr = malloc(size + 1)) == 0)
      return ENG_NOSPACEFORMSG;

    code = ent->GetCharSet(ptr, size);
  }

  *dest = ptr;

  return ENG_COMPLETED;

}


eng_rcode GetType(char **dest, headers *hdrs)
{

  uint32 size;
  ELib_rcode code;
  char *ptr;
  contentT *con = (contentT *) hdrs->FindHdr(ELIB_HDR_CONTENT_TYPE);

  code = con->GetMajorandMinorTypes(0, size);
  if (size)
  {
    if ((ptr = malloc(size + 1)) == 0)
      return ENG_NOSPACEFORMSG;

    code = con->GetMajorandMinorTypes(ptr, size);
  }

  *dest = ptr;

  return ENG_COMPLETED;

}


void CleanUpParse(void)
{
#ifdef RDW_SPEEDUP_HACK
  if (rdw_tmp)
    delete[] rdw_tmp;
  rdw_tmp = 0;
#endif
  char *file;

  /* clean up */
  destroy_context(&parsehdrstate.elibcontext);
  delete parsehdrstate.ent;
  file = SetFilename(parsehdrstate.msg->ID, true);
  UnlockFile(file);
  remove(file);

}


/*
** StartParseHeader() starts off the process of parsing a header.
** It creates a context and an entity in a temporary file.
*/

void StartParseHeader(void)
{

  uint32 len;
  char *file;
  eng_rcode code;

  if ((code = (eng_rcode) new_context(&parsehdrstate.elibcontext)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "***ERROR*** Error setting up context, code=%d\n",code));
    parsehdrstate.context = parsefailure;
    parsehdrstate.rc = code;
  }
  else
  {
    file = SetFilename(parsehdrstate.msg->ID, true);
    len = GetFileLength(file);

#ifdef RDW_SPEEDUP_HACK
    rdw_tmp = new char[len+1];
    FILE* rdw_fd = fopen(file, "rb");
    if (rdw_fd)
    {
      fread(rdw_tmp, 1, len, rdw_fd);
      fclose(rdw_fd);
      parsehdrstate.ent = new entity(false, rdw_tmp, 0, len);
    }
    else
      parsehdrstate.ent = 0;
#else
    parsehdrstate.ent = new entity(true, file, 0, len, ELIB_ENTITY_UNKNOWN, true);
#endif
    if (parsehdrstate.ent == 0)
      CleanUpParse();
    else
      parsehdrstate.context = parsing;
  }

}


/*
** ParseHeaderSlice() is called on null events while parsinghdr
** context is active. It time-slices the call to EmailLib
** to parse the header.
*/

void ParseHeaderSlice(void)
{

  clock_t t = clock();

  ELib_rcode code = parsehdrstate.ent->ParseData(parsehdrstate.elibcontext, t + 25);
  if (code < 0)
  {
    /* error has occurred during parsing */
    dprintf(("Eng", "***ERROR*** Error while parsing\n"));
    CleanUpParse();
    parsehdrstate.context = parsefailure;
    parsehdrstate.rc = (eng_rcode) code;
  }
  else if (code != ELIB_RUNNING)
  {
    /* parsing has finished */
    parsehdrstate.context = parsedone;
  }
  else
    dprintf(("Eng", "Parsing a slice\n"));

}


/*
** FinishParseHeader() puts the required header info into the
** message descriptor once EmailLib has parsed the header.
** It then moves on to the next header.
*/

void FinishParseHeader(void)
{

  eng_rcode code;
  uint32 len = 0;
  MessageDescriptor *msg = parsehdrstate.msg;

  dprintf(("Eng", "Finished parsing header for message %d\n",msg->ID));
  /* get headers into descriptor */
  headers *hdrs = parsehdrstate.ent->GetHdrs();
  from *h = (from *) hdrs->FindHdr(ELIB_HDR_FROM);

  parsehdrstate.rc = ENG_COMPLETED;
  if (!h)
    parsehdrstate.context = parsefailure;
  else
  {
    code = (eng_rcode) h->GetRealName(0, len);
    if (len)
    {
      if ((msg->fromreal = malloc(len + 1)) == 0)
      {
        parsehdrstate.rc = ENG_NOSPACEFORMSG;
        parsehdrstate.context = parsefailure;
      }
      else
      {
        code = (eng_rcode) h->GetRealName(msg->fromreal, len);
        dprintf(("Eng", "From Realname = %s\n",msg->fromreal));
      }
    }

    len = 0;
    code = (eng_rcode) h->GetAddress(0, len);
    if ((!len) && (!msg->fromreal))
      parsehdrstate.context = parsefailure;
    else if (len)
    {
      if ((msg->fromaddr = malloc(len + 1)) == 0)
      {
        parsehdrstate.rc = ENG_NOSPACEFORMSG;
        parsehdrstate.context = parsefailure;
      }
      else
      {
        code = (eng_rcode) h->GetAddress(msg->fromaddr, len);
        dprintf(("Eng", "From Address = %s\n",msg->fromaddr));
      }
    }
  }
  if ((!msg->fromaddr) && (!msg->fromreal))
    parsehdrstate.context = parsefailure;

  if ((code = GetHeader(&msg->subject, hdrs, ELIB_HDR_SUBJECT)) < 0)
  {
    parsehdrstate.context = parsefailure;
    parsehdrstate.rc = code;
  }
  else
    dprintf(("Eng", "Subject = %s\n",(msg->subject) ? msg->subject : "none"));

  if ((code = GetDate(&msg->datestruct, hdrs, ELIB_HDR_DATE)) < 0)
  {
    parsehdrstate.context = parsefailure;
    parsehdrstate.rc = code;
  }
  else
    dprintf(("Eng", "Date is %s\n",asctime(msg->datestruct)));

  CleanUpParse();
  if (parsehdrstate.context != parsefailure)
  {
    parsehdrstate.context = idle;
    msg->flags &= ~(NEWLYCREATED + ERROR);
    SortByDate(msg);
    if (hdrsdownloaded)
      FinishHeaders();
  }

}


void DoParseHeader(void)
{

  switch (parsehdrstate.context)
  {
    case readytoparse :

      dprintf(("Eng", "Parse context = readytoparse msg %d\n",parsehdrstate.msg->ID));
      StartParseHeader();
      break;

    case parsefailure :

      break;

    case parsing :

      dprintf(("Eng", "parse context = parsing msg %d\n",parsehdrstate.msg->ID));
      ParseHeaderSlice();
      break;

    case parsedone :

      dprintf(("Eng", "parse context = parsedone msg %d\n",parsehdrstate.msg->ID));
      FinishParseHeader();
      break;
  }

}


eng_rcode GetRFC822Body(rfc822msg *rfc, MessageDescriptor *msgptr)
{

  EntityDescriptor *e = NewEntity(msgptr);
  dprintf(("Eng", "Content type is not multipart\n"));
  if (e == 0)
  {
    /* wasn't enough memory */
    return ENG_NOSPACEFORMSG;
  }

  e->ent = (entity *) rfc;
  e->flags |= ENTITY_OK;

  return ENG_COMPLETED;
}


eng_rcode ParseMime(MIMEentity *ent, MessageDescriptor *msgptr)
{

  eng_rcode code = ENG_COMPLETED;
  ELIB_CT contenttype;
  int num = 1;

  dprintf(("Eng", "Entering ParseMime()\n"));
  ent->GetMajorType(contenttype);
  dprintf(("Eng", "major content type = %d\n",contenttype));
  if (contenttype == ELIB_CT_MULTIPART)
  {
    MIMEmultip *multipart;
    int current = 0;
    dprintf(("Eng", "Content type is multipart\n"));
    multipart = (MIMEmultip*) ent;
    num = multipart->GetNumEntities();
    dprintf(("Eng", "Number of entities = %d\n",num));
    while ((current < num) && (code >= 0))
      code = ParseMime(multipart->GetEntity(current++), msgptr);
  }
  else if (num)
  {
    /* Create an entity descriptor for the entity */
    EntityDescriptor *e = NewEntity(msgptr);
    dprintf(("Eng", "Content type is not multipart\n"));
    if (e == 0)
    {
      /* wasn't enough memory */
      return ENG_NOSPACEFORMSG;
    }

    headers *hdrs = ent->GetHdrs();
    e->ent = (entity *) ent;
    if ((code = GetType(&e->typestr, hdrs)) == ENG_NOSPACEFORMSG)
      return code;
    else
      dprintf(("Eng", "Content type = %s\n",e->typestr));

    dprintf(("Eng", "Number of entities in message = %d\n",msgptr->entity_num));
    /*
    ** If charset for message is not already set,
    ** set it to this entity's charset if it has one.
    */

    if (!msgptr->charset)
    {
      if ((code = GetCharSet(&e->charset, ent)) == ENG_NOSPACEFORMSG)
        return code;
      if (e->charset)
        msgptr->charset = e->charset;
    }

    /* Set entity flags according to content type */

    switch (contenttype)
    {
      case ELIB_CT_TEXT :
      case ELIB_CT_MESSAGE :

        dprintf(("Eng", "Setting entity flags to OK\n"));
        e->flags |= ENTITY_OK;
        break;

      case ELIB_CT_APPLICATION :
      case ELIB_CT_MODEL :
      case ELIB_CT_UNKNOWN :

        dprintf(("Eng", "Setting entity flags to BEST\n"));
        e->flags |= ENTITY_BEST;
        break;

      default :

        dprintf(("Eng", "Setting entity flags to NOT_OK\n"));
        e->flags |= ENTITY_NOT_OK;
        break;
    }
  }

  return code;
}


void StartParseMessage(void)
{

  int len;
  char *file;
  eng_rcode code;

  if ((code = (eng_rcode) new_context(&retrievestate.elibcontext)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "***ERROR*** Error creating new context\n"));
    retrievestate.context = downloadfailure;
    retrievestate.rc = code;
  }
  else
  {
    file = SetFilename(retrievestate.msg->ID, false);
    len = GetFileLength(file);
    retrievestate.rfc = new rfc822msg(true, file, 0, len, true);
    if (!retrievestate.rfc)
      retrievestate.context = downloadfailure;
    else
    {
      retrievestate.context = parsing;
      dprintf(("Eng", "About to parse message %d\n",retrievestate.msg->ID));
    }
  }
}


void ParseMessageSlice(void)
{

  clock_t t = clock();

  ELib_rcode code = retrievestate.rfc->ParseData(retrievestate.elibcontext, t + 25);
  if (code < 0)
  {
    /* error has occurred during parsing */
    dprintf(("Eng", "***ERROR*** Error in parsing, rc=%d\n",code));
    retrievestate.context = downloadfailure;
    retrievestate.rc = (eng_rcode) code;
  }
  else if (code != ELIB_RUNNING)
  {
    /* parsing has finished */
    dprintf(("Eng", "Parsing done\n"));
    retrievestate.context = parsedone;
  }
  else
    dprintf(("Eng", "Still parsing\n"));

}


void FinishParseMessage(void)
{

  eng_rcode code;
  MIMEentity *ent = retrievestate.rfc->GetMIMEentity();
  MessageDescriptor *msg = retrievestate.msg;
  headers *hdrs = retrievestate.rfc->GetHdrs();

  dprintf(("Eng", "Entering FinishParseMessage(), ent=0x%x\n",ent));
  msg->entity_num = 0;
  msg->entity_list = 0;
  msg->elibobj = retrievestate.rfc;

  /* get remaining headers */
  if ((code = GetHeader(&msg->to, hdrs, ELIB_HDR_TO)) == ENG_NOSPACEFORMSG)
    retrievestate.rc = code;
  else if (code >= 0)
    dprintf(("Eng", "To = %s\n",msg->to));

  if ((code = GetHeader(&msg->cc, hdrs, ELIB_HDR_CC)) == ENG_NOSPACEFORMSG)
  {
    retrievestate.rc = code;
  }
  else if (code >= 0)
    dprintf(("Eng", "CC = %s\n",msg->cc));

  if ((code = GetCharSet(&msg->charset, (entity *) retrievestate.rfc)) == ENG_NOSPACEFORMSG)
    retrievestate.rc = code;
  else if (code >= 0)
    dprintf(("Eng", "charset = %s\n",msg->charset));

  if ((code = GetHeader(&msg->datestr, hdrs, ELIB_HDR_DATE)) == ENG_NOSPACEFORMSG)
    retrievestate.rc = code;
  else if (code >= 0)
    dprintf(("Eng", "Date = %s\n",msg->datestr));

  if (ent == NULL)
    code = (eng_rcode) GetRFC822Body(retrievestate.rfc, msg);
  else
    code = ParseMime(ent, msg);

  if (code >= 0)
  {
    /* if descriptor doesn't now have a charset, set a default */
    if (!msg->charset)
    {
      if ((msg->charset = malloc(9)) == 0)
        code = ENG_NOSPACEFORMSG;
      else
        strcpy(msg->charset, "ISO-8859-1");
    }
  }

  /* clean up */
  destroy_context(&retrievestate.elibcontext);

  if (code < 0)
  {
    retrievestate.rc = code;
    retrievestate.context = downloadfailure;
  }

  else
  {
    retrievestate.ent = msg->entity_list;
    retrievestate.context = readytowrite;
  }

}


void WriteOutSlice(void)
{

  clock_t t = clock();
  ELib_rcode code;

  dprintf(("Eng", "Entering WriteOutSlice\n"));
  if (retrievestate.enc == 0)
    code = retrievestate.msgbody->WriteOut(retrievestate.elibcontext, t + 25, retrievestate.file);
  else
    code = retrievestate.msgbody->RemoveEncoding(retrievestate.elibcontext, t + 25, retrievestate.ent->fname, retrievestate.file, 0x1000);

  if (code < 0)
  {
    /* error has occurred during writing out */
    dprintf(("Eng", "***ERROR*** Error while writing out body\n"));
    retrievestate.context = writefailure;
    retrievestate.ent->flags = ENTITY_NOT_OK;
  }
  else if (code != ELIB_RUNNING)
  {
    /* writing out has finished */
    dprintf(("Eng", "Finished writing out body\n"));
    retrievestate.context = writedone;
  }

  else
  {
    dprintf(("Eng", "Writing out entity body\n"));
  }

}


void StartRetrieve(void)
{

  eng_rcode code;

  if ((code = (eng_rcode) new_context(&retrievestate.elibcontext)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "***ERROR*** Error creating new context\n"));
    retrievestate.context = writefailure;
  }

  else
  {
    retrievestate.file = fopen(retrievestate.ent->fname, "w");
    retrievestate.msgbody = retrievestate.ent->ent->GetBody();
    retrievestate.ent->ent->GetEncoding(retrievestate.enc);
    dprintf(("Eng", "Encoding for entity = %d\n",retrievestate.enc));
    retrievestate.context = writing;
  }

}


void AssembleMessage(MessageDescriptor *msg)
{

  ELib_rcode code;

  MIMEtext *ent = new MIMEtext(true, scrapf2, 0, 0, ELIB_CT_TEXT_PLAIN, true);
  if (!ent)
  {
    sendstate.context = parsefailure;
    return;
  }

  code = ent->ReplaceBody(sendstate.msgbody);
  if (code < 0)
  {
    sendstate.context = parsefailure;
    return;
  }

  to tohdr(false, 0, 0, 0, true);
/*   cc cchdr(false, 0, 0, 0, true); */
  subject *subhdr = new subject(false, 0, 0, 0, true);
  from fromhdr(false, 0, 0, 0, true);

  tohdr.SetAddress(msg->to);
  fromhdr.SetRealName(realname);
  fromhdr.SetAddress(emailaddr);
/*   cchdr.SetAddress(msg->cc); */

  rfc822msg *rfc = new rfc822msg(true, 0, 0, 0, true);
  if (!rfc)
  {
    sendstate.context = parsefailure;
    return;
  }

  headers *hdrs = rfc->GetHdrs();
  code = rfc->SetTo(tohdr);
  if (code >= 0)
    code = rfc->SetFrom(fromhdr);
  if (code < 0)
  {
    sendstate.context = parsefailure;
    return;
  }

  code = subhdr->SetBody(msg->subject);
  if (code >= 0)
    code = hdrs->AddHdr(*subhdr);
  if (code < 0)
  {
    delete subhdr;
    sendstate.context = parsefailure;
    return;
  }

#ifdef gorilla
  if ((code = hdrs->AddHdr(cchdr)) < 0)
  {
    sendstate.context = parsefailure;
    return;
  }
#endif

  sendstate.file = fopen(SetFilename(msg->ID, true), "w");
  dprintf(("Eng", "File handle for writing out is %d\n",sendstate.file));
  *rfc += *ent;
  sendstate.rfc = rfc;
  sendstate.context = readytowrite;

}


void DoCreateMessage(void)
{

  switch (createstate.context)
  {
    case readytocreate :

      dprintf(("Eng", "Create context is readytocreate\n"));
      if (state & CREATE)
      {
        state &= ~CREATE;
        dprintf(("Eng", "Calling back UI with new message %d\n",createstate.msg->ID));
        (*callbacklist.createfunc)(ENG_COMPLETED, createstate.msg, callbacklist.createhandle);
      }

      else
      {
        /* get EmailLib to parse the message and return a reply
           correctly formatted */
        dprintf(("Eng", "Asking EmailLib to prepare reply\n"));
        createstate.context = readytoparse;
      }

      break;

    case readytoparse :

      dprintf(("Eng", "Create context is readytoparse\n"));
      break;
  }

}


void DoSend(void)
{

  MessageDescriptor *msg = sendstate.msg;
  ELib_rcode code;

  switch (sendstate.context)
  {
    case readytoparse :

      dprintf(("Eng", "Send context is readytoparse\n"));
      if ((code = new_context(&sendstate.elibcontext)) < 0)
      {
        /* error setting up context */
       dprintf(("Eng", "***ERROR*** Error setting up context, code=%d\n",code));
       sendstate.context = parsefailure;
      }
      else
      {
        uint32 len = GetFileLength(sendstate.bodyname);
        sendstate.msgbody = new body(true, sendstate.bodyname, 0, len, ELIB_TE_NONE, true);
        sendstate.context = readytoencode;
      }

      break;

    case parsefailure :

      /* creation of new message has failed */
      dprintf(("Eng", "Send context is parsefailure\n"));
      (*callbacklist.sendfunc)(ENG_SENDFAILED, callbacklist.sendhandle);
      state &= ~SEND;
      break;

    case readytoencode :

      dprintf(("Eng", "Send context is readytoencode\n"));
      code = sendstate.msgbody->ApplyEncoding(sendstate.elibcontext, clock() + 25, ELIB_TE_QUOTED_PRINTABLE, scrapf1, 0x1000);
      if (code < 0)
      {
        dprintf(("Eng", "***ERROR*** Parsefailure rc=%d\n",code));
        sendstate.context = parsefailure;
      }
      else if (code != ELIB_RUNNING)
        sendstate.context = encoded;

      break;

    case encoded :

      dprintf(("Eng", "Send context is encoded\n"));
      AssembleMessage(msg);
      break;

    case readytowrite :

      dprintf(("Eng", "Send context is readytowrite\n"));
      code = sendstate.rfc->WriteOut(sendstate.elibcontext, clock() + 25, sendstate.file);
      dprintf(("Eng", "Writing out file\n"));
      if (code < 0)
        sendstate.context = parsefailure;
      else if (code != ELIB_RUNNING)
        sendstate.context = writedone;

    case writedone :

      dprintf(("Eng", "Send context is writedone\n"));
      fclose(sendstate.file);
      LockFile(SetFilename(msg->ID, true));
      remove(scrapf2);

      SendMessage();
      dprintf(("Eng", "Removing scrapfile %ssuccessfully\n",(remove(scrapf1)) ? "un" : ""));

      break;
  }

}
