/*
** Email Client
** EmailLib interface
*/

#define RDW_SPEEDUP_HACK 1

#include "stdlib.h"
#include "time.h"
#include "string.h"
#include "ctype.h"
#include "swis.h"

#include "DebugLib/DebugLib.h"

#include "Email/EmailLib/rfc822msg.h"
#include "Email/EmailLib/MIMEentity.h"
#include "Email/EmailLib/MIMEtext.h"
#include "Email/EmailLib/MIMEmultip.h"
#include "Email/EmailLib/date.h"
#include "Email/EmailLib/entity.h"
#include "Email/EmailLib/to.h"
#include "Email/EmailLib/cc.h"
#include "Email/EmailLib/subject.h"
#include "Email/EmailLib/body.h"
#include "Email/EmailLib/ELib.h"
#include "Email/EmailLib/from.h"

#include "Email/Mailbox/SendQ/SendQMailbox.h"

#include "engtypes.h"
#include "engmanager.h"
#include "engfile.h"
#include "engdownld.h"
#include "engstr.h"
#include "engcbf.h"
#include "enginit.h"
#include "engprocess.h"
#include "engparse.h"
#include "enguiapi.h"

#ifdef RDW_SPEEDUP_HACK
static char *rdw_tmp = 0;
#endif

eng_rcode FinishParseMessage(MessageDescriptor *msgptr);

eng_rcode GetHeader(char **dest, headers *hdrs, ELIB_HDR_TYPE type)
{

  ELib_rcode code;
  uint32 len;
  char *ptr;

  *dest = 0;
  header *h = hdrs->FindHdr(type);
  if (h)
  {
    code = h->GetBodyLen(len);
    if (code < 0)
      return ENG_GETHDRFAILED;
    else if (!len)
      return ENG_COMPLETED;

    ++len;
    if ((ptr = malloc(len + 1)) == 0)
    {
      dprintf(("Eng", "***ERROR*** Malloc failure\n"));
      return ENG_NOMEMORY;
    }

    code = h->GetUnfoldedNoCommentsBody(ptr, len);
    if (code < 0)
      return ENG_GETHDRFAILED;

    *dest = ptr;
  }

  return ENG_COMPLETED;

}


/*
** GetDate() gets a date header from a message
** and puts it into a tm structure.
*/

eng_rcode GetDate(struct tm **dest, headers *hdrs, ELIB_HDR_TYPE type)
{

  ELib_rcode code;
  struct tm *tim;
  date *d;

  *dest = 0;
  if ((tim = (struct tm *) malloc(sizeof(struct tm))) == 0)
  {
    dprintf(("Eng", "***ERROR*** Malloc failure\n"));
    return ENG_NOMEMORY;
  }

  d = (date *) hdrs->FindHdr(type);
  if (d)
  {
    code = d->GetDate(*tim);
    if (code < 0)
    {
      dprintf(("Eng", "***ERROR*** Error getting date, code=%d\n",code));
      return ENG_GETHDRFAILED;
    }

    *dest = tim;
  }

  return ENG_COMPLETED;

}


eng_rcode GetCharSet(char **dest, entity *ent)
{

  uint32 size = 0;
  ELib_rcode code;
  char *ptr = *dest;

  code = ent->GetCharSet(0, size);
  if (size)
  {
    if ((ptr = malloc(size + 1)) == 0)
      return ENG_NOMEMORY;

    code = ent->GetCharSet(ptr, size);
  }

  *dest = ptr;

  return ENG_COMPLETED;

}


eng_rcode GetType(char **dest, headers *hdrs)
{

  uint32 size;
  ELib_rcode code;
  char *ptr = 0;
  contentT *con = (contentT *) hdrs->FindHdr(ELIB_HDR_CONTENT_TYPE);

  code = con->GetMajorandMinorTypes(0, size);
  if (size)
  {
    if ((ptr = malloc(size + 1)) == 0)
      return ENG_NOMEMORY;

    code = con->GetMajorandMinorTypes(ptr, size);
  }

  *dest = ptr;

  return ENG_COMPLETED;

}


void CleanUpParse(void)
{
#ifdef RDW_SPEEDUP_HACK
  if (rdw_tmp)
    delete[] rdw_tmp;
  rdw_tmp = 0;
#endif
  char *file;

  /* clean up */
  destroy_context(&parsehdrstate.elibcontext);
  delete parsehdrstate.ent;
  file = SetFilename(parsehdrstate.msg->ID, true);
  UnlockFile(file);
  remove(file);

}


/*
** StartParseHeader() starts off the process of parsing a header.
** It creates a context and an entity in a temporary file.
*/

void StartParseHeader(void)
{

  uint32 len;
  char *file;
  eng_rcode code;

  if ((code = (eng_rcode) new_context(&parsehdrstate.elibcontext)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "***ERROR*** Error setting up context, code=%d\n",code));
    parsehdrstate.context = parsefailure;
    parsehdrstate.ret.code = (code == ELIB_EMALLOCFAILED) ? ENG_NOMEMORY : ENG_GETHDRFAILED;
  }
  else
  {
    file = SetFilename(parsehdrstate.msg->ID, true);
    len = GetFileLength(file);

#ifdef RDW_SPEEDUP_HACK
    rdw_tmp = new char[len+1];
    FILE* rdw_fd = fopen(file, "rb");
    if (rdw_fd)
    {
      fread(rdw_tmp, 1, len, rdw_fd);
      fclose(rdw_fd);
      parsehdrstate.ent = new entity(false, rdw_tmp, 0, len);
    }
    else
      parsehdrstate.ent = 0;
#else
    parsehdrstate.ent = new entity(true, file, 0, len, ELIB_ENTITY_UNKNOWN, true);
#endif
    if (parsehdrstate.ent == 0)
    {
      CleanUpParse();
      parsehdrstate.context = parsefailure;
      parsehdrstate.ret.code = ENG_NOMEMORY;
    }
    else
      parsehdrstate.context = parsing;
  }

}


/*
** ParseHeaderSlice() is called on null events while parsinghdr
** context is active. It time-slices the call to EmailLib
** to parse the header.
*/

void ParseHeaderSlice(void)
{

  clock_t t = clock();

  ELib_rcode code = parsehdrstate.ent->ParseData(parsehdrstate.elibcontext, t + 25);
  if (code < 0)
  {
    /* error has occurred during parsing */
    dprintf(("Eng", "***ERROR*** Error while parsing\n"));
    CleanUpParse();
    parsehdrstate.context = parsefailure;
    parsehdrstate.ret.code = (code == ELIB_EMALLOCFAILED) ? ENG_NOMEMORY : ENG_GETHDRFAILED;
  }
  else if (code != ELIB_RUNNING)
  {
    /* parsing has finished */
    parsehdrstate.context = parsedone;
  }
  else
    dprintf(("Eng", "Parsing a slice\n"));

}


/*
** FinishParseHeader() puts the required header info into the
** message descriptor once EmailLib has parsed the header.
** It then moves on to the next header.
*/

void FinishParseHeader(void)
{

  eng_rcode code;
  uint32 len = 0;
  MessageDescriptor *msg = parsehdrstate.msg;

  dprintf(("Eng", "Finished parsing header for message %d\n",msg->ID));
  /* get headers into descriptor */
  headers *hdrs = parsehdrstate.ent->GetHdrs();
  from *h = (from *) hdrs->FindHdr(ELIB_HDR_FROM);

  parsehdrstate.ret.code = ENG_COMPLETED;
  if (!h)
  {
    parsehdrstate.context = parsefailure;
    parsehdrstate.ret.code = ENG_NOMEMORY;
  }

  else
  {
    code = (eng_rcode) h->GetRealName(0, len);
    if (len)
    {
      if ((msg->fromreal = malloc(len + 1)) == 0)
      {
        parsehdrstate.ret.code = ENG_NOMEMORY;
        parsehdrstate.context = parsefailure;
      }
      else
      {
        code = (eng_rcode) h->GetRealName(msg->fromreal, len);
        dprintf(("Eng", "From Realname = %s\n",msg->fromreal));
      }
    }

    len = 0;
    code = (eng_rcode) h->GetAddress(0, len);
    if ((!len) && (!msg->fromreal))
      parsehdrstate.context = parsefailure;
    else if (len)
    {
      if ((msg->fromaddr = malloc(len + 1)) == 0)
      {
        parsehdrstate.ret.code = ENG_NOMEMORY;
        parsehdrstate.context = parsefailure;
      }
      else
      {
        code = (eng_rcode) h->GetAddress(msg->fromaddr, len);
        dprintf(("Eng", "From Address = %s\n",msg->fromaddr));
      }
    }
  }
  if ((!msg->fromaddr) && (!msg->fromreal))
    parsehdrstate.context = parsefailure;

  if ((code = GetHeader(&msg->subject, hdrs, ELIB_HDR_SUBJECT)) < 0)
  {
    parsehdrstate.context = parsefailure;
    parsehdrstate.ret.code = code;
  }
  else
    dprintf(("Eng", "Subject = %s\n",(msg->subject) ? msg->subject : "none"));

  if ((code = GetDate(&msg->datestruct, hdrs, ELIB_HDR_DATE)) < 0)
  {
    parsehdrstate.context = parsefailure;
    parsehdrstate.ret.code = code;
  }
  else
    dprintf(("Eng", "Date is %s\n",asctime(msg->datestruct)));

  CleanUpParse();
  if (parsehdrstate.context != parsefailure)
  {
    parsehdrstate.context = idle;
    msg->flags &= ~(NEWLYCREATED + ERROR);
    SortByDate(msg);
    if (hdrsdownloaded)
      FinishHeaders();
  }

}


void DoParseHeader(void)
{

  switch (parsehdrstate.context)
  {
    case readytoparse :

      dprintf(("Eng", "Parse context = readytoparse msg %d\n",parsehdrstate.msg->ID));
      StartParseHeader();
      break;

    case parsefailure :

      break;

    case parsing :

      dprintf(("Eng", "parse context = parsing msg %d\n",parsehdrstate.msg->ID));
      ParseHeaderSlice();
      break;

    case parsedone :

      dprintf(("Eng", "parse context = parsedone msg %d\n",parsehdrstate.msg->ID));
      FinishParseHeader();
      break;
  }

}


eng_rcode GetRFC822Body(rfc822msg *rfc, MessageDescriptor *msgptr)
{

  EntityDescriptor *e = NewEntity(msgptr, read);
  dprintf(("Eng", "Content type is not multipart\n"));
  if (e == 0)
  {
    /* wasn't enough memory */
    return ENG_NOMEMORY;
  }

  e->ent = (entity *) rfc;
  e->flags |= ENTITY_OK;

  return ENG_COMPLETED;
}


eng_rcode ParseMime(MIMEentity *ent, MessageDescriptor *msgptr)
{

  eng_rcode code = ENG_COMPLETED;
  ELIB_CT contenttype;
  int num = 1;

  dprintf(("Eng", "Entering ParseMime()\n"));
  ent->GetMajorType(contenttype);
  dprintf(("Eng", "major content type = %d\n",contenttype));
  if (contenttype == ELIB_CT_MULTIPART)
  {
    MIMEmultip *multipart;
    int current = 0;
    dprintf(("Eng", "Content type is multipart\n"));
    multipart = (MIMEmultip*) ent;
    num = multipart->GetNumEntities();
    dprintf(("Eng", "Number of entities = %d\n",num));
    while ((current < num) && (code >= 0))
      code = ParseMime(multipart->GetEntity(current++), msgptr);
  }
  else if (num)
  {
    /* Create an entity descriptor for the entity */
    EntityDescriptor *e = NewEntity(msgptr, read);
    dprintf(("Eng", "Content type is not multipart\n"));
    if (e == 0)
    {
      /* wasn't enough memory */
      return ENG_NOMEMORY;
    }

    headers *hdrs = ent->GetHdrs();
    e->ent = (entity *) ent;
    if ((code = GetType(&e->typestr, hdrs)) == ENG_NOMEMORY)
      return code;
    else
      dprintf(("Eng", "Content type = %s\n",e->typestr));

    dprintf(("Eng", "Number of entities in message = %d\n",msgptr->entity_num));
    /*
    ** If charset for message is not already set,
    ** set it to this entity's charset if it has one.
    */

    if (!msgptr->charset)
    {
      if ((code = GetCharSet(&e->charset, ent)) == ENG_NOMEMORY)
        return code;
      if (e->charset)
        msgptr->charset = e->charset;
    }

    /* Set entity flags according to content type */

    switch (contenttype)
    {
      case ELIB_CT_TEXT :
      case ELIB_CT_MESSAGE :

        dprintf(("Eng", "Setting entity flags to OK\n"));
        e->flags |= ENTITY_OK;
        break;

      case ELIB_CT_APPLICATION :
      case ELIB_CT_MODEL :
      case ELIB_CT_UNKNOWN :

        dprintf(("Eng", "Setting entity flags to BEST\n"));
        e->flags |= ENTITY_BEST;
        break;

      default :

        dprintf(("Eng", "Setting entity flags to NOT_OK\n"));
        e->flags |= ENTITY_NOT_OK;
        break;
    }
  }

  return code;
}


void StartParseMessage(void)
{

  int len;
  char *file;
  eng_rcode code;

  if ((code = (eng_rcode) new_context(&retrievestate.elibcontext)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "***ERROR*** Error creating new context\n"));
    retrievestate.context = retrievefailure;
    retrievestate.ret.code = (code == ELIB_EMALLOCFAILED) ? ENG_NOMEMORY  : ENG_GETMSGFAILED;
  }
  else
  {
    file = SetFilename(retrievestate.msg->ID, false);
    len = GetFileLength(file);
    retrievestate.rfc = new rfc822msg(true, file, 0, len, true);
    if (!retrievestate.rfc)
    {
      retrievestate.context = retrievefailure;
      retrievestate.ret.code = ENG_GETMSGFAILED;
    }
    else
    {
      retrievestate.context = parsing;
      dprintf(("Eng", "About to parse message %d\n",retrievestate.msg->ID));
    }
  }
}


void ParseMessageSlice(void)
{

  clock_t t = clock();

  ELib_rcode code = retrievestate.rfc->ParseData(retrievestate.elibcontext, t + 25);
  if (code < 0)
  {
    /* error has occurred during parsing */
    dprintf(("Eng", "***ERROR*** Error in parsing, rc=%d\n",code));
    retrievestate.context = retrievefailure;
    retrievestate.ret.code = (code == ELIB_EMALLOCFAILED) ? ENG_NOMEMORY : ENG_GETMSGFAILED;
  }
  else if (code != ELIB_RUNNING)
  {
    /* parsing has finished */
    dprintf(("Eng", "Parsing done\n"));
    retrievestate.context = parsedone;
  }
  else
    dprintf(("Eng", "Still parsing\n"));

}


void FinishParseMessage(void)
{

  eng_rcode code;
  MIMEentity *ent = retrievestate.rfc->GetMIMEentity();
  MessageDescriptor *msg = retrievestate.msg;
  headers *hdrs = retrievestate.rfc->GetHdrs();

  dprintf(("Eng", "Entering FinishParseMessage(), ent=0x%x\n",ent));
  msg->entity_num = 0;
  msg->entity_list = 0;
  msg->elibobj = retrievestate.rfc;

  /* get remaining headers */
  if ((code = GetHeader(&msg->to, hdrs, ELIB_HDR_TO)) == ENG_NOMEMORY)
    retrievestate.ret.code = code;
  else if (code >= 0)
    dprintf(("Eng", "To = %s\n",msg->to));

  if ((code = GetHeader(&msg->cc, hdrs, ELIB_HDR_CC)) == ENG_NOMEMORY)
  {
    retrievestate.ret.code = code;
  }
  else if (code >= 0)
    dprintf(("Eng", "CC = %s\n",msg->cc));

  if ((code = GetCharSet(&msg->charset, (entity *) retrievestate.rfc)) == ENG_NOMEMORY)
    retrievestate.ret.code = code;
  else if (code >= 0)
    dprintf(("Eng", "charset = %s\n",msg->charset));

  if ((code = GetHeader(&msg->datestr, hdrs, ELIB_HDR_DATE)) == ENG_NOMEMORY)
    retrievestate.ret.code = code;
  else if (code >= 0)
    dprintf(("Eng", "Date = %s\n",msg->datestr));

  if (ent == NULL)
    code = (eng_rcode) GetRFC822Body(retrievestate.rfc, msg);
  else
    code = ParseMime(ent, msg);

  if (code >= 0)
  {
    /* if descriptor doesn't now have a charset, set a default */
    if (!msg->charset)
    {
      if ((msg->charset = malloc(9)) == 0)
        code = ENG_NOMEMORY;
      else
        strcpy(msg->charset, "ISO-8859-1");
    }
  }

  /* clean up */
  destroy_context(&retrievestate.elibcontext);

  if (code < 0)
  {
    retrievestate.ret.code = code;
    retrievestate.context = retrievefailure;
  }

  else
  {
    retrievestate.ent = msg->entity_list;
    retrievestate.context = readytowrite;
  }

}


void WriteOutSlice(void)
{

  clock_t t = clock();
  ELib_rcode code;

  dprintf(("Eng", "Entering WriteOutSlice\n"));

#ifdef gorilla
  if (retrievestate.enc == 0)
    code = retrievestate.msgbody->WriteOut(retrievestate.elibcontext, t + 25, retrievestate.file);
  else
    code = retrievestate.msgbody->RemoveEncoding(retrievestate.elibcontext, t + 25, retrievestate.ent->fname, retrievestate.file, 0x1000);
#endif

  code = retrievestate.msgbody->WriteOut(retrievestate.elibcontext, t + 25, retrievestate.file, ELIB_TE_BINARY);

  if (code < 0)
  {
    /* error has occurred during writing out */
    dprintf(("Eng", "***ERROR*** Error while writing out body\n"));
    retrievestate.context = writefailure;
    retrievestate.ent->flags = ENTITY_NOT_OK;
  }
  else if (code != ELIB_RUNNING)
  {
    /* writing out has finished */
    dprintf(("Eng", "Finished writing out body\n"));
    retrievestate.context = writedone;
  }

  else
  {
    dprintf(("Eng", "Writing out entity body\n"));
  }

}


void StartRetrieve(void)
{

  eng_rcode code;

  if ((code = (eng_rcode) new_context(&retrievestate.elibcontext)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "***ERROR*** Error creating new context\n"));
    retrievestate.context = writefailure;
  }

  else
  {
    retrievestate.file = fopen(retrievestate.ent->fname, "w");
    retrievestate.msgbody = retrievestate.ent->ent->GetBody();
    retrievestate.ent->ent->GetEncoding(retrievestate.enc);
    dprintf(("Eng", "Encoding for entity = %d\n",retrievestate.enc));
    retrievestate.context = writing;
  }

}
