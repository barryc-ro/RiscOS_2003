/*
** Email Client
** EmailLib interface
*/

#include "stdlib.h"
#include "time.h"
#include "string.h"
#include "ctype.h"

#include "DebugLib/DebugLib.h"

#include "Email/EmailLib/rfc822msg.h"
#include "Email/EmailLib/MIMEentity.h"
#include "Email/EmailLib/MIMEmultip.h"
#include "Email/EmailLib/date.h"
#include "Email/EmailLib/entity.h"
#include "Email/EmailLib/to.h"
#include "Email/EmailLib/subject.h"
#include "Email/EmailLib/body.h"

#include "engtypes.h"
#include "engmanager.h"
#include "engfile.h"
#include "engdownld.h"
#include "engstr.h"
#include "enguiapi.h"


eng_rcode FinishParseMessage(MessageDescriptor *msgptr);

eng_rcode GetHeader(char **dest, headers *hdrs, ELIB_HDR_TYPE type)
{

  ELib_rcode code;
  uint32 len;
  char *ptr;

  *dest = 0;
  header *h = hdrs->FindHdr(type);
  code = h->GetBodyLen(len);
  dprintf(("Eng", "Got BodyLen, len=%d, code=%d\n",len,code));
  if (!len)
    return ENG_COMPLETED;

  ++len;
  if (code < 0)
    return (eng_rcode) code;

  else
  {
    if (!(ptr = malloc(len + 1)))
    {
      dprintf(("Eng", "Malloc failure\n"));
      return ENG_NOSPACEFORMSG;
    }
        
    code = h->GetUnfoldedNoCommentsBody(ptr, len);
    dprintf(("Eng", "Got Body, len=%d, code=%d\n",len,code));
    if (code < 0)
      return (eng_rcode) code;

  }

  *dest = ptr;
  return ENG_COMPLETED;

}


/*
** GetDate() gets a date header from a message
** and puts it into a tm structure.
*/

eng_rcode GetDate(struct tm **dest, headers *hdrs, ELIB_HDR_TYPE type)
{
  
  ELib_rcode code;
  struct tm *tim;
  date *d;

  if ((tim = (struct tm *) malloc(sizeof(struct tm))) == 0)
  {
    dprintf(("Eng", "Malloc failure\n"));
    return ENG_NOSPACEFORMSG;
  }
    
  d = (date *) hdrs->FindHdr(type);
  code = d->GetDate(*tim);
  if (code < 0)
  {
    dprintf(("Eng", "Error getting date, code=%d\n",code));
    return (eng_rcode) code;
  }
  
  *dest = tim;
  return ENG_COMPLETED;

}


/*
** StartParseHeader() starts off the process of parsing a header.
** It creates a context and an entity in a temporary file.
*/

void StartParseHeader(void)
{

  uint32 len;
  char *file;
  eng_rcode code;

  if ((code = (eng_rcode) new_context(&state.download.context)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "Error setting up context, code=%d\n",code));
    state.download.substate = downloadfailure;
    state.download.rc = code;
  }
  else
  {
    file = SetFilename(state.download.msg->ID, true);
    len = GetFileLength(file);
    state.download.ent = new entity(true, file, 0, len, ELIB_ENTITY_UNKNOWN, true);
    state.download.substate = parsing;
  }

}


/*
** ParseHeaderSlice() is called on null events while parsinghdr
** substate is active. It time-slices the call to EmailLib
** to parse the header.
*/

void ParseHeaderSlice(void)
{

  clock_t t = clock();
  
  ELib_rcode code = state.download.ent->ParseData(state.download.context, t + 25);
  if (code < 0)
  {
    /* error has occurred during parsing */
    dprintf(("Eng", "Error while parsing\n"));
    state.download.substate = downloadfailure;
    state.download.rc = (eng_rcode) code;
  }
  else if (code != ELIB_RUNNING)
  {
    /* parsing has finished */
    state.download.substate = parsedone;
  }
  else
    dprintf(("Eng", "Parsing a slice\n"));
  
}


/*
** FinishParseHeader() puts the required header info into the
** message descriptor once EmailLib has parsed the header.
** It then moves on to the next header.
*/

void FinishParseHeader(void)
{

  eng_rcode code;
  char *file;
  bool errorflag = false;
  MessageDescriptor *msg = state.download.msg;

  dprintf(("Eng", "Finished parsing header for message %d\n",msg->ID));
  /* get headers into descriptor */
  headers *hdrs = state.download.ent->GetHdrs();
  dprintf(("Eng", "About to get From\n"));
  if ((code = GetHeader(&msg->from, hdrs, ELIB_HDR_FROM)) < 0)
  {
    errorflag = true;
    state.download.rc = code;
  }
  else
    dprintf(("Eng", "From = %s\n",msg->from));
  dprintf(("Eng", "About to get Subject\n"));
  if ((code = GetHeader(&msg->subject, hdrs, ELIB_HDR_SUBJECT)) < 0)
  {
    errorflag = true;
    state.download.rc = code;
  }
  else
    dprintf(("Eng", "Subject = %s\n",(msg->subject) ? msg->subject : "none"));
  dprintf(("Eng", "About to get Date\n"));
  if ((code = GetDate(&msg->datestruct, hdrs, ELIB_HDR_DATE)) < 0)
  {
    errorflag = true;
    state.download.rc = code;
  }
  else
    dprintf(("Eng", "Time is %s\n",asctime(msg->datestruct)));

  /* clean up */
  destroy_context(&state.download.context);
  delete state.download.ent;
  file = SetFilename(msg->ID, true);
  UnlockFile(msg->ID, true);
  remove(file);
  if (errorflag)
    state.download.substate = downloadfailure;
  else
  {
    state.download.msg = msg->next;
    state.download.substate = readytodownload;
    msg->flags &= ~NEWLYCREATED;
  }

}


eng_rcode GetRFC822Body(rfc822msg *rfc, MessageDescriptor *msgptr)
{

  EntityDescriptor *e = NewEntity(msgptr);
  dprintf(("Eng", "Content type is not multipart\n"));
  if (e == 0)
  {
    /* wasn't enough memory */
    return ENG_NOSPACEFORMSG;
  }

  e->ent = (entity *) rfc;

  return ENG_COMPLETED;
}


eng_rcode ParseMime(MIMEentity *ent, MessageDescriptor *msgptr)
{

  eng_rcode code = ENG_COMPLETED;
  ELIB_CT major_content_type;
  int num = 1;

  dprintf(("Eng", "Entering ParseMime()\n"));
  ent->GetMajorType(major_content_type);
  dprintf(("Eng", "major content type = %d\n",major_content_type));
  if (major_content_type == ELIB_CT_MULTIPART)
  {
    MIMEmultip *multipart;
    int current = 0;
    dprintf(("Eng", "Content type is multipart\n"));
    multipart = (MIMEmultip*) ent;
    num = multipart->GetNumEntities();
    dprintf(("Eng", "Number of entities = %d\n",num));
    while ((current < num) && (code >= 0))
      code = ParseMime(multipart->GetEntity(current++), msgptr);
  }
  else if (num)
  {
    /* Create an entity descriptor for the entity */
    EntityDescriptor *e = NewEntity(msgptr);
    dprintf(("Eng", "Content type is not multipart\n"));
    if (e == 0)
    {
      /* wasn't enough memory */
      return ENG_NOSPACEFORMSG;
    }

    headers *hdrs = ent->GetHdrs();
    e->ent = (entity *) ent;
    code = GetHeader(&e->typestr, hdrs, ELIB_HDR_CONTENT_TYPE);

    dprintf(("Eng", "Number of entities in message = %d\n",msgptr->entity_num));
    /*
    ** If charset for message is not already set,
    ** set it to this entity's charset if it has one.
    */

    if (!msgptr->charset)
    {
/*     code = GetHeader(&e->charset, hdrs, ELIB_HDR_CHARSET); */
      if (e->charset)
        msgptr->charset = e->charset;
    }
  }

  return code;
}


void StartParseMessage(void)
{

  int len;
  char *file;
  eng_rcode code;

  if ((code = (eng_rcode) new_context(&state.retrieve.context)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "Error creating new context\n"));
    state.retrieve.substate = downloadfailure;
    state.retrieve.rc = code;
  }
  else
  {
    file = SetFilename(state.retrieve.msg->ID, false);
    len = GetFileLength(file);
    state.retrieve.rfc = new rfc822msg(true, file, 0, len, true);
    state.retrieve.substate = parsing;
    dprintf(("Eng", "About to parse message %d\n",state.retrieve.msg->ID));
  }
}


void ParseMessageSlice(void)
{

  clock_t t = clock();
  
  ELib_rcode code = state.retrieve.rfc->ParseData(state.retrieve.context, t + 25);
  if (code < 0)
  {
    /* error has occurred during parsing */
    dprintf(("Eng", "Error in parsing, rc=%d\n",code));
    state.retrieve.substate = downloadfailure;
    state.retrieve.rc = (eng_rcode) code;
  }
  else if (code != ELIB_RUNNING)
  {
    /* parsing has finished */
    dprintf(("Eng", "Parsing done\n"));
    state.retrieve.substate = parsedone;
  }
  else
    dprintf(("Eng", "Still parsing\n"));

}


void FinishParseMessage(void)
{

  eng_rcode code;
  MIMEentity *ent = state.retrieve.rfc->GetMIMEentity();
  MessageDescriptor *msg = state.retrieve.msg;
  headers *hdrs = state.retrieve.rfc->GetHdrs();

  dprintf(("Eng", "Entering FinishParseMessage(), ent=0x%x\n",ent));
  msg->entity_num = 0;
  msg->entity_list = 0;
  msg->elibobj = state.retrieve.rfc;

  /* get remaining headers */
  if ((code = GetHeader(&msg->to, hdrs, ELIB_HDR_TO)) < 0)
    state.retrieve.rc = code;
  else
    dprintf(("Eng", "To = %s\n",msg->to));

#ifdef gorilla
  /* to be added when CC and charset are handled by Elib */
  if ((code = GetHeader(&msg->cc, hdrs, ELIB_HDR_CC)) < 0)
  {
    errorflag = true;
    state.retrieve.rc = code;
  }
  else
    dprintf(("Eng", "CC = %s\n",msg->cc));

  if ((code = GetHeader(&msg->charset, hdrs, ELIB_HDR_CHARSET)) < 0)
    state.retrieve.rc = code;
  else
    dprintf(("Eng", "charset = %s\n",msg->charset));
#endif

  if ((code = GetHeader(&msg->datestr, hdrs, ELIB_HDR_DATE)) < 0)
    state.retrieve.rc = code;
  else
    dprintf(("Eng", "Date = %s\n",msg->datestr));

  if (ent == NULL)
    code = (eng_rcode) GetRFC822Body(state.retrieve.rfc, msg);
  else
    code = ParseMime(ent, msg);

  if (code >= 0)
  {
    /* if descriptor doesn't now have a charset, set a default */
    if (!msg->charset)
    {
      if ((msg->charset = malloc(9)) == 0)
        code = ENG_NOSPACEFORMSG;
      else
        strcpy(msg->charset, "us-ascii");
    }
  }

  /* clean up */
  destroy_context(&state.retrieve.context);

  if (code < 0)
  {
    state.retrieve.rc = code;
    state.retrieve.substate = downloadfailure;
  }

  else if (state.disconnectpending)
  {
    state.state &= ~(RETRIEVEMSG + DOWNLOADMSG);
    DisconnectFromISP();
  }

  else
    state.retrieve.substate = finished;

}


void WriteOutSlice(void)
{

  clock_t t = clock();
  
  ELib_rcode code = state.retrieve.msgbody->WriteOut(state.retrieve.context, t + 25, state.retrieve.file);
  dprintf(("Eng", "Entering WriteOutSlice\n"));
  if (code < 0)
  {
    /* error has occurred during writing out */
    dprintf(("Eng", "Error while writing out body\n"));
    (*callbacklist.getentfunc)(ENG_CANTFETCHENT, 0, callbacklist.getenthandle);
    state.state &= ~RETRIEVEENT;
  }
  else if (code != ELIB_RUNNING)
  {
    /* writing out has finished */
    dprintf(("Eng", "Finished writing out body\n"));
    state.state &= ~RETRIEVEENT;
    fclose(state.retrieve.file);
    (*callbacklist.getentfunc)(ENG_COMPLETED, state.retrieve.ent, callbacklist.getenthandle);
  }

  else
  {
    dprintf(("Eng", "Writing out entity body\n"));
  }

}


void StartRetrieve(void)
{

  eng_rcode code;

  if ((code = (eng_rcode) new_context(&state.retrieve.context)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "Error creating new context\n"));
    (*callbacklist.getentfunc)(ENG_CANTFETCHENT, 0, callbacklist.getenthandle);
  }

  else
  {
    state.state |= RETRIEVEENT;
    dprintf(("Eng", "Starting to retrieve attachment\n"));
    state.retrieve.file = fopen(callbacklist.getentfile, "w");
    state.retrieve.msgbody = state.retrieve.ent->ent->GetBody();
  }

}


void DoCreateMessage(void)
{

  switch (state.create.substate)
  {
    case readytocreate :

      dprintf(("Eng", "Substate is readytocreate\n"));
      if (state.state & CREATE)
      {
        state.state &= ~CREATE;
        dprintf(("Eng", "Calling back UI with new message %d\n",state.create.msg->ID));
        (*callbacklist.createfunc)(ENG_COMPLETED, state.create.msg, callbacklist.createhandle);
      }

      else
      {
        /* get EmailLib to parse the message and return a reply
           correctly formatted */
        dprintf(("Eng", "Asking EmailLib to prepare reply\n"));
        state.create.substate = readytoparse;
      }

      break;

    case readytoparse :

      break;
  }

}


void DoSend(void)
{

  MessageDescriptor *msg = state.send.msg;
  ELib_rcode code;

  switch (state.send.substate)
  {
    case readytoparse :
    {
      rfc822msg *rfc = new rfc822msg(true, 0, 0, 0, false);
      headers *hdrs = rfc->GetHdrs();
/*       header *tohdr = new header(false, msg->to, 0, strlen(msg->to) + 1, ELIB_HDR_TO, false); */
/*       header *subhdr = new header(false, msg->subject, 0, strlen(msg->subject) + 1, ELIB_HDR_SUBJECT, false); */
      to tohdr(false, msg->to, 0, strlen(msg->to) + 1, false);
      subject subhdr(false, msg->subject, 0, strlen(msg->subject) + 1, false);

      int len = GetFileLength(state.send.fname);
      body *msgbody = new body(true, state.send.fname, 0, len, ELIB_TE_UNKNOWN, false);
      FILE *f = fopen("NCMailStore:SendTemp", "w");

      dprintf(("", "New RFC822 created at 0x%x, headers at 0x%x\n",rfc,hdrs));      
dprintf(("", "About to parse new message body in file %s\n",state.send.fname));
      if ((code = new_context(&state.send.context)) < 0)
      {
        /* error setting up context */
       dprintf(("Eng", "Error setting up context, code=%d\n",code));
      }
      else
      {
        clock_t t = clock();
        msgbody->ParseData(state.send.context, t + 500);
        dprintf(("", "Message body parsed\n"));
        code = hdrs->AddHdr(tohdr);
        dprintf(("Eng", "Added To header, rc=%d\n",code));
        code = hdrs->AddHdr(subhdr);
        dprintf(("Eng", "Added Subject header, rc=%d\n",code));
        code = rfc->ReplaceBody(msgbody);
        dprintf(("Eng", "Added body, rc=%d\n",code));

        code = rfc->WriteOut(state.send.context, 0, f);
        dprintf(("Eng", "Writing out file\n"));
        fclose(f);
      }
      state.state &= ~SEND;
      break;
    }
  }

}
