#define RDW_SPEEDUP_HACK 1
/*
** Email Client
** EmailLib interface
*/

#include "stdlib.h"
#include "time.h"
#include "string.h"
#include "ctype.h"
#include "swis.h"

#include "DebugLib/DebugLib.h"

#include "Email/EmailLib/rfc822msg.h"
#include "Email/EmailLib/MIMEentity.h"
#include "Email/EmailLib/MIMEtext.h"
#include "Email/EmailLib/MIMEmultip.h"
#include "Email/EmailLib/date.h"
#include "Email/EmailLib/entity.h"
#include "Email/EmailLib/to.h"
#include "Email/EmailLib/subject.h"
#include "Email/EmailLib/body.h"
#include "Email/EmailLib/ELib.h"
#include "Email/EmailLib/from.h"

#include "Email/Mailbox/SendQ/SendQMailbox.h"

#include "engtypes.h"
#include "engmanager.h"
#include "engfile.h"
#include "engdownld.h"
#include "engstr.h"
#include "enguiapi.h"
#include "enginit.h"
#include "engprocess.h"

#ifdef RDW_SPEEDUP_HACK
static char *rdw_tmp = 0;
#endif
static char scrapf1[] = "<Wimp$ScrapDir>.TempBody";
static char scrapf2[] = "<Wimp$ScrapDir>.TempMime";

eng_rcode FinishParseMessage(MessageDescriptor *msgptr);

eng_rcode GetHeader(char **dest, headers *hdrs, ELIB_HDR_TYPE type)
{

  ELib_rcode code;
  uint32 len;
  char *ptr;

  *dest = 0;
  header *h = hdrs->FindHdr(type);
  if (h)
  {
    code = h->GetBodyLen(len);
/*     dprintf(("Eng", "Got BodyLen, len=%d, code=%d\n",len,code)); */
    if (code < 0)
      return (eng_rcode) code;
    else if (!len)
      return ENG_COMPLETED;

    ++len;
    if ((ptr = malloc(len + 1)) == 0)
    {
      dprintf(("Eng", "Malloc failure\n"));
      return ENG_NOSPACEFORMSG;
    }

    code = h->GetUnfoldedNoCommentsBody(ptr, len);
/*     dprintf(("Eng", "Got Body, len=%d, code=%d\n",len,code)); */
    if (code < 0)
      return (eng_rcode) code;

    *dest = ptr;
  }

  return ENG_COMPLETED;

}


/*
** GetDate() gets a date header from a message
** and puts it into a tm structure.
*/

eng_rcode GetDate(struct tm **dest, headers *hdrs, ELIB_HDR_TYPE type)
{

  ELib_rcode code;
  struct tm *tim;
  date *d;

  *dest = 0;
  if ((tim = (struct tm *) malloc(sizeof(struct tm))) == 0)
  {
    dprintf(("Eng", "Malloc failure\n"));
    return ENG_NOSPACEFORMSG;
  }

  d = (date *) hdrs->FindHdr(type);
  if (d)
  {
    code = d->GetDate(*tim);
    if (code < 0)
    {
      dprintf(("Eng", "Error getting date, code=%d\n",code));
      return (eng_rcode) code;
    }

    *dest = tim;
  }

  return ENG_COMPLETED;

}


void CleanUpParse(void)
{
#ifdef RDW_SPEEDUP_HACK
  if (rdw_tmp)
    delete[] rdw_tmp;
  rdw_tmp = 0;
#endif
  char *file;

  /* clean up */
  destroy_context(&state.download.context);
  delete state.download.ent;
  file = SetFilename(state.download.msg->ID, true);
  UnlockFile(file);
  remove(file);

}


/*
** StartParseHeader() starts off the process of parsing a header.
** It creates a context and an entity in a temporary file.
*/

void StartParseHeader(void)
{

  uint32 len;
  char *file;
  eng_rcode code;

  if ((code = (eng_rcode) new_context(&state.download.context)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "Error setting up context, code=%d\n",code));
    state.download.substate = downloadfailure;
    state.download.rc = code;
  }
  else
  {
    file = SetFilename(state.download.msg->ID, true);
    len = GetFileLength(file);

#ifdef RDW_SPEEDUP_HACK
    rdw_tmp = new char[len+1];
    FILE* rdw_fd = fopen(file, "rb");
    if (rdw_fd)
    {
      fread(rdw_tmp, 1, len, rdw_fd);
      fclose(rdw_fd);
      state.download.ent = new entity(false, rdw_tmp, 0, len);
    }
    else
      state.download.ent = 0;
#else
    state.download.ent = new entity(true, file, 0, len, ELIB_ENTITY_UNKNOWN, true);
#endif
    if (state.download.ent == 0)
      CleanUpParse();
    else
      state.download.substate = parsing;
  }

}


/*
** ParseHeaderSlice() is called on null events while parsinghdr
** substate is active. It time-slices the call to EmailLib
** to parse the header.
*/

void ParseHeaderSlice(void)
{

  clock_t t = clock();

  ELib_rcode code = state.download.ent->ParseData(state.download.context, t + 25);
  if (code < 0)
  {
    /* error has occurred during parsing */
    dprintf(("Eng", "Error while parsing\n"));
    CleanUpParse();
    state.download.substate = downloadfailure;
    state.download.rc = (eng_rcode) code;
  }
  else if (code != ELIB_RUNNING)
  {
    /* parsing has finished */
    state.download.substate = parsedone;
  }
  else
    dprintf(("Eng", "Parsing a slice\n"));

}


/*
** FinishParseHeader() puts the required header info into the
** message descriptor once EmailLib has parsed the header.
** It then moves on to the next header.
*/

void FinishParseHeader(void)
{

  eng_rcode code;
  uint32 len = 0;
  MessageDescriptor *msg = state.download.msg;

  dprintf(("Eng", "Finished parsing header for message %d\n",msg->ID));
  /* get headers into descriptor */
  headers *hdrs = state.download.ent->GetHdrs();
  from *h = (from *) hdrs->FindHdr(ELIB_HDR_FROM);

  state.download.rc = ENG_COMPLETED;
  if (!h)
    state.download.substate = downloadfailure;
  else
  {
    code = (eng_rcode) h->GetRealName(0, len);
    if (len)
    {
      if ((msg->fromreal = malloc(len + 1)) == 0)
      {
        state.download.rc = ENG_NOSPACEFORMSG;
        state.download.substate = downloadfailure;
      }
      else
      {
        code = (eng_rcode) h->GetRealName(msg->fromreal, len);
        dprintf(("Eng", "From Realname = %s\n",msg->fromreal));
      }
    }

    len = 0;
    code = (eng_rcode) h->GetAddress(0, len);
    if ((!len) && (!msg->fromreal))
      state.download.substate = downloadfailure;
    else if (len)
    {
      if ((msg->fromaddr = malloc(len + 1)) == 0)
      {
        state.download.rc = ENG_NOSPACEFORMSG;
        state.download.substate = downloadfailure;
      }
      else
      {
        code = (eng_rcode) h->GetAddress(msg->fromaddr, len);
        dprintf(("Eng", "From Address = %s\n",msg->fromaddr));
      }
    }
  }
  if ((!msg->fromaddr) && (!msg->fromreal))
    state.download.substate = downloadfailure;

  dprintf(("Eng", "About to get Subject\n"));
  if ((code = GetHeader(&msg->subject, hdrs, ELIB_HDR_SUBJECT)) < 0)
  {
    state.download.substate = downloadfailure;
    state.download.rc = code;
  }
  else
    dprintf(("Eng", "Subject = %s\n",(msg->subject) ? msg->subject : "none"));
  dprintf(("Eng", "About to get Date\n"));
  if ((code = GetDate(&msg->datestruct, hdrs, ELIB_HDR_DATE)) < 0)
  {
    state.download.substate = downloadfailure;
    state.download.rc = code;
  }
  else
    dprintf(("Eng", "Time is %s\n",asctime(msg->datestruct)));

  CleanUpParse();
  if (state.download.substate != downloadfailure)
  {
    state.download.msg = msg->next;
    state.download.substate = readytodownload;
    msg->flags &= ~(NEWLYCREATED + ERROR);
  }

}


eng_rcode GetRFC822Body(rfc822msg *rfc, MessageDescriptor *msgptr)
{

  EntityDescriptor *e = NewEntity(msgptr);
  dprintf(("Eng", "Content type is not multipart\n"));
  if (e == 0)
  {
    /* wasn't enough memory */
    return ENG_NOSPACEFORMSG;
  }

  e->ent = (entity *) rfc;
  e->flags |= ENTITY_OK;

  return ENG_COMPLETED;
}


eng_rcode ParseMime(MIMEentity *ent, MessageDescriptor *msgptr)
{

  eng_rcode code = ENG_COMPLETED;
  ELIB_CT contenttype;
  int num = 1;

  dprintf(("Eng", "Entering ParseMime()\n"));
  ent->GetMajorType(contenttype);
  dprintf(("Eng", "major content type = %d\n",contenttype));
  if (contenttype == ELIB_CT_MULTIPART)
  {
    MIMEmultip *multipart;
    int current = 0;
    dprintf(("Eng", "Content type is multipart\n"));
    multipart = (MIMEmultip*) ent;
    num = multipart->GetNumEntities();
    dprintf(("Eng", "Number of entities = %d\n",num));
    while ((current < num) && (code >= 0))
      code = ParseMime(multipart->GetEntity(current++), msgptr);
  }
  else if (num)
  {
    /* Create an entity descriptor for the entity */
    EntityDescriptor *e = NewEntity(msgptr);
    dprintf(("Eng", "Content type is not multipart\n"));
    if (e == 0)
    {
      /* wasn't enough memory */
      return ENG_NOSPACEFORMSG;
    }

    headers *hdrs = ent->GetHdrs();
    e->ent = (entity *) ent;
    if ((code = GetHeader(&e->typestr, hdrs, ELIB_HDR_CONTENT_TYPE)) == ENG_NOSPACEFORMSG)
      return code;

    dprintf(("Eng", "Number of entities in message = %d\n",msgptr->entity_num));
    /*
    ** If charset for message is not already set,
    ** set it to this entity's charset if it has one.
    */

    if (!msgptr->charset)
    {
#ifdef gorilla
      if ((code = GetHeader(&e->charset, hdrs, ELIB_HDR_CHARSET) == ENG_NOSPACEFORMSG)
        return code;
#endif
      if (e->charset)
        msgptr->charset = e->charset;
    }

    /* Set entity flags according to content type */

    switch (contenttype)
    {
      case ELIB_CT_TEXT :
      case ELIB_CT_MESSAGE :

        dprintf(("Eng", "Setting entity flags to OK\n"));
        e->flags |= ENTITY_OK;
        break;

      case ELIB_CT_APPLICATION :
      case ELIB_CT_MODEL :
      case ELIB_CT_UNKNOWN :

        dprintf(("Eng", "Setting entity flags to BEST\n"));
        e->flags |= ENTITY_BEST;
        break;

      default :

        dprintf(("Eng", "Setting entity flags to NOT_OK\n"));
        e->flags |= ENTITY_NOT_OK;
        break;
    }
  }

  return code;
}


void StartParseMessage(void)
{

  int len;
  char *file;
  eng_rcode code;

  if ((code = (eng_rcode) new_context(&state.retrieve.context)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "Error creating new context\n"));
    state.retrieve.substate = downloadfailure;
    state.retrieve.rc = code;
  }
  else
  {
    file = SetFilename(state.retrieve.msg->ID, false);
    len = GetFileLength(file);
    state.retrieve.rfc = new rfc822msg(true, file, 0, len, true);
    if (!state.retrieve.rfc)
      state.retrieve.substate = downloadfailure;
    else
    {
      state.retrieve.substate = parsing;
      dprintf(("Eng", "About to parse message %d\n",state.retrieve.msg->ID));
    }
  }
}


void ParseMessageSlice(void)
{

  clock_t t = clock();

  ELib_rcode code = state.retrieve.rfc->ParseData(state.retrieve.context, t + 25);
  if (code < 0)
  {
    /* error has occurred during parsing */
    dprintf(("Eng", "Error in parsing, rc=%d\n",code));
    state.retrieve.substate = downloadfailure;
    state.retrieve.rc = (eng_rcode) code;
  }
  else if (code != ELIB_RUNNING)
  {
    /* parsing has finished */
    dprintf(("Eng", "Parsing done\n"));
    state.retrieve.substate = parsedone;
  }
  else
    dprintf(("Eng", "Still parsing\n"));

}


void FinishParseMessage(void)
{

  eng_rcode code;
  MIMEentity *ent = state.retrieve.rfc->GetMIMEentity();
  MessageDescriptor *msg = state.retrieve.msg;
  headers *hdrs = state.retrieve.rfc->GetHdrs();

  dprintf(("Eng", "Entering FinishParseMessage(), ent=0x%x\n",ent));
  msg->entity_num = 0;
  msg->entity_list = 0;
  msg->elibobj = state.retrieve.rfc;

  /* get remaining headers */
  if ((code = GetHeader(&msg->to, hdrs, ELIB_HDR_TO)) == ENG_NOSPACEFORMSG)
    state.retrieve.rc = code;
  else if (code >= 0)
    dprintf(("Eng", "To = %s\n",msg->to));

  if ((code = GetHeader(&msg->cc, hdrs, ELIB_HDR_CC)) == ENG_NOSPACEFORMSG)
  {
    state.retrieve.rc = code;
  }
  else if (code >= 0)
    dprintf(("Eng", "CC = %s\n",msg->cc));

#ifdef gorilla
  /* to be added when charset is handled by Elib */
  if ((code = GetHeader(&msg->charset, hdrs, ELIB_HDR_CHARSET)) == ENG_NOSPACEFORMSG)
    state.retrieve.rc = code;
  else if (code >= 0)
    dprintf(("Eng", "charset = %s\n",msg->charset));
#endif

  if ((code = GetHeader(&msg->datestr, hdrs, ELIB_HDR_DATE)) == ENG_NOSPACEFORMSG)
    state.retrieve.rc = code;
  else if (code >= 0)
    dprintf(("Eng", "Date = %s\n",msg->datestr));

  if (ent == NULL)
    code = (eng_rcode) GetRFC822Body(state.retrieve.rfc, msg);
  else
    code = ParseMime(ent, msg);

  if (code >= 0)
  {
    /* if descriptor doesn't now have a charset, set a default */
    if (!msg->charset)
    {
      if ((msg->charset = malloc(9)) == 0)
        code = ENG_NOSPACEFORMSG;
      else
        strcpy(msg->charset, "us-ascii");
    }
  }

  /* clean up */
  destroy_context(&state.retrieve.context);

  if (code < 0)
  {
    state.retrieve.rc = code;
    state.retrieve.substate = downloadfailure;
  }

  else
  {
    state.retrieve.ent = msg->entity_list;
    state.retrieve.substate = readytowrite;
  }

}


void WriteOutSlice(void)
{

  clock_t t = clock();
  ELib_rcode code;

  dprintf(("Eng", "Entering WriteOutSlice\n"));
  if (state.retrieve.enc == 0)
    code = state.retrieve.msgbody->WriteOut(state.retrieve.context, t + 25, state.retrieve.file);
  else
    code = state.retrieve.msgbody->RemoveEncoding(state.retrieve.context, t + 25, "", state.retrieve.file, 0x1000);

  if (code < 0)
  {
    /* error has occurred during writing out */
    dprintf(("Eng", "Error while writing out body\n"));
    state.retrieve.substate = writefailure;
    state.retrieve.ent->flags = ENTITY_NOT_OK;
  }
  else if (code != ELIB_RUNNING)
  {
    /* writing out has finished */
    dprintf(("Eng", "Finished writing out body\n"));
    state.retrieve.substate = writedone;
  }

  else
  {
    dprintf(("Eng", "Writing out entity body\n"));
  }

}


void StartRetrieve(void)
{

  eng_rcode code;

  if ((code = (eng_rcode) new_context(&state.retrieve.context)) < 0)
  {
    /* error setting up context */
    dprintf(("Eng", "Error creating new context\n"));
    state.retrieve.substate = writefailure;
  }

  else
  {
    state.retrieve.file = fopen(state.retrieve.ent->fname, "w");
    state.retrieve.msgbody = state.retrieve.ent->ent->GetBody();
    state.retrieve.ent->ent->GetEncoding(state.retrieve.enc);
    dprintf(("Eng", "Encoding for entity = %d\n",state.retrieve.enc));
    state.retrieve.substate = writing;
  }

}


void AssembleMessage(MessageDescriptor *msg)
{

  ELib_rcode code;

  MIMEtext *ent = new MIMEtext(true, scrapf2, 0, 0, ELIB_CT_TEXT_PLAIN, true);
  if (!ent)
  {
    state.send.substate = parsefailure;
    return;
  }

  code = ent->ReplaceBody(state.send.msgbody);
  if (code < 0)
  {
    state.send.substate = parsefailure;
    return;
  }

  to tohdr(false, 0, 0, 0, true);
  subject *subhdr = new subject(false, 0, 0, 0, true);
  from fromhdr(false, 0, 0, 0, true);

  tohdr.SetAddress(msg->to);
  fromhdr.SetRealName(realname);
  fromhdr.SetAddress(emailaddr);

  rfc822msg *rfc = new rfc822msg(true, 0, 0, 0, true);
  if (!rfc)
  {
    state.send.substate = parsefailure;
    return;
  }

  headers *hdrs = rfc->GetHdrs();
  code = rfc->SetTo(tohdr);
  if (code >= 0)
    code = rfc->SetFrom(fromhdr);
  if (code < 0)
  {
    state.send.substate = parsefailure;
    return;
  }

  code = subhdr->SetBody(msg->subject);
  if (code >= 0)
    code = hdrs->AddHdr(*subhdr);
  if (code < 0)
  {
    delete subhdr;
    state.send.substate = parsefailure;
    return;
  }

  state.send.file = fopen(SetFilename(msg->ID, true), "w");
  dprintf(("Eng", "File handle for writing out is %d\n",state.send.file));
  *rfc += *ent;
  state.send.rfc = rfc;
  state.send.substate = readytowrite;

}


void DoCreateMessage(void)
{

  switch (state.create.substate)
  {
    case readytocreate :

      dprintf(("Eng", "Create substate is readytocreate\n"));
      if (state.state & CREATE)
      {
        state.state &= ~CREATE;
        dprintf(("Eng", "Calling back UI with new message %d\n",state.create.msg->ID));
        (*callbacklist.createfunc)(ENG_COMPLETED, state.create.msg, callbacklist.createhandle);
      }

      else
      {
        /* get EmailLib to parse the message and return a reply
           correctly formatted */
        dprintf(("Eng", "Asking EmailLib to prepare reply\n"));
        state.create.substate = readytoparse;
      }

      break;

    case readytoparse :

      dprintf(("Eng", "Create substate is readytoparse\n"));
      break;
  }

}


void DoSend(void)
{

  MessageDescriptor *msg = state.send.msg;
  ELib_rcode code;

  switch (state.send.substate)
  {
    case readytoparse :

      dprintf(("Eng", "Send substate is readytoparse\n"));
      if ((code = new_context(&state.send.context)) < 0)
      {
        /* error setting up context */
       dprintf(("Eng", "Error setting up context, code=%d\n",code));
       state.send.substate = parsefailure;
      }
      else
      {
        uint32 len = GetFileLength(state.send.bodyname);
        state.send.msgbody = new body(true, state.send.bodyname, 0, len, ELIB_TE_NONE, true);
        state.send.substate = readytoencode;
      }

      break;

    case parsefailure :

      /* creation of new message has failed */
      dprintf(("Eng", "Send substate is parsefailure\n"));
      break;

    case readytoencode :

      dprintf(("Eng", "Send substate is readytoencode\n"));
      code = state.send.msgbody->ApplyEncoding(state.send.context, clock() + 25, ELIB_TE_7BIT, scrapf1, 0x1000);
      if (code < 0)
        state.send.substate = parsefailure;
      else if (code != ELIB_RUNNING)
        state.send.substate = encoded;

      break;

    case encoded :

      dprintf(("Eng", "Send substate is encoded\n"));
      AssembleMessage(msg);
      break;

    case readytowrite :

      dprintf(("Eng", "Send substate is readytowrite\n"));
      code = state.send.rfc->WriteOut(state.send.context, clock() + 25, state.send.file);
      dprintf(("Eng", "Writing out file\n"));
      if (code < 0)
        state.send.substate = parsefailure;
      else if (code != ELIB_RUNNING)
        state.send.substate = writedone;

    case writedone :

      dprintf(("Eng", "Send substate is writedone\n"));
      fclose(state.send.file);
      LockFile(SetFilename(msg->ID, true));
      remove(scrapf2);

      state.state &= ~SEND;
      SendMessage();
      dprintf(("Eng", "Removing scrapfile %ssuccessfully\n",(remove(scrapf1)) ? "un" : ""));

      break;
  }

}
