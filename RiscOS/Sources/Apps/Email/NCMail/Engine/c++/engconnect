/*
** Email Engine
** Connect and disconnect routines
*/

#include "Email/NetLink/NetLink.h"
#include "Email/NetLink/Permanent.h"
#include "Email/NetLink/NCDial.h"

#include "Email/Common/bool.h"
#include "Email/Common/types.h"

#include "DebugLib/DebugLib.h"

#include "tboxlibs/toolbox.h"

#include "engmanager.h"
#include "engprocess.h"
#include "engtimers.h"
#include "enguser.h"
#include "engcbf.h"
#include "engconnect.h"
#include "enginit.h"
#include "engstr.h"

extern "C"
{
  #include "../Build/NCMailUI.h"
}

bool online, disconnectpending;

static NetLink *netlink;
const int NCAccessManager_MiscOp = 0x0004f001;

void ConnectToISP(void)
{

  ELib_rcode code;

  state |= CONNECT;
  /* Request NetLink Cntrl to bring link up. */
  code = netlink->Connect();

}


void DisconnectLine(void)
{

  /* disconnect from mail servers before taking line down */

  if (!(state & DISCONNECT))
  {
    dprintf(("Eng", "About to disconnect line, state = 0x%x\n",state));
    state |= (PROCESSPOP + PROCESSSMTP + DISCONNECT);
    smtpprocessstate.context = readytodisconnect;
    popprocessstate.context = readytodisconnect;
  }

}


void DisconnectServer(void)
{

  /* disconnect from POP3 server without taking line down */

  if ((!popactive) && (!(state & MARKDELETE)))
  {
    dprintf(("Eng", "About to disconnect server, state = 0x%x\n",state));
    state |= (PROCESSPOP + TIMEOUT);
    popprocessstate.context = readytodisconnect;
  }

}


void DisconnectFromISP(void)
{

  ELib_rcode code;

  dprintf(("Eng", "Disconnecting from ISP\n"));
  /*
  ** Mail servers have now been disconnected,
  ** so request NetLink Cntrl to take link down.
  */
  code = netlink->Disconnect();

}


void DisconnectPending(void)
{

  if (changepending)
    DisconnectServer();
  else
    DisconnectLine();

}


/*
** LineChange() is a callback function for NetLink.
** It is called whenever a change in the status of the link is reported.
*/

void LineChange(NetLink::Status status, void *h)
{

  (void)(h);

  switch (status)
  {
    case NetLink::Disconnected :

      dprintf(("Eng", "Receiving NetLink callback - disconnected\n"));
      online = false;
      disconnectpending = false;
      state &= ~(CONNECT + DISCONNECT);

      POPaccount->SetConnectionState(false);
      SMTPaccount->SetConnectionState(false);

      /* notify UI of line state */
      ncmui_line_state(false);

      /* stop all countdowns */
      popactive = false;
      StopTimeoutCount();
      StopReconnectCount();
      StopRetryCount();

      if (changepending)
        NewUser();

      if (state & PREQUIT)
      {
        /* reinstate the shutdown process */
        RestartPreQuit();
      }
      break;

    case NetLink::Connecting :

      dprintf(("Eng", "Receiving NetLink callback - connecting\n"));
      /************************************
      *** ATTENTION
      ************************************/
      /* are we going to report to UI here? */
      break;

    case NetLink::Connected :

      dprintf(("Eng", "Receiving NetLink callback - connected\n"));
      online = true;

      /* notify UI of line state */
      ncmui_line_state(true);

      /* notify account objects of line state */
      POPaccount->SetConnectionState(true);
      SMTPaccount->SetConnectionState(true);

      state &= ~(CONNECT + DISCONNECT);
      if (state & PREQUIT)
      {
        state &= ~PREQUIT;
        StartOffSMTP();
      }
      else if (state & RETRIEVEMSG)
        retrievestate.context = readytoconnect;
      else if (emailactive)
        StartProcess();
      break;

    case NetLink::Error :

      dprintf(("Eng", "Receiving NetLink callback - error\n"));
      if (state & RETRIEVEMSG)
        retrievestate.context = retrievefailure;

      /* Shouldn't need the following since NetLink will report */
      /*
      statusret.code = (state & CONNECT) ? ENG_CONNECTIONFAILED : ENG_DISCONNECTFAILED;
      state &= ~(CONNECT + DISCONNECT);
      (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, 0);
      */

      break;

    case NetLink::Disconnecting :

      dprintf(("Eng", "Receiving NetLink callback - disconnecting\n"));
      /************************************
      *** ATTENTION
      ************************************/
      /* are we going to report to UI here? */
      break;
  }

}


/* ********************************************************************* */
/*
   FUNCTION:       CreateNetLink
   DESCRIPTION:    Function that interigates the system environment the app is
                   running in and creates the appropriate concrete NetLink
                   object and returns it.

                   Currently, this means it calls NCMALite to get the
                   information and defaults to Ethernet/Permanent connection.

   DEPENDENCIES:   constant		NCAccessManager_MiscOp	enginit.c++
                   type			_kernel_swi_regs	kernel.h
                   type			_kernel_oserror		kernel.h
                   class		NetLink			Email/NetLink/NetLink.h
                   class		NCDialNetLink		Email/NetLink/NCDial.h
                   class		PermanentNetLink	Email/NetLink/Permanent.h
   DEPENDED ON BY: function		AppInit			enginit.c++
   INPUT PARAMS:   NONE
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NetLink*					0 if malloc failure
   CONSTANTS:      NONE
   VARIABLES:      NetLink*		netlink			the NetLink object
                   bool                 modem                   flag to indicate modem version
                   _kernel_oserror*	error			error from SWI call
                   _kernel_swi_regs	r			registers for SWI call
 */
/* ********************************************************************* */

static NetLink* CreateNetLink(void)
{
  NetLink*         netlink = 0;
  bool             modem   = false;
  _kernel_oserror* error   = 0;
  _kernel_swi_regs r;

  r.r[0] = 1;									// NCMALite reason code 1, request build type
  error = _kernel_swi(NCAccessManager_MiscOp, &r, &r);				// Do SWI call

  if (error)									// If error from NCMA, or error because
  {										// SWI not handled, ie. NCMA not present, then
    dprintf(("Eng", "Error from NCAccessManager_MiscOp, errnum: %d\t errmess: %s\n", error->errnum, error->errmess));
    modem = false;								// if SWI gives an error, then assume Ethernet
  }
  else
  {
    dprintf(("Eng", "NCAccessManager_MiscOp returned in r[1]: %d\n", r.r[1]));
    if (r.r[1] == 1)								// if r1 has 1, then it's modem
      modem = true;
  }

  if (modem)
  {
    dprintf(("Eng", "Creating a NCDialNetLink\n"));
    netlink = new NCDialNetLink();
  }
  else
  {
    dprintf(("Eng", "Creating a PermanentNetLink\n"));
    netlink = new PermanentNetLink();
  }

  return netlink;
}


bool SetupNetlink(void)
{

  NetLink::Status linestatus;

  netlink = CreateNetLink();					// Create the netlink object
  if (netlink == 0)
    return false;

  linestatus = netlink->GetStatus();
  online = (linestatus == NetLink::Connected) ? true : false;
  dprintf(("Eng", "We are %sonline\n",(online) ? "" : "not "));
  netlink->RegisterCallback(LineChange, 0);

  ncmui_initialise(infobuf, online);

  return true;

}


/*
** ConfirmConnect() is called as a callback from the UI when
** the Engine has requested confirmation from the user to
** reconnect if a message on the server is requested while offline.
*/

void ConfirmConnect(bool conf, void *h)
{

  (void)(h);
  if (conf)
  {
    /* user has confirmed connection */
    dprintf(("Eng", "User has confirmed connection\n"));
    ActivatePOP();
    ConnectToISP();
  }

  else
  {
    /* Cancel RETRIEVEMSG state and clean up. */
    dprintf(("Eng", "User has not confirmed connection\n"));
    state &= ~(RETRIEVEMSG + DOWNLOADMSG);
    retrievestate.ret.code = ENG_CONNECTCANCELLED;
    (*callbacklist.getmsgfunc)(&retrievestate.ret, 0, callbacklist.getmsghandle);
  }

}
