/*
** Email Engine
** Interface to UI
*/

#include "kernel.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "swis.h"
#include "limits.h"

#include "DebugLib/DebugLib.h"
/* #include "NBLib/NBLib.h" */


#include "engtypes.h"
#include "engmanager.h"
#include "engfile.h"
#include "enginit.h"
#include "engcbf.h"
#include "engstr.h"
#include "engevent.h"
#include "enguiapi.h"
#include "enguser.h"
#include "engtimers.h"
#include "engconnect.h"

MailboxDescriptor *ourmboxin, *ourmboxout, *transmbox;

bool emailactive, expungepending = false;
uint32 popstatus;
uint32 smtpstatus;
uint32 state;
bool hdrsdownloaded, popactive = false;

POPProcessState popprocessstate;
SMTPProcessState smtpprocessstate;
DownloadState downloadstate;
ParseHdrState parsehdrstate;
SendState sendstate;
RetrieveState retrievestate;
CreateState createstate;
MarkState markstate;

eng_return statusret;

static bool wrapped = false;

static uint32 entID;
static uint32 nextID = 1;  /* Number to allocate to next message ID.
                              Wrap around to one after 99999999
                              to allow filenames of "M" + 8 chars */

bool SetupState(void)
{

  state = IDLE;
  disconnectpending = false;
  popstatus = acctnonexistent;
  smtpstatus = acctnonexistent;
  emailactive = false;
  statusret.rc = ELIB_RUNNING;
  statusret.code = ENG_RUNNING;
  statusret.flags = 0;
  retrievestate.msg = 0;
  smtpprocessstate.attempts = 0;

  if ((ourmboxin = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor))) == 0)
    return false;
  if ((ourmboxout = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor))) == 0)
    return false;
  if ((transmbox = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor))) == 0)
    return false;

  ourmboxin->total = 0;
  ourmboxin->read = 0;
  ourmboxin->answered = 0;
  ourmboxin->list = 0;
  ourmboxin->flags = DOWNLOADINCOMPLETE;
  ourmboxout->total = 0;
  ourmboxout->read = 0;
  ourmboxout->answered = 0;
  ourmboxout->list = 0;
  ourmboxout->flags = 0;
  transmbox->total = 0;
  transmbox->list = 0;

  ReadTimerValues();

  return true;

}


/*
** FindDescriptor() returns a pointer to the Message Descriptor
** for ID msg_id, or null if ID can't be found.
*/

MessageDescriptor *FindDescriptor(uint32 msg_id, MailboxDescriptor *box)
{

  if (box->list == 0)
    return 0;

  else
  {
    MessageDescriptor *nextptr = box->list;

    while ((nextptr->next) && (nextptr->ID != msg_id))
      nextptr = nextptr->next;
    return (nextptr->ID == msg_id) ? nextptr : 0;
  }

}


MessageDescriptor *NewDescriptor(MessageDescriptor *newmsg, MailboxDescriptor *box, bool owner)
{

  if (!newmsg)
  {
    if ((newmsg = (MessageDescriptor *) calloc(1, sizeof(MessageDescriptor))) == 0)
    {
      /* no memory */
      return 0;
    }
  }

  if (wrapped)
  {
    /*
    ** If message ID numbers have wrapped round,
    ** check number against existing messages to ensure
    ** no duplication.
    ** Note: this is not very likely to happen - even if a user
    ** gets 1000 emails a day, the box will still need to be
    ** on for 273 years without loss of power before the ID
    ** wraps round!
    */
    while (FindDescriptor(nextID, box))
      nextID++;
  }

  newmsg->ID = nextID++;
  dprintf(("Eng", "Creating new message descriptor with ID %d at 0x%x\n",nextID - 1,newmsg));
  if (nextID > 99999999)
  {
    nextID = 1;
    wrapped = true;
  }

  if (box)
  {
    ++box->total;
    if (box->list)
    {
      MessageDescriptor *msg = box->list;
      while (msg->next)
        msg = msg->next;
      msg->next = newmsg;
      newmsg->last = msg;
    }
    else
    {
      box->list = newmsg;
      newmsg->last = 0;
    }
  }
  else
    newmsg->last = 0;

  if (owner)
    newmsg->flags |= OWNER;

  newmsg->next = 0;

  return newmsg;

}


void DestroyDescriptor(MessageDescriptor *msg, MailboxDescriptor *box)
{

  dprintf(("Eng", "Destroying descriptor for message %d\n",msg->ID));
  
  if (box)
  {
    if ((msg->last == 0) && (msg->next == 0))
    {
      /* set descriptor list to null */
      box->list = 0;
    }

    else if (msg->last == 0)
    {
      box->list = msg->next;
      msg->next->last = 0;
    }

    else if (msg->next == 0)
      msg->last->next = 0;

    else
    {
      msg->last->next = msg->next;
      msg->next->last = msg->last;
    }

    --box->total;
  }

  /*
  ** Throw away all memory blocks reserved for bits of the message.
  ** Also destroy any EmailLib objects, delete files etc.
  */

  SetFilename(msg->ID, false);
  UnlockFile(msgfilename);
  remove(msgfilename);
  RemoveEntities(msg);
  if ((msg->elibobj) && (msg->flags & OWNER))
  {
    delete msg->elibobj;
    msg->elibobj = 0;
  }
  free(msg->datestruct);
  free(msg->datestr);
  free(msg->subject);
  free(msg->cc);
  free(msg->fromreal);
  free(msg->fromaddr);
  free(msg->to);

  free(msg);
  
}


void RemoveEntities(MessageDescriptor *msg)
{

  EntityDescriptor *ent, *thisent;

  dprintf(("Eng", "Entering RemoveEntities for message %d\n",msg->ID));
  ent = msg->entity_list;
  while (ent)
  {
    thisent = ent;
    free(ent->typestr);
    free(ent->charset);
    if (ent->flags & ENTITY_RFC822)
      DestroyDescriptor(ent->data.msg, 0);
    else
    {
      UnlockFile(ent->data.fname);
      free(ent->data.fname);
    }
    ent = ent->next;
    free(thisent);
    /* entity object in ELib will have been removed when
       deleting msg->elibobj so doesn't need to be done here */
  }
  msg->entity_num = 0;
  msg->entity_list = 0;
}


EntityDescriptor *NewEntity(MessageDescriptor *msg, enttype t)
{

  EntityDescriptor *e = 0, *newent = (EntityDescriptor *) calloc(1, sizeof(EntityDescriptor));

  if (newent == 0)
  {
    /* not enough memory */
    dprintf(("Eng", "***ERROR*** Not enough memory for new entity descriptor\n"));
    return 0;
  }

  newent->ID = entID++;
  if (t != entmsg)
  {
    if ((newent->data.fname = malloc(20)) == 0)
    {
      dprintf(("Eng", "***ERROR*** Not enough memory for entity filename\n"));
      return 0;
    }
    sprintf(newent->data.fname, (t == entread) ? "NCMailStore:Ent%d\0" : "NCMailStore:Rep%d\0", newent->ID);
  }

  if (msg->entity_num)
  {
    e = msg->entity_list;
    while (e->next)
      e = e->next;
    e->next = newent;
  }
  else
    msg->entity_list = newent;

  ++msg->entity_num;
  newent->next = 0;
/*   dprintf(("Eng", "Creating new entity %d at 0x%x\n",newent->ID,newent)); */

  return newent;

}


void ResetEntID(void)
{

  entID = 0;

}


void eng_debug_show_status(void)
{

  dprintf(("Eng", "Engine state: 0x%x\n",state));

}


/*
** ActivatePOP() and DeactivatePOP() are used to set or unset a flag
** indicating whether the POP server is currently doing something,
** and to stop or start the timeout countdown accordingly.
** This ensures that a timeout does not occur while the server
** is currently engaged in some process.
*/

void ActivatePOP(void)
{
  
  popactive = true;
  StopTimeoutCount();

}


void DeactivatePOP(void)
{

  if (expungepending)
  {
    state |= (MARKDELETE + PROCESSPOP);
    dprintf(("Eng", "About to expunge\n"));
    popprocessstate.context = readytoconnect;
    markstate.context = idle;
    expungepending = false;
  }

  else if (disconnectpending)
    DisconnectPending();

  else
  {
    popactive = false;
    StartTimeoutCount();
  }
}


void RemoveMessage(void)
{
  
  MessageDescriptor *msgptr = retrievestate.msg;

  if (msgptr)
  {
    /*
    ** Operation is being performed after reading message.
    ** We can therefore destroy rfc object
    ** and remove entities from message.
    */
    dprintf(("Eng", "Cleaning up read message\n"));
    RemoveEntities(msgptr);
    if (msgptr->elibobj)
    {
      delete msgptr->elibobj;
      msgptr->elibobj = 0;
    }
    retrievestate.msg = 0;
  }
}


int32 FreeMem(void)
{

  if (!cachefs)
    return INT_MAX;

  regs.r[0] = 5;
  regs.r[1] = -1;
  _kernel_swi(OS_DynamicArea,&regs,&regs);
  return regs.r[2] - 0x200000;

}


eng_rcode ClearMemory(uint32 required, bool flag)
{

  /*
  ** If we are running on a CacheFS system:
  ** Remove any message files that can be removed.
  ** Start at oldest and remove one at a time
  ** until min is cleared.
  */

  if (!cachefs)
    return ENG_NOCACHEFS;

  else if (!ourmboxin->list)
    return ENG_NOMEMORY;

  else
  {
    MessageDescriptor *msgptr = ourmboxin->list, *lastptr;
    int32 released = FreeMem();
    int32 size = (int32) required;

    /* find last message in list */
    while (msgptr)
    {
      lastptr = msgptr;
      msgptr = msgptr->next;
    }

    /*
    ** Go through message list from last message backwards
    ** to see if enough memory can be released by removing messages.
    */
    while ((released < size) && (lastptr))
    {
      if ((lastptr->flags & DOWNLOADED) && (!(lastptr->flags & NEW)))
      {
        SetFilename(lastptr->ID, false);
        released += GetFileLength(msgfilename);
      }
      lastptr = lastptr->last;
    }

    if (released >= size)
    {
      /* enough memory available so remove message files */
      msgptr = (lastptr == 0) ? ourmboxin->list : lastptr->next;

      while (msgptr)
      {
        if ((msgptr->flags & DOWNLOADED) && (!(msgptr->flags & NEW)))
        {
          SetFilename(msgptr->ID, false);
          UnlockFile(msgfilename);
          remove(msgfilename);
          msgptr->flags &= ~DOWNLOADED;
          if (flag)
            msgptr->flags |= REMOVED;
          dprintf(("Eng", "Removing message %d to make more room\n",msgptr->ID));
        }
        msgptr = msgptr->next;
      }
    }        

    return ((released >= size) ? ENG_COMPLETED : ENG_NOMEMORY);
  }
}
