/*
** Email Engine
** Interface to UI
*/

#include "kernel.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "swis.h"

#include "DebugLib/DebugLib.h"

#include "Email/NetLink/NetLink.h"

#include "engtypes.h"
#include "engmanager.h"
#include "engfile.h"
#include "enginit.h"
#include "engcbf.h"
#include "engstr.h"
#include "engevent.h"

MailboxDescriptor *ourmboxin, *ourmboxout, *tempmbox;

char *realname = 0, *emailaddr = 0, *popuser = 0;
char *poppassword = 0, *pophostname = 0, *smtphostname = 0;

bool online, emailactive, disconnectpending;
uint32 popstatus;
uint32 smtpstatus;
uint32 state;
bool hdrsdownloaded;
bool baduser, badpop, badsmtp;

ChangeState changestate;
POPProcessState popprocessstate;
SMTPProcessState smtpprocessstate;
DownloadState downloadstate;
ParseHdrState parsehdrstate;
SendState sendstate;
RetrieveState retrievestate;
CreateState createstate;
MarkState markstate;

static uint32 timeouttime = 0, reconnecttime = 0;

static uint32 nextID = 1;  /* Number to allocate to next message ID.
                              Wrap around to one after 99999999
                              to allow filenames of "M" + 8 chars */

bool SetupState(void)
{

  char *ptr;

  state = IDLE;
  disconnectpending = false;
  popstatus = acctnonexistent;
  smtpstatus = acctnonexistent;
  emailactive = false;

  if ((ourmboxin = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor))) == 0)
    return false;
  if ((ourmboxout = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor))) == 0)
    return false;

  ourmboxin->total = 0;
  ourmboxin->read = 0;
  ourmboxin->answered = 0;
  ourmboxin->list = 0;
  ourmboxout->total = 0;
  ourmboxout->read = 0;
  ourmboxout->answered = 0;
  ourmboxout->list = 0;

  ptr = GetSysVar("NCMail$Timeout");
  if (ptr)
  {
    timeouttime = 6000 * atoi(ptr);
    free(ptr);
  }
  ptr = GetSysVar("NCMail$Reconnect");
  if (ptr)
  {
    reconnecttime = 6000 * atoi(ptr);
    free(ptr);
  }

  return true;

}


/*
** FindDescriptor() returns a pointer to the Message Descriptor
** for ID msg_id, or null if ID can't be found.
*/

MessageDescriptor *FindDescriptor(uint32 msg_id, MailboxDescriptor *box)
{

  if (box->list == 0)
    return 0;

  else
  {
    MessageDescriptor *nextptr = box->list;

    while ((nextptr->next) && (nextptr->ID != msg_id))
      nextptr = nextptr->next;
    return (nextptr->ID == msg_id) ? nextptr : 0;
  }

}


MessageDescriptor *NewDescriptor(MessageDescriptor *newmsg, MailboxDescriptor *box)
{

  if (!newmsg)
  {
    if ((newmsg = (MessageDescriptor *) calloc(1, sizeof(MessageDescriptor))) == 0)
    {
      /* no memory */
      return 0;
    }

    ++box->total;
  }

  while (FindDescriptor(nextID, box))
    nextID++;
  newmsg->ID = nextID++;
  dprintf(("Eng", "Creating new message descriptor with ID %d at 0x%x\n",nextID - 1,newmsg));
  if (nextID > 99999999)
    nextID = 1;

  if (box->list)
  {
    MessageDescriptor *msg = box->list;
    while (msg->next)
      msg = msg->next;
    msg->next = newmsg;
    newmsg->last = msg;
  }
  else
  {
    box->list = newmsg;
    newmsg->last = 0;
  }

  newmsg->next = 0;

  return newmsg;

}


void DestroyDescriptor(MessageDescriptor *msg, MailboxDescriptor *box)
{

  dprintf(("Eng", "Destroying descriptor for message %d\n",msg->ID));
  if ((msg->last == 0) && (msg->next == 0))
  {
    /* set descriptor list to null */
    box->list = 0;
  }

  else if (msg->last == 0)
  {
    box->list = msg->next;
    msg->next->last = 0;
  }

  else if (msg->next == 0)
    msg->last->next = 0;

  else
  {
    msg->last->next = msg->next;
    msg->next->last = msg->last;
  }

  /*
  ** Throw away all memory blocks reserved for bits of the message.
  ** Also destroy any EmailLib objects, delete files etc.
  */

  remove(SetFilename(msg->ID, false));
  if (msg->elibobj)
    delete msg->elibobj;
  free(msg->datestruct);
  free(msg->datestr);
  free(msg->subject);
  free(msg->cc);
  free(msg->fromreal);
  free(msg->fromaddr);
  free(msg->to);
  free(msg);
  --box->total;

}


EntityDescriptor *NewEntity(MessageDescriptor *msg)
{

  EntityDescriptor *e = 0, *newent = (EntityDescriptor *) calloc(1, sizeof(EntityDescriptor));

  if (newent == 0)
  {
    /* not enough memory */
    dprintf(("Eng", "***ERROR*** Not enough memory for new entity descriptor\n"));
    return 0;
  }

  if ((newent->fname = malloc(20)) == 0)
  {
    dprintf(("Eng", "***ERROR*** Not enough memory for entity filename\n"));
    return 0;
  }

  if (msg->entity_num)
  {
    e = msg->entity_list;
    while (e->next)
      e = e->next;
    e->next = newent;
  }
  else
    msg->entity_list = newent;

  newent->ID = msg->entity_num++;
  sprintf(newent->fname, "NCMailStore:Ent%d\0", newent->ID);
  newent->next = 0;
  dprintf(("Eng", "Creating new entity %d at 0x%x\n",newent->ID,newent));

  return newent;

}


void ConnectToISP(void)
{

  ELib_rcode code;

  state |= CONNECT;
  /*
  ** Request NetLink Cntrl to bring link up.
  **
  ** Callback from NetLink Cntrl to eng_line_change() will
  ** give result. Action will be taken there as appropriate.
  */

  /* following call fakes a successful connect */
  code = netlink->Connect();

}


void PreDisconnect(bool d)
{

  /* disconnect from mailbox accounts before taking line down */

  dprintf(("Eng", "Entering PreDisconnect(), state = 0x%x\n",state));
  state |= (PROCESSPOP + ((d) ? (PROCESSSMTP + DISCONNECT) : TIMEOUT));
  smtpprocessstate.context = smtpdone;
  popprocessstate.context = popdone;

}


void DisconnectFromISP(void)
{

  ELib_rcode code;

  dprintf(("Eng", "Disconnecting from ISP\n"));
  /*
  ** Mail servers have now been disconnected,
  ** so request NetLink Cntrl to take link down.
  **
  ** Callback from NetLink Cntrl to eng_line_change() will
  ** give result. Action will be taken there as appropriate.
  */

  /* following call fakes a successful disconnect */
  code = netlink->Disconnect();

}


void eng_debug_show_status(void)
{

  dprintf(("Eng", "Engine state: 0x%x\n",state));

}

bool ClearMemory(uint32 min)
{

  /* 
  ** Remove any message files that can be removed.
  ** E.g. start at oldest and remove one at a time
  ** until min is cleared.
  */

  return true; /* or false if not successful */

}


void StartTimeoutCount(void)
{

  int t;
  
  _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
  t = regs.r[0];

  if (timeouttime)
  {
    dprintf(("Eng", "Starting timeout countdown\n"));
    nexttimeout = t + timeouttime;
    timeoutactive = true;
  }

}


void StartReconnectCount(void)
{

  int t;

  _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
  t = regs.r[0];

  if (reconnecttime)
  {
    dprintf(("Eng", "Starting reconnect countdown\n"));
    nextreconnect = t + reconnecttime;
    reconactive = true;
  }

}


void StopTimeoutCount(void)
{
  
  dprintf(("Eng", "Stopping timeout countdown\n"));
  timeoutactive  = false;
  nexttimeout = 0;

}


void StopReconnectCount(void)
{
  
  dprintf(("Eng", "Stopping reconnect countdown\n"));
  reconactive = false;
  nextreconnect = 0;

}
