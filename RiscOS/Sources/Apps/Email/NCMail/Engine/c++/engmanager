/*
** Email Engine
** Interface to UI
*/

#include "kernel.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "swis.h"

#include "DebugLib/DebugLib.h"

#include "Email/NetLink/NetLink.h"

#include "engtypes.h"
#include "engmanager.h"
#include "engfile.h"
#include "enginit.h"
#include "engcbf.h"
#include "engstr.h"
#include "engevent.h"
#include "enguiapi.h"

MailboxDescriptor *ourmboxin, *ourmboxout, *tempmbox;

bool online, emailactive, disconnectpending, deletepending = false;
uint32 popstatus;
uint32 smtpstatus;
uint32 state;
bool hdrsdownloaded;

POPProcessState popprocessstate;
SMTPProcessState smtpprocessstate;
DownloadState downloadstate;
ParseHdrState parsehdrstate;
SendState sendstate;
RetrieveState retrievestate;
CreateState createstate;
MarkState markstate;

eng_return statusret;

static uint32 timeouttime = 0, reconnecttime = 0;
static bool wrapped = false;

static uint32 nextID = 1;  /* Number to allocate to next message ID.
                              Wrap around to one after 99999999
                              to allow filenames of "M" + 8 chars */

bool SetupState(void)
{

  char *ptr;

  state = IDLE;
  disconnectpending = false;
  popstatus = acctnonexistent;
  smtpstatus = acctnonexistent;
  emailactive = false;
  statusret.rc = ELIB_RUNNING;
  statusret.code = ENG_RUNNING;
  statusret.flags = 0;
  retrievestate.msg = 0;
  smtpprocessstate.attempts = 0;

  if ((ourmboxin = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor))) == 0)
    return false;
  if ((ourmboxout = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor))) == 0)
    return false;

  ourmboxin->total = 0;
  ourmboxin->read = 0;
  ourmboxin->answered = 0;
  ourmboxin->list = 0;
  ourmboxin->flags = 0;
  ourmboxout->total = 0;
  ourmboxout->read = 0;
  ourmboxout->answered = 0;
  ourmboxout->list = 0;
  ourmboxout->flags = 0;

  ptr = GetSysVar("NCMail$Timeout", true);
  if (ptr)
  {
    timeouttime = 6000 * atoi(ptr);
    free(ptr);
  }
  ptr = GetSysVar("NCMail$PollDelay", true);
  if (ptr)
  {
    reconnecttime = 6000 * atoi(ptr);
    free(ptr);
  }

  return true;

}


/*
** FindDescriptor() returns a pointer to the Message Descriptor
** for ID msg_id, or null if ID can't be found.
*/

MessageDescriptor *FindDescriptor(uint32 msg_id, MailboxDescriptor *box)
{

  if (box->list == 0)
    return 0;

  else
  {
    MessageDescriptor *nextptr = box->list;

    while ((nextptr->next) && (nextptr->ID != msg_id))
      nextptr = nextptr->next;
    return (nextptr->ID == msg_id) ? nextptr : 0;
  }

}


MessageDescriptor *NewDescriptor(MessageDescriptor *newmsg, MailboxDescriptor *box)
{

  if (!newmsg)
  {
    if ((newmsg = (MessageDescriptor *) calloc(1, sizeof(MessageDescriptor))) == 0)
    {
      /* no memory */
      return 0;
    }

    ++box->total;
  }

  if (wrapped)
  {
    /*
    ** If message ID numbers have wrapped round,
    ** check number against existing messages to ensure
    ** no duplication.
    ** Note: this is not very likely to happen - even if a user
    ** gets 1000 emails a day, the box will still need to be
    ** on for 273 years without loss of power before the ID
    ** wraps round!
    */
    while (FindDescriptor(nextID, box))
      nextID++;
  }

  newmsg->ID = nextID++;
  dprintf(("Eng", "Creating new message descriptor with ID %d at 0x%x\n",nextID - 1,newmsg));
  if (nextID > 99999999)
  {
    nextID = 1;
    wrapped = true;
  }

  if (box->list)
  {
    MessageDescriptor *msg = box->list;
    while (msg->next)
      msg = msg->next;
    msg->next = newmsg;
    newmsg->last = msg;
  }
  else
  {
    box->list = newmsg;
    newmsg->last = 0;
  }

  newmsg->next = 0;

  return newmsg;

}


void DestroyDescriptor(MessageDescriptor *msg, MailboxDescriptor *box)
{

  dprintf(("Eng", "Destroying descriptor for message %d\n",msg->ID));
  if ((msg->last == 0) && (msg->next == 0))
  {
    /* set descriptor list to null */
    box->list = 0;
  }

  else if (msg->last == 0)
  {
    box->list = msg->next;
    msg->next->last = 0;
  }

  else if (msg->next == 0)
    msg->last->next = 0;

  else
  {
    msg->last->next = msg->next;
    msg->next->last = msg->last;
  }

  /*
  ** Throw away all memory blocks reserved for bits of the message.
  ** Also destroy any EmailLib objects, delete files etc.
  */

  SetFilename(msg->ID, false);
  UnlockFile(msgfilename);
  remove(msgfilename);
  if (msg->elibobj)
  {
    delete msg->elibobj;
    msg->elibobj = 0;
  }
  free(msg->datestruct);
  free(msg->datestr);
  free(msg->subject);
  free(msg->cc);
  free(msg->fromreal);
  free(msg->fromaddr);
  free(msg->to);
  RemoveEntities(msg);
  free(msg);
  --box->total;

}


void RemoveEntities(MessageDescriptor *msg)
{

  EntityDescriptor *ent, *thisent;

  ent = msg->entity_list;
  while (ent)
  {
    thisent = ent;
    free(ent->typestr);
    free(ent->charset);
    UnlockFile(ent->fname);
    free(ent->fname);
    ent = ent->next;
    free(thisent);
    /* entity object in ELib will have been removed when
       deleting msg->elibobj so doesn't need to be done here */
  }
  msg->entity_num = 0;
  msg->entity_list = 0;
}


EntityDescriptor *NewEntity(MessageDescriptor *msg, enttype t)
{

  EntityDescriptor *e = 0, *newent = (EntityDescriptor *) calloc(1, sizeof(EntityDescriptor));

  if (newent == 0)
  {
    /* not enough memory */
    dprintf(("Eng", "***ERROR*** Not enough memory for new entity descriptor\n"));
    return 0;
  }

  if ((newent->fname = malloc(20)) == 0)
  {
    dprintf(("Eng", "***ERROR*** Not enough memory for entity filename\n"));
    return 0;
  }

  if (msg->entity_num)
  {
    e = msg->entity_list;
    while (e->next)
      e = e->next;
    e->next = newent;
  }
  else
    msg->entity_list = newent;

  newent->ID = msg->entity_num++;
  sprintf(newent->fname, (t == read) ? "NCMailStore:Ent%d\0" : "NCMailStore:Rep%d\0", newent->ID);
  newent->next = 0;
  dprintf(("Eng", "Creating new entity %d at 0x%x\n",newent->ID,newent));

  return newent;

}


void ConnectToISP(void)
{

  ELib_rcode code;

  state |= CONNECT;
  /* Request NetLink Cntrl to bring link up. */
  code = netlink->Connect();

}


void PreDisconnect(bool d)
{

  /* disconnect from mailbox accounts before taking line down */

  dprintf(("Eng", "Entering PreDisconnect(), state = 0x%x\n",state));
  state |= (PROCESSPOP + ((d) ? (PROCESSSMTP + DISCONNECT) : TIMEOUT));
  if (d)
    smtpprocessstate.context = done;
  popprocessstate.context = readytodisconnect;

}


void DisconnectFromISP(void)
{

  ELib_rcode code;

  dprintf(("Eng", "Disconnecting from ISP\n"));
  /*
  ** Mail servers have now been disconnected,
  ** so request NetLink Cntrl to take link down.
  */
  code = netlink->Disconnect();

}


void eng_debug_show_status(void)
{

  dprintf(("Eng", "Engine state: 0x%x\n",state));

}


void StartRetryCount(void)
{

  int t;

  _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
  t = regs.r[0];
    dprintf(("Eng", "Starting SMTP retry countdown\n"));
  nextretry = t + 6000;
  retryactive = true;

}


void StartTimeoutCount(void)
{

  int t;

  _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
  t = regs.r[0];

  if (timeouttime)
  {
    dprintf(("Eng", "Starting timeout countdown\n"));
    nexttimeout = t + timeouttime;
    timeoutactive = true;
  }

}


void StartReconnectCount(void)
{

  int t;

  _kernel_swi(OS_ReadMonotonicTime,&regs,&regs);
  t = regs.r[0];

  if (reconnecttime)
  {
    dprintf(("Eng", "Starting reconnect countdown\n"));
    nextreconnect = t + reconnecttime;
    reconactive = true;
  }

}


void StopRetryCount(void)
{

  dprintf(("Eng", "Stopping SMTP retry countdown\n"));
  retryactive  = false;
  nextretry = 0;
  smtpprocessstate.attempts = 0;

}


void StopTimeoutCount(void)
{

  dprintf(("Eng", "Stopping timeout countdown\n"));
  timeoutactive  = false;
  nexttimeout = 0;

}


void StopReconnectCount(void)
{

  dprintf(("Eng", "Stopping reconnect countdown\n"));
  reconactive = false;
  nextreconnect = 0;

}
