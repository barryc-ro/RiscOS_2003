/*
** Email Engine
** Interface to UI
*/

#include "kernel.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"

#include "DebugLib/DebugLib.h"

#include "engtypes.h"
/* #include "engdebug.h" */
#include "engmanager.h"
#include "engfile.h"
#include "enginit.h"
#include "engcbf.h"

MailboxDescriptor *ourmboxin, *ourmboxout;
EngineState state;

uint32 nextID = 1;     /* Number to allocate to next message ID.
                          Wrap around to one after 99999999
                          to allow filenames of "M" + 8 chars */

void InitState(void)
{

  state.state = IDLE;
  state.disconnectpending = false;
  state.popstatus = acctnonexistent;
  state.smtpstatus = acctnonexistent;
  state.emailactive = false;
  
  /*
  ** Register with NetLink Cntrl and find out state of connection.
  ** Replace next line with appropriate call.
  */
  state.connected = false;

  ourmboxin = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor));
  ourmboxout = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor));
  ourmboxin->total = 0;
  ourmboxin->read = 0;
  ourmboxin->answered = 0;
  ourmboxin->list = 0;
  ourmboxout->total = 0;
  ourmboxout->read = 0;
  ourmboxout->answered = 0;
  ourmboxout->list = 0;

}


/*
** FindDescriptor() returns a pointer to the Message Descriptor
** for ID msg_id, or null if ID can't be found.
*/

MessageDescriptor *FindDescriptor(uint32 msg_id, MailboxDescriptor *box)
{

  if (box->list == 0)
    return 0;

  else
  {
    MessageDescriptor *nextptr = box->list;

    while ((nextptr->next) && (nextptr->ID != msg_id))
      nextptr = nextptr->next;
    return (nextptr->ID == msg_id) ? nextptr : 0;
  }

}


MessageDescriptor *NewDescriptor(MessageDescriptor *newmsg, MailboxDescriptor *box)
{

  if (!newmsg)
  {
    if ((newmsg = (MessageDescriptor *) calloc(1, sizeof(MessageDescriptor))) == 0)
    {
      /* no memory */
      return 0;
    }
      
    ++box->total;
  }
  dprintf(("Eng", "mbox.total = %d\n",box->total));

  while (FindDescriptor(nextID, box))
    nextID++;
  newmsg->ID = nextID++;
  dprintf(("Eng", "Creating new message descriptor with ID %d at 0x%x\n",nextID - 1,newmsg));
  if (nextID > 99999999)
    nextID = 1;

  if (box->list)
  {
    MessageDescriptor *msg = box->list;
    while (msg->next)
      msg = msg->next;
    msg->next = newmsg;
    newmsg->last = msg;
  }
  else
  {
    box->list = newmsg;
    newmsg->last = 0;
  }

  newmsg->next = 0;

  return newmsg;

}


void DestroyDescriptor(MessageDescriptor *msg, MailboxDescriptor *box)
{

  MessageDescriptor *msgptr;
  char *file;

  if ((msg->last == 0) && (msg->next == 0))
    box->total = 0;

  else if (msg->last == 0)
  {
    msgptr = msg->next;
    box->list = msgptr;
    msgptr->last = 0;
  }
  else
  {
    msgptr = msg->last;
    msgptr->next = msg->next;
  }

  /*
  ** We need to throw away here any memory blocks
  ** we've reserved for bits of the message.
  ** Also destroy any EmailLib objects, delete files etc.
  */
  
  file = SetFilename(msg->ID, false);
  remove(file);
  if (msg->elibobj)
    delete msg->elibobj;
  free(msg->datestruct);
  free(msg->datestr);
  free(msg->subject);
  free(msg->cc);
  free(msg->from);
  free(msg->to);
  free(msg);
  --box->total;

}


EntityDescriptor *FindEntity(MessageDescriptor *msg, uint32 entID)
{

  EntityDescriptor *ent = msg->entity_list;

  if (!ent)
  {
    dprintf(("Eng", "Entity list is null\n"));
    return 0;
  }
  else
  {
    while ((ent->next) && (ent->ID != entID))
      ent = ent->next;
    return (ent->ID == entID) ? ent : 0;
  }
}


EntityDescriptor *NewEntity(MessageDescriptor *msg)
{

  EntityDescriptor *newent = (EntityDescriptor *) calloc(1, sizeof(EntityDescriptor));

  if (newent == 0)
  {
    /* not enough memory */
    dprintf(("Eng", "Not enough memory for new entity descriptor\n"));
    return 0;
  }

  if (msg->entity_list)
  {
    EntityDescriptor *e = msg->entity_list;
    while (e->next)
      e = e->next;
    e->next = newent;
  }
  else
    msg->entity_list = newent;

  newent->ID = msg->entity_num++;
  dprintf(("Eng", "Creating new entity %d\n",newent->ID));

  return newent;

}


void ConnectToISP(void)
{
  
  state.state |= CONNECT;
  /*
  ** Request NetLink Cntrl to bring link up.
  **
  ** Callback from NetLink Cntrl to eng_line_change() will
  ** give result. Action will be taken there as appropriate.
  */

  /* following call fakes a successful connect */
  eng_line_change(2);

}


void PreDisconnect(void)
{

  /* disconnect from mailbox accounts before taking line down */
    
  state.state |= (DISCONNECT + PROCESSSMTP + PROCESSPOP);
  state.smtpprocess.substate = smtpdone;
  state.popprocess.substate = popdone;

}


void DisconnectFromISP(void)
{

  dprintf(("Eng", "Disconnecting from ISP\n"));  
  /*
  ** Mail servers have now been disconnected,
  ** so request NetLink Cntrl to take link down.
  **
  ** Callback from NetLink Cntrl to eng_line_change() will
  ** give result. Action will be taken there as appropriate.
  */

  /* following call fakes a successful disconnect */
  eng_line_change(0);

}


void ReportError(char *s)
{
  
  char *ptr = malloc(strlen(s) + 5);
  
  *(int *) ptr = 1;
  strcpy(ptr + 4, s);
  regs.r[0] = (int) ptr;
  regs.r[1] = 1;
  regs.r[2] = (int) appname;
  _kernel_swi(Wimp_ReportError,&regs,&regs);

}
