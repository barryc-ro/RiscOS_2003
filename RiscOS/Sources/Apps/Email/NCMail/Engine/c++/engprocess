/*
** Email Client
** Mailbox interface
*/

#include "time.h"
#include "stdlib.h"
#include "swis.h"

#include "Email/Common/list.h"
#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "DebugLib/DebugLib.h"

#include "Email/Mailbox/Account.h"
#include "Email/Mailbox/POP3/POP3Account.h"
#include "Email/Mailbox/SendQ/SendQAccount.h"
#include "Email/Mailbox/SendQ/SendQMailbox.h"
#include "Email/Mailbox/Mailbox.h"
#include "Email/Mailbox/MBoxCB.h"
#include "Email/Mailbox/Message.h"
#include "Email/Mailbox/MBoxOpCB/connect.h"
#include "Email/Mailbox/MBoxOpCB/disconnect.h"
#include "Email/Mailbox/MBoxOpCB/process.h"
#include "Email/Mailbox/MBoxOpCB/getnummsgs.h"
#include "Email/Mailbox/MBoxOpCB/expunge.h"

#include "engevent.h"
#include "engtypes.h"
#include "enguiapi.h"
#include "engmanager.h"
#include "enginit.h"
#include "engcbf.h"
#include "engprocess.h"
#include "engfile.h"


Account *POPaccount, *SMTPaccount;
Mailbox *inbox;
SendQMailbox *outbox;
bool newmail = false;

void ProcessDone(bool changed);
void ReconcileMailbox(uint32 n);


eng_rcode POPAccountConnect(void)
{

  eng_rcode code;

  popprocessstate.connectobj = new MBoxOpCB_connect((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) pop);
  code = (eng_rcode) POPaccount->Connect(popprocessstate.connectobj);
  dprintf(("Eng", "Trying to connect to POP, rc=%d\n",code));

  return code;

}


eng_rcode SMTPAccountConnect(void)
{

  eng_rcode code;

  smtpprocessstate.connectobj = new MBoxOpCB_connect((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) smtp);
  code = (eng_rcode) SMTPaccount->Connect(smtpprocessstate.connectobj);
  dprintf(("Eng", "Trying to connect to SMTP, rc=%d\n",code));

  return code;

}


eng_rcode POPAccountDisconnect(void)
{

  if (popstatus == acctconnected)
  {
    popprocessstate.disconnectobj = new MBoxOpCB_disconnect((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) pop);
    return (eng_rcode) POPaccount->Disconnect(popprocessstate.disconnectobj);
  }
  else
    return ENG_COMPLETED;

}


eng_rcode SMTPAccountDisconnect(void)
{

  if (smtpstatus == acctconnected)
  {
    smtpprocessstate.disconnectobj = new MBoxOpCB_disconnect((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) smtp);
    return (eng_rcode) SMTPaccount->Disconnect(smtpprocessstate.disconnectobj);
  }
  else if (state & DISCONNECT)
    smtpprocessstate.context = disconnected;

  return ENG_COMPLETED;

}


void RemoveObj(MBoxOpCB **obj)
{

  if (*obj)
    delete *obj;
  *obj = 0;
}


/*
** StartProcess() initiates the processing of the mailbox via callback.
** The POP and SMTP mailboxes are processed in parallel.
*/

void StartProcess(void)
{

  newmail = false;
  ourmboxin->flags &= ~MBOXINCOMPLETE;
/*   StopCountDown(); */

  /*
  ** Set up initial contexts depending on whether POP
  ** and/or SMTP accounts have been successfully created.
  */

  if (popstatus != acctnonexistent)
  {
    popprocessstate.context = readytoexpunge;
    state |= PROCESSPOP;
    inbox = POPaccount->GetInbox();
  }
  if (smtpstatus != acctnonexistent)
  {
    smtpprocessstate.context = readytosend;
    state |= PROCESSSMTP;
    outbox = (SendQMailbox *) SMTPaccount->GetInbox();
  }

}


void DefunctPOP(bool b)
{
  state &= ~PROCESSPOP;
}


void DefunctSMTP(bool b)
{
  state &= ~PROCESSSMTP;
}


void DeadPOP(bool b)
{
  POPAccountDisconnect();
}


void DeadSMTP(bool b)
{
  SMTPAccountDisconnect();
}


void DoSMTPProcess(void)
{

  eng_rcode code;
  uint32 n;

  switch (smtpprocessstate.context)
  {
    case readytosend :

      dprintf(("Eng", "SMTP context = readytosend\n"));
      smtpprocessstate.context = idle;
      smtpprocessstate.getnumobj = new MBoxOpCB_getnummsgs((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) smtp);
      code = (eng_rcode) outbox->GetNumberMessages(smtpprocessstate.getnumobj);
      if (code < 0)
      {
        smtpprocessstate.context = getnumfailure;
        smtpprocessstate.rc = code;
      }

    case gotnumber :

      dprintf(("Eng", "SMTP context = gotnumber\n"));
      smtpprocessstate.context = idle;
      n = smtpprocessstate.getnumobj->number_messages;
      dprintf(("Eng", "Number of messages in send queue=%d\n",n));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.getnumobj);
      if (true)
      {
        code = SMTPAccountConnect();
        if (code < 0)
        {
          smtpprocessstate.rc = ENG_SMTPCONNECTFAIL;
          smtpprocessstate.context = connectfailure;
        }
      }

      else
      {
        /* no messages in send queue, so don't connect */
        smtpprocessstate.context = disconnected;
      }

      break;

    case getnumfailure :

      dprintf(("Eng", "SMTP context = getnumfailure\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.getnumobj);
      smtpprocessstate.context = disconnected;

      break;

    case connected :

      dprintf(("Eng", "SMTP context = connected\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.connectobj);
      smtpstatus = acctconnected;

      smtpprocessstate.context = idle;
      smtpprocessstate.processobj = new MBoxOpCB_process((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) smtp);
      code = (eng_rcode) outbox->Process(smtpprocessstate.processobj);
      dprintf(("Eng", "Processing SMTP mailbox, rc=%d\n",code));

      if (code < 0)
      {
        smtpprocessstate.rc = ENG_CANTPROCESSSMTP;
        smtpprocessstate.context = processfailure;
      }

      break;

    case connectfailure :

      /* connection has failed */
      dprintf(("Eng", "SMTP context = connectfailure\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.connectobj);
      smtpprocessstate.context = idle;
      if (state & SEND)
      {
        (*callbacklist.sendfunc)(ENG_SENDFAILED, callbacklist.sendhandle);
        state &= ~SEND;
      }
      else
        (*callbacklist.statusfunc)(smtpprocessstate.rc, callbacklist.statushandle, DefunctSMTP);

      break;

    case processfailure :

      /* processing has failed */
      dprintf(("Eng", "SMTP context = processfailure\n",));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.processobj);
      smtpprocessstate.context = idle;
      if (state & SEND)
      {
        (*callbacklist.sendfunc)(ENG_SENDFAILED, callbacklist.sendhandle);
        state &= ~SEND;
      }
      else
        (*callbacklist.statusfunc)(smtpprocessstate.rc, callbacklist.statushandle, DeadSMTP);

      break;

    case smtpdone :

      /*
      ** SMTP process completed.
      ** We need to alter following code to call
      ** GetNumberMessages again to see if queue is now empty.
      ** If it is, do an expunge. If not, report to UI?
      */
      dprintf(("Eng", "SMTP context = smptdone\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.processobj);
      smtpprocessstate.context = idle;
      SMTPAccountDisconnect();
      break;

    case disconnected :
    case disconnectfailure :

      dprintf(("Eng", "SMTP context = disconnected\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.disconnectobj);
      smtpstatus = acctcreated;
      state &= ~(PROCESSSMTP + TIMEOUT);
      if (state & SEND)
      {
        (*callbacklist.sendfunc)(ENG_COMPLETED, callbacklist.sendhandle);
        state &= ~SEND;
      }        
      if ((state & DISCONNECT) && (!(state & PROCESSPOP)))
      {
        state &= ~DISCONNECT;
        DisconnectFromISP();
      }

      break;

  }

}


void DoPOPProcess(void)
{

  eng_rcode code;
  uint32 n;
  bool changed;

  switch (popprocessstate.context)
  {
    case readytoexpunge :

      dprintf(("Eng", "POP context = readytoexpunge\n"));
      /* it may be already connected... */
      if (popstatus == acctconnected)
      {
        dprintf(("Eng", "Already connected\n"));
        popprocessstate.context = connected;
      }

      /* ...but if not, connect to it if it exists */
      else if (popstatus == acctcreated)
      {
        popprocessstate.context = idle;
        markstate.context = idle;
        POPAccountConnect();
        if (code < 0)
        {
          popprocessstate.rc = ENG_POPCONNECTFAIL;
          popprocessstate.context = connectfailure;
        }
      }

      break;

    case connected :

      dprintf(("Eng", "POP context = connected\n"));
      RemoveObj((MBoxOpCB**) &popprocessstate.connectobj);
      popstatus = acctconnected;

      popprocessstate.context = idle;
      markstate.context = idle;
      dprintf(("Eng", "About to create expunge object\n"));
      popprocessstate.expungeobj = new MBoxOpCB_expunge((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) pop);
      dprintf(("Eng", "About to call Expunge\n"));
      code = (eng_rcode) inbox->Expunge(popprocessstate.expungeobj);
      dprintf(("Eng", "Expunging POP mailbox, rc=%d\n",code));

      if (code < 0)
      {
        ourmboxin->flags |= MBOXINCOMPLETE;
        popprocessstate.context = readytoprocess;
      }

      break;

    case readytoprocess :

      dprintf(("Eng", "POP context = readytoprocess\n"));
      if (popprocessstate.expungeobj)
        changed = popprocessstate.expungeobj->mailbox_changed;
      RemoveObj((MBoxOpCB**) &popprocessstate.expungeobj);

      popprocessstate.context = idle;
      popprocessstate.processobj = new MBoxOpCB_process((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) pop);
      code = (eng_rcode) inbox->Process(popprocessstate.processobj);
      dprintf(("Eng", "Processing POP mailbox, rc=%d\n",code));

      if (code < 0)
      {
        popprocessstate.rc = ENG_CANTPROCESSPOP;
        popprocessstate.context = processfailure;
      }

      break;

    case connectfailure :

      /* connection has failed */
      dprintf(("Eng", "POP context = connectfailure\n",));
      RemoveObj((MBoxOpCB**) &popprocessstate.connectobj);
      popprocessstate.context = idle;
      (*callbacklist.statusfunc)(popprocessstate.rc, callbacklist.statushandle, DefunctPOP);
      break;

    case processfailure :

      /* processing has failed */
      dprintf(("Eng", "POP context = processfailure\n",));
      RemoveObj((MBoxOpCB**) &popprocessstate.processobj);
      popprocessstate.context = idle;
      (*callbacklist.statusfunc)(popprocessstate.rc, callbacklist.statushandle, DeadPOP);

      break;

    case popdone :

      dprintf(("Eng", "POP context = popdone\n"));
      /* only set changed if expunge hasn't already set it */
      if ((popprocessstate.processobj) && (!changed))
        changed = popprocessstate.processobj->mailbox_changed;
      RemoveObj((MBoxOpCB**) &popprocessstate.processobj);
      popprocessstate.context = idle;
      if (state & (DISCONNECT | TIMEOUT))
        POPAccountDisconnect();

      else
      {
        dprintf(("Eng", "Mailbox has %schanged\n",(changed) ? "" : "not "));
        if (changed)
        {
          popprocessstate.getnumobj = new MBoxOpCB_getnummsgs((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) pop);
          code = (eng_rcode) inbox->GetNumberMessages(popprocessstate.getnumobj);
          if (code < 0)
          {
            popprocessstate.context = getnumfailure;
            popprocessstate.rc = code;
          }
        }

        else
        {
          /* mailbox hasn't changed so no new mail */
          ProcessDone(false);
        }
      }

      break;

    case disconnected :
    case disconnectfailure :

      dprintf(("Eng", "POP context = disconnected\n"));
      RemoveObj((MBoxOpCB**) &popprocessstate.disconnectobj);
      popstatus = acctcreated;
      state &= ~(PROCESSPOP + TIMEOUT);
      if ((state & DISCONNECT) && (!(state & PROCESSSMTP)))
      {
        state &= ~DISCONNECT;
        DisconnectFromISP();
      }

      break;

    case gotnumber :

      dprintf(("Eng", "POP context = gotnumber\n"));
      n = popprocessstate.getnumobj->number_messages;
      dprintf(("Eng", "Number of messages=%d\n",n));
      RemoveObj((MBoxOpCB**) &popprocessstate.getnumobj);
      ReconcileMailbox(n);
      break;

    case getnumfailure :

      dprintf(("Eng", "POP context = getnumfailure\n"));
      popprocessstate.context = idle;
      RemoveObj((MBoxOpCB**) &popprocessstate.getnumobj);
      (*callbacklist.statusfunc)(ENG_CANTPROCESSPOP, callbacklist.statushandle, DeadPOP);

    default :

      break;
  }

}


/*
** OnOurList() checks a mailbox object pointer against our list
** to see if it is on the list.
*/

bool OnOurList(Message *obj)
{

  MessageDescriptor *msgptr = ourmboxin->list;

  while (msgptr)
  {
    if (msgptr->mboxobj == obj)
      return true;
    else
      msgptr = msgptr->next;
  }

  return false;

}


/*
** OnMboxList() checks a mailbox object pointer against the
** mailbox's list to see if it is on the list.
*/

bool OnMboxList(Message *obj, ELib_list& list, int n)
{

  list.Reset();  
  while (n--)
  {
    list.Next();
    if ((Message *) list.Current() == obj)
      return true;
  }

  return false;

}


void PAbort(bool b)
{
  ProcessDone(true);
}


/*
** ReconcileMailbox() gets the list of messages in the Inbox
** after receiving the callback with the number of messages.
**
** First it looks through our list to see if any are missing from
** the mailbox's list. If so, their descriptors are destroyed.
**
** Then it scans the messages in the mailbox's
** list to see if any are missing from our own list.
** If so, new descriptors are created and the flags are read.
*/

void ReconcileMailbox(uint32 n)
{

  MessageDescriptor *nextptr, *msgptr;
  ELib_rcode code;
  uint32 i;
  Message::Flags flags;
  Message *obj;
  bool errorflag = false;
  ELib_list& msglist = inbox->GetMessages();

  /* check through our list to see if any are missing
     from mailbox's list, and destroy them */

  msgptr = ourmboxin->list;
  dprintf(("Eng", "message list starts at 0x%x\n",ourmboxin->list));
  while (msgptr)
  {
    nextptr = msgptr->next;
    if (!OnMboxList(msgptr->mboxobj, msglist, n))
    {
      /* must have been deleted so destroy descriptor */
      dprintf(("Eng", "Deleting message %d not on mailbox list\n",msgptr->ID));
      DestroyDescriptor(msgptr, ourmboxin);
    }
    else
      dprintf(("Eng", "Message %d is on mailbox list\n",msgptr->ID));
    msgptr = nextptr;
  }

  msglist.Reset();

  if ((tempmbox = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor *))) == 0)
  {
    dprintf(("Eng", "Malloc failure setting up temp list\n"));
    errorflag = true;
  }
  else
  {
    uint32 count = 0;

    tempmbox->total = 0;
    tempmbox->list = 0;

    for (i = 0; i < n; i++)
    {
      msglist.Next();
      obj = (Message *) msglist.Current();
      dprintf(("Eng", "Examining message %d on mailbox list\n",i));
      if (!OnOurList(obj))
      {
        /* must be an unknown message so create new descriptor */
        dprintf(("Eng", "Message is not on our list\n"));

        if ((msgptr = NewDescriptor(0, tempmbox)) == 0)
        {
          /* there was not enough memory to create descriptor */
          dprintf(("Eng", "Malloc failure\n"));
          errorflag = true;
        }
        else
        {
          msgptr->mboxobj = obj;
          code = obj->GetFlags(flags, Message::Set);
          dprintf(("Eng", "Flags=0x%x, code=%d\n",flags,code));
          if (code >= 0)
          {
            if (flags & Message::Read)
              msgptr->flags |= READ;
            if (flags & Message::New)
            {
              newmail = true;
              msgptr->flags |= NEW;
            }
          }
          msgptr->flags |= NEWLYCREATED;
        }
      }
    }
  }
  dprintf(("Eng", "Total for mboxin %d, for tempmbox %d\n",ourmboxin->total,tempmbox->total));

  if (errorflag)
  {
    /* we've had a memory allocation failure */
    (*callbacklist.statusfunc)(ENG_NOSPACEFORMSG, callbacklist.statushandle, PAbort);
  }
  else
    ProcessDone(true);

}


void ProcessDone(bool changed)
{

  dprintf(("Eng", "Entering ProcessDone(), mailbox is %schanged\n",(changed) ? "" : "not "));
  dprintf(("Eng", "message list starts at 0x%x, tempbox start at 0x%x\n",ourmboxin->list,tempmbox->list));
  state &= ~PROCESSPOP;
  if (changed)
  {
    if (online)
    {
      /* go off and get headers for Inbox */
      downloadstate.msg = tempmbox->list;
      downloadstate.context = readytodownload;
      parsehdrstate.context = idle;
      downloadstate.rc = ENG_COMPLETED;
      hdrsdownloaded = false;
      state |= DOWNLOADHDR;
    }

    if (!emailactive)
    {
      if (newmail)
      {
        /* send an indication to the browser of new mail
           including number of new mails */
      }
      else
      {
        /* tell browser there's no new mail */
      }
    }
  }
  else
  {
    ourmboxin->flags |= MBOXPROCESSED;
    (*callbacklist.promptfunc)(ENG_COMPLETED, ourmboxin->list, online, callbacklist.prompthandle);
  }

}


void SortByDate(MessageDescriptor *newmsg)
{

  MessageDescriptor *msgptr = ourmboxin->list, *lastptr;

  if (newmsg->next)
    newmsg->next->last = 0;

  if (!msgptr)
  {
    dprintf(("Eng", "New message is first on mboxin\n"));
    ourmboxin->list = newmsg;
    newmsg->next = 0;
    newmsg->last = 0;
  }

  else
  {
    while (msgptr)
    {
      if (mktime(newmsg->datestruct) >= mktime(msgptr->datestruct))
        break;
      lastptr = msgptr;
      msgptr = msgptr->next;
    }

    if (!msgptr)
    {
      dprintf(("Eng", "Inserting new message at end of list\n"));
      lastptr->next = newmsg;
      newmsg->last = lastptr;
      newmsg->next = 0;
    }
    else
    {
      dprintf(("Eng", "Inserting new message before message %d\n",msgptr->ID));
      newmsg->next = msgptr;
      newmsg->last = msgptr->last;
      msgptr->last = newmsg;
      if (newmsg->last)
        newmsg->last->next = newmsg;
      else
        ourmboxin->list = newmsg;
    }
  }

  --tempmbox->total;
  ++ourmboxin->total;
  dprintf(("Eng", "mboxin total now %d, tempbox total %d\n",ourmboxin->total,tempmbox->total));

}        
  
  

#ifdef gorilla
/*
** SortMailbox() reorders the message list in date order, newest first.
*/

void SortMailbox(void)
{

  MessageDescriptor *msgptr, *nextptr, *prev, *beyond;
  bool sortflag;
  int i;

  do
  {
    sortflag = false;
    msgptr = ourmboxin->list;
    for (i = 0; i < ourmboxin->total; i++)
    {
      nextptr = msgptr->next;

      if (nextptr)
      {
        /*
        ** If date of next is greater than date of current,
        ** swap pointers and set sortflag.
        */

        if (mktime(nextptr->datestruct) > mktime(msgptr->datestruct))
        {
          sortflag = true;
          prev = msgptr->last;
          beyond = nextptr->next;
          if (beyond)
            beyond->last = msgptr;
          if (prev)
            prev->next = nextptr;
          msgptr->next = beyond;
          msgptr->last = nextptr;
          nextptr->next = msgptr;
          nextptr->last = prev;
          if (nextptr->last == 0)
            ourmboxin->list = nextptr;
        }
        else
          msgptr = msgptr->next;
      }
    }
  }
  while (sortflag);
  dprintf(("Eng", "Mailbox sorted\n"));
}
#endif

void DoMark(void)
{

  ELib_rcode code;

  switch (markstate.context)
  {
    case readytomark :

      dprintf(("Eng", "Mark context = readytomark\n"));
      markstate.context = idle;
      if (state & MARKDELETE)
      {
        /* mark for delete process */
        
        if (markstate.current == markstate.total)
        {
          /* all messages marked for deletion */
          dprintf(("Eng", "All messages marked\n"));
          free(markstate.list);
          if (online)
          {
            /* expunge mailbox now */
            dprintf(("Eng", "About to expunge\n"));
            popprocessstate.context = readytoexpunge;
            state |= PROCESSPOP;
          }
          else
            markstate.context = readytodisplay;
        }

        else
        {
          MessageDescriptor *msg = FindDescriptor(markstate.list[markstate.current], ourmboxin);
          if (!msg)
          {
            dprintf(("Eng", "Unknown message ID %d\n",msg->ID));
            markstate.context = markfailure;
          }
          else
          {
            markstate.setobj = new MBoxOpCB_setflags((MBoxCBHandlerFn) eng_mbox_cbfunc, 0);

            markstate.msg = msg;
            markstate.context = idle;
            code = msg->mboxobj->SetFlags(markstate.setobj, Message::Delete, Message::Set);
            if (code < 0)
            {
              /* mailbox has signalled an error in marking */
              dprintf(("Eng", "Error calling SetFlags, rc=%d\n",code));
              markstate.context = markfailure;
            }
          }
        }
      }
      
      else
      {
        /* mark as read process */

        markstate.setobj = new MBoxOpCB_setflags((MBoxCBHandlerFn) eng_mbox_cbfunc, 0);
        markstate.context = idle;
        code = markstate.msg->mboxobj->SetFlags(markstate.setobj, Message::Read, Message::Set);
        if (code < 0)
        {
          /* mailbox has signalled an error in marking */
          dprintf(("Eng", "Error calling SetFlags, rc=%d\n",code));
          markstate.context = markfailure;
        }
      }

      break;

    case markfailure :

      dprintf(("Eng", "Mark context = markfailure\n"));
      RemoveObj((MBoxOpCB**) &markstate.setobj);
      markstate.rc = ENG_MARKFAILED;
      if (state & MARKDELETE)
      {
        ++markstate.current;
        markstate.context = readytomark;
      }
      else
        markstate.context = readdone;

      break;

    case readdone :

      RemoveObj((MBoxOpCB**) &markstate.setobj);
      state &= ~MARKREAD;

      break;

    case deletedone :
    {
      MessageDescriptor *msg = markstate.msg;
      char *file = SetFilename(msg->ID, false);

      dprintf(("Eng", "Mark context = deletedone\n"));
      RemoveObj((MBoxOpCB**) &markstate.setobj);
      msg->flags |= MARKED;
      DestroyDescriptor(msg, ourmboxin);
      UnlockFile(SetFilename(msg->ID, false));
      remove(file);
      ++markstate.current;
      markstate.context = readytomark;
    
      break;
    }
    case readytodisplay :

      /* send message to UI to display Inbox */
      dprintf(("Eng", "Prompting UI to display Inbox\n"));
      state &= ~MARKDELETE;
      (*callbacklist.promptfunc)(markstate.rc, ourmboxin->list, online, callbacklist.prompthandle);
      break;

  }

}


void SendMessage(void)
{

  ELib_rcode code;
  MessageDescriptor *msg = sendstate.msg;
  char *file = SetFilename(msg->ID, true);

  sendstate.context = idle;
  outbox = (SendQMailbox *) SMTPaccount->GetInbox();
  code = outbox->AddMessage(file, msg->to, msg->fromaddr);
  dprintf(("Eng", "Added message to %s, from %s to send queue, rc=%d\n",msg->to,msg->fromaddr,code));

  if ((smtpstatus != acctnonexistent) && (online))
  {
    smtpprocessstate.context = readytosend;
    state |= PROCESSSMTP;
  }
  else
  {
    state &= ~SEND;
    (*callbacklist.sendfunc)(ENG_COMPLETED, callbacklist.sendhandle);
  }

}


void StartCountDown(void)
{

  static char comm[] = "NCMail_StartCountDown";
  regs.r[0] = (int) comm;
  err = _kernel_swi(OS_CLI,&regs,&regs);
  if (err)
    dprintf(("Eng", "***ERROR*** %s\n",(char*)err+4));

}


void StopCountDown(void)
{

  static char comm[] = "NCMail_StopCountDown";
  regs.r[0] = (int) comm;
  err = _kernel_swi(OS_CLI,&regs,&regs);
  if (err)
    dprintf(("Eng", "***ERROR*** %s\n",(char*)err+4));

}

