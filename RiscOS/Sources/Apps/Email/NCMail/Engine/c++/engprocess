/*
** Email Client
** Mailbox interface
*/

#include "time.h"
#include "stdlib.h"
#include "swis.h"

#include "Email/Common/list.h"
#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "DebugLib/DebugLib.h"
#include "NBLib/NBLib.h"

#include "Email/Mailbox/Account.h"
#include "Email/Mailbox/POP3/POP3Account.h"
#include "Email/Mailbox/SendQ/SendQAccount.h"
#include "Email/Mailbox/SendQ/SendQMailbox.h"
#include "Email/Mailbox/Mailbox.h"
#include "Email/Mailbox/MBoxCB.h"
#include "Email/Mailbox/Message.h"
#include "Email/Mailbox/MBoxOpCB/connect.h"
#include "Email/Mailbox/MBoxOpCB/disconnect.h"
#include "Email/Mailbox/MBoxOpCB/process.h"
#include "Email/Mailbox/MBoxOpCB/getnummsgs.h"
#include "Email/Mailbox/MBoxOpCB/expunge.h"

#include "engevent.h"
#include "engtypes.h"
#include "enguiapi.h"
#include "engmanager.h"
#include "enginit.h"
#include "engcbf.h"
#include "engprocess.h"
#include "engparse.h"
#include "engsend.h"
#include "engtimers.h"
#include "engconnect.h"

extern "C"
{
  #include "../Build/NCMailUI.h"
}


Account *POPaccount, *SMTPaccount;
Mailbox *inbox;
SendQMailbox *outbox;
bool firstprocess = true, firstdownload = true;
uint32 newmail = 0;

#ifdef ALAN
static int filecount1 = 1;
#endif

void ProcessDone(void);


ELib_rcode POPAccountConnect(void)
{

  ELib_rcode rc;

  popprocessstate.connectobj = new MBoxOpCB_connect((MBoxCBHandlerFn) MBoxCallback, (void *) pop);
  rc = POPaccount->Connect(popprocessstate.connectobj);
  dprintf(("Eng", "Trying to connect to POP, rc=%d\n",rc));

  return rc;

}


ELib_rcode SMTPAccountConnect(void)
{

  ELib_rcode rc;

  smtpprocessstate.connectobj = new MBoxOpCB_connect((MBoxCBHandlerFn) MBoxCallback, (void *) smtp);
  rc = SMTPaccount->Connect(smtpprocessstate.connectobj);
  dprintf(("Eng", "Trying to connect to SMTP, rc=%d\n",rc));

  return rc;

}


ELib_rcode POPAccountDisconnect(void)
{

  if (popstatus == acctconnected)
  {
    popprocessstate.disconnectobj = new MBoxOpCB_disconnect((MBoxCBHandlerFn) MBoxCallback, (void *) pop);
    return POPaccount->Disconnect(popprocessstate.disconnectobj);
  }
  else /* if (state & DISCONNECT) */
    popprocessstate.context = disconnected;

  return ELIB_COMPLETED;

}


ELib_rcode SMTPAccountDisconnect(void)
{

  if (smtpstatus == acctconnected)
  {
    smtpprocessstate.disconnectobj = new MBoxOpCB_disconnect((MBoxCBHandlerFn) MBoxCallback, (void *) smtp);
    return SMTPaccount->Disconnect(smtpprocessstate.disconnectobj);
  }
  else /* if (state & DISCONNECT) */
    smtpprocessstate.context = disconnected;

  return ELIB_COMPLETED;

}


void RemoveObj(MBoxOpCB **obj)
{

  if (*obj)
    delete *obj;
  *obj = 0;
}


void StartOffSMTP(void)
{

  ++smtpprocessstate.attempts;
  smtpprocessstate.context = readytosend;
  state |= PROCESSSMTP;
  outbox = (SendQMailbox *) SMTPaccount->GetInbox();

}


/*
** StartProcess() initiates the processing of the mailbox via callback.
** The POP and SMTP mailboxes are processed in parallel.
*/

void StartProcess(void)
{
  
  dprintf(("Eng", "Free memory = %dK\n",FreeMem()/1024));

  newmail = 0;
  popmbox->flags &= ~MBOXINCOMPLETE;
  StopReconnectCount();

  /*
  ** Set up initial contexts depending on whether POP
  ** and/or SMTP accounts have been successfully created.
  */

  if (popstatus > acctnonexistent)
  {
    popprocessstate.context = readytodisconnect;
    popmbox->flags &= ~CHANGED;
    state |= PROCESSPOP;
    ActivatePOP();
    inbox = POPaccount->GetInbox();
  }
  if (smtpstatus > acctnonexistent)
    StartOffSMTP();

}


void DeadPOP(bool b, void *h)
{

  (void)(b);
  (void)(h);
  ProcessDone();

}


void CleanupOutbox(void)
{

  MessageDescriptor *msgptr, *nextptr;

  msgptr = smtpmbox->list;
  while (msgptr)
  {
    nextptr = msgptr->next;
    SetFilename(msgptr->ID, true);
    if (nb_file_exists(1, msgfilename, 0, 0))
      DestroyDescriptor(msgptr, smtpmbox);
    msgptr = nextptr;
  }

}


void DealWithFailure(void)
{

  smtpprocessstate.context = idle;
  if (state & SEND)
  {
    sendstate.ret.code = ENG_SENDUNSUCCESSFUL;
    (*callbacklist.sendfunc)(&sendstate.ret, callbacklist.sendhandle);
    state &= ~SEND;
  }

  dprintf(("Eng", "Have now made %d SMTP attempts\n",smtpprocessstate.attempts));
  if (smtpprocessstate.attempts > 3)
  {
    statusret.code = ENG_CONFIRMRESEND;
    (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, ConfirmResend);
  }
  else
    StartRetryCount();

}


void DoSMTPProcess(void)
{

  ELib_rcode rc;
  uint32 n;

  switch (smtpprocessstate.context)
  {
    case readytosend :

      dprintf(("Eng", "SMTP context = readytosend\n"));
      smtpprocessstate.context = idle;
      if (sendpending)
      {
        rc = SMTPAccountConnect();
        if (rc < 0)
        {
          smtpprocessstate.ret.rc = rc;
          smtpprocessstate.context = connectfailure;
        }
      }

      else
      {
        /* no messages in send queue, so don't connect */
        smtpprocessstate.context = disconnected;
      }

      break;

    case connected :

      dprintf(("Eng", "SMTP context = connected\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.connectobj);
      smtpstatus = acctconnected;

      smtpprocessstate.context = idle;
      smtpprocessstate.processobj = new MBoxOpCB_process((MBoxCBHandlerFn) MBoxCallback, (void *) smtp);
      rc = outbox->Process(smtpprocessstate.processobj);
      dprintf(("Eng", "Processing SMTP mailbox, rc=%d\n",rc));

      if (rc < 0)
      {
        smtpprocessstate.ret.rc = rc;
        smtpprocessstate.context = processfailure;
      }

      break;

    case connectfailure :

      /* connection has failed */
      dprintf(("Eng", "SMTP context = connectfailure\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.connectobj);
      DealWithFailure();
      state &= ~PROCESSSMTP;

      break;

    case processfailure :

      /* processing has failed */
      dprintf(("Eng", "SMTP context = processfailure\n",));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.processobj);
      DealWithFailure();
      smtpprocessstate.context = readytodisconnect;

      break;

    case readytoexpunge :

      dprintf(("Eng", "SMTP context = smptdone\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.processobj);
      if (smtpstatus == acctconnected)
      {
        smtpprocessstate.context = idle;
        smtpprocessstate.expungeobj = new MBoxOpCB_expunge((MBoxCBHandlerFn) MBoxCallback, (void *) smtp);
        rc = outbox->Expunge(smtpprocessstate.expungeobj);
        dprintf(("Eng", "Expunging SMTP mailbox, rc=%d\n",rc));

        if (rc < 0)
        {
          /* error expunging SMTP */
          smtpprocessstate.ret.rc = rc;
          smtpprocessstate.context = expunged;
        }
      }
      else
        smtpprocessstate.context = disconnected;

      break;

    case expunged :

      RemoveObj((MBoxOpCB**) &smtpprocessstate.expungeobj);
      smtpprocessstate.getnumobj = new MBoxOpCB_getnummsgs((MBoxCBHandlerFn) MBoxCallback, (void *) smtp);
      rc = outbox->GetNumberMessages(smtpprocessstate.getnumobj);
      if (rc < 0)
      {
        smtpprocessstate.context = getnumfailure;
        smtpprocessstate.ret.rc = rc;
      }

      break;

    case gotnumber :

      dprintf(("Eng", "SMTP context = gotnumber\n"));
      n = smtpprocessstate.getnumobj->number_messages;
      dprintf(("Eng", "Number of messages still in send queue=%d\n",n));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.getnumobj);
      if (n)
      {
        /* send has failed for some reason */
        DealWithFailure();
      }

      else
      {
        /* all messages have been sent */
        sendpending = false;
        smtpprocessstate.ret.code = ENG_SENTMSG;
        StopRetryCount();
      }

      smtpprocessstate.context = readytodisconnect;

      break;

    case readytodisconnect :

      SMTPAccountDisconnect();

      break;

    case getnumfailure :

      dprintf(("Eng", "SMTP context = getnumfailure\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.getnumobj);
      smtpprocessstate.context = readytodisconnect;

      break;

    case disconnected :
    case disconnectfailure :

      dprintf(("Eng", "SMTP context = disconnected\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.disconnectobj);
      CleanupOutbox();
      smtpstatus = acctcreated;
      state &= ~PROCESSSMTP;

      if (state & SEND)
      {
        (*callbacklist.sendfunc)(&smtpprocessstate.ret, callbacklist.sendhandle);
        state &= ~SEND;
      }        

      if ((state & DISCONNECT) && (!(state & PROCESSPOP)))
      {
        state &= ~DISCONNECT;
        DisconnectFromISP();
      }

      break;

  }

}


#ifdef ALAN
/***************Temporary debugging code***************/

void TempList(void)
{

  FILE *f;
  char fname[32];
  MessageDescriptor *msgptr = popmbox->list;
  uint32 i = 1, n = popprocessstate.msglist->Size();

  sprintf(fname, "NFS::NCB.$.Debug.OurList%d\0",filecount1);
  f = fopen(fname, "w");
  while (msgptr)
  {
    fprintf(f, "%d:\t0x%x\n",msgptr->ID,msgptr->mboxobj);
    msgptr = msgptr->next;
  }
  fprintf(f, "\n");
  msgptr = transmbox->list;
  while (msgptr)
  {
    fprintf(f, "%d:\t0x%x\n",msgptr->ID,msgptr->mboxobj);
    msgptr = msgptr->next;
  }
  fclose(f);
  MakeFilePublic(fname);

  sprintf(fname, "NFS::NCB.$.Debug.MBList%d\0",filecount1++);
  f = fopen(fname, "w");
  popprocessstate.msglist->Reset();  
  while (n--)
  {
    popprocessstate.msglist->Next();
    fprintf(f, "%d:\t0x%x\n",i++,popprocessstate.msglist->Current());
  }
  fclose(f);
  MakeFilePublic(fname);

}

/***************End of debugging code***************/
#endif


void ReconcileMboxPart1(void)
{

  uint32 num;

  num = popprocessstate.getnumobj->number_messages;
  dprintf(("Eng", "Number of messages=%d\n",num));
  RemoveObj((MBoxOpCB**) &popprocessstate.getnumobj);
  if (firstprocess)
  {
    popstat->data.totalmsgs = num;
    popstat->flags = 0;
    popstat->tag = messagesfound;
    ncmui_connection_status(popstat);
  }

  popprocessstate.msglist = &inbox->GetMessages();
  popprocessstate.msg = popmbox->list;
  statusret.rc = ELIB_RUNNING;  
  popprocessstate.context = checkourlist;
  
#ifdef ALAN
  /* temporary debugging call */
  TempList();
#endif

}


void ReconcileMboxPart2(void)
{

  popprocessstate.msglist->Reset();
  popprocessstate.context = checkmboxlist;

}


/*
** OnMboxList() checks a mailbox object pointer against the
** mailbox's list to see if it is on the list.
*/

bool OnMboxList(Message *obj)
{

  uint32 n = popprocessstate.msglist->Size();

  popprocessstate.msglist->Reset();  
  while (n--)
  {
    popprocessstate.msglist->Next();
    if ((Message *) popprocessstate.msglist->Current() == obj)
      return true;
  }

  return false;

}


/*
** OnOurList() checks a mailbox object pointer against our list
** to see if it is on the list.
*/

bool OnOurList(Message *obj)
{

  MessageDescriptor *msgptr = popmbox->list;

  while (msgptr)
  {
    if (msgptr->mboxobj == obj)
      return true;
    else
      msgptr = msgptr->next;
  }

  if (transmbox->total)
  {
    msgptr = transmbox->list;

    while (msgptr)
    {
      if (msgptr->mboxobj == obj)
        return true;
      else
        msgptr = msgptr->next;
    }
  }

  return false;

}


MessageDescriptor *CheckOurList(MessageDescriptor *msg)
{

  MessageDescriptor *nextptr = msg->next;

  if (!OnMboxList(msg->mboxobj))
  {
    /* must have been deleted so destroy descriptor */
    dprintf(("Eng", "Deleting message %d at 0x%x not on mailbox list\n",msg->ID,msg));
    DestroyDescriptor(msg, popmbox);
    popmbox->flags |= CHANGED;
  }

  return nextptr;

}


bool CheckMboxList(void)
{

  MessageDescriptor *msgptr;
  ELib_rcode rc;
  Message::Flags flags;
  Message *obj;

  popprocessstate.msglist->Next();
  if (popprocessstate.msglist->Nul())
    return true;

  obj = (Message *) popprocessstate.msglist->Current();
  if ((firstprocess) || (!OnOurList(obj)))
  {
    /* must be an unknown message so create new descriptor */
    if ((msgptr = NewDescriptor(0, transmbox, true)) == 0)
    {
      /* there was not enough memory to create descriptor */
      dprintf(("Eng", "***ERROR*** Malloc failure\n"));
      statusret.rc = ELIB_EMALLOCFAILED;
      return true;
    }
    else
    {
      popmbox->flags |= CHANGED;
      msgptr->mboxobj = obj;
      rc = obj->GetFlags(flags, Message::Set);
      if (rc >= 0)
      {
        if (flags & Message::Read)
          msgptr->flags |= READ;
        if (flags & Message::New)
        {
          ++newmail;
          msgptr->flags |= NEW;
        }
      }
      msgptr->flags |= NEWLYCREATED;
    }
  }

  return false;

}


void DoPOPProcess(void)
{

  ELib_rcode rc;
  clock_t t;
  time_t tim;
  bool finished;

  switch (popprocessstate.context)
  {

    case readytodisconnect :

      /* need to ensure we are disconnected before processing */
      dprintf(("Eng", "POP process context = readytodisconnect, state=0x%x\n",state));
      if ((popstatus == acctcreated) && (!(state & (DISCONNECT | TIMEOUT))))
      {
        /* OK, we're not connected, go ahead */
        dprintf(("Eng", "POP not connected\n"));
        popprocessstate.context = readytoconnect;
      }

      else
      {
        popprocessstate.context = idle;
        POPAccountDisconnect();
      }

      break;        

    case readytoconnect :

      dprintf(("Eng", "POP context = readytoconnect\n"));
      popprocessstate.context = idle;
      retrievestate.context = idle;
      if (popstatus == acctconnected)
        popprocessstate.context = connected;
      else
      {
        rc = POPAccountConnect();
        if (rc < 0)
        {
          popprocessstate.ret.rc = rc;
          popprocessstate.ret.code = ENG_POPCONNECTFAIL;
          popprocessstate.context = connectfailure;
        }
      }

      break;

    case connected :

      dprintf(("Eng", "POP context = connected\n"));
      RemoveObj((MBoxOpCB**) &popprocessstate.connectobj);
      popstatus = acctconnected;

      if (firstprocess)
      {
        popstat->flags = 0;
        popstat->tag = processinginbox;
        ncmui_connection_status(popstat);
      }

      popprocessstate.context = idle;
      popprocessstate.processobj = new MBoxOpCB_process((MBoxCBHandlerFn) MBoxCallback, (void *) pop);
      rc = inbox->Process(popprocessstate.processobj);
      tim = time(0);
      dprintf(("Eng", "Processing POP mailbox, rc=%d, state = 0x%x, at %s\n",rc,state,ctime(&tim)));

      if (rc < 0)
      {
        if (state & RETRIEVEMSG)
        {
          state &= ~PROCESSPOP;
          retrievestate.context = readytoretrieve;
        }
        else
        {
          statusret.rc = rc;
          popprocessstate.context = processfailure;
        }
      }

      break;

    case readytoexpunge :

      dprintf(("Eng", "POP context = readytoexpunge\n"));
      popprocessstate.changed = popprocessstate.processobj->mailbox_changed;
      dprintf(("Eng", "Mailbox has %schanged\n",(popprocessstate.changed) ? "" : "not "));

      RemoveObj((MBoxOpCB**) &popprocessstate.processobj);
      popprocessstate.context = idle;
      markstate.context = idle;
      popprocessstate.expungeobj = new MBoxOpCB_expunge((MBoxCBHandlerFn) MBoxCallback, (void *) pop);
      rc = inbox->Expunge(popprocessstate.expungeobj);
      dprintf(("Eng", "Expunging POP mailbox, rc=%d\n",rc));

      if (rc < 0)
      {
        if (state & RETRIEVEMSG)
        {
          state &= ~PROCESSPOP;
          retrievestate.context = readytoretrieve;
        }
        else
        {
          popmbox->flags |= MBOXINCOMPLETE;
          popprocessstate.context = done;
        }
      }

      break;

    case connectfailure :

      /* connection has failed */
      dprintf(("Eng", "POP context = connectfailure\n",));
      RemoveObj((MBoxOpCB**) &popprocessstate.connectobj);
      popprocessstate.context = idle;
/*       state &= ~(PROCESSPOP + POPCONNECT); */
      state &= ~PROCESSPOP;
      DeactivatePOP();
      statusret.rc = popprocessstate.ret.rc;
      switch (statusret.rc)
      {
        case ELIB_EMALLOCFAILED :
          statusret.code = ENG_NOMEMORY;
          break;

        case ELIB_ECONREFUSED :
        case ELIB_ECONFAILED :

          statusret.code = ENG_POPCONNECTFAIL;
          break;

        case ELIB_EINVALIDUSERNAME :
        case ELIB_EINVALIDPASSWORD :

          statusret.code = ENG_AUTHORISATIONFAILED;
          break;

        case ELIB_ECONTIMEDOUT :

          statusret.code = ENG_POPTIMEOUT;
          break;

        default :
          statusret.code = ENG_POPCONNECTFAIL;
      }

      if (state & RETRIEVEMSG)
        retrievestate.context = connectfailure;

      else
        (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, 0);

      break;

    case processfailure :

      /* processing has failed */
      dprintf(("Eng", "POP context = processfailure\n",));
      RemoveObj((MBoxOpCB**) &popprocessstate.processobj);
      popprocessstate.context = idle;
      statusret.code = (statusret.rc == ELIB_EMALLOCFAILED) ? ENG_NOMEMORY : ENG_CANTPROCESSPOP;
      (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, DeadPOP);

      break;

    case expunged :

      dprintf(("Eng", "POP context = expunged\n"));
      RemoveObj((MBoxOpCB**) &popprocessstate.expungeobj);


      if (state & MARKDELETE)
        state &= ~MARKDELETE;

      if (state & RETRIEVEMSG)
        retrievestate.context = readytoretrieve;

      popprocessstate.context = done;

      break;

    case done :

      dprintf(("Eng", "POP context = done\n"));
      if ((popprocessstate.changed) || (popmbox->flags & (MBOXINCOMPLETE | DOWNLOADINCOMPLETE)))
      {
        popprocessstate.getnumobj = new MBoxOpCB_getnummsgs((MBoxCBHandlerFn) MBoxCallback, (void *) pop);
        rc = inbox->GetNumberMessages(popprocessstate.getnumobj);
        if (rc < 0)
        {
          popprocessstate.context = getnumfailure;
          statusret.rc = rc;
        }
      }

      else
      {
        /* mailbox hasn't changed so no new mail */
        ProcessDone();
      }

      break;

    case disconnected :
    case disconnectfailure :

      dprintf(("Eng", "POP context = disconnected, state=0x%x\n",state));
      RemoveObj((MBoxOpCB**) &popprocessstate.disconnectobj);
      popstatus = acctcreated;
      if (state & TIMEOUT)
      {
        state &= ~(PROCESSPOP + TIMEOUT);
        if (disconnectpending)
        {
          dprintf(("Eng", "Disconnect pending while timeout\n"));
          DisconnectLine();
        }
      }

      else if (state & DISCONNECT)
      {
        if (!(state & PROCESSSMTP))
        {
          state &= ~(DISCONNECT + PROCESSPOP);
          DisconnectFromISP();
        }
      }

      else
        popprocessstate.context = readytoconnect;

      break;

    case gotnumber :

      dprintf(("Eng", "POP context = gotnumber\n"));
      ReconcileMboxPart1();
      break;

    case getnumfailure :

      dprintf(("Eng", "POP context = getnumfailure\n"));
      popprocessstate.context = idle;
      RemoveObj((MBoxOpCB**) &popprocessstate.getnumobj);
      statusret.code = ENG_CANTPROCESSPOP;
      (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, DeadPOP);

    case checkourlist :

      /* check through our list to see if any are missing
         from mailbox's list, and destroy them */

      dprintf(("Eng", "POP process context = checkourlist\n"));
      t = clock();
      while (((clock() - t) < 10) && (popprocessstate.msg))
        popprocessstate.msg = CheckOurList(popprocessstate.msg);

      if (!popprocessstate.msg)
      {
        /* ready to go on to second stage of reconcile */
        ReconcileMboxPart2();
        break;
      }

      break;

    case checkmboxlist :

      dprintf(("Eng", "POP process context = checkmboxlist\n"));
      t = clock();
      finished = false;
      while (((clock() - t) < 10) && (!finished))
        finished = CheckMboxList();
      
      if (finished)
      {
        if (statusret.rc == ELIB_EMALLOCFAILED)
          popprocessstate.context = processfailure;
        else
          ProcessDone();
      }

      break;
  }
}


void ProcessDone(void)
{

  dprintf(("Eng", "Entering ProcessDone(), mailbox is %schanged\n",(popmbox->flags & CHANGED) ? "" : "not "));
  state &= ~PROCESSPOP;
  if (popmbox->flags & (CHANGED | MBOXINCOMPLETE | DOWNLOADINCOMPLETE))
  {
    if ((online) && (!disconnectpending))
    {
      /* go off and get headers for Inbox */
      popmbox->flags &= ~MBOXINCOMPLETE;
      downloadstate.msg = transmbox->list;
      downloadstate.context = startdownload;
      parsehdrstate.context = idle;
      downloadstate.ret.code = ENG_COMPLETED;
      hdrsdownloaded = false;
      state |= DOWNLOADHDR;
    }

  }

  else
  {
    popmbox->flags |= MBOXPROCESSED;
    popprocessstate.ret.code = ENG_COMPLETED;
    /* not changed - no need to send prompt to UI */
    DeactivatePOP();
    StartReconnectCount();
  }

  if (disconnectpending)
    DisconnectPending();
  
  else if ((!online) && (!emailactive))
  {
    /*
    ** NOTE: we only notify here if not online.
    ** If we are online, the notification happens after
    ** downloading headers.
    */
    NotifyBrowser(newmail);
  }

}


void SortByDate(MessageDescriptor *newmsg)
{

  MessageDescriptor *msgptr = popmbox->list, *lastptr = 0;

  if (newmsg->next)
    newmsg->next->last = 0;

  if (!msgptr)
  {
    popmbox->list = newmsg;
    newmsg->next = 0;
    newmsg->last = 0;
  }

  else
  {
    while (msgptr)
    {
      if (mktime(newmsg->datestruct) >= mktime(msgptr->datestruct))
        break;
      lastptr = msgptr;
      msgptr = msgptr->next;
    }

    if (!msgptr)
    {
      lastptr->next = newmsg;
      newmsg->last = lastptr;
      newmsg->next = 0;
    }
    else
    {
      newmsg->next = msgptr;
      newmsg->last = msgptr->last;
      msgptr->last = newmsg;
      if (newmsg->last)
        newmsg->last->next = newmsg;
      else
        popmbox->list = newmsg;
    }
  }

  --transmbox->total;
  ++popmbox->total;

}        
  
  
void DoMark(void)
{

  ELib_rcode rc;

  switch (markstate.context)
  {
    case readytomark :

      dprintf(("Eng", "Mark context = readytomark\n"));
      markstate.context = idle;
      if (state & MARKDELETE)
      {
        /* mark for delete process */

        if (markstate.current == markstate.total)
        {
          /* all messages marked for deletion */
          dprintf(("Eng", "All messages marked\n"));
          free(markstate.list);

          /* send message to UI to display Inbox */
          (*callbacklist.promptfunc)(&markstate.ret, popmbox->list, online, callbacklist.prompthandle);

          /************************************
          *** ATTENTION
          ************************************/
          /*
          ** Should we reconnect immediately to POP server if online,
          ** or wait until the next time a connection is made?
          ** If the former, uncomment the following line and remove
          ** the one after.
          */

/*           if ((online) && (!(state & TIMEOUT))) */
          if ((popstatus == acctconnected) && (!(state & TIMEOUT)))
          {
            if (popactive)
            {
              dprintf(("Eng", "Setting expungepending flag\n"));
              expungepending = true;
            }
            else
            {
              /* expunge mailbox now */
              ActivatePOP();
              popprocessstate.context = readytoconnect;
              state |= PROCESSPOP;
            }
          }
          else
            state &= ~MARKDELETE;
        }

        else
        {
          MessageDescriptor *msg = FindDescriptor(markstate.list[markstate.current], popmbox);
          if (!msg)
          {
            dprintf(("Eng", "Unknown message ID %d\n",msg->ID));
            markstate.context = markfailure;
          }
          else
          {
            markstate.msg = msg;
            markstate.context = marking;
          }
        }
      }

      else
        markstate.context = marking;

      break;

    case marking :

      markstate.setobj = new MBoxOpCB_setflags((MBoxCBHandlerFn) MBoxCallback, 0);
      rc = markstate.msg->mboxobj->SetFlags(markstate.setobj, (state & MARKDELETE) ? Message::Delete : Message::Read, Message::Set);
      if (rc < 0)
      {
        /* mailbox has signalled an error in marking */
        dprintf(("Eng", "***ERROR*** Error calling SetFlags, rc=%d\n",rc));
        markstate.ret.rc = rc;
        markstate.context = markfailure;
      }

      break;

    case markfailure :

      dprintf(("Eng", "Mark context = markfailure\n"));
      RemoveObj((MBoxOpCB**) &markstate.setobj);
      markstate.ret.code = ENG_MARKFAILED;
      if (state & MARKDELETE)
      {
        ++markstate.current;
        markstate.context = readytomark;
      }
      else
        markstate.context = readdone;

      break;

    case readdone :

      dprintf(("Eng", "Mark context = readdone\n"));
      RemoveObj((MBoxOpCB**) &markstate.setobj);
      state &= ~MARKREAD;

      break;

    case deletedone :

      dprintf(("Eng", "Mark context = deletedone\n"));
      {
        uint32 flags;
        markstate.msg->mboxobj->GetFlags(flags, Message::Set);
        dprintf(("Eng", "Deleted message flags=%d\n",flags));
      }
      RemoveObj((MBoxOpCB**) &markstate.setobj);
      DestroyDescriptor(markstate.msg, popmbox);
      ++markstate.current;
      markstate.context = readytomark;

      break;
  }
}
