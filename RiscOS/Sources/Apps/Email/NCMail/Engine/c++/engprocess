/*
** Email Client
** Mailbox interface
*/

#include "time.h"
#include "stdlib.h"
#include "swis.h"

#include "Email/Common/list.h"
#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "DebugLib/DebugLib.h"

#include "Email/Mailbox/Account.h"
#include "Email/Mailbox/POP3/POP3Account.h"
#include "Email/Mailbox/SendQ/SendQAccount.h"
#include "Email/Mailbox/SendQ/SendQMailbox.h"
#include "Email/Mailbox/Mailbox.h"
#include "Email/Mailbox/MBoxCB.h"
#include "Email/Mailbox/Message.h"
#include "Email/Mailbox/MBoxOpCB/connect.h"
#include "Email/Mailbox/MBoxOpCB/disconnect.h"
#include "Email/Mailbox/MBoxOpCB/process.h"
#include "Email/Mailbox/MBoxOpCB/getnummsgs.h"
#include "Email/Mailbox/MBoxOpCB/expunge.h"

#include "engevent.h"
#include "engtypes.h"
#include "enguiapi.h"
#include "engmanager.h"
#include "enginit.h"
#include "engcbf.h"
#include "engprocess.h"
#include "engfile.h"
#include "engparse.h"
#include "engsend.h"


Account *POPaccount, *SMTPaccount;
Mailbox *inbox;
SendQMailbox *outbox;
bool newmail = false, reprocess = false, processpending;

void ProcessDone(bool changed);


ELib_rcode POPAccountConnect(void)
{

  ELib_rcode rc;

  popprocessstate.connectobj = new MBoxOpCB_connect((MBoxCBHandlerFn) MBoxCallback, (void *) pop);
  rc = POPaccount->Connect(popprocessstate.connectobj);
  dprintf(("Eng", "Trying to connect to POP, rc=%d\n",rc));

  return rc;

}


ELib_rcode SMTPAccountConnect(void)
{

  ELib_rcode rc;

  smtpprocessstate.connectobj = new MBoxOpCB_connect((MBoxCBHandlerFn) MBoxCallback, (void *) smtp);
  rc = SMTPaccount->Connect(smtpprocessstate.connectobj);
  dprintf(("Eng", "Trying to connect to SMTP, rc=%d\n",rc));

  return rc;

}


ELib_rcode POPAccountDisconnect(void)
{

  if (popstatus == acctconnected)
  {
    popprocessstate.disconnectobj = new MBoxOpCB_disconnect((MBoxCBHandlerFn) MBoxCallback, (void *) pop);
    return POPaccount->Disconnect(popprocessstate.disconnectobj);
  }
  else /* if (state & DISCONNECT) */
    popprocessstate.context = disconnected;

  return ELIB_COMPLETED;

}


ELib_rcode SMTPAccountDisconnect(void)
{

  if (smtpstatus == acctconnected)
  {
    smtpprocessstate.disconnectobj = new MBoxOpCB_disconnect((MBoxCBHandlerFn) MBoxCallback, (void *) smtp);
    return SMTPaccount->Disconnect(smtpprocessstate.disconnectobj);
  }
  else /* if (state & DISCONNECT) */
    smtpprocessstate.context = disconnected;

  return ELIB_COMPLETED;

}


void RemoveObj(MBoxOpCB **obj)
{

  if (*obj)
    delete *obj;
  *obj = 0;
}


void StartOffSMTP(void)
{

  ++smtpprocessstate.attempts;
  smtpprocessstate.context = readytosend;
  state |= PROCESSSMTP;
  outbox = (SendQMailbox *) SMTPaccount->GetInbox();

}


/*
** StartProcess() initiates the processing of the mailbox via callback.
** The POP and SMTP mailboxes are processed in parallel.
*/

void StartProcess(void)
{
  
  int32 temp;
  eng_mem_available(&temp);

  newmail = false;
  processpending = false;
  ourmboxin->flags &= ~MBOXINCOMPLETE;
  StopReconnectCount();

  /*
  ** Set up initial contexts depending on whether POP
  ** and/or SMTP accounts have been successfully created.
  */

  if (popstatus > acctnonexistent)
  {
    popprocessstate.context = readytodisconnect;
    popprocessstate.changed = false;
    state |= PROCESSPOP;
    ActivatePOP();
    inbox = POPaccount->GetInbox();
  }
  if (smtpstatus > acctnonexistent)
    StartOffSMTP();

}


void DeadPOP(bool b, void *h)
{

  (void)(b);
  (void)(h);
  ProcessDone(true);

}


void CleanupOutbox(void)
{

  MessageDescriptor *msgptr, *nextptr;

  dprintf(("Eng", "Cleaning up outbox\n"));
  msgptr = ourmboxout->list;
  while (msgptr)
  {
    nextptr = msgptr->next;
    SetFilename(msgptr->ID, true);
    if (!FileExists(msgfilename))
      DestroyDescriptor(msgptr, ourmboxout);
    msgptr = nextptr;
  }

}


void DealWithFailure(void)
{

  smtpprocessstate.context = idle;
  if (state & SEND)
  {
    sendstate.ret.code = ENG_SENDUNSUCCESSFUL;
    (*callbacklist.sendfunc)(&sendstate.ret, callbacklist.sendhandle);
    state &= ~SEND;
  }

  dprintf(("Eng", "Have now made %d SMTP attempts\n",smtpprocessstate.attempts));
  if (smtpprocessstate.attempts > 3)
  {
    statusret.code = ENG_CONFIRMRESEND;
    (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, ConfirmResend);
  }
  else
    StartRetryCount();

}


void DoSMTPProcess(void)
{

  ELib_rcode rc;
  uint32 n;

  switch (smtpprocessstate.context)
  {
    case readytosend :

      dprintf(("Eng", "SMTP context = readytosend\n"));
      smtpprocessstate.context = idle;
      if (sendpending)
      {
        rc = SMTPAccountConnect();
        if (rc < 0)
        {
          smtpprocessstate.ret.rc = rc;
          smtpprocessstate.context = connectfailure;
        }
      }

      else
      {
        /* no messages in send queue, so don't connect */
        smtpprocessstate.context = disconnected;
      }

      break;

    case connected :

      dprintf(("Eng", "SMTP context = connected\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.connectobj);
      smtpstatus = acctconnected;

      smtpprocessstate.context = idle;
      smtpprocessstate.processobj = new MBoxOpCB_process((MBoxCBHandlerFn) MBoxCallback, (void *) smtp);
      rc = outbox->Process(smtpprocessstate.processobj);
      dprintf(("Eng", "Processing SMTP mailbox, rc=%d\n",rc));

      if (rc < 0)
      {
        smtpprocessstate.ret.rc = rc;
        smtpprocessstate.context = processfailure;
      }

      break;

    case connectfailure :

      /* connection has failed */
      dprintf(("Eng", "SMTP context = connectfailure\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.connectobj);
      DealWithFailure();
      state &= ~PROCESSSMTP;

      break;

    case processfailure :

      /* processing has failed */
      dprintf(("Eng", "SMTP context = processfailure\n",));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.processobj);
      DealWithFailure();
      smtpprocessstate.context = readytodisconnect;

      break;

    case readytoexpunge :

      dprintf(("Eng", "SMTP context = smptdone\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.processobj);
      if (smtpstatus == acctconnected)
      {
        smtpprocessstate.context = idle;
        smtpprocessstate.expungeobj = new MBoxOpCB_expunge((MBoxCBHandlerFn) MBoxCallback, (void *) smtp);
        rc = outbox->Expunge(smtpprocessstate.expungeobj);
        dprintf(("Eng", "Expunging SMTP mailbox, rc=%d\n",rc));

        if (rc < 0)
        {
          /* error expunging SMTP */
          smtpprocessstate.ret.rc = rc;
          smtpprocessstate.context = expunged;
        }
      }
      else
        smtpprocessstate.context = disconnected;

      break;

    case expunged :

      RemoveObj((MBoxOpCB**) &smtpprocessstate.expungeobj);
      smtpprocessstate.getnumobj = new MBoxOpCB_getnummsgs((MBoxCBHandlerFn) MBoxCallback, (void *) smtp);
      rc = outbox->GetNumberMessages(smtpprocessstate.getnumobj);
      if (rc < 0)
      {
        smtpprocessstate.context = getnumfailure;
        smtpprocessstate.ret.rc = rc;
      }

      break;

    case gotnumber :

      dprintf(("Eng", "SMTP context = gotnumber\n"));
      n = smtpprocessstate.getnumobj->number_messages;
      dprintf(("Eng", "Number of messages still in send queue=%d\n",n));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.getnumobj);
      if (n)
      {
        /* send has failed for some reason */
        DealWithFailure();
      }

      else
      {
        /* all messages have been sent */
        sendpending = false;
        smtpprocessstate.ret.code = ENG_SENTMSG;
        StopRetryCount();
      }

      smtpprocessstate.context = readytodisconnect;

      break;

    case readytodisconnect :

      SMTPAccountDisconnect();

      break;

    case getnumfailure :

      dprintf(("Eng", "SMTP context = getnumfailure\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.getnumobj);
      smtpprocessstate.context = readytodisconnect;

      break;

    case disconnected :
    case disconnectfailure :

      dprintf(("Eng", "SMTP context = disconnected\n"));
      RemoveObj((MBoxOpCB**) &smtpprocessstate.disconnectobj);
      CleanupOutbox();
      smtpstatus = acctcreated;
      state &= ~PROCESSSMTP;

      if (state & SEND)
      {
        (*callbacklist.sendfunc)(&smtpprocessstate.ret, callbacklist.sendhandle);
        state &= ~SEND;
      }        

      if ((state & DISCONNECT) && (!(state & PROCESSPOP)))
      {
        state &= ~DISCONNECT;
        DisconnectFromISP();
      }

      break;

  }

}


void ReconcileMboxPart1(void)
{

  uint32 total = popprocessstate.getnumobj->number_messages;
  dprintf(("Eng", "Number of messages=%d\n",total));
  RemoveObj((MBoxOpCB**) &popprocessstate.getnumobj);
  popprocessstate.msglist = &inbox->GetMessages();
  popprocessstate.msg = ourmboxin->list;
  statusret.rc = ELIB_RUNNING;  
  popprocessstate.context = checkourlist;

}


void ReconcileMboxPart2(void)
{

  popprocessstate.msglist->Reset();

  if ((tempmbox = (MailboxDescriptor *) malloc(sizeof(MailboxDescriptor))) == 0)
  {
    dprintf(("Eng", "***ERROR*** Malloc failure setting up temp list\n"));
    statusret.rc = ELIB_EMALLOCFAILED;
    popprocessstate.context = processfailure;
  }
  else
  {
    tempmbox->total = 0;
    tempmbox->list = 0;
    popprocessstate.context = checkmboxlist;
  }
}


/*
** OnMboxList() checks a mailbox object pointer against the
** mailbox's list to see if it is on the list.
*/

bool OnMboxList(Message *obj)
{

  uint32 n = popprocessstate.msglist->Size();

  popprocessstate.msglist->Reset();  
  while (n--)
  {
    popprocessstate.msglist->Next();
    if ((Message *) popprocessstate.msglist->Current() == obj)
      return true;
  }

  return false;

}


/*
** OnOurList() checks a mailbox object pointer against our list
** to see if it is on the list.
*/

bool OnOurList(Message *obj)
{

  MessageDescriptor *msgptr = ourmboxin->list;

  while (msgptr)
  {
    if (msgptr->mboxobj == obj)
      return true;
    else
      msgptr = msgptr->next;
  }

  return false;

}


MessageDescriptor *CheckOurList(MessageDescriptor *msg)
{

  MessageDescriptor *nextptr = msg->next;

  if (!OnMboxList(msg->mboxobj))
  {
    /* must have been deleted so destroy descriptor */
    dprintf(("Eng", "Deleting message %d at 0x%x not on mailbox list\n",msg->ID,msg));
    DestroyDescriptor(msg, ourmboxin);
  }

  return nextptr;

}


bool CheckMboxList(void)
{

  MessageDescriptor *msgptr;
  ELib_rcode rc;
  Message::Flags flags;
  Message *obj;

  popprocessstate.msglist->Next();
  if (popprocessstate.msglist->Nul())
    return true;

  obj = (Message *) popprocessstate.msglist->Current();
  if (!OnOurList(obj))
  {
    /* must be an unknown message so create new descriptor */
    if ((msgptr = NewDescriptor(0, tempmbox)) == 0)
    {
      /* there was not enough memory to create descriptor */
      dprintf(("Eng", "***ERROR*** Malloc failure\n"));
      statusret.rc = ELIB_EMALLOCFAILED;
      return true;
    }
    else
    {
      msgptr->mboxobj = obj;
      rc = obj->GetFlags(flags, Message::Set);
      if (rc >= 0)
      {
        if (flags & Message::Read)
          msgptr->flags |= READ;
        if (flags & Message::New)
        {
          newmail = true;
          msgptr->flags |= NEW;
        }
      }
      msgptr->flags |= NEWLYCREATED;
    }
  }

  return false;

}


void DoPOPProcess(void)
{

  ELib_rcode rc;
  clock_t t;
  bool finished;

  switch (popprocessstate.context)
  {

    case readytodisconnect :

      /* need to ensure we are disconnected before processing */
      dprintf(("Eng", "POP process context = readytodisconnect, state=0x%x\n",state));
      if ((popstatus == acctcreated) && (!(state & (DISCONNECT | TIMEOUT))))
      {
        /* OK, we're not connected, go ahead */
        dprintf(("Eng", "POP not connected\n"));
        popprocessstate.context = readytoconnect;
      }

      else
      {
        popprocessstate.context = idle;
        POPAccountDisconnect();
      }

      break;        

    case readytoconnect :

      dprintf(("Eng", "POP context = readytoconnect\n"));
      popprocessstate.context = idle;
      retrievestate.context = idle;
      if (popstatus == acctconnected)
        popprocessstate.context = connected;
      else
      {
        rc = POPAccountConnect();
        if (rc < 0)
        {
          popprocessstate.ret.rc = rc;
          popprocessstate.ret.code = ENG_POPCONNECTFAIL;
          popprocessstate.context = connectfailure;
        }
      }

      break;

    case connected :

      dprintf(("Eng", "POP context = connected\n"));
      RemoveObj((MBoxOpCB**) &popprocessstate.connectobj);
      popstatus = acctconnected;

      if (state & MARKDELETE)
        popprocessstate.context = readytoexpunge;

      else
      {
        popprocessstate.context = idle;
        popprocessstate.processobj = new MBoxOpCB_process((MBoxCBHandlerFn) MBoxCallback, (void *) pop);
        rc = inbox->Process(popprocessstate.processobj);
        dprintf(("Eng", "Processing POP mailbox, rc=%d\n",rc));

        if (rc < 0)
        {
          if (state & RETRIEVEMSG)
          {
            state &= ~PROCESSPOP;
            retrievestate.context = readytoretrieve;
          }
          else
          {
            statusret.rc = rc;
            popprocessstate.context = processfailure;
          }
        }
      }

      break;

    case readytoexpunge :

      dprintf(("Eng", "POP context = readytoexpunge\n"));
      if (popprocessstate.processobj)
        popprocessstate.changed = popprocessstate.processobj->mailbox_changed;
      RemoveObj((MBoxOpCB**) &popprocessstate.processobj);
      popprocessstate.context = idle;
      markstate.context = idle;
      popprocessstate.expungeobj = new MBoxOpCB_expunge((MBoxCBHandlerFn) MBoxCallback, (void *) pop);
      rc = inbox->Expunge(popprocessstate.expungeobj);
      dprintf(("Eng", "Expunging POP mailbox, rc=%d\n",rc));

      if (rc < 0)
      {
        if (state & RETRIEVEMSG)
        {
          state &= ~PROCESSPOP;
          retrievestate.context = readytoretrieve;
        }
        else
        {
          ourmboxin->flags |= MBOXINCOMPLETE;
          popprocessstate.context = done;
        }
      }

      break;

    case connectfailure :

      /* connection has failed */
      dprintf(("Eng", "POP context = connectfailure\n",));
      RemoveObj((MBoxOpCB**) &popprocessstate.connectobj);
      popprocessstate.context = idle;
      state &= ~PROCESSPOP;
      DeactivatePOP();
      statusret.rc = popprocessstate.ret.rc;
      switch (statusret.rc)
      {
        case ELIB_EMALLOCFAILED :
          statusret.code = ENG_NOMEMORY;
          break;

        case ELIB_ECONREFUSED :
        case ELIB_ECONFAILED :

          statusret.code = ENG_POPCONNECTFAIL;
          break;

        case ELIB_EINVALIDUSERNAME :
        case ELIB_EINVALIDPASSWORD :

          statusret.code = ENG_AUTHORISATIONFAILED;
          break;

        case ELIB_ECONTIMEDOUT :

          statusret.code = ENG_POPTIMEOUT;
          break;

        default :
          statusret.code = ENG_POPCONNECTFAIL;
      }

      if (state & RETRIEVEMSG)
        retrievestate.context = connectfailure;

      else
        (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, 0);

      break;

    case processfailure :

      /* processing has failed */
      dprintf(("Eng", "POP context = processfailure\n",));
      RemoveObj((MBoxOpCB**) &popprocessstate.processobj);
      popprocessstate.context = idle;
      statusret.code = (statusret.rc == ELIB_EMALLOCFAILED) ? ENG_NOMEMORY : ENG_CANTPROCESSPOP;
      (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, DeadPOP);

      break;

    case expunged :

      dprintf(("Eng", "POP context = expunged\n"));
      /* only set changed if Process hasn't already set it */
      if ((popprocessstate.expungeobj) && (!popprocessstate.changed))
        popprocessstate.changed = popprocessstate.expungeobj->mailbox_changed;
      RemoveObj((MBoxOpCB**) &popprocessstate.expungeobj);

      dprintf(("Eng", "Mailbox has %schanged\n",(popprocessstate.changed) ? "" : "not "));
      if (state & RETRIEVEMSG)
      {
        state &= ~PROCESSPOP;
        retrievestate.context = readytoretrieve;
        if (popprocessstate.changed)
          processpending = true;
        else
          StartReconnectCount();
      }

      else
        popprocessstate.context = done;

      break;
      
    case done :

      dprintf(("Eng", "POP context = done\n"));
      if ((popprocessstate.changed) || (ourmboxin->flags & (MBOXINCOMPLETE | DOWNLOADINCOMPLETE)))
      {
        popprocessstate.getnumobj = new MBoxOpCB_getnummsgs((MBoxCBHandlerFn) MBoxCallback, (void *) pop);
        rc = inbox->GetNumberMessages(popprocessstate.getnumobj);
        if (rc < 0)
        {
          popprocessstate.context = getnumfailure;
          statusret.rc = rc;
        }
      }

      else
      {
        /* mailbox hasn't changed so no new mail */
        ProcessDone(false);
      }

      break;

    case disconnected :
    case disconnectfailure :

      dprintf(("Eng", "POP context = disconnected, state=0x%x\n",state));
      RemoveObj((MBoxOpCB**) &popprocessstate.disconnectobj);
      popstatus = acctcreated;
      if (state & TIMEOUT)
      {
        state &= ~(PROCESSPOP + TIMEOUT);
        if (disconnectpending)
        {
          dprintf(("Eng", "Disconnect pending while timeout\n"));
          DisconnectLine();
        }
      }

      else if (state & DISCONNECT)
      {
        if (!(state & PROCESSSMTP))
        {
          state &= ~(DISCONNECT + PROCESSPOP);
          DisconnectFromISP();
        }
      }

      else
        popprocessstate.context = readytoconnect;

      break;

    case gotnumber :

      dprintf(("Eng", "POP context = gotnumber\n"));
      ReconcileMboxPart1();
      break;

    case getnumfailure :

      dprintf(("Eng", "POP context = getnumfailure\n"));
      popprocessstate.context = idle;
      RemoveObj((MBoxOpCB**) &popprocessstate.getnumobj);
      statusret.code = ENG_CANTPROCESSPOP;
      (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, DeadPOP);

    case checkourlist :

      /* check through our list to see if any are missing
         from mailbox's list, and destroy them */

      t = clock();
      while (((clock() - t) < 10) && (popprocessstate.msg))
        popprocessstate.msg = CheckOurList(popprocessstate.msg);

      if (!popprocessstate.msg)
      {
        /* ready to go on to second stage of reconcile */
        ReconcileMboxPart2();
        break;
      }

      break;

    case checkmboxlist :

      t = clock();
      finished = false;
      while (((clock() - t) < 10) && (!finished))
        finished = CheckMboxList();
      
      if (finished)
      {
        if (statusret.rc == ELIB_EMALLOCFAILED)
          popprocessstate.context = processfailure;
        else
          ProcessDone(true);
      }

      break;
  }
}


void ProcessDone(bool changed)
{

  dprintf(("Eng", "Entering ProcessDone(), mailbox is %schanged\n",(changed) ? "" : "not "));
  state &= ~PROCESSPOP;
  if (changed)
  {
    if (online)
    {
      /* go off and get headers for Inbox */
      ourmboxin->flags &= ~MBOXINCOMPLETE;
      downloadstate.msg = tempmbox->list;
      downloadstate.context = readytodownload;
      parsehdrstate.context = idle;
      downloadstate.ret.code = ENG_COMPLETED;
      hdrsdownloaded = false;
      state |= DOWNLOADHDR;
    }

    if (!emailactive)
    {
      if (newmail)
      {
        /* send an indication to the browser of new mail
           including number of new mails */
      }
      else
      {
        /* tell browser there's no new mail */
      }
    }
  }
  else
  {
    ourmboxin->flags |= MBOXPROCESSED;
    popprocessstate.ret.code = ENG_COMPLETED;
    (*callbacklist.promptfunc)(&popprocessstate.ret, ourmboxin->list, online, callbacklist.prompthandle);
    DeactivatePOP();
    StartReconnectCount();
  }

}


void SortByDate(MessageDescriptor *newmsg)
{

  MessageDescriptor *msgptr = ourmboxin->list, *lastptr = 0;

  if (newmsg->next)
    newmsg->next->last = 0;

  if (!msgptr)
  {
    dprintf(("Eng", "New message is first on mboxin\n"));
    ourmboxin->list = newmsg;
    newmsg->next = 0;
    newmsg->last = 0;
  }

  else
  {
    while (msgptr)
    {
      if (mktime(newmsg->datestruct) >= mktime(msgptr->datestruct))
        break;
      lastptr = msgptr;
      msgptr = msgptr->next;
    }

    if (!msgptr)
    {
/*       dprintf(("Eng", "Inserting new message at end of list\n")); */
      lastptr->next = newmsg;
      newmsg->last = lastptr;
      newmsg->next = 0;
    }
    else
    {
/*       dprintf(("Eng", "Inserting new message before message %d\n",msgptr->ID)); */
      newmsg->next = msgptr;
      newmsg->last = msgptr->last;
      msgptr->last = newmsg;
      if (newmsg->last)
        newmsg->last->next = newmsg;
      else
        ourmboxin->list = newmsg;
    }
  }

  --tempmbox->total;
  ++ourmboxin->total;

}        
  
  
void DoMark(void)
{

  ELib_rcode rc;

  switch (markstate.context)
  {
    case readytomark :

      dprintf(("Eng", "Mark context = readytomark\n"));
      markstate.context = idle;
      if (state & MARKDELETE)
      {
        /* mark for delete process */

        if (markstate.current == markstate.total)
        {
          /* all messages marked for deletion */
          dprintf(("Eng", "All messages marked\n"));
          free(markstate.list);

          /* send message to UI to display Inbox */
          dprintf(("Eng", "Prompting UI to display Inbox\n"));
          (*callbacklist.promptfunc)(&markstate.ret, ourmboxin->list, online, callbacklist.prompthandle);

          if ((online) && (!(state & TIMEOUT)))
          {
            if (popactive)
            {
              dprintf(("Eng", "Setting expungepending flag\n"));
              expungepending = true;
            }
            else
            {
              /* expunge mailbox now */
              dprintf(("Eng", "About to expunge\n"));
              ActivatePOP();
              popprocessstate.context = readytoconnect;
              state |= PROCESSPOP;
            }
          }
          else
            state &= ~MARKDELETE;
        }

        else
        {
          MessageDescriptor *msg = FindDescriptor(markstate.list[markstate.current], ourmboxin);
          if (!msg)
          {
            dprintf(("Eng", "Unknown message ID %d\n",msg->ID));
            markstate.context = markfailure;
          }
          else
          {
            markstate.msg = msg;
            markstate.context = marking;
          }
        }
      }

      else
        markstate.context = marking;

      break;

    case marking :

      markstate.setobj = new MBoxOpCB_setflags((MBoxCBHandlerFn) MBoxCallback, 0);
      rc = markstate.msg->mboxobj->SetFlags(markstate.setobj, (state & MARKDELETE) ? Message::Delete : Message::Read, Message::Set);
      if (rc < 0)
      {
        /* mailbox has signalled an error in marking */
        dprintf(("Eng", "***ERROR*** Error calling SetFlags, rc=%d\n",rc));
        markstate.ret.rc = rc;
        markstate.context = markfailure;
      }

      break;

    case markfailure :

      dprintf(("Eng", "Mark context = markfailure\n"));
      RemoveObj((MBoxOpCB**) &markstate.setobj);
      markstate.ret.code = ENG_MARKFAILED;
      if (state & MARKDELETE)
      {
        ++markstate.current;
        markstate.context = readytomark;
      }
      else
        markstate.context = readdone;

      break;

    case readdone :

      dprintf(("Eng", "Mark context = readdone\n"));
      RemoveObj((MBoxOpCB**) &markstate.setobj);
      state &= ~MARKREAD;

      break;

    case deletedone :
    {
      MessageDescriptor *msg = markstate.msg;
      uint32 flags;

      dprintf(("Eng", "Mark context = deletedone\n"));
      RemoveObj((MBoxOpCB**) &markstate.setobj);
      msg->flags |= MARKED;
      DestroyDescriptor(msg, ourmboxin);
      ++markstate.current;
      markstate.context = readytomark;

      msg->mboxobj->GetFlags(flags, Message::Set);
      dprintf(("Eng", "Message flags = %d\n",flags));
    
      break;
    }

  }

}
