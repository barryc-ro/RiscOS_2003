/*
** Email Client
** Mailbox interface
*/

#include "time.h"

#include "Email/Common/list.h"
#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "DebugLib/DebugLib.h"

#include "Email/Mailbox/Account.h"
#include "Email/Mailbox/POP3/POP3Accoun.h"
#include "Email/Mailbox/SendQ/SendQAccou.h"
#include "Email/Mailbox/Mailbox.h"
#include "Email/Mailbox/MBoxCB.h"
#include "Email/Mailbox/Message.h"
#include "Email/Mailbox/MBoxOpCB/connect.h"
#include "Email/Mailbox/MBoxOpCB/disconnect.h"
#include "Email/Mailbox/MBoxOpCB/process.h"
#include "Email/Mailbox/MBoxOpCB/getnummsgs.h"
#include "Email/Mailbox/MBoxOpCB/expunge.h"

#include "engevent.h"
#include "engtypes.h"
#include "enguiapi.h"
#include "engmanager.h"
#include "enginit.h"
/* #include "engdebug.h" */
#include "engcbf.h"
#include "engprocess.h"
#include "engfile.h"


Account *POPaccount, *SMTPaccount;
Mailbox *inbox, *outbox;
bool newmail = false;

void ProcessDone(bool changed);
void ReconcileMailbox(uint32 n);


eng_rcode POPAccountConnect(void)
{

  eng_rcode code;

  state.popprocess.connectobj = new MBoxOpCB_connect((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) pop);
  code = (eng_rcode) POPaccount->Connect(state.popprocess.connectobj);
  dprintf(("Eng", "Trying to connect to POP, rc=%d\n",code));

  return code;

}


eng_rcode SMTPAccountConnect(void)
{

  eng_rcode code;

  state.smtpprocess.connectobj = new MBoxOpCB_connect((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) smtp);
  code = (eng_rcode) SMTPaccount->Connect(state.smtpprocess.connectobj);
  dprintf(("Eng", "Trying to connect to SMTP, rc=%d\n",code));

  return code;

}


eng_rcode POPAccountDisconnect(void)
{

  if (state.popstatus == acctconnected)
  {
    state.popprocess.disconnectobj = new MBoxOpCB_disconnect((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) pop);
    return (eng_rcode) POPaccount->Disconnect(state.popprocess.disconnectobj);
  }
  else
    return ENG_COMPLETED;

}


eng_rcode SMTPAccountDisconnect(void)
{

  if (state.smtpstatus == acctconnected)
  {
    state.smtpprocess.disconnectobj = new MBoxOpCB_disconnect((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) smtp);
    return (eng_rcode) SMTPaccount->Disconnect(state.smtpprocess.disconnectobj);
  }
  else if (state.state & DISCONNECT)
    state.smtpprocess.substate = disconnected;

  return ENG_COMPLETED;

}


void RemoveObj(MBoxOpCB **obj)
{

  dprintf(("Eng", "Removing object at 0x%x\n",*obj));
  if (*obj)
    delete *obj;
  *obj = 0;
}


/*
** StartProcess() initiates the processing of the mailbox via callback.
**
** The process is as follows (assuming no errors):
**
** (1) PROCESS state is activated. This causes the rest of the process
**     to be executed in stages via null events.
** (2) readyforsending:    Connect to the SMTP account.
** (3a) connected:         on successful connection the SMTP mailbox
**                         is processed - i.e. queued messages are sent.
** (3b) connectfailure:    SMTP connection has failed.
** (4a) smtpdone:          SMTP account has been processed.
** (4b) processfailure:    SMTP processing failed.
** (5a) smtpdisconnected:  SMTP account has been disconnected,
                           now connect to POP.
** (5b) disconnectfailure: SMTP disconnection failure.
** (6a) connected:         on successful connection the POP mailbox
**                         is processed.
** (6b) connectfailure:    POP connection has failed.
** (7a) popdone:           POP account has been processed,
                           so get number of messages.
** (7b) processfailure:    POP processing failed.
** (8a) gotnumber:         Got number of messages, ready to
                           reconcile mailbox.
** (8b) getnumfailure:     Getting number of messages failed.
**
** Mailbox is now reconciled in ReconcileMailbox() described below.
** Finally ProcessDone() finishes the process ready for
** downloading headers.
*/

void StartProcess(void)
{

  newmail = false;
  ourmboxin->flags &= ~MBOXINCOMPLETE;

  /*
  ** Set up initial substates depending on whether POP
  ** and/or SMTP accounts have been successfully created.
  */

  if (state.popstatus != acctnonexistent)
  {
    inbox = POPaccount->GetInbox();
    state.popprocess.substate = readytoexpunge;
    state.state |= PROCESSPOP;
  }
  if (state.smtpstatus != acctnonexistent)
  {
    outbox = SMTPaccount->GetInbox();
    state.smtpprocess.substate = readytosend;
    state.state |= PROCESSSMTP;
  }

}


void DefunctPOP(bool b)
{
  state.state &= ~PROCESSPOP;
}


void DefunctSMTP(bool b)
{
  state.state &= ~PROCESSSMTP;
}


void DeadPOP(bool b)
{
  POPAccountDisconnect();
}


void DeadSMTP(bool b)
{
  SMTPAccountDisconnect();
}


void DoSMTPProcess(void)
{

  eng_rcode code;

  switch (state.smtpprocess.substate)
  {
    case readytosend :

      /*
      ** Need to find out if any messages in send queue.
      ** If not, we should set substate to smtpdisconnected
      ** and ignore the following.
      */

      dprintf(("Eng", "SMTP substate = readytosend\n"));
      state.smtpprocess.substate = idle;
      code = SMTPAccountConnect();
      if (code < 0)
      {
        state.smtpprocess.rc = ENG_ESMTPCONNECTFAIL;
        state.smtpprocess.substate = connectfailure;
      }

      break;

    case connected :

      dprintf(("Eng", "SMTP substate = connected\n"));
      RemoveObj((MBoxOpCB**) &state.smtpprocess.connectobj);
      state.smtpstatus = acctconnected;

      state.smtpprocess.substate = idle;
      state.smtpprocess.processobj = new MBoxOpCB_process((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) smtp);
      code = (eng_rcode) outbox->Process(state.smtpprocess.processobj);
      dprintf(("Eng", "Processing SMTP mailbox, rc=%d\n",code));

      if (code < 0)
      {
        state.smtpprocess.rc = ENG_ECANTPROCESSSMTP;
        state.smtpprocess.substate = processfailure;
      }

      break;

    case connectfailure :

      /* connection has failed */
      dprintf(("Eng", "SMTP substate = connectfailure\n"));
      RemoveObj((MBoxOpCB**) &state.smtpprocess.connectobj);
      state.smtpprocess.substate = idle;
      (*callbacklist.statusfunc)(state.smtpprocess.rc, callbacklist.statushandle, DefunctSMTP);
      break;

    case processfailure :

      /* processing has failed */
      dprintf(("Eng", "SMTP substate = processfailure\n",));
      RemoveObj((MBoxOpCB**) &state.smtpprocess.processobj);
      state.smtpprocess.substate = idle;
      (*callbacklist.statusfunc)(state.smtpprocess.rc, callbacklist.statushandle, DeadSMTP);

      break;

    case smtpdone :

      /* SMTP process completed -
         do we have a means to check that mail has been sent? */
      dprintf(("Eng", "SMTP substate = smptdone\n"));
      RemoveObj((MBoxOpCB**) &state.smtpprocess.processobj);
      state.smtpprocess.substate = idle;
      SMTPAccountDisconnect();
      break;

    case disconnected :
    case disconnectfailure :

      dprintf(("Eng", "SMTP substate = disconnected\n"));
      RemoveObj((MBoxOpCB**) &state.smtpprocess.disconnectobj);
      state.smtpstatus = acctcreated;
      state.state &= ~PROCESSSMTP;
      if (state.state & DISCONNECT)
      {
        dprintf(("Eng", "Now going to disconnect POP\n"));
        state.state |= PROCESSPOP;
        state.popprocess.substate = popdone;
      }

      break;

  }

}


void DoPOPProcess(void)
{

  eng_rcode code;
  uint32 n;
  bool changed;

  switch (state.popprocess.substate)
  {
    case readytoexpunge :

      dprintf(("Eng", "POP substate = readytoexpunge\n"));
      /* it may be already connected... */
      if (state.popstatus == acctconnected)
      {
        dprintf(("Eng", "Already connected\n"));
        state.popprocess.substate = connected;
      }

      /* ...but if not, connect to it if it exists */
      else if (state.popstatus == acctcreated)
      {
        state.popprocess.substate = idle;
        state.mark.substate = idle;
        POPAccountConnect();
        if (code < 0)
        {
          state.popprocess.rc = ENG_EPOPCONNECTFAIL;
          state.popprocess.substate = connectfailure;
        }
      }

      break;

    case connected :

      dprintf(("Eng", "POP substate = connected\n"));
      RemoveObj((MBoxOpCB**) &state.popprocess.connectobj);
      state.popstatus = acctconnected;

      state.popprocess.substate = idle;
      state.mark.substate = idle;
      dprintf(("Eng", "About to create expunge object\n"));
      state.popprocess.expungeobj = new MBoxOpCB_expunge((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) pop);
      dprintf(("Eng", "About to call Expunge\n"));
      code = (eng_rcode) inbox->Expunge(state.popprocess.expungeobj);
      dprintf(("Eng", "Expunging POP mailbox, rc=%d\n",code));

      if (code < 0)
      {
        ourmboxin->flags |= MBOXINCOMPLETE;
        state.popprocess.substate = readytoprocess;
      }

      break;

    case readytoprocess :

      dprintf(("Eng", "POP substate = readytoprocess\n"));
      RemoveObj((MBoxOpCB**) &state.popprocess.expungeobj);

      state.popprocess.substate = idle;
      state.popprocess.processobj = new MBoxOpCB_process((MBoxCBHandlerFn) eng_mbox_cbfunc, (void *) pop);
      code = (eng_rcode) inbox->Process(state.popprocess.processobj);
      dprintf(("Eng", "Processing POP mailbox, rc=%d\n",code));

      if (code < 0)
      {
        state.popprocess.rc = ENG_ECANTPROCESSPOP;
        state.popprocess.substate = processfailure;
      }

      break;

    case connectfailure :

      /* connection has failed */
      dprintf(("Eng", "POP substate = connectfailure\n",));
      RemoveObj((MBoxOpCB**) &state.popprocess.connectobj);
      state.popprocess.substate = idle;
      (*callbacklist.statusfunc)(state.popprocess.rc, callbacklist.statushandle, DefunctPOP);
      break;

    case processfailure :

      /* processing has failed */
      dprintf(("Eng", "POP substate = processfailure\n",));
      RemoveObj((MBoxOpCB**) &state.popprocess.processobj);
      state.popprocess.substate = idle;
      (*callbacklist.statusfunc)(state.popprocess.rc, callbacklist.statushandle, DeadPOP);

      break;

    case popdone :

      dprintf(("Eng", "POP substate = popdone\n"));
      if (state.popprocess.processobj)
        changed = state.popprocess.processobj->mailbox_changed;
      RemoveObj((MBoxOpCB**) &state.popprocess.processobj);
      if (state.state & DISCONNECT)
        POPAccountDisconnect();

      else
      {
        dprintf(("Eng", "Mailbox has %schanged\n",(changed) ? "" : "not "));
        if (changed)
        {
          state.popprocess.getnumobj = new MBoxOpCB_getnummsgs((MBoxCBHandlerFn) eng_mbox_cbfunc, 0);
          state.popprocess.substate = idle;
          code = (eng_rcode) inbox->GetNumberMessages(state.popprocess.getnumobj);
          if (code < 0)
          {
            state.popprocess.substate = getnumfailure;
            state.popprocess.rc = code;
          }
        }

        else
        {
          /* mailbox hasn't changed so no new mail */
          ProcessDone(false);
        }
      }

      break;

    case disconnected :
    case disconnectfailure :

      dprintf(("Eng", "POP substate = disconnected\n"));
      /* we should only be disconnecting from POP on an error
         or when the line is taken down */
      RemoveObj((MBoxOpCB**) &state.popprocess.disconnectobj);
      state.popstatus = acctcreated;
      state.state &= ~PROCESSPOP;
      if (state.state & DISCONNECT)
      {
        state.state &= ~DISCONNECT;
        DisconnectFromISP();
      }

      break;

    case gotnumber :

      dprintf(("Eng", "POP substate = gotnumber\n"));
      n = state.popprocess.getnumobj->number_messages;
      dprintf(("Eng", "Number of messages=%d\n",n));
      RemoveObj((MBoxOpCB**) &state.popprocess.getnumobj);
      ReconcileMailbox(n);
      break;

    case getnumfailure :

      dprintf(("Eng", "POP substate = getnumfailure\n"));
      state.popprocess.substate = idle;
      RemoveObj((MBoxOpCB**) &state.popprocess.getnumobj);
      (*callbacklist.statusfunc)(ENG_ECANTPROCESSPOP, callbacklist.statushandle, DeadPOP);

    default :

      break;
  }

}


/*
** OnOurList() checks a mailbox object pointer against our list
** to see if it is on the list.
*/

bool OnOurList(Message *obj)
{

  MessageDescriptor *msgptr = ourmboxin->list;

  while (msgptr)
  {
    if (msgptr->mboxobj == obj)
      return true;
    else
      msgptr = msgptr->next;
  }

  return false;

}


/*
** OnMboxList() checks a mailbox object pointer against the
** mailbox's list to see if it is on the list.
*/

bool OnMboxList(Message *obj, ELib_list list, int n)
{

  list.Reset();  
  while (n--)
  {
    list.Next();
    if ((Message *) list.Current() == obj)
      return true;
  }

  return false;

}


void PAbort(bool b)
{
  ProcessDone(true);
}


/*
** ReconcileMailbox() gets the list of messages in the Inbox
** after receiving the callback with the number of messages.
**
** First it looks through our list to see if any are missing from
** the mailbox's list. If so, their descriptors are destroyed.
**
** Then it scans the messages in the mailbox's
** list to see if any are missing from our own list.
** If so, new descriptors are created and the flags are read.
*/

void ReconcileMailbox(uint32 n)
{

  MessageDescriptor *nextptr, *msgptr;
  ELib_rcode code;
  uint32 i;
  Message::Flags flags;
  Message *obj;
  ELib_list msglist = inbox->GetMessages();

  /* check through our list to see if any are missing
     from mailbox's list, and destroy them */

  msgptr = ourmboxin->list;
  dprintf(("Eng", "message list starts at 0x%x\n",ourmboxin->list));
  while (msgptr)
  {
    nextptr = msgptr->next;
    if (!OnMboxList(msgptr->mboxobj, msglist, n))
    {
      /* must have been deleted so destroy descriptor */
      dprintf(("Eng", "Deleting message %d not on mailbox list\n",msgptr->ID));
      DestroyDescriptor(msgptr, ourmboxin);
    }
    msgptr = nextptr;
  }

  msglist.Reset();
  for (i = 0; i < n; i++)
  {
    msglist.Next();
    obj = (Message *) msglist.Current();
    dprintf(("Eng", "Examining message %d on mailbox list\n",i));
    if (!OnOurList(obj))
    {
      /* must be an unknown message so create new descriptor */
      dprintf(("Eng", "Message is not on our list\n"));

      if ((msgptr = NewDescriptor(0, ourmboxin)) == 0)
      {
        /* there was not enough memory to create descriptor */
        dprintf(("Eng", "Malloc failure\n"));
        break;
      }
      msgptr->mboxobj = obj;
      code = obj->GetFlags(flags, Message::Set);
      dprintf(("Eng", "Flags=0x%x, code=%d\n",flags,code));
      if (code >= 0)
      {
        if (flags & Message::Read)
          msgptr->flags |= READ;
        if (flags & Message::New)
        {
          newmail = true;
          msgptr->flags |= NEW;
        }
      }
      msgptr->flags |= NEWLYCREATED;
    }
  }

  if (msgptr == 0)
  {
    /* we've had a memory allocation failure */
    (*callbacklist.statusfunc)(ENG_ENOSPACEFORMSG, callbacklist.statushandle, PAbort);
  }
  else
    ProcessDone(true);

}


void ProcessDone(bool changed)
{

  dprintf(("Eng", "Entering ProcessDone(), mailbox is %schanged\n",(changed) ? "" : "not "));
  state.state &= ~PROCESSPOP;
  if (changed)
  {
    if (state.emailactive)
    {
      state.download.msg = ourmboxin->list;
      state.download.substate = readytodownload;
      state.download.rc = ENG_COMPLETED;
      state.state |= DOWNLOADHDR;
    }
    else
    {
      if (newmail)
      {
        /* send an indication to the browser of new mail
           including number of new mails */
      }
      else
      {
        /* tell browser there's no new mail */
      }

      /*
      ** Since email is not active,
      ** should we disconnect from POP account now?
      */
    }
  }
  else
  {
    ourmboxin->flags |= MBOXPROCESSED;
    (*callbacklist.promptfunc)(ENG_COMPLETED, ourmboxin->list, state.connected, callbacklist.prompthandle);
  }

}


/*
** SortMailbox() reorders the message list in date order, newest first.
*/

void SortMailbox(void)
{

  MessageDescriptor *msgptr, *nextptr, *prev, *beyond;
  bool sortflag;
  int i;

  do
  {
    sortflag = false;
    msgptr = ourmboxin->list;
    for (i = 0; i < ourmboxin->total; i++)
    {
      nextptr = msgptr->next;

      if (nextptr)
      {
        /*
        ** If date of next is greater than date of current,
        ** swap pointers and set sortflag.
        */

        if (mktime(nextptr->datestruct) > mktime(msgptr->datestruct))
        {
          sortflag = true;
          prev = msgptr->last;
          beyond = nextptr->next;
          if (beyond)
            beyond->last = msgptr;
          if (prev)
            prev->next = nextptr;
          msgptr->next = beyond;
          msgptr->last = nextptr;
          nextptr->next = msgptr;
          nextptr->last = prev;
          if (nextptr->last == 0)
            ourmboxin->list = nextptr;
        }
        else
          msgptr = msgptr->next;
      }
    }
  }
  while (sortflag);
  dprintf(("Eng", "Mailbox sorted\n"));
}


void DoMark(void)
{

  switch (state.mark.substate)
  {
    case readytomark :

      dprintf(("Eng", "Mark substate = readytomark\n"));
      state.mark.substate = idle;
      if (state.mark.current == state.mark.total)
      {
        /* all messages marked for deletion */
        dprintf(("Eng", "All messages marked\n"));
        if (state.connected)
        {
          /* expunge mailbox now */
          dprintf(("Eng", "About to expunge\n"));
          state.popprocess.substate = readytoexpunge;
          state.state |= PROCESSPOP;
        }
        else
          state.mark.substate = readytodisplay;
      }

      else
      {
        MessageDescriptor *msg = FindDescriptor(state.mark.list[state.mark.current], ourmboxin);
        ELib_rcode code;
        state.mark.setobj = new MBoxOpCB_setflags((MBoxCBHandlerFn) eng_mbox_cbfunc, 0);

        state.mark.msg = msg;
        state.mark.substate = idle;
        code = msg->mboxobj->SetFlags(state.mark.setobj, Message::Delete, Message::Set);
        if (code < 0)
        {
          /* mailbox has signalled an error in marking */
          dprintf(("Eng", "Error calling SetFlags, rc=%d\n",code));
          state.mark.substate = markfailure;
        }
      }
      break;

    case markfailure :

      dprintf(("Eng", "Mark substate = markfailure\n"));
      RemoveObj((MBoxOpCB**) &state.mark.setobj);
      state.mark.rc = ENG_EDELETEFAILED;
      ++state.mark.current;
      state.mark.substate = readytomark;

      break;

    case markdone :
    {
      MessageDescriptor *msg = state.mark.msg;
      char *file = SetFilename(msg->ID, false);

      dprintf(("Eng", "Mark substate = markdone\n"));
      RemoveObj((MBoxOpCB**) &state.mark.setobj);
      msg->flags |= MARKED;
      DestroyDescriptor(msg, ourmboxin);
      UnlockFile(msg->ID, false);
      remove(file);
      ++state.mark.current;
      state.mark.substate = readytomark;
    
      break;
    }
    case readytodisplay :

      /* send message to UI to display Inbox */
      dprintf(("Eng", "Prompting UI to display Inbox\n"));
      state.state &= ~DELETE;
      (*callbacklist.promptfunc)(state.mark.rc, ourmboxin->list, state.connected, callbacklist.prompthandle);
      break;

  }

}
