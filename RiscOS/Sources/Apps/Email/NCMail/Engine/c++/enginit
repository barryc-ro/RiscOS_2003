/*
** Email Engine
** Initialisation
*/

#include "kernel.h"
#include "stdlib.h"
#include "swis.h"
#include "string.h"

#include "tboxlibs/event.h"
#include "tboxlibs/toolbox.h"
#include "tboxlibs/wimplib.h"
#include "tboxlibs/quit.h"
#include "tboxlibs/wimp.h"

#include "Email/Mailbox/WimpRegistry.h"
#include "Email/Mailbox/Account.h"
#include "Email/Mailbox/POP3/POP3Account.h"
#include "Email/Mailbox/SendQ/SendQAccount.h"

#include "DebugLib/DebugLib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "enginit.h"
#include "engevent.h"
#include "engtypes.h"
#include "engmanager.h"
#include "engstr.h"
#include "enguiapi.h"
#include "engprocess.h"
#include "engmsgs.h"
#include "engfile.h"

extern "C"
{
  #include "../Build/NCMailUI.h"
}

_kernel_swi_regs regs;
_kernel_oserror  *err;
IdBlock idblock;
bool appquit = false;
int ourhandle;
char *appname, *realname = 0, *emailaddr = 0;

static int *msglist;

bool AppInit(void)
{

  char *size = 0;
  uint32 i, msgnum = 0;
  int *regmsglist = 0;
  static int ourmessages[] =
  {
    0x4AF80,
    Wimp_MPreQuit,
    Wimp_MQuit
  };

  /* create amalgamated message list for toolbox - need to
     get list from WimpRegistry first */

#ifdef MemCheck_MEMCHECK
  MemCheck_SetChecking(0, 0);
#endif
  msgnum = WimpRegistry::Instance()->GetRegisteredMessages(regmsglist);
#ifdef MemCheck_MEMCHECK
  MemCheck_SetChecking(1, 1);
  MemCheck_RegisterMiscBlock(regmsglist, sizeof(int) * msgnum);
#endif
  if ((msglist = (int *) malloc(msgnum * sizeof(uint32) + sizeof(ourmessages))) == 0)
  {
    /* no memory */
    return false;
  }

  if (msgnum)
    memcpy(msglist, regmsglist, msgnum * sizeof(uint32));

  free(regmsglist);
#ifdef MemCheck_MEMCHECK
  MemCheck_UnRegisterMiscBlock(regmsglist);
#endif
  memcpy(msglist + msgnum, ourmessages, sizeof(ourmessages));

  if ((err = toolbox_initialise(0, 310, msglist, tbevents, "<NCMail$Dir>", &infobuf, &idblock, 0, &ourhandle, 0)) != NULL)
  {
    wimp_report_error(err,0,0,0,0,0);
    free(msglist);
    return false;
  }

  appname = ReadToken("_TaskName");

  debug_initialise(appname, "", "");
  debug_output_device(PDEBUG_OUTPUT);
  debug_atexit();

  InitState();
  ncmui_initialise(infobuf, state.connected);

  /* need to pass task handle to WimpRegistry */
  WimpRegistry::Instance()->SetTaskID(ourhandle);

  event_initialise(&idblock);
  dprintf(("Eng", "Succesfully initialised\n"));

  event_register_message_handler(Wimp_MQuit, Messages, 0);
  event_register_message_handler(Wimp_MPreQuit, Messages, 0);
  event_register_wimp_handler(-1, Wimp_ENull, NullEvent, 0);

  event_register_toolbox_handler(-1, Quit_Quit, TBEvents, 0);

  /*
  ** May need to register here with NCMA
  ** to receive pre-standby notification.
  */

  if (((realname = GetSysVar("Inet$EmailRealName")) == 0) || ((emailaddr = GetSysVar("Inet$EmailAddress")) == 0))
  {
    /* real name and/or email address missing */
    dprintf(("Eng", "User details missing\n"));
    state.init.rc = ENG_BADUSERDETAILS;
    state.init.substate = precreate;
  }
  else
  {
    dprintf(("Eng", "Real name = %s, address = %s\n",realname,emailaddr));
    state.init.substate = creatingpop;
  }

  if ((size = GetSysVar("NCMail$ThresholdSize")) != 0)
  {
    regs.r[0] = 10;
    regs.r[1] = (int) size;
    _kernel_swi(OS_ReadUnsigned,&regs,&regs);
    ourmboxin->maxsize = regs.r[2];
    if (((*(char *) regs.r[1]) | 32) == 107)
      ourmboxin->maxsize <<= 10;
    else if (((*(char *) regs.r[1]) | 32) == 109)
      ourmboxin->maxsize <<= 20;
    dprintf(("Eng", "Maximum download size = %d\n",ourmboxin->maxsize));
  }
  else
    ourmboxin->maxsize = 0x8000;

  free(size);
  state.state |= INIT;

  return true;

}


void PreShutDown(WimpMessage *msg)
{

  dprintf(("Eng", "Receiving PreQuit massage\n"));

  if (state.state & PREQUIT)
  {
    /* prequit has already been done, we can ignore this time */
  }

  else if ((state.popstatus == acctconnected) || (state.smtpstatus == acctconnected))
  {
    /* object to quit and disconnect from servers if connected */
    msg->hdr.your_ref = msg->hdr.my_ref;
    regs.r[0] = 19;
    regs.r[1] = (int) msg;
    _kernel_swi(Wimp_SendMessage,&regs,&regs);
    dprintf(("Eng", "Objecting to shutdown\n"));
    state.state |= PREQUIT;
    PreDisconnect();
  }

}


void ShutDown(void)
{

  dprintf(("Eng", "Entering ShutDown\n"));
#ifdef gorilla
  if ((state.popstatus == acctconnected) || (state.smtpstatus == acctconnected))
  {
    dprintf(("Eng", "Prompting to disconnect servers\n"));
    ReportError("Please disconnect mailservers first");
    appquit = false;
  }

  else
#endif

  {
    static char storename[] = "<NCMailStore$Dir>.<NCMail$User>.*";
    static char attr[] = "wr";

    if (state.popstatus == acctcreated)
    {
      dprintf(("Eng", "About to delete POP account\n"));
      delete POPaccount;
    }

    if (state.smtpstatus == acctcreated)
    {
      dprintf(("Eng", "About to delete SMTP account\n"));
      delete SMTPaccount;
    }

    /* Unlock all files in user's store */
    dprintf(("Eng", "About to unlock files\n"));
    regs.r[0] = 24;
    regs.r[1] = (int) storename;
    regs.r[2] = (int) attr;
    _kernel_swi(OS_FSControl,&regs,&regs);

    dprintf(("Eng", "Shutting down app\n"));

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(WimpRegistry::Instance());
    MemCheck_OutputBlocksInfo();
#endif

    exit(0);
  }
}


void SetupStore(void)
{

  char storename[14];
  char attstr[3];

  strcpy(storename, "NCMailStore:*");
  strcpy(attstr, "WR");

  /* create directory to store user's mail */

  CreateDirectory("<NCMailStore$Dir>");
  CreateDirectory("<NCMailStore$Dir>.<NCMail$User>");

  /* unlock and clear out any files from directory if they exist */

  regs.r[0] = 24;
  regs.r[1] = (int) storename;
  regs.r[2] = (int) attstr;
  _kernel_swi(OS_FSControl,&regs,&regs);
  regs.r[0] = 27;
  regs.r[3] = 0;
  _kernel_swi(OS_FSControl,&regs,&regs);

}


void GoSMTP(bool b)
{
  state.init.substate = creatingsmtp;
}


void GoProcess(bool b)
{
  state.init.substate = smtpacctok;
}


void GoPopCr(bool b)
{
  state.init.substate = creatingpop;
}


/*
** CreatePOPAccount() sets up a new POP3 account.
** This is called when NCMail is first entered and the account
** stays valid until the user logs off or goes into standby mode.
*/

void CreatePOPAccount(void)
{

  ELib_rcode code;
  char *popuser = 0, *poppassword = 0, *pophostname = 0;

  if (((popuser = GetSysVar("Inet$EmailPOP3User")) == 0) || ((poppassword = GetSysVar("Inet$EmailPOP3Password")) == 0) || ((pophostname = GetSysVar("Inet$EmailPOP3Hostname")) == 0))
  {
    state.init.substate = popacctfailure;
    state.init.rc = ENG_BADPOPDETAILS;
    dprintf(("Eng", "Some POP account details missing\n"));
    return;
  }
  dprintf(("Eng", "POP3 user = %s, password = %s, hostname = %s \n",popuser,poppassword,pophostname));

  SetupStore();

  /* create new POP3 account */

  POPaccount = new POP3Account(popuser, poppassword, pophostname, code);
  if (code < 0)
  {
    /* error creating POP3 account */
    state.init.substate = popacctfailure;
    state.init.rc = ENG_NOPOPACCOUNT;
    dprintf(("Eng", "Error creating POP account, rc = %d\n",code));
  }
  else
  {
    state.init.substate = creatingsmtp;
    state.popstatus = acctcreated;
  }
  free(popuser);
  free(poppassword);
  free(pophostname);

}


void CreateSMTPAccount(void)
{

  ELib_rcode code;
  char *smtphostname;

  if ((smtphostname = GetSysVar("Inet$EmailSMTPHostname")) == 0)
  {
    state.init.substate = smtpacctfailure;
    state.init.rc = ENG_BADSMTPDETAILS;
    dprintf(("Eng", "SMTP hostname missing\n"));
    return;
  }

  dprintf(("Eng", "SMTP hostname = %s\n",smtphostname));

  SMTPaccount = new SendQAccount(smtphostname, code);
  if (code < 0)
  {
    /* error creating SMTP account */
    state.init.substate = smtpacctfailure;
    state.init.rc = ENG_NOSMTPACCOUNT;
    dprintf(("Eng", "Error creating SMTP account, rc = %d\n",code));
  }
  else
  {
    state.init.substate = smtpacctok;
    state.smtpstatus = acctcreated;
  }
  free(smtphostname);

}


void DoCreateAccount(void)
{

  switch (state.init.substate)
  {

    case precreate :

      state.init.substate = idle;
      (*callbacklist.statusfunc)(state.init.rc, callbacklist.statushandle, GoPopCr);
      break;

    case creatingpop :

      /* do we need to notify UI that we are connecting to mail servers? */
      dprintf(("Eng", "substate = creatingpop\n"));
      CreatePOPAccount();
      break;

    case creatingsmtp :

      dprintf(("Eng", "substate = creatingsmtp\n"));
      CreateSMTPAccount();
      break;

    case smtpacctok :

      dprintf(("Eng", "substate = smtpacctok\n"));
      state.state &= ~INIT;
      if ((state.connected) && ((state.popstatus != acctnonexistent) || (state.smtpstatus != acctnonexistent)))
        StartProcess();
      break;

    case popacctfailure :

      dprintf(("Eng", "substate = popacctfailure\n"));
      state.init.substate = idle;
      (*callbacklist.statusfunc)(state.init.rc, callbacklist.statushandle, GoSMTP);
      break;

    case smtpacctfailure :

      dprintf(("Eng", "substate = smtpacctfailure\n"));
      state.init.substate = idle;
      (*callbacklist.statusfunc)(state.init.rc, callbacklist.statushandle, GoProcess);
      break;

  }
}
