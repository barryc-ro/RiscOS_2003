/*
** Email Engine
** Initialisation
*/

#include "kernel.h"
#include "stdlib.h"
#include "swis.h"
#include "string.h"

#include "tboxlibs/event.h"
#include "tboxlibs/toolbox.h"
#include "tboxlibs/wimplib.h"
#include "tboxlibs/quit.h"

#include "Email/Mailbox/WimpRegistry.h"
#include "Email/Mailbox/Account.h"
#include "Email/Mailbox/POP3/POP3Account.h"
#include "Email/Mailbox/SendQ/SendQAccount.h"

#include "DebugLib/DebugLib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "enginit.h"
#include "engevent.h"
/* #include "engdebug.h" */
#include "engtypes.h"
#include "engmanager.h"
#include "engstr.h"
#include "enguiapi.h"
#include "engprocess.h"
#include "engmsgs.h"
#include "engfile.h"

extern "C"
{
  #include "../Build/NCMailUI.h"
}

_kernel_swi_regs regs;
_kernel_oserror  *err;
IdBlock idblock;
bool appquit = false;
int ourhandle;
char *appname;

#define OURMESSAGES 5

static int *msglist;
static int ourmessages[OURMESSAGES] = {0x4e500, 0x4e540, Wimp_MOpenURL, Wimp_MPreQuit, Wimp_MQuit};


bool app_init(void)
{

  uint32 i, msgnum = 0, *regmsglist;

  /* create amalgamated message list for toolbox - need to
     get list from WimpRegistry first */

  if ((msglist = (int *) malloc((msgnum + OURMESSAGES + 1) * sizeof(uint32))) == 0)
  {
    /* no memory */
    return false;
  }

  for (i = 0; i < OURMESSAGES; i++)
    msglist[i] = ourmessages[i];
  for (i = 0; i < msgnum; i++)
    msglist[i + OURMESSAGES] = regmsglist[i];

  if ((err = toolbox_initialise(0, 310, msglist, tbevents, "<NCMail$Dir>", &infobuf, &idblock, 0, &ourhandle, 0)) != NULL)
  {
    wimp_report_error(err,0,0,0,0,0);
    free(msglist);
    return false;
  }

  appname = ReadToken("_TaskName");

  debug_initialise(appname, "", "");
  debug_output_device(PDEBUG_OUTPUT);
  debug_atexit();

  InitState();
  ncmui_initialise(infobuf, state.connected);

  /* need to pass task handle to WimpRegistry */
  WimpRegistry::Instance()->SetTaskID(ourhandle);

  event_initialise(&idblock);
  dprintf(("", "Succesfully initialised\n"));

  event_register_message_handler(Wimp_MQuit, Messages, 0);
  event_register_message_handler(Wimp_MPreQuit, Messages, 0);
  event_register_message_handler(Wimp_MOpenURL, Messages, 0);
  event_register_wimp_handler(-1, Wimp_ENull, NullEvent, 0);

  event_register_toolbox_handler(-1, Quit_Quit, TBEvents, 0);

  /*
  ** Need to call any initialisation procedures in other components.
  ** e.g. UI will need to initialise in order to notify Engine
  ** of callback functions for status reports etc.
  */

  /*
  ** May need to register here with NCMA
  ** to receive pre-standby notification.
  */

  {

    char realname[32], emailaddr[64], size[32];

    if ((!GetSysVar("Inet$EmailRealName", realname, 32)) || (!GetSysVar("Inet$EmailAddress", emailaddr, 64)))
    {
      /* real name and/or email address missing */
      dprintf(("", "User details missing\n"));
      state.init.rc = ENG_EBADUSERDETAILS;
      state.init.substate = precreate;
    }
    else
    {
      dprintf(("", "Real name = %s, address = %s\n",realname,emailaddr));
      state.init.substate = creatingpop;
    }

    if (GetSysVar("NCMail$ThresholdSize", size, 32))
    {
      regs.r[0] = 10;
      regs.r[1] = (int) size;
      _kernel_swi(OS_ReadUnsigned,&regs,&regs);
      ourmbox.maxsize = regs.r[2];
      if (((*(char *) regs.r[1]) | 32) == 107)
        ourmbox.maxsize <<= 10;
      else if (((*(char *) regs.r[1]) | 32) == 109)
        ourmbox.maxsize <<= 20;
      dprintf(("", "Maximum download size = %d\n",ourmbox.maxsize));
    }
    else
      ourmbox.maxsize = 0x8000;

  }

  state.state |= INIT;

  return true;

}


void PreShutDown(void)
{

  dprintf(("", "Receiving PreQuit massage\n"));
  /*
  ** Do anything necessary before quitting,
  ** e.g. if connected to mail server, disconnect.
  ** Delete account objects.
  ** Unlock all files.
  ** Anything else?
  */

  if (state.popstatus == acctconnected)
  {
    /* disconnect POP account */
  }

  if (state.smtpstatus == acctconnected)
  {
    /* disconnect SMTP account */
  }

}


void ShutDown(void)
{

  if (state.popstatus == acctcreated)
    delete POPaccount;

  if (state.smtpstatus == acctcreated)
    delete SMTPaccount;

  /* clean up if necessary */
  dprintf(("", "Shutting down app\n"));
  appquit = true;
}


void SetupStore(void)
{

  char storename[14];
  char attstr[3];

  strcpy(storename, "NCMailStore:*");
  strcpy(attstr, "WR");

  /* create directory to store user's mail */

  CreateDirectory("<NCMail$Dir>.NCMail");
  CreateDirectory("<NCMail$Dir>.NCMail.<NCMail$User>");

  /* unlock and clear out any files from directory if they exist */

  regs.r[0] = 24;
  regs.r[1] = (int) storename;
  regs.r[2] = (int) attstr;
  _kernel_swi(OS_FSControl,&regs,&regs);
  regs.r[0] = 27;
  regs.r[3] = 0;
  _kernel_swi(OS_FSControl,&regs,&regs);

}


void GoSMTP(bool b)
{
  state.init.substate = creatingsmtp;
}


void GoProcess(bool b)
{
  state.init.substate = smtpacctok;
}


void GoPopCr(bool b)
{
  state.init.substate = creatingpop;
}


/*
** CreatePOPAccount() sets up a new POP3 account.
** This is called when NCMail is first entered and the account
** stays valid until the user logs off or goes into standby mode.
*/

void CreatePOPAccount(void)
{

  ELib_rcode code;
  char popuser[32], poppassword[32], pophostname[32];

  if ((!GetSysVar("Inet$EmailPOP3User", popuser, 32)) || (!GetSysVar("Inet$EmailPOP3Password", poppassword, 32)) || (!GetSysVar("Inet$EmailPOP3Hostname", pophostname, 32)))
  {
    state.init.substate = popacctfailure;
    state.init.rc = ENG_EBADPOPDETAILS;
    dprintf(("", "Some POP account details missing\n"));
    return;
  }
  dprintf(("", "POP3 user = %s, password = %s, hostname = %s \n",popuser,poppassword,pophostname));

  SetupStore();

  /* create new POP3 account */

  POPaccount = new POP3Account(popuser, poppassword, pophostname, code);
  if (code < 0)
  {
    /* error creating POP3 account */
    state.init.substate = popacctfailure;
    state.init.rc = ENG_ENOPOPACCOUNT;
    dprintf(("", "Error creating POP account, rc = %d\n",code));
  }
  else
  {
    state.init.substate = creatingsmtp;
    state.popstatus = acctcreated;
  }

}


void CreateSMTPAccount(void)
{

  ELib_rcode code;
  char smtphostname[32];

  if (!GetSysVar("Inet$EmailSMTPHostname", smtphostname, 32))
  {
    state.init.substate = smtpacctfailure;
    state.init.rc = ENG_EBADSMTPDETAILS;
    dprintf(("", "SMTP hostname missing\n"));
    return;
  }

  dprintf(("", "SMTP hostname = %s\n",smtphostname));

  SMTPaccount = new SendQAccount(smtphostname, code);
  if (code < 0)
  {
    /* error creating SMTP account */
    state.init.substate = smtpacctfailure;
    state.init.rc = ENG_ENOSMTPACCOUNT;
    dprintf(("", "Error creating SMTP account, rc = %d\n",code));
  }
  else
  {
    state.init.substate = smtpacctok;
    state.smtpstatus = acctcreated;
  }

}


void DoCreateAccount(void)
{

  switch (state.init.substate)
  {

    case precreate :

      state.init.substate = idle;
      (*callbacklist.statusfunc)(state.init.rc, callbacklist.statushandle, GoPopCr);
      break;

    case creatingpop :

      /* do we need to notify UI that we are connecting to mail servers? */
      dprintf(("", "substate = creatingpop\n"));
      CreatePOPAccount();
      break;

    case creatingsmtp :

      dprintf(("", "substate = creatingsmtp\n"));
      CreateSMTPAccount();
      break;

    case smtpacctok :

      dprintf(("", "substate = smtpacctok\n"));
      state.state &= ~INIT;
      if ((state.connected) && ((state.popstatus != acctnonexistent) || (state.smtpstatus != acctnonexistent)))
        StartProcess();
      break;

    case popacctfailure :

      dprintf(("", "substate = popacctfailure\n"));
      state.init.substate = idle;
      (*callbacklist.statusfunc)(state.init.rc, callbacklist.statushandle, GoSMTP);
      break;

    case smtpacctfailure :

      dprintf(("", "substate = smtpacctfailure\n"));
      state.init.substate = idle;
      (*callbacklist.statusfunc)(state.init.rc, callbacklist.statushandle, GoProcess);
      break;

  }
}
