/*
** Email Engine
** Initialisation
*/

#include "kernel.h"
#include "stdlib.h"
#include "swis.h"
#include "string.h"

#include "tboxlibs/event.h"
#include "tboxlibs/toolbox.h"
#include "tboxlibs/wimplib.h"
#include "tboxlibs/quit.h"
#include "tboxlibs/wimp.h"

#include "Email/Mailbox/WimpRegistry.h"

#include "NBLib/NBLib.h"
#include "DebugLib/DebugLib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

#include "Email/Common/types.h"
#include "Email/Common/bool.h"

#include "enginit.h"
#include "engevent.h"
#include "engtypes.h"
#include "engmanager.h"
#include "enguiapi.h"
#include "engprocess.h"
#include "engsend.h"
#include "enguser.h"
#include "engtimers.h"
#include "engconnect.h"
#include "engcbf.h"

extern "C"
{
  #include "../Build/NCMailUI.h"
}

_kernel_swi_regs regs;
_kernel_oserror  *err;
IdBlock idblock;
bool appquit = false, cachefs;
int ourhandle;
char *appname, *msgfilename;

MessagesFD infobuf;

#ifdef ALAN
static char ourvar[] = "NCMail$Handle";
#endif

static int *msglist, presender;
static unsigned int preflags;

bool AppInit(void)
{

  char *size = 0;
  uint32 msgnum = 0;
  int *regmsglist = 0;

  static int ourmessages[] =
  {
#ifdef BROKEN_5_10_LINKER
    /* RDW START OF HACK
       These 3 values below are the ones that should be picked up by the WimpRegistry
       but, because there seems to be a problem in Module builds with the static objects
       constructors not being called, it doesn't work so the values are put here as a
       workaround until I have time to look at the fault

       Fault found by Ben.  Fault in linker throwing away the static C++ object constructors
       Fixed by Stewart Brodie in link 5.11.

       If you're using a linker older than 5.11, then define BROKEN_5_10_LINKER
    */
    0x4e500,
    0x4e540,
    0x4AF80,
    0x4d300,
#endif
    /* RDW END */
    Wimp_MPreLogOff,
    Wimp_MLogOff,
    Wimp_MPreQuit,
    Wimp_MQuit
  };

  /* create amalgamated message list for toolbox - need to
     get list from WimpRegistry first */

#ifdef MemCheck_MEMCHECK
  MemCheck_SetChecking(0, 0);
#endif
  msgnum = WimpRegistry::Instance()->GetRegisteredMessages(regmsglist);
#ifdef MemCheck_MEMCHECK
  MemCheck_SetChecking(1, 1);
  MemCheck_RegisterMiscBlock(regmsglist, sizeof(int) * msgnum);
#endif
  if ((msglist = (int *) malloc(msgnum * sizeof(uint32) + sizeof(ourmessages))) == 0)
  {
    /* no memory */
    return false;
  }

  if ((msgfilename = malloc(32)) == 0)
  {
    /* no memory */
    return false;
  }

  if (msgnum)
    memcpy(msglist, regmsglist, msgnum * sizeof(uint32));

  free(regmsglist);
#ifdef MemCheck_MEMCHECK
  MemCheck_UnRegisterMiscBlock(regmsglist);
#endif
  memcpy(msglist + msgnum, ourmessages, sizeof(ourmessages));

  if ((err = toolbox_initialise(0, 310, msglist, tbevents, "NCMailRes:NCMail", &infobuf, &idblock, 0, &ourhandle, 0)) != NULL)
  {
    wimp_report_error(err,0,0,0,0,0);
    free(msglist);
    return false;
  }

/*   appname = ReadToken("_TaskName"); */
  appname = nb_messagetrans_lookup(infobuf, "_TaskName");

  debug_initialise(appname, "<NCMail$DebugLibFilename>", "");
  debug_output_device(DEBUGIT_OUTPUT);
  debug_atexit();

  if (!SetupState())
    return false;

#ifdef ALAN
  {
    char block[16];
    sprintf(block, "%d\0", ourhandle);
    regs.r[0] = (int) ourvar;
    regs.r[1] = (int) block;
    regs.r[2] = strlen(block) + 1;
    regs.r[3] = 0;
    regs.r[4] = 0;
    _kernel_swi(OS_SetVarVal,&regs,&regs);
  }
#endif

  if (!SetupNetlink())
  {
    dprintf(("Eng", "Failed to create NetLink object\n"));
    return false;
  }
  
  StopTimeoutCount();
  StopReconnectCount();
  StopRetryCount();
  /* are we running on a CacheFS-based system? */
  cachefs = (bool) nb_ensure_module(0, "CacheFS");

  WimpRegistry::Instance()->SetTaskID(ourhandle);

  event_initialise(&idblock);
  dprintf(("Eng", "Successfully initialised\n"));

  event_register_message_handler(Wimp_MQuit, Messages, 0);
  event_register_message_handler(Wimp_MPreQuit, Messages, 0);
  event_register_wimp_handler(-1, Wimp_ENull, NullEvent, 0);

  event_register_toolbox_handler(-1, Quit_Quit, TBEvents, 0);

  /* read sysvar to get configured threshold size */
  if ((size = GetSysVar("NCMail$ThresholdSize", true)) != 0)
  {
    regs.r[0] = 10;
    regs.r[1] = (int) size;
    _kernel_swi(OS_ReadUnsigned,&regs,&regs);
    popmbox->maxsize = regs.r[2];
    if (((*(char *) regs.r[1]) | 32) == 107)
      popmbox->maxsize <<= 10;
    else if (((*(char *) regs.r[1]) | 32) == 109)
      popmbox->maxsize <<= 20;
    dprintf(("Eng", "Maximum download size = %d\n",popmbox->maxsize));
  }
  else
    popmbox->maxsize = 0x8000;

  free(size);
  nb_directory_create(1, "<NCMailStore$Dir>", 0);
  LockFile("<NCMailStore$Dir>");

#ifdef CHECK_FOR_NCMALITE
  ChangeUser();
  dprintf(("Eng", "User details read\n"));
#else
  /*
  ** If sys var is already set, it means the start-up
  ** has been activated by Watchdog, and we can use
  ** the current user settings.
  ** Otherwise we do nothing and wait for the UI to send
  ** a change_user notification.
  */
  if (GetSysVar("Inet$EmailPOP3User", false))
    ChangeUser();
#endif

  return true;

}


/*
** CleanupApp() tidies up before Standby, Logoff,
** or quitting after a fatal error.
** It deletes any mailbox accounts, unlocks files,
** and if chuckvars flag is set, unsets the user variables.
** If called because of a fatal error, the flag will be unset
** because we want to reinstate the user details once the WatchDog
** restarts NCMail.
*/

void CleanupApp(bool chuckvars)
{

  ncmui_email_active(false);
  state = IDLE;
  if (popstatus == acctcreated)
  {
    dprintf(("Eng", "About to delete POP account\n"));
    delete POPaccount;
  }

  if (smtpstatus == acctcreated)
  {
    dprintf(("Eng", "About to delete SMTP account\n"));
    delete SMTPaccount;
  }

  /* Unlock all files in user's store */
  dprintf(("Eng", "About to unlock files\n"));
  UnlockFile("<NCMailStore$Dir>.<NCMail$User>.*");
  UnlockFile("<NCMailStore$Dir>.<NCMail$User>");
  UnlockFile("<NCMailStore$Dir>");

  if (chuckvars)
  {
    /* unset user variables */
    static char popvar[] = "Inet$EmailPOP3User";
    static char passvar[] = "Inet$EmailPOP3Password";

    regs.r[0] = (int) popvar;
    regs.r[1] = -1;
    regs.r[2] = -1;
    regs.r[3] = 0;
    _kernel_swi(OS_SetVarVal,&regs,&regs);
    regs.r[0] = (int) passvar;
    regs.r[1] = -1;
    regs.r[2] = -1;
    regs.r[3] = 0;
    _kernel_swi(OS_SetVarVal,&regs,&regs);
  }

}


bool UnfinishedBusiness(uint32 st)
{

  if (sendpending)
  {
    /* warn user that messages haven't been sent */
    statusret.code = ENG_UNSENTMAIL;
    (*callbacklist.statusfunc)(&statusret, callbacklist.statushandle, ConfirmSend);
    state |= st;
    return true;
  }

  else if ((popstatus == acctconnected) || (smtpstatus == acctconnected))
  {
    /* object to quit and disconnect from servers if connected */
    StopTimeoutCount();
    StopReconnectCount();
    state |= st;
    DisconnectLine();
    return true;
  }

  return false;

}


/*
** PreShutDown() is called before going to Standby or Logoff mode.
** If there is unsent mail in the queue, or if mail servers are
** connected, NCMail objects to the shutdown.
** In the former case it requests confirmation from the user,
** in the latter case simply postpones the shutdown until it
** has disconnected from the servers.
*/

void PreShutDown(WimpMessage *msg, uint32 st)
{

  dprintf(("Eng", "Receiving %s message\n",(st & PREQUIT) ? "PreQuit" : "PreLogOff"));

  if ((state & st) || (!UnfinishedBusiness(st)))
  {
    /*
    ** If state already exists, prequit or prelogoff has
    ** already been done so we can ignore this time.
    ** Otherwise if no unfinished business we can also ignore it.
    */
    CleanupApp(true);
  }

  else
  {
    presender = msg->hdr.sender;
    preflags = msg->data.words[0];
    msg->hdr.your_ref = msg->hdr.my_ref;
    regs.r[0] = 19;
    regs.r[1] = (int) msg;
    regs.r[2] = presender;
    _kernel_swi(Wimp_SendMessage,&regs,&regs);
    dprintf(("Eng", "Objecting to shutdown\n"));
  }

}


void ShutDown(void)
{

  dprintf(("Eng", "Entering ShutDown\n"));
  CleanupApp(false);

#ifdef MemCheck_MEMCHECK
  MemCheck_UnRegisterMiscBlock(WimpRegistry::Instance());
  MemCheck_OutputBlocksInfo();
#endif

  exit(0);
}


void RestartPreQuit(void)
{

  /* if there's still unfinished business, attend to it
     before restarting PreQuit */
  if (!UnfinishedBusiness(PREQUIT))
  {
    if (preflags & 1)
    {
      /* shut down task only, don't restart desktop shutdown */
      ShutDown();
    }

    else
    {
      WimpKeyPressedEvent eventblk;

      eventblk.caret.window_handle = -1;
      eventblk.caret.icon_handle = -1;
      eventblk.key_code = 0x1fc;
      regs.r[0] = Wimp_EKeyPressed;
      regs.r[1] = (int) &eventblk;
      regs.r[2] = presender;
      _kernel_swi(Wimp_SendMessage,&regs,&regs);
    }
  }
}


void LogOff(void)
{

  CleanupApp(true);

}


void RestartLogOff(void)
{

  /* if there's still unfinished business, attend to it
     before restarting LogOff */
  if (!UnfinishedBusiness(PRELOGOFF))
  {
    if (preflags & 1)
    {
      LogOff();
    }

    else
    {
      WimpMessage msgblk;

      msgblk.hdr.size = 24;
      msgblk.hdr.my_ref = 0;
      msgblk.hdr.action_code = Wimp_MRestartPreLogOff;
      regs.r[0] = 17;
      regs.r[1] = (int) &msgblk;
      regs.r[2] = presender;
      _kernel_swi(Wimp_SendMessage,&regs,&regs);
    }
  }
}
