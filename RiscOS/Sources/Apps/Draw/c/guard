/*guard*/

/* Copyright (C) Acorn Computers Limited 1991
   Confidential - Do not distribute outside Acorn Computers Limited.
   Neither the whole nor any part of the information contained here
   may be adapted or reproduced in any material form except with the
   prior written approval of Acorn Computers Limited (Acorn).
*/

/* History:
 *   Jonathan Coxhead 10 July 1991 Written, based on nova_.
 */

#include <assert.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "ftrace.h"

#include "guard.h"

#undef guard_summary
#undef guard_check
#undef free_size
/*------------------------------------------------------------------------*/
static Allocated_Store = 0, Allocated_Blocks = 0;

#define GUARD_WORD 0xACCE55ED /*an unlikely value*/
#define GUARD_BYTE 0xC0       /*first two letters of my name!*/ 
#define EXTRA 100             /*Must be >= 1 to hold the guard byte*/

typedef struct Block_Header
  { struct Block_Header *next;  /*a double-linked chain is maintained, to
                                  keep deletion reasonably quick */
    struct Block_Header *prev;
    int size;                   /*size excluding this header */
    char *file;                 /*where first created */
    int line;                   /*where first created */
    int guard;                  /*an unlikely value */
  }
  Block_Header;

static Block_Header *Blocks = NULL;
static int Largest_Block_Size = 0, Highest_Line_No = 0;
/*------------------------------------------------------------------------*/
void guard_summary (void)

{  Block_Header *header;

   ftracef (__FILE__, __LINE__, "allocated store ...\n");
   ftracef (__FILE__, __LINE__, "allocated %d blocks, %d bytes\n",
         Allocated_Blocks, Allocated_Store);

   ftracef (__FILE__, __LINE__, "block summary, in reverse order of allocation:\n");
   for (header = Blocks; header; header = header->prev)
      ftracef (__FILE__, __LINE__, "0x%X: guard_alloc (%d) at %s,%d\n",
            (char *) header + sizeof (Block_Header), header->size,
            header->file, header->line);

   ftracef (__FILE__, __LINE__, "... end\n");
}
/*------------------------------------------------------------------------*/
void guard_check (void)

{  Block_Header *header;
   int len, i, count = 0;

   ftracef (__FILE__, __LINE__, "checking %d blocks, largest %d, lines 1-%d\n",
         Allocated_Blocks, Largest_Block_Size, Highest_Line_No);

   for (header = Blocks; header != NULL; header = header->prev)
   {  /*The block must be a reasonable size.*/
      assert (0 < header->size && header->size <= Largest_Block_Size);

      /*We only trace C source.*/
      len = strlen (header->file);
      assert (3 <= len && len <= 12 /*it's RISC O S*/);
      assert (header->file [0] == 'c');
      assert (header->file [1] == '.');
      for (i = 2; i < len; i++) assert (isprint (header->file [i]));

      /*The line number must be reasonable.*/
      assert (1 <= header->line && header->line <= Highest_Line_No);

      /*There's a guard word in the header.*/
      assert (header->guard == GUARD_WORD);

      /*There's a guard byte at the end of each block.*/
      assert (((char *) (header + 1)) [header->size] == GUARD_BYTE);

      assert (count < Allocated_Blocks);
      count++;
   }

   assert (count == Allocated_Blocks);
}
/*------------------------------------------------------------------------*/
void *guard_alloc (char *file, int line, size_t size)

{  void *result;

   ftracef
   (  __FILE__, __LINE__,
      "[%d,%d(%d)] guard_alloc (%d) at %s,%d\n",
      Allocated_Blocks,
      Allocated_Store,
      sizeof (Block_Header)*Allocated_Blocks + Allocated_Store,
      size, file, line
   );

   guard_check ();

   result = size != 0? (malloc) (size + sizeof (Block_Header) + EXTRA): NULL;

   if (result == NULL)
   {  ftracef0 ("... NULL\n");
      return NULL;
   }
   else
   {  Block_Header *header = (Block_Header *) result;

      Allocated_Blocks++;
      Allocated_Store += size;
      if (Largest_Block_Size < size) Largest_Block_Size = size;
      if (Highest_Line_No < line) Highest_Line_No = line;

      header->prev = Blocks;
      if (Blocks) Blocks->next = header;
      header->next  = NULL;
      header->size  = size;
      header->file  = file;
      header->line  = line;
      header->guard = GUARD_WORD;
      Blocks = header;

      ((char *) (header + 1)) [size] = GUARD_BYTE;

      ftracef (__FILE__, __LINE__, "... 0x%X\n",
          (char *) result + sizeof (Block_Header));
      return (char *) result + sizeof (Block_Header);
}  }
/*------------------------------------------------------------------------*/
void *guard_realloc (char *file, int line, void *ptr, size_t size)

{  void *result;
   Block_Header *old_header = ptr != NULL? (Block_Header *) ptr - 1: NULL;
   size_t old_size = old_header != NULL? old_header->size: 0;

   ftracef
   (  __FILE__, __LINE__, 
      "[%d,%d(%d)] guard_realloc (0x%X, %d) at %s,%d\n",
      Allocated_Blocks, Allocated_Store,
      sizeof (Block_Header)*Allocated_Blocks + Allocated_Store,
      ptr, size, file, line
   );

   assert (old_header == NULL || old_header->guard == GUARD_WORD);
   assert (old_header == NULL ||
         ((char *) (old_header + 1)) [old_size] == GUARD_BYTE);
   guard_check ();

   if (size == 0 && old_size != 0)
   {  /*Effectively a call to free(). Remove the block from the chain.*/
      if (old_header->next)
      {  assert (old_header->next->prev == old_header);
         old_header->next->prev = old_header->prev;
      }

      if (old_header->prev)
      {  assert (old_header->prev->next == old_header);
         old_header->prev->next = old_header->next;
      }
      if (Blocks == old_header) Blocks = old_header->prev;

      Allocated_Blocks--;
      Allocated_Store -= old_size;
   }
   result = (realloc) ((char *) old_header,
       size != 0? size + sizeof (Block_Header) + EXTRA: 0);

   if (result == NULL)
   {  ftracef0 ("... NULL\n");
      return NULL;
   }
   else
   {  Block_Header *header = (Block_Header *) result;

      if (Largest_Block_Size < size) Largest_Block_Size = size;
      if (Highest_Line_No < line) Highest_Line_No = line;

      if (old_header == NULL)
      {  /*Fill in the new block.*/
         Allocated_Blocks++;
         Allocated_Store += size;
         
         header->prev = Blocks;
         if (Blocks) Blocks->next = header;
         header->next = NULL;
         header->size = size;
         header->file = file;
         header->line = line;
         header->guard = GUARD_WORD;
         Blocks = header;
      }
      else
      {  assert (header->guard == GUARD_WORD);

         Allocated_Store += size - header->size;
         header->size = size;

         /* the block may have moved, in which case we must move the
         pointers to it in the two-way chain. */
         if (header->prev)
         {  assert(header->prev->next == old_header);
            header->prev->next = header;
         }

         if (header->next)
         {  assert(header->next->prev == old_header);
            header->next->prev = header;
         }
         if (Blocks == old_header) Blocks = header;
      }

      ((char *) (header + 1)) [size] = GUARD_BYTE;

      ftracef (__FILE__, __LINE__, "... 0x%X\n",
            (char *) result + sizeof (Block_Header));
      return (char *) result + sizeof (Block_Header);
}  }
/*------------------------------------------------------------------------*/
void guard_free (char *file, int line, void *ptr, size_t size)

{  Block_Header *header = (Block_Header *) ptr - 1;
   size_t actual_size = header->size;

   ftracef
   (  __FILE__, __LINE__,
      "[%d,%d(%d)] guard_free (0x%X) (size %d) at %s,%d\n",
      Allocated_Blocks, Allocated_Store,
      sizeof (Block_Header)*Allocated_Blocks + Allocated_Store,
      ptr, actual_size, file, line
   );

   guard_check ();

   assert (!(ptr == 0 || (int) ptr < 0));
   assert (header->guard == GUARD_WORD); /*protects against multiple
         freeing*/
   assert (size == 0 || actual_size == size);
   assert (((char *) (header + 1)) [header->size] == GUARD_BYTE);

   /* Remove the block from the chain */
   if (header->next)
   {  assert(header->next->prev == header);
      header->next->prev = header->prev;
   }

   if (header->prev)
   {  assert(header->prev->next == header);
      header->prev->next = header->next;
   }
   if (Blocks == header) Blocks = header->prev;

   /*Set the contents of the block.*/
   memset (header, -1, actual_size + sizeof (Block_Header) + EXTRA);

   (free) (header);

   Allocated_Blocks--;
   Allocated_Store -= actual_size;
}
