/* Title:   wimpmsg.c
 * Purpose: functions for wimp message handling
 * Author:  IDJ
 * History: 19-Jun-94: IDJ: created
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"

#include "m.h"
#include "utils.h"

#include "event.h"

#include "types.h"
#include "wimpmsg.h"


static _kernel_oserror err = {0, "Error in event handling"};

#if TRACE
/*------------------------------------------------------------------------*/

   /*The name of a function.*/

static char *Function_Name (WimpMessageHandler *fn)
{
   char *name = (char *) fn - 4;

   static char Fn [80 + 1];

   if (name [3] == 0xFF)
      strcpy (Fn, name - *name);
   else
      sprintf (Fn, "(unnamed at 0x%X)" _ (unsigned) fn);

   return Fn;
}
#endif


static _kernel_oserror *make_error(void)
{
    return &err;
}

static WimpMessageHandlerItem  *wimpmsg__handlers = 0;   /* the list of all wimp message handlers */


/* ----------------------------------- dispatching a wimp message ----------------------------------- */


static int wimpmsg_message_matches (WimpMessageHandlerItem *h, WimpPollBlock *poll_block)
{
    int msg_no = poll_block->user_message.hdr.action_code;

    if (h->msg_no == -1 || h->msg_no == msg_no)
        return 1;

    return 0;
}


extern _kernel_oserror *wimpmsg_dispatch (WimpPollBlock *poll_block, IdBlock *id_block)
{
    /*
     * look down chain of wimp message handlers, looking for one interested in
     * this wimp message.  If handler returns non-zero it has claimed the
     * message.
     */

    WimpMessageHandlerItem *h, *next;
    int c;
    
    NOT_USED (id_block);
    
    for (h = wimpmsg__handlers; h != NULL; h = next)
    {
       next = h->next; /*avoid use when freed*/
       
       if (wimpmsg_message_matches (h, poll_block) && h->handler != NULL)
       {
           /* call the handler */
           TRACE2 ("calling Wimp message handler h 0x%X, h->handler 0x%X\n" _ h _ h->handler);
           TRACE2 ("fn %s\n" _ Function_Name (h->handler));
           c = h->handler (&poll_block->user_message, h->handle);
           TRACE2 ("called Wimp message handler %d\n" _ c);
           if (c) return NULL;
       }
    }
     
    return NULL;
}


/* ---------------------------- registering handlers for wimp messages ---------------------------- */

_kernel_oserror *wimpmsg_register_message_handler (int msg_no, WimpMessageHandler *handler, void *handle)
{ 
    WimpMessageHandlerItem *h, *new_h;
 
    /* 
     * first check to see if already there.
     */
    for (h = wimpmsg__handlers; h != NULL; h = h->next)
        if (h->handler == handler && h->handle == handle && h->msg_no == msg_no)
            return NULL;

    /*
     * create a new element and link it into the list.
     */
    if ((new_h = m_MALLOC (sizeof(WimpMessageHandlerItem))) == NULL)
        return make_error ();

    new_h->msg_no     = msg_no;
    new_h->handler    = handler;
    new_h->handle     = handle;
    new_h->next       = wimpmsg__handlers;
    wimpmsg__handlers = new_h;

    return NULL;
}

/* -------------------------------------- deregistering message handlers ----------------------------- */

_kernel_oserror *wimpmsg_deregister_message_handler (int msg_no, WimpMessageHandler *handler, void *handle)
{
    WimpMessageHandlerItem **h, *hh;

    /*
     * search for exact match of handler, list and handle.
     */
   for (h = &wimpmsg__handlers; *h != NULL; h = &(*h)->next)
      if ((*h)->handler == handler && (*h)->handle == handle && (*h)->msg_no == msg_no)
      {
         /*found---delete it!*/
         hh = *h; /*prevent use when freed*/

         *h = hh->next;
         m_FREE (hh, sizeof *hh);
    
         return NULL;
      }

   return make_error ();
}
