/* > utils.c
 *
 */

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "swis.h"
#include "wimp.h"
#include "wimplib.h"
#include "kernel.h"
#include "version.h"

#include "utils.h"

static _kernel_oserror Error_Unknown = {1, "C library error"};

_kernel_oserror Error_No_Mem = {1, "No memory"};

/* --------------------------------------------------------------------------------------------- */

static void *message_block = NULL;

void utils_init(void *message_ptr)
{
    message_block = message_ptr;
}

/* --------------------------------------------------------------------------------------------- */

#if DEBUG
void dbg (char const *file, int line, const char *fmt, ...)
{
   va_list ap;
   FILE *trace;

   if ((trace = fopen ("<CodecCtl$Trace>", "a")) != NULL)
   {
      fprintf (trace, "%12.12s,%4.4d@%5.5d: ", file, line, clock ());
      va_start (ap, fmt);
      vfprintf (trace, fmt, ap);
      va_end (ap);

      fclose (trace);
   }
}
#endif

/* --------------------------------------------------------------------------------------------- */

#if DEBUG
static void add_file_and_line(_kernel_oserror *e, const char *file, int line)
{
    int len = strlen(e->errmess);
    sprintf(e->errmess + len, " (%s: %d)", file, line);
}
#endif

/* --------------------------------------------------------------------------------------------- */

#if DEBUG
void err_fatal_(_kernel_oserror *e, const char *file, int line)
#else
void err_fatal(_kernel_oserror *e)
#endif
{
    if (e)
    {
	_kernel_oserror ee = *e;
#if DEBUG
	add_file_and_line(&ee, file, line);
	dbg ("error 0x%x %s\n", ee.errnum, ee.errmess);
#endif
	wimp_report_error(&ee, Wimp_ReportError_OK, APP_NAME " " VERSION_STRING);
	exit(EXIT_FAILURE);
    }
}

/* --------------------------------------------------------------------------------------------- */

#if DEBUG
_kernel_oserror *err_report_(_kernel_oserror *e, const char *file, int line)
#else
_kernel_oserror *err_report(_kernel_oserror *e)
#endif
{
    if (e)
    {
	_kernel_oserror ee = *e;
#if DEBUG
	add_file_and_line(&ee, file, line);
	dbg ("error 0x%x %s\n", ee.errnum, ee.errmess);
#endif
	wimp_report_error(&ee, Wimp_ReportError_OK, APP_NAME " " VERSION_STRING);
    }
    return e;
}

/* --------------------------------------------------------------------------------------------- */

#if DEBUG
void msg_report_(char *s, const char *file, int line)
#else
void msg_report(char *s)
#endif
{
    _kernel_oserror e;

    e.errnum = 0;
    sprintf (e.errmess, "%.*s", sizeof e.errmess - 1, s);

#if DEBUG
    dbg (file, line, "msg_report \"%s\"\n", e.errmess);
#endif
    wimp_report_error(&e, Wimp_ReportError_OK, APP_NAME " " VERSION_STRING);
}

/* --------------------------------------------------------------------------------------------- */

char *utils_msgs_lookup(char *tag)
{
    char *result;
/*     TRACE4("utils_msgs_lookup(): tag %s\n", tag); */
    if (message_block &&
	_swix(MessageTrans_Lookup, _INR(0,7) | _OUT(2),
	      message_block, tag, 0, 0, 0, 0, 0, 0,
	      &result) == NULL)
    {
/* 	TRACE4("utils_msgs_lookup(): result '%s'\n", result); */

	return result;
    }
/*     TRACE4("utils_msgs_lookup(): result '%s'\n", tag); */
    return tag;
}

/* --------------------------------------------------------------------------------------------- */

_kernel_oserror *utils_last_oserror (void)
{
   /*messing about here because _kernel_last_oserror() returns NULL the
      second time it's called*/
   _kernel_oserror *last_error;

   static _kernel_oserror *Last_Error;
   if (Last_Error == NULL) Last_Error = &Error_Unknown; /*to avoid static data init*/

   if ((last_error = _kernel_last_oserror ()) != NULL)
      Last_Error = last_error;

   return Last_Error; /*never NULL*/
}

/* --------------------------------------------------------------------------------------------- */

int strcasecomp (const char *a, const char *b)
{
    const char *p =a;
    const char *q =b;
    for(p=a, q=b; *p && *q; p++, q++) {
	int diff = tolower(*p) - tolower(*q);
	if (diff) return diff;
    }
    if (*p) return 1;	/* p was longer than q */
    if (*q) return -1;	/* p was shorter than q */
    return 0;		/* Exact match */
}

/* --------------------------------------------------------------------------------------------- */

char *strdup(const char *s)
{
    char *ss;

    if (s == NULL)
	return NULL;

    ss = malloc(strlen(s)+1);
    if (ss)
	strcpy(ss, s);

    return ss;
}

/* --------------------------------------------------------------------------------------------- */

#if DEBUG
const char *strsafe(const char *s)
{
    return s ? s : "<null>";
}
#endif

/* --------------------------------------------------------------------------------------------- */

void *rma_alloc(int size)
{
    char *ptr;
    if (_swix(OS_Module, _IN(0)|_IN(3)|_OUT(2),
	      6, size,
	      &ptr) != NULL)
	return NULL;

    return ptr;
}

/* --------------------------------------------------------------------------------------------- */

void rma_free(void *ptr)
{
    _swix(OS_Module, _IN(0)|_IN(2), 7, ptr);
}

/* --------------------------------------------------------------------------------------------- */

int get_file_type(const char *file_name)
{
  _kernel_swi_regs regs;

  regs.r[0] = 20;
  regs.r[1] = (int) file_name;

  err_fatal(_kernel_swi(OS_File, &regs, &regs));

  return regs.r[6];
} /* get_file_type */

/* --------------------------------------------------------------------------------------------- */

void set_system_variable(char *var_name, char *value)
{
  _kernel_swi_regs regs;

  regs.r[0] = (int) var_name;
  regs.r[1] = (int) value;
  regs.r[2] = strlen(value);
  regs.r[3] = 0;
  regs.r[4] = 0; /* string type */
  _kernel_swi(OS_SetVarVal, &regs, &regs);

} /* set_system_variable */

/* eof utils.c */
