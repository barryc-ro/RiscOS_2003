/* > clientmidi.c
 *
 */

/* ----------------------------------------------------------------------
 * INCLUDES
 * ----------------------------------------------------------------------
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <swis.h>

#include "wimplib.h"
#include "window.h"
#include "event.h"

#include "m.h"
#include "plugclient.h"
#include "client.h"
#include "version.h"
#include "utils.h"

/* ----------------------------------------------------------------------
 * CONSTANTS
 * ----------------------------------------------------------------------
 */

#define osfile_TYPE_MIDI        0xFD4

#define MIDIPLAY_SWI_CHUNK      0x45340
#define SWI_MIDIPLAY_FILE       (MIDIPLAY_SWI_CHUNK + 0)
#define SWI_MIDIPLAY_START      (MIDIPLAY_SWI_CHUNK + 1)
#define SWI_MIDIPLAY_STOP       (MIDIPLAY_SWI_CHUNK + 2)
#define SWI_MIDIPLAY_VOLUME     (MIDIPLAY_SWI_CHUNK + 3)
#define SWI_MIDIPLAY_TEMPO      (MIDIPLAY_SWI_CHUNK + 4)
#define SWI_MIDIPLAY_INFO       (MIDIPLAY_SWI_CHUNK + 5)
#define SWI_MIDIPLAY_CLOSE      (MIDIPLAY_SWI_CHUNK + 6)

#define SYNTH_SWI_CHUNK         0x4A840
#define SWI_SYNTH_ON            (SYNTH_SWI_CHUNK + 0)
#define SWI_SYNTH_MEMORY        (SYNTH_SWI_CHUNK + 1)
#define SWI_SYNTH_REMOVE_INSTRUMENT (SYNTH_SWI_CHUNK + 9)

#define DEFAULT_POLYPHONY       20
#define DEFAULT_MEMLIMIT        800

/* ----------------------------------------------------------------------
 * TYPE DEFINITIONS
 * ----------------------------------------------------------------------
 */

/* client specific stuff */

struct client_midi_str
{
    pluginclient_instance	*plugin;

    int				autostart;
    int				loop;
    int                         curr_loop;
    int                         starttime;
    int                         endtime;
    int                         volume;

    char                        *file_name;
    BOOL                        midi_playing;
    BOOL                        midi_paused;
};

typedef struct client_midi_str *client_midi_ptr;

/* ----------------------------------------------------------------------
 * GLOBALS
 * ----------------------------------------------------------------------
 */

static client_midi_ptr active_midi_client=NULL;

static int client_midi_file_types[] =
{
    osfile_TYPE_MIDI,
    -1				/* terminator */
};

/* Also see pluginclient_midi definition at end of file */

/* ----------------------------------------------------------------------
 * WIMP MESSAGE HANDLERS
 * ----------------------------------------------------------------------
 */

/* ----------------------------------------------------------------------
 * UTILITY FUNCTIONS
 * ----------------------------------------------------------------------
 */

static void get_env_str(const char *env_name, char *result, int result_len)
{
   char *env_str;

   if ((env_str = getenv (env_name)) != NULL)
      sprintf (result, "%.*s", result_len - 1, env_str);
   else
      result [0] = '\0';
} /* get_env_str */

static int param_bool(pluginclient_instance *plugin, const char *param_name,
                      int def)
{
    pluginclient_param *param;
    param = pluginclient_param_lookup(plugin, param_name, -1, FALSE);

    /* no parameter return the default */
    if (param == NULL)
	return def;

    /* no value then assume means TRUE */
    if (param->value == NULL)
	return TRUE;

    /* use the first letter to distinguish TRUE and FALSE */
    if (toupper(param->value[0]) == 'T')
	return TRUE;

    return FALSE;
} /* param_bool */

static void process_tag_params(pluginclient_instance *plugin, client_midi_ptr cmp)
{
  pluginclient_param *param;
  /* process tag parameters */

  cmp->autostart = param_bool(plugin, "AUTOSTART", FALSE);
  cmp->autostart = param_bool(plugin, "AUTOPLAY", cmp->autostart);

  /* sort out LOOP */
  cmp->loop = 0;
  param = pluginclient_param_lookup(plugin, "LOOP", -1, FALSE);

  if (param)
  {
    if (!param->value || toupper(param->value[0] == 'T')) /* present and true */
      cmp->loop = -1; /* loop forever */
    else if (param->value && !(toupper(param->value[0]) == 'F')) /* false */
    {
      if (toupper(param->value[0]) == 'I') /* infinite */
        cmp->loop = -1; /* loop forever */
      else if (sscanf(&param->value[0], "%d", &cmp->loop) == EOF) /* number */
        cmp->loop=-1; /* if conversion error, loop forever */
    } /* else if */
  } /* if */

  /* sort out STARTTIME */
  cmp->starttime = 0; /* default */
  param = pluginclient_param_lookup(plugin, "STARTTIME", -1, FALSE);

  if (param && param->value)  /* present, and has value */
  {
    char *temp_str;
    int min, sec;

    temp_str=strtok(&param->value[0], ":"); /* read up to ":" */

    if (temp_str && sscanf(temp_str, "%d", &min) != EOF) /* read minutes */
    {
      while (*(temp_str++)); /* move to rest of string */

      if (sscanf(temp_str, "%d", &sec) != EOF) /* read seconds */
      {
        cmp->starttime = (min * 60) + sec;
      } /* if */
    } /* if */
  } /* if */

  /* sort out ENDTIME */
  cmp->endtime = -1; /* default */
  param = pluginclient_param_lookup(plugin, "ENDTIME", -1, FALSE);

  if (param && param->value)  /* present, and has value */
  {
    char *temp_str;
    int min, sec;

    temp_str=strtok(&param->value[0], ":"); /* read up to ":" */
    if (temp_str && sscanf(temp_str, "%d", &min) != EOF) /* read minutes */
    {
      while (*(temp_str++)); /* move to rest of string */
      if (sscanf(temp_str, "%d", &sec) != EOF) /* read seconds */
      {
        cmp->endtime = (min * 60) + sec;
      } /* if */
    } /* if */
  } /* if */

  /* sort out VOLUME */
  cmp->volume=-1;  /* volume at max 100% */
  param = pluginclient_param_lookup(plugin, "VOLUME", -1, FALSE);

  if (param && param->value) /* present, and has value */
    sscanf(&param->value[0], "%d", &cmp->volume);

  TRACE2("process_tag_params(): AUTOSTART %d LOOP %d STARTTIME %d ENDTIME %d\n" _
         cmp->autostart _ cmp->loop _ cmp->starttime _ cmp->endtime);
  TRACE2("process_tag_params(): VOLUME %d\n" _
         cmp->volume);

} /* process_tag_params */


/* ----------------------------------------------------------------------
 * MODULE INIT/SHUTDOWN FUNCTIONS
 * ----------------------------------------------------------------------
 */

static void client_midi_init(int argc, char *argv[])
{
  _kernel_swi_regs regs;
  char temp_str[256];
  int temp_int;

  /* Poke client_midi_file_types address into client definition structure. */
  /* This avoids static init. data errors when building as a module.       */
  pluginclient_midi.file_type_list = &client_midi_file_types[0];
  
  /* read polyphony env var */
  get_env_str(APP_NAME "$MIDI_Polyphony", &temp_str[0], sizeof(temp_str));
  if (temp_str[0])
    if (sscanf(&temp_str[0], "%d", &temp_int) != 1)
      temp_str[0] = '\0'; /* to avoid confusion below */

  /* initialise synth module */
  regs.r[0] = 1; /* turn on */
  regs.r[1] = temp_str[0] ? temp_int : DEFAULT_POLYPHONY;

  TRACE4("Synth starting, polyphony = %d\n" _ regs.r[1]);

  err_fatal(_kernel_swi(SWI_SYNTH_ON, &regs, &regs));

  /* set memory limit */

  get_env_str(APP_NAME "$MIDI_MemLimit", &temp_str[0], sizeof(temp_str));
  if (temp_str[0])
    if (sscanf(&temp_str[0], "%d", &temp_int) != 1)
      temp_str[0] = '\0'; /* to avoid confusion below */

  regs.r[0] = 1;
  regs.r[1] = temp_str[0] ? temp_int : DEFAULT_MEMLIMIT;

  err_fatal(_kernel_swi(SWI_SYNTH_MEMORY, &regs, &regs));

} /* client_midi_init */

static void client_midi_shutdown(void)
{
  _kernel_swi_regs regs;

  /* initialise synth module */
  regs.r[0] = 0; /* turn off */

  TRACE4("Synth stopping\n");

  err_fatal(_kernel_swi(SWI_SYNTH_ON, &regs, &regs));

  regs.r[0] = -1;
  err_fatal(_kernel_swi(SWI_SYNTH_REMOVE_INSTRUMENT, &regs, &regs));

} /* client_midi_shutdown */

/* ----------------------------------------------------------------------
 * MISC INSTANCE EVENT HANDLERS
 * ----------------------------------------------------------------------
 */

static int client_midi_action(client_ptr cp, int reason)
{
  client_midi_ptr cmp = (client_midi_ptr) cp;
  _kernel_swi_regs regs;

  TRACE1("client_midi_action(): instance %p reason %d active client %p playing %d paused %d\n" _
         cmp _ reason _ active_midi_client _ cmp->midi_playing _ cmp->midi_paused);

  switch (reason)
  {
    case client_action_STOP:
           if ((active_midi_client==cmp) && cmp->midi_playing)
             err_report(_kernel_swi(SWI_MIDIPLAY_STOP, &regs, &regs));
           cmp->midi_playing=cmp->midi_paused=FALSE;
           pluginclient_send_busy(cmp->plugin, 0, plugin_state_STOP);
           break;

    case client_action_PLAY:
           /* if we're paused, unpause */
           if ((active_midi_client==cmp) && cmp->midi_paused)
           {
             regs.r[0] = 1; /* unpause */
             err_report(_kernel_swi(SWI_MIDIPLAY_START, &regs, &regs));
             pluginclient_send_busy(cmp->plugin, 0, plugin_state_PLAY);
           } /* if */

           /* if we're active but stopped, restart */
           else if ((active_midi_client==cmp) && !cmp->midi_playing)
           {
             regs.r[0] = 0;
             regs.r[1] = cmp->starttime * 100;
             err_report(_kernel_swi(SWI_MIDIPLAY_START, &regs, &regs));
             pluginclient_send_busy(cmp->plugin, 0, plugin_state_PLAY);
           } /* else if */

           /* if we're inactive, restart */
           else if (active_midi_client != cmp)
           {
             /* Just check */
             if (!cmp->file_name)
               return 1;

             /* stop the old client (if there is one) and become the new
              * active one */

             if (active_midi_client)
             {
               client_midi_action((client_ptr) active_midi_client,
                                  client_action_STOP);

               /* tell MIDI player to close file */
               err_report(_kernel_swi(SWI_MIDIPLAY_CLOSE, &regs, &regs));
               TRACE4("calling SWI_MIDIPLAY_CLOSE for %s\n" _ active_midi_client->file_name);
             } /* if */

             active_midi_client = cmp;

             /* tell MIDI player about file */
             regs.r[0] = 2; /* data type = file */
             regs.r[1] = (int) &cmp->file_name[0];
             regs.r[2] = 0; /* actually unused */
             regs.r[3] = 0; /* flags */
             err_report(_kernel_swi(SWI_MIDIPLAY_FILE, &regs, &regs));

             /* start playback */
             cmp->curr_loop=cmp->loop;
             client_midi_action(cp, client_action_UNMUTE);

             regs.r[0] = 0;
             regs.r[1] = cmp->starttime * 100;
             err_report(_kernel_swi(SWI_MIDIPLAY_START, &regs, &regs));
             pluginclient_send_busy(cmp->plugin, 0, plugin_state_PLAY);
           } /* else if */

           cmp->midi_playing=TRUE;
           cmp->midi_paused=FALSE;
           break;

    case client_action_PAUSE:
           if ((active_midi_client==cmp) && cmp->midi_playing)
           {
             err_report(_kernel_swi(SWI_MIDIPLAY_STOP, &regs, &regs));
             pluginclient_send_busy(cmp->plugin, 0, plugin_state_PAUSE);
             cmp->midi_paused=TRUE;
             cmp->midi_playing=FALSE;
           } /* if */
           break;

    case client_action_MUTE:
           if (active_midi_client==cmp)
           {
             regs.r[0] = 0; /* set volume to 0 */
             err_report(_kernel_swi(SWI_MIDIPLAY_VOLUME, &regs, &regs));
           } /* if */
           break;

    case client_action_UNMUTE:
           if (active_midi_client==cmp)
           {
             regs.r[0] = (cmp->volume==-1) ? 255 : cmp->volume; /* set volume to
                                                                 * volume or max
                                                                 */
             err_report(_kernel_swi(SWI_MIDIPLAY_VOLUME, &regs, &regs));
           } /* if */
           break;

    default:
           break;
  } /* switch */

  return 1;
} /* client_midi_action */


static void client_midi_idle(client_ptr cp)
{
  client_midi_ptr cmp = (client_midi_ptr) cp;
  _kernel_swi_regs regs;

  if ((active_midi_client==cmp) && cmp->midi_playing)
  {
    err_fatal(_kernel_swi(SWI_MIDIPLAY_INFO, &regs, &regs));

    /* has play stopped of own accord, or exceeded specified end time */
    if ((regs.r[2] == 0) ||
        ((cmp->endtime != -1) && ((regs.r[1] / 100) > cmp->endtime)))
    {
      if (regs.r[2] != 0) /* in other words, it was the other condition i.e.
                           * exceeding endtime that brought us in here */
      {
        err_fatal(_kernel_swi(SWI_MIDIPLAY_STOP, &regs, &regs));
      } /* if */
      cmp->midi_playing=cmp->midi_paused=FALSE;
      if (cmp->curr_loop & ~1) /* if 1 or 0 */
      {
        if (cmp->curr_loop != -1)
          cmp->curr_loop--;
        client_midi_action(cp, client_action_PLAY);
      } /* if */
      else
      {
        pluginclient_send_busy(cmp->plugin, 0, plugin_state_STOP);
      } /* else */
    } /* if */
  } /* if */

  return;
} /* client_midi_idle */


/* ----------------------------------------------------------------------
 * INSTANCE INITIALISATION FUNCTIONS
 * ----------------------------------------------------------------------
 */

static int client_midi_open(pluginclient_instance *plugin, client_ptr *client_data,
                            int *opening_flags)
{
    client_midi_ptr cmp = m_CALLOC (sizeof *cmp, 1);

    TRACE1("client_midi_open() cmp=%p\n" _ cmp);
    if (cmp)
    {
	/* store the instance value */
	cmp->plugin = plugin;

	/* check the parameters from the file */
	process_tag_params(plugin, cmp);

	*opening_flags = client_open_FETCH_DATA | client_open_ALLOW_ACTION;
    } /* if */

    *client_data = cmp;

    return (cmp != NULL);
} /* client_midi_open */


static void client_midi_close(client_ptr cp)
{
    client_midi_ptr cmp = (client_midi_ptr) cp;
    _kernel_swi_regs regs;

    TRACE1("client_midi_close(): instance %p\n" _ cmp);

    /* only tell it to stop if we were playing */
    if ((active_midi_client==cmp) && cmp->midi_playing)
    {
      _kernel_swi_regs regs;

      TRACE4("Stopping play\n");
      err_fatal(_kernel_swi(SWI_MIDIPLAY_STOP, &regs, &regs));
      cmp->midi_playing=cmp->midi_paused=FALSE;
    }
    /* we're no longer the one using the MIDI player */
    if (active_midi_client==cmp)
    {
      TRACE4("calling SWI_MIDIPLAY_CLOSE for %s\n" _ active_midi_client->file_name);
      active_midi_client=NULL;
      err_fatal(_kernel_swi(SWI_MIDIPLAY_CLOSE, &regs, &regs));
    } /* if */

    if (cmp->file_name) m_FREE(cmp->file_name, strlen (cmp->file_name) + 1);
    m_FREE(cmp, sizeof *cmp);
} /* client_midi_close */


/* ----------------------------------------------------------------------
 * INSTANCE EVENT HANDLERS FOR SCREEN EVENTS
 * ----------------------------------------------------------------------
 */

/* ----------------------------------------------------------------------
 * STREAM FUNCTIONS
 * ----------------------------------------------------------------------
 */

/*
 * The parent is opening a new stream to send to the client.
 *   Update the stream type.
 *   fill in stream->instance.plugin if we are likely to have more than one stream on the go
 *   at once.
 */

static void client_midi_stream_new(client_ptr cp, const char *mime_type,
                                   plugin_stream *stream, int seekable,
                                   int *stream_type)
{
    TRACE1("client_midi_stream_new(): instance %p\n" _ cp);

    /* Just tell them we only want the whole file */
    *stream_type = plugin_stream_TYPE_ASFILEONLY;
}

/*
 * The stream requested has finished downloading and is now available
 */

static int client_midi_stream_as_file(client_ptr cp, plugin_stream *stream,
                                      const char *cache_file)
{
    client_midi_ptr cmp = (client_midi_ptr) cp;

    TRACE1("client_midi_stream_as_file(): instance %p\n" _ cmp);

    if (!cmp->file_name) /* just in case */
      cmp->file_name = strdup(cache_file);

    /* start playback */
    if (cmp->autostart)
      client_midi_action(cp, client_action_PLAY);

    return 1;
}

/* ---------------------------------------------------------------------- */

/* play a straightforward file */
static client_ptr client_midi_play_file(const char *file_name, int filetype,
                                          ObjectId window_oid,
                                          pluginclient_instance *plugin)
{
  client_midi_ptr cmp;

  TRACE1("client_play_midi_file(): file \"%s\", type &%X, plugin %d\n" _ file_name _
         filetype _ plugin);

  /* create and clear cmp */
  cmp = m_CALLOC (sizeof *cmp, 1);

  if (cmp)
  {
    cmp->autostart=TRUE;
    cmp->loop = FALSE;
    cmp->starttime = 0;
    cmp->endtime = -1;
    cmp->volume = -1;
    cmp->plugin = plugin;

    cmp->file_name = strdup(file_name);

    client_midi_action(cmp, client_action_PLAY);
  } /* if */

  return (client_ptr) cmp;

  NOT_USED(filetype);
} /* client_midi_play_file */

/* ---------------------------------------------------------------------- */


/* externally available definition describing functions available */

pluginclient pluginclient_midi =
{
  &client_midi_init,
  &client_midi_shutdown,
  &client_midi_open,
  &client_midi_close,
  NULL, // &client_midi_set_window,
  NULL, // &client_midi_key,
  NULL, // &client_midi_click,
  NULL, // &client_midi_help,
  &client_midi_action,
  &client_midi_idle,
  NULL, // &client_midi_gain_caret,
  NULL, // &client_midi_lose_caret,
  NULL, // &client_midi_redraw_setup,
  NULL, // &client_midi_redraw,
  &client_midi_play_file,
  &client_midi_stream_new,
  &client_midi_stream_as_file,
  NULL, // &client_midi_stream_destroy,
  NULL  // Patched by client_midi_init.
};

/* eof clientmidi.c */
