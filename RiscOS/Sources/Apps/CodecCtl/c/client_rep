/* > client_rep.c
 *
 */

/* ----------------------------------------------------------------------
 * INCLUDES
 * ----------------------------------------------------------------------
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "swis.h"

#include "wimplib.h"
#include "window.h"
#include "event.h"

#include "plugclient.h"
#include "client.h"
#include "utils.h"

/* ----------------------------------------------------------------------
 * CONSTANTS
 * ----------------------------------------------------------------------
 */

#define osfile_TYPE_ARMOVIE                 0xAE7u
#define osfile_TYPE_AIFF                    0xFC2u
#define osfile_TYPE_AVI                     0xFB2u
#define osfile_TYPE_WAV                     0xFB1u
#define osfile_TYPE_FLI                     0xB9Fu
#define osfile_TYPE_REALAUDIO               0xF88u
#define osfile_TYPE_GENSOUND                0xF96u

#define REPLAY_MULTI_PAUSE                  (1<<0)
#define REPLAY_MULTI_MUTE                   (1<<1)
#define REPLAY_MULTI_EXIT                   (1<<2)
#define REPLAY_MULTI_FRAME_ADV              (1<<3)
#define REPLAY_MULTI_EXITCAP                (1<<4)
#define REPLAY_MULTI_INVIS_FRAMES           (1<<5)
#define REPLAY_MULTI_LOOP_END               (1<<6)
#define REPLAY_MULTI_NOVIDEO                (1<<7)
#define REPLAY_MULTI_PAINTIFPAUSED          (1<<8)
#define REPLAY_MULTI_ENDOFPLAY              (1<<9)

#define REPLAY_START_COMMAND                "/<ARMovie$Dir>.Player"

/* ----------------------------------------------------------------------
 * TYPE DEFINITIONS
 * ----------------------------------------------------------------------
 */

/* client specific stuff */

typedef void * (replay_open_handler)(int flags, WimpPollBlock *event);

typedef struct
{
    int task_handle;			/* our task handle */
    int wimp_handle;			/* wimp window handle of window to attach */
    replay_open_handler *open_handler;	/* filled in by Replay - call on Wimp_OpenWindow events */
} replay_mywindow_control;

typedef struct
{
    int *multi_status;
    BBox window_geom;
    int fps;
} multi_flag;

typedef struct
{
    replay_mywindow_control mywindow;
    multi_flag multi_flags;
} client_replay_rma_control;

typedef struct
{
    client_replay_rma_control *rma;	/* block allocated in the RMA */
    int replay_task;
    BOOL replay_running;
} client_replay_control;

struct client_replay_str
{
    pluginclient_instance	*plugin;

    char                        *file_name;
    int                         file_type;
    int				autostart;
    int				loop;
    int                         starttime;
    int                         endtime;
    int                         hidden;
    char                        href[1024];
    int                         volume;

    int				task_handle;
    ObjectId			window_handle;
    int				wimp_window;

    BOOL			has_focus;
    BOOL                        show_own_window;

    BBox			bbox;
    client_replay_control	*replay;
};

typedef struct client_replay_str *client_replay_ptr;

/* ----------------------------------------------------------------------
 * GLOBALS
 * ----------------------------------------------------------------------
 */

static int client_replay_file_types[] =
{
    osfile_TYPE_ARMOVIE,
    osfile_TYPE_AIFF,
    osfile_TYPE_AVI,
    osfile_TYPE_WAV,
    osfile_TYPE_FLI,
    osfile_TYPE_REALAUDIO,
    osfile_TYPE_GENSOUND,
    -1				/* terminator */
};

/* Also see pluginclient_replay definition at end of file */

/* ----------------------------------------------------------------------
 * FUNCTION PROTOTYPES
 * ----------------------------------------------------------------------
 */

static void replay_multi_end(client_replay_control *crc);


/* ----------------------------------------------------------------------
 * WIMP MESSAGE HANDLERS
 * ----------------------------------------------------------------------
 */

static int client_replay_open_win_handler(int event_code, WimpPollBlock *event,
                                          IdBlock *id_block, void *handle)
{
    client_replay_control *crc = (client_replay_control *) handle;

    if (crc->rma && crc->rma->mywindow.open_handler)
    {
      TRACE4("calling replay's open_handler()\n");
      err_report(crc->rma->mywindow.open_handler(0,event));
    }
    return 1;
} /* client_replay_open_win_handler */


static int client_replay_closedown_handler(WimpMessage *message, void *handle)
{
  client_replay_ptr crp = (client_replay_ptr) handle;

  if (message->hdr.sender == crp->replay->replay_task)
  {
    TRACE1("client_replay_closedown_handler: instance %p\n", crp);

    err_report(event_deregister_wimp_handler(crp->window_handle, Wimp_EOpenWindow,
                                             client_replay_open_win_handler,
                                             crp->replay));
    err_report(event_deregister_message_handler(Wimp_MTaskCloseDown,
                                                &client_replay_closedown_handler,
                                                crp));
    pluginclient_send_busy(crp->plugin, 0, plugin_busy_STOP);

    crp->replay->replay_running = FALSE;
    crp->replay->replay_task = 0;
    replay_multi_end(crp->replay);
    crp->replay=NULL;

    return 1;
  } /* if */

  return 0;
} /* client_replay_closedown_handler */


/* ----------------------------------------------------------------------
 * UTILITY FUNCTIONS
 * ----------------------------------------------------------------------
 */

/* read an int off the start of line, and ignore rest of line from file */
static int read_file_line_int(FILE *handle, int *value)
{
  char crap[1024];

  /* read int */
  if (fscanf(handle, "%d", value) == EOF)
  {
    TRACE4("error reading int from file\n");
    return 0;
  } /* if */

  /* go to next line */
  if (fgets(&crap[0], sizeof(crap), handle) == NULL)
  {
    TRACE4("error reading to next line of file\n");
    return 0;
  } /* if */

  return 1;
}

static int read_curr_screen_mode(int mode_var)
{
  _kernel_swi_regs regs;
  int carry;

  regs.r[0] = -1; /* current mode */
  regs.r[1] = mode_var;
  err_fatal(_kernel_swi_c(OS_ReadModeVariable, &regs, &regs, &carry));

  if (carry)
  {
    TRACE4("Error reading Mode Variable\n");
    exit(EXIT_FAILURE);
  } /* if */

  return regs.r[2];
} /* read_curr_screen_mode */

/*
 * read_xeig
 *
 * Returns the scaling factor between screen co-ordinates and pixels in the
 * x direction
 */

static int read_xeig(void)
{
  return (1 << read_curr_screen_mode(4));
} /* read_xeig */

/*
 * read_yeig
 *
 * Returns the scaling factor between screen co-ordinates and pixels in the
 * y direction
 */

static int read_yeig(void)
{
  return (1 << read_curr_screen_mode(5));
} /* read_yeig */

/*
 * read_xlimit
 *
 * Returns the width of the screen in pixels
 */

static int read_xlimit(void)
{
  return read_curr_screen_mode(11);
} /* read_xlimit */

/*
 * read_ylimit
 *
 * Returns the height of the screen in pixels
 */

static int read_ylimit(void)
{
  return read_curr_screen_mode(12);
} /* read_ylimit */

static void show_own_window(ObjectId window_handle, const char *file_name)
{
  FILE *replay_file;
  int i,x,y;
  WindowShowObjectBlock full_spec;

  TRACE4("show_own_window() handle %p file_name %s\n", window_handle, file_name);

  if ( (replay_file=fopen(file_name, "r"))==NULL )
  {
    TRACE4("show_own_window(): error opening file\n");
    return;
  } /* if */

  /* ignore first 4 lines */
  for (i=0; i<4; i++)
  {
    char value[1024];

    if (fgets(&value[0], sizeof(value), replay_file) == NULL)
    {
      TRACE4("error reading file\n");
      fclose(replay_file);
      return;
    } /* if */
  } /* for */

  /* read video format */
  if (!read_file_line_int(replay_file, &i) ||
      !read_file_line_int(replay_file, &x) ||   /* read x size */
      !read_file_line_int(replay_file, &y))     /* read y size */
  {
    fclose(replay_file);
    return;
  } /* if */

  fclose(replay_file);

  /* check video format is non-zero, i.e. has video */
  if (i==0)
    return; /* don't do anything if no video */

  if (!x || !y) return; /* nothing to show */

  /* reassign x and y to _real_ sizes for use on screen */
  x *= read_xeig() * 2;
  y *= read_yeig() * 2;

  /* centre on screen, word aligning to help work with replay */
  full_spec.visible_area.xmin = ROUND4((read_xlimit()*read_xeig() - x) / 2);
  full_spec.visible_area.xmax = full_spec.visible_area.xmin + x;
  full_spec.visible_area.ymin = ROUND4((read_ylimit()*read_yeig() - y) / 2);
  full_spec.visible_area.ymax = full_spec.visible_area.ymin + y;

  full_spec.xscroll = full_spec.yscroll = 0;
  full_spec.behind = -1;
  full_spec.window_flags = 0;
  full_spec.alignment_flags = 0;

  TRACE4("Showing window at xmin %d, ymin %d, xmax %d, ymax %d\n",
         full_spec.visible_area.xmin, full_spec.visible_area.ymin,
         full_spec.visible_area.xmax, full_spec.visible_area.ymax);

  /* show it */
  err_fatal(toolbox_show_object(0, window_handle, Toolbox_ShowObject_FullSpec,
                                &full_spec, 0, -1));
}

static void centre_in_window(int wimp_handle, const char *file_name,
                             int *windowx, int *windowy)
{
  FILE *replay_file;
  int i,x,y;
  WimpGetWindowStateBlock state;
  int window_height, window_width;

  TRACE4("centre_in_window() handle %08d file_name %s\n", wimp_handle, file_name);

  *windowx = *windowy = 0;

  if ( (replay_file=fopen(file_name, "r"))==NULL )
  {
    TRACE4("centre_in_window(): error opening file\n");
    return;
  } /* if */

  /* ignore first 4 lines */
  for (i=0; i<4; i++)
  {
    char value[1024];

    if (fgets(&value[0], sizeof(value), replay_file) == NULL)
    {
      TRACE4("error reading file\n");
      fclose(replay_file);
      return;
    } /* if */
  } /* for */

  /* read video format */
  if (!read_file_line_int(replay_file, &i) ||
      !read_file_line_int(replay_file, &x) ||   /* read x size */
      !read_file_line_int(replay_file, &y))     /* read y size */
  {
    fclose(replay_file);
    return;
  } /* if */

  fclose(replay_file);

  /* check video format is non-zero, i.e. has video */
  if (i==0)
    return; /* don't do anything if no video */

  if (!x || !y) return; /* nothing to show */

  /* reassign x and y to _real_ sizes for use on screen */
  x *= read_xeig() * 2;
  y *= read_yeig() * 2;

  state.window_handle = wimp_handle;
  err_fatal(wimp_get_window_state(&state));

  window_width  = state.visible_area.xmax - state.visible_area.xmin;
  window_height = state.visible_area.ymax - state.visible_area.ymin;

  *windowx = (x < window_width)  ? ((window_width  - x) / 2) : 0;
  *windowy = (y < window_height) ? ((window_height - y) / 2) : 0;

} /* centre_in_window */


static void replay_multi_end(client_replay_control *crc)
{
    if (crc)
    {
	if (crc->rma)
	    rma_free(crc->rma);
	free(crc);
    }
} /* replay_multi_end */

static client_replay_control *replay_multi_start(client_replay_ptr crp)
{
    client_replay_control *crc;
    char cmd_line[256];
    int n, x=0, y=0;

    crc = calloc(sizeof(*crc), 1);
    if (!crc)
	return NULL;

    crc->rma = rma_alloc(sizeof(*crc->rma));
    if (!crc->rma)
    {
        replay_multi_end(crc);
        return NULL;
    }

    /* set replay arguments that don't change */
    set_system_variable("ARMovie$ExtraArgs",
                        " -noerror -pollword -noadjust -nomenu");

    n = sprintf(cmd_line, REPLAY_START_COMMAND " %s", crp->file_name);

    /* if type isn't ARMOVIE, assume MovieFS is involved */
    if ((n < sizeof(cmd_line)) && (crp->file_type != osfile_TYPE_ARMOVIE))
    {
      FILE *temp_file;
      char temp_str[512];
      _kernel_oserror e;

      /* Check for MovieFS Error file */
      sprintf(&temp_str[0], "%s.Error", crp->file_name);

      temp_file=fopen(&temp_str[0], "r");

      if (temp_file) /* error file exists! */
      {
        e.errnum = 0;
        strcpy(&e.errmess[0], "Could not play multimedia file: ");
        fgets(&e.errmess[strlen(e.errmess)],
              sizeof(e.errmess)-strlen(e.errmess) - 1, temp_file);
        fclose(temp_file);

        TRACE4("%s found\n", &temp_str[0]);

        pluginclient_send_closed(crp->plugin, 0, &e, 0);

        return NULL;
      } /* if */

      /* check existence of .ARMovie file */

      sprintf(&temp_str[0], "%s.ARMovie", crp->file_name);
      temp_file=fopen(&temp_str[0], "r");

      if (!temp_file) /* not found */
      {
        TRACE4("%s not found\n", &temp_str[0]);
        return NULL;
      } /* if */

      fclose(temp_file);

      n += sprintf(cmd_line + n, ".ARMovie");
    } /* if */

    if (crp->show_own_window==TRUE && !crp->hidden)
      show_own_window(crp->window_handle,
                      cmd_line + strlen(REPLAY_START_COMMAND) + 1);
    else
      centre_in_window(crp->wimp_window,
                       cmd_line + strlen(REPLAY_START_COMMAND) + 1, &x, &y);

    crc->rma->mywindow.wimp_handle = crp->wimp_window;
    crc->rma->mywindow.task_handle = crp->task_handle;
    crc->rma->mywindow.open_handler = NULL;
    memset(&crc->rma->multi_flags, 0, sizeof(crc->rma->multi_flags));

    if (n < sizeof(cmd_line))
    {
        /* NB Resources (in file Res) set up so that bottom left of window is 0,0 */
        n += sprintf(cmd_line + n, " -at %d,%d -multi %d -mywindow %d",
                     x, y,
                     (int)&crc->rma->multi_flags,
                     (int)&crc->rma->mywindow);
    } /* if */

    if ((n < sizeof(cmd_line)) && (crp->loop==-1)) /* check at each stage that string won't
                                        * reach end of cmd_line */
    {
	n += sprintf(cmd_line + n, " -loop");
    } /* if */

    if ((n < sizeof(cmd_line)) && (crp->loop > 1))
    {
        n += sprintf(cmd_line + n, " -loop %d", crp->loop - 1);
    } /* if */

    if ((n < sizeof(cmd_line)) && (crp->starttime))
    {
        /* replay wants time in centiseconds */
        n += sprintf(cmd_line + n, " -startat %d", crp->starttime * 100);
    } /* if */

    if ((n < sizeof(cmd_line)) && (crp->endtime != -1))
    {
        /* replay wants time in centiseconds */
        n += sprintf(cmd_line + n, " -playfor %d",
                     (crp->endtime - crp->starttime) * 100);
    } /* if */

    if ((n < sizeof(cmd_line)) && (crp->hidden))
    {
        n += sprintf(cmd_line + n, " -novideo");
    } /* if */

    if ((n < sizeof(cmd_line)) && (!crp->hidden))
    {
      n += sprintf(cmd_line + n, " -pauseatend");
    } /* if */

    if ((n < sizeof(cmd_line)) && (crp->volume != -1)) /* volume on or off is
                                                        * all replay supports :-(
                                                        */
    {
        if (crp->volume == 0)
          n += sprintf(cmd_line + n, " -mute");
    } /* if */

    if (n >= sizeof(cmd_line))
      TRACE1("Warning, replay command-line over %d long!\n", sizeof(cmd_line));

    crc->replay_task=0;

    TRACE4("Starting replay, cmdline = %s\n", cmd_line);

    err_report(wimp_start_task(cmd_line, &crc->replay_task));

    if (crc->replay_task == 0) /* task has already quit */
    {
      TRACE4("replay failed to start!\n");
      crc->replay_running = FALSE;
      replay_multi_end(crc);
      return NULL;
    } /* if */

    crc->replay_running=TRUE;

    /* register handler so we know when replay closes */
    event_register_message_handler(Wimp_MTaskCloseDown,
                                   &client_replay_closedown_handler,
                                   crp);

    /* register open window event */
    event_register_wimp_handler(crp->window_handle, Wimp_EOpenWindow,
                                client_replay_open_win_handler, crc);

    pluginclient_send_busy(crp->plugin, 0, plugin_busy_PLAY);

    return crc;
} /* replay_multi_start */


static int param_bool(pluginclient_instance *plugin, const char *param_name,
                      int def)
{
    pluginclient_param *param;
    param = pluginclient_param_lookup(plugin, param_name, -1, FALSE);

    /* no parameter return the default */
    if (param == NULL)
	return def;

    /* no value then assume means TRUE */
    if (param->value == NULL)
	return TRUE;

    /* use the first letter to distinguish TRUE and FALSE */
    if (toupper(param->value[0]) == 'T')
	return TRUE;

    return FALSE;
} /* param_bool */

static void process_tag_params(pluginclient_instance *plugin, client_replay_ptr crp)
{
  pluginclient_param *param;
  /* process tag parameters */

  crp->autostart = param_bool(plugin, "AUTOSTART", FALSE);
  crp->autostart = param_bool(plugin, "AUTOPLAY", crp->autostart);

  /* sort out LOOP */
  crp->loop = 0;
  param = pluginclient_param_lookup(plugin, "LOOP", -1, FALSE);

  if (param)
  {
    if (!param->value || toupper(param->value[0] == 'T')) /* present and true */
      crp->loop = -1; /* loop forever */
    else if (param->value && !(toupper(param->value[0]) == 'F')) /* false */
    {
      if (toupper(param->value[0]) == 'I') /* infinite */
        crp->loop = -1; /* loop forever */
      else if (sscanf(&param->value[0], "%d", &crp->loop) == EOF) /* number */
        crp->loop=-1; /* if conversion error, loop forever */
    } /* else if */

  } /* if */

  /* sort out STARTTIME */
  crp->starttime = 0; /* default */
  param = pluginclient_param_lookup(plugin, "STARTTIME", -1, FALSE);

  if (param && param->value)  /* present, and has value */
  {
    char *temp_str;
    int min, sec;

    temp_str=strtok(&param->value[0], ":"); /* read up to ":" */

    if (temp_str && sscanf(temp_str, "%d", &min) != EOF) /* read minutes */
    {
      while (*(temp_str++)); /* move to rest of string */

      if (sscanf(temp_str, "%d", &sec) != EOF) /* read seconds */
      {
        crp->starttime = (min * 60) + sec;
      } /* if */
    } /* if */
  } /* if */

  /* sort out ENDTIME */
  crp->endtime = -1; /* default */
  param = pluginclient_param_lookup(plugin, "ENDTIME", -1, FALSE);

  if (param && param->value)  /* present, and has value */
  {
    char *temp_str;
    int min, sec;

    temp_str=strtok(&param->value[0], ":"); /* read up to ":" */
    if (temp_str && sscanf(temp_str, "%d", &min) != EOF) /* read minutes */
    {
      while (*(temp_str++)); /* move to rest of string */
      if (sscanf(temp_str, "%d", &sec) != EOF) /* read seconds */
      {
        crp->endtime = (min * 60) + sec;
      } /* if */
    } /* if */
  } /* if */

  crp->hidden = param_bool(plugin, "HIDDEN", FALSE);

  /* sort out HREF */
  crp->href[0] = '\0';
  param = pluginclient_param_lookup(plugin, "HREF", -1, FALSE);

  if (param && param->value)  /* present, and has value */
    strncpy(&crp->href[0], &param->value[0], sizeof(crp->href));

  /* sort out VOLUME */
  crp->volume=-1;  /* volume at max 100% */
  param = pluginclient_param_lookup(plugin, "VOLUME", -1, FALSE);

  if (param && param->value) /* present, and has value */
    sscanf(&param->value[0], "%d", &crp->volume);

  TRACE2("process_tag_params(): AUTOSTART %d LOOP %d STARTTIME %d ENDTIME %d\n",
         crp->autostart, crp->loop, crp->starttime, crp->endtime);
  TRACE2("process_tag_params(): HIDDEN %d HREF \"%s\" VOLUME %d\n",
         crp->hidden, crp->href, crp->volume);

} /* process_tag_params */


/* ----------------------------------------------------------------------
 * INSTANCE INITIALISATION FUNCTIONS
 * ----------------------------------------------------------------------
 */

static void client_replay_init(int argc, char *argv[])
{
  /* Poke client_replay_file_types address into client definition structure. */
  /* This avoids static init. data errors when building as a module.         */
  pluginclient_replay.file_type_list = &client_replay_file_types[0];
}


static int client_replay_open(pluginclient_instance *plugin, client_ptr *client_data,
                              int *opening_flags)
{
    client_replay_ptr crp = calloc(sizeof(*crp), 1);

    TRACE1("client_replay_open()\n");
    if (crp)
    {
	_kernel_swi_regs r;

	/* store the instance value */
	crp->plugin = plugin;

	/* get our task handle */

	toolbox_get_sys_info(Toolbox_GetSysInfo_TaskHandle, &r);
	crp->task_handle = r.r[0];

	/* check the parameters from the file */
	process_tag_params(plugin, crp);

	*opening_flags = client_open_FETCH_DATA | client_open_ALLOW_ACTION;

    }

    *client_data = crp;

    return crp != NULL;
} /* client_replay_open */


static void client_replay_close(client_ptr cp)
{
    client_replay_ptr crp = (client_replay_ptr) cp;

    TRACE1("client_replay_close(): instance %p\n", crp);

    if (crp->replay)
    {
      if (crp->replay->rma->multi_flags.multi_status)
        *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_EXIT;
      else
      {
        /* Have to send a quit message to replay as its not quite running
         * properly yet. Sigh :-( */
        WimpMessage message;
        message.hdr.size = sizeof(message.hdr);
        message.hdr.your_ref = 0;
        message.hdr.action_code = Wimp_MQuit;
        err_report(wimp_send_message(Wimp_EUserMessage, &message,
                                      crp->replay->replay_task, 0, NULL));
      } /* else */
      /* Don't send STOP message, as higher layer should know we're stopping */

      err_report(event_deregister_wimp_handler(crp->window_handle, Wimp_EOpenWindow,
                                               client_replay_open_win_handler,
                                               crp->replay));
      err_report(event_deregister_message_handler(Wimp_MTaskCloseDown,
                                                  &client_replay_closedown_handler,
                                                  crp));

      crp->replay->replay_running = FALSE;
      crp->replay->replay_task = 0;

      replay_multi_end(crp->replay);
      crp->replay = NULL;
    }

    if (crp->file_name)
      free(crp->file_name);
    free(crp);
} /* client_replay_close */


static void client_replay_set_window(client_ptr cp, ObjectId window_handle,
                                     BBox *bbox, BOOL subwindow)
{
    client_replay_ptr crp = (client_replay_ptr) cp;
    int window_changed = window_handle != crp->window_handle;

    TRACE1("client_replay_set_window(): instance %p id %d subwindow %d\n", crp,
            window_handle, subwindow);

    crp->bbox = *bbox;

    if (window_changed)
    {
	crp->window_handle = window_handle;
	err_fatal(window_get_wimp_handle(0, crp->window_handle, &crp->wimp_window));
    }

    if (subwindow==FALSE) crp->show_own_window=TRUE;
}

/* ----------------------------------------------------------------------
 * MISC INSTANCE EVENT HANDLERS
 * ----------------------------------------------------------------------
 */

static void client_replay_click(client_ptr cp, const WimpMouseClickEvent *click)
{
    client_replay_ptr crp = (client_replay_ptr) cp;

    TRACE1("client_replay_click(): instance %p\n", crp);

    wimp_set_caret_position(crp->wimp_window, -1, 0, 0, -1, -1);

    if ((crp->href[0] != '\0') && (click->buttons==Wimp_MouseButtonSelect))
    {
        pluginclient_browser_goto(crp->plugin, crp->href);
    } /* if */
}


static int client_replay_action(client_ptr cp, int reason)
{
  client_replay_ptr crp = (client_replay_ptr) cp;

  TRACE1("client_replay_action(): instance %p reason %d\n", crp, reason);

  switch (reason)
  {
    case client_action_STOP:
           if (crp->replay && crp->replay->replay_running)
           {
             *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_PAUSE;
             crp->replay->replay_running=FALSE;
             pluginclient_send_busy(crp->plugin, 0, plugin_busy_STOP);
           } /* if */
           break;

    case client_action_PLAY:
           if (crp->replay && crp->replay->replay_running)
           {
             *crp->replay->rma->multi_flags.multi_status &= ~REPLAY_MULTI_PAUSE;
           } /* if */
           else
           {
             /* start replay again */

             TRACE4("restarting replay\n");

             /* restart playback */
             if (crp->replay)
             {
               if (crp->replay->rma && crp->replay->rma->multi_flags.multi_status)
                 *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_EXIT;
               replay_multi_end(crp->replay);
             } /* if */

             crp->replay = replay_multi_start(crp);

             if (!crp->replay)
               return 0;

           } /* else */
           pluginclient_send_busy(crp->plugin, 0, plugin_busy_PLAY);

           break;

    case client_action_PAUSE:
           if (crp->replay && crp->replay->replay_running)
           {
             *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_PAUSE;
             pluginclient_send_busy(crp->plugin, 0, plugin_busy_PAUSE);
           } /* if */
           break;

    case client_action_MUTE:
           if (crp->replay && crp->replay->replay_running)
           {
             *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_MUTE;
           } /* if */
           break;

    case client_action_UNMUTE:
           if (crp->replay && crp->replay->replay_running)
           {
             *crp->replay->rma->multi_flags.multi_status &= ~REPLAY_MULTI_MUTE;
           } /* if */
           break;

    default:
           break;
  } /* switch */
  return 1;
} /* client_replay_action */

static void client_replay_idle(client_ptr cp)
{
  client_replay_ptr crp = (client_replay_ptr) cp;


  if (crp->replay && crp->replay->rma->multi_flags.multi_status)
  {
    if (*crp->replay->rma->multi_flags.multi_status & REPLAY_MULTI_ENDOFPLAY)
    {
      /* if replay has paused at end, we say that we aren't running so we don't
       * send STOP messages again */

      if (crp->replay->replay_running)
      {
        TRACE4("client_replay_idle() noticed end of play\n");
        crp->replay->replay_running = FALSE;
        pluginclient_send_busy(crp->plugin, 0, plugin_busy_STOP);
      } /* if */
    } /* if */
  } /* if */
} /* client_replay_idle */


/* ----------------------------------------------------------------------
 * INSTANCE EVENT HANDLERS FOR SCREEN EVENTS
 * ----------------------------------------------------------------------
 */

static void client_replay_focus(client_ptr cp)
{
    client_replay_ptr crp = (client_replay_ptr) cp;
    BBox box;

    box.xmin = box.ymin = -0x4000;
    box.xmax = box.ymax =  0x4000;

    TRACE1("client_replay_focus(): instance %p\n", crp);

    crp->has_focus = TRUE;
    window_force_redraw(0, crp->window_handle, &box);

    return;
}

static void client_replay_blur(client_ptr cp)
{
    client_replay_ptr crp = (client_replay_ptr) cp;
    BBox box;

    box.xmin = box.ymin = -0x4000;
    box.xmax = box.ymax =  0x4000;

    TRACE1("client_replay_blur(): instance %p\n", crp);

    crp->has_focus = FALSE;
    window_force_redraw(0, crp->window_handle, &box);
}

static _kernel_oserror *client_replay_redraw(client_ptr cp,
                                             WimpRedrawWindowBlock *r,
                                             int local)
{
    client_replay_ptr crp = (client_replay_ptr) cp;

    TRACE1("client_replay_redraw(): instance %p focus %d area %d,%d %d,%d\n",
	   crp, crp->has_focus,
	   r->redraw_area.xmin, r->redraw_area.ymin,
	   r->redraw_area.xmax, r->redraw_area.ymax);

    if (crp->replay && crp->replay->rma->multi_flags.multi_status &&
       (*crp->replay->rma->multi_flags.multi_status & REPLAY_MULTI_PAUSE))
    {
      /* ensure we repaint if paused */
      *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_PAINTIFPAUSED;
    } /* if */

    /* Just draw a black square - only happens if nothing is painting in
     * window, e.g. if HTML specifies window, but there's no video in the file */
    else
    {
	_swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4),
	      0x00000000, 0, 0); /* black */
	_swix(OS_Plot, _INR(0,2), 4, r->redraw_area.xmin, r->redraw_area.ymin);
	_swix(OS_Plot, _INR(0,2), 96 + 5, r->redraw_area.xmax, r->redraw_area.ymax);
    }

    return NULL;
    NOT_USED(local);
}

/* ----------------------------------------------------------------------
 * STREAM FUNCTIONS
 * ----------------------------------------------------------------------
 */

/*
 * The parent is opening a new stream to send to the client.
 *   Update the stream type.
 *   fill in stream->instance.plugin if we are likely to have more than one stream on the go
 *   at once.
 */

static void client_replay_stream_new(client_ptr cp, const char *mime_type,
                                     plugin_stream *stream, int seekable,
                                     int *stream_type)
{
    client_replay_ptr crp = (client_replay_ptr) cp;

    TRACE1("client_replay_stream_new(): instance %p\n", crp);

    /* Just tell them we only want the whole file */
    *stream_type = plugin_stream_TYPE_ASFILEONLY;
}

/*
 * The stream requested has finished downloading and is now available
 */

static int client_replay_stream_as_file(client_ptr cp, plugin_stream *stream,
                                        const char *cache_file)
{
    client_replay_ptr crp = (client_replay_ptr) cp;

    TRACE1("client_replay_stream_as_file(): instance %p\n", crp);

    crp->file_name = strdup(cache_file);
    if (!crp->file_name)
      return 0;

    crp->file_type = get_file_type(cache_file);

    /* start playback */
    if (crp->autostart)
    {
      crp->replay = replay_multi_start(crp);

      if (!crp->replay)
        return 0;
    } /* if */

    return 1;
}


/* ---------------------------------------------------------------------- */

/* play a straightforward file */
static client_ptr client_replay_play_file(const char *file_name, int filetype,
                                          ObjectId window_oid,
                                          pluginclient_instance *plugin)
{
  client_replay_ptr crp;
  _kernel_swi_regs regs;

  TRACE1("client_replay_play_file(): file \"%s\", type &%X, plugin %d\n", file_name,
         filetype, plugin);

  /* create and clear crp */
  crp = calloc(sizeof(*crp),1);

  if (crp)
  {
    crp->file_name = strdup(file_name);
    if (!crp->file_name)
    {
      free(crp);
      return NULL;
    } /* if */

    crp->file_type = filetype;
    crp->show_own_window=TRUE;
    crp->window_handle = window_oid;
    err_fatal(window_get_wimp_handle(0, crp->window_handle, &crp->wimp_window));
    err_fatal(toolbox_get_sys_info(Toolbox_GetSysInfo_TaskHandle, &regs));
    crp->task_handle = regs.r[0];
    crp->autostart=TRUE;
    crp->loop = FALSE;
    crp->starttime = 0;
    crp->endtime = -1;
    crp->hidden = FALSE;
    crp->href[0] = '\0';
    crp->volume = -1;
    crp->plugin = plugin;

    crp->replay = replay_multi_start(crp);

    if (!crp->replay)
      return NULL;
  } /* if */

  return (client_ptr) crp;

  NOT_USED(filetype);
} /* client_replay_play_file */

/* ---------------------------------------------------------------------- */


/* externally available definition describing functions available */

pluginclient pluginclient_replay =
{
  &client_replay_init,
  NULL, //  &client_replay_shutdown,
  &client_replay_open,
  &client_replay_close,
  &client_replay_set_window,
  NULL, //  &client_replay_key,
  &client_replay_click,
  NULL, //  &client_replay_help,
  &client_replay_action,
  &client_replay_idle,
  &client_replay_focus,
  &client_replay_blur,
  NULL, //  &client_replay_redraw_setup,
  &client_replay_redraw,
  &client_replay_play_file,
  &client_replay_stream_new,
  &client_replay_stream_as_file,
  NULL, //  &client_replay_stream_destroy,
  NULL  // Patched by client_replay_init.
};

/* eof client_rep.c */
