/* > client_rep.c
 *
 */

/* ----------------------------------------------------------------------
 * INCLUDES
 * ----------------------------------------------------------------------
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <swis.h>

#include "wimplib.h"
#include "window.h"
#include "event.h"

#include "m.h"
#include "plugclient.h"
#include "client.h"
#include "utils.h"

/*
   When to do a force_to_plain()? Cannot just be done in close, because if
the close causes a stop, the file is still open by replay and cannot be
forced to plain.

   Problem: we need for Replay to exit of its own accord, but any memory
we leave is owned only by that callback after the closed(). (The parent
plugin structure has been freed when the closed is called.)

   opened -> multi_start -> closedown (turn to image file now)
          -> multi_start -> close 
          -> multi_start -> stop -> close
          
   Separate replay_multi_end() into 2: replay_multi_closedown() called when
replay has already gone away; replay_multi_stop() called to stop replay.
Calling stop() will therefore cause closedown() to be called later.

   In closedown() we would just force the file to plain (and free its memory?).

   A plugin is tidied up when close() is called so we must leave no trace
after that.

   Just leave the closedown handler around? Can't because crp might be
deleted before it comes back. Change it not to use that? Can't be done (sends
a message to the browser using plugin).

   Special code?
   
   Can we even tell if Replay is still around? Yes---crp->replay != NULL. So
in close(), if crp->replay != NULL, we could queue a special message on
wimp_NULL_REASON_CODE that will force the file closed.

 */

/* ----------------------------------------------------------------------
 * CONSTANTS
 * ----------------------------------------------------------------------
 */

#define osfile_TYPE_ARMOVIE                 0xAE7u
#define osfile_TYPE_AIFF                    0xFC2u
#define osfile_TYPE_AVI                     0xFB2u
#define osfile_TYPE_WAV                     0xFB1u
#define osfile_TYPE_FLI                     0xB9Fu
#define osfile_TYPE_REALAUDIO               0xF88u
#define osfile_TYPE_GENSOUND                0xF96u

/*Replay status bits*/
#define REPLAY_MULTI_PAUSE                  (1<<0)
#define REPLAY_MULTI_MUTE                   (1<<1)
#define REPLAY_MULTI_EXIT                   (1<<2)
#define REPLAY_MULTI_FRAME_ADV              (1<<3)
#define REPLAY_MULTI_EXITCAP                (1<<4)
#define REPLAY_MULTI_INVIS_FRAMES           (1<<5)
#define REPLAY_MULTI_LOOP_END               (1<<6)
#define REPLAY_MULTI_NOVIDEO                (1<<7)
#define REPLAY_MULTI_PAINTIFPAUSED          (1<<8)
#define REPLAY_MULTI_ENDOFPLAY              (1<<9)

#define REPLAY_START_COMMAND                "/<ARMovie$Dir>.Player" /*must
                                            run Player direct, or we will
                                            reenter ourselves JRC 19 Jun
                                            1997*/

#define CMD_LINE_LIMIT                      256  /*longest command line possible for RISC O S*/
#define EXTRA_ARGS_LIMIT                    1024 /*buffer size for command buffer*/
#define SLACK_SPACE                         80   /*slack space to ensure we don't overrun*/

/* ----------------------------------------------------------------------
 * TYPE DEFINITIONS
 * ----------------------------------------------------------------------
 */

/* client specific stuff */

typedef _kernel_oserror *replay_open_handler (int, WimpPollBlock *);

typedef struct
{
    int task_handle;			/* our task handle */
    int wimp_handle;			/* wimp window handle of window to attach */
    replay_open_handler *open_handler;	/* filled in by Replay - call on Wimp_OpenWindow events */
} replay_mywindow_control;

typedef struct
{
    int *multi_status;
    BBox window_geom;
    int fps;
} multi_flag;

typedef struct
{
    replay_mywindow_control mywindow;
    multi_flag multi_flags;
} client_replay_rma_control;

typedef struct
{
    client_replay_rma_control *rma;	/* block allocated in the RMA */
    int replay_task;
    BOOL replay_running;
} client_replay_control;

struct client_replay_str
{
    pluginclient_instance	*plugin;

    char                        *file_name;
    int                         file_type;
    int				autostart;
    int				loop;
    int                         starttime;
    int                         endtime;
    int                         hidden;
    char                        href[1024];
    int                         volume;

    int				task_handle;
    ObjectId			window_handle;
    int				wimp_window;

    BOOL			has_focus;
    BOOL                        show_own_window;

    BBox			bbox;
    client_replay_control	*replay;

    int				stream_index;		/* stream number when using RealAudio */
};

typedef struct client_replay_str *client_replay_ptr;

/* ----------------------------------------------------------------------
 * GLOBALS
 * ----------------------------------------------------------------------
 */

static int client_replay_file_types[] =
{
    osfile_TYPE_ARMOVIE,
    osfile_TYPE_AIFF,
    osfile_TYPE_AVI,
    osfile_TYPE_WAV,
    osfile_TYPE_FLI,
    osfile_TYPE_REALAUDIO,
    osfile_TYPE_GENSOUND,
    -1				/* terminator */
};

static WimpEventHandler   client_replay_open_win_handler;
static WimpMessageHandler client_replay_closedown_handler;

/* ----------------------------------------------------------------------
 * UTILITY FUNCTIONS
 * ----------------------------------------------------------------------
 */

static int has_pick_streams(int file_type)
{
    /* return TRUE; */
    return file_type == osfile_TYPE_REALAUDIO;
}

/* read an int off the start of line, and ignore rest of line from file */
static _kernel_oserror *read_file_line_int (FILE *handle, int *value)
{
  char crap [1024];

  /* read int */
  if (fscanf(handle, "%d", value) == EOF)
    return utils_msgs_error_lookup (1, "Read");

  /* go to next line */
  if (fgets(crap, sizeof crap, handle) == NULL)
    return utils_msgs_error_lookup (1, "Read");

  return NULL;
}

static int read_curr_screen_mode(int mode_var)
{
  _kernel_swi_regs regs;
  int carry;

  regs.r[0] = -1; /* current mode */
  regs.r[1] = mode_var;
  err_fatal(_kernel_swi_c(OS_ReadModeVariable, &regs, &regs, &carry));

  if (carry)
  {
    TRACE5("Error reading Mode Variable\n");
    exit(EXIT_FAILURE);
  } /* if */

  return regs.r[2];
} /* read_curr_screen_mode */

/*
 * read_xeig
 *
 * Returns the scaling factor between screen co-ordinates and pixels in the
 * x direction
 */

static int read_xeig(void)
{
  return (1 << read_curr_screen_mode(4));
} /* read_xeig */

/*
 * read_yeig
 *
 * Returns the scaling factor between screen co-ordinates and pixels in the
 * y direction
 */

static int read_yeig(void)
{
  return (1 << read_curr_screen_mode(5));
} /* read_yeig */

/*
 * read_xlimit
 *
 * Returns the width of the screen in pixels
 */

static int read_xlimit(void)
{
  return read_curr_screen_mode(11);
} /* read_xlimit */

/*
 * read_ylimit
 *
 * Returns the height of the screen in pixels
 */

static int read_ylimit(void)
{
  return read_curr_screen_mode(12);
} /* read_ylimit */

static BOOL param_bool(pluginclient_instance *plugin, const char *param_name,
                      BOOL def)
{
    pluginclient_param *param;
    param = pluginclient_param_lookup(plugin, param_name, -1, FALSE);

    /* no parameter return the default */
    if (param == NULL)
	return def;

    /* no value then assume means TRUE */
    if (param->value == NULL)
	return TRUE;

    /* use the first letter to distinguish TRUE and FALSE */
    if (toupper(param->value[0]) == 'T')
	return TRUE;

    return FALSE;
} /* param_bool */

static void process_tag_params(pluginclient_instance *plugin, client_replay_ptr crp)
{
  pluginclient_param *param;
  /* process tag parameters */

  crp->autostart = param_bool(plugin, "AUTOPLAY", param_bool (plugin, "AUTOSTART", FALSE));

  /* sort out LOOP */
  crp->loop = 0;
  param = pluginclient_param_lookup(plugin, "LOOP", -1, FALSE);

  if (param != NULL)
  {
    if (param->value == NULL || toupper(param->value[0] == 'T')) /* present and true */
      crp->loop = -1; /* loop forever */
    else if (param->value != NULL && !(toupper(param->value[0]) == 'F')) /* false */
    {
      if (toupper(param->value[0]) == 'I') /* infinite */
        crp->loop = -1; /* loop forever */
      else if (sscanf(param->value, "%d", &crp->loop) == EOF) /* number */
        crp->loop=-1; /* if conversion error, loop forever */
    } /* else if */

  } /* if */

  /* sort out STARTTIME */
  crp->starttime = 0; /* default */
  param = pluginclient_param_lookup(plugin, "STARTTIME", -1, FALSE);

  if (param != NULL && param->value != NULL)  /* present, and has value */
  {
    char *temp_str;
    int min, sec;

    temp_str=strtok(param->value, ":"); /* read up to ":" */

    if (temp_str != NULL && sscanf(temp_str, "%d", &min) != EOF) /* read minutes */
    {
      while (*(temp_str++)); /* move to rest of string */

      if (sscanf(temp_str, "%d", &sec) != EOF) /* read seconds */
      {
        crp->starttime = (min * 60) + sec;
      } /* if */
    } /* if */
  } /* if */

  /* sort out ENDTIME */
  crp->endtime = -1; /* default */
  param = pluginclient_param_lookup(plugin, "ENDTIME", -1, FALSE);

  if (param != NULL && param->value != NULL)  /* present, and has value */
  {
    char *temp_str;
    int min, sec;

    temp_str=strtok(param->value, ":"); /* read up to ":" */
    if (temp_str != NULL && sscanf(temp_str, "%d", &min) != EOF) /* read minutes */
    {
      while (*(temp_str++)); /* move to rest of string */
      if (sscanf(temp_str, "%d", &sec) != EOF) /* read seconds */
      {
        crp->endtime = (min * 60) + sec;
      } /* if */
    } /* if */
  } /* if */

  crp->hidden = param_bool(plugin, "HIDDEN", FALSE);

  /* sort out HREF */
  crp->href[0] = '\0';
  param = pluginclient_param_lookup(plugin, "HREF", -1, FALSE);

  if (param != NULL && param->value != NULL)  /* present, and has value */
    strncpy(crp->href, param->value, sizeof crp->href);

  /* sort out VOLUME */
  crp->volume=-1;  /* volume at max 100% */
  param = pluginclient_param_lookup(plugin, "VOLUME", -1, FALSE);

  if (param != NULL && param->value != NULL) /* present, and has value */
    sscanf(param->value, "%d", &crp->volume);

  TRACE3 ("process_tag_params(): AUTOSTART %d LOOP %d STARTTIME %d ENDTIME %d\n" _
         crp->autostart _ crp->loop _ crp->starttime _ crp->endtime);
  TRACE3 ("process_tag_params(): HIDDEN %d HREF \"%s\" VOLUME %d\n" _
         crp->hidden _ crp->href _ crp->volume);

} /* process_tag_params */

/*If FileSwitch has opened the file as a directory (on behalf of MovieFS), we
   have to force it to close it by opening the file as a plain file and
   closing it again. JRC 16 Jul 1997*/

static void force_to_plain (char *file_name)
{
   FILE *file;

   TRACE3 ("+force_to_plain");

   if ((file = fopen (file_name, "r")) != NULL)
   {
      TRACE2 ("image file now plain again\n");
      (void) fclose (file);
   }
   else
      TRACE1 ("image file couldn't be forced back to plain\n");

   TRACE3 ("-force_to_plain");
}

static _kernel_oserror *show_own_window(ObjectId window_handle, const char *file_name,
      int *windowx, int *windowy)
{
   FILE *replay_file;
   int i, width, height;
   WindowShowObjectBlock full_spec;
   _kernel_oserror *error; /*not an error indicator!*/

   TRACE5("show_own_window() handle %p file_name %s\n" _ window_handle _
         file_name);

   if ((replay_file = fopen (file_name, "r")) == NULL)
   {
      TRACE5("show_own_window(): error opening file\n");
      return utils_msgs_error_lookup (1, "NotFound");
   } /* if */
 
   /* ignore first 4 lines */
   for (i = 0; i < 4; i++)
   {
      char value[1024];
 
      if (fgets (value, sizeof value, replay_file) == NULL)
      {
         TRACE5("error reading file\n");
         fclose(replay_file);
         return utils_msgs_error_lookup (1, "Read");
      } /* if */
   } /* for */

   /* read video format */
   if ((error = read_file_line_int(replay_file, &i)) != NULL ||
         (error = read_file_line_int(replay_file, &width)) != NULL || /*x size*/
         (error = read_file_line_int(replay_file, &height)) != NULL)   /*y size*/
   {
      fclose(replay_file);
      return error;
   } /* if */

   fclose(replay_file);

   /* check video format is non-zero, i.e. has video, and screen size is non-zero */
   if (i != 0 && width != 0 && height != 0)
   {
      /* reassign width and height to _real_ sizes for use on screen */
      width *= read_xeig() * 2;
      height *= read_yeig() * 2;

      /* centre on screen, word aligning to help work with replay */
      full_spec.visible_area.xmin = ALIGN ((read_xlimit()*read_xeig() - width)/2);
      full_spec.visible_area.xmax = full_spec.visible_area.xmin + width;
      full_spec.visible_area.ymin = ALIGN ((read_ylimit()*read_yeig() - height)/2);
      full_spec.visible_area.ymax = full_spec.visible_area.ymin + height;

      full_spec.xscroll = full_spec.yscroll = 0;
      full_spec.behind = -1;
      full_spec.window_flags = 0;
      full_spec.alignment_flags = 0;
 
      /*Return *window* coordinates to display movie at.*/
      *windowx = 0;
      *windowy = 0;
 
      TRACE5("Showing window at xmin %d, ymin %d, xmax %d, ymax %d\n" _
             full_spec.visible_area.xmin _ full_spec.visible_area.ymin _
             full_spec.visible_area.xmax _ full_spec.visible_area.ymax);

      /* show it */
      return toolbox_show_object(0, window_handle,
            Toolbox_ShowObject_FullSpec, &full_spec, 0, -1);
   }
   else
      return NULL;
}

static _kernel_oserror *centre_in_window(int wimp_window, const char *file_name,
                             int *windowx, int *windowy)
{
  FILE *replay_file;
  int i,width,height;
  WimpGetWindowStateBlock state;
  int window_height, window_width;
  _kernel_oserror *error; /*not an error indicator!*/

  TRACE5("centre_in_window() handle %08d file_name %s\n" _ wimp_window _ file_name);

  *windowx = *windowy = 0;

  if ( (replay_file=fopen(file_name, "r"))==NULL )
  {
    TRACE5("centre_in_window(): error opening file\n");
    return utils_msgs_error_lookup (1, "NotFound");
  } /* if */

  /* ignore first 4 lines */
  for (i=0; i<4; i++)
  {
    char value[1024];

    if (fgets(value, sizeof(value), replay_file) == NULL)
    {
      TRACE5("error reading file\n");
      fclose(replay_file);
      return utils_msgs_error_lookup (1, "Read");
    } /* if */
  } /* for */

  /* read video format */
  if ((error = read_file_line_int(replay_file, &i)) != NULL ||
      (error = read_file_line_int(replay_file, &width)) != NULL ||   /* read x size */
      (error = read_file_line_int(replay_file, &height)) != NULL)     /* read y size */
  {
    fclose(replay_file);
    return error;
  } /* if */

  fclose(replay_file);

  /* check video format is non-zero, i.e. has video */
  if (i != 0 && width != 0 && height != 0) /* don't do anything if no video */
  {
     /* reassign x and height to _real_ sizes for use on screen */
     width *= read_xeig() * 2;
     height *= read_yeig() * 2;

     state.window_handle = wimp_window;
     err_fatal(wimp_get_window_state(&state));

     window_width  = state.visible_area.xmax - state.visible_area.xmin;
     window_height = state.visible_area.ymax - state.visible_area.ymin;

     *windowx = (window_width  - width)/2;
     *windowy = (window_height - height)/2;
  }

  return NULL;
} /* centre_in_window */

/*
 * SJM: 13-Jun-97
 * Changed function so that only the replay file name goes on the command line
 * the rest of the parameters go in the system variable. This is necessary because the
 * command aliases get expanded and cause Too Long errors very easily.
 */

static _kernel_oserror *replay_multi_start(client_replay_ptr crp)
{
   char cmd_line [CMD_LINE_LIMIT]; /* only the filename and run commmand go in here */
   char extra_args [EXTRA_ARGS_LIMIT + SLACK_SPACE]; /* all other parameters go in here */
   char *msg;
   int n, x = 0, y = 0;
   _kernel_oserror *error = NULL; /*error indicator*/
   FILE *temp_file;
   char buffer [256];
   BOOL done_register_message_handler = FALSE;
   BOOL done_register_wimp_handler    = FALSE;
   BOOL fileswitch_opened_image_file  = FALSE;

   TRACE2 ("+replay_multi_start\n");

   m_ASSERT (crp != NULL);
   m_ASSERT (crp->replay == NULL);
   m_ASSERT (crp->file_name != NULL);

   if ((crp->replay = m_CALLOC (sizeof *crp->replay, 1)) == NULL)
   {
      error = utils_msgs_error_lookup (1, "Memory");
      TRACE3 ("finish\n");
      goto finish;
   }

   if ((crp->replay->rma = m_RMA_MALLOC (sizeof *crp->replay->rma)) == NULL)
   {
      error = utils_msgs_error_lookup (1, "Memory");
      TRACE3 ("finish\n");
      goto finish;
   }

   /* we are only putting the filename in cmd_line so assume it fits */
   sprintf (cmd_line, "%s %s", REPLAY_START_COMMAND, crp->file_name);

   /* if type isn't ARMOVIE, assume MovieFS is involved */
   if (crp->file_type != osfile_TYPE_ARMOVIE)
   {
       if (has_pick_streams(crp->file_type))
       {
	   /* ensure it has been closed, so we can select a new stream */
	   force_to_plain (crp->file_name);
	   
	   sprintf(extra_args, "RAPickStream %d", ++crp->stream_index);
	   TRACE2 ("stream %d oscli '%s'\n" _ crp->stream_index _ extra_args);
	   _kernel_oscli(extra_args);
       }

      /* Check for MovieFS Error file */
      sprintf (extra_args, "%s.Error", crp->file_name);
      temp_file = fopen (extra_args, "r");
      fileswitch_opened_image_file = TRUE; /*FileSwitch opens the image file regardless of
            whether the file within exists or not. JRC 16 Jul 1997*/

      if (temp_file != NULL) /* error file exists! */
      {
         TRACE5 ("%s found\n" _ extra_args);
         fgets (buffer, sizeof buffer - 1, temp_file);
         fclose (temp_file);

	 error = utils_msgs_error_lookup (1, "Play", buffer);

         TRACE3 ("finish\n");
         goto finish;
      } /* if */

      /* check existence of .ARMovie file */
      sprintf (extra_args, "%s.ARMovie", crp->file_name);
      temp_file = fopen (extra_args, "r");

      if (temp_file == NULL) /* not found */
      {
         TRACE5 ("%s not found\n" _ extra_args);
         error = utils_msgs_error_lookup (1, "Convert");
         TRACE3 ("finish\n");
         goto finish;
      } /* if */

      fclose (temp_file);

      /* add to the real file name ie cmd_line */
      strcat (cmd_line, ".ARMovie");
   } /* if */

   TRACE3 ("crp->show_own_window %s\n" _
         crp->show_own_window? "TRUE": "FALSE");
   if (crp->show_own_window)
   {
      if (!crp->hidden)
         if ((error = show_own_window (crp->window_handle,
               cmd_line + sizeof REPLAY_START_COMMAND, &x, &y)) != NULL)
         {
            TRACE3 ("finish\n");
            goto finish;
         }
   }
   else
   {
      if ((error = centre_in_window (crp->wimp_window,
            cmd_line + sizeof REPLAY_START_COMMAND, &x, &y)) != NULL)
      {
         TRACE3 ("finish\n");
         goto finish;
      }
   }

   m_ASSERT (crp->wimp_window != 0);
   crp->replay->rma->mywindow.wimp_handle = crp->wimp_window;
   m_ASSERT (crp->task_handle != 0);
   crp->replay->rma->mywindow.task_handle = crp->task_handle;
   crp->replay->rma->mywindow.open_handler = NULL;
   memset (&crp->replay->rma->multi_flags, '\0', sizeof crp->replay->rma->multi_flags);

   /* initialise the cmd buffer here */
   n = sprintf(extra_args, " -noerror -pollword -noadjust -nomenu");

   /* NB Resources (in file Res) set up so that bottom left of window is 0,0 */
   if ((n += sprintf (extra_args + n, " -at %d,%d -multi %d -mywindow %d",
         x, y,
         (int) &crp->replay->rma->multi_flags,
         (int) &crp->replay->rma->mywindow)) >= EXTRA_ARGS_LIMIT)
   {
      error = utils_msgs_error_lookup (1, "TooLong");
      TRACE3 ("finish\n");
      goto finish;
   }

   TRACE3 ("crp->loop %d\n" _ crp->loop);
   if (crp->loop == -1)
   {
      if ((n += sprintf (extra_args + n, " -loop")) >= EXTRA_ARGS_LIMIT)
      {
         error = utils_msgs_error_lookup (1, "TooLong");
         TRACE3 ("finish\n");
         goto finish;
      }
   }
   else if (crp->loop > 1)
   {
      if ((n += sprintf (extra_args + n, " -loop %d", crp->loop - 1)) >=
            EXTRA_ARGS_LIMIT)
      {
         error = utils_msgs_error_lookup (1, "TooLong");
         TRACE3 ("finish\n");
         goto finish;
      }
   }

   TRACE3 ("crp->starttime %d\n" _ crp->starttime);
   if (crp->starttime != 0)
      /* replay wants time in centiseconds */
      if ((n += sprintf (extra_args + n, " -startat %d", crp->starttime*100))
            >= EXTRA_ARGS_LIMIT)
      {
         error = utils_msgs_error_lookup (1, "TooLong");
         TRACE3 ("finish\n");
         goto finish;
      }

   TRACE3 ("crp->endtime %d\n" _ crp->endtime);
   if (crp->endtime != -1)
       /* replay wants time in centiseconds */
       if ((n += sprintf (extra_args + n, " -playfor %d",
             (crp->endtime - crp->starttime)*100)) >= EXTRA_ARGS_LIMIT)
       {
          error = utils_msgs_error_lookup (1, "TooLong");
          TRACE3 ("finish\n");
          goto finish;
       }

   TRACE3 ("crp->hidden %d\n" _ crp->hidden);
   if (crp->hidden)
       if ((n += sprintf (extra_args + n, " -novideo")) >= EXTRA_ARGS_LIMIT)
       {
          error = utils_msgs_error_lookup (1, "TooLong");
          TRACE3 ("finish\n");
          goto finish;
       }
   /*Close the window when the movie finishes. (Deleted code |else {if ((n +=
      sprintf (extra_args + n, " -pauseatend")) >= EXTRA_ARGS_LIMIT) {error =
      utils_msgs_error_lookup (1, "TooLong"); goto finish;}}|.) JRC 5 Jun 1997*/

   TRACE3 ("crp->volume %d\n" _ crp->volume);
   if (crp->volume == 0) /* volume on or off is all replay supports :-( */
      if ((n += sprintf (extra_args + n, " -mute")) >= EXTRA_ARGS_LIMIT)
      {
         error = utils_msgs_error_lookup (1, "TooLong");
         TRACE3 ("finish\n");
         goto finish;
      }

   TRACE2 ("Starting replay, cmd_line \"%s\", extra_args \"%s\"\n" _
         cmd_line _ extra_args);
   set_system_variable("ARMovie$ExtraArgs", extra_args);
   if ((error = utils_start_task (cmd_line, REPLAY_SLOT, &crp->replay->replay_task)) != NULL)
   {
      TRACE3 ("finish\n");
      goto finish;
   }

   TRACE3 ("crp->replay->replay_task 0x%X\n" _ crp->replay->replay_task);
   if (crp->replay->replay_task == 0)
   {
      if ((msg = getenv ("ARMovie$ReturnCode")) != NULL && msg [0] != '\0')
         error = utils_msgs_error_lookup (1, "Exit", msg);
      else
         error = utils_msgs_error_lookup (1, "Start");

      TRACE3 ("finish\n");
      goto finish;
   }

   /*Replay has filled in |crp->replay->rma->mywindow.open_handler| with an open
      handler function.*/
   crp->replay->replay_running = TRUE;

   /* register handler so we know when replay closes */
   if ((error = event_register_message_handler (Wimp_MTaskCloseDown,
         &client_replay_closedown_handler, crp)) != NULL)
   {
      TRACE3 ("finish\n");
      goto finish;
   }
   done_register_message_handler = TRUE;

   /* register open window event */
   if ((error = event_register_wimp_handler (crp->wimp_window, Wimp_EOpenWindow,
         client_replay_open_win_handler, crp->replay)) != NULL)
   {
      TRACE3 ("finish\n");
      goto finish;
   }
   done_register_wimp_handler = TRUE;

   pluginclient_send_busy (crp->plugin, 0, plugin_state_PLAY);

finish:
   if (error != NULL)
   {
      TRACE2 ("error finish 0x%x \"%s\"\n" _ error->errnum _ error->errmess);

      /* don't report an error on realaudio follow on streams, we
	 should really report the error if it is not the no more
	 streams error, however we can only tell that by string
	 comparisons which is so yucky I'm not going to do that */
      if (!has_pick_streams(crp->file_type) || crp->stream_index == 1)
	  pluginclient_send_closed(crp->plugin, 0, error, 0);

      /* deregister handler */
      if (done_register_message_handler)
         (void) event_deregister_message_handler (Wimp_MTaskCloseDown,
               &client_replay_closedown_handler, crp);

      if (crp->replay != NULL)
      {
         /* deregister open window event */
         if (done_register_wimp_handler)
            (void) event_deregister_wimp_handler (crp->wimp_window, Wimp_EOpenWindow,
                  client_replay_open_win_handler, crp->replay);

         if (fileswitch_opened_image_file)
            /*If FileSwitch has opened the file as a directory (on behalf of
               MovieFS), we have to force it to close it by opening the file
               as a plain file and closing it again. JRC 16 Jul 1997*/
            force_to_plain (crp->file_name);

         if (crp->replay->rma != NULL)
            m_RMA_FREE (crp->replay->rma, sizeof *crp->replay->rma);

         m_FREE (crp->replay, sizeof *crp->replay);

         crp->replay = NULL;
      }
   }

   TRACE2 ("-replay_multi_start\n");
   return error;
} /* replay_multi_start */

/* Also see pluginclient_replay definition at end of file */

/* This function can get called EITHER when replay has exited anyway (from
   the Wimp_CloseDown message handler) OR when the browser wants to stop the
   Replay task (as a result of user interaction.*/

static _kernel_oserror *replay_multi_end (client_replay_ptr crp, BOOL tell_browser)
{
   pluginclient_instance *plugin;
   WimpMessage            message;

   TRACE2 ("+replay_multi_end\n");
   m_ASSERT (crp->replay != NULL);
   m_ASSERT (crp->replay->rma != NULL);

   if (crp->show_own_window)
      /*Close the window now. JRC Tue 3rd June 1997*/
      err_report (toolbox_hide_object (0u, crp->window_handle));

   err_report (event_deregister_wimp_handler (crp->wimp_window,
         Wimp_EOpenWindow, client_replay_open_win_handler, crp->replay));

   if (crp->replay->rma->multi_flags.multi_status != NULL)
      /*Replay still here. Tell it to go away (and clear up all our resources anyway).*/
      *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_EXIT;
   else
   {
      /* Have to send a quit message to Replay as its not quite running
       * properly yet. Sigh :-( */
      message.hdr.size = sizeof(message.hdr);
      message.hdr.your_ref = 0;
      message.hdr.action_code = Wimp_MQuit;
      err_report(wimp_send_message(Wimp_EUserMessage, &message,
                                   crp->replay->replay_task, 0, NULL));
   }

   plugin = crp->plugin;

   err_report(event_deregister_message_handler (Wimp_MTaskCloseDown,
	 &client_replay_closedown_handler, crp));

   m_RMA_FREE (crp->replay->rma, sizeof *crp->replay->rma);

   m_FREE (crp->replay, sizeof *crp->replay);
   crp->replay = NULL;

   if (tell_browser)
      pluginclient_send_busy (plugin, 0, plugin_state_STOP);

   TRACE2 ("-replay_multi_end\n");
   return NULL;
} /* replay_multi_end */

/* ----------------------------------------------------------------------
 * WIMP MESSAGE HANDLERS
 * ----------------------------------------------------------------------
 */

static int client_replay_closedown_handler(WimpMessage *message, void *handle)
{
   client_replay_ptr crp = (client_replay_ptr) handle;

   TRACE2 ("+client_replay_closedown_handler: crp %p\n" _ crp);
   m_ASSERT (crp != NULL);
   m_ASSERT (crp->replay != NULL);

   if (pluginclient_exists (crp->plugin))
      if (crp->replay->replay_task == message->hdr.sender)
      {
         replay_multi_end (crp, /*tell_browser?*/ TRUE);

	 if (has_pick_streams(crp->file_type))
	 {
	     TRACE2 ("restarting for next stream\n");
	     /* if this gave an error it has already been reported to
                the user by the error handler or multi_start */
	     replay_multi_start (crp);
	 }
	 
	 TRACE2 ("-client_replay_closedown_handler\n");
         return 1;
      } /* if */

   TRACE2 ("-client_replay_closedown_handler\n");
   return 0;
} /* client_replay_closedown_handler */

static int client_replay_open_win_handler(int event_code, WimpPollBlock *event,
                                          IdBlock *id_block, void *handle)
{
    client_replay_control *crc = (client_replay_control *) handle;

    TRACE2 ("+client_replay_open_win_handler: crc %p\n" _ crc);
    NOT_USED (id_block), NOT_USED (event_code);

    if (crc->rma != NULL && crc->rma->mywindow.open_handler != NULL)
    {
      TRACE5("calling replay's open_handler()\n");
      err_report(crc->rma->mywindow.open_handler(0,event));
    }

    TRACE2 ("-client_replay_open_win_handler\n");
    return 1;
} /* client_replay_open_win_handler */

/* Function to be registered for 1 call when a file has to be forced to
   plain.*/

static int force_to_plain_handler (int event_code, WimpPollBlock *event,
      IdBlock *id_block, void *handle)
{
   char *file_name = (char *) handle;

   TRACE2 ("+force_to_plain_handler: file_name %s\n" _ file_name);
   m_ASSERT (event_code == Wimp_ENull);
   NOT_USED (event_code), NOT_USED (event), NOT_USED (id_block);

   /*Deregister ourselves.*/
   (void) event_deregister_wimp_handler (-1, Wimp_ENull,
         &force_to_plain_handler, file_name);

   /*Do our work.*/
   force_to_plain (file_name);

   /*Don't leave unfreed memory.*/
   m_FREE (file_name, strlen (file_name) + 1);

   TRACE2 ("-force_to_plain_handler\n");
   return 1;
} /* force_to_plain_handler */

/* ----------------------------------------------------------------------
 * INSTANCE INITIALISATION FUNCTIONS
 * ----------------------------------------------------------------------
 */

static _kernel_oserror *client_replay_init(int argc, char *argv[])
{
  TRACE2 ("+client_replay_init\n");
  NOT_USED (argc), NOT_USED (argv);
  
  /* Poke client_replay_file_types address into client definition structure. */
  /* This avoids static init. data errors when building as a module.         */
  pluginclient_replay.file_type_list = client_replay_file_types;
  TRACE2 ("-client_replay_init\n");
  return NULL;
}

static _kernel_oserror *client_replay_open(pluginclient_instance *plugin, client_ptr *client_data,
                              int *opening_flags)
{
   client_replay_ptr crp;
   _kernel_swi_regs r;
   _kernel_oserror *error = NULL;

   TRACE2 ("+client_replay_open\n");

   if ((crp = m_CALLOC (sizeof *crp, 1)) == NULL)
   {
      error = utils_msgs_error_lookup (1, "Memory");
      goto finish;
   }

   /* store the instance value */
   crp->plugin = plugin;

   /* get our task handle */
   if ((error = toolbox_get_sys_info(Toolbox_GetSysInfo_TaskHandle, &r)) != NULL)
      goto finish;
   crp->task_handle = r.r[0];

   /* check the parameters from the file */
   process_tag_params(plugin, crp);

   *opening_flags = plugin_opening_FETCH_DATA | plugin_opening_CAN_ACTION;
   *client_data = crp;

finish:
   TRACE2 ("-client_replay_open\n");
   return error;
} /* client_replay_open */

static _kernel_oserror *client_replay_close(client_ptr *cp)
{
   client_replay_ptr crp = (client_replay_ptr) *cp;

   TRACE2("+client_replay_close(): crp %p\n" _ crp);

   if (crp->replay != NULL)
   {
      if (crp->file_type != osfile_TYPE_ARMOVIE)
         /*Queue a message to make sure the file gets closed. If we don't
            have the memory to close it, it just stays open. This is bad,
            but as far as I can see, unavoidable. JRC 17 Jul 1997*/
	 /* SJM 980520 this used to be != NULL */
         if (event_register_wimp_handler (-1, Wimp_ENull,
               &force_to_plain_handler, crp->file_name) == NULL)
            /*Memory used for file_name is now owned by
               force_to_plain_handler().*/
            crp->file_name = NULL;

      replay_multi_end (crp, /*don't tell browser, as higher layer should
            know we're stopping*/ FALSE);
   }
   else
   {
      /*Replay not running---we can force the file back to plain now (if
         there ever was one).*/
      if (crp->file_name != NULL)
      {
         if (crp->file_type != osfile_TYPE_ARMOVIE)
            force_to_plain (crp->file_name);

         m_FREE (crp->file_name, strlen (crp->file_name) + 1);
      }
   }

   m_FREE(crp, sizeof *crp);

   *cp = NULL;

   TRACE2("-client_replay_close()\n");
   return NULL;
} /* client_replay_close */

static _kernel_oserror *client_replay_set_window(client_ptr cp, ObjectId window_handle,
                                     BBox *bbox, BOOL subwindow)
{
   client_replay_ptr crp = (client_replay_ptr) cp;
   BOOL window_changed = window_handle != crp->window_handle;

   TRACE2("+client_replay_set_window(): crp %p id %d subwindow %d\n" _ crp _
           window_handle _ subwindow);

   crp->bbox = *bbox;

   if (window_changed)
   {
      /*Deregister the handler for the window we used to have ...*/
      err_report (event_deregister_wimp_handler (crp->wimp_window,
            Wimp_EOpenWindow, &client_replay_open_win_handler, crp->replay));

      crp->window_handle = window_handle;
      err_report (window_get_wimp_handle (0u, crp->window_handle,
            &crp->wimp_window));

      /*... and reregister a new one. JRC Tue 3rd June 1997*/
      err_report (event_register_wimp_handler (crp->wimp_window,
            Wimp_EOpenWindow, &client_replay_open_win_handler, crp->replay));
   }

   if (!subwindow) crp->show_own_window=TRUE;

   TRACE2("-client_replay_set_window()\n");
  return NULL;
}

/* ----------------------------------------------------------------------
 * MISC INSTANCE EVENT HANDLERS
 * ----------------------------------------------------------------------
 */

static _kernel_oserror *client_replay_click(client_ptr cp, const WimpMouseClickEvent *click)
{
    client_replay_ptr crp = (client_replay_ptr) cp;

    TRACE2("+client_replay_click(): crp %p\n" _ crp);

    wimp_set_caret_position(crp->wimp_window, -1, 0, 0, -1, -1);

    if (crp->href[0] != '\0' && click->buttons == Wimp_MouseButtonSelect)
    {
        pluginclient_browser_goto(crp->plugin, crp->href);
    } /* if */
    
    TRACE2("-client_replay_click()\n");
  return NULL;
}

static _kernel_oserror *client_replay_action (client_ptr cp, int reason)
{
   client_replay_ptr crp = (client_replay_ptr) cp;
   _kernel_oserror *error = NULL;

   TRACE2("+client_replay_action(): crp %p reason %d\n" _ crp _ reason);
   switch (reason)
   {
      case plugin_state_STOP:
         if (crp->replay != NULL)
            if ((error = replay_multi_end (crp, /*tell_browser?*/ TRUE)) != NULL)
               goto finish;
      break;

      case plugin_state_PLAY:
         if (crp->replay != NULL && crp->replay->replay_running)
         {
            if (crp->replay->rma->multi_flags.multi_status != NULL)
               *crp->replay->rma->multi_flags.multi_status &=
                     ~REPLAY_MULTI_PAUSE;
         } /* if */
         else if (crp->file_name != NULL)
               /*C13283: The browser can send us PLAY messages before it has
                  sent us a STREAM_AS_FILE message or a PLAY_FILE message (as
                  indicated by the presence of a |file_name| field). Just
                  ignore it in this case. JRC 7 Jul 1997*/
         {
            /* start replay again */
            TRACE5("restarting replay\n");

            /* restart playback */
            if (crp->replay != NULL)
               (void) replay_multi_end (crp, /*tell browser?*/ FALSE);

	    crp->stream_index = 0;
            if ((error = replay_multi_start (crp)) != NULL)
               goto finish;
         }

         pluginclient_send_busy(crp->plugin, 0, plugin_state_PLAY);
      break;

      case plugin_state_PAUSE:
             if (crp->replay != NULL && crp->replay->replay_running)
             {
               if (crp->replay->rma->multi_flags.multi_status != NULL)
                  *crp->replay->rma->multi_flags.multi_status |=
                        REPLAY_MULTI_PAUSE;
               pluginclient_send_busy(crp->plugin, 0, plugin_state_PAUSE);
             } /* if */
      break;

      case plugin_state_MUTE:
            if (crp->replay != NULL && crp->replay->replay_running)
               if (crp->replay->rma->multi_flags.multi_status != NULL)
                  *crp->replay->rma->multi_flags.multi_status |=
                        REPLAY_MULTI_MUTE;
      break;

      case plugin_state_UNMUTE:
            if (crp->replay != NULL && crp->replay->replay_running)
               if (crp->replay->rma->multi_flags.multi_status != NULL)
                  *crp->replay->rma->multi_flags.multi_status &=
                        ~REPLAY_MULTI_MUTE;
      break;
   } /* switch */

finish:
   TRACE2("-client_replay_action()\n");
   return error;
} /* client_replay_action */

static _kernel_oserror *client_replay_idle(client_ptr cp)
{
  client_replay_ptr crp = (client_replay_ptr) cp;
  
  TRACE3 ("+client_replay_idle\n");

  if (crp->replay != NULL && crp->replay->rma->multi_flags.multi_status != NULL)
  {
    if ((*crp->replay->rma->multi_flags.multi_status & REPLAY_MULTI_ENDOFPLAY) != 0u)
    {
      /* if replay has paused at end, we say that we aren't running so we don't
       * send STOP messages again */
      if (crp->replay->replay_running)
      {
        TRACE2("client_replay_idle() noticed end of play\n");
        crp->replay->replay_running = FALSE;
        pluginclient_send_busy(crp->plugin, 0, plugin_state_STOP);
      } /* if */
    } /* if */
  } /* if */
  
  TRACE3 ("-client_replay_idle\n");
  return NULL;
} /* client_replay_idle */

/* ----------------------------------------------------------------------
 * INSTANCE EVENT HANDLERS FOR SCREEN EVENTS
 * ----------------------------------------------------------------------
 */

static _kernel_oserror *client_replay_gain_caret(client_ptr cp)
{
    client_replay_ptr crp = (client_replay_ptr) cp;
    BBox box;

    TRACE2("+client_replay_gain_caret(): crp %p\n" _ crp);

    box.xmin = box.ymin = -0x4000;
    box.xmax = box.ymax =  0x4000;

    crp->has_focus = TRUE;
    window_force_redraw(0, crp->window_handle, &box);

    TRACE2("-client_replay_gain_caret()\n");
  return NULL;
}

static _kernel_oserror *client_replay_lose_caret(client_ptr cp)
{
    client_replay_ptr crp = (client_replay_ptr) cp;
    BBox box;

    TRACE2("+client_replay_lose_caret(): crp %p\n" _ crp);

    box.xmin = box.ymin = -0x4000;
    box.xmax = box.ymax =  0x4000;

    crp->has_focus = FALSE;
    window_force_redraw(0, crp->window_handle, &box);

    TRACE2("-client_replay_lose_caret()\n");
  return NULL;
}

static _kernel_oserror *client_replay_redraw(client_ptr cp,
                                             WimpRedrawWindowBlock *r,
                                             int local)
{
    client_replay_ptr crp = (client_replay_ptr) cp;

    TRACE2("+client_replay_redraw(): crp %p focus %d area %d,%d %d,%d\n" _
	   crp _ crp->has_focus _
	   r->redraw_area.xmin _ r->redraw_area.ymin _
	   r->redraw_area.xmax _ r->redraw_area.ymax);

    if (crp->replay != NULL && crp->replay->rma->multi_flags.multi_status != NULL &&
          (*crp->replay->rma->multi_flags.multi_status & REPLAY_MULTI_PAUSE)
          != 0u)
    {
      /* ensure we repaint if paused */
      *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_PAINTIFPAUSED;
    } /* if */
    else
    {
       /* Just draw a black square - only happens if nothing is painting in
        * window, e.g. if HTML specifies window, but there's no video in the file */
	_swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4),
	      0x00000000, 0, 0); /* black */
	_swix(OS_Plot, _INR(0,2), 4, r->redraw_area.xmin, r->redraw_area.ymin);
	_swix(OS_Plot, _INR(0,2), 96 + 5, r->redraw_area.xmax, r->redraw_area.ymax);
    }

    TRACE2("-client_replay_redraw\n");

    return NULL;
    NOT_USED(local);
}

/* ----------------------------------------------------------------------
 * STREAM FUNCTIONS
 * ----------------------------------------------------------------------
 */

/*
 * The parent is opening a new stream to send to the client.
 *   Update the stream type.
 *   fill in stream->instance.plugin if we are likely to have more than one stream on the go
 *   at once.
 */

static _kernel_oserror *client_replay_stream_new(client_ptr cp, const char *mime_type,
                                     plugin_stream *stream, int seekable,
                                     int *stream_type)
{
   TRACE2("+client_replay_stream_new(): crp %p\n" _ cp);
    
   NOT_USED (cp), NOT_USED (seekable), NOT_USED (stream), NOT_USED (mime_type);

   /* Just tell them we only want the whole file */
   *stream_type = plugin_stream_TYPE_ASFILEONLY;
    
   TRACE2("-client_replay_stream_new()\n");
   return NULL;
}

/*
 * The stream requested has finished downloading and is now available
 */

static _kernel_oserror *client_replay_stream_as_file(client_ptr cp, plugin_stream *stream,
                                        const char *cache_file)
{
   client_replay_ptr crp = (client_replay_ptr) cp;
   _kernel_oserror *error = NULL; 

   TRACE2 ("+client_replay_stream_as_file(): crp %p\n" _ crp);
   NOT_USED (stream);

   if ((crp->file_name = strdup (cache_file)) == NULL)
   {
      error = utils_msgs_error_lookup (1, "Memory");
      goto finish;
   }

   crp->file_type = get_file_type (cache_file);
   crp->stream_index = 0;

   /* start playback */
   if (crp->autostart)
      if ((error = replay_multi_start (crp)) != NULL)
         goto finish;

finish:
   TRACE2("-client_replay_stream_as_file(): file type %x\n" _ crp->file_type);
   return error;
}


/* ---------------------------------------------------------------------- */

/* play a straightforward file */
static _kernel_oserror *client_replay_play_file(const char *file_name, int filetype,
                                          ObjectId window_handle,
                                          pluginclient_instance *plugin, client_ptr *cp)
{
   client_replay_ptr crp = NULL;
   _kernel_swi_regs regs;
   _kernel_oserror *error = NULL;

   TRACE2("+client_replay_play_file(): file \"%s\", type &%X, plugin %d, "
         "window_handle 0x%X\n" _ file_name _ filetype _ plugin _ window_handle);

   /*Might not be linked into list yet. JRC 1 Jul 1997*/

   /* create and clear crp */
   if ((crp = m_CALLOC (sizeof *crp, 1)) == NULL)
   {
      error = utils_msgs_error_lookup (1, "Memory");
      goto finish;
   }

   if ((crp->file_name = strdup (file_name)) == NULL)
   {
      error = utils_msgs_error_lookup (1, "Memory");
      goto finish;
   } /* if */

   crp->file_type       = filetype;
   crp->show_own_window = TRUE;
   crp->window_handle   = window_handle;
   err_fatal(window_get_wimp_handle(0, crp->window_handle, &crp->wimp_window));
   err_fatal(toolbox_get_sys_info(Toolbox_GetSysInfo_TaskHandle, &regs));
   crp->task_handle     = regs.r[0];
   crp->autostart       = TRUE;
   crp->loop            = FALSE;
   crp->starttime       = 0;
   crp->endtime         = -1;
   crp->hidden          = FALSE;
   crp->href [0]        = '\0';
   crp->volume          = -1;
   crp->plugin          = plugin;
   crp->stream_index	= 0;
   
   if ((error = replay_multi_start (crp)) != NULL)
      goto finish;
   /*IF THERE was anything that could go wrong after this, we would have to
      stop it again---but there isn't.*/

   *cp = (client_ptr) crp;

finish:
   if (error != NULL)
   {
      if (crp != NULL)
      {
         if (crp->file_name != NULL)
            m_FREE (crp->file_name, strlen (crp->file_name) + 1);

         m_FREE (crp, sizeof *crp);
      }
   }

   TRACE2("-client_replay_play_file()\n");
   return error;
} /* client_replay_play_file */

/* ---------------------------------------------------------------------- */

/* externally available definition describing functions available */

pluginclient pluginclient_replay =
{
  &client_replay_init,
  NULL, /*  &client_replay_shutdown,*/
  &client_replay_open,
  &client_replay_close,
  &client_replay_set_window,
  NULL, /*  &client_replay_key,*/
  &client_replay_click,
  NULL, /*  &client_replay_help,*/
  &client_replay_action,
  &client_replay_idle,
  &client_replay_gain_caret,
  &client_replay_lose_caret,
  NULL, /*  &client_replay_redraw_setup,*/
  &client_replay_redraw,
  &client_replay_play_file,
  &client_replay_stream_new,
  &client_replay_stream_as_file,
  NULL, /*  &client_replay_stream_destroy,*/
  NULL  /* Patched by client_replay_init.*/
};

/* eof client_rep.c */
