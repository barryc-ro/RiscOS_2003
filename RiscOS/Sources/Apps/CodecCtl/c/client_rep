/* > client_rep.c
 *
 */

/* ----------------------------------------------------------------------
 * INCLUDES
 * ----------------------------------------------------------------------
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <swis.h>

#include "wimplib.h"
#include "window.h"
#include "event.h"

#include "m.h"
#include "plugclient.h"
#include "client.h"
#include "utils.h"

/* ----------------------------------------------------------------------
 * CONSTANTS
 * ----------------------------------------------------------------------
 */

#define osfile_TYPE_ARMOVIE                 0xAE7u
#define osfile_TYPE_AIFF                    0xFC2u
#define osfile_TYPE_AVI                     0xFB2u
#define osfile_TYPE_WAV                     0xFB1u
#define osfile_TYPE_FLI                     0xB9Fu
#define osfile_TYPE_REALAUDIO               0xF88u
#define osfile_TYPE_GENSOUND                0xF96u

#define REPLAY_MULTI_PAUSE                  (1<<0)
#define REPLAY_MULTI_MUTE                   (1<<1)
#define REPLAY_MULTI_EXIT                   (1<<2)
#define REPLAY_MULTI_FRAME_ADV              (1<<3)
#define REPLAY_MULTI_EXITCAP                (1<<4)
#define REPLAY_MULTI_INVIS_FRAMES           (1<<5)
#define REPLAY_MULTI_LOOP_END               (1<<6)
#define REPLAY_MULTI_NOVIDEO                (1<<7)
#define REPLAY_MULTI_PAINTIFPAUSED          (1<<8)
#define REPLAY_MULTI_ENDOFPLAY              (1<<9)

#define REPLAY_START_COMMAND                "/<ARMovie$Dir>.Player" /*must
                                            run Player direct, or we will
                                            reenter ourselves JRC 19 Jun
                                            1997*/

#define CMD_LINE_LIMIT                      256  /*longest command line possible for RISC O S*/
#define EXTRA_ARGS_LIMIT                    1024 /*buffer size for command buffer*/
#define SLACK_SPACE                         80   /*slack space to ensure we don't overrun*/

static
   _kernel_oserror
      Error_Too_Long  = {1, "Replay command line too long"},
      Error_Not_Found = {1, "File %s not found"};

/* ----------------------------------------------------------------------
 * TYPE DEFINITIONS
 * ----------------------------------------------------------------------
 */

/* client specific stuff */

typedef _kernel_oserror *replay_open_handler (int, WimpPollBlock *);

typedef struct
{
    int task_handle;			/* our task handle */
    int wimp_handle;			/* wimp window handle of window to attach */
    replay_open_handler *open_handler;	/* filled in by Replay - call on Wimp_OpenWindow events */
} replay_mywindow_control;

typedef struct
{
    int *multi_status;
    BBox window_geom;
    int fps;
} multi_flag;

typedef struct
{
    replay_mywindow_control mywindow;
    multi_flag multi_flags;
} client_replay_rma_control;

typedef struct
{
    client_replay_rma_control *rma;	/* block allocated in the RMA */
    int replay_task;
    BOOL replay_running;
} client_replay_control;

struct client_replay_str
{
    pluginclient_instance	*plugin;

    char                        *file_name;
    int                         file_type;
    int				autostart;
    int				loop;
    int                         starttime;
    int                         endtime;
    int                         hidden;
    char                        href[1024];
    int                         volume;

    int				task_handle;
    ObjectId			window_handle;
    int				wimp_window;

    BOOL			has_focus;
    BOOL                        show_own_window;

    BBox			bbox;
    client_replay_control	*replay;
};

typedef struct client_replay_str *client_replay_ptr;

/* ----------------------------------------------------------------------
 * GLOBALS
 * ----------------------------------------------------------------------
 */

static int client_replay_file_types[] =
{
    osfile_TYPE_ARMOVIE,
    osfile_TYPE_AIFF,
    osfile_TYPE_AVI,
    osfile_TYPE_WAV,
    osfile_TYPE_FLI,
    osfile_TYPE_REALAUDIO,
    osfile_TYPE_GENSOUND,
    -1				/* terminator */
};

/* Also see pluginclient_replay definition at end of file */

static void replay_multi_end(client_replay_control *crc)
{
    TRACE1 ("+replay_multi_end\n");
    
    if (crc != NULL)
    {
	if (crc->rma != NULL)
	    rma_free(crc->rma);
	m_FREE(crc, sizeof *crc);
    }
    
    TRACE1 ("-replay_multi_end\n");
} /* replay_multi_end */

/* ----------------------------------------------------------------------
 * WIMP MESSAGE HANDLERS
 * ----------------------------------------------------------------------
 */

static int client_replay_open_win_handler(int event_code, WimpPollBlock *event,
                                          IdBlock *id_block, void *handle)
{
    client_replay_control *crc = (client_replay_control *) handle;

    TRACE1 ("+client_replay_open_win_handler: crc %p\n" _ crc);
    
    if (crc->rma != NULL && crc->rma->mywindow.open_handler != NULL)
    {
      TRACE4("calling replay's open_handler()\n");
      err_report(crc->rma->mywindow.open_handler(0,event));
    }

    TRACE1 ("-client_replay_open_win_handler\n");
    return 1;
} /* client_replay_open_win_handler */

static int client_replay_closedown_handler(WimpMessage *message, void *handle)
{
   client_replay_ptr crp = (client_replay_ptr) handle;
 
   TRACE1("+client_replay_closedown_handler: crp %p\n" _ crp);

   if (message->hdr.sender == crp->replay->replay_task)
   {
      if (crp->show_own_window)
         /*Close the window now. JRC Tue 3rd June 1997*/
         err_report (toolbox_hide_object (0u, crp->window_handle));

      if (crp->replay != NULL)
         err_report (event_deregister_wimp_handler (crp->wimp_window,
               Wimp_EOpenWindow, client_replay_open_win_handler, crp->replay));
      err_report(event_deregister_message_handler(Wimp_MTaskCloseDown,
            &client_replay_closedown_handler, crp));
      pluginclient_send_busy(crp->plugin, 0, plugin_state_STOP);
 
      crp->replay->replay_running = FALSE;
      crp->replay->replay_task = 0;
      replay_multi_end(crp->replay);
      crp->replay=NULL;

      TRACE1("-client_replay_closedown_handler\n");
      return 1;
   } /* if */
 
   TRACE1("-client_replay_closedown_handler\n");
   return 0;
} /* client_replay_closedown_handler */


/* ----------------------------------------------------------------------
 * UTILITY FUNCTIONS
 * ----------------------------------------------------------------------
 */

/* read an int off the start of line, and ignore rest of line from file */
static _kernel_oserror *read_file_line_int (FILE *handle, int *value)
{
  char crap [1024];

  /* read int */
  if (fscanf(handle, "%d", value) == EOF)
  {
    TRACE4("error reading int from file\n");
    return utils_last_oserror ();
  } /* if */

  /* go to next line */
  if (fgets(crap, sizeof crap, handle) == NULL)
  {
    TRACE4("error reading to next line of file\n");
    return utils_last_oserror ();
  } /* if */

  return NULL;
}

static int read_curr_screen_mode(int mode_var)
{
  _kernel_swi_regs regs;
  int carry;

  regs.r[0] = -1; /* current mode */
  regs.r[1] = mode_var;
  err_fatal(_kernel_swi_c(OS_ReadModeVariable, &regs, &regs, &carry));

  if (carry)
  {
    TRACE4("Error reading Mode Variable\n");
    exit(EXIT_FAILURE);
  } /* if */

  return regs.r[2];
} /* read_curr_screen_mode */

/*
 * read_xeig
 *
 * Returns the scaling factor between screen co-ordinates and pixels in the
 * x direction
 */

static int read_xeig(void)
{
  return (1 << read_curr_screen_mode(4));
} /* read_xeig */

/*
 * read_yeig
 *
 * Returns the scaling factor between screen co-ordinates and pixels in the
 * y direction
 */

static int read_yeig(void)
{
  return (1 << read_curr_screen_mode(5));
} /* read_yeig */

/*
 * read_xlimit
 *
 * Returns the width of the screen in pixels
 */

static int read_xlimit(void)
{
  return read_curr_screen_mode(11);
} /* read_xlimit */

/*
 * read_ylimit
 *
 * Returns the height of the screen in pixels
 */

static int read_ylimit(void)
{
  return read_curr_screen_mode(12);
} /* read_ylimit */

static _kernel_oserror *show_own_window(ObjectId window_handle, const char *file_name,
      int *windowx, int *windowy)
{
   FILE *replay_file;
   int i, width, height;
   WindowShowObjectBlock full_spec;
   _kernel_oserror *error;

   TRACE4("show_own_window() handle %p file_name %s\n" _ window_handle _
         file_name);

   if ((replay_file = fopen (file_name, "r")) == NULL)
   {
      TRACE4("show_own_window(): error opening file\n");
      sprintf (Error_Not_Found.errmess, "File %s not found", file_name);
      return &Error_Not_Found;
   } /* if */
 
   /* ignore first 4 lines */
   for (i = 0; i < 4; i++)
   {
      char value[1024];
 
      if (fgets (value, sizeof value, replay_file) == NULL)
      {
         TRACE4("error reading file\n");
         fclose(replay_file);
         return utils_last_oserror ();
      } /* if */
   } /* for */

   /* read video format */
   if ((error = read_file_line_int(replay_file, &i)) != NULL ||
       (error = read_file_line_int(replay_file, &width)) != NULL || /*x size*/
       (error = read_file_line_int(replay_file, &height)) != NULL)   /*y size*/
   {
      fclose(replay_file);
      return error;
   } /* if */

   fclose(replay_file);

   /* check video format is non-zero, i.e. has video, and screen size is non-zero */
   if (i != 0 && width != 0 && height != 0)
   {
      /* reassign width and height to _real_ sizes for use on screen */
      width *= read_xeig() * 2;
      height *= read_yeig() * 2;

      /* centre on screen, word aligning to help work with replay */
      full_spec.visible_area.xmin = ALIGN ((read_xlimit()*read_xeig() - width)/2);
      full_spec.visible_area.xmax = full_spec.visible_area.xmin + width;
      full_spec.visible_area.ymin = ALIGN ((read_ylimit()*read_yeig() - height)/2);
      full_spec.visible_area.ymax = full_spec.visible_area.ymin + height;

      full_spec.xscroll = full_spec.yscroll = 0;
      full_spec.behind = -1;
      full_spec.window_flags = 0;
      full_spec.alignment_flags = 0;
 
      /*Return *window* coordinates to display movie at.*/
      *windowx = 0;
      *windowy = 0;
 
      TRACE4("Showing window at xmin %d, ymin %d, xmax %d, ymax %d\n" _
             full_spec.visible_area.xmin _ full_spec.visible_area.ymin _
             full_spec.visible_area.xmax _ full_spec.visible_area.ymax);

      /* show it */
      return toolbox_show_object(0, window_handle,
            Toolbox_ShowObject_FullSpec, &full_spec, 0, -1);
   }
   else
      return NULL;
}

static _kernel_oserror *centre_in_window(int wimp_window, const char *file_name,
                             int *windowx, int *windowy)
{
  FILE *replay_file;
  int i,width,height;
  WimpGetWindowStateBlock state;
  int window_height, window_width;
  _kernel_oserror *error;

  TRACE4("centre_in_window() handle %08d file_name %s\n" _ wimp_window _ file_name);

  *windowx = *windowy = 0;

  if ( (replay_file=fopen(file_name, "r"))==NULL )
  {
    TRACE4("centre_in_window(): error opening file\n");
    sprintf (Error_Not_Found.errmess, "File %s not found", file_name);
    return &Error_Not_Found;
  } /* if */

  /* ignore first 4 lines */
  for (i=0; i<4; i++)
  {
    char value[1024];

    if (fgets(value, sizeof(value), replay_file) == NULL)
    {
      TRACE4("error reading file\n");
      fclose(replay_file);
      return utils_last_oserror ();
    } /* if */
  } /* for */

  /* read video format */
  if ((error = read_file_line_int(replay_file, &i)) != NULL ||
      (error = read_file_line_int(replay_file, &width)) != NULL ||   /* read x size */
      (error = read_file_line_int(replay_file, &height)) != NULL)     /* read y size */
  {
    fclose(replay_file);
    return error;
  } /* if */

  fclose(replay_file);

  /* check video format is non-zero, i.e. has video */
  if (i != 0 && width != 0 && height != 0) /* don't do anything if no video */
  {
     /* reassign x and height to _real_ sizes for use on screen */
     width *= read_xeig() * 2;
     height *= read_yeig() * 2;

     state.window_handle = wimp_window;
     err_fatal(wimp_get_window_state(&state));

     window_width  = state.visible_area.xmax - state.visible_area.xmin;
     window_height = state.visible_area.ymax - state.visible_area.ymin;

     *windowx = (window_width  - width)/2;
     *windowy = (window_height - height)/2;
  }

  return NULL;
} /* centre_in_window */

/*
 * SJM: 13-Jun-97
 * Changed function so that only the replay file name goes on the command line
 * the rest of the parameters go in the system variable. This is necessary because the
 * command aliases get expanded and cause Too Long errors very easily.
 */

static client_replay_control *replay_multi_start(client_replay_ptr crp)
{
   client_replay_control *crc;
   char cmd_line [CMD_LINE_LIMIT]; /* only the filename and run commmand go in here */
   char extra_args [EXTRA_ARGS_LIMIT + SLACK_SPACE]; /* all other parameters go in here */
   char *msg;
   int n, x = 0, y = 0, len;
   _kernel_oserror *error = NULL; /*error indicator*/
   FILE *temp_file;

   static _kernel_oserror Local_Error = {1, ""}; /*error buffer*/

   TRACE1 ("+replay_multi_start\n");

   if ((crc = m_CALLOC (sizeof *crc, 1)) == NULL)
   {
      error = &Error_No_Mem;
      TRACE2 ("finish\n");
      goto finish;
   }

   if ((crc->rma = rma_malloc (sizeof *crc->rma)) == NULL)
   {
      error = &Error_No_Mem;
      TRACE2 ("finish\n");
      goto finish;
   }

   /* we are only putting the filename in cmd_line so assume it fits */
   strcpy(cmd_line, REPLAY_START_COMMAND " ");
   strcat(cmd_line, crp->file_name);

   /* if type isn't ARMOVIE, assume MovieFS is involved */
   if (crp->file_type != osfile_TYPE_ARMOVIE)
   {
      /* Check for MovieFS Error file */
      sprintf (extra_args, "%s.Error", crp->file_name);
      temp_file = fopen (extra_args, "r");
 
      if (temp_file != NULL) /* error file exists! */
      {
         TRACE4 ("%s found\n" _ extra_args);
         strcpy (Local_Error.errmess, "Could not play multimedia file: ");
         len = strlen (Local_Error.errmess);
         fgets (Local_Error.errmess + len, sizeof Local_Error.errmess - len - 1, temp_file);
         fclose (temp_file);

         error = &Local_Error;
         TRACE2 ("finish\n");
         goto finish;
      } /* if */

      /* check existence of .ARMovie file */
      sprintf (extra_args, "%s.ARMovie", crp->file_name);
      temp_file = fopen (extra_args, "r");

      if (temp_file == NULL) /* not found */
      {
         TRACE4 ("%s not found\n" _ extra_args);
         sprintf (Error_Not_Found.errmess, "Could not play multimedia file: File %s not found",
               extra_args);
         error = &Error_Not_Found;
         TRACE2 ("finish\n");
         goto finish;
      } /* if */
 
      fclose (temp_file);

      /* add to the real file name ie cmd_line */
      strcat (cmd_line, ".ARMovie");
   } /* if */

   TRACE2 ("crp->show_own_window %s\n" _ crp->show_own_window? "TRUE": "FALSE");
   if (crp->show_own_window)
   {
      if (!crp->hidden)
         if ((error = show_own_window (crp->window_handle,
               cmd_line + sizeof REPLAY_START_COMMAND, &x, &y)) != NULL)
         {
            TRACE2 ("finish\n");
            goto finish;
         }
   }
   else
   {
      if ((error = centre_in_window (crp->wimp_window,
            cmd_line + sizeof REPLAY_START_COMMAND, &x, &y)) != NULL)
      {
         TRACE2 ("finish\n");
         goto finish;
      }
   }

   crc->rma->mywindow.wimp_handle = crp->wimp_window;
   crc->rma->mywindow.task_handle = crp->task_handle;
   crc->rma->mywindow.open_handler = NULL;
   memset (&crc->rma->multi_flags, '\0', sizeof crc->rma->multi_flags);

   /* initialise the cmd buffer here */
   n = sprintf(extra_args, " -noerror -pollword -noadjust -nomenu");

   /* NB Resources (in file Res) set up so that bottom left of window is 0,0 */
   if ((n += sprintf (extra_args + n, " -at %d,%d -multi %d -mywindow %d",
         x, y,
         (int) &crc->rma->multi_flags,
         (int) &crc->rma->mywindow)) >= EXTRA_ARGS_LIMIT)
   {
      error = &Error_Too_Long;
      TRACE2 ("finish\n");
      goto finish;
   }

   TRACE2 ("crp->loop %d\n" _ crp->loop);
   if (crp->loop == -1)
   {
      if ((n += sprintf (extra_args + n, " -loop")) >= EXTRA_ARGS_LIMIT)
      {
         error = &Error_Too_Long;
         TRACE2 ("finish\n");
         goto finish;
      }
   }
   else if (crp->loop > 1)
   {
      if ((n += sprintf (extra_args + n, " -loop %d", crp->loop - 1)) >=
            EXTRA_ARGS_LIMIT)
      {
         error = &Error_Too_Long;
         TRACE2 ("finish\n");
         goto finish;
      }
   }

   TRACE2 ("crp->starttime %d\n" _ crp->starttime);
   if (crp->starttime != 0)
      /* replay wants time in centiseconds */
      if ((n += sprintf (extra_args + n, " -startat %d", crp->starttime*100))
            >= EXTRA_ARGS_LIMIT)
      {
         error = &Error_Too_Long;
         TRACE2 ("finish\n");
         goto finish;
      }

   TRACE2 ("crp->endtime %d\n" _ crp->endtime);
   if (crp->endtime != -1)
       /* replay wants time in centiseconds */
       if ((n += sprintf (extra_args + n, " -playfor %d",
             (crp->endtime - crp->starttime)*100)) >= EXTRA_ARGS_LIMIT)
       {
          error = &Error_Too_Long;
          TRACE2 ("finish\n");
          goto finish;
       }

   TRACE2 ("crp->hidden %d\n" _ crp->hidden);
   if (crp->hidden)
   {
       if ((n += sprintf (extra_args + n, " -novideo")) >= EXTRA_ARGS_LIMIT)
       {
          error = &Error_Too_Long;
          TRACE2 ("finish\n");
          goto finish;
       }
   }

   /*Close the window when the movie finishes. (Deleted code |else {if ((n +=
      sprintf (extra_args + n, " -pauseatend")) >= EXTRA_ARGS_LIMIT) {error =
      &Error_Too_Long; goto finish;}}|.) JRC 5 Jun 1997*/

   TRACE2 ("crp->volume %d\n" _ crp->volume);
   if (crp->volume == 0) /* volume on or off is all replay supports :-( */
      if ((n += sprintf (extra_args + n, " -mute")) >= EXTRA_ARGS_LIMIT)
      {
         error = &Error_Too_Long;
         TRACE2 ("finish\n");
         goto finish;
      }

   TRACE2("Starting replay, cmd_line \"%s\", extra_args \"%s\"\n" _ cmd_line _ extra_args);
   set_system_variable("ARMovie$ExtraArgs", extra_args);
   if ((error = utils_start_task (cmd_line, REPLAY_SLOT, &crc->replay_task)) != NULL)
   {
      TRACE2 ("finish\n");
      goto finish;
   }

   TRACE2 ("crc->replay_task 0x%X\n" _ crc->replay_task);
   if (crc->replay_task == 0)
   {
      error = &Local_Error;

      strcpy (error->errmess, "Replay task exited unexpectedly");
      if ((msg = getenv ("ARMovie$ReturnCode")) != NULL && msg [0] != '\0')
      {
         strcat (error->errmess, ": ");
         len = strlen (error->errmess);
         sprintf (error->errmess + len, "%.*s", sizeof error->errmess - len - 1, msg);
      }

      TRACE2 ("finish\n");
      goto finish;
   }

   /*Replay has filled in |crc->rma->mywindow.open_handler| with an open
      handler function.*/
   crc->replay_running = TRUE;

   /* register handler so we know when replay closes */
   if ((error = event_register_message_handler (Wimp_MTaskCloseDown,
         &client_replay_closedown_handler, crp)) != NULL)
   {
      TRACE2 ("finish\n");
      goto finish;
   }

   /* register open window event */
   if ((error = event_register_wimp_handler (crp->wimp_window, Wimp_EOpenWindow,
         client_replay_open_win_handler, crc)) != NULL)
   {
      TRACE2 ("finish\n");
      goto finish;
   }

   pluginclient_send_busy (crp->plugin, 0, plugin_state_PLAY);

finish:
   if (error != NULL)
   {
      TRACE1 ("error finish \"%s\"\n" _ error->errmess);
      pluginclient_send_closed(crp->plugin, 0, error, 0);

      /* deregister handler */
      (void) event_deregister_message_handler (Wimp_MTaskCloseDown,
            &client_replay_closedown_handler, crp);

      if (crc != NULL)
      {
         /* deregister open window event */
         (void) event_deregister_wimp_handler (crp->wimp_window, Wimp_EOpenWindow,
               client_replay_open_win_handler, crc);

         if (crc->rma != NULL) rma_free (crc->rma);
         m_FREE (crc, sizeof *crc);
      }

      TRACE1 ("-replay_multi_start\n");
      return NULL;
   }
   else
   {
      TRACE1 ("-replay_multi_start\n");
      return crc;
   }
} /* replay_multi_start */

static BOOL param_bool(pluginclient_instance *plugin, const char *param_name,
                      BOOL def)
{
    pluginclient_param *param;
    param = pluginclient_param_lookup(plugin, param_name, -1, FALSE);

    /* no parameter return the default */
    if (param == NULL)
	return def;

    /* no value then assume means TRUE */
    if (param->value == NULL)
	return TRUE;

    /* use the first letter to distinguish TRUE and FALSE */
    if (toupper(param->value[0]) == 'T')
	return TRUE;

    return FALSE;
} /* param_bool */

static void process_tag_params(pluginclient_instance *plugin, client_replay_ptr crp)
{
  pluginclient_param *param;
  /* process tag parameters */

  crp->autostart = param_bool(plugin, "AUTOSTART", FALSE);
  crp->autostart = param_bool(plugin, "AUTOPLAY", crp->autostart);

  /* sort out LOOP */
  crp->loop = 0;
  param = pluginclient_param_lookup(plugin, "LOOP", -1, FALSE);

  if (param != NULL)
  {
    if (param->value == NULL || toupper(param->value[0] == 'T')) /* present and true */
      crp->loop = -1; /* loop forever */
    else if (param->value != NULL && !(toupper(param->value[0]) == 'F')) /* false */
    {
      if (toupper(param->value[0]) == 'I') /* infinite */
        crp->loop = -1; /* loop forever */
      else if (sscanf(param->value, "%d", &crp->loop) == EOF) /* number */
        crp->loop=-1; /* if conversion error, loop forever */
    } /* else if */

  } /* if */

  /* sort out STARTTIME */
  crp->starttime = 0; /* default */
  param = pluginclient_param_lookup(plugin, "STARTTIME", -1, FALSE);

  if (param != NULL && param->value != NULL)  /* present, and has value */
  {
    char *temp_str;
    int min, sec;

    temp_str=strtok(param->value, ":"); /* read up to ":" */

    if (temp_str != NULL && sscanf(temp_str, "%d", &min) != EOF) /* read minutes */
    {
      while (*(temp_str++)); /* move to rest of string */

      if (sscanf(temp_str, "%d", &sec) != EOF) /* read seconds */
      {
        crp->starttime = (min * 60) + sec;
      } /* if */
    } /* if */
  } /* if */

  /* sort out ENDTIME */
  crp->endtime = -1; /* default */
  param = pluginclient_param_lookup(plugin, "ENDTIME", -1, FALSE);

  if (param != NULL && param->value != NULL)  /* present, and has value */
  {
    char *temp_str;
    int min, sec;

    temp_str=strtok(param->value, ":"); /* read up to ":" */
    if (temp_str != NULL && sscanf(temp_str, "%d", &min) != EOF) /* read minutes */
    {
      while (*(temp_str++)); /* move to rest of string */
      if (sscanf(temp_str, "%d", &sec) != EOF) /* read seconds */
      {
        crp->endtime = (min * 60) + sec;
      } /* if */
    } /* if */
  } /* if */

  crp->hidden = param_bool(plugin, "HIDDEN", FALSE);

  /* sort out HREF */
  crp->href[0] = '\0';
  param = pluginclient_param_lookup(plugin, "HREF", -1, FALSE);

  if (param != NULL && param->value != NULL)  /* present, and has value */
    strncpy(crp->href, param->value, sizeof crp->href);

  /* sort out VOLUME */
  crp->volume=-1;  /* volume at max 100% */
  param = pluginclient_param_lookup(plugin, "VOLUME", -1, FALSE);

  if (param != NULL && param->value != NULL) /* present, and has value */
    sscanf(param->value, "%d", &crp->volume);

  TRACE2("process_tag_params(): AUTOSTART %d LOOP %d STARTTIME %d ENDTIME %d\n" _
         crp->autostart _ crp->loop _ crp->starttime _ crp->endtime);
  TRACE2("process_tag_params(): HIDDEN %d HREF \"%s\" VOLUME %d\n" _
         crp->hidden _ crp->href _ crp->volume);

} /* process_tag_params */


/* ----------------------------------------------------------------------
 * INSTANCE INITIALISATION FUNCTIONS
 * ----------------------------------------------------------------------
 */

static void client_replay_init(int argc, char *argv[])
{
  TRACE1 ("+client_replay_init\n");
  /* Poke client_replay_file_types address into client definition structure. */
  /* This avoids static init. data errors when building as a module.         */
  pluginclient_replay.file_type_list = client_replay_file_types;
  TRACE1 ("-client_replay_init\n");
}


static int client_replay_open(pluginclient_instance *plugin, client_ptr *client_data,
                              int *opening_flags)
{
    client_replay_ptr crp = m_CALLOC (sizeof *crp, 1);
    _kernel_swi_regs r;

    TRACE1 ("+client_replay_open\n");
    if (crp != NULL)
    {
	/* store the instance value */
	crp->plugin = plugin;

	/* get our task handle */
	toolbox_get_sys_info(Toolbox_GetSysInfo_TaskHandle, &r);
	crp->task_handle = r.r[0];

	/* check the parameters from the file */
	process_tag_params(plugin, crp);

	*opening_flags = client_open_FETCH_DATA | client_open_ALLOW_ACTION;
    }

    *client_data = crp;
    
    TRACE1 ("-client_replay_open\n");
    return crp != NULL;
} /* client_replay_open */

static void client_replay_close(client_ptr cp)
{
   client_replay_ptr crp = (client_replay_ptr) cp;
   WimpMessage message;

   TRACE1("+client_replay_close(): crp %p\n" _ crp);

   if (crp->replay != NULL)
   {
      if (crp->replay->rma->multi_flags.multi_status != NULL)
         *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_EXIT;
      else
      {
         /* Have to send a quit message to Replay as its not quite running
          * properly yet. Sigh :-( */
         message.hdr.size = sizeof(message.hdr);
         message.hdr.your_ref = 0;
         message.hdr.action_code = Wimp_MQuit;
         err_report(wimp_send_message(Wimp_EUserMessage, &message,
                                      crp->replay->replay_task, 0, NULL));
      } /* else */
      /*Don't send STOP message, as higher layer should know we're stopping*/

      err_report(event_deregister_wimp_handler(crp->wimp_window, Wimp_EOpenWindow,
                                               client_replay_open_win_handler,
                                               crp->replay));

      crp->replay->replay_running = FALSE;
      crp->replay->replay_task = 0;
      replay_multi_end(crp->replay);
      crp->replay = NULL;
   }

   /*Always remove the closedown handler, even if replay has stopped. It
      might not exist, so discard any error. JRC 6 Jun 1997*/
   (void) event_deregister_message_handler (Wimp_MTaskCloseDown,
         &client_replay_closedown_handler, crp);

   if (crp->file_name != NULL)
      m_FREE(crp->file_name, strlen (crp->file_name) + 1);

   m_FREE(crp, sizeof *crp);

   TRACE1("-client_replay_close()\n");
} /* client_replay_close */

static void client_replay_set_window(client_ptr cp, ObjectId window_handle,
                                     BBox *bbox, BOOL subwindow)
{
   client_replay_ptr crp = (client_replay_ptr) cp;
   BOOL window_changed = window_handle != crp->window_handle;

   TRACE1("+client_replay_set_window(): crp %p id %d subwindow %d\n" _ crp _
           window_handle _ subwindow);

   crp->bbox = *bbox;

   if (window_changed)
   {
      /*Deregister the handler for the window we used to have ...*/
      err_report (event_deregister_wimp_handler (crp->wimp_window,
            Wimp_EOpenWindow, &client_replay_open_win_handler, crp->replay));

      crp->window_handle = window_handle;
      err_report (window_get_wimp_handle (0u, crp->window_handle,
            &crp->wimp_window));

      /*... and reregister a new one. JRC Tue 3rd June 1997*/
      err_report (event_register_wimp_handler (crp->wimp_window,
            Wimp_EOpenWindow, &client_replay_open_win_handler, crp->replay));
   }

   if (!subwindow) crp->show_own_window=TRUE;

   TRACE1("-client_replay_set_window()\n");
}

/* ----------------------------------------------------------------------
 * MISC INSTANCE EVENT HANDLERS
 * ----------------------------------------------------------------------
 */

static void client_replay_click(client_ptr cp, const WimpMouseClickEvent *click)
{
    client_replay_ptr crp = (client_replay_ptr) cp;

    TRACE1("+client_replay_click(): crp %p\n" _ crp);

    wimp_set_caret_position(crp->wimp_window, -1, 0, 0, -1, -1);

    if (crp->href[0] != '\0' && click->buttons == Wimp_MouseButtonSelect)
    {
        pluginclient_browser_goto(crp->plugin, crp->href);
    } /* if */
    
    TRACE1("-client_replay_click()\n");
}

static int client_replay_action(client_ptr cp, int reason)
{
   client_replay_ptr crp = (client_replay_ptr) cp;

   TRACE1("+client_replay_action(): crp %p reason %d\n" _ crp _ reason);

   switch (reason)
   {
      case client_action_STOP:
         if (crp->replay != NULL && crp->replay->replay_running != NULL)
         {
            if (crp->show_own_window)
               /*Close the window now. JRC Tue 3rd June 1997*/
               err_report (toolbox_hide_object (0u, crp->window_handle));

            if (crp->replay->rma->multi_flags.multi_status != NULL)
               *crp->replay->rma->multi_flags.multi_status |=
                     REPLAY_MULTI_EXIT; /*was |REPLAY_MULTI_PAUSE|. JRC 5 Jun
                     1997*/

            /*Deregister no-longer-needed event handlers. JRC 6th Jun 1997*/
            err_report (event_deregister_wimp_handler (crp->wimp_window,
                  Wimp_EOpenWindow, client_replay_open_win_handler, crp->replay));
            err_report(event_deregister_message_handler(Wimp_MTaskCloseDown,
                  &client_replay_closedown_handler, crp));
            pluginclient_send_busy(crp->plugin, 0, plugin_state_STOP);
       
            crp->replay->replay_running = FALSE;
            crp->replay->replay_task = 0;
            replay_multi_end(crp->replay);
            crp->replay=NULL;
         } /* if */
      break;

      case client_action_PLAY:
         if (crp->replay != NULL && crp->replay->replay_running != NULL)
         {
            if (crp->replay->rma->multi_flags.multi_status != NULL)
               *crp->replay->rma->multi_flags.multi_status &=
                     ~REPLAY_MULTI_PAUSE;
         } /* if */
         else
         {
            /* start replay again */
            TRACE4("restarting replay\n");

            /* restart playback */
            if (crp->replay != NULL)
            {
               if (crp->replay->rma != NULL && crp->replay->rma->multi_flags.multi_status != NULL)
                  *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_EXIT;

               if (crp->show_own_window)
               {
                  /*Close the window now. JRC Tue 3rd June 1997*/
                  err_report (toolbox_hide_object (0u, crp->window_handle));

                  err_report (event_deregister_wimp_handler
                        (crp->wimp_window, Wimp_EOpenWindow,
                        client_replay_open_win_handler, crp->replay));
               }

               replay_multi_end(crp->replay);
            } /* if */

            crp->replay = replay_multi_start(crp);

            if (crp->replay == NULL)
            {
               TRACE1("-client_replay_action()\n");
               return 0;
            }
         } /* else */

         pluginclient_send_busy(crp->plugin, 0, plugin_state_PLAY);
      break;

      case client_action_PAUSE:
             if (crp->replay != NULL && crp->replay->replay_running != NULL)
             {
               if (crp->replay->rma->multi_flags.multi_status != NULL)
                  *crp->replay->rma->multi_flags.multi_status |=
                        REPLAY_MULTI_PAUSE;
               pluginclient_send_busy(crp->plugin, 0, plugin_state_PAUSE);
             } /* if */
      break;
  
      case client_action_MUTE:
             if (crp->replay != NULL && crp->replay->replay_running != NULL)
             {
               if (crp->replay->rma->multi_flags.multi_status != NULL)
                  *crp->replay->rma->multi_flags.multi_status |=
                        REPLAY_MULTI_MUTE;
             } /* if */
      break;
  
      case client_action_UNMUTE:
             if (crp->replay != NULL && crp->replay->replay_running != NULL)
             {
               if (crp->replay->rma->multi_flags.multi_status != NULL)
                  *crp->replay->rma->multi_flags.multi_status &=
                        ~REPLAY_MULTI_MUTE;
             } /* if */
      break;
   } /* switch */

   TRACE1("-client_replay_action()\n");
   return 1;
} /* client_replay_action */

static void client_replay_idle(client_ptr cp)
{
  client_replay_ptr crp = (client_replay_ptr) cp;
  
  TRACE1 ("+client_replay_idle\n");

  if (crp->replay != NULL && crp->replay->rma->multi_flags.multi_status != NULL)
  {
    if ((*crp->replay->rma->multi_flags.multi_status & REPLAY_MULTI_ENDOFPLAY) != 0u)
    {
      /* if replay has paused at end, we say that we aren't running so we don't
       * send STOP messages again */

      if (crp->replay->replay_running)
      {
        TRACE4("client_replay_idle() noticed end of play\n");
        crp->replay->replay_running = FALSE;
        pluginclient_send_busy(crp->plugin, 0, plugin_state_STOP);
      } /* if */
    } /* if */
  } /* if */
  
  TRACE1 ("-client_replay_idle\n");
} /* client_replay_idle */


/* ----------------------------------------------------------------------
 * INSTANCE EVENT HANDLERS FOR SCREEN EVENTS
 * ----------------------------------------------------------------------
 */

static void client_replay_gain_caret(client_ptr cp)
{
    client_replay_ptr crp = (client_replay_ptr) cp;
    BBox box;

    TRACE1("+client_replay_gain_caret(): crp %p\n" _ crp);

    box.xmin = box.ymin = -0x4000;
    box.xmax = box.ymax =  0x4000;

    crp->has_focus = TRUE;
    window_force_redraw(0, crp->window_handle, &box);

    TRACE1("-client_replay_gain_caret()\n");
}

static void client_replay_lose_caret(client_ptr cp)
{
    client_replay_ptr crp = (client_replay_ptr) cp;
    BBox box;

    TRACE1("+client_replay_lose_caret(): crp %p\n" _ crp);

    box.xmin = box.ymin = -0x4000;
    box.xmax = box.ymax =  0x4000;

    crp->has_focus = FALSE;
    window_force_redraw(0, crp->window_handle, &box);

    TRACE1("-client_replay_lose_caret()\n");
}

static _kernel_oserror *client_replay_redraw(client_ptr cp,
                                             WimpRedrawWindowBlock *r,
                                             int local)
{
    client_replay_ptr crp = (client_replay_ptr) cp;

    TRACE1("+client_replay_redraw(): crp %p focus %d area %d,%d %d,%d\n" _
	   crp _ crp->has_focus _
	   r->redraw_area.xmin _ r->redraw_area.ymin _
	   r->redraw_area.xmax _ r->redraw_area.ymax);

    if (crp->replay != NULL && crp->replay->rma->multi_flags.multi_status != NULL &&
          (*crp->replay->rma->multi_flags.multi_status & REPLAY_MULTI_PAUSE)
          != 0u)
    {
      /* ensure we repaint if paused */
      *crp->replay->rma->multi_flags.multi_status |= REPLAY_MULTI_PAINTIFPAUSED;
    } /* if */
    else
    {
       /* Just draw a black square - only happens if nothing is painting in
        * window, e.g. if HTML specifies window, but there's no video in the file */
	_swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4),
	      0x00000000, 0, 0); /* black */
	_swix(OS_Plot, _INR(0,2), 4, r->redraw_area.xmin, r->redraw_area.ymin);
	_swix(OS_Plot, _INR(0,2), 96 + 5, r->redraw_area.xmax, r->redraw_area.ymax);
    }

    TRACE1("-client_replay_redraw\n");

    return NULL;
    NOT_USED(local);
}

/* ----------------------------------------------------------------------
 * STREAM FUNCTIONS
 * ----------------------------------------------------------------------
 */

/*
 * The parent is opening a new stream to send to the client.
 *   Update the stream type.
 *   fill in stream->instance.plugin if we are likely to have more than one stream on the go
 *   at once.
 */

static void client_replay_stream_new(client_ptr cp, const char *mime_type,
                                     plugin_stream *stream, int seekable,
                                     int *stream_type)
{
    TRACE1("+client_replay_stream_new(): crp %p\n" _ cp);

    /* Just tell them we only want the whole file */
    *stream_type = plugin_stream_TYPE_ASFILEONLY;
    
    TRACE1("-client_replay_stream_new()\n");
}

/*
 * The stream requested has finished downloading and is now available
 */

static int client_replay_stream_as_file(client_ptr cp, plugin_stream *stream,
                                        const char *cache_file)
{
    client_replay_ptr crp = (client_replay_ptr) cp;

    TRACE1("+client_replay_stream_as_file(): crp %p\n" _ crp);

    crp->file_name = strdup(cache_file);
    if (crp->file_name == NULL)
    {
       TRACE1("-client_replay_stream_as_file()\n");
       return 0;
    }

    crp->file_type = get_file_type(cache_file);

    /* start playback */
    if (crp->autostart)
    {
      crp->replay = replay_multi_start(crp);

      if (crp->replay == NULL)
      {
         TRACE1("-client_replay_stream_as_file()\n");
         return 0;
      }
    } /* if */

    TRACE1("-client_replay_stream_as_file()\n");
    return 1;
}


/* ---------------------------------------------------------------------- */

/* play a straightforward file */
static client_ptr client_replay_play_file(const char *file_name, int filetype,
                                          ObjectId window_handle,
                                          pluginclient_instance *plugin)
{
   client_replay_ptr crp;
   _kernel_swi_regs regs;

   TRACE1("+client_replay_play_file(): file \"%s\", type &%X, plugin %d, "
         "window_handle 0x%X\n" _ file_name _ filetype _ plugin _ window_handle);

   /* create and clear crp */
   if ((crp = m_CALLOC (sizeof *crp, 1)) == NULL)
   {
      TRACE1("-client_replay_play_file()\n");
      return NULL;
   }
     
   if ((crp->file_name = strdup(file_name)) == NULL)
   {
      m_FREE(crp, sizeof *crp);
      TRACE1("-client_replay_play_file()\n");
      return NULL;
   } /* if */

   crp->file_type = filetype;
   crp->show_own_window=TRUE;
   crp->window_handle = window_handle;
   err_fatal(window_get_wimp_handle(0, crp->window_handle, &crp->wimp_window));
   err_fatal(toolbox_get_sys_info(Toolbox_GetSysInfo_TaskHandle, &regs));
   crp->task_handle = regs.r[0];
   crp->autostart=TRUE;
   crp->loop = FALSE;
   crp->starttime = 0;
   crp->endtime = -1;
   crp->hidden = FALSE;
   crp->href[0] = '\0';
   crp->volume = -1;
   crp->plugin = plugin;
   
   if ((crp->replay = replay_multi_start(crp)) == NULL)
   {
      m_FREE (crp->file_name, strlen (crp->file_name) + 1);
      m_FREE (crp, sizeof *crp);
      TRACE1("-client_replay_play_file()\n");
      return NULL;
   } /* if */

   TRACE1("-client_replay_play_file()\n");
   return (client_ptr) crp;

   NOT_USED(filetype);
} /* client_replay_play_file */

/* ---------------------------------------------------------------------- */

/* externally available definition describing functions available */

pluginclient pluginclient_replay =
{
  &client_replay_init,
  NULL, //  &client_replay_shutdown,
  &client_replay_open,
  &client_replay_close,
  &client_replay_set_window,
  NULL, //  &client_replay_key,
  &client_replay_click,
  NULL, //  &client_replay_help,
  &client_replay_action,
  &client_replay_idle,
  &client_replay_gain_caret,
  &client_replay_lose_caret,
  NULL, //  &client_replay_redraw_setup,
  &client_replay_redraw,
  &client_replay_play_file,
  &client_replay_stream_new,
  &client_replay_stream_as_file,
  NULL, //  &client_replay_stream_destroy,
  NULL  // Patched by client_replay_init.
};

/* eof client_rep.c */
