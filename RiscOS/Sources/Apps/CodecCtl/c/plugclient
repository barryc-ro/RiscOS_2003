/* > plugclient.c

 * Main file for a plugin client

 */

#include <ctype.h>
#include <locale.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <swis.h>
#include <time.h>

#include "toolbox.h"
#include "window.h"
#include "quit.h"
#include "event.h"
#include "wimplib.h"

#include "m.h"
#include "plugin.h"
#include "plugclient.h"
#include "version.h"
#include "client.h"
#include "utils.h"

/* --------------------------------------------------------------------------------------------- */

#define APP_DIR		            "<" APP_NAME "$Dir>"
#define MESSAGE_BROWSER_OPENURL     0x4AF80
#define POLL_TIME	            100	/* 1 second */
#define MIN_ESC_TIME	            50	/* cs */

#define MUTE_URL1                   "soundplaystop:"
#define MUTE_URL2                   "ncfrescointernal:loadurl?url=soundplaystop%3A"

/* --------------------------------------------------------------------------------------------- */

typedef union
{
  char url[236];
  struct
  {
    int tag;
    plugin_string_value url;
    int flags;
    plugin_string_value body_file;
    plugin_string_value target;
  } indirect;
} openurl_data;

static MessagesFD message_block;    /* declare a message block for use with toolbox initialise */
static IdBlock event_id_block;      /* declare an event block for use with toolbox initialise  */

static int ToolBox_EventList[] =
{
  Quit_Quit,
  0
};

static int Wimp_MessageList[] =

{
    Wimp_MPreQuit,
    Wimp_MDataOpen,
    Wimp_MTaskCloseDown,
    Wimp_MHelpRequest,
    MESSAGE_BROWSER_OPENURL,
    MESSAGE_PLUGIN_OPEN,
    MESSAGE_PLUGIN_CLOSE,
    MESSAGE_PLUGIN_RESHAPE,
    MESSAGE_PLUGIN_FOCUS,
    MESSAGE_PLUGIN_STREAM_NEW,
    MESSAGE_PLUGIN_STREAM_AS_FILE,
    MESSAGE_PLUGIN_STREAM_DESTROY,
    MESSAGE_PLUGIN_ACTION,
    MESSAGE_PLUGIN_ABORT,
    Wimp_MQuit
};

static int event_mask =
      Wimp_Poll_PointerLeavingWindowMask
    | Wimp_Poll_PointerEnteringWindowMask
    | Wimp_Poll_PollWordNonZeroMask;

/* --------------------------------------------------------------------------------------------- */

static int last_checkpoint = 0;
static int n_instances = 0;

/* cli set values */

static int cli_buffersize = 0;
static char cli_filename[1024];
static int cli_stop = 0;
static int cli_plugin = 0;
static int cli_timeout = -1; /* infinite */

/* key handling for moving focus */

static int last_key_code = -1;
static int last_key_time = 0;

/* --------------------------------------------------------------------------------------------- */

#if 0
/*
 * Signal handling.
 * Output postmortem on error.
 */

#define FATAL_ERROR utils_msgs_lookup("Ewimpt1:%s has suffered a fatal internal error (type=%i) and must exit immediately")

static _kernel_oserror	sig_errmsg;
static char		*sig_numspot;
static int		sig_dopostmortem = TRUE;

static void escape_handler(int sig)
{
    (void) signal(SIGINT, &escape_handler);
    sig = sig; /* avoid compiler warning */
}

static void handler(int signal)
{
    *sig_numspot = signal + '0';

    wimp_report_error(&sig_errmsg, 0, utils_msgs_lookup("_TaskName"));

    if (sig_dopostmortem) switch (signal)
    {
        case SIGFPE:
        case SIGILL:
        case SIGSEGV:
            return;
    }

    exit(EXIT_FAILURE);
}

static void signal_setup(void)
{
    sig_errmsg.errnum = 0;
    sprintf(sig_errmsg.errmess, FATAL_ERROR, utils_msgs_lookup("_TaskName"), 9);
    sig_numspot = strchr(sig_errmsg.errmess, '9');

    signal(SIGABRT, &handler);
    signal(SIGFPE, &handler);
    signal(SIGILL, &handler);
    signal(SIGINT, &escape_handler);
    signal(SIGSEGV, &handler);
    signal(SIGTERM, &handler);
}
#endif

/* --------------------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------------------- */

struct pluginclient_instance
{
    pluginclient_instance	*prev, *next;

    void		*parent_instance;
    int			parent_window;
    BBox		parent_box;
    int			parent_task;

    pluginclient_param	*param_list;

    ObjectId		window;
    int			msgref;		/* ref of last message sent */

    int			wimp_window;	/* wimp version of 'window' handle */

    pluginclient        *plugin_fns;    /* functions depending on whether
                                         * codec/replay/midi etc. */

    client_ptr          client_data;    /* client's private data */

    BOOL                helper;         /* Is this a helper or plugin */

    BOOL           closed_message_sent; /* Whether we've sent a closed message
                                         * to browser - so we only send the
                                         * first one, which will be the one with
                                         * the first error
                                         */
};

/* --------------------------------------------------------------------------------------------- */

static pluginclient_instance	*plugin_list = NULL;

/* For new clients increase the size of all_pluginclients
 * and add to function below to get initialised
 */

static pluginclient *all_pluginclients[3];

static void patch_all_pluginclients( void )
{
  all_pluginclients[0] = &pluginclient_replay;
  all_pluginclients[1] = &pluginclient_midi;
  all_pluginclients[2] = NULL;
}

/* --------------------------------------------------------------------------------------------- */

static pluginclient_instance *find_plugin (int wimp_window)
{
    pluginclient_instance *plugin;

    for (plugin = plugin_list; plugin != NULL; plugin = plugin->next)
	if (wimp_window == plugin->wimp_window)
	    return plugin;

    return NULL;
}

/* find the pluginclient that handles this file type, or NULL if not found */
static pluginclient *handle_file_type(int file_type)
{
    int *ft;
    pluginclient **curr_pluginclient;

    for (curr_pluginclient=all_pluginclients; *curr_pluginclient;
         curr_pluginclient++)
    {
      if (!(*curr_pluginclient)->file_type_list) continue;

      for (ft = (*curr_pluginclient)->file_type_list; *ft != -1; ft++)
	if (*ft == file_type)
	    return *curr_pluginclient;
    } /* for */

    return NULL;
}

/* --------------------------------------------------------------------------------------------- */

/*
 * Read a string from the parameter file
 */

static char *read_string(FILE *f)
{
    int string_size;
    char *string;

    fread(&string_size, 4, 1, f);

    if (string_size == 0)
	return NULL;

    if ((string = m_MALLOC(string_size+1)) != NULL)
    {
	fread(string, string_size, 1, f);
	string[string_size] = 0;
    }

    /* word-align pointer */
    fseek(f, (long) (4 - (string_size & 3)) & 3, SEEK_CUR);

    return string;
}

/*
 * Read and parse the whole parameter file
 */

static void parse_parameter_file(pluginclient_instance *plugin, const char *file_name)
{
    FILE *f;

    TRACE1 ("parse_parameter_file(): instance %p '%s'\n" _ plugin _ file_name);

    if ((f = fopen(file_name, "rb")) != NULL)
    {
	plugin_parameter_type type;
	int size, pos = 0;

	do
	{
	    type = plugin_parameter_TERMINATOR;
	    fread(&type, 4, 1, f);

	    TRACE4 ("param: type %d \n" _ type);

	    if (type != plugin_parameter_TERMINATOR)
	    {
		pluginclient_param *param;

		/* read size of strings */
		fread(&size, 4, 1, f);

		TRACE4 ("param: string size %d \n" _ size);

		/* read in the strings */
		if ((param = m_CALLOC(sizeof *param, 1)) != NULL)
		{
		    /* store type */
		    param->type = type;

		    /* read strings */
		    param->name = read_string(f);
		    param->value = read_string(f);
		    param->value_type = read_string(f);

		    TRACE3 ("param: '%s' '%s' '%s' \n" _ strsafe(param->name) _ strsafe(param->value) _ strsafe(param->value_type));

		    /* attach to list */
		    param->next = plugin->param_list;
		    plugin->param_list = param;
		}

		/* advance to next record */
		pos += 2*4 + ALIGN (size);
		fseek(f, pos, SEEK_SET);

		TRACE4 ("param: skip to %d \n" _ pos);
	    }
	}
	while (type != plugin_parameter_TERMINATOR);

	fclose(f);
    }
}

/*
 * Dispose of the memory used by a parameter list
 */

static void free_params(pluginclient_param *param)
{
    TRACE2 ("free_params(): %p\n" _ param);

    while (param)
    {
	pluginclient_param *next = param->next;

	m_FREE(param->name, strlen (param->name) + 1);
	m_FREE(param->value, strlen (param->value) + 1);
	m_FREE(param->value_type, sizeof *param->value_type);
	m_FREE(param, sizeof *param);

	param = next;
    }
}

pluginclient_param *pluginclient_param_lookup(pluginclient_instance *plugin, const char *name,
                                              int mask, int case_sensitive)
{
    pluginclient_param *param;

    TRACE3 ("pluginclient_param_lookup(): instance %p name %s mask %x case %d\n" _ plugin _ name _ mask _ case_sensitive);

    for (param = plugin->param_list; param; param = param->next)
    {
	if (((1 << param->type) & mask))
	{
	    if (case_sensitive)
	    {
		if (strcmp(name, param->name) == 0)
		    break;
	    }
	    else
	    {
		if (strcasecomp(name, param->name) == 0)
		    break;
	    }
	}
    }

    TRACE3 ("pluginclient_param_lookup(): returns '%s'\n" _ param ? strsafe(param->value) : "");

    return param;
}

void pluginclient_decrement_count(void)
{
    n_instances--;
    last_checkpoint = clock()/CLK_TCK;
}

void pluginclient_increment_count(void)
{
    n_instances++;
    last_checkpoint = 0;
}

/* --------------------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------------------- */

typedef struct pluginclient_string_rma_ptr pluginclient_string_rma_ptr;

struct pluginclient_string_rma_ptr
{
    pluginclient_string_rma_ptr *prev, *next;
    pluginclient_instance *pp;
    int msgref;
};

static pluginclient_string_rma_ptr *rma_ptr_list = NULL;

/* ----------------------------------------------------------------------------- */


/*
 * get a ptr to real data from a plugin message.
 * The data may be in the message body or in the RMA.
 */

static char *get_ptr(void *msgdata, plugin_string_value sv)
{
    return sv.offset == 0 ? 0 : sv.offset <= 236 ? (char *)msgdata + sv.offset : sv.ptr;
}

/* --------------------------------------------------------------------------------------------- */

/*
 * Copy the string 's' into a block allocated from the RMA and link it into the
 * list of blocks so allocated.
 */

static void *rma_dup(const char *s)
{
    pluginclient_string_rma_ptr *ptr;
    int len = strlen(s) + 1;

    if ((ptr = rma_malloc(len + sizeof (pluginclient_string_rma_ptr))) == NULL)
	return NULL;

    ptr->prev = NULL;
    ptr->next = rma_ptr_list;
    ptr->msgref = -1;

    if (rma_ptr_list)
	rma_ptr_list->prev = ptr;

    rma_ptr_list = ptr;

    memcpy(ptr+1, s, len);

    return ptr+1;
}

static void free_rma_strings(int msgref, pluginclient_instance *pp)
{
    pluginclient_string_rma_ptr *psrp, *next;

    for (psrp = rma_ptr_list; psrp; psrp = next)
    {
        next = psrp->next; /* prevent use when freed */

	/* if either the msgref or pointer match then
	 * remove from the list and free
	 */
	if (psrp->msgref == msgref || psrp->pp == pp)
	{
	    if (psrp->prev)
		psrp->prev->next = psrp->next;
	    if (psrp->next)
		psrp->next->prev = psrp->prev;

	    rma_free(psrp);
	}
    }
}

static void write_string(WimpMessage *mp, plugin_string_value *so, const char *data)
{
    int space_left = sizeof(*mp) - mp->hdr.size;
    int data_len = strlen(data) + 1;

    if (data_len <= space_left)
    {
 	so->offset = mp->hdr.size - sizeof(mp->hdr); /* offset is relative to data start */
	strcpy(mp->data.bytes + so->offset, data);
	mp->hdr.size += data_len;
    }
    else
    {
	/* copy to rma */
	so->ptr = rma_dup(data);
    }
}

static void send_message(WimpMessage *msg, pluginclient_instance *pp)
{
    message_plugin_base *base = (message_plugin_base *)&msg->data;
    pluginclient_string_rma_ptr *psrp;

    if (!pp || !pp->parent_instance) return;

    TRACE4("Sending message to browser\n");
    base->instance.plugin = pp;
    base->instance.parent = pp->parent_instance;

    msg->hdr.size = ALIGN (msg->hdr.size);

    err_fatal(wimp_send_message(Wimp_EUserMessage, msg, pp->parent_task, -1, NULL));
    pp->msgref = msg->hdr.my_ref;

    /* rma allocated pointers are linked into list, we need to write in the msg reference */
    for (psrp = rma_ptr_list; psrp && psrp->msgref == -1; psrp = psrp->next)
    {
	psrp->msgref = msg->hdr.my_ref;
	psrp->pp = pp;
    }
}

/* --------------------------------------------------------------------------------------------- */

/*
 * Send a message closed to the parent.
 */

void pluginclient_send_closed(pluginclient_instance *plugin, int your_ref,
                              _kernel_oserror *e, int close_now)
{
    WimpMessage message;
    message_plugin_closed *msg = (message_plugin_closed *)message.data.bytes;

    TRACE1("+pluginclient_send_closed() closed message sent before = %d\n" _
           plugin->closed_message_sent);

    if (plugin->closed_message_sent) /* don't send >1 closed to browser */
      return;

    message.hdr.your_ref = your_ref;
    message.hdr.action_code = MESSAGE_PLUGIN_CLOSED;
    message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_closed);

    msg->flags = your_ref ? 0 : plugin_closed_NOT_REPLY;
    msg->flags |= close_now ? plugin_closed_EXITING : 0;

    if (e)
    {
	msg->errnum = e->errnum;
	strncpy(msg->errmess, e->errmess, sizeof(msg->errmess));
	msg->errmess[sizeof(msg->errmess)-1] = 0;

	msg->flags |= plugin_closed_ERROR_MSG;
    }

    send_message(&message, plugin);

    plugin->closed_message_sent=TRUE;

    TRACE1("-pluginclient_send_closed\n");
}

/*
 * Send a STATUS message
 */

void pluginclient_send_status(pluginclient_instance *plugin, const char *status)
{
    WimpMessage message;
    message_plugin_status *msg = (message_plugin_status *)message.data.bytes;

    message.hdr.your_ref = 0;
    message.hdr.action_code = MESSAGE_PLUGIN_STATUS;
    message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_status);

    write_string(&message, &msg->message, status);

    send_message(&message, plugin);
}

/*
 * Send a FOCUS message
 */

static void pluginclient_send_focus(pluginclient_instance *plugin)
{
    WimpMessage message;

    message.hdr.your_ref = 0;
    message.hdr.action_code = MESSAGE_PLUGIN_FOCUS;
    message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_focus);

    send_message(&message, plugin);
}

/* --------------------------------------------------------------------------------------------- */

/* Window handlers */

static int redraw_handler(int event_code, WimpPollBlock *event, IdBlock *id_block,
                          void *handle)
{
    pluginclient_instance *plugin = handle;
    WimpRedrawWindowRequestEvent *e = &event->redraw_window_request;

    TRACE4("redraw_handler(): instance %p\n" _ plugin);

    err_fatal(pluginclient_redraw(e->window_handle,
                                  plugin->plugin_fns->client_redraw_setup,
                                  plugin->plugin_fns->client_redraw,
                                  plugin->client_data));

    return 1;
    NOT_USED(id_block);
    NOT_USED(event_code);
}

static int click_handler(int event_code, WimpPollBlock *event, IdBlock *id_block,
                         void *handle)
{
    pluginclient_instance *plugin = handle;
    WimpMouseClickEvent *e = &event->mouse_click;

    TRACE4("click_handler(): instance %p\n" _ plugin);

    if (plugin->plugin_fns->client_click)
      plugin->plugin_fns->client_click(plugin->client_data, e);

    return 1;
    NOT_USED(id_block);
    NOT_USED(event_code);
}

static int key_handler(int event_code, WimpPollBlock *event, IdBlock *id_block,
                       void *handle)
{
    pluginclient_instance *plugin = handle;
    WimpKeyPressedEvent *e = &event->key_pressed;
    int claimed = FALSE;

    if (e->key_code == 27)
    {
	time_t t = clock();

	if (last_key_code == 27 && (t - last_key_time) <= MIN_ESC_TIME)
	{
	    /* pass focus back to browser */
	    pluginclient_send_focus(plugin);

	    claimed = TRUE;
	}

	last_key_time = t;
    }

    last_key_code = e->key_code;

    if (!claimed && plugin->plugin_fns->client_key)
	plugin->plugin_fns->client_key(plugin->client_data, e);

    return 1;
    NOT_USED(id_block);
    NOT_USED(event_code);
}

static int gain_caret_handler(int event_code, WimpPollBlock *event,
                              IdBlock *id_block, void *handle)
{
   pluginclient_instance *plugin = handle;

   if (plugin->plugin_fns->client_gain_caret != NULL)
      plugin->plugin_fns->client_gain_caret (plugin->client_data);

    return 1;
    NOT_USED(id_block);
    NOT_USED(event_code);
    NOT_USED(event);
}

static int lose_caret_handler(int event_code, WimpPollBlock *event,
                              IdBlock *id_block, void *handle)
{
   pluginclient_instance *plugin = handle;

   if (plugin->plugin_fns->client_lose_caret != NULL)
      plugin->plugin_fns->client_lose_caret (plugin->client_data);

    return 1;
    NOT_USED(id_block);
    NOT_USED(event_code);
    NOT_USED(event);
}

static void remove_window_handlers(ObjectId id, void *handle)
{
    /* wimp event handlers */
    err_fatal(event_deregister_wimp_handler(id, Wimp_ERedrawWindow, redraw_handler, handle));
    err_fatal(event_deregister_wimp_handler(id, Wimp_EMouseClick, click_handler, handle));
    err_fatal(event_deregister_wimp_handler(id, Wimp_EKeyPressed, key_handler, handle));
    err_fatal(event_deregister_wimp_handler(id, Wimp_EGainCaret, gain_caret_handler, handle));
    err_fatal(event_deregister_wimp_handler(id, Wimp_ELoseCaret, lose_caret_handler, handle));
}

static void close_child_window(pluginclient_instance *plugin)
{
   TRACE1("+close_child_window() : plugin %p\n" _ plugin);
    
   if (plugin->window != NULL_ObjectId) /*HACK JRC 18 Jun 1997*/
   {
      remove_window_handlers(plugin->window, plugin);

      /* remove window */
      err_report(toolbox_delete_object(0, plugin->window));
      plugin->window = 0;
   }
   TRACE1("-close_child_window\n");
}

/*
 * dispose of the child window in the parent
 */

/* --------------------------------------------------------------------------------------------- */

static void dispose_plugin_info(pluginclient_instance *plugin)
{
    TRACE1("+dispose_plugin_info(): instance %p\n" _ plugin);

    /* free memory and zero pointers */
    free_params(plugin->param_list);
    plugin->param_list = NULL;

    free_rma_strings(NULL, plugin);

    /* unlink */
    if (plugin->prev)
	plugin->prev->next = plugin->next;
    else
	plugin_list = plugin->next;

    if (plugin->next)
	plugin->next->prev = plugin->prev;

    /* decrement uses and start exit timer */
    pluginclient_decrement_count();

    /* free */
    m_FREE (plugin, sizeof *plugin);

    TRACE1("-dispose_plugin_info\n");
}

/* send a busy message to browser. If no reason, set reason to -1 */
void pluginclient_send_busy(pluginclient_instance *plugin, int busy, int reason)
{
    WimpMessage message;
    message_plugin_busy *busy_mess;

    message.hdr.your_ref = 0;
    message.hdr.action_code = MESSAGE_PLUGIN_BUSY;
    message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_busy);

    busy_mess = (message_plugin_busy *) &message.data;
    busy_mess->flags = (busy ? plugin_busy_BUSY : 0) |
                       (reason != -1 ? plugin_busy_STATE_VALID : 0);
    busy_mess->state = reason; /* doesn't matter whether -1 or not, as flag means
                                 * it won't be looked at if it is */
    send_message(&message, plugin);

    /* if we've stopped, and we're a -file client, then quit the client */
    if (reason == plugin_state_STOP && plugin->parent_instance == NULL)
    {
      TRACE4("pluginclient_send_busy() noticed STOP with no parent\n");

      /* call client specific code */
      if (plugin->plugin_fns->client_close != NULL)
         plugin->plugin_fns->client_close(plugin->client_data);

      /* dispose of window and plugin info */
      close_child_window(plugin);

      /* dispose of stuff */
      dispose_plugin_info(plugin);
    } /* if */
} /* pluginclient_send_busy */


/* tell the browser to go to the specified url */
void pluginclient_browser_goto(pluginclient_instance *plugin, const char *url)
{
  WimpMessage message;
  openurl_data *data = (openurl_data *) &message.data;
  pluginclient_string_rma_ptr *psrp;

  if (!plugin->parent_task) return;

  message.hdr.size = sizeof(message.hdr);
  message.hdr.your_ref = 0;
  message.hdr.action_code = MESSAGE_BROWSER_OPENURL;

  if (strlen(url) < sizeof(data->url))
  {
    strcpy(data->url, url);
    message.hdr.size += strlen(url) + 1;
  } /* if */
  else
  {
    data->indirect.tag = 0;
    data->indirect.flags = 0;
    data->indirect.body_file.ptr = NULL;
    data->indirect.target.ptr = NULL;
    message.hdr.size += sizeof(data->indirect);
    write_string(&message, &data->indirect.url, url);
  } /* else */

  message.hdr.size = ALIGN (message.hdr.size);

  err_fatal(wimp_send_message(Wimp_EUserMessage, &message, plugin->parent_task,
                              0, NULL));
  plugin->msgref = message.hdr.my_ref;

  /* rma allocated pointers are linked into list, we need to write in the msg reference */
  for (psrp = rma_ptr_list; psrp && psrp->msgref == -1; psrp = psrp->next)
  {
    psrp->msgref = message.hdr.my_ref;
    psrp->pp = plugin;
  } /* for */
} /* pluginclient_browser_goto */

/* --------------------------------------------------------------------------------------------- */

void pluginclient_window_position(pluginclient_instance *plugin, BBox *box, int *xscroll, int *yscroll)
{
    WimpGetWindowStateBlock state;

    state.window_handle = (int)plugin->wimp_window;
    err_fatal(wimp_get_window_state(&state));

    if (box)
	*box = state.visible_area;
    if (xscroll)
	*xscroll = state.xscroll;
    if (yscroll)
	*yscroll = state.yscroll;
}

/* --------------------------------------------------------------------------------------------- */

/*
 * These two routines will handle redraws on a window
 */

_kernel_oserror *pluginclient_redraw(int window_handle,
                                     pluginclient_redraw_handler setup,
                                     pluginclient_redraw_handler draw,
                                     void *cp)
{
    int more;
    _kernel_oserror *e;
    WimpRedrawWindowBlock r;

    r.window_handle = window_handle;
    e = wimp_redraw_window(&r, &more);

    if (!e && more && setup)
    	e = setup((client_ptr *)cp, &r, FALSE);

    while (!e && more)
    {
    	if (draw) e = draw((client_ptr *)cp, &r, FALSE);
	if (!e) e = wimp_get_rectangle(&r, &more);
    }

    return e;
}

_kernel_oserror *pluginclient_update(WimpUpdateWindowBlock *update,
                                     pluginclient_redraw_handler setup,
                                     pluginclient_redraw_handler draw,
                                     void *cp)
{
    int more;
    _kernel_oserror *e;
    WimpRedrawWindowBlock r;

    r.window_handle = update->window_handle;
    r.visible_area = update->update_area;

    e = wimp_update_window(&r, &more);

    if (!e && more && setup)
    	e = setup((client_ptr *)cp, &r, TRUE);

    while (!e && more)
    {
    	if (draw) e = draw((client_ptr *)cp, &r, TRUE);
	if (!e) e = wimp_get_rectangle(&r, &more);
    }

    return e;
}

/* --------------------------------------------------------------------------------------------- */

static void add_window_handlers(ObjectId id, void *handle)
{
    /* wimp event handlers */
    err_fatal(event_register_wimp_handler(id, Wimp_ERedrawWindow, redraw_handler, handle));
    err_fatal(event_register_wimp_handler(id, Wimp_EMouseClick, click_handler, handle));
    err_fatal(event_register_wimp_handler(id, Wimp_EKeyPressed, key_handler, handle));
    err_fatal(event_register_wimp_handler(id, Wimp_EGainCaret, gain_caret_handler, handle));
    err_fatal(event_register_wimp_handler(id, Wimp_ELoseCaret, lose_caret_handler, handle));
}

/* --------------------------------------------------------------------------------------------- */

/*
 * open the child window in the parent. Returns TRUE iffz a window was opened.
 */

static int open_child_window(pluginclient_instance *plugin, BOOL subwindow)
{
    WindowShowObjectBlock full_spec;
    WimpGetWindowStateBlock state;
    BOOL ret_code = FALSE;

    TRACE4("open_child_window(): plugin %p subwindow %d\n" _ plugin _ subwindow);
    /* create the window if not already there */
    if (plugin->window == NULL_ObjectId)
    {
	err_fatal(toolbox_create_object(0, OUR_OBJECT, &plugin->window));
    }

    if (subwindow)
    {
      /* get the state of the parent */
      state.window_handle = (int)plugin->parent_window;
      err_fatal(wimp_get_window_state(&state));

      /* construct the open details for the plugin */
      full_spec.visible_area.xmin = plugin->parent_box.xmin +
                                    state.visible_area.xmin - state.xscroll;
      full_spec.visible_area.ymin = plugin->parent_box.ymin +
                                    state.visible_area.ymax - state.yscroll;
      full_spec.visible_area.xmax = plugin->parent_box.xmax +
                                    state.visible_area.xmin - state.xscroll;
      full_spec.visible_area.ymax = plugin->parent_box.ymax +
                                    state.visible_area.ymax - state.yscroll;

      /* only show if height and width are both greater than 1 pixel */
      if (((full_spec.visible_area.xmax - full_spec.visible_area.xmin) > 1) &&
    	  ((full_spec.visible_area.ymax - full_spec.visible_area.ymin) > 1))
      {
    	  full_spec.xscroll = 0;
	  full_spec.yscroll = 0;
	  full_spec.behind = -1;
	  full_spec.window_flags = 0;
	  full_spec.parent_window_handle = (int)plugin->parent_window;
	  full_spec.alignment_flags = 0;

	  /* show it */
	  err_fatal(toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
	                                plugin->window, Toolbox_ShowObject_FullSpec,
	                                &full_spec, 0, -1));
	  ret_code=TRUE;
      } /* if */
    } /* if */

    /* if a subwindow, tell the client where it is. If not a subwindow, client
     * takes note and will open window itself later if necessary */
    if (plugin->plugin_fns->client_set_window)
      plugin->plugin_fns->client_set_window(plugin->client_data, plugin->window,
                                            &full_spec.visible_area, subwindow);
    return ret_code;
}

/* Check if the application that's quit was responsible for any of the
   plugins that we've started. In practice, this means that if the task
   that's quit is the browser, we close all the plugins. But not
   necessarily! JRC 6 Jun 1997*/

static int closedown_handler(WimpMessage *message, void *handle)
{
   pluginclient_instance *plugin, *next;

   TRACE1 ("+closedown_handler\n");

   for (plugin = plugin_list; plugin != NULL; plugin = next)
   {
      next = plugin->next; /* prevent use when freed */

      /*Check whether the task that has closed down is the task that started
         this plugin instance.*/
      if (message->hdr.sender == plugin->parent_task)
      {
         /* call client specific code */
         if (plugin->plugin_fns->client_close != NULL)
            plugin->plugin_fns->client_close (plugin->client_data);

         /* dispose of window and plugin info */
         close_child_window (plugin);

         /* dispose of stuff */
         dispose_plugin_info (plugin);
      }
   }

   TRACE1 ("-closedown_handler\n");
   return 0; /* allow other tasks to get message */
} /* closedown_handler */

static void dispose_plugin_all(void)
{
    TRACE1("+dispose_plugin_all\n");
    while (plugin_list)
    {
	/* notify host */
	pluginclient_send_closed(plugin_list, 0, NULL, 0);

	/* dispose of window and plugin info */
	close_child_window(plugin_list);

	/* call client specific code */
	if (plugin_list->plugin_fns->client_close)
	  plugin_list->plugin_fns->client_close(plugin_list->client_data);

	/* dispose of stuff */
	dispose_plugin_info(plugin_list);
    }
    TRACE1("-dispose_plugin_all\n");
}

static void kill_old_helper(pluginclient_instance *except)
{
  pluginclient_instance *instance, *next;

  for (instance = plugin_list; instance != NULL; instance = next)
  {
    next = instance->next; /* prevent use when freed */

    if (instance->helper != NULL && instance != except)
    {
      TRACE4("Killing helper %p\n" _ instance);

      pluginclient_send_closed(instance, 0, NULL, 0);

      /* dispose of window and plugin info */
      close_child_window(instance);

      /* call client specific code */
      if (instance->plugin_fns->client_close != NULL)
        instance->plugin_fns->client_close(instance->client_data);

      /* dispose of stuff */
      dispose_plugin_info (instance);
    } /* if */
  } /* for */
} /* kill_old_helper */

/* --------------------------------------------------------------------------------------------- */

/* Broadcast when object is opened initially */

static int plugin_open_handler(WimpMessage *message, void *handle)
{
    message_plugin_open *msg = (message_plugin_open *)message->data.bytes;
    pluginclient_instance *plugin;
    pluginclient *pluginclient_fns;
    int opening_flags;

    TRACE1("+plugin_open_handler\n");

    /* check type is handled by a pluginclient, and which one it is */
    if ( (pluginclient_fns = handle_file_type(msg->file_type)) == NULL)
    {
        TRACE1("-plugin_open_handler\n");
	return 0;
    }

    /* allocate block */
    if ((plugin = m_CALLOC(sizeof (struct pluginclient_instance), 1)) == NULL)
    {
        TRACE1("-plugin_open_handler\n");
	return 0;
    }

    plugin->plugin_fns = pluginclient_fns;

    pluginclient_increment_count();

    /* add to list */
    plugin->next = plugin_list;
    if (plugin_list != NULL)
	plugin_list->prev = plugin;
    plugin_list = plugin;

    /* save info from the open message */
    plugin->helper          = (msg->flags & plugin_open_HELPER) != 0u;
    plugin->parent_instance = msg->instance.parent;
    plugin->parent_window   = (int) msg->window_handle;
    plugin->parent_box      = *(BBox *) &msg->box;
    plugin->parent_task     = message->hdr.sender;

    /* if we have a non-hidden box then force it to be a helper */
    if (msg->box.x1 - msg->box.x0 > 1 && msg->box.y1 - msg->box.y0 > 1)
        plugin->helper = TRUE;

    if (plugin->helper)
      kill_old_helper(plugin);  /* kills all helpers _except_ plugin */

    /* load up the file details */
    parse_parameter_file(plugin, get_ptr(msg, msg->file_name));

    TRACE4("Calling client_open()\n");

    /* call the client */
    if (plugin->plugin_fns->client_open != NULL &&
          plugin->plugin_fns->client_open (plugin, &plugin->client_data, &opening_flags))
    {
	/* open the window - must be after client_open() */
	if (open_child_window(plugin, FALSE))
	{
	  kill_old_helper(plugin); /* kills all helpers _except_ plugin */
          plugin->helper = TRUE;   /* SJM: mark it now as being a helper */
	} /* if */

	err_fatal(window_get_wimp_handle(0, plugin->window, &plugin->wimp_window));

	add_window_handlers(plugin->window, plugin);

	/* send acknowledgement - reuse message block */
	msg->instance.plugin = plugin;
	msg->flags = opening_flags |
	             (plugin->helper ? plugin_opening_HELPER : 0);

	message->hdr.action_code = MESSAGE_PLUGIN_OPENING;
	message->hdr.your_ref = message->hdr.my_ref;
	message->hdr.size = sizeof(message->hdr) + sizeof(message_plugin_opening);
	wimp_send_message(Wimp_EUserMessage, message, message->hdr.sender, 0, NULL);
    }

    TRACE1("-plugin_open_handler\n");
    return 1;
    NOT_USED(handle);
}

static int plugin_close_handler(WimpMessage *message, void *handle)
{
    message_plugin_close *plugin_close = (message_plugin_close *) message->data.bytes;
    pluginclient_instance *instance = (pluginclient_instance *) plugin_close->instance.plugin;

    TRACE1("+plugin_close_handler() plugin = %p\n" _ instance);

    if (instance == NULL) /* workaround for browser error */
    {
      TRACE1("-plugin_close_handler\n");
      return 1;
    }

    /* acknowledge */
    pluginclient_send_closed(instance, message->hdr.your_ref, NULL,
          (plugin_close->flags & plugin_close_PLEASE_EXIT) != 0u);

    /* call client specific code */
    if (instance->plugin_fns->client_close != NULL)
      instance->plugin_fns->client_close(instance->client_data);

    /* dispose of window and plugin info */
    close_child_window(instance);

    /* dispose of stuff */
    dispose_plugin_info(instance);

    if ((plugin_close->flags & plugin_close_PLEASE_EXIT) != 0u)
    {
      TRACE1("-plugin_close_handler\n");
      exit(EXIT_SUCCESS);
    } /* if */

    TRACE1("-plugin_close_handler\n");
    return 1;
    NOT_USED(handle);
}

static int plugin_reshape_handler(WimpMessage *message, void *handle)
{
    message_plugin_reshape *msg = (message_plugin_reshape *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

    TRACE1("+plugin_reshape_handler(): plugin %p\n" _ plugin);

    /* store the new values */
    plugin->parent_window = (int)msg->window_handle;
    plugin->parent_box = *(BBox *)&msg->box;

    /* reopen the window */
    /* SJM: don't need the #ifdef as we set helper correctly in opening */
    open_child_window(plugin, !plugin->helper);

    TRACE1("-plugin_reshape_handler\n");
    return 1;
    NOT_USED(handle);
}

static int plugin_focus_handler(WimpMessage *message, void *handle)
{
    message_plugin_focus *msg = (message_plugin_focus *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;
    
    TRACE1 ("+plugin_focus_handler\n");

// Think about when one of our things needs focus. Currently it doesn't. By
// rights, the browser shouldn't send this if the flag in plugin opening message
// isn't set, but...
#if 0
    err_report(wimp_set_caret_position(plugin->wimp_window, -1, 0, 0, -1, -1));

    /* acknowledge message - reusing contents */
    message->hdr.your_ref = message->hdr.my_ref;
    err_fatal(wimp_send_message(Wimp_EUserMessageAcknowledge, &message,
                                plugin->parent_task, 0, NULL));
#endif

    TRACE1 ("-plugin_focus_handler\n");
    return 1;
    NOT_USED(handle);
    NOT_USED(plugin);
}

/* --------------------------------------------------------------------------------------------- */

static int plugin_stream_new_handler(WimpMessage *message, void *handle)
{
    message_plugin_stream_new *msg = (message_plugin_stream_new *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;
    int stype;

    TRACE1("+plugin_stream_new(): flags %08x\n");
    /* tell client about new stream and get stream type */
    stype = msg->flags & plugin_stream_TYPE;

    if (plugin->plugin_fns->client_stream_new)
      plugin->plugin_fns->client_stream_new(plugin->client_data,
                            get_ptr(msg, msg->mime_type), &msg->stream,
                            msg->flags & plugin_stream_SEEKABLE ? 1 : 0,
                            &stype);
    msg->flags = (msg->flags &~ plugin_stream_TYPE) | (stype & plugin_stream_TYPE);

    /* reply to message with new type - reusing message */
    message->hdr.your_ref = message->hdr.my_ref;
    err_fatal(wimp_send_message(Wimp_EUserMessage, message, plugin->parent_task, -1, NULL));

    TRACE1("-plugin_stream_new\n");
    return 1;
    NOT_USED(handle);
}

static int plugin_stream_as_file_handler(WimpMessage *message, void *handle)
{
    message_plugin_stream_as_file *msg = (message_plugin_stream_as_file *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

    TRACE1("+plugin_stream_as_file_handler\n");
    if (plugin->plugin_fns->client_stream_as_file)
    {
      if (!plugin->plugin_fns->client_stream_as_file(plugin->client_data,
                                                     &msg->stream,
                                                     get_ptr(msg, msg->file_name)))
      {
        /* fatal error, so clean up */
        pluginclient_send_closed(plugin, 0, NULL, 0);

        /* dispose of window and plugin info */
        close_child_window(plugin);

        /* call client specific code */
        if (plugin->plugin_fns->client_close)
          plugin->plugin_fns->client_close(plugin->client_data);

        /* dispose of stuff */
        dispose_plugin_info(plugin);

      } /* if */
    } /* if */

    TRACE1("-plugin_stream_as_file_handler\n");
    return 1;
    NOT_USED(handle);
}

static int plugin_stream_destroy_handler(WimpMessage *message, void *handle)
{
    message_plugin_stream_destroy *msg = (message_plugin_stream_destroy *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

    TRACE1("+plugin_stream_destroy_handler\n");
    if (plugin->plugin_fns->client_stream_destroy)
      plugin->plugin_fns->client_stream_destroy(plugin->client_data,
                                                &msg->stream, 0);

    TRACE1("-plugin_stream_destroy_handler\n");
    return 1;
    NOT_USED(handle);
}

static int plugin_action_handler(WimpMessage *message, void *handle)
{
    message_plugin_action *msg = (message_plugin_action *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;
    
    TRACE1 ("+plugin_action_handler\n");

    if (plugin->plugin_fns->client_action)
      if (!plugin->plugin_fns->client_action(plugin->client_data, msg->new_state))
      {
        /* fatal error, so clean up */
        pluginclient_send_closed(plugin, 0, NULL, 0);

        /* dispose of window and plugin info */
        close_child_window(plugin);

        /* call client specific code */
        if (plugin->plugin_fns->client_close)
          plugin->plugin_fns->client_close(plugin->client_data);

        /* dispose of stuff */
        dispose_plugin_info(plugin);
      } /* if */

    TRACE1 ("-plugin_action_handler\n");
    return 1;
    NOT_USED(handle);
}

static int plugin_abort_handler(WimpMessage *message, void *handle)
{
    message_plugin_abort *msg = (message_plugin_abort *)message->data.bytes;
    pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;
    
    TRACE1 ("+plugin_abort_handler\n");

    if (plugin->plugin_fns->client_action)
      plugin->plugin_fns->client_action(plugin->client_data, client_action_STOP);

    TRACE1 ("-plugin_abort_handler\n");
    return 1;
    NOT_USED(handle);
}

/* --------------------------------------------------------------------------------------------- */

static int help_request_handler(WimpMessage *message, void *handle)
{
    WimpHelpRequestMessage *help_request = &message->data.help_request;
    pluginclient_instance *plugin = find_plugin (help_request->window_handle);

    TRACE1 ("+help_request_handler\n");

    if (plugin)
    {
	WimpMessage reply;
	WimpHelpReplyMessage *help_reply = &reply.data.help_reply;

	if (plugin->plugin_fns->client_help &&
	    plugin->plugin_fns->client_help(plugin->client_data, help_request,
	                                    help_reply))
	{
	    err_fatal(wimp_send_message(Wimp_EUserMessage, &reply,
	                                message->hdr.sender, 0, NULL));
            TRACE1 ("-help_request_handler\n");
	    return 1;
	}
    }

    TRACE1 ("-help_request_handler\n");
    return 0;
    NOT_USED(message);
    NOT_USED(handle);
}

/* --------------------------------------------------------------------------------------------- */

static void cleanup_task(void)
{
    TRACE1 ("+cleanup_task\n");
    dispose_plugin_all();
    TRACE1 ("-cleanup_task\n");
}

static void cleanup(void)
{
    pluginclient **curr_pluginclient;
    time_t tp;

    TRACE1 ("+cleanup\n");
    for (curr_pluginclient=all_pluginclients; *curr_pluginclient;
         curr_pluginclient++)
    {
      if ( (*curr_pluginclient)->client_shutdown )
        (*curr_pluginclient)->client_shutdown();
    } /* for */

    _swix(Hourglass_Smash, 0);	/* just in case */

    time(&tp);
    TRACE1("*** " APP_NAME " exiting at %s" _ ctime(&tp));
    m_SUMMARY ();
    TRACE1 ("-cleanup\n");
}

static int quit_handler(WimpMessage *message, void *handle)
{
    TRACE1 ("+quit_handler\n");
    exit(EXIT_SUCCESS);
    TRACE1 ("-quit_handler\n");
    return 1;
    NOT_USED(message);
    NOT_USED(handle);
}

static int quit_handler1(int event_code, ToolboxEvent *event, IdBlock *id_block,
                         void *handle)
{
    TRACE1 ("+quit_handler1\n");
    quit_handler(NULL, NULL);
    TRACE1 ("-quit_handler1\n");
    return 1;
    NOT_USED(event_code);
    NOT_USED(event);
    NOT_USED(id_block);
    NOT_USED(handle);
}

static int null_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    pluginclient_instance *curr_inst;

    TRACE1 ("+null_handler\n");

    if (n_instances == 0 &&
	cli_timeout != -1 &&
	clock()/CLK_TCK >= last_checkpoint + cli_timeout)
    {
        TRACE4("Exiting due to inactivity\n");
	exit(EXIT_SUCCESS);
        TRACE1 ("-null_handler\n");
    }

    for (curr_inst=plugin_list; curr_inst; curr_inst=curr_inst->next)
    {
      if ( curr_inst->plugin_fns->client_idle )
        curr_inst->plugin_fns->client_idle(curr_inst->client_data);
    } /* for */

    TRACE1 ("-null_handler\n");
    return 0;
    NOT_USED(event_code);
    NOT_USED(event);
    NOT_USED(id_block);
    NOT_USED(handle);
}

/* --------------------------------------------------------------------------------------------- */

/* Start playing file automatically when we start - I thought about pretending
 * to be a browser and do a plugin_open and plugin_stream things, but it was
 * far too complex in comparison */
#if 1
static int immediate_file_play(char *file_name)
{
  pluginclient *pluginclient_fns;
  pluginclient_instance *plugin;
  int file_type;

  /* first get file type so we know which client to use */
  file_type = get_file_type(file_name);

  if ( (pluginclient_fns = handle_file_type(file_type)) == NULL)
     return 0; /* not handled */

  TRACE4("immediate_file_play(): file type = &%X\n" _ file_type);

  /* create a plugin so we can close down later in the same way */
  if ((plugin = calloc(sizeof(struct pluginclient_instance), 1)) == NULL)
    return 0;

  plugin->plugin_fns = pluginclient_fns;

  pluginclient_increment_count();

  /* add to list */
  plugin->next = plugin_list;
  if (plugin_list)
    plugin_list->prev = plugin;
  plugin_list = plugin;

  err_fatal(toolbox_create_object(0, OUR_OBJECT, &plugin->window));

  add_window_handlers(plugin->window, plugin);

  kill_old_helper(plugin);  /* kills all helpers _except_ plugin */

  plugin->helper=TRUE;

  plugin->client_data = plugin->plugin_fns->client_play_file(file_name,
                                                             file_type,
                                                             plugin->window,
                                                             plugin);
  if (!plugin->client_data)
  {
    /* dispose of window and plugin info */
    close_child_window(plugin);

    /* call client specific code */
    if (plugin->plugin_fns->client_close)
      plugin->plugin_fns->client_close(plugin->client_data);

    /* dispose of stuff */
    dispose_plugin_info(plugin);
  } /* if */

  return 1;
} /* immediate_file_play */
#else
static int immediate_file_play(char *file_name)
{
   pluginclient *pluginclient_fns;
   pluginclient_instance *plugin = NULL;
   int file_type;
   BOOL handled = TRUE; /*error indicator*/
 
   TRACE1("+immediate_file_play(): file type = &%X\n" _ file_type);
 
   /* first get file type so we know which client to use */
   file_type = get_file_type(file_name);
 
   if ( (pluginclient_fns = handle_file_type(file_type)) == NULL)
   {
      handled = FALSE;
      goto finish;
   }
 
   /* create a plugin so we can close down later in the same way */
   if ((plugin = m_CALLOC(sizeof(struct pluginclient_instance), 1)) == NULL)
   {
      handled = FALSE;
      goto finish;
   }
 
   plugin->plugin_fns = pluginclient_fns;
 
   pluginclient_increment_count();
 
   if (toolbox_create_object (0, OUR_OBJECT, &plugin->window) != NULL)
   {
      handled = FALSE;
      goto finish;
   }
 
   add_window_handlers(plugin->window, plugin);
 
   kill_old_helper(plugin);  /* kills all helpers _except_ plugin */
   plugin->helper = TRUE;

   if (plugin->plugin_fns->client_play_file == NULL)
   {
      handled = FALSE;
      goto finish;
   }
      
   if ((plugin->client_data = plugin->plugin_fns->client_play_file
         (file_name, file_type, plugin->window, plugin)) == NULL)
   {
      handled = FALSE;
      goto finish;
   }

   /* add to list */
   plugin->next = plugin_list;
   if (plugin_list)
      plugin_list->prev = plugin;
   plugin_list = plugin;
   
finish:
   if (!handled)
   {
      /*Something went wrong---tidy up.*/
      if (plugin != NULL)
      {
         if (plugin->window != NULL_ObjectId)
         {
            close_child_window (plugin);
            pluginclient_decrement_count();
         }
         m_FREE (plugin, sizeof *plugin);
      }
      /*Don't call client specific code---if something went wrong, the window
         was never opened! Deleted code |if (plugin->plugin_fns->client_close
         != NULL) plugin->plugin_fns->client_close (plugin->client_data); JRC
         18 Jun 1997*/

      /* free memory and zero pointers */
      free_params(plugin->param_list);
      plugin->param_list = NULL;

      free_rma_strings(NULL, plugin);
   }

   return handled;
} /* immediate_file_play */
#endif

static int dataopen_handler(WimpMessage *message, void *handle) {
  WimpDataOpen *msg = (WimpDataOpen *) &message->data;
  WimpMessage reply;

  TRACE1 ("+dataopen_handler\n");

  if (immediate_file_play(msg->path_name))
  {
    memcpy(&reply, message, sizeof(reply));
    reply.hdr.action_code = Wimp_MDataLoadAck;
    reply.hdr.your_ref = reply.hdr.my_ref;
    err_fatal(wimp_send_message(Wimp_EUserMessage, &reply,
                                reply.hdr.sender, 0, NULL));

    TRACE1 ("-dataopen_handler\n");
    return 1;
  } /* if */

  TRACE1 ("-dataopen_handler\n");
  return 0;

  NOT_USED(handle);
} /* dataopen_handler */

/* handle soundplaystop: type URL to mute all clients */
static int openurl_handler(WimpMessage *message, void *handle)
{
  openurl_data *msg = (openurl_data *) &message->data;
  char *url;
  
  TRACE1 ("+openurl_handler\n");

  /* extract url */
  if (msg->indirect.tag == 0) /* indirected */
  {
    url = get_ptr(msg, msg->indirect.url);
  }
  else /* not indirected */
  {
    url = msg->url;
  } /* else */

  TRACE1("openurl_handler(): URL = \"%s\"\n" _ url);

  if ((strncmp(url, MUTE_URL1, strlen(MUTE_URL1)) == 0) ||
      (strncmp(url, MUTE_URL2, strlen(MUTE_URL2)) == 0))
  {
    pluginclient_instance *curr_inst;
    WimpMessage reply;

    /* request mute if available */
    for (curr_inst=plugin_list; curr_inst; curr_inst=curr_inst->next)
    {
      if ( curr_inst->plugin_fns->client_action )
        curr_inst->plugin_fns->client_action(curr_inst->client_data,
                                             client_action_MUTE);
    } /* for */

    /* acknowledge message */
    memcpy(&reply, message, sizeof(reply));
    reply.hdr.your_ref = reply.hdr.my_ref;
    err_fatal(wimp_send_message(Wimp_EUserMessageAcknowledge, &reply,
                                message->hdr.sender, 0, NULL));
  } /* if */
  
  TRACE1 ("-openurl_handler\n");
  return 0; /* allow others to get it */
} /* openurl_handler */

static void process_args(int argc, char *argv[])
{
    int i; /* boring counter var */

    cli_filename[0]='\0'; /* set filename to "" */

    for (i = 1; i < argc; i++)
    {
        char *s = argv[i];

        TRACE1("arg(%d)='%s'\n" _ i _ s);

	if (*s == '-')
	{
	    switch (tolower(*(s+1)))
	    {
	      case 'b':      /* sound buffer size in bytes */
	          if (i+1 < argc)
	            cli_buffersize = atoi(argv[++i]);
	          break;
	      case 'f':      /* file to play initially */
	          if (i+1 < argc)
	            strncpy(cli_filename, argv[++i], sizeof(cli_filename));
	          break;
              case 'p':      /* enable plugin protocol */
                  cli_plugin = 1;
                  break;
              case 'q':      /* quit when playback ends */
                  cli_timeout = 0;
                  break;
	      case 's':      /* stop playback immediately */
                  cli_stop = 1;
                  break;
	      case 't':      /* quit app after <next arg> seconds after last file
	                      * finished if no new file started */
		  if (i+1 < argc)
		    cli_timeout = atoi(argv[++i]);
		  break;
              default:
                  break;
	    } /* switch */
	} /* if */
    } /* for */
    TRACE4("process_args result: buffersize=%d, file=\"%s\", plugin=%d, "
           "stop=%d timeout=%d\n" _
           cli_buffersize _ cli_filename _ cli_plugin _ cli_stop _ cli_timeout);
} /* process_args */

static void initialise(int argc, char *argv[])
{
    int current_wimp, task;
    void *sprite;
    pluginclient **curr_pluginclient;

    /* usual library things */
    setlocale(LC_ALL, "");
    setbuf(stderr, NULL);
    atexit(cleanup);

    /* decode args */
    process_args(argc,argv);

    /* initialise toolbox first to get messages file */
    if (toolbox_initialise(0, 380, Wimp_MessageList, ToolBox_EventList, APP_DIR,
			      &message_block, &event_id_block,
			      &current_wimp, &task, &sprite) != NULL)
    {
	err_fatal(toolbox_initialise(0, 310, Wimp_MessageList, ToolBox_EventList, APP_DIR,
				     &message_block, &event_id_block,
				     &current_wimp, &task, &sprite));
    }

    /* cleanup that needs task running */
    atexit(cleanup_task);

    /* enabled msgs calls */
    utils_init(&message_block);

#if 0
    /* after main and utils init */
    signal_setup();
#endif

    /* initiliase event library */
    err_fatal(event_initialise(&event_id_block));

    patch_all_pluginclients();

    /* call clients' init after wimp/toolbox init */
    for (curr_pluginclient=all_pluginclients; *curr_pluginclient;
         curr_pluginclient++)
    {
      if ( (*curr_pluginclient)->client_init )
        (*curr_pluginclient)->client_init(argc, argv);
    } /* for */

    err_fatal(event_register_toolbox_handler(-1, Quit_Quit, quit_handler1, NULL));

    err_fatal(event_register_wimp_handler(0, Wimp_ENull, null_handler, NULL));

    err_fatal (event_register_message_handler (Wimp_MQuit,              quit_handler,      NULL));
    err_fatal (event_register_message_handler (Wimp_MPreQuit,           quit_handler,      NULL));
    err_fatal (event_register_message_handler (Wimp_MDataOpen,          dataopen_handler,  NULL));
    err_fatal (event_register_message_handler (Wimp_MTaskCloseDown,     closedown_handler, NULL));
    err_fatal (event_register_message_handler (MESSAGE_BROWSER_OPENURL, openurl_handler,   NULL));

    /* plugin protocol message handlers */
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_OPEN,           plugin_open_handler,           NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_CLOSE,          plugin_close_handler,          NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_RESHAPE,        plugin_reshape_handler,        NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_FOCUS,          plugin_focus_handler,          NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_STREAM_NEW,     plugin_stream_new_handler,     NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_STREAM_AS_FILE, plugin_stream_as_file_handler, NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_STREAM_DESTROY, plugin_stream_destroy_handler, NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_ACTION,         plugin_action_handler,         NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_ABORT,          plugin_abort_handler,          NULL));
    err_fatal (event_register_message_handler (Wimp_MHelpRequest,             help_request_handler,          NULL));
} /* initialise */

int main(int argc, char *argv[])
{
    time_t tp;

    time(&tp);
    TRACE1("*** New " APP_NAME " " VERSION_STRING " started %s" _ ctime(&tp));

    initialise(argc, argv);

    err_fatal(event_set_mask(event_mask));

    if (cli_filename[0] != '\0')
    {
      immediate_file_play(cli_filename);
    } /* if */

    TRACE4("Entering poll loop\n");
    m_SUMMARY ();
    while (TRUE)
    {
	int event_code;
	WimpPollBlock poll_block;

        TRACE4("waiting for event\n");
        event_poll_idle(&event_code, &poll_block, POLL_TIME, NULL);
        TRACE4("event was %d\n" _ event_code);
    }

    return EXIT_SUCCESS;
}

/* eof c.plugclient */
