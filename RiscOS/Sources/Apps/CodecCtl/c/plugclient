/* > plugclient.c

 * Main file for a plugin client

 */

#include <ctype.h>
#include <locale.h>
#include <signal.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <swis.h>
#include <time.h>

#include "toolbox.h"
#include "window.h"
#include "quit.h"
#include "event.h"
#include "wimplib.h"

#include "m.h"
#include "plugin.h"
#include "plugclient.h"
#include "version.h"
#include "client.h"
#include "utils.h"

/*Note. A sensible thing to do would be to write an explicit ctor and dtor
   for a plugin object, calling the ctor from immediate_file_play() and
   plugin_open(). JRC 11 Jul 1997*/

/* --------------------------------------------------------------------------------------------- */

#define APP_DIR		            "<" APP_NAME "$Dir>"
#define MESSAGE_BROWSER_OPENURL     0x4AF80
#define POLL_TIME	            100	/* 1 second */
#define MIN_ESC_TIME	            50	/* cs */

#define MUTE_URL1                   "soundplaystop:"
#define MUTE_URL2                   "ncfrescointernal:loadurl?url=soundplaystop%3A"

/* --------------------------------------------------------------------------------------------- */

typedef union
{
  char url[236];
  struct
  {
    int tag;
    plugin_string_value url;
    int flags;
    plugin_string_value body_file;
    plugin_string_value target;
  } indirect;
} openurl_data;

static MessagesFD message_block;    /* declare a message block for use with toolbox initialise */
static IdBlock event_id_block;      /* declare an event block for use with toolbox initialise  */

static int ToolBox_EventList[] =
{
  Quit_Quit,
  0
};

static int Wimp_MessageList[] =
{
    Wimp_MPreQuit,
    Wimp_MDataOpen,
    Wimp_MTaskCloseDown,
    Wimp_MHelpRequest,
    MESSAGE_BROWSER_OPENURL,
    MESSAGE_PLUGIN_OPEN,
    MESSAGE_PLUGIN_CLOSE,
    MESSAGE_PLUGIN_RESHAPE,
    MESSAGE_PLUGIN_FOCUS,
    MESSAGE_PLUGIN_STREAM_NEW,
    MESSAGE_PLUGIN_STREAM_AS_FILE,
    MESSAGE_PLUGIN_STREAM_DESTROY,
    MESSAGE_PLUGIN_ACTION,
    MESSAGE_PLUGIN_ABORT,
    Wimp_MQuit
};

static int event_mask = Wimp_Poll_PointerLeavingWindowMask |
      Wimp_Poll_PointerEnteringWindowMask |
      Wimp_Poll_PollWordNonZeroMask;

#define plugin_STATE_STRING(s) \
   ( \
      (s) == plugin_state_STOP? "plugin_state_STOP": \
      (s) == plugin_state_PLAY? "plugin_state_PLAY": \
      (s) == plugin_state_PAUSE? "plugin_state_PAUSE": \
      (s) == plugin_state_REWIND? "plugin_state_REWIND": \
      (s) == plugin_state_FAST_FORWARD? "plugin_state_FAST_FORWARD": \
      (s) == plugin_state_RECORD? "plugin_state_RECORD": \
      (s) == plugin_state_MUTE? "plugin_state_MUTE": \
      (s) == plugin_state_UNMUTE? "plugin_state_UNMUTE": \
      (m_ASSERT (FALSE), "") \
   )
   
static WimpEventHandler
   redraw_handler,
   click_handler,
   key_handler,
   gain_caret_handler,
   lose_caret_handler;

/* --------------------------------------------------------------------------------------------- */

static int last_checkpoint = 0;
static int n_instances = 0;

/* cli set values */

static int cli_buffersize = 0;
static char cli_filename[1024];
static int cli_stop = 0;
static int cli_plugin = 0;
static int cli_timeout = -1; /* infinite */

/* key handling for moving focus */

static int last_key_code = -1;
static int last_key_time = 0;

/* --------------------------------------------------------------------------------------------- */

struct pluginclient_instance
{
    pluginclient_instance	*prev, *next;

    void		*parent_instance;
    int			parent_window;
    BBox		parent_box;
    int			parent_task;

    pluginclient_param	*param_list;

    ObjectId		window;
    int			msgref;		/* ref of last message sent */

    int			wimp_window;	/* wimp version of 'window' handle */

    pluginclient        *plugin_fns;    /* functions depending on whether
                                         * codec/replay/midi etc. */

    client_ptr          client_data;    /* client's private data */

    BOOL                helper;         /* Is this a helper or plugin */

    BOOL           closed_message_sent; /* Whether we've sent a closed message
                                         * to browser - so we only send the
                                         * first one, which will be the one with
                                         * the first error
                                         */
    char                *url;           /*U R L being played by this plugin*/
};

/* --------------------------------------------------------------------------------------------- */

static pluginclient_instance	*plugin_list = NULL;

/* For new clients increase the size of all_pluginclients
 * and add to function below to get initialised
 */

static pluginclient *all_pluginclients[3];

static void patch_all_pluginclients( void )
{
  all_pluginclients[0] = &pluginclient_replay;
  all_pluginclients[1] = &pluginclient_midi;
  all_pluginclients[2] = NULL;
}

/* --------------------------------------------------------------------------------------------- */

static pluginclient_instance *find_plugin (int wimp_window)
{
    pluginclient_instance *plugin;

    for (plugin = plugin_list; plugin != NULL; plugin = plugin->next)
	if (wimp_window == plugin->wimp_window)
	    return plugin;

    return NULL;
}

/* Determine if a plugin exists.

   THIS FUNCTION SHOULD NEVER RETURN FALSE, because that is a sign that the
browser is asking us to do something to a plugin that no longer exists, and
the protocol is designed so that this need never happen. It certainly should
not be relied on, because quite often if you free a block and then allocate
one of the same size (as happens when 1 plugin is deleted and another created
in its place), you get the same pointer back; in this case, the browser would
be operating on the wrong plugin. However, at the moment, in order to ensure
some degree of reliability in the production code, we do make this check, and
do nothing (silently) if the plugin does not exist. We do make sure that a
noisy message gets into the trace file though! JRC 8 Jul 1997*/

BOOL pluginclient_exists (pluginclient_instance *p)
{
   pluginclient_instance *plugin;
   
   for (plugin = plugin_list; plugin != NULL; plugin = plugin->next)
      if (plugin == p)
         return TRUE;

   TRACE1 ("*** ASSERTION FAILURE (NOT REPORTED!) Non-existent plugin "
         "0x%X referenced ***\n" _ p);
   return FALSE;
}

/* find the pluginclient that handles this file type, or NULL if not found */
static pluginclient *handle_file_type(int file_type)
{
   int *ft;
   pluginclient **client;

   for (client = all_pluginclients; *client != NULL; client++)
      if ((*client)->file_type_list != NULL)
         for (ft = (*client)->file_type_list; *ft != -1; ft++)
	    if (*ft == file_type)
	       return *client;

   return NULL;
}

/* --------------------------------------------------------------------------------------------- */

/*
 * Read a string from the parameter file
 */

static _kernel_oserror *read_string(FILE *f, char **string_out)
{
   int              string_size;
   char            *string = NULL;
   _kernel_oserror *error = NULL; /*error indicator*/

   if (fread (&string_size, 4, 1, f) == EOF)
   {
      error = utils_msgs_error_lookup (1, "Read");
      goto finish;
   }

   if (string_size != 0)
   {
      if ((string = m_MALLOC (string_size + 1)) == NULL)
      {
         error = utils_msgs_error_lookup (1, "Memory");
         goto finish;
      }

      if (fread (string, string_size, 1, f) == EOF)
      {
         error = utils_msgs_error_lookup (1, "Read");
         goto finish;
      }

      string [string_size] = '\0';

      /* word-align pointer */
      if (fseek(f, -(long) string_size & 3L, SEEK_CUR) == EOF)
      {
         error = utils_msgs_error_lookup (1, "Seek");
         goto finish;
      }
   }
   else
      string = NULL;

   if (string_out != NULL) *string_out = string;

finish:
   if (error != NULL)
      if (string != NULL)
         free (string);

   return error;
}

/*
 * Read and parse the whole parameter file
 */

static _kernel_oserror *parse_parameter_file (pluginclient_instance *plugin,
      const char *file_name)
{
   FILE                  *f = NULL;
   plugin_parameter_type  type;
   int                    size, pos = 0;
   _kernel_oserror       *error = NULL; /*error indicator*/
   pluginclient_param    *param, *next;
   
   TRACE2 ("parse_parameter_file(): instance %p '%s'\n" _ plugin _ file_name);
   m_ASSERT (plugin != NULL);
    
   if ((f = fopen (file_name, "rb")) == NULL)
   {
      error = utils_msgs_error_lookup (1, "Open");
      goto finish;
   }

   while (TRUE)
   {
      type = plugin_parameter_TERMINATOR;
      if (fread (&type, 4, 1, f) == EOF)
      {
         error = utils_msgs_error_lookup (1, "Read");
         goto finish;
      }
      TRACE5 ("param: type %d \n" _ type);

      if (type == plugin_parameter_TERMINATOR)
          break;

      /* read size of strings */
      if (fread (&size, 4, 1, f) == EOF)
      {
         error = utils_msgs_error_lookup (1, "Read");
         goto finish;
      }
      TRACE5 ("param: string size %d \n" _ size);

      /* read in the strings */
      if ((param = m_CALLOC (sizeof *param, 1)) == NULL)
      {
         error = utils_msgs_error_lookup (1, "Memory");
         goto finish;
      }
      
      /* store type */
      param->type = type;
   
      /* read strings */
      if ((error = read_string (f, &param->name)) != NULL ||
            (error = read_string (f, &param->value)) != NULL ||
            (error = read_string (f, &param->value_type)) != NULL)
         goto finish;
      TRACE4 ("param: '%s' '%s' '%s' \n" _ strsafe (param->name) _
            strsafe (param->value) _ strsafe (param->value_type));

      /* advance to next record */
      pos += 2*4 + ALIGN (size);
      if (fseek (f, pos, SEEK_SET) == EOF)
      {
         error = utils_msgs_error_lookup (1, "Seek");
         goto finish;
      }
      TRACE5 ("param: skipped to %d \n" _ pos);

      /* attach to list */
      param->next = plugin->param_list;
      plugin->param_list = param;
   }

finish:
   if (f != NULL && fclose (f) && error == NULL) /*to be thought of as an
         iterated if*/
      error = utils_msgs_error_lookup (1, "Close");

   if (error != NULL)
   {
      /*Free the list.*/
      for (param = plugin->param_list; param != NULL; param = next)
      {
         next = param->next; /*avoid use when freed*/

         m_FREE (param->name, strlen (param->name) + 1);
	 m_FREE (param->value, strlen (param->value) + 1);
	 if (param->value_type != NULL)
	    m_FREE (param->value_type, strlen (param->value_type) + 1);
	 m_FREE (param, sizeof *param);
      }

      plugin->param_list = NULL;
   }

   return error;
}

/*
 * Dispose of the memory used by a parameter list
 */

static void free_params (pluginclient_instance *plugin)
{
   pluginclient_param *param, *next;
   
   TRACE3 ("free_params(): %p\n" _ plugin);
   m_ASSERT (plugin != NULL);
   
   for (param = plugin->param_list; param != NULL; param = next)
   {
      next = param->next; /*avoid use when freed*/

      m_FREE (param->name, strlen (param->name) + 1);
      m_FREE (param->value, strlen (param->value) + 1);
      if (param->value_type != NULL)
         m_FREE (param->value_type, strlen (param->value_type) + 1);
      m_FREE (param, sizeof *param);
   }

   plugin->param_list = NULL;
}

pluginclient_param *pluginclient_param_lookup(pluginclient_instance *plugin, const char *name,
                                              int mask, BOOL case_sensitive)
{
    pluginclient_param *param;

    TRACE4 ("pluginclient_param_lookup(): instance %p name %s mask 0x%X "
        "case %d\n" _ plugin _ name _ mask _ case_sensitive);
    m_ASSERT (plugin != NULL);

    for (param = plugin->param_list; param != NULL; param = param->next)
	if (((1 << param->type) & mask))
	{
	    if (case_sensitive)
	    {
		if (strcmp(name, param->name) == 0)
		    break;
	    }
	    else
	    {
		if (strcasecomp(name, param->name) == 0)
		    break;
	    }
	}

    TRACE4 ("pluginclient_param_lookup(): returns '%s'\n" _ param ? strsafe(param->value) : "");

    return param;
}

void pluginclient_decrement_count(void)
{
    m_ASSERT (n_instances > 0);
    if (--n_instances == 0) last_checkpoint = clock ()/CLK_TCK;
}

void pluginclient_increment_count(void)
{
    m_ASSERT (n_instances >= 0);
    n_instances++;
}

/* --------------------------------------------------------------------------------------------- */

typedef struct pluginclient_string_rma_ptr pluginclient_string_rma_ptr;

struct pluginclient_string_rma_ptr
{
    pluginclient_string_rma_ptr *prev, *next;
    pluginclient_instance *pp;
    int msgref;
};

static pluginclient_string_rma_ptr *rma_ptr_list = NULL;

/* ----------------------------------------------------------------------------- */


/*
 * get a ptr to real data from a plugin message.
 * The data may be in the message body or in the RMA.
 */

static char *get_ptr (void *msgdata, plugin_string_value sv)
{
   char *ptr;

   m_ASSERT (sv.offset != 0);
   ptr = sv.offset == 0? NULL: sv.offset <= 236? (char *) msgdata + sv.offset: sv.ptr;
   m_ASSERT (ptr != NULL);

   return ptr;
}

/* --------------------------------------------------------------------------------------------- */

/*
 * Copy the string 's' into a block allocated from the RMA and link it into the
 * list of blocks so allocated.
 */

static void *rma_dup(const char *s)
{
    pluginclient_string_rma_ptr *ptr;
    int len = strlen(s) + 1;

    if ((ptr = m_RMA_MALLOC(len + sizeof (pluginclient_string_rma_ptr))) == NULL)
	return NULL;

    ptr->prev = NULL;
    ptr->next = rma_ptr_list;
    ptr->msgref = -1;

    if (rma_ptr_list)
	rma_ptr_list->prev = ptr;

    rma_ptr_list = ptr;

    memcpy(ptr+1, s, len);

    return ptr+1;
}

static void free_rma_strings(int msgref, pluginclient_instance *pp)
{
    pluginclient_string_rma_ptr *psrp, *next;

    for (psrp = rma_ptr_list; psrp; psrp = next)
    {
        next = psrp->next; /* prevent use when freed */

	/* if either the msgref or pointer match then
	 * remove from the list and free
	 */
	if (psrp->msgref == msgref || psrp->pp == pp)
	{
	    if (psrp->prev)
		psrp->prev->next = psrp->next;
	    if (psrp->next)
		psrp->next->prev = psrp->prev;

	    m_RMA_FREE (psrp, sizeof *psrp + strlen ((char *) (psrp + 1)));
	}
    }
}

static void write_string(WimpMessage *mp, plugin_string_value *so, const char *data)
{
    int space_left = sizeof(*mp) - mp->hdr.size;
    int data_len = strlen(data) + 1;

    if (data_len <= space_left)
    {
 	so->offset = mp->hdr.size - sizeof(mp->hdr); /* offset is relative to data start */
	strcpy(mp->data.bytes + so->offset, data);
	mp->hdr.size += data_len;
    }
    else
    {
	/* copy to rma */
	so->ptr = rma_dup(data);
    }
}

static void send_message(WimpMessage *msg, pluginclient_instance *pp)
{
    message_plugin_base *base = (message_plugin_base *)&msg->data;
    pluginclient_string_rma_ptr *psrp;

    if (!pp || !pp->parent_instance) return;

    TRACE5("Sending message to browser\n");
    base->instance.plugin = pp;
    base->instance.parent = pp->parent_instance;

    msg->hdr.size = ALIGN (msg->hdr.size);

    err_fatal(wimp_send_message(Wimp_EUserMessage, msg, pp->parent_task, -1, NULL));
    pp->msgref = msg->hdr.my_ref;

    /* rma allocated pointers are linked into list, we need to write in the msg reference */
    for (psrp = rma_ptr_list; psrp && psrp->msgref == -1; psrp = psrp->next)
    {
	psrp->msgref = msg->hdr.my_ref;
	psrp->pp = pp;
    }
}

static void remove_window_handlers (pluginclient_instance *plugin)
{
   ObjectId id = plugin->window;

   TRACE2 ("+remove_window_handlers\n");
   m_ASSERT (plugin != NULL);
   m_ASSERT (id != NULL_ObjectId);

   if (pluginclient_exists (plugin))
   {
      /* wimp event handlers */
      err_fatal (event_deregister_wimp_handler (id, Wimp_ERedrawWindow, redraw_handler,     plugin));
      err_fatal (event_deregister_wimp_handler (id, Wimp_EMouseClick,   click_handler,      plugin));
      err_fatal (event_deregister_wimp_handler (id, Wimp_EKeyPressed,   key_handler,        plugin));
      err_fatal (event_deregister_wimp_handler (id, Wimp_EGainCaret,    gain_caret_handler, plugin));
      err_fatal (event_deregister_wimp_handler (id, Wimp_ELoseCaret,    lose_caret_handler, plugin));
   }

   TRACE2 ("-remove_window_handlers\n");
}

static void close_child_window(pluginclient_instance *plugin)
{
   TRACE2("+close_child_window() : plugin %p\n" _ plugin);
   m_ASSERT (plugin != NULL);

   remove_window_handlers (plugin);

   /* remove window */
   err_report(toolbox_delete_object(0, plugin->window));
   plugin->window = NULL_ObjectId;
   plugin->wimp_window = 0;

   TRACE2 ("-close_child_window\n");
}

/*
 * dispose of the child window in the parent
 */

/* --------------------------------------------------------------------------------------------- */

static void dispose_plugin_info(pluginclient_instance *plugin)
{
    TRACE2("+dispose_plugin_info(): instance %p\n" _ plugin);
    m_ASSERT (plugin != NULL);

    /* free memory and zero pointers */
    free_params (plugin);

    free_rma_strings(NULL, plugin);

    /* unlink */
    if (plugin->prev)
	plugin->prev->next = plugin->next;
    else
	plugin_list = plugin->next;

    if (plugin->next)
	plugin->next->prev = plugin->prev;

    /* decrement uses and start exit timer */
    pluginclient_decrement_count();
    
    if (plugin->url != NULL)
       m_FREE (plugin->url, strlen (plugin->url) + 1);

    /* free */
    m_FREE (plugin, sizeof *plugin);

    TRACE2("-dispose_plugin_info\n");
}

/* --------------------------------------------------------------------------------------------- */

/*
 * Send a message closed to the parent.
 */

void pluginclient_send_closed(pluginclient_instance *plugin, int your_ref,
                              _kernel_oserror *e, BOOL close_now)
{
   WimpMessage message;
   message_plugin_closed *msg = (message_plugin_closed *)message.data.bytes;

   TRACE2("+pluginclient_send_closed: plugin 0x%X, closed_message_sent %s\n" _
          plugin _ plugin->closed_message_sent? "TRUE": "FALSE");
   if (e != NULL)
      TRACE2 ("error %d: %s\n" _ e->errnum _ e->errmess);
      
   /*Might not exist yet (if called from error code in immediate_play_file,
      e g). JRC 1 Jul 1997*/
   if (!plugin->closed_message_sent) /* don't send >1 closed to browser */
   {
      plugin->closed_message_sent=TRUE;

      message.hdr.your_ref = your_ref;
      message.hdr.action_code = MESSAGE_PLUGIN_CLOSED;
      message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_closed);
  
      msg->flags = (your_ref ? 0 : plugin_closed_NOT_REPLY) |
            (close_now ? plugin_closed_EXITING : 0);
  
      if (e != NULL)
      {
         msg->errnum = e->errnum;
  	 strncpy(msg->errmess, e->errmess, sizeof(msg->errmess));
  	 msg->errmess[sizeof(msg->errmess)-1] = 0;
  
  	 msg->flags |= plugin_closed_ERROR_MSG;
      }
  
      send_message(&message, plugin);
   }

   TRACE2("-pluginclient_send_closed\n"); }

/*
 * Send a STATUS message
 */

void pluginclient_send_status(pluginclient_instance *plugin, const char *status)
{
   WimpMessage message;
   message_plugin_status *msg = (message_plugin_status *)message.data.bytes;

   TRACE2("+pluginclient_send_status: plugin 0x%X\n" _ plugin);

   /*Might not exist yet. JRC 1 Jul 1997*/
   message.hdr.your_ref = 0;
   message.hdr.action_code = MESSAGE_PLUGIN_STATUS;
   message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_status);

   write_string(&message, &msg->message, status);

   send_message(&message, plugin);

   TRACE2("-pluginclient_send_status\n"); }

/*
 * Send a FOCUS message
 */

static void pluginclient_send_focus(pluginclient_instance *plugin)
{
   WimpMessage message;

   TRACE2("+pluginclient_send_focus: plugin 0x%X\n" _ plugin);

   /*Might not exist yet. JRC 1 Jul 1997*/
   message.hdr.your_ref = 0;
   message.hdr.action_code = MESSAGE_PLUGIN_FOCUS;
   message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_focus);

   send_message(&message, plugin);
    
   TRACE2("-pluginclient_send_focus\n");
}

/* send a busy message to browser. If no state, set state to -1 */
void pluginclient_send_busy(pluginclient_instance *plugin, BOOL busy, int state)
{
   WimpMessage message;
   message_plugin_busy *busy_mess;

   TRACE2 ("+pluginclient_send_busy: plugin 0x%X, busy %s, state %s\n" _
         plugin _ busy? "TRUE": "FALSE" _ plugin_STATE_STRING (state));
   m_ASSERT (plugin != NULL);

   /*Might not exist yet. JRC 1 Jul 1997*/
   message.hdr.your_ref = 0;
   message.hdr.action_code = MESSAGE_PLUGIN_BUSY;
   message.hdr.size = sizeof(message.hdr) + sizeof(message_plugin_busy);

   busy_mess = (message_plugin_busy *) &message.data;
   busy_mess->flags = (busy ? plugin_busy_BUSY : 0) |
                    (state != -1 ? plugin_busy_STATE_VALID : 0);
   busy_mess->state = state; /* doesn't matter whether -1 or not, as flag means
                              * it won't be looked at if it is */
   send_message(&message, plugin);

   /* if we've stopped, and we're a -file client, then quit the client */
   if (state == plugin_state_STOP && plugin->parent_instance == NULL)
   {
     TRACE2("pluginclient_send_busy() noticed STOP with no parent\n");

     /* call client specific code */
     if (plugin->plugin_fns->client_close != NULL)
        plugin->plugin_fns->client_close (&plugin->client_data);

     /* dispose of window and plugin info */
     close_child_window(plugin);

     /* dispose of stuff */
     dispose_plugin_info(plugin);
   } /* if */

   TRACE2 ("-pluginclient_send_busy\n");
} /* pluginclient_send_busy */


/* tell the browser to go to the specified url */
void pluginclient_browser_goto(pluginclient_instance *plugin, const char *url)
{
   WimpMessage message;
   openurl_data *data = (openurl_data *) &message.data;
   pluginclient_string_rma_ptr *psrp;
   
   if (pluginclient_exists (plugin))
   {
      if (!plugin->parent_task) return;
    
      message.hdr.size = sizeof(message.hdr);
      message.hdr.your_ref = 0;
      message.hdr.action_code = MESSAGE_BROWSER_OPENURL;
    
      if (strlen(url) < sizeof(data->url))
      {
        strcpy(data->url, url);
        message.hdr.size += strlen(url) + 1;
      } /* if */
      else
      {
        data->indirect.tag = 0;
        data->indirect.flags = 0;
        data->indirect.body_file.ptr = NULL;
        data->indirect.target.ptr = NULL;
        message.hdr.size += sizeof(data->indirect);
        write_string(&message, &data->indirect.url, url);
      } /* else */
    
      message.hdr.size = ALIGN (message.hdr.size);
    
      err_fatal(wimp_send_message(Wimp_EUserMessage, &message, plugin->parent_task,
                                  0, NULL));
      plugin->msgref = message.hdr.my_ref;
    
      /* rma allocated pointers are linked into list, we need to write in the msg reference */
      for (psrp = rma_ptr_list; psrp && psrp->msgref == -1; psrp = psrp->next)
      {
        psrp->msgref = message.hdr.my_ref;
        psrp->pp = plugin;
      } /* for */
   }
} /* pluginclient_browser_goto */

/* --------------------------------------------------------------------------------------------- */

/* Window handlers */

static int redraw_handler(int event_code, WimpPollBlock *event, IdBlock *id_block,
                          void *handle)
{
   pluginclient_instance *plugin = handle;
   WimpRedrawWindowRequestEvent *e = &event->redraw_window_request;

   TRACE2 ("+redraw_handler(): instance %p\n" _ plugin);
    
   if (pluginclient_exists (plugin))
      err_fatal(pluginclient_redraw(e->window_handle,
                                  plugin->plugin_fns->client_redraw_setup,
                                  plugin->plugin_fns->client_redraw,
                                  plugin->client_data));

   TRACE2 ("-redraw_handler\n");
   return 1;
   NOT_USED(id_block);
   NOT_USED(event_code);
}

static int click_handler(int event_code, WimpPollBlock *event, IdBlock *id_block,
                         void *handle)
{
   pluginclient_instance *plugin = handle;
   WimpMouseClickEvent *e = &event->mouse_click;

   TRACE2 ("+click_handler(): instance %p\n" _ plugin);
    
   if (pluginclient_exists (plugin))
      if (plugin->plugin_fns->client_click)
         plugin->plugin_fns->client_click (plugin->client_data, e);

   TRACE2 ("-click_handler\n");
   return 1;
   NOT_USED(id_block);
   NOT_USED(event_code);
}

static int key_handler(int event_code, WimpPollBlock *event, IdBlock *id_block,
                       void *handle)
{
   pluginclient_instance *plugin = handle;
   WimpKeyPressedEvent *e = &event->key_pressed;
   int claimed = FALSE;

   TRACE2 ("+key_handler: instance %p\n" _ plugin);
    
   if (pluginclient_exists (plugin))
   {
      if (e->key_code == 27)
      {
  	time_t t = clock();
  
  	if (last_key_code == 27 && t - last_key_time <= MIN_ESC_TIME)
  	{
  	    /* pass focus back to browser */
  	    pluginclient_send_focus(plugin);
  
  	    claimed = TRUE;
  	}
  
  	last_key_time = t;
      }
  
      last_key_code = e->key_code;
  
      if (!claimed && plugin->plugin_fns->client_key)
  	plugin->plugin_fns->client_key(plugin->client_data, e);
   }

   TRACE2 ("-key_handler\n");
   return 1;
   NOT_USED(id_block);
   NOT_USED(event_code);
}

static int gain_caret_handler(int event_code, WimpPollBlock *event,
                              IdBlock *id_block, void *handle)
{
   pluginclient_instance *plugin = handle;

   TRACE2 ("+gain_caret_handler: plugin %p\n" _ plugin);

   if (pluginclient_exists (plugin))
      if (plugin->plugin_fns->client_gain_caret != NULL)
         plugin->plugin_fns->client_gain_caret (plugin->client_data);

   TRACE2 ("-gain_caret_handler\n");
   return 1;
   NOT_USED(id_block);
   NOT_USED(event_code);
   NOT_USED(event);
}

static int lose_caret_handler(int event_code, WimpPollBlock *event,
                              IdBlock *id_block, void *handle)
{
   pluginclient_instance *plugin = handle;

   TRACE2 ("+lose_caret_handler: plugin %p\n" _ plugin);

   if (pluginclient_exists (plugin))
      if (plugin->plugin_fns->client_lose_caret != NULL)
         plugin->plugin_fns->client_lose_caret (plugin->client_data);

   TRACE2 ("-lose_caret_handler\n");
   return 1;
   NOT_USED(id_block);
   NOT_USED(event_code);
   NOT_USED(event);
}

/* --------------------------------------------------------------------------------------------- */

void pluginclient_window_position(pluginclient_instance *plugin, BBox *box, int *xscroll, int *yscroll)
{
    WimpGetWindowStateBlock state;

    state.window_handle = (int)plugin->wimp_window;
    err_fatal(wimp_get_window_state(&state));

    if (box)
	*box = state.visible_area;
    if (xscroll)
	*xscroll = state.xscroll;
    if (yscroll)
	*yscroll = state.yscroll;
}

/* --------------------------------------------------------------------------------------------- */

/*
 * These two routines will handle redraws on a window
 */

_kernel_oserror *pluginclient_redraw(int window_handle,
                                     pluginclient_redraw_handler setup,
                                     pluginclient_redraw_handler draw,
                                     void *cp)
{
    int more;
    _kernel_oserror *e;
    WimpRedrawWindowBlock r;

    r.window_handle = window_handle;
    e = wimp_redraw_window(&r, &more);

    if (!e && more && setup)
    	e = setup((client_ptr *)cp, &r, FALSE);

    while (!e && more)
    {
    	if (draw) e = draw((client_ptr *)cp, &r, FALSE);
	if (!e) e = wimp_get_rectangle(&r, &more);
    }

    return e;
}

_kernel_oserror *pluginclient_update(WimpUpdateWindowBlock *update,
                                     pluginclient_redraw_handler setup,
                                     pluginclient_redraw_handler draw,
                                     void *cp)
{
    int more;
    _kernel_oserror *e;
    WimpRedrawWindowBlock r;

    r.window_handle = update->window_handle;
    r.visible_area = update->update_area;

    e = wimp_update_window(&r, &more);

    if (!e && more && setup)
    	e = setup((client_ptr *)cp, &r, TRUE);

    while (!e && more)
    {
    	if (draw) e = draw((client_ptr *)cp, &r, TRUE);
	if (!e) e = wimp_get_rectangle(&r, &more);
    }

    return e;
}

/* --------------------------------------------------------------------------------------------- */

static void add_window_handlers (pluginclient_instance *plugin)
{
   ObjectId id = plugin->window;

   TRACE2 ("+add_window_handlers\n");
   m_ASSERT (plugin != NULL);
   m_ASSERT (id != NULL_ObjectId);

   /* wimp event handlers */
   err_fatal (event_register_wimp_handler (id, Wimp_ERedrawWindow, redraw_handler,     plugin));
   err_fatal (event_register_wimp_handler (id, Wimp_EMouseClick,   click_handler,      plugin));
   err_fatal (event_register_wimp_handler (id, Wimp_EKeyPressed,   key_handler,        plugin));
   err_fatal (event_register_wimp_handler (id, Wimp_EGainCaret,    gain_caret_handler, plugin));
   err_fatal (event_register_wimp_handler (id, Wimp_ELoseCaret,    lose_caret_handler, plugin));

   TRACE2 ("-add_window_handlers\n");
}

/* --------------------------------------------------------------------------------------------- */

/*
 * open the child window in the parent. Returns TRUE iff a window was opened.
 */

static int open_child_window(pluginclient_instance *plugin, BOOL subwindow)
{
    WindowShowObjectBlock   full_spec;
    WimpGetWindowStateBlock state;
    BOOL                    opened = FALSE;

    TRACE2 ("+open_child_window(): plugin %p subwindow %d\n" _ plugin _ subwindow);
    /*Plugin does not exist yet. JRC 1 Jul 1997*/

    /* create the window if not already there */
    if (plugin->window == NULL_ObjectId)
    {
	err_fatal(toolbox_create_object(0, OUR_OBJECT, &plugin->window));
	err_fatal(window_get_wimp_handle(0, plugin->window, &plugin->wimp_window));
    }

    if (subwindow)
    {
      /* get the state of the parent */
      m_ASSERT (plugin->parent_window != 0);
      TRACE2 ("parent window 0x%X\n" _ plugin->parent_window);
      state.window_handle = (int)plugin->parent_window;
      err_fatal(wimp_get_window_state(&state));
      TRACE2 ("parent window O K\n");

      /* construct the open details for the plugin */
      full_spec.visible_area.xmin = plugin->parent_box.xmin +
                                    state.visible_area.xmin - state.xscroll;
      full_spec.visible_area.ymin = plugin->parent_box.ymin +
                                    state.visible_area.ymax - state.yscroll;
      full_spec.visible_area.xmax = plugin->parent_box.xmax +
                                    state.visible_area.xmin - state.xscroll;
      full_spec.visible_area.ymax = plugin->parent_box.ymax +
                                    state.visible_area.ymax - state.yscroll;

      /* only show if height and width are both greater than 1 pixel */
      if (((full_spec.visible_area.xmax - full_spec.visible_area.xmin) > 1) &&
    	  ((full_spec.visible_area.ymax - full_spec.visible_area.ymin) > 1))
      {
    	  full_spec.xscroll = 0;
	  full_spec.yscroll = 0;
	  full_spec.behind = -1;
	  full_spec.window_flags = 0;
	  full_spec.parent_window_handle = (int)plugin->parent_window;
	  full_spec.alignment_flags = 0;

	  /* show it */
	  err_fatal(toolbox_show_object(Toolbox_ShowObject_AsSubWindow,
	                                plugin->window, Toolbox_ShowObject_FullSpec,
	                                &full_spec, 0, -1));
	  opened = TRUE;
      } /* if */
    } /* if */

    /* if a subwindow, tell the client where it is. If not a subwindow, client
     * takes note and will open window itself later if necessary */
    if (plugin->plugin_fns->client_set_window != NULL)
      plugin->plugin_fns->client_set_window(plugin->client_data, plugin->window,
                                            &full_spec.visible_area, subwindow);

    TRACE2 ("-open_child_window\n");
    return opened;
}

/* Check if the application that's quit was responsible for any of the
   plugins that we've started. In practice, this means that if the task
   that's quit is the browser, we close all the plugins. But not
   necessarily! JRC 6 Jun 1997*/

static int closedown_handler(WimpMessage *message, void *handle)
{
   pluginclient_instance *plugin, *next;

   TRACE2 ("+closedown_handler\n");
   m_ASSERT (handle == NULL);
   NOT_USED (handle);

   for (plugin = plugin_list; plugin != NULL; plugin = next)
   {
      next = plugin->next; /* prevent use when freed */

      /*Check whether the task that has closed down is the task that started
         this plugin instance.*/
      if (message->hdr.sender == plugin->parent_task)
      {
         /* call client specific code */
         if (plugin->plugin_fns->client_close != NULL)
            plugin->plugin_fns->client_close (&plugin->client_data);

         /* dispose of window and plugin info */
         close_child_window (plugin);

         /* dispose of stuff */
         dispose_plugin_info (plugin);
      }
   }

   TRACE2 ("-closedown_handler\n");
   return 0; /* allow other tasks to get message */
} /* closedown_handler */

/*Dispose of all plugins. Recoded JRC 20 Jun 1997 to remove rather bizarre
   aliasing (based purely on paranoia).*/

static void dispose_plugin_all(void)
{
   pluginclient_instance *plugin, *next;
   
   TRACE2 ("+dispose_plugin_all\n");

   for (plugin = plugin_list; plugin != NULL; plugin = next)
   {
      next = plugin->next; /* prevent use when freed */

      /* notify host */
      pluginclient_send_closed(plugin, /*your_ref*/ 0, NULL, /*close_now?*/ FALSE);

      /* call client specific code (swapped JRC 20 Jun 1997)*/
      if (plugin->plugin_fns->client_close != NULL)
	  plugin->plugin_fns->client_close (&plugin->client_data);

      /* dispose of window and plugin info (swapped JRC 20 Jun 1997)*/
      close_child_window(plugin);

      /* dispose of stuff */
      dispose_plugin_info (plugin);
   }

   TRACE2 ("-dispose_plugin_all\n");
}

static void dispose_helpers_except(pluginclient_instance *except)
{
  pluginclient_instance *plugin, *next;

  TRACE2 ("+dispose_helpers_except\n");
  m_ASSERT (except != NULL);

  for (plugin = plugin_list; plugin != NULL; plugin = next)
  {
    next = plugin->next; /* prevent use when freed */

    if (plugin->helper && plugin != except)
    {
      TRACE5("Killing helper %p\n" _ plugin);

      pluginclient_send_closed(plugin, /*your_ref*/ 0, NULL, /*close_now?*/ FALSE);

      /* call client specific code (swapped JRC 20 Jun 1997)*/
      if (plugin->plugin_fns->client_close != NULL)
         plugin->plugin_fns->client_close (&plugin->client_data);

      /* dispose of window and plugin info (swapped JRC 20 Jun 1997)*/
      close_child_window (plugin);

      /* dispose of stuff */
      dispose_plugin_info (plugin);
    } /* if */
  } /* for */

  TRACE2 ("-dispose_helpers_except\n");
} /* dispose_helpers_except */

/* --------------------------------------------------------------------------------------------- */

/* Broadcast when object is opened initially */

static int plugin_open_handler(WimpMessage *message, void *handle)
{
   message_plugin_open     *msg = (message_plugin_open *) message->data.bytes;
   pluginclient_instance   *plugin = NULL;
   pluginclient            *pluginclient_fns;
   int                      opening_flags;
   _kernel_oserror         *error = NULL; /*error indicator*/
   BOOL                     handled = FALSE;
   BOOL                     incremented_count = FALSE;
   BOOL                     parsed = FALSE;
#if CHECK
   WimpGetWindowStateBlock  state;
#endif

   TRACE1 ("+plugin_open_handler\n");
   m_ASSERT (handle == NULL); NOT_USED (handle);

#if CHECK
   TRACE2 ("parent window 0x%X\n" _ msg->window_handle);
   if ((state.window_handle = (int) msg->window_handle) != 0)
      if ((error = wimp_get_window_state (&state)) != NULL)
         goto finish;
#endif

   /* check type is handled by a pluginclient, and which one it is */
   if ((pluginclient_fns = handle_file_type (msg->file_type)) != NULL)
   {
      /* allocate block */
      if ((plugin = m_CALLOC (sizeof *plugin, 1)) == NULL)
      {
         error = utils_msgs_error_lookup (1, "Memory");
         goto finish;
      }
      TRACE1 ("new plugin 0x%X\n" _ plugin);

      plugin->plugin_fns = pluginclient_fns;

      pluginclient_increment_count ();
      incremented_count = TRUE;

      /* save info from the open message */
      /* if we have a non-hidden box then force it to be a helper */
      plugin->helper = (msg->box.x1 - msg->box.x0 > 1 && msg->box.y1 - msg->box.y0 > 1) ||
            (msg->flags & plugin_open_HELPER) != 0u;
      plugin->parent_instance = msg->instance.parent;
      plugin->parent_window   = (int) msg->window_handle;
      plugin->parent_box      = *(BBox *) &msg->box;
      plugin->parent_task     = message->hdr.sender;

      /* load up the file details */
      if ((error = parse_parameter_file (plugin, get_ptr (msg, msg->file_name))) !=
            NULL)
  	goto finish;
      parsed = TRUE;

      /* call the client */
      TRACE5("Calling client_open()\n");
      if (plugin->plugin_fns->client_open != NULL)
      {
         if ((error = plugin->plugin_fns->client_open (plugin,
               &plugin->client_data, &opening_flags)) != NULL)
            goto finish;
         
         /* open the window - must be after client_open() */
         if (open_child_window (plugin, FALSE))
            plugin->helper = TRUE;   /* SJM: mark it now as being a helper*/

         add_window_handlers (plugin);
         /****IF*** THERE was anything that could go wrong after this point, we
            would have to remember that we had opened the window, and close it
            again if it *did* go wrong. As it is, textual examination of the
            file reveals that the error flag cannot get set in the sequel.
            Whew!*/

         /* send acknowledgement - reuse message block */
         msg->instance.plugin = plugin;
         msg->flags = opening_flags | (plugin->helper? plugin_opening_HELPER: 0u);
   
         message->hdr.action_code = MESSAGE_PLUGIN_OPENING;
         message->hdr.your_ref = message->hdr.my_ref;
         message->hdr.size = sizeof message->hdr + sizeof (message_plugin_opening);
         err_fatal (wimp_send_message (Wimp_EUserMessage, message, message->hdr.sender, 0,
               NULL));
   
         if (plugin->helper)
            dispose_helpers_except (plugin);  /* kills all helpers _except_ plugin */
   
         /* add to list---last thing we do JRC 20 Jun 1997*/
         plugin->next = plugin_list;
         if (plugin_list != NULL)
            plugin_list->prev = plugin;
         plugin_list = plugin;

         handled = TRUE;
      }
   }

finish:
   if (error != NULL)
   {
      message_plugin_closed *msg = (message_plugin_closed *) message->data.bytes;
            /*it's what a scoped language is for ...*/

      /* send error message---still reuse message block though*/
      msg->instance.plugin = NULL; /*we're going to free it soon ...*/
      msg->flags           = plugin_closed_EXITING | plugin_closed_ERROR_MSG;
      msg->errnum          = error->errnum;
      sprintf (msg->errmess, "%.*s", sizeof msg->errmess - 1, error->errmess);

      message->hdr.action_code = MESSAGE_PLUGIN_CLOSED;
      message->hdr.your_ref    = message->hdr.my_ref;
      message->hdr.size        = sizeof message->hdr +
                                 offsetof (message_plugin_closed, errmess) +
                                 ALIGN (strlen (msg->errmess) + 1);

      err_fatal (wimp_send_message (Wimp_EUserMessage, message,
            message->hdr.sender, 0, NULL));

      if (parsed) free_params (plugin);
      if (incremented_count) pluginclient_decrement_count ();
      if (plugin != NULL) m_FREE (plugin, sizeof *plugin);
   }

   TRACE1("-plugin_open_handler\n");
   return handled;
}

static int plugin_close_handler(WimpMessage *message, void *handle)
{
   message_plugin_close *plugin_close = (message_plugin_close *) message->data.bytes;
   pluginclient_instance *plugin = (pluginclient_instance *) plugin_close->instance.plugin;

   TRACE1("+plugin_close_handler: plugin 0x%X\n" _ plugin);
   m_ASSERT (plugin != NULL);

   if (pluginclient_exists (plugin))
   {
      /* acknowledge */
      pluginclient_send_closed(plugin, message->hdr.your_ref, NULL,
            /*close_now?*/ (plugin_close->flags & plugin_close_PLEASE_EXIT) != 0u);
   
      /* call client specific code */
      if (plugin->plugin_fns->client_close != NULL)
        plugin->plugin_fns->client_close (&plugin->client_data);
   
      /* dispose of window and plugin info */
      close_child_window(plugin);
   
      /* dispose of stuff */
      dispose_plugin_info(plugin);
   
      if ((plugin_close->flags & plugin_close_PLEASE_EXIT) != 0u)
      {
        TRACE2("-plugin_close_handler\n");
        exit(EXIT_SUCCESS);
      } /* if */
   }

   TRACE1("-plugin_close_handler\n");
   return 1;
   NOT_USED(handle);
}

static int plugin_reshape_handler(WimpMessage *message, void *handle)
{
   message_plugin_reshape *msg = (message_plugin_reshape *)message->data.bytes;
   pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

   TRACE1("+plugin_reshape_handler(): plugin %p\n" _ plugin);

   if (pluginclient_exists (plugin))
   {
      /* store the new values */
      plugin->parent_window = (int) msg->window_handle;
      plugin->parent_box = *(BBox *) &msg->box;
   
      /* reopen the window */
      /* SJM: don't need the #ifdef as we set helper correctly in opening */
      open_child_window (plugin, !plugin->helper);
   }

   TRACE1("-plugin_reshape_handler\n");
   return 1;
   NOT_USED(handle);
}

static int plugin_focus_handler(WimpMessage *message, void *handle)
{
   message_plugin_focus *msg = (message_plugin_focus *)message->data.bytes;
   pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;
   
   TRACE1 ("+plugin_focus_handler: plugin 0x%X\n" _ plugin);

   if (pluginclient_exists (plugin))
   {
     /* Think about when one of our things needs focus. Currently it doesn't. By
        rights, the browser shouldn't send this if the flag in plugin opening message
        isn't set, but...*/
#if 0
         err_report(wimp_set_caret_position(plugin->wimp_window, -1, 0, 0, -1, -1));
     
         /* acknowledge message - reusing contents */
         message->hdr.your_ref = message->hdr.my_ref;
         err_fatal(wimp_send_message(Wimp_EUserMessageAcknowledge, &message,
                                    plugin->parent_task, 0, NULL));
#endif
   }

   TRACE1 ("-plugin_focus_handler\n");
   return 1;
   NOT_USED(handle);
   NOT_USED(plugin);
}

/* --------------------------------------------------------------------------------------------- */

static int plugin_stream_new_handler(WimpMessage *message, void *handle)
{
   message_plugin_stream_new *msg = (message_plugin_stream_new *)message->data.bytes;
   pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;
   BOOL duplicate;
   int stype;
   _kernel_oserror *error = NULL; /*error indicator*/
   char *url;
   pluginclient_instance *p;
   
   TRACE1 ("+plugin_stream_new_handler: plugin 0x%X, flags 0x%X\n" _ plugin _ msg->flags);
   m_ASSERT (handle == NULL); NOT_USED (handle);
   m_ASSERT (plugin != NULL);

   if (pluginclient_exists (plugin))
   {
      duplicate = FALSE;
      url = get_ptr (msg, msg->stream.url);
      m_ASSERT (url != NULL);
   
      /*Dispose of 2 special cases: (j) some pages have both <object> and
         <embed> tags, to cater for Netscape and Internet Ek$plorer: we can
         handle both, so must ignore the second; and (ij) some pages have
         multiple codec controls on them with the same U R L, so again we must
         ignore the second. Don't include helpers in this check, as this would
         prevent a helper from starting once a plugin has been seen.*/
      if (!plugin->helper)
         /*Check that we don't have a client already active for this U R L.*/
         for (p = plugin_list; p != NULL; p = p->next)
            if (p != plugin && !p->helper && p->url != NULL && strcmp (p->url, url) == 0)
            {
               /*Just say no!*/
               duplicate = TRUE;
               break;
            }
      TRACE2 ("U R L \"%s\", duplicate %s, helper %s\n" _ url _ duplicate? "TRUE": "FALSE" _
            plugin->helper? "TRUE": "FALSE");
   
      if (duplicate)
      {
         /*Respond with a (non-error) CLOSED message to turn down the browser's
            request.*/
         message_plugin_closed *msg = (message_plugin_closed *) message->data.bytes;
               /*it's what a scoped language is for ...*/
   
         /* send error message---reuse message block*/
         msg->instance.plugin = plugin;
         msg->flags           = plugin_closed_NOT_REPLY;
   
         message->hdr.action_code = MESSAGE_PLUGIN_CLOSED;
         message->hdr.your_ref    = message->hdr.my_ref;
         message->hdr.size        = sizeof message->hdr + sizeof msg;
   
         err_fatal (wimp_send_message (Wimp_EUserMessage, message,
               message->hdr.sender, 0, NULL));
   
         dispose_plugin_info (plugin);
      }
      else
      {
         /*Remember the U R L that we are about to play. If we already have a
            U R L set, this is probably an error, but let's leave well enough
            alone ...*/
         if (plugin->url == NULL)
            plugin->url = strdup (url);
   
         /* tell client about new stream and get stream type */
         stype = msg->flags & plugin_stream_TYPE;
   
         if (plugin->plugin_fns->client_stream_new != NULL)
         {
            if ((error = plugin->plugin_fns->client_stream_new
                  (plugin->client_data, get_ptr (msg, msg->mime_type),
                  &msg->stream, (msg->flags & plugin_stream_SEEKABLE) != 0u,
                  &stype)) != NULL)
               goto finish;
   
            /* reply to message with new type - reusing message */
            msg->flags = (msg->flags &~ plugin_stream_TYPE) |
                  (stype & plugin_stream_TYPE);
            message->hdr.your_ref = message->hdr.my_ref;
   
            err_fatal (wimp_send_message (Wimp_EUserMessage, message,
                  plugin->parent_task, -1, NULL));
         }
      }
   }

finish:
   if (error != NULL)
   {
      /*Should send a message here.*/
   }

   TRACE1("-plugin_stream_new_handler\n");
   return 1;
}

static int plugin_stream_as_file_handler(WimpMessage *message, void *handle)
{
   message_plugin_stream_as_file *msg = (message_plugin_stream_as_file *)message->data.bytes;
   pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;
   _kernel_oserror *error;

   TRACE1("+plugin_stream_as_file_handler: plugin 0x%X\n" _ plugin);
   m_ASSERT (plugin != NULL);

   if (pluginclient_exists (plugin))
   {
      if (plugin->plugin_fns->client_stream_as_file != NULL)
      {
         error = plugin->plugin_fns->client_stream_as_file (plugin->client_data,
               &msg->stream, get_ptr (msg, msg->file_name));
               
         if (error != NULL)
         {
            /* fatal error, so clean up */
            pluginclient_send_closed(plugin, /*your_ref*/ 0, NULL, /*close_now?*/ FALSE);
     
            /* call client specific code. Swapped JRC 23 Jun 1997*/
            if (plugin->plugin_fns->client_close != NULL)
               plugin->plugin_fns->client_close (&plugin->client_data);
     
            /* dispose of window and plugin info. Swapped JRC 23 Jun 1997*/
            close_child_window(plugin);
     
            /* dispose of stuff */
            dispose_plugin_info(plugin);
         } /* if */
      } /* if */
   }

   TRACE1("-plugin_stream_as_file_handler\n");
   return 1;
   NOT_USED(handle);
}

static int plugin_stream_destroy_handler(WimpMessage *message, void *handle)
{
   message_plugin_stream_destroy *msg = (message_plugin_stream_destroy *)message->data.bytes;
   pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

   TRACE1("+plugin_stream_destroy_handler: plugin 0x%X\n" _ plugin);

   if (pluginclient_exists (plugin))
      if (plugin->plugin_fns->client_stream_destroy)
         plugin->plugin_fns->client_stream_destroy (plugin->client_data,
               &msg->stream, 0);

   TRACE1("-plugin_stream_destroy_handler\n");
   return 1;
   NOT_USED(handle);
}

static int plugin_action_handler(WimpMessage *message, void *handle)
{
   message_plugin_action *msg = (message_plugin_action *)message->data.bytes;
   pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;
   _kernel_oserror *error = NULL;

   NOT_USED(handle);

   TRACE1 ("+plugin_action_handler: plugin 0x%X\n" _ plugin);
   m_ASSERT (plugin != NULL);
   
   if (pluginclient_exists (plugin))
      if (plugin->plugin_fns->client_action != NULL)
      {
         error = plugin->plugin_fns->client_action (plugin->client_data,
               msg->new_state);
   
         if (error != NULL)
         {
            /* fatal error, so clean up */
            pluginclient_send_closed(plugin, /*your_ref*/ 0, NULL, /*close_now?*/ FALSE);
   
            /* call client specific code. Swapped JRC 23 Jun 1997*/
            if (plugin->plugin_fns->client_close != NULL)
               plugin->plugin_fns->client_close (&plugin->client_data);
   
            /* dispose of window and plugin info. Swapped JRC 23 Jun 1997*/
            close_child_window(plugin);
   
            /* dispose of stuff */
            dispose_plugin_info(plugin);
         } /* if */
      }

   TRACE1 ("-plugin_action_handler\n");
   return 1;
}

static int plugin_abort_handler(WimpMessage *message, void *handle)
{
   message_plugin_abort *msg = (message_plugin_abort *)message->data.bytes;
   pluginclient_instance *plugin = (pluginclient_instance *)msg->instance.plugin;

   NOT_USED(handle);
   TRACE1 ("+plugin_abort_handler: plugin 0x%X\n" _ plugin);
   
   if (pluginclient_exists (plugin))
      if (plugin->plugin_fns->client_action != NULL)
         (void) plugin->plugin_fns->client_action (plugin->client_data,
               plugin_state_STOP);

   TRACE1 ("-plugin_abort_handler\n");
   return 1;
}

/* --------------------------------------------------------------------------------------------- */

static int help_request_handler(WimpMessage *message, void *handle)
{
    WimpHelpRequestMessage *help_request = &message->data.help_request;
    pluginclient_instance *plugin;
    WimpMessage reply;
    WimpHelpReplyMessage *help_reply = &reply.data.help_reply;
    int helped;

    TRACE2 ("+help_request_handler\n");

    if ((plugin = find_plugin (help_request->window_handle)) != NULL)
    {
	if (plugin->plugin_fns->client_help != NULL)
	{
	    plugin->plugin_fns->client_help(plugin->client_data, help_request,
	                                    help_reply, &helped);
	    if (!helped)
                err_fatal(wimp_send_message(Wimp_EUserMessage, &reply,
	                                message->hdr.sender, 0, NULL));
            TRACE2 ("-help_request_handler\n");
	    return 1;
	}
    }

    TRACE2 ("-help_request_handler\n");
    return 0;
    NOT_USED(message);
    NOT_USED(handle);
}

/* --------------------------------------------------------------------------------------------- */

static void cleanup_task(void)
{
    TRACE2 ("+cleanup_task\n");
    dispose_plugin_all ();
    TRACE2 ("-cleanup_task\n");
}

static void cleanup(void)
{
   pluginclient **client;
   time_t tp;

   TRACE2 ("+cleanup\n");
   for (client = all_pluginclients; *client != NULL; client++)
      if ((*client)->client_shutdown != NULL)
         (*client)->client_shutdown ();

   _swix(Hourglass_Smash, 0);	/* just in case */

   time (&tp);
   TRACE1 ("*** " APP_NAME " exiting at %s" _ ctime (&tp));
   m_SUMMARY (), m_RMA_SUMMARY ();
   TRACE2 ("-cleanup\n");
}

static int prequit_handler(WimpMessage *message, void *handle)
{
   NOT_USED (message);
   NOT_USED (handle);

   TRACE2 ("+prequit_handler\n");
   m_ASSERT (handle == NULL);

   exit (EXIT_SUCCESS);
   return 0; /*suppress warning*/
}

static int quit_handler(WimpMessage *message, void *handle)
{
    NOT_USED(message);
    NOT_USED(handle);

    TRACE2 ("+quit_handler\n");
    m_ASSERT (handle == NULL);

    exit(EXIT_SUCCESS);
    return 0; /*suppress warning*/
}

static int quit_handler1(int event_code, ToolboxEvent *event, IdBlock *id_block,
                         void *handle)
{
    TRACE2 ("+quit_handler1\n");
    m_ASSERT (handle == NULL);

    quit_handler(NULL, NULL);
    TRACE2 ("-quit_handler1\n");
    return 1;
    NOT_USED(event_code);
    NOT_USED(event);
    NOT_USED(id_block);
    NOT_USED(handle);
}

static int null_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    pluginclient_instance *curr_inst;

    TRACE3 ("+null_handler\n");
    m_ASSERT (handle == NULL);

    if (n_instances == 0 &&
	cli_timeout != -1 &&
	clock()/CLK_TCK >= last_checkpoint + cli_timeout)
    {
        TRACE2("Exiting due to inactivity\n");
	exit(EXIT_SUCCESS);
    }

    for (curr_inst=plugin_list; curr_inst; curr_inst=curr_inst->next)
      if ( curr_inst->plugin_fns->client_idle != NULL)
        curr_inst->plugin_fns->client_idle(curr_inst->client_data);

    TRACE3 ("-null_handler\n");
    return 0;
    NOT_USED(event_code);
    NOT_USED(event);
    NOT_USED(id_block);
    NOT_USED(handle);
}

/* --------------------------------------------------------------------------------------------- */

/* Start playing file automatically when we start - I thought about pretending
 * to be a browser and do a plugin_open and plugin_stream things, but it was
 * far too complex in comparison */

static int immediate_file_play(char *file_name)
{
   pluginclient          *pluginclient_fns;
   pluginclient_instance *plugin = NULL;
   int                    file_type;
   BOOL                   handled = TRUE; /*error indicator*/
   BOOL                   incremented = FALSE;
   BOOL                   created = FALSE;
   BOOL                   added = FALSE;
 
   TRACE2("+immediate_file_play\n");
 
   /* first get file type so we know which client to use */
   file_type = get_file_type (file_name);
   TRACE3("file_type &%X\n" _ file_type);
 
   if ((pluginclient_fns = handle_file_type (file_type)) == NULL)
   {
      handled = FALSE;
      goto finish;
   }

   /* create a plugin so we can close down later in the same way */
   if ((plugin = m_CALLOC (sizeof *plugin, 1)) == NULL)
   {
      handled = FALSE;
      goto finish;
   }
 
   plugin->plugin_fns = pluginclient_fns;
 
   pluginclient_increment_count();
   incremented = TRUE;
 
   if (toolbox_create_object (0, OUR_OBJECT, &plugin->window) != NULL)
   {
      handled = FALSE;
      goto finish;
   }
   created = TRUE;
   err_fatal(window_get_wimp_handle(0, plugin->window, &plugin->wimp_window));
   
   add_window_handlers (plugin);
   added = TRUE;
 
   dispose_helpers_except (plugin);  /* kills all helpers _except_ plugin */
   plugin->helper = TRUE;

   if (plugin->plugin_fns->client_play_file == NULL)
   {
      handled = FALSE;
      goto finish;
   }

   plugin->plugin_fns->client_play_file (file_name, file_type, plugin->window, plugin, &plugin->client_data);

   if (plugin->client_data == NULL)
   {
      handled = FALSE;
      goto finish;
   }

   /* add to list */
   plugin->next = plugin_list;
   if (plugin_list != NULL)
      plugin_list->prev = plugin;
   plugin_list = plugin;

finish:
   if (!handled)
   {
      /*Something went wrong---tidy up.*/
      if (added) remove_window_handlers (plugin);

      if (created) toolbox_delete_object (0, plugin->window);

      if (incremented) pluginclient_decrement_count ();

      /*Don't call client specific code---if something went wrong, the window
         was never opened! Deleted code |if (plugin->plugin_fns->client_close
         != NULL) plugin->plugin_fns->client_close (&plugin->client_data);
         JRC 18 Jun 1997*/

      /*Don't call dispose_plugin_info() functions free_params(),
         free_rma_strings(). JRC 11 Jul 1997*/

      if (plugin != NULL) m_FREE (plugin, sizeof *plugin);
   }

   TRACE2("-immediate_file_play\n");

   return handled;
} /* immediate_file_play */

static int dataopen_handler(WimpMessage *message, void *handle)
{
  WimpDataOpen *msg = (WimpDataOpen *) &message->data;
  WimpMessage reply;

  TRACE2 ("+dataopen_handler\n");
  m_ASSERT (handle == NULL);

  if (immediate_file_play(msg->path_name))
  {
    memcpy(&reply, message, sizeof(reply));
    reply.hdr.action_code = Wimp_MDataLoadAck;
    reply.hdr.your_ref = reply.hdr.my_ref;
    err_fatal(wimp_send_message(Wimp_EUserMessage, &reply,
                                reply.hdr.sender, 0, NULL));

    TRACE2 ("-dataopen_handler\n");
    return 1;
  } /* if */

  TRACE2 ("-dataopen_handler\n");
  return 0;

  NOT_USED(handle);
} /* dataopen_handler */

/* handle soundplaystop: type URL to mute all clients */
static int openurl_handler(WimpMessage *message, void *handle)
{
  openurl_data *msg = (openurl_data *) &message->data;
  char *url;
  pluginclient_instance *plugin;
  WimpMessage reply;

  TRACE2 ("+openurl_handler\n");
  m_ASSERT (handle == NULL);
  NOT_USED (handle);

  /* extract url */
  if (msg->indirect.tag == 0) /* indirected */
    url = get_ptr(msg, msg->indirect.url);
  else /* not indirected */
    url = msg->url;

  TRACE2("openurl_handler(): URL = \"%s\"\n" _ url);

  if ((strncmp(url, MUTE_URL1, strlen(MUTE_URL1)) == 0) ||
      (strncmp(url, MUTE_URL2, strlen(MUTE_URL2)) == 0))
  {
    /* request mute if available */
    for (plugin = plugin_list; plugin != NULL; plugin = plugin->next)
      if (plugin->plugin_fns->client_action != NULL)
        (void) plugin->plugin_fns->client_action(plugin->client_data,
                                             plugin_state_MUTE);

    /* acknowledge message */
    memcpy(&reply, message, sizeof(reply));
    reply.hdr.your_ref = reply.hdr.my_ref;
    err_fatal(wimp_send_message(Wimp_EUserMessageAcknowledge, &reply,
                                message->hdr.sender, 0, NULL));
  } /* if */
  
  TRACE2 ("-openurl_handler\n");
  return 0; /* allow others to get it */
} /* openurl_handler */

static void process_args(int argc, char *argv[])
{
    int i; /* boring counter var */

    cli_filename[0]='\0'; /* set filename to "" */

    for (i = 1; i < argc; i++)
    {
        char *s = argv[i];

        TRACE5 ("arg(%d)='%s'\n" _ i _ s);

	if (*s == '-')
	{
	    switch (tolower(*(s+1)))
	    {
	      case 'b':      /* sound buffer size in bytes */
	          if (i+1 < argc)
	            cli_buffersize = atoi(argv[++i]);
	          break;
	      case 'f':      /* file to play initially */
	          if (i+1 < argc)
	            strncpy(cli_filename, argv[++i], sizeof(cli_filename));
	          break;
              case 'p':      /* enable plugin protocol */
                  cli_plugin = 1;
                  break;
              case 'q':      /* quit when playback ends */
                  cli_timeout = 0;
                  break;
	      case 's':      /* stop playback immediately */
                  cli_stop = 1;
                  break;
	      case 't':      /* quit app after <next arg> seconds after last file
	                      * finished if no new file started */
		  if (i+1 < argc)
		    cli_timeout = atoi(argv[++i]);
		  break;
              default:
                  break;
	    } /* switch */
	} /* if */
    } /* for */
    TRACE2 ("process_args result: buffersize=%d, file=\"%s\", plugin=%d, "
           "stop=%d timeout=%d\n" _
           cli_buffersize _ cli_filename _ cli_plugin _ cli_stop _ cli_timeout);
} /* process_args */

static void initialise(int argc, char *argv[])
{
    int current_wimp, task;
    void *sprite;
    pluginclient **client;

    /* usual library things */
    setlocale(LC_ALL, "");
    setbuf(stderr, NULL);
    atexit(cleanup);

    /* decode args */
    process_args(argc,argv);

    /* initialise toolbox first to get messages file */
    if (toolbox_initialise(0, 380, Wimp_MessageList, ToolBox_EventList, APP_DIR,
			      &message_block, &event_id_block,
			      &current_wimp, &task, &sprite) != NULL)
    {
	err_fatal(toolbox_initialise(0, 310, Wimp_MessageList, ToolBox_EventList, APP_DIR,
				     &message_block, &event_id_block,
				     &current_wimp, &task, &sprite));
    }

    /* cleanup that needs task running */
    atexit(cleanup_task);

    /* enabled msgs calls */
    utils_init(&message_block);

    /* initiliase event library */
    err_fatal(event_initialise(&event_id_block));

    patch_all_pluginclients();

    /* call clients' init after wimp/toolbox init */
    for (client=all_pluginclients; *client;
         client++)
    {
      if ( (*client)->client_init )
        (*client)->client_init(argc, argv);
    } /* for */

    err_fatal(event_register_toolbox_handler(-1, Quit_Quit, quit_handler1, NULL));

    err_fatal(event_register_wimp_handler(0, Wimp_ENull, null_handler, NULL));

    err_fatal (event_register_message_handler (Wimp_MQuit,              quit_handler,      NULL));
    err_fatal (event_register_message_handler (Wimp_MPreQuit,           prequit_handler,   NULL));
    err_fatal (event_register_message_handler (Wimp_MDataOpen,          dataopen_handler,  NULL));
    err_fatal (event_register_message_handler (Wimp_MTaskCloseDown,     closedown_handler, NULL));
    err_fatal (event_register_message_handler (MESSAGE_BROWSER_OPENURL, openurl_handler,   NULL));

    /* plugin protocol message handlers */
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_OPEN,           plugin_open_handler,           NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_CLOSE,          plugin_close_handler,          NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_RESHAPE,        plugin_reshape_handler,        NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_FOCUS,          plugin_focus_handler,          NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_STREAM_NEW,     plugin_stream_new_handler,     NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_STREAM_AS_FILE, plugin_stream_as_file_handler, NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_STREAM_DESTROY, plugin_stream_destroy_handler, NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_ACTION,         plugin_action_handler,         NULL));
    err_fatal (event_register_message_handler (MESSAGE_PLUGIN_ABORT,          plugin_abort_handler,          NULL));
    err_fatal (event_register_message_handler (Wimp_MHelpRequest,             help_request_handler,          NULL));
} /* initialise */

int main (int argc, char *argv [])
{
    time_t tp;
    int event_code;
    WimpPollBlock poll_block;

    time(&tp);
    TRACE1 ("*** " APP_NAME " " VERSION_STRING " started %s" _ ctime(&tp));

    initialise(argc, argv);

    err_fatal(event_set_mask(event_mask));

    if (cli_filename[0] != '\0')
    {
      immediate_file_play(cli_filename);
    } /* if */

    m_SUMMARY (), m_RMA_SUMMARY ();
    while (TRUE)
    {
	int t;
	_swix(OS_ReadMonotonicTime, _OUT(0), &t);
        event_poll_idle(&event_code, &poll_block, t + POLL_TIME, NULL);
#if TRACE
	dbgclose();
#endif
    }

    return EXIT_SUCCESS;
}

/* eof c.plugclient */
