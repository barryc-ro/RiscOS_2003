#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "swis.h"

#include "Desk.DeskMem.h"
#include "Desk.Debug.h"
#include "Desk.Wimp.h"
#include "Desk.MsgTrans.h"
#include "Desk.KernelSWIs.h"
#include "Desk.Str.h"
#include "Desk.Error2.h"

#include "HTML.Args.h"

#include "^.Modem.h"
#include "^.ISDN.h"
#include "^.Blank.h"

#include "^.Modem.CMOS.h"
#include "Global.h"



#define NCCONFIG_ISDN_OPERATOR_NISDN1		13
#define NCCONFIG_ISDN_OPERATOR_NISDN2		20
#define NCCONFIG_ISDN_OPERATOR_5ESS5		 6
#define NCCONFIG_ISDN_OPERATOR_5ESS9		 7
#define NCCONFIG_ISDN_OPERATOR_DMS100		 8


#define NCCONFIG_ISDN_CMOS_START		0x100

#define NCCONFIG_ISDN_MAX_DN_DIGITS		32	  /* assumed even */
#define NCCONFIG_ISDN_MAX_SUBADDR_DIGITS	20	  /* assumed even */
#define NCCONFIG_ISDN_MAX_SPID_DIGITS		20        /* assumed even */

/*  Number of bytes required to hold 'n' nibbles.  Half of one byte is unused if 'n' is odd.
 */
#define NUM_BYTES_FOR_NIBBLES(n)		((n + 1) / 2)


/*  Convert an integer value 'n', used to represent an ASCII digit in a nibble 
 *  of CMOS, to the corresponding ASCII digit.
 *  The values 1 .. 10 represent the digits '0' to '9'.  The value 0 is a terminator.
 */
#define NIBBLE_TO_ASCII_DIGIT(n)		(((n) == 0) ? '\0' : '0' + (n) - 1)


#define ASCII_DIGIT_TO_NIBBLE(d)		(((d) == '\0') ? 0 : (d) - '0' + 1)


/*  Stucture representing in memory the ISDN configuration information stored in CMOS.
 */
typedef struct {

  	int		country;
  	int		operator;

	char		directory_number[NCCONFIG_ISDN_MAX_DN_DIGITS + 1];
	char		subaddress[NCCONFIG_ISDN_MAX_SUBADDR_DIGITS + 1];
} NCConfig_ISDN_CMOS;
	  	


static void	NCConfig_ISDN_WriteCMOS (NCConfig_ISDN_CMOS *isdn)
{
	int 	i;
	int	cmos_addr = NCCONFIG_ISDN_CMOS_START;
		
	Desk_Debug_Printf (Desk_error_PLACE "NCConfig_ISDN_WriteCMOS operator=%i, country=%i\n",
		isdn->operator, isdn->country);

	Desk_Debug_Printf (Desk_error_PLACE "NCConfig_ISDN_WriteCMOS dn=%s, subaddr=%s\n",
		isdn->directory_number, isdn->subaddress);

	#ifdef NCConfig_ROMBUILD
		Desk_OS_Byte_WriteCMOS (cmos_addr++, isdn->country);
		Desk_OS_Byte_WriteCMOS (cmos_addr++, isdn->country >> 8);
		Desk_OS_Byte_WriteCMOS (cmos_addr++, isdn->operator);		

		for (i = 0; i < NCCONFIG_ISDN_MAX_DN_DIGITS; i+=2) {
		  	Desk_OS_Byte_WriteCMOS (cmos_addr++, 
		  		ASCII_DIGIT_TO_NIBBLE(isdn->directory_number[i]) +
		  		(ASCII_DIGIT_TO_NIBBLE(isdn->directory_number[i+1]) << 4));
		}

		for (i = 0; i < NCCONFIG_ISDN_MAX_SUBADDR_DIGITS; i+=2) {
		  	Desk_OS_Byte_WriteCMOS (cmos_addr++, 
		  		ASCII_DIGIT_TO_NIBBLE(isdn->subaddress[i]) +
		  		(ASCII_DIGIT_TO_NIBBLE(isdn->subaddress[i+1]) << 4));
		}
	#endif
}

static void	NCConfig_ISDN_ReadCMOS (NCConfig_ISDN_CMOS *isdn)
{
	char	*s;
	int	i;
	int	x;
	int 	cmos_addr = NCCONFIG_ISDN_CMOS_START;
		
	isdn->country = Desk_OS_Byte_ReadCMOS (cmos_addr++);
	isdn->country += Desk_OS_Byte_ReadCMOS (cmos_addr++) << 8;

	isdn->operator = Desk_OS_Byte_ReadCMOS (cmos_addr++);
	

	for (i = 0, s = isdn->directory_number; 
	     i < NUM_BYTES_FOR_NIBBLES (NCCONFIG_ISDN_MAX_DN_DIGITS); 
	     i++) {

		x = Desk_OS_Byte_ReadCMOS (cmos_addr++);

 		*s++ = NIBBLE_TO_ASCII_DIGIT (x & 0x0f);
 		*s++ = NIBBLE_TO_ASCII_DIGIT (x >> 4); 		
	}
	*s = '\0';
	
	for (i = 0, s = isdn->subaddress; 
	     i < NUM_BYTES_FOR_NIBBLES (NCCONFIG_ISDN_MAX_SPID_DIGITS); 
	     i++) {

		x = Desk_OS_Byte_ReadCMOS (cmos_addr++);

 		*s++ = NIBBLE_TO_ASCII_DIGIT (x & 0x0f);
 		*s++ = NIBBLE_TO_ASCII_DIGIT (x >> 4); 		
	}
        *s = '\0';

	
	Desk_Debug_Printf (Desk_error_PLACE "NCConfig_ISDN_ReadCMOS operator=%i, country=%i\n",
		isdn->operator, isdn->country);

	Desk_Debug_Printf (Desk_error_PLACE "NCConfig_ISDN_ReadCMOS dn=%s, subaddr=%s\n",
		isdn->directory_number, isdn->subaddress);
}


/*  Convert a string of ASCII decimal 'digits' into a binary array 'binarray' where each
 *  byte contains the binary integer value represented by the corresponding digit.
 *
 *  The maximum number of digits to convert is 'num', and 'binarray' must be large enough
 *  to receive this number of digits.
 * 
 *  The binary array is used as an intermediate format between the ASCII string supplied
 *  by the application and the format stored in the CMOS.  In CMOS, each binary value in 
 *  the array is stored in a nibble.  The use of the intermediate form is historic, and
 *  of unclear benefit compared with converting directly to the CMOS form, but if it 
 *  ain't broke...
 */
static void 	NCConfig_ISDN_Digits2Binarray (unsigned char *binarray, char *digits, unsigned num)
{
	int 	i;
	
	/* Zero the array to start.
	 */
	memset (binarray, 0, num);

	for (i = 0; i < num; i++) {
		int d = digits[i];
		
		if (d == '\0')
			break;
			
		if ( !isdigit( d))	{
			memset (binarray, 0, num);
			break;
		}

		binarray[i] = d - '0' + 1;			
	}
}


void NCConfig_ISDN_ArgsSet (HTML_Args_variablelist* vars)

{
	int 			i;
	NCConfig_Modem_CMOS	modem;
	NCConfig_ISDN_CMOS	isdn;
	
	HTML_Args_variable*	arg_prefix	= HTML_Args_FindVar( vars, "prefix", Desk_bool_TRUE);
	HTML_Args_variable*	arg_localcode	= HTML_Args_FindVar( vars, "localcode", Desk_bool_TRUE);
	HTML_Args_variable*	arg_disconnect	= HTML_Args_FindVar( vars, "disconnecttime", Desk_bool_TRUE);

	HTML_Args_variable*	arg_operator	= HTML_Args_FindVar( vars, "operator", Desk_bool_TRUE);
	HTML_Args_variable*	arg_country	= HTML_Args_FindVar( vars, "country", Desk_bool_TRUE);	

	HTML_Args_variable*	arg_dn		= HTML_Args_FindVar( vars, "dn", Desk_bool_TRUE);
	HTML_Args_variable*	arg_subaddr	= HTML_Args_FindVar( vars, "subaddr", Desk_bool_TRUE);

	memset (&modem, 0, sizeof(modem));
	memset (&isdn, 0, sizeof(isdn));	
	
	sscanf( arg_disconnect->value, "%i", &modem.disconnecttime);
	
	if ( arg_localcode)	{
		NCConfig_ISDN_Digits2Binarray (modem.localcode, arg_localcode->value, 6);
		
		Desk_Debug_Printf( Desk_error_PLACE "NCConfig_ISDN_ArgsSet: localcode is '%s', %i%i%i%i%i%i\n", 
			arg_localcode->value,
			modem.localcode[0], modem.localcode[1], modem.localcode[2], modem.localcode[3], modem.localcode[4], modem.localcode[5] 
			);
	}
	
	{
		char	prefix_digit = arg_prefix->value[0];
		
		if (0)	;
		else if ( prefix_digit=='*')		modem.flags.data.prefix = prefix_STAR;
		else if ( prefix_digit=='#')		modem.flags.data.prefix = prefix_HASH;
		else if ( isdigit( prefix_digit))	modem.flags.data.prefix = 1 + prefix_digit-'0';
		else					modem.flags.data.prefix = 0;
	}

	sscanf (arg_country->value, "%i", &isdn.country);
	sscanf (arg_operator->value, "%i", &isdn.operator);	
	
        for (i = 0; i < NCCONFIG_ISDN_MAX_DN_DIGITS; i++) {
            isdn.directory_number[i] = arg_dn->value[i];

            if (arg_dn->value[i] == '\0')
                break;

            if (!isdigit(arg_dn->value[i])) {
                memset(isdn.directory_number, 0, sizeof(isdn.directory_number));
                break;
            }    
        }	

        for (i = 0; i < NCCONFIG_ISDN_MAX_SUBADDR_DIGITS; i++) {
            isdn.subaddress[i] = arg_subaddr->value[i];

            if (arg_subaddr->value[i] == '\0')
                break;

            if (!isdigit(arg_subaddr->value[i])) {
                memset(isdn.subaddress, 0, sizeof(isdn.subaddress));
                break;
            }    
        }	

	
	NCConfig_Modem_WriteCMOS (&modem);
	NCConfig_ISDN_WriteCMOS (&isdn);
	
	NCConfig_BlankBottomPage2();
}


static void NCConfig_ISDN_FirstPage (Desk_deskmem_buffer *buffer)
{
	Desk_Debug_Printf (Desk_error_PLACE "NCConfig_ISDN_FirstPage called\n");

	Desk_Error2_Try	{
	  	NCConfig_ISDN_CMOS	isdn;
		int 			i;
				
		struct operator {
		    int	 		id;
		    char		*name;
		} operators [] = {
		    {11, "Euro-ISDN"},
		    {9, "NTT (Japan)"}
#if 0
		    {13, "North American National ISDN 1 (N-ISDN1)"},
		    {20, "North American National ISDN 2 (N-ISDN2)"},
		    {6,  "AT&T 5ESS5"},
		    {7,  "AT&T 5ESS9"},
		    {8,  "Northern Telecom DMS100"}
#endif
		};
		

		struct country {
		    int 	id;
		    char 	*name;
		} countries[] = {
		    {33, "France"},
		    {49, "Germany"},
		    {81, "Japan"},
		    {1000, "Other"} /* actually "Europe" */
		};					    	  	

		Desk_MessageTrans_LookupIntoBuffer (buffer, &NCConfig_global.messages, "ISDNOperatorHeader",
						    NULL, NULL, NULL, NULL);		

	  	NCConfig_ISDN_ReadCMOS (&isdn);

		for (i = 0; i < sizeof(operators) / sizeof(operators[0]); i++) {
			char operstring[16];

			sprintf (operstring, "%i", operators[i].id);

			Desk_MessageTrans_LookupIntoBufferCat (buffer, &NCConfig_global.messages, 
				"ISDNOperatorItem",
				isdn.operator == operators[i].id ? "selected" : "",
				operstring, operators[i].name, NULL);
		}

		Desk_MessageTrans_LookupIntoBufferCat (buffer, &NCConfig_global.messages, 
			"ISDNCountry", NULL, NULL, NULL, NULL);

		for (i = 0; i < sizeof(countries) / sizeof(countries[0]); i++) {
			char string[16];

			sprintf (string, "%i", countries[i].id);

			Desk_MessageTrans_LookupIntoBufferCat (buffer, &NCConfig_global.messages, 
				"ISDNCountryItem",
				isdn.country == countries[i].id ? "selected" : "",
				string, countries[i].name, NULL);
		}

		Desk_MessageTrans_LookupIntoBufferCat (buffer, &NCConfig_global.messages, 
			"ISDNOperatorFooter", NULL, NULL, NULL, NULL);
	}
	Desk_Error2_Catch {
		Desk_DeskMem_BufferFree (buffer);
		Desk_Error2_ReThrow ();
	}
	Desk_Error2_EndCatch

}

/*  Create in 'buffer' the HTML for the dialler settings section of the ISDN settings menu,
 *  which is common to all ISDN network variants.
 */
static void NCConfig_ISDN_CreateModemSettings (Desk_deskmem_buffer *buffer)
{
	Desk_Debug_Printf( Desk_error_PLACE "NCConfig_ISDN_CreateModemSettings called\n");
	
	Desk_Error2_Try	{
		NCConfig_Modem_CMOS	modem;
		char			prefix_string[ 4] = "";
		char			localcode[ 7] = "";
		
		NCConfig_Modem_ReadCMOS( &modem);
		Desk_Debug_Printf( Desk_error_PLACE "NCConfig_ISDN_CreateModemSettings, just read modem CMOS, prefix=%i\n", modem.flags.data.prefix);
		if ( (modem.flags.data.prefix>=1) && (modem.flags.data.prefix<11))	sprintf( prefix_string, "%i", modem.flags.data.prefix-1);
		if ( modem.flags.data.prefix==prefix_STAR)			strcpy( prefix_string, "*");
		if ( modem.flags.data.prefix==prefix_HASH)			strcpy( prefix_string, "#");
		Desk_Debug_Printf( Desk_error_PLACE "NCConfig_ISDN_CreateModemSettings, prefix_string='%s'\n", prefix_string);
		
			{
			int	digit;
			for ( digit=0; digit<6; digit++)	{
				if ( modem.localcode[digit])	localcode[digit] = '0' + modem.localcode[digit]-1;
				else				localcode[digit] = 0;
				}
			}
		
		Desk_Debug_Printf( Desk_error_PLACE "NCConfig_ISDN_CreateModemSettings, prefix_string='%s'\n", prefix_string);
		
		Desk_MessageTrans_LookupIntoBufferCat (buffer, &NCConfig_global.messages, "ISDNDial1",
			localcode,
			prefix_string,
			NULL,
			NULL
			);
		
		
		{
			int	i;
			int	standardtimes[] = { 3, 5, 10, 15, 30, -1};
			
			for ( i=0; standardtimes[i]!=-1; i++)	{
				char	timestring[ 16];
				sprintf( timestring, "%i", standardtimes[i]);
				Desk_MessageTrans_LookupIntoBufferCat( 
					buffer, &NCConfig_global.messages, "ISDNDisconnectItem",
					(modem.disconnecttime==standardtimes[i]) ? "selected" : "",
					timestring,
					timestring,
					NULL
					);
				}
			
			Desk_MessageTrans_LookupIntoBufferCat( 
				buffer, &NCConfig_global.messages, "ISDNDisconnectItemNever",
				(modem.disconnecttime==0) ? "selected" : "",
				NULL, NULL, NULL
				);
			
		}
		
		Desk_MessageTrans_LookupIntoBufferCat( buffer, &NCConfig_global.messages, "ISDNDial2", NULL, NULL, NULL, NULL);
		
	}
	
	Desk_Error2_Catch	{
		Desk_DeskMem_BufferFree( buffer);
		Desk_Error2_ReThrow();
		}
	Desk_Error2_EndCatch

}

static void NCConfig_ISDN_NextPage (HTML_Args_variablelist *vars, Desk_deskmem_buffer* buffer)
{
	Desk_Error2_Try	{

		HTML_Args_variable 	*arg_operator = HTML_Args_FindVar( vars, "operator", Desk_bool_TRUE);
	   	HTML_Args_variable 	*arg_country = HTML_Args_FindVar(vars, "country", Desk_bool_TRUE);
		NCConfig_ISDN_CMOS	isdn;
		
		NCConfig_ISDN_ReadCMOS (&isdn);

		Desk_MessageTrans_LookupIntoBuffer (
			buffer, &NCConfig_global.messages, 
			"ISDNHeader", arg_operator->value, arg_country->value, NULL, NULL
		);
		
		NCConfig_ISDN_CreateModemSettings (buffer);	

		Desk_MessageTrans_LookupIntoBufferCat (
			buffer, &NCConfig_global.messages, "ISDNLocal",
			isdn.directory_number, isdn.subaddress, NULL, NULL
		);

		Desk_MessageTrans_LookupIntoBufferCat (buffer, &NCConfig_global.messages, 
			"ISDNFooter", NULL, NULL, NULL, NULL);

	}		
	Desk_Error2_Catch	{
		Desk_DeskMem_BufferFree( buffer);
		Desk_Error2_ReThrow();
		}
	Desk_Error2_EndCatch
}

void NCConfig_CreateAppPage_ISDN (HTML_Args_variablelist *vars, Desk_deskmem_buffer *buffer)
{
	HTML_Args_variable *arg_operator = HTML_Args_FindPossibleVar( vars, "operator", Desk_bool_TRUE);

	Desk_Debug_Printf( Desk_error_PLACE "NCConfig_CreateAppPage_ISDN called\n");

	if (arg_operator == NULL)
		NCConfig_ISDN_FirstPage (buffer);
	else
		NCConfig_ISDN_NextPage (vars, buffer);	
}
