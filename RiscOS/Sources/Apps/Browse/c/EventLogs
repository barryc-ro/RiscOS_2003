/**************************************************************/
/* File:    EventLogs.c                                       */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Handle the Event Logs dialogue box and the event  */
/*          log display windows.                              */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 08-Jun-1999 (ADH): Created.                       */
/*          25-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>
#include <tboxlibs/ScrollList.h>
#include "TextArea.h"

#include "Global.h"
#include "Utils.h"

#include "Browser.h"
#include "Handlers.h"
#include "TGutils.h"
#include "URLutils.h"

#include "EventLogs.h"

/* Local definitions; default type is 1 for log by URLs, 0 for by    */
/* browser windows, and default display is 1 for titles, 0 for URLs. */
/* The last item enables (1) or disables (0) the master log.         */

#define EventLogs_DefaultList    (EventLogs_Log_HTTPMessages | EventLogs_Log_ScriptInformation)
#define EventLogs_DefaultType    (1)
#define EventLogs_DefaultDisplay (1)
#define EventLogs_DefaultMaster  (0)

#define EventLogs_TimeFormat     ("%DY %M3 %CE%YR %24:%MI:%SE.%CS %TZ")

#define EventLogs_FontName       ("Corpus.Medium")
#define EventLogs_FontWidth      (8  * 16)
#define EventLogs_FontHeight     (10 * 16)

/* Local statics */

static ObjectId        window_id  = NULL_ObjectId;
static eventlogs_log * log_head   = NULL;

static unsigned int    whattolog    = EventLogs_DefaultList;
static unsigned int    logbyurl     = EventLogs_DefaultType;
static unsigned int    showtitles   = EventLogs_DefaultDisplay;
static unsigned int    enablemaster = EventLogs_DefaultMaster;

static eventlogs_log   master       = {
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        -1,
                                        NULL_ObjectId,
                                        EventLogs_Log_Flags_Master
                                      };

/* Static function prototypes */

static int               eventlogs_hidden                   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               eventlogs_new_log_list             (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               eventlogs_new_log_type             (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               eventlogs_new_log_display          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static _kernel_oserror * eventlogs_clear_log                (eventlogs_log * which);
static int               eventlogs_clear_logs               (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               eventlogs_dismiss                  (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               eventlogs_close_all                (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               eventlogs_open_master              (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               eventlogs_scrolllist_event_handler (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static _kernel_oserror * eventlogs_refresh_list             (ObjectId self);
static _kernel_oserror * eventlogs_update_log_structure     (browser_data * b, int count);
static _kernel_oserror * eventlogs_log_message_known        (eventlogs_log * found, browser_data * b, eventlogs_type type, const char * message);

static int               eventlog_ok                        (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               eventlog_hidden                    (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               eventlog_empty                     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               eventlog_browser                   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/**************************************************************/
/* eventlogs_what_to_log()                                    */
/*                                                            */
/* Whilst eventlogs_log_item filters out things that we don't */
/* want to log, this informational call may be useful to some */
/* external routines that want to know what kind of filtering */
/* is being applied anyway.                                   */
/*                                                            */
/* Note that to conserve memory usage we take the decision to */
/* implement log-time filtering and no display-time           */
/* filtering.                                                 */
/*                                                            */
/* Returns:    An unsigned int with bits set according to the */
/*             definitions in EventLogs.h.                    */
/**************************************************************/

unsigned int eventlogs_what_to_log(void)
{
  return whattolog;
}

/**************************************************************/
/* eventlogs_log_by_url()                                     */
/*                                                            */
/* Are we logging by URL or browser window?                   */
/*                                                            */
/* Returns:    1 if logging by URL, else 0.                   */
/**************************************************************/

unsigned int eventlogs_log_by_url(void)
{
  return logbyurl;
}

/**************************************************************/
/* eventlogs_show_titles()                                    */
/*                                                            */
/* Are we displaying URLs or page titles?                     */
/*                                                            */
/* Returns:    1 if showing titles, else 0.                   */
/**************************************************************/

unsigned int eventlogs_show_titles(void)
{
  return showtitles;
}

/**************************************************************/
/* eventlogs_to_be_shown()                                    */
/*                                                            */
/* Called when the Event Logs (control) dialogue is to be     */
/* shown.                                                     */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int eventlogs_to_be_shown(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  if (window_id == NULL_ObjectId)
  {
    /* We need to register event handlers and set up the option / radio buttons */
    /* if the window has been opened for the first time, or since last hidden   */
    /* (as opposed to re-opened when already on screen)                         */

    window_id = idb->self_id;

    ChkError(event_register_toolbox_handler   (window_id, EEventLogsHTTPMessages,      eventlogs_new_log_list,    NULL));
    ChkError(event_register_toolbox_handler   (window_id, EEventLogsSeriousErrors,     eventlogs_new_log_list,    NULL));
    ChkError(event_register_toolbox_handler   (window_id, EEventLogsMinorErrors,       eventlogs_new_log_list,    NULL));
    ChkError(event_register_toolbox_handler   (window_id, EEventLogsEnableMaster,      eventlogs_new_log_list,    NULL));

    #ifdef JAVASCRIPT
      ChkError(event_register_toolbox_handler (window_id, EEventLogsScriptInformation, eventlogs_new_log_list,    NULL));
    #endif

    ChkError(event_register_toolbox_handler   (window_id, EEventLogsPerVisitedPage,    eventlogs_new_log_type,    NULL));
    ChkError(event_register_toolbox_handler   (window_id, EEventLogsPerBrowserWindow,  eventlogs_new_log_type,    NULL));

    ChkError(event_register_toolbox_handler   (window_id, EEventLogsByPageTitle,       eventlogs_new_log_display, NULL));
    ChkError(event_register_toolbox_handler   (window_id, EEventLogsByURL,             eventlogs_new_log_display, NULL));

    ChkError(event_register_toolbox_handler   (window_id, EEventLogsClearLogs,         eventlogs_clear_logs,      NULL));
    ChkError(event_register_toolbox_handler   (window_id, EEventLogsDismiss,           eventlogs_dismiss,         NULL));
    ChkError(event_register_toolbox_handler   (window_id, EEventLogsCloseAll,          eventlogs_close_all,       NULL));
    ChkError(event_register_toolbox_handler   (window_id, EEventLogsOpenMaster,        eventlogs_open_master,     NULL));
    ChkError(event_register_toolbox_handler   (window_id, EEventLogsHidden,            eventlogs_hidden,          NULL));

    /* We need a handler for the ScrollList events to get to the Event Log windows */

    ChkError(event_register_toolbox_handler(window_id, ScrollList_Selection, eventlogs_scrolllist_event_handler, NULL));

    /* Update the various option / radio buttons */

    ChkError(optionbutton_set_state   (0, window_id, EventLogsHTTPMessages,      !!(whattolog & EventLogs_Log_HTTPMessages)));
    ChkError(optionbutton_set_state   (0, window_id, EventLogsSeriousErrors,     !!(whattolog & EventLogs_Log_SeriousErrors)));
    ChkError(optionbutton_set_state   (0, window_id, EventLogsSignificantEvents, !!(whattolog & EventLogs_Log_SignificantEvents)));

    #ifdef JAVASCRIPT
      ChkError(optionbutton_set_state (0, window_id, EventLogsScriptInformation, !!(whattolog & EventLogs_Log_ScriptInformation)));
    #endif

    ChkError(optionbutton_set_state(0, window_id, EventLogsEnableMaster, enablemaster));
    ChkError(set_gadget_state(window_id, EventLogsOpenMaster, !enablemaster));

    ChkError(radiobutton_set_state(0, window_id, EventLogsPerVisitedPage, logbyurl));
    ChkError(radiobutton_set_state(0, window_id, EventLogsByPageTitle,    showtitles));
  }

  /* Update the ScrollList whether we've been re-opened or opened anew */

  ChkError(eventlogs_refresh_list(window_id));

  return 1;
}

/**************************************************************/
/* eventlogs_hidden()                                         */
/*                                                            */
/* Called when the Event Logs (control) dialogue is hidden.   */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlogs_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  ChkError(event_deregister_toolbox_handlers_for_object(idb->self_id));

  window_id = NULL_ObjectId;

  return 1;
}

/**************************************************************/
/* eventlogs_new_log_list()                                   */
/*                                                            */
/* The state of one of the option buttons relating to what    */
/* should be logged has been changed.                         */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlogs_new_log_list(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int state;

  whattolog    = EventLogs_DefaultList;
  enablemaster = EventLogs_DefaultMaster;

  if (!optionbutton_get_state(0, idb->self_id, EventLogsHTTPMessages, &state))
  {
    if (state) whattolog |=  EventLogs_Log_HTTPMessages;
    else       whattolog &= ~EventLogs_Log_HTTPMessages;
  }

  if (!optionbutton_get_state(0, idb->self_id, EventLogsSeriousErrors, &state))
  {
    if (state) whattolog |=  EventLogs_Log_SeriousErrors;
    else       whattolog &= ~EventLogs_Log_SeriousErrors;
  }

  if (!optionbutton_get_state(0, idb->self_id, EventLogsSignificantEvents, &state))
  {
    if (state) whattolog |=  EventLogs_Log_SignificantEvents;
    else       whattolog &= ~EventLogs_Log_SignificantEvents;
  }

  #ifdef JAVASCRIPT

    if (!optionbutton_get_state(0, idb->self_id, EventLogsScriptInformation, &state))
    {
      if (state) whattolog |=  EventLogs_Log_ScriptInformation;
      else       whattolog &= ~EventLogs_Log_ScriptInformation;
    }

  #endif

  if (!optionbutton_get_state(0, idb->self_id, EventLogsEnableMaster, &state))
  {
    enablemaster = state;
    ChkError(set_gadget_state(idb->self_id, EventLogsOpenMaster, !enablemaster));
    if (!enablemaster && master.dbox) ChkError(toolbox_hide_object(0, master.dbox));
  }

  return 1;
}

/**************************************************************/
/* eventlogs_new_log_type()                                   */
/*                                                            */
/* Change whether we log per-URL or per-window.               */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlogs_new_log_type(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int state;

  logbyurl = EventLogs_DefaultType;

  if (!radiobutton_get_state(0, idb->self_id, EventLogsPerVisitedPage, &state, NULL))
  {
    if (state) logbyurl = 1;
    else       logbyurl = 0;
  }

  return 1;
}

/**************************************************************/
/* eventlogs_new_log_display()                                */
/*                                                            */
/* Change whether we show the browser list by URLs or titles. */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlogs_new_log_display(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int          state;
  unsigned int old = showtitles;

  showtitles = EventLogs_DefaultDisplay;

  if (!radiobutton_get_state(0, idb->self_id, EventLogsByPageTitle, &state, NULL))
  {
    if (state) showtitles = 1;
    else       showtitles = 0;
  }

  if (showtitles != old) ChkError(eventlogs_refresh_list(idb->self_id));

  return 1;
}

/**************************************************************/
/* eventlogs_clear_log()                                      */
/*                                                            */
/* Clear a specific log file.                                 */
/*                                                            */
/* Parameters: Pointer to an eventlogs_log struct for the log */
/*             to clear.                                      */
/**************************************************************/

static _kernel_oserror * eventlogs_clear_log(eventlogs_log * which)
{
  if (which->text) free(which->text), which->text = NULL;
  if (which->dbox != NULL_ObjectId)
  {
    RetError(textarea_set_text(0,
                               which->dbox,
                               EventLogTextArea,
                               ""));
  }

  return NULL;
}

/**************************************************************/
/* eventlogs_clear_logs()                                     */
/*                                                            */
/* Handle the Event Logs dialogue's "Clear logs" button.      */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlogs_clear_logs(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  eventlogs_log * current = log_head;

  /* Do the browser logs... */

  while (current)
  {
    ChkError(eventlogs_clear_log(current));
    current = current->next;
  }

  /* ...and the master log. */

  ChkError(eventlogs_clear_log(&master));

  return 1;
}

/**************************************************************/
/* eventlogs_dismiss()                                        */
/*                                                            */
/* Handle the Event Logs dialogue's "Dismiss" button.         */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlogs_dismiss(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  /* No special actions required right now, except perhaps always */
  /* closing regardless of mouse button clicked.                  */

  ChkError(toolbox_hide_object(0, idb->self_id));

  return 1;
}

/**************************************************************/
/* eventlogs_close_all()                                      */
/*                                                            */
/* Close all event log viewers. If Ctrl is held down at call  */
/* time, closes all browser windows too.                      */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlogs_close_all(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int ctrl;

  /* Is Ctrl held down? */

  _swix(OS_Byte,
        _INR(0,1) | _OUT(1),

        121,
        129,

        &ctrl);

  if (ctrl == 0)
  {
    eventlogs_log * current = log_head;

    /* Close all browser logs */

    while (current)
    {
      if (current->dbox != NULL_ObjectId)
      {
        ChkError(toolbox_hide_object(0, current->dbox));
      }

      current = current->next;
    }
  }
  else
  {
    browser_data * b;

    /* Close all browser windows (and, therefore, logs) */

    _swix(Hourglass_Start, _IN(0), 10);

    while (last_browser)
    {
      b = last_browser;

      while (b && b->ancestor) b = b->previous;

      if (b && !b->ancestor) handle_close_browser(0, NULL, NULL, b);
    }

    _swix(Hourglass_Off, 0);
  }

  /* Close the master log. */

  if (master.dbox != NULL_ObjectId)
  {
    ChkError(toolbox_hide_object(0, master.dbox));
  }

  return 1;
}

/**************************************************************/
/* eventlogs_open_master()                                    */
/*                                                            */
/* Open an Event Log dialogue box for the master log file.    */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int eventlogs_open_master(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  if (master.dbox == NULL_ObjectId)
  {
    ChkError(toolbox_create_object(0,
                                   "EventLog",
                                   &master.dbox));

    /* Fill the Event Log's text area with the log text */

    ChkError(textarea_set_text(0,
                               master.dbox,
                               EventLogTextArea,
                               master.text ? master.text : ""));
  }

  /* Show the object, centred */

  ChkError(toolbox_show_object(0,
                               master.dbox,
                               Toolbox_ShowObject_Centre,
                               NULL,
                               idb->self_id,
                               idb->self_component));

  return 1;
}

/**************************************************************/
/* eventlogs_scrolllist_event_handler                         */
/*                                                            */
/* Called when the ScrollList gadget raises events.           */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int eventlogs_scrolllist_event_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  ScrollListSelectionEvent * sel = (ScrollListSelectionEvent *) event;

  if (sel->flags & ScrollList_Selection_Flags_DoubleClick)
  {
    /* An item was double-clicked upon. All we can find out without searching is   */
    /* the item number or the item text; so, instead, go through the eventlogs_log */
    /* structures looking for one matching the item number (index).                */

    eventlogs_log * found = log_head;

    while (found)
    {
      if (found->index == sel->item) break;
      else found = found->next;
    }

    /* Couldn't find one? Eeek! */

    if (!found)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "There is no eventlogs_log structure for ScrollList item %d in eventlogs_scrolllist_event_handler()",
                sel->item);

        ChkError(&erb);

      #endif

      return 0;
    }

    /* We've got one; create an Event Log window for it if none exists */

    if (found->dbox == NULL_ObjectId)
    {
      ChkError(toolbox_create_object(0,
                                     "EventLog",
                                     &found->dbox));

      /* Fill the Event Log's text area with the log text */

      ChkError(textarea_set_text(0,
                                 found->dbox,
                                 EventLogTextArea,
                                 found->text ? found->text : ""));
    }

    /* (Re-)show the object, centred */

    ChkError(toolbox_show_object(0,
                                 found->dbox,
                                 Toolbox_ShowObject_Centre,
                                 NULL,
                                 idb->self_id,
                                 idb->self_component));

    return 1;
  }

  return 0;
}

/**************************************************************/
/* eventlogs_refresh_list()                                   */
/*                                                            */
/* Completely rebuild the contents of the ScrollList in the   */
/* given Event Logs dialogue box.                             */
/*                                                            */
/* We also ensure all eventlogs_log structures attached to    */
/* browsers are up to date.                                   */
/*                                                            */
/* Parameters: Object ID of the dialogue box.                 */
/**************************************************************/

static _kernel_oserror * eventlogs_refresh_list(ObjectId self)
{
  if (self != NULL_ObjectId)
  {
    browser_data * current = last_browser;
    int            count   = 0;

    char           title[Limits_Title];
    char         * text;

    RetError(tgutils_remove_all(self, EventLogsScrollList));

    /* Add items with the most recently opened browser window */
    /* at the top of the list.                                */

    while (current)
    {
      /* Ugh, page title comes from the title bar */

      if (
           !eventlogs_show_titles() ||

           window_get_title(0,
                            current->self_id,
                            title,
                            sizeof(title),
                            NULL)
         )
         *title = '\0';

      if (*title != '\0') text = title;
      else                text = browser_fetch_url(current);

      /* May have NULL if fetching nothing but no meaningful title is present */

      if (!text) text = browser_current_url(current);
      if (!text) text = "...";

      /* Proceed only if the item looks sensible */

      if (text && *text)
      {
        if (!eventlogs_update_log_structure(current, count))
        {
          RetError(scrolllist_add_item(0,
                                       self,
                                       EventLogsScrollList,
                                       text,
                                       NULL,
                                       NULL,
                                       count++));
        }
      }

      current = current->previous;
    }
  }

  return NULL;
}

/**************************************************************/
/* eventlogs_update_log_structure()                           */
/*                                                            */
/* Update the ScrollList array index counter for the          */
/* eventlogs_log structure related to the given browser. If   */
/* such a structure does not already exist, an appropriately  */
/* initialised one will be created (hence this function may   */
/* return general memory error 41 directly).                  */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the structure;                                 */
/*                                                            */
/*             New ScrollList array index value, or -1 if we  */
/*             don't know it and are just calling here to     */
/*             ensure a log structure exists for the given    */
/*             browser.                                       */
/**************************************************************/

static _kernel_oserror * eventlogs_update_log_structure(browser_data * b, int count)
{
  eventlogs_log * found = log_head;

  /* Find an entry for this browser */

  while (found)
  {
    if (found->b == b) break;
    else found = found->next;
  }

  /* If not found, create one */

  if (!found)
  {
    found = calloc(1, sizeof(eventlogs_log));
    if (!found) return make_no_memory_error(41);

    #ifdef TRACE
      malloccount += sizeof(eventlogs_log);
      dprintf(("CMal", "** malloccount (eventlogs_update_log_structure): \0211%d\0217\n",malloccount));
    #endif

    found->b     = b;
    found->text  = NULL;
    found->index = count;
    found->dbox  = NULL_ObjectId;

    found->prev  = NULL;
    found->next  = log_head;

    if (log_head) log_head->prev = found;
    log_head = found;
  }

  /* Update the ScrollList array index value */

  found->index = count;

  return NULL;
}

/**************************************************************/
/* eventlogs_update_list()                                    */
/*                                                            */
/* Update the ScrollList because a new browser is present.    */
/*                                                            */
/* Parameters: Pointer to the browser_data struct for which   */
/*             the update is to take place.                   */
/**************************************************************/

_kernel_oserror * eventlogs_update_list(browser_data * b)
{
  if (window_id == NULL_ObjectId) return eventlogs_update_log_structure(b, -1);
  else                            return eventlogs_refresh_list(window_id);
}

/**************************************************************/
/* eventlogs_log_message()                                    */
/*                                                            */
/* Log a new message.                                         */
/*                                                            */
/* Parameters: Pointer to a browser_data struct for which the */
/*             message is to be logged;                       */
/*                                                            */
/*             Type of message (as an eventlogs_type, see     */
/*             EventLogs.h);                                  */
/*                                                            */
/*             Pointer to the message string.                 */
/**************************************************************/

_kernel_oserror * eventlogs_log_message(browser_data * b, eventlogs_type type, const char * message)
{
  eventlogs_log * found = log_head;

  if (!b) return NULL;

  /* Cryptic message time... :-) */

  if (!message || !*message)
  {
    type    = eventlogs_serious_error;
    message = "!";
  }

  /* Should we filter this? */

  if (
       (
         type == eventlogs_http_message &&
         !(whattolog & EventLogs_Log_HTTPMessages)
       )
       ||
       (
         type == eventlogs_serious_error &&
         !(whattolog & EventLogs_Log_SeriousErrors)
       )
       ||
       (
         type == eventlogs_significant_event &&
         !(whattolog & EventLogs_Log_SignificantEvents)
       )
       ||
       (
         type == eventlogs_script_information &&
         !(whattolog & EventLogs_Log_ScriptInformation)
       )
     )
     return NULL;

  /* OK, find the eventlogs_log structure for this browser */

  while (found)
  {
    if (found->b == b) break;
    else found = found->next;
  }

  if (!found)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "No errorlogs_log structure found for browser %p in eventlogs_log_message()",
              b);

      return &erb;

    #else

      return NULL;

    #endif
  }

  /* Record the message */

  RetError(eventlogs_log_message_known(found, b, type, message));

  if (enablemaster) RetError(eventlogs_log_message_known(&master, b, type, message));

  /* Finished */

  return NULL;
}

/**************************************************************/
/* eventlogs_log_message_known()                              */
/*                                                            */
/* Log a new message to a known eventlogs_log structure.      */
/*                                                            */
/* Parameters: Pointer to an eventlogs_lot structure to log   */
/*             to;                                            */
/*                                                            */
/*             Pointer to a browser_data struct to which the  */
/*             message relates;                               */
/*                                                            */
/*             Type of message (as an eventlogs_type, see     */
/*             EventLogs.h);                                  */
/*                                                            */
/*             Pointer to the message string.                 */
/**************************************************************/

static _kernel_oserror * eventlogs_log_message_known(eventlogs_log * found, browser_data * b, eventlogs_type type, const char * message)
{
  char * url;
  char   full [Limits_EventLogs];
  char   time [6];
  char   data [20];

  /* Construct a full log entry */

  *time = '\3';

  RetError(_swix(OS_Word,
                 _INR(0,1),

                 14,
                 time));

  /* This two-pass approach is used as OS_Word 14 with a sub-reason code */
  /* of 0 does get the time as a string, but doesn't let us tell it how  */
  /* big the buffer is - so the SWI could potentially overrun it.        */

  RetError(_swix(OS_ConvertDateAndTime,
                 _INR(0,3),

                 time,
                 full,
                 sizeof(full),
                 EventLogs_TimeFormat));

  /* Append browser address and message type */

  sprintf(data, " %08x %08x ", (unsigned int) b, (unsigned int) type);

  if (strlen(data) + strlen(full) + 1 < sizeof(full)) strcat(full, data);

  /* Append the URL */

  url           = browser_fetch_url(b);
  if (!url) url = browser_current_url(b);
  if (!url) url = "";

  if (!strncmp(url, Internal_URL, Int_URL_Len)) url += urlutils_internal_extra(url);

  if (strlen(url) + sizeof("\"")     < sizeof(full)) strcat(full, "\"");
  if (strlen(url) + strlen(full) + 1 < sizeof(full)) strcat(full, url);
  if (strlen(url) + sizeof("\": ")   < sizeof(full)) strcat(full, "\": ");

  /* Append the actual message */

  if (strlen(message) + strlen(full) + 1 < sizeof(full)) strcat(full, message);

  /* Right, now add that to the message text in the eventlogs_log */

  if (found->text)
  {
    char * new;
    int    size, olds, news;

    olds = strlen(found->text);
    news = strlen(full);
    size = olds + news + 2;

    new  = realloc(found->text, size);

    if (!new) return make_no_memory_error(42);
    else found->text = new;

    #ifdef TRACE
      malloccount += news + 1;
      dprintf(("CMal", "** malloccount (eventlogs_log_message): \0211%d\0217\n",malloccount));
    #endif

    strcat(found->text, full);

    found->text[size - 2] = '\n';
    found->text[size - 1] = '\0';
  }
  else
  {
    int size = strlen(full) + 2;

    found->text = malloc(size);
    if (!found->text) return make_no_memory_error(42);

    #ifdef TRACE
      malloccount += size;
      dprintf(("CMal", "** malloccount (eventlogs_log_message): \0211%d\0217\n",malloccount));
    #endif

    strcpy(found->text, full);

    found->text[size - 2] = '\n';
    found->text[size - 1] = '\0';
  }

  /* If we've got an Event Log dialogue open, update it */

  if (found->dbox != NULL_ObjectId)
  {
    RetError(textarea_set_text(0,
                               found->dbox,
                               EventLogTextArea,
                               found->text));
  }

  /* If need be, call ourselves back for the master log file */

  if (b && !(found->flags & EventLogs_Log_Flags_Master)) return eventlogs_log_message(NULL, type, message);
  else                                                   return NULL;
}

/**************************************************************/
/* eventlogs_url_changed()                                    */
/*                                                            */
/* Inform the logging system that a browser window's URL has  */
/* changed.                                                   */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the changing URL;                              */
/*                                                            */
/*             1 if you believe the log text should be        */
/*             cleared, provided we're logging on a per-URL   */
/*             basis, else 0.                                 */
/**************************************************************/

_kernel_oserror * eventlogs_url_changed(browser_data * b, unsigned int ok_to_clear)
{
  eventlogs_log * found = log_head;

  /* Find the relevant eventlogs_log structure */

  while (found)
  {
    if (found->b == b) break;
    else found = found->next;
  }

  if (!found)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "No errorlogs_log structure found for browser %p in eventlogs_url_changed()",
              b);

      return &erb;

    #else

      return NULL;

    #endif
  }

  /* If we're doing per-URL logging, clear the existing text */

  if (ok_to_clear && logbyurl && found->text)
  {
    #ifdef TRACE
      malloccount -= (strlen(found->text) + 1);
      dprintf(("CMal", "** malloccount (eventlogs_browser_died): \0211%d\0217\n",malloccount));
    #endif

    free(found->text), found->text = NULL;

    if (found->dbox != NULL_ObjectId)
    {
      RetError(textarea_set_text(0,
                                 found->dbox,
                                 EventLogTextArea,
                                 ""));
    }
  }

  /* Update the ScrollList - try our best to just update the */
  /* item relating to this browser, but if anything looks    */
  /* even remotely dodgy, update the entire thing.           */

  if (found->index < 0 || window_id == NULL_ObjectId) return eventlogs_update_list(b);
  else
  {
    char   title[Limits_Title];
    char * text;

    if (
         !eventlogs_show_titles() ||

         window_get_title(0,
                          b->self_id,
                          title,
                          sizeof(title),
                          NULL)
       )
       *title = '\0';

    if (*title != '\0') text = title;
    else                text = browser_fetch_url(b);

    /* May have NULL if fetching nothing but no meaningful title is present */

    if (!text) text = browser_current_url(b);
    if (!text) text = "...";

    /* Clean up internal URLs */

    if (!strncmp(text, Internal_URL, Int_URL_Len)) text += urlutils_internal_extra(text);

    return scrolllist_set_item_text(0,
                                    window_id,
                                    EventLogsScrollList,
                                    text,
                                    found->index);
  }
}

/**************************************************************/
/* eventlogs_browser_died()                                   */
/*                                                            */
/* A browser window has died (closed). Update the lggs.       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct relevant to   */
/*             the closed window.                             */
/**************************************************************/

_kernel_oserror * eventlogs_browser_died(browser_data * b)
{
  eventlogs_log * found = log_head;

  /* Find the relevant eventlogs_log structure */

  while (found)
  {
    if (found->b == b) break;
    else found = found->next;
  }

  if (!found)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "No errorlogs_log structure found for browser %p in eventlogs_url_changed()",
              b);

      return &erb;

    #else

      return NULL;

    #endif
  }

  /* Clear the text and delete any opened Event Log window */

  if (found->text)
  {
    #ifdef TRACE
      malloccount -= (strlen(found->text) + 1);
      dprintf(("CMal", "** malloccount (eventlogs_browser_died): \0211%d\0217\n",malloccount));
    #endif

    free(found->text);
    found->text = NULL;
  }

  if (found->dbox != NULL_ObjectId)
  {
    RetError(toolbox_hide_object(0, found->dbox));
  }

  /* Unlink the item and free it */

  if (found->prev) found->prev->next = found->next;
  if (found->next) found->next->prev = found->prev;

  if (found == log_head) log_head = found->next;

  free(found);

  #ifdef TRACE
    malloccount -= sizeof(eventlogs_log);
    dprintf(("CMal", "** malloccount (eventlogs_browser_died): \0211%d\0217\n",malloccount));
  #endif

  return eventlogs_update_list(b);
}

/**************************************************************/
/* eventlog_to_be_shown()                                     */
/*                                                            */
/* Called when an Event Log (control) dialogue is to be       */
/* shown.                                                     */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int eventlog_to_be_shown(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  /* Register handlers */

  ChkError(event_register_toolbox_handler(idb->self_id, EEventLogOK,      eventlog_ok,      NULL));
  ChkError(event_register_toolbox_handler(idb->self_id, EEventLogHidden,  eventlog_hidden,  NULL));
  ChkError(event_register_toolbox_handler(idb->self_id, EEventLogEmpty,   eventlog_empty,   NULL));
  ChkError(event_register_toolbox_handler(idb->self_id, EEventLogBrowser, eventlog_browser, NULL));

  /* Set the font */

  ChkError(textarea_set_font(0,
                             idb->self_id,
                             EventLogTextArea,
                             EventLogs_FontName,
                             EventLogs_FontWidth,
                             EventLogs_FontHeight));

  /* Grey out the "Browser" button if we're the master log view */

  if (master.dbox == idb->self_id) ChkError(set_gadget_state(idb->self_id, EventLogBrowser, 1));

  return 1;
}

/**************************************************************/
/* eventlog_ok()                                              */
/*                                                            */
/* Handle an Event Log dialogue's "OK" button.                */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlog_ok(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  /* Always hide, regardless of event's source */

  ChkError(toolbox_hide_object(0, idb->self_id));

  return 1;
}

/**************************************************************/
/* eventlog_hidden()                                          */
/*                                                            */
/* Called when an Event Log (control) dialogue is hidden.     */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlog_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  eventlogs_log * found = log_head;

  /* Find the eventlogs_log structure recording this dialogue box */

  if (master.dbox == idb->self_id) found = &master;
  else
  {
    while (found)
    {
      if (found->dbox == idb->self_id) break;
      else found = found->next;
    }
  }

  /* If found, clear the dbox field. If not found - maybe the structure */
  /* was deleted, because a browser window closed? So don't complain.   */

  if (found) found->dbox = NULL_ObjectId;

  /* Deregister handlers and delete this object */

  ChkError(event_deregister_toolbox_handlers_for_object(idb->self_id));
  ChkError(toolbox_delete_object(0, idb->self_id));

  return 1;
}

/**************************************************************/
/* eventlog_empty()                                           */
/*                                                            */
/* Handle an Event Log dialogue's "Empty" button.             */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlog_empty(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  eventlogs_log * found = log_head;

  /* Find the eventlogs_log structure recording this dialogue box */

  if (master.dbox == idb->self_id) found = &master;
  else
  {
    while (found)
    {
      if (found->dbox == idb->self_id) break;
      else found = found->next;
    }
  }

  /* If we found one, clear the log */

  if (found)
  {
    ChkError(eventlogs_clear_log(found));

    return 1;
  }

  return 0;
}

/**************************************************************/
/* eventlog_browser()                                         */
/*                                                            */
/* Handle an Event Log dialogue's "Browser" button.           */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

static int eventlog_browser(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  eventlogs_log * found = log_head;

  /* Find the eventlogs_log structure recording this dialogue box */

  while (found)
  {
    if (found->dbox == idb->self_id) break;
    else found = found->next;
  }

  /* If found, reopen the window */

  #ifdef TRACE

    if (!found)
    {
      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Can't find an eventlogs_log structure for object 0x%08x in eventlog_browser",
              idb->self_id);

      ChkError(&erb);
    }

  #endif

  if (found && found->b && is_known_browser(found->b))
  {
    browser_data * ancestor = utils_ancestor(found->b);
    ComponentId    pc;
    ObjectId       po;

    ChkError(toolbox_get_parent(0,
                                ancestor->self_id,
                                &po,
                                &pc));

    ChkError(toolbox_show_object(0,
                                 ancestor->self_id,
                                 Toolbox_ShowObject_Centre,
                                 NULL,
                                 po,
                                 pc));

    return 1;
  }

  return 0;
}

/**************************************************************/
/* eventlogs_find_from_id()                                   */
/*                                                            */
/* Return an eventlogs_log struct with a 'dbox' entry equal   */
/* to the given object ID, or NULL if none exists.            */
/*                                                            */
/*                                                            */
/* Parameters: The object ID to find.                         */
/*                                                            */
/* Returns:    Pointer to the corresponding eventlogs_log, or */
/*             NULL if no match is found.                     */
/**************************************************************/

const eventlogs_log * eventlogs_find_from_id(ObjectId id)
{
  eventlogs_log * current = log_head;

  if (master.dbox == id) return &master;

  while (current)
  {
    if (current->dbox == id) return current;
    else current = current->next;
  }

  return NULL;
}
