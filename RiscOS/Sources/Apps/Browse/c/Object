/***************************************************/
/* File   : Object.c                               */
/*                                                 */
/* Purpose: Handling OBJECT, APPLET and EMBED.     */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 05-Oct-97: Created.                    */
/***************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "swis.h"
#include "flex.h"

#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "toolbox.h"

#include "svcprint.h"
#include "Global.h"
#include "FromROSLib.h"
#include "Utils.h"

#include "Browser.h"
#include "ChoiceDefs.h"
#include "Fetch.h" /* (Which itself includes URLstat.h) */
#include "FetchHTML.h"
#include "Filetypes.h"
#include "Images.h"
#include "Memory.h"
#include "MimeMap.h"
#include "MiscDefs.h"
#include "PlugIn.h"
#include "Redraw.h"
#include "Reformat.h"
#include "TokenUtils.h"
#include "Toolbars.h"
#include "URLveneer.h"

#include "Object.h"

/* Static function prototypes */

static int               object_get_token_object    (browser_data * b, HStream * t);
static _kernel_oserror * object_get_object_size     (browser_data * b, int object, BBox * size);
static int               object_get_object_position (browser_data * b, int object, int * x, int * y);
static _kernel_oserror * object_get_object_plugin   (browser_data * b, int object, unsigned int * plugin_instance, unsigned int * plugin_task);
static _kernel_oserror * object_set_object_plugin   (browser_data * b, int object, unsigned int plugin_instance, unsigned int plugin_task);

/*************************************************/
/* object_new_object()                           */
/*                                               */
/* Adds a structure for a new Object to a        */
/* browser's array of Objects.                   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             to add to;                        */
/*                                               */
/*             Pointer to a token representing   */
/*             the Object (OBJECT, EMBED or      */
/*             APPLET tag).                      */
/*************************************************/

_kernel_oserror * object_new_object(browser_data * b, HStream * t)
{
  _kernel_oserror * e;
  const char      * data;
  const char      * type;

  /* If this isn't an Object token, do nothing (well, */
  /* complain about it in TRACE builds).              */

  if (!t || t->tagno != TAG_OBJECT)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Token %08x passed to object_new_object does not represent an OBJECT, APPLET or EMBED tag",
              (int) t);

      return &erb;

    #endif

    return NULL;
  }

  /* Allocate memory for the item */

  RetError(memory_set_chunk_size(b,
                                 NULL,
                                 CK_OBJB,
                                 (b->nobjects + 1) * sizeof(object_info)));

  /* Fill in the new item */

  b->odata[b->nobjects].plugin_instance_handle  = 0;
  b->odata[b->nobjects].plugin_task_handle      = 0;
  b->odata[b->nobjects].token                   = t;

  /* Until this is seen by the user, open it off-screen to avoid */
  /* having to send out lots of reposition calls during the main */
  /* page reformat.                                              */

  b->odata[b->nobjects].x                       = -1;
  b->odata[b->nobjects].y                       = -1;

  /* Set up initial flags values */

  b->odata[b->nobjects].isimage                 = 0;
  b->odata[b->nobjects].isplugin                = 0;
  b->odata[b->nobjects].broadcast_sent          = 0;

  /* Finally, increment the objects counter */

  b->nobjects++;

  /* Now deal with data types we can handle inline */

  data = HtmlOBJECTdata(t);
  type = HtmlOBJECTtype(t);

  if (data && *data && type && *type)
  {
    int filetype;

    if (mimemap_mime_to_riscos(type, &filetype)) filetype = FileType_DATA;

    /* Is it an image we can handle? */

    if (
         filetype == FileType_PNG  ||
         filetype == FileType_GIF  ||
         filetype == FileType_JPEG ||
         filetype == FileType_TIFF ||
         filetype == FileType_XBM  ||
         filetype == FileType_BMP
       )
    {
      const char * current;
      const char * newdata;

      /* Must relativise the data URL... */

      current = browser_fetch_url(b);
      if (!current) current = browser_current_url(b);

      if (current)
      {
        newdata = HtmlRelativiseURL(current, data, t);

        if (newdata)
        {
          /* If we've managed all that, call image_new_image */

          RetError(image_new_image(b,
                                   newdata,
                                   t,
                                   0));

          b->odata[b->nobjects - 1].isimage = 1;

          return NULL;
        }
      }
    }
  }

  /* Deal with external objects */

  else
  {
    data = HtmlOBJECTclassid(t);
    type = HtmlOBJECTcodetype(t);

    if (data && type) b->odata[b->nobjects - 1].isplugin = 1;
  }

  return NULL;
}

/*************************************************/
/* object_discard()                              */
/*                                               */
/* Discards all Objects held by a given browser. */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Objects.          */
/*************************************************/

_kernel_oserror * object_discard(browser_data * b)
{
  _kernel_oserror * e = NULL;
  _kernel_oserror * local;
  int               i;

  /* Close down any Plug-Ins */

  for (i = 0; i < b->nobjects; i++)
  {
    if (
         b->odata[i].isplugin       &&
         b->odata[i].broadcast_sent &&
         b->odata[i].plugin_task_handle
       )
    {
      e = plugin_send_plugin_close(b,
                                   b->odata[i].plugin_instance_handle,
                                   b->odata[i].plugin_task_handle);
    }
  }

  /* Only set 'e' from the queue flush if the above call didn't */
  /* generate an error.                                         */

  local = plugin_flush_queue(b, 1);
  if (!e) e = local;

  /* Remove the Objects themselves. */

  b->nobjects = 0;

  memory_set_chunk_size(b, NULL, CK_OBJB, 0);

  return e;
}

/*************************************************/
/* object_get_token_object()                     */
/*                                               */
/* Return the number of the Object represented   */
/* in the given browser by the given token.      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to a token representing   */
/*             the Object (OBJECT, EMBED or      */
/*             APPLET tag).                      */
/*                                               */
/* Returns:    Number of the Object from 0 to    */
/*             number of Objects minus 1, or -1  */
/*             if the Object cannot be found.    */
/*************************************************/

static int object_get_token_object(browser_data * b, HStream * t)
{
  int found = -1;
  int i;

  /* If this isn't an Object token, do nothing (well, */
  /* complain about it in TRACE builds).              */

  if (!t || t->tagno != TAG_OBJECT)
  {
    #ifdef TRACE

      if (t->tagno != TAG_OBJECT)
      {
        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Token %08x passed to object_get_token_object does not represent an OBJECT, APPLET or EMBED tag",
                (int) t);

        show_error_ret(&erb);
      }

    #endif

    return -1;
  }

  /* Otherwise, try to find the item */

  for (i = 0; i < b->nobjects; i++)
  {
    if (b->odata[i].token == t)
    {
      found = i;
      break;
    }
  }

  return found;
}

/*************************************************/
/* object_get_object_size()                      */
/*                                               */
/* Returns the size of a given Object.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             to add to;                        */
/*                                               */
/*             Number of the Object, from 0 to   */
/*             number of Objects minus 1;        */
/*                                               */
/*             Pointer to a BBox, in which the   */
/*             size of the Object will be        */
/*             written.                          */
/*************************************************/

static _kernel_oserror * object_get_object_size(browser_data * b, int object, BBox * size)
{
  /* Can't do anything without a bounding box! */

  if (!size)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;
      strcpy(erb.errmess, "Null bounding box pointer passed to object_get_object_size");
      return &erb;

    #endif

    return NULL;
  }

  /* Fill in zeros to start with */

  size->xmin = size->ymin = 0;
  size->xmax = size->ymax = 0;

  /* Is this a valid object number? */

  if (object < 0 || object >= b->nobjects)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid object number %d for passed to object_get_object_size (browser %08x, nobjects = %d)",
              object,
              (int) b,
              b->nobjects);

      return &erb;

    #endif

    return NULL;
  }

  /* If this is an image, return through the image sizing routines */

  if (b->odata[object].isimage) return image_get_token_image_size(b,
                                                                  b->odata[object].token,
                                                                  size);

  /* Find its size */

  {
    int       w, h;
    int       available_w = redraw_display_width (b, b->cell);
    int       available_h = redraw_display_height(b, b->cell);
    HStream * tp          = b->odata[object].token;

    /* Deal with % specifiers as well as pixels */

    if (OBJECT_HAS_WIDTH(tp))
    {
      switch (OBJECT_WIDTH_UNITS(tp))
      {
        default:
        case UNITS_PIXELS:  w = OBJECT_WIDTH(tp) * 2; break;
        case UNITS_PERCENT: w = available_w * OBJECT_WIDTH(tp) / 100; break;
      }
    }
    else w = 0;

    if (OBJECT_HAS_HEIGHT(tp))
    {
      switch (OBJECT_HEIGHT_UNITS(tp))
      {
        default:
        case UNITS_PIXELS:  h = OBJECT_HEIGHT(tp) * 2; break;
        case UNITS_PERCENT: h = available_h * OBJECT_HEIGHT(tp) / 100; break;
      }
    }
    else h = 0;

    size->xmax = w;
    size->ymax = h;
  }

  /* Don't allow zero in any direction */

  if (size->xmax == 0 || size->ymax == 0)
  {
    const char * text = HtmlOBJECTstandby(b->odata[object].token);

    reformat_get_placeholder_size(b, b->odata[object].token, text, size);
  }

  return NULL;
}

/*************************************************/
/* object_get_token_object_size()                */
/*                                               */
/* Returns the size of a given Object.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to a token representing   */
/*             the Object (OBJECT, EMBED or      */
/*             APPLET tag);                      */
/*                                               */
/*             Pointer to a BBox, in which the   */
/*             size of the Object will be        */
/*             written.                          */
/*************************************************/

_kernel_oserror * object_get_token_object_size(browser_data * b, HStream * t, BBox * size)
{
  return object_get_object_size(b, object_get_token_object(b, t), size);
}

/*************************************************/
/* object_get_object_position()                  */
/*                                               */
/* Returns the x and y fields of the object_info */
/* structure for a given Object.                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Number of the Object;             */
/*                                               */
/*             Pointer to an int, in which the   */
/*             X coordinate is returned;         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Y coordinate is returned.         */
/*                                               */
/* Returns:    1 if the object number is invalid */
/*             or 0 for success.                 */
/*                                               */
/* Assumes:    Neither pointer is NULL.          */
/*************************************************/

static int object_get_object_position(browser_data * b, int object, int * x, int * y)
{
  if (object < 0 || object >= b->nobjects) return 1;

  *x = b->odata[object].x;
  *y = b->odata[object].y;

  return 0;
}

/*************************************************/
/* object_get_token_object_position()            */
/*                                               */
/* Returns the x and y fields of the object_info */
/* structure for a given Object.                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object;                       */
/*                                               */
/*             Pointer to an int, in which the   */
/*             X coordinate is returned;         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Y coordinate is returned.         */
/*                                               */
/* Returns:    1 if the object could not be      */
/*             found from the given token, or 0  */
/*             for success.                      */
/*                                               */
/* Assumes:    Neither pointer is NULL.          */
/*************************************************/

int object_get_token_object_position(browser_data * b, HStream * t, int * x, int * y)
{
  int object = object_get_token_object(b, t);

  return object_get_object_position(b, object, x, y);
}

/*************************************************/
/* object_set_token_object_position()            */
/*                                               */
/* Sets the x and y fields of the object_info    */
/* structure for a given Object, so that it may  */
/* be [partially] plotted during a fetch.        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object;                       */
/*                                               */
/*             X coordinate (window coords);     */
/*                                               */
/*             Y coordinate (window coords).     */
/*                                               */
/* Returns:    Number of the Object that was     */
/*             changed, or -1 if none could be   */
/*             found for the given token.        */
/*************************************************/

int object_set_token_object_position(browser_data * b, HStream * t, int x, int y)
{
  int object = object_get_token_object(b, t);

  #ifdef TRACE
    if (tl & (1u<<30))
    {
      char debugbuf[1024];
      sprintf(debugbuf,"object_set_token_object_positon: Called for %p, %p at %d, %d",b,t,x,y);
      Printf("%s\n",debugbuf);
    }
  #endif

  /* If an object was found, set the x and y coordinates */

  if (object >= 0)
  {
    int oldx, oldy;

    oldx = b->odata[object].x;
    oldy = b->odata[object].y;

    /* *Don't* invalidate x and y positions for Objects; this causes */
    /* too many reshape messages for some PlugIns and can lead to    */
    /* items left with out-of-date position information.             */
    /*                                                               */
    /* Objects are initialised to be in an invalidated position, of  */
    /* course, so still need to check for that later in the code.    */

    if (x != -1 && y != -1)
    {
      b->odata[object].x = x;
      b->odata[object].y = y;
    }

    /* If this is is acting as an image, need to update */
    /* the image structure too.                         */

    if (b->odata[object].isimage) image_set_token_image_position(b, t, x, y);

    /* If this item is a Plug-In, this could be the first time we've */
    /* known for sure what position the item should be plotted at;   */
    /* pr we may want to tell the Plug-In to move to a new position. */

    if (b->odata[object].isplugin)
    {
      BBox position;

      #ifdef TRACE
        if (tl & (1u<<30)) Printf("object_set_token_object_positon: Is Plug-In\n");
      #endif

      show_error_ret(object_get_object_size(b, object, &position));

      /* If this is the first time we've tried to set a position for */
      /* the Object and a broadcast to start up an associated        */
      /* Plug-In has not yet been sent, add the Plug-In to the       */
      /* 'ready to launch' queue.                                    */

      if (!b->odata[object].broadcast_sent)
      {
        int start_now = 0;

        if (x < 0)
        {
          /* Object position is invalid, so hide the Plug-In by moving */
          /* it off the top of the work area.                          */

          position.xmax = (position.xmax - position.xmin);
          position.xmin = 0;
          position.ymax = (position.ymax - position.ymin) + 0x1000; /* 0x1000 to be (very) safe */
          position.ymin = 0x1000;

          /* This call will be done by the reformatter, as soon as it    */
          /* sees the Object item (the redraw routines set the position, */
          /* the reformatter invalidates it).                            */
          /*                                                             */
          /* So only start the Plug-In if Choices say to do so ASAP.     */

          if (choices.plugin_control == Choices_PlugIns_ASAP && choices.support_object) start_now = 1;

        }
        else
        {
          /* Object position is valid, we can place it in the right position initially */

          position.xmin += x;
          position.ymin += y;
          position.xmax += x;
          position.ymax += y;

          if (choices.plugin_control != Choices_PlugIns_Never && choices.support_object) start_now = 1;
        }

        if (start_now)
        {
          b->odata[object].broadcast_sent = 1; /* Don't try over and over if the first gives an error */

          #ifdef TRACE
            if (tl & (1u<<30)) Printf("object_set_token_object_positon: Starting Plug-In\n");
          #endif

          show_error_ret(plugin_add_queue_item(b, t, &position));
        }

        #ifdef TRACE

          else if (tl & (1u<<30)) Printf("object_set_token_object_position: Choices say not to start Plug-In yet\n");

        #endif
      }

      /* If the Plug-In has been started, and the position of the Object */
      /* has changed, tell the Plug-In to move.                          */

      else if (
                (
                  oldx != x ||
                  oldy != y
                )
                && b->odata[object].plugin_task_handle
              )
      {
        if (x < 0)
        {
          /* Object position is invalid */

          position.xmax = (position.xmax - position.xmin);
          position.xmin = 0;
          position.ymax = (position.ymax - position.ymin) + 0x1000; /* 0x1000 to be (very) safe */
          position.ymax = 0x1000;
        }
        else
        {
          /* Object position has been updated */

          position.xmin += x;
          position.ymin += y;
          position.xmax += x;
          position.ymax += y;
        }

        /* Send the reshape message */

        #ifdef TRACE
          if (tl & (1u<<30)) Printf("object_set_token_object_positon: Moving Plug-In\n");
        #endif

        show_error_ret(plugin_send_original_plugin_reshape(b,
                                                           b->odata[object].plugin_instance_handle,
                                                           b->odata[object].plugin_task_handle,
                                                           &position));
      }
    }
  }

  #ifdef TRACE
    if (tl & (1u<<30)) Printf("object_set_token_object_positon: Successful, returning Object number %d\n",object);
  #endif

  return object;
}

/*************************************************/
/* object_get_token_object_box()                 */
/*                                               */
/* Returns a bounding box filled in with parent  */
/* window work area coordinates for a given      */
/* Object.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object;                       */
/*                                               */
/*             Pointer to a BBox to return the   */
/*             work area coordinates describing  */
/*             the Object's size.                */
/*                                               */
/* Returns:    1 for failure, 0 for success.     */
/*************************************************/

int object_get_token_object_box(browser_data * b, HStream * t, BBox * box)
{
  int object = object_get_token_object(b, t);
  int x, y;

  if (object < 0 || object >= b->nobjects || !box) return 1;

  /* Get the Object bounding box */

  if (object_get_object_size(b, object, box)) return 1;

  /* Get the Object position */

  if (object_get_object_position(b, object, &x, &y)) return 1;

  /* Return if the Object position is invalidated at the moment */

  if (x < 0) return 1;

  /* Otherwise add the coordinates */

  box->xmin += x;
  box->ymin += y;
  box->xmax += x;
  box->ymax += y;

  return 0;
}

/*************************************************/
/* object_get_object_plugin()                    */
/*                                               */
/* Returns details of any Plug-In associated     */
/* with a given Object (referenced by number).   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Number of the Object;             */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Plug-In instance handle will be   */
/*             written;                          */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Plug-In task handle will be       */
/*             written, or 0 if the Object       */
/*             does not have an associated       */
/*             Plug-In or can't be found.        */
/*                                               */
/* Assumes:    Either pointer may be NULL.       */
/*************************************************/

static _kernel_oserror * object_get_object_plugin(browser_data * b, int object, unsigned int * plugin_instance, unsigned int * plugin_task)
{
  /* Fill in zeros to start with */

  if (plugin_instance) *plugin_instance = 0;
  if (plugin_task)     *plugin_task     = 0;

  /* Is this a valid object number? */

  if (object < 0 || object >= b->nobjects)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid object number %d passed to object_get_token_object_plugin (browser %08x, nobjects = %d)",
              object,
              (int) b,
              b->nobjects);

      return &erb;

    #endif

    return NULL;
  }

  /* If not associated with a Plug-In, exit */

  if (!b->odata[object].isplugin) return NULL;

  /* Otherwise, return the details */

  if (plugin_instance) *plugin_instance = b->odata[object].plugin_instance_handle;
  if (plugin_task)     *plugin_task     = b->odata[object].plugin_task_handle;

  /* Finished */

  return NULL;
}

/*************************************************/
/* object_get_token_object_plugin()              */
/*                                               */
/* Returns details of any Plug-In associated     */
/* with a given Object (referenced by token).    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object;                       */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Plug-In instance handle will be   */
/*             written;                          */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Plug-In task handle will be       */
/*             written, or 0 if the Object       */
/*             does not have an associated       */
/*             Plug-In or can't be found.        */
/*                                               */
/* Assumes:    Either pointer may be NULL.       */
/*************************************************/

_kernel_oserror * object_get_token_object_plugin(browser_data * b, HStream * t, unsigned int * plugin_instance, unsigned int * plugin_task)
{
  return object_get_object_plugin(b,
                                  object_get_token_object(b, t),
                                  plugin_instance,
                                  plugin_task);
}

/*************************************************/
/* object_set_object_plugin()                    */
/*                                               */
/* Sets details of any Plug-In associated with   */
/* a given Object (referenced by number).        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Number of the Object;             */
/*                                               */
/*             Plug-In instance handle to set;   */
/*                                               */
/*             Plug-In task handle to set.       */
/*                                               */
/* Assumes:    Either pointer may be NULL.       */
/*************************************************/

static _kernel_oserror * object_set_object_plugin(browser_data * b, int object, unsigned int plugin_instance, unsigned int plugin_task)
{
  /* Is this a valid object number? */

  if (object < 0 || object >= b->nobjects)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid object number %d for passed to object_set_token_object_plugin (browser %08x, nobjects = %d)",
              object,
              (int) b,
              b->nobjects);

      return &erb;

    #endif

    return NULL;
  }

  /* If not associated with a Plug-In, exit */

  if (!b->odata[object].isplugin) return NULL;

  /* Otherwise, set the details */

  b->odata[object].plugin_instance_handle = plugin_instance;
  b->odata[object].plugin_task_handle     = plugin_task;

  /* Finished */

  return NULL;
}

/*************************************************/
/* object_set_token_object_plugin()              */
/*                                               */
/* Sets details of any Plug-In associated with   */
/* a given Object (referenced by token).         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object - usually  */
/*             set as the browser instance       */
/*             handle for the Plug-In, so cast   */
/*             as an int;                        */
/*                                               */
/*             Pointer to the token representing */
/*             the Object (usually have to       */
/*             remember this when the initial    */
/*             Message_PlugIn_Open is sent);     */
/*                                               */
/*             Plug-In instance handle to set;   */
/*                                               */
/*             Plug-In task handle to set.       */
/*                                               */
/* Assumes:    Either pointer may be NULL.       */
/*************************************************/

_kernel_oserror * object_set_token_object_plugin(unsigned int browser_instance, HStream * t, unsigned int plugin_instance, unsigned int plugin_task)
{
  browser_data * b = (browser_data *) browser_instance;

  return object_set_object_plugin(b,
                                  object_get_token_object(b, t),
                                  plugin_instance,
                                  plugin_task);
}

/*************************************************/
/* object_redraw()                               */
/*                                               */
/* Does a high level redraw of an Object, using  */
/* an outline to show where the Object should be */
/* if it isn't plotted by some other method.     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the Object;           */
/*                                               */
/*             Pointer to a RedrawWindowBlock    */
/*             struct which holds information    */
/*             about the current redraw session; */
/*                                               */
/*             Address of the token representing */
/*             the OBJECT, APPLET or EMBED tag;  */
/*                                               */
/*             The X offset in window coords (so */
/*             OS units) of the left hand edge   */
/*             of the Object;                    */
/*                                               */
/*             The Y offset in window coords (so */
/*             OS units) of the bottom edge of   */
/*             the Object.                       */
/*************************************************/

_kernel_oserror * object_redraw(browser_data * b, WimpRedrawWindowBlock * r, HStream * token, int x, int y)
{
  _kernel_oserror * e       = NULL;
  int               object  = object_get_token_object(b, token);
  int               plotted = 0;

  if (b->odata[object].isimage)
  {
    e = image_redraw(b, r, token, x, y);
    if (!e) plotted = 1;
  }

  if (!plotted)
  {
    /* Plot a placeholder */

    BBox box;

    object_get_object_size(b, object, &box);

    box.xmin += x;
    box.ymin += y;
    box.xmax += x - box.xmin;
    box.ymax += y - box.ymin;

    box.xmin &= ~(wimpt_dx() - 1);
    box.ymin &= ~(wimpt_dy() - 1);

    redraw_draw_placeholder(b,
                            r,
                            &box,
                            token,
                            HtmlOBJECTstandby(token));
  }

  return e;
}

/*************************************************/
/* object_token_is_image()                       */
/*                                               */
/* Finds out whether an Object is acting as an   */
/* an inline image or not.                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the object;           */
/*                                               */
/*             Pointer to the token representing */
/*             the Object.                       */
/*                                               */
/* Returns:    1 if the Object is acting as an   */
/*             inline image, else 0.             */
/*************************************************/

int object_token_is_image(browser_data * b, HStream * t)
{
  int object = object_get_token_object(b, t);

  if (object < 0 || object >= b->nobjects) return 0;
  else                                     return !!b->odata[object].isimage;
}
