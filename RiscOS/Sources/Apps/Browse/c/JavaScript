/***************************************************/
/* File   : JavaScript.c                           */
/*                                                 */
/* Purpose: JavaScript support.                    */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 24-Jul-97: Created.                    */
/***************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "swis.h"

#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "svcprint.h"
#include "Global.h"
#include "Utils.h"

#include "Browser.h"
#include "FetchPage.h"
#include "Filetypes.h"
#include "Frames.h"
#include "History.h"
#include "LineOne.h"
#include "Multiuser.h"
#include "Protocols.h"
#include "Save.h"
#include "Windows.h"
#include "URLutils.h"

#include "JavaScript.h"

#ifdef JAVASCRIPT

  #include "JSconsts.h"
  #include "JSwindow.h"

  /* Local compilation options */

  #define BRANCH_CALLBACK_GC_MASK  0
  #define BRANCH_CALLBACK_LED_MASK 63

  #undef  ATTEMPT_JS_POLL

  /* Static function prototypes */

  static JSBool PR_CALLBACK   javascript_watchdog           (JSContext * cx, JSScript * script);
  static void                 javascript_error              (JSContext * cx, const char * message, JSErrorReport * report);

  /* Other local statics */

  static unsigned int        watchdog_counter;
  static unsigned int        watchdog_start;
  static unsigned int        watchdog_leds;

  static browser_data      * script_browser = NULL;
  static javascript_source   script_source  = JavaScript_Source_Unknown;
  static char              * script_write_p = NULL;
  static int                 script_write_l = 0;

  static int                 source_set     = 0;
  static int                 doc_write_used = 0;
  static int                 proceed        = 0;

  static browser_data      * pending_b      = NULL;
  static char              * pending_url    = NULL;
  static int                 pending_record = 0;
  static int                 pending_stop   = 0;

#endif

/*************************************************/
/* javascript_body_onload()                      */
/*                                               */
/* When a page has finished fetching the main    */
/* page data, a BODY tag may specify some        */
/* JavaScript action. This functon should be     */
/* called to carry out that action.              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             with a filled in 'onload' field   */
/*             describing the contents of the    */
/*             onLoad command in the HTML.       */
/*************************************************/

_kernel_oserror * javascript_body_onload(browser_data * b)
{
  _kernel_oserror * e = NULL;

  #ifdef TRACE
    if (tl & (1u<<24)) Printf("javascript_body_onload: Called\n");
  #endif

  if (!b->onload || !*b->onload) return NULL;

  #ifdef HACK_LINEONE

    /* Only call lineone_ functions if on the Line One site */

    if (strstr(browser_current_url(b), "www.lineone.net"))
    {
      e = lineone_body_onload(b);
    }

  #endif

  /* This is a bit unusual as the LineOne hack existed before any real */
  /* JS support, hence the function itself being 'live' even in non JS */
  /* builds.                                                           */

  #ifdef JAVASCRIPT

    e = javascript_process_script(b, b->onload);

  #endif

  /* Prevent multiple script executions... */

  b->onload = "";

  return e;
}

/*************************************************/
/* javascript_href_onclick()                     */
/*                                               */
/* When something is clicked upon that has an    */
/* onClick attribute specified for it, this      */
/* function is called with the details of that   */
/* attribute.                                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the item clicked on;  */
/*                                               */
/*             Pointer to the token representing */
/*             that item;                        */
/*                                               */
/*             Pointer to an int, in which 1 is  */
/*             written if the contents of the    */
/*             HREF attribute in the link that   */
/*             held the onClick should be        */
/*             ignored (else 0 is written) -     */
/*             this may be NULL if you're not    */
/*             interested.                       */
/*************************************************/

_kernel_oserror * javascript_href_onclick(browser_data * b, HStream * t, int * ignore)
{
  _kernel_oserror * e = NULL;

  #ifdef TRACE
    if (tl & (1u<<24)) Printf("javascript_href_onclick: Called\n");
  #endif

  if (ignore) *ignore = 0;

  #ifdef HACK_LINEONE

    /* Only call lineone_ functions if on the Line One site */

    if (strstr(browser_current_url(b), "www.lineone.net"))
    {
      e = lineone_href_onclick(b, t, ignore);
    }

  #endif

  return e;
}

/*************************************************/
/* javascript_window_open()                      */
/*                                               */
/* Opens a given URL in a given target window.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the window_open call; */
/*                                               */
/*             1 if the specified target window  */
/*             must be found to proceed, else 0  */
/*             (if the target isn't found the    */
/*             URL is opened in the given        */
/*             browser instead);                 */
/*                                               */
/*             1 if the URL displayed in the     */
/*             target is to be recorded in the   */
/*             History before the new one is     */
/*             fetched, else 0;                  */
/*                                               */
/*             Pointer to the URL to fetch;      */
/*                                               */
/*             Pointer to the target (or NULL /  */
/*             a null string for the given       */
/*             browser).                         */
/*************************************************/

_kernel_oserror * javascript_window_open(browser_data * b, int must_find, int record, char * url, char * target)
{
  _kernel_oserror * e;
  browser_data    * targetted = b;
  int               free_it   = 0;

  #ifdef TRACE
    if (tl & (1u<<24)) Printf("javascript_window_open: Called for %p with '%s' and target '%s'\n",b,url,target);
  #endif

  /* Exit if no URL or base browser is given */

  if (!b || !url || !*url) return NULL;

  /* If a target is specified, try and find it */

  if (target && *target)
  {
    browser_data * ancestor = utils_ancestor(b);

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_window_open: Proceeding with target '%s'\n",target);
    #endif

    targetted = frames_find_named(ancestor, target);

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_window_open: targetted = %p\n",targetted);
    #endif

    /* If the target can't be found and the parameters specify it must be, */
    /* then exit; else target the base browser instead.                    */

    if (!targetted)
    {
      if (must_find) return NULL;
      else targetted = b;
    }
  }

  /* Open the URL */

  #ifdef TRACE
    if (tl & (1u<<24)) Printf("javascript_window_open: Opening to target %p\n",targetted);
  #endif

  /* Relativise the URL if necessary */

  if (!strstr(url, HTTPmethod ProtocolSeparator)) /* (URLutils.h) */
  {
    browser_data * ancestor = utils_ancestor(targetted);
    char         * r_url;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_window_open: Relativising URL\n");
    #endif

    /* Need to go down a sequence of options for which URL to relativise to! */

    r_url = browser_current_url(targetted);

    if (!r_url) r_url = browser_fetch_url(targetted);
    if (!r_url) r_url = browser_current_url(ancestor);
    if (!r_url) r_url = browser_fetch_url(ancestor);

    url = urlutils_relativise_url(r_url, url);

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_window_open: Relativised URL is '%s'\n",url);
    #endif
  }

  e = fetchpage_new(targetted, url, record, 0);

  if (free_it) free(url);

  return e;
}

#ifdef JAVASCRIPT

  /*************************************************/
  /* javascript_url()                              */
  /*                                               */
  /* Find out if a URL is a JavaScript command.    */
  /*                                               */
  /* Parameters: Pointer to the URL string.        */
  /*                                               */
  /* Returns:    1 if the URL is a JavaScript URL, */
  /*             else 0.                           */
  /*************************************************/

  int javascript_url(const char * url)
  {
    if (!utils_strncasecmp(url, JavaScript_URL_Alternative1, sizeof(JavaScript_URL_Alternative1) - 1)) return 1;
    if (!utils_strncasecmp(url, JavaScript_URL_Alternative2, sizeof(JavaScript_URL_Alternative2) - 1)) return 1;

    return 0;
  }

  /*************************************************/
  /* javascript_watchdog()                         */
  /*                                               */
  /* Periodically called by JavaScript interpreter */
  /* - handles occasional garbage collection,      */
  /* watchdog timing, etc.                         */
  /*                                               */
  /* Assumes that the hourglass is turned on for   */
  /* the duration of the script - if not and the   */
  /* watchdog query comes up, it'll certainly turn */
  /* the hourglass on afterwards if the user wants */
  /* to continue script execution...!              */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* callback handler.                             */
  /*************************************************/

  static JSBool PR_CALLBACK javascript_watchdog(JSContext * cx, JSScript * script)
  {
    unsigned int now;

    #ifndef ATTEMPT_JS_POLL
      int esc;
    #endif

    if (
         _swix(OS_ReadMonotonicTime,
               _OUT(0),

               &now)
       )
       return JS_FALSE;

    #ifndef ATTEMPT_JS_POLL

      /* Deal with hourglass LEDs */

      if (!((now - watchdog_start) & BRANCH_CALLBACK_LED_MASK))
      {
        _swix(Hourglass_LEDs,
              _INR(0,1),

              3,
              watchdog_leds);

        watchdog_leds ^= 3;
      }

    #else

      /* Polling. This doesn't really work properly - it is definitely */
      /* not suitable for release builds - but if there's a very heavy */
      /* JS processing task to do, rebuild with this switched on and   */
      /* you can at least let things progress in the background.       */

      #define BRANCH_CALLBACK_POLL_MASK 7

      if (!((now - watchdog_start) & BRANCH_CALLBACK_POLL_MASK))
      {
        WimpPollBlock block;
        IdBlock       id;
        int           reason;

        if (
             !wimp_poll(0x1003830,
                        &block,
                        NULL,
                        &reason)
           )
        {
          if (reason != Wimp_ENull)
          {
            id.self_id            = last_browser->self_id;
            id.self_component     = NULL_ComponentId;
            id.parent_id          = NULL_ObjectId;
            id.parent_component   = NULL_ComponentId;
            id.ancestor_id        = NULL_ObjectId;
            id.ancestor_component = NULL_ComponentId;
          }

          switch (reason)
          {
            case Wimp_ERedrawWindow:
            {
              windows_redraw_browser(Wimp_ERedrawWindow,
                                     &block,
                                     &id,
                                     last_browser);
            }
            break;

            case Wimp_EOpenWindow:
            {
              windows_open_browser(Wimp_EOpenWindow,
                                   &block,
                                   &id,
                                   last_browser);
            }
            break;

            case Wimp_EKeyPressed:
            {
              wimp_process_key(block.key_pressed.key_code);
            }
            break;

            case Wimp_EUserMessage:
            case Wimp_EUserMessageRecorded:
            {
              if (block.user_message.hdr.action_code == Wimp_MQuit)
              {
                multiuser_logout();
                exit(EXIT_SUCCESS);
              }
            }
            break;
          }
        }
      }

    #endif

    /* Handle periodic garbage collection */

    if (!(watchdog_counter & BRANCH_CALLBACK_GC_MASK))
    {
      JS_MaybeGC(cx);
    }

    #ifndef ATTEMPT_JS_POLL

      /* Check Escape */

      if (!_swix(OS_Byte,
                 _INR(0, 1) | _OUT(1),

                 121, /* Key scan reason code */
                 112, /* Key code for Escape  */

                 &esc))
      {
        if (esc != 255)
        {
          erb.errnum = Utils_Error_Custom_Message;

          StrNCpy0(erb.errmess,
                   lookup_token("JSEsc:Escape (script aborted)",
                                0,
                                0));

          show_error_cont(&erb);

          return JS_FALSE;
        }
      }

      if (choices.js_watchdog)
      {
        /* Watchdog - if the script has taken more than a certain */
        /* length of time, ask if we should stop it.              */

        if (now - watchdog_start > choices.js_timeout)
        {
          /* Build the query message */

          erb.errnum = Utils_Error_Custom_Message;

          StrNCpy0(erb.errmess,
                   lookup_token("JSLock:Lengthy JavaScript script is still running. Continue?",
                                0,
                                0));

          /* Turn off the hourglass */

          _swix(Hourglass_Off, 0);

          /* If the user didn't select 'Continue', */
          /* stop the script.                      */

          if (
               show_error_ask(&erb,
                              "JSErr1:Continue,Stop")
               != 3
             )
             return JS_FALSE;

          /* Turn the hourglass back on, since we're continuing */
          /* with the script.                                   */

          _swix(Hourglass_Start,
                _IN(0),

                1);

          _swix(Hourglass_LEDs,
                _INR(0,1),

                3,
                watchdog_leds);

          /* Don't forget to reset the counter :-) */

          watchdog_counter = 0;

          if (
               _swix(OS_ReadMonotonicTime,
                     _OUT(0),

                     &watchdog_start)
             )
             watchdog_start = now;
        }
      }

    #endif

    /* Increment the counter */

    watchdog_counter++;

    /* Carry on with the script */

    return JS_TRUE;
  }

  /*************************************************/
  /* javascript_error()                            */
  /*                                               */
  /* Deal with errors from the JavaScript          */
  /* interpreter.                                  */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* error handling function.                      */
  /*************************************************/

  static void javascript_error(JSContext * cx, const char * message, JSErrorReport * report)
  {
    int response;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_error: Called\n");
    #endif

    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("JSMisc:JavaScript error",
                          0,
                          0));

    if (strlen(message) + 3 < sizeof(erb.errmess))
    {
      strcat(erb.errmess, " - ");
      strcat(erb.errmess, message);
    }

    response = show_error_ask(&erb, "JSErr2:Continue,More info");

    /* A response of 4 means 'more info' */

    if (response == 4)
    {
      FILE * f;
      int    i;

      f = fopen(Save_ScrapFile, "wb");

      if (!f)
      {
        erb = *_kernel_last_oserror();
        show_error_ret(&erb);

        return;
      }

      /* Write the introduction */

      fputs("// ", f);
      fputs(lookup_token("JSMisc:JavaScript error",0,0), f);
      fputs("\n// ", f);

      for (i = 0; i < strlen(tokens); i++) fputc('=', f);

      fputs("\n//\n", f);

      /* If we have a filename and/or line number, output them */

      if (report->filename) fprintf(f, "// %s, ", report->filename);
      if (report->lineno)   fprintf(f, "%u: ", report->lineno);

      if (!report->filename && !report->lineno) fputs("// ", f);

      /* Output the basic error message */

      if (message[0])
      {
        fputc(toupper(message[0]), f);
        fputs(&message[1], f);
      }

      if (!report->linebuf)
      {
        /* If that's all we have, we're finished */

        putc('\n', f);
      }
      else
      {
        int j, k, n;

        /* Otherwise, print out the contents of the error report block's line buffer */

        fprintf(f, ":\n\n   %s\n\n// ", report->linebuf);

        n = report->tokenptr - report->linebuf;

        for (i = j = 0; i < n; i++)
        {
          if (report->linebuf[i] == '\t')
          {
            for (k = (j + 8) & ~7; j < k; j++) putc('-', f);

            continue;
          }

          putc('-', f);
          j++;
        }

        fputs("^", f);
      }

      /* Close the file */

      fclose(f);

      /* Set the filetype */

      ChkError(_swix(OS_File,
                     _INR(0,2),

                     18,
                     Save_ScrapFile,
                     FileType_JSS));

//      /* If the source was the URL writable, fetch the page */
//      /* in the browser. Otherwise, give it to an editor.   */
//
//      if (
//           script_source == JavaScript_Source_URLWritable &&
//           is_known_browser(script_browser)
//         )
//      {
//        fetchpage_new(script_browser,
//                      FileMethod ProtocolSepShort Save_ScrapFile,
//                      1,
//                      0);
//      }

      /* Send to an external editor */

      ChkError(protocols_atats_send_data_open(FileType_TEXT, Save_ScrapFile));
    }

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_error: Finished\n");
    #endif

    return;
  }

  /*************************************************/
  /* javascript_configure_environment()            */
  /*                                               */
  /* Set up the browser environment for            */
  /* JavaScript.                                   */
  /*************************************************/

  _kernel_oserror * javascript_configure_environment(void)
  {
    unsigned int mask;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_configure_environment: Called\n");
    #endif

    /* Configure the floating point environment to act in a manner expected */
    /* by the JavaScript parser - turn off all exceptions.                  */

    set_fpsr(0, fpsr_trap_INX |
                fpsr_trap_UFL |
                fpsr_trap_OFL |
                fpsr_trap_DVZ |
                fpsr_trap_IVO);

    /* We must make sure our poll mask sets the bit that tells the Wimp */
    /* not to preserve floating point registers                         */

    RetError(event_get_mask(&mask));
    mask = (mask | Wimp_Poll_SaveFPRegs);
    RetError(event_set_mask(mask));

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_configure_environment: Successful\n");
    #endif

    return NULL;
  }

  /*************************************************/
  /* javascript_startup()                          */
  /*                                               */
  /* Having made sure the environment is set up    */
  /* with javascript_configure_environment, call   */
  /* this function to bring up the interpreter.    */
  /*************************************************/

  _kernel_oserror * javascript_startup(void)
  {
    if (choices.support_js)
    {
      jsr = JS_Init(JavaScript_HeapBeforeAutoGC /* See JavaScript.h */);

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_startup: Obtained run-time structure %p\n", jsr);
      #endif

      if (!jsr)
      {
        erb.errnum = Utils_Error_Custom_Fatal;

        StrNCpy0(erb.errmess,
                 lookup_token("JSInit:JavaScript interpreter initialisation failed (not enough memory?)",
                              0,
                              0));

        return &erb;
      }
    }

    return NULL;
  }

  /*************************************************/
  /* javascript_shutdown()                         */
  /*                                               */
  /* Shut down the JavaScript engine. Will throw   */
  /* an error if it believes the engine is still   */
  /* in use...                                     */
  /*************************************************/

  _kernel_oserror * javascript_shutdown(void)
  {
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_shutdown: Called\n");
    #endif

    if (!jsr)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Fatal;

        StrNCpy0(erb.errmess,
                 "JavaScript engine is not active in javascript_shutdown()");

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    if (last_browser)
    {
      erb.errnum = Utils_Error_Custom_Fatal;

      StrNCpy0(erb.errmess,
               lookup_token("JSActv:JavaScript interpreter still in use",
                            0,
                            0));

      return &erb;
    }

    JS_Finish(jsr);

    jsr = NULL;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_shutdown: Successful\n");
    #endif

    return NULL;
  }

  /*************************************************/
  /* javascript_gain_context()                     */
  /*                                               */
  /* For a given browser, either create an new     */
  /* interpreter context and initialise the        */
  /* various JS client-side objects within it; or  */
  /* inherit the context from the given parent.    */
  /*                                               */
  /* If a browser window already has a context,    */
  /* the function just exits.                      */
  /*                                               */
  /* Sets up also the branch callback (watchdog)   */
  /* and error reporting functions.                */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             to gain the context;              */
  /*                                               */
  /*             Pointer to a browser_data struct  */
  /*             to inherit from, or NULL for a    */
  /*             new context.                      */
  /*************************************************/

  _kernel_oserror * javascript_gain_context(browser_data * b, browser_data * parent)
  {
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_gain_context: Called for browser %p, parent %p\n",b,parent);
    #endif

    /* Does the browser already have a context? */

    if (!choices.support_js || b->bcx) return NULL;

    /* If we have a parent, inherit the context */

    if (parent)
    {
      /* Does the parent have a context? */

      if (!parent->bcx)
      {
        #ifdef TRACE

          erb.errnum = Utils_Error_Custom_Normal;

          sprintf(erb.errmess,
                  "Parent browser 0x%08x has no JSI context itself in javascript_gain_context()",
                  (int) parent);

          show_error_ret(&erb);

        #endif

        return NULL;
      }

      /* Copy the relevant details from the parent */

      b->bcx           = parent->bcx;
      b->bcx_inherited = parent;
    }

    /* If we don't have a parent, now there's some real work to do... */

    else
    {
      /* Get the context */

      b->bcx = JS_NewContext(jsr, JavaScript_Context_StackSize);

      if (!b->bcx)
      {
        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 lookup_token("JSCont:Cannot gain context in which to run JavaScript code (not enough memory?)",
                              0,
                              0));

        return &erb;
      }

    }

    /* Set up the client-side objects for this browser */

    if (!b->window_object) RetError(javascript_define_window(b));

    if (!parent)
    {
      /* Set up the watchdog and error functions for ancestors */

      JS_SetBranchCallback(b->bcx, javascript_watchdog);
      JS_SetErrorReporter (b->bcx, javascript_error);
    }

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_gain_context: Successful (context %p, Window object %p)\n", b->bcx, b->window_object);
    #endif

    return NULL;
  }

  /*************************************************/
  /* javascript_lose_context()                     */
  /*                                               */
  /* Get rid of a JavaScript interpreter context   */
  /* for a given browser. If the context was       */
  /* inherited, it is NOT destroyed, though any    */
  /* objects local to it are still thrown away.    */
  /*                                               */
  /* Parameters: Pointer to a browser_Data struct  */
  /*             with a valid JSI context.         */
  /*************************************************/

  _kernel_oserror * javascript_lose_context(browser_data * b)
  {
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_lose_context: Called\n");
    #endif

    if (!b->bcx)
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_lose_context: Browser %p has no context anyway! Exitting\n", b);
      #endif

      return NULL;
    }

    javascript_destroy_window(b);

    JS_GC(b->bcx);

    if (is_known_browser(b->bcx_inherited))
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_lose_context: Browser %p has an inherited context; only destroying objects\n", b);
      #endif
    }
    else
    {
      JS_DestroyContext(b->bcx);

      b->bcx           = NULL;
      b->bcx_inherited = NULL;
    }

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_lose_context: Successful\n");
    #endif

    return NULL;
  }

  /*************************************************/
  /* javascript_define_window()                    */
  /*                                               */
  /* Define the top-level Window JavaScript object */
  /* for the given browser (which must have a JSI  */
  /* context). Initialises also related objects.   */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             with a valid JSI context.         */
  /*************************************************/

  _kernel_oserror * javascript_define_window(browser_data * b)
  {
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_define_window: Called for %p\n",b);
    #endif

    if (!b->bcx)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser %p does not have an JSI context",
                b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    if (!jswindow_new_window(b))
    {
      erb.errnum = Utils_Error_Custom_Message;

      StrNCpy0(erb.errmess,
               lookup_token("JSGenE:Cannot start up JavaScript for this page (not enough memory?)",
                            0,
                            0));

      return &erb;
    }

    return NULL;
  }

  /*************************************************/
  /* javascript_destroy_window()                   */
  /*                                               */
  /* Get rid of the top-level Window JavaScript    */
  /* object for the given browser (which must have */
  /* a JSI context). Gets rid also of related      */
  /* objects.                                      */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             with a valid JSI context.         */
  /*************************************************/

  _kernel_oserror * javascript_destroy_window(browser_data * b)
  {
    if (!b->bcx)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser %p does not have a JSI context",
                b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    jswindow_destroy_window(b);

    return NULL;
  }

  /*************************************************/
  /* javascript_set_source()                       */
  /*                                               */
  /* Before processing a script, you should call   */
  /* this function to describe the way that the    */
  /* script source was encountered.                */
  /*                                               */
  /* Parameters: javascript_source describing the  */
  /*             way the script was encountered    */
  /*             (see JavaScript.h).               */
  /*************************************************/

  void javascript_set_source(javascript_source s)
  {
    /* Remember the source and flag that we've done so */

    script_source = s;
    source_set    = 1;
  }

  /*************************************************/
  /* javascript_process_script()                   */
  /*                                               */
  /* Run the interpreter for a script. This may be */
  /* a JavaScript URL, or it may have a SCRIPT     */
  /* tag at the front of it.                       */
  /*                                               */
  /* It is strongly recommended that you call      */
  /* javascript_set_source before calling this     */
  /* function.                                     */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             relevant to the script;           */
  /*                                               */
  /*             Pointer to the script as a null   */
  /*             terminated string.                */
  /*************************************************/

  _kernel_oserror * javascript_process_script(browser_data * b, const char * script)
  {
    int          len = strlen(script);
    const char * si  = script;
    const char * url;
    JSScript   * jss;
    jsval        result;
    int          ok;
    int          jsu = 0;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_process_script: Called\n");
    #endif

    /* Does the browser have a JavaScript context and Window object? */

    if (!b->bcx)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser 0x%08x has no JSI context in javascript_process_script()",
                (int) b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    if (!b->window_object)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser 0x%08x has no Window object in javascript_process_script()",
                (int) b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    /* Do we have a string to look at? */

    if (!si || !*si)
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_process_script: Null script passed\n");
      #endif

      return NULL;
    }

    /* Check for a JavaScript URL prefix and point past it if it is there */

    if (
         !utils_strncasecmp(script,
                            JavaScript_URL_Alternative1,
                            sizeof(JavaScript_URL_Alternative1) - 1)
       )
       len -= (sizeof(JavaScript_URL_Alternative1) - 1),
       si  += (sizeof(JavaScript_URL_Alternative1) - 1),
       jsu = 1;

    else if (
              !utils_strncasecmp(script,
                                 JavaScript_URL_Alternative2,
                                 sizeof(JavaScript_URL_Alternative2) - 1)
            )
            len -= (sizeof(JavaScript_URL_Alternative2) - 1),
            si  += (sizeof(JavaScript_URL_Alternative2) - 1),
            jsu = 1;

    /* Do we still have a script to use? */

    if (len < 1)
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_process_script: No script left after removing URL or SCRIPT tag prefix\n");
      #endif

      return NULL;
    }

    /* If javascript_set_source hasn't been called, the source_set */
    /* flag is clear - so we must state that the source of the     */
    /* script is unknown.                                          */

    if (!source_set) script_source = JavaScript_Source_Unknown;

    /* Remember the browser that the script is executing for */

    script_browser = b;

    /* Determine what the initial state of the doc_write_used flag should be */
    /* (which basically means 'do we reflect document.write output or raw    */
    /* interpreter output in the browser').                                  */

    if (script_source == JavaScript_Source_URLWritable) doc_write_used = 0;
    else                                                doc_write_used = 1;

    /* Compile the script */

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_process_script: Compiling script\n");
    #endif

    url           = browser_fetch_url(b);
    if (!url) url = browser_current_url(b);

    jss = JS_CompileScript(b->bcx,           /* Context                                */
                           b->window_object, /* Object with which script is associated */
                           si,               /* Pointer to script                      */
                           len,              /* Length of script                       */
                           url,              /* Name / URL for script (for errors)     */
                           0);               /* Line number (for errors)               */

    /* Ensure the source_set flag is cleared again ready for next time */

    source_set = 0;

    /* If JS_CompileScript failed, the error reporter function should */
    /* already have been called, so we exit silently now.             */

    if (!jss) ok = 0;
    else
    {
      /* Otherwise, go on to run the script. */

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_process_script: Script compiled. Now running it\n");
      #endif

      watchdog_counter = 0;
      watchdog_leds    = 1;

      RetError(_swix(OS_ReadMonotonicTime,
                     _OUT(0),

                     &watchdog_start));

      #ifndef ATTEMPT_JS_POLL
        _swix(Hourglass_On, 0);
      #endif

      ok = JS_ExecuteScript(b->bcx,
                            b->window_object,
                            jss,
                            &result);

      #ifndef ATTEMPT_JS_POLL
        _swix(Hourglass_Off, 0);
      #endif

      /* Throw away the bytecode */

      JS_DestroyScript(b->bcx, jss);
    }

    /* Try to allocate source in the browser source store */
    /* to report the results.                             */

    proceed = 1; /* Flag that the fetch should proceed until we know better */

//    if (b->source)
//    {
//      flex_free((flex_ptr) &b->source);
//      b->source = NULL;
//    }

    if (!ok)
    {
      /* There was an error - we shouldn't proceed with the fetch */

      proceed = 0;
    }
    else
    {
      /* If doc_write_used is clear, we want to turn the return result */
      /* from the script execution into some document source.          */

      if (!doc_write_used)
      {
        if (
             result == JSVAL_VOID     ||
             !JS_ConvertValue(b->bcx,
                              result,
                              JSTYPE_STRING,
                              &result)
           )
        {
          proceed = 0; // return javascript_empty_source_store(b);
        }
        else
        {
          int result_len = JS_GetStringLength(JSVAL_TO_STRING(result)); /* (Does not include terminator) */

          /* If this really was a JavaScript URL, record it in the history list now */
          /* (not really interested in errors, though; it's not critical...)        */

          if (jsu) history_record(b, script);

          /* Now copy the result across */

          if (b->source)
          {
            flex_free(&b->source);
            b->source = NULL;
          }

          if (flex_alloc((flex_ptr) &b->source, result_len))
          {
            /* The result is copied as plain text source - so there is no zero terminator to write */

            strncpy(b->source, JS_GetStringBytes(JSVAL_TO_STRING(result)), result_len);
          }
          else RetError(make_no_javascript_memory_error(3));
        }
      }

      // Would transer document.write accumulated store to here at this point.

      else
      {
        // Definitely *don't* touch the store if we've nothing to write.

        proceed = 0;
      }
    }

    /* TRACE builds will report how successful the execution was */

    #ifdef TRACE

      if (tl & (1u<<24))
      {
        if (ok) Printf("javascript_process_script: \0212Script ran OK\0217\n");
        else    Printf("javascript_process_script: \0211Script failed\0217\n");
      }

    #endif

    /* Finished */

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_process_script: Successful\n");
    #endif

    return NULL;
  }

  /*************************************************/
  /* javascript_script_callback()                  */
  /*                                               */
  /* Callback function for HTMLLib to handle a     */
  /* SCRIPT element.                               */
  /*                                               */
  /* Parameters: See HTMLLib "htmllib.h".          */
  /*                                               */
  /* Returns:    See HTMLLib "htmllib.h".          */
  /*************************************************/

  char * javascript_script_callback(void * stream, HStream * script_element, void * handle)
  {
    int            len;
    const char   * si;
    const char   * url;
    char         * ret;
    JSScript     * jss;
    jsval          result;
    int            ok;
    browser_data * b     = (browser_data *) handle;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_script_callback: Called\n");
    #endif

    /* Is this JavaScript? */

    if (
         script_element->name &&
         utils_strncasecmp(script_element->name,
                           JavaScript_Language_Name,
                           sizeof(JavaScript_Language_Name) - 1)
       )
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_script_callback: Unknown language '%s'\n", script_element->name);
      #endif

      return NULL;
    }

    /* Get the script details */

    si = script_element->text;
    if (!si || !*si) return NULL;

    len = strlen(si);

//    /* Cope with a leading '<script>' if one is there */
//
//    if (!utils_strncasecmp(si, "<script>", sizeof("<script>") - 1)) si += sizeof("<script>") - 1;
//    len = strlen(si);
//    if (!len) return NULL;

    /* Does the browser have a JavaScript context and Window object? */

    if (!b->bcx)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser 0x%08x has no JSI context in javascript_script_callback()",
                (int) b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    if (!b->window_object)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser 0x%08x has no Window object in javascript_script_callback()",
                (int) b);

        show_error_ret(&erb);

      #endif

      return NULL;
    }

    /* Set up initial information */

    javascript_free_document_write_block();

    script_source  = JavaScript_Source_ScriptInPage;
    script_browser = b;
    doc_write_used = 1;

    /* Compile the script */

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("javascript_script_callback: Compiling script\n");
    #endif

    url           = browser_fetch_url(b);
    if (!url) url = browser_current_url(b);

    jss = JS_CompileScript(b->bcx,           /* Context                                */
                           b->window_object, /* Object with which script is associated */
                           si,               /* Pointer to script                      */
                           len,              /* Length of script                       */
                           url,              /* Name / URL for script (for errors)     */
                           0);               /* Line number (for errors)               */

    /* Ensure the source_set flag is cleared again ready for next time */

    source_set = 0;

    /* If JS_CompileScript failed, the error reporter function should */
    /* already have been called, so we exit silently now.             */

    if (!jss) ok = 0;
    else
    {
      /* Otherwise, go on to run the script. */

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_script_callback: Script compiled. Now running it\n");
      #endif

      watchdog_counter = 0;
      watchdog_leds    = 1;

      _swi(OS_ReadMonotonicTime,
           _OUT(0),

           &watchdog_start);

      #ifndef ATTEMPT_JS_POLL
        _swix(Hourglass_On, 0);
      #endif

      ok = JS_ExecuteScript(b->bcx,
                            b->window_object,
                            jss,
                            &result);

      #ifndef ATTEMPT_JS_POLL
        _swix(Hourglass_Off, 0);
      #endif

      /* Throw away the bytecode */

      JS_DestroyScript(b->bcx, jss);
    }

    /* TRACE builds will report how successful the execution was */

    #ifdef TRACE

      if (tl & (1u<<24))
      {
        if (ok) Printf("javascript_script_callback: \0212Script ran OK\0217\n");
        else    Printf("javascript_script_callback: \0211Script failed\0217\n");
      }

    #endif

    /* Finished - copy the document.write() etc. data, or if there is */
    /* none or the script failed, return NULL.                        */

    if (ok && script_write_l)
    {
      int old_budge;

      /* The block has no terminator presently, so '+ 1' below leaves room for one*/

      ret = HtmlMalloc(script_write_l + 1, script_element);

      if (!ret)
      {
        #ifdef TRACE
          if (tl & (1u<<24)) Printf("javascript_script_callback: Couldn't allocate memory for return data block, exitting\n");
        #endif

        return NULL;
      }

      /* Copy the existing data over, locking flex down Just In Case */

      old_budge = flex_set_budge(0);
      memcpy(ret, script_write_p, script_write_l);
      flex_set_budge(old_budge);

      /* Write the terminator */

      ret[script_write_l] = '\0';

      // If you think document.write is going wrong, this can help...
      //
      // #ifdef TRACE
      //
      //   {
      //     char   f[2048];
      //     FILE * o;
      //
      //     protocols_util_make_unique_name(f, sizeof(f));
      //
      //     o = fopen(f, "wb");
      //     if (o)
      //     {
      //       fwrite(ret, 1, script_write_l+1, o);
      //       fclose(o);
      //     }
      //   }
      //
      // #endif

      /* Free the temporary block */

      javascript_free_document_write_block();

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_script_callback: Successful (return block %p)\n", ret);
      #endif

      return ret;
    }
    else
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("javascript_script_callback: Successful with no return data, or script failed\n");
      #endif

      return NULL;
    }
  }

  /*************************************************/
  /* javascript_allocate_document_write_block()    */
  /*                                               */
  /* Allocate a block of memory for a Document     */
  /* object (or similar) to write into. Repeated   */
  /* calls to this function will extend the single */
  /* block and return a pointer to the start point */
  /* where data should be written. If allocation   */
  /* fails, the entire block is discarded - there  */
  /* is no need to remember your old pointer (as   */
  /* if calling realloc(), say, directly), since   */
  /* this function does it for you.                */
  /*                                               */
  /* Parameters: Amount of data to allocate in     */
  /*             bytes.                            */
  /*                                               */
  /* Returns:    Pointer to start of region where  */
  /*             data should be written - NULL     */
  /*             terminators and the like should   */
  /*             NOT be included.                  */
  /*************************************************/

  char ** javascript_allocate_document_write_block(int len, int * offset)
  {
    int success;
    int old_l;

    /* Allocate the new block */

    if (script_write_p) success = flex_extend((flex_ptr) &script_write_p, script_write_l + len);
    else                success = flex_alloc ((flex_ptr) &script_write_p, script_write_l + len);

    if (!success)
    {
      if (script_write_p)
      {
        flex_free((flex_ptr) &script_write_p);

        script_write_p = NULL;
        script_write_l = 0;
      }

      return NULL;
    }

    /* Remember the new length */

    old_l          = script_write_l;
    script_write_l = script_write_l + len;

    /* Give back the offset to write to */

    if (offset) *offset = old_l;

    return &script_write_p;
  }

  /*************************************************/
  /* javascript_free_document_write_block()        */
  /*                                               */
  /* Free memory allocated through the             */
  /* javascript_allocate_document_write_block()    */
  /* function.                                     */
  /*************************************************/

  void javascript_free_document_write_block(void)
  {
    if (script_write_p)
    {
      flex_free((flex_ptr) &script_write_p);

      script_write_p = NULL;
      script_write_l = 0;
    }
  }

  /*************************************************/
  /* javascript_set_doc_write_used()               */
  /*                                               */
  /* If a script does not use document_write but   */
  /* it came from the URL writable, the value      */
  /* returned by the parser should be used as a    */
  /* plain text document in the browser window.    */
  /* However, if the script comes from anywhere    */
  /* else or if it uses document.write(), only the */
  /* document.write() generated information should */
  /* be displayed.                                 */
  /*                                               */
  /* So:                                           */
  /*                                               */
  /* If document.write() is called, this function  */
  /* should be invoked to flag the event.          */
  /*************************************************/

  void javascript_set_doc_write_used(void)
  {
    doc_write_used = 1;
  }

  /*************************************************/
  /* javascript_fetch_should_proceed()             */
  /*                                               */
  /* If a script has been processed because of a   */
  /* JavaScript URL, call this after               */
  /* javascript_script_callback to see if the      */
  /* fetch should be stopped or should continue.   */
  /*                                               */
  /* Returns:    1 if the fetch should proceed,    */
  /*             else 0.                           */
  /*************************************************/

  int javascript_fetch_should_proceed(void)
  {
    return proceed;
  }

  /*************************************************/
  /* javascript_set_pending_fetch()                */
  /*                                               */
  /* If, say, in the middle of the script callback */
  /* function, a URL needs to be visited (e.g.     */
  /* 'window.location.href="..."' is done in a     */
  /* script), use this function instead of just    */
  /* calling fetchpage_new (which won't work due   */
  /* to fetcher threading issues). Later on,       */
  /* javascript_fetch_is_pending will be called to */
  /* see if the fetch should be stopped and        */
  /* restarted at the recorded location.           */
  /*                                               */
  /* At the time of creation, this function's      */
  /* parameters list mirros exactly those for      */
  /* fetchpage_new. To cancel a pending fetch,     */
  /* however, call with a NULL browser_data        */
  /* struct pointer.                               */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             to which the new URL refers;      */
  /*                                               */
  /*             Pointer to the new URL string (a  */
  /*             copy is taken, so any space       */
  /*             allocated for this by the caller  */
  /*             may be safely disposed of         */
  /*             afterwards);                      */
  /*                                               */
  /*             1 to record the previous URL in   */
  /*             the history list, else 0;         */
  /*                                               */
  /*             1 to stop other page fetches in   */
  /*             any other frames related to this  */
  /*             document, 0 to only stop those in */
  /*             this frame.                       */
  /*************************************************/

  void javascript_set_pending_fetch(browser_data * b, const char * url, int record, int stop)
  {
    if (!b || !url || !*url) return;

    pending_b      = b;
    pending_record = record;
    pending_stop   = stop;

    /* Need to take a copy of the URL */

    free(pending_url);
    pending_url = malloc(strlen(url) + 1);

    /* If allocation fails, cancel the pending fetch quietly */
    /* - otherwise, just copy the URL over.                  */

    if (!pending_url)
    {
      pending_b      = NULL;
      pending_record = 0;
      pending_stop   = 0;
    }
    else
    {
      strcpy(pending_url, url);
    }

    return;
  }

  /*************************************************/
  /* javascript_fetch_is_pending()                 */
  /*                                               */
  /* See if javascript_set_pending_fetch has been  */
  /* used to record a fetch that needs to be done  */
  /* as soon as possible.                          */
  /*                                               */
  /* Use javascript_do_pending_fetch to start the  */
  /* new fetch, if this function says there is one */
  /* waiting.                                      */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             to check against the one          */
  /*             recorded for the pending fetch.   */
  /*                                               */
  /* Returns:    1 if a there is indeed a new      */
  /*             fetch to start, else 0.           */
  /*************************************************/

  int javascript_fetch_is_pending(browser_data * b)
  {
    if (pending_b && pending_b == b) return 1;

    return 0;
  }

  /*************************************************/
  /* javascript_do_pending_fetch()                 */
  /*                                               */
  /* If javascript_fetch_is_pending says there is  */
  /* a fetch to be done, use this function to      */
  /* start it.                                     */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             to check against the one          */
  /*             recorded for the pending fetch.   */
  /*************************************************/

  _kernel_oserror * javascript_do_pending_fetch(browser_data * b)
  {
    _kernel_oserror * e;

    #ifdef TRACE

      if (!b || b != pending_b)
      {
        erb.errnum = Utils_Error_Custom_Normal;

        sprintf(erb.errmess,
                "Browser %p has no fetch pending in javascript_do_pending_fetch",
                b);

        return &erb;
      }

    #else

      if (!b || b != pending_b) return NULL;

    #endif

    e = fetchpage_new(pending_b,
                      pending_url,
                      pending_record,
                      pending_stop);

    free(pending_url);

    pending_b      = 0;
    pending_record = 0;
    pending_stop   = 0;
    pending_url    = NULL;

    return e;
  }

  /*************************************************/
  /* javascript_fix_invalid_date_format()          */
  /*                                               */
  /* Look for dates of the form:                   */
  /*                                               */
  /*   FullDayName, dd-mmm-yy                      */
  /*                                               */
  /* and change them to:                           */
  /*                                               */
  /*   Day, dd mmm yy                              */
  /*                                               */
  /* to improve the changes of them being accepted */
  /* by the Date object constructor. For example,  */
  /* "Wednesday, 18-Oct-97" will be changed to     */
  /* "Wed, 18 Oct 97".                             */
  /*                                               */
  /* Originally created in a vague attempt to make */
  /* Last-modified dates returned by Netscape      */
  /* Commerce server readable by 'new Date(...)'.  */
  /*                                               */
  /* Parameters: Pointer to the date string, which */
  /*             may be modified; it will always   */
  /*             end up the same length or shorter */
  /*             than the string passed.           */
  /*                                               */
  /* Returns:    1 if the string was modified,     */
  /*             else 0.                           */
  /*************************************************/

  int javascript_fix_invalid_date_format(char * date)
  {
    int    modified = 0;
    char * p;

    if (!date) return 0;

    /* Monday -> Mon, Tuesday -> Tue, etc. */

    if (
         !strcmp(date, "Monday")    ||
         !strcmp(date, "Tuesday")   ||
         !strcmp(date, "Wednesday") ||
         !strcmp(date, "Thursday")  ||
         !strcmp(date, "Friday")    ||
         !strcmp(date, "Saturday")  ||
         !strcmp(date, "Sunday")
       )
    {
      char * end;
      char * space = strstr(date, " ");
      char * comma = strstr(date, ",");

      if (comma && space)
      {
        if (comma < space) end = comma;
        else               end = space;
      }
      else if (comma) end = comma;
      else if (space) end = space;
      else            end = NULL;

      if (end && end > (date + 3))
      {
        modified = 1;
        strcpy(end, date + 3);
      }
    }

    /* Any '-' changed to ' ' unless preceeded or followed by a ' ' */

    for (p = date; *p; p ++)
    {
      if (*p == '-')
      {
        if (
             p > date        &&
             *(p - 1) != ' ' &&
             *(p + 1) != ' '
           )
           *p = ' ', modified = 1;
      }
    }

    return modified;
  }

  /*************************************************/
  /* javascript_reread_window_details()            */
  /*                                               */
  /* The screen X and Y positions, size etc. of    */
  /* the browser window in JavaScript are recorded */
  /* to the accuracy of a JSDouble. JavaScript     */
  /* code may add 0.1 to the X position 10 times   */
  /* and have the window move one pixel. So, just  */
  /* reading the values from the Wimp each time we */
  /* need to change or return something is not     */
  /* good enough - we have to keep a similarly     */
  /* accurate record.                              */
  /*                                               */
  /* Keeping such a record requires this function  */
  /* to be called whenever code moves, resizes or  */
  /* otherwise changes a browser window or frame.  */
  /* This will ensure that the JSDouble accuracy   */
  /* information is kept correctly updated.        */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             relevant to the window for whom   */
  /*             the updated information is to be  */
  /*             recorded.                         */
  /*************************************************/

  _kernel_oserror * javascript_reread_window_details(browser_data * b)
  {
//    WimpGetWindowStateBlock   state;
//    WimpGetWindowOutlineBlock outline;
//    int                       wf, wl;
//
//    state.window_handle   = b->window_handle;
//    outline.window_handle = b->window_handle;
//
//    RetError(wimp_get_window_state(&state));
//    RetError(wimp_get_window_outline(&outline));
//
//    wf = bbc_modevar(-1, BBC_YEigFactor);
//    wl = bbc_modevar(-1, BBC_YWindLimit);
//
//    wl = (wl + 1) << wf;
//
//    /* The read-from-the-window values should always be whole pixels, */
//    /* hence the cast to int first, then JSDouble for storage.        */
//
//    b->screen_x     = (JSDouble) ((int) (outline.outline.xmin / 2));
//    b->screen_y     = (JSDouble) ((int) ((wl - outline.outline.ymax) / 2));
//
//    b->inner_width  = (JSDouble) ((int) ((state.visible_area.xmax - state.visible_area.xmin) / 2));
//    b->inner_height = (JSDouble) ((int) ((state.visible_area.ymax - state.visible_area.ymin) / 2));
//
//    b->outer_width  = (JSDouble) ((int) ((outline.outline.xmax - outline.outline.xmin) / 2));
//    b->outer_height = (JSDouble) ((int) ((outline.outline.ymax - outline.outline.ymin) / 2));

    return NULL;
  }

#endif
