/***************************************************/
/* File   : Save.c                                 */
/*                                                 */
/* Purpose: Save functions for the browser.        */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 04-Dec-96: Created.                    */
/***************************************************/

#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>

#include "swis.h"
#include "flex.h"

#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "toolbox.h"
#include "window.h"
#include "men u.h"
#include "saveas.h"

#include "svcprint.h"
#include "Global.h"
#include "Utils.h"

#include "ChoiceDefs.h"
#include "Fetch.h" /* (Which itself includes URLstat.h) */
#include "Filetypes.h"
#include "Fontmanage.h"
#include "Hotlist.h"
#include "Protocols.h"
#include "URLutils.h"

#include "Save.h"

/* Local enumerations and types */

typedef enum save_method
{
  Save_SaveNumber,
  Save_SaveInKBytes,
  Save_SaveString,
  Save_SaveColour,
  Save_SaveYesNo

} save_method;

typedef struct save_pair
{
  const char * name;
  const int    value;

} save_pair;

/* Static function prototypes */

static int  save_save_string  (FILE * file, char * string);
static int  save_save_colour  (FILE * file, int colour);
static int  save_save_number  (FILE * file, int number);
static int  save_save_yes_no  (FILE * file, int yes);
static int  save_save_font    (FILE * file, const char * typefacename);
static int  save_save_general (FILE * file, int how_many, const save_pair ns[], int match, int def);

/* Locals */

static char * last_path = NULL;

/*************************************************/
/* save_record_path()                            */
/*                                               */
/* Record the given pathname for future use. No  */
/* errors are raised if the memory allocation to */
/* do this fails.                                */
/*                                               */
/* Note that <Wimp$Scrap>... and                 */
/* <Wimp$ScrapDir>... are two exceptions - paths */
/* starting with these are not recorded.         */
/*                                               */
/* Parameters: Pointer to a pathname to record.  */
/*************************************************/

void save_record_path(const char * path)
{
  if (!path) return;

  /* Check for the special cases */

  if (!strncmp(path, "<Wimp$Scrap>", 12) || !strncmp(path, "<Wimp$ScrapDir>", 15)) return;

  /* Otherwise, record the path, failing silently if */
  /* we can't claim enough memory for it.            */

  free(last_path);

  last_path = malloc(strlen(path) + 1);

  if (last_path) strcpy(last_path, path);
}

/*************************************************/
/* save_return_last_path()                       */
/*                                               */
/* Used mostly for filling in writables of save  */
/* dialogues with paths based on previous saves. */
/*                                               */
/* Returns:    Pointer to the last pathname that */
/*             was used for saving, or NULL if   */
/*             no such record is available.      */
/*************************************************/

const char * save_return_last_path(void)
{
  return last_path;
}

/*************************************************/
/* save_save_source()                            */
/*                                               */
/* Saves the document source for a given browser */
/* to the given path, setting the filetype as    */
/* HTML or text as appropriate.                  */
/*                                               */
/* Parameters: Pointer to a null-terminated      */
/*             pathname to save to;              */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             owning the source to save.        */
/*************************************************/

_kernel_oserror * save_save_source(char * path, browser_data * b)
{
  _kernel_oserror * e;
  int               old_budge;

  /* Sanity checks */

  if (!b || !b->source || !path || !*path)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid parameters to save_save_source: %p, %p (source %p)",
              path,
              b,
              b ? b->source : NULL);

      return &erb;

    #else

      return NULL;

    #endif
  }

  save_record_path(path);

  /* Save the file - lock flex heap to ensure save transfer */

  old_budge = flex_set_budge(0);

  e = _swix(OS_File,
            _INR(0,2) | _INR(4,5),

            10, /* Save block of memory as a typed file */
            path,
            b->page_is_text ? FileType_TEXT : FileType_HTML,
            b->source,
            ((char *) b->source) + flex_size((flex_ptr) &b->source));

  /* Unlock flex */

  flex_set_budge(old_budge);

  return e;
}

/*************************************************/
/* save_transfer_source()                        */
/*                                               */
/* Save a browser's page source as an HTML file, */
/* through a RAM transfer buffer with            */
/* Wimp_TransferBlock.                           */
/*                                               */
/* Intended to be called as a response to a      */
/* Message_RAMFetch from another task.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the document source;  */
/*                                               */
/*             Pointer to an int, in which the   */
/*             amount of data transferred so     */
/*             far should be stored on entry;    */
/*                                               */
/*             Pointer to the WimpMessage struct */
/*             corresponding to the              */
/*             Message_RAMFetch that led to this */
/*             function being called.            */
/*                                               */
/* Returns:    The contents of the int holding   */
/*             the amount of data transferred    */
/*             prior to the function call are    */
/*             updated with the new amount       */
/*             transferred. Callers should use   */
/*             this in any future calls, and it  */
/*             *must* be checked for a value of  */
/*             -1, which indicates the transfer  */
/*             is complete (so any tidying up    */
/*             should be done if there is an     */
/*             error returned, or if the int is  */
/*             filled in with a value of -1).    */
/*                                               */
/* Assumes:    The various pointers may be NULL, */
/*             though if they are the function   */
/*             does nothing (it just exits).     */
/*************************************************/

_kernel_oserror * save_transfer_source(browser_data * b, int * transferred, WimpMessage * m)
{
  _kernel_oserror * e     = NULL;
  int               size  = save_source_size(b);
  int               left;
  int               write;

  /* Sanity check */

  if (!b || !b->source || !transferred || !m)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid parameters to save_transfer_source: %p (source %p), %p, %p",
              b,
              b ? b->source : NULL,
              transferred,
              m);

      return &erb;

    #else

      return NULL;

    #endif
  }

  left = size - *transferred;

  /* If we have data to transfer, do so */

  if (left >= 0)
  {
    /* Use either the buffer size, or the bytes left, whichever */
    /* is the smallest.                                         */

    write = left > m->data.ram_fetch.buffer_size ? m->data.ram_fetch.buffer_size : left;

    if (write)
    {
      int old_budge;

      /* Transfer the data - must lock the flex heap for the */
      /* duration of this...                                 */

      old_budge = flex_set_budge(0);

      e = wimp_transfer_block(task_handle,
                              (char *) b->source + (*transferred),
                              m->hdr.sender,
                              m->data.ram_fetch.buffer,
                              write);

      /* Unlock flex and report any errors */

      flex_set_budge(old_budge);

      if (e) return e;
    }

    /* If we have any data left to send, reply with a Message_RAMTransmit */

    e = protocols_atats_send_ram_transmit(m, write, write < m->data.ram_fetch.buffer_size);

    /* Increment the transferred counter */

    *transferred += write;
    left         -= write;
  }

  /* Finished */

  return e;
}

/*************************************************/
/* save_source_size()                            */
/*                                               */
/* Returns the size that a given HTML source     */
/* document would take on disc.                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             owning the source to save.        */
/*                                               */
/* Returns:    Size the file will be.            */
/*************************************************/

int save_source_size(browser_data * b)
{
  /* Sanity check */

  if (!b || !b->source)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid parameters to save_source_size: %p (source %p)",
              b,
              b ? b->source : NULL);

      show_error_ret(&erb);

    #endif

    return 0;
  }

  /* For now this is trivially simple, but in future it */
  /* could take account of, for example, inserting a    */
  /* <BASE> tag into the document.                      */

  return flex_size((flex_ptr) &b->source);
}

/*************************************************/
/* save_save_object()                            */
/*                                               */
/* Called when a fetch is to be spooled to disc. */
/* Handles saving as much data as is already     */
/* fetched, and setting the relevant parts of    */
/* the given browser_data structure up with the  */
/* output file details.                          */
/*                                               */
/* Parameters: Pointer to a null-terminated      */
/*             pathname to save to;              */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             relevant to the object to save.   */
/*************************************************/

_kernel_oserror * save_save_object(char * path, browser_data * b)
{
  /* Sanity check */

  if (!b || !path || !*path)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid parameters to save_save_object: %p, %p",
              path,
              b);

      return &erb;

    #else

      return NULL;

    #endif
  }

  save_record_path(path);

  /* If using a small fetch window, set the title to the save pathname */

  if (b->small_fetch)
  {
    char title[Limits_Title];

    StrNCpy0(title, path);

    /* Don't treat any errors here as fatal */

    show_error_ret(window_set_title(0, b->self_id, title));
  }

  /* Open the file */

  b->save_file = fopen(path, "wb");

  if (!b->save_file)
  {
    StrLastE;

    fetch_stop(b, 0);

    return &erb;
  }
  else
  {
    int bytes;

    /* Set the filetype to DEADDEAD, to represent an incomplete */
    /* file (particularly good on later Filers, which display   */
    /* a special sprite for this).                              */

    _swix(OS_File,
          _INR(0,2),

          2, /* Set load address */
          path,
          0xdeaddead);

    _swix(OS_File,
          _INR(0,1) | _IN(3),

          3, /* Set exec address */
          path,
          0xdeaddead);

    if (b->source)
    {
      int old_budge;

      /* Any data in the source store represents already */
      /* fetched bits of the file. Must lock flex down   */
      /* over the save to make sure the heap doesn't     */
      /* shift over the call to fwrite.                  */

      old_budge = flex_set_budge(0);

      bytes = fwrite(b->source,
                     1,
                     flex_size((flex_ptr) &b->source),
                     b->save_file);

      flex_set_budge(old_budge);

      /* If we didn't transfer as much as we expected, complain */

      if (bytes != flex_size((flex_ptr) &b->source))
      {
        /* Report any errors */

        StrLastE;

        fetch_stop(b, 0);

        return &erb;
      }
      else
      {
        /* Otherwise, get rid of the data in the source store */
        /* as it's been written to the file.                  */

        flex_free((flex_ptr) &b->source);
        b->source = NULL;
      }
    }
  }

  return NULL;
}

/*************************************************/
/* save_object_size()                            */
/*                                               */
/* Returns the estimated size that a given       */
/* object will be after being spooled through    */
/* the fetcher.                                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the object to save.   */
/*                                               */
/* Returns:    *Estimated* size of the object.   */
/*************************************************/

int save_object_size(browser_data * b)
{
  /* For now, we just don't know this information... */

  return 4096;
}

/*************************************************/
/* save_save_uri()                               */
/*                                               */
/* Save the contents of a link as a URI file.    */
/*                                               */
/* Parameters: Pointer to a null-terminated      */
/*             pathname to save to;              */
/*                                               */
/*             Pointer to the URI to save;       */
/*                                               */
/*             Pointer to the URL title, or NULL */
/*             / null string for no title;       */
/*                                               */
/*             0 to save as a URI file, else     */
/*             save as a non-terminated string   */
/*             with type FileType_URL (ANT       */
/*             suite URL file).                  */
/*************************************************/

_kernel_oserror * save_save_uri(char * path, char * url, char * title, int write_url)
{
  _kernel_oserror * e = NULL;
  FILE            * file;

  /* Sanity check */

  if (title && !*title) title = NULL;

  if (!path || !*path || !url || !*url)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid parameters to save_save_uri: %p, %p, %d",
              path,
              url,
              write_url);

      return &erb;

    #else

      return NULL;

    #endif
  }

  save_record_path(path);

  /* Try and open the file */

  file = fopen(path, "wb");
  if (!file) RetLastE;

  /* Write the contents */

  if (!write_url)
  {
    /* URI file */

    if (
         fprintf(file,
                 "URI\t100\n\t# %s v",
                 lookup_token("_TaskName",1,0)) < 0
       )
    {
      StrLastE;
      e = &erb;
    }
    else if (
              fprintf(file,
                      "%s\n\n\t%s",
                      lookup_token("Version:(Unknown!)",0,0),
                      url) < 0
            )
    {
      StrLastE;
      e = &erb;
    }
    else if (
              fprintf(file,
                      "\n\t%s",
                      title ? title : "*") < 0
            )
    {
      StrLastE;
      e = &erb;
    }
  }
  else
  {
    /* URL file */

    if (fprintf(file, url) < 0)
    {
      StrLastE;
      e = &erb;
    }
  }

  /* Close the file and return any error that may have */
  /* happened during the file writing stage            */

  fclose(file);

  if (e) return &erb;

  /* Exit via. setting the filetype */

  return _swix(OS_File,
               _INR(0,2),

               18, /* Set type of named object */
               path,
               write_url ? FileType_URL : FileType_URI);
}

/*************************************************/
/* save_transfer_uri()                           */
/*                                               */
/* Save the contents of a link as a URI file,    */
/* through a RAM transfer buffer with            */
/* Wimp_TransferBlock.                           */
/*                                               */
/* Intended to be called as a response to a      */
/* Message_RAMFetch from another task.           */
/*                                               */
/* Parameters: Pointer to the URL to save;       */
/*                                               */
/*             Pointer to the URL title, or NULL */
/*             / null string for no title;       */
/*                                               */
/*             0 to save as a URI file, else     */
/*             save as a non-terminated string   */
/*             with type FileType_URL (ANT       */
/*             suite URL file);                  */
/*                                               */
/*             Pointer to an int, in which the   */
/*             amount of data transferred so     */
/*             far should be stored on entry;    */
/*                                               */
/*             Pointer to the WimpMessage struct */
/*             corresponding to the              */
/*             Message_RAMFetch that led to this */
/*             function being called.            */
/*                                               */
/* Returns:    The contents of the int holding   */
/*             the amount of data transferred    */
/*             prior to the function call are    */
/*             updated with the new amount       */
/*             transferred. Callers should use   */
/*             this in any future calls, and it  */
/*             *must* be checked for a value of  */
/*             -1, which indicates the transfer  */
/*             is complete (so any tidying up    */
/*             should be done if there is an     */
/*             error returned, or if the int is  */
/*             filled in with a value of -1).    */
/*                                               */
/* Assumes:    The various pointers may be NULL, */
/*             though if they are the function   */
/*             does nothing (it just exits).     */
/*************************************************/

_kernel_oserror * save_transfer_uri(char * url, char * title, int write_url, int * transferred, WimpMessage * m)
{
  _kernel_oserror * e        = NULL;
  char            * uri_file = NULL;
  int               size     = save_uri_size(url, title, write_url);
  int               left;
  int               write;

  /* Sanity check */

  if (title && !*title) title = NULL;

  if (!url || !*url || !transferred || !m)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid parameters to save_transfer_uri: %p, %d, %p, %p",
              url,
              write_url,
              transferred,
              m);

      return &erb;

    #else

      return NULL;

    #endif
  }

  left = size - *transferred;

  /* Each time the function is called, rebuild the URI file in a */
  /* temporary buffer.                                           */

  if (size > 0 && left > 0)
  {
    uri_file = malloc(size + 1); /* + 1 to account for terminators */

    if (!uri_file)
    {
      e = make_no_memory_error(10);
      goto save_transfer_uri_exit;
    }

    /* Build the URI or URL file */

    if (!write_url)
    {
      int written;

      /* URI file */

      written = sprintf(uri_file,
                        "URI\t100\n\t# %s v",
                        lookup_token("_TaskName",1,0));

      written += sprintf(uri_file + written,
                         "%s\n\n\t%s",
                         lookup_token("Version:(Unknown!)",0,0),
                         url);

      written += sprintf(uri_file + written,
                         "\n\t%s",
                         title ? title : "*");
    }
    else
    {
      /* URL file */

      strcpy(uri_file, url);
    }
  }

  /* If we have data to transfer, do so */

  if (left >= 0)
  {
    /* Use either the buffer size, or the bytes left, whichever */
    /* is the smallest.                                         */

    write = left > m->data.ram_fetch.buffer_size ? m->data.ram_fetch.buffer_size : left;

    if (write)
    {
      /* Transfer the data */

      e = wimp_transfer_block(task_handle,
                              uri_file + (*transferred),
                              m->hdr.sender,
                              m->data.ram_fetch.buffer,
                              write);

      if (e) goto save_transfer_uri_exit;
    }

    /* If we have any data left to send, reply with a Message_RAMTransmit */

    e = protocols_atats_send_ram_transmit(m, write, write < m->data.ram_fetch.buffer_size);

    /* Increment the transferred counter */

    *transferred += write;
    left         -= write;
  }

  /* Finished */

save_transfer_uri_exit:

  /* Free the URI file buffer, if we claimed one */

  if (uri_file) free (uri_file);

  return e;
}

/*************************************************/
/* save_uri_size()                               */
/*                                               */
/* Returns the size, in bytes, that a URI or URL */
/* file will be.                                 */
/*                                               */
/* Parameters: Pointer to the URL that would be  */
/*             saved;                            */
/*                                               */
/*             Pointer to the URL title, or NULL */
/*             / null string for no title;       */
/*                                               */
/*             0 to find the length of a URI     */
/*             file, 1 to find the length of a   */
/*             URL file (as in save_save_uri).   */
/*                                               */
/* Returns:    The size, in bytes, that the file */
/*             will be.                          */
/*************************************************/

int save_uri_size(char * url, char * title, int write_url)
{
  int len = 0;

  /* Sanity check */

  if (title && !*title) title = NULL;

  if (!url || !*url)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Invalid parameters to save_uri_size: %p, %d",
              url,
              write_url);

      show_error_ret(&erb);

    #endif

    return 0;
  }

  if (!write_url)
  {
    /* URI file */

    len =  strlen("URI\t100\n\t# ");
    len += strlen(lookup_token("_TaskName",1,0));

    len += strlen(" v");
    len += strlen(lookup_token("Version:(Unknown!)",0,0));

    len += strlen("\n\n\t");
    len += strlen(url);

    len += strlen("\n\t");
    len += strlen(title ? title : "*");
  }
  else
  {
    /* URL file */

    len = strlen(url); /* (No terminator needed in URL files, so no '+ 1') */
  }

  return len;
}

/*************************************************/
/* save_build_messages_path()                    */
/*                                               */
/* Builds a pathname in a malloc block through   */
/* which the Choices or Controls file may be     */
/* accessed. The caller is responsible for       */
/* freeing the block.                            */
/*                                               */
/* Parameters: 0 for the Choices file (to load), */
/*             1 for the Controls file (to       */
/*             load), 2 for the Choices file (to */
/*             save), 3 for the Controls file    */
/*             (to save).                        */
/*                                               */
/* Returns:    Pointer to a null-terminated      */
/*             pathname, in a malloc block, or   */
/*             NULL if there was an error.       */
/*************************************************/

char * save_build_messages_path(int which)
{
  int    len, exists;
  char * path;
  char * sysvar;
  char * defpath;

  len =  strlen(lookup_token("_TaskName", 1, 0));
  len += sizeof("$ControlsFile"); /* Longer than "$ChoicesFile"! */

  sysvar = malloc(len);

  if (!sysvar) return NULL;
  else strcpy(sysvar, tokens);

  switch (which)
  {
    case 0:
    {
      strcat(sysvar, "$ChoicesFile");
      defpath = ".Choices";
    }
    break;

    case 1:
    {
      strcat(sysvar, "$ControlsFile");
      defpath = ".Controls";
    }
    break;

    case 2:
    {
      strcat(sysvar, "$ChoicesSave");
      defpath = ".Choices";
    }
    break;

    case 3:
    {
      strcat(sysvar, "$ControlsSave");
      defpath = ".Controls";
    }
    break;

    default:
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Fatal;

        sprintf(erb.errmess,
                "In open_messages_file, passed unrecognised parameter value '%d'",
                which);

        /* OK, so you'll get the above error and then callers will */
        /* probably think this call ran out of memory due to the   */
        /* NULL return (assuming the below call doesn't cause an   */
        /* immediate exit - it depends on what stage of            */
        /* initialisation the browser is at). But at least you get */
        /* to see what is happening.                               */

        show_error_ret(&erb);
        free(sysvar);

        return NULL;

      #else

        free(sysvar);

        return NULL;

      #endif
    }
  }

  /* First, find the system variable length. Must use _kernel_swi */
  /* here for various reasons.                                    */

  {
    _kernel_swi_regs r;

    r.r[0] = (int) sysvar;
    r.r[1] = (int) NULL;
    r.r[2] = -1;
    r.r[3] = 0;
    r.r[4] = 0;

    /* Equivalent to getenv(), but the RISC OS implementation evaluates */
    /* the system variable as an expression which we don't want (at     */
    /* least, not under RISC OS); hence the direct use of the SWI.      */

    _kernel_swi(OS_ReadVarVal, &r, &r);

    len = -r.r[2]; /* This includes a terminator */
  }

  if (!len)
  {
    /* Variable doesn't exist */

    len    = strlen(task_dir) + strlen(defpath) + 1;
    exists = 0;
  }
  else exists = 1;

  /* Allocate space */

  path = calloc(len + 1, 1);

  if (!path)
  {
    free(sysvar);
    return NULL;
  }

  /* Read the variable or copy the data in */

  if (exists) _swix(OS_ReadVarVal,
                    _INR(0,4),

                    sysvar, /* Variable name                      */
                    path,   /* Buffer                             */
                    len,    /* Size of buffer                     */
                    0,      /* Name pointer (0 for 1st call)      */
                    4);     /* Variable type (4 = literal string) */
  else
  {
    strcpy(path, task_dir);
    strcat(path, defpath);
  }

  free(sysvar);

  return path;
}

/*************************************************/
/* save_save_string()                            */
/*                                               */
/* Output a string                               */
/*                                               */
/* Parameters: Pointer to a FILE struct holding  */
/*             info on the file to write to;     */
/*                                               */
/*             String number to write.           */
/*                                               */
/* Returns:    Number of characters written, or  */
/*             EOF if there was an error.        */
/*************************************************/

static int save_save_string(FILE * file, char * string)
{
  int length;
  if ((length = strlen(string)) == 0) return 0;

  if (fprintf(file, "%s", string) < length) return EOF;

  return length;
}

/*************************************************/
/* save_save_colour()                            */
/*                                               */
/* Output a colour number in the format seen in  */
/* the Choices file, to a given file.            */
/*                                               */
/* Parameters: Pointer to a FILE struct holding  */
/*             info on the file to write to;     */
/*                                               */
/*             Colour number to write.           */
/*                                               */
/* Returns:    Number of characters written, or  */
/*             EOF if there was an error.        */
/*************************************************/

static int save_save_colour(FILE * file, int colour)
{
  if (fprintf(file, "0x%08x", colour) < 10) return EOF;

  return 10;
}

/*************************************************/
/* save_save_number()                            */
/*                                               */
/* Output a number as ASCII, to a given file.    */
/*                                               */
/* Parameters: Pointer to a FILE struct holding  */
/*             info on the file to write to;     */
/*                                               */
/*             Number to write.                  */
/*                                               */
/* Returns:    Number of characters written, or  */
/*             EOF if there was an error.        */
/*************************************************/

static int save_save_number(FILE * file, int number)
{
  char buffer[64];
  int  len;

  len = sprintf(buffer, "%d", number);

  if (fprintf(file, "%s", buffer) < len) return EOF;

  return len;
}

/*************************************************/
/* save_save_yes_no()                            */
/*                                               */
/* Output either 'yes' or 'no' to a given file.  */
/*                                               */
/* Parameters: Pointer to a FILE struct holding  */
/*             info on the file to write to;     */
/*                                               */
/*             0 to write 'no', else 'yes'.      */
/*                                               */
/* Returns:    Number of characters written, or  */
/*             EOF if there was an error.        */
/*************************************************/

static int save_save_yes_no(FILE * file, int yes)
{
  if (!yes)
  {
    if (fprintf(file, "no") < 2) return EOF;
  }
  else
  {
    if (fprintf(file, "yes") < 3) return EOF;
  }

  return !yes ? 2 : 3;
}

/*************************************************/
/* save_save_font()                              */
/*                                               */
/* Saves a typeface definition in the form       */
/* required by the browser font manager.         */
/*                                               */
/* Parameters: Pointer to a FILE struct holding  */
/*             info on the file to write to;     */
/*                                               */
/*             The name of the typeface to save. */
/*                                               */
/* Returns:    Number of characters written, or  */
/*             EOF if there was an error.        */
/*                                               */
/* Assumes:    No sanity checking is given on    */
/*             any of the supplied parameters... */
/*************************************************/

static int save_save_font(FILE * file, const char * typefacename)
{
  fm_typeface * tfptr;

  tfptr = fm_find_typeface((char *) typefacename);

  if (!tfptr) return EOF;

  return fprintf(file,
                 "%s=%s:%s:%s:%s;%s",
                 tfptr->name,
                 tfptr->fontnames[0],
                 tfptr->fontnames[1],
                 tfptr->fontnames[2],
                 tfptr->fontnames[3],
                 tfptr->alternative);
}

/*************************************************/
/* save_save_general()                           */
/*                                               */
/* Save a general item to the given file. This   */
/* is for items with a discrete set of values    */
/* that map to a discrete set of strings.        */
/*                                               */
/* Parameters: Pointer to a FILE struct holding  */
/*             info on the file to write to;     */
/*                                               */
/*             The number of discrete values     */
/*             that the item may take;           */
/*                                               */
/*             Pointer to an array of save_pair  */
/*             name/value pairs holding the      */
/*             names and corresponding values    */
/*             that the item may take;           */
/*                                               */
/*             Value to match out of those given */
/*             in the int array;                 */
/*                                               */
/*             Default item (from 1 to the value */
/*             given in the second parameter) to */
/*             use if the match value is not     */
/*             found in the int array.           */
/*                                               */
/* Returns:    Number of characters written, or  */
/*             EOF if there was an error.        */
/*                                               */
/* Assumes:    No sanity checking is given on    */
/*             any of the supplied parameters... */
/*************************************************/

static int save_save_general(FILE * file, int how_many, const save_pair ns[], int match, int def)
{
  int          i, found = 0;
  const char * string   = NULL;
  int          sl;

  /* Try to find the match value in the array of ints */

  for (i = 0; i < how_many && !found; i++)
  {
    if (ns[i].value == match) string = ns[i].name, found = 1;
  }

  /* If not found, raise an error in TRACE builds, and pick */
  /* the given default string                               */

  if (!found)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "Match value '%d' not found in save_save_general (",
              match);

      for (
            i = 0;
            i < how_many && strlen(erb.errmess) + strlen(ns[i].name) + 9 < sizeof(erb.errmess);
            i++
          )
      {
        strcat(erb.errmess, ns[i].name);
        if (i != how_many - 1) strcat(erb.errmess, ", ");

        if (i == how_many - 2) strcat(erb.errmess, "or ");
      }

      strcat(erb.errmess, ").");

      show_error_ret(&erb);

    #endif

    if (def > how_many) def = how_many;

    string = ns[def - 1].name;
  }

  /* Output the item to the file */

  if (!string) return EOF;

  sl = strlen(string);

  if (fprintf(file, "%s", string) < sl) return EOF;

  return sl;
}

/*************************************************/
/* save_save_simple_choice_item()                */
/*                                               */
/* Write the value of a Choices file item in a   */
/* specified format to the current file position */
/* in the give file.                             */
/*                                               */
/* Parameters: Pointer to a FILE structure with  */
/*             details on the file to write to;  */
/*                                               */
/*             Value of the item cast to an int; */
/*                                               */
/*             save_method to use for saving     */
/*             (see top of function), e.g.       */
/*             Save_SaveColour.                  */
/*************************************************/

static int save_save_simple_choice_item(FILE * file, int value, save_method method)
{
  switch (method)
  {
    default:
    case Save_SaveNumber:   return save_save_number (file, (int)    value);        break;
    case Save_SaveInKBytes: return save_save_number (file, (int)    value / 1024); break;
    case Save_SaveString:   return save_save_string (file, (char *) value);        break;
    case Save_SaveColour:   return save_save_colour (file, (int)    value);        break;
    case Save_SaveYesNo:    return save_save_yes_no (file, (int)    value);        break;
  }
}

/*************************************************/
/* save_save_simple_choice()                     */
/*                                               */
/* For use in a two-pass Choices save routine.   */
/*                                               */
/* If given a pointer to an entry name to match  */
/* (and the length of that entry name) and a     */
/* pointer to the entry name of the current item */
/* being considered, this will write the value   */
/* of the item to the current file position in   */
/* the given file if there's a match (and so     */
/* returns either EOF for error or non-zero).    */
/*                                               */
/* If given NULL and a pointer to the entry name */
/* of the current item being considered, this    */
/* will check the value of a flag and if clear   */
/* will write both the entry name and value to   */
/* the current file position of the given file.  */
/*                                               */
/* Parameters: Pointer to a FILE structure with  */
/*             details on the file to write to;  */
/*                                               */
/*             Pointer to the entry name we are  */
/*             trying to match, or NULL to       */
/*             write this entry if the flag (see */
/*             below) says it hasn't been        */
/*             written before;                   */
/*                                               */
/*             Length of the above entry name,   */
/*             or 0 if the above is NULL;        */
/*                                               */
/*             Pointer to the entry name under   */
/*             consideration that will either be */
/*             compared with the name given      */
/*             above or written to the file if   */
/*             the flag (see below) says it      */
/*             hasn't already been;              */
/*                                               */
/*             Value of the item under consider- */
/*             ation cast as an int;             */
/*                                               */
/*             save_method to use for saving     */
/*             (see top of function), e.g.       */
/*             Save_SaveColour;                  */
/*                                               */
/*             A flag used if the second param-  */
/*             eter is NULL, which is 1 to say   */
/*             'do write this' or 0 to say 'do   */
/*             not write this'.                  */
/*                                               */
/* Returns:    Amount of data written, or EOF if */
/*             there was an error.               */
/*                                               */
/* Assumes:    No pointer is NULL unless stated  */
/*             above that it may be.             */
/*************************************************/

static int save_save_simple_choice(FILE * file, const char * p, int len, const char * tagname,
                                   int value, save_method method, int flag)
{
  /* If p is set, this is the first pass - looking for existing items */

  if (p)
  {
    if (!strncmp(p, tagname, len))
    {
      return save_save_simple_choice_item(file, value, method);
    }
  }

  /* Otherwise, must write the tagname too */

  else
  {
    /* Only write the item if it wasn't written in the first pass */

    if (!flag)
    {
      int length = strlen(tagname);
      int result;

      if      (fprintf(file, "%s", tagname) < length)                               return EOF;
      else if (!fprintf(file, ":"))                                                 return EOF;
      else if ((result = save_save_simple_choice_item(file, value, method)) == EOF) return EOF;
      else if (!fprintf(file, "\n"))                                                return EOF;
      else                                                                          return length + result + 3;
    }
  }

  return 0;
}

/*************************************************/
/* save_save_font_choice()                       */
/*                                               */
/* As save_save_simple_choice, but for fonts.    */
/*                                               */
/* Parameters: Pointer to a FILE structure with  */
/*             details on the file to write to;  */
/*                                               */
/*             Pointer to the entry name we are  */
/*             trying to match, or NULL to       */
/*             write this entry if the flag (see */
/*             below) says it hasn't been        */
/*             written before;                   */
/*                                               */
/*             Length of the above entry name,   */
/*             or 0 if the above is NULL;        */
/*                                               */
/*             Pointer to the entry name under   */
/*             consideration that will either be */
/*             compared with the name given      */
/*             above or written to the file if   */
/*             the flag (see below) says it      */
/*             hasn't already been;              */
/*                                               */
/*             Pointer to the typeface variant   */
/*             name ("fixed", "sans", "serif");  */
/*                                               */
/*             A flag used if the second param-  */
/*             eter is NULL, which is 1 to say   */
/*             'do write this' or 0 to say 'do   */
/*             not write this'.                  */
/*                                               */
/* Returns:    Amount of data written, or EOF if */
/*             there was an error.               */
/*                                               */
/* Assumes:    No pointer is NULL unless stated  */
/*             above that it may be.             */
/*************************************************/

static int save_save_font_choice(FILE * file, const char * p, int len, const char * tagname,
                                 const char * variant, int flag)
{
  if (p)
  {
    if (!strncmp(p, tagname, len))
    {
      return save_save_font(file, variant);
    }
  }
  else
  {
    if (!flag)
    {
      int length = sizeof(tagname) - 1;
      int result;

      if      (fprintf(file, "%s", tagname) < length)           return EOF;
      else if (!fprintf(file, ":"))                             return EOF;
      else if ((result = save_save_font(file, variant)) == EOF) return EOF;
      else if (!fprintf(file, "\n"))                            return EOF;
      else                                                      return length + result + 3;
    }
  }

  return 0;
}

/*************************************************/
/* save_save_varied_choice()                     */
/*                                               */
/* As save_save_simple_choice, but designed for  */
/* those items which have a set of values which  */
/* correspond to particular words that must be   */
/* written to the Choices file (e.g. table       */
/* border types of 'auto', '2d', '3d' etc.).     */
/*                                               */
/* See save_save_simple_choice for more info.    */
/*                                               */
/* Parameters: Pointer to a FILE structure with  */
/*             details on the file to write to;  */
/*                                               */
/*             Pointer to the entry name we are  */
/*             trying to match, or NULL to       */
/*             write this entry if the flag (see */
/*             below) says it hasn't been        */
/*             written before;                   */
/*                                               */
/*             Length of the above entry name,   */
/*             or 0 if the above is NULL;        */
/*                                               */
/*             Pointer to the entry name under   */
/*             consideration that will either be */
/*             compared with the name given      */
/*             above or written to the file if   */
/*             the flag (see below) says it      */
/*             hasn't already been;              */
/*                                               */
/*             Value of the item under consider- */
/*             ation cast as an int;             */
/*                                               */
/*             Number of different values the    */
/*             item can take;                    */
/*                                               */
/*             Default value to use if the item  */
/*             seems to have an out-of-range     */
/*             value assigned to it;             */
/*                                               */
/*             Pointer to an array of save_pair  */
/*             name/value pairs holding the      */
/*             names and corresponding values    */
/*             that the item may take;           */
/*                                               */
/*             A flag used if the second param-  */
/*             eter is NULL, which is 1 to say   */
/*             'do write this' or 0 to say 'do   */
/*             not write this'.                  */
/*                                               */
/* Returns:    Amount of data written, or EOF if */
/*             there was an error.               */
/*                                               */
/* Assumes:    No pointer is NULL unless stated  */
/*             above that it may be.             */
/*************************************************/

static int save_save_varied_choice(FILE * file, const char * p, int len, const char * tagname, int value,
                                   int num, int def, const save_pair ns[], int flag)
{
  /* If p is set, this is the first pass - looking for existing items */

  if (p)
  {
    if (!strncmp(p, tagname, len))
    {
      return save_save_general(file, num, ns, value, def);
    }
  }

  /* Otherwise, must write the tagname too */

  else
  {
    /* Only write the item if it wasn't written in the first pass */

    if (!flag)
    {
      int length = strlen(tagname);
      int result;

      if      (fprintf(file, "%s", tagname) < length)                          return EOF;
      else if (!fprintf(file, ":"))                                            return EOF;
      else if ((result = save_save_general(file, num, ns, value, def)) == EOF) return EOF;
      else if (!fprintf(file, "\n"))                                           return EOF;
      else                                                                     return length + result + 3;
    }
  }

  return 0;
}

/*************************************************/
/* save_save_choices()                           */
/*                                               */
/* Saves out the Choices file to either the      */
/* given path or to the path constructed in      */
/* save_build_messages_page. Uses the global     */
/* Choices block as the source of what should be */
/* written.                                      */
/*                                               */
/* Parameters: Pointer to a null-terminated path */
/*             to write the file to, or NULL for */
/*             default (see description above).  */
/*************************************************/

_kernel_oserror * save_save_choices(char * path)
{
  _kernel_oserror * e                 = NULL;

  FILE            * file              = NULL;
  char            * out               = NULL;
  char            * canonicalised_out = NULL;

  char            * p                 = NULL; /* Moves through the file loaded into a malloc block. */
  char            * op                = NULL; /* Remembers the start address of the block.          */
  char            * en;                       /* Remembers the end address of the block.            */

  int               size;
  int               type;
  int               pass;

  int               saved_t1          = 0;    /* Nasty special casing stuff for typeface saving.    */
  int               saved_t2          = 0;
  int               saved_t3          = 0;

  global_choices    flags; /* Used to mark if a particular item has been saved or not */

  #ifdef TRACE
    if (tl & (1u<<26)) Printf("save_save_choices: Called\n");
  #endif

  memset(&flags, 0, sizeof(flags));

  /* Find out where to get the file from */

  if (path && *path) out = path;
  else               out = save_build_messages_path(2);

  if (!out) return make_no_memory_error(14);

  /* Now ensure the path is there */

  (utils_canonicalise_path(out, &canonicalised_out));

  /* Can get rid of 'out' if we allocated it locally */

  if (!path || !*path)
  {
    free(out);
    out = NULL;
  }

  if (!canonicalised_out) return make_no_memory_error(14);

  #ifdef TRACE
    if (tl & (1u<<26)) Printf("save_save_choices: Working with file '%s'\n", canonicalised_out);
  #endif

  /* Ensure this path is available */

  e = utils_build_tree(canonicalised_out);
  if (e) goto save_save_choices_read_error;

  /* Find out how big the file is - for this of course, use */
  /* the *load* path, not the canonicalised save path       */
  {
    char * load_path = save_build_messages_path(0);

    if (!load_path)
    {
      free(canonicalised_out);

      return make_no_memory_error(14);
    }

    e = _swix(OS_File,
              _INR(0,1) | _OUT(0) | _OUT(4),

              17,
              load_path,

              &type,
              &size);

    /* Throw the local path away - want to minimise how many */
    /* malloc blocks we're juggling for fear of opening up a */
    /* memory leak in here                                   */

    free(load_path);

    if (e || type != 1) goto save_save_choices_read_error;
  }

  /* Allocate memory for the file */

  p = malloc(size + 1);

  if (!p)
  {
    free(canonicalised_out);

    return make_no_memory_error(14);
  }

  en = p + size;
  op = p;

  /* Read the file into memory - again, use the load path */
  /* not the save path. Rebuild this path to avoid having */
  /* any more malloc blocks flying about (see comments    */
  /* earlier) - it doesn't take long to do this, and the  */
  /* function isn't speed critical anyway.                */

  {
    char * load_path = save_build_messages_path(0);

    if (!load_path)
    {
      free(canonicalised_out);
      free(op);

      return make_no_memory_error(14);
    }

    e = _swix(OS_File,
              _INR(0,3),

              16,
              load_path,
              p,
              0);

    free(load_path);

    if (e) goto save_save_choices_read_error;
  }

  /* Force a null terminator at the end, so strchr() calls */
  /* (or equivalent code fragments) don't run off the end  */
  /* of the block.                                         */

  p[size] = 0;

  /* Open it for writing */

  file = fopen(canonicalised_out, "wb");

  if (!file) goto save_save_choices_write_error;

  /* Two passes. One updates values of items found in the existing */
  /* Choices file, the second adds any items not yet saved to the  */
  /* end - e.g. !Browse.Choices may be up to date, but the copy in */
  /* !Boot.Choices.WWW.Browse may well be fairly old.              */

  for (pass = 0; pass < 2; pass ++)
  {
    /* Use the original file in memory as a reference for */
    /* writing the new one.                               */

    do
    {
      if (!pass && (*p == '#' || *p < ' '))
      {
        /* In the first pass, look for comments or white space, */
        /* and output until an end of line marker if found.     */

        while (*p >= ' ')
        {
          if (fputc(*p++, file) == EOF) goto save_save_choices_write_error;
        }

        /* Output any control characters - we thus preserve   */
        /* CR, LF, CR+LF or whatever was in the original file */

        while (*p < ' ' && p < en)
        {
          if (fputc(*p++, file) == EOF) goto save_save_choices_write_error;
        }
      }

      else
      {
        char * token_end = NULL;
        int    len       = 0;

        /* On the first pass, if not comments or white space, must have a token; */
        /* find the name. On the second pass we drop through to here anyway.     */

        if (!pass)
        {
          token_end = p;

          /* Search for a ':', but don't go off the end of a line */

          while (*token_end > 31 && *token_end != ':') token_end++;

          len = token_end - p; /* Doesn't include ':' in the count */
        }

        /* Provided this is the second pass or we've found a token name, continue */

        if (pass || (*token_end == ':' && len))
        {
          int    i, result = 0;
          char * pcurr     = pass ? NULL : p;

          /* In the first pass, output the token name to start with */

          for (i = 0; pcurr && i <= len; i++) /* '<=' to include the ':' */
          {
            if (fputc(p[i], file) == EOF) goto save_save_choices_write_error;
          }

          /* First, some macros. SaveCheck is called after trying to output an item; */
          /* if we get back EOF, jump to the error routine, else if we get back a    */
          /* non-zero value and we're on the first pass, the value was written out   */
          /* successfully so jump past all the other checks to get the next line.    */
          /*                                                                         */
          /* Yes, yes, 'goto' isn't a nice approach, but it works particularly       */
          /* effectively here.                                                       */

          #define SaveCheck(var, type)               do                                                                           \
                                                     {                                                                            \
                                                       if (result == EOF) goto save_save_choices_write_error;                     \
                                                       else if (result && !pass)                                                  \
                                                       {                                                                          \
                                                         flags.var = (type) 1;                                                    \
                                                         goto save_save_choices_item_written;                                     \
                                                       }                                                                          \
                                                     }                                                                            \
                                                     while (0)

          /* Use this to save a simple item (i.e. yes/no, number, string, font, colour) */

          #define SaveSimple(tag, var, type, method) do                                                                           \
                                                     {                                                                            \
                                                       result = save_save_simple_choice(file, pcurr, len, tag,                    \
                                                                                        (int) choices.var, method,                \
                                                                                        (int) flags.var);                         \
                                                       SaveCheck(var, type);                                                      \
                                                     }                                                                            \
                                                     while (0)

          /* Use this to save an item that can take several discrete string values */

          #define SaveVaried(tag, var, type, def)    do                                                                           \
                                                     {                                                                            \
                                                       result = save_save_varied_choice(file, pcurr, len, tag, (int) choices.var, \
                                                                                        sizeof(ns) / sizeof(save_pair), def, ns,  \
                                                                                        (int) flags.var);                         \
                                                       SaveCheck(var, type);                                                      \
                                                     }                                                                            \
                                                     while (0)

          /* Finally, font choices need a special routine */

          #define SaveFont(tag, variant, flag)       do                                                                           \
                                                     {                                                                            \
                                                       result = save_save_font_choice  (file, pcurr, len, tag, variant, flag);    \
                                                                                                                                  \
                                                       if (result == EOF) goto save_save_choices_write_error;                     \
                                                       else if (result && !pass)                                                  \
                                                       {                                                                          \
                                                         flag = 1;                                                                \
                                                         goto save_save_choices_item_written;                                     \
                                                       }                                                                          \
                                                     }                                                                            \
                                                     while (0)

          /* Now it just gets tedious...! NB, to avoid finding 'Type' */
          /* when checking 'TypeFace', say, make sure you organise    */
          /* these in decreasing order of length (i.e. longest first) */
          /* and, to be tidy, in alphabetical order within each       */
          /* length group.                                            */

          /* 16 chars */

          SaveSimple("AutoScrollMargin",   auto_scroll_margin, int,    Save_SaveNumber);
          SaveSimple("MSIE4StyleTables",   msie4_style_tables, int,    Save_SaveYesNo);

          {
            static const save_pair ns[] = { { "never",  Choices_SaveImageHistory_Never  },
                                            { "once",   Choices_SaveImageHistory_Once   },
                                            { "always", Choices_SaveImageHistory_Always } };

            SaveVaried("SaveImageHistory", save_image_history, int,    Choices_SaveImageHistory_Once);
          }

          SaveSimple("UnusedImageLimit",   unused_image_limit, int,    Save_SaveNumber);

          /* 15 chars */

          SaveSimple("AutoScrollDelay",    auto_scroll_delay,  int,    Save_SaveNumber);
          SaveSimple("MinimumFontSize",    minimum_font_size,  int,    Save_SaveNumber);

          /* 14 chars */

          SaveSimple("ImageExpiryAge",     image_expiry_age,   int,    Save_SaveNumber);
          SaveSimple("UnderlineLinks",     underline_links,    int,    Save_SaveYesNo);
          SaveSimple("ShowForeground",     show_foreground,    int,    Save_SaveYesNo);
          SaveSimple("ShowBackground",     show_background,    int,    Save_SaveYesNo);

          /* 13 chars */

          SaveSimple("AutoOpenDelay",      auto_open_delay,    int,    Save_SaveNumber);

          {
            static const save_pair ns[] = { { "never",  Choices_PlugIns_Never  },
                                            { "viewed", Choices_PlugIns_Viewed },
                                            { "asap",   Choices_PlugIns_ASAP   } };

            SaveVaried("PlugInControl",    plugin_control,     int,    Choices_PlugIns_Viewed);
          }

          SaveSimple("ShowMayScroll",      show_may_scroll,    int,    Save_SaveYesNo);
          SaveSimple("SupportFrames",      support_frames,     int,    Save_SaveYesNo);
          SaveSimple("SupportObject",      support_object,     int,    Save_SaveYesNo);
          SaveSimple("SupportTables",      support_tables,     int,    Save_SaveYesNo);
          SaveSimple("ToggleOnXOnly",      toggle_on_x_only,   int,    Save_SaveYesNo);
          SaveSimple("UseSourceCols",      use_source_cols,    int,    Save_SaveYesNo);

          /* 12 chars */

          SaveSimple("CollectAfter",       collect_after,      int,    Save_SaveYesNo);
          SaveSimple("DragToScroll",       drag_to_scroll,     int,    Save_SaveYesNo);
          SaveSimple("FreeRAMLimit",       free_ram_limit,     int,    Save_SaveNumber);
          SaveSimple("HighlightLks",       highlight_links,    int,    Save_SaveYesNo);
          SaveSimple("ImageMaxSize",       image_max_size,     int,    Save_SaveInKBytes);
          SaveSimple("NoScrollBars",       no_scroll_bars,     int,    Save_SaveYesNo);
          SaveSimple("ProxyAddress",       proxy_address,      char *, Save_SaveString);

          {
            static const save_pair ns[] = { { "os",       Choices_SupportPJPEG_OS       },
                                            { "both",     Choices_SupportPJPEG_Both     },
                                            { "internal", Choices_SupportPJPEG_Internal } };

            SaveVaried("SupportPJPEG",     support_pjpeg,      int,    Choices_SupportPJPEG_Both);
          }

          /* 11 chars */

          {
            static const save_pair ns[] = { { "urls",         Choices_HotlistType_URLs         },
                                            { "descriptions", Choices_HotlistType_Descriptions } };

            SaveVaried("HotlistType",      hotlist_show,       int,    Choices_HotlistType_Descriptions);
          }

          SaveSimple("KeyboardCtl",        keyboard_ctrl,      int,    Save_SaveYesNo);

          {
            static const save_pair ns[] = { { "never",  Choices_MoveGadgets_Never  },
                                            { "atend",  Choices_MoveGadgets_AtEnd  },
                                            { "during", Choices_MoveGadgets_During } };

            SaveVaried("MoveGadgets",      move_gadgets,       int,    Choices_MoveGadgets_During);
          }

          SaveSimple("QuoteMargin",        quote_margin,       int,    Save_SaveNumber);
          SaveSimple("RightMargin",        right_margin,       int,    Save_SaveNumber);

          {
            static const save_pair ns[] = { { "never",  Choices_SaveHistory_Never  },
                                            { "once",   Choices_SaveHistory_Once   },
                                            { "always", Choices_SaveHistory_Always } };

            SaveVaried("SaveHistory",      save_history,       int,    Choices_SaveHistory_Always);
          }

          {
            static const save_pair ns[] = { { "never",  Choices_SaveHotlist_Never  },
                                            { "once",   Choices_SaveHotlist_Once   },
                                            { "always", Choices_SaveHotlist_Always } };

            SaveVaried("SaveHotlist",      save_hotlist,       int,    Choices_SaveHotlist_Always);
          }

          {
            static const save_pair ns[] = { { "never",     Choices_SendReferer_Never    },
                                            { "always",    Choices_SendReferer_Always   },
                                            { "when http", Choices_SendReferer_WhenHTTP } };

            SaveVaried("SendReferer",      send_referer,       int,    Choices_SendReferer_WhenHTTP);
          }

          {
            static const save_pair ns[] = { { "no",     Choices_SolidResize_No     },
                                            { "yes",    Choices_SolidResize_Yes    },
                                            { "always", Choices_SolidResize_Always } };

            SaveVaried("SolidResize",      solid_resize,       int,    Choices_SolidResize_Always);
          }

          /* 10 chars */

          {
            static const save_pair ns[] = { { "top",    Choices_AddHotlist_Top    },
                                            { "bottom", Choices_AddHotlist_Bottom } };

            SaveVaried("AddHotlist",       add_hotlist,        int,    Choices_AddHotlist_Bottom);
          }

          SaveSimple("BackColour",         background_colour,  int,    Save_SaveColour);
          SaveSimple("ClientPull",         client_pull,        int,    Save_SaveYesNo);
          SaveSimple("FollColour",         followed_colour,    int,    Save_SaveColour);
          SaveSimple("FullScreen",         full_screen,        int,    Save_SaveYesNo);
          SaveSimple("JSWatchdog",         js_watchdog,        int,    Save_SaveYesNo);
          SaveSimple("LeftIndent",         left_indent,        int,    Save_SaveNumber);
          SaveSimple("LeftMargin",         left_margin,        int,    Save_SaveNumber);
          SaveSimple("LinkColour",         link_colour,        int,    Save_SaveColour);
          SaveSimple("SeeFetches",         see_fetches,        int,    Save_SaveYesNo);
          SaveSimple("SeleColour",         selected_colour,    int,    Save_SaveColour);
          SaveSimple("StartProxy",         start_proxy,        int,    Save_SaveYesNo);
          SaveSimple("SystemFont",         system_font,        int,    Save_SaveYesNo);

          {
            static const save_pair ns[] = { { "2d",    Choices_TableInner_Always2D },
                                            { "auto",  Choices_TableInner_Auto     },
                                            { "3d",    Choices_TableInner_Always3D },
                                            { "never", Choices_TableInner_Never    } };

            SaveVaried("TableInner",       table_inner,        int,    Choices_TableInner_Auto);
          }

          {
            static const save_pair ns[] = { { "2d",    Choices_TableOuter_Always2D },
                                            { "auto",  Choices_TableOuter_Auto     },
                                            { "3d",    Choices_TableOuter_Always3D },
                                            { "never", Choices_TableOuter_Never    } };

            SaveVaried("TableOuter",       table_outer,        int,    Choices_TableOuter_Auto);
          }

          SaveSimple("TextColour",         text_colour,        int,    Save_SaveColour);
          SaveSimple("UsedColour",         used_colour,        int,    Save_SaveColour);

          /* 9 chars */

          SaveSimple("ButtonBar",          button_bar,         int,    Save_SaveYesNo);
          SaveSimple("ExpiryAge",          expiry_age,         int,    Save_SaveNumber);
          SaveSimple("JSTimeout",          js_timeout,         int,    Save_SaveNumber);
          SaveSimple("MaxImages",          max_images,         int,    Save_SaveNumber);
          SaveSimple("OverrideX",          override_x,         int,    Save_SaveNumber);
          SaveSimple("OverrideY",          override_y,         int,    Save_SaveNumber);
          SaveSimple("StatusBar",          status_bar,         int,    Save_SaveYesNo);
          SaveSimple("SupportJS",          support_js,         int,    Save_SaveYesNo);

          /* Typefaces, rather annoyingly, are an odd special case */

          SaveFont("Typeface1", "fixed", saved_t1);
          SaveFont("Typeface2", "sans",  saved_t2);
          SaveFont("Typeface3", "serif", saved_t3);

          /* 8 chars */

          SaveSimple("Encoding",           encoding,           int,    Save_SaveNumber);
          SaveSimple("FixedPtr",           fixed_pointer,      int,    Save_SaveYesNo);
          SaveSimple("FontSize",           font_size,          int,    Save_SaveNumber);
          SaveSimple("HomePage",           home_page,          char *, Save_SaveString);
          SaveSimple("RefoHold",           refo_hold,          int,    Save_SaveYesNo);
          SaveSimple("RefoKeep",           refo_keep,          int,    Save_SaveYesNo);
          SaveSimple("RefoTime",           refo_time,          int,    Save_SaveNumber);
          SaveSimple("RefoWait",           refo_wait,          int,    Save_SaveYesNo);
          SaveSimple("ShowURLs",           show_urls,          int,    Save_SaveYesNo);
          SaveSimple("TTAspect",           tt_aspect,          int,    Save_SaveNumber);

          {
            static const save_pair ns[] = { { "never",                 Choices_URI_Never                 },
                                            { "requests only",         Choices_URI_RequestsOnly          },
                                            { "unknowns only",         Choices_URI_BroadcastUnknowns     },
                                            { "unknowns and requests", Choices_URI_UnknownsAndRequests   },
                                            { "everything",            Choices_URI_EverythingAndRequests } };

            SaveVaried("URIUsage",         uri_usage,          int,    Choices_URI_UnknownsAndRequests);
          }

          SaveSimple("UseProxy",           use_proxy,          int,    Save_SaveYesNo);

          /* 7 chars */

          {
            static const save_pair ns[] = { { "reject", Choices_Cookies_Reject },
                                            { "prompt", Choices_Cookies_Prompt },
                                            { "accept", Choices_Cookies_Accept } };

            SaveVaried("Cookies",          cookies,            int,    Choices_Cookies_Accept);
          }

          {
            static const save_pair ns[] = { { "no",   Choices_HScroll_No   },
                                            { "yes",  Choices_HScroll_Yes  },
                                            { "auto", Choices_HScroll_Auto } };

            SaveVaried("HScroll",          h_scroll,           int,    Choices_HScroll_Auto);
          }
          SaveSimple("Leading",            leading,            int,    Save_SaveNumber);

          #ifndef SINGLE_USER
            SaveSimple("PostOut",          post_out,           char *, Save_SaveString);
          #endif

          SaveSimple("MaxSize",            max_size,           int,    Save_SaveInKBytes);

          {
            static const save_pair ns[] = { { "no",   Choices_VScroll_No   },
                                            { "yes",  Choices_VScroll_Yes  },
                                            { "auto", Choices_VScroll_Auto } };

            SaveVaried("VScroll",          v_scroll,           int,    Choices_VScroll_Auto);
          }

          /* 6 chars */

          SaveSimple("Height",             height,             int,    Save_SaveNumber);

          #ifndef SINGLE_USER
            SaveSimple("PostIn",           post_in,            char *, Save_SaveString);
          #endif

          SaveSimple("URLbar",             url_bar,            int,    Save_SaveYesNo);

          /* 5 chars */

          SaveSimple("Clone",              clone,              int,    Save_SaveYesNo);
          SaveSimple("Width",              width,              int,    Save_SaveNumber);

          /* If we reach here, then on the first pass, this seems to be a line */
          /* containing a token but we don't recognise the token name. So, as  */
          /* with other unrecognised lines, just output it 'as was'.           */

          if (!pass)
          {
            #ifdef TRACE

              if (tl & (1u<<26))
              {
                Printf("save_save_choices: Unrecognised token '");

                for (i = 0; i <= len; i++)
                {
                  Printf("%c", p[i]);
                }

                Printf("'\n");
              }

            #endif

            p += len + 1;
            while (*p >= ' ' && result != EOF) fputc(*p++, file);
          }

save_save_choices_item_written:

          if (result == EOF) goto save_save_choices_write_error;

          if (!pass)
          {
            /* Skip to the end of the line */

            while (*p >= ' ') p++;

            /* Output any control characters - we thus preserve   */
            /* CR, LF, CR+LF or whatever was in the original file */

            while (*p < ' ' && p < en)
            {
              if (fputc(*p++, file) == EOF) goto save_save_choices_write_error;
            }
          }
        }
        else
        {
          /* In the first pass, unrecognised line contents (neither a comment */
          /* nor, apparently, a token name); spit out the whole line.         */

          #ifdef TRACE

            if (tl & (1u<<26))
            {
              int i = 0;

              Printf("save_save_choices: Unknown line fragment '");

              while (p[i] >= ' ')
              {
                Printf("%c", p[i++]);
              }

              Printf("'\n");
            }

          #endif

          while (*p >= ' ')
          {
            if (fputc(*p++, file) == EOF) goto save_save_choices_write_error;
          }
        }
      }
    }
    while (!pass && p && p < en);
  }

  /* Close the output file */

  fclose(file);

  /* Set the filetype - not essential, just nice to have, so */
  /* let it fail silently.                                   */

  _swix(OS_File,
        _INR(0,2),

        18, /* Set type of named object */
        canonicalised_out,
        FileType_TEXT);

  /* Free the canonicalised path */

  free(canonicalised_out);

  /* Free the old Choices file */

  free(op);

  /* Finished */

  #ifdef TRACE
    if (tl & (1u<<26)) Printf("save_save_choices: Successful\n");
  #endif

  return NULL;

  /* Error condition exits */

save_save_choices_read_error:

  if (!path || !*path) free(out);

  free(op);
  free(canonicalised_out);

  erb.errnum = Utils_Error_Custom_Message;

  StrNCpy0(erb.errmess,
           lookup_token("COChoices:Can't open the Choices file - the preferences cannot be saved.",
                        0,
                        0));

  #ifdef TRACE
    if (tl & (1u<<26)) Printf("save_save_choices: Can't open Choices file, exitting\n");
  #endif

  return &erb;

save_save_choices_write_error:

  StrLastE;

  if (file) fclose(file);

  /* We really want to avoid leaving a broken Choices file, so */
  /* have a last ditch go at dumping the original file down.   */

  _swix(OS_File,
        _INR(0,2) | _INR(4,5),

        10,
        out,
        FileType_TEXT,
        op,
        en);

  /* Free any temporary blocks */

  if (!path || !*path) free(out);

  free(op);
  free(canonicalised_out);

  #ifdef TRACE
    if (tl & (1u<<26)) Printf("save_save_choices: Exitting with error\n");
  #endif

  return &erb;
}
