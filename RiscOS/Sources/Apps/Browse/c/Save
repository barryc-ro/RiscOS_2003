/***************************************************/
/* File   : Save.c                                 */
/* Purpose: Save functions for the browser         */
/* Author : A.D.Hodgkinson                         */
/* History: 04-Dec-96: Created                     */
/***************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "swis.h"
#include "flex.h"

#include "wimp.h"
#include "event.h"

#include "toolbox.h"
#include "window.h"
#include "menu.h"
#include "saveas.h"

#include "svcprint.h"
#include "Global.h"
#include "TBEvents.h"
#include "Utils.h"

#include "URLutils.h"

#include "Save.h"

/* Locals */

static browser_data * save_origin = NULL;
static ObjectId       save_dbox   = 0;

//static char         * save_buffer = NULL;

/*************************************************/
/* save_return_dialogue_id()                     */
/*                                               */
/* Returns the object ID of the currently open   */
/* save dialogue. This may be 0 if none has been */
/* opened, or if it was closed through normal    */
/* methods (successful save).                    */
/*                                               */
/* Returns: Object ID of the current save dbox.  */
/*************************************************/

ObjectId save_return_dialogue_id(void)
{
  return save_dbox;
}

/*************************************************/
/* save_fill_in()                                */
/*                                               */
/* Examines where the SaveAs_AboutToBeShown      */
/* event (which led to this function being       */
/* called) came from, and then calls a function  */
/* relevant to that source.                      */
/*                                               */
/* Parameters are as for a standard Toolbox      */
/* event handler.                                */
/*************************************************/

int save_fill_in(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  switch (idb->parent_component)
  {
    case -1:
    case SaveSetAsHTML:
    case SaveAsHTML: return (save_fill_for_html(idb));
    break;

    case SaveHotlist:
    break;

    case ExportAsDraw:
    break;

    case ExportAsText:
    break;

    case ExportLink:
    break;

    case ExportSprite:
    break;

    #ifdef TRACE
      default:
      {
        erb.errnum = 0;
        StrNCpy0(erb.errmess,
                 "WhatSve:Internal error - Save dialogue origin not understood in save_fill_in().");

        show_error_cont(&erb);
      }
      break;
    #endif
  }

  return 1;
}

/*************************************************/
/* save_fill_for_html()                          */
/*                                               */
/* Fills in the Save As dialogue for saving an   */
/* HTML file.                                    */
/*                                               */
/* Parameters: An ID block containing the ID of  */
/*             the save dialogue in self_id, and */
/*             the ID of the browser window in   */
/*             ancestor_id (e.g. as passed in to */
/*             a Toolbox event handler).         */
/*                                               */
/* Returns:    1 for success, 0 for failure.     */
/*************************************************/

int save_fill_for_html(IdBlock *idb)
{
  browser_data * b;

  ChkError(toolbox_get_client_handle(0, idb->ancestor_id, (void *) &b));

  if (!b) return 0;

  /* For saving a frameset, work out the required browser_data struct */

  if (idb->parent_component == SaveSetAsHTML)
  {
    if      (b->parent      && b->parent     ->source) b = b->parent;
    else if (b->real_parent && b->real_parent->source) b = b->real_parent;
    else if (b->ancestor    && b->ancestor   ->source) b = b->ancestor;
  }

  /* Remember which browser the save dialogue was for, */
  /* and the dialogue's object ID.                     */

  save_origin = b;
  save_dbox   = idb->self_id;

  /* Reset the transferred data counter */

  b->savetransferred = 0;

  /* Only fill it in if there's document source */

  if (b->source)
  {
    char test[1024];

    ChkError(saveas_get_file_name(0,
                                  idb->self_id,
                                  test,
                                  sizeof(test),
                                  NULL));

    /* If there's not already a path filled in, then set just the file name */

    if (!strstr(test,".")) ChkError(saveas_set_file_name(0,
                                                         idb->self_id,
                                                         urlutils_leafname_from_url(b->urlddata,
                                                                                    test,
                                                                                    sizeof(test))));

    /* Set the filetype and estimated file size (of coure, if */
    /* more document comes in underneath the save window this */
    /* will become inaccurate).                               */

    ChkError(saveas_set_file_type(0,
                                  idb->self_id,
                                  FileType_HTML));

    ChkError(saveas_set_file_size(0,
                                  idb->self_id,
                                  flex_size((flex_ptr) &b->source)));

//    ChkError(saveas_set_data_address(0,
//                                     idb->self_id,
//                                     b->source,
//                                     flex_size((flex_ptr) &b->source),
//                                     NULL,
//                                     0));

    return 1;
  }

  else return 0;
}

/*************************************************/
/* save_save_to_file()                           */
/*                                               */
/* Saves document source to a file. Parameters   */
/* are as standard for a Toolbox event handler   */
/* responding to a SaveAs_SaveToFile event.      */
/*************************************************/

int save_save_to_file(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int file_type;

  if (!save_origin) return 0;

  ChkError(saveas_get_file_type(0, idb->self_id, &file_type));

  /* Using RISC OS SWIs rather than C functions as */
  /* the former are better suited to the RISC OS   */
  /* I/O system and return errors in a more useful */
  /* fashion than the standard C functions.        */

  ChkError(_swix(OS_File,
                 _INR(0,2) | _INR(4,5),

                 10, /* Save block of memory as a typed file */
                 ((SaveAsSaveToFileEvent *) event)->filename,
                 file_type,
                 save_origin->source,
                 ((char *) save_origin->source) + flex_size((flex_ptr) &save_origin->source)));

  /* Tell the SaveAs dialogue that the save has been done */

  ChkError(saveas_file_save_completed(SaveAs_SelectionSaved,
                                      idb->self_id,
                                      ((SaveAsSaveToFileEvent *) event)->filename));

  return 1;
}

/*************************************************/
/* save_fill_buffer()                            */
/*                                               */
/* Fills a give buffer with a chunk of document  */
/* source. Parameters are as standard for a      */
/* Toolbox event handler responding to a         */
/* SaveAs_FillBuffer event.                      */
/*************************************************/

int save_fill_buffer(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  SaveAsFillBufferEvent * fill;
  int                     datasize, copy = 0;

  fill = (SaveAsFillBufferEvent *) event;

  if (!save_origin) return 0;

  /* How much data is there? */

  datasize = flex_size((flex_ptr) &save_origin->source);

  /* If the amount transferred is less than the total, proceed */

  if (fill->no_bytes < datasize)
  {
    /* Work out how much to transfer */

    datasize -= fill->no_bytes;

    if (fill->size)
    {
      if (datasize < fill->size) copy = datasize;
      else                       copy = fill->size;
    }
  }

  /* Call the buffer filled function to tell the Toolbox */
  /* how much to transfer (a somewhat inappropriately    */
  /* named function in the context of its use here).     */

  ChkError(saveas_buffer_filled(0,
                                idb->self_id,
                                ((char *) save_origin->source) + save_origin->savetransferred,
                                copy));

  save_origin->savetransferred += copy;

  return 1;
}

/*************************************************/
/* save_save_completed()                         */
/*                                               */
/* Called when a document save is complete.      */
/* Parameters are as standard for a Toolbox      */
/* event handler responding to a                 */
/* SaveAs_SaveCompleted event.                   */
/*************************************************/

int save_save_completed(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  save_origin = NULL;
  save_dbox   = 0;

  return 1;
}

/*************************************************/
