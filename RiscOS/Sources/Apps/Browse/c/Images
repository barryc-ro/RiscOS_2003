/***************************************************/
/* File   : Images.c                               */
/*                                                 */
/* Purpose: Image related functions.               */
/*                                                 */
/* Author : Merlyn Kline for Intertalk browser     */
/*          This source adapted by A.D.Hodgkinson  */
/*                                                 */
/* History: 28-Nov-96: Created with dummy function */
/*                     for temporary use in other  */
/*                     routines.                   */
/*          20-Jan-97: Filled in with most of the  */
/*                     functions present and       */
/*                     converted to the new data   */
/*                     structures where needed.    */
/*          15-Mar-97: Reorganised a bit, putting  */
/*                     functions in a more logical */
/*                     order to aid legibility.    */
/*          17-Dec-97: Added support for saving as */
/*                     a Draw file.                */
/***************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "swis.h"
#include "flex.h"

#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "toolbox.h"

#include "svcprint.h"
#include "Global.h"
#include "FromROSLib.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Browser.h"
#include "Fetch.h" /* (Which itself includes URLstat.h) */
#include "FetchHTML.h"
#include "FetchPage.h"
#include "FontManage.h"
#include "ImgHistory.h"
#include "PrintStyle.h"
#include "Protocols.h"
#include "Redraw.h"
#include "Reformat.h"
#include "Save.h"
#include "SaveDraw.h"
#include "TokenUtils.h"
#include "Toolbars.h"
#include "URLutils.h"
#include "URLveneer.h"
#include "Windows.h"

#include "Images.h"

/* Statics */

static _kernel_oserror * image_load_chunk             (browser_data * b, int image, char * buffer, int bytes);
static void              image_remove_data            (browser_data * b, int image);
static void              image_remove_all_data        (int image);
static void              image_delay                  (browser_data * b, int image);
static void              image_abandon                (browser_data * b, int image);
static void              image_prepare                (browser_data * b, HStream * token, int image, int background);

static void              image_mark_as_deleted        (int i);
static void              image_mark_as_gcable         (int i);
static void              image_destroy                (int image);
static int               image_renumber               (int old, int new);
static int               image_purge_deleted_entries  (void);
static void              image_post_deletion_clearup  (void);
static int               image_gc_oldest              (browser_data * b);

static void              image_refetch                (browser_data * b, int image, int priority, int redraw);

static _kernel_oserror * image_update_area            (browser_data * b, int x, int y, BBox * ubox, int image, int redraw);
static _kernel_oserror * image_update_image           (browser_data * b, int image, BBox * box);

static _kernel_oserror * image_register_filler        (int xref);

//static int               image_data_offset            (int image);
static int               image_count_fetches          (browser_data * b);

static int               image_get_token_image_xref   (browser_data * b, HStream * token);
static int               image_get_token_image_actual (browser_data * b, HStream * token);

static void              image_lock_image_size        (browser_data * b, int image);
static void              image_unlock_image_size      (browser_data * b, int image);
static _kernel_oserror * image_get_image_size         (browser_data * b, int image, BBox * box, int ignore_stored);
static _kernel_oserror * image_set_image_size         (browser_data * b, int image, BBox * box);

static int               image_can_be_saved_as_sprite (browser_data * b, int i);

/* Locals */

static image_info   * idata       = NULL; /* Flex block for image_info structures (referenced as an array) */
static int            nimages     = 0;    /* Current number of image_info structures in idata array        */
static int            lastimage   = 0;    /* Used to work out what image_process_null should handle next   */
static int            animhandler = 0;    /* Flag so code knows when to (de)register GIF animation handler */
static unsigned int   unique_id   = 1;    /* IDs start at 1 and rise thereafter                            */
static char         * unique_name = NULL; /* Temporary pathname, nothing to do with unique_id!             */

/* For animated images, the filler function for the background of a   */
/* transparent image will get called only for the main image with the */
/* associated image data - not for any cross referenced images. These */
/* statics hold the browser and image being redrawn at any time, so   */
/* the filler function knows which cross referencing image is         */
/* actually being redrawn.                                            */

static int            image_redrawing   = -1;
static browser_data * browser_redrawing = NULL;

/* Local compilation options */

#undef  TRACE_FETCH_STORE
#define FAST_TOKEN_REFERENCE
#define FAST_TOKEN_REFERENCE_SHIFT 12
#undef  ALL_FAST

// Unimplemented functions:

// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
// static _kernel_oserror * image_savesprite_start_save1(image_info * ip,int * isize)
// {
//   int        size;
//
//   * isize=-1;
//   if(ip && ip->istore && ip->istore->width>0)
//   {
//     ERROUT((_kernel_oserror*)ip->istore->StartExport(ip->istore,&size));
//     size-=12; /* subtract the size of the sprite area header */
//   }
//   else
//   {
//     sprite_header * p;
//     sprite_area   * sa;
//     sprite_id     sid;
//
//     image_get_broken_sprite(&sa,&sid);
//     p=(sprite_header*)sid.s.addr;
//     size=WORDALIGN(p->next);
//   }
//   * isize=size;
//   return(NULL);
// }
//
// /* ----------------------------------------------------------------------*/
// _kernel_oserror * image_savesprite_start_save(browser_data * b,int token,int * isize)
// {
//   image_info * ip;
//
//   ip=image_get_token_image_xref(b,token);
//   return(image_savesprite_start_save1(ip,isize));
// }
//
//
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
// static int image_savesprite_save_image1(image_info * ip)
// {
//   sprite_header * p;
//   sprite_area   * sa;
//   sprite_id     sid;
//
//   if(ip && ip->istore && ip->istore->width>0)
//   {
//     int  len;
//     char buffer[2048];
//     int  skip=12; /* skip first 12 bytes (sprite area header) */
//
//     do
//     {
//       len=sizeof(buffer);
//       if(wimpt_complain((_kernel_oserror*)ip->istore->Export(ip->istore,buffer,&len))) return(0);
//       if(len-skip>0 && !save_write_bytes(buffer+skip,len-skip)) return(0);
//       skip-=len;
//       if(skip<0) skip=0;
//     } while(len);
//     return(1);
//   }
//   image_get_broken_sprite(&sa,&sid);
//   p=(sprite_header*)sid.s.addr;
//   return(save_write_bytes((void*)p,WORDALIGN(p->next)));
// }
//
// /* ----------------------------------------------------------------------*/
// int image_savesprite_save_image(browser_data * b,int token)
// {
//   image_info    * ip;
//
//   ip=image_get_token_image_xref(b,token);
//   return(image_savesprite_save_image1(ip));
// }
//
// /* ----------------------------------------------------------------------*/
// void image_savesprite_end_save(browser_data * b,int token)
// {
//   image_info * ip;
//
//   ip=image_get_token_image_xref(b,token);
//   if(ip && ip->istore && ip->istore->width>0) ip->istore->EndExport(ip->istore);
// }
//
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
// static int image_picture_saver(void * handle,char * pathname)
// {
//   browser       * b;
//   int           * si,token;
//   image_info    * ip;
//
//   pathname=pathname;
//   si=(int*)handle;
//   b=(browser*)si[0];
//   token=si[1];
//   ip=NULL;
//   if(token>0) ip=image_get_token_image_xref(b,token);
//   else if(b->background_image>0) ip=image_info_addr(b,b->background_image);
//   if(ip && ip->istore && ip->istore->width>0)
//   {
//     int  len;
//     char buffer[2048];
//
//     do
//     {
//       len=sizeof(buffer);
//       if(wimpt_complain((_kernel_oserror*)ip->istore->Export(ip->istore,buffer,&len))) return(0);
//       if(len && !save_write_bytes(buffer,len)) return(0);
//     } while(len);
//   }
//   else
//   {
//     sprite_area   area,* sa;
//     sprite_id     sid;
//     sprite_header * p;
//
//     image_get_broken_sprite(&sa,&sid);
//     p=(sprite_header*)sid.s.addr;
//     area.size=sizeof(sprite_area)+p->next;
//     area.number=1;
//     area.sproff=sizeof(sprite_area);
//     area.freeoff=area.size;
//     if(!save_write_bytes((void*)(&area.number),sizeof(area)-4)) return(0);
//     return(save_write_bytes((void*)p,p->next));
//   }
//   return(1);
// }
//
// /* ----------------------------------------------------------------------*/
// _kernel_oserror * image_save_picture(browser_data * b,int token)
// {
//   int        size,saveinfo[2];
//   char       pathname[256];
//   image_info * ip;
//
//   ip=NULL;
//   if(token && fetch_token_address(b,token)->style&IMG) ip=image_get_token_image_xref(b,token);
//   if(!ip && b->background_image>0)
//   {
//     ip=image_info_addr(b,b->background_image);
//     token=0;
//   }
//   if(ip && ip->istore && ip->istore->width>0) ip->istore->StartExport(ip->istore,&size);
//   else
//   {
//     sprite_area   * sa;
//     sprite_id     sid;
//     sprite_header * p;
//
//     image_get_broken_sprite(&sa,&sid);
//     p=(sprite_header*)sid.s.addr;
//     size=sizeof(sprite_area)+p->next-4;
//   }
//   saveinfo[0]=(int)b;
//   saveinfo[1]=token;
//   strcpy(pathname,msgs_lookup("sprfile:SpriteFile"));
//   save_saveas(FILETYPE_SPRITE,pathname,size,image_picture_saver,NULL,(void*)saveinfo);
//   if(ip && ip->istore && ip->istore->width>0) ip->istore->EndExport(ip->istore);
//   return(NULL);
// }

// /* ----------------------------------------------------------------------*/
// _kernel_oserror * image_saveback_start_save(browser_data * b,int * isize)
// {
//   image_info * ip;
//
//   ip=image_info_addr(b,b->background_image);
//   return(image_savesprite_start_save1(ip,isize));
// }
//
// /* ----------------------------------------------------------------------*/
// int image_saveback_save_image(browser_data * b)
// {
//   image_info    * ip;
//
//   ip=image_info_addr(b,b->background_image);
//   return(image_savesprite_save_image1(ip));
// }
//
// /* ----------------------------------------------------------------------*/
// void image_saveback_end_save(browser_data * b)
// {
//   image_info * ip;
//
//   ip=image_info_addr(b,b->background_image);
//   if(ip && idata[i].istore && idata[i].istore->width>0) idata[i].istore->EndExport(idata[i].istore);
// }

// **** static const char * image_get_url(HStream * t)
// **** {
// ****   if ISBODY(t)
// ****   {
// ****     if (t->tagno == TAG_TABLE) return NULL;
// ****     else if (t->style & IMG)   return t->src;
// ****     else if ISOBJECT(t)        return NULL; // Eeek
// ****     else if (t->style & FORM)
// ****     {
// ****       if (t->tagno == TAG_INPUT)
// ****       {
// ****         switch (HtmlINPUTtype(t))
// ****         {
// ****           case inputtype_IMAGE: return HtmlINPUTsrc(t);
// ****           default:              return NULL;
// ****         }
// ****       }
// ****       else return NULL;
// ****     }
// ****   }
// ****   else if ISFRAMESET(t) return NULL;
// ****   else if ISHEAD(t)
// ****   {
// ****     if (t->tag == BODY) return HtmlBODYbackground(t);
// ****   }
// ****
// ****   return NULL;
// **** }

/*************************************************/
/* image_load_chunk()                            */
/*                                               */
/* Tell the image library to deal with some of   */
/* image data we've fetched for a given image.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1;                      */
/*                                               */
/*             Pointer to a buffer containing    */
/*             the data, as a char *;            */
/*                                               */
/*             The amount of data in that        */
/*             buffer.                           */
/*************************************************/

static _kernel_oserror * image_load_chunk(browser_data * b, int image, char * buffer, int bytes)
{
  BBox              box;
  _kernel_oserror * e = NULL;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_load_chunk: Called for image %d\n",image);
  #endif

  /* If the library has filled in the istore field, tell it to */
  /* get some of the data we've fetched.                       */

  if (idata[image].istore) e = idata[image].istore -> Load(idata[image].istore,
                                                           buffer,
                                                           bytes,
                                                           &box);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_load_chunk: Exitting with error\n");
  #endif

  /* Return errors for STRICT_PARSER builds only */

  #ifdef STRICT_PARSER
    if (e) return e;
  #else
    if (e) return NULL;
  #endif

  /* Update the image on the page to reflect the new data */

  image_update_image(b, image, &box);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_load_chunk: Successful\n");
  #endif

  return NULL;
}

/*************************************************/
/* image_remove_data()                           */
/*                                               */
/* Discards the fetched image data associated    */
/* with an image, but leaves the URL information */
/* alone.                                        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1.                      */
/*************************************************/

static void image_remove_data(browser_data * b, int image)
{
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_remove_data: Called for image %d\n",image);
  #endif

  if (idata[image].flex->fetchdata)
  {
    #ifdef TRACE
      flexcount -= flex_size(&idata[image].flex->fetchdata);
      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
    #endif

    flex_free(&idata[image].flex->fetchdata);

    idata[image].flex->fetchdata = NULL;
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_remove_data: Successful\n");
  #endif
}

/*************************************************/
/* image_remove_all_data()                       */
/*                                               */
/* Discards the fetched image data associated    */
/* with an image, including URL information.     */
/*                                               */
/* Parameters: The image number, from 0 to       */
/*             nimages - 1.                      */
/*************************************************/

static void image_remove_all_data(int image)
{
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_remove_all_data: Called for image %d\n",image);
  #endif

  if (!idata[image].flex) return;

  if (idata[image].flex->urldata)
  {
    #ifdef TRACE
      flexcount -= flex_size((flex_ptr) &idata[image].flex->urldata);
      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
    #endif

    flex_free((flex_ptr) &idata[image].flex->urldata);

    idata[image].flex->urldata = NULL;
  }

  if (idata[image].flex->fetchdata)
  {
    #ifdef TRACE
      flexcount -= flex_size(&idata[image].flex->fetchdata);
      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
    #endif

    flex_free(&idata[image].flex->fetchdata);

    idata[image].flex->fetchdata = NULL;
  }

  free(idata[image].flex);
  idata[image].flex = NULL;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_remove_all_data: Successful\n");
  #endif
}

/*************************************************/
/* image_delay()                                 */
/*                                               */
/* Stop fetching data for an image, even if it   */
/* hasn't all been fetched, but allow the fetch  */
/* to continue later on.                         */
/*                                               */
/* Call with care. Keeping part of an image is   */
/* dangerous - ImageLib may object. Normally,    */
/* this should only be called for images which   */
/* have not started to fetch. Stopping an image  */
/* mid-fetch is more safely done through         */
/* image_abandon.                                */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1.                      */
/*************************************************/

static void image_delay(browser_data * b, int image)
{
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_delay: Called for image %d\n",image);
  #endif

  /* Stop any fetching for the image */

  if (idata[image].handle) html_close(idata[image].handle);

  idata[image].handle  = 0;
  idata[image].delayed = 1;

  /* If this is a background, go back to the plain background */

  if (image == b->background_image) b->antialias_colour = redraw_backcol(b);

  if (idata[image].istore) image_update_image(b, image, NULL);

  /* There may be a new overall fetch status, so ensure the */
  /* status bar is up to date                               */

  toolbars_cancel_status(b, Toolbars_Status_GetPics);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_delay: Successful\n");
  #endif
}

/*************************************************/
/* image_delay_fetches()                         */
/*                                               */
/* Stops any images which have not started to    */
/* fetch for a given browser from fetching at    */
/* all, by setting the image's 'delayed' flag.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*************************************************/

void image_delay_fetches(browser_data * b)
{
  if (nimages)
  {
    int image;

    for (image = 0; image < nimages; image++)
    {
      /* Only interested in non-cross referencing images */
      /* owned by this browser which are not fetching.   */

      if (
           idata[image].owner == b &&
           idata[image].xref < 0   &&
           !idata[image].handle
         )
         image_delay(b, image);
    }
  }
}

/*************************************************/
/* image_abandon()                               */
/*                                               */
/* Stop fetching data for an image, even if it   */
/* hasn't all been fetched.                      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1.                      */
/*************************************************/

static void image_abandon(browser_data * b, int image)
{
  BBox end;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_abandon: Called for image %d\n",image);
  #endif

  /* Stop any fetching for the image */

  if (idata[image].handle) html_close(idata[image].handle);

  idata[image].handle  = 0;
  idata[image].fetched = 1;

  /* If this is a background, go back to the plain background */

  if (image == b->background_image) b->antialias_colour = redraw_backcol(b);

  if (idata[image].istore)
  {
    /* Let this fail silently */

    idata[image].istore -> EndLoad(idata[image].istore, &end);

    /* Redraw the image */

    image_update_image(b, image, &end);
  }

  /* There may be a new overall fetch status, so ensure the */
  /* status bar is up to date                               */

  toolbars_cancel_status(b, Toolbars_Status_GetPics);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_abandon: Successful\n");
  #endif
}

/*************************************************/
/* image_abort_fetches()                         */
/*                                               */
/* Stop fetching data for all images belonging   */
/* to a given browser, discarding all data for   */
/* those images. The fetches cannot be restarted */
/* after this!                                   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*************************************************/

void image_abort_fetches(browser_data * b)
{
  int i;

  /* Loop through the images */

  for (i = 0; i < nimages; i++)
  {
    /* If owned by this browser... */

    if (idata[i].owner == b)
    {
      /* Mark the image as fetched (so pending images don't then */
      /* start to fetch after fetching images stop).             */

      idata[i].fetched = 1;

      /* Stop any images which are fetching */

      if (idata[i].handle)
      {
        html_close(idata[i].handle);
        idata[i].handle   = 0;
        idata[i].bytesgot = 0;

        /* If this is a background, go back to the plain background */

        if (i == b->background_image) b->antialias_colour = redraw_backcol(b);

        if (idata[i].istore)
        {
          #ifdef STRICT_PARSER

            /* Report any errors as Continue-only in strict parser mode */

            _kernel_oserror * e;

            e = idata[i].istore -> Delete(idata[i].istore);

            if (e)
            {
              e->errnum = Utils_Error_Custom_Message;
              show_error_ret(e);
            }

          #else

            /* If not in Strict mode, ignore any errors */

            idata[i].istore -> Delete(idata[i].istore);

          #endif

          idata[i].istore = NULL;

          /* Remove any fetched data (not URL information though) */

          image_remove_data(b, i);

          /* Redraw the item */

          if (idata[i].token) browser_update_token(b, idata[i].token, 0, 0);
        }
      }
    }
  }

  /* There may be a new overall fetch status, so ensure the */
  /* status bar is up to date                               */

  toolbars_cancel_status(b, Toolbars_Status_GetPics);
}

/*************************************************/
/* image_prepare()                               */
/*                                               */
/* Ensure various flags in an image are set up   */
/* as required by the token the image            */
/* represents. Will update the token to hold     */
/* the image number if FAST_TOKEN_REFERENCE is   */
/* defined.                                      */
/*                                               */
/* Originally part of image_new_image; made into */
/* a new function as it was needed more than     */
/* once.                                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to the token the image    */
/*             represents (NULL if none);        */
/*                                               */
/*             The image number;                 */
/*                                               */
/*             1 if this is a background image   */
/*             (fast processing), else 0.        */
/*************************************************/

static void image_prepare(browser_data * b, HStream * token, int image, int background)
{
  /* If the image is not a background one, need to update the */
  /* width and height fields according to any details in the  */
  /* HTML source.                                             */

  if (!background)
  {
    /* Need to flag if the HTML gives us an absolute size */

    if (
         token                                      &&
         OBJECT_HAS_WIDTH   (token)                 &&
         OBJECT_HAS_HEIGHT  (token)                 &&
         OBJECT_WIDTH_UNITS (token) == UNITS_PIXELS &&
         OBJECT_HEIGHT_UNITS(token) == UNITS_PIXELS
       )
       idata[image].fixedsize = 1, idata[image].canredraw = 1;

    else
    {
      /* If reformats aren't immediate, image_update_image may ask for */
      /* one and then if canredraw is set, will start updating the     */
      /* image. This is invalid unless the reformat has definitely     */
      /* occurred (a full size image plots inside a default size       */
      /* placeholder...). However, if reformats happen straight away,  */
      /* we'll always be able to redraw.                               */

      if (!choices.refo_wait) idata[image].canredraw = 1;
      else                    idata[image].canredraw = 0;
    }

    idata[image].currw = idata[image].currh = -1;
  }

  /* Store the image number in the token */

  #ifdef FAST_TOKEN_REFERENCE

    if (token)
    {
      token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
      token->flags |= ((image + 1) << FAST_TOKEN_REFERENCE_SHIFT);
    }

  #endif
}

/*************************************************/
/* image_new_image()                             */
/*                                               */
/* Starts fetching a new image. Creates a record */
/* in the idata flex block and increments the    */
/* image counter. If an image is already being   */
/* fetched with the same URL then a cross        */
/* reference is set up to point to that, else a  */
/* fetch is initiated.                           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image to fetch;   */
/*                                               */
/*             Pointer to the URL to fetch;      */
/*                                               */
/*             The address of the token that led */
/*             to this function call, i.e. the   */
/*             token representing that image;    */
/*                                               */
/*             1 if the image is for the         */
/*             background (it will be turned     */
/*             into a sprite for fast plotting), */
/*             else 0; or if 2, the              */
/*             background_image field of the     */
/*             browser_data structure is filled  */
/*             in with the relevant image number */
/*             and the image will again be       */
/*             turned into a sprite for fast     */
/*             plotting;                         */
/*                                               */
/*             Pointer to an int, in which an    */
/*             opaque value by which the image   */
/*             may be later referenced is        */
/*             returned - useful for garbage     */
/*             collection if you've no token     */
/*             to associate with this image (may */
/*             be NULL).                         */
/*************************************************/

_kernel_oserror * image_new_image(browser_data * b, const char * url, HStream * token, int background, int * handle)
{
  int ok, ulen;
  int xref;
  int use_xref   = 0;
  int tried_once = 0;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_new_image: Called\n");
  #endif

  /* Can't proceed without the URL to fetch! */

  if (!url) url = ""; /* Point to *something*, even if it is blank */

  xref = -1;

  /* Need to make sure we don't already have an image with this URL */
  /* if there are already some images present.                      */

  if (nimages)
  {
    int test = 1;

    #ifdef FAST_TOKEN_REFERENCE

      /* Must not try to have too many images... */

      if (nimages >= (((unsigned int) 0xffffffff) >> FAST_TOKEN_REFERENCE_SHIFT))
      {
        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 lookup_token("MaxImages:Too many images.",
                              0,
                              0));
        return &erb;
      }

    #endif

    /* If this is a File URL, check it's not scrap - don't allow cross */
    /* referencing if it is.                                           */

    if (!strncmp(url, FileMethod, sizeof(FileMethod) - 1))
    {
      char test_url[Limits_URL];

      /* Build the URL we'd be on for a scrap file fetch */

      StrNCpy0(test_url, Save_ScrapFile);

      urlutils_pathname_to_url(test_url, sizeof(test_url));

      /* If it's the same as the URL we've been given, don't */
      /* cross reference the image.                          */

      if (!strcmp(url, test_url)) test = 0;
    }

    if (test)
    {
      int i;

      for (i = 0; i < nimages; i++)
      {
        /* Can we simply create a cross reference to another image? */

        if (
             idata[i].flex->urldata                                  &&  /* The image has an associated URL                     */
             idata[i].xref < 0                                       &&  /* The image doesn't cross reference things itself     */
             idata[i].background == !!background                     &&  /* We're not trying to make a b/g an f/g or vice versa */
             !strcmp(url, idata[i].flex->urldata)                    &&  /* This holds a URL which matches that passed in       */
             (
               !background ||                                            /* This isn't a background image, or...                */
               (
                 background &&                                           /* If this is a background image, the background       */
                 redraw_backcol(idata[i].owner) == redraw_backcol(b)     /* colours match in the two owner browsers             */
               )
             )
           )
        {
          xref = i;       /* If all of the above are satisfied, cross reference */
          i    = nimages; /* this image with the one it matches.                */
        }
      }
    }
  }

  /* Don't need to hold the URL for a cross referenced image */

  if   (xref >= 0) ulen = 0;
  else             ulen = strlen(url) + 1;

  /* Are we cross-referencing an image which is ready for garbage */
  /* collection? If so, we can just claim this one.               */

  if (xref >= 0)
  {
    if (!idata[xref].from_js && !idata[xref].token)
    {
      /* Set the token and owner */

      idata[xref].token     = token;
      idata[xref].owner     = b;
      idata[xref].last_used = time(NULL);

      /* Handle background images */

      if (background == 2) b->background_image = xref;

      /* Ensure any required flags are updated */

      image_prepare(b, token, xref, background);

      /* Flag to any of the code we're about to jump to that the */
      /* xref image number should be used, not 'nimages - 1'     */

      use_xref = 1;

      /* Jump past all the image setup and cross referencing */
      /* code to carry on with whatever remains for this     */
      /* image.                                              */

      goto image_new_image_reclaimed_image_jump_point;
    }
  }

  /* For each of the following allocations, try twice. If the first */
  /* attempt fails, garbage collect all images and try again.       */

  tried_once = 0;

  do
  {
    /* Allocate space for the image_info structure */

    if (idata)
    {
      int oldsize;

      oldsize = flex_size  ((flex_ptr) &idata);
      ok      = flex_extend((flex_ptr) &idata, oldsize + sizeof(image_info));
    }
    else ok   = flex_alloc ((flex_ptr) &idata, sizeof(image_info));

    if (!ok && !tried_once)
    {
      tried_once = 1;
      image_gc(NULL, 0, 0);
    }
    else break;
  }
  while (!ok);

  /* Throw back an error if out of memory */

  if (!ok)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("NoMemImg:There is not enough free memory for any new images (%0).",
                          0,
                          "1"));

    return &erb;
  }

  /* Initialise the new structure (*before* incrementing nimages for now) */

  memset(&idata[nimages], 0, sizeof(image_info));

  idata[nimages].owner      = b;
  idata[nimages].x          = -1;
  idata[nimages].y          = -1;

  idata[nimages].token      = token;
  idata[nimages].last_used  = time(NULL);
  idata[nimages].xref       = xref;

  idata[nimages].background = !!background;
  idata[nimages].hadfiller  = 0;

  /* Allocate space for the URL */

  if (ulen)
  {
    tried_once = 0;

    do
    {
      /* Allocate space for the image data */

      idata[nimages].flex = malloc(sizeof(image_flex));

      if (!idata[nimages].flex) ok = 0;
      else                      ok = 1;

      memset(idata[nimages].flex, 0, sizeof(image_flex));

      if (ok) ok = flex_alloc((flex_ptr) &idata[nimages].flex->urldata, ulen);

      if (!ok && !tried_once)
      {
        tried_once = 1;
        image_gc(NULL, 0, 0);
      }
      else break;
    }
    while (!ok);
  }

  /* Again, throw back an error if out of memory */

  if (!ok)
  {
    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess,
             lookup_token("NoMemImg:There is not enough free memory for any new images (%0).",
                          0,
                          "1"));

    return &erb;
  }

  #ifdef TRACE
    flexcount += ulen;
    if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
  #endif

  /* If there's data for a URL, copy it into the above allocated block */
  /* and inform ImageLib of the new image.                             */

  if (ulen)
  {
    strcpy(idata[nimages].flex->urldata, url);

    #ifdef ALL_FAST
      idata[nimages].istore = NewImage(NULL, IMAGE_FAST);
    #else
      idata[nimages].istore = NewImage(NULL, background ? IMAGE_FAST : 0);
    #endif
  }

  /* Set the 'delayed' flag if it's not a background image and */
  /* images are flagged as not being shown right now, or if it */
  /* is a background image and backgrounds are flagged to be   */
  /* plain only.                                               */

  if (background)
  {
    idata[nimages].delayed   = !b->show_background;
    idata[nimages].canredraw = 1;

    /* Set the background image number */

    if (background == 2) b->background_image = nimages;
  }
  else
  {
    idata[nimages].delayed = (!b->show_foreground && b->displayed != Display_External_Image);
  }

  /* May have the image source in an exclusion list though */

  if (
       !idata[nimages].delayed                    &&
       ulen                                       &&
       urlutils_match_by_token(url, "LONoImages")
     )
     idata[nimages].delayed = 1;

  /* Make sure width and height info etc. is correct according */
  /* to the given HStream.                                     */

  image_prepare(b, token, nimages, background);

  /* Unique ID is never decremented... */

  idata[nimages].unique_id = unique_id ++;
  if (handle) *handle = idata[nimages].unique_id;

  /* ...whereas nimages is, when images get discarded. */

  nimages++;

image_new_image_reclaimed_image_jump_point:

  if (!ulen)
  {
    /* Since we aren't starting a fetch for this image, must call image_update_image  */
    /* on it to make sure any required reformats etc. (e.g. because a width or height */
    /* but not both was specified in the HTML) are carried out.                       */

    image_update_image(b, use_xref ? xref : nimages - 1, NULL);
  }

  /* Reflect any change of status */

  toolbars_update_status(b, Toolbars_Status_GetPics);
  toolbars_set_button_states(b);

  /* Finished. */

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_new_image: Successful\n");
  #endif

  return NULL;
}

/*************************************************/
/* image_process_null()                          */
/*                                               */
/* The main engine of the image loading system.  */
/* Allows up to choices.max_images images to be  */
/* simultaneously fetched. Handles redraw,       */
/* memory allocation, out-of-memory fetch stops, */
/* and so-forth.                                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*************************************************/

_kernel_oserror * image_process_null(browser_data * b)
{
  _kernel_oserror * e;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_process_null: Called\n");
  #endif

  /* If there are not max_images images being fetched and there are still */
  /* images which have not started fetching, then start a fetch for one.  */
  /* Then do a 'get next chunk' on the next image with a fetch going      */
  /* on. Cause a screen update as appropriate.                            */

  if (nimages && b->fetch_status != BS_DATAFETCH)
  {
    int image, fetches;

    fetches = image_count_fetches(b);

    if (lastimage < 0 || lastimage >= nimages) lastimage = nimages - 1;

    image = lastimage;

    /* For all images up to and including the last one dealt with in a */
    /* null event, initiate fetches if they haven't already started.   */

    do
    {
      image ++;
      if (image >= nimages) image = 0;

      if (
           !idata[image].handle         &&
           !idata[image].fetched        &&
           !idata[image].delayed        &&
           idata[image].xref < 0        &&
           fetches < choices.max_images
         )
      {
        const char * referer = browser_base_url(b);
        char       * url     = malloc(strlen(idata[image].flex->urldata) + 1);

        if (url)
        {
          strcpy(url, idata[image].flex->urldata);

          e = html_get(url,                          /* Document to fetch                */
                       NULL,                         /* Pointer to any extra data        */
                       (int *) &idata[image].handle, /* Place to return the fetch handle */
                       URL_Method_http_GET,          /* Fetch method                     */

                       #ifndef SINGLE_USER
                         user.name,                  /* User name for MailServ, if using */
                       #else                         /* a multiuser version              */
                         NULL,
                       #endif

                       0,                            /* 0 = Don't parse fetched data     */
                       !b->reloading,                /* 1 = Proxy can be used, 0 = can't */
                       referer);                     /* URL of referring page            */
          free(url);
        }
        else e = NULL; /* Suppress compiler warning */

        if (!url || e)
        {
          /* Don't report it; countless 'I've failed' reports for */
          /* the very beginning of a fetch are not very helpful.  */
          /* Particularly, 'file not found' for file fetches can  */
          /* be major pain!                                       */

          image_abandon(b, image);
          return NULL;
        }

        url = NULL;
      }
    }
    while (image != lastimage && !idata[image].handle);

    lastimage = image;

    /* If the image we're now on has a fetch handle... */

    if (idata[image].handle)
    {
      char buffer[10240];

      /* ...And a fetch has already started... */

      if (idata[image].started)
      {
        int done, bytes;

        /* ...Then get the next chunk of data. If the fetch */
        /* call gives an error, abandon the image fetch and */
        /* exit.                                            */

        e = fetch_get_raw_data(NULL,                /* The browser_data structure */
                               idata[image].handle, /* Fetch handle */
                               buffer,              /* Buffer for fetched data */
                               sizeof(buffer),      /* Buffer's size */
                               &done,               /* 'done' = 1 for fetch completed, else 0 */
                               &bytes);             /* Number of bytes put into buffer */

        if (e)
        {
          image_abandon(b, image);
          return e;
        }

        idata[image].bytesgot += bytes;

        /* If the fetch_get_raw_data call resulted in data being fetched, */
        /* send that to the image library and reflect the fetched data in */
        /* the status bar.                                                */

        if (bytes)
        {
          e = image_load_chunk(b, image, buffer, bytes);

          if (e)
          {
            image_abandon(b, image);
            return e;
          }

          toolbars_update_progress(b);
        }

        /* If the fetch has finished, update everything as appropriate */

        if (done)
        {
          BBox end;

          html_close(idata[image].handle);

          idata[image].handle  = 0;
          idata[image].fetched = 1;
          idata[image].success = 1;

          if (idata[image].istore)
          {
            #ifdef STRICT_PARSER

              /* Report any errors as Continue-only in strict parser mode */

              e = idata[image].istore -> EndLoad(idata[image].istore, &end);

              if (e)
              {
                e->errnum = Utils_Error_Custom_Message;
                show_error_ret(e);
              }

            #else

              /* If not in Strict mode, ignore any errors */

              idata[image].istore -> EndLoad(idata[image].istore, &end);

            #endif
          }

          /* If the image is a background image and the library has */
          /* dealt with it (this is assumed to be the case if the   */
          /* library has assigned a width to the image) then get    */
          /* the background text colour from the library on the     */
          /* basis of the image's contents. Else, use the plain     */
          /* background colour.                                     */
          /*                                                        */
          /* Note that it is not until the call to BGCol that       */
          /* ImageLib actually turns the background image into a    */
          /* sprite in the current colour depth, so if this isn't   */
          /* called, the sprite will plot slowly resulting in       */
          /* (typically) painfully slow redraws.                    */

          if (image == b->background_image) // idata[image].owner->background_image)
          {
            b->antialias_colour = redraw_backcol(b);

            if (idata[image].istore->width > 0)
            {
              #ifdef STRICT_PARSER

                /* Report any errors as Continue-only in strict parser mode */

                e = idata[image].istore -> BGCol(idata[image].istore,
                                                 &b->antialias_colour,
                                                 b->background_colour != -1 && b->use_source_cols);

                if (e)
                {
                  e->errnum = Utils_Error_Custom_Message;
                  show_error_ret(e);
                }

              #else

                /* If not in Strict mode, ignore any errors */

                idata[image].istore -> BGCol(idata[image].istore,
                                             &b->antialias_colour,
                                             b->background_colour != -1 && b->use_source_cols);

              #endif
            }
          }

          image_update_image(b, image, &end);
        }
      }
      else
      {
        /* In this block of code, the current image has had a fetch */
        /* started for it, but hasn't fetched any data yet - so we  */
        /* haven't (for example) got a full header for the request. */

        int       remn, sofar, waiting;
        int       realsize;
        int       oldsize;
        HStream * tptr;
        void    * store;
        char    * url = malloc(strlen(idata[image].flex->urldata) + 1);

        if (url) strcpy(url, idata[image].flex->urldata);

        /* Go in with no store; only interested in new data, as  */
        /* anything fetched so far goes into the ddata block. */

        store = NULL;

        /* At this stage, must put the data fetched so far back into the  */
        /* store. This is because headers may come in over several        */
        /* passes through the fetcher - if we give the fetcher an empty   */
        /* block each time, it won't be able to see the whole header      */
        /* block and the fetch fails (well, the image library keeps       */
        /* waiting for something to happen). At the time of writing this  */
        /* is demonstrated by the images at http://www.debenhams.co.uk/.  */

        if (idata[image].flex->fetchdata)
        {
          int isize = flex_size(&idata[image].flex->fetchdata);

          /* Complain if the flex allocation fails, else copy the data across */

          if (!flex_alloc(&store, isize))
          {
            image_abandon(b, image);
            free(url);
            return NULL;
          }
          else
          {
            int budge = flex_set_budge(0);

            #ifdef TRACE
              flexcount += isize;
              if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
            #endif

            memcpy(store, idata[image].flex->fetchdata, isize);

            flex_set_budge(budge);
          }
        }

        #ifdef TRACE_FETCH_STORE

          if (store)
          {
            int  offset;
            int  size = flex_size(&store);
            char cha;
            int  nl   = 0;

            Printf("Image %d pre-fetch store:\n\n",image);

            for (offset = 0; offset < size; offset ++)
            {
              cha = ((char *) store)[offset];

              if (cha > 31) Printf("%c",cha);
              if (cha == 13 || cha == 10)
              {
                if (!nl)
                {
                  Printf("\n");
                  nl = 1;
                }
                else nl = 0;
              }
            }

            Printf("\nEnd of store\n\n");
          }

        #endif

        /* Call the fetch routine */

        if (url)
        {
          e = html_get_next_token(b,
                                  idata[image].handle,
                                  &remn,
                                  &sofar,
                                  &tptr,
                                  &waiting,
                                  &store,
                                  url,
                                  1);

          free(url);
        }
        else e = NULL; /* Suppress compiler warning */

        if (!url || e)
        {
          /* If there's an error, free the store and ditch the image */

          if (store)
          {
            #ifdef TRACE
              flexcount -= flex_size(&store);
              if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
            #endif

            flex_free(&store);
          }

          image_abandon(b, image);

          #ifdef TRACE
            if (tl & (1u<<15)) Printf("image_process_null: Exitting with error\n");
          #endif

          /* Only return errors in STRICT_PARSER builds for similar reason to */
          /* suppression of any errors from html_get above. After all, errors */
          /* here can include things like "404 Not Found".                    */

          #ifdef STRICT_PARSER
            return e;
          #else
            return NULL;
          #endif
        }

        url = NULL;

        #ifdef TRACE_FETCH_STORE

          if (store)
          {
            int  offset;
            int  size = flex_size(&store);
            char cha;
            int  nl   = 0;

            Printf("Image %d post-fetch store:\n\n",image);

            for (offset = 0; offset < size; offset ++)
            {
              cha = ((char *) store)[offset];

              if (cha > 31) Printf("%c",cha);
              if (cha == 13 || cha == 10)
              {
                if (!nl)
                {
                  Printf("\n");
                  nl = 1;
                }
                else nl = 0;
              }
            }

            Printf("\nEnd of store\n\n");
          }

        #endif

        /* How much data was added? */

        oldsize  = idata[image].flex->fetchdata ? flex_size(&idata[image].flex->fetchdata) : 0;
        realsize = store                        ? flex_size(&store) - oldsize              : 0;

        /* If we've got data in the local store, copy it to the image store. */

        if (realsize > 0)
        {
          int ok;
          int amount = flex_size(&store);
          int budge;

          /* Make enough room for the extra data */

          if (idata[image].flex->fetchdata) ok = flex_extend(&idata[image].flex->fetchdata, amount);
          else                              ok = flex_alloc (&idata[image].flex->fetchdata, amount);

          if (!ok)
          {
            #ifdef TRACE
              flexcount -= flex_size(&store);
              if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
            #endif

            flex_free(&store);

            image_abandon(b,image);

            erb.errnum = Utils_Error_Custom_Message;

            StrNCpy0(erb.errmess,
                     lookup_token("NoMemImg:There is not enough free memory for any new images (%0).",
                                  0,
                                  "2"));
            return &erb;
          }

          #ifdef TRACE

          else
          {
            flexcount += realsize;
            if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
          }

          #endif

          /* Copy the added data from the temporary store into the image's store */

          budge = flex_set_budge(0);

          memcpy(((char *) idata[image].flex->fetchdata) + oldsize,
                 ((char *) store)                        + oldsize,
                 realsize);

          flex_set_budge(budge);
        }

        /* Free the temporary store, if it was used */

        if (store)
        {
          #ifdef TRACE
            flexcount -= flex_size(&store);
            if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
          #endif

          flex_free(&store);
        }

        /* Act according to the fetch status */

        switch (waiting)
        {
          case 1: break; /* Nothing happened yet, or the HTTP response header is still coming in */
          case 2: break; /* Redirected, we can ignore and wait for the fetcher to cope */

          case 0:        /* Not awaiting delivery (shouldn't happen in this context, but here 'just in case') */
          case 3:        /* We have some data */
          {
            int offset, remaining, this_block;

            /* Flag that a fetch is in progress (rather than headers still */
            /* arriving, waiting, or redirecting)                          */

            idata[image].started = 1;

            /* Increment the 'bytes so far' counter for the image */

            idata[image].bytesgot += realsize;

            /* Push the data into the library, in chunks defined by */
            /* the size of 'buffer' (allocated as a char[] above).  */
            /* We do this as we can't be sure the ImageLib Load     */
            /* function is flex-safe, so the recently fetched data  */
            /* is copiedied into a temporary, non-movable block.    */

            offset    = oldsize;
            remaining = realsize;

            while (remaining > 0)
            {
              this_block = remaining;

              if (this_block > sizeof(buffer)) this_block = sizeof(buffer);
              memcpy(buffer, ((char *) idata[image].flex->fetchdata) + offset, this_block);

              offset    += this_block;
              remaining -= this_block;

              e = image_load_chunk(b, image, buffer, this_block);

              if (e)
              {
                /* If there's an error, ditch the image */

                image_abandon(b, image);

                #ifdef TRACE
                  if (tl & (1u<<15)) Printf("image_process_null: Exitting with error\n");
                #endif

                return e;
              }
            }

            /* Get rid of any accumulated data and update the status bar */

            image_remove_data(b, image);
            toolbars_update_progress(b);
          }
          break;
        }

        /* Closure of long 'if' that deals with either continuing  */
        /* to fetch data for an image, or getting the first chunk  */
        /* of data for a fetch. (The code immediately above is for */
        /* getting the first chunk).                               */
      }
      /* Closure of long 'if' that sees if a fetch has started */
      /* for an image. (The code immediately above excutes if  */
      /* it has, else a fetch is started).                     */
    }

    /* Closure of long 'if' that checks to see if there are */
    /* images to be fetched, and that the fetch status is   */
    /* not BS_DATAFETCH (i.e. other fetch activity has      */
    /* ceased).                                             */
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_process_null: Successful\n");
  #endif

  return NULL;
}

/*************************************************/
/* image_mark_as_deleted()                       */
/*                                               */
/* Mark an image as deleted, but don't remove it */
/* from the image array yet. When all images     */
/* that are to be deleted have been thus marked, */
/* call image_purge_deleted_entries before       */
/* continuing.                                   */
/*                                               */
/* Does not free any memory at all, in the image */
/* array or any other blocks. Does not cancel    */
/* fetches or sort out other image references    */
/* such as background_image fields in            */
/* browser_data structures either, because this  */
/* may be called when images are renumbered      */
/* rather than wholly removed. If completely     */
/* wiping an image, make sure you do all of that */
/* *before* calling here.                        */
/*                                               */
/* Parameters: Number of the image to mark as    */
/*             deleted.                          */
/*************************************************/

static void image_mark_as_deleted(int i)
{
  /* Try to set the flags up so that if for some horrific */
  /* reason this image should end up being processed as a */
  /* "live" item, it'll do minimum damage!                */

  idata[i].handle    = 0;
  idata[i].istore    = NULL;

  idata[i].deleted   = 1;

  idata[i].fetched   = 1;
  idata[i].delayed   = 0;
  idata[i].success   = 1;

  idata[i].hadfirst  = 1;
  idata[i].reformat  = 0;
  idata[i].hadfiller = 0;
  idata[i].canredraw = 0;
  idata[i].priority  = 0;

  idata[i].token     = NULL;

  return;
}

/*************************************************/
/* image_mark_as_gcable()                        */
/*                                               */
/* Mark an image as suitable for garbage         */
/* collection. Such images may exist in the      */
/* image array for as long as required and may   */
/* be reclaimed as working items by calls to     */
/* image_new_image.                              */
/*                                               */
/* Parameters: Number of the image to mark as    */
/*             suitable for garbage collection.  */
/*************************************************/

static void image_mark_as_gcable(int i)
{
  idata[i].token = NULL;

  /* Yup, that was all that needs doing for now */

  return;
}

/*************************************************/
/* image_discard()                               */
/*                                               */
/* For a given browser, discard images:          */
/*                                               */
/* * Any images which are xrefed by another      */
/*   browser have their ownership transferred    */
/*   to that other browser and the xrefing item  */
/*   is removed instead                          */
/*                                               */
/* * Any images owned by the given browser which */
/*   just xref other images are removed          */
/*                                               */
/* * Any remaining images holding actual image   */
/*   data are marked for garbage collection but  */
/*   not removed immediately.                    */
/*                                               */
/* When an image is removed, all data, including */
/* fetches, ImageLib info and external refs to   */
/* the image number is sorted out. Remaining     */
/* items in the image_info array may end up      */
/* renumbered.                                   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*************************************************/

_kernel_oserror * image_discard(browser_data * b)
{
  int i, xref;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("\nimage_discard: Called for %p. There are %d images.\n\n", b, nimages);
  #endif

  if (!nimages) return NULL;

  /* See if any images cross reference those in the browser */
  /* for which images will be discarded. If so, 'move' the  */
  /* cross referencee over to be owned by the cross         */
  /* referencer.                                            */

  _swix(Hourglass_Start, _IN(0), 1);

  /* Must go backwards because we may delete items from the array */
  /* during the loop itself                                       */

  for (i = nimages - 1; i >= 0; i--)
  {
    xref = idata[i].xref;

    if (idata[i].owner != b && xref >= 0 && idata[xref].owner == b)
    {
      /* Keep the xref image, since that holds the real data and */
      /* is doing all the fetching, etc. - it works out as less  */
      /* effort overall (especially in the second pass below) to */
      /* delete the cross referencing image. This may seem a bit */
      /* odd as though we've been called to delete the images    */
      /* owned by browser 'b', in the first pass we end up       */
      /* deleting structures owned by completely different       */
      /* browsers...                                             */

      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_discard: Transferring cross referencer %d to cross referencee %d\n", i, xref);
      #endif

      idata[xref].owner      = idata[i].owner;
      idata[xref].x          = idata[i].x;
      idata[xref].y          = idata[i].y;

      idata[xref].token      = idata[i].token;
      idata[xref].last_used  = idata[i].last_used;

      idata[xref].currw      = idata[i].currw;
      idata[xref].currh      = idata[i].currh;
      idata[xref].xref       = -1;

      idata[xref].delayed    = idata[i].delayed;

      idata[xref].fixedsize  = idata[i].fixedsize;
      idata[xref].background = idata[i].background;

      idata[xref].hadfirst   = idata[i].hadfirst;
      idata[xref].canredraw  = idata[i].canredraw;
      idata[xref].priority   = idata[i].priority;

      /* Ensure the token is up to date */

      #ifdef FAST_TOKEN_REFERENCE

        if (idata[xref].token)
        {
          idata[xref].token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
          idata[xref].token->flags |= ((xref + 1) << FAST_TOKEN_REFERENCE_SHIFT);
        }

      #endif

      /* Did the image we're transferring a new owner to have */
      /* RegisterFiller called for it, with the old owner?    */

      if (idata[xref].hadfiller)
      {
        /* If an image became a background, ImageLib may have withdrawn the */
        /* RegisterFiller function...                                       */

        if (!idata[xref].istore->RegisterFiller)
        {
          idata[xref].hadfiller = 0;
        }
        else
        {
          /* Recall the RegisterFiller function with the new owner details */

          show_error_ret(image_register_filler(xref));
        }
      }

      /* If this is a background image for the cross referencer... */

      if (i == idata[i].owner->background_image)
      {
        /* Update the browser_data 'background_image' field to point to the */
        /* new cross reference image number.                                */

        idata[i].owner->background_image = xref;
      }

      /* If the cross referencee was being fetched, may need to */
      /* claim fetch nulls in the cross referencer to finish    */
      /* the job.                                               */

      if (idata[xref].handle && !idata[i].owner->fetch_handler)
      {
        fetchpage_claim_nulls(idata[i].owner);
        toolbars_update_status(idata[i].owner, Toolbars_Status_GetPics);
      }

      /* Delete the cross referencer */

      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_discard: Deleting entry owned by %p that cross references image %d\n\n", idata[i].owner, idata[i].xref);
      #endif

      image_destroy(i);
    }

    /* OK, so this image isn't owned by another browser but cross referencing */
    /* one owned by ourselves. A simpler case is where we own an image that   */
    /* just cross references another - we can delete those straight away      */

    else if (idata[i].owner == b)
    {
      if (idata[i].xref >= 0)
      {
        #ifdef TRACE
          if (tl & (1u<<15)) Printf("image_discard: Image %d is a simple cross-referencer, deleting it\n\n", i);
        #endif

        image_destroy(i);
      }

      /* Next case; this is owned by us but holds real data. In this case, mark */
      /* it as suitable for garbage collection but not as deleted.              */

      else if (idata[i].bytesgot)
      {
        #ifdef TRACE
          if (tl & (1u<<15)) Printf("image_discard: Image %d being marked for GC\n", i);
        #endif

        image_mark_as_gcable(i);
      }

      /* Last case: Not a cross referencer, but has no data yet - get rid of it */

      else
      {
        #ifdef TRACE
          if (tl & (1u<<15)) Printf("image_discard: Image does not cross reference but has no bytes fetched for it yet; so deleting it\n\n", i);
        #endif

        image_destroy(i);
      }
    }
  }

  _swix(Hourglass_Off, 0);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_discard: Delete pass complete; there are %d images. Calling clearup function.\n\n", nimages);
  #endif

  image_post_deletion_clearup();

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("\nimage_discard: Successful. Post-clearup, there are %d images.\n\n", nimages);
  #endif

  return NULL;
}

/*************************************************/
/* image_destroy()                               */
/*                                               */
/* Close down any fetch associated with an       */
/* image, deal with any references to it (e.g.   */
/* the background_image field of a browser_data  */
/* structure), and remove all data except for    */
/* the actual image_info array entry. The item   */
/* is marked as deleted.                         */
/*                                               */
/* Callers should be aware of the need to call   */
/* image_post_deletion_clearup as soon as        */
/* possible after a round of image deletions.    */
/*                                               */
/* Parameters: Number of the image to remove.    */
/*************************************************/

static void image_destroy(int image)
{
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_destroy: Called for image %d\n", image);
  #endif

  /* If the image was being fetched, close that session */

  if (idata[image].handle)
  {
    html_close(idata[image].handle);
    idata[image].handle = 0;
  }

  if (idata[image].istore)
  {
    #ifdef STRICT_PARSER

      /* Report any errors as Continue-only in strict parser mode */

      _kernel_oserror * e;

      e = idata[image].istore -> Delete(idata[image].istore);

      if (e)
      {
        e->errnum = Utils_Error_Custom_Message;
        show_error_ret(e);
      }

    #else

      /* If not in Strict mode, ignore any errors */

      idata[image].istore -> Delete(idata[image].istore);

    #endif

    idata[image].istore = NULL;
  }

  /* Get rid of associated data except the image_info struct */

  image_remove_all_data(image);

  /* Clear the background image field of the owner if necessary */

  if (idata[image].owner->background_image == image)
  {
    idata[image].owner->background_image = -1;
  }

  /* Mark the image as deleted */

  image_mark_as_deleted(image);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_destroy: Image %d deleted\n\n", image);
  #endif
}

/*************************************************/
/* image_renumber()                              */
/*                                               */
/* Move an image in the image array. Copies      */
/* over the structure from new position to old   */
/* and marks the old as deleted.                 */
/*                                               */
/* Destination image number must be a deleted    */
/* image!                                        */
/*                                               */
/* Parameters: Image's current number;           */
/*                                               */
/*             Image's desired number.           */
/*                                               */
/* Returns:    1 if the item was renumbered, 0   */
/*             if there was a problem (e.g.      */
/*             parameters out of range,          */
/*             destination image not deleted,    */
/*             etc.).                            */
/*************************************************/

static int image_renumber(int old, int new)
{
  if (
       old < 0        ||
       new < 0        ||
       old >= nimages ||
       new >= nimages ||
       old == new
     )
     return 0;

  if (!idata[new].deleted)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "In image_renumber, %d can't be renumbered to %d as the latter has not been deleted!",
              old,
              new);

      show_error_ret(&erb);

    #endif

    return 0;
  }

  /* First off, repoint any images which xref this one, if this */
  /* image has image data (else it can't be xref'd)             */

  if (idata[old].istore)
  {
    int i;

    for (i = 0; i < nimages; i++)
    {
      if (idata[i].xref == old) idata[i].xref = new;
    }
  }

  /* Sort out background images */

  if (idata[old].owner->background_image == old) idata[old].owner->background_image = new;

  /* Copy the old structure into the new position */

  idata[new] = idata[old];

  /* Reregister filler functions, if necessary */

  if (idata[new].hadfiller)
  {
    /* If so, then provided the filler function is still available, */
    /* reregister with the new image number.                        */

    if (!idata[new].istore->RegisterFiller)
    {
      idata[new].hadfiller = 0;
    }
    else
    {
      show_error_ret(image_register_filler(new));
    }
  }

  /* Update the associated token */

  #ifdef FAST_TOKEN_REFERENCE

    if (idata[new].token)
    {
      idata[new].token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
      idata[new].token->flags |= ((new + 1) << FAST_TOKEN_REFERENCE_SHIFT);
    }

  #endif

  /* Mark the old item as deleted. */

  image_mark_as_deleted(old);

  /* Finished */

  return 1;
}

/*************************************************/
/* image_purge_deleted_entries()                 */
/*                                               */
/* Gets rid of items in the image array which    */
/* are marked as deleted by renumbering things   */
/* to fill holes and then shrinking the image    */
/* array block.                                  */
/*                                               */
/* Assumes nimages is set up to include all of   */
/* the image array entries (i.e. it hasn't been  */
/* decremented yet) and decrements it before     */
/* exitting.                                     */
/*                                               */
/* Images marked as deleted but still in the     */
/* image array MUST ALWAYS BE REMOVED by this    */
/* function before anything else goes on after a */
/* round of deleting things. Deleted images will */
/* cause significant problems if run through the */
/* rest of the image system...!                  */
/*                                               */
/* This function does not touch any allocation   */
/* blocks other than idata, holding the array of */
/* image_info structures. The caller should      */
/* clean up any other image related data when    */
/* going through images marking them as deleted. */
/*                                               */
/* Returns:    1 if any items were deleted (so   */
/*             nimages will have been            */
/*             decremented appropriately), else  */
/*             0.                                */
/*************************************************/

static int image_purge_deleted_entries(void)
{
  int first_space = -1;
  int last_live   = -1;
  int finished    = 0;

  int i;
  int newsize;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_purge_deleted_entries: Called\n");
  #endif

  /* Shuffle non-deleted items from higher in the image */
  /* array down into free places currently held by      */
  /* deleted items lower down. On the whole, we're      */
  /* likely to shuffle less data and renumber fewer     */
  /* images this way than by a dumb "shuffle data down  */
  /* over the deleted hole" approach.                   */

  do
  {
    /* Find the first deleted item in the array */

    for (
          i = first_space == -1 ? 0 : first_space;
          i < nimages;
          i++
        )
    {
      if (idata[i].deleted)
      {
        first_space = i;
        break;
      }
    }

    if (first_space == -1)
    {
      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_purge_deleted_entries: No images are marked as deleted, exitting\n");
      #endif

      return 0;
    }

    /* Find the last non-deleted (live) item in the array */

    for (
          i = last_live == -1 ? (nimages - 1) : last_live;
          i >= 0;
          i--
        )
    {
      if (!idata[i].deleted)
      {
        last_live = i;
        break;
      }
    }

    /* If we can find a live image, proceed */

    if (last_live != -1)
    {
      if (first_space > last_live)
      {
        /* If the first space is above the last live item, we */
        /* can just shrink the array.                         */

        nimages = first_space; /* I.e. last_live + 1 */

        #ifdef TRACE

          if (first_space - last_live != 1)
          {
            erb.errnum = Utils_Error_Custom_Normal;

            StrNCpy0(erb.errmess,
                     "You're imagining this error from image_purge_deleted_entries, because it is impossible for it to occur.");

            show_error_ret(&erb);
          }

        #endif

        finished = 1;
      }
      else
      {
        /* If the first space is below the last live item, must start */
        /* moving things around. Ho hum.                              */

        #ifdef TRACE
          if (tl & (1u<<15)) Printf("image_purge_deleted_entries: Renumbering %d to %d\n", last_live, first_space);
        #endif

        image_renumber(last_live, first_space);
      }
    }

    /* If there are no live images, can exit the loop */

    else
    {
      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_purge_deleted_entries: There are no images left\n");
      #endif

      nimages  = 0;
      finished = 1;
    }
  }
  while (!finished);

  /* Check lastimage is OK */

  if (lastimage >= nimages) lastimage = nimages - 1;

  /* Ensure the image_info data block matches the size of the images now present */

  newsize = nimages * sizeof(image_info);

  #ifdef TRACE
    {
      int oldsize;

      oldsize    = flex_size((flex_ptr) &idata);
      flexcount -= (oldsize - newsize);

      if (tl & (1u<<14)) Printf("**   flexcount: %d\n",flexcount);
    }
  #endif

  if (idata)
  {
    if (newsize) flex_extend ((flex_ptr) &idata, newsize);
    else         flex_free   ((flex_ptr) &idata);
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_purge_deleted_entries: Successful, nimages now %d\n", nimages);
  #endif

  return 1;
}

/*************************************************/
/* image_post_deletion_clearup()                 */
/*                                               */
/* After deleting a set of images or image_info  */
/* structures which had no associated data in    */
/* ImageLib, call this to tidy up - deregister   */
/* the animation handler, resize the idata flex  */
/* block, etc.                                   */
/*************************************************/

static void image_post_deletion_clearup(void)
{
  int i;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_post_deletion_clearup: Called\n");
  #endif

  _swix(Hourglass_Start, _IN(0), 1);

  /* Compact the image_info array and shrink the idata flex block; */
  /* if the function returns 0 we've no work to do here            */

  if (image_purge_deleted_entries())
  {
    /* If there is an animation handler present, but no animated */
    /* images remain, remove that handler.                       */

    if (animhandler)
    {
      int found = 0;

      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_post_deletion_clearup: There is an animation handler present; checking to see if it can be removed\n");
      #endif

      for (i = 0; i < nimages; i++)
      {
        if (idata[i].istore && idata[i].istore->animated)
        {
          found = 1;
          break;
        }
      }

      if (!found)
      {
        #ifdef TRACE
          if (tl & (1u<<15)) Printf("image_post_deletion_clearup: Removing animation handler\n\n");
        #endif

        deregister_null_claimant(Wimp_ENull, (WimpEventHandler *) image_animate_images, NULL);
        animhandler = 0;
      }

      #ifdef TRACE

        else
        {
          if (tl & (1u<<15)) Printf("image_post_deletion_clearup: The handler is still required\n\n");
        }

      #endif
    }
  }

  /* Trace build sanity check */

  #ifdef FAST_TOKEN_REFERENCE
    #ifdef TRACE

      {
        for (i = 0; i < nimages; i ++)
        {
          if (idata[i].token && (idata[i].token->flags >> FAST_TOKEN_REFERENCE_SHIFT) - 1 != i)
          {
            Printf("image_post_deletion_clearup: \0211Image %d is referenced incorrectly by its token\0217 - correcting...\n", i);

            idata[i].token->flags &= (1 << FAST_TOKEN_REFERENCE_SHIFT) - 1;
            idata[i].token->flags |= ((i + 1) << FAST_TOKEN_REFERENCE_SHIFT);
          }
        }
      }

    #endif
  #endif

  _swix(Hourglass_Off, 0);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_post_deletion_clearup: Successful\n");
  #endif

  return;
}

/*************************************************/
/* image_gc()                                    */
/*                                               */
/* Garbage collect unused images.                */
/*                                               */
/* If removing only one specific image (see      */
/* parameters list), image_post_deletion_clearup */
/* is NOT called - it is assumed that the caller */
/* of this function may want to remove several   */
/* images and it would be very inefficient to    */
/* clear up after each one. So, if a specific    */
/* unique ID is given for image removal, the     */
/* caller must remember to invoke                */
/* image_post_deletion_clearup.                  */
/*                                               */
/* It is assumed that for any images marked as   */
/* suitable for GC, the owner browser still      */
/* exists. Consequently, this function MUST be   */
/* called for a given browser if that browser is */
/* about to be shut down.                        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images to collect */
/*             or NULL to remove any images      */
/*             regardless of owner;              */
/*                                               */
/*             Unique ID of a specific image to  */
/*             remove - 0 to remove all images   */
/*             regardless of ID;                 */
/*                                               */
/*             If removing images regardless of  */
/*             unique ID (0 is passed above),    */
/*             images with the 'from_js' flag    */
/*             set are still not removed unless  */
/*             a non-zero value is passed here.  */
/*************************************************/

_kernel_oserror * image_gc(browser_data * b, unsigned int uid, int remove_js_too)
{
  int i;
  int clearup = 0;

  /* UID is zero; remove all pending images */

  if (uid == 0)
  {
    /* Count backwards as we may remove idata array items */
    /* during the loop's execution                        */

    for (i = nimages - 1; i >= 0; i --)
    {
      if (
           (!b || idata[i].owner == b)          &&
           (remove_js_too || !idata[i].from_js) &&
           !idata[i].token
         )
      {
        image_destroy(i);
        clearup = 1;
      }
    }
  }

  /* Find the given unique ID */

  else
  {
    int i;
    int found = -1;

    for (i = 0; i < nimages; i ++)
    {
      if (idata[i].unique_id == uid)
      {
        found = i;
        break;
      }
    }

    if (found >= 0)
    {
      /* Found it - check it's not in use still! */

      #ifdef TRACE

        if (idata[found].token)
        {
          erb.errnum = Utils_Error_Custom_Normal;

          StrNCpy0(erb.errmess, "Unique ID given to image_gc() refers to an image with a non-NULL token field!");

          return &erb;
        }

      #else

        if (idata[found].token) return NULL;

      #endif

      /* OK, get rid of the item */

      image_destroy(found);
      clearup = 1;
    }

    #ifdef TRACE

      else
      {
        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess, "Unique ID not recognised in image_gc()");

        return &erb;
      }

    #endif
  }

  if (clearup) image_post_deletion_clearup();

  return NULL;
}

/*************************************************/
/* image_gc_js()                                 */
/*                                               */
/* Garbage collect unused images with the        */
/* 'from_js' flag set.                           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images to collect */
/*             or NULL to remove any images      */
/*             regardless of owner.              */
/*************************************************/

_kernel_oserror * image_gc_js(browser_data * b)
{
  // "Placeholder" function...

  return NULL;
}

/*************************************************/
/* image_gc_oldest()                             */
/*                                               */
/* Remove the oldest image which is pending      */
/* garbage collection owned by a given browser.  */
/*                                               */
/* Calls image_gc with a specific image unique   */
/* ID, therefore image_post_deletion_clearup is  */
/* not called - the caller of this function must */
/* remember to do that.                          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image to remove.  */
/*                                               */
/* Returns:    1 if an item was removed, else 0. */
/*************************************************/

static int image_gc_oldest(browser_data * b)
{
  int    i;
  int    found  = -1;
  time_t oldest = time(NULL);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_gc_oldest: Called for %p\n",b);
  #endif

  /* Look for the oldest item */

  for (i = 0; i < nimages; i ++)
  {
    if (
         idata[i].owner == b &&
         !idata[i].token     &&
         !idata[i].from_js
       )
    {
      if (difftime(idata[i].last_used, oldest) < 0)
      {
        oldest = idata[i].last_used;
        found  = i;
      }
    }
  }

  /* If we got one, remove it */

  #ifdef TRACE
    if (tl & (1u<<15))
    {
      if (found >= 0) Printf("image_gc_oldest: Oldest is %d\n", found);
      else            Printf("image_gc_oldest: No appropriate image found\n");
    }
  #endif

  if (found >= 0) image_gc(b, idata[found].unique_id, 0);

  /* Say whether or not one was removed */

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_gc_oldest: Successful\n");
  #endif

  return found >= 0 ? 1 : 0;
}

/*************************************************/
/* image_maybe_gc()                              */
/*                                               */
/* Possibly garbage collect unused images for    */
/* the given browser.                            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             who's images may be garbage       */
/*             collected.                        */
/*************************************************/

_kernel_oserror * image_maybe_gc(browser_data * b)
{
  int gc;
  int any = 0;

  _swix(Hourglass_On, 0);

  /* Keep going until we don't need to GC anymore... */

  do
  {
    gc = 0;

    /* Deal with the free RAM constraint */

    if (choices.free_ram_limit > 0)
    {
      unsigned int free;

      if (
           !_swix(Wimp_SlotSize,
                  _INR(0,1) | _OUT(2),

                  -1,
                  -1,

                  &free)
         )
      {
        if (free < choices.free_ram_limit) gc = 1;
      }
    }

    /* Deal with the unused images constraint */

    if (choices.unused_image_limit > 0)
    {
      int i;
      int unused = 0;

      for (i = 0; i < nimages; i ++)
      {
        if (
             idata[i].owner == b &&
             !idata[i].token     &&
             !idata[i].from_js
           )
           unused ++;
      }

      if (unused > choices.unused_image_limit) gc = 1;
    }
    else if (choices.unused_image_limit == 0) gc = 1;

    /* If required, get rid of the oldest image */

    if (gc) any = 1, gc = image_gc_oldest(b);
  }
  while (gc);

  /* Clear up after deletions, if there were any */

  if (any) image_post_deletion_clearup();

  _swix(Hourglass_Off, 0);

  return NULL;
}

/*************************************************/
/* image_refetch()                               */
/*                                               */
/* Reloads an image, redrawing as required and   */
/* setting the priority flag as asked.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images;           */
/*                                               */
/*             The image number;                 */
/*                                               */
/*             Value to set Priority flag to (so */
/*             that if 'show foreground images'  */
/*             is turned off, the image will     */
/*             override it);                     */
/*                                               */
/*             1 to redraw the image, 0 to not   */
/*             bother (e.g. for many images,     */
/*             may want to redraw the whole      */
/*             window instead).                  */
/*************************************************/

static void image_refetch(browser_data * b, int image, int priority, int redraw)
{
  int i;

  /* Sanity check */

  if (image < 0 || image >= nimages || !b) return;

  /* Use the cross referenced base image if necessary */

  if (idata[image].xref >= 0) image = idata[image].xref;

  if (
       (
         !idata[image].fetched &&  /* If the image isn't fetched...  */
         idata[image].delayed      /* ...and was flagged as delayed, */
       )
       ||
       (
         idata[image].fetched  &&  /* or has fetched but...       */
         !idata[image].success &&  /* ...not successfully, and... */
         !idata[image].istore      /* ...it has no ImageLib entry */
       )
     )
  {
    /* If the image says it isn't fetched, reset its 'bytesgot' counter */

    if (!idata[image].fetched) idata[image].bytesgot = 0;

    /* Set up the flags */

    idata[image].success  = 0;
    idata[image].delayed  = 0;
    idata[image].fetched  = 0;
    idata[image].priority = priority;

    /* If we deleted the ImageLib entry, need to recreate it */

    if (!idata[image].istore && idata[image].xref == -1)
    {
      #ifdef ALL_FAST
        idata[image].istore = NewImage(NULL, IMAGE_FAST);
      #else
        idata[image].istore = NewImage(NULL, image == b->background_image ? IMAGE_FAST : 0);
      #endif
    }

    /* Now handle the fetching */

    if (!b->fetch_handler)
    {
      fetchpage_claim_nulls(b);
      toolbars_update_status(b, Toolbars_Status_GetPics);
    }
  }
  else
  {
    /* If the image is already loaded, just redraw it */

    idata[image].priority = priority;
    idata[image].hadfirst = 0;

    if (redraw) image_update_image(b, image, NULL);
  }

  /* Deal with all cross referencers of the base image */

  for (i = 0; i < nimages; i++)
  {
    if (idata[i].xref == image)
    {
      idata[i].priority = priority;
      idata[i].hadfirst = 0;

      if (redraw) image_update_image(b, i, NULL);
    }
  }
}

/*************************************************/
/* image_reload()                                */
/*                                               */
/* Reloads an image, redrawing as required and   */
/* setting the priority flag so that even if a   */
/* browser has 'show foreground images' turned   */
/* off, the reloading image (and all that cross  */
/* reference it) will still be shown.            */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images;           */
/*                                               */
/*             Address of the token representing */
/*             the image.                        */
/*************************************************/

void image_reload(browser_data * b, HStream * token)
{
  int image = image_get_token_image_xref(b, token);

  if (image < 0) return;

  image_refetch(b, image, 1, 1);
}

/*************************************************/
/* image_restart_fetches()                       */
/*                                               */
/* If image loading has been suspended for any   */
/* reason, it can be resumed by calling this     */
/* function. Any images already loaded will be   */
/* reshown. The priority flag for images is not  */
/* set, so the browser must be set to display    */
/* foreground images for anything to show up.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images;           */
/*                                               */
/*             1 to restart foreground fetches,  */
/*             else 0;                           */
/*                                               */
/*             1 to restart background fetches,  */
/*             else 0.                           */
/*************************************************/

void image_restart_fetches(browser_data * b, int foreground, int background)
{
  if (nimages)
  {
    int image;

    /* Loop round all the images */

    for (image = 0; image < nimages; image++)
    {
      /* If an image has not been fetched and is flagged as being */
      /* delayed, or an image has been fetched but has not been   */
      /* flagged as succesfully fetched and has not been dealt    */
      /* with by the image library (the istore field is NULL),    */
      /* then clear all the fetch flags for the image so that it  */
      /* will later be fetched.                                   */

      if (idata[image].owner == b)
      {
        /* Only fetch foreground or background images if asked to */

        if (
             (idata[image].background  && background) ||
             (!idata[image].background && foreground)
           )
           image_refetch(idata[image].owner, image, 0, 0);
      }
    }
  }
}

/*************************************************/
/* image_update_area()                           */
/*                                               */
/* Updates (redraws) part of an image, which     */
/* will reflect any new data fetched for it if   */
/* the whole image hasn't been fetched yet.      */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The left hand X window coordinate */
/*             in OS units for the image;        */
/*                                               */
/*             The bottom Y window coordinate in */
/*             OS units for the image;           */
/*                                               */
/*             A BBox defining a rectangle       */
/*             relative to X and Y which is the  */
/*             area to update;                   */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1;                      */
/*                                               */
/*             1 to force a redraw (i.e. clear   */
/*             any previously drawn data first), */
/*             zero to not clear the region.     */
/*************************************************/

static _kernel_oserror * image_update_area(browser_data * b, int x, int y, BBox * ubox,
                                           int image, int redraw)
{
  _kernel_oserror       * e;
  WimpRedrawWindowBlock   r;
  int                     more, sx, sy;
  int                     xref;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_update_area: Called for image %d\n",image);
  #endif

  /* Zero width/height images are invisible */

  if (ubox->xmax - ubox->xmin == 0 || ubox->ymax - ubox->ymin == 0)
  {
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_update_area: Image has 0 width or height, so don't need to redraw anything\n");
    #endif

    return NULL;
  }

  /* If the image cannot be redrawn yet, don't redraw it... */

  if (!idata[image].canredraw)
  {
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_update_area: Image %d can't be redrawn yet (canredraw = 0)\n",image);
    #endif

    return NULL;
  }

  r.window_handle = b->window_handle;

  r.visible_area  = *ubox;

  r.visible_area.xmin += x;
  r.visible_area.ymin += y;
  r.visible_area.xmax += x;
  r.visible_area.ymax += (y + 4);

  /* Ensure that 'xref' holds the number of the given image, which may well */
  /* cross reference another, 'image', that has the actual render data.     */

  xref = image;
  if (idata[image].xref >= 0) image = idata[image].xref;

  /* If the image may acquire a mask during rendering, even if it is not    */
  /* initially transparent, need to force the area to redraw to clear first */

  if (
       idata[image].istore->mutable_mask ||
       redraw
     )
     wimp_force_redraw(r.window_handle,
                       r.visible_area.xmin,
                       r.visible_area.ymin,
                       r.visible_area.xmax,
                       r.visible_area.ymax);
  else
  {
    /* Otherwise, do a less flickery non-clearing update */

    wimp_update_window(&r, &more);

    sx = coords_x_toscreen(x, &r);
    sy = coords_y_toscreen(y, &r);

    while(more)
    {
      if (
           b->show_foreground                     ||
           b->displayed == Display_External_Image ||
           idata[xref].priority
         )
      {
        browser_redrawing = b;
        image_redrawing   = xref;

        e = idata[image].istore -> Render(idata[image].istore,
                                          sx,
                                          sy,
                                          100,
                                          idata[xref].currw,
                                          idata[xref].currh);

        browser_redrawing = NULL;
        image_redrawing   = -1;

        #ifdef STRICT_PARSER

          if (e)
          {
            e->errnum = Utils_Error_Custom_Message;
            show_error_ret(e);
          }

        #endif
      }

      #ifdef ANTI_TWITTER

        if (!printing) anti_twitter(&r);

      #endif

      wimp_get_rectangle(&r,&more);
    }
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_update_area: Successful\n");
  #endif

  return NULL;
}

/*************************************************/
/* image_update_image()                          */
/*                                               */
/* Update the specified image number on screen,  */
/* including all which cross reference it. If    */
/* the image has changed size on screen then     */
/* start a reformat from the first occurrence    */
/* (i.e. smallest token number), otherwise just  */
/* do an update on the relevant rectangle for    */
/* each occurrence.                              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images;           */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1;                      */
/*                                               */
/*             Pointer (which may be NULL) to a  */
/*             BBox into which the image's size  */
/*             will be returned.                 */
/*************************************************/

static _kernel_oserror * image_update_image(browser_data * b, int image, BBox * box)
{
  int  i, actual;
  int  istart, iend;
  BBox whole;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_update_image: Called for image %d\n",image);
  #endif

  /* If a BBox is passed in here, then the image will be redrawn in that */
  /* specific region. Otherwise, the region is derived from the image's  */
  /* size. The BBox 'whole' is used for the latter case, so by setting   */
  /* 'box' to the address of this if a BBox was *not* given, we can then */
  /* transparently use this elsewhere and update either the requested    */
  /* area or the whole image without needing other special case code.    */
  /*                                                                     */
  /* If the image's 'hadfirst' flag is clear, it hasn't been through     */
  /* this function yet. In that case, want to ensure that the whole      */
  /* image is redrawn to clear any placeholder that will be plotted in   */
  /* its place; otherwise, only the part of the placeholder that         */
  /* corresponds to the requested redraw box will be cleared.            */

  if (!box || !idata[image].hadfirst) box = &whole;

  /* Now ensure that 'image' is the image with the render information, as */
  /* the rest of the code has to deal with all xref images to this one    */
  /* anyway.                                                              */
  /*                                                                      */
  /* So 'actual' is now the image number given to image_update_image, and */
  /* 'image' is the number of the image with associated render data; this */
  /* may be the same as 'actual' or may be equal to the contents of its   */
  /* 'xref' field.                                                        */

  actual = image;
  if (idata[actual].xref >= 0) image = idata[actual].xref;

  /* If there appears to be no data for the image, or it is less than */
  /* one pixel wide (i.e. not displayable for whatever reason), exit. */

  if (!idata[image].istore || (idata[image].istore && idata[image].istore->width < 1)) return NULL;

  /* Check if the image has become animated */

  if (idata[image].istore->animated)
  {
    /* If the image is animated and we haven't got a null handler */
    /* for animations, install one now.                           */

    if (!animhandler)
    {
      register_null_claimant(Wimp_ENull, (WimpEventHandler *) image_animate_images, NULL);
      animhandler = 1;
    }
  }

  /* Register a per-image filler function if it hasn't already got one */

  if (idata[image].istore->RegisterFiller && !idata[image].hadfiller)
  {
    show_error_ret(image_register_filler(image));
  }

  /* A few things are only done for images with actual image data; */
  /* only if these change do we need to worry about xrefs.         */

  if (actual == image)
  {
    /* When the image library gets some data for an image it will fill */
    /* in the width_os and height_os fields of the istore structure    */
    /* that 'image' points to. If the HTML source didn't specify a     */
    /* size for this or cross referencing images and the size is not   */
    /* the same as stored in currw / currh, flag that a reformat is    */
    /* needed for this image.                                          */

    if (
         !idata[actual].hadfirst             &&
         idata[image].istore->width_os  >= 0 &&
         idata[image].istore->height_os >= 0
       )
    {
      for (i = 0; i < nimages; i++)
      {
        if (
             (
               idata[i].xref == image ||
               i == image
             )
             && !idata[i].fixedsize
           )
        {
          BBox size;

          /* Ignore any existing currw and currh values - find the image */
          /* size based entirely on the HTML and the image itself        */

          image_get_image_size(b,
                               i,
                               &size,
                               1);

          /* Does the returned value differ from the stored size? If so, */
          /* flag that we must do a reformat for this image. It is up to */
          /* the reformatter to call back to routines in this source     */
          /* file and update currw and currh once the image is           */
          /* incorporated into a line array.                             */

          if (
               size.xmax != idata[i].currw ||
               size.ymax != idata[i].currh
             )
             idata[i].reformat = 1;
        }
      }
    }

    /* If the image is for the background, just refresh the window contents */
    /* with browser_update_window (remembering to update those windows that */
    /* cross reference the same background image, too).                     */

    if (image == idata[image].owner->background_image)
    {
      for (i = 0; i < nimages; i++)
      {
        if ((i == image || idata[i].xref == image) && idata[image].fetched)
        {
          browser_update_bottom(idata[i].owner, NULL);
        }
      }

      return NULL;
    }
  }

  /* Look through images for cross references */

  whole.xmin = whole.ymin = 0;

  if (actual == image) istart = 0,      iend = nimages - 1;
  else                 istart = actual, iend = actual;

  for (i = istart; i <= iend; i++)
  {
    /* If we're on the current image, or on one which  */
    /* references it, then proceed.                    */

    if (i == image || idata[i].xref == image)
    {
      BBox partial;
      int  l;
      int  noplot = 0;

      /* Set the 'whole' BBox to the size of the base image in OS units */

      image_get_image_size(b, i, &whole, 0);

      /* Ensure the redraw box returned by the image Load call */
      /* (or the BBox 'whole' from above) is scaled to fit the */
      /* actual image's dimensions.                            */
      /*                                                       */
      /* We don't scale if box = &whole, as in that case the   */
      /* bbox is already scaled, or if for some reason the     */
      /* width or height fields in the ImageLib image struct   */
      /* seem to be invalid.                                   */

      if (
           box != &whole                      &&
           idata[image].istore->width_os  > 0 &&
           idata[image].istore->height_os > 0
         )
      {
        partial.xmin = (box->xmin * whole.xmax) / idata[image].istore->width_os;
        partial.ymin = (box->ymin * whole.ymax) / idata[image].istore->height_os;
        partial.xmax = (box->xmax * whole.xmax) / idata[image].istore->width_os;
        partial.ymax = (box->ymax * whole.ymax) / idata[image].istore->height_os;
      }
      else partial = *box;

      /* If the image doesn't have position information, can't plot it */

      if (idata[i].x == -1 && idata[i].y == -1) noplot = 1;

      /* Only continue if the line containing a chunk */
      /* relating to the token which relates to this  */
      /* image (!) can be found.                      */

      if (idata[i].token) l = tokenutils_find_ancestor_line(idata[i].owner, idata[i].token);
      else                l = -1;

      if (l < 0) noplot = 1;

      /* May not be redrawing the image, but might still want to */
      /* reformat the page here if the size has changed.         */

      if (noplot)
      {
        if (!idata[i].hadfirst && !idata[i].fixedsize)
        {
          /* This is the first time we've known how big the image is since it   */
          /* was encountered in the HTML; record it in the image history, then. */

          if (idata[i].istore)
          {
            /* Ignore errors, this isn't vital */

            imghistory_record((const char **) &idata[i].flex->urldata,
                              0,
                              idata[i].istore->width_os,
                              idata[i].istore->height_os);
          }

          /* Now do the reformat, if the size changed */

          idata[i].hadfirst = 1;

          if (idata[i].reformat)
          {
            idata[i].reformat = 0;

            if (l >= 0) reformat_format_from(idata[i].owner,
                                             l - 1,
                                             0,
                                             i);
          }

         /* If we don't need to reformat, we can (potentially!) redraw */

          else idata[i].canredraw = 1;
        }
      }
      else
      {
        int       x, y;
        BBox      ibox;
        HStream * tp;

        x  = idata[i].x;
        y  = idata[i].y;
        tp = idata[i].token;

        if (
             tp &&
             !reformat_get_image_size(idata[i].owner,
                                      tp,
                                      &ibox)
           )
        {
          /* If the image size was obtained without error, */
          /* correct its X and Y coordinates appropriately */

          if (!idata[i].hadfirst)
          {
            int do_redraw = 1;

            idata[i].hadfirst = 1;

            /* Is the image size fixed in the HTML? If not, may need to do a */
            /* reformat.                                                     */

            if (!idata[i].fixedsize)
            {
              /* As above, this is the first time we've known how big the image is */
              /* since it was encountered in the HTML, so record it in the image   */
              /* history.                                                          */

              if (idata[i].istore)
              {
                /* Ignore errors, this isn't vital */

                imghistory_record((const char **) &idata[i].flex->urldata,
                                  0,
                                  idata[i].istore->width_os,
                                  idata[i].istore->height_os);
              }

              /* If the size changed, do a reformat */

              if (idata[i].reformat)
              {
                idata[i].reformat = 0;
                do_redraw         = 0; /* Reformatting - no extra redraws needed */

                reformat_format_from(idata[i].owner, l - 1, 0, i);
              }

              /* If we don't need to reformat, we can redraw */

              else idata[i].canredraw = 1;
            }

            /* If no reformat was needed, just do a redraw (which clears the */
            /* background first; see the very large comment earlier on). NB, */
            /* we don't need to force a redraw if the image is animated as   */
            /* regardless of whether or not it has a mask, the composition   */
            /* through the filler function leads to an unmasked image plot   */
            /* at the end of the day.                                        */

            if (do_redraw)
            {
              int animated, ai;

              if (idata[i].xref >= 0) ai = idata[i].xref;
              else                    ai = 0;

              if (idata[ai].istore) animated = idata[ai].istore->animated;
              else                  animated = 0;

              image_update_area(idata[i].owner,
                                x,
                                y,
                                &partial,
                                i,
                                !animated);
            }
          }

          /* Work out what region to redraw (may only require */
          /* a partial area update)                           */

          else if (partial.ymax < partial.ymin)
          {
            BBox ubox = partial;

            /* If the y max coordinate is less than the y min coordinate, */
            /* redraw from ymin to the top of the image, and from ymax to */
            /* the bottom. That way can miss out a middle section.        */

            ubox.ymin = partial.ymin;
            ubox.ymax = whole.ymax;

            image_update_area(idata[i].owner,
                              x,
                              y,
                              &ubox,
                              i,
                              0);

            ubox.ymax = partial.ymax;
            ubox.ymin = 0;

            image_update_area(idata[i].owner,
                              x,
                              y,
                              &ubox,
                              i,
                              0);
          }
          else if (partial.xmax < partial.xmin)
          {
            BBox ubox = partial;

            /* Similarly, if xmax is less than xmin, draw from xmin to the */
            /* right hand side of the image and from xmax to the left, so  */
            /* a vertical strip in the middle may be untouched.            */

            ubox.xmin = partial.xmin;
            ubox.xmax = whole.xmax;

            image_update_area(idata[i].owner,
                              x,
                              y,
                              &ubox,
                              i,
                              0);

            ubox.xmax = partial.xmax;
            ubox.xmin = 0;

            image_update_area(idata[i].owner,
                              x,
                              y,
                              &ubox,
                              i,
                              0);
          }
          else
          {
            /* Otherwise, redraw the requested box */

            image_update_area(idata[i].owner,
                              x,
                              y,
                              &partial,
                              i,
                              0);
          }

        /* Closure of 'if (tp && !reformat_get_image_size(...))' */
        }

      /* Closure of 'if (noplot)' - code immediately above is */
      /* executed in the 'else' section.                      */
      }

    /* Closure of 'if (i == image || idata[i].xref == image)' */
    }

  /* Closure of loop running round all the images */
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_update_image: Successful\n");
  #endif

  return NULL;
}

/*************************************************/
/* image_animate_images()                        */
/*                                               */
/* Checks all images to see if they need         */
/* updating. Designed to be called on null       */
/* events.                                       */
/*                                               */
/* Parameters are as standard for a Wimp event   */
/* handler.                                      */
/*************************************************/

int image_animate_images(int eventcode, WimpPollBlock * block, IdBlock * idb, browser_data * handle)
{
  int i, image, redraw;

  /* Scan round all images */

  for (i = 0; i < nimages; i++)
  {
    /* Find the image with associated render data */

    if (idata[i].xref >= 0) image = idata[i].xref;
    else                    image = i;

    /* Skip this image if it as already been dealt with */

    if (image >= i)
    {
      /* If this image does have such data, is flagged as */
      /* animated, and has a pointer to a NeedRedraw      */
      /* function, proceed.                               */

      if (
           idata[image].istore             &&
           idata[image].istore->animated   &&
           idata[image].istore->NeedRedraw
         )
      {
        BBox extent; // Not actually used yet...!

        #ifdef STRICT_PARSER

          /* Report any errors as Continue-only in strict parser mode */

          _kernel_oserror * e;

          e = idata[image].istore -> NeedRedraw(idata[image].istore, &redraw, &extent);

          if (e)
          {
            e->errnum = Utils_Error_Custom_Message;
            show_error_ret(e);
          }

        #else

          /* If not in Strict mode, ignore any errors */

          idata[image].istore -> NeedRedraw(idata[image].istore, &redraw, &extent);

        #endif

        /* Redraw the image, if required */

        if (redraw) image_update_image(idata[i].owner, i, NULL);
      }
    }
  }

  return 0;
}

/*************************************************/
/* image_register_filler()                       */
/*                                               */
/* Registers the given image and it's owning     */
/* browser with ImageLib. Must be called for     */
/* cross referencing images only.                */
/*                                               */
/* Parameters: The image number to register.     */
/*************************************************/

static _kernel_oserror * image_register_filler(int xref)
{
  #ifdef STRICT_PARSER

    {
      _kernel_oserror * e;

      /* Report any errors as Continue-only in strict parser mode */

      e = idata[xref].istore -> RegisterFiller(idata[xref].istore,
                                               (FillerFunction *) image_fill_background,
                                               idata[xref].owner,
                                               (int *) xref);

      if (e)
      {
        e->errnum = Utils_Error_Custom_Message;
        return e;
      }
    }

  #else

    /* If not in Strict mode, don't report errors */

    idata[xref].istore -> RegisterFiller(idata[xref].istore,
                                         (FillerFunction *) image_fill_background,
                                         idata[xref].owner,
                                         (int *) xref);
  #endif

  idata[xref].hadfiller = 1;

  return NULL;
}

/*************************************************/
/* image_fill_background()                       */
/*                                               */
/* Called as a FillerFunction for ImageLib,      */
/* this draws whatever background is appropriate */
/* for the registered image. Output should have  */
/* been redirected by ImageLib at this point.    */
/*                                               */
/* The way the function is registered should     */
/* leave void * handle pointing to the browser   */
/* owning the image with int * i actually being  */
/* an int (not an int *) holding the image       */
/* number for which the function was registered  */
/* in the first place. The owner of this image   */
/* is used for all general information - the     */
/* browser given in the first pointer is just    */
/* used to spot potential errors; if the browser */
/* given as the owner is not actually the owner  */
/* of the given image, the function will exit.   */
/*************************************************/

_kernel_oserror * image_fill_background(void * handle, int * i)
{
  WimpGetWindowStateBlock   state;
  _kernel_oserror         * e        = NULL;
  browser_data            * b        = (browser_data *) handle;

  int                       image;
  int                       ximage   = (int) i;

  int                       noplot   = 0;
  int                       bimage   = -1;
  int                       bximage  = -1;
  int                       bgcolour = -1;

  int                       is_background_image;
  int                       x, y, xorigin, yorigin;
  int                       w, h;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fill_background: Called with %p, %d\n", handle, i);
  #endif

  b      = browser_redrawing;
  ximage = image = image_redrawing;

  if (idata[ximage].xref >= 0) ximage = idata[ximage].xref;

  if (image >= nimages || image <=0)
  {
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: \0211Serious error!\0217 Invalid image number %d. Exitting.\n",image);
    #endif

    return NULL;
  }

  if (!b)
  {
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: \0211Serious error!\0217 Null browser_data pointer. Exitting.\n");
    #endif

    return NULL;
  }

  if (!is_known_browser(b))
  {
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: \0211Serious error!\0217 Browser %p is not a known current browser. Exitting.\n",b);
    #endif

    return NULL;
  }

//  if (idata[ximage].owner != b)
//  {
//    #ifdef TRACE
//      if (tl & (1u<<15)) Printf("image_fill_background: \0211Serious error!\0217 Actual owner of image %d = %p, given owner = %p. Exitting.\n",ximage,idata[ximage].owner,b);
//    #endif
//
//    return NULL;
//  }

  state.window_handle = b->window_handle;
  e = wimp_get_window_state(&state);
  if (e) return e;

//  /* Should never happen, but you never know... */
//
//  if (idata[ximage].xref >= 0) ximage = idata[ximage].xref;
//
//  /* See the top of the file for details on browser_redrawing */
//  /* and image_redrawing                                      */
//
//  if (browser_redrawing) b = browser_redrawing;
//
//  if (image_redrawing >= -1) image = image_redrawing;
//  else                       image = ximage;

  #ifdef TRACE
    if (tl & (1u<<15))
    {
      Printf("image_fill_background: Decided to use %p, %d\n", b, image);
      Printf("image_fill_background: Image w, h = %d, %d\n",idata[image].currw,idata[image].currh);
    }
  #endif

  /* Can't plot a background image to fill this one if there's no */
  /* background to plot, or if *this* is the background image.    */

  if (b->background_image >= 0)
  {
    bimage = bximage = b->background_image;
    if (idata[bximage].xref >= 0) bximage = idata[bximage].xref;
  }
  else bimage = bximage = -1, noplot = 1;

  if (image == bimage) is_background_image = 1;
  else                 is_background_image = 0;

  #ifdef TRACE
    if (tl & (1u<<15))
    {
      if (bimage >= 0) Printf("image_fill_background: Background image = %d, is_background_image = %d\n", bimage, is_background_image);
      else             Printf("image_fill_background: No background image\n");
    }
  #endif

  /* The image may exist in a table, and we should check what */
  /* background colour to draw if this is the case.           */

  if (!is_background_image && idata[image].token && b->use_source_cols)
  {
    int effective_bgcolour = tokenutils_background_colour(b, idata[image].token);
    if (effective_bgcolour > -1) bgcolour = effective_bgcolour, noplot = 1;
  }

  /* If bgcolor is -1 here, there's no table cell behind the image in */
  /* question blocking the page background. Thus we may have to do a  */
  /* few more checks to see if there's a background image we need to  */
  /* plot, and either way, get the page background colour.            */

  if (bgcolour == -1)
  {
    if (!is_background_image)
    {
      if (
           !noplot &&
           (
             !idata[bximage].fetched ||
             !idata[bximage].istore
           )
         )
         noplot = 1;

      if (
           !noplot               &&
           idata[bximage].istore &&
           (
             idata[bximage].istore->width_os  <= 0 ||
             idata[bximage].istore->height_os <= 0
           )
         )
         noplot = 1;
    }

    bgcolour = redraw_backcol(b);
  }

  xorigin = -idata[image].x;
  yorigin = -idata[image].y;

  /* Ensure dithered background colours have a dithering */
  /* (ECF) pattern that starts in the right place        */

  e = _swix(OS_SetECFOrigin,
            _INR(0,1),

            -xorigin,
            -yorigin);

  if (e) return e;

  /* We need to draw a plain colour background if we're filling the */
  /* background image, if we were asked not to plot a background    */
  /* image, or if we were but that image is itself transparent -    */
  /* that is, has a simple mask (alpha blended backgrounds will     */
  /* have their own filler function and we get called back when we  */
  /* invoke Render on the image further down). We also need to show */
  /* the plain background if background images are disabled for     */
  /* general display or for printing (and we're in a print loop).   */

  if (
       is_background_image                ||
       noplot                             ||
       idata[bximage].istore->transparent ||
       !b->show_background                ||
       (
         printing &&
         !printstyle_show_all()
       )
     )
  {
    redraw_set_colour(bgcolour);

    bbc_rectanglefill(0,
                      0,
                      idata[ximage].istore -> width_os,
                      idata[ximage].istore -> height_os);
  }

  /* If there's no background image to plot, exit here */

  if (
       is_background_image ||
       !b->show_background ||
       noplot              ||
       (
         printing &&
         !printstyle_show_all()
       )
     )
  {
    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: No background image to plot, so successful (exitting)\n");
    #endif

    return NULL;
  }

  /* Find the scale for the background plotting; if the foreground */
  /* image is scaled, then plotting the background at 1:1 will     */
  /* make it look scaled by the same amount, and things won't      */
  /* match up. We could either prescale the foreground image and   */
  /* then plot into that prescaled image, but this takes a lot     */
  /* of memory, or we could try to stick with a post-scaled image. */
  /* In that case, the background can either be ignored or we can  */
  /* try to scale it down so though it will look blocky and low    */
  /* resolution, it will at least roughly line up with the things  */
  /* around the foreground. This code does the last of the three.  */
  /*                                                               */
  /* Note the faster, simpler routine for scalings of 1:1 - avoids */
  /* floating point.                                               */

  if (
       idata[image].currw != idata[ximage].istore->width_os  ||
       idata[image].currh != idata[ximage].istore->height_os
     )
  {
    BBox           redraw;
    float          scalex, scaley;
    float          tempx,  tempy;
    float          tempw,  temph;
    int            htop;

    int            oimage;
    browser_data * obrowser;

    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: Plotting scaled background\n");
    #endif

    tempx = (float) idata[ximage].istore->width_os, tempy = (float) idata[ximage].istore->height_os;
    tempw = (float) idata[image].currw,             temph = (float) idata[image].currh;

    scalex = tempx / tempw;
    scaley = tempy / temph;

    /* Round the background image's width and height down to pixel boundaries */

    tempw = idata[bximage].istore->width_os;
    temph = idata[bximage].istore->height_os;

    w = ((int) (tempw * scalex + (float) 0.5)) & ~(wimpt_dx() - 1);
    h = ((int) (temph * scaley + (float) 0.5)) & ~(wimpt_dy() - 1);

    /* Work out the coordinates over which to tile the image */

    tempx = - (float) (idata[image].x);

    if (!controls.swap_bars) htop = toolbars_button_height(b) + toolbars_url_height(b);
    else                     htop = toolbars_status_height(b);

    if (htop) htop += wimpt_dy();

    tempy = - (float) idata[image].y
            - (float) htop;

    xorigin = (int) (tempx * scalex + (float) 0.5) + 1;
    yorigin = (int) (tempy * scaley + (float) 0.5) + 1;

    /* Exit if the background size appears to be too small */

    if (w < 1 || h < 1) return NULL;

    redraw.xmin = -((-xorigin) % w);
    redraw.ymin = -h;
    redraw.xmax = idata[ximage].istore->width_os;
    redraw.ymax = idata[ximage].istore->height_os + (yorigin - idata[ximage].istore->height_os) % h - 1;

    idata[bximage].istore -> ModeChange(idata[bximage].istore);

    /* Render the image over the redraw region with a scaled plot */

    for (y = redraw.ymax - h + wimpt_dy(); y >= redraw.ymin; y -= h)
    {
      for (x = redraw.xmin; x <= redraw.xmax; x += w)
      {
        /* Re-entrancy - if the background image is transparent we get */
        /* called again, so need to stack image_redrawing etc. first   */

        oimage            = image_redrawing;
        obrowser          = browser_redrawing;
        image_redrawing   = bimage;
        browser_redrawing = idata[bimage].owner;

        e = (idata[bximage].istore -> Render(idata[bximage].istore,
                                             x,
                                             y,
                                             100,
                                             w,
                                             h));

        image_redrawing   = oimage;
        browser_redrawing = obrowser;

        if (e) break;
      }

      if (e) break;
    }

    idata[bximage].istore -> ModeChange(idata[bximage].istore);
  }
  else
  {
    BBox           redraw;
    int            htop;

    int            oimage;
    browser_data * obrowser;

    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_fill_background: Plotting unscaled background\n");
    #endif

    w = (idata[bximage].istore->width_os)  & ~(wimpt_dx() - 1);
    h = (idata[bximage].istore->height_os) & ~(wimpt_dy() - 1);

    xorigin = -idata[image].x;

    if (!controls.swap_bars) htop = toolbars_button_height(b) + toolbars_url_height(b);
    else                     htop = toolbars_status_height(b);

    if (htop) htop += wimpt_dy();

    yorigin = -idata[image].y - htop;

    /* Exit if the background size appears to be too small */

    if (w < 1 || h < 1) return NULL;

    redraw.xmin = -((-xorigin) % w);
    redraw.ymin = -h;
    redraw.xmax = idata[ximage].istore->width_os;
    redraw.ymax = idata[ximage].istore->height_os + (yorigin - idata[ximage].istore->height_os) % h - 1;

    idata[bximage].istore -> ModeChange(idata[bximage].istore);

    /* Render the image over the redraw region with an unscaled plot */

    for (y = redraw.ymax - h + wimpt_dy(); y >= redraw.ymin; y -= h)
    {
      for (x = redraw.xmin; x <= redraw.xmax; x += w)
      {
        oimage            = image_redrawing;
        obrowser          = browser_redrawing;
        image_redrawing   = bimage;
        browser_redrawing = idata[bimage].owner;

        e = (idata[bximage].istore -> Render(idata[bximage].istore,
                                             x,
                                             y,
                                             100,
                                             -1,
                                             -1));
        image_redrawing   = oimage;
        browser_redrawing = obrowser;

        if (e) break;
      }

      if (e) break;
    }

    idata[bximage].istore -> ModeChange(idata[bximage].istore);
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fill_background: Successful\n");
  #endif

  return e;
}

/*************************************************/
/* image_redraw()                                */
/*                                               */
/* Does a high level redraw of an image, with    */
/* an outline to show where the image should be  */
/* if it isn't all plotted, or a slabbed box to  */
/* display broken or unfetched images.           */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to a RedrawWindowBlock    */
/*             struct which holds information    */
/*             about the current redraw session; */
/*                                               */
/*             Address of the token representing */
/*             the image;                        */
/*                                               */
/*             The X offset in window coords (so */
/*             OS units) of the left hand edge   */
/*             of the image;                     */
/*                                               */
/*             The Y offset in window coords (so */
/*             OS units) of the bottom edge of   */
/*             the image.                        */
/*************************************************/

_kernel_oserror * image_redraw(browser_data * b, WimpRedrawWindowBlock * r, HStream * token, int x, int y)
{
  int image, actual;
  int plotted = 0;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_redraw: Called with token %d\n", token);
  #endif

  /* Get the image number for the given token; 'actual' holds the actual */
  /* image for the given token, which may cross reference 'image', which */
  /* holds the actual render data.                                       */

  image = actual = image_get_token_image_actual(b, token);

  if (image < 0) return NULL;

  if (idata[actual].xref >= 0) image = idata[actual].xref;

  /* If the image has a fetched width and height, */
  /* and the browser choices specify that images  */
  /* should be shown (or the image itself has a   */
  /* high priority show bit set), display part or */
  /* all of the image.                            */

  if (
       image  >= 0 &&
       actual >= 0 &&
       (
         b->show_foreground                     ||
         b->displayed == Display_External_Image ||
         idata[actual].priority
       )
       && idata[actual].canredraw
       && idata[image].istore             /* Must check istore here, as if width / height are <= 0, */
       && idata[image].istore->width  > 0 /* the image library has no data for the image and will   */
       && idata[image].istore->height > 0 /* not have filled in (e.g.) the Render field. So you'd   */
     )                                    /* get a rather nasty abort trying to call it!            */
  {
    _kernel_oserror * e = NULL;

    if (idata[actual].currw && idata[actual].currh)
    {
      browser_redrawing = b;
      image_redrawing   = actual;

      e = idata[image].istore -> Render(idata[image].istore,
                                        x,
                                        y,
                                        100,
                                        idata[actual].currw,
                                        idata[actual].currh);

      browser_redrawing = NULL;
      image_redrawing   = -1;

      #ifdef STRICT_PARSER

        if (e)
        {
          e->errnum = Utils_Error_Custom_Message;
          show_error_ret(e);
        }

      #endif
    }

    if (!e) plotted = 1;
  }

  if (!plotted)
  {
    /* If the image was not plotted, either due to error or because there's */
    /* no data yet, plot a placeholder and any present ALT text instead.    */

    BBox         box;
    const char * text;
    HStream    * tp   = NULL;

    image_get_image_size(b, actual, &box, 0);

    box.xmin += x;
    box.ymin += y;
    box.xmax += x - box.xmin;
    box.ymax += y - box.ymin;

    box.xmin &= ~(wimpt_dx() - 1);
    box.ymin &= ~(wimpt_dy() - 1);

    /* If an image, the ALT text wants to be from the actual image, not one */
    /* that might be being cross referenced.                                */

    tp = (ISOBJECT(tp)) ? token : idata[actual].token;

    if (tp)
    {
      text = (ISOBJECT(tp)) ? HtmlOBJECTstandby(tp) : tp->text;

      redraw_draw_placeholder(b,
                              r,
                              &box,
                              tp,
                              text);
    }
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_redraw: Successful\n");
  #endif

  return NULL;
}

/*************************************************/
/* image_tile_window()                           */
/*                                               */
/* For a given redraw rectangle, tiles the       */
/* background image within that rectangle.       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the window and image; */
/*                                               */
/*             Pointer to a WimpRedrawWindow-    */
/*             Block structure defining the area */
/*             over which to tile the image;     */
/*                                               */
/*             The X and Y coordinates to take   */
/*             as the tile origin, in OS units.  */
/*                                               */
/* Returns:    1 for success, 0 for failure.     */
/*************************************************/

int image_tile_window(browser_data * b, WimpRedrawWindowBlock * r, int xorigin, int yorigin)
{
  _kernel_oserror * e;
  int               x, y, w, h;
  int               xmin, ymax;
  int               image;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_tile_window: Called, background_image = %d\n",b->background_image);
  #endif

  /* Can only tile if there's a background image defined and fully fetched */

  if (b->background_image < 0) return 0;

  image = b->background_image;
  if (idata[image].xref >= 0) image = idata[image].xref;

  if (!idata[image].fetched || !idata[image].istore) return 0;

  /* Round the width and height to pixel boundaries */

  w = idata[image].istore->width_os  & ~(wimpt_dx() - 1);
  h = idata[image].istore->height_os & ~(wimpt_dy() - 1);

  if (w < 1 || h < 1) return 0;

  /* Work out the coordinates over which to tile the image */

  xmin = coords_x_toworkarea(r->redraw_area.xmin,r);
  ymax = coords_y_toworkarea(r->redraw_area.ymax,r);

  xmin -= ((xmin - xorigin) % w);
  ymax -= ((ymax - yorigin) % h) + 1;

  xmin = coords_x_toscreen(xmin, r);
  ymax = coords_y_toscreen(ymax, r);

  /* Do a blank rectangle if the image is transparent (has a mask) */

  if (idata[image].istore->transparent)
  {
    redraw_set_colour(redraw_backcol(b));

    bbc_rectanglefill(r->redraw_area.xmin,
                      r->redraw_area.ymin,
                      r->redraw_area.xmax - r->redraw_area.xmin,
                      r->redraw_area.ymax - r->redraw_area.ymin);
  }

  /* Render the image over the redraw region */

  for (y = ymax - h + wimpt_dy(); y >= r->redraw_area.ymin - h; y -= h)
  {
    for (x = xmin; x <= r->redraw_area.xmax; x += w)
    {
      browser_redrawing = b;
      image_redrawing   = b->background_image;

      e = idata[image].istore -> Render(idata[image].istore,
                                        x,
                                        y,
                                        100,
                                        w,
                                        h);

      browser_redrawing = NULL;
      image_redrawing   = -1;

      #ifdef STRICT_PARSER

        if (e)
        {
          e->errnum = Utils_Error_Custom_Message;
          show_error_ret(e);

          return 0;
        }

      #else

        if (e) return 0;

      #endif
    }
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_tile_window: Successful\n");
  #endif

  return 1;
}

/*************************************************/
/* image_mark_as_redrawable()                    */
/*                                               */
/* Flags that an image may now be redrawn (this  */
/* is generally called because an unsized image  */
/* has found its size, asked for a reformat, and */
/* that reformat is about to take place).        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number.                 */
/*************************************************/

void image_mark_as_redrawable(browser_data * b, int image)
{
  /* Mark the image as redrawable */

  if (idata[image].owner == b) idata[image].canredraw = 1;

  return;
}

/*************************************************/
/* image_token_reformatted()                     */
/*                                               */
/* Called by a reformatter to signal an image is */
/* locked in a line array. Sets the image's      */
/* canredraw flag and locks the image's size.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the image.           */
/*************************************************/

void image_token_reformatted(browser_data * b, HStream * token)
{
  int  image;
  int  xref;

  /* Get the image number */

  image = image_get_token_image_actual(b, token);
  if (image < 0 || image > nimages) return;

  if (idata[image].xref >= 0) xref = idata[image].xref;
  else                        xref = image;

  /* Lock the image size */

  image_lock_image_size(b, image);

  /* Exit if the image has no known real size yet - even if its size */
  /* is fixed in the HTML, there's no point marking it as redrawable */
  /* if there is no image data to redraw...!                         */

  if (
       !idata[xref].istore                ||
       idata[xref].istore->width_os  <= 0 ||
       idata[xref].istore->height_os <= 0
     )
     return;

  /* We do have some data and the reformatter has fixed the image in */
  /* the line array, so mark it as redrawable now.                   */

  image_mark_as_redrawable(b, image);

  return;
}

/*************************************************/
/* image_mode_change()                           */
/*                                               */
/* Ensure images are up to date following a mode */
/* change.                                       */
/*************************************************/

_kernel_oserror * image_mode_change(void)
{
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_mode_change: Called\n");
  #endif

  if (nimages)
  {
    int i;

    /* For each image, call the image library's mode change handling function */

    for (i = 0; i < nimages; i++)
    {
      if (idata[i].istore && idata[i].istore->width > 0 && idata[i].istore -> ModeChange)
      {
        #ifdef STRICT_PARSER

          /* Report any errors as Continue-only in strict parser mode */

          _kernel_oserror * e;

          e = idata[i].istore -> ModeChange(idata[i].istore);

          #ifdef TRACE
            if (tl & (1u<<15)) Printf("image_mode_change: Exitting with error\n");
          #endif

          if (e) return e;

        #else

          /* If not in Strict mode, ignore any errors */

          idata[i].istore -> ModeChange(idata[i].istore);

        #endif
      }
    }
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_mode_change: Successful\n");
  #endif

  return NULL;
}

/*************************************************/
/* image_count_fetches()                         */
/*                                               */
/* Counts how many fetches are being performed   */
/* for a given web page.                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the page and images   */
/*             being fetched.                    */
/*                                               */
/* Returns:    The number of image fetches that  */
/*             are currently in progress (this   */
/*             may be zero, of course).          */
/*************************************************/

static int image_count_fetches(browser_data * b)
{
  int i, c = 0;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_fetches: Called\n");
  #endif

  /* there is a fetch handle in their image_info structs. */

  for (i = 0; i < nimages; i++) if (idata[i].handle && idata[i].owner == b) c++;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_fetches: Exitting with %d\n",c);
  #endif

  return c;
}

/*************************************************/
/* image_fetching()                              */
/*                                               */
/* Returns 1 if there are any image fetches      */
/* going on at all, else 0 (faster than using    */
/* image_count_fetches above if you don't care   */
/* how many fetches there are).                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the inquiry.          */
/*                                               */
/* Returns:    1 if there are image fetches in   */
/*             progress, else 0.                 */
/*************************************************/

int image_fetching(browser_data * b)
{
  int i;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fetching: Called\n");
  #endif

  for (i = 0; i < nimages; i++)
  {
    if (idata[i].handle && idata[i].owner == b)
    {
      #ifdef TRACE
        if (tl & (1u<<15)) Printf("image_fetching: Exitting, there is at least 1 fetch in progress\n");
      #endif

      return 1;
    }
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fetching: Exitting, no fetches in progress\n");
  #endif

  return 0;
}

/*************************************************/
/* image_fetched()                               */
/*                                               */
/* Determines if an image has been completely    */
/* fetched or not.                               */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1.                      */
/*                                               */
/* Returns:    1 if the image has been fetched   */
/*             completely, else 0.               */
/*************************************************/

int image_fetched(browser_data * b, int image)
{
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fetched: Called for image %d\n",image);
  #endif

  if (image >= 0) return (idata[image].fetched);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_fetched: Exitting with 0 (failed)\n");
  #endif

  return 0;
}

/*************************************************/
/* image_token_fetched()                         */
/*                                               */
/* Determines if an image has been completely    */
/* fetched or not, based on a token representing */
/* the image.                                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to a token representing   */
/*             the image.                        */
/*                                               */
/* Returns:    1 if the image has been fetched   */
/*             completely, else 0.               */
/*************************************************/

int image_token_fetched(browser_data * b, HStream * token)
{
  int image;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_token_fetched: Called for token %p\n",token);
  #endif

  image = image_get_token_image_xref(b, token);

  #ifdef TRACE
    if (tl & (1u<<15))
    {
      Printf("image_token_fetched: Represents image %d\n",image);
      Printf("image_token_fetched: Exitting through image_fetched\n");
    }
  #endif

  return image_fetched(b, image);
}

/*************************************************/
/* image_total_bytes_fetched()                   */
/*                                               */
/* Works out the total number of bytes fetched   */
/* in images so far.                             */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*                                               */
/* Returns:    The number of bytes fetched in    */
/*             image data at the moment of       */
/*             calling the function.             */
/*************************************************/

int image_total_bytes_fetched(browser_data * b)
{
  int count = 0;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_total_bytes_fetched: Called\n");
  #endif

  /* Sum the fetched size of all images currently present, */
  /* if there are any to count.                            */

  if (nimages)
  {
    int image;

    for (image = 0; image < nimages; image++)
    {
      if (idata[image].owner == b && idata[image].token) count += idata[image].bytesgot;
    }
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_total_bytes_fetched: Exitting with %d\n",count);
  #endif

  return count;
}

/*************************************************/
/* image_count_pending()                         */
/*                                               */
/* Counts how many images are waiting to be      */
/* fetched, but have been delayed for whatever   */
/* reason.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images. Any       */
/*             images in child windows are also  */
/*             included in the count.            */
/*                                               */
/* Returns:    The number of images waiting to   */
/*             be fetched, counting any images   */
/*             in any child windows (if present) */
/*************************************************/

int image_count_pending(browser_data * b)
{
  int i, c = 0;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_pending: Called for %p\n",b);
  #endif

  if (b->nchildren)
  {
    for (i = 0; i < b->nchildren; i++)
    {
      c += image_count_pending(b->children[i]);
    }
  }
  else
  {
    for (i = 0; i < nimages; i++)
    {
      if (
           idata[i].xref < 0   &&
           idata[i].owner == b &&
           !idata[i].fetched   &&
           !idata[i].delayed
         )
         c++;
    }
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_pending: Exitting with %d for %p\n",c,b);
  #endif

  return c;
}

/*************************************************/
/* image_count_specific_pending()                */
/*                                               */
/* Counts how many images are waiting to be      */
/* fetched, but have been delayed for whatever   */
/* reason, for just the specified browser (not   */
/* including any child windows).                 */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*                                               */
/* Returns:    The number of images waiting to   */
/*             be fetched in the given browser.  */
/*************************************************/

int image_count_specific_pending(browser_data * b)
{
  int i, c = 0;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_specific_pending: Called for %p\n",b);
  #endif

  for (i = 0; i < nimages; i++)
  {
    if (
         idata[i].xref < 0   &&
         idata[i].owner == b &&
         !idata[i].fetched   &&
         !idata[i].delayed
       )
       c++;
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_count_specific_pending: Exitting with %d for %p\n",c,b);
  #endif

  return c;
}

/*************************************************/
/* image_count_delayed()                         */
/*                                               */
/* Returns the number of images which have been  */
/* delayed (could be fetched, but have been set  */
/* up to not fetch yet).                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the images.           */
/*************************************************/

int image_count_delayed(browser_data * b)
{
  int count = 0;

  if (nimages)
  {
    int  i;

    for (i = 0; i < nimages; i++)
    {
      if (
           (
             !idata[i].fetched &&
             idata[i].delayed
           )
           ||
           (
             idata[i].fetched  &&
             !idata[i].success &&
             !idata[i].istore
           )
         )
         count++;
    }
  }

  return count;
}

/*************************************************/
/* image_plot_started()                          */
/*                                               */
/* Returns 1 if a given image in a given browser */
/* has had some plotting done for it (so the     */
/* placeholder box and possibly ALT text will no */
/* longer be visible for it).                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The number of the image.          */
/*                                               */
/* Returns:    1 if the image has been partially */
/*             or completely plotted, else 0.    */
/*************************************************/

int image_plot_started(browser_data * b, int image)
{
  if (image < 0) return 0;

  if (!idata[image].istore) return 0;

  if (!idata[image].canredraw) return 0;

  if (idata[image].istore->width > 0) return 1;
  else                                return 0;
}

/*************************************************/
/* image_token_plot_started()                    */
/*                                               */
/* Returns 1 if a given image in a given browser */
/* has had some plotting done for it (so the     */
/* placeholder box and possibly ALT text will no */
/* longer be visible for it).                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to a token representing   */
/*             the image.                        */
/*                                               */
/* Returns:    1 if the image has been partially */
/*             or completely plotted, else 0.    */
/*************************************************/

int image_token_plot_started(browser_data * b, HStream * token)
{
  int image;

  image = image_get_token_image_xref(b, token);

  return image_plot_started(b, image);
}

/*************************************************/
/* image_get_token_image_xref()                  */
/*                                               */
/* Finds the image number associated with a      */
/* given token. The number will be the image     */
/* that actually has the associated image data,  */
/* not just one that cross references this data. */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The token address.                */
/*                                               */
/* Returns:    The image number which references */
/*             that token, or -1 if none found.  */
/*************************************************/

static int image_get_token_image_xref(browser_data * b, HStream * token)
{
  int found = -1;

  #ifndef FAST_TOKEN_REFERENCE
    int i;
  #endif

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_xref: Called\n");
  #endif

  #ifdef FAST_TOKEN_REFERENCE

    found = (token->flags >> FAST_TOKEN_REFERENCE_SHIFT) - 1;

    /* If an appropriate image was found, ensure it */
    /* is the one with render data attached, not    */
    /* just a cross reference image.                */

    if (found >= 0 && found < nimages)
    {
      if (idata[found].xref >= 0) found = idata[found].xref;
    }

  #else

    /* If there are any images to deal with... */

    if (nimages)
    {
      /* ...then look through them all, seeing if the */
      /* image is referred to by the given token.     */

      for (i = 0; i < nimages; i++)
      {

        if (idata[i].token == token && idata[i].owner == b)
        {
          found = i;
          break;
        }
      }

      /* If an appropriate image was found, ensure it */
      /* is the one with render data attached, not    */
      /* just a cross reference image.                */

      if (found >= 0)
      {
        if (idata[found].xref >= 0) found = idata[found].xref;
      }
    }

  #endif

  /* Return the image number, or -1 for failure */

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_xref: Exitting with %d\n", found);
  #endif

  return found;
}

/*************************************************/
/* image_get_token_image_actual()                */
/*                                               */
/* As image_get_token_image, but returns the     */
/* exact image number represented by the given   */
/* token rather than the cross referenced one    */
/* with the pointers to the image data.          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The token address.                */
/*                                               */
/* Returns:    The image number which references */
/*             that token, or -1 if none found.  */
/*************************************************/

static int image_get_token_image_actual(browser_data * b, HStream * token)
{
  int found = -1;

  #ifndef FAST_TOKEN_REFERENCE
    int i;
  #endif

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_actual: Called\n");
  #endif

  #ifdef FAST_TOKEN_REFERENCE

    found = (token->flags >> FAST_TOKEN_REFERENCE_SHIFT) - 1;

  #else

    /* If there are any images to deal with... */

    if (nimages)
    {
      /* ...then look through them all, seeing if the */
      /* image is referred to by the given token.     */

      for (i = 0; i < nimages; i++)
      {

        if (idata[i].token == token && idata[i].owner == b)
        {
          found = i;
          break;
        }
      }
    }

  #endif

  /* Return the image number, or -1 for failure */

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_actual: Exitting with %d\n", found);
  #endif

  return found;
}

/*************************************************/
/* image_lock_image_size()                       */
/*                                               */
/* Ask image_get_image_size for the size of an   */
/* image, making sure currw and currh are -1 so  */
/* that it works the size out from first         */
/* principles, then set that size jn currw and   */
/* currh for future reference.                   */
/*                                               */
/* Designed to be called by the reformatter when */
/* it encounters an image and stores it in a     */
/* line array.                                   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Number of the image.              */
/*************************************************/

static void image_lock_image_size(browser_data * b, int image)
{
  BBox size;

  /* Rediscover the image size - so ignore any stored */
  /* values in currw and currh.                       */

  if (image_get_image_size(b, image, &size, 1)) return;

  /* Now lock the size by (re)storing it in currw and currh */

  idata[image].currw = size.xmax;
  idata[image].currh = size.ymax;

  return;
}

/*************************************************/
/* image_lock_token_image_size()                 */
/*                                               */
/* As image_lock_image_size, but takes a pointer */
/* to an HStream rather than an image number.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the image.           */
/*************************************************/

void image_lock_token_image_size(browser_data * b, HStream * token)
{
  int  image = image_get_token_image_actual(b, token);

  if (image < 0) return;

  image_lock_image_size(b, image);

  return;
}

/*************************************************/
/* image_unlock_image_size()                     */
/*                                               */
/* Set currw and currh for an image to -1, so    */
/* that image_get_image_size will start working  */
/* the size out from first principles rather     */
/* than using any prestored value.               */
/*                                               */
/* Designed to be called by the reformatter when */
/* it destroys a line array with images in it.   */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Number of the image.              */
/*************************************************/

static void image_unlock_image_size(browser_data * b, int image)
{
  idata[image].currw = -1;
  idata[image].currh = -1;

  return;
}

/*************************************************/
/* image_unlock_token_image_size()               */
/*                                               */
/* As image_unlock_image_size, but takes a       */
/* pointer to an HStream rather than an image    */
/* number.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to an HStream struct      */
/*             representing the image.           */
/*************************************************/

void image_unlock_token_image_size(browser_data * b, HStream * token)
{
  int image = image_get_token_image_actual(b, token);

  if (image < 0) return;

  image_unlock_image_size(b, image);

  return;
}

/*************************************************/
/* image_get_image_size()                        */
/*                                               */
/* Returns the size of an image in OS units.     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1, which may just be a  */
/*             cross referencing image (i.e. has */
/*             no directly associated data);     */
/*                                               */
/*             Pointer to a BBox into which the  */
/*             size information is placed (xmax  */
/*             and ymax fields filled with       */
/*             width and height currently - xmin */
/*             and ymin always zero);            */
/*                                               */
/*             1 to ignore the image's currw and */
/*             currh fields, else use those if   */
/*             they are present.                 */
/*                                               */
/* Assumes:    The BBox pointer is not NULL.     */
/*************************************************/

static _kernel_oserror * image_get_image_size(browser_data * b, int image, BBox * box, int ignore_stored)
{
  int       awidth      = 0; /* Available page / cell width */
  int       aheight     = 0; /* Same, but height            */

  int       real_width  = 0; /* The actual image dimensions (OS units) */
  int       real_height = 0; /* from ImageLib                          */

  int       width_os    = -1; /* The image size as it will appear on the page, taking  */
  int       height_os   = -1; /* account of any WIDTH or HEIGHT attributes in the HTML */

  int       actual;
  int       subtract;
  HStream * tp          = idata[image].token;

  #ifdef TRACE

    if (tl & (1u<<15)) Printf("image_get_image_size: Called for image %d\n",image);

    if (!box)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      strcpy(erb.errmess,"Null pointer to BBox given to image_get_image_size");
      return &erb;
    }

    if (image < 0)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,"Invalid image number %d passed to image_get_image_size (nimages = %d)", image, nimages);
      return &erb;
    }
    if (image > nimages)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,"Out of range image number %d passed to image_get_image_size (nimages = %d)", image, nimages);
      return &erb;
    }

  #else

    if (!box || image < 0 || image >= nimages) return NULL;

  #endif

  /* Zero contents of the BBox */

  memset(box, 0, sizeof(BBox));

  /* Can we return a prestored size? */

  if (!ignore_stored && idata[image].currw >= 0 && idata[image].currh >= 0)
  {
    box->xmax = idata[image].currw;
    box->ymax = idata[image].currh;

    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_get_image_size: Successful\n");
    #endif

    return NULL;
  }

  /* If this cross references another image, get its number */

  if (idata[image].xref >= 0) actual = idata[image].xref;
  else                        actual = image;

  /* Work out the available width / height */

  if (!tp || !tp->parent)
  {
    awidth  = redraw_display_width (b, NULL);
    aheight = redraw_display_height(b, NULL);

    if (tp)
    {
      subtract = redraw_left_gap (b, b->cell, tp) +
                 redraw_right_gap(b, b->cell, tp);
    }
    else
    {
      subtract = redraw_left_margin (b, b->cell) +
                 redraw_right_margin(b, b->cell);
    }
  }
  else
  {
    reformat_cell * cell = tokenutils_token_cell(b, tp);

    if (!cell) cell = b->cell;

    if (
         TD_HAS_WIDTH  (tp->parent) &&
         TD_WIDTH_UNITS(tp->parent) == UNITS_PIXELS
       )
       awidth = TD_WIDTH(tp->parent) * 2; /* 1 'web pixel' = 2 OS units */

    if (
         TD_HAS_HEIGHT  (tp->parent) &&
         TD_HEIGHT_UNITS(tp->parent) == UNITS_PIXELS
       )
       aheight = TD_HEIGHT(tp->parent) * 2; /* 1 'web pixel' = 2 OS units */

    subtract = redraw_left_gap (b, cell, tp) +
               redraw_right_gap(b, cell, tp);
  }

  convert_to_os(subtract, &subtract);
  awidth -= subtract;
  if (awidth < 0) awidth = 0;

  /* Try to get the image size from the actual image data (i.e. ImageLib) */

  if (idata[actual].istore)
  {
    real_width  = idata[actual].istore->width_os;
    real_height = idata[actual].istore->height_os;
  }

  /* If we don't seem to have anything, try the image history */

  if (real_width <= 0 && real_height <= 0)
  {
    imghistory_return_size((const char **) &idata[actual].flex->urldata,
                           0,
                           &real_width,
                           &real_height);
  }

  /* The image may have a specific width and height given in */
  /* the HTML.                                               */

  if (tp && tp->tagno != TAG_INPUT)
  {
    /* The OBJECT macros work for IMGs as well as OBJECTs */

    if (OBJECT_HAS_WIDTH(tp))
    {
      switch (OBJECT_WIDTH_UNITS(tp))
      {
        default:
        case UNITS_PIXELS:  width_os = OBJECT_WIDTH(tp) * 2; break;
        case UNITS_PERCENT: width_os = awidth * OBJECT_WIDTH(tp) / 100; break;
      }
    }

    if (OBJECT_HAS_HEIGHT(tp))
    {
      switch (OBJECT_HEIGHT_UNITS(tp))
      {
        default:
        case UNITS_PIXELS:  height_os = OBJECT_HEIGHT(tp) * 2; break;
        case UNITS_PERCENT: height_os = aheight * OBJECT_HEIGHT(tp) / 100; break;
      }
    }
  }

  /* If width and height are both < zero, i.e. as yet unset, */
  /* try to find them out from the image data itself         */

  if (width_os < 0 && height_os < 0)
  {
    if (real_width > 0 && real_height > 0)
    {
      width_os  = real_width;
      height_os = real_height;
    }
  }

  /* If width and height are still both < zero, must go for a */
  /* default placeholder size instead.                        */

  if (width_os < 0 && height_os < 0) goto image_get_image_size_placeholder;

  /* We may have final values... */

  if (width_os >= 0 && height_os >= 0)
  {
    box->xmax = width_os;
    box->ymax = height_os;

    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_get_image_size: Successful\n");
    #endif

    return NULL;
  }

  /* Otherwise, scale one from the other if possible - for this we must */
  /* have a real image size to get the proportions from                 */

  if (real_width <= 0 || real_height <= 0) goto image_get_image_size_placeholder;

  /* We know the true image size and can thus scale whichever dimension is */
  /* missing for the on-page size from the proportions of the real image.  */

  if (width_os < 0)
  {
    /* Work out width based on the height */

    width_os = (height_os * real_width) / real_height;
  }
  else
  {
    /* Work out height based on the width */

    height_os = (width_os * real_height) / real_width;
  }

  /* We should now have both values, but if not, drop through to the */
  /* placeholder size routine.                                       */

  if (width_os >= 0 && height_os >= 0)
  {
    box->xmax = width_os;
    box->ymax = height_os;

    #ifdef TRACE
      if (tl & (1u<<15)) Printf("image_get_image_size: Successful\n");
    #endif

    return NULL;
  }

image_get_image_size_placeholder:

  {
    /* Don't have precise image dimensions, so work it out from */
    /* any ALT text present or go for a default value.          */

    HStream    * tp = NULL;
    const char * text;

    if (image >= 0) tp = idata[image].token;

    if (tp)
    {
      text = (ISOBJECT(tp)) ? HtmlOBJECTstandby(tp) : tp->text;
    }
    else
    {
      text = NULL;
    }

    reformat_get_placeholder_size(b, tp, text, box);
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_image_size: Successful\n");
  #endif

  return NULL;
}

/*************************************************/
/* image_get_token_image_size()                  */
/*                                               */
/* As image_get_image_size above, but takes a    */
/* token address rather than an image number.    */
/* The default 'unknown' image size will be      */
/* returned if no image could be associated with */
/* the token (no error will be raised).          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             A token address;                  */
/*                                               */
/*             Pointer to a BBox into which the  */
/*             size information is placed.       */
/*                                               */
/* Assumes:    The BBox pointer is not NULL.     */
/*************************************************/

_kernel_oserror * image_get_token_image_size(browser_data * b, HStream * token, BBox * box)
{
  int image;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_size: Called\n");
  #endif

  image = image_get_token_image_actual(b, token);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_image_size: Exitting through image_get_image_size\n");
  #endif

  return image_get_image_size(b, image, box, 0);
}

/*************************************************/
/* image_set_image_size()                        */
/*                                               */
/* Sets the size of an image (currw, currh       */
/* fields) in OS units.                          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             The image number, from 0 to       */
/*             nimages - 1, which may just be a  */
/*             cross referencing image (i.e. has */
/*             no directly associated data);     */
/*                                               */
/*             Pointer to a BBox from which the  */
/*             size information is read (xmax -  */
/*             xmin, ymax - ymin).               */
/*                                               */
/* Assumes:    The BBox pointer is not NULL.     */
/*************************************************/

static _kernel_oserror * image_set_image_size(browser_data * b, int image, BBox * box)
{
  #ifdef TRACE

    if (tl & (1u<<15)) Printf("image_set_image_size: Called for image %d\n",image);

    if (!box)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      strcpy(erb.errmess,"Null pointer to BBox given to image_set_image_size");
      return &erb;
    }

    if (image < 0)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,"Invalid image number %d passed to image_set_image_size (nimages = %d)", image, nimages);
      return &erb;
    }
    if (image > nimages)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess,"Out of range image number %d passed to image_set_image_size (nimages = %d)", image, nimages);
      return &erb;
    }

  #else

    if (image < 0 || image >= nimages) return NULL;

  #endif

  idata[image].currw = box->xmax - box->xmin;
  idata[image].currh = box->ymax - box->ymin;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_set_image_size: Successful\n");
  #endif

  return NULL;
}

/*************************************************/
/* image_set_token_image_size()                  */
/*                                               */
/* As image_set_image_size above, but takes a    */
/* token address rather than an image number.    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             A token address;                  */
/*                                               */
/*             Pointer to a BBox from which the  */
/*             size information is read (xmax -  */
/*             xmin, ymax - ymin).               */
/*                                               */
/* Assumes:    The BBox pointer is not NULL.     */
/*************************************************/

_kernel_oserror * image_set_token_image_size(browser_data * b, HStream * token, BBox * box)
{
  int image;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_set_token_image_size: Called\n");
  #endif

  image = image_get_token_image_actual(b, token);

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_set_token_image_size: Exitting through image_set_image_size\n");
  #endif

  return image_set_image_size(b, image, box);
}

/*************************************************/
/* image_get_token_actual_size()                 */
/*                                               */
/* Returns the width and height of an image, in  */
/* pixels, or 0 and 0 if it the size isn't known */
/* yet.                                          */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             A token address;                  */
/*                                               */
/*             Pointer to an int, in which the   */
/*             width is written;                 */
/*                                               */
/*             Pointer to an int, in which the   */
/*             height is written.                */
/*                                               */
/* Assumes:    All pointers are non-NULL and     */
/*             valid.                            */
/*************************************************/

void image_get_token_actual_size(browser_data * b, HStream * token, int * w, int * h)
{
  int image;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_actual_size: Called\n");
  #endif

  image = image_get_token_image_xref(b, token);

  if (idata[image].istore)
  {
    *w = idata[image].istore -> width_os  / 2;
    *h = idata[image].istore -> height_os / 2;
  }
  else
  {
    *w = 0;
    *h = 0;
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_token_actual_size: Exitting with width %d, height %d\n", *w, *h);
  #endif

  return;
}

/*************************************************/
/* image_get_back_image_size()                   */
/*                                               */
/* Finds out the size of the background image in */
/* OS units.                                     */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the background image; */
/*             Pointer to a BBox into which the  */
/*             size information is placed.       */
/*                                               */
/* Assumes:    That neither pointer is NULL.     */
/*************************************************/

_kernel_oserror * image_get_back_image_size(browser_data * b, BBox * box)
{
  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_get_back_image_size: Called, exitting through image_get_image_size\n");
  #endif

  return (image_get_image_size(b, b->background_image, box, 1));
}

/*************************************************/
/* image_get_token_image_position()              */
/*                                               */
/* Returns the x and y fields of the image_info  */
/* structure for a given image.                  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to the token representing */
/*             the image;                        */
/*                                               */
/*             Pointer to an int, in which the   */
/*             X coordinate is returned;         */
/*                                               */
/*             Pointer to an int, in which the   */
/*             Y coordinate is returned.         */
/*                                               */
/* Returns:    1 if the image could not be found */
/*             from the given token, or 0 for    */
/*             success.                          */
/*                                               */
/* Assumes:    Neither pointer is NULL.          */
/*************************************************/

int image_get_token_image_position(browser_data * b, HStream * t, int * x, int * y)
{
  int image = image_get_token_image_actual(b, t);

  if (image < 0) return 1;

  *x = idata[image].x;
  *y = idata[image].y;

  return 0;
}

/*************************************************/
/* image_set_token_image_position()              */
/*                                               */
/* Sets the x and y fields of the image_info     */
/* structure for a given image, so that it may   */
/* be [partially] plotted during a fetch.        */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to the token representing */
/*             the image;                        */
/*                                               */
/*             X coordinate (window coords);     */
/*                                               */
/*             Y coordinate (window coords).     */
/*                                               */
/* Returns:    Number of the image that was      */
/*             changed, or -1 if none could be   */
/*             found for the given token.        */
/*************************************************/

int image_set_token_image_position(browser_data * b, HStream * t, int x, int y)
{
  int image = image_get_token_image_actual(b, t);

  /* If an image was found, set the x and y coordinates */

  if (image >= 0)
  {
    idata[image].x = x;
    idata[image].y = y;
  }

  return image;
}

/*************************************************/
/* image_get_background_image_url()              */
/*                                               */
/* Returns the URL of a browser's current        */
/* background image.                             */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the background;       */
/*                                               */
/*             Pointer to a buffer to take the   */
/*             URL;                              */
/*                                               */
/*             Size of the buffer.               */
/*************************************************/

void image_get_background_image_url(browser_data * b, char * buffer, int size)
{
  int old_budge;
  int image = b ? b->background_image : -1;

  if (!buffer || size < 1) return;

  *buffer = 0;

  if (size < 2 || image < 0 || image >= nimages) return;

  /* Lock flex */

  old_budge = flex_set_budge(0);

  /* Copy the URL in, ensuring termination */

  strncpy(buffer, idata[image].flex->urldata, size);
  buffer[size - 1] = 0;

  /* Restore flex's previous budge state */

  flex_set_budge(old_budge);

  /* Finished */

  return;
}

/*************************************************/
/* image_convert_to_pixels()                     */
/*                                               */
/* Converts a given OS unit X and Y size to      */
/* pixel size, for a given image.                */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to the token representing */
/*             the image;                        */
/*                                               */
/*             Pointer to an int which already   */
/*             contains the X size in OS units,  */
/*             which will have the pixel size    */
/*             returned into it;                 */
/*                                               */
/*             A similar pointer for the Y size. */
/*                                               */
/* Assumes:    That no pointer is NULL.          */
/*************************************************/

void image_convert_to_pixels(browser_data * b, HStream * token, int * x, int * y)
{
  int image;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_convert_to_pixels: Called\n");
  #endif

  image = image_get_token_image_xref(b, token);

  /* If the library has got enough information to fill in the */
  /* width of the image, proceed with the conversion          */

  if (image >= 0 && idata[image].istore && idata[image].istore->width > 0)
  {
    *x = *x * idata[image].istore->width  / idata[image].istore->width_os;
    *y = *y * idata[image].istore->height / idata[image].istore->height_os;
  }
  else
  {
    /* Can't find image - maybe it's not loaded... Assume 2 OS units per pixel. */

    *x = *x / 2;
    *y = *y / 2;
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_convert_to_pixels: Successful\n");
  #endif
}

/*************************************************/
/* image_return_click_offset()                   */
/*                                               */
/* Calculate the coordinates of a click on an    */
/* image in pixels from the top left corner, as  */
/* required by image maps and image input        */
/* fields.                                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to a token representing   */
/*             the image;                        */
/*                                               */
/*             A WimpGetPointerInfo block        */
/*             pointer describing the mouse      */
/*             pointer's position;               */
/*                                               */
/*             Pointer to an int, in which the   */
/*             x offset is returned;             */
/*                                               */
/*             Pointer to an int, in which the   */
/*             y offset is returned.             */
/*                                               */
/* Assumes:    That the int pointers are not     */
/*             NULL.                             */
/*************************************************/

_kernel_oserror * image_return_click_offset(browser_data * b, HStream * t, WimpGetPointerInfoBlock * i, int * x, int * y)
{
  _kernel_oserror         * e;
  WimpGetWindowStateBlock   s;
  BBox                      box;

  /* Get the image's size and position on screen */

  s.window_handle = b->window_handle;

  e = wimp_get_window_state(&s);
  if (e) return e;

  e = image_get_token_image_size(b, t, &box);
  if (e) return e;

  if (image_get_token_image_position(b, t, x, y)) return NULL;

  *x = coords_x_toscreen(*x, (WimpRedrawWindowBlock *) &s);
  *y = coords_y_toscreen(*y, (WimpRedrawWindowBlock *) &s);

  /* Get the offset of the pointer position from the top left */
  /* of the image in ox and oy                                */

  *x = i->x - *x;
  *y = *y + (box.ymax - box.ymin) - i->y;

  image_convert_to_pixels(b, t, x, y);

  /* Check for daft values due to rounding etc. */

  if (*x < 0) *x = 0;
  if (*y < 0) *y = 0;

  return NULL;
}

/*************************************************/
/* image_can_be_saved_as_sprite                  */
/*                                               */
/* Returns 1 if a given image has data and can   */
/* be saved (the DumpSprite function is          */
/* present), else 0.                             */
/*                                               */
/* The image may cross reference another with    */
/* the actual data. If so, the return value will */
/* be referring to that cross referenced image.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             owning the image;                 */
/*                                               */
/*             Number of the image.              */
/*                                               */
/* Returns:    1 if the image can be saved as a  */
/*             sprite, else 0.                   */
/*************************************************/

static int image_can_be_saved_as_sprite(browser_data * b, int i)
{
  if (
       idata[i].istore                &&
       idata[i].istore->DumpSprite    &&
       idata[i].istore->width_os > 0  &&
       idata[i].istore->height_os > 0
     )
     return 1;

  return 0;
}

/*************************************************/
/* image_token_can_be_saved_as_sprite            */
/*                                               */
/* Returns 1 if a given image has data and can   */
/* be saved (the DumpSprite function is          */
/* present), else 0.                             */
/*                                               */
/* The image may cross reference another with    */
/* the actual data. If so, the return value will */
/* be referring to that cross referenced image.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             owning the image;                 */
/*                                               */
/*             Pointer to the token representing */
/*             the image, or NULL for the page's */
/*             background image.                 */
/*                                               */
/* Returns:    1 if the image can be saved as a  */
/*             sprite, else 0.                   */
/*************************************************/

int image_token_can_be_saved_as_sprite(browser_data * b, HStream * image)
{
  int i;

  /* Find the image number */

  if (!image) i = b->background_image;
  else        i = image_get_token_image_xref(b, image);

  /* Complain if we can't in TRACE builds */

  if (i < 0)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "In image_token_can_be_saved_as_sprite, can't find an image that is represented by the token %p for the browser %p.",
              image,
              b);

      show_error_ret(&erb);

    #endif

    return 0;
  }

  /* Can it be saved? */

  return image_can_be_saved_as_sprite(b, i);
}

/*************************************************/
/* image_export_sprite()                         */
/*                                               */
/* Saves an image represented by the given token */
/* as a sprite at the given path.                */
/*                                               */
/* Parameters: Pointer to the path to save to;   */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             that owns the image;              */
/*                                               */
/*             Pointer to the token representing */
/*             the image, or NULL for the page's */
/*             background image.                 */
/*************************************************/

_kernel_oserror * image_export_sprite(char * path, browser_data * b, HStream * image)
{
  int               im, i;
  _kernel_oserror * e;

  if (!path || !*path) return NULL;

  save_record_path(path);

  /* Find the image number */

  if (!image) im = b->background_image;
  else        im = image_get_token_image_actual(b, image);

  if (idata[im].xref >= 0) i = idata[im].xref;
  else                     i = im;

  /* Must have image data... */

  if (!image_can_be_saved_as_sprite(b, i))
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "There is no data for this image in image_export_sprite.");

      return &erb;

    #endif

    return NULL;
  }

  /* Export the image */

  browser_redrawing = b;
  image_redrawing   = im;

  e = idata[i].istore -> DumpSprite(idata[i].istore,
                                    path,
                                    -1);

  browser_redrawing = NULL;
  image_redrawing   = -1;

  return e;
}

/*************************************************/
/* image_sprite_size()                           */
/*                                               */
/* Returns the size that the given image would   */
/* be as a sprite on disc.                       */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             that owns the image;              */
/*                                               */
/*             Pointer to the token representing */
/*             the image, or NULL for the page's */
/*             background image.                 */
/*                                               */
/* Returns:    The size the image would be as a  */
/*             sprite file saved to disc, in     */
/*             bytes (a guess only).             */
/*************************************************/

int image_sprite_size(browser_data * b, HStream * image)
{
  /* ...And for now, we don't know. */

  return 4096;
}

/*************************************************/
/* image_export_original()                       */
/*                                               */
/* Saves an image represented by the given token */
/* in its original format to the given path.     */
/*                                               */
/* Parameters: Pointer to the path to save to;   */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             that owns the image;              */
/*                                               */
/*             Pointer to the token representing */
/*             the image, or NULL for the page's */
/*             background image.                 */
/*************************************************/

_kernel_oserror * image_export_original(char * path, browser_data * b, HStream * image)
{
  char url[Limits_URL];
  int  i;

  if (!path || !*path) return NULL;

  save_record_path(path);

  /* Find the image number */

  if (!image) i = b->background_image;
  else        i = image_get_token_image_xref(b, image);

  /* Must have image data... */

  if (!idata[i].flex->urldata)
  {
    #ifdef TRACE

      erb.errnum = Utils_Error_Custom_Normal;

      sprintf(erb.errmess,
              "There is no URL for this image in image_export_original.");

      return &erb;

    #endif

    return NULL;
  }

  /* Start a fetch for this URL */

  strncpy(url, idata[i].flex->urldata, sizeof(url));
  url[sizeof(url) - 1] = 0;

  RetError(windows_create_browser(url,
                                  NULL,
                                  NULL,
                                  NULL,
                                  Windows_CreateBrowser_SaveToFile));

  /* Set the title to the save pathname */

  {
    char title[Limits_Title];

    StrNCpy0(title, path);

    /* Don't treat any errors here as fatal */

    show_error_ret(window_set_title(0, last_browser->self_id, title));
  }

  /* Open the file */

  last_browser->save_file = fopen(path, "wb");

  if (!last_browser->save_file)
  {
    StrLastE;

    fetch_stop(last_browser, 0);

    return &erb;
  }
  else
  {
    int bytes;

    /* Set the filetype to DEADDEAD, to represent an incomplete */
    /* file (particularly good on later Filers, which display   */
    /* a special sprite for this).                              */

    _swix(OS_File,
          _INR(0,2),

          2, /* Set load address */
          path,
          0xdeaddead);

    _swix(OS_File,
          _INR(0,1) | _IN(3),

          3, /* Set exec address */
          path,
          0xdeaddead);

    if (last_browser->source)
    {
      int old_budge;

      /* Any data in the source store represents already */
      /* fetched bits of the file. Must lock flex down   */
      /* over the save to make sure the heap doesn't     */
      /* shift over the call to fwrite.                  */

      old_budge = flex_set_budge(0);

      bytes = fwrite(last_browser->source,
                     1,
                     flex_size((flex_ptr) &last_browser->source),
                     last_browser->save_file);

      flex_set_budge(old_budge);

      /* If we didn't transfer as much as we expected, complain */

      if (bytes != flex_size((flex_ptr) &last_browser->source))
      {
        /* Report any errors */

        StrLastE;

        fetch_stop(last_browser, 0);

        return &erb;
      }
      else
      {
        /* Otherwise, get rid of the data in the source store */
        /* as it's been written to the file.                  */

        flex_free((flex_ptr) &last_browser->source);
        last_browser->source = NULL;
      }
    }
  }

  return NULL;
}

/*************************************************/
/* image_original_size()                         */
/*                                               */
/* Returns the size of a given image in its      */
/* original format.                              */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             that owns the image;              */
/*                                               */
/*             Pointer to the token representing */
/*             the image, or NULL for the page's */
/*             background image.                 */
/*                                               */
/* Returns:    The size of the original image,   */
/*             in bytes (a guess only).          */
/*************************************************/

int image_original_size(browser_data * b, HStream * image)
{
  int size = image_draw_file_size(b, image, 0);

  if (size <= 0) return 0;
  else           return size + 12;
}

/*************************************************/
/* image_to_draw_file()                          */
/*                                               */
/* As image_redraw, but will output a sprite     */
/* to the Draw file being output by SaveDraw.c   */
/* (which must be active at the time this is     */
/* called). Assumes that the appropriate Draw    */
/* file object header has already been written.  */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Pointer to a RedrawWindowBlock    */
/*             struct which holds information    */
/*             about the current redraw session; */
/*                                               */
/*             Address of the token representing */
/*             the image;                        */
/*                                               */
/*             The X offset in window coords (so */
/*             OS units) of the left hand edge   */
/*             of the image;                     */
/*                                               */
/*             The Y offset in window coords (so */
/*             OS units) of the bottom edge of   */
/*             the image;                        */
/*                                               */
/*             1 to assume the image is already  */
/*             present as a sprite in            */
/*             'unique_name' else create the     */
/*             image first.                      */
/*                                               */
/* Returns:    0 if failed, 1 if successful; if  */
/*             failed, caller should try some    */
/*             alternative representation (e.g.  */
/*             write out a placeholder).         */
/*************************************************/

int image_to_draw_file(browser_data * b, WimpRedrawWindowBlock * r, HStream * token, int x, int y, int dont_create)
{
  int image, actual;
  int plotted = 0;

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_to_draw_file: Called with token %d\n", token);
  #endif

  /* Get the image number for the given token; 'actual' holds the actual */
  /* image for the given token, which may cross reference 'image', which */
  /* holds the actual render data.                                       */

  image = image_get_token_image_actual(b, token);

  if (image < 0) return NULL;

  actual = image;
  if (idata[actual].xref >= 0) image = idata[actual].xref;

  /* If the image has a fetched width and height, */
  /* and the browser choices specify that images  */
  /* should be shown (or the image itself has a   */
  /* high priority show bit set), display part or */
  /* all of the image.                            */

  if (
       image  >= 0 &&
       actual >= 0 &&
       (
         b->show_foreground                     ||
         b->displayed == Display_External_Image ||
         idata[actual].priority
       )
       && idata[actual].canredraw
       && idata[image].istore             /* Must check istore here, as if width / height are <= 0, */
       && idata[image].istore->width  > 0 /* the image library has no data for the image and will   */
       && idata[image].istore->height > 0 /* not have filled in (e.g.) the Render field. So you'd   */
       && idata[image].istore->DumpSprite /* get a rather nasty abort trying to call it!            */
       && image_can_be_saved_as_sprite(b, image)

//       && idata[image].istore->StartExport
//       && idata[image].istore->Export
//       && idata[image].istore->EndExport
     )
  {
    FILE            * input = NULL;
    _kernel_oserror * e     = NULL;

    int               written, ok;
    char              buffer[10240];

//    int               image_size = 0;

    if (!dont_create || !unique_name)
    {
      unique_name = malloc(Limits_OS_Pathname);

      if (unique_name)
      {
        protocols_util_make_unique_name(unique_name, Limits_OS_Pathname);

        /* Output the sprite, skipping the first 12 bytes of sprite area header */

        browser_redrawing = b;
        image_redrawing   = actual;

        e = idata[image].istore -> DumpSprite(idata[image].istore,
                                              unique_name,
                                              -1);

        browser_redrawing = NULL;
        image_redrawing   = -1;
      }
    }

    if (e || !unique_name) ok = 0;
    else
    {
      ok = 1;

      input = fopen(unique_name, "rb");

      if (!input || !input->__file) ok = 0;
    }

    if (ok)
    {
      e = _swix(OS_Args,
                _INR(0,2),

                1,
                input->__file,
                12);

      if (e) ok = 0;
    }

    if (ok)
    {
      do
      {
        e = _swix(OS_GBPB,
                  _INR(0,3) | _OUT(3),

                  4,
                  input->__file,
                  buffer,
                  sizeof(buffer),

                  &written);

        if (!e && written < sizeof(buffer)) ok = savedraw_write_bytes(buffer, sizeof(buffer) - written);
        else                                ok = e ? 0 : 1;
      }
      while (!e && written < sizeof(buffer));
    }

    if (input)
    {
      fclose(input);

      if (unique_name) remove(unique_name);

      free(unique_name);
      unique_name = NULL;
    }

//    browser_redrawing = b;
//    image_redrawing   = actual;
//
//    e       = idata[image].istore -> StartExport(idata[image].istore, &image_size);
//    ok      = 1;
//
//    written = 12;
//    e       = idata[image].istore -> Export(idata[image].istore, buffer, &written);
//
//    while (!e && ok && written)
//    {
//      written = sizeof(buffer);
//
//      e = idata[image].istore -> Export(idata[image].istore, buffer, &written);
//
//      if (!e) ok = savedraw_write_bytes(buffer, written);
//      else    ok = 0;
//    }
//
//    e = idata[image].istore -> EndExport(idata[image].istore);
//
//    browser_redrawing = NULL;
//    image_redrawing   = -1;

    /* Flag if we succeeded */

    if (!e && ok) plotted = 1;
  }

  #ifdef TRACE
    if (tl & (1u<<15)) Printf("image_to_draw_file: Exitting with %d\n", plotted);
  #endif

  return plotted;
}

/*************************************************/
/* image_draw_file_size()                        */
/*                                               */
/* Returns the amount of data that               */
/* image_to_draw_file would write to the output  */
/* file.                                         */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the image;            */
/*                                               */
/*             Address of the token representing */
/*             the image;                        */
/*                                               */
/*             1 to not delete the scrap file    */
/*             in 'unique_name' that this        */
/*             writes, else 0.                   */
/*                                               */
/* Returns:    0 if failed, else the amount of   */
/*             data that image_to-draw_file      */
/*             would write to the output file.   */
/*************************************************/

int image_draw_file_size(browser_data * b, HStream * token, int dont_delete)
{
  int image, actual;

  /* Get the image number for the given token; 'actual' holds the actual */
  /* image for the given token, which may cross reference 'image', which */
  /* holds the actual render data.                                       */

  image = image_get_token_image_actual(b, token);

  if (image < 0) return NULL;

  actual = image;
  if (idata[actual].xref >= 0) image = idata[actual].xref;

  /* If the image has a fetched width and height, */
  /* and the browser choices specify that images  */
  /* should be shown (or the image itself has a   */
  /* high priority show bit set), display part or */
  /* all of the image.                            */

  if (
       image  >= 0 &&
       actual >= 0 &&
       (
         b->show_foreground                     ||
         b->displayed == Display_External_Image ||
         idata[actual].priority
       )
       && idata[actual].canredraw
       && idata[image].istore             /* Must check istore here, as if width / height are <= 0, */
       && idata[image].istore->width  > 0 /* the image library has no data for the image and will   */
       && idata[image].istore->height > 0 /* not have filled in (e.g.) the Render field. So you'd   */
       && idata[image].istore->DumpSprite /* get a rather nasty abort trying to call it!            */
       && image_can_be_saved_as_sprite(b, image)

//       && idata[image].istore->StartExport
//       && idata[image].istore->Export
//       && idata[image].istore->EndExport
     )
  {
    _kernel_oserror * e          = NULL;
    int               image_size = 0;

    if (unique_name)
    {
      remove(unique_name);

      free(unique_name);
      unique_name = NULL;
    }

    unique_name = malloc(Limits_OS_Pathname);

    if (unique_name)
    {
      protocols_util_make_unique_name(unique_name, Limits_OS_Pathname);

      browser_redrawing = b;
      image_redrawing   = actual;

      e = idata[image].istore -> DumpSprite(idata[image].istore,
                                            unique_name,
                                            -1);

      browser_redrawing = NULL;
      image_redrawing   = -1;
    }

    if (!e && unique_name)
    {
      e = _swix(OS_File,
                _INR(0,1) | _OUT(4),

                17,
                unique_name,

                &image_size);

      if (!dont_delete)
      {
        remove(unique_name);

        free(unique_name);
        unique_name = NULL;
      }
    }

//    e = idata[image].istore -> StartExport(idata[image].istore, &image_size);
//
//    if (!e) idata[image].istore -> EndExport(idata[image].istore);

    /* Remember, we'd skip the first 12 bytes of sprite area header */
    /* in the output Draw file.                                     */

    if (!e && image_size > 12) return image_size - 12;
  }

  return 0;
}

/*************************************************/
/* image_tile_to_draw()                          */
/*                                               */
/* For a given redraw rectangle, tiles the       */
/* background image within that rectangle to a   */
/* Draw file.                                    */
/*                                               */
/* Parameters: Pointer to a browser_data struct  */
/*             relevant to the window and image; */
/*                                               */
/*             Pointer to a WimpRedrawWindow-    */
/*             Block structure defining the area */
/*             over which to tile the image;     */
/*                                               */
/*             The X and Y coordinates to take   */
/*             as the tile origin, in OS units;  */
/*                                               */
/*             Pointer to an int if wanting to   */
/*             know the size of the item only,   */
/*             else NULL (NB the int contents    */
/*             are not updated - the pointer is  */
/*             acting like a flag, basically).   */
/*                                               */
/* Returns:    0 if failed, else the amount of   */
/*             data that was output.             */
/*************************************************/

int image_tile_to_draw(browser_data * b, WimpRedrawWindowBlock * r, int xorigin, int yorigin, int * size)
{
  char              name[Limits_OS_Pathname];
  _kernel_oserror * e;
  FILE            * input = NULL;
  void            * block = NULL;
  int               image;
  int               tsize = 0;
  int               x, y, w, h;
  int               xmin, ymax;
  int               image_size;

  /* Can only tile if there's a background image defined and fully fetched */

  if (b->background_image < 0) return 0;

  image = b->background_image;
  if (idata[image].xref >= 0) image = idata[image].xref;

  if (!idata[image].fetched || !idata[image].istore) return 0;

  /* Round the width and height to pixel boundaries */

  w = idata[image].istore->width_os  & ~1;
  h = idata[image].istore->height_os & ~1;

  if (w < 1 || h < 1) return 0;

  /* Work out the coordinates over which to tile the image */

  xmin = coords_x_toworkarea(r->redraw_area.xmin, r);
  ymax = coords_y_toworkarea(r->redraw_area.ymax, r);

  xmin -= ((xmin - xorigin) % w);
  ymax -= ((ymax - yorigin) % h) + 1;

  xmin = coords_x_toscreen(xmin, r);
  ymax = coords_y_toscreen(ymax, r);

  /* Do a blank rectangle if the image is transparent (has a mask) */

  if (idata[image].istore->transparent)
  {
    redraw_set_colour(redraw_backcol(b));

    tsize += DSIZE_FRECT;

    if (!size)
    {
      if (!savedraw_rectangle_fill(OTD(r->redraw_area.xmin),
                                   OTD(r->redraw_area.ymin),
                                   OTD(r->redraw_area.xmax - r->redraw_area.xmin),
                                   OTD(r->redraw_area.ymax - r->redraw_area.ymin),
                                   redraw_backcol(b))) return 0;
    }
  }

  /* How big is each image going to be? */

  protocols_util_make_unique_name(name, sizeof(name));

  browser_redrawing = b;
  image_redrawing   = b->background_image;

  e = idata[image].istore -> DumpSprite(idata[image].istore,
                                        name,
                                        -1);

  browser_redrawing = NULL;
  image_redrawing   = -1;

  if (!e)
  {
    e = _swix(OS_File,
              _INR(0,1) | _OUT(4),

              17,
              name,

              &image_size);
  }

  if (e || image_size <= 12) return 0;

  /* Subtract the sprite file header size */

  image_size -= 12;

  input = fopen(name, "rb");
  block = malloc(image_size);

  if (block && input && input->__file)
  {
    /* Load the image */

    e = _swix(OS_Args,
              _INR(0,2),

              1,
              input->__file,
              12);

    if (e) goto image_tile_to_draw_exit;

    e = _swix(OS_GBPB,
              _INR(0,3),

              4,
              input->__file,
              block,
              image_size);

    if (e) goto image_tile_to_draw_exit;

    fclose(input);
    input = NULL;

    /* Render the image over the redraw region */

    for (y = ymax - h + 4; y >= r->redraw_area.ymin - h; y -= h)
    {
      for (x = xmin; x <= r->redraw_area.xmax; x += w)
      {
        if (!size)
        {
          draw_spristrhdr hdr;
          int             ok;

          /* Write the item header */

          hdr.tag  = draw_OBJSPRITE;
          hdr.size = image_size + sizeof(hdr);

          hdr.bbox.xmin = OTD(x);
          hdr.bbox.ymin = OTD(y);
          hdr.bbox.xmax = OTD(x + w);
          hdr.bbox.ymax = OTD(y + h);

          if (!savedraw_write_bytes((char *) &hdr, sizeof(hdr))) goto image_tile_to_draw_exit;

          /* Write out the image */

          ok = savedraw_write_bytes(block, image_size);
          if (!ok) goto image_tile_to_draw_exit;

          #ifdef STRICT_PARSER

            if (e)
            {
              e->errnum = Utils_Error_Custom_Message;
              show_error_ret(e);

              goto image_tile_to_draw_exit;
            }

          #else

            if (e) goto image_tile_to_draw_exit;

          #endif
        }

        tsize += image_size + sizeof(draw_spristrhdr);
      }
    }
  }

  /* Successful exit */

  if (input) fclose(input);
  if (block) free(block);

  remove(name);

  return tsize;

  /* Error condition exit */

image_tile_to_draw_exit:

  if (input) fclose(input);
  if (block) free(block);

  remove(name);

  return 0;
}
