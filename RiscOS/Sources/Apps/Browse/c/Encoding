/***************************************************/
/* File   : Encoding.c                             */
/*                                                 */
/* Purpose: Routines to handle the encoding menus. */
/*                                                 */
/* Author : K.J.Bracey                             */
/*                                                 */
/* History: 05-Sep-97: Created.                    */
/***************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#include "swis.h"

#include "wimp.h"
#include "toolbox.h"
#include "menu.h"
#include "event.h"

#include "iso10646.h"

#include "Global.h"
#include "Utils.h"

#include "Encoding.h"

/* Statics */

static ObjectId menu_id = NULL_ObjectId;

static int      ticked_encoding;
static int      delete_handler_registered;
static int      entries_faded;

/*************************************************/
/* encoding_fade_unusable_entries()              */
/*                                               */
/* Scan the Encoding menu, fading out encodings  */
/* that aren't supported.                        */
/*                                               */
/* Parameters: The object ID of the Encoding     */
/*             menu.                             */
/*************************************************/

static int encoding_fade_unusable_entries(ObjectId o)
{
  /* How do we do this without an enumerate call? */

  return 0;
}

/*************************************************/
/* encoding_tick_entry()                         */
/*                                               */
/* Select or deselect the entry corresponding    */
/* to a specified encoding. Parent menu items    */
/* are also selected/deselected.                 */
/*                                               */
/* Parameters: The object ID of the Encoding     */
/*             menu;                             */
/*                                               */
/*             The number of the encoding;       */
/*                                               */
/*             0 to untick, 1 to tick.           */
/*                                               */
/* Returns:    1 if entry found, 0 if not.       */
/*                                               */
/* Assumes:    Parent menu items have            */
/*             consecutive component IDs         */
/*             starting at 0x11000 in each menu; */
/*                                               */
/*             The component ID of an encoding   */
/*             item is the number of the         */
/*             encoding it represents;           */
/*                                               */
/*             A given encoding is only          */
/*             represented once in the menu      */
/*             tree.                             */
/*************************************************/

static int encoding_tick_entry(ObjectId o, int enc, int state)
{
  ComponentId c;
  _kernel_oserror *e;

  e = menu_set_tick(0, o, enc, state);

  if (!e) return 1;

  /* The encoding isn't in this menu, so scan the submenus. */

  for (c = 0x11000; ; c++)
  {
    ObjectId sub;

    e = menu_get_sub_menu_show(0, o, c, &sub);

    /* If an error - component not found - end of submenus */

    if (e) return 0;

    if (sub == NULL_ObjectId) continue;

    if (encoding_tick_entry(sub, enc, state))
    {
      ChkError(menu_set_tick(0, o, c, state));
      return 1;
    }
  }
}

/*************************************************/
/* encoding_prepare_menu()                       */
/*                                               */
/* Ensure that the state of the Encoding menu    */
/* is correct for a given browser.               */
/*                                               */
/* Parameters: Object ID of the Encoding menu;   */
/*                                               */
/*             Pointer to a browser_data struct  */
/*             owning the menu.                  */
/*                                               */
/* Assumes:    The "From document" item is       */
/*             component 0x11FFF in the top-     */
/*             level menu;                       */
/*                                               */
/*             The Encoding menu is a shared     */
/*             object.                           */
/*************************************************/

static void encoding_prepare_menu(ObjectId o, browser_data *b)
{
  menu_set_tick(0, o, 0x11FFF, b->encoding_priority != priority_user);

  if (ticked_encoding != b->encoding)
  {
    if (ticked_encoding) encoding_tick_entry(o, ticked_encoding, 0);

    encoding_tick_entry(o, b->encoding, 1);
    ticked_encoding = b->encoding;
  }

}

/*************************************************/
/* encoding_select()                             */
/*                                               */
/* Event handler for the selection of an         */
/* encoding (EEncoding_Select).                  */
/*                                               */
/* Parameters are as for a standard Toolbox      */
/* event handler.                                */
/*                                               */
/* Assumes: The top-level Encoding menu is an    */
/*          ancestor object;                     */
/*                                               */
/*          The component ID is the number of    */
/*          the encoding to select.              */
/*************************************************/

int encoding_select(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  browser_data * b;

  ChkError(toolbox_get_client_handle(0, idb->ancestor_id, (void *) &b));

  if (!is_known_browser(b)) return 0;

  b->encoding          = idb->self_component;
  b->encoding_priority = priority_user;

  encoding_prepare_menu(idb->ancestor_id, b);

  return 1;
}

/*************************************************/
/* encoding_from_document_select()               */
/*                                               */
/* Handle the selection of the "From document"   */
/* menu entry.                                   */
/*                                               */
/* Parameters are as for a standard Toolbox      */
/* event handler.                                */
/*************************************************/

int encoding_from_document_select(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  browser_data * b;
  ChkError(toolbox_get_client_handle(0, idb->ancestor_id, (void *) &b));

  if (!is_known_browser(b)) return 0;

  if (b->encoding_priority == priority_user)
  {
    b->encoding_priority = priority_default;
  }
  else
  {
    b->encoding_priority = priority_user;
  }

  encoding_prepare_menu(idb->self_id, b);

  return 1;
}

/*************************************************/
/* encoding_menu_deleted()                       */
/*                                               */
/* Note the deletion of the Encoding menu        */
/* (ticked entry no longer ticked, etc.)         */
/*                                               */
/* Parameters are as for a standard Toolbox      */
/* event handler.                                */
/*************************************************/

static int encoding_menu_deleted(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  menu_id                   = NULL_ObjectId;
  ticked_encoding           = 0;
  delete_handler_registered = 0;
  entries_faded             = 0;

  ChkError(event_deregister_toolbox_handler(idb->self_id,
                                            Toolbox_ObjectDeleted,
                                            encoding_menu_deleted,
                                            NULL));

  return 1;
}

/*************************************************/
/* encoding_show_menu()                          */
/*                                               */
/* Set up the Encoding menu before it is shown.  */
/*                                               */
/* Parameters are as for a standard Toolbox      */
/* event handler.                                */
/*************************************************/

int encoding_show_menu(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  browser_data * b;

  ChkError(toolbox_get_client_handle(0, idb->ancestor_id, (void *) &b));

  if (!is_known_browser(b)) return 0;

  if (!delete_handler_registered)
  {
    delete_handler_registered = 1;

    ChkError(event_register_toolbox_handler(idb->self_id,
                                            Toolbox_ObjectDeleted,
                                            encoding_menu_deleted,
                                            NULL));
  }

  if (!entries_faded)
  {
    encoding_fade_unusable_entries(idb->self_id);
    entries_faded = 1;
  }

  menu_id = idb->self_id;

  toolbox_set_client_handle(0, idb->self_id, b);

  encoding_prepare_menu(idb->self_id, b);

  return 1;
}

/*************************************************/
/* encoding_changed_by_meta()                    */
/*                                               */
/* Called by HTMLLib when a META tag that        */
/* changes encoding is found. Update the         */
/* browser_data struct and the menu accordingly. */
/*                                               */
/* This routine is registered with HTMLLib in    */
/* html_get_next_token() when the parse starts.  */
/*                                               */
/* Parameters: The number of the new encoding;   */
/*                                               */
/*             Pointer to the relevant           */
/*             browser_data struct.              */
/*************************************************/

void encoding_changed_by_meta(int encoding, void * handle)
{
  browser_data * b = (browser_data *) handle;

  b->encoding          = encoding;
  b->encoding_priority = priority_meta;

  encoding_update_menus(b);
}

/*************************************************/
/* encoding_update_menus()                       */
/*                                               */
/* Update the Encoding menu if it is currently   */
/* open for the specified browser.               */
/*                                               */
/* Parameters: Pointer to the browser_data       */
/*             whose encoding has changed.       */
/*************************************************/

void encoding_update_menus(browser_data * b)
{
  if (menu_id != NULL_ObjectId)
  {
    browser_data * b2;

    if (toolbox_get_client_handle(0, menu_id, (void *) &b2)) return;

    if (b2 == b) encoding_prepare_menu(menu_id, b);
  }
}
