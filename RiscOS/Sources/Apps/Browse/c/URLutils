/**************************************************************/
/* File:    URLutils.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: URL manipulation for the browser.browser.         */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 06-Feb-1997 (ADH): Created.                       */
/*          23-May-2000 (ADH): 64-wide comments adopted.      */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <URI.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/event.h>

#include "Global.h"
#include "Utils.h"

#include "Fetch.h" /* (Which itself includes URLstat.h) */
#include "Filetypes.h"
#include "Javascript.h"
#include "List.h"
#include "MimeMap.h"
#include "URIfile.h"
#include "URLveneer.h"

#include "URLutils.h"

/* Local definitions */

#define ExtensionMatches(url, len, ext) (len) > strlen(ext) && !strncmp((url) + (len) - strlen(ext), (ext), strlen(ext))

/* Local variables */

/* Pointer to first item in queue of URLs dispatched through */
/* the URI handler (structure defined in URLutils.h)         */

static uri_queue * uri_queue_base = NULL;

/**************************************************************/
/* urlutils_urlsscmp()                                        */
/*                                                            */
/* Compares two URLs, returning 1 if they differ or 0 if they */
/* are the same. Both URLs are converted internally to        */
/* url_descriptions.                                          */
/*                                                            */
/* Parameters: Pointer to a null terminated URL string;       */
/*                                                            */
/*             Pointer to a second null termina- ted URL      */
/*             string.                                        */
/*                                                            */
/* Returns:    0 if the URLs match, else 1.                   */
/**************************************************************/

int urlutils_urlsscmp(const char * url_s1, const char * url_s2)
{
  url_description * url_d1;
  url_description * url_d2;
  int               result;

  /* Sanity check */

  if (!url_s1 && !url_s2) return 0;
  if (!url_s1 || !url_s2) return 1;

  // Awaiting URL module stuff

  url_d1 = urlutils_return_description(url_s1);
  url_d2 = urlutils_return_description(url_s2);

  if (url_d1 && url_d2)
  {
    result = !!strcmp(url_d1->full, url_d2->full);
  }

  /* No memory, no brain. Hey ho. */

  else result = !!strcmp(url_s1, url_s2);

  urlutils_free_description(url_d1);
  urlutils_free_description(url_d2);

  return result;
}

/**************************************************************/
/* urlutils_urldscmp()                                        */
/*                                                            */
/* Compares two URLs, returning 1 if they differ or 0 if they */
/* are the same. The first URL is specified as a              */
/* url_description, the second URL is converted internally.   */
/*                                                            */
/* Parameters: Pointer to a url_description filled in with    */
/*             the URL details;                               */
/*                                                            */
/*             Pointer to a second null termina- ted URL      */
/*             string.                                        */
/*                                                            */
/* Returns:    0 if the URLs match, else 1.                   */
/**************************************************************/

int urlutils_urldscmp(const url_description * url_d, const char * url_s)
{
  url_description * url_d2;
  int               result;

  /* Sanity check */

  if (!url_d)                 return 1;
  if (!url_s && !url_d->full) return 0;
  if (!url_s || !url_d->full) return 1;

  // Awaiting URL module stuff

  url_d2 = urlutils_return_description(url_s);

  if (url_d && url_d2)
  {
    result = !!strcmp(url_d->full, url_d2->full);
  }
  else result = !!strcmp(url_d->full, url_s);

  urlutils_free_description(url_d2);

  return result;
}

/**************************************************************/
/* urlutils_urldscmp()                                        */
/*                                                            */
/* Compares two URLs, returning 1 if they differ or 0 if they */
/* are the same. Both URLs are specified as url_description   */
/* structures.                                                */
/*                                                            */
/* Parameters: Pointer to a url_description filled in with    */
/*             the URL details;                               */
/*                                                            */
/*             Another url_description pointer, filled in     */
/*             with the details of a second URL.              */
/*                                                            */
/* Returns:    0 if the URLs match, else 1.                   */
/**************************************************************/

int urlutils_urlddcmp(const url_description * url_d1, const url_description * url_d2)
{
  /* Sanity check */

  if (!url_d1 && url_d2)  return 1;
  if (!url_d2 && url_d1)  return 1;
  if (!url_d1 && !url_d2) return 0;

  if (!url_d1->full && !url_d2->full) return 0;
  if (!url_d1->full || !url_d2->full) return 1;

  // Awaiting URL module stuff

  return !!strcmp(url_d1->full, url_d2->full);
}

/**************************************************************/
/* urlutils_return_description()                              */
/*                                                            */
/* Given a URL string, returns a url_description structure    */
/* which contains more accessible details on the URL          */
/* contents.                                                  */
/*                                                            */
/* The block itself and all filled in fields are allocated    */
/* with malloc(), and any additions to the structure should   */
/* be allocated in the same way.                              */
/*                                                            */
/* Parameters: Pointer to a null terminated URL string.       */
/*                                                            */
/* Returns:    Pointer to a url_description structure filled  */
/*             in with details of the string, or NULL if      */
/*             allocation failed.                             */
/**************************************************************/

url_description * urlutils_return_description(const char * url_s)
{
  url_description * new;

  size_t            rlen;
  char *            tlen;
  int               plen;

  if (!url_s || !*url_s) return NULL;

  /* Allocate the structure */

  new = calloc(1, sizeof(url_description));

  if (!new) return NULL;

  /* Find the item lengths */

  if (_swix(URL_ParseURL,
            _INR(0,5),

            URL_ParseURL_LengthInR5,
            URL_ParseURL_Reason_FindLengths,
            url_s,
            NULL,
            new,
            sizeof(url_description) / sizeof(int))) goto urlutils_return_description_free_and_exit;

  /* Expect the canonicalised form at the very least; new->full on */
  /* return from the SWI holds the buffer length required for this */

  if (!new->full) goto urlutils_return_description_free_and_exit;

  /* Allocate a block to hold all of the fields */

  rlen = (int) new->full     +
         (int) new->protocol +
         (int) new->host     +
         (int) new->port     +
         (int) new->user     +
         (int) new->password +
         (int) new->account  +
         (int) new->path     +
         (int) new->query    +
         (int) new->fragment;

  if (!rlen) goto urlutils_return_description_free_and_exit;

  tlen      = (char *) new->full;
  new->full = malloc(rlen);
  if (!new->full) goto urlutils_return_description_free_and_exit;

  tlen     += (int) new->full;

  if (new->protocol) plen = (int) new->protocol, new->protocol = tlen, tlen += plen;
  if (new->host)     plen = (int) new->host,     new->host     = tlen, tlen += plen;
  if (new->port)     plen = (int) new->port,     new->port     = tlen, tlen += plen;

  if (new->user)     plen = (int) new->user,     new->user     = tlen, tlen += plen;
  if (new->password) plen = (int) new->password, new->password = tlen, tlen += plen;
  if (new->account)  plen = (int) new->account,  new->account  = tlen, tlen += plen;

  if (new->path)     plen = (int) new->path,     new->path     = tlen, tlen += plen;

  if (new->query)    plen = (int) new->query,    new->query    = tlen, tlen += plen;
  if (new->fragment) new->fragment = tlen;

  /* Fill in the block */

  if (_swix(URL_ParseURL,
            _INR(0,5),

            URL_ParseURL_LengthInR5,
            URL_ParseURL_Reason_FillBuffers,
            url_s,
            NULL,
            new,
            sizeof(url_description) / sizeof(int))) goto urlutils_return_description_free_and_exit;

  /* Finished */

  return new;

  /* Error condition exit routine */

urlutils_return_description_free_and_exit:

  urlutils_free_description(new);

  return NULL;
}

/**************************************************************/
/* urlutils_free_description()                                */
/*                                                            */
/* Frees a url_description and all memory associated with it. */
/*                                                            */
/* The function expects all filled in fields in the structure */
/* to point to malloced blocks, as this is the way that       */
/* urlutils_return_description allocates it.                  */
/*                                                            */
/* Parameters: Pointer to a url_description structure.        */
/**************************************************************/

void urlutils_free_description(url_description * url_d)
{
  /* Not the most demanding code in the world, really */

  free(url_d->full);
  free(url_d);

  return;
}

/**************************************************************/
/* urlutils_matches_special()                                 */
/*                                                            */
/* Given a URL description and a string with a comma          */
/* separated list of entries describing match parameters,     */
/* return 1 if the URL meets any of the match criteria. The   */
/* match string should be in a writeable buffer and will be   */
/* corrupted on exit. The string consists of:                 */
/*                                                            */
/* 1. An optional hostname; either fully qualified (e.g.      */
/*    'www.acorn.com') or partially if starting with a dot    */
/*    (e.g. .acorn.com' to match any host with a name ending  */
/*    in '.acorn.com').                                       */
/*                                                            */
/* 2. An optional port following the host name, separated by  */
/*    a colon (e.g. 'www:3172'). Note that specifying the     */
/*    default port for whatever fetch protocol is in use will */
/*    never match (e.g. 'www:80' would never match for an     */
/*    HTTP fetch of server 'www') so this is only useful for  */
/*    matching unusual port values.                           */
/*                                                            */
/* 3. An optional path fragment, which is matched against the */
/*    left hand side of the URL (e.g. 'www/this/that' would   */
/*    match any path 'this/that', 'this/that/more',           */
/*    'this/thatandmore.gif', etc.).                          */
/*                                                            */
/* Parameters: Pointer to a url_description filled in with    */
/*             details of the URL to examine;                 */
/*                                                            */
/*             Pointer to a string with the match parameters  */
/*             in it, comma separated if many are needed,     */
/*             which must be in a writeable buffer.           */
/*                                                            */
/* Returns:    1 if there's a match, else 0. The given match  */
/*             string is corrupted.                           */
/**************************************************************/

int urlutils_matches_special(const url_description * d, char * writeable)
{
  if (d && writeable)
  {
    char * at;

    char * host = d->host ? d->host : "";
    char * path = d->path ? d->path : "";
    char * port = d->port ? d->port : "";

    do
    {
      /* Get each comma separated section individually */

      at = strtok(writeable, ","), writeable = NULL;

      if (at)
      {
        char * slash = strchr(at, '/');
        char * colon = strchr(at, ':');

        int    match = 0;

        /* Overwrite key seperator characters with terminators to make */
        /* subsequent comparisons easier                               */

        if (colon) *colon = '\0', colon++;
        if (slash) *slash = '\0', slash++;

        /* Match port and left hand side of path if required */

        if (!colon) match++;
        else if (!utils_strcasecmp(port, colon)) match++;

        if (!slash) match++;
        else if (!utils_strncasecmp(path, slash, strlen(slash))) match++;

        /* Allow no host (so just match by port or path) */

        if (!*at && (colon || slash)) match++;

        /* Otherwise, do host matching */

        else if (*at)
        {
          /* Compare only the right hand side */

          if (*at == '.')
          {
            int hlen   = strlen(host);
            int offset = hlen - strlen(at);

            if (offset >= 0 && !utils_strcasecmp(host + offset, at)) match++;
          }

          /* Compare the whole thing */

          else
          {
            if (!utils_strcasecmp(host, at)) match++;
          }
        }

        /* Did we match it? */

        if (match == 3) return 1;

        /* No, so restore the string so strtok will continue to work */

        if (slash) *(--slash) = '/';
        if (colon) *(--colon) = ':';
      }
    }
    while (at);
  }

  return 0;
}

/**************************************************************/
/* urlutils_match_by_token()                                  */
/*                                                            */
/* Similar to urlutils_matches_special, but has a more        */
/* accessible API. Given a URL and a Choices file token name, */
/* see if the list of specifiers expected to be in the value  */
/* of the Choices file token matches the given URL. Has to    */
/* expand the URL to a url_description and go through the     */
/* List dialogue box lookup routines so this isn't all that   */
/* fast; if there is a series of matches to do on the same    */
/* URL, it would be better to make the url_description        */
/* externally and call urlutils_matches_special directly.     */
/*                                                            */
/* Parameters: Pointer to the URL to check;                   */
/*                                                            */
/*             Pointer to the Choices file token to check     */
/*             against.                                       */
/*                                                            */
/* Returns:    1 if the value of the token from the Choices   */
/*             file leads to a match with the URL. For        */
/*             details on the format, see the Choices file    */
/*             for comments on things like the                */
/*             LOProxyExclusions entry, or see                */
/*             urlutils_matches_special.                      */
/**************************************************************/

int urlutils_match_by_token(const char * url, const char * token)
{
  url_description * d    = NULL;
  char            * list = NULL;
  int               ret  = 0;

  if (!url || !token || !*url || !*token) return 0;

  d = urlutils_return_description(url);

  if (d)
  {
    char * list = list_get_malloc_list_string(token);
    if (list) ret = urlutils_matches_special(d, list);
  }

  if (d) urlutils_free_description(d);
  free(list);

  return ret;
}

/**************************************************************/
/* urlutils_pathname_to_url()                                 */
/*                                                            */
/* Takes a pathname, and turns it into a File URL, if it      */
/* isn't one already. The pathname that you give is altered   */
/* directly, so if you want to remember the path as well as   */
/* the URL, ensure there is a second copy of it in another    */
/* buffer somewhere.                                          */
/*                                                            */
/* Parameters: Pointer to the pathname;                       */
/*                                                            */
/*             Size of the buffer the pathname is stored in.  */
/**************************************************************/

void urlutils_pathname_to_url(char * path, int buffersize)
{
  int    len;
  char * pathdup;

  /* Try to expand the path - if this fails, carry on */
  /* without the expansion.                           */

  pathdup = malloc(strlen(path) + 1);

  if (pathdup)
  {
    unsigned int flags;

    strcpy(pathdup, path);

    /* Expand the path */

    if (
         _swix(OS_GSTrans,
               _INR(0,2) | _OUT(_FLAGS),

               pathdup,
               path,
               buffersize,

               &flags)

         || (flags & _C)
       )
    {
      strcpy(path, pathdup);
    }
    else
    {
      /* Terminate the string at any control code */

      for (len = 0; len < buffersize; len++)
      {
        if (path[len] < 32)
        {
          path[len] = 0;
          break;
        }
      }
    }

    free(pathdup);
  }

  /* Find the length of the File module protocol specifier */

  len = strlen(FileMethod ProtocolSepShort); /* (urlutils.h) */

  /* If the first part of the string doesn't match the FileMethod */
  /* specifier (see URLutils.h) then insert this text and convert */
  /* the rest of the path to a URL.                               */

  if (strncmp(path, FileMethod ProtocolSepShort, len))
  {
    memmove(path + len, path, buffersize - len);
    strncpy(path, FileMethod ProtocolSepShort, len);

    /* Ensure the string is terminated */

    path[buffersize - 1] = 0;

    /* Now translate the pathname part of the URL to a Unix-style */
    /* path scheme.                                               */

    urlutils_translate_pathname(path + len);
  }

  return;
}

/**************************************************************/
/* urlutils_url_to_pathname()                                 */
/*                                                            */
/* Takes a file:// URL, and turns it into a RISC OS pathname, */
/* if it isn't one already. The URL that you give is altered  */
/* directly, so if you want to remember the URL as well as    */
/* the new path, ensure there is a second copy of it in       */
/* another buffer somewhere.                                  */
/*                                                            */
/* Parameters: Pointer to the URL;                            */
/*                                                            */
/*             Size of the buffer the URL is stored in.       */
/**************************************************************/

void urlutils_url_to_pathname(char * url, int buffersize)
{
  url_description * url_d;

  url_d = urlutils_return_description(url);

  /* If this fails, try a more basic approach... */

  if (!url_d)
  {
    int    len;
    char * hash;

    /* Find the length of the File module protocol specifier */

    len = strlen(FileMethod); /* (urlutils.h) */

    /* If the first part of the string doesn't match the FileMethod */
    /* specifier (see URLutils.h) then we can't do anything.        */

    if (!url || strncmp(url, FileMethod, len)) return;

    /* Copy over the file: specifier and any '/'s */

    while (url[len] == '/') len++;

    memmove(url, url + len, buffersize - len);

    /* Strip off any fragment (this bit could fail badly for file */
    /* system specifiers, but in the absence of URL_ParseURL      */
    /* working - 'url_d' is NULL if we reach here - there's not a */
    /* lot of point working very hard to pull out.                */

    hash = strrchr(url, '#');
    if (hash) *hash = 0;
  }

  else
  {
    /* We managed to get a full URL description, so take the */
    /* path component of this.                               */

    strncpy(url, url_d->path, buffersize - 1);
    url[buffersize - 1] = 0;

    urlutils_free_description(url_d);
  }

  /* Convert the path component of the URL back to RISC OS style */

  urlutils_translate_pathname(url);

  return;
}

/**************************************************************/
/* urlutils_translate_pathname()                              */
/*                                                            */
/* Takes a RISC OS-style pathname and turns it into a         */
/* Unix-style pathname, or vice versa.                        */
/*                                                            */
/* The pathname you give is altered directly, so if you want  */
/* to remember the path before translation, ensure there is a */
/* second copy of in another buffer somewhere.                */
/*                                                            */
/* Parameters: Pointer to the pathname.                       */
/**************************************************************/

void urlutils_translate_pathname(char * path)
{
  char * p;

  p = path;

  /* Skip past any filing system separators (e.g. as in the */
  /* colons in 'ADFS::<disc>.<path>').                      */

  while (*p && *p != ':') p++;

  /* Swap '/' for '.' */

  while (*p)
  {
    if      (*p == '/') *p = '.';
    else if (*p == '.') *p = '/';

    p++;
  }

  return;
}

/**************************************************************/
/* urlutils_leafname_from_url()                               */
/*                                                            */
/* Returns a pointer to a string containing a possible        */
/* leafname, based upon the URL passed into the function.     */
/*                                                            */
/* Parameters: Pointer to a URL string;                       */
/*                                                            */
/*             Pointer to a buffer into which to place the    */
/*             leafname (not the same as the URL string);     */
/*                                                            */
/*             Size of the buffer.                            */
/*                                                            */
/* Returns:    Will fill the buffer in with some leafname,    */
/*             even if one could not be worked out from the   */
/*             URL. Returns the buffer pointer for            */
/*             convenience (even though the caller will       */
/*             almost certainly know this).                   */
/*                                                            */
/* Assumes:    Neither pointer may be NULL. The buffer must   */
/*             be at least 2 bytes in size. If either         */
/*             condition is not met, NULL is returned and the */
/*             buffer is left untouched.                      */
/**************************************************************/

char * urlutils_leafname_from_url(char * url, char * leaf, int size)
{
  int l = 0;

  if (!url || !leaf || size < 2) return NULL;

  memset(leaf, 0, size);

  /* l holds the string length if b->urlfdata exists */

  l = (int) strlen(url);

  /* If the string exists and is not null, try to extract */
  /* a leafname from it.                                  */

  if (l)
  {
    /* Set 'e' to point at the last character in the string, */
    /* and we will use 's' to point to the first character   */
    /* after the host name.                                  */

    int e     = l - 1;
    int s     = 0;
    int found = 0;

    /* We want to do the following, bearing in mind that whilst */
    /* a protocol at the start of the URL is assumed, it may be */
    /* separated by nothing more than a colon (not even ':/' or */
    /* '://'). The use of square brackets implies one or more   */
    /* analogous optional terms.                                */
    /*                                                          */
    /* a.b.c/[dir/]name.html  ->  name                          */
    /* a.b.c/dir[/]           ->  dir                           */
    /* a.b.c[/]               ->  Generic                       */
    /* a.b.c/name.txt         ->  name                          */
    /* a.b.c/name.tar.gz      ->  name/tar (as a consequence)   */
    /* a.b.c/name_1.2.1.gz    ->  name/1/2/1 (as a consequence) */
    /* a.b.c/name.html#anc    ->  anc                           */
    /*                                                          */
    /* A slight change to the above behaviour is to only strip  */
    /* filename extensions if there is a defined filetype for   */
    /* that extension. Then, for example, we get the following. */
    /*                                                          */
    /* a.b.c/dir/name.txt     ->  name                          */
    /* a.b.c/dir/name.zip     ->  name                          */
    /* a.b.c/dir/name.01      ->  name/01                       */
    /* a.b.c/dir/name.02      ->  name/02                       */
    /*                                                          */
    /* The tricky part is determining what bit is host name and */
    /* what bit is path; it gets easier after that. First, look */
    /* for a ':'. This will either be a protocol separator, or  */
    /* a port number separator. Trouble is, you need to skip    */
    /* any '/'s after the ':' if it's the first case, so check  */
    /* if any '.'s are passed when looking for the ':'. If so,  */
    /* we're on a port number. The only possible failure case   */
    /* is a URL with no protocol specified and a single word    */
    /* host name with a port number; but then, just about every */
    /* other system will fail as the host name will be taken to */
    /* be the protocol (e.g. 'dylan:8080'). So this isn't a     */
    /* problem, really - we'd return a generic response.        */

    while (s < l && url[s] != ':')
    {
      if (url[s] == '.') found = 1;
      s++;
    }

    /* Did we run out of string? If so, go back to the start; */
    /* we may just have no protocol or port specified.        */

    if (s == l) s = 0;

    /* If we've not found any dots, may need to skip a few slashes;  */
    /* but not more than two, as three slashes (for example) implies */
    /* that no host name is present.                                 */

    if (!found)
    {
      s++; /* Skip past the ':' */

      if (url[s] == '/') s++;
      if (url[s] == '/') s++;

      /* If we ran out of string, must use a generic response */

      if (s == l) goto return_generic;
    }

    /* We're either now on the ':' separating the host name */
    /* and port number, or on the first character after any */
    /* '/'s or the ':' separating the protocol from the     */
    /* host name. In either case, we now search forward for */
    /* a single slash - the separator between host name and */
    /* path.                                                */

    while (s < l && url[s] != '/')
    {
      s++;
    }

    /* Skip past the '/' */

    if (url[s] == '/') s++;

    /* If we're run out string, go for a generic response - */
    /* e.g. 'http://www/' or just 'http://www'.             */

    if (s >= l) goto return_generic;

    /* Otherwise, we can now start searching backwards for a */
    /* usable leafname, knowing that reaching 's' is the     */
    /* exit condition. First, look for anchor names.         */

    if (strrchr(url, '#') > strrchr(url, '/')) /* Want 'a/b#c' -> 'c', but not 'a#b/c' -> 'b/c' */
    {
      while (e > s && url[e] != '#')
      {
        e--;
      }

      /* Step forward past the '#' */

      e++;

      /* If it turns out that the '#' is all that there is after */
      /* the host name, it may be possible to step back and get  */
      /* whatever comes before it; or if we hit 's' in trying,   */
      /* we'll have to return a generic response.                */

      if (e == l)
      {
        e --;

        if (e <= s) goto return_generic;
        else        goto get_directory_name;
      }

      /* Right, copy the string from this point forwards */

      strncpy(leaf, url + e, size - 1);

      /* Finished, so jump to the final stripping routine */

      goto strip_illegal_chars;
    }

    /* Right, if we have a trailing '/' or '#' (from the above code), */
    /* following a directory name, then get that directory name.      */

get_directory_name:

    if (url[e] == '/' || url[e] == '#')
    {
      int chars;

      found = e--;

      /* Find the start point of the name */

      while (e > s && url[e] != '/') e--;

      /* If e is greater than s, we're sitting on the '/' */
      /* found above, so advance past it.                 */

      if (e > s) e++;

      /* Copy the name in */

      chars = found - e;
      if (chars > size - 1) chars = size - 1;
      strncpy(leaf, url + e, chars);

      /* Finished - just need to take care of any illegal characters */

      goto strip_illegal_chars;
    }

    /* Otherwise, continue, looking for a '/'. If a '.' is found on the */
    /* way, remember the offset for the first time it is encountered.   */

    found = 0;

    while (e > s && url[e] != '/')
    {
      if (url[e] == '.' && !found) found = e;
      e--;
    }

    if (url[e] == '/')
    {
      e++;
      if (e >= l) goto return_generic;
    }

    /* We now have 'e' pointing to the start of a leafname */
    /* and possibly 'found' pointing to the start of a     */
    /* filename extension. If the latter is true, check    */
    /* that there is something between the two...          */

    if (found && found <= e) goto return_generic;

    /* Take a copy of as much of the current leafname will fit;  */
    /* we may have to write zero terminators in at this point if */
    /* there is any CGI information to strip.                    */

    strncpy(leaf, url + e, size - 1);

    /* OK, we have a string. If found is NULL, then we don't have a  */
    /* filename extension to strip - there's no more work to do.     */
    /* Otherwise, strip the extension if a filetype is found for it. */

    if (found && (found - e) <= size - 1)
    {
      int chars = found - e;
      int filetype;

      /* Is there a filetype for this extension? And should we actually */
      /* strip it anyway?                                               */

      if (
           choices.strip_extensions &&
           (
             !utils_strcasecmp(leaf + chars, ".cgi") /* Special case '.cgi' - always strip it */
             ||
             (
               !mimemap_extension_to_riscos(leaf + chars, &filetype) &&
               filetype != FileType_DATA
             )
           )
         )
      {
        /* Strip the extension */

        *(leaf + chars) = '\0';
      }
    }

    /* Right, that's the worst of it over...! The strip routine will */
    /* take care of converting '.'s to '/'s, etc., if there are any. */

    goto strip_illegal_chars;

return_generic:

    lookup_token("NoURLleaf:Index",0,0);
    strncpy(leaf, tokens, size - 1);
  }

  /* There was apparently no URL in the buffer, so offer a */
  /* neutral filename of HTMLfile.                         */

  else
  {
    lookup_token("NoURLdata:HTMLfile",0,0); /* Will put the string in the 'tokens' global buffer */
    strncpy(leaf, tokens, size - 1);
  }

strip_illegal_chars:

  /* Scan the leaf for illegal characters */

  l = 0;

  while (leaf[l])
  {
    /* A few we can replace with meaningful alternatives */

    if (leaf[l] == '.')  leaf[l] = '/';
    if (leaf[l] == '\\') leaf[l] = '/';
    if (leaf[l] == '&')  leaf[l] = '+';
    if (leaf[l] == '"')  leaf[l] = '\'';

    /* And the rest, replace with underscores */

    if (
         leaf[l] == '$' ||
         leaf[l] == '%' ||
         leaf[l] == '@' ||
         leaf[l] == '^' ||
         leaf[l] == ':' ||
         leaf[l] == '#' ||
         leaf[l] == '*' ||
         leaf[l] == '"' ||
         leaf[l] == '|'
       )
       leaf[l] = '_';

    l++;
  }

  /* Finished. */

  return leaf;
}

/**************************************************************/
/* urlutils_host_name_from_url()                              */
/*                                                            */
/* Extracts the host name from a given URL.                   */
/*                                                            */
/* Parameters: Pointer to the URL string;                     */
/*                                                            */
/*             Pointer to a buffer to write the host name     */
/*             into;                                          */
/*                                                            */
/*             Size of the buffer.                            */
/**************************************************************/

void urlutils_host_name_from_url(char * url, char * host, int size)
{
  char * p;

  host[0] = 0;

  /* First look for '//', as in 'http://' */

  p = strstr(url, ProtocolSeparator);

  if (p)
  {
    /* If found, copy everything after that into 'host' */

    p += 2;
    strncpy(host, p, size - 1);
    host[size - 1] = 0;

    /* Now search for a '/', as in 'http://www.acorn/', */
    /* and if found force a terminator there.           */

    p = strchr(host, '/');
    if (p) *p = 0;
  }
}

/**************************************************************/
/* urlutils_filetype_from_url()                               */
/*                                                            */
/* Examines a URL and returns a RISC OS filetype based on the */
/* filename extension in the URL.                             */
/*                                                            */
/* FileType_TEXT is returned if no absolute determination can */
/* be made (e.g. no filename extension!).                     */
/*                                                            */
/* Parameters: Pointer to a null-terminated URL string.       */
/*                                                            */
/* Returns:    A RISC OS filetype.                            */
/**************************************************************/

int urlutils_filetype_from_url(const char * url)
{
  const char * dot;
  int          filetype;

  if (!url || !*url) return NULL;

  dot = strrchr(url, '.');

  if (!dot) return FileType_TEXT;

  if (mimemap_extension_to_riscos(dot, &filetype)) return FileType_TEXT;

  return filetype;

//  /* For now, hard code it. In future, use a mime mapper module. */
//
//  int len;
//
//  if (!url || !*url) return NULL;
//  else len = strlen(url);
//
//  /* Document types */
//
//  if (ExtensionMatches(url, len, ".html"))  return FileType_HTML;
//  if (ExtensionMatches(url, len, ".htm"))   return FileType_HTML;
//  if (ExtensionMatches(url, len, ".txt"))   return FileType_TEXT;
//  if (ExtensionMatches(url, len, ".shtml")) return FileType_HTML;
//  if (ExtensionMatches(url, len, ".shtm"))  return FileType_HTML;
//  if (ExtensionMatches(url, len, ".pdf"))   return FileType_PDF;
//  if (ExtensionMatches(url, len, ".doc"))   return FileType_WORD;
//  if (ExtensionMatches(url, len, ".ps"))    return FileType_PS;
//  if (ExtensionMatches(url, len, ".eps"))   return FileType_PS;
//  if (ExtensionMatches(url, len, ".wri"))   return FileType_DOS;
//  if (ExtensionMatches(url, len, ".xls"))   return FileType_XLS;
//
//  /* Images */
//
//  if (ExtensionMatches(url, len, ".gif"))   return FileType_GIF;
//  if (ExtensionMatches(url, len, ".jpg"))   return FileType_JPEG;
//  if (ExtensionMatches(url, len, ".jpeg"))  return FileType_JPEG;
//  if (ExtensionMatches(url, len, ".tiff"))  return FileType_TIFF;
//  if (ExtensionMatches(url, len, ".tif"))   return FileType_TIFF;
//  if (ExtensionMatches(url, len, ".png"))   return FileType_PNG;
//
//  /* Archives */
//
//  if (ExtensionMatches(url, len, ".zip"))   return FileType_ARC;
//  if (ExtensionMatches(url, len, ".arc"))   return FileType_ARC;
//  if (ExtensionMatches(url, len, ".spk"))   return FileType_ARC;
//  if (ExtensionMatches(url, len, ".arj"))   return FileType_ARC;
//  if (ExtensionMatches(url, len, ".gz"))    return FileType_GZ;
//  if (ExtensionMatches(url, len, ".tar"))   return FileType_ARC;
//  if (ExtensionMatches(url, len, ".zoo"))   return FileType_ARC;
//
//  /* Sounds */
//
//  if (ExtensionMatches(url, len, ".wav"))   return FileType_WAVE;
//  if (ExtensionMatches(url, len, ".arm"))   return FileType_ARMA;
//  if (ExtensionMatches(url, len, ".mod"))   return FileType_MOD;
//
//  /* Movies */
//
//  if (ExtensionMatches(url, len, ".mov"))   return FileType_AVI;
//  if (ExtensionMatches(url, len, ".avi"))   return FileType_AVI;
//  if (ExtensionMatches(url, len, ".qt"))    return FileType_AVI;
//  if (ExtensionMatches(url, len, ".qtvr"))  return FileType_AVI;
//  if (ExtensionMatches(url, len, ".rpl"))   return FileType_ARMO;
//  if (ExtensionMatches(url, len, ".rep"))   return FileType_ARMO;
//
//  /* Miscellaneous */
//
//  if (ExtensionMatches(url, len, ".bin"))   return FileType_DATA;
//  if (ExtensionMatches(url, len, ".dat"))   return FileType_DATA;
//  if (ExtensionMatches(url, len, ".data"))  return FileType_DATA;
//  if (ExtensionMatches(url, len, ".exe"))   return FileType_DOS;
//  if (ExtensionMatches(url, len, ".com"))   return FileType_DOS;
//
//  /* Otherwise, return text */
//
//  return FileType_TEXT;
}

/**************************************************************/
/* urlutils_create_hotlist_url()                              */
/*                                                            */
/* Creates a URL though which a hotlist file may be fetched.  */
/* This is done by looking at a system variable               */
/* '<App>$HotlistURL'. If that isn't set it looks at          */
/* '<App>$HotlistURIFile' which can hold the path of a URI    */
/* file to load. Lastly, it looks at the Choices file token   */
/* 'HotlistPath', where a RISC OS pathname pointing to the    */
/* file should be placed. This will be turned into a URL for  */
/* fetching, so care must be taken over the path used.        */
/*                                                            */
/* Parameters: Pointer to a buffer to place the URL in (not   */
/*             in a flex block!);                             */
/*                                                            */
/*             Size of the buffer.                            */
/**************************************************************/

void urlutils_create_hotlist_url(char * buffer, int size)
{
  _kernel_oserror * e;
  char            * varname;

  /* See if the variable exists. */

  memset(buffer, 0, size);

  /* Equivalent to getenv, but the RISC OS implementation evaluates  */
  /* the system variable as an expression which we don't want; hence */
  /* the direct use of the SWI.                                      */

  varname = lookup_token("_TaskName",1,0);
  strcat(varname, "$HotlistURL");

  e = _swix(OS_ReadVarVal,
            _INR(0,4),

            varname, /* Variable name                      */
            buffer,  /* Buffer                             */
            size,    /* Buffer size, -1 to check it exists */
            0,       /* Name pointer (0 for 1st call)      */
            4);      /* Variable type (4 = literal string) */

  /* First lookup failed, so try the URI file. */

  if (e)
  {
    varname = lookup_token("_TaskName",1,0);
    strcat(varname, "$HotlistURIFile");

    e = _swix(OS_ReadVarVal,
              _INR(0,4),

              varname,
              buffer,
              size,
              0,
              4);

    if (e)
    {
      /* If the above gives an error, the variable doesn't exist; get */
      /* the HotlistPath string from the Messages file instead.       */

      strncpy(buffer, lookup_choice("HotlistPath",1,0), size - 1);
      urlutils_pathname_to_url(buffer, size);
    }
    else
    {
      char path[Limits_OS_Pathname];

      StrNCpy0(path, buffer);
      urlutils_load_uri_file(buffer, size, NULL, 0, path);
    }
  }
}

/**************************************************************/
/* urlutils_create_home_url()                                 */
/*                                                            */
/* Creates a URL though which a home page may be fetched.     */
/* This is done by looking at a system variable               */
/* '<App>$HomeURL'. If that isn't set, it looks at            */
/* '<App>$HomeURIFile', which can  hold the path of a URI     */
/* file to load. Lastly, it looks at the Choices file token   */
/* 'HomePage'.                                                */
/*                                                            */
/* Parameters: Pointer to a buffer to place the URL in (not   */
/*             in a flex block!);                             */
/*                                                            */
/*             Size of the buffer.                            */
/**************************************************************/

void urlutils_create_home_url(char * buffer, int size)
{
  _kernel_oserror * e;
  char            * varname;

  /* See if the variable exists */

  memset(buffer, 0, size);

  /* Equivalent to getenv, but the RISC OS implementation evaluates  */
  /* the system variable as an expression which we don't want; hence */
  /* the direct use of the SWI.                                      */

  varname = lookup_token("_TaskName",1,0);
  strcat(varname, "$HomeURL");

  e = _swix(OS_ReadVarVal,
            _INR(0,4),

            varname, /* Variable name                      */
            buffer,  /* Buffer                             */
            size,    /* Buffer size, -1 to check it exists */
            0,       /* Name pointer (0 for 1st call)      */
            4);      /* Variable type (4 = literal string) */

  /* First lookup failed, so try the URI file. */

  if (e)
  {
    varname = lookup_token("_TaskName",1,0);
    strcat(varname, "$HomeURIFile");

    e = _swix(OS_ReadVarVal,
              _INR(0,4),

              varname,
              buffer,
              size,
              0,
              4);

    if (e)
    {
      /* If the above gives an error, the variable doesn't exist; get */
      /* the HotlistPath string from the global choices structure     */
      /* instead.                                                     */

      strncpy(buffer, choices.home_page, size - 1);
    }
    else
    {
      char path[Limits_OS_Pathname];

      StrNCpy0(path, buffer);
      urlutils_load_uri_file(buffer, size, NULL, 0, path);
    }
  }
}

/**************************************************************/
/* urlutils_fix_url()                                         */
/*                                                            */
/* Takes a URL and 'fixes' it, e.g. appends a '/' character   */
/* to a URL which is missing one. The contents of the buffer  */
/* you give with the URL inside are altered directly, so if   */
/* you want to remember the old URL, ensure there is a second */
/* copy of it in another buffer somewhere.                    */
/*                                                            */
/* Parameters: Pointer to the URL;                            */
/*                                                            */
/*             Size of the buffer the URL is stored in.       */
/*                                                            */
/* Returns:    Pointer to the fixed URL (which at the moment  */
/*             is the buffer that you passed in).             */
/**************************************************************/

char * urlutils_fix_url(char * buffer, int buffersize)
{
  int len,  shl;
  int flen, fshl;
  int glen, gshl;
  int blen, plen;

  plen = strlen(ProtocolSeparator);

  shl  = strlen(HTTPmethod);
  len  = shl + plen;

  fshl = strlen(FTPmethod);
  flen = fshl + plen;

  gshl = strlen(GopherMethod);
  glen = gshl + plen;

  blen = strlen(buffer);

  /* If there's no ':' in the string, insert a protocol type */

  if (
       !strchr(buffer, ':')     &&
       blen + len  < buffersize &&
       blen + flen < buffersize
     )
  {
    /* If the site appears to be an FTP site, insert the FTP protocol */
    /* at the start. Similarly for Gopher; else insert HTTP.          */

    if (!strncmp(buffer, FTPmethod, fshl - 1)) /* -1 as we don't want to compare the ':' */
    {
      memmove(buffer + flen, buffer, buffersize - flen);
      strncpy(buffer, FTPmethod ProtocolSeparator, flen);
    }
    else if (!strncmp(buffer, GopherMethod, gshl - 1))
    {
      memmove(buffer + glen, buffer, buffersize - glen);
      strncpy(buffer, GopherMethod ProtocolSeparator, glen);
    }
    else
    {
      memmove(buffer + len, buffer, buffersize - len);
      strncpy(buffer, HTTPmethod ProtocolSeparator, len);
    }

    buffer[buffersize - 1] = 0;
  }

  /* If there are at least 2 unused bytes in the buffer, and the */
  /* front of the string matches the HTTPMethod specifier (again */
  /* this is defined at the top of this file) then search for a  */
  /* '/' character which isn't part of a '//' sequence. If none  */
  /* is found, append a '/'. This is why 2 bytes free are needed */
  /* - one for the '/', one for the string terminator.           */

  if (strlen(buffer) < buffersize - 2 && !strncmp(buffer, HTTPmethod, shl))
  {
    int i, s = 0;

    for (i = 0;
         !s && buffer[i] && (i < (buffersize - 1));
         i ++)
    {
      /* If we have a '/' but not a '//' sequence, mark this with s = 1 */

      if (buffer[i] == '/' && buffer[i + 1] != '/') s = 1;

      /* If at start of a '//' sequence, skip past it */

      else if (buffer[i] == '/') i++;
    }

    if (!s) strcat(buffer,"/");
  }

  return buffer;
}

/**************************************************************/
/* urlutils_relativise_url()                                  */
/*                                                            */
/* HTMLLib has a call to take a base URL and a relative URL   */
/* and produce a canonical result based on the combination of */
/* the two. This does the same (it is based on the HTMLLib    */
/* code) but doesn't need an HTMLLib memory context to        */
/* operate in - the HTMLLib call is useful when context based */
/* memory allocation is handy.                                */
/*                                                            */
/* Parameters: Pointer to a base URL;                         */
/*                                                            */
/*             Pointer to a relative URL.                     */
/*                                                            */
/* Returns:    Pointer to a malloc'd URL (so it must be       */
/*             eventually free'd by the caller) which is the  */
/*             canonical result of combining the base and     */
/*             relative URLs.                                 */
/**************************************************************/

char * urlutils_relativise_url(const char * base, const char * link)
{
  _kernel_oserror * e;
  char            * ptr;
  int               blen;
  char            * ret = NULL;

  if (link == NULL) return NULL;

  if (base == NULL)
  {
    ret = utils_strdup(link);
    return ret;
  }

  /* Strip preceeding spaces */

  while (*link == ' ') link++;

  /* Cope with empty link URLs */

  if (*link == '\0') return utils_strdup(base);

  /* Otherwise, just go for it... */

  if (!base) base = "";

  blen = strlen(base) + 4 + (link ? strlen(link) : 0);
  ptr  = malloc(blen);

  if (ptr == NULL) return NULL;

  e = _swix(URL_ParseURL,
            _INR(0,5),

            0,
            URL_ParseURL_Reason_QuickResolve,
            base,
            link,
            ptr,
            blen);

  /* Did the above succeed? */

  if (e != NULL)
  {
    free(ptr);
    return NULL;
  }

  return ptr;
}

/**************************************************************/
/* urlutils_load_uri_file()                                   */
/*                                                            */
/* Version 1.00 files:                                        */
/*                                                            */
/* Loads a URI file. Will take ANT URL files too. The given   */
/* buffer will be filled with a null-terminated URI from the  */
/* file.                                                      */
/*                                                            */
/* The load terminates when the buffer is full except for the */
/* last byte (to allow for a forced terminator), or a control */
/* code is met in the URI file. Note that the buffer is       */
/* initialised to hold null bytes before the URI file is      */
/* opened.                                                    */
/*                                                            */
/* For URI files, you may also try to read a title string.    */
/*                                                            */
/* If there is an error opening the file or the file is       */
/* empty, the contents of the buffer are undefined.           */
/*                                                            */
/* Version 1.01 files:                                        */
/*                                                            */
/* As above, but will also automatically scan past the URL    */
/* looking for command lines and act upon them with no        */
/* external notification. For example, 'open <url>' will lead */
/* to a new window being created.                             */
/*                                                            */
/* Parameters: Pointer to the buffer for the URL;             */
/*                                                            */
/*             Size of the buffer;                            */
/*                                                            */
/*             Pointer to the buffer for the title (if any),  */
/*             or NULL;                                       */
/*                                                            */
/*             Size of the buffer (or zero);                  */
/*                                                            */
/*             Pointer to the pathname of the URI file.       */
/*                                                            */
/* Assumes:    The buffers and path must NOT be the same area */
/*             in memory.                                     */
/**************************************************************/

void urlutils_load_uri_file(char * buffer, size_t size, char * tbuffer, size_t tsize, char * path)
{
  urifile_command * commands;

  if (!size) return;
  memset(buffer, 0, size);

  if (tbuffer && tsize) memset(tbuffer, 0, tsize);

  /* Deal with any actual commands first */

  show_error_ret(urifile_parse_uri_file(path, &commands));

  urifile_execute_command_list(commands, 0);

  /* If the first item is command urifile_none, this holds the data */
  /* we should write into the given buffers.                        */

  if (commands->hdr.type == urifile_none)
  {
    if (commands->data.none.url)              strncpy(buffer,  commands->data.none.url,   size  - 1);
    if (commands->data.none.title && tbuffer) strncpy(tbuffer, commands->data.none.title, tsize - 1);
  }

  /* Finished */

  urifile_free_command_list(commands);
}

/**************************************************************/
/* urlutils_extract_uri()                                     */
/*                                                            */
/* Looks at a URI file loaded into a buffer, and overwrites   */
/* it with the URL contents extracted from the body. Will     */
/* also look for command lines in version 1.01 lines, and act */
/* upon them.                                                 */
/*                                                            */
/* Parameters: Pointer to the buffer holding the URI file;    */
/*                                                            */
/*             Size of the file (the buffer is assumed to be  */
/*             at least this size but not assumed to be       */
/*             larger).                                       */
/*                                                            */
/* Returns:    Contents of the buffer are updated to hold a   */
/*             null terminated URI followed by a null         */
/*             terminated title string, if there is one.      */
/**************************************************************/

void urlutils_extract_uri(char * buffer, size_t file_size)
{
  int copy    = 0;
  int counter = 0;
  int is_uri  = 1;

  if (!buffer || !file_size) return;

  /* Ensure it starts with 'URI' - if not, jump straight to */
  /* URI extraction (assume it's a URL file).               */

  if (strncmp(buffer, "URI", 3))
  {
    is_uri = 0;

    goto urlutils_extract_uri_read_uri;
  }

  /* Point to the first byte after the 'URI' indentifier */

  counter = 3;

  /* Skip white space to find the version number */

urlutils_extract_uri_skip_white_space_1:

  while (
          counter < file_size   &&
          buffer[counter]       &&
          buffer[counter] < ' '
        )
        counter++;

  /* If we find a comment, skip the comment body */

  if (buffer[counter] == '#')
  {
    while (
            counter < file_size    &&
            buffer[counter]        &&
            buffer[counter] >= ' '
          )
          counter++;

    /* Now go back to skip the white space after the comment, and */
    /* thus any other comments that follow.                       */

    if (buffer[counter]) goto urlutils_extract_uri_skip_white_space_1;
  }

  /* Skip the file version */

  while (
          counter < file_size    &&
          buffer[counter]        &&
          buffer[counter] >= ' '
        )
        counter++;

  /* Again, skip white space and comments */

urlutils_extract_uri_skip_white_space_2:

  while (
          counter < file_size   &&
          buffer[counter]       &&
          buffer[counter] < ' '
        )
        counter++;

  if (buffer[counter] == '#')
  {
    while (
            counter < file_size    &&
            buffer[counter]        &&
            buffer[counter] >= ' '
          )
          counter++;

    if (buffer[counter]) goto urlutils_extract_uri_skip_white_space_2;
  }

urlutils_extract_uri_read_uri:

  /* Now we're at the URI. Copy it to the start of the buffer. */

  while (
          counter < file_size    &&
          buffer[counter]        &&
          buffer[counter] >= ' '
        )
        buffer[copy++] = buffer[counter++];

  /* Need to make sure that the string is terminated - if we're */
  /* likely to overflow the buffer, we must overwrite the last  */
  /* char with a terminator. You never know, it could be a non- */
  /* essential last character (e.g. trailing '/').              */

  if (copy && copy < file_size) buffer[copy] = 0, copy++;
  else buffer[copy - 1] = 0;

  /* May have a title to read, too. */

  if (is_uri)
  {
    /* Skip white space and comments once more */

urlutils_extract_uri_skip_white_space_3:

    while (
            counter < file_size   &&
            buffer[counter]       &&
            buffer[counter] < ' '
          )
          counter++;

    if (buffer[counter] == '#')
    {
      while (
              counter < file_size    &&
              buffer[counter]        &&
              buffer[counter] >= ' '
            )
            counter++;

      if (buffer[counter]) goto urlutils_extract_uri_skip_white_space_3;
    }

    /* Now read the title */

    while (
            counter < file_size    &&
            buffer[counter]        &&
            buffer[counter] >= ' '
          )
          buffer[copy++] = buffer[counter++];

    /* Again, ensure things are correctly terminated */

    if (copy && copy < file_size) buffer[copy] = 0;
    else buffer[copy - 1] = 0;
  }

  /* If we've ended up with just a single star, the field is blank */

  if (!strcmp(buffer, "*")) *buffer = 0;

  return;
}

/**************************************************************/
/* urlutils_internal_extra()                                  */
/*                                                            */
/* Returns an offset into a given string at which extra data  */
/* in an internal URL may be found.                           */
/*                                                            */
/* Parameters: Pointer to the URL string.                     */
/*                                                            */
/* Returns:    Offset for the extra data, or 0 if none is     */
/*             found.                                         */
/**************************************************************/

int urlutils_internal_extra(char * iurl)
{
  char * extra;

  if (strncmp(iurl, Internal_URL, Int_URL_Len)) return 0;

  extra = strchr(iurl, ':');

  if (!extra) return 0;
  else extra ++;

  return (int) (extra - iurl);
}

/**************************************************************/
/* urlutils_internal_tail()                                   */
/*                                                            */
/* Returns an offset into a given string at which tail data   */
/* (typically a URL leafname) may be found.                   */
/*                                                            */
/* Parameters: Pointer to the URL string.                     */
/*                                                            */
/* Returns:    Offset for the tail data, or 0 if none is      */
/*             found.                                         */
/**************************************************************/

int urlutils_internal_tail(char * iurl)
{
  char * tail, * extra;
  int    exoff, found = 0;

  exoff = urlutils_internal_extra(iurl);

  if (!exoff) return 0;

  extra = iurl + exoff;
  tail  = iurl + strlen(iurl); /* No '-1' here as tail is decremented early in the while loop below */

  while (tail > extra && !found)
  {
    tail--;
    if (*tail == '/') found = 1;
  }

  if (!found) return 0;
  else tail ++;

  return (int) (tail - iurl);
}

/**************************************************************/
/* urlutils_set_displayed()                                   */
/*                                                            */
/* On the basis of a given internal URL, sets the 'displayed' */
/* field of a given browser_data structure.                   */
/*                                                            */
/* Knows also about JavaScript URLs and sets the 'displayed'  */
/* field for those too.                                       */
/*                                                            */
/* Parameters: Pointer to a browser_data struct that is to be */
/*             altered;                                       */
/*                                                            */
/*             Pointer to the internal URL.                   */
/**************************************************************/

void urlutils_set_displayed(browser_data * b, char * iurl)
{
  if (!strncmp(iurl, Internal_URL, Int_URL_Len))
  {
    if      (!strncmp(iurl + Int_URL_Len, ForExternalHImage, strlen(ForExternalHImage))) b->displayed = Display_External_Image;
    else if (!strncmp(iurl + Int_URL_Len, ForExternalNImage, strlen(ForExternalNImage))) b->displayed = Display_External_Image;
    else if (!strncmp(iurl + Int_URL_Len, ForScrapFile,      strlen(ForScrapFile)))      b->displayed = Display_Scrap_File;
    else if (!strncmp(iurl + Int_URL_Len, ForGoBack,         strlen(ForGoBack)))         b->displayed = Display_Previous_Page;
    else if (!strncmp(iurl + Int_URL_Len, ForGoForward,      strlen(ForGoForward)))      b->displayed = Display_Next_Page;
    else if (!strncmp(iurl + Int_URL_Len, ForGoRecover,      strlen(ForGoRecover)))      b->displayed = Display_Recovered_Page;
    else if (!strncmp(iurl + Int_URL_Len, ForGoReload,       strlen(ForGoReload)))       b->displayed = Display_Reloaded_Page;
    else if (!strncmp(iurl + Int_URL_Len, ForGoHome,         strlen(ForGoHome)))         b->displayed = Display_Home_Page;
    else if (!strncmp(iurl + Int_URL_Len, ForAbout,          strlen(ForAbout)))          b->displayed = Display_About_Page;
    else if (!strncmp(iurl + Int_URL_Len, ForGoToURL,        strlen(ForGoToURL)))        b->displayed = Display_Embedded_URL;
    else if (!strncmp(iurl + Int_URL_Len, ForAnError,        strlen(ForAnError)))        b->displayed = Display_Embedded_Error;

    else b->displayed = Display_Fetched_Page;
  }
  else
  {
    #ifdef JAVASCRIPT

      if (javascript_url(iurl)) b->displayed = Display_JavaScript_Info;
      else                      b->displayed = Display_Fetched_Page;

    #else

      b->displayed = Display_Fetched_Page;

    #endif
  }
}

/**************************************************************/
/* urlutils_check_protocols()                                 */
/*                                                            */
/* Checks a given URL to see if the fetch protocol it         */
/* specifies can be handled.                                  */
/*                                                            */
/* Parameters: Pointer to the URL string.                     */
/*                                                            */
/* Returns:    1 if the URL can be handled (i.e. the protocol */
/*             at the start of the URL matches one that the   */
/*             Messages file says a module which is currently */
/*             running copes with), else 0.                   */
/**************************************************************/

int urlutils_check_protocols(char * url)
{
  int          context = 0;
  const char * scheme;

  if (!url || (url && !*url)) return 0;

  /* Don't forget about JavaScript... */

  #ifdef JAVASCRIPT

    if (javascript_url(url)) return 1;

  #endif

  /* Look for a matching protocol */

  while (context != -1)
  {
    if (
         !url_enumerate_schemes(0, &context, &scheme)    &&
         context != -1                                   &&
         !utils_strncasecmp(scheme, url, strlen(scheme))
       )
       return 1;
  }

  /* If we reach here, no protocol was found. */

  return 0;
}

/**************************************************************/
/* urlutils_cycle_protocol()                                  */
/*                                                            */
/* Given a URL, add in the HTTP protocol specifier if none is */
/* already present, or cycle through those in order of        */
/* appearance in the protocols list in Controls.              */
/*                                                            */
/* Parameters: Pointer to the URL string;                     */
/*                                                            */
/*             Size of the buffer the URL string lies in (the */
/*             string will be updated).                       */
/*                                                            */
/* Returns:    1 if the URL was changed, else 0.              */
/**************************************************************/

int urlutils_cycle_protocol(char * url, int size)
{
  int          context  = 0;
  int          have_any = 0;
  int          have_one = 0;
  int          ulen;
  int          plen;
  const char * scheme;

  if (!url || !size) return 0;

  /* Loop round all protocols */

  do
  {
    if (url_enumerate_schemes(0, &context, &scheme)) return 0;

    if (context != -1)
    {
      have_any = 1;

      if (!utils_strncasecmp(scheme, url, strlen(scheme))) have_one = 1;
    }
  }
  while (context != -1 && !have_one);

  if (!have_any)
  {
    /* If we haven't got any available protocols (!) exit */

    return 0;
  }

  /* Assume a protocol ends with "://", and get rid of any */
  /* existing protocol specifier                           */

  {
    char * separator = strstr(url, "://");

    if (separator)
    {
      separator = separator + 3;
      memmove(url, separator, strlen(url) - (((int) separator) - ((int) url)) + 1);
    }
  }

  /* If we didn't recognise the current protocol, start from */
  /* either the first, or if we have it, HTTP.               */

  if (!have_one)
  {
    context = 0;

    do
    {
      if (url_enumerate_schemes(0, &context, &scheme)) return 0;

      if (
           context != -1 &&
           !utils_strncasecmp(scheme, HTTPmethod, strlen(scheme))
         )
         have_one = 1;
    }
    while (context != -1 && !have_one);

    /* No HTTP? Use the first protocol */

    if (!have_one)
    {
      context = 0;

      if (url_enumerate_schemes(0, &context, &scheme)) return 0;
    }
  }
  else
  {
    /* Find the first/next protocol */

    if (url_enumerate_schemes(0, &context, &scheme)) return 0;

    if (context == -1)
    {
      context = 0;
      if (url_enumerate_schemes(0, &context, &scheme)) return 0;
    }
  }

  /* Insert the new protocol */

  ulen = strlen(url);
  plen = strlen(scheme);

  /* (+3 to account for terminator and "//") */

  if (ulen + plen + 3 > size) return have_one; /* Yikes, if it won't fit we may have thrown out an existing protocol... */

  memmove(url + plen + 2, url, ulen + 1);

  strncpy(url, scheme, plen);
  strncpy(url + plen, "//", 2);

  /* Finished */

  return 1;
}

/**************************************************************/
/* urlutils_dispatch()                                        */
/*                                                            */
/* Puts a given URI into the URI queue and sends it out to    */
/* the URI handler.                                           */
/*                                                            */
/* Parameters: Pointer to a browser_data struct for which the */
/*             URI relates;                                   */
/*                                                            */
/*             Pointer to null-terminated URI string (not in  */
/*             a movable block, so not, e.g., in a flex       */
/*             block);                                        */
/*                                                            */
/*             URI queue flags (see URIutils.h).              */
/*                                                            */
/* Assumes:    That the caller has already made sure the URI  */
/*             handler is present.                            */
/**************************************************************/

_kernel_oserror * urlutils_dispatch(browser_data * b, char * uri, unsigned int flags)
{
  _kernel_oserror * e;
  unsigned int      return_code;
  uri_queue       * entry;

  dprintf(("URIH", "urlutils_dispatch: Called for %p with '%s'\n",b,uri));

  /* Claim memory for the new entry */

  entry = malloc(sizeof(uri_queue));

  /* Moan if the claim failed */

  if (!entry)
  {
    dprintf(("URIH", "urlutils_dispatch: Memory claim for queue entry failed\n"));

    return make_no_fetch_memory_error(15);
  }

  #ifdef TRACE
    malloccount += sizeof(uri_queue);
    dprintf(("CMal", "** malloccount (urlutils_dispatch): \0211%d\0217\n",malloccount));
  #endif

  dprintf(("URIH", "urlutils_dispatch: Claimed queue entry %p\n",entry));

  /* Fill in part of the entry */

  entry->flags = flags;
  entry->b     = b;

  /* If there are no entries, set uri_queue_base to the */
  /* address of this one. Otherwise, point this entry's */
  /* 'next' to the current base item, and point that    */
  /* item's 'prev' back to this entry. Then replace the */
  /* current base entry with this new one.              */

  entry->prev = NULL;

  if (!uri_queue_base) entry->next = NULL;
  else
  {
    entry->next          = uri_queue_base;
    uri_queue_base->prev = entry;
  }

  uri_queue_base = entry;

  /* Now call the URI handler and get a handle to fill in */
  /* the last uri_queue field.                            */

  e = uri_dispatch(URI_Dispatch_Action_Inform,
                   uri,
                   task_handle,

                   &return_code,
                   NULL,
                   &entry->uri_handle);

  if (e)
  {
    dprintf(("URIH", "urlutils_dispatch: Exitting with error\n"));

    return e;
  }

  /* If the request was refused complain */

  if (return_code != URI_Dispatch_Request_Accepted)
  {
    erb.errnum = Utils_Error_Custom_Message;
    StrNCpy0(erb.errmess,
             lookup_token("Refused:Cannot fetch this address as the fetch request was refused by the internal handler.",
                          0,0));

    dprintf(("URIH", "urlutils_dispatch: Exitting with error\n"));

    return &erb;
  }

  /* Otherwise exit successfully */

  dprintf(("URIH", "urlutils_dispatch: Successful\n"));

  return NULL;
}

/**************************************************************/
/* urlutils_remove_from_queue()                               */
/*                                                            */
/* Removes a specified entry from the list of uri_queue       */
/* structures, freeing the memory allocated for it.           */
/*                                                            */
/* Parameters: The URI handle of the entry.                   */
/**************************************************************/

_kernel_oserror * urlutils_remove_from_queue(URI_handle_t uri_handle)
{
  uri_queue * entry = uri_queue_base;

  dprintf(("URIH", "urlutils_remove_from_queue: Called with handle %p\n", uri_handle));

  /* Try to find the entry */

  while (entry && entry->uri_handle != uri_handle) entry = entry->next;

  #ifdef TRACE

    /* Complain if not found */

    if (!entry)
    {
      erb.errnum = Utils_Error_Custom_Normal;
      sprintf(erb.errmess, "Can't find URI handle %p in URI queue", uri_handle);

      dprintf(("URI", "urlutils_remove_from_queue: Exitting with error\n"));

      return &erb;
    }

  #else

    /* Fail silently */

    if (!entry) return NULL;

  #endif

  if (entry->prev) entry->prev->next = entry->next;
  if (entry->next) entry->next->prev = entry->prev;

  if (entry == uri_queue_base) uri_queue_base = entry->next;

  #ifdef TRACE
    malloccount -= sizeof(uri_queue);
    dprintf(("CMal", "** malloccount (uriutils_remove_from_queue): \0212%d\0217\n",malloccount));
  #endif

  dprintf(("URIH", "urlutils_remove_from_queue: Freeing entry %p\n",entry));

  free (entry);

  dprintf(("URIH", "urlutils_remove_from_queue: Successful\n"));

  return NULL;
}

/**************************************************************/
/* urlutils_find_queue_entry()                                */
/*                                                            */
/* Finds an entry in the list of uri_queue structures.        */
/*                                                            */
/* Parameters: The URI handle of the entry.                   */
/*                                                            */
/* Returns:    Pointer to the entry, or NULL if no entry with */
/*             that handle could be found.                    */
/**************************************************************/

uri_queue * urlutils_find_queue_entry(URI_handle_t uri_handle)
{
  uri_queue * entry = uri_queue_base;

  dprintf(("URIH", "urlutils_find_queue_entry: Called with handle %p\n", uri_handle));

  while (entry && entry->uri_handle != uri_handle) entry = entry->next;

  dprintf(("URIH", "urlutils_find_queue_entry: Returning with entry %p\n", entry));

  return entry;
}
