/***************************************************/
/* File   : JSwindow.c                             */
/*                                                 */
/* Purpose: JavaScript support - Window objects.   */
/*          Based in part on source in libmocha    */
/*          from the Mozilla browser sources.      */
/*                                                 */
/* Author : A.D.Hodgkinson                         */
/*                                                 */
/* History: 06-May-98: Created.                    */
/***************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "swis.h"

#include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

#include "wimp.h"
#include "wimplib.h"
#include "event.h"

#include "svcprint.h"
#include "Global.h"
#include "FromROSLib.h"
#include "MiscDefs.h"
#include "Utils.h"

#include "Browser.h"
#include "Fetch.h"
#include "FetchPage.h"
#include "Filetypes.h"
#include "Frames.h"
#include "Handlers.h"
#include "History.h"
#include "JavaScript.h"
#include "Memory.h"
#include "Toolbars.h"
#include "URLutils.h"
#include "Windows.h"

#ifdef JAVASCRIPT

  #include "JSconsts.h"
  #include "JSdocument.h"

  #include "JSwindow.h"

  /* Local compilation options: Minimum window width and */
  /* height, in pixels, for window.open().               */

  #define JSWindow_Minimum_Width  100
  #define JSWindow_Minimum_Height 100

  /* Static function prototypes */

  PR_STATIC_CALLBACK(PRBool) jswindow_get_property    (JSContext * cx, JSObject * obj, jsval id, jsval * vp);
  PR_STATIC_CALLBACK(PRBool) jswindow_set_property    (JSContext * cx, JSObject * obj, jsval id, jsval * vp);
  PR_STATIC_CALLBACK(JSBool) jswindow_list_properties (JSContext * cx, JSObject * obj);
  PR_STATIC_CALLBACK(JSBool) jswindow_resolve_name    (JSContext * cx, JSObject * obj, jsval id);
  PR_STATIC_CALLBACK(void)   jswindow_finalise        (JSContext * cx, JSObject * obj);

  PR_STATIC_CALLBACK(PRBool) jswindow_alert           (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_confirm         (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_home            (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_stop            (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_forward         (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_back            (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);
  PR_STATIC_CALLBACK(PRBool) jswindow_open            (JSContext * cx, JSObject * obj, uint argc, jsval * argv, jsval * rval);

  static int                 jswindow_has_option      (char * options, const char * name);
  static int                 jswindow_option_set      (char * options, const char * name);

  static void                jswindow_make_outer_bbox (BBox * size);
  static void                jswindow_make_inner_bbox (BBox * size);
  static void                jswindow_move_bbox       (BBox * size, int x, int y);
  static void                jswindow_convert_to_area (BBox * size);

  /* Window object property IDs */

  enum window_slot
  {
    WIN_LENGTH              = -1,
    WIN_FRAMES              = -2,
    WIN_PARENT              = -3,
    WIN_TOP                 = -4,
    WIN_SELF                = -5,
    WIN_NAME                = -6,
    WIN_STATUS              = -7,
    WIN_DEFAULT_STATUS      = -8,
    WIN_OPENER              = -9,
    WIN_CLOSED              = -10,
    WIN_WIDTH               = -11,
    WIN_HEIGHT              = -12,
    WIN_OUTWIDTH            = -13,
    WIN_OUTHEIGHT           = -14,
    WIN_XPOS                = -15,
    WIN_YPOS                = -16,
    WIN_XOFFSET             = -17,
    WIN_YOFFSET             = -18,
    WIN_SECURE              = -19,
    WIN_LOADING             = -20,
    WIN_FRAMERATE           = -21,
    WIN_OFFSCREEN_BUFFERING = -22
  };

  #define IS_INSECURE_SLOT(s) (WIN_LOADING <= (s) && (s) <= WIN_CLOSED)

  /* Window object property definitions */

  static JSPropertySpec jswindow_properties[] =
  {
    { "length",             WIN_LENGTH,              JSPROP_ENUMERATE | JSPROP_READONLY },
    { "frames",             WIN_FRAMES,              JSPROP_ENUMERATE | JSPROP_READONLY },
    { "parent",             WIN_PARENT,              JSPROP_ENUMERATE | JSPROP_READONLY },
    { "top",                WIN_TOP,                 JSPROP_ENUMERATE | JSPROP_READONLY },
    { "self",               WIN_SELF,                JSPROP_ENUMERATE | JSPROP_READONLY },
    { "window",             WIN_SELF,                JSPROP_READONLY                    },
    { "name",               WIN_NAME,                JSPROP_ENUMERATE                   },
    { "status",             WIN_STATUS,              JSPROP_ENUMERATE                   },
    { "defaultStatus",      WIN_DEFAULT_STATUS,      JSPROP_ENUMERATE                   },
    { lm_opener_str,        WIN_OPENER,              JSPROP_ENUMERATE                   },
    { lm_closed_str,        WIN_CLOSED,              JSPROP_ENUMERATE | JSPROP_READONLY },
    { "innerWidth",         WIN_WIDTH,               JSPROP_ENUMERATE                   },
    { "innerHeight",        WIN_HEIGHT,              JSPROP_ENUMERATE                   },
    { "outerWidth",         WIN_OUTWIDTH,            JSPROP_ENUMERATE                   },
    { "outerHeight",        WIN_OUTHEIGHT,           JSPROP_ENUMERATE                   },
    { "screenX",            WIN_XPOS,                JSPROP_ENUMERATE                   },
    { "screenY",            WIN_YPOS,                JSPROP_ENUMERATE                   },
    { "pageXOffset",        WIN_XOFFSET,             JSPROP_ENUMERATE | JSPROP_READONLY },
    { "pageYOffset",        WIN_YOFFSET,             JSPROP_ENUMERATE | JSPROP_READONLY },
    { "secure",             WIN_SECURE,              JSPROP_ENUMERATE | JSPROP_READONLY },
    { "frameRate",          WIN_FRAMERATE,           JSPROP_ENUMERATE                   },
    { "offscreenBuffering", WIN_OFFSCREEN_BUFFERING, JSPROP_ENUMERATE                   },
    { 0 }
  };

  /* Method table for Window object */

  static JSFunctionSpec jswindow_methods[] =
  {
    { "alert",                  jswindow_alert,                    1 },
//  { "clearTimeout",           jswindow_clear_timeout,            1 },
//  { "clearInterval",          jswindow_clear_timeout,            1 },
//  { "close",                  jswindow_close,                    0 },
    { "confirm",                jswindow_confirm,                  1 },
    { "open",                   jswindow_open,                     1 },
//  { "setZOptions",            jswindow_set_zoptions,             1 },
//  { "setHotkeys",             jswindow_set_hotkeys,              1 },
//  { "setResizable",           jswindow_set_resizable,            1 },
//  { "prompt",                 jswindow_prompt,                   2 },
//  { setTimeout_str,           jswindow_set_timeout,              2 },
//  { setInterval_str,          jswindow_set_interval,             2 },
//  { "delay",                  jswindow_delay,                    0 },
//  { "escape",                 jswindow_escape,                   2 },
//  { "unescape",               jswindow_unescape,                 1 },
//  { lm_blur_str,              jswindow_blur,                     0 },
//  { lm_focus_str,             jswindow_focus,                    0 },
//  { lm_scroll_str,            jswindow_scroll_to,                2 },
//  { "scrollTo",               jswindow_scroll_to,                2 },
//  { "scrollBy",               jswindow_scroll_by,                2 },
//  { "moveTo",                 jswindow_move_to,                  2 },
//  { "moveBy",                 jswindow_move_by,                  2 },
//  { "resizeTo",               jswindow_resize_to,                2 },
//  { "resizeBy",               jswindow_resize_by,                2 },
//  { "captureEvents",          jswindow_capture_events,           1 },
//  { "releaseEvents",          jswindow_release_events,           1 },
//  { "enableExternalCapture",  jswindow_enable_external_capture,  0 },
//  { "disableExternalCapture", jswindow_disable_external_capture, 0 },
//  { "compromisePrincipals",   jswindow_compromise_principals,    0 },
//  { "downgradePrincipals",    jswindow_downgrade_principals,     0 },
    { "back",                   jswindow_back,                     0 },
    { "forward",                jswindow_forward,                  0 },
    { "home",                   jswindow_home,                     0 },
//  { "find",                   jswindow_find,                     0 },
//  { "print",                  jswindow_print,                    0 },
//  { "openFile",               jswindow_open_file,                0 },
    { "stop",                   jswindow_stop,                     0 },
//  { "atob",                   jswindow_atob,                     1 },
//  { "btoa",                   jswindow_btoa,                     1 },
//  { "taint",                  jswindow_taint_stub,               1 },
//  { "untaint",                jswindow_taint_stub,               1 },
    { 0 }
  };

  /* Class description for Window object */

  JSClass jswindow_class =
  {
    "Window", JSCLASS_HAS_PRIVATE,
    JS_PropertyStub,          JS_PropertyStub,        jswindow_get_property, jswindow_set_property,
    jswindow_list_properties, jswindow_resolve_name,  JS_ConvertStub,        jswindow_finalise
  };

  /*************************************************/
  /* jswindow_new_window()                         */
  /*                                               */
  /* Create a new Window object for a given        */
  /* browser. Bring up related objects too.        */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             for which the object is to be     */
  /*             created.                          */
  /*                                               */
  /* Returns:    Pointer to the new object, or     */
  /*             NULL for an error.                */
  /*************************************************/

  JSObject * jswindow_new_window(browser_data * b)
  {
    JSContext * cx;
    JSObject  * obj;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_new_window: Called for %p\n",b);
    #endif

    cx  = b->bcx;

    if (!cx)
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_new_window: \0211Browser has no JSI context!\0217\n");
      #endif

      return JS_FALSE;
    }

    /* Create the object */

    obj = JS_NewObject(cx,
                       &jswindow_class,
                       NULL,
                       NULL);

    if (!obj)
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not create Window object in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    b->window_object = obj;

    /* Add a GC root in case GC runs soon */

    if (
         !JS_AddNamedRoot(cx,
                          &b->window_object,
                          "window_object")
       )
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not add GC roots for Window object in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    /* Set the browser_data structure pointer as private data */

    if (!JS_SetPrivate(cx, obj, b))
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not set private data for Window object in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    /* Initialise standard classes in the Window object */

    if (!JS_InitStandardClasses(cx, obj))
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not initialise standard classes in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    /* Define the properties of the Window object */

    if (!JS_DefineProperties(cx, obj, jswindow_properties))
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not define Window object properties in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    /* Define the functions of the Window object */

    if (
         !JS_DefineFunctions(cx,
                             obj,
                             jswindow_methods)
       )
    {
      #ifdef TRACE

        erb.errnum = Utils_Error_Custom_Normal;

        StrNCpy0(erb.errmess,
                 "Could not define Window object functions in jswindow_new_window()");

        show_error_ret(&erb);

      #endif

      return JS_FALSE;
    }

    /* The 'opener' object is created when window.open is used in a parent */
    /* to open a new window - it points back to that parent.               */

    if (b->opener)
    {
      if (
           !JS_DefinePropertyWithTinyId(cx,
                                        obj,
                                        lm_opener_str,
                                        WIN_OPENER,
                                        OBJECT_TO_JSVAL(b->opener),
                                        NULL,
                                        NULL,
                                        JSPROP_ENUMERATE)
         )
         return JS_FALSE;
    }

    /* Bring up all of the window property classes */

//    JSObject *obj;
//
//    obj = decoder->window_object;
//    return (JSBool)(JS_DefineFunctions(cx, obj, lm_window_methods) &&
//           lm_InitEventClasses(decoder) &&
//           lm_InitDocumentClass(decoder) &&
//           lm_DefineDocument(decoder, LO_DOCUMENT_LAYER_ID) &&
//           lm_DefineHistory(decoder) &&
//           lm_DefineLocation(decoder) &&
//           lm_DefineCrypto(decoder) &&
//           lm_DefineBarClasses(decoder) &&
//           lm_InitLayerClass(decoder) &&
//           lm_InitRectClass(decoder) &&
//           lm_InitImageClass(decoder) &&
//           lm_InitAnchorClass(decoder) &&
//           lm_InitInputClasses(decoder) &&
//           lm_DefinePkcs11(decoder));

//   Round about line 3300 of lm_win.c...
//
//   What about JS_SetPrototype(cx, obj, decoder->event_capturer_prototype); ?

    /* Set up the relevant GC roots */

    #define HOLD(obj) if (!JS_AddNamedRoot(cx, &(obj), #obj)) return NULL

    HOLD(b->anchor_prototype);
    HOLD(b->bar_prototype);
    HOLD(b->document_prototype);
    HOLD(b->event_prototype);
    HOLD(b->event_capturer_prototype);
    HOLD(b->event_receiver_prototype);
    HOLD(b->form_prototype);
    HOLD(b->image_prototype);
    HOLD(b->input_prototype);
    HOLD(b->layer_prototype);
    HOLD(b->option_prototype);
    HOLD(b->rect_prototype);
    HOLD(b->url_prototype);

    HOLD(b->document);
    HOLD(b->history);
    HOLD(b->location);
    HOLD(b->navigator);
    HOLD(b->components);
    HOLD(b->crypto);
    HOLD(b->screen);
    HOLD(b->hardware);
    HOLD(b->pkcs11);

    HOLD(b->event_receiver);
    HOLD(b->opener);

    #undef HOLD

    return obj;
  }

  /*************************************************/
  /* jswindow_destroy_window()                     */
  /*                                               */
  /* Destroy a given browser's Window and related  */
  /* objects.                                      */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             for which the object is to be     */
  /*             created.                          */
  /*************************************************/

  void jswindow_destroy_window(browser_data * b)
  {
    JSContext * cx  = b->bcx;
    JSObject  * obj = b->window_object;

    /* Do we have a JavaScript context? */

    if (!cx)
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_new_window: \0211Browser has no JSI context!\0217\n");
      #endif

      return;
    }

    /* In libmocha, it clears references before removing the GC */
    /* roots just by setting the pointers to NULL.              */

    /* Clear all object prototype refs. */

    b->anchor_prototype         = NULL;
    b->bar_prototype            = NULL;
    b->document_prototype       = NULL;
    b->event_prototype          = NULL;
    b->event_capturer_prototype = NULL;
    b->event_receiver_prototype = NULL;
    b->form_prototype           = NULL;
    b->image_prototype          = NULL;
    b->input_prototype          = NULL;
    b->layer_prototype          = NULL;
    b->option_prototype         = NULL;
    b->rect_prototype           = NULL;
    b->url_prototype            = NULL;

    /* Clear window sub-object refs. */

    if (b->document && obj)
    {
      JSDocument * doc = JS_GetPrivate(cx, obj); /* (JSDocument defined in JSconsts.h) */

      if (doc)
      {
        doc->forms              = NULL;
        doc->links              = NULL;
        doc->anchors            = NULL;
        doc->applets            = NULL;
        doc->embeds             = NULL;
        doc->images             = NULL;
        doc->layers             = NULL;
      }
    }

    b->document                 = NULL;
    b->history                  = NULL;
    b->location                 = NULL;
    b->navigator                = NULL;
    b->components               = NULL;
    b->crypto                   = NULL;
    b->screen                   = NULL;
    b->hardware                 = NULL;
    b->pkcs11                   = NULL;

    /* Drop ad-hoc GC roots, but not opener -- it survives unloads. */

    b->event_receiver           = NULL;

    /* Deal with the Window object specially */

    if (obj)
    {
//    JS_ClearWatchPointsForObject (cx, obj);
      JS_ClearScope                (cx, obj);
    }

    // This is where you'd do a lm_closed_str property with tiny ID?
    // (void) JS_DefinePropertyWithTinyId(cx, obj, lm_closed_str, WIN_CLOSED,
    //                                            JSVAL_FALSE, NULL, NULL,
    //                                            JSPROP_ENUMERATE|JSPROP_READONLY);

    /* Remove GC roots */

    #define DROP(obj) JS_RemoveRoot(cx, &(obj))

    /* Drop all object prototype refs. */

    DROP(b->anchor_prototype);
    DROP(b->bar_prototype);
    DROP(b->document_prototype);
    DROP(b->event_prototype);
    DROP(b->event_capturer_prototype);
    DROP(b->event_receiver_prototype);
    DROP(b->form_prototype);
    DROP(b->image_prototype);
    DROP(b->input_prototype);
    DROP(b->layer_prototype);
    DROP(b->option_prototype);
    DROP(b->rect_prototype);
    DROP(b->url_prototype);

    /* Drop window sub-object refs. */

    DROP(b->document);
    DROP(b->history);
    DROP(b->location);
    DROP(b->navigator);
    DROP(b->components);
    DROP(b->crypto);
    DROP(b->screen);
    DROP(b->hardware);
    DROP(b->pkcs11);

    /* Drop ad-hoc GC roots. */

    DROP(b->event_receiver);
    DROP(b->opener);

    /* Remove the root that holds up the whole window in the decoder world */

    DROP(b->window_object);

    #undef DROP

    // Call JS_DestroyContext here?

    return;
  }

  /*************************************************/
  /* jswindow_get_property()                       */
  /*                                               */
  /* Called when the interpreter is getting the    */
  /* value of a property in a Window object.       */
  /*                                               */
  /* Parameters as standard for an interpreter     */
  /* handler (callback) function.                  */
  /*************************************************/

  PR_STATIC_CALLBACK(PRBool) jswindow_get_property(JSContext * cx, JSObject * obj, jsval id, jsval * vp)
  {
    browser_data * decoder;
    jsint          slot;
    JSString     * str;

    /* Get the decoder (browser) */

//    while (!(decoder = JS_GetInstancePrivate(cx, obj, &jswindow_class, NULL)))
//    {
//      obj = JS_GetPrototype(cx, obj);
//      if (!obj) return JS_TRUE;
//    }

    do
    {
      decoder = JS_GetInstancePrivate(cx,
                                      obj,
                                      &jswindow_class,
                                      NULL);

      if (!decoder)
      {
        obj = JS_GetPrototype(cx, obj);

        if (!obj) return JS_TRUE;
      }
    }
    while (!decoder);

    /* Allow anyone who can address this window to refer to its "window" and  */
    /* "self" properties, because they refer to the window already in hand by */
    /* the accessing script. Useful for layer scripts that 'import window.*'. */

    if (JSVAL_IS_INT(id) && JSVAL_TO_INT(id) == WIN_SELF)
    {
      *vp = OBJECT_TO_JSVAL(decoder->window_object);

      return JS_TRUE;
    }

    slot = JSVAL_IS_INT(id) ? JSVAL_TO_INT(id) : 0;

    // Now do stuff about WIN_CLOSED?

    if (!JSVAL_IS_INT(id)) return JS_TRUE;

    /* Deal with the various properties */

    switch (slot)
    {
      case WIN_LENGTH:
      {
        int length = 0;

        while (frames_find_browser_from_index(decoder, length)) length ++;

        *vp = INT_TO_JSVAL((int) (length - 1));
      }
      break;

      case WIN_FRAMES:
      {
        *vp = OBJECT_TO_JSVAL(decoder->window_object);
      }
      break;

      /* Return either the current Window object, or if we can find */
      /* one, the Window object for the parent.                     */
      /*                                                            */
      /* Navigator only allows a frame to reference a parent that   */
      /* generated it via FRAMESET tags, if that parent generated   */
      /* the whole thing. If the parent loaded a page which itself  */
      /* had a FRAMESET, then that page would be the parent of the  */
      /* frames it loads.                                           */
      /*                                                            */
      /* The way that the internal structures work in this browser  */
      /* means we need to follow 'parent' pointers until we run out */
      /* to correctly copy the Navigator behaviour.                 */

      case WIN_PARENT:
      {
        browser_data * parent;

        /* See if we can find a suitable parent */

        if (decoder->parent)
        {
          parent = utils_flat_parent(decoder);

          *vp = OBJECT_TO_JSVAL(parent->window_object);
        }
        else
        {
          /* The parent of the ancestor Window object is itself */

          *vp = OBJECT_TO_JSVAL(decoder->window_object);
        }
      }
      break;

      case WIN_TOP:
      {
        browser_data * ancestor = utils_ancestor(decoder);

        if (ancestor) *vp = OBJECT_TO_JSVAL(ancestor->window_object);
        else          *vp = OBJECT_TO_JSVAL(decoder->window_object);
      }
      break;

      case WIN_NAME:
      {
        if (decoder->window_name) str = JS_NewString(cx, decoder->window_name, strlen(decoder->window_name));
        else                      str = JS_NewString(cx, "", 0);

        if (!str) return JS_FALSE;

        *vp = STRING_TO_JSVAL(str);
      }
      break;

      case WIN_STATUS:
      {
        return JS_TRUE; /* From LibMocha: 'XXX can't get yet, return last known' */
      }
      break;

      case WIN_DEFAULT_STATUS:
      {
        // To be done

        return JS_TRUE;
      }
      break;

      case WIN_OPENER:
      {
        if (
             !JSVAL_IS_OBJECT(*vp) &&
             !JS_ConvertValue(cx, *vp, JSTYPE_OBJECT, vp)
           )
           return JS_FALSE;
      }
      break;

      case WIN_CLOSED:
      {
        *vp = JSVAL_FALSE;
      }
      break;

      case WIN_WIDTH:
      {
        WimpGetWindowStateBlock   state;
        _kernel_oserror         * e;

        /* Window inner width (visible area), pixels; assume */
        /* 2 OS units to 1 pixel in both directions to mimic */
        /* the perceptual units you see with Navigator under */
        /* Windows.                                          */

        state.window_handle = decoder->window_handle;

        e = wimp_get_window_state(&state);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) ((state.visible_area.xmax - state.visible_area.xmin) / 2));
      }
      break;

      case WIN_HEIGHT:
      {
        WimpGetWindowStateBlock   state;
        _kernel_oserror         * e;

        /* Window inner height (visible area), pixels; assume */
        /* 2 OS units to 1 pixel in both directions to mimic  */
        /* the perceptual units you see with Navigator under  */
        /* Windows.                                           */

        state.window_handle = decoder->window_handle;

        e = wimp_get_window_state(&state);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) ((state.visible_area.ymax - state.visible_area.ymin) / 2));
      }
      break;

      case WIN_OUTWIDTH:
      {
        WimpGetWindowOutlineBlock   outline;
        _kernel_oserror           * e;

        /* Window outer width (window outline), pixels; assume */
        /* 2 OS units to 1 pixel in both directions to mimic   */
        /* the perceptual units you see with Navigator under   */
        /* Windows.                                            */

        outline.window_handle = decoder->window_handle;

        e = wimp_get_window_outline(&outline);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) ((outline.outline.xmax - outline.outline.xmin) / 2));
      }
      break;

      case WIN_OUTHEIGHT:
      {
        WimpGetWindowOutlineBlock   outline;
        _kernel_oserror           * e;

        /* Window outer height (window outline), pixels; assume */
        /* 2 OS units to 1 pixel in both directions to mimic    */
        /* the perceptual units you see with Navigator under    */
        /* Windows.                                             */

        outline.window_handle = decoder->window_handle;

        e = wimp_get_window_outline(&outline);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) ((outline.outline.ymax - outline.outline.ymin) / 2));
      }
      break;

      case WIN_XPOS:
      {
        WimpGetWindowOutlineBlock   outline;
        _kernel_oserror           * e;

        /* Window outline top left X,Y coordinates required here, */
        /* again in pixels. TRHC is meant to be 0,0.              */

        outline.window_handle = decoder->window_handle;

        e = wimp_get_window_outline(&outline);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) (outline.outline.xmin / 2));
      }
      break;

      case WIN_YPOS:
      {
        WimpGetWindowOutlineBlock   outline;
        int                         wf, wl;
        _kernel_oserror           * e;

        /* Window outline top left X,Y coordinates - TRHC is 0,0. */
        /* RISC OS has 0,0 in the *bottom* left so we need to     */
        /* find the screen height out.                            */

        outline.window_handle = decoder->window_handle;

        e = wimp_get_window_outline(&outline);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        wf = bbc_modevar(-1, BBC_YEigFactor);
        wl = bbc_modevar(-1, BBC_YWindLimit);

        wl = (wl + 1) << wf;

        *vp = INT_TO_JSVAL((int) ((wl - outline.outline.ymax) / 2));
      }
      break;

      case WIN_XOFFSET:
      {
        WimpGetWindowStateBlock   state;
        _kernel_oserror         * e;

        /* X scroll offset, in pixels. 0 is fully left. */

        state.window_handle = decoder->window_handle;

        e = wimp_get_window_state(&state);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) (state.xscroll / 2));
      }
      break;

      case WIN_YOFFSET:
      {
        WimpGetWindowStateBlock   state;
        _kernel_oserror         * e;

        /* Y scroll offset, in pixels. 0 is scrolled to the top. */
        /* Other values are positive downwards.                  */

        state.window_handle = decoder->window_handle;

        e = wimp_get_window_state(&state);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        *vp = INT_TO_JSVAL((int) (-state.yscroll / 2));
      }
      break;

      case WIN_SECURE:
      {
        // To be done

        *vp = JSVAL_FALSE;
      }
      break;

      case WIN_LOADING:
      {
        if (fetch_fetching(decoder)) *vp = JSVAL_TRUE;
        else                         *vp = JSVAL_FALSE;
      }
      break;

      case WIN_FRAMERATE:
      {
        // To be done

        *vp = INT_TO_JSVAL(50);
      }
      break;

      case WIN_OFFSCREEN_BUFFERING:
      {
        *vp = JSVAL_FALSE;
      }
      break;

      default:
      {
        browser_data * frame;

        /* Don't mess with user-defined or method properties */

        if (slot < 0) return JS_TRUE;

        frame = frames_find_browser_from_index(decoder, slot);

        if (frame)
        {
          if (frame->window_object) *vp = OBJECT_TO_JSVAL(frame->window_object);
          else                      *vp = JSVAL_NULL;
        }
      }
      break;
    }

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_set_property()                       */
  /*                                               */
  /* Called when the interpreter is setting the    */
  /* value of a property in a Window object.       */
  /*                                               */
  /* Parameters as standard for an interpreter     */
  /* handler (callback) function.                  */
  /*************************************************/

  PR_STATIC_CALLBACK(PRBool) jswindow_set_property(JSContext * cx, JSObject * obj, jsval id, jsval * vp)
  {
    browser_data * decoder;
    jsint          slot;
    jsdouble       size;
    char         * name;

    /* Get the decoder (browser) */

    do
    {
      decoder = JS_GetInstancePrivate(cx,
                                      obj,
                                      &jswindow_class,
                                      NULL);

      if (!decoder)
      {
        obj = JS_GetPrototype(cx, obj);

        if (!obj) return JS_TRUE;
      }
    }
    while (!decoder);

    if (!JSVAL_IS_INT(id))
    {
//        /* Due to the wonderful world of threads we need to know ahead of time if
//         * someone is setting an onMouseMove event handler here or in document so
//         * that we don't lose messages.*/
//        if (JS_TypeOfValue(cx, *vp) == JSTYPE_FUNCTION) {
//            if (JSVAL_IS_STRING(id)) {
//                prop_name = JS_GetStringBytes(JSVAL_TO_STRING(id));
//                /* XXX use lm_onMouseMove_str etc.*/
//                if (XP_STRCMP(prop_name, "onmousemove") == 0 ||
//                    XP_STRCMP(prop_name, "onMouseMove") == 0) {
//                    decoder->window_context->js_drag_enabled = TRUE;
//                }
//            }
//        }
      return JS_TRUE;
    }

    slot = JSVAL_TO_INT(id);

    /* For items which take a string, do the type */
    /* checking and conversion first              */

    switch (slot)
    {
      case WIN_NAME:
      case WIN_STATUS:
      case WIN_DEFAULT_STATUS:
      {
        if (
             !JSVAL_IS_STRING(*vp) &&
             !JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp)
           )
           return JS_FALSE;
      }
      break;
    }

    /* Now handle the actual property setting */

    switch (slot)
    {
      case WIN_NAME:
      {
        _kernel_oserror * e;

        name = JS_GetStringBytes(JSVAL_TO_STRING(*vp));

        if (!name) return JS_FALSE;

        /* Do we already have a name? */

        if (decoder->window_name)
        {
          /* If the decoder is a frame, change its name in */
          /* its parent's scope.                           */

          if (decoder->parent)
          {
            browser_data * parent = utils_parent(decoder);

            JS_DeleteProperty(cx,
                              parent->window_object,
                              decoder->window_name);
          }
        }

        /* Set the new name for the current decoder */

        e = memory_set_chunk_size(decoder, NULL, CK_NAME, strlen(name) + 1);
        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        strcpy(decoder->window_name, name);
      }
      break;

      case WIN_XPOS:
      case WIN_YPOS:
      {
        WimpGetWindowStateBlock     state;
        WimpGetWindowOutlineBlock   outline;
        BBox                        screen;
        _kernel_oserror           * e;
        int                         new_x, new_y, wout, hout, lmarg, tmarg;
        ObjectId                    parent_o;
        ComponentId                 parent_c;

        /* Move the window, but keep it fully within the visible area */

        outline.window_handle = decoder->window_handle;
        state.window_handle   = decoder->window_handle;

        e = wimp_get_window_outline(&outline);
        if (!e) e = wimp_get_window_state(&state);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }

        /* Having got the window details, also find the screen size */

        screen.xmin = bbc_modevar(-1, BBC_XEigFactor);
        screen.ymin = bbc_modevar(-1, BBC_YEigFactor);
        screen.xmax = bbc_modevar(-1, BBC_XWindLimit);
        screen.ymax = bbc_modevar(-1, BBC_YWindLimit);

        screen.xmax = (screen.xmax + 1) << screen.xmin;
        screen.ymax = (screen.ymax + 1) << screen.ymin;

        /* Work out where to move to */

        if (!JS_ValueToNumber(cx, *vp, &size)) return JS_FALSE;

        if (slot == WIN_XPOS)
        {
          new_x = ((int) size) * 2;
          new_y = outline.outline.ymax;
        }
        else if (slot == WIN_YPOS)
        {
          /* 0,0 is *top* left in JavaScript, but bottom left in RISC OS */

          new_y = screen.ymax - (((int) size) * 2);
          new_x = outline.outline.xmin;
        }
        else
        {
          new_x = outline.outline.xmin;
          new_y = outline.outline.ymax;
        }

        /* Get the new outline bounding box */

        wout = outline.outline.xmax - outline.outline.xmin;
        hout = outline.outline.ymax - outline.outline.ymin;

        lmarg = state.visible_area.xmin - outline.outline.xmin;
        tmarg = outline.outline.ymax - state.visible_area.ymax;

        outline.outline.xmin = new_x;
        outline.outline.xmax = new_x + wout;
        outline.outline.ymin = new_y - hout;
        outline.outline.ymax = new_y;

        /* Make sure it is wholly inside the screen display. The ordering */
        /* of tests here makes sure that if the window is simply too big  */
        /* to fit, then the top left hand part will be visible.           */

        if (outline.outline.ymin < 0) outline.outline.ymax -= outline.outline.ymin, outline.outline.ymin = 0;

        if (outline.outline.xmax >= screen.xmax)
        {
          int diff = outline.outline.xmax - screen.xmax;

          outline.outline.xmin -= diff;
          outline.outline.xmax -= diff;
        }

        if (outline.outline.xmin < 0) outline.outline.xmax -= outline.outline.xmin, outline.outline.xmin = 0;

        if (outline.outline.ymax >= screen.ymax)
        {
          int diff = outline.outline.ymax - screen.ymax;

          outline.outline.ymin -= diff;
          outline.outline.ymax -= diff;
        }

        /* From the margins calculated earlier, work out the visible */
        /* area coordinates.                                         */

        state.visible_area.xmin = outline.outline.xmin + lmarg;
        state.visible_area.xmax = outline.outline.xmax + lmarg;

        state.visible_area.ymin = outline.outline.ymin - tmarg;
        state.visible_area.ymax = outline.outline.ymax - tmarg;

        /* Open the window in the new position */

        e = toolbox_get_parent(0, decoder->self_id, &parent_o, &parent_c);

        if (!e) e = toolbox_show_object(0,
                                        decoder->self_id,
                                        Toolbox_ShowObject_FullSpec,
                                        &state.visible_area,
                                        parent_o,
                                        parent_c);

        if (e)
        {
          show_error_ret(e);
          return JS_FALSE;
        }
      }
      break;

      case WIN_OPENER:
      {
        if (decoder->opener && !JSVAL_TO_OBJECT(*vp)) decoder->opener = NULL;
      }
      break;

    }

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_list_properties()                    */
  /*                                               */
  /* Help JavaScript list the properties of a      */
  /* Window object.                                */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* property enumeration callback function.       */
  /*************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_list_properties(JSContext * cx, JSObject * obj)
  {
    browser_data * decoder;
    int            length = 0;
    int            slot;

    decoder = JS_GetPrivate(cx, obj);
    if (!decoder) return JS_TRUE;

    while (frames_find_browser_from_index(decoder, length)) length ++;

    if (length > 1)
    {
      for (slot = 0; slot < length; slot ++)
      {
        browser_data * frame = frames_find_browser_from_index(decoder, slot);

        if (
             !frame ||
             !JS_DefineProperty(cx,
                                decoder->window_object,
                                frame->window_name,
                                JSVAL_NULL,
                                NULL,
                                NULL,
                                JSPROP_ENUMERATE | JSPROP_READONLY)
           )
           return JS_FALSE;
      }
    }

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_resolve_name()                       */
  /*                                               */
  /* Help JavaScript work out what property a      */
  /* script is actually referring to in Window     */
  /* objects.                                      */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* interpreter name resolver callback function.  */
  /*************************************************/

  PR_STATIC_CALLBACK(JSBool) jswindow_resolve_name(JSContext * cx, JSObject * obj, jsval id)
  {
    char         * name = NULL;
    browser_data * decoder;
    browser_data * frame;
    jsint          slot;
    JSObject     * window_obj;

    /* Don't resolve any of names if id is on the left side of an = op. */

    if (JS_IsAssigning(cx))   return JS_TRUE;

    /* Can only resolve names (i.e. must have a string) */

    if (!JSVAL_IS_STRING(id)) return JS_TRUE;

    /* Get the associated browser_data structure and find the name */

    decoder = JS_GetPrivate(cx, obj);
    if (!decoder) return JS_TRUE;

    name = JS_GetStringBytes(JSVAL_TO_STRING(id));
    if (!name) return JS_TRUE;

    /* Get the Window object */

    window_obj = decoder->window_object;

    /* Have we got a frame with this name? */

    frame = frames_find_named_visible_same_index(decoder, name, &slot);

    if (frame)
    {
      /* We found a frame with that name.                */
      /*                                                 */
      /* Add the name as a property of the Window object */
      /* and alias it to Window.                         */

      if (
           !JS_DefinePropertyWithTinyId(cx,
                                        window_obj,
                                        frame->window_name,
                                        (int8) slot,
                                        JSVAL_NULL,
                                        NULL,
                                        NULL,
                                        JSPROP_ENUMERATE | JSPROP_READONLY)
         )
         return JS_FALSE;

      if (
           !JS_AliasElement(cx,
                            window_obj,
                            frame->window_name,
                            slot)
         )
         return JS_FALSE;

      return JS_TRUE;
    }

    /* Didn't find an appropriately named frame; */
    /* try generic Window properties instead.    */

    return jswindow_resolve_window_properties(decoder, obj, id);
  }

  /*************************************************/
  /* jswindow_resolve_window_properties()          */
  /*                                               */
  /* If a property name isn't a frame name, for    */
  /* example, it may refer to other specific       */
  /* object types. Deal with them here.            */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             relevant to the context;          */
  /*                                               */
  /*             Pointer to the Window object in   */
  /*             question;                         */
  /*                                               */
  /*             A jsval encoding the property ID. */
  /*                                               */
  /* Returns:    JS_TRUE if successful, JS_FALSE   */
  /*             if there is an error.             */
  /*************************************************/

  JSBool jswindow_resolve_window_properties(browser_data * decoder, JSObject * obj, jsval id)
  {
    const char * name;
    JSContext  * cx;

    cx = decoder->bcx;

    if (!cx)                  return JS_FALSE;
    if (!JSVAL_IS_STRING(id)) return JS_TRUE;

    name = JS_GetStringBytes(JSVAL_TO_STRING(id));

    if (!strcmp(name, "screen"))
    {
      // No screen object yet
      //
      // return ((JSBool) (lm_DefineScreen(decoder, obj) != NULL));

      return JS_TRUE;
    }

    if (!strcmp(name, "hardware"))
    {
      // No hardware object yet
      //
      // return ((JSBool) (lm_DefineHardware(decoder, obj) != NULL));

      return JS_TRUE;
    }

    if (!strcmp(name, "loading"))
    {
      return JS_DefinePropertyWithTinyId(cx,
                                         obj,
                                         name,
                                         WIN_LOADING,
                                         JSVAL_VOID,
                                         NULL,
                                         NULL,
                                         JSPROP_ENUMERATE);
    }

    /* Is this the Navigator object? */

    if (!strcmp(name, lm_navigator_str))
    {
      /* See if there is a global navigator object yet */

// Argh! Crippled decoder alert!
//
//      if (!lm_crippled_decoder->navigator) {
//          lm_DefinePluginClasses(lm_crippled_decoder);
//          lm_crippled_decoder->navigator = lm_DefineNavigator(lm_crippled_decoder);
//          if (!lm_crippled_decoder->navigator)
//              return JS_FALSE;
//          if (!JS_AddRoot(cx, &lm_crippled_decoder->navigator))
//              return JS_FALSE;
//      }
//
//      /* use the global navigator */
//      decoder->navigator = lm_crippled_decoder->navigator;
//      if (!JS_DefineProperty(cx, obj, lm_navigator_str,
//                             OBJECT_TO_JSVAL(decoder->navigator),
//                             NULL, NULL,
//                             JSPROP_ENUMERATE | JSPROP_READONLY)) {
//          return JS_FALSE;
//      }

      return JS_TRUE;
    }

    /* Is this the Components object? */

    if (!strcmp(name, lm_components_str))
    {
      /* see if there is a global components object yet */

// Double argh! Another crippled decoder alert!
//
//      if (!lm_crippled_decoder->components) {
//          lm_crippled_decoder->components =
//              lm_DefineComponents(lm_crippled_decoder);
//          if (!lm_crippled_decoder->components)
//              return JS_FALSE;
//          if (!JS_AddRoot(cx, &lm_crippled_decoder->components))
//              return JS_FALSE;
//      }
//
//      /* use the global navigator */
//      decoder->components = lm_crippled_decoder->components;
//      if (!JS_DefineProperty(cx, obj, lm_components_str,
//                             OBJECT_TO_JSVAL(decoder->components),
//                             NULL, NULL,
//                             JSPROP_ENUMERATE | JSPROP_READONLY)) {
//          return JS_FALSE;
//      }

      return JS_TRUE;
    }

// Toolbar, navigation bar, etc. stuff here
//
//    return lm_ResolveBar(cx, decoder, name);

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_finalise()                           */
  /*                                               */
  /* Get rid of a Window object.                   */
  /*                                               */
  /* Parameters are as standard for an interpreter */
  /* object finalisation callback function.        */
  /*************************************************/

  PR_STATIC_CALLBACK(void) jswindow_finalise(JSContext * cx, JSObject * obj)
  {
    browser_data * win;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_finalise: Called\n");
    #endif

    win = JS_GetPrivate(cx, obj);

    if (!win)
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_finalise: Can't get URL structure; exitting\n");
      #endif

      return;
    }

    win = JS_GetPrivate(cx, obj);
    if (!win) return;
    else win->window_object = NULL;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_finalise: Successful\n");
    #endif

    return;
  }

  /*************************************************/
  /* jswindow_alert()                              */
  /*                                               */
  /* Implementation of the Window object alert()   */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/

  PR_STATIC_CALLBACK(PRBool) jswindow_alert(JSContext * cx, JSObject * obj,
                                            uint argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    char         * message;
    JSString     * str;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_alert: Called\n");
    #endif

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_alert: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif

      return JS_FALSE;
    }

    /* Get the string we're to display */

    str = JS_ValueToString(cx, argv[0]);

    if (!str)
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_alert: Can't get alert message string\n");
      #endif

      return JS_FALSE;
    }

    /* Convert JSString to pointer to char array */

    message = JS_GetStringBytes(str);

    if (!message || !*message)
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_alert: Can't convert message string to char *\n");
      #endif

      return JS_FALSE;
    }

    /* Report the message */

    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess, message);

    show_error_ret(&erb);

    /* Finished */

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_confirm()                            */
  /*                                               */
  /* Implementation of the Window object confirm() */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/

  PR_STATIC_CALLBACK(PRBool) jswindow_confirm(JSContext * cx, JSObject * obj,
                                             uint argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    char         * message;
    JSString     * str;
    JSBool         result;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_confirm: Called\n");
    #endif

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_confirm: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif

      return JS_FALSE;
    }

    /* Get the string we're to display */

    str = JS_ValueToString(cx, argv[0]);

    if (!str)
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_confirm: Can't get confirm message string\n");
      #endif

      return JS_FALSE;
    }

    /* Convert JSString to pointer to char array */

    message = JS_GetStringBytes(str);

    if (!message || !*message)
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_confirm: Can't convert message string to char *\n");
      #endif

      return JS_FALSE;
    }

    /* Report the message */

    erb.errnum = Utils_Error_Custom_Message;

    StrNCpy0(erb.errmess, message);

    if (
         show_error_ask(&erb,
                        "JSErr3:OK,Cancel")
         != 3
       )
       result = JS_FALSE;

    else result = JS_TRUE;

    /* Return the result */

    *rval = BOOLEAN_TO_JSVAL(result);

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_home()                               */
  /*                                               */
  /* Implementation of the Window object home()    */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/

  PR_STATIC_CALLBACK(PRBool) jswindow_home(JSContext * cx, JSObject * obj,
                                           uint argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    IdBlock        id;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_home: Called\n");
    #endif

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_home: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif

      return JS_FALSE;
    }

    /* Build an ID block to make it look like an event */
    /* came from this window                           */

    id.ancestor_id        = b->self_id;
    id.ancestor_component = NULL_ComponentId;
    id.parent_id          = NULL_ObjectId;
    id.parent_component   = NULL_ComponentId;
    id.self_id            = toolbars_get_upper(b);
    id.self_component     = ButtonBarHome;

    handle_home(0, NULL, &id, NULL);

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_stop()                               */
  /*                                               */
  /* Implementation of the Window object stop()    */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/

  PR_STATIC_CALLBACK(PRBool) jswindow_stop(JSContext * cx, JSObject * obj,
                                           uint argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    IdBlock        id;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_stop: Called\n");
    #endif

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_stop: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif

      return JS_FALSE;
    }

    /* Build an ID block to make it look like an event */
    /* came from this window                           */

    id.ancestor_id        = b->self_id;
    id.ancestor_component = NULL_ComponentId;
    id.parent_id          = NULL_ObjectId;
    id.parent_component   = NULL_ComponentId;
    id.self_id            = toolbars_get_upper(b);
    id.self_component     = ButtonBarHome;

    handle_stop(0, NULL, &id, NULL);

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_forward()                            */
  /*                                               */
  /* Implementation of the Window object forward() */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/

  PR_STATIC_CALLBACK(PRBool) jswindow_forward(JSContext * cx, JSObject * obj,
                                              uint argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    IdBlock        id;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_forward: Called\n");
    #endif

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_forward: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif

      return JS_FALSE;
    }

    /* Build an ID block to make it look like an event */
    /* came from this window                           */

    id.ancestor_id        = b->self_id;
    id.ancestor_component = NULL_ComponentId;
    id.parent_id          = NULL_ObjectId;
    id.parent_component   = NULL_ComponentId;
    id.self_id            = toolbars_get_upper(b);
    id.self_component     = ButtonBarHome;

    handle_forwards(0, NULL, &id, NULL);

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_back()                               */
  /*                                               */
  /* Implementation of the Window object back()    */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/

  PR_STATIC_CALLBACK(PRBool) jswindow_back(JSContext * cx, JSObject * obj,
                                           uint argc, jsval * argv, jsval * rval)
  {
    browser_data * b;
    IdBlock        id;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_back: Called\n");
    #endif

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    b = JS_GetInstancePrivate(cx,
                              obj,
                              &jswindow_class,
                              argv);

    if (!is_known_browser(b))
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_back: Can't get valid browser_data address (received 0x%08x)\n", (int) b);
      #endif

      return JS_FALSE;
    }

    /* Build an ID block to make it look like an event */
    /* came from this window                           */

    id.ancestor_id        = b->self_id;
    id.ancestor_component = NULL_ComponentId;
    id.parent_id          = NULL_ObjectId;
    id.parent_component   = NULL_ComponentId;
    id.self_id            = toolbars_get_upper(b);
    id.self_component     = ButtonBarHome;

    handle_back(0, NULL, &id, NULL);

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_open()                               */
  /*                                               */
  /* Implementation of the Window object open()    */
  /* method.                                       */
  /*                                               */
  /* Parameters are as standard for a JavaScript   */
  /* method implementation.                        */
  /*************************************************/

  PR_STATIC_CALLBACK(PRBool) jswindow_open(JSContext * cx, JSObject * obj,
                                           uint argc, jsval * argv, jsval * rval)
  {
    _kernel_oserror * e;
    browser_data    * decoder;
    browser_data    * new_decoder;
    url_description * url_struct;
    char            * url_string   = "";
    const char      * url_relative = "";
    JSString        * str;
    JSString        * window_name_str;
    char            * window_name;
    char            * options;
    BBox              size;
    int               x, y;
    int               size_set     = 0;
    browser_data    * found;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("jswindow_open: Called\n");
    #endif

    /* Get the browser_data structure pointer, which was associated */
    /* as private data to the Window object at creation time        */

    decoder = JS_GetInstancePrivate(cx,
                                    obj,
                                    &jswindow_class,
                                    argv);

    if (!is_known_browser(decoder))
    {
      #ifdef TRACE
        if (tl & (1u<<24)) Printf("jswindow_open: Can't get valid browser_data address (received 0x%08x)\n", (int) decoder);
      #endif

      *rval = JSVAL_NULL;
      return JS_TRUE;
    }

    /* Make url_string absolute based on current document's base URL. */

    if (argc > 0)
    {
      const char * base;

      str = JS_ValueToString(cx, argv[0]);

      if (!str)
      {
        *rval = JSVAL_NULL;
        return JS_TRUE;
      }

      url_string = JS_GetStringBytes(str);

      if (!url_string)
      {
        *rval = JSVAL_NULL;
        return JS_TRUE;
      }

      /* Find the document base URL */

      base = browser_base_url(decoder);
      if (!base) base = url_string;

      /* Return a descriptor for the given URL, thereby ensuring */
      /* it is well formed.                                      */

      url_struct = urlutils_return_description(url_string);

      if (!url_struct)
      {
        *rval = JSVAL_NULL;
        return JS_TRUE;
      }
      else
      {
        urlutils_free_description(url_struct);
      }

      /* Relativise the URL to the document base location */

      url_relative = HtmlRelativiseURL(base, url_string, decoder->stream);
      if (!url_relative)
      {
        *rval = JSVAL_NULL;
        return JS_TRUE;
      }
    }

    /* Set this to null so we can goto fail from here onward. */

    new_decoder = NULL;

    /* Sanity-check the optional window_name argument. */

    if (argc > 1)
    {
      window_name_str = JS_ValueToString(cx, argv[1]);

      if (!window_name_str)                     goto fail;
      if (!JS_LockGCThing(cx, window_name_str)) goto fail;

      window_name = JS_GetStringBytes(window_name_str);
    }
    else
    {
      window_name_str = NULL;
      window_name     = NULL;
    }

    /* There are some things we have to find out from the options */
    /* list before we open the window.                            */

    if (argc > 2)
    {
      str = JS_ValueToString(cx, argv[2]);

      if (!str) goto fail;

      options = JS_GetStringBytes(str);
    }
    else options = "";

    /* Read various options before the window opens */

    if (argc > 2)
    {
      /* Deal with size specifiers. Here, we must have both a */
      /* width and height for the inner or outer size for     */
      /* anything to change.                                  */

      if (
           (
             jswindow_option_set(options, "innerWidth") ||
             jswindow_option_set(options, "width")
           )
           &&
           (
             jswindow_option_set(options, "innerHeight") ||
             jswindow_option_set(options, "height")
           )
         )
      {
        size.xmin = jswindow_has_option(options, "innerWidth") |
                    jswindow_has_option(options, "width");

        size.ymin = jswindow_has_option(options, "innerHeight") |
                    jswindow_has_option(options, "height");

        jswindow_make_inner_bbox(&size);

        size_set = 1;
      }

      /* Since there's no analogue to the Navigator window where the  */
      /* outer width is set independently of the inner - you just get */
      /* huge resize borders around the edge - under RISC OS we have  */
      /* the problem of which should override. Since the inner width  */
      /* is critical to the page layout, we'll let inner width come   */
      /* before outer. Hence the outer width case is in the 'else',   */
      /* rather than the other way around.                            */

      else
      {
        if (
             jswindow_option_set(options, "outerWidth") &&
             jswindow_option_set(options, "outerHeight")
           )
        {
          size.xmin = jswindow_has_option(options, "outerWidth");
          size.ymin = jswindow_has_option(options, "outerHeight");

          jswindow_make_outer_bbox(&size);

          size_set = 1;
        }
      }

      /* If either an X or Y coordinate is set, move the window. The */
      /* other defaults to 0 if not specified.                       */

      if (
           jswindow_option_set(options, "screenX") ||
           jswindow_option_set(options, "screenY")
         )
      {
        x = jswindow_has_option(options, "screenX");
        y = jswindow_has_option(options, "screenY");

        /* We may not have specified a size */

        if (!size_set)
        {
          size.xmin = choices.width  / 2;
          size.ymin = choices.height / 2;

          jswindow_make_inner_bbox(&size);

          size_set = 1;
        }

        jswindow_move_bbox(&size, x, y);
      }
    }

    /* If we've set the window size and/or position, */
    /* make sure the bounding box is converted from  */
    /* outline to visible area coordinates.          */

    if (size_set) jswindow_convert_to_area(&size);

    /* Is there a window of the same name already? */

    found = last_browser;

    while (found)
    {
      if (
           !found->ancestor                         &&
           window_name                              &&
           found->window_name                       &&
           !strcmp(window_name, found->window_name)
         )
         break;

      found = found->previous;
    }

    /* If we found a window, close it (and recreate it in passing) */

    if (found)
    {
      /* Try to preserve the top left hand X and Y coordinates */
      /* if they were not specified in the options string      */

      if (
           !jswindow_option_set(options, "screenX") &&
           !jswindow_option_set(options, "screenY")
         )
      {
        WimpGetWindowOutlineBlock outline;
        int                       th, hh, vw;
        int                       w, h;

        windows_return_tool_sizes(&th, &hh, &vw);

        w = size.xmax - size.xmin;
        h = size.ymax - size.ymin;

        outline.window_handle = found->window_handle;

        if (!wimp_get_window_outline(&outline))
        {
          size.xmin = outline.outline.xmin + wimpt_dx();
          size.xmax = size.xmin + w;
          size.ymax = outline.outline.ymax - th;
          size.ymin = size.ymax - h;
        }
      }

      handle_close_browser(0, NULL, NULL, found);
    }

    /* Create the window */

    e = windows_create_browser(url_relative,
                               decoder,
                               ((size_set) ? &size : NULL),
                               window_name,
                               Windows_CreateBrowser_AsJSChild);

    if (e)
    {
      show_error_ret(e);

      *rval = JSVAL_NULL;
      return JS_TRUE;
    }
    else
    {
      new_decoder = last_browser;
    }

    /* Deal with specific options on the window that */
    /* are useful after the window has been created  */

    if (argc > 2)
    {
      /* Toolbar options */

      new_decoder->button_bar = !!jswindow_has_option(options, "toolbar");
      new_decoder->url_bar    = !!jswindow_has_option(options, "location");
      new_decoder->status_bar = !!jswindow_has_option(options, "status");

      // directories, personalbar, menubar have no equivalent in Browse yet

      toolbars_set_presence(new_decoder, InternalTopLeft);
      toolbars_set_presence(new_decoder, InternalBottomLeft);

//      chrome->show_scrollbar         = win_has_option(options, "scrollbars");
//      chrome->allow_resize           = win_has_option(options, "resizable");
//      chrome->allow_close            = TRUE;
//      chrome->dependent              = win_has_option(options, "dependent");
//      chrome->copy_history           = FALSE; /* XXX need strong trust */
//      chrome->topmost         = win_has_option(options, "alwaysRaised");
//      chrome->bottommost              = win_has_option(options, "alwaysLowered");
//      chrome->z_lock          = win_has_option(options, "z-lock");
//      chrome->is_modal            = win_has_option(options, "modal");
//      chrome->hide_title_bar  = !(win_has_option(options, "titlebar"));
//
//      /* Allow disabling of commands only if there is no menubar */
//      if (!chrome->show_menu) {
//          chrome->disable_commands = !win_has_option(options, "hotkeys");
//          if (XP_STRCASESTR(options,"hotkeys")==NULL)
//              chrome->disable_commands = FALSE;
//      }
//      /* If titlebar condition not specified, default to shown */
//      if (XP_STRCASESTR(options,"titlebar")==0)
//          chrome->hide_title_bar=FALSE;
//
//      if (chrome->topmost || chrome->bottommost ||
//          chrome->z_lock || chrome->is_modal ||
//          chrome->hide_title_bar || chrome->disable_commands) {
//          if (!lm_CanAccessTarget(cx, JSTARGET_UNIVERSAL_BROWSER_WRITE)) {
//              chrome->topmost = chrome->bottommost =
//              chrome->z_lock = chrome->is_modal =
//              chrome->hide_title_bar = chrome->disable_commands = 0;
//          }
//      }
//
//      /* In order to not start Java for every single window open we
//       * have to first check if we need to check, and then check.
//       * Start by getting width and height to use for positioning
//       * calculations. Defaults to 100 if neither are specified.
//       * Then get screen size.
//       */
//
//      win_width = chrome->w_hint ? chrome->w_hint :
//          (chrome->outw_hint ? chrome->outw_hint : 100);
//      win_height = chrome->h_hint ? chrome->h_hint :
//          (chrome->outh_hint ? chrome->outh_hint : 100);
//      ET_PostGetScreenSize(decoder->window_context, &width, &height);
//      if ((chrome->w_hint && chrome->w_hint < 100) ||
//          (chrome->h_hint && chrome->h_hint < 100) ||
//          (chrome->outw_hint && chrome->outw_hint < 100) ||
//          (chrome->outh_hint && chrome->outh_hint < 100) ||
//          (width < chrome->l_hint + win_width) ||
//          (chrome->l_hint < 0) ||
//          (height < chrome->t_hint + win_height) ||
//          (chrome->t_hint < 0)) {
//          /* The window is trying to put a window offscreen or make it too
//           * small.  We have to check the security permissions
//           */
//          if (!lm_CanAccessTarget(cx, JSTARGET_UNIVERSAL_BROWSER_WRITE)) {
//              /* Make sure windows are at least 100 by 100 pixels. */
//              if (chrome->w_hint && chrome->w_hint < 100) {
//          chrome->w_hint = 100;
//          win_width = 100;
//      }
//              if (chrome->h_hint && chrome->h_hint < 100) {
//          chrome->h_hint = 100;
//          win_height = 100;
//      }
//              if (chrome->outw_hint && chrome->outw_hint < 100) {
//          chrome->outw_hint = 100;
//          win_width = 100;
//      }
//              if (chrome->outh_hint && chrome->outh_hint < 100) {
//          chrome->outh_hint = 100;
//          win_height = 100;
//      }
//              /* Windows must be positioned on screen without security */
//              chrome->l_hint = (width < chrome->l_hint + win_width) ?
//                                  width - win_width : chrome->l_hint;
//              chrome->l_hint = (chrome->l_hint < 0) ? 0 : chrome->l_hint;
//              chrome->t_hint = (height < chrome->t_hint + win_height) ?
//                                  height - win_height : chrome->t_hint;
//              chrome->t_hint = (chrome->t_hint < 0) ? 0 : chrome->t_hint;
//          }
//      }
//
//      /* Make sure they always at least 10 x 10 regardless of security. 1 x 1
//       * windows are really hard to spot */
//      if (chrome->w_hint && chrome->w_hint < 10) chrome->w_hint = 10;
//      if (chrome->h_hint && chrome->h_hint < 10) chrome->h_hint = 10;
//      if (chrome->outw_hint && chrome->outw_hint < 10) chrome->outw_hint = 10;
//      if (chrome->outh_hint && chrome->outh_hint < 10) chrome->outh_hint = 10;
//
//      /* You must specify both width and height to get either */
//      if (chrome->w_hint == 0 || chrome->h_hint == 0)
//          chrome->w_hint = chrome->h_hint = 0;
//      if (chrome->outw_hint == 0 || chrome->outh_hint == 0)
//          chrome->outw_hint = chrome->outh_hint = 0;
//
//      /* Needed to allow positioning of windows at 0,0 */
//      if ((XP_STRCASESTR(options,"top") || XP_STRCASESTR(options,"left") ||
//                  XP_STRCASESTR(options,"screenX") || XP_STRCASESTR(options,"screenY")) != 0)
//          chrome->location_is_chrome=TRUE;
//
//      options = 0;
    }
//    else
//    {
//      /* Make a fully chromed window, but don't copy history. */
//      chrome->show_button_bar         = TRUE;
//      chrome->show_url_bar            = TRUE;
//      chrome->show_directory_buttons  = TRUE;
//      chrome->show_bottom_status_bar  = TRUE;
//      chrome->show_menu               = TRUE;
//      chrome->show_security_bar       = FALSE;
//      chrome->w_hint = chrome->h_hint = 0;
//      chrome->is_modal                = FALSE;
//      chrome->show_scrollbar          = TRUE;
//      chrome->allow_resize            = TRUE;
//      chrome->allow_close             = TRUE;
//      chrome->copy_history            = FALSE; /* XXX need strong trust */
//    }
//
//    /* Windows created by JS cannot be randomly used by Mail/News */
//    chrome->restricted_target = TRUE;
//
//    old_context = decoder->window_context;
//    if (!old_context) goto fail;
//
//    if (window_name)
//        context = XP_FindNamedContextInList(old_context, (char*)window_name);
//    else
//        context = NULL;
//
//    if (context) {
//        new_decoder = LM_GetMochaDecoder(context);
//        if (!new_decoder)
//            goto fail;
//        if (url_struct && !lm_GetURL(cx, new_decoder, url_struct)) {
//            url_struct = 0;
//            goto fail;
//        }
//        /* lm_GetURL() stashed a url_struct pointer, and owns it now. */
//        url_struct = 0;
//
//    /* If specific options are specified we will update the named
//     * window to match those options.  If not, we won't change them */
//    if (argc > 2)
//        ET_PostUpdateChrome(context, chrome);
//    } else {
//        if (lm_window_count >= lm_window_limit)
//            goto fail;
//        context = ET_PostNewWindow(old_context, url_struct,
//                                   (char*)window_name,
//                                   chrome);
//        if (!context)
//            goto fail;
//        /* ET_PostNewWindow() stashed a url_struct pointer, and owns it now. */
//        url_struct = 0;
//        new_decoder = LM_GetMochaDecoder(context);
//        if (!new_decoder) {
//            (void) ET_PostDestroyWindow(context);
//            goto fail;
//        }
//    }
//
    /* Set up the given object as the opener */

    new_decoder->opener = obj;

    if (
         !JS_DefinePropertyWithTinyId(cx,
                                      new_decoder->window_object,
                                      lm_opener_str,
                                      WIN_OPENER,
                                      OBJECT_TO_JSVAL(obj),
                                      NULL,
                                      NULL,
                                      JSPROP_ENUMERATE)
       )
       goto fail;

    JS_UnlockGCThing(cx, window_name_str);

//    new_decoder->in_window_quota = JS_TRUE;
//
//    lm_window_count++;
//    LM_PutMochaDecoder(new_decoder);

    *rval = OBJECT_TO_JSVAL(new_decoder->window_object);

//    XP_FREE(chrome);
//    XP_FREEIF(window_name);

    return JS_TRUE;

fail:

    if (window_name_str) JS_UnlockGCThing(cx, window_name_str);
    if (new_decoder)     handle_close_browser(0, NULL, NULL, new_decoder);

    *rval = JSVAL_NULL;

    return JS_TRUE;
  }

  /*************************************************/
  /* jswindow_has_option()                         */
  /*                                               */
  /* In a string as would be passed to for example */
  /* the JavaScript window.open() method, return   */
  /* the value associated with the given named     */
  /* entry in the given option string.             */
  /*                                               */
  /* Parameters: Pointer to the options string,    */
  /*             which will be written to during   */
  /*             the operation of the function     */
  /*             though it'll be overall unchanged */
  /*             when the function exits;          */
  /*                                               */
  /*             Pointer to the name to find the   */
  /*             associated value of.              */
  /*                                               */
  /* Returns:    Value (or '1' for 'yes'), with    */
  /*             '0' returned if the item is not   */
  /*             found, its associated value is    */
  /*             malformed for 'atoi()', or its    */
  /*             associated value is actually 0!   */
  /*************************************************/

  static int jswindow_has_option(char * options, const char * name)
  {
    char * comma;
    char * equal;
    int    found = 0;

    for (;;)
    {
      /* Find a name or value separator and force a terminator */
      /* there for string comparison purposes.                 */

      comma = strchr(options, ',');
      if (comma) *comma = '\0';

      equal = strchr(options, '=');
      if (equal) *equal = '\0';

      /* Do we have a match for the name? */

      if (utils_strcasecmp(options, name) == 0)
      {
        /* Yes. If the option says 'yes' return 1, else try to */
        /* termine the value of the argument associated with   */
        /* the name.                                           */

        if (!equal || utils_strcasecmp(equal + 1, "yes") == 0) found = 1;
        else                                                   found = atoi(equal + 1);
      }

      /* Put back any characters we wrote over */

      if (equal) *equal = '=';
      if (comma) *comma = ',';

      /* If we found something or have run out of items, exit */

      if (found || !comma) break;

      /* Otherwise, try the next item */

      options = comma + 1;
    }

    return found;
  }

  /*************************************************/
  /* jswindow_option_set()                         */
  /*                                               */
  /* In a string as would be passed to for example */
  /* the JavaScript window.open() method, return   */
  /* 1 if a given option is present, else 0.       */
  /*                                               */
  /* Parameters: Pointer to the options string,    */
  /*             which will be written to during   */
  /*             the operation of the function     */
  /*             though it'll be overall unchanged */
  /*             when the function exits;          */
  /*                                               */
  /*             Pointer to the name to find the   */
  /*             associated value of.              */
  /*                                               */
  /* Returns:    1 if option is found, else 0.     */
  /*************************************************/

  static int jswindow_option_set(char * options, const char * name)
  {
    char * comma;
    char * equal;
    int    found = 0;

    for (;;)
    {
      /* Find a name or value separator and force a terminator */
      /* there for string comparison purposes.                 */

      comma = strchr(options, ',');
      if (comma) *comma = '\0';

      equal = strchr(options, '=');
      if (equal) *equal = '\0';

      /* Do we have a match for the name? */

      if (utils_strcasecmp(options, name) == 0)
      {
        found =  1;
      }

      /* Put back any characters we wrote over */

      if (equal) *equal = '=';
      if (comma) *comma = ',';

      /* If we found something or have run out of items, exit */

      if (found || !comma) break;

      /* Otherwise, try the next item */

      options = comma + 1;
    }

    return found;
  }

  /*************************************************/
  /* jswindow_make_outer_bbox()                    */
  /*                                               */
  /* Based on a width and height, construct a      */
  /* bounding box describing a window outline      */
  /* based on the assumption that the given        */
  /* values were pixel sizes for the intended      */
  /* outer window width and height. The window     */
  /* will be centred on screen.                    */
  /*                                               */
  /* If you want to pass this bounding box on to   */
  /* something like windows_create_browser, run it */
  /* through jswindow_convert_to_area.             */
  /*                                               */
  /* The width and height are not allowed to drop  */
  /* below JSWindow_Minimum_Width and              */
  /* JSWindow_Minimum_Height (see top of file).    */
  /*                                               */
  /* Parameters: Pointer to a BBox with the xmin   */
  /*             and ymin fields filled in with    */
  /*             the pixel width and height        */
  /*             respectively - a 1 pixel to 2 OS  */
  /*             unit mapping is assumed in both   */
  /*             directions.                       */
  /*************************************************/

  static void jswindow_make_outer_bbox(BBox * size)
  {
    BBox screen;
    int  w, h;

    if (size->xmin < 100) size->xmin = JSWindow_Minimum_Width;
    if (size->ymin < 100) size->ymin = JSWindow_Minimum_Height;

    /* Get the available screen X and Y size */

    screen.xmin = bbc_modevar(-1, BBC_XEigFactor);
    screen.ymin = bbc_modevar(-1, BBC_YEigFactor);
    screen.xmax = bbc_modevar(-1, BBC_XWindLimit);
    screen.ymax = bbc_modevar(-1, BBC_YWindLimit);

    screen.xmax = (screen.xmax + 1) << screen.xmin;
    screen.ymax = (screen.ymax + 1) << screen.ymin;

    /* Convert the given values to OS units */

    size->xmin *= 2;
    size->ymin *= 2;

    w = size->xmin;
    h = size->ymin;

    /* Work out the final BBox */

    size->xmin = (screen.xmax - w) / 2;
    size->ymin = (screen.ymax - h) / 2;
    size->xmax = size->xmin + w;
    size->ymax = size->ymin + h;

    return;
  }

  /*************************************************/
  /* jswindow_make_inner_bbox()                    */
  /*                                               */
  /* Based on a width and height, construct a      */
  /* bounding box describing a window outline      */
  /* based on the assumption that the given        */
  /* values were pixel sizes for the intended      */
  /* inner window width and height. The window     */
  /* will be centred on screen.                    */
  /*                                               */
  /* If you want to pass this bounding box on to   */
  /* something like windows_create_browser, run it */
  /* through jswindow_convert_to_area.             */
  /*                                               */
  /* The width and height are not allowed to drop  */
  /* below JSWindow_Minimum_Width and              */
  /* JSWindow_Minimum_Height (see top of file).    */
  /*                                               */
  /* Parameters: Pointer to a BBox with the xmin   */
  /*             and ymin fields filled in with    */
  /*             the pixel width and height        */
  /*             respectively - a 1 pixel to 2 OS  */
  /*             unit mapping is assumed in both   */
  /*             directions.                       */
  /*************************************************/

  static void jswindow_make_inner_bbox(BBox * size)
  {
    int th, hh, vw;

    /* Work out the final BBox as if it were the outer edge */

    jswindow_make_outer_bbox(size);

    /* Account for the left hand window edge */

    size->xmin -= wimpt_dx();

    /* Account for the title, lower and right hand scroll bars */

    windows_return_tool_sizes(&th, &hh, &vw);

    size->xmax += vw;
    size->ymax += th;
    size->ymin -= hh;

    return;
  }

  /*************************************************/
  /* jswindow_move_bbox()                          */
  /*                                               */
  /* Given a bounding box and X and Y absolute     */
  /* coordinates in pixels, move the box assuming  */
  /* it describes the outer outline of a window.   */
  /* Don't allow any window edge off-screen.       */
  /*                                               */
  /* Parameters: Pointer to a BBox filled in with  */
  /*             the coordinates describing a      */
  /*             window outline;                   */
  /*                                               */
  /*             X coordinate to move to in pixels */
  /*             - a 1 pixel to 2 OS unit mapping  */
  /*             is assumed (0 places the left     */
  /*             hand window edge at the far left  */
  /*             of the screen);                   */
  /*                                               */
  /*             Y coordinate to move to in pixels */
  /*             - again, a 1 pixel to 2 OS unit   */
  /*             mapping is assumed (0 places the  */
  /*             upper window edge at the top of   */
  /*             the screen).                      */
  /*************************************************/

  static void jswindow_move_bbox(BBox * size, int x, int y)
  {
    BBox screen;
    int  w, h;

    /* Get the available screen X and Y size */

    screen.xmin = bbc_modevar(-1, BBC_XEigFactor);
    screen.ymin = bbc_modevar(-1, BBC_YEigFactor);
    screen.xmax = bbc_modevar(-1, BBC_XWindLimit);
    screen.ymax = bbc_modevar(-1, BBC_YWindLimit);

    screen.xmax = (screen.xmax + 1) << screen.xmin;
    screen.ymax = (screen.ymax + 1) << screen.ymin;

    /* Convert the given values to OS units; */
    /* get the window width and height.      */

    x *= 2;

    w = size->xmax - size->xmin;
    h = size->ymax - size->ymin;

    y = screen.ymax - y * 2;

    /* First check to see if we'd end up hanging off the right */
    /* hand edge of the screen and shift left if so            */

    if (x + w > screen.xmax) size->xmax = screen.xmax, size->xmin = size->xmax - w;
    else                     size->xmax = x + w,       size->xmin = x;

    /* We may have ended up too far left (if the window is wider */
    /* that the screen). If so, push back again so the left hand */
    /* window edge abuts the left hand screen edge.              */

    if (size->xmin < 0) size->xmin = 0, size->xmax = w;

    /* In a similar manner to the X coordinate, we want to end up */
    /* with the top of the window visible if it is taller than    */
    /* the screen.                                                */

    if (y > screen.xmax) size->ymax = screen.ymax, size->ymin = size->ymax - h;
    else                 size->ymax = y,           size->ymin = y - h;

    if (size->xmin < 0) size->xmin = 0, size->xmax = w;

    return;
  }

  /*************************************************/
  /* jswindow_convert_to_area()                    */
  /*                                               */
  /* Convert a window outline bounding box to a    */
  /* window visible area bounding box, so it can   */
  /* e.g. be passed on to windows_create_browser.  */
  /*                                               */
  /* Parameters: Pointer to the BBox to convert.   */
  /*************************************************/

  static void jswindow_convert_to_area(BBox * size)
  {
    int th, hh, vw;

    /* Account for the left hand window edge */

    size->xmin += wimpt_dx();

    /* Account for the title, lower and right hand scroll bars */

    windows_return_tool_sizes(&th, &hh, &vw);

    size->xmax -= vw;
    size->ymax -= th;
    size->ymin += hh;

    return;
  }

#endif
