/***************************************************/
/* File   : LineOne.c                              */
/* Purpose: LineOne JavaScript hack                */
/* Author : A.D.Hodgkinson                         */
/* History: 24-Jul-97: Created                     */
/***************************************************/

#ifdef HACK_LINEONE

  #include <stdlib.h>
  #include <stdio.h>
  #include <string.h>

  #include "swis.h"

  #include "HTMLLib.h" /* HTML library API, Which will include html2_ext.h, tags.h and struct.h */

  #include "wimp.h"
  #include "wimplib.h"
  #include "event.h"

  #include "svcprint.h"
  #include "Global.h"
  #include "Utils.h"

  #include "Browser.h"
  #include "FetchPage.h"
  #include "Frames.h"
  #include "JavaScript.h"

  #include "LineOne.h"

  /* Static function prototypes */

  static _kernel_oserror * lineone_inline_error       (char * url);
  static _kernel_oserror * lineone_params_error       (const char * onclick);
  static _kernel_oserror * lineone_notrec_error       (const char * onclick);

  static char            * lineone_get_product        (browser_data * b, char * str);
  static _kernel_oserror * lineone_navigation_set_url (browser_data * b, char * str);
  static char            * lineone_remove_host        (browser_data * b, char * str);
  _kernel_oserror        * lineone_butler_set_tab     (browser_data * b, int i);
  _kernel_oserror        * lineone_butler_set_url     (browser_data * b, char * str);
  static _kernel_oserror * lineone_update_butler      (browser_data * b);

  static HStream         * lineone_find_next_script   (browser_data * b, HStream * current);
  static char            * lineone_find_window_open   (browser_data * b, char * script, char * function, char * url, int url_len, char * target, int target_len);

  /* Local definitions */

  #define MaxProductLen              256

  #define NavigationFrameName        "navigation"
  #define NavigationProductPrefixLen 32
  #define NavigationProductPrefix    "/java/butler/cgi-bin/loadnav.pl?"

  /* Local variables / arrays */

  static char   prod        [MaxProductLen];
  static char   last_product[MaxProductLen];

  static char * page   = "/pages/1.html"; /* For lineone_butler_set_tab and related functions */
  static int    curTab = 1;

  /*************************************************/
  /* lineone_inline_error()                        */
  /*                                               */
  /* Builds an error message in the global error   */
  /* block to report inline JavaScript code, if    */
  /* the Messages file says it should do so.       */
  /*                                               */
  /* Parameters: Pointer to the URL of the page    */
  /*             containing the inline code, or    */
  /*             NULL if not known for some        */
  /*             reason...                         */
  /*************************************************/

  static _kernel_oserror * lineone_inline_error(char * url)
  {
    if (strcmp(lookup_token("LOH_ReportInline:no",0,0),"yes")) return NULL;

    erb.errnum = Utils_Error_Custom_Normal;

    if (url)
    {
      *lasttokn = 0;

      if (strlen(url) > 160) strcpy(tokens, url + strlen(url) - 160);
      else                   strcpy(tokens, url);

      sprintf(erb.errmess, "Can't handle inline JavaScript code at '%s'", tokens);

      *tokens = 0;
    }
    else
    {
      strcpy(erb.errmess, "Can't handle inline JavaScript code");
    }

    return &erb;
  }

  /*************************************************/
  /* lineone_params_error()                        */
  /*                                               */
  /* Builds an error message in the global error   */
  /* block to report unknown parameters to a known */
  /* hardcoded function, if the Messages file says */
  /* it should do so.                              */
  /*                                               */
  /* Parameters: Pointer to the onClick string     */
  /*             containing the function call, or  */
  /*             NULL if not known for some        */
  /*             reason...                         */
  /*************************************************/

  static _kernel_oserror * lineone_params_error(const char * event)
  {
    if (strcmp(lookup_token("LOH_ReportIllegal:no",0,0),"yes")) return NULL;

    erb.errnum = Utils_Error_Custom_Normal;

    if (event)
    {
      *lasttokn = 0;

      if (strlen(event) > 160) strcpy(tokens, event + strlen(event) - 160);
      else                   strcpy(tokens, event);

      sprintf(erb.errmess, "Can't handle JavaScript function parameters in '%s'", tokens);

      *tokens = 0;
    }
    else
    {
      strcpy(erb.errmess, "Can't handle JavaScript function parameters");
    }

    return &erb;
  }

  /*************************************************/
  /* lineone_notrec_error()                        */
  /*                                               */
  /* Builds an error message in the global error   */
  /* block to report unknown function calls, if    */
  /* the Messages file says it should do so.       */
  /*                                               */
  /* Parameters: Pointer to the onClick string     */
  /*             containing the function call, or  */
  /*             NULL if not known for some        */
  /*             reason...                         */
  /*************************************************/

  static _kernel_oserror * lineone_notrec_error(const char * event)
  {
    if (strcmp(lookup_token("LOH_ReportUnknown:no",0,0),"yes")) return NULL;

    erb.errnum = Utils_Error_Custom_Normal;

    if (event)
    {
      *lasttokn = 0;

      strncpy(tokens, event, 160);

      sprintf(erb.errmess, "Unrecognised JavaScript function call '%s'", tokens);

      *tokens = 0;
    }
    else
    {
      strcpy(erb.errmess, "Unrecognised JavaScript function call");
    }

    return &erb;
  }

  /*************************************************/
  /* lineone_body_onload()                         */
  /*                                               */
  /* When a page has finished fetching the main    */
  /* page data, a BODY tag may specify some        */
  /* JavaScript action. This functon should be     */
  /* called to carry out that action.              */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             with a filled in 'onload' field   */
  /*             describing the contents of the    */
  /*             onLoad command in the HTML.       */
  /*************************************************/

  _kernel_oserror * lineone_body_onload(browser_data * b)
  {
    /* Deal with known functions */

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_body_onload: Called\n");
    #endif

    if (!utils_strncasecmp(b->onload, "updateButler", 12))
    {
      /* If we have updateButler but it appears to have some parameters, complain */

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("lineone_body_onload: Checking updateButler\n");
      #endif

      if (utils_strcasecmp(b->onload, "updateButler()")) return lineone_params_error(b->onload);

      /* Otherwise, do the updateButler functions */

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("lineone_body_onload: Calling lineone_update_butler\n");
      #endif

      return lineone_update_butler(b);
    }
    else
    {
      /* Have a stab at guessing if this is inline code */

      if (
           strstr(b->onload, "{")           ||
           strstr(b->onload, "}")           ||
           strstr(b->onload, "var")         ||
           strstr(b->onload, "window.open")
         )
         return lineone_inline_error(
                                      browser_fetch_url(b)   ?
                                      browser_fetch_url(b)   :
                                      browser_current_url(b)
                                    );

      /* If not, we don't know what the function was */

      else return lineone_notrec_error(b->onload);
    }

    return NULL;
  }

  /*************************************************/
  /* lineone_href_onclick()                        */
  /*                                               */
  /* When something is clicked upon that has an    */
  /* onClick attribute specified for it, this      */
  /* function is called with the details of that   */
  /* attribute.                                    */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             relevant to the item clicked on;  */
  /*                                               */
  /*             Pointer to the token representing */
  /*             that item.                        */
  /*************************************************/

  _kernel_oserror * lineone_href_onclick(browser_data * b, HStream * t)
  {
    _kernel_oserror * e;

    /* Deal with known functions */

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_href_onclick: Called\n");
    #endif

    if (!utils_strncasecmp(t->onclick, "top.butlerbar.setTab(", 21))
    {
      int tab;

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("lineone_href_onclick: top.butlerbar.setTab...\n");
      #endif

      /* Extract the single byte numerical parameter */

      tab = ((int) (*(t->onclick + 21))) - 48;

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("lineone_href_onclick: Calling lineone_butler_set_tab with %d\n", tab);
      #endif

      return lineone_butler_set_tab(b, tab);
    }
    else if (!strncmp(t->onclick, "loadWin", 7))
    {
      char      url    [8192];
      char      target [1024];
      char    * s_ptr;
      HStream * s_tag = NULL;

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("lineone_href_onclick: loadWin...\n");
      #endif

      if (strcmp(t->onclick, "loadWin()")) return lineone_params_error(t->onclick);

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("lineone_href_onclick: Parameters to loadWin are OK, proceeding\n");
      #endif

      do
      {
        s_tag = lineone_find_next_script(b, s_tag);

        if (!s_tag) Printf("lineone_href_onclick: Can't find any script!\n");
        else
        {
          s_ptr = s_tag->text;

          if (!s_ptr) Printf("lineone_href_onclick: SCRIPT tag doesn't have any text!\n");
          else
          {
            do
            {
              s_ptr = lineone_find_window_open(b,
                                               s_ptr,
                                               "loadWin()",

                                               url,
                                               sizeof(url),
                                               target,
                                               sizeof(target));

              if (*url)
              {
                e = javascript_window_open(b,
                                           0,
                                           1,
                                           url,
                                           target);

                if (e) return e;
              }
            }
            while (s_ptr);
          }
        }
      }
      while (s_tag);
    }
    else
    {
      /* Have a stab at guessing if this is inline code */

      if (
           strstr(t->onclick, "{")           ||
           strstr(t->onclick, "}")           ||
           strstr(t->onclick, "var")         ||
           strstr(t->onclick, "window.open")
         )
         return lineone_inline_error(
                                      browser_fetch_url(b)   ?
                                      browser_fetch_url(b)   :
                                      browser_current_url(b)
                                    );

      /* If not, we don't know what the function was */

      else return lineone_notrec_error(t->onclick);
    }

    return NULL;
  }

  /*************************************************/
  /* lineone_get_product()                         */
  /*                                               */
  /* Mimic the Line One getProduct JavaScript code */
  /* (Line One URLs are structured to include a    */
  /* 'product' name in a specific place).          */
  /*                                               */
  /* This would take, e.g.:                        */
  /*                                               */
  /* 'http://www.lineone.net/sun/today/story.html' */
  /*                                               */
  /* and return:                                   */
  /*                                               */
  /* 'sun'.                                        */
  /*                                               */
  /* Parameters: Pointer to the browser_data       */
  /*             struct relevant to the token that */
  /*             gave the JavaScript call to this  */
  /*             function, or to another that      */
  /*             calls it itself;                  */
  /*                                               */
  /*             Pointer to the URL that this      */
  /*             browser is displaying (or NULL    */
  /*             for browser_current_url()).       */
  /*                                               */
  /* Returns:    Pointer to a product name string  */
  /*             (in a 'safe' buffer, which may    */
  /*             have its contents altered within  */
  /*             the MaxProductLen length incl.    */
  /*             terminator - defined at the top   */
  /*             of this file).                    */
  /*************************************************/

  static char * lineone_get_product(browser_data * b, char * str)
  {
      if (tl & (1u<<24)) Printf("lineone_get_product: Called\n");

    if (!b) return NULL;
    if (!str) str = browser_current_url(b);

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_get_product: Proceeding with '%s'\n",str);
    #endif

    StrNCpy0(prod, "home"); /* Start with a default product name of 'home' */

    /* Is this a fully specified URL? */

    if (strstr(str, "http://"))
    {
      int i;
      int len = strlen(str);

      for (i = 7; i < len; i++)
      {
        /* Look for the first '/' after the 'http://' - i.e. */
        /* skip the host name.                               */

        if (str[i] == '/')
        {
          int j, k, p;
 
          /* Look for the next '/' after that */

          for (j = i + 1; j < len; j++)
          {
            if (str[j] == '/') break;
          }

          /* The product is the string between 'i + 1' and 'j' in 'str' */

          for (k = i + 1, p = 0; k < j && p < MaxProductLen - 1; k++, p++)
          {
            prod[p] = str[k];
          }

          break;
        }
      }
    }

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_get_product: Returning '%s'\n",prod);
    #endif

    return prod;
  }

  /*************************************************/
  /* lineone_navigation_set_url()                  */
  /*                                               */
  /* Mimics the Line One setURL function for the   */
  /* 'navigation' JavaScript object.               */
  /*                                               */
  /* All #define values (prefixed by Navigation)   */
  /* are defined at the top of this file.          */
  /*                                               */
  /* This opens a URL in the Navigation frame that */
  /* is based upon the product name (see           */
  /* lineone_get_product()).                       */
  /*                                               */
  /* Parameters: Pointer to the browser_data       */
  /*             struct relevant to the token that */
  /*             gave the JavaScript call to this  */
  /*             function, or to another that      */
  /*             calls it itself;                  */
  /*                                               */
  /*             Pointer to the URL that this      */
  /*             browser is displaying (or NULL    */
  /*             for browser_current_url()).       */
  /*************************************************/

  _kernel_oserror * lineone_navigation_set_url(browser_data * b, char * str)
  {
    static char * product = "";

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_navigation_set_url: Called\n");
    #endif

    if (!b) return NULL;
    if (!str) str = browser_current_url(b);

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_navigation_set_url: Proceeding with '%s'\n",str);
    #endif

    /* Remember the last product */

    strcpy(last_product, product);

    product               = lineone_get_product(b, str);
    if (!product) product = "";

    /* If the product has changed, open a new URL in the */
    /* 'navigation' pane as appropriate to the product   */

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_navigation_set_url: product, last product = '%s', '%s'\n",product,last_product);
    #endif

    if (strcmp(product, last_product))
    {
      char url[MaxProductLen + NavigationProductPrefixLen];

      /* Build the URL */

      strcpy(url, NavigationProductPrefix);
      strcat(url, product);

      /* Fetch the URL, without storing the previous in the History */

      #ifdef TRACE
        if (tl & (1u<<24))
        {
          Printf("lineone_navigation_set_url: Have URL '%s'\n",url);
          Printf("lineone_navigation_set_url: Exitting through javascript_window_open\n");
        }
      #endif

      return javascript_window_open(b,
                                    1,    /* Must find the target, else fail */
                                    0,    /* Don't record previous URL       */
                                    url,
                                    NavigationFrameName);
    }

    return NULL;
  }

  /*************************************************/
  /* lineone_remove_host()                         */
  /*                                               */
  /* Mimic the Line One removeHost JavaScript      */
  /* function.                                     */
  /*                                               */
  /* This takes, e.g. 'http://www.lineone/tst.htm' */
  /* and would return '/tst.htm'.                  */
  /*                                               */
  /* Parameters: Pointer to the browser_data       */
  /*             struct relevant to the token that */
  /*             gave the JavaScript call to this  */
  /*             function, or to another that      */
  /*             calls it itself;                  */
  /*                                               */
  /*             Pointer to the URL that this      */
  /*             browser is displaying (or NULL    */
  /*             for browser_current_url()).       */
  /*                                               */
  /* Returns:    Pointer into the URL string       */
  /*             which is past the host name -     */
  /*             this may or may not be a safe     */
  /*             buffer, it depends on what was    */
  /*             passed into the function in the   */
  /*             first place.                      */
  /*************************************************/

  static char * lineone_remove_host(browser_data * b, char * str)
  {
    char * res;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_remove_host: Called\n");
    #endif

    if (!b) return NULL;
    if (!str) str = browser_current_url(b);

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_remove_host: Proceeding with '%s'\n",str);
    #endif

    res = str;

    /* Skip the 'http://', if present */

    if (strstr(res, "http://"))
    {
      int i;
      int len = strlen(res);

      /* Skip to the next '/' */

      for (i = 7; i < len; i++)
      {
        if (res[i] == '/') break;
      }

      res = str + i;
    }

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_remove_host: Returning '%s'\n",res);
    #endif

    return res;
  }

  /*************************************************/
  /* lineone_butler_set_tab                        */
  /*                                               */
  /* Mimic the Line One setTab JavaScript code for */
  /* the Butler Bar object.                        */
  /*                                               */
  /* This takes, e.g. 'http://www.lineone/tst.htm' */
  /* and would return '/tst.htm'.                  */
  /*                                               */
  /* Parameters: Pointer to the browser_data       */
  /*             struct relevant to the token that */
  /*             gave the JavaScript call to this  */
  /*             function, or to another that      */
  /*             calls it itself;                  */
  /*                                               */
  /*             0, 1, or 2, this parameter coming */
  /*             from the JavaScript call.         */
  /*************************************************/

  _kernel_oserror * lineone_butler_set_tab(browser_data * b, int i)
  {
    char        * liveserver = "http://www.lineone.net";
    char        * db         = "d-1";

    /* Currently, these aren't used */

//    char        * nlinks     = "n6";
//    int           usejava    = 0;
//    int           websb;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_butler_set_tab: Called with %d\n", i);
    #endif

    /* Deal with the 3 known parameter values */

    switch (i)
    {
      case 0:
      {
        curTab = 0; /* For 'curTab', see top of file */

        #ifdef TRACE
          if (tl & (1u<<24)) Printf("lineone_butler_set_tab: Exitting through javascript_window_open\n");
        #endif

        return javascript_window_open(b,
                                      1,
                                      0,
                                      "/java/butler/cgi-bin/but_diary?h",
                                      "links");
      }
      break;

      case 1:
      {
        char * file = lineone_remove_host(b, page); /* For 'page', see top of file */
        char * str  = file;

        if (!str) str = file = page;

        /* Grotty C string handling (or rather, lack thereof)... */
        /* Mutter, mutter...                                     */

        {
          char * opt1 = "/java/butler/cgi-bin/redirect?";
          char * opt2 = "/java/butler/njlinks.html";

          char * add  = "+l+h";
          char * look = "-d.html";

          /* size = strlen(liveserver) + strlen(opt1) + strlen(file) + 1 + strlen(db) + strlen(add) + 1 */
          /* - I *hate* the fact that C can't cope with this, and you have to hard code it. Yuk!        */

          char url[8192]; /* Have to give a lot as strlen(file) will vary */

          char * srch = strstr(str, look);

          if (srch == str + strlen(str) - strlen(look))
          {
            /* Thanks to having to hard code the array size above, now have to  */
            /* do six lots of very tedious limit checking. This really is foul. */

            if (strlen(liveserver) + 1 > sizeof(url)) return NULL;
            strcpy(url, liveserver);

            if (strlen(opt1) + strlen(url) + 1 > sizeof(url)) return NULL;
            strcat(url, opt1);

            if (strlen(file) + strlen(url) + 1 > sizeof(url)) return NULL;
            strcat(url, file);

            if (strlen(url) + 2 > sizeof(url)) return NULL;
            strcat(url, "+");

            if (strlen(db) + strlen(url) + 1 > sizeof(url)) return NULL;
            strcat(url, db);

            if (strlen(add) + strlen(url) + 1 > sizeof(url)) return NULL;
            strcat(url, add);
          }
          else
          {
            /* And again, more limit checking */

            if (strlen(liveserver) + 1 > sizeof(url)) return NULL;
            strcpy(url, liveserver);

            if (strlen(opt2) + strlen(url) + 1 > sizeof(url)) return NULL;
            strcat(url, opt2);
          }

          curTab = 1;

          #ifdef TRACE
            if (tl & (1u<<24))
            {
              Printf("lineone_butler_set_tab: Option 1 -> url = '%s'\n",url);
              Printf("lineone_butler_set_tab: Exitting through javascript_window_open\n");
            }
          #endif

          return javascript_window_open(b,
                                        1,
                                        0,
                                        url,
                                        "links");
        }
      }
      break;

      case 2:
      {
        curTab = 2;

        #ifdef TRACE
          if (tl & (1u<<24)) Printf("lineone_butler_set_tab: Exitting through javascript_window_open\n");
        #endif

        return javascript_window_open(b,
                                      1,
                                      0,
                                      "njsearch.html",
                                      "links");
      }
      break;

      /* Complain if anything else was passed in */

      default:
      {
        #ifdef TRACE
          if (tl & (1u<<24)) Printf("lineone_butler_set_tab: Exitting through lineone_params_error\n");
        #endif

        return lineone_params_error(NULL);
      }
      break;
    }
  }

  /*************************************************/
  /* lineone_butler_set_url                        */
  /*                                               */
  /* Mimics the Line One setURL function for the   */
  /* Butler Bar JavaScript object.                 */
  /*                                               */
  /* This opens a URL in the Links frame that is   */
  /* based upon the current page URL (see          */
  /* lineone_butler_set_tab()).                    */
  /*                                               */
  /* Parameters: Pointer to the browser_data       */
  /*             struct relevant to the token that */
  /*             gave the JavaScript call to this  */
  /*             function, or to another that      */
  /*             calls it itself;                  */
  /*                                               */
  /*             Pointer to the URL that this      */
  /*             browser is displaying (or NULL    */
  /*             for browser_current_url()).       */
  /*************************************************/

  _kernel_oserror * lineone_butler_set_url(browser_data * b, char * str)
  {
    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_butler_set_url: Called\n");
    #endif

    if (!b) return NULL;
    if (!str) str = browser_current_url(b);

    page = str; /* For 'page', see top of file */

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_butler_set_url: Proceeding with '%s'\n",page);
    #endif

    if (curTab == 1) /* For 'curTab', see top of file */
    {
      /* Yes I *know* this is weird - if we're already showing 1, */
      /* why re-show it? I can only assume that this is supposed  */
      /* to deal with cacheing issues in some browsers. In any    */
      /* case, this is not a coding bug local to the browser; it  */
      /* is, at least at the time of creation, what the Line One  */
      /* JavaScript actually does.                                */

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("lineone_butler_set_url: Exitting through lineone_butler_set_tab\n");
      #endif

      return lineone_butler_set_tab(b, 1);
    }

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_butler_set_url: Exitting with no action\n");
    #endif

    return NULL;
  }

  /*************************************************/
  /* lineone_update_butler()                       */
  /*                                               */
  /* Mimic the Line One updateButler JavaScript    */
  /* code.                                         */
  /*                                               */
  /* Parameters: Pointer to the browser_data       */
  /*             struct relevant to the token that */
  /*             gave the JavaScript call.         */
  /*************************************************/

  static _kernel_oserror * lineone_update_butler(browser_data * b)
  {
    _kernel_oserror * e;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_update_butler: Called, calling lineone_butler_set_url\n");
    #endif

    e = lineone_butler_set_url(b, NULL);
    if (e) return e;

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_update_butler: Exitting through lineone_navigation_set_url\n");
    #endif

    return lineone_navigation_set_url(b, NULL);
  }

  /*************************************************/
  /* lineone_find_next_script()                    */
  /*                                               */
  /* Looks for a <SCRIPT> tag in a given token     */
  /* list.                                         */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             relevant to the list;             */
  /*                                               */
  /*             If called before, pointer to the  */
  /*             last returned SCRIPT tag, else    */
  /*             NULL for the first one.           */
  /*                                               */
  /* Returns:    Pointer to the first / next       */
  /*             SCRIPT tag, or NULL if there are  */
  /*             none / no more.                   */
  /*************************************************/

  static HStream * lineone_find_next_script(browser_data * b, HStream * current)
  {
    /* Find the first new token */

    if (!current) current = b->stream;
    else if (ISHEAD(current) && current->tag == SCRIPT) current = current->next;

    /* Scan for a SCRIPT item */

    while (current)
    {
      if (ISHEAD(current) && current->tag == SCRIPT) return current;

      current = current->next;
    }

    /* Nothing found, so return NULL */

    return NULL;
  }

  /*************************************************/
  /* lineone_find_window_open()                    */
  /*                                               */
  /* Finds a specific function name and any        */
  /* window.open commands within it up to another  */
  /* opening or closing curly brace etc.           */
  /*                                               */
  /* Parameters: Pointer to a browser_data struct  */
  /*             relevant to the script;           */
  /*                                               */
  /*             Pointer to the script text, or an */
  /*             offset into it (see 'Returns');   */
  /*                                               */
  /*             Pointer to the function name to   */
  /*             find;                             */
  /*                                               */
  /*             Pointer to a buffer for the       */
  /*             target of the window.open;        */
  /*                                               */
  /*             Length of that buffer;            */
  /*                                               */
  /*             Pointer to a buffer for the URL   */
  /*             specified by the window.open;     */
  /*                                               */
  /*             Length of that buffer.            */
  /*                                               */
  /* Returns:    Directly, NULL if there is no     */
  /*             need to make another call; else   */
  /*             pass the returned pointer in as   */
  /*             the second entry parameter (the   */
  /*             script text pointer);             */
  /*                                               */
  /*             Indirectly, the URL and possibly  */
  /*             the Target buffers will be filled */
  /*             in with non-null strings if a     */
  /*             valid window.open command was     */
  /*             found. If none was found, null    */
  /*             strings (i.e. a single terminator */
  /*             byte) will be written instead.    */
  /*************************************************/

  static char * lineone_find_window_open(browser_data * b, char * script, char * function,
                                         char * url, int url_len, char * target, int target_len)
  {
    char * scrptr = script;
    char * retptr = NULL;
    int    len    = strlen(function);

    #ifdef TRACE
      if (tl & (1u<<24)) Printf("lineone_find_window_open: Called\n");
    #endif

    /* Very tight sanity checking to help ensure robustness - this */
    /* is not speed critical...                                    */

    if (!b || !script || !function || !*script || !*function) return NULL;

    if (target && !target_len) target = NULL;
    if (url    && !url_len)    url    = NULL;

    /* Start with null strings */

    if (url)    memset(url,    0, url_len);
    if (target) memset(target, 0, target_len);

    while (scrptr && *scrptr)
    {
      /* First, look for the keyword 'function' */

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("lineone_find_window_open: Have script\n");
      #endif

      scrptr = strstr(scrptr, "function");

      /* If we can't even find that, exit */

      if (!scrptr) break;

      #ifdef TRACE
        if (tl & (1u<<24)) Printf("lineone_find_window_open: Found 'function' keyword\n");
      #endif

      /* Get past the keyword */

      scrptr += 8;

      /* Now look for the function name itself. We could use strstr, but */
      /* that might just find a later reference to the function name as  */
      /* a call - we must step through more carefully to ensure that the */
      /* function name really does follow the function keyword.          */
      /*                                                                 */
      /* So first, skip white space.                                     */

      while (*scrptr && *scrptr < 33) scrptr ++;

      /* Exit if dropped off the end of the script */

      if (!*scrptr) break;

      /* We should now have the function name */

      if (!strncmp(scrptr, function, len))
      {
        /* The next character after the function name should be white */
        /* space or an open curly bracket. If not, the first part of  */
        /* this function name just happened to match the function we  */
        /* are looking for.                                           */

        scrptr += len;

        if (*scrptr && (*scrptr < 33 || *scrptr == '{'))
        {
          /* We're having to deal with code of the form:                   */
          /*                                                               */
          /* function loadWindows() {                                      */
          /*          var win1 = window.open("url1","target1");            */
          /*          var win2 = window.open("url2","target2"); ... etc.   */
          /*                                                               */
          /* So first thing, skip the white space and look for 'var'       */

          while (*scrptr && (*scrptr < 33 || *scrptr == '{')) scrptr++;
          if (!*scrptr) break;

          /* If we find a closing curly brace, drop out immediately - */
          /* there is more complex code going on than we can handle   */

          if (*scrptr == '}') break;

          /* Otherwise, we should now have a 'var' command */

          if (!strncmp(scrptr, "var", 3))
          {
            /* Look for '=' */

            while (*scrptr && *scrptr != '=' && *scrptr != '}') scrptr ++;
            if (!*scrptr || *scrptr == '}') break;

            /* Now on '=', so skip it and any white space after it */

            scrptr ++;
            while (*scrptr && *scrptr < 33) scrptr++;
            if (!*scrptr || *scrptr == '}') break;

            /* Should now have a window.open command */

            if (!strncmp(scrptr, "window.open", 11))
            {
              int count;

              #ifdef TRACE
                if (tl & (1u<<24)) Printf("lineone_find_window_open: Found 'window.open' call\n");
              #endif

              /* OK, have the window.open - now extract the URL and */
              /* Target strings from it.                            */

              scrptr += 11;

              /* Skip to the opening '(' of the parameters */

              while (*scrptr && *scrptr != '(')
              {
                if (*scrptr == '}') break;
                scrptr ++;
              }
              if (!*scrptr) break;

              /* Skip to the opening '"' or ''' of the parameters */

              scrptr ++;
              if (!*scrptr) break;

              while (*scrptr && *scrptr != '"' && *scrptr != '\'')
              {
                if (*scrptr == '}') break;
                scrptr ++;
              }
              if (!*scrptr) break;

              /* Right, now copy the argument up to the next '"' or ''' */

              scrptr ++;
              if (!*scrptr) break;

              count = 0;

              while (
                      *scrptr             &&
                      count < url_len - 1 &&
                      *scrptr != '"'      &&
                      *scrptr != '\''
                    )
                    if (url) url[count++] = *scrptr++;

              if (!*scrptr)
              {
                if (url) *url = 0;
                break;
              }

              #ifdef TRACE
                if (tl & (1u<<24)) Printf("lineone_find_window_open: Dealt with first parameter\n");
              #endif

              /* Now skip to the separating ',' or closing ')' */

              scrptr ++;
              if (!*scrptr) break;

              while (*scrptr && *scrptr != ',' && *scrptr != ')')
              {
                if (*scrptr == '}') break;
                scrptr ++;
              }
              if (!*scrptr || *scrptr == ')') break;

              /* Have reached a ',' so now need to find the next argument starting quotes */

              scrptr ++;
              if (!*scrptr) break;

              while (*scrptr && *scrptr != '"' && *scrptr != '\'')
              {
                if (*scrptr == '}') break;
                scrptr ++;
              }
              if (!*scrptr) break;

              /* So again, copy the argument up to the next '"' or ''' */

              scrptr ++;
              if (!*scrptr) break;

              count = 0;

              while (
                      *scrptr                &&
                      count < target_len - 1 &&
                      *scrptr != '"'         &&
                      *scrptr != '\''
                    )
                    if (target) target[count++] = *scrptr++;

              if (!*scrptr)
              {
                if (target) *target = 0;
                break;
              }

              /* OK, finished - don't want to know about other parameters */

              #ifdef TRACE
                if (tl & (1u<<24)) Printf("lineone_find_window_open: Dealt with second parameter\n");
              #endif
            }
          }
        }
      }
    }

    return retptr;
  }

#else

  static void lineone_keep_compiler_happy(void)
  {
    int a;
    a = 0;
  }

#endif
