/*
 * Name     : handlers.c
 * Desc     : Onscreen software keyboard for Acorn RCA NC
 * Author   : Jonathan Larmour
 * Date     : 13th February 1997
 *
 * History
 * -------
 *
 *  20/10/98 ADH     IME support for Funai 3.
 *  03/09/98 ADH     Changes for Funai 3 (project 866) - see CVS logs for details
 *  19/08/98 SBF     Added handlers for additional toolbar keys: "www." and ".net"
 *  13/02/97 JIFL    Finished main coding
 *  05/02/97 JIFL    Created file
 *
 * Relevant Documents
 * ------------------
 *
 * 2107,738     Owen Love       RCA On-Screen Keyboard Software Functional Spec
 * 2107,217     Julian Smith    Icon Highlighter Functional Spec
 *
 * (and, of course, later specifications for revisions to the software).
 *
 * Summary
 * -------
 * This module is used to provide the wimp, toolbox, event and message handlers
 *
 * © Acorn Computers Ltd. 1997
 */

/* INCLUDES */

/* System includes */
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>

/* Kernel/Wimp/Toolbox includes */
#include "kernel.h"
#include "wimp.h"
#include "toolbox.h"
#include "wimplib.h"

/* Project includes */
#include "handlers.h"
#include "oskbime.h"
#include "oskbutils.h"
#include "windowops.h"

/* FUNCTIONS */

/*
 * oskb_quit_event_handler
 *
 * Event handler to be called when Close button is clicked
 */

int oskb_quit_event_handler(int event_code, ToolboxEvent *event,
                            IdBlock *id_block,void *handle)
{
  oskb_deal_with_exit(window_oid, scrollup);
  return(1);
} /* oskb_quit_event_handler */



int oskb_ptrenter_handler( int event_code, WimpPollBlock *event,
                          IdBlock *id_block,void *handle)
{
  oskb_start_iconhigh();
  return 1;
}


/*
 * oskb_pollword_handler
 *
 * Event handler to be called when poll word is non-zero (i.e. key pressed)
 */

int oskb_pollword_handler(int event_code, WimpPollBlock *event,
                          IdBlock *id_block,void *handle)
{
  /* this does the same things */
  return oskb_quit_event_handler(event_code, NULL, id_block, handle);
} /* oskb_pollword_handler */

/*
 * oskb_quit_message_handler
 *
 * Message handler to be called on receipt of a
 * Quit or PreQuit message from the Wimp.
 */

int oskb_quit_message_handler(WimpMessage *message,void *handle)
{
  oskb_deal_with_exit(window_oid, scrollup);
  return(1);
} /* oskb_quit_message_handler */

/*
 * oskb_control_message_handler
 *
 * Message handler to be called on receipt of
 * Message_NCKeyboard_Control from the Wimp.
 */

int oskb_control_message_handler(WimpMessage * message, void * handle)
{
  unsigned int flags = message->data.words[0];

  /* Close and quit specified in flags */

  if (flags & (1u<<OSKB_CONTROL_CLOSE_AND_QUIT))
  {
    oskb_deal_with_exit(window_oid, scrollup);
  }

  /* Change to full size mode, if not already there */

  else if (
            (
              toolbar_mode &&
              (flags & (1u<<OSKB_CONTROL_CHANGE_TO_FULL_SIZE))
            )
            ||
            (
              !toolbar_mode &&
              (flags & (1u<<OSKB_CONTROL_CHANGE_TO_TOOLBAR))
            )
          )
  {
    toolbar_mode = !toolbar_mode;
    oskb_reopen_window(NULL_ComponentId);
  }

  return 1;

} /* oskb_control_message_handler */

/*
 * oskb_click_handler
 *
 * In the click handler we look in the messages file for a token of the form:
 *
 * #ifndef FUNAI3
 *
 *   KeyQxxx or KeyAxxx for the QWERTY or ALPHABET layers respectively,
 *   and xxx is a three digit decimal component ID that the token's value
 *   maps to (pad with leading '0's as required). The rest is the same as
 *   the '#else' case below, except special key name 'layerL' will not be
 *   recognised.
 *
 *   In addition, if a token "AdjClickToClose" exists and has a value of
 *   "yes", an adjust-click on the keyboard will make it close (regardless
 *   of what buttons may have been clicked upon).
 *
 * #else
 *
 *   KeyLxxx where L is the layer number that this definition applies to
 *   and xxx is a three digit decimal component ID that the token's value
 *   maps to (pad with leading '0's as required). The 'L' part may be more
 *   than one digit, of course, if you've loads and loads of layers...!
 *   If we find this token, the value is looked at and inserted into the
 *   keyboard buffer according to -
 *
 *   1) Does it match a 'magic' key name? These are:
 *
 *      com     Insert string '.com'
 *      edu     Insert string '.edu'
 *      net     Insert string '.net
 *      org     Insert string '.org
 *      www     Insert string 'www.'
 *      shift   Toggle the keyboard Shift state
 *      caps    Toggle the Caps Lock state
 *      tab     Output TAB_SPACES spaces (ahem; a bit lame, this one)
 *      layout  Toggle between layers 0 and 1, or move straight to layer
 *              0 if on layer 2 or higher
 *      layerL  Move to layer L
 *
 *   2) Does it contain digits forming a number in the range 0 to 255?
 *      If so, this is considered an ASCII character code and output
 *      directly.
 *
 *   3) Does it begin with a '"' character? If so, the whole of the rest
 *      of the token value is taken as a string to be output literally
 *      (you can include character codes 128 to 255 here, so UTF-8
 *      sequences can be specified).
 *
 * #endif
 *
 * Keyxxx where xxx is the component ID. If we find it, then we insert the
 * corresponding value (from the messages file) into the keyboard buffer
 */

int oskb_click_handler(int event_code, WimpPollBlock *event,
                       IdBlock *id_block, void *handle)
{
  char            lookup_str [24];     /* string to look up in Messages */
  char            key_str    [66];     /* string version of numeric key code */
  int             key;                 /* numeric key value */
  _kernel_oserror kern_error;          /* kernel error */
  static int      oskb_shiftstate = 0; /* whether shift has been pressed */

  if (
       id_block->self_id        != NULL_ObjectId    &&
       id_block->self_component != NULL_ComponentId
     )
  {
    #ifdef FUNAI3

      /* See if an adjust-click should close the keyboard */

      if (event->mouse_click.buttons & Wimp_MouseButtonAdjust)
      {
        if (oskb_lookup_message_token("AdjClickToClose",
                                      lookup_str,
                                      sizeof(lookup_str)))
        {
          if (!strcmp(lookup_str, "yes"))
          {
            oskb_deal_with_exit(window_oid, scrollup);
            return 1;
          }
        }
      }

      /* IME control */

      if (ime_support_on)
      {
        if (id_block->self_component == ime_on_off)
        {
          oskbime_on_off();
          return 1;
        }
        else if (id_block->self_component == ime_cycle_mode)
        {
          oskbime_cycle_mode();
          return 1;
        }
        else if (id_block->self_component == ime_convert)
        {
          oskbime_convert();
          return 1;
        }
        else if (id_block->self_component == ime_lock_indicator)
        {
          /* Lock indicator has no associated action */

          return 1;
        }
      }

      /* Build the "KeyL" part of the token name for keyboard buttons */

      if (oskb_layout < 0 || oskb_layout >= layers)
      {
        kern_error.errnum=OSKB_UNKNOWN_LAYOUT;
        strcpy(kern_error.errmess,"Unknown keyboard layout!");
        wimp_report_error(&kern_error,0,0);

        return 0;
      }
      else
      {
        sprintf(lookup_str, "Key%d", oskb_layout);
      }

    #else

      /* Select layout */

      strcpy(lookup_str,"Key");

      switch (oskb_layout)
      {
        case OSKB_QWERTY: strcat(lookup_str,"Q"); break;
        case OSKB_ALPHA:  strcat(lookup_str,"A"); break;

        default: /* Use kern_error for now since its there! */
        {
          kern_error.errnum=OSKB_UNKNOWN_LAYOUT;
          strcpy(kern_error.errmess,"Unknown keyboard layout!");
          wimp_report_error(&kern_error,0,0);

          return 0;
        }
        break;
      }

    #endif

    /* Convert component num to string and tack onto end */
    sprintf(&lookup_str[strlen(lookup_str)],"%03d",id_block->self_component);

    #ifdef FUNAI3

      /*
       * If on layer 0, try KeyQ... if the lookup fails or for
       * layer 1 try KeyA... - backwards compatibility issues.
       */

      if (!oskb_lookup_message_token(lookup_str,&key_str[0],sizeof(key_str)))
      {
        if (oskb_layout == 0)      lookup_str[3] = 'Q';
        else if (oskb_layout == 1) lookup_str[3] = 'A';
        else return 1;

        if (!oskb_lookup_message_token(lookup_str,&key_str[0],sizeof(key_str)))
          return 1;
      }

    #else

      if (!oskb_lookup_message_token(lookup_str,&key_str[0],sizeof(key_str)))
          return 1; /* Exit if click isn't in known area */

    #endif

    /* Now deal with specials (next field, "www.", etc.) here */

/* COM */
    if (!strcmp(key_str,"com"))
    {
      oskb_shiftstate = 0;
      oskb_insert_key('.', oskb_capsstate);
      oskb_insert_key('c', oskb_capsstate);
      oskb_insert_key('o', oskb_capsstate);
      oskb_insert_key('m', oskb_capsstate);
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* if */

/* EDU */
    else if (!strcmp(key_str,"edu"))
    {
      oskb_shiftstate = 0;
      oskb_insert_key('.', oskb_capsstate);
      oskb_insert_key('e', oskb_capsstate);
      oskb_insert_key('d', oskb_capsstate);
      oskb_insert_key('u', oskb_capsstate);
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* else if */

/* NET */
    else if (!strcmp(key_str,"net"))
    {
      oskb_shiftstate = 0;
      oskb_insert_key('.', oskb_capsstate);
      oskb_insert_key('n', oskb_capsstate);
      oskb_insert_key('e', oskb_capsstate);
      oskb_insert_key('t', oskb_capsstate);
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* else if */

/* ORG */
    else if (!strcmp(key_str,"org"))
    {
      oskb_shiftstate = 0;
      oskb_insert_key('.', oskb_capsstate);
      oskb_insert_key('o', oskb_capsstate);
      oskb_insert_key('r', oskb_capsstate);
      oskb_insert_key('g', oskb_capsstate);
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* else if */

/* WWW */
    else if (!strcmp(key_str,"www"))
    {
      oskb_shiftstate = 0;
      oskb_insert_key('w', oskb_capsstate);
      oskb_insert_key('w', oskb_capsstate);
      oskb_insert_key('w', oskb_capsstate);
      oskb_insert_key('.', oskb_capsstate);
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* else if */

/* SHIFT */
    else if (!strcmp(key_str,"shift"))
    {
      oskb_shiftstate ^= 1; /* XOR */
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* else if */

/* CAPS */
    else if (!strcmp(key_str,"caps"))
    {
      oskb_capsstate ^= 1; /* XOR */
      oskb_shiftstate = 0;

      /* Change icon */
      oskb_update_caps_lock(window_oid, oskb_capsstate);
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* else if */

/* TAB */
    else if (!strcmp(key_str,"tab"))
    {
      int i;

      /* output TAB_SPACES spaces */
      for (i=0; i<TAB_SPACES; i++)
        oskb_insert_key(' ', oskb_shiftstate);
    } /* else if */

/* LAYOUT */
    else if (!strcmp(key_str,"layout"))
    {
      oskb_layout_t layout;

      oskb_shiftstate = 0;
      oskb_update_shift_key(window_oid, oskb_shiftstate);

      #ifdef FUNAI3

        if (oskb_layout >= 1) layout = 0;
        else layout = 1;

      #else

        if (oskb_layout==OSKB_ALPHA) layout=OSKB_QWERTY;
        else layout=OSKB_ALPHA;

      #endif

      oskb_change_keyboard(layout,

                           #ifdef FUNAI3
                             oskb_layout,
                           #endif

                           window_oid,
                           id_block->self_component);

    } /* else if */

#ifdef FUNAI3

/* Specific layer switching buttons */
    else if (!strncmp(key_str,"layer",5))
    {
      oskb_layout_t layer;

      oskb_shiftstate = 0;
      oskb_update_shift_key(window_oid, oskb_shiftstate);

      layer = atoi(key_str + sizeof("layer") - 1);
      if (layer < 0) layer = 0;

      oskb_change_keyboard(layer,
                           oskb_layout,
                           window_oid,
                           id_block->self_component);

    } /* else if */

#endif

/* Literal string */
    else if (key_str[0] == '"')
    {
      int i = 1;

      while (key_str[i] > 31)
      {
        if (key_str[i] < 128) oskb_insert_key(key_str[i++], oskb_capsstate ? oskb_capsstate : oskb_shiftstate);
        else                  oskb_insert_key(key_str[i++], 0);
      }

      oskb_shiftstate = 0;
      oskb_update_shift_key(window_oid, oskb_shiftstate);

    } /* else if */

/* default */
    else
    {
      /* If not special, convert answer to int as this is the key to insert */
      key=atoi(key_str);
      if (errno==ERANGE) /* conversion failed */
      {
        kern_error.errnum=OSKB_BAD_KEYMAP;
        sprintf(kern_error.errmess,
                "Error in keyboard map for token %s",
                lookup_str);
        wimp_report_error(&kern_error,0,0);
      }
      else
      {
        oskb_insert_key(key, oskb_capsstate ? oskb_capsstate : oskb_shiftstate);

        oskb_shiftstate = 0;
        oskb_update_shift_key(window_oid, oskb_shiftstate);
      } /* else */
    } /* else */
  } /* if */

  return(1);
} /* oskb_click_handler */
