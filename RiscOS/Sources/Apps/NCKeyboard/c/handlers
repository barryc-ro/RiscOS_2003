/*
 * Name	    : handlers.c
 * Desc	    : Onscreen software keyboard for Acorn RCA NC
 * Author   : Jonathan Larmour
 * Date	    : 13th February 1997
 *
 * History
 * -------
 *
 *  13/2/97 JIFL    Finished main coding
 *  5/2/97  JIFL    Created file
 *
 * Relevant Documents
 * ------------------
 *
 * 2107,738 	Owen Love   	RCA On-Screen Keyboard Software Functional Spec
 * 2107,217 	Julian Smith    Icon Highlighter Functional Spec
 *
 * Summary
 * -------
 * This module is used to provide the wimp, toolbox, event and message handlers
 *
 * © Acorn UK Ltd., 1997
 */

/* INCLUDES */

/* System includes */
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>

/* Kernel/Wimp/Toolbox includes */
#include "kernel.h"
#include "wimp.h"
#include "toolbox.h"
#include "wimplib.h"

/* Project includes */
#include "handlers.h"
#include "oskbutils.h"

/* FUNCTIONS */

/*
 * oskb_quit_event_handler
 *
 * Event handler to be called when Close button is clicked
 */

int oskb_quit_event_handler(int event_code, ToolboxEvent *event,
                            IdBlock *id_block,void *handle)
{
  extern object_id window_oid;
  extern int scrollup;

  oskb_deal_with_exit(window_oid, scrollup);
  return(1);
} /* oskb_quit_event_handler */



int oskb_ptrenter_handler( int event_code, WimpPollBlock *event,
                          IdBlock *id_block,void *handle)
{
oskb_start_iconhigh();
return 1;
}


/*
 * oskb_pollword_handler
 *
 * Event handler to be called when poll word is non-zero (i.e. key pressed)
 */

int oskb_pollword_handler(int event_code, WimpPollBlock *event,
                          IdBlock *id_block,void *handle)
{
  /* this does the same things */
  return oskb_quit_event_handler(event_code, NULL, id_block, handle);
} /* oskb_pollword_handler */

/*
 * oskb_quit_message_handler
 *
 * Message handler to be called on receipt of a
 * Quit or PreQuit message from the Wimp.
 */

int oskb_quit_message_handler(WimpMessage *message,void *handle)
{
  extern object_id window_oid;
  extern int scrollup;

  oskb_deal_with_exit(window_oid, scrollup);
  return(1);
} /* oskb_quit_message_handler */


/*
 * oskb_click_handler
 *
 * In the click handler we look in the messages file for a token of the form
 * Keyxxx where xxx is the component ID. If we find it, then we insert the
 * corresponding value (from the messages file) into the keyboard buffer
 */

int oskb_click_handler(int event_code, WimpPollBlock *event,
                       IdBlock *id_block, void *handle)
{
  char lookup_str[10];                  /* string to look up in Messages */
  char key_str[20];                     /* string version of numeric key code */
  int key;                              /* numeric key value */
  _kernel_oserror kern_error;           /* kernel error */
  static int oskb_shiftstate=0;         /* whether shift has been pressed */
  extern int oskb_capsstate;            /* whether CAPS LOCK has been pressed */
  extern oskb_layout_t oskb_layout;     /* current keyboard layout */
  extern object_id window_oid;          /* window object ID of main window */

  /* 0 indicates no object for id's */
  if (id_block->self_id && id_block->self_component)
  {
    strcpy(&lookup_str[0],"Key");

    /* Select layout */
    switch (oskb_layout)
    {
      case OSKB_ALPHA:	strcat(&lookup_str[0],"A");
      	    	    	break;
      case OSKB_QWERTY: strcat(&lookup_str[0],"Q");
      	    	    	break;
      default: /* Use kern_error for now since its there! */
      	       kern_error.errnum=OSKB_UNKNOWN_LAYOUT;
      	       strcpy(kern_error.errmess,"Unknown keyboard layout!");
      	       wimp_report_error(&kern_error,0,0);
      	       break;
    }

    /* Convert component num to string and tack onto end */
    sprintf(&lookup_str[strlen(lookup_str)],"%03d",id_block->self_component);

    if (!oskb_lookup_message_token(&lookup_str[0],&key_str[0],sizeof(key_str)))
        return 1; /* Exit if click isn't in known area */

    /* Now deal with specials (next field, "www.", etc.) here */

/* COM */
    if (!strcmp(key_str,"com"))
    {
      oskb_shiftstate = 0;
      oskb_insert_key('.', oskb_capsstate);
      oskb_insert_key('c', oskb_capsstate);
      oskb_insert_key('o', oskb_capsstate);
      oskb_insert_key('m', oskb_capsstate);
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* if */

/* EDU */
    else if (!strcmp(key_str,"edu"))
    {
      oskb_shiftstate = 0;
      oskb_insert_key('.', oskb_capsstate);
      oskb_insert_key('e', oskb_capsstate);
      oskb_insert_key('d', oskb_capsstate);
      oskb_insert_key('u', oskb_capsstate);
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* else if */

/* ORG */
    else if (!strcmp(key_str,"org"))
    {
      oskb_shiftstate = 0;
      oskb_insert_key('.', oskb_capsstate);
      oskb_insert_key('o', oskb_capsstate);
      oskb_insert_key('r', oskb_capsstate);
      oskb_insert_key('g', oskb_capsstate);
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* else if */

/* SHIFT */
    else if (!strcmp(key_str,"shift"))
    {
      oskb_shiftstate ^= 1; /* XOR */
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* else if */

/* CAPS */
    else if (!strcmp(key_str,"caps"))
    {
      oskb_capsstate ^= 1; /* XOR */
      oskb_shiftstate = 0;

      /* Change icon */
      oskb_update_caps_lock(window_oid, oskb_capsstate);
      oskb_update_shift_key(window_oid, oskb_shiftstate);
    } /* else if */

/* TAB */
    else if (!strcmp(key_str,"tab"))
    {
      int i;

      /* output TAB_SPACES spaces */
      for (i=0; i<TAB_SPACES; i++)
        oskb_insert_key(' ', oskb_shiftstate);
    } /* else if */

/* LAYOUT */
    else if (!strcmp(key_str,"layout"))
    {
      oskb_layout_t layout;

      oskb_shiftstate = 0;
      oskb_update_shift_key(window_oid, oskb_shiftstate);

      if (oskb_layout==OSKB_ALPHA) layout=OSKB_QWERTY;
      else layout=OSKB_ALPHA;

      oskb_change_keyboard(layout, window_oid);

    } /* else if */

/* default */
    else
    {
      /* If not special, convert answer to int as this is the key to insert */
      key=atoi(key_str);
      if (errno==ERANGE) /* conversion failed */
      {
        kern_error.errnum=OSKB_BAD_KEYMAP;
        sprintf(kern_error.errmess, "Error in keyboard map for token %s",
          	    	    	 &lookup_str[0]);
        wimp_report_error(&kern_error,0,0);
      }
      else
      {
        oskb_insert_key(key, oskb_capsstate ? oskb_capsstate : oskb_shiftstate);

        oskb_shiftstate = 0;
        oskb_update_shift_key(window_oid, oskb_shiftstate);
      } /* else */
    } /* else */
  } /* if */

  return(1);
} /* oskb_click_handler */
