/*
 * Name	    : windowops.c
 * Desc	    : Onscreen software keyboard for Acorn RCA NC
 * Author   : Jonathan Larmour
 * Date	    : 13th February 1997
 *
 * History
 * -------
 *
 *  17/4/97 OL      Add code to support both extension and no extension sprites
 *  20/3/97 JIFL    Exported oskb_read_[xy]limit and oskb_read_[xy]eig
 *  13/2/97 JIFL    Finished main coding
 *  5/2/97  JIFL    Created file
 *
 * Relevant Documents
 * ------------------
 *
 * 2107,738 	Owen Love   	RCA On-Screen Keyboard Software Functional Spec
 * 2107,217 	Julian Smith    Icon Highlighter Functional Spec
 *
 * Summary
 * -------
 * This module is used to provide the window related functionality to the
 * rest of the NCKeyboard app.
 *
 * © Acorn UK Ltd., 1997
 */

/* INCLUDES */

/* System includes */
#include <stdlib.h>
#include <string.h>

/* Kernel/Wimp/Toolbox includes */
#include "kernel.h"
#include "swis.h"
#include "toolbox.h"
#include "wimp.h"
#include "wimplib.h"
#include "window.h"

/* Project includes */
#include "NCKeybd.h"
#include "windowops.h"


/* LOCAL FUNCTION PROTOTYPES */

static void oskb_calc_sprite_geom(int show_extension,
                                  int *x_coord, int *keyb_width, int *keyb_height,
                                  int *ext_width, int *ext_height);

static int oskb_read_curr_mode(int mode_var);


/* FUNCTIONS */

/*
 * oskb_create_window
 *
 * This function uses the toolbox to create a window object - the main
 * window for the keyboard
 *
 */

int oskb_create_window(void)
{
    _kernel_oserror *kern_error;
    int temp_oid;

    kern_error=toolbox_create_object(0,"Window",&temp_oid);

    if (kern_error != NULL)
    {
      wimp_report_error(kern_error, 0, 0);
      exit(1);
    } /* if */

    return temp_oid;
} /* oskb_create_window */


/*
 * oskb_calc_sprite_geom
 *
 * This calculates the geometry required to display the window, centred
 * horizontally, possibly with the keyboard extension. It uses the
 * dimensions of the sprites to display as the basis.
 *
 * NOTE THAT IT IS ESSENTIAL THAT THE SPRITE SIZES ARE CONSISTENT!!! E.G.
 * ALL WIDTHS MUST BE THE SAME, THE EXTENSION GOES UP FROM EXACTLY "0", AND
 * THE KEYBOARD GOES DOWN FROM EXACTLY "0"
 */

static void oskb_calc_sprite_geom(int show_extension,
                                  int *x_coord, int *keyb_width, int *keyb_height,
                                  int *ext_width, int *ext_height)
{
  _kernel_oserror *kern_err;
  SpriteParams sprite_info;

  /* Read sprite geometry - alpha and qwerty should be same size */
  kern_err=wimp_sprite_op(READ_SPRITE_INFO, "kb_alpha", &sprite_info);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  *keyb_width=sprite_info.r3;
  *keyb_height=sprite_info.r4;

  if (show_extension)
    kern_err=wimp_sprite_op(READ_SPRITE_INFO, "kb_extension", &sprite_info);
  else
    kern_err=wimp_sprite_op(READ_SPRITE_INFO, "kb_noext", &sprite_info);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  *ext_width=sprite_info.r3;
  *ext_height=sprite_info.r4;
  
  *x_coord = (oskb_read_xlimit() -
               (*keyb_width > *ext_width ? *keyb_width : *ext_width))
             * ( oskb_read_xeig() / 2 );

} /* oskb_calc_sprite_geom */

/*
 * oskb_read_curr_mode
 *
 * This function uses OS_ReadModeVariable function to return the requested
 * information about the screen properties. The parameter specifies which
 * subfunction to use in this call
 */

static int oskb_read_curr_mode(int mode_var)
{
  _kernel_swi_regs regs;
  _kernel_oserror *kern_err;
  int carry;

  regs.r[0] = -1; /* current mode */
  regs.r[1] = mode_var;
  kern_err = _kernel_swi_c(OS_ReadModeVariable, &regs, &regs, &carry);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */
  if (carry)
  {
    _kernel_oserror kern_error;
    kern_error.errnum = OSKB_BAD_MODE_INFO;
    strcpy(kern_error.errmess, "Bad Mode info to OS_ReadModeVariable");
    wimp_report_error(&kern_error, 0, 0);
    exit(1);
  } /* if */

  return regs.r[2];
} /* oskb_read_curr_mode */

/*
 * oskb_read_xeig
 *
 * Returns the scaling factor between screen co-ordinates and pixels in the
 * x direction
 */

int oskb_read_xeig(void)
{
  return (1 << oskb_read_curr_mode(OSKB_XEIG_FN));
} /* oskb_read_xeig */

/*
 * oskb_read_yeig
 *
 * Returns the scaling factor between screen co-ordinates and pixels in the
 * y direction
 */

int oskb_read_yeig(void)
{
  return (1 << oskb_read_curr_mode(OSKB_YEIG_FN));
} /* oskb_read_yeig */

/*
 * oskb_read_xlimit
 *
 * Returns the width of the screen in pixels
 */

int oskb_read_xlimit(void)
{
  return oskb_read_curr_mode(OSKB_XLIMIT_FN);
} /* oskb_read_xlimit */

/*
 * oskb_read_ylimit
 *
 * Returns the height of the screen in pixels
 */

int oskb_read_ylimit(void)
{
  return oskb_read_curr_mode(OSKB_YLIMIT_FN);
} /* oskb_read_ylimit */


/*
 * oskb_scroll_window_open
 *
 * This function makes the window scroll in the intended direction
 * until the bottom is on y=scroll_limit if scrolling up, or top is on
 * y=scroll_limit if scrolling down
 * It returns 1 if scrolling is still happening, 0 if its finished
 */

int oskb_scroll_window_open(object_id window_oid, int show_extension,
                            int scrollup, int scroll_point)
{
  int window_handle;
  _kernel_oserror *kern_err;
  WimpGetWindowStateBlock window_state; /* to store the current window state */
  WindowShowObjectBlock show_data;      /* to store the new geometry */
  static BBox window_bbox = {-1, -1, -1, -1};   /* final expected geometry of
                                                 * window - stored statically
                                                 * as recalculating it is a
                                                 * drag
                                                 */
  int keyb_width, keyb_height, ext_width, ext_height; /* sprite geometries */
  int xeig = oskb_read_xeig();
  int yeig = oskb_read_yeig();
  int return_code=1;

  /* First find out current window data */
  kern_err=window_get_wimp_handle(0, window_oid, &window_handle);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  window_state.window_handle=window_handle;
  kern_err=wimp_get_window_state(&window_state);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  /* Deal with initial case when the retrieved geometry is rubbish */

  if (window_bbox.xmin == -1) /* invalid - only true at start */
  {
    oskb_calc_sprite_geom(show_extension, &window_bbox.xmin,
                          &keyb_width, &keyb_height, &ext_width, &ext_height);

    /* Put the final expected geometry into window_bbox */
    window_bbox.xmax = ((keyb_width > ext_width ? keyb_width : ext_width) * xeig)
                        + window_bbox.xmin;

    window_bbox.ymin = yeig * (scrollup ? scroll_point
                                     : (scroll_point - keyb_height - ext_height));

    window_bbox.ymax = yeig * (scrollup ? (scroll_point + keyb_height + ext_height)
                                        : scroll_point);

    /* Now fill in show_data with new data to display */
    show_data.visible_area = window_bbox;
    if (scrollup)
    {
      show_data.visible_area.ymax = show_data.visible_area.ymin;
    } /* if */
    else
    {
      show_data.visible_area.ymin = show_data.visible_area.ymax;
    } /* else */
  } /* if */
  else
  {
    /* The "normal" case - i.e. increase size of window */
    /* Due to the wimp changing values, I don't just assign the whole structs */
    show_data.visible_area.xmin = window_bbox.xmin;
    show_data.visible_area.xmax = window_bbox.xmax;
    show_data.visible_area.ymax = window_state.visible_area.ymax;

    if (scrollup)
    {
      show_data.yscroll = yeig * ext_height;
      show_data.visible_area.ymin = window_bbox.ymin;
      show_data.visible_area.ymax += OSKB_SCROLL_RATE * yeig;

      /* Are we done? */
      if (show_data.visible_area.ymax >= window_bbox.ymax)
      {
        /* have to ensure the window gets drawn completely, so "round up"
         * to window_bbox.ymax */
        show_data.visible_area.ymax = window_bbox.ymax;
        return_code=0;
      } /* if */
    } /* if */
    else
    {
      show_data.visible_area.ymax = window_bbox.ymax;
      show_data.visible_area.ymin -= OSKB_SCROLL_RATE * yeig;

      /* To get scrolling going the right way, we subtract the difference between
       * the final height and the current height off the "normal" yscroll. It
       * is easiest to understand when you think of what yscroll should be at the
       * end points e.g. when showing just one pixel line, and when showing the
       * whole window */
      show_data.yscroll = yeig * ext_height -
                      (window_bbox.ymax - window_bbox.ymin) +
                      (show_data.visible_area.ymax - show_data.visible_area.ymin);

      /* Are we done? */
      if (show_data.visible_area.ymin <= window_bbox.ymin)
      {
        /* have to ensure the window gets drawn completely, so "round down"
         * to window_bbox.ymin */
        show_data.visible_area.ymin = window_bbox.ymin;
        show_data.yscroll = yeig * ext_height;
        return_code=0;
      } /* if */
    } /* else */
  } /* else */

  /* common to all */
  show_data.xscroll=0;
  show_data.behind=-1;

  kern_err=toolbox_show_object(0, window_oid, 1, &show_data, 0, 0);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  return(return_code);
} /* oskb_scroll_window_open */


/*
 * oskb_scroll_window_closed
 *
 * This function makes the window scroll in the intended direction
 * until the window closes
 * It returns 1 if scrolling is still happening, 0 if its finished
 */

int oskb_scroll_window_closed(object_id window_oid, int scrollup)
{
  int window_handle;
  _kernel_oserror *kern_err;
  WimpGetWindowStateBlock window_state; /* to store the current window state */
  WindowShowObjectBlock show_data;      /* to store the new geometry */
  int yeig = oskb_read_yeig();
  int return_code=1;

  kern_err=toolbox_hide_object(0, window_oid);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  return(0);

  /* First find out current window data */
  kern_err=window_get_wimp_handle(0, window_oid, &window_handle);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  window_state.window_handle=window_handle;
  kern_err=wimp_get_window_state(&window_state);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  /* Set up show data from retrieved info */
  show_data.visible_area=window_state.visible_area;
  show_data.xscroll=window_state.xscroll;
  show_data.yscroll=window_state.yscroll;
  show_data.behind=window_state.behind;

  if (scrollup)
  {
    show_data.visible_area.ymax -= OSKB_SCROLL_RATE * yeig;
    if ((show_data.visible_area.ymax - show_data.visible_area.ymin) <= 0)
    {
      show_data.visible_area.ymax = show_data.visible_area.ymin;
      return_code=0;
    } /* if */
  } /* if */
  else
  {
    show_data.visible_area.ymin += OSKB_SCROLL_RATE * yeig;
    show_data.yscroll -= OSKB_SCROLL_RATE * yeig;
    if ((show_data.visible_area.ymax - show_data.visible_area.ymin) <= 0)
    {
      show_data.visible_area.ymin = show_data.visible_area.ymax;
      return_code=0;
    } /* if */
  } /* else */

  kern_err=toolbox_show_object(0, window_oid, 1, &show_data, 0, 0);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  return(return_code);
} /* oskb_scroll_window_open */


/*
 * oskb_publish_window_geom
 *
 * Broadcast the size of our window geometry to all tasks
 */

void oskb_publish_window_geom(object_id window_oid)
{
  _kernel_oserror *kern_error;
  WimpMessage message;
  BBox *message_data;
  int window_handle;
  WimpGetWindowStateBlock window_state; /* to store the current window state */
  int dummy; /* not actually used - just to satisfy function call */

  /* First find out current window data */
  kern_error=window_get_wimp_handle(0, window_oid, &window_handle);
  if (kern_error)
  {
    wimp_report_error(kern_error, 0, 0);
    exit(1);
  } /* if */

  window_state.window_handle=window_handle;
  kern_error = wimp_get_window_state(&window_state);
  if (kern_error)
  {
    wimp_report_error(kern_error, 0, 0);
    exit(1);
  } /* if */

  /* construct broadcast message */

  message.hdr.size = sizeof(message.hdr) + sizeof(*message_data);
  message.hdr.your_ref = 0;
  message.hdr.action_code = OSKB_MESSAGE_NCKEYBOARD_WINDOWSIZE;

  /* Cast to Bbox so we can fill in fields automagically */
  message_data = (BBox *) &message.data;
  *message_data = window_state.visible_area;


  kern_error = wimp_send_message (Wimp_EUserMessage, &message, 0, 0, &dummy);
  if (kern_error)
  {
    wimp_report_error(kern_error, 0, 0);
    exit(1);
  } /* if */
} /* oskb_publish_window_geom */
