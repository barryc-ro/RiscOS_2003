/*
 * Name	    : windowops.c
 * Desc	    : Onscreen software keyboard for Acorn RCA NC
 * Author   : Jonathan Larmour
 * Date	    : 13th February 1997
 *
 * History
 * -------
 *
 *  03/9/98 ADH     Changes for Funai 3 (project 866) - see CVS logs for details
 *  17/4/97 OL      Add code to support both extension and no extension sprites
 *  20/3/97 JIFL    Exported oskb_read_[xy]limit and oskb_read_[xy]eig
 *  13/2/97 JIFL    Finished main coding
 *  05/2/97 JIFL    Created file
 *
 * Relevant Documents
 * ------------------
 *
 * 2107,738 	Owen Love   	RCA On-Screen Keyboard Software Functional Spec
 * 2107,217 	Julian Smith    Icon Highlighter Functional Spec
 *
 * (and, of course, later specifications for revisions to the software).
 *
 * Summary
 * -------
 * This module is used to provide the window related functionality to the
 * rest of the NCKeyboard app.
 *
 * © Acorn Computers Ltd. 1997
 */

/* INCLUDES */

/* System includes */
#include <stdlib.h>
#include <string.h>

/* Kernel/Wimp/Toolbox includes */
#include "kernel.h"
#include "swis.h"
#include "toolbox.h"
#include "wimp.h"
#include "wimplib.h"
#include "window.h"

/* Project includes */
#include "NCKeybd.h"
#include "windowops.h"

#ifdef FUNAI3
#include "oskbutils.h"
#endif


/* LOCAL FUNCTION PROTOTYPES */

static void oskb_calc_sprite_geom(int show_extension, oskb_layout_t layout,
                                  int *x_coord, int *keyb_width, int *keyb_height,
                                  int *ext_width, int *ext_height);

static int oskb_read_curr_mode(int mode_var);


/* FUNCTIONS */

/*
 * oskb_create_window
 *
 * This function uses the toolbox to create a window object - the main
 * window for the keyboard
 *
 */

int oskb_create_window(void)
{
    _kernel_oserror *kern_error;
    int temp_oid;

    kern_error=toolbox_create_object(0,"Window",&temp_oid);

    if (kern_error != NULL)
    {
      wimp_report_error(kern_error, 0, 0);
      exit(EXIT_FAILURE);
    } /* if */

    return temp_oid;
} /* oskb_create_window */


/*
 * oskb_calc_sprite_geom
 *
 * This calculates the geometry required to display the window, centred
 * horizontally, possibly with the keyboard extension. It uses the
 * dimensions of the (first layer) sprites to display as the basis.
 *
 * If FUNAI3 is NOT defined:
 *
 *   NOTE THAT IT IS ESSENTIAL THAT THE SPRITE SIZES ARE CONSISTENT!!! E.G.
 *   ALL WIDTHS MUST BE THE SAME, THE EXTENSION GOES UP FROM EXACTLY "0", AND
 *   THE KEYBOARD GOES DOWN FROM EXACTLY "0"
 *
 * else:
 *
 *   There is no extension toolbar (the show_extension parameter will be
 *   ignored). Sprites must be the same width, but can vary in height.
 *   They will always be plotted in the bottom left hand corner of the
 *   window which will be sized vertically to fit (but not horizontally).
 *   The window extent must be large enough to allow the visible area to
 *   grow to the required height. I recommend setting the minimum width
 *   and height of the window to be the width of all sprites and the
 *   height of the smallest, too, though this is non-essential.
 */

static void oskb_calc_sprite_geom(int show_extension, oskb_layout_t layout,
                                  int *x_coord, int *keyb_width, int *keyb_height,
                                  int *ext_width, int *ext_height)
{
  _kernel_oserror *kern_err;
  SpriteParams sprite_info;

  #ifdef FUNAI3

    char sprite[13];

    oskb_get_sprite_name(layout, sprite, sizeof(sprite));
    kern_err=wimp_sprite_op(READ_SPRITE_INFO, sprite, &sprite_info);

  #else

    /* Read sprite geometry - alpha and qwerty should be same size */
    kern_err=wimp_sprite_op(READ_SPRITE_INFO,
                            (layout == OSKB_ALPHA ? "kb_alpha" : "kb_qwerty"),
                            &sprite_info);

  #endif

  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  *keyb_width=sprite_info.r3;
  *keyb_height=sprite_info.r4;

  if (show_extension)
  {
    kern_err=wimp_sprite_op(READ_SPRITE_INFO, "kb_extension", &sprite_info);
    if (kern_err)
    {
      wimp_report_error(kern_err, 0, 0);
      exit(EXIT_FAILURE);
    } /* if */

    *ext_width=sprite_info.r3;
    *ext_height=sprite_info.r4;
  } /* if */
  else
  {
    *ext_width=*ext_height=0;
  } /* else */

  *x_coord = (oskb_read_xlimit() -
               (*keyb_width > *ext_width ? *keyb_width : *ext_width))
             * ( oskb_read_xeig() / 2 );

} /* oskb_calc_sprite_geom */

/*
 * oskb_read_curr_mode
 *
 * This function uses OS_ReadModeVariable function to return the requested
 * information about the screen properties. The parameter specifies which
 * subfunction to use in this call
 */

static int oskb_read_curr_mode(int mode_var)
{
  _kernel_swi_regs regs;
  _kernel_oserror *kern_err;
  int carry;

  regs.r[0] = -1; /* current mode */
  regs.r[1] = mode_var;
  kern_err = _kernel_swi_c(OS_ReadModeVariable, &regs, &regs, &carry);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */
  if (carry)
  {
    _kernel_oserror kern_error;
    kern_error.errnum = OSKB_BAD_MODE_INFO;
    strcpy(kern_error.errmess, "Bad Mode info to OS_ReadModeVariable");
    wimp_report_error(&kern_error, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  return regs.r[2];
} /* oskb_read_curr_mode */

/*
 * oskb_read_xeig
 *
 * Returns the scaling factor between screen co-ordinates and pixels in the
 * x direction
 */

int oskb_read_xeig(void)
{
  return (1 << oskb_read_curr_mode(OSKB_XEIG_FN));
} /* oskb_read_xeig */

/*
 * oskb_read_yeig
 *
 * Returns the scaling factor between screen co-ordinates and pixels in the
 * y direction
 */

int oskb_read_yeig(void)
{
  return (1 << oskb_read_curr_mode(OSKB_YEIG_FN));
} /* oskb_read_yeig */

/*
 * oskb_read_xlimit
 *
 * Returns the width of the screen in pixels
 */

int oskb_read_xlimit(void)
{
  return oskb_read_curr_mode(OSKB_XLIMIT_FN);
} /* oskb_read_xlimit */

/*
 * oskb_read_ylimit
 *
 * Returns the height of the screen in pixels
 */

int oskb_read_ylimit(void)
{
  return oskb_read_curr_mode(OSKB_YLIMIT_FN);
} /* oskb_read_ylimit */


/*
 * oskb_calc_final_position
 *
 * Work out what visible area coordinates and, for FUNAI3 builds,
 * vertical scroll offset should be used to fully show the given
 * keyboard layer.
 *
 * Pass the window ID, for non-FUNAI3 builds 1 to take account of
 * the extension toolbar else 0, the layout to consider, pointer
 * to a BBox to take the visible area, pointer to an int to take
 * the keyboard sprite width for the given layer and same for the
 * height, pointer to an int for the extension toolbar width and
 * height (will both be set to zero for non-FUNAI3 builds).
 *
 * Returns the vertical scroll offset (as a positive number) for
 * FUNAI3 builds, else zero.
 *
 * No pointers may be NULL, regardless of build.
 */

int oskb_calc_final_position(object_id window_oid, int show_extension,
                             oskb_layout_t layout, BBox * box,
                             int * keyb_width, int * keyb_height,
                             int * ext_width, int * ext_height)
{
  int xeig = oskb_read_xeig();
  int yeig = oskb_read_yeig();

  #ifdef FUNAI3

    int tallest, this, temp, layer;

    /* Get the given layer sprite information */

    oskb_calc_sprite_geom(show_extension,
                          layout,
                          &box->xmin,
                          keyb_width,
                          keyb_height,
                          ext_width,
                          ext_height);

    /*
     * The layers can change height. Not only should we find out
     * the sprite geometry of what we're starting with - layer 0 -
     * but we should also find out the tallest layer we have.
     */

    tallest = *keyb_height;

    for (layer = 0; layer < layers; layer++)
    {
      if (layer != layout)
      {
        oskb_calc_sprite_geom(0,
                              layer,
                              &temp,
                              &temp,
                              &this,
                              &temp,
                              &temp);

        if (this > tallest) tallest = this;
      }
    }

  #else

    oskb_calc_sprite_geom(show_extension,
                          layout,
                          &box->xmin,
                          keyb_width,
                          keyb_height,
                          ext_width,
                          ext_height);

  #endif

  /* Put the final expected geometry into window_bbox */

  box->xmax = ((*keyb_width > *ext_width ? *keyb_width : *ext_width) * xeig)
              + box->xmin;

  box->ymin = yeig * (scrollup ? scroll_point
                               : (scroll_point - *keyb_height - *ext_height));

  box->ymax = yeig * (scrollup ? (scroll_point + *keyb_height + *ext_height)
                               : scroll_point);

  #ifdef FUNAI3

    return (tallest - *keyb_height) << 1;

  #else

    return 0;

  #endif
}

/*
 * oskb_scroll_window_open
 *
 * This function makes the window scroll in the intended direction
 * until the bottom is on y=scroll_limit if scrolling up, or top is on
 * y=scroll_limit if scrolling down
 *
 * It returns 1 if scrolling is still happening, 0 if its finished
 */

int oskb_scroll_window_open(object_id window_oid, int show_extension,
                            int scrollup, int scroll_point)
{
  int window_handle;
  _kernel_oserror *kern_err;
  WimpGetWindowStateBlock window_state; /* to store the current window state */
  WindowShowObjectBlock show_data;      /* to store the new geometry */
  static BBox window_bbox = {-1, -1, -1, -1};   /* final expected geometry of
                                                 * window - stored statically
                                                 * as recalculating it is a
                                                 * drag
                                                 */
  int keyb_width, keyb_height, ext_width, ext_height; /* sprite geometries */
  int yeig = oskb_read_yeig();
  int return_code=1;

  #ifdef FUNAI3
    static int vshift; /* Vertical shift of visible area that we should show */
  #endif

  /* First find out current window data */
  kern_err=window_get_wimp_handle(0, window_oid, &window_handle);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  window_state.window_handle=window_handle;
  kern_err=wimp_get_window_state(&window_state);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  /* Deal with initial case when the retrieved geometry is rubbish */

  if (window_bbox.xmin == -1) /* invalid - only true at start */
  {
    #ifdef FUNAI3

      vshift = oskb_calc_final_position(window_oid,
                                        show_extension,
                                        0,
                                        &window_bbox,
                                        &keyb_width,
                                        &keyb_height,
                                        &ext_width,
                                        &ext_height);
    #else

      oskb_calc_final_position(window_oid,
                               show_extension,
                               OSKB_ALPHA,
                               &window_bbox,
                               &keyb_width,
                               &keyb_height,
                               &ext_width,
                               &ext_height);
    #endif

    /* Now fill in show_data with new data to display */
    show_data.visible_area = window_bbox;
    if (scrollup)
    {
      show_data.visible_area.ymax = show_data.visible_area.ymin;
    } /* if */
    else
    {
      show_data.visible_area.ymin = show_data.visible_area.ymax;
    } /* else */
  } /* if */
  else
  {
    /* The "normal" case - i.e. increase size of window */
    /* Due to the wimp changing values, I don't just assign the whole structs */
    show_data.visible_area.xmin = window_bbox.xmin;
    show_data.visible_area.xmax = window_bbox.xmax;
    show_data.visible_area.ymax = window_state.visible_area.ymax;

    if (scrollup)
    {
      show_data.yscroll = yeig * ext_height;
      show_data.visible_area.ymin = window_bbox.ymin;
      show_data.visible_area.ymax += OSKB_SCROLL_RATE * yeig;

      /* Are we done? */
      if (show_data.visible_area.ymax >= window_bbox.ymax)
      {
        /* have to ensure the window gets drawn completely, so "round up"
         * to window_bbox.ymax */
        show_data.visible_area.ymax = window_bbox.ymax;
        return_code=0;
      } /* if */
    } /* if */
    else
    {
      show_data.visible_area.ymax = window_bbox.ymax;
      show_data.visible_area.ymin -= OSKB_SCROLL_RATE * yeig;

      /* To get scrolling going the right way, we subtract the difference between
       * the final height and the current height off the "normal" yscroll. It
       * is easiest to understand when you think of what yscroll should be at the
       * end points e.g. when showing just one pixel line, and when showing the
       * whole window */
      show_data.yscroll = yeig * ext_height -
                      (window_bbox.ymax - window_bbox.ymin) +
                      (show_data.visible_area.ymax - show_data.visible_area.ymin);

      /* Are we done? */
      if (show_data.visible_area.ymin <= window_bbox.ymin)
      {
        /* have to ensure the window gets drawn completely, so "round down"
         * to window_bbox.ymin */
        show_data.visible_area.ymin = window_bbox.ymin;
        show_data.yscroll = yeig * ext_height;
        return_code=0;
      } /* if */
    } /* else */

    #ifdef FUNAI3

      /*
       * Correct for the fact that we plot sprites in the bottom left hand
       * corner of the window because layers extend upwards rather than
       * downwards and we need to keep underneath the right gadgets marking
       * key positions. These gadgets will be placed based on the tallest
       * key layout, and vshift will have been set earlier on based on this
       * too.
       */

      show_data.yscroll -= vshift;

    #endif

  } /* else */

  /* common to all */
  show_data.xscroll=0;
  show_data.behind=-1;

  kern_err=toolbox_show_object(0,
                               window_oid,
                               Toolbox_ShowObject_FullSpec,
                               &show_data,
                               NULL_ObjectId,
                               NULL_ComponentId);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  return(return_code);
} /* oskb_scroll_window_open */


/*
 * oskb_scroll_window_closed
 *
 * This function makes the window scroll in the intended direction
 * until the window closes
 * It returns 1 if scrolling is still happening, 0 if its finished
 */

int oskb_scroll_window_closed(object_id window_oid, int scrollup)
{
  int window_handle;
  _kernel_oserror *kern_err;
  WimpGetWindowStateBlock window_state; /* to store the current window state */
  WindowShowObjectBlock show_data;      /* to store the new geometry */
  int yeig = oskb_read_yeig();
  int return_code=1;

  kern_err=toolbox_hide_object(0, window_oid);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  return(0);

  /* First find out current window data */
  kern_err=window_get_wimp_handle(0, window_oid, &window_handle);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  window_state.window_handle=window_handle;
  kern_err=wimp_get_window_state(&window_state);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  /* Set up show data from retrieved info */
  show_data.visible_area=window_state.visible_area;
  show_data.xscroll=window_state.xscroll;
  show_data.yscroll=window_state.yscroll;
  show_data.behind=window_state.behind;

  if (scrollup)
  {
    show_data.visible_area.ymax -= OSKB_SCROLL_RATE * yeig;
    if ((show_data.visible_area.ymax - show_data.visible_area.ymin) <= 0)
    {
      show_data.visible_area.ymax = show_data.visible_area.ymin;
      return_code=0;
    } /* if */
  } /* if */
  else
  {
    show_data.visible_area.ymin += OSKB_SCROLL_RATE * yeig;
    show_data.yscroll -= OSKB_SCROLL_RATE * yeig;
    if ((show_data.visible_area.ymax - show_data.visible_area.ymin) <= 0)
    {
      show_data.visible_area.ymin = show_data.visible_area.ymax;
      return_code=0;
    } /* if */
  } /* else */

  kern_err=toolbox_show_object(0,
                               window_oid,
                               Toolbox_ShowObject_FullSpec,
                               &show_data,
                               NULL_ObjectId,
                               NULL_ComponentId);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  return(return_code);
} /* oskb_scroll_window_open */

/*
 * oskb_reopen_window (FUNAI3 only)
 *
 * Reopen the window, presumably because the keyboard sprite has
 * changed size. Maintains bottom x coordinate for -scrollup or
 * top y coordinate for -scrolldown.
 *
 * Works entirely on the globals (see NCKeybd.h); pass only
 * a component ID to reposition the mouse over (or pass
 * NULL_ComponentId to not bother).
 *
 * This should not be called if an extension toolbar is in use
 * (you can't have variable height layers and the toolbar).
 *
 */

#ifdef FUNAI3

void oskb_reopen_window(ComponentId reposition)
{
  WindowShowObjectBlock   show_data;
  _kernel_oserror       * kern_err;
  int                     keyb_width, keyb_height;
  int                     temp;

  show_data.yscroll = -oskb_calc_final_position(window_oid,
                                                0,
                                                oskb_layout,
                                                &show_data.visible_area,
                                                &keyb_width,
                                                &keyb_height,
                                                &temp,
                                                &temp);

  show_data.xscroll = 0;
  show_data.behind  = -1;

  kern_err = toolbox_show_object(0,
                                 window_oid,
                                 Toolbox_ShowObject_FullSpec,
                                 &show_data,
                                 NULL_ObjectId,
                                 NULL_ComponentId);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  }

  if (reposition != NULL_ComponentId)
  {
    char osw_data[9];
    BBox gb;

    if (
         !gadget_get_bbox(0,
                          window_oid,
                          reposition,
                          &gb)
       )
    {
      WimpGetPointerInfoBlock info;
      int                     iconlist[2];
      int                     movex, movey;

      movex = show_data.visible_area.xmin + show_data.xscroll +
              ((gb.xmax + gb.xmin) / 2);

      movey = show_data.visible_area.ymax - show_data.yscroll +
              ((gb.ymax + gb.ymin) / 2);

      /*
       * Only move the pointer if either of the function calls
       * return an error, or, if they've succeeded, we find that
       * the mouse is not over the gadget specified by 'reposition'.
       * This stops the mouse being moved when the keyboard extends
       * upwards so that the mouse doesn't move off the button in
       * the first place - it looks silly if the mouse pointer
       * keeps jiggling about.
       */

      if (
           wimp_get_pointer_info(&info) ||
           gadget_get_icon_list(0,
                                window_oid,
                                reposition,
                                iconlist,
                                sizeof(iconlist),
                                NULL) ||

           info.icon_handle != iconlist[0]
         )
      {
        osw_data[0] = 3; /* subfunction for "set pointer position" */
        osw_data[1] = movex & 0x00ff;        /* X LSB */
        osw_data[2] = (movex & 0xff00) >> 8; /* X MSB */
        osw_data[3] = movey & 0x00ff;        /* Y LSB */
        osw_data[4] = (movey & 0xff00) >> 8; /* Y MSB */
      }

      _kernel_osword(21, (int *) &osw_data[0]);
    }
  }

  #ifdef BOUND_MOUSE

    {
      char osw_data[9];

      /* set bounding box so that mouse can't escape window */
      osw_data[0] = 1; /* subfunction for "set mouse bounding box" */
      osw_data[1] = show_data.visible_area.xmin & 0x00ff;        /* xmin LSB */
      osw_data[2] = (show_data.visible_area.xmin & 0xff00) >> 8; /* xmin MSB */
      osw_data[3] = show_data.visible_area.ymin & 0x00ff;        /* ymin LSB */
      osw_data[4] = (show_data.visible_area.ymin & 0xff00) >> 8; /* ymin MSB */
      osw_data[5] = show_data.visible_area.xmax & 0x00ff;        /* xmax LSB */
      osw_data[6] = (show_data.visible_area.xmax & 0xff00) >> 8; /* xmax MSB */
      osw_data[7] = show_data.visible_area.ymax & 0x00ff;        /* ymax LSB */
      osw_data[8] = (show_data.visible_area.ymax & 0xff00) >> 8; /* ymax MSB */

      _kernel_osword(21, (int *) &osw_data[0]);
    }

  #endif

  return;

} /* oskb_reopen_window */

#endif

/*
 * oskb_publish_window_geom
 *
 * Broadcast the size of our window geometry to all tasks
 */

void oskb_publish_window_geom(object_id window_oid)
{
  _kernel_oserror *kern_error;
  WimpMessage message;
  BBox *message_data;
  int window_handle;
  WimpGetWindowStateBlock window_state; /* to store the current window state */
  int dummy; /* not actually used - just to satisfy function call */

  /* First find out current window data */
  kern_error=window_get_wimp_handle(0, window_oid, &window_handle);
  if (kern_error)
  {
    wimp_report_error(kern_error, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  window_state.window_handle=window_handle;
  kern_error = wimp_get_window_state(&window_state);
  if (kern_error)
  {
    wimp_report_error(kern_error, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  /* construct broadcast message */

  message.hdr.size = sizeof(message.hdr) + sizeof(*message_data);
  message.hdr.your_ref = 0;
  message.hdr.action_code = OSKB_MESSAGE_NCKEYBOARD_WINDOWSIZE;

  /* Cast to Bbox so we can fill in fields automagically */
  message_data = (BBox *) &message.data;
  *message_data = window_state.visible_area;


  kern_error = wimp_send_message (Wimp_EUserMessage, &message, 0, 0, &dummy);
  if (kern_error)
  {
    wimp_report_error(kern_error, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */
} /* oskb_publish_window_geom */
