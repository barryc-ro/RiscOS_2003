/*
 * Name	    : oskbutils.c
 * Desc	    : Onscreen software keyboard for Acorn RCA NC
 * Author   : Jonathan Larmour
 * Date	    : 13th February 1997
 *
 * History
 * -------
 *
 *  19/3/97 JIFL    Changed keyboard and caps sprite names
 *                  Removed comment about different starting mouse position
 *                    for with/without extension
 *                  Added mouse bounding box when setting mouse position,
 *                  and remove when unsetting
 *                  Added read/write CMOS when changing layout
 *  24/2/97 JIFL    Add strncasecmp and oskb_get_initial_layout() body so that
 *                  we read a system variable to get default keyboard layout
 *  13/2/97 JIFL    Finished main coding
 *  5/2/97  JIFL    Created file
 *
 * Relevant Documents
 * ------------------
 *
 * 2107,738 	Owen Love   	RCA On-Screen Keyboard Software Functional Spec
 * 2107,217 	Julian Smith    Icon Highlighter Functional Spec
 *
 * Summary
 * -------
 * This module is used to provide various utility functions that don't fit into
 * any other category
 *
 * © Acorn UK Ltd., 1997
 */

/* INCLUDES */

/* System includes */
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

/* Kernel/Wimp/Toolbox includes */
#include "kernel.h"
#include "wimplib.h"
#include "swis.h"
#include "gadgets.h"
#include "event.h"
#include "window.h"

/* Project includes */
#include "NCKeybd.h"
#include "windowops.h"
#include "oskbutils.h"
#include "handlers.h"
#include "nvram.h"

/* FUNCTIONS */

/* strncasecmp - just as in other systems - case insensitive strncmp */
int strncasecmp (const char *a, const char *b, int len)
{
    const char *p =a;
    const char *q =b;
    for(p=a, q=b; *p && *q && (p-a < len) && (q-b < len); p++, q++) {
	int diff = tolower(*p) - tolower(*q);
	if (diff) return diff;
    }
    if (p-a == len) return 0; /* reached len and no difference */
    if (*p) return 1;	/* p was longer than q */
    if (*q) return -1;	/* p was shorter than q */
    return 0;		/* Exact match */
}

/*
 * oskb_lookup_message_token
 *
 * This function uses the MessageTrans module to fetch tokens from the Messages
 * file. token is the token to look for, and the result is returned in outstr,
 * and will be truncated to strsize if necessary (to prevent overwriting past
 * the end of outstr)
 */
int oskb_lookup_message_token(char *token, char *outstr, int strsize)
{
  _kernel_swi_regs regs;
  extern MessagesFD oskb_messages;

  regs.r[0] = (int) &oskb_messages;
  regs.r[1] = (int) token;
  regs.r[2] = 0;

  if (!_kernel_swi(MessageTrans_Lookup, &regs, &regs))
  {
    strncpy(outstr,(char *) regs.r[2], strsize-1);
    outstr[ regs.r[3] >= strsize ? strsize-1 : regs.r[3] ] = '\0';
    return regs.r[3];
  }
  return 0;
} /* oskb_lookup_message_token */



/*
 * oskb_insert_key
 *
 * This function inserts a key into the keyboard buffer
 */

void oskb_insert_key(int key, int shiftstate)
{
  int osb_err;
  _kernel_oserror kern_error;
  _kernel_oserror *kern_err_p;
  _kernel_swi_regs regs;

  key = shiftstate ? toupper(key) : key;

  /* warn iconhigh that a key is about to be inserted */
  regs.r[0] = 0;
  kern_err_p = _kernel_swi(OSKB_SWI_ICONHIGH_IGNORE_NEXT_CHAR, &regs, &regs);
  if (kern_err_p)
  {
    wimp_report_error(kern_err_p, 0, 0);
  } /* if */

/* I use osbyte fn 138, and not Wimp_process_key because the latter
 * curiously removes and reorders keys in the keyboard buffer according
 * to unknown criteria! This way, they come through un-modified
 */
  osb_err=_kernel_osbyte(OSB_INSERT_CHAR_FN, 0, key);

  if (osb_err & 0xffff0000) /* mask out corrupted registers */
  {
    kern_error.errnum=OSKB_KEY_ERR;
    sprintf(kern_error.errmess, "Error inserting key \"%c\", code %d", key,
     	    osb_err);
    wimp_report_error(&kern_error,0,0);
  }
} /* oskb_insert_key */

/*
 * oskb_update_caps_lock
 *
 * This function updates the caps lock graphic and store the new
 * caps lock state in a system variable so it is saved across separate
 * executions
 */

void oskb_update_caps_lock(object_id window_oid, int capsstate)
{
  _kernel_oserror *kern_err;
  _kernel_swi_regs regs;

  /* update sprite on screen to show caps lock set/unset */
  kern_err=button_set_value(0, window_oid, RES_CAPS_GADGET_ID,
  			    capsstate ? "kb_caps" : "");
  if (kern_err)
  {
    wimp_report_error(kern_err,0,0);
  } /* if */

  /* Store capsstate in system variable should we quit and start again */
  regs.r[0] = (int) OSKB_CAPS_ENV_VAR_NAME;
  regs.r[1] = (int) (capsstate ? "on" : "off");
  regs.r[2] = strlen((char *) regs.r[1]);
  regs.r[3] = 0;
  regs.r[4] = 0; /* string type */
  kern_err = _kernel_swi(OS_SetVarVal, &regs, &regs);

  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */
} /* oskb_update_caps_lock */

/*
 * oskb_get_initial_layout
 *
 * This function retrieves the initial keyboard layout,
 * either alphabetic, or qwerty, from CMOS
 */

oskb_layout_t oskb_get_initial_layout(void)
{
  int cmos_setting, err;
  oskb_layout_t key_layout = OSKB_QWERTY;

  if ( _swix(NVRAM_Read, _INR(0,2)|_OUT(0), OSKB_NVRAM_TAG, &cmos_setting, 0, &err) == NULL )
        if ( (err >= 0) && cmos_setting ) key_layout = OSKB_ALPHA;

  return key_layout;
} /* oskb_get_initial_layout */

/*
 * oskb_change_keyboard
 *
 * This function changes the keyboard graphic and writes the new layout to CMOS
 */

void oskb_change_keyboard(oskb_layout_t layout, object_id window_oid)
{
  _kernel_oserror *kern_err;
  extern oskb_layout_t oskb_layout;
  int new_cmos_setting;

  new_cmos_setting = (layout == OSKB_ALPHA) ? 1 : 0;

  /* update graphic */
  kern_err=button_set_value(0, window_oid, RES_KEYB_GADGET_ID,
                            new_cmos_setting ? "kb_alpha" : "kb_qwerty");
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  /* write back to CMOS */
  _swix( NVRAM_Write, _INR(0,2), OSKB_NVRAM_TAG, &new_cmos_setting, 0 );

  /* update global */
  oskb_layout = layout;
} /* oskb_change_keyboard */

/*
 * oskb_deal_with_exit
 *
 * This function handles a clean exit. Scroll window closed, tell people
 * we've closed, and deregister our usage of other modules
 */

void oskb_deal_with_exit(object_id window_oid, int scrollup)
{
  _kernel_oserror   *kern_error;
  int               event_code;
  WimpPollBlock     poll_block;
  int               dummy;      /* not used - merely to satisfy call */
  WimpMessage       message;    /* for close message */
  extern void       *poll_word; /* so we can stop KeyWatch */
  char osw_data[9];             /* data for OS_Word call */
  int xscreenlimit, yscreenlimit; /* screen size */

  /* Stop iconhigh */

  oskb_stop_iconhigh();

  /* Stop keywatch - SJM: 14Mar97 protect against calling twice */
  if (poll_word)
  {
      oskb_stop_keywatch(poll_word);
      poll_word = 0;
  }

  /* Allow null events, and disallow pollword-nonzero events */
  event_set_mask(OSKB_DEFAULT_EVENT_MASK & ~Wimp_Poll_NullMask |
                 Wimp_Poll_PollWordNonZeroMask);

  /* SJM: 14Mar97 disable event handlers to stop re entry of this routine */
  event_deregister_message_handler(Wimp_MQuit, oskb_quit_message_handler, 0);
  event_deregister_message_handler(OSKB_MESSAGE_NCKEYBOARD_CLOSE,
                                   oskb_quit_message_handler, 0);
  event_deregister_toolbox_handler(-1, Window_HasBeenHidden,
                                   oskb_quit_event_handler, 0);
  event_deregister_wimp_handler(-1, Wimp_EMouseClick,oskb_click_handler, 0);

  
  while (oskb_scroll_window_closed(window_oid, scrollup))
  {
    kern_error = event_poll(&event_code, &poll_block, 0);
    if (kern_error)
    {
      wimp_report_error(kern_error, 0, 0);
      exit(1);
    } /* if */
  } /* while */

#ifdef BOUND_MOUSE

  /* set bounding box so that mouse is free to go */
  osw_data[0] = 1; /* subfunction for "set mouse bounding box" */
  osw_data[1] = 0x00;       /* xmin LSB */
  osw_data[2] = 0x00;       /* xmin MSB */
  osw_data[3] = 0x00;       /* ymin LSB */
  osw_data[4] = 0x00;       /* ymin MSB */
  xscreenlimit = oskb_read_xlimit() * oskb_read_xeig();
  yscreenlimit = oskb_read_ylimit() * oskb_read_yeig();
  osw_data[5] = xscreenlimit & 0xff;        /* xmax LSB */
  osw_data[6] = (xscreenlimit >> 8) & 0xff; /* xmax MSB */
  osw_data[7] = yscreenlimit & 0xff;        /* ymax LSB */
  osw_data[8] = (yscreenlimit >> 8) & 0xff; /* ymax MSB */

  _kernel_osword(21, (int *) &osw_data[0]);

#endif

  /* Tell people we've closed */

  message.hdr.size = sizeof(message.hdr);
  message.hdr.your_ref = 0;
  message.hdr.action_code = OSKB_MESSAGE_NCKEYBOARD_CLOSED;
  kern_error = wimp_send_message (Wimp_EUserMessage, &message, 0, 0, &dummy);
  if (kern_error)
  {
    wimp_report_error(kern_error, 0, 0);
    exit(1);
  } /* if */

  exit(0);
} /* deal_with_exit */

/*
 * oskb_check_caps_state
 *
 * This function retrieves the caps state from a system variable. This is
 * useful to maintain the caps lock state across different executions
 */

void oskb_check_caps_state(object_id window_oid, int *caps_state)
{
  _kernel_oserror *kern_err;
  _kernel_swi_regs regs;
  char value[20];

  /* set up default */
  *caps_state=OSKB_DEFAULT_CAPS_STATE;

  /* first check if the var is set */
  regs.r[0] = (int) OSKB_CAPS_ENV_VAR_NAME;
  regs.r[1] = (int) &value[0];
  regs.r[2] = -1;
  regs.r[3] = 0;
  regs.r[4] = 0;

  kern_err=_kernel_swi(OS_ReadVarVal, &regs, &regs);

  if (regs.r[2] != 0)
  {
    /* Now we actually read the var contents. */
     regs.r[0] = (int) OSKB_CAPS_ENV_VAR_NAME;
     regs.r[1] = (int) &value[0];
     regs.r[2] = sizeof(value);
     regs.r[3] = 0;
     regs.r[4] = 0;

     kern_err=_kernel_swi(OS_ReadVarVal, &regs, &regs);

     if (kern_err)
    {
      wimp_report_error(kern_err, 0, 0);
      exit(1);
    } /* if */

    if (regs.r[4] == 0) /* The var type is strings */
    {
      value[ regs.r[2] ] = '\0'; /* just in case */
      if (strncasecmp(&value[0], "on", 3) == 0)
      {
        *caps_state = 1;
      } /* if */
      else if (strncasecmp(&value[0], "off", 4) == 0)
      {
        *caps_state = 0;
      } /* else if */

      /* If its something other than "on" or "off" it stays at default */
    } /* if */
  } /* if */

  oskb_update_caps_lock(window_oid, *caps_state);
} /* oskb_check_caps_state */

/*
 * oskb_set_mouse_position
 *
 * This function sets the mouse position so that it is over the centre of the
 * keyboard when the app starts, and restricts it to the app window
 * The gadget IDs are configurable in NCKeybd.h
 */

void oskb_set_mouse_position(object_id window_oid, oskb_layout_t key_layout)
{
  _kernel_oserror *kern_err;
  int window_handle;                    /* wimp window handle */
  WimpGetWindowStateBlock window_state; /* to store the current window state */
  int startx, starty;                   /* pointer starting co-ordinates */
  BBox starting_gadget_bbox;            /* bbox of gadget to highlight */
  char osw_data[9];                      /* data for OS_Word call */

  /* First find out window handle */
  kern_err=window_get_wimp_handle(0, window_oid, &window_handle);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  window_state.window_handle=window_handle;
  kern_err=wimp_get_window_state(&window_state);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  /* Now find starting gadget geometry to work out start position */

  kern_err = gadget_get_bbox(0, window_oid,
                             (key_layout == OSKB_QWERTY) ? OSKB_DEFAULT_KEYB_Q_HIGHLIGHT
                                                         : OSKB_DEFAULT_KEYB_A_HIGHLIGHT,
                             &starting_gadget_bbox);

  startx = window_state.visible_area.xmin + window_state.xscroll +
           ((starting_gadget_bbox.xmax + starting_gadget_bbox.xmin) / 2);

  starty = window_state.visible_area.ymax - window_state.yscroll +
           ((starting_gadget_bbox.ymax + starting_gadget_bbox.ymin) / 2);

  osw_data[0] = 3; /* subfunction for "set pointer position" */
  osw_data[1] = startx & 0x00ff;        /* X LSB */
  osw_data[2] = (startx & 0xff00) >> 8; /* X MSB */
  osw_data[3] = starty & 0x00ff;        /* Y LSB */
  osw_data[4] = (starty & 0xff00) >> 8; /* Y MSB */

  _kernel_osword(21, (int *) &osw_data[0]);

#ifdef BOUND_MOUSE

  /* set bounding box so that mouse can't escape window */
  osw_data[0] = 1; /* subfunction for "set mouse bounding box" */
  osw_data[1] = window_state.visible_area.xmin & 0x00ff;        /* xmin LSB */
  osw_data[2] = (window_state.visible_area.xmin & 0xff00) >> 8; /* xmin MSB */
  osw_data[3] = window_state.visible_area.ymin & 0x00ff;        /* ymin LSB */
  osw_data[4] = (window_state.visible_area.ymin & 0xff00) >> 8; /* ymin MSB */
  osw_data[5] = window_state.visible_area.xmax & 0x00ff;        /* xmax LSB */
  osw_data[6] = (window_state.visible_area.xmax & 0xff00) >> 8; /* xmax MSB */
  osw_data[7] = window_state.visible_area.ymax & 0x00ff;        /* ymax LSB */
  osw_data[8] = (window_state.visible_area.ymax & 0xff00) >> 8; /* ymax MSB */

  _kernel_osword(21, (int *) &osw_data[0]);
  
#endif

} /* oskb_set_mouse_position */

/*
 * oskb_start_iconhigh
 *
 * This starts iconhigh operation, i.e. allowing the IR handset to pretend to
 * be a mouse. See iconhigh's functional spec
 */

void oskb_start_iconhigh(void)
{
  _kernel_oserror *kern_err=NULL;
  _kernel_swi_regs regs;

  regs.r[0] = OSKB_ICONHIGH_START_FLAGS;

  kern_err = _kernel_swi(OSKB_SWI_ICONHIGH_START, &regs, &regs);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

} /* oskb_start_iconhigh */

/*
 * oskb_stop_iconhigh
 *
 * This function stops iconhigh
 */

void oskb_stop_iconhigh(void)
{
  _kernel_oserror *kern_err=NULL;
  _kernel_swi_regs regs;

  regs.r[0] = 0;

  kern_err = _kernel_swi(OSKB_SWI_ICONHIGH_STOP, &regs, &regs);

  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */
} /* oskb_stop_iconhigh */

/*
 * oskb_start_keywatch
 *
 * This functions registers with the keywatch module and returns a wimp
 * pollword to use
 */

void *oskb_start_keywatch(void)
{
  _kernel_oserror *kern_err;
  _kernel_swi_regs regs;

  regs.r[0] = 0;
  kern_err = _kernel_swi(OSKB_SWI_KEYWATCH_REGISTER, &regs, &regs);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

  return( (void *) regs.r[0]);
} /* oskb_start_keywatch */


/*
 * oskb_stop_keywatch
 *
 * This functions deregisters with the keywatch module
 */

void oskb_stop_keywatch(void *pollword)
{
  _kernel_oserror *kern_err;
  _kernel_swi_regs regs;

  regs.r[0] = (int) pollword;
  kern_err = _kernel_swi(OSKB_SWI_KEYWATCH_DEREGISTER, &regs, &regs);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(1);
  } /* if */

} /* oskb_stop_keywatch */
