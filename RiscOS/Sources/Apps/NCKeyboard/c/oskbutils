/*
 * Name     : oskbutils.c
 * Desc     : Onscreen software keyboard for Acorn RCA NC
 * Author   : Jonathan Larmour
 * Date     : 13th February 1997
 *
 * History
 * -------
 *
 *  03/9/98 ADH     Changes for Funai 3 (project 866) - see CVS logs for details
 *  19/3/97 JIFL    Changed keyboard and caps sprite names
 *                  Removed comment about different starting mouse position
 *                    for with/without extension
 *                  Added mouse bounding box when setting mouse position,
 *                  and remove when unsetting
 *                  Added read/write CMOS when changing layout
 *  24/2/97 JIFL    Add strncasecmp and oskb_get_initial_layout() body so that
 *                  we read a system variable to get default keyboard layout
 *  13/2/97 JIFL    Finished main coding
 *  05/2/97 JIFL    Created file
 *
 * Relevant Documents
 * ------------------
 *
 * 2107,738     Owen Love       RCA On-Screen Keyboard Software Functional Spec
 * 2107,217     Julian Smith    Icon Highlighter Functional Spec
 *
 * (and, of course, later specifications for revisions to the software).
 *
 * Summary
 * -------
 * This module is used to provide various utility functions that don't fit into
 * any other category
 *
 * © Acorn Computers Ltd. 1997
 */

/* INCLUDES */

/* System includes */
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

/* Kernel/Wimp/Toolbox includes */
#include "kernel.h"
#include "wimplib.h"
#include "swis.h"
#include "gadgets.h"
#include "event.h"
#include "window.h"

/* Project includes */
#include "NCKeybd.h"
#include "windowops.h"
#include "oskbutils.h"
#include "handlers.h"
#include "nvram.h"

/* VARIABLES */

/* Set-up an internal poll word - for use if KeyWatch module is not present */
static int internal_poll_word = 0;

/* FUNCTIONS */

/* strncasecmp - just as in other systems - case insensitive strncmp */
int strncasecmp (const char *a, const char *b, int len)
{
    const char *p =a;
    const char *q =b;
    for(p=a, q=b; *p && *q && (p-a < len) && (q-b < len); p++, q++) {
        int diff = tolower(*p) - tolower(*q);
        if (diff) return diff;
    }
    if (p-a == len) return 0; /* reached len and no difference */
    if (*p) return 1;   /* p was longer than q */
    if (*q) return -1;  /* p was shorter than q */
    return 0;           /* Exact match */
}

/*
 * oskb_lookup_message_token
 *
 * This function uses the MessageTrans module to fetch tokens from the Messages
 * file. token is the token to look for, and the result is returned in outstr,
 * and will be truncated to strsize if necessary (to prevent overwriting past
 * the end of outstr)
 */
int oskb_lookup_message_token(char *token, char *outstr, int strsize)
{
  _kernel_swi_regs regs;

  regs.r[0] = (int) &oskb_messages;
  regs.r[1] = (int) token;
  regs.r[2] = 0;

  if (!_kernel_swi(MessageTrans_Lookup, &regs, &regs))
  {
    strncpy(outstr,(char *) regs.r[2], strsize-1);
    outstr[ regs.r[3] >= strsize ? strsize-1 : regs.r[3] ] = '\0';
    return regs.r[3];
  }
  return 0;
} /* oskb_lookup_message_token */



/*
 * oskb_insert_key
 *
 * This function inserts a key into the keyboard buffer
 */

void oskb_insert_key(int key, int shiftstate)
{
  int osb_err;
  _kernel_oserror kern_error;
  _kernel_oserror *kern_err_p;
  _kernel_swi_regs regs;

  key = shiftstate ? toupper(key) : key;

  if (key == 0 || (key > 127 && key < 256))
  {
    /* warn iconhigh that a byte is about to be inserted */
    regs.r[0] = 0;
    kern_err_p = _kernel_swi(OSKB_SWI_ICONHIGH_IGNORE_NEXT_CHAR, &regs, &regs);
    if (kern_err_p)
    {
      wimp_report_error(kern_err_p, 0, 0);
    } /* if */

    osb_err=_kernel_osbyte(OSB_INSERT_CHAR_FN, 0, 0);
  }

  /* warn iconhigh that a[nother] byte is about to be inserted */
  regs.r[0] = 0;
  kern_err_p = _kernel_swi(OSKB_SWI_ICONHIGH_IGNORE_NEXT_CHAR, &regs, &regs);
  if (kern_err_p)
  {
    wimp_report_error(kern_err_p, 0, 0);
  } /* if */

  osb_err=_kernel_osbyte(OSB_INSERT_CHAR_FN, 0, key);

  if (osb_err & 0xffff0000) /* mask out corrupted registers */
  {
    kern_error.errnum=OSKB_KEY_ERR;
    sprintf(kern_error.errmess, "Error inserting key \"%c\", code %d", key,
            osb_err);
    wimp_report_error(&kern_error,0,0);
  }
} /* oskb_insert_key */

/*
 * oskb_update_caps_lock
 *
 * This function updates the caps lock graphic and store the new
 * caps lock state in a system variable so it is saved across separate
 * executions
 */

void oskb_update_caps_lock(object_id window_oid, int capsstate)
{
  _kernel_oserror *kern_err;
  _kernel_swi_regs regs;

  if (mm_caps_gadget != NULL_ComponentId)
  {
    /* update sprite on screen to show caps lock set/unset */
    kern_err=button_set_value(0, window_oid, mm_caps_gadget,
                              capsstate ? "kb_caps" : "");
    if (kern_err)
    {
      wimp_report_error(kern_err,0,0);
    } /* if */

    /* Store capsstate in system variable should we quit and start again */
    regs.r[0] = (int) OSKB_CAPS_ENV_VAR_NAME;
    regs.r[1] = (int) (capsstate ? "on" : "off");
    regs.r[2] = strlen((char *) regs.r[1]);
    regs.r[3] = 0;
    regs.r[4] = 0; /* string type */
    kern_err = _kernel_swi(OS_SetVarVal, &regs, &regs);

    if (kern_err)
    {
      wimp_report_error(kern_err, 0, 0);
      exit(EXIT_FAILURE);
    } /* if */
  }
} /* oskb_update_caps_lock */

/*
 * oskb_update_shift_key
 *
 * This function updates the shift key graphic.
 */

void oskb_update_shift_key(object_id window_oid, int shiftstate)
{
  _kernel_oserror *kern_err;

  if (mm_shift_gadget != NULL_ComponentId)
  {
    /* update sprite on screen to show shift key set/unset */
    kern_err=button_set_value(0, window_oid, mm_shift_gadget,
                              shiftstate ? "kb_shift" : "");
    if (kern_err)
    {
      wimp_report_error(kern_err,0,0);
    } /* if */
  }

} /* oskb_update_shift_key */

/*
 * oskb_get_initial_layout
 *
 * This function retrieves the initial keyboard layout,
 * either alphabetic, or qwerty, from CMOS
 */

oskb_layout_t oskb_get_initial_layout(void)
{
  int cmos_setting, err;

  #ifdef FUNAI3

    oskb_layout_t key_layout = 0;

    if (
         !_swix(NVRAM_Read,
                _INR(0,2) | _OUT(0),

                OSKB_NVRAM_TAG,
                &cmos_setting,
                0,

                &err)
       )
    {
      if (
           (err >= 0) &&
           cmos_setting
         )
         key_layout = cmos_setting;
    }

  #else

    oskb_layout_t key_layout = OSKB_QWERTY;

    if ( _swix(NVRAM_Read, _INR(0,2)|_OUT(0), OSKB_NVRAM_TAG, &cmos_setting, 0, &err) == NULL )
          if ( (err >= 0) && cmos_setting ) key_layout = OSKB_ALPHA;

  #endif

  return key_layout;
} /* oskb_get_initial_layout */

/*
 * oskb_get_sprite_name (FUNAI3 only)
 *
 * Return the sprite name for the given layer (FUNAI3 builds only).
 * Pass the layer number, a buffer to write the sprite name into,
 * and the size of the buffer.
 */

#ifdef FUNAI3

void oskb_get_sprite_name(oskb_layout_t layer, char * buffer, int buffer_size)
{
  char token[sizeof("Sprite") + 10];
  char sprite[13];

  if (buffer_size < 2) return;

  /* Look up the sprite name from the Messages file */

  sprintf(token, "Sprite%d", layer);

  if (!oskb_lookup_message_token(token, sprite, sizeof(sprite)))
  {
    /* Fall back to hard-wired defaults */

    if (layer == 1) strncpy(sprite, "kb_alpha",  sizeof(sprite) - 1);
    else            strncpy(sprite, "kb_qwerty", sizeof(sprite) - 1);
  }

  if (buffer_size > strlen(sprite))
  {
    strcpy(buffer, sprite);
  }
  else
  {
    *buffer = '\0';
    strncat(buffer, sprite, buffer_size);
  }

  return;
}

#endif


/*
 * oskb_change_keyboard
 *
 * This function changes the keyboard graphic and writes the new layout to CMOS
 * - the last parameter is either NULL_ComponentId or the ID of a gadget to
 * reposition the mouse pointer over, should the layer that is being switched
 * to be of a different size to the current one.
 */

void oskb_change_keyboard(oskb_layout_t layout, object_id window_oid,
                          ComponentId reposition)
{
  int new_cmos_setting;
  _kernel_oserror *kern_err;

  #ifdef FUNAI3

    SpriteParams spr;
    char         sprite[13];
    int          old_height = 0;
    int          new_height = 0;

    /* What is the current sprite size? */

    oskb_get_sprite_name(oskb_layout, sprite, sizeof(sprite));

    if (
         !wimp_sprite_op(READ_SPRITE_INFO,
                         sprite,
                         &spr)
       )
       old_height = spr.r4;

    /* What is the new sprite size? */

    oskb_get_sprite_name(layout, sprite, sizeof(sprite));

    if (
         !wimp_sprite_op(READ_SPRITE_INFO,
                         sprite,
                         &spr)
       )
       new_height = spr.r4;

    new_cmos_setting = layout;
    kern_err         = button_set_value(0,
                                        window_oid,
                                        RES_KEYB_GADGET_ID,
                                        sprite);

  #else

    new_cmos_setting = (layout == OSKB_ALPHA) ? 1 : 0;

    /* update graphic */
    kern_err=button_set_value(0, window_oid, RES_KEYB_GADGET_ID,
                              new_cmos_setting ? "kb_alpha" : "kb_qwerty");

  #endif

  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  /* write back to CMOS */
  _swix( NVRAM_Write, _INR(0,2), OSKB_NVRAM_TAG, &new_cmos_setting, 0 );

  /* update global */
  oskb_layout = layout;

  #ifdef FUNAI3

    /* Do we need to resize the window? */

    if (
         old_height &&
         new_height &&
         old_height != new_height
       )
    {
      oskb_reopen_window(reposition);
      oskb_publish_window_geom(window_oid);
    }

  #endif

} /* oskb_change_keyboard */

/*
 * oskb_deal_with_exit
 *
 * This function handles a clean exit. Scroll window closed, tell people
 * we've closed, and deregister our usage of other modules
 */

void oskb_deal_with_exit(object_id window_oid, int scrollup)
{
  _kernel_oserror   *kern_error;
  int               event_code;
  WimpPollBlock     poll_block;
  int               dummy;      /* not used - merely to satisfy call */
  WimpMessage       message;    /* for close message */

#ifdef BOUND_MOUSE
  char osw_data[9];             /* data for OS_Word call */
  int xscreenlimit, yscreenlimit; /* screen size */
#endif

  /* Stop iconhigh */

  oskb_stop_iconhigh();

  /* Stop keywatch - SJM: 14Mar97 protect against calling twice */
  if (poll_word)
  {
      oskb_stop_keywatch(poll_word);
      poll_word = 0;
  }

  /* Allow null events, and disallow pollword-nonzero events */
  event_set_mask(OSKB_DEFAULT_EVENT_MASK & ~Wimp_Poll_NullMask |
                 Wimp_Poll_PollWordNonZeroMask);

  /* SJM: 14Mar97 disable event handlers to stop re entry of this routine */
  event_deregister_message_handler(Wimp_MQuit, oskb_quit_message_handler, 0);
  event_deregister_message_handler(OSKB_MESSAGE_NCKEYBOARD_CLOSE,
                                   oskb_quit_message_handler, 0);
  event_deregister_toolbox_handler(-1, Window_HasBeenHidden,
                                   oskb_quit_event_handler, 0);
  event_deregister_wimp_handler(-1, Wimp_EMouseClick,oskb_click_handler, 0);

  oskb_play_sound(OSKB_SOUND_KBDOWN);

  while (oskb_scroll_window_closed(window_oid, scrollup))
  {
    kern_error = event_poll(&event_code, &poll_block, 0);
    if (kern_error)
    {
      wimp_report_error(kern_error, 0, 0);
      exit(EXIT_FAILURE);
    } /* if */
  } /* while */

#ifdef BOUND_MOUSE

  /* set bounding box so that mouse is free to go */
  osw_data[0] = 1; /* subfunction for "set mouse bounding box" */
  osw_data[1] = 0x00;       /* xmin LSB */
  osw_data[2] = 0x00;       /* xmin MSB */
  osw_data[3] = 0x00;       /* ymin LSB */
  osw_data[4] = 0x00;       /* ymin MSB */
  xscreenlimit = oskb_read_xlimit() * oskb_read_xeig();
  yscreenlimit = oskb_read_ylimit() * oskb_read_yeig();
  osw_data[5] = xscreenlimit & 0xff;        /* xmax LSB */
  osw_data[6] = (xscreenlimit >> 8) & 0xff; /* xmax MSB */
  osw_data[7] = yscreenlimit & 0xff;        /* ymax LSB */
  osw_data[8] = (yscreenlimit >> 8) & 0xff; /* ymax MSB */

  _kernel_osword(21, (int *) &osw_data[0]);

#endif

  /* Tell people we've closed */

  message.hdr.size = sizeof(message.hdr);
  message.hdr.your_ref = 0;
  message.hdr.action_code = OSKB_MESSAGE_NCKEYBOARD_CLOSED;
  kern_error = wimp_send_message (Wimp_EUserMessage, &message, 0, 0, &dummy);
  if (kern_error)
  {
    wimp_report_error(kern_error, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  exit(EXIT_SUCCESS);
} /* deal_with_exit */

/*
 * oskb_check_caps_state
 *
 * This function retrieves the caps state from a system variable. This is
 * useful to maintain the caps lock state across different executions
 */

void oskb_check_caps_state(object_id window_oid, int *caps_state)
{
  _kernel_oserror *kern_err;
  _kernel_swi_regs regs;
  char value[20];

  /* set up default */
  *caps_state=OSKB_DEFAULT_CAPS_STATE;

  /* first check if the var is set */
  regs.r[0] = (int) OSKB_CAPS_ENV_VAR_NAME;
  regs.r[1] = (int) &value[0];
  regs.r[2] = -1;
  regs.r[3] = 0;
  regs.r[4] = 0;

  kern_err=_kernel_swi(OS_ReadVarVal, &regs, &regs);

  if (regs.r[2] != 0)
  {
    /* Now we actually read the var contents. */
     regs.r[0] = (int) OSKB_CAPS_ENV_VAR_NAME;
     regs.r[1] = (int) &value[0];
     regs.r[2] = sizeof(value);
     regs.r[3] = 0;
     regs.r[4] = 0;

     kern_err=_kernel_swi(OS_ReadVarVal, &regs, &regs);

     if (kern_err)
    {
      wimp_report_error(kern_err, 0, 0);
      exit(EXIT_FAILURE);
    } /* if */

    if (regs.r[4] == 0) /* The var type is strings */
    {
      value[ regs.r[2] ] = '\0'; /* just in case */
      if (strncasecmp(&value[0], "on", 3) == 0)
      {
        *caps_state = 1;
      } /* if */
      else if (strncasecmp(&value[0], "off", 4) == 0)
      {
        *caps_state = 0;
      } /* else if */

      /* If its something other than "on" or "off" it stays at default */
    } /* if */
  } /* if */

  oskb_update_caps_lock(window_oid, *caps_state);
} /* oskb_check_caps_state */

/*
 * oskb_set_mouse_position
 *
 * This function sets the mouse position so that it is over the centre of the
 * default gadget for the given layer when the app starts, and restricts it to
 * the app window if BOUND_MOUSE is defined.
 *
 */

void oskb_set_mouse_position(object_id window_oid, oskb_layout_t key_layout)
{
  _kernel_oserror *kern_err;
  int window_handle;                    /* wimp window handle */
  WimpGetWindowStateBlock window_state; /* to store the current window state */
  int startx, starty;                   /* pointer starting co-ordinates */
  BBox starting_gadget_bbox;            /* bbox of gadget to highlight */
  char osw_data[9];                      /* data for OS_Word call */

  /* First find out window handle */
  kern_err=window_get_wimp_handle(0, window_oid, &window_handle);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  window_state.window_handle=window_handle;
  kern_err=wimp_get_window_state(&window_state);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

  /* Now find starting gadget geometry to work out start position */

  #ifdef FUNAI3

    kern_err = gadget_get_bbox(0,
                               window_oid,
                               default_gadgets[key_layout],
                               &starting_gadget_bbox);

  #else

    kern_err = gadget_get_bbox(0, window_oid,
                               (key_layout == OSKB_QWERTY) ? mm_qwerty_gadget
                                                           : mm_alpha_gadget,
                               &starting_gadget_bbox);

  #endif

  startx = window_state.visible_area.xmin + window_state.xscroll +
           ((starting_gadget_bbox.xmax + starting_gadget_bbox.xmin) / 2);

  starty = window_state.visible_area.ymax - window_state.yscroll +
           ((starting_gadget_bbox.ymax + starting_gadget_bbox.ymin) / 2);

  osw_data[0] = 3; /* subfunction for "set pointer position" */
  osw_data[1] = startx & 0x00ff;        /* X LSB */
  osw_data[2] = (startx & 0xff00) >> 8; /* X MSB */
  osw_data[3] = starty & 0x00ff;        /* Y LSB */
  osw_data[4] = (starty & 0xff00) >> 8; /* Y MSB */

  _kernel_osword(21, (int *) &osw_data[0]);

#ifdef BOUND_MOUSE

  /* set bounding box so that mouse can't escape window */
  osw_data[0] = 1; /* subfunction for "set mouse bounding box" */
  osw_data[1] = window_state.visible_area.xmin & 0x00ff;        /* xmin LSB */
  osw_data[2] = (window_state.visible_area.xmin & 0xff00) >> 8; /* xmin MSB */
  osw_data[3] = window_state.visible_area.ymin & 0x00ff;        /* ymin LSB */
  osw_data[4] = (window_state.visible_area.ymin & 0xff00) >> 8; /* ymin MSB */
  osw_data[5] = window_state.visible_area.xmax & 0x00ff;        /* xmax LSB */
  osw_data[6] = (window_state.visible_area.xmax & 0xff00) >> 8; /* xmax MSB */
  osw_data[7] = window_state.visible_area.ymax & 0x00ff;        /* ymax LSB */
  osw_data[8] = (window_state.visible_area.ymax & 0xff00) >> 8; /* ymax MSB */

  _kernel_osword(21, (int *) &osw_data[0]);

#endif

} /* oskb_set_mouse_position */

/*
 * oskb_start_iconhigh
 *
 * This starts iconhigh operation, i.e. allowing the IR handset to pretend to
 * be a mouse. See iconhigh's functional spec
 */

void oskb_start_iconhigh(void)
{
  _kernel_oserror *kern_err=NULL;
  _kernel_swi_regs regs;

  regs.r[0] = OSKB_ICONHIGH_START_FLAGS;

  kern_err = _kernel_swi(OSKB_SWI_ICONHIGH_START, &regs, &regs);
  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */

} /* oskb_start_iconhigh */

/*
 * oskb_stop_iconhigh
 *
 * This function stops iconhigh
 */

void oskb_stop_iconhigh(void)
{
  _kernel_oserror *kern_err=NULL;
  _kernel_swi_regs regs;

  regs.r[0] = 0;

  kern_err = _kernel_swi(OSKB_SWI_ICONHIGH_STOP, &regs, &regs);

  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  } /* if */
} /* oskb_stop_iconhigh */

/*
 * oskb_start_keywatch
 *
 * This functions registers with the keywatch module and returns a wimp
 * pollword to use
 */

void *oskb_start_keywatch(void)
{
  _kernel_oserror *kern_err;
  _kernel_swi_regs regs;

  regs.r[0] = 0;
  kern_err = _kernel_swi(OSKB_SWI_KEYWATCH_REGISTER, &regs, &regs);
  if (kern_err)
  {
    return( (void *) &internal_poll_word);
  } /* if */

  return( (void *) regs.r[0]);
} /* oskb_start_keywatch */

/*
 * oskb_stop_keywatch
 *
 * This functions deregisters with the keywatch module
 */

void oskb_stop_keywatch(void *pollword)
{
  _kernel_oserror *kern_err;
  _kernel_swi_regs regs;

  regs.r[0] = (int) pollword;
  kern_err = _kernel_swi(OSKB_SWI_KEYWATCH_DEREGISTER, &regs, &regs);
} /* oskb_stop_keywatch */

/*
 * oskb_play_sound
 *
 * Plays a sound using the SoundFX module
 *
 */

void oskb_play_sound(int sound)
{
  _kernel_oserror *kern_err;
  _kernel_swi_regs regs;

  regs.r[0] = 0;
  regs.r[1] = sound;
  kern_err = _kernel_swi(OSKB_SWI_SOUNDFX_PLAY, &regs, &regs);
/*  if (kern_err)
  {
    wimp_report_error(kern_err, 0, 0);
    exit(EXIT_FAILURE);
  }
*/

} /* oskb_play_sound */
