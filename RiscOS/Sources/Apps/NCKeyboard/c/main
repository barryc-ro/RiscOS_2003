/*
 * Name     : main.c
 * Desc     : Onscreen software keyboard for Acorn RCA NC
 * Author   : Jonathan Larmour
 * Date     : 13th February 1997
 *
 * History
 * -------
 *
 *  03/9/98 ADH     Changes for Funai 3 (project 866) - see CVS logs for details
 *  18/8/98 SBF     Removed the code to read whether there is a keyboard
 *                  extension, due to it breaking the "-browser" command line
 *                  option.
 *  18/2/98 OL      Changed the code to allow NCKeyboard to work without
 *                  KeyWatch module having to be present.
 *  12/8/97 MM      Added code to read the default keys to highlight from the
 *                  Messages file rather than being hard coded
 *  08/8/97 MM      Added code to read whether their is a keyboard extension
 *                  line above the main keyboard from the Messages file rather
 *                  rather than being hard coded
 *  17/4/97 OL      Add code to display either extension or noextension sprite
 *  10/3/97 JIFL    Removed Wimp_MPreQuit handler as unnecessary
 *  13/2/97 JIFL    Finished main coding
 *  05/2/97 JIFL    Created file
 *
 * Relevant Documents
 * ------------------
 *
 * 2107,738     Owen Love       RCA On-Screen Keyboard Software Functional Spec
 * 2107,217     Julian Smith    Icon Highlighter Functional Spec
 *
 * (and, of course, later specifications for revisions to the software).
 *
 * Summary
 * -------
 * This is the main module to implement a software keyboard that allows
 * the IR remote control to control a keyboard display. An Icon Highlighter
 * module (see IconHigh module spec initially for the RCA version of the NC,
 * doc ref. 2107,217/FS) provides input in the form of artificial mouse clicks.
 *
 * This is the main application. There is also an associated module called
 * KeyWatch which watches for key presses and toggles a wimp pollword it has
 * supplied to allow the onscreen keyboard to exit when a _real_ keyboard is
 * used
 *
 * © Acorn Computers Ltd. 1997
 */

/* System includes */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>

/* Toolbox/wimp includes */
#include "wimp.h"
#include "toolbox.h"
#include "event.h"
#include "wimplib.h"
#include "window.h"

/* Project includes */
#include "NCKeybd.h"
#include "windowops.h"
#include "oskbutils.h"
#include "handlers.h"


/* Globals (all exported at the end of  NCKeybd.h) */

object_id       window_oid;         /* main window's object ID */
MessagesFD      oskb_messages;      /* handle to messages file */
oskb_layout_t   oskb_layout;        /* current keyboard layout style */
int             oskb_capsstate;     /* whether CAPS LOCK has been pressed */
int             scrollup = 1;       /* default is to scroll up from bottom of
                                     * screen */
int             scroll_point = 0;   /* y coord reference for scrolling */
void          * poll_word;          /* wimp poll word so we can tell if a key has
                                     * been pressed. The value is retrieved from
                                     * the KeyWatch module */
int             mm_caps_gadget;
int             mm_shift_gadget;
int             mm_ex_back_gadget;

#ifdef FUNAI3
  int           layers;             /* Number of layers in use */
  int         * default_gadgets;    /* malloc block with default gadget numbers */
#else
  int           mm_alpha_gadget;
  int           mm_qwerty_gadget;
#endif

/* FUNCTIONS */

/*
 * oskb_process_args
 *
 * This function processes the command line arguments
 */

void oskb_process_args(int argc, char **argv, int *show_extension)
{
  int count; /* boring counting variable */

  for (count=1; count < argc; count++)
  {
    if (strcmp(argv[count],"-extension") == 0)
    {
      if ((++count < argc) &&        /* make sure there is another argument */
          (strcmp(argv[count], "browser") == 0)) /* only valid extension */
      {
        *show_extension=1;
      } /* if */
    } /* if */

    if (strcmp(argv[count],"-scrollup") == 0)
    {
      if (++count < argc) /* make sure there is another argument */
      {
        scrollup=1;
        scroll_point=atoi(argv[count]);
      } /* if */
    } /* if */
    if (strcmp(argv[count],"-scrolldown") == 0)
    {
      if (++count < argc) /* make sure there is another argument */
      {
        scrollup=0;
        scroll_point=atoi(argv[count]);
      } /* if */
    } /* if */
  } /* for */
} /* oskb_process_args */

/* Exit handler called on quiting application - unset system variable */
static void exit_handler(void)
{
  _kernel_oscli("UnSet NCKeybd$Running");
}

/*
 * main
 */

int main(int argc, char *argv[])
{
    int             toolbox_events[] = { Window_HasBeenHidden, 0 },
                    wimp_messages[] = { OSKB_MESSAGE_NCKEYBOARD_CLOSE, 0 } ,
                    event_code;
    WimpPollBlock   poll_block;
    IdBlock         id_block;
    _kernel_oserror *kern_error = NULL;
    int             show_extension=0; /* default is not to show keyboard
                                       * extension */
    int             scrolling=1; /* whether we are scrolling or not */
    char            mm_buffer[24];

    #ifdef FUNAI3
      unsigned int  event_mask;
    #endif

    /* Set NCKeybd$Running system variable to TRUE */
    _kernel_oscli("Set NCKeybd$Running TRUE");

    /* Set up the locale for the currently selected territory */
    setlocale(LC_ALL, "");

    /* Add exit handler to unset system variable on quiting application */
    atexit(exit_handler);

    /* parse command line arguments */
    oskb_process_args(argc, argv, &show_extension);

    /* register ourselves with the Toolbox */

    kern_error = toolbox_initialise (0, WimpVersion, &wimp_messages[0],
                                     &toolbox_events[0], "<NCKeybd$Dir>",
                                     &oskb_messages, &id_block, 0, 0, 0);
    if (kern_error != NULL)
    {
      wimp_report_error(kern_error, 0, 0);
      exit(EXIT_FAILURE);
    } /* if */

    #ifdef FUNAI3

      /* How many layers do we have? */

      oskb_lookup_message_token("Layers:2", mm_buffer, sizeof(mm_buffer) - 1);
        layers = atoi(mm_buffer);
        if (layers < 1) layers = 1;

    #endif

    /* Read the gadget ID details from the message file */

    #ifdef FUNAI3

      default_gadgets = malloc(sizeof(int) * layers);
      if (!default_gadgets) exit(EXIT_FAILURE); // ** Needs proper error handling!

      /*
       * Default gadgets
       */

      {
        char token[sizeof("GadgetNo") + 10]; /* 10 = Longest a +ve 32-bit int can be in decimal */
        int  l;

        for (l = 0; l < layers; l++)
        {
          sprintf(token, "GadgetNo%d\n", l);
          if (!oskb_lookup_message_token(token, mm_buffer, sizeof(mm_buffer) - 1))
          {
            /* Backwards compatibility... */

            if (l == 0)
            {
              if (oskb_lookup_message_token("GadgetNoQ", mm_buffer, sizeof(mm_buffer) - 1))
                default_gadgets[l] = atoi(mm_buffer);
              else
                default_gadgets[l] = RES_KEYB_GADGET_ID;
            }
            else if (l == 1)
            {
              if (oskb_lookup_message_token("GadgetNoA", mm_buffer, sizeof(mm_buffer) - 1))
                default_gadgets[l] = atoi(mm_buffer);
              else
                default_gadgets[l] = RES_KEYB_GADGET_ID;
            }
            else default_gadgets[l] = RES_KEYB_GADGET_ID;
          }
          else
          {
            default_gadgets[l] = atoi(mm_buffer);
          }
        }
      }

    #else

      if (oskb_lookup_message_token("GadgetNoQ", mm_buffer, sizeof(mm_buffer) - 1))
        mm_qwerty_gadget = atoi(mm_buffer);
      else
        mm_qwerty_gadget = RES_KEYB_GADGET_ID;

      if (oskb_lookup_message_token("GadgetNoA", mm_buffer, sizeof(mm_buffer) - 1))
        mm_alpha_gadget = atoi(mm_buffer);
      else
        mm_alpha_gadget = RES_KEYB_GADGET_ID;

    #endif

    /* Extension toolbar */

    if (oskb_lookup_message_token("GadgetNoEB", mm_buffer, sizeof(mm_buffer) - 1))
      mm_ex_back_gadget = atoi(mm_buffer);
    else
      mm_ex_back_gadget = NULL_ComponentId;

    /* Caps Lock and Shift gadgets */

    if (oskb_lookup_message_token("GadgetNoCL", mm_buffer, sizeof(mm_buffer) - 1))
      mm_caps_gadget = atoi(mm_buffer);
    else
      mm_caps_gadget = NULL_ComponentId;

    if (oskb_lookup_message_token("GadgetNoSh", mm_buffer, sizeof(mm_buffer) - 1))
      mm_shift_gadget = atoi(mm_buffer);
    else
      mm_shift_gadget = NULL_ComponentId;

    /* Create window */
    window_oid=oskb_create_window();

    /* Set initial keyboard type */
    oskb_change_keyboard(oskb_get_initial_layout(),
                         window_oid,
                         NULL_ComponentId);

    /* check initial caps lock state */
    oskb_check_caps_state(window_oid, &oskb_capsstate);

    /* remove extension to get rid of anomalies from overlaps */
    if (!show_extension && mm_ex_back_gadget != NULL_ComponentId)
      window_remove_gadget(0, window_oid, mm_ex_back_gadget);

    /*
     * initialise the event library.
     */

    event_initialise (&id_block);

    /* allow null events so we can scroll */
    event_set_mask (OSKB_DEFAULT_EVENT_MASK & ~Wimp_Poll_NullMask);

    /*
     * register handler for toolbox event 1,
     * which is generated by the 'Quit' option on the
     * iconbar menu.  Also register message handlers
     * to quit properly when quit messages are
     * received from the wimp.
     */

    event_register_message_handler(Wimp_MQuit, oskb_quit_message_handler, 0);
    event_register_message_handler(OSKB_MESSAGE_NCKEYBOARD_CLOSE,
                                   oskb_quit_message_handler, 0);
    event_register_toolbox_handler(-1, Window_HasBeenHidden,
                                   oskb_quit_event_handler, 0);
    event_register_wimp_handler(-1, Wimp_EMouseClick,oskb_click_handler, 0);
    event_register_wimp_handler(-1, Wimp_EPollWordNonZero,
                                oskb_pollword_handler, 0);
    event_register_wimp_handler(-1, Wimp_EPointerEnteringWindow, oskb_ptrenter_handler, 0);

    /* Get pollword from keywatch so we can tell if a key is pressed */
    poll_word = oskb_start_keywatch();

    #ifdef FUNAI3

      if (!poll_word)
      {
        event_mask = OSKB_DEFAULT_EVENT_MASK & ~Wimp_Poll_PollWord;
        event_set_mask(event_mask & ~Wimp_Poll_NullMask);
      }
      else
      {
        event_mask = OSKB_DEFAULT_EVENT_MASK;
      }

    #endif

    /*
     * poll loop
     */

    oskb_play_sound(OSKB_SOUND_KBUP);

    while (!kern_error)
    {
        /* Scroll window */
        if (scrolling)
        {
            if (!oskb_scroll_window_open(window_oid, show_extension,
                                         scrollup, scroll_point))
            {
              /* Turn off null events, and disable future scrolling */

              #ifdef FUNIA3
                event_set_mask(event_mask);
              #else
                event_set_mask(OSKB_DEFAULT_EVENT_MASK);
              #endif

              scrolling=0;

              /* Tell everyone our window size and position */
              oskb_publish_window_geom(window_oid);

              /* start iconhigh */
              oskb_start_iconhigh();

              /* set mouse position */
              oskb_set_mouse_position(window_oid, oskb_layout);

            } /* if */
        } /* if */
        kern_error = event_poll (&event_code, &poll_block, poll_word);
    } /* while */

    wimp_report_error(kern_error,0,0);

} /* main */
