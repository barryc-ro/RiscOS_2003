/*
 * Name     : main.c
 * Desc     : Onscreen software keyboard for Acorn RCA NC
 * Author   : Jonathan Larmour
 * Date     : 13th February 1997
 *
 * History
 * -------
 *
 *  01/09/00 MJR     Enabled No scrolling for the onscreen keyboard if
 *                   selected in th messages file.
 *
 *  10/12/98 ADH     Idiot detection code - GadgetNoCL, GadgetNoSh and
 *                   GadgetNoEB may be 0 in old builds, meaning "no
 *                   gadget" - should of course read -1. If the token
 *                   "AllowZeroIDs" is not in Messages, these values will
 *                   be corrected to -1. Use "AllowZeroIDs" if you really
 *                   do want to set a component ID of 0!
 *  20/10/98 ADH     IME support for Funai 3
 *  03/09/98 ADH     Changes for Funai 3 (project 866) - see CVS logs for details
 *  18/08/98 SBF     Removed the code to read whether there is a keyboard
 *                   extension, due to it breaking the "-browser" command line
 *                   option.
 *  18/02/98 OL      Changed the code to allow NCKeyboard to work without
 *                   KeyWatch module having to be present.
 *  12/08/97 MM      Added code to read the default keys to highlight from the
 *                   Messages file rather than being hard coded
 *  08/08/97 MM      Added code to read whether their is a keyboard extension
 *                   line above the main keyboard from the Messages file rather
 *                   rather than being hard coded
 *  17/04/97 OL      Add code to display either extension or noextension sprite
 *  10/03/97 JIFL    Removed Wimp_MPreQuit handler as unnecessary
 *  13/02/97 JIFL    Finished main coding
 *  05/02/97 JIFL    Created file
 *
 * Relevant Documents
 * ------------------
 *
 * 2107,738     Owen Love       RCA On-Screen Keyboard Software Functional Spec
 * 2107,217     Julian Smith    Icon Highlighter Functional Spec
 *
 * (and, of course, later specifications for revisions to the software).
 *
 * Summary
 * -------
 * This is the main module to implement a software keyboard that allows
 * the IR remote control to control a keyboard display. An Icon Highlighter
 * module (see IconHigh module spec initially for the RCA version of the NC,
 * doc ref. 2107,217/FS) provides input in the form of artificial mouse clicks.
 *
 * This is the main application. There is also an associated module called
 * KeyWatch which watches for key presses and toggles a wimp pollword it has
 * supplied to allow the onscreen keyboard to exit when a _real_ keyboard is
 * used
 *
 * © Acorn Computers Ltd. 1997
 */

/* System includes */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>

/* Toolbox/wimp includes */
#include "wimp.h"
#include "toolbox.h"
#include "event.h"
#include "wimplib.h"
#include "window.h"

/* Project includes */
#include "NCKeybd.h"
#include "windowops.h"
#include "oskbime.h"
#include "oskbutils.h"
#include "handlers.h"
#include "Debuglib/Debuglib.h"


/* Globals (all exported at the end of  NCKeybd.h) */

object_id       window_oid;         /* main window's object ID */
MessagesFD      oskb_messages;      /* handle to messages file */
oskb_layout_t   oskb_layout;        /* current keyboard layout style */
int             oskb_capsstate;     /* whether CAPS LOCK has been pressed */
int             scrollup = 1;       /* default is to scroll up from bottom of
                                     * screen */
int             scroll_point = 0;   /* y coord reference for scrolling */
int             scrolling_windows = TRUE;  /* Window scrolling variable */
void          * poll_word = NULL;   /* wimp poll word so we can tell if a key has
                                     * been pressed. The value is retrieved from
                                     * the KeyWatch module */
int             mm_caps_gadget;
int             mm_shift_gadget;
int             mm_ex_back_gadget;

int             task_handle;
unsigned int    event_mask = OSKB_DEFAULT_EVENT_MASK;


#ifdef DEBUGLIB
  debug_device DebugOutputDevice = FILE_OUTPUT;
#endif /* DEBUGLIB */



void        * oskb_sprite_pool;   /* From Toolbox_Initialise */

int           layers;             /* Number of layers in use */
int           toolbar_mode = 0;   /* Toolbar or full size mode */
ComponentId * default_gadgets;    /* malloc block with default gadget numbers */

int           ime_support_on = 0; /* Do we support the IME or not? */
int           ime_mode;           /* Current IME mode */

ComponentId   ime_lock_indicator;
ComponentId   ime_cycle_mode;     /* IME control button IDs */
ComponentId   ime_on_off;


/* FUNCTIONS */


/*
 * oskb_process_args
 *
 * This function processes the command line arguments
 */

void oskb_process_args(int argc, char **argv, int *show_extension)
{
  int count; /* boring counting variable */

  dprintf(("","oskb_process_args()\n"));

  for (count=1; count < argc; count++)
  {
    if (strcmp(argv[count],"-extension") == 0)
    {
      if ((++count < argc) &&        /* make sure there is another argument */
          (strcmp(argv[count], "browser") == 0)) /* only valid extension */
      {
        *show_extension=1;
      } /* if */
    } /* if */

    if (strcmp(argv[count],"-scrollup") == 0)
    {
      if (++count < argc) /* make sure there is another argument */
      {
        scrollup=1;
        scroll_point=atoi(argv[count]);
      } /* if */
    } /* if */
    if (strcmp(argv[count],"-scrolldown") == 0)
    {
      if (++count < argc) /* make sure there is another argument */
      {
        scrollup=0;
        scroll_point=atoi(argv[count]);
      } /* if */
    } /* if */

    if (strcmp(argv[count],"-toolbar") == 0) toolbar_mode = 1;

  } /* for */
} /* oskb_process_args */


/* Exit handler called on quiting application - unset system variable */
static void exit_handler(void)
{
  _kernel_oscli("UnSet NCKeybd$Running");
}


/*
 * oskbmain_poll_real_states
 *
 * Part of a hacky scheme to poll the keyboard and IME
 * states and update the front-end to reflect them. Used
 * in the absence of appropriate service calls etc. to
 * tell NCKeyboard when states are changed underneath it.
 */

#ifdef FUNAI3_POLL

  #include "kernel.h"
  #include "swis.h"

  static int oskbmain_poll_real_states(int eventcode, WimpPollBlock * event,
                                       IdBlock * id_block, void * handle)
  {
    _kernel_oserror     * e;

    static unsigned int   ime_flags = 0xffffffff;
    static unsigned int   kana_lock = 0;

    int                   changed   = 0;
    unsigned int          flags;

    dprintf(("","oskbmain_poll_real_states()\n"));

    /* See if the IME flags have changed */

    if (
         !_swix(OSKB_IME_CONFIGURE,
                _INR(0, 2) | _OUT(1),

                OSKB_IME_CONFIGURE_REASON_FLAGS,
                0,
                0xffffffff,

                &flags)
       )
    {
      if (flags != ime_flags) ime_flags = flags, changed = 1;
    }

    /* See if the Kana / Romaji lock state has changed */

    if (
         !_swix(OS_Byte,
                _INR(0,2) | _OUT(1),

                202, /* Read/write keyboard status byte */
                0,   /* - see PRM 1-883                 */
                255,

                &flags)
       )
    {
      if (!!(flags & (1u<<OSKB_IME_LOCK_BIT)) == !!(OSKB_IME_LOCK_IS_ROMAJI))
      {
        if (kana_lock) kana_lock = 0, changed = 1;
      }
      else
      {
        if (!kana_lock) kana_lock = 1, changed = 1;
      }
    }

    /* Show the new state if something changed */

    if (changed)
    {
      e = oskbime_reflect(0);

      /* Report any errors but continue afterwards */

      if (e) wimp_report_error(e, 0, 0);
    }

    /* Never claim null events...! */

    return 0;
  }

#endif


/*
 * main
 */

int main(int argc, char *argv[])
{
    int             toolbox_events[] = {
                                         Window_HasBeenHidden,
                                         0
                                       },

                    wimp_messages[]  = {
                                         OSKB_MESSAGE_NCKEYBOARD_CLOSE,
                                         OSKB_MESSAGE_NCKEYBOARD_CONTROL,
                                         Wimp_MDeviceClaim,
                                         Message_Service,
                                         Message_UpCall,

                                         0
                                       },
                    event_code;

    WimpPollBlock   poll_block;
    IdBlock         id_block;
    _kernel_oserror *kern_error = NULL;
    int             show_extension=0; /* default is not to show keyboard
                                       * extension */

    int             scrolling = 1;    // variable used when scrolling enabled

    int             window_open = 0;  // variable used when scrolling disabled

    char            mm_buffer[24];



    /* Set NCKeybd$Running system variable to TRUE */
    _kernel_oscli("Set NCKeybd$Running TRUE");

#ifdef DEBUGLIB
    debug_initialise ("OSKBlog", "izipfs:$.OSKBlog", "");
    debug_atexit ();
    debug_output_device (DebugOutputDevice);   /* Output debug info via pdebug */
    debug_set_stamp_debug(TRUE);
#endif /* DEBUGLIB */

    /* Set up the locale for the currently selected territory */
    setlocale(LC_ALL, "");

    /* Add exit handler to unset system variable on quiting application */
    atexit(exit_handler);

    /* parse command line arguments */
    oskb_process_args(argc, argv, &show_extension);

    /* register ourselves with the Toolbox */

    kern_error = toolbox_initialise(0,
                                    WimpVersion,
                                    wimp_messages,
                                    toolbox_events,
                                    "<NCKeybd$Dir>",
                                    &oskb_messages,
                                    &id_block,
                                    0,
                                    &task_handle,
                                    &oskb_sprite_pool);

    if (kern_error != NULL)
    {
      wimp_report_error(kern_error, 0, 0);
      exit(EXIT_FAILURE);
    }

    /* How many layers do we have? */

    oskb_lookup_message_token("Layers:2", mm_buffer, sizeof(mm_buffer));

    layers = atoi(mm_buffer);
    if (layers < 1) layers = 1;

    /* Read the gadget ID details from the message file */

    default_gadgets = malloc(sizeof(ComponentId) * layers);
    if (!default_gadgets) exit(EXIT_FAILURE); // ** Needs proper error handling!

    /*
     * Default gadgets
     */

    {
      char token[sizeof("GadgetNo") + 10]; /* 10 = Longest a +ve 32-bit int can be in decimal */
      int  l;

      for (l = 0; l < layers; l++)
      {
        sprintf(token, "GadgetNo%d\n", l);
        if (!oskb_lookup_message_token(token, mm_buffer, sizeof(mm_buffer)))
        {
          /* Backwards compatibility... */

          if (l == 0)
          {
            if (oskb_lookup_message_token("GadgetNoQ", mm_buffer, sizeof(mm_buffer)))
              default_gadgets[l] = (ComponentId) atoi(mm_buffer);
            else
              default_gadgets[l] = RES_KEYB_GADGET_ID;
          }
          else if (l == 1)
          {
            if (oskb_lookup_message_token("GadgetNoA", mm_buffer, sizeof(mm_buffer)))
              default_gadgets[l] = (ComponentId) atoi(mm_buffer);
            else
              default_gadgets[l] = RES_KEYB_GADGET_ID;
          }
          else default_gadgets[l] = RES_KEYB_GADGET_ID;
        }
        else
        {
          default_gadgets[l] = (ComponentId) atoi(mm_buffer);
        }
      }
    }

    /*
     * IME support gadgets. All three must be defined in the Messages
     * file to enable IME support.
     */

    if (oskb_lookup_message_token("GadgetNoLI", mm_buffer, sizeof(mm_buffer)))
    {
      ime_lock_indicator = (ComponentId) atoi(mm_buffer);

      if (oskb_lookup_message_token("GadgetNoCM", mm_buffer, sizeof(mm_buffer)))
      {
        ime_cycle_mode = (ComponentId) atoi(mm_buffer);

        if (oskb_lookup_message_token("GadgetNoOO", mm_buffer, sizeof(mm_buffer)))
        {
          ime_on_off     = (ComponentId) atoi(mm_buffer);
          ime_support_on = 1;
        }
      }
    }

    if (!ime_support_on)
    {
      /* Can't open as a toolbar unless there's IME support */

      toolbar_mode = 0;
    }

    /* Extension toolbar */

    if (oskb_lookup_message_token("GadgetNoEB", mm_buffer, sizeof(mm_buffer)))
      mm_ex_back_gadget = atoi(mm_buffer);
    else
      mm_ex_back_gadget = NULL_ComponentId;

    /* Caps Lock and Shift gadgets */

    if (oskb_lookup_message_token("GadgetNoCL", mm_buffer, sizeof(mm_buffer)))
      mm_caps_gadget = atoi(mm_buffer);
    else
      mm_caps_gadget = NULL_ComponentId;

    if (oskb_lookup_message_token("GadgetNoSh", mm_buffer, sizeof(mm_buffer)))
      mm_shift_gadget = atoi(mm_buffer);
    else
      mm_shift_gadget = NULL_ComponentId;

    /*
     * Idiot detection.
     *
     * Older Messages files may say '0' meaning no component, but
     * of course ID 0 is valid; you should say '-1' if that's what
     * you mean. So override GadgetNoCL, GadgetNoSh and GadgetNoEB
     * if they are zero and the special token "AllowZeroIDs" is
     * not present in the Messages file (the token value is
     * irrelevant, it just needs to be present).
     */

    if (!oskb_lookup_message_token("AllowZeroIDs", mm_buffer, sizeof(mm_buffer)))
    {
      if (mm_ex_back_gadget == 0) mm_ex_back_gadget = NULL_ComponentId;
      if (mm_caps_gadget    == 0) mm_caps_gadget    = NULL_ComponentId;
      if (mm_shift_gadget   == 0) mm_shift_gadget   = NULL_ComponentId;
    }

    /* Create window */
    window_oid=oskb_create_window();

    /* Set initial keyboard type */
    oskb_change_keyboard(oskb_get_initial_layout(),
                         -1,
                         window_oid,
                         NULL_ComponentId);

    /* Ensure IME control buttons are up to date */
    if (ime_support_on) oskbime_reflect(0);

    /* check initial caps lock state */
    oskb_check_caps_state(window_oid, &oskb_capsstate);

    /* remove extension to get rid of anomalies from overlaps */
    if (!show_extension && mm_ex_back_gadget != NULL_ComponentId)
      window_remove_gadget(0, window_oid, mm_ex_back_gadget);

    /*
     * initialise the event library.
     */

    event_initialise (&id_block);

    /* allow null events so we can scroll */

    event_mask &= ~Wimp_Poll_NullMask;
    event_set_mask(event_mask);

    /* Register various event handlers */

    event_register_message_handler(Wimp_MQuit,
                                   oskb_quit_message_handler, 0);
    event_register_message_handler(OSKB_MESSAGE_NCKEYBOARD_CLOSE,
                                   oskb_quit_message_handler, 0);

    event_register_wimp_handler(-1, Wimp_EMouseClick,
                                oskb_click_handler, 0);
    event_register_wimp_handler(-1, Wimp_EPollWordNonZero,
                                oskb_pollword_handler, 0);

    event_register_toolbox_handler(-1, Window_HasBeenHidden,
                                   oskb_quit_event_handler, 0);

    event_register_wimp_handler(-1, Wimp_EUserMessageAcknowledge,
                                oskb_ack_handler, 0);

    event_register_message_handler(OSKB_MESSAGE_NCKEYBOARD_CONTROL,
                                   oskb_control_message_handler, 0);
    event_register_message_handler(Message_Service,
                                   oskb_service_message_handler, 0);
    event_register_message_handler(Message_UpCall,
                                   oskb_upcall_message_handler, 0);

    if (!oskbutils_taskmodule_reg()) atexit(oskbutils_taskmodule_dereg);

    /*
     * If not told not to (sic), get a poll word from KeyWatch so
     * we know when a key is pressed and can quit automatically.
     */

    if (
         !oskb_lookup_message_token("NoKeyWatch", mm_buffer, sizeof(mm_buffer)) ||
         strncmp(mm_buffer, "yes", 3)
       )
       poll_word = oskb_start_keywatch();

    if (!poll_word)
    {
      event_mask &= ~Wimp_Poll_PollWord;
      event_set_mask(event_mask);
    }


    /* Lookup in the messages file whether scrolling is enabled or not
       Default value is Yes if no entry found !!! */

    if (oskb_lookup_message_token("KeyboardScrolling", mm_buffer,
                                                       sizeof(mm_buffer) ) )
    {
      if ( !strcmp(mm_buffer, "yes") ) scrolling_windows = TRUE;
      if ( !strcmp(mm_buffer, "no") )  scrolling_windows = FALSE;
    }

    // default case where no entry found in messages file.
    else
    {
      scrolling_windows = TRUE;
    }

    /*
     * poll loop
     */

    if (!toolbar_mode)
    {
        oskb_play_sound(OSKB_SOUND_KBUP);
    }

    while (!kern_error)
    {

        // if Scrolling not selected just open the window !!

        if (!scrolling_windows && !window_open)
        {
          oskb_window_open(window_oid, show_extension);

          /* Turn off null events and disable future scrolling */
          event_mask |= Wimp_Poll_NullMask;
          event_set_mask(event_mask);


          /* now look for pointer entering to enable iconhigh */
          event_register_wimp_handler(-1, Wimp_EPointerEnteringWindow,
                                          oskb_ptrenter_handler, 0);

          /* Tell everyone our window size and position */
          oskb_publish_window_geom(window_oid);

          /* set mouse position */

          if (!toolbar_mode)
          {
              /* start iconhigh */
              if ( oskb_pointer_visible() )
              {
                  if (oskb_pointer_over_window(window_oid))
                      oskb_start_iconhigh( FALSE );
              }
              else
              {
                   oskb_set_mouse_position(window_oid, oskb_layout);
                   oskb_start_iconhigh( FALSE );
              }
          }

          // tell the system that the window is open.
          window_open = 1;

        }




        /* If Scrolling enabled, scroll the window */
        if (scrolling && scrolling_windows)
        {
            if (!oskb_scroll_window_open(window_oid, show_extension,
                                         scrollup, scroll_point))
            {
              /* Turn off null events and disable future scrolling */
              event_mask |= Wimp_Poll_NullMask;
              event_set_mask(event_mask);
              scrolling=0;

              /* now look for pointer entering to enable iconhigh */
              event_register_wimp_handler(-1, Wimp_EPointerEnteringWindow,
                                          oskb_ptrenter_handler, 0);

              /* Tell everyone our window size and position */
              oskb_publish_window_geom(window_oid);

              /* set mouse position */

              if (!toolbar_mode)
              {
                  /* start iconhigh */
                  if ( oskb_pointer_visible() )
                  {
                      if (oskb_pointer_over_window(window_oid))
                          oskb_start_iconhigh( FALSE );
                  }
                  else
                  {
                      oskb_set_mouse_position(window_oid, oskb_layout);
                      oskb_start_iconhigh( FALSE );
                  }
              }

              /*
               * Hack for FUNAI3, to poll IME and keyboard state
               * in the absence of relevant service calls etc.
               */

              #ifdef FUNAI3_POLL
                event_mask &= ~Wimp_Poll_NullMask;
                event_set_mask(event_mask);
                event_register_wimp_handler(-1, Wimp_ENull,
                                            oskbmain_poll_real_states, 0);
              #endif

            } /* if */
        } /* if */

        /*
         * If FUNAI3_POLL is defined, allow idle reason code returns
         * every 25 centiseconds; the registration of a Null event
         * handler function earlier on means we can then scan the
         * keyboard and IME state, updating the front-end as needed.
         */

        #ifdef FUNAI3_POLL
          {
            unsigned int time;

            _swix(OS_ReadMonotonicTime, _OUT(0), &time);

            kern_error = event_poll_idle(&event_code,
                                         &poll_block,
                                         time + (scrolling ? 1 : 25),
                                         poll_word);
          }
        #else
          kern_error = event_poll (&event_code, &poll_block, poll_word);
        #endif

    } /* while */

    wimp_report_error(kern_error,0,0);

} /* main */
