/* Title:   textarea.c
 * Purpose: text area gadget for textgadgets module
 *
 * Revision History
 * piers    18/06/96 Created
 * piers    02/09/96 Implemented insert text method
 * piers    20/12/96 Incorporated RLougher's textarea source
 * piers    23/12/96 Fixed selections to use drag type 9 so it doesn't need
 *                   to claim null events
 * piers    03/02/97 Implemented fade flag
 * rlougher 18/03/97 Added MemChecking code
 * rlougher 20/03/97 Fixed bug in updating insert position after
 *                   keyboard input
 * rlougher 20/03/97 Fixed set selection
 * rlougher 11/08/97 Added ability to turn scrollbars on/off
 * rlougher 01/09/97 Added ability to turn word wrap on/off
 * rlougher 04/09/97 Wordwrap can now be changed dynamically at runtime
 * rlougher 05/09/97 Scrollbars can now be turned on/off at runtime
 * rlougher 10/09/97 Keyboard selection using shift + cursor keys
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "kernel.h"
#include "swis.h"

#include "toolbox.h"
#include "window.h"
#include "wimplib.h"

#include "glib.h"
#include "string32.h"
#include "riscos_utils.h"
#include "TextGadgets.h"
#include "TextArea.h"
#include "TextAreaP.h"
#include "Font.h"
#include "Text.h"
#include "Scrollbar.h"
#include "ScrollbarP.h"
#include "myswis.h"
#include "utils.h"

#ifdef MemCheck_MEMCHECK
#include "MemCheck:MemCheck.h"
#endif

static PrivateTextArea		*dragging = NULL;

#define IGNORE(a) (a)=(a)
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#define MAX(x, y) ((x) > (y) ? (x) : (y))

static int my_icons[] = {-1};

static PrivateTextArea **text_area_list = NULL;

static const WindowTemplate window_template =
{
    1<<1 | 1<<2, 		// flags
    NULL,	// help_message
    0, 		// max_help
    NULL,	// pointer_shape
    0,		// max_pointer_shape
    0,		// pointer_x_hot
    0,		// pointer_y_hot
    NULL,	// no menu
    0,		// num_keyboard_shortcuts
    NULL,	// keyboard_shortcuts
    0,		// num_gadgets
    NULL,	// gadgets
    -1,		// default_focus
    0,		// show_event
    0,		// hide_event
    NULL,	// toolbar_ibl
    NULL,	// toolbar_itl
    NULL,	// toolbar_ebl
    NULL,	// toolbar_etl
    {
        // WimpWindow struct
        {0, -100, 0, 0},	// visible_area
        0,			// xscroll
        0,			// yscroll
        -1,			// behind
        WimpWindow_NewFormat,  	// flags
#ifndef DAYTONA_BUILD
        7,			// title_fg
#else
	0xff,			// transparent title == no borders
#endif
        0,			// title_bg
        7,			// work_fg
        0xff,			// work_bg
        3,			// scroll_outer
        1,			// scroll_inner
        12,			// highlight_by
        0,			// reserved
        {0, -40960, 12800, 0},	// extent
        0,			// title_flags
        6 * WimpIcon_ButtonType,// work_flags
        NULL,			// sprite_area
        1,			// min_width
        1,			// min_height
        {
            // WimpIconData
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        },
        0			// nicons
    }
};

static /* const */ ObjectTemplateHeader text_area_window =
{
    Window_ObjectClass,		// object_class
    0,				// flags
    102,			// version
    "__editor",			// name
    sizeof(ObjectTemplateHeader) + sizeof(WindowTemplate),	// total_size
    NULL,			// body - due to a bug in the compiler, we
    				// have to set this at run-time
    sizeof(WindowTemplate)	// body_size
};

static BBox redraw_all_box = {0, -0xffff, 0xffff, 0};

static void update_display(PrivateTextArea *tdata,
			int first_line, int last_line, int line_delta);

static _kernel_oserror *out_of_memory(void)
{
   return (_kernel_oserror *) "    Unable to allocate memory to store text area gadget definition";
}

_kernel_oserror *textarea_init(void)
{
    text_area_window.body = (void*) &window_template;

    initialise_memory("TextArea workspace");

    return NULL;
}

_kernel_oserror *textarea_die(void)
{
    release_memory();

    return NULL;
}

/* ------------------------------------------------------------------------
 */
static _kernel_oserror *add_redraw_handler(PrivateTextArea *tb)
{
    _kernel_oserror no_mem = {0, "Not enough memory"};

    if (text_area_list == NULL)
    {
        if ( (text_area_list = malloc(sizeof(PrivateTextArea*) * 2)) == NULL)
            return &no_mem;

        text_area_list[0] = tb;
        text_area_list[1] = NULL;
    }
    else
    {
        PrivateTextArea **new_list;
        unsigned int i;

        for (i = 0; text_area_list[i] != NULL; i++)
            ;

        new_list = realloc(text_area_list,sizeof(PrivateTextArea*) * (i+2));

        if (new_list == NULL)
            return &no_mem;

        text_area_list = new_list;

        text_area_list[i] = tb;
        text_area_list[i + 1] = NULL;
    }

    return NULL;
}

static _kernel_oserror *remove_redraw_handler(PrivateTextArea *tb)
{
    _kernel_oserror bad_area = {0, "No such text area"};
    unsigned int i, j;

    if (text_area_list == NULL)
        return &bad_area;

    for (i = 0;
        (text_area_list[i] != NULL) && (text_area_list[i] != tb);
        i++)
        ;

    if (text_area_list[i] == NULL)
        return &bad_area;

    for (j = i; text_area_list[j] != NULL; j++)
        ;

    // j points to last entry

    if (j <= 1)
    {
        free(text_area_list);
        text_area_list = NULL;
    }
    else
    {
        PrivateTextArea **new_list;

        for (; i < j; i++)
            text_area_list[i] = text_area_list[i + 1];

        // No need to generate an error if the realloc fails, 'cos
        // it'll just realloc next time, hopefully
        new_list = realloc(text_area_list, sizeof(PrivateTextArea) * (j+1));

        if (new_list != NULL)
            text_area_list = new_list;
    }

    return NULL;
}

static void deselect(PrivateTextArea *tdata)
{
    tdata->text->sel_stop_pos = -1;

    if(tdata->text->sel_stop_line < tdata->text->insert_line)
        update_display(tdata, tdata->text->sel_stop_line,
        				tdata->text->insert_line, 0);
    else
        update_display(tdata, tdata->text->insert_line,
        				tdata->text->sel_stop_line, 0);

    tdata->text->sel_stop_line = -1;
}

static void _set_selection(PrivateTextArea *tdata, int from, int to)
{
    int		caret_x, caret_y;
    Text	*text = tdata->text;
    int		window;

    window_get_wimp_handle(0, tdata->object_id, &window);

    if(text->sel_stop_pos != -1)
        deselect(tdata);

    if((to == -1) || (to > get_text_size(text)))
        to = get_text_size(text);

    char_pos(text, from, &caret_x, &caret_y);
    wimp_set_caret_position(window, -1, caret_x, -caret_y,
                            text->line_height, -1);

    close_insertion(text);
    create_insertion(text, from);

    text->sel_stop_pos = to;
    text->sel_stop_line = line_index_of_char(text, to);

    update_display(tdata, text->insert_line, text->sel_stop_line, 0);
}

static _kernel_oserror *handle_drag(void)
{
    WimpGetPointerInfoBlock block;
    WimpGetWindowStateBlock state;
    int win, xcoord, ycoord, old_line, new_line, index, xpos, ypos;

    window_get_wimp_handle(0, dragging->object_id, &win);
    state.window_handle = win;
    wimp_get_window_state(&state);
    wimp_get_pointer_info(&block);

    xcoord = block.x - state.visible_area.xmin + state.xscroll;
    ycoord = state.visible_area.ymax - state.yscroll - block.y;

    char_block(dragging->text, xcoord, ycoord, &new_line, &index, &xpos, &ypos);

    if(((old_line = dragging->text->sel_stop_line) == new_line) &&
       (index == dragging->text->sel_stop_pos))
          return NULL;

    dragging->text->sel_stop_pos = index;
    dragging->text->sel_stop_line = new_line;

    if(old_line < new_line)
        update_display(dragging, old_line, new_line, 0);
    else
        update_display(dragging, new_line, old_line, 0);

    return NULL;
}

static _kernel_oserror *handle_drag_stop(BBox *box)
{
    IGNORE(box);

    dragging = NULL;

    return NULL;
}

static _kernel_oserror *_show(PrivateTextArea *tdata)
{
    WindowShowObjectBlock	show_block;
    BBox			new;
    int text_xmax, text_ymax, xextent, yextent, new_y, new_x;

    work_to_screen_handle(&show_block.visible_area, &tdata->box,
    				tdata->wimpw);

    show_block.xscroll = show_block.yscroll = 0;
    show_block.behind = -1;
    show_block.window_flags = 0;
    show_block.parent_window_handle = tdata->wimpw;
    show_block.alignment_flags = 0;
    
    xextent = show_block.visible_area.xmax - show_block.visible_area.xmin;
    if(tdata->state & TextArea_WordWrap)
        new_x = xextent;
    else
    {
        text_xmax = tdata->text->xmax + 10;
        new_x = text_xmax > xextent ? text_xmax : xextent;
    }
    
    text_ymax = tdata->text->no_of_lines * tdata->text->line_height;
    yextent = show_block.visible_area.ymax - show_block.visible_area.ymin;
    new_y = text_ymax > yextent ? text_ymax : yextent;

    new.xmin = 0;
    new.xmax = new_x;
    new.ymin = -new_y;
    new.ymax = 0;

    window_set_extent(0, tdata->object_id, &new);

    toolbox_show_object(Toolbox_ShowObject_AsSubWindow, tdata->object_id,
  			Toolbox_ShowObject_FullSpec, &show_block,
  			tdata->parent_id, -1);

    return NULL;
}

_kernel_oserror *textarea_plot(TextArea *tdata)
{
    WimpGetWindowStateBlock	state;
    _kernel_oserror		*e;
    BBox			box;

    state.window_handle = redrawing_window;
    if ((e = wimp_get_window_state(&state)) != NULL)
        return e;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(tdata, sizeof(TextArea));
#endif

    box = tdata->hdr.box;
    work_to_screen(&box, &state);

    colourtrans_set_gcol(tdata->background, 1<<7, 0);
    os_plot(PLOT_MOVE, box.xmin, box.ymin);
    os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK,
    		box.xmax, box.ymax);
    colourtrans_set_gcol(tdata->foreground, 0, 0);
    os_plot(PLOT_DRAW, box.xmin, box.ymax);
    os_plot(PLOT_DRAW, box.xmin, box.ymin);
    os_plot(PLOT_DRAW, box.xmax, box.ymin);
    os_plot(PLOT_DRAW, box.xmax, box.ymax);

    if (tdata->hdr.flags & TextArea_Scrollbar_Vertical)
    {
        // Has vertical scrollbar
        int x, y;

        colourtrans_set_gcol(0 /* black */, 1<<7, 0);
        x = MAX(box.xmax - SCROLLBAR_SIZE, box.xmin);
        y = (tdata->hdr.flags & TextArea_Scrollbar_Horizontal) ?
        	MIN(box.ymin + SCROLLBAR_SIZE, box.ymax) : box.ymin;
        os_plot(PLOT_MOVE, x, y);
        os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK, box.xmax, box.ymax);
    }

    if (tdata->hdr.flags & TextArea_Scrollbar_Horizontal)
    {
        // Has horizontal scrollbar
        int x, y;

        colourtrans_set_gcol(0 /* black */, 1<<7, 0);
        x = (tdata->hdr.flags & TextArea_Scrollbar_Vertical) ?
        	MAX(box.xmax - SCROLLBAR_SIZE, box.xmin) : box.xmax;
        y = MIN(box.ymin + SCROLLBAR_SIZE, box.ymax);
        os_plot(PLOT_MOVE, box.xmin, box.ymin);
        os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK, x, y);
    }

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(tdata);
#endif

    return NULL;
}

_kernel_oserror *textarea_move(int type, PrivateTextArea *tdata,
				BBox *box)
{
    IGNORE(type);

    tdata->box = *box;

    return _show(tdata);
}

/* ------------------------------------------------------------------------
 */
static void update_display(PrivateTextArea *tdata,
			int first_line, int last_line, int line_delta)
{
    Text			*text = tdata->text;
    BBox			current_ext;
    WimpRedrawWindowBlock	block;
    WimpGetWindowStateBlock     state;
    int				redraw_top, redraw_bottom;
    int				more;
    int				window;
    int                         xextent, yextent, text_xmax;
    int                         new_x, new_y, text_ymax;
    unsigned int		foreground, background;

    if (tdata->state & Gadget_Faded)
    {
        int fore, back;

        fore = tdata->foreground >> 8;
        back = tdata->background >> 8;

        foreground = tdata->foreground;

#ifdef DAYTONA_BUILD
	background = tdata->background;
#else
        background = ( ((((fore & 0xff0000) -
        			(back & 0xff0000)) / 5 +
        			(back & 0xff0000)) & 0xff0000)|
        		((((fore & 0xff00) -
        			(back & 0xff00)) / 5 +
        			(back & 0xff00)) & 0xff00)|
        		((((fore & 0xff) -
        			(back & 0xff)) / 5 +
        			(back & 0xff)) & 0xff) ) << 8;
#endif
    }
    else
    {
        foreground = tdata->foreground;
        background = tdata->background;
    }

    window_get_wimp_handle(0, tdata->object_id, &window);

    state.window_handle = window;
    wimp_get_window_state(&state);
    
    xextent = state.visible_area.xmax - state.visible_area.xmin;
    if(tdata->state & TextArea_WordWrap)
        new_x = xextent;
    else
    {
        text_xmax = text->xmax + 10;
        new_x = text_xmax > xextent ? text_xmax : xextent;
    }
    
    text_ymax = text->no_of_lines * text->line_height;
    yextent = state.visible_area.ymax - state.visible_area.ymin;
    new_y = text_ymax > yextent ? text_ymax : yextent;

    redraw_top = -first_line * text->line_height;
    redraw_bottom = -(last_line + line_delta + 1) * text->line_height;

    if (line_delta != 0)
    {
        int src_top, src_bottom, dest_bottom;

        dest_bottom = state.visible_area.ymin - state.visible_area.ymax +
                      state.yscroll;
        src_top = -(last_line + 1) * text->line_height;
        src_bottom = dest_bottom + line_delta * text->line_height;

        wimp_block_copy(window, 0, src_bottom, 0xffff, src_top, 0,
                        dest_bottom);
    }
    
    window_get_extent(0, tdata->object_id, &current_ext);

    if((new_x != current_ext.xmax) || (new_y != -current_ext.ymin))
    {
        current_ext.xmax = new_x;
        current_ext.ymin = -new_y;

        window_set_extent(0, tdata->object_id, &current_ext);
        wimp_open_window((WimpOpenWindowBlock *) &state);
    }

    block.visible_area.xmin = 0;
    block.visible_area.ymin = redraw_bottom;
    block.visible_area.xmax = 0xffff;
    block.visible_area.ymax = redraw_top;
    block.window_handle = window;

    wimp_update_window(&block, &more);
    while (more)
    {
        int xorg = block.visible_area.xmin - block.xscroll;
        int yorg = block.visible_area.ymax - block.yscroll;

        display_lines(text, yorg - block.redraw_area.ymax,
                        yorg - block.redraw_area.ymin,
                        xorg, yorg, foreground, background);

        wimp_get_rectangle (&block,&more);
    }
}

static void set_caret(int win, Text *text, int caret_x, int caret_y, int force)
{
    WimpGetWindowStateBlock     state;
    WimpGetCaretPositionBlock 	block;
    int xmax, ymax, new_x = -1, new_y = -1;

    state.window_handle = win;
    wimp_get_window_state(&state);

    xmax = state.visible_area.xmax - state.visible_area.xmin + state.xscroll;
    ymax = state.visible_area.ymax - state.visible_area.ymin - state.yscroll;
      
    if(xmax < caret_x)
        new_x = caret_x - xmax + state.xscroll + 10;
    else
        if(state.xscroll > caret_x)
            new_x = caret_x;

    if(ymax < caret_y)
        new_y = caret_y - ymax - state.yscroll;
    else
        if(-state.yscroll > (caret_y - text->line_height))
            new_y = (caret_y - text->line_height);

    if((new_x != -1) || (new_y != -1))
    {
        state.xscroll = new_x == -1 ? state.xscroll : new_x;
        state.yscroll = new_y == -1 ? state.yscroll : -new_y;
    
        wimp_open_window((WimpOpenWindowBlock *) &state);
    }

    wimp_get_caret_position(&block);
    if (force || block.window_handle == win)
        wimp_set_caret_position(win, -1, caret_x, -caret_y,
                            text->line_height, -1);
}


static void key_pressed(WimpKeyPressedEvent *event, PrivateTextArea *tdata)
{
    static char str[] = " ";
    Text *text = tdata->text;
    int win = event->caret.window_handle;
    int key = event->key_code;

    int first_line, last_line, line_delta;
    int l, new_pos = -1, caret_x, caret_y;

    if (tdata->state & Gadget_Faded)
    {
        wimp_process_key(key);
        return;
    }
    
    if((key == 8) || (key == 127))
    {
        if(text->sel_stop_pos != -1)
        {
            if(text->sel_stop_pos < text->insert_pos)
                replace_text(text, text->sel_stop_pos, text->insert_pos,
                             "", &first_line, &last_line, &line_delta);
            else
                replace_text(text, text->insert_pos, text->sel_stop_pos,
                             "", &first_line, &last_line, &line_delta);

            text->sel_stop_pos = -1;
        }
        else
        {
            if(text->insert_pos == 0)
                return;

            replace_text(text, text->insert_pos - 1, text->insert_pos, "",
                         &first_line, &last_line, &line_delta);
        }
        char_pos(text, text->insert_pos, &caret_x, &caret_y);
        set_caret(win, text, caret_x, caret_y, 1);
        update_display(tdata, first_line, last_line, line_delta);
    }
    else
    {
        switch(key & ~0x10)
        {
            case 0x18c:		// Left
                new_pos = text->insert_pos == 0 ? 0 : text->insert_pos -1;
                char_pos(text, new_pos, &caret_x, &caret_y);
                break;

            case 0x18d:		// Right
                new_pos = text->insert_pos > line_end(text,
                          text->no_of_lines - 1) ? text->insert_pos :
                          text->insert_pos + 1;
                char_pos(text, new_pos, &caret_x, &caret_y);
                break;

            case 0x18e:		// Down
                char_block(text, event->caret.xoffset,
                  -(event->caret.yoffset - text->line_height +1),
                  &l, &new_pos, &caret_x, &caret_y);
                break;

            case 0x18f:		// Up
                char_block(text, event->caret.xoffset,
                  -(event->caret.yoffset + text->line_height +1),
                  &l, &new_pos, &caret_x, &caret_y);
                break;

            case 13:
                key = 10;

            default:
                if(((key < 32) || (key > 255) || (key == 126)) &&
                    (key != 10) && (key != 9))
                {
                    wimp_process_key(key);
                    return;
                }
                    
                str[0] = key;
                if(text->sel_stop_pos != -1)
                {
                    if(text->sel_stop_pos < text->insert_pos)
                        replace_text(text, text->sel_stop_pos,
                                     text->insert_pos, str, &first_line,
                                     &last_line, &line_delta);
                    else
                    {
                        replace_text(text, text->insert_pos,
                                    text->sel_stop_pos, str, &first_line,
                                    &last_line, &line_delta);
                          close_insertion(text);
                          create_insertion(text, text->insert_pos + 1);
                    }

                    text->sel_stop_pos = -1;
                }
                else
                    insert_text(text, str, &first_line, &last_line, &line_delta);
                    
                if(line_delta >= 0)
                {
                    update_display(tdata, first_line, last_line, line_delta);
                    char_pos(text, text->insert_pos, &caret_x, &caret_y);
                    set_caret(win, text, caret_x, caret_y, 1);
                }
                else
                {
                    char_pos(text, text->insert_pos, &caret_x, &caret_y);
                    set_caret(win, text, caret_x, caret_y, 1);
                    update_display(tdata, first_line, last_line, line_delta);
                }
        }
        if(new_pos != -1)
        {
            if(key & 0x10)
            {
                int old_line = text->insert_line;
                int old_pos = text->insert_pos;
            
                close_insertion(text);
                create_insertion(text, new_pos);
                
                if((old_line != text->insert_line) || (old_pos != text->insert_pos))
                {
            
                    if(text->sel_stop_pos == -1)
                    {
                        text->sel_stop_pos = old_pos;
                        text->sel_stop_line = old_line;
                    }
                    
                    if(old_line < text->insert_line)
                        update_display(tdata, old_line, text->insert_line, 0);
                    else
                        update_display(tdata, text->insert_line, old_line, 0);
                }
            }
            else
            {
                if(text->sel_stop_pos != -1)
                    deselect(tdata);
                    
                close_insertion(text);
                create_insertion(text, new_pos);
            }
               
            char_pos(text, text->insert_pos, &caret_x, &caret_y);
            set_caret(win, text, caret_x, caret_y, 1);
        }
    }
    return;
}

static void _redraw(WimpRedrawWindowRequestEvent *event, PrivateTextArea *tdata)
{
   int				more;
   WimpRedrawWindowBlock	block;
   Text				*text = tdata->text;
   unsigned int			foreground, background;

    if (tdata->state & Gadget_Faded)
    {
        int fore, back;

        fore = tdata->foreground >> 8;
        back = tdata->background >> 8;

        foreground = tdata->foreground;
        
#ifdef DAYTONA_BUILD
	background = tdata->background;
#else
        background = ( ((((fore & 0xff0000) -
        			(back & 0xff0000)) / 5 +
        			(back & 0xff0000)) & 0xff0000)|
        		((((fore & 0xff00) -
        			(back & 0xff00)) / 5 +
        			(back & 0xff00)) & 0xff00)|
        		((((fore & 0xff) -
        			(back & 0xff)) / 5 +
        			(back & 0xff)) & 0xff) ) << 8;
#endif
    }
    else
    {
        foreground = tdata->foreground;
        background = tdata->background;
    }

   block.window_handle = event->window_handle;

   wimp_redraw_window(&block, &more);

   while (more)
   {
      int xorg = block.visible_area.xmin - block.xscroll;
      int yorg = block.visible_area.ymax - block.yscroll;

      colourtrans_set_gcol(background, 1<<7, 0);

      os_plot(PLOT_MOVE, block.redraw_area.xmin, block.redraw_area.ymin);
      os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK, block.redraw_area.xmax,
      			block.redraw_area.ymax);

      display_lines(text, yorg - block.redraw_area.ymax,
                          yorg - block.redraw_area.ymin,
                          xorg, yorg, foreground, background);

      wimp_get_rectangle(&block, &more);
   }

   return;
}

/* textarea_add -----------------------------------------------------------
 */
_kernel_oserror *
textarea_add(TextArea *tdata, int wimpw, ObjectId parent_id,
				int **icons, int **data)
{
    PrivateTextArea		*tb;
    _kernel_oserror		*e;
    Scrollbar			sdata;

    tb = (PrivateTextArea *) mem_allocate(sizeof(PrivateTextArea));
    if (!tb)
        return out_of_memory();

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(tb, sizeof(PrivateTextArea));
#endif

    tb->box = tdata->hdr.box;

#ifndef DAYTONA_BUILD
    if(tdata->hdr.flags & TextArea_Scrollbar_Horizontal)
    {
        tb->box.ymin += SCROLLBAR_SIZE;
        ((WindowTemplate *)text_area_window.body)->window.flags |= WimpWindow_HScroll;
    }
    else
        ((WindowTemplate *)text_area_window.body)->window.flags &= ~WimpWindow_HScroll;

    if(tdata->hdr.flags & TextArea_Scrollbar_Vertical)
    {
        tb->box.xmax -= SCROLLBAR_SIZE;
        ((WindowTemplate *)text_area_window.body)->window.flags |= WimpWindow_VScroll;
    }
    else
        ((WindowTemplate *)text_area_window.body)->window.flags &= ~WimpWindow_VScroll;
#endif
    
    if ((e = toolbox_create_object(1, &text_area_window,
    					&tb->object_id)) != NULL)
    {
#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(tb);
#endif
        mem_free(tb);
        return e;
    }

    *data = (int *) tb;

//    tb->event = tdata->event ? tdata->event : TextArea_StateChanged;
    tb->state = tdata->hdr.flags;
    tb->parent_id = parent_id;
    tb->component_id = tdata->hdr.component_id;

    tb->type = tdata->type;
    tb->wimpw = wimpw;
    tb->foreground = tdata->foreground;
    tb->background = tdata->background;
    tb->indent = TextArea_DefaultIndent;

    e = font_find_font(TextArea_DefaultFont, TextArea_DefaultWidth,
   		TextArea_DefaultHeight, 0, 0, (&tb->font_handle));
    if (e) tb->font_handle = 0;

    create_text(0, tb->font_handle, &tb->text);
    
    if(tb->state & TextArea_WordWrap)
    {
        int width = tb->box.xmax - tb->box.xmin - 10;
        
        _swix(Font_Converttopoints,_IN(1)|_IN(2)|_OUT(1), width > 0 ? width : 0, 0,
                                   &tb->text->margin);
    }
    else
        tb->text->margin = 0xffffff;
        
    if(tdata->text)
       insert_text(tb->text, tdata->text, &f, &l, &d);    
    
    *icons = my_icons;

    add_redraw_handler(tb);

    if (tdata->hdr.flags & TextArea_Scrollbar_Horizontal)
    {
        if (tdata->hdr.flags & TextArea_Scrollbar_Vertical)
            sdata.hdr.box.xmax -= SCROLLBAR_SIZE;
    }
    if (tdata->hdr.flags & TextArea_Scrollbar_Vertical)
    {
        if (tdata->hdr.flags & TextArea_Scrollbar_Horizontal)
            sdata.hdr.box.ymin += SCROLLBAR_SIZE;
    }

    add_task_interest(GLib_ToolboxEvents, filter_toolbox_events,
    				TextGadgets_Filter);
    add_task_interest(GLib_WimpEvents, filter_wimp_events,
    				TextGadgets_Filter);

    _show(tb);

    return NULL;
}

static _kernel_oserror *textarea_mclick(PrivateTextArea *tdata,
		WimpMouseClickEvent *event)
{
    Text			*text = tdata->text;
    WimpGetWindowStateBlock	state;
    int				win = event->window_handle;
    static int			dragging_workspace[4];
				// static int arrays are initialised to 0

    /* The dragging_workspace block (set up below) is modified by the
       assembler veneers.
       by checking sliding[3] we can determine if this is just a mouse click
       (ie. the start of a drag) or a faked click - ie a dragging */

    if (dragging_workspace[3])
    {
        _kernel_oserror *e;

        e = handle_drag();

        dragging_workspace[3] = 0;

        return e;
    }

    if(text->sel_stop_pos != -1)
        deselect(tdata);

    state.window_handle = win;
    wimp_get_window_state(&state);

    if (event->buttons == 2)
    {
        // Menu clicked
        ObjectId	menu_id;

        window_get_menu(0, tdata->parent_id, &menu_id);
        if (menu_id != 0)
            toolbox_show_object(0, menu_id, 0, 0,
                                tdata->parent_id, tdata->component_id);

        return NULL;
    }

    if(event->buttons >= 16)
    {
        /* This stuff is based on the slider gadget. */
        static WimpDragBox	drag_box;

       /* from s.TAsel_ven */
       extern void		_textarea_drag_draw(void);
       extern void		_textarea_drag_move(void);
       extern void		_textarea_drag_remove(void);

        dragging = tdata;

        drag_box.draw = _textarea_drag_draw;
        drag_box.move = _textarea_drag_move;
        drag_box.remove = _textarea_drag_remove;
        drag_box.wimp_window = event->window_handle;
        drag_box.drag_type = 9;
        drag_box.workspace = dragging_workspace;

        // This provides data to create a suitable mouse click
        dragging_workspace[1] = event->window_handle;
        dragging_workspace[0] = event->buttons >> 4;
        dragging_workspace[2] = event->icon_handle;
        dragging_workspace[3] = 0;

        drag_box.parent_box.xmin = state.visible_area.xmin;
        drag_box.parent_box.ymin = state.visible_area.ymin;
        drag_box.parent_box.xmax = state.visible_area.xmax;
        drag_box.parent_box.ymax = state.visible_area.ymax;

        drag_box.dragging_box.xmin = event->mouse_x;
        drag_box.dragging_box.ymin = event->mouse_y;
        drag_box.dragging_box.xmax = event->mouse_x;
        drag_box.dragging_box.ymax = event->mouse_y;

        wimp_drag_box(&drag_box);
    }
    else
    {
        int l, index, xpos, ypos;
        int xcoord = event->mouse_x - state.visible_area.xmin +
               state.xscroll;
        int ycoord = state.visible_area.ymax - state.yscroll -
               event->mouse_y;

        char_block(text, xcoord, ycoord, &l, &index, &xpos, &ypos);
        close_insertion(text);
        create_insertion(text, index);
        set_caret(win, text, xpos, ypos, 1);
    }

    return NULL;
}

static _kernel_oserror *_set_colour(PrivateTextArea *handle,
	unsigned int flags, unsigned int foreground, unsigned int background)
{
    if (flags | TextArea_DesktopColours == flags)
    {
        // Need to translate desktop colours to real colours
        Palette	palette;
        _kernel_oserror bad_col = {0, "Invalid desktop colour"};

        if ((foreground > 15) || (background > 15))
            return &bad_col;

        _swix(Wimp_ReadPalette, _IN(1)|_IN(2),&palette,0x45555254/*'TRUE'*/);
        foreground = palette.colours[foreground] & ~0xff;
        background = palette.colours[background] & ~0xff;
    }
    handle->foreground = foreground;
    handle->background = background;

    // Generate a force_redraw
    window_force_redraw(0, handle->object_id, &redraw_all_box);

    return NULL;
}

static _kernel_oserror *_set_text(PrivateTextArea *handle, const char *text)
{
    int first_line, last_line, line_delta;
    int caret_x, caret_y;
    int window_handle;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(text, strlen(text) + 1);
#endif

    if(handle->text->sel_stop_pos != -1)
        deselect(handle);

    window_get_wimp_handle(0, handle->object_id, &window_handle);

    replace_text(handle->text, 0, -1, text,
    			&first_line, &last_line, &line_delta);

    char_pos(handle->text, handle->text->insert_pos, &caret_x, &caret_y);
    set_caret(window_handle, handle->text, caret_x, caret_y, 0);
    update_display(handle, first_line, last_line, line_delta);

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(text);
#endif

    return NULL;
}

static _kernel_oserror *_get_text(PrivateTextArea *handle, char *buffer,
				unsigned int buff_size, int *nbytes)
{
    if (buffer == NULL)
    {
        // No buffer, so return amount of bytes needed for buffer
        if (nbytes)
            *nbytes = get_text_size(handle->text) + 1;
    }
    else
    {
        get_text(handle->text, 0, buff_size - 1, buffer);

        *nbytes = strlen(buffer);
    }

    return NULL;
}

static _kernel_oserror *_insert_text(PrivateTextArea *tdata, int index,
				char *buffer)
{
    unsigned int length;
    int first_line, last_line, line_delta;
    int caret_x, caret_y;
    int window_handle;

    if (buffer == NULL)
        return NULL;
    length = strlen(buffer);
    if (length == 0)
        return NULL;

    if(tdata->text->sel_stop_pos != -1)
        deselect(tdata);

    window_get_wimp_handle(0, tdata->object_id, &window_handle);

    replace_text(tdata->text, index, index, buffer,
        		&first_line, &last_line, &line_delta);

    char_pos(tdata->text, tdata->text->insert_pos, &caret_x, &caret_y);
    set_caret(window_handle, tdata->text, caret_x, caret_y, 0);
    update_display(tdata, first_line, last_line, line_delta);

    return NULL;
}

static _kernel_oserror *_replace_text(PrivateTextArea *tdata,
				int start, int end, char *buffer)
{
    unsigned int length;
    int first_line, last_line, line_delta;
    int caret_x, caret_y;
    int window_handle;

    if (buffer == NULL)
        return NULL;
    length = strlen(buffer);
    if (length == 0)
        return NULL;

    if(tdata->text->sel_stop_pos != -1)
        deselect(tdata);

    window_get_wimp_handle(0, tdata->object_id, &window_handle);

    replace_text(tdata->text, start, end, buffer,
    			&first_line, &last_line, &line_delta);

    char_pos(tdata->text, tdata->text->insert_pos, &caret_x, &caret_y);
    set_caret(window_handle, tdata->text, caret_x, caret_y, 0);
    update_display(tdata, first_line, last_line, line_delta);

    return NULL;
}

static _kernel_oserror *_get_selection(PrivateTextArea *handle, int flags,
			char *buff, int buff_size, int *start, int *end)
{
    if (flags & 1<<0)
    {
        // Return text rather than indexes
        if (buff == NULL)
        {
            if (end)
                *end = abs(handle->text->insert_pos -
                	        handle->text->sel_stop_pos) + 1;
        }
        else
        {
            unsigned int nbytes;

            nbytes = MIN(buff_size - 1, abs(handle->text->insert_pos -
                				handle->text->sel_stop_pos));

            if(handle->text->insert_pos < handle->text->sel_stop_pos)
                get_text(handle->text, handle->text->insert_pos,
            			handle->text->insert_pos + nbytes + 1, buff);
            else
                get_text(handle->text, handle->text->sel_stop_pos,
            	              handle->text->sel_stop_pos + nbytes + 1, buff);

            if (end)
                *end = nbytes;
        }
    }
    else
    {
        // Return indexes
        if (start)
            *start = handle->text->insert_pos;
        if (end)
        {
            if(handle->text->sel_stop_pos == -1)
                *end = *start;
            else
                *end = handle->text->sel_stop_pos;
        }
    }

    return NULL;
}

static _kernel_oserror *_set_font(PrivateTextArea *handle, const char *font,
				unsigned int width, unsigned int height)
{
    _kernel_oserror	*e;
    int window_handle, caret_x, caret_y;

    if (handle->font_handle != 0)
    {
        // Free existing font handle
        font_lose_font(handle->font_handle);
        handle->font_handle = 0;
    }

    // Get new font handle
    if (font == NULL)
    {
        handle->font_handle = 0;
    }
    else
    {
        e = font_find_font(font, width, height, 0, 0,
        			&handle->font_handle);
        if (e)
        {
            handle->font_handle = 0;
            return e;
        }
        set_font(handle->text, handle->font_handle);
    }

    window_get_wimp_handle(0, handle->object_id, &window_handle);
    char_pos(handle->text, handle->text->insert_pos, &caret_x, &caret_y);
    set_caret(window_handle, handle->text, caret_x, caret_y, 0);

    // Generate a force_redraw
    window_force_redraw(0, handle->object_id, &redraw_all_box);

    return NULL;
}

static void _set_state(PrivateTextArea *handle, unsigned int state)
{
    WimpGetWindowStateBlock wstate;
    BBox                    current_ext;
    unsigned int            changed = state ^ handle->state;
    int                     caret_x, caret_y, win;
    int                     parent, alignment;
    int                     xextent, yextent, new_x, new_y, text_ymax;
    
    if(!changed) return;
    
    handle->state = state;
    
    window_get_wimp_handle(0, handle->object_id, &win);
    wstate.window_handle = win;
       
    _swix(Wimp_GetWindowState,_IN(1)|_IN(2)|_OUT(3)|_OUT(4), &wstate,
                              0x4B534154 /* TASK */, &parent, &alignment);

#ifndef DAYTONA_BUILD  
    if(changed & TextArea_Scrollbar_Vertical)
    {
        if(state & TextArea_Scrollbar_Vertical)
        {
            wstate.flags |= WimpWindow_VScroll;
            wstate.visible_area.xmax -= SCROLLBAR_SIZE;
        }
        else
        {
            wstate.flags &= ~WimpWindow_VScroll;
            wstate.visible_area.xmax += SCROLLBAR_SIZE;
        }        
        alignment |= 1;
        
        if(state & TextArea_WordWrap)
            changed |= TextArea_WordWrap;
    }
    
    if(changed & TextArea_Scrollbar_Horizontal)
    {
        if(state & TextArea_Scrollbar_Horizontal)
        {
            wstate.flags |= WimpWindow_HScroll;
            wstate.visible_area.ymin += SCROLLBAR_SIZE;
        }
        else
        {
            wstate.flags &= ~WimpWindow_HScroll;
            wstate.visible_area.ymin -= SCROLLBAR_SIZE;
        }
        alignment |= 1;
    }
#endif
    
    xextent = wstate.visible_area.xmax - wstate.visible_area.xmin;
    
    if(changed & TextArea_WordWrap)
    {      
        if(state & TextArea_WordWrap)
            _swix(Font_Converttopoints,_IN(1)|_IN(2)|_OUT(1),
                              xextent > 10 ? xextent - 10 : xextent, 0, &handle->text->margin);
        else
            handle->text->margin = 0xffffff;
            
         compose_text(handle->text);
    }
    
    if(state & TextArea_WordWrap)
        new_x = xextent;
    else
        new_x = (handle->text->xmax + 10) > xextent ? handle->text->xmax + 10 : xextent;
    
    yextent = wstate.visible_area.ymax - wstate.visible_area.ymin;
    text_ymax = handle->text->no_of_lines * handle->text->line_height;
    new_y = text_ymax > yextent ? text_ymax : yextent;
        
    window_get_extent(0, handle->object_id, &current_ext);

    if((new_x != current_ext.xmax) || (new_y != -current_ext.ymin))
    {
        current_ext.xmax = new_x;
        current_ext.ymin = -new_y;

        window_set_extent(0, handle->object_id, &current_ext);
    }

    _swix(Wimp_OpenWindow,_INR(1,4), &wstate, 0x4B534154 /* TASK */,
                          parent, alignment);
                          
    char_pos(handle->text, handle->text->insert_pos, &caret_x, &caret_y);
    set_caret(win, handle->text, caret_x, caret_y, 0);                     
    window_force_redraw(0, handle->object_id, &redraw_all_box);
}

_kernel_oserror *textarea_method(PrivateTextArea *handle,
				_kernel_swi_regs *regs)
{
    _kernel_oserror *e = NULL;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(regs, sizeof(_kernel_swi_regs));
#endif

    switch (regs->r[2])
    {
        case TextArea_GetState:
            regs->r[0] = handle->state;
            break;
        case TextArea_SetState:
            _set_state(handle, regs->r[4]);
            break;
        case TextArea_SetText:
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock((void *)regs->r[4], 10240);  // Say 10K - don't know size
#endif
            e = _set_text(handle, (char *)regs->r[4]);
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock((void *)regs->r[4]);
#endif
            break;
        case TextArea_GetText:
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock((void *)regs->r[4], regs->r[5]);
#endif
            e = _get_text(handle, (char *)regs->r[4], regs->r[5],
            				&(regs->r[5]));
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock((void *)regs->r[4]);
#endif
            break;
        case TextArea_InsertText:
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock((void *)regs->r[5], 10240);  // Say 10K - don't know size
#endif
            e = _insert_text(handle, regs->r[4], (char *) regs->r[5]);
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock((void *)regs->r[5]);
#endif
            break;
        case TextArea_ReplaceText:
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock((void *)regs->r[6], 10240);  // Say 10K - don't know size
#endif
            e = _replace_text(handle, regs->r[4], regs->r[5],
            			(char *) regs->r[6]);
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock((void *)regs->r[6]);
#endif
            break;
        case TextArea_GetSelection:
            _get_selection(handle, regs->r[0], (char *) regs->r[4], regs->r[5],
            			&(regs->r[4]), &(regs->r[5]));
            break;
        case TextArea_SetSelection:
            _set_selection(handle, regs->r[4], regs->r[5]);
            break;
        case TextArea_SetFont:
            e = _set_font(handle, (char *)regs->r[4], regs->r[5],regs->r[6]);
            break;
        case TextArea_SetColour:
            // R4 = foreground col, R5 = background col
            e = _set_colour(handle, regs->r[0], regs->r[4], regs->r[5]);
            break;
        case TextArea_GetColour:
            regs->r[0] = handle->foreground;
            regs->r[1] = handle->background;
            break;
        default:
            break;
    }

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(regs);
#endif

    return e;
}

/* ------------------------------------------------------------------------
 */
_kernel_oserror *textarea_remove(PrivateTextArea *handle)
{
    remove_redraw_handler(handle);

    if (handle->font_handle)
        font_lose_font(handle->font_handle);

    remove_task_interest(GLib_ToolboxEvents, filter_toolbox_events);
    remove_task_interest(GLib_WimpEvents, filter_wimp_events);
    toolbox_delete_object(0, handle->object_id);

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(handle);
#endif
    mem_free(handle);

    return NULL;
}

_kernel_oserror *textarea_fade(PrivateTextArea *tdata, int fade)
{
    IGNORE(fade);

    tdata->state &= ~Gadget_Faded;
    tdata->state |= fade ? Gadget_Faded : 0;

    window_force_redraw(0, tdata->object_id, &redraw_all_box);

    return NULL;
}

/* ------------------------------------------------------------------------
 */
#ifdef MemCheck_MEMCHECK
static _kernel_oserror *textarea_filter2(_kernel_swi_regs *regs)
#else
_kernel_oserror *textarea_filter(_kernel_swi_regs *regs)
#endif
{
    ToolboxEvent *event = (ToolboxEvent *)regs->r[1];
    IdBlock	*id_block = (IdBlock *)regs->r[3];
    int		event_code = regs->r[0];
    unsigned int i;

    if (text_area_list == NULL)
        return NULL;

    if (event_code == Wimp_EMouseClick)
    {
        for (i = 0; text_area_list[i] != NULL; i++)
        {
            WimpMouseClickEvent *wimp_mouse_event = (WimpMouseClickEvent*)event;
            int			window_handle;

            window_get_wimp_handle(0, text_area_list[i]->object_id,
            			&window_handle);

            if (window_handle == wimp_mouse_event->window_handle)
            {
                textarea_mclick(text_area_list[i], wimp_mouse_event);
                // Claim event, since we don't want the application to know
                // what's going on?
                regs->r[0] = -1;
            }
        }

        return NULL;
    }
    else if (event_code == Wimp_EKeyPressed)
    {
        for (i = 0; text_area_list[i] != NULL; i++)
        {
            WimpKeyPressedEvent *wimp_key_event = (WimpKeyPressedEvent*)event;
            int			window_handle;

            window_get_wimp_handle(0, text_area_list[i]->object_id,
            			&window_handle);

            if (window_handle == wimp_key_event->caret.window_handle)
            {
                key_pressed(wimp_key_event, text_area_list[i]);
            }
        }

        return NULL;
    }
    else if (event_code == Wimp_ERedrawWindow)
    {
        for (i = 0; text_area_list[i] != NULL; i++)
        {
            WimpRedrawWindowRequestEvent *wimp_redraw_event =
            				(WimpRedrawWindowRequestEvent *) event;
            int			window_handle;

            window_get_wimp_handle(0, text_area_list[i]->object_id,
            			&window_handle);

            if (window_handle == wimp_redraw_event->window_handle)
            {
                _redraw(wimp_redraw_event, text_area_list[i]);

                // Claim event, since we don't want the application to do any
                // redraw
                regs->r[0] = -1;
            }
        }

        return NULL;
    }
    else if (event_code == Wimp_EUserDrag)
    {
        if (dragging)
        {
            handle_drag_stop((BBox *) event);

            // Claim event, since we don't want the application to think
            // the drag belongs to it
            regs->r[0] = -1;
        }

        return NULL;
    }

    if ((event_code != Wimp_EToolboxEvent) ||
        ((id_block->self_component & 0xfff) != 0x800) ||
        (text_area_list == NULL))
        return NULL;

    if (event->hdr.event_code == Toolbox_ObjectDeleted)
    {
        int remaining = 0;
        PrivateTextArea **new_list;
        // An object has been deleted, so remove from internal list
        // any gadgets inside it.
        for (i = 0; text_area_list[i] != NULL; i++)
        {
            if (text_area_list[i]->parent_id == id_block->self_id)
            {
                // Found one!
                int j;
                for (j = i; text_area_list[j] != NULL; j++)
                {
                    // Copy down following gadgets
                    text_area_list[j] = text_area_list[j+i];
                }
            }
            else
                remaining++;
        }

        // Shrink memory block
        if (remaining == 0)
        {
            free(text_area_list);
            text_area_list = NULL;
        }
        else
        {
            new_list = realloc(text_area_list,
        			sizeof(PrivateTextArea) * (remaining + 1));
            if (new_list != NULL)
                text_area_list = new_list;
        }
    }

    return NULL;
}

#ifdef MemCheck_MEMCHECK
_kernel_oserror *textarea_filter(_kernel_swi_regs *regs)
{
    _kernel_oserror *e;

    MemCheck_RegisterMiscBlock((void*)regs->r[1], 256);
    MemCheck_RegisterMiscBlock((void*)regs->r[3], sizeof(IdBlock));
    e = textarea_filter2(regs);
    MemCheck_UnRegisterMiscBlock((void*)regs->r[1]);
    MemCheck_UnRegisterMiscBlock((void*)regs->r[3]);

    return e;
}
#endif

