/* Title:   Sizes.c
 * Purpose: Work out various bits of size information, such
 *          as the current mode's scaling factors (OS units
 *          per pixel) or the width of the horizontal scroll
 *          bar.
 *
 * Revision History
 * ADH  24/03/1999  Created
 */

#include <stdlib.h>
#include <stdio.h>

#include "swis.h"
#include "kernel.h"

#include "toolbox.h"
#include "wimplib.h"

#include "Sizes.h"

/* Mode variables, as used by OS_ReadModeVariable */

typedef enum
{
  BBC_ModeFlags = 0,   /* Bit 0: Non-graphics mode                                   */
                       /* Bit 1: Teletext mode                                       */
                       /* Bit 2: Gap mode (there is a gap between VDU 4 lines)       */
                       /* Bit 3: BBC gap mode (3 and 6)                              */
                       /* Bit 4: Hi-res mono mode                                    */
                       /* Bit 5: Double height VDU chars                             */
                       /* Bit 6: Hardware scroll never used                          */
  BBC_ScrRCol,         /* Maximum text col number                                    */
  BBC_ScrBCol,         /* Maximum text row number                                    */
  BBC_NColour,         /* Maximum logical colour: 1, 3, 15 or 63                     */
  BBC_XEigFactor,      /* OS-unit->pixel shift factor. 0 -> OS-units = pixels,       */
  BBC_YEigFactor,      /* 1 -> 2 OS-units per pixel, 2 -> 4 OS-units per pixel, etc. */
  BBC_LineLength,      /* Bytes per pixel row                                        */
  BBC_ScreenSize,      /* Bytes per screen                                           */
  BBC_YShftFactor,     /* DEPRECATED; Log(2) of LineLength/5                         */
  BBC_Log2BPP,         /* Log base 2 of bits per pixel                               */
  BBC_Log2BPC,         /* Log base 2 of bytes per character                          */
  BBC_XWindLimit,      /* Screen width in pixels, minus 1                            */
  BBC_YWindLimit       /* Screen height in pixels, minus 1                           */

} bbc_modevariable;

/*
 * Simple window template for finding out tool sizes, adapted
 * from ScrollList.c
 */

static const WimpWindow window_template =
{
  {0, -100, 100, 0},                              /* visible_area */
  0,                                              /* xscroll      */
  0,                                              /* yscroll      */
  -1,                                             /* behind       */
  WimpWindow_NewFormat  | WimpWindow_AutoRedraw |
  WimpWindow_NoBounds   | WimpWindow_BackIcon   |
  WimpWindow_CloseIcon  | WimpWindow_TitleIcon  | /* flags        */
  WimpWindow_ToggleIcon | WimpWindow_SizeIcon   |
  WimpWindow_VScroll    | WimpWindow_HScroll,
  7,                                              /* title_fg     */
  2,                                              /* title_bg     */
  7,                                              /* work_fg      */
  4,                                              /* work_bg      */
  3,                                              /* scroll_outer */
  1,                                              /* scroll_inner */
  12,                                             /* highlight_by */
  0,                                              /* reserved     */
  {0, -256, 256, 0},                              /* extent       */
  0,                                              /* title_flags  */
  10 * WimpIcon_ButtonType,                       /* work_flags   */
  NULL,                                           /* sprite_area  */
  1,                                              /* min_width    */
  1,                                              /* min_height   */
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},           /* WimpIconData */
  0                                               /* nicons       */
};

/* Forward declarations */

static int bbc_vduvar (int varno);

/* sizes_x_scale()
 *
 * Return the current mode's horizontal scale factor in
 * OS units per pixel. E.g. 2 for mode 20, 4 for mode 13.
 */

unsigned int sizes_x_scale(void)
{
  return (1 << bbc_vduvar(BBC_XEigFactor));
}

/* sizes_y_scale()
 *
 * Return the current mode's vertical scale factor in
 * OS units per pixel. E.g. 2 for mode 20, 4 for mode 12.
 */

unsigned int sizes_y_scale(void)
{
  return (1 << bbc_vduvar(BBC_YEigFactor));
}


/* sizes_tool_sizes()
 *
 * Work out window tool sizes. Pass pointers to three unsigned
 * ints to receive the title bar height, vertical scroll bar
 * width and horizontal scroll bar height respectively. Any of
 * these pointers may be NULL if you're not interested in that
 * value.
 *
 * This runs fairly slowly so avoid calling too often (e.g. by
 * cacheing the returned information).
 *
 * All returned values are in OS units and include the window
 * border outlines on both of the left/right or top/bottom
 * edges.
 *
 * If there are any errors, SIZES_TOOL_DEFAULT is returned for
 * all values.
 */

void sizes_tool_sizes(unsigned int * title, unsigned int * vscroll, unsigned int * hscroll)
{
  int          handle;
  unsigned int ti, vs, hs;

  /* Anything to do? */

  if (!title && !vscroll && !hscroll) return;

  /* Start with default values */

  ti = vs = hs = SIZES_TOOL_DEFAULT;

  /* Create a simple window and open at -3 in the stack -
   * i.e. behind even the Wimp's back window
   */

  if (!wimp_create_window((WimpWindow *) &window_template, &handle))
  {
    WimpOpenWindowBlock       open;
    WimpGetWindowStateBlock   state;
    WimpGetWindowOutlineBlock outline;

    outline.window_handle = handle;
    state.window_handle   = handle;
    open.window_handle    = handle;
    open.visible_area     = window_template.visible_area;
    open.xscroll          = 0;
    open.yscroll          = 0;
    open.behind           = -3;

    if (
         !wimp_open_window(&open)           &&
         !wimp_get_window_state(&state)     &&
         !wimp_get_window_outline(&outline)
       )
    {
      /* Work out the sizes */

      ti = outline.outline.ymax - state.visible_area.ymax;
      hs = state.visible_area.ymin - outline.outline.ymin;
      vs = outline.outline.xmax - state.visible_area.xmax;
    }

    wimp_close_window(&handle);
  }

  /* Return the discovered values */

  if (title)   *title   = ti;
  if (vscroll) *vscroll = vs;
  if (hscroll) *hscroll = hs;

  return;
}

/* bbc_vduvar()
 *
 * Call OS_ReadVduVariables for a given variable number and
 * return the result, or -1 if there's an error.
 */

static int bbc_vduvar(int varno)
{
   int vars[2];
   int result;

   vars[0] = varno;
   vars[1] = -1; /* terminator */

   return _swix(OS_ReadVduVariables,
                _INR(0,1),
                vars,
                &result)
                != NULL ? -1 : result; /* relies on -1 never being valid */
}
