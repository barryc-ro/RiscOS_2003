/* Title:   ScrollList.c
 * Purpose: Scrolling list gadget for textgadgets module
 *
 * Revision History
 * piers    01/08/96 Created
 * piers    23/12/96 Added in MemCheck thingies
 * piers    06/01/97 Recoded to use a nested window so scrollbar is nicer
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "kernel.h"
#include "swis.h"

#include "toolbox.h"
#include "window.h"
#include "wimplib.h"

#include "glib.h"
#include "string32.h"
#include "riscos_utils.h"
#include "Font.h"
#include "TextGadgets.h"
#include "ScrollList.h"
#include "ScrollLisP.h"
#include "ScrollLisS.h"
#include "debug.h"
#include "myswis.h"
#include "utils.h"

#ifdef MemCheck_MEMCHECK
#include "MemCheck:MemCheck.h"
#endif

#define IGNORE(a) (a)=(a)
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#define MAX(x, y) ((x) > (y) ? (x) : (y))

static int my_icons[2] = {0, -1};

static PrivateScrollList **scrolllist_list = NULL;

static _kernel_oserror	bad_index = {0, "Bad index"};

// Cannot be a const, 'cos of the stupid blimmin' tbox header files
static BBox		redraw_box = {0, -0xffff, 0xffff, 0};

static const WindowTemplate window_template =
{
    1<<1 | 1<<2, 		// flags
    NULL,	// help_message
    0, 		// max_help
    NULL,	// pointer_shape
    0,		// max_pointer_shape
    0,		// pointer_x_hot
    0,		// pointer_y_hot
    NULL,	// no menu
    0,		// num_keyboard_shortcuts
    NULL,	// keyboard_shortcuts
    0,		// num_gadgets
    NULL,	// gadgets
    -1,		// default_focus
    0,		// show_event
    0,		// hide_event
    NULL,	// toolbar_ibl
    NULL,	// toolbar_itl
    NULL,	// toolbar_ebl
    NULL,	// toolbar_etl
    {
        // WimpWindow struct
        {0, -100, 0, 0},	// visible_area
        0,			// xscroll
        0,			// yscroll
        -1,			// behind
        WimpWindow_NewFormat | WimpWindow_VScroll,
        			// flags
        7,			// title_fg
        0,			// title_bg
        7,			// work_fg
        0xff,			// work_bg
        3,			// scroll_outer
        1,			// scroll_inner
        12,			// highlight_by
        0,			// reserved
        {0, -40960, 12800, 0},	// extent
        0,			// title_flags
        10 * WimpIcon_ButtonType,// work_flags
        NULL,			// sprite_area
        1,			// min_width
        1,			// min_height
        {
            // WimpIconData
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        },
        0			// nicons
    }
};

static /* const */ ObjectTemplateHeader scroll_list_window =
{
    Window_ObjectClass,		// object_class
    0,				// flags
    102,			// version
    "__list",			// name
    sizeof(ObjectTemplateHeader) + sizeof(WindowTemplate),	// total_size
    NULL,			// body - due to a bug in the compiler, we
    				// have to set this at run-time
    sizeof(WindowTemplate)	// body_size
};

static BBox redraw_all_box = {0, -0xffff, 0xffff, 0};

static _kernel_oserror *out_of_memory(void)
{
   return (_kernel_oserror *) "    Unable to allocate memory to store scrolllist gadget definition";
}

_kernel_oserror *scrolllist_init(void)
{
    scroll_list_window.body = (void*) &window_template;

    return NULL;
}

static _kernel_oserror *add_redraw_handler(PrivateScrollList *sl)
{
    _kernel_oserror no_mem = {0, "Not enough memory"};

    if (scrolllist_list == NULL)
    {
        if ( (scrolllist_list = malloc(sizeof(PrivateScrollList*)*2)) == NULL)
            return &no_mem;

        scrolllist_list[0] = sl;
        scrolllist_list[1] = NULL;
    }
    else
    {
        PrivateScrollList **new_list;
        unsigned int i;

        for (i = 0; scrolllist_list[i] != NULL; i++)
            ;

        new_list = realloc(scrolllist_list,
        			sizeof(PrivateScrollList*) * (i+2));

        if (new_list == NULL)
            return &no_mem;

        scrolllist_list = new_list;

        scrolllist_list[i] = sl;
        scrolllist_list[i + 1] = NULL;
    }

    return NULL;
}

static _kernel_oserror *remove_redraw_handler(PrivateScrollList *sl)
{
    _kernel_oserror bad_scrolllist = {0, "No such scrolling list"};
    unsigned int i, j;

    if (scrolllist_list == NULL)
        return &bad_scrolllist;

    for (i = 0;
        (scrolllist_list[i] != NULL) && (scrolllist_list[i] != sl);
        i++)
        ;

    if (scrolllist_list[i] == NULL)
        return &bad_scrolllist;

    for (j = i; scrolllist_list[j] != NULL; j++)
        ;

    // j points to last entry

    if (j <= 1)
    {
        free(scrolllist_list);
        scrolllist_list = NULL;
    }
    else
    {
        PrivateScrollList **new_list;

        for (; i < j; i++)
            scrolllist_list[i] = scrolllist_list[i + 1];

        // No need to generate an error if the realloc fails, 'cos
        // it'll just realloc next time, hopefully
        new_list = realloc(scrolllist_list,
        			sizeof(PrivateScrollList) * (j+1));

        if (new_list != NULL)
            scrolllist_list = new_list;
    }

    return NULL;
}

/* ------------------------------------------------------------------------
 */
static unsigned int _get_height_of_entry(const PrivateScrollList *sdata,
		int *base_line)
{
    unsigned int font_handle;
    int min, max;

    font_handle = sdata->font_handle;
    if (!font_handle)
    {
        _kernel_oserror *e;

        e = _swix(Wimp_ReadSysInfo, _IN(0)|_OUT(0), 8, &font_handle);
        if (e)
            return 0;
    }

    if (!font_handle)
        return 32;

    _swix(Font_ReadInfo, _IN(0)|_OUT(2)|_OUT(4),
    		font_handle, &min, &max);
    if (base_line)
        *base_line = min;

    return abs(min) + abs(max);
}

static void _get_size_of_sprites(const PrivateScrollList *sdata,
		unsigned int *max_sprite_width, unsigned int *max_sprite_height)
{
    unsigned int i;

    if (max_sprite_width != NULL)
        *max_sprite_width = 0;
    if (max_sprite_height != NULL)
        *max_sprite_height = 0;

    for (i = 0; i < sdata->no_entries; i++)
    {
        unsigned int sprite_info = sdata->entries[i].flags &
        			(FLAGS_SPRITE_AREA | FLAGS_SPRITE_NAME);

        if (sdata->entries[i].sprite_name)
        {
            unsigned int sprite_width = 0, sprite_height = 0;

            if (sprite_info == 3)
                continue;

            if (sprite_info == 0)
            {
                // Sprite in wimp poll
                _swix(Wimp_SpriteOp, _IN(0)|_IN(2)|_OUTR(3,4), 40,
                	sdata->entries[i].sprite_name,
                	&sprite_width, &sprite_height);
            }
            else
            {
                // Sprite in sprite area
                _swix(OS_SpriteOp, _INR(0,2)|_OUTR(3,4),
                	40 + (sprite_info == 1) ? 256 : 512,
                	sdata->entries[i].sprite_area,
                	sdata->entries[i].sprite_name,
                	&sprite_width, &sprite_height);
            }

            if (!(sdata->entries[i].flags & FLAGS_HALF_SIZE))
            {
                sprite_width *= 2;
                sprite_height *= 2;
            }

            if (max_sprite_width && (sprite_width > *max_sprite_width))
                *max_sprite_width = sprite_width;
            if (max_sprite_height && (sprite_height > *max_sprite_height))
                *max_sprite_height = sprite_height;
        }
    }
}

static void _get_item_size(const PrivateScrollList *sdata,
	unsigned int *width, unsigned int *height, int *base_line)
{
    unsigned int	item_height, font_height, item_width;
    int			base;

    _get_size_of_sprites(sdata, &item_height, &item_width);

    if (height)
    {
        font_height = _get_height_of_entry(sdata, &base);
        *height = MAX(font_height, item_height) + 4;
    }

    if (width)
        *width = item_width + 4;

    if (base_line)
        *base_line = base;
}

static void _set_extent(const PrivateScrollList *sdata)
{
    BBox		new;
    unsigned int	entry_height;

    _get_item_size(sdata, NULL, &entry_height, NULL);

    new.xmin = 0;
    new.xmax = 0xfff;
    new.ymin = -sdata->no_entries * entry_height;
    if (new.ymin > (sdata->box.ymin - sdata->box.ymax))
        new.ymin = sdata->box.ymin - sdata->box.ymax;
    new.ymax = 0;

    window_set_extent(0, sdata->object_id, &new);
}

static _kernel_oserror *_show(PrivateScrollList *sdata)
{
    WindowShowObjectBlock	show_block;

    work_to_screen_handle(&show_block.visible_area, &sdata->box,
    				sdata->parent_window);
    show_block.visible_area.xmax -= SCROLLBAR_SIZE;

    show_block.xscroll = show_block.yscroll = 0;
    show_block.behind = -1;
    show_block.window_flags = 0;
    show_block.parent_window_handle = sdata->parent_window;
    show_block.alignment_flags = 0;

    _set_extent(sdata);

    toolbox_show_object(Toolbox_ShowObject_AsSubWindow, sdata->object_id,
  			Toolbox_ShowObject_FullSpec, &show_block,
  			sdata->parent_id, -1);

    return NULL;
}

static void _redraw(PrivateScrollList *sdata,
				WimpRedrawWindowRequestEvent *event)
{
    WimpRedrawWindowBlock block;
    int			more;
    BBox		box;
    unsigned int	max_height, max_sprite_width;
    int			convertx, converty, base_line;

    block.window_handle = event->window_handle;

    wimp_redraw_window(&block, &more);

    convertx = block.visible_area.xmin - block.xscroll;
    converty = block.visible_area.ymax - block.yscroll;

    // Calculate item height
    _get_item_size(sdata, &max_sprite_width, &max_height, &base_line);

    while (more)
    {
        colourtrans_set_gcol(sdata->background, 1<<7, 0);

        os_plot(PLOT_MOVE, block.redraw_area.xmin, block.redraw_area.ymin);
        os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK,
        		block.redraw_area.xmax, block.redraw_area.ymax);

        box.xmin = block.redraw_area.xmin - convertx;
        box.xmax = block.redraw_area.xmax - convertx;
        box.ymin = block.redraw_area.ymin - converty;
        box.ymax = block.redraw_area.ymax - converty;

        _scrolllist_redraw(sdata, &block, &box, max_sprite_width, max_height,
        				base_line);

        wimp_get_rectangle(&block, &more);
    }

    return;
}

int scrolllist_active(void)
{
    return scrolllist_list != NULL;
}

_kernel_oserror *scrolllist_die(void)
{
    return NULL;
}

/* scrolllist_add ---------------------------------------------------------
 */
_kernel_oserror *
scrolllist_add(ScrollList *sdata, int wimpw, ObjectId object_id,
				int **icons, int **data)
{
    _kernel_oserror	*e;
    PrivateScrollList	*sl;

    sl = (PrivateScrollList *) mem_allocate(sizeof(PrivateScrollList));
    if (!sl)
        return out_of_memory();

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(sl, sizeof(PrivateScrollList));
#endif

    if ((e = toolbox_create_object(1, &scroll_list_window,
    					&sl->object_id)) != NULL)
    {
#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(sl);
#endif
        mem_free(sl);
        return e;
    }
    *data = (int *) sl;

    sl->event = sdata->event ? sdata->event : ScrollList_Selection;
    sl->state = sdata->hdr.flags;
    sl->parent_id = object_id;
    sl->component_id = sdata->hdr.component_id;

    sl->parent_window = wimpw;
    sl->box = sdata->hdr.box;
    sl->entries = NULL;
    sl->no_entries = 0;
    sl->foreground = sdata->foreground;
    sl->background = sdata->background;
    sl->font_handle = 0;
    sl->visible = 0;

    *icons = my_icons;

    add_redraw_handler(sl);

    add_task_interest(GLib_ToolboxEvents, filter_toolbox_events,
    				TextGadgets_Filter);
    add_task_interest(GLib_WimpEvents, filter_wimp_events,
    				TextGadgets_Filter);

    _show(sl);

    return NULL;
}

_kernel_oserror *scrolllist_remove(PrivateScrollList *handle)
{
    remove_redraw_handler(handle);

    if (handle->font_handle)
        font_lose_font(handle->font_handle);

    if (handle->entries)
    {
        while (handle->no_entries)
        {
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock(
            		handle->entries[handle->no_entries - 1].text);
#endif
            mem_free(handle->entries[handle->no_entries - 1].text);
            if (handle->entries[handle->no_entries - 1].sprite_name != NULL)
            {
#ifdef MemCheck_MEMCHECK
                MemCheck_UnRegisterMiscBlock(
            		handle->entries[handle->no_entries - 1].sprite_name);
#endif
                mem_free(handle->entries[handle->no_entries - 1].sprite_name);
            }
            handle->no_entries--;
        }

        free(handle->entries);
    }

    remove_task_interest(GLib_ToolboxEvents, filter_toolbox_events);
    remove_task_interest(GLib_WimpEvents, filter_wimp_events);
    toolbox_delete_object(0, handle->object_id);

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(handle);
#endif
    mem_free(handle);

    return NULL;
}

static _kernel_oserror *_set_colour(PrivateScrollList *handle,
	unsigned int flags, unsigned int foreground, unsigned int background)
{
    if (flags | ScrollList_DesktopColours == flags)
    {
        // Need to translate desktop colours to real colours
        Palette	palette;
        _kernel_oserror bad_col = {0, "Invalid desktop colour"};

        if ((foreground > 15) || (background > 15))
            return &bad_col;

        _swix(Wimp_ReadPalette, _IN(1)|_IN(2),&palette,0x45555254/*'TRUE'*/);
        foreground = palette.colours[foreground] & ~0xff;
        background = palette.colours[background] & ~0xff;
    }
    handle->foreground = foreground;
    handle->background = background;

    return NULL;
}

static _kernel_oserror *_add_item(PrivateScrollList *sdata,
	const char *text, const void *sprite_area, const char *sprite_name,
	int index, unsigned int flags)
{
    _kernel_oserror	no_mem = {0, "Not enough memory to add item"};
    struct _entries	*new_list;

    // Alloc array of char *s
    if (sdata->entries == NULL)
        new_list = malloc(sizeof(struct _entries));
    else
        new_list = realloc(sdata->entries, sizeof(struct _entries) *
        					(sdata->no_entries + 1));
    if (new_list == NULL)
        return &no_mem;

    sdata->entries = new_list;

    if ((index < 0) || (index > sdata->no_entries) ||
    	(sdata->no_entries == 0))
    {
        // Add item at end of list

        sdata->entries[sdata->no_entries].text = mem_allocate(strlen(text) + 1);
        if (sdata->entries[sdata->no_entries].text == NULL)
        {
            // Can't be bothered to shrink sdata->entries - only one bit
            // bigger, and will get realloc'd down on next call anyway
            return &no_mem;
        }
#ifdef MemCheck_MEMCHECK
        MemCheck_RegisterMiscBlock(sdata->entries[sdata->no_entries].text,
        			strlen(text) + 1);
#endif
        strcpy(sdata->entries[sdata->no_entries].text, text);

        sdata->entries[sdata->no_entries].sprite_area = (const int*)sprite_area;
        if (sprite_name != NULL)
        {
            sdata->entries[sdata->no_entries].sprite_name = mem_allocate(13);
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock(
        			sdata->entries[sdata->no_entries].sprite_name,
        			13);
#endif
            if (sdata->entries[sdata->no_entries].sprite_name == NULL)
                return &no_mem;

            strncpy(sdata->entries[sdata->no_entries].sprite_name,
            	sprite_name, 12);
            sdata->entries[sdata->no_entries].sprite_name[12] = '\0';
        }
        else
            sdata->entries[sdata->no_entries].sprite_name = NULL;

        sdata->entries[sdata->no_entries].flags = flags & 7;
    }
    else
    {
        // Insert entry
        unsigned int i;
        char *new_item;
        char *new_spr_name;

        new_item = mem_allocate(strlen(text) + 1);
        if (new_item == NULL)
            return &no_mem;
#ifdef MemCheck_MEMCHECK
        MemCheck_RegisterMiscBlock(new_item, strlen(text) + 1);
#endif
        strcpy(new_item, text);

        if (sprite_name != NULL)
        {
            new_spr_name = mem_allocate(strlen(sprite_name) + 1);
            if (new_spr_name == NULL)
                return &no_mem;
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock(new_spr_name, strlen(sprite_name) + 1);
#endif
            strcpy(new_spr_name, sprite_name);
        }
        else new_spr_name = NULL;

        for (i = sdata->no_entries; i > index; i--)
        {
            sdata->entries[i].text = sdata->entries[i - 1].text;
            sdata->entries[i].sprite_area = sdata->entries[i - 1].sprite_area;
            sdata->entries[i].sprite_name = sdata->entries[i - 1].sprite_name;
            sdata->entries[i].flags = sdata->entries[i - 1].flags;
        }

        sdata->entries[index].text = new_item;
        sdata->entries[index].sprite_area = sprite_area;
        sdata->entries[index].sprite_name = new_spr_name;
        sdata->entries[index].flags = flags & 7;
    }

    sdata->no_entries++;

    // Update window extent
    _show(sdata);

//    scrolllist_update(sdata, sdata->box.xmin, sdata->box.ymin,
//    		sdata->box.xmax - SCROLLBAR_SIZE, sdata->box.ymax);
    window_force_redraw(0, sdata->object_id, &redraw_box);

    return NULL;
}

static _kernel_oserror *_delete_items(PrivateScrollList *sdata,
				int start, int end)
{
    unsigned int	i, j;

    if (start < 0)
        start = 0;
    if (end > sdata->no_entries - 1)
        end = sdata->no_entries - 1;

    if ((end < start) || (sdata->no_entries == 0))
        return NULL;

    // Free all memory used
    for (i = start; i <= end; i++)
    {
#ifdef MemCheck_MEMCHECK
        MemCheck_UnRegisterMiscBlock(sdata->entries[i].text);
#endif
        mem_free(sdata->entries[i].text);
        if (sdata->entries[i].sprite_name != NULL)
        {
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock(sdata->entries[i].sprite_name);
#endif
            mem_free(sdata->entries[i].sprite_name);
        }
    }

    // Compact down any existing entries
    for (j = start; i < sdata->no_entries; i++, j++)
    {
        sdata->entries[j].text = sdata->entries[i].text;
        sdata->entries[j].sprite_area = sdata->entries[i].sprite_area;
        sdata->entries[j].sprite_name = sdata->entries[i].sprite_name;
        sdata->entries[j].flags = sdata->entries[i].flags;
    }

    sdata->no_entries -= end - start + 1;

    // Update extent
    _show(sdata);

//    scrolllist_update(sdata, sdata->box.xmin, sdata->box.ymin,
//    		sdata->box.xmax - SCROLLBAR_SIZE, sdata->box.ymax);
    window_force_redraw(0, sdata->object_id, &redraw_box);

    return NULL;
}

#define SELECT_SELECT	0
#define SELECT_DESELECT	1
#define SELECT_TOGGLE	2

static _kernel_oserror *_select_item(const PrivateScrollList *sdata, int index,
					unsigned int selected)
{
    BBox		box;
    unsigned int	item_height;

    if ((index < 0) || (index >= sdata->no_entries))
        return &bad_index;

    _get_item_size(sdata, NULL, &item_height, NULL);
    box.xmin = 0;
    box.xmax = 0xfff;

    if (!(sdata->state & ScrollList_MultipleSelections))
    {
        // Deselect all
        int i;

        for (i = 0; i < sdata->no_entries; i++)
        {
            if (i == index)
                continue;

            if (sdata->entries[i].flags & FLAGS_SELECTED)
            {
                sdata->entries[i].flags &= ~FLAGS_SELECTED;

                box.ymin = -(i + 1) * item_height;
                box.ymax = -i * item_height;

                window_force_redraw(0, sdata->object_id, &box);
            }
        }
    }

    if (selected == SELECT_SELECT)
        sdata->entries[index].flags |= FLAGS_SELECTED;
    else if (selected == SELECT_DESELECT)
        sdata->entries[index].flags &= ~FLAGS_SELECTED;
    else // SELECT_TOGGLE
        sdata->entries[index].flags ^= FLAGS_SELECTED;

    box.ymin = -(index + 1) * item_height;
    box.ymax = -index * item_height;

    window_force_redraw(0, sdata->object_id, &box);

    return NULL;
}

static _kernel_oserror *_set_font(PrivateScrollList *sdata,
				const char *font,
				unsigned int width, unsigned int height)
{
    _kernel_oserror	*e;

    if (sdata->font_handle != 0)
    {
        // Free existing font handle
        font_lose_font(sdata->font_handle);
        sdata->font_handle = 0;
    }

    // Get new font handle
    if (font == NULL)
    {
        sdata->font_handle = 0;
    }
    else
    {
        e = font_find_font(font, width, height, 0, 0,
        			&sdata->font_handle);
        if (e)
        {
            sdata->font_handle = 0;
            return e;
        }
    }

    scrolllist_update(sdata, sdata->box.xmin, sdata->box.ymin,
    		sdata->box.xmax - SCROLLBAR_SIZE, sdata->box.ymax);

    return NULL;
}

static _kernel_oserror *_get_selected(const PrivateScrollList *sdata,
				unsigned int offset, int *new_offset)
{
    if (sdata == NULL || new_offset == NULL)
        return NULL;

    for (offset++; offset < sdata->no_entries; offset++)
    {
        if (sdata->entries[offset].flags & FLAGS_SELECTED)
        {
            *new_offset = offset;
            return NULL;
        }
    }

    *new_offset = -1;

    return NULL;
}

static _kernel_oserror *_make_visible(const PrivateScrollList *sdata,
			int visible)
{
    unsigned int		item_height;
    WimpGetWindowStateBlock	block;

    _get_item_size(sdata, NULL, &item_height, NULL);

    window_get_wimp_handle(0, sdata->object_id, &block.window_handle);

    wimp_get_window_state(&block);

    block.yscroll = -visible * item_height;

    wimp_open_window((WimpOpenWindowBlock *) &block);

    return NULL;
}

static _kernel_oserror *_get_item_text(const PrivateScrollList *sdata,
			char *buffer, int buffer_size, int index, int *nbytes)
{
    if (index >= sdata->no_entries)
        return &bad_index;

    if (buffer == NULL)
    {
        *nbytes = strlen(sdata->entries[index].text) + 1;
        return NULL;
    }

    strncpy(buffer, sdata->entries[index].text, buffer_size);

    *(buffer + buffer_size - 1) = '\0';

    if (nbytes)
        *nbytes = strlen(buffer) + 1;

    return NULL;
}

_kernel_oserror *scrolllist_method(PrivateScrollList *sdata,
				_kernel_swi_regs *regs)
{
    _kernel_oserror *e = NULL;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(regs, sizeof(_kernel_swi_regs));
#endif

    switch (regs->r[2])
    {
        case ScrollList_GetState:
            regs->r[0] = sdata->state;
            break;

        case ScrollList_SetState:
            sdata->state = regs->r[4];
            break;

        case ScrollList_AddItem:
#ifdef MemCheck_MEMCHECK
            MemCheck_RegisterMiscBlock((void*)regs->r[4],
            			strlen((char*)regs->r[4]) + 1);
            MemCheck_SetBlockAccess((void*)regs->r[4], 1, 0); // read only
            MemCheck_RegisterMiscBlock((void*)regs->r[5], 4);
            if (regs->r[5] != NULL)
            {
                MemCheck_ResizeMiscBlock((void*)regs->r[5],*((int*)regs->r[5]));
            }
            MemCheck_SetBlockAccess((void*)regs->r[5], 1, 0); // read only
            MemCheck_RegisterMiscBlock((void*)regs->r[6],
            			strlen((char*)regs->r[6]) + 1);
            MemCheck_SetBlockAccess((void*)regs->r[6], 1, 0); // read only
#endif
            e = _add_item(sdata, (const char *)regs->r[4],
            		(const void *)regs->r[5], (const char *)regs->r[6],
            		regs->r[7], regs->r[0]);
#ifdef MemCheck_MEMCHECK
            MemCheck_UnRegisterMiscBlock((void*)regs->r[4]);
            MemCheck_UnRegisterMiscBlock((void*)regs->r[5]);
            MemCheck_UnRegisterMiscBlock((void*)regs->r[6]);
#endif
            break;

        case ScrollList_DeleteItems:
            e = _delete_items(sdata, regs->r[4], regs->r[5]);
            break;

        case ScrollList_SelectItem:
            e = _select_item(sdata, regs->r[4], SELECT_SELECT);
            break;

        case ScrollList_DeselectItem:
            e = _select_item(sdata, regs->r[4], SELECT_DESELECT);
            break;

        case ScrollList_GetSelected:
            e = _get_selected(sdata, regs->r[4], &(regs->r[0]));
            break;

        case ScrollList_MakeVisible:
            _make_visible(sdata, regs->r[4] < 0 ? 0 : regs->r[4]);
            break;

        case ScrollList_SetColour:
            // R4 = foreground col, R5 = background col
            e = _set_colour(sdata, regs->r[0], regs->r[4], regs->r[5]);
            scrolllist_update(sdata, sdata->box.xmin, sdata->box.ymin,
    		sdata->box.xmax - SCROLLBAR_SIZE, sdata->box.ymax);
            break;

        case ScrollList_GetColour:
            regs->r[0] = sdata->foreground;
            regs->r[1] = sdata->background;
            break;

        case ScrollList_SetFont:
            e = _set_font(sdata, (const char *)regs->r[4], regs->r[5],
            			regs->r[6]);
            break;

        case ScrollList_GetItemText:
            e = _get_item_text(sdata, (char*)regs->r[4], regs->r[5],
            			regs->r[6], &(regs->r[5]));
            break;

        default:
            break;
   }

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(regs);
#endif

   return e;
}

/* ------------------------------------------------------------------------
 */
_kernel_oserror *scrolllist_fade(PrivateScrollList *sdata, int fade)
{
    // Redraw all of gadget, faded
    // (plot foreground colour as foreground + background / 2, and
    // background as background
    IGNORE(fade);

    sdata->state &= ~Gadget_Faded;
    sdata->state |= fade ? Gadget_Faded : 0;

    window_force_redraw(0, sdata->object_id, &redraw_all_box);

    return NULL;
}

_kernel_oserror *scrolllist_move(int type, PrivateScrollList *sdata,
				BBox *box)
{
    IGNORE(type);

    sdata->box = *box;

    return _show(sdata);
}

/* ------------------------------------------------------------------------
 */

_kernel_oserror *scrolllist_plot(ScrollList *sdata)
{
    _kernel_oserror		*e;
    WimpGetWindowStateBlock	state;
    BBox			box;
    int				x;

    if (redrawing_window == 0)
        return NULL;

#ifdef MemCheck_MEMCHECK
    MemCheck_RegisterMiscBlock(sdata, sizeof(ScrollList));
#endif

    state.window_handle = redrawing_window;
    if ((e = wimp_get_window_state(&state)) != NULL)
        return e;

    box = sdata->hdr.box;
    work_to_screen(&box, &state);

    // Plot background
    colourtrans_set_gcol(sdata->background, 0, 0);
    os_plot(PLOT_MOVE, box.xmin, box.ymin);
    os_plot(PLOT_RECTANGLE_FILL | PLOT_DRAW, box.xmax, box.ymax);

    // Plot foreground (no actual sub-window on plotting...)
    colourtrans_set_gcol(sdata->foreground, 0, 0);
    os_plot(PLOT_DRAW, box.xmin, box.ymax);
    os_plot(PLOT_DRAW, box.xmin, box.ymin);
    os_plot(PLOT_DRAW, box.xmax, box.ymin);
    os_plot(PLOT_DRAW, box.xmax, box.ymax);

    // Plot fake scrollbar (black)
    colourtrans_set_gcol(0 /* black */, 1<<7, 0);
    x = MAX(box.xmax - SCROLLBAR_SIZE, box.xmin);
    os_plot(PLOT_MOVE, x, box.ymin);
    os_plot(PLOT_RECTANGLE_FILL | PLOT_BACK, box.xmax, box.ymax);

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(sdata);
#endif

    return NULL;
}

_kernel_oserror *_scrolllist_redraw(const PrivateScrollList *sdata,
				WimpGetRectangleBlock *block, BBox *box,
				unsigned int sprite_width,
				unsigned int item_height, int base_line)
{
    unsigned int	i, y;

    IGNORE(block);

    if (sdata->entries == NULL)
        return NULL;

    i = (-box->ymax) / item_height;

    for (y = block->visible_area.ymax - block->yscroll - ((i+1) * item_height);
    	(y + item_height > block->redraw_area.ymin) && (i < sdata->no_entries);
    	y -= item_height, i++)
    {
        // Plot item i
        unsigned int foreground, background;

        if (sdata->entries[i].flags & FLAGS_SELECTED)
        {
            colourtrans_set_gcol(sdata->foreground, 0, 0);
            os_plot(PLOT_MOVE, block->visible_area.xmin, y);
            os_plot(PLOT_RECTANGLE_FILL | PLOT_DRAW,
            	block->visible_area.xmax - 1, y + item_height - 1);
        }

        // Plot sprite
        if (sdata->entries[i].sprite_name)
        {
            unsigned int sprite_info = sdata->entries[i].flags &
            			(FLAGS_SPRITE_AREA | FLAGS_SPRITE_NAME);

            if (sprite_info != (FLAGS_SPRITE_AREA | FLAGS_SPRITE_NAME))
            {
                // We have a sprite to plot
                WimpPlotIconBlock	icon;

                icon.bbox.xmin = 4;
                icon.bbox.ymin = -(i+1) * item_height;
                icon.bbox.xmax = sprite_width + 8;
                icon.bbox.ymax = -i * item_height;
                icon.flags = WimpIcon_Sprite | WimpIcon_HCentred |
                			WimpIcon_VCentred | WimpIcon_Indirected;

                icon.data.is.sprite = sdata->entries[i].sprite_name;
                if (sprite_info == 0)
                    icon.data.is.sprite_area = (int*)1; // Wimp sprite area
                else
                    icon.data.is.sprite_area = (int*)
                    				sdata->entries[i].sprite_area;
                if (sprite_info == 2)
                    icon.data.is.sprite_name_length = 0;
                else
                    icon.data.is.sprite_name_length = strlen(
                    				icon.data.is.sprite);

                if (sdata->entries[i].flags & FLAGS_HALF_SIZE)
                    icon.flags |= WimpIcon_HalfSize;

                if (sdata->entries[i].flags & FLAGS_SELECTED)
                    icon.flags |= WimpIcon_Selected;

                if (sdata->state & Gadget_Faded)
                    icon.flags |= WimpIcon_Shaded;

                wimp_plot_icon(&icon);
            }
        }

        if (sdata->entries[i].flags & FLAGS_SELECTED)
        {
            foreground = sdata->background;
            background = sdata->foreground;
        }
        else
        {
            foreground = sdata->foreground;
            background = sdata->background;
        }

        if (sdata->state & Gadget_Faded)
            foreground = foreground & 0xfdfdfd00;

        // Plot text
        if (!sdata->font_handle)
        {
            // No outline font set so use Wimp_TextOp - this is safe, since we
            // already require nested windows, so must have this SWI too...

            // Set the colours
            _swix(Wimp_TextOp, _INR(0,2), 0, foreground, background);

            // Plot the text
            _swix(Wimp_TextOp, _INR(0,5), 2 | 1<<30, sdata->entries[i].text,
            		-1, -1, block->visible_area.xmin + sprite_width +12,
            		y - base_line);
        }
        else
        {
            // Plot using an outline font
            colourtrans_set_font_colours(sdata->font_handle, background,
            			foreground, 14);

            font_paint(sdata->font_handle, sdata->entries[i].text,
            		1<<4 | 1<<9, // OS units, kerning...
            		block->visible_area.xmin + sprite_width + 12,
            		y - base_line, 0, 0, 0);
        }
    }

    return NULL;
}

static _kernel_oserror *scrolllist_mclick(const PrivateScrollList *sdata,
		WimpMouseClickEvent *click)
{
    _kernel_oserror		*e;
    WimpGetWindowStateBlock	state;
    int				mouse_x, mouse_y;
    ScrollListSelectionEvent	event;
    unsigned int		item_height;

    if (click->buttons == 2)
    {
        // Menu clicked
        ObjectId	menu_id;

        window_get_menu(0, sdata->parent_id, &menu_id);
        if (menu_id != 0)
            toolbox_show_object(0, menu_id, 0, 0,
                                sdata->parent_id, sdata->component_id);

        return NULL;
    }

    // Check if it's a drag
    if (click->buttons >= 16 && click->buttons <256)
        return NULL;

    window_get_wimp_handle(0, sdata->object_id, &state.window_handle);
    e = wimp_get_window_state(&state);
    if (e) return e;

    mouse_x = click->mouse_x + state.visible_area.xmin + state.xscroll;
    mouse_y = click->mouse_y - state.visible_area.ymax + state.yscroll;

    _get_item_size(sdata, NULL, &item_height, NULL);

    event.item = -mouse_y / item_height;

    if (click->buttons >= 256)
    {
        if ((click->buttons / 256) & (1<<0))
        {
            _select_item(sdata, event.item, SELECT_TOGGLE);
        }
        else if ((click->buttons / 256) & (1<<2))
        {
            if (!(sdata->entries[event.item].flags & FLAGS_SELECTED))
                _select_item(sdata, event.item, SELECT_SELECT);
        }
    }

    // Send event

    if (event.item > sdata->no_entries)
        return NULL;

    event.hdr.size = sizeof(ScrollListSelectionEvent);
    event.hdr.reference_number = 0;
    event.hdr.event_code = sdata->event;
    event.hdr.flags = 0;
    event.flags = 0;

    if (click->buttons < 16)
    {
        // double click
        event.flags |= ScrollList_Selection_Flags_DoubleClick;
    }

    toolbox_raise_toolbox_event(0, sdata->parent_id, sdata->component_id,
    			(ToolboxEvent *) &event);

    return NULL;
}

#ifdef MemCheck_MEMCHECK
static _kernel_oserror *scrolllist_filter2(_kernel_swi_regs *regs)
#else
_kernel_oserror *scrolllist_filter(_kernel_swi_regs *regs)
#endif
{
    ToolboxEvent	*event = (ToolboxEvent *)regs->r[1];
    IdBlock		*id_block = (IdBlock *)regs->r[3];
    int			event_code = regs->r[0];
    unsigned int	i;

    if (scrolllist_list == NULL)
        return NULL;

    if (event_code == Wimp_ERedrawWindow)
    {
        for (i = 0; scrolllist_list[i] != NULL; i++)
        {
            WimpRedrawWindowRequestEvent *wimp_redraw_event =
            				(WimpRedrawWindowRequestEvent *) event;
            int			window_handle;

            window_get_wimp_handle(0, scrolllist_list[i]->object_id,
            			&window_handle);

            if (window_handle == wimp_redraw_event->window_handle)
            {
                _redraw(scrolllist_list[i], wimp_redraw_event);

                // Claim event, since we don't want the application to do any
                // redraw
                regs->r[0] = -1;
            }
        }

        return NULL;
    }
    else if (event_code == Wimp_EMouseClick)
    {
        for (i = 0; scrolllist_list[i] != NULL; i++)
        {
            WimpMouseClickEvent *wimp_mouse_event = (WimpMouseClickEvent*)event;
            int			window_handle;

            window_get_wimp_handle(0, scrolllist_list[i]->object_id,
            			&window_handle);

            if (window_handle == wimp_mouse_event->window_handle)
            {
                scrolllist_mclick(scrolllist_list[i], wimp_mouse_event);
                // Claim event
                regs->r[0] = -1;
            }
        }

        return NULL;
    }

    if ((event_code != 512) ||
        ((id_block->self_component & 0xfff) != 0x800) ||
        (scrolllist_list == NULL))
        return NULL;

    if (event->hdr.event_code == Toolbox_ObjectDeleted)
    {
        int remaining = 0;
        PrivateScrollList **new_list;
        // An object has been deleted, so remove from internal list
        // any gadgets inside it.
        for (i = 0; scrolllist_list[i] != NULL; i++)
        {
            if (scrolllist_list[i]->parent_id == id_block->self_id)
            {
                // Found one!
                int j;
                for (j = i; scrolllist_list[j] != NULL; j++)
                {
                    // Copy down following gadgets
                    scrolllist_list[j] = scrolllist_list[j+i];
                }
            }
            else
                remaining++;
        }

        // Shrink memory block
        if (remaining == 0)
        {
            free(scrolllist_list);
            scrolllist_list = NULL;
        }
        else
        {
            new_list = realloc(scrolllist_list,
        			sizeof(PrivateScrollList) * (remaining + 1));
            if (new_list != NULL)
                scrolllist_list = new_list;
        }
    }

    return NULL;
}

#ifdef MemCheck_MEMCHECK
_kernel_oserror *scrolllist_filter(_kernel_swi_regs *regs)
{
    _kernel_oserror *e;

    MemCheck_RegisterMiscBlock((void*)regs->r[1], 256);
    MemCheck_RegisterMiscBlock((void*)regs->r[3], sizeof(IdBlock));
    e = scrolllist_filter2(regs);
    MemCheck_UnRegisterMiscBlock((void*)regs->r[1]);
    MemCheck_UnRegisterMiscBlock((void*)regs->r[3]);

    return e;
}
#endif
