/*
 * Process.c
 *
 * Walk through the connections etc. processing any pending
 * data. Use select() to check network connections
 *
 * © Acorn Computers Ltd. 1993-1997
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include "kernel.h"
#include "swis.h"
#include "sys/types.h"
#include "sys/socket.h"
#include "sys/ioctl.h"
#include "netinet/in.h"
#include "sys/errno.h"
#include "socklib.h"
#include "sys/time.h"
#include "sys/select.h"
#include "sys/time.h"
#include "structs.h"
#include "include.h"
#include "process_gl.h"
#include "config_glo.h"
#include "serve_glob.h"
#include "cache_glob.h"
#include "network.h"
#include "debug.h"
#include "generic.h"
#include "network.h"
#include "filemanage.h"
#include "headers.h"
#include "main.h"
#include "checkloop.h"
#include "messages.h"

#define MimeMap_Translate	0x50B00	/* MimeMap SWI base */


#define SPEEDY_BUFFERS

static void process_set_initilise(SD default_sd);
static void process_rebuild_set(void);
static void process_add_socket(SD sd, int read); /* add a process */
/*static void process_del_socket(SD sd, int read);*/ /* remove process */
static void process_connect(void);
static void kill_active_process(process_list proc);
static void process_read(process_list proc);
static void process_parse_request(process_list proc);
static void process_dialling(process_list proc);
static void process_checking(process_list proc);
static void process_write(process_list proc);
static void process_write_header(process_list proc);
static void process_write_fromcache(process_list proc);
static void process_write_frombuffer(process_list proc);
static void process_cachedata(process_list proc);
static _kernel_oserror *data_from_wire(process_list proc, char *buffer, int buffersize, int *p_received, int *p_xfercomplete, int *p_xferaborted);
static void data_from_file(process_list proc, char *buffer, int buffersize, int *p_received, int *p_xfercomplete, int *p_xferaborted);
static int  data_to_user(process_list proc, char *buffer, int received, int xfercomplete, int xferaborted, int mustgo, int *p_errorsending);
static void header_to_user(process_list proc, int *p_errorsending);

extern void process_DiallingState(int state);
extern void process_URLAccessRights(int message_ref, int access);
extern void process_main(void);

static process_list new_process_record(SD sock);
static void free_process_record(process_list proc);

static void process_start_dynamic_error(process_list proc, _kernel_oserror *e);

static void process_deregister_url(process_list proc);

#define SWI_URL_Register   0x83e00
#define SWI_URL_GetURL	   0x83e01
#define SWI_URL_Status	   0x83e02
#define SWI_URL_ReadData   0x83e03
#define SWI_URL_SetProxy   0x83e04
#define SWI_URL_Stop	   0x83e05
#define SWI_URL_Deregister 0x83e06

static int    process_GetURLCache_delayed = 0;
static int    keep_line_active = 0;
static time_t last_resettimer  = 0;
static int    keep_dialling	   = 0;
static time_t last_connect_command = 0;
static int id=0;

process_list global_processes;


static fd_set fdr; /* server read */
static fd_set fdw; /* server write */
static fd_set fde; /* server exceptions */
static SD max_sd; /* max SD in use */

#ifdef TRACE
static char *process_state_name(int state)
{
	switch (state) {
		case PROC_WRITE_FROMBUFFER: return "PROC_WRITE_FROMBUFFER";
		case PROC_CHECKING: return "PROC_CHECKING";
		case PROC_DIALLING: return "PROC_DIALLING";
		case PROC_WRITE_HEADER: return "PROC_WRITE_HEADER";
		case PROC_CACHEDATA: return "PROC_CACHEDATA";
		case PROC_WRITE_FROMCACHE: return "PROC_WRITE_FROMCACHE";
		case PROC_KILL: return "PROC_KILL";
		case PROC_READ: return "PROC_READ";
		case PROC_WRITE: return "PROC_WRITE";
		case PROC_NULL: return "PROC_NULL";
		default:
			return "<UNKNOWN>";
	}
}
#endif

#define seconds_per_minute (60)

/*
 * This is the real workhorse routine of the whole program.
 * Basically it checks all outstanding connections and sees if
 * there is anything to do with them.
 */
int process_connections(void)
{
	int count=0;		/* number of sockets affected */
	struct timeval timeout; /* so we can non-block the select() */
	process_list *insert;	/* list of all connections */

	#if 0
	return;
	#endif

	/* if we havent bound to a socket return */
	if (http_socket == -1) return 0;

	/* setup what we think will be the max socket */
	max_sd = http_socket;

	/* zero the timeout structure */
	timerclear(&timeout);

	/* Recreate the fd_sets for this pass */
	process_set_initilise(http_socket);
	process_rebuild_set();

	/*
	 * Ask select what is happening. NOTE: this is non-blocking
	 * and a once only scan.
	 */
	count = select(FD_SETSIZE, &fdr, &fdw, &fde, &timeout);

	/* If nothing is pending return immediatly to speed things up */
	if ((count==0) && (global_processes->next==NULL) && (global_cache_writeback_delayed == 0) && (process_GetURLCache_delayed == 0)) {
		return 0;
	}

	/* Look to see if we have a new incoming connection */
	if (FD_ISSET(http_socket,&fdr)) {
		/* accept it and tag it for reading */
		process_connect();
	}

	keep_dialling = 0;    /* set true by any processes that are awaiting a dialup to complete */

	/* Look to see if we can read or write any data */

	/* go back to the top of the list and work down again */
	insert = &global_processes;

	/* go down the list, doing things as required */
	while (*insert != NULL) {
		process_list proc = *insert;

		if (proc != global_processes) {
			debug(("%p> processing.  State now %d (%s)\n", proc, proc->status, process_state_name(proc->status)));
		}

		/* if the process has done nothing for 5 minutes, assume its died! */
		if ((proc->status != PROC_NULL) && ((proc->last + 5*seconds_per_minute) < time(NULL))) {
			if (proc->status == PROC_DIALLING) {
				proc->dialling = 3;		/* timeout whilst dialling can return an error page */
			}
			else {
				/* anything else is quietly 'put out of its misery' */
				kill_active_process(proc);
			}
		}

		/* is the process pending a read */
		if (proc->status == PROC_READ) {
			/* does the socket have something pending on it ? */
			if (FD_ISSET(proc->sd,&fdr)) {
				/* read the data */
				process_read(proc);
			}
		}
		/* is it pending a write? */
		else if (proc->status == PROC_WRITE) {
			/* is the socket ready to write on */
			if (FD_ISSET(proc->sd,&fdw)) {
				/* write it out */
				process_write(proc);
			}
		}
		else if (proc->status == PROC_WRITE_HEADER) {
			/* is the socket ready to write on */
			if (FD_ISSET(proc->sd,&fdw)) {
				/* write it out */
				process_write_header(proc);
			}
		}
		else if (proc->status == PROC_WRITE_FROMBUFFER) {
			/* is the socket ready to write on */
			if (FD_ISSET(proc->sd,&fdw)) {
				/* write it out */
				process_write_frombuffer(proc);
			}
		}
		else if (proc->status == PROC_WRITE_FROMCACHE) {
			/* is the socket ready to write on */
			if (FD_ISSET(proc->sd,&fdw)) {
				/* write it out */
				process_write_fromcache(proc);
			}
		}
		else if (proc->status == PROC_CHECKING) {
			process_checking(proc);
		}
		else if (proc->status == PROC_DIALLING) {
			process_dialling(proc);
		}
		else if (proc->status == PROC_CACHEDATA) {
			process_cachedata(proc);
		}

		/* cut entry from list (if marked for killing) else step to next process */
		if (proc->status == PROC_KILL) {
			*insert = proc->next;		  /* cut this record from the process list */
			free_process_record(proc);	  /* then dispose of it */
		}
		else {
			insert = &proc->next;	  /* same as insert = &((*insert)->next) */
		}
	} /*while*/


	/* whilst receiving data from a remote host, prod !MailServe every minute so that the line stays up */
	if (keep_line_active && ((last_resettimer + seconds_per_minute) < time(NULL))) {
		keep_line_active = 0;
		last_resettimer  = time(NULL);
		send_ResetTimer_command();
	}

	/* one or more processes are awaiting a dialup to complete, poll every 2 seconds to see if it has */
	if (keep_dialling && ((last_connect_command + 2) < time(NULL))) {
		keep_dialling	     = 0;
		last_connect_command = time(NULL);
		send_Connect_command();
	}

	/* when processes start running, flag that a 'get cache size' request must be issued later on */
	if (global_processes->next != NULL) {
		process_GetURLCache_delayed = 1;
	}

	/* if no processes running and the flag set */
	if ((global_processes->next==NULL) && process_GetURLCache_delayed) {
		/*process_do_delayed_GetURLCache*/
		process_GetURLCache_delayed = 0;
		(void)send_GetURLCache_request(0);   /* the reply may trigger a cache_minimise operation */
	}
	else {
		#if (BUILD == ASPARTAME)
		/* as the WebCache is held in a RAM disc, keep it minimised at all times */
		cache_economise();
		#endif
	}


	if (global_cache_writeback_delayed) {
		cache_do_delayed_writeback();	    /* write changed CacheIndex files iff delay exceeded */
	}

	update_connections_window();
	return count;
}

/*
 * This function adds the default http socket to the read set
 * and zeros all the other sets. This should be called every
 * time the default port is reconnected.
 */
static void process_set_initilise(SD default_sd)
{
	/* set up some blank FD_SETs */
	FD_ZERO(&fdr);
	FD_ZERO(&fdw);
	FD_ZERO(&fde);

	/* add in the default SD */
	FD_SET(default_sd,&fdr);
}

/*
 * This routine adds in all the processes that have something
 * networky pending...
 */
static void process_rebuild_set(void)
{
	process_list proc;

	/*
	 * Add in all ports that are pending data read or we are
	 * writing to
	 */
	for (proc = global_processes; proc != NULL; proc = proc->next) {
		/* if we are using the socket flag it up */
		if (proc->status!=PROC_NULL) {
			if (proc->sd >= 0) {
				process_add_socket(proc->sd, proc->status);
				if (max_sd < proc->sd) max_sd=proc->sd;
			}
			else {
				#if 0
				/* The socket descriptor is invalid! Flag the process for killing */
				kill_active_process(proc);
				#endif
			}
		}
	}
}

/*
 * The next two routines toggle sockets in the sets. The 1st arg
 * is the socket and the second is the process status. If it
 * is PROC_READ we use the read set else we use the write set.
 *
 * The 1st routine adds a socket to the set.
 */
static void process_add_socket(SD sd, int read)
{
	if (read == PROC_READ) {
		FD_SET(sd,&fdr);
	}
	else {
		FD_SET(sd,&fdw);
	}
}

#if 0
/* remove a socket from the set */
static void process_del_socket(SD sd, int read)
{
	if (read==PROC_READ) {
		FD_CLR(sd,&fdr);
	}
	else {
		FD_CLR(sd,&fdw);
	}
}
#endif

static void process_connect(void)
{
	SD ns;
	process_list lastproc;
	int count = 0;

	for (lastproc = global_processes; lastproc->next; lastproc=lastproc->next) ++count;

	if (count >= max_connections) {
		/* Enforce max connections */
		return;
	}

	/* accept the incomming connection */
	ns = accept(http_socket, NULL, NULL);
	if (ns != -1) {
		struct linger linger;
		process_list newproc;
		int one = 1;
		(void) socketioctl(ns, FIONBIO, &one);
		linger.l_onoff = 1;
		linger.l_linger = 120;
		(void) setsockopt(ns, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger));
		newproc = new_process_record(ns);
		if (checkloop_socket(ns)) {
			/* This was a loopback connection */
			int size;
			int size_of_word = sizeof(size);
			(void) getsockopt(ns, SOL_SOCKET, SO_SNDBUF, &size, &size_of_word);
			debug(("%p> Send buffer size is %d bytes (&%x)\n", newproc,
				size, size));
			if (size > 0x1000) {
				size_of_word = sizeof(size);
				size = 0x1000;
				(void) setsockopt(ns, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size));
				debug(("%p> setsockopt returns %d\n", newproc, getsockopt(ns, SOL_SOCKET, SO_SNDBUF, &size, &size_of_word)));
				debug(("%p> New send buffer size is %d bytes (&%x)\n", newproc,
					size, size));
			}
		}
		if (newproc != NULL) {
			lastproc->next = newproc;
			remote_host_name(ns,newproc);
			debug(("%p> New process record for connection from %s\n", newproc, newproc->hostname));
		}
	}
}

/*
 * Kill an active process.
 *
 * Close any input stream (c.f. data_from_wire).
 * Decrement cache usage counters (c.f. data_from_wire, data_from_file).
 * Set status to PROC_KILL.
 *
 */
static void kill_active_process(process_list proc)
{
	const int status = proc->status == PROC_WRITE_FROMBUFFER ? proc->next_status : proc->status;

	switch (status) {
		case PROC_WRITE	    :
		case PROC_CACHEDATA :
			process_deregister_url(proc);
			/*FALLTHROUGH*/

		case PROC_DIALLING  :
			if (proc->cacheentry) {
				cache_list cache = proc->cacheentry;
				cache->errorloading = !cache->loadcomplete;

				if (cache->errorloading) {
					cache->delete = 1;
				}
			}

			/*FALLTHROUGH*/

		case PROC_WRITE_FROMCACHE :
		case PROC_WRITE_HEADER	  :
			if (proc->cacheentry) {
				cache_list cache = proc->cacheentry;

				cache_decfileusage(cache);	      /* NB may call cache_delete_entry() */
				cache = proc->cacheentry = NULL;      /* so don't access cache entry again! */
			}
			break;
	}

	proc->status = PROC_KILL;
}


/*
 * Should only be used by processes in state PROC_DIALLING or
 * in state PROC_WRITE_FROMCACHE before ANY data has been transfered
 */
static void reroute(process_list proc, cache_list error)
{
	if (proc->cacheentry) {
		cache_decfileusage(proc->cacheentry);
		if (proc->url != NULL) {
			free(proc->url);
			proc->url = NULL;
		}
	}

	proc->status	 = PROC_WRITE_HEADER;
	proc->cacheentry = error;
	proc->response	= 400;

	if (proc->cacheentry) {
		proc->url = Strdup(proc->cacheentry->url);
		cache_incfileusage(proc->cacheentry);
	}
}

static void process_incoming_request(process_list proc)
{
	if (proc->reading_body == 0) {
		int consumed = parse_user_header(proc->request, proc->req_len, proc, &proc->reading_body);

		if (consumed > 0) {
			const int amount = proc->req_len - consumed;
			if (amount > 0) {
				memmove(proc->request, proc->request + consumed, amount);
			}
			proc->req_len -= consumed;
		}

		if (proc->reading_body == 0) {
			/* Not finished reading request yet */
			proc->status = PROC_READ;
			return;
		}
		else {
			http_header *h = http_find_header(proc->headers, "content-length");
			if (h == NULL) {
				proc->status = PROC_CHECKING;
				return;
			}
			else {
				proc->content_length = atoi(h->value);
			}
		}
	}

	if (proc->req_len >= proc->content_length) {
		if (proc->req_len > proc->content_length) {
			/* oh dear */
		}
		proc->req_len = proc->content_length;
		proc->status = PROC_CHECKING;
		debug(("%p> OK - looks like we have all the data\n", proc));

	}
	else {
		proc->status = PROC_READ;
	}
}


/* read request from browser */
static void process_read(process_list proc)
{
	int   count;

	if (proc->request == 0) {
		proc->req_len = 0;
	}

	if (socketioctl(proc->sd, FIONREAD, &count) < 0) {
		/* Didn't work - socket problem */
		debug(("%p> FATAL - socketioctl failed (%d)\n", proc, errno));
		proc->status = PROC_CHECKING;
	}
	else {
		char *buffer = realloc(proc->request, proc->req_len + count + 1);

		if (buffer == NULL) {
			debug(("%p> FATAL - realloc failed (%d)\n", proc, errno));
			proc->status = PROC_CHECKING;
		}
		else {
			proc->request = buffer;
			count = socketread(proc->sd, proc->request + proc->req_len, count);
			if (count <= 0) {
				/* Finished reading */
				proc->status = PROC_CHECKING;
			}
			else {
				proc->req_len += count;
				proc->request[proc->req_len] = '\0';
				process_incoming_request(proc);
			}
		}
	}

	/* We need to ensure that we've read the entire request.  If we have not, then we MUST
	 * reset the state to PROC_READ so that we around the polling loop again waiting for
	 * the rest of the request to arrive.
	 */
	if (proc->status == PROC_READ) return;

	process_parse_request(proc);
}

static void process_add_user_agent(process_list proc)
{
	static const char version[] = "1.1 ";
	static const char ouragent[] = " ("  ")";
	const char *ourtoken = main_get_product_token();
	http_header *user_agent_header;

	user_agent_header = http_find_header(proc->headers, "user-agent");
	if (user_agent_header != NULL) {
		char *const hostname = local_host_name();
		const size_t size = strlen(hostname) + sizeof(version) + sizeof(":12345") + sizeof(ouragent) + strlen(ourtoken);

		debug(("%p> Existing user-agent was `%s'\n", proc, user_agent_header->value));
		proc->agent = malloc(size);
		if (proc->agent) {
			strcpy(proc->agent, version);
			strncat(proc->agent, hostname, 128);
			if (server_port != 80) {
				sprintf(strchr(proc->agent, '\0'), ":%d", server_port);
			}
			strcat(proc->agent, " (");
			strcat(proc->agent, ourtoken);
			strcat(proc->agent, ")");
			debug(("%p> New via header contains: `%s'\n", proc, proc->agent));
			http_add_header(&proc->headers, "Via", proc->agent);
			free(proc->agent);
		}
		else {
			debug(("%p> malloc failed for user-agent string\n", proc));
		}
		proc->agent = Strdup(user_agent_header->value);
		http_delete_header(&proc->headers, user_agent_header);
	}
	else {
		proc->agent = Strdup(ourtoken);
	}
}

static void process_filter_request_header(process_list proc, const char *header)
{
	/* Fresco sends partial content requests.  This buggers WebServe's cacheing
	 * currently (ideally we should handle partial content)
	 */

	for (;;) {
		http_header *h = http_find_header(proc->headers, header);
		if (!h) break;
		debug(("%p> Deleting header `%s' with value `%s'\n", proc, h->header, h->value));
		http_delete_header(&proc->headers, h);
	}
}

static int process_determine_method(const char *method)
{
        static const char *const methods[] = {
                NULL, "get", "head", "options", "post", "trace", NULL, NULL,
                "put", "mkdir", "rmdir", "rename", "delete", "stou" };
	size_t i;

	for (i=0; i<(sizeof(methods)/sizeof(const char *)); ++i) {
	        if (methods[i] != NULL && Strcmp_ci(method, methods[i]) == 0) return i;
	}

	return method__UNKNOWN;
}

static void process_filter_headers(process_list proc)
{
	/* We need to remove "dangerous" headers - including hop-by-hop headers */
	for (;;) {
		http_header *connection = http_find_header(proc->headers, "connection");

		if (!connection) break;
		http_filter_connection_tokens(&proc->headers, connection);
	}
	for (;;) {
	        /* Microsoft Internet Explorer uses this bizarre header for some reason.
	         * The Connection header is perfectly suitable for this
	         */
		http_header *connection = http_find_header(proc->headers, "proxy-connection");

		if (!connection) break;
		http_filter_connection_tokens(&proc->headers, connection);
	}
	process_filter_request_header(proc, "range");
	process_filter_request_header(proc, "if-range");
	process_filter_request_header(proc, "if-match");
	process_filter_request_header(proc, "if-none-match");
	process_filter_request_header(proc, "if-unmodified-since");
	process_filter_request_header(proc, "upgrade");
	process_filter_request_header(proc, "keep-alive");
	process_filter_request_header(proc, "proxy-authenticate");
	/* End header processing */
}

static char *process_parse_request_line(process_list proc)
{
	http_header *request_line = proc->headers;
	char *urlbuf;

	if (request_line == NULL) {
		return NULL;
	}

	proc->method = process_determine_method(request_line->header);
	if (proc->method == method__UNKNOWN) {
	        return NULL;
	}

	if (proc->method != method_GET && proc->method != method_HEAD) {
		proc->dont_cache = TRUE;
	}

	urlbuf = Strdup(request_line->value);
	if (urlbuf != NULL) {
		char *end = strchr(urlbuf, '\0');

		while (end > urlbuf) {
			--end;
			if (isspace(*end) || isdigit(*end) || *end == '.') continue;
			if (*end != '/') {
				/* 0.9 request?? */
				break;
			}
			if (end > (urlbuf + 4)) {
				end -= 4;
			}
			if (Strncmp_ci("http/", end, 5) == 0) {
				while (end > urlbuf) {
					--end;
					if (!isspace(*end)) break;
				}
				if (end == urlbuf) {
					free(urlbuf);
					urlbuf = Strdup("/");
					if (urlbuf) return urlbuf;
					break;
				}
				else {
					end[1] = '\0';
					return urlbuf;
				}
			}
		}
	}

	return NULL;
}

static int process_in_infinite_loop(process_list proc)
{
	http_header *h;
	const char *server = global_serveroot->hostname;
	size_t length = strlen(server);
	char *hp;

	if (server_port == 80) {
		hp = NULL;
	}
	else {
		hp = malloc(length + sizeof(":12345"));
		if (hp == NULL) return 0;
		length = sprintf(hp, "%s:%d", server, server_port);
		server = hp;
	}

	for (h = http_find_header(proc->headers, "Via"); h; h = http_find_header(h->next, "Via")) {
		/* Found a via header */
		const char *const substr = strstr(h->value, server);

		if (substr != NULL) {
			/* Loop detected possibly - check truncation of hostname */
			char *port = strpbrk(substr, "(,;)\t ");
			if (port == NULL) {
				continue;
			}
			if (!(port - substr) == length) {
				continue;
			}
			else {
				_kernel_oserror e;
				debug(("Trapped infinite loop\n"));
				http_free_headers(&proc->headers);
				e.errnum = 0;
				Strncpy_nz(e.errmess, messages_get(mtoken_LOOP), sizeof(e.errmess));
				process_start_dynamic_error(proc, &e);
				free(hp);
				return 1;
			}

		}
	}

	free(hp);
	return 0;
}

static void process_parse_request(process_list proc)
{
	char *urlbuf;
	size_t newsize;
	http_header *h;

	debug(("Read complete request entity body, about to filter it - dumping ...\n"));
	debug_dump(proc->request, proc->req_len);

	urlbuf = process_parse_request_line(proc);
        debug(("Request is for %s\n", urlbuf));
	if (urlbuf == NULL) {
		proc->status = PROC_KILL;
		return;
	}

	process_filter_headers(proc);
	if (urlbuf[0] != '/' && process_in_infinite_loop(proc)) {
		return;
	}

        if (urlbuf[0] != '/') {
		process_add_user_agent(proc);
        }

	/* From Aspartame build - more generally required */
	if (strchr(urlbuf, '?') != NULL) {
		proc->dont_cache = TRUE;
	}


	if (urlbuf[0] == '/') {
		/* What if the request is coming in on another interface ? DNW  */
		char *hostname = global_serveroot->hostname;
		char portnum[16];


		debug(("Checking for multihomed hosts\n"));
		{
			http_header *h;

			h = http_find_header(proc->headers, "host");
			if (h != NULL) {
				/* There was a host header */
				#ifdef MULTIHOMING_IMPLEMENTED
				/* It isn't */
				hostname = h->value;
			        #else
			        debug(("Multihoming check for local URL should be here for host: %s\n", hostname));
		                #endif
			}
		}

		if (server_port == 80) *portnum = '\0'; else sprintf(portnum, ":%d", server_port);
		proc->url = malloc(strlen("http://%s%s") + strlen(hostname) + strlen(urlbuf) + 2 + strlen(portnum));
		sprintf(proc->url, "http://%s%s%s", hostname, portnum, urlbuf); /* NB URL already prefixed by '/' */
		free(urlbuf);
	}
	else {
		proc->url = urlbuf;
	}

	debug(("%p> URL is `%s'\n", proc, proc->url));


	h = http_find_header(proc->headers, "mailserv-user");
	if (h) {
		proc->username = Strdup(h->value);
		http_delete_header(&proc->headers, h);
	}
	else {
		proc->username = Strdup("Alien");
	}

	h = http_find_header(proc->headers, "pragma");
	if (h) {
		proc->reloading = TRUE;
	}

	h = http_find_header(proc->headers, "cache-control");
	if (h) {
		proc->reloading = TRUE;
		proc->dont_cache = TRUE;
	}

	h = http_find_header(proc->headers, "x-noproxy");
	if (h) {
		proc->reloading = TRUE;
		http_delete_header(&proc->headers, h);
	}

	if (http_find_header(proc->headers, "authorization")) {
		proc->dont_cache = TRUE;
	}

	newsize = http_construct_header_buffer_no_request_line(proc, proc->req_len + 1);
	if (proc->req_len > 0) {
		memcpy(proc->resphdr + newsize, proc->request, proc->req_len);
		debug(("%p> Copying %d bytes of entity body to request buffer\n", proc, proc->req_len));
	}

	debug(("%p> Req buffer headers %d bytes; entity %d; total %d\n", proc, newsize, proc->req_len, proc->req_len + newsize));

	free(proc->request);
	proc->request = proc->resphdr;
	proc->resphdr = NULL;
	proc->req_len += newsize;
	if (proc->request == 0) {
		proc->status = PROC_KILL;
		return;
	}
	proc->request[proc->req_len] = '\0';

	debug(("Read complete request and rewritten it - dumping ...\n"));
	debug_dump(proc->request, proc->req_len);

	/* send a request to !MailServe to check that */
	/* the user is allowed access to this URL     */

	if (direct_connection) {
		proc->censorship = 1;
		process_checking(proc);
	}
	else {
		/* Must set the state first because if we aren't using another app to perform
		 * the checking, then the state will be moved on automatically by the called
		 * function.  sbrodie 18/11/97
		 */
		proc->status=PROC_CHECKING;
		send_CheckURLAccess_request(proc->username, proc->url, &proc->message_ref);
		/* we are given a message reference number    */
		/* allows process_URLAccessRights to identify */
		/* this process when the reply arrives	      */
	}
}


static void process_checking(process_list proc)
{
	char *url_error = NULL;	      /* OK */

	/* has !MailServ responded to our censorship check? */
	if (proc->censorship<0) {
		return;			    /* still awaiting response */
	}

	switch (proc->censorship) {
		case 1 :    /* allowed */
			/* URL may be for: a locally served data		       */
			/*		   a remotely served but already cached data   */
			/*		   a remotely served but as yet un-cached data */
		{
			cache_list cache = NULL;
			char *hostname;
			int port;

			http_get_request(proc->url, &hostname, &port);	   /* hostname will need to be freed */
			if (port == server_port) {
				cache = serve_search(hostname, proc->url, &proc->censorship);
			}
			if (cache) {
				proc->status=PROC_WRITE_HEADER;		  /* locally served */
				/* process_write_header changes status to PROC_WRITE_FROMCACHE; */
			}
			else {
				/* remotely served (but may be cached) */
				if (proc->dont_cache) {
					/* pages with AUTHORIZATION (sic) strings must not */
					/* be cached, nor shared with other processes	   */

					/* responses to POST must not be cached, nor	   */
					/* shared with other processes			   */

					/*cache	       = NULL*/
					proc->status = PROC_DIALLING;

					/* Force out other versions even if not cacheing */
					if (proc->reloading) {
					        cache = cache_search(hostname, proc->url, port);
					        if (cache) {
					                cache->expired = 1;
					                cache_delete_entry(cache);
					                cache = NULL;
					        }
					}
				}
				else {
					cache = cache_search(hostname, proc->url, port);
					if (cache && proc->reloading) {
						/* We wanted a reload */
						cache->expired = 1;
						cache_delete_entry(cache);
						cache = NULL;
					}
					if (cache) {
						/* data already in cache (or being read into it by another process) */
						if (cache->expired || cache->delete) {
							/* done now if usage_count is zero, else marked for later deletion */
							cache_delete_entry(cache);
							cache = NULL;
						}
						else {
							proc->status=PROC_WRITE_FROMCACHE;
						}
					}

					if (cache == NULL) {
						/* don't worry if this fails, we simply don't cache the data */
						cache = cache_new_entry(hostname, proc->url, port);
						proc->status = PROC_DIALLING;
					}
				}
			}

			free(hostname);			  /* no longer needed */

			if (cache) {
				cache_incfileusage(cache);
			}

			proc->cacheentry = cache;			  /* NULL if page is uncacheable or cache_new_entry failed */

			/* url_error is still NULL */
		}
		break;

		case 0 :    /* disallowed */
			url_error = "censor";
			break;

		case 2 :    /* !MailServer AWOL */
			url_error = "noserver";
			break;
	}

	if (url_error) {
		reroute(proc, error_search(url_error));
	}
	else {
		if (proc->status == PROC_DIALLING) {
			process_dialling(proc);
		}
	}
}


typedef enum {
	flags_USER_AGENT_IN_R6 = 1,
	flags_DATA_LENGTH_IN_R5 = 2,
	flags_NO_COOKIES = (1<<30),
	flags_PROXY = (signed) 0x80000000
} start_swi_r0_flags;


static char *process_start_url_request(process_list proc)
{
	_kernel_oserror  *error;
	char *url_error = NULL;

	/* register with the URL module */
	error = _swix(SWI_URL_Register, _INR(0,1)|_OUT(1), 0, 0, &proc->url_id);
	if (error != NULL) {
		proc->url_id = 0;
		return "fetchfail";
	}

	/* advance state so that kill_active_process knows to deregeister with URL module */
	proc->status = PROC_WRITE;

	/* ensure our request doesn't get routed back to us! */
	if ((proxy_server != NULL) && (*proxy_server != '\0')) {
		/* R3 was being set to "http:" but overridden with a #if 1 and I don't know why */
		error = _swix(SWI_URL_SetProxy, _INR(0,4), 0, proc->url_id, proxy_server, proc->url, 0);
	}
	else {
		/* R3 was being set to "http:" but overridden witb a #if 1 and I don't know why */

		/* switch off proxying for us! */
		error = _swix(SWI_URL_SetProxy, _INR(0,4), 0, proc->url_id, "", proc->url, 1);
	}

	if (error != NULL) {
		url_error = "proxyfail";
	}
	else {
		/* Ask the URL module to get our data */
		int status;
		/* Instruct AcornHTTP that no cookies must be added.  (Client will have already added them) */
		const int flags = flags_DATA_LENGTH_IN_R5 | flags_NO_COOKIES | (proc->agent ? flags_USER_AGENT_IN_R6 : 0);
		/* Ask for all data by setting bits 15-8 to 2 and indicating this via R0:1 */
		const int method_bits = proc->method | (2<<8);

		error = _swix(SWI_URL_GetURL, _INR(0,6)|_OUT(0), flags, proc->url_id, method_bits, proc->url,
			proc->request, proc->req_len, proc->agent, &status);

		#if USE_DIALLER
		if ((error != NULL) || (status & 64) != 0) {
			if ((retry_after_dialling > 0) && (status & 64) != 0) {
				url_error = (char*)1;	/* WARNING 'magic' value */
				retry_after_dialling -=1;
			}
			else {
				url_error = "badhost";
			}
		}
		else {
			retry_after_dialling = 0;	/* We've successfully connected, so no further retrys */
		}
		#else
		if (error != NULL) {
			process_start_dynamic_error(proc, error);
			return NULL;
		}
		#endif /*USE_DIALLER*/
	}

	if (url_error) {
		process_deregister_url(proc);
	}
	else {
		/* Must be here as error from above must not prevent timeout */
		proc->last = time(NULL);
	}

	return url_error;
}

static void process_dialling(process_list proc)
{
	char *url_error = NULL;	      /* ok */
	#if USE_DIALLER
	static int	retry_after_dialling;	/*bodge flag for retrying a request after a dial up */
	#endif

	#if 0
	/* has !MailServ responded to our censorship check? */
	if (proc->censorship<0) {
		return;			    /* still awaiting response */
	}
	#endif

	switch (proc->dialling) {
		case 0:	    /* not started */
			if (direct_connection) {
				proc->dialling = 2;
				process_dialling(proc);
				return;
			}
			(void) send_Connect_command();	   /* ask !MailServe to dial our service provider */
			#if USE_DIALLER
			if (proc->dialling == 0) {
				retry_after_dialling = RETRIES_AFTER_DIALLING; /* dialup hasn't completed yet, so set retry count */
			}
			#endif
			break;

		case 1:	    /* dialling - awaiting response */
			keep_dialling = 1;
			break;

		case 2:	    /* dialling successful */
			url_error = process_start_url_request(proc);
			break;

		case 3:	    /* failed timed out in state 1 */
			url_error = "dialtime";
			break;

		case 4:	    /* failed - disallowed by !MailServer */
			url_error = "dialoff";
			break;

		case 5:	    /* failed - !MailServer AWOL */
			url_error = "noserver";
			break;

		case 6:
			url_error = "dialfail";
			break;
	}

	#if USE_DIALLER
	/* Pragmatic fix for URL modules bad handling of PPP module not being ready.					*/
	/* If SWI_URL_GetURL returned an error, and we've only just connected, indicated by a 'magic' error address,	*/
	/* wind our state back to dialling so that we try again later.						*/
	if (url_error == (char*)1) {
		proc->status = PROC_DIALLING;
		proc->dialling = 1;		/* Mark as not yet finished dialling */
		return;
	}
	#endif

	if (url_error) {
		cache_list error = error_search(url_error);

		/* We are the process trying to fetch the remotely served data */
		/* but there may by other processes waiting to pull the data from the cache */

		/* To report the error, de-couple the process from the	       */
		/* cache entry, then couple it to a locally served ERROR page. */
		if (proc->cacheentry) {
			process_list scan;
			proc->cacheentry->delete = 1;

			/*>>>we need to look for other processes in PROC_WRITE_FROMCACHE state using this cacheentry*/
			for (scan = global_processes; scan != NULL; scan = scan->next) {

				if ((scan->status == PROC_WRITE_FROMCACHE) && (scan->cacheentry == proc->cacheentry)) {
					reroute(scan, error);
				}
			}
		}

		reroute(proc, error);
	}
}

static void process_start_dynamic_error(process_list proc, _kernel_oserror *e)
{
	http_header *tmp = proc->headers;
	cache_list error1 = error_search("readerror1");
	cache_list error2 = error_search("readerror2");
	filemanage_FILE *f;
	const size_t errlen = strlen(e->errmess);
	int done = 1;


	if (error1 == NULL || error2 == NULL) {
		reroute(proc, error_search("readerror"));
		return;
	}

	cache_incfileusage(error1);
	cache_incfileusage(error2);

	proc->headers = NULL;
	http_add_header(&proc->headers, "HTTP/1.0", "400 Local error");
	http_add_header(&proc->headers, "Content-type", "text/html");
	http_add_header(&proc->headers, "X-WebServe-LocalError", e->errmess);
	proc->bufsiz = http_construct_header_buffer(proc, error1->filesize + error2->filesize + errlen + 1);
	proc->buffer = proc->resphdr;
	proc->resphdr = NULL;
	proc->headers = tmp;

	debug_dump(proc->buffer, proc->bufsiz);

	f = cache_openfile(error1, "r");
	if (f != NULL) {
		proc->bufsiz += filemanage_read(proc->buffer + proc->bufsiz, 1, error1->filesize, f);
		filemanage_close(f);
		strcpy(proc->buffer + proc->bufsiz, e->errmess);
		proc->bufsiz += errlen;
		f = cache_openfile(error2, "r");
		if (f != NULL) {
			proc->bufsiz += filemanage_read(proc->buffer + proc->bufsiz, 1, error2->filesize, f);
			filemanage_close(f);
			done = 1;
		}
	}

	cache_decfileusage(error1);
	cache_decfileusage(error2);

	if (!done) {
		free(proc->buffer);
		proc->buffer = NULL;
		reroute(proc, error_search("readerror"));
	}
	else {
		cache_list cache = proc->cacheentry;
		proc->status = PROC_WRITE_FROMBUFFER;
		proc->next_status = PROC_KILL;
		if (cache) {
			cache->errorloading = !cache->loadcomplete;
			cache_delete_entry(cache);
			cache_decfileusage(cache);
			if (proc->url != NULL) {
				free(proc->url);
				proc->url = NULL;
			}
			proc->cacheentry = NULL;
		}
	}
}

static void process_write(process_list proc)
{
	char buffer[BUFSIZ+1];
	int  received = 1, sent = 1;
	int  xfercomplete = 0;
	int  xferaborted = 0;
	int  errorsending = 0;
	_kernel_oserror *e;

	#if 0
	/* Look at proc->sd and see how much we *could* send as a maximum, and limit the local buffer to
	 * that size, so that we don't accidentally cause an overrun and fail to complete data transmission
	 */
	#endif

	e = NULL;
	#ifdef SPEEDY_BUFFERS
	while (!errorsending && !xfercomplete && !xferaborted && received == sent && received != 0) {
		if (proc->buffer != NULL) {
			/* We have data pending in a buffer - write that first */
			received = proc->bufsiz;
			sent = data_to_user(proc, proc->buffer, proc->bufsiz, 0, 0, FALSE, &errorsending);
			if (errorsending == 0) {
				if (sent == proc->bufsiz) {
					free(proc->buffer);
					proc->buffer = NULL;
					xfercomplete = proc->buf_completed;
					sent = received = 1;
					continue;
				}
				/* Sent some of it */
				memmove(proc->buffer, proc->buffer + sent, proc->bufsiz - sent);
				proc->bufsiz -= sent;
			}
			break;
		}

		e = data_from_wire(proc, buffer, sizeof(buffer)-1, &received, &xfercomplete, &xferaborted);
		if (e != NULL) break;
		sent = data_to_user(proc, buffer, received,  xfercomplete,  xferaborted, FALSE, &errorsending);

		if (errorsending == 0 && xferaborted == 0 && sent != received) {
			size_t remaining = received - sent;

			debug(("Unable to send all data: wanted to send %d; sent %d; remaining %d\n", received, sent, remaining));

			proc->buffer = malloc(remaining);
			if (proc->buffer == NULL) {
				errorsending = 1;
			}
			else {
				memcpy(proc->buffer, buffer + sent, remaining);
				proc->bufsiz = remaining;
				proc->buf_completed = xfercomplete;
				xfercomplete = 0;
			}
			break;
		}
	}
	#else
	e = data_from_wire(proc, buffer, sizeof(buffer)-1, &received, &xfercomplete, &xferaborted);
	if (e == NULL) {
		sent = data_to_user(proc, buffer, received,  xfercomplete,  xferaborted, TRUE, &errorsending);
		debug(("%p> sent=%d; errorsending=%d; Done=%d; Abort=%d\n", proc, sent, errorsending, xfercomplete, xferaborted));
	}
	else {
		debug(("%p> error %s\n", proc, e->errmess));
	}
	#endif

	/* we don't care if data_to_user() errors and stops sending data   */
	/* as data_from_wire can usefully continue filling its cache entry */

	if (errorsending) {
		debug(("%p> Entering CACHEDATA state\n", proc));
		proc->status = PROC_CACHEDATA;
	}

	if (xfercomplete) {
		proc->status = PROC_KILL;
		if (e != NULL) {
			/* Termination was due to an error from URL_ReadData SWI call */
			if (proc->bytes == 0) {
				/* We haven't written any data, so in this case reroute the data  */
				process_start_dynamic_error(proc, e);
			}
		}
	}
}


/* 4K it too much for some images  */
/* 2K is better but fails sometime */
/* 1K seems fine		   */
/* sbrodie: what a load of ...	   */
/* that's what BUFSIZ is for!      */
#define CACHE_READ_SIZE BUFSIZ

/*
 * Locally sourced data and error messages files are
 * stored without an HTML header. This is for the
 * convienience of the user creating the data!.
 * We must generate and send a suitable header
 * before sending the file.
 *
 * Cached files are stored complete with received
 * headers and so don't use this routine
 */

static void process_write_header(process_list proc)
{
	int  errorsending;
	int  new_status;
	#if 0
	/* has !MailServ responded to our censorship check? */
	if (proc->censorship<0) {
		return;			    /* still awaiting response */
	}
	#endif

	header_to_user(proc, &errorsending);

	if (errorsending) {
		new_status = PROC_KILL;
	}
	else {
		new_status = PROC_WRITE_FROMCACHE;
	}

	if (proc->status != PROC_WRITE_FROMBUFFER) {
		proc->status = new_status;
	}
	else {
		proc->next_status = new_status;
	}
}

static void process_write_frombuffer(process_list proc)
{
	if (proc->buffer == NULL) {
		proc->status = proc->next_status;
		return;
	}
	else {
		int received, sent;
		int xfercomplete = 0;
		int errorsending = 0;

		/* We have data pending in a buffer - write that data out */
		received = proc->bufsiz;
		sent = data_to_user(proc, proc->buffer, proc->bufsiz, 0, 0, FALSE, &errorsending);
		if (proc->next_status == PROC_WRITE_FROMCACHE) {
			proc->bytes -= sent;
		}
		if (errorsending == 0) {
			if (sent == proc->bufsiz) {
				free(proc->buffer);
				proc->buffer = NULL;
				xfercomplete = proc->buf_completed;
				proc->status = proc->next_status;
				return;
			}

			/* Sent some of it */
			memmove(proc->buffer, proc->buffer + sent, proc->bufsiz - sent);
			proc->bufsiz -= sent;
		}
		else {
			free(proc->buffer);
			proc->buffer = NULL;
			proc->status = proc->next_status;
		}
	}
}

static void process_write_fromcache(process_list proc)
{
	char buffer[CACHE_READ_SIZE + 1];
	int  received;
	int  xfercomplete;
	int  xferaborted;
	int  errorsending;
	int  sent;

	#if 0
	/* has !MailServ responded to our censorship check? */
	if (proc->censorship<0) {
		return;			    /* still awaiting response */
	}
	#endif

	#ifdef SPEEDY_BUFFERS
	do {
		data_from_file(proc, buffer, sizeof(buffer)-1, &received, &xfercomplete, &xferaborted);
		sent = data_to_user(proc, buffer, received, xfercomplete, xferaborted, FALSE, &errorsending);
	} while (sent == received && !xfercomplete && !xferaborted && !errorsending && sent != 0) ;;
	#else
	debug(("%p> Reading from cache file\n", proc));
	data_from_file(proc, buffer, sizeof(buffer)-1, &received, &xfercomplete, &xferaborted);
	debug(("%p> Data read from cache file: %d bytes (Done=%d;Abort=%d)\n", proc, received, xfercomplete, xferaborted));
	sent = data_to_user(proc, buffer, received, xfercomplete, xferaborted, TRUE, &errorsending);
	#endif

	if (xfercomplete && !errorsending) {
		if (sent < received) {
			/* Didn't manage to send all the data yet */
			const int remaining = received - sent;
			proc->buffer = realloc(proc->buffer, remaining);
			if (proc->buffer != NULL) {
				memcpy(proc->buffer, buffer + sent, remaining);
				proc->bufsiz = remaining;
				proc->next_status = PROC_KILL;
				proc->status = PROC_WRITE_FROMBUFFER;
				return;
			}
		}
	}

	/* if data_to_user() errors and stops sending data there is */
	/* no point reading the rest of the file, so give up now    */

	if (xfercomplete || errorsending) {
		debug(("%p> xfercomplete=%d; errorsending=%d; entering PROC_KILL\n", proc, xfercomplete, errorsending));
		proc->status = PROC_KILL;
	}
}


/* Copy URLdata 'from the wire' into the cache without sending it to the user.

 *
 * This is used if the requested URL is disallowed (censored) to the user who
 * requested it, but we may as well cache it as the data is 'on the way'.
 *
 */
static void process_cachedata(process_list proc)
{
	char buffer[BUFSIZ+1];
	int  received;
	int  xfercomplete;
	int  xferaborted;

	/* This optimisation added to suck data off the network as fast as it comes.  This should speed
	 * reception of network data up and free mbufs quickly too.
	 */
	#ifdef SPEEDY_BUFFERS
	do {
		(void) data_from_wire(proc, buffer, sizeof(buffer)-1, &received, &xfercomplete, &xferaborted);
	} while (received > 0 && !xfercomplete && !xferaborted);
	#else
	(void) data_from_wire(proc, buffer, sizeof(buffer)-1, &received, &xfercomplete, &xferaborted);
	#endif

	if (proc->cacheentry) {
		if (proc->cacheentry->errorloading) {
			xferaborted = 1;
		}
	}

	if (xfercomplete || xferaborted) {
		proc->status = PROC_KILL;
	}
}


static _kernel_oserror *data_from_wire(process_list proc, char *buffer, int buffersize,
			   int *p_received, int *p_xfercomplete, int *p_xferaborted)
{
	_kernel_oserror *e;

	int received;
	int xfercomplete;
	int xferaborted;
	int flags;

	debug(("%p> data_from_wire: buffer %p maxdata %d\n", proc, buffer, buffersize));

	e = _swix(SWI_URL_ReadData, _INR(0,3)|_OUT(0)|_OUT(4), 0, proc->url_id, buffer, buffersize,
		&flags, &received);

	debug(("%p> data_from_wire: ReadData returns %d bytes, flags=%d %s\n", proc, received, flags, e?e->errmess:""));

	if (e != NULL) {
		*p_xferaborted = 1;
		*p_xfercomplete = 1;
		*p_received = 0;
		process_deregister_url(proc);
		return e;
	}

	xfercomplete   = !!(flags & 32);
	xferaborted    = !!(flags & 64);

	/*
	 * We usually cache the received data, so append it to the
	 * appropriate cache file now.
	 * The data is only ever not cached if we are unable to purge
	 * the data in a full cache of if there is no cache at all.
	 */
	if (proc->cacheentry) {
		cache_list cache=proc->cacheentry;

		#ifdef SPEEDY_BUFFERS
		if ((xfercomplete || xferaborted) && received == 0 && cache->f && !filemanage_tell(cache->f)) {
			cache->loadcomplete = 1;
			xferaborted = 1;
		}
		#endif

		if ((received > 0) && (!cache->errorloading)) {
			filemanage_FILE *fp = cache->f;

			if (cache->f == NULL) {
				fp = cache->f = cache_openfile(cache, "a+");
			}
			if (fp != NULL) {
				int written;

				if (cache->filesize != filemanage_tell(fp)) {
					filemanage_seek(fp, 0, SEEK_END);
				}

				written = filemanage_write(buffer, sizeof(char), received, fp);
				/*filemanage_close_p(&cache->f);*/
				cache_incfilesize(cache, written);
				if (written != received) {
					debug(("%p> ERROR during loading (written=%d; received=%d)\n", proc, written, received));
					cache->errorloading = 1;
				}
				proc->last = time(NULL);
			}
			else {
				cache->errorloading = 1;
			}
		}

		if (xfercomplete) {
			cache->errorloading |= xferaborted;
			cache->loadcomplete  = !cache->errorloading;	   /* data complete and OK if xfercomplete and NOT error loading */

			if (cache->errorloading) {
				cache->delete = 1;
			}
			else {
				cache_entry_complete(cache);	/* try to extract expiry time (or guess one) */
			}

			filemanage_close_p(&cache->f);
			cache->time_accessed = time(NULL);
			cache_decfileusage(cache);	  /* NB may call cache_delete_entry() */
			cache = proc->cacheentry = NULL;  /* so don't access cache entry again! */
		}
	}

	/* Each time some data arrives, indicate that we want the modem (if any) to  */
	/* stay connected. The 'keep_line_active' flag is checked and reset once     */
	/* every minute or so and a 'reset timeout' message sent to !MailServ.	     */
	if (received > 0) {
		keep_line_active = 1;
		#if (BUILD == ASPARTAME)
		/* Each time some data arrives, prod the 'data transfer LED'. This */
		/* has a mono-stable action - if data blocks arrive close together */
		/* the LED stays on, else it flashes each time one arrives.	   */
		(void) _swix(SWI_SurfBoard_SetLED, _INR(0,1), 0x14/*Flash LED code*/, 40/*centiseconds*/);
		#endif
	}

	if (xfercomplete) {
		process_deregister_url(proc);
	}

	*p_received	= received;
	*p_xfercomplete = xfercomplete;
	*p_xferaborted  = xferaborted;

	return NULL;
}


static void data_from_file(process_list proc, char *buffer, int buffersize,
			   int *p_received, int *p_xfercomplete, int *p_xferaborted)
{
	*p_received	= 0;
	*p_xfercomplete = 1;
	*p_xferaborted  = 0;

	/* We copy data out of the cache in lumps of CACHE_READ_SIZE bytes */

	if (proc->cacheentry) {
		cache_list cache = proc->cacheentry;
		int	   tryreading  = cache->filesize - proc->bytes;
		int	   xfercomplete;

		if (tryreading > buffersize) tryreading = buffersize;

		if (tryreading > 0) {
			filemanage_FILE *fp = proc->cacheentry->f;
			/* Open file for reading, seek past the data already sent */
			if (fp == NULL) {
				fp = proc->cacheentry->f = cache_openfile(cache, "a+");
			}
			if (fp != NULL) {
				if (proc->bytes != filemanage_tell(fp)) {
					filemanage_seek(fp, proc->bytes, SEEK_SET);
				}
				debug(("%p> data_from_file: buffer %p maxsize %d\n", proc, buffer, tryreading));
				*p_received = filemanage_read(buffer, sizeof(char), tryreading, fp);
			}
		}

		/*
		 * Transfer of data from the cache is complete if the number of bytes sent
		 * equals the cache file size AND the file is no longer being filled
		 */
		xfercomplete = ((cache->filesize == (proc->bytes + *p_received)) && (cache->loadcomplete || cache->errorloading));

		if (xfercomplete) {
			filemanage_close_p(&proc->cacheentry->f);
			*p_xferaborted = cache->errorloading;
			cache->time_accessed = time(NULL);
			cache_decfileusage(cache);	  /* NB may call cache_delete_entry() */
			proc->cacheentry = NULL; /* Added for 1.30 */
		}

		*p_xfercomplete = xfercomplete;
	}
}


static int data_to_user(process_list proc, char *buffer, int received, int xfercomplete, int xferaborted, int mustgo, int *p_errorsending)
{
	int error = (proc->sd == -1); /* error if socket closed on entry, */
	int sent = 0;

	(void) xferaborted;

	debug(("%p> data_to_user: %d bytes, aborted=%d mustgo=%d\n", proc, received, xferaborted, mustgo));

	if (!error) {
		if (received > 0) {

			/*
			 * Assume for now that we can write as much as we were sent.
			 * This is _highly_ likely since we are dealing in units
			 * of under 4Kb
			 */
			debug(("%p> WebServe> Sending %d bytes data to client\n", proc, received));

			sent = socketwrite(proc->sd, buffer, received);
			if (sent==-1) {
				debug(("%p> socketwrite fails: errno=%d\n", proc, errno));
				switch(errno) {
					case 0:
					case EWOULDBLOCK:
					case ENOBUFS:
						break;
					default:
						error = 1;
						break;
				}

				sent = 0;
			}
			if (sent > 0) {
				proc->bytes += sent;
			}

			if (sent != received) {
				debug(("%p> sent=%d, received=%d, mustgo=%d\n", proc, sent, received, mustgo));
				if (mustgo) {
					error = 1;
				}
				else {
					if (xfercomplete) {
						xfercomplete = 0;
					}
				}
			}

			proc->last = time(NULL);
		}

		if (xfercomplete || error) {
			socketclose(proc->sd); proc->sd = -1;
		}

		debug(("%p> received %d and sent %d bytes (total: %d)\n", proc, received, sent, proc->bytes));
	}

	*p_errorsending = error;      /* error if socket closed on entry, or if socketwrite() failed */
	return sent;
}


static void header_to_user(process_list proc, int *p_errorsending)
{
	int error = (proc->sd == -1); /* error if socket closed on entry, */

	if (!error) {
		char buf[128];
		http_header *tmp;
		time_t timenow = time(NULL);

		proc->rheaders = NULL;
		http_add_header(&proc->rheaders, "HTTP/1.0", "200 OK");
		http_add_header(&proc->rheaders, "Server", main_get_product_token());

		strftime(buf, 120, "%a, %d %b %Y %H:%M:%S GMT", localtime(&timenow));	   /* "Thu, 29 Feb 1996 14:01:31 GMT" */
		http_add_header(&proc->rheaders, "Date", buf);
		sprintf(buf, "%d", proc->cacheentry->filesize);
		http_add_header(&proc->rheaders, "Content-length", buf);
		convert_date_and_time(buf, 120, proc->cacheentry->LoadAddress, proc->cacheentry->ExecAddress);
		http_add_header(&proc->rheaders, "Last-modified", buf);

		if (_swix(MimeMap_Translate,_INR(0,3),0, proc->cacheentry->filetype, 2, buf) != NULL) {
			http_add_header(&proc->rheaders, "Content-type", "text/html");
		}
		else {
			http_add_header(&proc->rheaders, "Content-type", buf);
		}

		tmp = proc->headers;
		proc->headers = proc->rheaders;
		proc->bufsiz = http_construct_header_buffer(proc, 0);
		proc->rheaders = proc->headers;
		proc->headers = tmp;
		proc->buffer = proc->resphdr;
		proc->resphdr = NULL;
		proc->status = PROC_WRITE_FROMBUFFER;
		proc->next_status = proc->status;

		debug_dump(proc->buffer, proc->bufsiz);
	}

	*p_errorsending = error;      /* error if socket closed on entry, or if socketwrite() failed */
}


/*
 * access is 0/1/2 for denied/allowed/!MailServer AWOL
 */
void process_URLAccessRights(int message_ref, int access)
{
	process_list proc;
	for (proc = global_processes; proc != NULL; proc = proc->next) {
		if ((proc->censorship < 0) && (proc->message_ref == message_ref)) {
			proc->censorship = access;
			#if 0
			if ((access == 0) || (access == 2)) {
				/* access denied */
				char url_error[256];

				if (access == 0) {
					strcpy(url_error, "censor");
				}
				else {
					strcpy(url_error, "noserver");
				}

				switch (proc->status) {
					case PROC_WRITE_HEADER:
					case PROC_WRITE_FROMCACHE:
					/* The user requested cached or locally served data.		  */
					/* To censor the attempted access, de-couple the process from the */
					/* cached data, then couple it to a locally served ERROR page.	  */
						if (proc->cacheentry) {
							cache_decfileusage(proc->cacheentry);
						}

						proc->status	 = PROC_WRITE_HEADER;
						proc->cacheentry = error_search(url_error);

						if (proc->cacheentry) {
							free(proc->url);
							proc->url=Strdup(proc->cacheentry->url);
							cache_incfileusage(proc->cacheentry);
						}
						break;

					case PROC_DIALLING:
					case PROC_WRITE:    /*>>>redundent as now caught whilst in PROC_DIALLING state?*/
					{
					/* The user requested non-local uncached data. This data is already on the way, */
					/* so may as well be placed in the cache. The user who requested the data is not */
					/* authorised to see it and is fed a page containing the censored message. */

					/* Create a new process to talk to the user. Transfer all user/socket */
					/* related variables to the new process, then couple it to a locally served CENSORED page. */
					/* The old process retains all remote host variables and retrieves the data into the cache */

						process_list newproc;

						newproc = new_process_record(proc->sd);
						if (newproc != NULL) {
							proc->sd = -1;	      /* socket given to newproc, so MUST blat proc's copy */

							newproc->hostname   = proc->hostname;	    proc->hostname = NULL;
							newproc->status	    = PROC_WRITE_HEADER;

							newproc->username   = proc->username;	    proc->username=NULL;
							newproc->censorship = proc->censorship;
							newproc->cacheentry = error_search(url_error);
							if (newproc->cacheentry) {
								newproc->url	  = Strdup(newproc->cacheentry->url);
								cache_incfileusage(newproc->cacheentry);
							}

							/* add newproc to the end of the processes list */
							{
								process_list lastproc=global_processes;
								while (lastproc->next != NULL) {
									lastproc=lastproc->next;
								}

								lastproc->next=newproc;
							}
						}
						else {
							socketclose(proc->sd);
							proc->sd = -1;
						}

						proc->status = PROC_CACHEDATA;
					}
					break;
				} /*switch*/
			}
			#endif
			break; /*for*/
		}
	}
}


/*
 * state is 1/2/4/5/6 dialling/successfull/disallowed/!MailServer AWOL/dial failed
 */
void process_DiallingState(int state)
{
	process_list proc;

	for (proc = global_processes; proc != NULL; proc = proc->next) {
		if (proc->status == PROC_DIALLING) {
			proc->dialling = state;
		}
	}
}


/*
 * Create the top process...
 */
void process_main(void)
{
	if (global_processes != NULL) return;

	global_processes = new_process_record(http_socket);
	global_processes->status=PROC_NULL; /* cos it isnt really! */
}



/*
 * Create a new process structure
 */
static process_list new_process_record(SD sock)
{
	process_list proc = proc_malloc();

	if (proc == NULL) return proc;

	proc->sd=sock;
	proc->hostname=NULL;
	/*proc->fd=NULL;*/
	proc->request=NULL;
	proc->content_length=0;
	proc->reading_body=0;
	proc->headers = NULL;
	proc->rheaders = NULL;
	proc->resphdr = NULL;
	proc->agent = NULL;
	/*proc->body=NULL;*/
	proc->response=0;
	proc->status=PROC_READ;
	proc->buffer=NULL;
	proc->bufsiz=0;
	proc->bytes=0;
	proc->size=0;
	proc->start=proc->last=time(NULL);
	proc->session_id=id++;
	proc->url_id=0;
	proc->url=NULL;
	proc->extra_blk=NULL;
	proc->extra_len=0;
	proc->username=NULL;
	/*proc->authorise=NULL;*/
	proc->censorship=-1;
	proc->message_ref=0;
	proc->dialling=0;	     /* not started */
	proc->dont_cache=0;	    /* assume cacheable */
	proc->cache_confirm=0;
	proc->cacheentry = NULL;
	proc->next=NULL;

	return proc;
}


/*
 * Get rid of a dead process and (hopefully) free some memory!
 */
static void free_process_record(process_list proc)
{
	if (proc==NULL) return;

	/* free memory and resources associated with the process */
	if ((proc->hostname != NULL) && (proc->hostname != nohost)) {
		free(proc->hostname);
	}

	if (proc->sd != -1) socketclose(proc->sd);

	if (proc->cacheentry && proc->cacheentry->f) {
		filemanage_FILE *f = proc->cacheentry->f;
		filemanage_close_p(&f);
		proc->cacheentry->f = f;
	}

	free(proc->request);
	http_free_headers(&proc->headers);
	http_free_headers(&proc->rheaders);
	free(proc->agent);
	free(proc->resphdr);
	free(proc->buffer);
	free(proc->url);
	free(proc->extra_blk);
	free(proc->username);
	/*free(proc->authorise);*/

	free(proc);
}


/*
 * Flush active process queue
 * used by pre-Quit message handler
 * Principly intended for Aspartame build, but I suspect
 * it could be more generally useful, so not conditional
 * C.Elkins 970407
 */

void process_flush_queue(void)
{
	process_list *insert;	      /* list of all connections */

	/* go to the top of the list and work down */
	insert = &global_processes;

	/* go down the list, doing things as required */
	while (*insert != NULL) {
		process_list proc = *insert;

		if (proc->status != PROC_NULL) {
			kill_active_process(proc);	/* all active processes are quietly 'killed' */
		}
		insert = &proc->next;
	}
}

void process_app_control(int force)
{
	process_list *insert;	      /* list of all connections */

	/* go to the top of the list and work down */
	insert = &global_processes;

	debug(("process app control (force = %s)\n", force ?  "yes" : "no"));
	(void) force;

	/* go down the list, doing things as required */
	while (*insert != NULL) {
		process_list proc = *insert;

		if (proc->status == PROC_CACHEDATA) {
			/* This is a potential victim */
			if (proc->cacheentry) {
				if (proc->cacheentry->usage_count == 1) {
					kill_active_process(proc);	/* all active processes are quietly 'killed' */
				}
			}
		}
		insert = &proc->next;
	}

}

static void process_deregister_url(process_list proc)
{
	if (proc->url_id != 0) {
		_kernel_oserror *e;

		e = _swix(SWI_URL_Deregister, _INR(0,1), 0, proc->url_id);
		if (e != NULL) {
		        #ifdef NULL_ID_FAILURE
			FILE *f = fopen("ADFS::4.$.WS_FAILURE", "a");
			if (f) {
				fprintf(f, "WebServe has failed on a URL_Deregister: %s\n", e->errmess);
				fclose(f);
			}
			#endif
			debug(("%p> Deregister failure (%x) - %s\n", proc, proc->url_id, e->errmess));
		}
		else {
			debug(("%p> Deregister success (%x)\n", proc, proc->url_id));
		}
		proc->url_id = 0;
	}
	else {
	        	#ifdef NULL_ID_FAILURE
			FILE *f = fopen("ADFS::4.$.WS_FAILURE", "a");
			if (f) {
				fprintf(f, "WebServe has failed on a URL_Deregister: ZERO deregistered!\n");
				fclose(f);
			}
			#endif
		debug(("%p> Deregister failure (ZERO)\n"));
	}
}

/* end of process.c */

