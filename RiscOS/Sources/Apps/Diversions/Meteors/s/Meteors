; > Sources.Meteors

;;---------------------------------------------------------------------------
;; *********************
;; ***  CHANGE LIST  ***
;; *********************
;;
;; 30-Dec-87            File created
;; 25-May-89    0.01    Modified to fit in with new Wimp facilities
;;  7-Jun-89    0.02    GOAL-style queues implemented
;;  8-Jun-89    0.03    Ship movement and keyboard handling (3 hours)
;;  8-Jun-89    0.04    Implement colouring of shapes
;;  9-Jun-89    0.05    Implement collision detection (3.5 hours)
;; 21-Jul-89    0.06    Implement rock splitting (2.5 hours)
;; 21-Jul-89    0.07    Implement bullets (2 hours)
;; 29-Jul-89    0.08    Implement score display (2 hours)
;; 17-Jan-90    0.09    Implement new sheet code (1 hour)
;; 10-Mar-90    0.10    Implement proper exploding ship (3.5 hours)
;; 11-Mar-90    0.11    Improve algorithm for safe re-entrance of ship (3.5 hours)
;; 12-Mar-90    0.12    Implement hyperspace (0.5 hours)
;; 13-Mar-90    0.13    Implement toggling to full screen / no wimp poll (2 hours)
;; 13-Mar-90    0.14    Implement display of number of lives left (2 hours)
;; 14-Mar-90    0.15    Implement "Game over" display inside window
;; 01-Dec-93    0.16    Bring module version number up to date (5 mins)
;;                      Sort out colour calculations for 16 and 32 bpp (1/2 Hr)
;; 17-Jan-94    0.17    Add !Help acknowledging Neil Raine's authorship
;; 28-Jan-94    0.18    Add a WimpSlot -min to the !Run file.
;;
;;---------------------------------------------------------------------------

Module_BaseAddr

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:Wimp
        GET     Hdr:Messages
        GET     Hdr:VduExt
        GET     Hdr:ColourTran
        GET     Hdr:Sprite
        GET     Hdr:Font
        GET     Hdr:PublicWS
        GET     Hdr:NDRDebug
;       GET     Hdr:Time+Date
        GET     s.Constants
        GET     s.Macros

        GBLL    debug
        GBLL    debugxx
        GBLL    debugcc
        GBLL    debugln

debug   SETL    {FALSE}
debugxx SETL    {TRUE}  :LAND: debug
debugcc SETL    {FALSE} :LAND: debug
debugln SETL    {FALSE} :LAND: debug


;;---------------------------------------------------------------------------
;; Register names
;;---------------------------------------------------------------------------

wsptr           RN      R12

scy             RN      R11             ;; wimp stuff
scx             RN      R10             ;;

yco             RN      R11             ;; game stuff
xco             RN      R10             ;;

pointer         RN      R11
localvar        RN      R10     ; scx   ;; used for local variables

y1              RN      R9              ;; for each object
x1              RN      R8              ;;
y0              RN      R7              ;;
x0              RN      R6              ;;

yy1             RN      R7              ;; for collision detection
xx1             RN      R6              ;;
yy0             RN      R5 ; linelength ;;
xx0             RN      R4 ; bpp        ;;

linelength      RN      R5              ;; for plotting objects
bpp             RN      R4              ;;
mask            RN      R3              ;;
addr            RN      R2              ;;
temp            RN      R1              ;;


;;---------------------------------------------------------------------------
;; Workspace
;;---------------------------------------------------------------------------

coord_scoretextx0       *       16
coord_scoretexty0       *       -40
coord_scorex0           *       coord_scoretextx0 + 8*:LEN:"Score"
coord_scorey0           *       -72

roidrate        *       2               ; 2 centiseconds = 1 vsync
accfreq         *       8               ; frequency of deceleration

velbits         *       16

init_minv       *       (1:SHL:velbits)
init_maxv       *       (4:SHL:velbits) - init_minv
init_minsplitv  *       (0:SHL:velbits)
init_maxsplitv  *       (1:SHL:velbits) - init_minsplitv

add_minv        *       1 :SHL: (velbits-4)
add_maxv        *       4 :SHL: (velbits-4)
add_minsplitv   *       1 :SHL: (velbits-4)
add_maxsplitv   *       3 :SHL: (velbits-4) - add_minsplitv

                ^       0
shipQ           #       1               ; subsections of roidtable
roidQ           #       1               ; used for controlling rate of moving
bulletQ         #       1
spaceQ          #       1
spcbulletQ      #       1
shipexplosQ     #       1
numqueues       #       0

numroids        *       20*4
numbullets      *       4               ; separate queue for spaceship
numshipexp      *       5

shipO           *       1               ; index of ship in table
roidO           *       numroids        ; index of asteroids in table
bulletO         *       numbullets      ; index of bullets in table
spaceO          *       1
spcbulletO      *       1
shipexplosO     *       numshipexp

                ^       0
                #       shipO
                #       roidO
                #       bulletO
                #       spaceO
                #       spcbulletO
                #       shipexplosO
numobjects      #       0               ; number of objects in table

                ^       0               ; elements within the queue
sh_type         #       4               ; shape number
sh_xco          #       4               ; coordinates
sh_yco          #       4               ;
sh_xvel         #       4               ; velocity
sh_yvel         #       4               ;
sh_localvar     #       4               ; object-dependent purpose
sh_oldtype      #       4               ; previous type (for updating)
sh_oldxco       #       4
sh_oldyco       #       4
sh_size         #       0

shf_unused      *       1 :SHL: 31      ; object type flag => no object

shtype_ship0    *       0
shtype_ship32   *       32
shtype_roid0    *       32
shtype_roid1    *       33
shtype_roid2    *       34
shtype_bullet   *       35
shtype_space0   *       36
shtype_explos0  *       37
shtype_explos1  *       38
shtype_explos2  *       39
shtype_explos3  *       40
shtype_explos4  *       41
shtype_explosN  *       42
shtype_space1   *       42
shtype_creator  *       43              ; the invisible ship creator
shtype_hyperspace   *   44              ; while in hyperspace
shtype_newgame  *       45              ; waiting to start a new game

                ^       0,wsptr
wsorigin        #       0

privateword     #       4

freeptr         #       4               ; for templates
mytaskhandle    #       4
nwindows        #       4
h_Arena         #       4
h_FullArena     #       4
h_Scores        #       4
spritearea      #       4               ; pointer to sprite area
scoreheight     #       4               ; height of scores window

oldtime         #       4
seed            #       4
hascaret        #       4               ; 1 => we have the input focus
oldfirekey      #       4

acccounter      #       4

minv            #       4
maxv            #       4
minsplitv       #       4
maxsplitv       #       4

score           #       4
nships          #       4               ; number of ships left (including the one on the screen)
nsheet          #       4               ; current sheet number
extramanscore   #       4               ; next extra man

newsheetdelay   *       250             ; wait 250 centiseconds before new sheet
newsheetwait    #       4

newsheetroids   #       4               ; number of roids at start of sheet

hyperspace_delay  *     100             ; wait 1 second
hypertime       #       4               ; time when hyperspace occurred
hyperspace_wouldhavehitarock # 4        ; 1 => this was a justified hyperspace

bullet_speed    *       75              ; originally 50
bullet_lifetime *       50

state_inwimp    *       0               ; running under the Wimp
state_goingfull *       1               ; trying to occupy full screen
state_full      *       2               ; window occupies full screen
windowstate     #       4

paused          #       4               ; 0 => running, non-0 => paused

canhyperspace   #       4               ; 0 => space not yet released

game_inprogress *       0
game_finished   *       1
game_restart    *       2
gameoverflag    #       4

oldpointershape #       4
oldborderpal    #       8               ; actually only needs 5 bytes

wrapx0          #       4
wrapy0          #       4
wrapx1          #       4
wrapy1          #       4

wrapxpixels     #       4               ; size of wrap area (pixels)
wrapypixels     #       4               ; used in collision code

grafx0          #       4
grafy0          #       4
grafx1          #       4
grafy1          #       4

vduoutput       #       0
screenstart     #       4
linelen         #       4
log2bpc         #       4
log2bpp         #       4
log2px          #       4
log2py          #       4
xwindlimit      #       4
ywindlimit      #       4

screen_x1       #       4
screen_y1       #       4

BPP             #       4

colour          #       4               ; colour of current object
colour_ship     #       4               ; colour of ship
colour_bullet   #       0               ; same as dead ship
colour_dead     #       4               ; colour of dead ship
colour_roids    #       4               ; colour of asteroids

shipicon        #       i_size          ; copy of ship sprite icon
gameovericon    #       i_size          ; copy of "Game over" icon

wimpcolours     #       4 * 20          ; 20 words : bottom bytes are colours

; object and queue data

qstart          #       4 * numqueues + 4
qcurrent        #       4 * numqueues

roidtable       #       sh_size * numobjects

; gubbins for loading templates etc.

        ALIGNHASH       256

userdata        #       &400
stackbot        #       &200
stacktop        #       0

fonthandles     #       &100

dataarea        #       &200            ; for template indirected data
freeend         #       0

        ALIGNHASH       256

spriteareasize  *       1024            ; 1K should be enough
spritedata      #       spriteareasize

maxwork         *       (@-wsorigin)

        !       0,"Workspace needed = ":CC::STR:((maxwork+1023)/1024):CC:"K"


;;---------------------------------------------------------------------------
;; Module header
;;---------------------------------------------------------------------------

        LEADR   Module_LoadAddr

        ASSERT  (.=Module_BaseAddr)

        DCD     Start          - Module_BaseAddr
        DCD     0                               ; Init
        DCD     0 ; Die            - Module_BaseAddr  ; ### leave out while debugging!
        DCD     Service        - Module_BaseAddr
        DCD     Title          - Module_BaseAddr
        DCD     Helpstr        - Module_BaseAddr
        DCD     Helptable      - Module_BaseAddr
        DCD     0                               ; MySWIBase
        DCD     0                               ; Wimp_SWIdecode
        DCD     0                               ; Wimp_SWInames
        DCD     0
        DCD     0
        DCD     0

Title   =       "Meteors",0
Helpstr =       "Meteors",9,9,"0.18 (28 Jan 1994)",0
        ALIGN

Helptable
        Command Meteors_Start, 0, 0
        DCD     0

Meteors_Start_Help
        DCB     "*Meteors_Start starts up an instance of the meteors module"
        DCB     13,10
Meteors_Start_Syntax
        DCB     "Syntax: *Meteors_Start"
        DCB     0
        ALIGN

Meteors_Start_Code
        Push    "LR"
        MOV     R2,R0                   ; R2 -> command tail (if any)
        ADR     R1,Title
        MOV     R0,#ModHandReason_Enter
        SWI     XOS_Module
        Pull    "PC"


;;---------------------------------------------------------------------------
;; Init / Die routines
;;---------------------------------------------------------------------------

Die             ROUT
        Push    "LR"

        LDR     R14,[R12]                       ; any instances left?
        TEQ     R14,#0
        XError  CantKill,NE

        Pull    "PC"
        MakeErrorBlock CantKill

Service         ROUT
        TEQ     R1,#Service_Memory
        MOVNE   PC,LR

        Push    "LR"
        ADRL    LR,Module_BaseAddr
        CMP     R2,LR
        ADRGEL  LR,Module_EndAddr-1
        CMPGE   LR,R2
        MOVGE   R1,#0                       ; claim service if we're active
        Pull    "PC"


taskidentifier  DCB     "TASK"


;;---------------------------------------------------------------------------
;; Template information
;;---------------------------------------------------------------------------

templatefname   DCB     "<Meteors$Dir>.Templates",0
                ALIGN

wn_Scores       FixDCB  12,"Scores"
wn_Arena        FixDCB  12,"Arena"
wn_FullArena    FixDCB  12,"FullArena"
spritefilename  DCB     "<Meteors$Dir>.Sprites",0
                ALIGN

; Icons in Scores window

scoreicon_handle        *       1
sheeticon_handle        *       3
shipicon_handle         *       4

; Icons in (Full)Arena windows

gameovericon_handle     *       0       ; used with Wimp_PlotIcon

;;---------------------------------------------------------------------------
;; Entry point
;;---------------------------------------------------------------------------

ErrorCloseTemplate
        Push    "R0"
        SWI     XWimp_CloseTemplate
        Pull    "R0"

ErrorAbort
        MOV     R1,#2                   ; Cancel box only
        MOV     R2,#0
        SWI     XWimp_ReportError
        B       closedown

ErrorNoWimp
        XError  WimpNotPresent
        SWI     OS_GenerateError        ; can't use Wimp to report error!
        MakeErrorBlock WimpNotPresent

Start   ROUT
        MOV     R14,R12
        MOV     wsptr,#&8000            ; use application space
        STR     R14,privateword         ; remember for later
        ADR     sp,stacktop

      [ debug
        Debug_Init <Meteors$Dir>.debugfile
      ]

        ADR     R1,fonthandles          ; initialise font handle array
        MOV     R2,#256
        MOV     R14,#0
01      STR     R14,[R1],#4
        SUBS    R2,R2,#4
        BGT     %BT01

        MOV     R0,#200                 ; latest known Wimp version number
        LDR     R1,taskidentifier
        ADRL    R2,Title
        SWI     XWimp_Initialise
        BVS     ErrorNoWimp
        STR     R1,mytaskhandle

        LDR     R1,privateword
        LDR     R14,[R1]                ; increment task count
        ADD     R14,R14,#1
        STR     R14,[R1]

        MOV     R14,#0
        STR     R14,nwindows
        STR     R14,nships              ; old value used by setships
        STR     R14,oldborderpal        ; not saved yet
        STR     R14,paused

        MOV     R14,#2                  ; marker => set it up
        STR     R14,hascaret

        MOV     R14,#accfreq
        STR     R14,acccounter

        MOV     R14,#0                  ; can't fire till button released
        STR     R14,oldfirekey

        MOV     R14,#state_inwimp
        STR     R14,windowstate
;
; investigate mode properties
;
        BL      getmodeinfo
        BVS     ErrorAbort
;
; load internal sprites
;
        LDRVC   R0,=&100+SpriteReason_LoadSpriteFile
        ADRVC   R1,spritedata
        STRVC   R1,spritearea           ; pointer to sprite area
        MOVVC   R2,#spriteareasize
        MOVVC   R3,#0
        MOVVC   R4,#16
        MOVVC   R5,#16
        STMVCIA R1,{R2-R5}              ; initialise area header
        ADRVC   R2,spritefilename
        SWIVC   XOS_SpriteOp
;
; read templates
;
        ADR     R14,dataarea            ; for indirected data
        STR     R14,freeptr

        ADRVC   R1,templatefname
        SWIVC   XWimp_OpenTemplate
        BVS     ErrorAbort

        ADR     R1,userdata             ; 'Scores' window
        ADR     R5,wn_Scores
        BL      read_template
        LDRVC   R2,[R1,#w_way1]
        LDRVC   R3,[R1,#w_way0]
        SUBVC   R2,R2,R3
        STRVC   R2,scoreheight          ; used for positioning the window
        LDRVC   R14,spritearea
        STRVC   R14,[R1,#w_areaCBptr]
        MOVVC   R14,#255                ; no border required
        STRVCB  R14,[R1,#w_tfcol]
        ADDVC   R14,R1,#w_icons + shipicon_handle*i_size
        ASSERT  i_size = 8*4
        LDMVCIA R14,{R2-R9}
        ADRVC   R14,shipicon            ; used with Wimp_PlotIcon
        STMVCIA R14,{R2-R9}
        MOV     R14,#shipicon_handle
        STR     R14,[R1,#w_nicons]
        BLVC    create_window
        STRVC   R0,h_Scores

        ADRVC   R1,userdata             ; 'FullArena' window
        ADRVC   R5,wn_FullArena
        BLVC    read_template
        BLVC    create_window
        STRVC   R0,h_FullArena
        LDRVC   R14,nwindows            ; this one doesn't count
        SUBVC   R14,R14,#1
        STRVC   R14,nwindows

        ADRVC   R1,userdata             ; 'Arena' window
        ADRVC   R5,wn_Arena
        BLVC    read_template
        ADDVC   R14,R1,#w_icons + gameovericon_handle*i_size
        ASSERT  i_size = 8*4
        LDMVCIA R14,{R2-R9}
        ADRVC   R14,gameovericon        ; used with Wimp_PlotIcon
        STMVCIA R14,{R2-R9}
        MOVVC   R14,#0
        STRVC   R14,[R1,#w_nicons]      ; remove from window itself
        BLVC    create_window
        STRVC   R0,h_Arena
        BLVC    front
        BVS     ErrorCloseTemplate

        SWI     XWimp_CloseTemplate
;
; initialise random number seed
;
        SWIVC   XOS_ReadMonotonicTime
        STRVC   R0,oldtime
        ORRVC   R0,R0,#1                ; must not be zero!
        STRVC   R0,seed

        ADRVC   R1,userdata
        LDRVC   R0,h_Arena
        STRVC   R0,[R1,#u_handle]
        SWIVC   XWimp_GetWindowState
        BLVC    getwrap                 ; set up x0,y0,x1,y1
;
; set up data related to the game itself
;
        BLVC    setqueues               ; initialise queue structure
        BLVC    newgame                 ; create spaceship & delete rest
        BLVC    newsheet                ; create a new lot of rocks
        BVS     ErrorAbort

;
; initialisation complete - enter polling loop
;
repollwimp      ROUT
        BVS     reporterror

        MOV     R0,#&30                 ; disable ptrwindow
        ADR     R1,userdata
        LDR     R2,oldtime

        LDR     R14,windowstate
        CMP     R14,#state_full
        BEQ     fakepoll                ; save time - don't call the Wimp

        SWI     XWimp_PollIdle          ; can't call non-X form
        BVS     repollwimp

        ADR     LR,repollwimp
        CMP     R0,#(endjptable-jptable)/4
        ADDCC   PC,PC,R0,ASL #2
        MOV     PC,LR

jptable
        B       event_null              ;  0
        B       redraw_window           ;  1
        B       open_window             ;  2
        B       close_window            ;  3
        B       repollwimp              ;  4 pointer leaving window
        B       repollwimp              ;  5 pointer entering window
        B       event_mouse             ;  6 mouseclick
        B       repollwimp              ;  7 user dragbox
        B       event_keypressed        ;  8 keypressed
        B       repollwimp              ;  9 menuselect
        B       repollwimp              ; 10 scroll request
        B       event_losecaret         ; 11 lose caret
        B       event_gaincaret         ; 12 gain caret
        B       repollwimp              ; 13
        B       repollwimp              ; 14
        B       repollwimp              ; 15
        B       repollwimp              ; 16
        B       event_message           ; 17 message
        B       event_message           ; 18 message_recorded
        B       repollwimp              ; 19 message_returned
endjptable

;............................................................................

reporterror     ROUT
        MOVVS   R1,#1
        ADRVSL  R2,Title
        SWIVS   XWimp_ReportError
        BVS     ErrorAbort              ; error from Wimp_ReportError!

        BL      setwimpwindow           ; return to the Wimp!
        B       repollwimp

;............................................................................

fakepoll        ROUT
        BL      inkey0
        BMI     fakenull

        CMP     R0,#27                  ; escape?
        BEQ     backtowimp

        BL      processkeys
        B       repollwimp

fakenull
        SWI     OS_ReadMonotonicTime
        CMP     R0,R2                   ; time limit reached?
        BLPL    event_null              ; yes - do game step
        B       repollwimp

backtowimp
        BL      setwimpwindow           ; restore to original position
        B       repollwimp

;----------------------------------------------------------------------------

; All the following service routines will exit with V set if an error occurs
; subsequently control will pass back to the polling loop

event_null      ROUT

        LDR     R2,nwindows
        TEQ     R2,#0                   ; any windows left?
        BEQ     closedown

        Push    "LR"
;
; if we get a null event while in 'goingfull' state, window is up-to-date
;
        LDR     R14,windowstate
        CMP     R14,#state_goingfull
        BNE     %FT01

        MOV     R14,#state_full         ; next time don't bother with Wimp_Poll
        STR     R14,windowstate

        LDR     R14,oldborderpal        ; have we already saved the border colour?
        CMP     R14,#0
        BNE     %FT01

        MOV     R0,#106
        MOV     R1,#&00                 ; turn mouse pointer off
        SWI     OS_Byte
        STR     R1,oldpointershape

        MOV     R0,#0                   ; must use OS_ReadPalette to read border colour
        MOV     R1,#24
        SWI     OS_ReadPalette
        STRB    R0,oldborderpal+0
        STRB    R1,oldborderpal+1
        MOV     R14,R2,LSR #8
        STRB    R14,oldborderpal+2
        MOV     R14,R2,LSR #16
        STRB    R14,oldborderpal+3
        MOV     R14,R2,LSR #24
        STRB    R14,oldborderpal+4

        MOV     R0,#12                  ; write palette to black
        ADR     R1,newborderpal
        SWI     OS_Word
01
;
; ensure window has the input focus initially
;
        LDR     R14,hascaret
        TEQ     R14,#2
        MOVEQ   R14,#1
        STREQ   R14,hascaret
        BLEQ    toggleinputfocus        ; set caret to arena window
        Pull    "PC",VS

        SWI     OS_ReadMonotonicTime
        LDR     R14,oldtime
        ADD     R14,R14,#roidrate
        CMP     R14,R0                  ; ensure next time >= current
        MOVMI   R14,R0                  ; go flat out if necessary
        STR     R14,oldtime

        LDR     R14,hascaret            ; freeze unless we have the caret
        TEQ     R14,#0
        LDRNE   R14,paused              ; 1 => game is paused
        TEQNE   R14,#1
        BLNE    game_step               ; perform one 'game step'

        LDR     R14,gameoverflag
        TEQ     R14,#game_restart       ; has space been pressed?
        Pull    "PC",NE

        BLVC    newgame                 ; must do this outside object loop
        BLVC    newsheet
        BLVC    update_objects

        Pull    "PC"

newborderpal
        DCB     0,24,0,0,0              ; program border to black
        ALIGN

;----------------------------------------------------------------------------

event_mouse     ROUT                    ; just drop through for now...

;............................................................................

toggleinputfocus ROUT
        Push    "R1-R5,LR"

        LDR     R0,h_Arena              ; if we already have the input focus
        ASSERT  u_handle = 0            ; set it to null, else gain it
        STR     R0,[sp,#-u_windowstate]!
        MOV     R1,sp
        SWI     XWimp_GetWindowState
        LDRVC   R14,[R1,#u_wflags]
        ADD     sp,sp,#u_windowstate           ; correct stack
        Pull    "R1-R5,PC",VS

        TST     R14,#ws_hasfocus
        MOVNE   R14,#0                  ; losing input focus
        MOVEQ   R14,#1                  ; gaining input focus
        STR     R14,hascaret

        LDREQ   R0,h_Arena
        MOVNE   R0,#-1
        MOV     R1,#-1
        MOV     R2,#0
        MOV     R3,#0
        MOV     R4,#caret_invisible
        MOV     R5,#0
        SWI     XWimp_SetCaretPosition  ; Gain_Caret event will come later

        Pull    "R1-R5,PC"

;----------------------------------------------------------------------------

event_keypressed ROUT
        Push    "LR"
        LDR     R0,[R1,#6*4]            ; pass on all function key codes

        CMP     R0,#27
        BEQ     setfullw

        BL      processkeys             ; EQ => key was processed

        CMP     R0,#&100                ; pass on all function keys
        SWICS   XWimp_ProcessKey

        Pull    "PC"

setfullw
        BL      setfullwindow
        Pull    "PC"

;............................................................................

; Check for keys that are common to full window and Wimp window
; In    R0 = key code
; Out   EQ => key was dealt with (NE => pass it on)

processkeys     ROUT
        Push    "LR"

        CMP     R0,#" "                 ; for new game
        BEQ     dokey_space

        CMP     R0,#"N"
        CMPNE   R0,#"n"
        BEQ     dokey_newsheet

        LDR     R14,=&18B
        CMP     R0,R14
        MOVEQ   R14,#1
        STREQ   R14,paused

        CMP     R0,#&7F
        MOVEQ   R14,#0
        STREQ   R14,paused

        Pull    "PC"

dokey_space
        LDR     R14,gameoverflag
        CMP     R14,#game_finished
        MOVEQ   R14,#game_restart
        STREQ   R14,gameoverflag
        BLEQ    forceredraw_gameover
        Pull    "PC"

dokey_newsheet
        BL      newsheet
        Pull    "PC"

;............................................................................

; Open full window at front, covering the whole screen

setfullwindow   ROUT
        Push    "R1,x0,y0,x1,y1,scx,scy,LR"

        LDR     R14,windowstate         ; ignore this if already full
        CMP     R14,#state_inwimp
        Pull    "R1,x0,y0,x1,y1,scx,scy,PC",NE

        ADR     R1,userdata
        LDR     R0,h_Arena
        STR     R0,[R1,#u_handle]
        SWI     XWimp_GetWindowState

        LDR     R0,h_FullArena
        LDMIB   R1,{x0,y0,x1,y1,scx,scy}
        MOV     x0,#0
        MOV     y0,#0
        LDR     x1,screen_x1
        LDR     y1,screen_y1
        MOV     R14,#-1                 ; open at front
        STMIA   R1,{R0,x0,y0,x1,y1,scx,scy,R14}
        BLVC    open_window             ; opens pane as well

        MOVVC   R14,#state_goingfull    ; try to stop using Wimp_Poll
        STRVC   R14,windowstate

        BLVC    gameovercoords

        Pull    "R1,x0,y0,x1,y1,scx,scy,PC"

; Restore window to the Wimp environment

setwimpwindow   ROUT
        Push    "LR"

        LDR     R14,windowstate         ; ignore this if already in Wimp
        CMP     R14,#state_inwimp
        Pull    "PC",EQ

        CMP     R14,#state_full         ; did we go all the way?
        BNE     %FT01

        MOV     R0,#106
        LDR     R1,oldpointershape      ; restore pointer shape if so
        SWI     OS_Byte

        MOV     R0,#12                  ; write border palette
        ADR     R1,oldborderpal
        SWI     OS_Word

        MOV     R14,#0
        STR     R14,oldborderpal        ; we've written this back now
01
        MOV     R14,#state_inwimp
        STR     R14,windowstate

        ADR     R1,h_FullArena
        SWI     XWimp_CloseWindow

        ADRVC   R1,userdata
        LDRVC   R0,h_Arena
        STRVC   R0,[R1,#u_handle]
        SWIVC   XWimp_GetWindowState
        BLVC    open_window             ; opens pane as well

        BLVC    gameovercoords

        Pull    "PC"

;----------------------------------------------------------------------------

event_gaincaret ROUT
        MOV     R0,#1
        STR     R0,hascaret
        MOV     PC,LR

;----------------------------------------------------------------------------

event_losecaret ROUT
        MOV     R0,#0
        STR     R0,hascaret
        MOV     PC,LR

;----------------------------------------------------------------------------

event_message   ROUT
        LDR     R0,[R1,#ms_action]

        LDR     R2,=Message_ModeChange
        TEQ     R0,R2
        LDRNE   R2,=Message_PaletteChange
        TEQNE   R0,R2
        BEQ     getmodeinfo

        TEQ     R0,#Message_Quit
        MOVNE   PC,LR                   ; drop through if Quit

;............................................................................

closedown       ROUT
        ADR     R1,fonthandles
        MOV     R2,#255
01      LDRB    R14,[R1,R2]
        SUBS    R14,R14,#1
        STRGEB  R14,[R1,R2]
        ADDGT   R2,R2,#1                ; do this one again
        MOVGE   R0,R2
        SWIGE   XFont_LoseFont
        SUBS    R2,R2,#1
        BGE     %BT01

        LDR     R0,mytaskhandle
        LDR     R1,taskidentifier       ; R1 = "TASK"
        SWI     XWimp_CloseDown
        MOV     R14,#0
        STR     R14,mytaskhandle
        LDR     R1,privateword
        LDR     R14,[R1]
        SUB     R14,R14,#1
        STR     R14,[R1]

      [ debug
        Debug_Close
      ]

        LDR     R12, privateword
        TEQ     R14,#0
        ADREQL  R3,Title
        SWIEQ   OS_ExitAndDie
        SWI     OS_Exit

        LTORG

;----------------------------------------------------------------------------

; Get mode properties, on mode or palette change

getmodeinfo     ROUT
        Push    "R1-R3,LR"

        ADR     R0,vduinput
        ADR     R1,vduoutput
        SWI     XOS_ReadVduVariables

        ADRVC   R1,wimpcolours
        SWIVC   XWimp_ReadPalette

        Pull    "R1-R3,PC",VS

        LDR     R1,xwindlimit
        ADD     R1,R1,#1
        LDR     R2,log2px
        MOV     R1,R1,LSL R2
        STR     R1,screen_x1

        LDR     R1,ywindlimit
        ADD     R1,R1,#1
        LDR     R2,log2py
        MOV     R1,R1,LSL R2
        STR     R1,screen_y1

        LDR     R1,log2px
        LDR     R2,log2py
        SUBS    R3,R2,R1                ; if y-size > x-size,
        ADDGT   R1,R1,R3                ; multiply up the pixel width
        STRGT   R1,log2px

        MOV     R14,#1
        LDR     R1,log2bpc              ; watch out for double-pixel modes
        ADDGT   R1,R1,R3                ; and our own pixel enlargement
        STRGT   R1,log2bpc
        MOV     R2,R14,LSL R1
        STR     R2,BPP

        MOV     R0,#9
        BL      getcolour
        STRVC   R0,colour_ship

        MOV     R0,#11
        BL      getcolour
        STRVC   R0,colour_dead

        MOVVC   R0,#15
        BLVC    getcolour
        STRVC   R0,colour_roids

        Pull    "R1-R3,PC"

vduinput
        DCD     VduExt_ScreenStart
        DCD     VduExt_LineLength
        DCD     VduExt_Log2BPC
        DCD     VduExt_Log2BPP
        DCD     VduExt_XEigFactor
        DCD     VduExt_YEigFactor
        DCD     VduExt_XWindLimit
        DCD     VduExt_YWindLimit
        DCD     -1

;............................................................................

; In    R0 = Wimp colour
; Out   R0 = colour mask for colour EOR colour 0

getcolour       ROUT
        Push    "R2,LR"

        ADR     R14, wimpcolours
        LDR     R0, [R14, R0, LSL #2]
        SWI     XColourTrans_ReturnColourNumber
        MOVVC   R2, R0
        LDRVC   R0, wimpcolours+7*4
        SWIVC   XColourTrans_ReturnColourNumber
        Pull    "R2,PC",VS
        EOR     R0, R0, R2

        MOV     R14,#1
        LDR     R2,log2bpp
        MOV     R2,R14,LSL R2           ; R2 = bits per pixel
        MOV     R14,#32
01
        ORR     R0,R0,R0,LSL R2         ; add another pixel
        SUBS    R14,R14,R2
        BGT     %BT01

        Pull    "R2,PC"

;;---------------------------------------------------------------------------
;; Wimp service routines
;;---------------------------------------------------------------------------

; Entry:  R1 --> user block to put template
;         R5 --> name of relevant entry

read_template   ROUT
        Push    "R2,LR"
;
        LDR     R2,freeptr
        ADR     R3,freeend
        ADR     R4,fonthandles
        MOV     R6,#0
        SWI     XWimp_LoadTemplate
        Pull    "R2,PC",VS
;
        TEQ     R6,#0
        XError  WimpNoTemplate,EQ
;
        STRVC   R2,freeptr              ; forget these icons if error
;
        Pull    "R2,PC"
        MakeErrorBlock WimpNoTemplate

;............................................................................

create_template ROUT
        Push    "LR"
;
        ADR     R1,userdata
        BL      read_template
        BLVC    create_window
;
        Pull    "PC"

;............................................................................

create_window   ROUT
        Push    "LR"
;
        SWI     XWimp_CreateWindow
        LDRVC   R14,nwindows
        ADDVC   R14,R14,#1
        STRVC   R14,nwindows
;
        Pull    "PC"

;----------------------------------------------------------------------------

; Entry:  R1 --> block
;         R1+0   window handle
;         R1+4   x0,y0,x1,y1
;         R1+20  scx,scy
; Exit:   window opened at specified coordinates
;         pane windows opened as well

open_window     ROUT
        Push    "R0,R1,x0,y0,x1,y1,LR"

        LDR     R0,[R1,#u_handle]
        LDR     R14,h_Arena
        TEQ     R0,R14
        LDRNE   R14,h_FullArena
        TEQNE   R0,R14
        BNE     %FT50

        STR     R0,[sp,#-u_windowstate]!
        MOV     R1,sp
        SWI     XWimp_GetWindowState            ; get window state on stack
        LDMIA   R1,{R0,x0,y0,x1,y1}
        SUB     x0,x1,x0
        SUB     y0,y1,y0                        ; x0,y0 = previous size

        Push    "x0,y0"
        LDRVC   R1,[sp,#u_windowstate+4+8]
        BLVC    roundcoords
        SWIVC   XWimp_OpenWindow                ; open tool window first
        SWIVC   XWimp_GetWindowState            ; see where it went
        LDMVCIA R1,{R0,x0,y0,x1,y1}
        SUBVC   x0,x1,x0
        SUBVC   y0,y1,y0                        ; x0,y0 = new size
        Pull    "x1,y1"                         ; x1,y1 = old size
        ADDVS   sp,sp,#u_windowstate                   ; correct stack
        BVS     %FT99

        TEQ     x0,x1                   ; if size has changed, redraw the lot
        TEQEQ   y0,y1
        BLNE    ForceAll                ; R0 = window handle (see above)

        LDMIA   sp,{R0,x0,y0,x1,y1,scx,scy}
        LDR     R14,[sp,#u_wflags]
        TST     R14,#ws_open            ; correct coords if window was open
        ADD     sp,sp,#u_windowstate
        SUBNE   R4,x0,scx
        SUBNE   R5,y1,scy
        BLNE    correctcoords           ; R1 --> new coords, R4,R5 = old

        LDR     R14,[R1,#u_way1]
        LDR     R0,scoreheight
        SUB     R14,R14,R0
        STR     R14,[R1,#u_way0]                ; position at top of window
        MOV     R14,#0
        STR     R14,[R1,#u_scx]
        STR     R14,[R1,#u_scy]
        LDR     R0,h_Scores
        STR     R0,[R1,#u_handle]
50
        SWIVC   XWimp_OpenWindow
99
        STRVS   R0,[sp]
        Pull    "R0,R1,x0,y0,x1,y1,PC"

;----------------------------------------------------------------------------

; In    R1 -> open window block
; Out   coordinates rounded to pixels

roundcoords     ROUT
        Push    "R1-R5,x0,y0,x1,y1,scx,scy,LR"

        ASSERT  R4 < x0
        LDR     R4,h_Arena                      ; for comparison

        LDMIA   R1,{R0,x0,y0,x1,y1,scx,scy}

        MOV     R2,#1

        LDR     R14,log2px
        MOV     R14,R2,LSL R14                  ; R14 = width of one 'pixel'
        SUB     R3,R14,#1
        BIC     scx,scx,R3
        BICS    x0,x0,R3
        TEQEQ   R0,R4                           ; only if not full window
        ADDEQ   x0,x0,R14                       ; bounded to screen edge
        BIC     x1,x1,R3

        LDR     R14,log2py
        MOV     R14,R2,LSL R14
        SUB     R3,R14,#1
        BIC     scy,scy,R3
        BIC     y0,y0,R3
        BIC     y1,y1,R3

        STMIA   R1,{R0,x0,y0,x1,y1,scx,scy}

        Pull    "R1-R5,x0,y0,x1,y1,scx,scy,PC"


;----------------------------------------------------------------------------

; Entry:  R1 -> new set of coords
;         R4,R5 = old window origin
;         x0,y0,x1,y1,scx,scy = new window position
; Exit:   all live objects relocated

correctcoords   ROUT
        Push    "R0-R5,LR"

        LDMIA   R1,{R0,x0,y0,x1,y1,scx,scy}

        SUB     R14,x0,scx
        SUB     R4,R14,R4
        SUB     R14,y1,scy
        SUB     R5,R14,R5               ; R4,R5 = offset to add

        LDR     R14,log2px
        MOV     R4,R4,ASR R14
        MOV     R4,R4,LSL #velbits
        LDR     R14,log2py
        MOV     R5,R5,ASR R14
        MOV     R5,R5,LSL #velbits

        BL      getwrap

        LDR     R0,qstart
        LDR     R2,qstart + 4*numqueues
01
        LDMIA   R0,{R1,xco,yco}
        TST     R1,#shf_unused
        ADDEQ   xco,xco,R4
        ADDEQ   yco,yco,R5
        BLEQ    wrapcoords
        STMEQIA R0,{R1,xco,yco}

        LDR     xco,[R0,#sh_oldxco]
        LDR     yco,[R0,#sh_oldyco]
        ADD     xco,xco,R4
        ADD     yco,yco,R5
        BL      wrapcoords
        STR     xco,[R0,#sh_oldxco]
        STR     yco,[R0,#sh_oldyco]

        ADD     R0,R0,#sh_size
        CMP     R0,R2
        BNE     %BT01

        Pull    "R0-R5,PC"

;----------------------------------------------------------------------------

; Entry:  R1 --> block
;         [R1] = handle of window to delete

close_window    ROUT
        Push    "R0-R2,LR"
;
        LDR     R0,[R1]
        BL      deletewindow
        BVS     %FT99

        LDR     R14,h_Arena
        TEQ     R0,R14
        LDREQ   R0,h_Scores
        BLEQ    deletewindow
99
        STRVS   R0,[sp]
        Pull    "R0-R2,PC"

;----------------------------------------------------------------------------

; Entry:  R0 = handle of window to delete

deletewindow    ROUT
        Push    "R0,LR"

        MOV     R1,sp
        SWI     XWimp_DeleteWindow
        LDRVC   R14,nwindows
        SUBVC   R14,R14,#1
        STRVC   R14,nwindows

        STRVS   R0,[sp]
        Pull    "R0,PC"

;----------------------------------------------------------------------------

; Entry:  R0 = window handle
; Exit:   window opened at front

front   ROUT
        Push    "LR"

        ADR     R1,userdata
        STR     R0,[R1]
        SWI     XWimp_GetWindowState
        MOVVC   R14,#-1
        STRVC   R14,[R1,#u_bhandle]
        BLVC    open_window             ; check for size changing

        Pull    "PC"

;----------------------------------------------------------------------------

; Entry:  R0 = window handle
; Exit:   x1,y1 = origin of window

getwindowcoords ROUT
        Push    "R0,R1,x0,y0,scx,scy,LR"
;
        ADR     R1,userdata
        STR     R0,[R1]
        SWI     XWimp_GetWindowState
        ADRVCL  R14,userdata+4
        LDMVCIA R14,{x0,y0,x1,y1,scx,scy}
        SUBVC   x1,x0,scx                       ; x1,y1 = window origin
        SUBVC   y1,y1,scy
;
        STRVS   R0,[sp]
        Pull    "R0,R1,x0,y0,scx,scy,PC"

;----------------------------------------------------------------------------

; Entry:  R0 = window handle
; Exit:   window invalidated

ForceAll        ROUT
        Push    "R1-R4,LR"

        MOV     R1,#-bignum
        MOV     R2,#-bignum
        MOV     R3,#bignum
        MOV     R4,#bignum
        SWI     XWimp_ForceRedraw

        Pull    "R1-R4,PC"

;;---------------------------------------------------------------------------
;; Perform one 'game step'
;;---------------------------------------------------------------------------

; Entry:  roidtable contains object definitions
; Exit:   moved objects have different sh_type,xco,yo from sh_oldtype,oldxco,oldyco

game_step       ROUT
        Push    "LR"

        MOV     R0,#shipQ
        BL      move_queue

        MOV     R0,#roidQ
        MOV     R1,#numroids/3
        BL      moves_queue

        MOV     R0,#bulletQ
        MOV     R1,#numbullets
        BL      moves_queue

        MOV     R0,#shipexplosQ
        MOV     R1,#numshipexp
        BL      moves_queue

        BL      check_newsheet

        BL      update_objects          ; reflect changes on the screen

        Pull    "PC"

;............................................................................

; In    R0 = queue index
;       R1 = no of moves to make

moves_queue     ROUT
        Push    "LR"
01
        BL      move_queue
        SUBS    R1,R1,#1
        BNE     %BT01

        Pull    "PC"

;............................................................................

; In    [newsheetwait] indicates whether we're waiting for a new sheet
; Out   if newsheetwait = 0 then:
;            if no rocks, newsheetwait := current time OR 1
;       else if current time - newsheetwait > newsheetdelay
;               then create rocks for next sheet

check_newsheet  ROUT
        Push    "R2,R3,LR"

        LDR     R14,newsheetwait
        TEQ     R14,#0
        BEQ     %FT01

        SWI     OS_ReadMonotonicTime
        SUB     R0,R0,R14
        CMP     R0,#newsheetdelay
        BLHI    newsheet
        Pull    "R2,R3,PC"
01
        LDR     R2,qstart + 4*roidQ     ; R2 -> first object
        LDR     R3,qstart + 4*roidQ + 4 ; R3 -> last object plus one
        ASSERT  sh_type = 0
02      LDR     R14,[R2],#sh_size
        TST     R14,#shf_unused
        Pull    "R2,R3,PC",EQ           ; at least one rock left
        CMP     R2,R3
        BLO     %BT02

        SWI     OS_ReadMonotonicTime    ; start waiting for a new sheet
        ORR     R0,R0,#1                ; value mustn't be 0
        STR     R0,newsheetwait

        Pull    "R2,R3,PC"

;............................................................................

; In    R0 = index of relevant queue
;       qstart[R0] -> first object in queue
;       qstart[R0+1] -> one after the last object
;       qcurrent[R0] = index of next object to move in queue
; Out   x0,y0,x1,y1,localvar corrupted

move_queue      ROUT
        Push    "R0-R3,LR"

        ADR     R3,qcurrent
        LDR     R0,[R3,R0,LSL #2]!      ; R0 -> next object to move

        LDR     R1,[R0,#sh_type]
        TST     R1,#shf_unused          ; don't bother if dead
        LDMEQIB R0,{x0,y0,x1,y1,localvar}
        BLEQ    move_object             ; updates R1,x0,y0,x1,y1
        STMEQIA R0,{R1,x0,y0,x1,y1,localvar}
        ADD     R0,R0,#sh_size

        ADR     R2,qstart
        LDR     R14,[sp,#0*4]           ; R14 = queue index
        LDR     R1,[R2,R14,LSL #2]!     ; R1 -> first object in queue
        LDR     R2,[R2,#4]              ; R2 -> last object in queue
        TEQ     R0,R2
        MOVEQ   R0,R1
        STR     R0,[R3]                 ; update qcurrent[]

        Pull    "R0-R3,PC"

;............................................................................

; In    R0 -> current object entry
;       R1,x0,y0,x1,y1,localvar = current object's properties
; Out   R1,x0,y0,x1,y1,localvar updated (velocities are changed first)

move_object     ROUT
        Push    "R0,LR"

        CMP     R1,#maxmove             ; number of distinct move routines
        ADRLO   LR,move_return
        ADRLO   pointer,moveindexes
        LDRLOB  pointer,[pointer,R1]

        ASSERT  jumptable-. = 8
        ADDLO   PC,PC,pointer,LSL #2
        B       err_cockup

        MACRO
$lab    Jump    $Name, $Label
$Name   *       (.-jumptable)/4
$lab    B       mv_$Label
        MEND

jumptable
        Jump    Ship,       ship
        Jump    Roid,       roid
        Jump    Bullet,     bullet
        Jump    SpShip,     spaceship
        Jump    ShExp,      shipexplos
        Jump    Creator,    creator
        Jump    Hyperspace, hyperspace
        Jump    NewGame,    newgame

moveindexes
        DCB     Ship, Ship, Ship, Ship, Ship, Ship, Ship, Ship
        DCB     Ship, Ship, Ship, Ship, Ship, Ship, Ship, Ship
        DCB     Ship, Ship, Ship, Ship, Ship, Ship, Ship, Ship
        DCB     Ship, Ship, Ship, Ship, Ship, Ship, Ship, Ship
        DCB     Roid, Roid, Roid
        DCB     Bullet
        DCB     SpShip
        DCB     ShExp, ShExp, ShExp, ShExp, ShExp
        DCB     SpShip
        DCB     Creator
        DCB     Hyperspace
        DCB     NewGame
maxmove *       . - moveindexes

err_cockup
        ADR     R0,error_cockup
        SWI     OS_GenerateError

move_return
        ADD     x0,x0,x1
        ADD     y0,y0,y1

        Push    "x1,y1,xco,yco"         ; correct x0,y0
        MOV     xco,x0
        MOV     yco,y0
        ADR     R14,wrapx0
        LDMIA   R14,{x0,y0,x1,y1}
        BL      wrapcoords              ; don't let it get out of hand
        MOV     x0,xco
        MOV     y0,yco
        Pull    "x1,y1,xco,yco"

        Pull    "R0,PC",,^

error_cockup
        DCD     1
        DCB     "Unknown object type!"
        DCB     0
        ALIGN

;............................................................................

; In    R1,x0,y0,x1,y1,localvar = shape number,x,y,xv,yv,direction for ship
; Out   R1,x0,y0,x1,y1,localvar updated

key_Z           *       -98 :AND: &FF
key_X           *       -67 :AND: &FF
key_shift       *        -1 :AND: &FF
key_return      *       -74 :AND: &FF
key_space       *       -99 :AND: &FF

mv_ship         ROUT
        Push    "LR"

; deal with hyperspace button

        MOV     R0,#key_space
        BL      inkey
        BNE     hyperspace

        MOV     R14,#1
        STR     R14,canhyperspace       ; allowed to hyperspace if space seen up

; deal with turning left and right

        MOV     R0,#key_Z
        BL      inkey
        ADDNE   localvar,localvar,#1    ; turn left
        MOV     R0,#key_X
        BL      inkey
        SUBNE   localvar,localvar,#1    ; turn right
        AND     localvar,localvar,#63   ; keep within range
        MOV     R1,localvar,ASR #1      ; shape = direction / 2

; deal with thrust key and deceleration due to resistance

        MOV     R0,#key_shift
        BL      inkey
        ADRNEL  R2,acctable             ; add thrust in appropriate direction
        LDRNE   R14,[R2,R1,LSL #3]!
        ADDNE   x1,x1,R14
        LDRNE   R14,[R2,#4]
        ADDNE   y1,y1,R14

        LDR     R14,acccounter          ; subtract 1/16th of velocity
        SUBS    R14,R14,#1              ; (one in 8 cycles)
        MOVEQ   R14,#accfreq
        STR     R14,acccounter
        SUBEQ   x1,x1,x1,ASR #4
        SUBEQ   y1,y1,y1,ASR #4

        BL      tryhitroid
        BNE     deadship

; deal with 'fire' key

        MOV     R0,#key_return
        BL      inkey
        LDR     R14,oldfirekey
        STR     PC,oldfirekey
        BIC     R14,R14,PC              ; Z now unset, and was set
        TST     R14,#Z_bit
        BEQ     nofire

        Push    "R1,x0,y0,x1,y1,localvar"
        ADRL    R2,acctable
        LDR     R14,[R2,R1,LSL #3]!
        MOV     R0,#bullet_speed
        MLA     x1,R14,R0,x1            ; add ship's velocity to bullet's
        MOV     R0,#100
        MLA     x0,R14,R0,x0            ; start bullet off ahead of ship
        LDR     R14,[R2,#4]
        MOV     R0,#bullet_speed
        MLA     y1,R14,R0,y1            ; add ship's velocity to bullet's
        MOV     R0,#100
        MLA     y0,R14,R0,y0            ; start bullet off ahead of ship
        MOV     localvar,#bullet_lifetime   ; lifetime of bullet (cycles)
        MOV     R0,#bulletQ
        MOV     R1,#shtype_bullet
        BL      create_object
        Pull    "R1,x0,y0,x1,y1,localvar"
nofire

        Pull    "PC"

hyperspace
        LDR     R14,canhyperspace
        CMP     R14,#0
        Pull    "PC",EQ                 ; not allowed yet

        SWI     OS_ReadMonotonicTime
        STR     R0,hypertime

        MOV     x1,#0                   ; zero velocity immediately
        MOV     y1,#0

        MOV     R1,#cycles_hyperspace
        BL      clevercollision_withrocks       ; check all rocks
        MOVEQ   R14,#0
        MOVNE   R14,#1
        STR     R14,hyperspace_wouldhavehitarock

        MOV     R1,#shtype_hyperspace   ; go into hyperspace!

        Pull    "PC"

deadship
        BL      killroid                ; R0 -> object entry of asteroid
        BL      killship_returncoords   ; updates R1,x0,y0,x1,y1,localvar

        Pull    "PC"

;............................................................................

mv_hyperspace   ROUT
        Push    "LR"

        SWI     OS_ReadMonotonicTime
        LDR     R14,hypertime
        SUB     R0,R0,R14
        CMP     R0,#hyperspace_delay
        Pull    "PC",LE

        MOV     R1,localvar,LSR #1      ; regain original ship shape
        BL      rndcoords

        LDR     R14,hyperspace_wouldhavehitarock
        MOVEQ   R0,#3                   ; 1 in 3 if unnecessary
        MOVNE   R0,#5                   ; 1 in 5 otherwise
        BL      random
        CMP     R0,#0
        BLEQ    killship_returncoords   ; silly hyperspace

        Pull    "PC"

;............................................................................

; Out   x0,y0 = random coordinates within current wrap limits

rndcoords       ROUT
        Push    "x1,y1,xco,yco,LR"

        ASSERT  xco > y1
        ADR     R14,wrapx0
        LDMIA   R14,{x1,y1,xco,yco}

        SUB     R0,xco,x1
        MOV     R0,R0,ASR #velbits
        BL      random
        ADD     x0,x1,R0,LSL #velbits

        SUB     R0,yco,y1
        MOV     R0,R0,ASR #velbits
        BL      random
        ADD     y0,y1,R0,LSL #velbits

        Pull    "x1,y1,xco,yco,PC"

;............................................................................

; In    ship is assumed to be object 0 in shipQ
; Out   ship object killed, and explosion segments created
;       R1,x0,y0,x1,y1,localvar also updated

killship_returncoords ROUT
        Push    "LR"

        BL      killship                ; creates explosion etc
        LDR     R0,qstart + 4*shipQ     ; assume object 0 in shipQ
        LDMIA   R0,{R1,x0,y0,x1,y1,localvar}    ; recopied on exit

        Pull    "PC"

;............................................................................

; In    ship is assumed to be object 0 in shipQ
; Out   ship object killed, and explosion segments created

killship        ROUT
        Push    "R1,R2,x0,y0,x1,y1,localvar,LR"

        LDR     R0,qstart + 4*shipQ
        LDMIA   R0,{R1,x0,y0}           ; current ship position

        Push    "x0,y0"

        BL      newshipcoords           ; set up x0,y0,x1,y1
        LDR     R1,nships
        CMP     R1,#0                   ; if this is the last ship,
        MOVLE   R1,#shtype_newgame      ; we start a new game next time
        MOVGT   R1,#shtype_creator      ; else put it back later
        MOV     localvar,#shiprebirth   ; timeout for ship rebirth / new game
        STMIA   R0,{R1,x0,y0,x1,y1,localvar}

        Pull    "x0,y0"                 ; x0,y0 = where ship died

        ADR     R2,explosdata
        MOV     R0,#shipexplosQ
        MOV     R1,#shtype_explos0
01
        LDMIA   R2!,{x1,y1,localvar}
        BL      create_object
        ADD     R1,R1,#1
        CMP     R1,#shtype_explosN
        BLT     %BT01

        Pull    "R1,R2,x0,y0,x1,y1,localvar,PC"

        MACRO
$lab    explos  $x,$y,$c
$lab    DCD     $x :SHL: (velbits-7), $y :SHL: (velbits-7), $c
        MEND

explosdata
        explos  -40 ,  -8, 70           ; vx, vy, counter
        explos  -50,  60, 60
        explos   40,  48, 70
        explos   50, -10, 65
        explos    0, -60, 80

shiprebirth     *       81              ; minimum no of cycles before ship rebirth

cycles_newship  *       32              ; rock cycles for replacing ship lookahead
cycles_hyperspace  *    3               ; rock cycles for hyperspace

;............................................................................

mv_shipexplos   ROUT
        SUBS    localvar,localvar,#1    ; drift until timeout occurs
        MOVEQ   R1,#shf_unused

        MOV     PC,LR

;............................................................................

; After an initial timeout period, display "New game" and wait for space

mv_newgame      ROUT
        CMP     localvar,#0
        SUBNES  localvar,localvar,#1
        MOVNE   PC,LR

        Push    "LR"

        LDR     R14,gameoverflag         ; displayed "New game" yet?
        CMP     R14,#game_inprogress
        MOVEQ   R14,#game_finished
        STREQ   R14,gameoverflag
        BLEQ    gameovercoords           ; gameovericon+i_bbx0.. = coords (centred in window)
        BLEQ    forceredraw_gameover

        Pull    "PC"

;............................................................................

; In    [windowstate] indicates which window to redraw
; Out   Wimp_ForceRedraw called as appropriate, and Wimp_Poll enabled

forceredraw_gameover ROUT
        Push    "R0-R4,LR"

        LDR     R14,windowstate
        CMP     R14,#state_inwimp
        MOVNE   R14,#state_goingfull    ; want Wimp_Poll's for a while
        STRNE   R14,windowstate
        LDREQ   R0,h_Arena
        LDRNE   R0,h_FullArena
        ADR     R14,gameovericon+i_bbx0
        LDMIA   R14,{R1-R4}
        SWI     XWimp_ForceRedraw

        Pull    "R0-R4,PC",VC,^         ; must preserve flags for processkey
        STRVS   R0,[sp]
        Pull    "R0-R4,PC"

;............................................................................

; In    R0 = window handle (h_Arena or h_FullArena)
; Out   gamovericon coords set up (centred on current window posn)

gameovercoords  ROUT
        Push    "R1-R8,LR"

        LDR     R14,windowstate
        CMP     R14,#state_inwimp
        LDREQ   R0,h_Arena
        LDRNE   R0,h_FullArena
        ASSERT  u_windowstate = 4*9
        Push    "R0-R8"
        MOV     R1,sp
        SWI     XWimp_GetWindowState
        STRVS   R0,[sp]
        Pull    "R0-R8"

        SUB     R7,R3,R1                ; R7 = width of window
        SUB     R8,R4,R2                ; R8 = height of window

        ADR     R14,gameovericon + i_bbx0
        LDMVCIA R14,{R1-R4}
        SUB     R3,R3,R1                ; R3 = width of icon
        SUB     R4,R4,R2                ; R4 = height of icon

        MOV     R1,R7,ASR #1            ; R1,R2 = 1/2 width,height
        MOV     R2,R8,ASR #1
        SUB     R1,R1,R3,ASR #1         ; subtract 1/2 icon width,height
        SUB     R2,R2,R4,ASR #1
        ADD     R1,R1,R5                ; add scroll offsets
        ADD     R2,R2,R6
        SUB     R2,R2,R8                ; (scroll rel. to top-left)

        ADD     R3,R1,R3                ; R3,R4 = other coords
        ADD     R4,R2,R4

        LDR     R5,log2px
        MOV     R1,R1,ASR R5            ; round R1 downwards
        MOV     R1,R1,LSL R5
        SUB     R3,R3,#1                ; round R3 upwards
        MOV     R3,R3,ASR R5
        ADD     R3,R3,#1
        MOV     R3,R3,LSL R5

        STMVCIA R14,{R1-R4}             ; put back in icon

        Pull    "R1-R8,PC",,^

;............................................................................

; After an initial timeout period,
; wait till there are no asteroids intersecting the area round the ship
; Improved method:
;       Draw imaginary line between current roid posn and n cycles later
;       Use recursive algorithm to see if this intersects ship/roid box
;
; In    R1,x0,y0,x1,y1,localvar set up
; Out   ship re-created if the timeout has passed and there is enough space

mv_creator      ROUT
        Push    "LR"

        CMP     localvar,#0
        SUBNES  localvar,localvar,#1

        BLEQ    clevercollision_withrocks

        MOVEQ   R1,#shtype_ship0        ; create new ship
        MOVEQ   localvar,#0             ; localvar = 2 * ship shape

        LDREQ   R0,nships               ; decrement number remaining
        SUBEQ   R0,R0,#1
        BLEQ    setships                ; display ships remaining

        Pull    "PC"

;............................................................................

; In    R1 = number of cycles to look ahead
; Out   NE => a rock will hit the ship within that number of cycles

clevercollision_withrocks
        Push    "R0-R2,LR"

        LDR     R0,qstart+4*roidQ       ; R0 -> first object to scan
        LDR     R2,qstart+4*roidQ+4     ; R2 -> one after last object
        MOV     R1,#cycles_newship      ; R1 = no of cycles to look ahead for
01      BL      clevercollision         ; no collision if object null
        Pull    "R0-R2,PC",NE           ; collision - it's not safe
        ADD     R0,R0,#sh_size
        CMP     R0,R2
        BNE     %BT01

        Pull    "R0-R2,PC"              ; EQ => no collision

;............................................................................

; In    R0 -> object under consideration
;       R1 = number of cycles to look ahead for
;       x0,y0 = position of ship (when it comes back)
; Out   NE => collision within 32 cycles

clevercollision ROUT
        Push    "R1-R3,xx0,yy0,x0,y0,x1,y1,xco,yco,LR"

        LDR     R14,[R0,#sh_type]
        TEQ     R14,#shf_unused         ; note TEQ not TST
        Pull    "R1-R3,xx0,yy0,x0,y0,x1,y1,xco,yco,PC",EQ     ; miss

        ADRL    R3,objectsizes
        ADD     R14,R3,R14,LSL #4
        ASSERT  shtype_ship0 = 0
        LDMIA   R3,{xx0,yy0,x1,y1}      ; ship box
        ADD     xx0,xx0,x0,ASR #velbits
        ADD     yy0,yy0,y0,ASR #velbits
        ADD     xx1,xx0,x1
        ADD     yy1,yy0,y1              ; xx0,yy0,xx1,yy1 = box

        ASSERT  x1 > yy1
        ASSERT  xco > y1
        LDMIA   R14,{x1,y1,xco,yco}     ; roid box
        ADD     xco,x1,xco
        ADD     yco,y1,yco
        SUB     xx0,xx0,xco             ; x0' = x0 - X1
        SUB     yy0,yy0,yco             ; y0' = y0 - Y1
        SUB     xx1,xx1,x1              ; etc.
        SUB     yy1,yy1,y1              ; xx0,yy0,xx1,yy1 = combined box

        ASSERT  x1 > yy1
        ASSERT  xco > y1
        ASSERT  sh_xco = 4
        LDMIB   R0,{x1,y1,yco,R14}      ; yco,R14 = xv, yv
        MLA     xco,yco,R1,x1
        MLA     yco,R14,R1,y1           ; xco,yco = position R1 cycles later

        Debug   ln,"Target object x0,y0,x1,y1 =",xx0,yy0,xx1,yy1
        Debug   ln,"Target line x0,y0,x1,y1 =",x1,y1,xco,yco

        BL      islineinbox             ; returns NE => hit, EQ => miss

      [ debugxx
        BEQ     %FT01
        Debug   ln,"Hit!"
        B       %FT02
01
        Debug   ln,"Miss"
02
      ]

        Pull    "R1-R3,xx0,yy0,x0,y0,x1,y1,xco,yco,PC"

;............................................................................

; In    xx0,yy0,xx1,yy1 = box to consider (pixels)
;       x1,y1 to xco,yco = line to consider (pixels << velbits)
; Out   NE => line intersects, EQ => line doesn't intersect

islineinbox     ROUT
        Push    "x1,y1,xco,yco,LR"

islineinbox_tailrecurse
        MOV     R14,#0                   ; R14 = indicator
        CMP     xx0,x1,ASR #velbits
        ADDGT   R14,R14,#1
        CMP     xx1,x1,ASR #velbits
        ADDLT   R14,R14,#2
        CMP     yy0,y1,ASR #velbits
        ADDGT   R14,R14,#3
        CMP     yy1,y1,ASR #velbits
        ADDLT   R14,R14,#6

        CMP     xx0,xco,ASR #velbits
        ADDGT   R14,R14,#1 * 9
        CMP     xx1,xco,ASR #velbits
        ADDLT   R14,R14,#2 * 9
        CMP     yy0,yco,ASR #velbits
        ADDGT   R14,R14,#3 * 9
        CMP     yy1,yco,ASR #velbits
        ADDLT   R14,R14,#6 * 9

        Debug   ln,"  Line x0,y0,x1,y1,flag =",x1,y1,xco,yco,R14

        ADD     PC,PC,R14,LSL #2         ; jump!
        DCD     0

jumpt2
        GBLA    count1x
        GBLA    count1y
        GBLA    count2x
        GBLA    count2y

count1y SETA    0
        WHILE   count1y < 3
count1x SETA    0
        WHILE   count1x < 3
count2y SETA    0
        WHILE   count2y < 3
count2x SETA    0
        WHILE   count2x < 3
     [ (count2x=0 :LAND: count2y=0) :LOR: (count1x=0 :LAND: count1y=0)
        B       clever_hit
     |
      [ (count2x<>0 :LAND: count2x=count1x) :LOR: (count2y<>0 :LAND: count2y=count1y)
        B       clever_miss
      |
        B       clever_recurse
      ]
     ]
count2x SETA    count2x+1
        WEND
count2y SETA    count2y+1
        WEND
count1x SETA    count1x+1
        WEND
count1y SETA    count1y+1
        WEND
        ASSERT  (.-jumpt2) = 9 * 9 * 4

clever_hit
        TEQ     PC,#0                   ; unset Z
        Pull    "x1,y1,xco,yco,PC"

clever_miss
        TEQ     R0,R0                   ; set Z
        Pull    "x1,y1,xco,yco,PC"

clever_recurse
        Push    "x1,y1"
        ADD     R14,x1,xco
        MOV     x1,R14,ASR #1
        ADD     R14,y1,yco
        MOV     y1,R14,ASR #1           ; x1,y1 := midpoint of line
        BL      islineinbox
        MOV     xco,x1
        MOV     yco,y1                  ; xco,yco := midpoint of line
        Pull    "x1,y1"
        BEQ     islineinbox_tailrecurse ; don't push/pull registers
        Pull    "x1,y1,xco,yco,PC"      ; hit!

;............................................................................

mv_roid         ROUT
        MOV     PC,LR                   ; just drift at constant velocity

;............................................................................

mv_bullet       ROUT
        Push    "LR"

        BL      tryhitroid              ; bullets kill asteroids
        MOVNE   R1,#shf_unused
        BLNE    killroid

        SUBEQS  localvar,localvar,#1    ; or just run out of steam
        MOVEQ   R1,#shf_unused

        Pull    "PC"

;............................................................................

mv_spaceship    ROUT
        MOV     PC,LR                   ; not yet implemented

;............................................................................

; In    R0 -> object entry of relevant asteroid
;       we assume that any children can be allocated just afterwards

killroid        ROUT
        Push    "R0,R1,x0,y0,x1,y1,xco,yco,LR"

        ASSERT  sh_type = 0
        LDMIA   R0,{R1,x0,y0,x1,y1}

        SUB     R14,R1,#shtype_roid0
        ADR     R0,score_roids
        LDR     R0,[R0,R14,LSL #2]
        BL      addscore
        STRVS   R0,[sp]
        Pull    "R0,R1,x0,y0,x1,y1,xco,yco,PC",VS

        LDR     R0,[sp]                 ; recover object pointer

        ADD     R1,R1,#1
        TEQ     R1,#shtype_roid2 + 1
        MOVEQ   R1,#shf_unused
        Push    "x1,y1"
        BLNE    rndveladd
        ADDNE   x1,x1,xco
        ADDNE   y1,y1,yco
        STMIA   R0,{R1,x0,y0,x1,y1}
        Pull    "x1,y1"
        Pull    "R0,R1,x0,y0,x1,y1,xco,yco,PC",EQ,^

        TEQ     R1,#shtype_roid1
        ASSERT  sh_type = 0
        LDREQ   R14,[R0,#sh_size * 2]!
        LDRNE   R14,[R0,#sh_size]!
        STR     R14,[R0,#sh_oldtype]
        MOV     R14,#0
        STR     R14,[R0,#sh_localvar]
        SUB     x1,x1,xco
        SUB     y1,y1,yco
        STMIA   R0,{R1,x0,y0,x1,y1}

        Pull    "R0,R1,x0,y0,x1,y1,xco,yco,PC",,^

score_roids     DCD     20,50,100

;............................................................................

; Out   xco,yco = velocity difference for new rocks

rndveladd       ROUT
        Push    "R0,LR"

        LDR     R0,maxsplitv
        BL      random
        LDR     R14,minsplitv
        ADD     xco,R14,R0
        TST     R0,#1
        RSBNE   xco,xco,#1

        LDR     R0,maxsplitv
        BL      random
        LDR     R14,minsplitv
        ADD     yco,R14,R0
        TST     R0,#1
        RSBNE   yco,yco,#1

        Pull    "R0,PC",,^

;............................................................................

; In    R1,x0,y0,x1,y1 = data for current object
; Out   Z set   => R0 -> index of asteroid which was hit
;       Z unset => R0 corrupt

tryhitroid      ROUT
        Push    "LR"

        LDR     R0,qstart+4*roidQ       ; R0 = pointer to target object
01      BL      collision               ; R1,x0,y0 = position of this object
        Pull    "PC",NE
        ADD     R0,R0,#sh_size
        LDR     R14,qstart+4*roidQ+4
        CMP     R0,R14
        BNE     %BT01

        Pull    "PC"                    ; Z set => no collision

;............................................................................

; In    R1, x0,y0,x1,y1 = object type, x,y, xv,yv
;       R0 -> other object to compare with
; Out   Z unset => objects collide

        ASSERT  xx1 = x0
        ASSERT  yy1 = y0

collision       ROUT
        Push    "R0-R3,xx0,yy0,x0,y0,x1,y1,xco,yco,LR"

        ADD     xco,x0,x1               ; get future coordinate
        ADD     yco,y0,y1
;
; get bounding box of current object (pixels)
;
        ADRL    R3,objectsizes
        ADD     R14,R3,R1,LSL #4        ; R3 -> objectsizes
        LDMIA   R14,{x0,y0,x1,y1}
        ADD     xco,x0,xco,ASR #velbits ; xco,yco = new posn (pixels)
        ADD     yco,y0,yco,ASR #velbits ; x1,y1 = size of object (pixels)
;
; get bounding box of target object (pixels)
;
        LDMIA   R0,{R0,R1,R2}           ; forget it if shape null
        TST     R0,#shf_unused
        BNE     miss

        Push    "R0"                    ; used later

        ADD     R14,R3,R0,LSL #4        ; R3 -> objectsizes
        LDMIA   R14,{xx0,yy0,xx1,yy1}
        ADD     xx0,xx0,R1,ASR #velbits ; xx0,yy0 = lower-left (pixels)
        ADD     yy0,yy0,R2,ASR #velbits

        Debug   cc,"Current object x0,y0,xs,ys =",xco,yco,x1,y1
        Debug   cc,"Target object x0,y0,xs,ys =",xx0,yy0,xx1,yy1
;
; assuming that wrap size >= 2 * max object size,
; we only need to deal with one wrap state (depends on relative posns)
;
        LDR     R1,wrapxpixels
        LDR     R2,wrapypixels

        SUBS    xx0,xx0,xco             ; make relative to other object:
        ADDLT   xx0,xx0,R1

        SUBS    yy0,yy0,yco             ; xx0,yy0 = lower-left (inclusive)
        ADDLT   yy0,yy0,R2

        ADD     xx1,xx0,xx1             ; xx1,yy1 = upper-right (exclusive)
        CMP     xx1,R1
        SUBGT   xx0,xx0,R1              ; wrap to other side
        SUBGT   xx1,xx1,R1

        ADD     yy1,yy0,yy1
        CMP     yy1,R2
        SUBGT   yy0,yy0,R2              ; wrap to other side
        SUBGT   yy1,yy1,R2
;
; compute intersection of (0,0,x1,y1) and (xx0,yy0,xx1,yy1)
;
        MOV     xco,xx0                 ; keep upper-left point of target
        MOV     yco,yy1

        CMP     xx0,#0
        MOVLT   xx0,#0
        CMP     yy0,#0
        MOVLT   yy0,#0
        CMP     xx1,x1
        MOVGT   xx1,x1
        CMP     yy1,y1
        MOVGT   yy1,y1

        Debug   cc,"Intersection is",xx0,yy0,xx1,yy1

        Pull    "R0"                    ; R0,R1 = shape types
        LDR     R1,[sp,#1*4]

        CMP     xx0,xx1
        CMPLT   yy0,yy1
        CMPGE   xx0,xx0                 ; set Z => no hit
        Pull    "R0-R3,xx0,yy0,x0,y0,x1,y1,xco,yco,PC",EQ
;
; intersection is non-null - check whether both objects are non-rectangular
;
        CMP     R0,#shtype_creator
        CMPNE   R1,#shtype_creator
        TOGPSR  Z_bit,R14
        Pull    "R0-R3,xx0,yy0,x0,y0,x1,y1,xco,yco,PC",NE   ; Z unset => hit
;
; if either shape is non-rectangular, we must compare the bitmap data
;
        SUB     y1,y1,yy1               ; y1 = word offset in shape 1
        SUB     yco,yco,yy1             ; yco = word offset in shape 2
        SUB     yy1,yy1,yy0             ; yy1 = number of words to do

        Debug   cc,"Box hit: skip1, skip2, nwords =",y1,yco,yy1

        ADRL    R2,hitshapes
        LDR     R1,[R2,R1,LSL #2]
        ADD     R1,R2,R1                ; R1 -> shape 1 data
        LDR     R0,[R2,R0,LSL #2]
        ADD     R0,R2,R0                ; R0 -> shape 2 data
;
; decide which direction to shift the data in (depends on leftmost shape)
;
        CMP     xco,#0
        BLT     %FT02

        LDR     R2,[R1,y1,LSL #2]!      ; R2 = first word in shape 1
        LDR     R3,[R0,yco,LSL #2]!     ; R3 = first word in shape 2
01      TST     R3,R2,LSR xco
        BNE     hit                     ; on exit Z unset => hit
        SUBS    yy1,yy1,#1
        LDRNE   R2,[R1,#4]!
        LDRNE   R3,[R0,#4]!
        BNE     %BT01                   ; on exit Z set => no hit

        Pull    "R0-R3,xx0,yy0,x0,y0,x1,y1,xco,yco,PC"

02      RSB     xco,xco,#0
        LDR     R2,[R1,y1,LSL #2]!      ; R2 = first word in shape 1
        LDR     R3,[R0,yco,LSL #2]!     ; R3 = first word in shape 2
03      TST     R2,R3,LSR xco
        BNE     hit                     ; on exit Z unset => hit
        SUBS    yy1,yy1,#1
        LDRNE   R2,[R1,#4]!
        LDRNE   R3,[R0,#4]!
        BNE     %BT03                   ; on exit Z set => no hit
hit
        Pull    "R0-R3,xx0,yy0,x0,y0,x1,y1,xco,yco,PC"
miss
        TEQ     R0,R0                   ; set Z
        Pull    "R0-R3,xx0,yy0,x0,y0,x1,y1,xco,yco,PC"

;............................................................................

inkey           ROUT
        Push    "R1,R2,LR"

        MOV     R1,R0
        MOV     R2,#&FF
        MOV     R0,#&81
        SWI     XOS_Byte
        TEQ     R1,#0

        Pull    "R1,R2,PC"

;............................................................................

; Out   R0 = key code (as returned from Wimp_Poll in event_keypressed)
;       R0 = -1 (MI) => no key pressed

inkey0          ROUT
        Push    "R1,R2,LR"

        MOV     R0,#&81
        MOV     R1,#0
        MOV     R2,#0
        SWI     XOS_Byte                ; on exit R0 = key code

        ORR     R0,R1,R2,LSL #8
        MOV     R0,R0,LSL #16
        MOVS    R0,R0,ASR #16           ; -1 => no key press
        Pull    "R1,R2,PC",NE

        MOV     R0,#&81                 ; 0 should be followed by another code
        MOV     R1,#0
        MOV     R2,#0
        SWI     XOS_Byte                ; on exit R0 = key code

        ORRS    R0,R1,#&100             ; return with &100 added (cf. Wimp)
        Pull    "R1,R2,PC"

;;---------------------------------------------------------------------------
;; Update object table onto the screen
;;---------------------------------------------------------------------------

; Entry:  roidtable contains object definitions
;         objects to be moved have different type,xco,yco/oldtype,oldxco,oldyco
; Exit:   relevant objects updated in window, old coords := current

update_objects  ROUT
        Push    "LR"
;
; call Wimp_UpdateWindow for the whole window, then scan the list of objects
; if the update bit of the type is set, undraw / redraw the object
;
        LDR     R14,windowstate
        CMP     R14,#state_inwimp
        LDREQ   R0,h_Arena
        LDRNE   R0,h_FullArena

        ADR     R1,userdata
        MOV     x0,#-bignum
        MOV     y0,#-bignum
        MOV     x1,#bignum
        MOV     y1,#bignum
        STMIA   R1,{R0,x0,y0,x1,y1}
        SWI     XWimp_UpdateWindow
        BLVC    getwrap
11
        Pull    "PC",VS

        TEQ     R0,#0
        BEQ     %FT22

        BL      getgraf

        LDR     R0,qstart
        LDR     R2,qstart + 4*numqueues
01
        LDMIA   R0,{R1,xco,yco}                 ; R1 = new shape type
        Push    "x0,x1,y1"
        ADD     R14,R0,#sh_oldtype
        LDMIA   R14,{x0,x1,y1}                  ; x0,x1,y1 = old type/x/y
        TEQ     x0,R1
        TEQEQ   x1,xco
        TEQEQ   y1,yco
        Pull    "x0,x1,y1"
        BEQ     %FT02                           ; same - don't bother updating

        TST     R1,#shf_unused
        BLEQ    plotroid                        ; plot in new position
        ADD     R14,R0,#sh_oldtype
        LDMIA   R14,{R1,xco,yco}
        TST     R1,#shf_unused
        BLEQ    plotroid
02
        ADD     R0,R0,#sh_size
        CMP     R0,R2
        BNE     %BT01

        ADR     R1,userdata
        SWI     XWimp_GetRectangle
        B       %BT11

; now go through the table, copying current coords into old coords

22      LDR     R0,qstart
        LDR     R2,qstart + 4*numqueues
01
        ASSERT  sh_type = 0
        LDMIA   R0,{R1,xco,yco}
        ADD     R14,R0,#sh_oldtype
        STMIA   R14,{R1,xco,yco}        ; update 'old' position

        ADD     R0,R0,#sh_size
        CMP     R0,R2
        BNE     %BT01

        Pull    "PC"

;;---------------------------------------------------------------------------
;; Redraw_Window
;;---------------------------------------------------------------------------

redraw_window   ROUT
        Push    "LR"
;
        SWI     XWimp_RedrawWindow
        Pull    "PC",VS
;
        LDR     R2,[R1,#u_handle]
        LDR     R14,h_Arena
        TEQ     R2,R14
        LDRNE   R14,h_FullArena
        TEQNE   R2,R14
        BEQ     redraw_arena
        LDR     R14,h_Scores
        TEQ     R2,R14
        BEQ     redraw_scores
01
        TEQ     R0,#0                   ; go through this loop just in case
        Pull    "PC",EQ
        SWI     XWimp_GetRectangle
        BVC     %BT01
        Pull    "PC"

; redraw any active objects

redraw_arena    ROUT
        TEQ     R0,#0
        Pull    "PC",EQ

        BL      getgraf
        BL      getwrap

        Push    "R1"

; first redraw the "Game over" sign (if relevant)

        LDR     R14,gameoverflag
        CMP     R14,#game_finished
        LDREQ   R0,[R1,#u_handle]
        ADREQ   R1,gameovericon
        SWIEQ   XWimp_PlotIcon

; redraw all objects

        LDR     R0,qstart
        LDR     R2,qstart + 4*numqueues
01
        LDR     R14,[R0,#sh_oldtype]!
        TST     R14,#shf_unused
        LDMEQIA R0,{R1,xco,yco}
        BLEQ    plotroid
        ADD     R0,R0,#sh_size - sh_oldtype
        CMP     R0,R2
        BNE     %BT01

        Pull    "R1"

        SWI     XWimp_GetRectangle
        BVC     redraw_arena
        Pull    "PC"

; redraw current score and number of lives

redraw_scores   ROUT
        TEQ     R0,#0
        Pull    "PC",EQ

        BL      draw_scores

        SWIVC   XWimp_GetRectangle
        BVC     redraw_scores
        Pull    "PC"

; In    R1 -> redraw/update block for this window and rectangle
; Out   score redrawn in this rectangle

draw_scores     ROUT
        Push    "R1,R2,x0,y0,x1,y1,scx,scy,LR"

        ASSERT  i_size = 32
        ADR     R1,shipicon+16
        LDMIA   R1,{x0,y0,x1,y1}        ; boring stuff
        Push    "x0,y0,x1,y1"
        SUB     sp,sp,#16
        MOV     R1,sp                   ; R1 -> block (on stack)

        LDR     R0,nships
        BL      getshipsbbox            ; x0,y0,x1,y1 = coords of box

        LDR     scx,shipicon+i_bbx1
        LDR     R14,shipicon+i_bbx0
        SUB     scx,scx,R14             ; scx = width of 1 ship
        LDR     scy,nships              ; scy = number of ships
        CMP     scy,#0
        BLE     %FT02                   ; watch for 0 ships
01
        ADD     x1,x0,scx
        STMIA   R1,{x0,y0,x1,y1}
        SWI     XWimp_PlotIcon
        BVS     %FT02
        MOV     x0,x1
        SUBS    scy,scy,#1
        BNE     %BT01
02
        ADD     sp,sp,#i_size

        Pull    "R1,R2,x0,y0,x1,y1,scx,scy,PC"

;............................................................................

; In    R0 = amount to add to score
; Out   score added in and display updated

addscore        ROUT
        Push    "LR"
        LDR     R14,score
        ADD     R0,R14,R0
        Pull    "LR"            ; drop through

setscore        ROUT
        Push    "R1,LR"

        STR     R0,score
        MOV     R1,#scoreicon_handle
        BL      update_icon_numberstring

        LDR     R1,extramanscore
        LDR     R0,score
        CMP     R0,R1
        LDRHS   R14,extramanevery
        ADDHS   R1,R1,R14
        STRHS   R1,extramanscore
        LDRHS   R0,nships
        ADDHS   R0,R0,#1
        BLHS    setships                        ; extra man!

        Pull    "R1,PC"

extramanevery   DCD     10000

;............................................................................

; In    R0 = new sheet number

setsheet        ROUT
        Push    "R1,LR"

        STR     R0,nsheet
        MOV     R1,#sheeticon_handle
        BL      update_icon_numberstring

        Pull    "R1,PC"

;............................................................................

; In    R0 = new number of ships

setships        ROUT
        Push    "R1-R2,x0,y0,x1,y1,LR"

        LDR     R2,nships                       ; previous value
        STR     R0,nships

        CMP     R0,R2
        MOVLT   R0,R2                   ; R0 = max(current,previous)

        BL      getshipsbbox            ; gets x0,y0,x1,y1 from R0

        LDR     R0,h_Scores
        ADR     R1,userdata
        STMIA   R1,{R0,x0,y0,x1,y1}
        SWI     XWimp_UpdateWindow

01      TEQ     R0,#0                   ; doesn't affect V
        BEQ     %FT99

        MOVVC   R0,#&87                 ; assume colour 7 background
        SWIVC   XWimp_SetColour
        SWIVC   XOS_WriteI+16
        BLVC    draw_scores

        SWIVC   XWimp_GetRectangle
        BVC     %BT01
99
        Pull    "R1-R2,x0,y0,x1,y1,PC"

;............................................................................

; In    R0 = number of ships
; Out   x0,y0,x1,y1 = bounding box of all the ships (window-relative)

getshipsbbox    ROUT
        Push    "LR"

        ADR     R14,shipicon
        LDMIA   R14,{x0,y0,x1,y1}       ; window-relative

        SUB     x1,x1,x0                ; x1 = width of sprite
        ADD     x0,x0,x1,ASR #1         ; x0 = coord of middle
        MUL     R2,x1,R0                ; R2 = total width
        SUB     x0,x0,R2,ASR #1
        ADD     x1,x0,R2                ; x0,y0,x1,y1 = bbox

        Pull    "PC"

;............................................................................

; In    R0 = numeric value to set
;       R1 = icon handle (in h_Scores)
; Out   icon's buffer contents set to string equivalent of number
;       icon updated on screen (using Wimp_SetIconState)

update_icon_numberstring ROUT
        Push    "R0-R9,LR"

        LDR     R0,h_Scores
        ASSERT  i_size+8 = 4*10
        Push    "R0-R9"                 ; put buffer on stack
        MOV     R1,sp
        SWI     XWimp_GetIconState
        LDR     R1,[sp,#8+i_data+0]     ; R1 -> buffer
        LDR     R2,[sp,#8+i_data+8]     ; R2 = length
        ADD     sp,sp,#8+i_size

        LDRVC   R0,[sp]                 ; R0 = numeric value
        SWIVC   XOS_ConvertCardinal4

        LDRVC   R0,h_Scores
        LDRVC   R1,[sp,#4]
        MOVVC   R2,#0
        MOVVC   R3,#0
        Push    "R0-R3"
        MOVVC   R1,sp
        SWIVC   XWimp_SetIconState
        ADD     sp,sp,#4*4
99
        STRVS   R0,[sp]
        Pull    "R0-R9,PC"

;----------------------------------------------------------------------------

; Entry:  R1,xco,yco = asteroid type, x,y
; Calls internal routine with:
;       In:   addr        = pointer to current word (computed from xco,yco)
;             mask        = bitmask for current pixel
;             bpp         = bits per pixel
;             linelength  = bytes in one row on the screen
;             xco,yco     = x,y coordinates << velbits
;             x0,y0,x1,y1 = wrap x0,y0,x1,y1
;             [colour]    = colour to plot shape in
;             [grafx0]..  = graphics window coords << velbits
;       Uses: temp, LR

plotroid        ROUT
        Push    "R0-R5,LR"

      [ debugxx
        MOV     R0,#&37
        SWI     XWimp_SetColour
        MOV     R0,#4
        MOV     R1,xco,ASR #velbits-2
        MOV     R2,yco,ASR #velbits-2
        SWI     XOS_Plot
        LDR     R0,[sp]                 ; assume R0 -> object defn
        LDR     R1,[R0,#sh_xvel]
        LDR     R2,[R0,#sh_yvel]
        ADD     R1,xco,R1,LSL #5
        MOV     R1,R1,ASR #velbits-2
        ADD     R2,yco,R2,LSL #5
        MOV     R2,R2,ASR #velbits-2
        MOV     R0,#5
        SWI     XOS_Plot
        LDMIA   sp,{R0-R2}
      ]

        ADR     R14,wrapx0
        LDMIA   R14,{x0,y0,x1,y1}
        BL      wrapcoords
        LDR     bpp,BPP
        LDR     linelength,linelen
        BL      getaddr

        LDR     R0,[sp,#4]
        LDR     R14,colour_ship
        ASSERT  shtype_ship0 < shtype_roid0
        CMP     R0,#shtype_roid0
        LDRCS   R14,colour_roids
        TEQ     R0,#shtype_bullet
        LDREQ   R14,colour_bullet
        CMP     R0,#shtype_explos0
        LDRGE   R14,colour_ship
        STR     R14,colour

        ADRL    temp,Routines
        LDR     R0,[temp,R0,LSL #2]
        ADR     LR,%FT01
        ADD     PC,temp,R0
01
        Pull    "R0-R5,PC",,^

;----------------------------------------------------------------------------

;  Entry:  R1 --> window state block
;  Exit:   x0,y0,x1,y1 = graf x0,y0,x1,y1

getgraf         ROUT
        Push    "LR"

        ADD     R14,R1,#u_gwx0
        LDMIA   R14,{x0,y0,x1,y1}       ; get graf x0,y0,x1,y1
        LDR     R14,log2px
        MOV     x0,x0,ASR R14
        MOV     x1,x1,ASR R14
        LDR     R14,log2py
        MOV     y0,y0,ASR R14
        MOV     y1,y1,ASR R14
        MOV     x0,x0,LSL #velbits
        MOV     y0,y0,LSL #velbits
        MOV     x1,x1,LSL #velbits
        MOV     y1,y1,LSL #velbits
        SUB     x1,x1,#1                ; make inclusive
        SUB     y1,y1,#1                ; make inclusive
        ADR     R14,grafx0
        STMIA   R14,{x0,y0,x1,y1}

        Pull    "PC"

;----------------------------------------------------------------------------

;  Entry:  R1 --> window state block
;  Exit:   x0,y0,x1,y1 = wrap x0,y0,x1,y1
;          xco,yco = origin of window (internal coords)

getwrap         ROUT
        Push    "LR"

        ADD     R14,R1,#u_wax0
        LDMIA   R14,{x0,y0,x1,y1,scx,scy}       ; get wrap x0,y0,x1,y1
        SUB     xco,x0,scx                      ; xco,yco = window origin
        SUB     yco,y1,scy
        LDR     R14,scoreheight
        SUB     y1,y1,R14                       ; skip scores

        LDR     R14,log2px
        MOV     xco,xco,ASR R14
        MOV     x0,x0,ASR R14
        MOV     x1,x1,ASR R14

        LDR     R14,log2py
        MOV     yco,yco,ASR R14
        MOV     y0,y0,ASR R14
        MOV     y1,y1,ASR R14

        MOV     xco,xco,LSL #velbits            ; convert to internal coords
        MOV     yco,yco,LSL #velbits

        SUB     R14,x1,x0                       ; used in collision code
        STR     R14,wrapxpixels
        SUB     R14,y1,y0
        STR     R14,wrapypixels

        MOV     x0,x0,LSL #velbits              ; convert to internal coords
        MOV     y0,y0,LSL #velbits
        MOV     x1,x1,LSL #velbits
        MOV     y1,y1,LSL #velbits
        ADR     R14,wrapx0
        STMIA   R14,{x0,y0,x1,y1}

        Pull    "PC"


;;---------------------------------------------------------------------------
;; Game code
;;---------------------------------------------------------------------------

mv1     Move    L,U
mv2     Move     ,U
mv3     Move    R,U
mv4     Move    L,
mv5     Move
mv6     Move    R,
mv7     Move    L,D
mv8     Move     ,D
mv9     Move    R,D
mv10    Move    L,U,P
mv11    Move     ,U,P
mv12    Move    R,U,P
mv13    Move    L, ,P
mv14    Move     , ,P
mv15    Move    R, ,P
mv16    Move    L,D,P
mv17    Move     ,D,P
mv18    Move    R,D,P

;----------------------------------------------------------------------------

qsizes  DCB     shipO
        DCB     roidO
        DCB     bulletO
        DCB     spaceO
        DCB     spcbulletO
        DCB     shipexplosO

        ASSERT  (.-qsizes) = numqueues
        ALIGN

; Clear the whole roidtable to null, except for the spaceship itself

setqueues       ROUT
        Push    "R0-R5,LR"

; Set up queue pointers (qstart array is constant thereafter)

        MOV     R0,#sh_size             ; R0 = size of an object entry
        MOV     R1,#numqueues           ; R1 = number of queues
        ADR     R2,qsizes               ; R2 -> array of queue sizes
        ADR     R3,qcurrent             ; R3 -> array of current pointers
        ADR     R4,qstart               ; R4 -> array of start pointers
        ADR     R5,roidtable            ; R5 -> object table
01
        STR     R5,[R3],#4              ; R3 -> qcurrent array
        STR     R5,[R4],#4              ; R4 -> qstart array
        LDRB    R14,[R2],#1             ; R14 = number of items in queue
        MLA     R5,R14,R0,R5            ; R5 -> start of next queue
        SUBS    R1,R1,#1
        BNE     %BT01
        STR     R5,[R4]                 ; address of end of queues

; now fill all positions with null objects

        LDR     R0,qstart
        LDR     R2,qstart + 4*numqueues
        MOV     R1,#shf_unused
02
        STR     R1,[R0,#sh_oldtype]
        ASSERT  sh_type = 0
        STR     R1,[R0],#sh_size
        CMP     R0,R2
        BLO     %BT02

        Pull    "R0-R5,PC"

;----------------------------------------------------------------------------

; Start afresh - note that current objects may be in existence
;                so we must leave the old shapes alone

newgame         ROUT
        Push    "R1,x0,y0,x1,y1,localvar,LR"

; create a plausible-looking ship object

        BL      newshipcoords           ; sets up x0,y0 in middle of screen
                                        ; with x1,y1 = 0
        MOV     R1,#shtype_ship0
        MOV     localvar,#0             ; shape no * 2

        LDR     R0,qstart + 4*shipQ
        STMIA   R0,{R1,x0,y0,x1,y1,localvar}
        ASSERT  shipQ=0
        ADD     R0,R0,#sh_size

; wipe out 'current' position of all objects, so they'll be removed

        LDR     R2,qstart + 4*numqueues
        MOV     R1,#shf_unused
        MOV     x0,#0
        MOV     y0,#0
        MOV     x1,#0
        MOV     y1,#0
        MOV     localvar,#0
01
        STMIA   R0,{R1,x0,y0,x1,y1,localvar}
        ADD     R0,R0,#sh_size
        CMP     R0,R2
        BCC     %BT01

; initialise global variables

        LDR     R14,extramanevery
        STR     R14,extramanscore

        MOV     R14,#4         ; number of roids on first sheet
        STR     R14,newsheetroids

        MOV     R14,#init_minsplitv
        STR     R14,minsplitv

        MOV     R14,#init_maxsplitv
        STR     R14,maxsplitv

        MOV     R14,#init_minv
        STR     R14,minv

        MOV     R14,#init_maxv
        STR     R14,maxv

        MOV     R0,#3 - 1               ; 2 ships on the top, 1 on screen
        BL      setships

        MOV     R0,#0
        BL      setscore                ; must redraw display

        MOV     R0,#0                   ; updated by newsheet
        STR     R0,nsheet
        STR     R0,canhyperspace        ; must wait till space released

        MOV     R14,#game_inprogress    ; go!
        STR     R14,gameoverflag

        Pull    "R1,x0,y0,x1,y1,localvar,PC"

;............................................................................

; In    wrapx0,y0,x1,y1 = coords determined from window size
; Out   x0,y0 = initial coords of ship
;       x1,y1 = 0

newshipcoords   ROUT
        Push    "LR"

        ADR     R14,wrapx0
        LDMIA   R14,{x0,y0,x1,y1}
        ADD     x0,x0,x1
        ADD     y0,y0,y1
        MOV     x0,x0,ASR #1
        MOV     y0,y0,ASR #1            ; put spaceship in centre
        MOV     x1,#0
        MOV     y1,#0

        Pull    "PC"

;----------------------------------------------------------------------------

; Generate a new sheet-worth of asteroids

newsheet        ROUT
        Push    "R0-R11,LR"

        MOV     R14,#0                  ; not waiting for a new sheet any more!
        STR     R14,newsheetwait

        LDR     R0,nsheet
        ADD     R0,R0,#1
        BL      setsheet                ; increment sheet number

; increment parameters for sheet

        LDR     R14,minsplitv
        ADD     R14,R14,#add_minsplitv
        STR     R14,minsplitv

        LDR     R14,maxsplitv
        ADD     R14,R14,#add_maxsplitv
        STR     R14,maxsplitv

        LDR     R14,minv
        ADD     R14,R14,#add_minv
        STR     R14,minv

        LDR     R14,maxv
        ADD     R14,R14,#add_maxv
        STR     R14,maxv

        LDR     R2,newsheetroids
        CMP     R2,#numroids/4
        ADDLT   R14,R2,#1
        STRLT   R14,newsheetroids

; wipe out existing rocks (just in case)

        LDR     R0,qstart+4*roidQ
        LDR     R1,qstart+4*roidQ+4
        MOV     R14,#shf_unused
10
        ASSERT  sh_type=0
        STR     R14,[R0],#sh_size
        CMP     R0,R1
        BLO     %BT10

; now create new rocks

        MOV     R0,#numroids
        DivRem  R1,R0,R2, R14           ; R0 = desirable gap
        CMP     R1,#4
        MOVLT   R1,#4                   ; min gap = 4
        MOV     R14,#sh_size
        MUL     R0,R1,R14               ; R0 = gap between items
01
        ADR     R14,wrapx0
        LDMIA   R14,{x0,y0,x1,y1}

        Push    "R0"

        MOV     R0,#2
        BL      random                  ; 0 => left edge, 1=> bottom edge

        TEQ     R0,#0
        SUBEQ   R0,x1,x0
        SUBNE   R0,y1,y0
        BL      random                  ; must preserve flags
        ADDEQ   x0,x0,R0
        ADDNE   y0,y0,R0                ; put rocks at the edges

        BL      rndvel                  ; with random velocities
        MOV     x1,R0
        BL      rndvel
        MOV     y1,R0

        Pull    "R0"

        MOV     R1,#shtype_roid0        ; R1,x0,y0,x1,y1 = properties
        BL      create_roid

        SUBS    R2,R2,#1
        BNE     %BT01

        Pull    "R0-R11,PC",,^

;............................................................................

rndvel          ROUT
        Push    "LR"
        LDR     R0,maxv
        BL      random
        LDR     R14,minv
        ADD     R0,R0,R14
        TST     R0,#1
        RSBNE   R0,R0,#0
        Pull    "PC",,^

;----------------------------------------------------------------------------

; In    R0 = queue number to create object in
;       R1,x0,y0,x1,y1,localvar = values to give to object
; Out   Z set => object could not be allocated

create_object   ROUT
        Push    "R0,R2,R3,LR"

        ADR     R3,qstart
        LDR     R2,[R3,R0,LSL #2]!      ; R2 -> start of queue
        LDR     R3,[R3,#4]              ; R3 -> start of next queue
        MOV     R0,#sh_size
        BL      trycreate

        Pull    "R0,R2,R3,PC"

;............................................................................

; In    R0 = gap to use between attempts
;       R1,x0,y0,x1,y1 = object type, x,y, xvelocity, yvelocity
; Out   object allocated in roidtable (with gaps of 4 if possible)
;       Z set if object could not be created

create_roid     ROUT
        Push    "R0-R3,localvar,LR"

        LDR     R2,qstart + 4*roidQ
        LDR     R3,qstart + 4*roidQ+4
        MOV     localvar,#0
        BL      trycreate               ; to leave room for children

        Pull    "R0-R3,localvar,PC"

;............................................................................

; In    R0 = gap between attempts
;       R2,R3 -> start and finish of relevant queue
;       R1,x0,y0,x1,y1,localvar = properties to give to object
; Out   R0,R2,R3 corrupted
;       Z set => object could not be allocated

trycreate       ROUT
        Push    "LR"
01
        LDR     R14,[R2,#sh_type]       ; get current type
        TST     R14,#shf_unused
   ;;     LDRNE   R14,[R2,#sh_oldtype]    ; old type must also be null
   ;;     TSTNE   R14,#shf_unused        ;; NOT ANY MORE !!!
        BNE     %FT02
        ADD     R2,R2,R0
        CMP     R2,R3
        BNE     %BT01
        Pull    "PC"                    ; Z set => not allocated
02
        STMIA   R2,{R1,x0,y0,x1,y1,localvar}
        Pull    "PC"                    ; Z unset => allocated

;----------------------------------------------------------------------------

; Entry:  xco,yco     = coords
;         x0,y0,x1,y1 = wrap coords
; Exit:   xco,yco     = coords (within x0,y0,x1,y1)

wrapcoords      ROUT
        Push    "temp,LR"

01      SUBS    temp,xco,x1
        ADDGE   xco,x0,temp
        BGE     %BT01
01      SUBS    temp,xco,x0
        ADDLT   xco,x1,temp
        BLT     %BT01
01      SUBS    temp,yco,y1
        ADDGE   yco,y0,temp
        BGE     %BT01
01      SUBS    temp,yco,y0
        ADDLT   yco,y1,temp
        BLT     %BT01

        Pull    "temp,PC",,^

;----------------------------------------------------------------------------

; Entry:  xco,yco       = coords
;         linelength    = line length
;         bpp           = bits per pixel
;         [screenstart] = start address of screen
;         [ywindlimit]  = max y coord on screen
; Exit:   addr,mask     = equivalent position

getaddr         ROUT
        Push    "LR"

        LDR     temp,ywindlimit
        SUB     temp,temp,yco,ASR #velbits
        LDR     addr,screenstart
        MLA     addr,temp,linelength,addr
        MOV     temp,xco,ASR #velbits
        LDR     R14,log2bpc
        MOV     temp,temp,LSL R14
        AND     mask,temp,#31
        MOV     temp,temp,LSR #5
        ADD     addr,addr,temp,LSL #2
        MVN     temp,#0
        MOV     mask,temp,LSL mask
        BIC     mask,mask,mask,LSL bpp

        Pull    "PC"

;----------------------------------------------------------------------------

; Entry:  R0 = range
; Exit:   R0 = random number from 0..range-1

random          ROUT
        Push    "R1,R2,LR"

        MOV     R1,R0
        LDR     R0,seed
        EOR     R14,R0,R0,LSL #3
        MOV     R14,R14,LSL #9
        MOV     R14,R14,LSR #24
        ORR     R0,R14,R0,LSL #8
        STR     R0,seed
        DivRem  R2,R0,R1, R14

        Pull    "R1,R2,PC",,^


;;---------------------------------------------------------------------------
;; Neil's debugging routines
;;---------------------------------------------------------------------------

      [ debug
        InsertNDRDebugRoutines
      ]

;;---------------------------------------------------------------------------
;; Shape data generated by GenSrc
;;---------------------------------------------------------------------------

        GET     s.MetShapes

Module_EndAddr

        END
