/************************************************************************/
/* File:    timefunc.c                                                  */
/* Purpose: Declares the functions used to grab the date and time for   */
/*          the log entries.                                            */
/* Author:  Hed Simons (mailto:hsimons@acorn.com)                       */
/* History: Fri 19th September 1997  ver 0.01 - Created.                */
/*          Mon 17th November  1997  ver 0.04 - Added null handle (HKS) */
/************************************************************************/

/* Need the time library to decode the time entries */
#include <time.h>
#include <stdio.h>

#include "include.h"
#include "globals.h"
#include "recordlib.h"
#include "texthandle.h"
#include "messhandle.h"
#include "timefunc.h"
#include "main.h"

#define  HOUR24	1
#define	 HOUR12 0
#define	 YEAR2	0
#define	 YEAR4  1

/*----------------------------------------------------------------------*/

/*******************************************************************************
 * Name	       : decode_date_and_time                                          *
 * Parameters  : DecLogEntry *, EncLogEntry *                                  *
 * Description : Takes the encoded log entry and rips the first word (time_t)  *
 *	         which it decodes into a date and time format. It then         *
 *	         shoves this into the decoded log entry                        *
 * Returns     : Nothing                                                       *
 *******************************************************************************/
void decode_date_and_time(DecLogEntry *decode_entry, EncLogEntry *encode_entry)
{
  time_t	temp_time;
  struct tm	*decoded_time;
  int		year, hours, mins, secs;
  #if HOUR12
  char		am_pm_code;
  #endif

  /* Grab the time in the entry and decode into tm format */
  temp_time = encode_entry->time;
  decoded_time = localtime(&temp_time);

  year = decoded_time->tm_year;

  #if YEAR2
    /* Create a date string in format: month/day/year */
  if (year > 99)
    year -= 100;

  sprintf(decode_entry->date, "%02d/%02d/%02d", (decoded_time->tm_mon + 1),
  		decoded_time->tm_mday, year);
  #endif

  #if YEAR4
    /* Create a date string in format: month/day/4_digit_year */
    year = 1900 + decoded_time->tm_year;
    sprintf(decode_entry->date, "%02d/%02d/%d", (decoded_time->tm_mon + 1),
    		decoded_time->tm_mday, year);
  #endif


  /* Create a time string in format: hours:mins<a><p>\0 */
  hours = decoded_time->tm_hour;
  mins = decoded_time->tm_min;
  secs = decoded_time->tm_sec;

  #if HOUR12
    if (hours == 12)
 	am_pm_code = 'p';
    else if (hours == 24)
    {
    	hours = 12;
    	am_pm_code = 'a';
    }
    else if (hours > 12)
    {
  	hours -= 12;
  	am_pm_code = 'p';
    }
    else
  	am_pm_code = 'a';

    sprintf(decode_entry->time, "%d:%02d:%02d%c", hours, mins, secs, am_pm_code);
  #endif

  #if HOUR24
    sprintf(decode_entry->time, "%02d:%02d:%02d", hours, mins, secs);
  #endif

  /*if (mins < 10)
  	sprintf(decode_entry->time, "%d:0%d%c", hours, mins,
  		am_pm_code);
  else
  	sprintf(decode_entry->time, "%d:%d%c", hours, mins,
  		am_pm_code);*/
}

/*******************************************************************************
 * Name        : time_null_handler                                             *
 * Parameters  : Standard toolbox event handler                                *
 * Description : Catches the NULL poll event and then uses it to check for     *
 *               several conditions. Will clear the log file if the time       *
 *               is correct. Will also send the 'HELLO' message to DaytSetup   *
 *               until it receives a response                                  *
 * Returns     : Nothing                                                       *
 *******************************************************************************/
int time_null_handler(int event_code, WimpPollBlock *event, IdBlock *id_block,
			void *handle)
{
  struct tm		*time_test;
  time_t		timer;
  int			hours, mins, hours2, day;
  char			temp_str[3];
  Dayt_SendHello	send_message;
  DayLog_SendLog        send_log_message;


  /* Call the UI lib null poll handler */
  ui_pollword_handler(event_code, event, id_block, handle);

  /* Convert our symbols into integers */
  temp_str[0] = purge_time[0]; temp_str[1] = purge_time[1]; temp_str[2] = '\0';
  hours = atoi(temp_str);
  temp_str[0] = purge_time[2]; temp_str[1] = purge_time[3]; temp_str[2] = '\0';
  mins = atoi(temp_str);

  /* Now setup for a twice daily purge */
  if (hours < 12)
  	hours2 = hours + 12;
  else
  	hours2 = hours - 12;


  /* Now check them against the current time */
  timer = time(&timer);
  time_test = localtime(&timer);


  /* If this is a once or twice daily purge, and a timed log... */
  if (((purge_period == 1) || (purge_period == 2)) && (log_type == Timed))
  {
    /* Set the purge flag one min before the purge takes place */
    if ((hours == time_test->tm_hour) && (mins == (time_test->tm_min - 1)) && (purge_reset == FALSE))
    {
        dprintf(("", "Purge reset\n"));
  	time_purged = FALSE;
  	purge_reset = TRUE;
    }

    /* Do the same incase of twice daily purge */
    if (((hours2 == time_test->tm_hour) && (mins == (time_test->tm_min - 1)) && (purge_reset == FALSE)) &&
    	(purge_period == 2))
    {
        dprintf(("", "Purge reset\n"));
      	time_purged = FALSE;
      	purge_reset = TRUE;
    }

    /* Now if this is the right hour (once or twice daily)... */
    if ((hours == time_test->tm_hour) || ((hours2 == time_test->tm_hour) && (purge_period == 2)))
    {
      /* If this is/passed the right minute, purge! */
      if ((time_test->tm_min == mins) && (time_purged == FALSE))
      {
        dprintf(("", "Purging!!!\n"));

        if ((email_purge == TRUE) || (print_purge == TRUE))
        {
          send_log_message.Hdr.size = sizeof(DayLog_SendLog);
          send_log_message.Hdr.your_ref = 0;
          send_log_message.Hdr.action_code = DayLog_SendMail;
          strcpy(send_log_message.data.email_address, log_destination);

          /* Check which type of purge this is */
          if ((email_purge == TRUE) && (print_purge == TRUE))
          {
            dprintf(("", "Timed : Print and Email pruge\n"));
            send_log_message.data.send_methods = Email_Bit | Print_Bit;
          }
          else if (email_purge == TRUE)
          {
            dprintf(("", "Times : Email purge\n"));
            send_log_message.data.send_methods = Email_Bit;
          }
          else
          {
            dprintf(("", "Times : Print purge \n"));
            send_log_message.data.send_methods = Print_Bit;
          }

          wimp_send_message(Wimp_EUserMessage, (WimpMessage*)&send_log_message, 0, 0, NULL);

          time_purged = TRUE;
          purged = FALSE;
        }
        /* Else just go ahead and delete that sucker */
        else
        {
    	  top_record = 0;
    	  record_destroyall();
    	  time_purged = TRUE;
    	  purge_reset = FALSE;
          write_multiple_records();
	}
      }
    }
  }

  /* If this is a once weekly purge... */
  if ((purge_period == 3) && (log_type == Timed))
  {
    /* Get the day */
    day = time_test->tm_wday;

    if (purge_day == 7)
      purge_day = 0;

    /* Set the purge flag one hour before the purge takes place */
    if ((hours == time_test->tm_hour) && (mins == (time_test->tm_min - 1)) && (purge_reset == FALSE))
    {
  	time_purged = FALSE;
  	purge_reset = TRUE;
    }

    if ((day == purge_day) && (hours == time_test->tm_hour))
    {
      /* If this is/passed the right minute, purge! */
      if ((time_test->tm_min == mins) && (time_purged == FALSE))
      {
        /* Are the Email or Print purge flags set? If so, we want to do the appropriate email/print
           before we clear it */
        if ((email_purge == TRUE) || (print_purge == TRUE))
        {
          send_log_message.Hdr.size = sizeof(DayLog_SendLog);
          send_log_message.Hdr.your_ref = 0;
          send_log_message.Hdr.action_code = DayLog_SendMail;
          strcpy(send_log_message.data.email_address, log_destination);

          /* Check which type of purge this is */
          if ((email_purge == TRUE) && (print_purge == TRUE))
          {
            dprintf(("", "Timed : Print and Email pruge\n"));
            send_log_message.data.send_methods = Email_Bit | Print_Bit;
          }
          else if (email_purge == TRUE)
          {
            dprintf(("", "Times : Email purge\n"));
            send_log_message.data.send_methods = Email_Bit;
          }
          else
          {
            dprintf(("", "Times : Print purge \n"));
            send_log_message.data.send_methods = Print_Bit;
          }

          wimp_send_message(Wimp_EUserMessage, (WimpMessage*)&send_log_message, 0, 0, NULL);

          time_purged = TRUE;
          purged = FALSE;
        }
        /* Else just go ahead and delete that sucker */
        else
        {
    	  top_record = 0;
          record_destroyall();
    	  write_multiple_records();
    	  time_purged = TRUE;
    	  purge_reset = FALSE;
        }
      }
    }
  }

  if (registered != TRUE)
  {
    send_message.Hdr.size = sizeof(Dayt_SendHello);
    send_message.Hdr.your_ref = 0;
    send_message.Hdr.action_code = Dayt_Setup_Message;
    send_message.data.message_code = Setup_Message_Hello;
    wimp_send_message(Wimp_EUserMessage, (WimpMessage*)&send_message, 0, 0, NULL);
  }

  /* And that should be it! */
  return (TRUE);
}
