/************************************************************************/
/* File:    tokencode.c                                                 */
/* Purpose: Declares the functions used to code and decode the log      */
/*          entries into tokenised form.                                */
/* Author:  Hed Simons (mailto:hsimons@acorn.com)                       */
/* History: Thu 25th September 1997  ver 0.01 - Created.                */
/*          Mon 17th November  1997  ver 0.12 - Now uses _new_entry to  */
/*                                    decode the parameterised entries  */
/************************************************************************/

/* Include the relevant libraries */
#include <string.h>
#include <stdio.h>

#include "include.h"
#include "main.h"
#include "miscwimp.h"
#include "misc.h"
#include "tokencode.h"

/*----------------------------------------------------------------------*/

void tokencode_convert_token(char *token_in, char *token_out)
{
  if (token_in[0] == '_')
    /* Look up the token string and return it in token_out */
    strcpy(token_out, misc_lookup_message_token(&token_in[1]));
  else
    strcpy(token_out, token_in);
  /* IE. if subpart[0] is not a token, then we just send that to the
  	log and stop looking, as no parameterisation will occur */
}



void tokencode_decode_new_entry(char *entry_in, char *entry_out)
{
  char	sub_strings[5][255];
  char	out_strings[5][255];
  char	final[255];
  char	byte;
  int	index = 0, sub = 0, make_index = 0, loop;

  /* We need to split the string into several sub-parts:
  	Each sub-part is separated by a '|'
  	Sub-parts can be constant values or tokens
   */

  /* While we haven't scanned the entire string... */
  while (index < strlen(entry_in))
  {
    /* Reset the make index and get the first byte */
    make_index = 0;
    byte = entry_in[index];
    /* While haven't encountered a separator or end of string*/
    while ((byte != '|') && (byte != '\0'))
    {
      /* Copy into the substringa and go on one step */
      sub_strings[sub][make_index] = byte;
      make_index++;
      index++;
      byte = entry_in[index];
    }
    /* Add the NULL terminator and update the indexes */
    sub_strings[sub][make_index] = '\0';
    sub++;
    index++;
  }

  for (loop = 0; loop < 5; loop++)
  	out_strings[loop][0] = '\0';

  /* Now convert them into the relevant tokens */
  for (loop = 1; loop < sub; loop++)
	tokencode_convert_token(sub_strings[loop], out_strings[loop]);

  /* If the basestring was *not* a token, we simply print this and
     discard the rest of the parameters. Else we shove them in
     accordingly - do I have great language abilities, or what? */
  if (sub_strings[0][0] != '_')
  {
    tokencode_convert_token(sub_strings[0], out_strings[0]);
    strcpy(final, out_strings[0]);
  }
  else
  {
    /* Go through the number of sub strings apart from the base string
       we have and substitue them in */
    strcpy(out_strings[0], &sub_strings[0][1]);
    misc_create_final_string(out_strings[0], out_strings[1], out_strings[2],
    			out_strings[3], out_strings[4], final);
  }

  strcpy(entry_out, final);
}


