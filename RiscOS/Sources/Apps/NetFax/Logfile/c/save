/************************************************************************/
/* File:    save.c                                                      */
/* Purpose: Handles data saving to Flash                                */
/*                                                                      */
/* Author:  Neil Bingham (mailto:NBingham@acorn.co.uk)                  */
/* History: Wed 27th August 1997    ver 0.01 - Created.                 */
/*          Thu 18th December 1997  ver 0.09 - Done loads to it by now! */
/************************************************************************/

#include <string.h>

/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "main.h"
#include "functions.h"
#include "flashlib.h"
#include "messhandle.h"
#include "misc.h"
#include "scheduler.h"
#include "ui.h"
#include "save.h"

extern void optdate_set_clock(char, int, int, int, int, int, int);
extern void save_all_settings(void);

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

/* Defines whether this is the final compiled version or not. If not, don't muck about with the
   development machines DNS routing, thankyou very much */
#define FINAL 0

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/*
 * Name        : save_swi_call
 * Parameters  : tag string, result buffer, sizeof(buffer)
 * Description : Uses the SFConfigMan calls to save a takenised value to flash
 * Returns     : Appropriate error code
 */
int save_swi_call(char *tag, char *result_buffer, int buffer_size)
{
  _kernel_oserror	*er;
  _kernel_swi_regs	regs;

  /* Load in the values given, call the SWI and return the error code */
  regs.r[0] = (int)tag;
  regs.r[1] = (int)result_buffer;
  regs.r[2] = buffer_size;
  er = _kernel_swi(SFConfigMan_Write, &regs, &regs);

  return regs.r[0];
}

/*
 * Name        : save_create_inet
 * Parameters  : input string, length of string
 * Description : Takes the DNS string entered in setup and converts this into upto 3 words
 *		 containing this information
 * Returns     : Nothing
 */
void save_create_inet(char *string_in, int length)
{
  char	dns_strings[3][20];
  char	final_strings[3][20];
  char	dns_save[20];
  int	index = 0, make_index = 0, now_string = 0, num_strings = 0, loop, error;
  char	byte;

  /* Clear the three DNS Strings */
  for (loop = 0; loop < 3; loop++)
    strcpy(dns_strings[loop], "");

  /* Split the string into three sub-strings of form : 1.2.3.4 */
  byte = string_in[index];
  while ((byte != '\0') && (index < length))
  {
    while ((byte != ' ') && (index < length))
    {
      dns_strings[now_string][make_index] = byte;
      make_index++;
      index++;
      byte = string_in[index];
    }
    dns_strings[now_string][make_index] = '\0';
    make_index = 0;
    now_string++;

    num_strings++;

    index++;
    byte = string_in[index];
    dprintf(("", "Byte, index : '%c', %d\n", byte, index));
  }

  /* Now split each sub-string into the four number in the IP string and decode into a character */
  for (loop = 0; loop < 3; loop++)
  {
    dprintf(("", "DNS String : %s\n", dns_strings[loop]));

    if (dns_strings[loop][0] != '\0')
      save_cis(dns_strings[loop], final_strings[loop]);
    else
      strcpy(final_strings[loop], "\0\0\0\0");

    dprintf(("", "Output String Bytes : %d.%d.%d.%d\n", final_strings[loop][0],
    	final_strings[loop][1], final_strings[loop][2], final_strings[loop][3]));

    sprintf(dns_save, "DNSServer%d", (loop+1));
    error = save_swi_call(dns_save, final_strings[loop], 0);
  }
}

/*
 * Name        : save_cis
 * Parameters  : input string, output string
 * Description : Slave function for save_create_inet
 * Returns     : Nothing
 */
void save_cis(char *in_string, char *out_string)
{
  char	temp_string[20];
  int	index = 0, make_index = 0, main_index = 0;
  char	byte;

  /* We want to go through a DNS string and turn it into a four character string */
  byte = in_string[index];
  while (byte != '\0')
  {
    if (byte == '.')
    {
      /* Turn the temporary string into a character */
      temp_string[make_index] = '\0';
      out_string[main_index] = atoi(temp_string);
      dprintf(("", "os: %d\n", out_string[main_index]));
      index++;
      main_index++;
      make_index = 0;
      byte = in_string[index];
    }
    else
    {
      temp_string[make_index] = byte;
      make_index++;
      index++;
      byte = in_string[index];
    }
  }
  temp_string[make_index] = '\0';
  out_string[main_index] = atoi(temp_string);
  dprintf(("", "os: %d\n", out_string[main_index]));
  out_string[index] = '\0';
}

/*
 * Name        : save_create_login
 * Parameters  : type integer, result buffer, login string, response string
 * Description : Compacts a pair of login/response strings into an encoded form
 * Returns     : Nothing
 */
void save_create_login_ext(int input, char *result, char *log_string, char *res_string)
{
  /* If ordainary login/response strings... */
  if (input == 0)
  {
    strcat(result, log_string);
    strcat(result, "\n");
    strcat(result, res_string);
    strcat(result, "\n");
  }
  /* Else if username string */
  else if (input == 1)
  {
    strcat(result, log_string);
    strcat(result, "\n");
    strcat(result, "send_user");
    strcat(result, "\n");
  }
  /* Else is password string */
  else
  {
    strcat(result, log_string);
    strcat(result, "\n");
    strcat(result, "send_pass");
    strcat(result, "\n");
  }
}

/*
 * Name        : save_create_login
 * Parameters  : None
 * Description : Compacts a pair of login/response strings into an encoded form
 * Returns     : Nothing
 */
int save_create_login(void)
{
  _kernel_oserror	*er;
  int			error, switch_value, nbytes;
  char			log_buffer[255], res_buffer[255];
  char			make_string[255];

  /* Initialise the login-response string */
  strcpy(make_string, "");

  /* Now grab all the fields */
  er = writablefield_get_value(0, OptISP2_WindowHandle, optisp2_login_prompt1, log_buffer, sizeof(log_buffer), &nbytes);
  misc_error_check(er);
  er = writablefield_get_value(0, OptISP2_WindowHandle, optisp2_login_response1, res_buffer, sizeof(res_buffer), &nbytes);
  misc_error_check(er);
  switch_value = misc_tag_lookup(OptISP2_WindowHandle, optisp2_switch1_string, "OptISP2_LoginField");
  save_create_login_ext(switch_value, make_string, log_buffer, res_buffer);

  er = writablefield_get_value(0, OptISP2_WindowHandle, optisp2_login_prompt2, log_buffer, sizeof(log_buffer), &nbytes);
  misc_error_check(er);
  er = writablefield_get_value(0, OptISP2_WindowHandle, optisp2_login_response2, res_buffer, sizeof(res_buffer), &nbytes);
  misc_error_check(er);
  switch_value = misc_tag_lookup(OptISP2_WindowHandle, optisp2_switch2_string, "OptISP2_LoginField");
  save_create_login_ext(switch_value, make_string, log_buffer, res_buffer);

  er = writablefield_get_value(0, OptISP2_WindowHandle, optisp2_login_prompt3, log_buffer, sizeof(log_buffer), &nbytes);
  misc_error_check(er);
  er = writablefield_get_value(0, OptISP2_WindowHandle, optisp2_login_response3, res_buffer, sizeof(res_buffer), &nbytes);
  misc_error_check(er);
  switch_value = misc_tag_lookup(OptISP2_WindowHandle, optisp2_switch3_string, "OptISP2_LoginField");
  save_create_login_ext(switch_value, make_string, log_buffer, res_buffer);

  er = writablefield_get_value(0, OptISP2_WindowHandle, optisp2_login_prompt4, log_buffer, sizeof(log_buffer), &nbytes);
  misc_error_check(er);
  er = writablefield_get_value(0, OptISP2_WindowHandle, optisp2_login_response4, res_buffer, sizeof(res_buffer), &nbytes);
  misc_error_check(er);
  switch_value = misc_tag_lookup(OptISP2_WindowHandle, optisp2_switch4_string, "OptISP2_LoginField");
  save_create_login_ext(switch_value, make_string, log_buffer, res_buffer);

  er = writablefield_get_value(0, OptISP2_WindowHandle, optisp2_login_prompt5, log_buffer, sizeof(log_buffer), &nbytes);
  misc_error_check(er);
  er = writablefield_get_value(0, OptISP2_WindowHandle, optisp2_login_response5, res_buffer, sizeof(res_buffer), &nbytes);
  misc_error_check(er);
  switch_value = misc_tag_lookup(OptISP2_WindowHandle, optisp2_switch5_string, "OptISP2_LoginField");
  save_create_login_ext(switch_value, make_string, log_buffer, res_buffer);

  dprintf(("", "String is:%s\n", make_string));

  if (strlen(make_string) > 255)
  {
    dprintf(("", "Oh deary me, the string's too long!\n"));

    /* We need to tell the user that the total login/response script lengths are *waaaaay* too long */
    /*er = ui_confirm_window("OptISP1_Error_Title", "OptISP1_Error_Message", NULL, NULL, "confirm_1", runes_confirm);
    misc_error_check(er);*/
    runes_login_confirm(ConfirmAction_Start);
    return FALSE;
  }
  else
    error = save_swi_call("ResponseString", make_string, strlen(make_string));

  return TRUE;
}

/*
 * Name        : save_user_settings
 * Parameters  : None
 * Description : Saves the settings from the user window
 * Returns     : Nothing
 */
void save_user_settings(void)
{
  _kernel_oserror	*er;
  int			nbytes, error, flag;
  char			buffer[255];

  /* Company name */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_company_name, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("CompanyName", buffer, strlen(buffer));

  /* Contact name */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_user_name, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("ContactName", buffer, strlen(buffer));

  /* Fax Country Code */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_fax_country, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("FaxCountryCode", buffer, strlen(buffer));

  /* Fax Area Code */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_fax_area_code, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("FaxAreaCode", buffer, strlen(buffer));

  /* Fax Number */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_fax_number, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("FaxNumber", buffer, strlen(buffer));

  /* Voice Country Code */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_voice_country, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("VoiceCountryCode", buffer, strlen(buffer));

  /* Voice Area Code */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_voice_area_code, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("VoiceAreaCode", buffer, strlen(buffer));

  /* Voice Number */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_voice_number, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("VoiceNumber", buffer, strlen(buffer));

  /* Default routing */
  er = button_get_value(0, OptUser_WindowHandle, optuser_txstring, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  flag = misc_tag_lookup(OptUser_WindowHandle, optuser_txstring, "OptUser_Tx");
  dprintf(("", "save flag is : %d\n", flag));
  error = save_swi_call("DefaultRoute", (char *)&flag, 0);

  /* External Access Code */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_external_access_code, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("OutsideLineCode", buffer, 1);

  /* International Access Code */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_international_access_code, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("InternationalAccessCode", buffer, strlen(buffer));

  /* National Access Code */
  er = writablefield_get_value(0, OptUser_WindowHandle, optuser_national_access_code, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  error = save_swi_call("NationalAccessCode", buffer, strlen(buffer));
}

/*
 * Name        : save_datetime_settings
 * Parameters  : None
 * Description : Saves the settings from the date/time window
 * Returns     : Nothing
 */
void save_datetime_settings(void)
{
  _kernel_oserror	*er;
  char			buffer[255], oscli_string[255];
  int			nbytes, int_value, error, time_zone;

  /* Timezone string */
  er = button_get_value(0, OptDate_WindowHandle, optdate_toffset_string, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  int_value = misc_lookup_timezone();
  time_zone = int_value;
  error = save_swi_call("TimeZone", (char *)&int_value, 0);

  /* Finally set the time and date */
  if (time_window_opened == 1)
  	optdate_set_clock('S', 0, 0, 0, 0, 0, 0);

  dprintf(("", "Timezone is : %d\n", time_zone));
  sprintf(buffer, "%d\0", time_zone);
  strcpy(oscli_string, "co. timezone");
  strcat(oscli_string, buffer);
  _kernel_oscli(oscli_string);
}

/*
 * Name        : save_isp1_settings
 * Parameters  : None
 * Description : Saves the settings from the ISP window
 * Returns     : Nothing
 */
void save_isp1_settings(void)
{
  _kernel_oserror	*er;
  _kernel_swi_regs      regs;
  char			buffer[255], temp_string[255];
  char                  copy_name[255], new_name[255];
  int			nbytes, int_value, error, flag, login_bool;
  FILE			*f_point;

  /* Dialup number string */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_dialup_string, buffer, sizeof(buffer),
                               &nbytes);
  misc_error_check(er);
  error = save_swi_call("PrimaryPhone", buffer, strlen(buffer));

  /* Dialup retry string */
  er = button_get_value(0, OptISP1_WindowHandle, optisp1_dialupretry_string, buffer, sizeof(buffer),
                           &nbytes);
  misc_error_check(er);
  int_value = atoi(buffer);
  error = save_swi_call("PrimaryRedial", (char *)&int_value, 4);

  /* Alternate number string */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_alternate_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  error = save_swi_call("SecondaryPhone", buffer, strlen(buffer));

  /* Alternate retry string */
  er = button_get_value(0, OptISP1_WindowHandle, optisp1_alternateretry_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  int_value = atoi(buffer);
  error = save_swi_call("SecondaryRedial", (char *)&int_value, 4);

  /* SMTP server string */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_smtpserver_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  error = save_swi_call("SMTPHost", buffer, strlen(buffer));

  /* POP3 server string */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_pop3server_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  error = save_swi_call("POP3Host", buffer, strlen(buffer));

  /* POP3 email string */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_pop3email_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  error = save_swi_call("POP3mailbox", buffer, strlen(buffer));

  /* POP3 username string */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_pop3username_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  error = save_swi_call("POP3UserId", buffer, strlen(buffer));

  /* POP3 password string */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_pop3password_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  error = save_swi_call("POP3Password", buffer, strlen(buffer));

  /* ISP username */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_ispusername_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  error = save_swi_call("UserId", buffer, strlen(buffer));
  #if FINAL
    sprintf(temp_string, "name %s", buffer);
    _kernel_setenv("Inet$PPPOptions", temp_string);
  #endif

  /* ISP password */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_isppassword_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  error = save_swi_call("Password", buffer, strlen(buffer));

  /* Shared mailbox string */
  /*er = button_get_value(0, OptISP1_WindowHandle, optisp_sharedmailbox_string, buffer, sizeof(buffer),
                               &nbytes);
  misc_error_check(er);
  flag = (char)misc_tag_lookup(OptISP1_WindowHandle, optisp_sharedmailbox_string, "Opt_YesNo");
  error = save_swi_call("Shared", (char *)&flag, 0);*/

  /* DNS server string */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_dnsserver_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  strcpy(temp_string, buffer);
  save_create_inet(temp_string, strlen(temp_string));
  #if FINAL
    _kernel_setenv("Inet$Resolvers", buffer);
    _kernel_oscli("ResolverConfig");
  #endif

  /* Local domain string */
  er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_inetlocaldomain_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  error = save_swi_call("LocalHost", buffer, strlen(buffer));
  #if FINAL
    _kernel_setenv("Inet$LocalDomain", buffer);
  #endif

  /* Finally we create a directory 'PPP' in the IneDBase$Path and create a file inside
     called 'CHAPSecret' to store username and password for the PP settings */
  /* Okay, but we also need to be able to say alive in the event of there being no ram */
  f_point = fopen("RAM::RamDisc0.$.Test", "w");

  if (f_point != NULL)
  {
    /* Delete our test file */
    nbytes = fclose(f_point);
    _kernel_oscli("Delete RAM::RamDisc0.$.Test");

    /* Create our new file */
    _kernel_oscli("ram");
    _kernel_oscli("cdir Internet");
    _kernel_oscli("cdir Internet.Files");
    _kernel_oscli("cdir Internet.Files.PPP");
    f_point = fopen("RAM::RamDisc0.$.Internet.Files.PPP.CHAPSecret", "w");
    er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_ispusername_string, buffer, sizeof(buffer),
                                   &nbytes);
    nbytes = fprintf(f_point, "%s", buffer);
    er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_isppassword_string, buffer, sizeof(buffer),
                                   &nbytes);
    nbytes = fprintf(f_point, " * %s\0", buffer);
    nbytes = fclose(f_point);

    /* Now copy this file as PAPSecret for PAP access */
    strcpy(copy_name, "RAM:$.Internet.files.PPP.CHAPSecret");
    strcpy(new_name, "RAM:$.Internet.files.PPP.PAPSecret");
    regs.r[0] = 26;
    regs.r[1] = (int)copy_name;
    regs.r[2] = (int)new_name;
    regs.r[3] = 0;
    _kernel_swi(OS_FSControl, &regs, &regs);
  }
  else
    dprintf(("", "No RAM in which to save settings\n"));
}

/*
 * Name        : save_isp2_settings
 * Parameters  : None
 * Description : Saves the settings from the ISP2 window
 * Returns     : Nothing
 */
int save_isp2_settings(void)
{
  _kernel_oserror	*er;
  _kernel_swi_regs      regs;
  char			buffer[255], temp_string[255];
  char                  copy_name[255], new_name[255];
  int			nbytes, int_value, error, flag, login_bool;
  FILE			*f_point;

  /* Missing pages string */
  er = button_get_value(0, OptISP2_WindowHandle, optisp2_missingpages_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  int_value = atoi(buffer);
  error = save_swi_call("MissingPageConnectionCount", (char *)&int_value, 4);

  /* Connection time string */
  er = button_get_value(0, OptISP2_WindowHandle, optisp2_connectiontime_string, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  int_value = atoi(buffer);
  error = save_swi_call("ConnectionHoldUpTime", (char *)&int_value, 4);

  /* Pages per email string */
  er = button_get_value(0, OptISP2_WindowHandle, optisp2_pagesperemail_string, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  int_value = atoi(buffer);
  error = save_swi_call("PagesPerEmail", (char *)&int_value, 4);

  /* Max mailsize string */
  er = button_get_value(0, OptISP2_WindowHandle, optisp2_maxemailsize_string, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  int_value = atoi(buffer);
  error = save_swi_call("MaxEmailSize", (char *)&int_value, 4);

  /* Logon script prompts and responses */
  login_bool = save_create_login();
}

/*
 * Name        : save_misc_settings
 * Parameters  : None
 * Description : Saves the settings from the misc window
 * Returns     : Nothing
 */
void save_misc_settings(void)
{
  _kernel_oserror	*er;
  char			buffer[255];
  int			int_size, nbytes, error, flag, time_int;


  /* Not A Number string */
  er = writablefield_get_value(0, OptMisc_WindowHandle, optmisc_notanumber_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  error = save_swi_call("NANtoken", buffer, strlen(buffer));
  dprintf(("", "Misc ID : %d\n", OptMisc_WindowHandle));

  /* Capture timeout string */
  er = button_get_value(0, OptMisc_WindowHandle, optmisc_capturetime_string, buffer, sizeof(buffer), &nbytes);
  misc_error_check(er);
  int_size = atoi(buffer);
  error = save_swi_call("CaptureTimeOut", (char *)&int_size, 0);
}

/*
 * Name        : save_log_settings
 * Parameters  : None
 * Description : Saves the settings from the log settings window
 * Returns     : Nothing
 */
void save_log_settings(void)
{
  _kernel_oserror	*er;
  char			buffer[255];
  int			int_size, nbytes, error, flag, time_int;

  /* Logsize string */
  er = button_get_value(0, OptLog_WindowHandle, optlog_logsize_string, buffer, sizeof(buffer),
                               &nbytes);
  misc_error_check(er);
  int_size = atoi(buffer);
  error = save_swi_call("MaximumFileSize", (char *)&int_size, 0);

  /* Purge log after string */
  er = button_get_value(0, OptLog_WindowHandle, optlog_purgeperiod_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  int_size = misc_tag_lookup(OptLog_WindowHandle, optlog_purgeperiod_string, "OptLog_PurgePeriod");
  error = save_swi_call("PurgePeriod", (char *)&int_size, 0);

  /* Time of purge functions, we must make this a 'special' integer */
  /* Hour string */
  er = button_get_value(0, OptLog_WindowHandle, optlog_hour_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  time_int = atoi(buffer) * 100; /* This makes the time something like 2200 */

  /* Minutes string */
  er = button_get_value(0, OptLog_WindowHandle, optlog_minute_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  time_int += atoi(buffer); /* Now it'll be something like 2213 */
  sprintf(buffer, "%d", time_int);
  error = save_swi_call("PurgeTime", buffer, strlen(buffer));

  /* Day string */
  er = button_get_value(0, OptLog_WindowHandle, optlog_day_string, buffer, sizeof(buffer),
                                 &nbytes);
  misc_error_check(er);
  int_size = misc_tag_lookup(OptLog_WindowHandle, optlog_day_string, "OptMisc_Day");
  int_size += 1;  /* An integer between 1 and 7 */
  dprintf(("", "Day : %d\n", int_size));
  error = save_swi_call("PurgeDay", (char *)&int_size, 0);

  /* Print string */
  er = button_get_value(0, OptLog_WindowHandle, optlog_print_string, buffer, sizeof(buffer),
                               &nbytes);
  misc_error_check(er);
  flag = misc_tag_lookup(OptLog_WindowHandle, optlog_print_string, "Opt_YesNo");
  dprintf(("", "Print purge save : %d\n", flag));
  error = save_swi_call("PrintBeforePurge", (char *)&flag, 0);

  /* Email string */
  er = button_get_value(0, OptLog_WindowHandle, optlog_email_string, buffer, sizeof(buffer),
                               &nbytes);
  misc_error_check(er);
  flag = misc_tag_lookup(OptLog_WindowHandle, optlog_email_string, "Opt_YesNo");
  dprintf(("", "Email purge save : %d\n", flag));
  error = save_swi_call("EmailBeforePurge", (char *)&flag, 0);

  /* Admin string */
  er = writablefield_get_value(0, OptLog_WindowHandle, optlog_admin_string, buffer, sizeof(buffer),
  				&nbytes);
  misc_error_check(er);
  error = save_swi_call("Destination", buffer, strlen(buffer));

  dprintf(("", "Saved log options\n"));
}

/*
 * Name        : save_sched_settings
 * Parameters  : None
 * Description : Saves the settings from the scheduler window
 * Returns     : Nothing
 */
void save_sched_settings(void)
{
  _kernel_oserror	*error;
  int	er, nbytes, loop, int_size;
  char	buffer[255], buffer2[255];


  /* Scheduler On/Off */
  error = button_get_value(0, OptSchedule_WindowHandle, optschedule_scheduler_string, buffer, sizeof(buffer), &nbytes);
  misc_error_check(error);
  int_size = misc_tag_lookup(OptSchedule_WindowHandle, optschedule_scheduler_string, "Opt_OnOff");
  sched_on = int_size;
  er = save_swi_call("Scheduler", (char *)&int_size, 0);

  /* Scheduler Week On/Off */
  error = button_get_value(0, OptSchedule_WindowHandle, optschedule_stanweek_string, buffer, sizeof(buffer), &nbytes);
  misc_error_check(error);
  int_size = misc_tag_lookup(OptSchedule_WindowHandle, optschedule_stanweek_string, "Opt_OnOff");
  er = save_swi_call("SchedulerWeek", (char *)&int_size, 0);


  /* Grab the number of dialups for on and off peak */
  error = button_get_value(0, OptSchedule_WindowHandle, optschedule_peakdialup_string, buffer, sizeof(buffer), &nbytes);
  misc_error_check(error);
  error = button_get_value(0, OptSchedule_WindowHandle, optschedule_offdialup_string, buffer2, sizeof(buffer2), &nbytes);
  misc_error_check(error);

  for (loop = 0; loop < 7; loop++)
  {
    sched_num_peak[loop] = atoi(buffer);
    sched_num_off[loop]  = atoi(buffer2);
  }

  /* Dial up periods */
  int_size = atoi(buffer2);
  er = save_swi_call("OffPeakDialUps", (char *)&int_size, 0);
  int_size = atoi(buffer);
  er = save_swi_call("PeakDialUps", (char *)&int_size, 0);

  /* Grab the four times for each day that operate the scheduler */
  /* Monday */
  save_split_scheduler(0, buffer);
  er = save_swi_call("Monday", buffer, 16);

  /* Tuesday */
  save_split_scheduler(1, buffer);
  er = save_swi_call("Tuesday", buffer, 16);

  /* Wednesday */
  save_split_scheduler(2, buffer);
  er = save_swi_call("Wednesday", buffer, 16);

  /* Thursday */
  save_split_scheduler(3, buffer);
  er = save_swi_call("Thursday", buffer, 16);

  /* Friday */
  save_split_scheduler(4, buffer);
  er = save_swi_call("Friday", buffer, 16);

  /* Saturday */
  save_split_scheduler(5, buffer);
  er = save_swi_call("Saturday", buffer, 16);

  /* Sunday */
  save_split_scheduler(6, buffer);
  er = save_swi_call("Sunday", buffer, 16);


  /* Restart the scheduler */

  if (sched_on == TRUE)
  {
    sched_quick_init();

    loaded_scheds = TRUE;
    no_sched_time = TRUE;
  }
}

/*
 * Name        : save_split_scheduler
 * Parameters  : day integer, encoded string
 * Description : Takes the string and produces the idle and peak times for the day specified
 * Returns     : Nothing
 */
void save_split_scheduler(int day, char *buffer)
{
  char	temp_string[10];

  /* The start of peak time */
  sprintf(temp_string, "%02d", HH(sched_start_peak[day]));
  strcpy(buffer, temp_string);
  sprintf(temp_string, "%02d", MM(sched_start_peak[day]));
  strcat(buffer, temp_string);

  /* The end of peak time */
  sprintf(temp_string, "%02d", HH(sched_end_peak[day]));
  strcat(buffer, temp_string);
  sprintf(temp_string, "%02d", MM(sched_end_peak[day]));
  strcat(buffer, temp_string);

  /* The start of idle time */
  sprintf(temp_string, "%02d", HH(sched_start_idle[day]));
  strcat(buffer, temp_string);
  sprintf(temp_string, "%02d", MM(sched_start_idle[day]));
  strcat(buffer, temp_string);

  /* The end of idle time */
  sprintf(temp_string, "%02d", HH(sched_end_idle[day]));
  strcat(buffer, temp_string);
  sprintf(temp_string, "%02d", MM(sched_end_idle[day]));
  strcat(buffer, temp_string);

  //dprintf(("", "Saved day %d is : %s\n", day, buffer));
}

