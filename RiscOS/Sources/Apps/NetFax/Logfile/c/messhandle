/************************************************************************/
/* File:    messhandle.c                                                */
/* Purpose: Includes several vital parts of the application.            */
/*          This includes all of the data structures.                   */
/* Author:  Hed Simons (mailto:hsimons@acorn.com)                       */
/* History: Tue 08th October 1997 ver 0.01 - Created                    */
/*	    Fri 19th December 1997 ver 0.09 - Major additions have been */
/*					made previous two months	*/
/************************************************************************/

#include "messhandle.h"
#include "scheduler.h"
#include "main.h"

#include <time.h>

/*----------------------------------------------------------------------*/

void messhandle_register_application(int task_handle, int task_id)
{
  Dayt_SendBlock	s_message;

  /* Anti-compiler warnings! */
  task_id = task_id;

  dprintf(("", "About to send message to requesting application\n"));

  s_message.Hdr.size = sizeof(Dayt_SendBlock);
  s_message.Hdr.your_ref = 0;
  s_message.Hdr.action_code = Dayt_Setup_Message;
  s_message.data.message_code = General_Hello;
  wimp_send_message(Wimp_EUserMessage, (WimpMessage*)&s_message, 0, 0, &task_handle);
}

void messhandle_option_changed(int message_code)
{
  Dayt_SendBlock	s_message;

  s_message.Hdr.size = sizeof(Dayt_SendBlock);
  s_message.Hdr.your_ref = 0;
  s_message.Hdr.action_code = Dayt_Setup_Message;
  s_message.data.message_code = message_code;
  wimp_send_message(Wimp_EUserMessage, (WimpMessage*)&s_message, 0, 0, NULL);
}

int messhandle_poll_loop(int event_code, WimpPollBlock *event,
				IdBlock *id_block, void *handle)
{
  time_t		the_time;
  Dayt_SendHello	s_message;
  struct tm		*decoded_time;
  int			hour, min, day, sched_hour, sched_min, sched_day;


  /* Do we currently have no defined time for the scheduler to dial up? */
  if ((no_sched_time == TRUE) && (load_cycle == FALSE) && (loaded_scheds == TRUE) && (sched_on == TRUE))
  {
    /* We want to grab the next time, store it as string and set the scheduler
       as having a time to compare */
    next_sched_time = sched_next();

    no_sched_time = FALSE;
  }
  /* Else lets see if the time is right and then send a message to Daytona */
  else if ((sched_on == TRUE) && (load_cycle == FALSE) && (loaded_scheds == TRUE))
  {
    time(&the_time);
    decoded_time = localtime(&the_time);
    day =  decoded_time->tm_wday;
    hour = decoded_time->tm_hour; min = decoded_time->tm_min;

    sched_day  = DD(next_sched_time);
    sched_hour = HH(next_sched_time); sched_min = MM(next_sched_time);

    //dprintf(("", "Next dial up time is : %d at %d:%d\n", sched_day, sched_hour, sched_min));

    /* If the time for the next dialup is the same as the current time AND we
       haven't had an acknowledgement from Daytona, then send a message saying
       it's time for dialup */
    if (((day == sched_day) && (hour == sched_hour) && (min == sched_min))
        && (sched_acked == FALSE))
    {
      /* Send a message to Daytona telling it that the schedule time is here! */
      s_message.Hdr.size = sizeof(Dayt_SendHello);
      s_message.Hdr.your_ref = 0;
      s_message.Hdr.action_code = Dayt_Schedule_Message;
      s_message.data.message_code = 1;
      wimp_send_message(Wimp_EUserMessage, (WimpMessage*)&s_message, 0, 0, 0);

      dprintf(("", "Scheduled dialup time\n"));

      // Debuggy testing - remove after test!
      sched_acked = TRUE;
    }
    else if (((day == sched_day) && (hour == sched_hour) && (min == sched_min))
    		&& (sched_acked == TRUE) && (no_sched_time == FALSE))
    {
      dprintf(("", "Sched acked\n"));
      no_sched_time = TRUE;
    }

  }

  /* Have we updated the options at all? */
  if (update != 0)
  {
      dprintf(("", "Update signature : %d\n", update));
      messhandle_option_changed(update);
      update = 0;
  }


  /* Call the UI lib null poll handler */
  ui_pollword_handler(event_code, event, id_block, handle);

  return 1;

}
