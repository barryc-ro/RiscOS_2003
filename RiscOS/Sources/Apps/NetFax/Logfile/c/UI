/************************************************************************/
/* File:    UI.c                                                        */
/* Purpose: file deals with UI bits and pieces specifically the special */
/*          option system employed in Daytona.                          */
/*                                                                      */
/* Author:  Neil Bingham (mailto:NBingham@acorn.co.uk)                  */
/* History: Tue 18th February 1997  ver 0.01 - Created.                 */
/*          Thu 12th November 1997  ver 0.06 - Big jump in numbers as   */
/*                                             a *lot* of support added */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include <time.h>

#include "main.h"
#include "ui.h"
#include "functions.h"
#include "kernel.h"
#include "misc.h"
#include "scheduler.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */
void optdate_optionfields(int, ComponentId);
void optmisc_optionfields(int, ComponentId);
void optisp_optionfields(int, ComponentId);
void optsched_optionfields(int, ComponentId);
extern void optdate_set_datetime(void);
extern void optdate_set_clock(char, int, int, int, int, int, int);
extern void optdate_get_time_now(struct tm **);
extern int  misc_tag_lookup(ObjectId, ComponentId, char *);
/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/*  Name       : ui_alter_flag
 *  Parameters : window handle and flag value
 *  Purpose    : Fades or unfades a toolbox gadget
 */
void ui_alter_flag(ObjectId object, ComponentId component, unsigned int flaggy)
{
  _kernel_oserror	*er;
  unsigned int 		flag;

    er = gadget_get_flags(0, object, component, &flag);
    if (flaggy == 1)
      flag = flag | Gadget_Faded;
    else
      flag = flag & ~Gadget_Faded;
    er = gadget_set_flags(0, object, component, flag);
}


/*  Name       : ui_update_login
 *  Parameters : window handle and component handle
 *  Purpose    : Alters the login script states
 */
void ui_update_login(ComponentId option, ComponentId component)
{
  _kernel_oserror	*er;
  _kernel_swi_regs	regs;
  int			handle;

  if (misc_tag_lookup(OptISP2_WindowHandle, option, "OptISP2_LoginField") == 1)
  {
    /* Username mode! */
    ui_alter_flag(OptISP2_WindowHandle, component, 1);
    er = writablefield_set_value(0, OptISP2_WindowHandle, component, "ISP Username");
  }
  else if (misc_tag_lookup(OptISP2_WindowHandle, component, "OptISP2_LoginField") == 2)
  {
    /* Password mode! */
    ui_alter_flag(OptISP2_WindowHandle, component, 1);
    er = writablefield_set_value(0, OptISP2_WindowHandle, component, "ISP Password");
  }
  else
  {
    /* Normal mode! */
    ui_alter_flag(OptISP2_WindowHandle, component, 0);
    er = writablefield_set_value(0, OptISP2_WindowHandle, component, "");
  }

  er = window_get_wimp_handle(0, OptISP2_WindowHandle, &handle);
  regs.r[0] = handle;
  regs.r[1] = -1;
  regs.r[2] = 0;
  regs.r[3] = 0;
  regs.r[4] = 1<<25;
  regs.r[5] = 0;
  _kernel_swi(Wimp_SetCaretPosition, &regs, &regs);

}


/************************************************************************/
/* leftcursor_pressed                                                   */
/*                                                                      */
/* Function is called when the left of right arror keys are pressed.    */
/* Action will only be taken if that window has an option field.        */
/*                                                                      */
/* Parameters: ToolboxEventHandler parameters.                          */
/*                                                                      */
/* Returns:    TRUE or FALSE.                                           */
/*                                                                      */
/************************************************************************/
void leftcursor_pressed(void)
{
  _kernel_oserror		*er;
  WimpGetPointerInfoBlock	 pointer_info;
  ComponentId			 comp;
  ObjectId			 obj_name;

  /* In a window with an option field.  Now check to see if Iconhigh is highlighting the
   * clickable button surrounding the field
   */
  er = wimp_get_pointer_info(&pointer_info);
  error_check(er);

  window_wimp_to_toolbox(0, pointer_info.window_handle, pointer_info.icon_handle,
                         &obj_name, &comp);
  error_check(er);

  if ((obj_name == OptUser_WindowHandle) && (comp == optuser_txborder))
  {
    /* We are on an option, so do the processing */
    ui_optionfield_update(DOWN, "OptUser_Tx_", OptUser_WindowHandle, optuser_txstring, Optionfield_Wrap|Optionfield_NonNumerical);
  }
  else if (obj_name == OptDate_WindowHandle)
  {
    optdate_optionfields(DOWN, comp);
  }
  else if (obj_name == OptMisc_WindowHandle)
  {
    optmisc_optionfields(DOWN, comp);
  }
  else if (obj_name == OptLog_WindowHandle)
  {
    optlog_optionfields(DOWN, comp);
  }
  else if (obj_name == OptISP1_WindowHandle)
  {
    optisp1_optionfields(DOWN, comp);
  }
  else if (obj_name == OptISP2_WindowHandle)
  {
    optisp2_optionfields(DOWN, comp);
  }
  else if (obj_name == OptSchedule_WindowHandle)
  {
    optsched_optionfields(DOWN, comp);
  }
}


/************************************************************************/
/* rightcursor_pressed                                                  */
/*                                                                      */
/* Function is called when the left of right arror keys are pressed.    */
/* Action will only be taken if that window has an option field.        */
/*                                                                      */
/* Parameters: ToolboxEventHandler parameters.                          */
/*                                                                      */
/* Returns:    TRUE or FALSE.                                           */
/*                                                                      */
/************************************************************************/
void rightcursor_pressed(void)
{
  _kernel_oserror		*er;
  WimpGetPointerInfoBlock	 pointer_info;
  ComponentId			 comp;
  ObjectId			 obj_name;

  /* In a window with an option field.  Now check to see if Iconhigh is highlighting the
   * clickable button surrounding the field
   */
  er = wimp_get_pointer_info(&pointer_info);
  error_check(er);

  window_wimp_to_toolbox(0, pointer_info.window_handle, pointer_info.icon_handle,
                         &obj_name, &comp);
  error_check(er);

  if ((ui_currently_open_win == OptUser_WindowHandle) && (comp == optuser_txborder))
  {
    /* OptUser window */
    ui_optionfield_update(UP, "OptUser_Tx_", OptUser_WindowHandle, optuser_txstring, Optionfield_Wrap|Optionfield_NonNumerical);
  }
  else if (obj_name == OptDate_WindowHandle)
  {
    /* OptDate window */
    optdate_optionfields(UP, comp);
  }
  else if (obj_name == OptMisc_WindowHandle)
  {
    optmisc_optionfields(UP, comp);
  }
  else if (obj_name == OptLog_WindowHandle)
  {
    optlog_optionfields(UP, comp);
  }
  else if (obj_name == OptISP1_WindowHandle)
  {
    optisp1_optionfields(UP, comp);
  }
  else if (obj_name == OptISP2_WindowHandle)
  {
    optisp2_optionfields(UP, comp);
  }
  else if (obj_name == OptSchedule_WindowHandle)
  {
    optsched_optionfields(UP, comp);
  }
}


/************************************************************************/
/* optdate_optionfields                                                 */
/*                                                                      */
/* Function deals with the optionfields on the OptDate window.          */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optdate_optionfields(int updown, ComponentId comp)
{
  _kernel_oserror	*er;
  _kernel_swi_regs	regs;
  char			buffer[50], buffer2[50], oscli[30];
  struct tm		*local_time;
  int			secs, mins, hours, days, months, years, id, offset;
  int			secs2, mins2, hours2, days2, months2, years2;
  int			original_offset;

  if (comp == optdate_month_border)
  {
    /* Month optionfield */
    ui_optionfield_update(updown, "OptDate_Month_", OptDate_WindowHandle, optdate_month_string, Optionfield_Wrap|Optionfield_NonNumerical);
  }
  else if (comp == optdate_hour_border)
  {
    /* Hour optionfield */
    ui_optionfield_update(updown, "OptDate_Hour_", OptDate_WindowHandle, optdate_hour_string, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
  }
  else if (comp == optdate_minute_border)
  {
    /* Hour optionfield */
    ui_optionfield_update(updown, "OptDate_Min_", OptDate_WindowHandle, optdate_minute_string, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
  }
  else if (comp == optdate_dsave_border)
  {
    //local_time = malloc(sizeof(struct tm));
    ui_optionfield_update(updown, "OptDate_DSave_", OptDate_WindowHandle, optdate_dsave_string, Optionfield_Wrap|Optionfield_NonNumerical);
    er = button_get_value(0, OptDate_WindowHandle, optdate_dsave_string, buffer,
    				sizeof(buffer), 0);
    /* Daylight Saving optionfield */

    /* Get the time *now* */
    optdate_get_time_now(&local_time);
    secs = local_time->tm_sec; mins = local_time->tm_min; hours = local_time->tm_hour;
    days = local_time->tm_mday; months = local_time->tm_mon; years = local_time->tm_year;

    /* Update the clock from the writable field */
    optdate_set_clock('S', 0, 0, 0, 0, 0, 0);

    /* Alter the saving, reset the writables */
    if (misc_tag_lookup(OptDate_WindowHandle, optdate_dsave_string, "OptDate_DSave") == 1)
        _kernel_oscli("co. nodst");

    else
      	_kernel_oscli("co. dst");

    optdate_set_clock('S', 0, 0, 0, 0, 0, 0);

    /* Reset to original values to preserve */
    if (misc_tag_lookup(OptDate_WindowHandle, optdate_dsave_string, "OptDate_DSave") == 1)
        _kernel_oscli("co. dst");

    else
      	_kernel_oscli("co. nodst");

    /* And reset the clock to the real time *now* */
    optdate_set_datetime();
    optdate_set_clock('N', secs, mins, hours, days, months, years);
  }
  else if (comp == optdate_toffset_border)
  {
    /* Update the field so that the correct zone can be set */
    ui_optionfield_update(updown,"OptDate_TOffset_",OptDate_WindowHandle,optdate_toffset_string, Optionfield_Wrap|Optionfield_NonNumerical);
    /* Get timezone string from button */
    er = button_get_value(0, OptDate_WindowHandle, optdate_dsave_string, buffer,
    				sizeof(buffer), 0);
    /* Get ID from this string */
    id = misc_tag_lookup(OptDate_WindowHandle, optdate_toffset_string, "OptDate_TOffset");

    /* Calculate an offset, and shove into a string */
    er = button_get_value(0, OptDate_WindowHandle, optdate_toffset_string, buffer2, sizeof(buffer2), 0);
    offset = misc_lookup_timezone();

    /* Get the original timezone offset */
    regs.r[0] = 161;
    regs.r[1] = 139;
    _kernel_swi(OS_Byte, &regs, &regs);

    /* Convert the signed 2 bit complement to a real number */
    original_offset = regs.r[2];
    regs.r[0] = original_offset;
    regs.r[1] = (int)buffer;
    regs.r[2] = sizeof(buffer);
    _kernel_swi(OS_ConvertInteger1, &regs, &regs);

    /* Work out the time *now* */
    optdate_get_time_now(&local_time);
    secs = local_time->tm_sec; mins = local_time->tm_min; hours = local_time->tm_hour;
    days = local_time->tm_mday; months = local_time->tm_mon; years = local_time->tm_year;
    optdate_set_clock('N', secs, mins, hours, days, months, years);

    /* Set the writeable data (this should be quick enough not to update) */
    optdate_set_datetime();
    optdate_set_clock('S', 0, 0, 0, 0, 0, 0);

    /* Now set the timezone flags */
    sprintf(oscli, "co. timezone %d\0", offset);
    _kernel_oscli(oscli);
    optdate_get_time_now(&local_time);
    secs2 = local_time->tm_sec; mins2 = local_time->tm_min; hours2 = local_time->tm_hour;
    days2 = local_time->tm_mday; months2 = local_time->tm_mon; years2 = local_time->tm_year;

    /* Set the clock again */
    optdate_set_clock('N', secs2, mins2, hours2, days2, months2, years2);
    optdate_set_datetime();

    /* And reset the actual timezone */
    sprintf(oscli, "co. timezone %s\0", buffer);
    _kernel_oscli(oscli);

    /* Grab parameters and return clock values to normallity */
    optdate_set_clock('N', secs, mins, hours, days, months, years);
  }
}


/************************************************************************/
/* optmisc_optionfields                                                 */
/*                                                                      */
/* Function deals with the optionfields on the OptMisc window.          */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optmisc_optionfields(int updown, ComponentId comp)
{
  switch(comp)
  {
    case(optmisc_capturetime_border):
    {
      /* Capture timeout option */
      ui_optionfield_update(updown, "OptMisc_Capture_", OptMisc_WindowHandle, optmisc_capturetime_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }
  }
}

/************************************************************************/
/* optlog_optionfields                                                  */
/*                                                                      */
/* Function deals with the optionfields on the OptLog window.           */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optlog_optionfields(int updown, ComponentId comp)
{
  switch(comp)
  {
    case(optlog_logsize_border):
    {
      /* LogFile size option */
      ui_optionfield_update(updown, "OptLog_LogSize_", OptLog_WindowHandle, optlog_logsize_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }
    case(optlog_purgeperiod_border):
    {
      /* Purge period option */
      ui_optionfield_update(updown, "OptLog_PurgePeriod_", OptLog_WindowHandle, optlog_purgeperiod_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }
    case(optlog_hour_border):
    {
      /* Hour optionfield */
      ui_optionfield_update(updown, "OptDate_Hour_", OptLog_WindowHandle, optlog_hour_string, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
      break;
    }
    case(optlog_minute_border):
    {
      /* Min optionfield */
      ui_optionfield_update(updown, "OptDate_Min_", OptLog_WindowHandle, optlog_minute_string, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
      break;
    }
    case(optlog_day_border):
    {
      /* Day optionfield */
      ui_optionfield_update(updown, "OptMisc_Day_", OptLog_WindowHandle, optlog_day_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }
    case(optlog_email_border):
    {
      /* Email OptionField */
      ui_optionfield_update(updown, "Opt_YesNo_", OptLog_WindowHandle, optlog_email_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }
    case(optlog_print_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "Opt_YesNo_", OptLog_WindowHandle, optlog_print_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }
  }
}

/************************************************************************/
/* optisp1_optionfields                                                 */
/*                                                                      */
/* Function deals with the optionfields on the OptISP1 window.          */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optisp1_optionfields(int updown, ComponentId comp)
{
  switch(comp)
  {
    case(optisp1_dialupretry_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "OptISP1_Redial_", OptISP1_WindowHandle, optisp1_dialupretry_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optisp1_alternateretry_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "OptISP1_Redial_", OptISP1_WindowHandle, optisp1_alternateretry_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }
  }
}

/************************************************************************/
/* optisp2_optionfields                                                 */
/*                                                                      */
/* Function deals with the optionfields on the OptISP1 window.          */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optisp2_optionfields(int updown, ComponentId comp)
{
  switch(comp)
  {
    case(optisp2_missingpages_border):
    {
      /* Print optionfield */
      ui_optionfield_update(updown, "OptISP2_Pages_", OptISP2_WindowHandle, optisp2_missingpages_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optisp2_connectiontime_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "OptISP2_Connection_", OptISP2_WindowHandle, optisp2_connectiontime_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optisp2_pagesperemail_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "OptISP2_Pages_", OptISP2_WindowHandle, optisp2_pagesperemail_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optisp2_maxemailsize_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "OptISP2_MaxEmail_", OptISP2_WindowHandle, optisp2_maxemailsize_string, Optionfield_Wrap|Optionfield_Numerical);

      break;
    }

    case(optisp2_switch1_border):
    {
      /* Alter the contents of the switch to either password mode or non-password */
      ui_optionfield_update(updown, "OptISP2_LoginField_", OptISP2_WindowHandle, optisp2_switch1_string, Optionfield_Wrap|Optionfield_NonNumerical);

      ui_update_login(optisp2_switch1_string, optisp2_login_response1);
      break;
    }

    case(optisp2_switch2_border):
    {
      /* Alter the contents of the switch to either password mode or non-password */
      ui_optionfield_update(updown, "OptISP2_LoginField_", OptISP2_WindowHandle, optisp2_switch2_string, Optionfield_Wrap|Optionfield_NonNumerical);

      ui_update_login(optisp2_switch2_string, optisp2_login_response2);
      break;
    }

    case(optisp2_switch3_border):
    {
      /* Alter the contents of the switch to either password mode or non-password */
      ui_optionfield_update(updown, "OptISP2_LoginField_", OptISP2_WindowHandle, optisp2_switch3_string, Optionfield_Wrap|Optionfield_NonNumerical);

      ui_update_login(optisp2_switch3_string, optisp2_login_response3);
      break;
    }

    case(optisp2_switch4_border):
    {
      /* Alter the contents of the switch to either password mode or non-password */
      ui_optionfield_update(updown, "OptISP2_LoginField_", OptISP2_WindowHandle, optisp2_switch4_string, Optionfield_Wrap|Optionfield_NonNumerical);

      ui_update_login(optisp2_switch4_string, optisp2_login_response4);
      break;
    }

    case(optisp2_switch5_border):
    {
      /* Alter the contents of the switch to either password mode or non-password */
      ui_optionfield_update(updown, "OptISP2_LoginField_", OptISP2_WindowHandle, optisp2_switch5_string, Optionfield_Wrap|Optionfield_NonNumerical);

      ui_update_login(optisp2_switch5_string, optisp2_login_response5);
      break;
    }
  }
}

/************************************************************************/
/* optsched_optionfields                                                */
/*                                                                      */
/* Function deals with the optionfields on the OptSchedule window.      */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optsched_optionfields(int updown, ComponentId comp)
{
  /* The UI needs to alter the times depending on the day. Oh joy, this is going to be hell to do */
  switch(comp)
  {
    case(optschedule_scheduler_border):
    {
      /* Scheduler On/Off label */
      ui_optionfield_update(updown, "Opt_OnOff_", OptSchedule_WindowHandle, optschedule_scheduler_string, Optionfield_Wrap|Optionfield_NonNumerical);

      /* We now need to change this while *within* the scheduler to see if we need to ignore or save the
         entered schedule settings */
      if (misc_tag_lookup(OptSchedule_WindowHandle, optschedule_scheduler_string, "Opt_OnOff") == 1)
      {
        ui_sched_fade_fields(TRUE);
        sched_on = TRUE;
      }
      else
      {
        ui_sched_fade_fields(FALSE);
        sched_on = FALSE;
      }

      break;
    }
    case(optschedule_peakdialup_border):
    {
      /* Number of peak dialups label */
      ui_optionfield_update(updown, "OptSchedule_DialUp_", OptSchedule_WindowHandle, optschedule_peakdialup_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }
    case(optschedule_offdialup_border):
    {
      /* Number of off-peak dialups */
      ui_optionfield_update(updown, "OptSchedule_DialUp_", OptSchedule_WindowHandle, optschedule_offdialup_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }
    case(optschedule_stanweek_border):
    {
      /* This a standard week? */
      ui_optionfield_update(updown, "Opt_OnOff_", OptSchedule_WindowHandle, optschedule_stanweek_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }
    case(optschedule_day_border):
    {
      /* Day label */
      ui_optionfield_update(updown, "OptMisc_Day_", OptSchedule_WindowHandle, optschedule_day_string, Optionfield_Wrap|Optionfield_NonNumerical);
      /* Update the time fields to display the times for that particular day */
      ui_sched_update_fields();
      break;
    }
    /* All the schedule fields */
    case(optschedule_peakstart_hour_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_peakstart_hour_string, 1, TRUE, updown);

      break;
    }
    case(optschedule_peakstart_min_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_peakstart_min_string, 1, FALSE, updown);
      break;
    }
    case(optschedule_peakend_hour_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_peakend_hour_string, 2, TRUE, updown);
      break;
    }
    case(optschedule_peakend_min_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_peakend_min_string, 2, FALSE, updown);
      break;
    }
    case(optschedule_idlestart_hour_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_idlestart_hour_string, 3, TRUE, updown);
      break;
    }
    case(optschedule_idlestart_min_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_idlestart_min_string, 3, FALSE, updown);
      break;
    }
    case(optschedule_idleend_hour_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_idleend_hour_string, 4, TRUE, updown);
      break;
    }
    case(optschedule_idleend_min_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_idleend_min_string, 4, FALSE, updown);
      break;
    }
  }
}

/*  Name        : ui_sched_fade_fields
 *  Parameters  : TRUE/FALSE (greyed out fields or not)
 *  Description : Greys out the scheduler fields if TRUE is passed, else makes them selectable
 *  Returns     : Nothing
 */
void ui_sched_fade_fields(int grey)
{
  int         loop;
  int         sicon[30];

  sicon[0] = optschedule_peakdialup_string;
  sicon[1] = optschedule_peakdialup_border;
  sicon[2] = optschedule_offdialup_string;
  sicon[3] = optschedule_offdialup_border;
  sicon[4] = optschedule_stanweek_string;
  sicon[5] = optschedule_stanweek_border;
  sicon[6] = optschedule_day_string;
  sicon[7] = optschedule_day_border;
  sicon[8] = optschedule_peakstart_hour_string;
  sicon[9] = optschedule_peakstart_hour_border;
  sicon[10] = optschedule_peakstart_min_string;
  sicon[11] = optschedule_peakstart_min_border;
  sicon[12] = optschedule_peakend_hour_string;
  sicon[13] = optschedule_peakend_hour_border;
  sicon[14] = optschedule_peakend_min_string;
  sicon[15] = optschedule_peakend_min_border;
  sicon[16] = optschedule_idlestart_hour_string;
  sicon[17] = optschedule_idlestart_hour_border;
  sicon[18] = optschedule_idlestart_min_string;
  sicon[19] = optschedule_idlestart_min_border;
  sicon[20] = optschedule_idleend_hour_string;
  sicon[21] = optschedule_idleend_hour_border;
  sicon[22] = optschedule_idleend_min_string;
  sicon[23] = optschedule_idleend_min_border;

  if (grey == TRUE)
  {
    /* Ungrey the icons */
    for (loop = 0; loop < 24; loop++)
      ui_alter_flag(OptSchedule_WindowHandle, sicon[loop], 0);
  }
  else
  {
    /* Grey those icons out */
    for (loop = 0; loop < 24; loop++)
      ui_alter_flag(OptSchedule_WindowHandle, sicon[loop], 1);
  }
}

/*  Name        : ui_sched_time_fields
 *  Parameters  : Window handle/Component handle/schedule time type/hour or minute flag/updown
 *  Description : Updates the time set for the scheduler and updates the displayed times
 *  Returns     : Nothing
 */
void ui_sched_time_fields(ObjectId window, ComponentId comp, int type, int hom, int updown)
{
  _kernel_oserror	*er;
  char	buffer[255];
  int	hour = 0, min = 0, nbytes;

  /* Which scheduled times are we updating? */
  switch (type)
  {
    case 1:
    {
      hour = HH(sched_start_peak[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      min  = MM(sched_start_peak[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      break;
    }
    case 2:
    {
      hour = HH(sched_end_peak[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      min  = MM(sched_end_peak[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      break;
    }
    case 3:
    {
      hour = HH(sched_start_idle[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      min  = MM(sched_start_idle[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      break;
    }
    case 4:
    {
      hour = HH(sched_end_idle[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      min  = MM(sched_end_idle[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      break;
    }
  }

  /* If we're updating the hour */
  if (hom == TRUE)
  {
    /* Set the new hour */
    sprintf(buffer, "%d", hour);
    er = button_set_value(0, window, comp, buffer);
    ui_optionfield_update(updown, "OptDate_Hour_", window, comp, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
    er = button_get_value(0, window, comp, buffer, sizeof(buffer), &nbytes);
    hour = atoi(buffer);
  }
  else
  {
    /* Set the new minute */
    sprintf(buffer, "%d", min);
    er = button_set_value(0, window, comp, buffer);
    ui_optionfield_update(updown, "OptDate_Min_", window, comp, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
    er = button_get_value(0, window, comp, buffer, sizeof(buffer), &nbytes);
    min = atoi(buffer);
  }

  /* And finally update the icon fields on the screen */
  ui_update_sched_time(misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day"), type, HHMM(hour, min));
}


/*  Name        : ui_sched_update_fields
 *  Parameters  : None
 *  Description : Updates the icons in which the times are displayed
 *  Returns     : Nothing
 */
void ui_sched_update_fields(void)
{
  _kernel_oserror	*er;
  int			peak_hour_start, peak_hour_end, peak_min_start, peak_min_end;
  int			idle_hour_start, idle_hour_end, idle_min_start, idle_min_end;
  char			buffer[255];

  /* Start and end of peak times in hours and minutes */
  peak_hour_start = HH(sched_start_peak[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  peak_hour_end   = HH(sched_end_peak[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  peak_min_start  = MM(sched_start_peak[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  peak_min_end	  = MM(sched_end_peak[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);

  /* Start and end of idle times in hours and minutes */
  idle_hour_start = HH(sched_start_idle[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  idle_hour_end   = HH(sched_end_idle[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  idle_min_start  = MM(sched_start_idle[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  idle_min_end    = MM(sched_end_idle[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);

  /* Update the start and end optionfields for the peak times */
  sprintf(buffer, "%02d", peak_hour_start);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_peakstart_hour_string, buffer);
  sprintf(buffer, "%02d", peak_min_start);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_peakstart_min_string, buffer);
  sprintf(buffer, "%02d", peak_hour_end);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_peakend_hour_string, buffer);
  sprintf(buffer, "%02d", peak_min_end);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_peakend_min_string, buffer);

  /* Update the start and end optionfields for the idle times */
  sprintf(buffer, "%02d", idle_hour_start);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_idlestart_hour_string, buffer);
  sprintf(buffer, "%02d", idle_min_start);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_idlestart_min_string, buffer);
  sprintf(buffer, "%02d", idle_hour_end);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_idleend_hour_string, buffer);
  sprintf(buffer, "%02d", idle_min_end);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_idleend_min_string, buffer);

  /* Done */
}


/*  Name        : ui_update_sched_time
 *  Parameters  : day/time specifier/new time
 *  Description : Updates the times from the time passed to the function depending on the specifier
 *  Returns     : Nothing
 */
void ui_update_sched_time(int day, int specifier, int new_time)
{
  int	day_loop;

  /* If this is Saturday or Sunday or a non-standard week, then we simply set individually */
  if ((day == 5) || (day == 6) || (misc_tag_lookup(OptSchedule_WindowHandle, optschedule_stanweek_string, "Opt_OnOff") == 0))
  {
    switch (specifier)
    {
      case 1:
        sched_start_peak[day] = new_time;
        break;
      case 2:
        sched_end_peak[day] = new_time;
        break;
      case 3:
        sched_start_idle[day] = new_time;
        break;
      case 4:
        sched_end_idle[day] = new_time;
        break;
    }
  }
  /* Else if we are on a 'standard' week, set all the times to be the same */
  else
  {
    for (day_loop = 0; day_loop < 5; day_loop++)
    {
      switch (specifier)
      {
        case 1:
          sched_start_peak[day_loop] = new_time;
          break;
        case 2:
          sched_end_peak[day_loop] = new_time;
          break;
        case 3:
          sched_start_idle[day_loop] = new_time;
          break;
        case 4:
          sched_end_idle[day_loop] = new_time;
          break;
      }
    }
  }
}

