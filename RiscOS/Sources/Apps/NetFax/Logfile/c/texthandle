/************************************************************************/
/* File:    texthandle.c                                                */
/* Purpose: Declares the functions used to display log entries inside   */
/*          the log window using icon gadgets.                          */
/* Author:  Hed Simons (mailto:hsimons@acorn.com)                       */
/* History: Mon 22nd September 1997  ver 0.01 - Created.                */
/*          Mon 18th November 1997 ver 0.03 - Not too many changes,     */
/*                                        just those to do with records */
/*	    Tue 9th  December 1997 ver 0.05 - Added the faded icon patch*/
/*					  so now you can't access icons */
/*					  not containing log entries    */
/*	    Thu 11th December 1997 ver 0.06 - Monospaced and            */
/*					  proportional fonts are now    */
/*					  supported with the relevant   */
/*					  resource window		*/
/*	    Mon 05th January  1998 ver. 0.07 - Now intelligently finds  */
/*					  the max width of a string to  */
/*					  insert into the entry icon    */
/************************************************************************/

#include <stdio.h>
#include <string.h>

#include "include.h"
#include "main.h"
#include "misc.h"
#include "globals.h"
#include "recordlib.h"
#include "texthandle.h"

/*----------------------------------------------------------------------*/

/* STRINGSPACE defines how many character fit in a log entry icon at one time */
#define STRINGSPACE 18

/* FONTNAME is the name of the font used for the text entry gadgets. If you want to use another font,
   simply put the new font descriptor string in its place. */
#define FONTNAME "Homerton.Medium"
/* FONTPOINT is the fontsize in point*16 of the font to be used */
#define FONTPOINT 192

/*----------------------------------------------------------------------*/

/*******************************************************************************
 * Name	       : init_icon_tags                                                *
 * Parameters  : void                                                          *
 * Description : Initialises the icons used in the log screen to display       *
 *	         the logs themselves                                           *
 * Returns     : Nothing                                                       *
 *******************************************************************************/
void init_icon_tags(void)
{
  _kernel_oserror	*er;
  int 			loop;

  /* Initialise the identities of each of the icons in the records */
  for (loop = 0; loop < 5; loop++)
  {
    icon_entries[loop].date_icon = (3*loop);
    icon_entries[loop].time_icon = (3*loop)+1;
    icon_entries[loop].message_icon = (3*loop)+2;
    icon_entries[loop].border_icon = (48 + loop);
    icon_entries[loop].filled = FALSE;
    er = button_set_value(0, OptLog_WindowHandle, 0x20 + (2*loop),
    		"arrlr_blank");
    misc_error_check(er);
    er = button_set_value(0, OptLog_WindowHandle, 0x20 + (2*loop) + 1,
    		"arrlr_blank");
    misc_error_check(er);
  }
}

/*******************************************************************************
 * Name	       : write_log_entry                                               *
 * Parameters  : DecLogEntry *, int position, int index                        *
 * Description : Writes the log entry passed to it into the screen icons       *
 *	         defined by the position integer and starts at the string      *
 *	         index pointed to by index                                     *
 * Returns     : Nothing                                                       *
 *******************************************************************************/
void write_log_entry(DecLogEntry *entry, int position, int index)
{
  _kernel_oserror	*er;
  _kernel_swi_regs	regs;
  WimpGetIconStateBlock	icon_block;
  char			string[30]; /* Max of 30 characters in an icon at one time */
  int			loop, run = 0;
  int			nbytes, icon_handle, window_handle, icon_width, string_width, font_handle;
  int			milli_width;
  int		  	icon_buffer[10];
  unsigned int		flags;


  /* We need the window handle of this Object */
  er = window_get_wimp_handle(0, OptLog_WindowHandle, &window_handle);
  misc_error_check(er);

  /* First we get the wimp icon handle for this button */
  er = gadget_get_icon_list(0, OptLog_WindowHandle, icon_entries[position].message_icon, icon_buffer,
  	sizeof(icon_buffer), &nbytes);
  misc_error_check(er);
  icon_handle = icon_buffer[0];
  dprintf(("", "Icon handle is : %d\n", icon_handle));

  /* Now we need the width of this icon, in OS units, so we can determine the size of the string of text
     to send to the icon */
  icon_block.window_handle = window_handle;
  icon_block.icon_handle = icon_handle;
  er = wimp_get_icon_state(&icon_block);
  misc_error_check(er);
  icon_width = icon_block.icon.bbox.xmax - icon_block.icon.bbox.xmin;

  /* If there isn't any text in this entry... */
  if (entry == NULL)
  {
    er = button_set_value(0, OptLog_WindowHandle,
  	icon_entries[position].date_icon, "\0");
    misc_error_check(er);
    er = button_set_value(0, OptLog_WindowHandle,
  	icon_entries[position].time_icon, "\0");
    misc_error_check(er);
    er = button_set_value(0, OptLog_WindowHandle,
    	icon_entries[position].message_icon, "\0");
    misc_error_check(er);
    er = button_set_value(0, OptLog_WindowHandle, 0x20 + (2*position),
      		"arrlr_blank");
    misc_error_check(er);
    er = button_set_value(0, OptLog_WindowHandle, 0x20 + (2*position) + 1,
    		"arrlr_blank");
    misc_error_check(er);

    icon_entries[position].filled = FALSE;

    /* And finally fade this icons border out so we can't access it */
    er = gadget_get_flags(0, OptLog_WindowHandle,
    	icon_entries[position].border_icon, &flags);
    flags = flags | Gadget_Faded;
    er = gadget_set_flags(0, OptLog_WindowHandle,
    	icon_entries[position].border_icon, flags);
  }
  else
  {
    /* First fade this icon in, as it may be faded */
    er = gadget_get_flags(0, OptLog_WindowHandle,
    	icon_entries[position].border_icon, &flags);
    flags = flags & (~Gadget_Faded);
    er = gadget_set_flags(0, OptLog_WindowHandle,
    	icon_entries[position].border_icon, flags);

    /* Poke the values into the relevant icons */
    er = button_set_value(0, OptLog_WindowHandle,
  	icon_entries[position].date_icon, entry->date);
    misc_error_check(er);
    er = button_set_value(0, OptLog_WindowHandle,
  	icon_entries[position].time_icon, entry->time);
    misc_error_check(er);
    icon_entries[position].filled = TRUE;

    /* Right... we open the font used in the button gadget */
    regs.r[1] = (int)FONTNAME;
    regs.r[2] = (int)FONTPOINT;
    regs.r[3] = (int)FONTPOINT;
    regs.r[4] = -1;
    regs.r[5] = -1;
    er = _kernel_swi(Font_FindFont, &regs, &regs);
    misc_error_check(er);
    font_handle = regs.r[0];

    /* Use ScanString to find the size of the string in millipoints */
    regs.r[0] = font_handle;
    regs.r[1] = (int)entry->log_string;
    regs.r[2] = 0;
    regs.r[3] = 1000000;
    regs.r[4] = 1000000;
    er = _kernel_swi(Font_ScanString, &regs, &regs);
    misc_error_check(er);

    /* Convert millipoints to OS units */
    milli_width = regs.r[3];
    regs.r[1] = milli_width;
    regs.r[2] = 0;
    er = _kernel_swi(Font_ConverttoOS, &regs, &regs);
    misc_error_check(er);

    /* Finally we have the width of the string in OS units */
    string_width = regs.r[1];

    /* If the record is shorter than the log icon... */
    if (string_width < icon_width)
    {
      er = button_set_value(0, OptLog_WindowHandle,
    	icon_entries[position].message_icon, entry->log_string);
      misc_error_check(er);
      er = button_set_value(0, OptLog_WindowHandle, 0x20 + (2*position),
    		"arrlr_blank");
      misc_error_check(er);
      er = button_set_value(0, OptLog_WindowHandle, 0x20 + (2*position) + 1,
    		"arrlr_blank");
      misc_error_check(er);
    }
    /* Else */
    else
    {
      /* We want to scan the string until it's longer than the button gadget */
      loop = index;
      run = 0;
      string[run] = entry->log_string[loop];
      string[run+1] = '\0';

      /* Scan the string in its initial state */
      regs.r[0] = font_handle;
      regs.r[1] = (int)string;
      regs.r[2] = 0;
      regs.r[3] = 1000000;
      regs.r[4] = 1000000;
      er = _kernel_swi(Font_ScanString, &regs, &regs);
      misc_error_check(er);
      milli_width = regs.r[3];
      regs.r[1] = milli_width;
      regs.r[2] = 0;
      er = _kernel_swi(Font_ConverttoOS, &regs, &regs);
      misc_error_check(er);

      string_width = regs.r[1];

      run++;
      loop++;

      /* While the string width in OS units is smaller than the icon size in OS units, AND we
         haven't reached the end of the entry string... */
      while ((string_width <= icon_width - 10) && (loop < (strlen(entry->log_string) + 1)))
      {
        string[run] = entry->log_string[loop];
        run++;
        loop++;

        string[run] = '\0';

        regs.r[0] = font_handle;
        regs.r[1] = (int)string;
        regs.r[2] = 0;
        regs.r[3] = 1000000;
        regs.r[4] = 1000000;
        er = _kernel_swi(Font_ScanString, &regs, &regs);
        misc_error_check(er);
        milli_width = regs.r[3];
        regs.r[1] = milli_width;
        regs.r[2] = 0;
        er = _kernel_swi(Font_ConverttoOS, &regs, &regs);
        misc_error_check(er);
        string_width = regs.r[1];
      }
      run--;
      string[run] = '\0';

      /* If loop == (strlen(entry->log_entry) + 1) we are at the end of the string */
      if (loop == strlen(entry->log_string) + 1)
      {
  	string_icon_index--;
  	string_max = TRUE;
	dprintf(("", "String max\n"));
      }
      else
      {
        string_max = FALSE;
      }

      dprintf(("", "Printed string is : %s (%d chars)\n", string, run));

      er = button_set_value(0, OptLog_WindowHandle,
        	icon_entries[position].message_icon, string);
      misc_error_check(er);

      if (index != 0)
      {
      	er = button_set_value(0, OptLog_WindowHandle, 0x20 + (2*position),
      		"arrow_left");
        misc_error_check(er);
      }
      else
      {
      	er = button_set_value(0, OptLog_WindowHandle, 0x20 + (2*position),
      		"arrlr_blank");
      	misc_error_check(er);
      }

      /* Should really change this, though it makes no difference */
      if (string_max == FALSE)
      {
        er = button_set_value(0, OptLog_WindowHandle, 0x20 + (2*position) + 1,
    		"arrow_right");
    	misc_error_check(er);
      }
      else
      {
      	er = button_set_value(0, OptLog_WindowHandle, 0x20 + (2*position) + 1,
      		"arrlr_blank");
      	misc_error_check(er);
      }
    }
  }
}

/*******************************************************************************
 * Name	       : write_multiple_records                                        *
 * Parameters  : void                                                          *
 * Description : Uses the 'top_record' variable to see which is currently      *
 *	         the record being displayed at the top of the log screen,      *
 *	         and prints the next 6 entries to the screen, or until there   *
 *	         are no more entries                                           *
 * Returns     : Nothing                                                       *
 *******************************************************************************/
void write_multiple_records(void)
{
  _kernel_oserror	*er;
  _kernel_swi_regs      regs;
  DecLogEntry		*gopher;
  int                   buffer[5];
  int 			icon_position = 0, wimp_handle, icon_handle, nbytes;

  /* We want to scrap all the records we currently have, and reread them
     all from the logfile */
  record_read_next_records();

  gopher = decrec_head;

  dprintf(("", "Entry : %s\n", gopher->log_string));

  /* Now print out the next six records, or until there are no more records */
  while ((gopher != NULL) && (icon_position != 5))
  {
    write_log_entry(gopher, icon_position, 0);
    icon_position++;
    gopher = gopher->next_record;
  }

  /* If we are out of records, then print blanks */
  if (gopher == NULL)
  {
    while (icon_position != 5)
    {
      write_log_entry(NULL, icon_position, 0);
      icon_position++;
    }

  }

  /* If we printed the top record, there is no need to show the up arrow */
  if (top_record == 0)
  {
  	er = button_set_value(0, OptLog_WindowHandle, Up_Arrow, "arrud_blank");
        misc_error_check(er);
  }
  else
  {
  	er = button_set_value(0, OptLog_WindowHandle, Up_Arrow, "arrow_up");
        misc_error_check(er);
  }

  /* If we still have records underneath, print the down arrow */
  if ((number_records - top_record) < 6)
  {
  	er = button_set_value(0, OptLog_WindowHandle, Down_Arrow, "arrud_blank");
        misc_error_check(er);
  }
  else
  {
  	er = button_set_value(0, OptLog_WindowHandle, Down_Arrow, "arrow_down");
        misc_error_check(er);
  }

  /* If there's only one record then it's obviously just been added, so put the focus around it */
  if ((ui_currently_open_win == OptLog_WindowHandle) && (number_records == 1))
  {
    er = window_get_wimp_handle(0, OptLog_WindowHandle, &wimp_handle);
    misc_error_check(er);
    er = gadget_get_icon_list(0, OptLog_WindowHandle, icon_entries[0].border_icon, buffer,
      				sizeof(buffer), &nbytes);
    misc_error_check(er);

    icon_handle = buffer[0]; /* Must be the first icon, as there's only the one */
    regs.r[0] = 8;    regs.r[1] = wimp_handle;
    regs.r[2] = icon_handle;
    er = _kernel_swi(IconHigh_Start, &regs, &regs);
  }
}

/*******************************************************************************
 * Name	       : write_redrawn_icon                                            *
 * Parameters  : void                                                          *
 * Description : Called to display the subsection of the log entry string      *
 *	         currently being looked at                                     *
 * Returns     : Nothing                                                       *
 *******************************************************************************/
void write_redrawn_icon(void)
{
  DecLogEntry		*gopher;
  int 			position, scan_record, loop = 0;

  /* Get the position of the icon that is to be redrawn */
  position = current_icon - 0x30;

  if ((position > -1) && (position < 6))
  {
    //scan_record = top_record + position;
    scan_record = position;

    gopher = decrec_head;
    while (loop != scan_record)
    {
      gopher = gopher->next_record;
      loop++;
    }

    if (icon_entries[position].filled == TRUE)
    {
      write_log_entry(gopher, position, string_icon_index);
    }
    else
    {
      string_icon_index--;
    }
  }
  else
    string_icon_index--;
}


