/************************************************************************/
/* File:    optionlib.c                                                 */
/* Purpose: Declares the functions used to grab the options needed for  */
/*          the log file                                                */
/* Author:  Hed Simons (mailto:hsimons@acorn.com)                       */
/* History: Wed 24th September 1997  ver 0.01 - Created.                */
/*          Mon 17th November 1997   ver 0.11 - Uses the new SFConfigMan*/
/*                                    module to load options            */
/************************************************************************/

#include <string.h>

#include <stdio.h>


/* Need library to decode the time entries */
#include "include.h"
#include "globals.h"
#include "main.h"
#include "recordlib.h"
#include "optionlib.h"

#define	SFConfigMan_Read	0x50a40
#define SFConfigMan_Write	0x50a41

/*----------------------------------------------------------------------*/

/*******************************************************************************
 * Name        : option_load                                                   *
 * Parameters  : tag name, buffer to store result in, size of buffer           *
 * Description : Uses the SFConfigMan swi calls to load the relevant option    *
 * Returns     : The SFConfigMan error (R0) return code                        *
 *******************************************************************************/
int option_load(char *tag, char *result_buffer, int buffer_size)
{
  _kernel_oserror	*er;
  _kernel_swi_regs	regs;

  /* Load in the values given, call the SWI and return the chosen values */
  regs.r[0] = (int)tag;
  regs.r[1] = (int)result_buffer;
  regs.r[2] = buffer_size;
  er = _kernel_swi(SFConfigMan_Read, &regs, &regs);

  return regs.r[0];
}

/*******************************************************************************
 * Name        : optionlib_grab_options                                        *
 * Parameters  : None                                                          *
 * Description : Loads all of the Logfile options from SFConfigMan             *
 * Returns     : Nothing                                                       *
 *******************************************************************************/
void optionlib_grab_options(void)
{
  int	error, temp_time, prev_size;
  char	temp_buff[10];

  /* Load the relevant log file options from flash ram */
  error = option_load("MaximumFileSize", (char *)&max_size, 0);
  error = option_load("EmailBeforePurge", (char *)&email_purge, 0);
  error = option_load("PrintBeforePurge", (char *)&print_purge, 0);
  error = option_load("PurgeDay", (char *)&purge_day, 0);
  error = option_load("PurgePeriod", (char *)&purge_period, 0);
  error = option_load("PurgeTime", temp_buff, sizeof(temp_buff));
  error = option_load("Destination", log_destination, sizeof(log_destination));

  /* Max size in bytes, please */
  max_size *= 1024;

  /* Decode the time into a 4 character string */
  /* First the hour. Divide the integer by 100 and then pad whatevers left */
  temp_time = atoi(temp_buff);
  sprintf(temp_buff, "%02d", (temp_time/100));
  strcpy(purge_time, temp_buff);
  /* Then the minutes */
  temp_time = temp_time - ((temp_time/100)*100);
  sprintf(temp_buff, "%02d", temp_time);
  strcat(purge_time, temp_buff);

  /* If there isn't any setup info, we have to do an emergency configure.
     This consists of a 10K logfile, email and print purging off and a
     rolling style log. */
  if ((max_size == 0) && (email_purge == 0) && (print_purge == 0))
  {
    max_size = 10*1024;
    email_purge = FALSE;
    print_purge = FALSE;
    strcpy(purge_time, "0000");
    purge_day = 0;
    purge_period = 0;
    strcpy(log_destination, "");
  }

  dprintf(("", "Max Email size: %d\n", max_size));
  dprintf(("", "EmailBeforePurge:%d\n", email_purge));
  dprintf(("", "PrintBeforePurge:%d\n", print_purge));
  dprintf(("", "PurgeDay:%d\n", purge_day));
  dprintf(("", "PurgeTime:%s\n", purge_time));
  dprintf(("", "PurdgePeriod:%d\n", purge_period));
  dprintf(("", "Destination:%s\n", log_destination));

  /* Okay, for the second, it'd be a good idea to just fake the
     request and recieve */
  if (purge_period == 0)
    log_type = Rolling;
  else
    log_type = Timed;

  /* Work out the maximum number of records we can have by looking
     at the size of the record structure */
  prev_size = record_limit;
  record_limit = max_size/sizeof(EncLogEntry);
  dprintf(("", "Number of records : %d\n", record_limit));

  /* If the new size of the logfile is smaller than the previous one,
     delete it and start again */
  if (record_limit < prev_size)
    record_destroyall();

  /* Reset all of the purge values */
  purged = TRUE;
  time_purged = FALSE;
  purge_reset = TRUE;
}






