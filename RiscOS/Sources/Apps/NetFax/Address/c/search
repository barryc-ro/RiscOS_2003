/*
 * search.c
 */

#include "include.h"
#include "tbox.h"
#include "ctype.h"
#include "time.h"
#include "misc.h"
#include "miscwimp.h"
#include "numconvert.h"
#include "strings.h"
#include "flash.h"
#include "runes.h"
#include "error.h"
#include "addrbookIF.h"
#include "memhandle.h"
#include "search.h"
#include "globals.h"

clock_t timings[8000];
int timings_count = 0;

/* The default key handler is called as fall-through from the search window's
   specialised key handler */
extern int default_key_handler (int, WimpPollBlock *, IdBlock *, void *);

/************************/
/* Generic search enums */

enum {Search_Code_Start, Search_Code_Continue};
enum {Search_Status_Finished, Search_Status_InProgress};

enum {AfterNan_Action_OpenAdd, AfterNan_Action_OpenEdit, AfterNan_Action_OpenMain,
      AfterNan_Action_CallDaytona, AfterNan_Action_RestartSearch};

static int action_after_nansearch;

/************************/
/* Null poll task stuff */

#define NullPollTask_None       0u
#define NullPollTask_IntSearch  1u
#define NullPollTask_Search     2u
#define NullPollTask_Update     4u

static unsigned int nullpoll_task = NullPollTask_None;


#if 0
/**********************/
/* Search index stuff */

/* Data type for holding search index entry */
typedef struct search_index_entry
{
  int a_to_z : 26;
  int square_to_dash : 6;
  int zero_to_nine : 10;
  int space_to_slash : 16;
  int colon_to_at : 7;
  int curly_to_tilde : 4;
}search_index_entry;

/* Variable to hold the search index */
static search_index_entry search_search_index[2000];

/*****************************************************/
/* Higher level functions for accessing search index */

static void search_initialise_index (void);
extern void search_calculate_index_entry (AddressRecord *, int);
static  int search_check_index (char *, int);

/*************************************************************************/
/* Functions which directly access the individual bits of an index entry */

static void search_alter_index_entry (char, int);
static  int search_check_index_entry_for_char (char, int);
/*************************************************************************************/
/************************************************************************************/
#endif


/*********************/
/* Int search stuff */

/* States of the interactive search algorithm */
enum {Search_Operation_Start, Search_Operation_AddChar, Search_Operation_Resync_Phase1,
      Search_Operation_Resync_Phase2, Search_Operation_Resync_Phase3,
      Search_Operation_Resync_Phase3_Writing};

interactive_search_state *intsearch_state_current = NULL;
static interactive_search_state *intsearch_state_saved = NULL;


/************************/
/* Non-int search stuff */

typedef struct nonint_search_queue_entry
{
  struct data
  {
    void *handle;
    int my_ref;
    int sender;
    char *search_field;
    int fields_to_search;
   }data;

  struct nonint_search_queue_entry *next_entry, *previous_entry;

}nonint_search_queue_entry;

static nonint_search_queue_entry *nonint_search_queue_top = NULL, *nonint_search_queue_bottom = NULL;

static void search_nonintqueue_add (void *, int, int, char *, int);
static void search_nonintqueue_remove (void);

/***********************/
/* Update search stuff */

typedef struct update_search_queue_entry
{
  struct
  {
    AddressRecord *rec;
    unsigned int action_code;
  }data;

  struct update_search_queue_entry *next_entry, *previous_entry;

}update_search_queue_entry;

static update_search_queue_entry *update_search_queue_top = NULL,
                                 *update_search_queue_bottom = NULL;


/***************************/
/* Miscallaneous functions */
static void search_home_pressed (void);
static void search_send_return_message (char, AddressRecord *, char *,
                                        char *, char);

/***************************/
/* Search buffer functions */

static void search_buffer_insert (char);
static int search_buffer_get (char *);

/********************************/
/* Local Functions:             */
/* Interactive search functions */

static search_chain_record *search_new_search_chain_item (int *, char *);
static void search_delete_search_chain_item (search_chain_record *);
static void search_destroy_search_chain (void);

static void search_show_results (void);
static int search_interactive_search (int);

static void search_remove_tail (void);
static int search_resync_phase3 (int, int *);
static int search_add_char (int *, int *, char *);

static void search_searchfield_fade (Fade_Action);

static void search_initialise_intsearch (void);


/***********************************/
/* Local Functions:                */
/* Non-Interactve search functions */

static int search_noninteractive_search (int, char *, int, int *);
static void search_noninteractive_searchend (int);


/*********************/
/* Local Functions:  */
/* Update functions  */

static int search_update_search (int, int *);

/* static void search_update_record (int, AddressRecord *); */
static void search_update_searchend (int);
static void search_updatequeue_add (AddressRecord *, unsigned int);
static void search_updatequeue_remove (void);



/**************************************************************************************/
/************************** Code starts here ******************************************/
/**************************************************************************************/


void search_open_oneshot (void)
{
  _kernel_oserror *er;

  writablefield_set_value (0, ABShot_WindowHandle, abshot_fax, "");
  writablefield_set_value (0, ABShot_WindowHandle, abshot_email, "");

  er = ui_open_window (Open_SK_Required, ABShot_WindowHandle, "ABShot_Title",
                       "ABShot_SK1", "ABShot_SK2", "ABShot_SK3", "ABShot_SK4", -1);
  error_check_error (er);
}

void search_open_intsearch (void)
{
  _kernel_oserror *er;

  search_initialise_intsearch ();

  intsearch_state_current->search_mode = SearchMode_Normal;

  /* Open Address book search Screen */
  er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_Title",
                       "ABSearch_SK1", "ABSearch_SK2", "ABSearch_SK3",
                       "ABSearch_SK4", -1);
  error_check_error (er);
}

static void search_finish_nansearch (void)
{
  _kernel_oserror *er;

  switch (action_after_nansearch)
  {
    case AfterNan_Action_OpenAdd:
      /* Open the Add window */
      er = ui_open_window (Open_SK_Required | Open_SK_Narrow, ABAdd_WindowHandle,
                           "ABAdd_Title", "ABAdd_SK1", "ABAdd_SK2",
                           "ABAdd_SK3", "ABAdd_SK4", -1);
      error_check_error (er);
      break;

    case AfterNan_Action_OpenEdit:
      /* Open the Edit window */
      er = ui_open_window (Open_SK_Required | Open_SK_Narrow, ABEdit_WindowHandle,
                           "ABEdit_Title", "ABEdit_SK1", "ABEdit_SK2", "ABEdit_SK3",
                           "ABEdit_SK4", -1);
      error_check_error (er);
      break;

    case AfterNan_Action_OpenMain:
      /* Open the main window */
      runes_open_mainwindow ();
      break;

    case AfterNan_Action_CallDaytona:
      er = ui_open_other_program_window (Open_Daytona_Home, 0);
      error_check_error (er);
      break;

    case AfterNan_Action_RestartSearch:
      intsearch_state_current = intsearch_state_saved;
      writablefield_set_value (0, ABSearch_WindowHandle, absearch_searchfield,
                               intsearch_state_current->searchfield_state.new_field);
      if (intsearch_state_current->working)
      {
        search_searchfield_fade (Fade);
        nullpoll_task |= NullPollTask_IntSearch;
      }
      switch (intsearch_state_current->search_mode)
      {
        case SearchMode_Normal:
          /* Open the nornal Search window */
          er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_Title",
                               "ABSearch_SK1", "ABSearch_SK2", "ABSearch_SK3", "ABSearch_SK4", -1);
          error_check_error (er);
          break;

        case SearchMode_Names:
          /* Open the Names Search window */
          er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_Names_Title",
                               "ABSearch_Names_SK1", "ABSearch_Names_SK2",
                               "ABSearch_Names_SK3", "ABSearch_Names_SK4", -1);
          error_check_error (er);
          break;
      }
      break;
  }
}

void search_open_nansearch (int flags, int my_ref, int sender)
{
  _kernel_oserror *er;

  IGNORE (flags);

  if (ui_currently_open_win == ABAdd_WindowHandle)
    action_after_nansearch = AfterNan_Action_OpenAdd;

  else if (ui_currently_open_win == ABEdit_WindowHandle)
    action_after_nansearch = AfterNan_Action_OpenEdit;

  else if (ui_currently_open_win == Address_WindowHandle)
    action_after_nansearch = AfterNan_Action_OpenMain;

  else if (ui_currently_open_win == NULL)
    action_after_nansearch = AfterNan_Action_CallDaytona;

  else if (ui_currently_open_win == ABSearch_WindowHandle)
  {
    if (nullpoll_task & NullPollTask_IntSearch)
    {
      intsearch_state_current->working = 1;
      nullpoll_task &= ~NullPollTask_IntSearch;
      search_searchfield_fade (UnFade);
    }
    action_after_nansearch = AfterNan_Action_RestartSearch;
    intsearch_state_saved = intsearch_state_current;
    intsearch_state_current = NULL;
  }

  /* Create & Initialise the interactive search data structure */
  search_initialise_intsearch ();

  /* Initialise some more bits */
  intsearch_state_current->your_ref = my_ref;
  intsearch_state_current->sender_taskid = sender;
  intsearch_state_current->search_mode = SearchMode_NAN;

  /* Open the search window */
  er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_NAN_Title",
                       "ABSearch_NAN_SK1", "ABSearch_NAN_SK2", "ABSearch_NAN_SK3",
                       "ABSearch_NAN_SK4", -1);
  error_check_error (er);

  /* The acknowledge the open window request */
  er = ui_open_other_program_window (Open_DayAdd_NANSearch_Ack, 0);
  error_check_error (er);
}

void search_open_namessearch (int flags, int my_ref, int sender)
{
  _kernel_oserror *er;

  /* Create & Initialise the interactive search data structure */
  search_initialise_intsearch ();

  /* Initialise some more bits */
  if (flags & 1)
    intsearch_state_current->names_search_type = 1;
  else
    intsearch_state_current->names_search_type = 0;

  intsearch_state_current->your_ref = my_ref;
  intsearch_state_current->sender_taskid = sender;
  intsearch_state_current->search_mode = SearchMode_Names;

  /* Open the names search window */
  er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_Names_Title",
                       "ABSearch_Names_SK1", "ABSearch_Names_SK2",
                       "ABSearch_Names_SK3", "ABSearch_Names_SK4", -1);
  error_check_error (er);

  /* Then acknowledge the open window request */
  er = ui_open_other_program_window (Open_DayAdd_NamesSearch_Ack, 0);
  error_check_error (er);
}

static void search_free_intsearch_memory (int in_progress)
{
  /* If there's a search structure allocated, free all the memory */
  if (intsearch_state_current)
  {
    dprintf (("", "Freeing\n"));
    search_destroy_search_chain ();

    if (intsearch_state_current->resync_state.partial_field)
      free (intsearch_state_current->resync_state.partial_field);

    if (intsearch_state_current->searchfield_state.old_field)
      free (intsearch_state_current->searchfield_state.old_field);

    if (in_progress)
    {
      if (intsearch_state_current->searchfield_state.new_field)
        free (intsearch_state_current->searchfield_state.new_field);
    }

    free (intsearch_state_current);
    intsearch_state_current = NULL;
  }
}

static void search_initialise_intsearch (void)
{
  writablefield_set_value (0, ABSearch_WindowHandle, absearch_searchfield, "");

  /* If there's a search structure already, free all the memory */
  if (intsearch_state_current)
  {
    dprintf (("", "Freeing memory at the start of a search!!\n"));
    search_destroy_search_chain ();

    if (intsearch_state_current->resync_state.partial_field)
      free (intsearch_state_current->resync_state.partial_field);

    if (intsearch_state_current->searchfield_state.old_field)
      free (intsearch_state_current->searchfield_state.old_field);

/*
    if (intsearch_state_current->searchfield_state.new_field)
      free (intsearch_state_current->searchfield_state.new_field);
*/

    free (intsearch_state_current);
  }

  /* Allocate a new structure */
  intsearch_state_current = (interactive_search_state *) malloc (sizeof (interactive_search_state));

  /* Initialise the new structure */
  intsearch_state_current->search_mode = 0;
  intsearch_state_current->working = 0;
  intsearch_state_current->your_ref = 0;
  intsearch_state_current->sender_taskid = 0;
  intsearch_state_current->current_result_selection = 0;
  intsearch_state_current->search_result = 0;
  intsearch_state_current->search_chain_top = NULL;
  intsearch_state_current->search_chain_current = NULL;
  intsearch_state_current->search_halted = 0;
  intsearch_state_current->resync_state.result_counter = 0;
  intsearch_state_current->resync_state.count = 0;
  intsearch_state_current->resync_state.partial_field = NULL;

  intsearch_state_current->intsearch_state.count = 0;
  intsearch_state_current->intsearch_state.result_counter = 0;
  intsearch_state_current->intsearch_state.operation = 0;

  intsearch_state_current->searchfield_state.buffer_state.index_in = 0;
  intsearch_state_current->searchfield_state.buffer_state.index_out = 0;
  intsearch_state_current->searchfield_state.buffer_state.full = 0;
  intsearch_state_current->searchfield_state.old_len = 0;
  intsearch_state_current->searchfield_state.new_len = 0;
  intsearch_state_current->searchfield_state.old_field = NULL;
  intsearch_state_current->searchfield_state.new_field = NULL;

  /* And call show_results to fill in the search window */
  search_show_results ();
}

void search_oneshot (void)
{
  char *fax, *email;
  char tmp_str[25];
  char c;
  _kernel_oserror *er;
  int ret;
  char search_halted;
  WimpGetPointerInfoBlock	 pointer_info;
  ObjectId			 obj_name;

  /* Get the values from the window */
  fax = miscwimp_get_writable_value (ABShot_WindowHandle, abshot_fax);
  email = miscwimp_get_writable_value (ABShot_WindowHandle, abshot_email);

  tmp_str[0] = '\0';

  if (strlen (fax) || strlen (email))
  {
    if (strlen (fax))
    {
      ret = misc_strip_usernumber (fax);

      /* If we've emptied the fax number string ... */
      if (!strlen (fax))
      {
        /* If we've also got no email address, report an error */
        if (!strlen (email))
        {
          /* Discover the location of the pointer (and hence the location of the
             highlight), and store it locally so we can return to it if
             necessary */
          wimp_get_pointer_info (&pointer_info);
          window_wimp_to_toolbox (0, pointer_info.window_handle,
                                  pointer_info.icon_handle,
                                  &obj_name, &action_after_confirm.gadget_to_highlight);

          /* Tell the user and return to window */
          action_after_confirm.code = ConfirmAction_OpenOneShot;
          er = ui_confirm_window ("ABShot_Title", "AddEditC_NoFaxEmail",
                                  NULL, NULL, "confirm_1", runes_confirm_finished);
          error_check_error (er);
          goto end;
        }
      }
      /* If we still have a fax number to convert ... */
      else
      {
        switch (ret)
        {
           case UserNumber_XWrong:
             action_after_confirm.code = ConfirmAction_OpenOneShot;
             action_after_confirm.gadget_to_highlight = -1;
             er = ui_confirm_window ("ABShot_Title", "AddEditC_XMisplaced",
                                     NULL, NULL, "confirm_1", runes_confirm_finished);
             goto end;

           case UserNumber_PlusWrong:
             action_after_confirm.code = ConfirmAction_OpenOneShot;
             action_after_confirm.gadget_to_highlight = -1;
             er = ui_confirm_window ("ABShot_Title", "AddEditC_PlusMisplaced",
                                     NULL, NULL, "confirm_1", runes_confirm_finished);

             goto end;
        }
        numconvert_entered_to_internal (fax, tmp_str, sizeof (tmp_str),
                                        ip, np, cc, ac);

      }
    }
  }
  else
  {
    /* Discover the location of the pointer (and hence the location of the
       highlight), and store it locally so we can return to it if
       necessary */
    wimp_get_pointer_info (&pointer_info);
    window_wimp_to_toolbox (0, pointer_info.window_handle,
                            pointer_info.icon_handle,
                            &obj_name, &action_after_confirm.gadget_to_highlight);

    action_after_confirm.code = ConfirmAction_OpenOneShot;
    er = ui_confirm_window ("ABShot_Title", "AddEditC_NoFaxEmail",
                            NULL, NULL, "confirm_1", runes_confirm_finished);
    error_check_error (er);
    goto end;
  }

  /* If we've got through to this point, we've validated all the fields, so
     just send the message to Daytona */
  search_send_return_message (DataReturn_Code_OneShotData, NULL, tmp_str, email, 1);

  search_halted = intsearch_state_current->search_halted;

  /* If we were doing a search when we entered the oneshot window, clear up
     the remnants of the search */
  if (search_halted)
  {
    /* Empty the keyboard buffer */
    while (search_buffer_get (&c));

    /* And unfade the writable */
    search_searchfield_fade (UnFade);
  }

  /* Free the memory structure used by the NAN search */
  search_free_intsearch_memory (search_halted);

  /* And return to the window we were in when the NAN search was initiated */
  search_finish_nansearch ();

  end:

  /* Free the temporary storage */
  if (fax)
    free (fax);
  if (email)
    free (email);
}

void search_oneshot_back (void)
{
  _kernel_oserror *er;

  if (intsearch_state_current->search_halted)
  {
    /* Restart the interactive search */
    nullpoll_task |= NullPollTask_IntSearch;

    intsearch_state_current->search_halted = 0;

    /* And unfade the writable
    search_searchfield_fade (UnFade); */
  }
  er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_NAN_Title",
                       "ABSearch_NAN_SK1", "ABSearch_NAN_SK2", "ABSearch_NAN_SK3",
                       "ABSearch_NAN_SK4", -1);
  error_check_error (er);

#if 0
  if (intsearch_state_current->search_halted)
  {
     intsearch_state_current->search_halted = 0;

    /* And put the writable back to unfaded */
/*    search_searchfield_fade (Fade);*/
  }
#endif
}

static void search_send_return_message (char code, AddressRecord *rec, char *oneshot_fax,
                                        char *oneshot_email, char interactive)
{
  int destination;
  Dayt_SearchDataReturn_Message message;
  _kernel_oserror *er;

  AddressArea *area;
  void *end;
  int area_id;

  message.hdr.size = sizeof (Dayt_SearchDataReturn_Message);
  message.hdr.action_code = Dayt_SearchDataReturn_MessageNum;

  if (interactive)
  {
    message.hdr.your_ref = intsearch_state_current->your_ref;
    message.data.handle = (void *) intsearch_state_current->names_search_type;
    destination = intsearch_state_current->sender_taskid;
  }
  else
  {
    message.hdr.your_ref = nonint_search_queue_bottom->data.my_ref;
    message.data.handle = nonint_search_queue_bottom->data.handle;
    destination = nonint_search_queue_bottom->data.sender;
  }

  message.data.code = code;

  switch (code)
  {
    case DataReturn_Code_AddressData:
      area = memhandle_create_area (&end, &area_id);

      strcpy (area->machine_id, rec->machine_id);
      memcpy (area->creation_date, rec->creation_date, sizeof (rec->creation_date));
      strcpy (area->fax_number, rec->fax_number);
      strcpy (area->voice_number, rec->voice_number);
      strcpy (area->software_revision, rec->software_revision);
      area->device_class = rec->device_class;
      area->encryption_method = rec->encryption_method;
      area->encryption_revision = rec->encryption_revision;
      area->pgp_key_length = rec->pgp_key_length;
      area->routing_override = rec->routing_override;
      memhandle_add_string (&area->company_name, rec->company_name, &end, area_id);
      memhandle_add_string (&area->contact_name, rec->contact_name, &end, area_id);
      memhandle_add_string (&area->email_address, rec->email_address, &end, area_id);
      area->pgp_key = NULL;

      message.data.data_area = area;
      message.data.data_area_id = area_id;
      break;

    case DataReturn_Code_OneShotData:
      area = memhandle_create_area (&end, &area_id);

      strcpy (area->oneshot_fax_number, oneshot_fax);
      memhandle_add_string (&area->oneshot_email_address, oneshot_email, &end, area_id);;

      message.data.data_area = area;
      message.data.data_area_id = area_id;
      break;

    case DataReturn_Code_NotFound:
    case DataReturn_Code_Cancelled:
    default:
      message.data.data_area = NULL;
      message.data.data_area_id = -1;
  }

  er = wimp_send_message (Wimp_EUserMessage, &message, destination, 0, 0);
  error_check_error (er);
}

void search_sk1_pressed (void)
{
  AddressRecord *rec;
  _kernel_oserror *er;
  int *result_list;
  int search_mode;
  char search_mode_names;

  if (nullpoll_task & NullPollTask_IntSearch)
  {
    /* We're still busy searching, ignore the keypress */
    return;
  }

  if (intsearch_state_current->search_chain_current)
    result_list = intsearch_state_current->search_chain_current->result_list;
  else
    result_list = flash_used_records_list;

  if (misc_integerlist_findlength (result_list))
  {
    if (intsearch_state_current->search_mode == SearchMode_NAN ||
        intsearch_state_current->search_mode == SearchMode_Names)
    {
      rec = flash_read_record (result_list[intsearch_state_current->current_result_selection]);

#if 0
      /* This check no longer wanted */
      if ((intsearch_state_current->search_mode == SearchMode_Names)
           && (strlen (rec->email_address) == 0))
      {
        action_after_confirm.code = ConfirmAction_OpenNamesSearch;
        action_after_confirm.gadget_to_highlight = -1;
        er = ui_confirm_window ("ABSearch_Names_Title", "ABSearch_Selected3",
                                NULL, NULL, "confirm_1", runes_confirm_finished);
        error_check_error (er);
        misc_free_record_memory (rec);
        return;
      }
#endif

      search_send_return_message (DataReturn_Code_AddressData, rec, NULL, NULL, 1);
      misc_free_record_memory (rec);

      search_mode = intsearch_state_current->search_mode;
      search_mode_names = intsearch_state_current->names_search_type;

      search_free_intsearch_memory (0);

      if (search_mode == SearchMode_NAN)
        search_finish_nansearch ();
      else
      {
        if (search_mode_names == 0)
          er = ui_open_other_program_window (Open_DayNote_Enote, 0);
        else
          er = ui_open_other_program_window (Open_DayNote_Form, 0);
        error_check_error (er);
      }

      return;
    }
    else if (intsearch_state_current->search_mode == SearchMode_Normal)
    {
      intsearch_state_current->search_mode = SearchMode_NoSearch;
      selected_record = result_list[intsearch_state_current->current_result_selection];

      search_free_intsearch_memory (0);
      runes_open_mainwindow ();
    }
  }
  else
  {
    if (intsearch_state_current->search_mode == SearchMode_NAN)
    {
      action_after_confirm.code = ConfirmAction_OpenNANSearch;
      er = ui_confirm_window ("ABSearch_NAN_Title", "ABSearch_Selected2",
                              NULL, NULL, "confirm_1", runes_confirm_finished);
    }
    else if (intsearch_state_current->search_mode == SearchMode_Names)
    {
      action_after_confirm.code = ConfirmAction_OpenNamesSearch;
      er = ui_confirm_window ("ABSearch_Names_Title", "ABSearch_Selected2",
                              NULL, NULL, "confirm_1", runes_confirm_finished);
    }
    else
    {
      action_after_confirm.code = ConfirmAction_OpenSearch;
      er = ui_confirm_window ("ABSearch_Title", "ABSearch_Selected2",
                              NULL, NULL, "confirm_1", runes_confirm_finished);
    }
    error_check_error (er);

    action_after_confirm.gadget_to_highlight = -1;
  }
}

void search_sk2_pressed (void)
{
  _kernel_oserror *er;
  char c, flag = 0;
  char search_mode_names;

  /* If we were in the middle of a search */
  if (nullpoll_task & NullPollTask_IntSearch)
  {
    flag = 1;

    if ((intsearch_state_current->search_mode == SearchMode_Names) ||
        (intsearch_state_current->search_mode == SearchMode_Normal))
    {
      /* Stop the null poll task */
      nullpoll_task &= ~NullPollTask_IntSearch;

      /* Empty the keyboard buffer */
      while (search_buffer_get (&c));

      /* And unfade the writable */
      search_searchfield_fade (UnFade);
    }
  }

  if (intsearch_state_current->search_mode == SearchMode_Names)
  {
    search_send_return_message (DataReturn_Code_Cancelled, NULL, NULL, NULL, 1);

    search_mode_names = intsearch_state_current->names_search_type;

    search_free_intsearch_memory (flag);

    if (search_mode_names == 0)
      er = ui_open_other_program_window (Open_DayNote_Enote, 0);
    else
      er = ui_open_other_program_window (Open_DayNote_Form, 0);
    error_check_error (er);
  }

  else if (intsearch_state_current->search_mode == SearchMode_Normal)
  {
    /* And open the main address book window */
    runes_open_mainwindow ();

    search_free_intsearch_memory (flag);
  }

  else if (intsearch_state_current->search_mode == SearchMode_NAN)
  {
    /* Stop the null poll task */
    if (nullpoll_task & NullPollTask_IntSearch)
    {
      nullpoll_task &= ~NullPollTask_IntSearch;
      intsearch_state_current->search_halted = 1;
    }
    search_open_oneshot ();
  }
}

void search_back_pressed (void)
{
  /* If we're doing a normal or names search, pressing back is like pressing SK2 */
  if ((intsearch_state_current->search_mode == SearchMode_Names) ||
        (intsearch_state_current->search_mode == SearchMode_Normal))
  {
    search_sk2_pressed ();
  }
  else
  {
    /* do we really want to treat this like a "home"? */
    search_home_pressed ();
  }
}

void search_decideaction_cancelnanfax (int code, int action)
{
  _kernel_oserror *er;
  char c;

  IGNORE (code);

  /* cancel was chosen */
  if (action == 1)
  {
    /* Empty the keyboard buffer */
    while (search_buffer_get (&c));

    /* Unfade the writable */
    search_searchfield_fade (UnFade);

    /* Tell Daytona the user cancelled */
    search_send_return_message (DataReturn_Code_Cancelled, NULL, NULL, NULL, 1);

    /* Free the memory used for the NAN search */
    search_free_intsearch_memory (intsearch_state_current->search_halted);

    /* If there's a search saved, clear it also! */
    if (intsearch_state_saved)
    {
      intsearch_state_current = intsearch_state_saved;
      search_free_intsearch_memory (intsearch_state_current->working);
      intsearch_state_saved = intsearch_state_current = NULL;
    }

    /* Call Daytona to open its home window */
    ui_open_other_program_window (Open_Daytona_Home, 0);
  }
  else
  {
    /* If the search was halted when the decide window was brought up, we
       need to restart it before returning to the search window */
    if (intsearch_state_current->search_halted)
    {
      nullpoll_task |= NullPollTask_IntSearch;
      intsearch_state_current->search_halted = 0;
    }

    /* Open the NAN search window */
    er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_NAN_Title",
                         "ABSearch_NAN_SK1", "ABSearch_NAN_SK2", "ABSearch_NAN_SK3",
                         "ABSearch_NAN_SK4", -1);
    error_check_error (er);
  }
}

void search_decideaction_cancelnames (int code, int action)
{
  _kernel_oserror *er;
  char c;

  IGNORE (code);

  /* cancel was chosen */
  if (action == 1)
  {
    /* Empty the keyboard buffer */
    while (search_buffer_get (&c));

    /* Unfade the writable */
    search_searchfield_fade (UnFade);

    /* Tell DayNote the user cancelled */
    search_send_return_message (DataReturn_Code_Cancelled, NULL, NULL, NULL, 1);

    /* Free the memory used for the names search */
    search_free_intsearch_memory (intsearch_state_current->search_halted);

    /* If there's a search saved, clear it also! */
    if (intsearch_state_saved)
    {
      intsearch_state_current = intsearch_state_saved;
      search_free_intsearch_memory (intsearch_state_current->working);
      intsearch_state_saved = intsearch_state_current = NULL;
    }

    /* Call Daytona to open its home window */
    ui_open_other_program_window (Open_Daytona_Home, 0);
  }
  else
  {
    /* If the search was halted when the decide window was brought up, we
       need to restart it before returning to the search window */
    if (intsearch_state_current->search_halted)
    {
      nullpoll_task |= NullPollTask_IntSearch;
      intsearch_state_current->search_halted = 0;
    }

    /* Open the names search window */
    er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_Names_Title",
                         "ABSearch_Names_SK1", "ABSearch_Names_SK2",
                         "ABSearch_Names_SK3", "ABSearch_Names_SK4", -1);
    error_check_error (er);
  }
}

void search_decideaction_canceloneshotfax (int code, int action)
{
  _kernel_oserror *er;
  char c;

  IGNORE (code);

  if (action == 1)
  {
    /* cancel */

    /* Empty the keyboard buffer */
    while (search_buffer_get (&c));

    /* Unfade the writable */
    search_searchfield_fade (UnFade);

    /* Tell Daytona the user cancelled */
    search_send_return_message (DataReturn_Code_Cancelled, NULL, NULL, NULL, 1);

    /* Free the memory used for the NAN search */
    search_free_intsearch_memory (intsearch_state_current->search_halted);

    /* If there's a search saved, clear it also! */
    if (intsearch_state_saved)
    {
      intsearch_state_current = intsearch_state_saved;
      search_free_intsearch_memory (intsearch_state_current->working);
      intsearch_state_saved = intsearch_state_current = NULL;
    }

    /* Call Daytona to open its home window */
    ui_open_other_program_window (Open_Daytona_Home, 0);
  }
  else
  {
    /* Return to the One-Shot window */
    er = ui_open_window (Open_SK_Required, ABShot_WindowHandle, "ABShot_Title",
                         "ABShot_SK1", "ABShot_SK2", "ABShot_SK3", "ABShot_SK4", -1);
    error_check_error (er);
  }
}

static void search_home_pressed (void)
{
  _kernel_oserror *er;
  char c;
  int flag = 0;

  switch (intsearch_state_current->search_mode)
  {
    case SearchMode_Normal:
      /* If we were in the middle of a search */
      if (nullpoll_task & NullPollTask_IntSearch)
      {
        /* Stop the null poll task */
        nullpoll_task &= ~NullPollTask_IntSearch;

        /* Empty the keyboard buffer */
        while (search_buffer_get (&c));

        /* Unfade the writable */
        search_searchfield_fade (UnFade);

        flag = 1;
      }

      /* Tell Daytona to open its window */
      er = ui_open_other_program_window (Open_Daytona_Home, 0);
      error_check_error (er);

      /* Free the memory used for the search */
      search_free_intsearch_memory (flag);

      /* If there's a search saved, clear it also! */
      if (intsearch_state_saved)
      {
        intsearch_state_current = intsearch_state_saved;
        search_free_intsearch_memory (intsearch_state_current->working);
        intsearch_state_saved = intsearch_state_current = NULL;
      }
      break;

    case SearchMode_NAN:
      if (nullpoll_task & NullPollTask_IntSearch)
      {
        /* Stop the null poll task */
        nullpoll_task &= ~NullPollTask_IntSearch;

        intsearch_state_current->search_halted = 1;
      }

      /* Ask for a decision */
      ui_decide_window ("ABSearch_NAN_Title", "Yes", "No", "ABSearch_NAN_Cancel",
                        NULL, NULL, "decide_0", search_decideaction_cancelnanfax, 2);
      break;

    case SearchMode_Names:
      if (nullpoll_task & NullPollTask_IntSearch)
      {
        /* Stop the null poll task */
        nullpoll_task &= ~NullPollTask_IntSearch;

        intsearch_state_current->search_halted = 1;
      }

      /* Ask for a decision */

      /* names search for enote recipient */
      if (intsearch_state_current->names_search_type == 0)
      {
        ui_decide_window ("ABSearch_Names_Title", "Yes", "No", "ABSearch_Names_CancelEnote",
                          NULL, NULL, "decide_0", search_decideaction_cancelnames, 2);
      }
      /* names search for forms recipient */
      else
      {
        ui_decide_window ("ABSearch_Names_Title", "Yes", "No", "ABSearch_Names_CancelForm",
                          NULL, NULL, "decide_0", search_decideaction_cancelnames, 2);
      }

      break;
  }
}

/* Event handler for when a key is pressed in the search window */
int search_window_keypress (int event_code, WimpPollBlock *event,
                            IdBlock *id_block, void *handle)
{
  int *result_list;
  int len, key_code;


  IGNORE (event_code); IGNORE (id_block); IGNORE (handle);

  key_code = event->key_pressed.key_code;

  if (key_code != KeyCode_PageDown && key_code != KeyCode_PageUp &&
      key_code != KeyCode_Down && key_code != KeyCode_Up)
  {
    /* If home's been pressed */
    if (key_code == KeyCode_Home)
      search_home_pressed ();

    else if (isprint (key_code))
    {
      if (nullpoll_task & NullPollTask_IntSearch)
        search_buffer_insert ((char) key_code);
    }

    else
    {
      default_key_handler (event_code, event, id_block, handle);
    }

    return 1;
  }

  if (intsearch_state_current->search_chain_current)
    result_list = intsearch_state_current->search_chain_current->result_list;
  else
    result_list = flash_used_records_list;

  switch (key_code)
  {
    case KeyCode_Down:
      if (event->key_pressed.caret.icon_handle == -1)
      {
        len = misc_integerlist_findlength (result_list);
        if (intsearch_state_current->current_result_selection < (len-1))
          intsearch_state_current->current_result_selection++;
        else
          return 1;
      }
      break;

    case KeyCode_Up:
      if (event->key_pressed.caret.icon_handle == -1)
      {
        if (intsearch_state_current->current_result_selection > 0)
          intsearch_state_current->current_result_selection--;
        else
          return 1;
      }
      break;

    case KeyCode_PageDown:
      len = misc_integerlist_findlength (result_list);
      if (intsearch_state_current->current_result_selection < (len-1))
        intsearch_state_current->current_result_selection++;
      else
        return 1;
      break;

    case KeyCode_PageUp:
      if (intsearch_state_current->current_result_selection > 0)
        intsearch_state_current->current_result_selection--;
      else
        return 1;
      break;
  }
  search_show_results ();

  return 1;
}

static void search_buffer_insert (char c)
{
  if (intsearch_state_current->searchfield_state.buffer_state.full)
    return;

  dprintf (("", "Put '%c' in buffer\n", c));
  intsearch_state_current->searchfield_state.buffer_state.buffer[intsearch_state_current->searchfield_state.buffer_state.index_in] = c;

  intsearch_state_current->searchfield_state.buffer_state.index_in = (intsearch_state_current->searchfield_state.buffer_state.index_in + 1) % BufferSize;

  if (intsearch_state_current->searchfield_state.buffer_state.index_in == intsearch_state_current->searchfield_state.buffer_state.index_out)
    intsearch_state_current->searchfield_state.buffer_state.full = 1;
}

static int search_buffer_get (char *c)
{
  if (intsearch_state_current->searchfield_state.buffer_state.index_in == intsearch_state_current->searchfield_state.buffer_state.index_out)
  {
    if (intsearch_state_current->searchfield_state.buffer_state.full)
    {
      /* buffer full */
      intsearch_state_current->searchfield_state.buffer_state.full = 0;
    }
    else
    {
      /* Buffer empty */
      return 0;
    }
  }

  *c = intsearch_state_current->searchfield_state.buffer_state.buffer[intsearch_state_current->searchfield_state.buffer_state.index_out];
  dprintf (("", "Got '%c' from buffer\n", *c));

  intsearch_state_current->searchfield_state.buffer_state.index_out = (intsearch_state_current->searchfield_state.buffer_state.index_out + 1) % BufferSize;

  return 1;
}

/* Event handler for when search field has changed */
int search_searchfield_changed (int event_code, ToolboxEvent *event,
                                IdBlock *id_block, void *handle)
{
  char *temp_str;

  IGNORE (event_code); IGNORE (event); IGNORE (id_block); IGNORE (handle);

  if (ui_currently_open_win != ABSearch_WindowHandle)
    return 1;

  if (nullpoll_task & NullPollTask_IntSearch)
    return 1;

  if (!intsearch_state_current)
    return 1;

  temp_str = miscwimp_get_writable_value (ABSearch_WindowHandle, absearch_searchfield);
  if (!StrNullCmp (intsearch_state_current->searchfield_state.old_field, temp_str))
  {
    if (temp_str)
      free (temp_str);
    return 1;
  }

  intsearch_state_current->searchfield_state.old_field = intsearch_state_current->searchfield_state.new_field;
  intsearch_state_current->searchfield_state.new_field = temp_str;

  wimp_get_caret_position (&intsearch_state_current->searchfield_state.caret_position);

  /* Fade the search field writable */
  search_searchfield_fade (Fade);
  IconHigh_Stop();

  /* And start the search */
  search_interactive_search (Search_Code_Start);
  nullpoll_task |= NullPollTask_IntSearch;

  return 1;
}

void search_initialise (void)
{
  /* search_initialise_index (); */
}

int search_null_handler (int event_code, WimpPollBlock *event,
                         IdBlock *id_block, void *handle)
{
  int status, i, result;
  char c;
  char *old, *new_str;

  clock_t start;

  /* Call the UI lib null poll handler */
  ui_pollword_handler (event_code, event,  id_block, handle);

  if (nullpoll_task)
  {
    start = clock();

    while (nullpoll_task && ((clock() - start) < 5))
    {

    /* If we're doing an interactive search */
      if ((nullpoll_task & NullPollTask_IntSearch) == NullPollTask_IntSearch)
      {
    #if 0
        if (intsearch_state_current->search_halted)
        {
          intsearch_state_current->search_halted = 0;

          /* And put the writable back to unfaded */
          search_searchfield_fade (Fade);
        }
    #endif
        status = search_interactive_search (Search_Code_Continue);

        if (status == Search_Status_Finished)
        {
          if (intsearch_state_current)
          {
            if (intsearch_state_current->searchfield_state.old_field)
              free (intsearch_state_current->searchfield_state.old_field);
          }

          intsearch_state_current->searchfield_state.old_field =
             intsearch_state_current->searchfield_state.new_field;

          /* Show the search results */
          search_show_results ();

          /* Try to get a character from the keyboard buffer */
          status = search_buffer_get (&c);
          if (status)
          {
            /* If there's one available, add it into the search string at the
               correct point */
            old = miscwimp_get_writable_value (ABSearch_WindowHandle, absearch_searchfield);

            new_str = malloc (strlen (old) + 2);

            for (i = 0; i < intsearch_state_current->searchfield_state.caret_position.index; i++)
              new_str[i] = old[i];

            new_str[intsearch_state_current->searchfield_state.caret_position.index] = c;

            for (i = intsearch_state_current->searchfield_state.caret_position.index;
                        old[i] != '\0'; i++)
            {
              new_str[i+1] = old[i];
            }

            new_str[i+1] = '\0';

            writablefield_set_value (0, ABSearch_WindowHandle, absearch_searchfield, new_str);

            intsearch_state_current->searchfield_state.new_field = new_str;

            if (old)
              free (old);

            intsearch_state_current->searchfield_state.caret_position.index++;

            search_interactive_search (Search_Code_Start);
          }
          else
          {
            /* If there's nothing in the buffer, unfade the writable, and set the caret
               to the correct position */
            search_searchfield_fade (UnFade);
            IconHigh_Start ();
            wimp_set_caret_position (intsearch_state_current->searchfield_state.caret_position.window_handle,
                                     intsearch_state_current->searchfield_state.caret_position.icon_handle,
                                     intsearch_state_current->searchfield_state.caret_position.xoffset,
                                     intsearch_state_current->searchfield_state.caret_position.yoffset,
                                     intsearch_state_current->searchfield_state.caret_position.height,
                                     intsearch_state_current->searchfield_state.caret_position.index);

            /* And stop the null poll task */
            nullpoll_task &= ~NullPollTask_IntSearch;
          }
        }
      }

      /* If we're doing a non-interactive search */
      if ((nullpoll_task & NullPollTask_Search) == NullPollTask_Search)
      {
        status = search_noninteractive_search (Search_Code_Continue, NULL, NULL, &result);

        /* If the search has finished */
        if (status == Search_Status_Finished)
        {
          dprintf (("", "Finished non-interactive search, result = %d\n", result));
          nullpoll_task &= ~NullPollTask_Search;
          search_noninteractive_searchend (result);
        }
      }

      /* If we're doing an update search */
      if ((nullpoll_task & NullPollTask_Update) == NullPollTask_Update)
      {
        int result;

        status = search_update_search (Search_Code_Continue, &result);

        /* If the search has finished */
        if (status == Search_Status_Finished)
        {
          nullpoll_task &= ~NullPollTask_Update;
          search_update_searchend (result);
        }
      }
    }

#if 0
    timings[timings_count++] = clock() - start;

    if (timings_count == 8000)
    {
      FILE *fp;
      int i;

      fp = fopen ("adfs::4.$.overflow", "w");
      for (i=0; i < timings_count; i++)
        fprintf (fp, "%d:   %dcs\n", i, timings[i]);
      timings_count = 0;
      fclose (fp);
    }
#endif
  }

  return 1;
}



/*****************/
void search_noninteractive_searchstart (char *search_field, int fields_to_search,
                                        void *handle, int my_ref, int sender)
{
  char flag = 0;

  /* If the queue's empty, set a flag */
  if (nonint_search_queue_top == NULL)
    flag = 1;

  /* Add an entry to the queue for this search */
  search_nonintqueue_add (handle, my_ref, sender, search_field, fields_to_search);

  /* If the queue was empty, start this search immediately */
  if (flag)
  {
    dprintf (("", "Started non-interactive search in start\n"));
    search_noninteractive_search (Search_Code_Start, search_field, fields_to_search, NULL);

    nullpoll_task |= NullPollTask_Search;
  }
}


/*****************/
void search_update_searchstart (AddressRecord *rec, unsigned int action_code)
{
  char flag = 0;

  /* If the queue's empty, set a flag */
  if (update_search_queue_top == NULL)
    flag = 1;

  rec->routing_override = RoutingOverride_Default; /* Set as default until user
                                                     changes it to something else */

  memcpy (rec->creation_date, "29021997", sizeof (rec->creation_date));  /* From where ? */

  /* Add an entry to the queue for this search */
  search_updatequeue_add (rec, action_code);

  /* If the queue was empty, start this search immediately */
  if (flag)
  {
    dprintf (("", "Started update search in start\n"));

    search_update_search (Search_Code_Start, NULL);

    nullpoll_task |= NullPollTask_Update;
  }
}

/***************************************/
/* Search engine functions (all local) */


/******************************/
static void search_noninteractive_searchend (int result)
{
  AddressRecord *rec = NULL;

  /* If no match was found, send the NotFound message */
  if (result == 0)
  {
    search_send_return_message (DataReturn_Code_NotFound, NULL, NULL, NULL, 0);
  }
  else
  {
    /* Else, read the matching record .. */
    rec = flash_read_record (result);

    /* Send the message */
    search_send_return_message (DataReturn_Code_AddressData, rec, NULL, NULL, 0);

    /* And free the temporary storage */
    misc_free_record_memory (rec);
  }

  /* Remove the current search entry from the queue */
  search_nonintqueue_remove ();

  /* And if there's something in the queue, start a search */
  if (nonint_search_queue_bottom != NULL)
  {
    dprintf (("", "Started non-interactive search in end\n"));
    search_noninteractive_search (Search_Code_Start, nonint_search_queue_bottom->data.search_field,
                                  nonint_search_queue_bottom->data.fields_to_search, NULL);

    nullpoll_task |= NullPollTask_Search;
  }
}


/******************************/
static void search_update_searchend (int result)
{
  int ret;
  AddressRecord *matched_rec = NULL, *update_rec;

  update_rec = update_search_queue_bottom->data.rec;

  if (update_search_queue_bottom->data.action_code == AddressModify_ActionCode_ModifyDeviceClass)
  {
    if (result != 0)
    {
      dprintf (("", "Found match at page %d.\n", result));
      matched_rec = flash_read_record (result);

      if (matched_rec->device_class != update_rec->device_class)
      {
        /* Replace the device class in the matched record with the new one */
        matched_rec->device_class = update_rec->device_class;

        dprintf (("", "Delete old record, then add new\n"));

        /* Delete the old record */
        flash_delete_record (result);

        /* Then add new */
        ret = flash_write_record (matched_rec);

        if (result != 0)
        {
          /* If we're currently displaying the updated record, we need to change
             the number of the selected record to the new version, and redraw the
             main address book window */
          if (result == selected_record)
          {
            dprintf (("", "In here\n"));
            selected_record = ret;
            runes_complete_mainwindow ();
          }
        }
        dprintf (("", "Wrote new record at page %d\n", ret));

        /* Free some memory */
        misc_free_record_memory (matched_rec);
      }
    }
  }
  else if (update_search_queue_bottom->data.action_code == AddressModify_ActionCode_Update)
  {

    if (result != 0)
    {
      dprintf (("", "Found match at page %d.\n", result));

      matched_rec = flash_read_record (result);

      if (StrNullCmp (matched_rec->machine_id, update_rec->machine_id) == 0)
      {
        if (matched_rec->device_class == update_rec->device_class)
        {
          if (StrNullCmp (matched_rec->company_name, update_rec->company_name) == 0)
          {
            if (StrNullCmp (matched_rec->contact_name, update_rec->contact_name) == 0)
            {
              if (StrNullCmp (matched_rec->fax_number, update_rec->fax_number) == 0)
              {
                if (StrNullCmp (matched_rec->voice_number, update_rec->voice_number) == 0)
                {
                  if (StrNullCmp (matched_rec->email_address, update_rec->email_address) == 0)
                  {
                    if (memcmp (matched_rec->creation_date, update_rec->creation_date,
                                sizeof (matched_rec->creation_date)) == 0)
                    {
                      if (StrNullCmp (matched_rec->software_revision, update_rec->software_revision) == 0)
                      {
                        dprintf (("", "Exact match, no need to do anything!!!!!!!!\n"));
                        goto update_searchend_end;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      dprintf (("", "Delete old record, then add new\n"));

      /* Delete the old record */
      flash_delete_record (result);

      /* If the fax number has been entered as an extension, we want to keep it */
      if (matched_rec->fax_number[0] == '-')
        strcpy (update_rec->fax_number, matched_rec->fax_number);

      /* And the same for the voice number, I guess */
      if (matched_rec->voice_number[0] == '-')
        strcpy (update_rec->voice_number, matched_rec->voice_number);

      /* Free some memory */
      misc_free_record_memory (matched_rec);
    }
    else
      dprintf (("", "Search failed...just add new record.\n"));

    /* Write the new record */
    ret = flash_write_record (update_rec);

    if (result != 0)
    {
      /* If we're currently displaying the updated record, we need to change
         the number of the selected record to the new version, and redraw the
         main address book window */
      if (result == selected_record)
      {
        dprintf (("", "In here\n"));
        selected_record = ret;
        runes_complete_mainwindow ();
      }
    }
    dprintf (("", "Wrote new record at page %d\n", ret));
  }

  update_searchend_end:

  /* Remove the current search entry from the queue */
  search_updatequeue_remove ();

  /* And if there's something in the queue, start a search */
  if (update_search_queue_bottom != NULL)
  {
    dprintf (("", "Started update search in end\n"));
    search_update_search (Search_Code_Start, NULL);

    nullpoll_task |= NullPollTask_Update;
  }
}


/*******************/
static void search_nonintqueue_add (void *handle, int my_ref, int sender, char *search_field,
                                    int fields_to_search)
{
  nonint_search_queue_entry *temp_ptr;

  /* Allocate a new entry */
  temp_ptr = malloc (sizeof (nonint_search_queue_entry));

  /* Enter the data */
  temp_ptr->data.handle = handle;
  temp_ptr->data.my_ref = my_ref;
  temp_ptr->data.sender = sender;
  temp_ptr->data.search_field = strdup (search_field);
  temp_ptr->data.fields_to_search = fields_to_search;

  /* Link 'er up */
  if (nonint_search_queue_top)
  {
    nonint_search_queue_top->previous_entry = temp_ptr;
  }
  temp_ptr->next_entry = nonint_search_queue_top;
  temp_ptr->previous_entry = NULL;

  /* And set the queue top pointer to the new entry */
  nonint_search_queue_top = temp_ptr;

  /* If we've only just populated the queue, make top=bottom */
  if (nonint_search_queue_bottom == NULL)
    nonint_search_queue_bottom = nonint_search_queue_top;
}


/****************************/
static void search_nonintqueue_remove (void)
{
  nonint_search_queue_entry *temp_ptr;

  if (nonint_search_queue_bottom)
  {
    /* Unlink the bottom entry */
    temp_ptr = nonint_search_queue_bottom;
    if (nonint_search_queue_bottom->previous_entry)
      nonint_search_queue_bottom->previous_entry->next_entry = NULL;
    nonint_search_queue_bottom = nonint_search_queue_bottom->previous_entry;

    /* And free it */
    if (temp_ptr->data.search_field)
      free (temp_ptr->data.search_field);
    free (temp_ptr);
  }

  /* If we've just emptied the queue, reset the top pointer to NULL */
  if (nonint_search_queue_bottom == NULL)
    nonint_search_queue_top = NULL;
}


/**************************/
static void search_updatequeue_add (AddressRecord *rec, unsigned int action_code)
{
  update_search_queue_entry *temp_ptr;

  /* Allocate a new entry */
  temp_ptr = malloc (sizeof (update_search_queue_entry));

  /* Enter the data */
  temp_ptr->data.rec = misc_copy_record (rec);
  temp_ptr->data.action_code = action_code;

  /* Link 'er up */
  if (update_search_queue_top)
  {
    update_search_queue_top->previous_entry = temp_ptr;
  }
  temp_ptr->next_entry = update_search_queue_top;
  temp_ptr->previous_entry = NULL;

  /* And set the queue top pointer to the new entry */
  update_search_queue_top = temp_ptr;

  /* If we've only just populated the queue, make top=bottom */
  if (update_search_queue_bottom == NULL)
    update_search_queue_bottom = update_search_queue_top;
}


/***************/
static void search_updatequeue_remove (void)
{
  update_search_queue_entry *temp_ptr;

  if (update_search_queue_bottom)
  {
    /* Unlink the bottom entry */
    temp_ptr = update_search_queue_bottom;
    if (update_search_queue_bottom->previous_entry)
      update_search_queue_bottom->previous_entry->next_entry = NULL;
    update_search_queue_bottom = update_search_queue_bottom->previous_entry;

    /* And free it */
    if (temp_ptr->data.rec)
      misc_free_record_memory (temp_ptr->data.rec);
    free (temp_ptr);
  }

  /* If we've just emptied the queue, reset the top pointer to NULL */
  if (update_search_queue_bottom == NULL)
    update_search_queue_top = NULL;
}


/********************/
/* Update functions */


/***********************/
static int search_update_search (int code, int *search_result)
{
  static int record_index = 0;
  int record_num;
  AddressRecord *rec = NULL;
  char *match;
  static int mode = 0;

  if (code == Search_Code_Start)
  {
    record_index = 0;
    mode = 0;

    return Search_Status_InProgress;
  }

  /* main search */

  record_num = flash_used_records_list[record_index++];

  /* We've gone through all the records, and found no match */
  if (record_num == -1)
  {
    if (mode == 0)
    {
      mode = 1;
      record_index = 0;
      dprintf (("", "Now checking fax #\n"));

      return Search_Status_InProgress;
    }
    else
    {
      *search_result = 0;
      return Search_Status_Finished;
    }
  }

  if (mode == 0)
  {
    match = update_search_queue_bottom->data.rec->machine_id;
  }
  else
  {
    match = update_search_queue_bottom->data.rec->fax_number;
  }

  rec = flash_read_record (record_num);

  if (mode == 0)
  {
    if (!StrNullCmp (match, rec->machine_id))
    {
      /* Free up the memory used for the record */
      misc_free_record_memory (rec);

      *search_result = record_num;
      return Search_Status_Finished;
    }
  }
  else
  {
    if (!StrNullCmp (match, rec->fax_number))
    {
      /* Free up the memory used for the record */
      misc_free_record_memory (rec);

      *search_result = record_num;
      return Search_Status_Finished;
    }
  }

  return Search_Status_InProgress;
}

/************************************/
/* Non-Interactive search functions */

/*********************/
static int search_noninteractive_search (int code, char *search_field,
                                         int fields_to_search, int *result_p)
{
  static int record_index = 0;
  static char *string_to_match = NULL;
  static int search_mask = 0;
  int record_num;
  AddressRecord *rec = NULL;

  if (code == Search_Code_Start)
  {
    record_index = 0;
   /* nonint_search_result = 0; */

    if (string_to_match)
      free (string_to_match);

    string_to_match = strdup (search_field);
    search_mask = fields_to_search;

    return Search_Status_InProgress;
  }

  record_num = flash_used_records_list[record_index++];

  /* We've gone through all the records, and found no match */
  if (record_num == -1)
  {
    if (string_to_match)
    {
      free (string_to_match);
      string_to_match = NULL;
    }

  /*  nonint_search_result = 0; */
    *result_p = 0;

    return Search_Status_Finished;
  }

#if 0
  /* Check index for search string */
  if (search_check_index (string_to_match, record_num))
  {
#endif
    /* If found, read record from flash */
    rec = flash_read_record (record_num);

    /* Then, for each search key, check for a match */

    if (search_mask & Field_ContactName)
    {
      if (!StrNullCmp (string_to_match, rec->contact_name))
        goto nonint_match;
    }
    if (search_mask & Field_CompanyName)
    {
      if (!StrNullCmp (string_to_match, rec->company_name))
        goto nonint_match;
    }
    if (search_mask & Field_MachineID)
    {
      if (!StrNullCmp (string_to_match, rec->machine_id))
        goto nonint_match;
    }
    if (search_mask & Field_EmailAddress)
    {
      if (!StrNullCmp (string_to_match, rec->email_address))
        goto nonint_match;
    }
    if (search_mask & Field_FaxNumber)
    {
      if (!StrNullCmp (string_to_match, rec->fax_number))
        goto nonint_match;
    }
    if (search_mask & Field_VoiceNumber)
    {
      if (!StrNullCmp (string_to_match, rec->voice_number))
        goto nonint_match;
    }
    if (search_mask & Field_DeviceClass)
    {
      if (((unsigned int)atoi (string_to_match)) == rec->device_class)
        goto nonint_match;
    }
    if (search_mask & Field_SoftwareRevision)
    {
      if (!StrNullCmp (string_to_match, rec->software_revision))
        goto nonint_match;
    }
    if (search_mask & Field_EncryptionMethod)
    {
      if (((unsigned int)atoi (string_to_match)) == rec->encryption_method)
        goto nonint_match;
    }
    if (search_mask & Field_EncryptionRevision)
    {
      if (((unsigned int)atoi (string_to_match)) == rec->encryption_revision)
        goto nonint_match;
    }
    if (search_mask & Field_RoutingOverride)
    {
      if (((char)atoi (string_to_match)) == rec->routing_override)
        goto nonint_match;
    }
    if (search_mask & Field_CreationDate)
    {
      if (!memcmp (string_to_match, rec->creation_date, sizeof (rec->creation_date)))
        goto nonint_match;
    }

    /* Free up the memory used for the record */
    misc_free_record_memory (rec);
#if 0
  }
#endif

  /* If we've fallen through to here, we carry on to the next record */
  return Search_Status_InProgress;

  nonint_match:

  /* Free up the memory used for the record */
  misc_free_record_memory (rec);

  if (string_to_match)
  {
    free (string_to_match);
    string_to_match = NULL;
  }

  /* nonint_search_result = record_num; */
  *result_p = record_num;

  return Search_Status_Finished;
}

/********************************/
/* Interactive search functions */

/**************************/
static int search_interactive_search (int code)
{
  int rc = Search_Status_Finished;

  int old_len = strlen (intsearch_state_current->searchfield_state.old_field);
  int new_len = strlen (intsearch_state_current->searchfield_state.new_field);

  if (code == Search_Code_Start)
  {
    intsearch_state_current->intsearch_state.count = 0;
    intsearch_state_current->intsearch_state.result_counter = 0;

    intsearch_state_current->intsearch_state.operation = Search_Operation_Start;
    return Search_Status_InProgress;
  }

  /* Do the operation of calculating a new chain entry
     for adding a character */
  switch (intsearch_state_current->intsearch_state.operation)
  {
    case Search_Operation_Start:
      /* If no other case is found, we must resyncronise the
       search chain, starting at Phase 1 */
      intsearch_state_current->intsearch_state.operation = Search_Operation_Resync_Phase1;

      rc = Search_Status_InProgress;

      if ((new_len - old_len) == 1)
      {
        if (old_len == 0)
        {
          /* One char has been added to an empty search term, we
             need to make the search chain top entry */
          intsearch_state_current->intsearch_state.operation = Search_Operation_AddChar;
        }
        else if (strncmp (intsearch_state_current->searchfield_state.old_field,
                          intsearch_state_current->searchfield_state.new_field, old_len) == NULL)
        {
          /* One char has been added to the current search chain
             entry, we must add a new entry for this on the
             end of the chain */
          intsearch_state_current->intsearch_state.operation = Search_Operation_AddChar;
        }
      }
      else if ((old_len - new_len) == 1)
      {
        if (strncmp (intsearch_state_current->searchfield_state.old_field,
                     intsearch_state_current->searchfield_state.new_field, new_len) == NULL)
        {
          /* One character has been removed from the current
             search chain entry, we will remove the current search
             chain entry, and return the results of the previous
             entry */
          search_remove_tail ();
          rc = Search_Status_Finished;
        }
      }
      switch (intsearch_state_current->intsearch_state.operation)
      {
        case Search_Operation_Resync_Phase1:
          if (rc == Search_Status_InProgress)
            dprintf (("", ">>>>>>>>>>>>>Resync\n"));
          else
            dprintf (("", ">>>>>>>>>>>>>Remove tail\n"));
          break;
        case Search_Operation_AddChar:
          dprintf (("", ">>>>>>>>>>>>>Add char\n"));
          break;
      }
      break;

    case Search_Operation_AddChar:
      rc = search_add_char (&intsearch_state_current->intsearch_state.result_counter,
                            &intsearch_state_current->intsearch_state.count,
                             intsearch_state_current->searchfield_state.new_field);
      break;

    case Search_Operation_Resync_Phase1:
      /* First step back down the chain till you have the same
         length of string as for the search field, possibly emptying the chain */

      if (intsearch_state_current->search_chain_current != NULL)
      {
        if (new_len < strlen (intsearch_state_current->search_chain_current->search_term))
          search_remove_tail ();
        else
          intsearch_state_current->intsearch_state.operation = Search_Operation_Resync_Phase2;
      }
      else
      {
        /* We've removed the whole chain, go to Phase 3 */
        intsearch_state_current->search_chain_top = NULL;
        intsearch_state_current->intsearch_state.operation = Search_Operation_Resync_Phase3;
      }

      rc = Search_Status_InProgress;
      break;

    case Search_Operation_Resync_Phase2:
      /* Then step down the search chain until you get a match on the first
         chars in the search field, possibly emptying the chain */
      if (intsearch_state_current->search_chain_current != NULL)
      {
        if (strncmp (intsearch_state_current->search_chain_current->search_term,
                     intsearch_state_current->searchfield_state.new_field,
                     strlen (intsearch_state_current->search_chain_current->search_term)) != 0)
        {
          search_remove_tail ();
        }
        else
          intsearch_state_current->intsearch_state.operation = Search_Operation_Resync_Phase3;
      }
      else
      {
        /* We've removed the whole chain, go to Phase 3 */
        intsearch_state_current->search_chain_top = NULL;
        intsearch_state_current->intsearch_state.operation = Search_Operation_Resync_Phase3;
      }
      rc = Search_Status_InProgress;
      break;

    case Search_Operation_Resync_Phase3:
    case Search_Operation_Resync_Phase3_Writing:
      /* Rebuild search chain...possibly from scratch. */

      /* If the search field is empty, ensure search chain is empty, and finish */
      if (strlen (intsearch_state_current->searchfield_state.new_field) < 1)
      {
        search_destroy_search_chain ();
        rc = Search_Status_Finished;
      }
      else
      {
        if (intsearch_state_current->intsearch_state.operation == Search_Operation_Resync_Phase3)
          rc = search_resync_phase3 (1, &intsearch_state_current->intsearch_state.operation);
        else
          rc = search_resync_phase3 (0, &intsearch_state_current->intsearch_state.operation);
      }
  }

  return rc;
}


/*******************/
static int search_resync_phase3 (int start, int *operation)
{
  int status;
  int len;

  int full_len = strlen (intsearch_state_current->searchfield_state.new_field);


  /* If we're starting a new character */
  if (start)
  {
    *operation = Search_Operation_Resync_Phase3_Writing;
    intsearch_state_current->resync_state.result_counter = 0;
    intsearch_state_current->resync_state.count = 0;

    if (intsearch_state_current->resync_state.partial_field)
      free (intsearch_state_current->resync_state.partial_field);

    if (intsearch_state_current->search_chain_top == NULL)
      len = 1;
    else
      len = strlen (intsearch_state_current->search_chain_current->search_term) + 1;

    intsearch_state_current->resync_state.partial_field = malloc (len + 1);
    strncpy (intsearch_state_current->resync_state.partial_field,
             intsearch_state_current->searchfield_state.new_field, len);
    intsearch_state_current->resync_state.partial_field[len] = '\0';
  }

  if (intsearch_state_current->search_chain_top == NULL)
  {
    status = search_add_char (&intsearch_state_current->resync_state.result_counter,
                              &intsearch_state_current->resync_state.count,
                               intsearch_state_current->resync_state.partial_field);

    if (status == Search_Status_Finished)
      *operation = Search_Operation_Resync_Phase3;

    return Search_Status_InProgress;
  }
  else
  {
    /* If we've re-constructed the whole search tree */
    if (strlen (intsearch_state_current->search_chain_current->search_term) == full_len)
    {
      /* Return the finished status */
      return Search_Status_Finished;
    }
    else
    {
      /* Continue to add the next character in the sequence */
      status = search_add_char (&intsearch_state_current->resync_state.result_counter,
                                &intsearch_state_current->resync_state.count,
                                 intsearch_state_current->resync_state.partial_field);

      /* If we've finished a character, continue on to the next */
      if (status == Search_Status_Finished)
        *operation = Search_Operation_Resync_Phase3;

      return Search_Status_InProgress;
    }
  }
  /* Should never reach here */
  return Search_Status_InProgress;
}

/*******************/
static int search_add_char (int *result_counter, int *count, char *search_field)
{
  AddressRecord *rec;
  int record_num;
  search_chain_record *temp_ptr;
  char temp_str[25];
  char temp_str2[25];

  if (intsearch_state_current->search_chain_current == NULL)
    record_num = flash_used_records_list[*count];
  else
    record_num = intsearch_state_current->search_chain_current->result_list[*count];

  /* If we haven't finished searching... */
  if (record_num != -1)
  {
#if 0
    if (search_check_index (search_field, record_num))
    {
#endif
      /* Read the record */
      rec = flash_read_record (record_num);

#if 1
      /* it's probably a telephone number */
      if (isdigit (search_field[0]) || search_field[0] == 'x' ||
          search_field[0] == '+')
      {
        /* special case */
        if ((strlen (search_field) == 1) && (search_field[0] == np[0]))
        {
          if (strlen (rec->fax_number))
          {
            if (rec->fax_number[0] != '-')
            {
              dprintf (("", "special case, fax = \"%s\", voice = \"%s\"\n", rec->fax_number,
                            rec->voice_number));
              intsearch_state_current->addchar_result_list[(*result_counter)++] = record_num;
              goto addchar_match;
            }
          }
          if (strlen (rec->voice_number))
          {
            if (rec->voice_number[0] != '-')
            {
              dprintf (("", "special case, fax = \"%s\", voice = \"%s\"\n", rec->fax_number,
                         rec->voice_number));
              intsearch_state_current->addchar_result_list[(*result_counter)++] = record_num;
              goto addchar_match;
            }
          }
        }

        /* Convert the entered number into internal format */
        strncpy (temp_str, search_field, sizeof (temp_str));
        temp_str[24] = '\0';
        if (temp_str[0] == 'x')
          temp_str[0] = '-';
        numconvert_entered_to_internal (temp_str, temp_str2, sizeof (temp_str2),
                                        ip, np, cc, ac);

        /* and see if it matches either the fax or voice number */
        if (strings_match (temp_str2, rec->fax_number) ||
            strings_match (temp_str2, rec->voice_number))
        {
          if (strings_match (temp_str2, rec->fax_number))
          {
            dprintf (("", "converted input = \"%s\", fax match = \"%s\"\n", temp_str2,
                      rec->fax_number));
          }
          else
          {
            dprintf (("", "converted input = \"%s\", voice match = \"%s\"\n", temp_str2,
                      rec->voice_number));
          }

          intsearch_state_current->addchar_result_list[(*result_counter)++] = record_num;
          goto addchar_match;
        }
      }
#else
      numconvert_internal_to_display (rec->fax_number, temp_str2, sizeof (temp_str2),
                                      ip, np, cc, ac);
      if (strings_match (search_field, temp_str2))
      {
        intsearch_state_current->addchar_result_list[(*result_counter)++] = record_num;
        goto addchar_match;
      }
      numconvert_internal_to_display (rec->voice_number, temp_str2, sizeof (temp_str2),
                                      ip, np, cc, ac);
      if (strings_match (search_field, temp_str2))
      {
        intsearch_state_current->addchar_result_list[(*result_counter)++] = record_num;
        goto addchar_match;
      }
#endif

      /* Check for substring matches in the record fields */
      if (strings_match (search_field, rec->contact_name) ||
          strings_match (search_field, rec->company_name) ||
          strings_match (search_field, rec->email_address))
      {
        /* If the record matches, add an entry to the result list */
        intsearch_state_current->addchar_result_list[(*result_counter)++] = record_num;
      }

      addchar_match:

      /* Free the memory used for the record */
      misc_free_record_memory (rec);
#if 0
    }
#endif

    (*count)++;

    return Search_Status_InProgress;
  }

  intsearch_state_current->addchar_result_list[*result_counter] = -1;

  if (intsearch_state_current->search_chain_top == NULL)
  {
    intsearch_state_current->search_chain_top = intsearch_state_current->search_chain_current =
        search_new_search_chain_item (intsearch_state_current->addchar_result_list, search_field);
    intsearch_state_current->search_chain_top->next =
        intsearch_state_current->search_chain_top->previous = NULL;
  }
  else
  {
    temp_ptr = search_new_search_chain_item (intsearch_state_current->addchar_result_list,
                                             search_field);
    intsearch_state_current->search_chain_current->next = temp_ptr;
    temp_ptr->previous = intsearch_state_current->search_chain_current;
    temp_ptr->next = NULL;
    intsearch_state_current->search_chain_current = temp_ptr;
  }
  return Search_Status_Finished;
}

/***********/
static void search_remove_tail (void)
{
  search_chain_record *temp_ptr;

  /* Delink the last item on the search chain */
  temp_ptr = intsearch_state_current->search_chain_current;
  intsearch_state_current->search_chain_current =
      intsearch_state_current->search_chain_current->previous;

  /* And free the memory */
  search_delete_search_chain_item (temp_ptr);

  /* And finish the linking */
  if (intsearch_state_current->search_chain_current)
    intsearch_state_current->search_chain_current->next = NULL;
  else
    intsearch_state_current->search_chain_top = NULL;
}


/* Make a new search chain item */
static search_chain_record *search_new_search_chain_item (int *result_list,
                                                          char *search_term)
{
  search_chain_record *new_item = NULL;

  new_item = (search_chain_record *) malloc (sizeof (search_chain_record));

  new_item->search_term = strdup (search_term);
  new_item->result_list = misc_integerlist_copy (result_list);
  new_item->next = new_item->previous = NULL;

  return new_item;
}


/* Delete a whole search chain */
static void search_destroy_search_chain (void)
{
  search_chain_record *temp_ptr = NULL, *temp_ptr2 = NULL;

  temp_ptr = intsearch_state_current->search_chain_top;

  while (temp_ptr != NULL)
  {
    temp_ptr2 = temp_ptr->next;
    search_delete_search_chain_item (temp_ptr);
    temp_ptr = temp_ptr2;
  }
  intsearch_state_current->search_chain_top = intsearch_state_current->search_chain_current = NULL;
}


/* Delete a search chain item */
static void search_delete_search_chain_item (search_chain_record *to_delete)
{
  if (to_delete)
  {
    if (to_delete->search_term)
      free (to_delete->search_term);
    if (to_delete->result_list)
      free (to_delete->result_list);
    free (to_delete);
    to_delete = NULL;
  }
}


/* Show the current search results in the result window */
static void search_show_results (void)
{
  AddressRecord *rec;
  int len;
  int *result_list;
  char num[15];
  char temp_str[25];

  if (intsearch_state_current->search_chain_current != NULL)
    result_list = intsearch_state_current->search_chain_current->result_list;
  else
    result_list = flash_used_records_list;

  len = misc_integerlist_findlength (result_list);
  if (len > 0)
  {
    if (intsearch_state_current->current_result_selection > (len -1))
      intsearch_state_current->current_result_selection = len - 1;

    sprintf (num, "%d / %d", intsearch_state_current->current_result_selection+1, len);
    button_set_value (0, ABSearch_WindowHandle, absearch_numberfound, num);

    rec = flash_read_record (result_list[intsearch_state_current->current_result_selection]);

    button_set_value (0, ABSearch_WindowHandle, absearch_name, rec->contact_name);
    button_set_value (0, ABSearch_WindowHandle, absearch_company,
                      rec->company_name);
    button_set_value (0, ABSearch_WindowHandle, absearch_email,
                      rec->email_address);

    if (strlen (rec->fax_number))
    {
      numconvert_internal_to_display (rec->fax_number, temp_str, sizeof (temp_str),
                                      ip, np, cc, ac);
    }
    else
      temp_str[0] = '\0';
    button_set_value (0, ABSearch_WindowHandle, absearch_fax, temp_str);

    if (strlen (rec->voice_number))
    {
      numconvert_internal_to_display (rec->voice_number, temp_str, sizeof (temp_str),
                                      ip, np, cc, ac);
    }
    else
      temp_str[0] = '\0';
    button_set_value (0, ABSearch_WindowHandle, absearch_voice, temp_str);

    switch (rec->routing_override)
    {
      case 0:
        button_set_value (0, ABSearch_WindowHandle, absearch_routing,
                          lookup_message_token (&message_block, "ABSearch_RoutingDefault"));
        break;
      case 1:
        button_set_value (0, ABSearch_WindowHandle, absearch_routing,
                          lookup_message_token (&message_block, "ABSearch_RoutingPhone"));
        break;
      default:
        button_set_value (0, ABSearch_WindowHandle, absearch_routing,
                          lookup_message_token (&message_block, "ABSearch_RoutingEmail"));
        break;
    }

    /* Free up the memory used for the record */
    misc_free_record_memory (rec);

    return;
  }
  else
  {
    intsearch_state_current->current_result_selection = 0;

    button_set_value (0, ABSearch_WindowHandle, absearch_numberfound, "0 / 0");
    button_set_value (0, ABSearch_WindowHandle, absearch_name, "");
    button_set_value (0, ABSearch_WindowHandle, absearch_company, "");
    button_set_value (0, ABSearch_WindowHandle, absearch_fax, "");
    button_set_value (0, ABSearch_WindowHandle, absearch_voice, "");
    button_set_value (0, ABSearch_WindowHandle, absearch_email, "");
    button_set_value (0, ABSearch_WindowHandle, absearch_routing, "");
  }
}

/******************/
/* Misc functions */

/* Fade/Unfade the search field writablefield */
static void search_searchfield_fade (Fade_Action action_code)
{
  if (action_code == Fade)
  {
    /* Then fade the writable */
    miscwimp_fade_gadget (ABSearch_WindowHandle, absearch_searchfield, Fade);

    /* Set an invisible caret */
    wimp_set_caret_position (intsearch_state_current->searchfield_state.caret_position.window_handle,
                             -1, 0, 0, (1 << 25), 0);
  }
  else if (action_code == UnFade)
  {
    /* First, unfade the writable */
    miscwimp_fade_gadget (ABSearch_WindowHandle, absearch_searchfield, UnFade);
  }
}




#if 0

/**********************/
/* Indexing functions */


/* Initialises the search index for all the address records currently in flash */
static void search_initialise_index (void)
{
  int len, i;
  AddressRecord *rec;

  len = misc_integerlist_findlength (flash_used_records_list);

  for (i=0; i < len; i++)
  {
    rec = flash_read_record (flash_used_records_list[i]);

    search_calculate_index_entry (rec, flash_used_records_list[i]);

    /* Free up the memory used for the record */
    misc_free_record_memory (rec);
  }
}


/* Calculates the index entry for the address record "rec" which is indexed by
   "first_page" */
void search_calculate_index_entry (AddressRecord *rec, int first_page)
{
  int i, len;
  int index_num;

  /* Convert from "record's FirstPage indexing base" to indexing base for index */
  index_num = first_page - 48;

  /* Initialise index entry */
  search_search_index[index_num].a_to_z = 0;
  search_search_index[index_num].square_to_dash = 0;
  search_search_index[index_num].zero_to_nine = 0;
  search_search_index[index_num].space_to_slash = 0;
  search_search_index[index_num].colon_to_at = 0;
  search_search_index[index_num].curly_to_tilde = 0;

  len = strlen (rec->contact_name);
  for (i=0; i < len; i++)
    search_alter_index_entry (rec->contact_name[i], index_num);

  len = strlen (rec->company_name);
  for (i=0; i < len; i++)
    search_alter_index_entry (rec->company_name[i], index_num);

  len = strlen (rec->fax_number);
  for (i=0; i < len; i++)
    search_alter_index_entry (rec->fax_number[i], index_num);

  len = strlen (rec->voice_number);
  for (i=0; i < len; i++)
    search_alter_index_entry (rec->voice_number[i], index_num);

  len = strlen (rec->email_address);
  for (i=0; i < len; i++)
    search_alter_index_entry (rec->email_address[i], index_num);
}


/* Checks whether all the characters in the string "check_list" appear in the index
   entry for the address record indexed by "first_page" */
static int search_check_index (char *check_list, int first_page)
{
  int len;
  int i;
  int index_num;

  /* Calculate the index offset for this record */
  index_num = first_page - 48;

  len = strlen (check_list);
  for (i = 0; i < len; i++)
  {
    /* Check the index entry for each character of "usage_string". If any
       of these characters is not found in the index entry, return 0 to indicate
       that the record DOES NOT contain the chacaters in "usage_list" */
    if (!search_check_index_entry_for_char (check_list[i], index_num))
      return 0;
  }

  /* If this point is reached it means that every character of the usage list
     was found in the string, so return one to return 1 to indicate that the record
     DOES contain the characters in "usage_list" */
  return 1;
}


/* Alters the index entry indexed by "index_num" so that it includes the character "c" */
static void search_alter_index_entry (char c, int index_num)
{
  /* If the character isn't printable, no work to do */
  if (!(isprint (c)))
    return;

  /* a to z */
  if (isalpha (c))
    search_search_index[index_num].a_to_z |= 1 << (toupper(c) - 'A');
  /* 0 to 9 */
  else if (isdigit (c))
    search_search_index[index_num].zero_to_nine |= 1 << (c - '0');
  /* space to / */
  else if ((c >= ' ') && (c <= '/'))
    search_search_index[index_num].space_to_slash |= 1 << (c - ' ');
  /* : to @ */
  else if ((c >= ':') && (c <= '@'))
    search_search_index[index_num].colon_to_at |= 1 << (c - ':');
  /* [ to ` */
  else if ((c >= '[') && (c <= '`'))
    search_search_index[index_num].square_to_dash |= 1 << (c - '[');
  /* curly to tilde */
  else if ((c >= '{') && (c <= '~'))
    search_search_index[index_num].curly_to_tilde |= 1 << (c - '{');
}



/* Checks whether the character "c" appears in the index entry indexed by "index_num" */
static int search_check_index_entry_for_char (char c, int index_num)
{
  /* Convert from "record's FirstPage indexing base" to indexing base for index */

  if (isalpha (c))
    return (search_search_index[index_num].a_to_z & (1 << (toupper(c) - 'A')));
  else if (isdigit (c))
    return (search_search_index[index_num].zero_to_nine & (1 << (c - '0')));
  else if ((c >= ' ') && (c <= '/'))
    return (search_search_index[index_num].space_to_slash & (1 << (c - ' ')));
  else if ((c >= ':') && (c <= '@'))
    return (search_search_index[index_num].colon_to_at & (1 << (c - ':')));
  else if ((c >= '[') && (c <= '`'))
    return (search_search_index[index_num].square_to_dash & (1 << (c - '[')));
  else if ((c >= '{') && (c <= '~'))
    return (search_search_index[index_num].curly_to_tilde & (1 << (c - '{')));

  return 0;
}
#endif
