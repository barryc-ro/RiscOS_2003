/*
 * search.c
 */

#include "include.h"
#include "tbox.h"
#include "ctype.h"
#include "time.h"
#include "misc.h"
#include "miscwimp.h"
#include "numconvert/numconvert.h"
#include "strings.h"
#include "flash.h"
#include "runes.h"
#include "error.h"
#include "addrbookIF.h"
#include "memhandle.h"
#include "search.h"
#include "globals.h"

/* The default key handler is called as fall-through from the search window's
   specialised key handler */
extern int default_key_handler (int, WimpPollBlock *, IdBlock *, void *);


/************************/
/* Generic search enums */

enum {Search_Code_Start, Search_Code_Continue};
enum {Search_Status_Finished, Search_Status_InProgress};

enum {AfterNan_Action_OpenAdd, AfterNan_Action_OpenEdit, AfterNan_Action_OpenMain,
      AfterNan_Action_CallDaytona, AfterNan_Action_RestartSearch};

static int action_after_nansearch;


/************************/
/* Null poll task stuff */

#define NullPollTask_None       0u
#define NullPollTask_IntSearch  1u
#define NullPollTask_Search     2u
#define NullPollTask_Update     4u

static unsigned int nullpoll_task = NullPollTask_None;


/*********************/
/* Int search stuff */

/* States of the interactive search algorithm */
enum {Search_Operation_Start, Search_Operation_AddChar, Search_Operation_Resync_Phase1,
      Search_Operation_Resync_Phase2, Search_Operation_Resync_Phase3,
      Search_Operation_Resync_Phase3_Writing};

interactive_search_state *intsearch_state_current = NULL;
static interactive_search_state *intsearch_state_saved = NULL;


/************************/
/* Non-int search stuff */

typedef struct nonint_search_queue_entry
{
  struct data
  {
    void *handle;
    int my_ref;
    int sender;
    char *search_field;
    int fields_to_search;
   }data;

  struct nonint_search_queue_entry *next_entry, *previous_entry;

}nonint_search_queue_entry;

static nonint_search_queue_entry *nonint_search_queue_top = NULL, *nonint_search_queue_bottom = NULL;

static void search_nonintqueue_add (void *, int, int, char *, int);
static void search_nonintqueue_remove (void);


/***********************/
/* Update search stuff */

typedef struct update_search_queue_entry
{
  struct
  {
    AddressRecord *rec;
    unsigned int action_code;
  }data;

  struct update_search_queue_entry *next_entry, *previous_entry;

}update_search_queue_entry;

static update_search_queue_entry *update_search_queue_top = NULL,
                                 *update_search_queue_bottom = NULL;


/***************************/
/* Miscallaneous functions */
static void search_home_pressed (void);
static void search_send_return_message (char, AddressRecord *, char *,
                                        char *, char);


/***************************/
/* Search buffer functions */

static void search_buffer_remove_end (void);
static void search_buffer_insert (char);
static int search_buffer_get (char *);


/********************************/
/* Local Functions:             */
/* Interactive search functions */

static search_chain_record *search_new_search_chain_item (int *, char *);
static void search_delete_search_chain_item (search_chain_record *);
static void search_destroy_search_chain (void);

static void search_show_results (void);
static int search_interactive_search (int);

static int search_number_match (char *, char *, char *, int);

static void search_remove_tail (void);
static int search_resync_phase3 (int, int *);
static int search_add_char (int *, int *, char *);

static void search_searchfield_fade (Fade_Action);

static void search_initialise_intsearch (void);


/***********************************/
/* Local Functions:                */
/* Non-Interactve search functions */

static int search_noninteractive_search (int, char *, int, int *);
static void search_noninteractive_searchend (int);


/*********************/
/* Local Functions:  */
/* Update functions  */

static int search_update_search (int, int *);
static void search_update_searchend (int);
static void search_updatequeue_add (AddressRecord *, unsigned int);
static void search_updatequeue_remove (void);



/**************************************************************************************/
/************************** Code starts here ******************************************/
/**************************************************************************************/


/***********/
void search_open_oneshot (void)
{
  _kernel_oserror *er;

  writablefield_set_value (0, ABShot_WindowHandle, abshot_fax, "");
  writablefield_set_value (0, ABShot_WindowHandle, abshot_email, "");

  er = ui_open_window (Open_SK_Required, ABShot_WindowHandle, "ABShot_Title",
                       "ABShot_SK1", "ABShot_SK2", "ABShot_SK3", "ABShot_SK4", -1);
  error_check_error (er);
}


/***********/
void search_open_intsearch (void)
{
  _kernel_oserror *er;

  search_initialise_intsearch ();

  intsearch_state_current->search_mode = SearchMode_Normal;

  /* Open Address book search Screen */
  er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_Title",
                       "ABSearch_SK1", "ABSearch_SK2", "ABSearch_SK3",
                       "ABSearch_SK4", -1);
  error_check_error (er);
}


/***********/
static void search_finish_nansearch (void)
{
  _kernel_oserror *er;

  switch (action_after_nansearch)
  {
    case AfterNan_Action_OpenAdd:
      /* Open the Add window */
      er = ui_open_window (Open_SK_Required | Open_SK_Narrow, ABAdd_WindowHandle,
                           "ABAdd_Title", "ABAdd_SK1", "ABAdd_SK2",
                           "ABAdd_SK3", "ABAdd_SK4", -1);
      error_check_error (er);
      break;

    case AfterNan_Action_OpenEdit:
      /* Open the Edit window */
      er = ui_open_window (Open_SK_Required | Open_SK_Narrow, ABEdit_WindowHandle,
                           "ABEdit_Title", "ABEdit_SK1", "ABEdit_SK2", "ABEdit_SK3",
                           "ABEdit_SK4", -1);
      error_check_error (er);
      break;

    case AfterNan_Action_OpenMain:
      /* Open the main window */
      runes_open_mainwindow ();
      break;

    case AfterNan_Action_CallDaytona:
      er = ui_open_other_program_window (Open_Daytona_Home, 0);
      error_check_error (er);
      break;

    case AfterNan_Action_RestartSearch:
      intsearch_state_current = intsearch_state_saved;
      writablefield_set_value (0, ABSearch_WindowHandle, absearch_searchfield,
                               intsearch_state_current->searchfield_state.new_field);
      if (intsearch_state_current->working)
      {
        search_searchfield_fade (Fade);
        nullpoll_task |= NullPollTask_IntSearch;
      }
      switch (intsearch_state_current->search_mode)
      {
        case SearchMode_Normal:
          /* Open the nornal Search window */
          er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_Title",
                               "ABSearch_SK1", "ABSearch_SK2", "ABSearch_SK3", "ABSearch_SK4", -1);
          error_check_error (er);
          break;

        case SearchMode_Names:
          /* Open the Names Search window */
          er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_Names_Title",
                               "ABSearch_Names_SK1", "ABSearch_Names_SK2",
                               "ABSearch_Names_SK3", "ABSearch_Names_SK4", -1);
          error_check_error (er);
          break;
      }
      break;
  }
}


/**************/
void search_open_nansearch (int flags, int my_ref, int sender)
{
  _kernel_oserror *er;
  int stack_position;

  IGNORE (flags);

  ui_stack_position (&stack_position);

  if (stack_position != -1)
    action_after_nansearch = AfterNan_Action_CallDaytona;

  else if (ui_currently_open_win == ABAdd_WindowHandle)
    action_after_nansearch = AfterNan_Action_OpenAdd;

  else if (ui_currently_open_win == ABEdit_WindowHandle)
    action_after_nansearch = AfterNan_Action_OpenEdit;

  else if (ui_currently_open_win == Address_WindowHandle)
    action_after_nansearch = AfterNan_Action_OpenMain;

  else if (ui_currently_open_win == NULL)
    action_after_nansearch = AfterNan_Action_CallDaytona;

  else if (ui_currently_open_win == ABSearch_WindowHandle)
  {
    if (nullpoll_task & NullPollTask_IntSearch)
    {
      intsearch_state_current->working = 1;
      nullpoll_task &= ~NullPollTask_IntSearch;
      search_searchfield_fade (UnFade);
    }
    action_after_nansearch = AfterNan_Action_RestartSearch;
    intsearch_state_saved = intsearch_state_current;
    intsearch_state_current = NULL;
  }

  /* Create & Initialise the interactive search data structure */
  search_initialise_intsearch ();

  /* Initialise some more bits */
  intsearch_state_current->your_ref = my_ref;
  intsearch_state_current->sender_taskid = sender;
  intsearch_state_current->search_mode = SearchMode_NAN;

  /* Open the search window */
  er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_NAN_Title",
                       "ABSearch_NAN_SK1", "ABSearch_NAN_SK2", "ABSearch_NAN_SK3",
                       "ABSearch_NAN_SK4", -1);
  error_check_error (er);

  /* The acknowledge the open window request */
  er = ui_open_other_program_window (Open_DayAdd_NANSearch_Ack, 0);
  error_check_error (er);
}


/***************/
void search_open_namessearch (int flags, int my_ref, int sender)
{
  _kernel_oserror *er;

  /* Create & Initialise the interactive search data structure */
  search_initialise_intsearch ();

  /* Initialise some more bits */
  if (flags & 1)
    intsearch_state_current->names_search_type = 1;
  else
    intsearch_state_current->names_search_type = 0;

  intsearch_state_current->your_ref = my_ref;
  intsearch_state_current->sender_taskid = sender;
  intsearch_state_current->search_mode = SearchMode_Names;

  /* Open the names search window */
  er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_Names_Title",
                       "ABSearch_Names_SK1", "ABSearch_Names_SK2",
                       "ABSearch_Names_SK3", "ABSearch_Names_SK4", -1);
  error_check_error (er);

  /* Then acknowledge the open window request */
  er = ui_open_other_program_window (Open_DayAdd_NamesSearch_Ack, 0);
  error_check_error (er);
}

static void search_free_intsearch_memory (int in_progress)
{
  /* If there's a search structure allocated, free all the memory */
  if (intsearch_state_current)
  {
    dprintf (("", "Freeing\n"));
    search_destroy_search_chain ();

    if (intsearch_state_current->resync_state.partial_field)
      free (intsearch_state_current->resync_state.partial_field);

    if (intsearch_state_current->searchfield_state.old_field)
      free (intsearch_state_current->searchfield_state.old_field);

    if (in_progress)
    {
      if (intsearch_state_current->searchfield_state.new_field)
        free (intsearch_state_current->searchfield_state.new_field);
    }

    free (intsearch_state_current);
    intsearch_state_current = NULL;
  }
}


/****************/
static void search_initialise_intsearch (void)
{
  writablefield_set_value (0, ABSearch_WindowHandle, absearch_searchfield, "");

  /* If there's a search structure already, free all the memory */
  if (intsearch_state_current)
  {
    dprintf (("", "Freeing memory at the start of a search!!\n"));
    search_destroy_search_chain ();

    if (intsearch_state_current->resync_state.partial_field)
      free (intsearch_state_current->resync_state.partial_field);

    if (intsearch_state_current->searchfield_state.old_field)
      free (intsearch_state_current->searchfield_state.old_field);

/*
    if (intsearch_state_current->searchfield_state.new_field)
      free (intsearch_state_current->searchfield_state.new_field);
*/

    free (intsearch_state_current);
  }

  /* Allocate a new structure */
  intsearch_state_current = (interactive_search_state *) malloc (sizeof (interactive_search_state));

  /* Initialise the new structure */
  intsearch_state_current->search_mode = 0;
  intsearch_state_current->working = 0;
  intsearch_state_current->your_ref = 0;
  intsearch_state_current->sender_taskid = 0;
  intsearch_state_current->current_result_selection = 0;
  intsearch_state_current->search_result = 0;
  intsearch_state_current->search_chain_top = NULL;
  intsearch_state_current->search_chain_current = NULL;
  intsearch_state_current->search_halted = 0;
  intsearch_state_current->resync_state.result_counter = 0;
  intsearch_state_current->resync_state.count = 0;
  intsearch_state_current->resync_state.partial_field = NULL;

  intsearch_state_current->intsearch_state.count = 0;
  intsearch_state_current->intsearch_state.result_counter = 0;
  intsearch_state_current->intsearch_state.operation = 0;

  intsearch_state_current->searchfield_state.buffer_state.index_in = 0;
  intsearch_state_current->searchfield_state.buffer_state.index_out = 0;
  intsearch_state_current->searchfield_state.buffer_state.full = 0;
  intsearch_state_current->searchfield_state.old_len = 0;
  intsearch_state_current->searchfield_state.new_len = 0;
  intsearch_state_current->searchfield_state.old_field = NULL;
  intsearch_state_current->searchfield_state.new_field = NULL;

  /* And call show_results to fill in the search window */
  search_show_results ();
}


/***************/
void search_oneshot (void)
{
  char *fax, *email;
  char tmp_str[25];
  char c;
  _kernel_oserror *er;
  int ret;
  char search_halted;
  WimpGetPointerInfoBlock	 pointer_info;
  ObjectId			 obj_name;

  /* Get the values from the window */
  fax = miscwimp_get_writable_value (ABShot_WindowHandle, abshot_fax);
  email = miscwimp_get_writable_value (ABShot_WindowHandle, abshot_email);

  tmp_str[0] = '\0';

  if (strlen (fax) || strlen (email))
  {
    if (strlen (fax))
    {
      ret = misc_strip_usernumber (fax);

      /* If we've emptied the fax number string ... */
      if (!strlen (fax))
      {
        /* If we've also got no email address, report an error */
        if (!strlen (email))
        {
          /* Discover the location of the pointer (and hence the location of the
             highlight), and store it locally so we can return to it if
             necessary */
          wimp_get_pointer_info (&pointer_info);
          window_wimp_to_toolbox (0, pointer_info.window_handle,
                                  pointer_info.icon_handle,
                                  &obj_name, &action_after_confirm.gadget_to_highlight);

          /* Tell the user and return to window */
          action_after_confirm.code = ConfirmAction_OpenOneShot;
          er = ui_confirm_window ("ABShot_Title", "AddEditC_NoFaxEmail",
                                  NULL, NULL, "confirm_1", runes_confirm_finished);
          error_check_error (er);
          goto end;
        }
      }
      /* If we still have a fax number to convert ... */
      else
      {
        switch (ret)
        {
           case UserNumber_XWrong:
             action_after_confirm.code = ConfirmAction_OpenOneShot;
             action_after_confirm.gadget_to_highlight = -1;
             er = ui_confirm_window ("ABShot_Title", "AddEditC_XMisplaced",
                                     NULL, NULL, "confirm_1", runes_confirm_finished);
             goto end;

           case UserNumber_PlusWrong:
             action_after_confirm.code = ConfirmAction_OpenOneShot;
             action_after_confirm.gadget_to_highlight = -1;
             er = ui_confirm_window ("ABShot_Title", "AddEditC_PlusMisplaced",
                                     NULL, NULL, "confirm_1", runes_confirm_finished);

             goto end;
        }
        numconvert_entered_to_internal (fax, tmp_str, sizeof (tmp_str),
                                        ip, np, cc, ac);

      }
    }
  }
  else
  {
    /* Discover the location of the pointer (and hence the location of the
       highlight), and store it locally so we can return to it if
       necessary */
    wimp_get_pointer_info (&pointer_info);
    window_wimp_to_toolbox (0, pointer_info.window_handle,
                            pointer_info.icon_handle,
                            &obj_name, &action_after_confirm.gadget_to_highlight);

    action_after_confirm.code = ConfirmAction_OpenOneShot;
    er = ui_confirm_window ("ABShot_Title", "AddEditC_NoFaxEmail",
                            NULL, NULL, "confirm_1", runes_confirm_finished);
    error_check_error (er);
    goto end;
  }

  /* If we've got through to this point, we've validated all the fields, so
     just send the message to Daytona */
  search_send_return_message (DataReturn_Code_OneShotData, NULL, tmp_str, email, 1);

  search_halted = intsearch_state_current->search_halted;

  /* If we were doing a search when we entered the oneshot window, clear up
     the remnants of the search */
  if (search_halted)
  {
    /* Empty the keyboard buffer */
    while (search_buffer_get (&c));

    /* And unfade the writable */
    search_searchfield_fade (UnFade);
  }

  /* Free the memory structure used by the NAN search */
  search_free_intsearch_memory (search_halted);

  /* And return to the window we were in when the NAN search was initiated */
  search_finish_nansearch ();

  end:

  /* Free the temporary storage */
  if (fax)
    free (fax);
  if (email)
    free (email);
}


/*****************/
void search_oneshot_back (void)
{
  _kernel_oserror *er;

  if (intsearch_state_current->search_halted)
  {
    /* Restart the interactive search */
    nullpoll_task |= NullPollTask_IntSearch;

    intsearch_state_current->search_halted = 0;

    /* And unfade the writable
    search_searchfield_fade (UnFade); */
  }
  er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_NAN_Title",
                       "ABSearch_NAN_SK1", "ABSearch_NAN_SK2", "ABSearch_NAN_SK3",
                       "ABSearch_NAN_SK4", -1);
  error_check_error (er);

#if 0
  if (intsearch_state_current->search_halted)
  {
     intsearch_state_current->search_halted = 0;

    /* And put the writable back to unfaded */
/*    search_searchfield_fade (Fade);*/
  }
#endif
}


/*************/
static void search_send_return_message (char code, AddressRecord *rec, char *oneshot_fax,
                                        char *oneshot_email, char interactive)
{
  int destination;
  Dayt_SearchDataReturn_Message message;
  _kernel_oserror *er;

  AddressArea *area;
  void *end;
  int area_id;

  message.hdr.size = sizeof (Dayt_SearchDataReturn_Message);
  message.hdr.action_code = Dayt_SearchDataReturn_MessageNum;

  if (interactive)
  {
    message.hdr.your_ref = intsearch_state_current->your_ref;
    message.data.handle = (void *) intsearch_state_current->names_search_type;
    destination = intsearch_state_current->sender_taskid;
  }
  else
  {
    message.hdr.your_ref = nonint_search_queue_bottom->data.my_ref;
    message.data.handle = nonint_search_queue_bottom->data.handle;
    destination = nonint_search_queue_bottom->data.sender;
  }

  message.data.code = code;

  switch (code)
  {
    case DataReturn_Code_AddressData:
      area = memhandle_create_area (&end, &area_id);

      memcpy (area->machine_id, rec->machine_id, sizeof (rec->machine_id));
      memcpy (area->creation_date, rec->creation_date, sizeof (rec->creation_date));
      strcpy (area->fax_number, rec->fax_number);
      strcpy (area->voice_number, rec->voice_number);
      strcpy (area->software_revision, rec->software_revision);
      area->device_class = rec->device_class;
      area->encryption_method = rec->encryption_method;
      area->encryption_revision = rec->encryption_revision;
      area->pgp_key_length = rec->pgp_key_length;
      area->routing_override = rec->routing_override;
      memhandle_add_string (&area->company_name, rec->company_name, &end, area_id);
      memhandle_add_string (&area->contact_name, rec->contact_name, &end, area_id);
      memhandle_add_string (&area->email_address, rec->email_address, &end, area_id);
      area->pgp_key = NULL;

      message.data.data_area = area;
      message.data.data_area_id = area_id;
      break;

    case DataReturn_Code_OneShotData:
      area = memhandle_create_area (&end, &area_id);

      strcpy (area->oneshot_fax_number, oneshot_fax);
      memhandle_add_string (&area->oneshot_email_address, oneshot_email, &end, area_id);;

      message.data.data_area = area;
      message.data.data_area_id = area_id;
      break;

    case DataReturn_Code_NotFound:
    case DataReturn_Code_Cancelled:
    default:
      message.data.data_area = NULL;
      message.data.data_area_id = -1;
  }

  er = wimp_send_message (Wimp_EUserMessage, &message, destination, 0, 0);
  error_check_error (er);
}


/*************/
void search_sk1_pressed (void)
{
  AddressRecord *rec;
  _kernel_oserror *er;
  int *result_list;
  int search_mode;
  char search_mode_names;

  if (nullpoll_task & NullPollTask_IntSearch)
  {
    /* We're still busy searching, ignore the keypress */
    return;
  }

  if (intsearch_state_current->search_chain_current)
    result_list = intsearch_state_current->search_chain_current->result_list;
  else
    result_list = flash_used_records_list;

  if (misc_integerlist_findlength (result_list))
  {
    if (intsearch_state_current->search_mode == SearchMode_NAN ||
        intsearch_state_current->search_mode == SearchMode_Names)
    {
      rec = flash_read_record (result_list[intsearch_state_current->current_result_selection]);

#if 1
      /* If the names search is for an email address, ensure the record
         has got an email address */
      if ((intsearch_state_current->names_search_type == 0) &&
          (intsearch_state_current->search_mode == SearchMode_Names) &&
          (strlen (rec->email_address) == 0))
      {
        action_after_confirm.code = ConfirmAction_OpenNamesSearch;
        action_after_confirm.gadget_to_highlight = -1;
        er = ui_confirm_window ("ABSearch_Names_Title", "ABSearch_Select_NoEmail",
                                NULL, NULL, "confirm_1", runes_confirm_finished);
        error_check_error (er);
        misc_free_record_memory (rec);
        return;
      }
#endif

      search_send_return_message (DataReturn_Code_AddressData, rec, NULL, NULL, 1);
      misc_free_record_memory (rec);

      search_mode = intsearch_state_current->search_mode;
      search_mode_names = intsearch_state_current->names_search_type;

      search_free_intsearch_memory (0);

      if (search_mode == SearchMode_NAN)
        search_finish_nansearch ();
      else
      {
        if (search_mode_names == 0)
          er = ui_open_other_program_window (Open_DayNote_Enote, 0);
        else
          er = ui_open_other_program_window (Open_DayNote_Form, 0);
        error_check_error (er);
      }

      return;
    }
    else if (intsearch_state_current->search_mode == SearchMode_Normal)
    {
      intsearch_state_current->search_mode = SearchMode_NoSearch;
      selected_record = result_list[intsearch_state_current->current_result_selection];

      search_free_intsearch_memory (0);
      runes_open_mainwindow ();
    }
  }
  else
  {
    char *tag;

    if (intsearch_state_current->search_chain_current)
      tag = "ABSearch_Select_NoMatch";
    else
      tag = "ABSearch_Select_NoEntries";

    if (intsearch_state_current->search_mode == SearchMode_NAN)
    {
      action_after_confirm.code = ConfirmAction_OpenNANSearch;
      er = ui_confirm_window ("ABSearch_NAN_Title", tag,
                              NULL, NULL, "confirm_1", runes_confirm_finished);
    }
    else if (intsearch_state_current->search_mode == SearchMode_Names)
    {
      action_after_confirm.code = ConfirmAction_OpenNamesSearch;
      er = ui_confirm_window ("ABSearch_Names_Title", tag,
                              NULL, NULL, "confirm_1", runes_confirm_finished);
    }
    else
    {
      action_after_confirm.code = ConfirmAction_OpenSearch;
      er = ui_confirm_window ("ABSearch_Title", tag,
                              NULL, NULL, "confirm_1", runes_confirm_finished);
    }
    error_check_error (er);

    action_after_confirm.gadget_to_highlight = -1;
  }
}


/***************/
void search_sk2_pressed (void)
{
  _kernel_oserror *er;
  char c, flag = 0;
  char search_mode_names;

  /* If we were in the middle of a search */
  if (nullpoll_task & NullPollTask_IntSearch)
  {
    flag = 1;

    if ((intsearch_state_current->search_mode == SearchMode_Names) ||
        (intsearch_state_current->search_mode == SearchMode_Normal))
    {
      /* Stop the null poll task */
      nullpoll_task &= ~NullPollTask_IntSearch;

      /* Empty the keyboard buffer */
      while (search_buffer_get (&c));

      /* And unfade the writable */
      search_searchfield_fade (UnFade);
    }
  }

  if (intsearch_state_current->search_mode == SearchMode_Names)
  {
    search_send_return_message (DataReturn_Code_Cancelled, NULL, NULL, NULL, 1);

    search_mode_names = intsearch_state_current->names_search_type;

    search_free_intsearch_memory (flag);

    if (search_mode_names == 0)
      er = ui_open_other_program_window (Open_DayNote_Enote, 0);
    else
      er = ui_open_other_program_window (Open_DayNote_Form, 0);
    error_check_error (er);
  }

  else if (intsearch_state_current->search_mode == SearchMode_Normal)
  {
    /* And open the main address book window */
    runes_open_mainwindow ();

    search_free_intsearch_memory (flag);
  }

  else if (intsearch_state_current->search_mode == SearchMode_NAN)
  {
    /* Stop the null poll task */
    if (nullpoll_task & NullPollTask_IntSearch)
    {
      nullpoll_task &= ~NullPollTask_IntSearch;
      intsearch_state_current->search_halted = 1;
    }
    search_open_oneshot ();
  }
}


/***********/
void search_back_pressed (void)
{
  /* If we're doing a normal or names search, pressing back is like pressing SK2 */
  if ((intsearch_state_current->search_mode == SearchMode_Names) ||
        (intsearch_state_current->search_mode == SearchMode_Normal))
  {
    search_sk2_pressed ();
  }
  else
  {
    /* do we really want to treat this like a "home"? */
    search_home_pressed ();
  }
}


/************/
void search_decideaction_cancelnanfax (int code, int action)
{
  _kernel_oserror *er;
  char c;

  IGNORE (code);

  /* cancel was chosen */
  if (action == 1)
  {
    /* Empty the keyboard buffer */
    while (search_buffer_get (&c));

    /* Unfade the writable */
    search_searchfield_fade (UnFade);

    /* Tell Daytona the user cancelled */
    search_send_return_message (DataReturn_Code_Cancelled, NULL, NULL, NULL, 1);

    /* Free the memory used for the NAN search */
    search_free_intsearch_memory (intsearch_state_current->search_halted);

    /* If there's a search saved, clear it also! */
    if (intsearch_state_saved)
    {
      intsearch_state_current = intsearch_state_saved;
      search_free_intsearch_memory (intsearch_state_current->working);
      intsearch_state_saved = intsearch_state_current = NULL;
    }

    /* Call Daytona to open its home window */
    ui_open_other_program_window (Open_Daytona_Home, 0);
  }
  else
  {
    /* If the search was halted when the decide window was brought up, we
       need to restart it before returning to the search window */
    if (intsearch_state_current->search_halted)
    {
      nullpoll_task |= NullPollTask_IntSearch;
      intsearch_state_current->search_halted = 0;
    }

    /* Open the NAN search window */
    er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_NAN_Title",
                         "ABSearch_NAN_SK1", "ABSearch_NAN_SK2", "ABSearch_NAN_SK3",
                         "ABSearch_NAN_SK4", -1);
    error_check_error (er);
  }
}


/***********/
void search_decideaction_cancelnames (int code, int action)
{
  _kernel_oserror *er;
  char c;

  IGNORE (code);

  /* cancel was chosen */
  if (action == 1)
  {
    /* Empty the keyboard buffer */
    while (search_buffer_get (&c));

    /* Unfade the writable */
    search_searchfield_fade (UnFade);

    /* Tell DayNote the user cancelled */
    search_send_return_message (DataReturn_Code_Cancelled, NULL, NULL, NULL, 1);

    /* Free the memory used for the names search */
    search_free_intsearch_memory (intsearch_state_current->search_halted);

    /* If there's a search saved, clear it also! */
    if (intsearch_state_saved)
    {
      intsearch_state_current = intsearch_state_saved;
      search_free_intsearch_memory (intsearch_state_current->working);
      intsearch_state_saved = intsearch_state_current = NULL;
    }

    /* Call Daytona to open its home window */
    ui_open_other_program_window (Open_Daytona_Home, 0);
  }
  else
  {
    /* If the search was halted when the decide window was brought up, we
       need to restart it before returning to the search window */
    if (intsearch_state_current->search_halted)
    {
      nullpoll_task |= NullPollTask_IntSearch;
      intsearch_state_current->search_halted = 0;
    }

    /* Open the names search window */
    er = ui_open_window (Open_SK_Required, ABSearch_WindowHandle, "ABSearch_Names_Title",
                         "ABSearch_Names_SK1", "ABSearch_Names_SK2",
                         "ABSearch_Names_SK3", "ABSearch_Names_SK4", -1);
    error_check_error (er);
  }
}


/**************/
void search_decideaction_canceloneshotfax (int code, int action)
{
  _kernel_oserror *er;
  char c;

  IGNORE (code);

  if (action == 1)
  {
    /* cancel */

    /* Empty the keyboard buffer */
    while (search_buffer_get (&c));

    /* Unfade the writable */
    search_searchfield_fade (UnFade);

    /* Tell Daytona the user cancelled */
    search_send_return_message (DataReturn_Code_Cancelled, NULL, NULL, NULL, 1);

    /* Free the memory used for the NAN search */
    search_free_intsearch_memory (intsearch_state_current->search_halted);

    /* If there's a search saved, clear it also! */
    if (intsearch_state_saved)
    {
      intsearch_state_current = intsearch_state_saved;
      search_free_intsearch_memory (intsearch_state_current->working);
      intsearch_state_saved = intsearch_state_current = NULL;
    }

    /* Call Daytona to open its home window */
    ui_open_other_program_window (Open_Daytona_Home, 0);
  }
  else
  {
    /* Return to the One-Shot window */
    er = ui_open_window (Open_SK_Required, ABShot_WindowHandle, "ABShot_Title",
                         "ABShot_SK1", "ABShot_SK2", "ABShot_SK3", "ABShot_SK4", -1);
    error_check_error (er);
  }
}


/*************/
static void search_home_pressed (void)
{
  _kernel_oserror *er;
  char c;
  int flag = 0;

  switch (intsearch_state_current->search_mode)
  {
    case SearchMode_Normal:
      /* If we were in the middle of a search */
      if (nullpoll_task & NullPollTask_IntSearch)
      {
        /* Stop the null poll task */
        nullpoll_task &= ~NullPollTask_IntSearch;

        /* Empty the keyboard buffer */
        while (search_buffer_get (&c));

        /* Unfade the writable */
        search_searchfield_fade (UnFade);

        flag = 1;
      }

      /* Tell Daytona to open its window */
      er = ui_open_other_program_window (Open_Daytona_Home, 0);
      error_check_error (er);

      /* Free the memory used for the search */
      search_free_intsearch_memory (flag);

      /* If there's a search saved, clear it also! */
      if (intsearch_state_saved)
      {
        intsearch_state_current = intsearch_state_saved;
        search_free_intsearch_memory (intsearch_state_current->working);
        intsearch_state_saved = intsearch_state_current = NULL;
      }
      break;

    case SearchMode_NAN:
      if (nullpoll_task & NullPollTask_IntSearch)
      {
        /* Stop the null poll task */
        nullpoll_task &= ~NullPollTask_IntSearch;

        intsearch_state_current->search_halted = 1;
      }

      /* Ask for a decision */
      ui_decide_window ("ABSearch_NAN_Title", "Yes", "No", "ABSearch_NAN_Cancel",
                        NULL, NULL, "decide_0", search_decideaction_cancelnanfax, 2);
      break;

    case SearchMode_Names:
      if (nullpoll_task & NullPollTask_IntSearch)
      {
        /* Stop the null poll task */
        nullpoll_task &= ~NullPollTask_IntSearch;

        intsearch_state_current->search_halted = 1;
      }

      /* Ask for a decision */

      /* names search for enote recipient */
      if (intsearch_state_current->names_search_type == 0)
      {
        ui_decide_window ("ABSearch_Names_Title", "Yes", "No", "ABSearch_Names_CancelEnote",
                          NULL, NULL, "decide_0", search_decideaction_cancelnames, 2);
      }
      /* names search for forms recipient */
      else
      {
        ui_decide_window ("ABSearch_Names_Title", "Yes", "No", "ABSearch_Names_CancelForm",
                          NULL, NULL, "decide_0", search_decideaction_cancelnames, 2);
      }

      break;
  }
}


/* Event handler for when a key is pressed in the search window */
int search_window_keypress (int event_code, WimpPollBlock *event,
                            IdBlock *id_block, void *handle)
{
  int *result_list;
  int len, key_code;


  IGNORE (event_code); IGNORE (id_block); IGNORE (handle);

  key_code = event->key_pressed.key_code;

  if (key_code != KeyCode_PageDown && key_code != KeyCode_PageUp &&
      key_code != KeyCode_Down && key_code != KeyCode_Up)
  {
    /* If home's been pressed */
    if (key_code == KeyCode_Home)
      search_home_pressed ();

    else if (isprint (key_code))
    {
      if (nullpoll_task & NullPollTask_IntSearch)
        search_buffer_insert ((char) key_code);
    }

    else if (key_code == 8) /* backspace */
    {
      /* And if we're currently searching */
      if ((nullpoll_task & NullPollTask_IntSearch) == NullPollTask_IntSearch)
        search_buffer_remove_end ();
    }

    else
    {
      dprintf (("", "key code = %x\n", key_code));
      default_key_handler (event_code, event, id_block, handle);
    }

    return 1;
  }

  if (intsearch_state_current->search_chain_current)
    result_list = intsearch_state_current->search_chain_current->result_list;
  else
    result_list = flash_used_records_list;

  switch (key_code)
  {
    case KeyCode_Down:
      if (event->key_pressed.caret.icon_handle == -1)
      {
        len = misc_integerlist_findlength (result_list);
        if (intsearch_state_current->current_result_selection < (len-1))
          intsearch_state_current->current_result_selection++;
        else
          return 1;
      }
      break;

    case KeyCode_Up:
      if (event->key_pressed.caret.icon_handle == -1)
      {
        if (intsearch_state_current->current_result_selection > 0)
          intsearch_state_current->current_result_selection--;
        else
          return 1;
      }
      break;

    case KeyCode_PageDown:
      len = misc_integerlist_findlength (result_list);
      if (intsearch_state_current->current_result_selection < (len-1))
        intsearch_state_current->current_result_selection++;
      else
        return 1;
      break;

    case KeyCode_PageUp:
      if (intsearch_state_current->current_result_selection > 0)
        intsearch_state_current->current_result_selection--;
      else
        return 1;
      break;
  }
  search_show_results ();

  return 1;
}


/************/
static void search_buffer_insert (char c)
{
  /* Save some typing with these pointer variables */
  unsigned int *index_in_p;
  unsigned int *index_out_p;

  if (intsearch_state_current->searchfield_state.buffer_state.full)
    return;

  index_in_p = &intsearch_state_current->searchfield_state.buffer_state.index_in;
  index_out_p = &intsearch_state_current->searchfield_state.buffer_state.index_out;

  dprintf (("", "Put '%c' in buffer\n", c));
  intsearch_state_current->searchfield_state.buffer_state.buffer[*index_in_p] = c;

  *index_in_p = (*index_in_p + 1) % BufferSize;

  if (*index_in_p == *index_out_p)
    intsearch_state_current->searchfield_state.buffer_state.full = 1;
}

static void search_buffer_remove_end (void)
{
  unsigned int *index_in_p;
  unsigned int *index_out_p;

  index_in_p = &intsearch_state_current->searchfield_state.buffer_state.index_in;
  index_out_p = &intsearch_state_current->searchfield_state.buffer_state.index_out;

  if (*index_in_p == *index_out_p)
  {
    if (intsearch_state_current->searchfield_state.buffer_state.full == 0)
    {
      dprintf (("", "Buffer empty\n"));
      return;
    }
  }

  *index_in_p = (*index_in_p - 1) % BufferSize;

  dprintf (("", "Threw away \"%c\"\n", intsearch_state_current->searchfield_state.buffer_state.buffer[*index_in_p]));
}

static int search_buffer_get (char *c)
{
  /* Save some typing with these pointer variables */
  unsigned int *index_in_p;
  unsigned int *index_out_p;

  index_in_p = &intsearch_state_current->searchfield_state.buffer_state.index_in;
  index_out_p = &intsearch_state_current->searchfield_state.buffer_state.index_out;

  if (*index_in_p == *index_out_p)
  {
    if (intsearch_state_current->searchfield_state.buffer_state.full)
    {
      /* Buffer was full, and no longer is */
      intsearch_state_current->searchfield_state.buffer_state.full = 0;
    }
    else
    {
      /* Buffer empty */
      return 0;
    }
  }

  *c = intsearch_state_current->searchfield_state.buffer_state.buffer[*index_out_p];
  dprintf (("", "Got '%c' from buffer\n", *c));

  *index_out_p = (*index_out_p + 1) % BufferSize;

  return 1;
}


/* Event handler for when search field has changed */
int search_searchfield_changed (int event_code, ToolboxEvent *event,
                                IdBlock *id_block, void *handle)
{
  char *temp_str;
  int stack_pos;

  IGNORE (event_code); IGNORE (event); IGNORE (id_block); IGNORE (handle);

  if (ui_currently_open_win != ABSearch_WindowHandle)
    return 1;

  ui_stack_position (&stack_pos);

  /* If we're not in front, flee in terror */
  if (stack_pos != -1)
    return 1;

  if (nullpoll_task & NullPollTask_IntSearch)
    return 1;

  if (!intsearch_state_current)
    return 1;

  temp_str = miscwimp_get_writable_value (ABSearch_WindowHandle, absearch_searchfield);
  if (!StrNullCmp (intsearch_state_current->searchfield_state.old_field, temp_str))
  {
    if (temp_str)
      free (temp_str);
    return 1;
  }

  if (intsearch_state_current->current_result_selection > 0)
    intsearch_state_current->current_result_selection = 0;

  intsearch_state_current->searchfield_state.old_field = intsearch_state_current->searchfield_state.new_field;
  intsearch_state_current->searchfield_state.new_field = temp_str;

  wimp_get_caret_position (&intsearch_state_current->searchfield_state.caret_position);

  /* Fade the search field writable */
  search_searchfield_fade (Fade);
  IconHigh_Stop();

  /* And start the search */
  search_interactive_search (Search_Code_Start);
  nullpoll_task |= NullPollTask_IntSearch;

  return 1;
}


/***********/
void search_initialise (void)
{
  /* search_initialise_index (); */
}


/***********/
int search_null_handler (int event_code, WimpPollBlock *event,
                         IdBlock *id_block, void *handle)
{
  int status, i, result;
  char c;
  char *old, *new_str;

  clock_t start;

  /* Call the UI lib null poll handler */
  ui_pollword_handler (event_code, event,  id_block, handle);

  if (nullpoll_task)
  {
    start = clock();

    while (nullpoll_task && ((clock() - start) < 5))
    {

    /* If we're doing an interactive search */
      if ((nullpoll_task & NullPollTask_IntSearch) == NullPollTask_IntSearch)
      {
    #if 0
        if (intsearch_state_current->search_halted)
        {
          intsearch_state_current->search_halted = 0;

          /* And put the writable back to unfaded */
          search_searchfield_fade (Fade);
        }
    #endif
        status = search_interactive_search (Search_Code_Continue);

        if (status == Search_Status_Finished)
        {
          if (intsearch_state_current)
          {
            if (intsearch_state_current->searchfield_state.old_field)
              free (intsearch_state_current->searchfield_state.old_field);
          }

          intsearch_state_current->searchfield_state.old_field =
             intsearch_state_current->searchfield_state.new_field;

          /* Show the search results */
          search_show_results ();

          /* Try to get a character from the keyboard buffer */
          status = search_buffer_get (&c);
          if (status)
          {
            /* If there's one available, add it into the search string at the
               correct point */
            old = miscwimp_get_writable_value (ABSearch_WindowHandle, absearch_searchfield);

            new_str = malloc (strlen (old) + 2);

            for (i = 0; i < intsearch_state_current->searchfield_state.caret_position.index; i++)
              new_str[i] = old[i];

            new_str[intsearch_state_current->searchfield_state.caret_position.index] = c;

            for (i = intsearch_state_current->searchfield_state.caret_position.index;
                        old[i] != '\0'; i++)
            {
              new_str[i+1] = old[i];
            }

            new_str[i+1] = '\0';

            writablefield_set_value (0, ABSearch_WindowHandle, absearch_searchfield, new_str);

            intsearch_state_current->searchfield_state.new_field = new_str;

            if (old)
              free (old);

            intsearch_state_current->searchfield_state.caret_position.index++;

            search_interactive_search (Search_Code_Start);
          }
          else
          {
            /* If there's nothing in the buffer, unfade the writable, and set the caret
               to the correct position */
            search_searchfield_fade (UnFade);
            /* IconHigh_Start (); */
            wimp_set_caret_position (
               intsearch_state_current->searchfield_state.caret_position.window_handle,
               intsearch_state_current->searchfield_state.caret_position.icon_handle,
               intsearch_state_current->searchfield_state.caret_position.xoffset,
               intsearch_state_current->searchfield_state.caret_position.yoffset,
               intsearch_state_current->searchfield_state.caret_position.height,
               intsearch_state_current->searchfield_state.caret_position.index);

            /* And stop the null poll task */
            nullpoll_task &= ~NullPollTask_IntSearch;
          }
        }
      }

      /* If we're doing a non-interactive search */
      if ((nullpoll_task & NullPollTask_Search) == NullPollTask_Search)
      {
        status = search_noninteractive_search (Search_Code_Continue, NULL, NULL, &result);

        /* If the search has finished */
        if (status == Search_Status_Finished)
        {
          dprintf (("", "Finished non-interactive search, result = %d\n", result));
          nullpoll_task &= ~NullPollTask_Search;
          search_noninteractive_searchend (result);
        }
      }

      /* If we're doing an update search */
      if ((nullpoll_task & NullPollTask_Update) == NullPollTask_Update)
      {
        int result;

        status = search_update_search (Search_Code_Continue, &result);

        /* If the search has finished */
        if (status == Search_Status_Finished)
        {
          nullpoll_task &= ~NullPollTask_Update;
          search_update_searchend (result);
        }
      }
    }
  }

  return 1;
}


/*****************/
void search_noninteractive_searchstart (char *search_field, int fields_to_search,
                                        void *handle, int my_ref, int sender)
{
  char flag = 0;

  /* If the queue's empty, set a flag */
  if (nonint_search_queue_top == NULL)
    flag = 1;

  /* Add an entry to the queue for this search */
  search_nonintqueue_add (handle, my_ref, sender, search_field, fields_to_search);

  /* If the queue was empty, start this search immediately */
  if (flag)
  {
    dprintf (("", "Started non-interactive search in start\n"));
    search_noninteractive_search (Search_Code_Start, search_field, fields_to_search, NULL);

    nullpoll_task |= NullPollTask_Search;
  }
}


/*****************/
void search_update_searchstart (AddressRecord *rec, unsigned int action_code)
{
  char flag = 0;

  /* If the queue's empty, set a flag */
  if (update_search_queue_top == NULL)
    flag = 1;

  rec->routing_override = RoutingOverride_Default; /* Set as default until user
                                                     changes it to something else */

  /* Add an entry to the queue for this search */
  search_updatequeue_add (rec, action_code);

  /* If the queue was empty, start this search immediately */
  if (flag)
  {
    dprintf (("", "Started update search in start\n"));

    search_update_search (Search_Code_Start, NULL);

    nullpoll_task |= NullPollTask_Update;
  }
}


/***************************************/
/* Search engine functions (all local) */


/******************************/
static void search_noninteractive_searchend (int result)
{
  AddressRecord *rec = NULL;

  /* If no match was found, send the NotFound message */
  if (result == 0)
  {
    search_send_return_message (DataReturn_Code_NotFound, NULL, NULL, NULL, 0);
  }
  else
  {
    /* Else, read the matching record .. */
    rec = flash_read_record (result);

    /* Send the message */
    search_send_return_message (DataReturn_Code_AddressData, rec, NULL, NULL, 0);

    /* And free the temporary storage */
    misc_free_record_memory (rec);
  }

  /* Remove the current search entry from the queue */
  search_nonintqueue_remove ();

  /* And if there's something in the queue, start a search */
  if (nonint_search_queue_bottom != NULL)
  {
    dprintf (("", "Started non-interactive search in end\n"));
    search_noninteractive_search (Search_Code_Start, nonint_search_queue_bottom->data.search_field,
                                  nonint_search_queue_bottom->data.fields_to_search, NULL);

    nullpoll_task |= NullPollTask_Search;
  }
}


/************/
static void search_update_fix_intsearch (interactive_search_state *state, int old, int new)
{
  int num, counter;
  search_chain_record *ptr;

  if (state->search_chain_top)
  {
    ptr = state->search_chain_top;

    do
    {
      counter = 0;
      while ((num = ptr->result_list[counter++]) != -1)
      {
        if (num == old)
        {
          dprintf (("", "replacing in main result list\n"));
          ptr->result_list[counter - 1] = new;
        }
      };
    }while ((ptr = ptr->next) != NULL);
  }

  if ((state->working == 1) ||
      (nullpoll_task & NullPollTask_IntSearch))
  {
    counter = 0;
    while ((num = state->addchar_result_list[counter++]) != -1)
    {
      if (counter >= 2000)
        break;

      if (num == old)
      {
        dprintf (("", "replacing in addchar result list\n"));
        state->addchar_result_list[counter-1] = new;
      }
    };
  }
}

/******************************/
static void search_update_searchend (int result)
{
  int ret, stack_pos;
  AddressRecord *matched_rec = NULL, *update_rec;

  update_rec = update_search_queue_bottom->data.rec;

  if (update_search_queue_bottom->data.action_code == AddressModify_ActionCode_ModifyDeviceClass)
  {
    if (result != 0)
    {
      dprintf (("", "Found match at page %d.\n", result));
      matched_rec = flash_read_record (result);

      if (matched_rec->device_class != update_rec->device_class)
      {
        /* Replace the device class in the matched record with the new one */
        matched_rec->device_class = update_rec->device_class;

        dprintf (("", "Delete old record, then add new\n"));

        /* Delete the old record */
        flash_delete_record (result);

        /* Then add new */
        ret = flash_write_record (matched_rec);

        if (result != 0)
        {
          /* If we're currently displaying the updated record, we need to change
             the number of the selected record to the new version, and redraw the
             main address book window */
          if (result == selected_record)
          {
            dprintf (("", "In here\n"));
            selected_record = ret;
            runes_complete_mainwindow ();
          }

          /* Go through the search chain and replace old with new */
          if (intsearch_state_current)
          {
            search_update_fix_intsearch (intsearch_state_current, result, ret);
          }
          if (intsearch_state_saved)
          {
            search_update_fix_intsearch (intsearch_state_saved, result, ret);
          }
        }
        dprintf (("", "Wrote new record at page %d\n", ret));

      }
      else
        dprintf (("", "No need to do anything, device class is the same\n"));

      /* Free some memory */
       misc_free_record_memory (matched_rec);
    }
  }
  else if (update_search_queue_bottom->data.action_code == AddressModify_ActionCode_Update)
  {
    if (result != 0)
    {
      dprintf (("", "Found match at page %d.\n", result));

      matched_rec = flash_read_record (result);

      if (memcmp (matched_rec->machine_id, update_rec->machine_id,
                  sizeof (matched_rec->machine_id)) == 0)
      {
        if (matched_rec->device_class == update_rec->device_class)
        {
          if (StrNullCmp (matched_rec->company_name, update_rec->company_name) == 0)
          {
            if (StrNullCmp (matched_rec->contact_name, update_rec->contact_name) == 0)
            {
              int cont = 0;

              if (strlen (matched_rec->fax_number) &&
                  matched_rec->fax_number[0] != NUMCONVERT_EXTENSION)
              {
                if (strcmp (&(matched_rec->fax_number[1]), &(update_rec->fax_number[1])) == 0)
                {
                  /* special case */
                  cont = 1;
                }
              }
              else if (StrNullCmp (matched_rec->fax_number, update_rec->fax_number) == 0)
              {
                /* normal case */
                cont = 1;
              }

              if (cont)
              {
                cont = 0;

                if (strlen (matched_rec->voice_number) &&
                    matched_rec->voice_number[0] != NUMCONVERT_EXTENSION)
                {
                  if (strcmp (&(matched_rec->voice_number[1]), &(update_rec->voice_number[1])) == 0)
                  {
                    /* special case */
                    cont = 1;
                  }
                }
                else if (StrNullCmp (matched_rec->voice_number, update_rec->voice_number) == 0)
                {
                  /* normal case */
                  cont = 1;
                }

                if (cont)
                {
                  if (StrNullCmp (matched_rec->email_address, update_rec->email_address) == 0)
                  {
                    if (memcmp (matched_rec->creation_date, update_rec->creation_date,
                                sizeof (matched_rec->creation_date)) == 0)
                    {
                      if (StrNullCmp (matched_rec->software_revision, update_rec->software_revision) == 0)
                      {
                        dprintf (("", "Exact match, no need to do anything!!!!!!!!\n"));

                        /* Free some memory */
                        misc_free_record_memory (matched_rec);

                        goto update_searchend_end;
                      }
                      else
                        dprintf (("", "software rev differs\n"));
                    }
                    else
                      dprintf (("", "data differs\n"));
                  }
                  else
                    dprintf (("", "email differs\n"));
                }
                else
                  dprintf (("", "voice differs\n"));
              }
              else
                dprintf (("", "fax differs\n"));
            }
            else
              dprintf (("", "name differs\n"));
          }
          else
            dprintf (("", "company differs\n"));
        }
        else
          dprintf (("", "device class differs\n"));
      }
      else
        dprintf (("", "machine id differs\n"));

      dprintf (("", "Delete old record, then add new\n"));

      /* Delete the old record */
      flash_delete_record (result);

      if (strlen (matched_rec->fax_number) && strlen (update_rec->fax_number))
      {
        if (strcmp (&(matched_rec->fax_number[1]), &(update_rec->fax_number[1])) == 0)
        {
          update_rec->fax_number[0] = matched_rec->fax_number[0];
        }
      }

      /* If the matched record is permanent, leave it that way */
      {
        char perm[8];

        memset (perm, 0xff, 8);

        if (memcmp (perm, matched_rec->creation_date, 8) == 0)
          memset (update_rec->creation_date, 0xff, 8);
      }

      /* If the fax number has been entered as an extension, we want to keep it */
      if (matched_rec->fax_number[0] == NUMCONVERT_EXTENSION)
        strcpy (update_rec->fax_number, matched_rec->fax_number);

      /* And the same for the voice number, I guess */
      if (matched_rec->voice_number[0] == NUMCONVERT_EXTENSION)
        strcpy (update_rec->voice_number, matched_rec->voice_number);

      /* We also want to retain the routing in an existing record */
      update_rec->routing_override = matched_rec->routing_override;

      /* Free some memory */
      misc_free_record_memory (matched_rec);
    }
    else
      dprintf (("", "Search failed...just add new record.\n"));

    /* Write the new record */
    ret = flash_write_record (update_rec);

    /* If the write failed ... */
    if (ret == 0)
    {
      dprintf (("", "Write of new record failed\n"));
      goto update_searchend_end;
    }

    if (result != 0)
    {
      /* If we're currently displaying the updated record, we need to change
         the number of the selected record to the new version, and redraw the
         main address book window */
      if (result == selected_record)
      {
        dprintf (("", "Redisplay the main window\n"));
        selected_record = ret;
        runes_complete_mainwindow ();
      }

      /* Go through the search chain and replace old with new */
      if (intsearch_state_current)
      {
        search_update_fix_intsearch (intsearch_state_current, result, ret);
      }
      if (intsearch_state_saved)
      {
        search_update_fix_intsearch (intsearch_state_saved, result, ret);
      }

      /* Also, what do we do with non-interactive searches...search me! */

    }
    dprintf (("", "Wrote new record at page %d\n", ret));
  }

  update_searchend_end:

  ui_stack_position (&stack_pos);

  /* If we're in front, and in the search or oneshot window, update the results */
  if (((ui_currently_open_win == ABSearch_WindowHandle) ||
      (ui_currently_open_win == ABShot_WindowHandle)) &&
      (stack_pos == -1))
  {
    dprintf (("", "Redisplay the results screen\n"));
    search_show_results ();
  }

  /* Remove the current search entry from the queue */
  search_updatequeue_remove ();

  /* And if there's something in the queue, start a search */
  if (update_search_queue_bottom != NULL)
  {
    dprintf (("", "Started update search in end\n"));
    search_update_search (Search_Code_Start, NULL);

    nullpoll_task |= NullPollTask_Update;
  }
}


/*******************/
static void search_nonintqueue_add (void *handle, int my_ref, int sender, char *search_field,
                                    int fields_to_search)
{
  nonint_search_queue_entry *temp_ptr;

  /* Allocate a new entry */
  temp_ptr = malloc (sizeof (nonint_search_queue_entry));

  /* Enter the data */
  temp_ptr->data.handle = handle;
  temp_ptr->data.my_ref = my_ref;
  temp_ptr->data.sender = sender;
  temp_ptr->data.search_field = strdup (search_field);
  temp_ptr->data.fields_to_search = fields_to_search;

  /* Link 'er up */
  if (nonint_search_queue_top)
  {
    nonint_search_queue_top->previous_entry = temp_ptr;
  }
  temp_ptr->next_entry = nonint_search_queue_top;
  temp_ptr->previous_entry = NULL;

  /* And set the queue top pointer to the new entry */
  nonint_search_queue_top = temp_ptr;

  /* If we've only just populated the queue, make top=bottom */
  if (nonint_search_queue_bottom == NULL)
    nonint_search_queue_bottom = nonint_search_queue_top;
}


/****************************/
static void search_nonintqueue_remove (void)
{
  nonint_search_queue_entry *temp_ptr;

  if (nonint_search_queue_bottom)
  {
    /* Unlink the bottom entry */
    temp_ptr = nonint_search_queue_bottom;
    if (nonint_search_queue_bottom->previous_entry)
      nonint_search_queue_bottom->previous_entry->next_entry = NULL;
    nonint_search_queue_bottom = nonint_search_queue_bottom->previous_entry;

    /* And free it */
    if (temp_ptr)
    {
      if (temp_ptr->data.search_field)
        free (temp_ptr->data.search_field);
      free (temp_ptr);
    }
  }

  /* If we've just emptied the queue, reset the top pointer to NULL */
  if (nonint_search_queue_bottom == NULL)
    nonint_search_queue_top = NULL;
}


/**************************/
static void search_updatequeue_add (AddressRecord *rec, unsigned int action_code)
{
  update_search_queue_entry *temp_ptr;

  dprintf (("", "Add %s \n", rec->contact_name));

  /* Allocate a new entry */
  temp_ptr = malloc (sizeof (update_search_queue_entry));

  /* Enter the data */
  temp_ptr->data.rec = misc_copy_record (rec);
  temp_ptr->data.action_code = action_code;

  /* Link 'er up */
  if (update_search_queue_top)
  {
    update_search_queue_top->previous_entry = temp_ptr;
  }
  temp_ptr->next_entry = update_search_queue_top;
  temp_ptr->previous_entry = NULL;

  /* And set the queue top pointer to the new entry */
  update_search_queue_top = temp_ptr;

  /* If we've only just populated the queue, make top=bottom */
  if (update_search_queue_bottom == NULL)
    update_search_queue_bottom = update_search_queue_top;
}


/***************/
static void search_updatequeue_remove (void)
{
  update_search_queue_entry *temp_ptr;

  dprintf (("", "Remove %s \n", update_search_queue_bottom->data.rec->contact_name));

  if (update_search_queue_bottom)
  {
    /* Unlink the bottom entry */
    temp_ptr = update_search_queue_bottom;
    if (update_search_queue_bottom->previous_entry)
      update_search_queue_bottom->previous_entry->next_entry = NULL;
    update_search_queue_bottom = update_search_queue_bottom->previous_entry;

    /* And free it */
    if (temp_ptr)
    {
      if (temp_ptr->data.rec)
        misc_free_record_memory (temp_ptr->data.rec);
      free (temp_ptr);
    }
  }

  /* If we've just emptied the queue, reset the top pointer to NULL */
  if (update_search_queue_bottom == NULL)
    update_search_queue_top = NULL;
}


/********************/
/* Update functions */


/***********************/
static int search_update_search (int code, int *search_result)
{
  static int record_index = 0;
  int record_num;
  AddressRecord *rec = NULL;
  char *match;
  static int mode = 0;

  if (code == Search_Code_Start)
  {
    record_index = 0;
    mode = 0;

    dprintf (("", "Now checkng serial number\n"));

    return Search_Status_InProgress;
  }

  /* main search */

  record_num = flash_used_records_list[record_index++];

  /* We've gone through all the records, and found no match */
  if (record_num == -1)
  {
    switch (mode)
    {
      case 0:
        mode++;  /* Go on to the next mode (fax number) */
        record_index = 0;
        dprintf (("", "Now checking fax #\n"));

        return Search_Status_InProgress;

      case 1:
        mode++; /* Go on to the next mode (Email address) */
        record_index = 0;
        dprintf (("", "Now checking email address\n"));

        return Search_Status_InProgress;

      default:
        /* We've tried all modes, and found no match, we're done */
        *search_result = 0;
        return Search_Status_Finished;
    }
  }

  rec = flash_read_record (record_num);

  /* Just in case the read failed, skip this entry */
  if (!rec)
    return Search_Status_InProgress;

  switch (mode)
  {
    case 0:
      match = update_search_queue_bottom->data.rec->machine_id;

      if (!memcmp (match, rec->machine_id, sizeof (rec->machine_id)))
      {
        char empty_id[16];

        memset (empty_id, 0, sizeof (empty_id));

        /* If the record's machine is empty, don't match it */
        if (!memcmp (empty_id, rec->machine_id, sizeof (rec->machine_id)))
        {
          /* Free up the memory used for the record */
          misc_free_record_memory (rec);

          dprintf (("", "Matched empty machine ID, don't match it\n"));

          return Search_Status_InProgress;
        }

        dprintf (("", "Found serial number match: Name = \"%s\" Company =\"%s\"\n", rec->contact_name, rec->company_name));

        /* Free up the memory used for the record */
        misc_free_record_memory (rec);



        *search_result = record_num;
        return Search_Status_Finished;
      }
      break;

    case 1:
      match = update_search_queue_bottom->data.rec->fax_number;

      /* If the record's got no fax number, don't try to match it */
      if (!strlen (rec->fax_number))
      {
        /* Free up the memory used for the record */
        misc_free_record_memory (rec);

        return Search_Status_InProgress;
      }

      if (match[0] != NUMCONVERT_EXTENSION &&
          rec->fax_number[0] != NUMCONVERT_EXTENSION)
      {
        if (strcmp (&match[1], &rec->fax_number[1]) == 0)
        {
          dprintf (("", "Found fax number match: Name = \"%s\" Company =\"%s\"\n", rec->contact_name, rec->company_name));

          /* Free up the memory used for the record */
          misc_free_record_memory (rec);

          *search_result = record_num;
          return Search_Status_Finished;
        }
      }
      else if (!StrNullCmp (match, rec->fax_number))
      {
        dprintf (("", "Found fax number match: Name = \"%s\" Company =\"%s\"\n", rec->contact_name, rec->company_name));

        /* Free up the memory used for the record */
        misc_free_record_memory (rec);

        *search_result = record_num;
        return Search_Status_Finished;
      }
      break;

    case 2:
      match = update_search_queue_bottom->data.rec->email_address;

      /* If the record's got no email address, don't try to match it */
      if (!strlen (rec->email_address))
      {
        dprintf (("", "Found email match: Name = \"%s\" Company =\"%s\" email = \"%s\"\n", rec->contact_name, rec->company_name, rec->email_address));

        /* Free up the memory used for the record */
        misc_free_record_memory (rec);

        return Search_Status_InProgress;
      }

      if (!StrNullCmp (match, rec->email_address))
      {
        dprintf (("", "Found email match: Name = \"%s\" Company =\"%s\" email = \"%s\"\n", rec->contact_name, rec->company_name, rec->email_address));

        /* Free up the memory used for the record */
        misc_free_record_memory (rec);

        *search_result = record_num;
        return Search_Status_Finished;
      }
      break;
  }

  if (rec)
  {
    /* Free up the memory used for the record */
    misc_free_record_memory (rec);
  }

  return Search_Status_InProgress;
}


/************************************/
/* Non-Interactive search functions */


/*********************/
static int search_noninteractive_search (int code, char *search_field,
                                         int fields_to_search, int *result_p)
{
  static int record_index = 0;
  static char *string_to_match = NULL;
  static int search_mask = 0;
  int record_num;
  AddressRecord *rec = NULL;

  /* Initialiser */
  if (code == Search_Code_Start)
  {
    record_index = 0;

    if (string_to_match)
      free (string_to_match);

    string_to_match = strdup (search_field);
    search_mask = fields_to_search;

    return Search_Status_InProgress;
  }

  /* Get the record number to read from the used list */
  record_num = flash_used_records_list[record_index++];

  /* We've gone through all the records, and found no match */
  if (record_num == -1)
  {
    if (string_to_match)
    {
      free (string_to_match);
      string_to_match = NULL;
    }

    /* Set the result to 0 to indicate no match ... */
    *result_p = 0;

    /* ... and finish */
    return Search_Status_Finished;
  }

  /* Read record from flash */
  rec = flash_read_record (record_num);

  /* Just in case the read failed, skip this entry */
  if (!rec)
    return Search_Status_InProgress;

  /* Then, for each search key, check for a match */

  if (search_mask & Field_ContactName)
  {
    if (!StrNullCmp (string_to_match, rec->contact_name))
      goto nonint_match;
  }
  if (search_mask & Field_CompanyName)
  {
    if (!StrNullCmp (string_to_match, rec->company_name))
      goto nonint_match;
  }
  if (search_mask & Field_MachineID)
  {
    if (!memcmp (string_to_match, rec->machine_id, sizeof (rec->machine_id)))
      goto nonint_match;
  }
  if (search_mask & Field_EmailAddress)
  {
    if (!StrNullCmp (string_to_match, rec->email_address))
      goto nonint_match;
  }
  if (search_mask & Field_FaxNumber)
  {
    if (!StrNullCmp (string_to_match, rec->fax_number))
      goto nonint_match;
  }
  if (search_mask & Field_VoiceNumber)
  {
    if (!StrNullCmp (string_to_match, rec->voice_number))
      goto nonint_match;
  }
  if (search_mask & Field_DeviceClass)
  {
    if (((unsigned int)atoi (string_to_match)) == rec->device_class)
      goto nonint_match;
  }
  if (search_mask & Field_SoftwareRevision)
  {
    if (!StrNullCmp (string_to_match, rec->software_revision))
      goto nonint_match;
  }
  if (search_mask & Field_EncryptionMethod)
  {
    if (((unsigned int)atoi (string_to_match)) == rec->encryption_method)
      goto nonint_match;
  }
  if (search_mask & Field_EncryptionRevision)
  {
    if (((unsigned int)atoi (string_to_match)) == rec->encryption_revision)
      goto nonint_match;
  }
  if (search_mask & Field_RoutingOverride)
  {
    if (((char)atoi (string_to_match)) == rec->routing_override)
      goto nonint_match;
  }
  if (search_mask & Field_CreationDate)
  {
    if (!memcmp (string_to_match, rec->creation_date, sizeof (rec->creation_date)))
      goto nonint_match;
  }

  /* Free up the memory used for the record */
  misc_free_record_memory (rec);

  /* If we've fallen through to here, we carry on to the next record */
  return Search_Status_InProgress;

  nonint_match:

  /* Free up the memory used for the record */
  misc_free_record_memory (rec);

  if (string_to_match)
  {
    free (string_to_match);
    string_to_match = NULL;
  }

  /* Set the result to the matched record ... */
  *result_p = record_num;

  /* ... and finish. */
  return Search_Status_Finished;
}


/********************************/
/* Interactive search functions */


/**************************/
static int search_interactive_search (int code)
{
  int rc = Search_Status_Finished;

  int old_len = strlen (intsearch_state_current->searchfield_state.old_field);
  int new_len = strlen (intsearch_state_current->searchfield_state.new_field);

  if (code == Search_Code_Start)
  {
    intsearch_state_current->intsearch_state.count = 0;
    intsearch_state_current->intsearch_state.result_counter = 0;

    intsearch_state_current->intsearch_state.operation = Search_Operation_Start;
    return Search_Status_InProgress;
  }

  /* Do the operation of calculating a new chain entry
     for adding a character */
  switch (intsearch_state_current->intsearch_state.operation)
  {
    case Search_Operation_Start:
      /* If no other case is found, we must resyncronise the
       search chain, starting at Phase 1 */
      intsearch_state_current->intsearch_state.operation = Search_Operation_Resync_Phase1;

      rc = Search_Status_InProgress;

      if ((new_len - old_len) == 1)
      {
        if (old_len == 0)
        {
          /* One char has been added to an empty search term, we
             need to make the search chain top entry */
          intsearch_state_current->intsearch_state.operation = Search_Operation_AddChar;
        }
        else if (strncmp (intsearch_state_current->searchfield_state.old_field,
                          intsearch_state_current->searchfield_state.new_field, old_len) == NULL)
        {
          /* One char has been added to the current search chain
             entry, we must add a new entry for this on the
             end of the chain */
          intsearch_state_current->intsearch_state.operation = Search_Operation_AddChar;
        }
      }
      else if ((old_len - new_len) == 1)
      {
        if (strncmp (intsearch_state_current->searchfield_state.old_field,
                     intsearch_state_current->searchfield_state.new_field, new_len) == NULL)
        {
          /* One character has been removed from the current
             search chain entry, we will remove the current search
             chain entry, and return the results of the previous
             entry */
          search_remove_tail ();
          rc = Search_Status_Finished;
        }
      }
      switch (intsearch_state_current->intsearch_state.operation)
      {
        case Search_Operation_Resync_Phase1:
          if (rc == Search_Status_InProgress)
            dprintf (("", ">>>>>>>>>>>>>Resync\n"));
          else
            dprintf (("", ">>>>>>>>>>>>>Remove tail\n"));
          break;
        case Search_Operation_AddChar:
          dprintf (("", ">>>>>>>>>>>>>Add char\n"));
          break;
      }
      break;

    case Search_Operation_AddChar:
      rc = search_add_char (&intsearch_state_current->intsearch_state.result_counter,
                            &intsearch_state_current->intsearch_state.count,
                             intsearch_state_current->searchfield_state.new_field);
      break;

    case Search_Operation_Resync_Phase1:
      /* First step back down the chain till you have the same
         length of string as for the search field, possibly emptying the chain */

      if (intsearch_state_current->search_chain_current != NULL)
      {
        if (new_len < strlen (intsearch_state_current->search_chain_current->search_term))
          search_remove_tail ();
        else
          intsearch_state_current->intsearch_state.operation = Search_Operation_Resync_Phase2;
      }
      else
      {
        /* We've removed the whole chain, go to Phase 3 */
        intsearch_state_current->search_chain_top = NULL;
        intsearch_state_current->intsearch_state.operation = Search_Operation_Resync_Phase3;
      }

      rc = Search_Status_InProgress;
      break;

    case Search_Operation_Resync_Phase2:
      /* Then step down the search chain until you get a match on the first
         chars in the search field, possibly emptying the chain */
      if (intsearch_state_current->search_chain_current != NULL)
      {
        if (strncmp (intsearch_state_current->search_chain_current->search_term,
                     intsearch_state_current->searchfield_state.new_field,
                     strlen (intsearch_state_current->search_chain_current->search_term)) != 0)
        {
          search_remove_tail ();
        }
        else
          intsearch_state_current->intsearch_state.operation = Search_Operation_Resync_Phase3;
      }
      else
      {
        /* We've removed the whole chain, go to Phase 3 */
        intsearch_state_current->search_chain_top = NULL;
        intsearch_state_current->intsearch_state.operation = Search_Operation_Resync_Phase3;
      }
      rc = Search_Status_InProgress;
      break;

    case Search_Operation_Resync_Phase3:
    case Search_Operation_Resync_Phase3_Writing:
      /* Rebuild search chain...possibly from scratch. */

      /* If the search field is empty, ensure search chain is empty, and finish */
      if (strlen (intsearch_state_current->searchfield_state.new_field) < 1)
      {
        search_destroy_search_chain ();
        rc = Search_Status_Finished;
      }
      else
      {
        if (intsearch_state_current->intsearch_state.operation == Search_Operation_Resync_Phase3)
          rc = search_resync_phase3 (1, &intsearch_state_current->intsearch_state.operation);
        else
          rc = search_resync_phase3 (0, &intsearch_state_current->intsearch_state.operation);
      }
  }

  return rc;
}


/*******************/
static int search_resync_phase3 (int start, int *operation)
{
  int status;
  int len;

  int full_len = strlen (intsearch_state_current->searchfield_state.new_field);

  /* If we're starting a new character */
  if (start)
  {
    *operation = Search_Operation_Resync_Phase3_Writing;
    intsearch_state_current->resync_state.result_counter = 0;
    intsearch_state_current->resync_state.count = 0;

    if (intsearch_state_current->resync_state.partial_field)
      free (intsearch_state_current->resync_state.partial_field);

    if (intsearch_state_current->search_chain_top == NULL)
      len = 1;
    else
      len = strlen (intsearch_state_current->search_chain_current->search_term) + 1;

    intsearch_state_current->resync_state.partial_field = malloc (len + 1);
    strncpy (intsearch_state_current->resync_state.partial_field,
             intsearch_state_current->searchfield_state.new_field, len);
    intsearch_state_current->resync_state.partial_field[len] = '\0';
  }

  if (intsearch_state_current->search_chain_top == NULL)
  {
    status = search_add_char (&intsearch_state_current->resync_state.result_counter,
                              &intsearch_state_current->resync_state.count,
                               intsearch_state_current->resync_state.partial_field);

    if (status == Search_Status_Finished)
      *operation = Search_Operation_Resync_Phase3;

    return Search_Status_InProgress;
  }
  else
  {
    /* If we've re-constructed the whole search tree */
    if (strlen (intsearch_state_current->search_chain_current->search_term) == full_len)
    {
      /* Return the finished status */
      return Search_Status_Finished;
    }
    else
    {
      /* Continue to add the next character in the sequence */
      status = search_add_char (&intsearch_state_current->resync_state.result_counter,
                                &intsearch_state_current->resync_state.count,
                                 intsearch_state_current->resync_state.partial_field);

      /* If we've finished a character, continue on to the next */
      if (status == Search_Status_Finished)
        *operation = Search_Operation_Resync_Phase3;

      return Search_Status_InProgress;
    }
  }
  /* Should never reach here */
  return Search_Status_InProgress;
}


/***********/
static int search_number_match (char *search_field, char *str, char *last_p,
                                int count)
{
  char temp_str[25];
  char temp_str2[25];

  if (!strlen (str))
    return 0;

  /* Match all but the obviously wrong one digit numbers, to save problems */
  if (strlen (search_field) == 1)
  {
    switch (search_field[0])
    {
      case NUMCONVERT_INTERNATIONAL:
        if (str[0] == NUMCONVERT_EXTENSION)
        {
          /* Match failed. */
          return 0;
        }
        break;

      case 'x':
        if (str[0] != NUMCONVERT_EXTENSION)
        {
          /* Match failed. */
          return 0;
        }
        break;

      default:
        if (str[0] == NUMCONVERT_EXTENSION)
        {
          if (search_field[0] != str[1])
            return 0;
        }
        /* fall through */
        break;
    }

    dprintf (("", "1 char match --> "));
    return 1;
  }

  /* The user is typing an international number */
  if ((strlen (search_field) <= strlen (ip)) &&
      (strncmp (search_field, ip, strlen (search_field)) == 0))
  {
    dprintf (("", "International match 1 --> "));
    return 1;
  }

  if (str[0] == NUMCONVERT_EXTENSION && isdigit (search_field[0]) && (strlen (str) > 1))
  {
    if (strncmp (search_field, &str[1], strlen (search_field)) == 0)
    {
      dprintf (("", "Extension match --> "));
      return 1;
    }
  }

  /* Convert the entered number into internal format */
  strncpy (temp_str, search_field, sizeof (temp_str));
  temp_str[24] = '\0';
  numconvert_entered_to_internal (temp_str, temp_str2, sizeof (temp_str2),
                                  ip, np, cc, ac);

  /* USA hack, only do it if you're in the USA */
  if (temp_str2[0] != *last_p && (strcmp (cc, "1") == 0) &&
     (str[0] == NUMCONVERT_INTERNATIONAL ||
      str[0] == NUMCONVERT_NPANDAC ||
      str[0] == NUMCONVERT_AC ||
      str[0] == NUMCONVERT_NP) && str[1] == '1')
  {
    if (count == 1)
      *last_p = temp_str2[0];
    dprintf (("", "USA Hack 1 --> "));
    return 1;
  }
  if (count == 1)
    *last_p = temp_str2[0];

  /* The user is typing an international number */
  if ((strlen (temp_str2) == 1) &&
      (temp_str2[0] == NUMCONVERT_INTERNATIONAL) &&
      ((str[0] == NUMCONVERT_INTERNATIONAL) ||
       (str[0] == NUMCONVERT_NPANDAC) ||
       (str[0] == NUMCONVERT_AC) ||
       (str[0] == NUMCONVERT_NP)))
  {
    dprintf (("", "International match 2 --> "));
    return 1;
  }

  /* The "normal" match */
  if ((temp_str2[1] != '\0') && (str[1] != '\0'))
  {
    if (strstr (&(str[1]), &(temp_str2[1])) == &(str[1]))
    {
      dprintf (("", "Normal match --> "));
      return 1;
    }
  }

  /* And a final attempt to catch odd US numbers (only do it if in USA) */
  if (strcmp (cc, "1") == 0)
  {
    if ((str[0] == NUMCONVERT_INTERNATIONAL ||
         str[0] == NUMCONVERT_NPANDAC ||
         str[0] == NUMCONVERT_AC ||
         str[0] == NUMCONVERT_NP) && (str[1] == '1'))
    {
       if (strstr (str, search_field))
       {
         dprintf (("", "US Hack 2 --> "));
         return 1;
       }
    }
  }

  return 0;
}


/*******************/
static int search_add_char (int *result_counter, int *count, char *search_field)
{
  AddressRecord *rec;
  int record_num, ret;
  search_chain_record *temp_ptr;

  static char last = 'd';

  if (*count == 0)
    last = 'd';

  /* If the search chain is empty ... */
  if (intsearch_state_current->search_chain_current == NULL)
  {
    /* ... the record comes out of the full list of used records */
    record_num = flash_used_records_list[*count];
  }
  else
  {
    /* ... else use the reduced list from the search chain */
    record_num = intsearch_state_current->search_chain_current->result_list[*count];
  }

  /* If we haven't finished searching ... */
  if (record_num != -1)
  {
    /* Read the record */
    rec = flash_read_record (record_num);

    /* If for some reason the read failed (updated record perhaps),
       don't match the record */
    if (!rec)
      goto addchar_end;

    /* If it's a telephone number, check for match in fax and/or voice number */
    if (isdigit (search_field[0]) || search_field[0] == 'x' ||
                 search_field[0] == NUMCONVERT_INTERNATIONAL)
    {
      dprintf (("", "e = \"%s\" f = \"%s\" v = \"%s\" --> ", search_field, rec->fax_number,
                rec->voice_number));

      /* If the record contains a fax number ... */
      if (rec->fax_number)
      {
        if (strlen (rec->fax_number))
        {
          /* ... check if it matches the search field */
          ret = search_number_match (search_field, rec->fax_number, &last, *count);
          if (ret == 1)
          {
            dprintf (("", "Fax Match.\n"));
            /* It matches, so add the record to the result list and jump to the end */
            intsearch_state_current->addchar_result_list[(*result_counter)++] = record_num;
            goto addchar_end;
          }
          else
            dprintf (("", "Fax Fail. "));
        }
        else
          dprintf (("", "Fax Empty. "));
      }
      else
        dprintf (("", "Fax Empty. "));

      /* If the record contains a voice number ... */
      if (rec->voice_number)
      {
        if (strlen (rec->voice_number))
        {
          /* ... check if it matches the search field */
          ret = search_number_match (search_field, rec->voice_number, &last, *count);
          if (ret == 1)
          {
            dprintf (("", "Voice Match.\n"));
            /* It matches, so add the record to the result list and jump to the end */
            intsearch_state_current->addchar_result_list[(*result_counter)++] = record_num;
            goto addchar_end;
          }
          dprintf (("", "Voice Fail."));
        }
        else
          dprintf (("", "Voice Empty."));
      }
      else
        dprintf (("", "Voice Empty."));

      dprintf (("", "\n"));
    }

    /* Check for substring matches in the record fields */
    if (strings_match (search_field, rec->contact_name) ||
        strings_match (search_field, rec->company_name) ||
        strings_match (search_field, rec->email_address))
    {
      /* If the record matches, add an entry to the result list */
      intsearch_state_current->addchar_result_list[(*result_counter)++] = record_num;
    }

    addchar_end:

    /* Free the memory used for the record */
    misc_free_record_memory (rec);

    /* Go onto the next record */
    (*count)++;

    return Search_Status_InProgress;
  }

  /* Turn the temportary result list into a search chain entry */

  intsearch_state_current->addchar_result_list[*result_counter] = -1;

  if (intsearch_state_current->search_chain_top == NULL)
  {
    intsearch_state_current->search_chain_top = intsearch_state_current->search_chain_current =
        search_new_search_chain_item (intsearch_state_current->addchar_result_list, search_field);
    intsearch_state_current->search_chain_top->next =
        intsearch_state_current->search_chain_top->previous = NULL;
  }
  else
  {
    temp_ptr = search_new_search_chain_item (intsearch_state_current->addchar_result_list,
                                             search_field);
    intsearch_state_current->search_chain_current->next = temp_ptr;
    temp_ptr->previous = intsearch_state_current->search_chain_current;
    temp_ptr->next = NULL;
    intsearch_state_current->search_chain_current = temp_ptr;
  }

  /* And finish */
  return Search_Status_Finished;
}


/***********/
static void search_remove_tail (void)
{
  search_chain_record *temp_ptr;

  /* Delink the last item on the search chain */
  temp_ptr = intsearch_state_current->search_chain_current;
  intsearch_state_current->search_chain_current =
      intsearch_state_current->search_chain_current->previous;

  /* And free the memory */
  search_delete_search_chain_item (temp_ptr);

  /* And finish the linking */
  if (intsearch_state_current->search_chain_current)
    intsearch_state_current->search_chain_current->next = NULL;
  else
    intsearch_state_current->search_chain_top = NULL;
}


/* Make a new search chain item */
static search_chain_record *search_new_search_chain_item (int *result_list,
                                                          char *search_term)
{
  search_chain_record *new_item = NULL;

  new_item = (search_chain_record *) malloc (sizeof (search_chain_record));

  new_item->search_term = strdup (search_term);
  new_item->result_list = misc_integerlist_copy (result_list);
  new_item->next = new_item->previous = NULL;

  return new_item;
}


/* Delete a whole search chain */
static void search_destroy_search_chain (void)
{
  search_chain_record *temp_ptr = NULL, *temp_ptr2 = NULL;

  temp_ptr = intsearch_state_current->search_chain_top;

  while (temp_ptr != NULL)
  {
    temp_ptr2 = temp_ptr->next;
    search_delete_search_chain_item (temp_ptr);
    temp_ptr = temp_ptr2;
  }
  intsearch_state_current->search_chain_top = intsearch_state_current->search_chain_current = NULL;
}


/* Delete a search chain item */
static void search_delete_search_chain_item (search_chain_record *to_delete)
{
  if (to_delete)
  {
    if (to_delete->search_term)
      free (to_delete->search_term);
    if (to_delete->result_list)
      free (to_delete->result_list);
    free (to_delete);
    to_delete = NULL;
  }
}


/* Show the current search results in the result window */
static void search_show_results (void)
{
  AddressRecord *rec;
  int len;
  int *result_list;
  char num[15];
  char temp_str[25];

  if (intsearch_state_current->search_chain_current != NULL)
    result_list = intsearch_state_current->search_chain_current->result_list;
  else
    result_list = flash_used_records_list;

  len = misc_integerlist_findlength (result_list);
  if (len > 0)
  {
    if (intsearch_state_current->current_result_selection > (len -1))
      intsearch_state_current->current_result_selection = len - 1;

    sprintf (num, "%d / %d", intsearch_state_current->current_result_selection+1, len);
    button_set_value (0, ABSearch_WindowHandle, absearch_numberfound, num);

    rec = flash_read_record (result_list[intsearch_state_current->current_result_selection]);

    button_set_value (0, ABSearch_WindowHandle, absearch_name, rec->contact_name);
    button_set_value (0, ABSearch_WindowHandle, absearch_company,
                      rec->company_name);
    button_set_value (0, ABSearch_WindowHandle, absearch_email,
                      rec->email_address);

    if (strlen (rec->fax_number))
    {
      numconvert_internal_to_display (rec->fax_number, temp_str, sizeof (temp_str),
                                      ip, np, cc, ac);
    }
    else
      temp_str[0] = '\0';
    button_set_value (0, ABSearch_WindowHandle, absearch_fax, temp_str);

    if (strlen (rec->voice_number))
    {
      numconvert_internal_to_display (rec->voice_number, temp_str, sizeof (temp_str),
                                      ip, np, cc, ac);
    }
    else
      temp_str[0] = '\0';
    button_set_value (0, ABSearch_WindowHandle, absearch_voice, temp_str);

    switch (rec->routing_override)
    {
      case 0:
        button_set_value (0, ABSearch_WindowHandle, absearch_routing,
                          lookup_message_token (&message_block, "ABSearch_RoutingDefault"));
        break;
      case 1:
        button_set_value (0, ABSearch_WindowHandle, absearch_routing,
                          lookup_message_token (&message_block, "ABSearch_RoutingPhone"));
        break;
      default:
        button_set_value (0, ABSearch_WindowHandle, absearch_routing,
                          lookup_message_token (&message_block, "ABSearch_RoutingEmail"));
        break;
    }

    /* Free up the memory used for the record */
    misc_free_record_memory (rec);

    return;
  }
  else
  {
    intsearch_state_current->current_result_selection = 0;

    button_set_value (0, ABSearch_WindowHandle, absearch_numberfound, "0 / 0");
    button_set_value (0, ABSearch_WindowHandle, absearch_name, "");
    button_set_value (0, ABSearch_WindowHandle, absearch_company, "");
    button_set_value (0, ABSearch_WindowHandle, absearch_fax, "");
    button_set_value (0, ABSearch_WindowHandle, absearch_voice, "");
    button_set_value (0, ABSearch_WindowHandle, absearch_email, "");
    button_set_value (0, ABSearch_WindowHandle, absearch_routing, "");
  }
}


/******************/
/* Misc functions */


/* Fade/Unfade the search field writablefield */
static void search_searchfield_fade (Fade_Action action_code)
{
  if (action_code == Fade)
  {
    /* Then fade the writable */
    miscwimp_fade_gadget (ABSearch_WindowHandle, absearch_searchfield, Fade);

    /* Set an invisible caret */
    wimp_set_caret_position(intsearch_state_current->searchfield_state.caret_position.window_handle,
                            -1, 0, 0, (1 << 25), 0);
  }
  else if (action_code == UnFade)
  {
    /* First, unfade the writable */
    miscwimp_fade_gadget (ABSearch_WindowHandle, absearch_searchfield, UnFade);
  }
}
