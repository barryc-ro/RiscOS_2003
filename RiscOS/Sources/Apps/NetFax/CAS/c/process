/************************************************************************/
/*                  Copyright 1997 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#include "defs.h"
#include "inlines.h"
#include "wimp.h"
#include "inetlib.h"

#define DEBUG(u)

extern process_state update_status;
extern section *update_section;
extern section sections[];

FILE *response = NULL;

#define ALFCHAR "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
#define NUMCHAR "0123456789"

static const char *validstr = ALFCHAR NUMCHAR "!@#$%&*():,;|~<>.? ";
static const char *validint = NUMCHAR "+-";
static const char *validphn = NUMCHAR "*#,wW ";
static const char *validipa = ALFCHAR NUMCHAR "!@#$%&*():,;|~<>.? ";
/* static const char *validipa = ALFCHAR NUMCHAR "-.@"; */
static const char *validipn = NUMCHAR ".";

static char *RipNTrim(char *text)
{
  char *c, *ptr = text;
  int len;

  while (isspace(*ptr))                  /* Leading whitespace */
    ptr++;
  while (c = strchr(ptr, '\n'), c)       /* Trailing LF */
    *c = '\0';
  while (c = strchr(ptr, '\r'), c)       /* Trailing CR */
    *c = '\0';

  len = strlen(ptr);
  while (isspace(ptr[len - 1]))          /* Trailing whitespace */
    ptr[--len] = '\0';

  return(ptr);
}

static section *CheckSection(char *line)
{
  section *which;

  for (which = sections; which->name != NULL; which++)
  {
    if (strcmp(line, which->name) == 0)
    {
      fprintf(response, "\n%s\n", which->name);
      return(which);
    }
  }
  fprintf(response, "\n! Bad section name - %s\n", line);
  return(NULL);
}

BOOL StoreAndEcho(section *which, field *what, int argc, char *value[])
{
  char buffer[256];
  int good, len, loop, oldval, tosend, update = '&';
  struct in_addr ina;
  
  switch (what->type)
  {
  case AUFType_IPA:
  case AUFType_Phn:
  case AUFType_Str:
    _swix(SFConfigMan_Read, _INR(0, 2) | _OUT(0), what->name, buffer, 256, &len);
    buffer[len] = '\0';
    DEBUG(fprintf(response, "%s = %s\n", what->name, buffer));
    if (strcmp(buffer, value[0]) != 0)
    {
      _swix(SFConfigMan_Write, _INR(0, 2) | _OUT(0), what->name, value[0], strlen(value[0]), &good);
      if (good == 0)
        update = '*';
      else
        update = '#';
    }
    fprintf(response, "%c  %s = %s\n", update, what->name, buffer);
    break;

  case AUFType_Int:
    tosend = atoi(value[0]);
    _swix(SFConfigMan_Read, _INR(0, 2) | _OUT(0), what->name, &oldval, 0, &len);
    DEBUG(fprintf(response, "%s = %d\n", what->name, oldval));
    if (oldval != tosend)
    {
      _swix(SFConfigMan_Write, _INR(0, 2) | _OUT(0), what->name, &tosend, 0, &good);
      if (good == 0)
        update = '*';
      else
        update = '#';
    }
    fprintf(response, "%c  %s = %d\n", update, what->name, oldval);
    break;

  case AUFType_IPN:
     tosend  = inet_addr(value[0]);
    _swix(SFConfigMan_Read, _INR(0, 2) | _OUT(0), what->name, &ina.s_addr, 0, &len);
    DEBUG(fprintf(response, "%s = %s\n", what->name, inet_ntoa(ina)));
    if (ina.s_addr != tosend)
    {
      _swix(SFConfigMan_Write, _INR(0, 2) | _OUT(0), what->name, &tosend, 0, &good);
      if (good == 0)
        update = '*';
      else
        update = '#';
    }
    fprintf(response, "%c  %s = %s\n", update, what->name, inet_ntoa(ina));
    break;

  case AUFType_Tim:
    _swix(SFConfigMan_Read, _INR(0, 2) | _OUT(0), what->name, buffer, 256, &len);
    buffer[len] = '\0';
    fprintf(response, "*  %s = ", what->name);
    for (loop = 0; loop < (len / 4); loop++)
    {
      if (*value[loop] != 'X')
      {
        memcpy(&buffer[loop << 2], value[loop], 4);
      }
      fprintf(response, "%4.4s%s", &buffer[loop << 2], loop <  (len / 4) - 1 ? "," : "");
    }
    fprintf(response, "\n");
    _swix(SFConfigMan_Write, _INR(0, 2) | _OUT(0), what->name, buffer, 16, &good);
    break;

  case AUFType_Flg:
    if (*value[0] == '1' || strcmp(value[0], "TRUE") == 0)
      tosend = 1;
    else
      tosend = 0;
    _swix(SFConfigMan_Read, _INR(0, 2) | _OUT(0), what->name, &oldval, 0, &len);
    DEBUG(fprintf(response, "--- %s = %d\n", what->name, oldval));
    if (oldval != tosend)
    {
      _swix(SFConfigMan_Write, _INR(0, 2) | _OUT(0), what->name, &tosend, 0, &good);
      if (good == 0)
        update = '*';
      else
        update = '#';
    }
    fprintf(response, "%c  %s = %d\n", update, what->name, oldval);
    break;

  case AUFType_Spc:
    if (strcmp(what->name, "TimeZone") == 0)
    {
      char *tval = value[0];
      int hrs, mins;
      
      if (*tval == '+'|| *tval == '-')
        tval++;
      mins = atoi(&tval[2]);
      hrs  = atoi(tval) / 100;
      tosend = hrs * 4 + mins / 15;
      if (*value[0] == '-')
        tosend = 0 - tosend;

      _swix(SFConfigMan_Read, _INR(0, 2) | _OUT(0), what->name, &oldval, 0, &len);
      DEBUG(fprintf(response, "%s = %d\n", what->name, oldval));
      if (oldval != tosend)
      {
        _swix(SFConfigMan_Write, _INR(0, 2) | _OUT(0), what->name, &tosend, 0, &good);
        if (good == 0)
          update = '*';
        else
          update = '#';
      }
      fprintf(response, "%c  %s = %d\n", update, what->name, oldval);
    }
    break;

  case AUFType_Act:
    fprintf(response, "Action performed - %s\n", Export_Data(which, what, argc, value));
    break;
  }
  return(FALSE);
}

static char *SkipSpace(char *p)
{
  while (isspace(*p))
    p++;
  return p;
}

/* Command args extraction function
 * Borrowed from KA9Q/!TCPIP package
 * Can be used in two ways:
 * 1. Entered with argv==NULL to count the args only
 *    for eg to determin size of array needed for
 *    arg pointers.
 * 2. Entered with argv pointing to an array of char*
 *    with sufficient entries for number of args present
 * cmd is the command line being processed.
 *
 * Returns number of args present, ignoring tail comments
 * or <0 if a parse error occurs (eg missing quote)
 *
 * No escape sequence processing is done, other than to not count
 * '\"' as a '"', as may need to be handled differently according to
 * usage
 */
static int CommandTokenise(char *line, char *argv[])
{
  int n = 0;
  char *p = line;
  BOOL trailing = FALSE;

  while (*p != '\0' || trailing)
  {
    trailing = FALSE;
    p = SkipSpace(p);

/* Non escaped quote? (ie start of token) */
    if (*p == '\"')
    {
      ++p;

      if (argv != NULL)
        argv[n] = p;

  /* scan forward for another non escaped quote */
      while (!(*p == '\"' && *(p - 1) != '\\') && *p != '\0')
        ++p;

  /* Test for missing closing quote, and return a parse error if missing */
      if (*p == '\0')
        return -1;

      if (argv != NULL)  /* Terminate arg if extracting */
        *p = '\0';

      ++p;
      ++n;
      if (*p == ',')
      {
        p++;
        trailing = TRUE;
      }
    }
    else /* if (*p != '\0') */
    {
  /* Added to allow comments on end of script command to be ignored Tail
     comments may be either C++ style "// ..." or the style commonly used in
     scripts "# ..." and "; ..." */
  /*     if (!strncmp("#", p, 1) || !strncmp(";", p, 1) || !strncmp("//", p, 2))
        break; */

      if (argv != NULL)
        argv[n] = p;

      while (!isspace(*p) && *p != '\0' && *p != ',')
        ++p;

      if (argv != NULL && *p != '\0')  /* Terminate arg if extracting */
      {
        *p++ = '\0';
        trailing = TRUE;
      }

      ++n;
/*       if (*p == ',')
        p++; */
    }
  }
  return n;  /* Number of args found */
}

BOOL Validate(field *what, char *value)
{
  int len, val;
  
  switch (what->type)
  {
  case AUFType_Str:
    len = strlen(value);
    if (strspn(value, validstr) == len && len <= what->maxlen)
      return(TRUE);
    break;

  case AUFType_Int:
    if (strspn(value, validint) < strlen(value))
      return(FALSE);
    val = atoi(value);
    if (val >= what->minval && val <= what->maxval)
      return(TRUE);   
    break;

  case AUFType_Phn:
    len = strlen(value);
    if (strspn(value, validphn) == len && len <= what->maxlen)
      return(TRUE);
    break;

  case AUFType_IPA:
    if (strspn(value, validipa) == strlen(value))
      return(TRUE);
    break;

  case AUFType_IPN:
    if (strspn(value, validipn) == strlen(value))
      return(TRUE);
    break;

  case AUFType_Tim:
    len = strlen(value);
    if ((len == 1 && *value == 'X'))
      return(TRUE);
    if (len < 4 || strspn(value, NUMCHAR) < len)
      return(FALSE);
    val = atoi(&value[2]);
    if (val > 59 || val < 0)
      return(FALSE);
    val = atoi(value);
    if (val > 2359 || val < 0)
      return(FALSE);
    return(TRUE);
    break;

  case AUFType_Flg:
    len = strlen(value);
    if (len == 1 && (*value == '0' || *value == '1'))
      return(TRUE);
    if (strcmp(value, "FALSE") == 0 || strcmp(value, "TRUE") == 0)
      return(TRUE);
   return(FALSE);
   break;

  case AUFType_Spc:
    if (strcmp(what->name, "TimeZone") == 0)
    {
      char *tval = value;
      
      if (*tval == '+'|| *tval == '-')
        tval++;
      len = strlen(tval);
      if (len < 4 || strspn(tval, NUMCHAR) < len)
        return(FALSE);
      val = atoi(&tval[2]);
      if (val != 0 && val != 15 && val != 30 && val != 45)
        return(FALSE);
      val = atoi(tval);
      if (val > 2359 || val < 0)
        return(FALSE);
      return(TRUE);
    }
    return(TRUE);
    break;

  case AUFType_Act:
    return(TRUE);
    break;
  }
  return(FALSE);
}

static BOOL CompileLine(char *buffer, FILE *fin)
{
  char *line, *slash;

  slash = buffer;
  do
  {
    line = fgets(slash, 256, fin);
    RipNTrim(buffer);
    if (buffer[strlen(buffer) - 1] == '\\')
      slash = &buffer[strlen(buffer) - 1];
    else
      slash = buffer;
  } while (line != NULL && slash != buffer);
  if (line == NULL)
    return(FALSE);
  return(TRUE);
}

BOOL ProcessMail(char *filename, char *reply)
{
  char *line;
  char buffer[2048];
  FILE *fin;

  update_status = Admin_State_Scanning;

  if (response = fopen(reply, "w"), response == NULL)
  {
    return(FALSE);
  }
#if FALSE  
  else
  {
    int len;
    time_t now = time(NULL);
    
    strftime(buffer, 2048, "%a, %d %B %Y %H:%M:%S", gmtime(&now));
    fprintf(response, "Date: %s\n", buffer);
    _swix(SFConfigMan_Read, _INR(0, 2) | _OUT(0), "POP3mailbox", buffer, 256, &len);
    buffer[len] = '\0';
    fprintf(response, "From: %s\n", buffer);
    _swix(SFConfigMan_Read, _INR(0, 2) | _OUT(0), "NotificationOfReconfig", buffer, 256, &len);
    buffer[len] = '\0';
    fprintf(response, "To: %s\n", buffer);
    fprintf(response, "Subject: Result of Admin Update\n");
    strftime(buffer, 2048, "%Y%m%d.%H%M%Srcfg", gmtime(&now));
    fprintf(response, "Message-ID: %s\n\n", buffer);
  }
#endif

  if (fin = fopen(filename, "r"), fin)
  {
    vdu4();
    fprintf(response, "Opened file %s\n", filename);
    while (CompileLine(buffer, fin) && update_status != Admin_State_Idle)
    {
      line = RipNTrim(buffer);

      switch (update_status)
      {
      case Admin_State_Scanning:
        if (strcmp(line, "BEGIN TRANSACTION") == 0)
          update_status = Admin_State_Valid;
        else if (strcmp(line, "END TRANSACTION") == 0)
          update_status = Admin_State_Idle;
        else if (strcmp(line, "END PARTITION") == 0)
          update_status = Admin_State_Idle;
        break;

      case Admin_State_Valid:
      case Admin_State_Section:
        if (*line == '\0')
          continue;
        else if (*line == '[')      /* We're not in the section any more Toto */
        {
          if (update_section = CheckSection(line), update_section)
            update_status = Admin_State_Section;
          else
            update_status = Admin_State_Valid;
        }
        else if (strcmp(line, "END TRANSACTION") == 0)
        {
          update_status = Admin_State_Idle;
        }
        else if (strcmp(line, "END PARTITION") == 0)
        {
          update_status = Admin_State_Idle;
        }
        else
        {
          BOOL valid;
          char *cp;
          char *argv[MAXARG];
          field *what;
          int argc, loop;

          if (update_section)
          {
            fprintf(response, "%s\n", line);

            if (cp = strchr(line, '='), cp)
            {
              *cp++ = '\0';
              line = RipNTrim(line);
            }
            for (what = update_section->fields; what->type != AUFType_Sct; what++)
            {
              if (strcmp(what->name, line) == 0)
              {
                if (cp != NULL)
                  argc = CommandTokenise(cp, argv);
                else
                  argc = 0;
                
                DEBUG(fprintf(response, "  %s - %d arg%s\n", line, argc, argc == 1 ? "" : "s"));
                if (argc < what->minparam || argc > what->maxparam)
                {
                  fprintf(response, "! Wrong number of parameters\n");
                  break;
                }
                valid = TRUE;
                for (loop = 0; loop < argc; loop++)
                {
                  DEBUG(fprintf(response, "    %d      %s\n", loop + 1, argv[loop]));
                  valid &= Validate(what, argv[loop]);
                }
                if (valid)
                  StoreAndEcho(update_section, what, argc, argv);
                else
                  fprintf(response, "! Bad value supplied\n");
                break;
              }
            }
            if (what->type == AUFType_Sct)
            {
              fprintf(response, "! Bad field name for this section %s - %s\n", update_section->name, line);
            }
          }
        }
        break;
      }
    }
    fclose(fin);
    remove(filename);
  }
  update_status = Admin_State_Idle;
  fclose(response);
  response = NULL;
  {
    int len;
    message_block msg;

    memset(&msg, '\0', sizeof(message_block));

#if FALSE
    msg.header.size   = 256;
    msg.header.action = 0x83580;
    msg.data.newsbase.command  = 310;
    msg.data.newsbase.flags    = 0;
    strcpy(msg.data.newsbase.filename, reply);
#else
    msg.header.size   = 256;
    msg.header.action = Message_DayCas_SendMail;
    msg.data.sendnote.send_methods = 0; /* 0 in the nethods means send */
    _swix(SFConfigMan_Read, _INR(0, 2) | _OUT(0), "NotificationOfReconfig",
          msg.data.sendnote.email_address, 232, &len);
    msg.data.sendnote.email_address[len] = '\0';
#endif    
    _swix(Wimp_SendMessage, _INR(0, 5), 18, &msg, 0, 0, 0, 0);

    msg.header.size   = 28;
    msg.header.action = Message_Dayt_Setup;
    msg.data.words[0] = 0; 

    _swix(Wimp_SendMessage, _INR(0, 5), 18, &msg, 0, 0, 0, 0);

    msg.header.size   = 256;
    msg.header.action = Message_DayLog_SendEntry;
    strncpy(msg.data.logentry.log_entry, "CAS generated configuration update processed", 236);

    _swix(Wimp_SendMessage, _INR(0, 5), 18, &msg, 0, 0, 0, 0);
  }
  return(TRUE);
}
