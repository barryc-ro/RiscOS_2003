     1   
     3   
     4   
     5   
     6   
     7   
     8   
     9   
    10   
    11  
    12  
    18  
+++ C:sys.h.types: 45: Warning: Non-ANSI #include <sys/cdefs.h>
+++ C:sys.h.types: 48: Warning: Non-ANSI #include <machine/endian.h>
+++ C:sys.h.types: 106: Warning: Non-ANSI #include <machine/ansi.h>
+++ C:sys.h.types: 107: Warning: Non-ANSI #include <machine/types.h>
    23  
    24  
    25  extern process_state update_status;
    26  extern section *update_section;
    27  extern section sections[];
    28  
    29  static FILE *response =  0 ;
    30  
    31  
    32  
    33  
    34  static const char *validstr =  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"   "0123456789"  "!@#$%&*():,;|~<>.? ";
    35  static const char *validint =  "0123456789"  "+-";
    36  static const char *validphn =  "0123456789"  "*#,wW ";
    37  static const char *validipa =  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"   "0123456789"  "!@#$%&*():,;|~<>.? ";
    38   
    39  static const char *validipn =  "0123456789"  ".";
    40  
    41  static char *RipNTrim(char *text)
    42  {
    43    char *c, *ptr = text;
    44    int len;
    45  
    46    while ( (__ctype[ *ptr ] &  1 ) )                   
    47      ptr++;
    48    while (c = strchr(ptr, '\n'), c)        
    49      *c = '\0';
    50    while (c = strchr(ptr, '\r'), c)        
    51      *c = '\0';
    52  
    53    len = strlen(ptr);
    54    while ( (__ctype[ ptr[len - 1] ] &  1 ) )           
    55      ptr[--len] = '\0';
    56  
    57    return(ptr);
    58  }
    59  
    60  BOOL SendConfig(void)
    61  {
    62    char buffer[260];
    63    field *what;
    64    int len, val;
    65    struct in_addr ina;
    66  
    67    for (what = biglist; what->name; what++)
    68    {
    69      switch (what->type)
    70      {
    71      case AUFType_Sct:
    72        fprintf(response, "%s\n", what->name);
    73        break;
    74    
    75      case AUFType_IPA:
    76      case AUFType_Phn:
    77      case AUFType_Str:
    78        _swix( 0x050a40 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, buffer, 256, &len);
    79        buffer[len] = '\0';
    80        fprintf(response, "%s = %s\n", what->name, buffer);
    81        break;
    82    
    83      case AUFType_Int:
    84      case AUFType_Flg:
    85        _swix( 0x050a40 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, &val, 0, &len);
    86        fprintf(response, "%s = %d\n", what->name, val);
    87        break;
    88    
    89      case AUFType_IPN:
    90        _swix( 0x050a40 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, &ina.s_addr, 0, &len);
    91        fprintf(response, "%s = %s\n", what->name, inet_ntoa(ina));
    92        break;
    93    
    94      case AUFType_Tim:
    95        {
    96          int loop;
    97          
    98          _swix( 0x050a40 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, buffer, 256, &len);
    99          fprintf(response, "%s = ", what->name);
   100          for (loop = 0; loop < (len / 4); loop++)
   101          {
   102            fprintf(response, "%4.4s%s", &buffer[loop << 2], loop < 3 ? "," : "");
   103          }
   104          fprintf(response, "\n");
   105        }
   106        break;
   107      }
   108    }  
   109    return( 0 );
   110  }
   111  
   112  static section *CheckSection(char *line)
   113  {
   114    section *which;
   115  
   116    for (which = sections; which->name !=  0 ; which++)
   117    {
   118      if (strcmp(line, which->name) == 0)
   119      {
   120        fprintf(response, "\n%s\n", which->name);
   121        return(which);
   122      }
   123    }
   124    return( 0 );
   125  }
   126  
   127  BOOL StoreAndEcho(section *which, field *what, int argc, char *value[])
   128  {
   129    char buffer[256];
   130    int good, len, loop, oldval, tosend, update = '&';
   131    struct in_addr ina;
   132    
   133    switch (what->type)
   134    {
   135    case AUFType_IPA:
   136    case AUFType_Phn:
   137    case AUFType_Str:
   138      _swix( 0x050a40 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, buffer, 256, &len);
   139      buffer[len] = '\0';
   140        ;
   141      if (strcmp(buffer, value[0]) != 0)
   142      {
   143        _swix( 0x050a41 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, value[0], strlen(value[0]), &good);
   144        if (good == 0)
   145          update = '*';
   146        else
   147          update = '#';
   148      }
   149      fprintf(response, "%c  %s = %s\n", update, what->name, buffer);
   150      break;
   151  
   152    case AUFType_Int:
   153      tosend = atoi(value[0]);
   154      _swix( 0x050a40 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, &oldval, 0, &len);
   155        ;
   156      if (oldval != tosend)
   157      {
   158        _swix( 0x050a41 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, &tosend, 0, &good);
   159        if (good == 0)
   160          update = '*';
   161        else
   162          update = '#';
   163      }
   164      fprintf(response, "%c  %s = %d\n", update, what->name, oldval);
   165      break;
   166  
   167    case AUFType_IPN:
   168       tosend  = inet_addr(value[0]);
+++ Warning: implicit narrowing cast: '='
   169      _swix( 0x050a40 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, &ina.s_addr, 0, &len);
   170        ;
   171      if (ina.s_addr != tosend)
   172      {
   173        _swix( 0x050a41 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, &tosend, 0, &good);
   174        if (good == 0)
   175          update = '*';
   176        else
   177          update = '#';
   178      }
   179      fprintf(response, "%c  %s = %s\n", update, what->name, inet_ntoa(ina));
   180      break;
   181  
   182    case AUFType_Tim:
   183      _swix( 0x050a40 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, buffer, 256, &len);
   184      buffer[len] = '\0';
   185      fprintf(response, "*  %s = ", what->name);
   186      for (loop = 0; loop < (len / 4); loop++)
   187      {
   188        if (*value[loop] != 'X')
   189        {
   190          memcpy(&buffer[loop << 2], value[loop], 4);
   191        }
   192        fprintf(response, "%4.4s%s", &buffer[loop << 2], loop <  (len / 4) - 1 ? "," : "");
   193      }
   194      fprintf(response, "\n");
   195      _swix( 0x050a41 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, buffer, 16, &good);
   196      break;
   197  
   198    case AUFType_Flg:
   199      if (*value[0] == '1' || strcmp(value[0], "TRUE") == 0)
   200        tosend = 1;
   201      else
   202        tosend = 0;
   203      _swix( 0x050a40 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, &oldval, 0, &len);
   204        ;
   205      if (oldval != tosend)
   206      {
   207        _swix( 0x050a41 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , what->name, &tosend, 0, &good);
   208        if (good == 0)
   209          update = '*';
   210        else
   211          update = '#';
   212      }
   213      fprintf(response, "%c  %s = %d\n", update, what->name, oldval);
   214      break;
   215  
   216    case AUFType_Qry:
   217      break;
   218  
   219    case AUFType_Act:
   220      break;
   221  
   222    case AUFType_Frm:
   223      break;
   224  
   225    case AUFType_Mxd:
   226      break;
   227    }
   228    return( 0 );
   229  }
   230  
   231  static char *SkipSpace(char *p)
   232  {
   233    while ( (__ctype[ *p ] &  1 ) )
   234      p++;
   235    return p;
   236  }
   237  
   238   
   254  
   254  
   254  
   254  
   254  
   254  
   254  
   254  
   254  
   254  
   254  
   254  
   254  
   254  
   254  
   254  
   255  static int CommandTokenise(char *line, char *argv[])
   256  {
   257    int n = 0;
   258    char *p = line;
   259  
   260    while (*p != '\0')
   261    {
   262      p = SkipSpace(p);
   263  
   264   
   265      if (*p == '\"')
   266      {
   267        ++p;
   268  
   269        if (argv !=  0 )
   270          argv[n] = p;
   271  
   272     
   273        while (!(*p == '\"' && *(p - 1) != '\\') && *p != '\0')
   274          ++p;
   275  
   276     
   277        if (*p == '\0')
   278          return -1;
   279  
   280        if (argv !=  0 )   
   281          *p = '\0';
   282  
   283        ++p;
   284        ++n;
   285        if (*p == ',')
   286          p++;
   287      }
   288      else if (*p != '\0')
   289      {
   290     
   292  
   292  
   293     
   294  
   295  
   296        if (argv !=  0 )
   297          argv[n] = p;
   298  
   299        while (! (__ctype[ *p ] &  1 )  && *p != '\0' && *p != ',')
   300          ++p;
   301  
   302        if (argv !=  0  && *p != '\0')   
   303          *p++ = '\0';
   304  
   305        ++n;
   306        if (*p == ',')
   307          p++;
   308      }
   309    }
   310    return n;   
   311  }
   312  
   313  BOOL Validate(field *what, char *value)
   314  {
   315    int len, val;
   316    
   317    switch (what->type)
   318    {
   319    case AUFType_Str:
   320      len = strlen(value);
   321      if (strspn(value, validstr) == len && len <= what->maxlen)
   322        return( (!( 0 )) );
   323      break;
   324  
   325    case AUFType_Int:
   326      if (strspn(value, validint) < strlen(value))
   327        return( 0 );
   328      val = atoi(value);
   329      if (val >= what->minval && val <= what->maxval)
   330        return( (!( 0 )) );   
   331      break;
   332  
   333    case AUFType_Phn:
   334      len = strlen(value);
   335      if (strspn(value, validphn) == len && len <= what->maxlen)
   336        return( (!( 0 )) );
   337      break;
   338  
   339    case AUFType_IPA:
   340      if (strspn(value, validipa) == strlen(value))
   341        return( (!( 0 )) );
   342      break;
   343  
   344    case AUFType_IPN:
   345      if (strspn(value, validipn) == strlen(value))
   346        return( (!( 0 )) );
   347      break;
   348  
   349    case AUFType_Tim:
   350      len = strlen(value);
   351      if ((len == 1 && *value == 'X'))
   352        return( (!( 0 )) );
   353      if (len < 4 || strspn(value,  "0123456789" ) < len)
   354        return( 0 );
   355      val = atoi(&value[2]);
   356      if (val > 59 || val < 0)
   357        return( 0 );
   358      val = atoi(value);
   359      if (val > 2359 || val < 0)
   360        return( 0 );
   361      return( (!( 0 )) );
   362      break;
   363  
   364    case AUFType_Flg:
   365      len = strlen(value);
   366      if (len == 1 && (*value == '0' || *value == '1'))
   367        return( (!( 0 )) );
   368      if (strcmp(value, "FALSE") == 0 || strcmp(value, "TRUE") == 0)
   369        return( (!( 0 )) );
   370     return( 0 );
   371     break;
   372  
   373    case AUFType_Qry:
   374      return( (!( 0 )) );
   375      break;
   376  
   377    case AUFType_Act:
   378      return( (!( 0 )) );
   379      break;
   380  
   381    case AUFType_Frm:
   382      return( (!( 0 )) );
   383      break;
   384  
   385    case AUFType_Mxd:
   386      return( (!( 0 )) );
   387      break;
   388    }
   389    return( 0 );
   390  }
   391  
   392  static BOOL CompileLine(char *buffer, FILE *fin)
   393  {
   394    char *line, *slash;
   395  
   396    slash = buffer;
   397    do
   398    {
   399      line = fgets(slash, 256, fin);
   400      RipNTrim(buffer);
   401      if (buffer[strlen(buffer) - 1] == '\\')
   402        slash = &buffer[strlen(buffer) - 1];
   403      else
   404        slash = buffer;
   405    } while (line !=  0  && slash != buffer);
   406    if (line ==  0 )
   407      return( 0 );
   408    return( (!( 0 )) );
   409  }
   410  
   411  BOOL ProcessMail(char *filename, char *reply)
   412  {
   413    char *line;
   414    char buffer[2048];
   415    FILE *fin;
   416  
   417    update_status = Admin_State_Scanning;
   418  
   419    if (response = fopen(reply, "w"), response ==  0 )
   420    {
   421      return( 0 );
   422    }
   423   0   
   424  
   424  
   425  
   426  
   427  
   428  
   429  
   430  
   431  
   432  
   433  
   434  
   435  
   436  
   437  
   438  
   439  
   440  
   441  
   442  
   443    if (fin = fopen(filename, "r"), fin)
   444    {
   445      vdu4();
   446      fprintf(response, "Opened file %s\n", filename);
   447      while (CompileLine(buffer, fin) && update_status != Admin_State_Idle)
   448      {
   449        line = RipNTrim(buffer);
   450  
   451        switch (update_status)
   452        {
   453        case Admin_State_Scanning:
   454          if (strcmp(line, "BEGIN TRANSACTION") == 0)
   455            update_status = Admin_State_Valid;
   456          else if (strcmp(line, "END TRANSACTION") == 0)
   457            update_status = Admin_State_Idle;
   458          else if (strcmp(line, "END PARTITION") == 0)
   459            update_status = Admin_State_Idle;
   460          break;
   461  
   462        case Admin_State_Valid:
   463        case Admin_State_Section:
   464          if (*line == '\0')
   465            continue;
   466          else if (*line == '[')       
   467          {
   468            if (update_section = CheckSection(line), update_section)
   469              update_status = Admin_State_Section;
   470            else
   471              update_status = Admin_State_Valid;
   472          }
   473          else if (strcmp(line, "END TRANSACTION") == 0)
   474          {
   475            update_status = Admin_State_Idle;
   476          }
   477          else if (strcmp(line, "END PARTITION") == 0)
   478          {
   479            update_status = Admin_State_Idle;
   480          }
   481          else
   482          {
   483            BOOL valid;
   484            char *cp;
   485            char *argv[ (256) ];
   486            field *what;
   487            int argc, loop;
   488  
   489            if (update_status)
   490            {
   491              fprintf(response, "%s\n", line);
   492  
   493              if (cp = strchr(line, '='), cp)
   494              {
   495                *cp++ = '\0';
   496                line = RipNTrim(line);
   497              }
   498              for (what = update_section->fields; what->type != AUFType_Sct; what++)
   499              {
   500                if (strcmp(what->name, line) == 0)
   501                {
   502                  argc = CommandTokenise(cp, argv);
   503                  
   504                    ;
   505                  if (argc < what->minparam || argc > what->maxparam)
   506                  {
   507                    fprintf(response, "! Wrong number of parameters\n");
   508                    break;
   509                  }
   510                  valid =  (!( 0 )) ;
   511                  for (loop = 0; loop < argc; loop++)
   512                  {
   513                      ;
   514                    valid &= Validate(what, argv[loop]);
   515                  }
   516                  if (valid)
   517                    StoreAndEcho(update_section, what, argc, argv);
   518                  else
   519                    fprintf(response, "! Bad value supplied\n");
   520                  break;
   521                }
   522              }
   523              if (what->type == AUFType_Sct)
   524              {
   525                fprintf(response, "! Bad field name for this section %s - %s\n", update_section->name, line);
   526              }
   527            }
   528          }
   529          break;
   530        }
   531      }
   532      fclose(fin);
   533    }
   534    update_status = Admin_State_Idle;
   535    fclose(response);
   536    response =  0 ;
   537    {
   538      int len;
   539      message_block msg;
   540  
   541      memset(&msg, '\0', sizeof(message_block));
   542  
   543   0 
   544  
   544  
   545  
   546  
   547  
   548  
   549  
   550      msg.header.size   = 256;
   551      msg.header.action =  0x50D08 ;
   552      msg.data.sendnote.send_methods = 0;  
   553      _swix( 0x050a40 ,  (~0 << ( 0 ) ^ ~0 << ( 2 ) + 1)  |  (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , "NotificationOfReconfig",
   554            msg.data.sendnote.email_address, 232, &len);
   555      msg.data.sendnote.email_address[len] = '\0';
   556  
   557      _swix( 0x000400E7 ,  (~0 << ( 0 ) ^ ~0 << ( 5 ) + 1) , 18, &msg, 0, 0, 0, 0);
   558    }
   559    return( (!( 0 )) );
   560  }
   561  
