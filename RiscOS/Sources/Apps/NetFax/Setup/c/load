/************************************************************************/
/* File:    load.c                                                      */
/* Purpose: Handles data loading from Flash                             */
/*                                                                      */
/* Author:  Hed Simons (created by Neil Bingham)                        */
/* History: Wed 27th August 1997    ver 0.01 - Created.                 */
/*          Thu 18th December 1997  ver 0.09 - Done loads to it by now! */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include <string.h>

#include "main.h"
#include "cancel.h"
#include "functions.h"
#include "swis.h"
#include "kernel.h"
#include "misc.h"
#include "messhandle.h"
#include "scheduler.h"
#include "ui.h"
#include "numconvert/numconvert.h"
#include "save.h"
#include "load.h"

extern void optdate_set_clock(char, int, int, int, int, int, int);
extern void optdate_set_datetime(void);
extern int save_routing_lookup(char *);
/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */


/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

static char internal_string[30] = {0x54, 0x68, 0x65, 0x48, 0x65, 0x72, 0x6F, 0x4C, 0x69, 0x73, 0x74, 0x00};

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************************************
 * Name       : load_swi_call                                                                   *
 * Parameters : tag string, result buffer, sizeof(buffer)                                       *
 * Purpose    : Takes the tag and buffer, and loads the value stored in the tag into the buffer *
 *              using the SFConfigMan SWI call                                                  *
 * Returns    : Returns either the size of the result, or a relevant error code                 *
 ************************************************************************************************/
int load_swi_call(char *tag, char *result_buffer, int buffer_size)
{
  _kernel_oserror       *er;
  _kernel_swi_regs      regs;

  /* Load in the values given, call the SWI and return the chosen values */
  regs.r[0] = (int)tag;
  regs.r[1] = (int)result_buffer;
  regs.r[2] = buffer_size;
  er = _kernel_swi(SFConfigMan_Read, &regs, &regs);

  /* If the result isn't empty, terminate the string with a null character */
  if (buffer_size != 0)
  {
    if (regs.r[0] >= 0)
      result_buffer[regs.r[0]] = '\0';

    /* If the tag doesn't exist, or there isn't any data in it, return a NULL string */
    if ((regs.r[0] == -1) || (regs.r[0] == 0))
      result_buffer[0] = '\0';
  }
  /* Return the string/tag */
  return regs.r[0];
}

/************************************************************************************************
 * Name        : load_pause_convert                                                             *
 * Parameters  : saved input character                                                          *
 * Description : Takes the saved Pause character and converts it to an optionfield tag number   *
 * Returns     : Converted tag number                                                           *
 ************************************************************************************************/
int load_pause_convert(int id)
{
  int decode = 0;

  switch (id)
  {
    case 0:
    {
      decode = 0;   /* No pause between numbers */
      break;
    }

    case ',':
    {
      decode = 1;   /* Single pause between numbers */
      break;
    }

    case 'W':
    {
      decode = 2;   /* Wait for the dial tone */
      break;
    }
  }

  return (decode);
}

/************************************************************************************************
 * Name       : load_test_valid                                                                 *
 * Parameters : input token, value of loaded flag                                               *
 * Purpose    : Tests whether the flag is within the boundaries of the field                    *
 * Returns    : A corrected value of the flag                                                   *
 ************************************************************************************************/
int load_test_valid(char *tag_first, char *tag_last, int loaded_flag)
{
  int first_flag, last_flag;

  first_flag = atoi(lookup_message_token(&message_block, tag_first));
  last_flag = atoi(lookup_message_token(&message_block, tag_last));

  /*dprintf(("", "First flag is : %d\n", first_flag));
  dprintf(("", "Last flag is : %d\n", last_flag));
  dprintf(("", "Flag given is : %d\n", loaded_flag));*/

  if ((loaded_flag < first_flag) || (loaded_flag > last_flag))
  {
    dprintf(("", "Out of range error\n"));
    return (first_flag);
  }
  else
    return (loaded_flag);
}

/************************************************************************************************
 * Name       : load_testalign_valid                                                            *
 * Parameters : input token, value of loaded flag                                               *
 * Purpose    : Tests whether the flag is within the boundaries of the field, and if it is      *
 *               aligned properly                                                               *
 * Returns    : A corrected value of the flag                                                   *
 ************************************************************************************************/
int load_testalign_valid(char *tag_first, char *tag_last, char *tag_incr, int loaded_flag)
{
  int first_flag, last_flag, incr_flag;

  first_flag = atoi(lookup_message_token(&message_block, tag_first));
  last_flag = atoi(lookup_message_token(&message_block, tag_last));
  incr_flag = atoi(lookup_message_token(&message_block, tag_incr));

 /* force alignment */
  loaded_flag -= loaded_flag % incr_flag;

  if ((loaded_flag < first_flag) || (loaded_flag > last_flag))
  {
    dprintf(("", "Out of range error\n"));
    return (first_flag);
  }
  else
    return (loaded_flag);
}

/************************************************************************************************
 * Name        : load_decode_number                                                             *
 * Parameters  : internal number string, buffer string, size of buffer string                   *
 * Description : Takes the internal representation of the number stored and loads the relevant  *
 *               information to decode it into a display format                                 *
 *               (using numconvert_internal_to_display)                                         *
 * Returns     : Non-zero integer on error                                                      *
 ************************************************************************************************/
int load_decode_number(char *inter_num, char *display_num, int display_size)
{
  int    error;
  char   ip[50], np[50], cc[50], ac[50];

  display_num[0] = 0;  /* clear result string in case of error */

  error = load_swi_call("InternationalAccessCode", ip, sizeof(ip));
  error = load_swi_call("NationalAccessCode", np, sizeof(np));
  error = load_swi_call("FaxCountryCode", cc, sizeof(cc));
  error = load_swi_call("FaxAreaCode", ac, sizeof(ac));

  error = numconvert_internal_to_display(inter_num, display_num, display_size, ip, np, cc, ac);

  return (error);
}

/************************************************************************************************
 * Name       : load_decode_ipa                                                                 *
 * Parameters : input string, output string                                                     *
 * Purpose    : Takes a word value string and turns it into a readable DNS form (a.b.c.d)       *
 *                (ie in_string is a character array with four elements; it is not a zero       *
 *                  terminated string - indeed, b might be 0 with c non-zero)                   *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
void load_decode_ipa(char *in_string, char *out_string)
{
#if FALSE
  if (strcmp(in_string, "\0\0\0\0") != 0)
    sprintf(out_string, "%d.%d.%d.%d", in_string[0], in_string[1], in_string[2], in_string[3]);
  else
    strcpy(out_string, "\0\0\0\0");
#endif

  if (*((int *)in_string) == 0)
    out_string[0] = 0;  /* return empty string for 0.0.0.0 */
  else
    sprintf(out_string, "%d.%d.%d.%d", in_string[0], in_string[1], in_string[2], in_string[3]);

}

/************************************************************************************************
 * Name       : load_decode_login                                                               *
 * Parameters : input strig                                                                     *
 * Purpose    : Takes the response stored input string and turns them into the relevant         *
 *              login/response pairs                                                            *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
void load_decode_login(char *input)
{
  _kernel_oserror       *er;
  int   index, make_index, loop, sferror;
  char  byte;
  char  login[5][MAXLOGSTR+1], response[5][MAXLOGSTR+1];
  char  login_build[MAXLOGSTR+1], response_build[MAXLOGSTR+1], buffer[MAXLOGSTR+1];
  int   login_fields[5], response_fields[5], switch_fields[5];

  /* Copy the relevant component ID's into arrays for ease of use */
  login_fields[0] = optisp2_login_prompt1;
  login_fields[1] = optisp2_login_prompt2;
  login_fields[2] = optisp2_login_prompt3;
  login_fields[3] = optisp2_login_prompt4;
  login_fields[4] = optisp2_login_prompt5;
  switch_fields[0] = optisp2_switch1_string;
  switch_fields[1] = optisp2_switch2_string;
  switch_fields[2] = optisp2_switch3_string;
  switch_fields[3] = optisp2_switch4_string;
  switch_fields[4] = optisp2_switch5_string;
  response_fields[0] = optisp2_login_response1;
  response_fields[1] = optisp2_login_response2;
  response_fields[2] = optisp2_login_response3;
  response_fields[3] = optisp2_login_response4;
  response_fields[4] = optisp2_login_response5;

 /* clear prompt and response strings initially */
  for (loop = 0; loop < 5; loop++)
    login[loop][0] = response[loop][0] = 0;

  /* First we split the main string into substrings */
  index = 0; make_index = 0; loop = 0;

  dprintf(("", "Input: %s\n", input));

  while (index < strlen(input))
  {
    /* Login string */
    byte = input[index];
    while ((byte != '\n') && (index < strlen(input)))
    {
      login[loop][make_index] = byte;
      if (make_index < MAXLOGSTR)  /* ignore excess characters in an item */
        make_index++;
      index++;
      byte = input[index];
    }
    login[loop][make_index] = '\0';

    /* Response string */
    index++;
    make_index = 0;
    byte = input[index];
    while ((byte != '\n') && (index < strlen(input)))
    {
      response[loop][make_index] = byte;
      if (make_index < MAXLOGSTR)  /* ignore excess characters in an item */
        make_index++;
      index++;
      byte = input[index];
    }
    response[loop][make_index] = '\0';

    make_index = 0;
    index++;
    loop++;
    if (loop == 5)  /* ignore any excess items */
      break;
  }

  /* Debug - print out the substrings */
  for (index = 0; index < loop; index++)
  {
    dprintf(("", "Login:%s\nResponse:%s\n", login[index], response[index]));
  }

  /* Now go through all the substrings, expanding as needed and filling in the writable fields */
  index = 0;
  while (index < 5)
  {
    /* If we have an encoded username */
    if (strcmp(response[index], "send_user") == 0)
    {
      dprintf(("", "USERNAME!\n"));
      /* Set the value of the login/response switch */
      er = button_set_value(0, OptISP2_WindowHandle, switch_fields[index], misc_lookup_message_token("OptISP2_LoginField_1"));
      misc_error_check(er);
      /* Update the reponse field accordingly */
      ui_update_login(switch_fields[index], response_fields[index]);
      /* Finally fill in the login field */
      er = writablefield_set_value(0, OptISP2_WindowHandle, login_fields[index], login[index]);
      misc_error_check(er);

      /* Now set the appropriate Dialler$Dial$Prompt string */
      sprintf(login_build, "Dialler$Dial$Prompt%d", (index + 1));
      strcpy(buffer, login[index]);
      _kernel_setenv(login_build, buffer);

      /* Now set the appropriate Dialler$Dial$Response string */
      sprintf(response_build, "Dialler$Dial$Response%d", (index + 1));
      sferror = load_swi_call("UserId", buffer , sizeof(buffer));
      _kernel_setenv(response_build, buffer);
    }
    /* If we have an encoded password */
    else if (strcmp(response[index], "send_pass") == 0)
    {
      dprintf(("", "PASSWORD!\n"));
      /* Set the value of the login/response switch */
      er = button_set_value(0, OptISP2_WindowHandle, switch_fields[index], misc_lookup_message_token("OptISP2_LoginField_2"));
      misc_error_check(er);
      /* Update the response field accordingly */
      ui_update_login(switch_fields[index], response_fields[index]);
      /* Finally fill in the login field */
      er = writablefield_set_value(0, OptISP2_WindowHandle, login_fields[index], login[index]);
      misc_error_check(er);

      /* Now set the appropriate Dialler$Dial$Prompt string */
      sprintf(login_build, "Dialler$Dial$Prompt%d", (index + 1));
      strcpy(buffer, login[index]);
      _kernel_setenv(login_build, buffer);

      /* Now set the appropriate Dialler$Dial$Response string */
      sprintf(response_build, "Dialler$Dial$Response%d", (index + 1));
      sferror = load_swi_call("Password", buffer , sizeof(buffer));
      load_decode_password (buffer);
      _kernel_setenv(response_build, buffer);
    }
    /* Else this is a normal login/response string */
    else
    {
      /* Set the value of the login/response switch */
      er = button_set_value(0, OptISP2_WindowHandle, switch_fields[index], misc_lookup_message_token("OptISP2_LoginField_0"));
      misc_error_check(er);
      /* Update the response field accordingly */
      ui_update_login(switch_fields[index], response_fields[index]);
      /* Update the response and login fields */
      er = writablefield_set_value(0, OptISP2_WindowHandle, response_fields[index], response[index]);
      misc_error_check(er);
      er = writablefield_set_value(0, OptISP2_WindowHandle, login_fields[index], login[index]);
      misc_error_check(er);

      /* Now set the appropriate Dialler$Dial$Prompt string */
      sprintf(login_build, "Dialler$Dial$Prompt%d", (index + 1));
      strcpy(buffer, login[index]);
      _kernel_setenv(login_build, buffer);

      /* Now set the appropriate Dialler$Dial$Response string */
      sprintf(response_build, "Dialler$Dial$Response%d", (index + 1));
      strcpy(buffer, response[index]);
      _kernel_setenv(response_build, buffer);
    }
    index++;
  }

#if FALSE
  if (strlen(input) == 0)
  {
    for (loop = 0; loop < 5; loop++)
    {
      er = button_set_value(0, OptISP2_WindowHandle, switch_fields[index], misc_lookup_message_token("OptISP2_LoginField_0"));
      misc_error_check(er);
      er = writablefield_set_value(0, OptISP2_WindowHandle, response_fields[loop], "");
      misc_error_check(er);
      er = writablefield_set_value(0, OptISP2_WindowHandle, login_fields[loop], "");
      misc_error_check(er);
    }
  }
#endif

}

/************************************************************************************************
 * Name       : load_decode_password                                                            *
 * Parameters : input/output string                                                             *
 * Purpose    : The encrypted string is decoded                                                 *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/

void load_decode_password (char *p)

{
    int previndex;
    int thisindex;
    int i;
    int clen = strlen (codestr);
    int plen = strlen (p);

    previndex = clen / 3;           /* a "random" choice */

    for (i = 0; i < plen; i++)
    {
        thisindex = strchr (codestr, p[i]) - codestr;
        p[i] = codestr[(thisindex - previndex + clen) % clen];
        previndex = thisindex;
    }

    return;
}

/************************************************************************************************
 * Name       : load_user_settings                                                              *
 * Parameters : none                                                                            *
 * Purpose    : Loads the user settings from the flash via SFConfigMan and sets the writables   *
 *              and buttons accordingly                                                         *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
void load_user_settings(void)
{
  _kernel_oserror       *er;
  int                   error, flag;
  char                  buffer[255], temp_string[255];


  /* Company Name */
  error = load_swi_call("CompanyName", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_company_name, buffer);
  misc_error_check(er);

  /* Contact Name */
  error = load_swi_call("ContactName", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_user_name, buffer);
  misc_error_check(er);

  /* Fax Country Code */
  error = load_swi_call("FaxCountryCode", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_fax_country, buffer);
  misc_error_check(er);

  /* Fax Area Code */
  error = load_swi_call("FaxAreaCode", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_fax_area_code, buffer);
  misc_error_check(er);

  /* Fax Number */
  error = load_swi_call("FaxNumber", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_fax_number, buffer);
  misc_error_check(er);

  /* Voice Country Code */
  error = load_swi_call("VoiceCountryCode", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_voice_country, buffer);
  misc_error_check(er);

  /* Voice Area Code */
  error = load_swi_call("VoiceAreaCode", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_voice_area_code, buffer);
  misc_error_check(er);

  /* Voice Number */
  error = load_swi_call("VoiceNumber", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_voice_number, buffer);
  misc_error_check(er);

  /* Default routing */
  error = load_swi_call("DefaultRoute", (char *)&flag, 0);
  flag = load_test_valid("OptUser_Tx_First", "OptUser_Tx_Last", flag);
  sprintf(temp_string, "OptUser_Tx_%d", flag);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptUser_WindowHandle, optuser_txstring, buffer);
  misc_error_check(er);

  /* External Access Code */
  error = load_swi_call("OutsideLineCode", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_external_access_code, buffer);
  misc_error_check(er);

  /* International Access Code */
  error = load_swi_call("InternationalAccessCode", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_international_access_code, buffer);
  misc_error_check(er);

  /* National Access Code */
  error = load_swi_call("NationalAccessCode", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptUser_WindowHandle, optuser_national_access_code, buffer);
  misc_error_check(er);

  /* Now save these values in case any have changed */
  save_user_settings();
}

/************************************************************************************************
 * Name       : load_datetime_settings                                                          *
 * Parameters : none                                                                            *
 * Purpose    : Loads the date and time settings from the flash via SFConfigMan and sets the    *
 *              writables and buttons accordingly                                               *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
void load_datetime_settings(void)
{
  _kernel_oserror       *er;
  int                   int_value, error, time_zone, dst;
  char                  buffer[255], oscli_string[255];

  /* Timezone string */
  error = load_swi_call("TimeZone", (char *)&int_value, 0);
  misc_lookup_zone(int_value, buffer);
  er = button_set_value(0, OptDate_WindowHandle, optdate_toffset_string, buffer);
  misc_error_check(er);
  time_zone = int_value;

#if FALSE
  /* Finally set the time and date */
  if (time_window_opened == 1)
        optdate_set_clock('S', 0, 0, 0, 0, 0, 0);
#endif

  dprintf(("", "Load timezone is : %d\n", time_zone));
  sprintf(buffer, "%d\0", time_zone);
  strcpy(oscli_string, "co. timezone");
  strcat(oscli_string, buffer);
  _kernel_oscli(oscli_string);

 /* DST flag - load from flash and set button in date/time window */
  error = load_swi_call("DaylightSavings", (char *)&int_value, 0);
  int_value = load_test_valid("Opt_OnOff_First", "Opt_OnOff_Last", int_value);
  dst = int_value;
  sprintf(buffer, "Opt_OnOff_%d", int_value);
  strcpy(buffer, misc_lookup_message_token(buffer));
  er = button_set_value(0, OptDate_WindowHandle, optdate_dsave_string, buffer);
  misc_error_check(er);

 /* update CMOS configuration to match */
  if (dst == 1)
    _kernel_oscli("co. dst");
  else
    _kernel_oscli("co. nodst");

 /* and, finally, set date/time writeables from the system clock */
  optdate_set_datetime();

 /* Everyone should now have the same view of the world:
       - Timezone and DST values in serial flash
       - RISCOS CMOS RAM configuration (dst and timezone)
       - Writeables and buttons in the date/time setup window */
}

/************************************************************************************************
 * Name       : load_isp1_settings                                                              *
 * Parameters : none                                                                            *
 * Purpose    : Loads the isp settings from the flash via SFConfigMan and sets the              *
 *              writables and buttons accordingly                                               *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
void load_isp1_settings(void)
{
  _kernel_oserror       *er;
  char                  buffer[255], build_string[255], temp_string[255];
  char                  dns1[255], dns2[255], dns3[255];
  int                   int_value, flag, error;
#if FALSE
  FILE                  *f_point;
  int                   nbytes;
  char                  copy_name[255], new_name[255];
  _kernel_swi_regs      regs;
#endif

  /* Dialup number string - decoding from internal to display format */
  error = load_swi_call("PrimaryPhone", build_string, sizeof(build_string));
  dprintf(("", "Chars : %d, %d, %d\n", build_string[0], build_string[1], build_string[2]));
  if (strlen(build_string) != 0)
  {
    error = load_decode_number(build_string, buffer, sizeof(buffer));
  }
  else
  {
    strcpy(buffer, build_string);
  }
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_dialup_string, buffer);
  misc_error_check(er);

  /* Dialup retry string */
  error = load_swi_call("HardSetup", (char *)&flag, 0);
  error = load_swi_call("PrimaryRedial", (char *)&int_value, 0);
  /* We first test whether the flash is blank. If it is, then we want to give the redial value a
     default */
  if (flag == 0)
  {
    /* Default value of 2 dialups */
    int_value = 2;
  }
  else
  {
    /* Else we just check to see if the value is within valid bounds */
    int_value = load_test_valid("OptISP1_Redial_First", "OptISP1_Redial_Last", int_value);
  }
  sprintf(buffer, "%d", int_value);
  er = button_set_value(0, OptISP1_WindowHandle, optisp1_dialupretry_string, buffer);
  misc_error_check(er);

  /* Alternate number string */
  build_string[0] = '\0';
  build_string[1] = '\0';
  build_string[2] = '\0';
  error = load_swi_call("SecondaryPhone", build_string, sizeof(build_string));
  dprintf(("", "Chars : %d, %d, %d\n", build_string[0], build_string[1], build_string[2]));
  if (strlen(build_string) != 0)
  {
    error = load_decode_number(build_string, buffer, sizeof(buffer));
  }
  else
  {
    strcpy(buffer, build_string);
  }
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_alternate_string, buffer);
  misc_error_check(er);

  /* Alternate retry string */
  error = load_swi_call("SecondaryRedial", (char *)&int_value, 0);
  int_value = load_test_valid("OptISP1_Redial_First", "OptISP1_Redial_Last", int_value);
  sprintf(buffer, "%d", int_value);
  er = button_set_value(0, OptISP1_WindowHandle, optisp1_alternateretry_string, buffer);
  misc_error_check(er);

  /* SMTP server string */
  error = load_swi_call("SMTPHost", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_smtpserver_string, buffer);
  misc_error_check(er);

  /* POP3 server string */
  error = load_swi_call("POP3Host", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_pop3server_string, buffer);
  misc_error_check(er);

  /* POP3 email string */
  error = load_swi_call("POP3mailbox", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_pop3email_string, buffer);
  misc_error_check(er);

  /* POP3 username string */
  error = load_swi_call("POP3UserId", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_pop3username_string, buffer);
  misc_error_check(er);


  /* POP3 password string */
  error = load_swi_call("POP3Password", buffer, sizeof(buffer));
  load_decode_password (buffer);
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_pop3password_string, buffer);
  misc_error_check(er);

  /* ISP username */
  error = load_swi_call("UserId", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_ispusername_string, buffer);
  misc_error_check(er);
  #if FINAL
    sprintf(temp_string, "name %s", buffer);
    _kernel_setenv("Inet$PPPOptions", temp_string);
  #endif



  /* ISP password */
  error = load_swi_call("Password", buffer, sizeof(buffer));
  load_decode_password (buffer);
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_isppassword_string, buffer);
  misc_error_check(er);


  /* DNS server string */
  build_string[0] = '\0';
  error = load_swi_call("DNSServer1", buffer, 0);
  load_decode_ipa(buffer, dns1);

  error = load_swi_call("DNSServer2", buffer, 0);
  load_decode_ipa(buffer, dns2);

  error = load_swi_call("DNSServer3", buffer, 0);
  load_decode_ipa(buffer, dns3);

  strcpy(build_string, dns1);

  if (dns2[0] != '\0')
  {
    strcat(build_string, " ");
    strcat(build_string, dns2);

    if (dns3[0] != '\0')
    {
      strcat(build_string, " ");
      strcat(build_string, dns3);
    }
  }
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_dnsserver_string, build_string);
  misc_error_check(er);
  #if FINAL
    _kernel_setenv("Inet$Resolvers", build_string);
    _kernel_oscli("ResolverConfig");
  #endif

  /* Local domain string */
  error = load_swi_call("LocalHost", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptISP1_WindowHandle, optisp1_inetlocaldomain_string, buffer);
  misc_error_check(er);
  #if FINAL
    _kernel_setenv("Inet$LocalDomain", buffer);
    _kernel_oscli("ResolverConfig");
  #endif


#if FALSE     /* save_isp1_settings() [see below for this call] contains identical code! */

  /* Finally we create a directory 'PPP' in the IneDBase$Path and create a file inside
     called 'CHAPSecret' to store username and password for the PP settings */
  /* Okay, but we also need to be able to stay alive in the event of there being no ram */
  f_point = fopen("RAM:$.Test", "w");

  if (f_point != NULL)
  {
    /* Delete our test file */
    nbytes = fclose(f_point);
    /*_kernel_oscli("Delete RAM:$.Test");*/
    er = save_delete_file("RAM:$.Test");
    misc_error_check(er);

    /* Create our new file */
    er = save_create_dir("RAM:$.Internet");
    misc_error_check(er);
    er = save_create_dir("RAM:$.Internet.Files");
    misc_error_check(er);
    er = save_create_dir("RAM:$.Internet.Files.PPP");
    misc_error_check(er);

    f_point = fopen("RAM:$.Internet.files.PPP.CHAPSecret", "w");
    er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_ispusername_string, buffer, sizeof(buffer),
                                   &nbytes);
    nbytes = fprintf(f_point, "%s", buffer);
    er = writablefield_get_value(0, OptISP1_WindowHandle, optisp1_isppassword_string, buffer, sizeof(buffer),
                                   &nbytes);
    nbytes = fprintf(f_point, " * %s\0", buffer);
    nbytes = fclose(f_point);

    /* Now copy this file as PAPSecret for PAP access */
    strcpy(copy_name, "RAM:$.Internet.files.PPP.CHAPSecret");
    strcpy(new_name, "RAM:$.Internet.files.PPP.PAPSecrets");
    regs.r[0] = 26;
    regs.r[1] = (int)copy_name;
    regs.r[2] = (int)new_name;
    regs.r[3] = 2;
    _kernel_swi(OS_FSControl, &regs, &regs);
  }
  else
    dprintf(("", "No RAM in which to save settings\n"));

#endif


  /* Now save these settings in case anything has changed */
  save_isp1_settings();
}

/************************************************************************************************
 * Name       : load_isp2_settings                                                              *
 * Parameters : none                                                                            *
 * Purpose    : Loads the isp settings from the flash via SFConfigMan and sets the              *
 *              writables and buttons accordingly                                               *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
void load_isp2_settings(void)
{
  _kernel_oserror       *er;
  char                  buffer[255], temp_string[255];
  int                   int_value, error, flag;

  /* Missing pages string */
  error = load_swi_call("MissingPageConnectionCount", (char *)&int_value, 0);
  int_value = load_test_valid("OptISP2_Missing_First", "OptISP2_Missing_Last", int_value);
  sprintf(buffer, "%d", int_value);
  er = button_set_value(0, OptISP2_WindowHandle, optisp2_missingpages_string, buffer);
  misc_error_check(er);

#if FALSE
  /* Connection time string */
  error = load_swi_call("ConnectionHoldUpTime", (char *)&int_value, 0);
  int_value = load_test_valid("OptISP2_Connection_First", "OptISP2_Connection_Last", int_value);
  sprintf(buffer, "%d", int_value);
  er = button_set_value(0, OptISP2_WindowHandle, optisp2_connectiontime_string, buffer);
  misc_error_check(er);
#endif

  /* Pages per email string */
  error = load_swi_call("PagesPerEmail", (char *)&int_value, 0);
  int_value = load_test_valid("OptISP2_Pages_First", "OptISP2_Pages_Last", int_value);
  sprintf(buffer, "%d", int_value);
  er = button_set_value(0, OptISP2_WindowHandle, optisp2_pagesperemail_string, buffer);
  misc_error_check(er);

  /* Max mailsize string */
  error = load_swi_call("MaxEmailSize", (char *)&int_value, 0);
/*  int_value /= 1024;  */
  int_value = load_testalign_valid("OptISP2_MaxEmail_First", "OptISP2_MaxEmail_Last", "OptISP2_MaxEmail_Incr", int_value);
  sprintf(buffer, "%d", int_value);
  er = button_set_value(0, OptISP2_WindowHandle, optisp2_maxemailsize_string, buffer);
  misc_error_check(er);

  /* Request Receipt string */
  error = load_swi_call("RequestReceipt", (char *)&flag, 0);
  flag = load_test_valid("Opt_YesNo_First", "Opt_YesNo_Last", flag);
  sprintf(temp_string, "Opt_YesNo_%d", flag);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptISP2_WindowHandle, optisp2_emailreceipt_string, buffer);
  misc_error_check(er);

  /* Logon script prompts and responses */
  error = load_swi_call("ResponseString", buffer, sizeof(buffer));
  load_decode_login(buffer);

  /* Now save these settings in case anything has changed */
  save_isp2_settings();
}

/************************************************************************************************
 * Name       : load_misc_settings                                                              *
 * Parameters : none                                                                            *
 * Purpose    : Loads the misc settings from the flash via SFConfigMan and sets the             *
 *              writables and buttons accordingly                                               *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
void load_misc_settings(void)
{
  _kernel_oserror       *er;
  char                  buffer[255], temp_string[255];
  int                   int_size, error, flag;

  /* Not A Number string */
  error = load_swi_call("NANtoken", buffer, sizeof(buffer));
  error = load_swi_call("HardSetup", (char *)&flag, 0);
  dprintf(("", "Flag value : %d\n", flag));
  if (flag == 0)
  {
    sprintf(buffer, "100");
  }
  er = writablefield_set_value(0, OptMisc_WindowHandle, optmisc_notanumber_string, buffer);
  misc_error_check(er);

  /* Capture timeout string */
  error = load_swi_call("CaptureTimeOut", (char *)&int_size, 0);
  int_size = load_test_valid("OptMisc_Capture_First", "OptMisc_Capture_Last", int_size);
  sprintf(buffer, "%d", int_size);
  er = button_set_value(0, OptMisc_WindowHandle, optmisc_capturetime_string, buffer);
  misc_error_check(er);

  /* Enotes printing string */
  error = load_swi_call("PrintEnotes", (char *)&flag, 0);
  flag = load_test_valid("Opt_YesNo_First", "Opt_YesNo_Last", flag);
  sprintf(temp_string, "Opt_YesNo_%d", flag);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptMisc_WindowHandle, optmisc_enotes_string, buffer);
  misc_error_check(er);

  /* Fax Redial count string */
  error = load_swi_call("HardSetup", (char *)&flag, 0);
  error = load_swi_call("RedialCount", (char *)&int_size, 0);
  if (flag == 0)
  {
    int_size = 2;
  }
  else
  {
    int_size = load_test_valid("OptMisc_FaxRedial_First", "OptMisc_FaxRedial_Last", int_size);
  }
  sprintf(buffer, "%d", int_size);
  er = button_set_value(0, OptMisc_WindowHandle, optmisc_faxredial_string, buffer);
  misc_error_check(er);

  /* Pulse/Tone string */
  error = load_swi_call("ToneDial", (char *)&flag, 0);
  flag = load_test_valid("OptMisc_PulseTone_First", "OptMisc_PulseTone_Last", flag);
  sprintf(temp_string, "OptMisc_PulseTone_%d", flag);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptMisc_WindowHandle, optmisc_pulsetone_string, buffer);
  misc_error_check(er);

  /* Faxmethod string */
  error = load_swi_call("FaxType", (char *)&flag, 0);
  flag = load_test_valid("OptMisc_FaxMethod_First", "OptMisc_FaxMethod_Last", flag);
  sprintf(temp_string, "OptMisc_FaxMethod_%d", flag);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptMisc_WindowHandle, optmisc_faxmethod_string, buffer);
  misc_error_check(er);

  /* The next two options we have to convert to either nothing, ',' or 'W' */
  /* Post Prefix Pause */
  error = load_swi_call("PostPrefixPause", (char *)&flag, 1);
  flag = load_pause_convert(flag);
  flag = load_test_valid("OptMisc_Pause_First", "OptMisc_Pause_Last", flag);
  sprintf(temp_string, "OptMisc_Pause_%d", flag);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptMisc_WindowHandle, optmisc_prefixpause_string, buffer);
  misc_error_check(er);

  /* Post International Pause */
  error = load_swi_call("PostInternationalPause", (char *)&flag, 1);
  flag = load_pause_convert(flag);
  flag = load_test_valid("OptMisc_Pause_First", "OptMisc_Pause_Last", flag);
  sprintf(temp_string, "OptMisc_Pause_%d", flag);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptMisc_WindowHandle, optmisc_interpause_string, buffer);
  misc_error_check(er);

  /* Now save these settings in case anything has changed */
  save_misc_settings();
}

/************************************************************************************************
 * Name       : load_log_settings                                                               *
 * Parameters : none                                                                            *
 * Purpose    : Loads the log settings from the flash via SFConfigMan and sets the              *
 *              writables and buttons accordingly                                               *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
void load_log_settings(void)
{
  _kernel_oserror       *er;
  char                  buffer[255], temp_string[255];
  int                   int_size, error, flag, time_int, hours, mins;

  /* Logsize string */
  error = load_swi_call("MaximumFileSize", (char *)&int_size, 0);
  int_size = load_testalign_valid("OptLog_LogSize_First", "OptLog_LogSize_Last", "OptLog_LogSize_Incr", int_size);
  sprintf(buffer, "%d", int_size);
  er = button_set_value(0, OptLog_WindowHandle, optlog_logsize_string, buffer);
  misc_error_check(er);

  /* Purge log after string */
  error = load_swi_call("PurgePeriod", (char *)&int_size, 0);
  int_size = load_test_valid("OptLog_PurgePeriod_First", "OptLog_PurgePeriod_Last", int_size);
  sprintf(temp_string, "OptLog_PurgePeriod_%d", int_size);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptLog_WindowHandle, optlog_purgeperiod_string, buffer);
  misc_error_check(er);

  /* Time functions, using our 'special' integer */
  error = load_swi_call("PurgeTime", buffer, sizeof(buffer));
  time_int = atoi(buffer);
  dprintf(("", "String : %s, Int : %d\n", buffer, time_int));
  hours = (time_int/100);
  hours = load_test_valid("OptDate_Hour_First", "OptDate_Hour_Last", hours);

  /* Hour string */
  sprintf(buffer, "%02d", (time_int/100)); /* Gets the hours */
  er = button_set_value(0, OptLog_WindowHandle, optlog_hour_string, buffer);
  misc_error_check(er);

  /* Minutes string */
  mins = (time_int - ((time_int/100)*100));
  mins = load_test_valid("OptDate_Min_First", "OptDate_Min_Last", mins);
  sprintf(buffer, "%02d", mins); /* Gets the minutes */
  er = button_set_value(0, OptLog_WindowHandle, optlog_minute_string, buffer);
  misc_error_check(er);

  /* Day string */
  error = load_swi_call("PurgeDay", (char *)&int_size, 0);
  int_size--;
  int_size = load_test_valid("Optmisc_Day_First", "OptMisc_Day_Last", int_size);
  sprintf(temp_string, "OptMisc_Day_%d", int_size);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptLog_WindowHandle, optlog_day_string, buffer);
  misc_error_check(er);

  /* Print string */
  error = load_swi_call("PrintBeforePurge", (char *)&flag, 0);
  flag = load_test_valid("Opt_YesNo_First", "Opt_YesNo_Last", flag);
  sprintf(temp_string, "Opt_YesNo_%d", flag);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptLog_WindowHandle, optlog_print_string, buffer);

  /* Email string */
  error = load_swi_call("EmailBeforePurge", (char *)&flag, 0);
  flag = load_test_valid("Opt_YesNo_First", "Opt_YesNo_Last", flag);
  sprintf(temp_string, "Opt_YesNo_%d", flag);
  strcpy(buffer, misc_lookup_message_token(temp_string));
  er = button_set_value(0, OptLog_WindowHandle, optlog_email_string, buffer);
  misc_error_check(er);

  /* Admin string */
  error = load_swi_call("Destination", buffer, sizeof(buffer));
  er = writablefield_set_value(0, OptLog_WindowHandle, optlog_admin_string, buffer);
  misc_error_check(er);

  /* Check for the internal test again... */
  if (strcmp(buffer, internal_string) == 0)
  {
    cancel_internaltest(0, "");

    /* Now we reset the admin string field to be blank, to avoid problems */
    strcpy(buffer, "");
    er = writablefield_set_value(0, OptLog_WindowHandle, optlog_admin_string, buffer);
    misc_error_check(er);
  }

  /* Now save these settings in case anything has changed */
  save_log_settings();
}

/************************************************************************************************
 * Name       : load_sched_settings                                                             *
 * Parameters : none                                                                            *
 * Purpose    : Loads the scheduler settings from the flash via SFConfigMan and sets the        *
 *              writables and buttons accordingly                                               *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
void load_sched_settings(void)
{
  _kernel_oserror       *error;
  int   er, int_size, int_size2, loop, test = 0;
  char  buffer[255], temp_buffer[255];

  /* Initialise number of days scheduled */
  sched_days = 0;

  /* Grab the settings for the scheduler */

  /* Scheduler On/Off */
  er = load_swi_call("Scheduler", (char *)&int_size, 0);
  int_size = load_test_valid("Opt_OnOff_First", "Opt_OnOff_Last", int_size);
  sched_on = int_size;
  ui_sched_fade_fields(sched_on);
  sprintf(temp_buffer, "Opt_OnOff_%d", int_size);
  strcpy(buffer, misc_lookup_message_token(temp_buffer));
  error = button_set_value(0, OptSchedule_WindowHandle, optschedule_scheduler_string, buffer);

  /* Standard Week On/Off */
  er = load_swi_call("SchedulerWeek", (char *)&int_size, 0);
  int_size = load_test_valid("Opt_OnOff_First", "Opt_OnOff_Last", int_size);
  sprintf(temp_buffer, "Opt_OnOff_%d", int_size);
  strcpy(buffer, misc_lookup_message_token(temp_buffer));
  error = button_set_value(0, OptSchedule_WindowHandle, optschedule_stanweek_string, buffer);

  /* Peak dialups and offpeak dialups */
  er = load_swi_call("OffPeakDialUps", (char *)&int_size2, 0);
  int_size2 = load_test_valid("OptSchedule_DialUp_First", "OptSchedule_DialUp_Last", int_size2);

  er = load_swi_call("PeakDialUps", (char *)&int_size, 0);
  int_size = load_test_valid("OptSchedule_DialUp_First", "OptSchedule_DialUp_Last", int_size);

  /* Set the number of dialups for each day (all of these are the same) */
  for (loop = 0; loop < 7; loop++)
  {
    sched_num_peak[loop] = int_size;
    sched_num_off[loop]  = int_size2;
  }

  /* Set the values in the button fields */
  sprintf(temp_buffer, "%d", int_size);
  error = button_set_value(0, OptSchedule_WindowHandle, optschedule_peakdialup_string, temp_buffer);
  sprintf(temp_buffer, "%d", int_size2);
  error = button_set_value(0, OptSchedule_WindowHandle, optschedule_offdialup_string, temp_buffer);

  no_sched_time = FALSE;

  /* Sunday */
  er = load_swi_call("Sunday", buffer, 16);
  test += load_process_sched(0, buffer);

  /* Monday */
  er = load_swi_call("Monday", buffer, 16);
  dprintf(("", "Monday : %s\n", buffer));
  test += load_process_sched(1, buffer);

  /* Tuesday */
  er = load_swi_call("Tuesday", buffer, 16);
  test += load_process_sched(2, buffer);

  /* Wednesday */
  er = load_swi_call("Wednesday", buffer, 16);
  test += load_process_sched(3, buffer);

  /* Thursday */
  er = load_swi_call("Thursday", buffer, 16);
  test += load_process_sched(4, buffer);

  /* Friday */
  er = load_swi_call("Friday", buffer, 16);
  test += load_process_sched(5, buffer);

  /* Saturday */
  er = load_swi_call("Saturday", buffer, 16);
  test += load_process_sched(6, buffer);

  /* Finally update the icons in the scheduler window */
  ui_sched_update_fields();

  /* If there aren't any set times in the scheduler, then we don't want to try and get the next
     scheduled dial-up time, else all hell will break loose */
  if (test == 7)
  {
    no_sched_time = FALSE;
    loaded_scheds = FALSE;
  }
  else if (loaded_scheds == FALSE)
  {
    no_sched_time = TRUE;
    loaded_scheds = TRUE;
  }
}

/************************************************************************************************
 * Name       : load_process_sched                                                              *
 * Parameters : day integer, input buffer                                                       *
 * Purpose    : Takes the day and the input buffer and copies them into the relevant days       *
 *              schedule fields                                                                 *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
int load_process_sched(int day, char *buffer)
{
  char  temp_string[10];
  int   hour, min, no_peak, no_offpeak;

  temp_string[2] = 0;  /* string terminator */

  /* Peak time start */
  strncpy(temp_string, buffer, 2);
  hour = atoi(temp_string);
  strncpy(temp_string, &buffer[2], 2);
  min = atoi(temp_string);
  sched_start_peak[day] = HHMM(hour, min);
  //dprintf(("", "Peak start hour : %d\n", hour));

  /* Peak time end */
  strncpy(temp_string, &buffer[4], 2);
  hour = atoi(temp_string);
  strncpy(temp_string, &buffer[6], 2);
  min = atoi(temp_string);
  sched_end_peak[day] = HHMM(hour, min);
  //dprintf(("", "Peak time end : %d\n", hour));

  /* Idle time start */
  strncpy(temp_string, &buffer[8], 2);
  hour = atoi(temp_string);
  strncpy(temp_string, &buffer[10], 2);
  min = atoi(temp_string);
  sched_start_idle[day] = HHMM(hour, min);
  //dprintf(("", "Idle time start : %d\n", hour));

  /* Idle end time */
  strncpy(temp_string, &buffer[12], 2);
  hour = atoi(temp_string);
  strncpy(temp_string, &buffer[14], 2);
  min = atoi(temp_string);
  sched_end_idle[day] = HHMM(hour, min);
  //dprintf(("", "Idle time end : %d\n", hour));

  /* We don't want the thing to die on us, now do we */
  /*if ((sched_start_peak[day] == sched_end_peak[day]) &&
      (sched_start_idle[day] == sched_end_idle[day]) &&
      (sched_start_peak[day] == sched_start_idle[day]))
    return TRUE;
  else
    return FALSE;*/

  no_peak = FALSE;
  no_offpeak = FALSE;

  /* This should stop all manner of horrible hanging problems */
  if (sched_start_peak[day] == sched_end_peak[day])
  {
    sched_start_peak[day] = -1;
    sched_end_peak[day] = -1;
    no_peak = TRUE;
  }

  if (sched_start_idle[day] == sched_end_idle[day])
  {
    sched_start_idle[day] = -1;
    sched_end_idle[day] = -1;
    no_offpeak = TRUE;
  }

  /* Now we test to see if there are any dialups at all, and if there are
     then we increase the number of days scheduled this week by one */
  if ((no_peak == FALSE) || (no_offpeak == FALSE))
  {
    sched_days++;
  }

  return (FALSE);
}

/************************************************************************************************
 * Name       : load_all_settings                                                               *
 * Parameters : None                                                                            *
 * Purpose    : Calls each of the load functions independantly for an overall load              *
 * Returns    : Nothing                                                                         *
 ************************************************************************************************/
void load_all_settings(void)
{
  /* This is the load cycle */
  load_cycle = TRUE;

  /* Load all the settings */
  load_user_settings();
  load_datetime_settings();
  load_isp1_settings();
  load_isp2_settings();
  load_misc_settings();
  load_log_settings();
  load_sched_settings();

  save_hard_setup();

  /* The options have changed so send a message to the relevant processes */
  messhandle_option_changed(ALL_UPDATE);
}

