/************************************************************************/
/* File:    UI.c                                                        */
/* Purpose: file deals with UI bits and pieces specifically the special */
/*          option system employed in Daytona.                          */
/*                                                                      */
/* Author:  Neil Bingham (mailto:NBingham@acorn.co.uk)                  */
/* History: Tue 18th February 1997  ver 0.01 - Created.                 */
/*          Thu 12th November 1997  ver 0.06 - Big jump in numbers as   */
/*                                             a *lot* of support added */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include <time.h>

#include "main.h"
#include "ui.h"
#include "functions.h"
#include "kernel.h"
#include "misc.h"
#include "load.h"
#include "scheduler.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */
void optdate_optionfields(int, ComponentId);
void optmisc_optionfields(int, ComponentId);
void optisp_optionfields(int, ComponentId);
void optsched_optionfields(int, ComponentId);
extern void optdate_set_datetime(void);
extern void optdate_set_clock(char, int, int, int, int, int, int);
extern void optdate_get_time_now(struct tm **);
extern int  misc_tag_lookup(ObjectId, ComponentId, char *);
/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************
 *  Name       : ui_alter_flag                                          *
 *  Parameters : window handle and flag value                           *
 *  Purpose    : Fades or unfades a toolbox gadget                      *
 *  Returns    : Nothings                                               *
 ************************************************************************/
void ui_alter_flag(ObjectId object, ComponentId component, unsigned int flaggy)
{
  _kernel_oserror	*er;
  unsigned int 		flag;

    er = gadget_get_flags(0, object, component, &flag);
    if (flaggy == 1)
      flag = flag | Gadget_Faded;
    else
      flag = flag & ~Gadget_Faded;
    er = gadget_set_flags(0, object, component, flag);
}

/************************************************************************
 *  Name       : ui_update_login                                        *
 *  Parameters : window handle and component handle                     *
 *  Purpose    : Alters the login script states                         *
 ************************************************************************/
void ui_update_login(ComponentId option, ComponentId component)
{
  _kernel_oserror    *er;

  if (misc_tag_lookup(OptISP2_WindowHandle, option, "OptISP2_LoginField") == 1)
  {
    /* Username mode! */
    ui_alter_flag(OptISP2_WindowHandle, component, 1);
    er = writablefield_set_value(0, OptISP2_WindowHandle, component, misc_lookup_message_token("OptISP_LoginUser"));
  }
  else if (misc_tag_lookup(OptISP2_WindowHandle, component, "OptISP2_LoginField") == 2)
  {
    /* Password mode! */
    ui_alter_flag(OptISP2_WindowHandle, component, 1);
    er = writablefield_set_value(0, OptISP2_WindowHandle, component, misc_lookup_message_token("OptISP_LoginPass"));
  }
  else
  {
    /* Normal mode! */
    ui_alter_flag(OptISP2_WindowHandle, component, 0);
    er = writablefield_set_value(0, OptISP2_WindowHandle, component, "");
  }
}

/************************************************************************/
/* leftcursor_pressed                                                   */
/*                                                                      */
/* Function is called when the left of right arror keys are pressed.    */
/* Action will only be taken if that window has an option field.        */
/*                                                                      */
/* Parameters: ToolboxEventHandler parameters.                          */
/*                                                                      */
/* Returns:    TRUE or FALSE.                                           */
/*                                                                      */
/************************************************************************/
void leftcursor_pressed(void)
{
  _kernel_oserror		*er;
  WimpGetPointerInfoBlock	 pointer_info;
  ComponentId			 comp;
  ObjectId			 obj_name;

  /* In a window with an option field.  Now check to see if Iconhigh is highlighting the
   * clickable button surrounding the field
   */
  er = wimp_get_pointer_info(&pointer_info);
  error_check(er);

  window_wimp_to_toolbox(0, pointer_info.window_handle, pointer_info.icon_handle,
                         &obj_name, &comp);
  error_check(er);

  if ((obj_name == OptUser_WindowHandle) && (comp == optuser_txborder))
  {
    /* We are on an option, so do the processing */
    ui_optionfield_update(DOWN, "OptUser_Tx_", OptUser_WindowHandle, optuser_txstring, Optionfield_Wrap|Optionfield_NonNumerical);
  }
  else if (obj_name == OptDate_WindowHandle)
  {
    optdate_optionfields(DOWN, comp);
  }
  else if (obj_name == OptMisc_WindowHandle)
  {
    optmisc_optionfields(DOWN, comp);
  }
  else if (obj_name == OptLog_WindowHandle)
  {
    optlog_optionfields(DOWN, comp);
  }
  else if (obj_name == OptISP1_WindowHandle)
  {
    optisp1_optionfields(DOWN, comp);
  }
  else if (obj_name == OptISP2_WindowHandle)
  {
    optisp2_optionfields(DOWN, comp);
  }
  else if (obj_name == OptSchedule_WindowHandle)
  {
    optsched_optionfields(DOWN, comp);
  }
}

/************************************************************************/
/* rightcursor_pressed                                                  */
/*                                                                      */
/* Function is called when the left of right arror keys are pressed.    */
/* Action will only be taken if that window has an option field.        */
/*                                                                      */
/* Parameters: ToolboxEventHandler parameters.                          */
/*                                                                      */
/* Returns:    TRUE or FALSE.                                           */
/*                                                                      */
/************************************************************************/
void rightcursor_pressed(void)
{
  _kernel_oserror		*er;
  WimpGetPointerInfoBlock	 pointer_info;
  ComponentId			 comp;
  ObjectId			 obj_name;

  /* In a window with an option field.  Now check to see if Iconhigh is highlighting the
   * clickable button surrounding the field
   */
  er = wimp_get_pointer_info(&pointer_info);
  error_check(er);

  window_wimp_to_toolbox(0, pointer_info.window_handle, pointer_info.icon_handle,
                         &obj_name, &comp);
  error_check(er);

  if ((ui_currently_open_win == OptUser_WindowHandle) && (comp == optuser_txborder))
  {
    /* OptUser window */
    ui_optionfield_update(UP, "OptUser_Tx_", OptUser_WindowHandle, optuser_txstring, Optionfield_Wrap|Optionfield_NonNumerical);
  }
  else if (obj_name == OptDate_WindowHandle)
  {
    /* OptDate window */
    optdate_optionfields(UP, comp);
  }
  else if (obj_name == OptMisc_WindowHandle)
  {
    optmisc_optionfields(UP, comp);
  }
  else if (obj_name == OptLog_WindowHandle)
  {
    optlog_optionfields(UP, comp);
  }
  else if (obj_name == OptISP1_WindowHandle)
  {
    optisp1_optionfields(UP, comp);
  }
  else if (obj_name == OptISP2_WindowHandle)
  {
    optisp2_optionfields(UP, comp);
  }
  else if (obj_name == OptSchedule_WindowHandle)
  {
    optsched_optionfields(UP, comp);
  }
}

/************************************************************************/
/* optdate_optionfields                                                 */
/*                                                                      */
/* Function deals with the optionfields on the OptDate window.          */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optdate_optionfields(int updown, ComponentId comp)
{
  _kernel_oserror	*er;
  _kernel_swi_regs	regs;
  char			buffer[50], oscli[30];
  struct tm		*local_time;
  int			secs, mins, hours, days, months, years, id, offset, offset2;
  int			secs2, mins2, hours2, days2, months2, years2;
  int			original_offset, error;

  if (comp == optdate_month_border)
  {
    /* Month optionfield */
    ui_optionfield_update(updown, "OptDate_Month_", OptDate_WindowHandle, optdate_month_string, Optionfield_Wrap|Optionfield_NonNumerical);
  }
  else if (comp == optdate_hour_border)
  {
    /* Hour optionfield */
    ui_optionfield_update(updown, "OptDate_Hour_", OptDate_WindowHandle, optdate_hour_string, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
  }
  else if (comp == optdate_minute_border)
  {
    /* Hour optionfield */
    ui_optionfield_update(updown, "OptDate_Min_", OptDate_WindowHandle, optdate_minute_string, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
  }
  else if (comp == optdate_dsave_border)
  {
    //local_time = malloc(sizeof(struct tm));
    ui_optionfield_update(updown, "OptDate_DSave_", OptDate_WindowHandle, optdate_dsave_string, Optionfield_Wrap|Optionfield_NonNumerical);
    er = button_get_value(0, OptDate_WindowHandle, optdate_dsave_string, buffer,
    				sizeof(buffer), 0);
    /* Daylight Saving optionfield */

    /* Get the time *now* */
    optdate_get_time_now(&local_time);
    secs = local_time->tm_sec; mins = local_time->tm_min; hours = local_time->tm_hour;
    days = local_time->tm_mday; months = local_time->tm_mon; years = local_time->tm_year;

    /* Update the clock from the writable field */
    optdate_set_clock('S', 0, 0, 0, 0, 0, 0);

    /* Alter the saving, reset the writables */
    if (misc_tag_lookup(OptDate_WindowHandle, optdate_dsave_string, "OptDate_DSave") == 1)
    {
      _kernel_oscli("co. nodst");
    }
    else
    {
      _kernel_oscli("co. dst");
    }

    optdate_set_clock('S', 0, 0, 0, 0, 0, 0);

    /* Reset to original values to preserve */
    if (misc_tag_lookup(OptDate_WindowHandle, optdate_dsave_string, "OptDate_DSave") == 1)
    {
      _kernel_oscli("co. dst");
    }
    else
    {
      _kernel_oscli("co. nodst");
    }

    /* And reset the clock to the real time *now* */
    optdate_set_datetime();
    optdate_set_clock('N', secs, mins, hours, days, months, years);
  }
  else if (comp == optdate_toffset_border)
  {
    /* Update the field so that the correct zone can be set */
    ui_optionfield_update(updown,"OptDate_TOffset_",OptDate_WindowHandle,optdate_toffset_string, Optionfield_Wrap|Optionfield_NonNumerical);
    /* Get timezone string from button */
    er = button_get_value(0, OptDate_WindowHandle, optdate_dsave_string, buffer,
    				sizeof(buffer), 0);
    /* Get ID from this string */
    id = misc_tag_lookup(OptDate_WindowHandle, optdate_toffset_string, "OptDate_TOffset");

    /* Load our current timezone */
    error = load_swi_call("TimeZone", (char *)&offset2, 0);

    /* Load the selected timezone*/
    offset = misc_lookup_timezone();

    /* Get the current timezone offset stored in CMOS */
    regs.r[0] = 161;
    regs.r[1] = 139;
    _kernel_swi(OS_Byte, &regs, &regs);

    /* Convert the signed 2 bit complement to a real number */
    original_offset = regs.r[2];
    regs.r[0] = original_offset;
    regs.r[1] = (int)buffer;
    regs.r[2] = sizeof(buffer);
    _kernel_swi(OS_ConvertInteger1, &regs, &regs);

    /* As the timezone is stored in 15 min intervals, we divide by 4 to get it in hours */
    original_offset = atoi(buffer)/4;

    /* Get the present time from the system clock */
    optdate_get_time_now(&local_time);
    secs = local_time->tm_sec; mins = local_time->tm_min; hours = local_time->tm_hour;
    days = local_time->tm_mday; months = local_time->tm_mon; years = local_time->tm_year;
    optdate_set_clock('N', secs, mins, hours, days, months, years);

    /* Set the date and time from the writables in the Date/Time window */
    optdate_set_datetime();
    optdate_set_clock('S', 0, 0, 0, 0, 0, 0);

    /*************************************************************************************************************
     We have to work out the correct offset to add/subtract to the current timezone. As all timezone
     information stored in the messages file is relative to GMT, we use the current timezone's GMT offset,
     the selected timezones GMT offset. We then subtract the selected timezone offset from the current timezone
     offset to get the difference in hours between the two timezones. This we then subtract from the original
     timezone offset to find the value (relative to GMT) to add/subtract to the current timezone. In short:

     difference between timezones = current_timezone - selected_timezone;

     offset to add to current timezone = current timezone - difference between timezones
     ************************************************************************************************************/
    offset = (original_offset - (offset2 - offset));

    /* Now set the timezone according to our calculation */
    sprintf(oscli, "co. timezone %d\0", offset);
    _kernel_oscli(oscli);

    /* Get the time now the timezone has been set */
    optdate_get_time_now(&local_time);
    secs2 = local_time->tm_sec; mins2 = local_time->tm_min; hours2 = local_time->tm_hour;
    days2 = local_time->tm_mday; months2 = local_time->tm_mon; years2 = local_time->tm_year;

    /* Set the system clock with the new timezone'd time */
    optdate_set_clock('N', secs2, mins2, hours2, days2, months2, years2);
    optdate_set_datetime();

    /* Reset the timezone to its oRIginAL vALuE */
    sprintf(buffer, "%d", original_offset);
    sprintf(oscli, "co. timezone %s\0", buffer);
    _kernel_oscli(oscli);

    /* Reset the system clock to it's original value */
    optdate_set_clock('N', secs, mins, hours, days, months, years);
  }
}

/************************************************************************/
/* optmisc_optionfields                                                 */
/*                                                                      */
/* Function deals with the optionfields on the OptMisc window.          */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optmisc_optionfields(int updown, ComponentId comp)
{
  switch(comp)
  {
    case(optmisc_capturetime_border):
    {
      /* Capture timeout option */
      ui_optionfield_update(updown, "OptMisc_Capture_", OptMisc_WindowHandle, optmisc_capturetime_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optmisc_enotes_border):
    {
      /* Enote printing option */
      ui_optionfield_update(updown, "Opt_YesNo_", OptMisc_WindowHandle, optmisc_enotes_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }

    case(optmisc_faxredial_border):
    {
      /* Fax redial count option */
      ui_optionfield_update(updown, "OptMisc_FaxRedial_", OptMisc_WindowHandle, optmisc_faxredial_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optmisc_pulsetone_border):
    {
      /* Pulse/Tone dial option */
      ui_optionfield_update(updown, "OptMisc_PulseTone_", OptMisc_WindowHandle, optmisc_pulsetone_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }

    case(optmisc_receipts_border):
    {
      /* Request Receipts option */
      ui_optionfield_update(updown, "Opt_YesNo_", OptMisc_WindowHandle, optmisc_receipts_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }

    case(optmisc_faxmethod_border):
    {
      /* Fax Method option */
      ui_optionfield_update(updown, "OptMisc_FaxMethod_", OptMisc_WindowHandle, optmisc_faxmethod_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }

    case(optmisc_prefixpause_border):
    {
      /* Post Prefix Pause */
      ui_optionfield_update(updown, "OptMisc_Pause_", OptMisc_WindowHandle, optmisc_prefixpause_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }

    case(optmisc_interpause_border):
    {
      /* Post International Pause */
      ui_optionfield_update(updown, "OptMisc_Pause_", OptMisc_WindowHandle, optmisc_interpause_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }
  }
}

/************************************************************************/
/* optlog_optionfields                                                  */
/*                                                                      */
/* Function deals with the optionfields on the OptLog window.           */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optlog_optionfields(int updown, ComponentId comp)
{
  switch(comp)
  {
    case(optlog_logsize_border):
    {
      /* LogFile size option */
      ui_optionfield_update(updown, "OptLog_LogSize_", OptLog_WindowHandle, optlog_logsize_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optlog_purgeperiod_border):
    {
      /* Purge period option */
      ui_optionfield_update(updown, "OptLog_PurgePeriod_", OptLog_WindowHandle, optlog_purgeperiod_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }

    case(optlog_hour_border):
    {
      /* Hour optionfield */
      ui_optionfield_update(updown, "OptDate_Hour_", OptLog_WindowHandle, optlog_hour_string, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optlog_minute_border):
    {
      /* Min optionfield */
      ui_optionfield_update(updown, "OptDate_Min_", OptLog_WindowHandle, optlog_minute_string, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optlog_day_border):
    {
      /* Day optionfield */
      ui_optionfield_update(updown, "OptMisc_Day_", OptLog_WindowHandle, optlog_day_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }

    case(optlog_email_border):
    {
      /* Email OptionField */
      ui_optionfield_update(updown, "Opt_YesNo_", OptLog_WindowHandle, optlog_email_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }

    case(optlog_print_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "Opt_YesNo_", OptLog_WindowHandle, optlog_print_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }
  }
}

/************************************************************************/
/* optisp1_optionfields                                                 */
/*                                                                      */
/* Function deals with the optionfields on the OptISP1 window.          */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optisp1_optionfields(int updown, ComponentId comp)
{
  switch(comp)
  {
    case(optisp1_dialupretry_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "OptISP1_Redial_", OptISP1_WindowHandle, optisp1_dialupretry_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optisp1_alternateretry_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "OptISP1_Redial_", OptISP1_WindowHandle, optisp1_alternateretry_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }
  }
}

/************************************************************************/
/* optisp2_optionfields                                                 */
/*                                                                      */
/* Function deals with the optionfields on the OptISP1 window.          */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optisp2_optionfields(int updown, ComponentId comp)
{
  switch(comp)
  {
    case(optisp2_missingpages_border):
    {
      /* Print optionfield */
      ui_optionfield_update(updown, "OptISP2_Pages_", OptISP2_WindowHandle, optisp2_missingpages_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optisp2_connectiontime_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "OptISP2_Connection_", OptISP2_WindowHandle, optisp2_connectiontime_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optisp2_pagesperemail_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "OptISP2_Pages_", OptISP2_WindowHandle, optisp2_pagesperemail_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optisp2_maxemailsize_border):
    {
      /* Print OptionField */
      ui_optionfield_update(updown, "OptISP2_MaxEmail_", OptISP2_WindowHandle, optisp2_maxemailsize_string, Optionfield_Wrap|Optionfield_Numerical);

      break;
    }

    case(optisp2_emailreceipt_border):
    {
      /* Print Optionfield */
      ui_optionfield_update(updown, "Opt_YesNo_", OptISP2_WindowHandle, optisp2_emailreceipt_string, Optionfield_Wrap|Optionfield_NonNumerical);

      break;
    }

    case(optisp2_switch1_border):
    {
      /* Alter the contents of the switch to either password mode or non-password */
      ui_optionfield_update(updown, "OptISP2_LoginField_", OptISP2_WindowHandle, optisp2_switch1_string, Optionfield_Wrap|Optionfield_NonNumerical);

      ui_update_login(optisp2_switch1_string, optisp2_login_response1);
      break;
    }

    case(optisp2_switch2_border):
    {
      /* Alter the contents of the switch to either password mode or non-password */
      ui_optionfield_update(updown, "OptISP2_LoginField_", OptISP2_WindowHandle, optisp2_switch2_string, Optionfield_Wrap|Optionfield_NonNumerical);

      ui_update_login(optisp2_switch2_string, optisp2_login_response2);
      break;
    }

    case(optisp2_switch3_border):
    {
      /* Alter the contents of the switch to either password mode or non-password */
      ui_optionfield_update(updown, "OptISP2_LoginField_", OptISP2_WindowHandle, optisp2_switch3_string, Optionfield_Wrap|Optionfield_NonNumerical);

      ui_update_login(optisp2_switch3_string, optisp2_login_response3);
      break;
    }

    case(optisp2_switch4_border):
    {
      /* Alter the contents of the switch to either password mode or non-password */
      ui_optionfield_update(updown, "OptISP2_LoginField_", OptISP2_WindowHandle, optisp2_switch4_string, Optionfield_Wrap|Optionfield_NonNumerical);

      ui_update_login(optisp2_switch4_string, optisp2_login_response4);
      break;
    }

    case(optisp2_switch5_border):
    {
      /* Alter the contents of the switch to either password mode or non-password */
      ui_optionfield_update(updown, "OptISP2_LoginField_", OptISP2_WindowHandle, optisp2_switch5_string, Optionfield_Wrap|Optionfield_NonNumerical);

      ui_update_login(optisp2_switch5_string, optisp2_login_response5);
      break;
    }
  }
}

/************************************************************************/
/* optsched_optionfields                                                */
/*                                                                      */
/* Function deals with the optionfields on the OptSchedule window.      */
/*                                                                      */
/* Parameters: updown   - UP | DOWN (key pressed).                      */
/*             comp     - which optionfield it is.                      */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void optsched_optionfields(int updown, ComponentId comp)
{
  /* The UI needs to alter the times depending on the day. Oh joy, this is going to be hell to do */
  switch(comp)
  {
    case(optschedule_scheduler_border):
    {
      /* Scheduler On/Off label */
      ui_optionfield_update(updown, "Opt_OnOff_", OptSchedule_WindowHandle, optschedule_scheduler_string, Optionfield_Wrap|Optionfield_NonNumerical);

      /* We now need to change this while *within* the scheduler to see if we need to ignore or save the
         entered schedule settings */
      if (misc_tag_lookup(OptSchedule_WindowHandle, optschedule_scheduler_string, "Opt_OnOff") == 1)
      {
        ui_sched_fade_fields(TRUE);
        sched_on = TRUE;
      }
      else
      {
        ui_sched_fade_fields(FALSE);
        sched_on = FALSE;
      }

      break;
    }

    case(optschedule_peakdialup_border):
    {
      /* Number of peak dialups label */
      ui_optionfield_update(updown, "OptSchedule_DialUp_", OptSchedule_WindowHandle, optschedule_peakdialup_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optschedule_offdialup_border):
    {
      /* Number of off-peak dialups */
      ui_optionfield_update(updown, "OptSchedule_DialUp_", OptSchedule_WindowHandle, optschedule_offdialup_string, Optionfield_Wrap|Optionfield_Numerical);
      break;
    }

    case(optschedule_stanweek_border):
    {
      /* This a standard week? */
      ui_optionfield_update(updown, "Opt_OnOff_", OptSchedule_WindowHandle, optschedule_stanweek_string, Optionfield_Wrap|Optionfield_NonNumerical);
      break;
    }

    case(optschedule_day_border):
    {
      /* Day label */
      ui_optionfield_update(updown, "OptMisc_Day_", OptSchedule_WindowHandle, optschedule_day_string, Optionfield_Wrap|Optionfield_NonNumerical);
      /* Update the time fields to display the times for that particular day */
      ui_sched_update_fields();
      break;
    }

    /* All the schedule fields */
    case(optschedule_peakstart_hour_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_peakstart_hour_string, 1, TRUE, updown);
      break;
    }

    case(optschedule_peakstart_min_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_peakstart_min_string, 1, FALSE, updown);
      break;
    }

    case(optschedule_peakend_hour_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_peakend_hour_string, 2, TRUE, updown);
      break;
    }

    case(optschedule_peakend_min_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_peakend_min_string, 2, FALSE, updown);
      break;
    }

    case(optschedule_idlestart_hour_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_idlestart_hour_string, 3, TRUE, updown);
      break;
    }

    case(optschedule_idlestart_min_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_idlestart_min_string, 3, FALSE, updown);
      break;
    }

    case(optschedule_idleend_hour_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_idleend_hour_string, 4, TRUE, updown);
      break;
    }

    case(optschedule_idleend_min_border):
    {
      ui_sched_time_fields(OptSchedule_WindowHandle, optschedule_idleend_min_string, 4, FALSE, updown);
      break;
    }
  }
}

/************************************************************************
 *  Name        : ui_sched_fade_fields                                  *
 *  Parameters  : TRUE/FALSE (greyed out fields or not)                 *
 *  Description : Greys out the scheduler fields if TRUE is passed, else*
 *                makes them selectable                                 *
 *  Returns     : Nothing                                               *
 ************************************************************************/
void ui_sched_fade_fields(int grey)
{
  int         loop;
  int         sicon[30];

  sicon[0] = optschedule_peakdialup_string;
  sicon[1] = optschedule_peakdialup_border;
  sicon[2] = optschedule_offdialup_string;
  sicon[3] = optschedule_offdialup_border;
  sicon[4] = optschedule_stanweek_string;
  sicon[5] = optschedule_stanweek_border;
  sicon[6] = optschedule_day_string;
  sicon[7] = optschedule_day_border;
  sicon[8] = optschedule_peakstart_hour_string;
  sicon[9] = optschedule_peakstart_hour_border;
  sicon[10] = optschedule_peakstart_min_string;
  sicon[11] = optschedule_peakstart_min_border;
  sicon[12] = optschedule_peakend_hour_string;
  sicon[13] = optschedule_peakend_hour_border;
  sicon[14] = optschedule_peakend_min_string;
  sicon[15] = optschedule_peakend_min_border;
  sicon[16] = optschedule_idlestart_hour_string;
  sicon[17] = optschedule_idlestart_hour_border;
  sicon[18] = optschedule_idlestart_min_string;
  sicon[19] = optschedule_idlestart_min_border;
  sicon[20] = optschedule_idleend_hour_string;
  sicon[21] = optschedule_idleend_hour_border;
  sicon[22] = optschedule_idleend_min_string;
  sicon[23] = optschedule_idleend_min_border;

  if (grey == TRUE)
  {
    /* Ungrey the icons */
    for (loop = 0; loop < 24; loop++)
      ui_alter_flag(OptSchedule_WindowHandle, sicon[loop], 0);
  }
  else
  {
    /* Grey those icons out */
    for (loop = 0; loop < 24; loop++)
      ui_alter_flag(OptSchedule_WindowHandle, sicon[loop], 1);
  }
}

/************************************************************************
 *  Name        : ui_sched_time_fields                                  *
 *  Parameters  : Window handle/Component handle/schedule time type/hour*
 *                or minute flag/updown                                 *
 *  Description : Updates the time set for the scheduler and updates the*
 *                displayed times                                       *
 *  Returns     : Nothing                                               *
 ************************************************************************/
void ui_sched_time_fields(ObjectId window, ComponentId comp, int type, int hom, int updown)
{
  _kernel_oserror	*er;
  char	buffer[255];
  int	hour = 0, min = 0, nbytes;

  /* Which scheduled times are we updating? */
  switch (type)
  {
    case 1:
    {
      hour = HH(sched_start_peak[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      min  = MM(sched_start_peak[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      break;
    }

    case 2:
    {
      hour = HH(sched_end_peak[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      min  = MM(sched_end_peak[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      break;
    }

    case 3:
    {
      hour = HH(sched_start_idle[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      min  = MM(sched_start_idle[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      break;
    }

    case 4:
    {
      hour = HH(sched_end_idle[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      min  = MM(sched_end_idle[misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day")]);
      break;
    }
  }

  /* If we're updating the hour */
  if (hom == TRUE)
  {
    /* Set the new hour */
    sprintf(buffer, "%d", hour);
    er = button_set_value(0, window, comp, buffer);
    ui_optionfield_update(updown, "OptDate_Hour_", window, comp, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
    er = button_get_value(0, window, comp, buffer, sizeof(buffer), &nbytes);
    hour = atoi(buffer);
  }
  else
  {
    /* Set the new minute */
    sprintf(buffer, "%d", min);
    er = button_set_value(0, window, comp, buffer);
    ui_optionfield_update(updown, "OptDate_Min_", window, comp, Optionfield_Numerical_FormatExpand|Optionfield_Wrap|Optionfield_Numerical);
    er = button_get_value(0, window, comp, buffer, sizeof(buffer), &nbytes);
    min = atoi(buffer);
  }

  /* And finally update the icon fields on the screen */
  ui_update_sched_time(misc_tag_lookup(window, optschedule_day_string, "OptMisc_Day"), type, HHMM(hour, min));
}

/************************************************************************
 *  Name        : ui_sched_update_fields                                *
 *  Parameters  : None                                                  *
 *  Description : Updates the icons in which the times are displayed    *
 *  Returns     : Nothing                                               *
 ************************************************************************/
void ui_sched_update_fields(void)
{
  _kernel_oserror	*er;
  int			peak_hour_start, peak_hour_end, peak_min_start, peak_min_end;
  int			idle_hour_start, idle_hour_end, idle_min_start, idle_min_end;
  char			buffer[255];

  /* Start and end of peak times in hours and minutes */
  peak_hour_start = HH(sched_start_peak[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  peak_hour_end   = HH(sched_end_peak[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  peak_min_start  = MM(sched_start_peak[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  peak_min_end	  = MM(sched_end_peak[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);

  /* Start and end of idle times in hours and minutes */
  idle_hour_start = HH(sched_start_idle[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  idle_hour_end   = HH(sched_end_idle[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  idle_min_start  = MM(sched_start_idle[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);
  idle_min_end    = MM(sched_end_idle[misc_tag_lookup(OptSchedule_WindowHandle, optschedule_day_string, "OptMisc_Day")]);

  /* Update the start and end optionfields for the peak times */
  sprintf(buffer, "%02d", peak_hour_start);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_peakstart_hour_string, buffer);
  sprintf(buffer, "%02d", peak_min_start);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_peakstart_min_string, buffer);
  sprintf(buffer, "%02d", peak_hour_end);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_peakend_hour_string, buffer);
  sprintf(buffer, "%02d", peak_min_end);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_peakend_min_string, buffer);

  /* Update the start and end optionfields for the idle times */
  sprintf(buffer, "%02d", idle_hour_start);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_idlestart_hour_string, buffer);
  sprintf(buffer, "%02d", idle_min_start);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_idlestart_min_string, buffer);
  sprintf(buffer, "%02d", idle_hour_end);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_idleend_hour_string, buffer);
  sprintf(buffer, "%02d", idle_min_end);
  er = button_set_value(0, OptSchedule_WindowHandle, optschedule_idleend_min_string, buffer);

  /* Done */
}

/************************************************************************
 *  Name        : ui_update_sched_time                                  *
 *  Parameters  : day/time specifier/new time                           *
 *  Description : Updates the times from the time passed to the function*
 *                depending on the specifier                            *
 *  Returns     : Nothing                                               *
 ************************************************************************/
void ui_update_sched_time(int day, int specifier, int new_time)
{
  int	day_loop;

  /* If this is Saturday or Sunday or a non-standard week, then we simply set individually */
  if ((day == 5) || (day == 6) || (misc_tag_lookup(OptSchedule_WindowHandle, optschedule_stanweek_string, "Opt_OnOff") == 0))
  {
    switch (specifier)
    {
      case 1:
      {
        sched_start_peak[day] = new_time;
        break;
      }

      case 2:
      {
        sched_end_peak[day] = new_time;
        break;
      }

      case 3:
      {
        sched_start_idle[day] = new_time;
        break;
      }

      case 4:
      {
        sched_end_idle[day] = new_time;
        break;
      }
    }
  }
  /* Else if we are on a 'standard' week, set all the times to be the same */
  else
  {
    for (day_loop = 0; day_loop < 5; day_loop++)
    {
      switch (specifier)
      {
        case 1:
        {
          sched_start_peak[day_loop] = new_time;
          break;
        }

        case 2:
        {
          sched_end_peak[day_loop] = new_time;
          break;
        }

        case 3:
        {
          sched_start_idle[day_loop] = new_time;
          break;
        }

        case 4:
        {
          sched_end_idle[day_loop] = new_time;
          break;
        }
      }
    }
  }
}

