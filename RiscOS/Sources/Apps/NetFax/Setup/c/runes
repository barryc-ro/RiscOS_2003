/************************************************************************/
/* File:    runes.c                                                     */
/* Purpose: File contains code to deal with the Soft and Hard keys on   */
/*          Daytona.  Contains state tables for what to do in each      */
/*          circumstance.                                               */
/*                                                                      */
/* Author:  Neil Bingham (mailto:NBingham@acorn.co.uk)                  */
/* History: Thu 31st July 1997    - ver 0.01 - Created.                 */
/*	    Thu 13th November     - ver 0.09 - Loads and loads and loads*/
/*				  added, hence the huge leap in number  */
/*	    Tue 06th January 1998 -ver 0.11  - Fixed timezone/dst bug   */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "main.h"
#include "functions.h"
#include "stdio.h"
#include "datetime.h"
#include "scheduler.h"
#include "messhandle.h"
#include "ui.h"
#include "load.h"
#include "save.h"
#include "cancel.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

static int  back_choice = 0;
static struct tm *stat_time;

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* sk_1_pressed                                                         */
/*                                                                      */
/* Function does something when softkey 1 is pressed depending on which */
/* window is open.                                                      */
/*                                                                      */
/* Parameters: Toolbox Event Handler Parameters.                        */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sk_1_pressed(void)
{
  _kernel_oserror	*er; /* Okay, it's horrible but for now will have to suffice */
  char			buffer[50];
  struct tm		*local_time;
  int			year, month, day, hour, min, sec, invalid = 0, returned;
  int			peak_start, peak_end, idle_start, idle_end, loop, total_peak_mins, total_offpeak_mins;

  /* Reset the error switch */
  confirm_error = 0;

  switch(which_window(ui_currently_open_win))
  {
    case (OptMain_Window):
    {
      /* Load the settings - they might be new (CAS) */
      load_user_settings();
      ui_open_window(3, OptUser_WindowHandle, "OptUser_Title", "OptUser_SK1", "OptUser_SK2", "OptUser_SK3", "OptUser_SK4", -1);
      break;
    }

    case (OptUser_Window):
    {
      /* Check to see if any of the fax number hasn't been filled in. This information *must* be filled in */
      er = writablefield_get_value(0, OptUser_WindowHandle, optuser_fax_country, buffer, sizeof(buffer), 0);
      misc_error_check(er);
      if (strlen(buffer) == 0)
      {
        /* Tell the user to enter a fax country code */
        confirm_error = 1;
      }

      er = writablefield_get_value(0, OptUser_WindowHandle, optuser_fax_area_code, buffer, sizeof(buffer), 0);
      misc_error_check(er);
      if (strlen(buffer) == 0)
      {
        /* Tell the user to enter a fax area code */
        confirm_error = 2;
      }

      er = writablefield_get_value(0, OptUser_WindowHandle, optuser_fax_number, buffer, sizeof(buffer), 0);
      misc_error_check(er);
      if (strlen(buffer) == 0)
      {
        /* Tell the user to enter a fax number */
        confirm_error = 3;
      }


      /* We have to check to see if there's an international number included in the setup. Basically, there
         has to be, so if it's not present, we complain. */
      er = writablefield_get_value(0, OptUser_WindowHandle, optuser_international_access_code, buffer,
                                   sizeof(buffer), 0);
      misc_error_check(er);

      /* If the buffer for the international field is empty... */
      if (strlen(buffer) == 0)
      {
        /* We need a confirm window to tell the user to enter a code in the international field */
        confirm_error = 4;
      }

      /* If there is a national code used for the fax number, then there must be an national code in the
         national access code field */
      er = writablefield_get_value(0, OptUser_WindowHandle, optuser_fax_area_code, buffer,
                                   sizeof(buffer), 0);
      misc_error_check(er);

      /* If the buffer for the national code contains something... */
      if (strlen(buffer) != 0)
      {
        er = writablefield_get_value(0, OptUser_WindowHandle, optuser_national_access_code, buffer,
                                   sizeof(buffer), 0);
        misc_error_check(er);

        if (strlen(buffer) == 0)
        {
          confirm_error = 5;
        }
      }

      /* If we've detected an error, bring up a confirm window */
      if (confirm_error != 0)
      {
        runes_user_confirm(ConfirmAction_Start);
      }
      /* Else save the options from this window */
      else
      {
        /* Save the settings from the user settings window */
        save_user_settings();

        ui_update_clock_display();
        ui_open_window(1, OptMain_WindowHandle, "OptMain_Title","OptMain_SK1","OptMain_SK2",
                        "OptMain_SK3","OptMain_SK4", -1);

        update = ALL_UPDATE;
      }
      break;
    }

    case (OptSystem_Window):
    {
      /* Load the settings - they might be new (CAS) */

      /* System settings window open - so open Date window */
      time_window_opened = 1;
      optdate_set_datetime();
      optdate_get_time_now(&stat_time);

      /* We also make a copy of the current DST and Timezone status in case the user decides to Cancel
         the option later, so we can restore */
      er = button_get_value(0, OptDate_WindowHandle, optdate_toffset_string, buffer, sizeof(buffer), 0);
      misc_error_check(er);
      strcpy(timezone_store, buffer);

      er = button_get_value(0, OptDate_WindowHandle, optdate_dsave_string, buffer, sizeof(buffer), 0);
      misc_error_check(er);
      strcpy(daysave_store, buffer);

      ui_open_window(3, OptDate_WindowHandle, "OptDate_Title", "OptDate_SK1", "OptDate_SK2", "OptDate_SK3", "OptDate_SK4", -1);

      update = ALL_UPDATE;
      break;
    }

    case(OptEmail_Window):
    {
      load_isp1_settings();
      ui_open_window(3, OptISP1_WindowHandle, "OptISP1_Title", "OptISP1_SK1", "OptISP1_SK2",
                        "OptISP1_SK3", "OptISP1_SK4", -1);
      break;
    }

    case(OptDate_Window):
    {
      /* We should grab a copy of the local date-time, save, make sure the day, month and year
         are the same as the one just set */

      /* Get time before setting */
      optdate_get_time_now(&local_time);
      sec = local_time->tm_sec; min = local_time->tm_min; hour = local_time->tm_hour;
      day = local_time->tm_mday; month = local_time->tm_mon; year = local_time->tm_year;

      /* Now we set the time from the writable fields */
      er = button_get_value(0, OptDate_WindowHandle, optdate_dsave_string, buffer, sizeof(buffer), 0);
      if (misc_tag_lookup(OptDate_WindowHandle, optdate_dsave_string, "Opt_OnOff") == 1)
        _kernel_oscli("co. dst");
      else
      	_kernel_oscli("co. nodst");

      optdate_set_clock('S', 0, 0, 0, 0, 0, 0);

      /* Now get the date/time after being set from writables */
      optdate_get_time_now(&local_time);

      /* Now let's compare the writable fields to the time just grabbed */
      /* If it's not the same, display and error and reset the date to original value */
      if (optdate_compare(local_time) == FALSE)
      {
        /* ERROR! */
        optdate_set_clock('N', sec, min, hour, day, month, year);
        /*er = ui_confirm_window("OptDate_Error_Title", "OptDate_Error_Message", NULL, NULL, "confirm_1", runes_confirm(1));*/
        runes_date_confirm(ConfirmAction_Start);
      }
      else
      {
        /* Save the settings! */
        ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1",
                     "OptSystem_SK2", "OptSystem_SK3", "OptSystem_SK4", -1);

        /* Save the date and time settings */
        save_datetime_settings();

        update = ALL_UPDATE;
      }
      break;
    }

    case (OptISP1_Window):
    {
      /* Save the ISP details */
      save_isp1_settings();

      update = DAY_UPDATE;
      ui_open_window(1, OptEmail_WindowHandle, "OptEmail_Title", "OptEmail_SK1",
                     "OptEmail_SK2", "OptEmail_SK3", "OptEmail_SK4", -1);
      break;
    }

    case (OptISP2_Window):
    {
      /* Save the ISP details */
      returned = save_isp2_settings();

      if (returned == TRUE)
      {
        update = DAY_UPDATE;
        ui_open_window(1, OptEmail_WindowHandle, "OptEmail_Title", "OptEmail_SK1",
                     "OptEmail_SK2", "OptEmail_SK3", "OptEmail_SK4", -1);
      }
      break;
    }

    case (OptMisc_Window):
    {
      save_misc_settings();

      ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1",
                     "OptSystem_SK2", "OptSystem_SK3", "OptSystem_SK4", -1);

      update = ALL_UPDATE;
      break;
    }

    case (OptLog_Window):
    {
      /* Let's take a look at the email purge and log destination tags. If email purge is on, and there's
         no destination, throw an error */

      /* Get the string used to send the log to the admin */
      er = writablefield_get_value(0, OptLog_WindowHandle, optlog_admin_string, buffer, sizeof(buffer), 0);
      misc_error_check(er);

      dprintf(("", "Log email : %s, Length : %d\n", buffer, strlen(buffer)));
      dprintf(("", "Opmisc email : %d\n", misc_tag_lookup(OptLog_WindowHandle, optlog_email_string, "Opt_YesNo")));

      if ((misc_tag_lookup(OptLog_WindowHandle, optlog_email_string, "Opt_YesNo") == 1) &&
          (strlen(buffer) == 0))
      {
        runes_log_confirm(ConfirmAction_Start);
      }
      else
      {
        /* Save the settings */
        save_log_settings();

        ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1",
                       "OptSystem_SK2", "OptSystem_SK3", "OptSystem_SK4", -1);

        update = ALL_UPDATE;
      }
      break;
    }

    case (OptSchedule_Window):
    {
      dprintf(("", "Schedule window\n"));
      /* If the Scheduler is turned on, then we can check and then save the settings */
      if (sched_on == TRUE)
      {
        dprintf(("", "Scheduler is on\n"));
        /* Check to see if all the scheduler times are correct before saving */
        loop = 0;
        while (loop < 7)
        {
          /* Check to see if the peak and idle times overlap, if they do, say so */
          peak_start = sched_start_peak[loop];
          peak_end = sched_end_peak[loop];
          idle_start = sched_start_idle[loop];
          idle_end = sched_end_idle[loop];

          if ((peak_end < peak_start) || (idle_end < idle_start))
          {
            /* Invalid times, scheduler error message 1 */
            invalid = TRUE;
            confirm_error = 1;
          }
          else
          {
            if ((idle_start > peak_start) && (idle_start < peak_end))
            {
              /* Invalid times, scheduler error message 2 */
              invalid = TRUE;
              confirm_error = 2;
            }
            else if ((idle_end > peak_start) && (idle_end < peak_end))
            {
              /* Invalid times, scheduler error message 3 */
              invalid = TRUE;
              confirm_error = 3;
            }
            else if ((peak_start > idle_start) && (peak_start < idle_end))
            {
              /* Invalid times, scheduler error message 4 */
              invalid = TRUE;
              confirm_error = 4;
            }
          }

          /* If the peak start and end times are the same, then they are not used */
          if ((peak_start == peak_end) && (invalid == FALSE))
          {
            sched_start_peak[loop] = -1;
            sched_end_peak[loop] = -1;
            invalid = FALSE;
            dprintf(("", "Day : %d set to same peak time\n", loop));
          }

          /* If the idle start and end times are the same, then they are not used */
          if ((idle_start == idle_end) && (invalid == FALSE))
          {
            dprintf(("", "Day : %d set to same idle time\n", loop));
            sched_start_idle[loop] = -1;
            sched_end_idle[loop] = -1;
            invalid = FALSE;
          }

          /* Check to make sure that there are less dial-ups than there are total mins in dial-up time
             (ie. not more than one dial-up per minute) */
          /* We first need to work out how many minutes there are between dial-ups */
          total_peak_mins = ((sched_end_peak[loop] - sched_start_peak[loop]) / (100 * 60));
          dprintf(("", "Total mins : %d\n", total_peak_mins));

          total_offpeak_mins = ((2400 * 3600) - (sched_end_idle[loop] - sched_start_idle[loop])
                               - (total_peak_mins * (100 * 60)))/ (100 * 60);
          dprintf(("", "Total offpeak : %d\n", total_offpeak_mins));

          /* Are there more peak dial-ups then peak minutes? */
          if ((sched_num_peak[loop] > total_peak_mins) && (total_peak_mins != 0))
          {
            dprintf(("", "Sched on : %d\n", sched_num_peak[loop]));
            confirm_error = 6;
            invalid = TRUE;
          }

          /* Are there more offpeak dial-ups that offpeak minutes? */
          if ((sched_num_off[loop] > total_offpeak_mins) && (total_offpeak_mins != 0))
          {
            dprintf(("", "Sched off : %d\n", sched_num_off[loop]));
            confirm_error = 7;
            invalid = TRUE;
          }

          /* If there's an invalid parameter somewhere, inform the user */
          if (invalid == TRUE)
          {
            sched_error_day = loop;
            runes_sched_confirm(ConfirmAction_Start);
            loop = 6;
          }
          loop++;
        }
      }

      /* Save the gubbins */
      if (invalid != TRUE)
      {
        save_sched_settings();
        ui_open_window(1, OptMain_WindowHandle, "OptMain_Title", "OptMain_SK1", "OptMain_SK2",
      		       "OptMain_SK3", "OptMain_SK4", -1);
      }

      if (sched_on == FALSE)
        ui_open_window(1, OptMain_WindowHandle, "OptMain_Title", "OptMain_SK1", "OptMain_SK2",
      			"OptMain_SK3", "OptMain_SK4", -1);

      break;
    }

    default:
    {
      debug_beep();
      break;
    }
  }
}

/************************************************************************/
/* sk_2_pressed                                                         */
/*                                                                      */
/* Function does something when softkey 3 is pressed.                   */
/*                                                                      */
/* Parameters: Toolbox Event Handler Parameters.                        */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sk_2_pressed(void)
{
  back_choice = 1;
  switch(which_window(ui_currently_open_win))
  {
    case (OptMain_Window):
    {
      ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1",
                     "OptSystem_SK2", "OptSystem_SK3", "OptSystem_SK4", -1);
      break;
    }

    case (OptUser_Window):
    {
      /* A Cancel decision window should now pop up */
      runes_user_decision(DecideAction_Start, 0);
      break;
    }

    case(OptSystem_Window):
    {
      /* Load the settings - the might be new (CAS) */
      ui_open_window(1, OptEmail_WindowHandle, "OptEmail_Title", "OptEmail_SK1", "OptEmail_SK2",
                        "OptEmail_SK3", "OptEmail_SK4", -1);
      break;
    }

    case(OptEmail_Window):
    {
      load_isp2_settings();
      ui_open_window(3, OptISP2_WindowHandle, "OptISP2_Title", "OptISP2_SK1", "OptISP2_SK2",
                        "OptISP2_SK3", "OptISP2_SK4", -1);
      break;
    }

    case(OptDate_Window):
    {
      /* We want to now restore the timezone and the daylight saving information as they are no longer required */
      runes_date_decision(DecideAction_Start, 0);
      break;
    }

    case(OptMisc_Window):
    {
      runes_misc_decision(DecideAction_Start, 0);
      break;
    }
    case(OptISP1_Window):
    {
      runes_isp1_decision(DecideAction_Start, 0);
      break;
    }
    case(OptISP2_Window):
    {
      runes_isp2_decision(DecideAction_Start, 0);
      break;
    }
    case(OptSchedule_Window):
    {
      runes_sched_decision(DecideAction_Start, 0);
      break;
    }

    case (OptLog_Window):
    {
      runes_log_decision(DecideAction_Start, 0);
      break;
    }

    default:
    {
      debug_beep();
      break;
    }
  }
}

/************************************************************************/
/* sk_3_pressed                                                         */
/*                                                                      */
/* Function does something when softkey 3 is pressed.                   */
/*                                                                      */
/* Parameters: Toolbox Event Handler Parameters.                        */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sk_3_pressed(void)
{
  _kernel_oserror *er;
  int             loop, nbytes;
  char            buffer[255];

  switch(which_window(ui_currently_open_win))
  {
    case (OptMain_Window):
    {
      /* Load the settings - they might have changed (CAS) */
      load_sched_settings();

      /* Store the old values in case cancel is pressed in the scheduler window */
      /* These are special cases, there aren't any tags for these labels so we have to
         store them ourselves */
      er = button_get_value(0, OptSchedule_WindowHandle, optschedule_scheduler_string, buffer, sizeof(buffer),
                            &nbytes);
      misc_error_check(er);
      old_sched_state = atoi(buffer);

      er = button_get_value(0, OptSchedule_WindowHandle, optschedule_stanweek_string, buffer, sizeof(buffer),
                            &nbytes);
      misc_error_check(er);
      old_sched_week = atoi(buffer);

      er = button_get_value(0, OptSchedule_WindowHandle, optschedule_day_string, buffer, sizeof(buffer),
                            &nbytes);
      misc_error_check(er);
      strcpy(old_sched_day, buffer);

      for (loop = 0; loop < 7; loop ++)
      {
        old_sched_num_peak = sched_num_peak[loop];
        old_sched_num_off = sched_num_off[loop];
        old_sched_start_peak[loop] = sched_start_peak[loop];
        old_sched_end_peak[loop]   = sched_end_peak[loop];
        old_sched_start_idle[loop] = sched_start_idle[loop];
        old_sched_end_idle[loop]   = sched_end_idle[loop];
      }

      ui_open_window(3, OptSchedule_WindowHandle, "OptSchedule_Title", "OptSchedule_SK1",
                     "OptSchedule_SK2", "OptSchedule_SK3", "OptSchedule_SK4", -1);
      break;
    }

    case(OptSystem_Window):
    {
      /* Load the settings - they might have changed (CAS) */
      load_misc_settings();
      ui_open_window(3, OptMisc_WindowHandle, "OptMisc_Title", "OptMisc_SK1", "OptMisc_SK2", "OptMisc_SK3",
                     "OptMisc_SK4", -1);
      break;
    }
  }
}

/************************************************************************/
/* sk_4_pressed                                                         */
/*                                                                      */
/* Function does something when softkey 4 is pressed.                   */
/*                                                                      */
/* Parameters: Toolbox Event Handler Parameters.                        */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void sk_4_pressed(void)
{
  switch(which_window(ui_currently_open_win))
  {
    case (OptMain_Window):
    {
      ui_open_other_program_window(Open_DayLog_Main, 0);
      break;
    }

    case (OptSystem_Window):
    {
      load_log_settings();
      ui_open_window(3, OptLog_WindowHandle, "OptLog_Title", "OptLog_SK1", "OptLog_SK2", "OptLog_SK3",
                     "OptLog_SK4", -1);
      break;
    }
  }
}

/************************************************************************/
/* help_pressed                                                         */
/*                                                                      */
/* Function does something when Help key is pressed.                    */
/*                                                                      */
/* Parameters: Toolbox Event Handler Parameters.                        */
/*                                                                      */
/* Returns:    TRUE or FALSE.                                           */
/*                                                                      */
/************************************************************************/
void help_pressed(void)
{
  /* Hubble dubble, toil and bubble, there's no help, so we're in trouble */
  dprintf(("", "*PANIC!*\n"));
}

/************************************************************************/
/* home_pressed                                                         */
/*                                                                      */
/* Function opens Home_WindowHandle when Home is pressed.               */
/*                                                                      */
/* Parameters: Toolbox Event Handler Parameters.                        */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void home_pressed(void)
{
  back_choice = 2;
  switch(which_window(ui_currently_open_win))
  {
    case (OptMain_Window):
    {
      /* Must pass message to !Daytona from here. */
      ui_open_other_program_window(Open_Daytona_Home, 0);
      break;
    }

    case(OptUser_Window):
    {
      runes_user_decision(DecideAction_Start, 0);
      break;
    }

    case(OptSystem_Window):
    {
      /* Must pass message to !Daytona from here. */
      ui_open_other_program_window(Open_Daytona_Home, 0);
      break;
    }

    case(OptDate_Window):
    {
      runes_date_decision(DecideAction_Start, 0);
      break;
    }

    case(OptMisc_Window):
    {
      runes_misc_decision(DecideAction_Start, 0);
      break;
    }

    case(OptEmail_Window):
    {
      /* Must pass message to !Daytona from here. */
      ui_open_other_program_window(Open_Daytona_Home, 0);
      break;
    }

    case(OptISP1_Window):
    {
      runes_isp1_decision(DecideAction_Start, 0);
      break;
    }

    case(OptISP2_Window):
    {
      runes_isp2_decision(DecideAction_Start, 0);
      break;
    }

    case(OptSchedule_Window):
    {
      runes_sched_decision(DecideAction_Start, 0);
      break;
    }
    case(OptLog_Window):
    {
      runes_log_decision(DecideAction_Start, 0);
      break;
    }

    default:
    {
      debug_beep();
      break;
    }
  }
}

/************************************************************************/
/* back_pressed                                                         */
/*                                                                      */
/* Function opens the next window up in the chain.                      */
/*                                                                      */
/* Parameters: Toolbox Event Handler Parameters.                        */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void back_pressed(void)
{
  back_choice = 1;
  switch(which_window(ui_currently_open_win))
  {
    case (OptMain_Window):
    {
      /* Must pass message to !Daytona from here. */
      ui_open_other_program_window(Open_Daytona_Home, 0);
      break;
    }

    case(OptUser_Window):
    {
      runes_user_decision(DecideAction_Start, 0);
      break;
    }

    case(OptSystem_Window):
    {
      ui_open_window(1,OptMain_WindowHandle,"OptMain_Title","OptMain_SK1","OptMain_SK2",
                      "OptMain_SK3","OptMain_SK4", -1);
      break;
    }

    case(OptDate_Window):
    {
      runes_date_decision(DecideAction_Start, 0);
      break;
    }

    case(OptMisc_Window):
    {
      runes_misc_decision(DecideAction_Start, 0);
      break;
    }

    case(OptEmail_Window):
    {
      ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1",
                     "OptSystem_SK2", "OptSystem_SK3", "OptSystem_SK4", -1);
      break;
    }

    case(OptISP1_Window):
    {
      runes_isp1_decision(DecideAction_Start, 0);
      break;
    }

    case(OptISP2_Window):
    {
      runes_isp2_decision(DecideAction_Start, 0);
      break;
    }

    case(OptSchedule_Window):
    {
      runes_sched_decision(DecideAction_Start, 0);
      break;
    }
    case(OptLog_Window):
    {
      runes_log_decision(DecideAction_Start, 0);
      break;
    }

    default:
    {
      debug_beep();
      break;
    }
  }
}

/************************************************************************/
/* runes_user_confirm                                                   */
/*                                                                      */
/* Function starts and stops the user confirm window                    */
/*                                                                      */
/* Parameters: confirm window start/stop code                           */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_user_confirm(int code)
{
  _kernel_oserror	*er;
  char                  mess_string[255];
  int                   gadget_highlight = 0;

  sprintf(mess_string, "OptUser_Error_Message_%d", confirm_error);

  if (code == ConfirmAction_Start)
  {
    er = ui_confirm_window("OptDate_User_Title", mess_string, NULL, NULL, "confirm_1",
                            runes_user_confirm);
    misc_error_check(er);
  }
  else
  {
    switch (confirm_error)
    {
      case 1:
      {
        /* International access code gadget */
        gadget_highlight = optuser_international_access_code;
        break;
      }

      case 2:
      {
        /* National access code gadget */
        gadget_highlight = optuser_national_access_code;
        break;
      }
    }

    /* The date is not valid, so we want to highlight the date icon using iconhigh */
    er = ui_open_window(3, OptUser_WindowHandle, "OptUser_Title", "OptUser_SK1", "OptUser_SK2", "OptUser_SK3",
                                                    "OptUser_SK4", gadget_highlight);
    misc_error_check(er);
  }
}

/************************************************************************/
/* runes_date_confirm                                                   */
/*                                                                      */
/* Function starts and stops the date confirm window                    */
/*                                                                      */
/* Parameters: confirm window start/stop code                           */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_date_confirm(int code)
{
  _kernel_oserror	*er;

  if (code == ConfirmAction_Start)
  {
    er = ui_confirm_window("OptDate_Error_Title", "OptDate_Error_Message", NULL, NULL, "confirm_1",
                            runes_date_confirm);
    misc_error_check(er);
  }
  else
  {
    /* The date is not valid, so we want to highlight the date icon using iconhigh */
    er = ui_open_window(3, OptDate_WindowHandle, "OptDate_Title", "OptDate_SK1", "OptDate_SK2", "OptDate_SK3",
                                                    "OptDate_SK4", optdate_day_string);
    misc_error_check(er);
  }
}

/************************************************************************/
/* runes_sched_confirm                                                  */
/*                                                                      */
/* Function starts and stops the sched confirm window                   */
/*                                                                      */
/* Parameters: confirm window start/stop code                           */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_sched_confirm(int code)
{
  _kernel_oserror	*er;
  char                  mess_string[255], param_string[255];

  if (code == ConfirmAction_Start)
  {
    /* Get the right error message */
    sprintf(mess_string, "OptSchedule_Error_Message_%d", confirm_error);
    sprintf(param_string, "OptMisc_Day_%d", sched_error_day);

    er = ui_confirm_window("OptSchedule_Error_Title", mess_string, misc_lookup_message_token(param_string), NULL,
                            "confirm_1", runes_sched_confirm);
    misc_error_check(er);
  }
  else
  {
    er = ui_open_window(3, OptSchedule_WindowHandle, "OptSchedule_Title", "OptSchedule_SK1", "OptSchedule_SK2",
 	  						"OptSchedule_SK3", "OptSchedule_SK4", -1);
    misc_error_check(er);
  }
}

/************************************************************************/
/* runes_login_confirm                                                  */
/*                                                                      */
/* Function starts and stops the login confirm window                   */
/*                                                                      */
/* Parameters: confirm window start/stop code                           */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_login_confirm(int code)
{
  _kernel_oserror	*er;

  if (code == ConfirmAction_Start)
  {
    er = ui_confirm_window("OptISP_Error_Title", "OptISP_Error_Message", NULL, NULL, "confirm_1",
                            runes_login_confirm);
    misc_error_check(er);
  }
  else
  {
    er = ui_open_window(3, OptSchedule_WindowHandle, "OptSchedule_Title", "OptSchedule_SK1", "OptSchedule_SK2",
  							"OptSchedule_SK3", "OptSchedule_SK4", -1);
    misc_error_check(er);
  }
}

/************************************************************************/
/* runes_log_confirm                                                    */
/*                                                                      */
/* Function starts and stops the misc confirm window                    */
/*                                                                      */
/* Parameters: confirm window start/stop code                           */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_log_confirm(int code)
{
  _kernel_oserror       *er;

  if (code == ConfirmAction_Start)
  {
    er = ui_confirm_window("OptLog_Error_Title", "OptLog_Error_Message", NULL, NULL, "confirm_1",
                            runes_log_confirm);
    misc_error_check(er);
  }
  else
  {
    er = ui_open_window(3, OptLog_WindowHandle, "OptLog_Title", "OptLog_SK1", "OptLog_SK2", "OptLog_SK3",
                        "OptLog_SK4", optlog_admin_string);
    misc_error_check(er);
  }
}

/************************************************************************/
/* runes_user_decision                                                  */
/*                                                                      */
/* Function starts and stops the user decision window                   */
/*                                                                      */
/* Parameters: decision window start/stop code                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_user_decision(int code, int action)
{
  _kernel_oserror        *er;

  if (code == DecideAction_Start)
  {
    /* We check to see if anything has changed */
    /* If something's changed, we ask the user if they really want to cancel */
    if (cancel_user() != FALSE)
    {
      er = ui_decide_window("OptCancel_Title", "Opt_YesNo_1", "Opt_YesNo_0",  "OptCancel_Message", NULL, NULL,
                             "decide_0", runes_user_decision, 0);
      misc_error_check(er);
    }
    /* Else we simply return to the previous screen */
    else
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptMain_WindowHandle, "OptMain_Title", "OptMain_SK1", "OptMain_SK2",
      	    		"OptMain_SK3", "OptMain_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
  }
  else
  {
    /* If 'Yes' has been pressed */
    if (action == 1)
    {
      dprintf(("", "back : %d\n", back_choice));
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptMain_WindowHandle, "OptMain_Title", "OptMain_SK1", "OptMain_SK2",
      			"OptMain_SK3", "OptMain_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
    /* If 'No' has been pressed */
    else
    {
      er = ui_open_window(3, OptUser_WindowHandle, "OptUser_Title", "OptUser_SK1", "OptUser_SK2", "OptUser_SK3",
                          "OptUser_SK4", -1);
      misc_error_check(er);
    }
  }
}

/************************************************************************/
/* runes_date_decision                                                  */
/*                                                                      */
/* Function starts and stops the date decision window                   */
/*                                                                      */
/* Parameters: decision window start/stop code                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_date_decision(int code, int action)
{
  _kernel_oserror        *er;

  if (code == DecideAction_Start)
  {
    /* We check to see if anything has changed */
    /* If something's changed, we ask the user if they really want to cancel */
    if (cancel_datetime(stat_time) != FALSE)
    {
      er = ui_decide_window("OptCancel_Title", "Opt_YesNo_1", "Opt_YesNo_0",  "OptCancel_Message", NULL, NULL,
                           "decide_0", runes_date_decision, 0);
      misc_error_check(er);
    }
    else
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1", "OptSystem_SK2",
      			"OptSystem_SK3", "OptSystem_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
  }
  else
  {
    /* If 'Yes' has been pressed */
    if (action == 1)
    {
      /* Reset Timezone and DST values */
      er = button_set_value(0, OptDate_WindowHandle, optdate_toffset_string, timezone_store);
      misc_error_check(er);

      er = button_set_value(0, OptDate_WindowHandle, optdate_dsave_string, daysave_store);
      misc_error_check(er);

      if (back_choice == 1)
      {
        er = ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1", "OptSystem_SK2",
      			"OptSystem_SK3", "OptSystem_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
    /* If 'No' has been pressed */
    else
    {
      er = ui_open_window(3, OptDate_WindowHandle, "OptDate_Title", "OptDate_SK1", "OptDate_SK2", "OptDate_SK3",
                                                    "OptDate_SK4", -1);
      misc_error_check(er);
    }
  }
}

/************************************************************************/
/* runes_isp1_decision                                                  */
/*                                                                      */
/* Function starts and stops the isp1 decision window                   */
/*                                                                      */
/* Parameters: decision window start/stop code                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_isp1_decision(int code, int action)
{
  _kernel_oserror        *er;

  if (code == DecideAction_Start)
  {
    if (cancel_isp_main() != FALSE)
    {
      er = ui_decide_window("OptCancel_Title", "Opt_YesNo_1", "Opt_YesNo_0",  "OptCancel_Message", NULL, NULL,
                             "decide_0", runes_isp1_decision, 0);
      misc_error_check(er);
    }
    else
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptEmail_WindowHandle, "OptEmail_Title", "OptEmail_SK1",
                       "OptEmail_SK2", "OptEmail_SK3", "OptEmail_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
  }
  else
  {
    /* If 'Yes' has been pressed */
    if (action == 1)
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptEmail_WindowHandle, "OptEmail_Title", "OptEmail_SK1",
                     "OptEmail_SK2", "OptEmail_SK3", "OptEmail_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
    /* If 'No' has been pressed */
    else
    {
      er = ui_open_window(3, OptISP1_WindowHandle, "OptISP1_Title", "OptISP1_SK1", "OptISP1_SK2", "OptISP1_SK3",
                          "OptISP1_SK4", -1);
      misc_error_check(er);
    }
  }
}

/************************************************************************/
/* runes_isp2_decision                                                  */
/*                                                                      */
/* Function starts and stops the isp2 decision window                   */
/*                                                                      */
/* Parameters: decision window start/stop code                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_isp2_decision(int code, int action)
{
  _kernel_oserror        *er;

  if (code == DecideAction_Start)
  {
    if (cancel_isp_additional() != FALSE)
    {
      er = ui_decide_window("OptCancel_Title", "Opt_YesNo_1", "Opt_YesNo_0",  "OptCancel_Message", NULL, NULL,
                             "decide_0", runes_isp2_decision, 0);
      misc_error_check(er);
    }
    else
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptEmail_WindowHandle, "OptEmail_Title", "OptEmail_SK1",
                       "OptEmail_SK2", "OptEmail_SK3", "OptEmail_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
  }
  else
  {
    /* If 'Yes' has been pressed */
    if (action == 1)
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptEmail_WindowHandle, "OptEmail_Title", "OptEmail_SK1",
                     "OptEmail_SK2", "OptEmail_SK3", "OptEmail_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
    /* If 'No' has been pressed */
    else
    {
      er = ui_open_window(3, OptISP2_WindowHandle, "OptISP2_Title", "OptISP2_SK1", "OptISP2_SK2", "OptISP2_SK3",
                          "OptISP2_SK4", -1);
      misc_error_check(er);
    }
  }
}

/************************************************************************/
/* runes_sched_decision                                                 */
/*                                                                      */
/* Function starts and stops the sched decision window                  */
/*                                                                      */
/* Parameters: decision window start/stop code                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_sched_decision(int code, int action)
{
  _kernel_oserror        *er;
  char                   buffer[255];
  int                    loop;

  if (code == DecideAction_Start)
  {
    if (cancel_schedule() != FALSE)
    {
      er = ui_decide_window("OptCancel_Title", "Opt_YesNo_1", "Opt_YesNo_0",  "OptCancel_Message", NULL, NULL,
                             "decide_0", runes_sched_decision, 0);
      misc_error_check(er);
    }
    else
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptMain_WindowHandle, "OptMain_Title", "OptMain_SK1",
                     "OptMain_SK2", "OptMain_SK3", "OptMain_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
  }
  else
  {
    /* If 'Yes' has been pressed */
    if (action == 1)
    {
      /* Reset the old values, as the new ones are now cancelled */
      sprintf(buffer, "%d", old_sched_state);
      er = button_set_value(0, OptSchedule_WindowHandle, optschedule_scheduler_string, buffer);
      misc_error_check(er);

      sprintf(buffer, "%d", old_sched_week);
      er = button_set_value(0, OptSchedule_WindowHandle, optschedule_stanweek_string, buffer);
      misc_error_check(er);

      sprintf(buffer, "%s", old_sched_day);
      er = button_set_value(0, OptSchedule_WindowHandle, optschedule_day_string, buffer);
      misc_error_check(er);

      for (loop = 0; loop < 7; loop++)
      {
        sched_num_peak[loop]   = old_sched_num_peak;
        sched_num_off[loop]    = old_sched_num_off;
        sched_start_peak[loop] = old_sched_start_peak[loop];
        sched_end_peak[loop]   = old_sched_end_peak[loop];
        sched_start_idle[loop] = old_sched_start_idle[loop];
        sched_end_idle[loop]   = old_sched_end_idle[loop];
      }

      ui_sched_update_fields();

      if (back_choice == 1)
      {
        er = ui_open_window(1, OptMain_WindowHandle, "OptMain_Title", "OptMain_SK1",
                     "OptMain_SK2", "OptMain_SK3", "OptMain_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
    /* If 'No' has been pressed */
    else
    {
      er = ui_open_window(3, OptSchedule_WindowHandle, "OptSchedule_Title", "OptSchedule_SK1",
                     "OptSchedule_SK2", "OptSchedule_SK3", "OptSchedule_SK4", -1);
      misc_error_check(er);
    }
  }
}

/************************************************************************/
/* runes_misc_decision                                                  */
/*                                                                      */
/* Function starts and stops the misc decision window                   */
/*                                                                      */
/* Parameters: decision window start/stop code                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_misc_decision(int code, int action)
{
  _kernel_oserror        *er;

  if (code == DecideAction_Start)
  {
    if (cancel_misc() != FALSE)
    {
      er = ui_decide_window("OptCancel_Title", "Opt_YesNo_1", "Opt_YesNo_0",  "OptCancel_Message", NULL, NULL,
                             "decide_0", runes_misc_decision, 0);
      misc_error_check(er);
    }
    else
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1", "OptSystem_SK2",
      	  		"OptSystem_SK3", "OptSystem_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
  }
  else
  {
    /* If 'Yes' has been pressed */
    if (action == 1)
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1", "OptSystem_SK2",
      			"OptSystem_SK3", "OptSystem_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
    /* If 'No' has been pressed */
    else
    {
      er = ui_open_window(3, OptMisc_WindowHandle, "OptMisc_Title", "OptMisc_SK1", "OptMisc_SK2", "OptMisc_SK3",
                          "OptMisc_SK4", -1);
      misc_error_check(er);
    }
  }
}

/************************************************************************/
/* runes_log_decision                                                   */
/*                                                                      */
/* Function starts and stops the log decision window                    */
/*                                                                      */
/* Parameters: decision window start/stop code                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void runes_log_decision(int code, int action)
{
  _kernel_oserror        *er;

  if (code == DecideAction_Start)
  {
    if (cancel_log() != FALSE)
    {
      er = ui_decide_window("OptCancel_Title", "Opt_YesNo_1", "Opt_YesNo_0",  "OptCancel_Message", NULL, NULL,
                             "decide_0", runes_log_decision, 0);
      misc_error_check(er);
    }
    else
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1", "OptSystem_SK2",
      	  		"OptSystem_SK3", "OptSystem_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
  }
  else
  {
    /* If 'Yes' has been pressed */
    if (action == 1)
    {
      if (back_choice == 1)
      {
        er = ui_open_window(1, OptSys_WindowHandle, "OptSystem_Title", "OptSystem_SK1", "OptSystem_SK2",
      			"OptSystem_SK3", "OptSystem_SK4", -1);
        misc_error_check(er);
      }
      else
      {
        ui_open_other_program_window(Open_Daytona_Home, 0);
      }
    }
    /* If 'No' has been pressed */
    else
    {
      er = ui_open_window(3, OptLog_WindowHandle, "OptLog_Title", "OptLog_SK1", "OptLog_SK2", "OptLog_SK3",
                          "OptLog_SK4", -1);
      misc_error_check(er);
    }
  }
}
