/* File:    tokenmsg.c++
 * Purpose: Processing and generation of tokenised messages
 * Author:  Ben Laughton
 * History:
 *
 * 1998-02-23: BAL
 * Created.
 */




/* =============================================================================
 * Include header files
 */

/* CLib */
#include "kernel.h"
#include <stdio.h>
#include <string.h>

// Email library
#include "Email/EmailLib/from.h"


// Netfax specific libraries
#include "NetFax/NFELib/NFELib.h"


/* Daytona */
#include "emailrx.h"
#include "list.h"

#include "tboxlibs/toolbox.h"


/* =============================================================================
 * Define contants
 */

typedef enum
{
    Token_Type,
    Token_DateSent,
    Token_DateProcessed,
    Token_From,
    Token_Pages
} token_t;

typedef enum
{
    Token_Type_MissingPages,
    Token_Type_PrintedPages
} token_type_t;




/* =============================================================================
 * Define types
 */


typedef struct
{
    token_t  token;
    union
    {
        char *        text;
        token_type_t  type;
    } value;
} token_value_pair_t;

typedef struct
{
    token_t  token;
    char *   token_text;
    int      (*process_value) (token_value_pair_t *const,
                               char *);
} token_map_t;




/* =============================================================================
 * Define macros
 */




/* =============================================================================
 * Declare function prototypes
 */

static int read_tokens (FILE *const  file,
                        list_handle  list);

static char *generate_report (list_handle  list);

static char *generate_report_from_message (char *  message_token,
                                           char *  param0,
                                           char *  param1,
                                           char *  param2,
                                           char *  param3);

static char *extract_token_value (list_handle  list,
                                  token_t      token);



static int read_token_value_pair_len (FILE *const    file,
                                      size_t *const  token_len,
                                      size_t *const  value_len);

static token_t token_from_token_text (const char *const  token_text);

static int read_token_value_pair (FILE *const    file,
                                  char *const    token,
                                  char *const    value);

static int match_token (const void *const  list_item,
                        const void *const  search_item);

static void free_token_list_item (void *  client_data);

static int process_type_value (token_value_pair_t *const  token_value_pair,
                               char *                     value);

static int process_from_value (token_value_pair_t *const  token_value_pair,
                               char *                     value);

static int process_text_value (token_value_pair_t *const  token_value_pair,
                               char *                     value);

static int find_start_of_tokens (FILE *const  file);

static int match_string (FILE *  file,
                         char *  string);

static int skip_line (FILE *const  file);





/* =============================================================================
 * Declare global variables
 */

static token_map_t  g_token_map[] =
{
    { Token_Type,          "TYPE",          process_type_value },
    { Token_DateSent,      "DATESENT",      process_text_value },
    { Token_DateProcessed, "DATEPROCESSED", process_text_value },
    { Token_From,          "FROM",          process_from_value },
    { Token_Pages,         "PAGES",         process_text_value }
};




/* =============================================================================
 * Define functions
 */

/* -----------------------------------------------------------------------------
+
   tokenmsg_parse_message

   Parse a message to see if it is tokenised.  If it is then generate an
   appropriate human-readable version of the tokenised message; if not then
   just output the message in tokenised form.

   Inputs
   input_filename:  filename of the tokenised message
   output_filename: name of output file

   Returns
   0: success
   -1: failure
-
 */

extern "C" int tokenmsg_parse_message (const char *const  input_filename,
                                       const char *const  output_filename)
{
    char *       report;
    FILE *       file;
    list_handle  token_list;

    file = fopen (input_filename,
                  "r");
    if (file == NULL)
    {
        return -1;
    }


    if (!find_start_of_tokens (file) == -1)
    {
        return -1;
    }

    token_list = list_create (free_token_list_item);
    if (token_list == NULL)
    {
        return -1;
    }

    read_tokens (file,
                 token_list);

    fclose (file);

    report = generate_report (token_list);
    if (report == NULL)
    {
        return -1;
    }

    file = fopen (output_filename,
                  "w");
    if (file == NULL)
    {
        free (report);
        return -1;
    }


    int error;

    error = fputs (report,
                   file);

    free (report);
    fclose (file);


    if (error == EOF)
    {
        return -1;
    }
    return 0;
}




/* -----------------------------------------------------------------------------
+
   read_tokens

   Read pairs of tokens and values from a file and place them in an ordered
   list.

   Inputs
   file: file descriptor of file to read from
   list: list to place results in

   Returns
   success: 0
   failure: 1
-
 */

static int read_tokens (FILE *const  file,
                        list_handle  list)
{
    char *                token;
    char *                value;
    size_t                token_len;
    size_t                value_len;
    token_value_pair_t *  token_value_pair;


    do
    {
        if (read_token_value_pair_len (file,
                                       &token_len,
                                       &value_len) == -1)
        {
            return -1;
        }

        token = malloc (token_len + 1);    /* +1 for terminator */
        if (token == NULL)
        {
            return -1;
        }


        value = malloc (value_len + 1);   /* +1 for terminator */
        if (value == NULL)
        {
            free (token);
            return -1;
        }


        if (read_token_value_pair (file,
                                   token,
                                   value) == -1)
        {
            free (token);
            free (value);
            return -1;
        }

        (void) skip_line (file);

        token_value_pair =
            (token_value_pair_t *) malloc (sizeof (token_value_pair_t));
        if (token_value_pair == NULL)
        {
            free (token);
            free (value);
            return 1;
        }

        token_value_pair->token = token_from_token_text (token);

        free (token);

        /* Skip unrecognised tokens */
        if (token_value_pair->token != -1)
        {
            if (g_token_map[token_value_pair->token].process_value (
                    token_value_pair,
                    value) != 0)
            {
                free (value);
                return 1;
            }

            list_add_item (list,
                           token_value_pair);
        }
    }
    while (!feof (file));

    return 0;
}




/* -----------------------------------------------------------------------------
+
   generate_report

   Generate a human-readable report from a token list.

   Inputs
   list: list of token-value pairs

   Returns
   success: pointer to report - client's reponsiblility to free
   failure: NULL
-
 */

static char *generate_report (list_handle  list)
{
    char *                date_sent;
    char *                date_processed;
    char *                from;
    char *                pages;
    char *                report;
    token_t               token;
    token_value_pair_t *  token_value_pair;


    token = Token_Type;

    token_value_pair = (token_value_pair_t *) list_find_item (list,
                                                              match_token,
                                                              &token);
    if (token_value_pair == NULL)
    {
        return NULL;
    }

    /* Extract necessary information from list */
    date_sent = extract_token_value (list,
                                     Token_DateSent);
    if (date_sent == NULL)
    {
        return NULL;
    }

    date_processed = extract_token_value (list,
                                          Token_DateProcessed);
    if (date_processed == NULL)
    {
        return NULL;
    }

    from = extract_token_value (list,
                                Token_From);
    if (from == NULL)
    {
        return NULL;
    }

    pages = extract_token_value (list,
                                 Token_Pages);

    switch (token_value_pair->value.type)
    {
        case Token_Type_MissingPages:
            if (pages)
            {
                report = emailrx_generate_report_from_message ("MissingPageR",
                                                               date_sent,
                                                               from,
                                                               pages,
                                                               date_processed);
            }
            else
            {
                report = NULL;
            }
            break;

        case Token_Type_PrintedPages:
            if (pages)
            {
                report = emailrx_generate_report_from_message ("PrintedPageF",
                                                               pages,
                                                               date_sent,
                                                               from,
                                                               date_processed);
            }
            else
            {
                report = emailrx_generate_report_from_message ("PrintedPageO",
                                                               date_sent,
                                                               from,
                                                               date_processed,
                                                               NULL);
            }

            break;

        default:
            return NULL;
    }

    return report;
}




/* -----------------------------------------------------------------------------
+
   extract_token_value

   Lookup the item the list with the given token and return its corresponding
   value.

   Inputs
   list:  list to look up token in
   token: token to look up

   Returns
   success: pointer to value
   failure: NULL
-
 */

static char *extract_token_value (list_handle  list,
                                  token_t      token)
{
    token_value_pair_t *  token_value_pair;


    token_value_pair = (token_value_pair_t *) list_find_item (list,
                                                              match_token,
                                                              &token);
    if (token_value_pair == NULL)
    {
        return NULL;
    }

    return token_value_pair->value.text;
}




/* -----------------------------------------------------------------------------
+
   read_token_value_pair_len

   Find the lengths of a token-value pair from a file.  The file position is
   cached on entry and restored on exit (unless an error occurs).

   Inputs
   file: file descriptor of file to read from
   token_len: length of token (not including terminator)
   value_len: length of value (not including terminator)

   Returns
   success: 0
   failure: -1
-
 */

static int read_token_value_pair_len (FILE *const    file,
                                      size_t *const  token_len,
                                      size_t *const  value_len)
{
    int     number_read;
    fpos_t  line_start;


    fgetpos (file,
             &line_start);

    number_read = fscanf (file,
                          "%*[^=\r\n\t ]%n=%*[^\r\n\t]%n",
                          token_len,
                          value_len);
    if (number_read != 0)
    {
        return -1;
    }

    *value_len -= *token_len - 1;    /* -1 for '=' */

    fsetpos (file,
             &line_start);

    return 0;
}




/* -----------------------------------------------------------------------------
+
   token_from_token_text

   Find the value used to represent a token given the text used to represent
   the token.

   Inputs
   token_text: text used to represent token

   Returns
   success: token value
   failure: -1
-
 */

static token_t token_from_token_text (const char *const  token_text)
{
    int  i;
    int  number_tokens = sizeof (g_token_map) / sizeof (*g_token_map);


    for (i = 0; i < number_tokens; ++i)
    {
        if (strcmp (g_token_map[i].token_text,
                    token_text) == 0)
        {
            return (token_t) i;
        }
    }

    return (token_t) -1;
}




/* -----------------------------------------------------------------------------
+
   read_token_value_pair

   Read a token-value pair from a file into the supplied strings.

   Inputs
   file:  file descriptor of file to read from
   token: pointer to string long enough to store 0-terminated token
   value: pointer to string long enough to store 0-terminated value

   Returns
   success: 0
   failure: -1
-
 */

static int read_token_value_pair (FILE *const    file,
                                  char *const    token,
                                  char *const    value)
{
    int  number_read;


    number_read = fscanf (file,
                          "%[^=\r\n\t ]=%[^\r\n\t]",
                          token,
                          value);
    if (number_read != 2)
    {
        return -1;
    }

    return 0;
}




/* -----------------------------------------------------------------------------
+
   match_token

   Attempt to match a token with an item in a token-value pair list.

   Inputs
   list_item:   item in list to attempt match with
   search_item: token being searched for

   Returns
   0: no match
   1: match
-
 */

static int match_token (const void *const  list_item,
                        const void *const  search_item)
{
    const token_t                    token            =
       *((token_t *) search_item);
    const token_value_pair_t *const  token_value_pair =
        (const token_value_pair_t *const) list_item;

    return (token == token_value_pair->token);
}




/* -----------------------------------------------------------------------------
+
   free_token_list_item

   Free the memory allocated for an item in a list of token-value pairs.

   Inputs
   client_data: pointer to token-value pair to free
-
 */

static void free_token_list_item (void *  client_data)
{
    token_value_pair_t *token_value_pair = (token_value_pair_t *) client_data;

    if (token_value_pair->token != Token_Type)
    {
        free (token_value_pair->value.text);
    }
    free (token_value_pair);
}




/* -----------------------------------------------------------------------------
+
   process_type_value

   Process the value for the 'type' token.

   Inputs
   token_value_pair: pointer to token-value pair structure to fill in
   value:            text value read from file

   Returns
   -1: invalid value for this token
    0: success
-
 */

static int process_type_value (token_value_pair_t *const  token_value_pair,
                               char *                     value)
{
    if (strcmp (value, "PRINTEDPAGES") == 0)
    {
        token_value_pair->value.type = Token_Type_PrintedPages;
    }
    else if (strcmp (value, "MISSINGPAGES") == 0)
    {
        token_value_pair->value.type = Token_Type_MissingPages;
    }
    else
    {
        return -1;   /* invalid type */
    }

    free (value);
    return 0;
}




/* -----------------------------------------------------------------------------
+
   process_from_value

   Process the value for the 'from' token.  Needs to check if the from
   address will have a '<' in it, and if so escape it with '|' so that the
   from address canbe used with GSTrans.

   Inputs
   token_value_pair: pointer to token-value pair structure to fill in
   value:            text value read from file

   Returns
   -1: failure
    0: success
-
 */
static int process_from_value (token_value_pair_t *const  token_value_pair,
                               char *                     value)
{
    size_t       value_size = strlen (value) + 1;

    // Use the email library to parse the from address
    from  from_header (FALSE,
                       NULL,
                       0,
                       0,
                       TRUE);

    NFE_CONTEXT  context;
    NFE_rcode    rc;

    rc = from_header.SetBody (value);
    if (rc != NFE_COMPLETED)
    {
        return -1;
    }

    rc = from_header.ParseData (context,
                                0);
    if (rc != NFE_COMPLETED)
    {
        return -1;
    }


    NFE_address  from_address;

    // For the moment allocate more that enough space for the address and
    // real name because the 'from' class' methods don't work quite as they
    // should.
    from_address.address = malloc (value_size);
    if (from_address.address == NULL)
    {
        return -1;
    }
    from_address.real_name = malloc (value_size);
    if (from_address.real_name == NULL)
    {
        free (from_address.address);
        return -1;
    }

    size_t     value_len = value_size - 1;

    rc = from_header.GetAddress (from_address.address,
                                 value_len);
    if (rc != NFE_COMPLETED)
    {
        free (from_address.address);
        free (from_address.real_name);
        return -1;
    }

    rc = from_header.GetRealName (from_address.real_name,
                                  value_len);
    if (rc != NFE_COMPLETED)
    {
        free (from_address.address);
        free (from_address.real_name);
        return -1;
    }

    // Convert the from address back into a single string, suitable for
    // GSTrans.
    if (*from_address.real_name == '\0')
    {
        free (from_address.real_name);
        from_address.real_name = NULL;
    }

    token_value_pair->value.text = emailrx_construct_full_address (
                                       &from_address,
                                       1);
    free (value);

    return 0;
}




/* -----------------------------------------------------------------------------
+
   process_text_value

   Process the value for any token whose value is just stored as plain text

   Inputs
   token_value_pair: pointer to token-value pair structure to fill in
   value:            text value read from file

   Returns
   0 (always succeedes)
-
 */

static int process_text_value (token_value_pair_t *const  token_value_pair,
                               char *                     value)
{
    token_value_pair->value.text = value;
    return 0;
}




/* -----------------------------------------------------------------------------
+
   find_start_of_tokens

   Find the start of the next block of tokens in a file.  The file position is
   advanced to the start of the next line.

   Inputs
   file: file descriptor of file to search in

   Returns
   failure: -1
   success: 0
-
 */

static int find_start_of_tokens (FILE *const  file)
{
    int match;

    do
    {
        match = match_string (file,
                              "[TOKENISED]");
        switch (match)
        {
            case -1:
                return -1;

            default:
                if (skip_line (file) == EOF)
                {
                    return -1;
                }
                break;
        }
    }
    while (match != 1);

    return 0;
}




/* -----------------------------------------------------------------------------
+
   match_string

   Check if a given string appears at the current position in a file.

   Inputs
   file:   file descriptor of file to search
   string: string to look for in file

   Returns
   -1: EOF or file error
    0: no match
    1: match
-
 */

static int match_string (FILE *  file,
                         char *  string)
{
    char *  string_char = string;
    int     file_char;


    do
    {
        file_char = fgetc (file);
        if (file_char == EOF)
        {
            return -1;
        }

        if (*string_char != file_char)
        {
            if (file_char == '\n' || file_char == '\r')
            {
                if (ungetc (file_char,
                            file) == EOF)
                {
                    return -1;
                }
            }

            return 0;
        }

        ++string_char;

    }
    while (*string_char != '\0');

    return 1;
}




/* -----------------------------------------------------------------------------
+
   skip_line

   Skip to the start of the next line in a file.  Copes with any type of line
   ending (ie. CR, LF, CR & LF, LF & CR).

   Inputs
   file: file descriptor

   Returns
   success: 0
   failure: -1
-
 */

static int skip_line (FILE *const  file)
{
    int  file_char1;
    int  file_char2;


    /* Find first character in newline sequence */
    do
    {
        file_char1 = fgetc (file);
        if (file_char1 == EOF)
        {
            return -1;
        }
    }
    while (file_char1 != '\n' && file_char1 != '\r');


    /* Read next character to test if it's a multi-character newline sequence */
    file_char2 = fgetc (file);
    if (file_char2 == EOF)
    {
        return -1;
    }


    if ((file_char1 == '\r' && file_char2 != '\n') ||
        (file_char1 == '\n' && file_char2 != '\r'))
    {
        /* Single charcter line ending.  'Undo' the read of the second
         * character.
         */
        if (ungetc (file_char2,
                    file) == EOF)
        {
            return -1;
        }
    }

    return 0;
}
