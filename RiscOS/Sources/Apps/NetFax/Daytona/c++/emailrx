/* File:    emailrx.c++
 * Purpose: Daytona email receive
 * Author:  Ben Laughton
 * History:
 *
 * 1997-10-20: BAL
 * Created.
 *
 * 1998-02-25: BAL
 * Split up missing page report detection and generation.
 * Added printed page report (A.K.A. return-receipt, delivery confirmation)
 *
 * 1998-03-03: BAL
 * Corrected 'success' return code in
 * netfax_fax_document_t::printed_page_report (from 1 to 0).
 *
 * 1998-03-04: BAL
 * There was some confusion in the spec. about the significance of document
 * numbers in Netfax messages with no fax pages (eg. CAS, ENote etc.),
 * highlighted by the fact that adding a new message to the document list would
 * go wrong sometimes.  This has been resolved and emailrx_new_message has
 * been changed to check if the message being added is part of an
 * existing document *only* when the message being added contains fax pages.
 * Otherwise it is treated as an entirely separate document.
 *
 * 1998-04-01: BAL
 * Bug fix: number_pages_remaining in a document was being set incorrectly -
 * it was being initialised to the number of pages reported in the first message
 * seen for a document as well as being incremented on each new page encountered
 * (so it would typically end up double what it should be).  It is now
 * initialised to zero.  The only effect this had was a small memory leak.
 *
 * 1998-04-02: BAL
 * Fixed problem in addition of new messages: now checks if message is
 * already in document list before trying to add it.  In cases where only part
 * of the mailbox was downloaded in a session, remaining messages would be added
 * again in the next session.
 *
 * number_pages_remaining corrected again.  Used to only be incremented if
 * message had never been seen before.  It is now always incremented when a
 * message is added to the document list, even if that message has been seen
 * before.
 */




/* =============================================================================
 * Include header files
 */

/* CLib */
#include <assert.h>
#include "kernel.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "swis.h"

// Email
#include "Email/EmailLib/date.h"

/* NetFax specific libraries */
#include "NetFax/NFELib/NFELib.h"

/* Daytona */
#include "emailrx.h"
#include "list.h"
#include "SetupIF.h"

/* Toolbox */
#include "tboxlibs/toolbox.h"


/* =============================================================================
 * Define constants
 */

#define PartialDownloadLines    56
#define MaxParamSize            81
#define MaxReportSize         4096
#define MessageBufferSize     1024
#define ReportsPath           ("Daytona:Reports")




/* =============================================================================
 * Define macros
 */

#define M_unused(a) (void) (a)




/* =============================================================================
 * Define types
 */

enum bool
{
    false,
    true
};

/* Can't use an enum for this because Iwant it to be char to hopefully save
 * space when its used for arrays.
 */
typedef char  page_state;
enum
{
    PageState_Unseen,
    PageState_Seen
};

struct netfax_document_id
{
    unsigned int  device_class;
    unsigned int  document_number;
    char          serial_num[SERIAL_LEN];
};

class document_t
{
    // Methods
    public:
        document_t (const NFE_header &  header,
                    bool &              success);

        document_t (const document_t &  document,
                    bool &              success);

        ~document_t (void);

        virtual document_t *copy (void);

        virtual int operator== (const netfax_document_id &) const
            { return 0; }

        virtual message_t *add_message (const unsigned int      size,
                                        const char *const       unique_id,
                                        const NFE_message_id &  nf_message_id);

        virtual message_t *add_message (
                               const unsigned int      size,
                               const char *const       unique_id,
                               const NFE_message_id &  nf_message_id,
                               bool &                  delete_message);

        virtual void remove_message (const message_t &  message);

        list_item_handle add_to_list (list_handle list);

        void remove_from_list (list_handle list);

        virtual int add_to_download (list_handle   download_list,
                                     unsigned int  &free_space,
                                     unsigned int  &largest_message);

        list_handle get_message_list (void);

        virtual int get_number_messages (void);

        virtual int need_missing_page_report (void)
        {
            return 0;
        }

        virtual char *  generate_missing_page_report (
            char *const         remote_report_filename,
            const NFE_header &  header)
        {
            M_unused (remote_report_filename);
            M_unused (header);

            return NULL;
        }

        virtual int printed_page_report (FILE *const         file,
                                         const NFE_header &  header);

        virtual int cover_sheet (char *const         report,
                                 size_t              report_size,
                                 const NFE_header &  header);

#ifdef TEST
        virtual void  dump_to_file (FILE *const  file);

        virtual void  dump_message_list_to_file (FILE *const  file);
#endif

    // Data
    protected:
        list_item_handle  item_handle;
        unsigned int      document_size;
        list_handle       message_list;
        NFE_msg_class     message_class;
};

class netfax_document_t : public document_t
{
    // Methods
    public:
        netfax_document_t (const NFE_header &  header,
                           bool &              success);

        netfax_document_t (const netfax_document_t &  document,
                           bool &                     success);

        virtual document_t *copy (void);

        int operator== (const netfax_document_id &  id) const;

        virtual message_t *add_message (const unsigned int      size,
                                        const char *const       unique_id,
                                        const NFE_message_id &  nf_message_id);

        virtual message_t *add_message (
                               const unsigned int      size,
                               const char *const       unique_id,
                               const NFE_message_id &  nf_message_id,
                               bool &                  delete_message);

#ifdef TEST
        virtual void  dump_to_file (FILE *const  file);
#endif

    // Data
    protected:
        netfax_document_id  document_id;
        NFE_NF_msg_class    netfax_message_class;
};

class netfax_fax_document_t : public netfax_document_t
{
    // Methods
    public:
        netfax_fax_document_t (const NFE_header &  header,
                               bool &              success);

        netfax_fax_document_t (const netfax_fax_document_t &  document,
                               bool &                         success);

        virtual document_t *copy (void);

        virtual message_t *add_message (const unsigned int      size,
                                        const char *const       unique_id,
                                        const NFE_message_id &  nf_message_id);

        virtual message_t *add_message (
                               const unsigned int      size,
                               const char *const       unique_id,
                               const NFE_message_id &  nf_message_id,
                               bool &                  delete_message);

        void remove_message (const message_t &  message);

        int add_to_download (list_handle   download_list,
                             unsigned int  &free_space,
                             unsigned int  &largest_message);

        int get_number_messages (void);

        int need_missing_page_report (void)
        {
            return (connection_count > g_missing_page_threshold);
        }

        char *  generate_missing_page_report (
                    char *const         remote_report_filename,
                    const NFE_header &  header);

        int printed_page_report (FILE *const         file,
                                 const NFE_header &  header);

        int cover_sheet (char *const         report,
                         size_t              report_size,
                         const NFE_header &  header);

#ifdef TEST
        virtual void  dump_to_file (FILE *const  file);
#endif

    private:
        int page_range_report (char *const         report,
                               size_t              report_size,
                               const NFE_header &  header);

        int document_size_confirmation (char *const         report,
                                        size_t              report_size,
                                        const NFE_header &  header);

        void page_range (unsigned int &  first_page,
                         unsigned int &  last_page);

        int page_list (const page_state  page_list_seen_state,
                       char *const       string,
                       size_t            max_len);

    // Data
    protected:
        struct
        {
            bool  split_download     : 1;
            bool  exact_number_pages : 1;
        } flags;

        unsigned int  number_messages;
        unsigned int  connection_count;
        unsigned int  total_number_pages;
        unsigned int  number_pages;    // number pages seen so far
        unsigned int  number_pages_remaining;
        page_state *  page_seen;
};




/* =============================================================================
 * Declare global variables
 */

MessagesFD*         report_templates = NULL;

static list_handle  document_list;




/* =============================================================================
 * Declare function prototypes
 */

static document_t *create_doc (const NFE_header &  header);

static int match_doc (void *const  data1,
                      void *const  data2);

static int match_message (void *const  data1,
                          void *const  data2);

static int compare_page_nums (void *const  data1,
                              void *const  data2);

static void free_document (void *  document);

static void free_message (void *  message);

static int truncate_doc_list (void);

static bool check_free_space (const unsigned int  message_size,
                              const unsigned int  free_space,
                              const unsigned int  largest_message);

static void update_free_space (const unsigned int  message_size,
                               unsigned int &      free_space,
                               unsigned int &      largest_message);

static message_t *add_message_common (const unsigned int  size,
                                      const char *const   unique_id);




/* =============================================================================
 * Class method implementations
 */

document_t::document_t (const NFE_header  &header,
                        bool              &success)
{
    success = true;

    item_handle   = NULL;
    document_size = 0;
    message_class = header.msg_class;

    // Create empty list of messages for this document
    message_list = list_create (free_message);
    if (message_list == NULL)    // list creation failed
        success = false;
}




document_t::document_t (const document_t  &document,
                        bool              &success)
{
    success = true;

    item_handle = NULL;
    document_size = document.document_size;
    message_class = document.message_class;

    // Create empty list of messages for this document
    message_list = list_create (free_message);
    if (message_list == NULL)    // list creation failed
        success = false;
}




document_t::~document_t (void)
{
    list_destroy (message_list);
}




document_t *document_t::copy (void)
{
    bool  success;

    document_t *new_document = new document_t (*this,
                                               success);

    if (new_document && !success)
    {
        delete new_document;
        new_document = NULL;
    }

    return new_document;
}




list_item_handle document_t::add_to_list (list_handle list)
{
    item_handle = list_add_item (list,
                                 this);

    return item_handle;
}




void document_t::remove_from_list (list_handle list)
{
    list_remove_item (list,
                      this->item_handle);

    // Can you delete an object from within one of its member functions?
    delete this;
}




message_t *document_t::add_message (
               const unsigned int    size,
               const char *const     unique_id,
               const NFE_message_id  &nf_message_id)
{
    M_unused (nf_message_id);

    // Create new message information structure
    message_t *  message = add_message_common (size,
                                               unique_id);
    if (message == NULL)
        return NULL;


    // Unknown messages and SMTP error reports (which is what is being dealt
    // with here) do not have netfax message ids, so set the netfax message id
    // to a sensible blank value.
    message->nf_message_id.first_page_num  = 0;
    message->nf_message_id.last_page_num   = 0;
    message->nf_message_id.doc_num         = 0;
    message->nf_message_id.msg_num_pages   = 0;
    message->nf_message_id.exact_num_pages = TRUE;
    message->nf_message_id.iap_username    = NULL;

    message->lines              = PartialDownloadLines;
    message->flags              = MessageFlags_PartialDownload;

    // Add message to document's message list.  For these types of message
    // there is only ever one message per document.
    list_item_handle message_item_handle = list_add_item (message_list,
                                                          message);
    if (message_item_handle == NULL)
    {
        free (message->unique_id);
        free (message);
        return NULL;
    }
    message->item_handle = message_item_handle;

    document_size   = size;

    return message;
}




message_t *document_t::add_message (
               const unsigned int      size,
               const char *const       unique_id,
               const NFE_message_id &  nf_message_id,
               bool &                  delete_message)
{
    delete_message = false;

    return add_message (size,
                        unique_id,
                        nf_message_id);
}




void document_t::remove_message (const message_t &message)
{
    list_remove_item (message_list,
                      message.item_handle);
    document_size -= message.size;
}




int document_t::add_to_download (list_handle   download_list,
                                 unsigned int  &free_space,
                                 unsigned int  &largest_message)
{
    // Only one message per document for all documents except netfax fax
    // documents
    message_t *  message = (message_t *) list_head (message_list);

    if (check_free_space (message->size,
                          free_space,
                          largest_message))
    {
        document_t *download_document = copy ();
        if (download_document == NULL ||
            download_document->add_to_list (download_list) == NULL)
        {
            return -1;    // fatal error, out of memory
        }


        if (download_document->add_message (
                message->size,
                message->unique_id,
                message->nf_message_id) == NULL)
        {
            return 1;    // fatal error, out of memory
        }

        remove_message (*message);

        update_free_space (message->size,
                           free_space,
                           largest_message);

        remove_from_list (document_list);
    }

    // added document successfully: continue building download list
    return 0;
}




list_handle document_t::get_message_list (void)
{
    return message_list;
}




int document_t::get_number_messages (void)
{
    // All documents have at most 1 message, except for netfax fax documents

    if (list_head (message_list) == NULL)
        return 0;
    else
        return 1;
}




/* -----------------------------------------------------------------------------
+
   document_t::printed_page_report

   Generate tokens for printed page reports that are common to all types of
   document.

   Inputs
   filename: file in which to dump printed 'page' report
   header:   header for email message being printed

   Returns
   success: 0
   failure: -1
-
 */

int document_t::printed_page_report (FILE *const         file,
                                     const NFE_header &  header)
{
    NFE_address  from_address;

    if (*setup_from_mailaddress == '\0')
    {
        return -1;
    }
    from_address.address = setup_from_mailaddress;

    if (*setup_contact_name == '\0')
    {
        from_address.real_name = NULL;
    }
    else
    {
        from_address.real_name = setup_contact_name;
    }

    char *raw_from_address = emailrx_construct_full_address (&from_address,
                                                             0);
    if (raw_from_address == NULL)
    {
        return -1;
    }

    char *     raw_date;
    size_t     date_len;
    NFE_rcode  rc;
    date       date_processed (FALSE,
                               NULL,
                               0,
                               0,
                               TRUE);
    rc = date_processed.GetBodyLen (date_len);
    if (rc != NFE_COMPLETED)
    {
        free (raw_from_address);
        return -1;
    }

    raw_date = malloc (date_len + 2);
    if (raw_date == NULL)
    {
        free (raw_from_address);
        return -1;
    }

    ++date_len;
    rc = date_processed.GetUnfoldedBody (raw_date,
                                         date_len);
    if (rc != NFE_COMPLETED)
    {
        free (raw_date);
        free (raw_from_address);
        return -1;
    }

    int file_rc;

    file_rc = fprintf (file,
                       "TYPE=PRINTEDPAGES\n"
                       "DATESENT=%s\n"
                       "FROM=%s\n"
                       "DATEPROCESSED=%s\n",
                       header.date_hdr,
                       raw_from_address,
                       raw_date);

    free (raw_from_address);
    free (raw_date);
    if (file_rc < 0)
    {
        return -1;
    }


    return 0;
}




int document_t::cover_sheet (char *const         report,
                             size_t              report_size,
                             const NFE_header &  header)
{
    // No concept of pages for all documents except netfax fax documents so
    // impossible to ever have a cover sheet

    M_unused (report);
    M_unused (report_size);
    M_unused (header);

    return 0;
}




netfax_document_t::netfax_document_t (const NFE_header &  header,
                                      bool &              success)
    : document_t (header,
                  success)
{
    memcpy (document_id.serial_num,
            header.details.serial_num,
            SERIAL_LEN);

    document_id.device_class    = header.details.device_class;
    document_id.document_number = header.id.doc_num;

    netfax_message_class        = header.netfax_msg_class;
}




netfax_document_t::netfax_document_t (const netfax_document_t &  document,
                                      bool &                     success)
    : document_t (document,
                  success)
{
    memcpy (document_id.serial_num,
            document.document_id.serial_num,
            SERIAL_LEN);

    document_id.device_class    = document.document_id.device_class;
    document_id.document_number = document.document_id.document_number;

    netfax_message_class        = document.netfax_message_class;
}




document_t *netfax_document_t::copy (void)
{
    bool  success;

    netfax_document_t *new_document =
        new netfax_document_t ((netfax_document_t &) *this,
                               success);

    if (new_document && !success)
    {
        delete new_document;
        new_document = NULL;
    }

    return new_document;
}




int netfax_document_t::operator== (const netfax_document_id &  id) const
{
    return (document_id.device_class == id.device_class &&
            document_id.document_number == id.document_number &&
            memcmp (document_id.serial_num,
                    id.serial_num,
                    SERIAL_LEN) == 0);
}




message_t *netfax_document_t::add_message (
               const unsigned int    size,
               const char *const     unique_id,
               const NFE_message_id  &nf_message_id)
{
    // Create new message information structure
    message_t *  message = add_message_common (size,
                                               unique_id);
    if (message == NULL)
        return NULL;


    // All types of netfax messages must always have meaningful information in
    // the netfax message id, so just copy the netfax message id.
    message->nf_message_id = nf_message_id;

    message->flags = 0;

    // Add message to document's message list.  There is no concept of pages
    // or ordering for these netfax message classes so just add the message
    // to the end of the document's message list.
    list_item_handle message_item_handle = list_add_item (message_list,
                                                          message);
    if (message_item_handle == NULL)
    {
        free (message->unique_id);
        free (message);
        return NULL;
    }
    message->item_handle = message_item_handle;

    document_size   += size;

    return message;
}




message_t *netfax_document_t::add_message (
               const unsigned int      size,
               const char *const       unique_id,
               const NFE_message_id &  nf_message_id,
               bool &                  delete_message)
{
    delete_message = false;

    return add_message (size,
                        unique_id,
                        nf_message_id);
}




netfax_fax_document_t::netfax_fax_document_t (const NFE_header &  header,
                                              bool &              success)
    : netfax_document_t (header,
                         success)
{
    flags.split_download     = false;
    flags.exact_number_pages = (bool) header.id.exact_num_pages;

    number_messages        = 0;
    connection_count       = 0;
    total_number_pages     = 0;
    number_pages           = 0;
//     number_pages_remaining = header.id.msg_num_pages;
    number_pages_remaining = 0;
    page_seen              = NULL;
}




netfax_fax_document_t::netfax_fax_document_t (
    const netfax_fax_document_t &  document,
    bool                        &  success)
    : netfax_document_t (document,
                         success)
{
    flags                  = document.flags;
    number_messages        = 0;
    connection_count       = document.connection_count;
    total_number_pages     = 0;
    number_pages           = 0;
    number_pages_remaining = document.number_pages_remaining;
    page_seen              = NULL;
}




document_t *netfax_fax_document_t::copy (void)
{
    bool  success;

    netfax_fax_document_t *new_document =
        new netfax_fax_document_t ((netfax_fax_document_t &) *this,
                                   success);

    if (new_document && !success)
    {
        delete new_document;
        new_document = NULL;
    }

    return new_document;
}




message_t *netfax_fax_document_t::add_message (
               const unsigned int      size,
               const char *const       unique_id,
               const NFE_message_id &  nf_message_id)
{
    bool  delete_message;


    return add_message (size,
                        unique_id,
                        nf_message_id,
                        delete_message);
}




message_t *netfax_fax_document_t::add_message (
               const unsigned int      size,
               const char *const       unique_id,
               const NFE_message_id &  nf_message_id,
               bool &                  delete_message)
{
    message_t *  message;

    delete_message = false;

    // Don't want to actually add message to this document's message list if
    // the message is a dcs.
    if (nf_message_id.first_page_num != 0 && nf_message_id.last_page_num != 0)
    {
        // Create new message information structure
        message = add_message_common (size,
                                      unique_id);
        if (message == NULL)
        {
            goto no_mem;
        }


        // All types of netfax messages must always have meaningful information
        // in the netfax message id, so just copy the netfax message id.
        message->nf_message_id = nf_message_id;

        message->flags = 0;

        // Add message to document's message list.  Fax messages must be ordered
        // by page number
        list_item_handle message_item_handle =
            list_add_item_ordered (message_list,
                                   message,
                                   compare_page_nums);
        if (message_item_handle == NULL)
        {
            goto no_mem;
        }

        message->item_handle = message_item_handle;

        // Added message to document's message list successfully -
        // can now update document information.
        document_size   += size;
        number_messages += 1;
    }
    else
    {
        delete_message = true;
    }


    // msg_num_pages is actually the (minimum) number of pages in the
    // whole document so although this section of code below may look
    // strange, it is in fact alright.
    //
    // For documents which do not have an exact known number of pages,
    // subsequent messages may increase (but never decrease) the minimum
    // number of pages.

    if (nf_message_id.msg_num_pages > total_number_pages)
    {
        page_state *  temp_page_seen;
        unsigned int  delta_number_pages;

        temp_page_seen =
            realloc (page_seen,
                     nf_message_id.msg_num_pages * sizeof (page_seen));

        if (temp_page_seen == NULL)
            goto no_mem;

        page_seen = temp_page_seen;

        for (int i = total_number_pages;
             i < nf_message_id.msg_num_pages;
             i++)
        {
            page_seen[i] = PageState_Unseen;
        }

        delta_number_pages = nf_message_id.msg_num_pages -
                             total_number_pages;

        // number_pages_remaining += delta_number_pages;
        total_number_pages = nf_message_id.msg_num_pages;
    }

    if (nf_message_id.first_page_num == 0 && nf_message_id.last_page_num == 0)
    {
        // Document size confirmation; means that the exact number of pages
        // for this document is now known.
        //
        // This document is flagged as having a D.S.C., but no message is
        // added to the list (we would never want to actually download the
        // complete message as we can get all the info we need from the
        // headers).

        flags.exact_number_pages = true;
    }
    else
    {
        // Be careful when incrementing the number of pages in a document.  It
        // is possible for a message to be added to the document list, selected
        // for download (therefore moved from the document list to the download
        // list), but not actually get processed - ie. when the PrintQ aborts
        // a job before it is complete.  Then the message is seen again on the
        // next connection - it's not in the document list anymore so it's
        // added again, but we have previously taken account of the pages
        // contained in it, so we don't want to add these again.

        for (int i = nf_message_id.first_page_num - 1;
             i < nf_message_id.last_page_num;
             i++)
        {
            if (page_seen[i] == PageState_Unseen)
            {
                page_seen[i] = PageState_Seen;
                ++number_pages;
            }
        }

        number_pages_remaining += (nf_message_id.last_page_num -
                                   nf_message_id.first_page_num) + 1;
    }

    return message;


no_mem:
    if (message)
    {
        if (message->unique_id)
        {
            free (message->unique_id);
        }

        free (message);
    }

    return NULL;
}




void netfax_fax_document_t::remove_message (const message_t &  message)
{
    list_remove_item (message_list,
                      message.item_handle);
    document_size -= message.size;
    --number_messages;
}




int netfax_fax_document_t::add_to_download (list_handle     download_list,
                                            unsigned int &  free_space,
                                            unsigned int &  largest_message)
{
    netfax_fax_document_t *  download_document;

    // Document size confirmation is a special case.
    //
    // The only time that you would want to print one of these out is if
    // you had already downloaded and printed all other parts of this
    // document in a previous session.

    if (flags.exact_number_pages &&
        number_pages_remaining == 0 &&
        number_messages == 0)
    {
        download_document = (netfax_fax_document_t *) copy ();

        if (download_document == NULL ||
            download_document->add_to_list (download_list) == NULL)
        {
            return -1;    // fatal error, out of memory
        }
    }
    else
    {
        list_iterator_t  message_iterator;
        bool             document_created = false;

        // Iterate over the message list for this document, adding as many
        // messages from it to the download list as possible.

        list_initialise_iterator (&message_iterator,
                                  message_list);

        message_t *  message =
            (message_t *) (message_iterator.reset) (&message_iterator);

        while (!(message_iterator.finished) (&message_iterator))
        {
            if (check_free_space (message->size,
                                  free_space,
                                  largest_message))
            {
                if (!document_created)
                {
                    download_document = (netfax_fax_document_t *) copy ();

                    if (download_document == NULL ||
                        download_document->add_to_list (download_list) == NULL)
                    {
                        return -1;    // fatal error, out of memory
                    }

                    document_created = true;
                }

                if (download_document->add_message (
                        message->size,
                        message->unique_id,
                        message->nf_message_id) == NULL)
                {
                    return -1;    // fatal error, out of memory
                }

                // Remove this message from the list of messages for this
                // document in the document list.
                if (number_pages_remaining > 0)
                {
                    number_pages_remaining -=
                        (message->nf_message_id.last_page_num -
                         message->nf_message_id.first_page_num) + 1;
                }

                remove_message (*message);

                update_free_space (message->size,
                                   free_space,
                                   largest_message);
            }
            else
            {
                // There is not enough space to download all messages in
                // this document.
                //
                // 1. If some messages for this document have already been
                // added to the download list then don't add anything more
                // to the download list: just download what we already have,
                // disconnect, then reconnect to get the rest of the
                // document and any others we have space for.
                //
                // 2. If no messages for this document have been added to
                // the download list then just skip the rest of the messages
                // for this document and try to add other documents to the
                // download list (if we didn't do this and there was a
                // really large message on the server then it could prevent
                // any downloads for ages).
                //
                // If we do download part of a document with the intention
                // of getting the rest on the next connection then the
                // document must be flagged to indicate this.  Otherwise for
                // documents that fall into category 1. above,
                // when the second connection happens the rest of the
                // document could appear to fall into category 2. above and
                // we would end up with pyhsically split documents.

                if (document_created || flags.split_download)
                {
                    // not enough space to add this document: don't add anything
                    // else to the download list.
                    download_document->flags.split_download = true;
                    flags.split_download = true;
                    return 1;
                }
                else
                {
                    // skip this document and try the next
                    break;    // break out of enclosing while loop
                }
            }

            message = (message_t *) (message_iterator.next) (&message_iterator);

        }

        // A split download situation also occurs if the number of pages in the
        // part of the document to be downloaded is less than the minimum
        // number of pages known to exist for that document (ie. not all the
        // document has arrived on the server yet).

        if (document_created &&
            (download_document->number_pages < total_number_pages ||
             flags.split_download))
        {
            download_document->flags.split_download = true;
        }
    }

    // If more pages are expected for this document then indicate
    // this by leaving the document in the document list with an
    // empty list of messages.
    if (number_messages == 0)
    {
        if (number_pages_remaining == 0 && flags.exact_number_pages)
        {
            remove_from_list (document_list);
        }
        else
        {
            ++connection_count;
        }
    }

    // added document successfully: continue building download list
    return 0;
}




int netfax_fax_document_t::get_number_messages (void)
{
    return number_messages;
}




/* -----------------------------------------------------------------------------
+
   netfax_fax_document_t::generate_missing_page_report

   Generate a missing page report for a NetFax fax document.

   Currently assumes that there will never be more than 9999 pages in a single
   document.

   Inputs
   document_info:          document handle as returned by document iterator
   remote_report_filename: name of file to write remote report into
   header:                 email header information for this document

   Returns
   success: pointer to local report - client's responsibility to free
   failure: NULL
-
 */

char *  netfax_fax_document_t::generate_missing_page_report (
            char *const         remote_report_filename,
            const NFE_header &  header)
{
    char *  local_report;
    char    pages_list[MaxParamSize + 1];


    // Missing pages list
    *pages_list = '\0';
    if (page_list (PageState_Unseen,
                   pages_list,
                   sizeof (pages_list)))
    {
        return NULL;
    }


    char *full_address = emailrx_construct_full_address (&header.from,
                                                         (int) true);
    if (full_address == NULL)
    {
        return NULL;
    }

    local_report = emailrx_generate_report_from_message (
                       "MissingPageL",
                       header.date_hdr,
                       full_address,
                       pages_list,
                       NULL);

    free (full_address);

    if (local_report == NULL)
    {
        return NULL;
    }

    // Write out the tokenised remote report to a file
    FILE *  file;

    file = fopen (remote_report_filename,
                  "w");
    if (file == NULL)
    {
        return NULL;
    }

    full_address = emailrx_construct_full_address (&header.to,
                                                   (int) false);
    if (full_address == NULL)
    {
        return NULL;
    }

    if (fprintf (file,
                 "[TOKENISED]\n"
                 "TYPE=MISSINGPAGES\n"
                 "FROM=%s\n"
                 "PAGES=%s\n"
                 "DATESENT=%s\n"
                 "DATEPROCESSED=",
                 full_address,
                 pages_list,
                 header.date_hdr) < 0)
    {
        free (full_address);
        return NULL;
    }

    free (full_address);

    date  date_processed (FALSE,
                          NULL,
                          0,
                          0,
                          TRUE);

    NFE_CONTEXT context;

    if (date_processed.WriteOut (context,
                                 0,
                                 file) != NFE_COMPLETED)
    {
        return NULL;
    }

    return local_report;
}




/* -----------------------------------------------------------------------------
+
   netfax_fax_document_t::printed_page_report

   Generate tokens for printed page reports that are specific to NetFax fax
   documents.

   Inputs
   file:   file descriptor of file in which to dump printed 'page' report
   header:
   header for email message being printed

   Returns
   success: 0
   failure: -1
-
 */

int netfax_fax_document_t::printed_page_report (FILE *const         file,
                                                const NFE_header &  header)
{
    if (document_t::printed_page_report (file,
                                         header) != 0)
    {
        return -1;
    }

    char pages_list[MaxParamSize + 1];
    *pages_list = '\0';

    // This is a not very elegant at the moment.  There's no reason (apart
    // from lack of time) why page_list should not be modified so it can write
    // to a file, thereby not being constrained by arbitrary maximium size;

    if (page_list (PageState_Seen,
                   pages_list,
                   sizeof (pages_list)))
    {
        return -1;
    }

    if (fprintf (file,
                 "PAGES=%s\n",
                 pages_list) < 0)
    {
        return -1;
    }

    return 0;
}




int netfax_fax_document_t::cover_sheet (char *const         report,
                                        size_t              report_size,
                                        const NFE_header &  header)
{
    if (number_messages == 0)
    {
        // document size confirmation required
        return document_size_confirmation (report,
                                           report_size,
                                           header);
    }

    else if (!flags.exact_number_pages || flags.split_download)
    {
        // cover sheet required
        return page_range_report (report,
                                  report_size,
                                  header);
    }

    return 0;
}




int netfax_fax_document_t::page_range_report (char *const         report,
                                              size_t              report_size,
                                              const NFE_header &  header)
{
    enum
    {
        SinglePage_Exact,
        SinglePage_Unknown,
        MultiPage_Exact,
        MultiPage_Unknown
    };
    // The ordering of the coversheet tokens in the following array *MUST*
    // follow the ordering of the above enum.
    static const char *  coversheet_token[] =
    {
        "CSBodySPE",
        "CSBodySPU",
        "CSBodyMPE",
        "CSBodyMPU"
    };
    char                 param[4][MaxParamSize + 1];
    char                 buffer[MessageBufferSize + 1];
    const char *         read_only_buffer;
    unsigned int         first_page;
    unsigned int         last_page;
    int                  coversheet_type;
    int                  string_len;
    _kernel_oserror *    e;


    // Check that there is enough space for at least a '\0' terminator in
    // the report string.  If not return an error.  Also, decrement the
    // report size by one so that all checks automatically take account of a
    // '\0' terminator.

    if (--report_size < 1)
        return 1;
    report[0] = '\0';


    page_range (first_page,
                last_page);

    // Decide what type of cover sheet is required
    int page_count = 0;

    for (int i = first_page; i <= last_page; i++)
    {
        if (page_seen[i] == PageState_Seen)
        {
            if (++page_count > 1)
                break;
        }
    }

    if (page_count == 1)
    {
        if (flags.exact_number_pages)
            coversheet_type = SinglePage_Exact;
        else
            coversheet_type = SinglePage_Unknown;
    }
    else
    {
        if (flags.exact_number_pages)
            coversheet_type = MultiPage_Exact;
        else
            coversheet_type = MultiPage_Unknown;
    }

    // Generate cover sheet title
    e = _swix (MessageTrans_Lookup,
               _INR (0, 7) | _OUTR (2, 3),

               report_templates,
               "CSTitle",
               0,    // direct pointer to read-only result
               0,    // size of buffer N/A
               0,
               0,
               0,
               0,

               &read_only_buffer,
               &string_len);

    if (e != NULL)
        return 1;

    if (report_size < string_len)
        return 1;
    strncat (report, read_only_buffer, string_len);
    report_size -= string_len;

    if (report_size < 2)
        return 1;
    strcat (report, "\n\n");
    report_size -= 2;

    // Generate cover sheet document id
    sprintf (param[0],
             "%d",
             document_id.document_number);

    char *full_address = emailrx_construct_full_address (&header.from,
                                                         (int) true);
    if (full_address == NULL)
        return 1;

    e = _swix (MessageTrans_GSLookup,
               _INR (0, 7) | _OUT (3),

               report_templates,
               "CSId",
               buffer,
               sizeof (buffer),
               param[0],
               full_address,
               0,
               0,

               &string_len);

    free (full_address);

    if (e != NULL)
        return 1;

    if (report_size < string_len)
        return 0;
    strncat (report, buffer, string_len);
    report_size -= string_len;

    if (report_size < 2)
        return 0;
    strcat (report, "\n\n");
    report_size -= 2;

    // Create body text of cover sheet
    switch (coversheet_type)
    {
        case SinglePage_Exact:
        case SinglePage_Unknown:
            sprintf (param[0],
                     "%d",
                     first_page);

            sprintf (param[1],
                     "%d",
                     total_number_pages);

            e = _swix (MessageTrans_Lookup,
                       _INR (0, 7) | _OUT (3),

                       report_templates,
                       coversheet_token[coversheet_type],
                       buffer,
                       sizeof (buffer),
                       param[0],
                       param[1],
                       0,
                       0,

                       &string_len);
            break;

        case MultiPage_Exact:
        case MultiPage_Unknown:
            param[0][0] = '\0';

            if (page_list (PageState_Seen,
                           param[0],
                           MaxParamSize + 1))
            {
                return -1;
            }

            sprintf (param[1],
                     "%d",
                     total_number_pages);

            e = _swix (MessageTrans_Lookup,
                       _INR (0, 7) | _OUT (3),

                       report_templates,
                       coversheet_token[coversheet_type],
                       buffer,
                       sizeof (buffer),
                       param[0],
                       param[1],
                       0,
                       0,

                       &string_len);
            break;

       default:
            return 1;
    }

    if (e != NULL)
        return 1;

    if (report_size < string_len)
        return 0;
    strncat (report, buffer, string_len);
    report_size -= string_len;

    if (report_size < 1)
        return 0;
    strcat (report, "\n");
    report_size -= 1;

    return 1;
}





/* -----------------------------------------------------------------------------
+
   generate_doc_size_conf

   Generate a document size conformation report

   Inputs
   document_info: document handle as returned by document iterator
   report:        pointer to area in which to store explanation text
   report_size:   size of the area in which to store explanation text

   Returns
   success: 0
   failure: 1
-
 */

int netfax_fax_document_t::document_size_confirmation (
        char *const         report,
        size_t              report_size,
        const NFE_header &  header)
{
    enum
    {
        SinglePage_Now_SinglePage,
        SinglePage_Now_MultiPage,
        MultiPage
    };
    // The ordering of the tokens in the following array *MUST*
    // follow the ordering of the above enum.
    static const char *  dsc_token[] =
    {
        "DSCBodySPSP",
        "DSCBodySPMP",
        "DSCBodyMP"
    };
    char                 param[4][MaxParamSize + 1];
    char                 buffer[MessageBufferSize + 1];
    const char *         read_only_buffer;
    int                  dsc_type;
    int                  string_len;
    _kernel_oserror *    e;


    // Check that there is enough space for at least a '\0' terminator in
    // the report string.  If not return an error.  Also, decrement the
    // report size by one so that all checks automatically take account of a
    // '\0' terminator.
    if (--report_size < 1)
        return 1;
    report[0] = '\0';

    // Decide what type of dsc is required
    if (total_number_pages == 1)
        dsc_type = SinglePage_Now_SinglePage;
    else
    {
        if (number_pages == 1)
            dsc_type = SinglePage_Now_MultiPage;
        else
            dsc_type = MultiPage;
    }

    // Generate dsc title
    e = _swix (MessageTrans_Lookup,
               _INR (0, 7) | _OUTR (2, 3),

               report_templates,
               "DSCTitle",
               0,    // direct pointer to read-only result
               0,    // size of buffer N/A
               0,
               0,
               0,
               0,

               &read_only_buffer,
               &string_len);

    if (e != NULL)
        return 1;

    if (report_size < string_len)
        return 1;
    strncat (report, read_only_buffer, string_len);
    report_size -= string_len;

    if (report_size < 2)
        return 1;
    strcat (report, "\n\n");
    report_size -= 2;

    // Generate dsc document id
    sprintf (param[0],
             "%d",
             document_id.document_number);

    char *full_address = emailrx_construct_full_address (&header.from,
                                                         (int) true);
    if (full_address == NULL)
        return 1;

    e = _swix (MessageTrans_GSLookup,
               _INR (0, 7) | _OUT (3),

               report_templates,
               "DSCId",
               buffer,
               sizeof (buffer),
               param[0],
               full_address,
               0,
               0,

               &string_len);

    free (full_address);

    if (e != NULL)
        return 1;

    if (report_size < string_len)
        return 0;
    strncat (report, buffer, string_len);
    report_size -= string_len;

    if (report_size < 2)
        return 0;
    strcat (report, "\n\n");
    report_size -= 2;

    // Create body text of dsc
    switch (dsc_type)
    {
        case SinglePage_Now_SinglePage:
            e = _swix (MessageTrans_Lookup,
                       _INR (0, 7) | _OUT (3),

                       report_templates,
                       dsc_token[dsc_type],
                       buffer,
                       sizeof (buffer),
                       0,
                       0,
                       0,
                       0,

                       &string_len);
            break;

        case SinglePage_Now_MultiPage:
            sprintf (param[0],
                     "%d",
                     total_number_pages);

            e = _swix (MessageTrans_Lookup,
                       _INR (0, 7) | _OUT (3),

                       report_templates,
                       dsc_token[dsc_type],
                       buffer,
                       sizeof (buffer),
                       param[0],
                       0,
                       0,
                       0,

                       &string_len);
            break;


        case MultiPage:
            sprintf (param[0],
                     "%d",
                     number_pages);

            sprintf (param[1],
                     "%d",
                     total_number_pages);

            e = _swix (MessageTrans_Lookup,
                       _INR (0, 7) | _OUT (3),

                       report_templates,
                       dsc_token[dsc_type],
                       buffer,
                       sizeof (buffer),
                       param[0],
                       param[1],
                       0,
                       0,

                       &string_len);
            break;

       default:
            return 1;
    }

    if (e != NULL)
        return 1;

    if (report_size < string_len)
        return 0;
    strncat (report, buffer, string_len);
    report_size -= string_len;

    if (report_size < 1)
        return 0;
    strcat (report, "\n");
    report_size -= 1;

    return 1;
}




/* -----------------------------------------------------------------------------
+
   page_range

   Get the first and last page number of the document

   Outputs
   first_page: first page number (0 == no pages)
   last_page:  last page number (0 == no pages)
-
 */

void netfax_fax_document_t::page_range (
         unsigned int &  first_page,
         unsigned int &  last_page)
{
    message_t *  message;

    message = (message_t *) list_head (message_list);
    if (message == NULL)
        first_page = 0;
    else
        first_page = message->nf_message_id.first_page_num;

    message = (message_t *) list_tail (message_list);
    if (message == NULL)
        last_page = 0;
    else
        last_page = message->nf_message_id.last_page_num;
}




/* -----------------------------------------------------------------------------
+
   page_list

   Concatenate a 0 terminated list of pages (seen or unseen) onto the end of a 0
   terminated string using the array of seen pages.  Blocks of pages are
   written as ranges and individual pages are written as individual numbers.
   eg. a generated list may look like:

   1, 3-5, 8-13, 15, 17

   Assumes that there will never be more than 9999 pages in a single document.

   Inputs
   page_list_seen_state: add pages with this state to list
   string:               0 terminated string to concatenate list onto.
   max_len:              maximum allowed length of page list

   Returns
   0: success
   1: failure (size of list exceeds max_len)
-
 */

int netfax_fax_document_t::page_list (const page_state  page_list_seen_state,
                                      char *const       string,
                                      size_t            max_len)
{
    char          page_range[10];
    unsigned int  first_page = 0;
    size_t        page_range_len;
    bool          first_in_list = true;
    page_state    previous_page_seen_state;


    previous_page_seen_state = page_seen[first_page];

    int i = 0;

    while (i < total_number_pages)
    {
        // Find next page with state we're interested in
        while (i < total_number_pages)
        {
            if (page_seen[i] == page_list_seen_state)
                break;

            i++;
        }

        first_page = i;

        // Find last page in this block with state we're interested in
        // and add page range for block to list
        while (i < total_number_pages)
        {
            if (i == total_number_pages - 1 ||
                page_seen[i + 1] != page_list_seen_state)
            {
                if (i > first_page)
                {
                    sprintf (page_range,
                             "%u-%u",
                             first_page + 1,
                             i + 1);
                }
                else
                {
                    sprintf (page_range,
                             "%u",
                             first_page + 1);
                }

                // The list is comma separated, so write a comma to the list
                // before writing the page range / number - except for the
                // first page in the list.
                if (first_in_list)
                    first_in_list = false;
                else
                {
                    if (max_len < 2)
                        return 1;

                    strcat (string,
                            ", ");
                    max_len -= 2;
                }

                page_range_len = strlen (page_range);
                if (max_len < page_range_len)
                    return 1;

                strncat (string,
                         page_range,
                         page_range_len);
                max_len -= page_range_len;

                // know that next page does not have required state, so restart
                // at the page after that
                i += 2;

                break;
            }

            i++;
        }
    }

    return 0;
}




/* =============================================================================
 * C interface functions
 */

extern "C"
{

/* -----------------------------------------------------------------------------
+
   emailrx_initialise

   Initialise the email receive code.  Must be called before any other emailrx
   functions.
-
 */

extern int emailrx_initialise (void)
{
    _kernel_oserror *  e;

    document_list = list_create (free_document);
    if (document_list == NULL)
        return 1;


    /* Claim RMA for MessageTrans file descriptor and pathname */
    e = _swix (OS_Module,
               _IN (0) | _IN (3) | _OUT (2),

               6,
               sizeof (MessagesFD) + strlen (ReportsPath) + 1,

               &report_templates);

    if (e != NULL)
        return 1;

    strcpy ((char *) ((int) report_templates + sizeof (MessagesFD)),
            ReportsPath);

    e = _swix (MessageTrans_OpenFile,
               _INR (0, 2),

               report_templates,
               (int) report_templates + sizeof (MessagesFD),
               0);

    if (e != NULL)
    {
        _swix (OS_Module,
               _IN (0) | _IN (2),

               7,
               report_templates);
        report_templates = NULL;

        return 1;
    }

    return 0;
}




/* -----------------------------------------------------------------------------
+
   emailrx_finalise

   Close down the email receive code.  Must be called before shutdown or
   resources will be leaked.  May be attached to atexit.
-
 */

extern void emailrx_finalise (void)
{
    if (report_templates)
    {
        _swix (MessageTrans_CloseFile,
               _IN (0),

               report_templates);

        _swix (OS_Module,
               _IN (0) | _IN (2),

               7,
               report_templates);
    }
}




/* -----------------------------------------------------------------------------
+
    emailrx_new_message

    Add a new message to the document list.  Tries to cope with low memory
    situations by getting rid of some of the document list.  If this happens
    successfully then the caller may continue processing (ie. download what
    is left in the document list - obviously it shouldn't try to add any more
    messages to the document list).

    Some messages such as Document Size Confirmation contain all the required
    information in the headers, so do not need to be downloaded a second time.
    Such messages will never be added to the download list, so if the download
    list is being used to determine which messages should be deleted then this
    class of message needs to be kept track of separately.  NB. such messages
    should not be deleted instantly - wait for the next session.

    Inputs
    size:             size of message in bytes
    header:           pointer to message headers
    unique_id:        unqiue id returned by POP3 UIDL command
    message_class:    class of message
    nf_message_class: class of netfax message

    Outputs
    delete_message:   flag indicating whether the message be marked for
                      deletion immediately

    Returns
    0: message dealt with successfully (NB. not necessarily added)
    1: couldn't add message but managed to recover some memory
    2: couldn't add message and couldn't recover memory
-
 */

extern int emailrx_new_message (const unsigned int        size,
                                const NFE_header *const   header,
                                const char *const         unique_id,
                                int *const                delete_message)
{
    unsigned int  message_flags        = 0;
    unsigned int  message_number_lines = 0;
    document_t *  document             = NULL;


    *delete_message = 0;

    /* Check if the message contains a class of data which is supported */
    int support = emailrx_check_supported (header->msg_class,
                                           header->netfax_msg_class);
    if (support == EmailSupport_None)
    {
        *delete_message = 1;
        return 0;
    }


    netfax_document_id new_document_id;

    new_document_id.device_class = header->details.device_class;
    new_document_id.document_number = header->id.doc_num;
    memcpy (new_document_id.serial_num,
            header->details.serial_num,
            SERIAL_LEN);

    // If a message has no fax pages then it is
    // treated as a completely separate document, even if it is 'logically'
    // part of a document with fax pages.  (eg. if you sent a fax document
    // with an email tagged on the end, but the email got put in a separate
    // message).  This is all hypothetical at the moment because documents
    // cannot yet be split this way, but they may be in the future...

    if (header->msg_class == NFE_MC_NETFAX_DATA &&
        (header->netfax_msg_class & NFE_NFMC_FAX))
    {
        // This message has fax pages, so check to see if we already have
        // other fax pages that are part of this document in our document
        // list.
        document = (document_t *) list_find_item (document_list,
                                                  match_doc,
                                                  &new_document_id);
    }

    if (document == NULL)
    {
        // document not in document list
        document = create_doc (*header);

        if (document == NULL ||
            document->add_to_list (document_list) == NULL)
        {
            goto no_mem;
        }
    }
    else
    {
        // Document is already in document list.  Now have to check whether
        // message is already in message list for this document.

        if (list_find_item (document->get_message_list (),
                            match_message,
                            (void *) unique_id))
        {
            // Message is already in message list for this document
            return 0;
        }
    }


    if (document->add_message (size,
                               unique_id,
                               header->id,
                               *((bool *) delete_message)) == NULL)
    {
        goto no_mem;
    }

    return 0;

no_mem:
     /* Not enough memory to add a new document.  Get rid of some
      * of the document list to free up some space.
      */

    if (truncate_doc_list () > 0)    /* was able to free space */
        return 1;
    else
        return 2;
}




/* -----------------------------------------------------------------------------
+
   emailrx_build_dl_list

   Build the list of documents to download given an amount of free space.

   Inputs
   free_space: amount of free workspace available in bytes
-
 */

extern list_handle emailrx_build_dl_list (unsigned int free_space)
{
    unsigned int     largest_message = 0;
    list_handle      download_list;
    list_iterator_t  document_iterator;
    document_t *     document;


    download_list = list_create (free_document);
    if (download_list == NULL)
        return NULL;

    list_initialise_iterator (&document_iterator,
                              document_list);

    document = (document_t *) (document_iterator.reset) (&document_iterator);

    while (!(document_iterator.finished) (&document_iterator))
    {
        switch (document->add_to_download (download_list,
                                           free_space,
                                           largest_message))
        {
            case 0:
                // added document successfully: continue building download list
                break;

            case 1:
                // not enough free space for document: stop creating download
                // list and make do with what we've already got
                return download_list;

            default:
                // out of workspace: abandon entire download
                list_destroy (download_list);
                return NULL;
        }

        document = (document_t *) (document_iterator.next) (&document_iterator);
    }

    return download_list;
}




/* -----------------------------------------------------------------------------
+
   emailrx_need_missing_page_report

   Decide whether a missing page report needs to be generated for a document.

   Currently assumes that there will never be more than 9999 pages in a single
   document.

   Inputs
   document_info: document handle as returned by document iterator

   Returns
   0: missing page report not required
   1: missing page report required
-
 */

extern int emailrx_need_missing_page_report (const document_handle    document)
{
    return ((document_t *) document)->need_missing_page_report ();
}




/* -----------------------------------------------------------------------------
+
   emailrx_generate_missing_page_report

   Generate a missing page report for a document.

   Currently assumes that there will never be more than 9999 pages in a single
   document.

   Inputs
   document_info:          document handle as returned by document iterator
   remote_report_filename: name of file to write remote report into
   header:                 email headers for this document

   Returns
   -1: error
    0: success
-
 */

extern char *  emailrx_generate_missing_page_report (
                   const document_handle    document,
                   char *const              remote_report_filename,
                   const NFE_header *const  header)
{
    return ((document_t *) document)->generate_missing_page_report (
                                          remote_report_filename,
                                          *header);
}




/* -----------------------------------------------------------------------------
+
   emailrx_printed_page_report

   Decide whether a printed page report needs to be generated for a document,
   and if so generate it and dump it in a file.

   Currently assumes that there will never be more than 9999 pages in a single
   document.

   Inputs
   document_info:      document handle as returned by document iterator
   filename:           name of file to dump printed page report in

   Returns
   -1: error
    0: printed page report not required
    1: printed page report required
-
 */

extern int emailrx_printed_page_report (
               const document_handle    document,
               const char *const        filename,
               const NFE_header *const  header)
{
    if (header->return_receipt_to.address == NULL)
    {
        return 0;
    }
    else
    {
        FILE *  file;

        file = fopen (filename,
                      "w");
        if (file == NULL)
        {
            return -1;
        }


        if (fprintf (file,
                     "[TOKENISED]\n") < 0)
        {
            fclose (file);
            return -1;
        }

        if (((document_t *) document)->printed_page_report (file,
                                                            *header) != 0)
        {
            fclose (file);
            return -1;
        }

        fprintf (file,
                 "[END]\n");

        fclose (file);

        return 1;
    }
}




/* -----------------------------------------------------------------------------
+
   emailrx_cover_sheet

   Decide if some sort of cover sheet needs to be printed out for a document.
   This could happen if the exact number of pages in the document is not
   known or if a document is printed out in several chunks.  Also, if a dummy
   fax page (indicating the exact number of pages for a document that previously
   had an unknown number of pages) has been received in isolation then this
   information needs to be printed.

   Inputs
   document_info: document handle as returned by document iterator
   report:        pointer to area in which to store explanation text
   report_size:   size of the area in which to store explanation text

   Returns
   -1: error
    0: cover sheet not required
    1: cover sheet required
-
 */

extern int emailrx_cover_sheet (const document_handle    document,
                                char *const              report,
                                size_t                   report_size,
                                const NFE_header *const  header)
{
    /* Note that if a dsc is seen in the same session as real pages for the
     * document to which it refers then the following happens:
     *
     * 1. If all pages for the document are downloaded in that session then all
     * of the document will be printed in one go, so no special explanation is
     * required.
     *
     * 2. If only part of the document is downloaded then a cover sheet is
     * required to inform the user which section of the document has been
     * printed.  However, the exact number of pages is now known, so this
     * information can be conveyed in the cover sheet (which will say
     * "pages x to y of z" instead of "pages x to y of at least z").  This
     * avoids having to print out a separate dsc at the end.
     */

    return ((document_t *) document)->cover_sheet (report,
                                                   report_size,
                                                   *header);
}




/* -----------------------------------------------------------------------------
+
   emailrx_destory_dl_list

   Destroy a document list.

   Inputs
   download_list: the handle of the list to destroy
-
 */

extern void emailrx_destroy_dl_list (list_handle download_list)
{
    list_destroy (download_list);
}




/* -----------------------------------------------------------------------------
+
   emailrx_get_doc_list

   Get the list handle of the document list.

   Returns
   list handle
 */

extern list_handle emailrx_get_doc_list (void)
{
    return document_list;
}




/* -----------------------------------------------------------------------------
+
   emailrx_get_doc_msg_list

   Return the message list handle for a document.

   Inputs
   document_info: handle of document

   Returns
   list handle
-
 */

extern list_handle emailrx_get_doc_msg_list (
                       const document_handle document)
{
    assert (document != NULL);

    return ((document_t *) document)->get_message_list ();
}




/* -----------------------------------------------------------------------------
+
   emailrx_check_supported

   Given a message class and netfax message class for an entity, decide if
   it conatains data that is supported.  The degree of support can vary: eg.
   RFC822 messages with no netfax headers in can be handled, but only the first
   60 lines are downloaded because the message may contain 2MB worth of
   UUEncoded data for all we know!

   It is also possible for an entity to contain some types of data that are
   fully supported, and others that are either partially supported or not
   supported at all.  Such an entity would be classed as fully supported
   because to get at the fully supported data we need to download the whole
   message.  ie. the highest level of support takes priority.

   Inputs
   message_class:    message class
   nf_message_class: netfax message class

   Returns
   not supported at all: EmailSupport_None
   partially supported : EmailSupport_Partial
   fully supported:      EmaiLSupport_Full
-
 */

extern int emailrx_check_supported (const NFE_msg_class     message_class,
                                    const NFE_NF_msg_class  nf_message_class)
{
    int  support = EmailSupport_None;

    switch (message_class)
    {
        case NFE_MC_NETFAX_DATA:
            /* For the moment all the tests below are kept separate so that
             * it is easier to change support for an individual class of data
             * at a later stage.
             */

            if (nf_message_class & NFE_NFMC_RTEXT)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_FAX)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_CONFIG)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_ADDRBK)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_REPORT)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_LOG)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_DELIVERYREPORT)
                support = EmailSupport_Full;

            break;

        case NFE_MC_SMTP_DELIVERY_ERROR:
            support = EmailSupport_Partial;
            break;

        case NFE_MC_UNKNOWN:
            support = EmailSupport_Partial;
            break;

        default:
            support = EmailSupport_None;
            break;
    }

    return support;
}





/* -----------------------------------------------------------------------------
+
   emailrx_construct_full_address

   Combine a real name and email address into a single 0 terminated string of
   the form:
   Real Name <email address>

   eg. for me this would be:
   Ben Laughton <blaughton@acorn.com>

   Inputs
   address:  pointer to NFE_address structure holding real name and email
             address
   gs_trans: flag indicating whether generated string needs to be sutiable for
             gs_trans (ie. escapes '<')

   Returns
   success: pointer to malloc'd from string (client must free)
   failure: NULL
-
 */

extern char *emailrx_construct_full_address (const NFE_address *const  address,
                                             const int                 gs_trans)
{
    char *  full_address;
    size_t  full_address_len = 1;    // start at 1 to allow for 0 terminator


    // Calculate exact length of string needed to store the 'from' field
    if (address->real_name)
    {
        full_address_len += strlen (address->real_name);

        if (address->address)
        {
            // allow for space character between real name and address
            full_address_len += 1;
        }
    }

    if (address->address)
    {
        full_address_len += strlen (address->address);

        // allow for angle brackets around address as well
        full_address_len += 2;
        if (gs_trans)
            full_address_len++;
    }


    // Allocate memory to store the 'from' field.  It is the caller's
    // responsibility to free this.
    full_address = malloc (full_address_len);
    if (full_address == NULL)
        return NULL;


    // Construct the from field
    full_address[0] = '\0';
    if (address->real_name)
    {
        strcat (full_address,
                address->real_name);

        if (address->address)
        {
            strcat (full_address,
                    " ");
        }
    }

    if (address->address)
    {
        if (gs_trans)
        {
            strcat (full_address,
                    "|<");
        }
        else
        {
            strcat (full_address,
                    "<");
        }

        strcat (full_address,
                address->address);

        strcat (full_address,
                ">");
    }

    return full_address;
}




/* -----------------------------------------------------------------------------
+
   emailrx_generate_report_from_message

   Generate a report from a message token and up to four parameters.

   Inputs
   message_token: token in message file
   param0:        1st parameter (%0 for MessageTrans)
   param1:        2nd parameter (%1 for MessageTrans)
   param2:        3rd parameter (%2 for MessageTrans)
   param3:        4th parameter (%3 for MessageTrans)

   Returns
   success: pointer to report - client's responsibility to free
   failure: NULL
-
 */

extern char *emailrx_generate_report_from_message (char *  message_token,
                                                   char *  param0,
                                                   char *  param1,
                                                   char *  param2,
                                                   char *  param3)
{
    char *  report;
    size_t  report_size;


    /* Work out roughly how much space will be needed to store the report.
     * The estimate will be slightly over what's needed because the parameter
     * substitution characters in the message are not discounted.
     */

    if (_swix (MessageTrans_GSLookup,
               _INR (0, 2) | _OUT (3),

               report_templates,
               message_token,
               NULL,    /* return read-only string, no substitution */

               &report_size))
    {
        return NULL;
    }

    if (param0)
    {
        report_size += strlen (param0);
    }
    if (param1)
    {
        report_size += strlen (param1);
    }
    if (param2)
    {
        report_size += strlen (param2);
    }
    if (param3)
    {
        report_size += strlen (param3);
    }
    report_size += 1;    /* 0 terminator */

    report = malloc (report_size);
    if (report == NULL)
    {
        return NULL;
    }

    if (_swix (MessageTrans_GSLookup,
               _INR (0, 7),

               report_templates,
               message_token,
               report,
               report_size,
               param0,
               param1,
               param2,
               param3))
    {
        free (report);
        return NULL;
    }

    return report;
}




}    // end of C interface functions




/* -----------------------------------------------------------------------------
+
   create_doc

   Create a new document of the appropriate type according to the message
   class and netfax message class.

   Inputs
   header: header structure

   Returns
   success: pointer to document object
   failure: NULL
-
 */

static document_t *create_doc (const NFE_header &  header)
{
    bool          success;
    document_t *  document;


    switch (header.msg_class)
    {
        case NFE_MC_NETFAX_DATA:
            if (header.netfax_msg_class & NFE_NFMC_FAX)
                document = new netfax_fax_document_t (header,
                                                      success);

            else
                document = new netfax_document_t (header,
                                                  success);

            break;

        default:
            document = new document_t (header,
                                       success);
            break;
    }

    if (!success)
    {
        delete document;
        document = NULL;
    }

    return document;
}




/* -----------------------------------------------------------------------------
+
   match_doc

   Document matching routine for document list searching.

   Inputs
   data1: pointer to current document in list
   data2: pointer to details of document being searched for

   Returns
   1: match
   0: no match
-
 */

static int match_doc (void *const  data1,
                      void *const  data2)
{
    const document_t &          document    = *((document_t *const) data1);
    const netfax_document_id &  document_id = *((netfax_document_id *) data2);


    return (document == document_id);
}





/* -----------------------------------------------------------------------------
   match_message

   Message matching routine for document list searching.

   Inputs
   data1: pointer to current message in list
   data2: pointer to UID of message being searched for

   Returns
   1: match
   0: no match
 */

static int match_message (void *const  data1,
                          void *const  data2)
{
    const message_t &  message   = *((message_t *const) data1);
    const char *const  unique_id = (const char *const)  data2;


    if (strcmp (message.unique_id,
                unique_id) == 0)
    {
        return 1;
    }

    return 0;
}




/* -----------------------------------------------------------------------------
   compare_page_nums

   Page number comparison routine for inserting a message into a list of
   messages ordered by page number.

   Inputs
   data1: pointer to message information
   data2: pointer to message information

   Returns
   -1: message1 comes before message2
    1: message1 comes after message2
 */

static int compare_page_nums (void *const  data1,
                              void *const  data2)
{
    message_t *const  message1 = (message_t *const) data1;
    message_t *const  message2 = (message_t *const) data2;


    if (message1->nf_message_id.first_page_num <
            message2->nf_message_id.first_page_num)
    {
        return -1;
    }
    else if (message1->nf_message_id.first_page_num >
                 message2->nf_message_id.first_page_num)
    {
       return 1;
    }
    else
    {
        /* Is it even possible to get two messages in the same document with
         * the same start page number?  If it is then consider the end page
         * number.
         */

        if (message1->nf_message_id.last_page_num <
                message2->nf_message_id.last_page_num)
        {
            return -1;
        }
        else if (message1->nf_message_id.last_page_num >
                     message2->nf_message_id.last_page_num)
        {
           return 1;
        }
        else
        {
            /* The last page numbers are the same as well!!  For the sake of
             * argument say that message1 should come before message2.
             */

            return -1;
        }
    }
}




/* -----------------------------------------------------------------------------
+
   free_document

   Deallocate storage for a document when a document is removed
   from a list of documents.

   Inputs:
   document: pointer to document
-
 */

static void free_document (void *  document)
{
    delete document;
}



/* -----------------------------------------------------------------------------
+
   free_message

   Deallocate storage for message information when a message is removed
   from a list of messages.

   Inputs
   message_info: pointer to message information
-
 */

static void free_message (void *  message)
{
    free (message);
}




/* -----------------------------------------------------------------------------
+
   truncate_doc_list

   Remove approximately 2/3 of the document list.  Used as an emergency
   measure if we run out of memory to try to recover and still do something
   useful.  Junking 2/3 of the document list should leave enough space for
   the corresponding download list plus a bit extra for good measure.

   Returns
   failure: -1 (not able to recover any memory)
   success: number messages in truncated document list
-
 */

static int truncate_doc_list (void)
{
    int              message_count = 0;
    int              one_third_number_messages;
    list_iterator_t  document_iterator;
    document_t *     document;

    /* Iterate over the document list to find the total number of messages */
    list_initialise_iterator (&document_iterator,
                              document_list);

    document = (document_t *) (document_iterator.reset) (&document_iterator);

    while (!(document_iterator.finished) (&document_iterator))
    {
        message_count += document->get_number_messages ();

        document = (document_t *) (document_iterator.next) (&document_iterator);
    }

    /* Work out approximate 1/3 of total number messages */
    one_third_number_messages = message_count / 3;
    if (one_third_number_messages == 0)
        return -1;

    /* Iterate over the document list again to find the cut-off point.  Cut off
     * whole documents, not just bits.
     */
    message_count = 0;
    document = (document_t *) (document_iterator.reset) (&document_iterator);

    while (!(document_iterator.finished) (&document_iterator))
    {
        message_count += document->get_number_messages ();
        if (message_count > one_third_number_messages)
            break;

        document = (document_t *) (document_iterator.next) (&document_iterator);
    }

    /* Remove all documents from the cut-off point to the end of the list */
    while (!(document_iterator.finished) (&document_iterator))
    {
        document->remove_from_list (document_list);
        document = (document_t *) (document_iterator.next) (&document_iterator);
    }

    return one_third_number_messages;
}




/* -----------------------------------------------------------------------------
+
   check_free_space

   Check if there is enough free space to add a message to the download list.

   Inputs
   message_size:    size of message
   free_space:      free space
   largest_message: largest message added to download list so far

   Returns
   true:  enough free space to add message
   false: not enough free space to add message
-
 */

static bool check_free_space (const unsigned int  message_size,
                              const unsigned int  free_space,
                              const unsigned int  largest_message)
{
    unsigned int  temp_largest_message;

    if (message_size > largest_message)
        temp_largest_message = message_size;
    else
        temp_largest_message = largest_message;

    return (bool) (free_space - message_size >
                      (unsigned int) ((double) temp_largest_message * 0.75));
}




/* -----------------------------------------------------------------------------
+
   update_free_space

   Update the amount of free space given the size of a message that has been
   added to the download list.

   Inputs
   message_size:    size of message just added
   free_space:      free space before adding message
   largest_message: largest message added to download list so far

   Outputs
   free_space:      free space after adding message
   largest_message: possibly updated largest message
-
 */

static void update_free_space (const unsigned int  message_size,
                               unsigned int &      free_space,
                               unsigned int &      largest_message)
{
    if (message_size > largest_message)
        largest_message = message_size;

    free_space -= message_size;
}




/* -----------------------------------------------------------------------------
+
   add_message_common

   Common code used when adding a new message to a document regardless of the
   type of document.

   Inputs
   size:          size of message
   unique_id:     POP3 unique id of message, as returned by UIDL command
   nf_message_id: netfax message id of message

   Returns
   success: pointer to message structure
   failure: NULL
-
 */

static message_t *add_message_common (const unsigned int  size,
                                      const char *const   unique_id)
{
    /* Create new message information structure */
    message_t *  message = (message_t *) malloc (sizeof (message_t));
    if (message == NULL)
        return NULL;

    message->size = size;

    message->unique_id = malloc (strlen (unique_id) + 1);
    if (message->unique_id == NULL)
    {
        free (message);
        return NULL;
    }
    strcpy (message->unique_id, unique_id);

    return message;
}




#ifdef TEST
void document_t::dump_to_file (FILE *const  file)
{
    fprintf (file, "========================================\n");
    fprintf (file, "Document size: %u\n", document_size);
    fprintf (file, "Message class: %u\n", message_class);
}

void netfax_document_t::dump_to_file (FILE *const  file)
{
    document_t::dump_to_file (file);

    fprintf (file, "Document number: %u\n", document_id.document_number);
    fprintf (file, "Netfax messsage class: %x\n", netfax_message_class);
}

void netfax_fax_document_t::dump_to_file (FILE *const  file)
{
    netfax_document_t::dump_to_file (file);

    fprintf (file, "Split download: %s\n",
             flags.split_download ? "Yes" : "No");

    fprintf (file, "Connection count: %u\n", connection_count);
    fprintf (file, "Total number pages: %u\n", total_number_pages);
    fprintf (file, "Number pages: %u\n", number_pages);
    fprintf (file, "Number pages remaining: %u\n", number_pages_remaining);
    fprintf (file, "Exact number pages: %s\n",
             flags.exact_number_pages ? "Yes" : "No");

    fprintf (file, "Pages seen:");
    for (int i = 0; i < number_pages; ++i)
    {
        if (page_seen[i] == PageState_Seen)
        {
            fprintf (file, " %d", i + 1);
        }
    }

    fprintf (file, "\n\n");
}

void document_t::dump_message_list_to_file (FILE *const  file)
{
    list_iterator_t iter;
    message_t *message;

    list_initialise_iterator (&iter,
                              message_list);

    for (message = (message_t *) (iter.reset) (&iter);
         !(iter.finished) (&iter);
         message = (message_t *) (iter.next) (&iter))
    {
         fprintf (file, "----------------------------------------\n");
         fprintf (file, "Message size: %u\n", message->size);
         fprintf (file, "Unique id: %s\n", message->unique_id);
         fprintf (file, "Pages: %d - %d\n",
                  message->nf_message_id.first_page_num,
                  message->nf_message_id.last_page_num);
         fprintf (file, "\n");
    }
}

extern "C" void  emailrx_dump_doc_list_to_file (const list_handle  list,
                                                const char *const  filename)
{
    FILE *           file;
    list_iterator_t  iter;
    document_t *     document;


    file = fopen (filename, "a+");
    if (file == NULL)
    {
        return;
    }

    list_initialise_iterator (&iter,
                              list);

    fprintf (file, "########################################\n");
    for (document = (document_t *) (iter.reset) (&iter);
         !(iter.finished) (&iter);
         document = (document_t *) (iter.next) (&iter))
    {
        document->dump_to_file (file);
        document->dump_message_list_to_file (file);
    }

    fclose (file);
}

#endif
