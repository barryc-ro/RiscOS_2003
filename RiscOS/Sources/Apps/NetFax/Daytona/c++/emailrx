/* File:    emailrx.c++
 * Purpose: Daytona email receive
 * Author:  Ben Laughton
 * History:
 *
 * 1997-10-20: BAL
 * Created.
 *
 * 1998-02-25: BAL
 * Split up missing page report detection and generation.
 * Added printed page report (A.K.A. return-receipt, delivery confirmation)
 *
 * 1998-03-03: BAL
 * Corrected 'success' return code in
 * netfax_fax_document_t::printed_page_report (from 1 toadd 0).
 *
 * 1998-03-04: BAL
 * There was some confusion in the spec. about the significance of document
 * numbers in Netfax messages with no fax pages (eg. CAS, ENote etc.),
 * highlighted by the fact that adding a new message to the document list would
 * go wrong sometimes.  This has been resolved and emailrx_new_message has
 * been changed to check if the message being added is part of an
 * existing document *only* when the message being added contains fax pages.
 * Otherwise it is treated as an entirely separate document.
 *
 * 1998-04-01: BAL
 * Bug fix: number_pages_remaining in a document was being set incorrectly -
 * it was being initialised to the number of pages reported in the first message
 * seen for a document as well as being incremented on each new page encountered
 * (so it would typically end up double what it should be).  It is now
 * initialised to zero.  The only effect this had was a small memory leak.
 *
 * 1998-04-02: BAL
 * Fixed problem in addition of new messages: now checks if message is
 * already in document list before trying to add it.  In cases where only part
 * of the mailbox was downloaded in a session, remaining messages would be added
 * again in the next session.
 *
 * number_pages_remaining corrected again.  Used to only be incremented if
 * message had never been seen before.  It is now always incremented when a
 * message is added to the document list, even if that message has been seen
 * before.
 *
 * 1998-05-06: BAL
 * No longer have separate document and download lists: everything is now
 * controlled by setting flags, which has the bonus of considerably simplifying
 * code in certain areas.  Added new document flags to assist with fixing cover
 * sheet problems, not deleting messages before they've been printed, missing
 * page reports etc.
 *
 * 1998-05-18: BAL
 * Fixed bug: if non-NetFax messages were downloaded, then you reconnected to
 * the email account before the messages were printed, then the messages would
 * be downloaded again.  A side-effect of this is that all documents which are
 * not NetFax fax documents have their uniqueness determined by the POP3 UID
 * of the message and not by the document id, device class and serial number.
 *
 * 1998-05-20: BAL
 * Fixed bug: will no longer attempt to download emails which we would never
 * have enough space to download and decode.  Previously if such an email was
 * encountered Daytona would constantly redial the ISP in the hope that there
 * would be enough memory later.
 *
 * Fixed bug: partially supported documents (non-NetFax messages) only have
 * the first page or so downloaded and printed, but the watermark code was
 * treating these messages as if the *whole* message would be downloaded.
 *
 * Now uses the 'official' High Water-Mark system rather than our homegrown
 * one.
 */




/* =============================================================================
 * Include header files
 */

// CLib
#include <assert.h>
#include "kernel.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "swis.h"

// Email
#include "Email/EmailLib/date.h"
extern "C"
{
    #include "AcornPOP3.h"
}

// NetFax specific libraries
#include "NetFax/NFELib/NFELib.h"

// Toolbox
#include "tboxlibs/toolbox.h"
#include "tboxlibs/wimp.h"

// Daytona
#include "emailrx.h"
#include "list.h"
extern "C"
{
    // This little block of headers are order dependent because they don't
    // include the other headers that they need - yuk!  All I wanted was
    // QuCommon :-(.
    #include "BuildFlags.h"
    #include "PageList.h"
    #include "AddrBookIF.h"
    #include "QuStruct.h"
    #include "QuCommon.h"

    #include "SetupIF.h"
}




/* =============================================================================
 * Define constants
 */

#define PartialDownloadLines    56
#define PartialMaxSizeEstimate  (PartialDownloadLines * 1024)
#define MaxParamSize            81
#define MaxReportSize           4096
#define MessageBufferSize       1024
#define ReportsPath             ("Daytona:Reports")

#define MessageFlags_Download        0x00000001
#define MessageFlags_Downloaded      0x00000002
#define MessageFlags_Printing        0x00000004
#define MessageFlags_Printed         0x00000008
#define MessageFlags_JustPrinted     0x00000010
#define MessageFlags_Partial         0x00000020




/* =============================================================================
 * Define macros
 */

#define M_unused(a) (void) (a)




/* =============================================================================
 * Define types
 */

enum bool
{
    false,
    true
};

struct netfax_document_id
{
    unsigned int  device_class;
    unsigned int  document_number;
    char          serial_num[SERIAL_LEN];
};

class document_t
{
    // Methods
    public:
        document_t (const NFE_header &  header,
                    const char *const   id,
                    bool &              success);

        ~document_t (void);

        int operator== (const char *) const;

        virtual message_t *add_message (
                               const unsigned int      size,
                               const char *const       unique_id,
                               const NFE_message_id &  nf_message_id,
                               const unsigned int      max_free_space,
                               bool &                  delete_message,
                               bool &                  impossible);

        virtual void remove_message (const message_t &  message);

        virtual bool  download_possible (const unsigned int  max_free_space,
                                         const unsigned int  message_size);

        list_item_handle add_to_list (list_handle list);

        void remove_from_list (list_handle list);

        virtual bool  check_free_space (message_t *const    message,
                                        const unsigned int  largest_message);

        void  update_free_space (message_t *const  message,
                                 unsigned int &    free_space,
                                 unsigned int &    largest_message);

        virtual int add_to_download (unsigned int  &space_reserved,
                                     unsigned int  &largest_message);

        list_handle get_message_list (void);

        virtual int  get_number_messages (const unsigned int  flags_mask,
                                          const unsigned int  flags_match);

        virtual int  get_number_pages (const unsigned int  flags_mask,
                                       const unsigned int  flags_match);

        virtual bool  need_missing_page_report (void)
        {
            return false;
        }

        virtual char *  generate_missing_page_report (
            char *const         remote_report_filename,
            const NFE_header &  header)
        {
            M_unused (remote_report_filename);
            M_unused (header);

            return NULL;
        }

        virtual bool  need_printed_page_report (void);

        virtual int  printed_page_report (FILE *const         file,
                                          const NFE_header &  header);

        virtual int cover_sheet (char *const         report,
                                 size_t              report_size,
                                 const NFE_header &  header);

        virtual void  tidy (void);

        virtual void  update_flags (void);

        virtual bool  requires_printing (void);

        virtual bool  is_new (void);

#ifdef TEST
        virtual void  dump_to_file (FILE *const  file);

        virtual void  dump_message_list_to_file (FILE *const  file);
#endif

        static int  match_doc (const void *const  data1,
                               const void *const  data2);

    // Data
    protected:
        list_item_handle  item_handle;
        list_handle       message_list;
        NFE_msg_class     message_class;
        char *            return_receipt_address;

        char              unique_id[AcornPOP3_UIDL_SIZE];

        struct
        {
            bool  printing_required : 1;
            bool  is_new            : 1;
        } flags;
};

class netfax_document_t : public document_t
{
    // Methods
    public:
        netfax_document_t (const NFE_header &  header,
                           const char *const   id,
                           bool &              success);

        virtual message_t *add_message (
                               const unsigned int      size,
                               const char *const       unique_id,
                               const NFE_message_id &  nf_message_id,
                               const unsigned int      max_free_space,
                               bool &                  delete_message,
                               bool &                  impossible);

#ifdef TEST
        virtual void  dump_to_file (FILE *const  file);
#endif

    // Data
    protected:
        NFE_NF_msg_class    netfax_message_class;
};

class netfax_fax_document_t : public netfax_document_t
{
    // Methods
    public:
        netfax_fax_document_t (const NFE_header &  header,
                               const char *const   id,
                               bool &              success);

        int operator== (const netfax_document_id &  id) const;

        virtual message_t *  add_message (
                                 const unsigned int      size,
                                 const char *const       unique_id,
                                 const NFE_message_id &  nf_message_id,
                                 const unsigned int      max_free_space,
                                 bool &                  delete_message,
                                 bool &                  impossible);

        virtual bool  download_possible (const unsigned int  max_free_space,
                                         const unsigned int  message_size);


        void  remove_message (const message_t &  message);

        virtual bool  check_free_space (message_t *const    message,
                                        const unsigned int  largest_message);

        int  add_to_download (unsigned int  &space_reserved,
                              unsigned int  &largest_message);

        virtual int  get_number_pages (const unsigned int  flags_mask,
                                       const unsigned int  flags_match);

        virtual bool  need_missing_page_report (void);

        char *  generate_missing_page_report (
                    char *const         remote_report_filename,
                    const NFE_header &  header);

        virtual bool  need_printed_page_report (void);

        int  printed_page_report (FILE *const         file,
                                  const NFE_header &  header);

        int  cover_sheet (char *const         report,
                          size_t              report_size,
                          const NFE_header &  header);

        virtual void  tidy (void);

#ifdef TEST
        virtual void  dump_to_file (FILE *const  file);
#endif

        static int  match_doc (const void *const  data1,
                               const void *const  data2);

    private:
        int page_range_report (char *const         report,
                               size_t              report_size,
                               const NFE_header &  header);

        int document_size_confirmation (char *const         report,
                                        size_t              report_size,
                                        const NFE_header &  header);

        int page_range (char *const         string,
                        size_t              max_len,
                        const unsigned int  first_page,
                        const unsigned int  last_page);

        int page_list (char *const         string,
                       size_t              max_len,
                       const unsigned int  flags_mask,
                       const unsigned int  flags_match);

        int get_number_missing_pages (void);

        int missing_page_list (char *const  string,
                               size_t       max_len);

    // Data
    protected:
        netfax_document_id  document_id;
        struct
        {
            bool  split_download     : 1;
            bool  exact_number_pages : 1;
            bool  physically_split   : 1;
            bool  dsc                : 1;
        } nf_fax_flags;

        unsigned int  connection_count;
        unsigned int  total_number_pages;
};




/* =============================================================================
 * Declare global variables
 */

MessagesFD*         report_templates = NULL;

static list_handle  document_list;




/* =============================================================================
 * Declare function prototypes
 */

static document_t *create_doc (const NFE_header &  header,
                               const char *const   id);

static int match_message (const void *const  data1,
                          const void *const  data2);

static int compare_page_nums (const void *const  data1,
                              const void *const  data2);

static void free_document (void *  document);

static void free_message (void *  message);

static int truncate_doc_list (void);

static message_t *add_message_common (const unsigned int  size,
                                      const char *const   unique_id);




/* =============================================================================
 * Class method implementations
 */

document_t::document_t (const NFE_header &  header,
                        const char *const   id,
                        bool &              success)
{
    success = true;

    item_handle   = NULL;
    message_class = header.msg_class;

    flags.printing_required = false;
    flags.is_new            = true;

    if (id)
    {
        strcpy (unique_id,
                id);
    }

    if (header.return_receipt_to.address != NULL)
    {
        return_receipt_address =
            (char *) malloc (strlen (header.return_receipt_to.address) + 1);
        if (return_receipt_address == NULL)
        {
            success = false;
        }
        else
        {
            strcpy (return_receipt_address,
                    header.return_receipt_to.address);
        }
    }
    else
    {
        return_receipt_address = NULL;
    }

    // Create empty list of messages for this document
    message_list = list_create (free_message);
    if (message_list == NULL)
    {
        success = false;
    }
}




document_t::~document_t (void)
{
    if (return_receipt_address != NULL)
    {
        free (return_receipt_address);
    }
    list_destroy (message_list);
}




/* -----------------------------------------------------------------------------
   document_t::match_doc

   Single page document matching routine for document list searching.

   Inputs
   data1: pointer to current document in list
   data2: pointer to details of document being searched for

   Returns
   1: match
   0: no match
 */

int  document_t::match_doc (const void *const  data1,
                            const void *const  data2)
{
    const document_t &  document  = *((document_t *const) data1);
    const char *        unique_id = (const char *) data2;


    return (document == unique_id);
}





int document_t::operator== (const char *  test_unique_id) const
{
    return (strcmp (unique_id,
                    test_unique_id) == 0);
}




list_item_handle document_t::add_to_list (list_handle list)
{
    item_handle = list_add_item (list,
                                 this);

    return item_handle;
}




void document_t::remove_from_list (list_handle list)
{
    list_remove_item (list,
                      this->item_handle);

    delete this;
}




message_t *document_t::add_message (
               const unsigned int      size,
               const char *const       unique_id,
               const NFE_message_id &  nf_message_id,
               const unsigned int      max_free_space,
               bool &                  delete_message,
               bool &                  impossible)
{
    M_unused (size);
    M_unused (nf_message_id);

    delete_message = false;

    if (!download_possible (max_free_space,
                            PartialMaxSizeEstimate))
    {
        impossible = true;
        return NULL;
    }

    impossible = false;

    // Create new message information structure
    message_t *  message = add_message_common (PartialMaxSizeEstimate,
                                               unique_id);
    if (message == NULL)
    {
        return NULL;
    }


    // Unknown messages and SMTP error reports (which is what is being dealt
    // with here) do not have netfax message ids, so set the netfax message id
    // to a sensible blank value.
    message->nf_message_id.first_page_num  = 0;
    message->nf_message_id.last_page_num   = 0;
    message->nf_message_id.doc_num         = 0;
    message->nf_message_id.msg_num_pages   = 0;
    message->nf_message_id.exact_num_pages = TRUE;
    message->nf_message_id.iap_username    = NULL;

    message->flags.bits.partial = 1;
    message->lines              = PartialDownloadLines;

    // Add message to document's message list.  For these types of message
    // there is only ever one message per document.
    list_item_handle message_item_handle = list_add_item (message_list,
                                                          message);
    if (message_item_handle == NULL)
    {
        free (message->unique_id);
        free (message);
        return NULL;
    }
    message->item_handle = message_item_handle;

    return message;
}




void document_t::remove_message (const message_t &message)
{
    list_remove_item (message_list,
                      message.item_handle);
}




/* -----------------------------------------------------------------------------
   document_t::download_possible

   Determine whether it would ever be possible to download and decode a
   message of a certain size (ie. whether there could ever be enough free
   space).

   Inputs
   max_free_space: maximum possible amount of free space (bytes)
   message_size:   size of this message

   Returns
   false: impossible to download this message
   true:  possible to download this message
 */

bool  document_t::download_possible (const unsigned int  max_free_space,
                                     const unsigned int  message_size)
{
    bool possible = true;

    // Needs to be enough free space to hold raw message and decoded message
    // at the same time.  Decoded message is roughly same size as raw
    // message (may be a bit less).

    if (message_size > max_free_space / 2)
    {
        possible = false;
    }

    return possible;
}




/* -----------------------------------------------------------------------------
   check_free_space

   Check if there is enough free space to add a message to the download list.

   Inputs
   message_size:    size of message
   free_space:      free space
   largest_message: largest message added to download list so far

   Returns
   true:  enough free space to add message
   false: not enough free space to add message
 */

bool  document_t::check_free_space (message_t *const    message,
                                    const unsigned int  largest_message)
{
    unsigned int  temp_largest_message;

    if (message->size > largest_message)
    {
        temp_largest_message = message->size;
    }
    else
    {
        temp_largest_message = largest_message;
    }

    if (HWM_MailRx_Extra (message->decoded_size_estimate +
                          (temp_largest_message - largest_message)) == 0)
    {
        // Enough space to add this message to the download and decode the
        // largest message added to this download so far.
        return true;
    }

    return false;
}




/* -----------------------------------------------------------------------------
   update_free_space

   Update the amount of free space given the size of a message that has been
   added to the download list.

   Inputs
   message_size:    size of message just added
   space_reserved:  total amount of space reserved for this download so far
   largest_message: largest message added to download list so far

   Outputs
   space_reserved:  total amount of space reserved for this download so far
   largest_message: possibly updated largest message
 */

void  document_t::update_free_space (message_t *const  message,
                                     unsigned int &    space_reserved,
                                     unsigned int &    largest_message)
{
    if (message->size > largest_message)
    {
        space_reserved += message->size - largest_message;
        largest_message = message->size;
    }

    space_reserved += message->decoded_size_estimate;

    HWM_MailRx_Usage (0,
                      space_reserved);
}




/* -----------------------------------------------------------------------------
   document_t::add_to_download

   Check whether a document should be included in the download and if so,
   flag it to indicate this.

   Inputs
   space_reserved:  space reserved for this download so far (bytes)
   largest_message: largest email message in this download so far (bytes)

   Outputs
   free_space
   largest_message

   Returns
   0: document dealt with succesfully: either added to download or ignored if
      it's already been downloaded
   1: document needs downloading but there's not enough free space
 */

int document_t::add_to_download (unsigned int  &space_reserved,
                                 unsigned int  &largest_message)
{
    // Only one message per document for all documents except netfax fax
    // documents
    message_t *  message = (message_t *) list_head (message_list);
    int          rc = 0;

    message->flags.bits.download = 0;

    if (message->flags.bits.downloaded == 0)
    {
        if (check_free_space (message,
                              largest_message))
        {
            message->flags.bits.download = 1;
            flags.printing_required = true;

            update_free_space (message,
                               space_reserved,
                               largest_message);

        }
        else
        {
            // This document will be left on the server.  Flag this so that we
            // can automatically reconnect when there is more space available.

            rc = 1;
        }
    }

    // added document successfully: continue building download list
    return rc;
}




list_handle document_t::get_message_list (void)
{
    return message_list;
}




/* -----------------------------------------------------------------------------
   document_t::get_number_pages

   Get the number messages document which have a certain set of flags.

   Returns
   number of pages
 */

int  document_t::get_number_messages (const unsigned int  flags_mask,
                                      const unsigned int  flags_match)
{
    int              number_messages = 0;
    message_t *      message;
    list_iterator_t  i;

    list_initialise_iterator (&i,
                              message_list);

    for (message = (message_t *) M_list_reset (i);
         !M_list_finished (i);
         message = (message_t *) M_list_next (i))
    {
        if ((message->flags.value & flags_mask) == flags_match)
        {
            ++number_messages;
        }
    }

    return number_messages;
}




/* -----------------------------------------------------------------------------
   document_t::get_number_pages

   Get the number of pages in a document that are within messages with a
   certain set of flags.

   Returns
   number of pages
 */

int  document_t::get_number_pages (const unsigned int  flags_mask,
                                   const unsigned int  flags_match)
{
    message_t *      message;


    message = (message_t *) list_head (message_list);
    if (message &&
        (message->flags.value & flags_mask) == flags_match)
    {
        return 1;
    }

    return 0;
}




/* -----------------------------------------------------------------------------
   document_t::need_printed_page_report

   Decide whether a printed page report is needed for a document.

   Returns:
   true:  printed page report required
   false: printed page report not required
 */

bool  document_t::need_printed_page_report (void)
{
    if (return_receipt_address != NULL)
    {
        return true;
    }

    return false;
}




/* -----------------------------------------------------------------------------
   document_t::printed_page_report

   Generate tokens for printed page reports that are common to all types of
   document.

   Inputs
   filename: file in which to dump printed 'page' report
   header:   header for email message being printed

   Returns
   success: 0
   failure: -1
 */

int document_t::printed_page_report (FILE *const         file,
                                     const NFE_header &  header)
{
    NFE_address  from_address;

    if (*setup_from_mailaddress == '\0')
    {
        return -1;
    }
    from_address.address = setup_from_mailaddress;

    if (*setup_contact_name == '\0')
    {
        from_address.real_name = NULL;
    }
    else
    {
        from_address.real_name = setup_contact_name;
    }

    char *raw_from_address = emailrx_construct_full_address (&from_address,
                                                             0);
    if (raw_from_address == NULL)
    {
        return -1;
    }

    char *     raw_date;
    size_t     date_len;
    NFE_rcode  rc;
    date       date_processed (FALSE,
                               NULL,
                               0,
                               0,
                               TRUE);
    rc = date_processed.GetBodyLen (date_len);
    if (rc != NFE_COMPLETED)
    {
        free (raw_from_address);
        return -1;
    }

    raw_date = malloc (date_len + 2);
    if (raw_date == NULL)
    {
        free (raw_from_address);
        return -1;
    }

    ++date_len;
    rc = date_processed.GetUnfoldedBody (raw_date,
                                         date_len);
    if (rc != NFE_COMPLETED)
    {
        free (raw_date);
        free (raw_from_address);
        return -1;
    }

    int file_rc;

    file_rc = fprintf (file,
                       "TYPE=PRINTEDPAGES\n"
                       "DATESENT=%s\n"
                       "FROM=%s\n"
                       "DATEPROCESSED=%s\n",
                       header.date_hdr,
                       raw_from_address,
                       raw_date);

    free (raw_from_address);
    free (raw_date);
    if (file_rc < 0)
    {
        return -1;
    }


    return 0;
}




int document_t::cover_sheet (char *const         report,
                             size_t              report_size,
                             const NFE_header &  header)
{
    // No concept of pages for all documents except netfax fax documents so
    // impossible to ever have a cover sheet

    M_unused (report);
    M_unused (report_size);
    M_unused (header);

    return 0;
}




void document_t::tidy (void)
{
    if (get_number_messages (MessageFlags_Printed,
                             0) == 0)
    {
        remove_from_list (document_list);
    }
    else
    {
        update_flags ();
    }
}




/* -----------------------------------------------------------------------------
   document_t::update_flags

   Update a document's flags after a stage of processing has been completed.

   Documents which have been downloaded have their download flag cleared since
   they won't need to be downloaded again.

   Documents which have their printed flag set have their just printed flag
   cleared.
 */

void  document_t::update_flags (void)
{
    message_t *      message;
    list_iterator_t  i;

    flags.printing_required = false;

    list_initialise_iterator (&i,
                              message_list);

    for (message = (message_t *) M_list_reset (i);
         !M_list_finished (i);
         message = (message_t *) M_list_next (i))
    {
        if (message->flags.bits.downloaded)
        {
            message->flags.bits.download = 0;
        }

        if (message->flags.bits.printed)
        {
            message->flags.bits.just_printed = 0;
        }
    }
}




/* -----------------------------------------------------------------------------
   document_t::requires_printing

   Determine whether any printing needs to take place for a document.  This
   could be part of the document itself or a missing page report for the
   document etc.
 */

bool  document_t::requires_printing (void)
{
    return (bool) flags.printing_required;
}




/* -----------------------------------------------------------------------------
   document_t::is_new

   Determine whether this is the first time this document has been seen.
   'Seen' is defined by calling this method, so the first time it's called
   the document will be unseen, and then seen for all subsequent calls.
 */

bool  document_t::is_new (void)
{
    if (flags.is_new)
    {
        flags.is_new = false;
        return true;
    }

    return false;
}




netfax_document_t::netfax_document_t (const NFE_header &  header,
                                      const char *const   id,
                                      bool &              success)
    : document_t (header,
                  id,
                  success)
{
    netfax_message_class        = header.netfax_msg_class;
}




message_t *netfax_document_t::add_message (
               const unsigned int      size,
               const char *const       unique_id,
               const NFE_message_id &  nf_message_id,
               const unsigned int      max_free_space,
               bool &                  delete_message,
               bool &                  impossible)
{
    delete_message = false;

    if (!download_possible (max_free_space,
                            size))
    {
        impossible = true;
        return NULL;
    }

    impossible = false;


    // Create new message information structure
    message_t *  message = add_message_common (size,
                                               unique_id);
    if (message == NULL)
    {
        return NULL;
    }


    // All types of netfax messages must always have meaningful information in
    // the netfax message id, so just copy the netfax message id.
    message->nf_message_id = nf_message_id;
    message->nf_message_id = nf_message_id;

    // Add message to document's message list.  There is no concept of pages
    // or ordering for these netfax message classes so just add the message
    // to the end of the document's message list.
    list_item_handle message_item_handle = list_add_item (message_list,
                                                          message);
    if (message_item_handle == NULL)
    {
        free (message->unique_id);
        free (message);
        return NULL;
    }
    message->item_handle = message_item_handle;

    return message;
}




netfax_fax_document_t::netfax_fax_document_t (const NFE_header &  header,
                                              const char *const   id,
                                              bool &              success)
    : netfax_document_t (header,
                         id,
                         success)
{
    memcpy (document_id.serial_num,
            header.details.serial_num,
            SERIAL_LEN);

    document_id.device_class    = header.details.device_class;
    document_id.document_number = header.id.doc_num;

    nf_fax_flags.split_download     = false;
    nf_fax_flags.exact_number_pages = (bool) header.id.exact_num_pages;
    nf_fax_flags.physically_split   = false;
    nf_fax_flags.dsc                = false;

    connection_count       = 0;
    total_number_pages     = 0;
}




/* -----------------------------------------------------------------------------
   netfax_fax_document_t::match_doc

   NetFax fax document matching routine for document list searching.

   Inputs
   data1: pointer to current document in list
   data2: pointer to details of document being searched for

   Returns
   1: match
   0: no match
 */

int  netfax_fax_document_t::match_doc (const void *const  data1,
                                       const void *const  data2)
{
    const netfax_fax_document_t &  document    =
        *((netfax_fax_document_t *const) data1);

    const netfax_document_id &     document_id =
        *((netfax_document_id *) data2);


    return (document == document_id);
}




int netfax_fax_document_t::operator== (const netfax_document_id &  id) const
{
    return (document_id.device_class == id.device_class &&
            document_id.document_number == id.document_number &&
            memcmp (document_id.serial_num,
                    id.serial_num,
                    SERIAL_LEN) == 0);
}




message_t *netfax_fax_document_t::add_message (
               const unsigned int      size,
               const char *const       unique_id,
               const NFE_message_id &  nf_message_id,
               const unsigned int      max_free_space,
               bool &                  delete_message,
               bool &                  impossible)
{
    message_t *  message;

    delete_message = false;
    impossible     = false;


    // Don't want to actually add message to this document's message list if
    // the message is a dcs.
    if (nf_message_id.first_page_num != 0 && nf_message_id.last_page_num != 0)
    {
        if (!download_possible (max_free_space,
                                size))
        {
            impossible = true;
            return NULL;
        }

        // Create new message information structure
        message = add_message_common (size,
                                      unique_id);
        if (message == NULL)
        {
            goto no_mem;
        }


        // All types of netfax messages must always have meaningful information
        // in the netfax message id, so just copy the netfax message id.
        message->nf_message_id = nf_message_id;

        // Add message to document's message list.  Fax messages must be ordered
        // by page number
        list_item_handle message_item_handle =
            list_add_item_ordered (message_list,
                                   message,
                                   compare_page_nums);
        if (message_item_handle == NULL)
        {
            goto no_mem;
        }

        message->item_handle = message_item_handle;
    }
    else
    {
        delete_message = true;
    }


    // msg_num_pages is actually the (minimum) number of pages in the
    // whole document so although this section of code below may look
    // strange, it is in fact alright.
    //
    // For documents which do not have an exact known number of pages,
    // subsequent messages may increase (but never decrease) the minimum
    // number of pages.

    if (nf_message_id.msg_num_pages > total_number_pages)
    {
        total_number_pages = nf_message_id.msg_num_pages;
    }

    if (nf_message_id.first_page_num == 0 && nf_message_id.last_page_num == 0)
    {
        // Document size confirmation; means that the exact number of pages
        // for this document is now known.
        //
        // This document is flagged as having a D.S.C., but no message is
        // added to the list (we would never want to actually download the
        // complete message as we can get all the info we need from the
        // headers).

        nf_fax_flags.exact_number_pages = true;
        nf_fax_flags.dsc                = true;
        flags.printing_required         = true;
    }

    return message;


no_mem:
    if (message)
    {
        if (message->unique_id)
        {
            free (message->unique_id);
        }

        free (message);
    }

    return NULL;
}




void netfax_fax_document_t::remove_message (const message_t &  message)
{
    list_remove_item (message_list,
                      message.item_handle);
}




/* -----------------------------------------------------------------------------
   document_t::download_possible

   Determine whether it would ever be possible to download and decode a
   message of a certain size (ie. whether there could ever be enough free
   space).

   Inputs
   max_free_space: maximum possible amount of free space (bytes)
   message_size:   size of this message

   Returns
   false: impossible to download this message
   true:  possible to download this message
 */

bool  netfax_fax_document_t::download_possible (
          const unsigned int  max_free_space,
          const unsigned int  message_size)
{
    bool  possible = true;

    // Needs to be enough free space to hold raw message and decoded message
    // at the same time.  If raw message contains only fax pages then the
    // decoded message will be at most 75% the size of the original message.
    // If the message is a mixture of fax pages and other NetFax data (eg.
    // RText) then all we can say that the decoded message will be at most the
    // same size as the original message.

    if ((netfax_message_class & ~NFE_NFMC_FAX) == 0)
    {
        if (message_size + (unsigned int) ((double) message_size * 0.75) >
                max_free_space)
        {
            possible = false;
        }
    }
    else
    {
        if (message_size > max_free_space / 2)
        {
            possible = false;
        }
    }

    return possible;
}




/* -----------------------------------------------------------------------------
   check_free_space

   Check if there is enough free space to add a message to the download list.

   Inputs
   message_size:    size of message
   free_space:      free space
   largest_message: largest message added to download list so far

   Returns
   true:  enough free space to add message
   false: not enough free space to add message
 */

bool  netfax_fax_document_t::check_free_space (
          message_t *const    message,
          const unsigned int  largest_message)
{
    if ((netfax_message_class & ~NFE_NFMC_FAX) == 0)
    {
        message->decoded_size_estimate =
            (unsigned int) ((double) message->size * 0.75);
    }

    return document_t::check_free_space (message,
                                         largest_message);
}




/* -----------------------------------------------------------------------------
   netfax_fax_document_t::add_to_download

   Check whether a document should be included in the download and if so,
   flag it to indicate this.

   Inputs
   space_reserved:  space reserved for this download so far (bytes)
   largest_message: largest email message in this download so far (bytes)

   Outputs
   free_space
   largest_message

   Returns
   0: document dealt with succesfully: either added to download or ignored if
      it's already been downloaded
   1: document needs downloading but there's not enough free space
   2: document needs downloading but there's only enough free space for part of
      it to be downloaded
 */

int netfax_fax_document_t::add_to_download (unsigned int &  space_reserved,
                                            unsigned int &  largest_message)
{
    if (++connection_count == g_missing_page_threshold &&
        get_number_missing_pages () > 0)
    {
        flags.printing_required = true;
    }

    int              rc = 0;
    list_iterator_t  message_iterator;
    bool             download = false;

    // Iterate over the message list for this document, adding as many
    // messages from it to the download list as possible.

    list_initialise_iterator (&message_iterator,
                              message_list);

    message_t *  message =
        (message_t *) (message_iterator.reset) (&message_iterator);

    while (!(message_iterator.finished) (&message_iterator))
    {
        message->flags.bits.download = 0;

        if (message->flags.bits.downloaded == 0)
        {
            if (check_free_space (message,
                                  largest_message))
            {
                message->flags.bits.download = 1;
                flags.printing_required      = true;
                download                     = true;

                update_free_space (message,
                                   space_reserved,
                                   largest_message);
            }
            else
            {
                // There is not enough space to download all messages in
                // this document.
                //
                // 1. If some messages for this document have already been
                // marked for download then don't mark anything more for
                // download: just download what we already have, disconnect,
                // then reconnect to get the rest of the document and any others
                // we have space for.
                //
                // 2. If no messages for this document have been added to
                // the download list then just skip the rest of the messages
                // for this document and try to add other documents to the
                // download list (if we didn't do this and there was a
                // really large message on the server then it could prevent
                // any downloads for ages).
                //
                // If we do download part of a document with the intention
                // of getting the rest on the next connection then the
                // document must be flagged to indicate this.  Otherwise for
                // documents that fall into category 1. above,
                // when the second connection happens the rest of the
                // document could appear to fall into category 2. above and
                // we would end up with pyhsically split documents.

                if (download || nf_fax_flags.split_download)
                {
                    // not enough space to add this document: don't add anything
                    // else to the download list.
                    nf_fax_flags.split_download = true;
                    return 2;
                }
                else
                {
                    // Skip this document and try the next.  This document will
                    // be left on the server, so flag this so that we can
                    // automatically reconnect when there's more space available
                    rc = 1;
                    break;    // break out of enclosing while loop
                }
            }
        }

        message = (message_t *) (message_iterator.next) (&message_iterator);
    }

    // A split download situation also occurs if the number of pages in the
    // part of the document to be downloaded is less than the minimum
    // number of pages known to exist for that document (ie. not all the
    // document has arrived on the server yet).

    if (download &&
        get_number_pages (0,
                          0) < total_number_pages)
    {
        nf_fax_flags.split_download = true;
        nf_fax_flags.physically_split = true;
    }


    // dealt with document successfully: continue deciding download
    return rc;
}




/* -----------------------------------------------------------------------------
   netfax_fax_document_t::get_number_pages

   Get the number of pages in a NetFax fax document that are within messages
   with a certain set of flags.

   Returns
   number of pages
 */

int  netfax_fax_document_t::get_number_pages (const unsigned int  flags_mask,
                                              const unsigned int  flags_match)
{
    int              number_pages = 0;
    message_t *      message;
    list_iterator_t  i;

    list_initialise_iterator (&i,
                              message_list);

    for (message = (message_t *) M_list_reset (i);
         !M_list_finished (i);
         message = (message_t *) M_list_next (i))
    {
        if ((message->flags.value & flags_mask) == flags_match)
        {
            number_pages += (message->nf_message_id.last_page_num -
                             message->nf_message_id.last_page_num) + 1;
        }
    }

    return number_pages;
}




/* -----------------------------------------------------------------------------
   netfax_fax_document_t::need_missing_page_report

   Decide whether a missing page report is required for a NetFax fax document.

   Returns
   true:  missing page report required
   false: missing page report not required
 */

bool  netfax_fax_document_t::need_missing_page_report (void)
{
    if (connection_count == g_missing_page_threshold &&
        get_number_missing_pages () > 0)
    {
        return true;
    }

    return false;
}




/* -----------------------------------------------------------------------------
   netfax_fax_document_t::generate_missing_page_report

   Generate a missing page report for a NetFax fax document.

   Currently assumes that there will never be more than 9999 pages in a single
   document.

   Inputs
   document_info:          document handle as returned by document iterator
   remote_report_filename: name of file to write remote report into
   header:                 email header information for this document

   Returns
   success: pointer to local report - client's responsibility to free
   failure: NULL
 */

char *  netfax_fax_document_t::generate_missing_page_report (
            char *const         remote_report_filename,
            const NFE_header &  header)
{
    char *  local_report;
    char    pages_list[MaxParamSize + 1];


    // Missing pages list
    *pages_list = '\0';
    if (missing_page_list (pages_list,
                           sizeof (pages_list)))
    {
        return NULL;
    }


    char *full_address = emailrx_construct_full_address (&header.from,
                                                         (int) true);
    if (full_address == NULL)
    {
        return NULL;
    }

    local_report = emailrx_generate_report_from_message (
                       "MissingPageL",
                       header.date_hdr,
                       full_address,
                       pages_list,
                       NULL);

    free (full_address);

    if (local_report == NULL)
    {
        return NULL;
    }

    // Write out the tokenised remote report to a file
    FILE *  file;

    file = fopen (remote_report_filename,
                  "w");
    if (file == NULL)
    {
        return NULL;
    }

    full_address = emailrx_construct_full_address (&header.to,
                                                   (int) false);
    if (full_address == NULL)
    {
        fclose (file);
        return NULL;
    }

    if (fprintf (file,
                 "[TOKENISED]\n"
                 "TYPE=MISSINGPAGES\n"
                 "FROM=%s\n"
                 "PAGES=%s\n"
                 "DATESENT=%s\n"
                 "DATEPROCESSED=",
                 full_address,
                 pages_list,
                 header.date_hdr) < 0)
    {
        fclose (file);
        free (full_address);
        return NULL;
    }

    free (full_address);

    date  date_processed (FALSE,
                          NULL,
                          0,
                          0,
                          TRUE);

    unsigned int  body_len;
    char *        body;

    if (date_processed.GetBodyLen (body_len) != NFE_COMPLETED)
    {
        fclose (file);
        return NULL;
    }

    body = new char[body_len + 2];
    if (body == NULL)
    {
        fclose (file);
        return NULL;
    }

    ++body_len;
    if (date_processed.GetUnfoldedBody (body,
                                        body_len) != NFE_COMPLETED)
    {
        delete[] body;
        fclose (file);
        return NULL;
    }

    if (fputs (body,
               file))
    {
        delete[] body;
        fclose (file);
        return NULL;
    }

    delete[] body;

    if (fputs ("\n[END]\n",
               file))
    {
        fclose (file);
        return NULL;
    }

    fclose (file);

    return local_report;
}




/* -----------------------------------------------------------------------------
   netfax_fax_document_t::need_printed_page_report

   Decide whether a printed page report is required for this document.
 */

bool  netfax_fax_document_t::need_printed_page_report (void)
{
    if (return_receipt_address != NULL &&
        get_number_messages (MessageFlags_JustPrinted,
                             MessageFlags_JustPrinted) > 0)
    {
        return true;
    }

    return false;
}




/* -----------------------------------------------------------------------------
   netfax_fax_document_t::printed_page_report

   Generate tokens for printed page reports that are specific to NetFax fax
   documents.

   Inputs
   file:   file descriptor of file in which to dump printed 'page' report
   header:
   header for email message being printed

   Returns
   success: 0
   failure: -1
 */

int netfax_fax_document_t::printed_page_report (FILE *const         file,
                                                const NFE_header &  header)
{
    if (document_t::printed_page_report (file,
                                         header) != 0)
    {
        return -1;
    }

    char pages_list[MaxParamSize + 1];
    *pages_list = '\0';

    // This is not very elegant at the moment.  There's no reason (apart
    // from lack of time) why page_list should not be modified so it can write
    // to a file, thereby not being constrained by arbitrary maximium size;

    if (page_list (pages_list,
                   sizeof (pages_list),
                   MessageFlags_JustPrinted,
                   MessageFlags_JustPrinted))
    {
        return -1;
    }

    if (fprintf (file,
                 "PAGES=%s\n",
                 pages_list) < 0)
    {
        return -1;
    }

    return 0;
}




int netfax_fax_document_t::cover_sheet (char *const         report,
                                        size_t              report_size,
                                        const NFE_header &  header)
{
    if (nf_fax_flags.dsc)
    {
        // document size confirmation required
        return document_size_confirmation (report,
                                           report_size,
                                           header);
    }

//     else if (!nf_fax_flags.exact_number_pages || nf_fax_flags.split_download)
    else if (nf_fax_flags.physically_split &&
             get_number_messages (MessageFlags_Printing | MessageFlags_Printed,
                                  0) > 0)
    {
        // cover sheet required
        return page_range_report (report,
                                  report_size,
                                  header);
    }

    return 0;
}




int netfax_fax_document_t::page_range_report (char *const         report,
                                              size_t              report_size,
                                              const NFE_header &  header)
{
    enum
    {
        SinglePage_Exact,
        SinglePage_Unknown,
        MultiPage_Exact,
        MultiPage_Unknown
    };
    // The ordering of the coversheet tokens in the following array *MUST*
    // follow the ordering of the above enum.
    static const char *  coversheet_token[] =
    {
        "CSBodySPE",
        "CSBodySPU",
        "CSBodyMPE",
        "CSBodyMPU"
    };
    char                 param[4][MaxParamSize + 1];
    char                 buffer[MessageBufferSize + 1];
    const char *         read_only_buffer;
    int                  coversheet_type;
    int                  string_len;
    _kernel_oserror *    e;


    // Check that there is enough space for at least a '\0' terminator in
    // the report string.  If not return an error.  Also, decrement the
    // report size by one so that all checks automatically take account of a
    // '\0' terminator.

    if (--report_size < 1)
    {
        return 1;
    }
    report[0] = '\0';


    if (get_number_pages (MessageFlags_Printing | MessageFlags_Printed,
                          0) == 1)
    {
        if (nf_fax_flags.exact_number_pages)
        {
            coversheet_type = SinglePage_Exact;
        }
        else
        {
            coversheet_type = SinglePage_Unknown;
        }
    }
    else
    {
        if (nf_fax_flags.exact_number_pages)
        {
            coversheet_type = MultiPage_Exact;
        }
        else
        {
            coversheet_type = MultiPage_Unknown;
        }
    }

    // Generate cover sheet title
    e = _swix (MessageTrans_Lookup,
               _INR (0, 7) | _OUTR (2, 3),

               report_templates,
               "CSTitle",
               0,    // direct pointer to read-only result
               0,    // size of buffer N/A
               0,
               0,
               0,
               0,

               &read_only_buffer,
               &string_len);

    if (e != NULL)
    {
        return 1;
    }

    if (report_size < string_len)
    {
        return 1;
    }
    strncat (report, read_only_buffer, string_len);
    report_size -= string_len;

    if (report_size < 2)
    {
        return 1;
    }
    strcat (report, "\n\n");
    report_size -= 2;

    // Generate cover sheet document id
    sprintf (param[0],
             "%d",
             document_id.document_number);

    char *full_address = emailrx_construct_full_address (&header.from,
                                                         (int) true);
    if (full_address == NULL)
    {
        return 1;
    }

    e = _swix (MessageTrans_GSLookup,
               _INR (0, 7) | _OUT (3),

               report_templates,
               "CSId",
               buffer,
               sizeof (buffer),
               param[0],
               full_address,
               0,
               0,

               &string_len);

    free (full_address);

    if (e != NULL)
    {
        return 1;
    }

    if (report_size < string_len)
    {
        return 0;
    }
    strncat (report, buffer, string_len);
    report_size -= string_len;

    if (report_size < 2)
    {
        return 0;
    }
    strcat (report, "\n\n");
    report_size -= 2;

    param[0][0] = '\0';
    if (page_list (param[0],
                   MaxParamSize + 1,
                   MessageFlags_Printing | MessageFlags_Printed,
                   0))
    {
        return -1;
    }

    sprintf (param[1],
             "%d",
             total_number_pages);

    e = _swix (MessageTrans_Lookup,
               _INR (0, 7) | _OUT (3),

               report_templates,
               coversheet_token[coversheet_type],
               buffer,
               sizeof (buffer),
               param[0],
               param[1],
               0,
               0,

               &string_len);

    if (e != NULL)
    {
        return 1;
    }

    if (report_size < string_len)
    {
        return 0;
    }
    strncat (report, buffer, string_len);
    report_size -= string_len;

    if (report_size < 1)
    {
        return 0;
    }
    strcat (report, "\n");
    report_size -= 1;

    return 1;
}





/* -----------------------------------------------------------------------------
   generate_doc_size_conf

   Generate a document size conformation report

   Inputs
   document_info: document handle as returned by document iterator
   report:        pointer to area in which to store explanation text
   report_size:   size of the area in which to store explanation text

   Returns
   success: 0
   failure: 1
 */

int netfax_fax_document_t::document_size_confirmation (
        char *const         report,
        size_t              report_size,
        const NFE_header &  header)
{
    enum
    {
        SinglePage_Now_SinglePage,
        SinglePage_Now_MultiPage,
        MultiPage
    };
    // The ordering of the tokens in the following array *MUST*
    // follow the ordering of the above enum.
    static const char *  dsc_token[] =
    {
        "DSCBodySPSP",
        "DSCBodySPMP",
        "DSCBodyMP"
    };
    char                 param[4][MaxParamSize + 1];
    char                 buffer[MessageBufferSize + 1];
    const char *         read_only_buffer;
    int                  dsc_type;
    int                  string_len;
    _kernel_oserror *    e;


    // Check that there is enough space for at least a '\0' terminator in
    // the report string.  If not return an error.  Also, decrement the
    // report size by one so that all checks automatically take account of a
    // '\0' terminator.
    if (--report_size < 1)
    {
        return 1;
    }
    report[0] = '\0';

    // Decide what type of dsc is required
    if (total_number_pages == 1)
    {
        dsc_type = SinglePage_Now_SinglePage;
    }
    else
    {
        if (get_number_pages (MessageFlags_Printing | MessageFlags_Printed,
                              0) == 1)
        {
            dsc_type = SinglePage_Now_MultiPage;
        }
        else
        {
            dsc_type = MultiPage;
        }
    }

    // Generate dsc title
    e = _swix (MessageTrans_Lookup,
               _INR (0, 7) | _OUTR (2, 3),

               report_templates,
               "DSCTitle",
               0,    // direct pointer to read-only result
               0,    // size of buffer N/A
               0,
               0,
               0,
               0,

               &read_only_buffer,
               &string_len);

    if (e != NULL)
    {
        return 1;
    }

    if (report_size < string_len)
    {
        return 1;
    }
    strncat (report, read_only_buffer, string_len);
    report_size -= string_len;

    if (report_size < 2)
    {
        return 1;
    }
    strcat (report, "\n\n");
    report_size -= 2;

    // Generate dsc document id
    sprintf (param[0],
             "%d",
             document_id.document_number);

    char *full_address = emailrx_construct_full_address (&header.from,
                                                         (int) true);
    if (full_address == NULL)
    {
        return 1;
    }

    e = _swix (MessageTrans_GSLookup,
               _INR (0, 7) | _OUT (3),

               report_templates,
               "DSCId",
               buffer,
               sizeof (buffer),
               param[0],
               full_address,
               0,
               0,

               &string_len);

    free (full_address);

    if (e != NULL)
    {
        return 1;
    }

    if (report_size < string_len)
    {
        return 0;
    }
    strncat (report, buffer, string_len);
    report_size -= string_len;

    if (report_size < 2)
    {
        return 0;
    }
    strcat (report, "\n\n");
    report_size -= 2;

    // Create body text of dsc
    switch (dsc_type)
    {
        case SinglePage_Now_SinglePage:
            e = _swix (MessageTrans_Lookup,
                       _INR (0, 7) | _OUT (3),

                       report_templates,
                       dsc_token[dsc_type],
                       buffer,
                       sizeof (buffer),
                       0,
                       0,
                       0,
                       0,

                       &string_len);
            break;

        case SinglePage_Now_MultiPage:
            sprintf (param[0],
                     "%d",
                     total_number_pages);

            e = _swix (MessageTrans_Lookup,
                       _INR (0, 7) | _OUT (3),

                       report_templates,
                       dsc_token[dsc_type],
                       buffer,
                       sizeof (buffer),
                       param[0],
                       0,
                       0,
                       0,

                       &string_len);
            break;


        case MultiPage:
            sprintf (param[0],
                     "%d",
                     get_number_pages (0,
                                       0));

            sprintf (param[1],
                     "%d",
                     total_number_pages);

            e = _swix (MessageTrans_Lookup,
                       _INR (0, 7) | _OUT (3),

                       report_templates,
                       dsc_token[dsc_type],
                       buffer,
                       sizeof (buffer),
                       param[0],
                       param[1],
                       0,
                       0,

                       &string_len);
            break;

       default:
            return 1;
    }

    if (e != NULL)
    {
        return 1;
    }

    if (report_size < string_len)
    {
        return 0;
    }
    strncat (report, buffer, string_len);
    report_size -= string_len;

    if (report_size < 1)
    {
        return 0;
    }
    strcat (report, "\n");
    report_size -= 1;

    return 1;
}




/* -----------------------------------------------------------------------------
   page_range

   Concatenate a page range onto the end of a string.  Can be used to build a
   list of the form:

   1, 3-5, 8-13, 15, 17

   Inputs
   string:     buffer to hold generated list
   max_len:    maximum length of string excluding 0 terminator
   first_page: first page in range
   last_page:  last page in range

   Outputs
   string: generated list

   Returns
   0: success
   1: failure (length of list exceeds max_len)
  */

int netfax_fax_document_t::page_range (char *const         string,
                                       size_t              max_len,
                                       const unsigned int  first_page,
                                       const unsigned int  last_page)
{
    char    page_range[10];
    size_t  len = strlen (string);


    if (first_page == last_page)
    {
        sprintf (page_range,
                 "%u",
                 first_page);
    }
    else
    {
        sprintf (page_range,
                 "%u-%u",
                 first_page,
                 last_page);
    }

    if (len > 0)
    {
        if (max_len - len < 2)
        {
            return 1;
        }

        strcat (string,
                ", ");
        len += 2;
    }

    if (max_len - len < strlen (page_range))
    {
        return 1;
    }
    strcat (string,
            page_range);

    return 0;
}




/* -----------------------------------------------------------------------------
   netfax_fax_document_t::get_number_missing_pages

   Find the number of pages missing from a NetFax fax document.

   Returns
   number of pages
 */

int netfax_fax_document_t::get_number_missing_pages (void)
{
    int              number_missing_pages = 0;
    unsigned int     last_page = 0;
    message_t        *message;
    list_iterator_t  i;


    list_initialise_iterator (&i,
                              message_list);

    for (message = (message_t *) M_list_reset (i);
         !M_list_finished (i);
         message = (message_t *) M_list_next (i))
    {
        if (message->nf_message_id.first_page_num - last_page > 1)
        {
            number_missing_pages += (message->nf_message_id.first_page_num -
                                     last_page) + 1;
        }

        last_page = message->nf_message_id.last_page_num;
    }

    // Special case: if any pages at the end of the document are missing then
    // the above loop will not catch them.

    if (last_page < total_number_pages)
    {
        number_missing_pages += (total_number_pages - last_page) + 1;
    }


    return number_missing_pages;
}




/* -----------------------------------------------------------------------------
   missing_page_list

   Generate a list of pages missing from a document.  The list is of
   the form:

   1, 3-5, 8-13, 15, 17

   Inputs
   string:      buffer to hold generated list
   max_len:     maximum length of string excluding 0 terminator

   Outputs
   string: generated list

   Returns
   0: success
   1: failure (length of list exceeds max_len)
  */

int netfax_fax_document_t::missing_page_list (char *const  string,
                                              size_t       max_len)
{
    unsigned int     last_page = 0;
    message_t        *message;
    list_iterator_t  i;


    *string = '\0';

    list_initialise_iterator (&i,
                              message_list);

    for (message = (message_t *) M_list_reset (i);
         !M_list_finished (i);
         message = (message_t *) M_list_next (i))
    {
        if (message->nf_message_id.first_page_num - last_page > 1)
        {
            if (page_range (string,
                            max_len,
                            last_page + 1,
                            message->nf_message_id.first_page_num - 1))
            {
                return 1;
            }
        }

        last_page = message->nf_message_id.last_page_num;
    }

    // Special case: if any pages at the end of the document are missing then
    // the above loop will not catch them.

    if (last_page < total_number_pages)
    {
        if (page_range (string,
                        max_len,
                        last_page + 1,
                        total_number_pages))
        {
            return 1;
        }
    }


    return 0;
}




/* -----------------------------------------------------------------------------
   page_list

   Generate a list of pages from messages with specified flags.  The list is of
   the form:

   1, 3-5, 8-13, 15, 17

   Inputs
   string:      buffer to hold generated list
   max_len:     maximum length of string excluding 0 terminator
   flags_mask:  mask to apply to message flags
   flags_match: flags to match after mask has been applied

   Outputs
   string: generated list

   Returns
   0: success
   1: failure (length of list exceeds max_len)
  */

int netfax_fax_document_t::page_list (char *const         string,
                                      size_t              max_len,
                                      const unsigned int  flags_mask,
                                      const unsigned int  flags_match)
{
    bool             found;
    unsigned int     first_page;
    unsigned int     last_page;
    message_t *      message;
    list_iterator_t  i;


    *string = '\0';

    list_initialise_iterator (&i,
                              message_list);

    message = (message_t *) M_list_reset (i);

    while (!M_list_finished (i))
    {
        found = false;

        // Find next message with flags we're looking for.
        while (!M_list_finished (i) && !found)
        {
            if ((message->flags.value & flags_mask) == flags_match)
            {
                first_page = message->nf_message_id.first_page_num;
                last_page = message->nf_message_id.last_page_num;
                found = true;
            }

            message = (message_t *) M_list_next (i);
        }

        if (found)
        {
            found = false;

            // Find last message in this 'block' with the flags we're looking
            // for. Missing pages also terminate a block.
            while (!M_list_finished (i) && !found)
            {
                if (message->nf_message_id.first_page_num - last_page > 1 ||
                    (message->flags.value & flags_mask) != flags_match)
                {
                    found = true;
                }
                else
                {
                    last_page = message->nf_message_id.last_page_num;
                    message = (message_t *) M_list_next (i);
                }
            }

            if (page_range (string,
                            max_len,
                            first_page,
                            last_page))
            {
                return 1;
            }
        }
    }

    return 0;
}




#if 0
void netfax_fax_document_t::message_printed (void)
{
    unsigned int     last_page = 1;
    message_t *      message;
    list_iterator_t  i;

    list_initialise_iterator (&i,
                              message_list);

    for (message = (message_t *) M_list_reset (i);
         !M_list_finished (i);
         message = (message_t *) M_list_next (i))
    {
        if (!message->flags.bits.printed ||
            message->nf_message_id.first_page_num - last_page > 1)
        {
            return;
        }

        last_page = message->nf_message_id.last_page_num;
    }

    // All messages in document have been printed.  If no more are expected then
    // this document can be deleted.
    if (total_number_pages == last_page && nf_fax_flags.exact_number_pages)
    {
        flags.delete_pending = true;
    }
}
#endif




void netfax_fax_document_t::tidy (void)
{
    if (connection_count < g_missing_page_threshold ||
        get_number_messages (MessageFlags_Printed,
                             0) > 0)
    {
        // There are still messages waiting to be printed or the threshold for
        // reporting missing pages has not yet been reached.
        update_flags ();
    }
    else
    {
        remove_from_list (document_list);
    }
}




/* =============================================================================
 * C interface functions
 */

extern "C"
{

/* -----------------------------------------------------------------------------
   emailrx_initialise

   Initialise the email receive code.  Must be called before any other emailrx
   functions.
 */

extern int emailrx_initialise (void)
{
    _kernel_oserror *  e;

    document_list = list_create (free_document);
    if (document_list == NULL)
        return 1;


    /* Claim RMA for MessageTrans file descriptor and pathname */
    e = _swix (OS_Module,
               _IN (0) | _IN (3) | _OUT (2),

               6,
               sizeof (MessagesFD) + strlen (ReportsPath) + 1,

               &report_templates);

    if (e != NULL)
        return 1;

    strcpy ((char *) ((int) report_templates + sizeof (MessagesFD)),
            ReportsPath);

    e = _swix (MessageTrans_OpenFile,
               _INR (0, 2),

               report_templates,
               (int) report_templates + sizeof (MessagesFD),
               0);

    if (e != NULL)
    {
        _swix (OS_Module,
               _IN (0) | _IN (2),

               7,
               report_templates);
        report_templates = NULL;

        return 1;
    }

    return 0;
}




/* -----------------------------------------------------------------------------
   emailrx_finalise

   Close down the email receive code.  Must be called before shutdown or
   resources will be leaked.  May be attached to atexit.
 */

extern void emailrx_finalise (void)
{
    if (report_templates)
    {
        _swix (MessageTrans_CloseFile,
               _IN (0),

               report_templates);

        _swix (OS_Module,
               _IN (0) | _IN (2),

               7,
               report_templates);
    }
}




/* -----------------------------------------------------------------------------
    emailrx_new_message

    Add a new message to the document list.  Tries to cope with low memory
    situations by getting rid of some of the document list.  If this happens
    successfully then the caller may continue processing (ie. download what
    is left in the document list - obviously it shouldn't try to add any more
    messages to the document list).

    Some messages such as Document Size Confirmation contain all the required
    information in the headers, so do not need to be downloaded a second time.
    Such messages will never be added to the download list, so if the download
    list is being used to determine which messages should be deleted then this
    class of message needs to be kept track of separately.  NB. such messages
    should not be deleted instantly - wait for the next session.

    Inputs
    size:             size of message in bytes
    header:           pointer to message headers
    unique_id:        unqiue id returned by POP3 UIDL command
    max_free_space:   maximum conceivable amount of free space

    Outputs
    delete_message:   flag indicating whether the message be marked for
                      deletion immediately

    Returns
    0: message dealt with successfully (NB. not necessarily added)
    1: couldn't add message but managed to recover some memory
    2: couldn't add message and couldn't recover memory
 */

extern int emailrx_new_message (const unsigned int       size,
                                const NFE_header *const  header,
                                const char *const        unique_id,
                                const unsigned int       max_free_space,
                                int *const               delete_message)
{
    unsigned int  message_flags        = 0;
    unsigned int  message_number_lines = 0;
    document_t *  document             = NULL;


    *delete_message = 0;

    /* Check if the message contains a class of data which is supported */
    int support = emailrx_check_supported (header->msg_class,
                                           header->netfax_msg_class);
    if (support == EmailSupport_None)
    {
#if 0
        *delete_message = 1;
#endif
        return 0;
    }


    // Check whether the document that this message belongs to is already in
    // the document list.
    if (header->msg_class == NFE_MC_NETFAX_DATA &&
        (header->netfax_msg_class & NFE_NFMC_FAX))
    {
        // Document contains fax pages, so the document may be made up from
        // multiple messages.  In this case, can't use the unique-id of a
        // single message to determine document uniqueness.

        netfax_document_id new_document_id;

        new_document_id.device_class = header->details.device_class;
        new_document_id.document_number = header->id.doc_num;
        memcpy (new_document_id.serial_num,
                header->details.serial_num,
                SERIAL_LEN);

        document = (document_t *) list_find_item (
                                      document_list,
                                      netfax_fax_document_t::match_doc,
                                      &new_document_id);
    }
    else
    {
        // If a message has no fax pages then it is treated as a completely
        // separate document, even if it is 'logically' part of a document with
        // fax pages.  (eg. if you sent a fax document with an email tagged on
        // the end, but the email got put in a separate message).  This is all
        // hypothetical at the moment because documents cannot yet be split this
        // way, but they may be in the future...

        // All non-fax documents do not have a concept of pages, so each
        // document only has a single message.  This means that we can use the
        // unique-id of the message to determine the document's uniqueness.
        // We can't use the document id, device class etc. for uniqueness of
        // NetFax documents (as we do in NetFax fax documents) because
        // text/plain MIME messages are faked as NetFax rich text by the email
        // library; all text/plain MIME messages are given the same fake
        // document ID, device class etc.

        document = (document_t *) list_find_item (
                                      document_list,
                                      document_t::match_doc,
                                      unique_id);
    }

    bool  document_created = false;
    bool  impossible = false;

    if (document == NULL)
    {
        // document not in document list
        document = create_doc (*header,
                               unique_id);

        if (document == NULL ||
            document->add_to_list (document_list) == NULL)
        {
            goto no_mem;
        }

        document_created = true;
    }
    else
    {
        // Document is already in document list.  Now have to check whether
        // message is already in message list for this document.

        if (list_find_item (document->get_message_list (),
                            match_message,
                            (void *) unique_id))
        {
            // Message is already in message list for this document
            return 0;
        }
    }



    if (document->add_message (size,
                               unique_id,
                               header->id,
                               max_free_space,
                               *((bool *) delete_message),
                               impossible) == NULL)
    {
        if (impossible)
        {
            // Given the maximum possible amount of free space that could ever
            // be available for message downloads, we would never be able to
            // download and decode this message.

            if (document_created)
            {
                document->remove_from_list (document_list);
            }
        }
        else
        {
            goto no_mem;
        }
    }


    return 0;

no_mem:
     /* Not enough memory to add a new document.  Get rid of some
      * of the document list to free up some space.
      */

    if (truncate_doc_list () > 0)    /* was able to free space */
    {
        return 1;
    }
    else
    {
        return 2;
    }
}




/* -----------------------------------------------------------------------------
   emailrx_decide_download

   Build the list of documents to download given an amount of free space.

   Outputs
   space_reserved: amount of space reserved for this download (bytes)

   Returns
   0: all messages on server dealt with successfully
   1: not enough space to download all messages; reconnect ASAP
 */

extern int  emailrx_decide_download (unsigned int *const  space_reserved)
{
    int              rc = 0;
    unsigned int     largest_message = 0;
    list_iterator_t  i;
    document_t *     document;


    list_initialise_iterator (&i,
                              document_list);

    for (document = (document_t *) M_list_reset (i);
         !M_list_finished (i);
         document = (document_t *) M_list_next (i))
    {
        switch (document->add_to_download (*space_reserved,
                                           largest_message))
        {
            case 1:
                // document couldn't be added to download due to lack of memory
                rc = 1;
                break;

            case 2:
                // not enough free space for whole of document: don't try to add
                // anything else to the download, just make do with what we've
                // already got (so we don't interleave documents).
                return 1;

            default:
                break;
        }
    }

    return rc;
}




/* -----------------------------------------------------------------------------
   emailrx_need_missing_page_report

   Decide whether a missing page report needs to be generated for a document.

   Currently assumes that there will never be more than 9999 pages in a single
   document.

   Inputs
   document_info: document handle as returned by document iterator

   Returns
   0: missing page report not required
   1: missing page report required
 */

extern int emailrx_need_missing_page_report (const document_handle    document)
{
    if (((document_t *) document)->need_missing_page_report ())
    {
        return 1;
    }

    return 0;
}




/* -----------------------------------------------------------------------------
   emailrx_generate_missing_page_report

   Generate a missing page report for a document.

   Currently assumes that there will never be more than 9999 pages in a single
   document.

   Inputs
   document_info:          document handle as returned by document iterator
   remote_report_filename: name of file to write remote report into
   header:                 email headers for this document

   Returns
   -1: error
    0: success
 */

extern char *  emailrx_generate_missing_page_report (
                   const document_handle    document,
                   char *const              remote_report_filename,
                   const NFE_header *const  header)
{
    return ((document_t *) document)->generate_missing_page_report (
                                          remote_report_filename,
                                          *header);
}




/* -----------------------------------------------------------------------------
   emailrx_need_printed_page_report

   Decide whether a printed page report is required for a document.

   Inputs
   document: document to test

   Returns
   printed page report not required: 0
   printed page report required:     1
 */

extern int  emailrx_need_printed_page_report (const document_handle    document)
{
    if (((document_t *) document)->need_printed_page_report ())
    {
        return 1;
    }

    return 0;
}




/* -----------------------------------------------------------------------------
   emailrx_printed_page_report

   Generate a printed page report for a document, dumping it in a file.

   Currently assumes that there will never be more than 9999 pages in a single
   document.

   Inputs
   document: document handle as returned by document iterator
   filename: name of file to dump printed page report in
   header:   email message header information

   Returns
   -1: failure
    0: success
 */

extern int emailrx_printed_page_report (
               const document_handle    document,
               const char *const        filename,
               const NFE_header *const  header)
{
    FILE *  file;

    file = fopen (filename,
                  "w");
    if (file == NULL)
    {
        return -1;
    }


    if (fprintf (file,
                 "[TOKENISED]\n") < 0)
    {
        fclose (file);
        return -1;
    }

    if (((document_t *) document)->printed_page_report (file,
                                                        *header) != 0)
    {
        fclose (file);
        return -1;
    }

    fprintf (file,
             "[END]\n");

    fclose (file);

    return 0;
}




/* -----------------------------------------------------------------------------
   emailrx_cover_sheet

   Decide if some sort of cover sheet needs to be printed out for a document.
   This could happen if the exact number of pages in the document is not
   known or if a document is printed out in several chunks.  Also, if a dummy
   fax page (indicating the exact number of pages for a document that previously
   had an unknown number of pages) has been received in isolation then this
   information needs to be printed.

   Inputs
   document_info: document handle as returned by document iterator
   report:        pointer to area in which to store explanation text
   report_size:   size of the area in which to store explanation text

   Returns
   -1: error
    0: cover sheet not required
    1: cover sheet required
 */

extern int emailrx_cover_sheet (const document_handle    document,
                                char *const              report,
                                size_t                   report_size,
                                const NFE_header *const  header)
{
    /* Note that if a dsc is seen in the same session as real pages for the
     * document to which it refers then the following happens:
     *
     * 1. If all pages for the document are downloaded in that session then all
     * of the document will be printed in one go, so no special explanation is
     * required.
     *
     * 2. If only part of the document is downloaded then a cover sheet is
     * required to inform the user which section of the document has been
     * printed.  However, the exact number of pages is now known, so this
     * information can be conveyed in the cover sheet (which will say
     * "pages x to y of z" instead of "pages x to y of at least z").  This
     * avoids having to print out a separate dsc at the end.
     */

    return ((document_t *) document)->cover_sheet (report,
                                                   report_size,
                                                   *header);
}




/* -----------------------------------------------------------------------------
   emailrx_destory_dl_list

   Destroy a document list.

   Inputs
   download_list: the handle of the list to destroy
 */

extern void emailrx_destroy_dl_list (list_handle download_list)
{
    list_destroy (download_list);
}




/* -----------------------------------------------------------------------------
   emailrx_get_doc_list

   Get the list handle of the document list.

   Returns
   list handle
 */

extern list_handle emailrx_get_doc_list (void)
{
    return document_list;
}




/* -----------------------------------------------------------------------------
   emailrx_get_doc_msg_list

   Return the message list handle for a document.

   Inputs
   document_info: handle of document

   Returns
   list handle
 */

extern list_handle emailrx_get_doc_msg_list (
                       const document_handle document)
{
    assert (document != NULL);

    return ((document_t *) document)->get_message_list ();
}




/* -----------------------------------------------------------------------------
   emailrx_check_supported

   Given a message class and netfax message class for an entity, decide if
   it conatains data that is supported.  The degree of support can vary: eg.
   RFC822 messages with no netfax headers in can be handled, but only the first
   60 lines are downloaded because the message may contain 2MB worth of
   UUEncoded data for all we know!

   It is also possible for an entity to contain some types of data that are
   fully supported, and others that are either partially supported or not
   supported at all.  Such an entity would be classed as fully supported
   because to get at the fully supported data we need to download the whole
   message.  ie. the highest level of support takes priority.

   Inputs
   message_class:    message class
   nf_message_class: netfax message class

   Returns
   not supported at all: EmailSupport_None
   partially supported : EmailSupport_Partial
   fully supported:      EmaiLSupport_Full
 */

extern int emailrx_check_supported (const NFE_msg_class     message_class,
                                    const NFE_NF_msg_class  nf_message_class)
{
    int  support = EmailSupport_None;

    switch (message_class)
    {
        case NFE_MC_NETFAX_DATA:
            /* For the moment all the tests below are kept separate so that
             * it is easier to change support for an individual class of data
             * at a later stage.
             */

            if (nf_message_class & NFE_NFMC_RTEXT)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_FAX)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_CONFIG)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_ADDRBK)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_REPORT)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_LOG)
                support = EmailSupport_Full;

            if (nf_message_class & NFE_NFMC_DELIVERYREPORT)
                support = EmailSupport_Full;

            break;

        case NFE_MC_SMTP_DELIVERY_ERROR:
            support = EmailSupport_Partial;
            break;

        case NFE_MC_UNKNOWN:
            support = EmailSupport_Partial;
            break;

        default:
            support = EmailSupport_None;
            break;
    }

    return support;
}





/* -----------------------------------------------------------------------------
   emailrx_construct_full_address

   Combine a real name and email address into a single 0 terminated string of
   the form:
   Real Name <email address>

   eg. for me this would be:
   Ben Laughton <blaughton@acorn.com>

   Inputs
   address:  pointer to NFE_address structure holding real name and email
             address
   gs_trans: flag indicating whether generated string needs to be sutiable for
             gs_trans (ie. escapes '<')

   Returns
   success: pointer to malloc'd from string (client must free)
   failure: NULL
 */

extern char *emailrx_construct_full_address (const NFE_address *const  address,
                                             const int                 gs_trans)
{
    char *  full_address;
    size_t  full_address_len = 1;    // start at 1 to allow for 0 terminator


    // Calculate exact length of string needed to store the 'from' field
    if (address->real_name)
    {
        full_address_len += strlen (address->real_name);

        if (address->address)
        {
            // allow for space character between real name and address
            full_address_len += 1;
        }
    }

    if (address->address)
    {
        full_address_len += strlen (address->address);

        // allow for angle brackets around address as well
        full_address_len += 2;
        if (gs_trans)
            full_address_len++;
    }


    // Allocate memory to store the 'from' field.  It is the caller's
    // responsibility to free this.
    full_address = malloc (full_address_len);
    if (full_address == NULL)
        return NULL;


    // Construct the from field
    full_address[0] = '\0';
    if (address->real_name)
    {
        strcat (full_address,
                address->real_name);

        if (address->address)
        {
            strcat (full_address,
                    " ");
        }
    }

    if (address->address)
    {
        if (gs_trans)
        {
            strcat (full_address,
                    "|<");
        }
        else
        {
            strcat (full_address,
                    "<");
        }

        strcat (full_address,
                address->address);

        strcat (full_address,
                ">");
    }

    return full_address;
}




/* -----------------------------------------------------------------------------
   emailrx_generate_report_from_message

   Generate a report from a message token and up to four parameters.

   Inputs
   message_token: token in message file
   param0:        1st parameter (%0 for MessageTrans)
   param1:        2nd parameter (%1 for MessageTrans)
   param2:        3rd parameter (%2 for MessageTrans)
   param3:        4th parameter (%3 for MessageTrans)

   Returns
   success: pointer to report - client's responsibility to free
   failure: NULL
 */

extern char *emailrx_generate_report_from_message (char *  message_token,
                                                   char *  param0,
                                                   char *  param1,
                                                   char *  param2,
                                                   char *  param3)
{
    char *  report;
    size_t  report_size;


    /* Work out roughly how much space will be needed to store the report.
     * The estimate will be slightly over what's needed because the parameter
     * substitution characters in the message are not discounted.
     */

    if (_swix (MessageTrans_GSLookup,
               _INR (0, 2) | _OUT (3),

               report_templates,
               message_token,
               NULL,    /* return read-only string, no substitution */

               &report_size))
    {
        return NULL;
    }

    if (param0)
    {
        report_size += strlen (param0);
    }
    if (param1)
    {
        report_size += strlen (param1);
    }
    if (param2)
    {
        report_size += strlen (param2);
    }
    if (param3)
    {
        report_size += strlen (param3);
    }
    report_size += 1;    /* 0 terminator */

    report = malloc (report_size);
    if (report == NULL)
    {
        return NULL;
    }

    if (_swix (MessageTrans_GSLookup,
               _INR (0, 7),

               report_templates,
               message_token,
               report,
               report_size,
               param0,
               param1,
               param2,
               param3))
    {
        free (report);
        return NULL;
    }

    return report;
}




/* -----------------------------------------------------------------------------
   emailrx_message_downloaded

   Mark a message as downloaded.

   Inputs
   message:        pointer to message

   Outputs
 */

extern void  emailrx_message_downloaded (message_t *const     message)
{
    message->flags.bits.downloaded = 1;
    message->flags.bits.download   = 0;
}




/* -----------------------------------------------------------------------------
   emailrx_message_printed

   Mark a message as printed.

   Inputs
   message: pointer to message
 */

extern void  emailrx_message_printed (message_t *const  message)
{
    message->flags.bits.printing     = 0;
    message->flags.bits.printed      = 1;
    message->flags.bits.just_printed = 1;
}




/* -----------------------------------------------------------------------------
   emailrx_tidy

   Tidy the document list: clears temporary flags and deletes
   completed documents from the list (NB. not from the server).
 */

extern void  emailrx_tidy (void)
{
    document_t *     document;
    list_iterator_t  i;


    list_initialise_iterator (&i,
                              document_list);

    for (document = (document_t *) M_list_reset (i);
         !M_list_finished (i);
         document = (document_t *) M_list_next (i))
    {
        document->tidy ();
    }
}




/* -----------------------------------------------------------------------------
   emailrx_document_requires_printing

   Decide whether any printing needs to be done for a document at this moment.

   Returns:
   0: no printing required
   1: printing required
 */

extern int  emailrx_document_requires_printing (document_handle  document)
{
    return (int) ((document_t *) document)->requires_printing ();
}




/* -----------------------------------------------------------------------------
   emailrx_is_document_new

   Determine whether this document is new.

   Returns:
   0: document is old
   1: document is new
 */

extern int  emailrx_is_document_new (document_handle  document)
{
    return (int) ((document_t *) document)->is_new ();
}




/* -----------------------------------------------------------------------------
   emailrx_get_number_messages

   Get the number of messages in a document whose flags are in a specified
   state.

   Inputs
   document:    document handle
   flags_mask:  mask to apply to flags before checking in they match
   flags_match: flags to match

   Returns
   number of messages
 */

extern int  emailrx_get_number_messages (document_handle     document,
                                         const unsigned int  flags_mask,
                                         const unsigned int  flags_match)
{
    return ((document_t *) document)->get_number_messages (flags_mask,
                                                           flags_match);
}




}    // end of C interface functions




/* -----------------------------------------------------------------------------
   create_doc

   Create a new document of the appropriate type according to the message
   class and netfax message class.

   Inputs
   header: header structure
   id:     unique id to use for document

   Returns
   success: pointer to document object
   failure: NULL
 */

static document_t *create_doc (const NFE_header &  header,
                               const char *const   id)
{
    bool          success;
    document_t *  document;


    switch (header.msg_class)
    {
        case NFE_MC_NETFAX_DATA:
            if (header.netfax_msg_class & NFE_NFMC_FAX)
            {
                document = new netfax_fax_document_t (header,
                                                      NULL,
                                                      success);
            }
            else
            {
                document = new netfax_document_t (header,
                                                  id,
                                                  success);
            }
            break;

        default:
            document = new document_t (header,
                                       id,
                                       success);
            break;
    }

    if (!success)
    {
        delete document;
        document = NULL;
    }

    return document;
}




/* -----------------------------------------------------------------------------
   match_message

   Message matching routine for document list searching.

   Inputs
   data1: pointer to current message in list
   data2: pointer to UID of message being searched for

   Returns
   1: match
   0: no match
 */

static int match_message (const void *const  data1,
                          const void *const  data2)
{
    const message_t &  message   = *((message_t *const) data1);
    const char *const  unique_id = (const char *const)  data2;


    if (strcmp (message.unique_id,
                unique_id) == 0)
    {
        return 1;
    }

    return 0;
}




/* -----------------------------------------------------------------------------
   compare_page_nums

   Page number comparison routine for inserting a message into a list of
   messages ordered by page number.

   Inputs
   data1: pointer to message information
   data2: pointer to message information

   Returns
   -1: message1 comes before message2
    1: message1 comes after message2
 */

static int compare_page_nums (const void *const  data1,
                              const void *const  data2)
{
    const message_t *const  message1 = (message_t *const) data1;
    const message_t *const  message2 = (message_t *const) data2;


    if (message1->nf_message_id.first_page_num <
            message2->nf_message_id.first_page_num)
    {
        return -1;
    }
    else if (message1->nf_message_id.first_page_num >
                 message2->nf_message_id.first_page_num)
    {
       return 1;
    }
    else
    {
        /* Is it even possible to get two messages in the same document with
         * the same start page number?  If it is then consider the end page
         * number.
         */

        if (message1->nf_message_id.last_page_num <
                message2->nf_message_id.last_page_num)
        {
            return -1;
        }
        else if (message1->nf_message_id.last_page_num >
                     message2->nf_message_id.last_page_num)
        {
           return 1;
        }
        else
        {
            /* The last page numbers are the same as well!!  For the sake of
             * argument say that message1 should come before message2.
             */

            return -1;
        }
    }
}




/* -----------------------------------------------------------------------------
   free_document

   Deallocate storage for a document when a document is removed
   from a list of documents.

   Inputs:
   document: pointer to document
 */

static void free_document (void *  document)
{
    delete document;
}




/* -----------------------------------------------------------------------------
   free_message

   Deallocate storage for message information when a message is removed
   from a list of messages.

   Inputs
   message_info: pointer to message information
 */

static void free_message (void *  message)
{
    free (message);
}




/* -----------------------------------------------------------------------------
   truncate_doc_list

   Remove approximately 2/3 of the document list.  Used as an emergency
   measure if we run out of memory to try to recover and still do something
   useful.  Junking 2/3 of the document list should leave enough space for
   the corresponding download list plus a bit extra for good measure.

   Returns
   failure: -1 (not able to recover any memory)
   success: number messages in truncated document list
 */

static int truncate_doc_list (void)
{
    int              message_count = 0;
    int              one_third_number_messages;
    list_iterator_t  document_iterator;
    document_t *     document;

    /* Iterate over the document list to find the total number of messages */
    list_initialise_iterator (&document_iterator,
                              document_list);

    document = (document_t *) (document_iterator.reset) (&document_iterator);

    while (!(document_iterator.finished) (&document_iterator))
    {
        message_count += document->get_number_messages (0,
                                                        0);

        document = (document_t *) (document_iterator.next) (&document_iterator);
    }

    /* Work out approximate 1/3 of total number messages */
    one_third_number_messages = message_count / 3;
    if (one_third_number_messages == 0)
        return -1;

    /* Iterate over the document list again to find the cut-off point.  Cut off
     * whole documents, not just bits.
     */
    message_count = 0;
    document = (document_t *) (document_iterator.reset) (&document_iterator);

    while (!(document_iterator.finished) (&document_iterator))
    {
        message_count += document->get_number_messages (0,
                                                        0);
        if (message_count > one_third_number_messages)
            break;

        document = (document_t *) (document_iterator.next) (&document_iterator);
    }

    /* Remove all documents from the cut-off point to the end of the list */
    while (!(document_iterator.finished) (&document_iterator))
    {
        document->remove_from_list (document_list);
        document = (document_t *) (document_iterator.next) (&document_iterator);
    }

    return one_third_number_messages;
}




/* -----------------------------------------------------------------------------
   add_message_common

   Common code used when adding a new message to a document regardless of the
   type of document.

   Inputs
   size:          size of message
   unique_id:     POP3 unique id of message, as returned by UIDL command
   nf_message_id: netfax message id of message

   Returns
   success: pointer to message structure
   failure: NULL
 */

static message_t *  add_message_common (const unsigned int  size,
                                        const char *const   unique_id)
{
    /* Create new message information structure */
    message_t *  message = (message_t *) malloc (sizeof (message_t));
    if (message == NULL)
    {
        return NULL;
    }

    message->size                  = size;
    message->decoded_size_estimate = size;

    message->unique_id = malloc (strlen (unique_id) + 1);
    if (message->unique_id == NULL)
    {
        free (message);
        return NULL;
    }
    strcpy (message->unique_id, unique_id);
    message->flags.value = 0;

    return message;
}




#ifdef TEST
void document_t::dump_to_file (FILE *const  file)
{
    fprintf (file, "========================================\n");
    fprintf (file, "Message class: %u\n", message_class);
}

void netfax_document_t::dump_to_file (FILE *const  file)
{
    document_t::dump_to_file (file);

    fprintf (file, "Document number: %u\n", document_id.document_number);
    fprintf (file, "Netfax messsage class: %x\n", netfax_message_class);
}

void netfax_fax_document_t::dump_to_file (FILE *const  file)
{
    netfax_document_t::dump_to_file (file);

    fprintf (file, "Split download: %s\n",
             nf_fax_flags.split_download ? "Yes" : "No");

    fprintf (file, "Connection count: %u\n", connection_count);
    fprintf (file, "Total number pages: %u\n", total_number_pages);
    fprintf (file, "Number pages seen: %u\n", get_number_pages (0, 0));
    fprintf (file, "Exact number pages: %s\n",
             nf_fax_flags.exact_number_pages ? "Yes" : "No");

    fprintf (file, "Pages seen:");
#if 0
    for (int i = 0; i < total_number_pages; ++i)
    {
        if (page_seen[i] == PageState_Seen)
        {
            fprintf (file, " %d", i + 1);
        }
    }
#endif

    fprintf (file, "\n\n");
}

void document_t::dump_message_list_to_file (FILE *const  file)
{
    list_iterator_t iter;
    message_t *message;

    list_initialise_iterator (&iter,
                              message_list);

    for (message = (message_t *) (iter.reset) (&iter);
         !(iter.finished) (&iter);
         message = (message_t *) (iter.next) (&iter))
    {
         fprintf (file, "----------------------------------------\n");
         fprintf (file, "Message size: %u\n", message->size);
         fprintf (file, "Unique id: %s\n", message->unique_id);
         fprintf (file, "Pages: %d - %d\n",
                  message->nf_message_id.first_page_num,
                  message->nf_message_id.last_page_num);
         fprintf (file, "\n");
    }
}

extern "C" void  emailrx_dump_doc_list_to_file (const list_handle  list,
                                                const char *const  filename)
{
    FILE *           file;
    list_iterator_t  iter;
    document_t *     document;


    file = fopen (filename, "a+");
    if (file == NULL)
    {
        return;
    }

    list_initialise_iterator (&iter,
                              list);

    fprintf (file, "########################################\n");
    for (document = (document_t *) (iter.reset) (&iter);
         !(iter.finished) (&iter);
         document = (document_t *) (iter.next) (&iter))
    {
        document->dump_to_file (file);
        document->dump_message_list_to_file (file);
    }

    fclose (file);
}

#endif
